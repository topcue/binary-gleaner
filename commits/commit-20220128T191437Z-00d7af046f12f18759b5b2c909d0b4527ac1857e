{
  "sha": "00d7af046f12f18759b5b2c909d0b4527ac1857e",
  "node_id": "C_kwDOANOeidoAKDAwZDdhZjA0NmYxMmYxODc1OWI1YjJjOTA5ZDBiNDUyN2FjMTg1N2U",
  "commit": {
    "author": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-01-28T19:14:37Z"
    },
    "committer": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-01-28T19:14:37Z"
    },
    "message": "FreeBSD x86 nat: Use register maps for GP register sets.\n\nRather than using the x86-specific register offset tables, use\nregister maps to describe the layout of the general purpose registers\nfetched via PT_GETREGS.  The sole user-visible difference is that\nFreeBSD/amd64 will now report additional segment registers ($ds, $es,\n$fs, and $gs) for both 32-bit and 64-bit processes.\n\nAs part of these changes, the FreeBSD x86 native targets no longer use\namd64-bsd-nat.c or i386-bsd-nat.c.  Remove FreeBSD-specific register\nhandling (for $fs_base, $gs_base, and XSAVE state) from these files.\nSimilarly, remove the global x86bsd_xsave_len from x86-bsd-nat.c.  The\nFreeBSD x86 native targets use a static xsave_len instead.\n\nWhile here, rework the probing of PT_GETXMMREGS on FreeBSD/i386.\nProbe the ptrace op once in the target read_description method and\ncache the result for the future similar to the way the status of XSAVE\nsupport is probed in the read_description method.  In addition, return\nthe proper xcr0 mask (X87-only) for old kernels or systems without\neither XSAVE or XMM support.",
    "tree": {
      "sha": "d33e822e40937118700c31faf3a40c527664c7e0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d33e822e40937118700c31faf3a40c527664c7e0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/00d7af046f12f18759b5b2c909d0b4527ac1857e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/00d7af046f12f18759b5b2c909d0b4527ac1857e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/00d7af046f12f18759b5b2c909d0b4527ac1857e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/00d7af046f12f18759b5b2c909d0b4527ac1857e/comments",
  "author": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b95a31ed5d2b34f1a4072d701f5cd51075e61c01",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b95a31ed5d2b34f1a4072d701f5cd51075e61c01",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b95a31ed5d2b34f1a4072d701f5cd51075e61c01"
    }
  ],
  "stats": {
    "total": 720,
    "additions": 457,
    "deletions": 263
  },
  "files": [
    {
      "sha": "77dc4c935ca1310d1349365cc2aea1970c589338",
      "filename": "gdb/amd64-bsd-nat.c",
      "status": "modified",
      "additions": 0,
      "deletions": 96,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/amd64-bsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/amd64-bsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-bsd-nat.c?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -59,9 +59,6 @@ amd64bsd_fetch_inferior_registers (struct regcache *regcache, int regnum)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n   ptid_t ptid = regcache->ptid ();\n-#if defined(PT_GETFSBASE) || defined(PT_GETGSBASE)\n-  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n-#endif\n \n   if (regnum == -1 || amd64_native_gregset_supplies_p (gdbarch, regnum))\n     {\n@@ -75,50 +72,9 @@ amd64bsd_fetch_inferior_registers (struct regcache *regcache, int regnum)\n \treturn;\n     }\n \n-#ifdef PT_GETFSBASE\n-  if (regnum == -1 || regnum == tdep->fsbase_regnum)\n-    {\n-      register_t base;\n-\n-      if (gdb_ptrace (PT_GETFSBASE, ptid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n-\tperror_with_name (_(\"Couldn't get segment register fs_base\"));\n-\n-      regcache->raw_supply (tdep->fsbase_regnum, &base);\n-      if (regnum != -1)\n-\treturn;\n-    }\n-#endif\n-#ifdef PT_GETGSBASE\n-  if (regnum == -1 || regnum == tdep->fsbase_regnum + 1)\n-    {\n-      register_t base;\n-\n-      if (gdb_ptrace (PT_GETGSBASE, ptid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n-\tperror_with_name (_(\"Couldn't get segment register gs_base\"));\n-\n-      regcache->raw_supply (tdep->fsbase_regnum + 1, &base);\n-      if (regnum != -1)\n-\treturn;\n-    }\n-#endif\n-\n   if (regnum == -1 || !amd64_native_gregset_supplies_p (gdbarch, regnum))\n     {\n       struct fpreg fpregs;\n-#ifdef PT_GETXSTATE_INFO\n-      void *xstateregs;\n-\n-      if (x86bsd_xsave_len != 0)\n-\t{\n-\t  xstateregs = alloca (x86bsd_xsave_len);\n-\t  if (gdb_ptrace (PT_GETXSTATE, ptid, (PTRACE_TYPE_ARG3) xstateregs, 0)\n-\t      == -1)\n-\t    perror_with_name (_(\"Couldn't get extended state status\"));\n-\n-\t  amd64_supply_xsave (regcache, -1, xstateregs);\n-\t  return;\n-\t}\n-#endif\n \n       if (gdb_ptrace (PT_GETFPREGS, ptid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n \tperror_with_name (_(\"Couldn't get floating point status\"));\n@@ -135,9 +91,6 @@ amd64bsd_store_inferior_registers (struct regcache *regcache, int regnum)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n   ptid_t ptid = regcache->ptid ();\n-#if defined(PT_SETFSBASE) || defined(PT_SETGSBASE)\n-  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n-#endif\n \n   if (regnum == -1 || amd64_native_gregset_supplies_p (gdbarch, regnum))\n     {\n@@ -155,58 +108,9 @@ amd64bsd_store_inferior_registers (struct regcache *regcache, int regnum)\n \treturn;\n     }\n \n-#ifdef PT_SETFSBASE\n-  if (regnum == -1 || regnum == tdep->fsbase_regnum)\n-    {\n-      register_t base;\n-\n-      /* Clear the full base value to support 32-bit targets.  */\n-      base = 0;\n-      regcache->raw_collect (tdep->fsbase_regnum, &base);\n-\n-      if (gdb_ptrace (PT_SETFSBASE, ptid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n-\tperror_with_name (_(\"Couldn't write segment register fs_base\"));\n-      if (regnum != -1)\n-\treturn;\n-    }\n-#endif\n-#ifdef PT_SETGSBASE\n-  if (regnum == -1 || regnum == tdep->fsbase_regnum + 1)\n-    {\n-      register_t base;\n-\n-      /* Clear the full base value to support 32-bit targets.  */\n-      base = 0;\n-      regcache->raw_collect (tdep->fsbase_regnum + 1, &base);\n-\n-      if (gdb_ptrace (PT_SETGSBASE, ptid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n-\tperror_with_name (_(\"Couldn't write segment register gs_base\"));\n-      if (regnum != -1)\n-\treturn;\n-    }\n-#endif\n-\n   if (regnum == -1 || !amd64_native_gregset_supplies_p (gdbarch, regnum))\n     {\n       struct fpreg fpregs;\n-#ifdef PT_GETXSTATE_INFO\n-      void *xstateregs;\n-\n-      if (x86bsd_xsave_len != 0)\n-\t{\n-\t  xstateregs = alloca (x86bsd_xsave_len);\n-\t  if (gdb_ptrace (PT_GETXSTATE, ptid, (PTRACE_TYPE_ARG3) xstateregs, 0)\n-\t      == -1)\n-\t    perror_with_name (_(\"Couldn't get extended state status\"));\n-\n-\t  amd64_collect_xsave (regcache, regnum, xstateregs, 0);\n-\n-\t  if (gdb_ptrace (PT_SETXSTATE, ptid, (PTRACE_TYPE_ARG3) xstateregs,\n-\t\t\t  x86bsd_xsave_len) == -1)\n-\t    perror_with_name (_(\"Couldn't write extended state status\"));\n-\t  return;\n-\t}\n-#endif\n \n       if (gdb_ptrace (PT_GETFPREGS, ptid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n \tperror_with_name (_(\"Couldn't get floating point status\"));"
    },
    {
      "sha": "98a1af03a66012812991a1ba3f76b26c8ea8e747",
      "filename": "gdb/amd64-fbsd-nat.c",
      "status": "modified",
      "additions": 203,
      "deletions": 57,
      "changes": 260,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/amd64-fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/amd64-fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-fbsd-nat.c?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -31,17 +31,19 @@\n \n #include \"fbsd-nat.h\"\n #include \"amd64-tdep.h\"\n+#include \"amd64-fbsd-tdep.h\"\n #include \"amd64-nat.h\"\n-#include \"amd64-bsd-nat.h\"\n #include \"x86-nat.h\"\n #include \"gdbsupport/x86-xstate.h\"\n-\f\n+#include \"x86-bsd-nat.h\"\n \n class amd64_fbsd_nat_target final\n-  : public amd64_bsd_nat_target<fbsd_nat_target>\n+  : public x86bsd_nat_target<fbsd_nat_target>\n {\n public:\n-  /* Add some extra features to the common *BSD/amd64 target.  */\n+  void fetch_registers (struct regcache *, int) override;\n+  void store_registers (struct regcache *, int) override;\n+\n   const struct target_desc *read_description () override;\n \n #if defined(HAVE_PT_GETDBREGS) && defined(USE_SIGTRAP_SIGINFO)\n@@ -51,61 +53,208 @@ class amd64_fbsd_nat_target final\n \n static amd64_fbsd_nat_target the_amd64_fbsd_nat_target;\n \n-/* Offset in `struct reg' where MEMBER is stored.  */\n-#define REG_OFFSET(member) offsetof (struct reg, member)\n+#ifdef PT_GETXSTATE_INFO\n+static size_t xsave_len;\n+#endif\n+\n+/* This is a layout of the amd64 'struct reg' but with i386\n+   registers.  */\n \n-/* At amd64fbsd64_r_reg_offset[REGNUM] you'll find the offset in\n-   `struct reg' location where the GDB register REGNUM is stored.\n-   Unsupported registers are marked with `-1'.  */\n-static int amd64fbsd64_r_reg_offset[] =\n+static const struct regcache_map_entry amd64_fbsd32_gregmap[] =\n {\n-  REG_OFFSET (r_rax),\n-  REG_OFFSET (r_rbx),\n-  REG_OFFSET (r_rcx),\n-  REG_OFFSET (r_rdx),\n-  REG_OFFSET (r_rsi),\n-  REG_OFFSET (r_rdi),\n-  REG_OFFSET (r_rbp),\n-  REG_OFFSET (r_rsp),\n-  REG_OFFSET (r_r8),\n-  REG_OFFSET (r_r9),\n-  REG_OFFSET (r_r10),\n-  REG_OFFSET (r_r11),\n-  REG_OFFSET (r_r12),\n-  REG_OFFSET (r_r13),\n-  REG_OFFSET (r_r14),\n-  REG_OFFSET (r_r15),\n-  REG_OFFSET (r_rip),\n-  REG_OFFSET (r_rflags),\n-  REG_OFFSET (r_cs),\n-  REG_OFFSET (r_ss),\n-  -1,\n-  -1,\n-  -1,\n-  -1\n+  { 8, REGCACHE_MAP_SKIP, 8 },\n+  { 1, I386_EDI_REGNUM, 8 },\n+  { 1, I386_ESI_REGNUM, 8 },\n+  { 1, I386_EBP_REGNUM, 8 },\n+  { 1, I386_EBX_REGNUM, 8 },\n+  { 1, I386_EDX_REGNUM, 8 },\n+  { 1, I386_ECX_REGNUM, 8 },\n+  { 1, I386_EAX_REGNUM, 8 },\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* trapno */\n+  { 1, I386_FS_REGNUM, 2 },\n+  { 1, I386_GS_REGNUM, 2 },\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* err */\n+  { 1, I386_ES_REGNUM, 2 },\n+  { 1, I386_DS_REGNUM, 2 },\n+  { 1, I386_EIP_REGNUM, 8 },\n+  { 1, I386_CS_REGNUM, 8 },\n+  { 1, I386_EFLAGS_REGNUM, 8 },\n+  { 1, I386_ESP_REGNUM, 0 },\n+  { 1, I386_SS_REGNUM, 8 },\n+  { 0 }\n };\n-\f\n \n-/* Mapping between the general-purpose registers in FreeBSD/amd64\n-   `struct reg' format and GDB's register cache layout for\n-   FreeBSD/i386.\n+static const struct regset amd64_fbsd32_gregset =\n+{\n+  amd64_fbsd32_gregmap, regcache_supply_regset, regcache_collect_regset\n+};\n \n-   Note that most FreeBSD/amd64 registers are 64-bit, while the\n-   FreeBSD/i386 registers are all 32-bit, but since we're\n-   little-endian we get away with that.  */\n+/* Return the regset to use for 'struct reg' for the GDBARCH.  */\n \n-/* From <machine/reg.h>.  */\n-static int amd64fbsd32_r_reg_offset[I386_NUM_GREGS] =\n+static const struct regset *\n+find_gregset (struct gdbarch *gdbarch)\n {\n-  14 * 8, 13 * 8,\t\t/* %eax, %ecx */\n-  12 * 8, 11 * 8,\t\t/* %edx, %ebx */\n-  20 * 8, 10 * 8,\t\t/* %esp, %ebp */\n-  9 * 8, 8 * 8,\t\t\t/* %esi, %edi */\n-  17 * 8, 19 * 8,\t\t/* %eip, %eflags */\n-  18 * 8, 21 * 8,\t\t/* %cs, %ss */\n-  -1, -1, -1, -1\t\t/* %ds, %es, %fs, %gs */\n-};\n-\f\n+  if (gdbarch_bfd_arch_info (gdbarch)->bits_per_word == 32)\n+    return &amd64_fbsd32_gregset;\n+  else\n+    return &amd64_fbsd_gregset;\n+}\n+\n+/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this\n+   for all registers.  */\n+\n+void\n+amd64_fbsd_nat_target::fetch_registers (struct regcache *regcache, int regnum)\n+{\n+  struct gdbarch *gdbarch = regcache->arch ();\n+#if defined(PT_GETFSBASE) || defined(PT_GETGSBASE)\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+#endif\n+  pid_t pid = get_ptrace_pid (regcache->ptid ());\n+  const struct regset *gregset = find_gregset (gdbarch);\n+\n+  if (fetch_register_set<struct reg> (regcache, regnum, PT_GETREGS, gregset))\n+    {\n+      if (regnum != -1)\n+\treturn;\n+    }\n+\n+#ifdef PT_GETFSBASE\n+  if (regnum == -1 || regnum == tdep->fsbase_regnum)\n+    {\n+      register_t base;\n+\n+      if (ptrace (PT_GETFSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get segment register fs_base\"));\n+\n+      regcache->raw_supply (tdep->fsbase_regnum, &base);\n+      if (regnum != -1)\n+\treturn;\n+    }\n+#endif\n+#ifdef PT_GETGSBASE\n+  if (regnum == -1 || regnum == tdep->fsbase_regnum + 1)\n+    {\n+      register_t base;\n+\n+      if (ptrace (PT_GETGSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get segment register gs_base\"));\n+\n+      regcache->raw_supply (tdep->fsbase_regnum + 1, &base);\n+      if (regnum != -1)\n+\treturn;\n+    }\n+#endif\n+\n+  /* There is no amd64_fxsave_supplies or amd64_xsave_supplies.\n+     Instead, the earlier register sets return early if the request\n+     was for a specific register that was already satisified to avoid\n+     fetching the FPU/XSAVE state unnecessarily.  */\n+\n+#ifdef PT_GETXSTATE_INFO\n+  if (xsave_len != 0)\n+    {\n+      void *xstateregs = alloca (xsave_len);\n+\n+      if (ptrace (PT_GETXSTATE, pid, (PTRACE_TYPE_ARG3) xstateregs, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get extended state status\"));\n+\n+      amd64_supply_xsave (regcache, regnum, xstateregs);\n+      return;\n+    }\n+#endif\n+\n+  struct fpreg fpregs;\n+\n+  if (ptrace (PT_GETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n+    perror_with_name (_(\"Couldn't get floating point status\"));\n+\n+  amd64_supply_fxsave (regcache, regnum, &fpregs);\n+}\n+\n+/* Store register REGNUM back into the inferior.  If REGNUM is -1, do\n+   this for all registers.  */\n+\n+void\n+amd64_fbsd_nat_target::store_registers (struct regcache *regcache, int regnum)\n+{\n+  struct gdbarch *gdbarch = regcache->arch ();\n+#if defined(PT_GETFSBASE) || defined(PT_GETGSBASE)\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+#endif\n+  pid_t pid = get_ptrace_pid (regcache->ptid ());\n+  const struct regset *gregset = find_gregset (gdbarch);\n+\n+  if (store_register_set<struct reg> (regcache, regnum, PT_GETREGS, PT_SETREGS,\n+\t\t\t\t      gregset))\n+    {\n+      if (regnum != -1)\n+\treturn;\n+    }\n+\n+#ifdef PT_SETFSBASE\n+  if (regnum == -1 || regnum == tdep->fsbase_regnum)\n+    {\n+      register_t base;\n+\n+      /* Clear the full base value to support 32-bit targets.  */\n+      base = 0;\n+      regcache->raw_collect (tdep->fsbase_regnum, &base);\n+\n+      if (ptrace (PT_SETFSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n+\tperror_with_name (_(\"Couldn't write segment register fs_base\"));\n+      if (regnum != -1)\n+\treturn;\n+    }\n+#endif\n+#ifdef PT_SETGSBASE\n+  if (regnum == -1 || regnum == tdep->fsbase_regnum + 1)\n+    {\n+      register_t base;\n+\n+      /* Clear the full base value to support 32-bit targets.  */\n+      base = 0;\n+      regcache->raw_collect (tdep->fsbase_regnum + 1, &base);\n+\n+      if (ptrace (PT_SETGSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n+\tperror_with_name (_(\"Couldn't write segment register gs_base\"));\n+      if (regnum != -1)\n+\treturn;\n+    }\n+#endif\n+\n+  /* There is no amd64_fxsave_supplies or amd64_xsave_supplies.\n+     Instead, the earlier register sets return early if the request\n+     was for a specific register that was already satisified to avoid\n+     fetching the FPU/XSAVE state unnecessarily.  */\n+\n+#ifdef PT_GETXSTATE_INFO\n+  if (xsave_len != 0)\n+    {\n+      void *xstateregs = alloca (xsave_len);\n+\n+      if (ptrace (PT_GETXSTATE, pid, (PTRACE_TYPE_ARG3) xstateregs, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get extended state status\"));\n+\n+      amd64_collect_xsave (regcache, regnum, xstateregs, 0);\n+\n+      if (ptrace (PT_SETXSTATE, pid, (PTRACE_TYPE_ARG3) xstateregs,\n+\t\t  xsave_len) == -1)\n+\tperror_with_name (_(\"Couldn't write extended state status\"));\n+      return;\n+    }\n+#endif\n+\n+  struct fpreg fpregs;\n+\n+  if (ptrace (PT_GETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n+    perror_with_name (_(\"Couldn't get floating point status\"));\n+\n+  amd64_collect_fxsave (regcache, regnum, &fpregs);\n+\n+  if (ptrace (PT_SETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n+    perror_with_name (_(\"Couldn't write floating point status\"));\n+}\n \n /* Support for debugging kernel virtual memory images.  */\n \n@@ -179,13 +328,13 @@ amd64_fbsd_nat_target::read_description ()\n       if (ptrace (PT_GETXSTATE_INFO, inferior_ptid.pid (),\n \t\t  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)\n \t{\n-\t  x86bsd_xsave_len = info.xsave_len;\n+\t  xsave_len = info.xsave_len;\n \t  xcr0 = info.xsave_mask;\n \t}\n       xsave_probed = 1;\n     }\n \n-  if (x86bsd_xsave_len != 0)\n+  if (xsave_len != 0)\n     {\n       if (is64)\n \treturn amd64_target_description (xcr0, true);\n@@ -213,9 +362,6 @@ void _initialize_amd64fbsd_nat ();\n void\n _initialize_amd64fbsd_nat ()\n {\n-  amd64_native_gregset32_reg_offset = amd64fbsd32_r_reg_offset;\n-  amd64_native_gregset64_reg_offset = amd64fbsd64_r_reg_offset;\n-\n   add_inf_child_target (&the_amd64_fbsd_nat_target);\n \n   /* Support debugging kernel virtual memory images.  */"
    },
    {
      "sha": "f87c976dd613872f94aee64cd0d2f270c9fb0d0f",
      "filename": "gdb/amd64-fbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/amd64-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/amd64-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-fbsd-tdep.c?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -27,6 +27,7 @@\n #include \"gdbsupport/x86-xstate.h\"\n \n #include \"amd64-tdep.h\"\n+#include \"amd64-fbsd-tdep.h\"\n #include \"fbsd-tdep.h\"\n #include \"solib-svr4.h\"\n #include \"inferior.h\""
    },
    {
      "sha": "0a18dbcbfd741952f17340f3cbad401a1230c46b",
      "filename": "gdb/amd64-fbsd-tdep.h",
      "status": "added",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/amd64-fbsd-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/amd64-fbsd-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-fbsd-tdep.h?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -0,0 +1,27 @@\n+/* FreeBSD/amd64 target support, prototypes.\n+\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef AMD64_FBSD_TDEP_H\n+#define AMD64_FBSD_TDEP_H\n+\n+#include \"regset.h\"\n+\n+extern const struct regset amd64_fbsd_gregset;\n+\n+#endif /* AMD64_FBSD_TDEP_H */"
    },
    {
      "sha": "20ce8050a9692e87678863d7eba900f35d2b8eae",
      "filename": "gdb/configure.nat",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/configure.nat",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/configure.nat",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.nat?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -165,7 +165,7 @@ case ${gdb_host} in\n \t    i386)\n \t\t# Host: FreeBSD/i386\n \t\tNATDEPFILES=\"${NATDEPFILES} x86-nat.o nat/x86-dregs.o \\\n-\t\tx86-bsd-nat.o i386-bsd-nat.o i386-fbsd-nat.o bsd-kvm.o\"\n+\t\tx86-bsd-nat.o i386-fbsd-nat.o bsd-kvm.o\"\n \t\t;;\n \t    mips)\n \t\t# Host: FreeBSD/mips\n@@ -192,7 +192,7 @@ case ${gdb_host} in\n \tcase ${gdb_host_cpu} in\n \t    i386)\n \t\t# Host: FreeBSD/amd64\n-\t\tNATDEPFILES=\"${NATDEPFILES} amd64-nat.o amd64-bsd-nat.o \\\n+\t\tNATDEPFILES=\"${NATDEPFILES} amd64-nat.o \\\n \t\tamd64-fbsd-nat.o bsd-kvm.o x86-nat.o nat/x86-dregs.o \\\n \t\tx86-bsd-nat.o\"\n \t\t;;"
    },
    {
      "sha": "bd9655c9ef99f7214f4cd2c2e421e2a29a9efbb4",
      "filename": "gdb/i386-bsd-nat.c",
      "status": "modified",
      "additions": 0,
      "deletions": 92,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/i386-bsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/i386-bsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-bsd-nat.c?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -159,56 +159,12 @@ i386bsd_fetch_inferior_registers (struct regcache *regcache, int regnum)\n \treturn;\n     }\n \n-#ifdef PT_GETFSBASE\n-  if (regnum == -1 || regnum == I386_FSBASE_REGNUM)\n-    {\n-      register_t base;\n-\n-      if (gdb_ptrace (PT_GETFSBASE, ptid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n-\tperror_with_name (_(\"Couldn't get segment register fs_base\"));\n-\n-      regcache->raw_supply (I386_FSBASE_REGNUM, &base);\n-      if (regnum != -1)\n-\treturn;\n-    }\n-#endif\n-#ifdef PT_GETGSBASE\n-  if (regnum == -1 || regnum == I386_GSBASE_REGNUM)\n-    {\n-      register_t base;\n-\n-      if (gdb_ptrace (PT_GETGSBASE, ptid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n-\tperror_with_name (_(\"Couldn't get segment register gs_base\"));\n-\n-      regcache->raw_supply (I386_GSBASE_REGNUM, &base);\n-      if (regnum != -1)\n-\treturn;\n-    }\n-#endif\n-\n   if (regnum == -1 || regnum >= I386_ST0_REGNUM)\n     {\n       struct fpreg fpregs;\n #ifdef HAVE_PT_GETXMMREGS\n       char xmmregs[512];\n-#endif\n-\n-#ifdef PT_GETXSTATE_INFO\n-      if (x86bsd_xsave_len != 0)\n-\t{\n-\t  void *xstateregs;\n \n-\t  xstateregs = alloca (x86bsd_xsave_len);\n-\t  if (gdb_ptrace (PT_GETXSTATE, ptid,\n-\t\t\t  (PTRACE_TYPE_ARG3) xstateregs, 0) == -1)\n-\t    perror_with_name (_(\"Couldn't get extended state status\"));\n-\n-\t  i387_supply_xsave (regcache, -1, xstateregs);\n-\t  return;\n-\t}\n-#endif\n-      \n-#ifdef HAVE_PT_GETXMMREGS\n       if (have_ptrace_xmmregs != 0\n \t  && gdb_ptrace(PT_GETXMMREGS, ptid,\n \t\t\t(PTRACE_TYPE_ARG3) xmmregs, 0) == 0)\n@@ -255,60 +211,12 @@ i386bsd_store_inferior_registers (struct regcache *regcache, int regnum)\n \treturn;\n     }\n \n-#ifdef PT_SETFSBASE\n-  if (regnum == -1 || regnum == I386_FSBASE_REGNUM)\n-    {\n-      register_t base;\n-\n-      regcache->raw_collect (I386_FSBASE_REGNUM, &base);\n-\n-      if (gdb_ptrace (PT_SETFSBASE, ptid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n-\tperror_with_name (_(\"Couldn't write segment register fs_base\"));\n-      if (regnum != -1)\n-\treturn;\n-    }\n-#endif\n-#ifdef PT_SETGSBASE\n-  if (regnum == -1 || regnum == I386_GSBASE_REGNUM)\n-    {\n-      register_t base;\n-\n-      regcache->raw_collect (I386_GSBASE_REGNUM, &base);\n-\n-      if (gdb_ptrace (PT_SETGSBASE, ptid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n-\tperror_with_name (_(\"Couldn't write segment register gs_base\"));\n-      if (regnum != -1)\n-\treturn;\n-    }\n-#endif\n-\n   if (regnum == -1 || regnum >= I386_ST0_REGNUM)\n     {\n       struct fpreg fpregs;\n #ifdef HAVE_PT_GETXMMREGS\n       char xmmregs[512];\n-#endif\n-\n-#ifdef PT_GETXSTATE_INFO\n-      if (x86bsd_xsave_len != 0)\n-\t{\n-\t  void *xstateregs;\n-\n-\t  xstateregs = alloca (x86bsd_xsave_len);\n-\t  if (gdb_ptrace (PT_GETXSTATE, ptid,\n-\t\t\t  (PTRACE_TYPE_ARG3) xstateregs, 0) == -1)\n-\t    perror_with_name (_(\"Couldn't get extended state status\"));\n \n-\t  i387_collect_xsave (regcache, -1, xstateregs, 0);\n-\n-\t  if (gdb_ptrace (PT_SETXSTATE, ptid, (PTRACE_TYPE_ARG3) xstateregs,\n-\t\t\t  x86bsd_xsave_len) == -1)\n-\t    perror_with_name (_(\"Couldn't write extended state status\"));\n-\t  return;\n-\t}\n-#endif\n-\n-#ifdef HAVE_PT_GETXMMREGS\n       if (have_ptrace_xmmregs != 0\n \t  && gdb_ptrace(PT_GETXMMREGS, ptid,\n \t\t\t(PTRACE_TYPE_ARG3) xmmregs, 0) == 0)"
    },
    {
      "sha": "6fb67434a2d2431d7dfca9a682241a02ddbab9b1",
      "filename": "gdb/i386-fbsd-nat.c",
      "status": "modified",
      "additions": 220,
      "deletions": 9,
      "changes": 229,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/i386-fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/i386-fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-fbsd-nat.c?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -29,17 +29,20 @@\n \n #include \"fbsd-nat.h\"\n #include \"i386-tdep.h\"\n+#include \"i386-fbsd-tdep.h\"\n+#include \"i387-tdep.h\"\n #include \"x86-nat.h\"\n #include \"gdbsupport/x86-xstate.h\"\n #include \"x86-bsd-nat.h\"\n-#include \"i386-bsd-nat.h\"\n \n class i386_fbsd_nat_target final\n-  : public i386_bsd_nat_target<fbsd_nat_target>\n+  : public x86bsd_nat_target<fbsd_nat_target>\n {\n public:\n-  /* Add some extra features to the common *BSD/i386 target.  */\n-#ifdef PT_GETXSTATE_INFO\n+  void fetch_registers (struct regcache *, int) override;\n+  void store_registers (struct regcache *, int) override;\n+\n+#if defined(PT_GETXMMREGS) || defined(PT_GETXSTATE_INFO)\n   const struct target_desc *read_description () override;\n #endif\n \n@@ -52,6 +55,192 @@ class i386_fbsd_nat_target final\n \n static i386_fbsd_nat_target the_i386_fbsd_nat_target;\n \n+#ifdef PT_GETXSTATE_INFO\n+static size_t xsave_len;\n+#endif\n+\n+#ifdef HAVE_PT_GETXMMREGS\n+static int have_ptrace_xmmregs;\n+#endif\n+\n+/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this\n+   for all registers.  */\n+\n+void\n+i386_fbsd_nat_target::fetch_registers (struct regcache *regcache, int regnum)\n+{\n+  struct gdbarch *gdbarch = regcache->arch ();\n+#if defined(PT_GETFSBASE) || defined(PT_GETGSBASE)\n+  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+#endif\n+  pid_t pid = get_ptrace_pid (regcache->ptid ());\n+\n+  if (fetch_register_set<struct reg> (regcache, regnum, PT_GETREGS,\n+\t\t\t\t      &i386_fbsd_gregset))\n+    {\n+      if (regnum != -1)\n+\treturn;\n+    }\n+\n+#ifdef PT_GETFSBASE\n+  if (regnum == -1 || regnum == I386_FSBASE_REGNUM)\n+    {\n+      register_t base;\n+\n+      if (ptrace (PT_GETFSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get segment register fs_base\"));\n+\n+      regcache->raw_supply (I386_FSBASE_REGNUM, &base);\n+      if (regnum != -1)\n+\treturn;\n+    }\n+#endif\n+#ifdef PT_GETGSBASE\n+  if (regnum == -1 || regnum == I386_GSBASE_REGNUM)\n+    {\n+      register_t base;\n+\n+      if (ptrace (PT_GETGSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get segment register gs_base\"));\n+\n+      regcache->raw_supply (I386_GSBASE_REGNUM, &base);\n+      if (regnum != -1)\n+\treturn;\n+    }\n+#endif\n+\n+  /* There is no i386_fxsave_supplies or i386_xsave_supplies.\n+     Instead, the earlier register sets return early if the request\n+     was for a specific register that was already satisified to avoid\n+     fetching the FPU/XSAVE state unnecessarily.  */\n+\n+#ifdef PT_GETXSTATE_INFO\n+  if (xsave_len != 0)\n+    {\n+      void *xstateregs = alloca (xsave_len);\n+\n+      if (ptrace (PT_GETXSTATE, pid, (PTRACE_TYPE_ARG3) xstateregs, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get extended state status\"));\n+\n+      i387_supply_xsave (regcache, regnum, xstateregs);\n+      return;\n+    }\n+#endif\n+#ifdef HAVE_PT_GETXMMREGS\n+  if (have_ptrace_xmmregs != 0)\n+    {\n+      char xmmregs[I387_SIZEOF_FXSAVE];\n+\n+      if (ptrace(PT_GETXMMREGS, pid, (PTRACE_TYPE_ARG3) xmmregs, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get XMM registers\"));\n+\n+      i387_supply_fxsave (regcache, regnum, xmmregs);\n+      return;\n+    }\n+#endif\n+\n+  struct fpreg fpregs;\n+\n+  if (ptrace (PT_GETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n+    perror_with_name (_(\"Couldn't get floating point status\"));\n+\n+  i387_supply_fsave (regcache, regnum, &fpregs);\n+}\n+\n+/* Store register REGNUM back into the inferior.  If REGNUM is -1, do\n+   this for all registers.  */\n+\n+void\n+i386_fbsd_nat_target::store_registers (struct regcache *regcache, int regnum)\n+{\n+  struct gdbarch *gdbarch = regcache->arch ();\n+#if defined(PT_GETFSBASE) || defined(PT_GETGSBASE)\n+  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+#endif\n+  pid_t pid = get_ptrace_pid (regcache->ptid ());\n+\n+  if (store_register_set<struct reg> (regcache, regnum, PT_GETREGS, PT_SETREGS,\n+\t\t\t\t      &i386_fbsd_gregset))\n+    {\n+      if (regnum != -1)\n+\treturn;\n+    }\n+\n+#ifdef PT_SETFSBASE\n+  if (regnum == -1 || regnum == I386_FSBASE_REGNUM)\n+    {\n+      register_t base;\n+\n+      regcache->raw_collect (I386_FSBASE_REGNUM, &base);\n+\n+      if (ptrace (PT_SETFSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n+\tperror_with_name (_(\"Couldn't write segment register fs_base\"));\n+      if (regnum != -1)\n+\treturn;\n+    }\n+#endif\n+#ifdef PT_SETGSBASE\n+  if (regnum == -1 || regnum == I386_GSBASE_REGNUM)\n+    {\n+      register_t base;\n+\n+      regcache->raw_collect (I386_GSBASE_REGNUM, &base);\n+\n+      if (ptrace (PT_SETGSBASE, pid, (PTRACE_TYPE_ARG3) &base, 0) == -1)\n+\tperror_with_name (_(\"Couldn't write segment register gs_base\"));\n+      if (regnum != -1)\n+\treturn;\n+    }\n+#endif\n+\n+  /* There is no i386_fxsave_supplies or i386_xsave_supplies.\n+     Instead, the earlier register sets return early if the request\n+     was for a specific register that was already satisified to avoid\n+     fetching the FPU/XSAVE state unnecessarily.  */\n+\n+#ifdef PT_GETXSTATE_INFO\n+  if (xsave_len != 0)\n+    {\n+      void *xstateregs = alloca (xsave_len);\n+\n+      if (ptrace (PT_GETXSTATE, pid, (PTRACE_TYPE_ARG3) xstateregs, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get extended state status\"));\n+\n+      i387_collect_xsave (regcache, regnum, xstateregs, 0);\n+\n+      if (ptrace (PT_SETXSTATE, pid, (PTRACE_TYPE_ARG3) xstateregs, xsave_len)\n+\t  == -1)\n+\tperror_with_name (_(\"Couldn't write extended state status\"));\n+      return;\n+    }\n+#endif\n+#ifdef HAVE_PT_GETXMMREGS\n+  if (have_ptrace_xmmregs != 0)\n+    {\n+      char xmmregs[I387_SIZEOF_FXSAVE];\n+\n+      if (ptrace(PT_GETXMMREGS, pid, (PTRACE_TYPE_ARG3) xmmregs, 0) == -1)\n+\tperror_with_name (_(\"Couldn't get XMM registers\"));\n+\n+      i387_collect_fxsave (regcache, regnum, xmmregs);\n+\n+      if (ptrace (PT_SETXMMREGS, pid, (PTRACE_TYPE_ARG3) xmmregs, 0) == -1)\n+\tperror_with_name (_(\"Couldn't write XMM registers\"));\n+      return;\n+    }\n+#endif\n+\n+  struct fpreg fpregs;\n+\n+  if (ptrace (PT_GETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n+    perror_with_name (_(\"Couldn't get floating point status\"));\n+\n+  i387_collect_fsave (regcache, regnum, &fpregs);\n+\n+  if (ptrace (PT_SETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n+    perror_with_name (_(\"Couldn't write floating point status\"));\n+}\n+\n /* Resume execution of the inferior process.  If STEP is nonzero,\n    single-step it.  If SIGNAL is nonzero, give it that signal.  */\n \n@@ -135,32 +324,54 @@ i386fbsd_supply_pcb (struct regcache *regcache, struct pcb *pcb)\n }\n \f\n \n-#ifdef PT_GETXSTATE_INFO\n+#if defined(PT_GETXMMREGS) || defined(PT_GETXSTATE_INFO)\n /* Implement the read_description method.  */\n \n const struct target_desc *\n i386_fbsd_nat_target::read_description ()\n {\n+#ifdef PT_GETXSTATE_INFO\n   static int xsave_probed;\n   static uint64_t xcr0;\n+#endif\n+#ifdef PT_GETXMMREGS\n+  static int xmm_probed;\n+#endif\n \n+#ifdef PT_GETXSTATE_INFO\n   if (!xsave_probed)\n     {\n       struct ptrace_xstate_info info;\n \n       if (ptrace (PT_GETXSTATE_INFO, inferior_ptid.pid (),\n \t\t  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)\n \t{\n-\t  x86bsd_xsave_len = info.xsave_len;\n+\t  xsave_len = info.xsave_len;\n \t  xcr0 = info.xsave_mask;\n \t}\n       xsave_probed = 1;\n     }\n \n-  if (x86bsd_xsave_len == 0)\n-    xcr0 = X86_XSTATE_SSE_MASK;\n+  if (xsave_len != 0)\n+    return i386_target_description (xcr0, true);\n+#endif\n+\n+#ifdef PT_GETXMMREGS\n+  if (!xmm_probed)\n+    {\n+      char xmmregs[I387_SIZEOF_FXSAVE];\n+\n+      if (ptrace (PT_GETXMMREGS, inferior_ptid.pid (),\n+\t\t  (PTRACE_TYPE_ARG3) xmmregs, 0) == 0)\n+\thave_ptrace_xmmregs = 1;\n+      xmm_probed = 1;\n+    }\n+\n+  if (have_ptrace_xmmregs)\n+    return i386_target_description (X86_XSTATE_SSE_MASK, true);\n+#endif\n \n-  return i386_target_description (xcr0, true);\n+  return i386_target_description (X86_XSTATE_X87_MASK, true);\n }\n #endif\n "
    },
    {
      "sha": "76f4c20f6575fc615e05a0ab52f344f8eb6c7366",
      "filename": "gdb/i386-fbsd-tdep.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/i386-fbsd-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/i386-fbsd-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-fbsd-tdep.h?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -20,6 +20,8 @@\n #ifndef I386_FBSD_TDEP_H\n #define I386_FBSD_TDEP_H\n \n+#include \"regset.h\"\n+\n /* Get XSAVE extended state xcr0 from core dump.  */\n extern uint64_t i386fbsd_core_read_xcr0 (bfd *abfd);\n \n@@ -28,4 +30,6 @@ extern uint64_t i386fbsd_core_read_xcr0 (bfd *abfd);\n    matches the layout on Linux.  */\n #define I386_FBSD_XSAVE_XCR0_OFFSET 464\n \n+extern const struct regset i386_fbsd_gregset;\n+\n #endif /* i386-fbsd-tdep.h */"
    },
    {
      "sha": "099059a5e0bf0face550090d455537eb22c52e99",
      "filename": "gdb/x86-bsd-nat.c",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/x86-bsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/x86-bsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/x86-bsd-nat.c?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -33,10 +33,6 @@\n #include \"inf-ptrace.h\"\n \f\n \n-#ifdef PT_GETXSTATE_INFO\n-size_t x86bsd_xsave_len;\n-#endif\n-\n /* Support for debug registers.  */\n \n #ifdef HAVE_PT_GETDBREGS"
    },
    {
      "sha": "8b6760e716937165fa07b9ca9b2fed15a21ed4e7",
      "filename": "gdb/x86-bsd-nat.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/x86-bsd-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/00d7af046f12f18759b5b2c909d0b4527ac1857e/gdb/x86-bsd-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/x86-bsd-nat.h?ref=00d7af046f12f18759b5b2c909d0b4527ac1857e",
      "patch": "@@ -22,9 +22,6 @@\n \n #include \"x86-nat.h\"\n \n-/* Low level x86 XSAVE info.  */\n-extern size_t x86bsd_xsave_len;\n-\n /* A prototype *BSD/x86 target.  */\n \n #ifdef HAVE_PT_GETDBREGS"
    }
  ]
}