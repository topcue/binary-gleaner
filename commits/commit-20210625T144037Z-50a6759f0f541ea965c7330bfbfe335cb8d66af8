{
  "sha": "50a6759f0f541ea965c7330bfbfe335cb8d66af8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTBhNjc1OWYwZjU0MWVhOTY1YzczMzBiZmJmZTMzNWNiOGQ2NmFmOA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-06-25T14:40:37Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-06-25T14:40:37Z"
    },
    "message": "Use gdb::function_view in addrmap_foreach\n\nWhile working on the DWARF psymtab replacement, I needed\naddrmap_foreach to accept a gdb::function_view.  This seemed like a\nworthwhile change on its own, so I've written it separately for\nsubmission.\n\nRegression tested on x86-64 Fedora 32.\n\ngdb/ChangeLog\n2021-06-25  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/index-write.c (struct addrmap_index_data): Add\n\tinitializers.\n\t<operator()>: Declare.\n\t(addrmap_index_data::operator()): Rename from\n\tadd_address_entry_worker.  Remove 'datap' parameter.\n\t(write_address_map): Update.\n\t* psymtab.c (struct dump_psymtab_addrmap_data): Remove\n\t(dump_psymtab_addrmap_1): Remove 'data' parameter, add other\n\tparameters.\n\t(dump_psymtab_addrmap): Update.\n\t* addrmap.c (struct addrmap_funcs) <foreach>: Remove 'data'\n\tparameter.\n\t(addrmap_foreach, addrmap_fixed_foreach): Likewise.\n\t(struct mutable_foreach_data): Remove.\n\t(addrmap_mutable_foreach_worker): Update.\n\t(addrmap_mutable_foreach): Remove 'data' parameter.\n\t* addrmap.h (addrmap_foreach_fn): Use gdb::function_view.\n\t(addrmap_foreach): Remove 'data' parameter.",
    "tree": {
      "sha": "5f7add1207929170a7fcc2effc07c3e25335065d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5f7add1207929170a7fcc2effc07c3e25335065d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/50a6759f0f541ea965c7330bfbfe335cb8d66af8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/50a6759f0f541ea965c7330bfbfe335cb8d66af8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/50a6759f0f541ea965c7330bfbfe335cb8d66af8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/50a6759f0f541ea965c7330bfbfe335cb8d66af8/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "67470e9d8be180344494635dcef34e054938bfb8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/67470e9d8be180344494635dcef34e054938bfb8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/67470e9d8be180344494635dcef34e054938bfb8"
    }
  ],
  "stats": {
    "total": 179,
    "additions": 86,
    "deletions": 93
  },
  "files": [
    {
      "sha": "54f1b7bf539066dd4d23e656611908c4b00107ac",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=50a6759f0f541ea965c7330bfbfe335cb8d66af8",
      "patch": "@@ -1,3 +1,24 @@\n+2021-06-25  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/index-write.c (struct addrmap_index_data): Add\n+\tinitializers.\n+\t<operator()>: Declare.\n+\t(addrmap_index_data::operator()): Rename from\n+\tadd_address_entry_worker.  Remove 'datap' parameter.\n+\t(write_address_map): Update.\n+\t* psymtab.c (struct dump_psymtab_addrmap_data): Remove\n+\t(dump_psymtab_addrmap_1): Remove 'data' parameter, add other\n+\tparameters.\n+\t(dump_psymtab_addrmap): Update.\n+\t* addrmap.c (struct addrmap_funcs) <foreach>: Remove 'data'\n+\tparameter.\n+\t(addrmap_foreach, addrmap_fixed_foreach): Likewise.\n+\t(struct mutable_foreach_data): Remove.\n+\t(addrmap_mutable_foreach_worker): Update.\n+\t(addrmap_mutable_foreach): Remove 'data' parameter.\n+\t* addrmap.h (addrmap_foreach_fn): Use gdb::function_view.\n+\t(addrmap_foreach): Remove 'data' parameter.\n+\n 2021-06-25  Tom Tromey  <tromey@adacore.com>\n \n \t* python/py-type.c (typy_get_name): Decode an Ada type name."
    },
    {
      "sha": "9bd924e8382b2b15066f270318a911a309717622",
      "filename": "gdb/addrmap.c",
      "status": "modified",
      "additions": 9,
      "deletions": 25,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/addrmap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/addrmap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/addrmap.c?ref=50a6759f0f541ea965c7330bfbfe335cb8d66af8",
      "patch": "@@ -41,7 +41,7 @@ struct addrmap_funcs\n   struct addrmap *(*create_fixed) (struct addrmap *self,\n \t\t\t\t   struct obstack *obstack);\n   void (*relocate) (struct addrmap *self, CORE_ADDR offset);\n-  int (*foreach) (struct addrmap *self, addrmap_foreach_fn fn, void *data);\n+  int (*foreach) (struct addrmap *self, addrmap_foreach_fn fn);\n };\n \n \n@@ -84,9 +84,9 @@ addrmap_relocate (struct addrmap *map, CORE_ADDR offset)\n \n \n int\n-addrmap_foreach (struct addrmap *map, addrmap_foreach_fn fn, void *data)\n+addrmap_foreach (struct addrmap *map, addrmap_foreach_fn fn)\n {\n-  return map->funcs->foreach (map, fn, data);\n+  return map->funcs->foreach (map, fn);\n }\n \f\n /* Fixed address maps.  */\n@@ -182,15 +182,14 @@ addrmap_fixed_relocate (struct addrmap *self, CORE_ADDR offset)\n \n \n static int\n-addrmap_fixed_foreach (struct addrmap *self, addrmap_foreach_fn fn,\n-\t\t       void *data)\n+addrmap_fixed_foreach (struct addrmap *self, addrmap_foreach_fn fn)\n {\n   struct addrmap_fixed *map = (struct addrmap_fixed *) self;\n   size_t i;\n \n   for (i = 0; i < map->num_transitions; i++)\n     {\n-      int res = fn (data, map->transitions[i].addr, map->transitions[i].value);\n+      int res = fn (map->transitions[i].addr, map->transitions[i].value);\n \n       if (res != 0)\n \treturn res;\n@@ -471,39 +470,24 @@ addrmap_mutable_relocate (struct addrmap *self, CORE_ADDR offset)\n }\n \n \n-/* Struct to map addrmap's foreach function to splay_tree's version.  */\n-struct mutable_foreach_data\n-{\n-  addrmap_foreach_fn fn;\n-  void *data;\n-};\n-\n-\n /* This is a splay_tree_foreach_fn.  */\n \n static int\n addrmap_mutable_foreach_worker (splay_tree_node node, void *data)\n {\n-  struct mutable_foreach_data *foreach_data\n-    = (struct mutable_foreach_data *) data;\n+  addrmap_foreach_fn *fn = (addrmap_foreach_fn *) data;\n \n-  return foreach_data->fn (foreach_data->data,\n-\t\t\t   addrmap_node_key (node),\n-\t\t\t   addrmap_node_value (node));\n+  return (*fn) (addrmap_node_key (node), addrmap_node_value (node));\n }\n \n \n static int\n-addrmap_mutable_foreach (struct addrmap *self, addrmap_foreach_fn fn,\n-\t\t\t void *data)\n+addrmap_mutable_foreach (struct addrmap *self, addrmap_foreach_fn fn)\n {\n   struct addrmap_mutable *mutable_obj = (struct addrmap_mutable *) self;\n-  struct mutable_foreach_data foreach_data;\n \n-  foreach_data.fn = fn;\n-  foreach_data.data = data;\n   return splay_tree_foreach (mutable_obj->tree, addrmap_mutable_foreach_worker,\n-\t\t\t     &foreach_data);\n+\t\t\t     &fn);\n }\n \n "
    },
    {
      "sha": "4b1a59684b11abc421377ac33c13b62306449a09",
      "filename": "gdb/addrmap.h",
      "status": "modified",
      "additions": 10,
      "deletions": 8,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/addrmap.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/addrmap.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/addrmap.h?ref=50a6759f0f541ea965c7330bfbfe335cb8d66af8",
      "patch": "@@ -20,6 +20,8 @@\n #ifndef ADDRMAP_H\n #define ADDRMAP_H\n \n+#include \"gdbsupport/function-view.h\"\n+\n /* An address map is essentially a table mapping CORE_ADDRs onto GDB\n    data structures, like blocks, symtabs, partial symtabs, and so on.\n    An address map uses memory proportional to the number of\n@@ -93,13 +95,13 @@ void addrmap_relocate (struct addrmap *map, CORE_ADDR offset);\n \n /* The type of a function used to iterate over the map.\n    OBJ is NULL for unmapped regions.  */\n-typedef int (*addrmap_foreach_fn) (void *data, CORE_ADDR start_addr,\n-\t\t\t\t   void *obj);\n-\n-/* Call FN, passing it DATA, for every address in MAP, following an\n-   in-order traversal.  If FN ever returns a non-zero value, the\n-   iteration ceases immediately, and the value is returned.\n-   Otherwise, this function returns 0.  */\n-int addrmap_foreach (struct addrmap *map, addrmap_foreach_fn fn, void *data);\n+typedef gdb::function_view<int (CORE_ADDR start_addr, void *obj)>\n+     addrmap_foreach_fn;\n+\n+/* Call FN for every address in MAP, following an in-order traversal.\n+   If FN ever returns a non-zero value, the iteration ceases\n+   immediately, and the value is returned.  Otherwise, this function\n+   returns 0.  */\n+int addrmap_foreach (struct addrmap *map, addrmap_foreach_fn fn);\n \n #endif /* ADDRMAP_H */"
    },
    {
      "sha": "2da222a6b5d279ce4bec8f225df8e2658cdd1d4e",
      "filename": "gdb/dwarf2/index-write.c",
      "status": "modified",
      "additions": 18,
      "deletions": 23,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/dwarf2/index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/dwarf2/index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-write.c?ref=50a6759f0f541ea965c7330bfbfe335cb8d66af8",
      "patch": "@@ -419,14 +419,16 @@ struct addrmap_index_data\n   data_buf &addr_vec;\n   psym_index_map &cu_index_htab;\n \n+  int operator() (CORE_ADDR start_addr, void *obj);\n+\n   /* Non-zero if the previous_* fields are valid.\n      We can't write an entry until we see the next entry (since it is only then\n      that we know the end of the entry).  */\n-  int previous_valid;\n+  int previous_valid = 0;\n   /* Index of the CU in the table of all CUs in the index file.  */\n-  unsigned int previous_cu_index;\n+  unsigned int previous_cu_index = 0;\n   /* Start address of the CU.  */\n-  CORE_ADDR previous_cu_start;\n+  CORE_ADDR previous_cu_start = 0;\n };\n \n /* Write an address entry to ADDR_VEC.  */\n@@ -442,27 +444,26 @@ add_address_entry (data_buf &addr_vec,\n \n /* Worker function for traversing an addrmap to build the address table.  */\n \n-static int\n-add_address_entry_worker (void *datap, CORE_ADDR start_addr, void *obj)\n+int\n+addrmap_index_data::operator() (CORE_ADDR start_addr, void *obj)\n {\n-  struct addrmap_index_data *data = (struct addrmap_index_data *) datap;\n   partial_symtab *pst = (partial_symtab *) obj;\n \n-  if (data->previous_valid)\n-    add_address_entry (data->addr_vec,\n-\t\t       data->previous_cu_start, start_addr,\n-\t\t       data->previous_cu_index);\n+  if (previous_valid)\n+    add_address_entry (addr_vec,\n+\t\t       previous_cu_start, start_addr,\n+\t\t       previous_cu_index);\n \n-  data->previous_cu_start = start_addr;\n+  previous_cu_start = start_addr;\n   if (pst != NULL)\n     {\n-      const auto it = data->cu_index_htab.find (pst);\n-      gdb_assert (it != data->cu_index_htab.cend ());\n-      data->previous_cu_index = it->second;\n-      data->previous_valid = 1;\n+      const auto it = cu_index_htab.find (pst);\n+      gdb_assert (it != cu_index_htab.cend ());\n+      previous_cu_index = it->second;\n+      previous_valid = 1;\n     }\n   else\n-    data->previous_valid = 0;\n+    previous_valid = 0;\n \n   return 0;\n }\n@@ -477,14 +478,8 @@ write_address_map (dwarf2_per_bfd *per_bfd, data_buf &addr_vec,\n {\n   struct addrmap_index_data addrmap_index_data (addr_vec, cu_index_htab);\n \n-  /* When writing the address table, we have to cope with the fact that\n-     the addrmap iterator only provides the start of a region; we have to\n-     wait until the next invocation to get the start of the next region.  */\n-\n-  addrmap_index_data.previous_valid = 0;\n-\n   addrmap_foreach (per_bfd->partial_symtabs->psymtabs_addrmap,\n-\t\t   add_address_entry_worker, &addrmap_index_data);\n+\t\t   addrmap_index_data);\n \n   /* It's highly unlikely the last entry (end address = 0xff...ff)\n      is valid, but we should still handle it."
    },
    {
      "sha": "cbd21b3209fcf164de76a6d2ce5cae175699aaba",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 28,
      "deletions": 37,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50a6759f0f541ea965c7330bfbfe335cb8d66af8/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=50a6759f0f541ea965c7330bfbfe335cb8d66af8",
      "patch": "@@ -1465,52 +1465,39 @@ psymtab_storage::discard_psymtab (struct partial_symtab *pst)\n \n \f\n \n-/* We need to pass a couple of items to the addrmap_foreach function,\n-   so use a struct.  */\n-\n-struct dump_psymtab_addrmap_data\n-{\n-  struct objfile *objfile;\n-  struct partial_symtab *psymtab;\n-  struct ui_file *outfile;\n-\n-  /* Non-zero if the previously printed addrmap entry was for PSYMTAB.\n-     If so, we want to print the next one as well (since the next addrmap\n-     entry defines the end of the range).  */\n-  int previous_matched;\n-};\n-\n /* Helper function for dump_psymtab_addrmap to print an addrmap entry.  */\n \n static int\n-dump_psymtab_addrmap_1 (void *datap, CORE_ADDR start_addr, void *obj)\n+dump_psymtab_addrmap_1 (struct objfile *objfile,\n+\t\t\tstruct partial_symtab *psymtab,\n+\t\t\tstruct ui_file *outfile,\n+\t\t\tint *previous_matched,\n+\t\t\tCORE_ADDR start_addr,\n+\t\t\tvoid *obj)\n {\n-  struct dump_psymtab_addrmap_data *data\n-    = (struct dump_psymtab_addrmap_data *) datap;\n-  struct gdbarch *gdbarch = data->objfile->arch ();\n+  struct gdbarch *gdbarch = objfile->arch ();\n   struct partial_symtab *addrmap_psymtab = (struct partial_symtab *) obj;\n   const char *psymtab_address_or_end = NULL;\n \n   QUIT;\n \n-  if (data->psymtab == NULL\n-      || data->psymtab == addrmap_psymtab)\n+  if (psymtab == NULL\n+      || psymtab == addrmap_psymtab)\n     psymtab_address_or_end = host_address_to_string (addrmap_psymtab);\n-  else if (data->previous_matched)\n+  else if (*previous_matched)\n     psymtab_address_or_end = \"<ends here>\";\n \n-  if (data->psymtab == NULL\n-      || data->psymtab == addrmap_psymtab\n-      || data->previous_matched)\n+  if (psymtab == NULL\n+      || psymtab == addrmap_psymtab\n+      || *previous_matched)\n     {\n-      fprintf_filtered (data->outfile, \"  %s%s %s\\n\",\n-\t\t\tdata->psymtab != NULL ? \"  \" : \"\",\n+      fprintf_filtered (outfile, \"  %s%s %s\\n\",\n+\t\t\tpsymtab != NULL ? \"  \" : \"\",\n \t\t\tpaddress (gdbarch, start_addr),\n \t\t\tpsymtab_address_or_end);\n     }\n \n-  data->previous_matched = (data->psymtab == NULL\n-\t\t\t    || data->psymtab == addrmap_psymtab);\n+  *previous_matched = psymtab == NULL || psymtab == addrmap_psymtab;\n \n   return 0;\n }\n@@ -1524,20 +1511,24 @@ dump_psymtab_addrmap (struct objfile *objfile,\n \t\t      struct partial_symtab *psymtab,\n \t\t      struct ui_file *outfile)\n {\n-  struct dump_psymtab_addrmap_data addrmap_dump_data;\n-\n   if ((psymtab == NULL\n        || psymtab->psymtabs_addrmap_supported)\n       && partial_symtabs->psymtabs_addrmap != NULL)\n     {\n-      addrmap_dump_data.objfile = objfile;\n-      addrmap_dump_data.psymtab = psymtab;\n-      addrmap_dump_data.outfile = outfile;\n-      addrmap_dump_data.previous_matched = 0;\n+      /* Non-zero if the previously printed addrmap entry was for\n+\t PSYMTAB.  If so, we want to print the next one as well (since\n+\t the next addrmap entry defines the end of the range).  */\n+      int previous_matched = 0;\n+\n+      auto callback = [&] (CORE_ADDR start_addr, void *obj)\n+      {\n+\treturn dump_psymtab_addrmap_1 (objfile, psymtab, outfile,\n+\t\t\t\t       &previous_matched, start_addr, obj);\n+      };\n+\n       fprintf_filtered (outfile, \"%sddress map:\\n\",\n \t\t\tpsymtab == NULL ? \"Entire a\" : \"  A\");\n-      addrmap_foreach (partial_symtabs->psymtabs_addrmap,\n-\t\t       dump_psymtab_addrmap_1, &addrmap_dump_data);\n+      addrmap_foreach (partial_symtabs->psymtabs_addrmap, callback);\n     }\n }\n "
    }
  ]
}