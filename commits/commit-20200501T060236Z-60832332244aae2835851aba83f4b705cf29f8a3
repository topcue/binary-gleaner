{
  "sha": "60832332244aae2835851aba83f4b705cf29f8a3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjA4MzIzMzIyNDRhYWUyODM1ODUxYWJhODNmNGI3MDVjZjI5ZjhhMw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-05-01T06:00:12Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-05-01T06:02:36Z"
    },
    "message": "objdump: long run time when using -D -z\n\nThe zero scan is silly when the result isn't used.\n\n\t* objdump.c (disassemble_bytes): Don't scan for zeros when\n\tdisassembling zeros.  Translate \"resuming at file offset\" message.\n\tFormatting.  Replace some signed variables with unsigned.",
    "tree": {
      "sha": "4d0d3bb514d024c39c9a22195b8aee2ef9c2060b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4d0d3bb514d024c39c9a22195b8aee2ef9c2060b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/60832332244aae2835851aba83f4b705cf29f8a3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/60832332244aae2835851aba83f4b705cf29f8a3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/60832332244aae2835851aba83f4b705cf29f8a3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/60832332244aae2835851aba83f4b705cf29f8a3/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a8acd6eeb6dc2cc5460ece90f90ebe36b56b20ba",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a8acd6eeb6dc2cc5460ece90f90ebe36b56b20ba",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a8acd6eeb6dc2cc5460ece90f90ebe36b56b20ba"
    }
  ],
  "stats": {
    "total": 74,
    "additions": 42,
    "deletions": 32
  },
  "files": [
    {
      "sha": "52082fcae1216b14561050e11c1052ee29eb52e5",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/60832332244aae2835851aba83f4b705cf29f8a3/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/60832332244aae2835851aba83f4b705cf29f8a3/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=60832332244aae2835851aba83f4b705cf29f8a3",
      "patch": "@@ -1,3 +1,10 @@\n+2020-05-01  Alan Modra  <amodra@gmail.com>\n+\t    Haim Shimonovich  <Haim.Shimonovich@ceva-dsp.com>\n+\n+\t* objdump.c (disassemble_bytes): Don't scan for zeros when\n+\tdisassembling zeros.  Translate \"resuming at file offset\" message.\n+\tFormatting.  Replace some signed variables with unsigned.\n+\n 2020-04-30  Alex Coplan  <alex.coplan@arm.com>\n \n \t* testsuite/binutils-all/aarch64/in-order-all.d: Update to use new"
    },
    {
      "sha": "99e6df6eb17fbc7b07f439e8455fa534dd4dea98",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 35,
      "deletions": 32,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/60832332244aae2835851aba83f4b705cf29f8a3/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/60832332244aae2835851aba83f4b705cf29f8a3/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=60832332244aae2835851aba83f4b705cf29f8a3",
      "patch": "@@ -2555,13 +2555,13 @@ disassemble_bytes (struct disassemble_info * inf,\n {\n   struct objdump_disasm_info *aux;\n   asection *section;\n-  int octets_per_line;\n-  int skip_addr_chars;\n+  unsigned int octets_per_line;\n+  unsigned int skip_addr_chars;\n   bfd_vma addr_offset;\n   unsigned int opb = inf->octets_per_byte;\n   unsigned int skip_zeroes = inf->skip_zeroes;\n   unsigned int skip_zeroes_at_end = inf->skip_zeroes_at_end;\n-  int octets = opb;\n+  size_t octets;\n   SFILE sfile;\n \n   aux = (struct objdump_disasm_info *) inf->application_data;\n@@ -2630,7 +2630,6 @@ disassemble_bytes (struct disassemble_info * inf,\n   addr_offset = start_offset;\n   while (addr_offset < stop_offset)\n     {\n-      bfd_vma z;\n       bfd_boolean need_nl = FALSE;\n \n       octets = 0;\n@@ -2640,41 +2639,42 @@ disassemble_bytes (struct disassemble_info * inf,\n \n       /* If we see more than SKIP_ZEROES octets of zeroes, we just\n \t print `...'.  */\n-      for (z = addr_offset * opb; z < stop_offset * opb; z++)\n-\tif (data[z] != 0)\n-\t  break;\n+      if (! disassemble_zeroes)\n+\tfor (; addr_offset * opb + octets < stop_offset * opb; octets++)\n+\t  if (data[addr_offset * opb + octets] != 0)\n+\t    break;\n       if (! disassemble_zeroes\n \t  && (inf->insn_info_valid == 0\n \t      || inf->branch_delay_insns == 0)\n-\t  && (z - addr_offset * opb >= skip_zeroes\n-\t      || (z == stop_offset * opb &&\n-\t\t  z - addr_offset * opb < skip_zeroes_at_end)))\n+\t  && (octets >= skip_zeroes\n+\t      || (addr_offset * opb + octets == stop_offset * opb\n+\t\t  && octets < skip_zeroes_at_end)))\n \t{\n \t  /* If there are more nonzero octets to follow, we only skip\n \t     zeroes in multiples of 4, to try to avoid running over\n \t     the start of an instruction which happens to start with\n \t     zero.  */\n-\t  if (z != stop_offset * opb)\n-\t    z = addr_offset * opb + ((z - addr_offset * opb) &~ 3);\n-\n-\t  octets = z - addr_offset * opb;\n+\t  if (addr_offset * opb + octets != stop_offset * opb)\n+\t    octets &= ~3;\n \n \t  /* If we are going to display more data, and we are displaying\n \t     file offsets, then tell the user how many zeroes we skip\n \t     and the file offset from where we resume dumping.  */\n-\t  if (display_file_offsets && ((addr_offset + (octets / opb)) < stop_offset))\n-\t    printf (\"\\t... (skipping %d zeroes, resuming at file offset: 0x%lx)\\n\",\n-\t\t    octets / opb,\n+\t  if (display_file_offsets\n+\t      && addr_offset + octets / opb < stop_offset)\n+\t    printf (_(\"\\t... (skipping %lu zeroes, \"\n+\t\t      \"resuming at file offset: 0x%lx)\\n\"),\n+\t\t    (unsigned long) (octets / opb),\n \t\t    (unsigned long) (section->filepos\n-\t\t\t\t     + (addr_offset + (octets / opb))));\n+\t\t\t\t     + addr_offset + octets / opb));\n \t  else\n \t    printf (\"\\t...\\n\");\n \t}\n       else\n \t{\n \t  char buf[50];\n-\t  int bpc = 0;\n-\t  int pb = 0;\n+\t  unsigned int bpc = 0;\n+\t  unsigned int pb = 0;\n \n \t  if (with_line_numbers || with_source_code)\n \t    show_line (aux->abfd, section, addr_offset);\n@@ -2706,6 +2706,8 @@ disassemble_bytes (struct disassemble_info * inf,\n \n \t  if (insns)\n \t    {\n+\t      int insn_size;\n+\n \t      sfile.pos = 0;\n \t      inf->fprintf_func = (fprintf_ftype) objdump_sprintf;\n \t      inf->stream = &sfile;\n@@ -2722,13 +2724,13 @@ disassemble_bytes (struct disassemble_info * inf,\n \t\t  && *relppp < relppend)\n \t\t{\n \t\t  bfd_signed_vma distance_to_rel;\n-\t\t  int insn_size = 0;\n \t\t  int max_reloc_offset\n \t\t    = aux->abfd->arch_info->max_reloc_offset_into_insn;\n \n \t\t  distance_to_rel = ((**relppp)->address - rel_offset\n \t\t\t\t     - addr_offset);\n \n+\t\t  insn_size = 0;\n \t\t  if (distance_to_rel > 0\n \t\t      && (max_reloc_offset < 0\n \t\t\t  || distance_to_rel <= max_reloc_offset))\n@@ -2769,30 +2771,31 @@ disassemble_bytes (struct disassemble_info * inf,\n \t\t}\n \n \t      if (! disassemble_all\n-\t\t  && (section->flags & (SEC_CODE | SEC_HAS_CONTENTS))\n-\t\t  == (SEC_CODE | SEC_HAS_CONTENTS))\n+\t\t  && ((section->flags & (SEC_CODE | SEC_HAS_CONTENTS))\n+\t\t      == (SEC_CODE | SEC_HAS_CONTENTS)))\n \t\t/* Set a stop_vma so that the disassembler will not read\n \t\t   beyond the next symbol.  We assume that symbols appear on\n \t\t   the boundaries between instructions.  We only do this when\n \t\t   disassembling code of course, and when -D is in effect.  */\n \t\tinf->stop_vma = section->vma + stop_offset;\n \n \t      inf->stop_offset = stop_offset;\n-\t      octets = (*disassemble_fn) (section->vma + addr_offset, inf);\n+\t      insn_size = (*disassemble_fn) (section->vma + addr_offset, inf);\n+\t      octets = insn_size;\n \n \t      inf->stop_vma = 0;\n \t      inf->fprintf_func = (fprintf_ftype) fprintf;\n \t      inf->stream = stdout;\n \t      if (insn_width == 0 && inf->bytes_per_line != 0)\n \t\toctets_per_line = inf->bytes_per_line;\n-\t      if (octets < (int) opb)\n+\t      if (insn_size < (int) opb)\n \t\t{\n \t\t  if (sfile.pos)\n \t\t    printf (\"%s\\n\", sfile.buffer);\n-\t\t  if (octets >= 0)\n+\t\t  if (insn_size >= 0)\n \t\t    {\n \t\t      non_fatal (_(\"disassemble_fn returned length %d\"),\n-\t\t\t\t octets);\n+\t\t\t\t insn_size);\n \t\t      exit_status = 1;\n \t\t    }\n \t\t  break;\n@@ -2838,11 +2841,11 @@ disassemble_bytes (struct disassemble_info * inf,\n \t\t  /* PR 21580: Check for a buffer ending early.  */\n \t\t  if (j + bpc <= stop_offset * opb)\n \t\t    {\n-\t\t      int k;\n+\t\t      unsigned int k;\n \n \t\t      if (inf->display_endian == BFD_ENDIAN_LITTLE)\n \t\t\t{\n-\t\t\t  for (k = bpc - 1; k >= 0; k--)\n+\t\t\t  for (k = bpc; k-- != 0; )\n \t\t\t    printf (\"%02x\", (unsigned) data[j + k]);\n \t\t\t}\n \t\t      else\n@@ -2856,7 +2859,7 @@ disassemble_bytes (struct disassemble_info * inf,\n \n \t      for (; pb < octets_per_line; pb += bpc)\n \t\t{\n-\t\t  int k;\n+\t\t  unsigned int k;\n \n \t\t  for (k = 0; k < bpc; k++)\n \t\t    printf (\"  \");\n@@ -2911,11 +2914,11 @@ disassemble_bytes (struct disassemble_info * inf,\n \t\t      /* PR 21619: Check for a buffer ending early.  */\n \t\t      if (j + bpc <= stop_offset * opb)\n \t\t\t{\n-\t\t\t  int k;\n+\t\t\t  unsigned int k;\n \n \t\t\t  if (inf->display_endian == BFD_ENDIAN_LITTLE)\n \t\t\t    {\n-\t\t\t      for (k = bpc - 1; k >= 0; k--)\n+\t\t\t      for (k = bpc; k-- != 0; )\n \t\t\t\tprintf (\"%02x\", (unsigned) data[j + k]);\n \t\t\t    }\n \t\t\t  else"
    }
  ]
}