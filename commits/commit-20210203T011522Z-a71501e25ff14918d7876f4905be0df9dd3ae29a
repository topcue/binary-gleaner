{
  "sha": "a71501e25ff14918d7876f4905be0df9dd3ae29a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTcxNTAxZTI1ZmYxNDkxOGQ3ODc2ZjQ5MDViZTBkZjlkZDNhZTI5YQ==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-12-14T12:07:20Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-02-03T01:15:22Z"
    },
    "message": "Testcase for detaching while stepping over breakpoint\n\nThis adds a testcase that exercises detaching while GDB is stepping\nover a breakpoint, in all combinations of:\n\n  - maint target non-stop off/on\n  - set non-stop on/off\n  - displaced stepping on/off\n\nThis exercises the bugs fixed in the previous 8 patches.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.threads/detach-step-over.c: New file.\n\t* gdb.threads/detach-step-over.exp: New file.",
    "tree": {
      "sha": "ade5cacc853075157604ba5d4a09853397663b20",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ade5cacc853075157604ba5d4a09853397663b20"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a71501e25ff14918d7876f4905be0df9dd3ae29a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a71501e25ff14918d7876f4905be0df9dd3ae29a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a71501e25ff14918d7876f4905be0df9dd3ae29a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a71501e25ff14918d7876f4905be0df9dd3ae29a/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "408f66864a1a823591b26420410c982174c239a2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/408f66864a1a823591b26420410c982174c239a2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/408f66864a1a823591b26420410c982174c239a2"
    }
  ],
  "stats": {
    "total": 407,
    "additions": 407,
    "deletions": 0
  },
  "files": [
    {
      "sha": "62c06d0f52c7960da31b604d42860b44a6cce25d",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a71501e25ff14918d7876f4905be0df9dd3ae29a/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a71501e25ff14918d7876f4905be0df9dd3ae29a/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=a71501e25ff14918d7876f4905be0df9dd3ae29a",
      "patch": "@@ -1,3 +1,8 @@\n+2021-02-03  Pedro Alves  <pedro@palves.net>\n+\n+\t* gdb.threads/detach-step-over.c: New file.\n+\t* gdb.threads/detach-step-over.exp: New file.\n+\n 2021-02-03  Pedro Alves  <pedro@palves.net>\n \n \t* gdb.threads/attach-non-stop.c: New file."
    },
    {
      "sha": "13db9f60b049406b9d62189bc83e38eb1ad84cee",
      "filename": "gdb/testsuite/gdb.threads/detach-step-over.c",
      "status": "added",
      "additions": 112,
      "deletions": 0,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a71501e25ff14918d7876f4905be0df9dd3ae29a/gdb/testsuite/gdb.threads/detach-step-over.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a71501e25ff14918d7876f4905be0df9dd3ae29a/gdb/testsuite/gdb.threads/detach-step-over.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/detach-step-over.c?ref=a71501e25ff14918d7876f4905be0df9dd3ae29a",
      "patch": "@@ -0,0 +1,112 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#define _GNU_SOURCE\n+#include <assert.h>\n+#include <pthread.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <string.h>\n+#include <signal.h>\n+\n+/* Number of threads we'll create.  */\n+int n_threads = 10;\n+\n+int mypid;\n+\n+static void\n+setup_done (void)\n+{\n+}\n+\n+/* Entry point for threads.  Loops forever.  */\n+\n+void *\n+thread_func (void *arg)\n+{\n+  /* Avoid setting the breakpoint at an instruction that wouldn't\n+     require a fixup phase, like a branch/jump.  In such a case, even\n+     if GDB manages to detach the inferior with an incomplete\n+     displaced step, GDB inferior may still not crash.  A breakpoint\n+     at a line that increments a variable is good bet that we end up\n+     setting a breakpoint at an instruction that will require a fixup\n+     phase to move the PC from the scratch pad to the instruction\n+     after the breakpoint.  */\n+  volatile unsigned counter = 0;\n+\n+  while (1)\n+    {\n+      counter++; /* Set breakpoint here.  */\n+      counter++;\n+      counter++;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Allow for as much timeout as DejaGnu wants, plus a bit of\n+   slack.  */\n+#define SECONDS (TIMEOUT + 20)\n+\n+/* We'll exit after this many seconds.  */\n+unsigned int seconds_left = SECONDS;\n+\n+/* GDB sets this whenever it's about to start a new detach/attach\n+   sequence.  We react by resetting the seconds-left counter.  */\n+volatile int again = 0;\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i;\n+\n+  signal (SIGUSR1, SIG_IGN);\n+\n+  mypid = getpid ();\n+  setup_done ();\n+\n+  if (argc > 1)\n+    n_threads = atoi (argv[1]);\n+\n+  /* Spawn the test threads.  */\n+  for (i = 0; i < n_threads; ++i)\n+    {\n+      pthread_t child;\n+      int rc;\n+\n+      rc = pthread_create (&child, NULL, thread_func, NULL);\n+      assert (rc == 0);\n+    }\n+\n+  /* Exit after a while if GDB is gone/crashes.  But wait long enough\n+     for one attach/detach sequence done by the .exp file.  */\n+  while (--seconds_left > 0)\n+    {\n+      sleep (1);\n+\n+      if (again)\n+\t{\n+\t  /* GDB should be reattaching soon.  Restart the timer.  */\n+\t  again = 0;\n+\t  seconds_left = SECONDS;\n+\t}\n+    }\n+\n+  printf (\"timeout, exiting\\n\");\n+  return 0;\n+}"
    },
    {
      "sha": "8c58aebad8ae8b17ed8a4df2cc07a5284405a355",
      "filename": "gdb/testsuite/gdb.threads/detach-step-over.exp",
      "status": "added",
      "additions": 290,
      "deletions": 0,
      "changes": 290,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a71501e25ff14918d7876f4905be0df9dd3ae29a/gdb/testsuite/gdb.threads/detach-step-over.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a71501e25ff14918d7876f4905be0df9dd3ae29a/gdb/testsuite/gdb.threads/detach-step-over.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/detach-step-over.exp?ref=a71501e25ff14918d7876f4905be0df9dd3ae29a",
      "patch": "@@ -0,0 +1,290 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test detaching from a process that is running and has threads\n+# constantly hitting a breakpoint and stepping over it, in all\n+# combinations of:\n+#\n+#  - maint target non-stop off/on\n+#  - set non-stop on/off\n+#  - displaced stepping on/off\n+#\n+# This stresses the edge cases of detaching while a displaced step or\n+# an in-line step over are in progress.\n+#\n+# A fail mode is that the inferior process dies after being detached.\n+# This can happen because e.g.:\n+#\n+# - GDB leaves a breakpoint installed behind, or\n+#\n+# - GDB leaves a thread running in the displaced step scratch buffer.\n+#   With no debugger around to run the finish step, the thread runs\n+#   off of the scratch buffer, with undefined results.\n+#\n+# To exercise this, the testcase reattaches to the process shortly\n+# after detaching, ensuring the process is still alive and well.\n+#\n+# In addition, since GDB may pause threads of all processes for\n+# stepping over a breakpoint, it needs to re-resume all threads if it\n+# detaches from the process that was just stepping over the\n+# breakpoint.  To ensure that, the testcase actually runs a second\n+# process at the same time as the one that is used to test detaching.\n+# After the first process is detached, the testcase sends a SIGUSR1 to\n+# the second process.  If threads failed to be resumed, then the\n+# SIGUSR1 is never reported to the user, resulting in timeout.  The\n+# threads of this second process will also be constantly stepping over\n+# a breakpoint, which has helped with exposing further corner case\n+# bugs.\n+\n+if {![can_spawn_for_attach]} {\n+    return 0\n+}\n+\n+standard_testfile\n+\n+set bp_lineno [gdb_get_line_number \"Set breakpoint here\"]\n+\n+# The test proper.  See description above.\n+proc test {condition_eval target_non_stop non_stop displaced} {\n+    global binfile srcfile\n+    global gdb_prompt\n+    global decimal\n+    global bp_lineno\n+    global GDBFLAGS\n+\n+    # Number of threads started by the program.\n+    set n_threads 10\n+\n+    save_vars { GDBFLAGS } {\n+\tappend GDBFLAGS \" -ex \\\"maint set target-non-stop $target_non_stop\\\"\"\n+\tappend GDBFLAGS \" -ex \\\"set non-stop $non_stop\\\"\"\n+\tappend GDBFLAGS \" -ex \\\"set displaced $displaced\\\"\"\n+\tappend GDBFLAGS \" -ex \\\"set schedule-multiple on\\\"\"\n+\tclean_restart $binfile\n+    }\n+\n+    set test_spawn_id [spawn_wait_for_attach $binfile]\n+    set testpid [spawn_id_get_pid $test_spawn_id]\n+\n+    set any \"\\[^\\r\\n\\]*\"\n+\n+    gdb_test \"add-inferior\" \"Added inferior 2.*\"\n+    gdb_test \"inferior 2\" \"Switching to .*\"\n+\n+    gdb_load $binfile\n+    if ![runto setup_done] then {\n+\tfail \"can't run to setup_done\"\n+\tkill_wait_spawned_process $test_spawn_id\n+\treturn\n+    }\n+\n+    gdb_test_no_output \"set breakpoint condition-evaluation $condition_eval\"\n+\n+    # Get the PID of the test process.\n+    set pid_inf2 \"\"\n+    gdb_test_multiple \"p mypid\" \"get pid of inferior 2\" {\n+\t-re \" = ($decimal)\\r\\n$gdb_prompt $\" {\n+\t    set pid_inf2 $expect_out(1,string)\n+\t    pass $gdb_test_name\n+\t}\n+    }\n+\n+    set attempts 3\n+    for {set attempt 1} { $attempt <= $attempts } { incr attempt } {\n+\twith_test_prefix \"iter $attempt\" {\n+\t    gdb_test \"inferior 1\" \"Switching to .*\"\n+\n+\t    set attached 0\n+\t    set eperm 0\n+\t    set test \"attach\"\n+\t    gdb_test_multiple \"attach $testpid\" $test {\n+\t\t-re \"new threads in iteration\" {\n+\t\t    # Seen when \"set debug libthread_db\" is on.\n+\t\t    exp_continue\n+\t\t}\n+\t\t-re \"is a zombie - the process has already terminated.*$gdb_prompt \" {\n+\t\t    fail $gdb_test_name\n+\t\t}\n+\t\t-re \"Unable to attach: .*$gdb_prompt \" {\n+\t\t    fail $gdb_test_name\n+\t\t}\n+\t\t-re \"Attaching to program.*process $testpid.*$gdb_prompt \" {\n+\t\t    pass $test\n+\t\t    set attached 1\n+\t\t}\n+\t    }\n+\n+\t    if {!$attached} {\n+\t\tkill_wait_spawned_process $test_spawn_id\n+\t\treturn\n+\t    }\n+\n+\t    if {$non_stop} {\n+\t\t# In non-stop, we will see one stop per thread after\n+\t\t# the prompt.\n+\t\tset stops 0\n+\t\tset tid_re \"$::decimal\\.$::decimal\"\n+\t\tset test \"seen all stops\"\n+\t\tfor {set thread 1} { $thread <= $n_threads } { incr thread } {\n+\t\t    if {[gdb_test_multiple \"\" $test {\n+\t\t\t-re \"Thread ${tid_re} ${any} stopped\" {\n+\t\t\t    incr stops\n+\t\t\t}\n+\t\t    }] != 0} {\n+\t\t\tbreak\n+\t\t    }\n+\t\t}\n+\n+\t\t# If we haven't seen all stops, then the\n+\t\t# gdb_test_multiple in the loop above will have\n+\t\t# already issued a FAIL.\n+\t\tif {$stops != $n_threads} {\n+\t\t    kill_wait_spawned_process $test_spawn_id\n+\t\t    return\n+\t\t}\n+\t\tpass $test\n+\t    }\n+\n+\t    # Set threads stepping over a breakpoint continuously.\n+\t    gdb_test \"break $srcfile:$bp_lineno if 0\" \"Breakpoint.*\" \\\n+\t\t\"break LOC if 0\"\n+\n+\t    if {$attempt < $attempts} {\n+\t\t# Kick the time out timer for another round.\n+\t\tgdb_test \"print again = 1\" \" = 1\" \"reset timer in the inferior\"\n+\t\t# Show the time we had left in the logs, in case\n+\t\t# something goes wrong.\n+\t\tgdb_test \"print seconds_left\" \" = .*\"\n+\t    }\n+\n+\t    if {$non_stop} {\n+\t\tset cont_cmd \"continue -a &\"\n+\t    } else {\n+\t\tset cont_cmd \"continue &\"\n+\t    }\n+\n+\t    set cont_cmd_re [string_to_regexp $cont_cmd]\n+\t    gdb_test_multiple $cont_cmd \"\" {\n+\t\t-re \"^$cont_cmd_re\\r\\nContinuing\\.\\r\\n$gdb_prompt \" {\n+\t\t    pass $gdb_test_name\n+\t\t}\n+\t    }\n+\n+\t    # Wait a bit, to give time for the threads to hit the\n+\t    # breakpoint.\n+\t    sleep 1\n+\n+\t    set running_count 0\n+\t    set interrupted 0\n+\t    gdb_test_multiple \"info threads\" \"all threads running\" {\n+\t\t-re \"\\\\(running\\\\)\" {\n+\t\t    incr running_count\n+\t\t    exp_continue\n+\t\t}\n+\t\t-re \"Cannot execute this command while the target is running.*$gdb_prompt $\" {\n+\t\t    # Testing against a remote server that doesn't do\n+\t\t    # non-stop mode.  Explicitly interrupt.  This\n+\t\t    # doesn't test the same code paths in GDB, but\n+\t\t    # it's still something.\n+\t\t    set interrupted 1\n+\t\t    gdb_test_multiple \"interrupt\" \"\" {\n+\t\t\t-re \"$gdb_prompt \" {\n+\t\t\t    gdb_test_multiple \"\" $gdb_test_name {\n+\t\t\t\t-re \"received signal SIGINT, Interrupt\" {\n+\t\t\t\t    pass $gdb_test_name\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t\t-re \"$gdb_prompt $\" {\n+\t\t    gdb_assert {$running_count == ($n_threads + 1) * 2} $gdb_test_name\n+\t\t}\n+\t    }\n+\n+\t    gdb_test \"detach\" \"Detaching from.*\"\n+\n+\t    if {!$interrupted} {\n+\t\t# Now test whether inferior 2's thread were really left\n+\t\t# running.  Currently an inline step-over stops all\n+\t\t# threads of all processes.  If detach aborts such a step\n+\t\t# over, then threads of other inferiors should be\n+\t\t# re-resumed.  Test for that by sending a signal to\n+\t\t# inferior 2.\n+\t\tremote_exec target \"kill -SIGUSR1 ${pid_inf2}\"\n+\n+\t\tgdb_test_multiple \"\" \"stop with SIGUSR1\" {\n+\t\t    -re \"received signal SIGUSR1\" {\n+\t\t\tpass $gdb_test_name\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t    delete_breakpoints\n+\t}\n+    }\n+    kill_wait_spawned_process $test_spawn_id\n+}\n+\n+# The test program exits after a while, in case GDB crashes.  Make it\n+# wait at least as long as we may wait before declaring a time out\n+# failure.\n+set options { \"additional_flags=-DTIMEOUT=$timeout\" debug pthreads }\n+\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile $options] == -1} {\n+    return -1\n+}\n+\n+if ![runto_main] {\n+    return -1\n+}\n+\n+# Probe support for \"set breakpoint condition-evaluation target\".\n+# This setting influences who steps over the breakpoint, the (remote)\n+# target (e.g. gdbserver) or gdb, thus exposing issues on either the\n+# target or gdb.\n+set supports_condition_eval_target 1\n+set cmd \"set breakpoint condition-evaluation target\"\n+gdb_test_multiple $cmd \"probe condition-evaluation target support\" {\n+    -re \"warning: Target does not support breakpoint condition evaluation.\\r\\nUsing host evaluation mode instead.\\r\\n$gdb_prompt $\" {\n+\t# Target doesn't support breakpoint condition evaluation on\n+\t# its side.\n+\tset supports_condition_eval_target 0\n+\tpass $gdb_test_name\n+    }\n+    -re \"^$cmd\\r\\n$gdb_prompt $\" {\n+\tpass $gdb_test_name\n+    }\n+}\n+\n+foreach_with_prefix breakpoint-condition-evaluation {\"host\" \"target\"} {\n+    if {!$supports_condition_eval_target && ${breakpoint-condition-evaluation} == \"target\"} {\n+\tcontinue\n+    }\n+\n+    foreach_with_prefix target-non-stop {\"off\" \"on\"} {\n+\tforeach_with_prefix non-stop {\"off\" \"on\"} {\n+\t    if {${non-stop} && !${target-non-stop}} {\n+\t\t# \"set non-stop\" overrides \"maint set\n+\t\t# target-non-stop\", no use testing this combination.\n+\t\tcontinue\n+\t    }\n+\n+\t    foreach_with_prefix displaced {\"off\" \"auto\"} {\n+\t\ttest ${breakpoint-condition-evaluation} ${target-non-stop} ${non-stop} ${displaced}\n+\t    }\n+\t}\n+    }\n+}"
    }
  ]
}