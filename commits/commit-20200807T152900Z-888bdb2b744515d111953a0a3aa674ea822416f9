{
  "sha": "888bdb2b744515d111953a0a3aa674ea822416f9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODg4YmRiMmI3NDQ1MTVkMTExOTUzYTBhM2FhNjc0ZWE4MjI0MTZmOQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-07T15:28:52Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-07T15:29:00Z"
    },
    "message": "gdb: change regcache list to be a map\n\nOne regcache object is created for each stopped thread and is stored in\nthe regcache::regcaches linked list.  Looking up a regcache for a given\nthread is therefore in O(number of threads).  Stopping all threads then\nbecomes O((number of threads) ^ 2).  Same goes for resuming a thread\n(need to delete the regcache of a given ptid) and resuming all threads.\nIt becomes noticeable when debugging thousands of threads, which is\ntypical with GPU targets.  This patch replaces the linked list with some\nmaps to reduce that complexity.\n\nThe first design was using an std::unordered_map with (target, ptid,\narch) as the key, because that's how lookups are done (in\nget_thread_arch_aspace_regcache).  However, the registers_changed_ptid\nfunction, also somewhat on the hot path (it is used when resuming\nthreads), needs to delete all regcaches associated to a given (target,\nptid) tuple.  If the key of the map is (target, ptid, arch), we have to\nwalk all items of the map, not good.\n\nThe second design was therefore using an std::unordered_multimap with\n(target, ptid) as the key.  One key could be associated to multiple\nregcaches, all with different gdbarches.  When looking up, we would have\nto walk all these regcaches.  This would be ok, because there will\nusually be actually one matching regcache.  In the exceptional\nmulti-arch thread cases, there will be maybe two.  However, in\nregisters_changed_ptid, we sometimes need to remove all regcaches\nmatching a given target.  We would then have to talk all items of the\nmap again, not good.\n\nThe design as implemented in this patch therefore uses two levels of\nmap.  One std::unordered_map uses the target as the key.  The value type\nis an std::unordered_multimap that itself uses the ptid as the key.  The\nvalues of the multimap are the regcaches themselves.  Again, we expect\nto have one or very few regcaches per (target, ptid).\n\nSo, in summary:\n\n* The lookups (in get_thread_arch_aspace_regcache), become faster when\n  the number of threads grows, compared to the linked list.  With a\n  small number of threads, it will probably be a bit slower to do map\n  lookups than to walk a few linked list nodes, but I don't think it\n  will be noticeable in practice.\n\n* The function registers_changed_ptid deletes all regcaches related to a\n  given (target, ptid).  It must now handle the different cases separately:\n\n    - NULL target and minus_one_ptid: we delete all the entries\n    - NULL target and non-minus_one_ptid: invalid (checked by assert)\n    - non-NULL target and non-minus_one_ptid: we delete all the entries\n      associated to that tuple\n    - a non-NULL target and minus_one_ptid: we delete all the entries\n      associated to that target\n\n* The function regcache_thread_ptid_changed is called when a thread\n  changes ptid.  It is implemented efficiently using the map, although\n  that's not very important: it is not called often, mostly when\n  creating an inferior, on some specific platforms.\n\nThis patch is a tiny bit from ROCm GDB [1] we would like to merge\nupstream.  Laurent Morichetti gave be these performance numbers:\n\nThe benchmark used is:\n\n  time ./gdb --data-directory=data-directory /extra/lmoriche/hip/samples/0_Intro/bit_extract/bit_extract -ex \"set pagination off\" -ex \"set breakpoint pending on\" -ex \"b bit_extract_kernel if \\$_thread == 5\" -ex run -ex c -batch\n\nIt measures the time it takes to continue from a conditional breakpoint with\n2048 threads at that breakpoint, one of them reporting the breakpoint.\n\nbaseline:\nreal    0m10.227s\nreal    0m10.177s\nreal    0m10.362s\n\nwith patch:\nreal    0m8.356s\nreal    0m8.424s\nreal    0m8.494s\n\n[1] https://github.com/ROCm-Developer-Tools/ROCgdb\n\ngdb/ChangeLog:\n\n\t* regcache.c (ptid_regcache_map): New type.\n\t(target_ptid_regcache_map): New type.\n\t(regcaches): Change type to target_ptid_regcache_map.\n\t(get_thread_arch_aspace_regcache): Update to regcaches' new\n\ttype.\n\t(regcache_thread_ptid_changed): Likewise.\n\t(registers_changed_ptid): Likewise.\n\t(regcaches_size): Likewise.\n\t(regcaches_test): Update.\n\t(regcache_thread_ptid_changed): Update.\n\t* regcache.h (regcache_up): New type.\n\t* gdbsupport/ptid.h (hash_ptid): New struct.\n\nChange-Id: Iabb0a1111707936ca111ddb13f3b09efa83d3402",
    "tree": {
      "sha": "24407e8f85a294f5adad480644a0461255d0bbe8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/24407e8f85a294f5adad480644a0461255d0bbe8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/888bdb2b744515d111953a0a3aa674ea822416f9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/888bdb2b744515d111953a0a3aa674ea822416f9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/888bdb2b744515d111953a0a3aa674ea822416f9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/888bdb2b744515d111953a0a3aa674ea822416f9/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b161a60d1fe2a7383c7940815687c6100b97204e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b161a60d1fe2a7383c7940815687c6100b97204e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b161a60d1fe2a7383c7940815687c6100b97204e"
    }
  ],
  "stats": {
    "total": 167,
    "additions": 125,
    "deletions": 42
  },
  "files": [
    {
      "sha": "88583bd73d54762b121da708d01d436475215cde",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/888bdb2b744515d111953a0a3aa674ea822416f9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/888bdb2b744515d111953a0a3aa674ea822416f9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=888bdb2b744515d111953a0a3aa674ea822416f9",
      "patch": "@@ -1,3 +1,18 @@\n+2020-08-07  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* regcache.c (ptid_regcache_map): New type.\n+\t(target_ptid_regcache_map): New type.\n+\t(regcaches): Change type to target_ptid_regcache_map.\n+\t(get_thread_arch_aspace_regcache): Update to regcaches' new\n+\ttype.\n+\t(regcache_thread_ptid_changed): Likewise.\n+\t(registers_changed_ptid): Likewise.\n+\t(regcaches_size): Likewise.\n+\t(regcaches_test): Update.\n+\t(regcache_thread_ptid_changed): Update.\n+\t* regcache.h (regcache_up): New type.\n+\t* gdbsupport/ptid.h (hash_ptid): New struct.\n+\n 2020-08-07  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* observable.h (thread_ptid_changed): Add parameter"
    },
    {
      "sha": "b8fcc5286005ac9d380240b667d61b7f311952ea",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 92,
      "deletions": 42,
      "changes": 134,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/888bdb2b744515d111953a0a3aa674ea822416f9/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/888bdb2b744515d111953a0a3aa674ea822416f9/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=888bdb2b744515d111953a0a3aa674ea822416f9",
      "patch": "@@ -29,7 +29,7 @@\n #include \"reggroups.h\"\n #include \"observable.h\"\n #include \"regset.h\"\n-#include <forward_list>\n+#include <unordered_map>\n \n /*\n  * DATA STRUCTURE\n@@ -313,31 +313,48 @@ reg_buffer::assert_regnum (int regnum) const\n     gdb_assert (regnum < gdbarch_num_regs (arch ()));\n }\n \n-/* Global structure containing the current regcache.  */\n+/* Type to map a ptid to a list of regcaches (one thread may have multiple\n+   regcaches, associated to different gdbarches).  */\n+\n+using ptid_regcache_map\n+  = std::unordered_multimap<ptid_t, regcache_up, hash_ptid>;\n+\n+/* Type to map a target to a ptid_regcache_map, holding the regcaches for the\n+   threads defined by that target.  */\n+\n+using target_ptid_regcache_map\n+  = std::unordered_map<process_stratum_target *, ptid_regcache_map>;\n+\n+/* Global structure containing the existing regcaches.  */\n \n /* NOTE: this is a write-through cache.  There is no \"dirty\" bit for\n    recording if the register values have been changed (eg. by the\n    user).  Therefore all registers must be written back to the\n    target when appropriate.  */\n-static std::forward_list<regcache *> regcaches;\n+static target_ptid_regcache_map regcaches;\n \n struct regcache *\n get_thread_arch_aspace_regcache (process_stratum_target *target,\n-\t\t\t\t ptid_t ptid, struct gdbarch *gdbarch,\n+\t\t\t\t ptid_t ptid, gdbarch *arch,\n \t\t\t\t struct address_space *aspace)\n {\n   gdb_assert (target != nullptr);\n \n-  for (const auto &regcache : regcaches)\n-    if (regcache->target () == target\n-\t&& regcache->ptid () == ptid\n-\t&& regcache->arch () == gdbarch)\n-      return regcache;\n+  /* Find the ptid -> regcache map for this target.  */\n+  auto &ptid_regc_map = regcaches[target];\n \n-  regcache *new_regcache = new regcache (target, gdbarch, aspace);\n+  /* Check first if a regcache for this arch already exists.  */\n+  auto range = ptid_regc_map.equal_range (ptid);\n+  for (auto it = range.first; it != range.second; ++it)\n+    {\n+      if (it->second->arch () == arch)\n+\treturn it->second.get ();\n+    }\n \n-  regcaches.push_front (new_regcache);\n+  /* It does not exist, create it.  */\n+  regcache *new_regcache = new regcache (target, arch, aspace);\n   new_regcache->set_ptid (ptid);\n+  ptid_regc_map.insert (std::make_pair (ptid, new_regcache));\n \n   return new_regcache;\n }\n@@ -417,10 +434,22 @@ static void\n regcache_thread_ptid_changed (process_stratum_target *target,\n \t\t\t      ptid_t old_ptid, ptid_t new_ptid)\n {\n-  for (auto &regcache : regcaches)\n+  auto ptid_regc_map_it = regcaches.find (target);\n+\n+  if (ptid_regc_map_it == regcaches.end ())\n+    return;\n+\n+  auto &ptid_regc_map = ptid_regc_map_it->second;\n+  auto range = ptid_regc_map.equal_range (old_ptid);\n+  for (auto it = range.first; it != range.second;)\n     {\n-      if (regcache->ptid () == old_ptid && regcache->target () == target)\n-\tregcache->set_ptid (new_ptid);\n+      regcache_up rc = std::move (it->second);\n+      rc->set_ptid (new_ptid);\n+\n+      /* Remove old before inserting new, to avoid rehashing,\n+\t which would invalidate iterators.  */\n+      it = ptid_regc_map.erase (it);\n+      ptid_regc_map.insert (std::make_pair (new_ptid, std::move (rc)));\n     }\n }\n \n@@ -438,18 +467,31 @@ regcache_thread_ptid_changed (process_stratum_target *target,\n void\n registers_changed_ptid (process_stratum_target *target, ptid_t ptid)\n {\n-  for (auto oit = regcaches.before_begin (), it = std::next (oit);\n-       it != regcaches.end (); )\n+  if (target == nullptr)\n+    {\n+      /* Since there can be ptid clashes between targets, it's not valid to\n+\t pass a ptid without saying to which target it belongs.  */\n+      gdb_assert (ptid == minus_one_ptid);\n+\n+      /* Delete all the regcaches of all targets.  */\n+      regcaches.clear ();\n+    }\n+  else if (ptid != minus_one_ptid)\n     {\n-      struct regcache *regcache = *it;\n-      if ((target == nullptr || regcache->target () == target)\n-\t  && regcache->ptid ().matches (ptid))\n+      /* Non-NULL target and non-minus_one_ptid, delete all regcaches belonging\n+\tto this (TARGET, PTID).  */\n+      auto ptid_regc_map_it = regcaches.find (target);\n+      if (ptid_regc_map_it != regcaches.end ())\n \t{\n-\t  delete regcache;\n-\t  it = regcaches.erase_after (oit);\n+\t  auto &ptid_regc_map = ptid_regc_map_it->second;\n+\t  ptid_regc_map.erase (ptid);\n \t}\n-      else\n-\toit = it++;\n+    }\n+  else\n+    {\n+       /* Non-NULL target and minus_one_ptid, delete all regcaches\n+\t  associated to this target.  */\n+      regcaches.erase (target);\n     }\n \n   if ((target == nullptr || current_thread_target == target)\n@@ -1434,8 +1476,14 @@ namespace selftests {\n static size_t\n regcaches_size ()\n {\n-  return std::distance (regcaches.begin (),\n-\t\t\t  regcaches.end ());\n+  size_t size = 0;\n+  for (auto it = regcaches.begin (); it != regcaches.end (); ++it)\n+    {\n+      auto &ptid_regc_map = it->second;\n+      size += ptid_regc_map.size ();\n+    }\n+\n+  return size;\n }\n \n /* Wrapper around get_thread_arch_aspace_regcache that does some self checks.  */\n@@ -1852,31 +1900,33 @@ regcache_thread_ptid_changed ()\n   get_thread_arch_aspace_regcache (&target2.mock_target, old_ptid, arch,\n \t\t\t\t   nullptr);\n \n-  /* Return whether a regcache for (TARGET, PTID) exists in REGCACHES.  */\n-  auto regcache_exists = [] (process_stratum_target *target, ptid_t ptid)\n+  /* Return the count of regcaches for (TARGET, PTID) in REGCACHES.  */\n+  auto regcache_count = [] (process_stratum_target *target, ptid_t ptid)\n+    -> int\n     {\n-      for (regcache *rc : regcaches)\n+      auto ptid_regc_map_it = regcaches.find (target);\n+      if (ptid_regc_map_it != regcaches.end ())\n \t{\n-\t  if (rc->target () == target && rc->ptid () == ptid)\n-\t    return true;\n+\t  auto &ptid_regc_map = ptid_regc_map_it->second;\n+\t  auto range = ptid_regc_map.equal_range (ptid);\n+\t  return std::distance (range.first, range.second);\n \t}\n-\n-      return false;\n+      return 0;\n     };\n \n-  gdb_assert (regcaches_size () == 2);\n-  gdb_assert (regcache_exists (&target1.mock_target, old_ptid));\n-  gdb_assert (!regcache_exists (&target1.mock_target, new_ptid));\n-  gdb_assert (regcache_exists (&target2.mock_target, old_ptid));\n-  gdb_assert (!regcache_exists (&target2.mock_target, new_ptid));\n+  gdb_assert (regcaches.size () == 2);\n+  gdb_assert (regcache_count (&target1.mock_target, old_ptid) == 1);\n+  gdb_assert (regcache_count (&target1.mock_target, new_ptid) == 0);\n+  gdb_assert (regcache_count (&target2.mock_target, old_ptid) == 1);\n+  gdb_assert (regcache_count (&target2.mock_target, new_ptid) == 0);\n \n   thread_change_ptid (&target1.mock_target, old_ptid, new_ptid);\n \n-  gdb_assert (regcaches_size () == 2);\n-  gdb_assert (!regcache_exists (&target1.mock_target, old_ptid));\n-  gdb_assert (regcache_exists (&target1.mock_target, new_ptid));\n-  gdb_assert (regcache_exists (&target2.mock_target, old_ptid));\n-  gdb_assert (!regcache_exists (&target2.mock_target, new_ptid));\n+  gdb_assert (regcaches.size () == 2);\n+  gdb_assert (regcache_count (&target1.mock_target, old_ptid) == 0);\n+  gdb_assert (regcache_count (&target1.mock_target, new_ptid) == 1);\n+  gdb_assert (regcache_count (&target2.mock_target, old_ptid) == 1);\n+  gdb_assert (regcache_count (&target2.mock_target, new_ptid) == 0);\n \n   /* Leave the regcache list empty.  */\n   registers_changed ();"
    },
    {
      "sha": "9390f5708ea40480e4d33c1cebb2607a9fa3df78",
      "filename": "gdb/regcache.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/888bdb2b744515d111953a0a3aa674ea822416f9/gdb/regcache.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/888bdb2b744515d111953a0a3aa674ea822416f9/gdb/regcache.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.h?ref=888bdb2b744515d111953a0a3aa674ea822416f9",
      "patch": "@@ -435,6 +435,8 @@ class regcache : public detached_regcache\n \t\t\t\t   struct address_space *aspace);\n };\n \n+using regcache_up = std::unique_ptr<regcache>;\n+\n class readonly_detached_regcache : public readable_regcache\n {\n public:"
    },
    {
      "sha": "a528312bad5e79d81d32b5b01d3a541b2d1d2584",
      "filename": "gdbsupport/ptid.h",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/888bdb2b744515d111953a0a3aa674ea822416f9/gdbsupport/ptid.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/888bdb2b744515d111953a0a3aa674ea822416f9/gdbsupport/ptid.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/ptid.h?ref=888bdb2b744515d111953a0a3aa674ea822416f9",
      "patch": "@@ -32,6 +32,8 @@\n    thread_stratum target that might want to sit on top.\n */\n \n+#include <functional>\n+\n class ptid_t\n {\n public:\n@@ -143,6 +145,20 @@ class ptid_t\n   long m_tid;\n };\n \n+/* Functor to hash a ptid.  */\n+\n+struct hash_ptid\n+{\n+  size_t operator() (const ptid_t &ptid) const\n+  {\n+    std::hash<long> long_hash;\n+\n+    return (long_hash (ptid.pid ())\n+\t    + long_hash (ptid.lwp ())\n+\t    + long_hash (ptid.tid ()));\n+  }\n+};\n+\n /* The null or zero ptid, often used to indicate no process. */\n \n extern const ptid_t null_ptid;"
    }
  ]
}