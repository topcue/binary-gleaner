{
  "sha": "680d7fd5fcff860a31021845389d4dfeb7b42e3c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjgwZDdmZDVmY2ZmODYwYTMxMDIxODQ1Mzg5ZDRkZmViN2I0MmUzYw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-04-24T12:50:01Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-04-25T18:59:35Z"
    },
    "message": "Avoid undefined behavior in Guile exception handling\n\nThe Guile code will longjmp (via scm_throw) when an object requiring\ndestruction is on the stack.  This is undefined behavior.\n\nThis changes this code to run any destructors in inner scopes, and to\npass a POD to gdbscm_throw_gdb_exception.\n\ngdb/ChangeLog\n2019-04-25  Tom Tromey  <tromey@adacore.com>\n\n\t* guile/scm-exception.c (gdbscm_scm_from_gdb_exception)\n\t(gdbscm_throw_gdb_exception): Take a gdbscm_gdb_exception.\n\t* guile/scm-block.c, guile/scm-breakpoint.c, guile/scm-cmd.c,\n\tguile/scm-disasm.c, guile/scm-frame.c, guile/scm-lazy-string.c,\n\tguile/scm-math.c, guile/scm-param.c, guile/scm-ports.c,\n\tguile/scm-symbol.c, guile/scm-symtab.c, guile/scm-type.c,\n\tguile/scm-value.c: Use unpack.\n\t* guile/guile-internal.h (gdbscm_scm_from_gdb_exception): Take a\n\tgdbscm_gdb_exception.\n\t(gdbscm_throw_gdb_exception): Likewise.\n\t(struct gdbscm_gdb_exception): New.\n\t(unpack): New function.\n\t(gdbscm_wrap): Use unpack.",
    "tree": {
      "sha": "0065f8d560b3148a3a3dceb5e3e34ab724cc7cba",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0065f8d560b3148a3a3dceb5e3e34ab724cc7cba"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/680d7fd5fcff860a31021845389d4dfeb7b42e3c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/680d7fd5fcff860a31021845389d4dfeb7b42e3c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/680d7fd5fcff860a31021845389d4dfeb7b42e3c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/680d7fd5fcff860a31021845389d4dfeb7b42e3c/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c6fdd8b2052baa9b7a27d4d34f109c9622b53509",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c6fdd8b2052baa9b7a27d4d34f109c9622b53509",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c6fdd8b2052baa9b7a27d4d34f109c9622b53509"
    }
  ],
  "stats": {
    "total": 317,
    "additions": 235,
    "deletions": 82
  },
  "files": [
    {
      "sha": "ce3ea81aee3a9320fe4d1acf247cbf4007ce3875",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -1,3 +1,19 @@\n+2019-04-25  Tom Tromey  <tromey@adacore.com>\n+\n+\t* guile/scm-exception.c (gdbscm_scm_from_gdb_exception)\n+\t(gdbscm_throw_gdb_exception): Take a gdbscm_gdb_exception.\n+\t* guile/scm-block.c, guile/scm-breakpoint.c, guile/scm-cmd.c,\n+\tguile/scm-disasm.c, guile/scm-frame.c, guile/scm-lazy-string.c,\n+\tguile/scm-math.c, guile/scm-param.c, guile/scm-ports.c,\n+\tguile/scm-symbol.c, guile/scm-symtab.c, guile/scm-type.c,\n+\tguile/scm-value.c: Use unpack.\n+\t* guile/guile-internal.h (gdbscm_scm_from_gdb_exception): Take a\n+\tgdbscm_gdb_exception.\n+\t(gdbscm_throw_gdb_exception): Likewise.\n+\t(struct gdbscm_gdb_exception): New.\n+\t(unpack): New function.\n+\t(gdbscm_wrap): Use unpack.\n+\n 2019-04-25  Tom Tromey  <tromey@adacore.com>\n \n \t* event-top.c (gdb_rl_callback_read_char_wrapper_noexcept)"
    },
    {
      "sha": "8ea87065f9de2250294d0251710db8d4f52ef55f",
      "filename": "gdb/guile/guile-internal.h",
      "status": "modified",
      "additions": 35,
      "deletions": 3,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/guile-internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/guile-internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/guile-internal.h?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -353,9 +353,11 @@ extern void gdbscm_misc_error (const char *subr, int arg_pos,\n \n extern void gdbscm_throw (SCM exception) ATTRIBUTE_NORETURN;\n \n-extern SCM gdbscm_scm_from_gdb_exception (struct gdb_exception exception);\n+struct gdbscm_gdb_exception;\n+extern SCM gdbscm_scm_from_gdb_exception\n+  (const gdbscm_gdb_exception &exception);\n \n-extern void gdbscm_throw_gdb_exception (struct gdb_exception exception)\n+extern void gdbscm_throw_gdb_exception (gdbscm_gdb_exception exception)\n   ATTRIBUTE_NORETURN;\n \n extern void gdbscm_print_exception_with_stack (SCM port, SCM stack,\n@@ -650,6 +652,33 @@ extern void gdbscm_initialize_values (void);\n    with a TRY/CATCH, because the dtors won't otherwise be run when a\n    Guile exceptions is thrown.  */\n \n+/* This is a destructor-less clone of gdb_exception.  */\n+\n+struct gdbscm_gdb_exception\n+{\n+  enum return_reason reason;\n+  enum errors error;\n+  /* The message is xmalloc'd.  */\n+  char *message;\n+};\n+\n+/* Return a gdbscm_gdb_exception representing EXC.  */\n+\n+inline gdbscm_gdb_exception\n+unpack (const gdb_exception &exc)\n+{\n+  gdbscm_gdb_exception result;\n+  result.reason = exc.reason;\n+  result.error = exc.error;\n+  if (exc.message == nullptr)\n+    result.message = nullptr;\n+  else\n+    result.message = xstrdup (exc.message->c_str ());\n+  /* The message should be NULL iff the reason is zero.  */\n+  gdb_assert ((result.reason == 0) == (result.message == nullptr));\n+  return result;\n+}\n+\n /* Use this after a TRY/CATCH to throw the appropriate Scheme\n    exception if a GDB error occurred.  */\n \n@@ -676,16 +705,19 @@ SCM\n gdbscm_wrap (Function &&func, Args &&... args)\n {\n   SCM result = SCM_BOOL_F;\n+  gdbscm_gdb_exception exc {};\n \n   try\n     {\n       result = func (std::forward<Args> (args)...);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n+\n   if (gdbscm_is_exception (result))\n     gdbscm_throw (result);\n "
    },
    {
      "sha": "fbb2f4ae1d83f1b38aca6c51b5e104cf3865e20a",
      "filename": "gdb/guile/scm-block.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-block.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-block.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-block.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -680,6 +680,7 @@ gdbscm_lookup_block (SCM pc_scm)\n \n   gdbscm_parse_function_args (FUNC_NAME, SCM_ARG1, NULL, \"U\", pc_scm, &pc);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       cust = find_pc_compunit_symtab (pc);\n@@ -689,9 +690,10 @@ gdbscm_lookup_block (SCM pc_scm)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (cust == NULL || COMPUNIT_OBJFILE (cust) == NULL)\n     {\n       gdbscm_out_of_range_error (FUNC_NAME, SCM_ARG1, pc_scm,"
    },
    {
      "sha": "9a4efee92dc2b0710e27932547f2db7621fbdca4",
      "filename": "gdb/guile/scm-breakpoint.c",
      "status": "modified",
      "additions": 23,
      "deletions": 10,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-breakpoint.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -411,7 +411,7 @@ gdbscm_register_breakpoint_x (SCM self)\n {\n   breakpoint_smob *bp_smob\n     = bpscm_get_breakpoint_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n-  struct gdb_exception except;\n+  gdbscm_gdb_exception except {};\n   const char *location, *copy;\n \n   /* We only support registering breakpoints created with make-breakpoint.  */\n@@ -467,7 +467,7 @@ gdbscm_register_breakpoint_x (SCM self)\n     }\n   catch (const gdb_exception &ex)\n     {\n-      except = ex;\n+      except = unpack (ex);\n     }\n \n   /* Ensure this gets reset, even if there's an error.  */\n@@ -489,15 +489,17 @@ gdbscm_delete_breakpoint_x (SCM self)\n   breakpoint_smob *bp_smob\n     = bpscm_get_valid_breakpoint_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       delete_breakpoint (bp_smob->bp);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return SCM_UNSPECIFIED;\n }\n \n@@ -586,6 +588,7 @@ gdbscm_set_breakpoint_enabled_x (SCM self, SCM newvalue)\n   SCM_ASSERT_TYPE (gdbscm_is_bool (newvalue), newvalue, SCM_ARG2, FUNC_NAME,\n \t\t   _(\"boolean\"));\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       if (gdbscm_is_true (newvalue))\n@@ -595,9 +598,10 @@ gdbscm_set_breakpoint_enabled_x (SCM self, SCM newvalue)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return SCM_UNSPECIFIED;\n }\n \n@@ -623,15 +627,17 @@ gdbscm_set_breakpoint_silent_x (SCM self, SCM newvalue)\n   SCM_ASSERT_TYPE (gdbscm_is_bool (newvalue), newvalue, SCM_ARG2, FUNC_NAME,\n \t\t   _(\"boolean\"));\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       breakpoint_set_silent (bp_smob->bp, gdbscm_is_true (newvalue));\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return SCM_UNSPECIFIED;\n }\n \n@@ -663,15 +669,17 @@ gdbscm_set_breakpoint_ignore_count_x (SCM self, SCM newvalue)\n   if (value < 0)\n     value = 0;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       set_ignore_count (bp_smob->number, (int) value, 0);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return SCM_UNSPECIFIED;\n }\n \n@@ -783,15 +791,17 @@ gdbscm_set_breakpoint_task_x (SCM self, SCM newvalue)\n     {\n       id = scm_to_long (newvalue);\n \n+      gdbscm_gdb_exception exc {};\n       try\n \t{\n \t  valid_id = valid_task_id (id);\n \t}\n       catch (const gdb_exception &except)\n \t{\n-\t  GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+\t  exc = unpack (except);\n \t}\n \n+      GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n       if (! valid_id)\n \t{\n \t  gdbscm_out_of_range_error (FUNC_NAME, SCM_ARG2, newvalue,\n@@ -803,15 +813,17 @@ gdbscm_set_breakpoint_task_x (SCM self, SCM newvalue)\n   else\n     SCM_ASSERT_TYPE (0, newvalue, SCM_ARG2, FUNC_NAME, _(\"integer or #f\"));\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       breakpoint_set_task (bp_smob->bp, id);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return SCM_UNSPECIFIED;\n }\n \n@@ -968,17 +980,18 @@ gdbscm_breakpoint_commands (SCM self)\n   string_file buf;\n \n   current_uiout->redirect (&buf);\n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       print_command_lines (current_uiout, breakpoint_commands (bp), 0);\n     }\n   catch (const gdb_exception &except)\n     {\n-      current_uiout->redirect (NULL);\n-      gdbscm_throw_gdb_exception (except);\n+      exc = unpack (except);\n     }\n \n   current_uiout->redirect (NULL);\n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   result = gdbscm_scm_from_c_string (buf.c_str ());\n \n   return result;"
    },
    {
      "sha": "f2fa40e453b8bb132c8a07d8e54a22fdb201bd60",
      "filename": "gdb/guile/scm-cmd.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-cmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-cmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-cmd.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -758,6 +758,7 @@ gdbscm_register_command_x (SCM self)\n   c_smob->cmd_name = gdbscm_gc_xstrdup (cmd_name);\n   xfree (cmd_name);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       if (c_smob->is_prefix)\n@@ -778,8 +779,9 @@ gdbscm_register_command_x (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n \n   /* Note: At this point the command exists in gdb.\n      So no more errors after this point.  */"
    },
    {
      "sha": "6b34a229942d8a63f35142b48fbd9392b476db74",
      "filename": "gdb/guile/scm-disasm.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-disasm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-disasm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-disasm.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -247,6 +247,7 @@ gdbscm_arch_disassemble (SCM self, SCM start_scm, SCM rest)\n       int insn_len = 0;\n       string_file buf;\n \n+      gdbscm_gdb_exception exc {};\n       try\n \t{\n \t  if (using_port)\n@@ -259,9 +260,10 @@ gdbscm_arch_disassemble (SCM self, SCM start_scm, SCM rest)\n \t}\n       catch (const gdb_exception &except)\n \t{\n-\t  GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+\t  exc = unpack (except);\n \t}\n \n+      GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n       result = scm_cons (dascm_make_insn (pc, buf.c_str (), insn_len),\n \t\t\t result);\n "
    },
    {
      "sha": "e519ad808598f58426e9ecd82f316096e7236fd9",
      "filename": "gdb/guile/scm-exception.c",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-exception.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-exception.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-exception.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -428,7 +428,7 @@ gdbscm_throw (SCM exception)\n /* Convert a GDB exception to a <gdb:exception> object.  */\n \n SCM\n-gdbscm_scm_from_gdb_exception (struct gdb_exception exception)\n+gdbscm_scm_from_gdb_exception (const gdbscm_gdb_exception &exception)\n {\n   SCM key;\n \n@@ -446,17 +446,19 @@ gdbscm_scm_from_gdb_exception (struct gdb_exception exception)\n \n   return gdbscm_make_error (key, NULL, \"~A\",\n \t\t\t    scm_list_1 (gdbscm_scm_from_c_string\n-\t\t\t\t\t(exception.what ())),\n+\t\t\t\t\t(exception.message)),\n \t\t\t    SCM_BOOL_F);\n }\n \n /* Convert a GDB exception to the appropriate Scheme exception and throw it.\n    This function does not return.  */\n \n void\n-gdbscm_throw_gdb_exception (struct gdb_exception exception)\n+gdbscm_throw_gdb_exception (gdbscm_gdb_exception exception)\n {\n-  gdbscm_throw (gdbscm_scm_from_gdb_exception (exception));\n+  SCM scm_exception = gdbscm_scm_from_gdb_exception (exception);\n+  xfree (exception.message);\n+  gdbscm_throw (scm_exception);\n }\n \n /* Print the error message portion of an exception."
    },
    {
      "sha": "0345ac62ff7f19ae96946d1311dedb9eaf7e66ff",
      "filename": "gdb/guile/scm-frame.c",
      "status": "modified",
      "additions": 52,
      "deletions": 21,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-frame.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -250,7 +250,7 @@ frscm_scm_from_frame (struct frame_info *frame, struct inferior *inferior)\n     }\n   catch (const gdb_exception &except)\n     {\n-      return gdbscm_scm_from_gdb_exception (except);\n+      return gdbscm_scm_from_gdb_exception (unpack (except));\n     }\n \n   f_scm = frscm_make_frame_smob ();\n@@ -396,15 +396,17 @@ gdbscm_frame_valid_p (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return scm_from_bool (frame != NULL);\n }\n \n@@ -423,6 +425,7 @@ gdbscm_frame_name (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -431,9 +434,10 @@ gdbscm_frame_name (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -460,6 +464,7 @@ gdbscm_frame_type (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -468,9 +473,10 @@ gdbscm_frame_type (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -491,15 +497,17 @@ gdbscm_frame_arch (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -521,15 +529,17 @@ gdbscm_frame_unwind_stop_reason (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -553,6 +563,7 @@ gdbscm_frame_pc (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -561,9 +572,10 @@ gdbscm_frame_pc (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -585,6 +597,7 @@ gdbscm_frame_block (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -593,9 +606,10 @@ gdbscm_frame_block (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -635,6 +649,7 @@ gdbscm_frame_function (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -643,9 +658,10 @@ gdbscm_frame_function (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -671,6 +687,7 @@ gdbscm_frame_older (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -679,9 +696,10 @@ gdbscm_frame_older (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -707,6 +725,7 @@ gdbscm_frame_newer (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -715,9 +734,10 @@ gdbscm_frame_newer (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -742,6 +762,7 @@ gdbscm_frame_sal (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -750,9 +771,10 @@ gdbscm_frame_sal (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -777,7 +799,7 @@ gdbscm_frame_read_register (SCM self, SCM register_scm)\n   gdbscm_parse_function_args (FUNC_NAME, SCM_ARG2, NULL, \"s\",\n \t\t\t      register_scm, &register_str);\n \n-  struct gdb_exception except;\n+  gdbscm_gdb_exception except {};\n \n   try\n     {\n@@ -795,7 +817,7 @@ gdbscm_frame_read_register (SCM self, SCM register_scm)\n     }\n   catch (const gdb_exception &ex)\n     {\n-      except = ex;\n+      except = unpack (ex);\n     }\n \n   xfree (register_str);\n@@ -838,15 +860,17 @@ gdbscm_frame_read_var (SCM self, SCM symbol_scm, SCM rest)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -864,7 +888,7 @@ gdbscm_frame_read_var (SCM self, SCM symbol_scm, SCM rest)\n     }\n   else if (scm_is_string (symbol_scm))\n     {\n-      struct gdb_exception except;\n+      gdbscm_gdb_exception except {};\n \n       if (! SCM_UNBNDP (block_scm))\n \t{\n@@ -896,7 +920,7 @@ gdbscm_frame_read_var (SCM self, SCM symbol_scm, SCM rest)\n \t  }\n \tcatch (const gdb_exception &ex)\n \t  {\n-\t    except = ex;\n+\t    except = unpack (ex);\n \t  }\n       }\n \n@@ -919,9 +943,10 @@ gdbscm_frame_read_var (SCM self, SCM symbol_scm, SCM rest)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return vlscm_scm_from_value (value);\n }\n \n@@ -936,6 +961,7 @@ gdbscm_frame_select (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n@@ -944,9 +970,10 @@ gdbscm_frame_select (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (frame == NULL)\n     {\n       gdbscm_invalid_object_error (FUNC_NAME, SCM_ARG1, self,\n@@ -964,15 +991,17 @@ gdbscm_newest_frame (void)\n {\n   struct frame_info *frame = NULL;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = get_current_frame ();\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return frscm_scm_from_frame_unsafe (frame, current_inferior ());\n }\n \n@@ -984,15 +1013,17 @@ gdbscm_selected_frame (void)\n {\n   struct frame_info *frame = NULL;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       frame = get_selected_frame (_(\"No frame is currently selected\"));\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return frscm_scm_from_frame_unsafe (frame, current_inferior ());\n }\n "
    },
    {
      "sha": "b0bbc827c8fb3929f91ec6d4b0c1478de50d3417",
      "filename": "gdb/guile/scm-lazy-string.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-lazy-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-lazy-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-lazy-string.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -338,7 +338,7 @@ lsscm_safe_lazy_string_to_value (SCM string, int arg_pos,\n     }\n   catch (const gdb_exception &except)\n     {\n-      *except_scmp = gdbscm_scm_from_gdb_exception (except);\n+      *except_scmp = gdbscm_scm_from_gdb_exception (unpack (except));\n       return NULL;\n     }\n "
    },
    {
      "sha": "35ad4aa6035fd25a766bea6733705d7b8967b79b",
      "filename": "gdb/guile/scm-math.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-math.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-math.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-math.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -826,7 +826,7 @@ vlscm_convert_typed_value_from_scheme (const char *func_name,\n     }\n   catch (const gdb_exception &except)\n     {\n-      except_scm = gdbscm_scm_from_gdb_exception (except);\n+      except_scm = gdbscm_scm_from_gdb_exception (unpack (except));\n     }\n \n   if (gdbscm_is_true (except_scm))"
    },
    {
      "sha": "53120cb23e0950ebdb3e64bcbff7067a2e11791a",
      "filename": "gdb/guile/scm-param.c",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-param.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-param.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-param.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -1006,6 +1006,7 @@ gdbscm_register_parameter_x (SCM self)\n \t\t_(\"parameter exists, \\\"show\\\" command is already defined\"));\n     }\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       add_setshow_generic (p_smob->type, p_smob->cmd_class,\n@@ -1020,9 +1021,10 @@ gdbscm_register_parameter_x (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   /* Note: At this point the parameter exists in gdb.\n      So no more errors after this point.  */\n \n@@ -1056,7 +1058,7 @@ gdbscm_parameter_value (SCM self)\n       struct cmd_list_element *alias, *prefix, *cmd;\n       char *newarg;\n       int found = -1;\n-      struct gdb_exception except;\n+      gdbscm_gdb_exception except {};\n \n       gdb::unique_xmalloc_ptr<char> name\n \t= gdbscm_scm_to_host_string (self, NULL, &except_scm);\n@@ -1069,7 +1071,7 @@ gdbscm_parameter_value (SCM self)\n \t}\n       catch (const gdb_exception &ex)\n \t{\n-\t  except = ex;\n+\t  except = unpack (ex);\n \t}\n \n       xfree (newarg);"
    },
    {
      "sha": "114b35846ed757932f1dc0ba71f236c001b7be1a",
      "filename": "gdb/guile/scm-ports.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-ports.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-ports.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-ports.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -272,6 +272,7 @@ ioscm_write (SCM port, const void *data, size_t size)\n   if (scm_is_eq (port, input_port_scm))\n     return;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       if (scm_is_eq (port, error_port_scm))\n@@ -281,8 +282,9 @@ ioscm_write (SCM port, const void *data, size_t size)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n }\n \n /* Flush gdb's stdout or stderr.  */"
    },
    {
      "sha": "7b44b56581d0da75adb2782c0350723ea2938b93",
      "filename": "gdb/guile/scm-symbol.c",
      "status": "modified",
      "additions": 13,
      "deletions": 7,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-symbol.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -486,15 +486,17 @@ gdbscm_symbol_needs_frame_p (SCM self)\n   struct symbol *symbol = s_smob->symbol;\n   int result = 0;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       result = symbol_read_needs_frame (symbol);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return scm_from_bool (result);\n }\n \n@@ -538,6 +540,7 @@ gdbscm_symbol_value (SCM self, SCM rest)\n \t\t\t\t _(\"cannot get the value of a typedef\"));\n     }\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       if (f_smob != NULL)\n@@ -558,9 +561,10 @@ gdbscm_symbol_value (SCM self, SCM rest)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return vlscm_scm_from_value (value);\n }\n \f\n@@ -602,6 +606,7 @@ gdbscm_lookup_symbol (SCM name_scm, SCM rest)\n     {\n       struct frame_info *selected_frame;\n \n+      gdbscm_gdb_exception exc {};\n       try\n \t{\n \t  selected_frame = get_selected_frame (_(\"no frame selected\"));\n@@ -610,19 +615,20 @@ gdbscm_lookup_symbol (SCM name_scm, SCM rest)\n       catch (const gdb_exception &ex)\n \t{\n \t  xfree (name);\n-\t  GDBSCM_HANDLE_GDB_EXCEPTION (ex);\n+\t  exc = unpack (ex);\n \t}\n+      GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n     }\n \n-  struct gdb_exception except;\n+  gdbscm_gdb_exception except {};\n   try\n     {\n       symbol = lookup_symbol (name, block, (domain_enum) domain,\n \t\t\t      &is_a_field_of_this).symbol;\n     }\n   catch (const gdb_exception &ex)\n     {\n-      except = ex;\n+      except = unpack (ex);\n     }\n \n   xfree (name);\n@@ -646,7 +652,7 @@ gdbscm_lookup_global_symbol (SCM name_scm, SCM rest)\n   int domain_arg_pos = -1;\n   int domain = VAR_DOMAIN;\n   struct symbol *symbol = NULL;\n-  struct gdb_exception except;\n+  gdbscm_gdb_exception except {};\n \n   gdbscm_parse_function_args (FUNC_NAME, SCM_ARG1, keywords, \"s#i\",\n \t\t\t      name_scm, &name, rest,\n@@ -658,7 +664,7 @@ gdbscm_lookup_global_symbol (SCM name_scm, SCM rest)\n     }\n   catch (const gdb_exception &ex)\n     {\n-      except = ex;\n+      except = unpack (ex);\n     }\n \n   xfree (name);"
    },
    {
      "sha": "e55e49b0333a3f9e33305350ef517115aa0405e4",
      "filename": "gdb/guile/scm-symtab.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-symtab.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -591,6 +591,7 @@ gdbscm_find_pc_line (SCM pc_scm)\n \n   gdbscm_parse_function_args (FUNC_NAME, SCM_ARG1, NULL, \"U\", pc_scm, &pc_ull);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       CORE_ADDR pc = (CORE_ADDR) pc_ull;\n@@ -599,9 +600,10 @@ gdbscm_find_pc_line (SCM pc_scm)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return stscm_scm_from_sal (sal);\n }\n \f"
    },
    {
      "sha": "5b99da70e6eeb59e4cf9639f4ac018eb61df54be",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 30,
      "deletions": 12,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -105,6 +105,7 @@ tyscm_type_smob_type (type_smob *t_smob)\n static std::string\n tyscm_type_name (struct type *type)\n {\n+  SCM excp;\n   try\n     {\n       string_file stb;\n@@ -114,11 +115,10 @@ tyscm_type_name (struct type *type)\n     }\n   catch (const gdb_exception &except)\n     {\n-      SCM excp = gdbscm_scm_from_gdb_exception (except);\n-      gdbscm_throw (excp);\n+      excp = gdbscm_scm_from_gdb_exception (unpack (except));\n     }\n \n-  gdb_assert_not_reached (\"no way to get here\");\n+  gdbscm_throw (excp);\n }\n \f\n /* Administrivia for type smobs.  */\n@@ -234,15 +234,17 @@ tyscm_equal_p_type_smob (SCM type1_scm, SCM type2_scm)\n   type1 = type1_smob->type;\n   type2 = type2_smob->type;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       result = types_deeply_equal (type1, type2);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return scm_from_bool (result);\n }\n \n@@ -650,15 +652,17 @@ gdbscm_type_strip_typedefs (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = check_typedef (type);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return tyscm_scm_from_type (type);\n }\n \n@@ -671,15 +675,17 @@ tyscm_get_composite (struct type *type)\n \n   for (;;)\n     {\n+      gdbscm_gdb_exception exc {};\n       try\n \t{\n \t  type = check_typedef (type);\n \t}\n       catch (const gdb_exception &except)\n \t{\n-\t  GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+\t  exc = unpack (except);\n \t}\n \n+      GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n       if (TYPE_CODE (type) != TYPE_CODE_PTR\n \t  && TYPE_CODE (type) != TYPE_CODE_REF)\n \tbreak;\n@@ -725,6 +731,7 @@ tyscm_array_1 (SCM self, SCM n1_scm, SCM n2_scm, int is_vector,\n \t\t\t\t _(\"Array length must not be negative\"));\n     }\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       array = lookup_array_range_type (type, n1, n2);\n@@ -733,9 +740,10 @@ tyscm_array_1 (SCM self, SCM n1_scm, SCM n2_scm, int is_vector,\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return tyscm_scm_from_type (array);\n }\n \n@@ -781,15 +789,17 @@ gdbscm_type_pointer (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = lookup_pointer_type (type);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return tyscm_scm_from_type (type);\n }\n \n@@ -842,15 +852,17 @@ gdbscm_type_reference (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = lookup_lvalue_reference_type (type);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return tyscm_scm_from_type (type);\n }\n \n@@ -879,15 +891,17 @@ gdbscm_type_const (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = make_cv_type (1, 0, type, NULL);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return tyscm_scm_from_type (type);\n }\n \n@@ -901,15 +915,17 @@ gdbscm_type_volatile (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = make_cv_type (0, 1, type, NULL);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return tyscm_scm_from_type (type);\n }\n \n@@ -923,15 +939,17 @@ gdbscm_type_unqualified (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = make_cv_type (0, 0, type, NULL);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return tyscm_scm_from_type (type);\n }\n \f"
    },
    {
      "sha": "9b382108fb87a91a9c197c09e0459fa5c466f973",
      "filename": "gdb/guile/scm-value.c",
      "status": "modified",
      "additions": 38,
      "deletions": 15,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/680d7fd5fcff860a31021845389d4dfeb7b42e3c/gdb/guile/scm-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-value.c?ref=680d7fd5fcff860a31021845389d4dfeb7b42e3c",
      "patch": "@@ -156,6 +156,7 @@ vlscm_print_value_smob (SCM self, SCM port, scm_print_state *pstate)\n      instead of writingp.  */\n   opts.raw = !!pstate->writingp;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       string_file stb;\n@@ -165,9 +166,10 @@ vlscm_print_value_smob (SCM self, SCM port, scm_print_state *pstate)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (pstate->writingp)\n     scm_puts (\">\", port);\n \n@@ -186,15 +188,17 @@ vlscm_equal_p_value_smob (SCM v1, SCM v2)\n   const value_smob *v2_smob = (value_smob *) SCM_SMOB_DATA (v2);\n   int result = 0;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       result = value_equal (v1_smob->value, v2_smob->value);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return scm_from_bool (result);\n }\n \n@@ -493,6 +497,7 @@ gdbscm_value_dynamic_type (SCM self)\n   if (! SCM_UNBNDP (v_smob->dynamic_type))\n     return v_smob->dynamic_type;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       scoped_value_mark free_values;\n@@ -531,9 +536,10 @@ gdbscm_value_dynamic_type (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (type == NULL)\n     v_smob->dynamic_type = gdbscm_value_type (self);\n   else\n@@ -680,15 +686,17 @@ gdbscm_value_call (SCM self, SCM args)\n   long args_count;\n   struct value **vargs = NULL;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       ftype = check_typedef (value_type (function));\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   SCM_ASSERT_TYPE (TYPE_CODE (ftype) == TYPE_CODE_FUNC, self,\n \t\t   SCM_ARG1, FUNC_NAME,\n \t\t   _(\"function (value of TYPE_CODE_FUNC)\"));\n@@ -746,6 +754,7 @@ gdbscm_value_to_bytevector (SCM self)\n \n   type = value_type (value);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = check_typedef (type);\n@@ -754,9 +763,10 @@ gdbscm_value_to_bytevector (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   bv = scm_c_make_bytevector (length);\n   memcpy (SCM_BYTEVECTOR_CONTENTS (bv), contents, length);\n \n@@ -789,15 +799,17 @@ gdbscm_value_to_bool (SCM self)\n \n   type = value_type (value);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = check_typedef (type);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   SCM_ASSERT_TYPE (is_intlike (type, 1), self, SCM_ARG1, FUNC_NAME,\n \t\t   _(\"integer-like gdb value\"));\n \n@@ -810,9 +822,10 @@ gdbscm_value_to_bool (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   return scm_from_bool (l != 0);\n }\n \n@@ -830,15 +843,17 @@ gdbscm_value_to_integer (SCM self)\n \n   type = value_type (value);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = check_typedef (type);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   SCM_ASSERT_TYPE (is_intlike (type, 1), self, SCM_ARG1, FUNC_NAME,\n \t\t   _(\"integer-like gdb value\"));\n \n@@ -851,9 +866,10 @@ gdbscm_value_to_integer (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   if (TYPE_UNSIGNED (type))\n     return gdbscm_scm_from_ulongest (l);\n   else\n@@ -875,15 +891,17 @@ gdbscm_value_to_real (SCM self)\n \n   type = value_type (value);\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       type = check_typedef (type);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   SCM_ASSERT_TYPE (is_intlike (type, 0) || TYPE_CODE (type) == TYPE_CODE_FLT,\n \t\t   self, SCM_ARG1, FUNC_NAME, _(\"number\"));\n \n@@ -907,9 +925,10 @@ gdbscm_value_to_real (SCM self)\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   /* TODO: Is there a better way to check if the value fits?  */\n   if (!value_equal (value, check))\n     gdbscm_out_of_range_error (FUNC_NAME, SCM_ARG1, self,\n@@ -992,6 +1011,7 @@ gdbscm_value_to_string (SCM self, SCM rest)\n   /* We don't assume anything about the result of scm_port_conversion_strategy.\n      From this point on, if errors is not 'errors, use 'substitute.  */\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       gdb::unique_xmalloc_ptr<gdb_byte> buffer;\n@@ -1001,8 +1021,9 @@ gdbscm_value_to_string (SCM self, SCM rest)\n   catch (const gdb_exception &except)\n     {\n       xfree (encoding);\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n \n   /* If errors is \"error\", scm_from_stringn may throw a Scheme exception.\n      Make sure we don't leak.  This is done via scm_dynwind_begin, et.al.  */\n@@ -1048,7 +1069,7 @@ gdbscm_value_to_lazy_string (SCM self, SCM rest)\n   char *encoding = NULL;\n   int length = -1;\n   SCM result = SCM_BOOL_F; /* -Wall */\n-  struct gdb_exception except;\n+  gdbscm_gdb_exception except {};\n \n   /* The sequencing here, as everywhere else, is important.\n      We can't have existing cleanups when a Scheme exception is thrown.  */\n@@ -1121,7 +1142,7 @@ gdbscm_value_to_lazy_string (SCM self, SCM rest)\n     }\n   catch (const gdb_exception &ex)\n     {\n-      except = ex;\n+      except = unpack (ex);\n     }\n \n   xfree (encoding);\n@@ -1177,15 +1198,17 @@ gdbscm_value_print (SCM self)\n \n   string_file stb;\n \n+  gdbscm_gdb_exception exc {};\n   try\n     {\n       common_val_print (value, &stb, 0, &opts, current_language);\n     }\n   catch (const gdb_exception &except)\n     {\n-      GDBSCM_HANDLE_GDB_EXCEPTION (except);\n+      exc = unpack (except);\n     }\n \n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n   /* Use SCM_FAILED_CONVERSION_QUESTION_MARK to ensure this doesn't\n      throw an error if the encoding fails.\n      IWBN to use scm_take_locale_string here, but we'd have to temporarily"
    }
  ]
}