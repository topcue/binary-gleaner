{
  "sha": "64b653ca7058bfd4f91879dea628809d398b488e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjRiNjUzY2E3MDU4YmZkNGY5MTg3OWRlYTYyODgwOWQzOThiNDg4ZQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-13T23:39:52Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-14T00:03:41Z"
    },
    "message": "Introduce cp_print_value_fields and c_value_print_struct\n\nThis adds cp_print_value_fields and c_value_print_struct, value-based\nanalogues of the corresponding val-printing functions.  Note that the\nModula-2 printing code also calls cp_print_val_fields, and so is\nupdated to call the function function.\n\ngdb/ChangeLog\n2020-03-13  Tom Tromey  <tom@tromey.com>\n\n\t* m2-valprint.c (m2_value_print_inner): Use\n\tcp_print_value_fields.\n\t* cp-valprint.c\t(cp_print_value_fields): New function.\n\t* c-valprint.c (c_value_print_struct): New function.\n\t(c_value_print_inner): Use c_value_print_struct.\n\t* c-lang.h (cp_print_value_fields): Declare.",
    "tree": {
      "sha": "83ea5b40798b6782b733992385d12020bdd9667d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/83ea5b40798b6782b733992385d12020bdd9667d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/64b653ca7058bfd4f91879dea628809d398b488e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64b653ca7058bfd4f91879dea628809d398b488e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/64b653ca7058bfd4f91879dea628809d398b488e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64b653ca7058bfd4f91879dea628809d398b488e/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6999f067c1b30c1a2c3e41a0f68f74e459652560",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6999f067c1b30c1a2c3e41a0f68f74e459652560",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6999f067c1b30c1a2c3e41a0f68f74e459652560"
    }
  ],
  "stats": {
    "total": 333,
    "additions": 322,
    "deletions": 11
  },
  "files": [
    {
      "sha": "0a6c2fe210a9bc267f6203c74d8d555adcd2b377",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64b653ca7058bfd4f91879dea628809d398b488e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64b653ca7058bfd4f91879dea628809d398b488e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=64b653ca7058bfd4f91879dea628809d398b488e",
      "patch": "@@ -1,3 +1,12 @@\n+2020-03-13  Tom Tromey  <tom@tromey.com>\n+\n+\t* m2-valprint.c (m2_value_print_inner): Use\n+\tcp_print_value_fields.\n+\t* cp-valprint.c\t(cp_print_value_fields): New function.\n+\t* c-valprint.c (c_value_print_struct): New function.\n+\t(c_value_print_inner): Use c_value_print_struct.\n+\t* c-lang.h (cp_print_value_fields): Declare.\n+\n 2020-03-13  Tom Tromey  <tom@tromey.com>\n \n \t* c-valprint.c (c_value_print_array): New function."
    },
    {
      "sha": "e513805c001e8b8aee038957e4fe2ec567b9e816",
      "filename": "gdb/c-lang.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64b653ca7058bfd4f91879dea628809d398b488e/gdb/c-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64b653ca7058bfd4f91879dea628809d398b488e/gdb/c-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.h?ref=64b653ca7058bfd4f91879dea628809d398b488e",
      "patch": "@@ -135,6 +135,11 @@ extern void c_type_print_base (struct type *, struct ui_file *,\n extern void cp_print_class_member (const gdb_byte *, struct type *,\n \t\t\t\t   struct ui_file *, const char *);\n \n+extern void cp_print_value_fields (struct value *,\n+\t\t\t\t   struct ui_file *, int,\n+\t\t\t\t   const struct value_print_options *,\n+\t\t\t\t   struct type **, int);\n+\n extern void cp_print_value_fields (struct type *, struct type *,\n \t\t\t\t   LONGEST, CORE_ADDR,\n \t\t\t\t   struct ui_file *, int,"
    },
    {
      "sha": "0f40a86872a88727e2ee121f3e1f50d906f28a6e",
      "filename": "gdb/c-valprint.c",
      "status": "modified",
      "additions": 29,
      "deletions": 7,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64b653ca7058bfd4f91879dea628809d398b488e/gdb/c-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64b653ca7058bfd4f91879dea628809d398b488e/gdb/c-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-valprint.c?ref=64b653ca7058bfd4f91879dea628809d398b488e",
      "patch": "@@ -540,6 +540,34 @@ c_val_print_struct (struct type *type, const gdb_byte *valaddr,\n \t\t\t\tNULL, 0);\n }\n \n+/* c_value_print helper for TYPE_CODE_STRUCT and TYPE_CODE_UNION.  */\n+\n+static void\n+c_value_print_struct (struct value *val, struct ui_file *stream, int recurse,\n+\t\t      const struct value_print_options *options)\n+{\n+  struct type *type = check_typedef (value_type (val));\n+\n+  if (TYPE_CODE (type) == TYPE_CODE_UNION && recurse && !options->unionprint)\n+    fprintf_filtered (stream, \"{...}\");\n+  else if (options->vtblprint && cp_is_vtbl_ptr_type (type))\n+    {\n+      /* Print the unmangled name if desired.  */\n+      /* Print vtable entry - we only get here if NOT using\n+\t -fvtable_thunks.  (Otherwise, look under\n+\t TYPE_CODE_PTR.)  */\n+      struct gdbarch *gdbarch = get_type_arch (type);\n+      int offset = TYPE_FIELD_BITPOS (type, VTBL_FNADDR_OFFSET) / 8;\n+      struct type *field_type = TYPE_FIELD_TYPE (type, VTBL_FNADDR_OFFSET);\n+      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      CORE_ADDR addr = extract_typed_address (valaddr + offset, field_type);\n+\n+      print_function_pointer_address (options, gdbarch, addr, stream);\n+    }\n+  else\n+    cp_print_value_fields (val, stream, recurse, options, NULL, 0);\n+}\n+\n /* c_val_print helper for TYPE_CODE_UNION.  */\n \n static void\n@@ -746,7 +774,6 @@ c_value_print_inner (struct value *val, struct ui_file *stream, int recurse,\n \t\t     const struct value_print_options *options)\n {\n   struct type *type = value_type (val);\n-  CORE_ADDR address = value_address (val);\n   const gdb_byte *valaddr = value_contents_for_printing (val);\n \n   type = check_typedef (type);\n@@ -765,13 +792,8 @@ c_value_print_inner (struct value *val, struct ui_file *stream, int recurse,\n       break;\n \n     case TYPE_CODE_UNION:\n-      c_val_print_union (type, valaddr, 0, address, stream,\n-\t\t\t recurse, val, options);\n-      break;\n-\n     case TYPE_CODE_STRUCT:\n-      c_val_print_struct (type, valaddr, 0, address, stream,\n-\t\t\t  recurse, val, options);\n+      c_value_print_struct (val, stream, recurse, options);\n       break;\n \n     case TYPE_CODE_INT:"
    },
    {
      "sha": "e186d48d41972630ac25743a1dc5ea16bd26556b",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 278,
      "deletions": 1,
      "changes": 279,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64b653ca7058bfd4f91879dea628809d398b488e/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64b653ca7058bfd4f91879dea628809d398b488e/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=64b653ca7058bfd4f91879dea628809d398b488e",
      "patch": "@@ -329,6 +329,7 @@ cp_print_value_fields (struct type *type, struct type *real_type,\n \t\t    {\n \t\t      CORE_ADDR addr;\n \t\t      \n+\t\t      i_offset += value_embedded_offset (val);\n \t\t      addr = extract_typed_address (valaddr + i_offset, i_type);\n \t\t      print_function_pointer_address (opts,\n \t\t\t\t\t\t      get_type_arch (type),\n@@ -390,6 +391,282 @@ cp_print_value_fields (struct type *type, struct type *real_type,\n   fprintf_filtered (stream, \"}\");\n }\n \n+/* Mutually recursive subroutines of cp_print_value and c_value_print\n+   to print out a structure's fields: cp_print_value_fields and\n+   cp_print_value.\n+\n+   VAL, ADDRESS, STREAM, RECURSE, and OPTIONS have the same meanings\n+   as in cp_print_value and c_value_print.\n+\n+   DONT_PRINT is an array of baseclass types that we should not print,\n+   or zero if called from top level.  */\n+\n+void\n+cp_print_value_fields (struct value *val, struct ui_file *stream,\n+\t\t       int recurse, const struct value_print_options *options,\n+\t\t       struct type **dont_print_vb,\n+\t\t       int dont_print_statmem)\n+{\n+  int i, len, n_baseclasses;\n+  int fields_seen = 0;\n+  static int last_set_recurse = -1;\n+\n+  struct type *type = check_typedef (value_type (val));\n+  CORE_ADDR address = value_address (val);\n+\n+  if (recurse == 0)\n+    {\n+      /* Any object can be left on obstacks only during an unexpected\n+\t error.  */\n+\n+      if (obstack_object_size (&dont_print_statmem_obstack) > 0)\n+\t{\n+\t  obstack_free (&dont_print_statmem_obstack, NULL);\n+\t  obstack_begin (&dont_print_statmem_obstack,\n+\t\t\t 32 * sizeof (CORE_ADDR));\n+\t}\n+      if (obstack_object_size (&dont_print_stat_array_obstack) > 0)\n+\t{\n+\t  obstack_free (&dont_print_stat_array_obstack, NULL);\n+\t  obstack_begin (&dont_print_stat_array_obstack,\n+\t\t\t 32 * sizeof (struct type *));\n+\t}\n+    }\n+\n+  fprintf_filtered (stream, \"{\");\n+  len = TYPE_NFIELDS (type);\n+  n_baseclasses = TYPE_N_BASECLASSES (type);\n+\n+  /* First, print out baseclasses such that we don't print\n+     duplicates of virtual baseclasses.  */\n+\n+  if (n_baseclasses > 0)\n+    cp_print_value (type, type, 0, address, stream,\n+\t\t    recurse + 1, val, options,\n+\t\t    dont_print_vb);\n+\n+  /* Second, print out data fields */\n+\n+  /* If there are no data fields, skip this part */\n+  if (len == n_baseclasses || !len)\n+    fprintf_styled (stream, metadata_style.style (), \"<No data fields>\");\n+  else\n+    {\n+      size_t statmem_obstack_initial_size = 0;\n+      size_t stat_array_obstack_initial_size = 0;\n+      struct type *vptr_basetype = NULL;\n+      int vptr_fieldno;\n+\n+      if (dont_print_statmem == 0)\n+\t{\n+\t  statmem_obstack_initial_size =\n+\t    obstack_object_size (&dont_print_statmem_obstack);\n+\n+\t  if (last_set_recurse != recurse)\n+\t    {\n+\t      stat_array_obstack_initial_size =\n+\t\tobstack_object_size (&dont_print_stat_array_obstack);\n+\n+\t      last_set_recurse = recurse;\n+\t    }\n+\t}\n+\n+      vptr_fieldno = get_vptr_fieldno (type, &vptr_basetype);\n+      for (i = n_baseclasses; i < len; i++)\n+\t{\n+\t  const gdb_byte *valaddr = value_contents_for_printing (val);\n+\n+\t  /* If requested, skip printing of static fields.  */\n+\t  if (!options->static_field_print\n+\t      && field_is_static (&TYPE_FIELD (type, i)))\n+\t    continue;\n+\n+\t  if (fields_seen)\n+\t    {\n+\t      fputs_filtered (\",\", stream);\n+\t      if (!options->prettyformat)\n+\t\tfputs_filtered (\" \", stream);\n+\t    }\n+\t  else if (n_baseclasses > 0)\n+\t    {\n+\t      if (options->prettyformat)\n+\t\t{\n+\t\t  fprintf_filtered (stream, \"\\n\");\n+\t\t  print_spaces_filtered (2 + 2 * recurse, stream);\n+\t\t  fputs_filtered (\"members of \", stream);\n+\t\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t\t  fputs_filtered (\":\", stream);\n+\t\t}\n+\t    }\n+\t  fields_seen = 1;\n+\n+\t  if (options->prettyformat)\n+\t    {\n+\t      fprintf_filtered (stream, \"\\n\");\n+\t      print_spaces_filtered (2 + 2 * recurse, stream);\n+\t    }\n+\t  else\n+\t    {\n+\t      wrap_here (n_spaces (2 + 2 * recurse));\n+\t    }\n+\n+\t  annotate_field_begin (TYPE_FIELD_TYPE (type, i));\n+\n+\t  if (field_is_static (&TYPE_FIELD (type, i)))\n+\t    {\n+\t      fputs_filtered (\"static \", stream);\n+\t      fprintf_symbol_filtered (stream,\n+\t\t\t\t       TYPE_FIELD_NAME (type, i),\n+\t\t\t\t       current_language->la_language,\n+\t\t\t\t       DMGL_PARAMS | DMGL_ANSI);\n+\t    }\n+\t  else\n+\t    fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t\t\t  variable_name_style.style (), stream);\n+\t  annotate_field_name_end ();\n+\n+\t  /* We tweak various options in a few cases below.  */\n+\t  value_print_options options_copy = *options;\n+\t  value_print_options *opts = &options_copy;\n+\n+\t  /* Do not print leading '=' in case of anonymous\n+\t     unions.  */\n+\t  if (strcmp (TYPE_FIELD_NAME (type, i), \"\"))\n+\t    fputs_filtered (\" = \", stream);\n+\t  else\n+\t    {\n+\t      /* If this is an anonymous field then we want to consider it\n+\t\t as though it is at its parent's depth when it comes to the\n+\t\t max print depth.  */\n+\t      if (opts->max_depth != -1 && opts->max_depth < INT_MAX)\n+\t\t++opts->max_depth;\n+\t    }\n+\t  annotate_field_value ();\n+\n+\t  if (!field_is_static (&TYPE_FIELD (type, i))\n+\t      && TYPE_FIELD_PACKED (type, i))\n+\t    {\n+\t      struct value *v;\n+\n+\t      /* Bitfields require special handling, especially due to\n+\t         byte order problems.  */\n+\t      if (TYPE_FIELD_IGNORE (type, i))\n+\t\t{\n+\t\t  fputs_styled (\"<optimized out or zero length>\",\n+\t\t\t\tmetadata_style.style (), stream);\n+\t\t}\n+\t      else if (value_bits_synthetic_pointer (val,\n+\t\t\t\t\t\t     TYPE_FIELD_BITPOS (type,\n+\t\t\t\t\t\t\t\t\ti),\n+\t\t\t\t\t\t     TYPE_FIELD_BITSIZE (type,\n+\t\t\t\t\t\t\t\t\t i)))\n+\t\t{\n+\t\t  fputs_styled (_(\"<synthetic pointer>\"),\n+\t\t\t\tmetadata_style.style (), stream);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  opts->deref_ref = 0;\n+\n+\t\t  v = value_field_bitfield (type, i, valaddr,\n+\t\t\t\t\t    value_embedded_offset (val), val);\n+\n+\t\t  common_val_print (v, stream, recurse + 1,\n+\t\t\t\t    opts, current_language);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (TYPE_FIELD_IGNORE (type, i))\n+\t\t{\n+\t\t  fputs_styled (\"<optimized out or zero length>\",\n+\t\t\t\tmetadata_style.style (), stream);\n+\t\t}\n+\t      else if (field_is_static (&TYPE_FIELD (type, i)))\n+\t\t{\n+\t\t  try\n+\t\t    {\n+\t\t      struct value *v = value_static_field (type, i);\n+\n+\t\t      cp_print_static_field (TYPE_FIELD_TYPE (type, i),\n+\t\t\t\t\t     v, stream, recurse + 1,\n+\t\t\t\t\t     opts);\n+\t\t    }\n+\t\t  catch (const gdb_exception_error &ex)\n+\t\t    {\n+\t\t      fprintf_styled (stream, metadata_style.style (),\n+\t\t\t\t      _(\"<error reading variable: %s>\"),\n+\t\t\t\t      ex.what ());\n+\t\t    }\n+\t\t}\n+\t      else if (i == vptr_fieldno && type == vptr_basetype)\n+\t\t{\n+\t\t  int i_offset = TYPE_FIELD_BITPOS (type, i) / 8;\n+\t\t  struct type *i_type = TYPE_FIELD_TYPE (type, i);\n+\n+\t\t  if (valprint_check_validity (stream, i_type, i_offset, val))\n+\t\t    {\n+\t\t      CORE_ADDR addr;\n+\n+\t\t      addr = extract_typed_address (valaddr + i_offset, i_type);\n+\t\t      print_function_pointer_address (opts,\n+\t\t\t\t\t\t      get_type_arch (type),\n+\t\t\t\t\t\t      addr, stream);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct value *v = value_primitive_field (val, 0, i, type);\n+\t\t  opts->deref_ref = 0;\n+\t\t  common_val_print (v, stream, recurse + 1, opts,\n+\t\t\t\t    current_language);\n+\t\t}\n+\t    }\n+\t  annotate_field_end ();\n+\t}\n+\n+      if (dont_print_statmem == 0)\n+\t{\n+\t  size_t obstack_final_size =\n+           obstack_object_size (&dont_print_statmem_obstack);\n+\n+\t  if (obstack_final_size > statmem_obstack_initial_size)\n+\t    {\n+\t      /* In effect, a pop of the printed-statics stack.  */\n+\t      size_t shrink_bytes\n+\t\t= statmem_obstack_initial_size - obstack_final_size;\n+\t      obstack_blank_fast (&dont_print_statmem_obstack, shrink_bytes);\n+\t    }\n+\n+\t  if (last_set_recurse != recurse)\n+\t    {\n+\t      obstack_final_size =\n+\t\tobstack_object_size (&dont_print_stat_array_obstack);\n+\n+\t      if (obstack_final_size > stat_array_obstack_initial_size)\n+\t\t{\n+\t\t  void *free_to_ptr =\n+\t\t    (char *) obstack_next_free (&dont_print_stat_array_obstack)\n+\t\t    - (obstack_final_size\n+\t\t       - stat_array_obstack_initial_size);\n+\n+\t\t  obstack_free (&dont_print_stat_array_obstack,\n+\t\t\t\tfree_to_ptr);\n+\t\t}\n+\t      last_set_recurse = -1;\n+\t    }\n+\t}\n+\n+      if (options->prettyformat)\n+\t{\n+\t  fprintf_filtered (stream, \"\\n\");\n+\t  print_spaces_filtered (2 * recurse, stream);\n+\t}\n+    }\t\t\t\t/* if there are data fields */\n+\n+  fprintf_filtered (stream, \"}\");\n+}\n+\n /* Like cp_print_value_fields, but find the runtime type of the object\n    and pass it as the `real_type' argument to cp_print_value_fields.\n    This function is a hack to work around the fact that\n@@ -436,7 +713,7 @@ cp_print_value_fields_rtti (struct type *type,\n \t\t\t dont_print_vb, dont_print_statmem);\n }\n \n-/* Special val_print routine to avoid printing multiple copies of\n+/* Special value_print routine to avoid printing multiple copies of\n    virtual baseclasses.  */\n \n static void"
    },
    {
      "sha": "facd15e2393e2a6f02d1a63200717b4a5b07687d",
      "filename": "gdb/m2-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64b653ca7058bfd4f91879dea628809d398b488e/gdb/m2-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64b653ca7058bfd4f91879dea628809d398b488e/gdb/m2-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-valprint.c?ref=64b653ca7058bfd4f91879dea628809d398b488e",
      "patch": "@@ -605,9 +605,7 @@ m2_value_print_inner (struct value *val, struct ui_file *stream, int recurse,\n       else if (m2_is_unbounded_array (type))\n \tm2_print_unbounded_array (val, stream, recurse, options);\n       else\n-\tcp_print_value_fields (type, type, 0,\n-\t\t\t       address, stream, recurse, val,\n-\t\t\t       options, NULL, 0);\n+\tcp_print_value_fields (val, stream, recurse, options, NULL, 0);\n       break;\n \n     case TYPE_CODE_SET:"
    }
  ]
}