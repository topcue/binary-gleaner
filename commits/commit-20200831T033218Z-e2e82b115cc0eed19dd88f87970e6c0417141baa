{
  "sha": "e2e82b115cc0eed19dd88f87970e6c0417141baa",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTJlODJiMTE1Y2MwZWVkMTlkZDg4Zjg3OTcwZTZjMDQxNzE0MWJhYQ==",
  "commit": {
    "author": {
      "name": "Cooper Qu",
      "email": "cooper.qu@linux.alibaba.com",
      "date": "2020-08-31T03:27:54Z"
    },
    "committer": {
      "name": "Lifang Xia",
      "email": "lifang_xia@c-sky.com",
      "date": "2020-08-31T03:32:18Z"
    },
    "message": "CSKY: Refine operand format error reporting.\n\nRename SET_ERROR_NUMBER to SET_ERROR_STRING, and add SET_ERROR_INTEGER\nto report error message which pass an integer argument.\n\ngas/\n\t* config/tc-csky.c (csky_error_state): New member 'arg_int'.\n\t(SET_ERROR_NUMBER): Rename to SET_ERROR_STRING.\n\t(SET_ERROR_INTEGER): New.\n\t(err_formats): Add error format for ERROR_FREG_OVER_RANGE and\n\tERROR_VREG_OVER_RANGE.\n\t(csky_show_error): Pass an integer argument for some error\n\tnumbers.\n\t(parse_exp): Call SET_ERROR_STRING instead of SET_ERROR_NUMBER.\n\t(parse_rt): Likewise.\n\t(parse_type_ctrlreg): Likewise.\n\t(csky_get_reg_val): Likewise.\n\t(is_reglist_legal): Likewise.\n\t(is_freglist_legal): Likewise.\n\t(is_reglist_dash_comma_legal): Likewise.\n\t(is_reg_lshift_illegal): Likewise.\n\t(is_psr_bit): Likewise.\n\t(parse_type_cpreg): Likewise.\n\t(parse_type_cpcreg): Likewise.\n\t(parse_type_areg): Likewise.\n\t(parse_type_freg): Likewise.\n\t(parse_ldst_imm): Likewise and call SET_ERROR_INTEGER.\n\t(get_operand_value): Likewise.\n\t(parse_operands_op): Likewise and call is_imm_within_range,\n\tis_imm_within_range_ext and is_oimm_within_range.\n\t(md_assemble): Likewise.\n\t(is_imm_within_range): New.\n\t(is_imm_within_range_ext): Rename from is_imm_over_range.\n\t(is_oimm_within_range): Rename from is_oimm_over_range.\n\t(v2_work_add_sub): Call SET_ERROR_INTEGER.\n\t(csky_rolc): call is_imm_within_range instead of\n\tis_imm_over_range.\n\nopcodes/\n\t* csky-dis.c (csky_output_operand): Assign dis_info.value for\n\tOPRND_TYPE_VREG.",
    "tree": {
      "sha": "7741b2e70f9f4caceeaedb5d9466077fa7430955",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7741b2e70f9f4caceeaedb5d9466077fa7430955"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e2e82b115cc0eed19dd88f87970e6c0417141baa",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e2e82b115cc0eed19dd88f87970e6c0417141baa",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e2e82b115cc0eed19dd88f87970e6c0417141baa",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e2e82b115cc0eed19dd88f87970e6c0417141baa/comments",
  "author": {
    "login": "Cooper-Qu",
    "id": 68842787,
    "node_id": "MDQ6VXNlcjY4ODQyNzg3",
    "avatar_url": "https://avatars.githubusercontent.com/u/68842787?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Cooper-Qu",
    "html_url": "https://github.com/Cooper-Qu",
    "followers_url": "https://api.github.com/users/Cooper-Qu/followers",
    "following_url": "https://api.github.com/users/Cooper-Qu/following{/other_user}",
    "gists_url": "https://api.github.com/users/Cooper-Qu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Cooper-Qu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Cooper-Qu/subscriptions",
    "organizations_url": "https://api.github.com/users/Cooper-Qu/orgs",
    "repos_url": "https://api.github.com/users/Cooper-Qu/repos",
    "events_url": "https://api.github.com/users/Cooper-Qu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Cooper-Qu/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "Lifang-XIA",
    "id": 22215568,
    "node_id": "MDQ6VXNlcjIyMjE1NTY4",
    "avatar_url": "https://avatars.githubusercontent.com/u/22215568?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Lifang-XIA",
    "html_url": "https://github.com/Lifang-XIA",
    "followers_url": "https://api.github.com/users/Lifang-XIA/followers",
    "following_url": "https://api.github.com/users/Lifang-XIA/following{/other_user}",
    "gists_url": "https://api.github.com/users/Lifang-XIA/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Lifang-XIA/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Lifang-XIA/subscriptions",
    "organizations_url": "https://api.github.com/users/Lifang-XIA/orgs",
    "repos_url": "https://api.github.com/users/Lifang-XIA/repos",
    "events_url": "https://api.github.com/users/Lifang-XIA/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Lifang-XIA/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dd221981c470f4fcb3164ce6d47bcd7726b559a4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dd221981c470f4fcb3164ce6d47bcd7726b559a4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dd221981c470f4fcb3164ce6d47bcd7726b559a4"
    }
  ],
  "stats": {
    "total": 323,
    "additions": 214,
    "deletions": 109
  },
  "files": [
    {
      "sha": "70e58893336a95fb364cc3a70bbf686d03385be0",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2e82b115cc0eed19dd88f87970e6c0417141baa/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2e82b115cc0eed19dd88f87970e6c0417141baa/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=e2e82b115cc0eed19dd88f87970e6c0417141baa",
      "patch": "@@ -1,3 +1,37 @@\n+2020-08-31  Cooper Qu  <cooper.qu@linux.alibaba.com>\n+\n+\t* config/tc-csky.c (csky_error_state): New member 'arg_int'.\n+\t(SET_ERROR_NUMBER): Rename to SET_ERROR_STRING.\n+\t(SET_ERROR_INTEGER): New.\n+\t(err_formats): Add error format for ERROR_FREG_OVER_RANGE and\n+\tERROR_VREG_OVER_RANGE.\n+\t(csky_show_error): Pass an integer argument for some error\n+\tnumbers.\n+\t(parse_exp): Call SET_ERROR_STRING instead of SET_ERROR_NUMBER.\n+\t(parse_rt): Likewise.\n+\t(parse_type_ctrlreg): Likewise.\n+\t(csky_get_reg_val): Likewise.\n+\t(is_reglist_legal): Likewise.\n+\t(is_freglist_legal): Likewise.\n+\t(is_reglist_dash_comma_legal): Likewise.\n+\t(is_reg_lshift_illegal): Likewise.\n+\t(is_psr_bit): Likewise.\n+\t(parse_type_cpreg): Likewise.\n+\t(parse_type_cpcreg): Likewise.\n+\t(parse_type_areg): Likewise.\n+\t(parse_type_freg): Likewise.\n+\t(parse_ldst_imm): Likewise and call SET_ERROR_INTEGER.\n+\t(get_operand_value): Likewise.\n+\t(parse_operands_op): Likewise and call is_imm_within_range,\n+\tis_imm_within_range_ext and is_oimm_within_range.\n+\t(md_assemble): Likewise.\n+\t(is_imm_within_range): New.\n+\t(is_imm_within_range_ext): Rename from is_imm_over_range.\n+\t(is_oimm_within_range): Rename from is_oimm_over_range.\n+\t(v2_work_add_sub): Call SET_ERROR_INTEGER.\n+\t(csky_rolc): call is_imm_within_range instead of\n+\tis_imm_over_range.\n+\n 2020-08-31  Cooper Qu  <cooper.qu@linux.alibaba.com>\n \n \t* config/tc-csky.c (md_begin): Add warning when -mdsp and"
    },
    {
      "sha": "01f1d516600d90b3523c7c1a14adc1d183298eb3",
      "filename": "gas/config/tc-csky.c",
      "status": "modified",
      "additions": 174,
      "deletions": 109,
      "changes": 283,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2e82b115cc0eed19dd88f87970e6c0417141baa/gas/config/tc-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2e82b115cc0eed19dd88f87970e6c0417141baa/gas/config/tc-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-csky.c?ref=e2e82b115cc0eed19dd88f87970e6c0417141baa",
      "patch": "@@ -327,6 +327,8 @@ enum error_number\n   /* The following are errors.  */\n   ERROR_CREG_ILLEGAL = 0,\n   ERROR_REG_OVER_RANGE,\n+  ERROR_FREG_OVER_RANGE,\n+  ERROR_VREG_OVER_RANGE,\n   ERROR_GREG_ILLEGAL,\n   ERROR_802J_REG_OVER_RANGE,\n   ERROR_REG_FORMAT,\n@@ -372,13 +374,14 @@ struct csky_error_state\n {\n   enum error_number err_num;\n   int opnum;\n+  int arg_int;\n   const void *arg1;\n   const void *arg2;\n } error_state;\n \n /* This macro is used to set error number and arg1 in the global state.  */\n \n-#define SET_ERROR_NUMBER(err, msg)                      \\\n+#define SET_ERROR_STRING(err, msg)                      \\\n   do {\t\t\t\t\t\t\t\\\n     if (error_state.err_num > err)\t\t\t\\\n       {\t\t\t\t\t\t\t\\\n@@ -387,6 +390,14 @@ struct csky_error_state\n       }\t\t\t\t\t\t\t\\\n   } while (0)\n \n+#define SET_ERROR_INTEGER(err, integer)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (error_state.err_num > err)\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\terror_state.err_num = err;\t\t\t\\\n+\terror_state.arg_int = integer;\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n \n /* Map error identifiers onto a format string, which will use\n    arg1 and arg2 from the global error state.  */\n@@ -400,6 +411,8 @@ static const struct csky_error_format_map err_formats[] =\n {\n   {ERROR_CREG_ILLEGAL, \"Operand %d error: control register is illegal.\"},\n   {ERROR_REG_OVER_RANGE, \"Operand %d error: r%d register is over range.\"},\n+  {ERROR_FREG_OVER_RANGE, \"Operand %d error: vr%d register is over range.\"},\n+  {ERROR_VREG_OVER_RANGE, \"Operand %d error: vr%d register is out of range.\"},\n   {ERROR_GREG_ILLEGAL, \"Operand %d error: general register is illegal.\"},\n   {ERROR_802J_REG_OVER_RANGE, \"Operand %d register %s out of range (802j only has registers:0-15,23,24,25,30)\"},\n   {ERROR_REG_FORMAT, \"Operand %d error: %s.\"},\n@@ -857,19 +870,21 @@ csky_show_error (enum error_number err, int idx, void *arg1, void *arg2)\n       break;\n     case ERROR_OPERANDS_NUMBER:\n     case ERROR_IMM_POWER:\n-      as_bad (_(err_formats[err].fmt), (long)arg1);\n+      as_bad (_(err_formats[err].fmt), error_state.arg_int);\n       break;\n \n     case ERROR_OFFSET_UNALIGNED:\n-      as_bad (_(err_formats[err].fmt), idx, (long)arg1);\n+      as_bad (_(err_formats[err].fmt), idx, error_state.arg_int);\n       break;\n     case ERROR_RELOC_ILLEGAL:\n     case ERROR_BAD_END:\n     case ERROR_OPERANDS_ILLEGAL:\n       as_bad (_(err_formats[err].fmt), (char *)arg1);\n       break;\n     case ERROR_REG_OVER_RANGE:\n-      as_bad (_(err_formats[err].fmt), idx, (long) arg1);\n+    case ERROR_FREG_OVER_RANGE:\n+    case ERROR_VREG_OVER_RANGE:\n+      as_bad (_(err_formats[err].fmt), idx, error_state.arg_int);\n       break;\n     case ERROR_802J_REG_OVER_RANGE:\n     case ERROR_REG_FORMAT:\n@@ -1903,7 +1918,7 @@ parse_exp (char *s, expressionS *e)\n   lex_got (&insn_reloc, NULL);\n \n   if (e->X_op == O_absent)\n-    SET_ERROR_NUMBER (ERROR_MISSING_OPERAND, NULL);\n+    SET_ERROR_STRING (ERROR_MISSING_OPERAND, NULL);\n \n   new = input_line_pointer;\n   input_line_pointer = save;\n@@ -2022,7 +2037,7 @@ parse_rt (char *s,\n       if (*s == ']')\n \ts++;\n       else\n-\tSET_ERROR_NUMBER (ERROR_MISSING_RSQUARE_BRACKETS, NULL);\n+\tSET_ERROR_STRING (ERROR_MISSING_RSQUARE_BRACKETS, NULL);\n \n       if (ep)\n        *ep = e;\n@@ -2179,14 +2194,14 @@ parse_type_ctrlreg (char** oper)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      SET_ERROR_NUMBER (ERROR_REG_OVER_RANGE, \"control\");\n+\t\t      SET_ERROR_STRING (ERROR_REG_OVER_RANGE, \"control\");\n \t\t      return FALSE;\n \t\t    }\n \t\t  if (*s == ',')\n \t\t    s++;\n \t\t  else\n \t\t    {\n-\t\t      SET_ERROR_NUMBER (ERROR_CREG_ILLEGAL, NULL);\n+\t\t      SET_ERROR_STRING (ERROR_CREG_ILLEGAL, NULL);\n \t\t      return FALSE;\n \t\t    }\n \t\t  char *pS = s;\n@@ -2197,7 +2212,7 @@ parse_type_ctrlreg (char** oper)\n \t\t  else\n \t\t    {\n \t\t      /* Error. Missing '>'.  */\n-\t\t      SET_ERROR_NUMBER (ERROR_MISSING_RANGLE_BRACKETS, NULL);\n+\t\t      SET_ERROR_STRING (ERROR_MISSING_RANGLE_BRACKETS, NULL);\n \t\t      return FALSE;\n \t\t    }\n \t\t  expressionS e;\n@@ -2215,13 +2230,13 @@ parse_type_ctrlreg (char** oper)\n \t      else\n \t\t{\n \t\t  /* Error. Missing '<'.  */\n-\t\t  SET_ERROR_NUMBER (ERROR_MISSING_LANGLE_BRACKETS, NULL);\n+\t\t  SET_ERROR_STRING (ERROR_MISSING_LANGLE_BRACKETS, NULL);\n \t\t  return FALSE;\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      SET_ERROR_NUMBER (ERROR_CREG_ILLEGAL, NULL);\n+\t      SET_ERROR_STRING (ERROR_CREG_ILLEGAL, NULL);\n \t      return FALSE;\n \t    }\n \t}\n@@ -2444,7 +2459,7 @@ csky_get_reg_val (char *str, int *len)\n       /* CK801 register range is r0-r8 & r13-r15.  */\n       if ((reg > 8 && reg < 13) || reg > 15)\n \t{\n-\t  SET_ERROR_NUMBER (ERROR_REG_OVER_RANGE, reg);\n+\t  SET_ERROR_STRING (ERROR_REG_OVER_RANGE, reg);\n \t  return -1;\n \t}\n     }\n@@ -2453,13 +2468,13 @@ csky_get_reg_val (char *str, int *len)\n       /* CK802 register range is r0-r15 & r23-r25 & r30.  */\n       if ((reg > 15 && reg < 23) || (reg > 25 && reg != 30))\n \t{\n-\t  SET_ERROR_NUMBER (ERROR_REG_OVER_RANGE, reg);\n+\t  SET_ERROR_STRING (ERROR_REG_OVER_RANGE, reg);\n \t  return -1;\n \t}\n     }\n   else if (reg > 31 || reg < 0)\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_OVER_RANGE, reg);\n+      SET_ERROR_STRING (ERROR_REG_OVER_RANGE, reg);\n       return -1;\n     }\n \n@@ -2501,14 +2516,14 @@ is_reglist_legal (char **oper)\n \n   if (reg1 == -1 || (IS_CSKY_V1 (mach_flag) && (reg1 == 0 || reg1 == 15)))\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The first reg must not be r0/r15\");\n       return FALSE;\n     }\n \n   if (**oper != '-')\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The operand format must be rx-ry\");\n       return FALSE;\n     }\n@@ -2519,15 +2534,15 @@ is_reglist_legal (char **oper)\n \n   if (reg2 == -1 || (IS_CSKY_V1 (mach_flag) && reg1 == 15))\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The operand format must be r15 in C-SKY V1\");\n       return FALSE;\n     }\n   if (IS_CSKY_V2 (mach_flag))\n     {\n       if (reg2 < reg1)\n \t{\n-\t  SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+\t  SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t    \"The operand format must be rx-ry (rx < ry)\");\n \t  return FALSE;\n \t}\n@@ -2550,14 +2565,14 @@ is_freglist_legal (char **oper)\n \n   if (reg1 == -1)\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The fpu register format is not recognized.\");\n       return FALSE;\n     }\n \n   if (**oper != '-')\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The operand format must be vrx-vry/frx-fry.\");\n       return FALSE;\n     }\n@@ -2568,17 +2583,23 @@ is_freglist_legal (char **oper)\n \n   if (reg2 == -1)\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The fpu register format is not recognized.\");\n       return FALSE;\n     }\n   if (reg2 < reg1)\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The operand format must be rx-ry(rx < ry)\");\n       return FALSE;\n     }\n+\n   reg2 = reg2 - reg1;\n+  if (reg2 > (int)0x3)\n+    {\n+      SET_ERROR_STRING(ERROR_REG_FORMAT, (void *)\"vry-vrx is over range\");\n+      return FALSE;\n+    }\n   reg2 <<= 4;\n   reg1 |= reg2;\n   csky_insn.val[csky_insn.idx++] = reg1;\n@@ -2599,7 +2620,7 @@ is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n       reg1 = csky_get_reg_val  (*oper, &len);\n       if (reg1 == -1)\n \t{\n-\t  SET_ERROR_NUMBER (ERROR_REG_LIST, NULL);\n+\t  SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n \t  return FALSE;\n \t}\n       flag |= (1 << reg1);\n@@ -2610,13 +2631,13 @@ is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n \t  reg2 = csky_get_reg_val  (*oper, &len);\n \t  if (reg2 == -1)\n \t    {\n-\t      SET_ERROR_NUMBER (ERROR_REG_LIST, NULL);\n+\t      SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n \t      return FALSE;\n \t    }\n \t  *oper += len;\n \t  if (reg1 > reg2)\n \t    {\n-\t      SET_ERROR_NUMBER (ERROR_REG_LIST, NULL);\n+\t      SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n \t      return FALSE;\n \t    }\n \t  while (reg2 >= reg1)\n@@ -2632,7 +2653,7 @@ is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n #define REGLIST_BITS         0x10038ff0\n   if (flag & ~(REGLIST_BITS))\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_LIST, NULL);\n+      SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n       return FALSE;\n     }\n   /* Check r4-r11.  */\n@@ -2665,7 +2686,7 @@ is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n     list |= (1 << 8);\n   if (oprnd->mask == OPRND_MASK_0_4 && (list & ~OPRND_MASK_0_4))\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_LIST, NULL);\n+      SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n       return FALSE;\n     }\n   csky_insn.val[csky_insn.idx++] = list;\n@@ -2681,14 +2702,14 @@ is_reg_lshift_illegal (char **oper, int is_float)\n   reg = csky_get_reg_val  (*oper, &len);\n   if (reg == -1)\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT, \"The register must be r0-r31.\");\n+      SET_ERROR_STRING (ERROR_REG_FORMAT, \"The register must be r0-r31.\");\n       return FALSE;\n     }\n \n   *oper += len;\n   if ((*oper)[0] != '<' || (*oper)[1] != '<')\n     {\n-      SET_ERROR_NUMBER (ERROR_UNDEFINE,\n+      SET_ERROR_STRING (ERROR_UNDEFINE,\n \t\t\t\"Operand format error; should be (rx, ry << n)\");\n       return FALSE;\n     }\n@@ -2702,13 +2723,13 @@ is_reg_lshift_illegal (char **oper, int is_float)\n       /* The immediate must be in [0, 3].  */\n       if (e.X_add_number < 0 || e.X_add_number > 3)\n \t{\n-\t  SET_ERROR_NUMBER (ERROR_IMM_OVERFLOW, NULL);\n+\t  SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n \t  return FALSE;\n \t}\n     }\n   else\n     {\n-      SET_ERROR_NUMBER (ERROR_EXP_CONSTANT, NULL);\n+      SET_ERROR_STRING (ERROR_EXP_CONSTANT, NULL);\n       return FALSE;\n     }\n   if (is_float)\n@@ -2721,7 +2742,31 @@ is_reg_lshift_illegal (char **oper, int is_float)\n }\n \n static bfd_boolean\n-is_imm_over_range (char **oper, int min, int max, int ext)\n+is_imm_within_range (char **oper, int min, int max)\n+{\n+  expressionS e;\n+  bfd_boolean ret = FALSE;\n+  char *new_oper = parse_exp (*oper, &e);\n+  if (e.X_op == O_constant)\n+    {\n+      ret = TRUE;\n+      *oper = new_oper;\n+      if (e.X_add_number < min || e.X_add_number > max)\n+\t{\n+\t  ret = FALSE;\n+\t  SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n+\t}\n+      csky_insn.val[csky_insn.idx++] = e.X_add_number;\n+    }\n+\n+  else\n+    SET_ERROR_STRING(ERROR_IMM_ILLEGAL, NULL);\n+\n+  return ret;\n+}\n+\n+static bfd_boolean\n+is_imm_within_range_ext (char **oper, int min, int max, int ext)\n {\n   expressionS e;\n   bfd_boolean ret = FALSE;\n@@ -2734,16 +2779,19 @@ is_imm_over_range (char **oper, int min, int max, int ext)\n \t  && (e.X_add_number < min || e.X_add_number > max))\n \t{\n \t  ret = FALSE;\n-\t  SET_ERROR_NUMBER (ERROR_IMM_OVERFLOW, NULL);\n+\t  SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n \t}\n       csky_insn.val[csky_insn.idx++] = e.X_add_number;\n     }\n \n+  else\n+    SET_ERROR_STRING(ERROR_IMM_ILLEGAL, NULL);\n+\n   return ret;\n }\n \n static bfd_boolean\n-is_oimm_over_range (char **oper, int min, int max)\n+is_oimm_within_range (char **oper, int min, int max)\n {\n   expressionS e;\n   bfd_boolean ret = FALSE;\n@@ -2755,7 +2803,7 @@ is_oimm_over_range (char **oper, int min, int max)\n       if (e.X_add_number < min || e.X_add_number > max)\n \t{\n \t  ret = FALSE;\n-\t  SET_ERROR_NUMBER (ERROR_IMM_OVERFLOW, NULL);\n+\t  SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n \t}\n       csky_insn.val[csky_insn.idx++] = e.X_add_number - 1;\n     }\n@@ -2789,7 +2837,7 @@ is_psr_bit (char **oper)\n \t}\n       i++;\n     }\n-  SET_ERROR_NUMBER (ERROR_OPCODE_PSRBIT, NULL);\n+  SET_ERROR_STRING (ERROR_OPCODE_PSRBIT, NULL);\n   return FALSE;\n }\n \n@@ -2847,7 +2895,7 @@ parse_type_cpreg (char** oper)\n \t  return TRUE;\n \t}\n     }\n-  SET_ERROR_NUMBER (ERROR_CPREG_ILLEGAL, *oper);\n+  SET_ERROR_STRING (ERROR_CPREG_ILLEGAL, *oper);\n   return FALSE;\n }\n \n@@ -2868,7 +2916,7 @@ parse_type_cpcreg (char** oper)\n \t  return TRUE;\n \t}\n     }\n-  SET_ERROR_NUMBER (ERROR_CPREG_ILLEGAL, *oper);\n+  SET_ERROR_STRING (ERROR_CPREG_ILLEGAL, *oper);\n   return FALSE;\n }\n \n@@ -2880,7 +2928,7 @@ parse_type_areg (char** oper)\n   i = csky_get_reg_val (*oper, &len);\n   if (i == -1)\n     {\n-      SET_ERROR_NUMBER (ERROR_GREG_ILLEGAL, NULL);\n+      SET_ERROR_STRING (ERROR_GREG_ILLEGAL, NULL);\n       return FALSE;\n     }\n   *oper += len;\n@@ -2897,15 +2945,15 @@ parse_type_freg (char** oper, int even)\n   reg = csky_get_freg_val (*oper, &len);\n   if (reg == -1)\n     {\n-      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n-\t\t\t\"The fpu register format is not recognized.\");\n+      SET_ERROR_STRING (ERROR_REG_FORMAT,\n+\t\t\t(void *)\"The fpu register format is not recognized.\");\n       return FALSE;\n     }\n   *oper += len;\n   csky_insn.opcode_end = *oper;\n   if (even && reg & 0x1)\n     {\n-      SET_ERROR_NUMBER (ERROR_EXP_EVEN_FREG, NULL);\n+      SET_ERROR_STRING (ERROR_EXP_EVEN_FREG, NULL);\n       return FALSE;\n     }\n   csky_insn.val[csky_insn.idx++] = reg;\n@@ -2939,19 +2987,21 @@ parse_ldst_imm (char **oper, struct csky_opcode_info *op ATTRIBUTE_UNUSED,\n   expressionS e;\n   *oper = parse_exp (*oper, &e);\n   if (e.X_op != O_constant)\n+    {\n     /* Not a constant.  */\n+      SET_ERROR_STRING(ERROR_UNDEFINE, (void *)\"Operand format is error. eg. \\\"ld rz, (rx, n)\\\"\");\n     return FALSE;\n+    }\n   else if (e.X_add_number < 0 || e.X_add_number >= max)\n     {\n       /* Out of range.  */\n-      SET_ERROR_NUMBER (ERROR_IMM_OVERFLOW, NULL);\n+      SET_ERROR_STRING(ERROR_IMM_OVERFLOW, NULL);\n       return FALSE;\n     }\n   if ((e.X_add_number % (1 << shift)) != 0)\n     {\n       /* Not aligned.  */\n-      SET_ERROR_NUMBER (ERROR_OFFSET_UNALIGNED,\n-\t\t\t(void *)\"Operand format is error. eg. \\\"ld rz, (rx, n)\\\"\");\n+      SET_ERROR_INTEGER (ERROR_OFFSET_UNALIGNED, ((unsigned long)1 << shift));\n       return FALSE;\n     }\n \n@@ -3124,7 +3174,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t}\n       else\n \t{\n-\t  SET_ERROR_NUMBER ((oprnd->type == OPRND_TYPE_BRACKET\n+\t  SET_ERROR_STRING ((oprnd->type == OPRND_TYPE_BRACKET\n \t\t\t     ? ERROR_MISSING_LBRACKET\n \t\t\t     : ERROR_MISSING_LANGLE_BRACKETS), NULL);\n \t  return FALSE;\n@@ -3145,7 +3195,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t*s = '\\0';\n       else\n \t{\n-\t  SET_ERROR_NUMBER ((oprnd->type == OPRND_TYPE_BRACKET\n+\t  SET_ERROR_STRING ((oprnd->type == OPRND_TYPE_BRACKET\n \t\t\t     ? ERROR_MISSING_RBRACKET\n \t\t\t     : ERROR_MISSING_RANGLE_BRACKETS), NULL);\n \t  return FALSE;\n@@ -3158,6 +3208,12 @@ get_operand_value (struct csky_opcode_info *op,\n \t}\n       if (**oper == ',')\n \t*oper += 1;\n+      else if (**oper != '\\0')\n+\t{\n+\t  SET_ERROR_STRING (ERROR_MISSING_COMMA, NULL);\n+\t  return FALSE;\n+\t}\n+\n       if (get_operand_value (op, oper, &soprnd->subs[1]) == FALSE)\n \t{\n \t  *s = rc;\n@@ -3200,13 +3256,13 @@ get_operand_value (struct csky_opcode_info *op,\n \n \tif (reg == -1)\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_GREG_ILLEGAL, NULL);\n+\t    SET_ERROR_STRING (ERROR_GREG_ILLEGAL, NULL);\n \t    return FALSE;\n \t  }\n \telse if ((oprnd->type == OPRND_TYPE_GREG0_7 && reg > 7)\n \t\t || (oprnd->type == OPRND_TYPE_GREG0_15 && reg > 15))\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_REG_OVER_RANGE, reg);\n+\t    SET_ERROR_INTEGER (ERROR_REG_OVER_RANGE, reg);\n \t    return FALSE;\n \t  }\n \t*oper += len;\n@@ -3223,7 +3279,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t    || (IS_CSKY_V1 (mach_flag)\n \t\t&& (reg == V1_REG_SP || reg == V1_REG_LR)))\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_REG_OVER_RANGE, reg);\n+\t    SET_ERROR_STRING (ERROR_REG_OVER_RANGE, reg);\n \t    return FALSE;\n \t  }\n \tcsky_insn.val[csky_insn.idx++] = reg;\n@@ -3254,22 +3310,22 @@ get_operand_value (struct csky_opcode_info *op,\n \t  csky_insn.val[csky_insn.idx++] = 0;\n \t  return TRUE;\n \t}\n-      SET_ERROR_NUMBER (ERROR_OPCODE_ILLEGAL, NULL);\n+      SET_ERROR_STRING (ERROR_OPCODE_ILLEGAL, NULL);\n       return FALSE;\n     case OPRND_TYPE_IMM_LDST:\n       return parse_ldst_imm (oper, op, oprnd);\n     case OPRND_TYPE_IMM_FLDST:\n       return parse_ldst_imm (oper, op, oprnd);\n     case OPRND_TYPE_IMM1b:\n-      return is_imm_over_range (oper, 0, 1, -1);\n+      return is_imm_within_range (oper, 0, 1);\n     case OPRND_TYPE_IMM2b:\n-      return is_imm_over_range (oper, 0, 3, -1);\n+      return is_imm_within_range (oper, 0, 3);\n     case OPRND_TYPE_IMM2b_JMPIX:\n       /* ck802j support jmpix16, but not support jmpix32.  */\n       if (IS_CSKY_ARCH_802 (mach_flag)\n \t  && (op->opcode & 0xffff0000) != 0)\n \t{\n-\t  SET_ERROR_NUMBER (ERROR_OPCODE_ILLEGAL, NULL);\n+\t  SET_ERROR_STRING (ERROR_OPCODE_ILLEGAL, NULL);\n \t  return FALSE;\n \t}\n       *oper = parse_exp (*oper, &csky_insn.e1);\n@@ -3278,21 +3334,20 @@ get_operand_value (struct csky_opcode_info *op,\n \t  csky_insn.opcode_end = *oper;\n \t  if (csky_insn.e1.X_add_number & 0x7)\n \t    {\n-\t      SET_ERROR_NUMBER (ERROR_JMPIX_OVER_RANGE, NULL);\n+\t      SET_ERROR_STRING (ERROR_JMPIX_OVER_RANGE, NULL);\n \t      return FALSE;\n \t    }\n \t  csky_insn.val[csky_insn.idx++]\n \t    = (csky_insn.e1.X_add_number >> 3) - 2;\n \t}\n       return TRUE;\n     case OPRND_TYPE_IMM4b:\n-      return is_imm_over_range (oper, 0, 15, -1);\n-      break;\n+      return is_imm_within_range (oper, 0, 15);\n     case OPRND_TYPE_IMM5b:\n-      return is_imm_over_range (oper, 0, 31, -1);\n+      return is_imm_within_range (oper, 0, 31);\n       /* This type for \"bgeni\" in csky v1 ISA.  */\n     case OPRND_TYPE_IMM5b_7_31:\n-      if (is_imm_over_range (oper, 0, 31, -1))\n+      if (is_imm_within_range (oper, 0, 31))\n \t{\n \t  int val = csky_insn.val[csky_insn.idx - 1];\n \t  /* immediate values of 0 -> 6 translate to movi.  */\n@@ -3309,9 +3364,9 @@ get_operand_value (struct csky_opcode_info *op,\n \treturn FALSE;\n \n     case OPRND_TYPE_IMM5b_1_31:\n-      return is_imm_over_range (oper, 1, 31, -1);\n+      return is_imm_within_range (oper, 1, 31);\n     case OPRND_TYPE_IMM5b_POWER:\n-      if (is_imm_over_range (oper, 1, (1u << 31) - 1, 1u << 31))\n+      if (is_imm_within_range_ext (oper, 1, (1u << 31) - 1, 1u << 31))\n \t{\n \t  int log;\n \t  int val = csky_insn.val[csky_insn.idx - 1];\n@@ -3324,7 +3379,7 @@ get_operand_value (struct csky_opcode_info *op,\n \n       /* This type for \"mgeni\" in csky v1 ISA.  */\n       case OPRND_TYPE_IMM5b_7_31_POWER:\n-\tif (is_imm_over_range (oper, 1, (1u << 31) - 1, 1u << 31))\n+\tif (is_imm_within_range_ext (oper, 1, (1u << 31) - 1, 1u << 31))\n \t  {\n \t    int log;\n \t    int val = csky_insn.val[csky_insn.idx - 1];\n@@ -3348,7 +3403,7 @@ get_operand_value (struct csky_opcode_info *op,\n       {\n \tunsigned max_shift = IS_CSKY_V1 (mach_flag) ? 31 : 32;\n \n-\tif (is_imm_over_range (oper, 1, max_shift, -1))\n+\tif (is_imm_within_range (oper, 1, max_shift))\n \t  {\n \t    int i = csky_insn.idx - 1;\n \t    csky_insn.val[i] = 32 - csky_insn.val[i];\n@@ -3361,7 +3416,7 @@ get_operand_value (struct csky_opcode_info *op,\n     case OPRND_TYPE_IMM5b_BMASKI:\n       /* For csky v1 bmask inst.  */\n \n-      if (!is_imm_over_range (oper, 8, 31, 0))\n+      if (!is_imm_within_range_ext (oper, 8, 31, 0))\n \t{\n \t  unsigned int mask_val = csky_insn.val[csky_insn.idx - 1];\n \t  if (mask_val > 0 && mask_val < 8)\n@@ -3379,19 +3434,19 @@ get_operand_value (struct csky_opcode_info *op,\n \n       case OPRND_TYPE_IMM8b_BMASKI:\n       /* For csky v2 bmask, which will transfer to 16bits movi.  */\n-\tif (is_imm_over_range (oper, 1, 8, -1))\n+\tif (is_imm_within_range (oper, 1, 8))\n \t  {\n \t    unsigned int mask_val = csky_insn.val[csky_insn.idx - 1];\n \t    csky_insn.val[csky_insn.idx - 1] = (1 << mask_val) - 1;\n \t    return TRUE;\n \t  }\n \treturn FALSE;\n     case OPRND_TYPE_OIMM4b:\n-      return is_oimm_over_range (oper, 1, 16);\n+      return is_oimm_within_range (oper, 1, 16);\n     case OPRND_TYPE_OIMM5b:\n-      return is_oimm_over_range (oper, 1, 32);\n+      return is_oimm_within_range (oper, 1, 32);\n     case OPRND_TYPE_OIMM5b_IDLY:\n-      if (is_imm_over_range (oper, 0, 32, -1))\n+      if (is_imm_within_range (oper, 0, 32))\n \t{\n \t  /* imm5b for idly n: 0<=n<4, imm5b=3; 4<=n<=32, imm5b=n-1.  */\n \t  unsigned long imm = csky_insn.val[csky_insn.idx - 1];\n@@ -3409,7 +3464,7 @@ get_operand_value (struct csky_opcode_info *op,\n \n       /* For csky v2 bmask inst.  */\n     case OPRND_TYPE_OIMM5b_BMASKI:\n-      if (!is_oimm_over_range (oper, 17, 32))\n+      if (!is_oimm_within_range (oper, 17, 32))\n \t{\n \t  int mask_val = csky_insn.val[csky_insn.idx - 1];\n \t  if (mask_val + 1 == 0)\n@@ -3427,17 +3482,17 @@ get_operand_value (struct csky_opcode_info *op,\n \t}\n       return TRUE;\n     case OPRND_TYPE_IMM7b:\n-      return is_imm_over_range (oper, 0, 127, -1);\n+      return is_imm_within_range (oper, 0, 127);\n     case OPRND_TYPE_IMM8b:\n-      return is_imm_over_range (oper, 0, 255, -1);\n+      return is_imm_within_range (oper, 0, 255);\n     case OPRND_TYPE_IMM12b:\n-      return is_imm_over_range (oper, 0, 4095, -1);\n+      return is_imm_within_range (oper, 0, 4095);\n     case OPRND_TYPE_IMM15b:\n-      return is_imm_over_range (oper, 0, 0xfffff, -1);\n+      return is_imm_within_range (oper, 0, 0xfffff);\n     case OPRND_TYPE_IMM16b:\n-      return is_imm_over_range (oper, 0, 65535, -1);\n+      return is_imm_within_range (oper, 0, 65535);\n     case OPRND_TYPE_OIMM16b:\n-      return is_oimm_over_range (oper, 1, 65536);\n+      return is_oimm_within_range (oper, 1, 65536);\n     case OPRND_TYPE_IMM32b:\n       {\n \texpressionS e;\n@@ -3501,7 +3556,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t      ret = FALSE;\n \t  }\n \tif (!ret)\n-\t  SET_ERROR_NUMBER (ERROR_OPERANDS_ILLEGAL, csky_insn.opcode_end);\n+\t  SET_ERROR_STRING (ERROR_OPERANDS_ILLEGAL, csky_insn.opcode_end);\n \treturn ret;\n       }\n     case OPRND_TYPE_RM:\n@@ -3541,20 +3596,20 @@ get_operand_value (struct csky_opcode_info *op,\n \tint reg;\n \tif (**oper != '(')\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_MISSING_LBRACKET, NULL);\n+\t    SET_ERROR_STRING (ERROR_MISSING_LBRACKET, NULL);\n \t    return FALSE;\n \t  }\n \t*oper += 1;\n \treg = csky_get_reg_val (*oper, &len);\n \tif (reg == -1)\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_EXP_GREG, NULL);\n+\t    SET_ERROR_STRING (ERROR_EXP_GREG, NULL);\n \t    return FALSE;\n \t  }\n \t*oper += len;\n \tif (**oper != ')')\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_MISSING_RBRACKET, NULL);\n+\t    SET_ERROR_STRING (ERROR_MISSING_RBRACKET, NULL);\n \t    return FALSE;\n \t  }\n \t*oper += 1;\n@@ -3650,7 +3705,7 @@ get_operand_value (struct csky_opcode_info *op,\n \treg = csky_get_reg_val (*oper, &len);\n \tif (reg == -1)\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+\t    SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t      \"The first operand must be register r1.\");\n \t    return FALSE;\n \t  }\n@@ -3668,7 +3723,7 @@ get_operand_value (struct csky_opcode_info *op,\n \treg = csky_get_reg_val (*oper, &len);\n \tif (reg == -1)\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+\t    SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t      \"The second operand must be register r1.\");\n \t    return FALSE;\n \t  }\n@@ -3693,12 +3748,12 @@ get_operand_value (struct csky_opcode_info *op,\n \treg = csky_get_reg_val (*oper, &len);\n \tif (reg == -1)\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_GREG_ILLEGAL, NULL);\n+\t    SET_ERROR_STRING (ERROR_GREG_ILLEGAL, NULL);\n \t    return FALSE;\n \t  }\n \tif (reg != csky_insn.val[0])\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+\t    SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t      \"The second register must be the same as the first.\");\n \t    return FALSE;\n \t  }\n@@ -3716,7 +3771,7 @@ get_operand_value (struct csky_opcode_info *op,\n \treg = csky_get_reg_val (*oper, &len);\n \tif (reg == -1)\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_GREG_ILLEGAL, NULL);\n+\t    SET_ERROR_STRING (ERROR_GREG_ILLEGAL, NULL);\n \t    return FALSE;\n \t  }\n \t/* dummy reg's real type should be same with first operand.  */\n@@ -3772,16 +3827,16 @@ get_operand_value (struct csky_opcode_info *op,\n \tif (reg == -1)\n \t  {\n \t    if (max_reg == 31)\n-\t      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+\t      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\t\"The register must be r0-r31\");\n \t    else\n-\t      SET_ERROR_NUMBER (ERROR_REG_FORMAT,\n+\t      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\t\"The register must be r0-r15\");\n \t    return FALSE;\n \t  }\n \tif (reg > max_reg)\n \t  {\n-\t    SET_ERROR_NUMBER (ERROR_REG_OVER_RANGE, reg);\n+\t    SET_ERROR_STRING (ERROR_REG_OVER_RANGE, reg);\n \t    return FALSE;\n \t  }\n \treg |= reg << shift_num;\n@@ -3890,15 +3945,15 @@ get_operand_value (struct csky_opcode_info *op,\n \t    *oper = new_oper;\n \t    if (e.X_add_number > 31)\n \t      {\n-\t\tSET_ERROR_NUMBER (ERROR_IMM_OVERFLOW, NULL);\n+\t\tSET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n \t\treturn FALSE;\n \t      }\n \t    csky_insn.val[csky_insn.idx++] = e.X_add_number;\n \t    if (oprnd->type == OPRND_TYPE_LSB2SIZE)\n \t      {\n \t\tif (csky_insn.val[csky_insn.idx - 1] > csky_insn.val[csky_insn.idx - 2])\n \t\t  {\n-\t\t    SET_ERROR_NUMBER (ERROR_IMM_OVERFLOW, NULL);\n+\t\t    SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n \t\t    return FALSE;\n \t\t  }\n \t\tcsky_insn.val[csky_insn.idx - 2] -= e.X_add_number;\n@@ -3917,7 +3972,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t  if (**oper == '[')\n \t    {\n \t      (*oper)++;\n-\t      if (is_imm_over_range (oper, 0, 0xf, -1))\n+\t      if (is_imm_within_range (oper, 0, 0xf))\n \t\t{\n \t\t  if (**oper == ']')\n \t\t    {\n@@ -3928,11 +3983,11 @@ get_operand_value (struct csky_opcode_info *op,\n \t\t      return TRUE;\n \t\t    }\n \t\t  else\n-\t\t    SET_ERROR_NUMBER (ERROR_MISSING_RSQUARE_BRACKETS, NULL);\n+\t\t    SET_ERROR_STRING (ERROR_MISSING_RSQUARE_BRACKETS, NULL);\n \t\t}\n \t    }\n \t  else\n-\t    SET_ERROR_NUMBER (ERROR_MISSING_LSQUARE_BRACKETS, NULL);\n+\t    SET_ERROR_STRING (ERROR_MISSING_LSQUARE_BRACKETS, NULL);\n \t}\n       return FALSE;\n \n@@ -3963,7 +4018,7 @@ parse_operands_op (char *str, struct csky_opcode_info *op)\n \t    || (op[i].operand_num == -1 && csky_insn.number != 0)))\n \t{\n \t  /* The smaller err_num is more serious.  */\n-\t  SET_ERROR_NUMBER (ERROR_OPERANDS_NUMBER, op[i].operand_num);\n+\t  SET_ERROR_INTEGER (ERROR_OPERANDS_NUMBER, op[i].operand_num);\n \t  flag_pass = FALSE;\n \t  continue;\n \t}\n@@ -3985,14 +4040,14 @@ parse_operands_op (char *str, struct csky_opcode_info *op)\n \t\toper++;\n \t      else\n \t\t{\n-\t\t  SET_ERROR_NUMBER (ERROR_MISSING_COMMA, NULL);\n+\t\t  SET_ERROR_STRING (ERROR_MISSING_COMMA, NULL);\n \t\t  flag_pass = FALSE;\n \t\t  break;\n \t\t}\n \t    }\n \t  else if (!is_end_of_line[(unsigned char) *oper])\n \t    {\n-\t      SET_ERROR_NUMBER (ERROR_BAD_END, NULL);\n+\t      SET_ERROR_STRING (ERROR_BAD_END, NULL);\n \t      flag_pass = FALSE;\n \t      break;\n \t    }\n@@ -4233,12 +4288,12 @@ md_assemble (char *str)\n \t  return;\n \t}\n       else if (error_state.err_num > ERROR_OPERANDS_NUMBER)\n-\tSET_ERROR_NUMBER (ERROR_OPERANDS_NUMBER, csky_insn.macro->oprnd_num);\n+\tSET_ERROR_STRING (ERROR_OPERANDS_NUMBER, csky_insn.macro->oprnd_num);\n     }\n \n   if (csky_insn.opcode == NULL)\n     {\n-      SET_ERROR_NUMBER (ERROR_OPCODE_ILLEGAL, NULL);\n+      SET_ERROR_STRING (ERROR_OPCODE_ILLEGAL, NULL);\n       csky_show_error (error_state.err_num, error_state.opnum,\n \t\t       (void *)error_state.arg1, (void *)error_state.arg1);\n       return;\n@@ -5551,7 +5606,7 @@ static void\n csky_idly (void)\n {\n   char *s = csky_insn.opcode_end;\n-  if (!is_imm_over_range (&s, 4, 4, -1))\n+  if (!is_imm_within_range (&s, 4, 4))\n     {\n       as_bad (_(\"second operand must be 4\"));\n       return;\n@@ -5571,7 +5626,7 @@ csky_rolc (void)\n   s += csky_get_macro_operand (s, reg, ',');\n   ++s;\n \n-  if (is_imm_over_range (&s, 1, 1, -1))\n+  if (is_imm_within_range (&s, 1, 1))\n     {\n       csky_macro_md_assemble (\"addc\", reg, reg, NULL);\n       return;\n@@ -6404,23 +6459,33 @@ v2_work_add_sub (void)\n       if (csky_insn.number == 3)\n \t{\n \t  if (csky_insn.val[0] > 7)\n-\t    csky_show_error (ERROR_REG_OVER_RANGE, 1,\n-\t\t\t     (void *)(long)csky_insn.val[0], NULL);\n+\t    {\n+\t      SET_ERROR_INTEGER (ERROR_REG_OVER_RANGE, csky_insn.val[0]);\n+\t      csky_show_error (ERROR_REG_OVER_RANGE, 1, NULL, NULL);\n+\t    }\n \t  if (csky_insn.val[1] > 7)\n-\t    csky_show_error (ERROR_REG_OVER_RANGE, 2,\n-\t\t\t     (void *)(long)csky_insn.val[1], NULL);\n+\t    {\n+\t      SET_ERROR_INTEGER (ERROR_REG_OVER_RANGE, csky_insn.val[1]);\n+\t      csky_show_error (ERROR_REG_OVER_RANGE, 2, NULL, NULL);\n+\t    }\n \t  if (csky_insn.val[2] > 7)\n-\t    csky_show_error (ERROR_REG_OVER_RANGE, 3,\n-\t\t\t     (void *)(long)csky_insn.val[2], NULL);\n+\t    {\n+\t      SET_ERROR_INTEGER (ERROR_REG_OVER_RANGE, csky_insn.val[2]);\n+\t      csky_show_error (ERROR_REG_OVER_RANGE, 3, NULL, NULL);\n+\t    }\n \t}\n       else\n \t{\n \t  if (csky_insn.val[0] > 15)\n-\t    csky_show_error (ERROR_REG_OVER_RANGE, 1,\n-\t\t\t     (void *)(long)csky_insn.val[0], NULL);\n+\t    {\n+\t      SET_ERROR_INTEGER (ERROR_REG_OVER_RANGE, csky_insn.val[0]);\n+\t      csky_show_error (ERROR_REG_OVER_RANGE, 1, NULL, NULL);\n+\t    }\n \t  if (csky_insn.val[1] > 15)\n-\t    csky_show_error (ERROR_REG_OVER_RANGE, 2,\n-\t\t\t     (void *)(long)csky_insn.val[1], NULL);\n+\t    {\n+\t      SET_ERROR_INTEGER (ERROR_REG_OVER_RANGE, csky_insn.val[1]);\n+\t      csky_show_error (ERROR_REG_OVER_RANGE, 2, NULL, NULL);\n+\t    }\n \t}\n       return FALSE;\n     }"
    },
    {
      "sha": "20e7ec31a1782532568fb184e1b9001ea28f8387",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2e82b115cc0eed19dd88f87970e6c0417141baa/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2e82b115cc0eed19dd88f87970e6c0417141baa/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=e2e82b115cc0eed19dd88f87970e6c0417141baa",
      "patch": "@@ -1,3 +1,8 @@\n+2020-08-31  Cooper Qu  <cooper.qu@linux.alibaba.com>\n+\n+\t* csky-dis.c (csky_output_operand): Assign dis_info.value for\n+\tOPRND_TYPE_VREG.\n+\n 2020-08-30  Alan Modra  <amodra@gmail.com>\n \n \t* cr16-dis.c: Formatting."
    },
    {
      "sha": "09eed4b8253d248a6fa0f52cd57c61c1e6c1c94f",
      "filename": "opcodes/csky-dis.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2e82b115cc0eed19dd88f87970e6c0417141baa/opcodes/csky-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2e82b115cc0eed19dd88f87970e6c0417141baa/opcodes/csky-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/csky-dis.c?ref=e2e82b115cc0eed19dd88f87970e6c0417141baa",
      "patch": "@@ -342,6 +342,7 @@ csky_output_operand (char *str, struct operand const *oprnd,\n       strcat (str, buf);\n       break;\n     case OPRND_TYPE_VREG:\n+      dis_info.value = value;\n       sprintf (buf, \"vr%d\", (int)value);\n       strcat (str, buf);\n       break;"
    }
  ]
}