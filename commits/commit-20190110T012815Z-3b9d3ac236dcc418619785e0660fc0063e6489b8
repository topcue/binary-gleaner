{
  "sha": "3b9d3ac236dcc418619785e0660fc0063e6489b8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2I5ZDNhYzIzNmRjYzQxODYxOTc4NWUwNjYwZmMwMDYzZTY0ODliOA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2018-11-24T18:54:26Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-10T01:28:15Z"
    },
    "message": "Remove ALL_OBJSECTIONS\n\nThis removes the ALL_OBJSECTIONS macro, replacing its uses with ranged\nfor loops.\n\nThe special code in this macro for noticing a \"break\" from the inner\nloop was only needed in a single place; so rather than try to\nreplicate this, I've simply replaced that use with a \"goto\".\n\ngdb/ChangeLog\n2019-01-09  Tom Tromey  <tom@tromey.com>\n\n\t* symfile.c (overlay_invalidate_all, find_pc_overlay)\n\t(find_pc_mapped_section, list_overlays_command)\n\t(map_overlay_command, unmap_overlay_command)\n\t(simple_overlay_update): Use all_objfiles.\n\t* spu-tdep.c (spu_overlay_update): Use all_objfiles.\n\t* printcmd.c (info_symbol_command): Use all_objfiles.\n\t* objfiles.h (ALL_OBJSECTIONS): Remove.\n\t* maint.c (maintenance_translate_address): Use all_objfiles.\n\t* gcore.c (gcore_create_callback): Use all_objfiles.\n\t(objfile_find_memory_regions): Likewise.",
    "tree": {
      "sha": "cf889e1bf17b40f716551bb173c9189a45a33a99",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cf889e1bf17b40f716551bb173c9189a45a33a99"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3b9d3ac236dcc418619785e0660fc0063e6489b8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3b9d3ac236dcc418619785e0660fc0063e6489b8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3b9d3ac236dcc418619785e0660fc0063e6489b8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3b9d3ac236dcc418619785e0660fc0063e6489b8/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8b31193aa9752ba60d63cedaba943370d76ce543",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8b31193aa9752ba60d63cedaba943370d76ce543",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8b31193aa9752ba60d63cedaba943370d76ce543"
    }
  ],
  "stats": {
    "total": 508,
    "additions": 244,
    "deletions": 264
  },
  "files": [
    {
      "sha": "d7d1ad6cc3b18bb2110b1c7ff9404d2c1e05ceea",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "patch": "@@ -1,3 +1,16 @@\n+2019-01-09  Tom Tromey  <tom@tromey.com>\n+\n+\t* symfile.c (overlay_invalidate_all, find_pc_overlay)\n+\t(find_pc_mapped_section, list_overlays_command)\n+\t(map_overlay_command, unmap_overlay_command)\n+\t(simple_overlay_update): Use all_objfiles.\n+\t* spu-tdep.c (spu_overlay_update): Use all_objfiles.\n+\t* printcmd.c (info_symbol_command): Use all_objfiles.\n+\t* objfiles.h (ALL_OBJSECTIONS): Remove.\n+\t* maint.c (maintenance_translate_address): Use all_objfiles.\n+\t* gcore.c (gcore_create_callback): Use all_objfiles.\n+\t(objfile_find_memory_regions): Likewise.\n+\n 2019-01-09  Tom Tromey  <tom@tromey.com>\n \n \t* symtab.c (find_line_symtab, info_sources_command)"
    },
    {
      "sha": "1a2ed0cd7e09850f4cb4a69f8d5648fdf96ee227",
      "filename": "gdb/gcore.c",
      "status": "modified",
      "additions": 52,
      "deletions": 52,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/gcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/gcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.c?ref=3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "patch": "@@ -424,34 +424,34 @@ gcore_create_callback (CORE_ADDR vaddr, unsigned long size, int read,\n     {\n       /* See if this region of memory lies inside a known file on disk.\n \t If so, we can avoid copying its contents by clearing SEC_LOAD.  */\n-      struct objfile *objfile;\n       struct obj_section *objsec;\n \n-      ALL_OBJSECTIONS (objfile, objsec)\n-\t{\n-\t  bfd *abfd = objfile->obfd;\n-\t  asection *asec = objsec->the_bfd_section;\n-\t  bfd_vma align = (bfd_vma) 1 << bfd_get_section_alignment (abfd,\n-\t\t\t\t\t\t\t\t    asec);\n-\t  bfd_vma start = obj_section_addr (objsec) & -align;\n-\t  bfd_vma end = (obj_section_endaddr (objsec) + align - 1) & -align;\n-\n-\t  /* Match if either the entire memory region lies inside the\n-\t     section (i.e. a mapping covering some pages of a large\n-\t     segment) or the entire section lies inside the memory region\n-\t     (i.e. a mapping covering multiple small sections).\n-\n-\t     This BFD was synthesized from reading target memory,\n-\t     we don't want to omit that.  */\n-\t  if (objfile->separate_debug_objfile_backlink == NULL\n-\t      && ((vaddr >= start && vaddr + size <= end)\n-\t          || (start >= vaddr && end <= vaddr + size))\n-\t      && !(bfd_get_file_flags (abfd) & BFD_IN_MEMORY))\n-\t    {\n-\t      flags &= ~(SEC_LOAD | SEC_HAS_CONTENTS);\n-\t      goto keep;\t/* Break out of two nested for loops.  */\n-\t    }\n-\t}\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\tALL_OBJFILE_OSECTIONS (objfile, objsec)\n+\t  {\n+\t    bfd *abfd = objfile->obfd;\n+\t    asection *asec = objsec->the_bfd_section;\n+\t    bfd_vma align = (bfd_vma) 1 << bfd_get_section_alignment (abfd,\n+\t\t\t\t\t\t\t\t      asec);\n+\t    bfd_vma start = obj_section_addr (objsec) & -align;\n+\t    bfd_vma end = (obj_section_endaddr (objsec) + align - 1) & -align;\n+\n+\t    /* Match if either the entire memory region lies inside the\n+\t       section (i.e. a mapping covering some pages of a large\n+\t       segment) or the entire section lies inside the memory region\n+\t       (i.e. a mapping covering multiple small sections).\n+\n+\t       This BFD was synthesized from reading target memory,\n+\t       we don't want to omit that.  */\n+\t    if (objfile->separate_debug_objfile_backlink == NULL\n+\t\t&& ((vaddr >= start && vaddr + size <= end)\n+\t\t    || (start >= vaddr && end <= vaddr + size))\n+\t\t&& !(bfd_get_file_flags (abfd) & BFD_IN_MEMORY))\n+\t      {\n+\t\tflags &= ~(SEC_LOAD | SEC_HAS_CONTENTS);\n+\t\tgoto keep;\t/* Break out of two nested for loops.  */\n+\t      }\n+\t  }\n \n     keep:;\n     }\n@@ -489,36 +489,36 @@ objfile_find_memory_regions (struct target_ops *self,\n \t\t\t     find_memory_region_ftype func, void *obfd)\n {\n   /* Use objfile data to create memory sections.  */\n-  struct objfile *objfile;\n   struct obj_section *objsec;\n   bfd_vma temp_bottom, temp_top;\n \n   /* Call callback function for each objfile section.  */\n-  ALL_OBJSECTIONS (objfile, objsec)\n-    {\n-      bfd *ibfd = objfile->obfd;\n-      asection *isec = objsec->the_bfd_section;\n-      flagword flags = bfd_get_section_flags (ibfd, isec);\n-\n-      /* Separate debug info files are irrelevant for gcore.  */\n-      if (objfile->separate_debug_objfile_backlink != NULL)\n-\tcontinue;\n-\n-      if ((flags & SEC_ALLOC) || (flags & SEC_LOAD))\n-\t{\n-\t  int size = bfd_section_size (ibfd, isec);\n-\t  int ret;\n-\n-\t  ret = (*func) (obj_section_addr (objsec), size, \n-\t\t\t 1, /* All sections will be readable.  */\n-\t\t\t (flags & SEC_READONLY) == 0, /* Writable.  */\n-\t\t\t (flags & SEC_CODE) != 0, /* Executable.  */\n-\t\t\t 1, /* MODIFIED is unknown, pass it as true.  */\n-\t\t\t obfd);\n-\t  if (ret != 0)\n-\t    return ret;\n-\t}\n-    }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    ALL_OBJFILE_OSECTIONS (objfile, objsec)\n+      {\n+\tbfd *ibfd = objfile->obfd;\n+\tasection *isec = objsec->the_bfd_section;\n+\tflagword flags = bfd_get_section_flags (ibfd, isec);\n+\n+\t/* Separate debug info files are irrelevant for gcore.  */\n+\tif (objfile->separate_debug_objfile_backlink != NULL)\n+\t  continue;\n+\n+\tif ((flags & SEC_ALLOC) || (flags & SEC_LOAD))\n+\t  {\n+\t    int size = bfd_section_size (ibfd, isec);\n+\t    int ret;\n+\n+\t    ret = (*func) (obj_section_addr (objsec), size, \n+\t\t\t   1, /* All sections will be readable.  */\n+\t\t\t   (flags & SEC_READONLY) == 0, /* Writable.  */\n+\t\t\t   (flags & SEC_CODE) != 0, /* Executable.  */\n+\t\t\t   1, /* MODIFIED is unknown, pass it as true.  */\n+\t\t\t   obfd);\n+\t    if (ret != 0)\n+\t      return ret;\n+\t  }\n+      }\n \n   /* Make a stack segment.  */\n   if (derive_stack_segment (&temp_bottom, &temp_top))"
    },
    {
      "sha": "f286c6343039df69f756eeb51f19299cd5224b56",
      "filename": "gdb/maint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/maint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/maint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/maint.c?ref=3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "patch": "@@ -430,7 +430,6 @@ maintenance_translate_address (const char *arg, int from_tty)\n   struct obj_section *sect;\n   const char *p;\n   struct bound_minimal_symbol sym;\n-  struct objfile *objfile;\n \n   if (arg == NULL || *arg == 0)\n     error (_(\"requires argument (address or section + address)\"));\n@@ -448,14 +447,15 @@ maintenance_translate_address (const char *arg, int from_tty)\n       int arg_len = p - arg;\n       p = skip_spaces (p + 1);\n \n-      ALL_OBJSECTIONS (objfile, sect)\n-      {\n-\tif (strncmp (sect->the_bfd_section->name, arg, arg_len) == 0)\n-\t  break;\n-      }\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\tALL_OBJFILE_OSECTIONS (objfile, sect)\n+\t  {\n+\t    if (strncmp (sect->the_bfd_section->name, arg, arg_len) == 0)\n+\t      goto found;\n+\t  }\n \n-      if (!objfile)\n-\terror (_(\"Unknown section %s.\"), arg);\n+      error (_(\"Unknown section %s.\"), arg);\n+    found: ;\n     }\n \n   address = parse_and_eval_address (p);"
    },
    {
      "sha": "c0fc36f087c065e5993791cc7bf9ac73c99b9b3e",
      "filename": "gdb/objfiles.h",
      "status": "modified",
      "additions": 0,
      "deletions": 36,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/objfiles.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/objfiles.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.h?ref=3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "patch": "@@ -705,42 +705,6 @@ class objfile_msymbols\n       }\t\t\t\t\t\t\t\t\t\\\n     else\n \n-/* Traverse all obj_sections in all objfiles in the current program\n-   space.\n-\n-   Note that this detects a \"break\" in the inner loop, and exits\n-   immediately from the outer loop as well, thus, client code doesn't\n-   need to know that this is implemented with a double for.  The extra\n-   hair is to make sure that a \"break;\" stops the outer loop iterating\n-   as well, and both OBJFILE and OSECT are left unmodified:\n-\n-    - The outer loop learns about the inner loop's end condition, and\n-      stops iterating if it detects the inner loop didn't reach its\n-      end.  In other words, the outer loop keeps going only if the\n-      inner loop reached its end cleanly [(osect) ==\n-      (objfile)->sections_end].\n-\n-    - OSECT is initialized in the outer loop initialization\n-      expressions, such as if the inner loop has reached its end, so\n-      the check mentioned above succeeds the first time.\n-\n-    - The trick to not clearing OBJFILE on a \"break;\" is, in the outer\n-      loop's loop expression, advance OBJFILE, but iff the inner loop\n-      reached its end.  If not, there was a \"break;\", so leave OBJFILE\n-      as is; the outer loop's conditional will break immediately as\n-      well (as OSECT will be different from OBJFILE->sections_end).  */\n-\n-#define ALL_OBJSECTIONS(objfile, osect)\t\t\t\t\t\\\n-  for ((objfile) = current_program_space->objfiles,\t\t\t\\\n-\t (objfile) != NULL ? ((osect) = (objfile)->sections_end) : 0;\t\\\n-       (objfile) != NULL\t\t\t\t\t\t\\\n-\t && (osect) == (objfile)->sections_end;\t\t\t\t\\\n-       ((osect) == (objfile)->sections_end\t\t\t\t\\\n-\t? ((objfile) = (objfile)->next,\t\t\t\t\t\\\n-\t   (objfile) != NULL ? (osect) = (objfile)->sections_end : 0)\t\\\n-\t: 0))\t\t\t\t\t\t\t\t\\\n-    ALL_OBJFILE_OSECTIONS (objfile, osect)\n-\n #define SECT_OFF_DATA(objfile) \\\n      ((objfile->sect_index_data == -1) \\\n       ? (internal_error (__FILE__, __LINE__, \\"
    },
    {
      "sha": "9c476e743d39b95db9f439701f063f9f7b61cde2",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 70,
      "deletions": 68,
      "changes": 138,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "patch": "@@ -1273,7 +1273,6 @@ static void\n info_symbol_command (const char *arg, int from_tty)\n {\n   struct minimal_symbol *msymbol;\n-  struct objfile *objfile;\n   struct obj_section *osect;\n   CORE_ADDR addr, sect_addr;\n   int matches = 0;\n@@ -1283,78 +1282,81 @@ info_symbol_command (const char *arg, int from_tty)\n     error_no_arg (_(\"address\"));\n \n   addr = parse_and_eval_address (arg);\n-  ALL_OBJSECTIONS (objfile, osect)\n-  {\n-    /* Only process each object file once, even if there's a separate\n-       debug file.  */\n-    if (objfile->separate_debug_objfile_backlink)\n-      continue;\n-\n-    sect_addr = overlay_mapped_address (addr, osect);\n-\n-    if (obj_section_addr (osect) <= sect_addr\n-\t&& sect_addr < obj_section_endaddr (osect)\n-\t&& (msymbol\n-\t    = lookup_minimal_symbol_by_pc_section (sect_addr, osect).minsym))\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    ALL_OBJFILE_OSECTIONS (objfile, osect)\n       {\n-\tconst char *obj_name, *mapped, *sec_name, *msym_name;\n-\tconst char *loc_string;\n-\n-\tmatches = 1;\n-\toffset = sect_addr - MSYMBOL_VALUE_ADDRESS (objfile, msymbol);\n-\tmapped = section_is_mapped (osect) ? _(\"mapped\") : _(\"unmapped\");\n-\tsec_name = osect->the_bfd_section->name;\n-\tmsym_name = MSYMBOL_PRINT_NAME (msymbol);\n-\n-\t/* Don't print the offset if it is zero.\n-\t   We assume there's no need to handle i18n of \"sym + offset\".  */\n-\tstd::string string_holder;\n-\tif (offset)\n+\t/* Only process each object file once, even if there's a separate\n+\t   debug file.  */\n+\tif (objfile->separate_debug_objfile_backlink)\n+\t  continue;\n+\n+\tsect_addr = overlay_mapped_address (addr, osect);\n+\n+\tif (obj_section_addr (osect) <= sect_addr\n+\t    && sect_addr < obj_section_endaddr (osect)\n+\t    && (msymbol\n+\t\t= lookup_minimal_symbol_by_pc_section (sect_addr,\n+\t\t\t\t\t\t       osect).minsym))\n \t  {\n-\t    string_holder = string_printf (\"%s + %u\", msym_name, offset);\n-\t    loc_string = string_holder.c_str ();\n-\t  }\n-\telse\n-\t  loc_string = msym_name;\n-\n-\tgdb_assert (osect->objfile && objfile_name (osect->objfile));\n-\tobj_name = objfile_name (osect->objfile);\n-\n-\tif (MULTI_OBJFILE_P ())\n-\t  if (pc_in_unmapped_range (addr, osect))\n-\t    if (section_is_overlay (osect))\n-\t      printf_filtered (_(\"%s in load address range of \"\n-\t\t\t\t \"%s overlay section %s of %s\\n\"),\n-\t\t\t       loc_string, mapped, sec_name, obj_name);\n-\t    else\n-\t      printf_filtered (_(\"%s in load address range of \"\n-\t\t\t\t \"section %s of %s\\n\"),\n-\t\t\t       loc_string, sec_name, obj_name);\n-\t  else\n-\t    if (section_is_overlay (osect))\n-\t      printf_filtered (_(\"%s in %s overlay section %s of %s\\n\"),\n-\t\t\t       loc_string, mapped, sec_name, obj_name);\n-\t    else\n-\t      printf_filtered (_(\"%s in section %s of %s\\n\"),\n-\t\t\t       loc_string, sec_name, obj_name);\n-\telse\n-\t  if (pc_in_unmapped_range (addr, osect))\n-\t    if (section_is_overlay (osect))\n-\t      printf_filtered (_(\"%s in load address range of %s overlay \"\n-\t\t\t\t \"section %s\\n\"),\n-\t\t\t       loc_string, mapped, sec_name);\n+\t    const char *obj_name, *mapped, *sec_name, *msym_name;\n+\t    const char *loc_string;\n+\n+\t    matches = 1;\n+\t    offset = sect_addr - MSYMBOL_VALUE_ADDRESS (objfile, msymbol);\n+\t    mapped = section_is_mapped (osect) ? _(\"mapped\") : _(\"unmapped\");\n+\t    sec_name = osect->the_bfd_section->name;\n+\t    msym_name = MSYMBOL_PRINT_NAME (msymbol);\n+\n+\t    /* Don't print the offset if it is zero.\n+\t       We assume there's no need to handle i18n of \"sym + offset\".  */\n+\t    std::string string_holder;\n+\t    if (offset)\n+\t      {\n+\t\tstring_holder = string_printf (\"%s + %u\", msym_name, offset);\n+\t\tloc_string = string_holder.c_str ();\n+\t      }\n \t    else\n-\t      printf_filtered (_(\"%s in load address range of section %s\\n\"),\n-\t\t\t       loc_string, sec_name);\n-\t  else\n-\t    if (section_is_overlay (osect))\n-\t      printf_filtered (_(\"%s in %s overlay section %s\\n\"),\n-\t\t\t       loc_string, mapped, sec_name);\n+\t      loc_string = msym_name;\n+\n+\t    gdb_assert (osect->objfile && objfile_name (osect->objfile));\n+\t    obj_name = objfile_name (osect->objfile);\n+\n+\t    if (MULTI_OBJFILE_P ())\n+\t      if (pc_in_unmapped_range (addr, osect))\n+\t\tif (section_is_overlay (osect))\n+\t\t  printf_filtered (_(\"%s in load address range of \"\n+\t\t\t\t     \"%s overlay section %s of %s\\n\"),\n+\t\t\t\t   loc_string, mapped, sec_name, obj_name);\n+\t\telse\n+\t\t  printf_filtered (_(\"%s in load address range of \"\n+\t\t\t\t     \"section %s of %s\\n\"),\n+\t\t\t\t   loc_string, sec_name, obj_name);\n+\t      else\n+\t\tif (section_is_overlay (osect))\n+\t\t  printf_filtered (_(\"%s in %s overlay section %s of %s\\n\"),\n+\t\t\t\t   loc_string, mapped, sec_name, obj_name);\n+\t\telse\n+\t\t  printf_filtered (_(\"%s in section %s of %s\\n\"),\n+\t\t\t\t   loc_string, sec_name, obj_name);\n \t    else\n-\t      printf_filtered (_(\"%s in section %s\\n\"),\n-\t\t\t       loc_string, sec_name);\n+\t      if (pc_in_unmapped_range (addr, osect))\n+\t\tif (section_is_overlay (osect))\n+\t\t  printf_filtered (_(\"%s in load address range of %s overlay \"\n+\t\t\t\t     \"section %s\\n\"),\n+\t\t\t\t   loc_string, mapped, sec_name);\n+\t\telse\n+\t\t  printf_filtered\n+\t\t    (_(\"%s in load address range of section %s\\n\"),\n+\t\t     loc_string, sec_name);\n+\t      else\n+\t\tif (section_is_overlay (osect))\n+\t\t  printf_filtered (_(\"%s in %s overlay section %s\\n\"),\n+\t\t\t\t   loc_string, mapped, sec_name);\n+\t\telse\n+\t\t  printf_filtered (_(\"%s in section %s\\n\"),\n+\t\t\t\t   loc_string, sec_name);\n+\t  }\n       }\n-  }\n   if (matches == 0)\n     printf_filtered (_(\"No symbol matches %s.\\n\"), arg);\n }"
    },
    {
      "sha": "33081fb8285c883e868c125aa9a47c1655c83277",
      "filename": "gdb/spu-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/spu-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/spu-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/spu-tdep.c?ref=3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "patch": "@@ -1883,11 +1883,10 @@ spu_overlay_update (struct obj_section *osect)\n   /* All sections.  */\n   else\n     {\n-      struct objfile *objfile;\n-\n-      ALL_OBJSECTIONS (objfile, osect)\n-\tif (section_is_overlay (osect))\n-\t  spu_overlay_update_osect (osect);\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\tALL_OBJFILE_OSECTIONS (objfile, osect)\n+\t  if (section_is_overlay (osect))\n+\t    spu_overlay_update_osect (osect);\n     }\n }\n "
    },
    {
      "sha": "46c2299dc14bd7b92182a5ba72d83730197862d2",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 97,
      "deletions": 95,
      "changes": 192,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b9d3ac236dcc418619785e0660fc0063e6489b8/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "patch": "@@ -2988,12 +2988,12 @@ section_is_overlay (struct obj_section *section)\n static void\n overlay_invalidate_all (void)\n {\n-  struct objfile *objfile;\n   struct obj_section *sect;\n \n-  ALL_OBJSECTIONS (objfile, sect)\n-    if (section_is_overlay (sect))\n-      sect->ovly_mapped = -1;\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    ALL_OBJFILE_OSECTIONS (objfile, sect)\n+      if (section_is_overlay (sect))\n+\tsect->ovly_mapped = -1;\n }\n \n /* Function: section_is_mapped (SECTION)\n@@ -3164,24 +3164,24 @@ symbol_overlayed_address (CORE_ADDR address, struct obj_section *section)\n struct obj_section *\n find_pc_overlay (CORE_ADDR pc)\n {\n-  struct objfile *objfile;\n   struct obj_section *osect, *best_match = NULL;\n \n   if (overlay_debugging)\n     {\n-      ALL_OBJSECTIONS (objfile, osect)\n-\tif (section_is_overlay (osect))\n-\t  {\n-\t    if (pc_in_mapped_range (pc, osect))\n-\t      {\n-\t\tif (section_is_mapped (osect))\n-\t\t  return osect;\n-\t\telse\n-\t\t  best_match = osect;\n-\t      }\n-\t    else if (pc_in_unmapped_range (pc, osect))\n-\t      best_match = osect;\n-\t  }\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\tALL_OBJFILE_OSECTIONS (objfile, osect)\n+\t  if (section_is_overlay (osect))\n+\t    {\n+\t      if (pc_in_mapped_range (pc, osect))\n+\t\t{\n+\t\t  if (section_is_mapped (osect))\n+\t\t    return osect;\n+\t\t  else\n+\t\t    best_match = osect;\n+\t\t}\n+\t      else if (pc_in_unmapped_range (pc, osect))\n+\t\tbest_match = osect;\n+\t    }\n     }\n   return best_match;\n }\n@@ -3193,14 +3193,14 @@ find_pc_overlay (CORE_ADDR pc)\n struct obj_section *\n find_pc_mapped_section (CORE_ADDR pc)\n {\n-  struct objfile *objfile;\n   struct obj_section *osect;\n \n   if (overlay_debugging)\n     {\n-      ALL_OBJSECTIONS (objfile, osect)\n-\tif (pc_in_mapped_range (pc, osect) && section_is_mapped (osect))\n-\t  return osect;\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\tALL_OBJFILE_OSECTIONS (objfile, osect)\n+\t  if (pc_in_mapped_range (pc, osect) && section_is_mapped (osect))\n+\t    return osect;\n     }\n \n   return NULL;\n@@ -3213,36 +3213,36 @@ static void\n list_overlays_command (const char *args, int from_tty)\n {\n   int nmapped = 0;\n-  struct objfile *objfile;\n   struct obj_section *osect;\n \n   if (overlay_debugging)\n     {\n-      ALL_OBJSECTIONS (objfile, osect)\n-      if (section_is_mapped (osect))\n-\t{\n-\t  struct gdbarch *gdbarch = get_objfile_arch (objfile);\n-\t  const char *name;\n-\t  bfd_vma lma, vma;\n-\t  int size;\n-\n-\t  vma = bfd_section_vma (objfile->obfd, osect->the_bfd_section);\n-\t  lma = bfd_section_lma (objfile->obfd, osect->the_bfd_section);\n-\t  size = bfd_get_section_size (osect->the_bfd_section);\n-\t  name = bfd_section_name (objfile->obfd, osect->the_bfd_section);\n-\n-\t  printf_filtered (\"Section %s, loaded at \", name);\n-\t  fputs_filtered (paddress (gdbarch, lma), gdb_stdout);\n-\t  puts_filtered (\" - \");\n-\t  fputs_filtered (paddress (gdbarch, lma + size), gdb_stdout);\n-\t  printf_filtered (\", mapped at \");\n-\t  fputs_filtered (paddress (gdbarch, vma), gdb_stdout);\n-\t  puts_filtered (\" - \");\n-\t  fputs_filtered (paddress (gdbarch, vma + size), gdb_stdout);\n-\t  puts_filtered (\"\\n\");\n-\n-\t  nmapped++;\n-\t}\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\tALL_OBJFILE_OSECTIONS (objfile, osect)\n+\t  if (section_is_mapped (osect))\n+\t    {\n+\t      struct gdbarch *gdbarch = get_objfile_arch (objfile);\n+\t      const char *name;\n+\t      bfd_vma lma, vma;\n+\t      int size;\n+\n+\t      vma = bfd_section_vma (objfile->obfd, osect->the_bfd_section);\n+\t      lma = bfd_section_lma (objfile->obfd, osect->the_bfd_section);\n+\t      size = bfd_get_section_size (osect->the_bfd_section);\n+\t      name = bfd_section_name (objfile->obfd, osect->the_bfd_section);\n+\n+\t      printf_filtered (\"Section %s, loaded at \", name);\n+\t      fputs_filtered (paddress (gdbarch, lma), gdb_stdout);\n+\t      puts_filtered (\" - \");\n+\t      fputs_filtered (paddress (gdbarch, lma + size), gdb_stdout);\n+\t      printf_filtered (\", mapped at \");\n+\t      fputs_filtered (paddress (gdbarch, vma), gdb_stdout);\n+\t      puts_filtered (\" - \");\n+\t      fputs_filtered (paddress (gdbarch, vma + size), gdb_stdout);\n+\t      puts_filtered (\"\\n\");\n+\n+\t      nmapped++;\n+\t    }\n     }\n   if (nmapped == 0)\n     printf_filtered (_(\"No sections are mapped.\\n\"));\n@@ -3254,7 +3254,6 @@ list_overlays_command (const char *args, int from_tty)\n static void\n map_overlay_command (const char *args, int from_tty)\n {\n-  struct objfile *objfile, *objfile2;\n   struct obj_section *sec, *sec2;\n \n   if (!overlay_debugging)\n@@ -3266,29 +3265,33 @@ map_overlay_command (const char *args, int from_tty)\n     error (_(\"Argument required: name of an overlay section\"));\n \n   /* First, find a section matching the user supplied argument.  */\n-  ALL_OBJSECTIONS (objfile, sec)\n-    if (!strcmp (bfd_section_name (objfile->obfd, sec->the_bfd_section), args))\n-    {\n-      /* Now, check to see if the section is an overlay.  */\n-      if (!section_is_overlay (sec))\n-\tcontinue;\t\t/* not an overlay section */\n-\n-      /* Mark the overlay as \"mapped\".  */\n-      sec->ovly_mapped = 1;\n-\n-      /* Next, make a pass and unmap any sections that are\n-         overlapped by this new section: */\n-      ALL_OBJSECTIONS (objfile2, sec2)\n-\tif (sec2->ovly_mapped && sec != sec2 && sections_overlap (sec, sec2))\n+  for (objfile *obj_file : all_objfiles (current_program_space))\n+    ALL_OBJFILE_OSECTIONS (obj_file, sec)\n+      if (!strcmp (bfd_section_name (obj_file->obfd, sec->the_bfd_section),\n+\t\t   args))\n \t{\n-\t  if (info_verbose)\n-\t    printf_unfiltered (_(\"Note: section %s unmapped by overlap\\n\"),\n-\t\t\t     bfd_section_name (objfile->obfd,\n-\t\t\t\t\t       sec2->the_bfd_section));\n-\t  sec2->ovly_mapped = 0;\t/* sec2 overlaps sec: unmap sec2.  */\n+\t  /* Now, check to see if the section is an overlay.  */\n+\t  if (!section_is_overlay (sec))\n+\t    continue;\t\t/* not an overlay section */\n+\n+\t  /* Mark the overlay as \"mapped\".  */\n+\t  sec->ovly_mapped = 1;\n+\n+\t  /* Next, make a pass and unmap any sections that are\n+\t     overlapped by this new section: */\n+\t  for (objfile *objfile2 : all_objfiles (current_program_space))\n+\t    ALL_OBJFILE_OSECTIONS (objfile2, sec2)\n+\t      if (sec2->ovly_mapped && sec != sec2 && sections_overlap (sec,\n+\t\t\t\t\t\t\t\t\tsec2))\n+\t\t{\n+\t\t  if (info_verbose)\n+\t\t    printf_unfiltered (_(\"Note: section %s unmapped by overlap\\n\"),\n+\t\t\t\t       bfd_section_name (obj_file->obfd,\n+\t\t\t\t\t\t\t sec2->the_bfd_section));\n+\t\t  sec2->ovly_mapped = 0; /* sec2 overlaps sec: unmap sec2.  */\n+\t\t}\n+\t  return;\n \t}\n-      return;\n-    }\n   error (_(\"No overlay section called %s\"), args);\n }\n \n@@ -3299,7 +3302,6 @@ map_overlay_command (const char *args, int from_tty)\n static void\n unmap_overlay_command (const char *args, int from_tty)\n {\n-  struct objfile *objfile;\n   struct obj_section *sec = NULL;\n \n   if (!overlay_debugging)\n@@ -3311,14 +3313,15 @@ unmap_overlay_command (const char *args, int from_tty)\n     error (_(\"Argument required: name of an overlay section\"));\n \n   /* First, find a section matching the user supplied argument.  */\n-  ALL_OBJSECTIONS (objfile, sec)\n-    if (!strcmp (bfd_section_name (objfile->obfd, sec->the_bfd_section), args))\n-    {\n-      if (!sec->ovly_mapped)\n-\terror (_(\"Section %s is not mapped\"), args);\n-      sec->ovly_mapped = 0;\n-      return;\n-    }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    ALL_OBJFILE_OSECTIONS (objfile, sec)\n+      if (!strcmp (bfd_section_name (objfile->obfd, sec->the_bfd_section), args))\n+\t{\n+\t  if (!sec->ovly_mapped)\n+\t    error (_(\"Section %s is not mapped\"), args);\n+\t  sec->ovly_mapped = 0;\n+\t  return;\n+\t}\n   error (_(\"No overlay section called %s\"), args);\n }\n \n@@ -3550,8 +3553,6 @@ simple_overlay_update_1 (struct obj_section *osect)\n void\n simple_overlay_update (struct obj_section *osect)\n {\n-  struct objfile *objfile;\n-\n   /* Were we given an osect to look up?  NULL means do all of them.  */\n   if (osect)\n     /* Have we got a cached copy of the target's overlay table?  */\n@@ -3583,20 +3584,21 @@ simple_overlay_update (struct obj_section *osect)\n     return;\n \n   /* Now may as well update all sections, even if only one was requested.  */\n-  ALL_OBJSECTIONS (objfile, osect)\n-    if (section_is_overlay (osect))\n-    {\n-      int i;\n-      asection *bsect = osect->the_bfd_section;\n-\n-      for (i = 0; i < cache_novlys; i++)\n-\tif (cache_ovly_table[i][VMA] == bfd_section_vma (obfd, bsect)\n-\t    && cache_ovly_table[i][LMA] == bfd_section_lma (obfd, bsect))\n-\t  { /* obj_section matches i'th entry in ovly_table.  */\n-\t    osect->ovly_mapped = cache_ovly_table[i][MAPPED];\n-\t    break;\t\t/* finished with inner for loop: break out.  */\n-\t  }\n-    }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    ALL_OBJFILE_OSECTIONS (objfile, osect)\n+      if (section_is_overlay (osect))\n+\t{\n+\t  int i;\n+\t  asection *bsect = osect->the_bfd_section;\n+\n+\t  for (i = 0; i < cache_novlys; i++)\n+\t    if (cache_ovly_table[i][VMA] == bfd_section_vma (obfd, bsect)\n+\t\t&& cache_ovly_table[i][LMA] == bfd_section_lma (obfd, bsect))\n+\t      { /* obj_section matches i'th entry in ovly_table.  */\n+\t\tosect->ovly_mapped = cache_ovly_table[i][MAPPED];\n+\t\tbreak;\t\t/* finished with inner for loop: break out.  */\n+\t      }\n+\t}\n }\n \n /* Set the output sections and output offsets for section SECTP in"
    }
  ]
}