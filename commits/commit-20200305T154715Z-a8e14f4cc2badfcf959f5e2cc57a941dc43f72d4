{
  "sha": "a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YThlMTRmNGNjMmJhZGZjZjk1OWY1ZTJjYzU3YTk0MWRjNDNmNzJkNA==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-03-05T15:47:15Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-03-05T15:47:15Z"
    },
    "message": "Add support for ELF files which contain multiple reloc sections which all target the same section.\n\n\t* elf-bfd.h (struct elf_backend_data): Add new fields:\n\tinit_secondary_reloc_section, slurp_secondary_reloc_section,\n\twrite_secondary_reloc_section.\n\t(_bfd_elf_init_secondary_reloc_section): Prototype.\n\t(_bfd_elf_slurp_secondary_reloc_section): Prototype.\n\t(_bfd_elf_write_secondary_reloc_section): Prototype.\n\t* elf.c ( bfd_section_from_shdr): Invoke the new\n\tinit_secondary_reloc_section backend function, if defined, when a\n\tsecond reloc section is encountered.\n\t(swap_out_syms): Invoke the new symbol_section_index function, if\n\tdefined, when computing the section index of an OS/PROC specific\n\tsymbol.\n\t(_bfd_elf_init_secondary_reloc_section): New function.\n\t(_bfd_elf_slurp_secondary_reloc_section): New function.\n\t(_bfd_elf_write_secondary_reloc_section): New function.\n\t(_bfd_elf_copy_special_section_fields): New function.\n\t* elfcode.h (elf_write_relocs): Invoke the new\n\twrite_secondary_relocs function, if defined, in order to emit\n\tsecondary relocs.\n\t(elf_slurp_reloc_table): Invoke the new slurp_secondary_relocs\n\tfunction, if defined, in order to read in secondary relocs.\n\t* elfxx-target.h (elf_backend_copy_special_section_fields):\n\tProvide a non-NULL default definition.\n\t(elf_backend_init_secondary_reloc_section): Likewise.\n\t(elf_backend_slurp_secondary_reloc_section): Likewise.\n\t(elf_backend_write_secondary_reloc_section): Likewise.\n\t(struct elf_backend_data elfNN_bed): Add initialisers for the new\n\tfields.\n        * configure.ac (score_elf32_[bl]e_vec): Add elf64.lo\n        * configure: Regenerate.",
    "tree": {
      "sha": "444ec5de9720df67ac7202749119058278f3d9d7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/444ec5de9720df67ac7202749119058278f3d9d7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "842806cb6f1c321666dd086a79a0fdfbd35497ed",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/842806cb6f1c321666dd086a79a0fdfbd35497ed",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/842806cb6f1c321666dd086a79a0fdfbd35497ed"
    }
  ],
  "stats": {
    "total": 478,
    "additions": 465,
    "deletions": 13
  },
  "files": [
    {
      "sha": "1cfff1c04d77e3f359b71f87d50b98367c6655b9",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
      "patch": "@@ -1,3 +1,36 @@\n+2020-03-05  Nick Clifton  <nickc@redhat.com>\n+\n+\t* elf-bfd.h (struct elf_backend_data): Add new fields:\n+\tinit_secondary_reloc_section, slurp_secondary_reloc_section,\n+\twrite_secondary_reloc_section.\n+\t(_bfd_elf_init_secondary_reloc_section): Prototype.\n+\t(_bfd_elf_slurp_secondary_reloc_section): Prototype.\n+\t(_bfd_elf_write_secondary_reloc_section): Prototype.\n+\t* elf.c ( bfd_section_from_shdr): Invoke the new\n+\tinit_secondary_reloc_section backend function, if defined, when a\n+\tsecond reloc section is encountered.\n+\t(swap_out_syms): Invoke the new symbol_section_index function, if\n+\tdefined, when computing the section index of an OS/PROC specific\n+\tsymbol.\n+\t(_bfd_elf_init_secondary_reloc_section): New function.\n+\t(_bfd_elf_slurp_secondary_reloc_section): New function.\n+\t(_bfd_elf_write_secondary_reloc_section): New function.\n+\t(_bfd_elf_copy_special_section_fields): New function.\n+\t* elfcode.h (elf_write_relocs): Invoke the new\n+\twrite_secondary_relocs function, if defined, in order to emit\n+\tsecondary relocs.\n+\t(elf_slurp_reloc_table): Invoke the new slurp_secondary_relocs\n+\tfunction, if defined, in order to read in secondary relocs.\n+\t* elfxx-target.h (elf_backend_copy_special_section_fields):\n+\tProvide a non-NULL default definition.\n+\t(elf_backend_init_secondary_reloc_section): Likewise.\n+\t(elf_backend_slurp_secondary_reloc_section): Likewise.\n+\t(elf_backend_write_secondary_reloc_section): Likewise.\n+\t(struct elf_backend_data elfNN_bed): Add initialisers for the new\n+\tfields.\n+        * configure.ac (score_elf32_[bl]e_vec): Add elf64.lo\n+        * configure: Regenerate.\n+\n 2020-03-05  Alan Modra  <amodra@gmail.com>\n \n \t* archive64.c (_bfd_archive_64_bit_slurp_armap): Check parsed_size"
    },
    {
      "sha": "30b80fe27c16173f18368e8bd31146ef4e84cb5b",
      "filename": "bfd/configure",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/configure?ref=a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
      "patch": "@@ -14887,8 +14887,8 @@ do\n     rx_elf32_linux_le_vec)\t tb=\"$tb elf32-rx.lo elf32.lo $elf\" ;;\n     s390_elf32_vec)\t\t tb=\"$tb elf32-s390.lo elf32.lo $elf\" ;;\n     s390_elf64_vec)\t\t tb=\"$tb elf64-s390.lo elf64.lo $elf\"; target_size=64 ;;\n-    score_elf32_be_vec)\t\t tb=\"$tb elf32-score.lo elf32-score7.lo elf32.lo $elf\"; want64=true; target_size=64 ;;\n-    score_elf32_le_vec)\t\t tb=\"$tb elf32-score.lo elf32-score7.lo elf32.lo $elf\"; want64=true; target_size=64 ;;\n+    score_elf32_be_vec)\t\t tb=\"$tb elf32-score.lo elf32-score7.lo elf32.lo elf64.lo $elf\"; want64=true; target_size=64 ;;\n+    score_elf32_le_vec)\t\t tb=\"$tb elf32-score.lo elf32-score7.lo elf32.lo elf64.lo $elf\"; want64=true; target_size=64 ;;\n     sh_coff_vec)\t\t tb=\"$tb coff-sh.lo $coff\" ;;\n     sh_coff_le_vec)\t\t tb=\"$tb coff-sh.lo $coff\" ;;\n     sh_coff_small_vec)\t\t tb=\"$tb coff-sh.lo $coff\" ;;"
    },
    {
      "sha": "3426ded094aea651e12733acbb039d95982a658d",
      "filename": "bfd/configure.ac",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/configure.ac?ref=a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
      "patch": "@@ -619,8 +619,8 @@ do\n     rx_elf32_linux_le_vec)\t tb=\"$tb elf32-rx.lo elf32.lo $elf\" ;;\n     s390_elf32_vec)\t\t tb=\"$tb elf32-s390.lo elf32.lo $elf\" ;;\n     s390_elf64_vec)\t\t tb=\"$tb elf64-s390.lo elf64.lo $elf\"; target_size=64 ;;\n-    score_elf32_be_vec)\t\t tb=\"$tb elf32-score.lo elf32-score7.lo elf32.lo $elf\"; want64=true; target_size=64 ;;\n-    score_elf32_le_vec)\t\t tb=\"$tb elf32-score.lo elf32-score7.lo elf32.lo $elf\"; want64=true; target_size=64 ;;\n+    score_elf32_be_vec)\t\t tb=\"$tb elf32-score.lo elf32-score7.lo elf32.lo elf64.lo $elf\"; want64=true; target_size=64 ;;\n+    score_elf32_le_vec)\t\t tb=\"$tb elf32-score.lo elf32-score7.lo elf32.lo elf64.lo $elf\"; want64=true; target_size=64 ;;\n     sh_coff_vec)\t\t tb=\"$tb coff-sh.lo $coff\" ;;\n     sh_coff_le_vec)\t\t tb=\"$tb coff-sh.lo $coff\" ;;\n     sh_coff_small_vec)\t\t tb=\"$tb coff-sh.lo $coff\" ;;"
    },
    {
      "sha": "5d9e0fedcda076a270b89bbfe40ad5c80f960448",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
      "patch": "@@ -1509,6 +1509,16 @@ struct elf_backend_data\n      emitted symbol.  If not defined, the value is left unchanged.  */\n   unsigned int (*symbol_section_index) (bfd *, elf_symbol_type *);\n   \n+  /* Called when a section has extra reloc sections.  */\n+  bfd_boolean (*init_secondary_reloc_section) (bfd *, Elf_Internal_Shdr *,\n+\t\t\t\t\t       const char *, unsigned int);\n+\n+  /* Called when after loading the normal relocs for a section.  */\n+  bfd_boolean (*slurp_secondary_relocs) (bfd *, asection *, asymbol **);\n+\n+  /* Called after writing the normal relocs for a section.  */\n+  bfd_boolean (*write_secondary_relocs) (bfd *, asection *);\n+\n   /* This is non-zero if static TLS segments require a special alignment.  */\n   unsigned static_tls_alignment;\n \n@@ -2838,6 +2848,19 @@ extern bfd_vma elf32_r_sym (bfd_vma);\n \n extern bfd_boolean is_debuginfo_file (bfd *);\n \n+\n+extern bfd_boolean _bfd_elf_init_secondary_reloc_section\n+  (bfd *, Elf_Internal_Shdr *, const char *, unsigned int);\n+extern bfd_boolean _bfd_elf_slurp_secondary_reloc_section\n+  (bfd *, asection *, asymbol **);\n+extern bfd_boolean _bfd_elf_copy_special_section_fields\n+  (const bfd *, bfd *, const Elf_Internal_Shdr *, Elf_Internal_Shdr *);\n+extern bfd_boolean _bfd_elf_write_secondary_reloc_section\n+  (bfd *, asection *);\n+extern unsigned int _bfd_elf_symbol_section_index\n+  (bfd *, elf_symbol_type *);\n+\n+\n /* Large common section.  */\n extern asection _bfd_elf_large_com_section;\n "
    },
    {
      "sha": "747d120101fce8d0190ca725f025eea00552b500",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 371,
      "deletions": 6,
      "changes": 377,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
      "patch": "@@ -1607,7 +1607,7 @@ _bfd_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)\n \t  /* Final attempt.  Call the backend copy function\n \t     with a NULL input section.  */\n \t  if (bed->elf_backend_copy_special_section_fields != NULL)\n-\t    bed->elf_backend_copy_special_section_fields (ibfd, obfd, NULL, oheader);\n+\t    (void) bed->elf_backend_copy_special_section_fields (ibfd, obfd, NULL, oheader);\n \t}\n     }\n \n@@ -2458,13 +2458,17 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)\n \t   sections.  */\n \tif (*p_hdr != NULL)\n \t  {\n-\t    _bfd_error_handler\n-\t      /* xgettext:c-format */\n-\t      (_(\"%pB: warning: multiple relocation sections for section %pA \\\n-found - ignoring all but the first\"),\n-\t       abfd, target_sect);\n+\t    if (bed->init_secondary_reloc_section == NULL\n+\t\t|| ! bed->init_secondary_reloc_section (abfd, hdr, name, shindex))\n+\t      {\n+\t\t_bfd_error_handler\n+\t\t  /* xgettext:c-format */\n+\t\t  (_(\"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\"),\n+\t\t   abfd, name, target_sect);\n+\t      }\n \t    goto success;\n \t  }\n+\n \thdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, sizeof (*hdr2));\n \tif (hdr2 == NULL)\n \t  goto fail;\n@@ -12308,3 +12312,364 @@ _bfd_elf_maybe_function_sym (const asymbol *sym, asection *sec,\n     size = 1;\n   return size;\n }\n+\n+/* Set to non-zero to enable some debug messages.  */\n+#define DEBUG_SECONDARY_RELOCS\t 0\n+\n+/* An internal-to-the-bfd-library only section type\n+   used to indicate a cached secondary reloc section.  */\n+#define SHT_SECONDARY_RELOC\t (SHT_LOOS + SHT_RELA)\n+\n+/* Create a BFD section to hold a secondary reloc section.  */\n+\n+bfd_boolean\n+_bfd_elf_init_secondary_reloc_section (bfd * abfd,\n+\t\t\t\t       Elf_Internal_Shdr *hdr,\n+\t\t\t\t       const char * name,\n+\t\t\t\t       unsigned int shindex)\n+{\n+  /* We only support RELA secondary relocs.  */\n+  if (hdr->sh_type != SHT_RELA)\n+    return FALSE;\n+\n+#if DEBUG_SECONDARY_RELOCS\n+  fprintf (stderr, \"secondary reloc section %s encountered\\n\", name);\n+#endif\n+  hdr->sh_type = SHT_SECONDARY_RELOC;\n+  return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);\n+}\n+\n+/* Read in any secondary relocs associated with SEC.  */\n+\n+bfd_boolean\n+_bfd_elf_slurp_secondary_reloc_section (bfd *      abfd,\n+\t\t\t\t\tasection * sec,\n+\t\t\t\t\tasymbol ** symbols)\n+{\n+  const struct elf_backend_data * const ebd = get_elf_backend_data (abfd);\n+  asection * relsec;\n+  bfd_boolean result = TRUE;\n+  bfd_vma (*r_sym) (bfd_vma);\n+\n+#if BFD_DEFAULT_TARGET_SIZE > 32\n+  if (bfd_arch_bits_per_address (abfd) != 32)\n+    r_sym = elf64_r_sym;\n+  else\n+#endif\n+    r_sym = elf32_r_sym;\n+  \n+  /* Discover if there are any secondary reloc sections\n+     associated with SEC.  */\n+  for (relsec = abfd->sections; relsec != NULL; relsec = relsec->next)\n+    {\n+      Elf_Internal_Shdr * hdr = & elf_section_data (relsec)->this_hdr;\n+\n+      if (hdr->sh_type == SHT_SECONDARY_RELOC\n+\t  && hdr->sh_info == (unsigned) elf_section_data (sec)->this_idx)\n+\t{\n+\t  bfd_byte * native_relocs;\n+\t  bfd_byte * native_reloc;\n+\t  arelent * internal_relocs;\n+\t  arelent * internal_reloc;\n+\t  unsigned int i;\n+\t  unsigned int entsize;\n+\t  unsigned int symcount;\n+\t  unsigned int reloc_count;\n+\t  size_t amt;\n+\n+\t  if (ebd->elf_info_to_howto == NULL)\n+\t    return FALSE;\n+\n+#if DEBUG_SECONDARY_RELOCS\n+\t  fprintf (stderr, \"read secondary relocs for %s from %s\\n\",\n+\t\t   sec->name, relsec->name);\n+#endif\n+\t  entsize = hdr->sh_entsize;\n+\n+\t  native_relocs = bfd_malloc (hdr->sh_size);\n+\t  if (native_relocs == NULL)\n+\t    {\n+\t      result = FALSE;\n+\t      continue;\n+\t    }\n+\n+\t  reloc_count = NUM_SHDR_ENTRIES (hdr);\n+\t  if (_bfd_mul_overflow (reloc_count, sizeof (arelent), & amt))\n+\t    {\n+\t      bfd_set_error (bfd_error_file_too_big);\n+\t      result = FALSE;\n+\t      continue;\n+\t    }\n+\n+\t  internal_relocs = (arelent *) bfd_alloc (abfd, amt);\n+\t  if (internal_relocs == NULL)\n+\t    {\n+\t      free (native_relocs);\n+\t      result = FALSE;\n+\t      continue;\n+\t    }\n+\n+\t  if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n+\t      || (bfd_bread (native_relocs, hdr->sh_size, abfd)\n+\t\t  != hdr->sh_size))\n+\t    {\n+\t      free (native_relocs);\n+\t      free (internal_relocs);\n+\t      result = FALSE;\n+\t      continue;\n+\t    }\n+\n+\t  symcount = bfd_get_symcount (abfd);\n+\n+\t  for (i = 0, internal_reloc = internal_relocs,\n+\t\t native_reloc = native_relocs;\n+\t       i < reloc_count;\n+\t       i++, internal_reloc++, native_reloc += entsize)\n+\t    {\n+\t      bfd_boolean res;\n+\t      Elf_Internal_Rela rela;\n+\n+\t      ebd->s->swap_reloca_in (abfd, native_reloc, & rela);\n+\n+\t      /* The address of an ELF reloc is section relative for an object\n+\t\t file, and absolute for an executable file or shared library.\n+\t\t The address of a normal BFD reloc is always section relative,\n+\t\t and the address of a dynamic reloc is absolute..  */\n+\t      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)\n+\t\tinternal_reloc->address = rela.r_offset;\n+\t      else\n+\t\tinternal_reloc->address = rela.r_offset - sec->vma;\n+\n+\t      if (r_sym (rela.r_info) == STN_UNDEF)\n+\t\t{\n+\t\t  /* FIXME: This and the error case below mean that we\n+\t\t     have a symbol on relocs that is not elf_symbol_type.  */\n+\t\t  internal_reloc->sym_ptr_ptr =\n+\t\t    bfd_abs_section_ptr->symbol_ptr_ptr;\n+\t\t}\n+\t      else if (r_sym (rela.r_info) > symcount)\n+\t\t{\n+\t\t  _bfd_error_handler\n+\t\t    /* xgettext:c-format */\n+\t\t    (_(\"%pB(%pA): relocation %d has invalid symbol index %ld\"),\n+\t\t     abfd, sec, i, (long) r_sym (rela.r_info));\n+\t\t  bfd_set_error (bfd_error_bad_value);\n+\t\t  internal_reloc->sym_ptr_ptr =\n+\t\t    bfd_abs_section_ptr->symbol_ptr_ptr;\n+\t\t  result = FALSE;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  asymbol **ps;\n+\n+\t\t  ps = symbols + r_sym (rela.r_info) - 1;\n+\n+\t\t  internal_reloc->sym_ptr_ptr = ps;\n+\t\t  /* Make sure that this symbol is not removed by strip.  */\n+\t\t  (*ps)->flags |= BSF_KEEP;\n+\t\t}\n+\n+\t      internal_reloc->addend = rela.r_addend;\n+\n+\t      res = ebd->elf_info_to_howto (abfd, internal_reloc, & rela);\n+\t      if (! res || internal_reloc->howto == NULL)\n+\t\t{\n+#if DEBUG_SECONDARY_RELOCS\n+\t\t  fprintf (stderr, \"there is no howto associated with reloc %lx\\n\",\n+\t\t\t   rela.r_info);\n+#endif\n+\t\t  result = FALSE;\n+\t\t}\n+\t    }\n+\n+\t  free (native_relocs);\n+\t  /* Store the internal relocs.  */\n+\t  elf_section_data (relsec)->sec_info = internal_relocs;\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+/* Set the ELF section header fields of an output secondary reloc section.  */\n+\n+bfd_boolean\n+_bfd_elf_copy_special_section_fields (const bfd *   ibfd ATTRIBUTE_UNUSED,\n+\t\t\t\t      bfd *         obfd ATTRIBUTE_UNUSED,\n+\t\t\t\t      const Elf_Internal_Shdr * isection,\n+\t\t\t\t      Elf_Internal_Shdr *       osection)\n+{\n+  asection * isec;\n+  asection * osec;\n+\n+  if (isection == NULL)\n+    return FALSE;\n+\n+  if (isection->sh_type != SHT_SECONDARY_RELOC)\n+    return TRUE;\n+\n+  isec = isection->bfd_section;\n+  if (isec == NULL)\n+    return FALSE;\n+\n+  osec = osection->bfd_section;\n+  if (osec == NULL)\n+    return FALSE;\n+\n+  BFD_ASSERT (elf_section_data (osec)->sec_info == NULL);\n+  elf_section_data (osec)->sec_info = elf_section_data (isec)->sec_info;\n+  osection->sh_type = SHT_RELA;\n+  osection->sh_link = elf_onesymtab (obfd);\n+  if (osection->sh_link == 0)\n+    {\n+      /* There is no symbol table - we are hosed...  */\n+      _bfd_error_handler\n+\t/* xgettext:c-format */\n+\t(_(\"%pB(%pA): link section cannot be set because the output file does not have a symbol table\"),\n+\tobfd, osec);\n+      bfd_set_error (bfd_error_bad_value);\n+      return FALSE;\n+    }\n+\n+  /* Find the output section that corresponds to the isection's sh_info link.  */\n+  BFD_ASSERT (isection->sh_info > 0\n+\t      && isection->sh_info < elf_numsections (ibfd));\n+  isection = elf_elfsections (ibfd)[isection->sh_info];\n+\n+  BFD_ASSERT (isection != NULL);\n+  BFD_ASSERT (isection->bfd_section != NULL);\n+  BFD_ASSERT (isection->bfd_section->output_section != NULL);\n+  osection->sh_info =\n+    elf_section_data (isection->bfd_section->output_section)->this_idx;\n+\n+#if DEBUG_SECONDARY_RELOCS\n+  fprintf (stderr, \"update header of %s, sh_link = %u, sh_info = %u\\n\",\n+\t   osec->name, osection->sh_link, osection->sh_info);\n+#endif\n+\n+  return TRUE;\n+}\n+\n+/* Write out a secondary reloc section.  */\n+\n+bfd_boolean\n+_bfd_elf_write_secondary_reloc_section (bfd *abfd, asection *sec)\n+{\n+  const struct elf_backend_data * const ebd = get_elf_backend_data (abfd);\n+  bfd_vma addr_offset;\n+  asection * relsec;\n+  bfd_vma (*r_info) (bfd_vma, bfd_vma);\n+\n+#if BFD_DEFAULT_TARGET_SIZE > 32\n+  if (bfd_arch_bits_per_address (abfd) != 32)\n+    r_info = elf64_r_info;\n+  else\n+#endif\n+    r_info = elf32_r_info;\n+\n+  if (sec == NULL)\n+    return FALSE;\n+\n+  /* The address of an ELF reloc is section relative for an object\n+     file, and absolute for an executable file or shared library.\n+     The address of a BFD reloc is always section relative.  */\n+  addr_offset = 0;\n+  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)\n+    addr_offset = sec->vma;\n+\n+  /* Discover if there are any secondary reloc sections\n+     associated with SEC.  */\n+  for (relsec = abfd->sections; relsec != NULL; relsec = relsec->next)\n+    {\n+      const struct bfd_elf_section_data * const esd = elf_section_data (relsec);\n+      Elf_Internal_Shdr * const hdr = (Elf_Internal_Shdr *) & esd->this_hdr;\n+\n+      if (hdr->sh_type == SHT_RELA\n+\t  && hdr->sh_info == (unsigned) elf_section_data (sec)->this_idx)\n+\t{\n+\t  asymbol *    last_sym;\n+\t  int          last_sym_idx;\n+\t  unsigned int reloc_count;\n+\t  unsigned int idx;\n+\t  arelent *    src_irel;\n+\t  bfd_byte *   dst_rela;\n+\n+\t  BFD_ASSERT (hdr->contents == NULL);\n+\n+\t  reloc_count = hdr->sh_size / hdr->sh_entsize;\n+\t  BFD_ASSERT (reloc_count > 0);\n+\n+\t  hdr->contents = bfd_alloc (abfd, hdr->sh_size);\n+\t  if (hdr->contents == NULL)\n+\t    continue;\n+\n+#if DEBUG_SECONDARY_RELOCS\n+\t  fprintf (stderr, \"write %u secondary relocs for %s from %s\\n\",\n+\t\t   reloc_count, sec->name, relsec->name);\n+#endif\n+\t  last_sym = NULL;\n+\t  last_sym_idx = 0;\n+\t  dst_rela = hdr->contents;\n+\t  src_irel = (arelent *) esd->sec_info;\n+\t  BFD_ASSERT (src_irel != NULL);\n+\n+\t  for (idx = 0; idx < reloc_count; idx++, dst_rela += hdr->sh_entsize)\n+\t    {\n+\t      Elf_Internal_Rela src_rela;\n+\t      arelent *ptr;\n+\t      asymbol *sym;\n+\t      int n;\n+\n+\t      ptr = src_irel + idx;\n+\t      sym = *ptr->sym_ptr_ptr;\n+\n+\t      if (sym == last_sym)\n+\t\tn = last_sym_idx;\n+\t      else\n+\t\t{\n+\t\t  last_sym = sym;\n+\t\t  n = _bfd_elf_symbol_from_bfd_symbol (abfd, & sym);\n+\t\t  if (n < 0)\n+\t\t    {\n+#if DEBUG_SECONDARY_RELOCS\n+\t\t      fprintf (stderr, \"failed to find symbol %s whilst rewriting relocs\\n\",\n+\t\t\t       sym->name);\n+#endif\n+\t\t      /* FIXME: Signal failure somehow.  */\n+\t\t      n = 0;\n+\t\t    }\n+\t\t  last_sym_idx = n;\n+\t\t}\n+\n+\t      if ((*ptr->sym_ptr_ptr)->the_bfd != NULL\n+\t\t  && (*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec\n+\t\t  && ! _bfd_elf_validate_reloc (abfd, ptr))\n+\t\t{\n+#if DEBUG_SECONDARY_RELOCS\n+\t\t  fprintf (stderr, \"symbol %s is not in the output bfd\\n\",\n+\t\t\t   sym->name);\n+#endif\n+\t\t  /* FIXME: Signal failure somehow.  */\n+\t\t  n = 0;\n+\t\t}\n+\n+\t      if (ptr->howto == NULL)\n+\t\t{\n+#if DEBUG_SECONDARY_RELOCS\n+\t\t  fprintf (stderr, \"reloc for symbol %s does not have a howto associated with it\\n\",\n+\t\t\t   sym->name);\n+#endif\n+\t\t  /* FIXME: Signal failure somehow.  */\n+\t\t  n = 0;\n+\t\t}\n+\n+\t      src_rela.r_offset = ptr->address + addr_offset;\n+\t      src_rela.r_info = r_info (n, ptr->howto->type);\n+\t      src_rela.r_addend = ptr->addend;\n+\t      ebd->s->swap_reloca_out (abfd, &src_rela, dst_rela);\n+\t    }\n+\t}\n+    }\n+\n+  return TRUE;\n+}"
    },
    {
      "sha": "18a6dac64e04a83d62cbe7feec518be693f7ad13",
      "filename": "bfd/elfcode.h",
      "status": "modified",
      "additions": 17,
      "deletions": 1,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/elfcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/elfcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfcode.h?ref=a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
      "patch": "@@ -869,6 +869,7 @@ elf_object_p (bfd *abfd)\n void\n elf_write_relocs (bfd *abfd, asection *sec, void *data)\n {\n+  const struct elf_backend_data * const bed = get_elf_backend_data (abfd);\n   bfd_boolean *failedp = (bfd_boolean *) data;\n   Elf_Internal_Shdr *rela_hdr;\n   bfd_vma addr_offset;\n@@ -985,6 +986,13 @@ elf_write_relocs (bfd *abfd, asection *sec, void *data)\n       src_rela.r_addend = ptr->addend;\n       (*swap_out) (abfd, &src_rela, dst_rela);\n     }\n+\n+  if (bed->write_secondary_relocs != NULL)\n+    if (! bed->write_secondary_relocs (abfd, sec))\n+      {\n+\t*failedp = TRUE;\n+\treturn;\n+      }\n }\n \n /* Write out the program headers.  */\n@@ -1292,7 +1300,10 @@ elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)\n \t\t{\n \t\t  /* This symbol is in a section for which we did not\n \t\t     create a BFD section.  Just use bfd_abs_section,\n-\t\t     although it is wrong.  FIXME.  */\n+\t\t     although it is wrong.  FIXME.  Note - there is\n+\t\t     code in elf.c:swap_out_syms that calls\n+\t\t     symbol_section_index() in the elf backend for\n+\t\t     cases like this.  */\n \t\t  sym->symbol.section = bfd_abs_section_ptr;\n \t\t}\n \t    }\n@@ -1517,6 +1528,7 @@ elf_slurp_reloc_table (bfd *abfd,\n \t\t       asymbol **symbols,\n \t\t       bfd_boolean dynamic)\n {\n+  const struct elf_backend_data * const bed = get_elf_backend_data (abfd);\n   struct bfd_elf_section_data * const d = elf_section_data (asect);\n   Elf_Internal_Shdr *rel_hdr;\n   Elf_Internal_Shdr *rel_hdr2;\n@@ -1584,6 +1596,10 @@ elf_slurp_reloc_table (bfd *abfd,\n \t\t\t\t\t      symbols, dynamic))\n     return FALSE;\n \n+  if (bed->slurp_secondary_relocs != NULL\n+      && ! bed->slurp_secondary_relocs (abfd, asect, symbols))\n+    return FALSE;\n+\n   asect->relocation = relents;\n   return TRUE;\n }"
    },
    {
      "sha": "1ae17f45ee2ff3e2a27b800f64a874cc6ccd7565",
      "filename": "bfd/elfxx-target.h",
      "status": "modified",
      "additions": 17,
      "deletions": 2,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/elfxx-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4/bfd/elfxx-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-target.h?ref=a8e14f4cc2badfcf959f5e2cc57a941dc43f72d4",
      "patch": "@@ -758,15 +758,27 @@\n #endif\n \n #ifndef elf_backend_copy_special_section_fields\n-#define elf_backend_copy_special_section_fields NULL\n+#define elf_backend_copy_special_section_fields _bfd_elf_copy_special_section_fields\n #endif\n \n #ifndef elf_backend_compact_eh_encoding\n #define elf_backend_compact_eh_encoding NULL\n #endif\n \n #ifndef elf_backend_cant_unwind_opcode\n-#define elf_backend_cant_unwind_opcode 0\n+#define elf_backend_cant_unwind_opcode NULL\n+#endif\n+\n+#ifndef elf_backend_init_secondary_reloc_section\n+#define elf_backend_init_secondary_reloc_section _bfd_elf_init_secondary_reloc_section\n+#endif\n+\n+#ifndef elf_backend_slurp_secondary_reloc_section\n+#define elf_backend_slurp_secondary_reloc_section _bfd_elf_slurp_secondary_reloc_section\n+#endif\n+\n+#ifndef elf_backend_write_secondary_reloc_section\n+#define elf_backend_write_secondary_reloc_section _bfd_elf_write_secondary_reloc_section\n #endif\n \n #ifndef elf_backend_symbol_section_index\n@@ -900,6 +912,9 @@ static struct elf_backend_data elfNN_bed =\n   elf_backend_compact_eh_encoding,\n   elf_backend_cant_unwind_opcode,\n   elf_backend_symbol_section_index,\n+  elf_backend_init_secondary_reloc_section,\n+  elf_backend_slurp_secondary_reloc_section,\n+  elf_backend_write_secondary_reloc_section,\n   elf_backend_static_tls_alignment,\n   elf_backend_stack_align,\n   elf_backend_strtab_flags,"
    }
  ]
}