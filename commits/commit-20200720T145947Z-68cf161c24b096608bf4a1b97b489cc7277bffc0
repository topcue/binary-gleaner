{
  "sha": "68cf161c24b096608bf4a1b97b489cc7277bffc0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjhjZjE2MWMyNGIwOTY2MDhiZjRhMWI5N2I0ODljYzcyNzdiZmZjMA==",
  "commit": {
    "author": {
      "name": "Ludovic Court\u00e8s",
      "email": "ludo@gnu.org",
      "date": "2020-06-28T14:25:39Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-07-20T14:59:47Z"
    },
    "message": "guile: Add support for Guile 2.2.\n\nThis primarily updates code that uses the I/O port API of Guile.\n\ngdb/ChangeLog\n2020-06-28  Ludovic Court\u00c3\u00a8s  <ludo@gnu.org>\n            Doug Evans  <dje@google.com>\n\n\tPR gdb/21104\n\t* guile/scm-ports.c (USING_GUILE_BEFORE_2_2): New macro.\n\t(ioscm_memory_port)[read_buf_size, write_buf_size]: Wrap in #if\n\tUSING_GUILE_BEFORE_2_2.\n\t(stdio_port_desc, memory_port_desc) [!USING_GUILE_BEFORE_2_2]:\n\tChange type to 'scm_t_port_type *'.\n\t(natural_buffer_size) [!USING_GUILE_BEFORE_2_2]: New variable.\n\t(ioscm_open_port) [USING_GUILE_BEFORE_2_2]: Add 'stream'\n\tparameter and honor it.  Update callers.\n\t(ioscm_open_port) [!USING_GUILE_BEFORE_2_2]: New function.\n\t(ioscm_read_from_port, ioscm_write) [!USING_GUILE_BEFORE_2_2]: New\n\tfunctions.\n\t(ioscm_fill_input, ioscm_input_waiting, ioscm_flush): Wrap in #if\n\tUSING_GUILE_BEFORE_2_2.\n\t(ioscm_init_gdb_stdio_port) [!USING_GUILE_BEFORE_2_2]: Use\n\t'ioscm_read_from_port'.  Call 'scm_set_port_read_wait_fd'.\n\t(ioscm_init_stdio_buffers) [!USING_GUILE_BEFORE_2_2]: New function.\n\t(gdbscm_stdio_port_p) [!USING_GUILE_BEFORE_2_2]: Use 'SCM_PORTP'\n\tand 'SCM_PORT_TYPE'.\n\t(gdbscm_memory_port_end_input, gdbscm_memory_port_seek)\n\t(ioscm_reinit_memory_port): Wrap in #if USING_GUILE_BEFORE_2_2.\n\t(gdbscm_memory_port_read, gdbscm_memory_port_write)\n\t(gdbscm_memory_port_seek, gdbscm_memory_port_close)\n\t[!USING_GUILE_BEFORE_2_2]: New functions.\n\t(gdbscm_memory_port_print): Remove use of 'SCM_PTOB_NAME'.\n\t(ioscm_init_memory_port_type) [!USING_GUILE_BEFORE_2_2]: Use\n\t'gdbscm_memory_port_read'.\n\tWrap 'scm_set_port_end_input', 'scm_set_port_flush', and\n\t'scm_set_port_free' calls in #if USING_GUILE_BEFORE_2_2.\n\t(gdbscm_get_natural_buffer_sizes) [!USING_GUILE_BEFORE_2_2]: New\n\tfunction.\n\t(ioscm_init_memory_port): Remove.\n\t(ioscm_init_memory_port_stream): New function\n\t(ioscm_init_memory_port_buffers) [USING_GUILE_BEFORE_2_2]: New\n\tfunction.\n\t(gdbscm_memory_port_read_buffer_size) [!USING_GUILE_BEFORE_2_2]:\n\tReturn scm_from_uint (0).\n\t(gdbscm_set_memory_port_read_buffer_size_x)\n\t[!USING_GUILE_BEFORE_2_2]: Call 'scm_setvbuf'.\n\t(gdbscm_memory_port_write_buffer_size) [!USING_GUILE_BEFORE_2_2]:\n\tReturn scm_from_uint (0).\n\t(gdbscm_set_memory_port_write_buffer_size_x)\n\t[!USING_GUILE_BEFORE_2_2]: Call 'scm_setvbuf'.\n\t* configure.ac (try_guile_versions): Add \"guile-2.2\".\n\t* configure: Regenerate.\n\t* NEWS: Add entry.\n\ngdb/testsuite/ChangeLog\n2020-06-28  Ludovic Court\u00c3\u00a8s  <ludo@gnu.org>\n\n\t* gdb.guile/scm-error.exp (\"source $remote_guile_file_1\"): Relax\n\terror regexp to match on Guile 2.2.\n\ngdb/doc/ChangeLog\n2020-06-28  Ludovic Court\u00c3\u00a8s  <ludo@gnu.org>\n\n\t* guile.texi (Memory Ports in Guile): Mark\n\t'memory-port-read-buffer-size',\n\t'set-memory-port-read-buffer-size!',\n\t'memory-port-write-buffer-size',\n\t'set-memory-port-read-buffer-size!' as deprecated.\n\t* doc/guile.texi (Guile Introduction): Clarify which Guile\n\tversions are supported.\n\nChange-Id: Ib119b10a2787446e0ae482a5e1b36d809c44bb31",
    "tree": {
      "sha": "2770b8007e51d4c1eaa87b4ad0a09e1175b44ac6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2770b8007e51d4c1eaa87b4ad0a09e1175b44ac6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/68cf161c24b096608bf4a1b97b489cc7277bffc0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/68cf161c24b096608bf4a1b97b489cc7277bffc0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/68cf161c24b096608bf4a1b97b489cc7277bffc0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/68cf161c24b096608bf4a1b97b489cc7277bffc0/comments",
  "author": {
    "login": "civodul",
    "id": 1168435,
    "node_id": "MDQ6VXNlcjExNjg0MzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1168435?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/civodul",
    "html_url": "https://github.com/civodul",
    "followers_url": "https://api.github.com/users/civodul/followers",
    "following_url": "https://api.github.com/users/civodul/following{/other_user}",
    "gists_url": "https://api.github.com/users/civodul/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/civodul/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/civodul/subscriptions",
    "organizations_url": "https://api.github.com/users/civodul/orgs",
    "repos_url": "https://api.github.com/users/civodul/repos",
    "events_url": "https://api.github.com/users/civodul/events{/privacy}",
    "received_events_url": "https://api.github.com/users/civodul/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c14b49135568f7fa17a9df19e85a454581617468",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c14b49135568f7fa17a9df19e85a454581617468",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c14b49135568f7fa17a9df19e85a454581617468"
    }
  ],
  "stats": {
    "total": 717,
    "additions": 542,
    "deletions": 175
  },
  "files": [
    {
      "sha": "8305a274e257fa77146fca54426c8a79c2c36f84",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 50,
      "deletions": 0,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -1,3 +1,53 @@\n+2020-07-20  Ludovic Court\u00e8s  <ludo@gnu.org>\n+\t    Doug Evans  <dje@google.com>\n+\n+\tPR gdb/21104\n+\t* guile/scm-ports.c (USING_GUILE_BEFORE_2_2): New macro.\n+\t(ioscm_memory_port)[read_buf_size, write_buf_size]: Wrap in #if\n+\tUSING_GUILE_BEFORE_2_2.\n+\t(stdio_port_desc, memory_port_desc) [!USING_GUILE_BEFORE_2_2]:\n+\tChange type to 'scm_t_port_type *'.\n+\t(natural_buffer_size) [!USING_GUILE_BEFORE_2_2]: New variable.\n+\t(ioscm_open_port) [USING_GUILE_BEFORE_2_2]: Add 'stream'\n+\tparameter and honor it.  Update callers.\n+\t(ioscm_open_port) [!USING_GUILE_BEFORE_2_2]: New function.\n+\t(ioscm_read_from_port, ioscm_write) [!USING_GUILE_BEFORE_2_2]: New\n+\tfunctions.\n+\t(ioscm_fill_input, ioscm_input_waiting, ioscm_flush): Wrap in #if\n+\tUSING_GUILE_BEFORE_2_2.\n+\t(ioscm_init_gdb_stdio_port) [!USING_GUILE_BEFORE_2_2]: Use\n+\t'ioscm_read_from_port'.  Call 'scm_set_port_read_wait_fd'.\n+\t(ioscm_init_stdio_buffers) [!USING_GUILE_BEFORE_2_2]: New function.\n+\t(gdbscm_stdio_port_p) [!USING_GUILE_BEFORE_2_2]: Use 'SCM_PORTP'\n+\tand 'SCM_PORT_TYPE'.\n+\t(gdbscm_memory_port_end_input, gdbscm_memory_port_seek)\n+\t(ioscm_reinit_memory_port): Wrap in #if USING_GUILE_BEFORE_2_2.\n+\t(gdbscm_memory_port_read, gdbscm_memory_port_write)\n+\t(gdbscm_memory_port_seek, gdbscm_memory_port_close)\n+\t[!USING_GUILE_BEFORE_2_2]: New functions.\n+\t(gdbscm_memory_port_print): Remove use of 'SCM_PTOB_NAME'.\n+\t(ioscm_init_memory_port_type) [!USING_GUILE_BEFORE_2_2]: Use\n+\t'gdbscm_memory_port_read'.\n+\tWrap 'scm_set_port_end_input', 'scm_set_port_flush', and\n+\t'scm_set_port_free' calls in #if USING_GUILE_BEFORE_2_2.\n+\t(gdbscm_get_natural_buffer_sizes) [!USING_GUILE_BEFORE_2_2]: New\n+\tfunction.\n+\t(ioscm_init_memory_port): Remove.\n+\t(ioscm_init_memory_port_stream): New function\n+\t(ioscm_init_memory_port_buffers) [USING_GUILE_BEFORE_2_2]: New\n+\tfunction.\n+\t(gdbscm_memory_port_read_buffer_size) [!USING_GUILE_BEFORE_2_2]:\n+\tReturn scm_from_uint (0).\n+\t(gdbscm_set_memory_port_read_buffer_size_x)\n+\t[!USING_GUILE_BEFORE_2_2]: Call 'scm_setvbuf'.\n+\t(gdbscm_memory_port_write_buffer_size) [!USING_GUILE_BEFORE_2_2]:\n+\tReturn scm_from_uint (0).\n+\t(gdbscm_set_memory_port_write_buffer_size_x)\n+\t[!USING_GUILE_BEFORE_2_2]: Call 'scm_setvbuf'.\n+\t* configure.ac (try_guile_versions): Add \"guile-2.2\".\n+\t* configure: Regenerate.\n+\t* NEWS: Add entry.\n+\n 2020-07-18  Tom Tromey  <tom@tromey.com>\n \n \t* linux-nat.c (linux_multi_process): Remove."
    },
    {
      "sha": "b1912625e3670514f54927d6d7ccacac0cdc374e",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -130,6 +130,16 @@ GNU/Linux/RISC-V (gdbserver)\triscv*-*-linux*\n      gdb.RegisterGroup objects.  The new RegisterGroup is a way to\n      discover the available register groups.\n \n+* Guile API\n+\n+  ** GDB can now be built with GNU Guile 2.2 in addition to 2.0.\n+\n+  ** Procedures 'memory-port-read-buffer-size',\n+     'set-memory-port-read-buffer-size!', 'memory-port-write-buffer-size',\n+     and 'set-memory-port-write-buffer-size!' are deprecated.  When\n+     using Guile 2.2 and later, users who need to control the size of\n+     a memory port's internal buffer can use the 'setvbuf' procedure.\n+\n *** Changes in GDB 9\n \n * 'thread-exited' event is now available in the annotations interface."
    },
    {
      "sha": "3b71d03ebb5dc33ca24a82d20614ac0d41642bd1",
      "filename": "gdb/configure",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -10959,7 +10959,7 @@ fi\n \n \n \n-try_guile_versions=\"guile-2.0\"\n+try_guile_versions=\"guile-2.2 guile-2.0\"\n have_libguile=no\n case \"${with_guile}\" in\n no)"
    },
    {
      "sha": "0b40062e53643764c2df8f5f953a2176ed1675e3",
      "filename": "gdb/configure.ac",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.ac?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -1088,7 +1088,7 @@ AC_MSG_RESULT([$with_guile])\n dnl We check guile with pkg-config.\n AC_PATH_PROG(pkg_config_prog_path, pkg-config, missing)\n \n-try_guile_versions=\"guile-2.0\"\n+try_guile_versions=\"guile-2.2 guile-2.0\"\n have_libguile=no\n case \"${with_guile}\" in\n no)"
    },
    {
      "sha": "a573d205171fce05216b2a18dd1127b36043f778",
      "filename": "gdb/doc/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/doc/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/doc/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/ChangeLog?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -1,3 +1,13 @@\n+2020-07-20  Ludovic Court\u00e8s  <ludo@gnu.org>\n+\n+\t* guile.texi (Memory Ports in Guile): Mark\n+\t'memory-port-read-buffer-size',\n+\t'set-memory-port-read-buffer-size!',\n+\t'memory-port-write-buffer-size',\n+\t'set-memory-port-read-buffer-size!' as deprecated.\n+\t(Guile Introduction): Clarify which Guile\n+\tversions are supported.\n+\n 2020-07-13 Paul Carroll <pcarroll@codesourcery.com>\n \n \tPR gdb/25716"
    },
    {
      "sha": "52da7e7c17a2e1c79d1eb337c82587f34453966a",
      "filename": "gdb/doc/guile.texi",
      "status": "modified",
      "additions": 16,
      "deletions": 2,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/doc/guile.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/doc/guile.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/guile.texi?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -38,8 +38,7 @@ Guile support in @value{GDBN} follows the Python support in @value{GDBN}\n reasonably closely, so concepts there should carry over.\n However, some things are done differently where it makes sense.\n \n-@value{GDBN} requires Guile version 2.0 or greater.\n-Older versions are not supported.\n+@value{GDBN} requires Guile version 2.2 or 2.0.\n \n @cindex guile scripts directory\n Guile scripts used by @value{GDBN} should be installed in\n@@ -3559,21 +3558,36 @@ inclusive.\n @deffn {Scheme Procedure} memory-port-read-buffer-size memory-port\n Return the size of the read buffer of @code{<gdb:memory-port>}\n @var{memory-port}.\n+\n+This procedure is deprecated and will be removed in @value{GDBN} 11.\n+It returns 0 when using Guile 2.2 or later.\n @end deffn\n \n @deffn {Scheme Procedure} set-memory-port-read-buffer-size! memory-port size\n Set the size of the read buffer of @code{<gdb:memory-port>}\n @var{memory-port} to @var{size}.  The result is unspecified.\n+\n+This procedure is deprecated and will be removed in @value{GDBN} 11.\n+When @value{GDBN} is built with Guile 2.2 or later, you can call\n+@code{setvbuf} instead (@pxref{Buffering, @code{setvbuf},, guile, GNU\n+Guile Reference Manual}).\n @end deffn\n \n @deffn {Scheme Procedure} memory-port-write-buffer-size memory-port\n Return the size of the write buffer of @code{<gdb:memory-port>}\n @var{memory-port}.\n+\n+This procedure is deprecated and will be removed in @value{GDBN} 11.\n+It returns 0 when @value{GDBN} is built with Guile 2.2 or later.\n @end deffn\n \n @deffn {Scheme Procedure} set-memory-port-write-buffer-size! memory-port size\n Set the size of the write buffer of @code{<gdb:memory-port>}\n @var{memory-port} to @var{size}.  The result is unspecified.\n+\n+This procedure is deprecated and will be removed in @value{GDBN} 11.\n+When @value{GDBN} is built with Guile 2.2 or later, you can call\n+@code{setvbuf} instead.\n @end deffn\n \n A memory port is closed like any other port, with @code{close-port}."
    },
    {
      "sha": "17f8a30b11ed4699b28f6bdbbb8ffaef882e6a50",
      "filename": "gdb/guile/scm-ports.c",
      "status": "modified",
      "additions": 448,
      "deletions": 170,
      "changes": 618,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/guile/scm-ports.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/guile/scm-ports.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-ports.c?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -36,6 +36,12 @@\n #endif\n #endif\n \n+/* Whether we're using Guile < 2.2 and its clumsy port API.  */\n+\n+#define USING_GUILE_BEFORE_2_2\t\t\t\t\\\n+  (SCM_MAJOR_VERSION == 2 && SCM_MINOR_VERSION == 0)\n+\n+\n /* A ui-file for sending output to Guile.  */\n \n class ioscm_file_port : public ui_file\n@@ -66,12 +72,14 @@ typedef struct\n      This value is always in the range [0, size].  */\n   ULONGEST current;\n \n+#if USING_GUILE_BEFORE_2_2\n   /* The size of the internal r/w buffers.\n      Scheme ports aren't a straightforward mapping to memory r/w.\n      Generally the user specifies how much to r/w and all access is\n      unbuffered.  We don't try to provide equivalent access, but we allow\n      the user to specify these values to help get something similar.  */\n   unsigned read_buf_size, write_buf_size;\n+#endif\n } ioscm_memory_port;\n \n /* Copies of the original system input/output/error ports.\n@@ -81,7 +89,11 @@ static SCM orig_output_port_scm;\n static SCM orig_error_port_scm;\n \n /* This is the stdio port descriptor, scm_ptob_descriptor.  */\n+#if USING_GUILE_BEFORE_2_2\n static scm_t_bits stdio_port_desc;\n+#else\n+static scm_t_port_type *stdio_port_desc;\n+#endif\n \n /* Note: scm_make_port_type takes a char * instead of a const char *.  */\n static /*const*/ char stdio_port_desc_name[] = \"gdb:stdio-port\";\n@@ -102,11 +114,17 @@ static SCM error_port_scm;\n enum oport { GDB_STDOUT, GDB_STDERR };\n \n /* This is the memory port descriptor, scm_ptob_descriptor.  */\n+#if USING_GUILE_BEFORE_2_2\n static scm_t_bits memory_port_desc;\n+#else\n+static scm_t_port_type *memory_port_desc;\n+#endif\n \n /* Note: scm_make_port_type takes a char * instead of a const char *.  */\n static /*const*/ char memory_port_desc_name[] = \"gdb:memory-port\";\n \n+#if USING_GUILE_BEFORE_2_2\n+\n /* The default amount of memory to fetch for each read/write request.\n    Scheme ports don't provide a way to specify the size of a read,\n    which is important to us to minimize the number of inferior interactions,\n@@ -123,16 +141,24 @@ static const unsigned max_memory_port_buf_size = 4096;\n /* \"out of range\" error message for buf sizes.  */\n static char *out_of_range_buf_size;\n \n+#else\n+\n+/* The maximum values to use for get_natural_buffer_sizes.  */\n+static const unsigned natural_buf_size = 16;\n+\n+#endif\n+\n /* Keywords used by open-memory.  */\n static SCM mode_keyword;\n static SCM start_keyword;\n static SCM size_keyword;\n \f\n-/* Helper to do the low level work of opening a port.\n-   Newer versions of Guile (2.1.x) have scm_c_make_port.  */\n+/* Helper to do the low level work of opening a port.  */\n+\n+#if USING_GUILE_BEFORE_2_2\n \n static SCM\n-ioscm_open_port (scm_t_bits port_type, long mode_bits)\n+ioscm_open_port (scm_t_bits port_type, long mode_bits, scm_t_bits stream)\n {\n   SCM port;\n \n@@ -143,16 +169,47 @@ ioscm_open_port (scm_t_bits port_type, long mode_bits)\n   port = scm_new_port_table_entry (port_type);\n \n   SCM_SET_CELL_TYPE (port, port_type | mode_bits);\n+  SCM_SETSTREAM (port, stream);\n \n #if 0 /* TODO: Guile doesn't export this.  What to do?  */\n   scm_i_pthread_mutex_unlock (&scm_i_port_table_mutex);\n #endif\n \n   return port;\n }\n+\n+#else\n+\n+static SCM\n+ioscm_open_port (scm_t_port_type *port_type, long mode_bits, scm_t_bits stream)\n+{\n+  return scm_c_make_port (port_type, mode_bits, stream);\n+}\n+\n+#endif\n+\n \f\n /* Support for connecting Guile's stdio ports to GDB's stdio ports.  */\n \n+/* Like fputstrn_filtered, but don't escape characters, except nul.\n+   Also like fputs_filtered, but a length is specified.  */\n+\n+static void\n+fputsn_filtered (const char *s, size_t size, struct ui_file *stream)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < size; ++i)\n+    {\n+      if (s[i] == '\\0')\n+\tfputs_filtered (\"\\\\000\", stream);\n+      else\n+\tfputc_filtered (s[i], stream);\n+    }\n+}\n+\n+#if USING_GUILE_BEFORE_2_2\n+\n /* The scm_t_ptob_descriptor.input_waiting \"method\".\n    Return a lower bound on the number of bytes available for input.  */\n \n@@ -245,23 +302,6 @@ ioscm_fill_input (SCM port)\n   return *pt->read_buf;\n }\n \n-/* Like fputstrn_filtered, but don't escape characters, except nul.\n-   Also like fputs_filtered, but a length is specified.  */\n-\n-static void\n-fputsn_filtered (const char *s, size_t size, struct ui_file *stream)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < size; ++i)\n-    {\n-      if (s[i] == '\\0')\n-\tfputs_filtered (\"\\\\000\", stream);\n-      else\n-\tfputc_filtered (s[i], stream);\n-    }\n-}\n-\n /* Write to gdb's stdout or stderr.  */\n \n static void\n@@ -302,6 +342,62 @@ ioscm_flush (SCM port)\n     gdb_flush (gdb_stdout);\n }\n \n+#else /* !USING_GUILE_BEFORE_2_2 */\n+\n+/* Read up to COUNT bytes into bytevector DST at offset START.  Return the\n+   number of bytes read, zero for the end of file.  */\n+\n+static size_t\n+ioscm_read_from_port (SCM port, SCM dst, size_t start, size_t count)\n+{\n+  long read;\n+  char *read_buf;\n+\n+  /* If we're called on stdout,stderr, punt.  */\n+  if (! scm_is_eq (port, input_port_scm))\n+    return 0;\n+\n+  gdb_flush (gdb_stdout);\n+  gdb_flush (gdb_stderr);\n+\n+  read_buf = (char *) SCM_BYTEVECTOR_CONTENTS (dst) + start;\n+  read = gdb_stdin->read (read_buf, count);\n+  if (read == -1)\n+    scm_syserror (FUNC_NAME);\n+\n+  return (size_t) read;\n+}\n+\n+/* Write to gdb's stdout or stderr.  */\n+\n+static size_t\n+ioscm_write (SCM port, SCM src, size_t start, size_t count)\n+{\n+  const char *data = (char *) SCM_BYTEVECTOR_CONTENTS (src) + start;\n+\n+  /* If we're called on stdin, punt.  */\n+  if (scm_is_eq (port, input_port_scm))\n+    return 0;\n+\n+  gdbscm_gdb_exception exc {};\n+  try\n+    {\n+      if (scm_is_eq (port, error_port_scm))\n+\tfputsn_filtered ((const char *) data, count, gdb_stderr);\n+      else\n+\tfputsn_filtered ((const char *) data, count, gdb_stdout);\n+    }\n+  catch (const gdb_exception &except)\n+    {\n+      exc = unpack (except);\n+    }\n+  GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n+\n+  return count;\n+}\n+\n+#endif /* !USING_GUILE_BEFORE_2_2 */\n+\n /* Initialize the gdb stdio port type.\n \n    N.B. isatty? will fail on these ports, it is only supported for file\n@@ -311,12 +407,25 @@ static void\n ioscm_init_gdb_stdio_port (void)\n {\n   stdio_port_desc = scm_make_port_type (stdio_port_desc_name,\n-\t\t\t\t\tioscm_fill_input, ioscm_write);\n+#if USING_GUILE_BEFORE_2_2\n+\t\t\t\t\tioscm_fill_input,\n+#else\n+\t\t\t\t\tioscm_read_from_port,\n+#endif\n+\t\t\t\t\tioscm_write);\n \n+#if USING_GUILE_BEFORE_2_2\n   scm_set_port_input_waiting (stdio_port_desc, ioscm_input_waiting);\n   scm_set_port_flush (stdio_port_desc, ioscm_flush);\n+#else\n+  scm_set_port_read_wait_fd (stdio_port_desc, STDIN_FILENO);\n+#endif\n }\n \n+#define GDB_STDIO_BUFFER_DEFAULT_SIZE 1024\n+\n+#if USING_GUILE_BEFORE_2_2\n+\n /* Subroutine of ioscm_make_gdb_stdio_port to simplify it.\n    Set up the buffers of port PORT.\n    MODE_BITS are the mode bits of PORT.  */\n@@ -325,7 +434,6 @@ static void\n ioscm_init_stdio_buffers (SCM port, long mode_bits)\n {\n   scm_t_port *pt = SCM_PTAB_ENTRY (port);\n-#define GDB_STDIO_BUFFER_DEFAULT_SIZE 1024\n   int size = mode_bits & SCM_BUF0 ? 0 : GDB_STDIO_BUFFER_DEFAULT_SIZE;\n   int writing = (mode_bits & SCM_WRTNG) != 0;\n \n@@ -359,6 +467,20 @@ ioscm_init_stdio_buffers (SCM port, long mode_bits)\n   pt->write_end = pt->write_buf + pt->write_buf_size;\n }\n \n+#else\n+\n+static void\n+ioscm_init_stdio_buffers (SCM port, long mode_bits)\n+{\n+  if (mode_bits & SCM_BUF0)\n+    scm_setvbuf (port, scm_from_utf8_symbol (\"none\"), scm_from_size_t (0));\n+  else\n+    scm_setvbuf (port, scm_from_utf8_symbol (\"block\"),\n+\t\t scm_from_size_t (GDB_STDIO_BUFFER_DEFAULT_SIZE));\n+}\n+\n+#endif\n+\n /* Create a gdb stdio port.  */\n \n static SCM\n@@ -389,7 +511,7 @@ ioscm_make_gdb_stdio_port (int fd)\n     }\n \n   mode_bits = scm_mode_bits ((char *) mode_str);\n-  port = ioscm_open_port (stdio_port_desc, mode_bits);\n+  port = ioscm_open_port (stdio_port_desc, mode_bits, 0);\n \n   scm_set_port_filename_x (port, gdbscm_scm_from_c_string (name));\n \n@@ -403,9 +525,14 @@ ioscm_make_gdb_stdio_port (int fd)\n static SCM\n gdbscm_stdio_port_p (SCM scm)\n {\n+#if USING_GUILE_BEFORE_2_2\n   /* This is copied from SCM_FPORTP.  */\n   return scm_from_bool (!SCM_IMP (scm)\n \t\t\t&& (SCM_TYP16 (scm) == stdio_port_desc));\n+#else\n+  return scm_from_bool (SCM_PORTP (scm)\n+\t\t\t&& (SCM_PORT_TYPE (scm) == stdio_port_desc));\n+#endif\n }\n \f\n /* GDB's ports are accessed via functions to keep them read-only.  */\n@@ -568,6 +695,8 @@ ioscm_lseek_address (ioscm_memory_port *iomem, LONGEST offset, int whence)\n   return 1;\n }\n \n+#if USING_GUILE_BEFORE_2_2\n+\n /* \"fill_input\" method for memory ports.  */\n \n static int\n@@ -661,73 +790,6 @@ gdbscm_memory_port_flush (SCM port)\n   pt->rw_active = SCM_PORT_NEITHER;\n }\n \n-/* \"write\" method for memory ports.  */\n-\n-static void\n-gdbscm_memory_port_write (SCM port, const void *void_data, size_t size)\n-{\n-  scm_t_port *pt = SCM_PTAB_ENTRY (port);\n-  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n-  const gdb_byte *data = (const gdb_byte *) void_data;\n-\n-  /* There's no way to indicate a short write, so if the request goes past\n-     the end of the port's memory range, flag an error.  */\n-  if (size > iomem->size - iomem->current)\n-    {\n-      gdbscm_out_of_range_error (FUNC_NAME, 0, gdbscm_scm_from_ulongest (size),\n-\t\t\t\t _(\"writing beyond end of memory range\"));\n-    }\n-\n-  if (pt->write_buf == &pt->shortbuf)\n-    {\n-      /* Unbuffered port.  */\n-      if (target_write_memory (iomem->start + iomem->current, data, size) != 0)\n-\tgdbscm_memory_error (FUNC_NAME, _(\"error writing memory\"), SCM_EOL);\n-      iomem->current += size;\n-      return;\n-    }\n-\n-  /* Note: The edge case of what to do when the buffer exactly fills is\n-     debatable.  Guile flushes when the buffer exactly fills up, so we\n-     do too.  It's counter-intuitive to my mind, but in case there's a\n-     subtlety somewhere that depends on this, we do the same.  */\n-\n-  {\n-    size_t space = pt->write_end - pt->write_pos;\n-\n-    if (size < space)\n-      {\n-\t/* Data fits in buffer, and does not fill it.  */\n-\tmemcpy (pt->write_pos, data, size);\n-\tpt->write_pos += size;\n-      }\n-    else\n-      {\n-\tmemcpy (pt->write_pos, data, space);\n-\tpt->write_pos = pt->write_end;\n-\tgdbscm_memory_port_flush (port);\n-\t{\n-\t  const gdb_byte *ptr = data + space;\n-\t  size_t remaining = size - space;\n-\n-\t  if (remaining >= pt->write_buf_size)\n-\t    {\n-\t      if (target_write_memory (iomem->start + iomem->current, ptr,\n-\t\t\t\t       remaining) != 0)\n-\t\tgdbscm_memory_error (FUNC_NAME, _(\"error writing memory\"),\n-\t\t\t\t     SCM_EOL);\n-\t      iomem->current += remaining;\n-\t    }\n-\t  else\n-\t    {\n-\t      memcpy (pt->write_pos, ptr, remaining);\n-\t      pt->write_pos += remaining;\n-\t    }\n-\t}\n-      }\n-  }\n-}\n-\n /* \"seek\" method for memory ports.  */\n \n static scm_t_off\n@@ -820,6 +882,73 @@ gdbscm_memory_port_seek (SCM port, scm_t_off offset, int whence)\n   return result;\n }\n \n+/* \"write\" method for memory ports.  */\n+\n+static void\n+gdbscm_memory_port_write (SCM port, const void *void_data, size_t size)\n+{\n+  scm_t_port *pt = SCM_PTAB_ENTRY (port);\n+  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n+  const gdb_byte *data = (const gdb_byte *) void_data;\n+\n+  /* There's no way to indicate a short write, so if the request goes past\n+     the end of the port's memory range, flag an error.  */\n+  if (size > iomem->size - iomem->current)\n+    {\n+      gdbscm_out_of_range_error (FUNC_NAME, 0, gdbscm_scm_from_ulongest (size),\n+\t\t\t\t _(\"writing beyond end of memory range\"));\n+    }\n+\n+  if (pt->write_buf == &pt->shortbuf)\n+    {\n+      /* Unbuffered port.  */\n+      if (target_write_memory (iomem->start + iomem->current, data, size) != 0)\n+\tgdbscm_memory_error (FUNC_NAME, _(\"error writing memory\"), SCM_EOL);\n+      iomem->current += size;\n+      return;\n+    }\n+\n+  /* Note: The edge case of what to do when the buffer exactly fills is\n+     debatable.  Guile flushes when the buffer exactly fills up, so we\n+     do too.  It's counter-intuitive to my mind, but in case there's a\n+     subtlety somewhere that depends on this, we do the same.  */\n+\n+  {\n+    size_t space = pt->write_end - pt->write_pos;\n+\n+    if (size < space)\n+      {\n+\t/* Data fits in buffer, and does not fill it.  */\n+\tmemcpy (pt->write_pos, data, size);\n+\tpt->write_pos += size;\n+      }\n+    else\n+      {\n+\tmemcpy (pt->write_pos, data, space);\n+\tpt->write_pos = pt->write_end;\n+\tgdbscm_memory_port_flush (port);\n+\t{\n+\t  const gdb_byte *ptr = data + space;\n+\t  size_t remaining = size - space;\n+\n+\t  if (remaining >= pt->write_buf_size)\n+\t    {\n+\t      if (target_write_memory (iomem->start + iomem->current, ptr,\n+\t\t\t\t       remaining) != 0)\n+\t\tgdbscm_memory_error (FUNC_NAME, _(\"error writing memory\"),\n+\t\t\t\t     SCM_EOL);\n+\t      iomem->current += remaining;\n+\t    }\n+\t  else\n+\t    {\n+\t      memcpy (pt->write_pos, ptr, remaining);\n+\t      pt->write_pos += remaining;\n+\t    }\n+\t}\n+      }\n+  }\n+}\n+\n /* \"close\" method for memory ports.  */\n \n static int\n@@ -851,18 +980,178 @@ gdbscm_memory_port_free (SCM port)\n   return 0;\n }\n \n+/* Re-initialize a memory port, updating its read/write buffer sizes.\n+   An exception is thrown if the port is unbuffered.\n+   TODO: Allow switching buffered/unbuffered.\n+   An exception is also thrown if data is still buffered, except in the case\n+   where the buffer size isn't changing (since that's just a nop).  */\n+\n+static void\n+ioscm_reinit_memory_port (SCM port, size_t read_buf_size,\n+\t\t\t  size_t write_buf_size, const char *func_name)\n+{\n+  scm_t_port *pt = SCM_PTAB_ENTRY (port);\n+  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n+\n+  gdb_assert (read_buf_size >= min_memory_port_buf_size\n+\t      && read_buf_size <= max_memory_port_buf_size);\n+  gdb_assert (write_buf_size >= min_memory_port_buf_size\n+\t      && write_buf_size <= max_memory_port_buf_size);\n+\n+  /* First check if the port is unbuffered.  */\n+\n+  if (pt->read_buf == &pt->shortbuf)\n+    {\n+      gdb_assert (pt->write_buf == &pt->shortbuf);\n+      scm_misc_error (func_name, _(\"port is unbuffered: ~a\"),\n+\t\t      scm_list_1 (port));\n+    }\n+\n+  /* Next check if anything is buffered.  */\n+\n+  if (read_buf_size != pt->read_buf_size\n+      && pt->read_end != pt->read_buf)\n+    {\n+      scm_misc_error (func_name, _(\"read buffer not empty: ~a\"),\n+\t\t      scm_list_1 (port));\n+    }\n+\n+  if (write_buf_size != pt->write_buf_size\n+      && pt->write_pos != pt->write_buf)\n+    {\n+      scm_misc_error (func_name, _(\"write buffer not empty: ~a\"),\n+\t\t      scm_list_1 (port));\n+    }\n+\n+  /* Now we can update the buffer sizes, but only if the size has changed.  */\n+\n+  if (read_buf_size != pt->read_buf_size)\n+    {\n+      iomem->read_buf_size = read_buf_size;\n+      pt->read_buf_size = read_buf_size;\n+      xfree (pt->read_buf);\n+      pt->read_buf = (unsigned char *) xmalloc (pt->read_buf_size);\n+      pt->read_pos = pt->read_end = pt->read_buf;\n+    }\n+\n+  if (write_buf_size != pt->write_buf_size)\n+    {\n+      iomem->write_buf_size = write_buf_size;\n+      pt->write_buf_size = write_buf_size;\n+      xfree (pt->write_buf);\n+      pt->write_buf = (unsigned char *) xmalloc (pt->write_buf_size);\n+      pt->write_pos = pt->write_buf;\n+      pt->write_end = pt->write_buf + pt->write_buf_size;\n+    }\n+}\n+\n+#else /* !USING_GUILE_BEFORE_2_2 */\n+\n+/* The semantics get weird if the buffer size is larger than the port range,\n+   so provide a better default buffer size.  */\n+\n+static void\n+gdbscm_get_natural_buffer_sizes (SCM port, size_t *read_size,\n+\t\t\t\t size_t *write_size)\n+{\n+  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n+\n+  size_t size = natural_buf_size;\n+  if (iomem != NULL && iomem->size < size)\n+    size = iomem->size;\n+  *read_size = *write_size = size;\n+}\n+\n+/* Read up to COUNT bytes into bytevector DST at offset START.  Return the\n+   number of bytes read, zero for the end of file.  */\n+\n+static size_t\n+gdbscm_memory_port_read (SCM port, SCM dst, size_t start, size_t count)\n+{\n+  gdb_byte *read_buf;\n+  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n+\n+  /* \"current\" is the offset of the first byte we want to read.  */\n+  gdb_assert (iomem->current <= iomem->size);\n+  if (iomem->current == iomem->size)\n+    return 0;\n+\n+  /* Don't read outside the allowed memory range.  */\n+  if (count > iomem->size - iomem->current)\n+    count = iomem->size - iomem->current;\n+\n+  read_buf = (gdb_byte *) SCM_BYTEVECTOR_CONTENTS (dst) + start;\n+  if (target_read_memory (iomem->start + iomem->current, read_buf,\n+\t\t\t  count) != 0)\n+    gdbscm_memory_error (FUNC_NAME, _(\"error reading memory\"), SCM_EOL);\n+\n+  iomem->current += count;\n+  return count;\n+}\n+\n+static size_t\n+gdbscm_memory_port_write (SCM port, SCM src, size_t start, size_t count)\n+{\n+  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n+  const gdb_byte *data =\n+    (const gdb_byte *) SCM_BYTEVECTOR_CONTENTS (src) + start;\n+\n+  /* If the request goes past the end of the port's memory range, flag an\n+     error.  */\n+  if (count > iomem->size - iomem->current)\n+    gdbscm_out_of_range_error (FUNC_NAME, 0, scm_from_size_t (count),\n+\t\t\t       _(\"writing beyond end of memory range\"));\n+\n+  if (target_write_memory (iomem->start + iomem->current, data,\n+\t\t\t   count) != 0)\n+    gdbscm_memory_error (FUNC_NAME, _(\"error writing memory\"),\n+\t\t\t SCM_EOL);\n+\n+  iomem->current += count;\n+\n+  return count;\n+}\n+\n+static scm_t_off\n+gdbscm_memory_port_seek (SCM port, scm_t_off offset, int whence)\n+{\n+  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n+  int rc;\n+\n+  rc = ioscm_lseek_address (iomem, offset, whence);\n+  if (rc == 0)\n+    gdbscm_out_of_range_error (FUNC_NAME, 0,\n+\t\t\t       gdbscm_scm_from_longest (offset),\n+\t\t\t       _(\"bad seek\"));\n+\n+  /* TODO: The Guile API doesn't support 32x64.  We can't fix that here,\n+     and there's no need to throw an error if the new address can't be\n+     represented in a scm_t_off.  But we could return something less\n+     clumsy.  */\n+  return iomem->current;\n+}\n+\n+static void\n+gdbscm_memory_port_close (SCM port)\n+{\n+  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n+  scm_gc_free (iomem, sizeof (*iomem), \"memory port\");\n+  SCM_SETSTREAM (port, NULL);\n+}\n+\n+#endif /* !USING_GUILE_BEFORE_2_2 */\n+\n /* \"print\" method for memory ports.  */\n \n static int\n gdbscm_memory_port_print (SCM exp, SCM port, scm_print_state *pstate)\n {\n   ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (exp);\n-  char *type = SCM_PTOBNAME (SCM_PTOBNUM (exp));\n \n   scm_puts (\"#<\", port);\n   scm_print_port_mode (exp, port);\n   /* scm_print_port_mode includes a trailing space.  */\n-  gdbscm_printf (port, \"%s %s-%s\", type,\n+  gdbscm_printf (port, \"%s %s-%s\", memory_port_desc_name,\n \t\t hex_string (iomem->start), hex_string (iomem->end));\n   scm_putc ('>', port);\n   return 1;\n@@ -874,14 +1163,23 @@ static void\n ioscm_init_memory_port_type (void)\n {\n   memory_port_desc = scm_make_port_type (memory_port_desc_name,\n+#if USING_GUILE_BEFORE_2_2\n \t\t\t\t\t gdbscm_memory_port_fill_input,\n+#else\n+\t\t\t\t\t gdbscm_memory_port_read,\n+#endif\n \t\t\t\t\t gdbscm_memory_port_write);\n \n+#if USING_GUILE_BEFORE_2_2\n   scm_set_port_end_input (memory_port_desc, gdbscm_memory_port_end_input);\n   scm_set_port_flush (memory_port_desc, gdbscm_memory_port_flush);\n+  scm_set_port_free (memory_port_desc, gdbscm_memory_port_free);\n+#else\n+  scm_set_port_get_natural_buffer_sizes (memory_port_desc,\n+\t\t\t\t\t gdbscm_get_natural_buffer_sizes);\n+#endif\n   scm_set_port_seek (memory_port_desc, gdbscm_memory_port_seek);\n   scm_set_port_close (memory_port_desc, gdbscm_memory_port_close);\n-  scm_set_port_free (memory_port_desc, gdbscm_memory_port_free);\n   scm_set_port_print (memory_port_desc, gdbscm_memory_port_print);\n }\n \n@@ -922,17 +1220,13 @@ ioscm_parse_mode_bits (const char *func_name, const char *mode)\n   return mode_bits;\n }\n \n-/* Helper for gdbscm_open_memory to finish initializing the port.\n-   The port has address range [start,end).\n-   This means that address of 0xff..ff is not accessible.\n-   I can live with that.  */\n+/* Return the memory object to be used as a \"stream\" associated with a memory\n+   port for the START--END range.  */\n \n-static void\n-ioscm_init_memory_port (SCM port, CORE_ADDR start, CORE_ADDR end)\n+static ioscm_memory_port *\n+ioscm_init_memory_port_stream (CORE_ADDR start, CORE_ADDR end)\n {\n-  scm_t_port *pt;\n   ioscm_memory_port *iomem;\n-  int buffered = (SCM_CELL_WORD_0 (port) & SCM_BUF0) == 0;\n \n   gdb_assert (start <= end);\n \n@@ -943,6 +1237,23 @@ ioscm_init_memory_port (SCM port, CORE_ADDR start, CORE_ADDR end)\n   iomem->end = end;\n   iomem->size = end - start;\n   iomem->current = 0;\n+\n+  return iomem;\n+}\n+\n+#if USING_GUILE_BEFORE_2_2\n+\n+/* Helper for gdbscm_open_memory to finish initializing the port.\n+   The port has address range [start,end).\n+   This means that address of 0xff..ff is not accessible.\n+   I can live with that.  */\n+\n+static void\n+ioscm_init_memory_port_buffers (SCM port)\n+{\n+  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n+\n+  int buffered = (SCM_CELL_WORD_0 (port) & SCM_BUF0) == 0;\n   if (buffered)\n     {\n       iomem->read_buf_size = default_read_buf_size;\n@@ -954,7 +1265,7 @@ ioscm_init_memory_port (SCM port, CORE_ADDR start, CORE_ADDR end)\n       iomem->write_buf_size = 1;\n     }\n \n-  pt = SCM_PTAB_ENTRY (port);\n+  scm_t_port *pt = SCM_PTAB_ENTRY (port);\n   /* Match the expectation of `binary-port?'.  */\n   pt->encoding = NULL;\n   pt->rw_random = 1;\n@@ -973,74 +1284,9 @@ ioscm_init_memory_port (SCM port, CORE_ADDR start, CORE_ADDR end)\n   pt->read_pos = pt->read_end = pt->read_buf;\n   pt->write_pos = pt->write_buf;\n   pt->write_end = pt->write_buf + pt->write_buf_size;\n-\n-  SCM_SETSTREAM (port, iomem);\n }\n \n-/* Re-initialize a memory port, updating its read/write buffer sizes.\n-   An exception is thrown if the port is unbuffered.\n-   TODO: Allow switching buffered/unbuffered.\n-   An exception is also thrown if data is still buffered, except in the case\n-   where the buffer size isn't changing (since that's just a nop).  */\n-\n-static void\n-ioscm_reinit_memory_port (SCM port, size_t read_buf_size,\n-\t\t\t  size_t write_buf_size, const char *func_name)\n-{\n-  scm_t_port *pt = SCM_PTAB_ENTRY (port);\n-  ioscm_memory_port *iomem = (ioscm_memory_port *) SCM_STREAM (port);\n-\n-  gdb_assert (read_buf_size >= min_memory_port_buf_size\n-\t      && read_buf_size <= max_memory_port_buf_size);\n-  gdb_assert (write_buf_size >= min_memory_port_buf_size\n-\t      && write_buf_size <= max_memory_port_buf_size);\n-\n-  /* First check if the port is unbuffered.  */\n-\n-  if (pt->read_buf == &pt->shortbuf)\n-    {\n-      gdb_assert (pt->write_buf == &pt->shortbuf);\n-      scm_misc_error (func_name, _(\"port is unbuffered: ~a\"),\n-\t\t      scm_list_1 (port));\n-    }\n-\n-  /* Next check if anything is buffered.  */\n-\n-  if (read_buf_size != pt->read_buf_size\n-      && pt->read_end != pt->read_buf)\n-    {\n-      scm_misc_error (func_name, _(\"read buffer not empty: ~a\"),\n-\t\t      scm_list_1 (port));\n-    }\n-\n-  if (write_buf_size != pt->write_buf_size\n-      && pt->write_pos != pt->write_buf)\n-    {\n-      scm_misc_error (func_name, _(\"write buffer not empty: ~a\"),\n-\t\t      scm_list_1 (port));\n-    }\n-\n-  /* Now we can update the buffer sizes, but only if the size has changed.  */\n-\n-  if (read_buf_size != pt->read_buf_size)\n-    {\n-      iomem->read_buf_size = read_buf_size;\n-      pt->read_buf_size = read_buf_size;\n-      xfree (pt->read_buf);\n-      pt->read_buf = (unsigned char *) xmalloc (pt->read_buf_size);\n-      pt->read_pos = pt->read_end = pt->read_buf;\n-    }\n-\n-  if (write_buf_size != pt->write_buf_size)\n-    {\n-      iomem->write_buf_size = write_buf_size;\n-      pt->write_buf_size = write_buf_size;\n-      xfree (pt->write_buf);\n-      pt->write_buf = (unsigned char *) xmalloc (pt->write_buf_size);\n-      pt->write_pos = pt->write_buf;\n-      pt->write_end = pt->write_buf + pt->write_buf_size;\n-    }\n-}\n+#endif\n \n /* (open-memory [#:mode string] [#:start address] [#:size integer]) -> port\n    Return a port that can be used for reading and writing memory.\n@@ -1109,9 +1355,19 @@ gdbscm_open_memory (SCM rest)\n \n   mode_bits = ioscm_parse_mode_bits (FUNC_NAME, mode);\n \n-  port = ioscm_open_port (memory_port_desc, mode_bits);\n+  /* Edge case: empty range -> unbuffered.\n+     There's no need to disallow empty ranges, but we need an unbuffered port\n+     to get the semantics right.  */\n+  if (size == 0)\n+    mode_bits |= SCM_BUF0;\n+\n+  auto stream = ioscm_init_memory_port_stream (start, end);\n+  port = ioscm_open_port (memory_port_desc, mode_bits,\n+\t\t\t  (scm_t_bits) stream);\n \n-  ioscm_init_memory_port (port, start, end);\n+#if USING_GUILE_BEFORE_2_2\n+  ioscm_init_memory_port_buffers (port);\n+#endif\n \n   scm_dynwind_end ();\n \n@@ -1124,7 +1380,11 @@ gdbscm_open_memory (SCM rest)\n static int\n gdbscm_is_memory_port (SCM obj)\n {\n+#if USING_GUILE_BEFORE_2_2\n   return !SCM_IMP (obj) && (SCM_TYP16 (obj) == memory_port_desc);\n+#else\n+  return SCM_PORTP (obj) && (SCM_PORT_TYPE (obj) == memory_port_desc);\n+#endif\n }\n \n /* (memory-port? obj) -> boolean */\n@@ -1155,13 +1415,17 @@ gdbscm_memory_port_range (SCM port)\n static SCM\n gdbscm_memory_port_read_buffer_size (SCM port)\n {\n+#if USING_GUILE_BEFORE_2_2\n   ioscm_memory_port *iomem;\n \n   SCM_ASSERT_TYPE (gdbscm_is_memory_port (port), port, SCM_ARG1, FUNC_NAME,\n \t\t   memory_port_desc_name);\n \n   iomem = (ioscm_memory_port *) SCM_STREAM (port);\n   return scm_from_uint (iomem->read_buf_size);\n+#else\n+  return scm_from_uint (0);\n+#endif\n }\n \n /* (set-memory-port-read-buffer-size! port size) -> unspecified\n@@ -1171,6 +1435,7 @@ gdbscm_memory_port_read_buffer_size (SCM port)\n static SCM\n gdbscm_set_memory_port_read_buffer_size_x (SCM port, SCM size)\n {\n+#if USING_GUILE_BEFORE_2_2\n   ioscm_memory_port *iomem;\n \n   SCM_ASSERT_TYPE (gdbscm_is_memory_port (port), port, SCM_ARG1, FUNC_NAME,\n@@ -1190,20 +1455,27 @@ gdbscm_set_memory_port_read_buffer_size_x (SCM port, SCM size)\n \t\t\t    FUNC_NAME);\n \n   return SCM_UNSPECIFIED;\n+#else\n+  return scm_setvbuf (port, scm_from_utf8_symbol (\"block\"), size);\n+#endif\n }\n \n /* (memory-port-write-buffer-size port) -> integer */\n \n static SCM\n gdbscm_memory_port_write_buffer_size (SCM port)\n {\n+#if USING_GUILE_BEFORE_2_2\n   ioscm_memory_port *iomem;\n \n   SCM_ASSERT_TYPE (gdbscm_is_memory_port (port), port, SCM_ARG1, FUNC_NAME,\n \t\t   memory_port_desc_name);\n \n   iomem = (ioscm_memory_port *) SCM_STREAM (port);\n   return scm_from_uint (iomem->write_buf_size);\n+#else\n+  return scm_from_uint (0);\n+#endif\n }\n \n /* (set-memory-port-write-buffer-size! port size) -> unspecified\n@@ -1213,6 +1485,7 @@ gdbscm_memory_port_write_buffer_size (SCM port)\n static SCM\n gdbscm_set_memory_port_write_buffer_size_x (SCM port, SCM size)\n {\n+#if USING_GUILE_BEFORE_2_2\n   ioscm_memory_port *iomem;\n \n   SCM_ASSERT_TYPE (gdbscm_is_memory_port (port), port, SCM_ARG1, FUNC_NAME,\n@@ -1232,6 +1505,9 @@ gdbscm_set_memory_port_write_buffer_size_x (SCM port, SCM size)\n \t\t\t    FUNC_NAME);\n \n   return SCM_UNSPECIFIED;\n+#else\n+  return scm_setvbuf (port, scm_from_utf8_symbol (\"block\"), size);\n+#endif\n }\n \f\n /* Initialize gdb ports.  */\n@@ -1366,9 +1642,11 @@ gdbscm_initialize_ports (void)\n   start_keyword = scm_from_latin1_keyword (\"start\");\n   size_keyword = scm_from_latin1_keyword (\"size\");\n \n+#if USING_GUILE_BEFORE_2_2\n   /* Error message text for \"out of range\" memory port buffer sizes.  */\n \n   out_of_range_buf_size = xstrprintf (\"size not between %u - %u\",\n \t\t\t\t      min_memory_port_buf_size,\n \t\t\t\t      max_memory_port_buf_size);\n+#endif\n }"
    },
    {
      "sha": "885d317cb08aba980fa864cad90088ef477fae0f",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -1,3 +1,8 @@\n+2020-07-20  Ludovic Court\u00e8s  <ludo@gnu.org>\n+\n+\t* gdb.guile/scm-error.exp (\"source $remote_guile_file_1\"): Relax\n+\terror regexp to match on Guile 2.2.\n+\n 2020-07-20  Gary Benson <gbenson@redhat.com>\n \n \t* gdb.cp/align.exp: Fix \"alignof (void)\" tests when compiling"
    },
    {
      "sha": "f073200b6ee757f521f573fa676cfd041cc711cc",
      "filename": "gdb/testsuite/gdb.guile/scm-error.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/testsuite/gdb.guile/scm-error.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68cf161c24b096608bf4a1b97b489cc7277bffc0/gdb/testsuite/gdb.guile/scm-error.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.guile/scm-error.exp?ref=68cf161c24b096608bf4a1b97b489cc7277bffc0",
      "patch": "@@ -34,7 +34,7 @@ set remote_guile_file_2 [gdb_remote_download host \\\n \t\t\t     ${srcdir}/${subdir}/${testfile}-2.scm]\n \n gdb_test \"source $remote_guile_file_1\" \\\n-    \"(ERROR: )?In procedure \\[+\\]: Wrong type: #f.*\" \\\n+    \"(ERROR: )?In procedure \\[+\\]: Wrong type.*: #f.*\" \\\n     \"error loading scm file caught\"\n \n gdb_test \"p 1\" \" = 1\" \"no delayed error\""
    }
  ]
}