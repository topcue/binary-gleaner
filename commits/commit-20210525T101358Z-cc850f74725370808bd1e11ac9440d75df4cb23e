{
  "sha": "cc850f74725370808bd1e11ac9440d75df4cb23e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2M4NTBmNzQ3MjUzNzA4MDhiZDFlMTFhYzk0NDBkNzVkZjRjYjIzZQ==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-05-25T10:13:35Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-05-25T10:13:58Z"
    },
    "message": "Fix formatting in elf32-arm.c",
    "tree": {
      "sha": "de8558d486169692c68b2b18ee42079749a940f7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/de8558d486169692c68b2b18ee42079749a940f7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cc850f74725370808bd1e11ac9440d75df4cb23e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cc850f74725370808bd1e11ac9440d75df4cb23e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cc850f74725370808bd1e11ac9440d75df4cb23e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cc850f74725370808bd1e11ac9440d75df4cb23e/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bc30a119f3e32321a3116ab4b0d415a3c332e9a3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bc30a119f3e32321a3116ab4b0d415a3c332e9a3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bc30a119f3e32321a3116ab4b0d415a3c332e9a3"
    }
  ],
  "stats": {
    "total": 386,
    "additions": 203,
    "deletions": 183
  },
  "files": [
    {
      "sha": "248044fe94d13d60a3b35e5a4ca52802edd20a12",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cc850f74725370808bd1e11ac9440d75df4cb23e/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cc850f74725370808bd1e11ac9440d75df4cb23e/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=cc850f74725370808bd1e11ac9440d75df4cb23e",
      "patch": "@@ -1,3 +1,7 @@\n+2021-05-25  Nick Clifton  <nickc@redhat.com>\n+\n+\t* elf32-arm.c: Fix formatting.\n+\n 2021-05-25  Alan Modra  <amodra@gmail.com>\n \n \t* elf-attrs.c (elf_attr_strdup): New function."
    },
    {
      "sha": "cab9264b7fa1e4d520cd539ad522aa2c59d7b4f3",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 199,
      "deletions": 183,
      "changes": 382,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cc850f74725370808bd1e11ac9440d75df4cb23e/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cc850f74725370808bd1e11ac9440d75df4cb23e/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=cc850f74725370808bd1e11ac9440d75df4cb23e",
      "patch": "@@ -2831,29 +2831,29 @@ static const insn_sequence elf32_arm_stub_a8_veneer_blx[] =\n \n /* One entry per long/short branch stub defined above.  */\n #define DEF_STUBS \\\n-  DEF_STUB(long_branch_any_any)\t\\\n-  DEF_STUB(long_branch_v4t_arm_thumb) \\\n-  DEF_STUB(long_branch_thumb_only) \\\n-  DEF_STUB(long_branch_v4t_thumb_thumb)\t\\\n-  DEF_STUB(long_branch_v4t_thumb_arm) \\\n-  DEF_STUB(short_branch_v4t_thumb_arm) \\\n-  DEF_STUB(long_branch_any_arm_pic) \\\n-  DEF_STUB(long_branch_any_thumb_pic) \\\n-  DEF_STUB(long_branch_v4t_thumb_thumb_pic) \\\n-  DEF_STUB(long_branch_v4t_arm_thumb_pic) \\\n-  DEF_STUB(long_branch_v4t_thumb_arm_pic) \\\n-  DEF_STUB(long_branch_thumb_only_pic) \\\n-  DEF_STUB(long_branch_any_tls_pic) \\\n-  DEF_STUB(long_branch_v4t_thumb_tls_pic) \\\n-  DEF_STUB(long_branch_arm_nacl) \\\n-  DEF_STUB(long_branch_arm_nacl_pic) \\\n-  DEF_STUB(cmse_branch_thumb_only) \\\n-  DEF_STUB(a8_veneer_b_cond) \\\n-  DEF_STUB(a8_veneer_b) \\\n-  DEF_STUB(a8_veneer_bl) \\\n-  DEF_STUB(a8_veneer_blx) \\\n-  DEF_STUB(long_branch_thumb2_only) \\\n-  DEF_STUB(long_branch_thumb2_only_pure)\n+  DEF_STUB (long_branch_any_any)\t\\\n+  DEF_STUB (long_branch_v4t_arm_thumb) \\\n+  DEF_STUB (long_branch_thumb_only) \\\n+  DEF_STUB (long_branch_v4t_thumb_thumb)\t\\\n+  DEF_STUB (long_branch_v4t_thumb_arm) \\\n+  DEF_STUB (short_branch_v4t_thumb_arm) \\\n+  DEF_STUB (long_branch_any_arm_pic) \\\n+  DEF_STUB (long_branch_any_thumb_pic) \\\n+  DEF_STUB (long_branch_v4t_thumb_thumb_pic) \\\n+  DEF_STUB (long_branch_v4t_arm_thumb_pic) \\\n+  DEF_STUB (long_branch_v4t_thumb_arm_pic) \\\n+  DEF_STUB (long_branch_thumb_only_pic) \\\n+  DEF_STUB (long_branch_any_tls_pic) \\\n+  DEF_STUB (long_branch_v4t_thumb_tls_pic) \\\n+  DEF_STUB (long_branch_arm_nacl) \\\n+  DEF_STUB (long_branch_arm_nacl_pic) \\\n+  DEF_STUB (cmse_branch_thumb_only) \\\n+  DEF_STUB (a8_veneer_b_cond) \\\n+  DEF_STUB (a8_veneer_b) \\\n+  DEF_STUB (a8_veneer_bl) \\\n+  DEF_STUB (a8_veneer_blx) \\\n+  DEF_STUB (long_branch_thumb2_only) \\\n+  DEF_STUB (long_branch_thumb2_only_pure)\n \n #define DEF_STUB(x) arm_stub_##x,\n enum elf32_arm_stub_type\n@@ -3135,7 +3135,8 @@ struct arm_local_iplt_info\n };\n \n /* Structure to handle FDPIC support for local functions.  */\n-struct fdpic_local {\n+struct fdpic_local\n+{\n   unsigned int funcdesc_cnt;\n   unsigned int gotofffuncdesc_cnt;\n   int funcdesc_offset;\n@@ -3145,6 +3146,12 @@ struct elf_arm_obj_tdata\n {\n   struct elf_obj_tdata root;\n \n+  /* Zero to warn when linking objects with incompatible enum sizes.  */\n+  int no_enum_size_warning;\n+\n+  /* Zero to warn when linking objects with incompatible wchar_t sizes.  */\n+  int no_wchar_size_warning;\n+\n   /* tls_type for each local got entry.  */\n   char *local_got_tls_type;\n \n@@ -3154,12 +3161,6 @@ struct elf_arm_obj_tdata\n   /* Information for local symbols that need entries in .iplt.  */\n   struct arm_local_iplt_info **local_iplt;\n \n-  /* Zero to warn when linking objects with incompatible enum sizes.  */\n-  int no_enum_size_warning;\n-\n-  /* Zero to warn when linking objects with incompatible wchar_t sizes.  */\n-  int no_wchar_size_warning;\n-\n   /* Maintains FDPIC counters and funcdesc info.  */\n   struct fdpic_local *local_fdpic_cnts;\n };\n@@ -3479,21 +3480,21 @@ static void elf32_arm_add_dynreloc (bfd *output_bfd, struct bfd_link_info *info,\n \t\t\t\t    asection *sreloc, Elf_Internal_Rela *rel);\n \n static void\n-arm_elf_fill_funcdesc(bfd *output_bfd,\n-\t\t      struct bfd_link_info *info,\n-\t\t      int *funcdesc_offset,\n-\t\t      int dynindx,\n-\t\t      int offset,\n-\t\t      bfd_vma addr,\n-\t\t      bfd_vma dynreloc_value,\n-\t\t      bfd_vma seg)\n+arm_elf_fill_funcdesc (bfd *output_bfd,\n+\t\t       struct bfd_link_info *info,\n+\t\t       int *funcdesc_offset,\n+\t\t       int dynindx,\n+\t\t       int offset,\n+\t\t       bfd_vma addr,\n+\t\t       bfd_vma dynreloc_value,\n+\t\t       bfd_vma seg)\n {\n   if ((*funcdesc_offset & 1) == 0)\n     {\n       struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (info);\n       asection *sgot = globals->root.sgot;\n \n-      if (bfd_link_pic(info))\n+      if (bfd_link_pic (info))\n \t{\n \t  asection *srelgot = globals->root.srelgot;\n \t  Elf_Internal_Rela outrel;\n@@ -3513,12 +3514,12 @@ arm_elf_fill_funcdesc(bfd *output_bfd,\n \t    + hgot->root.u.def.section->output_section->vma\n \t    + hgot->root.u.def.section->output_offset;\n \n-\t  arm_elf_add_rofixup(output_bfd, globals->srofixup,\n-\t\t\t      sgot->output_section->vma + sgot->output_offset\n-\t\t\t      + offset);\n-\t  arm_elf_add_rofixup(output_bfd, globals->srofixup,\n-\t\t\t      sgot->output_section->vma + sgot->output_offset\n-\t\t\t      + offset + 4);\n+\t  arm_elf_add_rofixup (output_bfd, globals->srofixup,\n+\t\t\t       sgot->output_section->vma + sgot->output_offset\n+\t\t\t       + offset);\n+\t  arm_elf_add_rofixup (output_bfd, globals->srofixup,\n+\t\t\t       sgot->output_section->vma + sgot->output_offset\n+\t\t\t       + offset + 4);\n \t  bfd_put_32 (output_bfd, dynreloc_value, sgot->contents + offset);\n \t  bfd_put_32 (output_bfd, got_value, sgot->contents + offset + 4);\n \t}\n@@ -3693,7 +3694,7 @@ elf32_arm_plt_needs_thumb_stub_p (struct bfd_link_info *info,\n \n   htab = elf32_arm_hash_table (info);\n \n-  return (!using_thumb_only(htab) && (arm_plt->thumb_refcount != 0\n+  return (!using_thumb_only (htab) && (arm_plt->thumb_refcount != 0\n \t  || (!htab->use_blx && arm_plt->maybe_thumb_refcount != 0)));\n }\n \n@@ -3724,7 +3725,7 @@ elf32_arm_get_local_dynreloc_list (bfd *abfd, unsigned long r_symndx,\n \n       s = bfd_section_from_elf_index (abfd, isym->st_shndx);\n       if (s == NULL)\n-\tabort ();\n+\treturn NULL;\n \n       vpp = &elf_section_data (s)->local_dynrel;\n       return (struct elf_dyn_relocs **) vpp;\n@@ -3984,9 +3985,9 @@ elf32_arm_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)\n   if (htab->fdpic_p) {\n     htab->plt_header_size = 0;\n     if (info->flags & DF_BIND_NOW)\n-      htab->plt_entry_size = 4 * (ARRAY_SIZE(elf32_arm_fdpic_plt_entry) - 5);\n+      htab->plt_entry_size = 4 * (ARRAY_SIZE (elf32_arm_fdpic_plt_entry) - 5);\n     else\n-      htab->plt_entry_size = 4 * ARRAY_SIZE(elf32_arm_fdpic_plt_entry);\n+      htab->plt_entry_size = 4 * ARRAY_SIZE (elf32_arm_fdpic_plt_entry);\n   }\n \n   if (!htab->root.splt\n@@ -4545,7 +4546,7 @@ elf32_arm_get_stub_entry (const asection *input_section,\n   /* If the input section is the CMSE stubs one and it needs a long\n      branch stub to reach it's final destination, give up with an\n      error message: this is not supported.  See PR ld/24709.  */\n-  if (!strncmp (input_section->name, CMSE_STUB_NAME, strlen(CMSE_STUB_NAME)))\n+  if (!strncmp (input_section->name, CMSE_STUB_NAME, strlen (CMSE_STUB_NAME)))\n     {\n       bfd *output_bfd = htab->obfd;\n       asection *out_sec = bfd_get_section_by_name (output_bfd, CMSE_STUB_NAME);\n@@ -4560,7 +4561,7 @@ elf32_arm_get_stub_entry (const asection *input_section,\n \t\t\t    + h->root.root.u.def.value);\n       /* Exit, rather than leave incompletely processed\n \t relocations.  */\n-      xexit(1);\n+      xexit (1);\n     }\n \n   /* If this input section is part of a group of sections sharing one\n@@ -5220,8 +5221,8 @@ arm_size_one_stub (struct bfd_hash_entry *gen_entry,\n   /* Massage our args to the form they really have.  */\n   stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;\n \n-  BFD_ASSERT((stub_entry->stub_type > arm_stub_none)\n-\t     && stub_entry->stub_type < ARRAY_SIZE(stub_definitions));\n+  BFD_ASSERT ((stub_entry->stub_type > arm_stub_none)\n+\t      && stub_entry->stub_type < ARRAY_SIZE (stub_definitions));\n \n   size = find_stub_size_and_template (stub_entry->stub_type, &template_sequence,\n \t\t\t\t      &template_size);\n@@ -9750,7 +9751,7 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n     }\n   else if (htab->fdpic_p)\n     {\n-      const bfd_vma *plt_entry = using_thumb_only(htab)\n+      const bfd_vma *plt_entry = using_thumb_only (htab)\n \t? elf32_arm_fdpic_thumb_plt_entry\n \t: elf32_arm_fdpic_plt_entry;\n \n@@ -9765,10 +9766,10 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n       /* As we are using 32 bit instructions even for the Thumb\n \t version, we have to use 'put_arm_insn' instead of\n \t 'put_thumb_insn'.  */\n-      put_arm_insn(htab, output_bfd, plt_entry[0], ptr + 0);\n-      put_arm_insn(htab, output_bfd, plt_entry[1], ptr + 4);\n-      put_arm_insn(htab, output_bfd, plt_entry[2], ptr + 8);\n-      put_arm_insn(htab, output_bfd, plt_entry[3], ptr + 12);\n+      put_arm_insn (htab, output_bfd, plt_entry[0], ptr + 0);\n+      put_arm_insn (htab, output_bfd, plt_entry[1], ptr + 4);\n+      put_arm_insn (htab, output_bfd, plt_entry[2], ptr + 8);\n+      put_arm_insn (htab, output_bfd, plt_entry[3], ptr + 12);\n       bfd_put_32 (output_bfd, got_offset, ptr + 16);\n \n       if (!(info->flags & DF_BIND_NOW))\n@@ -9777,10 +9778,10 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n \t  bfd_put_32 (output_bfd,\n \t\t      htab->root.srelplt->reloc_count * RELOC_SIZE (htab),\n \t\t      ptr + 20);\n-\t  put_arm_insn(htab, output_bfd, plt_entry[6], ptr + 24);\n-\t  put_arm_insn(htab, output_bfd, plt_entry[7], ptr + 28);\n-\t  put_arm_insn(htab, output_bfd, plt_entry[8], ptr + 32);\n-\t  put_arm_insn(htab, output_bfd, plt_entry[9], ptr + 36);\n+\t  put_arm_insn (htab, output_bfd, plt_entry[6], ptr + 24);\n+\t  put_arm_insn (htab, output_bfd, plt_entry[7], ptr + 28);\n+\t  put_arm_insn (htab, output_bfd, plt_entry[8], ptr + 32);\n+\t  put_arm_insn (htab, output_bfd, plt_entry[9], ptr + 36);\n \t}\n     }\n   else if (using_thumb_only (htab))\n@@ -9928,10 +9929,10 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n \t instruction that could be used to prevent it; it is\n \t recommended that threaded FDPIC applications run with the\n \t LD_BIND_NOW environment variable set.  */\n-      bfd_put_32(output_bfd, plt_address + 0x18,\n-\t\t sgot->contents + got_offset);\n-      bfd_put_32(output_bfd, -1 /*TODO*/,\n-\t\t sgot->contents + got_offset + 4);\n+      bfd_put_32 (output_bfd, plt_address + 0x18,\n+\t\t  sgot->contents + got_offset);\n+      bfd_put_32 (output_bfd, -1 /*TODO*/,\n+\t\t  sgot->contents + got_offset + 4);\n     }\n \n   if (dynindx == -1)\n@@ -9944,9 +9945,9 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n \t     lazy binding otherwise we put them in .rel.plt.  For now,\n \t     we don't support lazy binding so put it in .rel.got.  */\n \t  if (info->flags & DF_BIND_NOW)\n-\t    elf32_arm_add_dynreloc(output_bfd, info, htab->root.srelgot, &rel);\n+\t    elf32_arm_add_dynreloc (output_bfd, info, htab->root.srelgot, &rel);\n \t  else\n-\t    elf32_arm_add_dynreloc(output_bfd, info, htab->root.srelplt, &rel);\n+\t    elf32_arm_add_dynreloc (output_bfd, info, htab->root.srelplt, &rel);\n \t}\n       else\n \t{\n@@ -10543,7 +10544,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \n \t      /* This symbol is local, or marked to become local.  */\n \t      BFD_ASSERT (r_type == R_ARM_ABS32 || r_type == R_ARM_ABS32_NOI\n-\t\t\t  || (globals->fdpic_p && !bfd_link_pic(info)));\n+\t\t\t  || (globals->fdpic_p && !bfd_link_pic (info)));\n \t      /* On SVR4-ish systems, the dynamic loader cannot\n \t\t relocate the text and data segments independently,\n \t\t so the symbol does not matter.  */\n@@ -10554,7 +10555,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t\t   must use an R_ARM_IRELATIVE relocation to obtain the\n \t\t   correct run-time address.  */\n \t\toutrel.r_info = ELF32_R_INFO (symbol, R_ARM_IRELATIVE);\n-\t      else if (globals->fdpic_p && !bfd_link_pic(info))\n+\t      else if (globals->fdpic_p && !bfd_link_pic (info))\n \t\tisrofixup = 1;\n \t      else\n \t\toutrel.r_info = ELF32_R_INFO (symbol, R_ARM_RELATIVE);\n@@ -10565,7 +10566,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t    }\n \n \t  if (isrofixup)\n-\t    arm_elf_add_rofixup(output_bfd, globals->srofixup, outrel.r_offset);\n+\t    arm_elf_add_rofixup (output_bfd, globals->srofixup, outrel.r_offset);\n \t  else\n \t    elf32_arm_add_dynreloc (output_bfd, info, sreloc, &outrel);\n \n@@ -11466,7 +11467,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \n \t      if (isrofixup)\n \t\tarm_elf_add_rofixup (output_bfd,\n-\t\t\t\t     elf32_arm_hash_table(info)->srofixup,\n+\t\t\t\t     elf32_arm_hash_table (info)->srofixup,\n \t\t\t\t     sgot->output_section->vma\n \t\t\t\t     + sgot->output_offset + off);\n \n@@ -11593,9 +11594,9 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \n \tif (r_type == R_ARM_TLS_LDM32_FDPIC)\n \t  {\n-\t    bfd_put_32(output_bfd,\n-\t\t       globals->root.sgot->output_offset + off,\n-\t\t       contents + rel->r_offset);\n+\t    bfd_put_32 (output_bfd,\n+\t\t\tglobals->root.sgot->output_offset + off,\n+\t\t\tcontents + rel->r_offset);\n \n \t    return bfd_reloc_ok;\n \t  }\n@@ -11647,14 +11648,15 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \telse\n \t  {\n \t    BFD_ASSERT (local_got_offsets != NULL);\n+\n \t    off = local_got_offsets[r_symndx];\n \t    offplt = local_tlsdesc_gotents[r_symndx];\n \t    tls_type = elf32_arm_local_got_tls_type (input_bfd)[r_symndx];\n \t  }\n \n \t/* Linker relaxations happens from one of the\n \t   R_ARM_{GOTDESC,CALL,DESCSEQ} relocations to IE or LE.  */\n-\tif (ELF32_R_TYPE(rel->r_info) != r_type)\n+\tif (ELF32_R_TYPE (rel->r_info) != r_type)\n \t  tls_type = GOT_TLS_IE;\n \n \tBFD_ASSERT (tls_type != GOT_UNKNOWN);\n@@ -11809,8 +11811,8 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \telse if (tls_type & GOT_TLS_GDESC)\n \t  off = offplt;\n \n-\tif (ELF32_R_TYPE(rel->r_info) == R_ARM_TLS_CALL\n-\t    || ELF32_R_TYPE(rel->r_info) == R_ARM_THM_TLS_CALL)\n+\tif (ELF32_R_TYPE (rel->r_info) == R_ARM_TLS_CALL\n+\t    || ELF32_R_TYPE (rel->r_info) == R_ARM_THM_TLS_CALL)\n \t  {\n \t    bfd_signed_vma offset;\n \t    /* TLS stubs are arm mode.  The original symbol is a\n@@ -11838,7 +11840,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t\t\t+ globals->root.splt->output_offset\n \t\t\t+ globals->tls_trampoline);\n \n-\t    if (ELF32_R_TYPE(rel->r_info) == R_ARM_TLS_CALL)\n+\t    if (ELF32_R_TYPE (rel->r_info) == R_ARM_TLS_CALL)\n \t      {\n \t\tunsigned long inst;\n \n@@ -11968,9 +11970,9 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t  {\n \t    /* For FDPIC relocations, resolve to the offset of the GOT\n \t       entry from the start of GOT.  */\n-\t    bfd_put_32(output_bfd,\n-\t\t       globals->root.sgot->output_offset + off,\n-\t\t       contents + rel->r_offset);\n+\t    bfd_put_32 (output_bfd,\n+\t\t\tglobals->root.sgot->output_offset + off,\n+\t\t\tcontents + rel->r_offset);\n \n \t    return bfd_reloc_ok;\n \t  }\n@@ -12565,23 +12567,26 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n       {\n \tif (h == NULL)\n \t  {\n-\t    struct fdpic_local *local_fdpic_cnts = elf32_arm_local_fdpic_cnts(input_bfd);\n+\t    struct fdpic_local *local_fdpic_cnts = elf32_arm_local_fdpic_cnts (input_bfd);\n \t    int dynindx = elf_section_data (sym_sec->output_section)->dynindx;\n \t    int offset = local_fdpic_cnts[r_symndx].funcdesc_offset & ~1;\n \t    bfd_vma addr = dynreloc_value - sym_sec->output_section->vma;\n \t    bfd_vma seg = -1;\n \n-\t    if (bfd_link_pic(info) && dynindx == 0)\n-\t      abort();\n+\t    if (bfd_link_pic (info) && dynindx == 0)\n+\t      {\n+\t\t* error_message = _(\"no dynamic index information available\");\n+\t\treturn bfd_reloc_dangerous;\n+\t      }\n \n \t    /* Resolve relocation.  */\n-\t    bfd_put_32(output_bfd, (offset + sgot->output_offset)\n+\t    bfd_put_32 (output_bfd, (offset + sgot->output_offset)\n \t\t       , contents + rel->r_offset);\n \t    /* Emit R_ARM_FUNCDESC_VALUE or two fixups on funcdesc if\n \t       not done yet.  */\n-\t    arm_elf_fill_funcdesc(output_bfd, info,\n-\t\t\t\t  &local_fdpic_cnts[r_symndx].funcdesc_offset,\n-\t\t\t\t  dynindx, offset, addr, dynreloc_value, seg);\n+\t    arm_elf_fill_funcdesc (output_bfd, info,\n+\t\t\t\t   &local_fdpic_cnts[r_symndx].funcdesc_offset,\n+\t\t\t\t   dynindx, offset, addr, dynreloc_value, seg);\n \t  }\n \telse\n \t  {\n@@ -12602,21 +12607,27 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t\taddr = 0;\n \t      }\n \n-\t    if (bfd_link_pic(info) && dynindx == 0)\n-\t      abort();\n+\t    if (bfd_link_pic (info) && dynindx == 0)\n+\t      {\n+\t\t* error_message = _(\"no dynamic index information available\");\n+\t\treturn bfd_reloc_dangerous;\n+\t      }\n \n \t    /* This case cannot occur since funcdesc is allocated by\n \t       the dynamic loader so we cannot resolve the relocation.  */\n \t    if (h->dynindx != -1)\n-\t      abort();\n+\t      {\n+\t\t* error_message = _(\"invalid dynamic index\");\n+\t\treturn bfd_reloc_dangerous;\n+\t      }\n \n \t    /* Resolve relocation.  */\n-\t    bfd_put_32(output_bfd, (offset + sgot->output_offset),\n-\t\t       contents + rel->r_offset);\n+\t    bfd_put_32 (output_bfd, (offset + sgot->output_offset),\n+\t\t        contents + rel->r_offset);\n \t    /* Emit R_ARM_FUNCDESC_VALUE on funcdesc if not done yet.  */\n-\t    arm_elf_fill_funcdesc(output_bfd, info,\n-\t\t\t\t  &eh->fdpic_cnts.funcdesc_offset,\n-\t\t\t\t  dynindx, offset, addr, dynreloc_value, seg);\n+\t    arm_elf_fill_funcdesc (output_bfd, info,\n+\t\t\t\t   &eh->fdpic_cnts.funcdesc_offset,\n+\t\t\t\t   dynindx, offset, addr, dynreloc_value, seg);\n \t  }\n       }\n       *unresolved_reloc_p = false;\n@@ -12629,11 +12640,11 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t    Elf_Internal_Rela outrel;\n \n \t    /* Resolve relocation.  */\n-\t    bfd_put_32(output_bfd, ((eh->fdpic_cnts.gotfuncdesc_offset & ~1)\n-\t\t\t\t    + sgot->output_offset),\n-\t\t       contents + rel->r_offset);\n+\t    bfd_put_32 (output_bfd, ((eh->fdpic_cnts.gotfuncdesc_offset & ~1)\n+\t\t\t\t     + sgot->output_offset),\n+\t\t\tcontents + rel->r_offset);\n \t    /* Add funcdesc and associated R_ARM_FUNCDESC_VALUE.  */\n-\t    if(h->dynindx == -1)\n+\t    if (h->dynindx == -1)\n \t      {\n \t\tint dynindx;\n \t\tint offset = eh->fdpic_cnts.funcdesc_offset & ~1;\n@@ -12653,9 +12664,9 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t\t  }\n \n \t\t/* Emit R_ARM_FUNCDESC_VALUE on funcdesc if not done yet.  */\n-\t\tarm_elf_fill_funcdesc(output_bfd, info,\n-\t\t\t\t      &eh->fdpic_cnts.funcdesc_offset,\n-\t\t\t\t      dynindx, offset, addr, dynreloc_value, seg);\n+\t\tarm_elf_fill_funcdesc (output_bfd, info,\n+\t\t\t\t       &eh->fdpic_cnts.funcdesc_offset,\n+\t\t\t\t       dynindx, offset, addr, dynreloc_value, seg);\n \t      }\n \n \t    /* Add a dynamic relocation on GOT entry if not already done.  */\n@@ -12665,14 +12676,14 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t\t  {\n \t\t    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);\n \t\t    if (h->root.type == bfd_link_hash_undefweak)\n-\t\t      bfd_put_32(output_bfd, 0, sgot->contents\n-\t\t\t\t + (eh->fdpic_cnts.gotfuncdesc_offset & ~1));\n+\t\t      bfd_put_32 (output_bfd, 0, sgot->contents\n+\t\t\t\t  + (eh->fdpic_cnts.gotfuncdesc_offset & ~1));\n \t\t    else\n-\t\t      bfd_put_32(output_bfd, sgot->output_section->vma\n-\t\t\t\t + sgot->output_offset\n-\t\t\t\t + (eh->fdpic_cnts.funcdesc_offset & ~1),\n-\t\t\t\t sgot->contents\n-\t\t\t\t + (eh->fdpic_cnts.gotfuncdesc_offset & ~1));\n+\t\t      bfd_put_32 (output_bfd, sgot->output_section->vma\n+\t\t\t\t  + sgot->output_offset\n+\t\t\t\t  + (eh->fdpic_cnts.funcdesc_offset & ~1),\n+\t\t\t\t  sgot->contents\n+\t\t\t\t  + (eh->fdpic_cnts.gotfuncdesc_offset & ~1));\n \t\t  }\n \t\telse\n \t\t  {\n@@ -12682,12 +12693,12 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t\t  + sgot->output_offset\n \t\t  + (eh->fdpic_cnts.gotfuncdesc_offset & ~1);\n \t\toutrel.r_addend = 0;\n-\t\tif (h->dynindx == -1 && !bfd_link_pic(info))\n+\t\tif (h->dynindx == -1 && !bfd_link_pic (info))\n \t\t  if (h->root.type == bfd_link_hash_undefweak)\n-\t\t    arm_elf_add_rofixup(output_bfd, globals->srofixup, -1);\n+\t\t    arm_elf_add_rofixup (output_bfd, globals->srofixup, -1);\n \t\t  else\n-\t\t    arm_elf_add_rofixup(output_bfd, globals->srofixup,\n-\t\t\t\t\toutrel.r_offset);\n+\t\t    arm_elf_add_rofixup (output_bfd, globals->srofixup,\n+\t\t\t\t\t outrel.r_offset);\n \t\telse\n \t\t  elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);\n \t\teh->fdpic_cnts.gotfuncdesc_offset |= 1;\n@@ -12697,7 +12708,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t  {\n \t    /* Such relocation on static function should not have been\n \t       emitted by the compiler.  */\n-\t    abort();\n+\t    return bfd_reloc_notsupported;\n \t  }\n       }\n       *unresolved_reloc_p = false;\n@@ -12707,15 +12718,18 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n       {\n \tif (h == NULL)\n \t  {\n-\t    struct fdpic_local *local_fdpic_cnts = elf32_arm_local_fdpic_cnts(input_bfd);\n+\t    struct fdpic_local *local_fdpic_cnts = elf32_arm_local_fdpic_cnts (input_bfd);\n \t    Elf_Internal_Rela outrel;\n \t    int dynindx = elf_section_data (sym_sec->output_section)->dynindx;\n \t    int offset = local_fdpic_cnts[r_symndx].funcdesc_offset & ~1;\n \t    bfd_vma addr = dynreloc_value - sym_sec->output_section->vma;\n \t    bfd_vma seg = -1;\n \n-\t    if (bfd_link_pic(info) && dynindx == 0)\n-\t      abort();\n+\t    if (bfd_link_pic (info) && dynindx == 0)\n+\t      {\n+\t\t* error_message = _(\"dynamic index information not available\");\n+\t\treturn bfd_reloc_dangerous;\n+\t      }\n \n \t    /* Replace static FUNCDESC relocation with a\n \t       R_ARM_RELATIVE dynamic relocation or with a rofixup for\n@@ -12724,18 +12738,18 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t    outrel.r_offset = input_section->output_section->vma\n \t      + input_section->output_offset + rel->r_offset;\n \t    outrel.r_addend = 0;\n-\t    if (bfd_link_pic(info))\n+\t    if (bfd_link_pic (info))\n \t      elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);\n \t    else\n-\t      arm_elf_add_rofixup(output_bfd, globals->srofixup, outrel.r_offset);\n+\t      arm_elf_add_rofixup (output_bfd, globals->srofixup, outrel.r_offset);\n \n \t    bfd_put_32 (input_bfd, sgot->output_section->vma\n \t\t\t+ sgot->output_offset + offset, hit_data);\n \n \t    /* Emit R_ARM_FUNCDESC_VALUE on funcdesc if not done yet.  */\n-\t    arm_elf_fill_funcdesc(output_bfd, info,\n-\t\t\t\t  &local_fdpic_cnts[r_symndx].funcdesc_offset,\n-\t\t\t\t  dynindx, offset, addr, dynreloc_value, seg);\n+\t    arm_elf_fill_funcdesc (output_bfd, info,\n+\t\t\t\t   &local_fdpic_cnts[r_symndx].funcdesc_offset,\n+\t\t\t\t   dynindx, offset, addr, dynreloc_value, seg);\n \t  }\n \telse\n \t  {\n@@ -12759,27 +12773,27 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t\t    addr = 0;\n \t\t  }\n \n-\t\tif (bfd_link_pic(info) && dynindx == 0)\n-\t\t  abort();\n+\t\tif (bfd_link_pic (info) && dynindx == 0)\n+\t\t  abort ();\n \n \t\t/* Replace static FUNCDESC relocation with a\n \t\t   R_ARM_RELATIVE dynamic relocation.  */\n \t\toutrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);\n \t\toutrel.r_offset = input_section->output_section->vma\n \t\t  + input_section->output_offset + rel->r_offset;\n \t\toutrel.r_addend = 0;\n-\t\tif (bfd_link_pic(info))\n+\t\tif (bfd_link_pic (info))\n \t\t  elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);\n \t\telse\n-\t\t  arm_elf_add_rofixup(output_bfd, globals->srofixup, outrel.r_offset);\n+\t\t  arm_elf_add_rofixup (output_bfd, globals->srofixup, outrel.r_offset);\n \n \t\tbfd_put_32 (input_bfd, sgot->output_section->vma\n \t\t\t    + sgot->output_offset + offset, hit_data);\n \n \t\t/* Emit R_ARM_FUNCDESC_VALUE on funcdesc if not done yet.  */\n-\t\tarm_elf_fill_funcdesc(output_bfd, info,\n-\t\t\t\t      &eh->fdpic_cnts.funcdesc_offset,\n-\t\t\t\t      dynindx, offset, addr, dynreloc_value, seg);\n+\t\tarm_elf_fill_funcdesc (output_bfd, info,\n+\t\t\t\t       &eh->fdpic_cnts.funcdesc_offset,\n+\t\t\t\t       dynindx, offset, addr, dynreloc_value, seg);\n \t      }\n \t    else\n \t      {\n@@ -13414,8 +13428,9 @@ add_unwind_table_edit (arm_unwind_table_edit **head,\n static _arm_elf_section_data *get_arm_elf_section_data (asection *);\n \n /* Increase the size of EXIDX_SEC by ADJUST bytes.  ADJUST mau be negative.  */\n+\n static void\n-adjust_exidx_size(asection *exidx_sec, int adjust)\n+adjust_exidx_size (asection *exidx_sec, int adjust)\n {\n   asection *out_sec;\n \n@@ -13425,24 +13440,25 @@ adjust_exidx_size(asection *exidx_sec, int adjust)\n   bfd_set_section_size (exidx_sec, exidx_sec->size + adjust);\n   out_sec = exidx_sec->output_section;\n   /* Adjust size of output section.  */\n-  bfd_set_section_size (out_sec, out_sec->size +adjust);\n+  bfd_set_section_size (out_sec, out_sec->size + adjust);\n }\n \n /* Insert an EXIDX_CANTUNWIND marker at the end of a section.  */\n+\n static void\n-insert_cantunwind_after(asection *text_sec, asection *exidx_sec)\n+insert_cantunwind_after (asection *text_sec, asection *exidx_sec)\n {\n   struct _arm_elf_section_data *exidx_arm_data;\n \n   exidx_arm_data = get_arm_elf_section_data (exidx_sec);\n-  add_unwind_table_edit (\n-    &exidx_arm_data->u.exidx.unwind_edit_list,\n-    &exidx_arm_data->u.exidx.unwind_edit_tail,\n-    INSERT_EXIDX_CANTUNWIND_AT_END, text_sec, UINT_MAX);\n+  add_unwind_table_edit\n+    (&exidx_arm_data->u.exidx.unwind_edit_list,\n+     &exidx_arm_data->u.exidx.unwind_edit_tail,\n+     INSERT_EXIDX_CANTUNWIND_AT_END, text_sec, UINT_MAX);\n \n   exidx_arm_data->additional_reloc_count++;\n \n-  adjust_exidx_size(exidx_sec, 8);\n+  adjust_exidx_size (exidx_sec, 8);\n }\n \n /* Scan .ARM.exidx tables, and create a list describing edits which should be\n@@ -13532,7 +13548,7 @@ elf32_arm_fix_exidx_coverage (asection **text_section_order,\n \t  if (sec->size == 0)\n \t    continue;\n \n-\t  insert_cantunwind_after(last_text_sec, last_exidx_sec);\n+\t  insert_cantunwind_after (last_text_sec, last_exidx_sec);\n \t  last_unwind_type = 0;\n \t  continue;\n \t}\n@@ -13616,7 +13632,7 @@ elf32_arm_fix_exidx_coverage (asection **text_section_order,\n       exidx_arm_data->u.exidx.unwind_edit_tail = unwind_edit_tail;\n \n       if (deleted_exidx_bytes > 0)\n-\tadjust_exidx_size(exidx_sec, -deleted_exidx_bytes);\n+\tadjust_exidx_size (exidx_sec, - deleted_exidx_bytes);\n \n       last_exidx_sec = exidx_sec;\n       last_text_sec = sec;\n@@ -13625,7 +13641,7 @@ elf32_arm_fix_exidx_coverage (asection **text_section_order,\n   /* Add terminating CANTUNWIND entry.  */\n   if (!bfd_link_relocatable (info) && last_exidx_sec\n       && last_unwind_type != 0)\n-    insert_cantunwind_after(last_text_sec, last_exidx_sec);\n+    insert_cantunwind_after (last_text_sec, last_exidx_sec);\n \n   return true;\n }\n@@ -14821,11 +14837,11 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, struct bfd_link_info *info)\n \t\t  static const char *aeabi_enum_names[] =\n \t\t    { \"\", \"variable-size\", \"32-bit\", \"\" };\n \t\t  const char *in_name =\n-\t\t    in_attr[i].i < ARRAY_SIZE(aeabi_enum_names)\n+\t\t    in_attr[i].i < ARRAY_SIZE (aeabi_enum_names)\n \t\t    ? aeabi_enum_names[in_attr[i].i]\n \t\t    : \"<unknown>\";\n \t\t  const char *out_name =\n-\t\t    out_attr[i].i < ARRAY_SIZE(aeabi_enum_names)\n+\t\t    out_attr[i].i < ARRAY_SIZE (aeabi_enum_names)\n \t\t    ? aeabi_enum_names[out_attr[i].i]\n \t\t    : \"<unknown>\";\n \t\t  _bfd_error_handler\n@@ -15261,8 +15277,8 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      {\n \t\tif (!elf32_arm_allocate_local_sym_info (abfd))\n \t\t  return false;\n-\t\telf32_arm_local_fdpic_cnts(abfd)[r_symndx].gotofffuncdesc_cnt += 1;\n-\t\telf32_arm_local_fdpic_cnts(abfd)[r_symndx].funcdesc_offset = -1;\n+\t\telf32_arm_local_fdpic_cnts (abfd) [r_symndx].gotofffuncdesc_cnt += 1;\n+\t\telf32_arm_local_fdpic_cnts (abfd) [r_symndx].funcdesc_offset = -1;\n \t      }\n \t    else\n \t      {\n@@ -15276,9 +15292,9 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t    if (h == NULL)\n \t      {\n \t\t/* Such a relocation is not supposed to be generated\n-\t\t   by gcc on a static function. */\n+\t\t   by gcc on a static function.  */\n \t\t/* Anyway if needed it could be handled.  */\n-\t\tabort();\n+\t\treturn false;\n \t      }\n \t    else\n \t      {\n@@ -15293,8 +15309,8 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      {\n \t\tif (!elf32_arm_allocate_local_sym_info (abfd))\n \t\t  return false;\n-\t\telf32_arm_local_fdpic_cnts(abfd)[r_symndx].funcdesc_cnt += 1;\n-\t\telf32_arm_local_fdpic_cnts(abfd)[r_symndx].funcdesc_offset = -1;\n+\t\telf32_arm_local_fdpic_cnts (abfd) [r_symndx].funcdesc_cnt += 1;\n+\t\telf32_arm_local_fdpic_cnts (abfd) [r_symndx].funcdesc_offset = -1;\n \t      }\n \t    else\n \t      {\n@@ -15591,18 +15607,18 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t  if (elf32_arm_howto_from_type (r_type)->pc_relative)\n \t    p->pc_count += 1;\n \t  p->count += 1;\n-\t  if (h == NULL && htab->fdpic_p && !bfd_link_pic(info)\n-\t      && r_type != R_ARM_ABS32 && r_type != R_ARM_ABS32_NOI) {\n-\t    /* Here we only support R_ARM_ABS32 and R_ARM_ABS32_NOI\n-\t       that will become rofixup.  */\n-\t    /* This is due to the fact that we suppose all will become rofixup.  */\n-\t    fprintf(stderr, \"FDPIC does not yet support %d relocation to become dynamic for executable\\n\", r_type);\n-\t    _bfd_error_handler\n-\t      (_(\"FDPIC does not yet support %s relocation\"\n-\t\t \" to become dynamic for executable\"),\n-\t       elf32_arm_howto_table_1[r_type].name);\n-\t    abort();\n-\t  }\n+\t  if (h == NULL && htab->fdpic_p && !bfd_link_pic (info)\n+\t      && r_type != R_ARM_ABS32 && r_type != R_ARM_ABS32_NOI)\n+\t    {\n+\t      /* Here we only support R_ARM_ABS32 and R_ARM_ABS32_NOI\n+\t\t that will become rofixup.  */\n+\t      /* This is due to the fact that we suppose all will become rofixup.  */\n+\t      _bfd_error_handler\n+\t\t(_(\"FDPIC does not yet support %s relocation\"\n+\t\t   \" to become dynamic for executable\"),\n+\t\t elf32_arm_howto_table_1[r_type].name);\n+\t      abort ();\n+\t    }\n \t}\n     }\n \n@@ -15927,7 +15943,7 @@ elf32_arm_maybe_function_sym (const asymbol *sym, asection *sec,\n \tdefault:\n \t  return 0;\n       }\n-\t\t\t\t\t\t\t\t\t\t\t     \n+\n   if ((sym->flags & BSF_LOCAL)\n       && bfd_is_arm_special_symbol_name (sym->name,\n \t\t\t\t\t BFD_ARM_SPECIAL_SYM_TYPE_ANY))\n@@ -16313,7 +16329,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n     {\n       /* Symbol musn't be exported.  */\n       if (h->dynindx != -1)\n-\tabort();\n+\tabort ();\n \n       /* We only allocate one function descriptor with its associated\n \t relocation.  */\n@@ -16324,7 +16340,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t  eh->fdpic_cnts.funcdesc_offset = s->size;\n \t  s->size += 8;\n \t  /* We will add an R_ARM_FUNCDESC_VALUE relocation or two rofixups.  */\n-\t  if (bfd_link_pic(info))\n+\t  if (bfd_link_pic (info))\n \t    elf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);\n \t  else\n \t    htab->srofixup->size += 8;\n@@ -16351,7 +16367,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t      s->size += 8;\n \t      /* We will add an R_ARM_FUNCDESC_VALUE relocation or two\n \t\t rofixups.  */\n-\t      if (bfd_link_pic(info))\n+\t      if (bfd_link_pic (info))\n \t\telf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);\n \t      else\n \t\thtab->srofixup->size += 8;\n@@ -16362,7 +16378,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t R_ARM_RELATIVE/rofixup relocation on it.  */\n       eh->fdpic_cnts.gotfuncdesc_offset = s->size;\n       s->size += 4;\n-      if (h->dynindx == -1 && !bfd_link_pic(info))\n+      if (h->dynindx == -1 && !bfd_link_pic (info))\n \thtab->srofixup->size += 4;\n       else\n \telf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);\n@@ -16387,13 +16403,13 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t      s->size += 8;\n \t      /* We will add an R_ARM_FUNCDESC_VALUE relocation or two\n \t\t rofixups.  */\n-\t      if (bfd_link_pic(info))\n+\t      if (bfd_link_pic (info))\n \t\telf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);\n \t      else\n \t\thtab->srofixup->size += 8;\n \t    }\n \t}\n-      if (h->dynindx == -1 && !bfd_link_pic(info))\n+      if (h->dynindx == -1 && !bfd_link_pic (info))\n \t{\n \t  /* For FDPIC executable we replace R_ARM_RELATIVE with a rofixup.  */\n \t  htab->srofixup->size += 4 * eh->fdpic_cnts.funcdesc_cnt;\n@@ -16560,9 +16576,9 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t  && SYMBOL_REFERENCES_LOCAL (info, h))\n \telf32_arm_allocate_irelocs (info, sreloc, p->count);\n       else if (h->dynindx != -1\n-\t       && (!bfd_link_pic(info) || !info->symbolic || !h->def_regular))\n+\t       && (!bfd_link_pic (info) || !info->symbolic || !h->def_regular))\n \telf32_arm_allocate_dynrelocs (info, sreloc, p->count);\n-      else if (htab->fdpic_p && !bfd_link_pic(info))\n+      else if (htab->fdpic_p && !bfd_link_pic (info))\n \thtab->srofixup->size += 4 * p->count;\n       else\n \telf32_arm_allocate_dynrelocs (info, sreloc, p->count);\n@@ -16659,7 +16675,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t      else if (p->count != 0)\n \t\t{\n \t\t  srel = elf_section_data (p->sec)->sreloc;\n-\t\t  if (htab->fdpic_p && !bfd_link_pic(info))\n+\t\t  if (htab->fdpic_p && !bfd_link_pic (info))\n \t\t    htab->srofixup->size += 4 * p->count;\n \t\t  else\n \t\t    elf32_arm_allocate_dynrelocs (info, srel, p->count);\n@@ -16670,7 +16686,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t}\n \n       local_got = elf_local_got_refcounts (ibfd);\n-      if (!local_got)\n+      if (local_got == NULL)\n \tcontinue;\n \n       symtab_hdr = & elf_symtab_hdr (ibfd);\n@@ -16699,7 +16715,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t\t  s->size += 8;\n \n \t\t  /* We will add an R_ARM_FUNCDESC_VALUE relocation or two rofixups.  */\n-\t\t  if (bfd_link_pic(info))\n+\t\t  if (bfd_link_pic (info))\n \t\t    elf32_arm_allocate_dynrelocs (info, srel, 1);\n \t\t  else\n \t\t    htab->srofixup->size += 8;\n@@ -16714,14 +16730,14 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t\t  s->size += 8;\n \n \t\t  /* We will add an R_ARM_FUNCDESC_VALUE relocation or two rofixups.  */\n-\t\t  if (bfd_link_pic(info))\n+\t\t  if (bfd_link_pic (info))\n \t\t    elf32_arm_allocate_dynrelocs (info, srel, 1);\n \t\t  else\n \t\t    htab->srofixup->size += 8;\n \t\t}\n \n \t      /* We will add n R_ARM_RELATIVE relocations or n rofixups.  */\n-\t      if (bfd_link_pic(info))\n+\t      if (bfd_link_pic (info))\n \t\telf32_arm_allocate_dynrelocs (info, srel, local_fdpic_cnts->funcdesc_cnt);\n \t      else\n \t\thtab->srofixup->size += 4 * local_fdpic_cnts->funcdesc_cnt;\n@@ -16868,7 +16884,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n      for them, it suffices to multiply the reloc count by the jump\n      slot size.  */\n   if (htab->root.srelplt)\n-    htab->sgotplt_jump_table_size = elf32_arm_compute_jump_table_size(htab);\n+    htab->sgotplt_jump_table_size = elf32_arm_compute_jump_table_size (htab);\n \n   if (htab->tls_trampoline)\n     {\n@@ -17469,7 +17485,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t+ hgot->root.u.def.section->output_section->vma\n \t+ hgot->root.u.def.section->output_offset;\n \n-      arm_elf_add_rofixup(output_bfd, htab->srofixup, got_value);\n+      arm_elf_add_rofixup (output_bfd, htab->srofixup, got_value);\n \n       /* Make sure we allocated and generated the same number of fixups.  */\n       BFD_ASSERT (htab->srofixup->reloc_count * 4 == htab->srofixup->size);\n@@ -17733,7 +17749,7 @@ elf32_arm_output_plt_map_1 (output_arch_syminfo *osi,\n     }\n   else if (htab->fdpic_p)\n     {\n-      enum map_symbol_type type = using_thumb_only(htab)\n+      enum map_symbol_type type = using_thumb_only (htab)\n \t? ARM_MAP_THUMB\n \t: ARM_MAP_ARM;\n \n@@ -17744,7 +17760,7 @@ elf32_arm_output_plt_map_1 (output_arch_syminfo *osi,\n \treturn false;\n       if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 16))\n \treturn false;\n-      if (htab->plt_entry_size == 4 * ARRAY_SIZE(elf32_arm_fdpic_plt_entry))\n+      if (htab->plt_entry_size == 4 * ARRAY_SIZE (elf32_arm_fdpic_plt_entry))\n \tif (!elf32_arm_output_map_sym (osi, type, addr + 24))\n \t  return false;\n     }\n@@ -19796,7 +19812,7 @@ elf32_arm_plt_size (const bfd *abfd, const bfd_byte *start, bfd_vma offset)\n   /* Respect Thumb stub if necessary.  */\n   if (read_code16 (abfd, addr) == elf32_arm_plt_thumb_stub[0])\n     {\n-      plt_size += 2 * ARRAY_SIZE(elf32_arm_plt_thumb_stub);\n+      plt_size += 2 * ARRAY_SIZE (elf32_arm_plt_thumb_stub);\n     }\n \n   /* Strip immediate from first add.  */\n@@ -19866,9 +19882,9 @@ elf32_arm_get_synthetic_symtab (bfd *abfd,\n   data = plt->contents;\n   if (data == NULL)\n     {\n-      if (!bfd_get_full_section_contents(abfd, (asection *) plt, &data) || data == NULL)\n+      if (!bfd_get_full_section_contents (abfd, (asection *) plt, &data) || data == NULL)\n \treturn -1;\n-      bfd_cache_section_contents((asection *) plt, data);\n+      bfd_cache_section_contents ((asection *) plt, data);\n     }\n \n   count = relplt->size / hdr->sh_entsize;"
    }
  ]
}