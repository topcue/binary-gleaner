{
  "sha": "edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWRiYTRlNGFiYWY2NzlkM2NlNGQ2MWZjYmZlNzdiMmJlYmZkNDUzNw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-15T05:09:11Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-15T05:18:33Z"
    },
    "message": "process_debug_info\n\nThis patch constrains process_debug_info to stay within the data\nspecified by the CU length rather than allowing access up to the end\nof the section.\n\n\t* dwarf.c (process_debug_info): Always do the first CU length\n\tscan for sanity checks.  Remove initial_length_size var and\n\tinstead calculate end_cu.  Use end_cu to limit data reads.\n\tDelete now dead code checking length.",
    "tree": {
      "sha": "8d58116fd5731ecfa560c008dd57ff5274013a88",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8d58116fd5731ecfa560c008dd57ff5274013a88"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ebb17864920d1b15f3c392ce5cd22ddee169e825",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ebb17864920d1b15f3c392ce5cd22ddee169e825",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ebb17864920d1b15f3c392ce5cd22ddee169e825"
    }
  ],
  "stats": {
    "total": 150,
    "additions": 68,
    "deletions": 82
  },
  "files": [
    {
      "sha": "669cdbda78cb84852151f435681c6524908a66e8",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537",
      "patch": "@@ -1,3 +1,10 @@\n+2021-05-15  Alan Modra  <amodra@gmail.com>\n+\n+\t* dwarf.c (process_debug_info): Always do the first CU length\n+\tscan for sanity checks.  Remove initial_length_size var and\n+\tinstead calculate end_cu.  Use end_cu to limit data reads.\n+\tDelete now dead code checking length.\n+\n 2021-05-15  Alan Modra  <amodra@gmail.com>\n \n \t* dwarf.c (SAFE_BYTE_GET_INTERNAL): Assert only when ENABLE_CHECKING."
    },
    {
      "sha": "b7061a9b99cc40c365fff714c60ead041ba80f4e",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 61,
      "deletions": 82,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=edba4e4abaf679d3ce4d61fcbfe77b2bebfd4537",
      "patch": "@@ -3429,47 +3429,49 @@ process_debug_info (struct dwarf_section * section,\n   unsigned int unit;\n   unsigned int num_units = 0;\n \n-  if ((do_loc || do_debug_loc || do_debug_ranges)\n-      && num_debug_info_entries == 0\n-      && ! do_types)\n+  /* First scan the section to get the number of comp units.\n+     Length sanity checks are done here.  */\n+  for (section_begin = start, num_units = 0; section_begin < end;\n+       num_units ++)\n     {\n       dwarf_vma length;\n \n-      /* First scan the section to get the number of comp units.  */\n-      for (section_begin = start, num_units = 0; section_begin < end;\n-\t   num_units ++)\n-\t{\n-\t  /* Read the first 4 bytes.  For a 32-bit DWARF section, this\n-\t     will be the length.  For a 64-bit DWARF section, it'll be\n-\t     the escape code 0xffffffff followed by an 8 byte length.  */\n-\t  SAFE_BYTE_GET_AND_INC (length, section_begin, 4, end);\n+      /* Read the first 4 bytes.  For a 32-bit DWARF section, this\n+\t will be the length.  For a 64-bit DWARF section, it'll be\n+\t the escape code 0xffffffff followed by an 8 byte length.  */\n+      SAFE_BYTE_GET_AND_INC (length, section_begin, 4, end);\n \n-\t  if (length == 0xffffffff)\n-\t    SAFE_BYTE_GET_AND_INC (length, section_begin, 8, end);\n-\t  else if (length >= 0xfffffff0 && length < 0xffffffff)\n-\t    {\n-\t      warn (_(\"Reserved length value (0x%s) found in section %s\\n\"),\n-\t\t    dwarf_vmatoa (\"x\", length), section->name);\n-\t      return false;\n-\t    }\n-\n-\t  /* Negative values are illegal, they may even cause infinite\n-\t     looping.  This can happen if we can't accurately apply\n-\t     relocations to an object file, or if the file is corrupt.  */\n-\t  if (length > (size_t) (end - section_begin))\n-\t    {\n-\t      warn (_(\"Corrupt unit length (0x%s) found in section %s\\n\"),\n-\t\t    dwarf_vmatoa (\"x\", length), section->name);\n-\t      return false;\n-\t    }\n-\t  section_begin += length;\n+      if (length == 0xffffffff)\n+\tSAFE_BYTE_GET_AND_INC (length, section_begin, 8, end);\n+      else if (length >= 0xfffffff0 && length < 0xffffffff)\n+\t{\n+\t  warn (_(\"Reserved length value (0x%s) found in section %s\\n\"),\n+\t\tdwarf_vmatoa (\"x\", length), section->name);\n+\t  return false;\n \t}\n \n-      if (num_units == 0)\n+      /* Negative values are illegal, they may even cause infinite\n+\t looping.  This can happen if we can't accurately apply\n+\t relocations to an object file, or if the file is corrupt.  */\n+      if (length > (size_t) (end - section_begin))\n \t{\n-\t  error (_(\"No comp units in %s section ?\\n\"), section->name);\n+\t  warn (_(\"Corrupt unit length (0x%s) found in section %s\\n\"),\n+\t\tdwarf_vmatoa (\"x\", length), section->name);\n \t  return false;\n \t}\n+      section_begin += length;\n+    }\n+\n+  if (num_units == 0)\n+    {\n+      error (_(\"No comp units in %s section ?\\n\"), section->name);\n+      return false;\n+    }\n+\n+  if ((do_loc || do_debug_loc || do_debug_ranges)\n+      && num_debug_info_entries == 0\n+      && ! do_types)\n+    {\n \n       /* Then allocate an array to hold the information.  */\n       debug_information = (debug_info *) cmalloc (num_units,\n@@ -3530,29 +3532,25 @@ process_debug_info (struct dwarf_section * section,\n       size_t                    abbrev_size;\n       dwarf_vma                 cu_offset;\n       unsigned int              offset_size;\n-      unsigned int              initial_length_size;\n       struct cu_tu_set *        this_set;\n       abbrev_list *             list;\n+      unsigned char *end_cu;\n \n       hdrptr = start;\n+      cu_offset = start - section_begin;\n \n       SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 4, end);\n \n       if (compunit.cu_length == 0xffffffff)\n \t{\n \t  SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 8, end);\n \t  offset_size = 8;\n-\t  initial_length_size = 12;\n \t}\n       else\n-\t{\n-\t  offset_size = 4;\n-\t  initial_length_size = 4;\n-\t}\n+\toffset_size = 4;\n+      end_cu = hdrptr + compunit.cu_length;\n \n-      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end);\n-\n-      cu_offset = start - section_begin;\n+      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end_cu);\n \n       this_set = find_cu_tu_set_v2 (cu_offset, do_types);\n \n@@ -3564,19 +3562,20 @@ process_debug_info (struct dwarf_section * section,\n \t}\n       else\n \t{\n-\t  SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end);\n+\t  SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end_cu);\n \t  do_types = (compunit.cu_unit_type == DW_UT_type);\n \n-\t  SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n+\t  SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end_cu);\n \t}\n \n-      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);\n+      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size,\n+\t\t\t     end_cu);\n \n       if (compunit.cu_unit_type == DW_UT_split_compile\n \t  || compunit.cu_unit_type == DW_UT_skeleton)\n \t{\n \t  uint64_t dwo_id;\n-\t  SAFE_BYTE_GET_AND_INC (dwo_id, hdrptr, 8, end);\n+\t  SAFE_BYTE_GET_AND_INC (dwo_id, hdrptr, 8, end_cu);\n \t}\n \n       if (this_set == NULL)\n@@ -3604,8 +3603,7 @@ process_debug_info (struct dwarf_section * section,\n \t  list->start_of_next_abbrevs = next;\n \t}\n \n-      start = section_begin + cu_offset + compunit.cu_length\n-\t+ initial_length_size;\n+      start = end_cu;\n       record_abbrev_list_for_cu (cu_offset, start - section_begin, list);\n     }\n \n@@ -3616,35 +3614,30 @@ process_debug_info (struct dwarf_section * section,\n       unsigned char *tags;\n       int level, last_level, saved_level;\n       dwarf_vma cu_offset;\n-      unsigned long sec_off;\n       unsigned int offset_size;\n-      unsigned int initial_length_size;\n       dwarf_vma signature = 0;\n       dwarf_vma type_offset = 0;\n       struct cu_tu_set *this_set;\n       dwarf_vma abbrev_base;\n       size_t abbrev_size;\n       abbrev_list * list = NULL;\n+      unsigned char *end_cu;\n \n       hdrptr = start;\n+      cu_offset = start - section_begin;\n \n       SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 4, end);\n \n       if (compunit.cu_length == 0xffffffff)\n \t{\n \t  SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 8, end);\n \t  offset_size = 8;\n-\t  initial_length_size = 12;\n \t}\n       else\n-\t{\n-\t  offset_size = 4;\n-\t  initial_length_size = 4;\n-\t}\n-\n-      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end);\n+\toffset_size = 4;\n+      end_cu = hdrptr + compunit.cu_length;\n \n-      cu_offset = start - section_begin;\n+      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end_cu);\n \n       this_set = find_cu_tu_set_v2 (cu_offset, do_types);\n \n@@ -3656,13 +3649,13 @@ process_debug_info (struct dwarf_section * section,\n \t}\n       else\n \t{\n-\t  SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end);\n+\t  SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end_cu);\n \t  do_types = (compunit.cu_unit_type == DW_UT_type);\n \n-\t  SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n+\t  SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end_cu);\n \t}\n \n-      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);\n+      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end_cu);\n \n       if (this_set == NULL)\n \t{\n@@ -3676,14 +3669,14 @@ process_debug_info (struct dwarf_section * section,\n \t}\n \n       if (compunit.cu_version < 5)\n-\tSAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n+\tSAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end_cu);\n \n       bool do_dwo_id = false;\n       uint64_t dwo_id = 0;\n       if (compunit.cu_unit_type == DW_UT_split_compile\n \t  || compunit.cu_unit_type == DW_UT_skeleton)\n \t{\n-\t  SAFE_BYTE_GET_AND_INC (dwo_id, hdrptr, 8, end);\n+\t  SAFE_BYTE_GET_AND_INC (dwo_id, hdrptr, 8, end_cu);\n \t  do_dwo_id = true;\n \t}\n \n@@ -3697,15 +3690,13 @@ process_debug_info (struct dwarf_section * section,\n \n       if (do_types)\n \t{\n-\t  SAFE_BYTE_GET_AND_INC (signature, hdrptr, 8, end);\n-\t  SAFE_BYTE_GET_AND_INC (type_offset, hdrptr, offset_size, end);\n+\t  SAFE_BYTE_GET_AND_INC (signature, hdrptr, 8, end_cu);\n+\t  SAFE_BYTE_GET_AND_INC (type_offset, hdrptr, offset_size, end_cu);\n \t}\n \n-      if (dwarf_start_die > (cu_offset + compunit.cu_length\n-\t\t\t     + initial_length_size))\n+      if (dwarf_start_die >= (size_t) (end_cu - section_begin))\n \t{\n-\t  start = section_begin + cu_offset + compunit.cu_length\n-\t    + initial_length_size;\n+\t  start = end_cu;\n \t  continue;\n \t}\n \n@@ -3780,20 +3771,8 @@ process_debug_info (struct dwarf_section * section,\n \t    }\n \t}\n \n-      sec_off = cu_offset + initial_length_size;\n-      if (sec_off + compunit.cu_length < sec_off\n-\t  || sec_off + compunit.cu_length > section->size)\n-\t{\n-\t  warn (_(\"Debug info is corrupted, %s header at %#lx has length %s\\n\"),\n-\t\tsection->name,\n-\t\t(unsigned long) cu_offset,\n-\t\tdwarf_vmatoa (\"x\", compunit.cu_length));\n-\t  num_units = unit;\n-\t  break;\n-\t}\n-\n       tags = hdrptr;\n-      start += compunit.cu_length + initial_length_size;\n+      start = end_cu;\n \n       if (compunit.cu_version < 2 || compunit.cu_version > 5)\n \t{\n@@ -3967,7 +3946,7 @@ process_debug_info (struct dwarf_section * section,\n \t\t\t\t\t    attr->implicit_const,\n \t\t\t\t\t    section_begin,\n \t\t\t\t\t    tags,\n-\t\t\t\t\t    end,\n+\t\t\t\t\t    start,\n \t\t\t\t\t    cu_offset,\n \t\t\t\t\t    compunit.cu_pointer_size,\n \t\t\t\t\t    offset_size,"
    }
  ]
}