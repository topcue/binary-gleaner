{
  "sha": "afd2ea23626c43886ab8b028b68b7b663d6de3c6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWZkMmVhMjM2MjZjNDM4ODZhYjhiMDI4YjY4YjdiNjYzZDZkZTNjNg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-07-23T01:05:56Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-07-27T13:01:37Z"
    },
    "message": "[GOLD] Power10 stub selection\n\ngold version of commit e10a07b32dc1.\n\n\t* options.h (DEFINE_enum): Add optional_arg__ param, adjust\n\tall uses.\n\t(General_options): Add --power10-stubs and --no-power10-stubs.\n\t* options.cc (General_options::finalize): Handle --power10-stubs.\n\t* powerpc.cc (set_power10_stubs): Don't set when --power10-stubs=no.\n\t(power10_stubs_auto): New.\n\t(struct Plt_stub_ent): Add toc_ and tocoff_.  Don't use a bitfield\n\tfor indx_.\n\t(struct Branch_stub_ent): Add toc_and tocoff_.  Use bitfields for\n\titer_, notoc_ and save_res_.\n\t(add_plt_call_entry): Set toc_.  Adjust resizing conditions for\n\t--power10-stubs=auto.\n\t(add_long_branch_entry): Set toc_.\n\t(add_eh_frame, define_stub_syms): No longer use const_iterators\n\tfor plt and long branch stub iteration.\n\t(build_tls_opt_head, build_tls_opt_tail): Change parameters and\n\treturn value.  Move tests for __tls_get_addr to callers.\n\t(plt_call_size): Handle --power10-stubs=auto.\n\t(branch_stub_size): Likewise.\n\t(Stub_table::do_write): Likewise.\n\t(relocate): Likewise.",
    "tree": {
      "sha": "655c431b1a433cdb530774e781b47077633e740e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/655c431b1a433cdb530774e781b47077633e740e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/afd2ea23626c43886ab8b028b68b7b663d6de3c6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/afd2ea23626c43886ab8b028b68b7b663d6de3c6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/afd2ea23626c43886ab8b028b68b7b663d6de3c6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/afd2ea23626c43886ab8b028b68b7b663d6de3c6/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "608d61c20245aa71875f8631bb799ee2d0372d40",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/608d61c20245aa71875f8631bb799ee2d0372d40",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/608d61c20245aa71875f8631bb799ee2d0372d40"
    }
  ],
  "stats": {
    "total": 782,
    "additions": 548,
    "deletions": 234
  },
  "files": [
    {
      "sha": "2938cdedff7f8edccc877b470771d0cb1a998101",
      "filename": "gold/ChangeLog",
      "status": "modified",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/afd2ea23626c43886ab8b028b68b7b663d6de3c6/gold/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/afd2ea23626c43886ab8b028b68b7b663d6de3c6/gold/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/ChangeLog?ref=afd2ea23626c43886ab8b028b68b7b663d6de3c6",
      "patch": "@@ -1,3 +1,28 @@\n+2020-07-27  Alan Modra  <amodra@gmail.com>\n+\n+\t* options.h (DEFINE_enum): Add optional_arg__ param, adjust\n+\tall uses.\n+\t(General_options): Add --power10-stubs and --no-power10-stubs.\n+\t* options.cc (General_options::parse_no_power10_stubs): New.\n+\t(General_options::finalize): Handle --power10-stubs.\n+\t* powerpc.cc (set_power10_stubs): Don't set when --power10-stubs=no.\n+\t(power10_stubs_auto): New.\n+\t(struct Plt_stub_ent): Add toc_ and tocoff_.  Don't use a bitfield\n+\tfor indx_.\n+\t(struct Branch_stub_ent): Add toc_and tocoff_.  Use bitfields for\n+\titer_, notoc_ and save_res_.\n+\t(add_plt_call_entry): Set toc_.  Adjust resizing conditions for\n+\t--power10-stubs=auto.\n+\t(add_long_branch_entry): Set toc_.\n+\t(add_eh_frame, define_stub_syms): No longer use const_iterators\n+\tfor plt and long branch stub iteration.\n+\t(build_tls_opt_head, build_tls_opt_tail): Change parameters and\n+\treturn value.  Move tests for __tls_get_addr to callers.\n+\t(plt_call_size): Handle --power10-stubs=auto.\n+\t(branch_stub_size): Likewise.\n+\t(Stub_table::do_write): Likewise.\n+\t(relocate): Likewise.\n+\n 2020-07-19  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* testsuite/bnd_ifunc_1.sh: Updated."
    },
    {
      "sha": "6b194374c8c458da491734bbeddc64f6b3d77905",
      "filename": "gold/options.cc",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/afd2ea23626c43886ab8b028b68b7b663d6de3c6/gold/options.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/afd2ea23626c43886ab8b028b68b7b663d6de3c6/gold/options.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/options.cc?ref=afd2ea23626c43886ab8b028b68b7b663d6de3c6",
      "patch": "@@ -464,6 +464,14 @@ General_options::parse_plugin_opt(const char*, const char* arg,\n   this->add_plugin_option(arg);\n }\n \n+void\n+General_options::parse_no_power10_stubs(const char*, const char*,\n+\t\t\t\t\tCommand_line*)\n+{\n+  this->set_power10_stubs(\"no\");\n+  this->set_user_set_power10_stubs();\n+}\n+\n void\n General_options::parse_R(const char* option, const char* arg,\n \t\t\t Command_line* cmdline)\n@@ -1183,6 +1191,27 @@ General_options::finalize()\n         this->set_start_stop_visibility_enum(elfcpp::STV_PROTECTED);\n     }\n \n+  // Parse the --power10-stubs argument.\n+  if (!this->user_set_power10_stubs())\n+    {\n+      // --power10-stubs without an arg is equivalent to --power10-stubs=yes\n+      // but not specifying --power10-stubs at all should be equivalent to\n+      // --power10-stubs=auto.  This doesn't fit into the notion of\n+      // \"default_value\", used both as a static initializer and to provide\n+      // a missing optional arg.  Fix it here.\n+      this->set_power10_stubs(\"auto\");\n+      this->set_power10_stubs_enum(POWER10_STUBS_AUTO);\n+    }\n+  else\n+    {\n+      if (strcmp(this->power10_stubs(), \"auto\") == 0)\n+\tthis->set_power10_stubs_enum(POWER10_STUBS_AUTO);\n+      else if (strcmp(this->power10_stubs(), \"no\") == 0)\n+\tthis->set_power10_stubs_enum(POWER10_STUBS_NO);\n+      else if (strcmp(this->power10_stubs(), \"yes\") == 0)\n+\tthis->set_power10_stubs_enum(POWER10_STUBS_YES);\n+    }\n+\n   // -M is equivalent to \"-Map -\".\n   if (this->print_map() && !this->user_set_Map())\n     {"
    },
    {
      "sha": "bc211151dee851d80222c9061c7535e9644ccdb3",
      "filename": "gold/options.h",
      "status": "modified",
      "additions": 37,
      "deletions": 11,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/afd2ea23626c43886ab8b028b68b7b663d6de3c6/gold/options.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/afd2ea23626c43886ab8b028b68b7b663d6de3c6/gold/options.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/options.h?ref=afd2ea23626c43886ab8b028b68b7b663d6de3c6",
      "patch": "@@ -481,9 +481,9 @@ struct Struct_special : public Struct_var\n // After helparg__ should come an initializer list, like\n //   {\"foo\", \"bar\", \"baz\"}\n #define DEFINE_enum(varname__, dashes__, shortname__, default_value__,   \\\n-\t\t    helpstring__, helparg__, ...)                        \\\n+\t\t    helpstring__, helparg__, optional_arg__, ...)        \\\n   DEFINE_var(varname__, dashes__, shortname__, default_value__,          \\\n-\t     default_value__, helpstring__, helparg__, false,\t\t \\\n+\t     default_value__, helpstring__, helparg__, optional_arg__,   \\\n \t     const char*, const char*, parse_choices_##varname__, false) \\\n  private:                                                                \\\n   static void parse_choices_##varname__(const char* option_name,         \\\n@@ -703,7 +703,7 @@ class General_options\n \t      N_(\"Use DT_NEEDED for all shared libraries\"));\n \n   DEFINE_enum(assert, options::ONE_DASH, '\\0', NULL,\n-\t      N_(\"Ignored\"), N_(\"[ignored]\"),\n+\t      N_(\"Ignored\"), N_(\"[ignored]\"), false,\n \t      {\"definitions\", \"nodefinitions\", \"nosymbolic\", \"pure-text\"});\n \n   // b\n@@ -761,7 +761,7 @@ class General_options\n \n   DEFINE_enum(compress_debug_sections, options::TWO_DASHES, '\\0', \"none\",\n \t      N_(\"Compress .debug_* sections in the output file\"),\n-\t      (\"[none,zlib,zlib-gnu,zlib-gabi]\"),\n+\t      (\"[none,zlib,zlib-gnu,zlib-gabi]\"), false,\n \t      {\"none\", \"zlib\", \"zlib-gnu\", \"zlib-gabi\"});\n \n   DEFINE_bool(copy_dt_needed_entries, options::TWO_DASHES, '\\0', false,\n@@ -934,7 +934,7 @@ class General_options\n \t\tN_(\"FRACTION\"));\n \n   DEFINE_enum(hash_style, options::TWO_DASHES, '\\0', DEFAULT_HASH_STYLE,\n-\t      N_(\"Dynamic hash style\"), N_(\"[sysv,gnu,both]\"),\n+\t      N_(\"Dynamic hash style\"), N_(\"[sysv,gnu,both]\"), false,\n \t      {\"sysv\", \"gnu\", \"both\"});\n \n   // i\n@@ -946,7 +946,7 @@ class General_options\n \t      N_(\"Identical Code Folding. \"\n \t\t \"\\'--icf=safe\\' Folds ctors, dtors and functions whose\"\n \t\t \" pointers are definitely not taken\"),\n-\t      (\"[none,all,safe]\"),\n+\t      (\"[none,all,safe]\"), false,\n \t      {\"none\", \"all\", \"safe\"});\n \n   DEFINE_uint(icf_iterations, options::TWO_DASHES , '\\0', 0,\n@@ -1086,7 +1086,7 @@ class General_options\n \n   DEFINE_enum(orphan_handling, options::TWO_DASHES, '\\0', \"place\",\n \t      N_(\"Orphan section handling\"), N_(\"[place,discard,warn,error]\"),\n-\t      {\"place\", \"discard\", \"warn\", \"error\"});\n+\t      false, {\"place\", \"discard\", \"warn\", \"error\"});\n \n   // p\n \n@@ -1141,6 +1141,12 @@ class General_options\n \t      N_(\"Use posix_fallocate to reserve space in the output file\"),\n \t      N_(\"Use fallocate or ftruncate to reserve space\"));\n \n+  DEFINE_enum(power10_stubs, options::TWO_DASHES, '\\0', \"yes\",\n+\t     N_(\"(PowerPC64 only) stubs use power10 insns\"),\n+\t     N_(\"[=auto,no,yes]\"), true, {\"auto\", \"no\", \"yes\"});\n+  DEFINE_special(no_power10_stubs, options::TWO_DASHES, '\\0',\n+\t\t N_(\"(PowerPC64 only) stubs do not use power10 insns\"), NULL);\n+\n   DEFINE_bool(preread_archive_symbols, options::TWO_DASHES, '\\0', false,\n \t      N_(\"Preread archive symbols when multi-threaded\"), NULL);\n \n@@ -1236,7 +1242,7 @@ class General_options\n   DEFINE_enum(sort_section, options::TWO_DASHES, '\\0', \"none\",\n \t      N_(\"Sort sections by name.  \\'--no-text-reorder\\'\"\n \t\t \" will override \\'--sort-section=name\\' for .text\"),\n-\t      N_(\"[none,name]\"),\n+\t      N_(\"[none,name]\"), false,\n \t      {\"none\", \"name\"});\n \n   DEFINE_uint(spare_dynamic_tags, options::TWO_DASHES, '\\0', 5,\n@@ -1287,7 +1293,7 @@ class General_options\n \t      NULL);\n   DEFINE_enum(target2, options::TWO_DASHES, '\\0', NULL,\n \t      N_(\"(ARM only) Set R_ARM_TARGET2 relocation type\"),\n-\t      N_(\"[rel, abs, got-rel\"),\n+\t      N_(\"[rel, abs, got-rel\"), false,\n \t      {\"rel\", \"abs\", \"got-rel\"});\n \n   DEFINE_bool(text_reorder, options::TWO_DASHES, '\\0', true,\n@@ -1344,7 +1350,7 @@ class General_options\n   DEFINE_enum(unresolved_symbols, options::TWO_DASHES, '\\0', NULL,\n \t      N_(\"How to handle unresolved symbols\"),\n \t      (\"ignore-all,report-all,ignore-in-object-files,\"\n-\t       \"ignore-in-shared-libs\"),\n+\t       \"ignore-in-shared-libs\"), false,\n \t      {\"ignore-all\", \"report-all\", \"ignore-in-object-files\",\n \t\t  \"ignore-in-shared-libs\"});\n \n@@ -1507,7 +1513,7 @@ class General_options\n   DEFINE_enum(start_stop_visibility, options::DASH_Z, '\\0', \"protected\",\n \t      N_(\"ELF symbol visibility for synthesized \"\n \t\t \"__start_* and __stop_* symbols\"),\n-\t      (\"[default,internal,hidden,protected]\"),\n+\t      (\"[default,internal,hidden,protected]\"), false,\n \t      {\"default\", \"internal\", \"hidden\", \"protected\"});\n   DEFINE_bool(text, options::DASH_Z, '\\0', false,\n \t      N_(\"Do not permit relocations in read-only segments\"),\n@@ -1763,6 +1769,20 @@ class General_options\n   start_stop_visibility_enum() const\n   { return this->start_stop_visibility_enum_; }\n \n+  enum Power10_stubs\n+  {\n+    // Use Power10 insns on @notoc calls/branches, non-Power10 elsewhere.\n+    POWER10_STUBS_AUTO,\n+    // Don't use Power10 insns\n+    POWER10_STUBS_NO,\n+    // Always use Power10 insns\n+    POWER10_STUBS_YES\n+  };\n+\n+  Power10_stubs\n+  power10_stubs_enum() const\n+  { return this->power10_stubs_enum_; }\n+\n  private:\n   // Don't copy this structure.\n   General_options(const General_options&);\n@@ -1826,6 +1846,10 @@ class General_options\n   set_start_stop_visibility_enum(elfcpp::STV value)\n   { this->start_stop_visibility_enum_ = value; }\n \n+  void\n+  set_power10_stubs_enum(Power10_stubs value)\n+  { this->power10_stubs_enum_ = value; }\n+\n   // These are called by finalize() to set up the search-path correctly.\n   void\n   add_to_library_path_with_sysroot(const std::string& arg)\n@@ -1895,6 +1919,8 @@ class General_options\n   Orphan_handling orphan_handling_enum_;\n   // Symbol visibility for __start_* / __stop_* magic symbols.\n   elfcpp::STV start_stop_visibility_enum_;\n+  // Power10 stubs option\n+  Power10_stubs power10_stubs_enum_;\n };\n \n // The position-dependent options.  We use this to store the state of"
    },
    {
      "sha": "d57366654997ff5b35bfba446f367afbb05c6739",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 457,
      "deletions": 223,
      "changes": 680,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/afd2ea23626c43886ab8b028b68b7b663d6de3c6/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/afd2ea23626c43886ab8b028b68b7b663d6de3c6/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=afd2ea23626c43886ab8b028b68b7b663d6de3c6",
      "patch": "@@ -1085,7 +1085,16 @@ class Target_powerpc : public Sized_target<size, big_endian>\n   void\n   set_power10_stubs()\n   {\n-    this->power10_stubs_ = true;\n+    if (parameters->options().power10_stubs_enum()\n+\t!= General_options::POWER10_STUBS_NO)\n+      this->power10_stubs_ = true;\n+  }\n+\n+  bool\n+  power10_stubs_auto() const\n+  {\n+    return (parameters->options().power10_stubs_enum()\n+\t    == General_options::POWER10_STUBS_AUTO);\n   }\n \n   bool\n@@ -4621,26 +4630,32 @@ class Stub_table : public Output_relaxed_input_section\n   struct Plt_stub_ent\n   {\n     Plt_stub_ent(unsigned int off, unsigned int indx)\n-      : off_(off), indx_(indx), iter_(0), notoc_(0), r2save_(0), localentry0_(0)\n+      : off_(off), indx_(indx), iter_(0), notoc_(0), toc_(0),\n+\tr2save_(0), localentry0_(0), tocoff_(0)\n     { }\n \n     unsigned int off_;\n-    unsigned int indx_ : 28;\n+    unsigned int indx_;\n     unsigned int iter_ : 1;\n     unsigned int notoc_ : 1;\n+    unsigned int toc_ : 1;\n     unsigned int r2save_ : 1;\n     unsigned int localentry0_ : 1;\n+    unsigned int tocoff_ : 8;\n   };\n   struct Branch_stub_ent\n   {\n     Branch_stub_ent(unsigned int off, bool notoc, bool save_res)\n-      : off_(off), iter_(false), notoc_(notoc), save_res_(save_res)\n+      : off_(off), iter_(0), notoc_(notoc), toc_(0), save_res_(save_res),\n+\ttocoff_(0)\n     { }\n \n     unsigned int off_;\n-    bool iter_;\n-    bool notoc_;\n-    bool save_res_;\n+    unsigned int iter_ : 1;\n+    unsigned int notoc_ : 1;\n+    unsigned int toc_ : 1;\n+    unsigned int save_res_ : 1;\n+    unsigned int tocoff_ : 8;\n   };\n   typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;\n   static const Address invalid_address = static_cast<Address>(0) - 1;\n@@ -4888,7 +4903,7 @@ class Stub_table : public Output_relaxed_input_section\n \n   // Size of a given plt call stub.\n   unsigned int\n-  plt_call_size(typename Plt_stub_entries::const_iterator p) const;\n+  plt_call_size(typename Plt_stub_entries::iterator p) const;\n \n   unsigned int\n   plt_call_align(unsigned int bytes) const\n@@ -4899,16 +4914,14 @@ class Stub_table : public Output_relaxed_input_section\n \n   // Return long branch stub size.\n   unsigned int\n-  branch_stub_size(typename Branch_stub_entries::const_iterator p,\n+  branch_stub_size(typename Branch_stub_entries::iterator p,\n \t\t   bool* need_lt);\n \n-  bool\n-  build_tls_opt_head(unsigned char** pp,\n-\t\t     typename Plt_stub_entries::const_iterator cs);\n+  void\n+  build_tls_opt_head(unsigned char** pp,  bool save_lr);\n \n-  bool\n-  build_tls_opt_tail(unsigned char* p,\n-\t\t     typename Plt_stub_entries::const_iterator cs);\n+  void\n+  build_tls_opt_tail(unsigned char* p);\n \n   void\n   plt_error(const Plt_stub_key& p);\n@@ -5073,15 +5086,22 @@ Stub_table<size, big_endian>::add_plt_call_entry(\n       if (r_type == elfcpp::R_PPC64_REL24_NOTOC)\n \t{\n \t  if (!p.second && !p.first->second.notoc_\n-\t      && !this->targ_->power10_stubs())\n+\t      && (!this->targ_->power10_stubs()\n+\t\t  || this->targ_->power10_stubs_auto()))\n \t    this->need_resize_ = true;\n \t  p.first->second.notoc_ = 1;\n \t}\n-      else if (!tocsave && !p.first->second.localentry0_)\n+      else\n \t{\n-\t  if (!p.second && !p.first->second.r2save_)\n+\t  if (!p.second && !p.first->second.toc_)\n \t    this->need_resize_ = true;\n-\t  p.first->second.r2save_ = 1;\n+\t  p.first->second.toc_ = 1;\n+\t  if (!tocsave && !p.first->second.localentry0_)\n+\t    {\n+\t      if (!p.second && !p.first->second.r2save_)\n+\t\tthis->need_resize_ = true;\n+\t      p.first->second.r2save_ = 1;\n+\t    }\n \t}\n     }\n   if (p.second || (this->resizing_ && !p.first->second.iter_))\n@@ -5124,15 +5144,22 @@ Stub_table<size, big_endian>::add_plt_call_entry(\n       if (r_type == elfcpp::R_PPC64_REL24_NOTOC)\n \t{\n \t  if (!p.second && !p.first->second.notoc_\n-\t      && !this->targ_->power10_stubs())\n+\t      && (!this->targ_->power10_stubs()\n+\t\t  || this->targ_->power10_stubs_auto()))\n \t    this->need_resize_ = true;\n \t  p.first->second.notoc_ = 1;\n \t}\n-      else if (!tocsave && !p.first->second.localentry0_)\n+      else\n \t{\n-\t  if (!p.second && !p.first->second.r2save_)\n+\t  if (!p.second && !p.first->second.toc_)\n \t    this->need_resize_ = true;\n-\t  p.first->second.r2save_ = 1;\n+\t  p.first->second.toc_ = 1;\n+\t  if (!tocsave && !p.first->second.localentry0_)\n+\t    {\n+\t      if (!p.second && !p.first->second.r2save_)\n+\t\tthis->need_resize_ = true;\n+\t      p.first->second.r2save_ = 1;\n+\t    }\n \t}\n     }\n   if (p.second || (this->resizing_ && !p.first->second.iter_))\n@@ -5221,11 +5248,18 @@ Stub_table<size, big_endian>::add_long_branch_entry(\n   Branch_stub_ent ent(this->branch_size_, notoc, save_res);\n   std::pair<typename Branch_stub_entries::iterator, bool> p\n     = this->long_branch_stubs_.insert(std::make_pair(key, ent));\n-  if (notoc && !p.first->second.notoc_)\n+  if (notoc)\n     {\n-      this->need_resize_ = true;\n+      if (!p.second && !p.first->second.notoc_)\n+\tthis->need_resize_ = true;\n       p.first->second.notoc_ = true;\n     }\n+  else\n+    {\n+      if (!p.second && !p.first->second.toc_)\n+\tthis->need_resize_ = true;\n+      p.first->second.toc_ = true;\n+    }\n   gold_assert(save_res == p.first->second.save_res_);\n   if (p.second || (this->resizing_ && !p.first->second.iter_))\n     {\n@@ -5320,7 +5354,7 @@ Stub_table<size, big_endian>::add_eh_frame(Layout* layout)\n   if (!this->targ_->has_glink())\n     return;\n \n-  typedef typename Plt_stub_entries::const_iterator plt_iter;\n+  typedef typename Plt_stub_entries::iterator plt_iter;\n   std::vector<plt_iter> calls;\n   if (!this->plt_call_stubs_.empty())\n     for (plt_iter cs = this->plt_call_stubs_.begin();\n@@ -5622,7 +5656,7 @@ Stub_table<size, big_endian>::define_stub_syms(Symbol_table* symtab)\n       // output .symtab ordering depends on the order in which symbols\n       // are added to the linker symtab.  We want reproducible output\n       // so must sort the call stub symbols.\n-      typedef typename Plt_stub_entries::const_iterator plt_iter;\n+      typedef typename Plt_stub_entries::iterator plt_iter;\n       std::vector<plt_iter> sorted;\n       sorted.resize(this->plt_call_stubs_.size());\n \n@@ -5666,7 +5700,7 @@ Stub_table<size, big_endian>::define_stub_syms(Symbol_table* symtab)\n \t}\n     }\n \n-  typedef typename Branch_stub_entries::const_iterator branch_iter;\n+  typedef typename Branch_stub_entries::iterator branch_iter;\n   for (branch_iter bs = this->long_branch_stubs_.begin();\n        bs != this->long_branch_stubs_.end();\n        ++bs)\n@@ -5688,88 +5722,72 @@ Stub_table<size, big_endian>::define_stub_syms(Symbol_table* symtab)\n // Emit the start of a __tls_get_addr_opt plt call stub.\n \n template<int size, bool big_endian>\n-bool\n-Stub_table<size, big_endian>::build_tls_opt_head(\n-     unsigned char** pp,\n-     typename Plt_stub_entries::const_iterator cs)\n+void\n+Stub_table<size, big_endian>::build_tls_opt_head(unsigned char** pp,\n+\t\t\t\t\t\t bool save_lr)\n {\n-  if (this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+  unsigned char* p = *pp;\n+  if (size == 64)\n     {\n-      unsigned char* p = *pp;\n-      if (size == 64)\n-\t{\n-\t  write_insn<big_endian>(p, ld_11_3 + 0);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, ld_12_3 + 8);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, mr_0_3);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, cmpdi_11_0);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, add_3_12_13);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, beqlr);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, mr_3_0);\n-\t  p += 4;\n-\t  if (cs->second.r2save_ && !cs->second.localentry0_)\n-\t    {\n-\t      write_insn<big_endian>(p, mflr_11);\n-\t      p += 4;\n-\t      write_insn<big_endian>(p, (std_11_1 + this->targ_->stk_linker()));\n-\t      p += 4;\n-\t    }\n-\t}\n-      else\n+      write_insn<big_endian>(p, ld_11_3 + 0);\n+      p += 4;\n+      write_insn<big_endian>(p, ld_12_3 + 8);\n+      p += 4;\n+      write_insn<big_endian>(p, mr_0_3);\n+      p += 4;\n+      write_insn<big_endian>(p, cmpdi_11_0);\n+      p += 4;\n+      write_insn<big_endian>(p, add_3_12_13);\n+      p += 4;\n+      write_insn<big_endian>(p, beqlr);\n+      p += 4;\n+      write_insn<big_endian>(p, mr_3_0);\n+      p += 4;\n+      if (save_lr)\n \t{\n-\t  write_insn<big_endian>(p, lwz_11_3 + 0);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, lwz_12_3 + 4);\n+\t  write_insn<big_endian>(p, mflr_11);\n \t  p += 4;\n-\t  write_insn<big_endian>(p, mr_0_3);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, cmpwi_11_0);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, add_3_12_2);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, beqlr);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, mr_3_0);\n-\t  p += 4;\n-\t  write_insn<big_endian>(p, nop);\n+\t  write_insn<big_endian>(p, (std_11_1 + this->targ_->stk_linker()));\n \t  p += 4;\n \t}\n-      *pp = p;\n-      return true;\n     }\n-  return false;\n-}\n-\n-// Emit the tail of a __tls_get_addr_opt plt call stub.\n-\n-template<int size, bool big_endian>\n-bool\n-Stub_table<size, big_endian>::build_tls_opt_tail(\n-     unsigned char* p,\n-     typename Plt_stub_entries::const_iterator cs)\n-{\n-  if (size == 64\n-      && cs->second.r2save_\n-      && !cs->second.localentry0_\n-      && this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+  else\n     {\n-      write_insn<big_endian>(p, bctrl);\n+      write_insn<big_endian>(p, lwz_11_3 + 0);\n       p += 4;\n-      write_insn<big_endian>(p, ld_2_1 + this->targ_->stk_toc());\n+      write_insn<big_endian>(p, lwz_12_3 + 4);\n       p += 4;\n-      write_insn<big_endian>(p, ld_11_1 + this->targ_->stk_linker());\n+      write_insn<big_endian>(p, mr_0_3);\n       p += 4;\n-      write_insn<big_endian>(p, mtlr_11);\n+      write_insn<big_endian>(p, cmpwi_11_0);\n+      p += 4;\n+      write_insn<big_endian>(p, add_3_12_2);\n+      p += 4;\n+      write_insn<big_endian>(p, beqlr);\n+      p += 4;\n+      write_insn<big_endian>(p, mr_3_0);\n+      p += 4;\n+      write_insn<big_endian>(p, nop);\n       p += 4;\n-      write_insn<big_endian>(p, blr);\n-      return true;\n     }\n-  return false;\n+  *pp = p;\n+}\n+\n+// Emit the tail of a __tls_get_addr_opt plt call stub.\n+\n+template<int size, bool big_endian>\n+void\n+Stub_table<size, big_endian>::build_tls_opt_tail(unsigned char* p)\n+{\n+  write_insn<big_endian>(p, bctrl);\n+  p += 4;\n+  write_insn<big_endian>(p, ld_2_1 + this->targ_->stk_toc());\n+  p += 4;\n+  write_insn<big_endian>(p, ld_11_1 + this->targ_->stk_linker());\n+  p += 4;\n+  write_insn<big_endian>(p, mtlr_11);\n+  p += 4;\n+  write_insn<big_endian>(p, blr);\n }\n \n // Emit pc-relative plt call stub code.\n@@ -5939,7 +5957,7 @@ build_notoc_offset(unsigned char* p, uint64_t off, bool load)\n template<int size, bool big_endian>\n unsigned int\n Stub_table<size, big_endian>::plt_call_size(\n-    typename Plt_stub_entries::const_iterator p) const\n+    typename Plt_stub_entries::iterator p) const\n {\n   if (size == 32)\n     {\n@@ -5951,85 +5969,130 @@ Stub_table<size, big_endian>::plt_call_size(\n   const Output_data_plt_powerpc<size, big_endian>* plt;\n   uint64_t plt_addr = this->plt_off(p, &plt);\n   plt_addr += plt->address();\n-  unsigned int bytes = 0;\n-  const Symbol* gsym = p->first.sym_;\n-  if (this->targ_->is_tls_get_addr_opt(gsym))\n+  if (this->targ_->power10_stubs()\n+      && this->targ_->power10_stubs_auto())\n     {\n-      if (p->second.r2save_ && !p->second.localentry0_)\n-\tbytes = 13 * 4;\n-      else\n-\tbytes = 7 * 4;\n+      unsigned int bytes = 0;\n+      if (p->second.notoc_)\n+\t{\n+\t  if (this->targ_->is_tls_get_addr_opt(p->first.sym_))\n+\t    bytes = 7 * 4;\n+\t  uint64_t from = this->stub_address() + p->second.off_ + bytes;\n+\t  uint64_t odd = from & 4;\n+\t  uint64_t off = plt_addr - from;\n+\t  if (off - odd + (1ULL << 33) < 1ULL << 34)\n+\t    bytes += odd + 4 * 4;\n+\t  else if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n+\t    bytes += 7 * 4;\n+\t  else\n+\t    bytes += 8 * 4;\n+\t  bytes = this->plt_call_align(bytes);\n+\t}\n+      unsigned int tail = 0;\n+      if (p->second.toc_)\n+\t{\n+\t  p->second.tocoff_ = bytes;\n+\t  if (this->targ_->is_tls_get_addr_opt(p->first.sym_))\n+\t    {\n+\t      bytes += 7 * 4;\n+\t      if (p->second.r2save_ && !p->second.localentry0_)\n+\t\t{\n+\t\t  bytes += 2 * 4;\n+\t\t  tail = 4 * 4;\n+\t\t}\n+\t    }\n+\t  if (p->second.r2save_)\n+\t    bytes += 4;\n+\t  uint64_t got_addr\n+\t    = this->targ_->got_section()->output_section()->address();\n+\t  const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n+\t    <const Powerpc_relobj<size, big_endian>*>(p->first.object_);\n+\t  got_addr += ppcobj->toc_base_offset();\n+\t  uint64_t off = plt_addr - got_addr;\n+\t  bytes += 3 * 4 + 4 * (ha(off) != 0);\n+\t}\n+      return bytes + tail;\n     }\n+  else\n+    {\n+      unsigned int bytes = 0;\n+      unsigned int tail = 0;\n+      if (this->targ_->is_tls_get_addr_opt(p->first.sym_))\n+\t{\n+\t  bytes = 7 * 4;\n+\t  if (p->second.r2save_ && !p->second.localentry0_)\n+\t    {\n+\t      bytes = 9 * 4;\n+\t      tail = 4 * 4;\n+\t    }\n+\t}\n \n-  if (p->second.r2save_)\n-    bytes += 4;\n+      if (p->second.r2save_)\n+\tbytes += 4;\n \n-  if (this->targ_->power10_stubs())\n-    {\n-      uint64_t from = this->stub_address() + p->second.off_ + bytes;\n-      if (bytes > 8 * 4)\n-\tfrom -= 4 * 4;\n-      uint64_t odd = from & 4;\n-      uint64_t off = plt_addr - from;\n-      if (off - odd + (1ULL << 33) < 1ULL << 34)\n-\tbytes += odd + 4 * 4;\n-      else if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n-\tbytes += 7 * 4;\n-      else\n-\tbytes += 8 * 4;\n-      return bytes;\n-    }\n+      if (this->targ_->power10_stubs())\n+\t{\n+\t  uint64_t from = this->stub_address() + p->second.off_ + bytes;\n+\t  uint64_t odd = from & 4;\n+\t  uint64_t off = plt_addr - from;\n+\t  if (off - odd + (1ULL << 33) < 1ULL << 34)\n+\t    bytes += odd + 4 * 4;\n+\t  else if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n+\t    bytes += 7 * 4;\n+\t  else\n+\t    bytes += 8 * 4;\n+\t  return bytes + tail;\n+\t}\n \n-  if (p->second.notoc_)\n-    {\n-      uint64_t from = this->stub_address() + p->second.off_ + bytes + 2 * 4;\n-      if (bytes > 32)\n-\tfrom -= 4 * 4;\n-      uint64_t off = plt_addr - from;\n-      if (off + 0x8000 < 0x10000)\n-\tbytes += 7 * 4;\n-      else if (off + 0x80008000ULL < 0x100000000ULL)\n-\tbytes += 8 * 4;\n-      else\n+      if (p->second.notoc_)\n \t{\n-\t  bytes += 8 * 4;\n-\t  if (off + 0x800000000000ULL >= 0x1000000000000ULL\n-\t      && ((off >> 32) & 0xffff) != 0)\n-\t    bytes += 4;\n-\t  if (((off >> 32) & 0xffffffffULL) != 0)\n-\t    bytes += 4;\n-\t  if (hi(off) != 0)\n-\t    bytes += 4;\n-\t  if (l(off) != 0)\n-\t    bytes += 4;\n+\t  uint64_t from = this->stub_address() + p->second.off_ + bytes + 2 * 4;\n+\t  uint64_t off = plt_addr - from;\n+\t  if (off + 0x8000 < 0x10000)\n+\t    bytes += 7 * 4;\n+\t  else if (off + 0x80008000ULL < 0x100000000ULL)\n+\t    bytes += 8 * 4;\n+\t  else\n+\t    {\n+\t      bytes += 8 * 4;\n+\t      if (off + 0x800000000000ULL >= 0x1000000000000ULL\n+\t\t  && ((off >> 32) & 0xffff) != 0)\n+\t\tbytes += 4;\n+\t      if (((off >> 32) & 0xffffffffULL) != 0)\n+\t\tbytes += 4;\n+\t      if (hi(off) != 0)\n+\t\tbytes += 4;\n+\t      if (l(off) != 0)\n+\t\tbytes += 4;\n+\t    }\n+\t  return bytes + tail;\n \t}\n-      return bytes;\n-    }\n \n-  uint64_t got_addr = this->targ_->got_section()->output_section()->address();\n-  const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n-    <const Powerpc_relobj<size, big_endian>*>(p->first.object_);\n-  got_addr += ppcobj->toc_base_offset();\n-  uint64_t off = plt_addr - got_addr;\n-  bytes += 3 * 4 + 4 * (ha(off) != 0);\n-  if (this->targ_->abiversion() < 2)\n-    {\n-      bool static_chain = parameters->options().plt_static_chain();\n-      bool thread_safe = this->targ_->plt_thread_safe();\n-      bytes += (4\n-\t\t+ 4 * static_chain\n-\t\t+ 8 * thread_safe\n-\t\t+ 4 * (ha(off + 8 + 8 * static_chain) != ha(off)));\n+      uint64_t got_addr = this->targ_->got_section()->output_section()->address();\n+      const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n+\t<const Powerpc_relobj<size, big_endian>*>(p->first.object_);\n+      got_addr += ppcobj->toc_base_offset();\n+      uint64_t off = plt_addr - got_addr;\n+      bytes += 3 * 4 + 4 * (ha(off) != 0);\n+      if (this->targ_->abiversion() < 2)\n+\t{\n+\t  bool static_chain = parameters->options().plt_static_chain();\n+\t  bool thread_safe = this->targ_->plt_thread_safe();\n+\t  bytes += (4\n+\t\t    + 4 * static_chain\n+\t\t    + 8 * thread_safe\n+\t\t    + 4 * (ha(off + 8 + 8 * static_chain) != ha(off)));\n+\t}\n+      return bytes + tail;\n     }\n-  return bytes;\n }\n \n // Return long branch stub size.\n \n template<int size, bool big_endian>\n unsigned int\n Stub_table<size, big_endian>::branch_stub_size(\n-     typename Branch_stub_entries::const_iterator p,\n+     typename Branch_stub_entries::iterator p,\n      bool* need_lt)\n {\n   Address loc = this->stub_address() + this->last_plt_size_ + p->second.off_;\n@@ -6043,46 +6106,56 @@ Stub_table<size, big_endian>::branch_stub_size(\n     }\n \n   uint64_t off = p->first.dest_ - loc;\n+  unsigned int bytes = 0;\n   if (p->second.notoc_)\n     {\n       if (this->targ_->power10_stubs())\n \t{\n \t  Address odd = loc & 4;\n \t  if (off + (1 << 25) < 2 << 25)\n-\t    return odd + 12;\n-\t  if (off - odd + (1ULL << 33) < 1ULL << 34)\n-\t    return odd + 16;\n-\t  if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n-\t    return 28;\n-\t  return 32;\n-\t}\n-      off -= 8;\n-      if (off + 0x8000 < 0x10000)\n-\treturn 24;\n-      if (off + 0x80008000ULL < 0x100000000ULL)\n-\t{\n-\t  if (off + 24 + (1 << 25) < 2 << 25)\n-\t    return 28;\n-\t  return 32;\n-\t}\n-      unsigned int bytes = 32;\n-      if (off + 0x800000000000ULL >= 0x1000000000000ULL\n-\t  && ((off >> 32) & 0xffff) != 0)\n-\tbytes += 4;\n-      if (((off >> 32) & 0xffffffffULL) != 0)\n-\tbytes += 4;\n-      if (hi(off) != 0)\n-\tbytes += 4;\n-      if (l(off) != 0)\n-\tbytes += 4;\n-      return bytes;\n+\t    bytes = odd + 12;\n+\t  else if (off - odd + (1ULL << 33) < 1ULL << 34)\n+\t    bytes = odd + 16;\n+\t  else if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n+\t    bytes = 28;\n+\t  else\n+\t    bytes = 32;\n+\t  if (!(p->second.toc_ && this->targ_->power10_stubs_auto()))\n+\t    return bytes;\n+\t  p->second.tocoff_ = bytes;\n+\t}\n+      else\n+\t{\n+\t  off -= 8;\n+\t  if (off + 0x8000 < 0x10000)\n+\t    return 24;\n+\t  if (off + 0x80008000ULL < 0x100000000ULL)\n+\t    {\n+\t      if (off + 24 + (1 << 25) < 2 << 25)\n+\t\treturn 28;\n+\t      return 32;\n+\t    }\n+\n+\t  bytes = 32;\n+\t  if (off + 0x800000000000ULL >= 0x1000000000000ULL\n+\t      && ((off >> 32) & 0xffff) != 0)\n+\t    bytes += 4;\n+\t  if (((off >> 32) & 0xffffffffULL) != 0)\n+\t    bytes += 4;\n+\t  if (hi(off) != 0)\n+\t    bytes += 4;\n+\t  if (l(off) != 0)\n+\t    bytes += 4;\n+\t  return bytes;\n+\t}\n     }\n \n   if (off + (1 << 25) < 2 << 25)\n-    return 4;\n-  if (!this->targ_->power10_stubs())\n+    return bytes + 4;\n+  if (!this->targ_->power10_stubs()\n+      || (p->second.toc_ && this->targ_->power10_stubs_auto()))\n     *need_lt = true;\n-  return 16;\n+  return bytes + 16;\n }\n \n template<int size, bool big_endian>\n@@ -6118,6 +6191,10 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n   if (size == 64\n       && this->targ_->power10_stubs())\n     {\n+      const Output_data_got_powerpc<size, big_endian>* got\n+\t= this->targ_->got_section();\n+      Address got_os_addr = got->output_section()->address();\n+\n       if (!this->plt_call_stubs_.empty())\n \t{\n \t  // Write out plt call stubs.\n@@ -6127,22 +6204,94 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t       ++cs)\n \t    {\n \t      p = oview + cs->second.off_;\n-\t      this->build_tls_opt_head(&p, cs);\n-\t      if (cs->second.r2save_)\n-\t\t{\n-\t\t  write_insn<big_endian>(p, std_2_1 + this->targ_->stk_toc());\n-\t\t  p += 4;\n-\t\t}\n \t      const Output_data_plt_powerpc<size, big_endian>* plt;\n \t      Address pltoff = this->plt_off(cs, &plt);\n \t      Address plt_addr = pltoff + plt->address();\n-\t      Address from = this->stub_address() + (p - oview);\n-\t      Address delta = plt_addr - from;\n-\t      p = build_power10_offset<big_endian>(p, delta, from & 4, true);\n-\t      write_insn<big_endian>(p, mtctr_12);\n-\t      p += 4;\n-\t      if (!this->build_tls_opt_tail(p, cs))\n-\t\twrite_insn<big_endian>(p, bctr);\n+\t      if (this->targ_->power10_stubs_auto())\n+\t\t{\n+\t\t  if (cs->second.notoc_)\n+\t\t    {\n+\t\t      if (this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\t\tthis->build_tls_opt_head(&p, false);\n+\t\t      Address from = this->stub_address() + (p - oview);\n+\t\t      Address delta = plt_addr - from;\n+\t\t      p = build_power10_offset<big_endian>(p, delta, from & 4,\n+\t\t\t\t\t\t\t   true);\n+\t\t      write_insn<big_endian>(p, mtctr_12);\n+\t\t      p += 4;\n+\t\t      write_insn<big_endian>(p, bctr);\n+\t\t      p += 4;\n+\t\t      p = oview + this->plt_call_align(p - oview);\n+\t\t    }\n+\t\t  if (cs->second.toc_)\n+\t\t    {\n+\t\t      if (this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\t\t{\n+\t\t\t  bool save_lr\n+\t\t\t    = cs->second.r2save_ && !cs->second.localentry0_;\n+\t\t\t  this->build_tls_opt_head(&p, save_lr);\n+\t\t\t}\n+\t\t      const Powerpc_relobj<size, big_endian>* ppcobj\n+\t\t\t= static_cast<const Powerpc_relobj<size, big_endian>*>(\n+\t\t\t    cs->first.object_);\n+\t\t      Address got_addr = got_os_addr + ppcobj->toc_base_offset();\n+\t\t      Address off = plt_addr - got_addr;\n+\n+\t\t      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)\n+\t\t\tthis->plt_error(cs->first);\n+\n+\t\t      if (cs->second.r2save_)\n+\t\t\t{\n+\t\t\t  write_insn<big_endian>(p, std_2_1 + this->targ_->stk_toc());\n+\t\t\t  p += 4;\n+\t\t\t}\n+\t\t      if (ha(off) != 0)\n+\t\t\t{\n+\t\t\t  write_insn<big_endian>(p, addis_12_2 + ha(off));\n+\t\t\t  p += 4;\n+\t\t\t  write_insn<big_endian>(p, ld_12_12 + l(off));\n+\t\t\t  p += 4;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  write_insn<big_endian>(p, ld_12_2 + l(off));\n+\t\t\t  p += 4;\n+\t\t\t}\n+\t\t      write_insn<big_endian>(p, mtctr_12);\n+\t\t      p += 4;\n+\t\t      if (cs->second.r2save_\n+\t\t\t  && !cs->second.localentry0_\n+\t\t\t  && this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\t\tthis->build_tls_opt_tail(p);\n+\t\t      else\n+\t\t\twrite_insn<big_endian>(p, bctr);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\t    {\n+\t\t      bool save_lr\n+\t\t\t= cs->second.r2save_ && !cs->second.localentry0_;\n+\t\t      this->build_tls_opt_head(&p, save_lr);\n+\t\t    }\n+\t\t  if (cs->second.r2save_)\n+\t\t    {\n+\t\t      write_insn<big_endian>(p, std_2_1 + this->targ_->stk_toc());\n+\t\t      p += 4;\n+\t\t    }\n+\t\t  Address from = this->stub_address() + (p - oview);\n+\t\t  Address delta = plt_addr - from;\n+\t\t  p = build_power10_offset<big_endian>(p, delta, from & 4, true);\n+\t\t  write_insn<big_endian>(p, mtctr_12);\n+\t\t  p += 4;\n+\t\t  if (cs->second.r2save_\n+\t\t      && !cs->second.localentry0_\n+\t\t      && this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\t    this->build_tls_opt_tail(p);\n+\t\t  else\n+\t\t    write_insn<big_endian>(p, bctr);\n+\t\t}\n \t    }\n \t}\n \n@@ -6158,19 +6307,76 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t  p = oview + off;\n \t  Address loc = this->stub_address() + off;\n \t  Address delta = bs->first.dest_ - loc;\n-\t  if (bs->second.notoc_ || delta + (1 << 25) >= 2 << 25)\n+\t  if (this->targ_->power10_stubs_auto())\n \t    {\n-\t      unsigned char* startp = p;\n-\t      p = build_power10_offset<big_endian>(p, delta, loc & 4, false);\n-\t      delta -= p - startp;\n+\t      if (bs->second.notoc_)\n+\t\t{\n+\t\t  unsigned char* startp = p;\n+\t\t  p = build_power10_offset<big_endian>(p, delta,\n+\t\t\t\t\t\t       loc & 4, false);\n+\t\t  delta -= p - startp;\n+\t\t  startp = p;\n+\t\t  if (delta + (1 << 25) < 2 << 25)\n+\t\t    write_insn<big_endian>(p, b | (delta & 0x3fffffc));\n+\t\t  else\n+\t\t    {\n+\t\t      write_insn<big_endian>(p, mtctr_12);\n+\t\t      p += 4;\n+\t\t      write_insn<big_endian>(p, bctr);\n+\t\t    }\n+\t\t  p += 4;\n+\t\t  delta -= p - startp;\n+\t\t}\n+\t      if (bs->second.toc_)\n+\t\t{\n+\t\t  if (delta + (1 << 25) >= 2 << 25)\n+\t\t    {\n+\t\t      Address brlt_addr\n+\t\t\t= this->targ_->find_branch_lookup_table(bs->first.dest_);\n+\t\t      gold_assert(brlt_addr != invalid_address);\n+\t\t      brlt_addr += this->targ_->brlt_section()->address();\n+\t\t      Address got_addr = got_os_addr + bs->first.toc_base_off_;\n+\t\t      Address brltoff = brlt_addr - got_addr;\n+\t\t      if (ha(brltoff) == 0)\n+\t\t\t{\n+\t\t\t  write_insn<big_endian>(p, ld_12_2 + l(brltoff));\n+\t\t\t  p += 4;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  write_insn<big_endian>(p, addis_12_2 + ha(brltoff));\n+\t\t\t  p += 4;\n+\t\t\t  write_insn<big_endian>(p, ld_12_12 + l(brltoff));\n+\t\t\t  p += 4;\n+\t\t\t}\n+\t\t    }\n+\t\t  if (delta + (1 << 25) < 2 << 25)\n+\t\t    write_insn<big_endian>(p, b | (delta & 0x3fffffc));\n+\t\t  else\n+\t\t    {\n+\t\t      write_insn<big_endian>(p, mtctr_12);\n+\t\t      p += 4;\n+\t\t      write_insn<big_endian>(p, bctr);\n+\t\t    }\n+\t\t}\n \t    }\n-\t  if (delta + (1 << 25) < 2 << 25)\n-\t    write_insn<big_endian>(p, b | (delta & 0x3fffffc));\n \t  else\n \t    {\n-\t      write_insn<big_endian>(p, mtctr_12);\n-\t      p += 4;\n-\t      write_insn<big_endian>(p, bctr);\n+\t      if (bs->second.notoc_ || delta + (1 << 25) >= 2 << 25)\n+\t\t{\n+\t\t  unsigned char* startp = p;\n+\t\t  p = build_power10_offset<big_endian>(p, delta,\n+\t\t\t\t\t\t       loc & 4, false);\n+\t\t  delta -= p - startp;\n+\t\t}\n+\t      if (delta + (1 << 25) < 2 << 25)\n+\t\twrite_insn<big_endian>(p, b | (delta & 0x3fffffc));\n+\t      else\n+\t\t{\n+\t\t  write_insn<big_endian>(p, mtctr_12);\n+\t\t  p += 4;\n+\t\t  write_insn<big_endian>(p, bctr);\n+\t\t}\n \t    }\n \t}\n     }\n@@ -6194,7 +6400,11 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t      Address plt_addr = pltoff + plt->address();\n \n \t      p = oview + cs->second.off_;\n-\t      this->build_tls_opt_head(&p, cs);\n+\t      if (this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\t{\n+\t\t  bool save_lr = cs->second.r2save_ && !cs->second.localentry0_;\n+\t\t  this->build_tls_opt_head(&p, save_lr);\n+\t\t}\n \t      if (cs->second.r2save_)\n \t\t{\n \t\t  write_insn<big_endian>(p, std_2_1 + this->targ_->stk_toc());\n@@ -6231,7 +6441,11 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t}\n \t      write_insn<big_endian>(p, mtctr_12);\n \t      p += 4;\n-\t      if (!this->build_tls_opt_tail(p, cs))\n+\t      if (cs->second.r2save_\n+\t\t  && !cs->second.localentry0_\n+\t\t  && this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\tthis->build_tls_opt_tail(p);\n+\t      else\n \t\twrite_insn<big_endian>(p, bctr);\n \t    }\n \t}\n@@ -6282,8 +6496,12 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t}\n \n \t      p = oview + cs->second.off_;\n-\t      if (this->build_tls_opt_head(&p, cs))\n-\t\tuse_fake_dep = thread_safe;\n+\t      if (this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\t{\n+\t\t  bool save_lr = cs->second.r2save_ && !cs->second.localentry0_;\n+\t\t  this->build_tls_opt_head(&p, save_lr);\n+\t\t  use_fake_dep = thread_safe;\n+\t\t}\n \t      if (cs->second.r2save_)\n \t\t{\n \t\t  write_insn<big_endian>(p, std_2_1 + this->targ_->stk_toc());\n@@ -6345,8 +6563,10 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t  write_insn<big_endian>(p, ld_2_2 + l(off + 8));\n \t\t  p += 4;\n \t\t}\n-\t      if (this->build_tls_opt_tail(p, cs))\n-\t\t;\n+\t      if (cs->second.r2save_\n+\t\t  && !cs->second.localentry0_\n+\t\t  && this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\tthis->build_tls_opt_tail(p);\n \t      else if (thread_safe && !use_fake_dep)\n \t\t{\n \t\t  write_insn<big_endian>(p, cmpldi_2_0);\n@@ -6427,7 +6647,8 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t      plt_addr += plt->address();\n \n \t      p = oview + cs->second.off_;\n-\t      this->build_tls_opt_head(&p, cs);\n+\t      if (this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+\t\tthis->build_tls_opt_head(&p, false);\n \t      if (parameters->options().output_is_position_independent())\n \t\t{\n \t\t  Address got_addr;\n@@ -10087,10 +10308,17 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t\t  const int reloc_size = elfcpp::Elf_sizes<size>::rela_size;\n \t\t  elfcpp::Shdr<size, big_endian> shdr(relinfo->reloc_shdr);\n \t\t  size_t reloc_count = shdr.get_sh_size() / reloc_size;\n+\t\t  if (size == 64\n+\t\t      && r_type != elfcpp::R_PPC64_REL24_NOTOC)\n+\t\t    value += ent->tocoff_;\n \t\t  if (size == 64\n \t\t      && ent->r2save_\n \t\t      && r_type == elfcpp::R_PPC64_REL24_NOTOC)\n-\t\t    value += 4;\n+\t\t    {\n+\t\t      if (!(target->power10_stubs()\n+\t\t\t    && target->power10_stubs_auto()))\n+\t\t\tvalue += 4;\n+\t\t    }\n \t\t  else if (size == 64\n \t\t\t   && ent->r2save_\n \t\t\t   && relnum < reloc_count - 1)\n@@ -10707,8 +10935,14 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t\t    value = (value - target->savres_section()->address()\n \t\t\t     + stub_table->branch_size());\n \t\t  else\n-\t\t    value = (stub_table->stub_address() + stub_table->plt_size()\n-\t\t\t     + ent->off_);\n+\t\t    {\n+\t\t      value = (stub_table->stub_address()\n+\t\t\t       + stub_table->plt_size()\n+\t\t\t       + ent->off_);\n+\t\t      if (size == 64\n+\t\t\t  && r_type != elfcpp::R_PPC64_REL24_NOTOC)\n+\t\t\tvalue += ent->tocoff_;\n+\t\t    }\n \t\t  has_stub_value = true;\n \t\t}\n \t    }"
    }
  ]
}