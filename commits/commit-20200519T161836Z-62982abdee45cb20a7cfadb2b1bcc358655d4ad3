{
  "sha": "62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjI5ODJhYmRlZTQ1Y2IyMGE3Y2ZhZGIyYjFiY2MzNTg2NTVkNGFkMw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-19T16:18:04Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-19T16:18:36Z"
    },
    "message": "gdb: allocate symfile_segment_data with new\n\n- Allocate this structure with new instead of XNEW, use a unique pointer\n  to manage its lifetime.\n- Change a few functions to return a unique   pointer instead of a\n  plain pointer.\n- Change free_symfile_segment_data to be symfile_segment_data's\n  destructor.\n\ngdb/ChangeLog:\n\n\t* symfile.h (struct symfile_segment_data): Initialize fields.\n\t<~symfile_segment_data>: Add.\n\t(symfile_segment_data_up): New.\n\t(struct sym_fns) <sym_segments>: Return a\n\tsymfile_segment_data_up.\n\t(default_symfile_segments): Return a symfile_segment_data_up.\n\t(free_symfile_segment_data): Remove.\n\t(get_symfile_segment_data): Return a symfile_segment_data_up.\n\t* symfile.c (default_symfile_segments): Likewise.\n\t(get_symfile_segment_data): Likewise.\n\t(free_symfile_segment_data): Remove.\n\t(symfile_find_segment_sections): Update.\n\t* elfread.c (elf_symfile_segments): Return a\n\tsymfile_segment_data_up.\n\t* remote.c (remote_target::get_offsets): Update.\n\t* solib-target.c (solib_target_relocate_section_addresses):\n\tUpdate.\n\t* symfile-debug.c (debug_sym_segments): Return a\n\tsymfile_segment_data_up.",
    "tree": {
      "sha": "e4b4bc04a83dfc55cecc865b20ad561f8ec13939",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e4b4bc04a83dfc55cecc865b20ad561f8ec13939"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8ac10c5bfca0602398b38cc69976db213a7d9917",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ac10c5bfca0602398b38cc69976db213a7d9917",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8ac10c5bfca0602398b38cc69976db213a7d9917"
    }
  ],
  "stats": {
    "total": 100,
    "additions": 55,
    "deletions": 45
  },
  "files": [
    {
      "sha": "ac9e1ccccaad6460a2b9fc6dc6ee52fd6c6cab4c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "patch": "@@ -1,3 +1,25 @@\n+2020-05-19  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* symfile.h (struct symfile_segment_data): Initialize fields.\n+\t<~symfile_segment_data>: Add.\n+\t(symfile_segment_data_up): New.\n+\t(struct sym_fns) <sym_segments>: Return a\n+\tsymfile_segment_data_up.\n+\t(default_symfile_segments): Return a symfile_segment_data_up.\n+\t(free_symfile_segment_data): Remove.\n+\t(get_symfile_segment_data): Return a symfile_segment_data_up.\n+\t* symfile.c (default_symfile_segments): Likewise.\n+\t(get_symfile_segment_data): Likewise.\n+\t(free_symfile_segment_data): Remove.\n+\t(symfile_find_segment_sections): Update.\n+\t* elfread.c (elf_symfile_segments): Return a\n+\tsymfile_segment_data_up.\n+\t* remote.c (remote_target::get_offsets): Update.\n+\t* solib-target.c (solib_target_relocate_section_addresses):\n+\tUpdate.\n+\t* symfile-debug.c (debug_sym_segments): Return a\n+\tsymfile_segment_data_up.\n+\n 2020-05-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR build/25981"
    },
    {
      "sha": "4804d62074c47d10ec3ec65b477060a149f02355",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "patch": "@@ -85,14 +85,13 @@ static const struct bfd_key<elfread_data> probe_key;\n \n /* Locate the segments in ABFD.  */\n \n-static struct symfile_segment_data *\n+static symfile_segment_data_up\n elf_symfile_segments (bfd *abfd)\n {\n   Elf_Internal_Phdr *phdrs, **segments;\n   long phdrs_size;\n   int num_phdrs, num_segments, num_sections, i;\n   asection *sect;\n-  struct symfile_segment_data *data;\n \n   phdrs_size = bfd_get_elf_phdr_upper_bound (abfd);\n   if (phdrs_size == -1)\n@@ -112,7 +111,7 @@ elf_symfile_segments (bfd *abfd)\n   if (num_segments == 0)\n     return NULL;\n \n-  data = XCNEW (struct symfile_segment_data);\n+  symfile_segment_data_up data (new symfile_segment_data);\n   data->num_segments = num_segments;\n   data->segment_bases = XCNEWVEC (CORE_ADDR, num_segments);\n   data->segment_sizes = XCNEWVEC (CORE_ADDR, num_segments);"
    },
    {
      "sha": "a28f34d157a90f699b77806d148e529d468b7150",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "patch": "@@ -4105,7 +4105,6 @@ remote_target::get_offsets ()\n   char *ptr;\n   int lose, num_segments = 0, do_sections, do_segments;\n   CORE_ADDR text_addr, data_addr, bss_addr, segments[2];\n-  struct symfile_segment_data *data;\n \n   if (symfile_objfile == NULL)\n     return;\n@@ -4185,7 +4184,8 @@ remote_target::get_offsets ()\n \n   section_offsets offs = symfile_objfile->section_offsets;\n \n-  data = get_symfile_segment_data (symfile_objfile->obfd);\n+  symfile_segment_data_up data\n+    = get_symfile_segment_data (symfile_objfile->obfd);\n   do_segments = (data != NULL);\n   do_sections = num_segments == 0;\n \n@@ -4220,8 +4220,9 @@ remote_target::get_offsets ()\n \n   if (do_segments)\n     {\n-      int ret = symfile_map_offsets_to_segments (symfile_objfile->obfd, data,\n-\t\t\t\t\t\t offs, num_segments, segments);\n+      int ret = symfile_map_offsets_to_segments (symfile_objfile->obfd,\n+\t\t\t\t\t\t data.get (), offs,\n+\t\t\t\t\t\t num_segments, segments);\n \n       if (ret == 0 && !do_sections)\n \terror (_(\"Can not handle qOffsets TextSeg \"\n@@ -4231,9 +4232,6 @@ remote_target::get_offsets ()\n \tdo_sections = 0;\n     }\n \n-  if (data)\n-    free_symfile_segment_data (data);\n-\n   if (do_sections)\n     {\n       offs[SECT_OFF_TEXT (symfile_objfile)] = text_addr;"
    },
    {
      "sha": "35e50a3e00b4d371bc2d318ccb89ff918253d373",
      "filename": "gdb/solib-target.c",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/solib-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/solib-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-target.c?ref=62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "patch": "@@ -364,9 +364,9 @@ Could not relocate shared library \\\"%s\\\": wrong number of ALLOC sections\"),\n \t}\n       else if (!li->segment_bases.empty ())\n \t{\n-\t  struct symfile_segment_data *data;\n+\t  symfile_segment_data_up data\n+\t    = get_symfile_segment_data (so->abfd);\n \n-\t  data = get_symfile_segment_data (so->abfd);\n \t  if (data == NULL)\n \t    warning (_(\"\\\n Could not relocate shared library \\\"%s\\\": no segments\"), so->so_name);\n@@ -375,7 +375,7 @@ Could not relocate shared library \\\"%s\\\": no segments\"), so->so_name);\n \t      ULONGEST orig_delta;\n \t      int i;\n \n-\t      if (!symfile_map_offsets_to_segments (so->abfd, data,\n+\t      if (!symfile_map_offsets_to_segments (so->abfd, data.get (),\n \t\t\t\t\t\t    li->offsets,\n \t\t\t\t\t\t    li->segment_bases.size (),\n \t\t\t\t\t\t    li->segment_bases.data ()))\n@@ -407,8 +407,6 @@ Could not relocate shared library \\\"%s\\\": bad offsets\"), so->so_name);\n \t\t\t       + data->segment_sizes[i - 1]\n \t\t\t       + orig_delta);\n \t      gdb_assert (so->addr_low <= so->addr_high);\n-\n-\t      free_symfile_segment_data (data);\n \t    }\n \t}\n     }"
    },
    {
      "sha": "bd806fdfee454f879f4bdf1d8851b22d4b2f88d8",
      "filename": "gdb/symfile-debug.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/symfile-debug.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/symfile-debug.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile-debug.c?ref=62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "patch": "@@ -475,7 +475,7 @@ debug_sym_offsets (struct objfile *objfile,\n   debug_data->real_sf->sym_offsets (objfile, info);\n }\n \n-static struct symfile_segment_data *\n+static symfile_segment_data_up\n debug_sym_segments (bfd *abfd)\n {\n   /* This API function is annoying, it doesn't take a \"this\" pointer."
    },
    {
      "sha": "9d5e2824b2a7ebd92a3ee6c86f85662b77375944",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 6,
      "deletions": 21,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "patch": "@@ -717,12 +717,11 @@ default_symfile_offsets (struct objfile *objfile,\n    It assumes that object files do not have segments, and fully linked\n    files have a single segment.  */\n \n-struct symfile_segment_data *\n+symfile_segment_data_up\n default_symfile_segments (bfd *abfd)\n {\n   int num_sections, i;\n   asection *sect;\n-  struct symfile_segment_data *data;\n   CORE_ADDR low, high;\n \n   /* Relocatable files contain enough information to position each\n@@ -745,7 +744,7 @@ default_symfile_segments (bfd *abfd)\n   low = bfd_section_vma (sect);\n   high = low + bfd_section_size (sect);\n \n-  data = XCNEW (struct symfile_segment_data);\n+  symfile_segment_data_up data (new symfile_segment_data);\n   data->num_segments = 1;\n   data->segment_bases = XCNEW (CORE_ADDR);\n   data->segment_sizes = XCNEW (CORE_ADDR);\n@@ -3621,7 +3620,7 @@ symfile_relocate_debug_section (struct objfile *objfile,\n   return (*objfile->sf->sym_relocate) (objfile, sectp, buf);\n }\n \n-struct symfile_segment_data *\n+symfile_segment_data_up\n get_symfile_segment_data (bfd *abfd)\n {\n   const struct sym_fns *sf = find_sym_fns (abfd);\n@@ -3632,15 +3631,6 @@ get_symfile_segment_data (bfd *abfd)\n   return sf->sym_segments (abfd);\n }\n \n-void\n-free_symfile_segment_data (struct symfile_segment_data *data)\n-{\n-  xfree (data->segment_bases);\n-  xfree (data->segment_sizes);\n-  xfree (data->segment_info);\n-  xfree (data);\n-}\n-\n /* Given:\n    - DATA, containing segment addresses from the object file ABFD, and\n      the mapping from ABFD's sections onto the segments that own them,\n@@ -3703,17 +3693,14 @@ symfile_find_segment_sections (struct objfile *objfile)\n   bfd *abfd = objfile->obfd;\n   int i;\n   asection *sect;\n-  struct symfile_segment_data *data;\n \n-  data = get_symfile_segment_data (objfile->obfd);\n+  symfile_segment_data_up data\n+    = get_symfile_segment_data (objfile->obfd);\n   if (data == NULL)\n     return;\n \n   if (data->num_segments != 1 && data->num_segments != 2)\n-    {\n-      free_symfile_segment_data (data);\n-      return;\n-    }\n+    return;\n \n   for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)\n     {\n@@ -3736,8 +3723,6 @@ symfile_find_segment_sections (struct objfile *objfile)\n \t    objfile->sect_index_bss = sect->index;\n \t}\n     }\n-\n-  free_symfile_segment_data (data);\n }\n \n /* Listen for free_objfile events.  */"
    },
    {
      "sha": "2dfa6556d47993b32d61979255d66e8b638c3a38",
      "filename": "gdb/symfile.h",
      "status": "modified",
      "additions": 16,
      "deletions": 8,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/symfile.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62982abdee45cb20a7cfadb2b1bcc358655d4ad3/gdb/symfile.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.h?ref=62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "patch": "@@ -80,26 +80,35 @@ typedef std::vector<other_sections> section_addr_info;\n    each BFD section belongs to.  */\n struct symfile_segment_data\n {\n+  ~symfile_segment_data ()\n+  {\n+    xfree (this->segment_bases);\n+    xfree (this->segment_sizes);\n+    xfree (this->segment_info);\n+  }\n+\n   /* How many segments are present in this file.  If there are\n      two, the text segment is the first one and the data segment\n      is the second one.  */\n-  int num_segments;\n+  int num_segments = 0;\n \n   /* If NUM_SEGMENTS is greater than zero, the original base address\n      of each segment.  */\n-  CORE_ADDR *segment_bases;\n+  CORE_ADDR *segment_bases = nullptr;\n \n   /* If NUM_SEGMENTS is greater than zero, the memory size of each\n      segment.  */\n-  CORE_ADDR *segment_sizes;\n+  CORE_ADDR *segment_sizes = nullptr;\n \n   /* If NUM_SEGMENTS is greater than zero, this is an array of entries\n      recording which segment contains each BFD section.\n      SEGMENT_INFO[I] is S+1 if the I'th BFD section belongs to segment\n      S, or zero if it is not in any segment.  */\n-  int *segment_info;\n+  int *segment_info = nullptr;\n };\n \n+using symfile_segment_data_up = std::unique_ptr<symfile_segment_data>;\n+\n /* Callback for quick_symbol_functions->map_symbol_filenames.  */\n \n typedef void (symbol_filename_ftype) (const char *filename,\n@@ -360,7 +369,7 @@ struct sym_fns\n      the segments of ABFD.  Each segment is a unit of the file\n      which may be relocated independently.  */\n \n-  struct symfile_segment_data *(*sym_segments) (bfd *abfd);\n+  symfile_segment_data_up (*sym_segments) (bfd *abfd);\n \n   /* This function should read the linetable from the objfile when\n      the line table cannot be read while processing the debugging\n@@ -401,7 +410,7 @@ extern void default_symfile_offsets (struct objfile *objfile,\n /* The default version of sym_fns.sym_segments for readers that don't\n    do anything special.  */\n \n-extern struct symfile_segment_data *default_symfile_segments (bfd *abfd);\n+extern symfile_segment_data_up default_symfile_segments (bfd *abfd);\n \n /* The default version of sym_fns.sym_relocate for readers that don't\n    do anything special.  */\n@@ -530,8 +539,7 @@ extern int symfile_map_offsets_to_segments (bfd *,\n \t\t\t\t\t    const struct symfile_segment_data *,\n \t\t\t\t\t    section_offsets &,\n \t\t\t\t\t    int, const CORE_ADDR *);\n-struct symfile_segment_data *get_symfile_segment_data (bfd *abfd);\n-void free_symfile_segment_data (struct symfile_segment_data *data);\n+symfile_segment_data_up get_symfile_segment_data (bfd *abfd);\n \n extern scoped_restore_tmpl<int> increment_reading_symtab (void);\n "
    }
  ]
}