{
  "sha": "a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTViZTliYmU4OTZkNGFkYjYwNzdlOWJiMmViY2FhYTQ0MjZiZGRlMQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-23T21:24:13Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:07:33Z"
    },
    "message": "libctf: implementation definitions related to file creation\n\nWe now enter a series of commits that are sufficiently tangled that\navoiding forward definitions is almost impossible: no attempt is made to\nmake individual commits compilable (which is why the build system does\nnot reference any of them yet): the only important thing is that they\nshould form something like conceptual groups.\n\nBut first, some definitions, including the core ctf_file_t itself.  Uses\nof these definitions will be introduced in later commits.\n\nlibctf/\n\t* ctf-impl.h: New definitions and declarations for type creation\n\tand lookup.",
    "tree": {
      "sha": "6fdf81886d7160464a5f26a3fe73856fe4cd8c7f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6fdf81886d7160464a5f26a3fe73856fe4cd8c7f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c0754cdd9af6d8259eac5c9daad9f9b0611358dd"
    }
  ],
  "stats": {
    "total": 219,
    "additions": 219,
    "deletions": 0
  },
  "files": [
    {
      "sha": "f8b2961b1333ee8ec4c62cdfccf94dc305796369",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1",
      "patch": "@@ -1,3 +1,8 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h: New definitions and declarations for type creation\n+\tand lookup.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-hash.c: New file."
    },
    {
      "sha": "ef4221a8a4fefa85d0bc940d2022d53348754900",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 214,
      "deletions": 0,
      "changes": 214,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1",
      "patch": "@@ -63,12 +63,210 @@ extern \"C\"\n typedef struct ctf_fixed_hash ctf_hash_t; /* Private to ctf-hash.c.  */\n typedef struct ctf_dynhash ctf_dynhash_t; /* Private to ctf-hash.c.  */\n \n+typedef struct ctf_strs\n+{\n+  const char *cts_strs;\t\t/* Base address of string table.  */\n+  size_t cts_len;\t\t/* Size of string table in bytes.  */\n+} ctf_strs_t;\n+\n+typedef struct ctf_dmodel\n+{\n+  const char *ctd_name;\t\t/* Data model name.  */\n+  int ctd_code;\t\t\t/* Data model code.  */\n+  size_t ctd_pointer;\t\t/* Size of void * in bytes.  */\n+  size_t ctd_char;\t\t/* Size of char in bytes.  */\n+  size_t ctd_short;\t\t/* Size of short in bytes.  */\n+  size_t ctd_int;\t\t/* Size of int in bytes.  */\n+  size_t ctd_long;\t\t/* Size of long in bytes.  */\n+} ctf_dmodel_t;\n+\n+typedef struct ctf_lookup\n+{\n+  const char *ctl_prefix;\t/* String prefix for this lookup.  */\n+  size_t ctl_len;\t\t/* Length of prefix string in bytes.  */\n+  ctf_hash_t *ctl_hash;\t\t/* Pointer to hash table for lookup.  */\n+} ctf_lookup_t;\n+\n+typedef struct ctf_fileops\n+{\n+  uint32_t (*ctfo_get_kind) (uint32_t);\n+  uint32_t (*ctfo_get_root) (uint32_t);\n+  uint32_t (*ctfo_get_vlen) (uint32_t);\n+  ssize_t (*ctfo_get_ctt_size) (const ctf_file_t *, const ctf_type_t *,\n+\t\t\t\tssize_t *, ssize_t *);\n+  ssize_t (*ctfo_get_vbytes) (unsigned short, ssize_t, size_t);\n+} ctf_fileops_t;\n+\n typedef struct ctf_list\n {\n   struct ctf_list *l_prev;\t/* Previous pointer or tail pointer.  */\n   struct ctf_list *l_next;\t/* Next pointer or head pointer.  */\n } ctf_list_t;\n \n+typedef enum\n+  {\n+   CTF_PREC_BASE,\n+   CTF_PREC_POINTER,\n+   CTF_PREC_ARRAY,\n+   CTF_PREC_FUNCTION,\n+   CTF_PREC_MAX\n+  } ctf_decl_prec_t;\n+\n+typedef struct ctf_decl_node\n+{\n+  ctf_list_t cd_list;\t\t/* Linked list pointers.  */\n+  ctf_id_t cd_type;\t\t/* Type identifier.  */\n+  uint32_t cd_kind;\t\t/* Type kind.  */\n+  uint32_t cd_n;\t\t/* Type dimension if array.  */\n+} ctf_decl_node_t;\n+\n+typedef struct ctf_decl\n+{\n+  ctf_list_t cd_nodes[CTF_PREC_MAX]; /* Declaration node stacks.  */\n+  int cd_order[CTF_PREC_MAX];\t     /* Storage order of decls.  */\n+  ctf_decl_prec_t cd_qualp;\t     /* Qualifier precision.  */\n+  ctf_decl_prec_t cd_ordp;\t     /* Ordered precision.  */\n+  char *cd_buf;\t\t\t     /* Buffer for output.  */\n+  int cd_err;\t\t\t     /* Saved error value.  */\n+  int cd_enomem;\t\t     /* Nonzero if OOM during printing.  */\n+} ctf_decl_t;\n+\n+typedef struct ctf_dmdef\n+{\n+  ctf_list_t dmd_list;\t\t/* List forward/back pointers.  */\n+  char *dmd_name;\t\t/* Name of this member.  */\n+  ctf_id_t dmd_type;\t\t/* Type of this member (for sou).  */\n+  unsigned long dmd_offset;\t/* Offset of this member in bits (for sou).  */\n+  int dmd_value;\t\t/* Value of this member (for enum).  */\n+} ctf_dmdef_t;\n+\n+typedef struct ctf_dtdef\n+{\n+  ctf_list_t dtd_list;\t\t/* List forward/back pointers.  */\n+  char *dtd_name;\t\t/* Name associated with definition (if any).  */\n+  ctf_id_t dtd_type;\t\t/* Type identifier for this definition.  */\n+  ctf_type_t dtd_data;\t\t/* Type node (see <ctf.h>).  */\n+  union\n+  {\n+    ctf_list_t dtu_members;\t/* struct, union, or enum */\n+    ctf_arinfo_t dtu_arr;\t/* array */\n+    ctf_encoding_t dtu_enc;\t/* integer or float */\n+    ctf_id_t *dtu_argv;\t\t/* function */\n+    ctf_slice_t dtu_slice;\t/* slice */\n+  } dtd_u;\n+} ctf_dtdef_t;\n+\n+typedef struct ctf_dvdef\n+{\n+  ctf_list_t dvd_list;\t\t/* List forward/back pointers.  */\n+  char *dvd_name;\t\t/* Name associated with variable.  */\n+  ctf_id_t dvd_type;\t\t/* Type of variable.  */\n+  unsigned long dvd_snapshots;\t/* Snapshot count when inserted.  */\n+} ctf_dvdef_t;\n+\n+typedef struct ctf_bundle\n+{\n+  ctf_file_t *ctb_file;\t\t/* CTF container handle.  */\n+  ctf_id_t ctb_type;\t\t/* CTF type identifier.  */\n+  ctf_dtdef_t *ctb_dtd;\t\t/* CTF dynamic type definition (if any).  */\n+} ctf_bundle_t;\n+\n+/* The ctf_file is the structure used to represent a CTF container to library\n+   clients, who see it only as an opaque pointer.  Modifications can therefore\n+   be made freely to this structure without regard to client versioning.  The\n+   ctf_file_t typedef appears in <ctf-api.h> and declares a forward tag.\n+\n+   NOTE: ctf_update() requires that everything inside of ctf_file either be an\n+   immediate value, a pointer to dynamically allocated data *outside* of the\n+   ctf_file itself, or a pointer to statically allocated data.  If you add a\n+   pointer to ctf_file that points to something within the ctf_file itself,\n+   you must make corresponding changes to ctf_update().  */\n+\n+struct ctf_file\n+{\n+  const ctf_fileops_t *ctf_fileops; /* Version-specific file operations.  */\n+  ctf_sect_t ctf_data;\t\t    /* CTF data from object file.  */\n+  ctf_sect_t ctf_symtab;\t    /* Symbol table from object file.  */\n+  ctf_sect_t ctf_strtab;\t    /* String table from object file.  */\n+  ctf_hash_t *ctf_structs;\t    /* Hash table of struct types.  */\n+  ctf_hash_t *ctf_unions;\t    /* Hash table of union types.  */\n+  ctf_hash_t *ctf_enums;\t    /* Hash table of enum types.  */\n+  ctf_hash_t *ctf_names;\t    /* Hash table of remaining type names.  */\n+  ctf_lookup_t ctf_lookups[5];\t    /* Pointers to hashes for name lookup.  */\n+  ctf_strs_t ctf_str[2];\t    /* Array of string table base and bounds.  */\n+  const unsigned char *ctf_base;  /* Base of CTF header + uncompressed buffer.  */\n+  const unsigned char *ctf_buf;\t  /* Uncompressed CTF data buffer.  */\n+  size_t ctf_size;\t\t  /* Size of CTF header + uncompressed data.  */\n+  uint32_t *ctf_sxlate;\t\t  /* Translation table for symtab entries.  */\n+  unsigned long ctf_nsyms;\t  /* Number of entries in symtab xlate table.  */\n+  uint32_t *ctf_txlate;\t\t  /* Translation table for type IDs.  */\n+  uint32_t *ctf_ptrtab;\t\t  /* Translation table for pointer-to lookups.  */\n+  struct ctf_varent *ctf_vars;\t  /* Sorted variable->type mapping.  */\n+  unsigned long ctf_nvars;\t  /* Number of variables in ctf_vars.  */\n+  unsigned long ctf_typemax;\t  /* Maximum valid type ID number.  */\n+  const ctf_dmodel_t *ctf_dmodel; /* Data model pointer (see above).  */\n+  struct ctf_file *ctf_parent;\t  /* Parent CTF container (if any).  */\n+  const char *ctf_parlabel;\t  /* Label in parent container (if any).  */\n+  const char *ctf_parname;\t  /* Basename of parent (if any).  */\n+  char *ctf_dynparname;\t\t  /* Dynamically allocated name of parent.  */\n+  uint32_t ctf_parmax;\t\t  /* Highest type ID of a parent type.  */\n+  uint32_t ctf_refcnt;\t\t  /* Reference count (for parent links).  */\n+  uint32_t ctf_flags;\t\t  /* Libctf flags (see below).  */\n+  int ctf_errno;\t\t  /* Error code for most recent error.  */\n+  int ctf_version;\t\t  /* CTF data version.  */\n+  ctf_dynhash_t *ctf_dthash;\t  /* Hash of dynamic type definitions.  */\n+  ctf_dynhash_t *ctf_dtbyname;\t  /* DTDs, indexed by name.  */\n+  ctf_list_t ctf_dtdefs;\t  /* List of dynamic type definitions.  */\n+  ctf_dynhash_t *ctf_dvhash;\t  /* Hash of dynamic variable mappings.  */\n+  ctf_list_t ctf_dvdefs;\t  /* List of dynamic variable definitions.  */\n+  size_t ctf_dtvstrlen;\t\t  /* Total length of dynamic type+var strings.  */\n+  unsigned long ctf_dtnextid;\t  /* Next dynamic type id to assign.  */\n+  unsigned long ctf_dtoldid;\t  /* Oldest id that has been committed.  */\n+  unsigned long ctf_snapshots;\t  /* ctf_snapshot() plus ctf_update() count.  */\n+  unsigned long ctf_snapshot_lu;  /* ctf_snapshot() call count at last update.  */\n+  ctf_archive_t *ctf_archive;\t  /* Archive this ctf_file_t came from.  */\n+  char *ctf_tmp_typeslice;\t  /* Storage for slicing up type names.  */\n+  size_t ctf_tmp_typeslicelen;\t  /* Size of the typeslice.  */\n+  void *ctf_specific;\t\t  /* Data for ctf_get/setspecific().  */\n+};\n+\n+/* Return x rounded up to an alignment boundary.\n+   eg, P2ROUNDUP(0x1234, 0x100) == 0x1300 (0x13*align)\n+   eg, P2ROUNDUP(0x5600, 0x100) == 0x5600 (0x56*align)  */\n+#define P2ROUNDUP(x, align)\t\t(-(-(x) & -(align)))\n+\n+/* * If an offs is not aligned already then round it up and align it. */\n+#define LCTF_ALIGN_OFFS(offs, align) ((offs + (align - 1)) & ~(align - 1))\n+\n+#define LCTF_TYPE_ISPARENT(fp, id) ((id) <= fp->ctf_parmax)\n+#define LCTF_TYPE_ISCHILD(fp, id) ((id) > fp->ctf_parmax)\n+#define LCTF_TYPE_TO_INDEX(fp, id) ((id) & (fp->ctf_parmax))\n+#define LCTF_INDEX_TO_TYPE(fp, id, child) (child ? ((id) | (fp->ctf_parmax+1)) : \\\n+\t\t\t\t\t   (id))\n+\n+#define LCTF_INDEX_TO_TYPEPTR(fp, i) \\\n+  ((ctf_type_t *)((uintptr_t)(fp)->ctf_buf + (fp)->ctf_txlate[(i)]))\n+\n+#define LCTF_INFO_KIND(fp, info)\t((fp)->ctf_fileops->ctfo_get_kind(info))\n+#define LCTF_INFO_ISROOT(fp, info)\t((fp)->ctf_fileops->ctfo_get_root(info))\n+#define LCTF_INFO_VLEN(fp, info)\t((fp)->ctf_fileops->ctfo_get_vlen(info))\n+#define LCTF_VBYTES(fp, kind, size, vlen) \\\n+  ((fp)->ctf_fileops->ctfo_get_vbytes(kind, size, vlen))\n+\n+static inline ssize_t ctf_get_ctt_size (const ctf_file_t *fp,\n+\t\t\t\t\tconst ctf_type_t *tp,\n+\t\t\t\t\tssize_t *sizep,\n+\t\t\t\t\tssize_t *incrementp)\n+{\n+  return (fp->ctf_fileops->ctfo_get_ctt_size (fp, tp, sizep, incrementp));\n+}\n+\n+#define LCTF_CHILD\t0x0001\t/* CTF container is a child */\n+#define LCTF_RDWR\t0x0002\t/* CTF container is writable */\n+#define LCTF_DIRTY\t0x0004\t/* CTF container has been modified */\n+\n+extern const ctf_type_t *ctf_lookup_by_id (ctf_file_t **, ctf_id_t);\n+\n typedef unsigned int (*ctf_hash_fun) (const void *ptr);\n extern unsigned int ctf_hash_integer (const void *ptr);\n extern unsigned int ctf_hash_string (const void *ptr);\n@@ -100,6 +298,15 @@ extern void ctf_list_append (ctf_list_t *, void *);\n extern void ctf_list_prepend (ctf_list_t *, void *);\n extern void ctf_list_delete (ctf_list_t *, void *);\n \n+extern void ctf_dtd_insert (ctf_file_t *, ctf_dtdef_t *);\n+extern void ctf_dtd_delete (ctf_file_t *, ctf_dtdef_t *);\n+extern ctf_dtdef_t *ctf_dtd_lookup (const ctf_file_t *, ctf_id_t);\n+extern ctf_dtdef_t *ctf_dynamic_type (const ctf_file_t *, ctf_id_t);\n+\n+extern void ctf_dvd_insert (ctf_file_t *, ctf_dvdef_t *);\n+extern void ctf_dvd_delete (ctf_file_t *, ctf_dvdef_t *);\n+extern ctf_dvdef_t *ctf_dvd_lookup (const ctf_file_t *, const char *);\n+\n extern const char *ctf_strraw (ctf_file_t *, uint32_t);\n extern const char *ctf_strptr (ctf_file_t *, uint32_t);\n \n@@ -125,12 +332,19 @@ extern char *ctf_strdup (const char *);\n extern char *ctf_str_append (char *, const char *);\n extern const char *ctf_strerror (int);\n \n+extern ctf_id_t ctf_type_resolve_unsliced (ctf_file_t *, ctf_id_t);\n+extern int ctf_type_kind_unsliced (ctf_file_t *, ctf_id_t);\n+\n _libctf_printflike_ (1, 2)\n extern void ctf_dprintf (const char *, ...);\n extern void libctf_init_debug (void);\n \n extern Elf64_Sym *ctf_sym_to_elf64 (const Elf32_Sym *src, Elf64_Sym *dst);\n \n+/* Variables, all underscore-prepended. */\n+\n+extern const char _CTF_NULLSTR[];\t/* empty string */\n+\n extern int _libctf_debug;\t/* debugging messages enabled */\n \n #ifdef\t__cplusplus"
    }
  ]
}