{
  "sha": "c1299a23448227e9bb57df883aba0118618db9f4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzEyOTlhMjM0NDgyMjdlOWJiNTdkZjg4M2FiYTAxMTg2MThkYjlmNA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:38Z"
    },
    "message": "Convert rust-exp.y to use operations\n\nThis converts the Rust parser to generate operations rather than\nexp_elements.\n\nThe Rust parser already made its own AST, that it then lowered to GDB\nexpressions.  Ironically, this made conversion trickier, rather than\nsimpler, than the other parsers, primarily due to the way that binary\noperations were lowered.  Perhaps in the future, converting the Rust\nparser to directly create operations while parsing would be\nworthwhile.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* rust-exp.y: Create operations.\n\t(rust_parser::convert_params_to_expression): Change return type.\n\t(binop_maker_ftype): New typedef.\n\t(maker_map): New global.\n\t(rust_parser::convert_ast_to_expression): Change return type.\n\t(rust_language::parser): Update.\n\t(_initialize_rust_exp): Initialize maker_map.",
    "tree": {
      "sha": "fab842592427b927fd810a301f271ed74af066eb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fab842592427b927fd810a301f271ed74af066eb"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c1299a23448227e9bb57df883aba0118618db9f4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c1299a23448227e9bb57df883aba0118618db9f4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c1299a23448227e9bb57df883aba0118618db9f4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c1299a23448227e9bb57df883aba0118618db9f4/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4c5e7a930a46ddd6844eb7aede3ef60df535bc33"
    }
  ],
  "stats": {
    "total": 334,
    "additions": 190,
    "deletions": 144
  },
  "files": [
    {
      "sha": "765dd9c0eed25de74655d498f1c7edf23bee2e44",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1299a23448227e9bb57df883aba0118618db9f4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1299a23448227e9bb57df883aba0118618db9f4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c1299a23448227e9bb57df883aba0118618db9f4",
      "patch": "@@ -1,3 +1,13 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* rust-exp.y: Create operations.\n+\t(rust_parser::convert_params_to_expression): Change return type.\n+\t(binop_maker_ftype): New typedef.\n+\t(maker_map): New global.\n+\t(rust_parser::convert_ast_to_expression): Change return type.\n+\t(rust_language::parser): Update.\n+\t(_initialize_rust_exp): Initialize maker_map.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* stap-probe.c (binop_maker_ftype): New typedef."
    },
    {
      "sha": "9a5bdd7a836cc30eac78682ad03f2e01568a243f",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 180,
      "deletions": 144,
      "changes": 324,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1299a23448227e9bb57df883aba0118618db9f4/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1299a23448227e9bb57df883aba0118618db9f4/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=c1299a23448227e9bb57df883aba0118618db9f4",
      "patch": "@@ -41,6 +41,8 @@\n #include \"gdbsupport/selftest.h\"\n #include \"value.h\"\n #include \"gdbarch.h\"\n+#include \"rust-exp.h\"\n+#include <unordered_map>\n \n #define GDB_YY_REMAP_PREFIX rust\n #include \"yy-remap.h\"\n@@ -246,11 +248,11 @@ struct rust_parser\n   std::vector<struct type *> convert_params_to_types (rust_op_vector *params);\n   struct type *convert_ast_to_type (const struct rust_op *operation);\n   const char *convert_name (const struct rust_op *operation);\n-  void convert_params_to_expression (rust_op_vector *params,\n-\t\t\t\t     const struct rust_op *top);\n-  void convert_ast_to_expression (const struct rust_op *operation,\n-\t\t\t\t  const struct rust_op *top,\n-\t\t\t\t  bool want_type = false);\n+  std::vector<expr::operation_up> convert_params_to_expression\n+       (rust_op_vector *params, const struct rust_op *top);\n+  expr::operation_up convert_ast_to_expression (const struct rust_op *opn,\n+\t\t\t\t\t\tconst struct rust_op *top,\n+\t\t\t\t\t\tbool want_type = false);\n \n   struct rust_op *ast_basic_type (enum type_code typecode);\n   const struct rust_op *ast_operation (enum exp_opcode opcode,\n@@ -2183,14 +2185,25 @@ rust_parser::convert_name (const struct rust_op *operation)\n /* A helper function that converts a vec of rust_ops to a gdb\n    expression.  */\n \n-void\n+std::vector<expr::operation_up>\n rust_parser::convert_params_to_expression (rust_op_vector *params,\n \t\t\t\t\t   const struct rust_op *top)\n {\n+  std::vector<expr::operation_up> result;\n   for (const rust_op *elem : *params)\n-    convert_ast_to_expression (elem, top);\n+    result.push_back (convert_ast_to_expression (elem, top));\n+  result.shrink_to_fit ();\n+  return result;\n }\n \n+typedef expr::operation_up binop_maker_ftype (expr::operation_up &&,\n+\t\t\t\t\t      expr::operation_up &&);\n+\n+/* Map from an expression opcode to a function that will create an\n+   instance of the appropriate operation subclass.  Only binary\n+   operations are handled this way.  */\n+static std::unordered_map<exp_opcode, binop_maker_ftype *> maker_map;\n+\n /* Lower a rust_op to a gdb expression.  STATE is the parser state.\n    OPERATION is the operation to lower.  TOP is a pointer to the\n    top-most operation; it is used to handle the special case where the\n@@ -2200,62 +2213,87 @@ rust_parser::convert_params_to_expression (rust_op_vector *params,\n    erroring).  If WANT_TYPE is set, then the similar TOP handling is\n    not done.  */\n \n-void\n+expr::operation_up\n rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t\t\t\t\tconst struct rust_op *top,\n \t\t\t\t\tbool want_type)\n {\n+  using namespace expr;\n+\n   switch (operation->opcode)\n     {\n     case OP_LONG:\n-      write_exp_elt_opcode (pstate, OP_LONG);\n-      write_exp_elt_type (pstate, operation->left.typed_val_int.type);\n-      write_exp_elt_longcst (pstate, operation->left.typed_val_int.val);\n-      write_exp_elt_opcode (pstate, OP_LONG);\n-      break;\n+      return operation_up\n+\t(new long_const_operation (operation->left.typed_val_int.type,\n+\t\t\t\t   operation->left.typed_val_int.val));\n \n     case OP_FLOAT:\n-      write_exp_elt_opcode (pstate, OP_FLOAT);\n-      write_exp_elt_type (pstate, operation->left.typed_val_float.type);\n-      write_exp_elt_floatcst (pstate, operation->left.typed_val_float.val);\n-      write_exp_elt_opcode (pstate, OP_FLOAT);\n-      break;\n+      {\n+\tfloat_data data;\n+\tmemcpy (data.data (), operation->left.typed_val_float.val,\n+\t\tsizeof (operation->left.typed_val_float.val));\n+\treturn operation_up\n+\t  (new float_const_operation (operation->left.typed_val_float.type,\n+\t\t\t\t      data));\n+      }\n \n     case STRUCTOP_STRUCT:\n       {\n-\tconvert_ast_to_expression (operation->left.op, top);\n-\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n+\tauto result = new rust_structop (std::move (lhs),\n+\t\t\t\t\t operation->right.sval.ptr);\n \tif (operation->completing)\n-\t  pstate->mark_struct_expression ();\n-\twrite_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\twrite_exp_string (pstate, operation->right.sval);\n-\twrite_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n+\t  pstate->mark_struct_expression (result);\n+\treturn operation_up (result);\n       }\n-      break;\n \n     case STRUCTOP_ANONYMOUS:\n       {\n-\tconvert_ast_to_expression (operation->left.op, top);\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n \n-\twrite_exp_elt_opcode (pstate, STRUCTOP_ANONYMOUS);\n-\twrite_exp_elt_longcst (pstate, operation->right.typed_val_int.val);\n-\twrite_exp_elt_opcode (pstate, STRUCTOP_ANONYMOUS);\n+\treturn operation_up\n+\t  (new rust_struct_anon (operation->right.typed_val_int.val,\n+\t\t\t\t std::move (lhs)));\n       }\n-      break;\n \n     case UNOP_SIZEOF:\n-      convert_ast_to_expression (operation->left.op, top, true);\n-      write_exp_elt_opcode (pstate, UNOP_SIZEOF);\n-      break;\n+      {\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top,\n+\t\t\t\t\t\t      true);\n+\treturn operation_up\n+\t  (new unop_sizeof_operation (std::move (lhs)));\n+      }\n \n     case UNOP_PLUS:\n+      {\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n+\treturn operation_up\n+\t  (new unary_plus_operation (std::move (lhs)));\n+      }\n     case UNOP_NEG:\n+      {\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n+\treturn operation_up\n+\t  (new unary_neg_operation (std::move (lhs)));\n+      }\n     case UNOP_COMPLEMENT:\n+      {\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n+\treturn operation_up\n+\t  (new rust_unop_compl_operation (std::move (lhs)));\n+      }\n     case UNOP_IND:\n+      {\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n+\treturn operation_up\n+\t  (new rust_unop_ind_operation (std::move (lhs)));\n+      }\n     case UNOP_ADDR:\n-      convert_ast_to_expression (operation->left.op, top);\n-      write_exp_elt_opcode (pstate, operation->opcode);\n-      break;\n+      {\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n+\treturn operation_up\n+\t  (new rust_unop_addr_operation (std::move (lhs)));\n+      }\n \n     case BINOP_SUBSCRIPT:\n     case BINOP_MUL:\n@@ -2279,45 +2317,45 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n     case BINOP_RSH:\n     case BINOP_ASSIGN:\n     case OP_RUST_ARRAY:\n-      convert_ast_to_expression (operation->left.op, top);\n-      convert_ast_to_expression (operation->right.op, top);\n-      if (operation->compound_assignment)\n-\t{\n-\t  write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);\n-\t  write_exp_elt_opcode (pstate, operation->opcode);\n-\t  write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);\n-\t}\n-      else\n-\twrite_exp_elt_opcode (pstate, operation->opcode);\n-\n-      if (operation->compound_assignment\n-\t  || operation->opcode == BINOP_ASSIGN)\n-\t{\n-\t  struct type *type;\n-\n-\t  type = language_lookup_primitive_type (pstate->language (),\n-\t\t\t\t\t\t pstate->gdbarch (),\n-\t\t\t\t\t\t \"()\");\n+      {\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n+\toperation_up rhs = convert_ast_to_expression (operation->right.op,\n+\t\t\t\t\t\t      top);\n+\toperation_up result;\n+\tif (operation->compound_assignment)\n+\t  result = (operation_up\n+\t\t    (new assign_modify_operation (operation->opcode,\n+\t\t\t\t\t\t  std::move (lhs),\n+\t\t\t\t\t\t  std::move (rhs))));\n+\telse\n+\t  {\n+\t    auto iter = maker_map.find (operation->opcode);\n+\t    gdb_assert (iter != maker_map.end ());\n+\t    result = iter->second (std::move (lhs), std::move (rhs));\n+\t  }\n \n-\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t  write_exp_elt_type (pstate, type);\n-\t  write_exp_elt_longcst (pstate, 0);\n-\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\tif (operation->compound_assignment\n+\t    || operation->opcode == BINOP_ASSIGN)\n+\t  {\n+\t    struct type *type\n+\t      = language_lookup_primitive_type (pstate->language (),\n+\t\t\t\t\t\tpstate->gdbarch (),\n+\t\t\t\t\t\t\"()\");\n+\n+\t    operation_up nil (new long_const_operation (type, 0));\n+\t    result.reset (new comma_operation (std::move (result),\n+\t\t\t\t\t       std::move (nil)));\n+\t  }\n \n-\t  write_exp_elt_opcode (pstate, BINOP_COMMA);\n-\t}\n-      break;\n+\treturn result;\n+      }\n \n     case UNOP_CAST:\n       {\n \tstruct type *type = convert_ast_to_type (operation->right.op);\n-\n-\tconvert_ast_to_expression (operation->left.op, top);\n-\twrite_exp_elt_opcode (pstate, UNOP_CAST);\n-\twrite_exp_elt_type (pstate, type);\n-\twrite_exp_elt_opcode (pstate, UNOP_CAST);\n+\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n+\treturn operation_up (new unop_cast_operation (std::move (lhs), type));\n       }\n-      break;\n \n     case OP_FUNCALL:\n       {\n@@ -2339,42 +2377,39 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t\t    if (!rust_tuple_struct_type_p (type))\n \t\t      error (_(\"Type %s is not a tuple struct\"), varname);\n \n+\t\t    std::vector<std::pair<std::string, operation_up>> args\n+\t\t      (params->size ());\n \t\t    for (int i = 0; i < params->size (); ++i)\n \t\t      {\n \t\t\tchar *cell = get_print_cell ();\n \n+\t\t\toperation_up op\n+\t\t\t  = convert_ast_to_expression ((*params)[i], top);\n \t\t\txsnprintf (cell, PRINT_CELL_SIZE, \"__%d\", i);\n-\t\t\twrite_exp_elt_opcode (pstate, OP_NAME);\n-\t\t\twrite_exp_string (pstate, make_stoken (cell));\n-\t\t\twrite_exp_elt_opcode (pstate, OP_NAME);\n-\n-\t\t\tconvert_ast_to_expression ((*params)[i], top);\n+\t\t\targs[i] = { cell, std::move (op) };\n \t\t      }\n \n-\t\t    write_exp_elt_opcode (pstate, OP_AGGREGATE);\n-\t\t    write_exp_elt_type (pstate, type);\n-\t\t    write_exp_elt_longcst (pstate, 2 * params->size ());\n-\t\t    write_exp_elt_opcode (pstate, OP_AGGREGATE);\n-\t\t    break;\n+\t\t    return make_operation<rust_aggregate_operation>\n+\t\t      (type, operation_up (), std::move (args));\n \t\t  }\n \t      }\n \t  }\n-\tconvert_ast_to_expression (operation->left.op, top);\n-\tconvert_params_to_expression (operation->right.params, top);\n-\twrite_exp_elt_opcode (pstate, OP_FUNCALL);\n-\twrite_exp_elt_longcst (pstate, operation->right.params->size ());\n-\twrite_exp_elt_longcst (pstate, OP_FUNCALL);\n+\toperation_up callee = convert_ast_to_expression (operation->left.op,\n+\t\t\t\t\t\t\t top);\n+\tstd::vector<operation_up> args\n+\t  = convert_params_to_expression (operation->right.params, top);\n+\treturn make_operation<funcall_operation> (std::move (callee),\n+\t\t\t\t\t\t  std::move (args));\n       }\n-      break;\n \n     case OP_ARRAY:\n-      gdb_assert (operation->left.op == NULL);\n-      convert_params_to_expression (operation->right.params, top);\n-      write_exp_elt_opcode (pstate, OP_ARRAY);\n-      write_exp_elt_longcst (pstate, 0);\n-      write_exp_elt_longcst (pstate, operation->right.params->size () - 1);\n-      write_exp_elt_longcst (pstate, OP_ARRAY);\n-      break;\n+      {\n+\tgdb_assert (operation->left.op == NULL);\n+\tstd::vector<operation_up> subexps\n+\t  = convert_params_to_expression (operation->right.params, top);\n+\treturn make_operation<array_operation>\n+\t  (0, operation->right.params->size () - 1, std::move (subexps));\n+      }\n \n     case OP_VAR_VALUE:\n       {\n@@ -2383,20 +2418,16 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \n \tif (operation->left.sval.ptr[0] == '$')\n \t  {\n-\t    write_dollar_variable (pstate, operation->left.sval);\n-\t    break;\n+\t    pstate->push_dollar (operation->left.sval);\n+\t    return pstate->pop ();\n \t  }\n \n \tvarname = convert_name (operation);\n \tsym = lookup_symbol (varname, pstate->expression_context_block,\n \t\t\t     VAR_DOMAIN);\n+\toperation_up result;\n \tif (sym.symbol != NULL && SYMBOL_CLASS (sym.symbol) != LOC_TYPEDEF)\n-\t  {\n-\t    write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t    write_exp_elt_block (pstate, sym.block);\n-\t    write_exp_elt_sym (pstate, sym.symbol);\n-\t    write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t  }\n+\t  result.reset (new var_value_operation (sym.symbol, sym.block));\n \telse\n \t  {\n \t    struct type *type = NULL;\n@@ -2417,52 +2448,35 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t\t&& type->num_fields () == 0)\n \t      {\n \t\t/* A unit-like struct.  */\n-\t\twrite_exp_elt_opcode (pstate, OP_AGGREGATE);\n-\t\twrite_exp_elt_type (pstate, type);\n-\t\twrite_exp_elt_longcst (pstate, 0);\n-\t\twrite_exp_elt_opcode (pstate, OP_AGGREGATE);\n+\t\tresult.reset (new rust_aggregate_operation (type, {}, {}));\n \t      }\n \t    else if (want_type || operation == top)\n-\t      {\n-\t\twrite_exp_elt_opcode (pstate, OP_TYPE);\n-\t\twrite_exp_elt_type (pstate, type);\n-\t\twrite_exp_elt_opcode (pstate, OP_TYPE);\n-\t      }\n+\t      result.reset (new type_operation (type));\n \t    else\n \t      error (_(\"Found type '%s', which can't be \"\n \t\t       \"evaluated in this context\"),\n \t\t     varname);\n \t  }\n+\n+\treturn result;\n       }\n-      break;\n \n     case OP_AGGREGATE:\n       {\n-\tint length;\n \trust_set_vector *fields = operation->right.field_inits;\n \tstruct type *type;\n \tconst char *name;\n \n-\tlength = 0;\n+\toperation_up others;\n+\tstd::vector<std::pair<std::string, operation_up>> field_v;\n \tfor (const set_field &init : *fields)\n \t  {\n-\t    if (init.name.ptr != NULL)\n-\t      {\n-\t\twrite_exp_elt_opcode (pstate, OP_NAME);\n-\t\twrite_exp_string (pstate, init.name);\n-\t\twrite_exp_elt_opcode (pstate, OP_NAME);\n-\t\t++length;\n-\t      }\n-\n-\t    convert_ast_to_expression (init.init, top);\n-\t    ++length;\n+\t    operation_up expr = convert_ast_to_expression (init.init, top);\n \n \t    if (init.name.ptr == NULL)\n-\t      {\n-\t\t/* This is handled differently from Ada in our\n-\t\t   evaluator.  */\n-\t\twrite_exp_elt_opcode (pstate, OP_OTHERS);\n-\t      }\n+\t      others = std::move (expr);\n+\t    else\n+\t      field_v.emplace_back (init.name.ptr, std::move (expr));\n \t  }\n \n \tname = convert_name (operation->left.op);\n@@ -2475,34 +2489,29 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t    || rust_tuple_struct_type_p (type))\n \t  error (_(\"Struct expression applied to non-struct type\"));\n \n-\twrite_exp_elt_opcode (pstate, OP_AGGREGATE);\n-\twrite_exp_elt_type (pstate, type);\n-\twrite_exp_elt_longcst (pstate, length);\n-\twrite_exp_elt_opcode (pstate, OP_AGGREGATE);\n+\treturn operation_up\n+\t  (new rust_aggregate_operation (type, std::move (others),\n+\t\t\t\t\t std::move (field_v)));\n       }\n-      break;\n \n     case OP_STRING:\n-      {\n-\twrite_exp_elt_opcode (pstate, OP_STRING);\n-\twrite_exp_string (pstate, operation->left.sval);\n-\twrite_exp_elt_opcode (pstate, OP_STRING);\n-      }\n-      break;\n+      return (operation_up\n+\t      (new string_operation (::copy_name (operation->left.sval))));\n \n     case OP_RANGE:\n       {\n \tenum range_flag kind = (RANGE_HIGH_BOUND_DEFAULT\n \t\t\t\t| RANGE_LOW_BOUND_DEFAULT);\n+\toperation_up lhs, rhs;\n \n \tif (operation->left.op != NULL)\n \t  {\n-\t    convert_ast_to_expression (operation->left.op, top);\n+\t    lhs = convert_ast_to_expression (operation->left.op, top);\n \t    kind &= ~RANGE_LOW_BOUND_DEFAULT;\n \t  }\n \tif (operation->right.op != NULL)\n \t  {\n-\t    convert_ast_to_expression (operation->right.op, top);\n+\t    rhs = convert_ast_to_expression (operation->right.op, top);\n \t    if (kind == (RANGE_HIGH_BOUND_DEFAULT | RANGE_LOW_BOUND_DEFAULT))\n \t      {\n \t\tkind = RANGE_LOW_BOUND_DEFAULT;\n@@ -2524,11 +2533,10 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t    gdb_assert (!operation->inclusive);\n \t  }\n \n-\twrite_exp_elt_opcode (pstate, OP_RANGE);\n-\twrite_exp_elt_longcst (pstate, kind);\n-\twrite_exp_elt_opcode (pstate, OP_RANGE);\n+\treturn operation_up (new rust_range_operation (kind,\n+\t\t\t\t\t\t       std::move (lhs),\n+\t\t\t\t\t\t       std::move (rhs)));\n       }\n-      break;\n \n     default:\n       gdb_assert_not_reached (\"unhandled opcode in convert_ast_to_expression\");\n@@ -2551,7 +2559,11 @@ rust_language::parser (struct parser_state *state) const\n   result = rustyyparse (&parser);\n \n   if (!result || (state->parse_completion && parser.rust_ast != NULL))\n-    parser.convert_ast_to_expression (parser.rust_ast, parser.rust_ast);\n+    {\n+      expr::operation_up op\n+\t= parser.convert_ast_to_expression (parser.rust_ast, parser.rust_ast);\n+      state->set_operation (std::move (op));\n+    }\n \n   return result;\n }\n@@ -2840,6 +2852,30 @@ _initialize_rust_exp ()\n      error.  */\n   gdb_assert (code == 0);\n \n+  using namespace expr;\n+  maker_map[BINOP_SUBSCRIPT] = make_operation<rust_subscript_operation>;\n+  maker_map[BINOP_MUL] = make_operation<mul_operation>;\n+  maker_map[BINOP_REPEAT] = make_operation<repeat_operation>;\n+  maker_map[BINOP_DIV] = make_operation<div_operation>;\n+  maker_map[BINOP_REM] = make_operation<rem_operation>;\n+  maker_map[BINOP_LESS] = make_operation<less_operation>;\n+  maker_map[BINOP_GTR] = make_operation<gtr_operation>;\n+  maker_map[BINOP_BITWISE_AND] = make_operation<bitwise_and_operation>;\n+  maker_map[BINOP_BITWISE_IOR] = make_operation<bitwise_ior_operation>;\n+  maker_map[BINOP_BITWISE_XOR] = make_operation<bitwise_xor_operation>;\n+  maker_map[BINOP_ADD] = make_operation<add_operation>;\n+  maker_map[BINOP_SUB] = make_operation<sub_operation>;\n+  maker_map[BINOP_LOGICAL_OR] = make_operation<logical_or_operation>;\n+  maker_map[BINOP_LOGICAL_AND] = make_operation<logical_and_operation>;\n+  maker_map[BINOP_EQUAL] = make_operation<equal_operation>;\n+  maker_map[BINOP_NOTEQUAL] = make_operation<notequal_operation>;\n+  maker_map[BINOP_LEQ] = make_operation<leq_operation>;\n+  maker_map[BINOP_GEQ] = make_operation<geq_operation>;\n+  maker_map[BINOP_LSH] = make_operation<lsh_operation>;\n+  maker_map[BINOP_RSH] = make_operation<rsh_operation>;\n+  maker_map[BINOP_ASSIGN] = make_operation<assign_operation>;\n+  maker_map[OP_RUST_ARRAY] = make_operation<rust_array_operation>;\n+\n #if GDB_SELF_TEST\n   selftests::register_test (\"rust-lex\", rust_lex_tests);\n #endif"
    }
  ]
}