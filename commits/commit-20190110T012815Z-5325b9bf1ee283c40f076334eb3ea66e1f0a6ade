{
  "sha": "5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTMyNWI5YmYxZWUyODNjNDBmMDc2MzM0ZWIzZWE2NmUxZjBhNmFkZQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2018-11-24T00:32:08Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-10T01:28:15Z"
    },
    "message": "Remove ALL_MSYMBOLS and ALL_OBJFILE_MSYMBOLS\n\nThis removes the ALL_MSYMBOLS and ALL_OBJFILE_MSYMBOLS macros,\nreplacing their uses with ranged for loops.\n\nIn a couple of spots, a new declaration was needed in order to work\naround shadowing; these are just temporary and are removed in a\nsubsequent patch.\n\ngdb/ChangeLog\n2019-01-09  Tom Tromey  <tom@tromey.com>\n\n\t* symtab.c (search_symbols)\n\t(default_collect_symbol_completion_matches_break_on): Use\n\tobjfile_msymbols.\n\t* ada-lang.c (ada_lookup_simple_minsym)\n\t(ada_collect_symbol_completion_matches): Use objfile_msymbols.\n\t* minsyms.c (find_solib_trampoline_target): Use objfile_msymbols.\n\t* hppa-tdep.c (hppa_lookup_stub_minimal_symbol): Use\n\tobjfile_msymbols.\n\t* coffread.c (coff_symfile_read): Use objfile_msymbols.\n\t* symmisc.c (dump_msymbols): Use objfile_msymbols.\n\t* objc-lang.c (find_methods): Use objfile_msymbols.\n\t(info_selectors_command, info_classes_command): Likewise.\n\t* stabsread.c (scan_file_globals): Use objfile_msymbols.\n\t* objfiles.h (class objfile_msymbols): New.\n\t(ALL_OBJFILE_MSYMBOLS): Remove.\n\t(ALL_MSYMBOLS): Remove.",
    "tree": {
      "sha": "4964d0282ac4cb82ed0a6691cbccf4062c3799d8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4964d0282ac4cb82ed0a6691cbccf4062c3799d8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cac85af2467c9bac326b397b150274d95d2916a5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cac85af2467c9bac326b397b150274d95d2916a5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cac85af2467c9bac326b397b150274d95d2916a5"
    }
  ],
  "stats": {
    "total": 649,
    "additions": 380,
    "deletions": 269
  },
  "files": [
    {
      "sha": "08a80d870d2e129656bf31b6aae2392527177821",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -1,3 +1,22 @@\n+2019-01-09  Tom Tromey  <tom@tromey.com>\n+\n+\t* symtab.c (search_symbols)\n+\t(default_collect_symbol_completion_matches_break_on): Use\n+\tobjfile_msymbols.\n+\t* ada-lang.c (ada_lookup_simple_minsym)\n+\t(ada_collect_symbol_completion_matches): Use objfile_msymbols.\n+\t* minsyms.c (find_solib_trampoline_target): Use objfile_msymbols.\n+\t* hppa-tdep.c (hppa_lookup_stub_minimal_symbol): Use\n+\tobjfile_msymbols.\n+\t* coffread.c (coff_symfile_read): Use objfile_msymbols.\n+\t* symmisc.c (dump_msymbols): Use objfile_msymbols.\n+\t* objc-lang.c (find_methods): Use objfile_msymbols.\n+\t(info_selectors_command, info_classes_command): Likewise.\n+\t* stabsread.c (scan_file_globals): Use objfile_msymbols.\n+\t* objfiles.h (class objfile_msymbols): New.\n+\t(ALL_OBJFILE_MSYMBOLS): Remove.\n+\t(ALL_MSYMBOLS): Remove.\n+\n 2019-01-09  Tom Tromey  <tom@tromey.com>\n \n \t* common/next-iterator.h (next_adapter): Add Iterator template"
    },
    {
      "sha": "e23a6fafd27195ac972857de2631a88bad9b30e7",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 46,
      "deletions": 43,
      "changes": 89,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -4913,8 +4913,6 @@ struct bound_minimal_symbol\n ada_lookup_simple_minsym (const char *name)\n {\n   struct bound_minimal_symbol result;\n-  struct objfile *objfile;\n-  struct minimal_symbol *msymbol;\n \n   memset (&result, 0, sizeof (result));\n \n@@ -4924,16 +4922,19 @@ ada_lookup_simple_minsym (const char *name)\n   symbol_name_matcher_ftype *match_name\n     = ada_get_symbol_name_matcher (lookup_name);\n \n-  ALL_MSYMBOLS (objfile, msymbol)\n-  {\n-    if (match_name (MSYMBOL_LINKAGE_NAME (msymbol), lookup_name, NULL)\n-        && MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)\n-      {\n-\tresult.minsym = msymbol;\n-\tresult.objfile = objfile;\n-\tbreak;\n-      }\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n+\t{\n+\t  if (match_name (MSYMBOL_LINKAGE_NAME (msymbol), lookup_name, NULL)\n+\t      && MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)\n+\t    {\n+\t      result.minsym = msymbol;\n+\t      result.objfile = objfile;\n+\t      break;\n+\t    }\n+\t}\n+    }\n \n   return result;\n }\n@@ -6391,8 +6392,6 @@ ada_collect_symbol_completion_matches (completion_tracker &tracker,\n {\n   struct symbol *sym;\n   struct compunit_symtab *s;\n-  struct minimal_symbol *msymbol;\n-  struct objfile *objfile;\n   const struct block *b, *surrounding_static_block = 0;\n   struct block_iterator iter;\n \n@@ -6412,35 +6411,38 @@ ada_collect_symbol_completion_matches (completion_tracker &tracker,\n      anything that isn't a text symbol (everything else will be\n      handled by the psymtab code above).  */\n \n-  ALL_MSYMBOLS (objfile, msymbol)\n-  {\n-    QUIT;\n-\n-    if (completion_skip_symbol (mode, msymbol))\n-      continue;\n-\n-    language symbol_language = MSYMBOL_LANGUAGE (msymbol);\n-\n-    /* Ada minimal symbols won't have their language set to Ada.  If\n-       we let completion_list_add_name compare using the\n-       default/C-like matcher, then when completing e.g., symbols in a\n-       package named \"pck\", we'd match internal Ada symbols like\n-       \"pckS\", which are invalid in an Ada expression, unless you wrap\n-       them in '<' '>' to request a verbatim match.\n-\n-       Unfortunately, some Ada encoded names successfully demangle as\n-       C++ symbols (using an old mangling scheme), such as \"name__2Xn\"\n-       -> \"Xn::name(void)\" and thus some Ada minimal symbols end up\n-       with the wrong language set.  Paper over that issue here.  */\n-    if (symbol_language == language_auto\n-\t|| symbol_language == language_cplus)\n-      symbol_language = language_ada;\n-\n-    completion_list_add_name (tracker,\n-\t\t\t      symbol_language,\n-\t\t\t      MSYMBOL_LINKAGE_NAME (msymbol),\n-\t\t\t      lookup_name, text, word);\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n+\t{\n+\t  QUIT;\n+\n+\t  if (completion_skip_symbol (mode, msymbol))\n+\t    continue;\n+\n+\t  language symbol_language = MSYMBOL_LANGUAGE (msymbol);\n+\n+\t  /* Ada minimal symbols won't have their language set to Ada.  If\n+\t     we let completion_list_add_name compare using the\n+\t     default/C-like matcher, then when completing e.g., symbols in a\n+\t     package named \"pck\", we'd match internal Ada symbols like\n+\t     \"pckS\", which are invalid in an Ada expression, unless you wrap\n+\t     them in '<' '>' to request a verbatim match.\n+\n+\t     Unfortunately, some Ada encoded names successfully demangle as\n+\t     C++ symbols (using an old mangling scheme), such as \"name__2Xn\"\n+\t     -> \"Xn::name(void)\" and thus some Ada minimal symbols end up\n+\t     with the wrong language set.  Paper over that issue here.  */\n+\t  if (symbol_language == language_auto\n+\t      || symbol_language == language_cplus)\n+\t    symbol_language = language_ada;\n+\n+\t  completion_list_add_name (tracker,\n+\t\t\t\t    symbol_language,\n+\t\t\t\t    MSYMBOL_LINKAGE_NAME (msymbol),\n+\t\t\t\t    lookup_name, text, word);\n+\t}\n+    }\n \n   /* Search upwards from currently selected frame (so that we can\n      complete on local vars.  */\n@@ -6465,6 +6467,7 @@ ada_collect_symbol_completion_matches (completion_tracker &tracker,\n   /* Go through the symtabs and check the externs and statics for\n      symbols which match.  */\n \n+  struct objfile *objfile;\n   ALL_COMPUNITS (objfile, s)\n   {\n     QUIT;"
    },
    {
      "sha": "e6ca7ed8aff008adeb33106bd42b1979697a32cf",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -661,9 +661,7 @@ coff_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n \n   if (pe_file)\n     {\n-      struct minimal_symbol *msym;\n-\n-      ALL_OBJFILE_MSYMBOLS (objfile, msym)\n+      for (minimal_symbol *msym : objfile_msymbols (objfile))\n \t{\n \t  const char *name = MSYMBOL_LINKAGE_NAME (msym);\n "
    },
    {
      "sha": "16e44252f5f6bb42f9757bbc1c0dd0ba36715471",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 14,
      "deletions": 13,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -2540,24 +2540,25 @@ struct bound_minimal_symbol\n hppa_lookup_stub_minimal_symbol (const char *name,\n                                  enum unwind_stub_types stub_type)\n {\n-  struct objfile *objfile;\n-  struct minimal_symbol *msym;\n   struct bound_minimal_symbol result = { NULL, NULL };\n \n-  ALL_MSYMBOLS (objfile, msym)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n-      if (strcmp (MSYMBOL_LINKAGE_NAME (msym), name) == 0)\n-        {\n-          struct unwind_table_entry *u;\n-\n-          u = find_unwind_entry (MSYMBOL_VALUE (msym));\n-          if (u != NULL && u->stub_unwind.stub_type == stub_type)\n+      for (minimal_symbol *msym : objfile_msymbols (objfile))\n+\t{\n+\t  if (strcmp (MSYMBOL_LINKAGE_NAME (msym), name) == 0)\n \t    {\n-\t      result.objfile = objfile;\n-\t      result.minsym = msym;\n-\t      return result;\n+\t      struct unwind_table_entry *u;\n+\n+\t      u = find_unwind_entry (MSYMBOL_VALUE (msym));\n+\t      if (u != NULL && u->stub_unwind.stub_type == stub_type)\n+\t\t{\n+\t\t  result.objfile = objfile;\n+\t\t  result.minsym = msym;\n+\t\t  return result;\n+\t\t}\n \t    }\n-        }\n+\t}\n     }\n \n   return result;"
    },
    {
      "sha": "d09022623d264e8a520de12b86bd20a842f1b516",
      "filename": "gdb/minsyms.c",
      "status": "modified",
      "additions": 21,
      "deletions": 19,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/minsyms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/minsyms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minsyms.c?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -1488,30 +1488,32 @@ lookup_solib_trampoline_symbol_by_pc (CORE_ADDR pc)\n CORE_ADDR\n find_solib_trampoline_target (struct frame_info *frame, CORE_ADDR pc)\n {\n-  struct objfile *objfile;\n-  struct minimal_symbol *msymbol;\n   struct minimal_symbol *tsymbol = lookup_solib_trampoline_symbol_by_pc (pc);\n \n   if (tsymbol != NULL)\n     {\n-      ALL_MSYMBOLS (objfile, msymbol)\n-      {\n-\t/* Also handle minimal symbols pointing to function descriptors.  */\n-\tif ((MSYMBOL_TYPE (msymbol) == mst_text\n-\t     || MSYMBOL_TYPE (msymbol) == mst_text_gnu_ifunc\n-\t     || MSYMBOL_TYPE (msymbol) == mst_data\n-\t     || MSYMBOL_TYPE (msymbol) == mst_data_gnu_ifunc)\n-\t    && strcmp (MSYMBOL_LINKAGE_NAME (msymbol),\n-\t\t       MSYMBOL_LINKAGE_NAME (tsymbol)) == 0)\n-\t  {\n-\t    CORE_ADDR func;\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\t{\n+\t  for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n+\t    {\n+\t      /* Also handle minimal symbols pointing to function\n+\t\t descriptors.  */\n+\t      if ((MSYMBOL_TYPE (msymbol) == mst_text\n+\t\t   || MSYMBOL_TYPE (msymbol) == mst_text_gnu_ifunc\n+\t\t   || MSYMBOL_TYPE (msymbol) == mst_data\n+\t\t   || MSYMBOL_TYPE (msymbol) == mst_data_gnu_ifunc)\n+\t\t  && strcmp (MSYMBOL_LINKAGE_NAME (msymbol),\n+\t\t\t     MSYMBOL_LINKAGE_NAME (tsymbol)) == 0)\n+\t\t{\n+\t\t  CORE_ADDR func;\n \n-\t    /* Ignore data symbols that are not function\n-\t       descriptors.  */\n-\t    if (msymbol_is_function (objfile, msymbol, &func))\n-\t      return func;\n-\t  }\n-      }\n+\t\t  /* Ignore data symbols that are not function\n+\t\t     descriptors.  */\n+\t\t  if (msymbol_is_function (objfile, msymbol, &func))\n+\t\t    return func;\n+\t\t}\n+\t    }\n+\t}\n     }\n   return 0;\n }"
    },
    {
      "sha": "22c12fff3bcc3bde24f097806bab84909f3424fe",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 72,
      "deletions": 65,
      "changes": 137,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -562,8 +562,6 @@ compare_selectors (const void *a, const void *b)\n static void\n info_selectors_command (const char *regexp, int from_tty)\n {\n-  struct objfile\t*objfile;\n-  struct minimal_symbol *msymbol;\n   const char            *name;\n   char                  *val;\n   int                    matches = 0;\n@@ -607,33 +605,36 @@ info_selectors_command (const char *regexp, int from_tty)\n     }\n \n   /* First time thru is JUST to get max length and count.  */\n-  ALL_MSYMBOLS (objfile, msymbol)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n-      QUIT;\n-      name = MSYMBOL_NATURAL_NAME (msymbol);\n-      if (name\n-          && (name[0] == '-' || name[0] == '+')\n-\t  && name[1] == '[')\t\t/* Got a method name.  */\n+      for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n \t{\n-\t  /* Filter for class/instance methods.  */\n-\t  if (plusminus && name[0] != plusminus)\n-\t    continue;\n-\t  /* Find selector part.  */\n-\t  name = (char *) strchr (name+2, ' ');\n-\t  if (name == NULL)\n+\t  QUIT;\n+\t  name = MSYMBOL_NATURAL_NAME (msymbol);\n+\t  if (name\n+\t      && (name[0] == '-' || name[0] == '+')\n+\t      && name[1] == '[')\t\t/* Got a method name.  */\n \t    {\n-\t      complaint (_(\"Bad method name '%s'\"),\n-\t\t\t MSYMBOL_NATURAL_NAME (msymbol));\n-\t      continue;\n-\t    }\n-\t  if (regexp == NULL || re_exec(++name) != 0)\n-\t    { \n-\t      const char *mystart = name;\n-\t      const char *myend   = strchr (mystart, ']');\n+\t      /* Filter for class/instance methods.  */\n+\t      if (plusminus && name[0] != plusminus)\n+\t\tcontinue;\n+\t      /* Find selector part.  */\n+\t      name = (char *) strchr (name+2, ' ');\n+\t      if (name == NULL)\n+\t\t{\n+\t\t  complaint (_(\"Bad method name '%s'\"),\n+\t\t\t     MSYMBOL_NATURAL_NAME (msymbol));\n+\t\t  continue;\n+\t\t}\n+\t      if (regexp == NULL || re_exec(++name) != 0)\n+\t\t{ \n+\t\t  const char *mystart = name;\n+\t\t  const char *myend   = strchr (mystart, ']');\n \t      \n-\t      if (myend && (myend - mystart > maxlen))\n-\t\tmaxlen = myend - mystart;\t/* Get longest selector.  */\n-\t      matches++;\n+\t\t  if (myend && (myend - mystart > maxlen))\n+\t\t    maxlen = myend - mystart;\t/* Get longest selector.  */\n+\t\t  matches++;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -644,21 +645,24 @@ info_selectors_command (const char *regexp, int from_tty)\n \n       sym_arr = XALLOCAVEC (struct symbol *, matches);\n       matches = 0;\n-      ALL_MSYMBOLS (objfile, msymbol)\n+      for (objfile *objfile : all_objfiles (current_program_space))\n \t{\n-\t  QUIT;\n-\t  name = MSYMBOL_NATURAL_NAME (msymbol);\n-\t  if (name &&\n-\t     (name[0] == '-' || name[0] == '+') &&\n-\t      name[1] == '[')\t\t/* Got a method name.  */\n+\t  for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n \t    {\n-\t      /* Filter for class/instance methods.  */\n-\t      if (plusminus && name[0] != plusminus)\n-\t\tcontinue;\n-\t      /* Find selector part.  */\n-\t      name = (char *) strchr(name+2, ' ');\n-\t      if (regexp == NULL || re_exec(++name) != 0)\n-\t\tsym_arr[matches++] = (struct symbol *) msymbol;\n+\t      QUIT;\n+\t      name = MSYMBOL_NATURAL_NAME (msymbol);\n+\t      if (name &&\n+\t\t  (name[0] == '-' || name[0] == '+') &&\n+\t\t  name[1] == '[')\t\t/* Got a method name.  */\n+\t\t{\n+\t\t  /* Filter for class/instance methods.  */\n+\t\t  if (plusminus && name[0] != plusminus)\n+\t\t    continue;\n+\t\t  /* Find selector part.  */\n+\t\t  name = (char *) strchr(name+2, ' ');\n+\t\t  if (regexp == NULL || re_exec(++name) != 0)\n+\t\t    sym_arr[matches++] = (struct symbol *) msymbol;\n+\t\t}\n \t    }\n \t}\n \n@@ -723,8 +727,6 @@ compare_classes (const void *a, const void *b)\n static void\n info_classes_command (const char *regexp, int from_tty)\n {\n-  struct objfile\t*objfile;\n-  struct minimal_symbol *msymbol;\n   const char            *name;\n   char                  *val;\n   int                    matches = 0;\n@@ -757,39 +759,45 @@ info_classes_command (const char *regexp, int from_tty)\n     }\n \n   /* First time thru is JUST to get max length and count.  */\n-  ALL_MSYMBOLS (objfile, msymbol)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n-      QUIT;\n-      name = MSYMBOL_NATURAL_NAME (msymbol);\n-      if (name &&\n-\t (name[0] == '-' || name[0] == '+') &&\n-\t  name[1] == '[')\t\t\t/* Got a method name.  */\n-\tif (regexp == NULL || re_exec(name+2) != 0)\n-\t  { \n-\t    /* Compute length of classname part.  */\n-\t    const char *mystart = name + 2;\n-\t    const char *myend   = strchr (mystart, ' ');\n+      for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n+\t{\n+\t  QUIT;\n+\t  name = MSYMBOL_NATURAL_NAME (msymbol);\n+\t  if (name &&\n+\t      (name[0] == '-' || name[0] == '+') &&\n+\t      name[1] == '[')\t\t\t/* Got a method name.  */\n+\t    if (regexp == NULL || re_exec(name+2) != 0)\n+\t      { \n+\t\t/* Compute length of classname part.  */\n+\t\tconst char *mystart = name + 2;\n+\t\tconst char *myend   = strchr (mystart, ' ');\n \t    \n-\t    if (myend && (myend - mystart > maxlen))\n-\t      maxlen = myend - mystart;\n-\t    matches++;\n-\t  }\n+\t\tif (myend && (myend - mystart > maxlen))\n+\t\t  maxlen = myend - mystart;\n+\t\tmatches++;\n+\t      }\n+\t}\n     }\n   if (matches)\n     {\n       printf_filtered (_(\"Classes matching \\\"%s\\\":\\n\\n\"), \n \t\t       regexp ? regexp : \"*\");\n       sym_arr = XALLOCAVEC (struct symbol *, matches);\n       matches = 0;\n-      ALL_MSYMBOLS (objfile, msymbol)\n+      for (objfile *objfile : all_objfiles (current_program_space))\n \t{\n-\t  QUIT;\n-\t  name = MSYMBOL_NATURAL_NAME (msymbol);\n-\t  if (name &&\n-\t     (name[0] == '-' || name[0] == '+') &&\n-\t      name[1] == '[')\t\t\t/* Got a method name.  */\n-\t    if (regexp == NULL || re_exec(name+2) != 0)\n-\t\tsym_arr[matches++] = (struct symbol *) msymbol;\n+\t  for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n+\t    {\n+\t      QUIT;\n+\t      name = MSYMBOL_NATURAL_NAME (msymbol);\n+\t      if (name &&\n+\t\t  (name[0] == '-' || name[0] == '+') &&\n+\t\t  name[1] == '[') /* Got a method name.  */\n+\t\tif (regexp == NULL || re_exec(name+2) != 0)\n+\t\t  sym_arr[matches++] = (struct symbol *) msymbol;\n+\t    }\n \t}\n \n       qsort (sym_arr, matches, sizeof (struct minimal_symbol *), \n@@ -987,7 +995,6 @@ find_methods (char type, const char *theclass, const char *category,\n   for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       unsigned int *objc_csym;\n-      struct minimal_symbol *msymbol = NULL;\n \n       /* The objfile_csym variable counts the number of ObjC methods\n \t that this objfile defines.  We save that count as a private\n@@ -1001,7 +1008,7 @@ find_methods (char type, const char *theclass, const char *category,\n \t/* There are no ObjC symbols in this objfile.  Skip it entirely.  */\n \tcontinue;\n \n-      ALL_OBJFILE_MSYMBOLS (objfile, msymbol)\n+      for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n \t{\n \t  QUIT;\n "
    },
    {
      "sha": "a3b0e9213550ff6db53947dc08a0259f9bf7f8d2",
      "filename": "gdb/objfiles.h",
      "status": "modified",
      "additions": 78,
      "deletions": 12,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/objfiles.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/objfiles.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.h?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -623,12 +623,85 @@ class all_objfiles_safe\n #define ALL_OBJFILE_COMPUNITS(objfile, cu) \\\n   for ((cu) = (objfile) -> compunit_symtabs; (cu) != NULL; (cu) = (cu) -> next)\n \n-/* Traverse all minimal symbols in one objfile.  */\n+/* A range adapter that makes it possible to iterate over all\n+   minimal symbols of an objfile.  */\n \n-#define\tALL_OBJFILE_MSYMBOLS(objfile, m)\t\\\n-    for ((m) = (objfile)->per_bfd->msymbols;\t\\\n-\t MSYMBOL_LINKAGE_NAME (m) != NULL;\t\\\n-\t (m)++)\n+class objfile_msymbols\n+{\n+public:\n+\n+  explicit objfile_msymbols (struct objfile *objfile)\n+    : m_objfile (objfile)\n+  {\n+  }\n+\n+  struct iterator\n+  {\n+    typedef iterator self_type;\n+    typedef struct minimal_symbol *value_type;\n+    typedef struct minimal_symbol *&reference;\n+    typedef struct minimal_symbol **pointer;\n+    typedef std::forward_iterator_tag iterator_category;\n+    typedef int difference_type;\n+\n+    explicit iterator (struct objfile *objfile)\n+      : m_msym (objfile->per_bfd->msymbols)\n+    {\n+      /* Make sure to properly handle the case where there are no\n+\t minsyms.  */\n+      if (MSYMBOL_LINKAGE_NAME (m_msym) == nullptr)\n+\tm_msym = nullptr;\n+    }\n+\n+    iterator ()\n+      : m_msym (nullptr)\n+    {\n+    }\n+    \n+    value_type operator* () const\n+    {\n+      return m_msym;\n+    }\n+\n+    bool operator== (const self_type &other) const\n+    {\n+      return m_msym == other.m_msym;\n+    }\n+\n+    bool operator!= (const self_type &other) const\n+    {\n+      return m_msym != other.m_msym;\n+    }\n+\n+    self_type &operator++ ()\n+    {\n+      if (m_msym != nullptr)\n+\t{\n+\t  ++m_msym;\n+\t  if (MSYMBOL_LINKAGE_NAME (m_msym) == nullptr)\n+\t    m_msym = nullptr;\n+\t}\n+      return *this;\n+    }\n+\n+  private:\n+    struct minimal_symbol *m_msym;\n+  };\n+\n+  iterator begin () const\n+  {\n+    return iterator (m_objfile);\n+  }\n+\n+  iterator end () const\n+  {\n+    return iterator ();\n+  }\n+\n+private:\n+\n+  struct objfile *m_objfile;\n+};\n \n /* Traverse all symtabs in all objfiles in the current symbol\n    space.  */\n@@ -643,13 +716,6 @@ class all_objfiles_safe\n   ALL_OBJFILES (objfile)\t\t\\\n     ALL_OBJFILE_COMPUNITS (objfile, cu)\n \n-/* Traverse all minimal symbols in all objfiles in the current symbol\n-   space.  */\n-\n-#define\tALL_MSYMBOLS(objfile, m) \\\n-  ALL_OBJFILES (objfile)\t \\\n-    ALL_OBJFILE_MSYMBOLS (objfile, m)\n-\n #define ALL_OBJFILE_OSECTIONS(objfile, osect)\t\\\n   for (osect = objfile->sections; osect < objfile->sections_end; osect++) \\\n     if (osect->the_bfd_section == NULL)\t\t\t\t\t\\"
    },
    {
      "sha": "daba7cb98b6946ed6d832eab97728db8aa36c881",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -4573,7 +4573,6 @@ void\n scan_file_globals (struct objfile *objfile)\n {\n   int hash;\n-  struct minimal_symbol *msymbol;\n   struct symbol *sym, *prev;\n   struct objfile *resolve_objfile;\n \n@@ -4599,7 +4598,7 @@ scan_file_globals (struct objfile *objfile)\n       if (hash >= HASHSIZE)\n \treturn;\n \n-      ALL_OBJFILE_MSYMBOLS (resolve_objfile, msymbol)\n+      for (minimal_symbol *msymbol : objfile_msymbols (resolve_objfile))\n \t{\n \t  QUIT;\n "
    },
    {
      "sha": "24f9176a8a12c8f7353bf6d399457605eb7f285a",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -183,7 +183,6 @@ static void\n dump_msymbols (struct objfile *objfile, struct ui_file *outfile)\n {\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n-  struct minimal_symbol *msymbol;\n   int index;\n   char ms_type;\n \n@@ -194,7 +193,7 @@ dump_msymbols (struct objfile *objfile, struct ui_file *outfile)\n       return;\n     }\n   index = 0;\n-  ALL_OBJFILE_MSYMBOLS (objfile, msymbol)\n+  for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n     {\n       struct obj_section *section = MSYMBOL_OBJ_SECTION (objfile, msymbol);\n "
    },
    {
      "sha": "8bd91bc84797c41866f7920b2155c4e53a381edd",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 127,
      "deletions": 110,
      "changes": 237,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5325b9bf1ee283c40f076334eb3ea66e1f0a6ade/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=5325b9bf1ee283c40f076334eb3ea66e1f0a6ade",
      "patch": "@@ -4344,8 +4344,6 @@ search_symbols (const char *regexp, enum search_domain kind,\n   int i = 0;\n   struct block_iterator iter;\n   struct symbol *sym;\n-  struct objfile *objfile;\n-  struct minimal_symbol *msymbol;\n   int found_misc = 0;\n   static const enum minimal_symbol_type types[]\n     = {mst_data, mst_text, mst_abs};\n@@ -4454,81 +4452,93 @@ search_symbols (const char *regexp, enum search_domain kind,\n \n   if (nfiles == 0 && (kind == VARIABLES_DOMAIN || kind == FUNCTIONS_DOMAIN))\n     {\n-      ALL_MSYMBOLS (objfile, msymbol)\n-      {\n-        QUIT;\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\t{\n+\t  for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n+\t    {\n+\t      QUIT;\n \n-\tif (msymbol->created_by_gdb)\n-\t  continue;\n+\t      if (msymbol->created_by_gdb)\n+\t\tcontinue;\n \n-\tif (MSYMBOL_TYPE (msymbol) == ourtype\n-\t    || MSYMBOL_TYPE (msymbol) == ourtype2\n-\t    || MSYMBOL_TYPE (msymbol) == ourtype3\n-\t    || MSYMBOL_TYPE (msymbol) == ourtype4)\n-\t  {\n-\t    if (!preg.has_value ()\n-\t\t|| preg->exec (MSYMBOL_NATURAL_NAME (msymbol), 0,\n-\t\t\t       NULL, 0) == 0)\n-\t      {\n-\t\t/* Note: An important side-effect of these lookup functions\n-\t\t   is to expand the symbol table if msymbol is found, for the\n-\t\t   benefit of the next loop on ALL_COMPUNITS.  */\n-\t\tif (kind == FUNCTIONS_DOMAIN\n-\t\t    ? (find_pc_compunit_symtab\n-\t\t       (MSYMBOL_VALUE_ADDRESS (objfile, msymbol)) == NULL)\n-\t\t    : (lookup_symbol_in_objfile_from_linkage_name\n-\t\t       (objfile, MSYMBOL_LINKAGE_NAME (msymbol), VAR_DOMAIN)\n-\t\t       .symbol == NULL))\n-\t\t  found_misc = 1;\n-\t      }\n-\t  }\n-      }\n+\t      if (MSYMBOL_TYPE (msymbol) == ourtype\n+\t\t  || MSYMBOL_TYPE (msymbol) == ourtype2\n+\t\t  || MSYMBOL_TYPE (msymbol) == ourtype3\n+\t\t  || MSYMBOL_TYPE (msymbol) == ourtype4)\n+\t\t{\n+\t\t  if (!preg.has_value ()\n+\t\t      || preg->exec (MSYMBOL_NATURAL_NAME (msymbol), 0,\n+\t\t\t\t     NULL, 0) == 0)\n+\t\t    {\n+\t\t      /* Note: An important side-effect of these\n+\t\t\t lookup functions is to expand the symbol\n+\t\t\t table if msymbol is found, for the benefit of\n+\t\t\t the next loop on ALL_COMPUNITS.  */\n+\t\t      if (kind == FUNCTIONS_DOMAIN\n+\t\t\t  ? (find_pc_compunit_symtab\n+\t\t\t     (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n+\t\t\t     == NULL)\n+\t\t\t  : (lookup_symbol_in_objfile_from_linkage_name\n+\t\t\t     (objfile, MSYMBOL_LINKAGE_NAME (msymbol),\n+\t\t\t      VAR_DOMAIN)\n+\t\t\t     .symbol == NULL))\n+\t\t\tfound_misc = 1;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n     }\n \n-  ALL_COMPUNITS (objfile, cust)\n   {\n-    bv = COMPUNIT_BLOCKVECTOR (cust);\n-    for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)\n+    struct objfile *objfile;\n+    ALL_COMPUNITS (objfile, cust)\n       {\n-\tb = BLOCKVECTOR_BLOCK (bv, i);\n-\tALL_BLOCK_SYMBOLS (b, iter, sym)\n+\tbv = COMPUNIT_BLOCKVECTOR (cust);\n+\tfor (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)\n \t  {\n-\t    struct symtab *real_symtab = symbol_symtab (sym);\n-\n-\t    QUIT;\n-\n-\t    /* Check first sole REAL_SYMTAB->FILENAME.  It does not need to be\n-\t       a substring of symtab_to_fullname as it may contain \"./\" etc.  */\n-\t    if ((file_matches (real_symtab->filename, files, nfiles, 0)\n-\t\t || ((basenames_may_differ\n-\t\t      || file_matches (lbasename (real_symtab->filename),\n-\t\t\t\t       files, nfiles, 1))\n-\t\t     && file_matches (symtab_to_fullname (real_symtab),\n-\t\t\t\t      files, nfiles, 0)))\n-\t\t&& ((!preg.has_value ()\n-\t\t     || preg->exec (SYMBOL_NATURAL_NAME (sym), 0,\n-\t\t\t\t    NULL, 0) == 0)\n-\t\t    && ((kind == VARIABLES_DOMAIN\n-\t\t\t && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n-\t\t\t && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n-\t\t\t && SYMBOL_CLASS (sym) != LOC_BLOCK\n-\t\t\t /* LOC_CONST can be used for more than just enums,\n-\t\t\t    e.g., c++ static const members.\n-\t\t\t    We only want to skip enums here.  */\n-\t\t\t && !(SYMBOL_CLASS (sym) == LOC_CONST\n-\t\t\t      && (TYPE_CODE (SYMBOL_TYPE (sym))\n-\t\t\t\t  == TYPE_CODE_ENUM))\n-\t\t\t && (!treg.has_value ()\n-\t\t\t     || treg_matches_sym_type_name (*treg, sym)))\n-\t\t\t|| (kind == FUNCTIONS_DOMAIN\n-\t\t\t    && SYMBOL_CLASS (sym) == LOC_BLOCK\n-\t\t\t    && (!treg.has_value ()\n-\t\t\t\t|| treg_matches_sym_type_name (*treg, sym)))\n-\t\t\t|| (kind == TYPES_DOMAIN\n-\t\t\t    && SYMBOL_CLASS (sym) == LOC_TYPEDEF))))\n+\t    b = BLOCKVECTOR_BLOCK (bv, i);\n+\t    ALL_BLOCK_SYMBOLS (b, iter, sym)\n \t      {\n-\t\t/* match */\n-\t\tresult.emplace_back (i, sym);\n+\t\tstruct symtab *real_symtab = symbol_symtab (sym);\n+\n+\t\tQUIT;\n+\n+\t\t/* Check first sole REAL_SYMTAB->FILENAME.  It does\n+\t\t   not need to be a substring of symtab_to_fullname as\n+\t\t   it may contain \"./\" etc.  */\n+\t\tif ((file_matches (real_symtab->filename, files, nfiles, 0)\n+\t\t     || ((basenames_may_differ\n+\t\t\t  || file_matches (lbasename (real_symtab->filename),\n+\t\t\t\t\t   files, nfiles, 1))\n+\t\t\t && file_matches (symtab_to_fullname (real_symtab),\n+\t\t\t\t\t  files, nfiles, 0)))\n+\t\t    && ((!preg.has_value ()\n+\t\t\t || preg->exec (SYMBOL_NATURAL_NAME (sym), 0,\n+\t\t\t\t\tNULL, 0) == 0)\n+\t\t\t&& ((kind == VARIABLES_DOMAIN\n+\t\t\t     && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n+\t\t\t     && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n+\t\t\t     && SYMBOL_CLASS (sym) != LOC_BLOCK\n+\t\t\t     /* LOC_CONST can be used for more than\n+\t\t\t\tjust enums, e.g., c++ static const\n+\t\t\t\tmembers.  We only want to skip enums\n+\t\t\t\there.  */\n+\t\t\t     && !(SYMBOL_CLASS (sym) == LOC_CONST\n+\t\t\t\t  && (TYPE_CODE (SYMBOL_TYPE (sym))\n+\t\t\t\t      == TYPE_CODE_ENUM))\n+\t\t\t     && (!treg.has_value ()\n+\t\t\t\t || treg_matches_sym_type_name (*treg, sym)))\n+\t\t\t    || (kind == FUNCTIONS_DOMAIN\n+\t\t\t\t&& SYMBOL_CLASS (sym) == LOC_BLOCK\n+\t\t\t\t&& (!treg.has_value ()\n+\t\t\t\t    || treg_matches_sym_type_name (*treg,\n+\t\t\t\t\t\t\t\t   sym)))\n+\t\t\t    || (kind == TYPES_DOMAIN\n+\t\t\t\t&& SYMBOL_CLASS (sym) == LOC_TYPEDEF))))\n+\t\t  {\n+\t\t    /* match */\n+\t\t    result.emplace_back (i, sym);\n+\t\t  }\n \t      }\n \t  }\n       }\n@@ -4545,39 +4555,44 @@ search_symbols (const char *regexp, enum search_domain kind,\n   if ((found_misc || (nfiles == 0 && kind != FUNCTIONS_DOMAIN))\n       && !treg.has_value ())\n     {\n-      ALL_MSYMBOLS (objfile, msymbol)\n-      {\n-        QUIT;\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\t{\n+\t  for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n+\t    {\n+\t      QUIT;\n \n-\tif (msymbol->created_by_gdb)\n-\t  continue;\n+\t      if (msymbol->created_by_gdb)\n+\t\tcontinue;\n \n-\tif (MSYMBOL_TYPE (msymbol) == ourtype\n-\t    || MSYMBOL_TYPE (msymbol) == ourtype2\n-\t    || MSYMBOL_TYPE (msymbol) == ourtype3\n-\t    || MSYMBOL_TYPE (msymbol) == ourtype4)\n-\t  {\n-\t    if (!preg.has_value ()\n-\t\t|| preg->exec (MSYMBOL_NATURAL_NAME (msymbol), 0,\n-\t\t\t       NULL, 0) == 0)\n-\t      {\n-\t\t/* For functions we can do a quick check of whether the\n-\t\t   symbol might be found via find_pc_symtab.  */\n-\t\tif (kind != FUNCTIONS_DOMAIN\n-\t\t    || (find_pc_compunit_symtab\n-\t\t\t(MSYMBOL_VALUE_ADDRESS (objfile, msymbol)) == NULL))\n-\t\t  {\n-\t\t    if (lookup_symbol_in_objfile_from_linkage_name\n-\t\t\t(objfile, MSYMBOL_LINKAGE_NAME (msymbol), VAR_DOMAIN)\n-\t\t\t.symbol == NULL)\n-\t\t      {\n-\t\t\t/* match */\n-\t\t\tresult.emplace_back (i, msymbol, objfile);\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n+\t      if (MSYMBOL_TYPE (msymbol) == ourtype\n+\t\t  || MSYMBOL_TYPE (msymbol) == ourtype2\n+\t\t  || MSYMBOL_TYPE (msymbol) == ourtype3\n+\t\t  || MSYMBOL_TYPE (msymbol) == ourtype4)\n+\t\t{\n+\t\t  if (!preg.has_value ()\n+\t\t      || preg->exec (MSYMBOL_NATURAL_NAME (msymbol), 0,\n+\t\t\t\t     NULL, 0) == 0)\n+\t\t    {\n+\t\t      /* For functions we can do a quick check of whether the\n+\t\t\t symbol might be found via find_pc_symtab.  */\n+\t\t      if (kind != FUNCTIONS_DOMAIN\n+\t\t\t  || (find_pc_compunit_symtab\n+\t\t\t      (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n+\t\t\t      == NULL))\n+\t\t\t{\n+\t\t\t  if (lookup_symbol_in_objfile_from_linkage_name\n+\t\t\t      (objfile, MSYMBOL_LINKAGE_NAME (msymbol),\n+\t\t\t       VAR_DOMAIN)\n+\t\t\t      .symbol == NULL)\n+\t\t\t    {\n+\t\t\t      /* match */\n+\t\t\t      result.emplace_back (i, msymbol, objfile);\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   return result;\n@@ -5188,8 +5203,6 @@ default_collect_symbol_completion_matches_break_on\n \n   struct symbol *sym;\n   struct compunit_symtab *cust;\n-  struct minimal_symbol *msymbol;\n-  struct objfile *objfile;\n   const struct block *b;\n   const struct block *surrounding_static_block, *surrounding_global_block;\n   struct block_iterator iter;\n@@ -5259,22 +5272,26 @@ default_collect_symbol_completion_matches_break_on\n \n   if (code == TYPE_CODE_UNDEF)\n     {\n-      ALL_MSYMBOLS (objfile, msymbol)\n+      for (objfile *objfile : all_objfiles (current_program_space))\n \t{\n-\t  QUIT;\n+\t  for (minimal_symbol *msymbol : objfile_msymbols (objfile))\n+\t    {\n+\t      QUIT;\n \n-\t  if (completion_skip_symbol (mode, msymbol))\n-\t    continue;\n+\t      if (completion_skip_symbol (mode, msymbol))\n+\t\tcontinue;\n \n-\t  completion_list_add_msymbol (tracker, msymbol, lookup_name,\n-\t\t\t\t       sym_text, word);\n+\t      completion_list_add_msymbol (tracker, msymbol, lookup_name,\n+\t\t\t\t\t   sym_text, word);\n \n-\t  completion_list_objc_symbol (tracker, msymbol, lookup_name,\n-\t\t\t\t       sym_text, word);\n+\t      completion_list_objc_symbol (tracker, msymbol, lookup_name,\n+\t\t\t\t\t   sym_text, word);\n+\t    }\n \t}\n     }\n \n   /* Add completions for all currently loaded symbol tables.  */\n+  struct objfile *objfile;\n   ALL_COMPUNITS (objfile, cust)\n     add_symtab_completions (cust, tracker, mode, lookup_name,\n \t\t\t    sym_text, word, code);"
    }
  ]
}