{
  "sha": "fd486f32d15e3299b905084a697fac6349c43f76",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmQ0ODZmMzJkMTVlMzI5OWI5MDUwODRhNjk3ZmFjNjM0OWM0M2Y3Ng==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-13T02:51:15Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-13T03:56:24Z"
    },
    "message": "asan: more readelf leaks\n\n\t* elfcomm.c (get_archive_member_name): Always return malloc'd\n\tstring or NULL.\n\t* elfedit.c (process_archive): Tidy memory on all return paths.\n\t* readelf.c (process_archive): Likewise.\n\t(process_symbol_table): Likewise.\n\t(ba_cache): New, replacing ..\n\t(get_symbol_for_build_attribute): ..static vars here.  Free\n\tstrtab and symtab before loading new ones.  Reject symtab without\n\tvalid strtab in loop, breaking out of loop on valid symtab.\n\t(process_file): Free ba_cache symtab and strtab here, resetting\n\tba_cache.",
    "tree": {
      "sha": "19dd88d1110f8a2e5ef2baa44a7e180a9d3e2467",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/19dd88d1110f8a2e5ef2baa44a7e180a9d3e2467"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fd486f32d15e3299b905084a697fac6349c43f76",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd486f32d15e3299b905084a697fac6349c43f76",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fd486f32d15e3299b905084a697fac6349c43f76",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd486f32d15e3299b905084a697fac6349c43f76/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "49ba92c0a6765ee7dc3a773c1a044680d29cee0e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/49ba92c0a6765ee7dc3a773c1a044680d29cee0e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/49ba92c0a6765ee7dc3a773c1a044680d29cee0e"
    }
  ],
  "stats": {
    "total": 183,
    "additions": 121,
    "deletions": 62
  },
  "files": [
    {
      "sha": "cafd0762a651ee76dba1a93b082fdf02f45a56aa",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd486f32d15e3299b905084a697fac6349c43f76/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd486f32d15e3299b905084a697fac6349c43f76/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=fd486f32d15e3299b905084a697fac6349c43f76",
      "patch": "@@ -1,3 +1,17 @@\n+2020-03-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* elfcomm.c (get_archive_member_name): Always return malloc'd\n+\tstring or NULL.\n+\t* elfedit.c (process_archive): Tidy memory on all return paths.\n+\t* readelf.c (process_archive): Likewise.\n+\t(process_symbol_table): Likewise.\n+\t(ba_cache): New, replacing ..\n+\t(get_symbol_for_build_attribute): ..static vars here.  Free\n+\tstrtab and symtab before loading new ones.  Reject symtab without\n+\tvalid strtab in loop, breaking out of loop on valid symtab.\n+\t(process_file): Free ba_cache symtab and strtab here, resetting\n+\tba_cache.\n+\n 2020-03-12  Alan Modra  <amodra@gmail.com>\n \n \t* readelf.c (process_section_headers): Don't just set"
    },
    {
      "sha": "3060ff178e129b04e8b3f3dc6f8b69992c8b02cc",
      "filename": "binutils/elfcomm.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd486f32d15e3299b905084a697fac6349c43f76/binutils/elfcomm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd486f32d15e3299b905084a697fac6349c43f76/binutils/elfcomm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/elfcomm.c?ref=fd486f32d15e3299b905084a697fac6349c43f76",
      "patch": "@@ -797,7 +797,7 @@ get_archive_member_name (struct archive_info *arch,\n       arch->longnames[j] = '\\0';\n \n       if (!arch->is_thin_archive || arch->nested_member_origin == 0)\n-        return arch->longnames + k;\n+\treturn xstrdup (arch->longnames + k);\n \n       /* PR 17531: file: 2896dc8b.  */\n       if (k >= j)\n@@ -813,7 +813,7 @@ get_archive_member_name (struct archive_info *arch,\n       if (member_file_name != NULL\n           && setup_nested_archive (nested_arch, member_file_name) == 0)\n \t{\n-          member_name = get_archive_member_name_at (nested_arch,\n+\t  member_name = get_archive_member_name_at (nested_arch,\n \t\t\t\t\t\t    arch->nested_member_origin,\n \t\t\t\t\t\t    NULL);\n \t  if (member_name != NULL)\n@@ -825,15 +825,15 @@ get_archive_member_name (struct archive_info *arch,\n       free (member_file_name);\n \n       /* Last resort: just return the name of the nested archive.  */\n-      return arch->longnames + k;\n+      return xstrdup (arch->longnames + k);\n     }\n \n   /* We have a normal (short) name.  */\n   for (j = 0; j < sizeof (arch->arhdr.ar_name); j++)\n     if (arch->arhdr.ar_name[j] == '/')\n       {\n \tarch->arhdr.ar_name[j] = '\\0';\n-\treturn arch->arhdr.ar_name;\n+\treturn xstrdup (arch->arhdr.ar_name);\n       }\n \n   /* The full ar_name field is used.  Don't rely on ar_date starting"
    },
    {
      "sha": "3a14c60ece62b2c4a1f2dd524dff08608c7f9ad4",
      "filename": "binutils/elfedit.c",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd486f32d15e3299b905084a697fac6349c43f76/binutils/elfedit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd486f32d15e3299b905084a697fac6349c43f76/binutils/elfedit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/elfedit.c?ref=fd486f32d15e3299b905084a697fac6349c43f76",
      "patch": "@@ -616,6 +616,7 @@ process_archive (const char * file_name, FILE * file,\n       if (qualified_name == NULL)\n \t{\n \t  error (_(\"%s: bad archive file name\\n\"), file_name);\n+\t  free (name);\n \t  ret = 1;\n \t  break;\n \t}\n@@ -626,8 +627,10 @@ process_archive (const char * file_name, FILE * file,\n           FILE *member_file;\n           char *member_file_name = adjust_relative_path (file_name,\n \t\t\t\t\t\t\t name, namelen);\n+\t  free (name);\n           if (member_file_name == NULL)\n             {\n+\t      free (qualified_name);\n               ret = 1;\n               break;\n             }\n@@ -638,6 +641,7 @@ process_archive (const char * file_name, FILE * file,\n               error (_(\"Input file '%s' is not readable\\n\"),\n \t\t\t member_file_name);\n               free (member_file_name);\n+\t      free (qualified_name);\n               ret = 1;\n               break;\n             }\n@@ -648,9 +652,12 @@ process_archive (const char * file_name, FILE * file,\n \n           fclose (member_file);\n           free (member_file_name);\n+\t  free (qualified_name);\n         }\n       else if (is_thin_archive)\n         {\n+\t  free (name);\n+\n           /* This is a proxy for a member of a nested archive.  */\n           archive_file_offset = arch.nested_member_origin + sizeof arch.arhdr;\n \n@@ -661,6 +668,7 @@ process_archive (const char * file_name, FILE * file,\n             {\n               error (_(\"%s: failed to seek to archive member\\n\"),\n \t\t\t nested_arch.file_name);\n+\t      free (qualified_name);\n               ret = 1;\n               break;\n             }\n@@ -669,6 +677,7 @@ process_archive (const char * file_name, FILE * file,\n         }\n       else\n         {\n+\t  free (name);\n           archive_file_offset = arch.next_arhdr_offset;\n           arch.next_arhdr_offset += archive_file_size;\n "
    },
    {
      "sha": "4e21bdb56c9125e4940cb0baa6d244560aa2cab5",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 94,
      "deletions": 58,
      "changes": 152,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd486f32d15e3299b905084a697fac6349c43f76/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd486f32d15e3299b905084a697fac6349c43f76/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=fd486f32d15e3299b905084a697fac6349c43f76",
      "patch": "@@ -11766,17 +11766,17 @@ process_symbol_table (Filedata * filedata)\n       buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n       chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n \n-    no_hash:\n       if (buckets == NULL || chains == NULL)\n \t{\n-\t  if (do_using_dynamic)\n-\t    return FALSE;\n+\tno_hash:\n \t  free (buckets);\n \t  free (chains);\n \t  buckets = NULL;\n \t  chains = NULL;\n \t  nbuckets = 0;\n \t  nchains = 0;\n+\t  if (do_using_dynamic)\n+\t    goto err_out;\n \t}\n     }\n \n@@ -11833,7 +11833,7 @@ process_symbol_table (Filedata * filedata)\n \tif (gnubuckets[i] != 0)\n \t  {\n \t    if (gnubuckets[i] < gnusymidx)\n-\t      return FALSE;\n+\t      goto err_out;\n \n \t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n \t      maxchain = gnubuckets[i];\n@@ -11898,21 +11898,17 @@ process_symbol_table (Filedata * filedata)\n \t    }\n \n \t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n-\t}\n-\n-    no_gnu_hash:\n-      if (dynamic_info_DT_MIPS_XHASH && mipsxlat == NULL)\n-\t{\n-\t  free (gnuchains);\n-\t  gnuchains = NULL;\n-\t}\n-      if (gnuchains == NULL)\n-\t{\n-\t  free (gnubuckets);\n-\t  gnubuckets = NULL;\n-\t  ngnubuckets = 0;\n-\t  if (do_using_dynamic)\n-\t    return FALSE;\n+\t  if (mipsxlat == NULL)\n+\t    {\n+\t    no_gnu_hash:\n+\t      free (gnuchains);\n+\t      gnuchains = NULL;\n+\t      free (gnubuckets);\n+\t      gnubuckets = NULL;\n+\t      ngnubuckets = 0;\n+\t      if (do_using_dynamic)\n+\t\tgoto err_out;\n+\t    }\n \t}\n     }\n \n@@ -12129,7 +12125,7 @@ process_symbol_table (Filedata * filedata)\n       if (lengths == NULL)\n \t{\n \t  error (_(\"Out of memory allocating space for histogram buckets\\n\"));\n-\t  return FALSE;\n+\t  goto err_out;\n \t}\n       visited = xcmalloc (nchains, 1);\n       memset (visited, 0, nchains);\n@@ -12157,7 +12153,7 @@ process_symbol_table (Filedata * filedata)\n \t{\n \t  free (lengths);\n \t  error (_(\"Out of memory allocating space for histogram counts\\n\"));\n-\t  return FALSE;\n+\t  goto err_out;\n \t}\n \n       for (hn = 0; hn < nbuckets; ++hn)\n@@ -12181,11 +12177,10 @@ process_symbol_table (Filedata * filedata)\n       free (lengths);\n     }\n \n-  if (buckets != NULL)\n-    {\n-      free (buckets);\n-      free (chains);\n-    }\n+  free (buckets);\n+  buckets = NULL;\n+  free (chains);\n+  chains = NULL;\n \n   if (do_histogram && gnubuckets != NULL)\n     {\n@@ -12208,7 +12203,7 @@ process_symbol_table (Filedata * filedata)\n       if (lengths == NULL)\n \t{\n \t  error (_(\"Out of memory allocating space for gnu histogram buckets\\n\"));\n-\t  return FALSE;\n+\t  goto err_out;\n \t}\n \n       printf (_(\" Length  Number     %% of total  Coverage\\n\"));\n@@ -12234,7 +12229,7 @@ process_symbol_table (Filedata * filedata)\n \t{\n \t  free (lengths);\n \t  error (_(\"Out of memory allocating space for gnu histogram counts\\n\"));\n-\t  return FALSE;\n+\t  goto err_out;\n \t}\n \n       for (hn = 0; hn < ngnubuckets; ++hn)\n@@ -12256,12 +12251,19 @@ process_symbol_table (Filedata * filedata)\n \n       free (counts);\n       free (lengths);\n-      free (gnubuckets);\n-      free (gnuchains);\n-      free (mipsxlat);\n     }\n-\n+  free (gnubuckets);\n+  free (gnuchains);\n+  free (mipsxlat);\n   return TRUE;\n+\n+ err_out:\n+  free (gnubuckets);\n+  free (gnuchains);\n+  free (mipsxlat);\n+  free (buckets);\n+  free (chains);\n+  return FALSE;\n }\n \n static bfd_boolean\n@@ -18773,6 +18775,14 @@ print_ia64_vms_note (Elf_Internal_Note * pnote)\n   return FALSE;\n }\n \n+struct build_attr_cache {\n+  Filedata *filedata;\n+  char *strtab;\n+  unsigned long strtablen;\n+  Elf_Internal_Sym *symtab;\n+  unsigned long nsyms;\n+} ba_cache;\n+\n /* Find the symbol associated with a build attribute that is attached\n    to address OFFSET.  If PNAME is non-NULL then store the name of\n    the symbol (if found) in the provided pointer,  Returns NULL if a\n@@ -18784,61 +18794,72 @@ get_symbol_for_build_attribute (Filedata *       filedata,\n \t\t\t\tbfd_boolean      is_open_attr,\n \t\t\t\tconst char **    pname)\n {\n-  static Filedata *         saved_filedata = NULL;\n-  static char *             strtab;\n-  static unsigned long      strtablen;\n-  static Elf_Internal_Sym * symtab;\n-  static unsigned long      nsyms;\n-  Elf_Internal_Sym *        saved_sym = NULL;\n-  Elf_Internal_Sym *        sym;\n+  Elf_Internal_Sym *saved_sym = NULL;\n+  Elf_Internal_Sym *sym;\n \n   if (filedata->section_headers != NULL\n-      && (saved_filedata == NULL || filedata != saved_filedata))\n+      && (ba_cache.filedata == NULL || filedata != ba_cache.filedata))\n     {\n       Elf_Internal_Shdr * symsec;\n \n+      free (ba_cache.strtab);\n+      ba_cache.strtab = NULL;\n+      free (ba_cache.symtab);\n+      ba_cache.symtab = NULL;\n+\n       /* Load the symbol and string sections.  */\n       for (symsec = filedata->section_headers;\n \t   symsec < filedata->section_headers + filedata->file_header.e_shnum;\n \t   symsec ++)\n \t{\n \t  if (symsec->sh_type == SHT_SYMTAB)\n \t    {\n-\t      symtab = GET_ELF_SYMBOLS (filedata, symsec, & nsyms);\n+\t      ba_cache.symtab = GET_ELF_SYMBOLS (filedata, symsec,\n+\t\t\t\t\t\t &ba_cache.nsyms);\n \n-\t      if (symsec->sh_link < filedata->file_header.e_shnum)\n+\t      if (ba_cache.symtab != NULL\n+\t\t  && symsec->sh_link < filedata->file_header.e_shnum)\n \t\t{\n-\t\t  Elf_Internal_Shdr * strtab_sec = filedata->section_headers + symsec->sh_link;\n-\n-\t\t  strtab = (char *) get_data (NULL, filedata, strtab_sec->sh_offset,\n-\t\t\t\t\t      1, strtab_sec->sh_size,\n-\t\t\t\t\t      _(\"string table\"));\n-\t\t  strtablen = strtab != NULL ? strtab_sec->sh_size : 0;\n+\t\t  Elf_Internal_Shdr *strtab_sec\n+\t\t    = filedata->section_headers + symsec->sh_link;\n+\n+\t\t  ba_cache.strtab\n+\t\t    = (char *) get_data (NULL, filedata, strtab_sec->sh_offset,\n+\t\t\t\t\t 1, strtab_sec->sh_size,\n+\t\t\t\t\t _(\"string table\"));\n+\t\t  ba_cache.strtablen = strtab_sec->sh_size;\n \t\t}\n+\t      if (ba_cache.strtab == NULL)\n+\t\t{\n+\t\t  free (ba_cache.symtab);\n+\t\t  ba_cache.symtab = NULL;\n+\t\t}\n+\t      if (ba_cache.symtab != NULL)\n+\t\tbreak;\n \t    }\n \t}\n-      saved_filedata = filedata;\n+      ba_cache.filedata = filedata;\n     }\n \n-  if (symtab == NULL || strtab == NULL)\n+  if (ba_cache.symtab == NULL)\n     return NULL;\n \n   /* Find a symbol whose value matches offset.  */\n-  for (sym = symtab; sym < symtab + nsyms; sym ++)\n+  for (sym = ba_cache.symtab; sym < ba_cache.symtab + ba_cache.nsyms; sym ++)\n     if (sym->st_value == offset)\n       {\n-\tif (sym->st_name >= strtablen)\n+\tif (sym->st_name >= ba_cache.strtablen)\n \t  /* Huh ?  This should not happen.  */\n \t  continue;\n \n-\tif (strtab[sym->st_name] == 0)\n+\tif (ba_cache.strtab[sym->st_name] == 0)\n \t  continue;\n \n \t/* The AArch64 and ARM architectures define mapping symbols\n \t   (eg $d, $x, $t) which we want to ignore.  */\n-\tif (strtab[sym->st_name] == '$'\n-\t    && strtab[sym->st_name + 1] != 0\n-\t    && strtab[sym->st_name + 2] == 0)\n+\tif (ba_cache.strtab[sym->st_name] == '$'\n+\t    && ba_cache.strtab[sym->st_name + 1] != 0\n+\t    && ba_cache.strtab[sym->st_name + 2] == 0)\n \t  continue;\n \n \tif (is_open_attr)\n@@ -18855,7 +18876,7 @@ get_symbol_for_build_attribute (Filedata *       filedata,\n \t\t  {\n \t\t    /* If the symbol has a size associated\n \t\t       with it then we can stop searching.  */\n-\t\t    sym = symtab + nsyms;\n+\t\t    sym = ba_cache.symtab + ba_cache.nsyms;\n \t\t  }\n \t\tcontinue;\n \n@@ -18895,7 +18916,7 @@ get_symbol_for_build_attribute (Filedata *       filedata,\n       }\n \n   if (saved_sym && pname)\n-    * pname = strtab + saved_sym->st_name;\n+    * pname = ba_cache.strtab + saved_sym->st_name;\n \n   return saved_sym;\n }\n@@ -20238,6 +20259,7 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \t\t\t  putchar ('\\n');\n \t\t          free (qualified_name);\n \t\t        }\n+\t\t      free (member_name);\n \t\t    }\n \t\t}\n \n@@ -20340,6 +20362,7 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n       if (qualified_name == NULL)\n \t{\n \t  error (_(\"%s: bad archive file name\\n\"), arch.file_name);\n+\t  free (name);\n \t  ret = FALSE;\n \t  break;\n \t}\n@@ -20351,8 +20374,10 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n           char * member_file_name = adjust_relative_path\n \t    (filedata->file_name, name, namelen);\n \n+\t  free (name);\n           if (member_file_name == NULL)\n             {\n+\t      free (qualified_name);\n               ret = FALSE;\n               break;\n             }\n@@ -20362,6 +20387,7 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n             {\n               error (_(\"Input file '%s' is not readable.\\n\"), member_file_name);\n               free (member_file_name);\n+\t      free (qualified_name);\n               ret = FALSE;\n               break;\n             }\n@@ -20374,6 +20400,7 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \n           close_file (member_filedata);\n           free (member_file_name);\n+\t  free (qualified_name);\n         }\n       else if (is_thin_archive)\n         {\n@@ -20386,9 +20413,12 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \t    {\n \t      error (_(\"%s: contains corrupt thin archive: %s\\n\"),\n \t\t     qualified_name, name);\n+\t      free (qualified_name);\n+\t      free (name);\n \t      ret = FALSE;\n \t      break;\n \t    }\n+\t  free (name);\n \n           /* This is a proxy for a member of a nested archive.  */\n           archive_file_offset = arch.nested_member_origin + sizeof arch.arhdr;\n@@ -20398,6 +20428,7 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n           if (fseek (nested_arch.file, archive_file_offset, SEEK_SET) != 0)\n             {\n               error (_(\"%s: failed to seek to archive member.\\n\"), nested_arch.file_name);\n+\t      free (qualified_name);\n               ret = FALSE;\n               break;\n             }\n@@ -20410,6 +20441,7 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n         }\n       else\n         {\n+\t  free (name);\n           archive_file_offset = arch.next_arhdr_offset;\n           arch.next_arhdr_offset += archive_file_size;\n \n@@ -20510,6 +20542,10 @@ process_file (char * file_name)\n   free (filedata->dump_sects);\n   free (filedata);\n \n+  free (ba_cache.strtab);\n+  free (ba_cache.symtab);\n+  ba_cache.filedata = NULL;\n+\n   return ret;\n }\n "
    }
  ]
}