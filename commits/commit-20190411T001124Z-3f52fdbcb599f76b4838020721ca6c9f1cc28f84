{
  "sha": "3f52fdbcb599f76b4838020721ca6c9f1cc28f84",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2Y1MmZkYmNiNTk5Zjc2YjQ4MzgwMjA3MjFjYTZjOWYxY2MyOGY4NA==",
  "commit": {
    "author": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2019-03-16T19:40:01Z"
    },
    "committer": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2019-04-11T00:11:24Z"
    },
    "message": "Fix amd64->i386 linux syscall restart problem\n\nThis commit fixes some failures in gdb.base/interrupt.exp\nwhen debugging a 32-bit i386 linux inferior from an amd64 host.\n\nWhen running the following test...\n\n  make check RUNTESTFLAGS=\"--target_board unix/-m32 interrupt.exp\"\n\n... without this commit, I see the following output:\n\nFAIL: gdb.base/interrupt.exp: continue (the program exited)\nFAIL: gdb.base/interrupt.exp: echo data\nFAIL: gdb.base/interrupt.exp: Send Control-C, second time\nFAIL: gdb.base/interrupt.exp: signal SIGINT (the program is no longer running)\nERROR: Undefined command \"\".\nERROR: GDB process no longer exists\n\n\t\t=== gdb Summary ===\n\nWhen the test is run with this commit in place, we see 12 passes\ninstead.  This is the desired behavior.\n\nAnalysis:\n\nOn Linux, when a syscall is interrupted by a signal, the syscall\nmay return -ERESTARTSYS when a signal occurs.  Doing so indicates that\nthe syscall is restartable.  Then, depending on settings associated\nwith the signal handler, and after the signal handler is called, the\nkernel can then either return -EINTR or can cause the syscall to be\nrestarted.  In this discussion, we are concerned with the latter\ncase.\n\nOn i386, the kernel returns this status via the EAX register.\n\nWhen debugging a 32-bit (i386) process from a 64-bit (amd64)\nGDB, the debugger fetches 64-bit registers even though the\nprocess being debugged is 32-bit.  Since we're debugging a 32-bit\ntarget, only 32 bits are being saved in the register cache.\nNow, ideally, GDB would save all 64-bits in the regcache and\nthen would be able to restore those same values when it comes\ntime to continue the target.  I've looked into doing this, but\nit's not easy and I don't see many benefits to doing so.  One\nbenefit, however, would be that EAX would appear as a negative\nvalue for doing syscall restarts.\n\nAt the moment, GDB is setting the high 32 bits of RAX (and other\nregisters too) to 0.  So, when GDB restores EAX just prior to\na syscall restart, the high 32 bits of RAX are zeroed, thus making\nit look like a positive value.  For this particular purpose, we\nneed to sign extend EAX so that RAX will appear as a negative\nvalue when EAX is set to -ERESTARTSYS.  This in turn will cause\nthe signal handling code in the kernel to recognize -ERESTARTSYS\nwhich will in turn cause the syscall to be restarted.\n\nThis commit is based on work by Jan Kratochvil from 2009:\n\nhttps://sourceware.org/ml/gdb-patches/2009-11/msg00592.html\n\nJan's patch had the sign extension code in amd64-nat.c.  Several\nother native targets make use of this code, so it seemed better\nto move the sign extension code to a linux specific file.  I\nalso added similar code to gdbserver.\n\nAnother approach is to fix the problem in the kernel.  Hui Zhu\ntried to get a fix into the kernel back in 2014, but it was not\naccepted.  Discussion regarding this approach may be found here:\n\nhttps://lore.kernel.org/patchwork/patch/457841/\n\nEven if a fix were to be put into the kernel, we'd still need\nsome kind of fix in GDB in order to support older kernels.\n\nFinally, I'll note that Fedora has been carrying a similar patch for\nat least nine years.  Other distributions, including RHEL and CentOS\nhave picked up this change and have been using it too.\n\ngdb/ChangeLog:\n\n\t* amd64-linux-nat.c (amd64_linux_collect_native_gregset): New\n\tfunction.\n\t(fill_gregset): Call amd64_linux_collect_native_gregset instead\n\tof amd64_collect_native_gregset.\n\t(amd64_linux_nat_target::store_registers): Likewise.\n\ngdb/gdbserver/ChangeLog:\n\n\t* linux-x86-low.c (x86_fill_gregset): Sign extend EAX value\n\twhen using a 64-bit gdbserver.",
    "tree": {
      "sha": "7ddfa1ed53a93803b0ad06c554fa89b4703cdc39",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7ddfa1ed53a93803b0ad06c554fa89b4703cdc39"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3f52fdbcb599f76b4838020721ca6c9f1cc28f84",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3f52fdbcb599f76b4838020721ca6c9f1cc28f84",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3f52fdbcb599f76b4838020721ca6c9f1cc28f84",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/comments",
  "author": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e7f0831be837c00511573e4466a57cc0b8b097d4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e7f0831be837c00511573e4466a57cc0b8b097d4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e7f0831be837c00511573e4466a57cc0b8b097d4"
    }
  ],
  "stats": {
    "total": 95,
    "additions": 93,
    "deletions": 2
  },
  "files": [
    {
      "sha": "cc6762dc7865f45bbca0f2cb47828680142662a3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3f52fdbcb599f76b4838020721ca6c9f1cc28f84",
      "patch": "@@ -1,3 +1,11 @@\n+2019-04-10  Kevin Buettner  <kevinb@redhat.com>\n+\n+\t* amd64-linux-nat.c (amd64_linux_collect_native_gregset): New\n+\tfunction.\n+\t(fill_gregset): Call amd64_linux_collect_native_gregset instead\n+\tof amd64_collect_native_gregset.\n+\t(amd64_linux_nat_target::store_registers): Likewise.\n+\n 2019-04-10  Tom Tromey  <tom@tromey.com>\n \n \t* symtab.c (lookup_global_symbol_from_objfile)"
    },
    {
      "sha": "8d0e8eb35cd2bd3af599cae48f888044d3393663",
      "filename": "gdb/amd64-linux-nat.c",
      "status": "modified",
      "additions": 67,
      "deletions": 2,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/gdb/amd64-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/gdb/amd64-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-linux-nat.c?ref=3f52fdbcb599f76b4838020721ca6c9f1cc28f84",
      "patch": "@@ -92,6 +92,71 @@ static int amd64_linux_gregset32_reg_offset[] =\n /* Transfering the general-purpose registers between GDB, inferiors\n    and core files.  */\n \n+/* See amd64_collect_native_gregset.  This linux specific version handles\n+   issues with negative EAX values not being restored correctly upon syscall\n+   return when debugging 32-bit targets.  It has no effect on 64-bit\n+   targets.  */\n+\n+static void\n+amd64_linux_collect_native_gregset (const struct regcache *regcache,\n+\t\t\t            void *gregs, int regnum)\n+{\n+  amd64_collect_native_gregset (regcache, gregs, regnum);\n+\n+  struct gdbarch *gdbarch = regcache->arch ();\n+  if (gdbarch_bfd_arch_info (gdbarch)->bits_per_word == 32)\n+    {\n+      /* Sign extend EAX value to avoid potential syscall restart\n+\t problems.  \n+\n+\t On Linux, when a syscall is interrupted by a signal, the\n+\t (kernel function implementing the) syscall may return\n+\t -ERESTARTSYS when a signal occurs.  Doing so indicates that\n+\t the syscall is restartable.  Then, depending on settings\n+\t associated with the signal handler, and after the signal\n+\t handler is called, the kernel can then either return -EINTR\n+\t or it can cause the syscall to be restarted.  We are\n+\t concerned with the latter case here.\n+\t \n+\t On (32-bit) i386, the status (-ERESTARTSYS) is placed in the\n+\t EAX register.  When debugging a 32-bit process from a 64-bit\n+\t (amd64) GDB, the debugger fetches 64-bit registers even\n+\t though the process being debugged is only 32-bit.  The\n+\t register cache is only 32 bits wide though; GDB discards the\n+\t high 32 bits when placing 64-bit values in the 32-bit\n+\t regcache.  Normally, this is not a problem since the 32-bit\n+\t process should only care about the lower 32-bit portions of\n+\t these registers.  That said, it can happen that the 64-bit\n+\t value being restored will be different from the 64-bit value\n+\t that was originally retrieved from the kernel.  The one place\n+\t (that we know of) where it does matter is in the kernel's\n+\t syscall restart code.  The kernel's code for restarting a\n+\t syscall after a signal expects to see a negative value\n+\t (specifically -ERESTARTSYS) in the 64-bit RAX register in\n+\t order to correctly cause a syscall to be restarted.\n+\t \n+\t The call to amd64_collect_native_gregset, above, is setting\n+\t the high 32 bits of RAX (and other registers too) to 0.  For\n+\t syscall restart, we need to sign extend EAX so that RAX will\n+\t appear as a negative value when EAX is set to -ERESTARTSYS. \n+\t This in turn will cause the signal handling code in the\n+\t kernel to recognize -ERESTARTSYS which will in turn cause the\n+\t syscall to be restarted.\n+\n+\t The test case gdb.base/interrupt.exp tests for this problem.\n+\t Without this sign extension code in place, it'll show\n+\t a number of failures when testing against unix/-m32.  */\n+\n+      if (regnum == -1 || regnum == I386_EAX_REGNUM)\n+\t{\n+\t  void *ptr = ((gdb_byte *) gregs \n+\t\t       + amd64_linux_gregset32_reg_offset[I386_EAX_REGNUM]);\n+\n+\t  *(int64_t *) ptr = *(int32_t *) ptr;\n+\t}\n+    }\n+}\n+\n /* Fill GDB's register cache with the general-purpose register values\n    in *GREGSETP.  */\n \n@@ -109,7 +174,7 @@ void\n fill_gregset (const struct regcache *regcache,\n \t      elf_gregset_t *gregsetp, int regnum)\n {\n-  amd64_collect_native_gregset (regcache, gregsetp, regnum);\n+  amd64_linux_collect_native_gregset (regcache, gregsetp, regnum);\n }\n \n /* Transfering floating-point registers between GDB, inferiors and cores.  */\n@@ -237,7 +302,7 @@ amd64_linux_nat_target::store_registers (struct regcache *regcache, int regnum)\n       if (ptrace (PTRACE_GETREGS, tid, 0, (long) &regs) < 0)\n \tperror_with_name (_(\"Couldn't get registers\"));\n \n-      amd64_collect_native_gregset (regcache, &regs, regnum);\n+      amd64_linux_collect_native_gregset (regcache, &regs, regnum);\n \n       if (ptrace (PTRACE_SETREGS, tid, 0, (long) &regs) < 0)\n \tperror_with_name (_(\"Couldn't write registers\"));"
    },
    {
      "sha": "2a5233b663370fb3daa569d62da57af6edf05096",
      "filename": "gdb/gdbserver/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/gdb/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/gdb/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/ChangeLog?ref=3f52fdbcb599f76b4838020721ca6c9f1cc28f84",
      "patch": "@@ -1,3 +1,8 @@\n+2019-04-10  Kevin Buettner  <kevinb@redhat.com>\n+\n+\t* linux-x86-low.c (x86_fill_gregset): Sign extend EAX value\n+\twhen using a 64-bit gdbserver.\n+\n 2019-04-09  Tom Tromey  <tromey@adacore.com>\n \n \t* linux-low.c (select_event_lwp): Use find_thread_in_random."
    },
    {
      "sha": "dd7673126ed4f98e5db8ff255c1cf09b0769b8b9",
      "filename": "gdb/gdbserver/linux-x86-low.c",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/gdb/gdbserver/linux-x86-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3f52fdbcb599f76b4838020721ca6c9f1cc28f84/gdb/gdbserver/linux-x86-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-x86-low.c?ref=3f52fdbcb599f76b4838020721ca6c9f1cc28f84",
      "patch": "@@ -338,6 +338,19 @@ x86_fill_gregset (struct regcache *regcache, void *buf)\n \n   collect_register_by_name (regcache, \"orig_eax\",\n \t\t\t    ((char *) buf) + ORIG_EAX * REGSIZE);\n+\n+  /* Sign extend EAX value to avoid potential syscall restart\n+     problems. \n+\n+     See amd64_linux_collect_native_gregset() in gdb/amd64-linux-nat.c\n+     for a detailed explanation.  */\n+  if (register_size (regcache->tdesc, 0) == 4)\n+    {\n+      void *ptr = ((gdb_byte *) buf\n+                   + i386_regmap[find_regno (regcache->tdesc, \"eax\")]);\n+\n+      *(int64_t *) ptr = *(int32_t *) ptr;\n+    }\n }\n \n static void"
    }
  ]
}