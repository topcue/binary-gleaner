{
  "sha": "2c0e48e5b797de474ef2e19f4146349065833138",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmMwZTQ4ZTViNzk3ZGU0NzRlZjJlMTlmNDE0NjM0OTA2NTgzMzEzOA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-23T07:36:23Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-23T07:36:23Z"
    },
    "message": "asan: vms-alpha: heap-buffer-overflow\n\nTwo buffer overflows, and some over restrictive length checks.\n\n\t* vms-alpha.c (add_symbol): Add \"max\" parameter.  Error on string\n\tlength larger than max.\n\t(_bfd_vms_slurp_egsd): Ensure record is at least large enough to\n\tread string length byte, error if not.  Pass size to add_symbol.\n\t(_bfd_vms_slurp_etir): Don't read past end of buffer when reading\n\ttype and length.  Allow read of last byte in buffer.",
    "tree": {
      "sha": "1ad1808d21261921afd1cde473bee5da21fce877",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1ad1808d21261921afd1cde473bee5da21fce877"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2c0e48e5b797de474ef2e19f4146349065833138",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c0e48e5b797de474ef2e19f4146349065833138",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2c0e48e5b797de474ef2e19f4146349065833138",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c0e48e5b797de474ef2e19f4146349065833138/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7936714c0c5030f872ced475f848692ce835708a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7936714c0c5030f872ced475f848692ce835708a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7936714c0c5030f872ced475f848692ce835708a"
    }
  ],
  "stats": {
    "total": 65,
    "additions": 49,
    "deletions": 16
  },
  "files": [
    {
      "sha": "073bbb6f2b2321bec85f6a9136f8c0bf769c2334",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c0e48e5b797de474ef2e19f4146349065833138/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c0e48e5b797de474ef2e19f4146349065833138/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=2c0e48e5b797de474ef2e19f4146349065833138",
      "patch": "@@ -1,3 +1,12 @@\n+2019-12-23  Alan Modra  <amodra@gmail.com>\n+\n+\t* vms-alpha.c (add_symbol): Add \"max\" parameter.  Error on string\n+\tlength larger than max.\n+\t(_bfd_vms_slurp_egsd): Ensure record is at least large enough to\n+\tread string length byte, error if not.  Pass size to add_symbol.\n+\t(_bfd_vms_slurp_etir): Don't read past end of buffer when reading\n+\ttype and length.  Allow read of last byte in buffer.\n+\n 2019-12-23  Alan Modra  <amodra@gmail.com>\n \n \t* wasm-module.c (wasm_read_leb128): Don't allow oversize shifts."
    },
    {
      "sha": "0b1b4ca8d8b93ada9a402d0a36d2e0fa95bbf774",
      "filename": "bfd/vms-alpha.c",
      "status": "modified",
      "additions": 40,
      "deletions": 16,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c0e48e5b797de474ef2e19f4146349065833138/bfd/vms-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c0e48e5b797de474ef2e19f4146349065833138/bfd/vms-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-alpha.c?ref=2c0e48e5b797de474ef2e19f4146349065833138",
      "patch": "@@ -1137,12 +1137,20 @@ add_symbol_entry (bfd *abfd, struct vms_symbol_entry *sym)\n    Return NULL in case of error.  */\n \n static struct vms_symbol_entry *\n-add_symbol (bfd *abfd, const unsigned char *ascic)\n+add_symbol (bfd *abfd, const unsigned char *ascic, unsigned int max)\n {\n   struct vms_symbol_entry *entry;\n-  int len;\n+  unsigned int len;\n \n   len = *ascic++;\n+  max -= 1;\n+  if (len > max)\n+    {\n+      _bfd_error_handler (_(\"record is too small for symbol name length\"));\n+      bfd_set_error (bfd_error_bad_value);\n+      return NULL;\n+    }\n+\n   entry = (struct vms_symbol_entry *)bfd_zalloc (abfd, sizeof (*entry) + len);\n   if (entry == NULL)\n     return NULL;\n@@ -1292,7 +1300,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \n \tcase EGSD__C_SYM:\n \t  {\n-\t    int nameoff;\n+\t    unsigned int nameoff;\n \t    struct vms_symbol_entry *entry;\n \t    struct vms_egsy *egsy = (struct vms_egsy *) vms_rec;\n \t    flagword old_flags;\n@@ -1303,7 +1311,13 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \t    else\n \t      nameoff = ESRF__B_NAMLNG;\n \n-\t    entry = add_symbol (abfd, vms_rec + nameoff);\n+\t    if (nameoff >= gsd_size)\n+\t      {\n+\t\t_bfd_error_handler (_(\"ECSD__C_SYM record is too small\"));\n+\t\tbfd_set_error (bfd_error_bad_value);\n+\t\treturn FALSE;\n+\t      }\n+\t    entry = add_symbol (abfd, vms_rec + nameoff, gsd_size - nameoff);\n \t    if (entry == NULL)\n \t      return FALSE;\n \n@@ -1363,11 +1377,17 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \t    struct vms_symbol_entry *entry;\n \t    struct vms_egst *egst = (struct vms_egst *)vms_rec;\n \t    flagword old_flags;\n+\t    unsigned int nameoff = offsetof (struct vms_egst, namlng);\n \n \t    old_flags = bfd_getl16 (egst->header.flags);\n \n-\t    entry = add_symbol (abfd, &egst->namlng);\n-\n+\t    if (nameoff >= gsd_size)\n+\t      {\n+\t\t_bfd_error_handler (_(\"ECSD__C_SYMG record is too small\"));\n+\t\tbfd_set_error (bfd_error_bad_value);\n+\t\treturn FALSE;\n+\t      }\n+\t    entry = add_symbol (abfd, &egst->namlng, gsd_size - nameoff);\n \t    if (entry == NULL)\n \t      return FALSE;\n \n@@ -1854,19 +1874,23 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \n   while (ptr < maxptr)\n     {\n-      int cmd = bfd_getl16 (ptr);\n-      int cmd_length = bfd_getl16 (ptr + 2);\n+      int cmd, cmd_length;\n \n-      ptr += 4;\n+      if (ptr + 4 > maxptr)\n+\tgoto corrupt_etir;\n+\n+      cmd = bfd_getl16 (ptr);\n+      cmd_length = bfd_getl16 (ptr + 2);\n \n       /* PR 21589 and 21579: Check for a corrupt ETIR record.  */\n-      if (cmd_length < 4 || (ptr + cmd_length > maxptr + 4))\n+      if (cmd_length < 4 || ptr + cmd_length > maxptr)\n \t{\n \tcorrupt_etir:\n \t  _bfd_error_handler (_(\"corrupt ETIR record encountered\"));\n \t  bfd_set_error (bfd_error_bad_value);\n \t  return FALSE;\n \t}\n+      ptr += 4;\n \n #if VMS_DEBUG\n       _bfd_vms_debug (4, \"etir: %s(%d)\\n\",\n@@ -1890,7 +1914,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \n \t     stack 32 bit value, sign extend to 64 bit.  */\n \tcase ETIR__C_STA_LW:\n-\t  if (ptr + 4 >= maxptr)\n+\t  if (ptr + 4 > maxptr)\n \t    goto corrupt_etir;\n \t  _bfd_vms_push (abfd, bfd_getl32 (ptr), RELC_NONE);\n \t  break;\n@@ -1900,7 +1924,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \n \t     stack 64 bit value of symbol.  */\n \tcase ETIR__C_STA_QW:\n-\t  if (ptr + 8 >= maxptr)\n+\t  if (ptr + 8 > maxptr)\n \t    goto corrupt_etir;\n \t  _bfd_vms_push (abfd, bfd_getl64 (ptr), RELC_NONE);\n \t  break;\n@@ -1915,7 +1939,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  {\n \t    int psect;\n \n-\t    if (ptr + 12 >= maxptr)\n+\t    if (ptr + 12 > maxptr)\n \t      goto corrupt_etir;\n \t    psect = bfd_getl32 (ptr);\n \t    if ((unsigned int) psect >= PRIV (section_count))\n@@ -2006,7 +2030,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  {\n \t    int size;\n \n-\t    if (ptr + 4 >= maxptr)\n+\t    if (ptr + 4 > maxptr)\n \t      goto corrupt_etir;\n \t    size = bfd_getl32 (ptr);\n \t    _bfd_vms_pop (abfd, &op1, &rel1);\n@@ -2089,7 +2113,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  {\n \t    unsigned int size;\n \n-\t    if (ptr + 4 >= maxptr)\n+\t    if (ptr + 4 > maxptr)\n \t      goto corrupt_etir;\n \t    size = bfd_getl32 (ptr);\n \t    image_write (abfd, ptr + 4, size);\n@@ -2252,7 +2276,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Augment relocation base: increment image location counter by offset\n \t     arg: lw\toffset value.  */\n \tcase ETIR__C_CTL_AUGRB:\n-\t  if (ptr + 4 >= maxptr)\n+\t  if (ptr + 4 > maxptr)\n \t    goto corrupt_etir;\n \t  op1 = bfd_getl32 (ptr);\n \t  image_inc_ptr (abfd, op1);"
    }
  ]
}