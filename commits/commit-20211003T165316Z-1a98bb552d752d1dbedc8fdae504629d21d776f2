{
  "sha": "1a98bb552d752d1dbedc8fdae504629d21d776f2",
  "node_id": "C_kwDOANOeidoAKDFhOThiYjU1MmQ3NTJkMWRiZWRjOGZkYWU1MDQ2MjlkMjFkNzc2ZjI",
  "commit": {
    "author": {
      "name": "Lancelot SIX",
      "email": "lsix@lancelotsix.com",
      "date": "2021-09-14T22:37:25Z"
    },
    "committer": {
      "name": "Lancelot SIX",
      "email": "lsix@lancelotsix.com",
      "date": "2021-10-03T16:53:16Z"
    },
    "message": "gdb: Setting setter return a bool to tell if the value changed\n\nGDB can notify observers when a parameter is changed.\n\nTo do that, do_set_command (in gdb/cli/cli-setshow.c) compares the new\nvalue against the old one before updating it, and based on that notifies\nobservers.  This looks like something like:\n\n    int valuechanged = 0;\n    switch (cmd->var.type ())\n    {\n    case var_integer:\n      {\n        LONGEST new_val = parse_and_eval_long (arg)\n        if (new_val != cmd->var.get<int> ())\n        {\n          cmd->var.get<int> (new_val);\n          value_changes = 1;\n        }\n      }\n    case var_uinteger:\n    case var_zuinteger:\n      {\n        unsigned int val\n          = parse_cli_var_uinteger (c->var->type (), &arg, true);\n        if (c->var->get<unsigned int> () != val)\n          {\n            c->var->set<unsigned int> (val);\n            option_changed = true;\n          }\n      }\n    case...\n      /* And so on for all possible var_types.  */\n    }\n\nThis comparison is done for each possible var_type, which leads to\nunnecessary logic duplication.\n\nIn this patch I propose to move all those checks in one place within the\nsetting setter method.  This limits the code duplication and simplifies\nthe do_set_command implementation.\n\nThis patch also changes slightly the way a value change is detected.\nInstead of comparing the user provided value against the current value\nof the setting, we compare the value of the setting before and after the\nset operation.  This is meant to handle edge cases where trying to set\nan unrecognized value would be equivalent to a noop (the actual value\nremains unchanged).  Doing this requires that the original value needs\nto be copied before the update, which can be non trivial for\nstd::string.\n\nThere should be no user visible change introduced by this commit.\n\nTested on x86_64 GNU/Linux.\n\n[1] https://review.lttng.org/c/binutils-gdb/+/5831/41\n\nChange-Id: If064b9cede3eb56275aacd2b286f74eceb1aed11",
    "tree": {
      "sha": "e963b0bc4faa6aec5a34a72b33dcaee274e5da8a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e963b0bc4faa6aec5a34a72b33dcaee274e5da8a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1a98bb552d752d1dbedc8fdae504629d21d776f2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1a98bb552d752d1dbedc8fdae504629d21d776f2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1a98bb552d752d1dbedc8fdae504629d21d776f2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1a98bb552d752d1dbedc8fdae504629d21d776f2/comments",
  "author": {
    "login": "lsix",
    "id": 724339,
    "node_id": "MDQ6VXNlcjcyNDMzOQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/724339?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lsix",
    "html_url": "https://github.com/lsix",
    "followers_url": "https://api.github.com/users/lsix/followers",
    "following_url": "https://api.github.com/users/lsix/following{/other_user}",
    "gists_url": "https://api.github.com/users/lsix/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lsix/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lsix/subscriptions",
    "organizations_url": "https://api.github.com/users/lsix/orgs",
    "repos_url": "https://api.github.com/users/lsix/repos",
    "events_url": "https://api.github.com/users/lsix/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lsix/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "lsix",
    "id": 724339,
    "node_id": "MDQ6VXNlcjcyNDMzOQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/724339?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lsix",
    "html_url": "https://github.com/lsix",
    "followers_url": "https://api.github.com/users/lsix/followers",
    "following_url": "https://api.github.com/users/lsix/following{/other_user}",
    "gists_url": "https://api.github.com/users/lsix/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lsix/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lsix/subscriptions",
    "organizations_url": "https://api.github.com/users/lsix/orgs",
    "repos_url": "https://api.github.com/users/lsix/repos",
    "events_url": "https://api.github.com/users/lsix/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lsix/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "702991711a91bd47b209289562843a11e7009396",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/702991711a91bd47b209289562843a11e7009396",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/702991711a91bd47b209289562843a11e7009396"
    }
  ],
  "stats": {
    "total": 93,
    "additions": 21,
    "deletions": 72
  },
  "files": [
    {
      "sha": "42c2b15b3928d73e075a0f3b71d5ff6eaa8fa469",
      "filename": "gdb/cli/cli-setshow.c",
      "status": "modified",
      "additions": 13,
      "deletions": 70,
      "changes": 83,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1a98bb552d752d1dbedc8fdae504629d21d776f2/gdb/cli/cli-setshow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1a98bb552d752d1dbedc8fdae504629d21d776f2/gdb/cli/cli-setshow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-setshow.c?ref=1a98bb552d752d1dbedc8fdae504629d21d776f2",
      "patch": "@@ -360,26 +360,12 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \t*q++ = '\\0';\n \tnewobj = (char *) xrealloc (newobj, q - newobj);\n \n-\tconst std::string &cur_val = c->var->get<std::string> ();\n-\tif (strcmp (cur_val.c_str(),  newobj) != 0)\n-\t  {\n-\t    c->var->set<std::string> (std::string (newobj));\n-\n-\t    option_changed = true;\n-\t  }\n+\toption_changed = c->var->set<std::string> (std::string (newobj));\n \txfree (newobj);\n       }\n       break;\n     case var_string_noescape:\n-      {\n-\tconst std::string &cur_val = c->var->get<std::string> ();\n-\tif (strcmp (cur_val.c_str (), arg) != 0)\n-\t  {\n-\t    c->var->set<std::string> (std::string (arg));\n-\n-\t    option_changed = true;\n-\t  }\n-      }\n+      option_changed = c->var->set<std::string> (std::string (arg));\n       break;\n     case var_filename:\n       if (*arg == '\\0')\n@@ -405,13 +391,8 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \telse\n \t  val = xstrdup (\"\");\n \n-\tconst std::string &cur_val = c->var->get<std::string> ();\n-\tif (strcmp (cur_val.c_str (), val) != 0)\n-\t  {\n-\t    c->var->set<std::string> (std::string (val));\n-\n-\t    option_changed = true;\n-\t  }\n+\toption_changed\n+\t  = c->var->set<std::string> (std::string (val));\n \txfree (val);\n       }\n       break;\n@@ -421,39 +402,18 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \n \tif (val < 0)\n \t  error (_(\"\\\"on\\\" or \\\"off\\\" expected.\"));\n-\tif (val != c->var->get<bool> ())\n-\t  {\n-\t    c->var->set<bool> (val);\n \n-\t    option_changed = true;\n-\t  }\n+\toption_changed = c->var->set<bool> (val);\n       }\n       break;\n     case var_auto_boolean:\n-      {\n-\tenum auto_boolean val = parse_auto_binary_operation (arg);\n-\n-\tif (c->var->get<enum auto_boolean> () != val)\n-\t  {\n-\t    c->var->set<enum auto_boolean> (val);\n-\n-\t    option_changed = true;\n-\t  }\n-      }\n+      option_changed = c->var->set<enum auto_boolean> (parse_auto_binary_operation (arg));\n       break;\n     case var_uinteger:\n     case var_zuinteger:\n-      {\n-\tunsigned int val\n-\t  = parse_cli_var_uinteger (c->var->type (), &arg, true);\n-\n-\tif (c->var->get<unsigned int> () != val)\n-\t  {\n-\t    c->var->set<unsigned int> (val);\n-\n-\t    option_changed = true;\n-\t  }\n-      }\n+      option_changed\n+\t= c->var->set<unsigned int> (parse_cli_var_uinteger (c->var->type (),\n+\t\t\t\t\t\t\t     &arg, true));\n       break;\n     case var_integer:\n     case var_zinteger:\n@@ -483,12 +443,7 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \t\t || (c->var->type () == var_zinteger && val > INT_MAX))\n \t  error (_(\"integer %s out of range\"), plongest (val));\n \n-\tif (c->var->get<int> () != val)\n-\t  {\n-\t    c->var->set<int> (val);\n-\n-\t    option_changed = true;\n-\t  }\n+\toption_changed = c->var->set<int> (val);\n       }\n       break;\n     case var_enum:\n@@ -501,24 +456,12 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \tif (*after != '\\0')\n \t  error (_(\"Junk after item \\\"%.*s\\\": %s\"), len, arg, after);\n \n-\tif (c->var->get<const char *> () != match)\n-\t  {\n-\t    c->var->set<const char *> (match);\n-\n-\t    option_changed = true;\n-\t  }\n+\toption_changed = c->var->set<const char *> (match);\n       }\n       break;\n     case var_zuinteger_unlimited:\n-      {\n-\tint val = parse_cli_var_zuinteger_unlimited (&arg, true);\n-\n-\tif (c->var->get<int> () != val)\n-\t  {\n-\t    c->var->set<int> (val);\n-\t    option_changed = true;\n-\t  }\n-      }\n+      option_changed = c->var->set<int>\n+\t(parse_cli_var_zuinteger_unlimited (&arg, true));\n       break;\n     default:\n       error (_(\"gdb internal error: bad var_type in do_setshow_command\"));"
    },
    {
      "sha": "7c226f193b805d5f076c89cf29193c18b4f58e41",
      "filename": "gdb/command.h",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1a98bb552d752d1dbedc8fdae504629d21d776f2/gdb/command.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1a98bb552d752d1dbedc8fdae504629d21d776f2/gdb/command.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/command.h?ref=1a98bb552d752d1dbedc8fdae504629d21d776f2",
      "patch": "@@ -300,7 +300,9 @@ struct setting\n       return *static_cast<const T *> (m_var);\n   }\n \n-  /* Sets the value of the setting to V.\n+  /* Sets the value of the setting to V.  Returns true if the setting was\n+     effectively changed, false if the update failed and the setting is left\n+     unchanged.\n \n      If we have a user-provided setter, use it to set the setting.  Otherwise\n      copy the value V to the internally referenced buffer.\n@@ -310,12 +312,14 @@ struct setting\n \n      The var_type of the setting must match T.  */\n   template<typename T>\n-  void set (const T &v)\n+  bool set (const T &v)\n   {\n     /* Check that the current instance is of one of the supported types for\n        this instantiation.  */\n     gdb_assert (var_type_uses<T> (m_var_type));\n \n+    const T old_value = this->get<T> ();\n+\n     if (m_var == nullptr)\n       {\n \tgdb_assert (m_setter != nullptr);\n@@ -324,6 +328,8 @@ struct setting\n       }\n     else\n       *static_cast<T *> (m_var) = v;\n+\n+    return old_value != this->get<T> ();\n   }\n \n private:"
    }
  ]
}