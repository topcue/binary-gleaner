{
  "sha": "446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDQ2ZjdlZDVhYmZkMmQwYmVkOGM0NDQyZDA2MzRiMWE4YmMxMTZmNA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-19T02:44:45Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-19T02:44:45Z"
    },
    "message": "alloc2 used unnecessarily\n\nThe bfd_alloc2 series of functions were invented to handle cases where\nnmemb * size can overflow.  This patch changes some places where the\ncalculation can't overflow.\n\n\t* elf.c (bfd_section_from_shdr): Use bfd_zalloc rather than\n\tbfd_zalloc2.\n\t(assign_section_numbers): Likewise.\n\t(elf_map_symbols): Likewise, and bfd_alloc rather than bfd_alloc2.\n\t(_bfd_elf_map_sections_to_segments): Use bfd_malloc rather than\n\tbfd_malloc2, size_t amt, and unsigned tls_count.\n\t(rewrite_elf_program_header): Use bfd_malloc and size_t amt.\n\t* elflink.c (elf_create_symbuf): Use bfd_malloc.\n\t(elf_output_implib): Use bfd_alloc.",
    "tree": {
      "sha": "8e1fac2505e01df41dc5991026fb3733f03442bb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8e1fac2505e01df41dc5991026fb3733f03442bb"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b03202e32c8235997b3485b0b4655926ad97a1cc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b03202e32c8235997b3485b0b4655926ad97a1cc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b03202e32c8235997b3485b0b4655926ad97a1cc"
    }
  ],
  "stats": {
    "total": 61,
    "additions": 39,
    "deletions": 22
  },
  "files": [
    {
      "sha": "a1ef28c035fee66f7547cbec60cadabca8db249d",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
      "patch": "@@ -1,3 +1,15 @@\n+2020-02-19  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf.c (bfd_section_from_shdr): Use bfd_zalloc rather than\n+\tbfd_zalloc2.\n+\t(assign_section_numbers): Likewise.\n+\t(elf_map_symbols): Likewise, and bfd_alloc rather than bfd_alloc2.\n+\t(_bfd_elf_map_sections_to_segments): Use bfd_malloc rather than\n+\tbfd_malloc2, size_t amt, and unsigned tls_count.\n+\t(rewrite_elf_program_header): Use bfd_malloc and size_t amt.\n+\t* elflink.c (elf_create_symbuf): Use bfd_malloc.\n+\t(elf_output_implib): Use bfd_alloc.\n+\n 2020-02-19  Alan Modra  <amodra@gmail.com>\n \n \t* bfd.c (struct bfd): Move format and direction to other"
    },
    {
      "sha": "8f18daf687c27bbb64e9ab91d8b49dd803d05824",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 21,
      "deletions": 18,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
      "patch": "@@ -2069,8 +2069,8 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)\n \tsections_being_created = NULL;\n       if (sections_being_created == NULL)\n \t{\n-\t  sections_being_created = (bfd_boolean *)\n-\t    bfd_zalloc2 (abfd, elf_numsections (abfd), sizeof (bfd_boolean));\n+\t  size_t amt = elf_numsections (abfd) * sizeof (bfd_boolean);\n+\t  sections_being_created = (bfd_boolean *) bfd_zalloc (abfd, amt);\n \t  if (sections_being_created == NULL)\n \t    return FALSE;\n \t  sections_being_created_abfd = abfd;\n@@ -3723,6 +3723,7 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)\n   Elf_Internal_Shdr **i_shdrp;\n   struct bfd_elf_section_data *d;\n   bfd_boolean need_symtab;\n+  size_t amt;\n \n   section_number = 1;\n \n@@ -3830,8 +3831,8 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)\n \n   /* Set up the list of section header pointers, in agreement with the\n      indices.  */\n-  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc2 (abfd, section_number,\n-\t\t\t\t\t\tsizeof (Elf_Internal_Shdr *));\n+  amt = section_number * sizeof (Elf_Internal_Shdr *);\n+  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc (abfd, amt);\n   if (i_shdrp == NULL)\n     return FALSE;\n \n@@ -4150,6 +4151,7 @@ elf_map_symbols (bfd *abfd, unsigned int *pnum_locals)\n   unsigned int idx;\n   asection *asect;\n   asymbol **new_syms;\n+  size_t amt;\n \n #ifdef DEBUG\n   fprintf (stderr, \"elf_map_symbols\\n\");\n@@ -4163,7 +4165,8 @@ elf_map_symbols (bfd *abfd, unsigned int *pnum_locals)\n     }\n \n   max_index++;\n-  sect_syms = (asymbol **) bfd_zalloc2 (abfd, max_index, sizeof (asymbol *));\n+  amt = max_index * sizeof (asymbol *);\n+  sect_syms = (asymbol **) bfd_zalloc (abfd, amt);\n   if (sect_syms == NULL)\n     return FALSE;\n   elf_section_syms (abfd) = sect_syms;\n@@ -4214,9 +4217,8 @@ elf_map_symbols (bfd *abfd, unsigned int *pnum_locals)\n     }\n \n   /* Now sort the symbols so the local symbols are first.  */\n-  new_syms = (asymbol **) bfd_alloc2 (abfd, num_locals + num_globals,\n-\t\t\t\t      sizeof (asymbol *));\n-\n+  amt = (num_locals + num_globals) * sizeof (asymbol *);\n+  new_syms = (asymbol **) bfd_alloc (abfd, amt);\n   if (new_syms == NULL)\n     return FALSE;\n \n@@ -4680,18 +4682,18 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n       bfd_boolean phdr_in_segment;\n       bfd_boolean writable;\n       bfd_boolean executable;\n-      int tls_count = 0;\n+      unsigned int tls_count = 0;\n       asection *first_tls = NULL;\n       asection *first_mbind = NULL;\n       asection *dynsec, *eh_frame_hdr;\n-      bfd_size_type amt;\n+      size_t amt;\n       bfd_vma addr_mask, wrap_to = 0;\n       bfd_size_type phdr_size;\n \n       /* Select the allocated sections, and sort them.  */\n \n-      sections = (asection **) bfd_malloc2 (bfd_count_sections (abfd),\n-\t\t\t\t\t    sizeof (asection *));\n+      amt = bfd_count_sections (abfd) * sizeof (asection *);\n+      sections = (asection **) bfd_malloc (amt);\n       if (sections == NULL)\n \tgoto error_return;\n \n@@ -5076,15 +5078,15 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n \t  m->p_flags = PF_R;\n \t  m->p_flags_valid = 1;\n \t  s = first_tls;\n-\t  for (i = 0; i < (unsigned int) tls_count; ++i)\n+\t  for (i = 0; i < tls_count; ++i)\n \t    {\n \t      if ((s->flags & SEC_THREAD_LOCAL) == 0)\n \t\t{\n \t\t  _bfd_error_handler\n \t\t    (_(\"%pB: TLS sections are not adjacent:\"), abfd);\n \t\t  s = first_tls;\n \t\t  i = 0;\n-\t\t  while (i < (unsigned int) tls_count)\n+\t\t  while (i < tls_count)\n \t\t    {\n \t\t      if ((s->flags & SEC_THREAD_LOCAL) != 0)\n \t\t\t{\n@@ -7029,7 +7031,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n       asection *matching_lma;\n       asection *suggested_lma;\n       unsigned int j;\n-      bfd_size_type amt;\n+      size_t amt;\n       asection *first_section;\n \n       if (segment->p_type == PT_NULL)\n@@ -7055,7 +7057,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n       /* Allocate a segment map big enough to contain\n \t all of the sections we have selected.  */\n       amt = sizeof (struct elf_segment_map) - sizeof (asection *);\n-      amt += (bfd_size_type) section_count * sizeof (asection *);\n+      amt += section_count * sizeof (asection *);\n       map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);\n       if (map == NULL)\n \treturn FALSE;\n@@ -7147,7 +7149,8 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \t pointers that we are interested in.  As these sections get assigned\n \t to a segment, they are removed from this array.  */\n \n-      sections = (asection **) bfd_malloc2 (section_count, sizeof (asection *));\n+      amt = section_count * sizeof (asection *);\n+      sections = (asection **) bfd_malloc (amt);\n       if (sections == NULL)\n \treturn FALSE;\n \n@@ -7376,7 +7379,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \t\t segments.  Create a new segment here, initialise it\n \t\t and carry on looping.  */\n \t      amt = sizeof (struct elf_segment_map) - sizeof (asection *);\n-\t      amt += (bfd_size_type) section_count * sizeof (asection *);\n+\t      amt += section_count * sizeof (asection *);\n \t      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);\n \t      if (map == NULL)\n \t\t{"
    },
    {
      "sha": "1656978e07ec4775a452775d520c8a6689430246",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
      "patch": "@@ -7931,9 +7931,10 @@ elf_create_symbuf (size_t symcount, Elf_Internal_Sym *isymbuf)\n   Elf_Internal_Sym **ind, **indbufend, **indbuf;\n   struct elf_symbuf_symbol *ssym;\n   struct elf_symbuf_head *ssymbuf, *ssymhead;\n-  size_t i, shndx_count, total_size;\n+  size_t i, shndx_count, total_size, amt;\n \n-  indbuf = (Elf_Internal_Sym **) bfd_malloc2 (symcount, sizeof (*indbuf));\n+  amt = symcount * sizeof (*indbuf);\n+  indbuf = (Elf_Internal_Sym **) bfd_malloc (amt);\n   if (indbuf == NULL)\n     return NULL;\n \n@@ -11657,6 +11658,7 @@ elf_output_implib (bfd *abfd, struct bfd_link_info *info)\n   long symcount;\n   long src_count;\n   elf_symbol_type *osymbuf;\n+  size_t amt;\n \n   implib_bfd = info->out_implib_bfd;\n   bed = get_elf_backend_data (abfd);\n@@ -11714,8 +11716,8 @@ elf_output_implib (bfd *abfd, struct bfd_link_info *info)\n \n \n   /* Make symbols absolute.  */\n-  osymbuf = (elf_symbol_type *) bfd_alloc2 (implib_bfd, symcount,\n-\t\t\t\t\t    sizeof (*osymbuf));\n+  amt = symcount * sizeof (*osymbuf);\n+  osymbuf = (elf_symbol_type *) bfd_alloc (implib_bfd, amt);\n   if (osymbuf == NULL)\n     goto free_sym_buf;\n "
    }
  ]
}