{
  "sha": "2e187550373de67a20a2584d595ed9bb18e742ee",
  "node_id": "C_kwDOANOeidoAKDJlMTg3NTUwMzczZGU2N2EyMGEyNTg0ZDU5NWVkOWJiMThlNzQyZWU",
  "commit": {
    "author": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-12-02T17:20:13Z"
    },
    "committer": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-12-02T17:20:13Z"
    },
    "message": "[gdb/tdep] Fix avx512 -m32 support in gdbserver\n\nPR27257 reports a problem that can be reproduced as follows:\n- use x86_64 machine with avx512 support\n- compile a hello world with -m32 to a.out\n- start a gdbserver session with a.out\n- use gdb to connect to the gdbserver session\n\nThis makes us run into:\n...\nListening on port 2346\nRemote debugging from host ::1, port 34940\nsrc/gdbserver/regcache.cc:257: \\\n  A problem internal to GDBserver has been detected.\nUnknown register zmm16h requested\n...\n\nThe problem is that i387_xsave_to_cache in gdbserver/i387-fp.cc can't find a\nregister zmm16h in the register cache.\n\nTo understand how this happens, first some background.\n\nSSE has 16 128-bit wide xmm registers.\n\nAVX extends the SSE registers set as follows:\n- it extends the 16 existing 128-bit wide xmm registers to 256-bit wide ymm\n  registers.\n\nAVX512 extends the AVX register set as follows:\n- it extends the 16 existing 256-bit wide ymm registers to 512-bit wide zmm\n  registers.\n- it adds 16 additional 512-bit wide zmm registers (with corresponding ymm and\n  xmm subregisters added as well)\n\nHowever, in 32-bit mode, there are only 8 xmm/ymm/zmm registers.\n\nThe problem we're running into is that gdbserver/i387-fp.cc uses these\nconstants to describe the size of the register file:\n...\nstatic const int num_avx512_zmmh_low_registers = 16;\nstatic const int num_avx512_zmmh_high_registers = 16;\nstatic const int num_avx512_ymmh_registers = 16;\nstatic const int num_avx512_xmm_registers = 16;\n...\nwhich are all incorrect for the 32-bit case.\n\nFix this by replacing the constants with variables that have the appropriate\nvalues in 64-bit and 32-bit mode.\n\nTested on x86_64-linux with native and unix/-m32.",
    "tree": {
      "sha": "420767015554c93c3e9b1dcbdc7356e1c7030c4a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/420767015554c93c3e9b1dcbdc7356e1c7030c4a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2e187550373de67a20a2584d595ed9bb18e742ee",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e187550373de67a20a2584d595ed9bb18e742ee",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2e187550373de67a20a2584d595ed9bb18e742ee",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e187550373de67a20a2584d595ed9bb18e742ee/comments",
  "author": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d184a3c16a0f1c3c235713337ffb61b730e4a940",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d184a3c16a0f1c3c235713337ffb61b730e4a940",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d184a3c16a0f1c3c235713337ffb61b730e4a940"
    }
  ],
  "stats": {
    "total": 50,
    "additions": 37,
    "deletions": 13
  },
  "files": [
    {
      "sha": "9b07ded592d521c165152b921f4f61782d520091",
      "filename": "gdbserver/i387-fp.cc",
      "status": "modified",
      "additions": 37,
      "deletions": 13,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2e187550373de67a20a2584d595ed9bb18e742ee/gdbserver/i387-fp.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2e187550373de67a20a2584d595ed9bb18e742ee/gdbserver/i387-fp.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/i387-fp.cc?ref=2e187550373de67a20a2584d595ed9bb18e742ee",
      "patch": "@@ -23,10 +23,6 @@\n static const int num_mpx_bnd_registers = 4;\n static const int num_mpx_cfg_registers = 2;\n static const int num_avx512_k_registers = 8;\n-static const int num_avx512_zmmh_low_registers = 16;\n-static const int num_avx512_zmmh_high_registers = 16;\n-static const int num_avx512_ymmh_registers = 16;\n-static const int num_avx512_xmm_registers = 16;\n static const int num_pkeys_registers = 1;\n \n /* Note: These functions preserve the reserved bits in control registers.\n@@ -256,14 +252,22 @@ void\n i387_cache_to_xsave (struct regcache *regcache, void *buf)\n {\n   struct i387_xsave *fp = (struct i387_xsave *) buf;\n+  bool amd64 = register_size (regcache->tdesc, 0) == 8;\n   int i;\n   unsigned long val, val2;\n   unsigned long long xstate_bv = 0;\n   unsigned long long clear_bv = 0;\n   char raw[64];\n   char *p;\n+\n   /* Amd64 has 16 xmm regs; I386 has 8 xmm regs.  */\n-  int num_xmm_registers = register_size (regcache->tdesc, 0) == 8 ? 16 : 8;\n+  int num_xmm_registers = amd64 ? 16 : 8;\n+  /* AVX512 extends the existing xmm/ymm registers to a wider mode: zmm.  */\n+  int num_avx512_zmmh_low_registers = num_xmm_registers;\n+  /* AVX512 adds 16 extra regs in Amd64 mode, but none in I386 mode.*/\n+  int num_avx512_zmmh_high_registers = amd64 ? 16 : 0;\n+  int num_avx512_ymmh_registers = amd64 ? 16 : 0;\n+  int num_avx512_xmm_registers = amd64 ? 16 : 0;\n \n   /* The supported bits in `xstat_bv' are 8 bytes.  Clear part in\n      vector registers if its bit in xstat_bv is zero.  */\n@@ -452,7 +456,9 @@ i387_cache_to_xsave (struct regcache *regcache, void *buf)\n   /* Check if any of ZMM16H-ZMM31H registers are changed.  */\n   if ((x86_xcr0 & X86_XSTATE_ZMM))\n     {\n-      int zmm16h_regnum = find_regno (regcache->tdesc, \"zmm16h\");\n+      int zmm16h_regnum = (num_avx512_zmmh_high_registers == 0\n+\t\t\t   ? -1\n+\t\t\t   : find_regno (regcache->tdesc, \"zmm16h\"));\n \n       for (i = 0; i < num_avx512_zmmh_high_registers; i++)\n \t{\n@@ -469,7 +475,9 @@ i387_cache_to_xsave (struct regcache *regcache, void *buf)\n   /* Check if any XMM_AVX512 registers are changed.  */\n   if ((x86_xcr0 & X86_XSTATE_ZMM))\n     {\n-      int xmm_avx512_regnum = find_regno (regcache->tdesc, \"xmm16\");\n+      int xmm_avx512_regnum = (num_avx512_xmm_registers == 0\n+\t\t\t       ? -1\n+\t\t\t       : find_regno (regcache->tdesc, \"xmm16\"));\n \n       for (i = 0; i < num_avx512_xmm_registers; i++)\n \t{\n@@ -486,7 +494,9 @@ i387_cache_to_xsave (struct regcache *regcache, void *buf)\n   /* Check if any YMMH_AVX512 registers are changed.  */\n   if ((x86_xcr0 & X86_XSTATE_ZMM))\n     {\n-      int ymmh_avx512_regnum = find_regno (regcache->tdesc, \"ymm16h\");\n+      int ymmh_avx512_regnum = (num_avx512_ymmh_registers == 0\n+\t\t\t\t? -1\n+\t\t\t\t: find_regno (regcache->tdesc, \"ymm16h\"));\n \n       for (i = 0; i < num_avx512_ymmh_registers; i++)\n \t{\n@@ -710,12 +720,20 @@ i387_xsave_to_cache (struct regcache *regcache, const void *buf)\n {\n   struct i387_xsave *fp = (struct i387_xsave *) buf;\n   struct i387_fxsave *fxp = (struct i387_fxsave *) buf;\n+  bool amd64 = register_size (regcache->tdesc, 0) == 8;\n   int i, top;\n   unsigned long val;\n   unsigned long long clear_bv;\n   gdb_byte *p;\n-  /* Amd64 has 16 xmm regs; I386 has 8 xmm regs.  */\n-  int num_xmm_registers = register_size (regcache->tdesc, 0) == 8 ? 16 : 8;\n+\n+   /* Amd64 has 16 xmm regs; I386 has 8 xmm regs.  */\n+  int num_xmm_registers = amd64 ? 16 : 8;\n+  /* AVX512 extends the existing xmm/ymm registers to a wider mode: zmm.  */\n+  int num_avx512_zmmh_low_registers = num_xmm_registers;\n+  /* AVX512 adds 16 extra regs in Amd64 mode, but none in I386 mode.*/\n+  int num_avx512_zmmh_high_registers = amd64 ? 16 : 0;\n+  int num_avx512_ymmh_registers = amd64 ? 16 : 0;\n+  int num_avx512_xmm_registers = amd64 ? 16 : 0;\n \n   /* The supported bits in `xstat_bv' are 8 bytes.  Clear part in\n      vector registers if its bit in xstat_bv is zero.  */\n@@ -845,9 +863,15 @@ i387_xsave_to_cache (struct regcache *regcache, const void *buf)\n \n   if ((x86_xcr0 & X86_XSTATE_ZMM) != 0)\n     {\n-      int zmm16h_regnum = find_regno (regcache->tdesc, \"zmm16h\");\n-      int ymm16h_regnum = find_regno (regcache->tdesc, \"ymm16h\");\n-      int xmm16_regnum = find_regno (regcache->tdesc, \"xmm16\");\n+      int zmm16h_regnum = (num_avx512_zmmh_high_registers == 0\n+\t\t\t   ? -1\n+\t\t\t   : find_regno (regcache->tdesc, \"zmm16h\"));\n+      int ymm16h_regnum = (num_avx512_ymmh_registers == 0\n+\t\t\t   ? -1\n+\t\t\t   : find_regno (regcache->tdesc, \"ymm16h\"));\n+      int xmm16_regnum = (num_avx512_xmm_registers == 0\n+\t\t\t  ? -1\n+\t\t\t  : find_regno (regcache->tdesc, \"xmm16\"));\n \n       if ((clear_bv & X86_XSTATE_ZMM) != 0)\n \t{"
    }
  ]
}