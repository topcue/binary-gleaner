{
  "sha": "74fcd19c514f7beb24ab842381453efb74a8ac58",
  "node_id": "C_kwDOANOeidoAKDc0ZmNkMTljNTE0ZjdiZWIyNGFiODQyMzgxNDUzZWZiNzRhOGFjNTg",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-14T23:33:56Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-17T21:53:44Z"
    },
    "message": "Move ordinary gdbarch code to arch-utils\n\nWhile I think it makes sense to generate gdbarch.c, at the same time I\nthink it is better for ordinary code to be editable in a C file -- not\nas a hunk of C code embedded in the generator.\n\nThis patch moves this sort of code out of gdbarch.sh and gdbarch.c and\ninto arch-utils.c, then has arch-utils.c include gdbarch.c.",
    "tree": {
      "sha": "d1062a4ca2cc61219954d29bd4b83765c8ca6177",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d1062a4ca2cc61219954d29bd4b83765c8ca6177"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/74fcd19c514f7beb24ab842381453efb74a8ac58",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74fcd19c514f7beb24ab842381453efb74a8ac58",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/74fcd19c514f7beb24ab842381453efb74a8ac58",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74fcd19c514f7beb24ab842381453efb74a8ac58/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8294c9025a901ad055c979f80815465765836ae1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8294c9025a901ad055c979f80815465765836ae1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8294c9025a901ad055c979f80815465765836ae1"
    }
  ],
  "stats": {
    "total": 1516,
    "additions": 488,
    "deletions": 1028
  },
  "files": [
    {
      "sha": "d9db4245f4084805682fb2a80b99d7c48a065974",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74fcd19c514f7beb24ab842381453efb74a8ac58/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74fcd19c514f7beb24ab842381453efb74a8ac58/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=74fcd19c514f7beb24ab842381453efb74a8ac58",
      "patch": "@@ -1075,7 +1075,6 @@ COMMON_SFILES = \\\n \tgdb_bfd.c \\\n \tgdb_obstack.c \\\n \tgdb_regex.c \\\n-\tgdbarch.c \\\n \tgdbtypes.c \\\n \tgmp-utils.c \\\n \tgnu-v2-abi.c \\"
    },
    {
      "sha": "4442ec9b82f4199abf80fd33988e43a5a5254241",
      "filename": "gdb/arch-utils.c",
      "status": "modified",
      "additions": 488,
      "deletions": 0,
      "changes": 488,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74fcd19c514f7beb24ab842381453efb74a8ac58/gdb/arch-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74fcd19c514f7beb24ab842381453efb74a8ac58/gdb/arch-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.c?ref=74fcd19c514f7beb24ab842381453efb74a8ac58",
      "patch": "@@ -31,6 +31,11 @@\n #include \"objfiles.h\"\n #include \"language.h\"\n #include \"symtab.h\"\n+#include \"dummy-frame.h\"\n+#include \"frame-unwind.h\"\n+#include \"reggroups.h\"\n+#include \"auxv.h\"\n+#include \"observable.h\"\n \n #include \"gdbsupport/version.h\"\n \n@@ -1083,6 +1088,482 @@ default_read_core_file_mappings\n {\n }\n \n+/* Static function declarations */\n+\n+static void alloc_gdbarch_data (struct gdbarch *);\n+\n+/* Non-zero if we want to trace architecture code.  */\n+\n+#ifndef GDBARCH_DEBUG\n+#define GDBARCH_DEBUG 0\n+#endif\n+unsigned int gdbarch_debug = GDBARCH_DEBUG;\n+static void\n+show_gdbarch_debug (struct ui_file *file, int from_tty,\n+\t\t    struct cmd_list_element *c, const char *value)\n+{\n+  fprintf_filtered (file, _(\"Architecture debugging is %s.\\n\"), value);\n+}\n+\n+static const char *\n+pformat (const struct floatformat **format)\n+{\n+  if (format == NULL)\n+    return \"(null)\";\n+  else\n+    /* Just print out one of them - this is only for diagnostics.  */\n+    return format[0]->name;\n+}\n+\n+static const char *\n+pstring (const char *string)\n+{\n+  if (string == NULL)\n+    return \"(null)\";\n+  return string;\n+}\n+\n+static const char *\n+pstring_ptr (char **string)\n+{\n+  if (string == NULL || *string == NULL)\n+    return \"(null)\";\n+  return *string;\n+}\n+\n+/* Helper function to print a list of strings, represented as \"const\n+   char *const *\".  The list is printed comma-separated.  */\n+\n+static const char *\n+pstring_list (const char *const *list)\n+{\n+  static char ret[100];\n+  const char *const *p;\n+  size_t offset = 0;\n+\n+  if (list == NULL)\n+    return \"(null)\";\n+\n+  ret[0] = '\\0';\n+  for (p = list; *p != NULL && offset < sizeof (ret); ++p)\n+    {\n+      size_t s = xsnprintf (ret + offset, sizeof (ret) - offset, \"%s, \", *p);\n+      offset += 2 + s;\n+    }\n+\n+  if (offset > 0)\n+    {\n+      gdb_assert (offset - 2 < sizeof (ret));\n+      ret[offset - 2] = '\\0';\n+    }\n+\n+  return ret;\n+}\n+\n+#include \"gdbarch.c\"\n+\n+obstack *gdbarch_obstack (gdbarch *arch)\n+{\n+  return arch->obstack;\n+}\n+\n+/* See gdbarch.h.  */\n+\n+char *\n+gdbarch_obstack_strdup (struct gdbarch *arch, const char *string)\n+{\n+  return obstack_strdup (arch->obstack, string);\n+}\n+\n+\n+/* Free a gdbarch struct.  This should never happen in normal\n+   operation --- once you've created a gdbarch, you keep it around.\n+   However, if an architecture's init function encounters an error\n+   building the structure, it may need to clean up a partially\n+   constructed gdbarch.  */\n+\n+void\n+gdbarch_free (struct gdbarch *arch)\n+{\n+  struct obstack *obstack;\n+\n+  gdb_assert (arch != NULL);\n+  gdb_assert (!arch->initialized_p);\n+  obstack = arch->obstack;\n+  obstack_free (obstack, 0); /* Includes the ARCH.  */\n+  xfree (obstack);\n+}\n+\n+struct gdbarch_tdep *\n+gdbarch_tdep (struct gdbarch *gdbarch)\n+{\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_tdep called\\n\");\n+  return gdbarch->tdep;\n+}\n+\n+/* Keep a registry of per-architecture data-pointers required by GDB\n+   modules.  */\n+\n+struct gdbarch_data\n+{\n+  unsigned index;\n+  int init_p;\n+  gdbarch_data_pre_init_ftype *pre_init;\n+  gdbarch_data_post_init_ftype *post_init;\n+};\n+\n+struct gdbarch_data_registration\n+{\n+  struct gdbarch_data *data;\n+  struct gdbarch_data_registration *next;\n+};\n+\n+struct gdbarch_data_registry\n+{\n+  unsigned nr;\n+  struct gdbarch_data_registration *registrations;\n+};\n+\n+static struct gdbarch_data_registry gdbarch_data_registry =\n+{\n+  0, NULL,\n+};\n+\n+static struct gdbarch_data *\n+gdbarch_data_register (gdbarch_data_pre_init_ftype *pre_init,\n+\t\t       gdbarch_data_post_init_ftype *post_init)\n+{\n+  struct gdbarch_data_registration **curr;\n+\n+  /* Append the new registration.  */\n+  for (curr = &gdbarch_data_registry.registrations;\n+       (*curr) != NULL;\n+       curr = &(*curr)->next);\n+  (*curr) = XNEW (struct gdbarch_data_registration);\n+  (*curr)->next = NULL;\n+  (*curr)->data = XNEW (struct gdbarch_data);\n+  (*curr)->data->index = gdbarch_data_registry.nr++;\n+  (*curr)->data->pre_init = pre_init;\n+  (*curr)->data->post_init = post_init;\n+  (*curr)->data->init_p = 1;\n+  return (*curr)->data;\n+}\n+\n+struct gdbarch_data *\n+gdbarch_data_register_pre_init (gdbarch_data_pre_init_ftype *pre_init)\n+{\n+  return gdbarch_data_register (pre_init, NULL);\n+}\n+\n+struct gdbarch_data *\n+gdbarch_data_register_post_init (gdbarch_data_post_init_ftype *post_init)\n+{\n+  return gdbarch_data_register (NULL, post_init);\n+}\n+\n+/* Create/delete the gdbarch data vector.  */\n+\n+static void\n+alloc_gdbarch_data (struct gdbarch *gdbarch)\n+{\n+  gdb_assert (gdbarch->data == NULL);\n+  gdbarch->nr_data = gdbarch_data_registry.nr;\n+  gdbarch->data = GDBARCH_OBSTACK_CALLOC (gdbarch, gdbarch->nr_data, void *);\n+}\n+\n+/* Return the current value of the specified per-architecture\n+   data-pointer.  */\n+\n+void *\n+gdbarch_data (struct gdbarch *gdbarch, struct gdbarch_data *data)\n+{\n+  gdb_assert (data->index < gdbarch->nr_data);\n+  if (gdbarch->data[data->index] == NULL)\n+    {\n+      /* The data-pointer isn't initialized, call init() to get a\n+\t value.  */\n+      if (data->pre_init != NULL)\n+\t/* Mid architecture creation: pass just the obstack, and not\n+\t   the entire architecture, as that way it isn't possible for\n+\t   pre-init code to refer to undefined architecture\n+\t   fields.  */\n+\tgdbarch->data[data->index] = data->pre_init (gdbarch->obstack);\n+      else if (gdbarch->initialized_p\n+\t       && data->post_init != NULL)\n+\t/* Post architecture creation: pass the entire architecture\n+\t   (as all fields are valid), but be careful to also detect\n+\t   recursive references.  */\n+\t{\n+\t  gdb_assert (data->init_p);\n+\t  data->init_p = 0;\n+\t  gdbarch->data[data->index] = data->post_init (gdbarch);\n+\t  data->init_p = 1;\n+\t}\n+      else\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"gdbarch post-init data field can only be used \"\n+\t\t\t  \"after gdbarch is fully initialised\"));\n+      gdb_assert (gdbarch->data[data->index] != NULL);\n+    }\n+  return gdbarch->data[data->index];\n+}\n+\n+\n+/* Keep a registry of the architectures known by GDB.  */\n+\n+struct gdbarch_registration\n+{\n+  enum bfd_architecture bfd_architecture;\n+  gdbarch_init_ftype *init;\n+  gdbarch_dump_tdep_ftype *dump_tdep;\n+  struct gdbarch_list *arches;\n+  struct gdbarch_registration *next;\n+};\n+\n+static struct gdbarch_registration *gdbarch_registry = NULL;\n+\n+std::vector<const char *>\n+gdbarch_printable_names ()\n+{\n+  /* Accumulate a list of names based on the registed list of\n+     architectures.  */\n+  std::vector<const char *> arches;\n+\n+  for (gdbarch_registration *rego = gdbarch_registry;\n+       rego != nullptr;\n+       rego = rego->next)\n+    {\n+      const struct bfd_arch_info *ap\n+\t= bfd_lookup_arch (rego->bfd_architecture, 0);\n+      if (ap == nullptr)\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"gdbarch_architecture_names: multi-arch unknown\"));\n+      do\n+\t{\n+\t  arches.push_back (ap->printable_name);\n+\t  ap = ap->next;\n+\t}\n+      while (ap != NULL);\n+    }\n+\n+  return arches;\n+}\n+\n+\n+void\n+gdbarch_register (enum bfd_architecture bfd_architecture,\n+\t\t  gdbarch_init_ftype *init,\n+\t\t  gdbarch_dump_tdep_ftype *dump_tdep)\n+{\n+  struct gdbarch_registration **curr;\n+  const struct bfd_arch_info *bfd_arch_info;\n+\n+  /* Check that BFD recognizes this architecture */\n+  bfd_arch_info = bfd_lookup_arch (bfd_architecture, 0);\n+  if (bfd_arch_info == NULL)\n+    {\n+      internal_error (__FILE__, __LINE__,\n+\t\t      _(\"gdbarch: Attempt to register \"\n+\t\t\t\"unknown architecture (%d)\"),\n+\t\t      bfd_architecture);\n+    }\n+  /* Check that we haven't seen this architecture before.  */\n+  for (curr = &gdbarch_registry;\n+       (*curr) != NULL;\n+       curr = &(*curr)->next)\n+    {\n+      if (bfd_architecture == (*curr)->bfd_architecture)\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"gdbarch: Duplicate registration \"\n+\t\t\t  \"of architecture (%s)\"),\n+\t\t\tbfd_arch_info->printable_name);\n+    }\n+  /* log it */\n+  if (gdbarch_debug)\n+    fprintf_unfiltered (gdb_stdlog, \"register_gdbarch_init (%s, %s)\\n\",\n+\t\t\tbfd_arch_info->printable_name,\n+\t\t\thost_address_to_string (init));\n+  /* Append it */\n+  (*curr) = XNEW (struct gdbarch_registration);\n+  (*curr)->bfd_architecture = bfd_architecture;\n+  (*curr)->init = init;\n+  (*curr)->dump_tdep = dump_tdep;\n+  (*curr)->arches = NULL;\n+  (*curr)->next = NULL;\n+}\n+\n+void\n+register_gdbarch_init (enum bfd_architecture bfd_architecture,\n+\t\t       gdbarch_init_ftype *init)\n+{\n+  gdbarch_register (bfd_architecture, init, NULL);\n+}\n+\n+\n+/* Look for an architecture using gdbarch_info.  */\n+\n+struct gdbarch_list *\n+gdbarch_list_lookup_by_info (struct gdbarch_list *arches,\n+\t\t\t     const struct gdbarch_info *info)\n+{\n+  for (; arches != NULL; arches = arches->next)\n+    {\n+      if (info->bfd_arch_info != arches->gdbarch->bfd_arch_info)\n+\tcontinue;\n+      if (info->byte_order != arches->gdbarch->byte_order)\n+\tcontinue;\n+      if (info->osabi != arches->gdbarch->osabi)\n+\tcontinue;\n+      if (info->target_desc != arches->gdbarch->target_desc)\n+\tcontinue;\n+      return arches;\n+    }\n+  return NULL;\n+}\n+\n+\n+/* Find an architecture that matches the specified INFO.  Create a new\n+   architecture if needed.  Return that new architecture.  */\n+\n+struct gdbarch *\n+gdbarch_find_by_info (struct gdbarch_info info)\n+{\n+  struct gdbarch *new_gdbarch;\n+  struct gdbarch_registration *rego;\n+\n+  /* Fill in missing parts of the INFO struct using a number of\n+     sources: \"set ...\"; INFOabfd supplied; and the global\n+     defaults.  */\n+  gdbarch_info_fill (&info);\n+\n+  /* Must have found some sort of architecture.  */\n+  gdb_assert (info.bfd_arch_info != NULL);\n+\n+  if (gdbarch_debug)\n+    {\n+      fprintf_unfiltered (gdb_stdlog,\n+\t\t\t  \"gdbarch_find_by_info: info.bfd_arch_info %s\\n\",\n+\t\t\t  (info.bfd_arch_info != NULL\n+\t\t\t   ? info.bfd_arch_info->printable_name\n+\t\t\t   : \"(null)\"));\n+      fprintf_unfiltered (gdb_stdlog,\n+\t\t\t  \"gdbarch_find_by_info: info.byte_order %d (%s)\\n\",\n+\t\t\t  info.byte_order,\n+\t\t\t  (info.byte_order == BFD_ENDIAN_BIG ? \"big\"\n+\t\t\t   : info.byte_order == BFD_ENDIAN_LITTLE ? \"little\"\n+\t\t\t   : \"default\"));\n+      fprintf_unfiltered (gdb_stdlog,\n+\t\t\t  \"gdbarch_find_by_info: info.osabi %d (%s)\\n\",\n+\t\t\t  info.osabi, gdbarch_osabi_name (info.osabi));\n+      fprintf_unfiltered (gdb_stdlog,\n+\t\t\t  \"gdbarch_find_by_info: info.abfd %s\\n\",\n+\t\t\t  host_address_to_string (info.abfd));\n+    }\n+\n+  /* Find the tdep code that knows about this architecture.  */\n+  for (rego = gdbarch_registry;\n+       rego != NULL;\n+       rego = rego->next)\n+    if (rego->bfd_architecture == info.bfd_arch_info->arch)\n+      break;\n+  if (rego == NULL)\n+    {\n+      if (gdbarch_debug)\n+\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n+\t\t\t    \"No matching architecture\\n\");\n+      return 0;\n+    }\n+\n+  /* Ask the tdep code for an architecture that matches \"info\".  */\n+  new_gdbarch = rego->init (info, rego->arches);\n+\n+  /* Did the tdep code like it?  No.  Reject the change and revert to\n+     the old architecture.  */\n+  if (new_gdbarch == NULL)\n+    {\n+      if (gdbarch_debug)\n+\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n+\t\t\t    \"Target rejected architecture\\n\");\n+      return NULL;\n+    }\n+\n+  /* Is this a pre-existing architecture (as determined by already\n+     being initialized)?  Move it to the front of the architecture\n+     list (keeping the list sorted Most Recently Used).  */\n+  if (new_gdbarch->initialized_p)\n+    {\n+      struct gdbarch_list **list;\n+      struct gdbarch_list *self;\n+      if (gdbarch_debug)\n+\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n+\t\t\t    \"Previous architecture %s (%s) selected\\n\",\n+\t\t\t    host_address_to_string (new_gdbarch),\n+\t\t\t    new_gdbarch->bfd_arch_info->printable_name);\n+      /* Find the existing arch in the list.  */\n+      for (list = &rego->arches;\n+\t   (*list) != NULL && (*list)->gdbarch != new_gdbarch;\n+\t   list = &(*list)->next);\n+      /* It had better be in the list of architectures.  */\n+      gdb_assert ((*list) != NULL && (*list)->gdbarch == new_gdbarch);\n+      /* Unlink SELF.  */\n+      self = (*list);\n+      (*list) = self->next;\n+      /* Insert SELF at the front.  */\n+      self->next = rego->arches;\n+      rego->arches = self;\n+      /* Return it.  */\n+      return new_gdbarch;\n+    }\n+\n+  /* It's a new architecture.  */\n+  if (gdbarch_debug)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n+\t\t\t\"New architecture %s (%s) selected\\n\",\n+\t\t\thost_address_to_string (new_gdbarch),\n+\t\t\tnew_gdbarch->bfd_arch_info->printable_name);\n+\n+  /* Insert the new architecture into the front of the architecture\n+     list (keep the list sorted Most Recently Used).  */\n+  {\n+    struct gdbarch_list *self = XNEW (struct gdbarch_list);\n+    self->next = rego->arches;\n+    self->gdbarch = new_gdbarch;\n+    rego->arches = self;\n+  }\n+\n+  /* Check that the newly installed architecture is valid.  Plug in\n+     any post init values.  */\n+  new_gdbarch->dump_tdep = rego->dump_tdep;\n+  verify_gdbarch (new_gdbarch);\n+  new_gdbarch->initialized_p = 1;\n+\n+  if (gdbarch_debug)\n+    gdbarch_dump (new_gdbarch, gdb_stdlog);\n+\n+  return new_gdbarch;\n+}\n+\n+/* Make the specified architecture current.  */\n+\n+void\n+set_target_gdbarch (struct gdbarch *new_gdbarch)\n+{\n+  gdb_assert (new_gdbarch != NULL);\n+  gdb_assert (new_gdbarch->initialized_p);\n+  current_inferior ()->gdbarch = new_gdbarch;\n+  gdb::observers::architecture_changed.notify (new_gdbarch);\n+  registers_changed ();\n+}\n+\n+/* Return the current inferior's arch.  */\n+\n+struct gdbarch *\n+target_gdbarch (void)\n+{\n+  return current_inferior ()->gdbarch;\n+}\n+\n void _initialize_gdbarch_utils ();\n void\n _initialize_gdbarch_utils ()\n@@ -1093,4 +1574,11 @@ _initialize_gdbarch_utils ()\n \t\t\t_(\"Show endianness of target.\"),\n \t\t\tNULL, set_endian, show_endian,\n \t\t\t&setlist, &showlist);\n+  add_setshow_zuinteger_cmd (\"arch\", class_maintenance, &gdbarch_debug, _(\"\\\n+Set architecture debugging.\"), _(\"\\\n+Show architecture debugging.\"), _(\"\\\n+When non-zero, architecture debugging is enabled.\"),\n+\t\t\t    NULL,\n+\t\t\t    show_gdbarch_debug,\n+\t\t\t    &setdebuglist, &showdebuglist);\n }"
    },
    {
      "sha": "f4460a6e616d3fe742bea7f8a13cfc1550e956a8",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 0,
      "deletions": 508,
      "changes": 508,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74fcd19c514f7beb24ab842381453efb74a8ac58/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74fcd19c514f7beb24ab842381453efb74a8ac58/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=74fcd19c514f7beb24ab842381453efb74a8ac58",
      "patch": "@@ -23,97 +23,6 @@\n /* This file was created with the aid of ``gdbarch.sh''.  */\n \n \n-#include \"defs.h\"\n-#include \"arch-utils.h\"\n-\n-#include \"gdbcmd.h\"\n-#include \"inferior.h\" \n-#include \"symcat.h\"\n-\n-#include \"floatformat.h\"\n-#include \"reggroups.h\"\n-#include \"osabi.h\"\n-#include \"gdb_obstack.h\"\n-#include \"observable.h\"\n-#include \"regcache.h\"\n-#include \"objfiles.h\"\n-#include \"auxv.h\"\n-#include \"frame-unwind.h\"\n-#include \"dummy-frame.h\"\n-\n-/* Static function declarations */\n-\n-static void alloc_gdbarch_data (struct gdbarch *);\n-\n-/* Non-zero if we want to trace architecture code.  */\n-\n-#ifndef GDBARCH_DEBUG\n-#define GDBARCH_DEBUG 0\n-#endif\n-unsigned int gdbarch_debug = GDBARCH_DEBUG;\n-static void\n-show_gdbarch_debug (struct ui_file *file, int from_tty,\n-\t\t    struct cmd_list_element *c, const char *value)\n-{\n-  fprintf_filtered (file, _(\"Architecture debugging is %s.\\n\"), value);\n-}\n-\n-static const char *\n-pformat (const struct floatformat **format)\n-{\n-  if (format == NULL)\n-    return \"(null)\";\n-  else\n-    /* Just print out one of them - this is only for diagnostics.  */\n-    return format[0]->name;\n-}\n-\n-static const char *\n-pstring (const char *string)\n-{\n-  if (string == NULL)\n-    return \"(null)\";\n-  return string;\n-}\n-\n-static const char *\n-pstring_ptr (char **string)\n-{\n-  if (string == NULL || *string == NULL)\n-    return \"(null)\";\n-  return *string;\n-}\n-\n-/* Helper function to print a list of strings, represented as \"const\n-   char *const *\".  The list is printed comma-separated.  */\n-\n-static const char *\n-pstring_list (const char *const *list)\n-{\n-  static char ret[100];\n-  const char *const *p;\n-  size_t offset = 0;\n-\n-  if (list == NULL)\n-    return \"(null)\";\n-\n-  ret[0] = '\\0';\n-  for (p = list; *p != NULL && offset < sizeof (ret); ++p)\n-    {\n-      size_t s = xsnprintf (ret + offset, sizeof (ret) - offset, \"%s, \", *p);\n-      offset += 2 + s;\n-    }\n-\n-  if (offset > 0)\n-    {\n-      gdb_assert (offset - 2 < sizeof (ret));\n-      ret[offset - 2] = '\\0';\n-    }\n-\n-  return ret;\n-}\n-\n-\n /* Maintain the struct gdbarch object.  */\n \n struct gdbarch\n@@ -490,39 +399,6 @@ gdbarch_alloc (const struct gdbarch_info *info,\n \n \n \n-obstack *gdbarch_obstack (gdbarch *arch)\n-{\n-  return arch->obstack;\n-}\n-\n-/* See gdbarch.h.  */\n-\n-char *\n-gdbarch_obstack_strdup (struct gdbarch *arch, const char *string)\n-{\n-  return obstack_strdup (arch->obstack, string);\n-}\n-\n-\n-/* Free a gdbarch struct.  This should never happen in normal\n-   operation --- once you've created a gdbarch, you keep it around.\n-   However, if an architecture's init function encounters an error\n-   building the structure, it may need to clean up a partially\n-   constructed gdbarch.  */\n-\n-void\n-gdbarch_free (struct gdbarch *arch)\n-{\n-  struct obstack *obstack;\n-\n-  gdb_assert (arch != NULL);\n-  gdb_assert (!arch->initialized_p);\n-  obstack = arch->obstack;\n-  obstack_free (obstack, 0); /* Includes the ARCH.  */\n-  xfree (obstack);\n-}\n-\n-\n /* Ensure that all values in a GDBARCH are reasonable.  */\n \n static void\n@@ -1565,14 +1441,6 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n     gdbarch->dump_tdep (gdbarch, file);\n }\n \n-struct gdbarch_tdep *\n-gdbarch_tdep (struct gdbarch *gdbarch)\n-{\n-  if (gdbarch_debug >= 2)\n-    fprintf_unfiltered (gdb_stdlog, \"gdbarch_tdep called\\n\");\n-  return gdbarch->tdep;\n-}\n-\n \n const struct bfd_arch_info *\n gdbarch_bfd_arch_info (struct gdbarch *gdbarch)\n@@ -5426,379 +5294,3 @@ set_gdbarch_read_core_file_mappings (struct gdbarch *gdbarch,\n {\n   gdbarch->read_core_file_mappings = read_core_file_mappings;\n }\n-\n-\n-/* Keep a registry of per-architecture data-pointers required by GDB\n-   modules.  */\n-\n-struct gdbarch_data\n-{\n-  unsigned index;\n-  int init_p;\n-  gdbarch_data_pre_init_ftype *pre_init;\n-  gdbarch_data_post_init_ftype *post_init;\n-};\n-\n-struct gdbarch_data_registration\n-{\n-  struct gdbarch_data *data;\n-  struct gdbarch_data_registration *next;\n-};\n-\n-struct gdbarch_data_registry\n-{\n-  unsigned nr;\n-  struct gdbarch_data_registration *registrations;\n-};\n-\n-static struct gdbarch_data_registry gdbarch_data_registry =\n-{\n-  0, NULL,\n-};\n-\n-static struct gdbarch_data *\n-gdbarch_data_register (gdbarch_data_pre_init_ftype *pre_init,\n-\t\t       gdbarch_data_post_init_ftype *post_init)\n-{\n-  struct gdbarch_data_registration **curr;\n-\n-  /* Append the new registration.  */\n-  for (curr = &gdbarch_data_registry.registrations;\n-       (*curr) != NULL;\n-       curr = &(*curr)->next);\n-  (*curr) = XNEW (struct gdbarch_data_registration);\n-  (*curr)->next = NULL;\n-  (*curr)->data = XNEW (struct gdbarch_data);\n-  (*curr)->data->index = gdbarch_data_registry.nr++;\n-  (*curr)->data->pre_init = pre_init;\n-  (*curr)->data->post_init = post_init;\n-  (*curr)->data->init_p = 1;\n-  return (*curr)->data;\n-}\n-\n-struct gdbarch_data *\n-gdbarch_data_register_pre_init (gdbarch_data_pre_init_ftype *pre_init)\n-{\n-  return gdbarch_data_register (pre_init, NULL);\n-}\n-\n-struct gdbarch_data *\n-gdbarch_data_register_post_init (gdbarch_data_post_init_ftype *post_init)\n-{\n-  return gdbarch_data_register (NULL, post_init);\n-}\n-\n-/* Create/delete the gdbarch data vector.  */\n-\n-static void\n-alloc_gdbarch_data (struct gdbarch *gdbarch)\n-{\n-  gdb_assert (gdbarch->data == NULL);\n-  gdbarch->nr_data = gdbarch_data_registry.nr;\n-  gdbarch->data = GDBARCH_OBSTACK_CALLOC (gdbarch, gdbarch->nr_data, void *);\n-}\n-\n-/* Return the current value of the specified per-architecture\n-   data-pointer.  */\n-\n-void *\n-gdbarch_data (struct gdbarch *gdbarch, struct gdbarch_data *data)\n-{\n-  gdb_assert (data->index < gdbarch->nr_data);\n-  if (gdbarch->data[data->index] == NULL)\n-    {\n-      /* The data-pointer isn't initialized, call init() to get a\n-\t value.  */\n-      if (data->pre_init != NULL)\n-\t/* Mid architecture creation: pass just the obstack, and not\n-\t   the entire architecture, as that way it isn't possible for\n-\t   pre-init code to refer to undefined architecture\n-\t   fields.  */\n-\tgdbarch->data[data->index] = data->pre_init (gdbarch->obstack);\n-      else if (gdbarch->initialized_p\n-\t       && data->post_init != NULL)\n-\t/* Post architecture creation: pass the entire architecture\n-\t   (as all fields are valid), but be careful to also detect\n-\t   recursive references.  */\n-\t{\n-\t  gdb_assert (data->init_p);\n-\t  data->init_p = 0;\n-\t  gdbarch->data[data->index] = data->post_init (gdbarch);\n-\t  data->init_p = 1;\n-\t}\n-      else\n-\tinternal_error (__FILE__, __LINE__,\n-\t\t\t_(\"gdbarch post-init data field can only be used \"\n-\t\t\t  \"after gdbarch is fully initialised\"));\n-      gdb_assert (gdbarch->data[data->index] != NULL);\n-    }\n-  return gdbarch->data[data->index];\n-}\n-\n-\n-/* Keep a registry of the architectures known by GDB.  */\n-\n-struct gdbarch_registration\n-{\n-  enum bfd_architecture bfd_architecture;\n-  gdbarch_init_ftype *init;\n-  gdbarch_dump_tdep_ftype *dump_tdep;\n-  struct gdbarch_list *arches;\n-  struct gdbarch_registration *next;\n-};\n-\n-static struct gdbarch_registration *gdbarch_registry = NULL;\n-\n-std::vector<const char *>\n-gdbarch_printable_names ()\n-{\n-  /* Accumulate a list of names based on the registed list of\n-     architectures.  */\n-  std::vector<const char *> arches;\n-\n-  for (gdbarch_registration *rego = gdbarch_registry;\n-       rego != nullptr;\n-       rego = rego->next)\n-    {\n-      const struct bfd_arch_info *ap\n-\t= bfd_lookup_arch (rego->bfd_architecture, 0);\n-      if (ap == nullptr)\n-\tinternal_error (__FILE__, __LINE__,\n-\t\t\t_(\"gdbarch_architecture_names: multi-arch unknown\"));\n-      do\n-\t{\n-\t  arches.push_back (ap->printable_name);\n-\t  ap = ap->next;\n-\t}\n-      while (ap != NULL);\n-    }\n-\n-  return arches;\n-}\n-\n-\n-void\n-gdbarch_register (enum bfd_architecture bfd_architecture,\n-\t\t  gdbarch_init_ftype *init,\n-\t\t  gdbarch_dump_tdep_ftype *dump_tdep)\n-{\n-  struct gdbarch_registration **curr;\n-  const struct bfd_arch_info *bfd_arch_info;\n-\n-  /* Check that BFD recognizes this architecture */\n-  bfd_arch_info = bfd_lookup_arch (bfd_architecture, 0);\n-  if (bfd_arch_info == NULL)\n-    {\n-      internal_error (__FILE__, __LINE__,\n-\t\t      _(\"gdbarch: Attempt to register \"\n-\t\t\t\"unknown architecture (%d)\"),\n-\t\t      bfd_architecture);\n-    }\n-  /* Check that we haven't seen this architecture before.  */\n-  for (curr = &gdbarch_registry;\n-       (*curr) != NULL;\n-       curr = &(*curr)->next)\n-    {\n-      if (bfd_architecture == (*curr)->bfd_architecture)\n-\tinternal_error (__FILE__, __LINE__,\n-\t\t\t_(\"gdbarch: Duplicate registration \"\n-\t\t\t  \"of architecture (%s)\"),\n-\t\t\tbfd_arch_info->printable_name);\n-    }\n-  /* log it */\n-  if (gdbarch_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"register_gdbarch_init (%s, %s)\\n\",\n-\t\t\tbfd_arch_info->printable_name,\n-\t\t\thost_address_to_string (init));\n-  /* Append it */\n-  (*curr) = XNEW (struct gdbarch_registration);\n-  (*curr)->bfd_architecture = bfd_architecture;\n-  (*curr)->init = init;\n-  (*curr)->dump_tdep = dump_tdep;\n-  (*curr)->arches = NULL;\n-  (*curr)->next = NULL;\n-}\n-\n-void\n-register_gdbarch_init (enum bfd_architecture bfd_architecture,\n-\t\t       gdbarch_init_ftype *init)\n-{\n-  gdbarch_register (bfd_architecture, init, NULL);\n-}\n-\n-\n-/* Look for an architecture using gdbarch_info.  */\n-\n-struct gdbarch_list *\n-gdbarch_list_lookup_by_info (struct gdbarch_list *arches,\n-\t\t\t     const struct gdbarch_info *info)\n-{\n-  for (; arches != NULL; arches = arches->next)\n-    {\n-      if (info->bfd_arch_info != arches->gdbarch->bfd_arch_info)\n-\tcontinue;\n-      if (info->byte_order != arches->gdbarch->byte_order)\n-\tcontinue;\n-      if (info->osabi != arches->gdbarch->osabi)\n-\tcontinue;\n-      if (info->target_desc != arches->gdbarch->target_desc)\n-\tcontinue;\n-      return arches;\n-    }\n-  return NULL;\n-}\n-\n-\n-/* Find an architecture that matches the specified INFO.  Create a new\n-   architecture if needed.  Return that new architecture.  */\n-\n-struct gdbarch *\n-gdbarch_find_by_info (struct gdbarch_info info)\n-{\n-  struct gdbarch *new_gdbarch;\n-  struct gdbarch_registration *rego;\n-\n-  /* Fill in missing parts of the INFO struct using a number of\n-     sources: \"set ...\"; INFOabfd supplied; and the global\n-     defaults.  */\n-  gdbarch_info_fill (&info);\n-\n-  /* Must have found some sort of architecture.  */\n-  gdb_assert (info.bfd_arch_info != NULL);\n-\n-  if (gdbarch_debug)\n-    {\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"gdbarch_find_by_info: info.bfd_arch_info %s\\n\",\n-\t\t\t  (info.bfd_arch_info != NULL\n-\t\t\t   ? info.bfd_arch_info->printable_name\n-\t\t\t   : \"(null)\"));\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"gdbarch_find_by_info: info.byte_order %d (%s)\\n\",\n-\t\t\t  info.byte_order,\n-\t\t\t  (info.byte_order == BFD_ENDIAN_BIG ? \"big\"\n-\t\t\t   : info.byte_order == BFD_ENDIAN_LITTLE ? \"little\"\n-\t\t\t   : \"default\"));\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"gdbarch_find_by_info: info.osabi %d (%s)\\n\",\n-\t\t\t  info.osabi, gdbarch_osabi_name (info.osabi));\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"gdbarch_find_by_info: info.abfd %s\\n\",\n-\t\t\t  host_address_to_string (info.abfd));\n-    }\n-\n-  /* Find the tdep code that knows about this architecture.  */\n-  for (rego = gdbarch_registry;\n-       rego != NULL;\n-       rego = rego->next)\n-    if (rego->bfd_architecture == info.bfd_arch_info->arch)\n-      break;\n-  if (rego == NULL)\n-    {\n-      if (gdbarch_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n-\t\t\t    \"No matching architecture\\n\");\n-      return 0;\n-    }\n-\n-  /* Ask the tdep code for an architecture that matches \"info\".  */\n-  new_gdbarch = rego->init (info, rego->arches);\n-\n-  /* Did the tdep code like it?  No.  Reject the change and revert to\n-     the old architecture.  */\n-  if (new_gdbarch == NULL)\n-    {\n-      if (gdbarch_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n-\t\t\t    \"Target rejected architecture\\n\");\n-      return NULL;\n-    }\n-\n-  /* Is this a pre-existing architecture (as determined by already\n-     being initialized)?  Move it to the front of the architecture\n-     list (keeping the list sorted Most Recently Used).  */\n-  if (new_gdbarch->initialized_p)\n-    {\n-      struct gdbarch_list **list;\n-      struct gdbarch_list *self;\n-      if (gdbarch_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n-\t\t\t    \"Previous architecture %s (%s) selected\\n\",\n-\t\t\t    host_address_to_string (new_gdbarch),\n-\t\t\t    new_gdbarch->bfd_arch_info->printable_name);\n-      /* Find the existing arch in the list.  */\n-      for (list = &rego->arches;\n-\t   (*list) != NULL && (*list)->gdbarch != new_gdbarch;\n-\t   list = &(*list)->next);\n-      /* It had better be in the list of architectures.  */\n-      gdb_assert ((*list) != NULL && (*list)->gdbarch == new_gdbarch);\n-      /* Unlink SELF.  */\n-      self = (*list);\n-      (*list) = self->next;\n-      /* Insert SELF at the front.  */\n-      self->next = rego->arches;\n-      rego->arches = self;\n-      /* Return it.  */\n-      return new_gdbarch;\n-    }\n-\n-  /* It's a new architecture.  */\n-  if (gdbarch_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n-\t\t\t\"New architecture %s (%s) selected\\n\",\n-\t\t\thost_address_to_string (new_gdbarch),\n-\t\t\tnew_gdbarch->bfd_arch_info->printable_name);\n-  \n-  /* Insert the new architecture into the front of the architecture\n-     list (keep the list sorted Most Recently Used).  */\n-  {\n-    struct gdbarch_list *self = XNEW (struct gdbarch_list);\n-    self->next = rego->arches;\n-    self->gdbarch = new_gdbarch;\n-    rego->arches = self;\n-  }    \n-\n-  /* Check that the newly installed architecture is valid.  Plug in\n-     any post init values.  */\n-  new_gdbarch->dump_tdep = rego->dump_tdep;\n-  verify_gdbarch (new_gdbarch);\n-  new_gdbarch->initialized_p = 1;\n-\n-  if (gdbarch_debug)\n-    gdbarch_dump (new_gdbarch, gdb_stdlog);\n-\n-  return new_gdbarch;\n-}\n-\n-/* Make the specified architecture current.  */\n-\n-void\n-set_target_gdbarch (struct gdbarch *new_gdbarch)\n-{\n-  gdb_assert (new_gdbarch != NULL);\n-  gdb_assert (new_gdbarch->initialized_p);\n-  current_inferior ()->gdbarch = new_gdbarch;\n-  gdb::observers::architecture_changed.notify (new_gdbarch);\n-  registers_changed ();\n-}\n-\n-/* Return the current inferior's arch.  */\n-\n-struct gdbarch *\n-target_gdbarch (void)\n-{\n-  return current_inferior ()->gdbarch;\n-}\n-\n-void _initialize_gdbarch ();\n-void\n-_initialize_gdbarch ()\n-{\n-  add_setshow_zuinteger_cmd (\"arch\", class_maintenance, &gdbarch_debug, _(\"\\\n-Set architecture debugging.\"), _(\"\\\n-Show architecture debugging.\"), _(\"\\\n-When non-zero, architecture debugging is enabled.\"),\n-\t\t\t    NULL,\n-\t\t\t    show_gdbarch_debug,\n-\t\t\t    &setdebuglist, &showdebuglist);\n-}"
    },
    {
      "sha": "0d63462d7bb9a4a37992945f47f648bfbcf590c3",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 0,
      "deletions": 519,
      "changes": 519,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74fcd19c514f7beb24ab842381453efb74a8ac58/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74fcd19c514f7beb24ab842381453efb74a8ac58/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=74fcd19c514f7beb24ab842381453efb74a8ac58",
      "patch": "@@ -1729,99 +1729,6 @@ rm -f new-gdbarch.h\n \n exec > new-gdbarch.c\n copyright\n-cat <<EOF\n-\n-#include \"defs.h\"\n-#include \"arch-utils.h\"\n-\n-#include \"gdbcmd.h\"\n-#include \"inferior.h\" \n-#include \"symcat.h\"\n-\n-#include \"floatformat.h\"\n-#include \"reggroups.h\"\n-#include \"osabi.h\"\n-#include \"gdb_obstack.h\"\n-#include \"observable.h\"\n-#include \"regcache.h\"\n-#include \"objfiles.h\"\n-#include \"auxv.h\"\n-#include \"frame-unwind.h\"\n-#include \"dummy-frame.h\"\n-\n-/* Static function declarations */\n-\n-static void alloc_gdbarch_data (struct gdbarch *);\n-\n-/* Non-zero if we want to trace architecture code.  */\n-\n-#ifndef GDBARCH_DEBUG\n-#define GDBARCH_DEBUG 0\n-#endif\n-unsigned int gdbarch_debug = GDBARCH_DEBUG;\n-static void\n-show_gdbarch_debug (struct ui_file *file, int from_tty,\n-\t\t    struct cmd_list_element *c, const char *value)\n-{\n-  fprintf_filtered (file, _(\"Architecture debugging is %s.\\\\n\"), value);\n-}\n-\n-static const char *\n-pformat (const struct floatformat **format)\n-{\n-  if (format == NULL)\n-    return \"(null)\";\n-  else\n-    /* Just print out one of them - this is only for diagnostics.  */\n-    return format[0]->name;\n-}\n-\n-static const char *\n-pstring (const char *string)\n-{\n-  if (string == NULL)\n-    return \"(null)\";\n-  return string;\n-}\n-\n-static const char *\n-pstring_ptr (char **string)\n-{\n-  if (string == NULL || *string == NULL)\n-    return \"(null)\";\n-  return *string;\n-}\n-\n-/* Helper function to print a list of strings, represented as \"const\n-   char *const *\".  The list is printed comma-separated.  */\n-\n-static const char *\n-pstring_list (const char *const *list)\n-{\n-  static char ret[100];\n-  const char *const *p;\n-  size_t offset = 0;\n-\n-  if (list == NULL)\n-    return \"(null)\";\n-\n-  ret[0] = '\\0';\n-  for (p = list; *p != NULL && offset < sizeof (ret); ++p)\n-    {\n-      size_t s = xsnprintf (ret + offset, sizeof (ret) - offset, \"%s, \", *p);\n-      offset += 2 + s;\n-    }\n-\n-  if (offset > 0)\n-    {\n-      gdb_assert (offset - 2 < sizeof (ret));\n-      ret[offset - 2] = '\\0';\n-    }\n-\n-  return ret;\n-}\n-\n-EOF\n \n # gdbarch open the gdbarch object\n printf \"\\n\"\n@@ -1944,41 +1851,6 @@ EOF\n \n # Free a gdbarch struct.\n printf \"\\n\"\n-printf \"\\n\"\n-cat <<EOF\n-\n-obstack *gdbarch_obstack (gdbarch *arch)\n-{\n-  return arch->obstack;\n-}\n-\n-/* See gdbarch.h.  */\n-\n-char *\n-gdbarch_obstack_strdup (struct gdbarch *arch, const char *string)\n-{\n-  return obstack_strdup (arch->obstack, string);\n-}\n-\n-\n-/* Free a gdbarch struct.  This should never happen in normal\n-   operation --- once you've created a gdbarch, you keep it around.\n-   However, if an architecture's init function encounters an error\n-   building the structure, it may need to clean up a partially\n-   constructed gdbarch.  */\n-\n-void\n-gdbarch_free (struct gdbarch *arch)\n-{\n-  struct obstack *obstack;\n-\n-  gdb_assert (arch != NULL);\n-  gdb_assert (!arch->initialized_p);\n-  obstack = arch->obstack;\n-  obstack_free (obstack, 0); /* Includes the ARCH.  */\n-  xfree (obstack);\n-}\n-EOF\n \n # verify a new architecture\n cat <<EOF\n@@ -2100,17 +1972,6 @@ cat <<EOF\n EOF\n \n \n-# GET/SET\n-printf \"\\n\"\n-cat <<EOF\n-struct gdbarch_tdep *\n-gdbarch_tdep (struct gdbarch *gdbarch)\n-{\n-  if (gdbarch_debug >= 2)\n-    fprintf_unfiltered (gdb_stdlog, \"gdbarch_tdep called\\\\n\");\n-  return gdbarch->tdep;\n-}\n-EOF\n printf \"\\n\"\n function_list | while do_read\n do\n@@ -2218,386 +2079,6 @@ do\n     fi\n done\n \n-# All the trailing guff\n-cat <<EOF\n-\n-\n-/* Keep a registry of per-architecture data-pointers required by GDB\n-   modules.  */\n-\n-struct gdbarch_data\n-{\n-  unsigned index;\n-  int init_p;\n-  gdbarch_data_pre_init_ftype *pre_init;\n-  gdbarch_data_post_init_ftype *post_init;\n-};\n-\n-struct gdbarch_data_registration\n-{\n-  struct gdbarch_data *data;\n-  struct gdbarch_data_registration *next;\n-};\n-\n-struct gdbarch_data_registry\n-{\n-  unsigned nr;\n-  struct gdbarch_data_registration *registrations;\n-};\n-\n-static struct gdbarch_data_registry gdbarch_data_registry =\n-{\n-  0, NULL,\n-};\n-\n-static struct gdbarch_data *\n-gdbarch_data_register (gdbarch_data_pre_init_ftype *pre_init,\n-\t\t       gdbarch_data_post_init_ftype *post_init)\n-{\n-  struct gdbarch_data_registration **curr;\n-\n-  /* Append the new registration.  */\n-  for (curr = &gdbarch_data_registry.registrations;\n-       (*curr) != NULL;\n-       curr = &(*curr)->next);\n-  (*curr) = XNEW (struct gdbarch_data_registration);\n-  (*curr)->next = NULL;\n-  (*curr)->data = XNEW (struct gdbarch_data);\n-  (*curr)->data->index = gdbarch_data_registry.nr++;\n-  (*curr)->data->pre_init = pre_init;\n-  (*curr)->data->post_init = post_init;\n-  (*curr)->data->init_p = 1;\n-  return (*curr)->data;\n-}\n-\n-struct gdbarch_data *\n-gdbarch_data_register_pre_init (gdbarch_data_pre_init_ftype *pre_init)\n-{\n-  return gdbarch_data_register (pre_init, NULL);\n-}\n-\n-struct gdbarch_data *\n-gdbarch_data_register_post_init (gdbarch_data_post_init_ftype *post_init)\n-{\n-  return gdbarch_data_register (NULL, post_init);\n-}\n-\n-/* Create/delete the gdbarch data vector.  */\n-\n-static void\n-alloc_gdbarch_data (struct gdbarch *gdbarch)\n-{\n-  gdb_assert (gdbarch->data == NULL);\n-  gdbarch->nr_data = gdbarch_data_registry.nr;\n-  gdbarch->data = GDBARCH_OBSTACK_CALLOC (gdbarch, gdbarch->nr_data, void *);\n-}\n-\n-/* Return the current value of the specified per-architecture\n-   data-pointer.  */\n-\n-void *\n-gdbarch_data (struct gdbarch *gdbarch, struct gdbarch_data *data)\n-{\n-  gdb_assert (data->index < gdbarch->nr_data);\n-  if (gdbarch->data[data->index] == NULL)\n-    {\n-      /* The data-pointer isn't initialized, call init() to get a\n-\t value.  */\n-      if (data->pre_init != NULL)\n-\t/* Mid architecture creation: pass just the obstack, and not\n-\t   the entire architecture, as that way it isn't possible for\n-\t   pre-init code to refer to undefined architecture\n-\t   fields.  */\n-\tgdbarch->data[data->index] = data->pre_init (gdbarch->obstack);\n-      else if (gdbarch->initialized_p\n-\t       && data->post_init != NULL)\n-\t/* Post architecture creation: pass the entire architecture\n-\t   (as all fields are valid), but be careful to also detect\n-\t   recursive references.  */\n-\t{\n-\t  gdb_assert (data->init_p);\n-\t  data->init_p = 0;\n-\t  gdbarch->data[data->index] = data->post_init (gdbarch);\n-\t  data->init_p = 1;\n-\t}\n-      else\n-\tinternal_error (__FILE__, __LINE__,\n-\t\t\t_(\"gdbarch post-init data field can only be used \"\n-\t\t\t  \"after gdbarch is fully initialised\"));\n-      gdb_assert (gdbarch->data[data->index] != NULL);\n-    }\n-  return gdbarch->data[data->index];\n-}\n-\n-\n-/* Keep a registry of the architectures known by GDB.  */\n-\n-struct gdbarch_registration\n-{\n-  enum bfd_architecture bfd_architecture;\n-  gdbarch_init_ftype *init;\n-  gdbarch_dump_tdep_ftype *dump_tdep;\n-  struct gdbarch_list *arches;\n-  struct gdbarch_registration *next;\n-};\n-\n-static struct gdbarch_registration *gdbarch_registry = NULL;\n-\n-std::vector<const char *>\n-gdbarch_printable_names ()\n-{\n-  /* Accumulate a list of names based on the registed list of\n-     architectures.  */\n-  std::vector<const char *> arches;\n-\n-  for (gdbarch_registration *rego = gdbarch_registry;\n-       rego != nullptr;\n-       rego = rego->next)\n-    {\n-      const struct bfd_arch_info *ap\n-\t= bfd_lookup_arch (rego->bfd_architecture, 0);\n-      if (ap == nullptr)\n-\tinternal_error (__FILE__, __LINE__,\n-\t\t\t_(\"gdbarch_architecture_names: multi-arch unknown\"));\n-      do\n-\t{\n-\t  arches.push_back (ap->printable_name);\n-\t  ap = ap->next;\n-\t}\n-      while (ap != NULL);\n-    }\n-\n-  return arches;\n-}\n-\n-\n-void\n-gdbarch_register (enum bfd_architecture bfd_architecture,\n-\t\t  gdbarch_init_ftype *init,\n-\t\t  gdbarch_dump_tdep_ftype *dump_tdep)\n-{\n-  struct gdbarch_registration **curr;\n-  const struct bfd_arch_info *bfd_arch_info;\n-\n-  /* Check that BFD recognizes this architecture */\n-  bfd_arch_info = bfd_lookup_arch (bfd_architecture, 0);\n-  if (bfd_arch_info == NULL)\n-    {\n-      internal_error (__FILE__, __LINE__,\n-\t\t      _(\"gdbarch: Attempt to register \"\n-\t\t\t\"unknown architecture (%d)\"),\n-\t\t      bfd_architecture);\n-    }\n-  /* Check that we haven't seen this architecture before.  */\n-  for (curr = &gdbarch_registry;\n-       (*curr) != NULL;\n-       curr = &(*curr)->next)\n-    {\n-      if (bfd_architecture == (*curr)->bfd_architecture)\n-\tinternal_error (__FILE__, __LINE__,\n-\t\t\t_(\"gdbarch: Duplicate registration \"\n-\t\t\t  \"of architecture (%s)\"),\n-\t\t\tbfd_arch_info->printable_name);\n-    }\n-  /* log it */\n-  if (gdbarch_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"register_gdbarch_init (%s, %s)\\n\",\n-\t\t\tbfd_arch_info->printable_name,\n-\t\t\thost_address_to_string (init));\n-  /* Append it */\n-  (*curr) = XNEW (struct gdbarch_registration);\n-  (*curr)->bfd_architecture = bfd_architecture;\n-  (*curr)->init = init;\n-  (*curr)->dump_tdep = dump_tdep;\n-  (*curr)->arches = NULL;\n-  (*curr)->next = NULL;\n-}\n-\n-void\n-register_gdbarch_init (enum bfd_architecture bfd_architecture,\n-\t\t       gdbarch_init_ftype *init)\n-{\n-  gdbarch_register (bfd_architecture, init, NULL);\n-}\n-\n-\n-/* Look for an architecture using gdbarch_info.  */\n-\n-struct gdbarch_list *\n-gdbarch_list_lookup_by_info (struct gdbarch_list *arches,\n-\t\t\t     const struct gdbarch_info *info)\n-{\n-  for (; arches != NULL; arches = arches->next)\n-    {\n-      if (info->bfd_arch_info != arches->gdbarch->bfd_arch_info)\n-\tcontinue;\n-      if (info->byte_order != arches->gdbarch->byte_order)\n-\tcontinue;\n-      if (info->osabi != arches->gdbarch->osabi)\n-\tcontinue;\n-      if (info->target_desc != arches->gdbarch->target_desc)\n-\tcontinue;\n-      return arches;\n-    }\n-  return NULL;\n-}\n-\n-\n-/* Find an architecture that matches the specified INFO.  Create a new\n-   architecture if needed.  Return that new architecture.  */\n-\n-struct gdbarch *\n-gdbarch_find_by_info (struct gdbarch_info info)\n-{\n-  struct gdbarch *new_gdbarch;\n-  struct gdbarch_registration *rego;\n-\n-  /* Fill in missing parts of the INFO struct using a number of\n-     sources: \"set ...\"; INFOabfd supplied; and the global\n-     defaults.  */\n-  gdbarch_info_fill (&info);\n-\n-  /* Must have found some sort of architecture.  */\n-  gdb_assert (info.bfd_arch_info != NULL);\n-\n-  if (gdbarch_debug)\n-    {\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"gdbarch_find_by_info: info.bfd_arch_info %s\\n\",\n-\t\t\t  (info.bfd_arch_info != NULL\n-\t\t\t   ? info.bfd_arch_info->printable_name\n-\t\t\t   : \"(null)\"));\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"gdbarch_find_by_info: info.byte_order %d (%s)\\n\",\n-\t\t\t  info.byte_order,\n-\t\t\t  (info.byte_order == BFD_ENDIAN_BIG ? \"big\"\n-\t\t\t   : info.byte_order == BFD_ENDIAN_LITTLE ? \"little\"\n-\t\t\t   : \"default\"));\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"gdbarch_find_by_info: info.osabi %d (%s)\\n\",\n-\t\t\t  info.osabi, gdbarch_osabi_name (info.osabi));\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"gdbarch_find_by_info: info.abfd %s\\n\",\n-\t\t\t  host_address_to_string (info.abfd));\n-    }\n-\n-  /* Find the tdep code that knows about this architecture.  */\n-  for (rego = gdbarch_registry;\n-       rego != NULL;\n-       rego = rego->next)\n-    if (rego->bfd_architecture == info.bfd_arch_info->arch)\n-      break;\n-  if (rego == NULL)\n-    {\n-      if (gdbarch_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n-\t\t\t    \"No matching architecture\\n\");\n-      return 0;\n-    }\n-\n-  /* Ask the tdep code for an architecture that matches \"info\".  */\n-  new_gdbarch = rego->init (info, rego->arches);\n-\n-  /* Did the tdep code like it?  No.  Reject the change and revert to\n-     the old architecture.  */\n-  if (new_gdbarch == NULL)\n-    {\n-      if (gdbarch_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n-\t\t\t    \"Target rejected architecture\\n\");\n-      return NULL;\n-    }\n-\n-  /* Is this a pre-existing architecture (as determined by already\n-     being initialized)?  Move it to the front of the architecture\n-     list (keeping the list sorted Most Recently Used).  */\n-  if (new_gdbarch->initialized_p)\n-    {\n-      struct gdbarch_list **list;\n-      struct gdbarch_list *self;\n-      if (gdbarch_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n-\t\t\t    \"Previous architecture %s (%s) selected\\n\",\n-\t\t\t    host_address_to_string (new_gdbarch),\n-\t\t\t    new_gdbarch->bfd_arch_info->printable_name);\n-      /* Find the existing arch in the list.  */\n-      for (list = &rego->arches;\n-\t   (*list) != NULL && (*list)->gdbarch != new_gdbarch;\n-\t   list = &(*list)->next);\n-      /* It had better be in the list of architectures.  */\n-      gdb_assert ((*list) != NULL && (*list)->gdbarch == new_gdbarch);\n-      /* Unlink SELF.  */\n-      self = (*list);\n-      (*list) = self->next;\n-      /* Insert SELF at the front.  */\n-      self->next = rego->arches;\n-      rego->arches = self;\n-      /* Return it.  */\n-      return new_gdbarch;\n-    }\n-\n-  /* It's a new architecture.  */\n-  if (gdbarch_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"gdbarch_find_by_info: \"\n-\t\t\t\"New architecture %s (%s) selected\\n\",\n-\t\t\thost_address_to_string (new_gdbarch),\n-\t\t\tnew_gdbarch->bfd_arch_info->printable_name);\n-  \n-  /* Insert the new architecture into the front of the architecture\n-     list (keep the list sorted Most Recently Used).  */\n-  {\n-    struct gdbarch_list *self = XNEW (struct gdbarch_list);\n-    self->next = rego->arches;\n-    self->gdbarch = new_gdbarch;\n-    rego->arches = self;\n-  }    \n-\n-  /* Check that the newly installed architecture is valid.  Plug in\n-     any post init values.  */\n-  new_gdbarch->dump_tdep = rego->dump_tdep;\n-  verify_gdbarch (new_gdbarch);\n-  new_gdbarch->initialized_p = 1;\n-\n-  if (gdbarch_debug)\n-    gdbarch_dump (new_gdbarch, gdb_stdlog);\n-\n-  return new_gdbarch;\n-}\n-\n-/* Make the specified architecture current.  */\n-\n-void\n-set_target_gdbarch (struct gdbarch *new_gdbarch)\n-{\n-  gdb_assert (new_gdbarch != NULL);\n-  gdb_assert (new_gdbarch->initialized_p);\n-  current_inferior ()->gdbarch = new_gdbarch;\n-  gdb::observers::architecture_changed.notify (new_gdbarch);\n-  registers_changed ();\n-}\n-\n-/* Return the current inferior's arch.  */\n-\n-struct gdbarch *\n-target_gdbarch (void)\n-{\n-  return current_inferior ()->gdbarch;\n-}\n-\n-void _initialize_gdbarch ();\n-void\n-_initialize_gdbarch ()\n-{\n-  add_setshow_zuinteger_cmd (\"arch\", class_maintenance, &gdbarch_debug, _(\"\\\\\n-Set architecture debugging.\"), _(\"\\\\\n-Show architecture debugging.\"), _(\"\\\\\n-When non-zero, architecture debugging is enabled.\"),\n-\t\t\t    NULL,\n-\t\t\t    show_gdbarch_debug,\n-\t\t\t    &setdebuglist, &showdebuglist);\n-}\n-EOF\n-\n # close things off\n exec 1>&2\n ../move-if-change new-gdbarch.c gdbarch.c"
    }
  ]
}