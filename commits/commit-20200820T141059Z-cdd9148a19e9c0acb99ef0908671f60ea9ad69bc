{
  "sha": "cdd9148a19e9c0acb99ef0908671f60ea9ad69bc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2RkOTE0OGExOWU5YzBhY2I5OWVmMDkwODY3MWY2MGVhOWFkNjliYw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-20T14:10:59Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-20T14:10:59Z"
    },
    "message": "gdb: split regcaches management selftest\n\nThe selftest `regcaches` selftest is a bit too broad for my taste,\ntesting the behavior of get_thread_arch_aspace_regcache and various\ncases of registers_changed_ptid.  Since I'll want to test even more\nscenarios of registers_changed_ptid, passing different sets of\nparameters, it will be difficult to do in a single test case.  It is\ndifficult to change something at some point in the test case while make\nsure it doesn't compromise what comes after, that we still test the\nscenarios that we intended to test.  So, split the test case in multiple\nsmaller ones.\n\n- Split the test case in multiple, where each test case starts from\n  scratch and tests one specific scenario.\n\n- Introduce the populate_regcaches_for_test function, which is used by\n  the various test cases to start with a regcache container populated\n  with a few regcaches for two different targets.\n\n- populate_regcaches_for_test returns a regcache_test_data object, which\n  contains the test targets that were used to create the regcaches.  It\n  also takes care to call registers_changed at the beginning and end of\n  the test to ensure the test isn't influenced by existing regcaches,\n  and cleans up after itself.\n\n- Move the regcache_count lambda function out of\n  regcache_thread_ptid_changed, so it can be used in\n  other tests.\n\n- For get_thread_arch_aspace_regcache, test that getting a regcache that\n  already exists does not increase the count of existing regcaches.\n\n- For registers_changed_ptid, test the three cases we handle today:\n  (nullptr, minus_one_ptid), (target, minus_one_ptid) and (target,\n  ptid).  The (target, minus_one_ptid) case was not tested prior to this\n  patch.\n\ngdb/ChangeLog:\n\n\t* regcache.c (regcache_count): New.\n\t(struct regcache_test_data): New.\n\t(regcache_test_data_up): New.\n\t(populate_regcaches_for_test): New.\n\t(regcaches_test): Remove.\n\t(get_thread_arch_aspace_regcache_test): New.\n\t(registers_changed_ptid_all_test): New.\n\t(registers_changed_ptid_target_test): New.\n\t(registers_changed_ptid_target_ptid_test): New.\n\t(regcache_thread_ptid_changed): Remove regcache_count lambda.\n\t(_initialize_regcache): Register new tests.\n\nChange-Id: Id4280879fb40ff3aeae49b01b95359e1359c3d4b",
    "tree": {
      "sha": "576e6765bd810f70f7fc62ce3d560a67eb48c357",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/576e6765bd810f70f7fc62ce3d560a67eb48c357"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dd125343a1cccac2878d528d61a5ea71e46793fa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dd125343a1cccac2878d528d61a5ea71e46793fa",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dd125343a1cccac2878d528d61a5ea71e46793fa"
    }
  ],
  "stats": {
    "total": 199,
    "additions": 139,
    "deletions": 60
  },
  "files": [
    {
      "sha": "330d7f3ada06205bc02a1f46d9c5d526bece1b8b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=cdd9148a19e9c0acb99ef0908671f60ea9ad69bc",
      "patch": "@@ -1,3 +1,17 @@\n+2020-08-20  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* regcache.c (regcache_count): New.\n+\t(struct regcache_test_data): New.\n+\t(regcache_test_data_up): New.\n+\t(populate_regcaches_for_test): New.\n+\t(regcaches_test): Remove.\n+\t(get_thread_arch_aspace_regcache_test): New.\n+\t(registers_changed_ptid_all_test): New.\n+\t(registers_changed_ptid_target_test): New.\n+\t(registers_changed_ptid_target_ptid_test): New.\n+\t(regcache_thread_ptid_changed): Remove regcache_count lambda.\n+\t(_initialize_regcache): Register new tests.\n+\n 2020-08-20  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* regcache.c (test_get_thread_arch_aspace_regcache): Rename to..."
    },
    {
      "sha": "d9af4539ab9aff3eb8eca4e405100230fc6ec6c2",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 125,
      "deletions": 60,
      "changes": 185,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=cdd9148a19e9c0acb99ef0908671f60ea9ad69bc",
      "patch": "@@ -1488,6 +1488,23 @@ regcaches_size ()\n   return size;\n }\n \n+/* Return the count of regcaches for (TARGET, PTID) in REGCACHES.  */\n+\n+static int\n+regcache_count (process_stratum_target *target, ptid_t ptid)\n+{\n+  auto ptid_regc_map_it = regcaches.find (target);\n+  if (ptid_regc_map_it != regcaches.end ())\n+    {\n+      auto &ptid_regc_map = ptid_regc_map_it->second;\n+      auto range = ptid_regc_map.equal_range (ptid);\n+\n+      return std::distance (range.first, range.second);\n+    }\n+\n+  return 0;\n+};\n+\n /* Wrapper around get_thread_arch_aspace_regcache that does some self checks.  */\n \n static void\n@@ -1509,60 +1526,115 @@ get_thread_arch_aspace_regcache_and_check (process_stratum_target *target,\n   SELF_CHECK (regcache->aspace () == aspace);\n }\n \n-static void\n-regcaches_test ()\n+/* The data that the regcaches selftests must hold onto for the duration of the\n+   test.  */\n+\n+struct regcache_test_data\n {\n-  /* Ensure the regcaches container is empty at the start.  */\n-  registers_changed ();\n-  SELF_CHECK (regcaches_size () == 0);\n+  regcache_test_data ()\n+  {\n+    /* Ensure the regcaches container is empty at the start.  */\n+    registers_changed ();\n+  }\n \n-  ptid_t ptid1 (1), ptid2 (2), ptid3 (3);\n+  ~regcache_test_data ()\n+  {\n+    /* Make sure to leave the global regcaches container empty.  */\n+    registers_changed ();\n+  }\n \n   test_target_ops test_target1;\n   test_target_ops test_target2;\n+};\n+\n+using regcache_test_data_up = std::unique_ptr<regcache_test_data>;\n+\n+/* Set up a few regcaches from two different targets, for use in\n+   regcache-management tests.\n+\n+   Return a pointer, because the `regcache_test_data` type is not moveable.  */\n+\n+static regcache_test_data_up\n+populate_regcaches_for_test ()\n+{\n+  regcache_test_data_up data (new regcache_test_data);\n+  size_t expected_regcache_size = 0;\n+\n+  SELF_CHECK (regcaches_size () == 0);\n+\n+  /* Populate the regcache container with a few regcaches for the two test\n+     targets. */\n+  for (int pid : { 1, 2 })\n+    {\n+      for (long lwp : { 1, 2, 3 })\n+\t{\n+\t  get_thread_arch_aspace_regcache_and_check\n+\t    (&data->test_target1, ptid_t (pid, lwp));\n+\t  expected_regcache_size++;\n+\t  SELF_CHECK (regcaches_size () == expected_regcache_size);\n+\n+\t  get_thread_arch_aspace_regcache_and_check\n+\t    (&data->test_target2, ptid_t (pid, lwp));\n+\t  expected_regcache_size++;\n+\t  SELF_CHECK (regcaches_size () == expected_regcache_size);\n+\t}\n+    }\n+\n+  return data;\n+}\n+\n+static void\n+get_thread_arch_aspace_regcache_test ()\n+{\n+  /* populate_regcaches_for_test already tests most of the\n+     get_thread_arch_aspace_regcache functionality.  */\n+  regcache_test_data_up data = populate_regcaches_for_test ();\n+  size_t regcaches_size_before = regcaches_size ();\n+\n+  /* Test that getting an existing regcache doesn't create a new one.  */\n+  get_thread_arch_aspace_regcache_and_check (&data->test_target1, ptid_t (2, 2));\n+  SELF_CHECK (regcaches_size () == regcaches_size_before);\n+}\n+\n+  /* Test marking all regcaches of all targets as changed.  */\n+\n+static void\n+registers_changed_ptid_all_test ()\n+{\n+  regcache_test_data_up data = populate_regcaches_for_test ();\n \n-  /* Get regcache from (target1,ptid1), a new regcache is added to\n-     REGCACHES.  */\n-  get_thread_arch_aspace_regcache_and_check (&test_target1, ptid1);\n-  SELF_CHECK (regcaches_size () == 1);\n-\n-  /* Get regcache from (target1,ptid2), a new regcache is added to\n-     REGCACHES.  */\n-  get_thread_arch_aspace_regcache_and_check (&test_target1, ptid2);\n-  SELF_CHECK (regcaches_size () == 2);\n-\n-  /* Get regcache from (target1,ptid3), a new regcache is added to\n-     REGCACHES.  */\n-  get_thread_arch_aspace_regcache_and_check (&test_target1, ptid3);\n-  SELF_CHECK (regcaches_size () == 3);\n-\n-  /* Get regcache from (target1,ptid2) again, nothing is added to\n-     REGCACHES.  */\n-  get_thread_arch_aspace_regcache_and_check (&test_target1, ptid2);\n-  SELF_CHECK (regcaches_size () == 3);\n-\n-  /* Get regcache from (target2,ptid2), a new regcache is added to\n-     REGCACHES, since this time we're using a different target.  */\n-  get_thread_arch_aspace_regcache_and_check (&test_target2, ptid2);\n-  SELF_CHECK (regcaches_size () == 4);\n-\n-  /* Mark that (target1,ptid2) changed.  The regcache of (target1,\n-     ptid2) should be removed from REGCACHES.  */\n-  registers_changed_ptid (&test_target1, ptid2);\n-  SELF_CHECK (regcaches_size () == 3);\n-\n-  /* Get the regcache from (target2,ptid2) again, confirming the\n-     registers_changed_ptid call above did not delete it.  */\n-  get_thread_arch_aspace_regcache_and_check (&test_target2, ptid2);\n-  SELF_CHECK (regcaches_size () == 3);\n-\n-  /* Confirm that marking all regcaches of all targets as changed\n-     clears REGCACHES.  */\n   registers_changed_ptid (nullptr, minus_one_ptid);\n   SELF_CHECK (regcaches_size () == 0);\n+}\n \n-  /* Make sure to leave the global regcaches container empty.  */\n-  registers_changed ();\n+/* Test marking regcaches of a specific target as changed.  */\n+\n+static void\n+registers_changed_ptid_target_test ()\n+{\n+  regcache_test_data_up data = populate_regcaches_for_test ();\n+\n+  registers_changed_ptid (&data->test_target1, minus_one_ptid);\n+  SELF_CHECK (regcaches_size () == 6);\n+\n+  /* Check that we deleted the regcache for the right target.  */\n+  SELF_CHECK (regcache_count (&data->test_target1, ptid_t (2, 2)) == 0);\n+  SELF_CHECK (regcache_count (&data->test_target2, ptid_t (2, 2)) == 1);\n+}\n+\n+/* Test marking regcaches of a specific (target, ptid) as changed.  */\n+\n+static void\n+registers_changed_ptid_target_ptid_test ()\n+{\n+  regcache_test_data_up data = populate_regcaches_for_test ();\n+\n+  registers_changed_ptid (&data->test_target1, ptid_t (2, 2));\n+  SELF_CHECK (regcaches_size () == 11);\n+\n+  /* Check that we deleted the regcache for the right target.  */\n+  SELF_CHECK (regcache_count (&data->test_target1, ptid_t (2, 2)) == 0);\n+  SELF_CHECK (regcache_count (&data->test_target2, ptid_t (2, 2)) == 1);\n }\n \n class target_ops_no_register : public test_target_ops\n@@ -1900,20 +1972,6 @@ regcache_thread_ptid_changed ()\n   get_thread_arch_aspace_regcache (&target2.mock_target, old_ptid, arch,\n \t\t\t\t   nullptr);\n \n-  /* Return the count of regcaches for (TARGET, PTID) in REGCACHES.  */\n-  auto regcache_count = [] (process_stratum_target *target, ptid_t ptid)\n-    -> int\n-    {\n-      auto ptid_regc_map_it = regcaches.find (target);\n-      if (ptid_regc_map_it != regcaches.end ())\n-\t{\n-\t  auto &ptid_regc_map = ptid_regc_map_it->second;\n-\t  auto range = ptid_regc_map.equal_range (ptid);\n-\t  return std::distance (range.first, range.second);\n-\t}\n-      return 0;\n-    };\n-\n   gdb_assert (regcaches.size () == 2);\n   gdb_assert (regcache_count (&target1.mock_target, old_ptid) == 1);\n   gdb_assert (regcache_count (&target1.mock_target, new_ptid) == 0);\n@@ -1950,7 +2008,14 @@ _initialize_regcache ()\n \t   _(\"Force gdb to flush its register cache (maintainer command).\"));\n \n #if GDB_SELF_TEST\n-  selftests::register_test (\"regcaches\", selftests::regcaches_test);\n+  selftests::register_test (\"get_thread_arch_aspace_regcache\",\n+  \t\t\t    selftests::get_thread_arch_aspace_regcache_test);\n+  selftests::register_test (\"registers_changed_ptid_all\",\n+\t\t\t    selftests::registers_changed_ptid_all_test);\n+  selftests::register_test (\"registers_changed_ptid_target_ptid\",\n+\t\t\t    selftests::registers_changed_ptid_target_ptid_test);\n+  selftests::register_test (\"registers_changed_ptid_target\",\n+\t\t\t    selftests::registers_changed_ptid_target_test);\n \n   selftests::register_test_foreach_arch (\"regcache::cooked_read_test\",\n \t\t\t\t\t selftests::cooked_read_test);"
    }
  ]
}