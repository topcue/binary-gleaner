{
  "sha": "ec1b0fbb8dffc09f64f65b6459b786c35218803a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWMxYjBmYmI4ZGZmYzA5ZjY0ZjY1YjY0NTliNzg2YzM1MjE4ODAzYQ==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2019-08-27T15:28:55Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2019-08-27T15:28:55Z"
    },
    "message": "Improve the DWARF decoder's ability to describe the DW_AT_discr_list attribute.\n\n\tPR 24510\n\t* dwarf.c (MAX_CU_NESTING): New constant.\n\t(level_type_signed): New static array.\n\t(skip_attr_bytes): New function.\n\t(get_type_signedness): New function.\n\t(read_and_print_leb128): New function.\n\t(display_discr_list): New function.\n\t(read_and_display_attr_value): Add start parameter.\n\tUse new functions when handling DW_AT_type and DW_AT_discr_list.\n\t(read_and_display_attr): Add start parameter.  Pass to\n\tread_and_display_attr_value.\n\t(process_debug_info): Update call to read_and_display_attr.\n\t(display_formatted_table): Likewise.\n\t(display_debug_lines_decoded): Likewise.  Also add start\n\tparameter.\n\t(display_debug_lines): Likewise.\n\t* testsuite/binutils-all/dwarf-attributes.S: Update discrimination\n\tlists.\n\t* testsuite/binutils-all/dwarf-attributes.W: Update expected\n\toutput.",
    "tree": {
      "sha": "26c032d1dfbf17df520724cc95435346f4cdf8fa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/26c032d1dfbf17df520724cc95435346f4cdf8fa"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ec1b0fbb8dffc09f64f65b6459b786c35218803a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ec1b0fbb8dffc09f64f65b6459b786c35218803a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ec1b0fbb8dffc09f64f65b6459b786c35218803a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ec1b0fbb8dffc09f64f65b6459b786c35218803a/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4acfdd20c9ef3c0368868b4221554f0abef04196",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4acfdd20c9ef3c0368868b4221554f0abef04196",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4acfdd20c9ef3c0368868b4221554f0abef04196"
    }
  ],
  "stats": {
    "total": 517,
    "additions": 443,
    "deletions": 74
  },
  "files": [
    {
      "sha": "4de9a9302c9f8e2306b0a9ea7071c81f066a49df",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ec1b0fbb8dffc09f64f65b6459b786c35218803a/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ec1b0fbb8dffc09f64f65b6459b786c35218803a/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=ec1b0fbb8dffc09f64f65b6459b786c35218803a",
      "patch": "@@ -1,3 +1,26 @@\n+2019-08-27  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR 24510\n+\t* dwarf.c (MAX_CU_NESTING): New constant.\n+\t(level_type_signed): New static array.\n+\t(skip_attr_bytes): New function.\n+\t(get_type_signedness): New function.\n+\t(read_and_print_leb128): New function.\n+\t(display_discr_list): New function.\n+\t(read_and_display_attr_value): Add start parameter.\n+\tUse new functions when handling DW_AT_type and DW_AT_discr_list.\n+\t(read_and_display_attr): Add start parameter.  Pass to\n+\tread_and_display_attr_value.\n+\t(process_debug_info): Update call to read_and_display_attr.\n+\t(display_formatted_table): Likewise.\n+\t(display_debug_lines_decoded): Likewise.  Also add start\n+\tparameter.\n+\t(display_debug_lines): Likewise.\n+\t* testsuite/binutils-all/dwarf-attributes.S: Update discrimination\n+\tlists.\n+\t* testsuite/binutils-all/dwarf-attributes.W: Update expected\n+\toutput.\n+\n 2019-08-26  Alan Modra  <amodra@gmail.com>\n \n \tPR 24938"
    },
    {
      "sha": "19ae1edca7649ec8572cc86cd7818f63b5d81872",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 380,
      "deletions": 34,
      "changes": 414,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ec1b0fbb8dffc09f64f65b6459b786c35218803a/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ec1b0fbb8dffc09f64f65b6459b786c35218803a/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=ec1b0fbb8dffc09f64f65b6459b786c35218803a",
      "patch": "@@ -120,9 +120,9 @@ static unsigned int shndx_pool_used = 0;\n \n struct cu_tu_set\n {\n-  uint64_t signature;\n-  dwarf_vma section_offsets[DW_SECT_MAX];\n-  size_t section_sizes[DW_SECT_MAX];\n+  uint64_t   signature;\n+  dwarf_vma  section_offsets[DW_SECT_MAX];\n+  size_t     section_sizes[DW_SECT_MAX];\n };\n \n static int cu_count = 0;\n@@ -132,6 +132,12 @@ static struct cu_tu_set *tu_sets = NULL;\n \n static bfd_boolean load_cu_tu_indexes (void *);\n \n+/* An array that indicates for a given level of CU nesting whether\n+   the latest DW_AT_type seen for that level was a signed type or\n+   an unsigned type.  */\n+#define MAX_CU_NESTING (1 << 8)\n+static bfd_boolean level_type_signed[MAX_CU_NESTING];\n+\n /* Values for do_debug_lines.  */\n #define FLAG_DEBUG_LINES_RAW\t 1\n #define FLAG_DEBUG_LINES_DECODED 2\n@@ -1860,10 +1866,336 @@ check_uvalue (const unsigned char * start,\n   return uvalue;\n }\n \n+static unsigned char *\n+skip_attr_bytes (unsigned long          form,\n+\t\t unsigned char *        data,\n+\t\t unsigned const char *  end,\n+\t\t dwarf_vma              pointer_size,\n+\t\t dwarf_vma              offset_size,\n+\t\t int                    dwarf_version,\n+\t\t dwarf_vma *            value_return)\n+{\n+  unsigned int  bytes_read;\n+  dwarf_vma     uvalue = 0;\n+\n+  * value_return = 0;\n+\n+  switch (form)\n+    {\n+    case DW_FORM_ref_addr:\n+      if (dwarf_version == 2)\n+\tSAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);\n+      else if (dwarf_version == 3 || dwarf_version == 4)\n+\tSAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);\n+      else\n+\treturn NULL;\n+      break;\n+\n+    case DW_FORM_addr:\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);\n+      break;\n+\n+    case DW_FORM_strp:\n+    case DW_FORM_line_strp:\n+    case DW_FORM_sec_offset:\n+    case DW_FORM_GNU_ref_alt:\n+    case DW_FORM_GNU_strp_alt:\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);\n+      break;\n+\n+    case DW_FORM_flag_present:\n+      uvalue = 1;\n+      break;\n+\n+    case DW_FORM_ref1:\n+    case DW_FORM_flag:\n+    case DW_FORM_data1:\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);\n+      break;\n+\n+    case DW_FORM_ref2:\n+    case DW_FORM_data2:\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 2, end);\n+      break;\n+\n+    case DW_FORM_ref4:\n+    case DW_FORM_data4:\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);\n+      break;\n+\n+    case DW_FORM_sdata:\n+      uvalue = read_sleb128 (data, & bytes_read, end);\n+      data += bytes_read;\n+      break;\n+\n+    case DW_FORM_ref_udata:\n+    case DW_FORM_udata:\n+    case DW_FORM_GNU_str_index:\n+    case DW_FORM_GNU_addr_index:\n+      uvalue = read_uleb128 (data, & bytes_read, end);\n+      data += bytes_read;\n+      break;\n+\n+    case DW_FORM_ref8:\n+    case DW_FORM_data8:\n+      data += 8;\n+      break;\n+\n+    case DW_FORM_data16:\n+      data += 16;\n+      break;\n+\n+    case DW_FORM_string:\n+      data += strnlen ((char *) data, end - data) + 1;\n+      break;\n+\n+    case DW_FORM_block:\n+    case DW_FORM_exprloc:\n+      uvalue = read_uleb128 (data, & bytes_read, end);\n+      data += bytes_read + uvalue;\n+      break;\n+\n+    case DW_FORM_block1:\n+      SAFE_BYTE_GET (uvalue, data, 1, end);\n+      data += 1 + uvalue;\n+      break;\n+\n+    case DW_FORM_block2:\n+      SAFE_BYTE_GET (uvalue, data, 2, end);\n+      data += 2 + uvalue;\n+      break;\n+\n+    case DW_FORM_block4:\n+      SAFE_BYTE_GET (uvalue, data, 4, end);\n+      data += 4 + uvalue;\n+      break;\n+\n+    case DW_FORM_ref_sig8:\n+      data += 8;\n+      break;\n+\n+    case DW_FORM_indirect:\n+      /* FIXME: Handle this form.  */\n+    default:\n+      return NULL;\n+    }\n+\n+  * value_return = uvalue;\n+  if (data > end)\n+    data = (unsigned char *) end;\n+  return data;\n+}\n+\n+/* Return IS_SIGNED set to TRUE if the type at\n+   DATA can be determined to be a signed type.  */\n+\n+static void\n+get_type_signedness (unsigned char *        start,\n+\t\t     unsigned char *        data,\n+\t\t     unsigned const char *  end,\n+\t\t     dwarf_vma              pointer_size,\n+\t\t     dwarf_vma              offset_size,\n+\t\t     int                    dwarf_version,\n+\t\t     bfd_boolean *          is_signed,\n+\t\t     bfd_boolean\t    is_nested)\n+{\n+  unsigned long   abbrev_number;\n+  unsigned int    bytes_read;\n+  abbrev_entry *  entry;\n+  abbrev_attr *   attr;\n+\n+  * is_signed = FALSE;\n+\n+  if (data >= end)\n+    return;\n+\n+  abbrev_number = read_uleb128 (data, & bytes_read, end);\n+  data += bytes_read;\n+\n+  for (entry = first_abbrev;\n+       entry != NULL && entry->entry != abbrev_number;\n+       entry = entry->next)\n+    continue;\n+\n+  if (entry == NULL)\n+    /* FIXME: Issue a warning ?  */\n+    return;\n+\n+  for (attr = entry->first_attr;\n+       attr != NULL && attr->attribute;\n+       attr = attr->next)\n+    {\n+      dwarf_vma uvalue = 0;\n+\n+      data = skip_attr_bytes (attr->form, data, end, pointer_size,\n+\t\t\t      offset_size, dwarf_version, & uvalue);\n+      if (data == NULL)\n+\treturn;\n+\n+      switch (attr->attribute)\n+\t{\n+#if 0 /* FIXME: It would be nice to print the name of the type,\n+\t but this would mean updating a lot of binutils tests.  */\n+\tcase DW_AT_name:\n+\t  if (attr->form == DW_FORM_strp)\n+\t    printf (\"%s\", fetch_indirect_string (uvalue));\n+\t  break;\n+#endif\n+\tcase DW_AT_type:\n+\t  /* Recurse.  */\n+\t  if (is_nested)\n+\t    {\n+\t      /* FIXME: Warn - or is this expected ?\n+\t\t NB/ We need to avoid infinite recursion.  */\n+\t      return;\n+\t    }\n+\t  get_type_signedness (start, start + uvalue, end, pointer_size,\n+\t\t\t       offset_size, dwarf_version, is_signed, TRUE);\n+\t  break;\n+\n+\tcase DW_AT_encoding:\n+\t  /* Determine signness.  */\n+\t  switch (uvalue)\n+\t    {\n+\t    case DW_ATE_address:\n+\t      /* FIXME - some architectures have signed addresses.  */\n+\t    case DW_ATE_boolean:\n+\t    case DW_ATE_unsigned:\n+\t    case DW_ATE_unsigned_char:\n+\t    case DW_ATE_unsigned_fixed:\n+\t      * is_signed = FALSE;\n+\t      break;\n+\n+\t    default:\n+\t    case DW_ATE_complex_float:\n+\t    case DW_ATE_float:\n+\t    case DW_ATE_signed:\n+\t    case DW_ATE_signed_char:\n+\t    case DW_ATE_imaginary_float:\n+\t    case DW_ATE_decimal_float:\n+\t    case DW_ATE_signed_fixed:\n+\t      * is_signed = TRUE;\n+\t      break;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+static void\n+read_and_print_leb128 (unsigned char *        data,\n+\t\t       unsigned int *         bytes_read,\n+\t\t       unsigned const char *  end,\n+\t\t       bfd_boolean            is_signed)\n+{\n+  if (is_signed)\n+    {\n+      dwarf_signed_vma sval = read_sleb128 (data, bytes_read, end);\n+      printf (\"%ld\", (long) sval);\n+    }\n+  else\n+    {\n+      dwarf_vma uval = read_uleb128 (data, bytes_read, end);\n+      printf (\"%lu\", (unsigned long) uval);\n+    }\n+}\n+\n+static void\n+display_discr_list (unsigned long          form,\n+\t\t    dwarf_vma              uvalue,\n+\t\t    unsigned char *        data,\n+\t\t    unsigned const char *  end,\n+\t\t    int                    level)\n+{\n+  if (uvalue == 0)\n+    {\n+      printf (\"[default]\");\n+      return;\n+    }\n+  \n+  switch (form)\n+    {\n+    case DW_FORM_block:\n+    case DW_FORM_block1:\n+    case DW_FORM_block2:\n+    case DW_FORM_block4:\n+      /* Move data pointer back to the start of the byte array.  */\n+      data -= uvalue;\n+      break;\n+    default:\n+      printf (\"<corrupt>\\n\");\n+      warn (_(\"corrupt discr_list - not using a block form\\n\"));\n+      return;\n+    }\n+\n+  if (uvalue < 2)\n+    {\n+      printf (\"<corrupt>\\n\");\n+      warn (_(\"corrupt discr_list - block not long enough\\n\"));\n+      return;\n+    }\n+\n+  bfd_boolean is_signed =\n+    (level > 0 && level <= MAX_CU_NESTING)\n+    ? level_type_signed [level - 1] : FALSE;\n+    \n+  printf (\"(\");\n+  while (uvalue)\n+    {\n+      unsigned char     discriminant;\n+      unsigned int      bytes_read;\n+\n+      SAFE_BYTE_GET (discriminant, data, 1, end);\n+      -- uvalue;\n+      data ++;\n+\n+      assert (uvalue > 0);\n+      switch (discriminant)\n+\t{\n+\tcase DW_DSC_label:\n+\t  printf (\"label \");\n+\t  read_and_print_leb128 (data, & bytes_read, end, is_signed);\n+\t  assert (bytes_read <= uvalue && bytes_read > 0);\n+\t  uvalue -= bytes_read;\n+\t  data += bytes_read;\n+\t  break;\n+\n+\tcase DW_DSC_range:\n+\t  printf (\"range \");\n+\t  read_and_print_leb128 (data, & bytes_read, end, is_signed);\n+\t  assert (bytes_read <= uvalue && bytes_read > 0);\n+\t  uvalue -= bytes_read;\n+\t  data += bytes_read;\n+\n+\t  printf (\"..\");\n+\t  read_and_print_leb128 (data, & bytes_read, end, is_signed);\n+\t  assert (bytes_read <= uvalue && bytes_read > 0);\n+\t  uvalue -= bytes_read;\n+\t  data += bytes_read;\n+\t  break;\n+\n+\tdefault:\n+\t  printf (\"<corrupt>\\n\");\n+\t  warn (_(\"corrupt discr_list - unrecognised discriminant byte %#x\\n\"),\n+\t\tdiscriminant);\n+\t  return;\n+\t}\n+\n+      if (uvalue)\n+\tprintf (\", \");\n+    }\n+\n+  if (is_signed)\n+    printf (\")(signed)\");\n+  else\n+    printf (\")(unsigned)\");\n+}\n+\n static unsigned char *\n read_and_display_attr_value (unsigned long           attribute,\n \t\t\t     unsigned long           form,\n \t\t\t     dwarf_signed_vma        implicit_const,\n+\t\t\t     unsigned char *         start,\n \t\t\t     unsigned char *         data,\n \t\t\t     unsigned char *         end,\n \t\t\t     dwarf_vma               cu_offset,\n@@ -1874,12 +2206,13 @@ read_and_display_attr_value (unsigned long           attribute,\n \t\t\t     int                     do_loc,\n \t\t\t     struct dwarf_section *  section,\n \t\t\t     struct cu_tu_set *      this_set,\n-\t\t\t     char                    delimiter)\n+\t\t\t     char                    delimiter,\n+\t\t\t     int                     level)\n {\n-  dwarf_vma uvalue = 0;\n-  unsigned char *block_start = NULL;\n-  unsigned char * orig_data = data;\n-  unsigned int bytes_read;\n+  dwarf_vma        uvalue = 0;\n+  unsigned char *  block_start = NULL;\n+  unsigned char *  orig_data = data;\n+  unsigned int     bytes_read;\n \n   if (data > end || (data == end && form != DW_FORM_flag_present))\n     {\n@@ -1960,11 +2293,12 @@ read_and_display_attr_value (unsigned long           attribute,\n \t  implicit_const = read_sleb128 (data, & bytes_read, end);\n \t  data += bytes_read;\n \t}\n-      return read_and_display_attr_value (attribute, form, implicit_const, data,\n-\t\t\t\t\t  end, cu_offset, pointer_size,\n+      return read_and_display_attr_value (attribute, form, implicit_const,\n+\t\t\t\t\t  start, data, end,\n+\t\t\t\t\t  cu_offset, pointer_size,\n \t\t\t\t\t  offset_size, dwarf_version,\n \t\t\t\t\t  debug_info_p, do_loc,\n-\t\t\t\t\t  section, this_set, delimiter);\n+\t\t\t\t\t  section, this_set, delimiter, level);\n     case DW_FORM_GNU_addr_index:\n       uvalue = read_uleb128 (data, & bytes_read, end);\n       data += bytes_read;\n@@ -2397,6 +2731,17 @@ read_and_display_attr_value (unsigned long           attribute,\n   /* For some attributes we can display further information.  */\n   switch (attribute)\n     {\n+    case DW_AT_type:\n+      if (level >= 0 && level < MAX_CU_NESTING)\n+\t{\n+\t  bfd_boolean is_signed = FALSE;\n+\n+\t  get_type_signedness (start, start + uvalue, end, pointer_size,\n+\t\t\t       offset_size, dwarf_version, & is_signed, FALSE);\n+\t  level_type_signed[level] = is_signed;\n+\t}\n+      break;\n+      \n     case DW_AT_inline:\n       printf (\"\\t\");\n       switch (uvalue)\n@@ -2646,12 +2991,7 @@ read_and_display_attr_value (unsigned long           attribute,\n \n     case DW_AT_discr_list:\n       printf (\"\\t\");\n-      switch (uvalue)\n-\t{\n-\tcase DW_DSC_label:  printf (_(\"(label)\")); break;\n-\tcase DW_DSC_range:  printf (_(\"(range)\")); break;\n-\tdefault:            printf (_(\"(unrecognised)\")); break;\n-\t}\n+      display_discr_list (form, uvalue, data, end, level);\n       break;\n       \n     case DW_AT_frame_base:\n@@ -2768,6 +3108,7 @@ static unsigned char *\n read_and_display_attr (unsigned long           attribute,\n \t\t       unsigned long           form,\n \t\t       dwarf_signed_vma        implicit_const,\n+\t\t       unsigned char *         start,\n \t\t       unsigned char *         data,\n \t\t       unsigned char *         end,\n \t\t       dwarf_vma               cu_offset,\n@@ -2777,14 +3118,16 @@ read_and_display_attr (unsigned long           attribute,\n \t\t       debug_info *            debug_info_p,\n \t\t       int                     do_loc,\n \t\t       struct dwarf_section *  section,\n-\t\t       struct cu_tu_set *      this_set)\n+\t\t       struct cu_tu_set *      this_set,\n+\t\t       int                     level)\n {\n   if (!do_loc)\n     printf (\"   %-18s:\", get_AT_name (attribute));\n-  data = read_and_display_attr_value (attribute, form, implicit_const, data, end,\n+  data = read_and_display_attr_value (attribute, form, implicit_const,\n+\t\t\t\t      start, data, end,\n \t\t\t\t      cu_offset, pointer_size, offset_size,\n \t\t\t\t      dwarf_version, debug_info_p,\n-\t\t\t\t      do_loc, section, this_set, ' ');\n+\t\t\t\t      do_loc, section, this_set, ' ', level);\n   if (!do_loc)\n     printf (\"\\n\");\n   return data;\n@@ -3310,6 +3653,7 @@ process_debug_info (struct dwarf_section *           section,\n \t      tags = read_and_display_attr (attr->attribute,\n \t\t\t\t\t    attr->form,\n \t\t\t\t\t    attr->implicit_const,\n+\t\t\t\t\t    section_begin,\n \t\t\t\t\t    tags,\n \t\t\t\t\t    end,\n \t\t\t\t\t    cu_offset,\n@@ -3319,7 +3663,8 @@ process_debug_info (struct dwarf_section *           section,\n \t\t\t\t\t    debug_info_p,\n \t\t\t\t\t    do_loc || ! do_printing,\n \t\t\t\t\t    section,\n-\t\t\t\t\t    this_set);\n+\t\t\t\t\t    this_set,\n+\t\t\t\t\t    level);\n \t    }\n \n \t  /* If a locview attribute appears before a location one,\n@@ -3636,11 +3981,11 @@ display_formatted_table (unsigned char *                   data,\n \t      format += bytes_read;\n \t      form = read_uleb128 (format, & bytes_read, end);\n \t      format += bytes_read;\n-\t      data = read_and_display_attr_value (0, form, 0, data, end, 0, 0,\n+\t      data = read_and_display_attr_value (0, form, 0, start, data, end, 0, 0,\n \t\t\t\t\t\t  linfo->li_offset_size,\n \t\t\t\t\t\t  linfo->li_version, NULL,\n \t\t\t    ((content_type == DW_LNCT_path) != (namepass == 1)),\n-\t\t\t\t\t\t  section, NULL, '\\t');\n+\t\t\t\t\t\t  section, NULL, '\\t', -1);\n \t    }\n \t}\n       if (data == end)\n@@ -4080,6 +4425,7 @@ typedef struct\n \n static int\n display_debug_lines_decoded (struct dwarf_section *  section,\n+\t\t\t     unsigned char *         start,\n \t\t\t     unsigned char *         data,\n \t\t\t     unsigned char *         end,\n \t\t\t     void *                  fileptr)\n@@ -4213,12 +4559,12 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t\t\t    }\n \t\t\t  break;\n \t\t\t}\n-\t\t      data = read_and_display_attr_value (0, form, 0, data, end,\n+\t\t      data = read_and_display_attr_value (0, form, 0, start, data, end,\n \t\t                                          0, 0,\n \t\t\t\t\t\t\t  linfo.li_offset_size,\n \t\t\t\t\t\t\t  linfo.li_version,\n \t\t\t\t\t\t\t  NULL, 1, section,\n-\t\t\t\t\t\t\t  NULL, '\\t');\n+\t\t\t\t\t\t\t  NULL, '\\t', -1);\n \t\t    }\n \t\t  if (data == end)\n \t\t    {\n@@ -4303,12 +4649,12 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t\t\t    }\n \t\t\t  break;\n \t\t\t}\n-\t\t      data = read_and_display_attr_value (0, form, 0, data, end,\n+\t\t      data = read_and_display_attr_value (0, form, 0, start, data, end,\n \t\t\t\t\t\t\t  0, 0,\n \t\t\t\t\t\t\t  linfo.li_offset_size,\n \t\t\t\t\t\t\t  linfo.li_version,\n \t\t\t\t\t\t\t  NULL, 1, section,\n-\t\t\t\t\t\t\t  NULL, '\\t');\n+\t\t\t\t\t\t\t  NULL, '\\t', -1);\n \t\t    }\n \t\t  if (data == end)\n \t\t    {\n@@ -4835,7 +5181,7 @@ display_debug_lines (struct dwarf_section *section, void *file)\n     retValRaw = display_debug_lines_raw (section, data, end, file);\n \n   if (do_debug_lines & FLAG_DEBUG_LINES_DECODED)\n-    retValDecoded = display_debug_lines_decoded (section, data, end, file);\n+    retValDecoded = display_debug_lines_decoded (section, data, data, end, file);\n \n   if (!retValRaw || !retValDecoded)\n     return 0;\n@@ -5440,9 +5786,9 @@ display_debug_macro (struct dwarf_section *section,\n \t\t      SAFE_BYTE_GET_AND_INC (val, desc, 1, end);\n \t\t      curr\n \t\t\t= read_and_display_attr_value (0, val, 0,\n-\t\t\t\t\t\t       curr, end, 0, 0, offset_size,\n+\t\t\t\t\t\t       start, curr, end, 0, 0, offset_size,\n \t\t\t\t\t\t       version, NULL, 0, NULL,\n-\t\t\t\t\t\t       NULL, ' ');\n+\t\t\t\t\t\t       NULL, ' ', -1);\n \t\t      if (n != nargs - 1)\n \t\t\tprintf (\",\");\n \t\t    }\n@@ -8880,12 +9226,12 @@ display_debug_names (struct dwarf_section *section, void *file)\n \n \t\t  if (tagno >= 0)\n \t\t    printf (\" %s\", get_IDX_name (xindex));\n-\t\t  entryptr = read_and_display_attr_value (0, form, 0, entryptr,\n-\t\t\t\t\t\t\t  unit_end, 0, 0,\n-\t\t\t\t\t\t\t  offset_size,\n+\t\t  entryptr = read_and_display_attr_value (0, form, 0,\n+\t\t\t\t\t\t\t  unit_start, entryptr, unit_end,\n+\t\t\t\t\t\t\t  0, 0, offset_size,\n \t\t\t\t\t\t\t  dwarf_version, NULL,\n \t\t\t\t\t\t\t  (tagno < 0), NULL,\n-\t\t\t\t\t\t\t  NULL, '=');\n+\t\t\t\t\t\t\t  NULL, '=', -1);\n \t\t}\n \t      ++tagno;\n \t    }"
    },
    {
      "sha": "39a7258a9be1354cf1f6d6736eb49a9d63e65377",
      "filename": "binutils/testsuite/binutils-all/dwarf-attributes.S",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ec1b0fbb8dffc09f64f65b6459b786c35218803a/binutils/testsuite/binutils-all/dwarf-attributes.S",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ec1b0fbb8dffc09f64f65b6459b786c35218803a/binutils/testsuite/binutils-all/dwarf-attributes.S",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/testsuite/binutils-all/dwarf-attributes.S?ref=ec1b0fbb8dffc09f64f65b6459b786c35218803a",
      "patch": "@@ -38,7 +38,7 @@\n \t.byte  1\t/* Inline: inlined.  */\n \t.byte  1\t/* Accessibility: public.  */\n \t.byte  1\t/* Calling convention: normal.  */\n-\t.byte  1\t/* Discriminate list: range.  */\n+\t.byte  3,1,1,2\t/* Discriminate list: range.  */\n \t.byte  1\t/* Encoding: address.  */\n \t.byte  1\t/* Identifier case: up.  */\n \t.byte  1\t/* Virtuality: virtual.  */\n@@ -53,7 +53,7 @@\n \t.byte  0\t/* Inline: not.  */\n \t.byte  2\t/* Accessibility: protected.  */\n \t.byte  5\t/* Calling convention: pass by value.  */\n-\t.byte  0\t/* Discriminate list: label.  */\n+\t.byte  2,0,1\t/* Discriminate list: label.  */\n \t.byte  0x12\t/* Encoding: ASCII.  */\n \t.byte  0\t/* Identifier case: sensitive.  */\n \t.byte  0\t/* Virtuality: none.  */\n@@ -68,7 +68,7 @@\n \t.byte  3\t/* Inline: declared.  */\n \t.byte  3\t/* Accessibility: private.  */\n \t.byte  0x40\t/* Calling convention: Renesas SH.  */\n-\t.byte  1\t/* Discriminate list: range.  */\n+\t.byte  5,1,2,3,0,4\t/* Discriminate list: range and label.  */\n \t.byte  0x81\t/* Encoding: user specified.  */\n \t.byte  3\t/* Identifier case: insensitive.  */\n \t.byte  2\t/* Virtuality: pure.  */\n@@ -107,7 +107,7 @@\n \t.uleb128 0x0b\t/* (DW_FORM_data1) */\n \t\n \t.uleb128 0x3d\t/* (DW_AT_discr_lists) */\n-\t.uleb128 0x0b\t/* (DW_FORM_data1) */\n+\t.uleb128 0x0a\t/* (DW_FORM_block1) */\n \t\n \t.uleb128 0x3e\t/* (DW_AT_encoding) */\n \t.uleb128 0x0b\t/* (DW_FORM_data1) */"
    },
    {
      "sha": "3a4e7409889a91f9fc7a5b77b0581bc54dc75ee7",
      "filename": "binutils/testsuite/binutils-all/dwarf-attributes.W",
      "status": "modified",
      "additions": 36,
      "deletions": 36,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ec1b0fbb8dffc09f64f65b6459b786c35218803a/binutils/testsuite/binutils-all/dwarf-attributes.W",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ec1b0fbb8dffc09f64f65b6459b786c35218803a/binutils/testsuite/binutils-all/dwarf-attributes.W",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/testsuite/binutils-all/dwarf-attributes.W?ref=ec1b0fbb8dffc09f64f65b6459b786c35218803a",
      "patch": "@@ -1,7 +1,7 @@\n Contents of the .debug_info section:\n \n   Compilation Unit @ offset 0x0:\n-   Length:        0x36 \\(32-bit\\)\n+   Length:        0x40 \\(32-bit\\)\n    Version:       5\n    Abbrev Offset: 0x0\n    Pointer Size:  4\n@@ -12,38 +12,38 @@ Contents of the .debug_info section:\n     <11>   DW_AT_inline      : 1\t\\(inlined\\)\n     <12>   DW_AT_accessibility: 1\t\\(public\\)\n     <13>   DW_AT_calling_convention: 1\t\\(normal\\)\n-    <14>   DW_AT_discr_list  : 1\t\\(range\\)\n-    <15>   DW_AT_encoding    : 1\t\\(machine address\\)\n-    <16>   DW_AT_identifier_case: 1\t\\(up_case\\)\n-    <17>   DW_AT_virtuality  : 1\t\\(virtual\\)\n-    <18>   DW_AT_decimal_sign: 1\t\\(unsigned\\)\n-    <19>   DW_AT_endianity   : 1\t\\(big\\)\n-    <1a>   DW_AT_defaulted   : 1\t\\(in class\\)\n- <0><1b>: Abbrev Number: 1 \\(User TAG value: 0x5555\\)\n-    <1c>   DW_AT_ordering    : 0\t\\(row major\\)\n-    <1d>   DW_AT_language    : 22\t\\(Go\\)\n-    <1f>   DW_AT_visibility  : 2\t\\(exported\\)\n-    <20>   DW_AT_inline      : 0\t\\(not inlined\\)\n-    <21>   DW_AT_accessibility: 2\t\\(protected\\)\n-    <22>   DW_AT_calling_convention: 5\t\\(pass by value\\)\n-    <23>   DW_AT_discr_list  : 0\t\\(label\\)\n-    <24>   DW_AT_encoding    : 18\t\\(ASCII\\)\n-    <25>   DW_AT_identifier_case: 0\t\\(case_sensitive\\)\n-    <26>   DW_AT_virtuality  : 0\t\\(none\\)\n-    <27>   DW_AT_decimal_sign: 2\t\\(leading overpunch\\)\n-    <28>   DW_AT_endianity   : 0\t\\(default\\)\n-    <29>   DW_AT_defaulted   : 0\t\\(no\\)\n- <0><2a>: Abbrev Number: 1 \\(User TAG value: 0x5555\\)\n-    <2b>   DW_AT_ordering    : 255\t\\(undefined\\)\n-    <2c>   DW_AT_language    : 32769\t\\(MIPS assembler\\)\n-    <2e>   DW_AT_visibility  : 3\t\\(qualified\\)\n-    <2f>   DW_AT_inline      : 3\t\\(declared as inline and inlined\\)\n-    <30>   DW_AT_accessibility: 3\t\\(private\\)\n-    <31>   DW_AT_calling_convention: 64\t\\(Rensas SH\\)\n-    <32>   DW_AT_discr_list  : 1\t\\(range\\)\n-    <33>   DW_AT_encoding    : 129\t\\(HP_complex_float80\\)\n-    <34>   DW_AT_identifier_case: 3\t\\(case_insensitive\\)\n-    <35>   DW_AT_virtuality  : 2\t\\(pure_virtual\\)\n-    <36>   DW_AT_decimal_sign: 5\t\\(trailing separate\\)\n-    <37>   DW_AT_endianity   : 80\t\\(user specified\\)\n-    <38>   DW_AT_defaulted   : 2\t\\(out of class\\)\n+    <14>   DW_AT_discr_list  : 3 byte block: 1 1 2 \t\\(range 1..2\\)\\(unsigned\\)\n+    <18>   DW_AT_encoding    : 1\t\\(machine address\\)\n+    <19>   DW_AT_identifier_case: 1\t\\(up_case\\)\n+    <1a>   DW_AT_virtuality  : 1\t\\(virtual\\)\n+    <1b>   DW_AT_decimal_sign: 1\t\\(unsigned\\)\n+    <1c>   DW_AT_endianity   : 1\t\\(big\\)\n+    <1d>   DW_AT_defaulted   : 1\t\\(in class\\)\n+ <0><1e>: Abbrev Number: 1 \\(User TAG value: 0x5555\\)\n+    <1f>   DW_AT_ordering    : 0\t\\(row major\\)\n+    <20>   DW_AT_language    : 22\t\\(Go\\)\n+    <22>   DW_AT_visibility  : 2\t\\(exported\\)\n+    <23>   DW_AT_inline      : 0\t\\(not inlined\\)\n+    <24>   DW_AT_accessibility: 2\t\\(protected\\)\n+    <25>   DW_AT_calling_convention: 5\t\\(pass by value\\)\n+    <26>   DW_AT_discr_list  : 2 byte block: 0 1 \t\\(label 1\\)\\(unsigned\\)\n+    <29>   DW_AT_encoding    : 18\t\\(ASCII\\)\n+    <2a>   DW_AT_identifier_case: 0\t\\(case_sensitive\\)\n+    <2b>   DW_AT_virtuality  : 0\t\\(none\\)\n+    <2c>   DW_AT_decimal_sign: 2\t\\(leading overpunch\\)\n+    <2d>   DW_AT_endianity   : 0\t\\(default\\)\n+    <2e>   DW_AT_defaulted   : 0\t\\(no\\)\n+ <0><2f>: Abbrev Number: 1 \\(User TAG value: 0x5555\\)\n+    <30>   DW_AT_ordering    : 255\t\\(undefined\\)\n+    <31>   DW_AT_language    : 32769\t\\(MIPS assembler\\)\n+    <33>   DW_AT_visibility  : 3\t\\(qualified\\)\n+    <34>   DW_AT_inline      : 3\t\\(declared as inline and inlined\\)\n+    <35>   DW_AT_accessibility: 3\t\\(private\\)\n+    <36>   DW_AT_calling_convention: 64\t\\(Rensas SH\\)\n+    <37>   DW_AT_discr_list  : 5 byte block: 1 2 3 0 4 \t\\(range 2..3, label 4\\)\\(unsigned\\)\n+    <3d>   DW_AT_encoding    : 129\t\\(HP_complex_float80\\)\n+    <3e>   DW_AT_identifier_case: 3\t\\(case_insensitive\\)\n+    <3f>   DW_AT_virtuality  : 2\t\\(pure_virtual\\)\n+    <40>   DW_AT_decimal_sign: 5\t\\(trailing separate\\)\n+    <41>   DW_AT_endianity   : 80\t\\(user specified\\)\n+    <42>   DW_AT_defaulted   : 2\t\\(out of class\\)"
    }
  ]
}