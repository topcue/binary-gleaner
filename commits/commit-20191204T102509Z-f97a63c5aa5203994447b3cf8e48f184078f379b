{
  "sha": "f97a63c5aa5203994447b3cf8e48f184078f379b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Zjk3YTYzYzVhYTUyMDM5OTQ0NDdiM2NmOGU0OGYxODQwNzhmMzc5Yg==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-12-02T11:36:45Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-12-04T10:25:09Z"
    },
    "message": "gdb: Split global symbol search into separate functions\n\nIn preparation for the next commit, this commit restructures the code\nby splitting global_symbol_searcher::search into separate functions.\nThere should be no functional changes after this commit.\n\ngdb/ChangeLog:\n\n\t* symtab.c (symbol_search::compare_search_syms): Update header\n\tcomment.\n\t(global_symbol_searcher::is_suitable_msymbol): New function.\n\t(global_symbol_searcher::expand_symtabs): New function.\n\t(global_symbol_searcher::add_matching_symbols): New function.\n\t(global_symbol_searcher::add_matching_msymbols): New function.\n\t(global_symbol_searcher::search): Move most of the content\n\tinto the new functions above, and call them as needed.\n\t* symtab.h (global_symbol_searcher) <expand_symtabs>: New member\n\tfunction.\n\t(global_symbol_searcher) <add_matching_symbols>: New member\n\tfunction.\n\t(global_symbol_searcher) <add_matching_msymbols>: New member\n\tfunction.\n\t(global_symbol_searcher) <is_suitable_msymbol>: New member\n\tfunction.\n\nChange-Id: I06b26920f35c268f7a38d8203dc2c2813aa501c6",
    "tree": {
      "sha": "b13666c9c194b2609e3f0dd14b76997cbe5cb8c0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b13666c9c194b2609e3f0dd14b76997cbe5cb8c0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f97a63c5aa5203994447b3cf8e48f184078f379b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f97a63c5aa5203994447b3cf8e48f184078f379b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f97a63c5aa5203994447b3cf8e48f184078f379b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f97a63c5aa5203994447b3cf8e48f184078f379b/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "293b38d60f15422cf7e3d3ba06fdbc5cc90aee67",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/293b38d60f15422cf7e3d3ba06fdbc5cc90aee67",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/293b38d60f15422cf7e3d3ba06fdbc5cc90aee67"
    }
  ],
  "stats": {
    "total": 468,
    "additions": 273,
    "deletions": 195
  },
  "files": [
    {
      "sha": "391b23e9e3fddd51e8ba32dd9d83e14df970a531",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f97a63c5aa5203994447b3cf8e48f184078f379b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f97a63c5aa5203994447b3cf8e48f184078f379b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f97a63c5aa5203994447b3cf8e48f184078f379b",
      "patch": "@@ -1,3 +1,22 @@\n+2019-12-04  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* symtab.c (symbol_search::compare_search_syms): Update header\n+\tcomment.\n+\t(global_symbol_searcher::is_suitable_msymbol): New function.\n+\t(global_symbol_searcher::expand_symtabs): New function.\n+\t(global_symbol_searcher::add_matching_symbols): New function.\n+\t(global_symbol_searcher::add_matching_msymbols): New function.\n+\t(global_symbol_searcher::search): Move most of the content\n+\tinto the new functions above, and call them as needed.\n+\t* symtab.h (global_symbol_searcher) <expand_symtabs>: New member\n+\tfunction.\n+\t(global_symbol_searcher) <add_matching_symbols>: New member\n+\tfunction.\n+\t(global_symbol_searcher) <add_matching_msymbols>: New member\n+\tfunction.\n+\t(global_symbol_searcher) <is_suitable_msymbol>: New member\n+\tfunction.\n+\n 2019-12-04  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* mi/mi-cmds.c (mi_cmds): Add -symbol-info-module-functions and"
    },
    {
      "sha": "d54ff1444317eb33be5da9d0e437e87c33b4248b",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 231,
      "deletions": 195,
      "changes": 426,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f97a63c5aa5203994447b3cf8e48f184078f379b/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f97a63c5aa5203994447b3cf8e48f184078f379b/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=f97a63c5aa5203994447b3cf8e48f184078f379b",
      "patch": "@@ -4383,8 +4383,8 @@ file_matches (const char *file, const std::vector<const char *> &filenames,\n   return false;\n }\n \n-/* Helper function for sort_search_symbols_remove_dups and qsort.  Can only\n-   sort symbols, not minimal symbols.  */\n+/* Helper function for std::sort on symbol_search objects.  Can only sort\n+   symbols, not minimal symbols.  */\n \n int\n symbol_search::compare_search_syms (const symbol_search &sym_a,\n@@ -4445,6 +4445,220 @@ treg_matches_sym_type_name (const compiled_regex &treg,\n   return treg.exec (printed_sym_type_name.c_str (), 0, NULL, 0) == 0;\n }\n \n+/* See symtab.h.  */\n+\n+bool\n+global_symbol_searcher::is_suitable_msymbol\n+\t(const enum search_domain kind, const minimal_symbol *msymbol)\n+{\n+  switch (MSYMBOL_TYPE (msymbol))\n+    {\n+    case mst_data:\n+    case mst_bss:\n+    case mst_file_data:\n+    case mst_file_bss:\n+      return kind == VARIABLES_DOMAIN;\n+    case mst_text:\n+    case mst_file_text:\n+    case mst_solib_trampoline:\n+    case mst_text_gnu_ifunc:\n+      return kind == FUNCTIONS_DOMAIN;\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* See symtab.h.  */\n+\n+bool\n+global_symbol_searcher::expand_symtabs\n+\t(objfile *objfile, const gdb::optional<compiled_regex> &preg) const\n+{\n+  enum search_domain kind = m_kind;\n+  bool found_msymbol = false;\n+\n+  if (objfile->sf)\n+    objfile->sf->qf->expand_symtabs_matching\n+      (objfile,\n+       [&] (const char *filename, bool basenames)\n+       {\n+\t return file_matches (filename, filenames, basenames);\n+       },\n+       lookup_name_info::match_any (),\n+       [&] (const char *symname)\n+       {\n+\t return (!preg.has_value ()\n+\t\t || preg->exec (symname, 0, NULL, 0) == 0);\n+       },\n+       NULL,\n+       kind);\n+\n+  /* Here, we search through the minimal symbol tables for functions and\n+     variables that match, and force their symbols to be read.  This is in\n+     particular necessary for demangled variable names, which are no longer\n+     put into the partial symbol tables.  The symbol will then be found\n+     during the scan of symtabs later.\n+\n+     For functions, find_pc_symtab should succeed if we have debug info for\n+     the function, for variables we have to call\n+     lookup_symbol_in_objfile_from_linkage_name to determine if the\n+     variable has debug info.  If the lookup fails, set found_msymbol so\n+     that we will rescan to print any matching symbols without debug info.\n+     We only search the objfile the msymbol came from, we no longer search\n+     all objfiles.  In large programs (1000s of shared libs) searching all\n+     objfiles is not worth the pain.  */\n+  if (filenames.empty ()\n+      && (kind == VARIABLES_DOMAIN || kind == FUNCTIONS_DOMAIN))\n+    {\n+      for (minimal_symbol *msymbol : objfile->msymbols ())\n+\t{\n+\t  QUIT;\n+\n+\t  if (msymbol->created_by_gdb)\n+\t    continue;\n+\n+\t  if (is_suitable_msymbol (kind, msymbol))\n+\t    {\n+\t      if (!preg.has_value ()\n+\t\t  || preg->exec (msymbol->natural_name (), 0,\n+\t\t\t\t NULL, 0) == 0)\n+\t\t{\n+\t\t  /* An important side-effect of these lookup functions is\n+\t\t     to expand the symbol table if msymbol is found, later\n+\t\t     in the process we will add matching symbols or\n+\t\t     msymbols to the results list, and that requires that\n+\t\t     the symbols tables are expanded.  */\n+\t\t  if (kind == FUNCTIONS_DOMAIN\n+\t\t      ? (find_pc_compunit_symtab\n+\t\t\t (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n+\t\t\t == NULL)\n+\t\t      : (lookup_symbol_in_objfile_from_linkage_name\n+\t\t\t (objfile, msymbol->linkage_name (),\n+\t\t\t  VAR_DOMAIN)\n+\t\t\t .symbol == NULL))\n+\t\t    found_msymbol = true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return found_msymbol;\n+}\n+\n+/* See symtab.h.  */\n+\n+void\n+global_symbol_searcher::add_matching_symbols\n+\t(objfile *objfile,\n+\t const gdb::optional<compiled_regex> &preg,\n+\t const gdb::optional<compiled_regex> &treg,\n+\t std::vector<symbol_search> *results) const\n+{\n+  enum search_domain kind = m_kind;\n+\n+  /* Add matching symbols (if not already present).  */\n+  for (compunit_symtab *cust : objfile->compunits ())\n+    {\n+      const struct blockvector *bv  = COMPUNIT_BLOCKVECTOR (cust);\n+\n+      for (block_enum block : { GLOBAL_BLOCK, STATIC_BLOCK })\n+\t{\n+\t  struct block_iterator iter;\n+\t  struct symbol *sym;\n+\t  const struct block *b = BLOCKVECTOR_BLOCK (bv, block);\n+\n+\t  ALL_BLOCK_SYMBOLS (b, iter, sym)\n+\t    {\n+\t      struct symtab *real_symtab = symbol_symtab (sym);\n+\n+\t      QUIT;\n+\n+\t      /* Check first sole REAL_SYMTAB->FILENAME.  It does\n+\t\t not need to be a substring of symtab_to_fullname as\n+\t\t it may contain \"./\" etc.  */\n+\t      if ((file_matches (real_symtab->filename, filenames, false)\n+\t\t   || ((basenames_may_differ\n+\t\t\t|| file_matches (lbasename (real_symtab->filename),\n+\t\t\t\t\t filenames, true))\n+\t\t       && file_matches (symtab_to_fullname (real_symtab),\n+\t\t\t\t\tfilenames, false)))\n+\t\t  && ((!preg.has_value ()\n+\t\t       || preg->exec (sym->natural_name (), 0,\n+\t\t\t\t      NULL, 0) == 0)\n+\t\t      && ((kind == VARIABLES_DOMAIN\n+\t\t\t   && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n+\t\t\t   && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n+\t\t\t   && SYMBOL_CLASS (sym) != LOC_BLOCK\n+\t\t\t   /* LOC_CONST can be used for more than\n+\t\t\t      just enums, e.g., c++ static const\n+\t\t\t      members.  We only want to skip enums\n+\t\t\t      here.  */\n+\t\t\t   && !(SYMBOL_CLASS (sym) == LOC_CONST\n+\t\t\t\t&& (TYPE_CODE (SYMBOL_TYPE (sym))\n+\t\t\t\t    == TYPE_CODE_ENUM))\n+\t\t\t   && (!treg.has_value ()\n+\t\t\t       || treg_matches_sym_type_name (*treg, sym)))\n+\t\t\t  || (kind == FUNCTIONS_DOMAIN\n+\t\t\t      && SYMBOL_CLASS (sym) == LOC_BLOCK\n+\t\t\t      && (!treg.has_value ()\n+\t\t\t\t  || treg_matches_sym_type_name (*treg,\n+\t\t\t\t\t\t\t\t sym)))\n+\t\t\t  || (kind == TYPES_DOMAIN\n+\t\t\t      && SYMBOL_CLASS (sym) == LOC_TYPEDEF\n+\t\t\t      && SYMBOL_DOMAIN (sym) != MODULE_DOMAIN)\n+\t\t\t  || (kind == MODULES_DOMAIN\n+\t\t\t      && SYMBOL_DOMAIN (sym) == MODULE_DOMAIN\n+\t\t\t      && SYMBOL_LINE (sym) != 0))))\n+\t\t{\n+\t\t  /* Matching msymbol, add it to the results list.  */\n+\t\t  results->emplace_back (block, sym);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* See symtab.h.  */\n+\n+void\n+global_symbol_searcher::add_matching_msymbols\n+\t(objfile *objfile, const gdb::optional<compiled_regex> &preg,\n+\t std::vector<symbol_search> *results) const\n+{\n+  enum search_domain kind = m_kind;\n+\n+  for (minimal_symbol *msymbol : objfile->msymbols ())\n+    {\n+      QUIT;\n+\n+      if (msymbol->created_by_gdb)\n+\tcontinue;\n+\n+      if (is_suitable_msymbol (kind, msymbol))\n+\t{\n+\t  if (!preg.has_value ()\n+\t      || preg->exec (msymbol->natural_name (), 0,\n+\t\t\t     NULL, 0) == 0)\n+\t    {\n+\t      /* For functions we can do a quick check of whether the\n+\t\t symbol might be found via find_pc_symtab.  */\n+\t      if (kind != FUNCTIONS_DOMAIN\n+\t\t  || (find_pc_compunit_symtab\n+\t\t      (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n+\t\t      == NULL))\n+\t\t{\n+\t\t  if (lookup_symbol_in_objfile_from_linkage_name\n+\t\t      (objfile, msymbol->linkage_name (),\n+\t\t       VAR_DOMAIN).symbol == NULL)\n+\t\t    {\n+\t\t      /* Matching msymbol, add it to the results list.  */\n+\t\t      results->emplace_back (GLOBAL_BLOCK, msymbol, objfile);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n \n /* Sort the symbols in RESULT and remove duplicates.  */\n \n@@ -4461,35 +4675,11 @@ sort_search_symbols_remove_dups (std::vector<symbol_search> *result)\n std::vector<symbol_search>\n global_symbol_searcher::search () const\n {\n-  const struct blockvector *bv;\n-  const struct block *b;\n-  int i = 0;\n-  struct block_iterator iter;\n-  struct symbol *sym;\n-  int found_misc = 0;\n-  static const enum minimal_symbol_type types[]\n-    = {mst_data, mst_text, mst_unknown};\n-  static const enum minimal_symbol_type types2[]\n-    = {mst_bss, mst_file_text, mst_unknown};\n-  static const enum minimal_symbol_type types3[]\n-    = {mst_file_data, mst_solib_trampoline, mst_unknown};\n-  static const enum minimal_symbol_type types4[]\n-    = {mst_file_bss, mst_text_gnu_ifunc, mst_unknown};\n-  enum minimal_symbol_type ourtype;\n-  enum minimal_symbol_type ourtype2;\n-  enum minimal_symbol_type ourtype3;\n-  enum minimal_symbol_type ourtype4;\n-  std::vector<symbol_search> result;\n   gdb::optional<compiled_regex> preg;\n   gdb::optional<compiled_regex> treg;\n \n   gdb_assert (m_kind != ALL_DOMAIN);\n \n-  ourtype = types[m_kind];\n-  ourtype2 = types2[m_kind];\n-  ourtype3 = types3[m_kind];\n-  ourtype4 = types4[m_kind];\n-\n   if (m_symbol_name_regexp != NULL)\n     {\n       const char *symbol_name_regexp = m_symbol_name_regexp;\n@@ -4542,187 +4732,33 @@ global_symbol_searcher::search () const\n \t\t    _(\"Invalid regexp\"));\n     }\n \n-  /* Search through the partial symtabs *first* for all symbols matching\n-     the m_symbol_name_regexp (in preg).  That way we don't have to\n-     reproduce all of the machinery below.  */\n-  expand_symtabs_matching ([&] (const char *filename, bool basenames)\n-\t\t\t   {\n-\t\t\t     return file_matches (filename, filenames,\n-\t\t\t\t\t\t  basenames);\n-\t\t\t   },\n-\t\t\t   lookup_name_info::match_any (),\n-\t\t\t   [&] (const char *symname)\n-\t\t\t   {\n-\t\t\t     return (!preg.has_value ()\n-\t\t\t\t     || preg->exec (symname,\n-\t\t\t\t\t\t    0, NULL, 0) == 0);\n-\t\t\t   },\n-\t\t\t   NULL,\n-\t\t\t   m_kind);\n-\n-  /* Here, we search through the minimal symbol tables for functions\n-     and variables that match, and force their symbols to be read.\n-     This is in particular necessary for demangled variable names,\n-     which are no longer put into the partial symbol tables.\n-     The symbol will then be found during the scan of symtabs below.\n-\n-     For functions, find_pc_symtab should succeed if we have debug info\n-     for the function, for variables we have to call\n-     lookup_symbol_in_objfile_from_linkage_name to determine if the variable\n-     has debug info.\n-     If the lookup fails, set found_misc so that we will rescan to print\n-     any matching symbols without debug info.\n-     We only search the objfile the msymbol came from, we no longer search\n-     all objfiles.  In large programs (1000s of shared libs) searching all\n-     objfiles is not worth the pain.  */\n-\n-  if (filenames.empty () && (m_kind == VARIABLES_DOMAIN\n-\t\t\t     || m_kind == FUNCTIONS_DOMAIN))\n-    {\n-      for (objfile *objfile : current_program_space->objfiles ())\n-\t{\n-\t  for (minimal_symbol *msymbol : objfile->msymbols ())\n-\t    {\n-\t      QUIT;\n-\n-\t      if (msymbol->created_by_gdb)\n-\t\tcontinue;\n-\n-\t      if (MSYMBOL_TYPE (msymbol) == ourtype\n-\t\t  || MSYMBOL_TYPE (msymbol) == ourtype2\n-\t\t  || MSYMBOL_TYPE (msymbol) == ourtype3\n-\t\t  || MSYMBOL_TYPE (msymbol) == ourtype4)\n-\t\t{\n-\t\t  if (!preg.has_value ()\n-\t\t      || preg->exec (msymbol->natural_name (), 0,\n-\t\t\t\t     NULL, 0) == 0)\n-\t\t    {\n-\t\t      /* Note: An important side-effect of these\n-\t\t\t lookup functions is to expand the symbol\n-\t\t\t table if msymbol is found, for the benefit of\n-\t\t\t the next loop on compunits.  */\n-\t\t      if (m_kind == FUNCTIONS_DOMAIN\n-\t\t\t  ? (find_pc_compunit_symtab\n-\t\t\t     (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n-\t\t\t     == NULL)\n-\t\t\t  : (lookup_symbol_in_objfile_from_linkage_name\n-\t\t\t     (objfile, msymbol->linkage_name (), VAR_DOMAIN)\n-\t\t\t     .symbol == NULL))\n-\t\t\tfound_misc = 1;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n+  bool found_msymbol = false;\n+  std::vector<symbol_search> result;\n   for (objfile *objfile : current_program_space->objfiles ())\n     {\n-      for (compunit_symtab *cust : objfile->compunits ())\n-\t{\n-\t  bv = COMPUNIT_BLOCKVECTOR (cust);\n-\t  for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)\n-\t    {\n-\t      b = BLOCKVECTOR_BLOCK (bv, i);\n-\t      ALL_BLOCK_SYMBOLS (b, iter, sym)\n-\t\t{\n-\t\t  struct symtab *real_symtab = symbol_symtab (sym);\n-\n-\t\t  QUIT;\n-\n-\t\t  /* Check first sole REAL_SYMTAB->FILENAME.  It does\n-\t\t     not need to be a substring of symtab_to_fullname as\n-\t\t     it may contain \"./\" etc.  */\n-\t\t  if ((file_matches (real_symtab->filename, filenames, false)\n-\t\t       || ((basenames_may_differ\n-\t\t\t    || file_matches (lbasename (real_symtab->filename),\n-\t\t\t\t\t     filenames, true))\n-\t\t\t   && file_matches (symtab_to_fullname (real_symtab),\n-\t\t\t\t\t    filenames, false)))\n-\t\t      && ((!preg.has_value ()\n-\t\t\t   || preg->exec (sym->natural_name (), 0,\n-\t\t\t\t\t  NULL, 0) == 0)\n-\t\t\t  && ((m_kind == VARIABLES_DOMAIN\n-\t\t\t       && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n-\t\t\t       && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n-\t\t\t       && SYMBOL_CLASS (sym) != LOC_BLOCK\n-\t\t\t       /* LOC_CONST can be used for more than\n-\t\t\t\t  just enums, e.g., c++ static const\n-\t\t\t\t  members.  We only want to skip enums\n-\t\t\t\t  here.  */\n-\t\t\t       && !(SYMBOL_CLASS (sym) == LOC_CONST\n-\t\t\t\t    && (TYPE_CODE (SYMBOL_TYPE (sym))\n-\t\t\t\t\t== TYPE_CODE_ENUM))\n-\t\t\t       && (!treg.has_value ()\n-\t\t\t\t   || treg_matches_sym_type_name (*treg, sym)))\n-\t\t\t      || (m_kind == FUNCTIONS_DOMAIN\n-\t\t\t\t  && SYMBOL_CLASS (sym) == LOC_BLOCK\n-\t\t\t\t  && (!treg.has_value ()\n-\t\t\t\t      || treg_matches_sym_type_name (*treg,\n-\t\t\t\t\t\t\t\t     sym)))\n-\t\t\t      || (m_kind == TYPES_DOMAIN\n-\t\t\t\t  && SYMBOL_CLASS (sym) == LOC_TYPEDEF\n-\t\t\t\t  && SYMBOL_DOMAIN (sym) != MODULE_DOMAIN)\n-\t\t\t      || (m_kind == MODULES_DOMAIN\n-\t\t\t\t  && SYMBOL_DOMAIN (sym) == MODULE_DOMAIN\n-\t\t\t\t  && SYMBOL_LINE (sym) != 0))))\n-\t\t    {\n-\t\t      /* match */\n-\t\t      result.emplace_back (i, sym);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+      /* Expand symtabs within objfile that possibly contain matching\n+\t symbols.  */\n+      found_msymbol |= expand_symtabs (objfile, preg);\n+\n+      /* Find matching symbols within OBJFILE and add them in to the RESULT\n+\t vector.  */\n+      add_matching_symbols (objfile, preg, treg, &result);\n     }\n \n   if (!result.empty ())\n     sort_search_symbols_remove_dups (&result);\n \n   /* If there are no debug symbols, then add matching minsyms.  But if the\n-     user wants to see symbols matching a type m_symbol_type_regexp, then\n-     never give a minimal symbol, as we assume that a minimal symbol does\n-     not have a type.  */\n-\n-  if ((found_misc || (filenames.empty () && m_kind != FUNCTIONS_DOMAIN))\n+     user wants to see symbols matching a type regexp, then never give a\n+     minimal symbol, as we assume that a minimal symbol does not have a\n+     type.  */\n+  if ((found_msymbol || (filenames.empty () && m_kind == VARIABLES_DOMAIN))\n       && !m_exclude_minsyms\n       && !treg.has_value ())\n     {\n+      gdb_assert (m_kind == VARIABLES_DOMAIN || m_kind == FUNCTIONS_DOMAIN);\n       for (objfile *objfile : current_program_space->objfiles ())\n-\t{\n-\t  for (minimal_symbol *msymbol : objfile->msymbols ())\n-\t    {\n-\t      QUIT;\n-\n-\t      if (msymbol->created_by_gdb)\n-\t\tcontinue;\n-\n-\t      if (MSYMBOL_TYPE (msymbol) == ourtype\n-\t\t  || MSYMBOL_TYPE (msymbol) == ourtype2\n-\t\t  || MSYMBOL_TYPE (msymbol) == ourtype3\n-\t\t  || MSYMBOL_TYPE (msymbol) == ourtype4)\n-\t\t{\n-\t\t  if (!preg.has_value ()\n-\t\t      || preg->exec (msymbol->natural_name (), 0,\n-\t\t\t\t     NULL, 0) == 0)\n-\t\t    {\n-\t\t      /* For functions we can do a quick check of whether the\n-\t\t\t symbol might be found via find_pc_symtab.  */\n-\t\t      if (m_kind != FUNCTIONS_DOMAIN\n-\t\t\t  || (find_pc_compunit_symtab\n-\t\t\t      (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n-\t\t\t      == NULL))\n-\t\t\t{\n-\t\t\t  if (lookup_symbol_in_objfile_from_linkage_name\n-\t\t\t      (objfile, msymbol->linkage_name (), VAR_DOMAIN)\n-\t\t\t      .symbol == NULL)\n-\t\t\t    {\n-\t\t\t      /* match */\n-\t\t\t      result.emplace_back (i, msymbol, objfile);\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+\tadd_matching_msymbols (objfile, preg, &result);\n     }\n \n   return result;"
    },
    {
      "sha": "41abf1f38ff0af71412e4b82a13e84cac31410cc",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f97a63c5aa5203994447b3cf8e48f184078f379b/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f97a63c5aa5203994447b3cf8e48f184078f379b/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=f97a63c5aa5203994447b3cf8e48f184078f379b",
      "patch": "@@ -2124,6 +2124,29 @@ class global_symbol_searcher\n   /* When this flag is false then minsyms that match M_SYMBOL_REGEXP will\n      be included in the results, otherwise they are excluded.  */\n   bool m_exclude_minsyms = false;\n+\n+  /* Expand symtabs in OBJFILE that match PREG, are of type M_KIND.  Return\n+     true if any msymbols were seen that we should later consider adding to\n+     the results list.  */\n+  bool expand_symtabs (objfile *objfile,\n+\t\t       const gdb::optional<compiled_regex> &preg) const;\n+\n+  /* Add symbols from symtabs in OBJFILE that match PREG, and TREG, and are\n+     of type M_KIND, to the results vector RESULTS.  */\n+  void add_matching_symbols (objfile *objfile,\n+\t\t\t     const gdb::optional<compiled_regex> &preg,\n+\t\t\t     const gdb::optional<compiled_regex> &treg,\n+\t\t\t     std::vector<symbol_search> *results) const;\n+\n+  /* Add msymbols from OBJFILE that match PREG and M_KIND, to the\n+     results vector RESULTS.  */\n+  void add_matching_msymbols (objfile *objfile,\n+\t\t\t      const gdb::optional<compiled_regex> &preg,\n+\t\t\t      std::vector<symbol_search> *results) const;\n+\n+  /* Return true if MSYMBOL is of type KIND.  */\n+  static bool is_suitable_msymbol (const enum search_domain kind,\n+\t\t\t\t   const minimal_symbol *msymbol);\n };\n \n /* When searching for Fortran symbols within modules (functions/variables)"
    }
  ]
}