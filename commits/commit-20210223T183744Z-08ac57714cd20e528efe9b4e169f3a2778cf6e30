{
  "sha": "08ac57714cd20e528efe9b4e169f3a2778cf6e30",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDhhYzU3NzE0Y2QyMGU1MjhlZmU5YjRlMTY5ZjNhMjc3OGNmNmUzMA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-02-23T18:37:44Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-02-23T18:37:44Z"
    },
    "message": "gdb/dwarf: create and destroy dwarf2_per_bfd's CUs-to-expand queue\n\nAs described in the log of patch \"gdb/dwarf: add assertion in\nmaybe_queue_comp_unit\", it would happen that a call to\nmaybe_queue_comp_unit would enqueue a CU in the to-expand queue while\nnothing up the stack was processing the queue.  This is not desirable,\nas items are then left lingering in the queue when we exit the\ndwarf2/read code.  This is an inconsistent state.\n\nThe normal case of using the queue is when we go through\ndw2_do_instantiate_symtab and process_queue.  As depended-on CUs are\nfound, they get added to the queue.  process_queue expands CUs until the\nqueue is empty.\n\nTo catch these cases where things are enqueued while nothing up the\nstack is processing the queue, change dwarf2_per_bfd::queue to be an\noptional.  The optional is instantiated in dwarf2_queue_guard, just\nbefore where we call process_queue.  In the dwarf2_queue_guard\ndestructor, the optional gets reset.  Therefore, the queue object is\ninstantiated only when something up the stack is handling it.  If\nanother entry point tries to enqueue a CU for expansion, an assertion\nwill fail and we know we have something to fix.\n\ndwarf2_queue_guard sounds like the good place for this, as it's\ncurrently responsible for making sure the queue gets cleared if we exit\ndue to an error.\n\nThis also allows asserting that when age_comp_units or remove_all_cus\nrun, the queue is not instantiated, and gives us one more level of\nassurance that we won't free the DIEs of a CU that is in the\nCUs-to-expand queue.\n\ngdb/ChangeLog:\n\n\tPR gdb/26828\n\t* dwarf2/read.c (dwarf2_queue_guard) <dwarf2_queue_guard>:\n\tInstantiate queue.\n\t(~dwarf2_queue_guard): Clear queue.\n\t(queue_comp_unit): Assert that queue is\n\tinstantiated.\n\t(process_queue): Adjust.\n\t* dwarf2/read.h (struct dwarf2_per_bfd) <queue>: Make optional.\n\nChange-Id: I8fe3d77845bb4ad3d309eac906acebe79d9f0a9d",
    "tree": {
      "sha": "b74e30e1e5d4f6dc6bbd45c1d4959f9b4586e7a5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b74e30e1e5d4f6dc6bbd45c1d4959f9b4586e7a5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/08ac57714cd20e528efe9b4e169f3a2778cf6e30",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08ac57714cd20e528efe9b4e169f3a2778cf6e30",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/08ac57714cd20e528efe9b4e169f3a2778cf6e30",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08ac57714cd20e528efe9b4e169f3a2778cf6e30/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "616c069a3f1a841e5bc63d20aec8e5b71b499f6c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/616c069a3f1a841e5bc63d20aec8e5b71b499f6c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/616c069a3f1a841e5bc63d20aec8e5b71b499f6c"
    }
  ],
  "stats": {
    "total": 87,
    "additions": 57,
    "deletions": 30
  },
  "files": [
    {
      "sha": "d189a0919b277a8d96cfc3ce4975f79ebf116630",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08ac57714cd20e528efe9b4e169f3a2778cf6e30/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08ac57714cd20e528efe9b4e169f3a2778cf6e30/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=08ac57714cd20e528efe9b4e169f3a2778cf6e30",
      "patch": "@@ -1,3 +1,14 @@\n+2021-02-23  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\tPR gdb/26828\n+\t* dwarf2/read.c (dwarf2_queue_guard) <dwarf2_queue_guard>:\n+\tInstantiate queue.\n+\t(~dwarf2_queue_guard): Clear queue.\n+\t(queue_comp_unit): Assert that queue is\n+\tinstantiated.\n+\t(process_queue): Adjust.\n+\t* dwarf2/read.h (struct dwarf2_per_bfd) <queue>: Make optional.\n+\n 2021-02-23  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \tPR gdb/26828"
    },
    {
      "sha": "0fccce869fc09aac5d0fd1bc4b1dc7a3db59bb55",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 45,
      "deletions": 29,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08ac57714cd20e528efe9b4e169f3a2778cf6e30/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08ac57714cd20e528efe9b4e169f3a2778cf6e30/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=08ac57714cd20e528efe9b4e169f3a2778cf6e30",
      "patch": "@@ -1684,15 +1684,18 @@ class dwarf2_queue_guard\n   explicit dwarf2_queue_guard (dwarf2_per_objfile *per_objfile)\n     : m_per_objfile (per_objfile)\n   {\n+    gdb_assert (!m_per_objfile->per_bfd->queue.has_value ());\n+\n+    m_per_objfile->per_bfd->queue.emplace ();\n   }\n \n   /* Free any entries remaining on the queue.  There should only be\n      entries left if we hit an error while processing the dwarf.  */\n   ~dwarf2_queue_guard ()\n   {\n-    /* Ensure that no memory is allocated by the queue.  */\n-    std::queue<dwarf2_queue_item> empty;\n-    std::swap (m_per_objfile->per_bfd->queue, empty);\n+    gdb_assert (m_per_objfile->per_bfd->queue.has_value ());\n+\n+    m_per_objfile->per_bfd->queue.reset ();\n   }\n \n   DISABLE_COPY_AND_ASSIGN (dwarf2_queue_guard);\n@@ -1861,6 +1864,8 @@ dwarf2_per_bfd::~dwarf2_per_bfd ()\n void\n dwarf2_per_objfile::remove_all_cus ()\n {\n+  gdb_assert (!this->per_bfd->queue.has_value ());\n+\n   for (auto pair : m_dwarf2_cus)\n     delete pair.second;\n \n@@ -2542,30 +2547,32 @@ dw2_do_instantiate_symtab (dwarf2_per_cu_data *per_cu,\n   if (per_cu->type_unit_group_p ())\n     return;\n \n-  /* The destructor of dwarf2_queue_guard frees any entries left on\n-     the queue.  After this point we're guaranteed to leave this function\n-     with the dwarf queue empty.  */\n-  dwarf2_queue_guard q_guard (per_objfile);\n-\n-  if (!per_objfile->symtab_set_p (per_cu))\n-    {\n-      queue_comp_unit (per_cu, per_objfile, language_minimal);\n-      dwarf2_cu *cu = load_cu (per_cu, per_objfile, skip_partial);\n+  {\n+    /* The destructor of dwarf2_queue_guard frees any entries left on\n+       the queue.  After this point we're guaranteed to leave this function\n+       with the dwarf queue empty.  */\n+    dwarf2_queue_guard q_guard (per_objfile);\n \n-      /* If we just loaded a CU from a DWO, and we're working with an index\n-\t that may badly handle TUs, load all the TUs in that DWO as well.\n-\t http://sourceware.org/bugzilla/show_bug.cgi?id=15021  */\n-      if (!per_cu->is_debug_types\n-\t  && cu != NULL\n-\t  && cu->dwo_unit != NULL\n-\t  && per_objfile->per_bfd->index_table != NULL\n-\t  && per_objfile->per_bfd->index_table->version <= 7\n-\t  /* DWP files aren't supported yet.  */\n-\t  && get_dwp_file (per_objfile) == NULL)\n-\tqueue_and_load_all_dwo_tus (cu);\n-    }\n+    if (!per_objfile->symtab_set_p (per_cu))\n+      {\n+\tqueue_comp_unit (per_cu, per_objfile, language_minimal);\n+\tdwarf2_cu *cu = load_cu (per_cu, per_objfile, skip_partial);\n+\n+\t/* If we just loaded a CU from a DWO, and we're working with an index\n+\t   that may badly handle TUs, load all the TUs in that DWO as well.\n+\t   http://sourceware.org/bugzilla/show_bug.cgi?id=15021  */\n+\tif (!per_cu->is_debug_types\n+\t    && cu != NULL\n+\t    && cu->dwo_unit != NULL\n+\t    && per_objfile->per_bfd->index_table != NULL\n+\t    && per_objfile->per_bfd->index_table->version <= 7\n+\t    /* DWP files aren't supported yet.  */\n+\t    && get_dwp_file (per_objfile) == NULL)\n+\t  queue_and_load_all_dwo_tus (cu);\n+      }\n \n-  process_queue (per_objfile);\n+    process_queue (per_objfile);\n+  }\n \n   /* Age the cache, releasing compilation units that have not\n      been used recently.  */\n@@ -9180,7 +9187,9 @@ queue_comp_unit (dwarf2_per_cu_data *per_cu,\n \t\t enum language pretend_language)\n {\n   per_cu->queued = 1;\n-  per_cu->per_bfd->queue.emplace (per_cu, per_objfile, pretend_language);\n+\n+  gdb_assert (per_objfile->per_bfd->queue.has_value ());\n+  per_cu->per_bfd->queue->emplace (per_cu, per_objfile, pretend_language);\n }\n \n /* If PER_CU is not yet expanded of queued for expansion, add it to the queue.\n@@ -9275,9 +9284,9 @@ process_queue (dwarf2_per_objfile *per_objfile)\n \n   /* The queue starts out with one item, but following a DIE reference\n      may load a new CU, adding it to the end of the queue.  */\n-  while (!per_objfile->per_bfd->queue.empty ())\n+  while (!per_objfile->per_bfd->queue->empty ())\n     {\n-      dwarf2_queue_item &item = per_objfile->per_bfd->queue.front ();\n+      dwarf2_queue_item &item = per_objfile->per_bfd->queue->front ();\n       dwarf2_per_cu_data *per_cu = item.per_cu;\n \n       if (!per_objfile->symtab_set_p (per_cu))\n@@ -9323,7 +9332,7 @@ process_queue (dwarf2_per_objfile *per_objfile)\n \t}\n \n       per_cu->queued = 0;\n-      per_objfile->per_bfd->queue.pop ();\n+      per_objfile->per_bfd->queue->pop ();\n     }\n \n   dwarf_read_debug_printf (\"Done expanding symtabs of %s.\",\n@@ -25122,6 +25131,13 @@ dwarf2_per_objfile::age_comp_units ()\n {\n   dwarf_read_debug_printf_v (\"running\");\n \n+  /* This is not expected to be called in the middle of CU expansion.  There is\n+     an invariant that if a CU is in the CUs-to-expand queue, its DIEs are\n+     loaded in memory.  Calling age_comp_units while the queue is in use could\n+     make us free the DIEs for a CU that is in the queue and therefore break\n+     that invariant.  */\n+  gdb_assert (!this->per_bfd->queue.has_value ());\n+\n   /* Start by clearing all marks.  */\n   for (auto pair : m_dwarf2_cus)\n     pair.second->mark = false;"
    },
    {
      "sha": "c7f6a111b8c4c321568318acb454fb1e893dd510",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08ac57714cd20e528efe9b4e169f3a2778cf6e30/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08ac57714cd20e528efe9b4e169f3a2778cf6e30/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=08ac57714cd20e528efe9b4e169f3a2778cf6e30",
      "patch": "@@ -250,7 +250,7 @@ struct dwarf2_per_bfd\n     abstract_to_concrete;\n \n   /* CUs that are queued to be read.  */\n-  std::queue<dwarf2_queue_item> queue;\n+  gdb::optional<std::queue<dwarf2_queue_item>> queue;\n \n   /* We keep a separate reference to the partial symtabs, in case we\n      are sharing them between objfiles.  This is only set after"
    }
  ]
}