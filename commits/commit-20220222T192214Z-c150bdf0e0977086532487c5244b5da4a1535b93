{
  "sha": "c150bdf0e0977086532487c5244b5da4a1535b93",
  "node_id": "C_kwDOANOeidoAKGMxNTBiZGYwZTA5NzcwODY1MzI0ODdjNTI0NGI1ZGE0YTE1MzViOTM",
  "commit": {
    "author": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-02-22T19:22:14Z"
    },
    "committer": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-02-22T19:22:14Z"
    },
    "message": "gdb linux-nat: Convert linux_nat_event_pipe to the event_pipe class.\n\nUse event_pipe from gdbsupport in place of the existing file\ndescriptor array.",
    "tree": {
      "sha": "1b1edfd9dfa08d38481448a5681517c6eeb7aa8c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1b1edfd9dfa08d38481448a5681517c6eeb7aa8c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c150bdf0e0977086532487c5244b5da4a1535b93",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c150bdf0e0977086532487c5244b5da4a1535b93",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c150bdf0e0977086532487c5244b5da4a1535b93",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c150bdf0e0977086532487c5244b5da4a1535b93/comments",
  "author": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ea3e7446dcac18abb68772ce4e04b72815f49745",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea3e7446dcac18abb68772ce4e04b72815f49745",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ea3e7446dcac18abb68772ce4e04b72815f49745"
    }
  ],
  "stats": {
    "total": 59,
    "additions": 16,
    "deletions": 43
  },
  "files": [
    {
      "sha": "5e22d1d3f98bff08ad4e9a007e0647e69dd12424",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 16,
      "deletions": 43,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c150bdf0e0977086532487c5244b5da4a1535b93/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c150bdf0e0977086532487c5244b5da4a1535b93/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=c150bdf0e0977086532487c5244b5da4a1535b93",
      "patch": "@@ -48,6 +48,7 @@\n #include <fcntl.h>\t\t/* for O_RDONLY */\n #include \"inf-loop.h\"\n #include \"gdbsupport/event-loop.h\"\n+#include \"gdbsupport/event-pipe.h\"\n #include \"event-top.h\"\n #include <pwd.h>\n #include <sys/types.h>\n@@ -111,11 +112,11 @@ and target events, so neither blocking waitpid nor sigsuspend are\n viable options.  Instead, we should asynchronously notify the GDB main\n event loop whenever there's an unprocessed event from the target.  We\n detect asynchronous target events by handling SIGCHLD signals.  To\n-notify the event loop about target events, the self-pipe trick is used\n---- a pipe is registered as waitable event source in the event loop,\n+notify the event loop about target events, an event pipe is used\n+--- the pipe is registered as waitable event source in the event loop,\n the event loop select/poll's on the read end of this pipe (as well on\n-other event sources, e.g., stdin), and the SIGCHLD handler writes a\n-byte to this pipe.  This is more portable than relying on\n+other event sources, e.g., stdin), and the SIGCHLD handler marks the\n+event pipe to raise an event.  This is more portable than relying on\n pselect/ppoll, since on kernels that lack those syscalls, libc\n emulates them with select/poll+sigprocmask, and that is racy\n (a.k.a. plain broken).\n@@ -228,26 +229,18 @@ static int report_thread_events;\n \n /* Async mode support.  */\n \n-/* The read/write ends of the pipe registered as waitable file in the\n-   event loop.  */\n-static int linux_nat_event_pipe[2] = { -1, -1 };\n+/* The event pipe registered as a waitable file in the event loop.  */\n+static event_pipe linux_nat_event_pipe;\n \n /* True if we're currently in async mode.  */\n-#define linux_is_async_p() (linux_nat_event_pipe[0] != -1)\n+#define linux_is_async_p() (linux_nat_event_pipe.is_open ())\n \n /* Flush the event pipe.  */\n \n static void\n async_file_flush (void)\n {\n-  int ret;\n-  char buf;\n-\n-  do\n-    {\n-      ret = read (linux_nat_event_pipe[0], &buf, 1);\n-    }\n-  while (ret >= 0 || (ret == -1 && errno == EINTR));\n+  linux_nat_event_pipe.flush ();\n }\n \n /* Put something (anything, doesn't matter what, or how much) in event\n@@ -257,21 +250,7 @@ async_file_flush (void)\n static void\n async_file_mark (void)\n {\n-  int ret;\n-\n-  /* It doesn't really matter what the pipe contains, as long we end\n-     up with something in it.  Might as well flush the previous\n-     left-overs.  */\n-  async_file_flush ();\n-\n-  do\n-    {\n-      ret = write (linux_nat_event_pipe[1], \"+\", 1);\n-    }\n-  while (ret == -1 && errno == EINTR);\n-\n-  /* Ignore EAGAIN.  If the pipe is full, the event loop will already\n-     be awakened anyway.  */\n+  linux_nat_event_pipe.mark ();\n }\n \n static int kill_lwp (int lwpid, int signo);\n@@ -4141,7 +4120,7 @@ sigchld_handler (int signo)\n     gdb_stdlog->write_async_safe (\"sigchld\\n\", sizeof (\"sigchld\\n\") - 1);\n \n   if (signo == SIGCHLD\n-      && linux_nat_event_pipe[0] != -1)\n+      && linux_nat_event_pipe.is_open ())\n     async_file_mark (); /* Let the event loop know that there are\n \t\t\t   events to handle.  */\n \n@@ -4173,19 +4152,13 @@ linux_async_pipe (int enable)\n \n       if (enable)\n \t{\n-\t  if (gdb_pipe_cloexec (linux_nat_event_pipe) == -1)\n+\t  if (!linux_nat_event_pipe.open ())\n \t    internal_error (__FILE__, __LINE__,\n \t\t\t    \"creating event pipe failed.\");\n-\n-\t  fcntl (linux_nat_event_pipe[0], F_SETFL, O_NONBLOCK);\n-\t  fcntl (linux_nat_event_pipe[1], F_SETFL, O_NONBLOCK);\n \t}\n       else\n \t{\n-\t  close (linux_nat_event_pipe[0]);\n-\t  close (linux_nat_event_pipe[1]);\n-\t  linux_nat_event_pipe[0] = -1;\n-\t  linux_nat_event_pipe[1] = -1;\n+\t  linux_nat_event_pipe.close ();\n \t}\n \n       restore_child_signals_mask (&prev_mask);\n@@ -4197,7 +4170,7 @@ linux_async_pipe (int enable)\n int\n linux_nat_target::async_wait_fd ()\n {\n-  return linux_nat_event_pipe[0];\n+  return linux_nat_event_pipe.event_fd ();\n }\n \n /* target_async implementation.  */\n@@ -4209,7 +4182,7 @@ linux_nat_target::async (int enable)\n     {\n       if (!linux_async_pipe (1))\n \t{\n-\t  add_file_handler (linux_nat_event_pipe[0],\n+\t  add_file_handler (linux_nat_event_pipe.event_fd (),\n \t\t\t    handle_target_event, NULL,\n \t\t\t    \"linux-nat\");\n \t  /* There may be pending events to handle.  Tell the event loop\n@@ -4219,7 +4192,7 @@ linux_nat_target::async (int enable)\n     }\n   else\n     {\n-      delete_file_handler (linux_nat_event_pipe[0]);\n+      delete_file_handler (linux_nat_event_pipe.event_fd ());\n       linux_async_pipe (0);\n     }\n   return;"
    }
  ]
}