{
  "sha": "fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmQ1NWVhZTg0ZDhiOTRiNDk3YzYwNDNlNWFhNmUxMTFlN2Y1YTIyNQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-07-06T16:36:21Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-10-03T16:04:55Z"
    },
    "message": "libctf: allow the header to change between versions\n\nlibctf supports dynamic upgrading of the type table as file format\nversions change, but before now has not supported changes to the CTF\nheader.  Doing this is complicated by the baroque storage method used:\nthe CTF header is kept prepended to the rest of the CTF data, just as\nwhen read from the file, and written out from there, and is\nendian-flipped in place.\n\nThis makes accessing it needlessly hard and makes it almost impossible\nto make the header larger if we add fields.  The general storage\nmachinery around the malloced ctf pointer (the 'ctf_base') is also\novercomplicated: the pointer is sometimes malloced locally and sometimes\nassigned from a parameter, so freeing it requires checking to see if\nthat parameter was used, needlessly coupling ctf_bufopen and\nctf_file_close together.\n\nSo split the header out into a new ctf_file_t.ctf_header, which is\nwritten out explicitly: squeeze it out of the CTF buffer whenever we\nreallocate it, and use ctf_file_t.ctf_buf to skip past the header when\nwe do not need to reallocate (when no upgrading or endian-flipping is\nrequired).  We now track whether the CTF base can be freed explicitly\nvia a new ctf_dynbase pointer which is non-NULL only when freeing is\npossible.\n\nWith all this done, we can upgrade the header on the fly and add new\nfields as desired, via a new upgrade_header function in ctf-open.\nAs with other forms of upgrading, libctf upgrades older headers\nautomatically to the latest supported version at open time.\n\nFor a first use of this field, we add a new string field cth_cuname, and\na corresponding setter/getter pair ctf_cuname_set and ctf_cuname: this\nis used by debuggers to determine whether a CTF section's types relate\nto a single compilation unit, or to all compilation units in the\nprogram.  (Types with ambiguous definitions in different CUs have only\none of these types placed in the top-level shared .ctf container: the\nrest are placed in much smaller per-CU containers, which have the shared\ncontainer as their parent.  Since CTF must be useful in the absence of\nDWARF, we store the names of the relevant CUs ourselves, so the debugger\ncan look them up.)\n\nv5: fix tabdamage.\n\ninclude/\n\t* ctf-api.h (ctf_cuname): New function.\n\t(ctf_cuname_set): Likewise.\n\t* ctf.h: Improve comment around upgrading, no longer\n\timplying that v2 is the target of upgrades (it is v3 now).\n\t(ctf_header_v2_t): New, old-format header for backward\n\tcompatibility.\n\t(ctf_header_t): Add cth_cuname: this is the first of several\n\theader changes in format v3.\nlibctf/\n\t* ctf-impl.h (ctf_file_t): New fields ctf_header, ctf_dynbase,\n\tctf_cuname, ctf_dyncuname: ctf_base and ctf_buf are no longer const.\n\t* ctf-open.c (ctf_set_base): Preserve the gap between ctf_buf and\n\tctf_base: do not assume that it is always sizeof (ctf_header_t).\n\tPrint out ctf_cuname: only print out ctf_parname if set.\n\t(ctf_free_base): Removed, ctf_base is no longer freed: free\n\tctf_dynbase instead.\n\t(ctf_set_version): Fix spacing.\n\t(upgrade_header): New, in-place header upgrading.\n\t(upgrade_types): Rename to...\n\t(upgrade_types_v1): ... this.  Free ctf_dynbase, not ctf_base.  No\n\tlonger track old and new headers separately.  No longer allow for\n\theader sizes explicitly: squeeze the headers out on upgrade (they\n\tare preserved in fp->ctf_header).  Set ctf_dynbase, ctf_base and\n\tctf_buf explicitly.  Use ctf_free, not ctf_free_base.\n\t(upgrade_types): New, also handle ctf_parmax updating.\n\t(flip_header): Flip ctf_cuname.\n\t(flip_types): Flip BUF explicitly rather than deriving BUF from\n\tBASE.\n\t(ctf_bufopen): Store the header in fp->ctf_header.  Correct minimum\n\trequired alignment of objtoff and funcoff.  No longer store it in\n\tthe ctf_buf unless that buf is derived unmodified from the input.\n\tSet ctf_dynbase where ctf_base is dynamically allocated. Drop locals\n\tthat duplicate fields in ctf_file: move allocation of ctf_file\n\tfurther up instead.  Call upgrade_header as needed.  Move\n\tversion-specific ctf_parmax initialization into upgrade_types.  More\n\tconcise error handling.\n\t(ctf_file_close): No longer test for null pointers before freeing.\n\tFree ctf_dyncuname, ctf_dynbase, and ctf_header.  Do not call\n\tctf_free_base.\n\t(ctf_cuname): New.\n\t(ctf_cuname_set): New.\n\t* ctf-create.c (ctf_update): Populate ctf_cuname.\n\t(ctf_gzwrite): Write out the header explicitly.  Remove obsolescent\n\tcomment.\n\t(ctf_write): Likewise.\n\t(ctf_compress_write): Get the header from ctf_header, not ctf_base.\n\tFix the compression length: fp->ctf_size never counted the CTF\n\theader.  Simplify the compress call accordingly.",
    "tree": {
      "sha": "bb17a5265cdaf3b0ede0e38ba1437597ea0433e7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bb17a5265cdaf3b0ede0e38ba1437597ea0433e7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "083114f8ba2baa16a48638ecbf41e333eedb738b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/083114f8ba2baa16a48638ecbf41e333eedb738b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/083114f8ba2baa16a48638ecbf41e333eedb738b"
    }
  ],
  "stats": {
    "total": 512,
    "additions": 333,
    "deletions": 179
  },
  "files": [
    {
      "sha": "de933943ce5ad0614b9213597a9d4ec639f1505c",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
      "patch": "@@ -1,3 +1,14 @@\n+2019-07-06  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_cuname): New function.\n+\t(ctf_cuname_set): Likewise.\n+\t* ctf.h: Improve comment around upgrading, no longer\n+\timplying that v2 is the target of upgrades (it is v3 now).\n+\t(ctf_header_v2_t): New, old-format header for backward\n+\tcompatibility.\n+\t(ctf_header_t): Add cth_cuname: this is the first of several\n+\theader changes in format v3.\n+\n 2019-09-23  Alan Modra  <amodra@gmail.com>\n \n \t* bfdlink.h (struct bfd_section_already_linked): Forward declare."
    },
    {
      "sha": "28256a3c4e86aadbef21dcd7596b6cbfbe25714e",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
      "patch": "@@ -258,6 +258,8 @@ extern void ctf_file_close (ctf_file_t *);\n extern int ctf_arc_write (const char *, ctf_file_t **, size_t,\n \t\t\t  const char **, size_t);\n \n+extern const char *ctf_cuname (ctf_file_t *);\n+extern void ctf_cuname_set (ctf_file_t *, const char *);\n extern ctf_file_t *ctf_parent_file (ctf_file_t *);\n extern const char *ctf_parent_name (ctf_file_t *);\n extern void ctf_parent_name_set (ctf_file_t *, const char *);"
    },
    {
      "sha": "7e00005d27e618b5c06960079fa28f06e03b315c",
      "filename": "include/ctf.h",
      "status": "modified",
      "additions": 23,
      "deletions": 7,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/include/ctf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/include/ctf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf.h?ref=fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
      "patch": "@@ -126,11 +126,26 @@ typedef struct ctf_preamble\n   unsigned char ctp_flags;\t/* Flags (see below).  */\n } ctf_preamble_t;\n \n+typedef struct ctf_header_v2\n+{\n+  ctf_preamble_t cth_preamble;\n+  uint32_t cth_parlabel;\t/* Ref to name of parent lbl uniq'd against.  */\n+  uint32_t cth_parname;\t\t/* Ref to basename of parent.  */\n+  uint32_t cth_lbloff;\t\t/* Offset of label section.  */\n+  uint32_t cth_objtoff;\t\t/* Offset of object section.  */\n+  uint32_t cth_funcoff;\t\t/* Offset of function section.  */\n+  uint32_t cth_varoff;\t\t/* Offset of variable section.  */\n+  uint32_t cth_typeoff;\t\t/* Offset of type section.  */\n+  uint32_t cth_stroff;\t\t/* Offset of string section.  */\n+  uint32_t cth_strlen;\t\t/* Length of string section in bytes.  */\n+} ctf_header_v2_t;\n+\n typedef struct ctf_header\n {\n   ctf_preamble_t cth_preamble;\n   uint32_t cth_parlabel;\t/* Ref to name of parent lbl uniq'd against.  */\n   uint32_t cth_parname;\t\t/* Ref to basename of parent.  */\n+  uint32_t cth_cuname;\t\t/* Ref to CU name (may be 0).  */\n   uint32_t cth_lbloff;\t\t/* Offset of label section.  */\n   uint32_t cth_objtoff;\t\t/* Offset of object section.  */\n   uint32_t cth_funcoff;\t\t/* Offset of function section.  */\n@@ -148,13 +163,14 @@ typedef struct ctf_header\n \n /* Data format version number.  */\n \n-/* v1 upgraded to v2 is not quite the same as native v2 (the boundary between\n-   parent and child types is different), and you can write it out again via\n-   ctf_compress_write(), so we must track whether the thing was originally v1 or\n-   not.  If we were writing the header from scratch, we would add a *pair* of\n-   version number fields to allow for this, but this will do for now.  (A flag\n-   will not do, because we need to encode both the version we came from and the\n-   version we went to, not just \"we were upgraded\".) */\n+/* v1 upgraded to a later version is not quite the same as the native form,\n+   because the boundary between parent and child types is different but not\n+   recorded anywhere, and you can write it out again via ctf_compress_write(),\n+   so we must track whether the thing was originally v1 or not.  If we were\n+   writing the header from scratch, we would add a *pair* of version number\n+   fields to allow for this, but this will do for now.  (A flag will not do,\n+   because we need to encode both the version we came from and the version we\n+   went to, not just \"we were upgraded\".) */\n \n # define CTF_VERSION_1 1\n # define CTF_VERSION_1_UPGRADED_3 2"
    },
    {
      "sha": "9188a25c7f220066d96a4c89085c795ba3f08d1d",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 42,
      "deletions": 0,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
      "patch": "@@ -1,3 +1,45 @@\n+2019-07-06  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_file_t): New fields ctf_header, ctf_dynbase,\n+\tctf_cuname, ctf_dyncuname: ctf_base and ctf_buf are no longer const.\n+\t* ctf-open.c (ctf_set_base): Preserve the gap between ctf_buf and\n+\tctf_base: do not assume that it is always sizeof (ctf_header_t).\n+\tPrint out ctf_cuname: only print out ctf_parname if set.\n+\t(ctf_free_base): Removed, ctf_base is no longer freed: free\n+\tctf_dynbase instead.\n+\t(ctf_set_version): Fix spacing.\n+\t(upgrade_header): New, in-place header upgrading.\n+\t(upgrade_types): Rename to...\n+\t(upgrade_types_v1): ... this.  Free ctf_dynbase, not ctf_base.  No\n+\tlonger track old and new headers separately.  No longer allow for\n+\theader sizes explicitly: squeeze the headers out on upgrade (they\n+\tare preserved in fp->ctf_header).  Set ctf_dynbase, ctf_base and\n+\tctf_buf explicitly.  Use ctf_free, not ctf_free_base.\n+\t(upgrade_types): New, also handle ctf_parmax updating.\n+\t(flip_header): Flip ctf_cuname.\n+\t(flip_types): Flip BUF explicitly rather than deriving BUF from\n+\tBASE.\n+\t(ctf_bufopen): Store the header in fp->ctf_header.  Correct minimum\n+\trequired alignment of objtoff and funcoff.  No longer store it in\n+\tthe ctf_buf unless that buf is derived unmodified from the input.\n+\tSet ctf_dynbase where ctf_base is dynamically allocated. Drop locals\n+\tthat duplicate fields in ctf_file: move allocation of ctf_file\n+\tfurther up instead.  Call upgrade_header as needed.  Move\n+\tversion-specific ctf_parmax initialization into upgrade_types.  More\n+\tconcise error handling.\n+\t(ctf_file_close): No longer test for null pointers before freeing.\n+\tFree ctf_dyncuname, ctf_dynbase, and ctf_header.  Do not call\n+\tctf_free_base.\n+\t(ctf_cuname): New.\n+\t(ctf_cuname_set): New.\n+\t* ctf-create.c (ctf_update): Populate ctf_cuname.\n+\t(ctf_gzwrite): Write out the header explicitly.  Remove obsolescent\n+\tcomment.\n+\t(ctf_write): Likewise.\n+\t(ctf_compress_write): Get the header from ctf_header, not ctf_base.\n+\tFix the compression length: fp->ctf_size never counted the CTF\n+\theader.  Simplify the compress call accordingly.\n+\n 2019-07-11  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* ctf-endian.h: Don't assume htole64 and le64toh are always"
    },
    {
      "sha": "cef235199efb42690048fd21a2d17b7c10a0acdb",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 38,
      "deletions": 14,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
      "patch": "@@ -294,6 +294,8 @@ ctf_update (ctf_file_t *fp)\n   hdrp = (ctf_header_t *) buf;\n   if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parname != NULL))\n     ctf_str_add_ref (fp, fp->ctf_parname, &hdrp->cth_parname);\n+  if (fp->ctf_cuname != NULL)\n+    ctf_str_add_ref (fp, fp->ctf_cuname, &hdrp->cth_cuname);\n \n   /* Work over the variable list, translating everything into ctf_varent_t's and\n      prepping the string table.  */\n@@ -443,7 +445,8 @@ ctf_update (ctf_file_t *fp)\n \n   nfp->ctf_refcnt = fp->ctf_refcnt;\n   nfp->ctf_flags |= fp->ctf_flags & ~LCTF_DIRTY;\n-  nfp->ctf_data.cts_data = NULL;\t/* Force ctf_free() on close.  */\n+  if (nfp->ctf_dynbase == NULL)\n+    nfp->ctf_dynbase = buf;\t\t/* Make sure buf is freed on close.  */\n   nfp->ctf_dthash = fp->ctf_dthash;\n   nfp->ctf_dtdefs = fp->ctf_dtdefs;\n   nfp->ctf_dtbyname = fp->ctf_dtbyname;\n@@ -1919,15 +1922,26 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n   return dst_type;\n }\n \n-/* Write the compressed CTF data stream to the specified gzFile descriptor.\n-   This is useful for saving the results of dynamic CTF containers.  */\n+/* Write the compressed CTF data stream to the specified gzFile descriptor.  */\n int\n ctf_gzwrite (ctf_file_t *fp, gzFile fd)\n {\n-  const unsigned char *buf = fp->ctf_base;\n-  ssize_t resid = fp->ctf_size;\n+  const unsigned char *buf;\n+  ssize_t resid;\n   ssize_t len;\n \n+  resid = sizeof (ctf_header_t);\n+  buf = (unsigned char *) fp->ctf_header;\n+  while (resid != 0)\n+    {\n+      if ((len = gzwrite (fd, buf, resid)) <= 0)\n+\treturn (ctf_set_errno (fp, errno));\n+      resid -= len;\n+      buf += len;\n+    }\n+\n+  resid = fp->ctf_size;\n+  buf = fp->ctf_buf;\n   while (resid != 0)\n     {\n       if ((len = gzwrite (fd, buf, resid)) <= 0)\n@@ -1950,21 +1964,20 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n   ctf_header_t *hp = &h;\n   ssize_t header_len = sizeof (ctf_header_t);\n   ssize_t compress_len;\n-  size_t max_compress_len = compressBound (fp->ctf_size - header_len);\n+  size_t max_compress_len = compressBound (fp->ctf_size);\n   ssize_t len;\n   int rc;\n   int err = 0;\n \n-  memcpy (hp, fp->ctf_base, header_len);\n+  memcpy (hp, fp->ctf_header, header_len);\n   hp->cth_flags |= CTF_F_COMPRESS;\n \n   if ((buf = ctf_alloc (max_compress_len)) == NULL)\n     return (ctf_set_errno (fp, ECTF_ZALLOC));\n \n   compress_len = max_compress_len;\n   if ((rc = compress (buf, (uLongf *) &compress_len,\n-\t\t      fp->ctf_base + header_len,\n-\t\t      fp->ctf_size - header_len)) != Z_OK)\n+\t\t      fp->ctf_buf, fp->ctf_size)) != Z_OK)\n     {\n       ctf_dprintf (\"zlib deflate err: %s\\n\", zError (rc));\n       err = ctf_set_errno (fp, ECTF_COMPRESS);\n@@ -2000,18 +2013,29 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n   return err;\n }\n \n-/* Write the uncompressed CTF data stream to the specified file descriptor.\n-   This is useful for saving the results of dynamic CTF containers.  */\n+/* Write the uncompressed CTF data stream to the specified file descriptor.  */\n int\n ctf_write (ctf_file_t *fp, int fd)\n {\n-  const unsigned char *buf = fp->ctf_base;\n-  ssize_t resid = fp->ctf_size;\n+  const unsigned char *buf;\n+  ssize_t resid;\n   ssize_t len;\n \n+  resid = sizeof (ctf_header_t);\n+  buf = (unsigned char *) fp->ctf_header;\n+  while (resid != 0)\n+    {\n+      if ((len = write (fd, buf, resid)) <= 0)\n+\treturn (ctf_set_errno (fp, errno));\n+      resid -= len;\n+      buf += len;\n+    }\n+\n+  resid = fp->ctf_size;\n+  buf = fp->ctf_buf;\n   while (resid != 0)\n     {\n-      if ((len = write (fd, buf, resid)) < 0)\n+      if ((len = write (fd, buf, resid)) <= 0)\n \treturn (ctf_set_errno (fp, errno));\n       resid -= len;\n       buf += len;"
    },
    {
      "sha": "1cfab431cac681f773b5a5ce8c7f2a7ed56080ca",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
      "patch": "@@ -217,6 +217,7 @@ typedef struct ctf_str_atom_ref\n struct ctf_file\n {\n   const ctf_fileops_t *ctf_fileops; /* Version-specific file operations.  */\n+  struct ctf_header *ctf_header;    /* The header from this CTF file.  */\n   ctf_sect_t ctf_data;\t\t    /* CTF data from object file.  */\n   ctf_sect_t ctf_symtab;\t    /* Symbol table from object file.  */\n   ctf_sect_t ctf_strtab;\t    /* String table from object file.  */\n@@ -230,8 +231,9 @@ struct ctf_file\n   ctf_strs_t ctf_str[2];\t    /* Array of string table base and bounds.  */\n   ctf_dynhash_t *ctf_str_atoms;\t  /* Hash table of ctf_str_atoms_t.  */\n   uint64_t ctf_str_num_refs;\t  /* Number of refs to cts_str_atoms.  */\n-  const unsigned char *ctf_base;  /* Base of CTF header + uncompressed buffer.  */\n-  const unsigned char *ctf_buf;\t  /* Uncompressed CTF data buffer.  */\n+  unsigned char *ctf_base;\t  /* CTF file pointer.  */\n+  unsigned char *ctf_dynbase;\t  /* Freeable CTF file pointer. */\n+  unsigned char *ctf_buf;\t  /* Uncompressed CTF data buffer.  */\n   size_t ctf_size;\t\t  /* Size of CTF header + uncompressed data.  */\n   uint32_t *ctf_sxlate;\t\t  /* Translation table for symtab entries.  */\n   unsigned long ctf_nsyms;\t  /* Number of entries in symtab xlate table.  */\n@@ -241,6 +243,8 @@ struct ctf_file\n   unsigned long ctf_nvars;\t  /* Number of variables in ctf_vars.  */\n   unsigned long ctf_typemax;\t  /* Maximum valid type ID number.  */\n   const ctf_dmodel_t *ctf_dmodel; /* Data model pointer (see above).  */\n+  const char *ctf_cuname;\t  /* Compilation unit name (if any).  */\n+  char *ctf_dyncuname;\t\t  /* Dynamically allocated name of CU.  */\n   struct ctf_file *ctf_parent;\t  /* Parent CTF container (if any).  */\n   const char *ctf_parlabel;\t  /* Label in parent container (if any).  */\n   const char *ctf_parname;\t  /* Basename of parent (if any).  */"
    },
    {
      "sha": "ec05ce59cd5c0a0988d28ba2983a5b7e248728a1",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 211,
      "deletions": 156,
      "changes": 367,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd55eae84d8b94b497c6043e5aa6e111e7f5a225/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=fd55eae84d8b94b497c6043e5aa6e111e7f5a225",
      "patch": "@@ -309,14 +309,18 @@ init_symtab (ctf_file_t *fp, const ctf_header_t *hp,\n   return 0;\n }\n \n-/* Set the CTF base pointer and derive the buf pointer from it, initializing\n-   everything in the ctf_file that depends on the base or buf pointers.  */\n+/* Reset the CTF base pointer and derive the buf pointer from it, initializing\n+   everything in the ctf_file that depends on the base or buf pointers.\n+\n+   The original gap between the buf and base pointers, if any -- the original,\n+   unconverted CTF header -- is kept, but its contents are not specified and are\n+   never used.  */\n \n static void\n-ctf_set_base (ctf_file_t *fp, const ctf_header_t *hp, void *base)\n+ctf_set_base (ctf_file_t *fp, const ctf_header_t *hp, unsigned char *base)\n {\n+  fp->ctf_buf = base + (fp->ctf_buf - fp->ctf_base);\n   fp->ctf_base = base;\n-  fp->ctf_buf = fp->ctf_base + sizeof (ctf_header_t);\n   fp->ctf_vars = (ctf_varent_t *) ((const char *) fp->ctf_buf +\n \t\t\t\t   hp->cth_varoff);\n   fp->ctf_nvars = (hp->cth_typeoff - hp->cth_varoff) / sizeof (ctf_varent_t);\n@@ -336,60 +340,67 @@ ctf_set_base (ctf_file_t *fp, const ctf_header_t *hp, void *base)\n     fp->ctf_parlabel = ctf_strptr (fp, hp->cth_parlabel);\n   if (hp->cth_parname != 0)\n     fp->ctf_parname = ctf_strptr (fp, hp->cth_parname);\n-\n-  ctf_dprintf (\"ctf_set_base: parent name %s (label %s)\\n\",\n-\t       fp->ctf_parname ? fp->ctf_parname : \"<NULL>\",\n+  if (hp->cth_cuname != 0)\n+    fp->ctf_cuname = ctf_strptr (fp, hp->cth_cuname);\n+\n+  if (fp->ctf_cuname)\n+    ctf_dprintf (\"ctf_set_base: CU name %s\\n\", fp->ctf_cuname);\n+  if (fp->ctf_parname)\n+    ctf_dprintf (\"ctf_set_base: parent name %s (label %s)\\n\",\n+\t       fp->ctf_parname,\n \t       fp->ctf_parlabel ? fp->ctf_parlabel : \"<NULL>\");\n }\n \n-/* Free a ctf_base pointer: the pointer passed, or (if NULL) fp->ctf_base.  */\n-static void\n-ctf_free_base (ctf_file_t *fp, unsigned char *ctf_base)\n-{\n-  unsigned char *base;\n-\n-  if (ctf_base)\n-      base = ctf_base;\n-  else\n-      base = (unsigned char *) fp->ctf_base;\n-\n-  if (base != fp->ctf_data.cts_data && base != NULL)\n-    ctf_free (base);\n-}\n-\n /* Set the version of the CTF file. */\n \n /* When this is reset, LCTF_* changes behaviour, but there is no guarantee that\n    the variable data list associated with each type has been upgraded: the\n    caller must ensure this has been done in advance.  */\n \n static void\n-ctf_set_version (ctf_file_t * fp, ctf_header_t * cth, int ctf_version)\n+ctf_set_version (ctf_file_t *fp, ctf_header_t *cth, int ctf_version)\n {\n   fp->ctf_version = ctf_version;\n   cth->cth_version = ctf_version;\n   fp->ctf_fileops = &ctf_fileops[ctf_version];\n }\n \n-/* Upgrade the type table to CTF_VERSION_3 (really CTF_VERSION_1_UPGRADED_3).\n+\n+/* Upgrade the header to CTF_VERSION_3.  The upgrade is done in-place.  */\n+static void\n+upgrade_header (ctf_header_t *hp)\n+{\n+  ctf_header_v2_t *oldhp = (ctf_header_v2_t *) hp;\n+\n+  hp->cth_strlen = oldhp->cth_strlen;\n+  hp->cth_stroff = oldhp->cth_stroff;\n+  hp->cth_typeoff = oldhp->cth_typeoff;\n+  hp->cth_varoff = oldhp->cth_varoff;\n+  hp->cth_funcoff = oldhp->cth_funcoff;\n+  hp->cth_objtoff = oldhp->cth_objtoff;\n+  hp->cth_lbloff = oldhp->cth_lbloff;\n+  hp->cth_cuname = 0;\t\t\t\t/* No CU name.  */\n+}\n+\n+/* Upgrade the type table to CTF_VERSION_3 (really CTF_VERSION_1_UPGRADED_3)\n+   from CTF_VERSION_1.\n \n    The upgrade is not done in-place: the ctf_base is moved.  ctf_strptr() must\n    not be called before reallocation is complete.\n \n    Type kinds not checked here due to nonexistence in older formats:\n       CTF_K_SLICE.  */\n static int\n-upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n+upgrade_types_v1 (ctf_file_t *fp, ctf_header_t *cth)\n {\n   const ctf_type_v1_t *tbuf;\n   const ctf_type_v1_t *tend;\n-  unsigned char *ctf_base, *old_ctf_base = (unsigned char *) fp->ctf_base;\n+  unsigned char *ctf_base, *old_ctf_base = (unsigned char *) fp->ctf_dynbase;\n   ctf_type_t *t2buf;\n \n   ssize_t increase = 0, size, increment, v2increment, vbytes, v2bytes;\n   const ctf_type_v1_t *tp;\n   ctf_type_t *t2p;\n-  ctf_header_t *new_cth;\n \n   tbuf = (ctf_type_v1_t *) (fp->ctf_buf + cth->cth_typeoff);\n   tend = (ctf_type_v1_t *) (fp->ctf_buf + cth->cth_stroff);\n@@ -425,35 +436,33 @@ upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n       increase += v2bytes - vbytes;\n     }\n \n-  /* Allocate enough room for the new buffer, then copy everything but the\n-     type section into place, and reset the base accordingly.  Leave the\n-     version number unchanged, so that LCTF_INFO_* still works on the\n+  /* Allocate enough room for the new buffer, then copy everything but the type\n+     section into place, and reset the base accordingly.  Leave the version\n+     number unchanged, so that LCTF_INFO_* still works on the\n      as-yet-untranslated type info.  */\n \n   if ((ctf_base = ctf_alloc (fp->ctf_size + increase)) == NULL)\n     return ECTF_ZALLOC;\n \n-  memcpy (ctf_base, fp->ctf_base, sizeof (ctf_header_t) + cth->cth_typeoff);\n-  memcpy (ctf_base + sizeof (ctf_header_t) + cth->cth_stroff + increase,\n-\t  fp->ctf_base + sizeof (ctf_header_t) + cth->cth_stroff,\n-\t  cth->cth_strlen);\n+  /* Start at ctf_buf, not ctf_base, to squeeze out the original header: we\n+     never use it and it is unconverted.  */\n \n-  memset (ctf_base + sizeof (ctf_header_t) + cth->cth_typeoff, 0,\n-\t cth->cth_stroff - cth->cth_typeoff + increase);\n+  memcpy (ctf_base, fp->ctf_buf, cth->cth_typeoff);\n+  memcpy (ctf_base + cth->cth_stroff + increase,\n+\t  fp->ctf_buf + cth->cth_stroff, cth->cth_strlen);\n \n-  /* The cth here is an automatic variable in ctf_bufopen(), and transient\n-     (a copy maintained because at that stage the header read out of the\n-     ctf file may be read-only). We make all modifications in the\n-     canonical copy at ctf_base (by now, writable), then copy it back into\n-     cth at the end.  */\n+  memset (ctf_base + cth->cth_typeoff, 0, cth->cth_stroff - cth->cth_typeoff\n+\t  + increase);\n \n-  new_cth = (ctf_header_t *) ctf_base;\n-  new_cth->cth_stroff += increase;\n+  cth->cth_stroff += increase;\n   fp->ctf_size += increase;\n-  assert (new_cth->cth_stroff >= new_cth->cth_typeoff);\n-  ctf_set_base (fp, new_cth, ctf_base);\n+  assert (cth->cth_stroff >= cth->cth_typeoff);\n+  fp->ctf_base = ctf_base;\n+  fp->ctf_buf = ctf_base;\n+  fp->ctf_dynbase = ctf_base;\n+  ctf_set_base (fp, cth, ctf_base);\n \n-  t2buf = (ctf_type_t *) (fp->ctf_buf + new_cth->cth_typeoff);\n+  t2buf = (ctf_type_t *) (fp->ctf_buf + cth->cth_typeoff);\n \n   /* Iterate through all the types again, upgrading them.\n \n@@ -596,15 +605,38 @@ upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n      converting too much, or too little (leading to a buffer overrun either here\n      or at read time, in init_types().) */\n \n-  assert ((size_t) t2p - (size_t) fp->ctf_buf == new_cth->cth_stroff);\n+  assert ((size_t) t2p - (size_t) fp->ctf_buf == cth->cth_stroff);\n \n-  ctf_set_version (fp, (ctf_header_t *) ctf_base, CTF_VERSION_1_UPGRADED_3);\n-  ctf_free_base (fp, old_ctf_base);\n-  memcpy (cth, new_cth, sizeof (ctf_header_t));\n+  ctf_set_version (fp, cth, CTF_VERSION_1_UPGRADED_3);\n+  ctf_free (old_ctf_base);\n \n   return 0;\n }\n \n+/* Upgrade from any earlier version.  */\n+static int\n+upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n+{\n+  switch (cth->cth_version)\n+    {\n+      /* v1 requires a full pass and reformatting.  */\n+    case CTF_VERSION_1:\n+      upgrade_types_v1 (fp, cth);\n+      /* FALLTHRU */\n+      /* Already-converted v1 is just like later versions except that its\n+\t parent/child boundary is unchanged (and much lower).  */\n+\n+    case CTF_VERSION_1_UPGRADED_3:\n+      fp->ctf_parmax = CTF_MAX_PTYPE_V1;\n+\n+      /* v2 is just the same as v3 except for new types and sections:\n+\t no upgrading required. */\n+    case CTF_VERSION_2: ;\n+      /* FALLTHRU */\n+    }\n+  return 0;\n+}\n+\n /* Initialize the type ID translation table with the byte offset of each type,\n    and initialize the hash tables of each named type.  Upgrade the type table to\n    the latest supported representation in the process, if needed, and if this\n@@ -932,6 +964,7 @@ flip_header (ctf_header_t *cth)\n   swap_thing (cth->cth_preamble.ctp_flags);\n   swap_thing (cth->cth_parlabel);\n   swap_thing (cth->cth_parname);\n+  swap_thing (cth->cth_cuname);\n   swap_thing (cth->cth_objtoff);\n   swap_thing (cth->cth_funcoff);\n   swap_thing (cth->cth_varoff);\n@@ -1131,23 +1164,21 @@ flip_types (void *start, size_t len)\n   return 0;\n }\n \n-/* Flip the endianness of BASE, given the offsets in the (already endian-\n+/* Flip the endianness of BUF, given the offsets in the (already endian-\n    converted) CTH.\n \n    All of this stuff happens before the header is fully initialized, so the\n    LCTF_*() macros cannot be used yet.  Since we do not try to endian-convert v1\n    data, this is no real loss.  */\n \n static int\n-flip_ctf (ctf_header_t *cth, unsigned char *base)\n+flip_ctf (ctf_header_t *cth, unsigned char *buf)\n {\n-  base += sizeof (ctf_header_t);\n-\n-  flip_lbls (base + cth->cth_lbloff, cth->cth_objtoff - cth->cth_lbloff);\n-  flip_objts (base + cth->cth_objtoff, cth->cth_funcoff - cth->cth_objtoff);\n-  flip_objts (base + cth->cth_funcoff, cth->cth_varoff - cth->cth_funcoff);\n-  flip_vars (base + cth->cth_varoff, cth->cth_typeoff - cth->cth_varoff);\n-  return flip_types (base + cth->cth_typeoff, cth->cth_stroff - cth->cth_typeoff);\n+  flip_lbls (buf + cth->cth_lbloff, cth->cth_objtoff - cth->cth_lbloff);\n+  flip_objts (buf + cth->cth_objtoff, cth->cth_funcoff - cth->cth_objtoff);\n+  flip_objts (buf + cth->cth_funcoff, cth->cth_varoff - cth->cth_funcoff);\n+  flip_vars (buf + cth->cth_varoff, cth->cth_typeoff - cth->cth_varoff);\n+  return flip_types (buf + cth->cth_typeoff, cth->cth_stroff - cth->cth_typeoff);\n }\n \n /* Open a CTF file, mocking up a suitable ctf_sect.  */\n@@ -1205,10 +1236,9 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t     const ctf_sect_t *strsect, int *errp)\n {\n   const ctf_preamble_t *pp;\n-  ctf_header_t hp;\n+  size_t hdrsz = sizeof (ctf_header_t);\n+  ctf_header_t *hp;\n   ctf_file_t *fp;\n-  void *base;\n-  size_t size, hdrsz;\n   int foreign_endian = 0;\n   int err;\n \n@@ -1270,36 +1300,55 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n       return (ctf_set_open_errno (errp, ECTF_NOTSUP));\n     }\n \n-  if (ctfsect->cts_size < sizeof (ctf_header_t))\n+  if (pp->ctp_version < CTF_VERSION_3)\n+    hdrsz = sizeof (ctf_header_v2_t);\n+\n+  if (ctfsect->cts_size < hdrsz)\n     return (ctf_set_open_errno (errp, ECTF_NOCTFBUF));\n \n-  memcpy (&hp, ctfsect->cts_data, sizeof (hp));\n+  if ((fp = ctf_alloc (sizeof (ctf_file_t))) == NULL)\n+    return (ctf_set_open_errno (errp, ENOMEM));\n+\n+  memset (fp, 0, sizeof (ctf_file_t));\n+\n+  if ((fp->ctf_header = ctf_alloc (sizeof (struct ctf_header))) == NULL)\n+    {\n+      ctf_free (fp);\n+      return (ctf_set_open_errno (errp, ENOMEM));\n+    }\n+  hp = fp->ctf_header;\n+  memcpy (hp, ctfsect->cts_data, hdrsz);\n+  if (pp->ctp_version < CTF_VERSION_3)\n+    upgrade_header (hp);\n \n   if (foreign_endian)\n-    flip_header (&hp);\n+    flip_header (hp);\n \n   ctf_dprintf (\"header offsets: %x/%x/%x/%x/%x/%x/%x\\n\",\n-\t       hp.cth_lbloff, hp.cth_objtoff, hp.cth_funcoff, hp.cth_varoff,\n-\t       hp.cth_typeoff, hp.cth_stroff, hp.cth_strlen);\n-  hdrsz = sizeof (ctf_header_t);\n+\t       hp->cth_lbloff, hp->cth_objtoff, hp->cth_funcoff,\n+\t       hp->cth_varoff, hp->cth_typeoff, hp->cth_stroff,\n+\t       hp->cth_strlen);\n \n-  size = hp.cth_stroff + hp.cth_strlen;\n+  fp->ctf_size = hp->cth_stroff + hp->cth_strlen;\n \n-  ctf_dprintf (\"ctf_bufopen: uncompressed size=%lu\\n\", (unsigned long) size);\n+  ctf_dprintf (\"ctf_bufopen: uncompressed size=%lu\\n\",\n+\t       (unsigned long) fp->ctf_size);\n \n-  if (hp.cth_lbloff > size || hp.cth_objtoff > size\n-      || hp.cth_funcoff > size || hp.cth_typeoff > size || hp.cth_stroff > size)\n+  if (hp->cth_lbloff > fp->ctf_size || hp->cth_objtoff > fp->ctf_size\n+      || hp->cth_funcoff > fp->ctf_size || hp->cth_typeoff > fp->ctf_size\n+      || hp->cth_stroff > fp->ctf_size)\n     return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n \n-  if (hp.cth_lbloff > hp.cth_objtoff\n-      || hp.cth_objtoff > hp.cth_funcoff\n-      || hp.cth_funcoff > hp.cth_typeoff\n-      || hp.cth_funcoff > hp.cth_varoff\n-      || hp.cth_varoff > hp.cth_typeoff || hp.cth_typeoff > hp.cth_stroff)\n+  if (hp->cth_lbloff > hp->cth_objtoff\n+      || hp->cth_objtoff > hp->cth_funcoff\n+      || hp->cth_funcoff > hp->cth_typeoff\n+      || hp->cth_funcoff > hp->cth_varoff\n+      || hp->cth_varoff > hp->cth_typeoff || hp->cth_typeoff > hp->cth_stroff)\n     return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n \n-  if ((hp.cth_lbloff & 3) || (hp.cth_objtoff & 1)\n-      || (hp.cth_funcoff & 1) || (hp.cth_varoff & 3) || (hp.cth_typeoff & 3))\n+  if ((hp->cth_lbloff & 3) || (hp->cth_objtoff & 2)\n+      || (hp->cth_funcoff & 2) || (hp->cth_varoff & 3)\n+      || (hp->cth_typeoff & 3))\n     return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n \n   /* Once everything is determined to be valid, attempt to decompress the CTF\n@@ -1310,76 +1359,78 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n   /* Note: if this is a v1 buffer, it will be reallocated and expanded by\n      init_types().  */\n \n-  if (hp.cth_flags & CTF_F_COMPRESS)\n+  if (hp->cth_flags & CTF_F_COMPRESS)\n     {\n       size_t srclen;\n       uLongf dstlen;\n       const void *src;\n       int rc = Z_OK;\n-      void *buf;\n \n-      if ((base = ctf_alloc (size + hdrsz)) == NULL)\n-\treturn (ctf_set_open_errno (errp, ECTF_ZALLOC));\n+      /* We are allocating this ourselves, so we can drop the ctf header\n+\t copy in favour of ctf->ctf_header.  */\n \n-      memcpy (base, ctfsect->cts_data, hdrsz);\n-      ((ctf_preamble_t *) base)->ctp_flags &= ~CTF_F_COMPRESS;\n-      buf = (unsigned char *) base + hdrsz;\n+      if ((fp->ctf_base = ctf_alloc (fp->ctf_size)) == NULL)\n+\t{\n+\t  err = ECTF_ZALLOC;\n+\t  goto bad;\n+\t}\n+      fp->ctf_dynbase = fp->ctf_base;\n+      hp->cth_flags &= ~CTF_F_COMPRESS;\n \n       src = (unsigned char *) ctfsect->cts_data + hdrsz;\n       srclen = ctfsect->cts_size - hdrsz;\n-      dstlen = size;\n+      dstlen = fp->ctf_size;\n+      fp->ctf_buf = fp->ctf_base;\n \n-      if ((rc = uncompress (buf, &dstlen, src, srclen)) != Z_OK)\n+      if ((rc = uncompress (fp->ctf_base, &dstlen, src, srclen)) != Z_OK)\n \t{\n \t  ctf_dprintf (\"zlib inflate err: %s\\n\", zError (rc));\n-\t  free (base);\n-\t  return (ctf_set_open_errno (errp, ECTF_DECOMPRESS));\n+\t  err = ECTF_DECOMPRESS;\n+\t  goto bad;\n \t}\n \n-      if ((size_t) dstlen != size)\n+      if ((size_t) dstlen != fp->ctf_size)\n \t{\n \t  ctf_dprintf (\"zlib inflate short -- got %lu of %lu \"\n-\t\t       \"bytes\\n\", (unsigned long) dstlen, (unsigned long) size);\n-\t  free (base);\n-\t  return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+\t\t       \"bytes\\n\", (unsigned long) dstlen,\n+\t\t       (unsigned long) fp->ctf_size);\n+\t  err = ECTF_CORRUPT;\n+\t  goto bad;\n \t}\n-\n     }\n   else if (foreign_endian)\n     {\n-      if ((base = ctf_alloc (size + hdrsz)) == NULL)\n-\treturn (ctf_set_open_errno (errp, ECTF_ZALLOC));\n-      memcpy (base, ctfsect->cts_data, size + hdrsz);\n+      if ((fp->ctf_base = ctf_alloc (fp->ctf_size)) == NULL)\n+\t{\n+\t  err = ECTF_ZALLOC;\n+\t  goto bad;\n+\t}\n+      fp->ctf_dynbase = fp->ctf_base;\n+      memcpy (fp->ctf_base, ((unsigned char *) ctfsect->cts_data) + hdrsz,\n+\t      fp->ctf_size);\n+      fp->ctf_buf = fp->ctf_base;\n     }\n   else\n-    base = (void *) ctfsect->cts_data;\n-\n-  /* Flip the endianness of the copy of the header in the section, to avoid\n-     ending up with a partially-endian-flipped file.  */\n-\n-  if (foreign_endian)\n-    flip_header ((ctf_header_t *) base);\n+    {\n+      /* We are just using the section passed in -- but its header may be an old\n+\t version.  Point ctf_buf past the old header, and never touch it\n+\t again.  */\n+      fp->ctf_base = (unsigned char *) ctfsect->cts_data;\n+      fp->ctf_dynbase = NULL;\n+      fp->ctf_buf = fp->ctf_base + hdrsz;\n+    }\n \n   /* Once we have uncompressed and validated the CTF data buffer, we can\n-     proceed with allocating a ctf_file_t and initializing it.\n+     proceed with initializing the ctf_file_t we allocated above.\n \n      Nothing that depends on buf or base should be set directly in this function\n      before the init_types() call, because it may be reallocated during\n      transparent upgrade if this recension of libctf is so configured: see\n-     ctf_set_base() and ctf_realloc_base().  */\n+     ctf_set_base().  */\n \n-  if ((fp = ctf_alloc (sizeof (ctf_file_t))) == NULL)\n-    return (ctf_set_open_errno (errp, ENOMEM));\n-\n-  memset (fp, 0, sizeof (ctf_file_t));\n-  ctf_set_version (fp, &hp, hp.cth_version);\n+  ctf_set_version (fp, hp, hp->cth_version);\n   ctf_str_create_atoms (fp);\n-\n-  if (_libctf_unlikely_ (hp.cth_version < CTF_VERSION_2))\n-    fp->ctf_parmax = CTF_MAX_PTYPE_V1;\n-  else\n-    fp->ctf_parmax = CTF_MAX_PTYPE;\n-\n+  fp->ctf_parmax = CTF_MAX_PTYPE;\n   memcpy (&fp->ctf_data, ctfsect, sizeof (ctf_sect_t));\n \n   if (symsect != NULL)\n@@ -1409,28 +1460,25 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n     }\n \n   if (foreign_endian &&\n-      (err = flip_ctf (&hp, base)) != 0)\n+      (err = flip_ctf (hp, fp->ctf_buf)) != 0)\n     {\n       /* We can be certain that flip_ctf() will have endian-flipped everything\n          other than the types table when we return.  In particular the header\n          is fine, so set it, to allow freeing to use the usual code path.  */\n \n-      (void) ctf_set_open_errno (errp, err);\n-      ctf_set_base (fp, &hp, base);\n+      ctf_set_base (fp, hp, fp->ctf_base);\n       goto bad;\n     }\n \n-  ctf_set_base (fp, &hp, base);\n-  fp->ctf_size = size + hdrsz;\n+  ctf_set_base (fp, hp, fp->ctf_base);\n \n-  if ((err = init_types (fp, &hp)) != 0)\n-    {\n-      (void) ctf_set_open_errno (errp, err);\n-      goto bad;\n-    }\n+  if ((err = init_types (fp, hp)) != 0)\n+    goto bad;\n \n   /* If we have a symbol table section, allocate and initialize\n-     the symtab translation table, pointed to by ctf_sxlate.  */\n+     the symtab translation table, pointed to by ctf_sxlate.  This table may be\n+     too large for the actual size of the object and function info sections: if\n+     so, ctf_nsyms will be adjusted and the excess will never be used.  */\n \n   if (symsect != NULL)\n     {\n@@ -1439,15 +1487,12 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n       if (fp->ctf_sxlate == NULL)\n \t{\n-\t  (void) ctf_set_open_errno (errp, ENOMEM);\n+\t  err = ENOMEM;\n \t  goto bad;\n \t}\n \n-      if ((err = init_symtab (fp, &hp, symsect, strsect)) != 0)\n-\t{\n-\t  (void) ctf_set_open_errno (errp, err);\n-\t  goto bad;\n-\t}\n+      if ((err = init_symtab (fp, hp, symsect, strsect)) != 0)\n+\tgoto bad;\n     }\n \n   /* Initialize the ctf_lookup_by_name top-level dictionary.  We keep an\n@@ -1483,6 +1528,7 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n   return fp;\n \n bad:\n+  ctf_set_open_errno (errp, err);\n   ctf_file_close (fp);\n   return NULL;\n }\n@@ -1509,11 +1555,9 @@ ctf_file_close (ctf_file_t *fp)\n       return;\n     }\n \n-  if (fp->ctf_dynparname != NULL)\n-    ctf_free (fp->ctf_dynparname);\n-\n-  if (fp->ctf_parent != NULL)\n-    ctf_file_close (fp->ctf_parent);\n+  ctf_free (fp->ctf_dyncuname);\n+  ctf_free (fp->ctf_dynparname);\n+  ctf_file_close (fp->ctf_parent);\n \n   for (dtd = ctf_list_next (&fp->ctf_dtdefs); dtd != NULL; dtd = ntd)\n     {\n@@ -1530,40 +1574,32 @@ ctf_file_close (ctf_file_t *fp)\n     }\n   ctf_dynhash_destroy (fp->ctf_dvhash);\n   ctf_str_free_atoms (fp);\n-\n   ctf_free (fp->ctf_tmp_typeslice);\n \n-  if (fp->ctf_data.cts_name != _CTF_NULLSTR &&\n-      fp->ctf_data.cts_name != NULL)\n+  if (fp->ctf_data.cts_name != _CTF_NULLSTR)\n     ctf_free ((char *) fp->ctf_data.cts_name);\n \n-  if (fp->ctf_symtab.cts_name != _CTF_NULLSTR &&\n-      fp->ctf_symtab.cts_name != NULL)\n+  if (fp->ctf_symtab.cts_name != _CTF_NULLSTR)\n     ctf_free ((char *) fp->ctf_symtab.cts_name);\n \n-  if (fp->ctf_strtab.cts_name != _CTF_NULLSTR &&\n-      fp->ctf_strtab.cts_name != NULL)\n+  if (fp->ctf_strtab.cts_name != _CTF_NULLSTR)\n     ctf_free ((char *) fp->ctf_strtab.cts_name);\n \n   else if (fp->ctf_data_mmapped)\n     ctf_munmap (fp->ctf_data_mmapped, fp->ctf_data_mmapped_len);\n \n-  ctf_free_base (fp, NULL);\n-\n-  if (fp->ctf_sxlate != NULL)\n-    ctf_free (fp->ctf_sxlate);\n-\n-  if (fp->ctf_txlate != NULL)\n-    ctf_free (fp->ctf_txlate);\n+  ctf_free (fp->ctf_dynbase);\n \n-  if (fp->ctf_ptrtab != NULL)\n-    ctf_free (fp->ctf_ptrtab);\n+  ctf_free (fp->ctf_sxlate);\n+  ctf_free (fp->ctf_txlate);\n+  ctf_free (fp->ctf_ptrtab);\n \n   ctf_hash_destroy (fp->ctf_structs);\n   ctf_hash_destroy (fp->ctf_unions);\n   ctf_hash_destroy (fp->ctf_enums);\n   ctf_hash_destroy (fp->ctf_names);\n \n+  ctf_free (fp->ctf_header);\n   ctf_free (fp);\n }\n \n@@ -1621,6 +1657,25 @@ ctf_parent_name_set (ctf_file_t *fp, const char *name)\n   fp->ctf_parname = fp->ctf_dynparname;\n }\n \n+/* Return the name of the compilation unit this CTF file applies to.  Usually\n+   non-NULL only for non-parent containers.  */\n+const char *\n+ctf_cuname (ctf_file_t *fp)\n+{\n+  return fp->ctf_cuname;\n+}\n+\n+/* Set the compilation unit name.  */\n+void\n+ctf_cuname_set (ctf_file_t *fp, const char *name)\n+{\n+  if (fp->ctf_dyncuname != NULL)\n+    ctf_free (fp->ctf_dyncuname);\n+\n+  fp->ctf_dyncuname = ctf_strdup (name);\n+  fp->ctf_cuname = fp->ctf_dyncuname;\n+}\n+\n /* Import the types from the specified parent container by storing a pointer\n    to it in ctf_parent and incrementing its reference count.  Only one parent\n    is allowed: if a parent already exists, it is replaced by the new parent.  */"
    }
  ]
}