{
  "sha": "4d4eaa30055138112bd17ed6933f2da39760d9e6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGQ0ZWFhMzAwNTUxMzgxMTJiZDE3ZWQ2OTMzZjJkYTM5NzYwZDllNg==",
  "commit": {
    "author": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-11-28T02:52:35Z"
    },
    "committer": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-12-27T04:41:35Z"
    },
    "message": "Make symbol_set_names a member function\n\nThis also renames it to make it clearer that this is not a cheap\nfunction (to compute_and_set_names).  Also renames name to m_name\nto make the implementation of the renamed function more readable.\n\nMost of the places that access sym->m_name directly were also changed\nto call linkage_name () instead, to make it clearer which name they\nare accessing.\n\ngdb/ChangeLog:\n\n2019-12-26  Christian Biesinger  <cbiesinger@google.com>\n\n\t* ada-lang.c (ada_decode_symbol): Update.\n\t* buildsym.c (add_symbol_to_list): Update.\n\t* coffread.c (process_coff_symbol): Update.\n\t* ctfread.c (ctf_add_enum_member_cb): Update.\n\t(new_symbol): Update.\n\t(ctf_add_var_cb): Update.\n\t* dwarf2read.c (fixup_go_packaging): Update.\n\t(dwarf2_compute_name): Update.\n\t(new_symbol): Update.\n\t* jit.c (finalize_symtab): Update.\n\t* language.c (language_alloc_type_symbol): Update.\n\t* mdebugread.c (new_symbol): Update.\n\t* minsyms.c (minimal_symbol_reader::record_full): Update.\n\t(minimal_symbol_reader::install): Update.\n\t* psymtab.c (print_partial_symbols): Update.\n\t(psymbol_hash): Update.\n\t(psymbol_compare): Update.\n\t(add_psymbol_to_bcache): Update.\n\t(maintenance_check_psymtabs): Update.\n\t* stabsread.c (define_symbol): Update.\n\t* symtab.c (symbol_set_names): Rename to...\n\t(general_symbol_info::compute_and_set_names): ...this.\n\t(general_symbol_info::natural_name): Update.\n\t(general_symbol_info::search_name): Update.\n\t(fixup_section): Update.\n\t* symtab.h (struct general_symbol_info) <name>: Rename to...\n\t<m_name>: ...this.\n\t<compute_and_set_names>: Rename from...\n\t(symbol_set_names): ...this.\n\t(SYMBOL_SET_NAMES): Remove.\n\t(struct symbol) <ctor>: Update.\n\nChange-Id: I8da1f10cab4e0b89f19d5750fa4e6e2ac8d2b24f",
    "tree": {
      "sha": "5908e91dd79fe15f590a918b344a195c1c21b3d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5908e91dd79fe15f590a918b344a195c1c21b3d6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4d4eaa30055138112bd17ed6933f2da39760d9e6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d4eaa30055138112bd17ed6933f2da39760d9e6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4d4eaa30055138112bd17ed6933f2da39760d9e6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d4eaa30055138112bd17ed6933f2da39760d9e6/comments",
  "author": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b0d674e2b47b9143b7f78111e2d5dd9f462272d9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b0d674e2b47b9143b7f78111e2d5dd9f462272d9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b0d674e2b47b9143b7f78111e2d5dd9f462272d9"
    }
  ],
  "stats": {
    "total": 187,
    "additions": 106,
    "deletions": 81
  },
  "files": [
    {
      "sha": "8600e2ee19ecbc0de118bd75e987316dfaae6fc1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -1,3 +1,37 @@\n+2019-12-26  Christian Biesinger  <cbiesinger@google.com>\n+\n+\t* ada-lang.c (ada_decode_symbol): Update.\n+\t* buildsym.c (add_symbol_to_list): Update.\n+\t* coffread.c (process_coff_symbol): Update.\n+\t* ctfread.c (ctf_add_enum_member_cb): Update.\n+\t(new_symbol): Update.\n+\t(ctf_add_var_cb): Update.\n+\t* dwarf2read.c (fixup_go_packaging): Update.\n+\t(dwarf2_compute_name): Update.\n+\t(new_symbol): Update.\n+\t* jit.c (finalize_symtab): Update.\n+\t* language.c (language_alloc_type_symbol): Update.\n+\t* mdebugread.c (new_symbol): Update.\n+\t* minsyms.c (minimal_symbol_reader::record_full): Update.\n+\t(minimal_symbol_reader::install): Update.\n+\t* psymtab.c (print_partial_symbols): Update.\n+\t(psymbol_hash): Update.\n+\t(psymbol_compare): Update.\n+\t(add_psymbol_to_bcache): Update.\n+\t(maintenance_check_psymtabs): Update.\n+\t* stabsread.c (define_symbol): Update.\n+\t* symtab.c (symbol_set_names): Rename to...\n+\t(general_symbol_info::compute_and_set_names): ...this.\n+\t(general_symbol_info::natural_name): Update.\n+\t(general_symbol_info::search_name): Update.\n+\t(fixup_section): Update.\n+\t* symtab.h (struct general_symbol_info) <name>: Rename to...\n+\t<m_name>: ...this.\n+\t<compute_and_set_names>: Rename from...\n+\t(symbol_set_names): ...this.\n+\t(SYMBOL_SET_NAMES): Remove.\n+\t(struct symbol) <ctor>: Update.\n+\n 2019-12-26  Christian Biesinger  <cbiesinger@google.com>\n \n \t* NEWS: Mention that multithreaded symbol loading is now on by"
    },
    {
      "sha": "b7988890fb78dcfb926eddcf1f88b05eee169099",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -1376,7 +1376,7 @@ ada_decode_symbol (const struct general_symbol_info *arg)\n \n   if (!gsymbol->ada_mangled)\n     {\n-      std::string decoded = ada_decode (gsymbol->name);\n+      std::string decoded = ada_decode (gsymbol->linkage_name ());\n       struct obstack *obstack = gsymbol->language_specific.obstack;\n \n       gsymbol->ada_mangled = 1;"
    },
    {
      "sha": "df74508081794dc67d0491d47e7dfa96fc87da5e",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -135,7 +135,7 @@ add_symbol_to_list (struct symbol *symbol, struct pending **listhead)\n   struct pending *link;\n \n   /* If this is an alias for another symbol, don't add it.  */\n-  if (symbol->name && symbol->name[0] == '#')\n+  if (symbol->linkage_name () && symbol->linkage_name ()[0] == '#')\n     return;\n \n   /* We keep PENDINGSIZE symbols in each link of the list.  If we"
    },
    {
      "sha": "3e5ade80a4985156e03a2bf74b3f3cb74c8c7d38",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -1568,7 +1568,7 @@ process_coff_symbol (struct coff_symbol *cs,\n   name = EXTERNAL_NAME (name, objfile->obfd);\n   sym->set_language (get_current_subfile ()->language,\n \t\t     &objfile->objfile_obstack);\n-  SYMBOL_SET_NAMES (sym, name, true, objfile);\n+  sym->compute_and_set_names (name, true, objfile->per_bfd);\n \n   /* default assumptions */\n   SYMBOL_VALUE (sym) = cs->c_value;"
    },
    {
      "sha": "001120d9f14b0aed2648b5edb32d2d4769352892",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -399,7 +399,7 @@ ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n       OBJSTAT (ccp->of, n_syms++);\n \n       sym->set_language (language_c, &ccp->of->objfile_obstack);\n-      SYMBOL_SET_NAMES (sym, name, false, ccp->of);\n+      sym->compute_and_set_names (name, false, ccp->of->per_bfd);\n       SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SYMBOL_TYPE (sym) = fip->ptype;\n@@ -428,7 +428,7 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n       OBJSTAT (objfile, n_syms++);\n \n       sym->set_language (language_c, &objfile->objfile_obstack);\n-      SYMBOL_SET_NAMES (sym, name.get (), true, objfile);\n+      sym->compute_and_set_names (name.get (), true, objfile->per_bfd);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n \n@@ -1048,7 +1048,7 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n \tif (type)\n \t  {\n \t    sym = new_symbol (ccp, type, id);\n-\t    SYMBOL_SET_NAMES (sym, name, false, ccp->of);\n+\t    sym->compute_and_set_names (name, false, ccp->of->per_bfd);\n \t  }\n \tbreak;\n       case CTF_K_STRUCT:\n@@ -1064,7 +1064,7 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n \tSYMBOL_TYPE (sym) = type;\n \tSYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \tSYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n-\tSYMBOL_SET_NAMES (sym, name, false, ccp->of);\n+\tsym->compute_and_set_names (name, false, ccp->of->per_bfd);\n \tadd_symbol_to_list (sym, ccp->builder->get_global_symbols ());\n \tbreak;\n       default:"
    },
    {
      "sha": "819d37c9b8e6d3a0775791c278f63ee718e01ff4",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -9953,7 +9953,7 @@ fixup_go_packaging (struct dwarf2_cu *cu)\n \n       sym = allocate_symbol (objfile);\n       sym->set_language (language_go, &objfile->objfile_obstack);\n-      SYMBOL_SET_NAMES (sym, saved_package_name, false, objfile);\n+      sym->compute_and_set_names (saved_package_name, false, objfile->per_bfd);\n       /* This is not VAR_DOMAIN because we want a way to ensure a lookup of,\n \t e.g., \"main\" finds the \"main\" module and not C's main().  */\n       SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n@@ -10878,7 +10878,7 @@ dwarf2_compute_name (const char *name,\n   /* For Fortran GDB prefers DW_AT_*linkage_name for the physname if present\n      but otherwise compute it by typename_concat inside GDB.\n      FIXME: Actually this is not really true, or at least not always true.\n-     It's all very confusing.  SYMBOL_SET_NAMES doesn't try to demangle\n+     It's all very confusing.  compute_and_set_names doesn't try to demangle\n      Fortran names because there is no mangling standard.  So new_symbol\n      will set the demangled name to the result of dwarf2_full_name, and it is\n      the demangled name that GDB uses if it exists.  */\n@@ -21873,7 +21873,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n       /* Cache this symbol's name and the name's demangled form (if any).  */\n       sym->set_language (cu->language, &objfile->objfile_obstack);\n       linkagename = dwarf2_physname (name, die, cu);\n-      SYMBOL_SET_NAMES (sym, linkagename, false, objfile);\n+      sym->compute_and_set_names (linkagename, false, objfile->per_bfd);\n \n       /* Fortran does not have mangling standard and the mangling does differ\n \t between gfortran, iFort etc.  */"
    },
    {
      "sha": "2cfea4561b312b8277a0537c3e6d763333d2dbaa",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -672,8 +672,8 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n       SYMBOL_TYPE (block_name) = lookup_function_type (block_type);\n       SYMBOL_BLOCK_VALUE (block_name) = new_block;\n \n-      block_name->name = obstack_strdup (&objfile->objfile_obstack,\n-\t\t\t\t\t gdb_block_iter.name.get ());\n+      block_name->m_name = obstack_strdup (&objfile->objfile_obstack,\n+\t\t\t\t\t   gdb_block_iter.name.get ());\n \n       BLOCK_FUNCTION (new_block) = block_name;\n "
    },
    {
      "sha": "bf990da8a9753fac3420f6c0b0eb0ed12d8a46d7",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -1052,7 +1052,7 @@ language_alloc_type_symbol (enum language lang, struct type *type)\n   gdbarch = TYPE_OWNER (type).gdbarch;\n   symbol = new (gdbarch_obstack (gdbarch)) struct symbol ();\n \n-  symbol->name = TYPE_NAME (type);\n+  symbol->m_name = TYPE_NAME (type);\n   symbol->set_language (lang, nullptr);\n   symbol->owner.arch = gdbarch;\n   SYMBOL_OBJFILE_OWNED (symbol) = 0;"
    },
    {
      "sha": "314b6bd0ecd23a16216d9d4ffa939626429b6c65",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -4762,7 +4762,7 @@ new_symbol (const char *name)\n   struct symbol *s = allocate_symbol (mdebugread_objfile);\n \n   s->set_language (psymtab_language, &mdebugread_objfile->objfile_obstack);\n-  SYMBOL_SET_NAMES (s, name, true, mdebugread_objfile);\n+  s->compute_and_set_names (name, true, mdebugread_objfile->per_bfd);\n   return s;\n }\n "
    },
    {
      "sha": "88606ce11a43d6cf11c7fb683753be15f4ad398f",
      "filename": "gdb/minsyms.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/minsyms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/minsyms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minsyms.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -1132,10 +1132,10 @@ minimal_symbol_reader::record_full (gdb::string_view name,\n \t\t\t &m_objfile->per_bfd->storage_obstack);\n \n   if (copy_name)\n-    msymbol->name = obstack_strndup (&m_objfile->per_bfd->storage_obstack,\n-\t\t\t\t     name.data (), name.size ());\n+    msymbol->m_name = obstack_strndup (&m_objfile->per_bfd->storage_obstack,\n+\t\t\t\t       name.data (), name.size ());\n   else\n-    msymbol->name = name.data ();\n+    msymbol->m_name = name.data ();\n \n   SET_MSYMBOL_VALUE_ADDRESS (msymbol, address);\n   MSYMBOL_SECTION (msymbol) = section;\n@@ -1397,22 +1397,23 @@ minimal_symbol_reader::install ()\n \t   for (minimal_symbol *msym = start; msym < end; ++msym)\n \t     {\n \t       size_t idx = msym - msymbols;\n-\t       hash_values[idx].name_length = strlen (msym->name);\n+\t       hash_values[idx].name_length = strlen (msym->linkage_name ());\n \t       if (!msym->name_set)\n \t\t {\n-\t\t   /* This will be freed later, by symbol_set_names.  */\n+\t\t   /* This will be freed later, by compute_and_set_names.  */\n \t\t   char *demangled_name\n-\t\t     = symbol_find_demangled_name (msym, msym->name);\n+\t\t     = symbol_find_demangled_name (msym, msym->linkage_name ());\n \t\t   symbol_set_demangled_name\n \t\t     (msym, demangled_name,\n \t\t      &m_objfile->per_bfd->storage_obstack);\n \t\t   msym->name_set = 1;\n \t\t }\n \t       /* This mangled_name_hash computation has to be outside of\n-\t\t  the name_set check, or symbol_set_names below will\n+\t\t  the name_set check, or compute_and_set_names below will\n \t\t  be called with an invalid hash value.  */\n \t       hash_values[idx].mangled_name_hash\n-\t\t = fast_hash (msym->name, hash_values[idx].name_length);\n+\t\t = fast_hash (msym->linkage_name (),\n+\t\t\t      hash_values[idx].name_length);\n \t       hash_values[idx].minsym_hash\n \t\t = msymbol_hash (msym->linkage_name ());\n \t       /* We only use this hash code if the search name differs\n@@ -1431,10 +1432,9 @@ minimal_symbol_reader::install ()\n \t     for (minimal_symbol *msym = start; msym < end; ++msym)\n \t       {\n \t\t size_t idx = msym - msymbols;\n-\t\t symbol_set_names\n-\t\t   (msym,\n-\t\t    gdb::string_view(msym->name,\n-\t\t\t\t     hash_values[idx].name_length),\n+\t\t msym->compute_and_set_names\n+\t\t   (gdb::string_view (msym->linkage_name (),\n+\t\t\t\t      hash_values[idx].name_length),\n \t\t    false,\n \t\t    m_objfile->per_bfd,\n \t\t    hash_values[idx].mangled_name_hash);"
    },
    {
      "sha": "4c53e73454cdbb463bdc308d58be62aceeac0f95",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -835,7 +835,7 @@ print_partial_symbols (struct gdbarch *gdbarch, struct objfile *objfile,\n   while (count-- > 0)\n     {\n       QUIT;\n-      fprintf_filtered (outfile, \"    `%s'\", (*p)->ginfo.name);\n+      fprintf_filtered (outfile, \"    `%s'\", (*p)->ginfo.linkage_name ());\n       if ((*p)->ginfo.demangled_name () != NULL)\n \t{\n \t  fprintf_filtered (outfile, \"  `%s'\",\n@@ -1534,9 +1534,9 @@ psymbol_hash (const void *addr, int length)\n   h = fast_hash (&lang, sizeof (unsigned int), h);\n   h = fast_hash (&domain, sizeof (unsigned int), h);\n   h = fast_hash (&theclass, sizeof (unsigned int), h);\n-  /* Note that psymbol names are interned via symbol_set_names, so\n+  /* Note that psymbol names are interned via compute_and_set_names, so\n      there's no need to hash the contents of the name here.  */\n-  h = fast_hash (&psymbol->ginfo.name, sizeof (psymbol->ginfo.name), h);\n+  h = fast_hash (&psymbol->ginfo.m_name, sizeof (psymbol->ginfo.m_name), h);\n \n   return h;\n }\n@@ -1557,9 +1557,9 @@ psymbol_compare (const void *addr1, const void *addr2, int length)\n           && sym1->domain == sym2->domain\n           && sym1->aclass == sym2->aclass\n \t  /* Note that psymbol names are interned via\n-\t     symbol_set_names, so there's no need to compare the\n+\t     compute_and_set_names, so there's no need to compare the\n \t     contents of the name here.  */\n-          && sym1->ginfo.name == sym2->ginfo.name);\n+          && sym1->ginfo.linkage_name () == sym2->ginfo.linkage_name ());\n }\n \n /* Helper function, initialises partial symbol structure and stashes\n@@ -1585,8 +1585,7 @@ add_psymbol_to_bcache (gdb::string_view name, bool copy_name,\n   psymbol.domain = domain;\n   psymbol.aclass = theclass;\n   psymbol.ginfo.set_language (language, objfile->partial_symtabs->obstack ());\n-  symbol_set_names (&psymbol.ginfo, name, copy_name,\n-\t\t    objfile->per_bfd);\n+  psymbol.ginfo.compute_and_set_names (name, copy_name, objfile->per_bfd);\n \n   /* Stash the partial symbol away in the cache.  */\n   return ((struct partial_symbol *)\n@@ -2110,7 +2109,7 @@ maintenance_check_psymtabs (const char *ignore, int from_tty)\n \t    if (!sym)\n \t      {\n \t\tprintf_filtered (\"Static symbol `\");\n-\t\tputs_filtered ((*psym)->ginfo.name);\n+\t\tputs_filtered ((*psym)->ginfo.linkage_name ());\n \t\tprintf_filtered (\"' only found in \");\n \t\tputs_filtered (ps->filename);\n \t\tprintf_filtered (\" psymtab\\n\");\n@@ -2128,7 +2127,7 @@ maintenance_check_psymtabs (const char *ignore, int from_tty)\n \t    if (!sym)\n \t      {\n \t\tprintf_filtered (\"Global symbol `\");\n-\t\tputs_filtered ((*psym)->ginfo.name);\n+\t\tputs_filtered ((*psym)->ginfo.linkage_name ());\n \t\tprintf_filtered (\"' only found in \");\n \t\tputs_filtered (ps->filename);\n \t\tprintf_filtered (\" psymtab\\n\");"
    },
    {
      "sha": "0b60402c81efc0accae32520be8aa5d9eb680828",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 3,
      "deletions": 7,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -749,14 +749,10 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  new_name = cp_canonicalize_string (name);\n \t}\n       if (!new_name.empty ())\n-\t{\n-\t  SYMBOL_SET_NAMES (sym,\n-\t\t\t    new_name,\n-\t\t\t    1, objfile);\n-\t}\n+\tsym->compute_and_set_names (new_name, true, objfile->per_bfd);\n       else\n-\tSYMBOL_SET_NAMES (sym, gdb::string_view (string, p - string), true,\n-\t\t\t  objfile);\n+\tsym->compute_and_set_names (gdb::string_view (string, p - string), true,\n+\t\t\t\t    objfile->per_bfd);\n \n       if (sym->language () == language_cplus)\n \tcp_scan_for_anonymous_namespaces (get_buildsym_compunit (), sym,"
    },
    {
      "sha": "099e92070a8a1eee6b93f0442898ce0e13045343",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -855,29 +855,29 @@ symbol_find_demangled_name (struct general_symbol_info *gsymbol,\n    so the pointer can be discarded after calling this function.  */\n \n void\n-symbol_set_names (struct general_symbol_info *gsymbol,\n-\t\t  gdb::string_view linkage_name, bool copy_name,\n-\t\t  struct objfile_per_bfd_storage *per_bfd,\n-\t\t  gdb::optional<hashval_t> hash)\n+general_symbol_info::compute_and_set_names (gdb::string_view linkage_name,\n+\t\t\t\t\t    bool copy_name,\n+\t\t\t\t\t    objfile_per_bfd_storage *per_bfd,\n+\t\t\t\t\t    gdb::optional<hashval_t> hash)\n {\n   struct demangled_name_entry **slot;\n \n-  if (gsymbol->language () == language_ada)\n+  if (language () == language_ada)\n     {\n       /* In Ada, we do the symbol lookups using the mangled name, so\n          we can save some space by not storing the demangled name.  */\n       if (!copy_name)\n-\tgsymbol->name = linkage_name.data ();\n+\tm_name = linkage_name.data ();\n       else\n \t{\n \t  char *name = (char *) obstack_alloc (&per_bfd->storage_obstack,\n \t\t\t\t\t       linkage_name.length () + 1);\n \n \t  memcpy (name, linkage_name.data (), linkage_name.length ());\n \t  name[linkage_name.length ()] = '\\0';\n-\t  gsymbol->name = name;\n+\t  m_name = name;\n \t}\n-      symbol_set_demangled_name (gsymbol, NULL, &per_bfd->storage_obstack);\n+      symbol_set_demangled_name (this, NULL, &per_bfd->storage_obstack);\n \n       return;\n     }\n@@ -896,7 +896,7 @@ symbol_set_names (struct general_symbol_info *gsymbol,\n   if (*slot == NULL\n       /* A C version of the symbol may have already snuck into the table.\n \t This happens to, e.g., main.init (__go_init_main).  Cope.  */\n-      || (gsymbol->language () == language_go && (*slot)->demangled == nullptr))\n+      || (language () == language_go && (*slot)->demangled == nullptr))\n     {\n       /* A 0-terminated copy of the linkage name.  Callers must set COPY_NAME\n          to true if the string might not be nullterminated.  We have to make\n@@ -920,9 +920,9 @@ symbol_set_names (struct general_symbol_info *gsymbol,\n          allocated from the heap and needs to be freed by us, just\n          like if we called symbol_find_demangled_name here.  */\n       gdb::unique_xmalloc_ptr<char> demangled_name\n-\t(gsymbol->language_specific.demangled_name\n-\t ? const_cast<char *> (gsymbol->language_specific.demangled_name)\n-\t : symbol_find_demangled_name (gsymbol, linkage_name_copy.data ()));\n+\t(language_specific.demangled_name\n+\t ? const_cast<char *> (language_specific.demangled_name)\n+\t : symbol_find_demangled_name (this, linkage_name_copy.data ()));\n \n       /* Suppose we have demangled_name==NULL, copy_name==0, and\n \t linkage_name_copy==linkage_name.  In this case, we already have the\n@@ -957,18 +957,17 @@ symbol_set_names (struct general_symbol_info *gsymbol,\n \t    (gdb::string_view (mangled_ptr, linkage_name.length ()));\n \t}\n       (*slot)->demangled = std::move (demangled_name);\n-      (*slot)->language = gsymbol->language ();\n+      (*slot)->language = language ();\n     }\n-  else if (gsymbol->language () == language_unknown\n-\t   || gsymbol->language () == language_auto)\n-    gsymbol->m_language = (*slot)->language;\n+  else if (language () == language_unknown || language () == language_auto)\n+    m_language = (*slot)->language;\n \n-  gsymbol->name = (*slot)->mangled.data ();\n+  m_name = (*slot)->mangled.data ();\n   if ((*slot)->demangled != nullptr)\n-    symbol_set_demangled_name (gsymbol, (*slot)->demangled.get (),\n+    symbol_set_demangled_name (this, (*slot)->demangled.get (),\n \t\t\t       &per_bfd->storage_obstack);\n   else\n-    symbol_set_demangled_name (gsymbol, NULL, &per_bfd->storage_obstack);\n+    symbol_set_demangled_name (this, NULL, &per_bfd->storage_obstack);\n }\n \n /* See symtab.h.  */\n@@ -991,7 +990,7 @@ general_symbol_info::natural_name () const\n     default:\n       break;\n     }\n-  return name;\n+  return linkage_name ();\n }\n \n /* See symtab.h.  */\n@@ -1025,7 +1024,7 @@ const char *\n general_symbol_info::search_name () const\n {\n   if (language () == language_ada)\n-    return name;\n+    return linkage_name ();\n   else\n     return natural_name ();\n }\n@@ -1670,7 +1669,8 @@ fixup_section (struct general_symbol_info *ginfo,\n      e.g. on PowerPC64, where the minimal symbol for a function will\n      point to the function descriptor, while the debug symbol will\n      point to the actual function code.  */\n-  msym = lookup_minimal_symbol_by_pc_name (addr, ginfo->name, objfile);\n+  msym = lookup_minimal_symbol_by_pc_name (addr, ginfo->linkage_name (),\n+\t\t\t\t\t   objfile);\n   if (msym)\n     ginfo->section = MSYMBOL_SECTION (msym);\n   else"
    },
    {
      "sha": "a16829693552b860fe7a4f6ef9abec4fa0c402ab",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 13,
      "deletions": 17,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d4eaa30055138112bd17ed6933f2da39760d9e6/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=4d4eaa30055138112bd17ed6933f2da39760d9e6",
      "patch": "@@ -389,7 +389,7 @@ struct general_symbol_info\n      and linkage_name () are different.  */\n \n   const char *linkage_name () const\n-  { return name; }\n+  { return m_name; }\n \n   /* Return SYMBOL's \"natural\" name, i.e. the name that it was called in\n      the original source code.  In languages like C++ where symbols may\n@@ -419,11 +419,11 @@ struct general_symbol_info\n \n   /* Set just the linkage name of a symbol; do not try to demangle\n      it.  Used for constructs which do not have a mangled name,\n-     e.g. struct tags.  Unlike SYMBOL_SET_NAMES, linkage_name must\n+     e.g. struct tags.  Unlike compute_and_set_names, linkage_name must\n      be terminated and either already on the objfile's obstack or\n      permanently allocated.  */\n   void set_linkage_name (const char *linkage_name)\n-  { name = linkage_name; }\n+  { m_name = linkage_name; }\n \n   enum language language () const\n   { return m_language; }\n@@ -432,13 +432,21 @@ struct general_symbol_info\n      depending upon the language for the symbol.  */\n   void set_language (enum language language, struct obstack *obstack);\n \n+  /* Set the linkage and natural names of a symbol, by demangling\n+     the linkage name.  If linkage_name may not be nullterminated,\n+     copy_name must be set to true.  */\n+  void compute_and_set_names (gdb::string_view linkage_name, bool copy_name,\n+\t\t\t      struct objfile_per_bfd_storage *per_bfd,\n+\t\t\t      gdb::optional<hashval_t> hash\n+\t\t\t        = gdb::optional<hashval_t> ());\n+\n   /* Name of the symbol.  This is a required field.  Storage for the\n      name is allocated on the objfile_obstack for the associated\n      objfile.  For languages like C++ that make a distinction between\n      the mangled name and demangled name, this is the mangled\n      name.  */\n \n-  const char *name;\n+  const char *m_name;\n \n   /* Value of the symbol.  Which member of this union to use, and what\n      it means, depends on what kind of symbol this is and its\n@@ -544,18 +552,6 @@ extern CORE_ADDR get_symbol_address (const struct symbol *sym);\n extern char *symbol_find_demangled_name (struct general_symbol_info *gsymbol,\n \t\t\t\t\t const char *mangled);\n \n-/* Set the linkage and natural names of a symbol, by demangling\n-   the linkage name.  If linkage_name may not be nullterminated,\n-   copy_name must be set to true.  */\n-#define SYMBOL_SET_NAMES(symbol,linkage_name,copy_name,objfile)\t\\\n-  symbol_set_names ((symbol), linkage_name, copy_name, \\\n-\t\t    (objfile)->per_bfd)\n-extern void symbol_set_names (struct general_symbol_info *symbol,\n-\t\t\t      gdb::string_view linkage_name, bool copy_name,\n-\t\t\t      struct objfile_per_bfd_storage *per_bfd,\n-\t\t\t      gdb::optional<hashval_t> hash\n-\t\t\t        = gdb::optional<hashval_t> ());\n-\n /* Return true if NAME matches the \"search\" name of SYMBOL, according\n    to the symbol's language.  */\n #define SYMBOL_MATCHES_SEARCH_NAME(symbol, name)                       \\\n@@ -1092,7 +1088,7 @@ struct symbol : public general_symbol_info, public allocate_on_obstack\n     {\n       /* We can't use an initializer list for members of a base class, and\n          general_symbol_info needs to stay a POD type.  */\n-      name = nullptr;\n+      m_name = nullptr;\n       value.ivalue = 0;\n       language_specific.obstack = nullptr;\n       m_language = language_unknown;"
    }
  ]
}