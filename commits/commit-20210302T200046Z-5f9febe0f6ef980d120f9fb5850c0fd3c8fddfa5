{
  "sha": "5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWY5ZmViZTBmNmVmOTgwZDEyMGY5ZmI1ODUwYzBmZDNjOGZkZGZhNQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-03-02T20:00:45Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-03-02T20:00:46Z"
    },
    "message": "Use std::string rather than grow_vect\n\nThis removes the \"GROW_VECT\" macro and helper function in favor of\nsimply using std::string in a few spots.\n\ngdb/ChangeLog\n2021-03-02  Tom Tromey  <tromey@adacore.com>\n\n\t* ada-lang.c (ada_fold_name, ada_variant_discrim_name)\n\t(ada_enum_name, scan_discrim_bound, to_fixed_range_type): Use\n\tstd::string.\n\t(GROW_VECT): Remove.\n\t(grow_vect): Remove.",
    "tree": {
      "sha": "c44e57f0d47e8e67d8194ecb6e224d8d778adf90",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c44e57f0d47e8e67d8194ecb6e224d8d778adf90"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d1183b064cae59353c3a80d27dc250ca440cb879",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d1183b064cae59353c3a80d27dc250ca440cb879",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d1183b064cae59353c3a80d27dc250ca440cb879"
    }
  ],
  "stats": {
    "total": 110,
    "additions": 34,
    "deletions": 76
  },
  "files": [
    {
      "sha": "05e53caad669fb729c6b72fe6e0f32f319bce542",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5",
      "patch": "@@ -1,3 +1,11 @@\n+2021-03-02  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ada-lang.c (ada_fold_name, ada_variant_discrim_name)\n+\t(ada_enum_name, scan_discrim_bound, to_fixed_range_type): Use\n+\tstd::string.\n+\t(GROW_VECT): Remove.\n+\t(grow_vect): Remove.\n+\n 2021-03-02  Tom Tromey  <tromey@adacore.com>\n \n \t* ada-lang.h (ada_lookup_symbol_list): Return a vector."
    },
    {
      "sha": "44afbd975c013bcd8711c8cc2c69f9fa9cae0742",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 26,
      "deletions": 76,
      "changes": 102,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5",
      "patch": "@@ -475,29 +475,6 @@ add_angle_brackets (const char *str)\n   return string_printf (\"<%s>\", str);\n }\n \n-/* Assuming V points to an array of S objects,  make sure that it contains at\n-   least M objects, updating V and S as necessary.  */\n-\n-#define GROW_VECT(v, s, m)                                    \\\n-   if ((s) < (m)) (v) = (char *) grow_vect (v, &(s), m, sizeof *(v));\n-\n-/* Assuming VECT points to an array of *SIZE objects of size\n-   ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,\n-   updating *SIZE as necessary and returning the (new) array.  */\n-\n-static void *\n-grow_vect (void *vect, size_t *size, size_t min_size, int element_size)\n-{\n-  if (*size < min_size)\n-    {\n-      *size *= 2;\n-      if (*size < min_size)\n-\t*size = min_size;\n-      vect = xrealloc (vect, *size * element_size);\n-    }\n-  return vect;\n-}\n-\n /* True (non-zero) iff TARGET matches FIELD_NAME up to any trailing\n    suffix of FIELD_NAME beginning \"___\".  */\n \n@@ -961,30 +938,21 @@ ada_encode (const char *decoded)\n    quotes, unfolded, but with the quotes stripped away.  Result good\n    to next call.  */\n \n-static char *\n+static const char *\n ada_fold_name (gdb::string_view name)\n {\n-  static char *fold_buffer = NULL;\n-  static size_t fold_buffer_size = 0;\n-\n-  int len = name.size ();\n-  GROW_VECT (fold_buffer, fold_buffer_size, len + 1);\n+  static std::string fold_storage;\n \n   if (!name.empty () && name[0] == '\\'')\n-    {\n-      strncpy (fold_buffer, name.data () + 1, len - 2);\n-      fold_buffer[len - 2] = '\\000';\n-    }\n+    fold_storage = to_string (name.substr (1, name.size () - 2));\n   else\n     {\n-      int i;\n-\n-      for (i = 0; i < len; i += 1)\n-\tfold_buffer[i] = tolower (name[i]);\n-      fold_buffer[i] = '\\0';\n+      fold_storage = to_string (name);\n+      for (int i = 0; i < name.size (); i += 1)\n+\tfold_storage[i] = tolower (fold_storage[i]);\n     }\n \n-  return fold_buffer;\n+  return fold_storage.c_str ();\n }\n \n /* Return nonzero if C is either a digit or a lowercase alphabet character.  */\n@@ -6695,8 +6663,7 @@ ada_is_others_clause (struct type *type, int field_num)\n const char *\n ada_variant_discrim_name (struct type *type0)\n {\n-  static char *result = NULL;\n-  static size_t result_len = 0;\n+  static std::string result;\n   struct type *type;\n   const char *name;\n   const char *discrim_end;\n@@ -6732,10 +6699,8 @@ ada_variant_discrim_name (struct type *type0)\n \tbreak;\n     }\n \n-  GROW_VECT (result, result_len, discrim_end - discrim_start + 1);\n-  strncpy (result, discrim_start, discrim_end - discrim_start);\n-  result[discrim_end - discrim_start] = '\\0';\n-  return result;\n+  result = std::string (discrim_start, discrim_end - discrim_start);\n+  return result.c_str ();\n }\n \n /* Scan STR for a subtype-encoded number, beginning at position K.\n@@ -9048,8 +9013,7 @@ ada_aligned_value_addr (struct type *type, const gdb_byte *valaddr)\n const char *\n ada_enum_name (const char *name)\n {\n-  static char *result;\n-  static size_t result_len = 0;\n+  static std::string storage;\n   const char *tmp;\n \n   /* First, unqualify the enumeration name:\n@@ -9088,22 +9052,20 @@ ada_enum_name (const char *name)\n \t\t|| (name[1] >= 'a' && name[1] <= 'z'))\n \t       && name[2] == '\\0')\n \t{\n-\t  GROW_VECT (result, result_len, 4);\n-\t  xsnprintf (result, result_len, \"'%c'\", name[1]);\n-\t  return result;\n+\t  storage = string_printf (\"'%c'\", name[1]);\n+\t  return storage.c_str ();\n \t}\n       else\n \treturn name;\n \n-      GROW_VECT (result, result_len, 16);\n       if (isascii (v) && isprint (v))\n-\txsnprintf (result, result_len, \"'%c'\", v);\n+\tstorage = string_printf (\"'%c'\", v);\n       else if (name[1] == 'U')\n-\txsnprintf (result, result_len, \"[\\\"%02x\\\"]\", v);\n+\tstorage = string_printf (\"[\\\"%02x\\\"]\", v);\n       else\n-\txsnprintf (result, result_len, \"[\\\"%04x\\\"]\", v);\n+\tstorage = string_printf (\"[\\\"%04x\\\"]\", v);\n \n-      return result;\n+      return storage.c_str ();\n     }\n   else\n     {\n@@ -9112,10 +9074,8 @@ ada_enum_name (const char *name)\n \ttmp = strstr (name, \"$\");\n       if (tmp != NULL)\n \t{\n-\t  GROW_VECT (result, result_len, tmp - name + 1);\n-\t  strncpy (result, name, tmp - name);\n-\t  result[tmp - name] = '\\0';\n-\t  return result;\n+\t  storage = std::string (name, tmp - name);\n+\t  return storage.c_str ();\n \t}\n \n       return name;\n@@ -11204,8 +11164,7 @@ static int\n scan_discrim_bound (const char *str, int k, struct value *dval, LONGEST * px,\n \t\t    int *pnew_k)\n {\n-  static char *bound_buffer = NULL;\n-  static size_t bound_buffer_len = 0;\n+  static std::string storage;\n   const char *pstart, *pend, *bound;\n   struct value *bound_val;\n \n@@ -11224,11 +11183,8 @@ scan_discrim_bound (const char *str, int k, struct value *dval, LONGEST * px,\n       int len = pend - pstart;\n \n       /* Strip __ and beyond.  */\n-      GROW_VECT (bound_buffer, bound_buffer_len, len + 1);\n-      strncpy (bound_buffer, pstart, len);\n-      bound_buffer[len] = '\\0';\n-\n-      bound = bound_buffer;\n+      storage = std::string (pstart, len);\n+      bound = storage.c_str ();\n       k = pend - str;\n     }\n \n@@ -11325,18 +11281,12 @@ to_fixed_range_type (struct type *raw_type, struct value *dval)\n     }\n   else\n     {\n-      static char *name_buf = NULL;\n-      static size_t name_len = 0;\n       int prefix_len = subtype_info - name;\n       LONGEST L, U;\n       struct type *type;\n       const char *bounds_str;\n       int n;\n \n-      GROW_VECT (name_buf, name_len, prefix_len + 5);\n-      strncpy (name_buf, name, prefix_len);\n-      name_buf[prefix_len] = '\\0';\n-\n       subtype_info += 5;\n       bounds_str = strchr (subtype_info, '_');\n       n = 1;\n@@ -11354,8 +11304,8 @@ to_fixed_range_type (struct type *raw_type, struct value *dval)\n \t}\n       else\n \t{\n-\t  strcpy (name_buf + prefix_len, \"___L\");\n-\t  if (!get_int_var_value (name_buf, L))\n+\t  std::string name_buf = std::string (name, prefix_len) + \"___L\";\n+\t  if (!get_int_var_value (name_buf.c_str (), L))\n \t    {\n \t      lim_warning (_(\"Unknown lower bound, using 1.\"));\n \t      L = 1;\n@@ -11370,8 +11320,8 @@ to_fixed_range_type (struct type *raw_type, struct value *dval)\n \t}\n       else\n \t{\n-\t  strcpy (name_buf + prefix_len, \"___U\");\n-\t  if (!get_int_var_value (name_buf, U))\n+\t  std::string name_buf = std::string (name, prefix_len) + \"___U\";\n+\t  if (!get_int_var_value (name_buf.c_str (), U))\n \t    {\n \t      lim_warning (_(\"Unknown upper bound, using %ld.\"), (long) L);\n \t      U = L;"
    }
  ]
}