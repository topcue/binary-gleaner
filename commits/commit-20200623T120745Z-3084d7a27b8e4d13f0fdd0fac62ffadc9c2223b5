{
  "sha": "3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzA4NGQ3YTI3YjhlNGQxM2YwZmRkMGZhYzYyZmZhZGM5YzIyMjNiNQ==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-23T12:07:31Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-23T12:07:45Z"
    },
    "message": "ELF: Add _bfd_elf_add_dynamic_tags\n\nAll ELF backends with shared library support need to add dynamic tags.\nAdd dt_pltgot_required and dt_jmprel_required to elf_link_hash_table to\nindicate that DT_PLTGOT and DT_JMPREL are required dynamic tags.\n\n1. Add _bfd_elf_add_dynamic_tags to add common dynamic tags.\n2. Add _bfd_elf_maybe_vxworks_add_dynamic_tags to add common VxWorks\ndynamic tags.\n\n\t* elf-bfd.h (elf_link_hash_table): Add dt_pltgot_required and\n\tdt_jmprel_required.\n\t(_bfd_elf_add_dynamic_tags): New.\n\t* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Call\n\t_bfd_elf_add_dynamic_tags.\n\t* elf32-arc.c (elf_arc_size_dynamic_sections): Likewise.\n\t* elf32-bfin.c (elf32_bfinfdpic_size_dynamic_sections): Likewise.\n\t* elf32-cr16.c (_bfd_cr16_elf_size_dynamic_sections): Likewise.\n\t* elf32-frv.c (elf32_frvfdpic_size_dynamic_sections): Likewise.\n\t* elf32-lm32.c (lm32_elf_size_dynamic_sections): Likewise.\n\t* elf32-m32r.c (m32r_elf_size_dynamic_sections): Likewise.\n\t* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.\n\t* elf32-microblaze.c (microblaze_elf_size_dynamic_sections):\n\tLikewise.\n\t* elf32-nds32.c (nds32_elf_size_dynamic_sections): Likewise.\n\t* elf32-nios2.c (nios2_elf32_size_dynamic_sections): Likewise.\n\t* elf32-or1k.c (or1k_elf_size_dynamic_sections): Likewise.\n\t* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.\n\t* elf32-tilepro.c (tilepro_elf_size_dynamic_sections): Likewise.\n\t* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.\n\t* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.\n\t* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.\n\t* elfnn-aarch64.c (elfNN_aarch64_size_dynamic_sections):\n\tLikewise.\n\t* elfnn-riscv.c (riscv_elf_size_dynamic_sections): Likewise.\n\t* elfxx-tilegx.c (tilegx_elf_size_dynamic_sections): Likewise.\n\t* elf32-arm.c (elf32_arm_size_dynamic_sections): Call\n\t_bfd_elf_maybe_vxworks_add_dynamic_tags.\n\t* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.\n\t* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections):\n\tLikewise.\n\t* elfxx-x86.c (_bfd_x86_elf_link_hash_table_create): Likewise.\n\t(_bfd_x86_elf_size_dynamic_sections): Likewise.\n\t* elfxx-x86.h (elf_x86_link_hash_table): Remove dt_reloc,\n\tdt_reloc_sz and dt_reloc_ent.\n\t* elf-vxworks.c (_bfd_elf_maybe_vxworks_add_dynamic_tags): New.\n\t* elf-vxworks.h (_bfd_elf_maybe_vxworks_add_dynamic_tags):\n\tLikewise.\n\t* elf32-hppa.c (elf32_hppa_link_hash_table_create): Set\n\tetab.dt_pltgot_required.\n\t(elf32_hppa_size_dynamic_sections): Call\n\t_bfd_elf_add_dynamic_tags.\n\t* elf32-metag.c (elf_metag_link_hash_table_create): Set\n\tetab.dt_pltgot_required.\n\t(elf_metag_size_dynamic_sections): Call _bfd_elf_add_dynamic_tags.\n\t* elf32-sh.c (sh_elf_link_hash_table_create): Set\n\troot.dt_pltgot_required for FDPIC output.\n\t(sh_elf_size_dynamic_sections): Call\n\t_bfd_elf_maybe_vxworks_add_dynamic_tags.\n\t* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Set\n\telf.dt_pltgot_required.\n\t(elf_xtensa_size_dynamic_sections): Call\n\t_bfd_elf_add_dynamic_tags.\n\t* elf64-hppa.c (elf64_hppa_hash_table_create): Set\n\troot.dt_pltgot_required.\n\t(elf64_hppa_size_dynamic_sections): Call\n\t_bfd_elf_add_dynamic_tags.\n\t* elfnn-ia64.c (elfNN_ia64_hash_table_create): Set\n\troot.dt_pltgot_required.\n\t(elfNN_ia64_size_dynamic_sections): Set root.dt_jmprel_required\n\tfor rel_pltoff_sec.  Call _bfd_elf_add_dynamic_tags.\n\t* elflink.c (_bfd_elf_add_dynamic_tags): New.",
    "tree": {
      "sha": "6cf63cdbd80c06d4dfceb2ff02c4ebc3ff155104",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6cf63cdbd80c06d4dfceb2ff02c4ebc3ff155104"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2e573c0a3f9de232587f75de0af765abb8e193b9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e573c0a3f9de232587f75de0af765abb8e193b9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2e573c0a3f9de232587f75de0af765abb8e193b9"
    }
  ],
  "stats": {
    "total": 1666,
    "additions": 257,
    "deletions": 1409
  },
  "files": [
    {
      "sha": "5d1075e743d34cc462bebd7e889806e8492fce06",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 65,
      "deletions": 0,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -1,3 +1,68 @@\n+2020-06-23  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* elf-bfd.h (elf_link_hash_table): Add dt_pltgot_required and\n+\tdt_jmprel_required.\n+\t(_bfd_elf_add_dynamic_tags): New.\n+\t* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Call\n+\t_bfd_elf_add_dynamic_tags.\n+\t* elf32-arc.c (elf_arc_size_dynamic_sections): Likewise.\n+\t* elf32-bfin.c (elf32_bfinfdpic_size_dynamic_sections): Likewise.\n+\t* elf32-cr16.c (_bfd_cr16_elf_size_dynamic_sections): Likewise.\n+\t* elf32-frv.c (elf32_frvfdpic_size_dynamic_sections): Likewise.\n+\t* elf32-lm32.c (lm32_elf_size_dynamic_sections): Likewise.\n+\t* elf32-m32r.c (m32r_elf_size_dynamic_sections): Likewise.\n+\t* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.\n+\t* elf32-microblaze.c (microblaze_elf_size_dynamic_sections):\n+\tLikewise.\n+\t* elf32-nds32.c (nds32_elf_size_dynamic_sections): Likewise.\n+\t* elf32-nios2.c (nios2_elf32_size_dynamic_sections): Likewise.\n+\t* elf32-or1k.c (or1k_elf_size_dynamic_sections): Likewise.\n+\t* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.\n+\t* elf32-tilepro.c (tilepro_elf_size_dynamic_sections): Likewise.\n+\t* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.\n+\t* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.\n+\t* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.\n+\t* elfnn-aarch64.c (elfNN_aarch64_size_dynamic_sections):\n+\tLikewise.\n+\t* elfnn-riscv.c (riscv_elf_size_dynamic_sections): Likewise.\n+\t* elfxx-tilegx.c (tilegx_elf_size_dynamic_sections): Likewise.\n+\t* elf32-arm.c (elf32_arm_size_dynamic_sections): Call\n+\t_bfd_elf_maybe_vxworks_add_dynamic_tags.\n+\t* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.\n+\t* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections):\n+\tLikewise.\n+\t* elfxx-x86.c (_bfd_x86_elf_link_hash_table_create): Likewise.\n+\t(_bfd_x86_elf_size_dynamic_sections): Likewise.\n+\t* elfxx-x86.h (elf_x86_link_hash_table): Remove dt_reloc,\n+\tdt_reloc_sz and dt_reloc_ent.\n+\t* elf-vxworks.c (_bfd_elf_maybe_vxworks_add_dynamic_tags): New.\n+\t* elf-vxworks.h (_bfd_elf_maybe_vxworks_add_dynamic_tags):\n+\tLikewise.\n+\t* elf32-hppa.c (elf32_hppa_link_hash_table_create): Set\n+\tetab.dt_pltgot_required.\n+\t(elf32_hppa_size_dynamic_sections): Call\n+\t_bfd_elf_add_dynamic_tags.\n+\t* elf32-metag.c (elf_metag_link_hash_table_create): Set\n+\tetab.dt_pltgot_required.\n+\t(elf_metag_size_dynamic_sections): Call _bfd_elf_add_dynamic_tags.\n+\t* elf32-sh.c (sh_elf_link_hash_table_create): Set\n+\troot.dt_pltgot_required for FDPIC output.\n+\t(sh_elf_size_dynamic_sections): Call\n+\t_bfd_elf_maybe_vxworks_add_dynamic_tags.\n+\t* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Set\n+\telf.dt_pltgot_required.\n+\t(elf_xtensa_size_dynamic_sections): Call\n+\t_bfd_elf_add_dynamic_tags.\n+\t* elf64-hppa.c (elf64_hppa_hash_table_create): Set\n+\troot.dt_pltgot_required.\n+\t(elf64_hppa_size_dynamic_sections): Call\n+\t_bfd_elf_add_dynamic_tags.\n+\t* elfnn-ia64.c (elfNN_ia64_hash_table_create): Set\n+\troot.dt_pltgot_required.\n+\t(elfNN_ia64_size_dynamic_sections): Set root.dt_jmprel_required\n+\tfor rel_pltoff_sec.  Call _bfd_elf_add_dynamic_tags.\n+\t* elflink.c (_bfd_elf_add_dynamic_tags): New.\n+\n 2020-06-22  Saagar Jha  <saagar@saagarjha.com>\n \n \t* mach-o.c: Support the new load commands by reading a linkedit"
    },
    {
      "sha": "1576724511d2f1cffce3c241754dfa3fe129ff96",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -573,6 +573,12 @@ struct elf_link_hash_table\n   /* TRUE if there are IFUNC resolvers.  */\n   bfd_boolean ifunc_resolvers;\n \n+  /* TRUE if DT_PLTGOT is a required dynamic tag.  */\n+  bfd_boolean dt_pltgot_required;\n+\n+  /* TRUE if DT_JMPREL is a required dynamic tag.  */\n+  bfd_boolean dt_jmprel_required;\n+\n   /* The BFD used to hold special sections created by the linker.\n      This will be the first BFD found which requires these sections to\n      be created.  */\n@@ -2908,6 +2914,9 @@ extern asection *_bfd_elf_readonly_dynrelocs\n extern bfd_boolean _bfd_elf_maybe_set_textrel\n   (struct elf_link_hash_entry *, void *);\n \n+extern bfd_boolean _bfd_elf_add_dynamic_tags\n+  (bfd *, struct bfd_link_info *, bfd_boolean);\n+\n /* Large common section.  */\n extern asection _bfd_elf_large_com_section;\n "
    },
    {
      "sha": "1c436a78d5cb2aeb593251442d88854295763f6c",
      "filename": "bfd/elf-m10300.c",
      "status": "modified",
      "additions": 3,
      "deletions": 63,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf-m10300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf-m10300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-m10300.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -5012,9 +5012,7 @@ _bfd_mn10300_elf_size_dynamic_sections (bfd * output_bfd,\n   struct elf32_mn10300_link_hash_table *htab = elf32_mn10300_hash_table (info);\n   bfd * dynobj;\n   asection * s;\n-  bfd_boolean plt;\n   bfd_boolean relocs;\n-  bfd_boolean reltext;\n \n   dynobj = htab->root.dynobj;\n   BFD_ASSERT (dynobj != NULL);\n@@ -5052,9 +5050,7 @@ _bfd_mn10300_elf_size_dynamic_sections (bfd * output_bfd,\n   /* The check_relocs and adjust_dynamic_symbol entry points have\n      determined the sizes of the various dynamic sections.  Allocate\n      memory for them.  */\n-  plt = FALSE;\n   relocs = FALSE;\n-  reltext = FALSE;\n   for (s = dynobj->sections; s != NULL; s = s->next)\n     {\n       const char * name;\n@@ -5069,34 +5065,16 @@ _bfd_mn10300_elf_size_dynamic_sections (bfd * output_bfd,\n       if (streq (name, \".plt\"))\n \t{\n \t  /* Remember whether there is a PLT.  */\n-\t  plt = s->size != 0;\n+\t  ;\n \t}\n       else if (CONST_STRNEQ (name, \".rela\"))\n \t{\n \t  if (s->size != 0)\n \t    {\n-\t      asection * target;\n-\n \t      /* Remember whether there are any reloc sections other\n \t\t than .rela.plt.  */\n \t      if (! streq (name, \".rela.plt\"))\n-\t\t{\n-\t\t  const char * outname;\n-\n-\t\t  relocs = TRUE;\n-\n-\t\t  /* If this relocation section applies to a read only\n-\t\t     section, then we probably need a DT_TEXTREL\n-\t\t     entry.  The entries in the .rela.plt section\n-\t\t     really apply to the .got section, which we\n-\t\t     created ourselves and so know is not readonly.  */\n-\t\t  outname = bfd_section_name (s->output_section);\n-\t\t  target = bfd_get_section_by_name (output_bfd, outname + 5);\n-\t\t  if (target != NULL\n-\t\t      && (target->flags & SEC_READONLY) != 0\n-\t\t      && (target->flags & SEC_ALLOC) != 0)\n-\t\t    reltext = TRUE;\n-\t\t}\n+\t\trelocs = TRUE;\n \n \t      /* We use the reloc_count field as a counter if we need\n \t\t to copy relocs into the output file.  */\n@@ -5136,45 +5114,7 @@ _bfd_mn10300_elf_size_dynamic_sections (bfd * output_bfd,\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in _bfd_mn10300_elf_finish_dynamic_sections,\n-\t but we must add the entries now so that we get the correct\n-\t size for the .dynamic section.  The DT_DEBUG entry is filled\n-\t in by the dynamic linker and used by the debugger.  */\n-      if (! bfd_link_pic (info))\n-\t{\n-\t  if (!_bfd_elf_add_dynamic_entry (info, DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (plt)\n-\t{\n-\t  if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_RELA)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!_bfd_elf_add_dynamic_entry (info, DT_RELA, 0)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_RELASZ, 0)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_RELAENT,\n-\t\t\t\t\t      sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\t}\n-\n-      if (reltext)\n-\t{\n-\t  if (!_bfd_elf_add_dynamic_entry (info, DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-    }\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Finish up dynamic symbol handling.  We set the contents of various"
    },
    {
      "sha": "f8a57e1a7dc7d18ed723816248d973a294afff42",
      "filename": "bfd/elf-vxworks.c",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf-vxworks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf-vxworks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-vxworks.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -295,4 +295,17 @@ elf_vxworks_finish_dynamic_entry (bfd *output_bfd, Elf_Internal_Dyn *dyn)\n   return TRUE;\n }\n \n+/* Add dynamic tags.  */\n \n+bfd_boolean\n+_bfd_elf_maybe_vxworks_add_dynamic_tags (bfd *output_bfd,\n+\t\t\t\t\t struct bfd_link_info *info,\n+\t\t\t\t\t bfd_boolean need_dynamic_reloc)\n+{\n+  struct elf_link_hash_table *htab = elf_hash_table (info);\n+  return (_bfd_elf_add_dynamic_tags (output_bfd, info,\n+\t\t\t\t     need_dynamic_reloc)\n+\t  && (!htab->dynamic_sections_created\n+\t      || htab->target_os != is_vxworks\n+\t      || elf_vxworks_add_dynamic_entries (output_bfd, info)));\n+}"
    },
    {
      "sha": "47a099fca729229258386caca7ecb27eb466a36d",
      "filename": "bfd/elf-vxworks.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf-vxworks.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf-vxworks.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-vxworks.h?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -33,4 +33,5 @@ bfd_boolean elf_vxworks_create_dynamic_sections\n   (bfd *, struct bfd_link_info *, asection **);\n bfd_boolean elf_vxworks_add_dynamic_entries (bfd *, struct bfd_link_info *);\n bfd_boolean elf_vxworks_finish_dynamic_entry (bfd *, Elf_Internal_Dyn *);\n-\n+bfd_boolean _bfd_elf_maybe_vxworks_add_dynamic_tags\n+  (bfd *, struct bfd_link_info *, bfd_boolean);"
    },
    {
      "sha": "4d9d6b999285e0ded9601b265e098a88c07c4de6",
      "filename": "bfd/elf32-arc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 51,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arc.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2707,7 +2707,6 @@ elf_arc_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n   bfd *dynobj;\n   asection *s;\n   bfd_boolean relocs_exist = FALSE;\n-  bfd_boolean reltext_exist = FALSE;\n   struct elf_link_hash_table *htab = elf_hash_table (info);\n \n   dynobj = htab->dynobj;\n@@ -2762,29 +2761,7 @@ elf_arc_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n       else if (strncmp (s->name, \".rela\", 5) == 0)\n \t{\n \t  if (s->size != 0 && s != htab->srelplt)\n-\t    {\n-\t      if (!reltext_exist)\n-\t\t{\n-\t\t  const char *name = s->name + 5;\n-\t\t  bfd *ibfd;\n-\t\t  for (ibfd = info->input_bfds; ibfd; ibfd = ibfd->link.next)\n-\t\t    if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour\n-\t\t\t&& ibfd->flags & DYNAMIC)\n-\t\t      {\n-\t\t\tasection *target = bfd_get_section_by_name (ibfd, name);\n-\t\t\tif (target != NULL\n-\t\t\t    && elf_section_data (target)->sreloc == s\n-\t\t\t    && ((target->output_section->flags\n-\t\t\t\t & (SEC_READONLY | SEC_ALLOC))\n-\t\t\t\t== (SEC_READONLY | SEC_ALLOC)))\n-\t\t\t  {\n-\t\t\t    reltext_exist = TRUE;\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t      }\n-\t\t}\n-\t      relocs_exist = TRUE;\n-\t    }\n+\t    relocs_exist = TRUE;\n \n \t  /* We use the reloc_count field as a counter if we need to\n \t     copy relocs into the output file.  */\n@@ -2811,33 +2788,7 @@ elf_arc_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (htab->dynamic_sections_created)\n-    {\n-      /* TODO: Check if this is needed.  */\n-      if (!bfd_link_pic (info))\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_DEBUG, 0))\n-\t\treturn FALSE;\n-\n-      if (htab->splt && (htab->splt->flags & SEC_EXCLUDE) == 0)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_RELA)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))\n-\t  return FALSE;\n-\n-      if (relocs_exist)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_RELA, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_RELASZ, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_RELAENT,\n-\t\t\t\t\t    sizeof (Elf32_External_Rela)))\n-\t  return FALSE;\n-\n-      if (reltext_exist)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_TEXTREL, 0))\n-\t  return FALSE;\n-    }\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs_exist);\n }\n \n "
    },
    {
      "sha": "508f4236932ac9a5234af26563cea6246bcd448f",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 3,
      "deletions": 70,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -16673,7 +16673,6 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n {\n   bfd * dynobj;\n   asection * s;\n-  bfd_boolean plt;\n   bfd_boolean relocs;\n   bfd *ibfd;\n   struct elf32_arm_link_hash_table *htab;\n@@ -16976,7 +16975,6 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n   /* The check_relocs and adjust_dynamic_symbol entry points have\n      determined the sizes of the various dynamic sections.  Allocate\n      memory for them.  */\n-  plt = FALSE;\n   relocs = FALSE;\n   for (s = dynobj->sections; s != NULL; s = s->next)\n     {\n@@ -16992,7 +16990,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n       if (s == htab->root.splt)\n \t{\n \t  /* Remember whether there is a PLT.  */\n-\t  plt = s->size != 0;\n+\t  ;\n \t}\n       else if (CONST_STRNEQ (name, \".rel\"))\n \t{\n@@ -17044,73 +17042,8 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf32_arm_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-     if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (plt)\n-\t{\n-\t  if (   !add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL,\n-\t\t\t\t     htab->use_rel ? DT_REL : DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\n-\t  if (htab->root.tlsdesc_plt\n-\t      && (!add_dynamic_entry (DT_TLSDESC_PLT,0)\n-\t\t  || !add_dynamic_entry (DT_TLSDESC_GOT,0)))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (htab->use_rel)\n-\t    {\n-\t      if (!add_dynamic_entry (DT_REL, 0)\n-\t\t  || !add_dynamic_entry (DT_RELSZ, 0)\n-\t\t  || !add_dynamic_entry (DT_RELENT, RELOC_SIZE (htab)))\n-\t\treturn FALSE;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (!add_dynamic_entry (DT_RELA, 0)\n-\t\t  || !add_dynamic_entry (DT_RELASZ, 0)\n-\t\t  || !add_dynamic_entry (DT_RELAENT, RELOC_SIZE (htab)))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-\n-      /* If any dynamic relocs apply to a read-only section,\n-\t then we need a DT_TEXTREL entry.  */\n-      if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->root,\n-\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n-\n-      if ((info->flags & DF_TEXTREL) != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-      if (htab->root.target_os == is_vxworks\n-\t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n-\treturn FALSE;\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_maybe_vxworks_add_dynamic_tags (output_bfd, info,\n+\t\t\t\t\t\t  relocs);\n }\n \n /* Size sections even though they're not dynamic.  We use it to setup"
    },
    {
      "sha": "eed437f8f43fbdf122e80fc6e2efa86d1a80b021",
      "filename": "bfd/elf32-bfin.c",
      "status": "modified",
      "additions": 1,
      "deletions": 21,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-bfin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-bfin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-bfin.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -4067,26 +4067,6 @@ elf32_bfinfdpic_size_dynamic_sections (bfd *output_bfd,\n   if (!_bfinfdpic_size_got_plt (output_bfd, &gpinfo))\n       return FALSE;\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      if (bfinfdpic_got_section (info)->size)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0))\n-\t  return FALSE;\n-\n-      if (bfinfdpic_pltrel_section (info)->size)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_REL)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))\n-\t  return FALSE;\n-\n-      if (bfinfdpic_gotrel_section (info)->size)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_REL, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_RELSZ, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_RELENT,\n-\t\t\t\t\t    sizeof (Elf32_External_Rel)))\n-\t  return FALSE;\n-    }\n-\n   s = bfd_get_linker_section (dynobj, \".dynbss\");\n   if (s && s->size == 0)\n     s->flags |= SEC_EXCLUDE;\n@@ -4095,7 +4075,7 @@ elf32_bfinfdpic_size_dynamic_sections (bfd *output_bfd,\n   if (s && s->size == 0)\n     s->flags |= SEC_EXCLUDE;\n \n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, TRUE);\n }\n \n static bfd_boolean"
    },
    {
      "sha": "8a3775efc07e80beb9a01c88870854aa2d55b16b",
      "filename": "bfd/elf32-cr16.c",
      "status": "modified",
      "additions": 3,
      "deletions": 63,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-cr16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-cr16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-cr16.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2407,9 +2407,7 @@ _bfd_cr16_elf_size_dynamic_sections (bfd * output_bfd,\n {\n   bfd * dynobj;\n   asection * s;\n-  bfd_boolean plt;\n   bfd_boolean relocs;\n-  bfd_boolean reltext;\n \n   dynobj = elf_hash_table (info)->dynobj;\n   BFD_ASSERT (dynobj != NULL);\n@@ -2442,9 +2440,7 @@ _bfd_cr16_elf_size_dynamic_sections (bfd * output_bfd,\n   /* The check_relocs and adjust_dynamic_symbol entry points have\n      determined the sizes of the various dynamic sections.  Allocate\n      memory for them.  */\n-  plt = FALSE;\n   relocs = FALSE;\n-  reltext = FALSE;\n   for (s = dynobj->sections; s != NULL; s = s->next)\n     {\n       const char * name;\n@@ -2459,34 +2455,16 @@ _bfd_cr16_elf_size_dynamic_sections (bfd * output_bfd,\n       if (strcmp (name, \".plt\") == 0)\n \t{\n \t  /* Remember whether there is a PLT.  */\n-\t  plt = s->size != 0;\n+\t  ;\n \t}\n       else if (CONST_STRNEQ (name, \".rela\"))\n \t{\n \t  if (s->size != 0)\n \t    {\n-\t      asection * target;\n-\n \t      /* Remember whether there are any reloc sections other\n \t\t than .rela.plt.  */\n \t      if (strcmp (name, \".rela.plt\") != 0)\n-\t\t{\n-\t\t  const char * outname;\n-\n-\t\t  relocs = TRUE;\n-\n-\t\t  /* If this relocation section applies to a read only\n-\t\t     section, then we probably need a DT_TEXTREL\n-\t\t     entry.  The entries in the .rela.plt section\n-\t\t     really apply to the .got section, which we\n-\t\t     created ourselves and so know is not readonly.  */\n-\t\t  outname = bfd_section_name (s->output_section);\n-\t\t  target = bfd_get_section_by_name (output_bfd, outname + 5);\n-\t\t  if (target != NULL\n-\t\t      && (target->flags & SEC_READONLY) != 0\n-\t\t      && (target->flags & SEC_ALLOC) != 0)\n-\t\t    reltext = TRUE;\n-\t\t}\n+\t\trelocs = TRUE;\n \n \t      /* We use the reloc_count field as a counter if we need\n \t\t to copy relocs into the output file.  */\n@@ -2526,45 +2504,7 @@ _bfd_cr16_elf_size_dynamic_sections (bfd * output_bfd,\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in _bfd_cr16_elf_finish_dynamic_sections,\n-\t but we must add the entries now so that we get the correct\n-\t size for the .dynamic section.  The DT_DEBUG entry is filled\n-\t in by the dynamic linker and used by the debugger.  */\n-      if (! bfd_link_executable (info))\n-\t{\n-\t  if (!_bfd_elf_add_dynamic_entry (info, DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (plt)\n-\t{\n-\t  if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_RELA)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!_bfd_elf_add_dynamic_entry (info, DT_RELA, 0)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_RELASZ, 0)\n-\t      || !_bfd_elf_add_dynamic_entry (info, DT_RELAENT,\n-\t\t\t\t\t      sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\t}\n-\n-      if (reltext)\n-\t{\n-\t  if (!_bfd_elf_add_dynamic_entry (info, DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-    }\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Finish up dynamic symbol handling.  We set the contents of various"
    },
    {
      "sha": "96ed5f6bb065c9317c75449b5afb670a2c406812",
      "filename": "bfd/elf32-frv.c",
      "status": "modified",
      "additions": 1,
      "deletions": 21,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-frv.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -5466,27 +5466,7 @@ elf32_frvfdpic_size_dynamic_sections (bfd *output_bfd,\n   if (!_frvfdpic_size_got_plt (output_bfd, &gpinfo))\n     return FALSE;\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      if (frvfdpic_got_section (info)->size)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0))\n-\t  return FALSE;\n-\n-      if (frvfdpic_pltrel_section (info)->size)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_REL)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))\n-\t  return FALSE;\n-\n-      if (frvfdpic_gotrel_section (info)->size)\n-\tif (!_bfd_elf_add_dynamic_entry (info, DT_REL, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_RELSZ, 0)\n-\t    || !_bfd_elf_add_dynamic_entry (info, DT_RELENT,\n-\t\t\t\t\t    sizeof (Elf32_External_Rel)))\n-\t  return FALSE;\n-    }\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, TRUE);\n }\n \n static bfd_boolean"
    },
    {
      "sha": "36582d078f946ae14f597cd0a461d15beac63e1b",
      "filename": "bfd/elf32-hppa.c",
      "status": "modified",
      "additions": 2,
      "deletions": 54,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-hppa.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -435,6 +435,7 @@ elf32_hppa_link_hash_table_create (bfd *abfd)\n       return NULL;\n     }\n   htab->etab.root.hash_table_free = elf32_hppa_link_hash_table_free;\n+  htab->etab.dt_pltgot_required = TRUE;\n \n   htab->text_segment_base = (bfd_vma) -1;\n   htab->data_segment_base = (bfd_vma) -1;\n@@ -2278,60 +2279,7 @@ elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (htab->etab.dynamic_sections_created)\n-    {\n-      /* Like IA-64 and HPPA64, always create a DT_PLTGOT.  It\n-\t actually has nothing to do with the PLT, it is how we\n-\t communicate the LTP value of a load module to the dynamic\n-\t linker.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (!add_dynamic_entry (DT_PLTGOT, 0))\n-\treturn FALSE;\n-\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf32_hppa_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->etab.srelplt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->etab,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* External entry points for sizing and building linker stubs.  */"
    },
    {
      "sha": "2be3b9264421ff114c76a79646e67b0b6b8b35ce",
      "filename": "bfd/elf32-lm32.c",
      "status": "modified",
      "additions": 2,
      "deletions": 47,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-lm32.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2060,53 +2060,8 @@ lm32_elf_size_dynamic_sections (bfd *output_bfd,\n \treturn FALSE;\n     }\n \n-  if (htab->root.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in lm32_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-     if (bfd_link_executable (info))\n-\t{\n-\t  if (! add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->root.splt->size != 0)\n-\t{\n-\t  if (! add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || ! add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || ! add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || ! add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (! add_dynamic_entry (DT_RELA, 0)\n-\t      || ! add_dynamic_entry (DT_RELASZ, 0)\n-\t      || ! add_dynamic_entry (DT_RELAENT,\n-\t\t\t\t      sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (! add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-    }\n-#undef add_dynamic_entry\n+  if (!_bfd_elf_add_dynamic_tags (output_bfd, info, relocs))\n+    return FALSE;\n \n   /* Allocate .rofixup section.  */\n   if (IS_FDPIC (output_bfd))"
    },
    {
      "sha": "dfdf8f38c77bab13d3b7e1d232cae4dc77c9a4a7",
      "filename": "bfd/elf32-m32r.c",
      "status": "modified",
      "additions": 1,
      "deletions": 49,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32r.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2137,55 +2137,7 @@ m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (htab->root.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in m32r_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-     if (bfd_link_executable (info))\n-\t{\n-\t  if (! add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->root.splt->size != 0)\n-\t{\n-\t  if (! add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || ! add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || ! add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || ! add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (! add_dynamic_entry (DT_RELA, 0)\n-\t      || ! add_dynamic_entry (DT_RELASZ, 0)\n-\t      || ! add_dynamic_entry (DT_RELAENT,\n-\t\t\t\t      sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (! add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Relocate an M32R/D ELF section."
    },
    {
      "sha": "39c5e1c2cc9a0fd9388a3491c29177b811642de9",
      "filename": "bfd/elf32-m68k.c",
      "status": "modified",
      "additions": 2,
      "deletions": 45,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-m68k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-m68k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68k.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -3052,7 +3052,6 @@ elf_m68k_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n {\n   bfd *dynobj;\n   asection *s;\n-  bfd_boolean plt;\n   bfd_boolean relocs;\n \n   dynobj = elf_hash_table (info)->dynobj;\n@@ -3095,7 +3094,6 @@ elf_m68k_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n   /* The check_relocs and adjust_dynamic_symbol entry points have\n      determined the sizes of the various dynamic sections.  Allocate\n      memory for them.  */\n-  plt = FALSE;\n   relocs = FALSE;\n   for (s = dynobj->sections; s != NULL; s = s->next)\n     {\n@@ -3111,7 +3109,7 @@ elf_m68k_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n       if (strcmp (name, \".plt\") == 0)\n \t{\n \t  /* Remember whether there is a PLT.  */\n-\t  plt = s->size != 0;\n+\t  ;\n \t}\n       else if (CONST_STRNEQ (name, \".rela\"))\n \t{\n@@ -3160,48 +3158,7 @@ elf_m68k_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf_m68k_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (plt)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\t}\n-\n-      if ((info->flags & DF_TEXTREL) != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* This function is called via elf_link_hash_traverse if we are"
    },
    {
      "sha": "fc5f3a99d47706befebc4de800e12db6edec0995",
      "filename": "bfd/elf32-metag.c",
      "status": "modified",
      "additions": 2,
      "deletions": 50,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-metag.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -1039,6 +1039,7 @@ elf_metag_link_hash_table_create (bfd *abfd)\n       return NULL;\n     }\n   htab->etab.root.hash_table_free = elf_metag_link_hash_table_free;\n+  htab->etab.dt_pltgot_required = TRUE;\n \n   return &htab->etab.root;\n }\n@@ -2902,56 +2903,7 @@ elf_metag_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t}\n     }\n \n-  if (htab->etab.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf_metag_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (!add_dynamic_entry (DT_PLTGOT, 0))\n-\treturn FALSE;\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->etab.srelplt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->etab,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Finish up dynamic symbol handling.  We set the contents of various"
    },
    {
      "sha": "693fc71f73007677fabc49c33bcedc6ebec1e077",
      "filename": "bfd/elf32-microblaze.c",
      "status": "modified",
      "additions": 3,
      "deletions": 39,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-microblaze.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -3103,45 +3103,9 @@ microblaze_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in microblaze_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL)\t\t\t\\\n-      _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (!add_dynamic_entry (DT_RELA, 0)\n-\t  || !add_dynamic_entry (DT_RELASZ, 0)\n-\t  || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\treturn FALSE;\n-\n-      if (htab->elf.splt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0)\n-\t      || !add_dynamic_entry (DT_BIND_NOW, 1))\n-\t    return FALSE;\n-\t}\n-\n-      if (info->flags & DF_TEXTREL)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-    }\n-#undef add_dynamic_entry\n-  return TRUE;\n+  /* ??? Force DF_BIND_NOW?  */\n+  info->flags |= DF_BIND_NOW;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, TRUE);\n }\n \n /* Finish up dynamic symbol handling.  We set the contents of various"
    },
    {
      "sha": "186ab36e89c53eb4f42e866a9860bfe822f55d6d",
      "filename": "bfd/elf32-nds32.c",
      "status": "modified",
      "additions": 2,
      "deletions": 61,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -4262,7 +4262,6 @@ nds32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n   bfd *dynobj;\n   asection *s;\n   bfd_boolean relocs;\n-  bfd_boolean plt;\n   bfd *ibfd;\n \n   htab = nds32_elf_hash_table (info);\n@@ -4422,7 +4421,6 @@ nds32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n   /* The check_relocs and adjust_dynamic_symbol entry points have\n      determined the sizes of the various dynamic sections.  Allocate\n      memory for them.  */\n-  plt = FALSE;\n   relocs = FALSE;\n   for (s = dynobj->sections; s != NULL; s = s->next)\n     {\n@@ -4433,7 +4431,7 @@ nds32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t{\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n-\t  plt = s->size != 0;\n+\t  ;\n \t}\n       else if (s == elf_hash_table (info)->sgot)\n \t{\n@@ -4483,64 +4481,7 @@ nds32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-\n-  if (htab->root.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in nds32_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (elf_hash_table (info)->splt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->tls_desc_trampoline && plt)\n-\t{\n-\t  if (htab->root.tlsdesc_plt\n-\t      && (!add_dynamic_entry (DT_TLSDESC_PLT, 0)\n-\t\t  || !add_dynamic_entry (DT_TLSDESC_GOT, 0)))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel,\n-\t\t\t\t    (void *) info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n static bfd_reloc_status_type"
    },
    {
      "sha": "01c2fe5ee54cfe65b1fdbb1b4bf9816f5249fd4c",
      "filename": "bfd/elf32-nios2.c",
      "status": "modified",
      "additions": 1,
      "deletions": 46,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-nios2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-nios2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nios2.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -5877,52 +5877,7 @@ nios2_elf32_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n   if (htab->res_n_size)\n     elf_link_hash_traverse (& htab->root, adjust_dynrelocs, info);\n \n-  if (htab->root.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf_nios2_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (!bfd_link_pic (info) && !add_dynamic_entry (DT_DEBUG, 0))\n-\treturn FALSE;\n-\n-      if (htab->root.sgotplt->size != 0\n-\t  && !add_dynamic_entry (DT_PLTGOT, 0))\n-\treturn FALSE;\n-\n-      if (htab->root.splt->size != 0\n-\t  && (!add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0)))\n-\treturn FALSE;\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT,\n-\t\t\t\t     sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0\n-\t      && !add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (!bfd_link_pic (info) && !add_dynamic_entry (DT_NIOS2_GP, 0))\n-\treturn FALSE;\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Free the derived linker hash table.  */"
    },
    {
      "sha": "7c02d004cc7afcd1e8c932a108e706e4f0ce2fbe",
      "filename": "bfd/elf32-or1k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 49,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-or1k.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -3078,55 +3078,7 @@ or1k_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (htab->root.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in or1k_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-     if (bfd_link_executable (info))\n-       {\n-\t if (! add_dynamic_entry (DT_DEBUG, 0))\n-\t   return FALSE;\n-       }\n-\n-     if (htab->root.splt->size != 0)\n-       {\n-\t if (! add_dynamic_entry (DT_PLTGOT, 0)\n-\t     || ! add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t     || ! add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t     || ! add_dynamic_entry (DT_JMPREL, 0))\n-\t   return FALSE;\n-\t}\n-\n-     if (relocs)\n-       {\n-\t if (! add_dynamic_entry (DT_RELA, 0)\n-\t     || ! add_dynamic_entry (DT_RELASZ, 0)\n-\t     || ! add_dynamic_entry (DT_RELAENT,\n-\t\t\t\t     sizeof (Elf32_External_Rela)))\n-\t   return FALSE;\n-\n-\t /* If any dynamic relocs apply to a read-only section,\n-\t    then we need a DT_TEXTREL entry.  */\n-\t if ((info->flags & DF_TEXTREL) == 0)\n-\t   elf_link_hash_traverse (&htab->root,\n-\t\t\t\t   _bfd_elf_maybe_set_textrel, info);\n-\n-\t if ((info->flags & DF_TEXTREL) != 0)\n-\t   {\n-\t     if (! add_dynamic_entry (DT_TEXTREL, 0))\n-\t       return FALSE;\n-\t   }\n-       }\n-    }\n-\n-#undef add_dynamic_entry\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Copy the extra info we tack onto an elf_link_hash_entry.  */"
    },
    {
      "sha": "5155dc935f98c563f629f1cd13b7b2bce9a6357c",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 3,
      "deletions": 38,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -5822,20 +5822,9 @@ ppc_elf_size_dynamic_sections (bfd *output_bfd,\n #define add_dynamic_entry(TAG, VAL) \\\n   _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n \n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.splt != NULL && htab->elf.splt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n+      if (!_bfd_elf_maybe_vxworks_add_dynamic_tags (output_bfd, info,\n+\t\t\t\t\t\t    relocs))\n+\treturn FALSE;\n \n       if (htab->plt_type == PLT_NEW\n \t  && htab->glink != NULL\n@@ -5849,30 +5838,6 @@ ppc_elf_size_dynamic_sections (bfd *output_bfd,\n \t      && !add_dynamic_entry (DT_PPC_OPT, PPC_OPT_TLS))\n \t    return FALSE;\n \t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\t}\n-\n-      /* If any dynamic relocs apply to a read-only section, then we\n-\t need a DT_TEXTREL entry.  */\n-      if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (elf_hash_table (info),\n-\t\t\t\t_bfd_elf_maybe_set_textrel,\n-\t\t\t\tinfo);\n-\n-      if ((info->flags & DF_TEXTREL) != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-      if (htab->elf.target_os == is_vxworks\n-\t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n-\treturn FALSE;\n    }\n #undef add_dynamic_entry\n "
    },
    {
      "sha": "ceb978791774b0300b250c28ac2dbc816e3e6da5",
      "filename": "bfd/elf32-s390.c",
      "status": "modified",
      "additions": 1,
      "deletions": 48,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-s390.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -1965,54 +1965,7 @@ elf_s390_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (htab->elf.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf_s390_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.splt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Return the base VMA address which should be subtracted from real addresses"
    },
    {
      "sha": "8c74ef7c778eaf76cfde970611869bef00b0c060",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 7,
      "deletions": 58,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2255,7 +2255,11 @@ sh_elf_link_hash_table_create (bfd *abfd)\n       return NULL;\n     }\n \n-  ret->fdpic_p = fdpic_object_p (abfd);\n+  if (fdpic_object_p (abfd))\n+    {\n+      ret->root.dt_pltgot_required = TRUE;\n+      ret->fdpic_p = TRUE;\n+    }\n \n   return &ret->root.root;\n }\n@@ -3196,63 +3200,8 @@ sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (htab->root.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in sh_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (! add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->root.splt->size != 0)\n-\t{\n-\t  if (! add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || ! add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || ! add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || ! add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-      else if ((elf_elfheader (output_bfd)->e_flags & EF_SH_FDPIC))\n-\t{\n-\t  if (! add_dynamic_entry (DT_PLTGOT, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (! add_dynamic_entry (DT_RELA, 0)\n-\t      || ! add_dynamic_entry (DT_RELASZ, 0)\n-\t      || ! add_dynamic_entry (DT_RELAENT,\n-\t\t\t\t      sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (! add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-      if (htab->root.target_os == is_vxworks\n-\t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n-\treturn FALSE;\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_maybe_vxworks_add_dynamic_tags (output_bfd, info,\n+\t\t\t\t\t\t  relocs);\n }\n \f\n /* Add a dynamic relocation to the SRELOC section.  */"
    },
    {
      "sha": "5b3e80a5fc9865ef86a5502ca655884b589c535c",
      "filename": "bfd/elf32-tilepro.c",
      "status": "modified",
      "additions": 1,
      "deletions": 45,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tilepro.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2381,51 +2381,7 @@ tilepro_elf_size_dynamic_sections (bfd *output_bfd,\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in tilepro_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.srelplt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (!add_dynamic_entry (DT_RELA, 0)\n-\t  || !add_dynamic_entry (DT_RELASZ, 0)\n-\t  || !add_dynamic_entry (DT_RELAENT, TILEPRO_ELF_RELA_BYTES))\n-\treturn FALSE;\n-\n-      /* If any dynamic relocs apply to a read-only section,\n-\t then we need a DT_TEXTREL entry.  */\n-      if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->elf,\n-\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n-\n-      if (info->flags & DF_TEXTREL)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, TRUE);\n }\n \f\n /* Return the base VMA address which should be subtracted from real addresses"
    },
    {
      "sha": "58a4a8bdfbee928ea4820e4a5bc154268cf6fd39",
      "filename": "bfd/elf32-vax.c",
      "status": "modified",
      "additions": 3,
      "deletions": 67,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-vax.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-vax.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-vax.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -1029,9 +1029,7 @@ elf_vax_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n {\n   bfd *dynobj;\n   asection *s;\n-  bfd_boolean plt;\n   bfd_boolean relocs;\n-  bfd_boolean reltext;\n \n   dynobj = elf_hash_table (info)->dynobj;\n   BFD_ASSERT (dynobj != NULL);\n@@ -1067,9 +1065,7 @@ elf_vax_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n   /* The check_relocs and adjust_dynamic_symbol entry points have\n      determined the sizes of the various dynamic sections.  Allocate\n      memory for them.  */\n-  plt = FALSE;\n   relocs = FALSE;\n-  reltext = FALSE;\n   for (s = dynobj->sections; s != NULL; s = s->next)\n     {\n       const char *name;\n@@ -1084,33 +1080,14 @@ elf_vax_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n       if (strcmp (name, \".plt\") == 0)\n \t{\n \t  /* Remember whether there is a PLT.  */\n-\t  plt = s->size != 0;\n+\t  ;\n \t}\n       else if (CONST_STRNEQ (name, \".rela\"))\n \t{\n \t  if (s->size != 0)\n \t    {\n-\t      asection *target;\n-\n-\t      /* Remember whether there are any reloc sections other\n-\t\t than .rela.plt.  */\n \t      if (strcmp (name, \".rela.plt\") != 0)\n-\t\t{\n-\t\t  const char *outname;\n-\n-\t\t  relocs = TRUE;\n-\n-\t\t  /* If this relocation section applies to a read only\n-\t\t     section, then we probably need a DT_TEXTREL\n-\t\t     entry.  .rela.plt is actually associated with\n-\t\t     .got.plt, which is never readonly.  */\n-\t\t  outname = bfd_section_name (s->output_section);\n-\t\t  target = bfd_get_section_by_name (output_bfd, outname + 5);\n-\t\t  if (target != NULL\n-\t\t      && (target->flags & SEC_READONLY) != 0\n-\t\t      && (target->flags & SEC_ALLOC) != 0)\n-\t\t    reltext = TRUE;\n-\t\t}\n+\t\trelocs = TRUE;\n \n \t      /* We use the reloc_count field as a counter if we need\n \t\t to copy relocs into the output file.  */\n@@ -1148,48 +1125,7 @@ elf_vax_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf_vax_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (!bfd_link_pic (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (plt)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\t}\n-\n-      if (reltext || (info->flags & DF_TEXTREL) != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* This function is called via elf_vax_link_hash_traverse if we are"
    },
    {
      "sha": "45727b3f805c070eb9dc208082318fea915d574a",
      "filename": "bfd/elf32-xtensa.c",
      "status": "modified",
      "additions": 5,
      "deletions": 23,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-xtensa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf32-xtensa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-xtensa.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -766,6 +766,7 @@ elf_xtensa_link_hash_table_create (bfd *abfd)\n   tlsbase->root.type = bfd_link_hash_new;\n   tlsbase->root.u.undef.abfd = NULL;\n   tlsbase->non_elf = 0;\n+  ret->elf.dt_pltgot_required = TRUE;\n   ret->tlsbase = elf_xtensa_hash_entry (tlsbase);\n   ret->tlsbase->tls_type = GOT_UNKNOWN;\n \n@@ -1767,30 +1768,11 @@ elf_xtensa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n #define add_dynamic_entry(TAG, VAL) \\\n   _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n \n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relplt)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relgot)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))\n-\t    return FALSE;\n-\t}\n+      if (!_bfd_elf_add_dynamic_tags (output_bfd, info,\n+\t\t\t\t      relplt || relgot))\n+\treturn FALSE;\n \n-      if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t  || !add_dynamic_entry (DT_XTENSA_GOT_LOC_OFF, 0)\n+      if (!add_dynamic_entry (DT_XTENSA_GOT_LOC_OFF, 0)\n \t  || !add_dynamic_entry (DT_XTENSA_GOT_LOC_SZ, 0))\n \treturn FALSE;\n     }"
    },
    {
      "sha": "a6b20982609b3d2ca3ed8a052d011dfe0cae88f3",
      "filename": "bfd/elf64-alpha.c",
      "status": "modified",
      "additions": 7,
      "deletions": 31,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf64-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf64-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-alpha.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2910,38 +2910,14 @@ elf64_alpha_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n #define add_dynamic_entry(TAG, VAL) \\\n   _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n \n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relplt)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\n-\t  if (elf64_alpha_use_secureplt\n-\t      && !add_dynamic_entry (DT_ALPHA_PLTRO, 1))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))\n-\t    return FALSE;\n+      if (!_bfd_elf_add_dynamic_tags (output_bfd, info,\n+\t\t\t\t      relocs || relplt))\n+\treturn FALSE;\n \n-\t  if (info->flags & DF_TEXTREL)\n-\t    {\n-\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n+      if (relplt\n+\t  && elf64_alpha_use_secureplt\n+\t  && !add_dynamic_entry (DT_ALPHA_PLTRO, 1))\n+\treturn FALSE;\n     }\n #undef add_dynamic_entry\n "
    },
    {
      "sha": "dd52b3511825bd7c3531f5eb7b4a39b9d1dd079d",
      "filename": "bfd/elf64-hppa.c",
      "status": "modified",
      "additions": 6,
      "deletions": 52,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf64-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf64-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-hppa.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -302,6 +302,7 @@ elf64_hppa_hash_table_create (bfd *abfd)\n       return NULL;\n     }\n \n+  htab->root.dt_pltgot_required = TRUE;\n   htab->text_segment_base = (bfd_vma) -1;\n   htab->data_segment_base = (bfd_vma) -1;\n \n@@ -1526,9 +1527,7 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n   bfd *dynobj;\n   bfd *ibfd;\n   asection *sec;\n-  bfd_boolean plt;\n   bfd_boolean relocs;\n-  bfd_boolean reltext;\n \n   hppa_info = hppa_link_hash_table (info);\n   if (hppa_info == NULL)\n@@ -1736,9 +1735,7 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t\t\t    allocate_dynrel_entries, &data);\n \n   /* The sizes of all the sections are set.  Allocate memory for them.  */\n-  plt = FALSE;\n   relocs = FALSE;\n-  reltext = FALSE;\n   for (sec = dynobj->sections; sec != NULL; sec = sec->next)\n     {\n       const char *name;\n@@ -1753,7 +1750,7 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n       if (strcmp (name, \".plt\") == 0)\n \t{\n \t  /* Remember whether there is a PLT.  */\n-\t  plt = sec->size != 0;\n+\t  ;\n \t}\n       else if (strcmp (name, \".opd\") == 0\n \t       || CONST_STRNEQ (name, \".dlt\")\n@@ -1766,28 +1763,10 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t{\n \t  if (sec->size != 0)\n \t    {\n-\t      asection *target;\n-\n \t      /* Remember whether there are any reloc sections other\n \t\t than .rela.plt.  */\n \t      if (strcmp (name, \".rela.plt\") != 0)\n-\t\t{\n-\t\t  const char *outname;\n-\n-\t\t  relocs = TRUE;\n-\n-\t\t  /* If this relocation section applies to a read only\n-\t\t     section, then we probably need a DT_TEXTREL\n-\t\t     entry.  The entries in the .rela.plt section\n-\t\t     really apply to the .got section, which we\n-\t\t     created ourselves and so know is not readonly.  */\n-\t\t  outname = bfd_section_name (sec->output_section);\n-\t\t  target = bfd_get_section_by_name (output_bfd, outname + 4);\n-\t\t  if (target != NULL\n-\t\t      && (target->flags & SEC_READONLY) != 0\n-\t\t      && (target->flags & SEC_ALLOC) != 0)\n-\t\t    reltext = TRUE;\n-\t\t}\n+\t\trelocs = TRUE;\n \n \t      /* We use the reloc_count field as a counter if we need\n \t\t to copy relocs into the output file.  */\n@@ -1840,8 +1819,7 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n #define add_dynamic_entry(TAG, VAL) \\\n   _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n \n-      if (!add_dynamic_entry (DT_HP_DLD_FLAGS, 0)\n-\t  || !add_dynamic_entry (DT_PLTGOT, 0))\n+      if (!add_dynamic_entry (DT_HP_DLD_FLAGS, 0))\n \treturn FALSE;\n \n       /* Add some entries to the .dynamic section.  We fill in the\n@@ -1851,8 +1829,7 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t dynamic linker and used by the debugger.  */\n       if (! bfd_link_pic (info))\n \t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0)\n-\t      || !add_dynamic_entry (DT_HP_DLD_HOOK, 0)\n+\t  if (!add_dynamic_entry (DT_HP_DLD_HOOK, 0)\n \t      || !add_dynamic_entry (DT_HP_LOAD_MAP, 0))\n \t    return FALSE;\n \t}\n@@ -1861,33 +1838,10 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t Required by HPUX 11.00 patch PHSS_26559.  */\n       if (!add_dynamic_entry (DT_FLAGS, (info)->flags))\n \treturn FALSE;\n-\n-      if (plt)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))\n-\t    return FALSE;\n-\t}\n-\n-      if (reltext)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t  info->flags |= DF_TEXTREL;\n-\t}\n     }\n #undef add_dynamic_entry\n \n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Called after we have output the symbol into the dynamic symbol"
    },
    {
      "sha": "da72c78753ef34fc9ac1b9aea14cda7a4872512c",
      "filename": "bfd/elf64-s390.c",
      "status": "modified",
      "additions": 1,
      "deletions": 48,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf64-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elf64-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-s390.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -1919,54 +1919,7 @@ elf_s390_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (htab->elf.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf_s390_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.splt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, relocs);\n }\n \n /* Return the base VMA address which should be subtracted from real addresses"
    },
    {
      "sha": "998b72f2281c5b9b5482795b9b55dfffe284ee23",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 93,
      "deletions": 0,
      "changes": 93,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -14897,3 +14897,96 @@ _bfd_elf_maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)\n     }\n   return TRUE;\n }\n+\n+/* Add dynamic tags.  */\n+\n+bfd_boolean\n+_bfd_elf_add_dynamic_tags (bfd *output_bfd, struct bfd_link_info *info,\n+\t\t\t   bfd_boolean need_dynamic_reloc)\n+{\n+  struct elf_link_hash_table *htab = elf_hash_table (info);\n+\n+  if (htab->dynamic_sections_created)\n+    {\n+      /* Add some entries to the .dynamic section.  We fill in the\n+\t values later, in finish_dynamic_sections, but we must add\n+\t the entries now so that we get the correct size for the\n+\t .dynamic section.  The DT_DEBUG entry is filled in by the\n+\t dynamic linker and used by the debugger.  */\n+#define add_dynamic_entry(TAG, VAL) \\\n+  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n+\n+      const struct elf_backend_data *bed\n+\t= get_elf_backend_data (output_bfd);\n+\n+      if (bfd_link_executable (info))\n+\t{\n+\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n+\t    return FALSE;\n+\t}\n+\n+      if (htab->dt_pltgot_required || htab->splt->size != 0)\n+\t{\n+\t  /* DT_PLTGOT is used by prelink even if there is no PLT\n+\t     relocation.  */\n+\t  if (!add_dynamic_entry (DT_PLTGOT, 0))\n+\t    return FALSE;\n+\t}\n+\n+      if (htab->dt_jmprel_required || htab->srelplt->size != 0)\n+\t{\n+\t  if (!add_dynamic_entry (DT_PLTRELSZ, 0)\n+\t      || !add_dynamic_entry (DT_PLTREL,\n+\t\t\t\t     (bed->rela_plts_and_copies_p\n+\t\t\t\t      ? DT_RELA : DT_REL))\n+\t      || !add_dynamic_entry (DT_JMPREL, 0))\n+\t    return FALSE;\n+\t}\n+\n+      if (htab->tlsdesc_plt\n+\t  && (!add_dynamic_entry (DT_TLSDESC_PLT, 0)\n+\t      || !add_dynamic_entry (DT_TLSDESC_GOT, 0)))\n+\treturn FALSE;\n+\n+      if (need_dynamic_reloc)\n+\t{\n+\t  if (bed->rela_plts_and_copies_p)\n+\t    {\n+\t      if (!add_dynamic_entry (DT_RELA, 0)\n+\t\t  || !add_dynamic_entry (DT_RELASZ, 0)\n+\t\t  || !add_dynamic_entry (DT_RELAENT,\n+\t\t\t\t\t bed->s->sizeof_rela))\n+\t\treturn FALSE;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!add_dynamic_entry (DT_REL, 0)\n+\t\t  || !add_dynamic_entry (DT_RELSZ, 0)\n+\t\t  || !add_dynamic_entry (DT_RELENT,\n+\t\t\t\t\t bed->s->sizeof_rel))\n+\t\treturn FALSE;\n+\t    }\n+\n+\t  /* If any dynamic relocs apply to a read-only section,\n+\t     then we need a DT_TEXTREL entry.  */\n+\t  if ((info->flags & DF_TEXTREL) == 0)\n+\t    elf_link_hash_traverse (htab, _bfd_elf_maybe_set_textrel,\n+\t\t\t\t    info);\n+\n+\t  if ((info->flags & DF_TEXTREL) != 0)\n+\t    {\n+\t      if (htab->ifunc_resolvers)\n+\t\tinfo->callbacks->einfo\n+\t\t  (_(\"%P: warning: GNU indirect functions with DT_TEXTREL \"\n+\t\t     \"may result in a segfault at runtime; recompile with %s\\n\"),\n+\t\t   bfd_link_dll (info) ? \"-fPIC\" : \"-fPIE\");\n+\n+\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n+\t\treturn FALSE;\n+\t    }\n+\t}\n+    }\n+#undef add_dynamic_entry\n+\n+  return TRUE;\n+}"
    },
    {
      "sha": "8f1e5e1e456abbfa8b8eb9ae219d76f1f49c0cab",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 2,
      "deletions": 36,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -9101,29 +9101,15 @@ elfNN_aarch64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n #define add_dynamic_entry(TAG, VAL)\t\t\t\\\n       _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n \n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n+      if (!_bfd_elf_add_dynamic_tags (output_bfd, info, relocs))\n+\treturn FALSE;\n \n       if (htab->root.splt->size != 0)\n \t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\n \t  if (htab->variant_pcs\n \t      && !add_dynamic_entry (DT_AARCH64_VARIANT_PCS, 0))\n \t    return FALSE;\n \n-\t  if (htab->root.tlsdesc_plt\n-\t      && (!add_dynamic_entry (DT_TLSDESC_PLT, 0)\n-\t\t  || !add_dynamic_entry (DT_TLSDESC_GOT, 0)))\n-\t    return FALSE;\n-\n \t  if ((elf_aarch64_tdata (output_bfd)->plt_type == PLT_BTI_PAC)\n \t      && (!add_dynamic_entry (DT_AARCH64_BTI_PLT, 0)\n \t\t  || !add_dynamic_entry (DT_AARCH64_PAC_PLT, 0)))\n@@ -9137,26 +9123,6 @@ elfNN_aarch64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t   && !add_dynamic_entry (DT_AARCH64_PAC_PLT, 0))\n \t    return FALSE;\n \t}\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (DT_RELA, 0)\n-\t      || !add_dynamic_entry (DT_RELASZ, 0)\n-\t      || !add_dynamic_entry (DT_RELAENT, RELOC_SIZE (htab)))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n     }\n #undef add_dynamic_entry\n "
    },
    {
      "sha": "4d6a0279e319cbca553257508509dad7c47d5e78",
      "filename": "bfd/elfnn-ia64.c",
      "status": "modified",
      "additions": 4,
      "deletions": 30,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfnn-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfnn-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-ia64.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -1473,6 +1473,7 @@ elfNN_ia64_hash_table_create (bfd *abfd)\n       return NULL;\n     }\n   ret->root.root.hash_table_free = elfNN_ia64_link_hash_table_free;\n+  ret->root.dt_pltgot_required = TRUE;\n \n   return &ret->root.root;\n }\n@@ -2994,7 +2995,6 @@ elfNN_ia64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n   struct elfNN_ia64_link_hash_table *ia64_info;\n   asection *sec;\n   bfd *dynobj;\n-  bfd_boolean relplt = FALSE;\n \n   ia64_info = elfNN_ia64_hash_table (info);\n   if (ia64_info == NULL)\n@@ -3148,7 +3148,7 @@ elfNN_ia64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t    ia64_info->rel_pltoff_sec = NULL;\n \t  else\n \t    {\n-\t      relplt = TRUE;\n+\t      ia64_info->root.dt_jmprel_required = TRUE;\n \t      /* We use the reloc_count field as a counter if we need to\n \t\t copy relocs into the output file.  */\n \t      sec->reloc_count = 0;\n@@ -3194,40 +3194,14 @@ elfNN_ia64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t later (in finish_dynamic_sections) but we must add the entries now\n \t so that we get the correct size for the .dynamic section.  */\n \n-      if (bfd_link_executable (info))\n-\t{\n-\t  /* The DT_DEBUG entry is filled in by the dynamic linker and used\n-\t     by the debugger.  */\n #define add_dynamic_entry(TAG, VAL) \\\n   _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n \n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (!add_dynamic_entry (DT_IA_64_PLT_RESERVE, 0))\n-\treturn FALSE;\n-      if (!add_dynamic_entry (DT_PLTGOT, 0))\n+      if (!_bfd_elf_add_dynamic_tags (output_bfd, info, TRUE))\n \treturn FALSE;\n \n-      if (relplt)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (!add_dynamic_entry (DT_RELA, 0)\n-\t  || !add_dynamic_entry (DT_RELASZ, 0)\n-\t  || !add_dynamic_entry (DT_RELAENT, sizeof (ElfNN_External_Rela)))\n+      if (!add_dynamic_entry (DT_IA_64_PLT_RESERVE, 0))\n \treturn FALSE;\n-\n-      if ((info->flags & DF_TEXTREL) != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n     }\n \n   /* ??? Perhaps force __gp local.  */"
    },
    {
      "sha": "a5fa415309ae890ef96d97ea82562cb7a1735067",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 1,
      "deletions": 45,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -1261,51 +1261,7 @@ riscv_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in riscv_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.srelplt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (!add_dynamic_entry (DT_RELA, 0)\n-\t  || !add_dynamic_entry (DT_RELASZ, 0)\n-\t  || !add_dynamic_entry (DT_RELAENT, sizeof (ElfNN_External_Rela)))\n-\treturn FALSE;\n-\n-      /* If any dynamic relocs apply to a read-only section,\n-\t then we need a DT_TEXTREL entry.  */\n-      if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->elf,\n-\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n-\n-      if (info->flags & DF_TEXTREL)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, TRUE);\n }\n \n #define TP_OFFSET 0"
    },
    {
      "sha": "bd046aca6c8e2ad93044b37994c1f0cc9c1ab9a6",
      "filename": "bfd/elfxx-sparc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 34,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfxx-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfxx-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2590,39 +2590,10 @@ _bfd_sparc_elf_size_dynamic_sections (bfd *output_bfd,\n #define add_dynamic_entry(TAG, VAL) \\\n   _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n \n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.srelplt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (!add_dynamic_entry (DT_RELA, 0)\n-\t  || !add_dynamic_entry (DT_RELASZ, 0)\n-\t  || !add_dynamic_entry (DT_RELAENT,\n-\t\t\t\t SPARC_ELF_RELA_BYTES (htab)))\n+      if (!_bfd_elf_maybe_vxworks_add_dynamic_tags (output_bfd, info,\n+\t\t\t\t\t\t    TRUE))\n \treturn FALSE;\n \n-      /* If any dynamic relocs apply to a read-only section,\n-\t then we need a DT_TEXTREL entry.  */\n-      if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->elf,\n-\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n-\n-      if (info->flags & DF_TEXTREL)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-\n       if (ABI_64_P (output_bfd))\n \t{\n \t  int reg;\n@@ -2678,9 +2649,6 @@ _bfd_sparc_elf_size_dynamic_sections (bfd *output_bfd,\n \t\teht->dynsymcount++;\n \t      }\n \t}\n-      if (htab->elf.target_os == is_vxworks\n-\t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n-\treturn FALSE;\n     }\n #undef add_dynamic_entry\n "
    },
    {
      "sha": "c0494a4ced526826b157d55467b38ba88ae33ef3",
      "filename": "bfd/elfxx-tilegx.c",
      "status": "modified",
      "additions": 1,
      "deletions": 45,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfxx-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfxx-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-tilegx.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -2621,51 +2621,7 @@ tilegx_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \treturn FALSE;\n     }\n \n-  if (elf_hash_table (info)->dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in tilegx_elf_finish_dynamic_sections, but we\n-\t must add the entries now so that we get the correct size for\n-\t the .dynamic section.  The DT_DEBUG entry is filled in by the\n-\t dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.srelplt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0)\n-\t      || !add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, DT_RELA)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (!add_dynamic_entry (DT_RELA, 0)\n-\t  || !add_dynamic_entry (DT_RELASZ, 0)\n-\t  || !add_dynamic_entry (DT_RELAENT, TILEGX_ELF_RELA_BYTES (htab)))\n-\treturn FALSE;\n-\n-      /* If any dynamic relocs apply to a read-only section,\n-\t then we need a DT_TEXTREL entry.  */\n-      if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->elf,\n-\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n-\n-      if (info->flags & DF_TEXTREL)\n-\t{\n-\t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t    return FALSE;\n-\t}\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_add_dynamic_tags (output_bfd, info, TRUE);\n }\n \f\n /* Return the base VMA address which should be subtracted from real addresses"
    },
    {
      "sha": "5b1793ae8071a17c9b47ef60744946b9f92d7698",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 2,
      "deletions": 76,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -721,9 +721,6 @@ _bfd_x86_elf_link_hash_table_create (bfd *abfd)\n   if (bed->target_id == X86_64_ELF_DATA)\n     {\n       ret->is_reloc_section = elf_x86_64_is_reloc_section;\n-      ret->dt_reloc = DT_RELA;\n-      ret->dt_reloc_sz = DT_RELASZ;\n-      ret->dt_reloc_ent = DT_RELAENT;\n       ret->got_entry_size = 8;\n       ret->pcrel_plt = TRUE;\n       ret->tls_get_addr = \"__tls_get_addr\";\n@@ -748,9 +745,6 @@ _bfd_x86_elf_link_hash_table_create (bfd *abfd)\n       else\n \t{\n \t  ret->is_reloc_section = elf_i386_is_reloc_section;\n-\t  ret->dt_reloc = DT_REL;\n-\t  ret->dt_reloc_sz = DT_RELSZ;\n-\t  ret->dt_reloc_ent = DT_RELENT;\n \t  ret->sizeof_reloc = sizeof (Elf32_External_Rel);\n \t  ret->got_entry_size = 4;\n \t  ret->pcrel_plt = FALSE;\n@@ -1362,76 +1356,8 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t   + PLT_FDE_LEN_OFFSET));\n     }\n \n-  if (htab->elf.dynamic_sections_created)\n-    {\n-      /* Add some entries to the .dynamic section.  We fill in the\n-\t values later, in elf_{i386,x86_64}_finish_dynamic_sections,\n-\t but we must add the entries now so that we get the correct\n-\t size for the .dynamic section.  The DT_DEBUG entry is filled\n-\t in by the dynamic linker and used by the debugger.  */\n-#define add_dynamic_entry(TAG, VAL) \\\n-  _bfd_elf_add_dynamic_entry (info, TAG, VAL)\n-\n-      if (bfd_link_executable (info))\n-\t{\n-\t  if (!add_dynamic_entry (DT_DEBUG, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.splt->size != 0)\n-\t{\n-\t  /* DT_PLTGOT is used by prelink even if there is no PLT\n-\t     relocation.  */\n-\t  if (!add_dynamic_entry (DT_PLTGOT, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.srelplt->size != 0)\n-\t{\n-\t  if (!add_dynamic_entry (DT_PLTRELSZ, 0)\n-\t      || !add_dynamic_entry (DT_PLTREL, htab->dt_reloc)\n-\t      || !add_dynamic_entry (DT_JMPREL, 0))\n-\t    return FALSE;\n-\t}\n-\n-      if (htab->elf.tlsdesc_plt\n-\t  && (!add_dynamic_entry (DT_TLSDESC_PLT, 0)\n-\t      || !add_dynamic_entry (DT_TLSDESC_GOT, 0)))\n-\treturn FALSE;\n-\n-      if (relocs)\n-\t{\n-\t  if (!add_dynamic_entry (htab->dt_reloc, 0)\n-\t      || !add_dynamic_entry (htab->dt_reloc_sz, 0)\n-\t      || !add_dynamic_entry (htab->dt_reloc_ent,\n-\t\t\t\t     htab->sizeof_reloc))\n-\t    return FALSE;\n-\n-\t  /* If any dynamic relocs apply to a read-only section,\n-\t     then we need a DT_TEXTREL entry.  */\n-\t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf,\n-\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n-\n-\t  if ((info->flags & DF_TEXTREL) != 0)\n-\t    {\n-\t      if (htab->elf.ifunc_resolvers)\n-\t\tinfo->callbacks->einfo\n-\t\t  (_(\"%P: warning: GNU indirect functions with DT_TEXTREL \"\n-\t\t     \"may result in a segfault at runtime; recompile with %s\\n\"),\n-\t\t   bfd_link_dll (info) ? \"-fPIC\" : \"-fPIE\");\n-\n-\t      if (!add_dynamic_entry (DT_TEXTREL, 0))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-      if (htab->elf.target_os == is_vxworks\n-\t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n-\treturn FALSE;\n-    }\n-#undef add_dynamic_entry\n-\n-  return TRUE;\n+  return _bfd_elf_maybe_vxworks_add_dynamic_tags (output_bfd, info,\n+\t\t\t\t\t\t  relocs);\n }\n \n /* Finish up the x86 dynamic sections.  */"
    },
    {
      "sha": "7541554bafb357a18d0fbe4ed282ffbb7c4f0923",
      "filename": "bfd/elfxx-x86.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfxx-x86.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5/bfd/elfxx-x86.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.h?ref=3084d7a27b8e4d13f0fdd0fac62ffadc9c2223b5",
      "patch": "@@ -510,9 +510,6 @@ struct elf_x86_link_hash_table\n   bfd_vma (*r_sym) (bfd_vma);\n   bfd_boolean (*is_reloc_section) (const char *);\n   unsigned int sizeof_reloc;\n-  unsigned int dt_reloc;\n-  unsigned int dt_reloc_sz;\n-  unsigned int dt_reloc_ent;\n   unsigned int got_entry_size;\n   unsigned int pointer_r_type;\n   int dynamic_interpreter_size;"
    }
  ]
}