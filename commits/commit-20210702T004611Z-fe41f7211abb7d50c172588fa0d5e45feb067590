{
  "sha": "fe41f7211abb7d50c172588fa0d5e45feb067590",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmU0MWY3MjExYWJiN2Q1MGMxNzI1ODhmYTBkNWU0NWZlYjA2NzU5MA==",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-07-01T04:28:10Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-07-02T00:46:11Z"
    },
    "message": "sim: m32r: unify ELF & Linux traps logic\n\nThis makes the simulator work the same regardless of the target (bare\nmetal m32r-elf or Linux m32r-linux-gnu) by unifying the traps code.\nIt was mostly already the same with the only difference being support\nfor trap #2 reserved for Linux syscalls.  We can move that logic to\nruntime by checking the current environment operating mode instead.",
    "tree": {
      "sha": "46618318325249c61fc839b589b54d8c70a2bed9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/46618318325249c61fc839b589b54d8c70a2bed9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fe41f7211abb7d50c172588fa0d5e45feb067590",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fe41f7211abb7d50c172588fa0d5e45feb067590",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fe41f7211abb7d50c172588fa0d5e45feb067590",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fe41f7211abb7d50c172588fa0d5e45feb067590/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d4a0121347ad9890060709a2a7660e0ac58b4b84",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d4a0121347ad9890060709a2a7660e0ac58b4b84",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d4a0121347ad9890060709a2a7660e0ac58b4b84"
    }
  ],
  "stats": {
    "total": 2592,
    "additions": 1207,
    "deletions": 1385
  },
  "files": [
    {
      "sha": "6b80e6a904fc23ced58ba736e2e6a09d5f1006e8",
      "filename": "sim/m32r/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/ChangeLog?ref=fe41f7211abb7d50c172588fa0d5e45feb067590",
      "patch": "@@ -1,3 +1,15 @@\n+2021-07-01  Mike Frysinger  <vapier@gentoo.org>\n+\n+\t* Makefile.in (TRAPS_OBJ, SIM_EXTRA_CFLAGS): Delete.\n+\t* configure.ac (traps_obj, sim_extra_cflags): Delete.\n+\t* sim-if.c (M32R_DEFAULT_MEM_SIZE): New define.\n+\t(sim_create_inferior): Replace M32R_LINUX with STATE_ENVIRONMENT\n+\tcheck.\n+\t* sim-main.h (M32R_DEFAULT_MEM_SIZE): Delete.\n+\t* traps-linux.c: Merge with ...\n+\t* traps.c: ... this file.\n+\t* configure: Regenerate.\n+\n 2021-07-01  Mike Frysinger  <vapier@gentoo.org>\n \n \t* traps-linux.c (conv_endian, conv_endian16,"
    },
    {
      "sha": "8877edcf4ae6a6cd93b70d478d2da053e266d373",
      "filename": "sim/m32r/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/Makefile.in?ref=fe41f7211abb7d50c172588fa0d5e45feb067590",
      "patch": "@@ -22,7 +22,6 @@\n M32R_OBJS = m32r.o cpu.o decode.o sem.o model.o mloop.o\n M32RX_OBJS = m32rx.o cpux.o decodex.o modelx.o mloopx.o\n M32R2_OBJS = m32r2.o cpu2.o decode2.o model2.o mloop2.o\n-TRAPS_OBJ = @traps_obj@\n \n SIM_OBJS = \\\n \t$(SIM_NEW_COMMON_OBJS) \\\n@@ -32,7 +31,7 @@ SIM_OBJS = \\\n \t$(M32R_OBJS) \\\n \t$(M32RX_OBJS) \\\n \t$(M32R2_OBJS) \\\n-\t$(TRAPS_OBJ)\n+\ttraps.o\n \n SIM_EXTRA_HW_DEVICES = m32r_cache m32r_uart\n \n@@ -42,8 +41,6 @@ SIM_EXTRA_DEPS = \\\n \tarch.h cpuall.h m32r-sim.h $(srcdir)/../../opcodes/m32r-desc.h \\\n \teng.h engx.h eng2.h\n \n-SIM_EXTRA_CFLAGS = @sim_extra_cflags@\n-\n SIM_EXTRA_CLEAN = m32r-clean\n \n # Code doesn't build cleanly yet."
    },
    {
      "sha": "38fa43dc998b059a6ccc6d70df4db3add57443c6",
      "filename": "sim/m32r/configure",
      "status": "modified",
      "additions": 0,
      "deletions": 15,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/configure?ref=fe41f7211abb7d50c172588fa0d5e45feb067590",
      "patch": "@@ -590,8 +590,6 @@ sim_reserved_bits\n sim_float\n sim_bitsize\n cgen_breaks\n-sim_extra_cflags\n-traps_obj\n target_alias\n host_alias\n build_alias\n@@ -1670,19 +1668,6 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n \n \n-  case \"${target_alias}\" in\n-  m32r*-linux*)\n-    traps_obj=traps-linux.o\n-    sim_extra_cflags=\"-DM32R_LINUX\"\n-    ;;\n-  *)\n-    traps_obj=traps.o\n-    sim_extra_cflags=\"-DM32R_ELF\"\n-    ;;\n-  esac\n-\n-\n-\n cgen_breaks=\"\"\n if grep CGEN_MAINT $srcdir/Makefile.in >/dev/null; then\n cgen_breaks=\"break cgen_rtx_error\";"
    },
    {
      "sha": "99370b3a5770e6ce8dc83f6ca797c74d008978a7",
      "filename": "sim/m32r/configure.ac",
      "status": "modified",
      "additions": 0,
      "deletions": 13,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/configure.ac?ref=fe41f7211abb7d50c172588fa0d5e45feb067590",
      "patch": "@@ -2,17 +2,4 @@ dnl Process this file with autoconf to produce a configure script.\n AC_INIT(Makefile.in)\n AC_CONFIG_MACRO_DIRS([../m4 ../.. ../../config])\n \n-  case \"${target_alias}\" in\n-  m32r*-linux*)\n-    traps_obj=traps-linux.o\n-    sim_extra_cflags=\"-DM32R_LINUX\"\n-    ;;\n-  *)\n-    traps_obj=traps.o\n-    sim_extra_cflags=\"-DM32R_ELF\"\n-    ;;\n-  esac\n-AC_SUBST(traps_obj)\n-AC_SUBST(sim_extra_cflags)\n-\n SIM_AC_OUTPUT"
    },
    {
      "sha": "e05b1630ace7250063d7f33157d1baab31b9ffbb",
      "filename": "sim/m32r/sim-if.c",
      "status": "modified",
      "additions": 9,
      "deletions": 6,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/sim-if.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/sim-if.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/sim-if.c?ref=fe41f7211abb7d50c172588fa0d5e45feb067590",
      "patch": "@@ -30,6 +30,8 @@\n \n #include \"dv-m32r_uart.h\"\n \n+#define M32R_DEFAULT_MEM_SIZE 0x2000000 /* 32M */\n+\n static void free_state (SIM_DESC);\n static void print_m32r_misc_cpu (SIM_CPU *cpu, int verbose);\n \f\n@@ -158,12 +160,13 @@ sim_create_inferior (SIM_DESC sd, struct bfd *abfd, char * const *argv,\n     addr = 0;\n   sim_pc_set (current_cpu, addr);\n \n-#ifdef M32R_LINUX\n-  m32rbf_h_cr_set (current_cpu,\n-                    m32r_decode_gdb_ctrl_regnum(SPI_REGNUM), 0x1f00000);\n-  m32rbf_h_cr_set (current_cpu,\n-                    m32r_decode_gdb_ctrl_regnum(SPU_REGNUM), 0x1f00000);\n-#endif\n+  if (STATE_ENVIRONMENT (sd) == USER_ENVIRONMENT)\n+    {\n+      m32rbf_h_cr_set (current_cpu,\n+\t\t       m32r_decode_gdb_ctrl_regnum(SPI_REGNUM), 0x1f00000);\n+      m32rbf_h_cr_set (current_cpu,\n+\t\t       m32r_decode_gdb_ctrl_regnum(SPU_REGNUM), 0x1f00000);\n+    }\n \n   /* Standalone mode (i.e. `run`) will take care of the argv for us in\n      sim_open() -> sim_parse_args().  But in debug mode (i.e. 'target sim'"
    },
    {
      "sha": "2ce989a897a1a8fd339cae5040279e3841cc0b77",
      "filename": "sim/m32r/sim-main.h",
      "status": "modified",
      "additions": 0,
      "deletions": 7,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/sim-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/sim-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/sim-main.h?ref=fe41f7211abb7d50c172588fa0d5e45feb067590",
      "patch": "@@ -56,11 +56,4 @@ extern SIM_CORE_SIGNAL_FN m32r_core_signal;\n m32r_core_signal ((SD), (CPU), (CIA), (MAP), (NR_BYTES), (ADDR), \\\n \t\t  (TRANSFER), (ERROR))\n \n-/* Default memory size.  */\n-#ifdef M32R_LINUX\n-#define M32R_DEFAULT_MEM_SIZE 0x2000000 /* 32M */\n-#else\n-#define M32R_DEFAULT_MEM_SIZE 0x800000 /* 8M */\n-#endif\n-\n #endif /* SIM_MAIN_H */"
    },
    {
      "sha": "4d86a0a4e3618ecd9aea0044d3c4a5d400479590",
      "filename": "sim/m32r/traps-linux.c",
      "status": "removed",
      "additions": 0,
      "deletions": 1326,
      "changes": 1326,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d4a0121347ad9890060709a2a7660e0ac58b4b84/sim/m32r/traps-linux.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d4a0121347ad9890060709a2a7660e0ac58b4b84/sim/m32r/traps-linux.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/traps-linux.c?ref=d4a0121347ad9890060709a2a7660e0ac58b4b84",
      "patch": "@@ -1,1326 +0,0 @@\n-/* m32r exception, interrupt, and trap (EIT) support\n-   Copyright (C) 1998-2021 Free Software Foundation, Inc.\n-   Contributed by Renesas.\n-\n-   This file is part of GDB, the GNU debugger.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-/* This must come before any other includes.  */\n-#include \"defs.h\"\n-\n-#include \"portability.h\"\n-#include \"sim-main.h\"\n-#include \"sim-signal.h\"\n-#include \"sim-syscall.h\"\n-#include \"sim/callback.h\"\n-#include \"syscall.h\"\n-#include \"targ-vals.h\"\n-#include <dirent.h>\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <stdlib.h>\n-#include <time.h>\n-#include <unistd.h>\n-#include <utime.h>\n-#include <sys/mman.h>\n-#include <sys/poll.h>\n-#include <sys/resource.h>\n-#include <sys/sysinfo.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/timeb.h>\n-#include <sys/timex.h>\n-#include <sys/types.h>\n-#include <sys/uio.h>\n-#include <sys/utsname.h>\n-#include <sys/vfs.h>\n-#include <linux/sysctl.h>\n-#include <linux/types.h>\n-#include <linux/unistd.h>\n-\n-#define TRAP_ELF_SYSCALL 0\n-#define TRAP_LINUX_SYSCALL 2\n-#define TRAP_FLUSH_CACHE 12\n-\n-/* The semantic code invokes this for invalid (unrecognized) instructions.  */\n-\n-SEM_PC\n-sim_engine_invalid_insn (SIM_CPU *current_cpu, IADDR cia, SEM_PC vpc)\n-{\n-  SIM_DESC sd = CPU_STATE (current_cpu);\n-\n-#if 0\n-  if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)\n-    {\n-      h_bsm_set (current_cpu, h_sm_get (current_cpu));\n-      h_bie_set (current_cpu, h_ie_get (current_cpu));\n-      h_bcond_set (current_cpu, h_cond_get (current_cpu));\n-      /* sm not changed */\n-      h_ie_set (current_cpu, 0);\n-      h_cond_set (current_cpu, 0);\n-\n-      h_bpc_set (current_cpu, cia);\n-\n-      sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,\n-\t\t\t  EIT_RSVD_INSN_ADDR);\n-    }\n-  else\n-#endif\n-    sim_engine_halt (sd, current_cpu, NULL, cia, sim_stopped, SIM_SIGILL);\n-  return vpc;\n-}\n-\n-/* Process an address exception.  */\n-\n-void\n-m32r_core_signal (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia,\n-\t\t  unsigned int map, int nr_bytes, address_word addr,\n-\t\t  transfer_type transfer, sim_core_signals sig)\n-{\n-  if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)\n-    {\n-      m32rbf_h_cr_set (current_cpu, H_CR_BBPC,\n-                       m32rbf_h_cr_get (current_cpu, H_CR_BPC));\n-      if (MACH_NUM (CPU_MACH (current_cpu)) == MACH_M32R)\n-        {\n-          m32rbf_h_bpsw_set (current_cpu, m32rbf_h_psw_get (current_cpu));\n-          /* sm not changed */\n-          m32rbf_h_psw_set (current_cpu, m32rbf_h_psw_get (current_cpu) & 0x80);\n-        }\n-      else if (MACH_NUM (CPU_MACH (current_cpu)) == MACH_M32RX)\n-        {\n-          m32rxf_h_bpsw_set (current_cpu, m32rxf_h_psw_get (current_cpu));\n-          /* sm not changed */\n-          m32rxf_h_psw_set (current_cpu, m32rxf_h_psw_get (current_cpu) & 0x80);\n-        }\n-      else\n-        {\n-          m32r2f_h_bpsw_set (current_cpu, m32r2f_h_psw_get (current_cpu));\n-          /* sm not changed */\n-          m32r2f_h_psw_set (current_cpu, m32r2f_h_psw_get (current_cpu) & 0x80);\n-        }\n-      m32rbf_h_cr_set (current_cpu, H_CR_BPC, cia);\n-\n-      sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,\n-                          EIT_ADDR_EXCP_ADDR);\n-    }\n-  else\n-    sim_core_signal (sd, current_cpu, cia, map, nr_bytes, addr,\n-                     transfer, sig);\n-}\n-\f\n-/* Translate target's address to host's address.  */\n-\n-static void *\n-t2h_addr (host_callback *cb, struct cb_syscall *sc,\n-          unsigned long taddr)\n-{\n-  void *addr;\n-  SIM_DESC sd = (SIM_DESC) sc->p1;\n-  SIM_CPU *cpu = (SIM_CPU *) sc->p2;\n-\n-  if (taddr == 0)\n-    return NULL;\n-\n-  return sim_core_trans_addr (sd, cpu, read_map, taddr);\n-}\n-\n-/* TODO: These functions are a big hack and assume that the host runtime has\n-   type sizes and struct layouts that match the target.  So the Linux emulation\n-   probaly only really works in 32-bit runtimes.  */\n-\n-static void\n-translate_endian_h2t (void *addr, size_t size)\n-{\n-  unsigned int *p = (unsigned int *) addr;\n-  int i;\n-\n-  for (i = 0; i <= size - 4; i += 4,p++)\n-    *p = H2T_4 (*p);\n-\n-  if (i <= size - 2)\n-    *((unsigned short *) p) = H2T_2 (*((unsigned short *) p));\n-}\n-\n-static void\n-translate_endian_t2h (void *addr, size_t size)\n-{\n-  unsigned int *p = (unsigned int *) addr;\n-  int i;\n-\n-  for (i = 0; i <= size - 4; i += 4,p++)\n-    *p = T2H_4 (*p);\n-\n-  if (i <= size - 2)\n-    *((unsigned short *) p) = T2H_2 (*((unsigned short *) p));\n-}\n-\n-/* Trap support.\n-   The result is the pc address to continue at.\n-   Preprocessing like saving the various registers has already been done.  */\n-\n-USI\n-m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n-{\n-  SIM_DESC sd = CPU_STATE (current_cpu);\n-  host_callback *cb = STATE_CALLBACK (sd);\n-\n-  switch (num)\n-    {\n-    case TRAP_ELF_SYSCALL :\n-      {\n-\tlong result, result2;\n-\tint errcode;\n-\n-\tsim_syscall_multi (current_cpu,\n-\t\t\t   m32rbf_h_gr_get (current_cpu, 0),\n-\t\t\t   m32rbf_h_gr_get (current_cpu, 1),\n-\t\t\t   m32rbf_h_gr_get (current_cpu, 2),\n-\t\t\t   m32rbf_h_gr_get (current_cpu, 3),\n-\t\t\t   m32rbf_h_gr_get (current_cpu, 4),\n-\t\t\t   &result, &result2, &errcode);\n-\n-\tm32rbf_h_gr_set (current_cpu, 2, errcode);\n-\tm32rbf_h_gr_set (current_cpu, 0, result);\n-\tm32rbf_h_gr_set (current_cpu, 1, result2);\n-\tbreak;\n-      }\n-\n-    case TRAP_LINUX_SYSCALL :\n-      {\n-\tCB_SYSCALL s;\n-        unsigned int func, arg1, arg2, arg3, arg4, arg5, arg6, arg7;\n-        int result, result2, errcode;\n-\n-\tif (STATE_ENVIRONMENT (sd) != USER_ENVIRONMENT)\n-\t  goto case_default;\n-\n-\tfunc = m32rbf_h_gr_get (current_cpu, 7);\n-\targ1 = m32rbf_h_gr_get (current_cpu, 0);\n-\targ2 = m32rbf_h_gr_get (current_cpu, 1);\n-\targ3 = m32rbf_h_gr_get (current_cpu, 2);\n-\targ4 = m32rbf_h_gr_get (current_cpu, 3);\n-\targ5 = m32rbf_h_gr_get (current_cpu, 4);\n-\targ6 = m32rbf_h_gr_get (current_cpu, 5);\n-\targ7 = m32rbf_h_gr_get (current_cpu, 6);\n-\n-        CB_SYSCALL_INIT (&s);\n-        s.func = func;\n-        s.arg1 = arg1;\n-        s.arg2 = arg2;\n-        s.arg3 = arg3;\n-        s.arg4 = arg4;\n-        s.arg5 = arg5;\n-        s.arg6 = arg6;\n-        s.arg7 = arg7;\n-\n-        s.p1 = (PTR) sd;\n-        s.p2 = (PTR) current_cpu;\n-        s.read_mem = sim_syscall_read_mem;\n-        s.write_mem = sim_syscall_write_mem;\n-\n-        result = 0;\n-        result2 = 0;\n-        errcode = 0;\n-\n-        switch (func)\n-          {\n-          case TARGET_LINUX_SYS_exit:\n-\t    sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, arg1);\n-            break;\n-\n-          case TARGET_LINUX_SYS_read:\n-            result = read(arg1, t2h_addr(cb, &s, arg2), arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_write:\n-            result = write(arg1, t2h_addr(cb, &s, arg2), arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_open:\n-            result = open((char *) t2h_addr(cb, &s, arg1), arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_close:\n-            result = close(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_creat:\n-            result = creat((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_link:\n-            result = link((char *) t2h_addr(cb, &s, arg1),\n-                          (char *) t2h_addr(cb, &s, arg2));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_unlink:\n-            result = unlink((char *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_chdir:\n-            result = chdir((char *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_time:\n-            {\n-              time_t t;\n-\n-              if (arg1 == 0)\n-                {\n-                  result = (int) time(NULL);\n-                  errcode = errno;\n-                }\n-              else\n-                {\n-                  result = (int) time(&t);\n-                  errcode = errno;\n-\n-                  if (result != 0)\n-                    break;\n-\n-                  t = H2T_4 (t);\n-                  if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t)) != sizeof(t))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_mknod:\n-            result = mknod((char *) t2h_addr(cb, &s, arg1),\n-                           (mode_t) arg2, (dev_t) arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_chmod:\n-            result = chmod((char *) t2h_addr(cb, &s, arg1), (mode_t) arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_lchown32:\n-          case TARGET_LINUX_SYS_lchown:\n-            result = lchown((char *) t2h_addr(cb, &s, arg1),\n-                            (uid_t) arg2, (gid_t) arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_lseek:\n-            result = (int) lseek(arg1, (off_t) arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getpid:\n-            result = getpid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getuid32:\n-          case TARGET_LINUX_SYS_getuid:\n-            result = getuid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_utime:\n-            {\n-              struct utimbuf buf;\n-\n-              if (arg2 == 0)\n-                {\n-                  result = utime((char *) t2h_addr(cb, &s, arg1), NULL);\n-                  errcode = errno;\n-                }\n-              else\n-                {\n-                  buf = *((struct utimbuf *) t2h_addr(cb, &s, arg2));\n-                  translate_endian_t2h (&buf, sizeof(buf));\n-                  result = utime((char *) t2h_addr(cb, &s, arg1), &buf);\n-                  errcode = errno;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_access:\n-            result = access((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_ftime:\n-            {\n-              struct timeb t;\n-\n-              result = ftime(&t);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              t.time = H2T_4 (t.time);\n-              t.millitm = H2T_2 (t.millitm);\n-              t.timezone = H2T_2 (t.timezone);\n-              t.dstflag = H2T_2 (t.dstflag);\n-              if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t))\n-                  != sizeof(t))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-\n-          case TARGET_LINUX_SYS_sync:\n-            sync();\n-            result = 0;\n-            break;\n-\n-          case TARGET_LINUX_SYS_rename:\n-            result = rename((char *) t2h_addr(cb, &s, arg1),\n-                            (char *) t2h_addr(cb, &s, arg2));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_mkdir:\n-            result = mkdir((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_rmdir:\n-            result = rmdir((char *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_dup:\n-            result = dup(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_brk:\n-            result = brk((void *) arg1);\n-            errcode = errno;\n-            //result = arg1;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getgid32:\n-          case TARGET_LINUX_SYS_getgid:\n-            result = getgid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_geteuid32:\n-          case TARGET_LINUX_SYS_geteuid:\n-            result = geteuid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getegid32:\n-          case TARGET_LINUX_SYS_getegid:\n-            result = getegid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_ioctl:\n-            result = ioctl(arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_fcntl:\n-            result = fcntl(arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_dup2:\n-            result = dup2(arg1, arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getppid:\n-            result = getppid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getpgrp:\n-            result = getpgrp();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getrlimit:\n-            {\n-              struct rlimit rlim;\n-\n-              result = getrlimit(arg1, &rlim);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&rlim, sizeof(rlim));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &rlim, sizeof(rlim))\n-                  != sizeof(rlim))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getrusage:\n-            {\n-              struct rusage usage;\n-\n-              result = getrusage(arg1, &usage);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&usage, sizeof(usage));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &usage, sizeof(usage))\n-                  != sizeof(usage))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_gettimeofday:\n-            {\n-              struct timeval tv;\n-              struct timezone tz;\n-              \n-              result = gettimeofday(&tv, &tz);\n-              errcode = errno;\n-              \n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&tv, sizeof(tv));\n-              if ((s.write_mem) (cb, &s, arg1, (char *) &tv, sizeof(tv))\n-                  != sizeof(tv))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-\n-              translate_endian_h2t (&tz, sizeof(tz));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &tz, sizeof(tz))\n-                  != sizeof(tz))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getgroups32:\n-          case TARGET_LINUX_SYS_getgroups:\n-            {\n-              gid_t *list;\n-\n-              if (arg1 > 0)\n-                list = (gid_t *) malloc(arg1 * sizeof(gid_t));\n-\n-              result = getgroups(arg1, list);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (list, arg1 * sizeof(gid_t));\n-              if (arg1 > 0)\n-                if ((s.write_mem) (cb, &s, arg2, (char *) list, arg1 * sizeof(gid_t))\n-                    != arg1 * sizeof(gid_t))\n-                  {\n-                    result = -1;\n-                     errcode = EINVAL;\n-                  }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_select:\n-            {\n-              int n;\n-              fd_set readfds;\n-              fd_set *treadfdsp;\n-              fd_set *hreadfdsp;\n-              fd_set writefds;\n-              fd_set *twritefdsp;\n-              fd_set *hwritefdsp;\n-              fd_set exceptfds;\n-              fd_set *texceptfdsp;\n-              fd_set *hexceptfdsp;\n-              struct timeval *ttimeoutp;\n-              struct timeval timeout;\n-              \n-              n = arg1;\n-\n-              treadfdsp = (fd_set *) arg2;\n-              if (treadfdsp != NULL)\n-                {\n-                  readfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) treadfdsp));\n-                  translate_endian_t2h (&readfds, sizeof(readfds));\n-                  hreadfdsp = &readfds;\n-                }\n-              else\n-                hreadfdsp = NULL;\n-              \n-              twritefdsp  = (fd_set *) arg3;\n-              if (twritefdsp != NULL)\n-                {\n-                  writefds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) twritefdsp));\n-                  translate_endian_t2h (&writefds, sizeof(writefds));\n-                  hwritefdsp = &writefds;\n-                }\n-              else\n-                hwritefdsp = NULL;\n-              \n-              texceptfdsp = (fd_set *) arg4;\n-              if (texceptfdsp != NULL)\n-                {\n-                  exceptfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) texceptfdsp));\n-                  translate_endian_t2h (&exceptfds, sizeof(exceptfds));\n-                  hexceptfdsp = &exceptfds;\n-                }\n-              else\n-                hexceptfdsp = NULL;\n-              \n-              ttimeoutp = (struct timeval *) arg5;\n-              timeout = *((struct timeval *) t2h_addr(cb, &s, (unsigned int) ttimeoutp));\n-              translate_endian_t2h (&timeout, sizeof(timeout));\n-\n-              result = select(n, hreadfdsp, hwritefdsp, hexceptfdsp, &timeout);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              if (treadfdsp != NULL)\n-                {\n-                  translate_endian_h2t (&readfds, sizeof(readfds));\n-                  if ((s.write_mem) (cb, &s, (unsigned long) treadfdsp,\n-                       (char *) &readfds, sizeof(readfds)) != sizeof(readfds))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-\n-              if (twritefdsp != NULL)\n-                {\n-                  translate_endian_h2t (&writefds, sizeof(writefds));\n-                  if ((s.write_mem) (cb, &s, (unsigned long) twritefdsp,\n-                       (char *) &writefds, sizeof(writefds)) != sizeof(writefds))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-\n-              if (texceptfdsp != NULL)\n-                {\n-                  translate_endian_h2t (&exceptfds, sizeof(exceptfds));\n-                  if ((s.write_mem) (cb, &s, (unsigned long) texceptfdsp,\n-                       (char *) &exceptfds, sizeof(exceptfds)) != sizeof(exceptfds))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-\n-              translate_endian_h2t (&timeout, sizeof(timeout));\n-              if ((s.write_mem) (cb, &s, (unsigned long) ttimeoutp,\n-                   (char *) &timeout, sizeof(timeout)) != sizeof(timeout))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_symlink:\n-            result = symlink((char *) t2h_addr(cb, &s, arg1),\n-                             (char *) t2h_addr(cb, &s, arg2));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_readlink:\n-            result = readlink((char *) t2h_addr(cb, &s, arg1),\n-                              (char *) t2h_addr(cb, &s, arg2),\n-                              arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_readdir:\n-            result = (int) readdir((DIR *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-#if 0\n-          case TARGET_LINUX_SYS_mmap:\n-            {\n-              result = (int) mmap((void *) t2h_addr(cb, &s, arg1),\n-                                  arg2, arg3, arg4, arg5, arg6);\n-              errcode = errno;\n-\n-              if (errno == 0)\n-                {\n-                  sim_core_attach (sd, NULL,\n-                                   0, access_read_write_exec, 0,\n-                                   result, arg2, 0, NULL, NULL);\n-                }\n-            }\n-            break;\n-#endif\n-          case TARGET_LINUX_SYS_mmap2:\n-            {\n-              void *addr;\n-              size_t len;\n-              int prot, flags, fildes;\n-              off_t off;\n-              \n-              addr   = (void *)  t2h_addr(cb, &s, arg1);\n-              len    = arg2;\n-              prot   = arg3;\n-              flags  = arg4;\n-              fildes = arg5;\n-              off    = arg6 << 12;\n-\n-\t      result = (int) mmap(addr, len, prot, flags, fildes, off);\n-              errcode = errno;\n-              if (result != -1)\n-                {\n-                  char c;\n-\t\t  if (sim_core_read_buffer (sd, NULL, read_map, &c, result, 1) == 0)\n-                    sim_core_attach (sd, NULL,\n-                                     0, access_read_write_exec, 0,\n-                                     result, len, 0, NULL, NULL);\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_mmap:\n-            {\n-              void *addr;\n-              size_t len;\n-              int prot, flags, fildes;\n-              off_t off;\n-              \n-              addr   = *((void **)  t2h_addr(cb, &s, arg1));\n-              len    = *((size_t *) t2h_addr(cb, &s, arg1 + 4));\n-              prot   = *((int *)    t2h_addr(cb, &s, arg1 + 8));\n-              flags  = *((int *)    t2h_addr(cb, &s, arg1 + 12));\n-              fildes = *((int *)    t2h_addr(cb, &s, arg1 + 16));\n-              off    = *((off_t *)  t2h_addr(cb, &s, arg1 + 20));\n-\n-              addr   = (void *) T2H_4 ((unsigned int) addr);\n-              len    = T2H_4 (len);\n-              prot   = T2H_4 (prot);\n-              flags  = T2H_4 (flags);\n-              fildes = T2H_4 (fildes);\n-              off    = T2H_4 (off);\n-\n-              //addr   = (void *) t2h_addr(cb, &s, (unsigned int) addr);\n-              result = (int) mmap(addr, len, prot, flags, fildes, off);\n-              errcode = errno;\n-\n-              //if (errno == 0)\n-              if (result != -1)\n-                {\n-                  char c;\n-\t\t  if (sim_core_read_buffer (sd, NULL, read_map, &c, result, 1) == 0)\n-                    sim_core_attach (sd, NULL,\n-                                     0, access_read_write_exec, 0,\n-                                     result, len, 0, NULL, NULL);\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_munmap:\n-            {\n-            result = munmap((void *)arg1, arg2);\n-            errcode = errno;\n-            if (result != -1)\n-              {\n-                sim_core_detach (sd, NULL, 0, arg2, result);\n-              }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_truncate:\n-            result = truncate((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_ftruncate:\n-            result = ftruncate(arg1, arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_fchmod:\n-            result = fchmod(arg1, arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_fchown32:\n-          case TARGET_LINUX_SYS_fchown:\n-            result = fchown(arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_statfs:\n-            {\n-              struct statfs statbuf;\n-\n-              result = statfs((char *) t2h_addr(cb, &s, arg1), &statbuf);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&statbuf, sizeof(statbuf));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n-                  != sizeof(statbuf))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_fstatfs:\n-            {\n-              struct statfs statbuf;\n-\n-              result = fstatfs(arg1, &statbuf);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&statbuf, sizeof(statbuf));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n-                  != sizeof(statbuf))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_syslog:\n-            result = syslog(arg1, (char *) t2h_addr(cb, &s, arg2));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_setitimer:\n-            {\n-              struct itimerval value, ovalue;\n-\n-              value = *((struct itimerval *) t2h_addr(cb, &s, arg2));\n-              translate_endian_t2h (&value, sizeof(value));\n-\n-              if (arg2 == 0)\n-                {\n-                  result = setitimer(arg1, &value, NULL);\n-                  errcode = errno;\n-                }\n-              else\n-                {\n-                  result = setitimer(arg1, &value, &ovalue);\n-                  errcode = errno;\n-\n-                  if (result != 0)\n-                    break;\n-\n-                  translate_endian_h2t (&ovalue, sizeof(ovalue));\n-                  if ((s.write_mem) (cb, &s, arg3, (char *) &ovalue, sizeof(ovalue))\n-                      != sizeof(ovalue))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getitimer:\n-            {\n-              struct itimerval value;\n-\n-              result = getitimer(arg1, &value);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&value, sizeof(value));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &value, sizeof(value))\n-                  != sizeof(value))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_stat:\n-            {\n-              char *buf;\n-              int buflen;\n-              struct stat statbuf;\n-\n-              result = stat((char *) t2h_addr(cb, &s, arg1), &statbuf);\n-              errcode = errno;\n-              if (result < 0)\n-                break;\n-\n-              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n-              buf = xmalloc (buflen);\n-              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n-                {\n-                  /* The translation failed.  This is due to an internal\n-                     host program error, not the target's fault.  */\n-                  free (buf);\n-                  result = -1;\n-                  errcode = ENOSYS;\n-                  break;\n-                }\n-              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n-                {\n-                  free (buf);\n-                  result = -1;\n-                  errcode = EINVAL;\n-                  break;\n-                }\n-              free (buf);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_lstat:\n-            {\n-              char *buf;\n-              int buflen;\n-              struct stat statbuf;\n-\n-              result = lstat((char *) t2h_addr(cb, &s, arg1), &statbuf);\n-              errcode = errno;\n-              if (result < 0)\n-                break;\n-\n-              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n-              buf = xmalloc (buflen);\n-              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n-                {\n-                  /* The translation failed.  This is due to an internal\n-                     host program error, not the target's fault.  */\n-                  free (buf);\n-                  result = -1;\n-                  errcode = ENOSYS;\n-                  break;\n-                }\n-              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n-                {\n-                  free (buf);\n-                  result = -1;\n-                  errcode = EINVAL;\n-                  break;\n-                }\n-              free (buf);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_fstat:\n-            {\n-              char *buf;\n-              int buflen;\n-              struct stat statbuf;\n-\n-              result = fstat(arg1, &statbuf);\n-              errcode = errno;\n-              if (result < 0)\n-                break;\n-\n-              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n-              buf = xmalloc (buflen);\n-              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n-                {\n-                  /* The translation failed.  This is due to an internal\n-                     host program error, not the target's fault.  */\n-                  free (buf);\n-                  result = -1;\n-                  errcode = ENOSYS;\n-                  break;\n-                }\n-              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n-                {\n-                  free (buf);\n-                  result = -1;\n-                  errcode = EINVAL;\n-                  break;\n-                }\n-              free (buf);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_sysinfo:\n-            {\n-              struct sysinfo info;\n-\n-              result = sysinfo(&info);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              info.uptime    = H2T_4 (info.uptime);\n-              info.loads[0]  = H2T_4 (info.loads[0]);\n-              info.loads[1]  = H2T_4 (info.loads[1]);\n-              info.loads[2]  = H2T_4 (info.loads[2]);\n-              info.totalram  = H2T_4 (info.totalram);\n-              info.freeram   = H2T_4 (info.freeram);\n-              info.sharedram = H2T_4 (info.sharedram);\n-              info.bufferram = H2T_4 (info.bufferram);\n-              info.totalswap = H2T_4 (info.totalswap);\n-              info.freeswap  = H2T_4 (info.freeswap);\n-              info.procs     = H2T_2 (info.procs);\n-#if LINUX_VERSION_CODE >= 0x20400\n-              info.totalhigh = H2T_4 (info.totalhigh);\n-              info.freehigh  = H2T_4 (info.freehigh);\n-              info.mem_unit  = H2T_4 (info.mem_unit);\n-#endif\n-              if ((s.write_mem) (cb, &s, arg1, (char *) &info, sizeof(info))\n-                  != sizeof(info))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-#if 0\n-          case TARGET_LINUX_SYS_ipc:\n-            {\n-              result = ipc(arg1, arg2, arg3, arg4,\n-                           (void *) t2h_addr(cb, &s, arg5), arg6);\n-              errcode = errno;\n-            }\n-            break;\n-#endif\n-\n-          case TARGET_LINUX_SYS_fsync:\n-            result = fsync(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_uname:\n-            /* utsname contains only arrays of char, so it is not necessary\n-               to translate endian. */\n-            result = uname((struct utsname *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_adjtimex:\n-            {\n-              struct timex buf;\n-\n-              result = adjtimex(&buf);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&buf, sizeof(buf));\n-              if ((s.write_mem) (cb, &s, arg1, (char *) &buf, sizeof(buf))\n-                  != sizeof(buf))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_mprotect:\n-            result = mprotect((void *) arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_fchdir:\n-            result = fchdir(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_setfsuid32:\n-          case TARGET_LINUX_SYS_setfsuid:\n-            result = setfsuid(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_setfsgid32:\n-          case TARGET_LINUX_SYS_setfsgid:\n-            result = setfsgid(arg1);\n-            errcode = errno;\n-            break;\n-\n-#if 0\n-          case TARGET_LINUX_SYS__llseek:\n-            {\n-              loff_t buf;\n-\n-              result = _llseek(arg1, arg2, arg3, &buf, arg5);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&buf, sizeof(buf));\n-              if ((s.write_mem) (cb, &s, t2h_addr(cb, &s, arg4),\n-                                 (char *) &buf, sizeof(buf)) != sizeof(buf))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getdents:\n-            {\n-              struct dirent dir;\n-\n-              result = getdents(arg1, &dir, arg3);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              dir.d_ino = H2T_4 (dir.d_ino);\n-              dir.d_off = H2T_4 (dir.d_off);\n-              dir.d_reclen = H2T_2 (dir.d_reclen);\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &dir, sizeof(dir))\n-                  != sizeof(dir))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-#endif\n-\n-          case TARGET_LINUX_SYS_flock:\n-            result = flock(arg1, arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_msync:\n-            result = msync((void *) arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_readv:\n-            {\n-              struct iovec vector;\n-\n-              vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n-              translate_endian_t2h (&vector, sizeof(vector));\n-\n-              result = readv(arg1, &vector, arg3);\n-              errcode = errno;\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_writev:\n-            {\n-              struct iovec vector;\n-\n-              vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n-              translate_endian_t2h (&vector, sizeof(vector));\n-\n-              result = writev(arg1, &vector, arg3);\n-              errcode = errno;\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_fdatasync:\n-            result = fdatasync(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_mlock:\n-            result = mlock((void *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_munlock:\n-            result = munlock((void *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_nanosleep:\n-            {\n-              struct timespec req, rem;\n-\n-              req = *((struct timespec *) t2h_addr(cb, &s, arg2));\n-              translate_endian_t2h (&req, sizeof(req));\n-\n-              result = nanosleep(&req, &rem);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&rem, sizeof(rem));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &rem, sizeof(rem))\n-                  != sizeof(rem))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_mremap: /* FIXME */\n-            result = (int) mremap((void *) t2h_addr(cb, &s, arg1), arg2, arg3, arg4); \n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getresuid32:\n-          case TARGET_LINUX_SYS_getresuid:\n-            {\n-              uid_t ruid, euid, suid;\n-\n-              result = getresuid(&ruid, &euid, &suid);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              *((uid_t *) t2h_addr(cb, &s, arg1)) = H2T_4 (ruid);\n-              *((uid_t *) t2h_addr(cb, &s, arg2)) = H2T_4 (euid);\n-              *((uid_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (suid);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_poll:\n-            {\n-              struct pollfd ufds;\n-\n-              ufds = *((struct pollfd *) t2h_addr(cb, &s, arg1));\n-              ufds.fd = T2H_4 (ufds.fd);\n-              ufds.events = T2H_2 (ufds.events);\n-              ufds.revents = T2H_2 (ufds.revents);\n-\n-              result = poll(&ufds, arg2, arg3);\n-              errcode = errno;\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getresgid32:\n-          case TARGET_LINUX_SYS_getresgid:\n-            {\n-              uid_t rgid, egid, sgid;\n-\n-              result = getresgid(&rgid, &egid, &sgid);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              *((uid_t *) t2h_addr(cb, &s, arg1)) = H2T_4 (rgid);\n-              *((uid_t *) t2h_addr(cb, &s, arg2)) = H2T_4 (egid);\n-              *((uid_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (sgid);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_pread:\n-            result =  pread(arg1, (void *) t2h_addr(cb, &s, arg2), arg3, arg4); \n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_pwrite:\n-            result =  pwrite(arg1, (void *) t2h_addr(cb, &s, arg2), arg3, arg4); \n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_chown32:\n-          case TARGET_LINUX_SYS_chown:\n-            result = chown((char *) t2h_addr(cb, &s, arg1), arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getcwd:\n-            result = (int) getcwd((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_sendfile:\n-            {\n-              off_t offset;\n-\n-              offset = *((off_t *) t2h_addr(cb, &s, arg3));\n-              offset = T2H_4 (offset);\n-\n-              result = sendfile(arg1, arg2, &offset, arg3);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              *((off_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (offset);\n-            }\n-            break;\n-\n-          default:\n-            result = -1;\n-            errcode = ENOSYS;\n-            break;\n-          }\n-        \n-        if (result == -1)\n-\t  m32rbf_h_gr_set (current_cpu, 0, -errcode);\n-        else\n-\t  m32rbf_h_gr_set (current_cpu, 0, result);\n-\tbreak;\n-      }\n-\n-    case TRAP_BREAKPOINT:\n-      sim_engine_halt (sd, current_cpu, NULL, pc,\n-\t\t       sim_stopped, SIM_SIGTRAP);\n-      break;\n-\n-    case TRAP_FLUSH_CACHE:\n-      /* Do nothing.  */\n-      break;\n-\n-    case_default:\n-    default :\n-      {\n-\t/* Use cr5 as EVB (EIT Vector Base) register.  */\n-        USI new_pc = m32rbf_h_cr_get (current_cpu, 5) + 0x40 + num * 4;\n-\treturn new_pc;\n-      }\n-    }\n-\n-  /* Fake an \"rte\" insn.  */\n-  /* FIXME: Should duplicate all of rte processing.  */\n-  return (pc & -4) + 4;\n-}"
    },
    {
      "sha": "c4c1224ad276812af2de07986fcdd0f85e9d6d47",
      "filename": "sim/m32r/traps.c",
      "status": "modified",
      "additions": 1185,
      "deletions": 14,
      "changes": 1199,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/traps.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe41f7211abb7d50c172588fa0d5e45feb067590/sim/m32r/traps.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/traps.c?ref=fe41f7211abb7d50c172588fa0d5e45feb067590",
      "patch": "@@ -1,6 +1,6 @@\n /* m32r exception, interrupt, and trap (EIT) support\n    Copyright (C) 1998-2021 Free Software Foundation, Inc.\n-   Contributed by Cygnus Solutions.\n+   Contributed by Cygnus Solutions & Renesas.\n \n    This file is part of GDB, the GNU debugger.\n \n@@ -20,12 +20,37 @@\n /* This must come before any other includes.  */\n #include \"defs.h\"\n \n+#include \"portability.h\"\n #include \"sim-main.h\"\n #include \"sim-signal.h\"\n #include \"sim-syscall.h\"\n+#include \"sim/callback.h\"\n+#include \"syscall.h\"\n #include \"targ-vals.h\"\n+#include <dirent.h>\n+#include <errno.h>\n+#include <fcntl.h>\n #include <stdlib.h>\n+#include <time.h>\n+#include <unistd.h>\n+#include <utime.h>\n+#include <sys/mman.h>\n+#include <sys/poll.h>\n+#include <sys/resource.h>\n+#include <sys/sysinfo.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/timeb.h>\n+#include <sys/timex.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <sys/utsname.h>\n+#include <sys/vfs.h>\n+#include <linux/sysctl.h>\n+#include <linux/types.h>\n+#include <linux/unistd.h>\n \n+#define TRAP_LINUX_SYSCALL 2\n #define TRAP_FLUSH_CACHE 12\n /* The semantic code invokes this for invalid (unrecognized) instructions.  */\n \n@@ -87,7 +112,7 @@ m32r_core_signal (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia,\n \tdefault:\n \t  abort ();\n \t}\n-\t    \n+\n       m32rbf_h_cr_set (current_cpu, H_CR_BPC, cia);\n \n       sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,\n@@ -98,6 +123,52 @@ m32r_core_signal (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia,\n \t\t     transfer, sig);\n }\n \f\n+/* Translate target's address to host's address.  */\n+\n+static void *\n+t2h_addr (host_callback *cb, struct cb_syscall *sc,\n+\t  unsigned long taddr)\n+{\n+  void *addr;\n+  SIM_DESC sd = (SIM_DESC) sc->p1;\n+  SIM_CPU *cpu = (SIM_CPU *) sc->p2;\n+\n+  if (taddr == 0)\n+    return NULL;\n+\n+  return sim_core_trans_addr (sd, cpu, read_map, taddr);\n+}\n+\n+/* TODO: These functions are a big hack and assume that the host runtime has\n+   type sizes and struct layouts that match the target.  So the Linux emulation\n+   probaly only really works in 32-bit runtimes.  */\n+\n+static void\n+translate_endian_h2t (void *addr, size_t size)\n+{\n+  unsigned int *p = (unsigned int *) addr;\n+  int i;\n+\n+  for (i = 0; i <= size - 4; i += 4,p++)\n+    *p = H2T_4 (*p);\n+\n+  if (i <= size - 2)\n+    *((unsigned short *) p) = H2T_2 (*((unsigned short *) p));\n+}\n+\n+static void\n+translate_endian_t2h (void *addr, size_t size)\n+{\n+  unsigned int *p = (unsigned int *) addr;\n+  int i;\n+\n+  for (i = 0; i <= size - 4; i += 4,p++)\n+    *p = T2H_4 (*p);\n+\n+  if (i <= size - 2)\n+    *((unsigned short *) p) = T2H_2 (*((unsigned short *) p));\n+}\n+\n /* Trap support.\n    The result is the pc address to continue at.\n    Preprocessing like saving the various registers has already been done.  */\n@@ -109,18 +180,11 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n   host_callback *cb = STATE_CALLBACK (sd);\n \n   if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)\n-    {\n-      /* The new pc is the trap vector entry.\n-\t We assume there's a branch there to some handler.\n-         Use cr5 as EVB (EIT Vector Base) register.  */\n-      /* USI new_pc = EIT_TRAP_BASE_ADDR + num * 4; */\n-      USI new_pc = m32rbf_h_cr_get (current_cpu, 5) + 0x40 + num * 4;\n-      return new_pc;\n-    }\n+    goto case_default;\n \n   switch (num)\n     {\n-    case TRAP_SYSCALL :\n+    case TRAP_SYSCALL:\n       {\n \tlong result, result2;\n \tint errcode;\n@@ -139,6 +203,1110 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n \tbreak;\n       }\n \n+    case TRAP_LINUX_SYSCALL:\n+      {\n+\tCB_SYSCALL s;\n+        unsigned int func, arg1, arg2, arg3, arg4, arg5, arg6, arg7;\n+        int result, result2, errcode;\n+\n+\tif (STATE_ENVIRONMENT (sd) != USER_ENVIRONMENT)\n+\t  goto case_default;\n+\n+\tfunc = m32rbf_h_gr_get (current_cpu, 7);\n+\targ1 = m32rbf_h_gr_get (current_cpu, 0);\n+\targ2 = m32rbf_h_gr_get (current_cpu, 1);\n+\targ3 = m32rbf_h_gr_get (current_cpu, 2);\n+\targ4 = m32rbf_h_gr_get (current_cpu, 3);\n+\targ5 = m32rbf_h_gr_get (current_cpu, 4);\n+\targ6 = m32rbf_h_gr_get (current_cpu, 5);\n+\targ7 = m32rbf_h_gr_get (current_cpu, 6);\n+\n+        CB_SYSCALL_INIT (&s);\n+        s.func = func;\n+        s.arg1 = arg1;\n+        s.arg2 = arg2;\n+        s.arg3 = arg3;\n+        s.arg4 = arg4;\n+        s.arg5 = arg5;\n+        s.arg6 = arg6;\n+        s.arg7 = arg7;\n+\n+        s.p1 = (PTR) sd;\n+        s.p2 = (PTR) current_cpu;\n+        s.read_mem = sim_syscall_read_mem;\n+        s.write_mem = sim_syscall_write_mem;\n+\n+        result = 0;\n+        result2 = 0;\n+        errcode = 0;\n+\n+        switch (func)\n+          {\n+          case TARGET_LINUX_SYS_exit:\n+\t    sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, arg1);\n+            break;\n+\n+          case TARGET_LINUX_SYS_read:\n+            result = read(arg1, t2h_addr(cb, &s, arg2), arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_write:\n+            result = write(arg1, t2h_addr(cb, &s, arg2), arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_open:\n+            result = open((char *) t2h_addr(cb, &s, arg1), arg2, arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_close:\n+            result = close(arg1);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_creat:\n+            result = creat((char *) t2h_addr(cb, &s, arg1), arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_link:\n+            result = link((char *) t2h_addr(cb, &s, arg1),\n+                          (char *) t2h_addr(cb, &s, arg2));\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_unlink:\n+            result = unlink((char *) t2h_addr(cb, &s, arg1));\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_chdir:\n+            result = chdir((char *) t2h_addr(cb, &s, arg1));\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_time:\n+            {\n+              time_t t;\n+\n+              if (arg1 == 0)\n+                {\n+                  result = (int) time(NULL);\n+                  errcode = errno;\n+                }\n+              else\n+                {\n+                  result = (int) time(&t);\n+                  errcode = errno;\n+\n+                  if (result != 0)\n+                    break;\n+\n+                  t = H2T_4 (t);\n+                  if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t)) != sizeof(t))\n+                    {\n+                      result = -1;\n+                      errcode = EINVAL;\n+                    }\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_mknod:\n+            result = mknod((char *) t2h_addr(cb, &s, arg1),\n+                           (mode_t) arg2, (dev_t) arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_chmod:\n+            result = chmod((char *) t2h_addr(cb, &s, arg1), (mode_t) arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_lchown32:\n+          case TARGET_LINUX_SYS_lchown:\n+            result = lchown((char *) t2h_addr(cb, &s, arg1),\n+                            (uid_t) arg2, (gid_t) arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_lseek:\n+            result = (int) lseek(arg1, (off_t) arg2, arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getpid:\n+            result = getpid();\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getuid32:\n+          case TARGET_LINUX_SYS_getuid:\n+            result = getuid();\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_utime:\n+            {\n+              struct utimbuf buf;\n+\n+              if (arg2 == 0)\n+                {\n+                  result = utime((char *) t2h_addr(cb, &s, arg1), NULL);\n+                  errcode = errno;\n+                }\n+              else\n+                {\n+                  buf = *((struct utimbuf *) t2h_addr(cb, &s, arg2));\n+                  translate_endian_t2h (&buf, sizeof(buf));\n+                  result = utime((char *) t2h_addr(cb, &s, arg1), &buf);\n+                  errcode = errno;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_access:\n+            result = access((char *) t2h_addr(cb, &s, arg1), arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_ftime:\n+            {\n+              struct timeb t;\n+\n+              result = ftime(&t);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              t.time = H2T_4 (t.time);\n+              t.millitm = H2T_2 (t.millitm);\n+              t.timezone = H2T_2 (t.timezone);\n+              t.dstflag = H2T_2 (t.dstflag);\n+              if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t))\n+                  != sizeof(t))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+\n+          case TARGET_LINUX_SYS_sync:\n+            sync();\n+            result = 0;\n+            break;\n+\n+          case TARGET_LINUX_SYS_rename:\n+            result = rename((char *) t2h_addr(cb, &s, arg1),\n+                            (char *) t2h_addr(cb, &s, arg2));\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_mkdir:\n+            result = mkdir((char *) t2h_addr(cb, &s, arg1), arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_rmdir:\n+            result = rmdir((char *) t2h_addr(cb, &s, arg1));\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_dup:\n+            result = dup(arg1);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_brk:\n+            result = brk((void *) arg1);\n+            errcode = errno;\n+            //result = arg1;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getgid32:\n+          case TARGET_LINUX_SYS_getgid:\n+            result = getgid();\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_geteuid32:\n+          case TARGET_LINUX_SYS_geteuid:\n+            result = geteuid();\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getegid32:\n+          case TARGET_LINUX_SYS_getegid:\n+            result = getegid();\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_ioctl:\n+            result = ioctl(arg1, arg2, arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_fcntl:\n+            result = fcntl(arg1, arg2, arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_dup2:\n+            result = dup2(arg1, arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getppid:\n+            result = getppid();\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getpgrp:\n+            result = getpgrp();\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getrlimit:\n+            {\n+              struct rlimit rlim;\n+\n+              result = getrlimit(arg1, &rlim);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&rlim, sizeof(rlim));\n+              if ((s.write_mem) (cb, &s, arg2, (char *) &rlim, sizeof(rlim))\n+                  != sizeof(rlim))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_getrusage:\n+            {\n+              struct rusage usage;\n+\n+              result = getrusage(arg1, &usage);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&usage, sizeof(usage));\n+              if ((s.write_mem) (cb, &s, arg2, (char *) &usage, sizeof(usage))\n+                  != sizeof(usage))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_gettimeofday:\n+            {\n+              struct timeval tv;\n+              struct timezone tz;\n+              \n+              result = gettimeofday(&tv, &tz);\n+              errcode = errno;\n+              \n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&tv, sizeof(tv));\n+              if ((s.write_mem) (cb, &s, arg1, (char *) &tv, sizeof(tv))\n+                  != sizeof(tv))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+\n+              translate_endian_h2t (&tz, sizeof(tz));\n+              if ((s.write_mem) (cb, &s, arg2, (char *) &tz, sizeof(tz))\n+                  != sizeof(tz))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_getgroups32:\n+          case TARGET_LINUX_SYS_getgroups:\n+            {\n+              gid_t *list;\n+\n+              if (arg1 > 0)\n+                list = (gid_t *) malloc(arg1 * sizeof(gid_t));\n+\n+              result = getgroups(arg1, list);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (list, arg1 * sizeof(gid_t));\n+              if (arg1 > 0)\n+                if ((s.write_mem) (cb, &s, arg2, (char *) list, arg1 * sizeof(gid_t))\n+                    != arg1 * sizeof(gid_t))\n+                  {\n+                    result = -1;\n+                     errcode = EINVAL;\n+                  }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_select:\n+            {\n+              int n;\n+              fd_set readfds;\n+              fd_set *treadfdsp;\n+              fd_set *hreadfdsp;\n+              fd_set writefds;\n+              fd_set *twritefdsp;\n+              fd_set *hwritefdsp;\n+              fd_set exceptfds;\n+              fd_set *texceptfdsp;\n+              fd_set *hexceptfdsp;\n+              struct timeval *ttimeoutp;\n+              struct timeval timeout;\n+              \n+              n = arg1;\n+\n+              treadfdsp = (fd_set *) arg2;\n+              if (treadfdsp != NULL)\n+                {\n+                  readfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) treadfdsp));\n+                  translate_endian_t2h (&readfds, sizeof(readfds));\n+                  hreadfdsp = &readfds;\n+                }\n+              else\n+                hreadfdsp = NULL;\n+              \n+              twritefdsp  = (fd_set *) arg3;\n+              if (twritefdsp != NULL)\n+                {\n+                  writefds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) twritefdsp));\n+                  translate_endian_t2h (&writefds, sizeof(writefds));\n+                  hwritefdsp = &writefds;\n+                }\n+              else\n+                hwritefdsp = NULL;\n+              \n+              texceptfdsp = (fd_set *) arg4;\n+              if (texceptfdsp != NULL)\n+                {\n+                  exceptfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) texceptfdsp));\n+                  translate_endian_t2h (&exceptfds, sizeof(exceptfds));\n+                  hexceptfdsp = &exceptfds;\n+                }\n+              else\n+                hexceptfdsp = NULL;\n+              \n+              ttimeoutp = (struct timeval *) arg5;\n+              timeout = *((struct timeval *) t2h_addr(cb, &s, (unsigned int) ttimeoutp));\n+              translate_endian_t2h (&timeout, sizeof(timeout));\n+\n+              result = select(n, hreadfdsp, hwritefdsp, hexceptfdsp, &timeout);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              if (treadfdsp != NULL)\n+                {\n+                  translate_endian_h2t (&readfds, sizeof(readfds));\n+                  if ((s.write_mem) (cb, &s, (unsigned long) treadfdsp,\n+                       (char *) &readfds, sizeof(readfds)) != sizeof(readfds))\n+                    {\n+                      result = -1;\n+                      errcode = EINVAL;\n+                    }\n+                }\n+\n+              if (twritefdsp != NULL)\n+                {\n+                  translate_endian_h2t (&writefds, sizeof(writefds));\n+                  if ((s.write_mem) (cb, &s, (unsigned long) twritefdsp,\n+                       (char *) &writefds, sizeof(writefds)) != sizeof(writefds))\n+                    {\n+                      result = -1;\n+                      errcode = EINVAL;\n+                    }\n+                }\n+\n+              if (texceptfdsp != NULL)\n+                {\n+                  translate_endian_h2t (&exceptfds, sizeof(exceptfds));\n+                  if ((s.write_mem) (cb, &s, (unsigned long) texceptfdsp,\n+                       (char *) &exceptfds, sizeof(exceptfds)) != sizeof(exceptfds))\n+                    {\n+                      result = -1;\n+                      errcode = EINVAL;\n+                    }\n+                }\n+\n+              translate_endian_h2t (&timeout, sizeof(timeout));\n+              if ((s.write_mem) (cb, &s, (unsigned long) ttimeoutp,\n+                   (char *) &timeout, sizeof(timeout)) != sizeof(timeout))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_symlink:\n+            result = symlink((char *) t2h_addr(cb, &s, arg1),\n+                             (char *) t2h_addr(cb, &s, arg2));\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_readlink:\n+            result = readlink((char *) t2h_addr(cb, &s, arg1),\n+                              (char *) t2h_addr(cb, &s, arg2),\n+                              arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_readdir:\n+            result = (int) readdir((DIR *) t2h_addr(cb, &s, arg1));\n+            errcode = errno;\n+            break;\n+\n+#if 0\n+          case TARGET_LINUX_SYS_mmap:\n+            {\n+              result = (int) mmap((void *) t2h_addr(cb, &s, arg1),\n+                                  arg2, arg3, arg4, arg5, arg6);\n+              errcode = errno;\n+\n+              if (errno == 0)\n+                {\n+                  sim_core_attach (sd, NULL,\n+                                   0, access_read_write_exec, 0,\n+                                   result, arg2, 0, NULL, NULL);\n+                }\n+            }\n+            break;\n+#endif\n+          case TARGET_LINUX_SYS_mmap2:\n+            {\n+              void *addr;\n+              size_t len;\n+              int prot, flags, fildes;\n+              off_t off;\n+              \n+              addr   = (void *)  t2h_addr(cb, &s, arg1);\n+              len    = arg2;\n+              prot   = arg3;\n+              flags  = arg4;\n+              fildes = arg5;\n+              off    = arg6 << 12;\n+\n+\t      result = (int) mmap(addr, len, prot, flags, fildes, off);\n+              errcode = errno;\n+              if (result != -1)\n+                {\n+                  char c;\n+\t\t  if (sim_core_read_buffer (sd, NULL, read_map, &c, result, 1) == 0)\n+                    sim_core_attach (sd, NULL,\n+                                     0, access_read_write_exec, 0,\n+                                     result, len, 0, NULL, NULL);\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_mmap:\n+            {\n+              void *addr;\n+              size_t len;\n+              int prot, flags, fildes;\n+              off_t off;\n+              \n+              addr   = *((void **)  t2h_addr(cb, &s, arg1));\n+              len    = *((size_t *) t2h_addr(cb, &s, arg1 + 4));\n+              prot   = *((int *)    t2h_addr(cb, &s, arg1 + 8));\n+              flags  = *((int *)    t2h_addr(cb, &s, arg1 + 12));\n+              fildes = *((int *)    t2h_addr(cb, &s, arg1 + 16));\n+              off    = *((off_t *)  t2h_addr(cb, &s, arg1 + 20));\n+\n+              addr   = (void *) T2H_4 ((unsigned int) addr);\n+              len    = T2H_4 (len);\n+              prot   = T2H_4 (prot);\n+              flags  = T2H_4 (flags);\n+              fildes = T2H_4 (fildes);\n+              off    = T2H_4 (off);\n+\n+              //addr   = (void *) t2h_addr(cb, &s, (unsigned int) addr);\n+              result = (int) mmap(addr, len, prot, flags, fildes, off);\n+              errcode = errno;\n+\n+              //if (errno == 0)\n+              if (result != -1)\n+                {\n+                  char c;\n+\t\t  if (sim_core_read_buffer (sd, NULL, read_map, &c, result, 1) == 0)\n+                    sim_core_attach (sd, NULL,\n+                                     0, access_read_write_exec, 0,\n+                                     result, len, 0, NULL, NULL);\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_munmap:\n+            {\n+            result = munmap((void *)arg1, arg2);\n+            errcode = errno;\n+            if (result != -1)\n+              {\n+                sim_core_detach (sd, NULL, 0, arg2, result);\n+              }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_truncate:\n+            result = truncate((char *) t2h_addr(cb, &s, arg1), arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_ftruncate:\n+            result = ftruncate(arg1, arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_fchmod:\n+            result = fchmod(arg1, arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_fchown32:\n+          case TARGET_LINUX_SYS_fchown:\n+            result = fchown(arg1, arg2, arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_statfs:\n+            {\n+              struct statfs statbuf;\n+\n+              result = statfs((char *) t2h_addr(cb, &s, arg1), &statbuf);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&statbuf, sizeof(statbuf));\n+              if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n+                  != sizeof(statbuf))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_fstatfs:\n+            {\n+              struct statfs statbuf;\n+\n+              result = fstatfs(arg1, &statbuf);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&statbuf, sizeof(statbuf));\n+              if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n+                  != sizeof(statbuf))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_syslog:\n+            result = syslog(arg1, (char *) t2h_addr(cb, &s, arg2));\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_setitimer:\n+            {\n+              struct itimerval value, ovalue;\n+\n+              value = *((struct itimerval *) t2h_addr(cb, &s, arg2));\n+              translate_endian_t2h (&value, sizeof(value));\n+\n+              if (arg2 == 0)\n+                {\n+                  result = setitimer(arg1, &value, NULL);\n+                  errcode = errno;\n+                }\n+              else\n+                {\n+                  result = setitimer(arg1, &value, &ovalue);\n+                  errcode = errno;\n+\n+                  if (result != 0)\n+                    break;\n+\n+                  translate_endian_h2t (&ovalue, sizeof(ovalue));\n+                  if ((s.write_mem) (cb, &s, arg3, (char *) &ovalue, sizeof(ovalue))\n+                      != sizeof(ovalue))\n+                    {\n+                      result = -1;\n+                      errcode = EINVAL;\n+                    }\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_getitimer:\n+            {\n+              struct itimerval value;\n+\n+              result = getitimer(arg1, &value);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&value, sizeof(value));\n+              if ((s.write_mem) (cb, &s, arg2, (char *) &value, sizeof(value))\n+                  != sizeof(value))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_stat:\n+            {\n+              char *buf;\n+              int buflen;\n+              struct stat statbuf;\n+\n+              result = stat((char *) t2h_addr(cb, &s, arg1), &statbuf);\n+              errcode = errno;\n+              if (result < 0)\n+                break;\n+\n+              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n+              buf = xmalloc (buflen);\n+              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n+                {\n+                  /* The translation failed.  This is due to an internal\n+                     host program error, not the target's fault.  */\n+                  free (buf);\n+                  result = -1;\n+                  errcode = ENOSYS;\n+                  break;\n+                }\n+              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n+                {\n+                  free (buf);\n+                  result = -1;\n+                  errcode = EINVAL;\n+                  break;\n+                }\n+              free (buf);\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_lstat:\n+            {\n+              char *buf;\n+              int buflen;\n+              struct stat statbuf;\n+\n+              result = lstat((char *) t2h_addr(cb, &s, arg1), &statbuf);\n+              errcode = errno;\n+              if (result < 0)\n+                break;\n+\n+              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n+              buf = xmalloc (buflen);\n+              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n+                {\n+                  /* The translation failed.  This is due to an internal\n+                     host program error, not the target's fault.  */\n+                  free (buf);\n+                  result = -1;\n+                  errcode = ENOSYS;\n+                  break;\n+                }\n+              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n+                {\n+                  free (buf);\n+                  result = -1;\n+                  errcode = EINVAL;\n+                  break;\n+                }\n+              free (buf);\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_fstat:\n+            {\n+              char *buf;\n+              int buflen;\n+              struct stat statbuf;\n+\n+              result = fstat(arg1, &statbuf);\n+              errcode = errno;\n+              if (result < 0)\n+                break;\n+\n+              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n+              buf = xmalloc (buflen);\n+              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n+                {\n+                  /* The translation failed.  This is due to an internal\n+                     host program error, not the target's fault.  */\n+                  free (buf);\n+                  result = -1;\n+                  errcode = ENOSYS;\n+                  break;\n+                }\n+              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n+                {\n+                  free (buf);\n+                  result = -1;\n+                  errcode = EINVAL;\n+                  break;\n+                }\n+              free (buf);\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_sysinfo:\n+            {\n+              struct sysinfo info;\n+\n+              result = sysinfo(&info);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              info.uptime    = H2T_4 (info.uptime);\n+              info.loads[0]  = H2T_4 (info.loads[0]);\n+              info.loads[1]  = H2T_4 (info.loads[1]);\n+              info.loads[2]  = H2T_4 (info.loads[2]);\n+              info.totalram  = H2T_4 (info.totalram);\n+              info.freeram   = H2T_4 (info.freeram);\n+              info.sharedram = H2T_4 (info.sharedram);\n+              info.bufferram = H2T_4 (info.bufferram);\n+              info.totalswap = H2T_4 (info.totalswap);\n+              info.freeswap  = H2T_4 (info.freeswap);\n+              info.procs     = H2T_2 (info.procs);\n+#if LINUX_VERSION_CODE >= 0x20400\n+              info.totalhigh = H2T_4 (info.totalhigh);\n+              info.freehigh  = H2T_4 (info.freehigh);\n+              info.mem_unit  = H2T_4 (info.mem_unit);\n+#endif\n+              if ((s.write_mem) (cb, &s, arg1, (char *) &info, sizeof(info))\n+                  != sizeof(info))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+#if 0\n+          case TARGET_LINUX_SYS_ipc:\n+            {\n+              result = ipc(arg1, arg2, arg3, arg4,\n+                           (void *) t2h_addr(cb, &s, arg5), arg6);\n+              errcode = errno;\n+            }\n+            break;\n+#endif\n+\n+          case TARGET_LINUX_SYS_fsync:\n+            result = fsync(arg1);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_uname:\n+            /* utsname contains only arrays of char, so it is not necessary\n+               to translate endian. */\n+            result = uname((struct utsname *) t2h_addr(cb, &s, arg1));\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_adjtimex:\n+            {\n+              struct timex buf;\n+\n+              result = adjtimex(&buf);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&buf, sizeof(buf));\n+              if ((s.write_mem) (cb, &s, arg1, (char *) &buf, sizeof(buf))\n+                  != sizeof(buf))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_mprotect:\n+            result = mprotect((void *) arg1, arg2, arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_fchdir:\n+            result = fchdir(arg1);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_setfsuid32:\n+          case TARGET_LINUX_SYS_setfsuid:\n+            result = setfsuid(arg1);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_setfsgid32:\n+          case TARGET_LINUX_SYS_setfsgid:\n+            result = setfsgid(arg1);\n+            errcode = errno;\n+            break;\n+\n+#if 0\n+          case TARGET_LINUX_SYS__llseek:\n+            {\n+              loff_t buf;\n+\n+              result = _llseek(arg1, arg2, arg3, &buf, arg5);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&buf, sizeof(buf));\n+              if ((s.write_mem) (cb, &s, t2h_addr(cb, &s, arg4),\n+                                 (char *) &buf, sizeof(buf)) != sizeof(buf))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_getdents:\n+            {\n+              struct dirent dir;\n+\n+              result = getdents(arg1, &dir, arg3);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              dir.d_ino = H2T_4 (dir.d_ino);\n+              dir.d_off = H2T_4 (dir.d_off);\n+              dir.d_reclen = H2T_2 (dir.d_reclen);\n+              if ((s.write_mem) (cb, &s, arg2, (char *) &dir, sizeof(dir))\n+                  != sizeof(dir))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+#endif\n+\n+          case TARGET_LINUX_SYS_flock:\n+            result = flock(arg1, arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_msync:\n+            result = msync((void *) arg1, arg2, arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_readv:\n+            {\n+              struct iovec vector;\n+\n+              vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n+              translate_endian_t2h (&vector, sizeof(vector));\n+\n+              result = readv(arg1, &vector, arg3);\n+              errcode = errno;\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_writev:\n+            {\n+              struct iovec vector;\n+\n+              vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n+              translate_endian_t2h (&vector, sizeof(vector));\n+\n+              result = writev(arg1, &vector, arg3);\n+              errcode = errno;\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_fdatasync:\n+            result = fdatasync(arg1);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_mlock:\n+            result = mlock((void *) t2h_addr(cb, &s, arg1), arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_munlock:\n+            result = munlock((void *) t2h_addr(cb, &s, arg1), arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_nanosleep:\n+            {\n+              struct timespec req, rem;\n+\n+              req = *((struct timespec *) t2h_addr(cb, &s, arg2));\n+              translate_endian_t2h (&req, sizeof(req));\n+\n+              result = nanosleep(&req, &rem);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              translate_endian_h2t (&rem, sizeof(rem));\n+              if ((s.write_mem) (cb, &s, arg2, (char *) &rem, sizeof(rem))\n+                  != sizeof(rem))\n+                {\n+                  result = -1;\n+                  errcode = EINVAL;\n+                }\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_mremap: /* FIXME */\n+            result = (int) mremap((void *) t2h_addr(cb, &s, arg1), arg2, arg3, arg4); \n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getresuid32:\n+          case TARGET_LINUX_SYS_getresuid:\n+            {\n+              uid_t ruid, euid, suid;\n+\n+              result = getresuid(&ruid, &euid, &suid);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              *((uid_t *) t2h_addr(cb, &s, arg1)) = H2T_4 (ruid);\n+              *((uid_t *) t2h_addr(cb, &s, arg2)) = H2T_4 (euid);\n+              *((uid_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (suid);\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_poll:\n+            {\n+              struct pollfd ufds;\n+\n+              ufds = *((struct pollfd *) t2h_addr(cb, &s, arg1));\n+              ufds.fd = T2H_4 (ufds.fd);\n+              ufds.events = T2H_2 (ufds.events);\n+              ufds.revents = T2H_2 (ufds.revents);\n+\n+              result = poll(&ufds, arg2, arg3);\n+              errcode = errno;\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_getresgid32:\n+          case TARGET_LINUX_SYS_getresgid:\n+            {\n+              uid_t rgid, egid, sgid;\n+\n+              result = getresgid(&rgid, &egid, &sgid);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              *((uid_t *) t2h_addr(cb, &s, arg1)) = H2T_4 (rgid);\n+              *((uid_t *) t2h_addr(cb, &s, arg2)) = H2T_4 (egid);\n+              *((uid_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (sgid);\n+            }\n+            break;\n+\n+          case TARGET_LINUX_SYS_pread:\n+            result =  pread(arg1, (void *) t2h_addr(cb, &s, arg2), arg3, arg4); \n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_pwrite:\n+            result =  pwrite(arg1, (void *) t2h_addr(cb, &s, arg2), arg3, arg4); \n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_chown32:\n+          case TARGET_LINUX_SYS_chown:\n+            result = chown((char *) t2h_addr(cb, &s, arg1), arg2, arg3);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_getcwd:\n+            result = (int) getcwd((char *) t2h_addr(cb, &s, arg1), arg2);\n+            errcode = errno;\n+            break;\n+\n+          case TARGET_LINUX_SYS_sendfile:\n+            {\n+              off_t offset;\n+\n+              offset = *((off_t *) t2h_addr(cb, &s, arg3));\n+              offset = T2H_4 (offset);\n+\n+              result = sendfile(arg1, arg2, &offset, arg3);\n+              errcode = errno;\n+\n+              if (result != 0)\n+                break;\n+\n+              *((off_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (offset);\n+            }\n+            break;\n+\n+          default:\n+            result = -1;\n+            errcode = ENOSYS;\n+            break;\n+          }\n+        \n+        if (result == -1)\n+\t  m32rbf_h_gr_set (current_cpu, 0, -errcode);\n+        else\n+\t  m32rbf_h_gr_set (current_cpu, 0, result);\n+\tbreak;\n+      }\n+\n     case TRAP_BREAKPOINT:\n       sim_engine_halt (sd, current_cpu, NULL, pc,\n \t\t       sim_stopped, SIM_SIGTRAP);\n@@ -148,11 +1316,14 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n       /* Do nothing.  */\n       break;\n \n-    default :\n+    case_default:\n+    default:\n       {\n+\t/* The new pc is the trap vector entry.\n+\t   We assume there's a branch there to some handler.\n+\t   Use cr5 as EVB (EIT Vector Base) register.  */\n \t/* USI new_pc = EIT_TRAP_BASE_ADDR + num * 4; */\n-        /* Use cr5 as EVB (EIT Vector Base) register.  */\n-        USI new_pc = m32rbf_h_cr_get (current_cpu, 5) + 0x40 + num * 4;\n+\tUSI new_pc = m32rbf_h_cr_get (current_cpu, 5) + 0x40 + num * 4;\n \treturn new_pc;\n       }\n     }"
    }
  ]
}