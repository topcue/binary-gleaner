{
  "sha": "73021deb50855f31bb312241899a464c62155f6a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzMwMjFkZWI1MDg1NWYzMWJiMzEyMjQxODk5YTQ2NGM2MjE1NWY2YQ==",
  "commit": {
    "author": {
      "name": "Alan Hayward",
      "email": "alan.hayward@arm.com",
      "date": "2019-01-21T15:51:49Z"
    },
    "committer": {
      "name": "Alan Hayward",
      "email": "alan.hayward@arm.com",
      "date": "2019-01-21T15:51:49Z"
    },
    "message": "AArch64 AAPCS: Empty structs have non zero size in C++\n\nWhen gdb.base/infcall-nested-structs.c is complied as C++, the compiler\nwill not pass structs containing empty structs via float arguments.\nThis is because structs in C++ have a minimum size of 1, causing padding\nin the struct once compiled.  The AAPCS does not allow structs with\npadding to be passed in float arguments.\n\nAdd padding checks to AArch64 and add C++ compile variant to the test.\n\nSome of the tests fail on X86_64. This has been raised as bug gdb/24104.\n\ngdb/ChangeLog:\n\n\t* aarch64-tdep.c (aapcs_is_vfp_call_or_return_candidate_1): Check\n\tfor padding.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.base/infcall-nested-structs.exp: Test C++ in addition to C.",
    "tree": {
      "sha": "244743e4b0361fb6426946c1dfe9567a1ec64f53",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/244743e4b0361fb6426946c1dfe9567a1ec64f53"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/73021deb50855f31bb312241899a464c62155f6a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/73021deb50855f31bb312241899a464c62155f6a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/73021deb50855f31bb312241899a464c62155f6a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/73021deb50855f31bb312241899a464c62155f6a/comments",
  "author": {
    "login": "a74nh",
    "id": 4146708,
    "node_id": "MDQ6VXNlcjQxNDY3MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/a74nh",
    "html_url": "https://github.com/a74nh",
    "followers_url": "https://api.github.com/users/a74nh/followers",
    "following_url": "https://api.github.com/users/a74nh/following{/other_user}",
    "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions",
    "organizations_url": "https://api.github.com/users/a74nh/orgs",
    "repos_url": "https://api.github.com/users/a74nh/repos",
    "events_url": "https://api.github.com/users/a74nh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/a74nh/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "a74nh",
    "id": 4146708,
    "node_id": "MDQ6VXNlcjQxNDY3MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/a74nh",
    "html_url": "https://github.com/a74nh",
    "followers_url": "https://api.github.com/users/a74nh/followers",
    "following_url": "https://api.github.com/users/a74nh/following{/other_user}",
    "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions",
    "organizations_url": "https://api.github.com/users/a74nh/orgs",
    "repos_url": "https://api.github.com/users/a74nh/repos",
    "events_url": "https://api.github.com/users/a74nh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/a74nh/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a6c9b4042921847ee52003811383e4b8bf5d5875",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a6c9b4042921847ee52003811383e4b8bf5d5875",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a6c9b4042921847ee52003811383e4b8bf5d5875"
    }
  ],
  "stats": {
    "total": 74,
    "additions": 61,
    "deletions": 13
  },
  "files": [
    {
      "sha": "e495ff97066af2311fabb2bf9060eb40e76cb286",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/73021deb50855f31bb312241899a464c62155f6a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/73021deb50855f31bb312241899a464c62155f6a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=73021deb50855f31bb312241899a464c62155f6a",
      "patch": "@@ -1,3 +1,8 @@\n+2019-01-21  Alan Hayward  <alan.hayward@arm.com>\n+\n+\t* aarch64-tdep.c (aapcs_is_vfp_call_or_return_candidate_1): Check\n+\tfor padding.\n+\n 2019-01-16  Tom Tromey  <tom@tromey.com>\n \n \t* objfiles.h (struct minimal_symbol_iterator): Rename.  Move"
    },
    {
      "sha": "7c5d74858d153dfbee5cf3f9327cef55ecaff108",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/73021deb50855f31bb312241899a464c62155f6a/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/73021deb50855f31bb312241899a464c62155f6a/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=73021deb50855f31bb312241899a464c62155f6a",
      "patch": "@@ -1232,6 +1232,14 @@ aapcs_is_vfp_call_or_return_candidate_1 (struct type *type,\n \t      return -1;\n \t    count += sub_count;\n \t  }\n+\n+\t/* Ensure there is no padding between the fields (allowing for empty\n+\t   zero length structs)  */\n+\tint ftype_length = (*fundamental_type == nullptr)\n+\t\t\t   ? 0 : TYPE_LENGTH (*fundamental_type);\n+\tif (count * ftype_length != TYPE_LENGTH (type))\n+\t  return -1;\n+\n \treturn count;\n       }\n "
    },
    {
      "sha": "7d8c7908fe5caedd2497b9310e9eacda5aac1ee7",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/73021deb50855f31bb312241899a464c62155f6a/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/73021deb50855f31bb312241899a464c62155f6a/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=73021deb50855f31bb312241899a464c62155f6a",
      "patch": "@@ -1,3 +1,6 @@\n+2019-01-21  Alan Hayward  <alan.hayward@arm.com>\n+\t* gdb.base/infcall-nested-structs.exp: Test C++ in addition to C.\n+\n 2019-01-21  Alan Hayward  <alan.hayward@arm.com>\n \t* gdb.base/stack-protector.c: New test.\n \t* gdb.base/stack-protector.exp: New file."
    },
    {
      "sha": "d7d1e3e00d8ada9ee2cd375f28509a1047181707",
      "filename": "gdb/testsuite/gdb.base/infcall-nested-structs.exp",
      "status": "modified",
      "additions": 45,
      "deletions": 13,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/73021deb50855f31bb312241899a464c62155f6a/gdb/testsuite/gdb.base/infcall-nested-structs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/73021deb50855f31bb312241899a464c62155f6a/gdb/testsuite/gdb.base/infcall-nested-structs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/infcall-nested-structs.exp?ref=73021deb50855f31bb312241899a464c62155f6a",
      "patch": "@@ -24,13 +24,28 @@ if [target_info exists gdb,cannot_call_functions] {\n     continue\n }\n \n+# Only test C++ if we are able.  Always use C.\n+if { [skip_cplus_tests] || [get_compiler_info \"c++\"] } {\n+    set lang {c}\n+} else {\n+    set lang {c c++}\n+}\n+\n+foreach l $lang {\n+    set dir \"$l\"\n+    remote_exec host \"rm -rf [standard_output_file ${dir}]\"\n+    remote_exec host \"mkdir -p [standard_output_file ${dir}]\"\n+}\n+\n+\n set int_types { tc ts ti tl tll }\n set float_types { tf td tld }\n set complex_types { tfc tdc tldc }\n \n set compile_flags {debug}\n if [support_complex_tests] {\n     lappend compile_flags \"additional_flags=-DTEST_COMPLEX\"\n+    lappend compile_flags \"additional_flags=-Wno-psabi\"\n }\n \n # Given N (0..25), return the corresponding alphabetic letter in upper\n@@ -44,7 +59,7 @@ proc I2A { n } {\n # types of the struct fields within the source.  Run up to main.\n # Also updates the global \"testfile\" to reflect the most recent build.\n \n-proc start_nested_structs_test { types } {\n+proc start_nested_structs_test { lang types } {\n     global testfile\n     global srcfile\n     global binfile\n@@ -53,9 +68,11 @@ proc start_nested_structs_test { types } {\n     global compile_flags\n \n     standard_testfile .c\n+    set dir \"$lang\"\n \n     # Create the additional flags\n     set flags $compile_flags\n+    lappend flags $lang\n \n     for {set n 0} {$n<[llength ${types}]} {incr n} {\n \tset m [I2A ${n}]\n@@ -64,7 +81,7 @@ proc start_nested_structs_test { types } {\n \tappend testfile \"-\" \"$t\"\n     }\n \n-    set binfile [standard_output_file ${testfile}]\n+    set binfile [standard_output_file ${dir}/${testfile}]\n     if  { [gdb_compile \"${srcdir}/${subdir}/${srcfile}\" \"${binfile}\" executable \"${flags}\"] != \"\" } {\n \tunresolved \"failed to compile\"\n \treturn 0\n@@ -99,22 +116,35 @@ proc start_nested_structs_test { types } {\n # Assuming GDB is stopped at main within a test binary, run some tests\n # passing structures, and reading return value structures.\n \n-proc run_tests {} {\n+proc run_tests { lang types } {\n     global gdb_prompt\n \n     foreach {name} {struct_01_01 struct_01_02 struct_01_03 struct_01_04\n                     struct_02_01 struct_02_02 struct_02_03 struct_02_04\n                     struct_04_01 struct_04_02 struct_04_03 struct_04_04\n                     struct_05_01 struct_05_02 struct_05_03 struct_05_04} {\n+\n+\tif { ( $lang == \"c++\"\n+\t       && ( ( [regexp \"struct_01_0(1|2|3)\" $name match] && [regexp \"^types-(td($|-)|tl(|l)(|-tf|-td|-tld)$)\" $types match] )\n+\t\t    || ( $name == \"struct_01_02\" && $types == \"types-tfc\" )\n+\t\t    || ( $name == \"struct_01_04\" && [regexp \"^types-(tf($|-)|ti(|-tf|-td|-tld)$)\" $types match] )\n+\t\t    || ( $name == \"struct_02_01\" && [regexp \"^types-tf-t(c|s|i)\" $types match] ) ) ) } {\n+\t    setup_xfail gdb/24104 \"x86_64-*-linux*\"\n+\t}\n \tgdb_test \"p/d check_arg_${name} (ref_val_${name})\" \"= 1\"\n \n \tset refval [ get_valueof \"\" \"ref_val_${name}\" \"\" ]\n \tverbose -log \"Refval: ${refval}\"\n \n \tset test \"check return value ${name}\"\n \tif { ${refval} != \"\" } {\n+\n \t    set answer [ get_valueof \"\" \"rtn_str_${name} ()\" \"XXXX\"]\n \t    verbose -log \"Answer: ${answer}\"\n+\n+\t    if { ($lang == \"c++\" && $name == \"struct_02_01\" && [regexp \"^types-(tf-t(c|s|i)|t(c|s|i)-tf)\" $types match] ) } {\n+\t\tsetup_xfail gdb/24104 \"x86_64-*-linux*\"\n+\t    }\n \t    gdb_assert [string eq ${answer} ${refval}] ${test}\n \t} else {\n \t    unresolved $test\n@@ -125,48 +155,50 @@ proc run_tests {} {\n # Set up a test prefix, compile the test binary, run to main, and then\n # run some tests.\n \n-proc start_gdb_and_run_tests { types } {\n+proc start_gdb_and_run_tests { lang types } {\n     set prefix \"types\"\n \n     foreach t $types {\n \tappend prefix \"-\" \"${t}\"\n     }\n \n-    with_test_prefix $prefix {\n-\tif { [start_nested_structs_test $types] } {\n-\t    run_tests\n+    foreach_with_prefix l $lang {\n+\twith_test_prefix $prefix {\n+\t    if { [start_nested_structs_test $l $types] } {\n+\t\trun_tests $l $prefix\n+\t    }\n \t}\n     }\n }\n \n foreach ta $int_types {\n-    start_gdb_and_run_tests $ta\n+    start_gdb_and_run_tests $lang $ta\n }\n \n if [support_complex_tests] {\n     foreach ta $complex_types {\n-\tstart_gdb_and_run_tests $ta\n+\tstart_gdb_and_run_tests $lang $ta\n     }\n }\n \n if ![gdb_skip_float_test] {\n     foreach ta $float_types {\n-\tstart_gdb_and_run_tests $ta\n+\tstart_gdb_and_run_tests $lang $ta\n     }\n \n     foreach ta $int_types {\n \tforeach tb $float_types {\n-\t    start_gdb_and_run_tests [list $ta $tb]\n+\t    start_gdb_and_run_tests $lang [list $ta $tb]\n \t}\n     }\n \n     foreach ta $float_types {\n \tforeach tb $int_types {\n-\t    start_gdb_and_run_tests [list $ta $tb]\n+\t    start_gdb_and_run_tests $lang [list $ta $tb]\n \t}\n \n \tforeach tb $float_types {\n-\t    start_gdb_and_run_tests [list $ta $tb]\n+\t    start_gdb_and_run_tests $lang [list $ta $tb]\n \t}\n     }\n }"
    }
  ]
}