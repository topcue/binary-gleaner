{
  "sha": "abe8cab7cb39e5db02d318e56595fa13677b52da",
  "node_id": "C_kwDOANOeidoAKGFiZThjYWI3Y2IzOWU1ZGIwMmQzMThlNTY1OTVmYTEzNjc3YjUyZGE",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-06-07T17:15:05Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-09-29T00:18:30Z"
    },
    "message": "gdb: enable target_async around stop_all_threads call in process_initial_stop_replies\n\nThe following scenario hangs:\n\n - maint set target-non-stop on\n - `gdbserver --attach`\n - a multi-threaded program\n\nFor example:\n\nTerminal 1:\n\n    $ gnome-calculator&\n    [1] 495731\n    $ ../gdbserver/gdbserver --once --attach :1234 495731\n    Attached; pid = 495731\n    Listening on port 1234\n\nTerminal 2:\n\n    $ ./gdb -nx -q --data-directory=data-directory /usr/bin/gnome-calculator -ex \"maint set target-non-stop on\" -ex \"tar rem :1234\"\n    Reading symbols from /usr/bin/gnome-calculator...\n    (No debugging symbols found in /usr/bin/gnome-calculator)\n    Remote debugging using :1234\n    * hangs *\n\nWhat happens is:\n\n - The protocol between gdb and gdbserver is in non-stop mode, but the\n   user-visible behavior is all-stop\n - On connect, gdbserver sends one stop reply for one thread that is\n   stops, the others stay running\n - In process_initial_stop_replies, gdb calls stop_all_threads to stop\n   these other threads, because we are using the all-stop user-visible\n   mode\n - stop_all_threads sends a stop request for all the running threads and\n   then waits for resulting events\n - At this point, the remote target is in target_async(0) mode, which\n   makes stop_all_threads not consider it for events\n - stop_all_threads loops indefinitely (it does not even block\n   indefinitely, it is in an infinite busy loop) because there are no\n   event sources.  wait_one_event returns a TARGET_WAITKIND_NO_RESUMED\n   wait status.\n\nFix that by making the remote target async around the stop_all_threads\ncall.\n\nI haven't implemented it because I'm not sure how to do it, but I think\nit would be a good idea to have, in stop_all_threads / wait_one /\nhandle_one, an assert to check that if we are expecting one or more\nevent, then there are some targets that are in a state where they can\nsupply some events.  Otherwise, we'll necessarily be stuck in this\ninfinite loop, and it's probably due to a bug in GDB.  I'm not too sure\nwhere to put this or how to express it though.  Perhaps in\nstop_all_threads, here:\n\n\t  for (int i = 0; i < waits_needed; i++)\n\t    {\n\t      wait_one_event event = wait_one ();\n\t      *here*\n\t      if (handle_one (event))\n\t\tbreak;\n\t    }\n\nIf at that point, the returned event is TARGET_WAITKIND_NO_RESUMED,\nthere's a problem.  We expect some event, because we've asked some\nthreads to stop, but all targets are answering that they won't have any\nevents for us.  That's a contradiction, and a sign that something has\ngone wrong.  It could perhaps event be:\n\n    gdb_assert (event.ws.kind != TARGET_WAITKIND_NO_RESUMED);\n\nin handle_one, as the idea is the same in prepare_for_detach.\n\nA bit more sophisticated would be: we know which targets we are\nexpecting waits from, since we know which threads we have asked to\nstop.  So if any of these targets returns TARGET_WAITKIND_NO_RESUMED,\nsomething is fishy.\n\nAdd a test that tests attaching with gdbserver's --attach flag to a\nmulti-threaded program, and then connecting to it.  Without the fix, the\ntest reproduces the hang.\n\nChange-Id: If6f6690a4887ca66693ef1af64791dda4c65f24f",
    "tree": {
      "sha": "9d2bbb939735b31bc469f231f422bbbbb90439d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9d2bbb939735b31bc469f231f422bbbbb90439d6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/abe8cab7cb39e5db02d318e56595fa13677b52da",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/abe8cab7cb39e5db02d318e56595fa13677b52da",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/abe8cab7cb39e5db02d318e56595fa13677b52da",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/abe8cab7cb39e5db02d318e56595fa13677b52da/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f08d6b8e02a6e80e5fe30134505c530b3cf77b1c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f08d6b8e02a6e80e5fe30134505c530b3cf77b1c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f08d6b8e02a6e80e5fe30134505c530b3cf77b1c"
    }
  ],
  "stats": {
    "total": 118,
    "additions": 117,
    "deletions": 1
  },
  "files": [
    {
      "sha": "c4a31e0c2f874896b7e0ce0c8a2cecb7a6014069",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abe8cab7cb39e5db02d318e56595fa13677b52da/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abe8cab7cb39e5db02d318e56595fa13677b52da/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=abe8cab7cb39e5db02d318e56595fa13677b52da",
      "patch": "@@ -4609,7 +4609,15 @@ remote_target::process_initial_stop_replies (int from_tty)\n      the inferiors.  */\n   if (!non_stop)\n     {\n-      stop_all_threads ();\n+      {\n+\t/* At this point, the remote target is not async.  It needs to be for\n+\t   the poll in stop_all_threads to consider events from it, so enable\n+\t   it temporarily.  */\n+\tgdb_assert (!this->is_async_p ());\n+\tSCOPE_EXIT { target_async (0); };\n+\ttarget_async (1);\n+\tstop_all_threads ();\n+      }\n \n       /* If all threads of an inferior were already stopped, we\n \t haven't setup the inferior yet.  */"
    },
    {
      "sha": "f6ed6180eef9b4f4b02cccdf217ddf08253c95db",
      "filename": "gdb/testsuite/gdb.server/attach-flag.c",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abe8cab7cb39e5db02d318e56595fa13677b52da/gdb/testsuite/gdb.server/attach-flag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abe8cab7cb39e5db02d318e56595fa13677b52da/gdb/testsuite/gdb.server/attach-flag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.server/attach-flag.c?ref=abe8cab7cb39e5db02d318e56595fa13677b52da",
      "patch": "@@ -0,0 +1,29 @@\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+static const int NTHREADS = 10;\n+static pthread_barrier_t barrier;\n+\n+static void *\n+thread_func (void *p)\n+{\n+  pthread_barrier_wait (&barrier);\n+  return NULL;\n+}\n+\n+int\n+main (void)\n+{\n+  alarm (60);\n+\n+  pthread_t threads[NTHREADS];\n+  pthread_barrier_init (&barrier, NULL, NTHREADS + 2);\n+\n+  for (int i = 0; i < NTHREADS; i++)\n+    pthread_create (&threads[i], NULL, thread_func, NULL);\n+\n+  pthread_barrier_wait (&barrier);\n+\n+  for (int i = 0; i < NTHREADS; i++)\n+    pthread_join (threads[i], NULL);\n+}"
    },
    {
      "sha": "dc949386e0e2ced054bce637aa164a9efe8b3cd8",
      "filename": "gdb/testsuite/gdb.server/attach-flag.exp",
      "status": "added",
      "additions": 79,
      "deletions": 0,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abe8cab7cb39e5db02d318e56595fa13677b52da/gdb/testsuite/gdb.server/attach-flag.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abe8cab7cb39e5db02d318e56595fa13677b52da/gdb/testsuite/gdb.server/attach-flag.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.server/attach-flag.exp?ref=abe8cab7cb39e5db02d318e56595fa13677b52da",
      "patch": "@@ -0,0 +1,79 @@\n+# This testcase is part of GDB, the GNU debugger.\n+\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test attaching to a multi-threaded process using gdbserver's --attach flag.\n+\n+load_lib gdbserver-support.exp\n+\n+standard_testfile\n+\n+if { [skip_gdbserver_tests] } {\n+    return 0\n+}\n+\n+if {![can_spawn_for_attach]} {\n+    return 0\n+}\n+\n+# Start the test program, attach to it using gdbserver's --attach flag, connect\n+# to it with GDB, check that what we see makes sense.\n+\n+proc run_one_test { non-stop target-non-stop } {\n+    save_vars { ::GDBFLAGS } {\n+\t# If GDB and GDBserver are both running locally, set the sysroot to avoid\n+\t# reading files via the remote protocol.\n+\tif { ![is_remote host] && ![is_remote target] } {\n+\t    set ::GDBFLAGS \"$::GDBFLAGS -ex \\\"set sysroot\\\"\"\n+\t}\n+\n+\tif { [prepare_for_testing \"failed to prepare\" $::testfile $::srcfile \\\n+\t\t{debug pthreads}] } {\n+\t    return -1\n+\t}\n+    }\n+\n+    # Make sure we're disconnected, in case we're testing with an\n+    # extended-remote board, therefore already connected.\n+    gdb_test \"disconnect\" \".*\"\n+\n+    set target_exec [gdbserver_download_current_prog]\n+    set test_spawn_id [spawn_wait_for_attach $::binfile]\n+    set testpid [spawn_id_get_pid $test_spawn_id]\n+\n+    lassign [gdbserver_start \"\" \"--attach $testpid\"] unused gdbserver_address\n+\n+    gdb_test_no_output \"set non-stop ${non-stop}\"\n+    gdb_test_no_output \"maint set target-non-stop ${target-non-stop}\"\n+    gdb_target_cmd \"remote\" $gdbserver_address\n+\n+    # There should be 11 threads.\n+    gdb_test \"thread 11\" \"Switching to thread 11.*\"\n+\n+    kill_wait_spawned_process $test_spawn_id\n+    gdbserver_exit 0\n+}\n+\n+foreach_with_prefix non-stop {0 1} {\n+    foreach_with_prefix target-non-stop {0 1} {\n+\t# This combination does not make sense.\n+\tif { ${non-stop} == 1 && ${target-non-stop} == 0} {\n+\t    continue\n+\t}\n+\n+\trun_one_test ${non-stop} ${target-non-stop}\n+    }\n+}"
    }
  ]
}