{
  "sha": "5f6b8397a40ca30460464e115c6aed8b7b6679f8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWY2YjgzOTdhNDBjYTMwNDYwNDY0ZTExNWM2YWVkOGI3YjY2NzlmOA==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-07-22T11:03:37Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-07-22T11:03:37Z"
    },
    "message": "x86: fold duplicate register printing code\n\nWhat so far was OP_E_register() can be easily reused also for OP_G().\nAdd suitable parameters to the function and move the invocation of\nswap_operand() to OP_E(). Adjust MOVSXD's first operand: There never was\na need to use movsxd_mode there, and its use gets in the way of the code\nfolding.",
    "tree": {
      "sha": "f1497cbea0a4cd94d1b672cb15a0157b63a8e4b1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f1497cbea0a4cd94d1b672cb15a0157b63a8e4b1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5f6b8397a40ca30460464e115c6aed8b7b6679f8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f6b8397a40ca30460464e115c6aed8b7b6679f8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5f6b8397a40ca30460464e115c6aed8b7b6679f8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f6b8397a40ca30460464e115c6aed8b7b6679f8/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bac11f2cfe7913ef4c37af608454451e27f78eff",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bac11f2cfe7913ef4c37af608454451e27f78eff",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bac11f2cfe7913ef4c37af608454451e27f78eff"
    }
  ],
  "stats": {
    "total": 119,
    "additions": 14,
    "deletions": 105
  },
  "files": [
    {
      "sha": "725b38b1dda8fdb13f4a77035888ed2af59ae8e3",
      "filename": "opcodes/i386-dis.c",
      "status": "modified",
      "additions": 14,
      "deletions": 105,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f6b8397a40ca30460464e115c6aed8b7b6679f8/opcodes/i386-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f6b8397a40ca30460464e115c6aed8b7b6679f8/opcodes/i386-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-dis.c?ref=5f6b8397a40ca30460464e115c6aed8b7b6679f8",
      "patch": "@@ -50,7 +50,6 @@ static void oappend (const char *);\n static void append_seg (void);\n static void OP_indirE (int, int);\n static void print_operand_value (char *, int, bfd_vma);\n-static void OP_E_register (int, int);\n static void OP_E_memory (int, int);\n static void print_displacement (char *, bfd_vma);\n static void OP_E (int, int);\n@@ -4180,7 +4179,7 @@ static const struct dis386 x86_64_table[][2] = {\n   /* X86_64_63 */\n   {\n     { \"arpl\", { Ew, Gw }, 0 },\n-    { \"movs\", { { OP_G, movsxd_mode }, { MOVSXD_Fixup, movsxd_mode } }, 0 },\n+    { \"movs\", { Gv, { MOVSXD_Fixup, movsxd_mode } }, 0 },\n   },\n \n   /* X86_64_6D */\n@@ -11290,21 +11289,14 @@ intel_operand_size (int bytemode, int sizeflag)\n }\n \n static void\n-OP_E_register (int bytemode, int sizeflag)\n+print_register (unsigned int reg, unsigned int rexmask, int bytemode, int sizeflag)\n {\n-  int reg = modrm.rm;\n   const char **names;\n \n-  USED_REX (REX_B);\n-  if ((rex & REX_B))\n+  USED_REX (rexmask);\n+  if (rex & rexmask)\n     reg += 8;\n \n-  if ((sizeflag & SUFFIX_ALWAYS)\n-      && (bytemode == b_swap_mode\n-\t  || bytemode == bnd_swap_mode\n-\t  || bytemode == v_swap_mode))\n-    swap_operand ();\n-\n   switch (bytemode)\n     {\n     case b_mode:\n@@ -11924,112 +11916,29 @@ OP_E (int bytemode, int sizeflag)\n   codep++;\n \n   if (modrm.mod == 3)\n-    OP_E_register (bytemode, sizeflag);\n+    {\n+      if ((sizeflag & SUFFIX_ALWAYS)\n+\t  && (bytemode == b_swap_mode\n+\t      || bytemode == bnd_swap_mode\n+\t      || bytemode == v_swap_mode))\n+\tswap_operand ();\n+\n+      print_register (modrm.rm, REX_B, bytemode, sizeflag);\n+    }\n   else\n     OP_E_memory (bytemode, sizeflag);\n }\n \n static void\n OP_G (int bytemode, int sizeflag)\n {\n-  int add = 0;\n-  const char **names;\n-\n   if (vex.evex && !vex.r && address_mode == mode_64bit)\n     {\n       oappend (\"(bad)\");\n       return;\n     }\n \n-  USED_REX (REX_R);\n-  if (rex & REX_R)\n-    add += 8;\n-  switch (bytemode)\n-    {\n-    case b_mode:\n-      if (modrm.reg & 4)\n-\tUSED_REX (0);\n-      if (rex)\n-\toappend (names8rex[modrm.reg + add]);\n-      else\n-\toappend (names8[modrm.reg + add]);\n-      break;\n-    case w_mode:\n-      oappend (names16[modrm.reg + add]);\n-      break;\n-    case d_mode:\n-    case db_mode:\n-    case dw_mode:\n-      oappend (names32[modrm.reg + add]);\n-      break;\n-    case q_mode:\n-      oappend (names64[modrm.reg + add]);\n-      break;\n-    case bnd_mode:\n-      if (modrm.reg + add > 0x3)\n-\t{\n-\t  oappend (\"(bad)\");\n-\t  return;\n-\t}\n-      oappend (names_bnd[modrm.reg]);\n-      break;\n-    case v_mode:\n-    case dq_mode:\n-    case dqb_mode:\n-    case dqd_mode:\n-    case dqw_mode:\n-    case movsxd_mode:\n-      USED_REX (REX_W);\n-      if (rex & REX_W)\n-\toappend (names64[modrm.reg + add]);\n-      else if (bytemode != v_mode && bytemode != movsxd_mode)\n-\toappend (names32[modrm.reg + add]);\n-      else\n-\t{\n-\t  if (sizeflag & DFLAG)\n-\t    oappend (names32[modrm.reg + add]);\n-\t  else\n-\t    oappend (names16[modrm.reg + add]);\n-\t  used_prefixes |= (prefixes & PREFIX_DATA);\n-\t}\n-      break;\n-    case va_mode:\n-      names = (address_mode == mode_64bit\n-\t       ? names64 : names32);\n-      if (!(prefixes & PREFIX_ADDR))\n-\t{\n-\t  if (address_mode == mode_16bit)\n-\t    names = names16;\n-\t}\n-      else\n-\t{\n-\t  /* Remove \"addr16/addr32\".  */\n-\t  all_prefixes[last_addr_prefix] = 0;\n-\t  names = (address_mode != mode_32bit\n-\t\t       ? names32 : names16);\n-\t  used_prefixes |= PREFIX_ADDR;\n-\t}\n-      oappend (names[modrm.reg + add]);\n-      break;\n-    case m_mode:\n-      if (address_mode == mode_64bit)\n-\toappend (names64[modrm.reg + add]);\n-      else\n-\toappend (names32[modrm.reg + add]);\n-      break;\n-    case mask_bd_mode:\n-    case mask_mode:\n-      if (add)\n-\t{\n-\t  oappend (\"(bad)\");\n-\t  return;\n-\t}\n-      oappend (names_mask[modrm.reg]);\n-      break;\n-    default:\n-      oappend (INTERNAL_DISASSEMBLER_ERROR);\n-      break;\n-    }\n+  print_register (modrm.reg, REX_R, bytemode, sizeflag);\n }\n \n static bfd_vma"
    }
  ]
}