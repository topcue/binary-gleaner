{
  "sha": "e2b0ab597857bfe9d7c8742ff50bbb77c70936c4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTJiMGFiNTk3ODU3YmZlOWQ3Yzg3NDJmZjUwYmJiNzdjNzA5MzZjNA==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-04-15T10:12:57Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-04-15T11:30:21Z"
    },
    "message": "[binutils, ARM, 4/16] BF insns infrastructure with array of relocs in struct arm_it\n\nThis patch is part of a series of patches to add support for ARMv8.1-M Mainline\ninstructions to binutils.\nThis adds infrastructure for the Branch Future instructions (BF, BFX, BFL,\nBFLX, BFCSEL).\nThese are the first instructions in ARM that have more than one relocations in\nthem. Their external relocations can be found in the 'ELF for the Arm\nArchitecture - ABI 2019Q1' document on developer.arm.com\n\nThis is the second infrastructure patch that adds support to allow up to\n3 relocations in an instruction. This is done by changing the reloc member of\nstruct arm_it to an array instead (relocs[3]). All the previous occurrences of\nreloc can now to referring to relocs[0].\n\nChangeLog entries are as follows :\n\n*** gas/ChangeLog ***\n\n2019-04-15  Sudakshina Das  <sudi.das@arm.com>\n\n\t* config/tc-arm.c (ARM_IT_MAX_RELOCS): New macro.\n\t(arm_it): Member reloc renamed relocs and updated to an array.\n\tRest: Replace all occurrences of reloc to relocs[0].",
    "tree": {
      "sha": "5090b63b4d92e0921eb174f4bf8a1c5384652f6a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5090b63b4d92e0921eb174f4bf8a1c5384652f6a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e2b0ab597857bfe9d7c8742ff50bbb77c70936c4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e2b0ab597857bfe9d7c8742ff50bbb77c70936c4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e2b0ab597857bfe9d7c8742ff50bbb77c70936c4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e2b0ab597857bfe9d7c8742ff50bbb77c70936c4/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e12437dc862690eeaa4a487fee35a237703d2b29",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e12437dc862690eeaa4a487fee35a237703d2b29",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e12437dc862690eeaa4a487fee35a237703d2b29"
    }
  ],
  "stats": {
    "total": 581,
    "additions": 310,
    "deletions": 271
  },
  "files": [
    {
      "sha": "d08dd0038f458a0e2c57959dde7c9b358068d29a",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2b0ab597857bfe9d7c8742ff50bbb77c70936c4/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2b0ab597857bfe9d7c8742ff50bbb77c70936c4/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=e2b0ab597857bfe9d7c8742ff50bbb77c70936c4",
      "patch": "@@ -1,3 +1,9 @@\n+2019-04-15  Sudakshina Das  <sudi.das@arm.com>\n+\n+\t* config/tc-arm.c (ARM_IT_MAX_RELOCS): New macro.\n+\t(arm_it): Member reloc renamed relocs and updated to an array.\n+\tRest: Replace all occurrences of reloc to relocs[0].\n+\n 2019-04-15  Sudakshina Das  <sudi.das@arm.com>\n \n \t* config/tc-arm.c (md_pcrel_from_section): New switch case"
    },
    {
      "sha": "14d114adbeec62b11fa3bc7d4f7cb3cdd030bf8f",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 304,
      "deletions": 271,
      "changes": 575,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2b0ab597857bfe9d7c8742ff50bbb77c70936c4/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2b0ab597857bfe9d7c8742ff50bbb77c70936c4/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=e2b0ab597857bfe9d7c8742ff50bbb77c70936c4",
      "patch": "@@ -463,6 +463,7 @@ enum it_instruction_type\n \n /* The maximum number of operands we need.  */\n #define ARM_IT_MAX_OPERANDS 6\n+#define ARM_IT_MAX_RELOCS 3\n \n struct arm_it\n {\n@@ -487,7 +488,7 @@ struct arm_it\n     bfd_reloc_code_real_type type;\n     expressionS\t\t     exp;\n     int\t\t\t     pc_rel;\n-  } reloc;\n+  } relocs[ARM_IT_MAX_RELOCS];\n \n   enum it_instruction_type it_insn_type;\n \n@@ -1791,15 +1792,15 @@ parse_reg_list (char ** strp)\n \t    }\n \t  else\n \t    {\n-\t      if (inst.reloc.type != 0)\n+\t      if (inst.relocs[0].type != 0)\n \t\t{\n \t\t  inst.error = _(\"expression too complex\");\n \t\t  return FAIL;\n \t\t}\n \n-\t      memcpy (&inst.reloc.exp, &exp, sizeof (expressionS));\n-\t      inst.reloc.type = BFD_RELOC_ARM_MULTI;\n-\t      inst.reloc.pc_rel = 0;\n+\t      memcpy (&inst.relocs[0].exp, &exp, sizeof (expressionS));\n+\t      inst.relocs[0].type = BFD_RELOC_ARM_MULTI;\n+\t      inst.relocs[0].pc_rel = 0;\n \t    }\n \t}\n \n@@ -3249,7 +3250,7 @@ add_to_lit_pool (unsigned int nbytes)\n     {\n       imm1 = inst.operands[1].imm;\n       imm2 = (inst.operands[1].regisimm ? inst.operands[1].reg\n-\t       : inst.reloc.exp.X_unsigned ? 0\n+\t       : inst.relocs[0].exp.X_unsigned ? 0\n \t       : ((bfd_int64_t) inst.operands[1].imm) >> 32);\n       if (target_big_endian)\n \t{\n@@ -3265,23 +3266,23 @@ add_to_lit_pool (unsigned int nbytes)\n     {\n       if (nbytes == 4)\n \t{\n-\t  if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)\n-\t      && (inst.reloc.exp.X_op == O_constant)\n+\t  if ((pool->literals[entry].X_op == inst.relocs[0].exp.X_op)\n+\t      && (inst.relocs[0].exp.X_op == O_constant)\n \t      && (pool->literals[entry].X_add_number\n-\t\t  == inst.reloc.exp.X_add_number)\n+\t\t  == inst.relocs[0].exp.X_add_number)\n \t      && (pool->literals[entry].X_md == nbytes)\n \t      && (pool->literals[entry].X_unsigned\n-\t\t  == inst.reloc.exp.X_unsigned))\n+\t\t  == inst.relocs[0].exp.X_unsigned))\n \t    break;\n \n-\t  if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)\n-\t      && (inst.reloc.exp.X_op == O_symbol)\n+\t  if ((pool->literals[entry].X_op == inst.relocs[0].exp.X_op)\n+\t      && (inst.relocs[0].exp.X_op == O_symbol)\n \t      && (pool->literals[entry].X_add_number\n-\t\t  == inst.reloc.exp.X_add_number)\n+\t\t  == inst.relocs[0].exp.X_add_number)\n \t      && (pool->literals[entry].X_add_symbol\n-\t\t  == inst.reloc.exp.X_add_symbol)\n+\t\t  == inst.relocs[0].exp.X_add_symbol)\n \t      && (pool->literals[entry].X_op_symbol\n-\t\t  == inst.reloc.exp.X_op_symbol)\n+\t\t  == inst.relocs[0].exp.X_op_symbol)\n \t      && (pool->literals[entry].X_md == nbytes))\n \t    break;\n \t}\n@@ -3291,11 +3292,11 @@ add_to_lit_pool (unsigned int nbytes)\n \t       && (pool->literals[entry].X_op == O_constant)\n \t       && (pool->literals[entry].X_add_number == (offsetT) imm1)\n \t       && (pool->literals[entry].X_unsigned\n-\t\t   == inst.reloc.exp.X_unsigned)\n+\t\t   == inst.relocs[0].exp.X_unsigned)\n \t       && (pool->literals[entry + 1].X_op == O_constant)\n \t       && (pool->literals[entry + 1].X_add_number == (offsetT) imm2)\n \t       && (pool->literals[entry + 1].X_unsigned\n-\t\t   == inst.reloc.exp.X_unsigned))\n+\t\t   == inst.relocs[0].exp.X_unsigned))\n \tbreak;\n \n       padding_slot_p = ((pool->literals[entry].X_md >> 8) == PADDING_SLOT);\n@@ -3327,8 +3328,8 @@ add_to_lit_pool (unsigned int nbytes)\n \n \t     We also check to make sure the literal operand is a\n \t     constant number.  */\n-\t  if (!(inst.reloc.exp.X_op == O_constant\n-\t        || inst.reloc.exp.X_op == O_big))\n+\t  if (!(inst.relocs[0].exp.X_op == O_constant\n+\t\t|| inst.relocs[0].exp.X_op == O_big))\n \t    {\n \t      inst.error = _(\"invalid type for literal pool\");\n \t      return FAIL;\n@@ -3341,7 +3342,7 @@ add_to_lit_pool (unsigned int nbytes)\n \t\t  return FAIL;\n \t\t}\n \n-\t      pool->literals[entry] = inst.reloc.exp;\n+\t      pool->literals[entry] = inst.relocs[0].exp;\n \t      pool->literals[entry].X_op = O_constant;\n \t      pool->literals[entry].X_add_number = 0;\n \t      pool->literals[entry++].X_md = (PADDING_SLOT << 8) | 4;\n@@ -3354,22 +3355,22 @@ add_to_lit_pool (unsigned int nbytes)\n \t      return FAIL;\n \t    }\n \n-\t  pool->literals[entry] = inst.reloc.exp;\n+\t  pool->literals[entry] = inst.relocs[0].exp;\n \t  pool->literals[entry].X_op = O_constant;\n \t  pool->literals[entry].X_add_number = imm1;\n-\t  pool->literals[entry].X_unsigned = inst.reloc.exp.X_unsigned;\n+\t  pool->literals[entry].X_unsigned = inst.relocs[0].exp.X_unsigned;\n \t  pool->literals[entry++].X_md = 4;\n-\t  pool->literals[entry] = inst.reloc.exp;\n+\t  pool->literals[entry] = inst.relocs[0].exp;\n \t  pool->literals[entry].X_op = O_constant;\n \t  pool->literals[entry].X_add_number = imm2;\n-\t  pool->literals[entry].X_unsigned = inst.reloc.exp.X_unsigned;\n+\t  pool->literals[entry].X_unsigned = inst.relocs[0].exp.X_unsigned;\n \t  pool->literals[entry].X_md = 4;\n \t  pool->alignment = 3;\n \t  pool->next_free_entry += 1;\n \t}\n       else\n \t{\n-\t  pool->literals[entry] = inst.reloc.exp;\n+\t  pool->literals[entry] = inst.relocs[0].exp;\n \t  pool->literals[entry].X_md = 4;\n \t}\n \n@@ -3385,13 +3386,13 @@ add_to_lit_pool (unsigned int nbytes)\n     }\n   else if (padding_slot_p)\n     {\n-      pool->literals[entry] = inst.reloc.exp;\n+      pool->literals[entry] = inst.relocs[0].exp;\n       pool->literals[entry].X_md = nbytes;\n     }\n \n-  inst.reloc.exp.X_op\t      = O_symbol;\n-  inst.reloc.exp.X_add_number = pool_size;\n-  inst.reloc.exp.X_add_symbol = pool->symbol;\n+  inst.relocs[0].exp.X_op\t      = O_symbol;\n+  inst.relocs[0].exp.X_add_number = pool_size;\n+  inst.relocs[0].exp.X_add_symbol = pool->symbol;\n \n   return SUCCESS;\n }\n@@ -5212,7 +5213,7 @@ parse_shift (char **str, int i, enum parse_shift_mode mode)\n \t  inst.operands[i].imm = reg;\n \t  inst.operands[i].immisreg = 1;\n \t}\n-      else if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))\n+      else if (my_get_expression (&inst.relocs[0].exp, &p, GE_IMM_PREFIX))\n \treturn FAIL;\n     }\n   inst.operands[i].shift_kind = shift;\n@@ -5244,8 +5245,8 @@ parse_shifter_operand (char **str, int i)\n       inst.operands[i].isreg = 1;\n \n       /* parse_shift will override this if appropriate */\n-      inst.reloc.exp.X_op = O_constant;\n-      inst.reloc.exp.X_add_number = 0;\n+      inst.relocs[0].exp.X_op = O_constant;\n+      inst.relocs[0].exp.X_add_number = 0;\n \n       if (skip_past_comma (str) == FAIL)\n \treturn SUCCESS;\n@@ -5254,7 +5255,7 @@ parse_shifter_operand (char **str, int i)\n       return parse_shift (str, i, NO_SHIFT_RESTRICT);\n     }\n \n-  if (my_get_expression (&inst.reloc.exp, str, GE_IMM_PREFIX))\n+  if (my_get_expression (&inst.relocs[0].exp, str, GE_IMM_PREFIX))\n     return FAIL;\n \n   if (skip_past_comma (str) == SUCCESS)\n@@ -5263,7 +5264,7 @@ parse_shifter_operand (char **str, int i)\n       if (my_get_expression (&exp, str, GE_NO_PREFIX))\n \treturn FAIL;\n \n-      if (exp.X_op != O_constant || inst.reloc.exp.X_op != O_constant)\n+      if (exp.X_op != O_constant || inst.relocs[0].exp.X_op != O_constant)\n \t{\n \t  inst.error = _(\"constant expression expected\");\n \t  return FAIL;\n@@ -5275,19 +5276,20 @@ parse_shifter_operand (char **str, int i)\n \t  inst.error = _(\"invalid rotation\");\n \t  return FAIL;\n \t}\n-      if (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 255)\n+      if (inst.relocs[0].exp.X_add_number < 0\n+\t  || inst.relocs[0].exp.X_add_number > 255)\n \t{\n \t  inst.error = _(\"invalid constant\");\n \t  return FAIL;\n \t}\n \n       /* Encode as specified.  */\n-      inst.operands[i].imm = inst.reloc.exp.X_add_number | value << 7;\n+      inst.operands[i].imm = inst.relocs[0].exp.X_add_number | value << 7;\n       return SUCCESS;\n     }\n \n-  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;\n-  inst.reloc.pc_rel = 0;\n+  inst.relocs[0].type = BFD_RELOC_ARM_IMMEDIATE;\n+  inst.relocs[0].pc_rel = 0;\n   return SUCCESS;\n }\n \n@@ -5458,12 +5460,12 @@ parse_shifter_operand_group_reloc (char **str, int i)\n \n       /* We now have the group relocation table entry corresponding to\n \t the name in the assembler source.  Next, we parse the expression.  */\n-      if (my_get_expression (&inst.reloc.exp, str, GE_NO_PREFIX))\n+      if (my_get_expression (&inst.relocs[0].exp, str, GE_NO_PREFIX))\n \treturn PARSE_OPERAND_FAIL_NO_BACKTRACK;\n \n       /* Record the relocation type (always the ALU variant here).  */\n-      inst.reloc.type = (bfd_reloc_code_real_type) entry->alu_code;\n-      gas_assert (inst.reloc.type != 0);\n+      inst.relocs[0].type = (bfd_reloc_code_real_type) entry->alu_code;\n+      gas_assert (inst.relocs[0].type != 0);\n \n       return PARSE_OPERAND_SUCCESS;\n     }\n@@ -5502,23 +5504,23 @@ parse_neon_alignment (char **str, int i)\n }\n \n /* Parse all forms of an ARM address expression.  Information is written\n-   to inst.operands[i] and/or inst.reloc.\n+   to inst.operands[i] and/or inst.relocs[0].\n \n    Preindexed addressing (.preind=1):\n \n-   [Rn, #offset]       .reg=Rn .reloc.exp=offset\n+   [Rn, #offset]       .reg=Rn .relocs[0].exp=offset\n    [Rn, +/-Rm]\t       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1\n    [Rn, +/-Rm, shift]  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1\n-\t\t       .shift_kind=shift .reloc.exp=shift_imm\n+\t\t       .shift_kind=shift .relocs[0].exp=shift_imm\n \n    These three may have a trailing ! which causes .writeback to be set also.\n \n    Postindexed addressing (.postind=1, .writeback=1):\n \n-   [Rn], #offset       .reg=Rn .reloc.exp=offset\n+   [Rn], #offset       .reg=Rn .relocs[0].exp=offset\n    [Rn], +/-Rm\t       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1\n    [Rn], +/-Rm, shift  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1\n-\t\t       .shift_kind=shift .reloc.exp=shift_imm\n+\t\t       .shift_kind=shift .relocs[0].exp=shift_imm\n \n    Unindexed addressing (.preind=0, .postind=0):\n \n@@ -5527,11 +5529,11 @@ parse_neon_alignment (char **str, int i)\n    Other:\n \n    [Rn]{!}\t       shorthand for [Rn,#0]{!}\n-   =immediate\t       .isreg=0 .reloc.exp=immediate\n-   label\t       .reg=PC .reloc.pc_rel=1 .reloc.exp=label\n+   =immediate\t       .isreg=0 .relocs[0].exp=immediate\n+   label\t       .reg=PC .relocs[0].pc_rel=1 .relocs[0].exp=label\n \n   It is the caller's responsibility to check for addressing modes not\n-  supported by the instruction, and to set inst.reloc.type.  */\n+  supported by the instruction, and to set inst.relocs[0].type.  */\n \n static parse_operand_result\n parse_address_main (char **str, int i, int group_relocations,\n@@ -5545,15 +5547,15 @@ parse_address_main (char **str, int i, int group_relocations,\n       if (skip_past_char (&p, '=') == FAIL)\n \t{\n \t  /* Bare address - translate to PC-relative offset.  */\n-\t  inst.reloc.pc_rel = 1;\n+\t  inst.relocs[0].pc_rel = 1;\n \t  inst.operands[i].reg = REG_PC;\n \t  inst.operands[i].isreg = 1;\n \t  inst.operands[i].preind = 1;\n \n-\t  if (my_get_expression (&inst.reloc.exp, &p, GE_OPT_PREFIX_BIG))\n+\t  if (my_get_expression (&inst.relocs[0].exp, &p, GE_OPT_PREFIX_BIG))\n \t    return PARSE_OPERAND_FAIL;\n \t}\n-      else if (parse_big_immediate (&p, i, &inst.reloc.exp,\n+      else if (parse_big_immediate (&p, i, &inst.relocs[0].exp,\n \t\t\t\t    /*allow_symbol_p=*/TRUE))\n \treturn PARSE_OPERAND_FAIL;\n \n@@ -5628,29 +5630,32 @@ parse_address_main (char **str, int i, int group_relocations,\n \t      /* We now have the group relocation table entry corresponding to\n \t\t the name in the assembler source.  Next, we parse the\n \t\t expression.  */\n-\t      if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))\n+\t      if (my_get_expression (&inst.relocs[0].exp, &p, GE_NO_PREFIX))\n \t\treturn PARSE_OPERAND_FAIL_NO_BACKTRACK;\n \n \t      /* Record the relocation type.  */\n \t      switch (group_type)\n \t\t{\n \t\t  case GROUP_LDR:\n-\t\t    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldr_code;\n+\t\t    inst.relocs[0].type\n+\t\t\t= (bfd_reloc_code_real_type) entry->ldr_code;\n \t\t    break;\n \n \t\t  case GROUP_LDRS:\n-\t\t    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldrs_code;\n+\t\t    inst.relocs[0].type\n+\t\t\t= (bfd_reloc_code_real_type) entry->ldrs_code;\n \t\t    break;\n \n \t\t  case GROUP_LDC:\n-\t\t    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldc_code;\n+\t\t    inst.relocs[0].type\n+\t\t\t= (bfd_reloc_code_real_type) entry->ldc_code;\n \t\t    break;\n \n \t\t  default:\n \t\t    gas_assert (0);\n \t\t}\n \n-\t      if (inst.reloc.type == 0)\n+\t      if (inst.relocs[0].type == 0)\n \t\t{\n \t\t  inst.error = _(\"this group relocation is not allowed on this instruction\");\n \t\t  return PARSE_OPERAND_FAIL_NO_BACKTRACK;\n@@ -5660,11 +5665,11 @@ parse_address_main (char **str, int i, int group_relocations,\n \t    {\n \t      char *q = p;\n \n-\t      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))\n+\t      if (my_get_expression (&inst.relocs[0].exp, &p, GE_IMM_PREFIX))\n \t\treturn PARSE_OPERAND_FAIL;\n \t      /* If the offset is 0, find out if it's a +0 or -0.  */\n-\t      if (inst.reloc.exp.X_op == O_constant\n-\t\t  && inst.reloc.exp.X_add_number == 0)\n+\t      if (inst.relocs[0].exp.X_op == O_constant\n+\t\t  && inst.relocs[0].exp.X_add_number == 0)\n \t\t{\n \t\t  skip_whitespace (q);\n \t\t  if (*q == '#')\n@@ -5756,11 +5761,11 @@ parse_address_main (char **str, int i, int group_relocations,\n \t\t  inst.operands[i].negative = 0;\n \t\t  p--;\n \t\t}\n-\t      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))\n+\t      if (my_get_expression (&inst.relocs[0].exp, &p, GE_IMM_PREFIX))\n \t\treturn PARSE_OPERAND_FAIL;\n \t      /* If the offset is 0, find out if it's a +0 or -0.  */\n-\t      if (inst.reloc.exp.X_op == O_constant\n-\t\t  && inst.reloc.exp.X_add_number == 0)\n+\t      if (inst.relocs[0].exp.X_op == O_constant\n+\t\t  && inst.relocs[0].exp.X_add_number == 0)\n \t\t{\n \t\t  skip_whitespace (q);\n \t\t  if (*q == '#')\n@@ -5780,8 +5785,8 @@ parse_address_main (char **str, int i, int group_relocations,\n   if (inst.operands[i].preind == 0 && inst.operands[i].postind == 0)\n     {\n       inst.operands[i].preind = 1;\n-      inst.reloc.exp.X_op = O_constant;\n-      inst.reloc.exp.X_add_number = 0;\n+      inst.relocs[0].exp.X_op = O_constant;\n+      inst.relocs[0].exp.X_add_number = 0;\n     }\n   *str = p;\n   return PARSE_OPERAND_SUCCESS;\n@@ -5809,28 +5814,28 @@ parse_half (char **str)\n   p = *str;\n   skip_past_char (&p, '#');\n   if (strncasecmp (p, \":lower16:\", 9) == 0)\n-    inst.reloc.type = BFD_RELOC_ARM_MOVW;\n+    inst.relocs[0].type = BFD_RELOC_ARM_MOVW;\n   else if (strncasecmp (p, \":upper16:\", 9) == 0)\n-    inst.reloc.type = BFD_RELOC_ARM_MOVT;\n+    inst.relocs[0].type = BFD_RELOC_ARM_MOVT;\n \n-  if (inst.reloc.type != BFD_RELOC_UNUSED)\n+  if (inst.relocs[0].type != BFD_RELOC_UNUSED)\n     {\n       p += 9;\n       skip_whitespace (p);\n     }\n \n-  if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))\n+  if (my_get_expression (&inst.relocs[0].exp, &p, GE_NO_PREFIX))\n     return FAIL;\n \n-  if (inst.reloc.type == BFD_RELOC_UNUSED)\n+  if (inst.relocs[0].type == BFD_RELOC_UNUSED)\n     {\n-      if (inst.reloc.exp.X_op != O_constant)\n+      if (inst.relocs[0].exp.X_op != O_constant)\n \t{\n \t  inst.error = _(\"constant expression expected\");\n \t  return FAIL;\n \t}\n-      if (inst.reloc.exp.X_add_number < 0\n-\t  || inst.reloc.exp.X_add_number > 0xffff)\n+      if (inst.relocs[0].exp.X_add_number < 0\n+\t  || inst.relocs[0].exp.X_add_number > 0xffff)\n \t{\n \t  inst.error = _(\"immediate value out of range\");\n \t  return FAIL;\n@@ -6257,7 +6262,7 @@ parse_tb (char **str)\n     {\n       if (parse_shift (&p, 0, SHIFT_LSL_IMMEDIATE) == FAIL)\n \treturn FAIL;\n-      if (inst.reloc.exp.X_add_number != 1)\n+      if (inst.relocs[0].exp.X_add_number != 1)\n \t{\n \t  inst.error = _(\"invalid shift\");\n \t  return FAIL;\n@@ -6587,6 +6592,7 @@ enum operand_parse_code\n   OP_EXP,\t/* arbitrary expression */\n   OP_EXPi,\t/* same, with optional immediate prefix */\n   OP_EXPr,\t/* same, with optional relocation suffix */\n+  OP_EXPs,\t/* same, with optional non-first operand relocation suffix */\n   OP_HALF,\t/* 0 .. 65535 or low/high reloc.  */\n   OP_IROT1,\t/* VCADD rotate immediate: 90, 270.  */\n   OP_IROT2,\t/* VCMLA rotate immediate: 0, 90, 180, 270.  */\n@@ -6995,19 +7001,19 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \n \t  /* Expressions */\n \tcase OP_EXPi:\tEXPi:\n-\t  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,\n+\t  po_misc_or_fail (my_get_expression (&inst.relocs[0].exp, &str,\n \t\t\t\t\t      GE_OPT_PREFIX));\n \t  break;\n \n \tcase OP_EXP:\n-\t  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,\n+\t  po_misc_or_fail (my_get_expression (&inst.relocs[0].exp, &str,\n \t\t\t\t\t      GE_NO_PREFIX));\n \t  break;\n \n \tcase OP_EXPr:\tEXPr:\n-\t  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,\n+\t  po_misc_or_fail (my_get_expression (&inst.relocs[0].exp, &str,\n \t\t\t\t\t      GE_NO_PREFIX));\n-\t  if (inst.reloc.exp.X_op == O_symbol)\n+\t  if (inst.relocs[0].exp.X_op == O_symbol)\n \t    {\n \t      val = parse_reloc (&str);\n \t      if (val == -1)\n@@ -7023,6 +7029,20 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \t    }\n \t  break;\n \n+\tcase OP_EXPs:\n+\t  po_misc_or_fail (my_get_expression (&inst.relocs[i].exp, &str,\n+\t\t\t\t\t      GE_NO_PREFIX));\n+\t  if (inst.relocs[i].exp.X_op == O_symbol)\n+\t    {\n+\t      inst.operands[i].hasreloc = 1;\n+\t    }\n+\t  else if (inst.relocs[i].exp.X_op == O_constant)\n+\t    {\n+\t      inst.operands[i].imm = inst.relocs[i].exp.X_add_number;\n+\t      inst.operands[i].hasreloc = 0;\n+\t    }\n+\t  break;\n+\n \t  /* Operand for MOVW or MOVT.  */\n \tcase OP_HALF:\n \t  po_misc_or_fail (parse_half (&str));\n@@ -7543,7 +7563,7 @@ encode_arm_shift (int i)\n \t  inst.instruction |= inst.operands[i].imm << 8;\n \t}\n       else\n-\tinst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;\n+\tinst.relocs[0].type = BFD_RELOC_ARM_SHIFT_IMM;\n     }\n }\n \n@@ -7558,7 +7578,7 @@ encode_arm_shifter_operand (int i)\n   else\n     {\n       inst.instruction |= INST_IMMEDIATE;\n-      if (inst.reloc.type != BFD_RELOC_ARM_IMMEDIATE)\n+      if (inst.relocs[0].type != BFD_RELOC_ARM_IMMEDIATE)\n \tinst.instruction |= inst.operands[i].imm;\n     }\n }\n@@ -7633,13 +7653,13 @@ encode_arm_addr_mode_2 (int i, bfd_boolean is_t)\n \t  else\n \t    {\n \t      inst.instruction |= inst.operands[i].shift_kind << 5;\n-\t      inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;\n+\t      inst.relocs[0].type = BFD_RELOC_ARM_SHIFT_IMM;\n \t    }\n \t}\n     }\n-  else /* immediate offset in inst.reloc */\n+  else /* immediate offset in inst.relocs[0] */\n     {\n-      if (is_pc && !inst.reloc.pc_rel)\n+      if (is_pc && !inst.relocs[0].pc_rel)\n \t{\n \t  const bfd_boolean is_load = ((inst.instruction & LOAD_BIT) != 0);\n \n@@ -7656,12 +7676,12 @@ encode_arm_addr_mode_2 (int i, bfd_boolean is_t)\n \t    as_tsktsk (_(\"use of PC in this instruction is deprecated\"));\n \t}\n \n-      if (inst.reloc.type == BFD_RELOC_UNUSED)\n+      if (inst.relocs[0].type == BFD_RELOC_UNUSED)\n \t{\n \t  /* Prefer + for zero encoded value.  */\n \t  if (!inst.operands[i].negative)\n \t    inst.instruction |= INDEX_UP;\n-\t  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;\n+\t  inst.relocs[0].type = BFD_RELOC_ARM_OFFSET_IMM;\n \t}\n     }\n }\n@@ -7693,19 +7713,19 @@ encode_arm_addr_mode_3 (int i, bfd_boolean is_t)\n       if (!inst.operands[i].negative)\n \tinst.instruction |= INDEX_UP;\n     }\n-  else /* immediate offset in inst.reloc */\n+  else /* immediate offset in inst.relocs[0] */\n     {\n-      constraint ((inst.operands[i].reg == REG_PC && !inst.reloc.pc_rel\n+      constraint ((inst.operands[i].reg == REG_PC && !inst.relocs[0].pc_rel\n \t\t   && inst.operands[i].writeback),\n \t\t  BAD_PC_WRITEBACK);\n       inst.instruction |= HWOFFSET_IMM;\n-      if (inst.reloc.type == BFD_RELOC_UNUSED)\n+      if (inst.relocs[0].type == BFD_RELOC_UNUSED)\n \t{\n \t  /* Prefer + for zero encoded value.  */\n \t  if (!inst.operands[i].negative)\n \t    inst.instruction |= INDEX_UP;\n \n-\t  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;\n+\t  inst.relocs[0].type = BFD_RELOC_ARM_OFFSET_IMM8;\n \t}\n     }\n }\n@@ -7958,7 +7978,7 @@ enum lit_type\n \n static void do_vfp_nsyn_opcode (const char *);\n \n-/* inst.reloc.exp describes an \"=expr\" load pseudo-operation.\n+/* inst.relocs[0].exp describes an \"=expr\" load pseudo-operation.\n    Determine whether it can be performed with a move instruction; if\n    it can, convert inst.instruction to that move instruction and\n    return TRUE; if it can't, convert inst.instruction to a literal-pool\n@@ -7985,28 +8005,28 @@ move_or_literal_pool (int i, enum lit_type t, bfd_boolean mode_3)\n       return TRUE;\n     }\n \n-  if (inst.reloc.exp.X_op != O_constant\n-      && inst.reloc.exp.X_op != O_symbol\n-      && inst.reloc.exp.X_op != O_big)\n+  if (inst.relocs[0].exp.X_op != O_constant\n+      && inst.relocs[0].exp.X_op != O_symbol\n+      && inst.relocs[0].exp.X_op != O_big)\n     {\n       inst.error = _(\"constant expression expected\");\n       return TRUE;\n     }\n \n-  if (inst.reloc.exp.X_op == O_constant\n-      || inst.reloc.exp.X_op == O_big)\n+  if (inst.relocs[0].exp.X_op == O_constant\n+      || inst.relocs[0].exp.X_op == O_big)\n     {\n #if defined BFD_HOST_64_BIT\n       bfd_int64_t v;\n #else\n       offsetT v;\n #endif\n-      if (inst.reloc.exp.X_op == O_big)\n+      if (inst.relocs[0].exp.X_op == O_big)\n \t{\n \t  LITTLENUM_TYPE w[X_PRECISION];\n \t  LITTLENUM_TYPE * l;\n \n-\t  if (inst.reloc.exp.X_add_number == -1)\n+\t  if (inst.relocs[0].exp.X_add_number == -1)\n \t    {\n \t      gen_to_words (w, X_PRECISION, E_PRECISION);\n \t      l = w;\n@@ -8030,7 +8050,7 @@ move_or_literal_pool (int i, enum lit_type t, bfd_boolean mode_3)\n #endif\n \t}\n       else\n-\tv = inst.reloc.exp.X_add_number;\n+\tv = inst.relocs[0].exp.X_add_number;\n \n       if (!inst.operands[i].issingle)\n \t{\n@@ -8119,7 +8139,7 @@ move_or_literal_pool (int i, enum lit_type t, bfd_boolean mode_3)\n \t      unsigned immlo = inst.operands[1].imm;\n \t      unsigned immhi = inst.operands[1].regisimm\n \t\t? inst.operands[1].reg\n-\t\t: inst.reloc.exp.X_unsigned\n+\t\t: inst.relocs[0].exp.X_unsigned\n \t\t? 0\n \t\t: ((bfd_int64_t)((int) immlo)) >> 32;\n \t      int cmode = neon_cmode_for_move_imm (immlo, immhi, FALSE, &immbits,\n@@ -8194,8 +8214,8 @@ move_or_literal_pool (int i, enum lit_type t, bfd_boolean mode_3)\n   inst.operands[1].reg = REG_PC;\n   inst.operands[1].isreg = 1;\n   inst.operands[1].preind = 1;\n-  inst.reloc.pc_rel = 1;\n-  inst.reloc.type = (thumb_p\n+  inst.relocs[0].pc_rel = 1;\n+  inst.relocs[0].type = (thumb_p\n \t\t     ? BFD_RELOC_ARM_THUMB_OFFSET\n \t\t     : (mode_3\n \t\t\t? BFD_RELOC_ARM_HWLITERAL\n@@ -8262,15 +8282,15 @@ encode_arm_cp_address (int i, int wb_ok, int unind_ok, int reloc_override)\n     }\n \n   if (reloc_override)\n-    inst.reloc.type = (bfd_reloc_code_real_type) reloc_override;\n-  else if ((inst.reloc.type < BFD_RELOC_ARM_ALU_PC_G0_NC\n-\t    || inst.reloc.type > BFD_RELOC_ARM_LDC_SB_G2)\n-\t   && inst.reloc.type != BFD_RELOC_ARM_LDR_PC_G0)\n+    inst.relocs[0].type = (bfd_reloc_code_real_type) reloc_override;\n+  else if ((inst.relocs[0].type < BFD_RELOC_ARM_ALU_PC_G0_NC\n+\t    || inst.relocs[0].type > BFD_RELOC_ARM_LDC_SB_G2)\n+\t   && inst.relocs[0].type != BFD_RELOC_ARM_LDR_PC_G0)\n     {\n       if (thumb_mode)\n-\tinst.reloc.type = BFD_RELOC_ARM_T32_CP_OFF_IMM;\n+\tinst.relocs[0].type = BFD_RELOC_ARM_T32_CP_OFF_IMM;\n       else\n-\tinst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;\n+\tinst.relocs[0].type = BFD_RELOC_ARM_CP_OFF_IMM;\n     }\n \n   /* Prefer + for zero encoded value.  */\n@@ -8389,9 +8409,9 @@ static void\n do_rm_rd_rn (void)\n {\n   constraint ((inst.operands[2].reg == REG_PC), BAD_PC);\n-  constraint (((inst.reloc.exp.X_op != O_constant\n-\t\t&& inst.reloc.exp.X_op != O_illegal)\n-\t       || inst.reloc.exp.X_add_number != 0),\n+  constraint (((inst.relocs[0].exp.X_op != O_constant\n+\t\t&& inst.relocs[0].exp.X_op != O_illegal)\n+\t       || inst.relocs[0].exp.X_add_number != 0),\n \t      BAD_ADDR_MODE);\n   inst.instruction |= inst.operands[0].reg;\n   inst.instruction |= inst.operands[1].reg << 12;\n@@ -8425,16 +8445,16 @@ do_adr (void)\n \n   /* Frag hacking will turn this into a sub instruction if the offset turns\n      out to be negative.  */\n-  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;\n-  inst.reloc.pc_rel = 1;\n-  inst.reloc.exp.X_add_number -= 8;\n+  inst.relocs[0].type = BFD_RELOC_ARM_IMMEDIATE;\n+  inst.relocs[0].pc_rel = 1;\n+  inst.relocs[0].exp.X_add_number -= 8;\n \n   if (support_interwork\n-      && inst.reloc.exp.X_op == O_symbol\n-      && inst.reloc.exp.X_add_symbol != NULL\n-      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)\n-      && THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))\n-    inst.reloc.exp.X_add_number |= 1;\n+      && inst.relocs[0].exp.X_op == O_symbol\n+      && inst.relocs[0].exp.X_add_symbol != NULL\n+      && S_IS_DEFINED (inst.relocs[0].exp.X_add_symbol)\n+      && THUMB_IS_FUNC (inst.relocs[0].exp.X_add_symbol))\n+    inst.relocs[0].exp.X_add_number |= 1;\n }\n \n /* This is a pseudo-op of the form \"adrl rd, label\" to be converted\n@@ -8449,24 +8469,24 @@ do_adrl (void)\n \n   /* Frag hacking will turn this into a sub instruction if the offset turns\n      out to be negative.  */\n-  inst.reloc.type\t       = BFD_RELOC_ARM_ADRL_IMMEDIATE;\n-  inst.reloc.pc_rel\t       = 1;\n+  inst.relocs[0].type\t       = BFD_RELOC_ARM_ADRL_IMMEDIATE;\n+  inst.relocs[0].pc_rel\t       = 1;\n   inst.size\t\t       = INSN_SIZE * 2;\n-  inst.reloc.exp.X_add_number -= 8;\n+  inst.relocs[0].exp.X_add_number -= 8;\n \n   if (support_interwork\n-      && inst.reloc.exp.X_op == O_symbol\n-      && inst.reloc.exp.X_add_symbol != NULL\n-      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)\n-      && THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))\n-    inst.reloc.exp.X_add_number |= 1;\n+      && inst.relocs[0].exp.X_op == O_symbol\n+      && inst.relocs[0].exp.X_add_symbol != NULL\n+      && S_IS_DEFINED (inst.relocs[0].exp.X_add_symbol)\n+      && THUMB_IS_FUNC (inst.relocs[0].exp.X_add_symbol))\n+    inst.relocs[0].exp.X_add_number |= 1;\n }\n \n static void\n do_arit (void)\n {\n-  constraint (inst.reloc.type >= BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n-\t      && inst.reloc.type <= BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC ,\n+  constraint (inst.relocs[0].type >= BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n+\t      && inst.relocs[0].type <= BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC ,\n \t      THUMB1_RELOC_ONLY);\n   if (!inst.operands[1].present)\n     inst.operands[1].reg = inst.operands[0].reg;\n@@ -8551,13 +8571,13 @@ encode_branch (int default_reloc)\n       constraint (inst.operands[0].imm != BFD_RELOC_ARM_PLT32\n \t\t  && inst.operands[0].imm != BFD_RELOC_ARM_TLS_CALL,\n \t\t  _(\"the only valid suffixes here are '(plt)' and '(tlscall)'\"));\n-      inst.reloc.type = inst.operands[0].imm == BFD_RELOC_ARM_PLT32\n+      inst.relocs[0].type = inst.operands[0].imm == BFD_RELOC_ARM_PLT32\n \t? BFD_RELOC_ARM_PLT32\n \t: thumb_mode ? BFD_RELOC_ARM_THM_TLS_CALL : BFD_RELOC_ARM_TLS_CALL;\n     }\n   else\n-    inst.reloc.type = (bfd_reloc_code_real_type) default_reloc;\n-  inst.reloc.pc_rel = 1;\n+    inst.relocs[0].type = (bfd_reloc_code_real_type) default_reloc;\n+  inst.relocs[0].pc_rel = 1;\n }\n \n static void\n@@ -8641,7 +8661,7 @@ do_bx (void)\n     want_reloc = FALSE;\n \n   if (want_reloc)\n-    inst.reloc.type = BFD_RELOC_ARM_V4BX;\n+    inst.relocs[0].type = BFD_RELOC_ARM_V4BX;\n }\n \n \n@@ -9010,15 +9030,15 @@ do_ldrex (void)\n \t      || (inst.operands[1].reg == REG_PC),\n \t      BAD_ADDR_MODE);\n \n-  constraint (inst.reloc.exp.X_op != O_constant\n-\t      || inst.reloc.exp.X_add_number != 0,\n+  constraint (inst.relocs[0].exp.X_op != O_constant\n+\t      || inst.relocs[0].exp.X_add_number != 0,\n \t      _(\"offset must be zero in ARM encoding\"));\n \n   constraint ((inst.operands[1].reg == REG_PC), BAD_PC);\n \n   inst.instruction |= inst.operands[0].reg << 12;\n   inst.instruction |= inst.operands[1].reg << 16;\n-  inst.reloc.type = BFD_RELOC_UNUSED;\n+  inst.relocs[0].type = BFD_RELOC_UNUSED;\n }\n \n static void\n@@ -9045,7 +9065,7 @@ check_ldr_r15_aligned (void)\n   constraint (!(inst.operands[1].immisreg)\n \t      && (inst.operands[0].reg == REG_PC\n \t      && inst.operands[1].reg == REG_PC\n-\t      && (inst.reloc.exp.X_add_number & 0x3)),\n+\t      && (inst.relocs[0].exp.X_add_number & 0x3)),\n \t      _(\"ldr to register 15 must be 4-byte aligned\"));\n }\n \n@@ -9067,8 +9087,8 @@ do_ldstt (void)\n      reject [Rn,...].  */\n   if (inst.operands[1].preind)\n     {\n-      constraint (inst.reloc.exp.X_op != O_constant\n-\t\t  || inst.reloc.exp.X_add_number != 0,\n+      constraint (inst.relocs[0].exp.X_op != O_constant\n+\t\t  || inst.relocs[0].exp.X_add_number != 0,\n \t\t  _(\"this instruction requires a post-indexed address\"));\n \n       inst.operands[1].preind = 0;\n@@ -9099,8 +9119,8 @@ do_ldsttv4 (void)\n      reject [Rn,...].  */\n   if (inst.operands[1].preind)\n     {\n-      constraint (inst.reloc.exp.X_op != O_constant\n-\t\t  || inst.reloc.exp.X_add_number != 0,\n+      constraint (inst.relocs[0].exp.X_op != O_constant\n+\t\t  || inst.relocs[0].exp.X_add_number != 0,\n \t\t  _(\"this instruction requires a post-indexed address\"));\n \n       inst.operands[1].preind = 0;\n@@ -9139,8 +9159,8 @@ do_mlas (void)\n static void\n do_mov (void)\n {\n-  constraint (inst.reloc.type >= BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n-\t      && inst.reloc.type <= BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC ,\n+  constraint (inst.relocs[0].type >= BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n+\t      && inst.relocs[0].type <= BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC ,\n \t      THUMB1_RELOC_ONLY);\n   inst.instruction |= inst.operands[0].reg << 12;\n   encode_arm_shifter_operand (1);\n@@ -9154,14 +9174,14 @@ do_mov16 (void)\n   bfd_boolean top;\n \n   top = (inst.instruction & 0x00400000) != 0;\n-  constraint (top && inst.reloc.type == BFD_RELOC_ARM_MOVW,\n+  constraint (top && inst.relocs[0].type == BFD_RELOC_ARM_MOVW,\n \t      _(\":lower16: not allowed in this instruction\"));\n-  constraint (!top && inst.reloc.type == BFD_RELOC_ARM_MOVT,\n+  constraint (!top && inst.relocs[0].type == BFD_RELOC_ARM_MOVT,\n \t      _(\":upper16: not allowed in this instruction\"));\n   inst.instruction |= inst.operands[0].reg << 12;\n-  if (inst.reloc.type == BFD_RELOC_UNUSED)\n+  if (inst.relocs[0].type == BFD_RELOC_UNUSED)\n     {\n-      imm = inst.reloc.exp.X_add_number;\n+      imm = inst.relocs[0].exp.X_add_number;\n       /* The value is in two pieces: 0:11, 16:19.  */\n       inst.instruction |= (imm & 0x00000fff);\n       inst.instruction |= (imm & 0x0000f000) << 4;\n@@ -9296,8 +9316,8 @@ do_msr (void)\n   else\n     {\n       inst.instruction |= INST_IMMEDIATE;\n-      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;\n-      inst.reloc.pc_rel = 0;\n+      inst.relocs[0].type = BFD_RELOC_ARM_IMMEDIATE;\n+      inst.relocs[0].pc_rel = 0;\n     }\n }\n \n@@ -9537,28 +9557,28 @@ do_shift (void)\n \t\t  _(\"extraneous shift as part of operand to shift insn\"));\n     }\n   else\n-    inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;\n+    inst.relocs[0].type = BFD_RELOC_ARM_SHIFT_IMM;\n }\n \n static void\n do_smc (void)\n {\n-  inst.reloc.type = BFD_RELOC_ARM_SMC;\n-  inst.reloc.pc_rel = 0;\n+  inst.relocs[0].type = BFD_RELOC_ARM_SMC;\n+  inst.relocs[0].pc_rel = 0;\n }\n \n static void\n do_hvc (void)\n {\n-  inst.reloc.type = BFD_RELOC_ARM_HVC;\n-  inst.reloc.pc_rel = 0;\n+  inst.relocs[0].type = BFD_RELOC_ARM_HVC;\n+  inst.relocs[0].pc_rel = 0;\n }\n \n static void\n do_swi (void)\n {\n-  inst.reloc.type = BFD_RELOC_ARM_SWI;\n-  inst.reloc.pc_rel = 0;\n+  inst.relocs[0].type = BFD_RELOC_ARM_SWI;\n+  inst.relocs[0].pc_rel = 0;\n }\n \n static void\n@@ -9660,14 +9680,14 @@ do_strex (void)\n   constraint (inst.operands[0].reg == inst.operands[1].reg\n \t      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);\n \n-  constraint (inst.reloc.exp.X_op != O_constant\n-\t      || inst.reloc.exp.X_add_number != 0,\n+  constraint (inst.relocs[0].exp.X_op != O_constant\n+\t      || inst.relocs[0].exp.X_add_number != 0,\n \t      _(\"offset must be zero in ARM encoding\"));\n \n   inst.instruction |= inst.operands[0].reg << 12;\n   inst.instruction |= inst.operands[1].reg;\n   inst.instruction |= inst.operands[2].reg << 16;\n-  inst.reloc.type = BFD_RELOC_UNUSED;\n+  inst.relocs[0].type = BFD_RELOC_UNUSED;\n }\n \n static void\n@@ -10054,15 +10074,15 @@ do_fpa_ldmstm (void)\n \t [Rn]{!}.  The instruction does not really support stacking or\n \t unstacking, so we have to emulate these by setting appropriate\n \t bits and offsets.  */\n-      constraint (inst.reloc.exp.X_op != O_constant\n-\t\t  || inst.reloc.exp.X_add_number != 0,\n+      constraint (inst.relocs[0].exp.X_op != O_constant\n+\t\t  || inst.relocs[0].exp.X_add_number != 0,\n \t\t  _(\"this instruction does not support indexing\"));\n \n       if ((inst.instruction & PRE_INDEX) || inst.operands[2].writeback)\n-\tinst.reloc.exp.X_add_number = 12 * inst.operands[1].imm;\n+\tinst.relocs[0].exp.X_add_number = 12 * inst.operands[1].imm;\n \n       if (!(inst.instruction & INDEX_UP))\n-\tinst.reloc.exp.X_add_number = -inst.reloc.exp.X_add_number;\n+\tinst.relocs[0].exp.X_add_number = -inst.relocs[0].exp.X_add_number;\n \n       if (!(inst.instruction & PRE_INDEX) && inst.operands[2].writeback)\n \t{\n@@ -10182,7 +10202,7 @@ do_iwmmxt_wldstd (void)\n       if (inst.operands[1].writeback)\n \tinst.instruction |= WRITE_BACK;\n       inst.instruction |= inst.operands[1].reg << 16;\n-      inst.instruction |= inst.reloc.exp.X_add_number << 4;\n+      inst.instruction |= inst.relocs[0].exp.X_add_number << 4;\n       inst.instruction |= inst.operands[1].imm;\n     }\n   else\n@@ -10354,7 +10374,7 @@ do_xsc_mra (void)\n static void\n encode_thumb32_shifted_operand (int i)\n {\n-  unsigned int value = inst.reloc.exp.X_add_number;\n+  unsigned int value = inst.relocs[0].exp.X_add_number;\n   unsigned int shift = inst.operands[i].shift_kind;\n \n   constraint (inst.operands[i].immisreg,\n@@ -10364,7 +10384,7 @@ encode_thumb32_shifted_operand (int i)\n     inst.instruction |= SHIFT_ROR << 4;\n   else\n     {\n-      constraint (inst.reloc.exp.X_op != O_constant,\n+      constraint (inst.relocs[0].exp.X_op != O_constant,\n \t\t  _(\"expression too complex\"));\n \n       constraint (value > 32\n@@ -10416,14 +10436,14 @@ encode_thumb32_addr_mode (int i, bfd_boolean is_t, bfd_boolean is_d)\n       inst.instruction |= inst.operands[i].imm;\n       if (inst.operands[i].shifted)\n \t{\n-\t  constraint (inst.reloc.exp.X_op != O_constant,\n+\t  constraint (inst.relocs[0].exp.X_op != O_constant,\n \t\t      _(\"expression too complex\"));\n-\t  constraint (inst.reloc.exp.X_add_number < 0\n-\t\t      || inst.reloc.exp.X_add_number > 3,\n+\t  constraint (inst.relocs[0].exp.X_add_number < 0\n+\t\t      || inst.relocs[0].exp.X_add_number > 3,\n \t\t      _(\"shift out of range\"));\n-\t  inst.instruction |= inst.reloc.exp.X_add_number << 4;\n+\t  inst.instruction |= inst.relocs[0].exp.X_add_number << 4;\n \t}\n-      inst.reloc.type = BFD_RELOC_UNUSED;\n+      inst.relocs[0].type = BFD_RELOC_UNUSED;\n     }\n   else if (inst.operands[i].preind)\n     {\n@@ -10445,7 +10465,7 @@ encode_thumb32_addr_mode (int i, bfd_boolean is_t, bfd_boolean is_d)\n \t  if (inst.operands[i].writeback)\n \t    inst.instruction |= 0x00000100;\n \t}\n-      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;\n+      inst.relocs[0].type = BFD_RELOC_ARM_T32_OFFSET_IMM;\n     }\n   else if (inst.operands[i].postind)\n     {\n@@ -10457,7 +10477,7 @@ encode_thumb32_addr_mode (int i, bfd_boolean is_t, bfd_boolean is_d)\n \tinst.instruction |= 0x00200000;\n       else\n \tinst.instruction |= 0x00000900;\n-      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;\n+      inst.relocs[0].type = BFD_RELOC_ARM_T32_OFFSET_IMM;\n     }\n   else /* unindexed - only for coprocessor */\n     inst.error = _(\"instruction does not accept unindexed addressing\");\n@@ -10589,7 +10609,7 @@ do_t_add_sub_w (void)\n     reject_bad_reg (Rd);\n \n   inst.instruction |= (Rn << 16) | (Rd << 8);\n-  inst.reloc.type = BFD_RELOC_ARM_T32_IMM12;\n+  inst.relocs[0].type = BFD_RELOC_ARM_T32_IMM12;\n }\n \n /* Parse an add or subtract instruction.  We get here with inst.instruction\n@@ -10651,11 +10671,12 @@ do_t_add_sub (void)\n \t\t{\n \t\t  inst.instruction = THUMB_OP16(opcode);\n \t\t  inst.instruction |= (Rd << 4) | Rs;\n-\t\t  if (inst.reloc.type < BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n-\t\t      || inst.reloc.type > BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC)\n+\t\t  if (inst.relocs[0].type < BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n+\t\t      || (inst.relocs[0].type\n+\t\t\t  > BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC))\n \t\t  {\n \t\t    if (inst.size_req == 2)\n-\t\t      inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;\n+\t\t      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_ADD;\n \t\t    else\n \t\t      inst.relax = opcode;\n \t\t  }\n@@ -10666,47 +10687,49 @@ do_t_add_sub (void)\n \t  if (inst.size_req == 4\n \t      || (inst.size_req != 2 && !opcode))\n \t    {\n-\t      constraint (inst.reloc.type >= BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n-\t\t\t  && inst.reloc.type <= BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC ,\n+\t      constraint ((inst.relocs[0].type\n+\t\t\t   >= BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC)\n+\t\t\t  && (inst.relocs[0].type\n+\t\t\t      <= BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC) ,\n \t\t\t  THUMB1_RELOC_ONLY);\n \t      if (Rd == REG_PC)\n \t\t{\n \t\t  constraint (add, BAD_PC);\n \t\t  constraint (Rs != REG_LR || inst.instruction != T_MNEM_subs,\n \t\t\t     _(\"only SUBS PC, LR, #const allowed\"));\n-\t\t  constraint (inst.reloc.exp.X_op != O_constant,\n+\t\t  constraint (inst.relocs[0].exp.X_op != O_constant,\n \t\t\t      _(\"expression too complex\"));\n-\t\t  constraint (inst.reloc.exp.X_add_number < 0\n-\t\t\t      || inst.reloc.exp.X_add_number > 0xff,\n+\t\t  constraint (inst.relocs[0].exp.X_add_number < 0\n+\t\t\t      || inst.relocs[0].exp.X_add_number > 0xff,\n \t\t\t     _(\"immediate value out of range\"));\n \t\t  inst.instruction = T2_SUBS_PC_LR\n-\t\t\t\t     | inst.reloc.exp.X_add_number;\n-\t\t  inst.reloc.type = BFD_RELOC_UNUSED;\n+\t\t\t\t     | inst.relocs[0].exp.X_add_number;\n+\t\t  inst.relocs[0].type = BFD_RELOC_UNUSED;\n \t\t  return;\n \t\t}\n \t      else if (Rs == REG_PC)\n \t\t{\n \t\t  /* Always use addw/subw.  */\n \t\t  inst.instruction = add ? 0xf20f0000 : 0xf2af0000;\n-\t\t  inst.reloc.type = BFD_RELOC_ARM_T32_IMM12;\n+\t\t  inst.relocs[0].type = BFD_RELOC_ARM_T32_IMM12;\n \t\t}\n \t      else\n \t\t{\n \t\t  inst.instruction = THUMB_OP32 (inst.instruction);\n \t\t  inst.instruction = (inst.instruction & 0xe1ffffff)\n \t\t\t\t     | 0x10000000;\n \t\t  if (flags)\n-\t\t    inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;\n+\t\t    inst.relocs[0].type = BFD_RELOC_ARM_T32_IMMEDIATE;\n \t\t  else\n-\t\t    inst.reloc.type = BFD_RELOC_ARM_T32_ADD_IMM;\n+\t\t    inst.relocs[0].type = BFD_RELOC_ARM_T32_ADD_IMM;\n \t\t}\n \t      inst.instruction |= Rd << 8;\n \t      inst.instruction |= Rs << 16;\n \t    }\n \t}\n       else\n \t{\n-\t  unsigned int value = inst.reloc.exp.X_add_number;\n+\t  unsigned int value = inst.relocs[0].exp.X_add_number;\n \t  unsigned int shift = inst.operands[2].shift_kind;\n \n \t  Rn = inst.operands[2].reg;\n@@ -10782,7 +10805,7 @@ do_t_add_sub (void)\n \t  inst.instruction = (inst.instruction == T_MNEM_add\n \t\t\t      ? 0x0000 : 0x8000);\n \t  inst.instruction |= (Rd << 4) | Rs;\n-\t  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;\n+\t  inst.relocs[0].type = BFD_RELOC_ARM_THUMB_ADD;\n \t  return;\n \t}\n \n@@ -10833,24 +10856,24 @@ do_t_adr (void)\n       /* Generate a 32-bit opcode.  */\n       inst.instruction = THUMB_OP32 (inst.instruction);\n       inst.instruction |= Rd << 8;\n-      inst.reloc.type = BFD_RELOC_ARM_T32_ADD_PC12;\n-      inst.reloc.pc_rel = 1;\n+      inst.relocs[0].type = BFD_RELOC_ARM_T32_ADD_PC12;\n+      inst.relocs[0].pc_rel = 1;\n     }\n   else\n     {\n       /* Generate a 16-bit opcode.  */\n       inst.instruction = THUMB_OP16 (inst.instruction);\n-      inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;\n-      inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */\n-      inst.reloc.pc_rel = 1;\n+      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_ADD;\n+      inst.relocs[0].exp.X_add_number -= 4; /* PC relative adjust.  */\n+      inst.relocs[0].pc_rel = 1;\n       inst.instruction |= Rd << 4;\n     }\n \n-  if (inst.reloc.exp.X_op == O_symbol\n-      && inst.reloc.exp.X_add_symbol != NULL\n-      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)\n-      && THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))\n-    inst.reloc.exp.X_add_number += 1;\n+  if (inst.relocs[0].exp.X_op == O_symbol\n+      && inst.relocs[0].exp.X_add_symbol != NULL\n+      && S_IS_DEFINED (inst.relocs[0].exp.X_add_symbol)\n+      && THUMB_IS_FUNC (inst.relocs[0].exp.X_add_symbol))\n+    inst.relocs[0].exp.X_add_number += 1;\n }\n \n /* Arithmetic instructions for which there is just one 16-bit\n@@ -10885,7 +10908,7 @@ do_t_arit3 (void)\n \t  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;\n \t  inst.instruction |= Rd << 8;\n \t  inst.instruction |= Rs << 16;\n-\t  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;\n+\t  inst.relocs[0].type = BFD_RELOC_ARM_T32_IMMEDIATE;\n \t}\n       else\n \t{\n@@ -10973,7 +10996,7 @@ do_t_arit3c (void)\n \t  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;\n \t  inst.instruction |= Rd << 8;\n \t  inst.instruction |= Rs << 16;\n-\t  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;\n+\t  inst.relocs[0].type = BFD_RELOC_ARM_T32_IMMEDIATE;\n \t}\n       else\n \t{\n@@ -11166,7 +11189,7 @@ do_t_branch (void)\n       && (inst.size_req == 4\n \t  || (inst.size_req != 2\n \t      && (inst.operands[0].hasreloc\n-\t\t  || inst.reloc.exp.X_op == O_constant))))\n+\t\t  || inst.relocs[0].exp.X_op == O_constant))))\n     {\n       inst.instruction = THUMB_OP32(opcode);\n       if (cond == COND_ALWAYS)\n@@ -11196,8 +11219,8 @@ do_t_branch (void)\n       if (unified_syntax && inst.size_req != 2)\n \tinst.relax = opcode;\n     }\n-  inst.reloc.type = reloc;\n-  inst.reloc.pc_rel = 1;\n+  inst.relocs[0].type = reloc;\n+  inst.relocs[0].pc_rel = 1;\n }\n \n /* Actually do the work for Thumb state bkpt and hlt.  The only difference\n@@ -11241,20 +11264,20 @@ do_t_branch23 (void)\n      the branch encoding is now needed to deal with TLSCALL relocs.\n      So if we see a PLT reloc now, put it back to how it used to be to\n      keep the preexisting behaviour.  */\n-  if (inst.reloc.type == BFD_RELOC_ARM_PLT32)\n-    inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH23;\n+  if (inst.relocs[0].type == BFD_RELOC_ARM_PLT32)\n+    inst.relocs[0].type = BFD_RELOC_THUMB_PCREL_BRANCH23;\n \n #if defined(OBJ_COFF)\n   /* If the destination of the branch is a defined symbol which does not have\n      the THUMB_FUNC attribute, then we must be calling a function which has\n      the (interfacearm) attribute.  We look for the Thumb entry point to that\n      function and change the branch to refer to that function instead.\t*/\n-  if (\t inst.reloc.exp.X_op == O_symbol\n-      && inst.reloc.exp.X_add_symbol != NULL\n-      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)\n-      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))\n-    inst.reloc.exp.X_add_symbol =\n-      find_real_start (inst.reloc.exp.X_add_symbol);\n+  if (\t inst.relocs[0].exp.X_op == O_symbol\n+      && inst.relocs[0].exp.X_add_symbol != NULL\n+      && S_IS_DEFINED (inst.relocs[0].exp.X_add_symbol)\n+      && ! THUMB_IS_FUNC (inst.relocs[0].exp.X_add_symbol))\n+    inst.relocs[0].exp.X_add_symbol\n+      = find_real_start (inst.relocs[0].exp.X_add_symbol);\n #endif\n }\n \n@@ -11362,8 +11385,8 @@ do_t_cbz (void)\n   set_it_insn_type (OUTSIDE_IT_INSN);\n   constraint (inst.operands[0].reg > 7, BAD_HIREG);\n   inst.instruction |= inst.operands[0].reg;\n-  inst.reloc.pc_rel = 1;\n-  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH7;\n+  inst.relocs[0].pc_rel = 1;\n+  inst.relocs[0].type = BFD_RELOC_THUMB_PCREL_BRANCH7;\n }\n \n static void\n@@ -11511,7 +11534,7 @@ static void\n do_t_ldmstm (void)\n {\n   /* This really doesn't seem worth it.  */\n-  constraint (inst.reloc.type != BFD_RELOC_UNUSED,\n+  constraint (inst.relocs[0].type != BFD_RELOC_UNUSED,\n \t      _(\"expression too complex\"));\n   constraint (inst.operands[1].writeback,\n \t      _(\"Thumb load/store multiple does not support {reglist}^\"));\n@@ -11648,7 +11671,7 @@ do_t_ldrex (void)\n \n   inst.instruction |= inst.operands[0].reg << 12;\n   inst.instruction |= inst.operands[1].reg << 16;\n-  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;\n+  inst.relocs[0].type = BFD_RELOC_ARM_T32_OFFSET_U8;\n }\n \n static void\n@@ -11718,7 +11741,7 @@ do_t_ldst (void)\n \t\t{\n \t\t  if (Rn == REG_PC)\n \t\t    {\n-\t\t      if (inst.reloc.pc_rel)\n+\t\t      if (inst.relocs[0].pc_rel)\n \t\t\topcode = T_MNEM_ldr_pc2;\n \t\t      else\n \t\t\topcode = T_MNEM_ldr_pc;\n@@ -11739,7 +11762,7 @@ do_t_ldst (void)\n \t\t}\n \t      inst.instruction |= THUMB_OP16 (opcode);\n \t      if (inst.size_req == 2)\n-\t\tinst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;\n+\t\tinst.relocs[0].type = BFD_RELOC_ARM_THUMB_OFFSET;\n \t      else\n \t\tinst.relax = opcode;\n \t      return;\n@@ -11818,7 +11841,7 @@ do_t_ldst (void)\n \tinst.instruction = T_OPCODE_STR_SP;\n \n       inst.instruction |= inst.operands[0].reg << 8;\n-      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;\n+      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_OFFSET;\n       return;\n     }\n \n@@ -11828,7 +11851,7 @@ do_t_ldst (void)\n       /* Immediate offset.  */\n       inst.instruction |= inst.operands[0].reg;\n       inst.instruction |= inst.operands[1].reg << 3;\n-      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;\n+      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_OFFSET;\n       return;\n     }\n \n@@ -12026,25 +12049,27 @@ do_t_mov_cmp (void)\n \t    {\n \t      inst.instruction = THUMB_OP16 (opcode);\n \t      inst.instruction |= Rn << 8;\n-\t      if (inst.reloc.type < BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n-\t\t  || inst.reloc.type > BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC)\n+\t      if (inst.relocs[0].type < BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n+\t\t  || inst.relocs[0].type > BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC)\n \t\t{\n \t\t  if (inst.size_req == 2)\n-\t\t    inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;\n+\t\t    inst.relocs[0].type = BFD_RELOC_ARM_THUMB_IMM;\n \t\t  else\n \t\t    inst.relax = opcode;\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      constraint (inst.reloc.type >= BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC\n-\t\t\t  && inst.reloc.type <= BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC ,\n+\t      constraint ((inst.relocs[0].type\n+\t\t\t   >= BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC)\n+\t\t\t  && (inst.relocs[0].type\n+\t\t\t      <= BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC) ,\n \t\t\t  THUMB1_RELOC_ONLY);\n \n \t      inst.instruction = THUMB_OP32 (inst.instruction);\n \t      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;\n \t      inst.instruction |= Rn << r0off;\n-\t      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;\n+\t      inst.relocs[0].type = BFD_RELOC_ARM_T32_IMMEDIATE;\n \t    }\n \t}\n       else if (inst.operands[1].shifted && inst.operands[1].immisreg\n@@ -12131,7 +12156,7 @@ do_t_mov_cmp (void)\n \t    {\n \t      inst.instruction |= Rn;\n \t      inst.instruction |= Rm << 3;\n-\t      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;\n+\t      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_SHIFT;\n \t    }\n \t  else\n \t    {\n@@ -12222,7 +12247,7 @@ do_t_mov_cmp (void)\n       constraint (Rn > 7,\n \t\t  _(\"only lo regs allowed with immediate\"));\n       inst.instruction |= Rn << 8;\n-      inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;\n+      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_IMM;\n     }\n }\n \n@@ -12234,24 +12259,24 @@ do_t_mov16 (void)\n   bfd_boolean top;\n \n   top = (inst.instruction & 0x00800000) != 0;\n-  if (inst.reloc.type == BFD_RELOC_ARM_MOVW)\n+  if (inst.relocs[0].type == BFD_RELOC_ARM_MOVW)\n     {\n       constraint (top, _(\":lower16: not allowed in this instruction\"));\n-      inst.reloc.type = BFD_RELOC_ARM_THUMB_MOVW;\n+      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_MOVW;\n     }\n-  else if (inst.reloc.type == BFD_RELOC_ARM_MOVT)\n+  else if (inst.relocs[0].type == BFD_RELOC_ARM_MOVT)\n     {\n       constraint (!top, _(\":upper16: not allowed in this instruction\"));\n-      inst.reloc.type = BFD_RELOC_ARM_THUMB_MOVT;\n+      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_MOVT;\n     }\n \n   Rd = inst.operands[0].reg;\n   reject_bad_reg (Rd);\n \n   inst.instruction |= Rd << 8;\n-  if (inst.reloc.type == BFD_RELOC_UNUSED)\n+  if (inst.relocs[0].type == BFD_RELOC_UNUSED)\n     {\n-      imm = inst.reloc.exp.X_add_number;\n+      imm = inst.relocs[0].exp.X_add_number;\n       inst.instruction |= (imm & 0xf000) << 4;\n       inst.instruction |= (imm & 0x0800) << 15;\n       inst.instruction |= (imm & 0x0700) << 4;\n@@ -12301,7 +12326,7 @@ do_t_mvn_tst (void)\n \t    inst.instruction = THUMB_OP32 (inst.instruction);\n \t  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;\n \t  inst.instruction |= Rn << r0off;\n-\t  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;\n+\t  inst.relocs[0].type = BFD_RELOC_ARM_T32_IMMEDIATE;\n \t}\n       else\n \t{\n@@ -12613,7 +12638,7 @@ do_t_orn (void)\n   if (!inst.operands[2].isreg)\n     {\n       inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;\n-      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;\n+      inst.relocs[0].type = BFD_RELOC_ARM_T32_IMMEDIATE;\n     }\n   else\n     {\n@@ -12647,8 +12672,8 @@ do_t_pkhbt (void)\n   inst.instruction |= Rm;\n   if (inst.operands[3].present)\n     {\n-      unsigned int val = inst.reloc.exp.X_add_number;\n-      constraint (inst.reloc.exp.X_op != O_constant,\n+      unsigned int val = inst.relocs[0].exp.X_add_number;\n+      constraint (inst.relocs[0].exp.X_op != O_constant,\n \t\t  _(\"expression too complex\"));\n       inst.instruction |= (val & 0x1c) << 10;\n       inst.instruction |= (val & 0x03) << 6;\n@@ -12688,7 +12713,7 @@ do_t_push_pop (void)\n \n   constraint (inst.operands[0].writeback,\n \t      _(\"push/pop do not support {reglist}^\"));\n-  constraint (inst.reloc.type != BFD_RELOC_UNUSED,\n+  constraint (inst.relocs[0].type != BFD_RELOC_UNUSED,\n \t      _(\"expression too complex\"));\n \n   mask = inst.operands[0].imm;\n@@ -12806,23 +12831,23 @@ do_t_rsb (void)\n       if (inst.size_req == 4 || !unified_syntax)\n \tnarrow = FALSE;\n \n-      if (inst.reloc.exp.X_op != O_constant\n-\t  || inst.reloc.exp.X_add_number != 0)\n+      if (inst.relocs[0].exp.X_op != O_constant\n+\t  || inst.relocs[0].exp.X_add_number != 0)\n \tnarrow = FALSE;\n \n       /* Turn rsb #0 into 16-bit neg.  We should probably do this via\n \t relaxation, but it doesn't seem worth the hassle.  */\n       if (narrow)\n \t{\n-\t  inst.reloc.type = BFD_RELOC_UNUSED;\n+\t  inst.relocs[0].type = BFD_RELOC_UNUSED;\n \t  inst.instruction = THUMB_OP16 (T_MNEM_negs);\n \t  inst.instruction |= Rs << 3;\n \t  inst.instruction |= Rd;\n \t}\n       else\n \t{\n \t  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;\n-\t  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;\n+\t  inst.relocs[0].type = BFD_RELOC_ARM_T32_IMMEDIATE;\n \t}\n     }\n   else\n@@ -12906,7 +12931,7 @@ do_t_shift (void)\n \t      inst.instruction |= inst.operands[0].reg << 8;\n \t      encode_thumb32_shifted_operand (1);\n \t      /* Prevent the incorrect generation of an ARM_IMMEDIATE fixup.  */\n-\t      inst.reloc.type = BFD_RELOC_UNUSED;\n+\t      inst.relocs[0].type = BFD_RELOC_UNUSED;\n \t    }\n \t}\n       else\n@@ -12938,7 +12963,7 @@ do_t_shift (void)\n \t\tcase SHIFT_LSR: inst.instruction = T_OPCODE_LSR_I; break;\n \t\tdefault: abort ();\n \t\t}\n-\t      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;\n+\t      inst.relocs[0].type = BFD_RELOC_ARM_THUMB_SHIFT;\n \t      inst.instruction |= inst.operands[0].reg;\n \t      inst.instruction |= inst.operands[1].reg << 3;\n \t    }\n@@ -12982,7 +13007,7 @@ do_t_shift (void)\n \t    case T_MNEM_ror: inst.error = _(\"ror #imm not supported\"); return;\n \t    default: abort ();\n \t    }\n-\t  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;\n+\t  inst.relocs[0].type = BFD_RELOC_ARM_THUMB_SHIFT;\n \t  inst.instruction |= inst.operands[0].reg;\n \t  inst.instruction |= inst.operands[1].reg << 3;\n \t}\n@@ -13028,12 +13053,12 @@ do_t_simd2 (void)\n static void\n do_t_smc (void)\n {\n-  unsigned int value = inst.reloc.exp.X_add_number;\n+  unsigned int value = inst.relocs[0].exp.X_add_number;\n   constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7a),\n \t      _(\"SMC is not permitted on this architecture\"));\n-  constraint (inst.reloc.exp.X_op != O_constant,\n+  constraint (inst.relocs[0].exp.X_op != O_constant,\n \t      _(\"expression too complex\"));\n-  inst.reloc.type = BFD_RELOC_UNUSED;\n+  inst.relocs[0].type = BFD_RELOC_UNUSED;\n   inst.instruction |= (value & 0xf000) >> 12;\n   inst.instruction |= (value & 0x0ff0);\n   inst.instruction |= (value & 0x000f) << 16;\n@@ -13044,9 +13069,9 @@ do_t_smc (void)\n static void\n do_t_hvc (void)\n {\n-  unsigned int value = inst.reloc.exp.X_add_number;\n+  unsigned int value = inst.relocs[0].exp.X_add_number;\n \n-  inst.reloc.type = BFD_RELOC_UNUSED;\n+  inst.relocs[0].type = BFD_RELOC_UNUSED;\n   inst.instruction |= (value & 0x0fff);\n   inst.instruction |= (value & 0xf000) << 4;\n }\n@@ -13068,11 +13093,11 @@ do_t_ssat_usat (int bias)\n \n   if (inst.operands[3].present)\n     {\n-      offsetT shift_amount = inst.reloc.exp.X_add_number;\n+      offsetT shift_amount = inst.relocs[0].exp.X_add_number;\n \n-      inst.reloc.type = BFD_RELOC_UNUSED;\n+      inst.relocs[0].type = BFD_RELOC_UNUSED;\n \n-      constraint (inst.reloc.exp.X_op != O_constant,\n+      constraint (inst.relocs[0].exp.X_op != O_constant,\n \t\t  _(\"expression too complex\"));\n \n       if (shift_amount != 0)\n@@ -13125,7 +13150,7 @@ do_t_strex (void)\n   inst.instruction |= inst.operands[0].reg << 8;\n   inst.instruction |= inst.operands[1].reg << 12;\n   inst.instruction |= inst.operands[2].reg << 16;\n-  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;\n+  inst.relocs[0].type = BFD_RELOC_ARM_T32_OFFSET_U8;\n }\n \n static void\n@@ -13203,7 +13228,7 @@ do_t_sxth (void)\n static void\n do_t_swi (void)\n {\n-  inst.reloc.type = BFD_RELOC_ARM_SWI;\n+  inst.relocs[0].type = BFD_RELOC_ARM_SWI;\n }\n \n static void\n@@ -17360,8 +17385,8 @@ do_neon_ldx_stx (void)\n   else\n     {\n       constraint (inst.operands[1].immisreg, BAD_ADDR_MODE);\n-      constraint (inst.reloc.exp.X_op != O_constant\n-\t\t  || inst.reloc.exp.X_add_number != 0,\n+      constraint (inst.relocs[0].exp.X_op != O_constant\n+\t\t  || inst.relocs[0].exp.X_add_number != 0,\n \t\t  BAD_ADDR_MODE);\n \n       if (inst.operands[1].writeback)\n@@ -17584,8 +17609,9 @@ do_vcmla (void)\n {\n   constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_armv8),\n \t      _(BAD_FPU));\n-  constraint (inst.reloc.exp.X_op != O_constant, _(\"expression too complex\"));\n-  unsigned rot = inst.reloc.exp.X_add_number;\n+  constraint (inst.relocs[0].exp.X_op != O_constant,\n+\t      _(\"expression too complex\"));\n+  unsigned rot = inst.relocs[0].exp.X_add_number;\n   constraint (rot != 0 && rot != 90 && rot != 180 && rot != 270,\n \t      _(\"immediate out of range\"));\n   rot /= 90;\n@@ -17625,8 +17651,9 @@ do_vcadd (void)\n {\n   constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_armv8),\n \t      _(BAD_FPU));\n-  constraint (inst.reloc.exp.X_op != O_constant, _(\"expression too complex\"));\n-  unsigned rot = inst.reloc.exp.X_add_number;\n+  constraint (inst.relocs[0].exp.X_op != O_constant,\n+\t      _(\"expression too complex\"));\n+  unsigned rot = inst.relocs[0].exp.X_add_number;\n   constraint (rot != 90 && rot != 270, _(\"immediate out of range\"));\n   enum neon_shape rs = neon_select_shape (NS_DDDI, NS_QQQI, NS_NULL);\n   unsigned size = neon_check_type (3, rs, N_EQK, N_EQK,\n@@ -17976,18 +18003,18 @@ output_relax_insn (void)\n      start of the instruction.  */\n   dwarf2_emit_insn (0);\n \n-  switch (inst.reloc.exp.X_op)\n+  switch (inst.relocs[0].exp.X_op)\n     {\n     case O_symbol:\n-      sym = inst.reloc.exp.X_add_symbol;\n-      offset = inst.reloc.exp.X_add_number;\n+      sym = inst.relocs[0].exp.X_add_symbol;\n+      offset = inst.relocs[0].exp.X_add_number;\n       break;\n     case O_constant:\n       sym = NULL;\n-      offset = inst.reloc.exp.X_add_number;\n+      offset = inst.relocs[0].exp.X_add_number;\n       break;\n     default:\n-      sym = make_expr_symbol (&inst.reloc.exp);\n+      sym = make_expr_symbol (&inst.relocs[0].exp);\n       offset = 0;\n       break;\n   }\n@@ -18043,10 +18070,14 @@ output_inst (const char * str)\n   else\n     md_number_to_chars (to, inst.instruction, inst.size);\n \n-  if (inst.reloc.type != BFD_RELOC_UNUSED)\n-    fix_new_arm (frag_now, to - frag_now->fr_literal,\n-\t\t inst.size, & inst.reloc.exp, inst.reloc.pc_rel,\n-\t\t inst.reloc.type);\n+  int r;\n+  for (r = 0; r < ARM_IT_MAX_RELOCS; r++)\n+    {\n+      if (inst.relocs[r].type != BFD_RELOC_UNUSED)\n+\tfix_new_arm (frag_now, to - frag_now->fr_literal,\n+\t\t     inst.size, & inst.relocs[r].exp, inst.relocs[r].pc_rel,\n+\t\t     inst.relocs[r].type);\n+    }\n \n   dwarf2_emit_insn (inst.size);\n }\n@@ -18771,7 +18802,9 @@ md_assemble (char *str)\n     }\n \n   memset (&inst, '\\0', sizeof (inst));\n-  inst.reloc.type = BFD_RELOC_UNUSED;\n+  int r;\n+  for (r = 0; r < ARM_IT_MAX_RELOCS; r++)\n+    inst.relocs[r].type = BFD_RELOC_UNUSED;\n \n   opcode = opcode_lookup (&p);\n   if (!opcode)"
    }
  ]
}