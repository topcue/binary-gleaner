{
  "sha": "0826b30a9fa085ccee574465523d0560a4a01198",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDgyNmIzMGE5ZmEwODVjY2VlNTc0NDY1NTIzZDA1NjBhNGEwMTE5OA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-26T15:28:08Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-26T15:28:28Z"
    },
    "message": "Change two functions to be methods on struct attribute\n\nThis changes dwarf2_get_ref_die_offset and\ndwarf2_get_attr_constant_value to be methods on struct attribute.\n\ngdb/ChangeLog\n2020-03-26  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.c (handle_data_member_location, dwarf2_add_field)\n\t(mark_common_block_symbol_computed, read_tag_string_type)\n\t(attr_to_dynamic_prop, read_subrange_type): Update.\n\t(dwarf2_get_ref_die_offset, dwarf2_get_attr_constant_value): Move\n\tto be methods on struct attribute.\n\t(skip_one_die, process_imported_unit_die, read_namespace_alias)\n\t(read_call_site_scope, partial_die_info::read)\n\t(partial_die_info::read, lookup_die_type, follow_die_ref):\n\tUpdate.\n\t* dwarf2/attribute.c (attribute::get_ref_die_offset): New method,\n\tfrom dwarf2_get_ref_die_offset.\n\t(attribute::constant_value): New method, from\n\tdwarf2_get_attr_constant_value.\n\t* dwarf2/attribute.h (struct attribute) <get_ref_die_offset>:\n\tDeclare method.\n\t<constant_value>: New method.",
    "tree": {
      "sha": "db67aeae32f988166c068b8841e96181c97f8861",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/db67aeae32f988166c068b8841e96181c97f8861"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0826b30a9fa085ccee574465523d0560a4a01198",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0826b30a9fa085ccee574465523d0560a4a01198",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0826b30a9fa085ccee574465523d0560a4a01198",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0826b30a9fa085ccee574465523d0560a4a01198/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2b2558bfacba3813863da6728c021eb89fa34677",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b2558bfacba3813863da6728c021eb89fa34677",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2b2558bfacba3813863da6728c021eb89fa34677"
    }
  ],
  "stats": {
    "total": 146,
    "additions": 86,
    "deletions": 60
  },
  "files": [
    {
      "sha": "049f52d3cc31919c214dbfaf045afa76920bf151",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0826b30a9fa085ccee574465523d0560a4a01198/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0826b30a9fa085ccee574465523d0560a4a01198/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=0826b30a9fa085ccee574465523d0560a4a01198",
      "patch": "@@ -1,3 +1,22 @@\n+2020-03-26  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.c (handle_data_member_location, dwarf2_add_field)\n+\t(mark_common_block_symbol_computed, read_tag_string_type)\n+\t(attr_to_dynamic_prop, read_subrange_type): Update.\n+\t(dwarf2_get_ref_die_offset, dwarf2_get_attr_constant_value): Move\n+\tto be methods on struct attribute.\n+\t(skip_one_die, process_imported_unit_die, read_namespace_alias)\n+\t(read_call_site_scope, partial_die_info::read)\n+\t(partial_die_info::read, lookup_die_type, follow_die_ref):\n+\tUpdate.\n+\t* dwarf2/attribute.c (attribute::get_ref_die_offset): New method,\n+\tfrom dwarf2_get_ref_die_offset.\n+\t(attribute::constant_value): New method, from\n+\tdwarf2_get_attr_constant_value.\n+\t* dwarf2/attribute.h (struct attribute) <get_ref_die_offset>:\n+\tDeclare method.\n+\t<constant_value>: New method.\n+\n 2020-03-26  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (dwarf_unit_type_name, dwarf_tag_name)"
    },
    {
      "sha": "0e5a8c8f536fef71e7ca917bbc73a60ff80b3a50",
      "filename": "gdb/dwarf2/attribute.c",
      "status": "modified",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0826b30a9fa085ccee574465523d0560a4a01198/gdb/dwarf2/attribute.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0826b30a9fa085ccee574465523d0560a4a01198/gdb/dwarf2/attribute.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.c?ref=0826b30a9fa085ccee574465523d0560a4a01198",
      "patch": "@@ -26,6 +26,8 @@\n \n #include \"defs.h\"\n #include \"dwarf2/attribute.h\"\n+#include \"dwarf2/stringify.h\"\n+#include \"complaints.h\"\n \n /* See attribute.h.  */\n \n@@ -119,3 +121,38 @@ attribute::form_is_ref () const\n       return false;\n     }\n }\n+\n+/* See attribute.h.  */\n+\n+sect_offset\n+attribute::get_ref_die_offset () const\n+{\n+  if (form_is_ref ())\n+    return (sect_offset) DW_UNSND (this);\n+\n+  complaint (_(\"unsupported die ref attribute form: '%s'\"),\n+\t     dwarf_form_name (form));\n+  return {};\n+}\n+\n+/* See attribute.h.  */\n+\n+LONGEST\n+attribute::constant_value (int default_value) const\n+{\n+  if (form == DW_FORM_sdata || form == DW_FORM_implicit_const)\n+    return DW_SND (this);\n+  else if (form == DW_FORM_udata\n+\t   || form == DW_FORM_data1\n+\t   || form == DW_FORM_data2\n+\t   || form == DW_FORM_data4\n+\t   || form == DW_FORM_data8)\n+    return DW_UNSND (this);\n+  else\n+    {\n+      /* For DW_FORM_data16 see attribute::form_is_constant.  */\n+      complaint (_(\"Attribute value is not a constant (%s)\"),\n+\t\t dwarf_form_name (form));\n+      return default_value;\n+    }\n+}"
    },
    {
      "sha": "483b805433b644d56dd51535df355fc06044d94c",
      "filename": "gdb/dwarf2/attribute.h",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0826b30a9fa085ccee574465523d0560a4a01198/gdb/dwarf2/attribute.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0826b30a9fa085ccee574465523d0560a4a01198/gdb/dwarf2/attribute.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.h?ref=0826b30a9fa085ccee574465523d0560a4a01198",
      "patch": "@@ -28,6 +28,7 @@\n #define GDB_DWARF2_ATTRIBUTE_H\n \n #include \"dwarf2.h\"\n+#include \"gdbtypes.h\"\n \n /* Blocks are a bunch of untyped bytes.  */\n struct dwarf_block\n@@ -84,6 +85,17 @@ struct attribute\n \n   bool form_is_block () const;\n \n+  /* Return DIE offset of this attribute.  Return 0 with complaint if\n+     the attribute is not of the required kind.  */\n+\n+  sect_offset get_ref_die_offset () const;\n+\n+  /* Return the constant value held by this attribute.  Return\n+     DEFAULT_VALUE if the value held by the attribute is not\n+     constant.  */\n+\n+  LONGEST constant_value (int default_value) const;\n+\n \n   ENUM_BITFIELD(dwarf_attribute) name : 16;\n   ENUM_BITFIELD(dwarf_form) form : 15;"
    },
    {
      "sha": "2465ecebe34ae284312ce1421e14a3fbe44fa967",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 18,
      "deletions": 60,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0826b30a9fa085ccee574465523d0560a4a01198/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0826b30a9fa085ccee574465523d0560a4a01198/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=0826b30a9fa085ccee574465523d0560a4a01198",
      "patch": "@@ -1419,10 +1419,6 @@ static void dump_die_1 (struct ui_file *, int level, int max_level,\n static void store_in_ref_table (struct die_info *,\n \t\t\t\tstruct dwarf2_cu *);\n \n-static sect_offset dwarf2_get_ref_die_offset (const struct attribute *);\n-\n-static LONGEST dwarf2_get_attr_constant_value (const struct attribute *, int);\n-\n static struct die_info *follow_die_ref_or_sig (struct die_info *,\n \t\t\t\t\t       const struct attribute *,\n \t\t\t\t\t       struct dwarf2_cu **);\n@@ -8476,7 +8472,7 @@ skip_one_die (const struct die_reader_specs *reader, const gdb_byte *info_ptr,\n \t    complaint (_(\"ignoring absolute DW_AT_sibling\"));\n \t  else\n \t    {\n-\t      sect_offset off = dwarf2_get_ref_die_offset (&attr);\n+\t      sect_offset off = attr.get_ref_die_offset ();\n \t      const gdb_byte *sibling_ptr = buffer + to_underlying (off);\n \n \t      if (sibling_ptr < info_ptr)\n@@ -9643,7 +9639,7 @@ process_imported_unit_die (struct die_info *die, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_import, cu);\n   if (attr != NULL)\n     {\n-      sect_offset sect_off = dwarf2_get_ref_die_offset (attr);\n+      sect_offset sect_off = attr->get_ref_die_offset ();\n       bool is_dwz = (attr->form == DW_FORM_GNU_ref_alt || cu->per_cu->is_dwz);\n       dwarf2_per_cu_data *per_cu\n \t= dwarf2_find_containing_comp_unit (sect_off, is_dwz,\n@@ -10296,7 +10292,7 @@ read_namespace_alias (struct die_info *die, struct dwarf2_cu *cu)\n       if (attr != NULL)\n \t{\n \t  struct type *type;\n-\t  sect_offset sect_off = dwarf2_get_ref_die_offset (attr);\n+\t  sect_offset sect_off = attr->get_ref_die_offset ();\n \n \t  type = get_die_type_at_offset (sect_off, cu->per_cu);\n \t  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_NAMESPACE)\n@@ -13224,8 +13220,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t{\n \t  parameter->kind = CALL_SITE_PARAMETER_PARAM_OFFSET;\n \n-\t  sect_offset sect_off\n-\t    = (sect_offset) dwarf2_get_ref_die_offset (origin);\n+\t  sect_offset sect_off = origin->get_ref_die_offset ();\n \t  if (!cu->header.offset_in_cu_p (sect_off))\n \t    {\n \t      /* As DW_OP_GNU_parameter_ref uses CU-relative offset this\n@@ -14059,7 +14054,7 @@ handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,\n \t so if we see it, we can assume that a constant form is really\n \t a constant and not a section offset.  */\n       if (attr->form_is_constant ())\n-\t*offset = dwarf2_get_attr_constant_value (attr, 0);\n+\t*offset = attr->constant_value (0);\n       else if (attr->form_is_section_offset ())\n \tdwarf2_complex_location_expr_complaint ();\n       else if (attr->form_is_block ())\n@@ -14186,7 +14181,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       attr = dwarf2_attr (die, DW_AT_data_bit_offset, cu);\n       if (attr != NULL)\n \tSET_FIELD_BITPOS (*fp, (FIELD_BITPOS (*fp)\n-\t\t\t\t+ dwarf2_get_attr_constant_value (attr, 0)));\n+\t\t\t\t+ attr->constant_value (0)));\n \n       /* Get name of field.  */\n       fieldname = dwarf2_name (die, cu);\n@@ -15860,7 +15855,7 @@ mark_common_block_symbol_computed (struct symbol *sym,\n \n   if (member_loc->form_is_constant ())\n     {\n-      offset = dwarf2_get_attr_constant_value (member_loc, 0);\n+      offset = member_loc->constant_value (0);\n       baton->size += 1 /* DW_OP_addr */ + cu->header.addr_size;\n     }\n   else\n@@ -16452,7 +16447,7 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n \t{\n \t  /* Pass 0 as the default as we know this attribute is constant\n \t     and the default value will not be returned.  */\n-\t  LONGEST sz = dwarf2_get_attr_constant_value (len, 0);\n+\t  LONGEST sz = len->constant_value (0);\n \t  prop_type = cu->per_cu->int_type (sz, true);\n \t}\n       else\n@@ -16474,12 +16469,12 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n \t indirection.  There's no need to create a dynamic property in this\n \t case.  Pass 0 for the default value as we know it will not be\n \t returned in this case.  */\n-      length = dwarf2_get_attr_constant_value (attr, 0);\n+      length = attr->constant_value (0);\n     }\n   else if ((attr = dwarf2_attr (die, DW_AT_byte_size, cu)) != nullptr)\n     {\n       /* We don't currently support non-constant byte sizes for strings.  */\n-      length = dwarf2_get_attr_constant_value (attr, 1);\n+      length = attr->constant_value (1);\n     }\n   else\n     {\n@@ -17058,7 +17053,7 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n     }\n   else if (attr->form_is_constant ())\n     {\n-      prop->data.const_val = dwarf2_get_attr_constant_value (attr, 0);\n+      prop->data.const_val = attr->constant_value (0);\n       prop->kind = PROP_CONST;\n     }\n   else\n@@ -17236,7 +17231,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n   LONGEST bias = 0;\n   struct attribute *bias_attr = dwarf2_attr (die, DW_AT_GNU_bias, cu);\n   if (bias_attr != nullptr && bias_attr->form_is_constant ())\n-    bias = dwarf2_get_attr_constant_value (bias_attr, 0);\n+    bias = bias_attr->constant_value (0);\n \n   /* Normally, the DWARF producers are expected to use a signed\n      constant form (Eg. DW_FORM_sdata) to express negative bounds.\n@@ -17942,7 +17937,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \tcase DW_AT_specification:\n \tcase DW_AT_extension:\n \t  has_specification = 1;\n-\t  spec_offset = dwarf2_get_ref_die_offset (&attr);\n+\t  spec_offset = attr.get_ref_die_offset ();\n \t  spec_is_dwz = (attr.form == DW_FORM_GNU_ref_alt\n \t\t\t\t   || cu->per_cu->is_dwz);\n \t  break;\n@@ -17954,7 +17949,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t  else\n \t    {\n \t      const gdb_byte *buffer = reader->buffer;\n-\t      sect_offset off = dwarf2_get_ref_die_offset (&attr);\n+\t      sect_offset off = attr.get_ref_die_offset ();\n \t      const gdb_byte *sibling_ptr = buffer + to_underlying (off);\n \n \t      if (sibling_ptr < info_ptr)\n@@ -17999,7 +17994,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \tcase DW_AT_import:\n \t  if (tag == DW_TAG_imported_unit)\n \t    {\n-\t      d.sect_off = dwarf2_get_ref_die_offset (&attr);\n+\t      d.sect_off = attr.get_ref_die_offset ();\n \t      is_dwz = (attr.form == DW_FORM_GNU_ref_alt\n \t\t\t\t  || cu->per_cu->is_dwz);\n \t    }\n@@ -20701,15 +20696,15 @@ lookup_die_type (struct die_info *die, const struct attribute *attr,\n   if (attr->form == DW_FORM_GNU_ref_alt)\n     {\n       struct dwarf2_per_cu_data *per_cu;\n-      sect_offset sect_off = dwarf2_get_ref_die_offset (attr);\n+      sect_offset sect_off = attr->get_ref_die_offset ();\n \n       per_cu = dwarf2_find_containing_comp_unit (sect_off, 1,\n \t\t\t\t\t\t dwarf2_per_objfile);\n       this_type = get_die_type_at_offset (sect_off, per_cu);\n     }\n   else if (attr->form_is_ref ())\n     {\n-      sect_offset sect_off = dwarf2_get_ref_die_offset (attr);\n+      sect_offset sect_off = attr->get_ref_die_offset ();\n \n       this_type = get_die_type_at_offset (sect_off, cu->per_cu);\n     }\n@@ -21511,43 +21506,6 @@ store_in_ref_table (struct die_info *die, struct dwarf2_cu *cu)\n   *slot = die;\n }\n \n-/* Return DIE offset of ATTR.  Return 0 with complaint if ATTR is not of the\n-   required kind.  */\n-\n-static sect_offset\n-dwarf2_get_ref_die_offset (const struct attribute *attr)\n-{\n-  if (attr->form_is_ref ())\n-    return (sect_offset) DW_UNSND (attr);\n-\n-  complaint (_(\"unsupported die ref attribute form: '%s'\"),\n-\t     dwarf_form_name (attr->form));\n-  return {};\n-}\n-\n-/* Return the constant value held by ATTR.  Return DEFAULT_VALUE if\n- * the value held by the attribute is not constant.  */\n-\n-static LONGEST\n-dwarf2_get_attr_constant_value (const struct attribute *attr, int default_value)\n-{\n-  if (attr->form == DW_FORM_sdata || attr->form == DW_FORM_implicit_const)\n-    return DW_SND (attr);\n-  else if (attr->form == DW_FORM_udata\n-           || attr->form == DW_FORM_data1\n-           || attr->form == DW_FORM_data2\n-           || attr->form == DW_FORM_data4\n-           || attr->form == DW_FORM_data8)\n-    return DW_UNSND (attr);\n-  else\n-    {\n-      /* For DW_FORM_data16 see attribute::form_is_constant.  */\n-      complaint (_(\"Attribute value is not a constant (%s)\"),\n-                 dwarf_form_name (attr->form));\n-      return default_value;\n-    }\n-}\n-\n /* Follow reference or signature attribute ATTR of SRC_DIE.\n    On entry *REF_CU is the CU of SRC_DIE.\n    On exit *REF_CU is the CU of the result.  */\n@@ -21638,7 +21596,7 @@ static struct die_info *\n follow_die_ref (struct die_info *src_die, const struct attribute *attr,\n \t\tstruct dwarf2_cu **ref_cu)\n {\n-  sect_offset sect_off = dwarf2_get_ref_die_offset (attr);\n+  sect_offset sect_off = attr->get_ref_die_offset ();\n   struct dwarf2_cu *cu = *ref_cu;\n   struct die_info *die;\n "
    }
  ]
}