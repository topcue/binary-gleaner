{
  "sha": "8915c559d40186064d0be75229f9b4e5ac649b16",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODkxNWM1NTlkNDAxODYwNjRkMGJlNzUyMjlmOWI0ZTVhYzY0OWIxNg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-02T15:10:05Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-02T15:10:05Z"
    },
    "message": "libctf, include: remove the nondeduplicating CTF linker\n\nThe nondeduplicating CTF linker was kept around when the deduplicating\none was added so that people had something to fall back to in case the\ndeduplicating linker turned out to be buggy.  It's now much more stable\nthan the nondeduplicating linker, in addition to much faster, using much\nless memory and producing much better output.  In addition, while\nlibctf has a linker flag to invoke the nondeduplicating linker, ld does\nnot expose it: the only way to turn it on within ld is an intentionally-\nundocumented environment variable.  So we can remove it without any ABI\nor user-visibility concerns (the only thing we leave around is the\nCTF_LINK_NONDEDUP flag, which can easily be interpreted as \"deduplicate\nless\", though right now it does nothing).\n\nThis lets us remove a lot of complexity associated with tracking\nfilenames and CU names separately (something the deduplcating linker\nnever bothered with, since the cunames are always reliable and ld never\nhands us useful filenames anyway)\n\nThe biggest lacuna left behind is the ctf_type_mapping machinery, which\nslows down deduplicating links quite a lot.  We can't just ditch it\nbecause ctf_add_type uses it: removing the slowdown from the\ndeduplicating linker is a job for another commit.\n\ninclude/ChangeLog\n2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-api.h (CTF_LINK_SHARE_DUPLICATED): Note that this might\n\tmerely change how much deduplication is done.\n\nlibctf/ChangeLog\n2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-link.c (ctf_create_per_cu): Drop FILENAME now that it is\n\talways identical to CUNAME.\n\t(ctf_link_deduplicating_one_symtypetab): Adjust.\n\t(ctf_link_one_type): Remove.\n\t(ctf_link_one_input_archive_member): Likewise.\n\t(ctf_link_close_one_input_archive): Likewise.\n\t(ctf_link_one_input_archive): Likewise.\n\t(ctf_link): No longer call it.  Drop CTF_LINK_NONDEDUP path.\n\tImprove header comment a bit (dicts, not files).  Adjust\n\tctf_create_per_cu call.\n\t(ctf_link_deduplicating_variables): Simplify.\n\t(ctf_link_in_member_cb_arg_t) <cu_name>: Remove.\n\t<in_input_cu_file>: Likewise.\n\t<in_fp_parent>: Likewise.\n\t<done_parent>: Likewise.\n\t(ctf_link_one_variable): Turn uses of in_file_name to in_cuname.",
    "tree": {
      "sha": "1e64aa681aafe4ec0deaa22ce1362cf6db2d4aff",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1e64aa681aafe4ec0deaa22ce1362cf6db2d4aff"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8915c559d40186064d0be75229f9b4e5ac649b16",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8915c559d40186064d0be75229f9b4e5ac649b16",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8915c559d40186064d0be75229f9b4e5ac649b16",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8915c559d40186064d0be75229f9b4e5ac649b16/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fd12633780a9f5a5541e0999749c67b562ee9a16",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd12633780a9f5a5541e0999749c67b562ee9a16",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fd12633780a9f5a5541e0999749c67b562ee9a16"
    }
  ],
  "stats": {
    "total": 277,
    "additions": 46,
    "deletions": 231
  },
  "files": [
    {
      "sha": "d287b78870fad335c26df92f9265c836d55d8e55",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8915c559d40186064d0be75229f9b4e5ac649b16/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8915c559d40186064d0be75229f9b4e5ac649b16/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=8915c559d40186064d0be75229f9b4e5ac649b16",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (CTF_LINK_SHARE_DUPLICATED): Note that this might\n+\tmerely change how much deduplication is done.\n+\n 2021-03-01  Alan Modra  <amodra@gmail.com>\n \t    Fangrui Song <maskray@google.com>\n "
    },
    {
      "sha": "25dbe9ec53358f8db14218083fdd3cb3a2f93a89",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8915c559d40186064d0be75229f9b4e5ac649b16/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8915c559d40186064d0be75229f9b4e5ac649b16/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=8915c559d40186064d0be75229f9b4e5ac649b16",
      "patch": "@@ -94,7 +94,8 @@ typedef struct ctf_link_sym\n /* Share only types that are used by multiple inputs.  */\n #define CTF_LINK_SHARE_DUPLICATED 0x1\n \n-/* Do a nondeduplicating link.  */\n+/* Do a nondeduplicating link, or otherwise deduplicate \"less hard\", trading off\n+   CTF output size for link time.  */\n #define CTF_LINK_NONDEDUP 0x2\n \n /* Create empty outputs for all registered CU mappings even if no types are"
    },
    {
      "sha": "5c38c6f391bee911adb187c3ffe1eae1cd4a9c6d",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8915c559d40186064d0be75229f9b4e5ac649b16/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8915c559d40186064d0be75229f9b4e5ac649b16/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=8915c559d40186064d0be75229f9b4e5ac649b16",
      "patch": "@@ -1,3 +1,22 @@\n+2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-link.c (ctf_create_per_cu): Drop FILENAME now that it is\n+\talways identical to CUNAME.\n+\t(ctf_link_deduplicating_one_symtypetab): Adjust.\n+\t(ctf_link_one_type): Remove.\n+\t(ctf_link_one_input_archive_member): Likewise.\n+\t(ctf_link_close_one_input_archive): Likewise.\n+\t(ctf_link_one_input_archive): Likewise.\n+\t(ctf_link): No longer call it.  Drop CTF_LINK_NONDEDUP path.\n+\tImprove header comment a bit (dicts, not files).  Adjust\n+\tctf_create_per_cu call.\n+\t(ctf_link_deduplicating_variables): Simplify.\n+\t(ctf_link_in_member_cb_arg_t) <cu_name>: Remove.\n+\t<in_input_cu_file>: Likewise.\n+\t<in_fp_parent>: Likewise.\n+\t<done_parent>: Likewise.\n+\t(ctf_link_one_variable): Turn uses of in_file_name to in_cuname.\n+\n 2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-types.c (ctf_member_iter): Move 'rc' to an inner scope."
    },
    {
      "sha": "5d813dbf8b3c6ae7854090912e4bb1249dc2187d",
      "filename": "libctf/ctf-link.c",
      "status": "modified",
      "additions": 20,
      "deletions": 230,
      "changes": 250,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8915c559d40186064d0be75229f9b4e5ac649b16/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8915c559d40186064d0be75229f9b4e5ac649b16/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=8915c559d40186064d0be75229f9b4e5ac649b16",
      "patch": "@@ -280,29 +280,24 @@ ctf_link_add_ctf (ctf_dict_t *fp, ctf_archive_t *ctf, const char *name)\n    interning it if need be.  */\n \n static ctf_dict_t *\n-ctf_create_per_cu (ctf_dict_t *fp, const char *filename, const char *cuname)\n+ctf_create_per_cu (ctf_dict_t *fp, const char *cu_name)\n {\n   ctf_dict_t *cu_fp;\n   const char *ctf_name = NULL;\n   char *dynname = NULL;\n \n   /* First, check the mapping table and translate the per-CU name we use\n-     accordingly.  We check both the input filename and the CU name.  Only if\n-     neither are set do we fall back to the input filename as the per-CU\n-     dictionary name.  We prefer the filename because this is easier for likely\n-     callers to determine.  */\n+     accordingly.  */\n \n   if (fp->ctf_link_in_cu_mapping)\n     {\n-      if (((ctf_name = ctf_dynhash_lookup (fp->ctf_link_in_cu_mapping,\n-\t\t\t\t\t   filename)) == NULL) &&\n-\t  ((ctf_name = ctf_dynhash_lookup (fp->ctf_link_in_cu_mapping,\n-\t\t\t\t\t   cuname)) == NULL))\n-\tctf_name = filename;\n+      if ((ctf_name = ctf_dynhash_lookup (fp->ctf_link_in_cu_mapping,\n+\t\t\t\t\t  cu_name)) == NULL)\n+\tctf_name = cu_name;\n     }\n \n   if (ctf_name == NULL)\n-    ctf_name = filename;\n+    ctf_name = cu_name;\n \n   if ((cu_fp = ctf_dynhash_lookup (fp->ctf_link_outputs, ctf_name)) == NULL)\n     {\n@@ -311,8 +306,7 @@ ctf_create_per_cu (ctf_dict_t *fp, const char *filename, const char *cuname)\n       if ((cu_fp = ctf_create (&err)) == NULL)\n \t{\n \t  ctf_err_warn (fp, 0, err, _(\"cannot create per-CU CTF archive for \"\n-\t\t\t\t      \"CU %s from input file %s\"),\n-\t\t\tcuname, filename);\n+\t\t\t\t      \"input CU %s\"), cu_name);\n \t  ctf_set_errno (fp, err);\n \t  return NULL;\n \t}\n@@ -323,7 +317,7 @@ ctf_create_per_cu (ctf_dict_t *fp, const char *filename, const char *cuname)\n \tgoto oom;\n \n       ctf_import_unref (cu_fp, fp);\n-      ctf_cuname_set (cu_fp, cuname);\n+      ctf_cuname_set (cu_fp, cu_name);\n       ctf_parent_name_set (cu_fp, _CTF_SECTION);\n     }\n   return cu_fp;\n@@ -440,93 +434,16 @@ typedef struct ctf_link_in_member_cb_arg\n   /* The shared output dictionary.  */\n   ctf_dict_t *out_fp;\n \n-  /* The filename of the input file, and an fp to each dictionary in that file\n+  /* The cuname of the input file, and an fp to each dictionary in that file\n      in turn.  */\n-  const char *in_file_name;\n+  const char *in_cuname;\n   ctf_dict_t *in_fp;\n \n-  /* The CU name of the dict being processed.  */\n-  const char *cu_name;\n-  int in_input_cu_file;\n-\n-  /* The parent dictionary in the input, and whether it's been processed yet.\n-     Not needed by ctf_link_one_type / ctf_link_one_variable, only by higher\n-     layers.  */\n-  ctf_dict_t *in_fp_parent;\n-  int done_parent;\n-\n   /* If true, this is the CU-mapped portion of a deduplicating link: no child\n      dictionaries should be created.  */\n   int cu_mapped;\n } ctf_link_in_member_cb_arg_t;\n \n-/* Link one type into the link.  We rely on ctf_add_type() to detect\n-   duplicates.  This is not terribly reliable yet (unnmamed types will be\n-   mindlessly duplicated), but will improve shortly.  */\n-\n-static int\n-ctf_link_one_type (ctf_id_t type, int isroot _libctf_unused_, void *arg_)\n-{\n-  ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n-  ctf_dict_t *per_cu_out_fp;\n-  int err;\n-\n-  if (arg->in_fp->ctf_link_flags != CTF_LINK_SHARE_UNCONFLICTED)\n-    {\n-      ctf_err_warn (arg->out_fp, 0, ECTF_NOTYET,\n-\t\t    _(\"share-duplicated mode not yet implemented\"));\n-      return ctf_set_errno (arg->out_fp, ECTF_NOTYET);\n-    }\n-\n-  /* Simply call ctf_add_type: if it reports a conflict and we're adding to the\n-     main CTF file, add to the per-CU archive member instead, creating it if\n-     necessary.  If we got this type from a per-CU archive member, add it\n-     straight back to the corresponding member in the output.  */\n-\n-  if (!arg->in_input_cu_file)\n-    {\n-      if (ctf_add_type (arg->out_fp, arg->in_fp, type) != CTF_ERR)\n-\treturn 0;\n-\n-      err = ctf_errno (arg->out_fp);\n-      if (err != ECTF_CONFLICT)\n-\t{\n-\t  if (err != ECTF_NONREPRESENTABLE)\n-\t    ctf_err_warn (arg->out_fp, 1, 0,\n-\t\t\t  _(\"cannot link type %lx from input file %s, CU %s \"\n-\t\t\t    \"into output link\"), type, arg->cu_name,\n-\t\t\t  arg->in_file_name);\n-\t  /* We must ignore this problem or we end up losing future types, then\n-\t     trying to link the variables in, then exploding.  Better to link as\n-\t     much as possible.  */\n-\t  return 0;\n-\t}\n-      ctf_set_errno (arg->out_fp, 0);\n-    }\n-\n-  if ((per_cu_out_fp = ctf_create_per_cu (arg->out_fp, arg->in_file_name,\n-\t\t\t\t\t  arg->cu_name)) == NULL)\n-    return -1;\t\t\t\t\t/* Errno is set for us.  */\n-\n-  if (ctf_add_type (per_cu_out_fp, arg->in_fp, type) != CTF_ERR)\n-    return 0;\n-\n-  err = ctf_errno (per_cu_out_fp);\n-  if (err != ECTF_NONREPRESENTABLE)\n-    ctf_err_warn (arg->out_fp, 1, 0,\n-\t\t  _(\"cannot link type %lx from input file %s, CU %s \"\n-\t\t    \"into output per-CU CTF archive member %s: %s: skipped\"),\n-\t\t  type, ctf_link_input_name (arg->in_fp), arg->in_file_name,\n-\t\t  ctf_link_input_name (per_cu_out_fp), ctf_errmsg (err));\n-  if (err == ECTF_CONFLICT)\n-      /* Conflicts are possible at this stage only if a non-ld user has combined\n-\t multiple TUs into a single output dictionary.  Even in this case we do not\n-\t want to stop the link or propagate the error.  */\n-      ctf_set_errno (arg->out_fp, 0);\n-\n-  return 0;\t\t\t\t\t/* As above: do not lose types.  */\n-}\n-\n /* Set a function which is used to filter out unwanted variables from the link.  */\n int\n ctf_link_set_variable_filter (ctf_dict_t *fp, ctf_link_variable_filter_f *filter,\n@@ -615,13 +532,12 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n   if (arg->cu_mapped)\n     {\n       ctf_dprintf (\"Variable %s in input file %s depends on a type %lx hidden \"\n-\t\t   \"due to conflicts: skipped.\\n\", name, arg->in_file_name,\n+\t\t   \"due to conflicts: skipped.\\n\", name, arg->in_cuname,\n \t\t   type);\n       return 0;\n     }\n \n-  if ((per_cu_out_fp = ctf_create_per_cu (arg->out_fp, arg->in_file_name,\n-\t\t\t\t\t  arg->cu_name)) == NULL)\n+  if ((per_cu_out_fp = ctf_create_per_cu (arg->out_fp, arg->in_cuname)) == NULL)\n     return -1;\t\t\t\t\t/* Errno is set for us.  */\n \n   /* If the type was not found, check for it in the child too.  */\n@@ -635,7 +551,7 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n \t  ctf_err_warn (arg->out_fp, 1, 0,\n \t\t\t_(\"type %lx for variable %s in input file %s \"\n \t\t\t  \"not found: skipped\"), type, name,\n-\t\t\targ->in_file_name);\n+\t\t\targ->in_cuname);\n \t  /* Do not terminate the link: just skip the variable.  */\n \t  return 0;\n \t}\n@@ -647,55 +563,6 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n   return 0;\n }\n \n-/* Merge every type (and optionally, variable) in this archive member into the\n-   link, so we can relink things that have already had ld run on them.  We use\n-   the archive member name, sans any leading '.ctf.', as the CU name for\n-   ambiguous types if there is one and it's not the default: otherwise, we use\n-   the name of the input file.  */\n-static int\n-ctf_link_one_input_archive_member (ctf_dict_t *in_fp, const char *name, void *arg_)\n-{\n-  ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n-  int err = 0;\n-\n-  if (strcmp (name, _CTF_SECTION) == 0)\n-    {\n-      /* This file is the default member of this archive, and has already been\n-\t explicitly processed.\n-\n-\t In the default sharing mode of CTF_LINK_SHARE_UNCONFLICTED, it does no\n-\t harm to rescan an existing shared repo again: all the types will just\n-\t end up in the same place.  But in CTF_LINK_SHARE_DUPLICATED mode, this\n-\t causes the system to erroneously conclude that all types are duplicated\n-\t and should be shared, even if they are not.  */\n-\n-      if (arg->done_parent)\n-\treturn 0;\n-    }\n-  else\n-    {\n-      /* Get ambiguous types from our parent.  */\n-      ctf_import (in_fp, arg->in_fp_parent);\n-      arg->in_input_cu_file = 1;\n-    }\n-\n-  arg->cu_name = name;\n-  if (strncmp (arg->cu_name, \".ctf.\", strlen (\".ctf.\")) == 0)\n-    arg->cu_name += strlen (\".ctf.\");\n-  arg->in_fp = in_fp;\n-\n-  if ((err = ctf_type_iter_all (in_fp, ctf_link_one_type, arg)) > -1)\n-    if (!(in_fp->ctf_link_flags & CTF_LINK_OMIT_VARIABLES_SECTION))\n-      err = ctf_variable_iter (in_fp, ctf_link_one_variable, arg);\n-\n-  arg->in_input_cu_file = 0;\n-\n-  if (err < 0)\n-      return -1;\t\t\t\t/* Errno is set for us.  */\n-\n-  return 0;\n-}\n-\n /* Dump the unnecessary link type mapping after one input file is processed.  */\n static void\n empty_link_type_mapping (void *key _libctf_unused_, void *value,\n@@ -753,73 +620,6 @@ ctf_link_lazy_open (ctf_dict_t *fp, ctf_link_input_t *input)\n   return (ssize_t) count;\n }\n \n-/* Close an input, as a ctf_dynhash_iter iterator.  */\n-static void\n-ctf_link_close_one_input_archive (void *key _libctf_unused_, void *value,\n-\t\t\t\t  void *arg _libctf_unused_)\n-{\n-  ctf_link_input_t *input = (ctf_link_input_t *) value;\n-  if (input->clin_arc)\n-    ctf_arc_close (input->clin_arc);\n-  input->clin_arc = NULL;\n-}\n-\n-/* Link one input file's types into the output file.  */\n-static void\n-ctf_link_one_input_archive (void *key, void *value, void *arg_)\n-{\n-  const char *file_name = (const char *) key;\n-  ctf_link_input_t *input = (ctf_link_input_t *)value;\n-  ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n-  int err = 0;\n-\n-  if (!input->clin_arc)\n-    {\n-      err = ctf_link_lazy_open (arg->out_fp, input);\n-      if (err == 0)\t\t\t\t/* Just no CTF.  */\n-\treturn;\n-\n-      if (err < 0)\n-\treturn;\t\t\t\t\t/* errno is set for us.  */\n-    }\n-\n-  arg->in_file_name = file_name;\n-  arg->done_parent = 0;\n-  if ((arg->in_fp_parent = ctf_dict_open (input->clin_arc,\n-\t\t\t\t\t  NULL, &err)) == NULL)\n-    if (err != ECTF_ARNNAME)\n-      {\n-\tctf_err_warn (arg->out_fp, 1, 0,\n-\t\t      _(\"cannot open main archive member in input file %s \"\n-\t\t\t\"in the link: skipping: %s\"), arg->in_file_name,\n-\t\t      ctf_errmsg (err));\n-\tgoto out;\n-      }\n-\n-  if (ctf_link_one_input_archive_member (arg->in_fp_parent,\n-\t\t\t\t\t _CTF_SECTION, arg) < 0)\n-    {\n-      ctf_dict_close (arg->in_fp_parent);\n-      goto out;\n-    }\n-  arg->done_parent = 1;\n-  if (ctf_archive_iter (input->clin_arc, ctf_link_one_input_archive_member,\n-\t\t\targ) < 0)\n-    ctf_err_warn (arg->out_fp, 0, 0, _(\"cannot traverse archive in input file \"\n-\t\t\t\t       \"%s: link cannot continue\"),\n-\t\t  arg->in_file_name);\n-  else\n-    {\n-      /* The only error indication to the caller is the errno: so ensure that it\n-\t is zero if there was no actual error from the caller.  */\n-      ctf_set_errno (arg->out_fp, 0);\n-    }\n-  ctf_dict_close (arg->in_fp_parent);\n-\n- out:\n-  ctf_link_close_one_input_archive (key, value, NULL);\n-}\n-\n typedef struct link_sort_inputs_cb_arg\n {\n   int is_cu_mapped;\n@@ -1130,21 +930,16 @@ ctf_link_deduplicating_variables (ctf_dict_t *fp, ctf_dict_t **inputs,\n \n   arg.cu_mapped = cu_mapped;\n   arg.out_fp = fp;\n-  arg.in_input_cu_file = 0;\n \n   for (i = 0; i < ninputs; i++)\n     {\n       arg.in_fp = inputs[i];\n       if (ctf_cuname (inputs[i]) != NULL)\n-\targ.in_file_name = ctf_cuname (inputs[i]);\n+\targ.in_cuname = ctf_cuname (inputs[i]);\n       else\n-\targ.in_file_name = \"unnamed-CU\";\n-      arg.cu_name = arg.in_file_name;\n+\targ.in_cuname = \"unnamed-CU\";\n       if (ctf_variable_iter (arg.in_fp, ctf_link_one_variable, &arg) < 0)\n \treturn ctf_set_errno (fp, ctf_errno (arg.in_fp));\n-\n-      /* Outputs > 0 are per-CU.  */\n-      arg.in_input_cu_file = 1;\n     }\n   return 0;\n }\n@@ -1237,8 +1032,7 @@ ctf_link_deduplicating_one_symtypetab (ctf_dict_t *fp, ctf_dict_t *input,\n \t  continue;\n \t}\n \n-      if ((per_cu_out_fp = ctf_create_per_cu (fp, in_file_name,\n-\t\t\t\t\t      in_file_name)) == NULL)\n+      if ((per_cu_out_fp = ctf_create_per_cu (fp, in_file_name)) == NULL)\n \treturn -1;\t\t\t\t/* errno is set for us.  */\n \n       /* If the type was not found, check for it in the child too.  */\n@@ -1653,8 +1447,8 @@ ctf_link_deduplicating (ctf_dict_t *fp)\n   goto err;\n }\n \n-/* Merge types and variable sections in all files added to the link\n-   together.  All the added files are closed.  */\n+/* Merge types and variable sections in all dicts added to the link together.\n+   All the added dicts are closed.  */\n int\n ctf_link (ctf_dict_t *fp, int flags)\n {\n@@ -1691,7 +1485,7 @@ ctf_link (ctf_dict_t *fp, int flags)\n \t\t\t\t      NULL)) == 0)\n \t{\n \t  const char *to = (const char *) v;\n-\t  if (ctf_create_per_cu (fp, to, to) == NULL)\n+\t  if (ctf_create_per_cu (fp, to) == NULL)\n \t    {\n \t      fp->ctf_flags &= ~LCTF_LINKING;\n \t      ctf_next_destroy (i);\n@@ -1707,11 +1501,7 @@ ctf_link (ctf_dict_t *fp, int flags)\n \t}\n     }\n \n-  if ((flags & CTF_LINK_NONDEDUP) || (getenv (\"LD_NO_CTF_DEDUP\")))\n-    ctf_dynhash_iter (fp->ctf_link_inputs, ctf_link_one_input_archive,\n-\t\t      &arg);\n-  else\n-    ctf_link_deduplicating (fp);\n+  ctf_link_deduplicating (fp);\n \n   /* Discard the now-unnecessary mapping table data from all the outputs.  */\n   if (fp->ctf_link_type_mapping)"
    }
  ]
}