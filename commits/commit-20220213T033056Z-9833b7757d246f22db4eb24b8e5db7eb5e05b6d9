{
  "sha": "9833b7757d246f22db4eb24b8e5db7eb5e05b6d9",
  "node_id": "C_kwDOANOeidoAKDk4MzNiNzc1N2QyNDZmMjJkYjRlYjI0YjhlNWRiN2ViNWUwNWI2ZDk",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2022-01-27T04:47:16Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2022-02-13T03:30:56Z"
    },
    "message": "PR28824, relro security issues\n\nBackground\n==========\nThere are constraints on layout of binaries to meet demand paging and\nmemory protection requirements.  Demand paged binaries must have file\noffset mod pagesize equal to vma mod pagesize.  Memory protection\n(executable, read, write status) can only change at page boundaries.\nThe linker's MAXPAGESIZE variable gives the page size for these layout\nconstraints.\n\nIn a typical basic executable with two memory segments, text (RE) and\ndata (RW), the data segment must start on a different page to the\nlast text segment page.  For example, with 64k pages and a small\nexecutable of 48k text and 1k data, the text segment might start at\naddress 0x10000 and data at 0x20000 for a total of two 64k memory\npages.  Demand paging would require the image on disk to be 64k+1k\nin size.  We can do better than that.  If the data segment instead\nstarts at 0x2c000 (the end of the text segment plus one 64k page) then\nthere are still only two memory pages, but the disk image is now\nsmaller, 48k+1k in size.  This is why the linker normally starts the\ndata segment at the end of the text segment plus one page.  That\nsimple heuristic isn't ideal in all cases.  Changing our simple\nexample to one with 64k-1 text size, following that heuristic would\nresult in data starting at 0x2ffff.  Now we have two 64k memory data\npages for a data segment of 1k!  If the data segment instead started\nat 0x30000 we'd get a single data segment page at the cost of 1 byte\nextra in the disk image, which is likely a good trade-off.  So the\nlinker does adjust the simple heuristic.  Just how much disk image\nsize increase is allowed is controlled by the linker's COMMONPAGESIZE\nvariable.\n\nA PT_GNU_RELRO segment overlays the initial part of the data segment,\nsaying that those pages should be made read-only after relocation by\nthe dynamic loader.  Page granularity for memory protection means that\nthe end of the relro segment must be at a page boundary.\n\nThe problem\n===========\nUnfortunately most targets currently only align the end of the relro\nsegment to COMMONPAGESIZE.  That results in only partial relro\nprotection if an executable is running with MAXPAGESIZE pages, since\nany part of the relro segment past the last MAXPAGESIZE boundary can't\nbe made read-only without also affecting sections past the end of the\nrelro segment.  I believe this problem arose because x86 always runs\nwith 4k (COMMPAGESIZE) memory pages, and therefore using a larger\nMAXPAGESIZE on x86 is for reasons other than the demand paging and\nmemory page protection boundary requirements.\n\nThe solution\n============\nAlways end the relro segment on a MAXPAGESIZE boundary, except for\nx86.  Note that the relro segment, comprising of sections at the start\nof the data segment, is sized according to how those sections are laid\nout.  That means the start of the relro segment is fixed relative to\nits end.  Which also means the start of the data segment must be at a\nfixed address mod MAXPAGESIZE.  So for relro the linker can't play\ngames with the start of the data segment to save disk space.  At\nleast, not without introducing gaps between the relro sections.  In\nfact, because the linker was starting layout using its simple\nheuristic of starting the data segment at the end of the text segment\nplus one page, it was sometimes introducing page gaps for no reason.\nSee pr28743.\n\n\tPR 28824\n\tPR 28734\n\t* ldexp.c (fold_segment_align): When relro, don't adjust up by\n\toffset within page.  Set relropagesize.\n\t(fold_segment_relro_end): Align to relropagesize.\n\t* ldexp.h (seg_align_type): Rename pagesize to commonpagesize.\n\tAdd relropagesize.  Comment.\n\t* ldlang.c (lang_size_segment): Adjust to suit field renaming.\n\t(lang_size_relro_segment_1): Align relro_end using relropagesize.",
    "tree": {
      "sha": "b35cae2b1d24043f67809583e89d7c9550abce21",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b35cae2b1d24043f67809583e89d7c9550abce21"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f63300e0fae2c114186e1985ecbe5641e05c13c3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f63300e0fae2c114186e1985ecbe5641e05c13c3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f63300e0fae2c114186e1985ecbe5641e05c13c3"
    }
  ],
  "stats": {
    "total": 30,
    "additions": 17,
    "deletions": 13
  },
  "files": [
    {
      "sha": "a38cec7829d0fa91a55c52b53b0e385ffd2254fc",
      "filename": "ld/ldexp.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9/ld/ldexp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9/ld/ldexp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldexp.c?ref=9833b7757d246f22db4eb24b8e5db7eb5e05b6d9",
      "patch": "@@ -469,7 +469,8 @@ fold_segment_align (seg_align_type *seg, etree_value_type *lhs)\n \t}\n       else\n \t{\n-\t  expld.result.value += expld.dot & (maxpage - 1);\n+\t  if (!link_info.relro)\n+\t    expld.result.value += expld.dot & (maxpage - 1);\n \t  if (seg->phase == exp_seg_done)\n \t    {\n \t      /* OK.  */\n@@ -478,8 +479,9 @@ fold_segment_align (seg_align_type *seg, etree_value_type *lhs)\n \t    {\n \t      seg->phase = exp_seg_align_seen;\n \t      seg->base = expld.result.value;\n-\t      seg->pagesize = commonpage;\n+\t      seg->commonpagesize = commonpage;\n \t      seg->maxpagesize = maxpage;\n+\t      seg->relropagesize = maxpage;\n \t      seg->relro_end = 0;\n \t    }\n \t  else\n@@ -508,10 +510,10 @@ fold_segment_relro_end (seg_align_type *seg, etree_value_type *lhs)\n \tseg->relro_end = lhs->value + expld.result.value;\n \n       if (seg->phase == exp_seg_relro_adjust\n-\t  && (seg->relro_end & (seg->pagesize - 1)))\n+\t  && (seg->relro_end & (seg->relropagesize - 1)))\n \t{\n-\t  seg->relro_end += seg->pagesize - 1;\n-\t  seg->relro_end &= ~(seg->pagesize - 1);\n+\t  seg->relro_end += seg->relropagesize - 1;\n+\t  seg->relro_end &= ~(seg->relropagesize - 1);\n \t  expld.result.value = seg->relro_end - expld.result.value;\n \t}\n       else"
    },
    {
      "sha": "ed6fb8be715d40a1cdb8c239fe68e25a01868521",
      "filename": "ld/ldexp.h",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9/ld/ldexp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9/ld/ldexp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldexp.h?ref=9833b7757d246f22db4eb24b8e5db7eb5e05b6d9",
      "patch": "@@ -136,7 +136,10 @@ enum relro_enum {\n typedef struct {\n   enum phase_enum phase;\n \n-  bfd_vma base, relro_offset, relro_end, end, pagesize, maxpagesize;\n+  bfd_vma base, relro_offset, relro_end, end;\n+  /* MAXPAGESIZE and COMMMONPAGESIZE as passed to DATA_SEGMENT_ALIGN.\n+     relropagesize sets the alignment of the end of the relro segment.  */\n+  bfd_vma maxpagesize, commonpagesize, relropagesize;\n \n   enum relro_enum relro;\n "
    },
    {
      "sha": "f481586a7bad44e099836eb923131618d1eac7d9",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9833b7757d246f22db4eb24b8e5db7eb5e05b6d9/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=9833b7757d246f22db4eb24b8e5db7eb5e05b6d9",
      "patch": "@@ -6352,12 +6352,12 @@ lang_size_segment (seg_align_type *seg)\n      a page could be saved in the data segment.  */\n   bfd_vma first, last;\n \n-  first = -seg->base & (seg->pagesize - 1);\n-  last = seg->end & (seg->pagesize - 1);\n+  first = -seg->base & (seg->commonpagesize - 1);\n+  last = seg->end & (seg->commonpagesize - 1);\n   if (first && last\n-      && ((seg->base & ~(seg->pagesize - 1))\n-\t  != (seg->end & ~(seg->pagesize - 1)))\n-      && first + last <= seg->pagesize)\n+      && ((seg->base & ~(seg->commonpagesize - 1))\n+\t  != (seg->end & ~(seg->commonpagesize - 1)))\n+      && first + last <= seg->commonpagesize)\n     {\n       seg->phase = exp_seg_adjust;\n       return true;\n@@ -6374,8 +6374,7 @@ lang_size_relro_segment_1 (seg_align_type *seg)\n   asection *sec;\n \n   /* Compute the expected PT_GNU_RELRO/PT_LOAD segment end.  */\n-  relro_end = ((seg->relro_end + seg->pagesize - 1)\n-\t       & ~(seg->pagesize - 1));\n+  relro_end = (seg->relro_end + seg->relropagesize - 1) & -seg->relropagesize;\n \n   /* Adjust by the offset arg of XXX_SEGMENT_RELRO_END.  */\n   desired_end = relro_end - seg->relro_offset;"
    }
  ]
}