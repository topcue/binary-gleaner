{
  "sha": "529908cbd0afc2524044b7df3626c09d0bdae12d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTI5OTA4Y2JkMGFmYzI1MjQwNDRiN2RmMzYyNmMwOWQwYmRhZTEyZA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-30T00:49:08Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-30T02:29:07Z"
    },
    "message": "Remove DW_UNSND\n\nThis removes DW_UNSND, replacing uses with either as_unsigned or\nconstant_value, depending primarily on whether or not the form is\nalready known to be appropriate.\n\ngdb/ChangeLog\n2020-09-29  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.c (lookup_dwo_id, get_type_unit_group)\n\t(read_file_scope, dwarf2_get_pc_bounds)\n\t(dwarf2_record_block_ranges, dwarf2_add_field, get_alignment)\n\t(read_structure_type, handle_struct_member_die)\n\t(read_enumeration_type, read_array_type, read_set_type)\n\t(read_tag_pointer_type, read_tag_reference_type)\n\t(read_subroutine_type, read_base_type, read_subrange_type)\n\t(read_full_die_1, partial_die_info::read)\n\t(partial_die_info::read, by, new_symbol)\n\t(dwarf2_const_value_data, dwarf2_const_value_attr)\n\t(dump_die_shallow, dwarf2_fetch_constant_bytes)\n\t(prepare_one_comp_unit): Update.\n\t* dwarf2/attribute.h (DW_UNSND): Remove.",
    "tree": {
      "sha": "6413c3f83a42fe114ef51d04bb1408688d0f4477",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6413c3f83a42fe114ef51d04bb1408688d0f4477"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/529908cbd0afc2524044b7df3626c09d0bdae12d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/529908cbd0afc2524044b7df3626c09d0bdae12d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/529908cbd0afc2524044b7df3626c09d0bdae12d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/529908cbd0afc2524044b7df3626c09d0bdae12d/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c45bc3f8ab3b657912f07c7823ad58ba4f9fe3f1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c45bc3f8ab3b657912f07c7823ad58ba4f9fe3f1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c45bc3f8ab3b657912f07c7823ad58ba4f9fe3f1"
    }
  ],
  "stats": {
    "total": 191,
    "additions": 102,
    "deletions": 89
  },
  "files": [
    {
      "sha": "9c802c57ef4b5b4a7005c075831bc2a13e45cb63",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/529908cbd0afc2524044b7df3626c09d0bdae12d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/529908cbd0afc2524044b7df3626c09d0bdae12d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=529908cbd0afc2524044b7df3626c09d0bdae12d",
      "patch": "@@ -1,3 +1,19 @@\n+2020-09-29  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.c (lookup_dwo_id, get_type_unit_group)\n+\t(read_file_scope, dwarf2_get_pc_bounds)\n+\t(dwarf2_record_block_ranges, dwarf2_add_field, get_alignment)\n+\t(read_structure_type, handle_struct_member_die)\n+\t(read_enumeration_type, read_array_type, read_set_type)\n+\t(read_tag_pointer_type, read_tag_reference_type)\n+\t(read_subroutine_type, read_base_type, read_subrange_type)\n+\t(read_full_die_1, partial_die_info::read)\n+\t(partial_die_info::read, by, new_symbol)\n+\t(dwarf2_const_value_data, dwarf2_const_value_attr)\n+\t(dump_die_shallow, dwarf2_fetch_constant_bytes)\n+\t(prepare_one_comp_unit): Update.\n+\t* dwarf2/attribute.h (DW_UNSND): Remove.\n+\n 2020-09-29  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (read_func_scope, prototyped_function_p)"
    },
    {
      "sha": "aded129764a38ea09ef9d145181cf5b0ee224e6d",
      "filename": "gdb/dwarf2/attribute.h",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/529908cbd0afc2524044b7df3626c09d0bdae12d/gdb/dwarf2/attribute.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/529908cbd0afc2524044b7df3626c09d0bdae12d/gdb/dwarf2/attribute.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.h?ref=529908cbd0afc2524044b7df3626c09d0bdae12d",
      "patch": "@@ -305,8 +305,4 @@ struct attribute\n   void get_ref_die_offset_complaint () const;\n };\n \n-/* Get at parts of an attribute structure.  */\n-\n-#define DW_UNSND(attr)     ((attr)->u.unsnd)\n-\n #endif /* GDB_DWARF2_ATTRIBUTE_H */"
    },
    {
      "sha": "bcac94ed36adc18255518fa50eb41081ef980217",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 86,
      "deletions": 85,
      "changes": 171,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/529908cbd0afc2524044b7df3626c09d0bdae12d/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/529908cbd0afc2524044b7df3626c09d0bdae12d/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=529908cbd0afc2524044b7df3626c09d0bdae12d",
      "patch": "@@ -6985,9 +6985,9 @@ lookup_dwo_id (struct dwarf2_cu *cu, struct die_info* comp_unit_die)\n     return cu->header.signature;\n   struct attribute *attr;\n   attr = dwarf2_attr (comp_unit_die, DW_AT_GNU_dwo_id, cu);\n-  if (attr == nullptr)\n+  if (attr == nullptr || !attr->form_is_unsigned ())\n     return gdb::optional<ULONGEST> ();\n-  return DW_UNSND (attr);\n+  return attr->as_unsigned ();\n }\n \n /* Subroutine of cutu_reader to simplify it.\n@@ -7471,9 +7471,9 @@ get_type_unit_group (struct dwarf2_cu *cu, const struct attribute *stmt_list)\n \n   /* Do we need to create a new group, or can we use an existing one?  */\n \n-  if (stmt_list)\n+  if (stmt_list != nullptr && stmt_list->form_is_unsigned ())\n     {\n-      line_offset = DW_UNSND (stmt_list);\n+      line_offset = stmt_list->as_unsigned ();\n       ++tu_stats->nr_symtab_sharers;\n     }\n   else\n@@ -11147,19 +11147,19 @@ read_file_scope (struct die_info *die, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_macros, cu);\n   if (attr == NULL)\n     attr = dwarf2_attr (die, DW_AT_GNU_macros, cu);\n-  if (attr && cu->line_header)\n+  if (attr != nullptr && attr->form_is_unsigned () && cu->line_header)\n     {\n       if (dwarf2_attr (die, DW_AT_macro_info, cu))\n \tcomplaint (_(\"CU refers to both DW_AT_macros and DW_AT_macro_info\"));\n \n-      dwarf_decode_macros (cu, DW_UNSND (attr), 1);\n+      dwarf_decode_macros (cu, attr->as_unsigned (), 1);\n     }\n   else\n     {\n       attr = dwarf2_attr (die, DW_AT_macro_info, cu);\n-      if (attr && cu->line_header)\n+      if (attr != nullptr && attr->form_is_unsigned () && cu->line_header)\n \t{\n-\t  unsigned int macro_offset = DW_UNSND (attr);\n+\t  unsigned int macro_offset = attr->as_unsigned ();\n \n \t  dwarf_decode_macros (cu, macro_offset, 0);\n \t}\n@@ -14586,7 +14586,7 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n   else\n     {\n       attr = dwarf2_attr (die, DW_AT_ranges, cu);\n-      if (attr != NULL)\n+      if (attr != nullptr && attr->form_is_unsigned ())\n \t{\n \t  /* DW_AT_rnglists_base does not apply to DIEs from the DWO skeleton.\n \t     We take advantage of the fact that DW_AT_ranges does not appear\n@@ -14598,7 +14598,7 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n \t     either.  */\n \t  int need_ranges_base = (die->tag != DW_TAG_compile_unit\n \t\t\t\t  && attr->form != DW_FORM_rnglistx);\n-\t  unsigned int ranges_offset = (DW_UNSND (attr)\n+\t  unsigned int ranges_offset = (attr->as_unsigned ()\n \t\t\t\t\t+ (need_ranges_base\n \t\t\t\t\t   ? cu->ranges_base\n \t\t\t\t\t   : 0));\n@@ -14764,7 +14764,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n     }\n \n   attr = dwarf2_attr (die, DW_AT_ranges, cu);\n-  if (attr != nullptr)\n+  if (attr != nullptr && attr->form_is_unsigned ())\n     {\n       /* DW_AT_rnglists_base does not apply to DIEs from the DWO skeleton.\n \t We take advantage of the fact that DW_AT_ranges does not appear\n@@ -14779,7 +14779,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n \n       /* The value of the DW_AT_ranges attribute is the offset of the\n          address range list in the .debug_ranges section.  */\n-      unsigned long offset = (DW_UNSND (attr)\n+      unsigned long offset = (attr->as_unsigned ()\n \t\t\t      + (need_ranges_base ? cu->ranges_base : 0));\n \n       std::vector<blockrange> blockvec;\n@@ -15040,7 +15040,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       attr = dwarf2_attr (die, DW_AT_bit_size, cu);\n       if (attr != nullptr)\n \t{\n-\t  FIELD_BITSIZE (*fp) = DW_UNSND (attr);\n+\t  FIELD_BITSIZE (*fp) = attr->constant_value (0);\n \t}\n       else\n \t{\n@@ -15050,7 +15050,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       /* Get bit offset of field.  */\n       handle_data_member_location (die, cu, fp);\n       attr = dwarf2_attr (die, DW_AT_bit_offset, cu);\n-      if (attr != nullptr)\n+      if (attr != nullptr && attr->form_is_unsigned ())\n \t{\n \t  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)\n \t    {\n@@ -15059,7 +15059,8 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \t         anonymous object to the MSB of the field.  We don't\n \t         have to do anything special since we don't need to\n \t         know the size of the anonymous object.  */\n-\t      SET_FIELD_BITPOS (*fp, FIELD_BITPOS (*fp) + DW_UNSND (attr));\n+\t      SET_FIELD_BITPOS (*fp, (FIELD_BITPOS (*fp)\n+\t\t\t\t      + attr->as_unsigned ()));\n \t    }\n \t  else\n \t    {\n@@ -15070,15 +15071,15 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \t         the field itself.  The result is the bit offset of\n \t         the LSB of the field.  */\n \t      int anonymous_size;\n-\t      int bit_offset = DW_UNSND (attr);\n+\t      int bit_offset = attr->as_unsigned ();\n \n \t      attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-\t      if (attr != nullptr)\n+\t      if (attr != nullptr && attr->form_is_unsigned ())\n \t\t{\n \t\t  /* The size of the anonymous object containing\n \t\t     the bit field is explicit, so use the\n \t\t     indicated size (in bytes).  */\n-\t\t  anonymous_size = DW_UNSND (attr);\n+\t\t  anonymous_size = attr->as_unsigned ();\n \t\t}\n \t      else\n \t\t{\n@@ -15845,22 +15846,16 @@ get_alignment (struct dwarf2_cu *cu, struct die_info *die)\n       return 0;\n     }\n \n-  ULONGEST align;\n-  if (attr->form == DW_FORM_sdata)\n+  LONGEST val = attr->constant_value (0);\n+  if (val < 0)\n     {\n-      LONGEST val = attr->as_signed ();\n-      if (val < 0)\n-\t{\n-\t  complaint (_(\"DW_AT_alignment value must not be negative\"\n-\t\t       \" - DIE at %s [in module %s]\"),\n-\t\t     sect_offset_str (die->sect_off),\n-\t\t     objfile_name (cu->per_objfile->objfile));\n-\t  return 0;\n-\t}\n-      align = val;\n+      complaint (_(\"DW_AT_alignment value must not be negative\"\n+\t\t   \" - DIE at %s [in module %s]\"),\n+\t\t sect_offset_str (die->sect_off),\n+\t\t objfile_name (cu->per_objfile->objfile));\n+      return 0;\n     }\n-  else\n-    align = DW_UNSND (attr);\n+  ULONGEST align = val;\n \n   if (align == 0)\n     {\n@@ -16023,18 +16018,18 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n      the default value DW_CC_normal.  */\n   attr = dwarf2_attr (die, DW_AT_calling_convention, cu);\n   if (attr != nullptr\n-      && is_valid_DW_AT_calling_convention_for_type (DW_UNSND (attr)))\n+      && is_valid_DW_AT_calling_convention_for_type (attr->constant_value (0)))\n     {\n       ALLOCATE_CPLUS_STRUCT_TYPE (type);\n       TYPE_CPLUS_CALLING_CONVENTION (type)\n-\t= (enum dwarf_calling_convention) (DW_UNSND (attr));\n+\t= (enum dwarf_calling_convention) (attr->constant_value (0));\n     }\n \n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n   if (attr != nullptr)\n     {\n       if (attr->form_is_constant ())\n-        TYPE_LENGTH (type) = DW_UNSND (attr);\n+        TYPE_LENGTH (type) = attr->constant_value (0);\n       else\n \t{\n \t  struct dynamic_prop prop;\n@@ -16192,7 +16187,7 @@ handle_variant (struct die_info *die, struct type *type,\n \tvariant.discr_list_data = discr->as_block ();\n     }\n   else\n-    variant.discriminant_value = DW_UNSND (discr);\n+    variant.discriminant_value = discr->as_unsigned ();\n \n   for (die_info *variant_child = die->child;\n        variant_child != NULL;\n@@ -16589,7 +16584,7 @@ read_enumeration_type (struct die_info *die, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n   if (attr != nullptr)\n     {\n-      TYPE_LENGTH (type) = DW_UNSND (attr);\n+      TYPE_LENGTH (type) = attr->constant_value (0);\n     }\n   else\n     {\n@@ -16749,7 +16744,7 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   attr = dwarf2_attr (die, DW_AT_bit_stride, cu);\n   if (attr != NULL)\n-    bit_stride = DW_UNSND (attr);\n+    bit_stride = attr->constant_value (0);\n \n   /* Irix 6.2 native cc creates array types without children for\n      arrays with unspecified length.  */\n@@ -16815,10 +16810,10 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n      implementation may choose to implement triple vectors using this\n      attribute.  */\n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr != nullptr)\n+  if (attr != nullptr && attr->form_is_unsigned ())\n     {\n-      if (DW_UNSND (attr) >= TYPE_LENGTH (type))\n-\tTYPE_LENGTH (type) = DW_UNSND (attr);\n+      if (attr->as_unsigned () >= TYPE_LENGTH (type))\n+\tTYPE_LENGTH (type) = attr->as_unsigned ();\n       else\n \tcomplaint (_(\"DW_AT_byte_size for array type smaller \"\n \t\t     \"than the total size of elements\"));\n@@ -16895,8 +16890,8 @@ read_set_type (struct die_info *die, struct dwarf2_cu *cu)\n   set_type = create_set_type (NULL, domain_type);\n \n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr != nullptr)\n-    TYPE_LENGTH (set_type) = DW_UNSND (attr);\n+  if (attr != nullptr && attr->form_is_unsigned ())\n+    TYPE_LENGTH (set_type) = attr->as_unsigned ();\n \n   maybe_set_alignment (cu, die, set_type);\n \n@@ -17252,13 +17247,13 @@ read_tag_pointer_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   attr_byte_size = dwarf2_attr (die, DW_AT_byte_size, cu);\n   if (attr_byte_size)\n-    byte_size = DW_UNSND (attr_byte_size);\n+    byte_size = attr_byte_size->constant_value (cu_header->addr_size);\n   else\n     byte_size = cu_header->addr_size;\n \n   attr_address_class = dwarf2_attr (die, DW_AT_address_class, cu);\n   if (attr_address_class)\n-    addr_class = DW_UNSND (attr_address_class);\n+    addr_class = attr_address_class->constant_value (DW_ADDR_none);\n   else\n     addr_class = DW_ADDR_none;\n \n@@ -17362,7 +17357,7 @@ read_tag_reference_type (struct die_info *die, struct dwarf2_cu *cu,\n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n   if (attr != nullptr)\n     {\n-      TYPE_LENGTH (type) = DW_UNSND (attr);\n+      TYPE_LENGTH (type) = attr->constant_value (cu_header->addr_size);\n     }\n   else\n     {\n@@ -17649,9 +17644,9 @@ read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)\n      the default value DW_CC_normal.  */\n   attr = dwarf2_attr (die, DW_AT_calling_convention, cu);\n   if (attr != nullptr\n-      && is_valid_DW_AT_calling_convention_for_subroutine (DW_UNSND (attr)))\n+      && is_valid_DW_AT_calling_convention_for_subroutine (attr->constant_value (0)))\n     TYPE_CALLING_CONVENTION (ftype)\n-      = (enum dwarf_calling_convention) (DW_UNSND (attr));\n+      = (enum dwarf_calling_convention) attr->constant_value (0);\n   else if (cu->producer && strstr (cu->producer, \"IBM XL C for OpenCL\"))\n     TYPE_CALLING_CONVENTION (ftype) = DW_CC_GDB_IBM_OpenCL;\n   else\n@@ -17920,11 +17915,11 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n   gdbarch *arch;\n \n   attr = dwarf2_attr (die, DW_AT_encoding, cu);\n-  if (attr != nullptr)\n-    encoding = DW_UNSND (attr);\n+  if (attr != nullptr && attr->form_is_constant ())\n+    encoding = attr->constant_value (0);\n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n   if (attr != nullptr)\n-    bits = DW_UNSND (attr) * TARGET_CHAR_BIT;\n+    bits = attr->constant_value (0) * TARGET_CHAR_BIT;\n   name = dwarf2_name (die, cu);\n   if (!name)\n     complaint (_(\"DW_AT_name missing from DW_TAG_base_type\"));\n@@ -17933,9 +17928,9 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n   enum bfd_endian byte_order = gdbarch_byte_order (arch);\n \n   attr = dwarf2_attr (die, DW_AT_endianity, cu);\n-  if (attr)\n+  if (attr != nullptr && attr->form_is_constant ())\n     {\n-      int endianity = DW_UNSND (attr);\n+      int endianity = attr->constant_value (0);\n \n       switch (endianity)\n \t{\n@@ -18045,19 +18040,20 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n   if (TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_INT)\n     {\n       attr = dwarf2_attr (die, DW_AT_bit_size, cu);\n-      if (attr != nullptr && DW_UNSND (attr) <= 8 * TYPE_LENGTH (type))\n+      if (attr != nullptr && attr->as_unsigned () <= 8 * TYPE_LENGTH (type))\n \t{\n-\t  unsigned real_bit_size = DW_UNSND (attr);\n+\t  unsigned real_bit_size = attr->as_unsigned ();\n \t  attr = dwarf2_attr (die, DW_AT_data_bit_offset, cu);\n \t  /* Only use the attributes if they make sense together.  */\n \t  if (attr == nullptr\n-\t      || DW_UNSND (attr) + real_bit_size <= 8 * TYPE_LENGTH (type))\n+\t      || (attr->as_unsigned () + real_bit_size\n+\t\t  <= 8 * TYPE_LENGTH (type)))\n \t    {\n \t      TYPE_MAIN_TYPE (type)->type_specific.int_stuff.bit_size\n \t\t= real_bit_size;\n \t      if (attr != nullptr)\n \t\tTYPE_MAIN_TYPE (type)->type_specific.int_stuff.bit_offset\n-\t\t  = DW_UNSND (attr);\n+\t\t  = attr->as_unsigned ();\n \t    }\n \t}\n     }\n@@ -18420,7 +18416,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n   if (attr != nullptr)\n-    TYPE_LENGTH (range_type) = DW_UNSND (attr);\n+    TYPE_LENGTH (range_type) = attr->constant_value (0);\n \n   maybe_set_alignment (cu, die, range_type);\n \n@@ -18603,20 +18599,20 @@ read_full_die_1 (const struct die_reader_specs *reader,\n     }\n \n   struct attribute *attr = die->attr (DW_AT_str_offsets_base);\n-  if (attr != nullptr)\n-    cu->str_offsets_base = DW_UNSND (attr);\n+  if (attr != nullptr && attr->form_is_unsigned ())\n+    cu->str_offsets_base = attr->as_unsigned ();\n \n   attr = die->attr (DW_AT_loclists_base);\n   if (attr != nullptr)\n-    cu->loclist_base = DW_UNSND (attr);\n+    cu->loclist_base = attr->as_unsigned ();\n \n   auto maybe_addr_base = die->addr_base ();\n   if (maybe_addr_base.has_value ())\n     cu->addr_base = *maybe_addr_base;\n \n   attr = die->attr (DW_AT_rnglists_base);\n   if (attr != nullptr)\n-    cu->ranges_base = DW_UNSND (attr);\n+    cu->ranges_base = attr->as_unsigned ();\n \n   if (any_need_reprocess)\n     {\n@@ -19108,14 +19104,17 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t     Although DWARF now specifies a way to provide this\n \t     information, we support this practice for backward\n \t     compatibility.  */\n-\t  if (DW_UNSND (&attr) == DW_CC_program\n+\t  if (attr.constant_value (0) == DW_CC_program\n \t      && cu->language == language_fortran)\n \t    main_subprogram = 1;\n \t  break;\n \tcase DW_AT_inline:\n-\t  if (DW_UNSND (&attr) == DW_INL_inlined\n-\t      || DW_UNSND (&attr) == DW_INL_declared_inlined)\n-\t    may_be_inlined = 1;\n+\t  {\n+\t    LONGEST value = attr.constant_value (-1);\n+\t    if (value == DW_INL_inlined\n+\t\t|| value == DW_INL_declared_inlined)\n+\t      may_be_inlined = 1;\n+\t  }\n \t  break;\n \n \tcase DW_AT_import:\n@@ -19143,7 +19142,10 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t       base, either.  */\n \t    int need_ranges_base = (tag != DW_TAG_compile_unit\n \t\t\t\t    && attr.form != DW_FORM_rnglistx);\n-\t    unsigned int ranges_offset = (DW_UNSND (&attr)\n+\t    /* It would be nice to reuse dwarf2_get_pc_bounds here,\n+\t       but that requires a full DIE, so instead we just\n+\t       reimplement it.  */\n+\t    unsigned int ranges_offset = (attr.constant_value (0)\n \t\t\t\t\t  + (need_ranges_base\n \t\t\t\t\t     ? cu->ranges_base\n \t\t\t\t\t     : 0));\n@@ -19622,10 +19624,10 @@ read_attribute_reprocess (const struct die_reader_specs *reader,\n \t\t\t\t\t    attr->as_unsigned_reprocess ()));\n         break;\n       case DW_FORM_loclistx:\n-\t DW_UNSND (attr) = read_loclist_index (cu, DW_UNSND (attr));\n+\tattr->set_address (read_loclist_index (cu, attr->as_unsigned ()));\n \t break;\n       case DW_FORM_rnglistx:\n-        DW_UNSND (attr) = read_rnglist_index (cu, DW_UNSND (attr), tag);\n+\tattr->set_address (read_rnglist_index (cu, attr->as_unsigned (), tag));\n         break;\n       case DW_FORM_strx:\n       case DW_FORM_strx1:\n@@ -19918,11 +19920,11 @@ read_attribute_value (const struct die_reader_specs *reader,\n      treat them as zero by default.  */\n   if (attr->name == DW_AT_byte_size\n       && form == DW_FORM_data4\n-      && DW_UNSND (attr) >= 0xffffffff)\n+      && attr->as_unsigned () >= 0xffffffff)\n     {\n       complaint\n         (_(\"Suspicious DW_AT_byte_size value treated as zero instead of %s\"),\n-         hex_string (DW_UNSND (attr)));\n+         hex_string (attr->as_unsigned ()));\n       attr->set_unsigned (0);\n     }\n \n@@ -21420,16 +21422,15 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t\t  inlined_func ? DW_AT_call_line : DW_AT_decl_line,\n \t\t\t  cu);\n       if (attr != nullptr)\n-\t{\n-\t  SYMBOL_LINE (sym) = DW_UNSND (attr);\n-\t}\n+\tSYMBOL_LINE (sym) = attr->constant_value (0);\n \n       attr = dwarf2_attr (die,\n \t\t\t  inlined_func ? DW_AT_call_file : DW_AT_decl_file,\n \t\t\t  cu);\n-      if (attr != nullptr)\n+      if (attr != nullptr && attr->form_is_unsigned ())\n \t{\n-\t  file_name_index file_index = (file_name_index) DW_UNSND (attr);\n+\t  file_name_index file_index\n+\t    = (file_name_index) attr->as_unsigned ();\n \t  struct file_entry *fe;\n \n \t  if (cu->line_header != NULL)\n@@ -21781,7 +21782,7 @@ dwarf2_const_value_data (const struct attribute *attr, struct obstack *obstack,\n   struct objfile *objfile = cu->per_objfile->objfile;\n   enum bfd_endian byte_order = bfd_big_endian (objfile->obfd) ?\n \t\t\t\tBFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;\n-  LONGEST l = DW_UNSND (attr);\n+  LONGEST l = attr->constant_value (0);\n \n   if (bits < sizeof (*value) * 8)\n     {\n@@ -21900,7 +21901,7 @@ dwarf2_const_value_attr (const struct attribute *attr, struct type *type,\n       break;\n \n     case DW_FORM_udata:\n-      *value = DW_UNSND (attr);\n+      *value = attr->as_unsigned ();\n       break;\n \n     default:\n@@ -22738,31 +22739,31 @@ dump_die_shallow (struct ui_file *f, int indent, struct die_info *die)\n \t  break;\n \tcase DW_FORM_ref_addr:\n \t  fprintf_unfiltered (f, \"ref address: \");\n-\t  fputs_filtered (hex_string (DW_UNSND (&die->attrs[i])), f);\n+\t  fputs_filtered (hex_string (die->attrs[i].as_unsigned ()), f);\n \t  break;\n \tcase DW_FORM_GNU_ref_alt:\n \t  fprintf_unfiltered (f, \"alt ref address: \");\n-\t  fputs_filtered (hex_string (DW_UNSND (&die->attrs[i])), f);\n+\t  fputs_filtered (hex_string (die->attrs[i].as_unsigned ()), f);\n \t  break;\n \tcase DW_FORM_ref1:\n \tcase DW_FORM_ref2:\n \tcase DW_FORM_ref4:\n \tcase DW_FORM_ref8:\n \tcase DW_FORM_ref_udata:\n \t  fprintf_unfiltered (f, \"constant ref: 0x%lx (adjusted)\",\n-\t\t\t      (long) (DW_UNSND (&die->attrs[i])));\n+\t\t\t      (long) (die->attrs[i].as_unsigned ()));\n \t  break;\n \tcase DW_FORM_data1:\n \tcase DW_FORM_data2:\n \tcase DW_FORM_data4:\n \tcase DW_FORM_data8:\n \tcase DW_FORM_udata:\n \t  fprintf_unfiltered (f, \"constant: %s\",\n-\t\t\t      pulongest (DW_UNSND (&die->attrs[i])));\n+\t\t\t      pulongest (die->attrs[i].as_unsigned ()));\n \t  break;\n \tcase DW_FORM_sec_offset:\n \t  fprintf_unfiltered (f, \"section offset: %s\",\n-\t\t\t      pulongest (DW_UNSND (&die->attrs[i])));\n+\t\t\t      pulongest (die->attrs[i].as_unsigned ()));\n \t  break;\n \tcase DW_FORM_ref_sig8:\n \t  fprintf_unfiltered (f, \"signature: %s\",\n@@ -23238,7 +23239,7 @@ dwarf2_fetch_constant_bytes (sect_offset sect_off,\n     case DW_FORM_udata:\n       type = die_type (die, cu);\n       result = write_constant_as_bytes (obstack, byte_order,\n-\t\t\t\t\ttype, DW_UNSND (attr), len);\n+\t\t\t\t\ttype, attr->as_unsigned (), len);\n       break;\n \n     default:\n@@ -24248,7 +24249,7 @@ prepare_one_comp_unit (struct dwarf2_cu *cu, struct die_info *comp_unit_die,\n   /* Set the language we're debugging.  */\n   attr = dwarf2_attr (comp_unit_die, DW_AT_language, cu);\n   if (attr != nullptr)\n-    set_cu_language (DW_UNSND (attr), cu);\n+    set_cu_language (attr->constant_value (0), cu);\n   else\n     {\n       cu->language = pretend_language;"
    }
  ]
}