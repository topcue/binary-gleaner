{
  "sha": "96b792931fe4dd30f42eecd711ad5e44b6b135a3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTZiNzkyOTMxZmU0ZGQzMGY0MmVlY2Q3MTFhZDVlNDRiNmIxMzVhMw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:55Z"
    },
    "message": "Change section functions to be methods of dwarf2_section_info\n\nThis changes various section-related functions to be methods on\ndwarf2_section_info.  I think this clarifies the role of these\nfunctions.  This also changes one such function to return bool.\n\ngdb/ChangeLog\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2read.c (dwarf2_section_buffer_overflow_complaint)\n\t(dwarf2_section_size, dwarf2_get_section_info)\n\t(create_signatured_type_table_from_debug_names)\n\t(create_addrmap_from_aranges, read_debug_names_from_section)\n\t(get_gdb_index_contents_from_section, read_comp_unit_head)\n\t(error_check_comp_unit_head, read_abbrev_offset)\n\t(create_debug_type_hash_table, init_cu_die_reader)\n\t(read_cutu_die_from_dwo, dwarf2_build_psymtabs_hard)\n\t(read_comp_units_from_section, create_cus_hash_table)\n\t(create_dwp_hash_table, create_dwo_unit_in_dwp_v1)\n\t(create_dwp_v2_section, dwarf2_rnglists_process)\n\t(dwarf2_ranges_process, read_die_and_siblings, read_full_die)\n\t(abbrev_table_read_table, read_indirect_string_at_offset_from)\n\t(read_indirect_string_from_dwz, read_addr_index_1)\n\t(read_str_index, dwarf_decode_line_header, skip_form_bytes)\n\t(dwarf_decode_macro_bytes, dwarf_decode_macros)\n\t(fill_in_loclist_baton): Update.\n\t* dwarf2/section.h (struct dwarf2_section_info) <get_name,\n\tget_containing_section, get_bfd_owner, get_bfd_section,\n\tget_file_name, get_id, get_flags, empty, read>: Declare methods.\n\t(dwarf2_read_section, get_section_name, get_section_file_name)\n\t(get_containing_section, get_section_bfd_owner)\n\t(get_section_bfd_section, get_section_name, get_section_file_name)\n\t(get_section_id, get_section_flags, dwarf2_section_empty_p): Don't\n\tdeclare.\n\t* dwarf2/section.c (dwarf2_section_info::get_containing_section)\n\t(dwarf2_section_info::get_bfd_owner)\n\t(dwarf2_section_info::get_bfd_section)\n\t(dwarf2_section_info::get_name)\n\t(dwarf2_section_info::get_file_name, dwarf2_section_info::get_id)\n\t(dwarf2_section_info::get_flags, dwarf2_section_info::empty)\n\t(dwarf2_section_info::read): Now methods.\n\t* dwarf-index-write.c (class debug_names): Update.\n\nChange-Id: Ic849f182f57a18bad6b1c7c3b9368005d307758a",
    "tree": {
      "sha": "efd2622f44db1359e92b6e18209b073b095059c7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/efd2622f44db1359e92b6e18209b073b095059c7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/96b792931fe4dd30f42eecd711ad5e44b6b135a3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/96b792931fe4dd30f42eecd711ad5e44b6b135a3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/96b792931fe4dd30f42eecd711ad5e44b6b135a3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/96b792931fe4dd30f42eecd711ad5e44b6b135a3/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2c86cff96f47cdc7fe16e231f29566b3da2f756b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c86cff96f47cdc7fe16e231f29566b3da2f756b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2c86cff96f47cdc7fe16e231f29566b3da2f756b"
    }
  ],
  "stats": {
    "total": 345,
    "additions": 183,
    "deletions": 162
  },
  "files": [
    {
      "sha": "38ec68cd9b6e64b0979aec1dd818423591869b43",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 36,
      "deletions": 0,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=96b792931fe4dd30f42eecd711ad5e44b6b135a3",
      "patch": "@@ -1,3 +1,39 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2read.c (dwarf2_section_buffer_overflow_complaint)\n+\t(dwarf2_section_size, dwarf2_get_section_info)\n+\t(create_signatured_type_table_from_debug_names)\n+\t(create_addrmap_from_aranges, read_debug_names_from_section)\n+\t(get_gdb_index_contents_from_section, read_comp_unit_head)\n+\t(error_check_comp_unit_head, read_abbrev_offset)\n+\t(create_debug_type_hash_table, init_cu_die_reader)\n+\t(read_cutu_die_from_dwo, dwarf2_build_psymtabs_hard)\n+\t(read_comp_units_from_section, create_cus_hash_table)\n+\t(create_dwp_hash_table, create_dwo_unit_in_dwp_v1)\n+\t(create_dwp_v2_section, dwarf2_rnglists_process)\n+\t(dwarf2_ranges_process, read_die_and_siblings, read_full_die)\n+\t(abbrev_table_read_table, read_indirect_string_at_offset_from)\n+\t(read_indirect_string_from_dwz, read_addr_index_1)\n+\t(read_str_index, dwarf_decode_line_header, skip_form_bytes)\n+\t(dwarf_decode_macro_bytes, dwarf_decode_macros)\n+\t(fill_in_loclist_baton): Update.\n+\t* dwarf2/section.h (struct dwarf2_section_info) <get_name,\n+\tget_containing_section, get_bfd_owner, get_bfd_section,\n+\tget_file_name, get_id, get_flags, empty, read>: Declare methods.\n+\t(dwarf2_read_section, get_section_name, get_section_file_name)\n+\t(get_containing_section, get_section_bfd_owner)\n+\t(get_section_bfd_section, get_section_name, get_section_file_name)\n+\t(get_section_id, get_section_flags, dwarf2_section_empty_p): Don't\n+\tdeclare.\n+\t* dwarf2/section.c (dwarf2_section_info::get_containing_section)\n+\t(dwarf2_section_info::get_bfd_owner)\n+\t(dwarf2_section_info::get_bfd_section)\n+\t(dwarf2_section_info::get_name)\n+\t(dwarf2_section_info::get_file_name, dwarf2_section_info::get_id)\n+\t(dwarf2_section_info::get_flags, dwarf2_section_info::empty)\n+\t(dwarf2_section_info::read): Now methods.\n+\t* dwarf-index-write.c (class debug_names): Update.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2read.h (struct dwarf2_section_info, dwarf2_read_section):"
    },
    {
      "sha": "4b2a3b07f47fafb56bdf32a18772751d2110085f",
      "filename": "gdb/dwarf-index-write.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/dwarf-index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/dwarf-index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf-index-write.c?ref=96b792931fe4dd30f42eecd711ad5e44b6b135a3",
      "patch": "@@ -960,8 +960,7 @@ class debug_names\n       : m_abfd (dwarf2_per_objfile->objfile->obfd),\n \tm_dwarf2_per_objfile (dwarf2_per_objfile)\n     {\n-      dwarf2_read_section (dwarf2_per_objfile->objfile,\n-\t\t\t   &dwarf2_per_objfile->str);\n+      dwarf2_per_objfile->str.read (dwarf2_per_objfile->objfile);\n       if (dwarf2_per_objfile->str.buffer == NULL)\n \treturn;\n       for (const gdb_byte *data = dwarf2_per_objfile->str.buffer;"
    },
    {
      "sha": "5e33809117d9ba05de1faf9febf9384f0912ebc1",
      "filename": "gdb/dwarf2/section.c",
      "status": "modified",
      "additions": 41,
      "deletions": 40,
      "changes": 81,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/dwarf2/section.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/dwarf2/section.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/section.c?ref=96b792931fe4dd30f42eecd711ad5e44b6b135a3",
      "patch": "@@ -30,130 +30,131 @@\n #include \"objfiles.h\"\n \n struct dwarf2_section_info *\n-get_containing_section (const struct dwarf2_section_info *section)\n+dwarf2_section_info::get_containing_section () const\n {\n-  gdb_assert (section->is_virtual);\n-  return section->s.containing_section;\n+  gdb_assert (is_virtual);\n+  return s.containing_section;\n }\n \n struct bfd *\n-get_section_bfd_owner (const struct dwarf2_section_info *section)\n+dwarf2_section_info::get_bfd_owner () const\n {\n-  if (section->is_virtual)\n+  const dwarf2_section_info *section = this;\n+  if (is_virtual)\n     {\n-      section = get_containing_section (section);\n+      section = get_containing_section ();\n       gdb_assert (!section->is_virtual);\n     }\n   return section->s.section->owner;\n }\n \n asection *\n-get_section_bfd_section (const struct dwarf2_section_info *section)\n+dwarf2_section_info::get_bfd_section () const\n {\n+  const dwarf2_section_info *section = this;\n   if (section->is_virtual)\n     {\n-      section = get_containing_section (section);\n+      section = get_containing_section ();\n       gdb_assert (!section->is_virtual);\n     }\n   return section->s.section;\n }\n \n const char *\n-get_section_name (const struct dwarf2_section_info *section)\n+dwarf2_section_info::get_name () const\n {\n-  asection *sectp = get_section_bfd_section (section);\n+  asection *sectp = get_bfd_section ();\n \n   gdb_assert (sectp != NULL);\n   return bfd_section_name (sectp);\n }\n \n const char *\n-get_section_file_name (const struct dwarf2_section_info *section)\n+dwarf2_section_info::get_file_name () const\n {\n-  bfd *abfd = get_section_bfd_owner (section);\n+  bfd *abfd = get_bfd_owner ();\n \n   return bfd_get_filename (abfd);\n }\n \n int\n-get_section_id (const struct dwarf2_section_info *section)\n+dwarf2_section_info::get_id () const\n {\n-  asection *sectp = get_section_bfd_section (section);\n+  asection *sectp = get_bfd_section ();\n \n   if (sectp == NULL)\n     return 0;\n   return sectp->id;\n }\n \n int\n-get_section_flags (const struct dwarf2_section_info *section)\n+dwarf2_section_info::get_flags () const\n {\n-  asection *sectp = get_section_bfd_section (section);\n+  asection *sectp = get_bfd_section ();\n \n   gdb_assert (sectp != NULL);\n   return bfd_section_flags (sectp);\n }\n \n-int\n-dwarf2_section_empty_p (const struct dwarf2_section_info *section)\n+bool\n+dwarf2_section_info::empty () const\n {\n-  if (section->is_virtual)\n-    return section->size == 0;\n-  return section->s.section == NULL || section->size == 0;\n+  if (is_virtual)\n+    return size == 0;\n+  return s.section == NULL || size == 0;\n }\n \n void\n-dwarf2_read_section (struct objfile *objfile, dwarf2_section_info *info)\n+dwarf2_section_info::read (struct objfile *objfile)\n {\n   asection *sectp;\n   bfd *abfd;\n   gdb_byte *buf, *retbuf;\n \n-  if (info->readin)\n+  if (readin)\n     return;\n-  info->buffer = NULL;\n-  info->readin = true;\n+  buffer = NULL;\n+  readin = true;\n \n-  if (dwarf2_section_empty_p (info))\n+  if (empty ())\n     return;\n \n-  sectp = get_section_bfd_section (info);\n+  sectp = get_bfd_section ();\n \n   /* If this is a virtual section we need to read in the real one first.  */\n-  if (info->is_virtual)\n+  if (is_virtual)\n     {\n       struct dwarf2_section_info *containing_section =\n-\tget_containing_section (info);\n+\tget_containing_section ();\n \n       gdb_assert (sectp != NULL);\n       if ((sectp->flags & SEC_RELOC) != 0)\n \t{\n \t  error (_(\"Dwarf Error: DWP format V2 with relocations is not\"\n \t\t   \" supported in section %s [in module %s]\"),\n-\t\t get_section_name (info), get_section_file_name (info));\n+\t\t get_name (), get_file_name ());\n \t}\n-      dwarf2_read_section (objfile, containing_section);\n+      containing_section->read (objfile);\n       /* Other code should have already caught virtual sections that don't\n \t fit.  */\n-      gdb_assert (info->virtual_offset + info->size\n-\t\t  <= containing_section->size);\n+      gdb_assert (virtual_offset + size <= containing_section->size);\n       /* If the real section is empty or there was a problem reading the\n \t section we shouldn't get here.  */\n       gdb_assert (containing_section->buffer != NULL);\n-      info->buffer = containing_section->buffer + info->virtual_offset;\n+      buffer = containing_section->buffer + virtual_offset;\n       return;\n     }\n \n   /* If the section has relocations, we must read it ourselves.\n      Otherwise we attach it to the BFD.  */\n   if ((sectp->flags & SEC_RELOC) == 0)\n     {\n-      info->buffer = gdb_bfd_map_section (sectp, &info->size);\n+      buffer = gdb_bfd_map_section (sectp, &size);\n       return;\n     }\n \n-  buf = (gdb_byte *) obstack_alloc (&objfile->objfile_obstack, info->size);\n-  info->buffer = buf;\n+  buf = (gdb_byte *) obstack_alloc (&objfile->objfile_obstack, size);\n+  buffer = buf;\n \n   /* When debugging .o files, we may need to apply relocations; see\n      http://sourceware.org/ml/gdb-patches/2002-04/msg00136.html .\n@@ -162,15 +163,15 @@ dwarf2_read_section (struct objfile *objfile, dwarf2_section_info *info)\n   retbuf = symfile_relocate_debug_section (objfile, sectp, buf);\n   if (retbuf != NULL)\n     {\n-      info->buffer = retbuf;\n+      buffer = retbuf;\n       return;\n     }\n \n-  abfd = get_section_bfd_owner (info);\n+  abfd = get_bfd_owner ();\n   gdb_assert (abfd != NULL);\n \n   if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0\n-      || bfd_bread (buf, info->size, abfd) != info->size)\n+      || bfd_bread (buf, size, abfd) != size)\n     {\n       error (_(\"Dwarf Error: Can't read DWARF data\"\n \t       \" in section %s [in module %s]\"),"
    },
    {
      "sha": "f76f1ef7bf58d7c4b282b25cf7bd14a795bb4f12",
      "filename": "gdb/dwarf2/section.h",
      "status": "modified",
      "additions": 36,
      "deletions": 51,
      "changes": 87,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/dwarf2/section.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/dwarf2/section.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/section.h?ref=96b792931fe4dd30f42eecd711ad5e44b6b135a3",
      "patch": "@@ -45,6 +45,42 @@\n \n struct dwarf2_section_info\n {\n+  /* Return the name of this section.  */\n+  const char *get_name () const;\n+\n+  /* Return the containing section of this section, which must be a\n+     virtual section.  */\n+  struct dwarf2_section_info *get_containing_section () const;\n+\n+  /* Return the bfd owner of this section.  */\n+  struct bfd *get_bfd_owner () const;\n+\n+  /* Return the bfd section of this section.\n+     Returns NULL if the section is not present.  */\n+  asection *get_bfd_section () const;\n+\n+  /* Return the name of the file this section is in.  */\n+  const char *get_file_name () const;\n+\n+  /* Return the id of this section.\n+     Returns 0 if this section doesn't exist.  */\n+  int get_id () const;\n+\n+  /* Return the flags of this section.  This section (or containing\n+     section if this is a virtual section) must exist.  */\n+  int get_flags () const;\n+\n+  /* Return true if this section does not exist or if it has no\n+     contents. */\n+  bool empty () const;\n+\n+  /* Read the contents of this section.\n+     OBJFILE is the main object file, but not necessarily the file where\n+     the section comes from.  E.g., for DWO files the bfd of INFO is the bfd\n+     of the DWO file.\n+     If the section is compressed, uncompress it before returning.  */\n+  void read (struct objfile *objfile);\n+\n   union\n   {\n     /* If this is a real section, the bfd section.  */\n@@ -67,55 +103,4 @@ struct dwarf2_section_info\n   bool is_virtual;\n };\n \n-/* Read the contents of the section INFO.\n-   OBJFILE is the main object file, but not necessarily the file where\n-   the section comes from.  E.g., for DWO files the bfd of INFO is the bfd\n-   of the DWO file.\n-   If the section is compressed, uncompress it before returning.  */\n-\n-extern void dwarf2_read_section (struct objfile *objfile,\n-\t\t\t\t dwarf2_section_info *info);\n-\n-extern const char *get_section_name (const struct dwarf2_section_info *);\n-\n-extern const char *get_section_file_name (const struct dwarf2_section_info *);\n-\n-/* Return the containing section of virtual section SECTION.  */\n-\n-extern struct dwarf2_section_info *get_containing_section\n-  (const struct dwarf2_section_info *section);\n-\n-/* Return the bfd owner of SECTION.  */\n-\n-extern struct bfd *get_section_bfd_owner\n-  (const struct dwarf2_section_info *section);\n-\n-/* Return the bfd section of SECTION.\n-   Returns NULL if the section is not present.  */\n-\n-extern asection *get_section_bfd_section\n-  (const struct dwarf2_section_info *section);\n-\n-/* Return the name of SECTION.  */\n-\n-extern const char *get_section_name\n-  (const struct dwarf2_section_info *section);\n-\n-/* Return the name of the file SECTION is in.  */\n-\n-extern const char *get_section_file_name\n-  (const struct dwarf2_section_info *section);\n-\n-/* Return the id of SECTION.\n-   Returns 0 if SECTION doesn't exist.  */\n-\n-extern int get_section_id (const struct dwarf2_section_info *section);\n-\n-/* Return the flags of SECTION.\n-   SECTION (or containing section if this is a virtual section) must exist.  */\n-\n-extern int get_section_flags (const struct dwarf2_section_info *section);\n-\n-extern int dwarf2_section_empty_p (const struct dwarf2_section_info *section);\n-\n #endif /* GDB_DWARF2_SECTION_H */"
    },
    {
      "sha": "903d98b59d82bd61648de8304f33c07905236f36",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 69,
      "deletions": 69,
      "changes": 138,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96b792931fe4dd30f42eecd711ad5e44b6b135a3/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=96b792931fe4dd30f42eecd711ad5e44b6b135a3",
      "patch": "@@ -2071,8 +2071,8 @@ dwarf2_section_buffer_overflow_complaint (struct dwarf2_section_info *section)\n {\n   complaint (_(\"debug info runs off end of %s section\"\n \t       \" [in module %s]\"),\n-\t     get_section_name (section),\n-\t     get_section_file_name (section));\n+\t     section->get_name (),\n+\t     section->get_file_name ());\n }\n \n static void\n@@ -2414,7 +2414,7 @@ dwarf2_section_size (struct objfile *objfile,\n \t\t     struct dwarf2_section_info *info)\n {\n   if (!info->readin)\n-    dwarf2_read_section (objfile, info);\n+    info->read (objfile);\n   return info->size;\n }\n \n@@ -2451,9 +2451,9 @@ dwarf2_get_section_info (struct objfile *objfile,\n       gdb_assert_not_reached (\"unexpected section\");\n     }\n \n-  dwarf2_read_section (objfile, info);\n+  info->read (objfile);\n \n-  *sectp = get_section_bfd_section (info);\n+  *sectp = info->get_bfd_section ();\n   *bufp = info->buffer;\n   *sizep = info->size;\n }\n@@ -2953,8 +2953,8 @@ create_signatured_type_table_from_debug_names\n {\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n \n-  dwarf2_read_section (objfile, section);\n-  dwarf2_read_section (objfile, abbrev_section);\n+  section->read (objfile);\n+  abbrev_section->read (objfile);\n \n   gdb_assert (dwarf2_per_objfile->all_type_units.empty ());\n   dwarf2_per_objfile->all_type_units.reserve (map.tu_count);\n@@ -3087,7 +3087,7 @@ create_addrmap_from_aranges (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t}\n     }\n \n-  dwarf2_read_section (objfile, section);\n+  section->read (objfile);\n \n   const bfd_endian dwarf5_byte_order = gdbarch_byte_order (gdbarch);\n \n@@ -5214,21 +5214,21 @@ read_debug_names_from_section (struct objfile *objfile,\n \t\t\t       struct dwarf2_section_info *section,\n \t\t\t       mapped_debug_names &map)\n {\n-  if (dwarf2_section_empty_p (section))\n+  if (section->empty ())\n     return false;\n \n   /* Older elfutils strip versions could keep the section in the main\n      executable while splitting it for the separate debug info file.  */\n-  if ((get_section_flags (section) & SEC_HAS_CONTENTS) == 0)\n+  if ((section->get_flags () & SEC_HAS_CONTENTS) == 0)\n     return false;\n \n-  dwarf2_read_section (objfile, section);\n+  section->read (objfile);\n \n   map.dwarf5_byte_order = gdbarch_byte_order (get_objfile_arch (objfile));\n \n   const gdb_byte *addr = section->buffer;\n \n-  bfd *const abfd = get_section_bfd_owner (section);\n+  bfd *const abfd = section->get_bfd_owner ();\n \n   unsigned int bytes_read;\n   LONGEST length = read_initial_length (abfd, addr, &bytes_read);\n@@ -6088,15 +6088,15 @@ get_gdb_index_contents_from_section (objfile *obj, T *section_owner)\n {\n   dwarf2_section_info *section = &section_owner->gdb_index;\n \n-  if (dwarf2_section_empty_p (section))\n+  if (section->empty ())\n     return {};\n \n   /* Older elfutils strip versions could keep the section in the main\n      executable while splitting it for the separate debug info file.  */\n-  if ((get_section_flags (section) & SEC_HAS_CONTENTS) == 0)\n+  if ((section->get_flags () & SEC_HAS_CONTENTS) == 0)\n     return {};\n \n-  dwarf2_read_section (obj, section);\n+  section->read (obj);\n \n   /* dwarf2_section_info::size is a bfd_size_type, while\n      gdb::array_view works with size_t.  On 32-bit hosts, with\n@@ -6291,8 +6291,8 @@ read_comp_unit_head (struct comp_unit_head *cu_header,\n {\n   int signed_addr;\n   unsigned int bytes_read;\n-  const char *filename = get_section_file_name (section);\n-  bfd *abfd = get_section_bfd_owner (section);\n+  const char *filename = section->get_file_name ();\n+  bfd *abfd = section->get_bfd_owner ();\n \n   cu_header->length = read_initial_length (abfd, info_ptr, &bytes_read);\n   cu_header->initial_length_size = bytes_read;\n@@ -6419,7 +6419,7 @@ error_check_comp_unit_head (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\t    struct dwarf2_section_info *section,\n \t\t\t    struct dwarf2_section_info *abbrev_section)\n {\n-  const char *filename = get_section_file_name (section);\n+  const char *filename = section->get_file_name ();\n \n   if (to_underlying (header->abbrev_sect_off)\n       >= dwarf2_section_size (dwarf2_per_objfile->objfile, abbrev_section))\n@@ -6472,12 +6472,12 @@ read_abbrev_offset (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t    struct dwarf2_section_info *section,\n \t\t    sect_offset sect_off)\n {\n-  bfd *abfd = get_section_bfd_owner (section);\n+  bfd *abfd = section->get_bfd_owner ();\n   const gdb_byte *info_ptr;\n   unsigned int initial_length_size, offset_size;\n   uint16_t version;\n \n-  dwarf2_read_section (dwarf2_per_objfile->objfile, section);\n+  section->read (dwarf2_per_objfile->objfile);\n   info_ptr = section->buffer + to_underlying (sect_off);\n   read_initial_length (abfd, info_ptr, &initial_length_size);\n   offset_size = initial_length_size == 4 ? 4 : 8;\n@@ -6613,18 +6613,18 @@ create_debug_type_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   if (dwarf_read_debug)\n     fprintf_unfiltered (gdb_stdlog, \"Reading %s for %s:\\n\",\n-\t\t\tget_section_name (section),\n-\t\t\tget_section_file_name (abbrev_section));\n+\t\t\tsection->get_name (),\n+\t\t\tabbrev_section->get_file_name ());\n \n-  dwarf2_read_section (objfile, section);\n+  section->read (objfile);\n   info_ptr = section->buffer;\n \n   if (info_ptr == NULL)\n     return;\n \n   /* We can't set abfd until now because the section may be empty or\n      not present, in which case the bfd is unknown.  */\n-  abfd = get_section_bfd_owner (section);\n+  abfd = section->get_bfd_owner ();\n \n   /* We don't use cutu_reader here because we don't need to read\n      any dies: the signature is in the header.  */\n@@ -7060,7 +7060,7 @@ init_cu_die_reader (struct die_reader_specs *reader,\n \t\t    struct abbrev_table *abbrev_table)\n {\n   gdb_assert (section->readin && section->buffer != NULL);\n-  reader->abfd = get_section_bfd_owner (section);\n+  reader->abfd = section->get_bfd_owner ();\n   reader->cu = cu;\n   reader->dwo_file = dwo_file;\n   reader->die_section = section;\n@@ -7158,8 +7158,8 @@ read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,\n   /* Set up for reading the DWO CU/TU.  */\n   cu->dwo_unit = dwo_unit;\n   dwarf2_section_info *section = dwo_unit->section;\n-  dwarf2_read_section (objfile, section);\n-  abfd = get_section_bfd_owner (section);\n+  section->read (objfile);\n+  abfd = section->get_bfd_owner ();\n   begin_info_ptr = info_ptr = (section->buffer\n \t\t\t       + to_underlying (dwo_unit->sect_off));\n   dwo_abbrev_section = &dwo_unit->dwo_file->sections.abbrev;\n@@ -7242,7 +7242,7 @@ read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,\n     {\n       fprintf_unfiltered (gdb_stdlog,\n \t\t\t  \"Read die from %s@0x%x of %s:\\n\",\n-\t\t\t  get_section_name (section),\n+\t\t\t  section->get_name (),\n \t\t\t  (unsigned) (begin_info_ptr - section->buffer),\n \t\t\t  bfd_get_filename (abfd));\n       dump_die (comp_unit_die, dwarf_die_debug);\n@@ -7392,7 +7392,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n   struct dwarf2_per_objfile *dwarf2_per_objfile = this_cu->dwarf2_per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_section_info *section = this_cu->section;\n-  bfd *abfd = get_section_bfd_owner (section);\n+  bfd *abfd = section->get_bfd_owner ();\n   struct dwarf2_cu *cu;\n   const gdb_byte *begin_info_ptr;\n   struct signatured_type *sig_type = NULL;\n@@ -7422,7 +7422,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n     }\n \n   /* This is cheap if the section is already read in.  */\n-  dwarf2_read_section (objfile, section);\n+  section->read (objfile);\n \n   begin_info_ptr = info_ptr = section->buffer + to_underlying (this_cu->sect_off);\n \n@@ -7613,7 +7613,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n   struct dwarf2_per_objfile *dwarf2_per_objfile = this_cu->dwarf2_per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_section_info *section = this_cu->section;\n-  bfd *abfd = get_section_bfd_owner (section);\n+  bfd *abfd = section->get_bfd_owner ();\n   struct dwarf2_section_info *abbrev_section;\n   const gdb_byte *begin_info_ptr, *info_ptr;\n   int has_children;\n@@ -7630,7 +7630,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n \t\t    : get_abbrev_section_for_cu (this_cu));\n \n   /* This is cheap if the section is already read in.  */\n-  dwarf2_read_section (objfile, section);\n+  section->read (objfile);\n \n   m_new_cu.reset (new dwarf2_cu (this_cu));\n \n@@ -8347,7 +8347,7 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \n   dwarf2_per_objfile->reading_partial_symbols = 1;\n \n-  dwarf2_read_section (objfile, &dwarf2_per_objfile->info);\n+  dwarf2_per_objfile->info.read (objfile);\n \n   /* Any cached compilation units will be linked by the per-objfile\n      read_in_chain.  Make sure to free them when we're done.  */\n@@ -8426,10 +8426,10 @@ read_comp_units_from_section (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   if (dwarf_read_debug)\n     fprintf_unfiltered (gdb_stdlog, \"Reading %s for %s\\n\",\n-\t\t\tget_section_name (section),\n-\t\t\tget_section_file_name (section));\n+\t\t\tsection->get_name (),\n+\t\t\tsection->get_file_name ());\n \n-  dwarf2_read_section (objfile, section);\n+  section->read (objfile);\n \n   info_ptr = section->buffer;\n \n@@ -11738,7 +11738,7 @@ create_cus_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   const gdb_byte *info_ptr, *end_ptr;\n \n-  dwarf2_read_section (objfile, &section);\n+  section.read (objfile);\n   info_ptr = section.buffer;\n \n   if (info_ptr == NULL)\n@@ -11747,8 +11747,8 @@ create_cus_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   if (dwarf_read_debug)\n     {\n       fprintf_unfiltered (gdb_stdlog, \"Reading %s for %s:\\n\",\n-\t\t\t  get_section_name (&section),\n-\t\t\t  get_section_file_name (&section));\n+\t\t\t  section.get_name (),\n+\t\t\t  section.get_file_name ());\n     }\n \n   end_ptr = info_ptr + section.size;\n@@ -11950,9 +11950,9 @@ create_dwp_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   else\n     index = &dwp_file->sections.cu_index;\n \n-  if (dwarf2_section_empty_p (index))\n+  if (index->empty ())\n     return NULL;\n-  dwarf2_read_section (objfile, index);\n+  index->read (objfile);\n \n   index_ptr = index->buffer;\n   index_end = index_ptr + index->size;\n@@ -12242,8 +12242,8 @@ create_dwo_unit_in_dwp_v1 (struct dwarf2_per_objfile *dwarf2_per_objfile,\n     }\n \n   if (i < 2\n-      || dwarf2_section_empty_p (&sections.info_or_types)\n-      || dwarf2_section_empty_p (&sections.abbrev))\n+      || sections.info_or_types.empty ()\n+      || sections.abbrev.empty ())\n     {\n       error (_(\"Dwarf Error: bad DWP hash table, missing DWO sections\"\n \t       \" [in module %s]\"),\n@@ -12267,10 +12267,10 @@ create_dwo_unit_in_dwp_v1 (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   std::string virtual_dwo_name =\n     string_printf (\"virtual-dwo/%d-%d-%d-%d\",\n-\t\t   get_section_id (&sections.abbrev),\n-\t\t   get_section_id (&sections.line),\n-\t\t   get_section_id (&sections.loc),\n-\t\t   get_section_id (&sections.str_offsets));\n+\t\t   sections.abbrev.get_id (),\n+\t\t   sections.line.get_id (),\n+\t\t   sections.loc.get_id (),\n+\t\t   sections.str_offsets.get_id ());\n   /* Can we use an existing virtual DWO file?  */\n   dwo_file_slot = lookup_dwo_file_slot (dwarf2_per_objfile,\n \t\t\t\t\tvirtual_dwo_name.c_str (),\n@@ -12348,7 +12348,7 @@ create_dwp_v2_section (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   if (size == 0)\n     return result;\n \n-  sectp = get_section_bfd_section (section);\n+  sectp = section->get_bfd_section ();\n \n   /* Flag an error if the piece denoted by OFFSET,SIZE is outside the\n      bounds of the real section.  This is a pretty-rare event, so just\n@@ -14111,7 +14111,7 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n   found_base = cu->base_known;\n   base = cu->base_address;\n \n-  dwarf2_read_section (objfile, &dwarf2_per_objfile->rnglists);\n+  dwarf2_per_objfile->rnglists.read (objfile);\n   if (offset >= dwarf2_per_objfile->rnglists.size)\n     {\n       complaint (_(\"Offset %d out of bounds for DW_AT_ranges attribute\"),\n@@ -14279,7 +14279,7 @@ dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu,\n   found_base = cu->base_known;\n   base = cu->base_address;\n \n-  dwarf2_read_section (objfile, &dwarf2_per_objfile->ranges);\n+  dwarf2_per_objfile->ranges.read (objfile);\n   if (offset >= dwarf2_per_objfile->ranges.size)\n     {\n       complaint (_(\"Offset %d out of bounds for DW_AT_ranges attribute\"),\n@@ -18151,7 +18151,7 @@ read_die_and_siblings (const struct die_reader_specs *reader,\n     {\n       fprintf_unfiltered (gdb_stdlog,\n \t\t\t  \"Read die from %s@0x%x of %s:\\n\",\n-\t\t\t  get_section_name (reader->die_section),\n+\t\t\t  reader->die_section->get_name (),\n \t\t\t  (unsigned) (info_ptr - reader->die_section->buffer),\n \t\t\t  bfd_get_filename (reader->abfd));\n       dump_die (die, dwarf_die_debug);\n@@ -18248,7 +18248,7 @@ read_full_die (const struct die_reader_specs *reader,\n     {\n       fprintf_unfiltered (gdb_stdlog,\n \t\t\t  \"Read die from %s@0x%x of %s:\\n\",\n-\t\t\t  get_section_name (reader->die_section),\n+\t\t\t  reader->die_section->get_name (),\n \t\t\t  (unsigned) (info_ptr - reader->die_section->buffer),\n \t\t\t  bfd_get_filename (reader->abfd));\n       dump_die (*diep, dwarf_die_debug);\n@@ -18319,7 +18319,7 @@ abbrev_table_read_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\t sect_offset sect_off)\n {\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n-  bfd *abfd = get_section_bfd_owner (section);\n+  bfd *abfd = section->get_bfd_owner ();\n   const gdb_byte *abbrev_ptr;\n   struct abbrev_info *cur_abbrev;\n   unsigned int abbrev_number, bytes_read, abbrev_name;\n@@ -18328,7 +18328,7 @@ abbrev_table_read_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   abbrev_table_up abbrev_table (new struct abbrev_table (sect_off));\n \n-  dwarf2_read_section (objfile, section);\n+  section->read (objfile);\n   abbrev_ptr = section->buffer + to_underlying (sect_off);\n   abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n   abbrev_ptr += bytes_read;\n@@ -19711,7 +19711,7 @@ read_indirect_string_at_offset_from (struct objfile *objfile,\n \t\t\t\t     const char *form_name,\n \t\t\t\t     const char *sect_name)\n {\n-  dwarf2_read_section (objfile, sect);\n+  sect->read (objfile);\n   if (sect->buffer == NULL)\n     error (_(\"%s used without %s section [in module %s]\"),\n \t   form_name, sect_name, bfd_get_filename (abfd));\n@@ -19758,7 +19758,7 @@ static const char *\n read_indirect_string_from_dwz (struct objfile *objfile, struct dwz_file *dwz,\n \t\t\t       LONGEST str_offset)\n {\n-  dwarf2_read_section (objfile, &dwz->str);\n+  dwz->str.read (objfile);\n \n   if (dwz->str.buffer == NULL)\n     error (_(\"DW_FORM_GNU_strp_alt used without .debug_str \"\n@@ -19819,7 +19819,7 @@ read_addr_index_1 (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   const gdb_byte *info_ptr;\n   ULONGEST addr_base_or_zero = addr_base.has_value () ? *addr_base : 0;\n \n-  dwarf2_read_section (objfile, &dwarf2_per_objfile->addr);\n+  dwarf2_per_objfile->addr.read (objfile);\n   if (dwarf2_per_objfile->addr.buffer == NULL)\n     error (_(\"DW_FORM_addr_index used without .debug_addr section [in module %s]\"),\n \t   objfile_name (objfile));\n@@ -19922,17 +19922,17 @@ read_str_index (struct dwarf2_cu *cu,\n   ULONGEST str_offset;\n   static const char form_name[] = \"DW_FORM_GNU_str_index or DW_FORM_strx\";\n \n-  dwarf2_read_section (objfile, str_section);\n-  dwarf2_read_section (objfile, str_offsets_section);\n+  str_section->read (objfile);\n+  str_offsets_section->read (objfile);\n   if (str_section->buffer == NULL)\n     error (_(\"%s used without %s section\"\n \t     \" in CU at offset %s [in module %s]\"),\n-\t   form_name, get_section_name (str_section),\n+\t   form_name, str_section->get_name (),\n            sect_offset_str (cu->header.sect_off), objf_name);\n   if (str_offsets_section->buffer == NULL)\n     error (_(\"%s used without %s section\"\n \t     \" in CU at offset %s [in module %s]\"),\n-\t   form_name, get_section_name (str_section),\n+\t   form_name, str_section->get_name (),\n            sect_offset_str (cu->header.sect_off), objf_name);\n   info_ptr = (str_offsets_section->buffer\n \t      + str_offsets_base\n@@ -20423,7 +20423,7 @@ dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n     = cu->per_cu->dwarf2_per_objfile;\n \n   section = get_debug_line_section (cu);\n-  dwarf2_read_section (dwarf2_per_objfile->objfile, section);\n+  section->read (dwarf2_per_objfile->objfile);\n   if (section->buffer == NULL)\n     {\n       if (cu->dwo_unit && cu->per_cu->is_debug_types)\n@@ -20435,7 +20435,7 @@ dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n \n   /* We can't do this until we know the section is non-empty.\n      Only then do we know we have such a section.  */\n-  abfd = get_section_bfd_owner (section);\n+  abfd = section->get_bfd_owner ();\n \n   /* Make sure that at least there's room for the total_length field.\n      That could be 12 bytes long, but we're just going to fudge that.  */\n@@ -24435,7 +24435,7 @@ skip_form_bytes (bfd *abfd, const gdb_byte *bytes, const gdb_byte *buffer_end,\n     default:\n       {\n \tcomplaint (_(\"invalid form 0x%x in `%s'\"),\n-\t\t   form, get_section_name (section));\n+\t\t   form, section->get_name ());\n \treturn NULL;\n       }\n     }\n@@ -24778,10 +24778,10 @@ dwarf_decode_macro_bytes (struct dwarf2_cu *cu,\n \t      {\n \t\tstruct dwz_file *dwz = dwarf2_get_dwz_file (dwarf2_per_objfile);\n \n-\t\tdwarf2_read_section (objfile, &dwz->macro);\n+\t\tdwz->macro.read (objfile);\n \n \t\tinclude_section = &dwz->macro;\n-\t\tinclude_bfd = get_section_bfd_owner (include_section);\n+\t\tinclude_bfd = include_section->get_bfd_owner ();\n \t\tinclude_mac_end = dwz->macro.buffer + dwz->macro.size;\n \t\tis_dwz = 1;\n \t      }\n@@ -24884,13 +24884,13 @@ dwarf_decode_macros (struct dwarf2_cu *cu, unsigned int offset,\n \t}\n     }\n \n-  dwarf2_read_section (objfile, section);\n+  section->read (objfile);\n   if (section->buffer == NULL)\n     {\n       complaint (_(\"missing %s section\"), section_name);\n       return;\n     }\n-  abfd = get_section_bfd_owner (section);\n+  abfd = section->get_bfd_owner ();\n \n   /* First pass: Find the name of the base filename.\n      This filename is needed in order to process all macros whose definition\n@@ -25150,7 +25150,7 @@ fill_in_loclist_baton (struct dwarf2_cu *cu,\n     = cu->per_cu->dwarf2_per_objfile;\n   struct dwarf2_section_info *section = cu_debug_loc_section (cu);\n \n-  dwarf2_read_section (dwarf2_per_objfile->objfile, section);\n+  section->read (dwarf2_per_objfile->objfile);\n \n   baton->per_cu = cu->per_cu;\n   gdb_assert (baton->per_cu);"
    }
  ]
}