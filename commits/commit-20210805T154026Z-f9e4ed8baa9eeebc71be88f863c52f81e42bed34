{
  "sha": "f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjllNGVkOGJhYTllZWViYzcxYmU4OGY4NjNjNTJmODFlNDJiZWQzNA==",
  "commit": {
    "author": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2020-09-15T11:35:56Z"
    },
    "committer": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2021-08-05T15:40:26Z"
    },
    "message": "Merge evaluate_for_locexpr_baton evaluator\n\nThe evaluate_for_locexpr_baton is the last derived class from the\ndwarf_expr_context class. It's purpose is to support the passed in\nbuffer functionality.\n\nAlthough, it is not really necessary to merge this class with it's\nbase class, doing that simplifies new expression evaluator design.\n\nConsidering that this functionality is going around the DWARF standard,\nit is also reasonable to expect that with a new evaluator design and\nextending the push object address functionality to accept any location\ndescription, there will be no need to support passed in buffers.\n\nAlternatively, it would also makes sense to abstract the interaction\nbetween the evaluator and a given resource in the near future. The\npassed in buffer would then be a specialization of that abstraction.\n\ngdb/ChangeLog:\n\n\t* dwarf2/expr.c (dwarf_expr_context::read_mem): Merge with\n\tevaluate_for_locexpr_baton implementation.\n\t* dwarf2/loc.c (class evaluate_for_locexpr_baton): Remove\n\tclass.\n\t(evaluate_for_locexpr_baton::read_mem): Move to\n\tdwarf_expr_context.\n\t(dwarf2_locexpr_baton_eval): Instantiate dwarf_expr_context\n\tinstead of evaluate_for_locexpr_baton class.",
    "tree": {
      "sha": "fae4b1fd02894866edb1fd00402028afb5b7ca4b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fae4b1fd02894866edb1fd00402028afb5b7ca4b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f9e4ed8baa9eeebc71be88f863c52f81e42bed34/comments",
  "author": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "14a62404c9845827d92986af2dfcdbb7e48c65fc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/14a62404c9845827d92986af2dfcdbb7e48c65fc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/14a62404c9845827d92986af2dfcdbb7e48c65fc"
    }
  ],
  "stats": {
    "total": 83,
    "additions": 28,
    "deletions": 55
  },
  "files": [
    {
      "sha": "f9ac77160f63ff2a195ff667ac53a9223da87865",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 18,
      "deletions": 2,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f9e4ed8baa9eeebc71be88f863c52f81e42bed34/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f9e4ed8baa9eeebc71be88f863c52f81e42bed34/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
      "patch": "@@ -242,6 +242,19 @@ void\n dwarf_expr_context::read_mem (gdb_byte *buf, CORE_ADDR addr,\n \t\t\t      size_t length)\n {\n+  if (length == 0)\n+    return;\n+\n+  /* Prefer the passed-in memory, if it exists.  */\n+  CORE_ADDR offset = addr - this->obj_address;\n+\n+  if (offset < this->data_view.size ()\n+      && offset + length <= this->data_view.size ())\n+    {\n+      memcpy (buf, this->data_view.data (), length);\n+      return;\n+    }\n+\n   read_memory (addr, buf, length);\n }\n \n@@ -1573,8 +1586,11 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \tcase DW_OP_push_object_address:\n \t  /* Return the address of the object we are currently observing.  */\n-\t  result = this->get_object_address ();\n-\t  result_val = value_from_ulongest (address_type, result);\n+\t  if (this->data_view.data () == nullptr\n+\t      && this->obj_address == 0)\n+\t    error (_(\"Location address is not set.\"));\n+\n+\t  result_val = value_from_ulongest (address_type, this->obj_address);\n \t  break;\n \n \tdefault:"
    },
    {
      "sha": "76c073cf38f7bf58e1a45e2a34a9fdcde23f7d2b",
      "filename": "gdb/dwarf2/expr.h",
      "status": "modified",
      "additions": 8,
      "deletions": 10,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f9e4ed8baa9eeebc71be88f863c52f81e42bed34/gdb/dwarf2/expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f9e4ed8baa9eeebc71be88f863c52f81e42bed34/gdb/dwarf2/expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.h?ref=f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
      "patch": "@@ -191,16 +191,8 @@ struct dwarf_expr_context\n   /* Object address used for the evaluation.  */\n   CORE_ADDR obj_address = 0;\n \n-  /* Read LENGTH bytes at ADDR into BUF.  */\n-  virtual void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t length);\n-\n-  /* Return the `object address' for DW_OP_push_object_address.  */\n-  virtual CORE_ADDR get_object_address ()\n-  {\n-    if (obj_address == 0)\n-      error (_(\"Location address is not set.\"));\n-    return obj_address;\n-  }\n+  /* The data that was passed in.  */\n+  gdb::array_view<const gdb_byte> data_view;\n \n private:\n \n@@ -234,6 +226,12 @@ struct dwarf_expr_context\n   void push_dwarf_reg_entry_value (call_site_parameter_kind kind,\n \t\t\t\t   call_site_parameter_u kind_u,\n \t\t\t\t   int deref_size);\n+\n+  /* Read LENGTH bytes at ADDR into BUF.  This method also handles the\n+     case where a caller of the evaluator passes in some data,\n+     but with the address being 0.  In this situation, we arrange for\n+     memory reads to come from the passed-in buffer.  */\n+  void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t length);\n };\n \n /* Return the value of register number REG (a DWARF register number),"
    },
    {
      "sha": "6b9fc19ec054c103907167f68553f6ce105ab672",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 43,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f9e4ed8baa9eeebc71be88f863c52f81e42bed34/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f9e4ed8baa9eeebc71be88f863c52f81e42bed34/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
      "patch": "@@ -2262,45 +2262,6 @@ dwarf2_evaluate_loc_desc (struct type *type, struct frame_info *frame,\n \t\t\t\t\tper_objfile, NULL, 0);\n }\n \n-/* A specialization of dwarf_expr_context that is used by\n-   dwarf2_locexpr_baton_eval.  This subclass exists to handle the case\n-   where a caller of dwarf2_locexpr_baton_eval passes in some data,\n-   but with the address being 0.  In this situation, we arrange for\n-   memory reads to come from the passed-in buffer.  */\n-\n-struct evaluate_for_locexpr_baton : public dwarf_expr_context\n-{\n-  evaluate_for_locexpr_baton (dwarf2_per_objfile *per_objfile)\n-    : dwarf_expr_context (per_objfile)\n-  {}\n-\n-  /* The data that was passed in.  */\n-  gdb::array_view<const gdb_byte> data_view;\n-\n-  CORE_ADDR get_object_address () override\n-  {\n-    if (data_view.data () == nullptr && obj_address == 0)\n-      error (_(\"Location address is not set.\"));\n-    return obj_address;\n-  }\n-\n-  void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t len) override\n-  {\n-    if (len == 0)\n-      return;\n-\n-    /* Prefer the passed-in memory, if it exists.  */\n-    CORE_ADDR offset = addr - obj_address;\n-    if (offset < data_view.size () && offset + len <= data_view.size ())\n-      {\n-\tmemcpy (buf, data_view.data (), len);\n-\treturn;\n-      }\n-\n-    read_memory (addr, buf, len);\n-  }\n-};\n-\n /* Evaluates a dwarf expression and stores the result in VAL,\n    expecting that the dwarf expression only produces a single\n    CORE_ADDR.  FRAME is the frame in which the expression is\n@@ -2324,13 +2285,11 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n     return 0;\n \n   dwarf2_per_objfile *per_objfile = dlbaton->per_objfile;\n-  evaluate_for_locexpr_baton ctx (per_objfile);\n+  dwarf_expr_context ctx (per_objfile);\n \n   ctx.frame = frame;\n   ctx.per_cu = dlbaton->per_cu;\n-  if (addr_stack == nullptr)\n-    ctx.obj_address = 0;\n-  else\n+  if (addr_stack != nullptr)\n     {\n       ctx.obj_address = addr_stack->addr;\n       ctx.data_view = addr_stack->valaddr;"
    }
  ]
}