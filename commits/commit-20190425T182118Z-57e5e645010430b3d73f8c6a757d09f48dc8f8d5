{
  "sha": "57e5e645010430b3d73f8c6a757d09f48dc8f8d5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTdlNWU2NDUwMTA0MzBiM2Q3M2Y4YzZhNzU3ZDA5ZjQ4ZGM4ZjhkNQ==",
  "commit": {
    "author": {
      "name": "Sergio Durigan Junior",
      "email": "sergiodj@redhat.com",
      "date": "2019-04-23T22:17:57Z"
    },
    "committer": {
      "name": "Sergio Durigan Junior",
      "email": "sergiodj@redhat.com",
      "date": "2019-04-25T18:21:18Z"
    },
    "message": "Implement dump of mappings with ELF headers by gcore\n\nThis patch has a long story, but it all started back in 2015, with\ncommit df8411da087dc05481926f4c4a82deabc5bc3859 (\"Implement support\nfor checking /proc/PID/coredump_filter\").  The purpose of that commit\nwas to bring GDB's corefile generation closer to what the Linux kernel\ndoes.  However, back then, I did not implement the full support for\nthe dumping of memory mappings containing ELF headers (like mappings\nof DSOs or executables).  These mappings were being dumped most of\ntime, though, because the default value of /proc/PID/coredump_filter\nis 0x33, which would cause anonymous private mappings (DSOs/executable\ncode mappings have this type) to be dumped.  Well, until something\nhappened on binutils...\n\nA while ago, I noticed something strange was happening with one of our\nlocal testcases on Fedora GDB: it was failing due to some strange\nbuild-id problem.  On Fedora GDB, we (unfortunately) carry a bunch of\n\"local\" patches, and some of these patches actually extend upstream's\nbuild-id support in order to generate more useful information for the\nuser of a Fedora system (for example, when the user loads a corefile\ninto GDB, we detect whether the executable that generated that\ncorefile is present, and if it's not we issue a warning suggesting\nthat it should be installed, while also providing the build-id of the\nexecutable).  A while ago, Fedora GDB stopped printing those warnings.\n\nI wanted to investigate this right away, and spent some time trying to\ndetermine what was going on, but other things happened and I got\nsidetracked.  Meanwhile, the bug started to be noticed by some of our\nusers, and its priority started changing.  Then, someone on IRC also\nmentioned the problem, and when I tried helping him, I noticed he\nwasn't running Fedora.  Hm...  So maybe the bug was *also* present\nupstream.\n\nAfter \"some\" time investigating, and with a lot of help from Keith and\nothers, I was finally able to determine that yes, the bug is also\npresent upstream, and that even though it started with a change in ld,\nit is indeed a GDB issue.\n\nSo, as I said, the problem started with binutils, more specifically\nafter the following commit was pushed:\n\n  commit f6aec96dce1ddbd8961a3aa8a2925db2021719bb\n  Author: H.J. Lu <hjl.tools@gmail.com>\n  Date:   Tue Feb 27 11:34:20 2018 -0800\n\n      ld: Add --enable-separate-code\n\nThis commit makes ld use \"-z separate-code\" by default on x86-64\nmachines.  What this means is that code pages and data pages are now\nseparated in the binary, which is confusing GDB when it tries to decide\nwhat to dump.\n\nBTW, Fedora 28 binutils doesn't have this code, which means that\nFedora 28 GDB doesn't have the problem.  From Fedora 29 on, binutils\nwas rebased and incorporated the commit above, which started causing\nFedora GDB to fail.\n\nAnyway, the first thing I tried was to pass \"-z max-page-size\" and\nspecify a bigger page size (I saw a patch that did this and was\nproposed to Linux, so I thought it might help).  Obviously, this\ndidn't work, because the real \"problem\" is that ld will always use\nseparate pages for code and data.  So I decided to look into how GDB\ndumped the pages, and that's where I found the real issue.\n\nWhat happens is that, because of \"-z separate-code\", the first two pages\nof the ELF binary are (from /proc/PID/smaps):\n\n  00400000-00401000 r--p 00000000 fc:01 799548                             /file\n  Size:                  4 kB\n  KernelPageSize:        4 kB\n  MMUPageSize:           4 kB\n  Rss:                   4 kB\n  Pss:                   4 kB\n  Shared_Clean:          0 kB\n  Shared_Dirty:          0 kB\n  Private_Clean:         4 kB\n  Private_Dirty:         0 kB\n  Referenced:            4 kB\n  Anonymous:             0 kB\n  LazyFree:              0 kB\n  AnonHugePages:         0 kB\n  ShmemPmdMapped:        0 kB\n  Shared_Hugetlb:        0 kB\n  Private_Hugetlb:       0 kB\n  Swap:                  0 kB\n  SwapPss:               0 kB\n  Locked:                0 kB\n  THPeligible:    0\n  VmFlags: rd mr mw me dw sd\n  00401000-00402000 r-xp 00001000 fc:01 799548                             /file\n  Size:                  4 kB\n  KernelPageSize:        4 kB\n  MMUPageSize:           4 kB\n  Rss:                   4 kB\n  Pss:                   4 kB\n  Shared_Clean:          0 kB\n  Shared_Dirty:          0 kB\n  Private_Clean:         0 kB\n  Private_Dirty:         4 kB\n  Referenced:            4 kB\n  Anonymous:             4 kB\n  LazyFree:              0 kB\n  AnonHugePages:         0 kB\n  ShmemPmdMapped:        0 kB\n  Shared_Hugetlb:        0 kB\n  Private_Hugetlb:       0 kB\n  Swap:                  0 kB\n  SwapPss:               0 kB\n  Locked:                0 kB\n  THPeligible:    0\n  VmFlags: rd ex mr mw me dw sd\n\nWhereas before, we had only one:\n\n  00400000-00401000 r-xp 00000000 fc:01 798593                             /file\n  Size:                  4 kB\n  KernelPageSize:        4 kB\n  MMUPageSize:           4 kB\n  Rss:                   4 kB\n  Pss:                   4 kB\n  Shared_Clean:          0 kB\n  Shared_Dirty:          0 kB\n  Private_Clean:         0 kB\n  Private_Dirty:         4 kB\n  Referenced:            4 kB\n  Anonymous:             4 kB\n  LazyFree:              0 kB\n  AnonHugePages:         0 kB\n  ShmemPmdMapped:        0 kB\n  Shared_Hugetlb:        0 kB\n  Private_Hugetlb:       0 kB\n  Swap:                  0 kB\n  SwapPss:               0 kB\n  Locked:                0 kB\n  THPeligible:    0\n  VmFlags: rd ex mr mw me dw sd\n\nNotice how we have \"Anonymous\" data mapped into the page.  This will be\nimportant.\n\nSo, the way GDB decides which pages it should dump has been revamped\nby my patch in 2015, and now it takes the contents of\n/proc/PID/coredump_filter into account.  The default value for Linux\nis 0x33, which means:\n\n  Dump anonymous private, anonymous shared, ELF headers and HugeTLB\n  private pages.\n\nOr:\n\n  filter_flags filterflags = (COREFILTER_ANON_PRIVATE\n\t\t\t      | COREFILTER_ANON_SHARED\n\t\t\t      | COREFILTER_ELF_HEADERS\n\t\t\t      | COREFILTER_HUGETLB_PRIVATE);\n\nNow, it is important to keep in mind that GDB doesn't always have *all*\nof the necessary information to exactly determine the type of a page, so\nthe whole algorithm is based on heuristics (you can take a look at\nlinux-tdep.c:dump_mapping_p and\nlinux-tdep.c:linux_find_memory_regions_full for more info).\n\nBefore the patch to make ld use \"-z separate-code\", the (single) page\ncontaining data and code was being flagged as an anonymous (due to the\nnon-zero \"Anonymous:\" field) private (due to the \"r-xp\" permission),\nwhich means that it was being dumped into the corefile.  That's why it\nwas working fine.\n\nNow, as you can imagine, when \"-z separate-code\" is used, the *data*\npage (which is where the ELF notes are, including the build-id one) now\ndoesn't have any \"Anonymous:\" mapping, so the heuristic is flagging it\nas file-backed private, which is *not* dumped by default.\n\nThe next question I had to answer was: how come a corefile generated by\nthe Linux kernel was correct?  Well, the answer is that GDB, unlike\nLinux, doesn't actually implement the COREFILTER_ELF_HEADERS support.\nOn Linux, even though the data page is also treated as a file-backed\nprivate mapping, it is also checked to see if there are any ELF headers\nin the page, and then, because we *do* have ELF headers there, it is\ndumped.\n\nSo, after more time trying to think of ways to fix this, I was able to\nimplement an algorithm that reads the first few bytes of the memory\nmapping being processed, and checks to see if the ELF magic code is\npresent.  This is basically what Linux does as well, except that, if\nit finds the ELF magic code, it just dumps one page to the corefile,\nwhereas GDB will dump the whole mapping.  But I don't think that's a\nbig issue, to be honest.\n\nIt's also important to explain that we *only* perform the ELF magic\ncode check if:\n\n  - The algorithm has decided *not* to dump the mapping so far, and;\n  - The mapping is private, and;\n  - The mapping's offset is zero, and;\n  - The user has requested us to dump mappings with ELF headers.\n\nIOW, we're not going to blindly check every mapping.\n\nAs for the testcase, I struggled even more trying to write it.  Since\nour build-id support on upstream GDB is not very extensive, it's not\nreally possible to determine whether a corefile contains build-id\ninformation or not just by using GDB.  So, after thinking a lot about\nthe problem, I decided to rely on an external tool, eu-unstrip, in\norder to verify whether the dump was successful.  I verified the test\nhere on my machine, and everything seems to work as expected (i.e., it\nfails without the patch, and works with the patch applied).  We are\nworking hard to upstream our \"local\" Fedora GDB patches, and we intend\nto submit our build-id extension patches \"soon\", so hopefully we'll be\nable to use GDB itself to perform this verification.\n\nI built and regtested this on the BuildBot, and no problems were\nfound.\n\ngdb/ChangeLog:\n2019-04-25  Sergio Durigan Junior  <sergiodj@redhat.com>\n\n\tPR corefiles/11608\n\tPR corefiles/18187\n\t* linux-tdep.c (dump_mapping_p): Add new parameters ADDR and\n\tOFFSET.  Verify if current mapping contains an ELF header.\n\t(linux_find_memory_regions_full): Adjust call to\n\tdump_mapping_p.\n\ngdb/testsuite/ChangeLog:\n2019-04-25  Sergio Durigan Junior  <sergiodj@redhat.com>\n\n\tPR corefiles/11608\n\tPR corefiles/18187\n\t* gdb.base/coredump-filter-build-id.exp: New file.",
    "tree": {
      "sha": "60c3a8f2dd47acc450b5965d8d02be0ae989f2cf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/60c3a8f2dd47acc450b5965d8d02be0ae989f2cf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/57e5e645010430b3d73f8c6a757d09f48dc8f8d5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/57e5e645010430b3d73f8c6a757d09f48dc8f8d5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/57e5e645010430b3d73f8c6a757d09f48dc8f8d5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/57e5e645010430b3d73f8c6a757d09f48dc8f8d5/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "dd06d4d6889ee58b76255b775f52ba8e475a7a2d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dd06d4d6889ee58b76255b775f52ba8e475a7a2d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dd06d4d6889ee58b76255b775f52ba8e475a7a2d"
    }
  ],
  "stats": {
    "total": 152,
    "additions": 139,
    "deletions": 13
  },
  "files": [
    {
      "sha": "c1666d189ae009b594d906ca7a87091ea535e05f",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 60,
      "deletions": 13,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57e5e645010430b3d73f8c6a757d09f48dc8f8d5/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57e5e645010430b3d73f8c6a757d09f48dc8f8d5/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=57e5e645010430b3d73f8c6a757d09f48dc8f8d5",
      "patch": "@@ -586,8 +586,8 @@ mapping_is_anonymous_p (const char *filename)\n }\n \n /* Return 0 if the memory mapping (which is related to FILTERFLAGS, V,\n-   MAYBE_PRIVATE_P, and MAPPING_ANONYMOUS_P) should not be dumped, or\n-   greater than 0 if it should.\n+   MAYBE_PRIVATE_P, MAPPING_ANONYMOUS_P, ADDR and OFFSET) should not\n+   be dumped, or greater than 0 if it should.\n \n    In a nutshell, this is the logic that we follow in order to decide\n    if a mapping should be dumped or not.\n@@ -625,12 +625,17 @@ mapping_is_anonymous_p (const char *filename)\n      see 'p' in the permission flags, then we assume that the mapping\n      is private, even though the presence of the 's' flag there would\n      mean VM_MAYSHARE, which means the mapping could still be private.\n-     This should work OK enough, however.  */\n+     This should work OK enough, however.\n+\n+   - Even if, at the end, we decided that we should not dump the\n+     mapping, we still have to check if it is something like an ELF\n+     header (of a DSO or an executable, for example).  If it is, and\n+     if the user is interested in dump it, then we should dump it.  */\n \n static int\n dump_mapping_p (filter_flags filterflags, const struct smaps_vmflags *v,\n \t\tint maybe_private_p, int mapping_anon_p, int mapping_file_p,\n-\t\tconst char *filename)\n+\t\tconst char *filename, ULONGEST addr, ULONGEST offset)\n {\n   /* Initially, we trust in what we received from our caller.  This\n      value may not be very precise (i.e., it was probably gathered\n@@ -640,6 +645,7 @@ dump_mapping_p (filter_flags filterflags, const struct smaps_vmflags *v,\n      (assuming that the version of the Linux kernel being used\n      supports it, of course).  */\n   int private_p = maybe_private_p;\n+  int dump_p;\n \n   /* We always dump vDSO and vsyscall mappings, because it's likely that\n      there'll be no file to read the contents from at core load time.\n@@ -680,13 +686,13 @@ dump_mapping_p (filter_flags filterflags, const struct smaps_vmflags *v,\n \t  /* This is a special situation.  It can happen when we see a\n \t     mapping that is file-backed, but that contains anonymous\n \t     pages.  */\n-\t  return ((filterflags & COREFILTER_ANON_PRIVATE) != 0\n-\t\t  || (filterflags & COREFILTER_MAPPED_PRIVATE) != 0);\n+\t  dump_p = ((filterflags & COREFILTER_ANON_PRIVATE) != 0\n+\t\t    || (filterflags & COREFILTER_MAPPED_PRIVATE) != 0);\n \t}\n       else if (mapping_anon_p)\n-\treturn (filterflags & COREFILTER_ANON_PRIVATE) != 0;\n+\tdump_p = (filterflags & COREFILTER_ANON_PRIVATE) != 0;\n       else\n-\treturn (filterflags & COREFILTER_MAPPED_PRIVATE) != 0;\n+\tdump_p = (filterflags & COREFILTER_MAPPED_PRIVATE) != 0;\n     }\n   else\n     {\n@@ -695,14 +701,55 @@ dump_mapping_p (filter_flags filterflags, const struct smaps_vmflags *v,\n \t  /* This is a special situation.  It can happen when we see a\n \t     mapping that is file-backed, but that contains anonymous\n \t     pages.  */\n-\t  return ((filterflags & COREFILTER_ANON_SHARED) != 0\n-\t\t  || (filterflags & COREFILTER_MAPPED_SHARED) != 0);\n+\t  dump_p = ((filterflags & COREFILTER_ANON_SHARED) != 0\n+\t\t    || (filterflags & COREFILTER_MAPPED_SHARED) != 0);\n \t}\n       else if (mapping_anon_p)\n-\treturn (filterflags & COREFILTER_ANON_SHARED) != 0;\n+\tdump_p = (filterflags & COREFILTER_ANON_SHARED) != 0;\n       else\n-\treturn (filterflags & COREFILTER_MAPPED_SHARED) != 0;\n+\tdump_p = (filterflags & COREFILTER_MAPPED_SHARED) != 0;\n     }\n+\n+  /* Even if we decided that we shouldn't dump this mapping, we still\n+     have to check whether (a) the user wants us to dump mappings\n+     containing an ELF header, and (b) the mapping in question\n+     contains an ELF header.  If (a) and (b) are true, then we should\n+     dump this mapping.\n+\n+     A mapping contains an ELF header if it is a private mapping, its\n+     offset is zero, and its first word is ELFMAG.  */\n+  if (!dump_p && private_p && offset == 0\n+      && (filterflags & COREFILTER_ELF_HEADERS) != 0)\n+    {\n+      /* Let's check if we have an ELF header.  */\n+      gdb::unique_xmalloc_ptr<char> header;\n+      int errcode;\n+\n+      /* Useful define specifying the size of the ELF magical\n+\t header.  */\n+#ifndef SELFMAG\n+#define SELFMAG 4\n+#endif\n+\n+      /* Read the first SELFMAG bytes and check if it is ELFMAG.  */\n+      if (target_read_string (addr, &header, SELFMAG, &errcode) == SELFMAG\n+\t  && errcode == 0)\n+\t{\n+\t  const char *h = header.get ();\n+\n+\t  /* The EI_MAG* and ELFMAG* constants come from\n+\t     <elf/common.h>.  */\n+\t  if (h[EI_MAG0] == ELFMAG0 && h[EI_MAG1] == ELFMAG1\n+\t      && h[EI_MAG2] == ELFMAG2 && h[EI_MAG3] == ELFMAG3)\n+\t    {\n+\t      /* This mapping contains an ELF header, so we\n+\t\t should dump it.  */\n+\t      dump_p = 1;\n+\t    }\n+\t}\n+    }\n+\n+  return dump_p;\n }\n \n /* Implement the \"info proc\" command.  */\n@@ -1306,7 +1353,7 @@ linux_find_memory_regions_full (struct gdbarch *gdbarch,\n \t  if (has_anonymous)\n \t    should_dump_p = dump_mapping_p (filterflags, &v, priv,\n \t\t\t\t\t    mapping_anon_p, mapping_file_p,\n-\t\t\t\t\t    filename);\n+\t\t\t\t\t    filename, addr, offset);\n \t  else\n \t    {\n \t      /* Older Linux kernels did not support the \"Anonymous:\" counter."
    },
    {
      "sha": "fc2b039406a5156c87f97c439c24fd7a3809b17f",
      "filename": "gdb/testsuite/gdb.base/coredump-filter-build-id.exp",
      "status": "added",
      "additions": 69,
      "deletions": 0,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57e5e645010430b3d73f8c6a757d09f48dc8f8d5/gdb/testsuite/gdb.base/coredump-filter-build-id.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57e5e645010430b3d73f8c6a757d09f48dc8f8d5/gdb/testsuite/gdb.base/coredump-filter-build-id.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/coredump-filter-build-id.exp?ref=57e5e645010430b3d73f8c6a757d09f48dc8f8d5",
      "patch": "@@ -0,0 +1,69 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test whether GDB's gcore/generate-core-file command can dump memory\n+# mappings with ELF headers, containing a build-id note.\n+#\n+# Due to the fact that we don't have an easy way to process a corefile\n+# and look for specific notes using GDB/dejagnu, we rely on an\n+# external tool, eu-unstrip, to verify if the corefile contains\n+# build-ids.\n+\n+standard_testfile \"normal.c\"\n+\n+# This test is Linux x86_64 only.\n+if { ![istarget *-*-linux*] } {\n+    untested \"$testfile.exp\"\n+    return -1\n+}\n+if { ![istarget \"x86_64-*-*\"] || ![is_lp64_target] } {\n+    untested \"$testfile.exp\"\n+    return -1\n+}\n+\n+if { [prepare_for_testing \"failed to prepare\" $testfile $srcfile debug] } {\n+    return -1\n+}\n+\n+if { ![runto_main] } {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+# First we need to generate a corefile.\n+set corefilename \"[standard_output_file gcore.test]\"\n+if { ![gdb_gcore_cmd \"$corefilename\" \"save corefile\"] } {\n+    verbose -log \"Could not save corefile\"\n+    untested \"$testfile.exp\"\n+    return -1\n+}\n+\n+# Determine if GDB dumped the mapping containing the build-id.  This\n+# is done by invoking an external program (eu-unstrip).\n+if { [catch \"exec [gdb_find_eu-unstrip] -n --core $corefilename\" output] == 0 } {\n+    set line [lindex [split $output \"\\n\"] 0]\n+    set test \"gcore dumped mapping with build-id\"\n+\n+    verbose -log \"First line of eu-unstrip: $line\"\n+\n+    if { [regexp \"^${hex}\\\\+${hex} \\[a-f0-9\\]+@${hex}.*[string_to_regexp $binfile]$\" $line] } {\n+\tpass \"$test\"\n+    } else {\n+\tfail \"$test\"\n+    }\n+} else {\n+    verbose -log \"Could not execute eu-unstrip program\"\n+    untested \"$testfile.exp\"\n+}"
    },
    {
      "sha": "122e652858f92ec0f4b4500216da39111ab121fd",
      "filename": "gdb/testsuite/lib/future.exp",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57e5e645010430b3d73f8c6a757d09f48dc8f8d5/gdb/testsuite/lib/future.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57e5e645010430b3d73f8c6a757d09f48dc8f8d5/gdb/testsuite/lib/future.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/future.exp?ref=57e5e645010430b3d73f8c6a757d09f48dc8f8d5",
      "patch": "@@ -162,6 +162,16 @@ proc gdb_find_readelf {} {\n     return $readelf\n }\n \n+proc gdb_find_eu-unstrip {} {\n+    global EU_UNSTRIP_FOR_TARGET\n+    if [info exists EU_UNSTRIP_FOR_TARGET] {\n+\tset eu_unstrip $EU_UNSTRIP_FOR_TARGET\n+    } else {\n+\tset eu_unstrip [transform eu-unstrip]\n+    }\n+    return $eu_unstrip\n+}\n+\n proc gdb_default_target_compile {source destfile type options} {\n     global target_triplet\n     global tool_root_dir"
    }
  ]
}