{
  "sha": "162dce5526debd7fbc3a4516c37ee6178bab6e5b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTYyZGNlNTUyNmRlYmQ3ZmJjM2E0NTE2YzM3ZWU2MTc4YmFiNmU1Yg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:56Z"
    },
    "message": "Create dwarf2/attribute.[ch]\n\nThis moves the attribute-related code out of dwarf2read.c and into the\nnew files dwarf2/attribute.[ch].\n\ngdb/ChangeLog\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2read.c (struct attribute, DW_STRING)\n\t(DW_STRING_IS_CANONICAL, DW_UNSND, DW_BLOCK, DW_SND, DW_ADDR)\n\t(DW_SIGNATURE, struct dwarf_block, attr_value_as_address)\n\t(attr_form_is_block, attr_form_is_section_offset)\n\t(attr_form_is_constant, attr_form_is_ref): Move.\n\t* dwarf2/attribute.h: New file.\n\t* dwarf2/attribute.c: New file, from dwarf2read.c.\n\t* Makefile.in (COMMON_SFILES): Add dwarf2/attribute.c.\n\nChange-Id: I1ea4c146256a1b9e38b66f1c605d782a14eeded7",
    "tree": {
      "sha": "d9b3a39c5458a76bf70f193b4dcc2338c24ca887",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d9b3a39c5458a76bf70f193b4dcc2338c24ca887"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/162dce5526debd7fbc3a4516c37ee6178bab6e5b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/162dce5526debd7fbc3a4516c37ee6178bab6e5b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/162dce5526debd7fbc3a4516c37ee6178bab6e5b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/162dce5526debd7fbc3a4516c37ee6178bab6e5b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3054dd54700066c423fe73731ab46ea2a9c3f541",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3054dd54700066c423fe73731ab46ea2a9c3f541",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3054dd54700066c423fe73731ab46ea2a9c3f541"
    }
  ],
  "stats": {
    "total": 421,
    "additions": 253,
    "deletions": 168
  },
  "files": [
    {
      "sha": "741d4bfbc4589abfe99ce8fac187bf8cdda1210a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=162dce5526debd7fbc3a4516c37ee6178bab6e5b",
      "patch": "@@ -1,3 +1,14 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2read.c (struct attribute, DW_STRING)\n+\t(DW_STRING_IS_CANONICAL, DW_UNSND, DW_BLOCK, DW_SND, DW_ADDR)\n+\t(DW_SIGNATURE, struct dwarf_block, attr_value_as_address)\n+\t(attr_form_is_block, attr_form_is_section_offset)\n+\t(attr_form_is_constant, attr_form_is_ref): Move.\n+\t* dwarf2/attribute.h: New file.\n+\t* dwarf2/attribute.c: New file, from dwarf2read.c.\n+\t* Makefile.in (COMMON_SFILES): Add dwarf2/attribute.c.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2read.c (abbrev_table_up, struct abbrev_info)"
    },
    {
      "sha": "b726ae8cb266fcf347435ca2ee2b92bd73493688",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=162dce5526debd7fbc3a4516c37ee6178bab6e5b",
      "patch": "@@ -1003,6 +1003,7 @@ COMMON_SFILES = \\\n \tdwarf2loc.c \\\n \tdwarf2read.c \\\n \tdwarf2/abbrev.c \\\n+\tdwarf2/attribute.c \\\n \tdwarf2/leb.c \\\n \tdwarf2/section.c \\\n \teval.c \\"
    },
    {
      "sha": "75a2fa3774bc01e4f7182ad7ceaad4879154a455",
      "filename": "gdb/dwarf2/attribute.c",
      "status": "added",
      "additions": 122,
      "deletions": 0,
      "changes": 122,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/dwarf2/attribute.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/dwarf2/attribute.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.c?ref=162dce5526debd7fbc3a4516c37ee6178bab6e5b",
      "patch": "@@ -0,0 +1,122 @@\n+/* DWARF attributes\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"dwarf2/attribute.h\"\n+\n+/* See attribute.h.  */\n+\n+CORE_ADDR\n+attr_value_as_address (struct attribute *attr)\n+{\n+  CORE_ADDR addr;\n+\n+  if (attr->form != DW_FORM_addr && attr->form != DW_FORM_addrx\n+      && attr->form != DW_FORM_GNU_addr_index)\n+    {\n+      /* Aside from a few clearly defined exceptions, attributes that\n+\t contain an address must always be in DW_FORM_addr form.\n+\t Unfortunately, some compilers happen to be violating this\n+\t requirement by encoding addresses using other forms, such\n+\t as DW_FORM_data4 for example.  For those broken compilers,\n+\t we try to do our best, without any guarantee of success,\n+\t to interpret the address correctly.  It would also be nice\n+\t to generate a complaint, but that would require us to maintain\n+\t a list of legitimate cases where a non-address form is allowed,\n+\t as well as update callers to pass in at least the CU's DWARF\n+\t version.  This is more overhead than what we're willing to\n+\t expand for a pretty rare case.  */\n+      addr = DW_UNSND (attr);\n+    }\n+  else\n+    addr = DW_ADDR (attr);\n+\n+  return addr;\n+}\n+\n+/* See attribute.h.  */\n+\n+int\n+attr_form_is_block (const struct attribute *attr)\n+{\n+  return (attr == NULL ? 0 :\n+      attr->form == DW_FORM_block1\n+      || attr->form == DW_FORM_block2\n+      || attr->form == DW_FORM_block4\n+      || attr->form == DW_FORM_block\n+      || attr->form == DW_FORM_exprloc);\n+}\n+\n+/* See attribute.h.  */\n+\n+int\n+attr_form_is_section_offset (const struct attribute *attr)\n+{\n+  return (attr->form == DW_FORM_data4\n+          || attr->form == DW_FORM_data8\n+\t  || attr->form == DW_FORM_sec_offset);\n+}\n+\n+/* See attribute.h.  */\n+\n+int\n+attr_form_is_constant (const struct attribute *attr)\n+{\n+  switch (attr->form)\n+    {\n+    case DW_FORM_sdata:\n+    case DW_FORM_udata:\n+    case DW_FORM_data1:\n+    case DW_FORM_data2:\n+    case DW_FORM_data4:\n+    case DW_FORM_data8:\n+    case DW_FORM_implicit_const:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* DW_ADDR is always stored already as sect_offset; despite for the forms\n+   besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */\n+\n+int\n+attr_form_is_ref (const struct attribute *attr)\n+{\n+  switch (attr->form)\n+    {\n+    case DW_FORM_ref_addr:\n+    case DW_FORM_ref1:\n+    case DW_FORM_ref2:\n+    case DW_FORM_ref4:\n+    case DW_FORM_ref8:\n+    case DW_FORM_ref_udata:\n+    case DW_FORM_GNU_ref_alt:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}"
    },
    {
      "sha": "11c6cb929d9dfe7eeed6663f4f4e951d7516ac4b",
      "filename": "gdb/dwarf2/attribute.h",
      "status": "added",
      "additions": 118,
      "deletions": 0,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/dwarf2/attribute.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/dwarf2/attribute.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.h?ref=162dce5526debd7fbc3a4516c37ee6178bab6e5b",
      "patch": "@@ -0,0 +1,118 @@\n+/* DWARF attributes\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDB_DWARF2_ATTRIBUTE_H\n+#define GDB_DWARF2_ATTRIBUTE_H\n+\n+#include \"dwarf2.h\"\n+\n+/* Blocks are a bunch of untyped bytes.  */\n+struct dwarf_block\n+{\n+  size_t size;\n+\n+  /* Valid only if SIZE is not zero.  */\n+  const gdb_byte *data;\n+};\n+\n+/* Attributes have a name and a value.  */\n+struct attribute\n+{\n+  ENUM_BITFIELD(dwarf_attribute) name : 16;\n+  ENUM_BITFIELD(dwarf_form) form : 15;\n+\n+  /* Has DW_STRING already been updated by dwarf2_canonicalize_name?  This\n+     field should be in u.str (existing only for DW_STRING) but it is kept\n+     here for better struct attribute alignment.  */\n+  unsigned int string_is_canonical : 1;\n+\n+  union\n+    {\n+      const char *str;\n+      struct dwarf_block *blk;\n+      ULONGEST unsnd;\n+      LONGEST snd;\n+      CORE_ADDR addr;\n+      ULONGEST signature;\n+    }\n+  u;\n+};\n+\n+/* Get at parts of an attribute structure.  */\n+\n+#define DW_STRING(attr)    ((attr)->u.str)\n+#define DW_STRING_IS_CANONICAL(attr) ((attr)->string_is_canonical)\n+#define DW_UNSND(attr)     ((attr)->u.unsnd)\n+#define DW_BLOCK(attr)     ((attr)->u.blk)\n+#define DW_SND(attr)       ((attr)->u.snd)\n+#define DW_ADDR(attr)\t   ((attr)->u.addr)\n+#define DW_SIGNATURE(attr) ((attr)->u.signature)\n+\n+/* Read the given attribute value as an address, taking the attribute's\n+   form into account.  */\n+\n+extern CORE_ADDR attr_value_as_address (struct attribute *attr);\n+\n+/* Check if the attribute's form is a DW_FORM_block*\n+   if so return true else false.  */\n+\n+extern int attr_form_is_block (const struct attribute *attr);\n+\n+/* Return non-zero if ATTR's value is a section offset --- classes\n+   lineptr, loclistptr, macptr or rangelistptr --- or zero, otherwise.\n+   You may use DW_UNSND (attr) to retrieve such offsets.\n+\n+   Section 7.5.4, \"Attribute Encodings\", explains that no attribute\n+   may have a value that belongs to more than one of these classes; it\n+   would be ambiguous if we did, because we use the same forms for all\n+   of them.  */\n+\n+extern int attr_form_is_section_offset (const struct attribute *attr);\n+\n+/* Return non-zero if ATTR's value falls in the 'constant' class, or\n+   zero otherwise.  When this function returns true, you can apply\n+   dwarf2_get_attr_constant_value to it.\n+\n+   However, note that for some attributes you must check\n+   attr_form_is_section_offset before using this test.  DW_FORM_data4\n+   and DW_FORM_data8 are members of both the constant class, and of\n+   the classes that contain offsets into other debug sections\n+   (lineptr, loclistptr, macptr or rangelistptr).  The DWARF spec says\n+   that, if an attribute's can be either a constant or one of the\n+   section offset classes, DW_FORM_data4 and DW_FORM_data8 should be\n+   taken as section offsets, not constants.\n+\n+   DW_FORM_data16 is not considered as dwarf2_get_attr_constant_value\n+   cannot handle that.  */\n+\n+extern int attr_form_is_constant (const struct attribute *attr);\n+\n+/* DW_ADDR is always stored already as sect_offset; despite for the forms\n+   besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */\n+\n+extern int attr_form_is_ref (const struct attribute *attr);\n+\n+#endif /* GDB_DWARF2_ATTRIBUTE_H */"
    },
    {
      "sha": "02bf1ef3d44e424e73030d72388e2c37f0b38026",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 1,
      "deletions": 168,
      "changes": 169,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/162dce5526debd7fbc3a4516c37ee6178bab6e5b/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=162dce5526debd7fbc3a4516c37ee6178bab6e5b",
      "patch": "@@ -31,6 +31,7 @@\n #include \"defs.h\"\n #include \"dwarf2read.h\"\n #include \"dwarf2/abbrev.h\"\n+#include \"dwarf2/attribute.h\"\n #include \"dwarf-index-cache.h\"\n #include \"dwarf-index-common.h\"\n #include \"dwarf2/leb.h\"\n@@ -1233,29 +1234,6 @@ struct partial_die_info : public allocate_on_obstack\n     }\n   };\n \n-/* Attributes have a name and a value.  */\n-struct attribute\n-  {\n-    ENUM_BITFIELD(dwarf_attribute) name : 16;\n-    ENUM_BITFIELD(dwarf_form) form : 15;\n-\n-    /* Has DW_STRING already been updated by dwarf2_canonicalize_name?  This\n-       field should be in u.str (existing only for DW_STRING) but it is kept\n-       here for better struct attribute alignment.  */\n-    unsigned int string_is_canonical : 1;\n-\n-    union\n-      {\n-\tconst char *str;\n-\tstruct dwarf_block *blk;\n-\tULONGEST unsnd;\n-\tLONGEST snd;\n-\tCORE_ADDR addr;\n-\tULONGEST signature;\n-      }\n-    u;\n-  };\n-\n /* This data structure holds a complete die structure.  */\n struct die_info\n   {\n@@ -1292,25 +1270,6 @@ struct die_info\n     struct attribute attrs[1];\n   };\n \n-/* Get at parts of an attribute structure.  */\n-\n-#define DW_STRING(attr)    ((attr)->u.str)\n-#define DW_STRING_IS_CANONICAL(attr) ((attr)->string_is_canonical)\n-#define DW_UNSND(attr)     ((attr)->u.unsnd)\n-#define DW_BLOCK(attr)     ((attr)->u.blk)\n-#define DW_SND(attr)       ((attr)->u.snd)\n-#define DW_ADDR(attr)\t   ((attr)->u.addr)\n-#define DW_SIGNATURE(attr) ((attr)->u.signature)\n-\n-/* Blocks are a bunch of untyped bytes.  */\n-struct dwarf_block\n-  {\n-    size_t size;\n-\n-    /* Valid only if SIZE is not zero.  */\n-    const gdb_byte *data;\n-  };\n-\n /* FIXME: We might want to set this from BFD via bfd_arch_bits_per_byte,\n    but this would require a corresponding change in unpack_field_as_long\n    and friends.  */\n@@ -1780,14 +1739,6 @@ static struct die_info *dwarf_alloc_die (struct dwarf2_cu *, int);\n \n static void dwarf_decode_macros (struct dwarf2_cu *, unsigned int, int);\n \n-static int attr_form_is_block (const struct attribute *);\n-\n-static int attr_form_is_section_offset (const struct attribute *);\n-\n-static int attr_form_is_constant (const struct attribute *);\n-\n-static int attr_form_is_ref (const struct attribute *);\n-\n static void fill_in_loclist_baton (struct dwarf2_cu *cu,\n \t\t\t\t   struct dwarf2_loclist_baton *baton,\n \t\t\t\t   const struct attribute *attr);\n@@ -2050,37 +2001,6 @@ line_header_eq_voidp (const void *item_lhs, const void *item_rhs)\n \n \f\n \n-/* Read the given attribute value as an address, taking the attribute's\n-   form into account.  */\n-\n-static CORE_ADDR\n-attr_value_as_address (struct attribute *attr)\n-{\n-  CORE_ADDR addr;\n-\n-  if (attr->form != DW_FORM_addr && attr->form != DW_FORM_addrx\n-      && attr->form != DW_FORM_GNU_addr_index)\n-    {\n-      /* Aside from a few clearly defined exceptions, attributes that\n-\t contain an address must always be in DW_FORM_addr form.\n-\t Unfortunately, some compilers happen to be violating this\n-\t requirement by encoding addresses using other forms, such\n-\t as DW_FORM_data4 for example.  For those broken compilers,\n-\t we try to do our best, without any guarantee of success,\n-\t to interpret the address correctly.  It would also be nice\n-\t to generate a complaint, but that would require us to maintain\n-\t a list of legitimate cases where a non-address form is allowed,\n-\t as well as update callers to pass in at least the CU's DWARF\n-\t version.  This is more overhead than what we're willing to\n-\t expand for a pretty rare case.  */\n-      addr = DW_UNSND (attr);\n-    }\n-  else\n-    addr = DW_ADDR (attr);\n-\n-  return addr;\n-}\n-\n /* See declaration.  */\n \n dwarf2_per_objfile::dwarf2_per_objfile (struct objfile *objfile_,\n@@ -24814,93 +24734,6 @@ dwarf_decode_macros (struct dwarf2_cu *cu, unsigned int offset,\n \t\t\t    include_hash.get ());\n }\n \n-/* Check if the attribute's form is a DW_FORM_block*\n-   if so return true else false.  */\n-\n-static int\n-attr_form_is_block (const struct attribute *attr)\n-{\n-  return (attr == NULL ? 0 :\n-      attr->form == DW_FORM_block1\n-      || attr->form == DW_FORM_block2\n-      || attr->form == DW_FORM_block4\n-      || attr->form == DW_FORM_block\n-      || attr->form == DW_FORM_exprloc);\n-}\n-\n-/* Return non-zero if ATTR's value is a section offset --- classes\n-   lineptr, loclistptr, macptr or rangelistptr --- or zero, otherwise.\n-   You may use DW_UNSND (attr) to retrieve such offsets.\n-\n-   Section 7.5.4, \"Attribute Encodings\", explains that no attribute\n-   may have a value that belongs to more than one of these classes; it\n-   would be ambiguous if we did, because we use the same forms for all\n-   of them.  */\n-\n-static int\n-attr_form_is_section_offset (const struct attribute *attr)\n-{\n-  return (attr->form == DW_FORM_data4\n-          || attr->form == DW_FORM_data8\n-\t  || attr->form == DW_FORM_sec_offset);\n-}\n-\n-/* Return non-zero if ATTR's value falls in the 'constant' class, or\n-   zero otherwise.  When this function returns true, you can apply\n-   dwarf2_get_attr_constant_value to it.\n-\n-   However, note that for some attributes you must check\n-   attr_form_is_section_offset before using this test.  DW_FORM_data4\n-   and DW_FORM_data8 are members of both the constant class, and of\n-   the classes that contain offsets into other debug sections\n-   (lineptr, loclistptr, macptr or rangelistptr).  The DWARF spec says\n-   that, if an attribute's can be either a constant or one of the\n-   section offset classes, DW_FORM_data4 and DW_FORM_data8 should be\n-   taken as section offsets, not constants.\n-\n-   DW_FORM_data16 is not considered as dwarf2_get_attr_constant_value\n-   cannot handle that.  */\n-\n-static int\n-attr_form_is_constant (const struct attribute *attr)\n-{\n-  switch (attr->form)\n-    {\n-    case DW_FORM_sdata:\n-    case DW_FORM_udata:\n-    case DW_FORM_data1:\n-    case DW_FORM_data2:\n-    case DW_FORM_data4:\n-    case DW_FORM_data8:\n-    case DW_FORM_implicit_const:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-\n-/* DW_ADDR is always stored already as sect_offset; despite for the forms\n-   besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */\n-\n-static int\n-attr_form_is_ref (const struct attribute *attr)\n-{\n-  switch (attr->form)\n-    {\n-    case DW_FORM_ref_addr:\n-    case DW_FORM_ref1:\n-    case DW_FORM_ref2:\n-    case DW_FORM_ref4:\n-    case DW_FORM_ref8:\n-    case DW_FORM_ref_udata:\n-    case DW_FORM_GNU_ref_alt:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n /* Return the .debug_loc section to use for CU.\n    For DWO files use .debug_loc.dwo.  */\n "
    }
  ]
}