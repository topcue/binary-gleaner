{
  "sha": "62e37eac1c5b9e4805d40715e7570f7146caa788",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjJlMzdlYWMxYzViOWU0ODA1ZDQwNzE1ZTc1NzBmNzE0NmNhYTc4OA==",
  "commit": {
    "author": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2020-09-14T15:05:14Z"
    },
    "committer": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2021-08-05T15:39:01Z"
    },
    "message": "Move frame context info to dwarf_expr_context\n\nFollowing 15 patches in this patch series is cleaning up the design of\nthe DWARF expression evaluator (dwarf_expr_context) to make future\nextensions of that evaluator easier and cleaner to implement.\n\nThere are three subclasses of the dwarf_expr_context class\n(dwarf_expr_executor, dwarf_evaluate_loc_desc and\nevaluate_for_locexpr_baton). Here is a short description of each class:\n\n- dwarf_expr_executor is evaluating a DWARF expression in a context\n  of a Call Frame Information. The overridden methods of this subclass\n  report an error if a specific DWARF operation, represented by that\n  method, is not allowed in a CFI context. The source code of this\n  subclass lacks the support for composite as well as implicit pointer\n  location description.\n\n- dwarf_evaluate_loc_desc can evaluate any expression with no\n  restrictions. All of the methods that this subclass overrides are\n  actually doing what they are intended to do. This subclass contains\n  a full support for all location description types.\n\n- evaluate_for_locexpr_baton subclass is a specialization of the\n  dwarf_evaluate_loc_desc subclass and it's function is to add\n  support for passed in buffers. This seems to be a way to go around\n  the fact that DWARF standard lacks a bit offset support for memory\n  location descriptions as well as using any location description for\n  the push object address functionality.\n\nIt all comes down to this question: what is a function of a DWARF\nexpression evaluator?\n\nIs it to evaluate the expression in a given context or to check the\ncorrectness of that expression in that context?\n\nCurrently, the only reason why there is a dwarf_expr_executor subclass\nis to report an invalid DWARF expression in a context of a CFI, but is\nthat what the evaluator is supposed to do considering that the evaluator\nis not tied to a given DWARF version?\n\nThere are more and more vendor and GNU extensions that are not part of\nthe DWARF standard, so is it that impossible to expect that some of the\nextensions could actually lift the previously imposed restrictions of\nthe CFI context? Not to mention that every new DWARF version is lifting\nsome restrictions anyway.\n\nThe thing that makes more sense for an evaluator to do, is to take the\ncontext of an evaluation and checks the requirements of every operation\nevaluated against that context. With this approach, the evaluator would\nreport an error only if parts of the context, necessary for the\nevaluation, are missing.\n\nIf this approach is taken, then the unification of the\ndwarf_evaluate_loc_desc, dwarf_expr_executor and dwarf_expr_context\nis the next logical step. This makes a design of the DWARF expression\nevaluator cleaner and allows more flexibility when supporting future\nvendor and GNU extensions.\n\nAdditional benefit here is that now all evaluators have access to all\nlocation description types, which means that a vendor extended CFI\nrules could support composite location description as well. This also\nmeans that a new evaluator interface can be changed to return a single\nstruct value (that describes the result of the evaluation) instead of\na caller poking around the dwarf_expr_context internal data for answers\n(like it is done currently).\n\nThis patch starts the merging process by moving the frame context\ninformation and support from dwarf_expr_executor and\ndwarf_evaluate_loc_desc to dwarf_expr_context evaluator. The idea\nis to report an error when a given operation requires a frame\ninformation to be resolved, if that information is not present.\n\ngdb/ChangeLog:\n\n\t* dwarf2/expr.c (ensure_have_frame): New function.\n\t(read_addr_from_reg): Add from frame.c.\n\t(dwarf_expr_context::dwarf_expr_context): Add frame info to\n\tdwarf_expr_context.\n\t(dwarf_expr_context::read_addr_from_reg): Remove.\n\t(dwarf_expr_context::get_reg_value): Move from\n\tdwarf_evaluate_loc_desc.\n\t(dwarf_expr_context::get_frame_base): Move from\n\tdwarf_evaluate_loc_desc.\n\t(dwarf_expr_context::execute_stack_op): Call frame context info\n\tcheck. Remove use of read_addr_from_reg method.\n\t* dwarf2/expr.h (struct dwarf_expr_context): Add frame info\n\tmember, read_addr_from_reg, get_reg_value and get_frame_base\n\tdeclaration.\n\t(read_addr_from_reg): Move to expr.c.\n\t* dwarf2/frame.c (read_addr_from_reg): Move to\n\tdwarf_expr_context.\n\t(dwarf_expr_executor::read_addr_from_reg): Remove.\n\t(dwarf_expr_executor::get_frame_base): Remove.\n\t(dwarf_expr_executor::get_reg_value): Remove.\n\t(execute_stack_op): Use read_addr_from_reg function instead of\n\tread_addr_from_reg method.\n\t* dwarf2/loc.c (dwarf_evaluate_loc_desc::get_frame_base): Move\n\tto dwarf_expr_context.\n\t(dwarf_evaluate_loc_desc::get_reg_value): Move to\n\tdwarf_expr_context.\n\t(dwarf_evaluate_loc_desc::read_addr_from_reg): Remove.\n\t(dwarf2_locexpr_baton_eval):Use read_addr_from_reg function\n\tinstead of read_addr_from_reg method.",
    "tree": {
      "sha": "2f7803ee5ad3348a4aaf2a0d38e129b32c0d6f4d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2f7803ee5ad3348a4aaf2a0d38e129b32c0d6f4d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/62e37eac1c5b9e4805d40715e7570f7146caa788",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62e37eac1c5b9e4805d40715e7570f7146caa788",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/62e37eac1c5b9e4805d40715e7570f7146caa788",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62e37eac1c5b9e4805d40715e7570f7146caa788/comments",
  "author": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fb4cdecb7e3b9cab8a83f3e69a9deafcf53501fe",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fb4cdecb7e3b9cab8a83f3e69a9deafcf53501fe",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fb4cdecb7e3b9cab8a83f3e69a9deafcf53501fe"
    }
  ],
  "stats": {
    "total": 196,
    "additions": 91,
    "deletions": 105
  },
  "files": [
    {
      "sha": "0e992c162e592a8697a592fbfc47dad24a284b8c",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 71,
      "deletions": 3,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62e37eac1c5b9e4805d40715e7570f7146caa788/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62e37eac1c5b9e4805d40715e7570f7146caa788/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=62e37eac1c5b9e4805d40715e7570f7146caa788",
      "patch": "@@ -20,6 +20,7 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n+#include \"block.h\"\n #include \"symtab.h\"\n #include \"gdbtypes.h\"\n #include \"value.h\"\n@@ -56,6 +57,27 @@ dwarf_gdbarch_types_init (struct gdbarch *gdbarch)\n   return types;\n }\n \n+/* Ensure that a FRAME is defined, throw an exception otherwise.  */\n+\n+static void\n+ensure_have_frame (frame_info *frame, const char *op_name)\n+{\n+  if (frame == nullptr)\n+    throw_error (GENERIC_ERROR,\n+\t\t _(\"%s evaluation requires a frame.\"), op_name);\n+}\n+\n+/* See expr.h.  */\n+\n+CORE_ADDR\n+read_addr_from_reg (frame_info *frame, int reg)\n+{\n+  struct gdbarch *gdbarch = get_frame_arch (frame);\n+  int regnum = dwarf_reg_to_regnum_or_error (gdbarch, reg);\n+\n+  return address_from_register (regnum, frame);\n+}\n+\n /* Return the type used for DWARF operations where the type is\n    unspecified in the DWARF spec.  Only certain sizes are\n    supported.  */\n@@ -133,6 +155,47 @@ dwarf_expr_context::fetch (int n)\n   return stack[stack.size () - (1 + n)].value;\n }\n \n+/* See expr.h.  */\n+\n+struct value *\n+dwarf_expr_context::get_reg_value (struct type *type, int reg)\n+{\n+  ensure_have_frame (this->frame, \"DW_OP_regval_type\");\n+\n+  struct gdbarch *gdbarch = get_frame_arch (this->frame);\n+  int regnum = dwarf_reg_to_regnum_or_error (gdbarch, reg);\n+\n+  return value_from_register (type, regnum, this->frame);\n+}\n+\n+/* See expr.h.  */\n+\n+void\n+dwarf_expr_context::get_frame_base (const gdb_byte **start,\n+\t\t\t\t    size_t * length)\n+{\n+  ensure_have_frame (this->frame, \"DW_OP_fbreg\");\n+\n+  const block *bl = get_frame_block (this->frame, NULL);\n+\n+  if (bl == NULL)\n+    error (_(\"frame address is not available.\"));\n+\n+  /* Use block_linkage_function, which returns a real (not inlined)\n+     function, instead of get_frame_function, which may return an\n+     inlined function.  */\n+  symbol *framefunc = block_linkage_function (bl);\n+\n+  /* If we found a frame-relative symbol then it was certainly within\n+     some function associated with a frame. If we can't find the frame,\n+     something has gone wrong.  */\n+  gdb_assert (framefunc != NULL);\n+\n+  func_get_frame_base_dwarf_block (framefunc,\n+\t\t\t\t   get_frame_address_in_block (this->frame),\n+\t\t\t\t   start, length);\n+}\n+\n /* Require that TYPE be an integral type; throw an exception if not.  */\n \n static void\n@@ -821,7 +884,9 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \tcase DW_OP_breg31:\n \t  {\n \t    op_ptr = safe_read_sleb128 (op_ptr, op_end, &offset);\n-\t    result = this->read_addr_from_reg (op - DW_OP_breg0);\n+\t    ensure_have_frame (this->frame, \"DW_OP_breg\");\n+\n+\t    result = read_addr_from_reg (this->frame, op - DW_OP_breg0);\n \t    result += offset;\n \t    result_val = value_from_ulongest (address_type, result);\n \t  }\n@@ -830,7 +895,9 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t  {\n \t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &reg);\n \t    op_ptr = safe_read_sleb128 (op_ptr, op_end, &offset);\n-\t    result = this->read_addr_from_reg (reg);\n+\t    ensure_have_frame (this->frame, \"DW_OP_bregx\");\n+\n+\t    result = read_addr_from_reg (this->frame, reg);\n \t    result += offset;\n \t    result_val = value_from_ulongest (address_type, result);\n \t  }\n@@ -857,7 +924,8 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    if (this->location == DWARF_VALUE_MEMORY)\n \t      result = fetch_address (0);\n \t    else if (this->location == DWARF_VALUE_REGISTER)\n-\t      result = this->read_addr_from_reg (value_as_long (fetch (0)));\n+\t      result\n+\t\t= read_addr_from_reg (this->frame, value_as_long (fetch (0)));\n \t    else\n \t      error (_(\"Not implemented: computing frame \"\n \t\t       \"base using explicit value operator\"));"
    },
    {
      "sha": "b227690df4d847c803ec48b46208b1360e7534d1",
      "filename": "gdb/dwarf2/expr.h",
      "status": "modified",
      "additions": 17,
      "deletions": 14,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62e37eac1c5b9e4805d40715e7570f7146caa788/gdb/dwarf2/expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62e37eac1c5b9e4805d40715e7570f7146caa788/gdb/dwarf2/expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.h?ref=62e37eac1c5b9e4805d40715e7570f7146caa788",
      "patch": "@@ -186,24 +186,12 @@ struct dwarf_expr_context\n   /* We evaluate the expression in the context of this objfile.  */\n   dwarf2_per_objfile *per_objfile;\n \n-  /* Return the value of register number REGNUM (a DWARF register number),\n-     read as an address.  */\n-  virtual CORE_ADDR read_addr_from_reg (int regnum) = 0;\n-\n-  /* Return a value of type TYPE, stored in register number REGNUM\n-     of the frame associated to the given BATON.\n-\n-     REGNUM is a DWARF register number.  */\n-  virtual struct value *get_reg_value (struct type *type, int regnum) = 0;\n+  /* Frame information used for the evaluation.  */\n+  frame_info *frame = nullptr;\n \n   /* Read LENGTH bytes at ADDR into BUF.  */\n   virtual void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t length) = 0;\n \n-  /* Return the location expression for the frame base attribute, in\n-     START and LENGTH.  The result must be live until the current\n-     expression evaluation is complete.  */\n-  virtual void get_frame_base (const gdb_byte **start, size_t *length) = 0;\n-\n   /* Return the CFA for the frame.  */\n   virtual CORE_ADDR get_frame_cfa () = 0;\n \n@@ -259,8 +247,23 @@ struct dwarf_expr_context\n   void add_piece (ULONGEST size, ULONGEST offset);\n   void execute_stack_op (const gdb_byte *op_ptr, const gdb_byte *op_end);\n   void pop ();\n+\n+  /* Return a value of type TYPE, stored in register number REGNUM\n+     in a current context.\n+\n+     REGNUM is a DWARF register number.  */\n+  struct value *get_reg_value (struct type *type, int regnum);\n+\n+  /* Return the location expression for the frame base attribute, in\n+     START and LENGTH.  The result must be live until the current\n+     expression evaluation is complete.  */\n+  void get_frame_base (const gdb_byte **start, size_t *length);\n };\n \n+/* Return the value of register number REG (a DWARF register number),\n+   read as an address in a given FRAME.  */\n+CORE_ADDR read_addr_from_reg (frame_info *frame, int reg);\n+\n void dwarf_expr_require_composition (const gdb_byte *, const gdb_byte *,\n \t\t\t\t     const char *);\n "
    },
    {
      "sha": "19915df7a83bd2f8a70390ecfdcf5b33a8e5bac5",
      "filename": "gdb/dwarf2/frame.c",
      "status": "modified",
      "additions": 2,
      "deletions": 34,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62e37eac1c5b9e4805d40715e7570f7146caa788/gdb/dwarf2/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62e37eac1c5b9e4805d40715e7570f7146caa788/gdb/dwarf2/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame.c?ref=62e37eac1c5b9e4805d40715e7570f7146caa788",
      "patch": "@@ -192,18 +192,6 @@ dwarf2_frame_state::dwarf2_frame_state (CORE_ADDR pc_, struct dwarf2_cie *cie)\n     retaddr_column (cie->return_address_register)\n {\n }\n-\f\n-\n-/* Helper functions for execute_stack_op.  */\n-\n-static CORE_ADDR\n-read_addr_from_reg (struct frame_info *this_frame, int reg)\n-{\n-  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  int regnum = dwarf_reg_to_regnum_or_error (gdbarch, reg);\n-\n-  return address_from_register (regnum, this_frame);\n-}\n \n /* Execute the required actions for both the DW_CFA_restore and\n DW_CFA_restore_extended instructions.  */\n@@ -244,31 +232,11 @@ class dwarf_expr_executor : public dwarf_expr_context\n     : dwarf_expr_context (per_objfile)\n   {}\n \n-  struct frame_info *this_frame;\n-\n-  CORE_ADDR read_addr_from_reg (int reg) override\n-  {\n-    return ::read_addr_from_reg (this_frame, reg);\n-  }\n-\n-  struct value *get_reg_value (struct type *type, int reg) override\n-  {\n-    struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-    int regnum = dwarf_reg_to_regnum_or_error (gdbarch, reg);\n-\n-    return value_from_register (type, regnum, this_frame);\n-  }\n-\n   void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t len) override\n   {\n     read_memory (addr, buf, len);\n   }\n \n-  void get_frame_base (const gdb_byte **start, size_t *length) override\n-  {\n-    invalid (\"DW_OP_fbreg\");\n-  }\n-\n   void push_dwarf_reg_entry_value (enum call_site_parameter_kind kind,\n \t\t\t\t   union call_site_parameter_u kind_u,\n \t\t\t\t   int deref_size) override\n@@ -324,7 +292,7 @@ execute_stack_op (const gdb_byte *exp, ULONGEST len, int addr_size,\n   dwarf_expr_executor ctx (per_objfile);\n   scoped_value_mark free_values;\n \n-  ctx.this_frame = this_frame;\n+  ctx.frame = this_frame;\n   ctx.gdbarch = get_frame_arch (this_frame);\n   ctx.addr_size = addr_size;\n   ctx.ref_addr_size = -1;\n@@ -335,7 +303,7 @@ execute_stack_op (const gdb_byte *exp, ULONGEST len, int addr_size,\n   if (ctx.location == DWARF_VALUE_MEMORY)\n     result = ctx.fetch_address (0);\n   else if (ctx.location == DWARF_VALUE_REGISTER)\n-    result = ctx.read_addr_from_reg (value_as_long (ctx.fetch (0)));\n+    result = read_addr_from_reg (this_frame, value_as_long (ctx.fetch (0)));\n   else\n     {\n       /* This is actually invalid DWARF, but if we ever do run across"
    },
    {
      "sha": "d004ea5cd65b66dd98936f6f0d8e074a4911ddd1",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 54,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62e37eac1c5b9e4805d40715e7570f7146caa788/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62e37eac1c5b9e4805d40715e7570f7146caa788/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=62e37eac1c5b9e4805d40715e7570f7146caa788",
      "patch": "@@ -696,7 +696,6 @@ class dwarf_evaluate_loc_desc : public dwarf_expr_context\n     : dwarf_expr_context (per_objfile)\n   {}\n \n-  struct frame_info *frame;\n   struct dwarf2_per_cu_data *per_cu;\n   CORE_ADDR obj_address;\n \n@@ -822,64 +821,12 @@ class dwarf_evaluate_loc_desc : public dwarf_expr_context\n     this->eval (data_src, size);\n   }\n \n-  /* Using the frame specified in BATON, find the location expression\n-     describing the frame base.  Return a pointer to it in START and\n-     its length in LENGTH.  */\n-  void get_frame_base (const gdb_byte **start, size_t * length) override\n-  {\n-    if (frame == nullptr)\n-      error (_(\"frame address is not available.\"));\n-\n-    /* FIXME: cagney/2003-03-26: This code should be using\n-       get_frame_base_address(), and then implement a dwarf2 specific\n-       this_base method.  */\n-    struct symbol *framefunc;\n-    const struct block *bl = get_frame_block (frame, NULL);\n-\n-    if (bl == NULL)\n-      error (_(\"frame address is not available.\"));\n-\n-    /* Use block_linkage_function, which returns a real (not inlined)\n-       function, instead of get_frame_function, which may return an\n-       inlined function.  */\n-    framefunc = block_linkage_function (bl);\n-\n-    /* If we found a frame-relative symbol then it was certainly within\n-       some function associated with a frame. If we can't find the frame,\n-       something has gone wrong.  */\n-    gdb_assert (framefunc != NULL);\n-\n-    func_get_frame_base_dwarf_block (framefunc,\n-\t\t\t\t     get_frame_address_in_block (frame),\n-\t\t\t\t     start, length);\n-  }\n-\n   /* Read memory at ADDR (length LEN) into BUF.  */\n \n   void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t len) override\n   {\n     read_memory (addr, buf, len);\n   }\n-\n-  /* Using the frame specified in BATON, return the value of register\n-     REGNUM, treated as a pointer.  */\n-  CORE_ADDR read_addr_from_reg (int dwarf_regnum) override\n-  {\n-    struct gdbarch *gdbarch = get_frame_arch (frame);\n-    int regnum = dwarf_reg_to_regnum_or_error (gdbarch, dwarf_regnum);\n-\n-    return address_from_register (regnum, frame);\n-  }\n-\n-  /* Implement \"get_reg_value\" callback.  */\n-\n-  struct value *get_reg_value (struct type *type, int dwarf_regnum) override\n-  {\n-    struct gdbarch *gdbarch = get_frame_arch (frame);\n-    int regnum = dwarf_reg_to_regnum_or_error (gdbarch, dwarf_regnum);\n-\n-    return value_from_register (type, regnum, frame);\n-  }\n };\n \n /* See dwarf2loc.h.  */\n@@ -2600,7 +2547,7 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n     case DWARF_VALUE_MEMORY:\n       *valp = ctx.fetch_address (0);\n       if (ctx.location == DWARF_VALUE_REGISTER)\n-\t*valp = ctx.read_addr_from_reg (*valp);\n+\t*valp = read_addr_from_reg (frame, *valp);\n       return 1;\n     case DWARF_VALUE_LITERAL:\n       *valp = extract_signed_integer (ctx.data, ctx.len,"
    }
  ]
}