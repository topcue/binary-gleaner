{
  "sha": "f1b8ceef1b055a0eb927852e9a9402d21aea96f5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjFiOGNlZWYxYjA1NWEwZWI5Mjc4NTJlOWE5NDAyZDIxYWVhOTZmNQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:39Z"
    },
    "message": "Convert m2-exp.y to use operations\n\nThis converts the Modula-2 parser to generate operations rather than\nexp_elements.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* m2-exp.y: Create operations.\n\t(m2_language::parser): Update.",
    "tree": {
      "sha": "7f70e34dea372479c17bbe73acb95a66c5eec840",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7f70e34dea372479c17bbe73acb95a66c5eec840"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f1b8ceef1b055a0eb927852e9a9402d21aea96f5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f1b8ceef1b055a0eb927852e9a9402d21aea96f5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f1b8ceef1b055a0eb927852e9a9402d21aea96f5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f1b8ceef1b055a0eb927852e9a9402d21aea96f5/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3163898ec86b30d022a7ebf5bdec286c23cebd45",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3163898ec86b30d022a7ebf5bdec286c23cebd45",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3163898ec86b30d022a7ebf5bdec286c23cebd45"
    }
  ],
  "stats": {
    "total": 239,
    "additions": 117,
    "deletions": 122
  },
  "files": [
    {
      "sha": "7834e755e70e7c6431bcefdcdd3f5e940b8e0ccf",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1b8ceef1b055a0eb927852e9a9402d21aea96f5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1b8ceef1b055a0eb927852e9a9402d21aea96f5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f1b8ceef1b055a0eb927852e9a9402d21aea96f5",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* m2-exp.y: Create operations.\n+\t(m2_language::parser): Update.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* p-exp.y: Create operations."
    },
    {
      "sha": "273270a85ce2694ce1477e43540841cc8f18598c",
      "filename": "gdb/m2-exp.y",
      "status": "modified",
      "additions": 112,
      "deletions": 122,
      "changes": 234,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1b8ceef1b055a0eb927852e9a9402d21aea96f5/gdb/m2-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1b8ceef1b055a0eb927852e9a9402d21aea96f5/gdb/m2-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-exp.y?ref=f1b8ceef1b055a0eb927852e9a9402d21aea96f5",
      "patch": "@@ -47,6 +47,7 @@\n #include \"symfile.h\" /* Required by objfiles.h.  */\n #include \"objfiles.h\" /* For have_full_symbols and have_partial_symbols */\n #include \"block.h\"\n+#include \"m2-exp.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n #define parse_m2_type(ps) builtin_m2_type (ps->gdbarch ())\n@@ -72,6 +73,7 @@ static int parse_number (int);\n /* The sign of the number being parsed.  */\n static int number_sign = 1;\n \n+using namespace expr;\n %}\n \n /* Although the yacc \"value\" of an expression is not used,\n@@ -153,123 +155,119 @@ start   :\texp\n \t;\n \n type_exp:\ttype\n-\t\t{ write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t  write_exp_elt_type (pstate, $1);\n-\t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t}\n+\t\t{ pstate->push_new<type_operation> ($1); }\n \t;\n \n /* Expressions */\n \n exp     :       exp '^'   %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_IND); }\n+\t\t\t{ pstate->wrap<unop_ind_operation> (); }\n \t;\n \n exp\t:\t'-'\n \t\t\t{ number_sign = -1; }\n \t\texp    %prec UNARY\n \t\t\t{ number_sign = 1;\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_NEG); }\n+\t\t\t  pstate->wrap<unary_neg_operation> (); }\n \t;\n \n exp\t:\t'+' exp    %prec UNARY\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_PLUS); }\n+\t\t{ pstate->wrap<unary_plus_operation> (); }\n \t;\n \n exp\t:\tnot_exp exp %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT); }\n+\t\t\t{ pstate->wrap<unary_logical_not_operation> (); }\n \t;\n \n not_exp\t:\tNOT\n \t|\t'~'\n \t;\n \n exp\t:\tCAP '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_CAP); }\n+\t\t\t{ error (_(\"CAP function is not implemented\")); }\n \t;\n \n exp\t:\tORD '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ORD); }\n+\t\t\t{ error (_(\"ORD function is not implemented\")); }\n \t;\n \n exp\t:\tABS '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ABS); }\n+\t\t\t{ error (_(\"ABS function is not implemented\")); }\n \t;\n \n exp\t: \tHIGH '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_HIGH); }\n+\t\t\t{ pstate->wrap<m2_unop_high_operation> (); }\n \t;\n \n exp \t:\tMIN_FUNC '(' type ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_MIN);\n-\t\t\t  write_exp_elt_type (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_MIN); }\n+\t\t\t{ error (_(\"MIN function is not implemented\")); }\n \t;\n \n exp\t: \tMAX_FUNC '(' type ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_MAX);\n-\t\t\t  write_exp_elt_type (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_MAX); }\n+\t\t\t{ error (_(\"MAX function is not implemented\")); }\n \t;\n \n exp\t:\tFLOAT_FUNC '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_FLOAT); }\n+\t\t\t{ error (_(\"FLOAT function is not implemented\")); }\n \t;\n \n exp\t:\tVAL '(' type ',' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_VAL);\n-\t\t\t  write_exp_elt_type (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_VAL); }\n+\t\t\t{ error (_(\"VAL function is not implemented\")); }\n \t;\n \n exp\t:\tCHR '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_CHR); }\n+\t\t\t{ error (_(\"CHR function is not implemented\")); }\n \t;\n \n exp\t:\tODD '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ODD); }\n+\t\t\t{ error (_(\"ODD function is not implemented\")); }\n \t;\n \n exp\t:\tTRUNC '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_TRUNC); }\n+\t\t\t{ error (_(\"TRUNC function is not implemented\")); }\n \t;\n \n exp\t:\tTSIZE '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_SIZEOF); }\n+\t\t\t{ pstate->wrap<unop_sizeof_operation> (); }\n \t;\n \n exp\t:\tSIZE exp       %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_SIZEOF); }\n+\t\t\t{ pstate->wrap<unop_sizeof_operation> (); }\n \t;\n \n \n exp\t:\tINC '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PREINCREMENT); }\n+\t\t\t{ pstate->wrap<preinc_operation> (); }\n \t;\n \n exp\t:\tINC '(' exp ',' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);\n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_ADD);\n-\t\t\t  write_exp_elt_opcode (pstate,\n-\t\t\t\t\t\tBINOP_ASSIGN_MODIFY); }\n+\t\t\t{\n+\t\t\t  operation_up rhs = pstate->pop ();\n+\t\t\t  operation_up lhs = pstate->pop ();\n+\t\t\t  pstate->push_new<assign_modify_operation>\n+\t\t\t    (BINOP_ADD, std::move (lhs), std::move (rhs));\n+\t\t\t}\n \t;\n \n exp\t:\tDEC '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PREDECREMENT);}\n+\t\t\t{ pstate->wrap<predec_operation> (); }\n \t;\n \n exp\t:\tDEC '(' exp ',' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);\n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_SUB);\n-\t\t\t  write_exp_elt_opcode (pstate,\n-\t\t\t\t\t\tBINOP_ASSIGN_MODIFY); }\n+\t\t\t{\n+\t\t\t  operation_up rhs = pstate->pop ();\n+\t\t\t  operation_up lhs = pstate->pop ();\n+\t\t\t  pstate->push_new<assign_modify_operation>\n+\t\t\t    (BINOP_SUB, std::move (lhs), std::move (rhs));\n+\t\t\t}\n \t;\n \n exp\t:\texp DOT NAME\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n-\t;\n+\t\t\t{\n+\t\t\t  pstate->push_new<structop_operation>\n+\t\t\t    (pstate->pop (), copy_name ($3));\n+\t\t\t}\n+;\n \n exp\t:\tset\n \t;\n@@ -302,10 +300,10 @@ exp     :       exp '['\n \t\tnon_empty_arglist ']'  %prec DOT\n \t\t\t{\n \t\t\t  gdb_assert (pstate->arglist_len > 0);\n-\t\t\t  write_exp_elt_opcode (pstate, MULTI_SUBSCRIPT);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t pstate->end_arglist());\n-\t\t\t  write_exp_elt_opcode (pstate, MULTI_SUBSCRIPT);\n+\t\t\t  std::vector<operation_up> args\n+\t\t\t    = pstate->pop_vector (pstate->end_arglist ());\n+\t\t\t  pstate->push_new<multi_subscript_operation>\n+\t\t\t    (pstate->pop (), std::move (args));\n \t\t\t}\n \t;\n \n@@ -314,10 +312,12 @@ exp\t:\texp '('\n \t\t\t   being accumulated by an outer function call.  */\n \t\t\t{ pstate->start_arglist (); }\n \t\targlist ')'\t%prec DOT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t pstate->end_arglist ());\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL); }\n+\t\t\t{\n+\t\t\t  std::vector<operation_up> args\n+\t\t\t    = pstate->pop_vector (pstate->end_arglist ());\n+\t\t\t  pstate->push_new<funcall_operation>\n+\t\t\t    (pstate->pop (), std::move (args));\n+\t\t\t}\n \t;\n \n arglist\t:\n@@ -343,15 +343,17 @@ non_empty_arglist\n \n /* GDB construct */\n exp\t:\t'{' type '}' exp  %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_MEMVAL);\n-\t\t\t  write_exp_elt_type (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_MEMVAL); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<unop_memval_operation>\n+\t\t\t    (pstate->pop (), $2);\n+\t\t\t}\n \t;\n \n exp     :       type '(' exp ')' %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_CAST);\n-\t\t\t  write_exp_elt_type (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<unop_cast_operation>\n+\t\t\t    (pstate->pop (), $1);\n+\t\t\t}\n \t;\n \n exp\t:\t'(' exp ')'\n@@ -363,140 +365,127 @@ exp\t:\t'(' exp ')'\n \n /* GDB construct */\n exp\t:\texp '@' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REPEAT); }\n+\t\t\t{ pstate->wrap2<repeat_operation> (); }\n \t;\n \n exp\t:\texp '*' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_MUL); }\n+\t\t\t{ pstate->wrap2<mul_operation> (); }\n \t;\n \n exp\t:\texp '/' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_DIV); }\n+\t\t\t{ pstate->wrap2<div_operation> (); }\n \t;\n \n exp     :       exp DIV exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_INTDIV); }\n+\t\t\t{ pstate->wrap2<intdiv_operation> (); }\n \t;\n \n exp\t:\texp MOD exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REM); }\n+\t\t\t{ pstate->wrap2<rem_operation> (); }\n \t;\n \n exp\t:\texp '+' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ADD); }\n+\t\t\t{ pstate->wrap2<add_operation> (); }\n \t;\n \n exp\t:\texp '-' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUB); }\n+\t\t\t{ pstate->wrap2<sub_operation> (); }\n \t;\n \n exp\t:\texp '=' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }\n+\t\t\t{ pstate->wrap2<equal_operation> (); }\n \t;\n \n exp\t:\texp NOTEQUAL exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }\n+\t\t\t{ pstate->wrap2<notequal_operation> (); }\n \t|       exp '#' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }\n+\t\t\t{ pstate->wrap2<notequal_operation> (); }\n \t;\n \n exp\t:\texp LEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LEQ); }\n+\t\t\t{ pstate->wrap2<leq_operation> (); }\n \t;\n \n exp\t:\texp GEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GEQ); }\n+\t\t\t{ pstate->wrap2<geq_operation> (); }\n \t;\n \n exp\t:\texp '<' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LESS); }\n+\t\t\t{ pstate->wrap2<less_operation> (); }\n \t;\n \n exp\t:\texp '>' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GTR); }\n+\t\t\t{ pstate->wrap2<gtr_operation> (); }\n \t;\n \n exp\t:\texp LOGICAL_AND exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n+\t\t\t{ pstate->wrap2<logical_and_operation> (); }\n \t;\n \n exp\t:\texp OROR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n+\t\t\t{ pstate->wrap2<logical_or_operation> (); }\n \t;\n \n exp\t:\texp ASSIGN exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN); }\n+\t\t\t{ pstate->wrap2<assign_operation> (); }\n \t;\n \n \n /* Constants */\n \n exp\t:\tM2_TRUE\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_BOOL); }\n+\t\t\t{ pstate->push_new<bool_operation> ($1); }\n \t;\n \n exp\t:\tM2_FALSE\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_BOOL); }\n+\t\t\t{ pstate->push_new<bool_operation> ($1); }\n \t;\n \n exp\t:\tINT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\tparse_m2_type (pstate)->builtin_int);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (parse_m2_type (pstate)->builtin_int, $1);\n+\t\t\t}\n \t;\n \n exp\t:\tUINT\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t      parse_m2_type (pstate)\n-\t\t\t\t\t      ->builtin_card);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (parse_m2_type (pstate)->builtin_card, $1);\n \t\t\t}\n \t;\n \n exp\t:\tCHAR\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t      parse_m2_type (pstate)\n-\t\t\t\t\t      ->builtin_char);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (parse_m2_type (pstate)->builtin_char, $1);\n+\t\t\t}\n \t;\n \n \n exp\t:\tFLOAT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t      parse_m2_type (pstate)\n-\t\t\t\t\t      ->builtin_real);\n-\t\t\t  write_exp_elt_floatcst (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT); }\n+\t\t\t{\n+\t\t\t  float_data data;\n+\t\t\t  std::copy (std::begin ($1), std::end ($1),\n+\t\t\t\t     std::begin (data));\n+\t\t\t  pstate->push_new<float_const_operation>\n+\t\t\t    (parse_m2_type (pstate)->builtin_real, data);\n+\t\t\t}\n \t;\n \n exp\t:\tvariable\n \t;\n \n exp\t:\tSIZE '(' type ')'\t%prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t    parse_type (pstate)->builtin_int);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (LONGEST) TYPE_LENGTH ($3));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (parse_m2_type (pstate)->builtin_int,\n+\t\t\t     TYPE_LENGTH ($3));\n+\t\t\t}\n \t;\n \n exp\t:\tSTRING\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_M2_STRING);\n-\t\t\t  write_exp_string (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_M2_STRING); }\n+\t\t\t{ error (_(\"strings are not implemented\")); }\n \t;\n \n /* This will be used for extensions later.  Like adding modules.  */\n@@ -527,15 +516,15 @@ fblock\t:\tblock COLONCOLON BLOCKNAME\n \n /* Useful for assigning to PROCEDURE variables */\n variable:\tfblock\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t  write_exp_elt_block (pstate, NULL);\n-\t\t\t  write_exp_elt_sym (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<var_value_operation>\n+\t\t\t    ($1, nullptr);\n+\t\t\t}\n \t;\n \n /* GDB internal ($foo) variable */\n variable:\tDOLLAR_VARIABLE\n-\t\t\t{ write_dollar_variable (pstate, $1); }\n+\t\t\t{ pstate->push_dollar ($1); }\n \t;\n \n /* GDB scope operator */\n@@ -550,10 +539,9 @@ variable:\tblock COLONCOLON NAME\n \t\t\t  if (symbol_read_needs_frame (sym.symbol))\n \t\t\t    pstate->block_tracker->update (sym);\n \n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t  write_exp_elt_block (pstate, sym.block);\n-\t\t\t  write_exp_elt_sym (pstate, sym.symbol);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE); }\n+\t\t\t  pstate->push_new<var_value_operation>\n+\t\t\t    (sym.symbol, sym.block);\n+\t\t\t}\n \t;\n \n /* Base case for variables.  */\n@@ -568,8 +556,7 @@ variable:\tNAME\n \t\t\t\t\t     VAR_DOMAIN,\n \t\t\t\t\t     &is_a_field_of_this);\n \n-\t\t\t  write_exp_symbol_reference (pstate, name.c_str (),\n-\t\t\t\t\t\t      sym);\n+\t\t\t  pstate->push_symbol (name.c_str (), sym);\n \t\t\t}\n \t;\n \n@@ -1015,7 +1002,10 @@ m2_language::parser (struct parser_state *par_state) const\n   pstate = par_state;\n   paren_depth = 0;\n \n-  return yyparse ();\n+  int result = yyparse ();\n+  if (!result)\n+    pstate->set_operation (pstate->pop ());\n+  return result;\n }\n \n static void"
    }
  ]
}