{
  "sha": "d3c54a1ce8b250acf83dda2653393f29b70d3390",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDNjNTRhMWNlOGIyNTBhY2Y4M2RkYTI2NTMzOTNmMjliNzBkMzM5MA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:40Z"
    },
    "message": "Remove now-unused Ada evaluator code\n\nNow that the Ada parser has switched to the new style, there is no\nneed for the old Ada evaluation code.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (resolve_subexp, replace_operator_with_call)\n\t(evaluate_subexp_type, assign_aggregate)\n\t(aggregate_assign_positional, aggregate_assign_from_choices)\n\t(aggregate_assign_others, ada_evaluate_subexp_for_cast)\n\t(ada_evaluate_subexp, ADA_OPERATORS, ada_operator_length)\n\t(ada_operator_check, ada_forward_operator_length)\n\t(ada_dump_subexp_body, ada_print_subexp, ada_exp_descriptor):\n\tRemove.\n\t(post_parser): Update.\n\t(class ada_language) <expresssion_ops>: Remove.",
    "tree": {
      "sha": "fc8b4b308578280080d617ddbe8c56c98bea3fbc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fc8b4b308578280080d617ddbe8c56c98bea3fbc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d3c54a1ce8b250acf83dda2653393f29b70d3390",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3c54a1ce8b250acf83dda2653393f29b70d3390",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d3c54a1ce8b250acf83dda2653393f29b70d3390",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3c54a1ce8b250acf83dda2653393f29b70d3390/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5871f0a38dd0f2403765e60d7b00f511fcc4a6cc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5871f0a38dd0f2403765e60d7b00f511fcc4a6cc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5871f0a38dd0f2403765e60d7b00f511fcc4a6cc"
    }
  ],
  "stats": {
    "total": 2117,
    "additions": 188,
    "deletions": 1929
  },
  "files": [
    {
      "sha": "0853471221e9550f52e1af1c3262f78041a1ad7c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3c54a1ce8b250acf83dda2653393f29b70d3390/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3c54a1ce8b250acf83dda2653393f29b70d3390/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d3c54a1ce8b250acf83dda2653393f29b70d3390",
      "patch": "@@ -1,3 +1,16 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (resolve_subexp, replace_operator_with_call)\n+\t(evaluate_subexp_type, assign_aggregate)\n+\t(aggregate_assign_positional, aggregate_assign_from_choices)\n+\t(aggregate_assign_others, ada_evaluate_subexp_for_cast)\n+\t(ada_evaluate_subexp, ADA_OPERATORS, ada_operator_length)\n+\t(ada_operator_check, ada_forward_operator_length)\n+\t(ada_dump_subexp_body, ada_print_subexp, ada_exp_descriptor):\n+\tRemove.\n+\t(post_parser): Update.\n+\t(class ada_language) <expresssion_ops>: Remove.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* m2-lang.h (class m2_language) <expresssion_ops,"
    },
    {
      "sha": "cfc2a6fbae0d59367ae94f815fbfb4268bb53a16",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 175,
      "deletions": 1929,
      "changes": 2104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3c54a1ce8b250acf83dda2653393f29b70d3390/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3c54a1ce8b250acf83dda2653393f29b70d3390/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=d3c54a1ce8b250acf83dda2653393f29b70d3390",
      "patch": "@@ -117,13 +117,6 @@ static void add_defn_to_vec (std::vector<struct block_symbol> &,\n \t\t\t     struct symbol *,\n \t\t\t     const struct block *);\n \n-static struct value *resolve_subexp (expression_up *, int *, int,\n-\t\t\t\t     struct type *, int,\n-\t\t\t\t     innermost_block_tracker *);\n-\n-static void replace_operator_with_call (expression_up *, int, int, int,\n-\t\t\t\t\tstruct symbol *, const struct block *);\n-\n static int possible_user_operator_p (enum exp_opcode, struct value **);\n \n static const char *ada_decoded_op_name (enum exp_opcode);\n@@ -139,8 +132,6 @@ static int discrete_type_p (struct type *);\n static struct type *ada_lookup_struct_elt_type (struct type *, const char *,\n \t\t\t\t\t\tint, int);\n \n-static struct value *evaluate_subexp_type (struct expression *, int *);\n-\n static struct type *ada_find_parallel_type_with_name (struct type *,\n \t\t\t\t\t\t      const char *);\n \n@@ -209,36 +200,9 @@ static int ada_is_direct_array_type (struct type *);\n static struct value *ada_index_struct_field (int, struct value *, int,\n \t\t\t\t\t     struct type *);\n \n-static struct value *assign_aggregate (struct value *, struct value *, \n-\t\t\t\t       struct expression *,\n-\t\t\t\t       int *, enum noside);\n-\n-static void aggregate_assign_from_choices (struct value *, struct value *,\n-\t\t\t\t\t   struct expression *,\n-\t\t\t\t\t   int *, std::vector<LONGEST> &,\n-\t\t\t\t\t   LONGEST, LONGEST);\n-\n-static void aggregate_assign_positional (struct value *, struct value *,\n-\t\t\t\t\t struct expression *,\n-\t\t\t\t\t int *, std::vector<LONGEST> &,\n-\t\t\t\t\t LONGEST, LONGEST);\n-\n-\n-static void aggregate_assign_others (struct value *, struct value *,\n-\t\t\t\t     struct expression *,\n-\t\t\t\t     int *, std::vector<LONGEST> &,\n-\t\t\t\t     LONGEST, LONGEST);\n-\n-\n static void add_component_interval (LONGEST, LONGEST, std::vector<LONGEST> &);\n \n \n-static struct value *ada_evaluate_subexp (struct type *, struct expression *,\n-\t\t\t\t\t  int *, enum noside);\n-\n-static void ada_forward_operator_length (struct expression *, int, int *,\n-\t\t\t\t\t int *);\n-\n static struct type *ada_find_any_type (const char *name);\n \n static symbol_name_matcher_ftype *ada_get_symbol_name_matcher\n@@ -3528,293 +3492,6 @@ ada_resolve_variable (struct symbol *sym, const struct block *block,\n   return candidates[i];\n }\n \n-/* Resolve the operator of the subexpression beginning at\n-   position *POS of *EXPP.  \"Resolving\" consists of replacing\n-   the symbols that have undefined namespaces in OP_VAR_VALUE nodes\n-   with their resolutions, replacing built-in operators with\n-   function calls to user-defined operators, where appropriate, and,\n-   when DEPROCEDURE_P is non-zero, converting function-valued variables\n-   into parameterless calls.  May expand *EXPP.  The CONTEXT_TYPE functions\n-   are as in ada_resolve, above.  */\n-\n-static struct value *\n-resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n-\t\tstruct type *context_type, int parse_completion,\n-\t\tinnermost_block_tracker *tracker)\n-{\n-  int pc = *pos;\n-  int i;\n-  struct expression *exp;       /* Convenience: == *expp.  */\n-  enum exp_opcode op = (*expp)->elts[pc].opcode;\n-  struct value **argvec;        /* Vector of operand types (alloca'ed).  */\n-  int nargs;                    /* Number of operands.  */\n-  int oplen;\n-  /* If we're resolving an expression like ARRAY(ARG...), then we set\n-     this to the type of the array, so we can use the index types as\n-     the expected types for resolution.  */\n-  struct type *array_type = nullptr;\n-  /* The arity of ARRAY_TYPE.  */\n-  int array_arity = 0;\n-\n-  argvec = NULL;\n-  nargs = 0;\n-  exp = expp->get ();\n-\n-  /* Pass one: resolve operands, saving their types and updating *pos,\n-     if needed.  */\n-  switch (op)\n-    {\n-    case OP_FUNCALL:\n-      if (exp->elts[pc + 3].opcode == OP_VAR_VALUE\n-\t  && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n-\t*pos += 7;\n-      else\n-\t{\n-\t  *pos += 3;\n-\t  struct value *lhs = resolve_subexp (expp, pos, 0, NULL,\n-\t\t\t\t\t      parse_completion, tracker);\n-\t  struct type *lhstype = ada_check_typedef (value_type (lhs));\n-\t  array_arity = ada_array_arity (lhstype);\n-\t  if (array_arity > 0)\n-\t    array_type = lhstype;\n-\t}\n-      nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-      break;\n-\n-    case UNOP_ADDR:\n-      *pos += 1;\n-      resolve_subexp (expp, pos, 0, NULL, parse_completion, tracker);\n-      break;\n-\n-    case UNOP_QUAL:\n-      *pos += 3;\n-      resolve_subexp (expp, pos, 1, check_typedef (exp->elts[pc + 1].type),\n-\t\t      parse_completion, tracker);\n-      break;\n-\n-    case OP_ATR_MODULUS:\n-    case OP_ATR_SIZE:\n-    case OP_ATR_TAG:\n-    case OP_ATR_FIRST:\n-    case OP_ATR_LAST:\n-    case OP_ATR_LENGTH:\n-    case OP_ATR_POS:\n-    case OP_ATR_VAL:\n-    case OP_ATR_MIN:\n-    case OP_ATR_MAX:\n-    case TERNOP_IN_RANGE:\n-    case BINOP_IN_BOUNDS:\n-    case UNOP_IN_RANGE:\n-    case OP_AGGREGATE:\n-    case OP_OTHERS:\n-    case OP_CHOICES:\n-    case OP_POSITIONAL:\n-    case OP_DISCRETE_RANGE:\n-    case OP_NAME:\n-      ada_forward_operator_length (exp, pc, &oplen, &nargs);\n-      *pos += oplen;\n-      break;\n-\n-    case BINOP_ASSIGN:\n-      {\n-\tstruct value *arg1;\n-\n-\t*pos += 1;\n-\targ1 = resolve_subexp (expp, pos, 0, NULL, parse_completion, tracker);\n-\tif (arg1 == NULL)\n-\t  resolve_subexp (expp, pos, 1, NULL, parse_completion, tracker);\n-\telse\n-\t  resolve_subexp (expp, pos, 1, value_type (arg1), parse_completion,\n-\t\t\t  tracker);\n-\tbreak;\n-      }\n-\n-    case UNOP_CAST:\n-      *pos += 3;\n-      nargs = 1;\n-      break;\n-\n-    case BINOP_ADD:\n-    case BINOP_SUB:\n-    case BINOP_MUL:\n-    case BINOP_DIV:\n-    case BINOP_REM:\n-    case BINOP_MOD:\n-    case BINOP_EXP:\n-    case BINOP_CONCAT:\n-    case BINOP_LOGICAL_AND:\n-    case BINOP_LOGICAL_OR:\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n-\n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-    case BINOP_LESS:\n-    case BINOP_GTR:\n-    case BINOP_LEQ:\n-    case BINOP_GEQ:\n-\n-    case BINOP_REPEAT:\n-    case BINOP_SUBSCRIPT:\n-    case BINOP_COMMA:\n-      *pos += 1;\n-      nargs = 2;\n-      break;\n-\n-    case UNOP_NEG:\n-    case UNOP_PLUS:\n-    case UNOP_LOGICAL_NOT:\n-    case UNOP_ABS:\n-    case UNOP_IND:\n-      *pos += 1;\n-      nargs = 1;\n-      break;\n-\n-    case OP_LONG:\n-    case OP_FLOAT:\n-    case OP_VAR_VALUE:\n-    case OP_VAR_MSYM_VALUE:\n-      *pos += 4;\n-      break;\n-\n-    case OP_TYPE:\n-    case OP_BOOL:\n-    case OP_LAST:\n-    case OP_INTERNALVAR:\n-      *pos += 3;\n-      break;\n-\n-    case UNOP_MEMVAL:\n-      *pos += 3;\n-      nargs = 1;\n-      break;\n-\n-    case OP_REGISTER:\n-      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);\n-      break;\n-\n-    case STRUCTOP_STRUCT:\n-      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);\n-      nargs = 1;\n-      break;\n-\n-    case TERNOP_SLICE:\n-      *pos += 1;\n-      nargs = 3;\n-      break;\n-\n-    case OP_STRING:\n-      break;\n-\n-    default:\n-      error (_(\"Unexpected operator during name resolution\"));\n-    }\n-\n-  argvec = XALLOCAVEC (struct value *, nargs + 1);\n-  for (i = 0; i < nargs; i += 1)\n-    {\n-      struct type *subtype = nullptr;\n-      if (i < array_arity)\n-\tsubtype = ada_index_type (array_type, i + 1, \"array type\");\n-      argvec[i] = resolve_subexp (expp, pos, 1, subtype, parse_completion,\n-\t\t\t\t  tracker);\n-    }\n-  argvec[i] = NULL;\n-  exp = expp->get ();\n-\n-  /* Pass two: perform any resolution on principal operator.  */\n-  switch (op)\n-    {\n-    default:\n-      break;\n-\n-    case OP_VAR_VALUE:\n-      if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)\n-\t{\n-\t  block_symbol resolved\n-\t    = ada_resolve_variable (exp->elts[pc + 2].symbol,\n-\t\t\t\t    exp->elts[pc + 1].block,\n-\t\t\t\t    context_type, parse_completion,\n-\t\t\t\t    deprocedure_p, tracker);\n-\t  exp->elts[pc + 1].block = resolved.block;\n-\t  exp->elts[pc + 2].symbol = resolved.symbol;\n-\t}\n-\n-      if (deprocedure_p\n-\t  && (SYMBOL_TYPE (exp->elts[pc + 2].symbol)->code ()\n-\t      == TYPE_CODE_FUNC))\n-\t{\n-\t  replace_operator_with_call (expp, pc, 0, 4,\n-\t\t\t\t      exp->elts[pc + 2].symbol,\n-\t\t\t\t      exp->elts[pc + 1].block);\n-\t  exp = expp->get ();\n-\t}\n-      break;\n-\n-    case OP_FUNCALL:\n-      {\n-\tif (exp->elts[pc + 3].opcode == OP_VAR_VALUE\n-\t    && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n-\t  {\n-\t    block_symbol resolved\n-\t      = ada_resolve_funcall (exp->elts[pc + 5].symbol,\n-\t\t\t\t     exp->elts[pc + 4].block,\n-\t\t\t\t     context_type, parse_completion,\n-\t\t\t\t     nargs, argvec,\n-\t\t\t\t     tracker);\n-\t    exp->elts[pc + 4].block = resolved.block;\n-\t    exp->elts[pc + 5].symbol = resolved.symbol;\n-\t  }\n-      }\n-      break;\n-    case BINOP_ADD:\n-    case BINOP_SUB:\n-    case BINOP_MUL:\n-    case BINOP_DIV:\n-    case BINOP_REM:\n-    case BINOP_MOD:\n-    case BINOP_CONCAT:\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-    case BINOP_LESS:\n-    case BINOP_GTR:\n-    case BINOP_LEQ:\n-    case BINOP_GEQ:\n-    case BINOP_EXP:\n-    case UNOP_NEG:\n-    case UNOP_PLUS:\n-    case UNOP_LOGICAL_NOT:\n-    case UNOP_ABS:\n-      {\n-\tblock_symbol found = ada_find_operator_symbol (op, parse_completion,\n-\t\t\t\t\t\t       nargs, argvec);\n-\tif (found.symbol == nullptr)\n-\t  break;\n-\n-\treplace_operator_with_call (expp, pc, nargs, 1,\n-\t\t\t\t    found.symbol, found.block);\n-\texp = expp->get ();\n-      }\n-      break;\n-\n-    case OP_TYPE:\n-    case OP_REGISTER:\n-      return NULL;\n-    }\n-\n-  *pos = pc;\n-  if (exp->elts[pc].opcode == OP_VAR_MSYM_VALUE)\n-    return evaluate_var_msym_value (EVAL_AVOID_SIDE_EFFECTS,\n-\t\t\t\t    exp->elts[pc + 1].objfile,\n-\t\t\t\t    exp->elts[pc + 2].msymbol);\n-  else\n-    return evaluate_subexp_type (exp, pos);\n-}\n-\n /* Return non-zero if formal type FTYPE matches actual type ATYPE.  If\n    MAY_DEREF is non-zero, the formal may be a pointer and the actual\n    a non-pointer.  */\n@@ -3997,38 +3674,6 @@ ada_resolve_function (std::vector<struct block_symbol> &syms,\n   return 0;\n }\n \n-/* Replace the operator of length OPLEN at position PC in *EXPP with a call\n-   on the function identified by SYM and BLOCK, and taking NARGS\n-   arguments.  Update *EXPP as needed to hold more space.  */\n-\n-static void\n-replace_operator_with_call (expression_up *expp, int pc, int nargs,\n-\t\t\t    int oplen, struct symbol *sym,\n-\t\t\t    const struct block *block)\n-{\n-  /* We want to add 6 more elements (3 for funcall, 4 for function\n-     symbol, -OPLEN for operator being replaced) to the\n-     expression.  */\n-  struct expression *exp = expp->get ();\n-  int save_nelts = exp->nelts;\n-  int extra_elts = 7 - oplen;\n-  exp->nelts += extra_elts;\n-\n-  if (extra_elts > 0)\n-    exp->resize (exp->nelts);\n-  memmove (exp->elts + pc + 7, exp->elts + pc + oplen,\n-\t   EXP_ELEM_TO_BYTES (save_nelts - pc - oplen));\n-  if (extra_elts < 0)\n-    exp->resize (exp->nelts);\n-\n-  exp->elts[pc].opcode = exp->elts[pc + 2].opcode = OP_FUNCALL;\n-  exp->elts[pc + 1].longconst = (LONGEST) nargs;\n-\n-  exp->elts[pc + 3].opcode = exp->elts[pc + 6].opcode = OP_VAR_VALUE;\n-  exp->elts[pc + 4].block = block;\n-  exp->elts[pc + 5].symbol = sym;\n-}\n-\n /* Type-class predicates */\n \n /* True iff TYPE is numeric (i.e., an INT, RANGE (of numeric type),\n@@ -9131,16 +8776,6 @@ ada_enum_name (const char *name)\n     }\n }\n \n-/* Evaluate the subexpression of EXP starting at *POS as for\n-   evaluate_type, updating *POS to point just past the evaluated\n-   expression.  */\n-\n-static struct value *\n-evaluate_subexp_type (struct expression *exp, int *pos)\n-{\n-  return evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-}\n-\n /* If VAL is wrapped in an aligner or subtype wrapper, return the\n    value it wraps.  */\n \n@@ -9392,17 +9027,27 @@ ada_value_equal (struct value *arg1, struct value *arg2)\n   return value_equal (arg1, arg2);\n }\n \n-/* Assign the result of evaluating EXP starting at *POS to the INDEXth \n-   component of LHS (a simple array or a record), updating *POS past\n-   the expression, assuming that LHS is contained in CONTAINER.  Does\n-   not modify the inferior's memory, nor does it modify LHS (unless\n-   LHS == CONTAINER).  */\n+namespace expr\n+{\n+\n+bool\n+check_objfile (const std::unique_ptr<ada_component> &comp,\n+\t       struct objfile *objfile)\n+{\n+  return comp->uses_objfile (objfile);\n+}\n+\n+/* Assign the result of evaluating ARG starting at *POS to the INDEXth\n+   component of LHS (a simple array or a record).  Does not modify the\n+   inferior's memory, nor does it modify LHS (unless LHS ==\n+   CONTAINER).  */\n \n static void\n assign_component (struct value *container, struct value *lhs, LONGEST index,\n-\t\t  struct expression *exp, int *pos)\n+\t\t  struct expression *exp, operation_up &arg)\n {\n-  struct value *mark = value_mark ();\n+  scoped_value_mark mark;\n+\n   struct value *elt;\n   struct type *lhs_type = check_typedef (value_type (lhs));\n \n@@ -9419,41 +9064,56 @@ assign_component (struct value *container, struct value *lhs, LONGEST index,\n       elt = ada_to_fixed_value (elt);\n     }\n \n-  if (exp->elts[*pos].opcode == OP_AGGREGATE)\n-    assign_aggregate (container, elt, exp, pos, EVAL_NORMAL);\n+  ada_aggregate_operation *ag_op\n+    = dynamic_cast<ada_aggregate_operation *> (arg.get ());\n+  if (ag_op != nullptr)\n+    ag_op->assign_aggregate (container, elt, exp);\n   else\n-    value_assign_to_component (container, elt, \n-\t\t\t       ada_evaluate_subexp (NULL, exp, pos, \n-\t\t\t\t\t\t    EVAL_NORMAL));\n+    value_assign_to_component (container, elt,\n+\t\t\t       arg->evaluate (nullptr, exp,\n+\t\t\t\t\t      EVAL_NORMAL));\n+}\n \n-  value_free_to_mark (mark);\n+bool\n+ada_aggregate_component::uses_objfile (struct objfile *objfile)\n+{\n+  for (const auto &item : m_components)\n+    if (item->uses_objfile (objfile))\n+      return true;\n+  return false;\n+}\n+\n+void\n+ada_aggregate_component::dump (ui_file *stream, int depth)\n+{\n+  fprintf_filtered (stream, _(\"%*sAggregate\\n\"), depth, \"\");\n+  for (const auto &item : m_components)\n+    item->dump (stream, depth + 1);\n+}\n+\n+void\n+ada_aggregate_component::assign (struct value *container,\n+\t\t\t\t struct value *lhs, struct expression *exp,\n+\t\t\t\t std::vector<LONGEST> &indices,\n+\t\t\t\t LONGEST low, LONGEST high)\n+{\n+  for (auto &item : m_components)\n+    item->assign (container, lhs, exp, indices, low, high);\n }\n \n /* Assuming that LHS represents an lvalue having a record or array\n-   type, and EXP->ELTS[*POS] is an OP_AGGREGATE, evaluate an assignment\n-   of that aggregate's value to LHS, advancing *POS past the\n-   aggregate.  NOSIDE is as for evaluate_subexp.  CONTAINER is an\n-   lvalue containing LHS (possibly LHS itself).  Does not modify\n-   the inferior's memory, nor does it modify the contents of \n-   LHS (unless == CONTAINER).  Returns the modified CONTAINER.  */\n+   type, evaluate an assignment of this aggregate's value to LHS.\n+   CONTAINER is an lvalue containing LHS (possibly LHS itself).  Does\n+   not modify the inferior's memory, nor does it modify the contents\n+   of LHS (unless == CONTAINER).  */\n \n-static struct value *\n-assign_aggregate (struct value *container, \n-\t\t  struct value *lhs, struct expression *exp, \n-\t\t  int *pos, enum noside noside)\n+void\n+ada_aggregate_operation::assign_aggregate (struct value *container,\n+\t\t\t\t\t   struct value *lhs,\n+\t\t\t\t\t   struct expression *exp)\n {\n   struct type *lhs_type;\n-  int n = exp->elts[*pos+1].longconst;\n   LONGEST low_index, high_index;\n-  int i;\n-\n-  *pos += 3;\n-  if (noside != EVAL_NORMAL)\n-    {\n-      for (i = 0; i < n; i += 1)\n-\tada_evaluate_subexp (NULL, exp, pos, noside);\n-      return container;\n-    }\n \n   container = ada_coerce_ref (container);\n   if (ada_is_direct_array_type (value_type (container)))\n@@ -9482,317 +9142,47 @@ assign_aggregate (struct value *container,\n   indices[0] = indices[1] = low_index - 1;\n   indices[2] = indices[3] = high_index + 1;\n \n-  for (i = 0; i < n; i += 1)\n-    {\n-      switch (exp->elts[*pos].opcode)\n-\t{\n-\t  case OP_CHOICES:\n-\t    aggregate_assign_from_choices (container, lhs, exp, pos, indices,\n-\t\t\t\t\t   low_index, high_index);\n-\t    break;\n-\t  case OP_POSITIONAL:\n-\t    aggregate_assign_positional (container, lhs, exp, pos, indices,\n-\t\t\t\t\t low_index, high_index);\n-\t    break;\n-\t  case OP_OTHERS:\n-\t    if (i != n-1)\n-\t      error (_(\"Misplaced 'others' clause\"));\n-\t    aggregate_assign_others (container, lhs, exp, pos, indices,\n-\t\t\t\t     low_index, high_index);\n-\t    break;\n-\t  default:\n-\t    error (_(\"Internal error: bad aggregate clause\"));\n-\t}\n-    }\n+  std::get<0> (m_storage)->assign (container, lhs, exp, indices,\n+\t\t\t\t   low_index, high_index);\n+}\n+\n+bool\n+ada_positional_component::uses_objfile (struct objfile *objfile)\n+{\n+  return m_op->uses_objfile (objfile);\n+}\n \n-  return container;\n+void\n+ada_positional_component::dump (ui_file *stream, int depth)\n+{\n+  fprintf_filtered (stream, _(\"%*sPositional, index = %d\\n\"),\n+\t\t    depth, \"\", m_index);\n+  m_op->dump (stream, depth + 1);\n }\n-\t      \n+\n /* Assign into the component of LHS indexed by the OP_POSITIONAL\n-   construct at *POS, updating *POS past the construct, given that\n-   the positions are relative to lower bound LOW, where HIGH is the\n-   upper bound.  Record the position in INDICES.  CONTAINER is as for\n-   assign_aggregate.  */\n-static void\n-aggregate_assign_positional (struct value *container,\n-\t\t\t     struct value *lhs, struct expression *exp,\n-\t\t\t     int *pos, std::vector<LONGEST> &indices,\n-\t\t\t     LONGEST low, LONGEST high)\n+   construct, given that the positions are relative to lower bound\n+   LOW, where HIGH is the upper bound.  Record the position in\n+   INDICES.  CONTAINER is as for assign_aggregate.  */\n+void\n+ada_positional_component::assign (struct value *container,\n+\t\t\t\t  struct value *lhs, struct expression *exp,\n+\t\t\t\t  std::vector<LONGEST> &indices,\n+\t\t\t\t  LONGEST low, LONGEST high)\n {\n-  LONGEST ind = longest_to_int (exp->elts[*pos + 1].longconst) + low;\n-  \n+  LONGEST ind = m_index + low;\n+\n   if (ind - 1 == high)\n     warning (_(\"Extra components in aggregate ignored.\"));\n   if (ind <= high)\n     {\n       add_component_interval (ind, ind, indices);\n-      *pos += 3;\n-      assign_component (container, lhs, ind, exp, pos);\n+      assign_component (container, lhs, ind, exp, m_op);\n     }\n-  else\n-    ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);\n }\n \n-/* Assign into the components of LHS indexed by the OP_CHOICES\n-   construct at *POS, updating *POS past the construct, given that\n-   the allowable indices are LOW..HIGH.  Record the indices assigned\n-   to in INDICES.  CONTAINER is as for assign_aggregate.  */\n-static void\n-aggregate_assign_from_choices (struct value *container,\n-\t\t\t       struct value *lhs, struct expression *exp,\n-\t\t\t       int *pos, std::vector<LONGEST> &indices,\n-\t\t\t       LONGEST low, LONGEST high)\n-{\n-  int j;\n-  int n_choices = longest_to_int (exp->elts[*pos+1].longconst);\n-  int choice_pos, expr_pc;\n-  int is_array = ada_is_direct_array_type (value_type (lhs));\n-\n-  choice_pos = *pos += 3;\n-\n-  for (j = 0; j < n_choices; j += 1)\n-    ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);\n-  expr_pc = *pos;\n-  ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);\n-  \n-  for (j = 0; j < n_choices; j += 1)\n-    {\n-      LONGEST lower, upper;\n-      enum exp_opcode op = exp->elts[choice_pos].opcode;\n-\n-      if (op == OP_DISCRETE_RANGE)\n-\t{\n-\t  choice_pos += 1;\n-\t  lower = value_as_long (ada_evaluate_subexp (NULL, exp, pos,\n-\t\t\t\t\t\t      EVAL_NORMAL));\n-\t  upper = value_as_long (ada_evaluate_subexp (NULL, exp, pos, \n-\t\t\t\t\t\t      EVAL_NORMAL));\n-\t}\n-      else if (is_array)\n-\t{\n-\t  lower = value_as_long (ada_evaluate_subexp (NULL, exp, &choice_pos, \n-\t\t\t\t\t\t      EVAL_NORMAL));\n-\t  upper = lower;\n-\t}\n-      else\n-\t{\n-\t  int ind;\n-\t  const char *name;\n-\n-\t  switch (op)\n-\t    {\n-\t    case OP_NAME:\n-\t      name = &exp->elts[choice_pos + 2].string;\n-\t      break;\n-\t    case OP_VAR_VALUE:\n-\t      name = exp->elts[choice_pos + 2].symbol->natural_name ();\n-\t      break;\n-\t    default:\n-\t      error (_(\"Invalid record component association.\"));\n-\t    }\n-\t  ada_evaluate_subexp (NULL, exp, &choice_pos, EVAL_SKIP);\n-\t  ind = 0;\n-\t  if (! find_struct_field (name, value_type (lhs), 0, \n-\t\t\t\t   NULL, NULL, NULL, NULL, &ind))\n-\t    error (_(\"Unknown component name: %s.\"), name);\n-\t  lower = upper = ind;\n-\t}\n-\n-      if (lower <= upper && (lower < low || upper > high))\n-\terror (_(\"Index in component association out of bounds.\"));\n-\n-      add_component_interval (lower, upper, indices);\n-      while (lower <= upper)\n-\t{\n-\t  int pos1;\n-\n-\t  pos1 = expr_pc;\n-\t  assign_component (container, lhs, lower, exp, &pos1);\n-\t  lower += 1;\n-\t}\n-    }\n-}\n-\n-/* Assign the value of the expression in the OP_OTHERS construct in\n-   EXP at *POS into the components of LHS indexed from LOW .. HIGH that\n-   have not been previously assigned.  The index intervals already assigned\n-   are in INDICES.  Updates *POS to after the OP_OTHERS clause.\n-   CONTAINER is as for assign_aggregate.  */\n-static void\n-aggregate_assign_others (struct value *container,\n-\t\t\t struct value *lhs, struct expression *exp,\n-\t\t\t int *pos, std::vector<LONGEST> &indices,\n-\t\t\t LONGEST low, LONGEST high) \n-{\n-  int i;\n-  int expr_pc = *pos + 1;\n-  \n-  int num_indices = indices.size ();\n-  for (i = 0; i < num_indices - 2; i += 2)\n-    {\n-      LONGEST ind;\n-\n-      for (ind = indices[i + 1] + 1; ind < indices[i + 2]; ind += 1)\n-\t{\n-\t  int localpos;\n-\n-\t  localpos = expr_pc;\n-\t  assign_component (container, lhs, ind, exp, &localpos);\n-\t}\n-    }\n-  ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);\n-}\n-\n-namespace expr\n-{\n-\n-bool\n-check_objfile (const std::unique_ptr<ada_component> &comp,\n-\t       struct objfile *objfile)\n-{\n-  return comp->uses_objfile (objfile);\n-}\n-\n-/* Assign the result of evaluating ARG starting at *POS to the INDEXth\n-   component of LHS (a simple array or a record).  Does not modify the\n-   inferior's memory, nor does it modify LHS (unless LHS ==\n-   CONTAINER).  */\n-\n-static void\n-assign_component (struct value *container, struct value *lhs, LONGEST index,\n-\t\t  struct expression *exp, operation_up &arg)\n-{\n-  scoped_value_mark mark;\n-\n-  struct value *elt;\n-  struct type *lhs_type = check_typedef (value_type (lhs));\n-\n-  if (lhs_type->code () == TYPE_CODE_ARRAY)\n-    {\n-      struct type *index_type = builtin_type (exp->gdbarch)->builtin_int;\n-      struct value *index_val = value_from_longest (index_type, index);\n-\n-      elt = unwrap_value (ada_value_subscript (lhs, 1, &index_val));\n-    }\n-  else\n-    {\n-      elt = ada_index_struct_field (index, lhs, 0, value_type (lhs));\n-      elt = ada_to_fixed_value (elt);\n-    }\n-\n-  ada_aggregate_operation *ag_op\n-    = dynamic_cast<ada_aggregate_operation *> (arg.get ());\n-  if (ag_op != nullptr)\n-    ag_op->assign_aggregate (container, elt, exp);\n-  else\n-    value_assign_to_component (container, elt,\n-\t\t\t       arg->evaluate (nullptr, exp,\n-\t\t\t\t\t      EVAL_NORMAL));\n-}\n-\n-bool\n-ada_aggregate_component::uses_objfile (struct objfile *objfile)\n-{\n-  for (const auto &item : m_components)\n-    if (item->uses_objfile (objfile))\n-      return true;\n-  return false;\n-}\n-\n-void\n-ada_aggregate_component::dump (ui_file *stream, int depth)\n-{\n-  fprintf_filtered (stream, _(\"%*sAggregate\\n\"), depth, \"\");\n-  for (const auto &item : m_components)\n-    item->dump (stream, depth + 1);\n-}\n-\n-void\n-ada_aggregate_component::assign (struct value *container,\n-\t\t\t\t struct value *lhs, struct expression *exp,\n-\t\t\t\t std::vector<LONGEST> &indices,\n-\t\t\t\t LONGEST low, LONGEST high)\n-{\n-  for (auto &item : m_components)\n-    item->assign (container, lhs, exp, indices, low, high);\n-}\n-\n-void\n-ada_aggregate_operation::assign_aggregate (struct value *container,\n-\t\t\t\t\t   struct value *lhs,\n-\t\t\t\t\t   struct expression *exp)\n-{\n-  struct type *lhs_type;\n-  LONGEST low_index, high_index;\n-\n-  container = ada_coerce_ref (container);\n-  if (ada_is_direct_array_type (value_type (container)))\n-    container = ada_coerce_to_simple_array (container);\n-  lhs = ada_coerce_ref (lhs);\n-  if (!deprecated_value_modifiable (lhs))\n-    error (_(\"Left operand of assignment is not a modifiable lvalue.\"));\n-\n-  lhs_type = check_typedef (value_type (lhs));\n-  if (ada_is_direct_array_type (lhs_type))\n-    {\n-      lhs = ada_coerce_to_simple_array (lhs);\n-      lhs_type = check_typedef (value_type (lhs));\n-      low_index = lhs_type->bounds ()->low.const_val ();\n-      high_index = lhs_type->bounds ()->high.const_val ();\n-    }\n-  else if (lhs_type->code () == TYPE_CODE_STRUCT)\n-    {\n-      low_index = 0;\n-      high_index = num_visible_fields (lhs_type) - 1;\n-    }\n-  else\n-    error (_(\"Left-hand side must be array or record.\"));\n-\n-  std::vector<LONGEST> indices (4);\n-  indices[0] = indices[1] = low_index - 1;\n-  indices[2] = indices[3] = high_index + 1;\n-\n-  std::get<0> (m_storage)->assign (container, lhs, exp, indices,\n-\t\t\t\t   low_index, high_index);\n-}\n-\n-bool\n-ada_positional_component::uses_objfile (struct objfile *objfile)\n-{\n-  return m_op->uses_objfile (objfile);\n-}\n-\n-void\n-ada_positional_component::dump (ui_file *stream, int depth)\n-{\n-  fprintf_filtered (stream, _(\"%*sPositional, index = %d\\n\"),\n-\t\t    depth, \"\", m_index);\n-  m_op->dump (stream, depth + 1);\n-}\n-\n-/* Assign into the component of LHS indexed by the OP_POSITIONAL\n-   construct, given that the positions are relative to lower bound\n-   LOW, where HIGH is the upper bound.  Record the position in\n-   INDICES.  CONTAINER is as for assign_aggregate.  */\n-void\n-ada_positional_component::assign (struct value *container,\n-\t\t\t\t  struct value *lhs, struct expression *exp,\n-\t\t\t\t  std::vector<LONGEST> &indices,\n-\t\t\t\t  LONGEST low, LONGEST high)\n-{\n-  LONGEST ind = m_index + low;\n-\n-  if (ind - 1 == high)\n-    warning (_(\"Extra components in aggregate ignored.\"));\n-  if (ind <= high)\n-    {\n-      add_component_interval (ind, ind, indices);\n-      assign_component (container, lhs, ind, exp, m_op);\n-    }\n-}\n-\n-bool\n-ada_discrete_range_association::uses_objfile (struct objfile *objfile)\n+bool\n+ada_discrete_range_association::uses_objfile (struct objfile *objfile)\n {\n   return m_low->uses_objfile (objfile) || m_high->uses_objfile (objfile);\n }\n@@ -10287,58 +9677,6 @@ ada_value_cast (struct type *type, struct value *arg2)\n     entity.  Results in this case are unpredictable, as we usually read\n     past the buffer containing the data =:-o.  */\n \n-/* Evaluate a subexpression of EXP, at index *POS, and return a value\n-   for that subexpression cast to TO_TYPE.  Advance *POS over the\n-   subexpression.  */\n-\n-static value *\n-ada_evaluate_subexp_for_cast (expression *exp, int *pos,\n-\t\t\t      enum noside noside, struct type *to_type)\n-{\n-  int pc = *pos;\n-\n-  if (exp->elts[pc].opcode == OP_VAR_MSYM_VALUE\n-      || exp->elts[pc].opcode == OP_VAR_VALUE)\n-    {\n-      (*pos) += 4;\n-\n-      value *val;\n-      if (exp->elts[pc].opcode == OP_VAR_MSYM_VALUE)\n-\t{\n-\t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t    return value_zero (to_type, not_lval);\n-\n-\t  val = evaluate_var_msym_value (noside,\n-\t\t\t\t\t exp->elts[pc + 1].objfile,\n-\t\t\t\t\t exp->elts[pc + 2].msymbol);\n-\t}\n-      else\n-\tval = evaluate_var_value (noside,\n-\t\t\t\t  exp->elts[pc + 1].block,\n-\t\t\t\t  exp->elts[pc + 2].symbol);\n-\n-      if (noside == EVAL_SKIP)\n-\treturn eval_skip_value (exp);\n-\n-      val = ada_value_cast (to_type, val);\n-\n-      /* Follow the Ada language semantics that do not allow taking\n-\t an address of the result of a cast (view conversion in Ada).  */\n-      if (VALUE_LVAL (val) == lval_memory)\n-\t{\n-\t  if (value_lazy (val))\n-\t    value_fetch_lazy (val);\n-\t  VALUE_LVAL (val) = not_lval;\n-\t}\n-      return val;\n-    }\n-\n-  value *val = evaluate_subexp (to_type, exp, pos, noside);\n-  if (noside == EVAL_SKIP)\n-    return eval_skip_value (exp);\n-  return ada_value_cast (to_type, val);\n-}\n-\n /* A helper function for TERNOP_IN_RANGE.  */\n \n static value *\n@@ -11297,852 +10635,111 @@ ada_funcall_operation::evaluate (struct type *expect_type,\n \t\t\t\t       callee, nargs,\n \t\t\t\t       argvec.data ());\n \n-    case TYPE_CODE_STRUCT:\n-      {\n-\tint arity;\n-\n-\tarity = ada_array_arity (type);\n-\ttype = ada_array_element_type (type, nargs);\n-\tif (type == NULL)\n-\t  error (_(\"cannot subscript or call a record\"));\n-\tif (arity != nargs)\n-\t  error (_(\"wrong number of subscripts; expecting %d\"), arity);\n-\tif (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t  return value_zero (ada_aligned_type (type), lval_memory);\n-\treturn\n-\t  unwrap_value (ada_value_subscript\n-\t\t\t(callee, nargs, argvec.data ()));\n-      }\n-    case TYPE_CODE_ARRAY:\n-      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t{\n-\t  type = ada_array_element_type (type, nargs);\n-\t  if (type == NULL)\n-\t    error (_(\"element type of array unknown\"));\n-\t  else\n-\t    return value_zero (ada_aligned_type (type), lval_memory);\n-\t}\n-      return\n-\tunwrap_value (ada_value_subscript\n-\t\t      (ada_coerce_to_simple_array (callee),\n-\t\t       nargs, argvec.data ()));\n-    case TYPE_CODE_PTR:     /* Pointer to array */\n-      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t{\n-\t  type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);\n-\t  type = ada_array_element_type (type, nargs);\n-\t  if (type == NULL)\n-\t    error (_(\"element type of array unknown\"));\n-\t  else\n-\t    return value_zero (ada_aligned_type (type), lval_memory);\n-\t}\n-      return\n-\tunwrap_value (ada_value_ptr_subscript (callee, nargs,\n-\t\t\t\t\t       argvec.data ()));\n-\n-    default:\n-      error (_(\"Attempt to index or call something other than an \"\n-\t       \"array or function\"));\n-    }\n-}\n-\n-bool\n-ada_funcall_operation::resolve (struct expression *exp,\n-\t\t\t\tbool deprocedure_p,\n-\t\t\t\tbool parse_completion,\n-\t\t\t\tinnermost_block_tracker *tracker,\n-\t\t\t\tstruct type *context_type)\n-{\n-  operation_up &callee_op = std::get<0> (m_storage);\n-\n-  ada_var_value_operation *avv\n-    = dynamic_cast<ada_var_value_operation *> (callee_op.get ());\n-  if (avv == nullptr)\n-    return false;\n-\n-  symbol *sym = avv->get_symbol ();\n-  if (SYMBOL_DOMAIN (sym) != UNDEF_DOMAIN)\n-    return false;\n-\n-  const std::vector<operation_up> &args_up = std::get<1> (m_storage);\n-  int nargs = args_up.size ();\n-  std::vector<value *> argvec (nargs);\n-\n-  for (int i = 0; i < args_up.size (); ++i)\n-    argvec[i] = args_up[i]->evaluate (nullptr, exp, EVAL_AVOID_SIDE_EFFECTS);\n-\n-  const block *block = avv->get_block ();\n-  block_symbol resolved\n-    = ada_resolve_funcall (sym, block,\n-\t\t\t   context_type, parse_completion,\n-\t\t\t   nargs, argvec.data (),\n-\t\t\t   tracker);\n-\n-  std::get<0> (m_storage)\n-    = make_operation<ada_var_value_operation> (resolved.symbol,\n-\t\t\t\t\t       resolved.block);\n-  return false;\n-}\n-\n-bool\n-ada_ternop_slice_operation::resolve (struct expression *exp,\n-\t\t\t\t     bool deprocedure_p,\n-\t\t\t\t     bool parse_completion,\n-\t\t\t\t     innermost_block_tracker *tracker,\n-\t\t\t\t     struct type *context_type)\n-{\n-  /* Historically this check was done during resolution, so we\n-     continue that here.  */\n-  value *v = std::get<0> (m_storage)->evaluate (context_type, exp,\n-\t\t\t\t\t\tEVAL_AVOID_SIDE_EFFECTS);\n-  if (ada_is_any_packed_array_type (value_type (v)))\n-    error (_(\"cannot slice a packed array\"));\n-  return false;\n-}\n-\n-}\n-\n-/* Implement the evaluate_exp routine in the exp_descriptor structure\n-   for the Ada language.  */\n-\n-static struct value *\n-ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n-\t\t     int *pos, enum noside noside)\n-{\n-  enum exp_opcode op;\n-  int tem;\n-  int pc;\n-  int preeval_pos;\n-  struct value *arg1 = NULL, *arg2 = NULL, *arg3;\n-  struct type *type;\n-  int nargs, oplen;\n-  struct value **argvec;\n-\n-  pc = *pos;\n-  *pos += 1;\n-  op = exp->elts[pc].opcode;\n-\n-  switch (op)\n-    {\n-    default:\n-      *pos -= 1;\n-      arg1 = evaluate_subexp_standard (expect_type, exp, pos, noside);\n-\n-      if (noside == EVAL_NORMAL)\n-\targ1 = unwrap_value (arg1);\n-\n-      /* If evaluating an OP_FLOAT and an EXPECT_TYPE was provided,\n-\t then we need to perform the conversion manually, because\n-\t evaluate_subexp_standard doesn't do it.  This conversion is\n-\t necessary in Ada because the different kinds of float/fixed\n-\t types in Ada have different representations.\n-\n-\t Similarly, we need to perform the conversion from OP_LONG\n-\t ourselves.  */\n-      if ((op == OP_FLOAT || op == OP_LONG) && expect_type != NULL)\n-\targ1 = ada_value_cast (expect_type, arg1);\n-\n-      return arg1;\n-\n-    case OP_STRING:\n-      {\n-\tstruct value *result;\n-\n-\t*pos -= 1;\n-\tresult = evaluate_subexp_standard (expect_type, exp, pos, noside);\n-\t/* The result type will have code OP_STRING, bashed there from \n-\t   OP_ARRAY.  Bash it back.  */\n-\tif (value_type (result)->code () == TYPE_CODE_STRING)\n-\t  value_type (result)->set_code (TYPE_CODE_ARRAY);\n-\treturn result;\n-      }\n-\n-    case UNOP_CAST:\n-      (*pos) += 2;\n-      type = exp->elts[pc + 1].type;\n-      return ada_evaluate_subexp_for_cast (exp, pos, noside, type);\n-\n-    case UNOP_QUAL:\n-      (*pos) += 2;\n-      type = exp->elts[pc + 1].type;\n-      return ada_evaluate_subexp (type, exp, pos, noside);\n-\n-    case BINOP_ASSIGN:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (exp->elts[*pos].opcode == OP_AGGREGATE)\n-\t{\n-\t  arg1 = assign_aggregate (arg1, arg1, exp, pos, noside);\n-\t  if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t    return arg1;\n-\t  return ada_value_assign (arg1, arg1);\n-\t}\n-      /* Force the evaluation of the rhs ARG2 to the type of the lhs ARG1,\n-\t except if the lhs of our assignment is a convenience variable.\n-\t In the case of assigning to a convenience variable, the lhs\n-\t should be exactly the result of the evaluation of the rhs.  */\n-      type = value_type (arg1);\n-      if (VALUE_LVAL (arg1) == lval_internalvar)\n-\t type = NULL;\n-      arg2 = evaluate_subexp (type, exp, pos, noside);\n-      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)\n-\treturn arg1;\n-      if (VALUE_LVAL (arg1) == lval_internalvar)\n-\t{\n-\t  /* Nothing.  */\n-\t}\n-      else\n-\targ2 = coerce_for_assign (value_type (arg1), arg2);\n-      return ada_value_assign (arg1, arg2);\n-\n-    case BINOP_ADD:\n-      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      if (value_type (arg1)->code () == TYPE_CODE_PTR)\n-\treturn (value_from_longest\n-\t\t (value_type (arg1),\n-\t\t  value_as_long (arg1) + value_as_long (arg2)));\n-      if (value_type (arg2)->code () == TYPE_CODE_PTR)\n-\treturn (value_from_longest\n-\t\t (value_type (arg2),\n-\t\t  value_as_long (arg1) + value_as_long (arg2)));\n-      /* Preserve the original type for use by the range case below.\n-\t We cannot cast the result to a reference type, so if ARG1 is\n-\t a reference type, find its underlying type.  */\n-      type = value_type (arg1);\n-      while (type->code () == TYPE_CODE_REF)\n-\ttype = TYPE_TARGET_TYPE (type);\n-      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n-      arg1 = value_binop (arg1, arg2, BINOP_ADD);\n-      /* We need to special-case the result of adding to a range.\n-\t This is done for the benefit of \"ptype\".  gdb's Ada support\n-\t historically used the LHS to set the result type here, so\n-\t preserve this behavior.  */\n-      if (type->code () == TYPE_CODE_RANGE)\n-\targ1 = value_cast (type, arg1);\n-      return arg1;\n-\n-    case BINOP_SUB:\n-      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      if (value_type (arg1)->code () == TYPE_CODE_PTR)\n-\treturn (value_from_longest\n-\t\t (value_type (arg1),\n-\t\t  value_as_long (arg1) - value_as_long (arg2)));\n-      if (value_type (arg2)->code () == TYPE_CODE_PTR)\n-\treturn (value_from_longest\n-\t\t (value_type (arg2),\n-\t\t  value_as_long (arg1) - value_as_long (arg2)));\n-      /* Preserve the original type for use by the range case below.\n-\t We cannot cast the result to a reference type, so if ARG1 is\n-\t a reference type, find its underlying type.  */\n-      type = value_type (arg1);\n-      while (type->code () == TYPE_CODE_REF)\n-\ttype = TYPE_TARGET_TYPE (type);\n-      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n-      arg1 = value_binop (arg1, arg2, BINOP_SUB);\n-      /* We need to special-case the result of adding to a range.\n-\t This is done for the benefit of \"ptype\".  gdb's Ada support\n-\t historically used the LHS to set the result type here, so\n-\t preserve this behavior.  */\n-      if (type->code () == TYPE_CODE_RANGE)\n-\targ1 = value_cast (type, arg1);\n-      return arg1;\n-\n-    case BINOP_MUL:\n-    case BINOP_DIV:\n-    case BINOP_REM:\n-    case BINOP_MOD:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      return ada_mult_binop (expect_type, exp, noside, op,\n-\t\t\t     arg1, arg2);\n-\n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      return ada_equal_binop (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case UNOP_NEG:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return ada_unop_neg (expect_type, exp, noside, op, arg1);\n-\n-    case BINOP_LOGICAL_AND:\n-    case BINOP_LOGICAL_OR:\n-    case UNOP_LOGICAL_NOT:\n-      {\n-\tstruct value *val;\n-\n-\t*pos -= 1;\n-\tval = evaluate_subexp_standard (expect_type, exp, pos, noside);\n-\ttype = language_bool_type (exp->language_defn, exp->gdbarch);\n-\treturn value_cast (type, val);\n-      }\n-\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n-      {\n-\tstruct value *val;\n-\n-\targ1 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-\t*pos = pc;\n-\tval = evaluate_subexp_standard (expect_type, exp, pos, noside);\n-\n-\treturn value_cast (value_type (arg1), val);\n-      }\n-\n-    case OP_VAR_VALUE:\n-      *pos -= 1;\n-\n-      if (noside == EVAL_SKIP)\n-\t{\n-\t  *pos += 4;\n-\t  goto nosideret;\n-\t}\n-\n-      if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)\n-\t/* Only encountered when an unresolved symbol occurs in a\n-\t   context other than a function call, in which case, it is\n-\t   invalid.  */\n-\terror (_(\"Unexpected unresolved symbol, %s, during evaluation\"),\n-\t       exp->elts[pc + 2].symbol->print_name ());\n-\n-      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t{\n-\t  type = static_unwrap_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol));\n-\t  /* Check to see if this is a tagged type.  We also need to handle\n-\t     the case where the type is a reference to a tagged type, but\n-\t     we have to be careful to exclude pointers to tagged types.\n-\t     The latter should be shown as usual (as a pointer), whereas\n-\t     a reference should mostly be transparent to the user.  */\n-\t  if (ada_is_tagged_type (type, 0)\n-\t      || (type->code () == TYPE_CODE_REF\n-\t\t  && ada_is_tagged_type (TYPE_TARGET_TYPE (type), 0)))\n-\t    {\n-\t      /* Tagged types are a little special in the fact that the real\n-\t\t type is dynamic and can only be determined by inspecting the\n-\t\t object's tag.  This means that we need to get the object's\n-\t\t value first (EVAL_NORMAL) and then extract the actual object\n-\t\t type from its tag.\n-\n-\t\t Note that we cannot skip the final step where we extract\n-\t\t the object type from its tag, because the EVAL_NORMAL phase\n-\t\t results in dynamic components being resolved into fixed ones.\n-\t\t This can cause problems when trying to print the type\n-\t\t description of tagged types whose parent has a dynamic size:\n-\t\t We use the type name of the \"_parent\" component in order\n-\t\t to print the name of the ancestor type in the type description.\n-\t\t If that component had a dynamic size, the resolution into\n-\t\t a fixed type would result in the loss of that type name,\n-\t\t thus preventing us from printing the name of the ancestor\n-\t\t type in the type description.  */\n-\t      arg1 = evaluate_subexp (nullptr, exp, pos, EVAL_NORMAL);\n-\n-\t      if (type->code () != TYPE_CODE_REF)\n-\t\t{\n-\t\t  struct type *actual_type;\n-\n-\t\t  actual_type = type_from_tag (ada_value_tag (arg1));\n-\t\t  if (actual_type == NULL)\n-\t\t    /* If, for some reason, we were unable to determine\n-\t\t       the actual type from the tag, then use the static\n-\t\t       approximation that we just computed as a fallback.\n-\t\t       This can happen if the debugging information is\n-\t\t       incomplete, for instance.  */\n-\t\t    actual_type = type;\n-\t\t  return value_zero (actual_type, not_lval);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* In the case of a ref, ada_coerce_ref takes care\n-\t\t     of determining the actual type.  But the evaluation\n-\t\t     should return a ref as it should be valid to ask\n-\t\t     for its address; so rebuild a ref after coerce.  */\n-\t\t  arg1 = ada_coerce_ref (arg1);\n-\t\t  return value_ref (arg1, TYPE_CODE_REF);\n-\t\t}\n-\t    }\n-\n-\t  /* Records and unions for which GNAT encodings have been\n-\t     generated need to be statically fixed as well.\n-\t     Otherwise, non-static fixing produces a type where\n-\t     all dynamic properties are removed, which prevents \"ptype\"\n-\t     from being able to completely describe the type.\n-\t     For instance, a case statement in a variant record would be\n-\t     replaced by the relevant components based on the actual\n-\t     value of the discriminants.  */\n-\t  if ((type->code () == TYPE_CODE_STRUCT\n-\t       && dynamic_template_type (type) != NULL)\n-\t      || (type->code () == TYPE_CODE_UNION\n-\t\t  && ada_find_parallel_type (type, \"___XVU\") != NULL))\n-\t    {\n-\t      *pos += 4;\n-\t      return value_zero (to_static_fixed_type (type), not_lval);\n-\t    }\n-\t}\n-\n-      arg1 = evaluate_subexp_standard (expect_type, exp, pos, noside);\n-      return ada_to_fixed_value (arg1);\n-\n-    case OP_FUNCALL:\n-      (*pos) += 2;\n-\n-      /* Allocate arg vector, including space for the function to be\n-\t called in argvec[0] and a terminating NULL.  */\n-      nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-      argvec = XALLOCAVEC (struct value *, nargs + 2);\n-\n-      if (exp->elts[*pos].opcode == OP_VAR_VALUE\n-\t  && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n-\terror (_(\"Unexpected unresolved symbol, %s, during evaluation\"),\n-\t       exp->elts[pc + 5].symbol->print_name ());\n-      else\n-\t{\n-\t  for (tem = 0; tem <= nargs; tem += 1)\n-\t    argvec[tem] = evaluate_subexp (nullptr, exp, pos, noside);\n-\t  argvec[tem] = 0;\n-\n-\t  if (noside == EVAL_SKIP)\n-\t    goto nosideret;\n-\t}\n-\n-      if (ada_is_constrained_packed_array_type\n-\t  (desc_base_type (value_type (argvec[0]))))\n-\targvec[0] = ada_coerce_to_simple_array (argvec[0]);\n-      else if (value_type (argvec[0])->code () == TYPE_CODE_ARRAY\n-\t       && TYPE_FIELD_BITSIZE (value_type (argvec[0]), 0) != 0)\n-\t/* This is a packed array that has already been fixed, and\n-\t   therefore already coerced to a simple array.  Nothing further\n-\t   to do.  */\n-\t;\n-      else if (value_type (argvec[0])->code () == TYPE_CODE_REF)\n-\t{\n-\t  /* Make sure we dereference references so that all the code below\n-\t     feels like it's really handling the referenced value.  Wrapping\n-\t     types (for alignment) may be there, so make sure we strip them as\n-\t     well.  */\n-\t  argvec[0] = ada_to_fixed_value (coerce_ref (argvec[0]));\n-\t}\n-      else if (value_type (argvec[0])->code () == TYPE_CODE_ARRAY\n-\t       && VALUE_LVAL (argvec[0]) == lval_memory)\n-\targvec[0] = value_addr (argvec[0]);\n-\n-      type = ada_check_typedef (value_type (argvec[0]));\n-\n-      /* Ada allows us to implicitly dereference arrays when subscripting\n-\t them.  So, if this is an array typedef (encoding use for array\n-\t access types encoded as fat pointers), strip it now.  */\n-      if (type->code () == TYPE_CODE_TYPEDEF)\n-\ttype = ada_typedef_target_type (type);\n-\n-      if (type->code () == TYPE_CODE_PTR)\n-\t{\n-\t  switch (ada_check_typedef (TYPE_TARGET_TYPE (type))->code ())\n-\t    {\n-\t    case TYPE_CODE_FUNC:\n-\t      type = ada_check_typedef (TYPE_TARGET_TYPE (type));\n-\t      break;\n-\t    case TYPE_CODE_ARRAY:\n-\t      break;\n-\t    case TYPE_CODE_STRUCT:\n-\t      if (noside != EVAL_AVOID_SIDE_EFFECTS)\n-\t\targvec[0] = ada_value_ind (argvec[0]);\n-\t      type = ada_check_typedef (TYPE_TARGET_TYPE (type));\n-\t      break;\n-\t    default:\n-\t      error (_(\"cannot subscript or call something of type `%s'\"),\n-\t\t     ada_type_name (value_type (argvec[0])));\n-\t      break;\n-\t    }\n-\t}\n-\n-      switch (type->code ())\n-\t{\n-\tcase TYPE_CODE_FUNC:\n-\t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t    {\n-\t      if (TYPE_TARGET_TYPE (type) == NULL)\n-\t\terror_call_unknown_return_type (NULL);\n-\t      return allocate_value (TYPE_TARGET_TYPE (type));\n-\t    }\n-\t  return call_function_by_hand (argvec[0], NULL,\n-\t\t\t\t\tgdb::make_array_view (argvec + 1,\n-\t\t\t\t\t\t\t      nargs));\n-\tcase TYPE_CODE_INTERNAL_FUNCTION:\n-\t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t    /* We don't know anything about what the internal\n-\t       function might return, but we have to return\n-\t       something.  */\n-\t    return value_zero (builtin_type (exp->gdbarch)->builtin_int,\n-\t\t\t       not_lval);\n-\t  else\n-\t    return call_internal_function (exp->gdbarch, exp->language_defn,\n-\t\t\t\t\t   argvec[0], nargs, argvec + 1);\n-\n-\tcase TYPE_CODE_STRUCT:\n-\t  {\n-\t    int arity;\n-\n-\t    arity = ada_array_arity (type);\n-\t    type = ada_array_element_type (type, nargs);\n-\t    if (type == NULL)\n-\t      error (_(\"cannot subscript or call a record\"));\n-\t    if (arity != nargs)\n-\t      error (_(\"wrong number of subscripts; expecting %d\"), arity);\n-\t    if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t      return value_zero (ada_aligned_type (type), lval_memory);\n-\t    return\n-\t      unwrap_value (ada_value_subscript\n-\t\t\t    (argvec[0], nargs, argvec + 1));\n-\t  }\n-\tcase TYPE_CODE_ARRAY:\n-\t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t    {\n-\t      type = ada_array_element_type (type, nargs);\n-\t      if (type == NULL)\n-\t\terror (_(\"element type of array unknown\"));\n-\t      else\n-\t\treturn value_zero (ada_aligned_type (type), lval_memory);\n-\t    }\n-\t  return\n-\t    unwrap_value (ada_value_subscript\n-\t\t\t  (ada_coerce_to_simple_array (argvec[0]),\n-\t\t\t   nargs, argvec + 1));\n-\tcase TYPE_CODE_PTR:     /* Pointer to array */\n-\t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t    {\n-\t      type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);\n-\t      type = ada_array_element_type (type, nargs);\n-\t      if (type == NULL)\n-\t\terror (_(\"element type of array unknown\"));\n-\t      else\n-\t\treturn value_zero (ada_aligned_type (type), lval_memory);\n-\t    }\n-\t  return\n-\t    unwrap_value (ada_value_ptr_subscript (argvec[0],\n-\t\t\t\t\t\t   nargs, argvec + 1));\n-\n-\tdefault:\n-\t  error (_(\"Attempt to index or call something other than an \"\n-\t\t   \"array or function\"));\n-\t}\n-\n-    case TERNOP_SLICE:\n-      {\n-\tstruct value *array = evaluate_subexp (nullptr, exp, pos, noside);\n-\tstruct value *low_bound_val\n-\t  = evaluate_subexp (nullptr, exp, pos, noside);\n-\tstruct value *high_bound_val\n-\t  = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-\tif (noside == EVAL_SKIP)\n-\t  goto nosideret;\n-\n-\treturn ada_ternop_slice (exp, noside, array, low_bound_val,\n-\t\t\t\t high_bound_val);\n-      }\n-\n-    case UNOP_IN_RANGE:\n-      (*pos) += 2;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      type = check_typedef (exp->elts[pc + 1].type);\n-      return ada_unop_in_range (expect_type, exp, noside, op, arg1, type);\n-\n-    case BINOP_IN_BOUNDS:\n-      (*pos) += 2;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-\n-      return ada_binop_in_bounds (exp, noside, arg1, arg2, tem);\n-\n-    case TERNOP_IN_RANGE:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg3 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      return eval_ternop_in_range (expect_type, exp, noside, arg1, arg2, arg3);\n-\n-    case OP_ATR_FIRST:\n-    case OP_ATR_LAST:\n-    case OP_ATR_LENGTH:\n-      {\n-\tstruct type *type_arg;\n-\n-\tif (exp->elts[*pos].opcode == OP_TYPE)\n-\t  {\n-\t    evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\t    arg1 = NULL;\n-\t    type_arg = check_typedef (exp->elts[pc + 2].type);\n-\t  }\n-\telse\n-\t  {\n-\t    arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\t    type_arg = NULL;\n-\t  }\n-\n-\tif (exp->elts[*pos].opcode != OP_LONG)\n-\t  error (_(\"Invalid operand to '%s\"), ada_attribute_name (op));\n-\ttem = longest_to_int (exp->elts[*pos + 2].longconst);\n-\t*pos += 4;\n-\n-\tif (noside == EVAL_SKIP)\n-\t  goto nosideret;\n-\n-\treturn ada_unop_atr (exp, noside, op, arg1, type_arg, tem);\n-      }\n-\n-    case OP_ATR_TAG:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      return ada_atr_tag (expect_type, exp, noside, op, arg1);\n-\n-    case OP_ATR_MIN:\n-    case OP_ATR_MAX:\n-      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      return ada_binop_minmax (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case OP_ATR_MODULUS:\n-      {\n-\tstruct type *type_arg = check_typedef (exp->elts[pc + 2].type);\n-\n-\tevaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\tif (noside == EVAL_SKIP)\n-\t  goto nosideret;\n-\n-\tif (!ada_is_modular_type (type_arg))\n-\t  error (_(\"'modulus must be applied to modular type\"));\n-\n-\treturn value_from_longest (TYPE_TARGET_TYPE (type_arg),\n-\t\t\t\t   ada_modulus (type_arg));\n-      }\n-\n-\n-    case OP_ATR_POS:\n-      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      return ada_pos_atr (expect_type, exp, noside, op, arg1);\n-\n-    case OP_ATR_SIZE:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return ada_atr_size (expect_type, exp, noside, op, arg1);\n-\n-    case OP_ATR_VAL:\n-      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      type = exp->elts[pc + 2].type;\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      return ada_val_atr (noside, type, arg1);\n-\n-    case BINOP_EXP:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      return ada_binop_exp (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case UNOP_PLUS:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      else\n-\treturn arg1;\n+    case TYPE_CODE_STRUCT:\n+      {\n+\tint arity;\n \n-    case UNOP_ABS:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      return ada_abs (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_IND:\n-      preeval_pos = *pos;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      type = ada_check_typedef (value_type (arg1));\n+\tarity = ada_array_arity (type);\n+\ttype = ada_array_element_type (type, nargs);\n+\tif (type == NULL)\n+\t  error (_(\"cannot subscript or call a record\"));\n+\tif (arity != nargs)\n+\t  error (_(\"wrong number of subscripts; expecting %d\"), arity);\n+\tif (noside == EVAL_AVOID_SIDE_EFFECTS)\n+\t  return value_zero (ada_aligned_type (type), lval_memory);\n+\treturn\n+\t  unwrap_value (ada_value_subscript\n+\t\t\t(callee, nargs, argvec.data ()));\n+      }\n+    case TYPE_CODE_ARRAY:\n       if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t{\n-\t  if (ada_is_array_descriptor_type (type))\n-\t    /* GDB allows dereferencing GNAT array descriptors.  */\n-\t    {\n-\t      struct type *arrType = ada_type_of_array (arg1, 0);\n-\n-\t      if (arrType == NULL)\n-\t\terror (_(\"Attempt to dereference null array pointer.\"));\n-\t      return value_at_lazy (arrType, 0);\n-\t    }\n-\t  else if (type->code () == TYPE_CODE_PTR\n-\t\t   || type->code () == TYPE_CODE_REF\n-\t\t   /* In C you can dereference an array to get the 1st elt.  */\n-\t\t   || type->code () == TYPE_CODE_ARRAY)\n-\t    {\n-\t    /* As mentioned in the OP_VAR_VALUE case, tagged types can\n-\t       only be determined by inspecting the object's tag.\n-\t       This means that we need to evaluate completely the\n-\t       expression in order to get its type.  */\n-\n-\t      if ((type->code () == TYPE_CODE_REF\n-\t\t   || type->code () == TYPE_CODE_PTR)\n-\t\t  && ada_is_tagged_type (TYPE_TARGET_TYPE (type), 0))\n-\t\t{\n-\t\t  arg1\n-\t\t    = evaluate_subexp (nullptr, exp, &preeval_pos, EVAL_NORMAL);\n-\t\t  type = value_type (ada_value_ind (arg1));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  type = to_static_fixed_type\n-\t\t    (ada_aligned_type\n-\t\t     (ada_check_typedef (TYPE_TARGET_TYPE (type))));\n-\t\t}\n-\t      ada_ensure_varsize_limit (type);\n-\t      return value_zero (type, lval_memory);\n-\t    }\n-\t  else if (type->code () == TYPE_CODE_INT)\n-\t    {\n-\t      /* GDB allows dereferencing an int.  */\n-\t      if (expect_type == NULL)\n-\t\treturn value_zero (builtin_type (exp->gdbarch)->builtin_int,\n-\t\t\t\t   lval_memory);\n-\t      else\n-\t\t{\n-\t\t  expect_type = \n-\t\t    to_static_fixed_type (ada_aligned_type (expect_type));\n-\t\t  return value_zero (expect_type, lval_memory);\n-\t\t}\n-\t    }\n+\t  type = ada_array_element_type (type, nargs);\n+\t  if (type == NULL)\n+\t    error (_(\"element type of array unknown\"));\n \t  else\n-\t    error (_(\"Attempt to take contents of a non-pointer value.\"));\n+\t    return value_zero (ada_aligned_type (type), lval_memory);\n \t}\n-      arg1 = ada_coerce_ref (arg1);     /* FIXME: What is this for??  */\n-      type = ada_check_typedef (value_type (arg1));\n-\n-      if (type->code () == TYPE_CODE_INT)\n-\t  /* GDB allows dereferencing an int.  If we were given\n-\t     the expect_type, then use that as the target type.\n-\t     Otherwise, assume that the target type is an int.  */\n+      return\n+\tunwrap_value (ada_value_subscript\n+\t\t      (ada_coerce_to_simple_array (callee),\n+\t\t       nargs, argvec.data ()));\n+    case TYPE_CODE_PTR:     /* Pointer to array */\n+      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t{\n-\t  if (expect_type != NULL)\n-\t    return ada_value_ind (value_cast (lookup_pointer_type (expect_type),\n-\t\t\t\t\t      arg1));\n+\t  type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);\n+\t  type = ada_array_element_type (type, nargs);\n+\t  if (type == NULL)\n+\t    error (_(\"element type of array unknown\"));\n \t  else\n-\t    return value_at_lazy (builtin_type (exp->gdbarch)->builtin_int,\n-\t\t\t\t  (CORE_ADDR) value_as_address (arg1));\n+\t    return value_zero (ada_aligned_type (type), lval_memory);\n \t}\n+      return\n+\tunwrap_value (ada_value_ptr_subscript (callee, nargs,\n+\t\t\t\t\t       argvec.data ()));\n \n-      if (ada_is_array_descriptor_type (type))\n-\t/* GDB allows dereferencing GNAT array descriptors.  */\n-\treturn ada_coerce_to_simple_array (arg1);\n-      else\n-\treturn ada_value_ind (arg1);\n-\n-    case STRUCTOP_STRUCT:\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      preeval_pos = *pos;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t{\n-\t  struct type *type1 = value_type (arg1);\n+    default:\n+      error (_(\"Attempt to index or call something other than an \"\n+\t       \"array or function\"));\n+    }\n+}\n \n-\t  if (ada_is_tagged_type (type1, 1))\n-\t    {\n-\t      type = ada_lookup_struct_elt_type (type1,\n-\t\t\t\t\t\t &exp->elts[pc + 2].string,\n-\t\t\t\t\t\t 1, 1);\n+bool\n+ada_funcall_operation::resolve (struct expression *exp,\n+\t\t\t\tbool deprocedure_p,\n+\t\t\t\tbool parse_completion,\n+\t\t\t\tinnermost_block_tracker *tracker,\n+\t\t\t\tstruct type *context_type)\n+{\n+  operation_up &callee_op = std::get<0> (m_storage);\n \n-\t      /* If the field is not found, check if it exists in the\n-\t\t extension of this object's type. This means that we\n-\t\t need to evaluate completely the expression.  */\n+  ada_var_value_operation *avv\n+    = dynamic_cast<ada_var_value_operation *> (callee_op.get ());\n+  if (avv == nullptr)\n+    return false;\n \n-\t      if (type == NULL)\n-\t\t{\n-\t\t  arg1\n-\t\t    = evaluate_subexp (nullptr, exp, &preeval_pos, EVAL_NORMAL);\n-\t\t  arg1 = ada_value_struct_elt (arg1,\n-\t\t\t\t\t       &exp->elts[pc + 2].string,\n-\t\t\t\t\t       0);\n-\t\t  arg1 = unwrap_value (arg1);\n-\t\t  type = value_type (ada_to_fixed_value (arg1));\n-\t\t}\n-\t    }\n-\t  else\n-\t    type =\n-\t      ada_lookup_struct_elt_type (type1, &exp->elts[pc + 2].string, 1,\n-\t\t\t\t\t  0);\n+  symbol *sym = avv->get_symbol ();\n+  if (SYMBOL_DOMAIN (sym) != UNDEF_DOMAIN)\n+    return false;\n \n-\t  return value_zero (ada_aligned_type (type), lval_memory);\n-\t}\n-      else\n-\t{\n-\t  arg1 = ada_value_struct_elt (arg1, &exp->elts[pc + 2].string, 0);\n-\t  arg1 = unwrap_value (arg1);\n-\t  return ada_to_fixed_value (arg1);\n-\t}\n+  const std::vector<operation_up> &args_up = std::get<1> (m_storage);\n+  int nargs = args_up.size ();\n+  std::vector<value *> argvec (nargs);\n \n-    case OP_TYPE:\n-      /* The value is not supposed to be used.  This is here to make it\n-\t easier to accommodate expressions that contain types.  */\n-      (*pos) += 2;\n-      if (noside == EVAL_SKIP)\n-\tgoto nosideret;\n-      else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\treturn allocate_value (exp->elts[pc + 1].type);\n-      else\n-\terror (_(\"Attempt to use a type name as an expression\"));\n-\n-    case OP_AGGREGATE:\n-    case OP_CHOICES:\n-    case OP_OTHERS:\n-    case OP_DISCRETE_RANGE:\n-    case OP_POSITIONAL:\n-    case OP_NAME:\n-      if (noside == EVAL_NORMAL)\n-\tswitch (op) \n-\t  {\n-\t  case OP_NAME:\n-\t    error (_(\"Undefined name, ambiguous name, or renaming used in \"\n-\t\t     \"component association: %s.\"), &exp->elts[pc+2].string);\n-\t  case OP_AGGREGATE:\n-\t    error (_(\"Aggregates only allowed on the right of an assignment\"));\n-\t  default:\n-\t    internal_error (__FILE__, __LINE__,\n-\t\t\t    _(\"aggregate apparently mangled\"));\n-\t  }\n+  for (int i = 0; i < args_up.size (); ++i)\n+    argvec[i] = args_up[i]->evaluate (nullptr, exp, EVAL_AVOID_SIDE_EFFECTS);\n \n-      ada_forward_operator_length (exp, pc, &oplen, &nargs);\n-      *pos += oplen - 1;\n-      for (tem = 0; tem < nargs; tem += 1) \n-\tada_evaluate_subexp (NULL, exp, pos, noside);\n-      goto nosideret;\n-    }\n+  const block *block = avv->get_block ();\n+  block_symbol resolved\n+    = ada_resolve_funcall (sym, block,\n+\t\t\t   context_type, parse_completion,\n+\t\t\t   nargs, argvec.data (),\n+\t\t\t   tracker);\n+\n+  std::get<0> (m_storage)\n+    = make_operation<ada_var_value_operation> (resolved.symbol,\n+\t\t\t\t\t       resolved.block);\n+  return false;\n+}\n+\n+bool\n+ada_ternop_slice_operation::resolve (struct expression *exp,\n+\t\t\t\t     bool deprocedure_p,\n+\t\t\t\t     bool parse_completion,\n+\t\t\t\t     innermost_block_tracker *tracker,\n+\t\t\t\t     struct type *context_type)\n+{\n+  /* Historically this check was done during resolution, so we\n+     continue that here.  */\n+  value *v = std::get<0> (m_storage)->evaluate (context_type, exp,\n+\t\t\t\t\t\tEVAL_AVOID_SIDE_EFFECTS);\n+  if (ada_is_any_packed_array_type (value_type (v)))\n+    error (_(\"cannot slice a packed array\"));\n+  return false;\n+}\n \n-nosideret:\n-  return eval_skip_value (exp);\n }\n+\n \f\n \n /* Return non-zero iff TYPE represents a System.Address type.  */\n@@ -14055,336 +12652,6 @@ info_exceptions_command (const char *regexp, int from_tty)\n     printf_filtered (\"%s: %s\\n\", info.name, paddress (gdbarch, info.addr));\n }\n \n-\t\t\t\t/* Operators */\n-/* Information about operators given special treatment in functions\n-   below.  */\n-/* Format: OP_DEFN (<operator>, <operator length>, <# args>, <binop>).  */\n-\n-#define ADA_OPERATORS \\\n-    OP_DEFN (OP_VAR_VALUE, 4, 0, 0) \\\n-    OP_DEFN (BINOP_IN_BOUNDS, 3, 2, 0) \\\n-    OP_DEFN (TERNOP_IN_RANGE, 1, 3, 0) \\\n-    OP_DEFN (OP_ATR_FIRST, 1, 2, 0) \\\n-    OP_DEFN (OP_ATR_LAST, 1, 2, 0) \\\n-    OP_DEFN (OP_ATR_LENGTH, 1, 2, 0) \\\n-    OP_DEFN (OP_ATR_IMAGE, 1, 2, 0) \\\n-    OP_DEFN (OP_ATR_MAX, 1, 3, 0) \\\n-    OP_DEFN (OP_ATR_MIN, 1, 3, 0) \\\n-    OP_DEFN (OP_ATR_MODULUS, 1, 1, 0) \\\n-    OP_DEFN (OP_ATR_POS, 1, 2, 0) \\\n-    OP_DEFN (OP_ATR_SIZE, 1, 1, 0) \\\n-    OP_DEFN (OP_ATR_TAG, 1, 1, 0) \\\n-    OP_DEFN (OP_ATR_VAL, 1, 2, 0) \\\n-    OP_DEFN (UNOP_QUAL, 3, 1, 0) \\\n-    OP_DEFN (UNOP_IN_RANGE, 3, 1, 0) \\\n-    OP_DEFN (OP_OTHERS, 1, 1, 0) \\\n-    OP_DEFN (OP_POSITIONAL, 3, 1, 0) \\\n-    OP_DEFN (OP_DISCRETE_RANGE, 1, 2, 0)\n-\n-static void\n-ada_operator_length (const struct expression *exp, int pc, int *oplenp,\n-\t\t     int *argsp)\n-{\n-  switch (exp->elts[pc - 1].opcode)\n-    {\n-    default:\n-      operator_length_standard (exp, pc, oplenp, argsp);\n-      break;\n-\n-#define OP_DEFN(op, len, args, binop) \\\n-    case op: *oplenp = len; *argsp = args; break;\n-      ADA_OPERATORS;\n-#undef OP_DEFN\n-\n-    case OP_AGGREGATE:\n-      *oplenp = 3;\n-      *argsp = longest_to_int (exp->elts[pc - 2].longconst);\n-      break;\n-\n-    case OP_CHOICES:\n-      *oplenp = 3;\n-      *argsp = longest_to_int (exp->elts[pc - 2].longconst) + 1;\n-      break;\n-    }\n-}\n-\n-/* Implementation of the exp_descriptor method operator_check.  */\n-\n-static int\n-ada_operator_check (struct expression *exp, int pos,\n-\t\t    int (*objfile_func) (struct objfile *objfile, void *data),\n-\t\t    void *data)\n-{\n-  const union exp_element *const elts = exp->elts;\n-  struct type *type = NULL;\n-\n-  switch (elts[pos].opcode)\n-    {\n-      case UNOP_IN_RANGE:\n-      case UNOP_QUAL:\n-\ttype = elts[pos + 1].type;\n-\tbreak;\n-\n-      default:\n-\treturn operator_check_standard (exp, pos, objfile_func, data);\n-    }\n-\n-  /* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */\n-\n-  if (type != nullptr && type->objfile_owner () != nullptr\n-      && objfile_func (type->objfile_owner (), data))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* As for operator_length, but assumes PC is pointing at the first\n-   element of the operator, and gives meaningful results only for the \n-   Ada-specific operators, returning 0 for *OPLENP and *ARGSP otherwise.  */\n-\n-static void\n-ada_forward_operator_length (struct expression *exp, int pc,\n-\t\t\t     int *oplenp, int *argsp)\n-{\n-  switch (exp->elts[pc].opcode)\n-    {\n-    default:\n-      *oplenp = *argsp = 0;\n-      break;\n-\n-#define OP_DEFN(op, len, args, binop) \\\n-    case op: *oplenp = len; *argsp = args; break;\n-      ADA_OPERATORS;\n-#undef OP_DEFN\n-\n-    case OP_AGGREGATE:\n-      *oplenp = 3;\n-      *argsp = longest_to_int (exp->elts[pc + 1].longconst);\n-      break;\n-\n-    case OP_CHOICES:\n-      *oplenp = 3;\n-      *argsp = longest_to_int (exp->elts[pc + 1].longconst) + 1;\n-      break;\n-\n-    case OP_STRING:\n-    case OP_NAME:\n-      {\n-\tint len = longest_to_int (exp->elts[pc + 1].longconst);\n-\n-\t*oplenp = 4 + BYTES_TO_EXP_ELEM (len + 1);\n-\t*argsp = 0;\n-\tbreak;\n-      }\n-    }\n-}\n-\n-static int\n-ada_dump_subexp_body (struct expression *exp, struct ui_file *stream, int elt)\n-{\n-  enum exp_opcode op = exp->elts[elt].opcode;\n-  int oplen, nargs;\n-  int pc = elt;\n-  int i;\n-\n-  ada_forward_operator_length (exp, elt, &oplen, &nargs);\n-\n-  switch (op)\n-    {\n-      /* Ada attributes ('Foo).  */\n-    case OP_ATR_FIRST:\n-    case OP_ATR_LAST:\n-    case OP_ATR_LENGTH:\n-    case OP_ATR_IMAGE:\n-    case OP_ATR_MAX:\n-    case OP_ATR_MIN:\n-    case OP_ATR_MODULUS:\n-    case OP_ATR_POS:\n-    case OP_ATR_SIZE:\n-    case OP_ATR_TAG:\n-    case OP_ATR_VAL:\n-      break;\n-\n-    case UNOP_IN_RANGE:\n-    case UNOP_QUAL:\n-      /* XXX: gdb_sprint_host_address, type_sprint */\n-      fprintf_filtered (stream, _(\"Type @\"));\n-      gdb_print_host_address (exp->elts[pc + 1].type, stream);\n-      fprintf_filtered (stream, \" (\");\n-      type_print (exp->elts[pc + 1].type, NULL, stream, 0);\n-      fprintf_filtered (stream, \")\");\n-      break;\n-    case BINOP_IN_BOUNDS:\n-      fprintf_filtered (stream, \" (%d)\",\n-\t\t\tlongest_to_int (exp->elts[pc + 2].longconst));\n-      break;\n-    case TERNOP_IN_RANGE:\n-      break;\n-\n-    case OP_AGGREGATE:\n-    case OP_OTHERS:\n-    case OP_DISCRETE_RANGE:\n-    case OP_POSITIONAL:\n-    case OP_CHOICES:\n-      break;\n-\n-    case OP_NAME:\n-    case OP_STRING:\n-      {\n-\tchar *name = &exp->elts[elt + 2].string;\n-\tint len = longest_to_int (exp->elts[elt + 1].longconst);\n-\n-\tfprintf_filtered (stream, \"Text: `%.*s'\", len, name);\n-\tbreak;\n-      }\n-\n-    default:\n-      return dump_subexp_body_standard (exp, stream, elt);\n-    }\n-\n-  elt += oplen;\n-  for (i = 0; i < nargs; i += 1)\n-    elt = dump_subexp (exp, stream, elt);\n-\n-  return elt;\n-}\n-\n-/* The Ada extension of print_subexp (q.v.).  */\n-\n-static void\n-ada_print_subexp (struct expression *exp, int *pos,\n-\t\t  struct ui_file *stream, enum precedence prec)\n-{\n-  int oplen, nargs, i;\n-  int pc = *pos;\n-  enum exp_opcode op = exp->elts[pc].opcode;\n-\n-  ada_forward_operator_length (exp, pc, &oplen, &nargs);\n-\n-  *pos += oplen;\n-  switch (op)\n-    {\n-    default:\n-      *pos -= oplen;\n-      print_subexp_standard (exp, pos, stream, prec);\n-      return;\n-\n-    case OP_VAR_VALUE:\n-      fputs_filtered (exp->elts[pc + 2].symbol->natural_name (), stream);\n-      return;\n-\n-    case BINOP_IN_BOUNDS:\n-      /* XXX: sprint_subexp */\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\" in \", stream);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\"'range\", stream);\n-      if (exp->elts[pc + 1].longconst > 1)\n-\tfprintf_filtered (stream, \"(%ld)\",\n-\t\t\t  (long) exp->elts[pc + 1].longconst);\n-      return;\n-\n-    case TERNOP_IN_RANGE:\n-      if (prec >= PREC_EQUAL)\n-\tfputs_filtered (\"(\", stream);\n-      /* XXX: sprint_subexp */\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\" in \", stream);\n-      print_subexp (exp, pos, stream, PREC_EQUAL);\n-      fputs_filtered (\" .. \", stream);\n-      print_subexp (exp, pos, stream, PREC_EQUAL);\n-      if (prec >= PREC_EQUAL)\n-\tfputs_filtered (\")\", stream);\n-      return;\n-\n-    case OP_ATR_FIRST:\n-    case OP_ATR_LAST:\n-    case OP_ATR_LENGTH:\n-    case OP_ATR_IMAGE:\n-    case OP_ATR_MAX:\n-    case OP_ATR_MIN:\n-    case OP_ATR_MODULUS:\n-    case OP_ATR_POS:\n-    case OP_ATR_SIZE:\n-    case OP_ATR_TAG:\n-    case OP_ATR_VAL:\n-      if (exp->elts[*pos].opcode == OP_TYPE)\n-\t{\n-\t  if (exp->elts[*pos + 1].type->code () != TYPE_CODE_VOID)\n-\t    LA_PRINT_TYPE (exp->elts[*pos + 1].type, \"\", stream, 0, 0,\n-\t\t\t   &type_print_raw_options);\n-\t  *pos += 3;\n-\t}\n-      else\n-\tprint_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fprintf_filtered (stream, \"'%s\", ada_attribute_name (op));\n-      if (nargs > 1)\n-\t{\n-\t  int tem;\n-\n-\t  for (tem = 1; tem < nargs; tem += 1)\n-\t    {\n-\t      fputs_filtered ((tem == 1) ? \" (\" : \", \", stream);\n-\t      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-\t    }\n-\t  fputs_filtered (\")\", stream);\n-\t}\n-      return;\n-\n-    case UNOP_QUAL:\n-      type_print (exp->elts[pc + 1].type, \"\", stream, 0);\n-      fputs_filtered (\"'(\", stream);\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      fputs_filtered (\")\", stream);\n-      return;\n-\n-    case UNOP_IN_RANGE:\n-      /* XXX: sprint_subexp */\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\" in \", stream);\n-      LA_PRINT_TYPE (exp->elts[pc + 1].type, \"\", stream, 1, 0,\n-\t\t     &type_print_raw_options);\n-      return;\n-\n-    case OP_DISCRETE_RANGE:\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\"..\", stream);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      return;\n-\n-    case OP_OTHERS:\n-      fputs_filtered (\"others => \", stream);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      return;\n-\n-    case OP_CHOICES:\n-      for (i = 0; i < nargs-1; i += 1)\n-\t{\n-\t  if (i > 0)\n-\t    fputs_filtered (\"|\", stream);\n-\t  print_subexp (exp, pos, stream, PREC_SUFFIX);\n-\t}\n-      fputs_filtered (\" => \", stream);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      return;\n-      \n-    case OP_POSITIONAL:\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      return;\n-\n-    case OP_AGGREGATE:\n-      fputs_filtered (\"(\", stream);\n-      for (i = 0; i < nargs; i += 1)\n-\t{\n-\t  if (i > 0)\n-\t    fputs_filtered (\", \", stream);\n-\t  print_subexp (exp, pos, stream, PREC_SUFFIX);\n-\t}\n-      fputs_filtered (\")\", stream);\n-      return;\n-    }\n-}\n-\n /* Table mapping opcodes into strings for printing operators\n    and precedences of the operators.  */\n \n@@ -14425,14 +12692,6 @@ static const struct op_print ada_op_print_tab[] = {\n \f\n \t\t\t\t/* Language vector */\n \n-static const struct exp_descriptor ada_exp_descriptor = {\n-  ada_print_subexp,\n-  ada_operator_length,\n-  ada_operator_check,\n-  ada_dump_subexp_body,\n-  ada_evaluate_subexp\n-};\n-\n /* symbol_name_matcher_ftype adapter for wild_match.  */\n \n static bool\n@@ -15030,14 +13289,6 @@ class ada_language : public language_defn\n   void post_parser (expression_up *expp, struct parser_state *ps)\n     const override\n   {\n-    struct type *context_type = NULL;\n-    int pc = 0;\n-\n-    if (ps->void_context_p)\n-      context_type = builtin_type ((*expp)->gdbarch)->builtin_void;\n-\n-    resolve_subexp (expp, &pc, 1, context_type, ps->parse_completion,\n-\t\t    ps->block_tracker);\n   }\n \n   /* See language.h.  */\n@@ -15104,11 +13355,6 @@ class ada_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &ada_exp_descriptor; }\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return ada_op_print_tab; }\n "
    }
  ]
}