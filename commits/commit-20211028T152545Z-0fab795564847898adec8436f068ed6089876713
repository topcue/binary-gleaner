{
  "sha": "0fab795564847898adec8436f068ed6089876713",
  "node_id": "C_kwDOANOeidoAKDBmYWI3OTU1NjQ4NDc4OThhZGVjODQzNmYwNjhlZDYwODk4NzY3MTM",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-10-28T15:25:45Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-10-28T15:25:45Z"
    },
    "message": "gdb: use ptid_t::to_string in infrun debug messages\n\nIn debug messages, I think it would be more helpful to print ptid using\nthe simple \"pid.lwp.tid\" notation in infrun debug messages.  I am\ncurrently debugging some fork issues, and find the pid_to_str output not\nso useful, as it doesn't tell which process a thread belongs to.\n\nIt currently shows up like this:\n\n    [infrun] resume_1: step=1, signal=GDB_SIGNAL_0, trap_expected=0, current thread [Thread 0x7ffff7d95740 (LWP 892942)] at 0x55555555521f\n\nWith the patch, it shows up like this:\n\n    [infrun] resume_1: step=1, signal=GDB_SIGNAL_0, trap_expected=1, current thread [894072.894077.0] at 0x5555555551d9\n\nChange-Id: I130796d7dfb0d8e763b8358d8a6002701d80c4ea",
    "tree": {
      "sha": "48570993c043dfbcb0943f76db28b0a3f4af5a03",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/48570993c043dfbcb0943f76db28b0a3f4af5a03"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0fab795564847898adec8436f068ed6089876713",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0fab795564847898adec8436f068ed6089876713",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0fab795564847898adec8436f068ed6089876713",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0fab795564847898adec8436f068ed6089876713/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c0492bea7ca33fafc280f08f4ed9f505d29e7130",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0492bea7ca33fafc280f08f4ed9f505d29e7130",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c0492bea7ca33fafc280f08f4ed9f505d29e7130"
    }
  ],
  "stats": {
    "total": 116,
    "additions": 57,
    "deletions": 59
  },
  "files": [
    {
      "sha": "4698fe20cc164b6c9fe401244c234cdee714a4f8",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 57,
      "deletions": 59,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0fab795564847898adec8436f068ed6089876713/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0fab795564847898adec8436f068ed6089876713/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=0fab795564847898adec8436f068ed6089876713",
      "patch": "@@ -888,7 +888,7 @@ proceed_after_vfork_done (thread_info *thread)\n       && thread->stop_signal () == GDB_SIGNAL_0)\n     {\n       infrun_debug_printf (\"resuming vfork parent thread %s\",\n-\t\t\t   target_pid_to_str (thread->ptid).c_str ());\n+\t\t\t   thread->ptid.to_string ().c_str ());\n \n       switch_to_thread (thread);\n       clear_proceed_status (0);\n@@ -1652,14 +1652,14 @@ displaced_step_prepare_throw (thread_info *tp)\n \t it is likely that it will return unavailable, so don't bother asking.  */\n \n       displaced_debug_printf (\"deferring step of %s\",\n-\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t      tp->ptid.to_string ().c_str ());\n \n       global_thread_step_over_chain_enqueue (tp);\n       return DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE;\n     }\n \n   displaced_debug_printf (\"displaced-stepping %s now\",\n-\t\t\t  target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t  tp->ptid.to_string ().c_str ());\n \n   scoped_restore_current_thread restore_thread;\n \n@@ -1674,7 +1674,7 @@ displaced_step_prepare_throw (thread_info *tp)\n   if (status == DISPLACED_STEP_PREPARE_STATUS_CANT)\n     {\n       displaced_debug_printf (\"failed to prepare (%s)\",\n-\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t      tp->ptid.to_string ().c_str ());\n \n       return DISPLACED_STEP_PREPARE_STATUS_CANT;\n     }\n@@ -1685,7 +1685,7 @@ displaced_step_prepare_throw (thread_info *tp)\n \n       displaced_debug_printf (\"not enough resources available, \"\n \t\t\t      \"deferring step of %s\",\n-\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t      tp->ptid.to_string ().c_str ());\n \n       global_thread_step_over_chain_enqueue (tp);\n \n@@ -1702,7 +1702,7 @@ displaced_step_prepare_throw (thread_info *tp)\n \n   displaced_debug_printf (\"prepared successfully thread=%s, \"\n \t\t\t  \"original_pc=%s, displaced_pc=%s\",\n-\t\t\t  target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t  tp->ptid.to_string ().c_str (),\n \t\t\t  paddress (gdbarch, original_pc),\n \t\t\t  paddress (gdbarch, displaced_pc));\n \n@@ -1930,14 +1930,14 @@ start_step_over (void)\n \t  internal_error (__FILE__, __LINE__,\n \t\t\t  \"[%s] has inconsistent state: \"\n \t\t\t  \"trap_expected=%d, resumed=%d, executing=%d\\n\",\n-\t\t\t  target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t  tp->ptid.to_string ().c_str (),\n \t\t\t  tp->control.trap_expected,\n \t\t\t  tp->resumed (),\n \t\t\t  tp->executing ());\n \t}\n \n       infrun_debug_printf (\"resuming [%s] for step-over\",\n-\t\t\t   target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t   tp->ptid.to_string ().c_str ());\n \n       /* keep_going_pass_signal skips the step-over if the breakpoint\n \t is no longer inserted.  In all-stop, we want to keep looking\n@@ -1960,13 +1960,13 @@ start_step_over (void)\n       if (tp->resumed  ())\n \t{\n \t  infrun_debug_printf (\"[%s] was resumed.\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  gdb_assert (!thread_is_in_step_over_chain (tp));\n \t}\n       else\n \t{\n \t  infrun_debug_printf (\"[%s] was NOT resumed.\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  gdb_assert (thread_is_in_step_over_chain (tp));\n \t}\n \n@@ -2218,7 +2218,7 @@ resume_1 (enum gdb_signal sig)\n       infrun_debug_printf\n \t(\"thread %s has pending wait \"\n \t \"status %s (currently_stepping=%d).\",\n-\t target_pid_to_str (tp->ptid).c_str (),\n+\t tp->ptid.to_string ().c_str (),\n \t target_waitstatus_to_string (&tp->pending_waitstatus ()).c_str (),\n \t currently_stepping (tp));\n \n@@ -2232,7 +2232,7 @@ resume_1 (enum gdb_signal sig)\n \t{\n \t  warning (_(\"Couldn't deliver signal %s to %s.\"),\n \t\t   gdb_signal_to_name (sig),\n-\t\t   target_pid_to_str (tp->ptid).c_str ());\n+\t\t   tp->ptid.to_string ().c_str ());\n \t}\n \n       tp->set_stop_signal (GDB_SIGNAL_0);\n@@ -2274,7 +2274,7 @@ resume_1 (enum gdb_signal sig)\n \t\t       \"current thread [%s] at %s\",\n \t\t       step, gdb_signal_to_symbol_string (sig),\n \t\t       tp->control.trap_expected,\n-\t\t       target_pid_to_str (inferior_ptid).c_str (),\n+\t\t       inferior_ptid.to_string ().c_str (),\n \t\t       paddress (gdbarch, pc));\n \n   /* Normally, by the time we reach `resume', the breakpoints are either\n@@ -2515,7 +2515,7 @@ resume_1 (enum gdb_signal sig)\n \t do displaced stepping.  */\n \n       infrun_debug_printf (\"resume: [%s] stepped breakpoint\",\n-\t\t\t   target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t   tp->ptid.to_string ().c_str ());\n \n       tp->stepped_breakpoint = 1;\n \n@@ -2617,7 +2617,7 @@ new_stop_id (void)\n static void\n clear_proceed_status_thread (struct thread_info *tp)\n {\n-  infrun_debug_printf (\"%s\", target_pid_to_str (tp->ptid).c_str ());\n+  infrun_debug_printf (\"%s\", tp->ptid.to_string ().c_str ());\n \n   /* If we're starting a new sequence, then the previous finished\n      single-step is no longer relevant.  */\n@@ -2627,7 +2627,7 @@ clear_proceed_status_thread (struct thread_info *tp)\n \t{\n \t  infrun_debug_printf (\"pending event of %s was a finished step. \"\n \t\t\t       \"Discarding.\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \n \t  tp->clear_pending_waitstatus ();\n \t  tp->set_stop_reason (TARGET_STOPPED_BY_NO_REASON);\n@@ -2636,7 +2636,7 @@ clear_proceed_status_thread (struct thread_info *tp)\n \t{\n \t  infrun_debug_printf\n \t    (\"thread %s has pending wait status %s (currently_stepping=%d).\",\n-\t     target_pid_to_str (tp->ptid).c_str (),\n+\t     tp->ptid.to_string ().c_str (),\n \t     target_waitstatus_to_string (&tp->pending_waitstatus ()).c_str (),\n \t     currently_stepping (tp));\n \t}\n@@ -3179,7 +3179,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t  gdb_assert (!thread_is_in_step_over_chain (tp));\n \n \t  infrun_debug_printf (\"need to step-over [%s] first\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \n \t  global_thread_step_over_chain_enqueue (tp);\n \t}\n@@ -3230,27 +3230,27 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t    if (!tp->inf->has_execution ())\n \t      {\n \t\tinfrun_debug_printf (\"[%s] target has no execution\",\n-\t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t\t     tp->ptid.to_string ().c_str ());\n \t\tcontinue;\n \t      }\n \n \t    if (tp->resumed ())\n \t      {\n \t\tinfrun_debug_printf (\"[%s] resumed\",\n-\t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t\t     tp->ptid.to_string ().c_str ());\n \t\tgdb_assert (tp->executing () || tp->has_pending_waitstatus ());\n \t\tcontinue;\n \t      }\n \n \t    if (thread_is_in_step_over_chain (tp))\n \t      {\n \t\tinfrun_debug_printf (\"[%s] needs step-over\",\n-\t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t\t     tp->ptid.to_string ().c_str ());\n \t\tcontinue;\n \t      }\n \n \t    infrun_debug_printf (\"resuming %s\",\n-\t\t\t\t target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t\t tp->ptid.to_string ().c_str ());\n \n \t    reset_ecs (ecs, tp);\n \t    switch_to_thread (tp);\n@@ -3502,7 +3502,7 @@ random_pending_event_thread (inferior *inf, ptid_t waiton_ptid)\n       return nullptr;\n     }\n \n-  infrun_debug_printf (\"Found %s.\", target_pid_to_str (thread->ptid).c_str ());\n+  infrun_debug_printf (\"Found %s.\", thread->ptid.to_string ().c_str ());\n   gdb_assert (thread->resumed ());\n   gdb_assert (thread->has_pending_waitstatus ());\n \n@@ -3536,7 +3536,7 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n   else\n     {\n       infrun_debug_printf (\"Waiting for specific thread %s.\",\n-\t\t\t   target_pid_to_str (ptid).c_str ());\n+\t\t\t   ptid.to_string ().c_str ());\n \n       /* We have a specific thread to check.  */\n       tp = find_thread_ptid (inf, ptid);\n@@ -3559,15 +3559,15 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n       if (pc != tp->stop_pc ())\n \t{\n \t  infrun_debug_printf (\"PC of %s changed.  was=%s, now=%s\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t       tp->ptid.to_string ().c_str (),\n \t\t\t       paddress (gdbarch, tp->stop_pc ()),\n \t\t\t       paddress (gdbarch, pc));\n \t  discard = 1;\n \t}\n       else if (!breakpoint_inserted_here_p (regcache->aspace (), pc))\n \t{\n \t  infrun_debug_printf (\"previous breakpoint of %s, at %s gone\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t       tp->ptid.to_string ().c_str (),\n \t\t\t       paddress (gdbarch, pc));\n \n \t  discard = 1;\n@@ -3576,7 +3576,7 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n       if (discard)\n \t{\n \t  infrun_debug_printf (\"pending event of %s cancelled.\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \n \t  tp->clear_pending_waitstatus ();\n \t  target_waitstatus ws;\n@@ -3591,7 +3591,7 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n       infrun_debug_printf (\"Using pending wait status %s for %s.\",\n \t\t\t   target_waitstatus_to_string\n \t\t\t     (&tp->pending_waitstatus ()).c_str (),\n-\t\t\t   target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t   tp->ptid.to_string ().c_str ());\n \n       /* Now that we've selected our final event LWP, un-adjust its PC\n \t if it was a software breakpoint (and the target doesn't\n@@ -3775,7 +3775,7 @@ prepare_for_detach (void)\n     if (tp->inf == inf)\n       {\n \tinfrun_debug_printf (\"removing thread %s from global step over chain\",\n-\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t     tp->ptid.to_string ().c_str ());\n \tglobal_thread_step_over_chain_remove (tp);\n       }\n \n@@ -4249,8 +4249,8 @@ context_switch (execution_control_state *ecs)\n \t  || ecs->event_thread != inferior_thread ()))\n     {\n       infrun_debug_printf (\"Switching context from %s to %s\",\n-\t\t\t   target_pid_to_str (inferior_ptid).c_str (),\n-\t\t\t   target_pid_to_str (ecs->ptid).c_str ());\n+\t\t\t   inferior_ptid.to_string ().c_str (),\n+\t\t\t   ecs->ptid.to_string ().c_str ());\n     }\n \n   switch_to_thread (ecs->event_thread);\n@@ -4775,7 +4775,7 @@ handle_one (const wait_one_event &event)\n {\n   infrun_debug_printf\n     (\"%s %s\", target_waitstatus_to_string (&event.ws).c_str (),\n-     target_pid_to_str (event.ptid).c_str ());\n+     event.ptid.to_string ().c_str ());\n \n   if (event.ws.kind () == TARGET_WAITKIND_NO_RESUMED)\n     {\n@@ -4811,7 +4811,7 @@ handle_one (const wait_one_event &event)\n \t  gdb_assert (t != nullptr);\n \n \t  infrun_debug_printf\n-\t    (\"using %s\", target_pid_to_str (t->ptid).c_str ());\n+\t    (\"using %s\", t->ptid.to_string ().c_str ());\n \t}\n       else\n \t{\n@@ -4866,7 +4866,7 @@ handle_one (const wait_one_event &event)\n \t      /* Add it back to the step-over queue.  */\n \t      infrun_debug_printf\n \t\t(\"displaced-step of %s canceled\",\n-\t\t target_pid_to_str (t->ptid).c_str ());\n+\t\t t->ptid.to_string ().c_str ());\n \n \t      t->control.trap_expected = 0;\n \t      if (!t->inf->detaching)\n@@ -4904,7 +4904,7 @@ handle_one (const wait_one_event &event)\n \t  infrun_debug_printf (\"saved stop_pc=%s for %s \"\n \t\t\t       \"(currently_stepping=%d)\",\n \t\t\t       paddress (target_gdbarch (), t->stop_pc ()),\n-\t\t\t       target_pid_to_str (t->ptid).c_str (),\n+\t\t\t       t->ptid.to_string ().c_str (),\n \t\t\t       currently_stepping (t));\n \t}\n     }\n@@ -4989,14 +4989,14 @@ stop_all_threads (void)\n \t\t  if (!t->stop_requested)\n \t\t    {\n \t\t      infrun_debug_printf (\"  %s executing, need stop\",\n-\t\t\t\t\t   target_pid_to_str (t->ptid).c_str ());\n+\t\t\t\t\t   t->ptid.to_string ().c_str ());\n \t\t      target_stop (t->ptid);\n \t\t      t->stop_requested = 1;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      infrun_debug_printf (\"  %s executing, already stopping\",\n-\t\t\t\t\t   target_pid_to_str (t->ptid).c_str ());\n+\t\t\t\t\t   t->ptid.to_string ().c_str ());\n \t\t    }\n \n \t\t  if (t->stop_requested)\n@@ -5005,7 +5005,7 @@ stop_all_threads (void)\n \t      else\n \t\t{\n \t\t  infrun_debug_printf (\"  %s not executing\",\n-\t\t\t\t       target_pid_to_str (t->ptid).c_str ());\n+\t\t\t\t       t->ptid.to_string ().c_str ());\n \n \t\t  /* The thread may be not executing, but still be\n \t\t     resumed with a pending status to process.  */\n@@ -5728,7 +5728,7 @@ restart_threads (struct thread_info *event_thread)\n       if (tp->inf->detaching)\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] inferior detaching\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  continue;\n \t}\n \n@@ -5737,29 +5737,29 @@ restart_threads (struct thread_info *event_thread)\n       if (tp == event_thread)\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] is event thread\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  continue;\n \t}\n \n       if (!(tp->state == THREAD_RUNNING || tp->control.in_infcall))\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] not meant to be running\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  continue;\n \t}\n \n       if (tp->resumed ())\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] resumed\",\n-\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t      tp->ptid.to_string ().c_str ());\n \t  gdb_assert (tp->executing () || tp->has_pending_waitstatus ());\n \t  continue;\n \t}\n \n       if (thread_is_in_step_over_chain (tp))\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] needs step-over\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  gdb_assert (!tp->resumed ());\n \t  continue;\n \t}\n@@ -5768,7 +5768,7 @@ restart_threads (struct thread_info *event_thread)\n       if (tp->has_pending_waitstatus ())\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] has pending status\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  tp->set_resumed (true);\n \t  continue;\n \t}\n@@ -5783,13 +5783,13 @@ restart_threads (struct thread_info *event_thread)\n \t  internal_error (__FILE__, __LINE__,\n \t\t\t  \"thread [%s] needs a step-over, but not in \"\n \t\t\t  \"step-over queue\\n\",\n-\t\t\t  target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t  tp->ptid.to_string ().c_str ());\n \t}\n \n       if (currently_stepping (tp))\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] was stepping\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  keep_going_stepped_thread (tp);\n \t}\n       else\n@@ -5798,7 +5798,7 @@ restart_threads (struct thread_info *event_thread)\n \t  struct execution_control_state *ecs = &ecss;\n \n \t  infrun_debug_printf (\"restart threads: [%s] continuing\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  reset_ecs (ecs, tp);\n \t  switch_to_thread (tp);\n \t  keep_going_pass_signal (ecs);\n@@ -5907,7 +5907,7 @@ finish_step_over (struct execution_control_state *ecs)\n \t  infrun_debug_printf (\"saved stop_pc=%s for %s \"\n \t\t\t       \"(currently_stepping=%d)\",\n \t\t\t       paddress (target_gdbarch (), tp->stop_pc ()),\n-\t\t\t       target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t       tp->ptid.to_string ().c_str (),\n \t\t\t       currently_stepping (tp));\n \n \t  /* This in-line step-over finished; clear this so we won't\n@@ -6051,14 +6051,14 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t    {\n \t      infrun_debug_printf (\"[%s] hit another thread's single-step \"\n \t\t\t\t   \"breakpoint\",\n-\t\t\t\t   target_pid_to_str (ecs->ptid).c_str ());\n+\t\t\t\t   ecs->ptid.to_string ().c_str ());\n \t      ecs->hit_singlestep_breakpoint = 1;\n \t    }\n \t}\n       else\n \t{\n \t  infrun_debug_printf (\"[%s] hit its single-step breakpoint\",\n-\t\t\t       target_pid_to_str (ecs->ptid).c_str ());\n+\t\t\t       ecs->ptid.to_string ().c_str ());\n \t}\n     }\n   delete_just_stopped_threads_single_step_breakpoints ();\n@@ -7304,7 +7304,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t{\n \t  infrun_debug_printf\n \t    (\"need to finish step-over of [%s]\",\n-\t     target_pid_to_str (ecs->event_thread->ptid).c_str ());\n+\t     ecs->event_thread->ptid.to_string ().c_str ());\n \t  keep_going (ecs);\n \t  return true;\n \t}\n@@ -7314,7 +7314,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n       if (ecs->hit_singlestep_breakpoint)\n        {\n \t infrun_debug_printf (\"need to step [%s] over single-step breakpoint\",\n-\t\t\t      target_pid_to_str (ecs->ptid).c_str ());\n+\t\t\t      ecs->ptid.to_string ().c_str ());\n \t keep_going (ecs);\n \t return true;\n        }\n@@ -7326,7 +7326,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t{\n \t  infrun_debug_printf\n \t    (\"thread [%s] still needs step-over\",\n-\t     target_pid_to_str (ecs->event_thread->ptid).c_str ());\n+\t     ecs->event_thread->ptid.to_string ().c_str ());\n \t  keep_going (ecs);\n \t  return true;\n \t}\n@@ -7986,7 +7986,7 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \n       infrun_debug_printf (\"%s has trap_expected set, \"\n \t\t\t   \"resuming to collect trap\",\n-\t\t\t   target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t   tp->ptid.to_string ().c_str ());\n \n       /* We haven't yet gotten our trap, and either: intercepted a\n \t non-signal event (e.g., a fork); or took a signal which we\n@@ -8006,14 +8006,12 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \t{\n \t  infrun_debug_printf (\"step-over already in progress: \"\n \t\t\t       \"step-over for %s deferred\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t\t       tp->ptid.to_string ().c_str ());\n \t  global_thread_step_over_chain_enqueue (tp);\n \t}\n       else\n-\t{\n-\t  infrun_debug_printf (\"step-over in progress: resume of %s deferred\",\n-\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n-\t}\n+\tinfrun_debug_printf (\"step-over in progress: resume of %s deferred\",\n+\t\t\t     tp->ptid.to_string ().c_str ());\n     }\n   else\n     {"
    }
  ]
}