{
  "sha": "7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2E1ZjI5NGRiZDExYTY0ZjUyMzFmMGZlY2RiMTYzZTNjN2VjZmFmOA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-30T00:49:08Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-30T02:29:07Z"
    },
    "message": "Change how reprocessing is done\n\nCurrently gdb keeps a vector of attributes that require reprocessing.\nHowever, now that there is a reprocessing flag in the attribute, we\ncan remove the vector and instead simply loop over attributes a second\ntime.  Normally there are not many attributes, so this should be\nreasonably cheap.\n\ngdb/ChangeLog\n2020-09-29  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.c (skip_one_die): Update.\n\t(read_full_die_1): Change how reprocessing is done.\n\t(partial_die_info::read): Update.\n\t(read_attribute_value): Remove need_reprocess parameter.\n\t(read_attribute): Likewise.\n\t* dwarf2/attribute.h (struct attribute) <requires_reprocessing_p>:\n\tNew method.",
    "tree": {
      "sha": "bdfec01117869bfc6ff2f9ebf7041efc197aa5f7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bdfec01117869bfc6ff2f9ebf7041efc197aa5f7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "36d378cf86c7b4ed26f2a45cc1a4ea1a3802b4e1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/36d378cf86c7b4ed26f2a45cc1a4ea1a3802b4e1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/36d378cf86c7b4ed26f2a45cc1a4ea1a3802b4e1"
    }
  ],
  "stats": {
    "total": 79,
    "additions": 47,
    "deletions": 32
  },
  "files": [
    {
      "sha": "5418288e2772797619c4de48ffca080da27994fc",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8",
      "patch": "@@ -1,3 +1,13 @@\n+2020-09-29  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.c (skip_one_die): Update.\n+\t(read_full_die_1): Change how reprocessing is done.\n+\t(partial_die_info::read): Update.\n+\t(read_attribute_value): Remove need_reprocess parameter.\n+\t(read_attribute): Likewise.\n+\t* dwarf2/attribute.h (struct attribute) <requires_reprocessing_p>:\n+\tNew method.\n+\n 2020-09-29  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (read_attribute_reprocess, read_attribute_value)"
    },
    {
      "sha": "cb25208b5530a8b05f00483622068e9a6a932aa0",
      "filename": "gdb/dwarf2/attribute.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8/gdb/dwarf2/attribute.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8/gdb/dwarf2/attribute.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.h?ref=7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8",
      "patch": "@@ -235,6 +235,12 @@ struct attribute\n     requires_reprocessing = 0;\n   }\n \n+  /* True if this attribute requires reprocessing.  */\n+  bool requires_reprocessing_p () const\n+  {\n+    return requires_reprocessing;\n+  }\n+\n \n   ENUM_BITFIELD(dwarf_attribute) name : 15;\n "
    },
    {
      "sha": "0ce07dfa9a92c2a96e640af2ee7089b1d44f4e69",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 31,
      "deletions": 32,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=7a5f294dbd11a64f5231f0fecdb163e3c7ecfaf8",
      "patch": "@@ -1304,7 +1304,7 @@ static const struct cu_partial_die_info find_partial_die (sect_offset, int,\n \n static const gdb_byte *read_attribute (const struct die_reader_specs *,\n \t\t\t\t       struct attribute *, struct attr_abbrev *,\n-\t\t\t\t       const gdb_byte *, bool *need_reprocess);\n+\t\t\t\t       const gdb_byte *);\n \n static void read_attribute_reprocess (const struct die_reader_specs *reader,\n \t\t\t\t      struct attribute *attr, dwarf_tag tag);\n@@ -8861,9 +8861,7 @@ skip_one_die (const struct die_reader_specs *reader, const gdb_byte *info_ptr,\n       /* The only abbrev we care about is DW_AT_sibling.  */\n       if (abbrev->attrs[i].name == DW_AT_sibling)\n \t{\n-\t  bool ignored;\n-\t  read_attribute (reader, &attr, &abbrev->attrs[i], info_ptr,\n-\t\t\t  &ignored);\n+\t  read_attribute (reader, &attr, &abbrev->attrs[i], info_ptr);\n \t  if (attr.form == DW_FORM_ref_addr)\n \t    complaint (_(\"ignoring absolute DW_AT_sibling\"));\n \t  else\n@@ -18617,15 +18615,13 @@ read_full_die_1 (const struct die_reader_specs *reader,\n      attributes.  */\n   die->num_attrs = abbrev->num_attrs;\n \n-  std::vector<int> indexes_that_need_reprocess;\n+  bool any_need_reprocess = false;\n   for (i = 0; i < abbrev->num_attrs; ++i)\n     {\n-      bool need_reprocess;\n-      info_ptr =\n-        read_attribute (reader, &die->attrs[i], &abbrev->attrs[i],\n-\t\t\tinfo_ptr, &need_reprocess);\n-      if (need_reprocess)\n-        indexes_that_need_reprocess.push_back (i);\n+      info_ptr = read_attribute (reader, &die->attrs[i], &abbrev->attrs[i],\n+\t\t\t\t info_ptr);\n+      if (die->attrs[i].requires_reprocessing_p ())\n+\tany_need_reprocess = true;\n     }\n \n   struct attribute *attr = die->attr (DW_AT_str_offsets_base);\n@@ -18644,8 +18640,14 @@ read_full_die_1 (const struct die_reader_specs *reader,\n   if (attr != nullptr)\n     cu->ranges_base = DW_UNSND (attr);\n \n-  for (int index : indexes_that_need_reprocess)\n-    read_attribute_reprocess (reader, &die->attrs[index], die->tag);\n+  if (any_need_reprocess)\n+    {\n+      for (i = 0; i < abbrev->num_attrs; ++i)\n+\t{\n+\t  if (die->attrs[i].requires_reprocessing_p ())\n+\t    read_attribute_reprocess (reader, &die->attrs[i], die->tag);\n+\t}\n+    }\n   *diep = die;\n   return info_ptr;\n }\n@@ -19007,13 +19009,11 @@ partial_die_info::read (const struct die_reader_specs *reader,\n   for (i = 0; i < abbrev.num_attrs; ++i)\n     {\n       attribute attr;\n-      bool need_reprocess;\n-      info_ptr = read_attribute (reader, &attr, &abbrev.attrs[i],\n-\t\t\t\t info_ptr, &need_reprocess);\n+      info_ptr = read_attribute (reader, &attr, &abbrev.attrs[i], info_ptr);\n       /* String and address offsets that need to do the reprocessing have\n          already been read at this point, so there is no need to wait until\n \t the loop terminates to do the reprocessing.  */\n-      if (need_reprocess)\n+      if (attr.requires_reprocessing_p ())\n \tread_attribute_reprocess (reader, &attr, tag);\n       /* Store the data if it is of an attribute we want to keep in a\n          partial symbol table.  */\n@@ -19676,8 +19676,7 @@ read_attribute_reprocess (const struct die_reader_specs *reader,\n static const gdb_byte *\n read_attribute_value (const struct die_reader_specs *reader,\n \t\t      struct attribute *attr, unsigned form,\n-\t\t      LONGEST implicit_const, const gdb_byte *info_ptr,\n-\t\t      bool *need_reprocess)\n+\t\t      LONGEST implicit_const, const gdb_byte *info_ptr)\n {\n   struct dwarf2_cu *cu = reader->cu;\n   dwarf2_per_objfile *per_objfile = cu->per_objfile;\n@@ -19686,7 +19685,6 @@ read_attribute_value (const struct die_reader_specs *reader,\n   struct comp_unit_head *cu_header = &cu->header;\n   unsigned int bytes_read;\n   struct dwarf_block *blk;\n-  *need_reprocess = false;\n \n   attr->form = (enum dwarf_form) form;\n   switch (form)\n@@ -19756,9 +19754,9 @@ read_attribute_value (const struct die_reader_specs *reader,\n       break;\n     case DW_FORM_loclistx:\n       {\n-\t *need_reprocess = true;\n-\t DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);\n-\t info_ptr += bytes_read;\n+\tattr->set_unsigned_reprocess (read_unsigned_leb128 (abfd, info_ptr,\n+\t\t\t\t\t\t\t    &bytes_read));\n+\tinfo_ptr += bytes_read;\n       }\n       break;\n     case DW_FORM_string:\n@@ -19828,8 +19826,12 @@ read_attribute_value (const struct die_reader_specs *reader,\n       info_ptr += bytes_read;\n       break;\n     case DW_FORM_rnglistx:\n-      *need_reprocess = true;\n-      /* FALLTHROUGH */\n+      {\n+\tattr->set_unsigned_reprocess (read_unsigned_leb128 (abfd, info_ptr,\n+\t\t\t\t\t\t\t    &bytes_read));\n+\tinfo_ptr += bytes_read;\n+      }\n+      break;\n     case DW_FORM_udata:\n       attr->set_unsigned (read_unsigned_leb128 (abfd, info_ptr, &bytes_read));\n       info_ptr += bytes_read;\n@@ -19873,14 +19875,13 @@ read_attribute_value (const struct die_reader_specs *reader,\n \t  info_ptr += bytes_read;\n \t}\n       info_ptr = read_attribute_value (reader, attr, form, implicit_const,\n-\t\t\t\t       info_ptr, need_reprocess);\n+\t\t\t\t       info_ptr);\n       break;\n     case DW_FORM_implicit_const:\n       attr->set_signed (implicit_const);\n       break;\n     case DW_FORM_addrx:\n     case DW_FORM_GNU_addr_index:\n-      *need_reprocess = true;\n       attr->set_unsigned_reprocess (read_unsigned_leb128 (abfd, info_ptr,\n \t\t\t\t\t\t\t  &bytes_read));\n       info_ptr += bytes_read;\n@@ -19918,9 +19919,8 @@ read_attribute_value (const struct die_reader_specs *reader,\n \t    str_index = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);\n \t    info_ptr += bytes_read;\n \t  }\n-\t*need_reprocess = true;\n \tattr->set_unsigned_reprocess (str_index);\n-\t}\n+      }\n       break;\n     default:\n       error (_(\"Dwarf Error: Cannot handle %s in DWARF reader [in module %s]\"),\n@@ -19956,14 +19956,13 @@ read_attribute_value (const struct die_reader_specs *reader,\n static const gdb_byte *\n read_attribute (const struct die_reader_specs *reader,\n \t\tstruct attribute *attr, struct attr_abbrev *abbrev,\n-\t\tconst gdb_byte *info_ptr, bool *need_reprocess)\n+\t\tconst gdb_byte *info_ptr)\n {\n   attr->name = abbrev->name;\n   attr->string_is_canonical = 0;\n   attr->requires_reprocessing = 0;\n   return read_attribute_value (reader, attr, abbrev->form,\n-\t\t\t       abbrev->implicit_const, info_ptr,\n-\t\t\t       need_reprocess);\n+\t\t\t       abbrev->implicit_const, info_ptr);\n }\n \n /* Return pointer to string at .debug_str offset STR_OFFSET.  */"
    }
  ]
}