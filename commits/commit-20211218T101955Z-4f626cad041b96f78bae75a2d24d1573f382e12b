{
  "sha": "4f626cad041b96f78bae75a2d24d1573f382e12b",
  "node_id": "C_kwDOANOeidoAKDRmNjI2Y2FkMDQxYjk2Zjc4YmFlNzVhMmQyNGQxNTczZjM4MmUxMmI",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-17T17:17:37Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-18T10:19:55Z"
    },
    "message": "gdb/remote: some fixes for 'maint set target-async off'\n\nWhile working on another patch relating to remote targets, I wanted to\ntest with 'maint set target-async off' in place.  Unfortunately I ran\ninto some problems.  This commit is an attempt to fix one of the\nissues I hit.\n\nIn my particular case I was actually running with:\n\n  maint set target-async off\n  maint set target-non-stop off\n\nthat is, we're telling GDB to force the targets to operate in\nnon-async mode, and in all-stop mode.  Here's my GDB session showing\nthe problem:\n\n  (gdb) maintenance set target-async off\n  (gdb) maintenance set target-non-stop off\n  (gdb) target extended-remote :54321\n  Remote debugging using :54321\n  (gdb) attach 2365960\n  Attaching to process 2365960\n  No unwaited-for children left.\n  (gdb)\n\nNotice the 'No unwaited-for children left.' error, this is the\nproblem.  There's no reason why GDB should not be able to attach to\nthe process.\n\nThe problem is this:\n\n  1. The user runs 'attach PID' and this sends GDB into attach_command\n  in infcmd.c.  From here we call the ::attach method on the attach\n  target, which will be the extended_remote_target.\n\n  2. In extended_remote_target::attach, we attach to the remote target\n  and get the first reply (which is a stop packet).  We put off\n  processing the stop packet until the end of ::attach.  We setup the\n  inferior and thread to represent the process we attached to, and\n  download the target description.  Finally, we process the initial\n  stop packet.\n\n  If '!target_is_non_stop_p ()' and '!target_can_async_p ()', which is\n  the case for us given the maintenance commands we used, we cache the\n  stop packet within the remote_state::buf for later processing.\n\n  3. Back in attach_command, if 'target_is_non_stop_p ()' then we\n  request that the target stops.  This will either process any cached\n  stop replies, or request that the target stops, and process the stop\n  replies.  However, this code is not what we use due to non-stop mode\n  being disabled.  So, we skip to the next step which is to call\n  validate_exec_file.\n\n  4. Calling validate_exec_file can cause packets to be sent to the\n  remote target, and replies received, the first path I hit is the\n  call to target_pid_to_exec_file, which calls\n  remote_target::pid_to_exec_file, which can then try to read the\n  executable from the remote.  Sending an receiving packets will make\n  use of the remote_state::buf object.\n\n  5. The attempt to attach continues, but the damage is already done...\n\nSo, the problem is that, in step #2 we cache a stop reply in the\nremote_state::buf, and then in step #4 we reuse the remote_state::buf\nobject, discarding any cached stop reply.  As a result, the initial\nstop, which is sent when GDB first attaches to the target, is lost.\n\nThis problem can clearly be seen, I feel, by looking at the\nremote_state::cached_wait_status flag.  This flag tells GDB if there\nis a wait status cached in remote_state::buf.  However, in\nremote_target::putpkt_binary and remote_target::getpkt_or_notif_sane_1\nthis flag is just set back to 0, doing this immediately discards any\ncached data.\n\nI don't know if this scheme ever made sense,  looking at commit\n2d717e4f8a54, where the cached_wait_status flag was added, it appears\nthat there was nothing between where the stop was cached, and where\nthe stop was consumed, so, I suspect, there never was a situation\nwhere we ended up in putpkt_binary or getpkt_or_notif_sane_1 and\nneeded to clear to the flag, maybe the clearing was added \"just in\ncase\".  Whatever the history, I claim that this clearing this flag is\nno longer a good idea.\n\nSo, my first step toward fixing this issue was to replace the two\ninstances of 'rs->cached_wait_status = 0;' in ::putpkt_binary and\n::getpkt_or_notif_sane_1 with 'gdb_assert (rs->cached_wait_status ==\n0);', this, at least would show me when GDB was doing something\ndangerous, and indeed, this assert is now hit in my test case above.\n\nI did play with using some kind of scoped restore to backup, and\nrestore the remote_state::buf object in all the places within remote.c\nthat I was hitting where the ::buf was being corrupted.  The first\nproblem with this is that, where the ::cached_wait_status flag is\nreset is _not_ where ::buf is corrupted.  For the ::putpkt_binary\ncase, by the time we get to the method the buffer has already been\ncorrupted in many cases, so we end up needing to add the scoped\nsave/restore within the callers, which means we need the save/restore\nin _lots_ of places.\n\nPlus, using this save/restore model feels like the wrong solution.  I\ndon't think that it's obvious that the buffer might be holding cached\ndata, and I think it would be too easy for new corruptions of the\nbuffer to be introduced, which could easily go unnoticed for a long\ntime.\n\nSo, I really wanted a solution that didn't require us to cache data in\nthe ::buf object.\n\nLuckily, I think we already have such a solution in place, the\nremote_state::stop_reply_queue, it seems like this does exactly the\nsame task, just in a slightly different way.  With the\n::stop_reply_queue, the stop packets are processed upon receipt and\nthe stop_reply object is added to the queue.  With the ::buf cache\nsolution, the unprocessed stop reply is cached in the ::buf, and\nprocessed later.\n\nSo, finally, in this commit, I propose to remove the\nremote_state::cached_wait_status flag and to stop using the ::buf to\ncache stop replies.  Instead, stop replies will now always be stored\nin the ::stop_reply_queue.\n\nThere are two places where we use the ::buf to hold a cached stop\nreply, the first is in the ::attach method, and the second is in\nremote_target::start_remote, however, the second of these cases is far\nless problematic, as after caching the stop reply in ::buf we call the\nglobal start_remote function, which does very little work before\ncalling normal_stop, which processes the cached stop reply.  However,\nmy plan is to switch both users over to using ::stop_reply_queue so\nthat the old (unsafe) ::cached_wait_status mechanism can be completely\nremoved.\n\nThe next problem is that the ::stop_reply_queue is currently only used\nfor async-mode, and so, in remote_target::push_stop_reply, where we\npush stop_reply objects into the ::stop_reply_queue, we currently also\nmark the async event token.  I've modified this so we only mark the\nasync event token if 'target_is_async_p ()' - note, _is_, not _can_\nhere. The ::push_stop_reply method is called in places where async\nmode has been temporarily disabled, but, when async mode is switched\nback on (see remote_target::async) we will mark the event token if\nthere are events in the queue.\n\nAnother change of interest is in remote_target::remote_interrupt_as.\nPreviously this code checked ::cached_wait_status, but didn't check\nfor events in the ::stop_reply_queue.  Now that ::cached_wait_status\nhas been removed we now check the queue length instead, which should\nhave the same result.\n\nFinally, in remote_target::wait_as, I've tried to merge the processing\nof the ::stop_reply_queue with how we used to handle the\n::cached_wait_status flag.\n\nCurrently, when processing the ::stop_reply_queue we call\nprocess_stop_reply and immediately return.  However, when handling\n::cached_wait_status we run through the whole of ::wait_as, and return\nat the end of the function.\n\nIf we consider a standard stop packet, the two differences I see are:\n\n  1. Resetting of the remote_state::waiting_for_stop_reply, flag; this\n  is not currently done when processing a stop from the\n  ::stop_reply_queue.\n\n  2. The final return value has the possibility of being adjusted at\n  the end of ::wait_as, as well as there being calls to\n  record_currthread, non of which are done if we process a stop from\n  the ::stop_reply_queue.\n\nAfter discussion on the mailing list:\n\n  https://sourceware.org/pipermail/gdb-patches/2021-December/184535.html\n\nit was suggested that, when an event is pushed into the\n::stop_reply_queue, the ::waiting_for_stop_reply flag is never going\nto be set.  As a result, we don't need to worry about the first\ndifference.  I have however, added a gdb_assert to validate the\nassumption that the flag is never going to be set.  If in future the\nsituation ever changes, then we should find out pretty quickly.\n\nAs for the second difference, I have resolved this by having all stop\npackets taken from the ::stop_reply_queue, pass through the return\nvalue adjustment code at the end of ::wait_as.\n\nAn example of a test that reveals the benefits of this commit is:\n\n  make check-gdb \\\n    RUNTESTFLAGS=\"--target_board=native-extended-gdbserver \\\n                  GDBFLAGS='-ex maint\\ set\\ target-async\\ off \\\n                            -ex maint\\ set\\ target-non-stop\\ off' \\\n                  gdb.base/attach.exp\"\n\nFor testing I've been running test on x86-64/GNU Linux, and run with\ntarget boards unix, native-gdbserver, and native-extended-gdbserver.\nFor each board I've run with the default GDBFLAGS, as well as with:\n\n  GDBFLAGS='-ex maint\\ set\\ target-async\\ off \\\n            -ex maint\\ set\\ target-non-stop\\ off' \\\n\nThough running with the above GDBFLAGS is clearly a lot more unstable\nboth before and after my patch, I'm not seeing any consistent new\nfailures with my patch, except, with the native-extended-gdbserver\nboard, where I am seeing new failures, but only because more tests are\nnow running.  For that configuration alone I see the number of\nunresolved go down by 49, the number of passes goes up by 446, and the\nnumber of failures also increases by 144.  All of the failures are new\ntests as far as I can tell.",
    "tree": {
      "sha": "5d078cafc68e69389eb9a6e94656ad8689785482",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5d078cafc68e69389eb9a6e94656ad8689785482"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4f626cad041b96f78bae75a2d24d1573f382e12b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4f626cad041b96f78bae75a2d24d1573f382e12b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4f626cad041b96f78bae75a2d24d1573f382e12b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4f626cad041b96f78bae75a2d24d1573f382e12b/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "9833dd97678ef5e369ff6a5eb7b508179bc038f7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9833dd97678ef5e369ff6a5eb7b508179bc038f7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9833dd97678ef5e369ff6a5eb7b508179bc038f7"
    }
  ],
  "stats": {
    "total": 188,
    "additions": 84,
    "deletions": 104
  },
  "files": [
    {
      "sha": "f0f3dcbabb000abe656c12da042f07064c600bc1",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 84,
      "deletions": 104,
      "changes": 188,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4f626cad041b96f78bae75a2d24d1573f382e12b/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4f626cad041b96f78bae75a2d24d1573f382e12b/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=4f626cad041b96f78bae75a2d24d1573f382e12b",
      "patch": "@@ -258,15 +258,6 @@ class remote_state\n      Otherwise zero, meaning to use the guessed size.  */\n   long explicit_packet_size = 0;\n \n-  /* remote_wait is normally called when the target is running and\n-     waits for a stop reply packet.  But sometimes we need to call it\n-     when the target is already stopped.  We can send a \"?\" packet\n-     and have remote_wait read the response.  Or, if we already have\n-     the response, we can stash it in BUF and tell remote_wait to\n-     skip calling getpkt.  This flag is set when BUF contains a\n-     stop reply packet and the target is not waiting.  */\n-  int cached_wait_status = 0;\n-\n   /* True, if in no ack mode.  That is, neither GDB nor the stub will\n      expect acks from each other.  The connection is assumed to be\n      reliable.  */\n@@ -4969,8 +4960,9 @@ remote_target::start_remote_1 (int from_tty, int extended_p)\n \n       /* Use the previously fetched status.  */\n       gdb_assert (wait_status != NULL);\n-      strcpy (rs->buf.data (), wait_status);\n-      rs->cached_wait_status = 1;\n+      struct notif_event *reply\n+\t= remote_notif_parse (this, &notif_client_stop, wait_status);\n+      push_stop_reply ((struct stop_reply *) reply);\n \n       ::start_remote (from_tty); /* Initialize gdb process mechanisms.  */\n     }\n@@ -5804,7 +5796,6 @@ remote_target::open_1 (const char *name, int from_tty, int extended_p)\n   /* Reset the target state; these things will be queried either by\n      remote_query_supported or as they are needed.  */\n   reset_all_packet_configs_support ();\n-  rs->cached_wait_status = 0;\n   rs->explicit_packet_size = 0;\n   rs->noack_mode = 0;\n   rs->extended = extended_p;\n@@ -6199,21 +6190,13 @@ extended_remote_target::attach (const char *args, int from_tty)\n       /* Use the previously fetched status.  */\n       gdb_assert (wait_status != NULL);\n \n-      if (target_can_async_p ())\n-\t{\n-\t  struct notif_event *reply\n-\t    =  remote_notif_parse (this, &notif_client_stop, wait_status);\n+      struct notif_event *reply\n+\t=  remote_notif_parse (this, &notif_client_stop, wait_status);\n \n-\t  push_stop_reply ((struct stop_reply *) reply);\n+      push_stop_reply ((struct stop_reply *) reply);\n \n-\t  target_async (1);\n-\t}\n-      else\n-\t{\n-\t  gdb_assert (wait_status != NULL);\n-\t  strcpy (rs->buf.data (), wait_status);\n-\t  rs->cached_wait_status = 1;\n-\t}\n+      if (target_can_async_p ())\n+\ttarget_async (1);\n     }\n   else\n     {\n@@ -7084,9 +7067,9 @@ remote_target::remote_interrupt_as ()\n   rs->ctrlc_pending_p = 1;\n \n   /* If the inferior is stopped already, but the core didn't know\n-     about it yet, just ignore the request.  The cached wait status\n+     about it yet, just ignore the request.  The pending stop events\n      will be collected in remote_wait.  */\n-  if (rs->cached_wait_status)\n+  if (stop_reply_queue_length () > 0)\n     return;\n \n   /* Send interrupt_sequence to remote target.  */\n@@ -7480,7 +7463,7 @@ remote_target::queued_stop_reply (ptid_t ptid)\n   remote_state *rs = get_remote_state ();\n   struct stop_reply *r = remote_notif_remove_queued_reply (ptid);\n \n-  if (!rs->stop_reply_queue.empty ())\n+  if (!rs->stop_reply_queue.empty () && target_can_async_p ())\n     {\n       /* There's still at least an event left.  */\n       mark_async_event_handler (rs->remote_async_inferior_event_token);\n@@ -7505,7 +7488,12 @@ remote_target::push_stop_reply (struct stop_reply *new_event)\n \t\t\ttarget_pid_to_str (new_event->ptid).c_str (),\n \t\t\tint (rs->stop_reply_queue.size ()));\n \n-  mark_async_event_handler (rs->remote_async_inferior_event_token);\n+  /* Mark the pending event queue only if async mode is currently enabled.\n+     If async mode is not currently enabled, then, if it later becomes\n+     enabled, and there are events in this queue, we will mark the event\n+     token at that point, see remote_target::async.  */\n+  if (target_is_async_p ())\n+    mark_async_event_handler (rs->remote_async_inferior_event_token);\n }\n \n /* Returns true if we have a stop reply for PTID.  */\n@@ -8214,15 +8202,14 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status,\n \n   stop_reply = queued_stop_reply (ptid);\n   if (stop_reply != NULL)\n-    return process_stop_reply (stop_reply, status);\n-\n-  if (rs->cached_wait_status)\n-    /* Use the cached wait status, but only once.  */\n-    rs->cached_wait_status = 0;\n+    {\n+      /* None of the paths that push a stop reply onto the queue should\n+\t have set the waiting_for_stop_reply flag.  */\n+      gdb_assert (!rs->waiting_for_stop_reply);\n+      event_ptid = process_stop_reply (stop_reply, status);\n+    }\n   else\n     {\n-      int ret;\n-      int is_notif;\n       int forever = ((options & TARGET_WNOHANG) == 0\n \t\t     && rs->wait_forever_enabled_p);\n \n@@ -8236,7 +8223,8 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status,\n \t _never_ wait for ever -> test on target_is_async_p().\n \t However, before we do that we need to ensure that the caller\n \t knows how to take the target into/out of async mode.  */\n-      ret = getpkt_or_notif_sane (&rs->buf, forever, &is_notif);\n+      int is_notif;\n+      int ret = getpkt_or_notif_sane (&rs->buf, forever, &is_notif);\n \n       /* GDB gets a notification.  Return to core as this event is\n \t not interesting.  */\n@@ -8245,73 +8233,73 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status,\n \n       if (ret == -1 && (options & TARGET_WNOHANG) != 0)\n \treturn minus_one_ptid;\n-    }\n \n-  buf = rs->buf.data ();\n+      buf = rs->buf.data ();\n \n-  /* Assume that the target has acknowledged Ctrl-C unless we receive\n-     an 'F' or 'O' packet.  */\n-  if (buf[0] != 'F' && buf[0] != 'O')\n-    rs->ctrlc_pending_p = 0;\n+      /* Assume that the target has acknowledged Ctrl-C unless we receive\n+\t an 'F' or 'O' packet.  */\n+      if (buf[0] != 'F' && buf[0] != 'O')\n+\trs->ctrlc_pending_p = 0;\n \n-  switch (buf[0])\n-    {\n-    case 'E':\t\t/* Error of some sort.\t*/\n-      /* We're out of sync with the target now.  Did it continue or\n-\t not?  Not is more likely, so report a stop.  */\n-      rs->waiting_for_stop_reply = 0;\n+      switch (buf[0])\n+\t{\n+\tcase 'E':\t\t/* Error of some sort.\t*/\n+\t  /* We're out of sync with the target now.  Did it continue or\n+\t     not?  Not is more likely, so report a stop.  */\n+\t  rs->waiting_for_stop_reply = 0;\n \n-      warning (_(\"Remote failure reply: %s\"), buf);\n-      status->set_stopped (GDB_SIGNAL_0);\n-      break;\n-    case 'F':\t\t/* File-I/O request.  */\n-      /* GDB may access the inferior memory while handling the File-I/O\n-\t request, but we don't want GDB accessing memory while waiting\n-\t for a stop reply.  See the comments in putpkt_binary.  Set\n-\t waiting_for_stop_reply to 0 temporarily.  */\n-      rs->waiting_for_stop_reply = 0;\n-      remote_fileio_request (this, buf, rs->ctrlc_pending_p);\n-      rs->ctrlc_pending_p = 0;\n-      /* GDB handled the File-I/O request, and the target is running\n-\t again.  Keep waiting for events.  */\n-      rs->waiting_for_stop_reply = 1;\n-      break;\n-    case 'N': case 'T': case 'S': case 'X': case 'W':\n-      {\n-\t/* There is a stop reply to handle.  */\n-\trs->waiting_for_stop_reply = 0;\n+\t  warning (_(\"Remote failure reply: %s\"), buf);\n+\t  status->set_stopped (GDB_SIGNAL_0);\n+\t  break;\n+\tcase 'F':\t\t/* File-I/O request.  */\n+\t  /* GDB may access the inferior memory while handling the File-I/O\n+\t     request, but we don't want GDB accessing memory while waiting\n+\t     for a stop reply.  See the comments in putpkt_binary.  Set\n+\t     waiting_for_stop_reply to 0 temporarily.  */\n+\t  rs->waiting_for_stop_reply = 0;\n+\t  remote_fileio_request (this, buf, rs->ctrlc_pending_p);\n+\t  rs->ctrlc_pending_p = 0;\n+\t  /* GDB handled the File-I/O request, and the target is running\n+\t     again.  Keep waiting for events.  */\n+\t  rs->waiting_for_stop_reply = 1;\n+\t  break;\n+\tcase 'N': case 'T': case 'S': case 'X': case 'W':\n+\t  {\n+\t    /* There is a stop reply to handle.  */\n+\t    rs->waiting_for_stop_reply = 0;\n \n-\tstop_reply\n-\t  = (struct stop_reply *) remote_notif_parse (this,\n-\t\t\t\t\t\t      &notif_client_stop,\n-\t\t\t\t\t\t      rs->buf.data ());\n+\t    stop_reply\n+\t      = (struct stop_reply *) remote_notif_parse (this,\n+\t\t\t\t\t\t\t  &notif_client_stop,\n+\t\t\t\t\t\t\t  rs->buf.data ());\n \n-\tevent_ptid = process_stop_reply (stop_reply, status);\n-\tbreak;\n-      }\n-    case 'O':\t\t/* Console output.  */\n-      remote_console_output (buf + 1);\n-      break;\n-    case '\\0':\n-      if (rs->last_sent_signal != GDB_SIGNAL_0)\n-\t{\n-\t  /* Zero length reply means that we tried 'S' or 'C' and the\n-\t     remote system doesn't support it.  */\n-\t  target_terminal::ours_for_output ();\n-\t  printf_filtered\n-\t    (\"Can't send signals to this remote system.  %s not sent.\\n\",\n-\t     gdb_signal_to_name (rs->last_sent_signal));\n-\t  rs->last_sent_signal = GDB_SIGNAL_0;\n-\t  target_terminal::inferior ();\n-\n-\t  strcpy (buf, rs->last_sent_step ? \"s\" : \"c\");\n-\t  putpkt (buf);\n+\t    event_ptid = process_stop_reply (stop_reply, status);\n+\t    break;\n+\t  }\n+\tcase 'O':\t\t/* Console output.  */\n+\t  remote_console_output (buf + 1);\n+\t  break;\n+\tcase '\\0':\n+\t  if (rs->last_sent_signal != GDB_SIGNAL_0)\n+\t    {\n+\t      /* Zero length reply means that we tried 'S' or 'C' and the\n+\t\t remote system doesn't support it.  */\n+\t      target_terminal::ours_for_output ();\n+\t      printf_filtered\n+\t\t(\"Can't send signals to this remote system.  %s not sent.\\n\",\n+\t\t gdb_signal_to_name (rs->last_sent_signal));\n+\t      rs->last_sent_signal = GDB_SIGNAL_0;\n+\t      target_terminal::inferior ();\n+\n+\t      strcpy (buf, rs->last_sent_step ? \"s\" : \"c\");\n+\t      putpkt (buf);\n+\t      break;\n+\t    }\n+\t  /* fallthrough */\n+\tdefault:\n+\t  warning (_(\"Invalid remote reply: %s\"), buf);\n \t  break;\n \t}\n-      /* fallthrough */\n-    default:\n-      warning (_(\"Invalid remote reply: %s\"), buf);\n-      break;\n     }\n \n   if (status->kind () == TARGET_WAITKIND_NO_RESUMED)\n@@ -9596,10 +9584,6 @@ remote_target::putpkt_binary (const char *buf, int cnt)\n \t       \"and then try again.\"));\n     }\n \n-  /* We're sending out a new packet.  Make sure we don't look at a\n-     stale cached response.  */\n-  rs->cached_wait_status = 0;\n-\n   /* Copy the packet into buffer BUF2, encapsulating it\n      and giving it a checksum.  */\n \n@@ -9937,10 +9921,6 @@ remote_target::getpkt_or_notif_sane_1 (gdb::char_vector *buf,\n   int timeout;\n   int val = -1;\n \n-  /* We're reading a new response.  Make sure we don't look at a\n-     previously cached response.  */\n-  rs->cached_wait_status = 0;\n-\n   strcpy (buf->data (), \"timeout\");\n \n   if (forever)"
    }
  ]
}