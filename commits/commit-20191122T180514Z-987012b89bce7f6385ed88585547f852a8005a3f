{
  "sha": "987012b89bce7f6385ed88585547f852a8005a3f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTg3MDEyYjg5YmNlN2Y2Mzg1ZWQ4ODU4NTU0N2Y4NTJhODAwNWEzZg==",
  "commit": {
    "author": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-11-22T18:05:14Z"
    },
    "committer": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-11-22T18:05:14Z"
    },
    "message": "Replace SYMBOL_*_NAME accessors with member functions\n\nSimilar to the MSYMBOL version of this patch, improves readability\nand will eventually allow making name private.\n\ngdb/ChangeLog:\n\n2019-11-22  Christian Biesinger  <cbiesinger@google.com>\n\n\t* ada-exp.y: Update.\n\t* ada-lang.c (sort_choices): Update.\n\t(ada_print_symbol_signature): Update.\n\t(resolve_subexp): Update.\n\t(ada_parse_renaming): Update.\n\t(ada_read_renaming_var_value): Update.\n\t(lesseq_defined_than): Update.\n\t(remove_extra_symbols): Update.\n\t(remove_irrelevant_renamings): Update.\n\t(ada_add_block_symbols): Update.\n\t(ada_collect_symbol_completion_matches): Update.\n\t(ada_is_renaming_symbol): Update.\n\t(aggregate_assign_from_choices): Update.\n\t(ada_evaluate_subexp): Update.\n\t(ada_has_this_exception_support): Update.\n\t(ada_is_non_standard_exception_sym): Update.\n\t(ada_add_exceptions_from_frame): Update.\n\t(ada_add_global_exceptions): Update.\n\t(ada_print_subexp): Update.\n\t* ax-gdb.c (gen_var_ref): Update.\n\t(gen_maybe_namespace_elt): Update.\n\t(gen_expr_for_cast): Update.\n\t(gen_expr): Update.\n\t* block.h: Update.\n\t* blockframe.c (find_pc_partial_function): Update.\n\t* breakpoint.c (print_breakpoint_location): Update.\n\t(update_static_tracepoint): Update.\n\t* btrace.c (ftrace_print_function_name): Update.\n\t(ftrace_function_switched): Update.\n\t* buildsym.c (find_symbol_in_list): Update.\n\t* c-exp.y: Update.\n\t* c-typeprint.c (c_print_typedef): Update.\n\t(c_type_print_template_args): Update.\n\t* cli/cli-cmds.c (edit_command): Update.\n\t(list_command): Update.\n\t(print_sal_location): Update.\n\t* coffread.c (patch_opaque_types): Update.\n\t(process_coff_symbol): Update.\n\t(coff_read_enum_type): Update.\n\t* compile/compile-c-symbols.c (c_symbol_substitution_name): Update.\n\t(convert_one_symbol): Update.\n\t(hash_symname): Update.\n\t(eq_symname): Update.\n\t* compile/compile-cplus-symbols.c (convert_one_symbol): Update.\n\t* compile/compile-cplus-types.c (debug_print_scope): Update.\n\t* compile/compile-loc2c.c (do_compile_dwarf_expr_to_c): Update.\n\t* compile/compile-object-load.c (get_out_value_type): Update.\n\t* cp-namespace.c (cp_scan_for_anonymous_namespaces): Update.\n\t(search_symbol_list): Update.\n\t(cp_lookup_symbol_imports_or_template): Update.\n\t* cp-support.c (overload_list_add_symbol): Update.\n\t* ctfread.c (psymtab_to_symtab): Update.\n\t* dbxread.c (cp_set_block_scope): Update.\n\t* dictionary.c (iter_match_first_hashed): Update.\n\t(iter_match_next_hashed): Update.\n\t(insert_symbol_hashed): Update.\n\t(iter_match_next_linear): Update.\n\t* dictionary.h: Update.\n\t* dwarf2loc.c (func_get_frame_base_dwarf_block): Update.\n\t(locexpr_describe_location_piece): Update.\n\t(locexpr_describe_location_1): Update.\n\t(locexpr_generate_c_location): Update.\n\t(loclist_describe_location): Update.\n\t(loclist_generate_c_location): Update.\n\t* dwarf2read.c (dw2_debug_names_lookup_symbol): Update.\n\t(read_func_scope): Update.\n\t(process_enumeration_scope): Update.\n\t(new_symbol): Update.\n\t(dwarf2_const_value): Update.\n\t(dwarf2_symbol_mark_computed): Update.\n\t* eval.c (evaluate_funcall): Update.\n\t(evaluate_subexp_standard): Update.\n\t* expprint.c (print_subexp_standard): Update.\n\t(dump_subexp_body_standard): Update.\n\t* f-valprint.c (info_common_command_for_block): Update.\n\t* findvar.c (get_hosting_frame): Update.\n\t(default_read_var_value): Update.\n\t* go-lang.c (go_symbol_package_name): Update.\n\t* guile/scm-block.c (bkscm_print_block_smob): Update.\n\t* guile/scm-symbol.c (syscm_print_symbol_smob): Update.\n\t(gdbscm_symbol_name): Update.\n\t(gdbscm_symbol_linkage_name): Update.\n\t(gdbscm_symbol_print_name): Update.\n\t* infcall.c (get_function_name): Update.\n\t* infcmd.c (jump_command): Update.\n\t(finish_command): Update.\n\t* infrun.c (insert_exception_resume_breakpoint): Update.\n\t* linespec.c (canonicalize_linespec): Update.\n\t(create_sals_line_offset): Update.\n\t(convert_linespec_to_sals): Update.\n\t(complete_label): Update.\n\t(find_label_symbols_in_block): Update.\n\t* m2-typeprint.c (m2_print_typedef): Update.\n\t* mdebugread.c (mdebug_reg_to_regnum): Update.\n\t(parse_symbol): Update.\n\t(mylookup_symbol): Update.\n\t* mi/mi-cmd-stack.c (list_arg_or_local): Update.\n\t(list_args_or_locals): Update.\n\t* objc-lang.c (compare_selectors): Update.\n\t(info_selectors_command): Update.\n\t(compare_classes): Update.\n\t(info_classes_command): Update.\n\t(find_imps): Update.\n\t* p-typeprint.c (pascal_print_typedef): Update.\n\t* printcmd.c (build_address_symbolic): Update.\n\t(info_address_command): Update.\n\t(print_variable_and_value): Update.\n\t* python/py-framefilter.c (extract_sym): Update.\n\t(py_print_single_arg): Update.\n\t* python/py-symbol.c (sympy_str): Update.\n\t(sympy_get_name): Update.\n\t(sympy_get_linkage_name): Update.\n\t* python/python.c (gdbpy_rbreak): Update.\n\t* record-btrace.c (btrace_get_bfun_name): Update.\n\t(btrace_call_history): Update.\n\t* rust-lang.c (rust_print_typedef): Update.\n\t* solib-frv.c (frv_fdpic_find_canonical_descriptor): Update.\n\t* stabsread.c (stab_reg_to_regnum): Update.\n\t(define_symbol): Update.\n\t(read_enum_type): Update.\n\t(common_block_end): Update.\n\t(cleanup_undefined_types_1): Update.\n\t(scan_file_globals): Update.\n\t* stack.c (print_frame_arg): Update.\n\t(print_frame_args): Update.\n\t(find_frame_funname): Update.\n\t(info_frame_command_core): Update.\n\t(iterate_over_block_locals): Update.\n\t(print_block_frame_labels): Update.\n\t(do_print_variable_and_value): Update.\n\t(iterate_over_block_arg_vars): Update.\n\t(return_command): Update.\n\t* symmisc.c (dump_symtab_1): Update.\n\t(print_symbol): Update.\n\t* symtab.c (eq_symbol_entry): Update.\n\t(symbol_cache_dump): Update.\n\t(lookup_language_this): Update.\n\t(find_pc_sect_line): Update.\n\t(skip_prologue_sal): Update.\n\t(symbol_search::compare_search_syms): Update.\n\t(treg_matches_sym_type_name): Update.\n\t(search_symbols): Update.\n\t(print_symbol_info): Update.\n\t(rbreak_command): Update.\n\t(completion_list_add_symbol): Update.\n\t(find_gnu_ifunc): Update.\n\t(get_symbol_address): Update.\n\t(search_module_symbols): Update.\n\t(info_module_subcommand): Update.\n\t* symtab.h (SYMBOL_NATURAL_NAME): Remove.\n\t(SYMBOL_LINKAGE_NAME): Remove.\n\t(SYMBOL_DEMANGLED_NAME): Remove.\n\t(SYMBOL_PRINT_NAME): Remove.\n\t(SYMBOL_SEARCH_NAME): Remove.\n\t* tracepoint.c (set_traceframe_context): Update.\n\t(validate_actionline): Update.\n\t(collection_list::collect_symbol): Update.\n\t(encode_actions_1): Update.\n\t(info_scope_command): Update.\n\t(print_one_static_tracepoint_marker): Update.\n\t* typeprint.c (typedef_hash_table::add_template_parameters): Update.\n\t* valops.c (address_of_variable): Update.\n\t(find_overload_match): Update.\n\t(find_oload_champ): Update.\n\nChange-Id: I76bdc8b44eea6876bf03af9d351f8e90cc0154b2",
    "tree": {
      "sha": "df68767bc0b073a1e0eb95ba58ba2077fdde83b3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/df68767bc0b073a1e0eb95ba58ba2077fdde83b3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/987012b89bce7f6385ed88585547f852a8005a3f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/987012b89bce7f6385ed88585547f852a8005a3f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/987012b89bce7f6385ed88585547f852a8005a3f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/987012b89bce7f6385ed88585547f852a8005a3f/comments",
  "author": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c9d95fa3d034ae614e33b631e0bc019015c444e9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c9d95fa3d034ae614e33b631e0bc019015c444e9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c9d95fa3d034ae614e33b631e0bc019015c444e9"
    }
  ],
  "stats": {
    "total": 857,
    "additions": 481,
    "deletions": 376
  },
  "files": [
    {
      "sha": "5dd8d4281436a9a634aa87f4de3e357187042753",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 167,
      "deletions": 0,
      "changes": 167,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1,3 +1,170 @@\n+2019-11-22  Christian Biesinger  <cbiesinger@google.com>\n+\n+\t* ada-exp.y: Update.\n+\t* ada-lang.c (sort_choices): Update.\n+\t(ada_print_symbol_signature): Update.\n+\t(resolve_subexp): Update.\n+\t(ada_parse_renaming): Update.\n+\t(ada_read_renaming_var_value): Update.\n+\t(lesseq_defined_than): Update.\n+\t(remove_extra_symbols): Update.\n+\t(remove_irrelevant_renamings): Update.\n+\t(ada_add_block_symbols): Update.\n+\t(ada_collect_symbol_completion_matches): Update.\n+\t(ada_is_renaming_symbol): Update.\n+\t(aggregate_assign_from_choices): Update.\n+\t(ada_evaluate_subexp): Update.\n+\t(ada_has_this_exception_support): Update.\n+\t(ada_is_non_standard_exception_sym): Update.\n+\t(ada_add_exceptions_from_frame): Update.\n+\t(ada_add_global_exceptions): Update.\n+\t(ada_print_subexp): Update.\n+\t* ax-gdb.c (gen_var_ref): Update.\n+\t(gen_maybe_namespace_elt): Update.\n+\t(gen_expr_for_cast): Update.\n+\t(gen_expr): Update.\n+\t* block.h: Update.\n+\t* blockframe.c (find_pc_partial_function): Update.\n+\t* breakpoint.c (print_breakpoint_location): Update.\n+\t(update_static_tracepoint): Update.\n+\t* btrace.c (ftrace_print_function_name): Update.\n+\t(ftrace_function_switched): Update.\n+\t* buildsym.c (find_symbol_in_list): Update.\n+\t* c-exp.y: Update.\n+\t* c-typeprint.c (c_print_typedef): Update.\n+\t(c_type_print_template_args): Update.\n+\t* cli/cli-cmds.c (edit_command): Update.\n+\t(list_command): Update.\n+\t(print_sal_location): Update.\n+\t* coffread.c (patch_opaque_types): Update.\n+\t(process_coff_symbol): Update.\n+\t(coff_read_enum_type): Update.\n+\t* compile/compile-c-symbols.c (c_symbol_substitution_name): Update.\n+\t(convert_one_symbol): Update.\n+\t(hash_symname): Update.\n+\t(eq_symname): Update.\n+\t* compile/compile-cplus-symbols.c (convert_one_symbol): Update.\n+\t* compile/compile-cplus-types.c (debug_print_scope): Update.\n+\t* compile/compile-loc2c.c (do_compile_dwarf_expr_to_c): Update.\n+\t* compile/compile-object-load.c (get_out_value_type): Update.\n+\t* cp-namespace.c (cp_scan_for_anonymous_namespaces): Update.\n+\t(search_symbol_list): Update.\n+\t(cp_lookup_symbol_imports_or_template): Update.\n+\t* cp-support.c (overload_list_add_symbol): Update.\n+\t* ctfread.c (psymtab_to_symtab): Update.\n+\t* dbxread.c (cp_set_block_scope): Update.\n+\t* dictionary.c (iter_match_first_hashed): Update.\n+\t(iter_match_next_hashed): Update.\n+\t(insert_symbol_hashed): Update.\n+\t(iter_match_next_linear): Update.\n+\t* dictionary.h: Update.\n+\t* dwarf2loc.c (func_get_frame_base_dwarf_block): Update.\n+\t(locexpr_describe_location_piece): Update.\n+\t(locexpr_describe_location_1): Update.\n+\t(locexpr_generate_c_location): Update.\n+\t(loclist_describe_location): Update.\n+\t(loclist_generate_c_location): Update.\n+\t* dwarf2read.c (dw2_debug_names_lookup_symbol): Update.\n+\t(read_func_scope): Update.\n+\t(process_enumeration_scope): Update.\n+\t(new_symbol): Update.\n+\t(dwarf2_const_value): Update.\n+\t(dwarf2_symbol_mark_computed): Update.\n+\t* eval.c (evaluate_funcall): Update.\n+\t(evaluate_subexp_standard): Update.\n+\t* expprint.c (print_subexp_standard): Update.\n+\t(dump_subexp_body_standard): Update.\n+\t* f-valprint.c (info_common_command_for_block): Update.\n+\t* findvar.c (get_hosting_frame): Update.\n+\t(default_read_var_value): Update.\n+\t* go-lang.c (go_symbol_package_name): Update.\n+\t* guile/scm-block.c (bkscm_print_block_smob): Update.\n+\t* guile/scm-symbol.c (syscm_print_symbol_smob): Update.\n+\t(gdbscm_symbol_name): Update.\n+\t(gdbscm_symbol_linkage_name): Update.\n+\t(gdbscm_symbol_print_name): Update.\n+\t* infcall.c (get_function_name): Update.\n+\t* infcmd.c (jump_command): Update.\n+\t(finish_command): Update.\n+\t* infrun.c (insert_exception_resume_breakpoint): Update.\n+\t* linespec.c (canonicalize_linespec): Update.\n+\t(create_sals_line_offset): Update.\n+\t(convert_linespec_to_sals): Update.\n+\t(complete_label): Update.\n+\t(find_label_symbols_in_block): Update.\n+\t* m2-typeprint.c (m2_print_typedef): Update.\n+\t* mdebugread.c (mdebug_reg_to_regnum): Update.\n+\t(parse_symbol): Update.\n+\t(mylookup_symbol): Update.\n+\t* mi/mi-cmd-stack.c (list_arg_or_local): Update.\n+\t(list_args_or_locals): Update.\n+\t* objc-lang.c (compare_selectors): Update.\n+\t(info_selectors_command): Update.\n+\t(compare_classes): Update.\n+\t(info_classes_command): Update.\n+\t(find_imps): Update.\n+\t* p-typeprint.c (pascal_print_typedef): Update.\n+\t* printcmd.c (build_address_symbolic): Update.\n+\t(info_address_command): Update.\n+\t(print_variable_and_value): Update.\n+\t* python/py-framefilter.c (extract_sym): Update.\n+\t(py_print_single_arg): Update.\n+\t* python/py-symbol.c (sympy_str): Update.\n+\t(sympy_get_name): Update.\n+\t(sympy_get_linkage_name): Update.\n+\t* python/python.c (gdbpy_rbreak): Update.\n+\t* record-btrace.c (btrace_get_bfun_name): Update.\n+\t(btrace_call_history): Update.\n+\t* rust-lang.c (rust_print_typedef): Update.\n+\t* solib-frv.c (frv_fdpic_find_canonical_descriptor): Update.\n+\t* stabsread.c (stab_reg_to_regnum): Update.\n+\t(define_symbol): Update.\n+\t(read_enum_type): Update.\n+\t(common_block_end): Update.\n+\t(cleanup_undefined_types_1): Update.\n+\t(scan_file_globals): Update.\n+\t* stack.c (print_frame_arg): Update.\n+\t(print_frame_args): Update.\n+\t(find_frame_funname): Update.\n+\t(info_frame_command_core): Update.\n+\t(iterate_over_block_locals): Update.\n+\t(print_block_frame_labels): Update.\n+\t(do_print_variable_and_value): Update.\n+\t(iterate_over_block_arg_vars): Update.\n+\t(return_command): Update.\n+\t* symmisc.c (dump_symtab_1): Update.\n+\t(print_symbol): Update.\n+\t* symtab.c (eq_symbol_entry): Update.\n+\t(symbol_cache_dump): Update.\n+\t(lookup_language_this): Update.\n+\t(find_pc_sect_line): Update.\n+\t(skip_prologue_sal): Update.\n+\t(symbol_search::compare_search_syms): Update.\n+\t(treg_matches_sym_type_name): Update.\n+\t(search_symbols): Update.\n+\t(print_symbol_info): Update.\n+\t(rbreak_command): Update.\n+\t(completion_list_add_symbol): Update.\n+\t(find_gnu_ifunc): Update.\n+\t(get_symbol_address): Update.\n+\t(search_module_symbols): Update.\n+\t(info_module_subcommand): Update.\n+\t* symtab.h (SYMBOL_NATURAL_NAME): Remove.\n+\t(SYMBOL_LINKAGE_NAME): Remove.\n+\t(SYMBOL_DEMANGLED_NAME): Remove.\n+\t(SYMBOL_PRINT_NAME): Remove.\n+\t(SYMBOL_SEARCH_NAME): Remove.\n+\t* tracepoint.c (set_traceframe_context): Update.\n+\t(validate_actionline): Update.\n+\t(collection_list::collect_symbol): Update.\n+\t(encode_actions_1): Update.\n+\t(info_scope_command): Update.\n+\t(print_one_static_tracepoint_marker): Update.\n+\t* typeprint.c (typedef_hash_table::add_template_parameters): Update.\n+\t* valops.c (address_of_variable): Update.\n+\t(find_overload_match): Update.\n+\t(find_oload_champ): Update.\n+\n 2019-11-22  Christian Biesinger  <cbiesinger@google.com>\n \n \t* ada-lang.c (ada_lookup_simple_minsym): Update."
    },
    {
      "sha": "5e9d3e70b9292db2834e21fa9a2cb060820deea6",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1105,7 +1105,8 @@ write_ambiguous_var (struct parser_state *par_state,\n   struct symbol *sym = new (&temp_parse_space) symbol ();\n \n   SYMBOL_DOMAIN (sym) = UNDEF_DOMAIN;\n-  SYMBOL_LINKAGE_NAME (sym) = obstack_strndup (&temp_parse_space, name, len);\n+  SYMBOL_SET_LINKAGE_NAME (sym,\n+\t\t\t   obstack_strndup (&temp_parse_space, name, len));\n   SYMBOL_LANGUAGE (sym) = language_ada;\n \n   write_exp_elt_opcode (par_state, OP_VAR_VALUE);"
    },
    {
      "sha": "7959a5f06e2237da8d6cfaa1e2dc2c333bd2f89c",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 48,
      "deletions": 50,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -3201,8 +3201,8 @@ sort_choices (struct block_symbol syms[], int nsyms)\n \n       for (j = i - 1; j >= 0; j -= 1)\n         {\n-          if (encoded_ordered_before (SYMBOL_LINKAGE_NAME (syms[j].symbol),\n-                                      SYMBOL_LINKAGE_NAME (sym.symbol)))\n+          if (encoded_ordered_before (syms[j].symbol->linkage_name (),\n+                                      sym.symbol->linkage_name ()))\n             break;\n           syms[j + 1] = syms[j];\n         }\n@@ -3225,7 +3225,7 @@ ada_print_symbol_signature (struct ui_file *stream, struct symbol *sym,\n {\n   struct type *type = SYMBOL_TYPE (sym);\n \n-  fprintf_filtered (stream, \"%s\", SYMBOL_PRINT_NAME (sym));\n+  fprintf_filtered (stream, \"%s\", sym->print_name ());\n   if (!print_signatures\n       || type == NULL\n       || TYPE_CODE (type) != TYPE_CODE_FUNC)\n@@ -3431,7 +3431,7 @@ See set/show multiple-symbol.\"));\n               ada_print_type (SYMBOL_TYPE (syms[i].symbol), NULL,\n                               gdb_stdout, -1, 0, &type_print_raw_options);\n               printf_filtered (_(\"'(%s) (enumeral)\\n\"),\n-\t\t\t       SYMBOL_PRINT_NAME (syms[i].symbol));\n+\t\t\t       syms[i].symbol->print_name ());\n             }\n \t  else\n \t    {\n@@ -3675,8 +3675,7 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n           int n_candidates;\n \n           n_candidates =\n-            ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME\n-                                    (exp->elts[pc + 2].symbol),\n+            ada_lookup_symbol_list (exp->elts[pc + 2].symbol->linkage_name (),\n                                     exp->elts[pc + 1].block, VAR_DOMAIN,\n                                     &candidates);\n \n@@ -3718,24 +3717,24 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n \n           if (n_candidates == 0)\n             error (_(\"No definition found for %s\"),\n-                   SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n+                   exp->elts[pc + 2].symbol->print_name ());\n           else if (n_candidates == 1)\n             i = 0;\n           else if (deprocedure_p\n                    && !is_nonfunction (candidates.data (), n_candidates))\n             {\n               i = ada_resolve_function\n                 (candidates.data (), n_candidates, NULL, 0,\n-                 SYMBOL_LINKAGE_NAME (exp->elts[pc + 2].symbol),\n+                 exp->elts[pc + 2].symbol->linkage_name (),\n                  context_type, parse_completion);\n               if (i < 0)\n                 error (_(\"Could not find a match for %s\"),\n-                       SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n+                       exp->elts[pc + 2].symbol->print_name ());\n             }\n           else\n             {\n               printf_filtered (_(\"Multiple matches for %s\\n\"),\n-                               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n+                               exp->elts[pc + 2].symbol->print_name ());\n               user_select_syms (candidates.data (), n_candidates, 1);\n               i = 0;\n             }\n@@ -3765,8 +3764,7 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n             int n_candidates;\n \n             n_candidates =\n-              ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME\n-                                      (exp->elts[pc + 5].symbol),\n+              ada_lookup_symbol_list (exp->elts[pc + 5].symbol->linkage_name (),\n                                       exp->elts[pc + 4].block, VAR_DOMAIN,\n                                       &candidates);\n \n@@ -3777,11 +3775,11 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n                 i = ada_resolve_function\n                   (candidates.data (), n_candidates,\n                    argvec, nargs,\n-                   SYMBOL_LINKAGE_NAME (exp->elts[pc + 5].symbol),\n+                   exp->elts[pc + 5].symbol->linkage_name (),\n                    context_type, parse_completion);\n                 if (i < 0)\n                   error (_(\"Could not find a match for %s\"),\n-                         SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));\n+                         exp->elts[pc + 5].symbol->print_name ());\n               }\n \n             exp->elts[pc + 4].block = candidates[i].block;\n@@ -4264,7 +4262,7 @@ ada_parse_renaming (struct symbol *sym,\n     case LOC_STATIC:\n     case LOC_COMPUTED:\n     case LOC_OPTIMIZED_OUT:\n-      info = strstr (SYMBOL_LINKAGE_NAME (sym), \"___XR\");\n+      info = strstr (sym->linkage_name (), \"___XR\");\n       if (info == NULL)\n \treturn ADA_NOT_RENAMING;\n       switch (info[5])\n@@ -4313,7 +4311,7 @@ ada_read_renaming_var_value (struct symbol *renaming_sym,\n {\n   const char *sym_name;\n \n-  sym_name = SYMBOL_LINKAGE_NAME (renaming_sym);\n+  sym_name = renaming_sym->linkage_name ();\n   expression_up expr = parse_exp_1 (&sym_name, 0, block, 0);\n   return evaluate_expression (expr.get ());\n }\n@@ -4834,8 +4832,8 @@ lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)\n       {\n         struct type *type0 = SYMBOL_TYPE (sym0);\n         struct type *type1 = SYMBOL_TYPE (sym1);\n-        const char *name0 = SYMBOL_LINKAGE_NAME (sym0);\n-        const char *name1 = SYMBOL_LINKAGE_NAME (sym1);\n+        const char *name0 = sym0->linkage_name ();\n+        const char *name1 = sym1->linkage_name ();\n         int len0 = strlen (name0);\n \n         return\n@@ -4850,8 +4848,8 @@ lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)\n \n     case LOC_STATIC:\n       {\n-        const char *name0 = SYMBOL_LINKAGE_NAME (sym0);\n-        const char *name1 = SYMBOL_LINKAGE_NAME (sym1);\n+        const char *name0 = sym0->linkage_name ();\n+        const char *name1 = sym1->linkage_name ();\n         return (strcmp (name0, name1) == 0\n                 && SYMBOL_VALUE_ADDRESS (sym0) == SYMBOL_VALUE_ADDRESS (sym1));\n       }\n@@ -5112,32 +5110,32 @@ remove_extra_symbols (std::vector<struct block_symbol> *syms)\n          the get rid of the stub.  */\n \n       if (TYPE_STUB (SYMBOL_TYPE ((*syms)[i].symbol))\n-          && SYMBOL_LINKAGE_NAME ((*syms)[i].symbol) != NULL)\n+          && (*syms)[i].symbol->linkage_name () != NULL)\n         {\n           for (j = 0; j < syms->size (); j++)\n             {\n               if (j != i\n                   && !TYPE_STUB (SYMBOL_TYPE ((*syms)[j].symbol))\n-                  && SYMBOL_LINKAGE_NAME ((*syms)[j].symbol) != NULL\n-                  && strcmp (SYMBOL_LINKAGE_NAME ((*syms)[i].symbol),\n-                             SYMBOL_LINKAGE_NAME ((*syms)[j].symbol)) == 0)\n+                  && (*syms)[j].symbol->linkage_name () != NULL\n+                  && strcmp ((*syms)[i].symbol->linkage_name (),\n+                             (*syms)[j].symbol->linkage_name ()) == 0)\n                 remove_p = 1;\n             }\n         }\n \n       /* Two symbols with the same name, same class and same address\n          should be identical.  */\n \n-      else if (SYMBOL_LINKAGE_NAME ((*syms)[i].symbol) != NULL\n+      else if ((*syms)[i].symbol->linkage_name () != NULL\n           && SYMBOL_CLASS ((*syms)[i].symbol) == LOC_STATIC\n           && is_nondebugging_type (SYMBOL_TYPE ((*syms)[i].symbol)))\n         {\n           for (j = 0; j < syms->size (); j += 1)\n             {\n               if (i != j\n-                  && SYMBOL_LINKAGE_NAME ((*syms)[j].symbol) != NULL\n-                  && strcmp (SYMBOL_LINKAGE_NAME ((*syms)[i].symbol),\n-                             SYMBOL_LINKAGE_NAME ((*syms)[j].symbol)) == 0\n+                  && (*syms)[j].symbol->linkage_name () != NULL\n+                  && strcmp ((*syms)[i].symbol->linkage_name (),\n+                             (*syms)[j].symbol->linkage_name ()) == 0\n                   && SYMBOL_CLASS ((*syms)[i].symbol)\n \t\t       == SYMBOL_CLASS ((*syms)[j].symbol)\n                   && SYMBOL_VALUE_ADDRESS ((*syms)[i].symbol)\n@@ -5314,7 +5312,7 @@ remove_irrelevant_renamings (std::vector<struct block_symbol> *syms,\n \n       if (sym == NULL || SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n \tcontinue;\n-      name = SYMBOL_LINKAGE_NAME (sym);\n+      name = sym->linkage_name ();\n       suffix = strstr (name, \"___XR\");\n \n       if (suffix != NULL)\n@@ -5325,7 +5323,7 @@ remove_irrelevant_renamings (std::vector<struct block_symbol> *syms,\n \t  is_new_style_renaming = 1;\n \t  for (j = 0; j < syms->size (); j += 1)\n \t    if (i != j && (*syms)[j].symbol != NULL\n-\t\t&& strncmp (name, SYMBOL_LINKAGE_NAME ((*syms)[j].symbol),\n+\t\t&& strncmp (name, (*syms)[j].symbol->linkage_name (),\n \t\t\t    name_len) == 0\n \t\t&& block == (*syms)[j].block)\n \t      (*syms)[j].symbol = NULL;\n@@ -5354,7 +5352,7 @@ remove_irrelevant_renamings (std::vector<struct block_symbol> *syms,\n   if (current_function == NULL)\n     return syms->size ();\n \n-  current_function_name = SYMBOL_LINKAGE_NAME (current_function);\n+  current_function_name = current_function->linkage_name ();\n   if (current_function_name == NULL)\n     return syms->size ();\n \n@@ -6267,17 +6265,17 @@ ada_add_block_symbols (struct obstack *obstackp,\n           {\n             int cmp;\n \n-            cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (sym)[0];\n+            cmp = (int) '_' - (int) sym->linkage_name ()[0];\n             if (cmp == 0)\n               {\n-                cmp = !startswith (SYMBOL_LINKAGE_NAME (sym), \"_ada_\");\n+                cmp = !startswith (sym->linkage_name (), \"_ada_\");\n                 if (cmp == 0)\n-                  cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym) + 5,\n+                  cmp = strncmp (name, sym->linkage_name () + 5,\n                                  name_len);\n               }\n \n             if (cmp == 0\n-                && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len + 5))\n+                && is_name_suffix (sym->linkage_name () + name_len + 5))\n               {\n \t\tif (SYMBOL_CLASS (sym) != LOC_UNRESOLVED)\n \t\t  {\n@@ -6469,7 +6467,7 @@ ada_collect_symbol_completion_matches (completion_tracker &tracker,\n \n \tcompletion_list_add_name (tracker,\n \t\t\t\t  SYMBOL_LANGUAGE (sym),\n-\t\t\t\t  SYMBOL_LINKAGE_NAME (sym),\n+\t\t\t\t  sym->linkage_name (),\n \t\t\t\t  lookup_name, text, word);\n       }\n     }\n@@ -6490,7 +6488,7 @@ ada_collect_symbol_completion_matches (completion_tracker &tracker,\n \n \t      completion_list_add_name (tracker,\n \t\t\t\t\tSYMBOL_LANGUAGE (sym),\n-\t\t\t\t\tSYMBOL_LINKAGE_NAME (sym),\n+\t\t\t\t\tsym->linkage_name (),\n \t\t\t\t\tlookup_name, text, word);\n \t    }\n \t}\n@@ -6512,7 +6510,7 @@ ada_collect_symbol_completion_matches (completion_tracker &tracker,\n \n \t      completion_list_add_name (tracker,\n \t\t\t\t\tSYMBOL_LANGUAGE (sym),\n-\t\t\t\t\tSYMBOL_LINKAGE_NAME (sym),\n+\t\t\t\t\tsym->linkage_name (),\n \t\t\t\t\tlookup_name, text, word);\n \t    }\n \t}\n@@ -7856,7 +7854,7 @@ ada_find_any_type (const char *name)\n static bool\n ada_is_renaming_symbol (struct symbol *name_sym)\n {\n-  const char *name = SYMBOL_LINKAGE_NAME (name_sym);\n+  const char *name = name_sym->linkage_name ();\n   return strstr (name, \"___XR\") != NULL;\n }\n \n@@ -9945,7 +9943,7 @@ aggregate_assign_from_choices (struct value *container,\n \t      name = &exp->elts[choice_pos + 2].string;\n \t      break;\n \t    case OP_VAR_VALUE:\n-\t      name = SYMBOL_NATURAL_NAME (exp->elts[choice_pos + 2].symbol);\n+\t      name = exp->elts[choice_pos + 2].symbol->natural_name ();\n \t      break;\n \t    default:\n \t      error (_(\"Invalid record component association.\"));\n@@ -10610,7 +10608,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n            context other than a function call, in which case, it is\n            invalid.  */\n         error (_(\"Unexpected unresolved symbol, %s, during evaluation\"),\n-               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n+               exp->elts[pc + 2].symbol->print_name ());\n \n       if (noside == EVAL_AVOID_SIDE_EFFECTS)\n         {\n@@ -10700,7 +10698,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       if (exp->elts[*pos].opcode == OP_VAR_VALUE\n           && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n         error (_(\"Unexpected unresolved symbol, %s, during evaluation\"),\n-               SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));\n+               exp->elts[pc + 5].symbol->print_name ());\n       else\n         {\n           for (tem = 0; tem <= nargs; tem += 1)\n@@ -11923,7 +11921,7 @@ ada_has_this_exception_support (const struct exception_support_info *einfo)\n   if (SYMBOL_CLASS (sym) != LOC_BLOCK)\n     {\n       error (_(\"Symbol \\\"%s\\\" is not a function (class = %d)\"),\n-\t     SYMBOL_LINKAGE_NAME (sym), SYMBOL_CLASS (sym));\n+\t     sym->linkage_name (), SYMBOL_CLASS (sym));\n       return 0;\n     }\n \n@@ -11946,7 +11944,7 @@ ada_has_this_exception_support (const struct exception_support_info *einfo)\n   if (SYMBOL_CLASS (sym) != LOC_BLOCK)\n     {\n       error (_(\"Symbol \\\"%s\\\" is not a function (class = %d)\"),\n-\t     SYMBOL_LINKAGE_NAME (sym), SYMBOL_CLASS (sym));\n+\t     sym->linkage_name (), SYMBOL_CLASS (sym));\n       return 0;\n     }\n \n@@ -13141,13 +13139,13 @@ ada_is_non_standard_exception_sym (struct symbol *sym)\n     return 0;\n \n   for (i = 0; i < ARRAY_SIZE (standard_exc); i++)\n-    if (strcmp (SYMBOL_LINKAGE_NAME (sym), standard_exc[i]) == 0)\n+    if (strcmp (sym->linkage_name (), standard_exc[i]) == 0)\n       return 0;  /* A standard exception.  */\n \n   /* Numeric_Error is also a standard exception, so exclude it.\n      See the STANDARD_EXC description for more details as to why\n      this exception is not listed in that array.  */\n-  if (strcmp (SYMBOL_LINKAGE_NAME (sym), \"numeric_error\") == 0)\n+  if (strcmp (sym->linkage_name (), \"numeric_error\") == 0)\n     return 0;\n \n   return 1;\n@@ -13260,7 +13258,7 @@ ada_add_exceptions_from_frame (compiled_regex *preg,\n \t    default:\n \t      if (ada_is_exception_sym (sym))\n \t\t{\n-\t\t  struct ada_exc_info info = {SYMBOL_PRINT_NAME (sym),\n+\t\t  struct ada_exc_info info = {sym->print_name (),\n \t\t\t\t\t      SYMBOL_VALUE_ADDRESS (sym)};\n \n \t\t  exceptions->push_back (info);\n@@ -13333,10 +13331,10 @@ ada_add_global_exceptions (compiled_regex *preg,\n \n \t      ALL_BLOCK_SYMBOLS (b, iter, sym)\n \t\tif (ada_is_non_standard_exception_sym (sym)\n-\t\t    && name_matches_regex (SYMBOL_NATURAL_NAME (sym), preg))\n+\t\t    && name_matches_regex (sym->natural_name (), preg))\n \t\t  {\n \t\t    struct ada_exc_info info\n-\t\t      = {SYMBOL_PRINT_NAME (sym), SYMBOL_VALUE_ADDRESS (sym)};\n+\t\t      = {sym->print_name (), SYMBOL_VALUE_ADDRESS (sym)};\n \n \t\t    exceptions->push_back (info);\n \t\t  }\n@@ -13664,7 +13662,7 @@ ada_print_subexp (struct expression *exp, int *pos,\n       return;\n \n     case OP_VAR_VALUE:\n-      fputs_filtered (SYMBOL_NATURAL_NAME (exp->elts[pc + 2].symbol), stream);\n+      fputs_filtered (exp->elts[pc + 2].symbol->natural_name (), stream);\n       return;\n \n     case BINOP_IN_BOUNDS:"
    },
    {
      "sha": "848958706437511606f265688a745462b108ba3e",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -675,7 +675,7 @@ gen_var_ref (struct agent_expr *ax, struct axs_value *value, struct symbol *var)\n \n     case LOC_TYPEDEF:\n       error (_(\"Cannot compute value of typedef `%s'.\"),\n-\t     SYMBOL_PRINT_NAME (var));\n+\t     var->print_name ());\n       break;\n \n     case LOC_BLOCK:\n@@ -705,10 +705,10 @@ gen_var_ref (struct agent_expr *ax, struct axs_value *value, struct symbol *var)\n     case LOC_UNRESOLVED:\n       {\n \tstruct bound_minimal_symbol msym\n-\t  = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (var), NULL, NULL);\n+\t  = lookup_minimal_symbol (var->linkage_name (), NULL, NULL);\n \n \tif (!msym.minsym)\n-\t  error (_(\"Couldn't resolve symbol `%s'.\"), SYMBOL_PRINT_NAME (var));\n+\t  error (_(\"Couldn't resolve symbol `%s'.\"), var->print_name ());\n \n \t/* Push the address of the variable.  */\n \tax_const_l (ax, BMSYMBOL_VALUE_ADDRESS (msym));\n@@ -727,7 +727,7 @@ gen_var_ref (struct agent_expr *ax, struct axs_value *value, struct symbol *var)\n \n     default:\n       error (_(\"Cannot find value of botched symbol `%s'.\"),\n-\t     SYMBOL_PRINT_NAME (var));\n+\t     var->print_name ());\n       break;\n     }\n }\n@@ -1658,7 +1658,7 @@ gen_maybe_namespace_elt (struct agent_expr *ax, struct axs_value *value,\n \n   if (value->optimized_out)\n     error (_(\"`%s' has been optimized out, cannot use\"),\n-\t   SYMBOL_PRINT_NAME (sym.symbol));\n+\t   sym.symbol->print_name ());\n \n   return 1;\n }\n@@ -1784,7 +1784,7 @@ gen_expr_for_cast (struct expression *exp, union exp_element **pc,\n \n \t  if (value->optimized_out)\n \t    error (_(\"`%s' has been optimized out, cannot use\"),\n-\t\t   SYMBOL_PRINT_NAME ((*pc)[2].symbol));\n+\t\t   (*pc)[2].symbol->print_name ());\n \t}\n       else\n \tgen_msym_var_ref (ax, value, (*pc)[2].msymbol, (*pc)[1].objfile);\n@@ -2008,10 +2008,10 @@ gen_expr (struct expression *exp, union exp_element **pc,\n \n       if (value->optimized_out)\n \terror (_(\"`%s' has been optimized out, cannot use\"),\n-\t       SYMBOL_PRINT_NAME ((*pc)[2].symbol));\n+\t       (*pc)[2].symbol->print_name ());\n \n       if (TYPE_CODE (value->type) == TYPE_CODE_ERROR)\n-\terror_unknown_type (SYMBOL_PRINT_NAME ((*pc)[2].symbol));\n+\terror_unknown_type ((*pc)[2].symbol->print_name ());\n \n       (*pc) += 4;\n       break;\n@@ -2240,7 +2240,7 @@ gen_expr (struct expression *exp, union exp_element **pc,\n \n \tif (value->optimized_out)\n \t  error (_(\"`%s' has been optimized out, cannot use\"),\n-\t\t SYMBOL_PRINT_NAME (sym));\n+\t\t sym->print_name ());\n \n \t(*pc) += 2;\n       }"
    },
    {
      "sha": "118046d446d64cdc57ed2440ebab6b17148eb50f",
      "filename": "gdb/block.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/block.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/block.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/block.h?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -325,15 +325,15 @@ extern struct symbol *block_iterator_first (const struct block *block,\n extern struct symbol *block_iterator_next (struct block_iterator *iterator);\n \n /* Initialize ITERATOR to point at the first symbol in BLOCK whose\n-   SYMBOL_SEARCH_NAME matches NAME, and return that first symbol, or\n+   search_name () matches NAME, and return that first symbol, or\n    NULL if there are no such symbols.  */\n \n extern struct symbol *block_iter_match_first (const struct block *block,\n \t\t\t\t\t      const lookup_name_info &name,\n \t\t\t\t\t      struct block_iterator *iterator);\n \n /* Advance ITERATOR to point at the next symbol in BLOCK whose\n-   SYMBOL_SEARCH_NAME matches NAME, or NULL if there are no more such\n+   search_name () matches NAME, or NULL if there are no more such\n    symbols.  Don't call this if you've previously received NULL from\n    block_iterator_match_first or block_iterator_match_next on this\n    iteration.  And don't call it unless ITERATOR was created by a"
    },
    {
      "sha": "d9c28e0a0176a1d91fec1df089fdc4aa382e8672",
      "filename": "gdb/blockframe.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/blockframe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/blockframe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/blockframe.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -269,7 +269,7 @@ find_pc_partial_function (CORE_ADDR pc, const char **name, CORE_ADDR *address,\n \t{\n \t  const struct block *b = SYMBOL_BLOCK_VALUE (f);\n \n-\t  cache_pc_function_name = SYMBOL_LINKAGE_NAME (f);\n+\t  cache_pc_function_name = f->linkage_name ();\n \t  cache_pc_function_section = section;\n \t  cache_pc_function_block = b;\n "
    },
    {
      "sha": "583f46d8521053ffbd55baa58d7308130dc3c305",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -5818,7 +5818,7 @@ print_breakpoint_location (struct breakpoint *b,\n       if (sym)\n \t{\n \t  uiout->text (\"in \");\n-\t  uiout->field_string (\"func\", SYMBOL_PRINT_NAME (sym),\n+\t  uiout->field_string (\"func\", sym->print_name (),\n \t\t\t       function_name_style.style ());\n \t  uiout->text (\" \");\n \t  uiout->wrap_hint (wrap_indent_at_field (uiout, \"what\"));\n@@ -13304,7 +13304,7 @@ update_static_tracepoint (struct breakpoint *b, struct symtab_and_line sal)\n \t  uiout->text (\"Now in \");\n \t  if (sym)\n \t    {\n-\t      uiout->field_string (\"func\", SYMBOL_PRINT_NAME (sym),\n+\t      uiout->field_string (\"func\", sym->print_name (),\n \t\t\t\t   function_name_style.style ());\n \t      uiout->text (\" at \");\n \t    }"
    },
    {
      "sha": "f6a0643ba172cffe0360c8f0b876b01440df45bf",
      "filename": "gdb/btrace.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/btrace.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -82,7 +82,7 @@ ftrace_print_function_name (const struct btrace_function *bfun)\n   sym = bfun->sym;\n \n   if (sym != NULL)\n-    return SYMBOL_PRINT_NAME (sym);\n+    return sym->print_name ();\n \n   if (msym != NULL)\n     return msym->print_name ();\n@@ -206,7 +206,7 @@ ftrace_function_switched (const struct btrace_function *bfun,\n       const char *bfname, *fname;\n \n       /* Check the function name.  */\n-      if (strcmp (SYMBOL_LINKAGE_NAME (fun), SYMBOL_LINKAGE_NAME (sym)) != 0)\n+      if (strcmp (fun->linkage_name (), sym->linkage_name ()) != 0)\n \treturn 1;\n \n       /* Check the location of those functions, as well.  */"
    },
    {
      "sha": "79f8305763443afc827399ee4c095e98799f3caa",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -164,7 +164,7 @@ find_symbol_in_list (struct pending *list, char *name, int length)\n     {\n       for (j = list->nsyms; --j >= 0;)\n \t{\n-\t  pp = SYMBOL_LINKAGE_NAME (list->symbol[j]);\n+\t  pp = list->symbol[j]->linkage_name ();\n \t  if (*pp == *name && strncmp (pp, name, length) == 0\n \t      && pp[length] == '\\0')\n \t    {\n@@ -319,7 +319,7 @@ buildsym_compunit::finish_block_internal\n \t{\n \t  complaint (_(\"block end address less than block \"\n \t\t       \"start address in %s (patched it)\"),\n-\t\t     SYMBOL_PRINT_NAME (symbol));\n+\t\t     symbol->print_name ());\n \t}\n       else\n \t{\n@@ -356,7 +356,7 @@ buildsym_compunit::finish_block_internal\n \t      if (symbol)\n \t\t{\n \t\t  complaint (_(\"inner block not inside outer block in %s\"),\n-\t\t\t     SYMBOL_PRINT_NAME (symbol));\n+\t\t\t     symbol->print_name ());\n \t\t}\n \t      else\n \t\t{"
    },
    {
      "sha": "0ec6b193dc64da46fbd78e58dd71241339466302",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -3393,7 +3393,7 @@ c_print_token (FILE *file, int type, YYSTYPE value)\n       parser_fprintf (file, \"ssym<name=%s, sym=%s, field_of_this=%d>\",\n \t\t       copy_name (value.ssym.stoken).c_str (),\n \t\t       (value.ssym.sym.symbol == NULL\n-\t\t\t? \"(null)\" : SYMBOL_PRINT_NAME (value.ssym.sym.symbol)),\n+\t\t\t? \"(null)\" : value.ssym.sym.symbol->print_name ()),\n \t\t       value.ssym.is_a_field_of_this);\n       break;\n "
    },
    {
      "sha": "677b85ee842ff3e4061527864cd593c08f5a1645",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -208,9 +208,9 @@ c_print_typedef (struct type *type,\n   type_print (type, \"\", stream, -1);\n   if (TYPE_NAME ((SYMBOL_TYPE (new_symbol))) == 0\n       || strcmp (TYPE_NAME ((SYMBOL_TYPE (new_symbol))),\n-\t\t SYMBOL_LINKAGE_NAME (new_symbol)) != 0\n+\t\t new_symbol->linkage_name ()) != 0\n       || TYPE_CODE (SYMBOL_TYPE (new_symbol)) == TYPE_CODE_TYPEDEF)\n-    fprintf_filtered (stream, \" %s\", SYMBOL_PRINT_NAME (new_symbol));\n+    fprintf_filtered (stream, \" %s\", new_symbol->print_name ());\n   fprintf_filtered (stream, \";\");\n }\n \n@@ -880,15 +880,14 @@ c_type_print_template_args (const struct type_print_options *flags,\n       if (first)\n \t{\n \t  wrap_here (\"    \");\n-\t  fprintf_filtered (stream, _(\"[with %s = \"),\n-\t\t\t    SYMBOL_LINKAGE_NAME (sym));\n+\t  fprintf_filtered (stream, _(\"[with %s = \"), sym->linkage_name ());\n \t  first = 0;\n \t}\n       else\n \t{\n \t  fputs_filtered (\", \", stream);\n \t  wrap_here (\"         \");\n-\t  fprintf_filtered (stream, \"%s = \", SYMBOL_LINKAGE_NAME (sym));\n+\t  fprintf_filtered (stream, \"%s = \", sym->linkage_name ());\n \t}\n \n       c_print_type (SYMBOL_TYPE (sym), \"\", stream, -1, 0, flags);"
    },
    {
      "sha": "681d53c574d88709a72767bf713efac92d092342",
      "filename": "gdb/cli/cli-cmds.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/cli/cli-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/cli/cli-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-cmds.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -938,7 +938,7 @@ edit_command (const char *arg, int from_tty)\n           if (sym)\n \t    printf_filtered (\"%s is in %s (%s:%d).\\n\",\n \t\t\t     paddress (gdbarch, sal.pc),\n-\t\t\t     SYMBOL_PRINT_NAME (sym),\n+\t\t\t     sym->print_name (),\n \t\t\t     symtab_to_filename_for_display (sal.symtab),\n \t\t\t     sal.line);\n           else\n@@ -1270,7 +1270,7 @@ list_command (const char *arg, int from_tty)\n       if (sym)\n \tprintf_filtered (\"%s is in %s (%s:%d).\\n\",\n \t\t\t paddress (gdbarch, sal.pc),\n-\t\t\t SYMBOL_PRINT_NAME (sym),\n+\t\t\t sym->print_name (),\n \t\t\t symtab_to_filename_for_display (sal.symtab), sal.line);\n       else\n \tprintf_filtered (\"%s is at %s:%d.\\n\",\n@@ -1758,7 +1758,7 @@ print_sal_location (const symtab_and_line &sal)\n \n   const char *sym_name = NULL;\n   if (sal.symbol != NULL)\n-    sym_name = SYMBOL_PRINT_NAME (sal.symbol);\n+    sym_name = sal.symbol->print_name ();\n   printf_filtered (_(\"file: \\\"%s\\\", line number: %d, symbol: \\\"%s\\\"\\n\"),\n \t\t   symtab_to_filename_for_display (sal.symtab),\n \t\t   sal.line, sym_name != NULL ? sym_name : \"???\");"
    },
    {
      "sha": "ac00e1c1e3b1f3c11214dbb5b86edaf9d005be2e",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 10,
      "deletions": 11,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1502,15 +1502,15 @@ patch_opaque_types (struct symtab *s)\n \t  && TYPE_CODE (SYMBOL_TYPE (real_sym)) == TYPE_CODE_PTR\n \t  && TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (real_sym))) != 0)\n \t{\n-\t  const char *name = SYMBOL_LINKAGE_NAME (real_sym);\n+\t  const char *name = real_sym->linkage_name ();\n \t  int hash = hashname (name);\n \t  struct symbol *sym, *prev;\n \n \t  prev = 0;\n \t  for (sym = opaque_type_chain[hash]; sym;)\n \t    {\n-\t      if (name[0] == SYMBOL_LINKAGE_NAME (sym)[0]\n-\t\t  && strcmp (name + 1, SYMBOL_LINKAGE_NAME (sym) + 1) == 0)\n+\t      if (name[0] == sym->linkage_name ()[0]\n+\t\t  && strcmp (name + 1, sym->linkage_name () + 1) == 0)\n \t\t{\n \t\t  if (prev)\n \t\t    {\n@@ -1693,7 +1693,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \t\t}\n \t      else\n \t\tTYPE_NAME (SYMBOL_TYPE (sym)) =\n-\t\t  xstrdup (SYMBOL_LINKAGE_NAME (sym));\n+\t\t  xstrdup (sym->linkage_name ());\n \t    }\n \n \t  /* Keep track of any type which points to empty structured\n@@ -1707,7 +1707,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \t      && TYPE_CODE (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym)))\n \t         != TYPE_CODE_UNDEF)\n \t    {\n-\t      int i = hashname (SYMBOL_LINKAGE_NAME (sym));\n+\t      int i = hashname (sym->linkage_name ());\n \n \t      SYMBOL_VALUE_CHAIN (sym) = opaque_type_chain[i];\n \t      opaque_type_chain[i] = sym;\n@@ -1725,11 +1725,10 @@ process_coff_symbol (struct coff_symbol *cs,\n \t     names for anonymous enums, structures, and unions, like\n \t     \"~0fake\" or \".0fake\".  Thanks, but no thanks...  */\n \t  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n-\t    if (SYMBOL_LINKAGE_NAME (sym) != NULL\n-\t\t&& *SYMBOL_LINKAGE_NAME (sym) != '~'\n-\t\t&& *SYMBOL_LINKAGE_NAME (sym) != '.')\n-\t      TYPE_NAME (SYMBOL_TYPE (sym)) =\n-\t\txstrdup (SYMBOL_LINKAGE_NAME (sym));\n+\t    if (sym->linkage_name () != NULL\n+\t\t&& *sym->linkage_name () != '~'\n+\t\t&& *sym->linkage_name () != '.')\n+\t      TYPE_NAME (SYMBOL_TYPE (sym)) = xstrdup (sym->linkage_name ());\n \n \t  add_symbol_to_list (sym, get_file_symbols ());\n \t  break;\n@@ -2154,7 +2153,7 @@ coff_read_enum_type (int index, int length, int lastsym,\n \t  struct symbol *xsym = syms->symbol[j];\n \n \t  SYMBOL_TYPE (xsym) = type;\n-\t  TYPE_FIELD_NAME (type, n) = SYMBOL_LINKAGE_NAME (xsym);\n+\t  TYPE_FIELD_NAME (type, n) = xsym->linkage_name ();\n \t  SET_FIELD_ENUMVAL (TYPE_FIELD (type, n), SYMBOL_VALUE (xsym));\n \t  if (SYMBOL_VALUE (xsym) < 0)\n \t    unsigned_enum = 0;"
    },
    {
      "sha": "5143088058699df8d25d9080c00318348640e03a",
      "filename": "gdb/compile/compile-c-symbols.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-c-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-c-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-symbols.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -40,7 +40,7 @@ gdb::unique_xmalloc_ptr<char>\n c_symbol_substitution_name (struct symbol *sym)\n {\n   return gdb::unique_xmalloc_ptr<char>\n-    (concat (\"__\", SYMBOL_NATURAL_NAME (sym), \"_ptr\", (char *) NULL));\n+    (concat (\"__\", sym->natural_name (), \"_ptr\", (char *) NULL));\n }\n \n /* Convert a given symbol, SYM, to the compiler's representation.\n@@ -70,7 +70,7 @@ convert_one_symbol (compile_c_instance *context,\n   if (SYMBOL_DOMAIN (sym.symbol) == STRUCT_DOMAIN)\n     {\n       /* Binding a tag, so we don't need to build a decl.  */\n-      context->plugin ().tagbind (SYMBOL_NATURAL_NAME (sym.symbol),\n+      context->plugin ().tagbind (sym.symbol->natural_name (),\n \t\t\t\t  sym_type, filename, line);\n     }\n   else\n@@ -105,28 +105,28 @@ convert_one_symbol (compile_c_instance *context,\n \t      return;\n \t    }\n \t  context->plugin ().build_constant\n-\t    (sym_type, SYMBOL_NATURAL_NAME (sym.symbol),\n+\t    (sym_type, sym.symbol->natural_name (),\n \t     SYMBOL_VALUE (sym.symbol),\n \t     filename, line);\n \t  return;\n \n \tcase LOC_CONST_BYTES:\n \t  error (_(\"Unsupported LOC_CONST_BYTES for symbol \\\"%s\\\".\"),\n-\t\t SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t sym.symbol->print_name ());\n \n \tcase LOC_UNDEF:\n \t  internal_error (__FILE__, __LINE__, _(\"LOC_UNDEF found for \\\"%s\\\".\"),\n-\t\t\t  SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t\t  sym.symbol->print_name ());\n \n \tcase LOC_COMMON_BLOCK:\n \t  error (_(\"Fortran common block is unsupported for compilation \"\n \t\t   \"evaluaton of symbol \\\"%s\\\".\"),\n-\t\t SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t sym.symbol->print_name ());\n \n \tcase LOC_OPTIMIZED_OUT:\n \t  error (_(\"Symbol \\\"%s\\\" cannot be used for compilation evaluation \"\n \t\t   \"as it is optimized out.\"),\n-\t\t SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t sym.symbol->print_name ());\n \n \tcase LOC_COMPUTED:\n \t  if (is_local)\n@@ -135,7 +135,7 @@ convert_one_symbol (compile_c_instance *context,\n \t  warning (_(\"Symbol \\\"%s\\\" is thread-local and currently can only \"\n \t\t     \"be referenced from the current thread in \"\n \t\t     \"compiled code.\"),\n-\t\t   SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t   sym.symbol->print_name ());\n \t  /* FALLTHROUGH */\n \tcase LOC_UNRESOLVED:\n \t  /* 'symbol_name' cannot be used here as that one is used only for\n@@ -152,14 +152,14 @@ convert_one_symbol (compile_c_instance *context,\n \t\tif (frame == NULL)\n \t\t  error (_(\"Symbol \\\"%s\\\" cannot be used because \"\n \t\t\t   \"there is no selected frame\"),\n-\t\t\t SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t\t sym.symbol->print_name ());\n \t      }\n \n \t    val = read_var_value (sym.symbol, sym.block, frame);\n \t    if (VALUE_LVAL (val) != lval_memory)\n \t      error (_(\"Symbol \\\"%s\\\" cannot be used for compilation \"\n \t\t       \"evaluation as its address has not been found.\"),\n-\t\t     SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t     sym.symbol->print_name ());\n \n \t    kind = GCC_C_SYMBOL_VARIABLE;\n \t    addr = value_address (val);\n@@ -193,7 +193,7 @@ convert_one_symbol (compile_c_instance *context,\n \t  || symbol_name == NULL)\n \t{\n \t  decl = context->plugin ().build_decl\n-\t    (SYMBOL_NATURAL_NAME (sym.symbol),\n+\t    (sym.symbol->natural_name (),\n \t     kind,\n \t     sym_type,\n \t     symbol_name.get (), addr,\n@@ -450,7 +450,7 @@ hash_symname (const void *a)\n {\n   const struct symbol *sym = (const struct symbol *) a;\n \n-  return htab_hash_string (SYMBOL_NATURAL_NAME (sym));\n+  return htab_hash_string (sym->natural_name ());\n }\n \n /* A comparison function for hash tables that just looks at symbol\n@@ -462,7 +462,7 @@ eq_symname (const void *a, const void *b)\n   const struct symbol *syma = (const struct symbol *) a;\n   const struct symbol *symb = (const struct symbol *) b;\n \n-  return strcmp (SYMBOL_NATURAL_NAME (syma), SYMBOL_NATURAL_NAME (symb)) == 0;\n+  return strcmp (syma->natural_name (), symb->natural_name ()) == 0;\n }\n \n /* If a symbol with the same name as SYM is already in HASHTAB, return"
    },
    {
      "sha": "65b27f89e7bc870f4631a7f4bfaaa3380df52b01",
      "filename": "gdb/compile/compile-cplus-symbols.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-cplus-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-cplus-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-symbols.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -100,27 +100,27 @@ convert_one_symbol (compile_cplus_instance *instance,\n \t      return;\n \t    }\n \t  instance->plugin ().build_constant\n-\t    (sym_type, SYMBOL_NATURAL_NAME (sym.symbol),\n+\t    (sym_type, sym.symbol->natural_name (),\n \t     SYMBOL_VALUE (sym.symbol), filename, line);\n \t  return;\n \n \tcase LOC_CONST_BYTES:\n \t  error (_(\"Unsupported LOC_CONST_BYTES for symbol \\\"%s\\\".\"),\n-\t\t SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t sym.symbol->print_name ());\n \n \tcase LOC_UNDEF:\n \t  internal_error (__FILE__, __LINE__, _(\"LOC_UNDEF found for \\\"%s\\\".\"),\n-\t\t\t  SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t\t  sym.symbol->print_name ());\n \n \tcase LOC_COMMON_BLOCK:\n \t  error (_(\"Fortran common block is unsupported for compilation \"\n \t\t   \"evaluaton of symbol \\\"%s\\\".\"),\n-\t\t SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t sym.symbol->print_name ());\n \n \tcase LOC_OPTIMIZED_OUT:\n \t  error (_(\"Symbol \\\"%s\\\" cannot be used for compilation evaluation \"\n \t\t   \"as it is optimized out.\"),\n-\t\t SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t sym.symbol->print_name ());\n \n \tcase LOC_COMPUTED:\n \t  if (is_local)\n@@ -129,7 +129,7 @@ convert_one_symbol (compile_cplus_instance *instance,\n \t  warning (_(\"Symbol \\\"%s\\\" is thread-local and currently can only \"\n \t\t     \"be referenced from the current thread in \"\n \t\t     \"compiled code.\"),\n-\t\t   SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t   sym.symbol->print_name ());\n \t  /* FALLTHROUGH */\n \tcase LOC_UNRESOLVED:\n \t  /* 'symbol_name' cannot be used here as that one is used only for\n@@ -146,14 +146,14 @@ convert_one_symbol (compile_cplus_instance *instance,\n \t\tif (frame == nullptr)\n \t\t  error (_(\"Symbol \\\"%s\\\" cannot be used because \"\n \t\t\t   \"there is no selected frame\"),\n-\t\t\t SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t\t sym.symbol->print_name ());\n \t      }\n \n \t    val = read_var_value (sym.symbol, sym.block, frame);\n \t    if (VALUE_LVAL (val) != lval_memory)\n \t      error (_(\"Symbol \\\"%s\\\" cannot be used for compilation \"\n \t\t       \"evaluation as its address has not been found.\"),\n-\t\t     SYMBOL_PRINT_NAME (sym.symbol));\n+\t\t     sym.symbol->print_name ());\n \n \t    kind = GCC_CP_SYMBOL_VARIABLE;\n \t    addr = value_address (val);\n@@ -189,7 +189,7 @@ convert_one_symbol (compile_cplus_instance *instance,\n \t  if (!is_local)\n \t    {\n \t      compile_scope scope\n-\t\t= instance->new_scope (SYMBOL_NATURAL_NAME (sym.symbol),\n+\t\t= instance->new_scope (sym.symbol->natural_name (),\n \t\t\t\t       SYMBOL_TYPE (sym.symbol));\n \t      if (scope.nested_type () != GCC_TYPE_NONE)\n \t\t{\n@@ -202,9 +202,9 @@ convert_one_symbol (compile_cplus_instance *instance,\n \t    }\n \n \t  /* Get the `raw' name of the symbol.  */\n-\t  if (name.empty () && SYMBOL_NATURAL_NAME (sym.symbol) != nullptr)\n+\t  if (name.empty () && sym.symbol->natural_name () != nullptr)\n \t    name = compile_cplus_instance::decl_name\n-\t      (SYMBOL_NATURAL_NAME (sym.symbol)).get ();\n+\t      (sym.symbol->natural_name ()).get ();\n \n \t  /* Define the decl.  */\n \t  instance->plugin ().build_decl"
    },
    {
      "sha": "c6d2b294ab202bdd40939f4ff82554c79257caa0",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -112,7 +112,7 @@ debug_print_scope (const compile_scope &scope)\n   for (const auto &comp: scope)\n     {\n       const char *symbol = (comp.bsymbol.symbol != nullptr\n-\t\t\t    ? SYMBOL_NATURAL_NAME (comp.bsymbol.symbol)\n+\t\t\t    ? comp.bsymbol.symbol->natural_name ()\n \t\t\t    : \"<none>\");\n \n       printf_unfiltered (\"\\tname = %s, symbol = %s\\n\", comp.name.c_str (),"
    },
    {
      "sha": "2580f9d6b845ddb7589c87dceb5244c814126530",
      "filename": "gdb/compile/compile-loc2c.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-loc2c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-loc2c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-loc2c.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -622,18 +622,18 @@ do_compile_dwarf_expr_to_c (int indent, string_file *stream,\n       if (frame == NULL)\n \terror (_(\"Symbol \\\"%s\\\" cannot be used because \"\n \t\t \"there is no selected frame\"),\n-\t       SYMBOL_PRINT_NAME (sym));\n+\t       sym->print_name ());\n \n       val = read_var_value (sym, NULL, frame);\n       if (VALUE_LVAL (val) != lval_memory)\n \terror (_(\"Symbol \\\"%s\\\" cannot be used for compilation evaluation \"\n \t\t \"as its address has not been found.\"),\n-\t       SYMBOL_PRINT_NAME (sym));\n+\t       sym->print_name ());\n \n       warning (_(\"Symbol \\\"%s\\\" is thread-local and currently can only \"\n \t\t \"be referenced from the current thread in \"\n \t\t \"compiled code.\"),\n-\t       SYMBOL_PRINT_NAME (sym));\n+\t       sym->print_name ());\n \n       fprintfi_filtered (indent, stream, \"%s = %s;\\n\",\n \t\t\t result_name,"
    },
    {
      "sha": "c9bf1518372eead0d936288cf460d6265cb62e2c",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -433,7 +433,7 @@ get_out_value_type (struct symbol *func_sym, struct objfile *objfile,\n       if (function != NULL\n \t  && (BLOCK_SUPERBLOCK (function_block)\n \t      == BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK))\n-\t  && (strcmp_iw (SYMBOL_LINKAGE_NAME (function),\n+\t  && (strcmp_iw (function->linkage_name (),\n \t\t\t GCC_FE_WRAPPER_FUNCTION)\n \t      == 0))\n \tbreak;"
    },
    {
      "sha": "2b3f014253aca950be53ae2bb36d4e9b0820fa3b",
      "filename": "gdb/cp-namespace.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/cp-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/cp-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-namespace.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -54,9 +54,9 @@ cp_scan_for_anonymous_namespaces (struct buildsym_compunit *compunit,\n \t\t\t\t  const struct symbol *const symbol,\n \t\t\t\t  struct objfile *const objfile)\n {\n-  if (SYMBOL_DEMANGLED_NAME (symbol) != NULL)\n+  if (symbol->demangled_name () != NULL)\n     {\n-      const char *name = SYMBOL_DEMANGLED_NAME (symbol);\n+      const char *name = symbol->demangled_name ();\n       unsigned int previous_component;\n       unsigned int next_component;\n \n@@ -488,7 +488,7 @@ search_symbol_list (const char *name, int num,\n   /* Maybe we should store a dictionary in here instead.  */\n   for (i = 0; i < num; ++i)\n     {\n-      if (strcmp (name, SYMBOL_NATURAL_NAME (syms[i])) == 0)\n+      if (strcmp (name, syms[i]->natural_name ()) == 0)\n \treturn syms[i];\n     }\n   return NULL;\n@@ -542,10 +542,10 @@ cp_lookup_symbol_imports_or_template (const char *scope,\n \n       /* Search the template parameters of the function's defining\n \t context.  */\n-      if (SYMBOL_NATURAL_NAME (function))\n+      if (function->natural_name ())\n \t{\n \t  struct type *context;\n-\t  std::string name_copy (SYMBOL_NATURAL_NAME (function));\n+\t  std::string name_copy (function->natural_name ());\n \t  const struct language_defn *lang = language_def (language_cplus);\n \t  struct gdbarch *arch = symbol_arch (function);\n \t  const struct block *parent = BLOCK_SUPERBLOCK (block);"
    },
    {
      "sha": "55a2e42b34b400f1a70fa22b777cb46665ecf250",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1154,13 +1154,12 @@ overload_list_add_symbol (struct symbol *sym,\n \n   /* skip any symbols that we've already considered.  */\n   for (symbol *listed_sym : *overload_list)\n-    if (strcmp (SYMBOL_LINKAGE_NAME (sym),\n-\t\tSYMBOL_LINKAGE_NAME (listed_sym)) == 0)\n+    if (strcmp (sym->linkage_name (), listed_sym->linkage_name ()) == 0)\n       return;\n \n   /* Get the demangled name without parameters */\n   gdb::unique_xmalloc_ptr<char> sym_name\n-    = cp_remove_params (SYMBOL_NATURAL_NAME (sym));\n+    = cp_remove_params (sym->natural_name ());\n   if (!sym_name)\n     return;\n "
    },
    {
      "sha": "c5f9130c6a827744ff9593a24c1d92d539734b11",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1230,7 +1230,7 @@ psymtab_to_symtab (struct partial_symtab *pst)\n       if (sym == NULL)\n \tcontinue;\n \n-      set_symbol_address (ccp->of, sym, SYMBOL_LINKAGE_NAME (sym));\n+      set_symbol_address (ccp->of, sym, sym->linkage_name ());\n     }\n \n   pst->readin = 1;"
    },
    {
      "sha": "73f1ba8759a1f790c961cc9940336a987f8ffde3",
      "filename": "gdb/dbxread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dbxread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dbxread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dbxread.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -2341,7 +2341,7 @@ cp_set_block_scope (const struct symbol *symbol,\n \t\t    struct block *block,\n \t\t    struct obstack *obstack)\n {\n-  if (SYMBOL_DEMANGLED_NAME (symbol) != NULL)\n+  if (symbol->demangled_name () != NULL)\n     {\n       /* Try to figure out the appropriate namespace from the\n \t demangled name.  */\n@@ -2351,7 +2351,7 @@ cp_set_block_scope (const struct symbol *symbol,\n \t name of the class as well.  This should be harmless, but\n \t is a little unfortunate.  */\n \n-      const char *name = SYMBOL_DEMANGLED_NAME (symbol);\n+      const char *name = symbol->demangled_name ();\n       unsigned int prefix_len = cp_entire_prefix_len (name);\n \n       block_set_scope (block, obstack_strndup (obstack, name, prefix_len),"
    },
    {
      "sha": "e47e0217b9cddee1d4b9908f6c8fcd7dd0e81a7d",
      "filename": "gdb/dictionary.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dictionary.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dictionary.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dictionary.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -608,7 +608,7 @@ iter_match_first_hashed (const struct dictionary *dict,\n        sym = sym->hash_next)\n     {\n       /* Warning: the order of arguments to compare matters!  */\n-      if (matches_name (SYMBOL_SEARCH_NAME (sym), name, NULL))\n+      if (matches_name (sym->search_name (), name, NULL))\n \tbreak;\n     }\n \n@@ -629,7 +629,7 @@ iter_match_next_hashed (const lookup_name_info &name,\n        next != NULL;\n        next = next->hash_next)\n     {\n-      if (matches_name (SYMBOL_SEARCH_NAME (next), name, NULL))\n+      if (matches_name (next->search_name (), name, NULL))\n \tbreak;\n     }\n \n@@ -652,7 +652,7 @@ insert_symbol_hashed (struct dictionary *dict,\n      language.  The two may not use the same hashing algorithm.  */\n   gdb_assert (SYMBOL_LANGUAGE (sym) == DICT_LANGUAGE (dict)->la_language);\n \n-  hash = search_name_hash (SYMBOL_LANGUAGE (sym), SYMBOL_SEARCH_NAME (sym));\n+  hash = search_name_hash (SYMBOL_LANGUAGE (sym), sym->search_name ());\n   hash_index = hash % DICT_HASHED_NBUCKETS (dict);\n   sym->hash_next = buckets[hash_index];\n   buckets[hash_index] = sym;\n@@ -847,7 +847,7 @@ iter_match_next_linear (const lookup_name_info &name,\n     {\n       sym = DICT_LINEAR_SYM (dict, i);\n \n-      if (matches_name (SYMBOL_SEARCH_NAME (sym), name, NULL))\n+      if (matches_name (sym->search_name (), name, NULL))\n \t{\n \t  retval = sym;\n \t  break;"
    },
    {
      "sha": "e6481cd38ce9895c3a79c4afa935cf049c6c531d",
      "filename": "gdb/dictionary.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dictionary.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dictionary.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dictionary.h?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -142,7 +142,7 @@ extern struct symbol *\n extern struct symbol *mdict_iterator_next (struct mdict_iterator *miterator);\n \n /* Initialize MITERATOR to point at the first symbol in MDICT whose\n-   SYMBOL_SEARCH_NAME is NAME, as tested using COMPARE (which must use\n+   search_name () is NAME, as tested using COMPARE (which must use\n    the same conventions as strcmp_iw and be compatible with any\n    dictionary hashing function), and return that first symbol, or NULL\n    if there are no such symbols.  */\n@@ -153,7 +153,7 @@ extern struct symbol *\n \t\t\t  struct mdict_iterator *miterator);\n \n /* Advance MITERATOR to point at the next symbol in MDICT whose\n-   SYMBOL_SEARCH_NAME is NAME, as tested using COMPARE (see\n+   search_name () is NAME, as tested using COMPARE (see\n    dict_iter_match_first), or NULL if there are no more such symbols.\n    Don't call this if you've previously received NULL from \n    mdict_iterator_match_first or mdict_iterator_match_next on this"
    },
    {
      "sha": "0b22745074ad45559a47a30588270ea83182c276",
      "filename": "gdb/dwarf2loc.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dwarf2loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dwarf2loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2loc.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -524,7 +524,7 @@ func_get_frame_base_dwarf_block (struct symbol *framefunc, CORE_ADDR pc,\n \n   if (*length == 0)\n     error (_(\"Could not find the frame base for \\\"%s\\\".\"),\n-\t   SYMBOL_NATURAL_NAME (framefunc));\n+\t   framefunc->natural_name ());\n }\n \n static CORE_ADDR\n@@ -3635,13 +3635,13 @@ locexpr_describe_location_piece (struct symbol *symbol, struct ui_file *stream,\n \n       if (!b)\n \terror (_(\"No block found for address for symbol \\\"%s\\\".\"),\n-\t       SYMBOL_PRINT_NAME (symbol));\n+\t       symbol->print_name ());\n \n       framefunc = block_linkage_function (b);\n \n       if (!framefunc)\n \terror (_(\"No function found for block for symbol \\\"%s\\\".\"),\n-\t       SYMBOL_PRINT_NAME (symbol));\n+\t       symbol->print_name ());\n \n       func_get_frame_base_dwarf_block (framefunc, addr, &base_data, &base_size);\n \n@@ -3655,7 +3655,7 @@ locexpr_describe_location_piece (struct symbol *symbol, struct ui_file *stream,\n \t  if (buf_end != base_data + base_size)\n \t    error (_(\"Unexpected opcode after \"\n \t\t     \"DW_OP_breg%u for symbol \\\"%s\\\".\"),\n-\t\t   frame_reg, SYMBOL_PRINT_NAME (symbol));\n+\t\t   frame_reg, symbol->print_name ());\n \t}\n       else if (base_data[0] >= DW_OP_reg0 && base_data[0] <= DW_OP_reg31)\n \t{\n@@ -4229,7 +4229,7 @@ locexpr_describe_location_1 (struct symbol *symbol, CORE_ADDR addr,\n \n   if (bad || data > end)\n     error (_(\"Corrupted DWARF2 expression for \\\"%s\\\".\"),\n-\t   SYMBOL_PRINT_NAME (symbol));\n+\t   symbol->print_name ());\n }\n \n /* Print a natural-language description of SYMBOL to STREAM.  This\n@@ -4282,7 +4282,7 @@ locexpr_generate_c_location (struct symbol *sym, string_file *stream,\n   unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);\n \n   if (dlbaton->size == 0)\n-    error (_(\"symbol \\\"%s\\\" is optimized out\"), SYMBOL_NATURAL_NAME (sym));\n+    error (_(\"symbol \\\"%s\\\" is optimized out\"), sym->natural_name ());\n \n   compile_dwarf_expr_to_c (stream, result_name,\n \t\t\t   sym, pc, gdbarch, registers_used, addr_size,\n@@ -4428,7 +4428,7 @@ loclist_describe_location (struct symbol *symbol, CORE_ADDR addr,\n \tcase DEBUG_LOC_BUFFER_OVERFLOW:\n \tcase DEBUG_LOC_INVALID_ENTRY:\n \t  error (_(\"Corrupted DWARF expression for symbol \\\"%s\\\".\"),\n-\t\t SYMBOL_PRINT_NAME (symbol));\n+\t\t symbol->print_name ());\n \tdefault:\n \t  gdb_assert_not_reached (\"bad debug_loc_kind\");\n \t}\n@@ -4495,7 +4495,7 @@ loclist_generate_c_location (struct symbol *sym, string_file *stream,\n \n   data = dwarf2_find_location_expression (dlbaton, &size, pc);\n   if (size == 0)\n-    error (_(\"symbol \\\"%s\\\" is optimized out\"), SYMBOL_NATURAL_NAME (sym));\n+    error (_(\"symbol \\\"%s\\\" is optimized out\"), sym->natural_name ());\n \n   compile_dwarf_expr_to_c (stream, result_name,\n \t\t\t   sym, pc, gdbarch, registers_used, addr_size,"
    },
    {
      "sha": "1ca801c3977233dbef728193f0f02ea48fa03452",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -6073,10 +6073,10 @@ dw2_debug_names_lookup_symbol (struct objfile *objfile, block_enum block_index,\n \t information (but NAME might contain it).  */\n \n       if (sym != NULL\n-\t  && strcmp_iw (SYMBOL_SEARCH_NAME (sym), name) == 0)\n+\t  && strcmp_iw (sym->search_name (), name) == 0)\n \treturn stab;\n       if (with_opaque != NULL\n-\t  && strcmp_iw (SYMBOL_SEARCH_NAME (with_opaque), name) == 0)\n+\t  && strcmp_iw (with_opaque->search_name (), name) == 0)\n \tstab_best = stab;\n \n       /* Keep looking through other CUs.  */\n@@ -13776,7 +13776,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t\t     (struct symbol *) templ_func);\n \n   if (dwarf2_flag_true_p (die, DW_AT_main_subprogram, cu))\n-    set_objfile_main_name (objfile, SYMBOL_LINKAGE_NAME (newobj->name),\n+    set_objfile_main_name (objfile, newobj->name->linkage_name (),\n \t\t\t   cu->language);\n \n   /* If there is a location expression for DW_AT_frame_base, record\n@@ -16476,7 +16476,7 @@ process_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t\t\t  * sizeof (struct field));\n \t\t    }\n \n-\t\t  FIELD_NAME (fields[num_fields]) = SYMBOL_LINKAGE_NAME (sym);\n+\t\t  FIELD_NAME (fields[num_fields]) = sym->linkage_name ();\n \t\t  FIELD_TYPE (fields[num_fields]) = NULL;\n \t\t  SET_FIELD_ENUMVAL (fields[num_fields], SYMBOL_VALUE (sym));\n \t\t  FIELD_BITSIZE (fields[num_fields]) = 0;\n@@ -21800,7 +21800,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t\t apply.  */\n \t\t      bound_minimal_symbol found\n \t\t\t= (lookup_minimal_symbol_linkage\n-\t\t\t   (SYMBOL_LINKAGE_NAME (sym), objfile));\n+\t\t\t   (sym->linkage_name (), objfile));\n \t\t      if (found.minsym != nullptr)\n \t\t\tsym->maybe_copied = 1;\n \t\t    }\n@@ -21929,7 +21929,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t       with this objfile, so we don't need to\n \t\t       duplicate it for the type.  */\n \t\t    if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n-\t\t      TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_SEARCH_NAME (sym);\n+\t\t      TYPE_NAME (SYMBOL_TYPE (sym)) = sym->search_name ();\n \t\t  }\n \t      }\n \t  }\n@@ -22162,7 +22162,7 @@ dwarf2_const_value (const struct attribute *attr, struct symbol *sym,\n   struct dwarf2_locexpr_baton *baton;\n \n   dwarf2_const_value_attr (attr, SYMBOL_TYPE (sym),\n-\t\t\t   SYMBOL_PRINT_NAME (sym),\n+\t\t\t   sym->print_name (),\n \t\t\t   &objfile->objfile_obstack, cu,\n \t\t\t   &value, &bytes, &baton);\n \n@@ -25344,7 +25344,7 @@ dwarf2_symbol_mark_computed (const struct attribute *attr, struct symbol *sym,\n       else\n \t{\n \t  dwarf2_invalid_attrib_class_complaint (\"location description\",\n-\t\t\t\t\t\t SYMBOL_NATURAL_NAME (sym));\n+\t\t\t\t\t\t sym->natural_name ());\n \t  baton->size = 0;\n \t}\n "
    },
    {
      "sha": "72f5109a7c424739059e4ebba279c1ad32548e6c",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1049,7 +1049,7 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \t  else if (op == OP_VAR_VALUE)\n \t    {\n \t      symbol *sym = exp->elts[*pos + 2].symbol;\n-\t      var_func_name = SYMBOL_PRINT_NAME (sym);\n+\t      var_func_name = sym->print_name ();\n \t    }\n \n \t  argvec[0] = evaluate_subexp_with_coercion (exp, pos, noside);\n@@ -1300,7 +1300,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t(*pos) += 3;\n \tsymbol *var = exp->elts[pc + 2].symbol;\n \tif (TYPE_CODE (SYMBOL_TYPE (var)) == TYPE_CODE_ERROR)\n-\t  error_unknown_type (SYMBOL_PRINT_NAME (var));\n+\t  error_unknown_type (var->print_name ());\n \tif (noside != EVAL_SKIP)\n \t    return evaluate_var_value (noside, exp->elts[pc + 1].block, var);\n \telse\n@@ -1342,7 +1342,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \tif (SYMBOL_COMPUTED_OPS (sym) == NULL\n \t    || SYMBOL_COMPUTED_OPS (sym)->read_variable_at_entry == NULL)\n \t  error (_(\"Symbol \\\"%s\\\" does not have any specific entry value\"),\n-\t\t SYMBOL_PRINT_NAME (sym));\n+\t\t sym->print_name ());\n \n \tframe = get_selected_frame (NULL);\n \treturn SYMBOL_COMPUTED_OPS (sym)->read_variable_at_entry (sym, frame);"
    },
    {
      "sha": "70cc7ca594a87e0cc405052eeabd52acf856a029",
      "filename": "gdb/expprint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/expprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/expprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expprint.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -126,12 +126,12 @@ print_subexp_standard (struct expression *exp, int *pos,\n \tb = exp->elts[pc + 1].block;\n \tif (b != NULL\n \t    && BLOCK_FUNCTION (b) != NULL\n-\t    && SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)) != NULL)\n+\t    && BLOCK_FUNCTION (b)->print_name () != NULL)\n \t  {\n-\t    fputs_filtered (SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)), stream);\n+\t    fputs_filtered (BLOCK_FUNCTION (b)->print_name (), stream);\n \t    fputs_filtered (\"::\", stream);\n \t  }\n-\tfputs_filtered (SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol), stream);\n+\tfputs_filtered (exp->elts[pc + 2].symbol->print_name (), stream);\n       }\n       return;\n \n@@ -154,7 +154,7 @@ print_subexp_standard (struct expression *exp, int *pos,\n       {\n \t(*pos) += 2;\n \tfprintf_filtered (stream, \"%s@entry\",\n-\t\t\t  SYMBOL_PRINT_NAME (exp->elts[pc + 1].symbol));\n+\t\t\t  exp->elts[pc + 1].symbol->print_name ());\n       }\n       return;\n \n@@ -899,7 +899,7 @@ dump_subexp_body_standard (struct expression *exp,\n       fprintf_filtered (stream, \", symbol @\");\n       gdb_print_host_address (exp->elts[elt + 1].symbol, stream);\n       fprintf_filtered (stream, \" (%s)\",\n-\t\t\tSYMBOL_PRINT_NAME (exp->elts[elt + 1].symbol));\n+\t\t\texp->elts[elt + 1].symbol->print_name ());\n       elt += 3;\n       break;\n     case OP_VAR_MSYM_VALUE:\n@@ -915,7 +915,7 @@ dump_subexp_body_standard (struct expression *exp,\n       fprintf_filtered (stream, \"Entry value of symbol @\");\n       gdb_print_host_address (exp->elts[elt].symbol, stream);\n       fprintf_filtered (stream, \" (%s)\",\n-\t\t\tSYMBOL_PRINT_NAME (exp->elts[elt].symbol));\n+\t\t\texp->elts[elt].symbol->print_name ());\n       elt += 2;\n       break;\n     case OP_LAST:"
    },
    {
      "sha": "d5515c8f8fec041f8dfc97bcd6d6293b31e4b119",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -387,17 +387,17 @@ info_common_command_for_block (const struct block *block, const char *comname,\n \n \tgdb_assert (SYMBOL_CLASS (sym) == LOC_COMMON_BLOCK);\n \n-\tif (comname && (!SYMBOL_LINKAGE_NAME (sym)\n-\t                || strcmp (comname, SYMBOL_LINKAGE_NAME (sym)) != 0))\n+\tif (comname && (!sym->linkage_name ()\n+\t                || strcmp (comname, sym->linkage_name ()) != 0))\n \t  continue;\n \n \tif (*any_printed)\n \t  putchar_filtered ('\\n');\n \telse\n \t  *any_printed = 1;\n-\tif (SYMBOL_PRINT_NAME (sym))\n+\tif (sym->print_name ())\n \t  printf_filtered (_(\"Contents of F77 COMMON block '%s':\\n\"),\n-\t\t\t   SYMBOL_PRINT_NAME (sym));\n+\t\t\t   sym->print_name ());\n \telse\n \t  printf_filtered (_(\"Contents of blank COMMON block:\\n\"));\n \t\n@@ -406,7 +406,7 @@ info_common_command_for_block (const struct block *block, const char *comname,\n \t    struct value *val = NULL;\n \n \t    printf_filtered (\"%s = \",\n-\t\t\t     SYMBOL_PRINT_NAME (common->contents[index]));\n+\t\t\t     common->contents[index]->print_name ());\n \n \t    try\n \t      {"
    },
    {
      "sha": "50e99f48d1f0bdeab800dde111e074d074223f40",
      "filename": "gdb/findvar.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/findvar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/findvar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/findvar.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -566,9 +566,9 @@ get_hosting_frame (struct symbol *var, const struct block *var_block,\n \t{\n \t  if (BLOCK_FUNCTION (var_block)\n \t      && !block_inlined_p (var_block)\n-\t      && SYMBOL_PRINT_NAME (BLOCK_FUNCTION (var_block)))\n+\t      && BLOCK_FUNCTION (var_block)->print_name ())\n \t    error (_(\"No frame is currently executing in block %s.\"),\n-\t\t   SYMBOL_PRINT_NAME (BLOCK_FUNCTION (var_block)));\n+\t\t   BLOCK_FUNCTION (var_block)->print_name ());\n \t  else\n \t    error (_(\"No frame is currently executing in specified\"\n \t\t     \" block\"));\n@@ -601,7 +601,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n   if (sym_need == SYMBOL_NEEDS_FRAME)\n     gdb_assert (frame != NULL);\n   else if (sym_need == SYMBOL_NEEDS_REGISTERS && !target_has_registers)\n-    error (_(\"Cannot read `%s' without registers\"), SYMBOL_PRINT_NAME (var));\n+    error (_(\"Cannot read `%s' without registers\"), var->print_name ());\n \n   if (frame != NULL)\n     frame = get_hosting_frame (var, var_block, frame);\n@@ -668,7 +668,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n       addr = get_frame_args_address (frame);\n       if (!addr)\n \terror (_(\"Unknown argument list address for `%s'.\"),\n-\t       SYMBOL_PRINT_NAME (var));\n+\t       var->print_name ());\n       addr += SYMBOL_VALUE (var);\n       break;\n \n@@ -680,7 +680,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n \targref = get_frame_args_address (frame);\n \tif (!argref)\n \t  error (_(\"Unknown argument list address for `%s'.\"),\n-\t\t SYMBOL_PRINT_NAME (var));\n+\t\t var->print_name ());\n \targref += SYMBOL_VALUE (var);\n \tref = value_at (lookup_pointer_type (type), argref);\n \taddr = value_as_address (ref);\n@@ -694,7 +694,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n \n     case LOC_TYPEDEF:\n       error (_(\"Cannot look up value of a typedef `%s'.\"),\n-\t     SYMBOL_PRINT_NAME (var));\n+\t     var->print_name ());\n       break;\n \n     case LOC_BLOCK:\n@@ -721,7 +721,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n \n \t    if (regval == NULL)\n \t      error (_(\"Value of register variable not available for `%s'.\"),\n-\t             SYMBOL_PRINT_NAME (var));\n+\t             var->print_name ());\n \n \t    addr = value_as_address (regval);\n \t  }\n@@ -731,7 +731,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n \n \t    if (regval == NULL)\n \t      error (_(\"Value of register variable not available for `%s'.\"),\n-\t             SYMBOL_PRINT_NAME (var));\n+\t             var->print_name ());\n \t    return regval;\n \t  }\n       }\n@@ -747,7 +747,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n \tstruct obj_section *obj_section;\n \n \tmemset (&lookup_data, 0, sizeof (lookup_data));\n-\tlookup_data.name = SYMBOL_LINKAGE_NAME (var);\n+\tlookup_data.name = var->linkage_name ();\n \n \tgdbarch_iterate_over_objfiles_in_search_order\n \t  (symbol_arch (var),\n@@ -767,7 +767,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n \t       can't be NULL.  */\n \t    gdb_assert (flavour_name != NULL);\n \t    error (_(\"Missing %s symbol \\\"%s\\\".\"),\n-\t\t   flavour_name, SYMBOL_LINKAGE_NAME (var));\n+\t\t   flavour_name, var->linkage_name ());\n \t  }\n \tobj_section = MSYMBOL_OBJ_SECTION (lookup_data.result.objfile, msym);\n \t/* Relocate address, unless there is no section or the variable is\n@@ -793,7 +793,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n \n     default:\n       error (_(\"Cannot look up value of a botched symbol `%s'.\"),\n-\t     SYMBOL_PRINT_NAME (var));\n+\t     var->print_name ());\n       break;\n     }\n "
    },
    {
      "sha": "bf2eb1b6f71696940cc380f111701caff70ece42",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -411,7 +411,7 @@ go_sniff_from_mangled_name (const char *mangled, char **demangled)\n char *\n go_symbol_package_name (const struct symbol *sym)\n {\n-  const char *mangled_name = SYMBOL_LINKAGE_NAME (sym);\n+  const char *mangled_name = sym->linkage_name ();\n   const char *package_name;\n   const char *object_name;\n   const char *method_type_package_name;"
    },
    {
      "sha": "20037b2e66c8ad44d3998d127ee68bfdfca14f57",
      "filename": "gdb/guile/scm-block.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/guile/scm-block.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/guile/scm-block.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-block.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -157,7 +157,7 @@ bkscm_print_block_smob (SCM self, SCM port, scm_print_state *pstate)\n     gdbscm_printf (port, \" static\");\n \n   if (BLOCK_FUNCTION (b) != NULL)\n-    gdbscm_printf (port, \" %s\", SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)));\n+    gdbscm_printf (port, \" %s\", BLOCK_FUNCTION (b)->print_name ());\n \n   gdbscm_printf (port, \" %s-%s\",\n \t\t hex_string (BLOCK_START (b)), hex_string (BLOCK_END (b)));"
    },
    {
      "sha": "c1b3635deac888df9638c6741724887734acf2d4",
      "filename": "gdb/guile/scm-symbol.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/guile/scm-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/guile/scm-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-symbol.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -157,7 +157,7 @@ syscm_print_symbol_smob (SCM self, SCM port, scm_print_state *pstate)\n     gdbscm_printf (port, \"#<%s \", symbol_smob_name);\n   gdbscm_printf (port, \"%s\",\n \t\t s_smob->symbol != NULL\n-\t\t ? SYMBOL_PRINT_NAME (s_smob->symbol)\n+\t\t ? s_smob->symbol->print_name ()\n \t\t : \"<invalid>\");\n   if (pstate->writingp)\n     scm_puts (\">\", port);\n@@ -376,7 +376,7 @@ gdbscm_symbol_name (SCM self)\n     = syscm_get_valid_symbol_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   const struct symbol *symbol = s_smob->symbol;\n \n-  return gdbscm_scm_from_c_string (SYMBOL_NATURAL_NAME (symbol));\n+  return gdbscm_scm_from_c_string (symbol->natural_name ());\n }\n \n /* (symbol-linkage-name <gdb:symbol>) -> string */\n@@ -388,7 +388,7 @@ gdbscm_symbol_linkage_name (SCM self)\n     = syscm_get_valid_symbol_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   const struct symbol *symbol = s_smob->symbol;\n \n-  return gdbscm_scm_from_c_string (SYMBOL_LINKAGE_NAME (symbol));\n+  return gdbscm_scm_from_c_string (symbol->linkage_name ());\n }\n \n /* (symbol-print-name <gdb:symbol>) -> string */\n@@ -400,7 +400,7 @@ gdbscm_symbol_print_name (SCM self)\n     = syscm_get_valid_symbol_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   const struct symbol *symbol = s_smob->symbol;\n \n-  return gdbscm_scm_from_c_string (SYMBOL_PRINT_NAME (symbol));\n+  return gdbscm_scm_from_c_string (symbol->print_name ());\n }\n \n /* (symbol-addr-class <gdb:symbol>) -> integer */"
    },
    {
      "sha": "5553fc9779179b32504b8382ee168437b0dd960f",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -387,7 +387,7 @@ get_function_name (CORE_ADDR funaddr, char *buf, int buf_size)\n     struct symbol *symbol = find_pc_function (funaddr);\n \n     if (symbol)\n-      return SYMBOL_PRINT_NAME (symbol);\n+      return symbol->print_name ();\n   }\n \n   {"
    },
    {
      "sha": "2a253469e745774c468a194697d42f745e03c1a3",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1210,7 +1210,7 @@ jump_command (const char *arg, int from_tty)\n   if (fn != NULL && sfn != fn)\n     {\n       if (!query (_(\"Line %d is not in `%s'.  Jump anyway? \"), sal.line,\n-\t\t  SYMBOL_PRINT_NAME (fn)))\n+\t\t  fn->print_name ()))\n \t{\n \t  error (_(\"Not confirmed.\"));\n \t  /* NOTREACHED */\n@@ -1939,7 +1939,7 @@ finish_command (const char *arg, int from_tty)\n \t  if (sm->function != NULL && TYPE_NO_RETURN (sm->function->type)\n \t      && !query (_(\"warning: Function %s does not return normally.\\n\"\n \t\t\t   \"Try to finish anyway? \"),\n-\t\t\t SYMBOL_PRINT_NAME (sm->function)))\n+\t\t\t sm->function->print_name ()))\n \t    error (_(\"Not confirmed.\"));\n \t  printf_filtered (_(\"Run till exit from \"));\n \t}"
    },
    {
      "sha": "37186745dbf58af3f0f6f0b111e2752b7677a916",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -7281,7 +7281,7 @@ insert_exception_resume_breakpoint (struct thread_info *tp,\n       CORE_ADDR handler;\n       struct breakpoint *bp;\n \n-      vsym = lookup_symbol_search_name (SYMBOL_SEARCH_NAME (sym),\n+      vsym = lookup_symbol_search_name (sym->search_name (),\n \t\t\t\t\tb, VAR_DOMAIN);\n       value = read_var_value (vsym.symbol, vsym.block, frame);\n       /* If the value was optimized out, revert to the old behavior.  */"
    },
    {
      "sha": "61dcb4830e29821a5fdf5fc347fad30e0ff80a35",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -2066,8 +2066,7 @@ canonicalize_linespec (struct linespec_state *state, const linespec_p ls)\n \t  gdb_assert (!ls->labels.function_symbols->empty ()\n \t\t      && (ls->labels.function_symbols->size () == 1));\n \t  block_symbol s = ls->labels.function_symbols->front ();\n-\t  explicit_loc->function_name\n-\t    = xstrdup (SYMBOL_NATURAL_NAME (s.symbol));\n+\t  explicit_loc->function_name = xstrdup (s.symbol->natural_name ());\n \t}\n     }\n \n@@ -2195,7 +2194,7 @@ create_sals_line_offset (struct linespec_state *self,\n \t      skip_prologue_sal (&intermediate_results[i]);\n \t    intermediate_results[i].symbol = sym;\n \t    add_sal_to_sals (self, &values, &intermediate_results[i],\n-\t\t\t     sym ? SYMBOL_NATURAL_NAME (sym) : NULL, 0);\n+\t\t\t     sym ? sym->natural_name () : NULL, 0);\n \t  }\n     }\n \n@@ -2250,7 +2249,7 @@ convert_linespec_to_sals (struct linespec_state *state, linespec_p ls)\n \t  if (symbol_to_sal (&sal, state->funfirstline, sym.symbol)\n \t      && maybe_add_address (state->addr_set, pspace, sal.pc))\n \t    add_sal_to_sals (state, &sals, &sal,\n-\t\t\t     SYMBOL_NATURAL_NAME (sym.symbol), 0);\n+\t\t\t     sym.symbol->natural_name (), 0);\n \t}\n     }\n   else if (ls->function_symbols != NULL || ls->minimal_symbols != NULL)\n@@ -2315,7 +2314,7 @@ convert_linespec_to_sals (struct linespec_state *state, linespec_p ls)\n \t\t  if (symbol_to_sal (&sal, state->funfirstline, sym.symbol)\n \t\t      && maybe_add_address (state->addr_set, pspace, sal.pc))\n \t\t    add_sal_to_sals (state, &sals, &sal,\n-\t\t\t\t     SYMBOL_NATURAL_NAME (sym.symbol), 0);\n+\t\t\t\t     sym.symbol->natural_name (), 0);\n \t\t}\n \t    }\n \t}\n@@ -2903,7 +2902,7 @@ complete_label (completion_tracker &tracker,\n     {\n       for (const auto &label : *labels)\n \t{\n-\t  char *match = xstrdup (SYMBOL_SEARCH_NAME (label.symbol));\n+\t  char *match = xstrdup (label.symbol->search_name ());\n \t  tracker.add_completion (gdb::unique_xmalloc_ptr<char> (match));\n \t}\n       delete labels;\n@@ -4001,7 +4000,7 @@ find_label_symbols_in_block (const struct block *block,\n \t{\n \t  if (symbol_matches_domain (SYMBOL_LANGUAGE (sym),\n \t\t\t\t     SYMBOL_DOMAIN (sym), LABEL_DOMAIN)\n-\t      && cmp (SYMBOL_SEARCH_NAME (sym), name, name_len) == 0)\n+\t      && cmp (sym->search_name (), name, name_len) == 0)\n \t    {\n \t      result->push_back ({sym, block});\n \t      label_funcs_ret->push_back ({fn_sym, block});"
    },
    {
      "sha": "41cdc87f409c3936701ee31e89d7bead8140a400",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -165,8 +165,8 @@ m2_print_typedef (struct type *type, struct symbol *new_symbol,\n   fprintf_filtered (stream, \"TYPE \");\n   if (!TYPE_NAME (SYMBOL_TYPE (new_symbol))\n       || strcmp (TYPE_NAME ((SYMBOL_TYPE (new_symbol))),\n-\t\t SYMBOL_LINKAGE_NAME (new_symbol)) != 0)\n-    fprintf_filtered (stream, \"%s = \", SYMBOL_PRINT_NAME (new_symbol));\n+\t\t new_symbol->linkage_name ()) != 0)\n+    fprintf_filtered (stream, \"%s = \", new_symbol->print_name ());\n   else\n     fprintf_filtered (stream, \"<builtin> = \");\n   type_print (type, \"\", stream, 0);"
    },
    {
      "sha": "c58e40c94a007c08e809eff315273f07900f68ec",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -541,7 +541,7 @@ mdebug_reg_to_regnum (struct symbol *sym, struct gdbarch *gdbarch)\n   if (regno < 0 || regno >= gdbarch_num_cooked_regs (gdbarch))\n     {\n       reg_value_complaint (regno, gdbarch_num_cooked_regs (gdbarch),\n-\t\t\t   SYMBOL_PRINT_NAME (sym));\n+\t\t\t   sym->print_name ());\n \n       regno = gdbarch_sp_regnum (gdbarch); /* Known safe, though useless.  */\n     }\n@@ -646,7 +646,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t  /* It is a FORTRAN common block.  At least for SGI Fortran the\n \t     address is not in the symbol; we need to fix it later in\n \t     scan_file_globals.  */\n-\t  int bucket = hashname (SYMBOL_LINKAGE_NAME (s));\n+\t  int bucket = hashname (s->linkage_name ());\n \t  SYMBOL_VALUE_CHAIN (s) = global_sym_chain[bucket];\n \t  global_sym_chain[bucket] = s;\n \t}\n@@ -1334,7 +1334,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t         for anything except pointers or functions.  */\n \t    }\n \t  else\n-\t    TYPE_NAME (SYMBOL_TYPE (s)) = SYMBOL_LINKAGE_NAME (s);\n+\t    TYPE_NAME (SYMBOL_TYPE (s)) = s->linkage_name ();\n \t}\n       break;\n \n@@ -4489,10 +4489,10 @@ mylookup_symbol (const char *name, const struct block *block,\n   inc = name[0];\n   ALL_BLOCK_SYMBOLS (block, iter, sym)\n     {\n-      if (SYMBOL_LINKAGE_NAME (sym)[0] == inc\n+      if (sym->linkage_name ()[0] == inc\n \t  && SYMBOL_DOMAIN (sym) == domain\n \t  && SYMBOL_CLASS (sym) == theclass\n-\t  && strcmp (SYMBOL_LINKAGE_NAME (sym), name) == 0)\n+\t  && strcmp (sym->linkage_name (), name) == 0)\n \treturn sym;\n     }\n "
    },
    {
      "sha": "50843313f856846e04a99a29077e167fff9add2f",
      "filename": "gdb/mi/mi-cmd-stack.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/mi/mi-cmd-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/mi/mi-cmd-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-stack.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -515,7 +515,7 @@ list_arg_or_local (const struct frame_arg *arg, enum what_to_list what,\n \n   string_file stb;\n \n-  stb.puts (SYMBOL_PRINT_NAME (arg->sym));\n+  stb.puts (arg->sym->print_name ());\n   if (arg->entry_kind == print_entry_values_only)\n     stb.puts (\"@entry\");\n   uiout->field_stream (\"name\", stb);\n@@ -634,7 +634,7 @@ list_args_or_locals (const frame_print_options &fp_opts,\n \t      struct frame_arg arg, entryarg;\n \n \t      if (SYMBOL_IS_ARGUMENT (sym))\n-\t\tsym2 = lookup_symbol (SYMBOL_LINKAGE_NAME (sym),\n+\t\tsym2 = lookup_symbol (sym->linkage_name (),\n \t\t\t\t      block, VAR_DOMAIN,\n \t\t\t\t      NULL).symbol;\n \t      else"
    },
    {
      "sha": "e2a6e800b55e8bcf01f2ebd649a919b7a8dba87b",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -537,8 +537,8 @@ compare_selectors (const void *a, const void *b)\n {\n   const char *aname, *bname;\n \n-  aname = SYMBOL_PRINT_NAME (*(struct symbol **) a);\n-  bname = SYMBOL_PRINT_NAME (*(struct symbol **) b);\n+  aname = (*(struct symbol **) a)->print_name ();\n+  bname = (*(struct symbol **) b)->print_name ();\n   if (aname == NULL || bname == NULL)\n     error (_(\"internal: compare_selectors(1)\"));\n \n@@ -675,7 +675,7 @@ info_selectors_command (const char *regexp, int from_tty)\n \t  char *p = asel;\n \n \t  QUIT;\n-\t  name = SYMBOL_NATURAL_NAME (sym_arr[ix]);\n+\t  name = sym_arr[ix]->natural_name ();\n \t  name = strchr (name, ' ') + 1;\n \t  if (p[0] && specialcmp(name, p) == 0)\n \t    continue;\t\t/* Seen this one already (not unique).  */\n@@ -706,8 +706,8 @@ compare_classes (const void *a, const void *b)\n {\n   const char *aname, *bname;\n \n-  aname = SYMBOL_PRINT_NAME (*(struct symbol **) a);\n-  bname = SYMBOL_PRINT_NAME (*(struct symbol **) b);\n+  aname = (*(struct symbol **) a)->print_name ();\n+  bname = (*(struct symbol **) b)->print_name ();\n   if (aname == NULL || bname == NULL)\n     error (_(\"internal: compare_classes(1)\"));\n \n@@ -809,7 +809,7 @@ info_classes_command (const char *regexp, int from_tty)\n \t  char *p = aclass;\n \n \t  QUIT;\n-\t  name = SYMBOL_NATURAL_NAME (sym_arr[ix]);\n+\t  name = sym_arr[ix]->natural_name ();\n \t  name += 2;\n \t  if (p[0] && specialcmp(name, p) == 0)\n \t    continue;\t/* Seen this one already (not unique).  */\n@@ -1145,7 +1145,7 @@ find_imps (const char *method, std::vector<const char *> *symbol_names)\n \t\t\t\t\t  0).symbol;\n \n       if (sym != NULL) \n-\tsymbol_names->push_back (SYMBOL_NATURAL_NAME (sym));\n+\tsymbol_names->push_back (sym->natural_name ());\n       else\n \t{\n \t  struct bound_minimal_symbol msym"
    },
    {
      "sha": "f501aad549b97b7a206e24cf426e8e14556d47ac",
      "filename": "gdb/p-typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/p-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/p-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-typeprint.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -99,7 +99,7 @@ pascal_print_typedef (struct type *type, struct symbol *new_symbol,\n {\n   type = check_typedef (type);\n   fprintf_filtered (stream, \"type \");\n-  fprintf_filtered (stream, \"%s = \", SYMBOL_PRINT_NAME (new_symbol));\n+  fprintf_filtered (stream, \"%s = \", new_symbol->print_name ());\n   type_print (type, \"\", stream, 0);\n   fprintf_filtered (stream, \";\");\n }"
    },
    {
      "sha": "fe0efd371a536404d2066fa5359e33f9e9c4df4c",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -628,9 +628,9 @@ build_address_symbolic (struct gdbarch *gdbarch,\n \n       name_location = BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (symbol));\n       if (do_demangle || asm_demangle)\n-\tname_temp = SYMBOL_PRINT_NAME (symbol);\n+\tname_temp = symbol->print_name ();\n       else\n-\tname_temp = SYMBOL_LINKAGE_NAME (symbol);\n+\tname_temp = symbol->linkage_name ();\n     }\n \n   if (msymbol.minsym != NULL\n@@ -1472,7 +1472,7 @@ info_address_command (const char *exp, int from_tty)\n     }\n \n   printf_filtered (\"Symbol \\\"\");\n-  fprintf_symbol_filtered (gdb_stdout, SYMBOL_PRINT_NAME (sym),\n+  fprintf_symbol_filtered (gdb_stdout, sym->print_name (),\n \t\t\t   current_language->la_language, DMGL_ANSI);\n   printf_filtered (\"\\\" is \");\n   val = SYMBOL_VALUE (sym);\n@@ -1592,7 +1592,7 @@ info_address_command (const char *exp, int from_tty)\n       {\n \tstruct bound_minimal_symbol msym;\n \n-\tmsym = lookup_bound_minimal_symbol (SYMBOL_LINKAGE_NAME (sym));\n+\tmsym = lookup_bound_minimal_symbol (sym->linkage_name ());\n \tif (msym.minsym == NULL)\n \t  printf_filtered (\"unresolved\");\n \telse\n@@ -2214,7 +2214,7 @@ print_variable_and_value (const char *name, struct symbol *var,\n {\n \n   if (!name)\n-    name = SYMBOL_PRINT_NAME (var);\n+    name = var->print_name ();\n \n   fprintf_filtered (stream, \"%s%ps = \", n_spaces (2 * indent),\n \t\t    styled_string (variable_name_style.style (), name));"
    },
    {
      "sha": "8e38d8d7a454927c4b0840c0726f0c5c24989e69",
      "filename": "gdb/python/py-framefilter.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/python/py-framefilter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/python/py-framefilter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-framefilter.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -103,7 +103,7 @@ extract_sym (PyObject *obj, gdb::unique_xmalloc_ptr<char> *name,\n \n       /* Duplicate the symbol name, so the caller has consistency\n \t in garbage collection.  */\n-      name->reset (xstrdup (SYMBOL_PRINT_NAME (*sym)));\n+      name->reset (xstrdup ((*sym)->print_name ()));\n \n       /* If a symbol is specified attempt to determine the language\n \t from the symbol.  If mode is not \"auto\", then the language\n@@ -348,14 +348,14 @@ py_print_single_arg (struct ui_out *out,\n     {\n       string_file stb;\n \n-      fprintf_symbol_filtered (&stb, SYMBOL_PRINT_NAME (fa->sym),\n+      fprintf_symbol_filtered (&stb, fa->sym->print_name (),\n \t\t\t       SYMBOL_LANGUAGE (fa->sym),\n \t\t\t       DMGL_PARAMS | DMGL_ANSI);\n       if (fa->entry_kind == print_entry_values_compact)\n \t{\n \t  stb.puts (\"=\");\n \n-\t  fprintf_symbol_filtered (&stb, SYMBOL_PRINT_NAME (fa->sym),\n+\t  fprintf_symbol_filtered (&stb, fa->sym->print_name (),\n \t\t\t\t   SYMBOL_LANGUAGE (fa->sym),\n \t\t\t\t   DMGL_PARAMS | DMGL_ANSI);\n \t}"
    },
    {
      "sha": "e79fbd06d28d93797f43c622b812e6a88912f1bf",
      "filename": "gdb/python/py-symbol.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/python/py-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/python/py-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-symbol.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -60,7 +60,7 @@ sympy_str (PyObject *self)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  result = PyString_FromString (SYMBOL_PRINT_NAME (symbol));\n+  result = PyString_FromString (symbol->print_name ());\n \n   return result;\n }\n@@ -101,7 +101,7 @@ sympy_get_name (PyObject *self, void *closure)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  return PyString_FromString (SYMBOL_NATURAL_NAME (symbol));\n+  return PyString_FromString (symbol->natural_name ());\n }\n \n static PyObject *\n@@ -111,7 +111,7 @@ sympy_get_linkage_name (PyObject *self, void *closure)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  return PyString_FromString (SYMBOL_LINKAGE_NAME (symbol));\n+  return PyString_FromString (symbol->linkage_name ());\n }\n \n static PyObject *"
    },
    {
      "sha": "7b561a1c35f099f0e0d5a2d83f6e3d487e4a4319",
      "filename": "gdb/python/python.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/python/python.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/python/python.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/python.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -791,7 +791,7 @@ gdbpy_rbreak (PyObject *self, PyObject *args, PyObject *kw)\n \n \t  symbol_name = fullname;\n \t  symbol_name  += \":\";\n-\t  symbol_name  += SYMBOL_LINKAGE_NAME (p.symbol);\n+\t  symbol_name  += p.symbol->linkage_name ();\n \t}\n       else\n \tsymbol_name = p.msymbol.minsym->linkage_name ();"
    },
    {
      "sha": "459d0da84027d2e5a2fc37764e1ba42620eb2f14",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1115,7 +1115,7 @@ btrace_get_bfun_name (const struct btrace_function *bfun)\n   sym = bfun->sym;\n \n   if (sym != NULL)\n-    return SYMBOL_PRINT_NAME (sym);\n+    return sym->print_name ();\n   else if (msym != NULL)\n     return msym->print_name ();\n   else\n@@ -1175,7 +1175,7 @@ btrace_call_history (struct ui_out *uiout,\n \t}\n \n       if (sym != NULL)\n-\tuiout->field_string (\"function\", SYMBOL_PRINT_NAME (sym),\n+\tuiout->field_string (\"function\", sym->print_name (),\n \t\t\t     function_name_style.style ());\n       else if (msym != NULL)\n \tuiout->field_string (\"function\", msym->print_name (),"
    },
    {
      "sha": "f9adb5d07cccf65812e96ae9a2d690e1edd73547",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -829,7 +829,7 @@ rust_print_typedef (struct type *type,\n \t\t    struct ui_file *stream)\n {\n   type = check_typedef (type);\n-  fprintf_filtered (stream, \"type %s = \", SYMBOL_PRINT_NAME (new_symbol));\n+  fprintf_filtered (stream, \"type %s = \", new_symbol->print_name ());\n   type_print (type, \"\", stream, 0);\n   fprintf_filtered (stream, \";\");\n }"
    },
    {
      "sha": "13d14122e5f464f3a7f4d869740364a97e786756",
      "filename": "gdb/solib-frv.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/solib-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/solib-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-frv.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -959,7 +959,7 @@ frv_fdpic_find_canonical_descriptor (CORE_ADDR entry_point)\n   if (sym == 0)\n     name = 0;\n   else\n-    name = SYMBOL_LINKAGE_NAME (sym);\n+    name = sym->linkage_name ();\n \n   /* Check the main executable.  */\n   addr = find_canonical_descriptor_in_load_object"
    },
    {
      "sha": "6ec9f971e16076ef8bb6b052199ca2b9b47d4cb1",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 26,
      "deletions": 36,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -629,7 +629,7 @@ stab_reg_to_regnum (struct symbol *sym, struct gdbarch *gdbarch)\n   if (regno < 0 || regno >= gdbarch_num_cooked_regs (gdbarch))\n     {\n       reg_value_complaint (regno, gdbarch_num_cooked_regs (gdbarch),\n-\t\t\t   SYMBOL_PRINT_NAME (sym));\n+\t\t\t   sym->print_name ());\n \n       regno = gdbarch_sp_regnum (gdbarch); /* Known safe, though useless.  */\n     }\n@@ -1039,9 +1039,9 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n          Symbol references don't have valid names and wont't match up with\n          minimal symbols when the global_sym_chain is relocated.\n          We'll fixup symbol references when we fixup the defining symbol.  */\n-      if (SYMBOL_LINKAGE_NAME (sym) && SYMBOL_LINKAGE_NAME (sym)[0] != '#')\n+      if (sym->linkage_name () && sym->linkage_name ()[0] != '#')\n \t{\n-\t  i = hashname (SYMBOL_LINKAGE_NAME (sym));\n+\t  i = hashname (sym->linkage_name ());\n \t  SYMBOL_VALUE_CHAIN (sym) = global_sym_chain[i];\n \t  global_sym_chain[i] = sym;\n \t}\n@@ -1142,8 +1142,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t     the same name to represent an argument passed in a\n \t     register.  GCC uses 'P' for the same case.  So if we find\n \t     such a symbol pair we combine it into one 'P' symbol.\n-\t     For Sun cc we need to do this regardless of\n-\t     stabs_argument_has_addr, because the compiler puts out\n+\t     For Sun cc we need to do this regardless of stabs_argument_has_addr, because the compiler puts out\n \t     the 'p' symbol even if it never saves the argument onto\n \t     the stack.\n \n@@ -1168,8 +1167,8 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t      prev_sym = local_symbols->symbol[local_symbols->nsyms - 1];\n \t      if ((SYMBOL_CLASS (prev_sym) == LOC_REF_ARG\n \t\t   || SYMBOL_CLASS (prev_sym) == LOC_ARG)\n-\t\t  && strcmp (SYMBOL_LINKAGE_NAME (prev_sym),\n-\t\t\t     SYMBOL_LINKAGE_NAME (sym)) == 0)\n+\t\t  && strcmp (prev_sym->linkage_name (),\n+\t\t\t     sym->linkage_name ()) == 0)\n \t\t{\n \t\t  SYMBOL_ACLASS_INDEX (prev_sym) = stab_register_index;\n \t\t  /* Use the type from the LOC_REGISTER; that is the type\n@@ -1192,18 +1191,16 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n       SET_SYMBOL_VALUE_ADDRESS (sym, valu);\n       if (gdbarch_static_transform_name_p (gdbarch)\n-\t  && gdbarch_static_transform_name (gdbarch,\n-\t\t\t\t\t    SYMBOL_LINKAGE_NAME (sym))\n-\t     != SYMBOL_LINKAGE_NAME (sym))\n+\t  && gdbarch_static_transform_name (gdbarch, sym->linkage_name ())\n+\t     != sym->linkage_name ())\n \t{\n \t  struct bound_minimal_symbol msym;\n \n-\t  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym),\n-\t\t\t\t\tNULL, objfile);\n+\t  msym = lookup_minimal_symbol (sym->linkage_name (), NULL, objfile);\n \t  if (msym.minsym != NULL)\n \t    {\n \t      const char *new_name = gdbarch_static_transform_name\n-\t\t(gdbarch, SYMBOL_LINKAGE_NAME (sym));\n+\t\t(gdbarch, sym->linkage_name ());\n \n \t      SYMBOL_SET_LINKAGE_NAME (sym, new_name);\n \t      SET_SYMBOL_VALUE_ADDRESS (sym,\n@@ -1262,7 +1259,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       if (TYPE_NAME (SYMBOL_TYPE (sym)) == NULL)\n \t{\n \t  if ((TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR\n-\t       && strcmp (SYMBOL_LINKAGE_NAME (sym), vtbl_ptr_name))\n+\t       && strcmp (sym->linkage_name (), vtbl_ptr_name))\n \t      || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FUNC)\n \t    {\n \t      /* If we are giving a name to a type such as \"pointer to\n@@ -1303,11 +1300,11 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t      /* Pascal accepts names for pointer types.  */\n \t      if (get_current_subfile ()->language == language_pascal)\n \t\t{\n-\t\t  TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_LINKAGE_NAME (sym);\n+\t\t  TYPE_NAME (SYMBOL_TYPE (sym)) = sym->linkage_name ();\n           \t}\n \t    }\n \t  else\n-\t    TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_LINKAGE_NAME (sym);\n+\t    TYPE_NAME (SYMBOL_TYPE (sym)) = sym->linkage_name ();\n \t}\n \n       add_symbol_to_list (sym, get_file_symbols ());\n@@ -1323,8 +1320,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n           SYMBOL_DOMAIN (struct_sym) = STRUCT_DOMAIN;\n           if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n             TYPE_NAME (SYMBOL_TYPE (sym))\n-\t      = obconcat (&objfile->objfile_obstack,\n-\t\t\t  SYMBOL_LINKAGE_NAME (sym),\n+\t      = obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t\t  (char *) NULL);\n           add_symbol_to_list (struct_sym, get_file_symbols ());\n         }\n@@ -1351,8 +1347,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n       if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n \tTYPE_NAME (SYMBOL_TYPE (sym))\n-\t  = obconcat (&objfile->objfile_obstack,\n-\t\t      SYMBOL_LINKAGE_NAME (sym),\n+\t  = obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t      (char *) NULL);\n       add_symbol_to_list (sym, get_file_symbols ());\n \n@@ -1367,8 +1362,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;\n \t  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n \t    TYPE_NAME (SYMBOL_TYPE (sym))\n-\t      = obconcat (&objfile->objfile_obstack,\n-\t\t\t  SYMBOL_LINKAGE_NAME (sym),\n+\t      = obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t\t  (char *) NULL);\n \t  add_symbol_to_list (typedef_sym, get_file_symbols ());\n \t}\n@@ -1380,18 +1374,16 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n       SET_SYMBOL_VALUE_ADDRESS (sym, valu);\n       if (gdbarch_static_transform_name_p (gdbarch)\n-\t  && gdbarch_static_transform_name (gdbarch,\n-\t\t\t\t\t    SYMBOL_LINKAGE_NAME (sym))\n-\t     != SYMBOL_LINKAGE_NAME (sym))\n+\t  && gdbarch_static_transform_name (gdbarch, sym->linkage_name ())\n+\t     != sym->linkage_name ())\n \t{\n \t  struct bound_minimal_symbol msym;\n \n-\t  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym), \n-\t\t\t\t\tNULL, objfile);\n+\t  msym = lookup_minimal_symbol (sym->linkage_name (), NULL, objfile);\n \t  if (msym.minsym != NULL)\n \t    {\n \t      const char *new_name = gdbarch_static_transform_name\n-\t\t(gdbarch, SYMBOL_LINKAGE_NAME (sym));\n+\t\t(gdbarch, sym->linkage_name ());\n \n \t      SYMBOL_SET_LINKAGE_NAME (sym, new_name);\n \t      SET_SYMBOL_VALUE_ADDRESS (sym, BMSYMBOL_VALUE_ADDRESS (msym));\n@@ -1684,7 +1676,7 @@ read_type (const char **pp, struct objfile *objfile)\n \t      if (SYMBOL_CLASS (sym) == LOC_TYPEDEF\n \t\t  && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN\n \t\t  && (TYPE_CODE (SYMBOL_TYPE (sym)) == code)\n-\t\t  && strcmp (SYMBOL_LINKAGE_NAME (sym), type_name) == 0)\n+\t\t  && strcmp (sym->linkage_name (), type_name) == 0)\n \t\t{\n \t\t  obstack_free (&objfile->objfile_obstack, type_name);\n \t\t  type = SYMBOL_TYPE (sym);\n@@ -3692,7 +3684,7 @@ read_enum_type (const char **pp, struct type *type,\n \t  struct symbol *xsym = syms->symbol[j];\n \n \t  SYMBOL_TYPE (xsym) = type;\n-\t  TYPE_FIELD_NAME (type, n) = SYMBOL_LINKAGE_NAME (xsym);\n+\t  TYPE_FIELD_NAME (type, n) = xsym->linkage_name ();\n \t  SET_FIELD_ENUMVAL (TYPE_FIELD (type, n), SYMBOL_VALUE (xsym));\n \t  TYPE_FIELD_BITSIZE (type, n) = 0;\n \t}\n@@ -4341,7 +4333,7 @@ common_block_end (struct objfile *objfile)\n   /* Should we be putting local_symbols back to what it was?\n      Does it matter?  */\n \n-  i = hashname (SYMBOL_LINKAGE_NAME (sym));\n+  i = hashname (sym->linkage_name ());\n   SYMBOL_VALUE_CHAIN (sym) = global_sym_chain[i];\n   global_sym_chain[i] = sym;\n   common_block_name = NULL;\n@@ -4527,8 +4519,7 @@ cleanup_undefined_types_1 (void)\n \t\t\t\tTYPE_CODE (*type))\n \t\t\t    && (TYPE_INSTANCE_FLAGS (*type) ==\n \t\t\t\tTYPE_INSTANCE_FLAGS (SYMBOL_TYPE (sym)))\n-\t\t\t    && strcmp (SYMBOL_LINKAGE_NAME (sym),\n-\t\t\t\t       type_name) == 0)\n+\t\t\t    && strcmp (sym->linkage_name (), type_name) == 0)\n                           replace_type (*type, SYMBOL_TYPE (sym));\n \t\t      }\n \t\t  }\n@@ -4614,8 +4605,7 @@ scan_file_globals (struct objfile *objfile)\n \n \t  for (sym = global_sym_chain[hash]; sym;)\n \t    {\n-\t      if (strcmp (msymbol->linkage_name (),\n-\t\t\t  SYMBOL_LINKAGE_NAME (sym)) == 0)\n+\t      if (strcmp (msymbol->linkage_name (), sym->linkage_name ()) == 0)\n \t\t{\n \t\t  /* Splice this symbol out of the hash chain and\n \t\t     assign the value we have to it.  */\n@@ -4689,7 +4679,7 @@ scan_file_globals (struct objfile *objfile)\n \t  else\n \t    complaint (_(\"%s: common block `%s' from \"\n \t\t\t \"global_sym_chain unresolved\"),\n-\t\t       objfile_name (objfile), SYMBOL_PRINT_NAME (prev));\n+\t\t       objfile_name (objfile), prev->print_name ());\n \t}\n     }\n   memset (global_sym_chain, 0, sizeof (global_sym_chain));"
    },
    {
      "sha": "5099f613666fb30dd0c624369057bb5db6999d07",
      "filename": "gdb/stack.c",
      "status": "modified",
      "additions": 15,
      "deletions": 16,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stack.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -427,15 +427,15 @@ print_frame_arg (const frame_print_options &fp_opts,\n \n   annotate_arg_emitter arg_emitter;\n   ui_out_emit_tuple tuple_emitter (uiout, NULL);\n-  fprintf_symbol_filtered (&stb, SYMBOL_PRINT_NAME (arg->sym),\n+  fprintf_symbol_filtered (&stb, arg->sym->print_name (),\n \t\t\t   SYMBOL_LANGUAGE (arg->sym), DMGL_PARAMS | DMGL_ANSI);\n   if (arg->entry_kind == print_entry_values_compact)\n     {\n       /* It is OK to provide invalid MI-like stream as with\n \t PRINT_ENTRY_VALUE_COMPACT we never use MI.  */\n       stb.puts (\"=\");\n \n-      fprintf_symbol_filtered (&stb, SYMBOL_PRINT_NAME (arg->sym),\n+      fprintf_symbol_filtered (&stb, arg->sym->print_name (),\n \t\t\t       SYMBOL_LANGUAGE (arg->sym),\n \t\t\t       DMGL_PARAMS | DMGL_ANSI);\n     }\n@@ -817,11 +817,11 @@ print_frame_args (const frame_print_options &fp_opts,\n \t     parameter names occur on the RS/6000, for traceback\n \t     tables.  FIXME, should we even print them?  */\n \n-\t  if (*SYMBOL_LINKAGE_NAME (sym))\n+\t  if (*sym->linkage_name ())\n \t    {\n \t      struct symbol *nsym;\n \n-\t      nsym = lookup_symbol_search_name (SYMBOL_SEARCH_NAME (sym),\n+\t      nsym = lookup_symbol_search_name (sym->search_name (),\n \t\t\t\t\t\tb, VAR_DOMAIN).symbol;\n \t      gdb_assert (nsym != NULL);\n \t      if (SYMBOL_CLASS (nsym) == LOC_REGISTER\n@@ -1259,14 +1259,14 @@ find_frame_funname (struct frame_info *frame, enum language *funlang,\n   func = get_frame_function (frame);\n   if (func)\n     {\n-      const char *print_name = SYMBOL_PRINT_NAME (func);\n+      const char *print_name = func->print_name ();\n \n       *funlang = SYMBOL_LANGUAGE (func);\n       if (funcp)\n \t*funcp = func;\n       if (*funlang == language_cplus)\n \t{\n-\t  /* It seems appropriate to use SYMBOL_PRINT_NAME() here,\n+\t  /* It seems appropriate to use print_name() here,\n \t     to display the demangled name that we already have\n \t     stored in the symbol table, but we stored a version\n \t     with DMGL_PARAMS turned on, and here we don't want to\n@@ -1494,11 +1494,11 @@ info_frame_command_core (struct frame_info *fi, bool selected_frame_p)\n   gdb::unique_xmalloc_ptr<char> func_only;\n   if (func)\n     {\n-      funname = SYMBOL_PRINT_NAME (func);\n+      funname = func->print_name ();\n       funlang = SYMBOL_LANGUAGE (func);\n       if (funlang == language_cplus)\n \t{\n-\t  /* It seems appropriate to use SYMBOL_PRINT_NAME() here,\n+\t  /* It seems appropriate to use print_name() here,\n \t     to display the demangled name that we already have\n \t     stored in the symbol table, but we stored a version\n \t     with DMGL_PARAMS turned on, and here we don't want to\n@@ -2246,7 +2246,7 @@ iterate_over_block_locals (const struct block *b,\n \t    break;\n \t  if (SYMBOL_DOMAIN (sym) == COMMON_BLOCK_DOMAIN)\n \t    break;\n-\t  (*cb) (SYMBOL_PRINT_NAME (sym), sym, cb_data);\n+\t  (*cb) (sym->print_name (), sym, cb_data);\n \t  break;\n \n \tdefault:\n@@ -2276,7 +2276,7 @@ print_block_frame_labels (struct gdbarch *gdbarch, struct block *b,\n \n   ALL_BLOCK_SYMBOLS (b, iter, sym)\n     {\n-      if (strcmp (SYMBOL_LINKAGE_NAME (sym), \"default\") == 0)\n+      if (strcmp (sym->linkage_name (), \"default\") == 0)\n \t{\n \t  if (*have_default)\n \t    continue;\n@@ -2289,7 +2289,7 @@ print_block_frame_labels (struct gdbarch *gdbarch, struct block *b,\n \n \t  sal = find_pc_line (SYMBOL_VALUE_ADDRESS (sym), 0);\n \t  values_printed = 1;\n-\t  fputs_filtered (SYMBOL_PRINT_NAME (sym), stream);\n+\t  fputs_filtered (sym->print_name (), stream);\n \t  get_user_print_options (&opts);\n \t  if (opts.addressprint)\n \t    {\n@@ -2351,8 +2351,7 @@ do_print_variable_and_value (const char *print_name,\n   struct frame_info *frame;\n \n   if (p->preg.has_value ()\n-      && p->preg->exec (SYMBOL_NATURAL_NAME (sym), 0,\n-\t\t\tNULL, 0) != 0)\n+      && p->preg->exec (sym->natural_name (), 0, NULL, 0) != 0)\n     return;\n   if (p->treg.has_value ()\n       && !treg_matches_sym_type_name (*p->treg, sym))\n@@ -2554,9 +2553,9 @@ iterate_over_block_arg_vars (const struct block *b,\n \t     float).  There are also LOC_ARG/LOC_REGISTER pairs which\n \t     are not combined in symbol-reading.  */\n \n-\t  sym2 = lookup_symbol_search_name (SYMBOL_SEARCH_NAME (sym),\n+\t  sym2 = lookup_symbol_search_name (sym->search_name (),\n \t\t\t\t\t    b, VAR_DOMAIN).symbol;\n-\t  (*cb) (SYMBOL_PRINT_NAME (sym), sym2, cb_data);\n+\t  (*cb) (sym->print_name (), sym2, cb_data);\n \t}\n     }\n }\n@@ -2856,7 +2855,7 @@ return_command (const char *retval_exp, int from_tty)\n \t  if (TYPE_NO_RETURN (thisfun->type))\n \t    warning (_(\"Function does not return normally to caller.\"));\n \t  confirmed = query (_(\"%sMake %s return now? \"), query_prefix,\n-\t\t\t     SYMBOL_PRINT_NAME (thisfun));\n+\t\t\t     thisfun->print_name ());\n \t}\n       if (!confirmed)\n \terror (_(\"Not confirmed\"));"
    },
    {
      "sha": "69d035dc84387b75044abd69a91ddadc78421949",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -339,11 +339,11 @@ dump_symtab_1 (struct symtab *symtab, struct ui_file *outfile)\n \t  if (BLOCK_FUNCTION (b))\n \t    {\n \t      fprintf_filtered (outfile, \", function %s\",\n-\t\t\t\tSYMBOL_LINKAGE_NAME (BLOCK_FUNCTION (b)));\n-\t      if (SYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)) != NULL)\n+\t\t\t\tBLOCK_FUNCTION (b)->linkage_name ());\n+\t      if (BLOCK_FUNCTION (b)->demangled_name () != NULL)\n \t\t{\n \t\t  fprintf_filtered (outfile, \", %s\",\n-\t\t\t\tSYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)));\n+\t\t\t\tBLOCK_FUNCTION (b)->demangled_name ());\n \t\t}\n \t    }\n \t  fprintf_filtered (outfile, \"\\n\");\n@@ -523,7 +523,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n   print_spaces (depth, outfile);\n   if (SYMBOL_DOMAIN (symbol) == LABEL_DOMAIN)\n     {\n-      fprintf_filtered (outfile, \"label %s at \", SYMBOL_PRINT_NAME (symbol));\n+      fprintf_filtered (outfile, \"label %s at \", symbol->print_name ());\n       fputs_filtered (paddress (gdbarch, SYMBOL_VALUE_ADDRESS (symbol)),\n \t\t      outfile);\n       if (section)\n@@ -548,7 +548,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \t\t\t  ? \"enum\"\n \t\t     : (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_STRUCT\n \t\t\t? \"struct\" : \"union\")),\n-\t\t\t    SYMBOL_LINKAGE_NAME (symbol));\n+\t\t\t    symbol->linkage_name ());\n \t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), \"\", outfile, 1, depth,\n \t\t\t &type_print_raw_options);\n \t}\n@@ -561,15 +561,15 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n       if (SYMBOL_TYPE (symbol))\n \t{\n \t  /* Print details of types, except for enums where it's clutter.  */\n-\t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), SYMBOL_PRINT_NAME (symbol),\n+\t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), symbol->print_name (),\n \t\t\t outfile,\n \t\t\t TYPE_CODE (SYMBOL_TYPE (symbol)) != TYPE_CODE_ENUM,\n \t\t\t depth,\n \t\t\t &type_print_raw_options);\n \t  fprintf_filtered (outfile, \"; \");\n \t}\n       else\n-\tfprintf_filtered (outfile, \"%s \", SYMBOL_PRINT_NAME (symbol));\n+\tfprintf_filtered (outfile, \"%s \", symbol->print_name ());\n \n       switch (SYMBOL_CLASS (symbol))\n \t{"
    },
    {
      "sha": "2e8ae2383ed24b71168d8a6234ea5360c16bc571",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 19,
      "deletions": 21,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1151,7 +1151,7 @@ eq_symbol_entry (const struct symbol_cache_slot *slot,\n     }\n   else\n     {\n-      slot_name = SYMBOL_SEARCH_NAME (slot->value.found.symbol);\n+      slot_name = slot->value.found.symbol->search_name ();\n       slot_domain = SYMBOL_DOMAIN (slot->value.found.symbol);\n     }\n \n@@ -1168,7 +1168,7 @@ eq_symbol_entry (const struct symbol_cache_slot *slot,\n       /* It's important that we use the same comparison that was done\n \t the first time through.  If the slot records a found symbol,\n \t then this means using the symbol name comparison function of\n-\t the symbol's language with SYMBOL_SEARCH_NAME.  See\n+\t the symbol's language with symbol->search_name ().  See\n \t dictionary.c.  It also means using symbol_matches_domain for\n \t found symbols.  See block.c.\n \n@@ -1517,7 +1517,7 @@ symbol_cache_dump (const struct symbol_cache *cache)\n \n \t\tprintf_filtered (\"  [%4u] = %s, %s %s\\n\", i,\n \t\t\t\t host_address_to_string (context),\n-\t\t\t\t SYMBOL_PRINT_NAME (found),\n+\t\t\t\t found->print_name (),\n \t\t\t\t domain_name (SYMBOL_DOMAIN (found)));\n \t\tbreak;\n \t      }\n@@ -1950,7 +1950,7 @@ lookup_language_this (const struct language_defn *lang,\n \t  if (symbol_lookup_debug > 1)\n \t    {\n \t      fprintf_unfiltered (gdb_stdlog, \" = %s (%s, block %s)\\n\",\n-\t\t\t\t  SYMBOL_PRINT_NAME (sym),\n+\t\t\t\t  sym->print_name (),\n \t\t\t\t  host_address_to_string (sym),\n \t\t\t\t  host_address_to_string (block));\n \t    }\n@@ -3136,15 +3136,15 @@ find_pc_sect_line (CORE_ADDR pc, struct obj_section *section, int notcurrent)\n \t   * but the \"break\" still works, and the warning is annoying.\n \t   * So I commented out the warning.  RT */\n \t  /* warning (\"In stub for %s; unable to find real function/line info\",\n-\t     SYMBOL_LINKAGE_NAME (msymbol)); */\n+\t     msymbol->linkage_name ()); */\n \t  ;\n \t/* fall through */\n \telse if (BMSYMBOL_VALUE_ADDRESS (mfunsym)\n \t\t == BMSYMBOL_VALUE_ADDRESS (msymbol))\n \t  /* Avoid infinite recursion */\n \t  /* See above comment about why warning is commented out.  */\n \t  /* warning (\"In stub for %s; unable to find real function/line info\",\n-\t     SYMBOL_LINKAGE_NAME (msymbol)); */\n+\t     msymbol->linkage_name ()); */\n \t  ;\n \t/* fall through */\n \telse\n@@ -3715,7 +3715,7 @@ skip_prologue_sal (struct symtab_and_line *sal)\n       objfile = symbol_objfile (sym);\n       pc = BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (sym));\n       section = SYMBOL_OBJ_SECTION (objfile, sym);\n-      name = SYMBOL_LINKAGE_NAME (sym);\n+      name = sym->linkage_name ();\n     }\n   else\n     {\n@@ -4384,8 +4384,7 @@ symbol_search::compare_search_syms (const symbol_search &sym_a,\n   if (sym_a.block != sym_b.block)\n     return sym_a.block - sym_b.block;\n \n-  return strcmp (SYMBOL_PRINT_NAME (sym_a.symbol),\n-\t\t SYMBOL_PRINT_NAME (sym_b.symbol));\n+  return strcmp (sym_a.symbol->print_name (), sym_b.symbol->print_name ());\n }\n \n /* Returns true if the type_name of symbol_type of SYM matches TREG.\n@@ -4402,7 +4401,7 @@ treg_matches_sym_type_name (const compiled_regex &treg,\n     {\n       fprintf_unfiltered (gdb_stdlog,\n \t\t\t  \"treg_matches_sym_type_name\\n     sym %s\\n\",\n-\t\t\t  SYMBOL_NATURAL_NAME (sym));\n+\t\t\t  sym->natural_name ());\n     }\n \n   sym_type = SYMBOL_TYPE (sym);\n@@ -4639,7 +4638,7 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t\t\t   && file_matches (symtab_to_fullname (real_symtab),\n \t\t\t\t\t    files, nfiles, 0)))\n \t\t      && ((!preg.has_value ()\n-\t\t\t   || preg->exec (SYMBOL_NATURAL_NAME (sym), 0,\n+\t\t\t   || preg->exec (sym->natural_name (), 0,\n \t\t\t\t\t  NULL, 0) == 0)\n \t\t\t  && ((kind == VARIABLES_DOMAIN\n \t\t\t       && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n@@ -4787,7 +4786,7 @@ print_symbol_info (enum search_domain kind,\n     {\n       type_print (SYMBOL_TYPE (sym),\n \t\t  (SYMBOL_CLASS (sym) == LOC_TYPEDEF\n-\t\t   ? \"\" : SYMBOL_PRINT_NAME (sym)),\n+\t\t   ? \"\" : sym->print_name ()),\n \t\t  gdb_stdout, 0);\n \n       printf_filtered (\";\\n\");\n@@ -4796,7 +4795,7 @@ print_symbol_info (enum search_domain kind,\n      point we might want a language specific method to print the module\n      symbol so that we can customise the output more.  */\n   else if (kind == MODULES_DOMAIN)\n-    printf_filtered (\"%s\\n\", SYMBOL_PRINT_NAME (sym));\n+    printf_filtered (\"%s\\n\", sym->print_name ());\n }\n \n /* This help function for symtab_symbol_info() prints information\n@@ -5128,7 +5127,7 @@ rbreak_command (const char *regexp, int from_tty)\n \t  const char *fullname = symtab_to_fullname (symtab);\n \n \t  string = string_printf (\"%s:'%s'\", fullname,\n-\t\t\t\t  SYMBOL_LINKAGE_NAME (p.symbol));\n+\t\t\t\t  p.symbol->linkage_name ());\n \t  break_command (&string[0], from_tty);\n \t  print_symbol_info (FUNCTIONS_DOMAIN, p.symbol, p.block, NULL);\n \t}\n@@ -5209,7 +5208,7 @@ completion_list_add_symbol (completion_tracker &tracker,\n \t\t\t    const char *text, const char *word)\n {\n   completion_list_add_name (tracker, SYMBOL_LANGUAGE (sym),\n-\t\t\t    SYMBOL_NATURAL_NAME (sym),\n+\t\t\t    sym->natural_name (),\n \t\t\t    lookup_name, text, word);\n }\n \n@@ -5401,7 +5400,7 @@ find_gnu_ifunc (const symbol *sym)\n   if (SYMBOL_CLASS (sym) != LOC_BLOCK)\n     return {};\n \n-  lookup_name_info lookup_name (SYMBOL_SEARCH_NAME (sym),\n+  lookup_name_info lookup_name (sym->search_name (),\n \t\t\t\tsymbol_name_match_type::SEARCH_NAME);\n   struct objfile *objfile = symbol_objfile (sym);\n \n@@ -6291,7 +6290,7 @@ get_symbol_address (const struct symbol *sym)\n   gdb_assert (sym->maybe_copied);\n   gdb_assert (SYMBOL_CLASS (sym) == LOC_STATIC);\n \n-  const char *linkage_name = SYMBOL_LINKAGE_NAME (sym);\n+  const char *linkage_name = sym->linkage_name ();\n \n   for (objfile *objfile : current_program_space->objfiles ())\n     {\n@@ -6372,15 +6371,15 @@ search_module_symbols (const char *module_regexp, const char *regexp,\n       /* This is a module.  */\n       gdb_assert (p.symbol != nullptr);\n \n-      std::string prefix = SYMBOL_PRINT_NAME (p.symbol);\n+      std::string prefix = p.symbol->print_name ();\n       prefix += \"::\";\n \n       for (const symbol_search &q : symbols)\n \t{\n \t  if (q.symbol == nullptr)\n \t    continue;\n \n-\t  if (strncmp (SYMBOL_PRINT_NAME (q.symbol), prefix.c_str (),\n+\t  if (strncmp (q.symbol->print_name (), prefix.c_str (),\n \t\t       prefix.size ()) != 0)\n \t    continue;\n \n@@ -6523,8 +6522,7 @@ info_module_subcommand (bool quiet, const char *module_regexp,\n       if (last_module_symbol != p.symbol)\n \t{\n \t  printf_filtered (\"\\n\");\n-\t  printf_filtered (_(\"Module \\\"%s\\\":\\n\"),\n-\t\t\t   SYMBOL_PRINT_NAME (p.symbol));\n+\t  printf_filtered (_(\"Module \\\"%s\\\":\\n\"), p.symbol->print_name ());\n \t  last_module_symbol = p.symbol;\n \t  last_filename = \"\";\n \t}"
    },
    {
      "sha": "897ffda76e2ceb7066cb7afefd142485d7a331a4",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 2,
      "deletions": 40,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -67,7 +67,7 @@ enum class symbol_name_match_type\n \n   /* Search name matching.  This is like FULL, but the search name did\n      not come from the user; instead it is already a search name\n-     retrieved from a SYMBOL_SEARCH_NAME/search_name () call.\n+     retrieved from a search_name () call.\n      For Ada, this avoids re-encoding an already-encoded search name\n      (which would potentially incorrectly lowercase letters in the\n      linkage/search name that should remain uppercase).  For C++, it\n@@ -546,43 +546,6 @@ extern void symbol_set_names (struct general_symbol_info *symbol,\n \t\t\t      gdb::string_view linkage_name, bool copy_name,\n \t\t\t      struct objfile_per_bfd_storage *per_bfd);\n \n-/* Now come lots of name accessor macros.  Short version as to when to\n-   use which: Use SYMBOL_NATURAL_NAME to refer to the name of the\n-   symbol in the original source code.  Use SYMBOL_LINKAGE_NAME if you\n-   want to know what the linker thinks the symbol's name is.  Use\n-   SYMBOL_PRINT_NAME for output.  Use SYMBOL_DEMANGLED_NAME if you\n-   specifically need to know whether SYMBOL_NATURAL_NAME and\n-   SYMBOL_LINKAGE_NAME are different.  */\n-\n-#define SYMBOL_NATURAL_NAME(symbol) \\\n-  ((symbol)->natural_name ())\n-\n-/* Return SYMBOL's name from the point of view of the linker.  In\n-   languages like C++ where symbols may be mangled for ease of\n-   manipulation by the linker, this is the mangled name; otherwise,\n-   it's the same as SYMBOL_NATURAL_NAME.  */\n-\n-#define SYMBOL_LINKAGE_NAME(symbol)\t(symbol)->name\n-\n-#define SYMBOL_DEMANGLED_NAME(symbol) \\\n-  ((symbol)->demangled_name ())\n-\n-/* Macro that returns a version of the name of a symbol that is\n-   suitable for output.  In C++ this is the \"demangled\" form of the\n-   name if demangle is on and the \"mangled\" form of the name if\n-   demangle is off.  In other languages this is just the symbol name.\n-   The result should never be NULL.  Don't use this for internal\n-   purposes (e.g. storing in a hashtable): it's only suitable for output.\n-\n-   N.B. symbol may be anything inheriting from general_symbol_info,\n-   e.g., struct symbol or struct minimal_symbol.  */\n-\n-#define SYMBOL_PRINT_NAME(symbol)\t\t\t\t\t\\\n-  (demangle ? SYMBOL_NATURAL_NAME (symbol) : SYMBOL_LINKAGE_NAME (symbol))\n-\n-#define SYMBOL_SEARCH_NAME(symbol)\t\t\t\t\t \\\n-   ((symbol)->search_name ())\n-\n /* Return true if NAME matches the \"search\" name of SYMBOL, according\n    to the symbol's language.  */\n #define SYMBOL_MATCHES_SEARCH_NAME(symbol, name)                       \\\n@@ -1640,8 +1603,7 @@ extern struct block_symbol lookup_symbol (const char *,\n    DOMAIN, visible from lexical block BLOCK if non-NULL or from\n    global/static blocks if BLOCK is NULL.  The passed-in search name\n    should not come from the user; instead it should already be a\n-   search name as retrieved from a\n-   SYMBOL_SEARCH_NAME/search_name () call.  See definition of\n+   search name as retrieved from a search_name () call.  See definition of\n    symbol_name_match_type::SEARCH_NAME.  Returns the struct symbol\n    pointer, or NULL if no symbol is found.  The symbol's section is\n    fixed up if necessary.  */"
    },
    {
      "sha": "8e04cad504e9a039c51204bfe9021ef818d7967a",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 18,
      "deletions": 24,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -236,11 +236,11 @@ set_traceframe_context (struct frame_info *trace_frame)\n   /* Save func name as \"$trace_func\", a debugger variable visible to\n      users.  */\n   if (traceframe_fun == NULL\n-      || SYMBOL_LINKAGE_NAME (traceframe_fun) == NULL)\n+      || traceframe_fun->linkage_name () == NULL)\n     clear_internalvar (lookup_internalvar (\"trace_func\"));\n   else\n     set_internalvar_string (lookup_internalvar (\"trace_func\"),\n-\t\t\t    SYMBOL_LINKAGE_NAME (traceframe_fun));\n+\t\t\t    traceframe_fun->linkage_name ());\n \n   /* Save file name as \"$trace_file\", a debugger variable visible to\n      users.  */\n@@ -693,15 +693,15 @@ validate_actionline (const char *line, struct breakpoint *b)\n \t\t    {\n \t\t      error (_(\"constant `%s' (value %s) \"\n \t\t\t       \"will not be collected.\"),\n-\t\t\t     SYMBOL_PRINT_NAME (exp->elts[2].symbol),\n+\t\t\t     exp->elts[2].symbol->print_name (),\n \t\t\t     plongest (SYMBOL_VALUE (exp->elts[2].symbol)));\n \t\t    }\n \t\t  else if (SYMBOL_CLASS (exp->elts[2].symbol)\n \t\t\t   == LOC_OPTIMIZED_OUT)\n \t\t    {\n \t\t      error (_(\"`%s' is optimized away \"\n \t\t\t       \"and cannot be collected.\"),\n-\t\t\t     SYMBOL_PRINT_NAME (exp->elts[2].symbol));\n+\t\t\t     exp->elts[2].symbol->print_name ());\n \t\t    }\n \t\t}\n \n@@ -926,19 +926,18 @@ collection_list::collect_symbol (struct symbol *sym,\n     {\n     default:\n       printf_filtered (\"%s: don't know symbol class %d\\n\",\n-\t\t       SYMBOL_PRINT_NAME (sym),\n-\t\t       SYMBOL_CLASS (sym));\n+\t\t       sym->print_name (), SYMBOL_CLASS (sym));\n       break;\n     case LOC_CONST:\n       printf_filtered (\"constant %s (value %s) will not be collected.\\n\",\n-\t\t       SYMBOL_PRINT_NAME (sym), plongest (SYMBOL_VALUE (sym)));\n+\t\t       sym->print_name (), plongest (SYMBOL_VALUE (sym)));\n       break;\n     case LOC_STATIC:\n       offset = SYMBOL_VALUE_ADDRESS (sym);\n       if (info_verbose)\n \t{\n \t  printf_filtered (\"LOC_STATIC %s: collect %ld bytes at %s.\\n\",\n-\t\t\t   SYMBOL_PRINT_NAME (sym), len,\n+\t\t\t   sym->print_name (), len,\n \t\t\t   paddress (gdbarch, offset));\n \t}\n       /* A struct may be a C++ class with static fields, go to general\n@@ -951,8 +950,7 @@ collection_list::collect_symbol (struct symbol *sym,\n     case LOC_REGISTER:\n       reg = SYMBOL_REGISTER_OPS (sym)->register_number (sym, gdbarch);\n       if (info_verbose)\n-\tprintf_filtered (\"LOC_REG[parm] %s: \", \n-\t\t\t SYMBOL_PRINT_NAME (sym));\n+\tprintf_filtered (\"LOC_REG[parm] %s: \", sym->print_name ());\n       add_local_register (gdbarch, reg, scope);\n       /* Check for doubles stored in two registers.  */\n       /* FIXME: how about larger types stored in 3 or more regs?  */\n@@ -962,17 +960,15 @@ collection_list::collect_symbol (struct symbol *sym,\n       break;\n     case LOC_REF_ARG:\n       printf_filtered (\"Sorry, don't know how to do LOC_REF_ARG yet.\\n\");\n-      printf_filtered (\"       (will not collect %s)\\n\",\n-\t\t       SYMBOL_PRINT_NAME (sym));\n+      printf_filtered (\"       (will not collect %s)\\n\", sym->print_name ());\n       break;\n     case LOC_ARG:\n       reg = frame_regno;\n       offset = frame_offset + SYMBOL_VALUE (sym);\n       if (info_verbose)\n \t{\n \t  printf_filtered (\"LOC_LOCAL %s: Collect %ld bytes at offset %s\"\n-\t\t\t   \" from frame ptr reg %d\\n\",\n-\t\t\t   SYMBOL_PRINT_NAME (sym), len,\n+\t\t\t   \" from frame ptr reg %d\\n\", sym->print_name (), len,\n \t\t\t   paddress (gdbarch, offset), reg);\n \t}\n       add_memrange (gdbarch, reg, offset, len, scope);\n@@ -983,8 +979,7 @@ collection_list::collect_symbol (struct symbol *sym,\n       if (info_verbose)\n \t{\n \t  printf_filtered (\"LOC_REGPARM_ADDR %s: Collect %ld bytes at offset %s\"\n-\t\t\t   \" from reg %d\\n\",\n-\t\t\t   SYMBOL_PRINT_NAME (sym), len,\n+\t\t\t   \" from reg %d\\n\", sym->print_name (), len,\n \t\t\t   paddress (gdbarch, offset), reg);\n \t}\n       add_memrange (gdbarch, reg, offset, len, scope);\n@@ -995,8 +990,7 @@ collection_list::collect_symbol (struct symbol *sym,\n       if (info_verbose)\n \t{\n \t  printf_filtered (\"LOC_LOCAL %s: Collect %ld bytes at offset %s\"\n-\t\t\t   \" from frame ptr reg %d\\n\",\n-\t\t\t   SYMBOL_PRINT_NAME (sym), len,\n+\t\t\t   \" from frame ptr reg %d\\n\", sym->print_name (), len,\n \t\t\t   paddress (gdbarch, offset), reg);\n \t}\n       add_memrange (gdbarch, reg, offset, len, scope);\n@@ -1008,7 +1002,7 @@ collection_list::collect_symbol (struct symbol *sym,\n \n     case LOC_OPTIMIZED_OUT:\n       printf_filtered (\"%s has been optimized out of existence.\\n\",\n-\t\t       SYMBOL_PRINT_NAME (sym));\n+\t\t       sym->print_name ());\n       break;\n \n     case LOC_COMPUTED:\n@@ -1028,7 +1022,7 @@ collection_list::collect_symbol (struct symbol *sym,\n       if (!aexpr)\n \t{\n \t  printf_filtered (\"%s has been optimized out of existence.\\n\",\n-\t\t\t   SYMBOL_PRINT_NAME (sym));\n+\t\t\t   sym->print_name ());\n \t  return;\n \t}\n \n@@ -1424,7 +1418,7 @@ encode_actions_1 (struct command_line *action,\n \t\t    case OP_VAR_VALUE:\n \t\t      {\n \t\t\tstruct symbol *sym = exp->elts[2].symbol;\n-\t\t\tconst char *name = SYMBOL_NATURAL_NAME (sym);\n+\t\t\tconst char *name = sym->natural_name ();\n \n \t\t\tcollect->collect_symbol (exp->elts[2].symbol,\n \t\t\t\t\t\t target_gdbarch (),\n@@ -2526,7 +2520,7 @@ info_scope_command (const char *args_in, int from_tty)\n \t    printf_filtered (\"Scope for %s:\\n\", save_args);\n \t  count++;\n \n-\t  symname = SYMBOL_PRINT_NAME (sym);\n+\t  symname = sym->print_name ();\n \t  if (symname == NULL || *symname == '\\0')\n \t    continue;\t\t/* Probably botched, certainly useless.  */\n \n@@ -2616,7 +2610,7 @@ info_scope_command (const char *args_in, int from_tty)\n \t\t\t\t   paddress (gdbarch, BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (sym))));\n \t\t  break;\n \t\tcase LOC_UNRESOLVED:\n-\t\t  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (sym),\n+\t\t  msym = lookup_minimal_symbol (sym->linkage_name (),\n \t\t\t\t\t\tNULL, NULL);\n \t\t  if (msym.minsym == NULL)\n \t\t    printf_filtered (\"Unresolved Static\");\n@@ -3689,7 +3683,7 @@ print_one_static_tracepoint_marker (int count,\n   if (sym)\n     {\n       uiout->text (\"in \");\n-      uiout->field_string (\"func\", SYMBOL_PRINT_NAME (sym),\n+      uiout->field_string (\"func\", sym->print_name (),\n \t\t\t   function_name_style.style ());\n       uiout->wrap_hint (wrap_indent);\n       uiout->text (\" at \");"
    },
    {
      "sha": "ded8096c630fbb5c8b0f925490f2f7cc679287aa",
      "filename": "gdb/typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/typeprint.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -239,7 +239,7 @@ typedef_hash_table::add_template_parameters (struct type *t)\n \tcontinue;\n \n       tf = XOBNEW (&m_storage, struct decl_field);\n-      tf->name = SYMBOL_LINKAGE_NAME (TYPE_TEMPLATE_ARGUMENT (t, i));\n+      tf->name = TYPE_TEMPLATE_ARGUMENT (t, i)->linkage_name ();\n       tf->type = SYMBOL_TYPE (TYPE_TEMPLATE_ARGUMENT (t, i));\n \n       slot = htab_find_slot (m_table, tf, INSERT);"
    },
    {
      "sha": "cbb1f30e71b40882a7bb12f4e3a4fb8810669f6d",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/987012b89bce7f6385ed88585547f852a8005a3f/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/987012b89bce7f6385ed88585547f852a8005a3f/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=987012b89bce7f6385ed88585547f852a8005a3f",
      "patch": "@@ -1330,13 +1330,13 @@ address_of_variable (struct symbol *var, const struct block *b)\n \n \terror (_(\"Address requested for identifier \"\n \t\t \"\\\"%s\\\" which is in register $%s\"),\n-\t       SYMBOL_PRINT_NAME (var), regname);\n+\t       var->print_name (), regname);\n \tbreak;\n       }\n \n     default:\n       error (_(\"Can't take address of \\\"%s\\\" which isn't an lvalue.\"),\n-\t     SYMBOL_PRINT_NAME (var));\n+\t     var->print_name ());\n       break;\n     }\n \n@@ -2644,7 +2644,7 @@ find_overload_match (gdb::array_view<value *> args,\n \n       if (fsym)\n         {\n-          qualified_name = SYMBOL_NATURAL_NAME (fsym);\n+          qualified_name = fsym->natural_name ();\n \n           /* If we have a function with a C++ name, try to extract just\n \t     the function part.  Do not try this for non-functions (e.g.\n@@ -3061,7 +3061,7 @@ find_oload_champ (gdb::array_view<value *> args,\n \t    fprintf_filtered (gdb_stderr,\n \t\t\t      \"Overloaded function instance \"\n \t\t\t      \"%s # of parms %d\\n\",\n-\t\t\t      SYMBOL_DEMANGLED_NAME (functions[ix]),\n+\t\t\t      functions[ix]->demangled_name (),\n \t\t\t      (int) parm_types.size ());\n \t  for (jj = 0; jj < args.size () - static_offset; jj++)\n \t    fprintf_filtered (gdb_stderr,"
    }
  ]
}