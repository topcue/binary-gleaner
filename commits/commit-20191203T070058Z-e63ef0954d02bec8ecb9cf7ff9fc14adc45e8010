{
  "sha": "e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTYzZWYwOTU0ZDAyYmVjOGVjYjljZjdmZjlmYzE0YWRjNDVlODAxMA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-02T13:07:34Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-03T07:00:58Z"
    },
    "message": "PR25230, addr2line fails on dwz output\n\nThis patch remedies the following DW_FORM_GNU_ref_alt related problem:\n      /* FIXME: Do we need to locate the correct CU, in a similar\n        fashion to the code in the DW_FORM_ref_addr case above ?  */\nWithout the correct CU the wrong abbrevs are used, resulting in\nerrors and/or wrong file names.\n\nThere is scope for further work here.  Parsing of CUs should be a two\nstep process, with the first stage just finding the bounds of the CU.\nThis would allow find_abstract_instance to quickly find the CU\nreferenced by DW_FORM_ref_addr or DW_FORM_GNU_ref_alt, then take the\nsecond stage of CU parsing where abbrevs, ranges and suchlike consume\ntime and memory.  As it is, we just process CUs from the start of\n.debug_info until we find the one of interest.  The testcase in the PR\ntakes 98G of virtual memory.\n\n\tPR 25230\n\t* dwarf2.c (struct dwarf2_debug_file): Add line_table and\n\tabbrev_offsets.\n\t(struct abbrev_offset_entry): New.\n\t(hash_abbrev, eq_abbrev, del_abbrev): New functions.\n\t(read_abbrevs): Check whether we have already read abbrevs at\n\tgiven offset, and add new offset/abbrev to hash table.\n\t(decode_line_info): Keep line table at offset zero in file struct.\n\tReturn this for a cu reusing the same dir/file list.\n\t(find_abstract_instance): Find cu for DW_FORM_GNU_ref_alt.\n\t(_bfd_dwarf2_slurp_debug_info): Create offset/abbrev hash tables.\n\t(_bfd_dwarf2_cleanup_debug_info): Adjust deletion of lines and\n\tabbrevs.",
    "tree": {
      "sha": "822465f1f6143252a0c4104d52f1c82483bc6abd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/822465f1f6143252a0c4104d52f1c82483bc6abd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1"
    }
  ],
  "stats": {
    "total": 232,
    "additions": 172,
    "deletions": 60
  },
  "files": [
    {
      "sha": "02c39fa416ef0f17ce6e345b97ddef25ed740912",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010",
      "patch": "@@ -1,3 +1,19 @@\n+2019-12-03  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25230\n+\t* dwarf2.c (struct dwarf2_debug_file): Add line_table and\n+\tabbrev_offsets.\n+\t(struct abbrev_offset_entry): New.\n+\t(hash_abbrev, eq_abbrev, del_abbrev): New functions.\n+\t(read_abbrevs): Check whether we have already read abbrevs at\n+\tgiven offset, and add new offset/abbrev to hash table.\n+\t(decode_line_info): Keep line table at offset zero in file struct.\n+\tReturn this for a cu reusing the same dir/file list.\n+\t(find_abstract_instance): Find cu for DW_FORM_GNU_ref_alt.\n+\t(_bfd_dwarf2_slurp_debug_info): Create offset/abbrev hash tables.\n+\t(_bfd_dwarf2_cleanup_debug_info): Adjust deletion of lines and\n+\tabbrevs.\n+\n 2019-12-03  Alan Modra  <amodra@gmail.com>\n \n \tPR 25230"
    },
    {
      "sha": "c73665c1d88c3bed389fc26b6975d1d958b82641",
      "filename": "bfd/dwarf2.c",
      "status": "modified",
      "additions": 156,
      "deletions": 60,
      "changes": 216,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010/bfd/dwarf2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010/bfd/dwarf2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf2.c?ref=e63ef0954d02bec8ecb9cf7ff9fc14adc45e8010",
      "patch": "@@ -135,6 +135,12 @@ struct dwarf2_debug_file\n \n   /* Last comp unit in list above.  */\n   struct comp_unit *last_comp_unit;\n+\n+  /* Line table at line_offset zero.  */\n+  struct line_info_table *line_table;\n+\n+  /* Hash table to map offsets to decoded abbrevs.  */\n+  htab_t abbrev_offsets;\n };\n \n struct dwarf2_debug\n@@ -929,6 +935,51 @@ lookup_abbrev (unsigned int number, struct abbrev_info **abbrevs)\n   return NULL;\n }\n \n+/* We keep a hash table to map .debug_abbrev section offsets to the\n+   array of abbrevs, so that compilation units using the same set of\n+   abbrevs do not waste memory.  */\n+\n+struct abbrev_offset_entry\n+{\n+  size_t offset;\n+  struct abbrev_info **abbrevs;\n+};\n+\n+static hashval_t\n+hash_abbrev (const void *p)\n+{\n+  const struct abbrev_offset_entry *ent = p;\n+  return htab_hash_pointer ((void *) ent->offset);\n+}\n+\n+static int\n+eq_abbrev (const void *pa, const void *pb)\n+{\n+  const struct abbrev_offset_entry *a = pa;\n+  const struct abbrev_offset_entry *b = pb;\n+  return a->offset == b->offset;\n+}\n+\n+static void\n+del_abbrev (void *p)\n+{\n+  struct abbrev_offset_entry *ent = p;\n+  struct abbrev_info **abbrevs = ent->abbrevs;\n+  size_t i;\n+\n+  for (i = 0; i < ABBREV_HASH_SIZE; i++)\n+    {\n+      struct abbrev_info *abbrev = abbrevs[i];\n+\n+      while (abbrev)\n+\t{\n+\t  free (abbrev->attrs);\n+\t  abbrev = abbrev->next;\n+\t}\n+    }\n+  free (ent);\n+}\n+\n /* In DWARF version 2, the description of the debugging information is\n    stored in a separate .debug_abbrev section.  Before we read any\n    dies from a section we read in all abbreviations and install them\n@@ -945,6 +996,17 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,\n   unsigned int abbrev_number, bytes_read, abbrev_name;\n   unsigned int abbrev_form, hash_number;\n   bfd_size_type amt;\n+  void **slot;\n+  struct abbrev_offset_entry ent = { offset, NULL };\n+\n+  if (ent.offset != offset)\n+    return NULL;\n+\n+  slot = htab_find_slot (file->abbrev_offsets, &ent, INSERT);\n+  if (slot == NULL)\n+    return NULL;\n+  if (*slot != NULL)\n+    return ((struct abbrev_offset_entry *) (*slot))->abbrevs;\n \n   if (! read_section (abfd, &stash->debug_sections[debug_abbrev],\n \t\t      file->syms, offset,\n@@ -1044,6 +1106,12 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,\n       if (lookup_abbrev (abbrev_number, abbrevs) != NULL)\n \tbreak;\n     }\n+\n+  *slot = bfd_malloc (sizeof ent);\n+  if (!*slot)\n+    goto fail;\n+  ent.abbrevs = abbrevs;\n+  memcpy (*slot, &ent, sizeof ent);\n   return abbrevs;\n \n  fail:\n@@ -2025,29 +2093,14 @@ decode_line_info (struct comp_unit *unit)\n   unsigned int exop_len;\n   bfd_size_type amt;\n \n+  if (unit->line_offset == 0 && file->line_table)\n+    return file->line_table;\n+\n   if (! read_section (abfd, &stash->debug_sections[debug_line],\n \t\t      file->syms, unit->line_offset,\n \t\t      &file->dwarf_line_buffer, &file->dwarf_line_size))\n     return NULL;\n \n-  amt = sizeof (struct line_info_table);\n-  table = (struct line_info_table *) bfd_alloc (abfd, amt);\n-  if (table == NULL)\n-    return NULL;\n-  table->abfd = abfd;\n-  table->comp_dir = unit->comp_dir;\n-\n-  table->num_files = 0;\n-  table->files = NULL;\n-\n-  table->num_dirs = 0;\n-  table->dirs = NULL;\n-\n-  table->num_sequences = 0;\n-  table->sequences = NULL;\n-\n-  table->lcl_head = NULL;\n-\n   if (file->dwarf_line_size < 16)\n     {\n       _bfd_error_handler\n@@ -2184,6 +2237,24 @@ decode_line_info (struct comp_unit *unit)\n       line_ptr += 1;\n     }\n \n+  amt = sizeof (struct line_info_table);\n+  table = (struct line_info_table *) bfd_alloc (abfd, amt);\n+  if (table == NULL)\n+    return NULL;\n+  table->abfd = abfd;\n+  table->comp_dir = unit->comp_dir;\n+\n+  table->num_files = 0;\n+  table->files = NULL;\n+\n+  table->num_dirs = 0;\n+  table->dirs = NULL;\n+\n+  table->num_sequences = 0;\n+  table->sequences = NULL;\n+\n+  table->lcl_head = NULL;\n+\n   if (lh.version >= 5)\n     {\n       /* Read directory table.  */\n@@ -2441,6 +2512,8 @@ decode_line_info (struct comp_unit *unit)\n \tfree (filename);\n     }\n \n+  if (unit->line_offset == 0)\n+    file->line_table = table;\n   if (sort_line_sequences (table))\n     return table;\n \n@@ -2818,7 +2891,7 @@ find_abstract_instance (struct comp_unit *unit,\n \t\t\tint *linenumber_ptr)\n {\n   bfd *abfd = unit->abfd;\n-  bfd_byte *info_ptr;\n+  bfd_byte *info_ptr = NULL;\n   bfd_byte *info_ptr_end;\n   unsigned int abbrev_number, bytes_read, i;\n   struct abbrev_info *abbrev;\n@@ -2868,14 +2941,38 @@ find_abstract_instance (struct comp_unit *unit,\n \t  return FALSE;\n \t}\n       info_ptr += die_ref;\n+    }\n+  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n+    {\n+      bfd_boolean first_time = unit->stash->alt.dwarf_info_buffer == NULL;\n+\n+      info_ptr = read_alt_indirect_ref (unit, die_ref);\n+      if (first_time)\n+\tunit->stash->alt.info_ptr = unit->stash->alt.dwarf_info_buffer;\n+      if (info_ptr == NULL)\n+\t{\n+\t  _bfd_error_handler\n+\t    (_(\"DWARF error: unable to read alt ref %\" PRIu64),\n+\t     (uint64_t) die_ref);\n+\t  bfd_set_error (bfd_error_bad_value);\n+\t  return FALSE;\n+\t}\n+      info_ptr_end = (unit->stash->alt.dwarf_info_buffer\n+\t\t      + unit->stash->alt.dwarf_info_size);\n+      if (unit->stash->alt.all_comp_units)\n+\tunit = unit->stash->alt.all_comp_units;\n+    }\n \n+  if (attr_ptr->form == DW_FORM_ref_addr\n+      || attr_ptr->form == DW_FORM_GNU_ref_alt)\n+    {\n       /* Now find the CU containing this pointer.  */\n       if (info_ptr >= unit->info_ptr_unit && info_ptr < unit->end_ptr)\n \tinfo_ptr_end = unit->end_ptr;\n       else\n \t{\n \t  /* Check other CUs to see if they contain the abbrev.  */\n-\t  struct comp_unit * u;\n+\t  struct comp_unit *u;\n \n \t  for (u = unit->prev_unit; u != NULL; u = u->prev_unit)\n \t    if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n@@ -2886,15 +2983,27 @@ find_abstract_instance (struct comp_unit *unit,\n \t      if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n \t\tbreak;\n \n-\t  while (u == NULL)\n-\t    {\n-\t      u = stash_comp_unit (unit->stash, unit->file);\n-\t      if (u == NULL)\n-\t\tbreak;\n-\t      if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n-\t\tbreak;\n-\t      u = NULL;\n-\t    }\n+\t  if (attr_ptr->form == DW_FORM_ref_addr)\n+\t    while (u == NULL)\n+\t      {\n+\t\tu = stash_comp_unit (unit->stash, &unit->stash->f);\n+\t\tif (u == NULL)\n+\t\t  break;\n+\t\tif (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n+\t\t  break;\n+\t\tu = NULL;\n+\t      }\n+\n+\t  if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n+\t    while (u == NULL)\n+\t      {\n+\t\tu = stash_comp_unit (unit->stash, &unit->stash->alt);\n+\t\tif (u == NULL)\n+\t\t  break;\n+\t\tif (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n+\t\t  break;\n+\t\tu = NULL;\n+\t      }\n \n \t  if (u == NULL)\n \t    {\n@@ -2908,23 +3017,6 @@ find_abstract_instance (struct comp_unit *unit,\n \t  info_ptr_end = unit->end_ptr;\n \t}\n     }\n-  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n-    {\n-      info_ptr = read_alt_indirect_ref (unit, die_ref);\n-      if (info_ptr == NULL)\n-\t{\n-\t  _bfd_error_handler\n-\t    (_(\"DWARF error: unable to read alt ref %\" PRIu64),\n-\t     (uint64_t) die_ref);\n-\t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n-\t}\n-      info_ptr_end = (unit->stash->alt.dwarf_info_buffer\n-\t\t      + unit->stash->alt.dwarf_info_size);\n-\n-      /* FIXME: Do we need to locate the correct CU, in a similar\n-\t fashion to the code in the DW_FORM_ref_addr case above ?  */\n-    }\n   else\n     {\n       /* DW_FORM_ref1, DW_FORM_ref2, DW_FORM_ref4, DW_FORM_ref8 or\n@@ -4396,6 +4488,16 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n   if (!save_section_vma (abfd, stash))\n     return FALSE;\n \n+  stash->f.abbrev_offsets = htab_create_alloc (10, hash_abbrev, eq_abbrev,\n+\t\t\t\t\t       del_abbrev, calloc, free);\n+  if (!stash->f.abbrev_offsets)\n+    return FALSE;\n+\n+  stash->alt.abbrev_offsets = htab_create_alloc (10, hash_abbrev, eq_abbrev,\n+\t\t\t\t\t\t del_abbrev, calloc, free);\n+  if (!stash->alt.abbrev_offsets)\n+    return FALSE;\n+\n   *pinfo = stash;\n \n   if (debug_bfd == NULL)\n@@ -4983,23 +5085,10 @@ _bfd_dwarf2_cleanup_debug_info (bfd *abfd, void **pinfo)\n     {\n       for (each = file->all_comp_units; each; each = each->next_unit)\n \t{\n-\t  struct abbrev_info **abbrevs = each->abbrevs;\n \t  struct funcinfo *function_table = each->function_table;\n \t  struct varinfo *variable_table = each->variable_table;\n-\t  size_t i;\n-\n-\t  for (i = 0; i < ABBREV_HASH_SIZE; i++)\n-\t    {\n-\t      struct abbrev_info *abbrev = abbrevs[i];\n-\n-\t      while (abbrev)\n-\t\t{\n-\t\t  free (abbrev->attrs);\n-\t\t  abbrev = abbrev->next;\n-\t\t}\n-\t    }\n \n-\t  if (each->line_table)\n+\t  if (each->line_table && each->line_table != file->line_table)\n \t    {\n \t      free (each->line_table->files);\n \t      free (each->line_table->dirs);\n@@ -5037,6 +5126,13 @@ _bfd_dwarf2_cleanup_debug_info (bfd *abfd, void **pinfo)\n \t    }\n \t}\n \n+      if (file->line_table)\n+\t{\n+\t  free (file->line_table->files);\n+\t  free (file->line_table->dirs);\n+\t}\n+      htab_delete (file->abbrev_offsets);\n+\n       free (file->dwarf_line_str_buffer);\n       free (file->dwarf_str_buffer);\n       free (file->dwarf_ranges_buffer);"
    }
  ]
}