{
  "sha": "7d93a1e0b6af703c75daa93456608f8bb5f34f13",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2Q5M2ExZTBiNmFmNzAzYzc1ZGFhOTM0NTY2MDhmOGJiNWYzNGYxMw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-16T16:16:06Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-16T16:36:05Z"
    },
    "message": "gdb: remove TYPE_NAME macro\n\nRemove `TYPE_NAME`, changing all the call sites to use `type::name`\ndirectly.  This is quite a big diff, but this was mostly done using sed\nand coccinelle.  A few call sites were done by hand.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (TYPE_NAME): Remove.  Change all cal sites to use\n\ttype::name instead.",
    "tree": {
      "sha": "463f7922a76e4a9341095339498726b65be181db",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/463f7922a76e4a9341095339498726b65be181db"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7d93a1e0b6af703c75daa93456608f8bb5f34f13",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d93a1e0b6af703c75daa93456608f8bb5f34f13",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7d93a1e0b6af703c75daa93456608f8bb5f34f13",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d93a1e0b6af703c75daa93456608f8bb5f34f13/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d0e39ea27cde07011967ab74d39cf13dfe3370c4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d0e39ea27cde07011967ab74d39cf13dfe3370c4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d0e39ea27cde07011967ab74d39cf13dfe3370c4"
    }
  ],
  "stats": {
    "total": 665,
    "additions": 334,
    "deletions": 331
  },
  "files": [
    {
      "sha": "aa42a7a35ccdbf8b0fd15684f919e0442ed1e838",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1,3 +1,8 @@\n+2020-05-16  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (TYPE_NAME): Remove.  Change all cal sites to use\n+\ttype::name instead.\n+\n 2020-05-16  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (struct type) <name, set_name>: New methods."
    },
    {
      "sha": "825549d86e9b53a713380a962951a05ff3879c72",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 22,
      "deletions": 23,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -577,7 +577,7 @@ ada_get_field_index (const struct type *type, const char *field_name,\n \n   if (!maybe_missing)\n     error (_(\"Unable to find field %s in struct %s.  Aborting\"),\n-           field_name, TYPE_NAME (struct_type));\n+           field_name, struct_type->name ());\n \n   return -1;\n }\n@@ -1470,8 +1470,8 @@ ada_fixup_array_indexes_type (struct type *index_desc_type)\n      If our INDEX_DESC_TYPE was generated using the older encoding,\n      the field type should be a meaningless integer type whose name\n      is not equal to the field name.  */\n-  if (TYPE_NAME (TYPE_FIELD_TYPE (index_desc_type, 0)) != NULL\n-      && strcmp (TYPE_NAME (TYPE_FIELD_TYPE (index_desc_type, 0)),\n+  if (TYPE_FIELD_TYPE (index_desc_type, 0)->name () != NULL\n+      && strcmp (TYPE_FIELD_TYPE (index_desc_type, 0)->name (),\n                  TYPE_FIELD_NAME (index_desc_type, 0)) == 0)\n     return;\n \n@@ -3405,7 +3405,7 @@ See set/show multiple-symbol.\"));\n \t\t\t       SYMBOL_LINE (syms[i].symbol));\n \t    }\n           else if (is_enumeral\n-                   && TYPE_NAME (SYMBOL_TYPE (syms[i].symbol)) != NULL)\n+                   && SYMBOL_TYPE (syms[i].symbol)->name () != NULL)\n             {\n               printf_filtered ((\"[%d] \"), i + first_choice);\n               ada_print_type (SYMBOL_TYPE (syms[i].symbol), NULL,\n@@ -5158,7 +5158,7 @@ xget_renaming_scope (struct type *renaming_type)\n      So, to extract the scope, we search for the \"___XR\" extension,\n      and then backtrack until we find the first \"__\".  */\n \n-  const char *name = TYPE_NAME (renaming_type);\n+  const char *name = renaming_type->name ();\n   const char *suffix = strstr (name, \"___XR\");\n   const char *last;\n \n@@ -6506,7 +6506,7 @@ ada_is_dispatch_table_ptr_type (struct type *type)\n   if (type->code () != TYPE_CODE_PTR)\n     return 0;\n \n-  name = TYPE_NAME (TYPE_TARGET_TYPE (type));\n+  name = TYPE_TARGET_TYPE (type)->name ();\n   if (name == NULL)\n     return 0;\n \n@@ -6518,7 +6518,7 @@ ada_is_dispatch_table_ptr_type (struct type *type)\n static int\n ada_is_interface_tag (struct type *type)\n {\n-  const char *name = TYPE_NAME (type);\n+  const char *name = type->name ();\n \n   if (name == NULL)\n     return 0;\n@@ -7834,7 +7834,7 @@ ada_prefer_type (struct type *type0, struct type *type1)\n     return 1;\n   else if (type0->code () == TYPE_CODE_VOID)\n     return 0;\n-  else if (TYPE_NAME (type1) == NULL && TYPE_NAME (type0) != NULL)\n+  else if (type1->name () == NULL && type0->name () != NULL)\n     return 1;\n   else if (ada_is_constrained_packed_array_type (type0))\n     return 1;\n@@ -7843,8 +7843,8 @@ ada_prefer_type (struct type *type0, struct type *type1)\n     return 1;\n   else\n     {\n-      const char *type0_name = TYPE_NAME (type0);\n-      const char *type1_name = TYPE_NAME (type1);\n+      const char *type0_name = type0->name ();\n+      const char *type1_name = type1->name ();\n \n       if (type0_name != NULL && strstr (type0_name, \"___XR\") != NULL\n \t  && (type1_name == NULL || strstr (type1_name, \"___XR\") == NULL))\n@@ -7861,7 +7861,7 @@ ada_type_name (struct type *type)\n {\n   if (type == NULL)\n     return NULL;\n-  return TYPE_NAME (type);\n+  return type->name ();\n }\n \n /* Search the list of \"descriptive\" types associated to TYPE for a type\n@@ -8275,9 +8275,9 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n      the current RTYPE length might be good enough for our purposes.  */\n   if (TYPE_LENGTH (type) <= 0)\n     {\n-      if (TYPE_NAME (rtype))\n+      if (rtype->name ())\n \twarning (_(\"Invalid type size for `%s' detected: %s.\"),\n-\t\t TYPE_NAME (rtype), pulongest (TYPE_LENGTH (type)));\n+\t\t rtype->name (), pulongest (TYPE_LENGTH (type)));\n       else\n \twarning (_(\"Invalid type size for <unnamed> detected: %s.\"),\n \t\t pulongest (TYPE_LENGTH (type)));\n@@ -8563,10 +8563,10 @@ ada_is_redundant_range_encoding (struct type *range_type,\n   if (is_dynamic_type (range_type))\n     return 0;\n \n-  if (TYPE_NAME (encoding_type) == NULL)\n+  if (encoding_type->name () == NULL)\n     return 0;\n \n-  bounds_str = strstr (TYPE_NAME (encoding_type), \"___XDLU_\");\n+  bounds_str = strstr (encoding_type->name (), \"___XDLU_\");\n   if (bounds_str == NULL)\n     return 0;\n \n@@ -8734,7 +8734,7 @@ to_fixed_array_type (struct type *type0, struct value *dval,\n   /* We want to preserve the type name.  This can be useful when\n      trying to get the type name of a value that has already been\n      printed (for instance, if the user did \"print VAR; whatis $\".  */\n-  result->set_name (TYPE_NAME (type0));\n+  result->set_name (type0->name ());\n \n   if (constrained_packed_array_p)\n     {\n@@ -9025,11 +9025,11 @@ ada_check_typedef (struct type *type)\n   type = check_typedef (type);\n   if (type == NULL || type->code () != TYPE_CODE_ENUM\n       || !TYPE_STUB (type)\n-      || TYPE_NAME (type) == NULL)\n+      || type->name () == NULL)\n     return type;\n   else\n     {\n-      const char *name = TYPE_NAME (type);\n+      const char *name = type->name ();\n       struct type *type1 = ada_find_any_type (name);\n \n       if (type1 == NULL)\n@@ -11424,8 +11424,7 @@ ada_is_gnat_encoded_fixed_point_type (struct type *type)\n int\n ada_is_system_address_type (struct type *type)\n {\n-  return (TYPE_NAME (type)\n-          && strcmp (TYPE_NAME (type), \"system__address\") == 0);\n+  return (type->name () && strcmp (type->name (), \"system__address\") == 0);\n }\n \n /* Assuming that TYPE is the representation of an Ada fixed-point\n@@ -11593,14 +11592,14 @@ to_fixed_range_type (struct type *raw_type, struct value *dval)\n   const char *subtype_info;\n \n   gdb_assert (raw_type != NULL);\n-  gdb_assert (TYPE_NAME (raw_type) != NULL);\n+  gdb_assert (raw_type->name () != NULL);\n \n   if (raw_type->code () == TYPE_CODE_RANGE)\n     base_type = TYPE_TARGET_TYPE (raw_type);\n   else\n     base_type = raw_type;\n \n-  name = TYPE_NAME (raw_type);\n+  name = raw_type->name ();\n   subtype_info = strstr (name, \"___XD\");\n   if (subtype_info == NULL)\n     {\n@@ -13075,7 +13074,7 @@ catch_assert_command (const char *arg_entry, int from_tty,\n static int\n ada_is_exception_sym (struct symbol *sym)\n {\n-  const char *type_name = TYPE_NAME (SYMBOL_TYPE (sym));\n+  const char *type_name = SYMBOL_TYPE (sym)->name ();\n \n   return (SYMBOL_CLASS (sym) != LOC_TYPEDEF\n           && SYMBOL_CLASS (sym) != LOC_BLOCK"
    },
    {
      "sha": "076c0a63bfa15f14302288fa6a490b1032039a1a",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -180,8 +180,8 @@ print_range (struct type *type, struct ui_file *stream,\n       break;\n     default:\n       fprintf_filtered (stream, \"%.*s\",\n-\t\t\tada_name_prefix_len (TYPE_NAME (type)),\n-\t\t\tTYPE_NAME (type));\n+\t\t\tada_name_prefix_len (type->name ()),\n+\t\t\ttype->name ());\n       break;\n     }\n }\n@@ -267,7 +267,7 @@ print_range_type (struct type *raw_type, struct ui_file *stream,\n   const char *subtype_info;\n \n   gdb_assert (raw_type != NULL);\n-  name = TYPE_NAME (raw_type);\n+  name = raw_type->name ();\n   gdb_assert (name != NULL);\n \n   if (raw_type->code () == TYPE_CODE_RANGE)"
    },
    {
      "sha": "0f389e49cb7e50275de46f7797b79b502985827a",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -520,7 +520,7 @@ gen_fetch (struct agent_expr *ax, struct type *type)\n \t type.  Error out and give callers a chance to handle the failure\n \t gracefully.  */\n       error (_(\"gen_fetch: Unsupported type code `%s'.\"),\n-\t     TYPE_NAME (type));\n+\t     type->name ());\n     }\n }\n \n@@ -1533,7 +1533,7 @@ gen_struct_ref (struct agent_expr *ax, struct axs_value *value,\n   \n   if (!found)\n     error (_(\"Couldn't find member named `%s' in struct/union/class `%s'\"),\n-\t   field, TYPE_NAME (type));\n+\t   field, type->name ());\n }\n \n static int\n@@ -1629,7 +1629,7 @@ gen_namespace_elt (struct agent_expr *ax, struct axs_value *value,\n \n   if (!found)\n     error (_(\"No symbol \\\"%s\\\" in namespace \\\"%s\\\".\"), \n-\t   name, TYPE_NAME (curtype));\n+\t   name, curtype->name ());\n \n   return found;\n }\n@@ -1644,7 +1644,7 @@ static int\n gen_maybe_namespace_elt (struct agent_expr *ax, struct axs_value *value,\n \t\t\t const struct type *curtype, char *name)\n {\n-  const char *namespace_name = TYPE_NAME (curtype);\n+  const char *namespace_name = curtype->name ();\n   struct block_symbol sym;\n \n   sym = cp_lookup_symbol_namespace (namespace_name, name,\n@@ -2354,9 +2354,9 @@ gen_expr_binop_rest (struct expression *exp,\n \t    if (type->code () != TYPE_CODE_ARRAY\n \t\t&& type->code () != TYPE_CODE_PTR)\n \t      {\n-\t\tif (TYPE_NAME (type))\n+\t\tif (type->name ())\n \t\t  error (_(\"cannot subscript something of type `%s'\"),\n-\t\t\t TYPE_NAME (type));\n+\t\t\t type->name ());\n \t\telse\n \t\t  error (_(\"cannot subscript requested type\"));\n \t      }"
    },
    {
      "sha": "e7d0a0dc4ad398f514ccb866b1cd6eb27324c3dc",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1431,13 +1431,13 @@ scalar_type:\n \t\t\t\t\t\t0); }\n \t|\tUNSIGNED type_name\n \t\t\t{ $$ = lookup_unsigned_typename (pstate->language (),\n-\t\t\t\t\t\t\t TYPE_NAME($2.type)); }\n+\t\t\t\t\t\t\t $2.type->name ()); }\n \t|\tUNSIGNED\n \t\t\t{ $$ = lookup_unsigned_typename (pstate->language (),\n \t\t\t\t\t\t\t \"int\"); }\n \t|\tSIGNED_KEYWORD type_name\n \t\t\t{ $$ = lookup_signed_typename (pstate->language (),\n-\t\t\t\t\t\t       TYPE_NAME($2.type)); }\n+\t\t\t\t\t\t       $2.type->name ()); }\n \t|\tSIGNED_KEYWORD\n \t\t\t{ $$ = lookup_signed_typename (pstate->language (),\n \t\t\t\t\t\t       \"int\"); }"
    },
    {
      "sha": "557482f2be446dba0ff24b338d382835fb4a7eaa",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -84,7 +84,7 @@ classify_type (struct type *elttype, struct gdbarch *gdbarch,\n      that would do the wrong thing.  */\n   while (elttype)\n     {\n-      const char *name = TYPE_NAME (elttype);\n+      const char *name = elttype->name ();\n \n       if (elttype->code () == TYPE_CODE_CHAR || !name)\n \t{"
    },
    {
      "sha": "bbe12ccfe871ff27fe8e639a099befff9af99a99",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 28,
      "deletions": 28,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -129,7 +129,7 @@ c_print_type_1 (struct type *type,\n       if ((varstring != NULL && *varstring != '\\0')\n \t  /* Need a space if going to print stars or brackets;\n \t     but not if we will print just a type name.  */\n-\t  || ((show > 0 || TYPE_NAME (type) == 0)\n+\t  || ((show > 0 || type->name () == 0)\n \t      && (code == TYPE_CODE_PTR || code == TYPE_CODE_FUNC\n \t\t  || code == TYPE_CODE_METHOD\n \t\t  || (code == TYPE_CODE_ARRAY\n@@ -206,8 +206,8 @@ c_print_typedef (struct type *type,\n   type = check_typedef (type);\n   fprintf_filtered (stream, \"typedef \");\n   type_print (type, \"\", stream, -1);\n-  if (TYPE_NAME ((SYMBOL_TYPE (new_symbol))) == 0\n-      || strcmp (TYPE_NAME ((SYMBOL_TYPE (new_symbol))),\n+  if ((SYMBOL_TYPE (new_symbol))->name () == 0\n+      || strcmp ((SYMBOL_TYPE (new_symbol))->name (),\n \t\t new_symbol->linkage_name ()) != 0\n       || SYMBOL_TYPE (new_symbol)->code () == TYPE_CODE_TYPEDEF)\n     fprintf_filtered (stream, \" %s\", new_symbol->print_name ());\n@@ -256,7 +256,7 @@ cp_type_print_derivation_info (struct ui_file *stream,\n \t\t\t? \"public\" : (TYPE_FIELD_PROTECTED (type, i)\n \t\t\t\t      ? \"protected\" : \"private\"),\n \t\t\tBASETYPE_VIA_VIRTUAL (type, i) ? \" virtual\" : \"\");\n-      name = TYPE_NAME (TYPE_BASECLASS (type, i));\n+      name = TYPE_BASECLASS (type, i)->name ();\n       if (name)\n \tprint_name_maybe_canonical (name, flags, stream);\n       else\n@@ -373,7 +373,7 @@ c_type_print_varspec_prefix (struct type *type,\n   if (type == 0)\n     return;\n \n-  if (TYPE_NAME (type) && show <= 0)\n+  if (type->name () && show <= 0)\n     return;\n \n   QUIT;\n@@ -391,7 +391,7 @@ c_type_print_varspec_prefix (struct type *type,\n     case TYPE_CODE_MEMBERPTR:\n       c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),\n \t\t\t\t   stream, show, 0, 0, language, flags, podata);\n-      name = TYPE_NAME (TYPE_SELF_TYPE (type));\n+      name = TYPE_SELF_TYPE (type)->name ();\n       if (name)\n \tprint_name_maybe_canonical (name, flags, stream);\n       else\n@@ -406,7 +406,7 @@ c_type_print_varspec_prefix (struct type *type,\n \t\t\t\t   stream, show, 0, 0, language, flags,\n \t\t\t\t   podata);\n       fprintf_filtered (stream, \"(\");\n-      name = TYPE_NAME (TYPE_SELF_TYPE (type));\n+      name = TYPE_SELF_TYPE (type)->name ();\n       if (name)\n \tprint_name_maybe_canonical (name, flags, stream);\n       else\n@@ -762,7 +762,7 @@ c_type_print_varspec_suffix (struct type *type,\n   if (type == 0)\n     return;\n \n-  if (TYPE_NAME (type) && show <= 0)\n+  if (type->name () && show <= 0)\n     return;\n \n   QUIT;\n@@ -1067,13 +1067,13 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n      spurious \"{unnamed struct}\"/\"{unnamed union}\"/\"{unnamed\n      enum}\" tag for unnamed struct/union/enum's, which we don't\n      want to print.  */\n-  if (TYPE_NAME (type) != NULL\n-      && !startswith (TYPE_NAME (type), \"{unnamed\"))\n+  if (type->name () != NULL\n+      && !startswith (type->name (), \"{unnamed\"))\n     {\n       /* When printing the tag name, we are still effectively\n \t printing in the outer context, hence the use of FLAGS\n \t here.  */\n-      print_name_maybe_canonical (TYPE_NAME (type), flags, stream);\n+      print_name_maybe_canonical (type->name (), flags, stream);\n       if (show > 0)\n \tfputs_filtered (\" \", stream);\n     }\n@@ -1082,10 +1082,10 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n     {\n       /* If we just printed a tag name, no need to print anything\n \t else.  */\n-      if (TYPE_NAME (type) == NULL)\n+      if (type->name () == NULL)\n \tfprintf_filtered (stream, \"{...}\");\n     }\n-  else if (show > 0 || TYPE_NAME (type) == NULL)\n+  else if (show > 0 || type->name () == NULL)\n     {\n       struct type *basetype;\n       int vptr_fieldno;\n@@ -1247,7 +1247,7 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \t  struct fn_field *f = TYPE_FN_FIELDLIST1 (type, i);\n \t  int j, len2 = TYPE_FN_FIELDLIST_LENGTH (type, i);\n \t  const char *method_name = TYPE_FN_FIELDLIST_NAME (type, i);\n-\t  const char *name = TYPE_NAME (type);\n+\t  const char *name = type->name ();\n \t  int is_constructor = name && strcmp (method_name,\n \t\t\t\t\t       name) == 0;\n \n@@ -1480,7 +1480,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n      always just print the type name directly from the type.  */\n \n   if (show <= 0\n-      && TYPE_NAME (type) != NULL)\n+      && type->name () != NULL)\n     {\n       c_type_print_modifier (type, stream, 0, 1, language);\n \n@@ -1505,7 +1505,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t    fprintf_filtered (stream, \"enum \");\n \t}\n \n-      print_name_maybe_canonical (TYPE_NAME (type), flags, stream);\n+      print_name_maybe_canonical (type->name (), flags, stream);\n       return;\n     }\n \n@@ -1516,7 +1516,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n     case TYPE_CODE_TYPEDEF:\n       /* If we get here, the typedef doesn't have a name, and we\n \t couldn't resolve TYPE_TARGET_TYPE.  Not much we can do.  */\n-      gdb_assert (TYPE_NAME (type) == NULL);\n+      gdb_assert (type->name () == NULL);\n       gdb_assert (TYPE_TARGET_TYPE (type) == NULL);\n       fprintf_styled (stream, metadata_style.style (),\n \t\t      _(\"<unnamed typedef>\"));\n@@ -1556,10 +1556,10 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n          \"{unnamed struct}\"/\"{unnamed union}\"/\"{unnamed enum}\"\n          tag for unnamed struct/union/enum's, which we don't\n          want to print.  */\n-      if (TYPE_NAME (type) != NULL\n-\t  && !startswith (TYPE_NAME (type), \"{unnamed\"))\n+      if (type->name () != NULL\n+\t  && !startswith (type->name (), \"{unnamed\"))\n \t{\n-\t  print_name_maybe_canonical (TYPE_NAME (type), flags, stream);\n+\t  print_name_maybe_canonical (type->name (), flags, stream);\n \t  if (show > 0)\n \t    fputs_filtered (\" \", stream);\n \t}\n@@ -1569,10 +1569,10 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t{\n \t  /* If we just printed a tag name, no need to print anything\n \t     else.  */\n-\t  if (TYPE_NAME (type) == NULL)\n+\t  if (type->name () == NULL)\n \t    fprintf_filtered (stream, \"{...}\");\n \t}\n-      else if (show > 0 || TYPE_NAME (type) == NULL)\n+      else if (show > 0 || type->name () == NULL)\n \t{\n \t  LONGEST lastval = 0;\n \n@@ -1588,8 +1588,8 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t    {\n \t      struct type *underlying = check_typedef (TYPE_TARGET_TYPE (type));\n \n-\t      if (TYPE_NAME (underlying) != NULL)\n-\t\tfprintf_filtered (stream, \": %s \", TYPE_NAME (underlying));\n+\t      if (underlying->name () != NULL)\n+\t\tfprintf_filtered (stream, \": %s \", underlying->name ());\n \t    }\n \n \t  fprintf_filtered (stream, \"{\");\n@@ -1622,7 +1622,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \n \tc_type_print_modifier (type, stream, 0, 1, language);\n \tfprintf_filtered (stream, \"flag \");\n-\tprint_name_maybe_canonical (TYPE_NAME (type), flags, stream);\n+\tprint_name_maybe_canonical (type->name (), flags, stream);\n \tif (show > 0)\n \t  {\n \t    fputs_filtered (\" \", stream);\n@@ -1684,18 +1684,18 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \n     case TYPE_CODE_NAMESPACE:\n       fputs_filtered (\"namespace \", stream);\n-      fputs_filtered (TYPE_NAME (type), stream);\n+      fputs_filtered (type->name (), stream);\n       break;\n \n     default:\n       /* Handle types not explicitly handled by the other cases, such\n          as fundamental types.  For these, just print whatever the\n          type name is, as recorded in the type itself.  If there is no\n          type name, then complain.  */\n-      if (TYPE_NAME (type) != NULL)\n+      if (type->name () != NULL)\n \t{\n \t  c_type_print_modifier (type, stream, 0, 1, language);\n-\t  print_name_maybe_canonical (TYPE_NAME (type), flags, stream);\n+\t  print_name_maybe_canonical (type->name (), flags, stream);\n \t}\n       else\n \t{"
    },
    {
      "sha": "7d5feb3e6bc8d9eac070038c4a903a79f4bf6ecd",
      "filename": "gdb/c-valprint.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-valprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -78,7 +78,7 @@ c_textual_element_type (struct type *type, char format)\n   while (iter_type)\n     {\n       /* Check the name of the type.  */\n-      if (TYPE_NAME (iter_type) && textual_name (TYPE_NAME (iter_type)))\n+      if (iter_type->name () && textual_name (iter_type->name ()))\n \treturn 1;\n \n       if (iter_type->code () != TYPE_CODE_TYPEDEF)\n@@ -521,11 +521,11 @@ c_value_print (struct value *val, struct ui_file *stream,\n          (Don't use c_textual_element_type here; quoted strings\n          are always exactly (char *), (wchar_t *), or the like.  */\n       if (original_type->code () == TYPE_CODE_PTR\n-\t  && TYPE_NAME (original_type) == NULL\n-\t  && TYPE_NAME (TYPE_TARGET_TYPE (original_type)) != NULL\n-\t  && (strcmp (TYPE_NAME (TYPE_TARGET_TYPE (original_type)),\n+\t  && original_type->name () == NULL\n+\t  && TYPE_TARGET_TYPE (original_type)->name () != NULL\n+\t  && (strcmp (TYPE_TARGET_TYPE (original_type)->name (),\n \t\t      \"char\") == 0\n-\t      || textual_name (TYPE_NAME (TYPE_TARGET_TYPE (original_type)))))\n+\t      || textual_name (TYPE_TARGET_TYPE (original_type)->name ())))\n \t{\n \t  /* Print nothing.  */\n \t}\n@@ -598,14 +598,14 @@ c_value_print (struct value *val, struct ui_file *stream,\n \t\t    < TYPE_LENGTH (value_enclosing_type (val)))))\n \t    val = value_cast (real_type, val);\n \t  fprintf_filtered (stream, \"(%s%s) \",\n-\t\t\t    TYPE_NAME (real_type),\n+\t\t\t    real_type->name (),\n \t\t\t    full ? \"\" : _(\" [incomplete object]\"));\n \t}\n       else if (type != check_typedef (value_enclosing_type (val)))\n \t{\n \t  /* No RTTI information, so let's do our best.  */\n \t  fprintf_filtered (stream, \"(%s ?) \",\n-\t\t\t    TYPE_NAME (value_enclosing_type (val)));\n+\t\t\t    value_enclosing_type (val)->name ());\n \t  val = value_cast (value_enclosing_type (val), val);\n \t}\n     }"
    },
    {
      "sha": "51940b9dd667c3cf65e3984b46abef72745f753a",
      "filename": "gdb/c-varobj.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/c-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-varobj.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -144,7 +144,7 @@ c_is_path_expr_parent (const struct varobj *var)\n   /* Anonymous unions and structs are also not path_expr parents.  */\n   if ((type->code () == TYPE_CODE_STRUCT\n        || type->code () == TYPE_CODE_UNION)\n-      && TYPE_NAME (type) == NULL)\n+      && type->name () == NULL)\n     {\n       const struct varobj *parent = var->parent;\n "
    },
    {
      "sha": "fc44e53cc4c40521569b824fdaa5641c9a05c676",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1463,13 +1463,13 @@ patch_type (struct type *type, struct type *real_type)\n \t  TYPE_FIELDS (real_target), \n \t  field_size);\n \n-  if (TYPE_NAME (real_target))\n+  if (real_target->name ())\n     {\n       /* The previous copy of TYPE_NAME is allocated by\n \t process_coff_symbol.  */\n-      if (TYPE_NAME (target))\n-\txfree ((char*) TYPE_NAME (target));\n-      target->set_name (xstrdup (TYPE_NAME (real_target)));\n+      if (target->name ())\n+\txfree ((char*) target->name ());\n+      target->set_name (xstrdup (real_target->name ()));\n     }\n }\n \n@@ -1658,7 +1658,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \n \t  /* If type has no name, give it one.  */\n-\t  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n+\t  if (SYMBOL_TYPE (sym)->name () == 0)\n \t    {\n \t      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_PTR\n \t\t  || SYMBOL_TYPE (sym)->code () == TYPE_CODE_FUNC)\n@@ -1715,7 +1715,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  /* Some compilers try to be helpful by inventing \"fake\"\n \t     names for anonymous enums, structures, and unions, like\n \t     \"~0fake\" or \".0fake\".  Thanks, but no thanks...  */\n-\t  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n+\t  if (SYMBOL_TYPE (sym)->name () == 0)\n \t    if (sym->linkage_name () != NULL\n \t\t&& *sym->linkage_name () != '~'\n \t\t&& *sym->linkage_name () != '.')"
    },
    {
      "sha": "8f6ed0571ca9cd1b7671ac135cffca81815d2ed3",
      "filename": "gdb/compile/compile-c-types.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/compile/compile-c-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/compile/compile-c-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-types.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -201,7 +201,7 @@ convert_int (compile_c_instance *context, struct type *type)\n \t}\n       return context->plugin ().int_type (TYPE_UNSIGNED (type),\n \t\t\t\t\t  TYPE_LENGTH (type),\n-\t\t\t\t\t  TYPE_NAME (type));\n+\t\t\t\t\t  type->name ());\n     }\n   else\n     return context->plugin ().int_type_v0 (TYPE_UNSIGNED (type),\n@@ -215,7 +215,7 @@ convert_float (compile_c_instance *context, struct type *type)\n {\n   if (context->plugin ().version () >= GCC_C_FE_VERSION_1)\n     return context->plugin ().float_type (TYPE_LENGTH (type),\n-\t\t\t\t\t  TYPE_NAME (type));\n+\t\t\t\t\t  type->name ());\n   else\n     return context->plugin ().float_type_v0 (TYPE_LENGTH (type));\n }"
    },
    {
      "sha": "523ab34b403e70923ceda8464039077b9a94ae3c",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -364,7 +364,7 @@ compile_cplus_instance::new_scope (const char *type_name, struct type *type)\n     }\n   else\n     {\n-      if (TYPE_NAME (type) == nullptr)\n+      if (type->name () == nullptr)\n \t{\n \t  /* Anonymous type  */\n \n@@ -383,8 +383,8 @@ compile_cplus_instance::new_scope (const char *type_name, struct type *type)\n \t{\n \t  scope_component comp\n \t    = {\n-\t        decl_name (TYPE_NAME (type)).get (),\n-\t\tlookup_symbol (TYPE_NAME (type), block (), VAR_DOMAIN, nullptr)\n+\t        decl_name (type->name ()).get (),\n+\t\tlookup_symbol (type->name (), block (), VAR_DOMAIN, nullptr)\n \t      };\n \t  scope.push_back (comp);\n \t}\n@@ -515,13 +515,13 @@ compile_cplus_convert_typedef (compile_cplus_instance *instance,\n \t\t\t       struct type *type,\n \t\t\t       enum gcc_cp_symbol_kind nested_access)\n {\n-  compile_scope scope = instance->new_scope (TYPE_NAME (type), type);\n+  compile_scope scope = instance->new_scope (type->name (), type);\n \n   if (scope.nested_type () != GCC_TYPE_NONE)\n     return scope.nested_type ();\n \n   gdb::unique_xmalloc_ptr<char> name\n-    = compile_cplus_instance::decl_name (TYPE_NAME (type));\n+    = compile_cplus_instance::decl_name (type->name ());\n \n   /* Make sure the scope for this type has been pushed.  */\n   instance->enter_scope (std::move (scope));\n@@ -807,10 +807,10 @@ compile_cplus_convert_struct_or_union (compile_cplus_instance *instance,\n \n   /* Get the decl name of this type.  */\n   gdb::unique_xmalloc_ptr<char> name\n-    = compile_cplus_instance::decl_name (TYPE_NAME (type));\n+    = compile_cplus_instance::decl_name (type->name ());\n \n   /* Create a new scope for TYPE.  */\n-  compile_scope scope = instance->new_scope (TYPE_NAME (type), type);\n+  compile_scope scope = instance->new_scope (type->name (), type);\n \n   if (scope.nested_type () != GCC_TYPE_NONE)\n     {\n@@ -913,7 +913,7 @@ compile_cplus_convert_enum (compile_cplus_instance *instance, struct type *type,\n   bool scoped_enum_p = false;\n \n   /* Create a new scope for this type.  */\n-  compile_scope scope = instance->new_scope (TYPE_NAME (type), type);\n+  compile_scope scope = instance->new_scope (type->name (), type);\n \n   if (scope.nested_type () != GCC_TYPE_NONE)\n     {\n@@ -923,7 +923,7 @@ compile_cplus_convert_enum (compile_cplus_instance *instance, struct type *type,\n     }\n \n   gdb::unique_xmalloc_ptr<char> name\n-    = compile_cplus_instance::decl_name (TYPE_NAME (type));\n+    = compile_cplus_instance::decl_name (type->name ());\n \n   /* Push all scopes.  */\n   instance->enter_scope (std::move (scope));\n@@ -1022,7 +1022,7 @@ compile_cplus_convert_int (compile_cplus_instance *instance, struct type *type)\n     }\n \n   return instance->plugin ().get_int_type\n-    (TYPE_UNSIGNED (type), TYPE_LENGTH (type), TYPE_NAME (type));\n+    (TYPE_UNSIGNED (type), TYPE_LENGTH (type), type->name ());\n }\n \n /* Convert a floating-point type to its gcc representation.  */\n@@ -1032,7 +1032,7 @@ compile_cplus_convert_float (compile_cplus_instance *instance,\n \t\t\t     struct type *type)\n {\n   return instance->plugin ().get_float_type\n-    (TYPE_LENGTH (type), TYPE_NAME (type));\n+    (TYPE_LENGTH (type), type->name ());\n }\n \n /* Convert the 'void' type to its gcc representation.  */\n@@ -1102,9 +1102,9 @@ static gcc_type\n compile_cplus_convert_namespace (compile_cplus_instance *instance,\n \t\t\t\t struct type *type)\n {\n-  compile_scope scope = instance->new_scope (TYPE_NAME (type), type);\n+  compile_scope scope = instance->new_scope (type->name (), type);\n   gdb::unique_xmalloc_ptr<char> name\n-    = compile_cplus_instance::decl_name (TYPE_NAME (type));\n+    = compile_cplus_instance::decl_name (type->name ());\n \n   /* Push scope.  */\n   instance->enter_scope (std::move (scope));"
    },
    {
      "sha": "d03dc77c65dafc682b7d1aa5c764a3c9d1156217",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1120,7 +1120,7 @@ add_struct_fields (struct type *type, completion_list &output,\n \t{\n \t  if (!computed_type_name)\n \t    {\n-\t      type_name = TYPE_NAME (type);\n+\t      type_name = type->name ();\n \t      computed_type_name = 1;\n \t    }\n \t  /* Omit constructors from the completion list.  */"
    },
    {
      "sha": "81fb2ef67c43a09d9fc35066a7597de064121b44",
      "filename": "gdb/cp-namespace.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/cp-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/cp-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-namespace.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -224,7 +224,7 @@ cp_lookup_bare_symbol (const struct language_defn *langdef,\n       /* If TYPE_NAME is NULL, abandon trying to find this symbol.\n \t This can happen for lambda functions compiled with clang++,\n \t which outputs no name for the container class.  */\n-      if (TYPE_NAME (type) == NULL)\n+      if (type->name () == NULL)\n \treturn {};\n \n       /* Look for symbol NAME in this class.  */\n@@ -918,7 +918,7 @@ cp_lookup_nested_symbol (struct type *parent_type,\n \n   if (symbol_lookup_debug)\n     {\n-      const char *type_name = TYPE_NAME (saved_parent_type);\n+      const char *type_name = saved_parent_type->name ();\n \n       fprintf_unfiltered (gdb_stdlog,\n \t\t\t  \"cp_lookup_nested_symbol (%s, %s, %s, %s)\\n\","
    },
    {
      "sha": "1e54aaea3b128a33783311587becf688bd73fbb5",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -207,11 +207,11 @@ inspect_type (struct demangle_parse_info *info,\n \n \t     If the symbol is typedef and its type name is the same\n \t     as the symbol's name, e.g., \"typedef struct foo foo;\".  */\n-\t  if (TYPE_NAME (type) != nullptr\n-\t      && strcmp (TYPE_NAME (type), name) == 0)\n+\t  if (type->name () != nullptr\n+\t      && strcmp (type->name (), name) == 0)\n \t    return 0;\n \n-\t  is_anon = (TYPE_NAME (type) == NULL\n+\t  is_anon = (type->name () == NULL\n \t\t     && (type->code () == TYPE_CODE_ENUM\n \t\t\t || type->code () == TYPE_CODE_STRUCT\n \t\t\t || type->code () == TYPE_CODE_UNION));\n@@ -1278,7 +1278,7 @@ add_symbol_overload_list_adl_namespace (struct type *type,\n \ttype = TYPE_TARGET_TYPE (type);\n     }\n \n-  type_name = TYPE_NAME (type);\n+  type_name = type->name ();\n \n   if (type_name == NULL)\n     return;"
    },
    {
      "sha": "1fb7edd5b0531fc8ac4404318c267c04568bdc81",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -61,7 +61,7 @@ const char vtbl_ptr_name[] = \"__vtbl_ptr_type\";\n int\n cp_is_vtbl_ptr_type (struct type *type)\n {\n-  const char *type_name = TYPE_NAME (type);\n+  const char *type_name = type->name ();\n \n   return (type_name != NULL && !strcmp (type_name, vtbl_ptr_name));\n }\n@@ -207,7 +207,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n \t\t  fprintf_filtered (stream, \"\\n\");\n \t\t  print_spaces_filtered (2 + 2 * recurse, stream);\n \t\t  fputs_filtered (\"members of \", stream);\n-\t\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t\t  fputs_filtered (type->name (), stream);\n \t\t  fputs_filtered (\":\", stream);\n \t\t}\n \t    }\n@@ -411,7 +411,7 @@ cp_print_value (struct value *val, struct ui_file *stream,\n       LONGEST boffset = 0;\n       int skip = 0;\n       struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));\n-      const char *basename = TYPE_NAME (baseclass);\n+      const char *basename = baseclass->name ();\n       struct value *base_val = NULL;\n \n       if (BASETYPE_VIA_VIRTUAL (type, i))\n@@ -708,7 +708,7 @@ cp_print_class_member (const gdb_byte *valaddr, struct type *type,\n       const char *name;\n \n       fputs_filtered (prefix, stream);\n-      name = TYPE_NAME (self_type);\n+      name = self_type->name ();\n       if (name)\n \tfputs_filtered (name, stream);\n       else"
    },
    {
      "sha": "f3053d6a734c4c938486d9cb3e489e3f0704d050",
      "filename": "gdb/d-namespace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/d-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/d-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-namespace.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -131,7 +131,7 @@ d_lookup_symbol (const struct language_defn *langdef,\n \t    return {};\n \n \t  type = check_typedef (TYPE_TARGET_TYPE (SYMBOL_TYPE (lang_this.symbol)));\n-\t  classname = TYPE_NAME (type);\n+\t  classname = type->name ();\n \t  nested = name;\n \t}\n       else"
    },
    {
      "sha": "719051bc5b2fa264afd659ef5071ac5805826754",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -9342,13 +9342,13 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t field at index 1 and the data-less field at index 2.  */\n       TYPE_FIELD (type, 1) = saved_field;\n       TYPE_FIELD_NAME (type, 1)\n-\t= rust_last_path_segment (TYPE_NAME (TYPE_FIELD_TYPE (type, 1)));\n+\t= rust_last_path_segment (TYPE_FIELD_TYPE (type, 1)->name ());\n       TYPE_FIELD_TYPE (type, 1)->set_name\n-\t(rust_fully_qualify (&objfile->objfile_obstack, TYPE_NAME (type),\n+\t(rust_fully_qualify (&objfile->objfile_obstack, type->name (),\n \t\t\t     TYPE_FIELD_NAME (type, 1)));\n \n       const char *dataless_name\n-\t= rust_fully_qualify (&objfile->objfile_obstack, TYPE_NAME (type),\n+\t= rust_fully_qualify (&objfile->objfile_obstack, type->name (),\n \t\t\t      name);\n       struct type *dataless_type = init_type (objfile, TYPE_CODE_VOID, 0,\n \t\t\t\t\t      dataless_name);\n@@ -9372,11 +9372,11 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \n       struct type *field_type = TYPE_FIELD_TYPE (type, 0);\n       const char *variant_name\n-\t= rust_last_path_segment (TYPE_NAME (field_type));\n+\t= rust_last_path_segment (field_type->name ());\n       TYPE_FIELD_NAME (type, 0) = variant_name;\n       field_type->set_name\n \t(rust_fully_qualify (&objfile->objfile_obstack,\n-\t\t\t     TYPE_NAME (type), variant_name));\n+\t\t\t     type->name (), variant_name));\n     }\n   else\n     {\n@@ -9460,7 +9460,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t     That name can be used to look up the correct\n \t     discriminant.  */\n \t  const char *variant_name\n-\t    = rust_last_path_segment (TYPE_NAME (TYPE_FIELD_TYPE (type, i)));\n+\t    = rust_last_path_segment (TYPE_FIELD_TYPE (type, i)->name ());\n \n \t  auto iter = discriminant_map.find (variant_name);\n \t  if (iter != discriminant_map.end ())\n@@ -9479,7 +9479,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t  TYPE_FIELD_NAME (type, i) = variant_name;\n \t  sub_type->set_name\n \t    (rust_fully_qualify (&objfile->objfile_obstack,\n-\t\t\t\t TYPE_NAME (type), variant_name));\n+\t\t\t\t type->name (), variant_name));\n \t}\n \n       /* Indicate that this is a variant type.  */\n@@ -14494,7 +14494,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       handle_data_member_location (die, cu, fp);\n       FIELD_BITSIZE (*fp) = 0;\n       FIELD_TYPE (*fp) = die_type (die, cu);\n-      FIELD_NAME (*fp) = TYPE_NAME (fp->type);\n+      FIELD_NAME (*fp) = fp->type->name ();\n     }\n   else\n     gdb_assert_not_reached (\"missing case in dwarf2_add_field\");\n@@ -15703,7 +15703,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t  if (i < TYPE_N_BASECLASSES (t))\n \t\t    complaint (_(\"virtual function table pointer \"\n \t\t\t\t \"not found when defining class '%s'\"),\n-\t\t\t       TYPE_NAME (type) ? TYPE_NAME (type) : \"\");\n+\t\t\t       type->name () ? type->name () : \"\");\n \t\t}\n \t      else\n \t\t{\n@@ -16497,7 +16497,7 @@ read_namespace (struct die_info *die, struct dwarf2_cu *cu)\n \n \t  std::vector<const char *> excludes;\n \t  add_using_directive (using_directives (cu),\n-\t\t\t       previous_prefix, TYPE_NAME (type), NULL,\n+\t\t\t       previous_prefix, type->name (), NULL,\n \t\t\t       NULL, excludes, 0, &objfile->objfile_obstack);\n \t}\n     }\n@@ -17260,7 +17260,7 @@ dwarf2_init_complex_target_type (struct dwarf2_cu *cu,\n   if (tt != nullptr && TYPE_LENGTH (tt) * TARGET_CHAR_BIT != bits)\n     tt = nullptr;\n \n-  const char *name = (tt == nullptr) ? nullptr : TYPE_NAME (tt);\n+  const char *name = (tt == nullptr) ? nullptr : tt->name ();\n   return dwarf2_init_float_type (objfile, bits, name, name_hint, byte_order);\n }\n \n@@ -17328,7 +17328,7 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n \t      {\n \t\tstruct obstack *obstack\n \t\t  = &cu->per_cu->dwarf2_per_objfile->objfile->objfile_obstack;\n-\t\tname = obconcat (obstack, \"_Complex \", TYPE_NAME (type),\n+\t\tname = obconcat (obstack, \"_Complex \", type->name (),\n \t\t\t\t nullptr);\n \t      }\n \t    type = init_type (objfile, TYPE_CODE_ERROR, bits, name);\n@@ -20904,7 +20904,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t    /* The symbol's name is already allocated along\n \t\t       with this objfile, so we don't need to\n \t\t       duplicate it for the type.  */\n-\t\t    if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n+\t\t    if (SYMBOL_TYPE (sym)->name () == 0)\n \t\t      SYMBOL_TYPE (sym)->set_name (sym->search_name ());\n \t\t  }\n \t      }\n@@ -21656,18 +21656,18 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n \t   DW_TAG_namespace DIEs with a name of \"::\" for the global namespace.\n \t   Work around this problem here.  */\n \tif (cu->language == language_cplus\n-\t    && strcmp (TYPE_NAME (parent_type), \"::\") == 0)\n+\t    && strcmp (parent_type->name (), \"::\") == 0)\n \t  return \"\";\n \t/* We give a name to even anonymous namespaces.  */\n-\treturn TYPE_NAME (parent_type);\n+\treturn parent_type->name ();\n       case DW_TAG_class_type:\n       case DW_TAG_interface_type:\n       case DW_TAG_structure_type:\n       case DW_TAG_union_type:\n       case DW_TAG_module:\n \tparent_type = read_type_die (parent, cu);\n-\tif (TYPE_NAME (parent_type) != NULL)\n-\t  return TYPE_NAME (parent_type);\n+\tif (parent_type->name () != NULL)\n+\t  return parent_type->name ();\n \telse\n \t  /* An anonymous structure is only allowed non-static data\n \t     members; no typedefs, no member functions, et cetera.\n@@ -21702,8 +21702,8 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n \tparent_type = read_type_die (parent, cu);\n \tif (TYPE_DECLARED_CLASS (parent_type))\n \t  {\n-\t    if (TYPE_NAME (parent_type) != NULL)\n-\t      return TYPE_NAME (parent_type);\n+\t    if (parent_type->name () != NULL)\n+\t      return parent_type->name ();\n \t    return \"\";\n \t  }\n \t/* Fall through.  */"
    },
    {
      "sha": "ea08602788085d9cb8d6ab56b28d5fc347b65a6f",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -989,13 +989,13 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n       function_name = NULL;\n       if (type->code () == TYPE_CODE_NAMESPACE)\n \t{\n-\t  function = cp_lookup_symbol_namespace (TYPE_NAME (type),\n+\t  function = cp_lookup_symbol_namespace (type->name (),\n \t\t\t\t\t\t name,\n \t\t\t\t\t\t get_selected_block (0),\n \t\t\t\t\t\t VAR_DOMAIN).symbol;\n \t  if (function == NULL)\n \t    error (_(\"No symbol \\\"%s\\\" in namespace \\\"%s\\\".\"),\n-\t\t   name, TYPE_NAME (type));\n+\t\t   name, type->name ());\n \n \t  tem = 1;\n \t  /* arg2 is left as NULL on purpose.  */\n@@ -2327,9 +2327,9 @@ evaluate_subexp_standard (struct type *expect_type,\n \t  if (type->code () != TYPE_CODE_ARRAY\n \t      && type->code () != TYPE_CODE_PTR)\n \t    {\n-\t      if (TYPE_NAME (type))\n+\t      if (type->name ())\n \t\terror (_(\"cannot subscript something of type `%s'\"),\n-\t\t       TYPE_NAME (type));\n+\t\t       type->name ());\n \t      else\n \t\terror (_(\"cannot subscript requested type\"));\n \t    }\n@@ -2370,7 +2370,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t      else\n \t\t{\n \t\t  error (_(\"cannot subscript something of type `%s'\"),\n-\t\t\t TYPE_NAME (value_type (arg1)));\n+\t\t\t value_type (arg1)->name ());\n \t\t}\n \t    }\n \n@@ -2392,9 +2392,9 @@ evaluate_subexp_standard (struct type *expect_type,\n \t\t  break;\n \n \t\tdefault:\n-\t\t  if (TYPE_NAME (type))\n+\t\t  if (type->name ())\n \t\t    error (_(\"cannot subscript something of type `%s'\"),\n-\t\t\t   TYPE_NAME (type));\n+\t\t\t   type->name ());\n \t\t  else\n \t\t    error (_(\"cannot subscript requested type\"));\n \t\t}"
    },
    {
      "sha": "026b775260d88f308833a3cf8806ad5c2a26e406",
      "filename": "gdb/expprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/expprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/expprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -87,7 +87,7 @@ print_subexp_standard (struct expression *exp, int *pos,\n     case OP_SCOPE:\n       myprec = PREC_PREFIX;\n       assoc = 0;\n-      fputs_filtered (TYPE_NAME (exp->elts[pc + 1].type), stream);\n+      fputs_filtered (exp->elts[pc + 1].type->name (), stream);\n       fputs_filtered (\"::\", stream);\n       nargs = longest_to_int (exp->elts[pc + 2].longconst);\n       (*pos) += 4 + BYTES_TO_EXP_ELEM (nargs + 1);"
    },
    {
      "sha": "820ba5ff0efea78c7140c0a31d397538dae7922f",
      "filename": "gdb/f-typeprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/f-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/f-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-typeprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -70,7 +70,7 @@ f_print_type (struct type *type, const char *varstring, struct ui_file *stream,\n       /* Need a space if going to print stars or brackets; but not if we\n \t will print just a type name.  */\n       || ((show > 0\n-\t   || TYPE_NAME (type) == 0)\n+\t   || type->name () == 0)\n           && (code == TYPE_CODE_FUNC\n \t      || code == TYPE_CODE_METHOD\n \t      || code == TYPE_CODE_ARRAY\n@@ -114,7 +114,7 @@ f_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n   if (type == 0)\n     return;\n \n-  if (TYPE_NAME (type) && show <= 0)\n+  if (type->name () && show <= 0)\n     return;\n \n   QUIT;\n@@ -178,7 +178,7 @@ f_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n   if (type == 0)\n     return;\n \n-  if (TYPE_NAME (type) && show <= 0)\n+  if (type->name () && show <= 0)\n     return;\n \n   QUIT;\n@@ -332,14 +332,14 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n   /* When SHOW is zero or less, and there is a valid type name, then always\n      just print the type name directly from the type.  */\n \n-  if ((show <= 0) && (TYPE_NAME (type) != NULL))\n+  if ((show <= 0) && (type->name () != NULL))\n     {\n       const char *prefix = \"\";\n       if (type->code () == TYPE_CODE_UNION)\n \tprefix = \"Type, C_Union :: \";\n       else if (type->code () == TYPE_CODE_STRUCT)\n \tprefix = \"Type \";\n-      fprintfi_filtered (level, stream, \"%s%s\", prefix, TYPE_NAME (type));\n+      fprintfi_filtered (level, stream, \"%s%s\", prefix, type->name ());\n       return;\n     }\n \n@@ -376,7 +376,7 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n       {\n \tgdbarch *gdbarch = get_type_arch (type);\n \tstruct type *void_type = builtin_f_type (gdbarch)->builtin_void;\n-\tfprintfi_filtered (level, stream, \"%s\", TYPE_NAME (void_type));\n+\tfprintfi_filtered (level, stream, \"%s\", void_type->name ());\n       }\n       break;\n \n@@ -399,7 +399,7 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n          through as TYPE_CODE_INT since dbxstclass.h is so\n          C-oriented, we must change these to \"character\" from \"char\".  */\n \n-      if (strcmp (TYPE_NAME (type), \"char\") == 0)\n+      if (strcmp (type->name (), \"char\") == 0)\n \tfprintfi_filtered (level, stream, \"character\");\n       else\n \tgoto default_case;\n@@ -424,7 +424,7 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n \tfprintfi_filtered (level, stream, \"Type, C_Union :: \");\n       else\n \tfprintfi_filtered (level, stream, \"Type \");\n-      fputs_filtered (TYPE_NAME (type), stream);\n+      fputs_filtered (type->name (), stream);\n       /* According to the definition,\n          we only print structure elements in case show > 0.  */\n       if (show > 0)\n@@ -442,12 +442,12 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t      fputs_filtered (\"\\n\", stream);\n \t    }\n \t  fprintfi_filtered (level, stream, \"End Type \");\n-\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t  fputs_filtered (type->name (), stream);\n \t}\n       break;\n \n     case TYPE_CODE_MODULE:\n-      fprintfi_filtered (level, stream, \"module %s\", TYPE_NAME (type));\n+      fprintfi_filtered (level, stream, \"module %s\", type->name ());\n       break;\n \n     default_case:\n@@ -456,8 +456,8 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n          such as fundamental types.  For these, just print whatever\n          the type name is, as recorded in the type itself.  If there\n          is no type name, then complain.  */\n-      if (TYPE_NAME (type) != NULL)\n-\tfprintfi_filtered (level, stream, \"%s\", TYPE_NAME (type));\n+      if (type->name () != NULL)\n+\tfprintfi_filtered (level, stream, \"%s\", type->name ());\n       else\n \terror (_(\"Invalid type code (%d) in symbol table.\"), type->code ());\n       break;"
    },
    {
      "sha": "68d4c0c4a24051269e1ec20109ee282aa6fe1440",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 32,
      "deletions": 32,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1572,11 +1572,11 @@ type_name_or_error (struct type *type)\n \n   type = check_typedef (type);\n \n-  name = TYPE_NAME (type);\n+  name = type->name ();\n   if (name != NULL)\n     return name;\n \n-  name = TYPE_NAME (saved_type);\n+  name = saved_type->name ();\n   objfile = TYPE_OBJFILE (saved_type);\n   error (_(\"Invalid anonymous type %s [in module %s], GCC PR debug/47510 bug?\"),\n \t name ? name : \"<anonymous>\",\n@@ -1706,11 +1706,11 @@ lookup_template_type (const char *name, struct type *type,\n {\n   struct symbol *sym;\n   char *nam = (char *) \n-    alloca (strlen (name) + strlen (TYPE_NAME (type)) + 4);\n+    alloca (strlen (name) + strlen (type->name ()) + 4);\n \n   strcpy (nam, name);\n   strcat (nam, \"<\");\n-  strcat (nam, TYPE_NAME (type));\n+  strcat (nam, type->name ());\n   strcat (nam, \" >\");\t/* FIXME, extra space still introduced in gcc?  */\n \n   sym = lookup_symbol (nam, block, VAR_DOMAIN, 0).symbol;\n@@ -2213,7 +2213,7 @@ resolve_dynamic_array_or_string (struct type *type,\n \t     if the DWARF info is not correct.  Issue a warning,\n \t     and assume no byte/bit stride (leave bit_stride = 0).  */\n \t  warning (_(\"cannot determine array stride for type %s\"),\n-\t\t   TYPE_NAME (type) ? TYPE_NAME (type) : \"<no name>\");\n+\t\t   type->name () ? type->name () : \"<no name>\");\n \t}\n     }\n   else\n@@ -2764,7 +2764,7 @@ check_typedef (struct type *type)\n \t  if (currently_reading_symtab)\n \t    return make_qualified_type (type, instance_flags, NULL);\n \n-\t  name = TYPE_NAME (type);\n+\t  name = type->name ();\n \t  /* FIXME: shouldn't we look in STRUCT_DOMAIN and/or\n \t     VAR_DOMAIN as appropriate?  */\n \t  if (name == NULL)\n@@ -2817,7 +2817,7 @@ check_typedef (struct type *type)\n       && opaque_type_resolution \n       && !currently_reading_symtab)\n     {\n-      const char *name = TYPE_NAME (type);\n+      const char *name = type->name ();\n       struct type *newtype;\n \n       if (name == NULL)\n@@ -2851,7 +2851,7 @@ check_typedef (struct type *type)\n      types.  */\n   else if (TYPE_STUB (type) && !currently_reading_symtab)\n     {\n-      const char *name = TYPE_NAME (type);\n+      const char *name = type->name ();\n       /* FIXME: shouldn't we look in STRUCT_DOMAIN and/or VAR_DOMAIN\n          as appropriate?  */\n       struct symbol *sym;\n@@ -3297,10 +3297,10 @@ init_complex_type (const char *name, struct type *target_type)\n \t{\n \t  char *new_name\n \t    = (char *) TYPE_ALLOC (target_type,\n-\t\t\t\t   strlen (TYPE_NAME (target_type))\n+\t\t\t\t   strlen (target_type->name ())\n \t\t\t\t   + strlen (\"_Complex \") + 1);\n \t  strcpy (new_name, \"_Complex \");\n-\t  strcat (new_name, TYPE_NAME (target_type));\n+\t  strcat (new_name, target_type->name ());\n \t  name = new_name;\n \t}\n \n@@ -3575,8 +3575,8 @@ int\n class_types_same_p (const struct type *a, const struct type *b)\n {\n   return (TYPE_MAIN_TYPE (a) == TYPE_MAIN_TYPE (b)\n-\t  || (TYPE_NAME (a) && TYPE_NAME (b)\n-\t      && !strcmp (TYPE_NAME (a), TYPE_NAME (b))));\n+\t  || (a->name () && b->name ()\n+\t      && !strcmp (a->name (), b->name ())));\n }\n \n /* If BASE is an ancestor of DCLASS return the distance between them.\n@@ -3929,8 +3929,8 @@ types_equal (struct type *a, struct type *b)\n      stubs.  The types won't point to the same address, but they\n      really are the same.  */\n \n-  if (TYPE_NAME (a) && TYPE_NAME (b)\n-      && strcmp (TYPE_NAME (a), TYPE_NAME (b)) == 0)\n+  if (a->name () && b->name ()\n+      && strcmp (a->name (), b->name ()) == 0)\n     return true;\n \n   /* Check if identical after resolving typedefs.  */\n@@ -4011,9 +4011,9 @@ check_types_equal (struct type *type1, struct type *type2,\n       || TYPE_NFIELDS (type1) != TYPE_NFIELDS (type2))\n     return false;\n \n-  if (!compare_maybe_null_strings (TYPE_NAME (type1), TYPE_NAME (type2)))\n+  if (!compare_maybe_null_strings (type1->name (), type2->name ()))\n     return false;\n-  if (!compare_maybe_null_strings (TYPE_NAME (type1), TYPE_NAME (type2)))\n+  if (!compare_maybe_null_strings (type1->name (), type2->name ()))\n     return false;\n \n   if (type1->code () == TYPE_CODE_RANGE)\n@@ -4290,12 +4290,12 @@ rank_one_type_parm_int (struct type *parm, struct type *arg, struct value *value\n \t\t{\n \t\t  /* unsigned int -> unsigned int, or\n \t\t     unsigned long -> unsigned long */\n-\t\t  if (integer_types_same_name_p (TYPE_NAME (parm),\n-\t\t\t\t\t\t TYPE_NAME (arg)))\n+\t\t  if (integer_types_same_name_p (parm->name (),\n+\t\t\t\t\t\t arg->name ()))\n \t\t    return EXACT_MATCH_BADNESS;\n-\t\t  else if (integer_types_same_name_p (TYPE_NAME (arg),\n+\t\t  else if (integer_types_same_name_p (arg->name (),\n \t\t\t\t\t\t      \"int\")\n-\t\t\t   && integer_types_same_name_p (TYPE_NAME (parm),\n+\t\t\t   && integer_types_same_name_p (parm->name (),\n \t\t\t\t\t\t\t \"long\"))\n \t\t    /* unsigned int -> unsigned long */\n \t\t    return INTEGER_PROMOTION_BADNESS;\n@@ -4305,9 +4305,9 @@ rank_one_type_parm_int (struct type *parm, struct type *arg, struct value *value\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (integer_types_same_name_p (TYPE_NAME (arg),\n+\t\t  if (integer_types_same_name_p (arg->name (),\n \t\t\t\t\t\t \"long\")\n-\t\t      && integer_types_same_name_p (TYPE_NAME (parm),\n+\t\t      && integer_types_same_name_p (parm->name (),\n \t\t\t\t\t\t    \"int\"))\n \t\t    /* signed long -> unsigned int */\n \t\t    return INTEGER_CONVERSION_BADNESS;\n@@ -4318,12 +4318,12 @@ rank_one_type_parm_int (struct type *parm, struct type *arg, struct value *value\n \t    }\n \t  else if (!TYPE_NOSIGN (arg) && !TYPE_UNSIGNED (arg))\n \t    {\n-\t      if (integer_types_same_name_p (TYPE_NAME (parm),\n-\t\t\t\t\t     TYPE_NAME (arg)))\n+\t      if (integer_types_same_name_p (parm->name (),\n+\t\t\t\t\t     arg->name ()))\n \t\treturn EXACT_MATCH_BADNESS;\n-\t      else if (integer_types_same_name_p (TYPE_NAME (arg),\n+\t      else if (integer_types_same_name_p (arg->name (),\n \t\t\t\t\t\t  \"int\")\n-\t\t       && integer_types_same_name_p (TYPE_NAME (parm),\n+\t\t       && integer_types_same_name_p (parm->name (),\n \t\t\t\t\t\t     \"long\"))\n \t\treturn INTEGER_PROMOTION_BADNESS;\n \t      else\n@@ -4629,8 +4629,8 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n   /* Debugging only.  */\n     fprintf_filtered (gdb_stderr,\n \t\t      \"------ Arg is %s [%d], parm is %s [%d]\\n\",\n-\t\t      TYPE_NAME (arg), arg->code (),\n-\t\t      TYPE_NAME (parm), parm->code ());\n+\t\t      arg->name (), arg->code (),\n+\t\t      parm->name (), parm->code ());\n \n   /* x -> y means arg of type x being supplied for parameter of type y.  */\n \n@@ -4905,8 +4905,8 @@ recursive_dump_type (struct type *type, int spaces)\n   gdb_print_host_address (type, gdb_stdout);\n   printf_filtered (\"\\n\");\n   printfi_filtered (spaces, \"name '%s' (\",\n-\t\t    TYPE_NAME (type) ? TYPE_NAME (type) : \"<NULL>\");\n-  gdb_print_host_address (TYPE_NAME (type), gdb_stdout);\n+\t\t    type->name () ? type->name () : \"<NULL>\");\n+  gdb_print_host_address (type->name (), gdb_stdout);\n   printf_filtered (\")\\n\");\n   printfi_filtered (spaces, \"code 0x%x \", type->code ());\n   switch (type->code ())\n@@ -5289,8 +5289,8 @@ copy_type_recursive (struct objfile *objfile,\n   TYPE_OBJFILE_OWNED (new_type) = 0;\n   TYPE_OWNER (new_type).gdbarch = get_type_arch (type);\n \n-  if (TYPE_NAME (type))\n-    new_type->set_name (xstrdup (TYPE_NAME (type)));\n+  if (type->name ())\n+    new_type->set_name (xstrdup (type->name ()));\n \n   TYPE_INSTANCE_FLAGS (new_type) = TYPE_INSTANCE_FLAGS (type);\n   TYPE_LENGTH (new_type) = TYPE_LENGTH (type);"
    },
    {
      "sha": "ba8e6f837aaf91bca07abbaa123e266822f76c8f",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1416,7 +1416,6 @@ extern void allocate_gnat_aux_type (struct type *);\n \n #define TYPE_INSTANCE_FLAGS(thistype) (thistype)->instance_flags\n #define TYPE_MAIN_TYPE(thistype) (thistype)->main_type\n-#define TYPE_NAME(thistype) ((thistype)->name ())\n #define TYPE_TARGET_TYPE(thistype) TYPE_MAIN_TYPE(thistype)->target_type\n #define TYPE_POINTER_TYPE(thistype) (thistype)->pointer_type\n #define TYPE_REFERENCE_TYPE(thistype) (thistype)->reference_type\n@@ -1703,13 +1702,13 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n    if the type has no name.  */\n \n #define TYPE_SAFE_NAME(type) \\\n-  (TYPE_NAME (type) ? TYPE_NAME (type) : _(\"<unnamed type>\"))\n+  (type->name () != nullptr ? type->name () : _(\"<unnamed type>\"))\n \n /* * A helper macro that returns the name of an error type.  If the\n    type has a name, it is used; otherwise, a default is used.  */\n \n #define TYPE_ERROR_NAME(type) \\\n-  (TYPE_NAME (type) ? TYPE_NAME (type) : _(\"<error type>\"))\n+  (type->name () ? type->name () : _(\"<error type>\"))\n \n /* Given TYPE, return its floatformat.  */\n const struct floatformat *floatformat_from_type (const struct type *type);"
    },
    {
      "sha": "d4cf6b95629c8152d376432a99ee3e5c85c335f6",
      "filename": "gdb/gnu-v2-abi.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/gnu-v2-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/gnu-v2-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v2-abi.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -325,10 +325,10 @@ vb_match (struct type *type, int index, struct type *basetype)\n   if (TYPE_TARGET_TYPE (fieldtype) == basetype)\n     return 1;\n \n-  if (TYPE_NAME (basetype) != NULL\n-      && TYPE_NAME (TYPE_TARGET_TYPE (fieldtype)) != NULL\n-      && strcmp (TYPE_NAME (basetype),\n-\t\t TYPE_NAME (TYPE_TARGET_TYPE (fieldtype))) == 0)\n+  if (basetype->name () != NULL\n+      && TYPE_TARGET_TYPE (fieldtype)->name () != NULL\n+      && strcmp (basetype->name (),\n+\t\t TYPE_TARGET_TYPE (fieldtype)->name ()) == 0)\n     return 1;\n   return 0;\n }"
    },
    {
      "sha": "366ac368333a56c0aaaffdd560b7c7ab721d3441",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -92,7 +92,7 @@ gccgo_string_p (struct type *type)\n \n \t  if (target_type->code () == TYPE_CODE_INT\n \t      && TYPE_LENGTH (target_type) == 1\n-\t      && strcmp (TYPE_NAME (target_type), \"uint8\") == 0)\n+\t      && strcmp (target_type->name (), \"uint8\") == 0)\n \t    return 1;\n \t}\n     }\n@@ -107,8 +107,8 @@ static int\n sixg_string_p (struct type *type)\n {\n   if (TYPE_NFIELDS (type) == 2\n-      && TYPE_NAME (type) != NULL\n-      && strcmp (TYPE_NAME (type), \"string\") == 0)\n+      && type->name () != NULL\n+      && strcmp (type->name (), \"string\") == 0)\n     return 1;\n \n   return 0;"
    },
    {
      "sha": "6ea6a3140cf0e74b99ef67d06206aea484eb1265",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -580,7 +580,7 @@ gdbscm_type_tag (SCM self)\n   if (type->code () == TYPE_CODE_STRUCT\n       || type->code () == TYPE_CODE_UNION\n       || type->code () == TYPE_CODE_ENUM)\n-    tagname = TYPE_NAME (type);\n+    tagname = type->name ();\n \n   if (tagname == nullptr)\n     return SCM_BOOL_F;\n@@ -597,9 +597,9 @@ gdbscm_type_name (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  if (!TYPE_NAME (type))\n+  if (!type->name ())\n     return SCM_BOOL_F;\n-  return gdbscm_scm_from_c_string (TYPE_NAME (type));\n+  return gdbscm_scm_from_c_string (type->name ());\n }\n \n /* (type-print-name <gdb:type>) -> string"
    },
    {
      "sha": "8da843a01901107476fb7ef451b6daf0214aa0b3",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1062,11 +1062,11 @@ call_function_by_hand_dummy (struct value *function,\n       auto info = language_pass_by_reference (param_type);\n       if (!info.copy_constructible)\n \terror (_(\"expression cannot be evaluated because the type '%s' \"\n-\t\t \"is not copy constructible\"), TYPE_NAME (param_type));\n+\t\t \"is not copy constructible\"), param_type->name ());\n \n       if (!info.destructible)\n \terror (_(\"expression cannot be evaluated because the type '%s' \"\n-\t\t \"is not destructible\"), TYPE_NAME (param_type));\n+\t\t \"is not destructible\"), param_type->name ());\n \n       if (info.trivially_copyable)\n \tcontinue;\n@@ -1091,14 +1091,14 @@ call_function_by_hand_dummy (struct value *function,\n \t  value *copy_ctor;\n \t  value *cctor_args[2] = { clone_ptr, original_arg };\n \t  find_overload_match (gdb::make_array_view (cctor_args, 2),\n-\t\t\t       TYPE_NAME (param_type), METHOD,\n+\t\t\t       param_type->name (), METHOD,\n \t\t\t       &clone_ptr, nullptr, &copy_ctor, nullptr,\n \t\t\t       nullptr, 0, EVAL_NORMAL);\n \n \t  if (copy_ctor == nullptr)\n \t    error (_(\"expression cannot be evaluated because a copy \"\n \t\t     \"constructor for the type '%s' could not be found \"\n-\t\t     \"(maybe inlined?)\"), TYPE_NAME (param_type));\n+\t\t     \"(maybe inlined?)\"), param_type->name ());\n \n \t  call_function_by_hand (copy_ctor, default_return_type,\n \t\t\t\t gdb::make_array_view (cctor_args, 2));\n@@ -1130,7 +1130,7 @@ call_function_by_hand_dummy (struct value *function,\n \t  if (dtor_name == nullptr)\n \t    error (_(\"expression cannot be evaluated because a destructor \"\n \t\t     \"for the type '%s' could not be found \"\n-\t\t     \"(maybe inlined?)\"), TYPE_NAME (param_type));\n+\t\t     \"(maybe inlined?)\"), param_type->name ());\n \n \t  value *dtor\n \t    = find_function_in_inferior (dtor_name, 0);"
    },
    {
      "sha": "732a69721ca6d186d1fc6893116e02681690e31d",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -999,7 +999,7 @@ language_lookup_primitive_type_1 (const struct language_arch_info *lai,\n \n   for (p = lai->primitive_type_vector; (*p) != NULL; p++)\n     {\n-      if (strcmp (TYPE_NAME (*p), name) == 0)\n+      if (strcmp ((*p)->name (), name) == 0)\n \treturn p;\n     }\n   return NULL;\n@@ -1037,7 +1037,7 @@ language_alloc_type_symbol (enum language lang, struct type *type)\n   gdbarch = TYPE_OWNER (type).gdbarch;\n   symbol = new (gdbarch_obstack (gdbarch)) struct symbol ();\n \n-  symbol->m_name = TYPE_NAME (type);\n+  symbol->m_name = type->name ();\n   symbol->set_language (lang, nullptr);\n   symbol->owner.arch = gdbarch;\n   SYMBOL_OBJFILE_OWNED (symbol) = 0;"
    },
    {
      "sha": "c59c30e262e1f1e1e24d9041ab352fc974cc6671",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1222,7 +1222,7 @@ find_methods (struct type *t, enum language t_lang, const char *name,\n \t      std::vector<struct type *> *superclasses)\n {\n   int ibase;\n-  const char *class_name = TYPE_NAME (t);\n+  const char *class_name = t->name ();\n \n   /* Ignore this class if it doesn't have a name.  This is ugly, but\n      unless we figure out how to get the physname without the name of"
    },
    {
      "sha": "5912670a9f0033c683404854fd3650e3c4f4b71f",
      "filename": "gdb/m2-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/m2-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/m2-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -271,9 +271,9 @@ evaluate_subexp_modula2 (struct type *expect_type, struct expression *exp,\n       else\n \tif (type->code () != TYPE_CODE_ARRAY)\n \t  {\n-\t    if (TYPE_NAME (type))\n+\t    if (type->name ())\n \t      error (_(\"cannot subscript something of type `%s'\"),\n-\t\t     TYPE_NAME (type));\n+\t\t     type->name ());\n \t    else\n \t      error (_(\"cannot subscript requested type\"));\n \t  }"
    },
    {
      "sha": "99222993f4a6d468093c32df43e2ec119ec63cba",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -163,8 +163,8 @@ m2_print_typedef (struct type *type, struct symbol *new_symbol,\n {\n   type = check_typedef (type);\n   fprintf_filtered (stream, \"TYPE \");\n-  if (!TYPE_NAME (SYMBOL_TYPE (new_symbol))\n-      || strcmp (TYPE_NAME ((SYMBOL_TYPE (new_symbol))),\n+  if (!SYMBOL_TYPE (new_symbol)->name ()\n+      || strcmp ((SYMBOL_TYPE (new_symbol))->name (),\n \t\t new_symbol->linkage_name ()) != 0)\n     fprintf_filtered (stream, \"%s = \", new_symbol->print_name ());\n   else\n@@ -178,8 +178,8 @@ m2_print_typedef (struct type *type, struct symbol *new_symbol,\n void\n m2_type_name (struct type *type, struct ui_file *stream)\n {\n-  if (TYPE_NAME (type) != NULL)\n-    fputs_filtered (TYPE_NAME (type), stream);\n+  if (type->name () != NULL)\n+    fputs_filtered (type->name (), stream);\n }\n \n /* m2_range - displays a Modula-2 subrange type.  */\n@@ -211,9 +211,9 @@ static void\n m2_typedef (struct type *type, struct ui_file *stream, int show,\n \t    int level, const struct type_print_options *flags)\n {\n-  if (TYPE_NAME (type) != NULL)\n+  if (type->name () != NULL)\n     {\n-      fputs_filtered (TYPE_NAME (type), stream);\n+      fputs_filtered (type->name (), stream);\n       fputs_filtered (\" = \", stream);\n     }\n   m2_print_type (TYPE_TARGET_TYPE (type), \"\", stream, show, level, flags);\n@@ -440,9 +440,9 @@ m2_long_set (struct type *type, struct ui_file *stream, int show, int level,\n \n   if (m2_is_long_set (type))\n     {\n-      if (TYPE_NAME (type) != NULL)\n+      if (type->name () != NULL)\n \t{\n-\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t  fputs_filtered (type->name (), stream);\n \t  if (show == 0)\n \t    return 1;\n \t  fputs_filtered (\" = \", stream);\n@@ -530,11 +530,11 @@ m2_record_fields (struct type *type, struct ui_file *stream, int show,\n \t\t  int level, const struct type_print_options *flags)\n {\n   /* Print the tag if it exists.  */\n-  if (TYPE_NAME (type) != NULL)\n+  if (type->name () != NULL)\n     {\n-      if (!startswith (TYPE_NAME (type), \"$$\"))\n+      if (!startswith (type->name (), \"$$\"))\n \t{\n-\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t  fputs_filtered (type->name (), stream);\n \t  if (show > 0)\n \t    fprintf_filtered (stream, \" = \");\n \t}\n@@ -595,10 +595,10 @@ m2_enum (struct type *type, struct ui_file *stream, int show, int level)\n   if (show < 0)\n     {\n       /* If we just printed a tag name, no need to print anything else.  */\n-      if (TYPE_NAME (type) == NULL)\n+      if (type->name () == NULL)\n \tfprintf_filtered (stream, \"(...)\");\n     }\n-  else if (show > 0 || TYPE_NAME (type) == NULL)\n+  else if (show > 0 || type->name () == NULL)\n     {\n       fprintf_filtered (stream, \"(\");\n       len = TYPE_NFIELDS (type);"
    },
    {
      "sha": "9ad9c664bcbd5df020a0619c981e05d797f755a4",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1296,7 +1296,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n       add_symbol (s, top_stack->cur_st, top_stack->cur_block);\n \n       /* Incomplete definitions of structs should not get a name.  */\n-      if (TYPE_NAME (SYMBOL_TYPE (s)) == NULL\n+      if (SYMBOL_TYPE (s)->name () == NULL\n \t  && (TYPE_NFIELDS (SYMBOL_TYPE (s)) != 0\n \t      || (SYMBOL_TYPE (s)->code () != TYPE_CODE_STRUCT\n \t\t  && SYMBOL_TYPE (s)->code () != TYPE_CODE_UNION)))\n@@ -1675,8 +1675,8 @@ parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,\n \t     (.Fxx or .xxfake or empty) for unnamed struct/union/enums.  */\n \t  if (name[0] == '.' || name[0] == '\\0')\n \t    tp->set_name (NULL);\n-\t  else if (TYPE_NAME (tp) == NULL\n-\t\t   || strcmp (TYPE_NAME (tp), name) != 0)\n+\t  else if (tp->name () == NULL\n+\t\t   || strcmp (tp->name (), name) != 0)\n \t    tp->set_name (obstack_strdup (&mdebugread_objfile->objfile_obstack,\n \t\t\t\t\t  name));\n \t}\n@@ -1711,8 +1711,8 @@ parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,\n \t      bad_tag_guess_complaint (sym_name);\n \t      tp->set_code (type_code);\n \t    }\n-\t  if (TYPE_NAME (tp) == NULL\n-\t      || strcmp (TYPE_NAME (tp), name) != 0)\n+\t  if (tp->name () == NULL\n+\t      || strcmp (tp->name (), name) != 0)\n \t    tp->set_name (obstack_strdup (&mdebugread_objfile->objfile_obstack,\n \t\t\t\t\t  name));\n \t}"
    },
    {
      "sha": "ae95d77f2551eef1e5e635715fd97cbd6fe58f5b",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1008,7 +1008,7 @@ opencl_print_type (struct type *type, const char *varstring,\n     {\n       type = check_typedef (type);\n       if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n-\t  && TYPE_NAME (type) != NULL)\n+\t  && type->name () != NULL)\n \tshow = 0;\n     }\n "
    },
    {
      "sha": "6403e410571656d971faea7f3a6ce1bc17467995",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -669,7 +669,7 @@ qualified_name:\ttypebase COLONCOLON name\n \t\t\t  if (type->code () != TYPE_CODE_STRUCT\n \t\t\t      && type->code () != TYPE_CODE_UNION)\n \t\t\t    error (_(\"`%s' is not defined as an aggregate type.\"),\n-\t\t\t\t   TYPE_NAME (type));\n+\t\t\t\t   type->name ());\n \n \t\t\t  write_exp_elt_opcode (pstate, OP_SCOPE);\n \t\t\t  write_exp_elt_type (pstate, type);"
    },
    {
      "sha": "05e28a49d3ebdcaec303d1feb6a725772ced6c1c",
      "filename": "gdb/p-typeprint.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/p-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/p-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-typeprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -140,7 +140,7 @@ pascal_type_print_derivation_info (struct ui_file *stream, struct type *type)\n       fprintf_filtered (stream, \"%s%s \",\n \t\t\tBASETYPE_VIA_PUBLIC (type, i) ? \"public\" : \"private\",\n \t\t\tBASETYPE_VIA_VIRTUAL (type, i) ? \" virtual\" : \"\");\n-      name = TYPE_NAME (TYPE_BASECLASS (type, i));\n+      name = TYPE_BASECLASS (type, i)->name ();\n       fprintf_filtered (stream, \"%s\", name ? name : \"(null)\");\n     }\n   if (i > 0)\n@@ -211,7 +211,7 @@ pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n   if (type == 0)\n     return;\n \n-  if (TYPE_NAME (type) && show <= 0)\n+  if (type->name () && show <= 0)\n     return;\n \n   QUIT;\n@@ -377,7 +377,7 @@ pascal_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n   if (type == 0)\n     return;\n \n-  if (TYPE_NAME (type) && show <= 0)\n+  if (type->name () && show <= 0)\n     return;\n \n   QUIT;\n@@ -479,17 +479,17 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n   if ((type->code () == TYPE_CODE_PTR)\n       && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_VOID))\n     {\n-      fputs_filtered (TYPE_NAME (type) ? TYPE_NAME (type) : \"pointer\",\n+      fputs_filtered (type->name () ? type->name () : \"pointer\",\n \t\t      stream);\n       return;\n     }\n   /* When SHOW is zero or less, and there is a valid type name, then always\n      just print the type name directly from the type.  */\n \n   if (show <= 0\n-      && TYPE_NAME (type) != NULL)\n+      && type->name () != NULL)\n     {\n-      fputs_filtered (TYPE_NAME (type), stream);\n+      fputs_filtered (type->name (), stream);\n       return;\n     }\n \n@@ -523,9 +523,9 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n          only after args !!  */\n       break;\n     case TYPE_CODE_STRUCT:\n-      if (TYPE_NAME (type) != NULL)\n+      if (type->name () != NULL)\n \t{\n-\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t  fputs_filtered (type->name (), stream);\n \t  fputs_filtered (\" = \", stream);\n \t}\n       if (HAVE_CPLUS_STRUCT (type))\n@@ -539,9 +539,9 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n       goto struct_union;\n \n     case TYPE_CODE_UNION:\n-      if (TYPE_NAME (type) != NULL)\n+      if (type->name () != NULL)\n \t{\n-\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t  fputs_filtered (type->name (), stream);\n \t  fputs_filtered (\" = \", stream);\n \t}\n       fprintf_filtered (stream, \"case <?> of \");\n@@ -551,10 +551,10 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n       if (show < 0)\n \t{\n \t  /* If we just printed a tag name, no need to print anything else.  */\n-\t  if (TYPE_NAME (type) == NULL)\n+\t  if (type->name () == NULL)\n \t    fprintf_filtered (stream, \"{...}\");\n \t}\n-      else if (show > 0 || TYPE_NAME (type) == NULL)\n+      else if (show > 0 || type->name () == NULL)\n \t{\n \t  pascal_type_print_derivation_info (stream, type);\n \n@@ -739,9 +739,9 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n       break;\n \n     case TYPE_CODE_ENUM:\n-      if (TYPE_NAME (type) != NULL)\n+      if (type->name () != NULL)\n \t{\n-\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t  fputs_filtered (type->name (), stream);\n \t  if (show > 0)\n \t    fputs_filtered (\" \", stream);\n \t}\n@@ -752,10 +752,10 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n       if (show < 0)\n \t{\n \t  /* If we just printed a tag name, no need to print anything else.  */\n-\t  if (TYPE_NAME (type) == NULL)\n+\t  if (type->name () == NULL)\n \t    fprintf_filtered (stream, \"(...)\");\n \t}\n-      else if (show > 0 || TYPE_NAME (type) == NULL)\n+      else if (show > 0 || type->name () == NULL)\n \t{\n \t  fprintf_filtered (stream, \"(\");\n \t  len = TYPE_NFIELDS (type);\n@@ -818,9 +818,9 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n          such as fundamental types.  For these, just print whatever\n          the type name is, as recorded in the type itself.  If there\n          is no type name, then complain.  */\n-      if (TYPE_NAME (type) != NULL)\n+      if (type->name () != NULL)\n \t{\n-\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t  fputs_filtered (type->name (), stream);\n \t}\n       else\n \t{"
    },
    {
      "sha": "44dcbf9dc4295eb7a40cedf9bbbf68b4c4922749",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -423,9 +423,9 @@ pascal_value_print (struct value *val, struct ui_file *stream,\n       /* Hack:  remove (char *) for char strings.  Their\n          type is indicated by the quoted string anyway.  */\n       if (type->code () == TYPE_CODE_PTR\n-\t  && TYPE_NAME (type) == NULL\n-\t  && TYPE_NAME (TYPE_TARGET_TYPE (type)) != NULL\n-\t  && strcmp (TYPE_NAME (TYPE_TARGET_TYPE (type)), \"char\") == 0)\n+\t  && type->name () == NULL\n+\t  && TYPE_TARGET_TYPE (type)->name () != NULL\n+\t  && strcmp (TYPE_TARGET_TYPE (type)->name (), \"char\") == 0)\n \t{\n \t  /* Print nothing.  */\n \t}\n@@ -469,7 +469,7 @@ const char pascal_vtbl_ptr_name[] =\n int\n pascal_object_is_vtbl_ptr_type (struct type *type)\n {\n-  const char *type_name = TYPE_NAME (type);\n+  const char *type_name = type->name ();\n \n   return (type_name != NULL\n \t  && strcmp (type_name, pascal_vtbl_ptr_name) == 0);\n@@ -564,7 +564,7 @@ pascal_object_print_value_fields (struct value *val, struct ui_file *stream,\n \t\t  fprintf_filtered (stream, \"\\n\");\n \t\t  print_spaces_filtered (2 + 2 * recurse, stream);\n \t\t  fputs_filtered (\"members of \", stream);\n-\t\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t\t  fputs_filtered (type->name (), stream);\n \t\t  fputs_filtered (\": \", stream);\n \t\t}\n \t    }\n@@ -710,7 +710,7 @@ pascal_object_print_value (struct value *val, struct ui_file *stream,\n     {\n       LONGEST boffset = 0;\n       struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));\n-      const char *basename = TYPE_NAME (baseclass);\n+      const char *basename = baseclass->name ();\n       int skip = 0;\n \n       if (BASETYPE_VIA_VIRTUAL (type, i))"
    },
    {
      "sha": "4b57e1638edbc975faea2a8adac022aca147b21a",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -393,9 +393,9 @@ typy_get_name (PyObject *self, void *closure)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  if (TYPE_NAME (type) == NULL)\n+  if (type->name () == NULL)\n     Py_RETURN_NONE;\n-  return PyString_FromString (TYPE_NAME (type));\n+  return PyString_FromString (type->name ());\n }\n \n /* Return the type's tag, or None.  */\n@@ -408,7 +408,7 @@ typy_get_tag (PyObject *self, void *closure)\n   if (type->code () == TYPE_CODE_STRUCT\n       || type->code () == TYPE_CODE_UNION\n       || type->code () == TYPE_CODE_ENUM)\n-    tagname = TYPE_NAME (type);\n+    tagname = type->name ();\n \n   if (tagname == nullptr)\n     Py_RETURN_NONE;\n@@ -875,7 +875,7 @@ typy_legacy_template_argument (struct type *type, const struct block *block,\n   std::string err;\n   struct type *argtype;\n \n-  if (TYPE_NAME (type) == NULL)\n+  if (type->name () == NULL)\n     {\n       PyErr_SetString (PyExc_RuntimeError, _(\"Null type name.\"));\n       return NULL;\n@@ -884,7 +884,7 @@ typy_legacy_template_argument (struct type *type, const struct block *block,\n   try\n     {\n       /* Note -- this is not thread-safe.  */\n-      info = cp_demangled_name_to_comp (TYPE_NAME (type), &err);\n+      info = cp_demangled_name_to_comp (type->name (), &err);\n     }\n   catch (const gdb_exception &except)\n     {"
    },
    {
      "sha": "6a4359d0f36146f8cca5ef7e3140b5be97775649",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1392,7 +1392,7 @@ register_dump::dump (ui_file *file)\n \t  {\n \t    static const char blt[] = \"builtin_type\";\n \n-\t    t = TYPE_NAME (register_type (m_gdbarch, regnum));\n+\t    t = register_type (m_gdbarch, regnum)->name ();\n \t    if (t == NULL)\n \t      {\n \t\tif (!footnote_register_type_name_null)"
    },
    {
      "sha": "dae6520f1f854cabadc4282ec75a6225a263c4ad",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -576,8 +576,8 @@ riscv_register_type (struct gdbarch *gdbarch, int regnum)\n       if (flen == 8\n           && type->code () == TYPE_CODE_FLT\n           && TYPE_LENGTH (type) == flen\n-          && (strcmp (TYPE_NAME (type), \"builtin_type_ieee_double\") == 0\n-              || strcmp (TYPE_NAME (type), \"double\") == 0))\n+          && (strcmp (type->name (), \"builtin_type_ieee_double\") == 0\n+              || strcmp (type->name (), \"double\") == 0))\n         type = riscv_fpreg_d_type (gdbarch);\n     }\n "
    },
    {
      "sha": "2c76762eff2090e22eff476a014f8e0512e1ae66",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 42,
      "deletions": 42,
      "changes": 84,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -110,8 +110,8 @@ rust_tuple_type_p (struct type *type)\n      nothing else in the debuginfo to distinguish a tuple from a\n      struct.  */\n   return (type->code () == TYPE_CODE_STRUCT\n-\t  && TYPE_NAME (type) != NULL\n-\t  && TYPE_NAME (type)[0] == '(');\n+\t  && type->name () != NULL\n+\t  && type->name ()[0] == '(');\n }\n \n /* Return true if all non-static fields of a structlike type are in a\n@@ -158,9 +158,9 @@ static bool\n rust_slice_type_p (struct type *type)\n {\n   return (type->code () == TYPE_CODE_STRUCT\n-\t  && TYPE_NAME (type) != NULL\n-\t  && (strncmp (TYPE_NAME (type), \"&[\", 2) == 0\n-\t      || strcmp (TYPE_NAME (type), \"&str\") == 0));\n+\t  && type->name () != NULL\n+\t  && (strncmp (type->name (), \"&[\", 2) == 0\n+\t      || strcmp (type->name (), \"&str\") == 0));\n }\n \n /* Return true if TYPE is a range type, otherwise false.  */\n@@ -172,8 +172,8 @@ rust_range_type_p (struct type *type)\n \n   if (type->code () != TYPE_CODE_STRUCT\n       || TYPE_NFIELDS (type) > 2\n-      || TYPE_NAME (type) == NULL\n-      || strstr (TYPE_NAME (type), \"::Range\") == NULL)\n+      || type->name () == NULL\n+      || strstr (type->name (), \"::Range\") == NULL)\n     return false;\n \n   if (TYPE_NFIELDS (type) == 0)\n@@ -202,8 +202,8 @@ rust_range_type_p (struct type *type)\n static bool\n rust_inclusive_range_type_p (struct type *type)\n {\n-  return (strstr (TYPE_NAME (type), \"::RangeInclusive\") != NULL\n-\t  || strstr (TYPE_NAME (type), \"::RangeToInclusive\") != NULL);\n+  return (strstr (type->name (), \"::RangeInclusive\") != NULL\n+\t  || strstr (type->name (), \"::RangeToInclusive\") != NULL);\n }\n \n /* Return true if TYPE seems to be the type \"u8\", otherwise false.  */\n@@ -243,7 +243,7 @@ rust_is_string_type_p (struct type *type)\n \t  || (type->code () == TYPE_CODE_STRUCT\n \t      && !rust_enum_p (type)\n \t      && rust_slice_type_p (type)\n-\t      && strcmp (TYPE_NAME (type), \"&str\") == 0));\n+\t      && strcmp (type->name (), \"&str\") == 0));\n }\n \n /* If VALUE represents a trait object pointer, return the underlying\n@@ -379,7 +379,7 @@ val_print_struct (struct value *val, struct ui_file *stream, int recurse,\n   int first_field;\n   struct type *type = check_typedef (value_type (val));\n \n-  if (rust_slice_type_p (type) && strcmp (TYPE_NAME (type), \"&str\") == 0)\n+  if (rust_slice_type_p (type) && strcmp (type->name (), \"&str\") == 0)\n     {\n       /* If what we are printing here is actually a string within a\n \t structure then VAL will be the original parent value, while TYPE\n@@ -399,13 +399,13 @@ val_print_struct (struct value *val, struct ui_file *stream, int recurse,\n \n   if (!is_tuple)\n     {\n-      if (TYPE_NAME (type) != NULL)\n-        fprintf_filtered (stream, \"%s\", TYPE_NAME (type));\n+      if (type->name () != NULL)\n+        fprintf_filtered (stream, \"%s\", type->name ());\n \n       if (TYPE_NFIELDS (type) == 0)\n         return;\n \n-      if (TYPE_NAME (type) != NULL)\n+      if (type->name () != NULL)\n         fputs_filtered (\" \", stream);\n     }\n \n@@ -479,7 +479,7 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n     {\n       /* Print the enum type name here to be more clear.  */\n       fprintf_filtered (stream, _(\"%s {%p[<No data fields>%p]}\"),\n-\t\t\tTYPE_NAME (type),\n+\t\t\ttype->name (),\n \t\t\tmetadata_style.style ().ptr (), nullptr);\n       return;\n     }\n@@ -492,7 +492,7 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n \n   bool is_tuple = rust_tuple_struct_type_p (variant_type);\n \n-  fprintf_filtered (stream, \"%s\", TYPE_NAME (variant_type));\n+  fprintf_filtered (stream, \"%s\", variant_type->name ());\n   if (nfields == 0)\n     {\n       /* In case of a nullary variant like 'None', just output\n@@ -599,7 +599,7 @@ rust_value_print_inner (struct value *val, struct ui_file *stream,\n     case TYPE_CODE_INT:\n       /* Recognize the unit type.  */\n       if (TYPE_UNSIGNED (type) && TYPE_LENGTH (type) == 0\n-\t  && TYPE_NAME (type) != NULL && strcmp (TYPE_NAME (type), \"()\") == 0)\n+\t  && type->name () != NULL && strcmp (type->name (), \"()\") == 0)\n \t{\n \t  fputs_filtered (\"()\", stream);\n \t  break;\n@@ -676,7 +676,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n   /* Print a tuple type simply.  */\n   if (rust_tuple_type_p (type))\n     {\n-      fputs_filtered (TYPE_NAME (type), stream);\n+      fputs_filtered (type->name (), stream);\n       return;\n     }\n \n@@ -693,7 +693,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n \n   /* Compute properties of TYPE here because, in the enum case, the\n      rest of the code ends up looking only at the variant part.  */\n-  const char *tagname = TYPE_NAME (type);\n+  const char *tagname = type->name ();\n   bool is_tuple_struct = rust_tuple_struct_type_p (type);\n   bool is_tuple = rust_tuple_type_p (type);\n   bool is_enum = rust_enum_p (type);\n@@ -824,14 +824,14 @@ rust_internal_print_type (struct type *type, const char *varstring,\n {\n   QUIT;\n   if (show <= 0\n-      && TYPE_NAME (type) != NULL)\n+      && type->name () != NULL)\n     {\n       /* Rust calls the unit type \"void\" in its debuginfo,\n          but we don't want to print it as that.  */\n       if (type->code () == TYPE_CODE_VOID)\n         fputs_filtered (\"()\", stream);\n       else\n-        fputs_filtered (TYPE_NAME (type), stream);\n+        fputs_filtered (type->name (), stream);\n       return;\n     }\n \n@@ -903,11 +903,11 @@ rust_internal_print_type (struct type *type, const char *varstring,\n \tint len = 0;\n \n \tfputs_filtered (\"enum \", stream);\n-\tif (TYPE_NAME (type) != NULL)\n+\tif (type->name () != NULL)\n \t  {\n-\t    fputs_filtered (TYPE_NAME (type), stream);\n+\t    fputs_filtered (type->name (), stream);\n \t    fputs_filtered (\" \", stream);\n-\t    len = strlen (TYPE_NAME (type));\n+\t    len = strlen (type->name ());\n \t  }\n \tfputs_filtered (\"{\\n\", stream);\n \n@@ -918,7 +918,7 @@ rust_internal_print_type (struct type *type, const char *varstring,\n \t    QUIT;\n \n \t    if (len > 0\n-\t\t&& strncmp (name, TYPE_NAME (type), len) == 0\n+\t\t&& strncmp (name, type->name (), len) == 0\n \t\t&& name[len] == ':'\n \t\t&& name[len + 1] == ':')\n \t      name += len + 2;\n@@ -933,8 +933,8 @@ rust_internal_print_type (struct type *type, const char *varstring,\n \n     case TYPE_CODE_PTR:\n       {\n-\tif (TYPE_NAME (type) != nullptr)\n-\t  fputs_filtered (TYPE_NAME (type), stream);\n+\tif (type->name () != nullptr)\n+\t  fputs_filtered (type->name (), stream);\n \telse\n \t  {\n \t    /* We currently can't distinguish between pointers and\n@@ -1160,10 +1160,10 @@ rust_evaluate_funcall (struct expression *exp, int *pos, enum noside noside)\n        && type->code () != TYPE_CODE_ENUM)\n       || rust_tuple_type_p (type))\n     error (_(\"Method calls only supported on struct or enum types\"));\n-  if (TYPE_NAME (type) == NULL)\n+  if (type->name () == NULL)\n     error (_(\"Method call on nameless type\"));\n \n-  std::string name = std::string (TYPE_NAME (type)) + \"::\" + method;\n+  std::string name = std::string (type->name ()) + \"::\" + method;\n \n   block = get_selected_block (0);\n   sym = lookup_symbol (name.c_str (), block, VAR_DOMAIN, NULL);\n@@ -1465,7 +1465,7 @@ rust_subscript (struct expression *exp, int *pos, enum noside noside,\n \t\t\t\t\t\t  \"usize\");\n \t  const char *new_name = ((type != nullptr\n \t\t\t\t   && rust_slice_type_p (type))\n-\t\t\t\t  ? TYPE_NAME (type) : \"&[*gdb*]\");\n+\t\t\t\t  ? type->name () : \"&[*gdb*]\");\n \n \t  slice = rust_slice_type (new_name, value_type (result), usize);\n \n@@ -1667,7 +1667,7 @@ rust_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n \t\tif (rust_empty_enum_p (type))\n \t\t  error (_(\"Cannot access field %d of empty enum %s\"),\n-\t\t\t field_number, TYPE_NAME (type));\n+\t\t\t field_number, type->name ());\n \n \t\tint fieldno = rust_enum_variant (type);\n \t\tlhs = value_primitive_field (lhs, 0, fieldno, type);\n@@ -1683,27 +1683,27 @@ rust_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t\tif (outer_type != NULL)\n \t\t  error(_(\"Cannot access field %d of variant %s::%s, \"\n \t\t\t  \"there are only %d fields\"),\n-\t\t\tfield_number, TYPE_NAME (outer_type),\n-\t\t\trust_last_path_segment (TYPE_NAME (type)),\n+\t\t\tfield_number, outer_type->name (),\n+\t\t\trust_last_path_segment (type->name ()),\n \t\t\tnfields);\n \t\telse\n \t\t  error(_(\"Cannot access field %d of %s, \"\n \t\t\t  \"there are only %d fields\"),\n-\t\t\tfield_number, TYPE_NAME (type), nfields);\n+\t\t\tfield_number, type->name (), nfields);\n \t      }\n \n \t    /* Tuples are tuple structs too.  */\n \t    if (!rust_tuple_struct_type_p (type))\n \t      {\n \t\tif (outer_type != NULL)\n \t\t  error(_(\"Variant %s::%s is not a tuple variant\"),\n-\t\t\tTYPE_NAME (outer_type),\n-\t\t\trust_last_path_segment (TYPE_NAME (type)));\n+\t\t\touter_type->name (),\n+\t\t\trust_last_path_segment (type->name ()));\n \t\telse\n \t\t  error(_(\"Attempting to access anonymous field %d \"\n \t\t\t  \"of %s, which is not a tuple, tuple struct, or \"\n \t\t\t  \"tuple-like variant\"),\n-\t\t      field_number, TYPE_NAME (type));\n+\t\t      field_number, type->name ());\n \t      }\n \n \t    result = value_primitive_field (lhs, 0, field_number, type);\n@@ -1735,7 +1735,7 @@ tuple structs, and tuple-like enum variants\"));\n \n \t    if (rust_empty_enum_p (type))\n \t      error (_(\"Cannot access field %s of empty enum %s\"),\n-\t\t     field_name, TYPE_NAME (type));\n+\t\t     field_name, type->name ());\n \n \t    int fieldno = rust_enum_variant (type);\n \t    lhs = value_primitive_field (lhs, 0, fieldno, type);\n@@ -1745,8 +1745,8 @@ tuple structs, and tuple-like enum variants\"));\n \t    if (rust_tuple_type_p (type) || rust_tuple_struct_type_p (type))\n \t\terror (_(\"Attempting to access named field %s of tuple \"\n \t\t\t \"variant %s::%s, which has only anonymous fields\"),\n-\t\t       field_name, TYPE_NAME (outer_type),\n-\t\t       rust_last_path_segment (TYPE_NAME (type)));\n+\t\t       field_name, outer_type->name (),\n+\t\t       rust_last_path_segment (type->name ()));\n \n \t    try\n \t      {\n@@ -1756,8 +1756,8 @@ tuple structs, and tuple-like enum variants\"));\n \t    catch (const gdb_exception_error &except)\n \t      {\n \t\terror (_(\"Could not find field %s of struct variant %s::%s\"),\n-\t\t       field_name, TYPE_NAME (outer_type),\n-\t\t       rust_last_path_segment (TYPE_NAME (type)));\n+\t\t       field_name, outer_type->name (),\n+\t\t       rust_last_path_segment (type->name ()));\n \t      }\n \t  }\n \telse"
    },
    {
      "sha": "a632856404b9b15a30a1a72154b9557ac234464a",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1238,7 +1238,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n          a base type which did not have its name defined when the\n          derived class was output.  We fill in the derived class's\n          base part member's name here in that case.  */\n-      if (TYPE_NAME (SYMBOL_TYPE (sym)) != NULL)\n+      if (SYMBOL_TYPE (sym)->name () != NULL)\n \tif ((SYMBOL_TYPE (sym)->code () == TYPE_CODE_STRUCT\n \t     || SYMBOL_TYPE (sym)->code () == TYPE_CODE_UNION)\n \t    && TYPE_N_BASECLASSES (SYMBOL_TYPE (sym)))\n@@ -1248,10 +1248,10 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t    for (j = TYPE_N_BASECLASSES (SYMBOL_TYPE (sym)) - 1; j >= 0; j--)\n \t      if (TYPE_BASECLASS_NAME (SYMBOL_TYPE (sym), j) == 0)\n \t\tTYPE_BASECLASS_NAME (SYMBOL_TYPE (sym), j) =\n-\t\t  TYPE_NAME (TYPE_BASECLASS (SYMBOL_TYPE (sym), j));\n+\t\t  TYPE_BASECLASS (SYMBOL_TYPE (sym), j)->name ();\n \t  }\n \n-      if (TYPE_NAME (SYMBOL_TYPE (sym)) == NULL)\n+      if (SYMBOL_TYPE (sym)->name () == NULL)\n \t{\n \t  if ((SYMBOL_TYPE (sym)->code () == TYPE_CODE_PTR\n \t       && strcmp (sym->linkage_name (), vtbl_ptr_name))\n@@ -1311,7 +1311,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n           SYMBOL_ACLASS_INDEX (struct_sym) = LOC_TYPEDEF;\n           SYMBOL_VALUE (struct_sym) = valu;\n           SYMBOL_DOMAIN (struct_sym) = STRUCT_DOMAIN;\n-          if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n+          if (SYMBOL_TYPE (sym)->name () == 0)\n \t    SYMBOL_TYPE (sym)->set_name\n \t      (obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t\t (char *) NULL));\n@@ -1338,7 +1338,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n-      if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n+      if (SYMBOL_TYPE (sym)->name () == 0)\n \tSYMBOL_TYPE (sym)->set_name\n \t  (obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t     (char *) NULL));\n@@ -1353,7 +1353,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  SYMBOL_ACLASS_INDEX (typedef_sym) = LOC_TYPEDEF;\n \t  SYMBOL_VALUE (typedef_sym) = valu;\n \t  SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;\n-\t  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n+\t  if (SYMBOL_TYPE (sym)->name () == 0)\n \t    SYMBOL_TYPE (sym)->set_name\n \t      (obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t\t (char *) NULL));\n@@ -2748,7 +2748,7 @@ read_cpp_abbrev (struct stab_field_info *fip, const char **pp,\n       switch (cpp_abbrev)\n \t{\n \tcase 'f':\t\t/* $vf -- a virtual function table pointer */\n-\t  name = TYPE_NAME (context);\n+\t  name = context->name ();\n \t  if (name == NULL)\n \t    {\n \t      name = \"\";\n@@ -2758,7 +2758,7 @@ read_cpp_abbrev (struct stab_field_info *fip, const char **pp,\n \t  break;\n \n \tcase 'b':\t\t/* $vb -- a virtual bsomethingorother */\n-\t  name = TYPE_NAME (context);\n+\t  name = context->name ();\n \t  if (name == NULL)\n \t    {\n \t      complaint (_(\"C++ abbreviated type name \"\n@@ -3161,7 +3161,7 @@ read_baseclasses (struct stab_field_info *fip, const char **pp,\n          field's name.  */\n \n       newobj->field.type = read_type (pp, objfile);\n-      newobj->field.name = TYPE_NAME (newobj->field.type);\n+      newobj->field.name = newobj->field.type->name ();\n \n       /* Skip trailing ';' and bump count of number of fields seen.  */\n       if (**pp == ';')\n@@ -3248,7 +3248,7 @@ read_tilde_fields (struct stab_field_info *fip, const char **pp,\n \t      /* Virtual function table field not found.  */\n \t      complaint (_(\"virtual function table pointer \"\n \t\t\t   \"not found when defining class `%s'\"),\n-\t\t\t TYPE_NAME (type));\n+\t\t\t type->name ());\n \t      return 0;\n \t    }\n \t  else\n@@ -3377,9 +3377,9 @@ complain_about_struct_wipeout (struct type *type)\n   const char *name = \"\";\n   const char *kind = \"\";\n \n-  if (TYPE_NAME (type))\n+  if (type->name ())\n     {\n-      name = TYPE_NAME (type);\n+      name = type->name ();\n       switch (type->code ())\n         {\n         case TYPE_CODE_STRUCT: kind = \"struct \"; break;\n@@ -4408,7 +4408,7 @@ add_undefined_type_1 (struct type *type)\n static void\n add_undefined_type (struct type *type, int typenums[2])\n {\n-  if (TYPE_NAME (type) == NULL)\n+  if (type->name () == NULL)\n     add_undefined_type_noname (type, typenums);\n   else\n     add_undefined_type_1 (type);\n@@ -4493,7 +4493,7 @@ cleanup_undefined_types_1 (void)\n \t\tstruct pending *ppt;\n \t\tint i;\n \t\t/* Name of the type, without \"struct\" or \"union\".  */\n-\t\tconst char *type_name = TYPE_NAME (*type);\n+\t\tconst char *type_name = (*type)->name ();\n \n \t\tif (type_name == NULL)\n \t\t  {"
    },
    {
      "sha": "fc56cfa9381c3ac36cccbd919563ff9a8c4e5d05",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -556,7 +556,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \n   if (SYMBOL_DOMAIN (symbol) == STRUCT_DOMAIN)\n     {\n-      if (TYPE_NAME (SYMBOL_TYPE (symbol)))\n+      if (SYMBOL_TYPE (symbol)->name ())\n \t{\n \t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), \"\", outfile, 1, depth,\n \t\t\t &type_print_raw_options);"
    },
    {
      "sha": "20d73bb28f57e0a0d1b705bdcf99b3728fafff34",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -595,7 +595,7 @@ gdb_mangle_name (struct type *type, int method_id, int signature_id)\n   struct fn_field *method = &f[signature_id];\n   const char *field_name = TYPE_FN_FIELDLIST_NAME (type, method_id);\n   const char *physname = TYPE_FN_FIELD_PHYSNAME (f, signature_id);\n-  const char *newname = TYPE_NAME (type);\n+  const char *newname = type->name ();\n \n   /* Does the form of physname indicate that it is the full mangled name\n      of a constructor (not just the args)?  */"
    },
    {
      "sha": "82e63a33cbbd1fe9f28e3a5a72ccea69cd25415b",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -60,7 +60,7 @@ find_size_for_pointer_math (struct type *ptr_type)\n \t{\n \t  const char *name;\n \t  \n-\t  name = TYPE_NAME (ptr_target);\n+\t  name = ptr_target->name ();\n \t  if (name == NULL)\n \t    error (_(\"Cannot perform pointer math on incomplete types, \"\n \t\t   \"try casting to a known type, or void *.\"));\n@@ -888,8 +888,8 @@ value_args_as_target_float (struct value *arg1, struct value *arg2,\n \ttarget_float_from_longest (x, *eff_type_x, value_as_long (arg1));\n     }\n   else\n-    error (_(\"Don't know how to convert from %s to %s.\"), TYPE_NAME (type1),\n-\t     TYPE_NAME (type2));\n+    error (_(\"Don't know how to convert from %s to %s.\"), type1->name (),\n+\t     type2->name ());\n \n   /* Obtain value of arg2, converting from other types if necessary.  */\n \n@@ -907,8 +907,8 @@ value_args_as_target_float (struct value *arg1, struct value *arg2,\n \ttarget_float_from_longest (y, *eff_type_y, value_as_long (arg2));\n     }\n   else\n-    error (_(\"Don't know how to convert from %s to %s.\"), TYPE_NAME (type1),\n-\t     TYPE_NAME (type2));\n+    error (_(\"Don't know how to convert from %s to %s.\"), type1->name (),\n+\t     type2->name ());\n }\n \n /* A helper function that finds the type to use for a binary operation"
    },
    {
      "sha": "40c8f34ea1deac1a0573144eb3361941f24a1ed0",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -222,17 +222,17 @@ value_cast_structs (struct type *type, struct value *v2)\n \t       || t2->code () == TYPE_CODE_UNION)\n \t      && !!\"Precondition is that value is of STRUCT or UNION kind\");\n \n-  if (TYPE_NAME (t1) != NULL\n-      && TYPE_NAME (t2) != NULL\n-      && !strcmp (TYPE_NAME (t1), TYPE_NAME (t2)))\n+  if (t1->name () != NULL\n+      && t2->name () != NULL\n+      && !strcmp (t1->name (), t2->name ()))\n     return NULL;\n \n   /* Upcasting: look in the type of the source to see if it contains the\n      type of the target as a superclass.  If so, we'll need to\n      offset the pointer rather than just change its type.  */\n-  if (TYPE_NAME (t1) != NULL)\n+  if (t1->name () != NULL)\n     {\n-      v = search_struct_field (TYPE_NAME (t1),\n+      v = search_struct_field (t1->name (),\n \t\t\t       v2, t2, 1);\n       if (v)\n \treturn v;\n@@ -241,7 +241,7 @@ value_cast_structs (struct type *type, struct value *v2)\n   /* Downcasting: look in the type of the target to see if it contains the\n      type of the source as a superclass.  If so, we'll need to\n      offset the pointer rather than just change its type.  */\n-  if (TYPE_NAME (t2) != NULL)\n+  if (t2->name () != NULL)\n     {\n       /* Try downcasting using the run-time type of the value.  */\n       int full, using_enc;\n@@ -257,19 +257,19 @@ value_cast_structs (struct type *type, struct value *v2)\n \n \t  /* We might be trying to cast to the outermost enclosing\n \t     type, in which case search_struct_field won't work.  */\n-\t  if (TYPE_NAME (real_type) != NULL\n-\t      && !strcmp (TYPE_NAME (real_type), TYPE_NAME (t1)))\n+\t  if (real_type->name () != NULL\n+\t      && !strcmp (real_type->name (), t1->name ()))\n \t    return v;\n \n-\t  v = search_struct_field (TYPE_NAME (t2), v, real_type, 1);\n+\t  v = search_struct_field (t2->name (), v, real_type, 1);\n \t  if (v)\n \t    return v;\n \t}\n \n       /* Try downcasting using information from the destination type\n \t T2.  This wouldn't work properly for classes with virtual\n \t bases, but those were handled above.  */\n-      v = search_struct_field (TYPE_NAME (t2),\n+      v = search_struct_field (t2->name (),\n \t\t\t       value_zero (t1, not_lval), t1, 1);\n       if (v)\n \t{\n@@ -443,7 +443,7 @@ value_cast (struct type *type, struct value *arg2)\n \n   if ((code1 == TYPE_CODE_STRUCT || code1 == TYPE_CODE_UNION)\n       && (code2 == TYPE_CODE_STRUCT || code2 == TYPE_CODE_UNION)\n-      && TYPE_NAME (type) != 0)\n+      && type->name () != 0)\n     {\n       struct value *v = value_cast_structs (to_type, arg2);\n \n@@ -2479,7 +2479,7 @@ find_overload_match (gdb::array_view<value *> args,\n       obj = coerce_ref (obj);\n       while (check_typedef (value_type (obj))->code () == TYPE_CODE_PTR)\n \tobj = coerce_ref (value_ind (obj));\n-      obj_type_name = TYPE_NAME (value_type (obj));\n+      obj_type_name = value_type (obj)->name ();\n \n       /* First check whether this is a data member, e.g. a pointer to\n \t a function.  */\n@@ -3141,7 +3141,7 @@ enum_constant_from_type (struct type *type, const char *name)\n     }\n \n   error (_(\"no constant named \\\"%s\\\" in enum \\\"%s\\\"\"),\n-\t name, TYPE_NAME (type));\n+\t name, type->name ());\n }\n \n /* C++: Given an aggregate type CURTYPE, and a member name NAME,\n@@ -3528,7 +3528,7 @@ value_namespace_elt (const struct type *curtype,\n \n   if (retval == NULL)\n     error (_(\"No symbol \\\"%s\\\" in namespace \\\"%s\\\".\"), \n-\t   name, TYPE_NAME (curtype));\n+\t   name, curtype->name ());\n \n   return retval;\n }\n@@ -3544,7 +3544,7 @@ value_maybe_namespace_elt (const struct type *curtype,\n \t\t\t   const char *name, int want_address,\n \t\t\t   enum noside noside)\n {\n-  const char *namespace_name = TYPE_NAME (curtype);\n+  const char *namespace_name = curtype->name ();\n   struct block_symbol sym;\n   struct value *result;\n \n@@ -3684,7 +3684,7 @@ value_full_object (struct value *argp,\n     {\n       warning (_(\"Couldn't retrieve complete object of RTTI \"\n \t\t \"type %s; object may be in register(s).\"), \n-\t       TYPE_NAME (real_type));\n+\t       real_type->name ());\n \n       return argp;\n     }"
    },
    {
      "sha": "cb860509f80547c8a32dc1e5dea68b22a1fb59d4",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d93a1e0b6af703c75daa93456608f8bb5f34f13/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=7d93a1e0b6af703c75daa93456608f8bb5f34f13",
      "patch": "@@ -1001,9 +1001,9 @@ check_type_length_before_alloc (const struct type *type)\n \n   if (max_value_size > -1 && length > max_value_size)\n     {\n-      if (TYPE_NAME (type) != NULL)\n+      if (type->name () != NULL)\n \terror (_(\"value of type `%s' requires %u bytes, which is more \"\n-\t\t \"than max-value-size\"), TYPE_NAME (type), length);\n+\t\t \"than max-value-size\"), type->name (), length);\n       else\n \terror (_(\"value requires %u bytes, which is more than \"\n \t\t \"max-value-size\"), length);"
    }
  ]
}