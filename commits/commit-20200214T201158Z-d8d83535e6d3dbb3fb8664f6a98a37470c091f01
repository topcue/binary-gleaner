{
  "sha": "d8d83535e6d3dbb3fb8664f6a98a37470c091f01",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDhkODM1MzVlNmQzZGJiM2ZiODY2NGY2YTk4YTM3NDcwYzA5MWYwMQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-02-14T20:11:58Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-02-14T20:11:58Z"
    },
    "message": "gdb: cleanup of displaced_step_inferior_state::reset/displaced_step_clear\n\ndisplaced_step_inferior_state::reset and displaced_step_clear appear to\nhave the same goal, but they don't do the same thing.\ndisplaced_step_inferior_state::reset clears more things than\ndisplaced_step_clear, but it misses free'ing the closure, which\ndisplaced_step_clear does.\n\nThis patch replaces displaced_step_clear's implementation with just a call to\ndisplaced_step_inferior_state::reset.  It then changes\ndisplaced_step_inferior_state::step_closure to be a unique_ptr, to indicate the\nfact that displaced_step_inferior_state owns the closure (and so that it is\nautomatically freed when the field is reset).\n\nThe test gdb.base/step-over-syscall.exp caught a problem when doing this, which\nI consider to be a latent bug which my cleanup exposes.  In\nhandle_inferior_event, in the TARGET_WAITKIND_FORKED case, if we displaced-step\nover a fork syscall, we make sure to restore the memory that we used as a\ndisplaced-stepping buffer in the child.  We do so using the\ndisplaced_step_inferior_state of the parent.  However, we do it after calling\ndisplaced_step_fixup for the parent, which clears the information in the\nparent's displaced_step_inferior_state.  It worked fine before, because\ndisplaced_step_clear didn't completely clear the displaced_step_inferior_state\nstructure, so the required information (in this case the gdbarch) was\nstill available after clearing.\n\nI fixed it by making GDB restore the child's memory before calling the\ndisplaced_step_fixup on the parent.  This way, the data in the\ndisplaced_step_inferior_state structure is still valid when we use it for the\nchild.  This is the error you would get in\ngdb.base/step-over-syscall.exp without this fix:\n\n    /home/smarchi/src/binutils-gdb/gdb/gdbarch.c:3911: internal-error: ULONGEST gdbarch_max_insn_length(gdbarch*): Assertion `gdbarch != NULL' failed.\n\ngdb/ChangeLog:\n\n\t* infrun.c (get_displaced_step_closure_by_addr): Adjust to\n\tstd::unique_ptr.\n\t(displaced_step_clear): Rename to...\n\t(displaced_step_reset): ... this.  Just call displaced->reset ().\n\t(displaced_step_clear_cleanup): Rename to...\n\t(displaced_step_reset_cleanup): ... this.\n\t(displaced_step_prepare_throw): Adjust to std::unique_ptr.\n\t(displaced_step_fixup): Likewise.\n\t(resume_1): Likewise.\n\t(handle_inferior_event): Restore child's memory before calling\n\tdisplaced_step_fixup on the parent.\n\t* infrun.h (displaced_step_inferior_state) <reset>: Adjust\n\tto std::unique_ptr.\n\t<step_closure>: Change type to std::unique_ptr.",
    "tree": {
      "sha": "b578e96844a2ba6f67f890ea902690281ba56cca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b578e96844a2ba6f67f890ea902690281ba56cca"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d8d83535e6d3dbb3fb8664f6a98a37470c091f01",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8d83535e6d3dbb3fb8664f6a98a37470c091f01",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d8d83535e6d3dbb3fb8664f6a98a37470c091f01",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8d83535e6d3dbb3fb8664f6a98a37470c091f01/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5f661e03972e3412778c0bee8d20522b9bffea76",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f661e03972e3412778c0bee8d20522b9bffea76",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5f661e03972e3412778c0bee8d20522b9bffea76"
    }
  ],
  "stats": {
    "total": 73,
    "additions": 44,
    "deletions": 29
  },
  "files": [
    {
      "sha": "e3fa08165a7c0775c677e6ce4b70e3d7360baf40",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d83535e6d3dbb3fb8664f6a98a37470c091f01/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d83535e6d3dbb3fb8664f6a98a37470c091f01/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d8d83535e6d3dbb3fb8664f6a98a37470c091f01",
      "patch": "@@ -1,3 +1,20 @@\n+2020-02-14  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* infrun.c (get_displaced_step_closure_by_addr): Adjust to\n+\tstd::unique_ptr.\n+\t(displaced_step_clear): Rename to...\n+\t(displaced_step_reset): ... this.  Just call displaced->reset ().\n+\t(displaced_step_clear_cleanup): Rename to...\n+\t(displaced_step_reset_cleanup): ... this.\n+\t(displaced_step_prepare_throw): Adjust to std::unique_ptr.\n+\t(displaced_step_fixup): Likewise.\n+\t(resume_1): Likewise.\n+\t(handle_inferior_event): Restore child's memory before calling\n+\tdisplaced_step_fixup on the parent.\n+\t* infrun.h (displaced_step_inferior_state) <reset>: Adjust\n+\tto std::unique_ptr.\n+\t<step_closure>: Change type to std::unique_ptr.\n+\n 2020-02-14  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* arm-tdep.c: Include count-one-bits.h."
    },
    {
      "sha": "e3e4bdb9b847483a1dd6ef9c32dcf61282495489",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 25,
      "deletions": 27,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d83535e6d3dbb3fb8664f6a98a37470c091f01/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d83535e6d3dbb3fb8664f6a98a37470c091f01/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=d8d83535e6d3dbb3fb8664f6a98a37470c091f01",
      "patch": "@@ -1540,7 +1540,7 @@ get_displaced_step_closure_by_addr (CORE_ADDR addr)\n   /* If checking the mode of displaced instruction in copy area.  */\n   if (displaced->step_thread != nullptr\n       && displaced->step_copy == addr)\n-    return displaced->step_closure;\n+    return displaced->step_closure.get ();\n \n   return NULL;\n }\n@@ -1596,20 +1596,18 @@ use_displaced_stepping (struct thread_info *tp)\n \t  && !displaced_state->failed_before);\n }\n \n-/* Clean out any stray displaced stepping state.  */\n+/* Simple function wrapper around displaced_step_inferior_state::reset.  */\n+\n static void\n-displaced_step_clear (struct displaced_step_inferior_state *displaced)\n+displaced_step_reset (displaced_step_inferior_state *displaced)\n {\n-  /* Indicate that there is no cleanup pending.  */\n-  displaced->step_thread = nullptr;\n-\n-  delete displaced->step_closure;\n-  displaced->step_closure = NULL;\n+  displaced->reset ();\n }\n \n-/* A cleanup that wraps displaced_step_clear.  */\n-using displaced_step_clear_cleanup\n-  = FORWARD_SCOPE_EXIT (displaced_step_clear);\n+/* A cleanup that wraps displaced_step_reset.  We use this instead of, say,\n+   SCOPE_EXIT, because it needs to be discardable with \"cleanup.release ()\".  */\n+\n+using displaced_step_reset_cleanup = FORWARD_SCOPE_EXIT (displaced_step_reset);\n \n /* Dump LEN bytes at BUF in hex to FILE, followed by a newline.  */\n void\n@@ -1691,7 +1689,7 @@ displaced_step_prepare_throw (thread_info *tp)\n \t\t\t    target_pid_to_str (tp->ptid).c_str ());\n     }\n \n-  displaced_step_clear (displaced);\n+  displaced_step_reset (displaced);\n \n   scoped_restore_current_thread restore_thread;\n \n@@ -1754,12 +1752,12 @@ displaced_step_prepare_throw (thread_info *tp)\n      succeeds.  */\n   displaced->step_thread = tp;\n   displaced->step_gdbarch = gdbarch;\n-  displaced->step_closure = closure;\n+  displaced->step_closure.reset (closure);\n   displaced->step_original = original;\n   displaced->step_copy = copy;\n \n   {\n-    displaced_step_clear_cleanup cleanup (displaced);\n+    displaced_step_reset_cleanup cleanup (displaced);\n \n     /* Resume execution at the copy.  */\n     regcache_write_pc (regcache, copy);\n@@ -1862,7 +1860,7 @@ displaced_step_fixup (thread_info *event_thread, enum gdb_signal signal)\n   if (displaced->step_thread != event_thread)\n     return 0;\n \n-  displaced_step_clear_cleanup cleanup (displaced);\n+  displaced_step_reset_cleanup cleanup (displaced);\n \n   displaced_step_restore (displaced, displaced->step_thread->ptid);\n \n@@ -1879,7 +1877,7 @@ displaced_step_fixup (thread_info *event_thread, enum gdb_signal signal)\n     {\n       /* Fix up the resulting state.  */\n       gdbarch_displaced_step_fixup (displaced->step_gdbarch,\n-                                    displaced->step_closure,\n+                                    displaced->step_closure.get (),\n                                     displaced->step_original,\n                                     displaced->step_copy,\n                                     get_thread_regcache (displaced->step_thread));\n@@ -2472,8 +2470,8 @@ resume_1 (enum gdb_signal sig)\n \t  pc = regcache_read_pc (get_thread_regcache (tp));\n \n \t  displaced = get_displaced_stepping_state (tp->inf);\n-\t  step = gdbarch_displaced_step_hw_singlestep (gdbarch,\n-\t\t\t\t\t\t       displaced->step_closure);\n+\t  step = gdbarch_displaced_step_hw_singlestep\n+\t    (gdbarch, displaced->step_closure.get ());\n \t}\n     }\n \n@@ -5305,6 +5303,15 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n \t    struct regcache *child_regcache;\n \t    CORE_ADDR parent_pc;\n \n+\t    if (ecs->ws.kind == TARGET_WAITKIND_FORKED)\n+\t      {\n+\t\tstruct displaced_step_inferior_state *displaced\n+\t\t  = get_displaced_stepping_state (parent_inf);\n+\n+\t\t/* Restore scratch pad for child process.  */\n+\t\tdisplaced_step_restore (displaced, ecs->ws.value.related_pid);\n+\t      }\n+\n \t    /* GDB has got TARGET_WAITKIND_FORKED or TARGET_WAITKIND_VFORKED,\n \t       indicating that the displaced stepping of syscall instruction\n \t       has been done.  Perform cleanup for parent process here.  Note\n@@ -5315,15 +5322,6 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n \t       that needs it.  */\n \t    start_step_over ();\n \n-\t    if (ecs->ws.kind == TARGET_WAITKIND_FORKED)\n-\t      {\n-\t\tstruct displaced_step_inferior_state *displaced\n-\t\t  = get_displaced_stepping_state (parent_inf);\n-\n-\t\t/* Restore scratch pad for child process.  */\n-\t\tdisplaced_step_restore (displaced, ecs->ws.value.related_pid);\n-\t      }\n-\n \t    /* Since the vfork/fork syscall instruction was executed in the scratchpad,\n \t       the child's PC is also within the scratchpad.  Set the child's PC\n \t       to the parent's PC value, which has already been fixed up."
    },
    {
      "sha": "c6329c844d9bc3512824c053a60dfe2fe2560e75",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d83535e6d3dbb3fb8664f6a98a37470c091f01/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d83535e6d3dbb3fb8664f6a98a37470c091f01/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=d8d83535e6d3dbb3fb8664f6a98a37470c091f01",
      "patch": "@@ -290,7 +290,7 @@ struct displaced_step_inferior_state\n     failed_before = 0;\n     step_thread = nullptr;\n     step_gdbarch = nullptr;\n-    step_closure = nullptr;\n+    step_closure.reset ();\n     step_original = 0;\n     step_copy = 0;\n     step_saved_copy.clear ();\n@@ -310,7 +310,7 @@ struct displaced_step_inferior_state\n \n   /* The closure provided gdbarch_displaced_step_copy_insn, to be used\n      for post-step cleanup.  */\n-  displaced_step_closure *step_closure;\n+  std::unique_ptr<displaced_step_closure> step_closure;\n \n   /* The address of the original instruction, and the copy we\n      made.  */"
    }
  ]
}