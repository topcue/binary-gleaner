{
  "sha": "940da03e32c28144134d0373faf7fd5ea158f1ae",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTQwZGEwM2UzMmMyODE0NDEzNGQwMzczZmFmN2ZkNWVhMTU4ZjFhZQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-08T19:26:20Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-08T19:26:31Z"
    },
    "message": "gdb: remove TYPE_FIELD_TYPE macro\n\nRemove the `TYPE_FIELD_TYPE` macro, changing all the call sites to use\n`type::field` and `field::type` directly.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (TYPE_FIELD_TYPE): Remove.  Change all call sites\n\tto use type::field and field::type instead.\n\nChange-Id: Ifda6226a25c811cfd334a756a9fbc5c0afdddff3",
    "tree": {
      "sha": "a104a5666df69b0a45c5e5d04aba70cb10410dad",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a104a5666df69b0a45c5e5d04aba70cb10410dad"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/940da03e32c28144134d0373faf7fd5ea158f1ae",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/940da03e32c28144134d0373faf7fd5ea158f1ae",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/940da03e32c28144134d0373faf7fd5ea158f1ae",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/940da03e32c28144134d0373faf7fd5ea158f1ae/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b6cdac4b80c1d32726227305e16483cef9d40e2c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b6cdac4b80c1d32726227305e16483cef9d40e2c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b6cdac4b80c1d32726227305e16483cef9d40e2c"
    }
  ],
  "stats": {
    "total": 579,
    "additions": 287,
    "deletions": 292
  },
  "files": [
    {
      "sha": "26310c429b33f32e6cf97b4d9c60459cdd107e2a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1,3 +1,8 @@\n+2020-06-08  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (TYPE_FIELD_TYPE): Remove.  Change all call sites\n+\tto use type::field and field::type instead.\n+\n 2020-06-08  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (FIELD_TYPE): Remove.  Change all call sites"
    },
    {
      "sha": "5e7d0d0b8682af04ce4f01fd999d26c9eb459932",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1352,7 +1352,7 @@ aapcs_is_vfp_call_or_return_candidate_1 (struct type *type,\n \t    if (field_is_static (&type->field (i)))\n \t      continue;\n \n-\t    struct type *member = check_typedef (TYPE_FIELD_TYPE (type, i));\n+\t    struct type *member = check_typedef (type->field (i).type ());\n \n \t    int sub_count = aapcs_is_vfp_call_or_return_candidate_1\n \t\t\t      (member, fundamental_type);"
    },
    {
      "sha": "57d89b01fec6c6c44886a14ab89561d4f5afaa4e",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1158,7 +1158,7 @@ get_symbol_field_type (struct symbol *sym, char *encoded_field_name)\n \n       fieldno = ada_get_field_index (type, field_name, 1);\n       if (fieldno >= 0)\n-        return TYPE_FIELD_TYPE (type, fieldno);\n+        return type->field (fieldno).type ();\n \n       subfield_name = field_name;\n       while (*subfield_name != '\\0' && *subfield_name != '.' \n@@ -1173,7 +1173,7 @@ get_symbol_field_type (struct symbol *sym, char *encoded_field_name)\n       if (fieldno < 0)\n         return NULL;\n \n-      type = TYPE_FIELD_TYPE (type, fieldno);\n+      type = type->field (fieldno).type ();\n       field_name = subfield_name;\n     }\n "
    },
    {
      "sha": "f7b973f36ee16ad235a74a85073e810c963f33e2",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 54,
      "deletions": 58,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1420,8 +1420,8 @@ ada_fixup_array_indexes_type (struct type *index_desc_type)\n      If our INDEX_DESC_TYPE was generated using the older encoding,\n      the field type should be a meaningless integer type whose name\n      is not equal to the field name.  */\n-  if (TYPE_FIELD_TYPE (index_desc_type, 0)->name () != NULL\n-      && strcmp (TYPE_FIELD_TYPE (index_desc_type, 0)->name (),\n+  if (index_desc_type->field (0).type ()->name () != NULL\n+      && strcmp (index_desc_type->field (0).type ()->name (),\n                  TYPE_FIELD_NAME (index_desc_type, 0)) == 0)\n     return;\n \n@@ -1622,7 +1622,7 @@ fat_pntr_bounds_bitsize (struct type *type)\n   if (TYPE_FIELD_BITSIZE (type, 1) > 0)\n     return TYPE_FIELD_BITSIZE (type, 1);\n   else\n-    return 8 * TYPE_LENGTH (ada_check_typedef (TYPE_FIELD_TYPE (type, 1)));\n+    return 8 * TYPE_LENGTH (ada_check_typedef (type->field (1).type ()));\n }\n \n /* If TYPE is the type of an array descriptor (fat or thin pointer) or a\n@@ -1637,7 +1637,7 @@ desc_data_target_type (struct type *type)\n \n   /* NOTE: The following is bogus; see comment in desc_bounds.  */\n   if (is_thin_pntr (type))\n-    return desc_base_type (TYPE_FIELD_TYPE (thin_descriptor_type (type), 1));\n+    return desc_base_type (thin_descriptor_type (type)->field (1).type ());\n   else if (is_thick_pntr (type))\n     {\n       struct type *data_type = lookup_struct_elt_type (type, \"P_ARRAY\", 1);\n@@ -1688,7 +1688,7 @@ fat_pntr_data_bitsize (struct type *type)\n   if (TYPE_FIELD_BITSIZE (type, 0) > 0)\n     return TYPE_FIELD_BITSIZE (type, 0);\n   else\n-    return TARGET_CHAR_BIT * TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0));\n+    return TARGET_CHAR_BIT * TYPE_LENGTH (type->field (0).type ());\n }\n \n /* If BOUNDS is an array-bounds structure (or pointer to one), return\n@@ -1727,7 +1727,7 @@ desc_bound_bitsize (struct type *type, int i, int which)\n   if (TYPE_FIELD_BITSIZE (type, 2 * i + which - 2) > 0)\n     return TYPE_FIELD_BITSIZE (type, 2 * i + which - 2);\n   else\n-    return 8 * TYPE_LENGTH (TYPE_FIELD_TYPE (type, 2 * i + which - 2));\n+    return 8 * TYPE_LENGTH (type->field (2 * i + which - 2).type ());\n }\n \n /* If TYPE is the type of an array-bounds structure, the type of its\n@@ -2078,7 +2078,7 @@ constrained_packed_array_type (struct type *type, long *elt_bits)\n \n   index_type_desc = ada_find_parallel_type (type, \"___XA\");\n   if (index_type_desc)\n-    index_type = to_fixed_range_type (TYPE_FIELD_TYPE (index_type_desc, 0),\n+    index_type = to_fixed_range_type (index_type_desc->field (0).type (),\n \t\t\t\t      NULL);\n   else\n     index_type = type->index_type ();\n@@ -2948,7 +2948,7 @@ ada_array_bound_from_type (struct type *arr_type, int n, int which)\n     }\n \n   if (index_type_desc != NULL)\n-    index_type = to_fixed_range_type (TYPE_FIELD_TYPE (index_type_desc, n - 1),\n+    index_type = to_fixed_range_type (index_type_desc->field (n - 1).type (),\n \t\t\t\t      NULL);\n   else\n     {\n@@ -3163,7 +3163,7 @@ ada_print_symbol_signature (struct ui_file *stream, struct symbol *sym,\n \t{\n \t  if (i > 0)\n \t    fprintf_filtered (stream, \"; \");\n-\t  ada_print_type (TYPE_FIELD_TYPE (type, i), NULL, stream, -1, 0,\n+\t  ada_print_type (type->field (i).type (), NULL, stream, -1, 0,\n \t\t\t  flags);\n \t}\n       fprintf_filtered (stream, \")\");\n@@ -3854,8 +3854,7 @@ ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)\n         return 0;\n       else\n         {\n-          struct type *ftype = ada_check_typedef (TYPE_FIELD_TYPE (func_type,\n-\t\t\t\t\t\t\t\t   i));\n+          struct type *ftype = ada_check_typedef (func_type->field (i).type ());\n           struct type *atype = ada_check_typedef (value_type (actuals[i]));\n \n           if (!ada_type_match (ftype, atype, 1))\n@@ -4505,14 +4504,14 @@ make_array_descriptor (struct type *type, struct value *arr)\n   modify_field (value_type (descriptor),\n \t\tvalue_contents_writeable (descriptor),\n \t\tvalue_pointer (ensure_lval (arr),\n-\t\t\t       TYPE_FIELD_TYPE (desc_type, 0)),\n+\t\t\t       desc_type->field (0).type ()),\n \t\tfat_pntr_data_bitpos (desc_type),\n \t\tfat_pntr_data_bitsize (desc_type));\n \n   modify_field (value_type (descriptor),\n \t\tvalue_contents_writeable (descriptor),\n \t\tvalue_pointer (bounds,\n-\t\t\t       TYPE_FIELD_TYPE (desc_type, 1)),\n+\t\t\t       desc_type->field (1).type ()),\n \t\tfat_pntr_bounds_bitpos (desc_type),\n \t\tfat_pntr_bounds_bitsize (desc_type));\n \n@@ -6480,8 +6479,8 @@ ada_is_ignored_field (struct type *type, int field_num)\n   /* If this is the dispatch table of a tagged type or an interface tag,\n      then ignore.  */\n   if (ada_is_tagged_type (type, 1)\n-      && (ada_is_dispatch_table_ptr_type (TYPE_FIELD_TYPE (type, field_num))\n-\t  || ada_is_interface_tag (TYPE_FIELD_TYPE (type, field_num))))\n+      && (ada_is_dispatch_table_ptr_type (type->field (field_num).type ())\n+\t  || ada_is_interface_tag (type->field (field_num).type ())))\n     return 1;\n \n   /* Not a special field, so it should not be ignored.  */\n@@ -6792,7 +6791,7 @@ ada_parent_type (struct type *type)\n   for (i = 0; i < type->num_fields (); i += 1)\n     if (ada_is_parent_field (type, i))\n       {\n-        struct type *parent_type = TYPE_FIELD_TYPE (type, i);\n+        struct type *parent_type = type->field (i).type ();\n \n         /* If the _parent field is a pointer, then dereference it.  */\n         if (parent_type->code () == TYPE_CODE_PTR)\n@@ -6860,7 +6859,7 @@ ada_is_variant_part (struct type *type, int field_num)\n   if (!ADA_TYPE_P (type))\n     return 0;\n \n-  struct type *field_type = TYPE_FIELD_TYPE (type, field_num);\n+  struct type *field_type = type->field (field_num).type ();\n \n   return (field_type->code () == TYPE_CODE_UNION\n \t  || (is_dynamic_field (type, field_num)\n@@ -7049,7 +7048,7 @@ ada_value_primitive_field (struct value *arg1, int offset, int fieldno,\n   struct type *type;\n \n   arg_type = ada_check_typedef (arg_type);\n-  type = TYPE_FIELD_TYPE (arg_type, fieldno);\n+  type = arg_type->field (fieldno).type ();\n \n   /* Handle packed fields.  It might be that the field is not packed\n      relative to its containing structure, but the structure itself is\n@@ -7180,7 +7179,7 @@ find_struct_field (const char *name, struct type *type, int offset,\n           int bit_size = TYPE_FIELD_BITSIZE (type, i);\n \n \t  if (field_type_p != NULL)\n-\t    *field_type_p = TYPE_FIELD_TYPE (type, i);\n+\t    *field_type_p = type->field (i).type ();\n \t  if (byte_offset_p != NULL)\n \t    *byte_offset_p = fld_offset;\n \t  if (bit_offset_p != NULL)\n@@ -7191,7 +7190,7 @@ find_struct_field (const char *name, struct type *type, int offset,\n         }\n       else if (ada_is_wrapper_field (type, i))\n         {\n-\t  if (find_struct_field (name, TYPE_FIELD_TYPE (type, i), fld_offset,\n+\t  if (find_struct_field (name, type->field (i).type (), fld_offset,\n \t\t\t\t field_type_p, byte_offset_p, bit_offset_p,\n \t\t\t\t bit_size_p, index_p))\n             return 1;\n@@ -7202,11 +7201,11 @@ find_struct_field (const char *name, struct type *type, int offset,\n \t     fixed type?? */\n           int j;\n           struct type *field_type\n-\t    = ada_check_typedef (TYPE_FIELD_TYPE (type, i));\n+\t    = ada_check_typedef (type->field (i).type ());\n \n           for (j = 0; j < field_type->num_fields (); j += 1)\n             {\n-              if (find_struct_field (name, TYPE_FIELD_TYPE (field_type, j),\n+              if (find_struct_field (name, field_type->field (j).type (),\n                                      fld_offset\n                                      + TYPE_FIELD_BITPOS (field_type, j) / 8,\n                                      field_type_p, byte_offset_p,\n@@ -7226,7 +7225,7 @@ find_struct_field (const char *name, struct type *type, int offset,\n       int bit_pos = TYPE_FIELD_BITPOS (type, parent_offset);\n       int fld_offset = offset + bit_pos / 8;\n \n-      if (find_struct_field (name, TYPE_FIELD_TYPE (type, parent_offset),\n+      if (find_struct_field (name, type->field (parent_offset).type (),\n                              fld_offset, field_type_p, byte_offset_p,\n                              bit_offset_p, bit_size_p, index_p))\n         return 1;\n@@ -7293,7 +7292,7 @@ ada_search_struct_field (const char *name, struct value *arg, int offset,\n           struct value *v =     /* Do not let indent join lines here.  */\n             ada_search_struct_field (name, arg,\n                                      offset + TYPE_FIELD_BITPOS (type, i) / 8,\n-                                     TYPE_FIELD_TYPE (type, i));\n+                                     type->field (i).type ());\n \n           if (v != NULL)\n             return v;\n@@ -7303,8 +7302,7 @@ ada_search_struct_field (const char *name, struct value *arg, int offset,\n         {\n \t  /* PNH: Do we ever get here?  See find_struct_field.  */\n           int j;\n-          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type,\n-\t\t\t\t\t\t\t\t\ti));\n+          struct type *field_type = ada_check_typedef (type->field (i).type ());\n           int var_offset = offset + TYPE_FIELD_BITPOS (type, i) / 8;\n \n           for (j = 0; j < field_type->num_fields (); j += 1)\n@@ -7313,7 +7311,7 @@ ada_search_struct_field (const char *name, struct value *arg, int offset,\n \t\t\t\t\t\t\t   break.  */\n                 (name, arg,\n                  var_offset + TYPE_FIELD_BITPOS (field_type, j) / 8,\n-                 TYPE_FIELD_TYPE (field_type, j));\n+                 field_type->field (j).type ());\n \n               if (v != NULL)\n                 return v;\n@@ -7328,7 +7326,7 @@ ada_search_struct_field (const char *name, struct value *arg, int offset,\n     {\n       struct value *v = ada_search_struct_field (\n \tname, arg, offset + TYPE_FIELD_BITPOS (type, parent_offset) / 8,\n-\tTYPE_FIELD_TYPE (type, parent_offset));\n+\ttype->field (parent_offset).type ());\n \n       if (v != NULL)\n         return v;\n@@ -7374,7 +7372,7 @@ ada_index_struct_field_1 (int *index_p, struct value *arg, int offset,\n           struct value *v =     /* Do not let indent join lines here.  */\n             ada_index_struct_field_1 (index_p, arg,\n \t\t\t\t      offset + TYPE_FIELD_BITPOS (type, i) / 8,\n-\t\t\t\t      TYPE_FIELD_TYPE (type, i));\n+\t\t\t\t      type->field (i).type ());\n \n           if (v != NULL)\n             return v;\n@@ -7481,11 +7479,11 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n         }\n \n       else if (field_name_match (t_field_name, name))\n-\treturn TYPE_FIELD_TYPE (type, i);\n+\treturn type->field (i).type ();\n \n       else if (ada_is_wrapper_field (type, i))\n         {\n-          t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name,\n+          t = ada_lookup_struct_elt_type (type->field (i).type (), name,\n                                           0, 1);\n           if (t != NULL)\n \t    return t;\n@@ -7494,8 +7492,7 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n       else if (ada_is_variant_part (type, i))\n         {\n           int j;\n-          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type,\n-\t\t\t\t\t\t\t\t\ti));\n+          struct type *field_type = ada_check_typedef (type->field (i).type ());\n \n           for (j = field_type->num_fields () - 1; j >= 0; j -= 1)\n             {\n@@ -7507,10 +7504,9 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n \n \t      if (v_field_name != NULL \n \t\t  && field_name_match (v_field_name, name))\n-\t\tt = TYPE_FIELD_TYPE (field_type, j);\n+\t\tt = field_type->field (j).type ();\n \t      else\n-\t\tt = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (field_type,\n-\t\t\t\t\t\t\t\t j),\n+\t\tt = ada_lookup_struct_elt_type (field_type->field (j).type (),\n \t\t\t\t\t\tname, 0, 1);\n \n               if (t != NULL)\n@@ -7527,7 +7523,7 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n       {\n         struct type *t;\n \n-        t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, parent_offset),\n+        t = ada_lookup_struct_elt_type (type->field (parent_offset).type (),\n                                         name, 0, 1);\n         if (t != NULL)\n \t  return t;\n@@ -7916,7 +7912,7 @@ is_dynamic_field (struct type *templ_type, int field_num)\n   const char *name = TYPE_FIELD_NAME (templ_type, field_num);\n \n   return name != NULL\n-    && TYPE_FIELD_TYPE (templ_type, field_num)->code () == TYPE_CODE_PTR\n+    && templ_type->field (field_num).type ()->code () == TYPE_CODE_PTR\n     && strstr (name, \"___XVL\") != NULL;\n }\n \n@@ -8029,7 +8025,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t  const gdb_byte *field_valaddr = valaddr;\n \t  CORE_ADDR field_address = address;\n \t  struct type *field_type =\n-\t    TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f));\n+\t    TYPE_TARGET_TYPE (type->field (f).type ());\n \n           if (dval0 == NULL)\n \t    {\n@@ -8097,7 +8093,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t     adding overflow recovery code to this already complex code,\n \t     we just assume that it's not going to happen.  */\n           fld_bit_len =\n-            TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, f)) * TARGET_CHAR_BIT;\n+            TYPE_LENGTH (rtype->field (f).type ()) * TARGET_CHAR_BIT;\n         }\n       else\n         {\n@@ -8111,14 +8107,14 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t     structure, the typedef is the only clue which allows us\n \t     to distinguish between the two options.  Stripping it\n \t     would prevent us from printing this field appropriately.  */\n-          rtype->field (f).set_type (TYPE_FIELD_TYPE (type, f));\n+          rtype->field (f).set_type (type->field (f).type ());\n           TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);\n           if (TYPE_FIELD_BITSIZE (type, f) > 0)\n             fld_bit_len =\n               TYPE_FIELD_BITSIZE (rtype, f) = TYPE_FIELD_BITSIZE (type, f);\n           else\n \t    {\n-\t      struct type *field_type = TYPE_FIELD_TYPE (type, f);\n+\t      struct type *field_type = type->field (f).type ();\n \n \t      /* We need to be careful of typedefs when computing\n \t\t the length of our field.  If this is a typedef,\n@@ -8162,7 +8158,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \n       branch_type =\n         to_fixed_variant_branch_type\n-        (TYPE_FIELD_TYPE (type, variant_field),\n+        (type->field (variant_field).type (),\n          cond_offset_host (valaddr, off / TARGET_CHAR_BIT),\n          cond_offset_target (address, off / TARGET_CHAR_BIT), dval);\n       if (branch_type == NULL)\n@@ -8176,7 +8172,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n           rtype->field (variant_field).set_type (branch_type);\n           TYPE_FIELD_NAME (rtype, variant_field) = \"S\";\n           fld_bit_len =\n-            TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, variant_field)) *\n+            TYPE_LENGTH (rtype->field (variant_field).type ()) *\n             TARGET_CHAR_BIT;\n           if (off + fld_bit_len > bit_len)\n             bit_len = off + fld_bit_len;\n@@ -8257,7 +8253,7 @@ template_to_static_fixed_type (struct type *type0)\n \n   for (f = 0; f < nfields; f += 1)\n     {\n-      struct type *field_type = TYPE_FIELD_TYPE (type0, f);\n+      struct type *field_type = type0->field (f).type ();\n       struct type *new_type;\n \n       if (is_dynamic_field (type0, f))\n@@ -8341,7 +8337,7 @@ to_record_with_fixed_variant_part (struct type *type, const gdb_byte *valaddr,\n   TYPE_LENGTH (rtype) = TYPE_LENGTH (type);\n \n   branch_type = to_fixed_variant_branch_type\n-    (TYPE_FIELD_TYPE (type, variant_field),\n+    (type->field (variant_field).type (),\n      cond_offset_host (valaddr,\n                        TYPE_FIELD_BITPOS (type, variant_field)\n                        / TARGET_CHAR_BIT),\n@@ -8363,7 +8359,7 @@ to_record_with_fixed_variant_part (struct type *type, const gdb_byte *valaddr,\n       TYPE_FIELD_BITSIZE (rtype, variant_field) = 0;\n       TYPE_LENGTH (rtype) += TYPE_LENGTH (branch_type);\n     }\n-  TYPE_LENGTH (rtype) -= TYPE_LENGTH (TYPE_FIELD_TYPE (type, variant_field));\n+  TYPE_LENGTH (rtype) -= TYPE_LENGTH (type->field (variant_field).type ());\n \n   value_free_to_mark (mark);\n   return rtype;\n@@ -8449,14 +8445,14 @@ to_fixed_variant_branch_type (struct type *var_type0, const gdb_byte *valaddr,\n     return empty_record (var_type);\n   else if (is_dynamic_field (var_type, which))\n     return to_fixed_record_type\n-      (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (var_type, which)),\n+      (TYPE_TARGET_TYPE (var_type->field (which).type ()),\n        valaddr, address, dval);\n-  else if (variant_field_index (TYPE_FIELD_TYPE (var_type, which)) >= 0)\n+  else if (variant_field_index (var_type->field (which).type ()) >= 0)\n     return\n       to_fixed_record_type\n-      (TYPE_FIELD_TYPE (var_type, which), valaddr, address, dval);\n+      (var_type->field (which).type (), valaddr, address, dval);\n   else\n-    return TYPE_FIELD_TYPE (var_type, which);\n+    return var_type->field (which).type ();\n }\n \n /* Assuming RANGE_TYPE is a TYPE_CODE_RANGE, return nonzero if\n@@ -8523,7 +8519,7 @@ ada_is_redundant_index_type_desc (struct type *array_type,\n   for (i = 0; i < desc_type->num_fields (); i++)\n     {\n       if (!ada_is_redundant_range_encoding (this_layer->index_type (),\n-\t\t\t\t\t    TYPE_FIELD_TYPE (desc_type, i)))\n+\t\t\t\t\t    desc_type->field (i).type ()))\n \treturn 0;\n       this_layer = check_typedef (TYPE_TARGET_TYPE (this_layer));\n     }\n@@ -8645,7 +8641,7 @@ to_fixed_array_type (struct type *type0, struct value *dval,\n       for (i = index_type_desc->num_fields () - 1; i >= 0; i -= 1)\n         {\n           struct type *range_type =\n-            to_fixed_range_type (TYPE_FIELD_TYPE (index_type_desc, i), dval);\n+            to_fixed_range_type (index_type_desc->field (i).type (), dval);\n \n           result = create_array_type (alloc_type_copy (elt_type0),\n                                       result, range_type);\n@@ -8900,7 +8896,7 @@ static_unwrap_type (struct type *type)\n {\n   if (ada_is_aligner_type (type))\n     {\n-      struct type *type1 = TYPE_FIELD_TYPE (ada_check_typedef (type), 0);\n+      struct type *type1 = ada_check_typedef (type)->field (0).type ();\n       if (ada_type_name (type1) == NULL)\n \ttype1->set_name (ada_type_name (type));\n \n@@ -9202,7 +9198,7 @@ ada_get_base_type (struct type *raw_type)\n       || real_type_namer->num_fields () != 1)\n     return raw_type;\n \n-  if (TYPE_FIELD_TYPE (real_type_namer, 0)->code () != TYPE_CODE_REF)\n+  if (real_type_namer->field (0).type ()->code () != TYPE_CODE_REF)\n     {\n       /* This is an older encoding form where the base type needs to be\n \t looked up by name.  We prefer the newer encoding because it is\n@@ -9215,7 +9211,7 @@ ada_get_base_type (struct type *raw_type)\n     }\n \n   /* The field in our XVS type is a reference to the base type.  */\n-  return TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (real_type_namer, 0));\n+  return TYPE_TARGET_TYPE (real_type_namer->field (0).type ());\n }\n \n /* The type of value designated by TYPE, with all aligners removed.  */\n@@ -9224,7 +9220,7 @@ struct type *\n ada_aligned_type (struct type *type)\n {\n   if (ada_is_aligner_type (type))\n-    return ada_aligned_type (TYPE_FIELD_TYPE (type, 0));\n+    return ada_aligned_type (type->field (0).type ());\n   else\n     return ada_get_base_type (type);\n }\n@@ -9237,7 +9233,7 @@ const gdb_byte *\n ada_aligned_value_addr (struct type *type, const gdb_byte *valaddr)\n {\n   if (ada_is_aligner_type (type))\n-    return ada_aligned_value_addr (TYPE_FIELD_TYPE (type, 0),\n+    return ada_aligned_value_addr (type->field (0).type (),\n                                    valaddr +\n                                    TYPE_FIELD_BITPOS (type,\n                                                       0) / TARGET_CHAR_BIT);"
    },
    {
      "sha": "785a91c6ed0ba78663273497db6f8c769d2ae347",
      "filename": "gdb/ada-tasks.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-tasks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-tasks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-tasks.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -430,7 +430,7 @@ read_fat_string_value (char *dest, struct value *val, int max_len)\n       array_fieldno = ada_get_field_index (type, \"P_ARRAY\", 0);\n       bounds_fieldno = ada_get_field_index (type, \"P_BOUNDS\", 0);\n \n-      bounds_type = TYPE_FIELD_TYPE (type, bounds_fieldno);\n+      bounds_type = type->field (bounds_fieldno).type ();\n       if (bounds_type->code () == TYPE_CODE_PTR)\n         bounds_type = TYPE_TARGET_TYPE (bounds_type);\n       if (bounds_type->code () != TYPE_CODE_STRUCT)"
    },
    {
      "sha": "165ea0ee4aa8b28352e3aef54f5c69e69675205c",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -424,7 +424,7 @@ print_array_type (struct type *type, struct ui_file *stream, int show,\n \t    {\n \t      if (k > 0)\n \t\tfprintf_filtered (stream, \", \");\n-\t      print_range_type (TYPE_FIELD_TYPE (range_desc_type, k),\n+\t      print_range_type (range_desc_type->field (k).type (),\n \t\t\t\tstream, 0 /* bounds_prefered_p */);\n \t      if (TYPE_FIELD_BITSIZE (arr_type, 0) > 0)\n \t\tbitsize = TYPE_FIELD_BITSIZE (arr_type, 0);\n@@ -549,7 +549,7 @@ print_variant_clauses (struct type *type, int field_num,\n   struct type *var_type, *par_type;\n   struct type *discr_type;\n \n-  var_type = TYPE_FIELD_TYPE (type, field_num);\n+  var_type = type->field (field_num).type ();\n   discr_type = ada_variant_discrim_type (var_type, outer_type);\n \n   if (var_type->code () == TYPE_CODE_PTR)\n@@ -568,7 +568,7 @@ print_variant_clauses (struct type *type, int field_num,\n       fprintf_filtered (stream, \"\\n%*swhen \", level + 4, \"\");\n       if (print_choices (var_type, i, stream, discr_type))\n \t{\n-\t  if (print_record_field_types (TYPE_FIELD_TYPE (var_type, i),\n+\t  if (print_record_field_types (var_type->field (i).type (),\n \t\t\t\t\touter_type, stream, show, level + 4,\n \t\t\t\t\tflags)\n \t      <= 0)\n@@ -594,7 +594,7 @@ print_variant_part (struct type *type, int field_num, struct type *outer_type,\n \t\t    const struct type_print_options *flags)\n {\n   const char *variant\n-    = ada_variant_discrim_name (TYPE_FIELD_TYPE (type, field_num));\n+    = ada_variant_discrim_name (type->field (field_num).type ());\n   if (*variant == '\\0')\n     variant = \"?\";\n \n@@ -633,7 +633,7 @@ print_selected_record_field_types (struct type *type, struct type *outer_type,\n       if (ada_is_parent_field (type, i) || ada_is_ignored_field (type, i))\n \t;\n       else if (ada_is_wrapper_field (type, i))\n-\tflds += print_record_field_types (TYPE_FIELD_TYPE (type, i), type,\n+\tflds += print_record_field_types (type->field (i).type (), type,\n \t\t\t\t\t  stream, show, level, flags);\n       else if (ada_is_variant_part (type, i))\n \t{\n@@ -644,7 +644,7 @@ print_selected_record_field_types (struct type *type, struct type *outer_type,\n \t{\n \t  flds += 1;\n \t  fprintf_filtered (stream, \"\\n%*s\", level + 4, \"\");\n-\t  ada_print_type (TYPE_FIELD_TYPE (type, i),\n+\t  ada_print_type (type->field (i).type (),\n \t\t\t  TYPE_FIELD_NAME (type, i),\n \t\t\t  stream, show - 1, level + 4, flags);\n \t  fprintf_filtered (stream, \";\");\n@@ -708,7 +708,7 @@ print_variant_part (const variant_part &part,\n   else\n     {\n       name = TYPE_FIELD_NAME (type, part.discriminant_index);\n-      discr_type = TYPE_FIELD_TYPE (type, part.discriminant_index);\n+      discr_type = type->field (part.discriminant_index).type ();\n     }\n \n   fprintf_filtered (stream, \"\\n%*scase %s is\", level + 4, \"\", name);\n@@ -875,7 +875,7 @@ print_unchecked_union_type (struct type *type, struct ui_file *stream,\n \t{\n \t  fprintf_filtered (stream, \"\\n%*swhen ? =>\\n%*s\", level + 8, \"\",\n \t\t\t    level + 12, \"\");\n-\t  ada_print_type (TYPE_FIELD_TYPE (type, i),\n+\t  ada_print_type (type->field (i).type (),\n \t\t\t  TYPE_FIELD_NAME (type, i),\n \t\t\t  stream, show - 1, level + 12, flags);\n \t  fprintf_filtered (stream, \";\");\n@@ -920,7 +920,7 @@ print_func_type (struct type *type, struct ui_file *stream, const char *name,\n \t      wrap_here (\"    \");\n \t    }\n \t  fprintf_filtered (stream, \"a%d: \", i + 1);\n-\t  ada_print_type (TYPE_FIELD_TYPE (type, i), \"\", stream, -1, 0,\n+\t  ada_print_type (type->field (i).type (), \"\", stream, -1, 0,\n \t\t\t  flags);\n \t}\n       fprintf_filtered (stream, \")\");"
    },
    {
      "sha": "a36e7ca793a396e65d421e1dfd43ee8702842eb4",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -542,7 +542,7 @@ print_variant_part (struct value *value, int field_num,\n \t\t    const struct language_defn *language)\n {\n   struct type *type = value_type (value);\n-  struct type *var_type = TYPE_FIELD_TYPE (type, field_num);\n+  struct type *var_type = type->field (field_num).type ();\n   int which = ada_which_variant_applies (var_type, outer_value);\n \n   if (which < 0)\n@@ -617,7 +617,7 @@ print_field_values (struct value *value, struct value *outer_value,\n \t  wrap_here (n_spaces (2 + 2 * recurse));\n \t}\n \n-      annotate_field_begin (TYPE_FIELD_TYPE (type, i));\n+      annotate_field_begin (type->field (i).type ());\n       fprintf_filtered (stream, \"%.*s\",\n \t\t\tada_name_prefix_len (TYPE_FIELD_NAME (type, i)),\n \t\t\tTYPE_FIELD_NAME (type, i));\n@@ -641,12 +641,12 @@ print_field_values (struct value *value, struct value *outer_value,\n \t      int bit_size = TYPE_FIELD_BITSIZE (type, i);\n \t      struct value_print_options opts;\n \n-\t      adjust_type_signedness (TYPE_FIELD_TYPE (type, i));\n+\t      adjust_type_signedness (type->field (i).type ());\n \t      v = ada_value_primitive_packed_val\n \t\t    (value, nullptr,\n \t\t     bit_pos / HOST_CHAR_BIT,\n \t\t     bit_pos % HOST_CHAR_BIT,\n-\t\t     bit_size, TYPE_FIELD_TYPE (type, i));\n+\t\t     bit_size, type->field (i).type ());\n \t      opts = *options;\n \t      opts.deref_ref = 0;\n \t      common_val_print (v, stream, recurse + 1, &opts, language);"
    },
    {
      "sha": "f67fe5002a32d4cfbae0e0c7bf68538b6d486e3f",
      "filename": "gdb/ada-varobj.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ada-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-varobj.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -105,7 +105,7 @@ ada_varobj_struct_elt (struct value *parent_value,\n       type = value_type (value);\n     }\n   else\n-    type = TYPE_FIELD_TYPE (parent_type, fieldno);\n+    type = parent_type->field (fieldno).type ();\n \n   if (child_value)\n     *child_value = value;"
    },
    {
      "sha": "0ce9fbc2997313cdeff434d92851766a17dc510f",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -551,7 +551,7 @@ amd64_has_unaligned_fields (struct type *type)\n     {\n       for (int i = 0; i < type->num_fields (); i++)\n \t{\n-\t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n+\t  struct type *subtype = check_typedef (type->field (i).type ());\n \t  int bitpos = TYPE_FIELD_BITPOS (type, i);\n \t  int align = type_align(subtype);\n \n@@ -587,7 +587,7 @@ amd64_classify_aggregate_field (struct type *type, int i,\n \t\t\t\tenum amd64_reg_class theclass[2],\n \t\t\t\tunsigned int bitoffset)\n {\n-  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n+  struct type *subtype = check_typedef (type->field (i).type ());\n   int bitpos = bitoffset + TYPE_FIELD_BITPOS (type, i);\n   int pos = bitpos / 64;\n   enum amd64_reg_class subclass[2];"
    },
    {
      "sha": "9cedcc8575544be5817c8b58f60e886ec279a066",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -3502,7 +3502,7 @@ arm_vfp_cprc_sub_candidate (struct type *t,\n \t    int sub_count = 0;\n \n \t    if (!field_is_static (&t->field (i)))\n-\t      sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),\n+\t      sub_count = arm_vfp_cprc_sub_candidate (t->field (i).type (),\n \t\t\t\t\t\t      base_type);\n \t    if (sub_count == -1)\n \t      return -1;\n@@ -3528,7 +3528,7 @@ arm_vfp_cprc_sub_candidate (struct type *t,\n \tint i;\n \tfor (i = 0; i < t->num_fields (); i++)\n \t  {\n-\t    int sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),\n+\t    int sub_count = arm_vfp_cprc_sub_candidate (t->field (i).type (),\n \t\t\t\t\t\t\tbase_type);\n \t    if (sub_count == -1)\n \t      return -1;\n@@ -7975,7 +7975,7 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n \t      enum type_code field_type_code;\n \n \t      field_type_code\n-\t\t= check_typedef (TYPE_FIELD_TYPE (type, i))->code ();\n+\t\t= check_typedef (type->field (i).type ())->code ();\n \n \t      /* Is it a floating point type field?  */\n \t      if (field_type_code == TYPE_CODE_FLT)"
    },
    {
      "sha": "34e22b289ecec951d329368cb211b853e0ff3c8e",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1417,7 +1417,7 @@ gen_primitive_field (struct agent_expr *ax, struct axs_value *value,\n {\n   /* Is this a bitfield?  */\n   if (TYPE_FIELD_PACKED (type, fieldno))\n-    gen_bitfield_ref (ax, value, TYPE_FIELD_TYPE (type, fieldno),\n+    gen_bitfield_ref (ax, value, type->field (fieldno).type (),\n \t\t      (offset * TARGET_CHAR_BIT\n \t\t       + TYPE_FIELD_BITPOS (type, fieldno)),\n \t\t      (offset * TARGET_CHAR_BIT\n@@ -1428,7 +1428,7 @@ gen_primitive_field (struct agent_expr *ax, struct axs_value *value,\n       gen_offset (ax, offset\n \t\t  + TYPE_FIELD_BITPOS (type, fieldno) / TARGET_CHAR_BIT);\n       value->kind = axs_lvalue_memory;\n-      value->type = TYPE_FIELD_TYPE (type, fieldno);\n+      value->type = type->field (fieldno).type ();\n     }\n }\n \n@@ -1551,7 +1551,7 @@ gen_static_field (struct agent_expr *ax, struct axs_value *value,\n     {\n       ax_const_l (ax, TYPE_FIELD_STATIC_PHYSADDR (type, fieldno));\n       value->kind = axs_lvalue_memory;\n-      value->type = TYPE_FIELD_TYPE (type, fieldno);\n+      value->type = type->field (fieldno).type ();\n       value->optimized_out = 0;\n     }\n   else"
    },
    {
      "sha": "53137e89b85168d4f65ba775f65230471ed3c60a",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -257,11 +257,11 @@ c_get_string (struct value *value, gdb::unique_xmalloc_ptr<gdb_byte> *buffer,\n       /* If we know the size of the array, we can use it as a limit on\n \t the number of characters to be fetched.  */\n       if (type->num_fields () == 1\n-\t  && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_RANGE)\n+\t  && type->field (0).type ()->code () == TYPE_CODE_RANGE)\n \t{\n \t  LONGEST low_bound, high_bound;\n \n-\t  get_discrete_bounds (TYPE_FIELD_TYPE (type, 0),\n+\t  get_discrete_bounds (type->field (0).type (),\n \t\t\t       &low_bound, &high_bound);\n \t  fetchlimit = high_bound - low_bound + 1;\n \t}"
    },
    {
      "sha": "e10a4858a03cc9371f7b7e63dd34a395ec2beb2b",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -573,7 +573,7 @@ c_type_print_args (struct type *type, struct ui_file *stream,\n \t  wrap_here (\"    \");\n \t}\n \n-      param_type = TYPE_FIELD_TYPE (type, i);\n+      param_type = type->field (i).type ();\n \n       if (language == language_cplus && linkage_name)\n \t{\n@@ -1179,8 +1179,8 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \t  int newshow = show - 1;\n \n \t  if (!is_static && flags->print_offsets\n-\t      && (TYPE_FIELD_TYPE (type, i)->code () == TYPE_CODE_STRUCT\n-\t\t  || TYPE_FIELD_TYPE (type, i)->code () == TYPE_CODE_UNION))\n+\t      && (type->field (i).type ()->code () == TYPE_CODE_STRUCT\n+\t\t  || type->field (i).type ()->code () == TYPE_CODE_UNION))\n \t    {\n \t      /* If we're printing offsets and this field's type is\n \t\t either a struct or an union, then we're interested in\n@@ -1200,10 +1200,10 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \t\t the whole struct/union.  */\n \t      local_podata.end_bitpos\n \t\t= podata->end_bitpos\n-\t\t  - TYPE_LENGTH (TYPE_FIELD_TYPE (type, i)) * TARGET_CHAR_BIT;\n+\t\t  - TYPE_LENGTH (type->field (i).type ()) * TARGET_CHAR_BIT;\n \t    }\n \n-\t  c_print_type_1 (TYPE_FIELD_TYPE (type, i),\n+\t  c_print_type_1 (type->field (i).type (),\n \t\t\t  TYPE_FIELD_NAME (type, i),\n \t\t\t  stream, newshow, level + 4,\n \t\t\t  language, &local_flags, &local_podata);\n@@ -1645,7 +1645,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t\tprint_spaces_filtered (level + 4, stream);\n \t\t/* We pass \"show\" here and not \"show - 1\" to get enum types\n \t\t   printed.  There's no other way to see them.  */\n-\t\tc_print_type_1 (TYPE_FIELD_TYPE (type, i),\n+\t\tc_print_type_1 (type->field (i).type (),\n \t\t\t\tTYPE_FIELD_NAME (type, i),\n \t\t\t\tstream, show, level + 4,\n \t\t\t\tlanguage, &local_flags, podata);"
    },
    {
      "sha": "eefe6f106bb7ed305a478094ff9fef497e84bbba",
      "filename": "gdb/c-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/c-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/c-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -375,7 +375,7 @@ c_value_print_struct (struct value *val, struct ui_file *stream, int recurse,\n \t TYPE_CODE_PTR.)  */\n       struct gdbarch *gdbarch = get_type_arch (type);\n       int offset = TYPE_FIELD_BITPOS (type, VTBL_FNADDR_OFFSET) / 8;\n-      struct type *field_type = TYPE_FIELD_TYPE (type, VTBL_FNADDR_OFFSET);\n+      struct type *field_type = type->field (VTBL_FNADDR_OFFSET).type ();\n       const gdb_byte *valaddr = value_contents_for_printing (val);\n       CORE_ADDR addr = extract_typed_address (valaddr + offset, field_type);\n "
    },
    {
      "sha": "6cc76a1e7ac60c4e31571fdf1913ce74ac118bbd",
      "filename": "gdb/c-varobj.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/c-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/c-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-varobj.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -348,7 +348,7 @@ c_describe_child (const struct varobj *parent, int index,\n \t  {\n \t    if (cname)\n \t      {\n-\t\tif (TYPE_FIELD_TYPE (type, index)->code ()\n+\t\tif (type->field (index).type ()->code ()\n \t\t    == TYPE_CODE_STRUCT)\n \t\t  *cname = ANONYMOUS_STRUCT_NAME;\n \t\telse\n@@ -380,7 +380,7 @@ c_describe_child (const struct varobj *parent, int index,\n \t  }\n \n \tif (ctype)\n-\t  *ctype = TYPE_FIELD_TYPE (type, index);\n+\t  *ctype = type->field (index).type ();\n       }\n       break;\n \n@@ -771,10 +771,10 @@ cplus_describe_child (const struct varobj *parent, int index,\n \t    {\n \t      if (cname)\n \t\t{\n-\t\t  if (TYPE_FIELD_TYPE (type, type_index)->code ()\n+\t\t  if (type->field (type_index).type ()->code ()\n \t\t      == TYPE_CODE_STRUCT)\n \t\t    *cname = ANONYMOUS_STRUCT_NAME;\n-\t\t  else if (TYPE_FIELD_TYPE (type, type_index)->code ()\n+\t\t  else if (type->field (type_index).type ()->code ()\n \t\t\t   == TYPE_CODE_UNION)\n \t\t    *cname = ANONYMOUS_UNION_NAME;\n \t\t}\n@@ -797,7 +797,7 @@ cplus_describe_child (const struct varobj *parent, int index,\n \t    *cvalue = value_struct_element_index (value, type_index);\n \n \t  if (ctype)\n-\t    *ctype = TYPE_FIELD_TYPE (type, type_index);\n+\t    *ctype = type->field (type_index).type ();\n \t}\n       else if (index < TYPE_N_BASECLASSES (type))\n \t{\n@@ -806,11 +806,11 @@ cplus_describe_child (const struct varobj *parent, int index,\n \t    *cname = TYPE_FIELD_NAME (type, index);\n \n \t  if (cvalue && value)\n-\t    *cvalue = value_cast (TYPE_FIELD_TYPE (type, index), value);\n+\t    *cvalue = value_cast (type->field (index).type (), value);\n \n \t  if (ctype)\n \t    {\n-\t      *ctype = TYPE_FIELD_TYPE (type, index);\n+\t      *ctype = type->field (index).type ();\n \t    }\n \n \t  if (cfull_expression)"
    },
    {
      "sha": "4ff757acc6aea09db70f23b6bffee2e0ffa2c230",
      "filename": "gdb/compile/compile-c-symbols.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-c-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-c-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-symbols.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -529,7 +529,7 @@ generate_vla_size (compile_instance *compiler,\n \tfor (i = 0; i < type->num_fields (); ++i)\n \t  if (!field_is_static (&type->field (i)))\n \t    generate_vla_size (compiler, stream, gdbarch, registers_used, pc,\n-\t\t\t       TYPE_FIELD_TYPE (type, i), sym);\n+\t\t\t       type->field (i).type (), sym);\n       }\n       break;\n     }"
    },
    {
      "sha": "aad35887666865dc9980de34700fd3d4984dba1d",
      "filename": "gdb/compile/compile-c-types.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-c-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-c-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-types.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -108,9 +108,9 @@ convert_struct_or_union (compile_c_instance *context, struct type *type)\n       gcc_type field_type;\n       unsigned long bitsize = TYPE_FIELD_BITSIZE (type, i);\n \n-      field_type = context->convert_type (TYPE_FIELD_TYPE (type, i));\n+      field_type = context->convert_type (type->field (i).type ());\n       if (bitsize == 0)\n-\tbitsize = 8 * TYPE_LENGTH (TYPE_FIELD_TYPE (type, i));\n+\tbitsize = 8 * TYPE_LENGTH (type->field (i).type ());\n       context->plugin ().build_add_field (result,\n \t\t\t\t\t  TYPE_FIELD_NAME (type, i),\n \t\t\t\t\t  field_type,\n@@ -178,7 +178,7 @@ convert_func (compile_c_instance *context, struct type *type)\n   array.n_elements = type->num_fields ();\n   array.elements = XNEWVEC (gcc_type, type->num_fields ());\n   for (i = 0; i < type->num_fields (); ++i)\n-    array.elements[i] = context->convert_type (TYPE_FIELD_TYPE (type, i));\n+    array.elements[i] = context->convert_type (type->field (i).type ());\n \n   result = context->plugin ().build_function_type (return_type,\n \t\t\t\t\t\t   &array, is_varargs);"
    },
    {
      "sha": "b04d6c6e4eaaec8c9354b35d8d79cb6275fc6796",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -593,7 +593,7 @@ compile_cplus_convert_struct_or_union_members\n \tfield_name = nullptr;\n \n       gcc_type field_type\n-\t= instance->convert_type (TYPE_FIELD_TYPE (type, i));\n+\t= instance->convert_type (type->field (i).type ());\n \n       if (field_is_static (&type->field (i)))\n \t{\n@@ -648,7 +648,7 @@ compile_cplus_convert_struct_or_union_members\n \t    | get_field_access_flag (type, i);\n \n \t  if (bitsize == 0)\n-\t    bitsize = 8 * TYPE_LENGTH (TYPE_FIELD_TYPE (type, i));\n+\t    bitsize = 8 * TYPE_LENGTH (type->field (i).type ());\n \n \t  instance->plugin ().build_field\n \t    (field_name, field_type, field_flags, bitsize,\n@@ -998,7 +998,7 @@ compile_cplus_convert_func (compile_cplus_instance *instance,\n       else\n \t{\n \t  array.elements[i - artificials]\n-\t    = instance->convert_type (TYPE_FIELD_TYPE (type, i));\n+\t    = instance->convert_type (type->field (i).type ());\n \t}\n     }\n "
    },
    {
      "sha": "2f416079025d44b152440c4632831f316e84bdc2",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -508,7 +508,7 @@ get_regs_type (struct symbol *func_sym, struct objfile *objfile)\n   if (func_type->num_fields () == 0)\n     return NULL;\n \n-  regsp_type = check_typedef (TYPE_FIELD_TYPE (func_type, 0));\n+  regsp_type = check_typedef (func_type->field (0).type ());\n   if (regsp_type->code () != TYPE_CODE_PTR)\n     error (_(\"Invalid type code %d of first parameter of function \\\"%s\\\" \"\n \t     \"in compiled module \\\"%s\\\".\"),\n@@ -540,8 +540,8 @@ store_regs (struct type *regs_type, CORE_ADDR regs_base)\n       ULONGEST reg_bitpos = TYPE_FIELD_BITPOS (regs_type, fieldno);\n       ULONGEST reg_bitsize = TYPE_FIELD_BITSIZE (regs_type, fieldno);\n       ULONGEST reg_offset;\n-      struct type *reg_type = check_typedef (TYPE_FIELD_TYPE (regs_type,\n-\t\t\t\t\t\t\t      fieldno));\n+      struct type *reg_type\n+\t= check_typedef (regs_type->field (fieldno).type ());\n       ULONGEST reg_size = TYPE_LENGTH (reg_type);\n       int regnum;\n       struct value *regval;"
    },
    {
      "sha": "a2f39900053255d7f7ad1ebdad94f362fd78422e",
      "filename": "gdb/compile/compile-object-run.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-object-run.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/compile/compile-object-run.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-run.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -158,14 +158,14 @@ compile_object_run (struct compile_module *module)\n \t{\n \t  gdb_assert (regs_addr != 0);\n \t  vargs[current_arg] = value_from_pointer\n-\t\t\t  (TYPE_FIELD_TYPE (func_type, current_arg), regs_addr);\n+\t\t\t  (func_type->field (current_arg).type (), regs_addr);\n \t  ++current_arg;\n \t}\n       if (func_type->num_fields () >= 2)\n \t{\n \t  gdb_assert (data->out_value_addr != 0);\n \t  vargs[current_arg] = value_from_pointer\n-\t       (TYPE_FIELD_TYPE (func_type, current_arg), data->out_value_addr);\n+\t       (func_type->field (current_arg).type (), data->out_value_addr);\n \t  ++current_arg;\n \t}\n       gdb_assert (current_arg == func_type->num_fields ());"
    },
    {
      "sha": "1ec0a0ed4f1f79c8488e0a6e324ab2756fdebd2b",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1103,10 +1103,10 @@ add_struct_fields (struct type *type, completion_list &output,\n \t\t\t     fieldname, namelen))\n \t\toutput.emplace_back (xstrdup (TYPE_FIELD_NAME (type, i)));\n \t    }\n-\t  else if (TYPE_FIELD_TYPE (type, i)->code () == TYPE_CODE_UNION)\n+\t  else if (type->field (i).type ()->code () == TYPE_CODE_UNION)\n \t    {\n \t      /* Recurse into anonymous unions.  */\n-\t      add_struct_fields (TYPE_FIELD_TYPE (type, i),\n+\t      add_struct_fields (type->field (i).type (),\n \t\t\t\t output, fieldname, namelen);\n \t    }\n \t}"
    },
    {
      "sha": "a02fee6b5524f7ace301787dff0922e67bd6c6cb",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -223,7 +223,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n \t      wrap_here (n_spaces (2 + 2 * recurse));\n \t    }\n \n-\t  annotate_field_begin (TYPE_FIELD_TYPE (type, i));\n+\t  annotate_field_begin (type->field (i).type ());\n \n \t  if (field_is_static (&type->field (i)))\n \t    {\n@@ -301,7 +301,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n \t\t    {\n \t\t      struct value *v = value_static_field (type, i);\n \n-\t\t      cp_print_static_field (TYPE_FIELD_TYPE (type, i),\n+\t\t      cp_print_static_field (type->field (i).type (),\n \t\t\t\t\t     v, stream, recurse + 1,\n \t\t\t\t\t     opts);\n \t\t    }\n@@ -315,7 +315,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n \t      else if (i == vptr_fieldno && type == vptr_basetype)\n \t\t{\n \t\t  int i_offset = TYPE_FIELD_BITPOS (type, i) / 8;\n-\t\t  struct type *i_type = TYPE_FIELD_TYPE (type, i);\n+\t\t  struct type *i_type = type->field (i).type ();\n \n \t\t  if (valprint_check_validity (stream, i_type, i_offset, val))\n \t\t    {\n@@ -655,11 +655,11 @@ cp_find_class_member (struct type **self_p, int *fieldno,\n   for (i = 0; i < TYPE_N_BASECLASSES (self); i++)\n     {\n       LONGEST bitpos = TYPE_FIELD_BITPOS (self, i);\n-      LONGEST bitsize = 8 * TYPE_LENGTH (TYPE_FIELD_TYPE (self, i));\n+      LONGEST bitsize = 8 * TYPE_LENGTH (self->field (i).type ());\n \n       if (offset >= bitpos && offset < bitpos + bitsize)\n \t{\n-\t  *self_p = TYPE_FIELD_TYPE (self, i);\n+\t  *self_p = self->field (i).type ();\n \t  cp_find_class_member (self_p, fieldno, offset - bitpos);\n \t  return;\n \t}"
    },
    {
      "sha": "1c2ddae6f6d4281b09269755678a401533e6cd1c",
      "filename": "gdb/d-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/d-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/d-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -35,7 +35,7 @@ dynamic_array_type (struct type *type,\n \t\t    const struct value_print_options *options)\n {\n   if (type->num_fields () == 2\n-      && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_INT\n+      && type->field (0).type ()->code () == TYPE_CODE_INT\n       && strcmp (TYPE_FIELD_NAME (type, 0), \"length\") == 0\n       && strcmp (TYPE_FIELD_NAME (type, 1), \"ptr\") == 0\n       && !value_bits_any_optimized_out (val,\n@@ -52,7 +52,7 @@ dynamic_array_type (struct type *type,\n \n       length = unpack_field_as_long (type, valaddr + embedded_offset, 0);\n \n-      ptr_type = TYPE_FIELD_TYPE (type, 1);\n+      ptr_type = type->field (1).type ();\n       elttype = check_typedef (TYPE_TARGET_TYPE (ptr_type));\n       addr = unpack_pointer (ptr_type,\n \t\t\t     valaddr + TYPE_FIELD_BITPOS (type, 1) / 8"
    },
    {
      "sha": "97d1771a6295eaf36b4f4e93c13c25e9be287127",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 16,
      "deletions": 18,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -9418,8 +9418,7 @@ alloc_rust_variant (struct obstack *obstack, struct type *type,\n \n   variant_part *part = new (obstack) variant_part;\n   part->discriminant_index = discriminant_index;\n-  part->is_unsigned = TYPE_UNSIGNED (TYPE_FIELD_TYPE (type,\n-\t\t\t\t\t\t      discriminant_index));\n+  part->is_unsigned = TYPE_UNSIGNED (type->field (discriminant_index).type ());\n   part->variants = gdb::array_view<variant> (variants, n_variants);\n \n   void *storage = obstack_alloc (obstack, sizeof (gdb::array_view<variant_part>));\n@@ -9471,7 +9470,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n       /* Decode the field name to find the offset of the\n \t discriminant.  */\n       ULONGEST bit_offset = 0;\n-      struct type *field_type = TYPE_FIELD_TYPE (type, 0);\n+      struct type *field_type = type->field (0).type ();\n       while (name[0] >= '0' && name[0] <= '9')\n \t{\n \t  char *tail;\n@@ -9491,7 +9490,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t  ++name;\n \n \t  bit_offset += TYPE_FIELD_BITPOS (field_type, index);\n-\t  field_type = TYPE_FIELD_TYPE (field_type, index);\n+\t  field_type = field_type->field (index).type ();\n \t}\n \n       /* Smash this type to be a structure type.  We have to do this\n@@ -9513,8 +9512,8 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t field at index 1 and the data-less field at index 2.  */\n       type->field (1) = saved_field;\n       TYPE_FIELD_NAME (type, 1)\n-\t= rust_last_path_segment (TYPE_FIELD_TYPE (type, 1)->name ());\n-      TYPE_FIELD_TYPE (type, 1)->set_name\n+\t= rust_last_path_segment (type->field (1).type ()->name ());\n+      type->field (1).type ()->set_name\n \t(rust_fully_qualify (&objfile->objfile_obstack, type->name (),\n \t\t\t     TYPE_FIELD_NAME (type, 1)));\n \n@@ -9541,7 +9540,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t because the type has already been recorded.  */\n       type->set_code (TYPE_CODE_STRUCT);\n \n-      struct type *field_type = TYPE_FIELD_TYPE (type, 0);\n+      struct type *field_type = type->field (0).type ();\n       const char *variant_name\n \t= rust_last_path_segment (field_type->name ());\n       TYPE_FIELD_NAME (type, 0) = variant_name;\n@@ -9554,7 +9553,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n       struct type *disr_type = nullptr;\n       for (int i = 0; i < type->num_fields (); ++i)\n \t{\n-\t  disr_type = TYPE_FIELD_TYPE (type, i);\n+\t  disr_type = type->field (i).type ();\n \n \t  if (disr_type->code () != TYPE_CODE_STRUCT)\n \t    {\n@@ -9631,7 +9630,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t     That name can be used to look up the correct\n \t     discriminant.  */\n \t  const char *variant_name\n-\t    = rust_last_path_segment (TYPE_FIELD_TYPE (type, i)->name ());\n+\t    = rust_last_path_segment (type->field (i).type ()->name ());\n \n \t  auto iter = discriminant_map.find (variant_name);\n \t  if (iter != discriminant_map.end ())\n@@ -9641,7 +9640,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t    }\n \n \t  /* Remove the discriminant field, if it exists.  */\n-\t  struct type *sub_type = TYPE_FIELD_TYPE (type, i);\n+\t  struct type *sub_type = type->field (i).type ();\n \t  if (sub_type->num_fields () > 0)\n \t    {\n \t      sub_type->set_num_fields (sub_type->num_fields () - 1);\n@@ -10482,9 +10481,8 @@ dwarf2_compute_name (const char *name,\n \t\t     the two cases.  */\n \t\t  if (type->num_fields () > 0\n \t\t      && TYPE_FIELD_ARTIFICIAL (type, 0)\n-\t\t      && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_PTR\n-\t\t      && TYPE_CONST (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type,\n-\t\t\t\t\t\t\t\t\t0))))\n+\t\t      && type->field (0).type ()->code () == TYPE_CODE_PTR\n+\t\t      && TYPE_CONST (TYPE_TARGET_TYPE (type->field (0).type ())))\n \t\t    buf.puts (\" const\");\n \t\t}\n \t    }\n@@ -15242,7 +15240,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n \t      else\n \t\t{\n \t\t  fnp->fcontext\n-\t\t    = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (this_type, 0));\n+\t\t    = TYPE_TARGET_TYPE (this_type->field (0).type ());\n \t\t}\n \t    }\n \t}\n@@ -15340,7 +15338,7 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n     return;\n \n   /* Find the type of the method.  */\n-  pfn_type = TYPE_FIELD_TYPE (type, 0);\n+  pfn_type = type->field (0).type ();\n   if (pfn_type == NULL\n       || pfn_type->code () != TYPE_CODE_PTR\n       || TYPE_TARGET_TYPE (pfn_type)->code () != TYPE_CODE_FUNC)\n@@ -15349,11 +15347,11 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n   /* Look for the \"this\" argument.  */\n   pfn_type = TYPE_TARGET_TYPE (pfn_type);\n   if (pfn_type->num_fields () == 0\n-      /* || TYPE_FIELD_TYPE (pfn_type, 0) == NULL */\n-      || TYPE_FIELD_TYPE (pfn_type, 0)->code () != TYPE_CODE_PTR)\n+      /* || pfn_type->field (0).type () == NULL */\n+      || pfn_type->field (0).type ()->code () != TYPE_CODE_PTR)\n     return;\n \n-  self_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (pfn_type, 0));\n+  self_type = TYPE_TARGET_TYPE (pfn_type->field (0).type ());\n   new_type = alloc_type (objfile);\n   smash_to_method_type (new_type, self_type, TYPE_TARGET_TYPE (pfn_type),\n \t\t\tpfn_type->fields (), pfn_type->num_fields (),"
    },
    {
      "sha": "f975081621635f9382ff0e88d7bc61c56ae0ecc5",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -300,7 +300,7 @@ evaluate_struct_tuple (struct value *struct_val,\n \tfieldno++;\n       if (fieldno >= struct_type->num_fields ())\n \terror (_(\"too many initializers\"));\n-      field_type = TYPE_FIELD_TYPE (struct_type, fieldno);\n+      field_type = struct_type->field (fieldno).type ();\n       if (field_type->code () == TYPE_CODE_UNION\n \t  && TYPE_FIELD_NAME (struct_type, fieldno)[0] == '0')\n \terror (_(\"don't know which variant you want to set\"));\n@@ -314,7 +314,7 @@ evaluate_struct_tuple (struct value *struct_val,\n \t subfieldno is the index of the actual real (named inner) field\n \t in substruct_type.  */\n \n-      field_type = TYPE_FIELD_TYPE (struct_type, fieldno);\n+      field_type = struct_type->field (fieldno).type ();\n       if (val == 0)\n \tval = evaluate_subexp (field_type, exp, pos, noside);\n \n@@ -1059,8 +1059,7 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \t    {\n \t      for (; tem <= nargs && tem <= type->num_fields (); tem++)\n \t\t{\n-\t\t  argvec[tem] = evaluate_subexp (TYPE_FIELD_TYPE (type,\n-\t\t\t\t\t\t\t\t  tem - 1),\n+\t\t  argvec[tem] = evaluate_subexp (type->field (tem - 1).type (),\n \t\t\t\t\t\t exp, pos, noside);\n \t\t}\n \t    }"
    },
    {
      "sha": "f09a4b1f21bfe2da4df7ce74f30f115b7da1f4c8",
      "filename": "gdb/f-typeprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/f-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/f-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-typeprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -273,7 +273,7 @@ f_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n \t\t  fputs_filtered (\", \", stream);\n \t\t  wrap_here (\"    \");\n \t\t}\n-\t      f_print_type (TYPE_FIELD_TYPE (type, i), \"\", stream, -1, 0, 0);\n+\t      f_print_type (type->field (i).type (), \"\", stream, -1, 0, 0);\n \t    }\n \tfprintf_filtered (stream, \")\");\n       }\n@@ -432,12 +432,12 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t  fputs_filtered (\"\\n\", stream);\n \t  for (index = 0; index < type->num_fields (); index++)\n \t    {\n-\t      f_type_print_base (TYPE_FIELD_TYPE (type, index), stream,\n+\t      f_type_print_base (type->field (index).type (), stream,\n \t\t\t\t show - 1, level + 4);\n \t      fputs_filtered (\" :: \", stream);\n \t      fputs_styled (TYPE_FIELD_NAME (type, index),\n \t\t\t    variable_name_style.style (), stream);\n-\t      f_type_print_varspec_suffix (TYPE_FIELD_TYPE (type, index),\n+\t      f_type_print_varspec_suffix (type->field (index).type (),\n \t\t\t\t\t   stream, show - 1, 0, 0, 0, false);\n \t      fputs_filtered (\"\\n\", stream);\n \t    }"
    },
    {
      "sha": "972d1652db72727971a2aabb9d605eb4dfb86a2f",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -317,7 +317,7 @@ f_value_print_innner (struct value *val, struct ui_file *stream, int recurse,\n         {\n \t  struct value *field = value_field (val, index);\n \n-\t  struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, index));\n+\t  struct type *field_type = check_typedef (type->field (index).type ());\n \n \n \t  if (field_type->code () != TYPE_CODE_FUNC)"
    },
    {
      "sha": "b5a13107ede0425ca22a350718af1fba20637511",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1771,7 +1771,7 @@ lookup_struct_elt (struct type *type, const char *name, int noerr)\n      else if (!t_field_name || *t_field_name == '\\0')\n \t{\n \t  struct_elt elt\n-\t    = lookup_struct_elt (TYPE_FIELD_TYPE (type, i), name, 1);\n+\t    = lookup_struct_elt (type->field (i).type (), name, 1);\n \t  if (elt.field != NULL)\n \t    {\n \t      elt.offset += TYPE_FIELD_BITPOS (type, i);\n@@ -2051,7 +2051,7 @@ is_dynamic_type_internal (struct type *type, int top_level)\n \t    if (field_is_static (&type->field (i)))\n \t      continue;\n \t    /* If the field has dynamic type, then so does TYPE.  */\n-\t    if (is_dynamic_type_internal (TYPE_FIELD_TYPE (type, i), 0))\n+\t    if (is_dynamic_type_internal (type->field (i).type (), 0))\n \t      return 1;\n \t    /* If the field is at a fixed offset, then it is not\n \t       dynamic.  */\n@@ -2261,7 +2261,7 @@ resolve_dynamic_union (struct type *type,\n       if (field_is_static (&type->field (i)))\n \tcontinue;\n \n-      t = resolve_dynamic_type_internal (TYPE_FIELD_TYPE (resolved_type, i),\n+      t = resolve_dynamic_type_internal (resolved_type->field (i).type (),\n \t\t\t\t\t addr_stack, 0);\n       resolved_type->field (i).set_type (t);\n       if (TYPE_LENGTH (t) > max_len)\n@@ -2358,15 +2358,15 @@ compute_variant_fields_inner (struct type *type,\n \t  LONGEST bitsize = TYPE_FIELD_BITSIZE (type, idx);\n \t  LONGEST size = bitsize / 8;\n \t  if (size == 0)\n-\t    size = TYPE_LENGTH (TYPE_FIELD_TYPE (type, idx));\n+\t    size = TYPE_LENGTH (type->field (idx).type ());\n \n \t  gdb_byte bits[sizeof (ULONGEST)];\n \t  read_memory (addr, bits, size);\n \n \t  LONGEST bitpos = (TYPE_FIELD_BITPOS (type, idx)\n \t\t\t    % TARGET_CHAR_BIT);\n \n-\t  discr_value = unpack_bits_as_long (TYPE_FIELD_TYPE (type, idx),\n+\t  discr_value = unpack_bits_as_long (type->field (idx).type (),\n \t\t\t\t\t     bits, bitpos, bitsize);\n \t}\n     }\n@@ -2479,7 +2479,7 @@ resolve_dynamic_struct (struct type *type,\n \t{\n \t  struct dwarf2_property_baton baton;\n \t  baton.property_type\n-\t    = lookup_pointer_type (TYPE_FIELD_TYPE (resolved_type, i));\n+\t    = lookup_pointer_type (resolved_type->field (i).type ());\n \t  baton.locexpr = *TYPE_FIELD_DWARF_BLOCK (resolved_type, i);\n \n \t  struct dynamic_prop prop;\n@@ -2504,15 +2504,15 @@ resolve_dynamic_struct (struct type *type,\n \terror (_(\"Cannot determine struct field location\"\n \t\t \" (invalid location kind)\"));\n \n-      pinfo.type = check_typedef (TYPE_FIELD_TYPE (resolved_type, i));\n+      pinfo.type = check_typedef (resolved_type->field (i).type ());\n       pinfo.valaddr = addr_stack->valaddr;\n       pinfo.addr\n \t= (addr_stack->addr\n \t   + (TYPE_FIELD_BITPOS (resolved_type, i) / TARGET_CHAR_BIT));\n       pinfo.next = addr_stack;\n \n       resolved_type->field (i).set_type\n-\t(resolve_dynamic_type_internal (TYPE_FIELD_TYPE (resolved_type, i),\n+\t(resolve_dynamic_type_internal (resolved_type->field (i).type (),\n \t\t\t\t\t&pinfo, 0));\n       gdb_assert (TYPE_FIELD_LOC_KIND (resolved_type, i)\n \t\t  == FIELD_LOC_KIND_BITPOS);\n@@ -2521,7 +2521,7 @@ resolve_dynamic_struct (struct type *type,\n       if (TYPE_FIELD_BITSIZE (resolved_type, i) != 0)\n \tnew_bit_length += TYPE_FIELD_BITSIZE (resolved_type, i);\n       else\n-\tnew_bit_length += (TYPE_LENGTH (TYPE_FIELD_TYPE (resolved_type, i))\n+\tnew_bit_length += (TYPE_LENGTH (resolved_type->field (i).type ())\n \t\t\t   * TARGET_CHAR_BIT);\n \n       /* Normally, we would use the position and size of the last field\n@@ -3403,7 +3403,7 @@ type_align (struct type *type)\n \t    if (!field_is_static (&type->field (i)))\n \t      {\n \t\tnumber_of_non_static_fields++;\n-\t\tULONGEST f_align = type_align (TYPE_FIELD_TYPE (type, i));\n+\t\tULONGEST f_align = type_align (type->field (i).type ());\n \t\tif (f_align == 0)\n \t\t  {\n \t\t    /* Don't pretend we know something we don't.  */\n@@ -3552,14 +3552,14 @@ is_scalar_type_recursive (struct type *t)\n     }\n   /* Are we dealing with a struct with one element?  */\n   else if (t->code () == TYPE_CODE_STRUCT && t->num_fields () == 1)\n-    return is_scalar_type_recursive (TYPE_FIELD_TYPE (t, 0));\n+    return is_scalar_type_recursive (t->field (0).type ());\n   else if (t->code () == TYPE_CODE_UNION)\n     {\n       int i, n = t->num_fields ();\n \n       /* If all elements of the union are scalar, then the union is scalar.  */\n       for (i = 0; i < n; i++)\n-\tif (!is_scalar_type_recursive (TYPE_FIELD_TYPE (t, i)))\n+\tif (!is_scalar_type_recursive (t->field (i).type ()))\n \t  return 0;\n \n       return 1;\n@@ -3960,7 +3960,7 @@ types_equal (struct type *a, struct type *b)\n \treturn false;\n \n       for (i = 0; i < a->num_fields (); ++i)\n-\tif (!types_equal (TYPE_FIELD_TYPE (a, i), TYPE_FIELD_TYPE (b, i)))\n+\tif (!types_equal (a->field (i).type (), b->field (i).type ()))\n \t  return false;\n \n       return true;\n@@ -4553,8 +4553,8 @@ rank_one_type_parm_set (struct type *parm, struct type *arg, struct value *value\n     {\n       /* Not in C++ */\n     case TYPE_CODE_SET:\n-      return rank_one_type (TYPE_FIELD_TYPE (parm, 0),\n-\t\t\t    TYPE_FIELD_TYPE (arg, 0), NULL);\n+      return rank_one_type (parm->field (0).type (),\n+\t\t\t    arg->field (0).type (), NULL);\n     default:\n       return INCOMPATIBLE_TYPE_BADNESS;\n     }\n@@ -5125,16 +5125,16 @@ recursive_dump_type (struct type *type, int spaces)\n \t\t\t  \"[%d] bitpos %s bitsize %d type \",\n \t\t\t  idx, plongest (TYPE_FIELD_BITPOS (type, idx)),\n \t\t\t  TYPE_FIELD_BITSIZE (type, idx));\n-      gdb_print_host_address (TYPE_FIELD_TYPE (type, idx), gdb_stdout);\n+      gdb_print_host_address (type->field (idx).type (), gdb_stdout);\n       printf_filtered (\" name '%s' (\",\n \t\t       TYPE_FIELD_NAME (type, idx) != NULL\n \t\t       ? TYPE_FIELD_NAME (type, idx)\n \t\t       : \"<NULL>\");\n       gdb_print_host_address (TYPE_FIELD_NAME (type, idx), gdb_stdout);\n       printf_filtered (\")\\n\");\n-      if (TYPE_FIELD_TYPE (type, idx) != NULL)\n+      if (type->field (idx).type () != NULL)\n \t{\n-\t  recursive_dump_type (TYPE_FIELD_TYPE (type, idx), spaces + 4);\n+\t  recursive_dump_type (type->field (idx).type (), spaces + 4);\n \t}\n     }\n   if (type->code () == TYPE_CODE_RANGE)\n@@ -5320,9 +5320,9 @@ copy_type_recursive (struct objfile *objfile,\n \t  TYPE_FIELD_ARTIFICIAL (new_type, i) = \n \t    TYPE_FIELD_ARTIFICIAL (type, i);\n \t  TYPE_FIELD_BITSIZE (new_type, i) = TYPE_FIELD_BITSIZE (type, i);\n-\t  if (TYPE_FIELD_TYPE (type, i))\n+\t  if (type->field (i).type ())\n \t    new_type->field (i).set_type\n-\t      (copy_type_recursive (objfile, TYPE_FIELD_TYPE (type, i),\n+\t      (copy_type_recursive (objfile, type->field (i).type (),\n \t\t\t\t    copied_types));\n \t  if (TYPE_FIELD_NAME (type, i))\n \t    TYPE_FIELD_NAME (new_type, i) = "
    },
    {
      "sha": "28d42efb7285e1a94ade25a30ab334952bfabcee",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1598,7 +1598,7 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n #define TYPE_CALLING_CONVENTION(thistype) TYPE_MAIN_TYPE(thistype)->type_specific.func_stuff->calling_convention\n #define TYPE_NO_RETURN(thistype) TYPE_MAIN_TYPE(thistype)->type_specific.func_stuff->is_noreturn\n #define TYPE_TAIL_CALL_LIST(thistype) TYPE_MAIN_TYPE(thistype)->type_specific.func_stuff->tail_call_list\n-#define TYPE_BASECLASS(thistype,index) TYPE_FIELD_TYPE(thistype, index)\n+#define TYPE_BASECLASS(thistype,index) ((thistype)->field (index).type ())\n #define TYPE_N_BASECLASSES(thistype) TYPE_CPLUS_SPECIFIC(thistype)->n_baseclasses\n #define TYPE_BASECLASS_NAME(thistype,index) TYPE_FIELD_NAME(thistype, index)\n #define TYPE_BASECLASS_BITPOS(thistype,index) TYPE_FIELD_BITPOS(thistype,index)\n@@ -1637,7 +1637,6 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n #define FIELD_ARTIFICIAL(thisfld) ((thisfld).artificial)\n #define FIELD_BITSIZE(thisfld) ((thisfld).bitsize)\n \n-#define TYPE_FIELD_TYPE(thistype, n) ((thistype)->field (n).type ())\n #define TYPE_FIELD_NAME(thistype, n) FIELD_NAME((thistype)->field (n))\n #define TYPE_FIELD_LOC_KIND(thistype, n) FIELD_LOC_KIND ((thistype)->field (n))\n #define TYPE_FIELD_BITPOS(thistype, n) FIELD_BITPOS ((thistype)->field (n))"
    },
    {
      "sha": "9f7dd0ac12f076e7afe592ece43a8e068da778fe",
      "filename": "gdb/gnu-v2-abi.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/gnu-v2-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/gnu-v2-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v2-abi.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -312,7 +312,7 @@ vb_match (struct type *type, int index, struct type *basetype)\n \n   /* It's a virtual baseclass pointer, now we just need to find out whether\n      it is for this baseclass.  */\n-  fieldtype = TYPE_FIELD_TYPE (type, index);\n+  fieldtype = type->field (index).type ();\n   if (fieldtype == NULL\n       || fieldtype->code () != TYPE_CODE_PTR)\n     /* \"Can't happen\".  */\n@@ -362,7 +362,7 @@ gnuv2_baseclass_offset (struct type *type, int index,\n \t      int field_length;\n \t      CORE_ADDR addr;\n \n-\t      field_type = check_typedef (TYPE_FIELD_TYPE (type, i));\n+\t      field_type = check_typedef (type->field (i).type ());\n \t      field_offset = TYPE_FIELD_BITPOS (type, i) / 8;\n \t      field_length = TYPE_LENGTH (field_type);\n "
    },
    {
      "sha": "23c9c940ca3bde76878096f1e5578e96d6a71ba5",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -182,7 +182,7 @@ vtable_ptrdiff_type (struct gdbarch *gdbarch)\n     = (struct type *) gdbarch_data (gdbarch, vtable_type_gdbarch_data);\n \n   /* The \"offset_to_top\" field has the appropriate (ptrdiff_t) type.  */\n-  return TYPE_FIELD_TYPE (vtable_type, vtable_field_offset_to_top);\n+  return vtable_type->field (vtable_field_offset_to_top).type ();\n }\n \n /* Return the offset from the start of the imaginary `struct\n@@ -221,7 +221,7 @@ gnuv3_dynamic_class (struct type *type)\n \n   for (fieldnum = 0; fieldnum < TYPE_N_BASECLASSES (type); fieldnum++)\n     if (BASETYPE_VIA_VIRTUAL (type, fieldnum)\n-\t|| gnuv3_dynamic_class (TYPE_FIELD_TYPE (type, fieldnum)))\n+\t|| gnuv3_dynamic_class (type->field (fieldnum).type ()))\n       {\n \tTYPE_CPLUS_DYNAMIC (type) = 1;\n \treturn 1;\n@@ -467,7 +467,7 @@ gnuv3_baseclass_offset (struct type *type, int index,\n     {\n       struct dwarf2_property_baton baton;\n       baton.property_type\n-\t= lookup_pointer_type (TYPE_FIELD_TYPE (type, index));\n+\t= lookup_pointer_type (type->field (index).type ());\n       baton.locexpr = *TYPE_FIELD_DWARF_BLOCK (type, index);\n \n       struct dynamic_prop prop;\n@@ -550,7 +550,7 @@ gnuv3_find_method_in (struct type *domain, CORE_ADDR voffset,\n \tcontinue;\n \n       pos = TYPE_BASECLASS_BITPOS (domain, i) / 8;\n-      basetype = TYPE_FIELD_TYPE (domain, i);\n+      basetype = domain->field (i).type ();\n       /* Recurse with a modified adjustment.  We don't need to adjust\n \t voffset.  */\n       if (adjustment >= pos && adjustment < pos + TYPE_LENGTH (basetype))\n@@ -1331,7 +1331,7 @@ is_copy_or_move_constructor_type (struct type *class_type,\n \n   /* ...and the second argument should be the same as the class\n      type, with the expected type code...  */\n-  struct type *arg_type = TYPE_FIELD_TYPE (method_type, 1);\n+  struct type *arg_type = method_type->field (1).type ();\n \n   if (arg_type->code () != expected)\n     return false;\n@@ -1345,7 +1345,7 @@ is_copy_or_move_constructor_type (struct type *class_type,\n      constructor.  */\n   for (int i = 2; i < method_type->num_fields (); i++)\n     {\n-      arg_type = TYPE_FIELD_TYPE (method_type, i);\n+      arg_type = method_type->field (i).type ();\n       /* FIXME aktemur/2019-10-31: As of this date, neither\n \t clang++-7.0.0 nor g++-8.2.0 produce a DW_AT_default_value\n \t attribute.  GDB is also not set to read this attribute, yet.\n@@ -1529,7 +1529,7 @@ gnuv3_pass_by_reference (struct type *type)\n   for (fieldnum = 0; fieldnum < type->num_fields (); fieldnum++)\n     if (!field_is_static (&type->field (fieldnum)))\n       {\n-\tstruct type *field_type = TYPE_FIELD_TYPE (type, fieldnum);\n+\tstruct type *field_type = type->field (fieldnum).type ();\n \n \t/* For arrays, make the decision based on the element type.  */\n \tif (field_type->code () == TYPE_CODE_ARRAY)"
    },
    {
      "sha": "6a60e1864d979516eaea8a8a5c721a2ac28b6c30",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -75,8 +75,8 @@ gccgo_string_p (struct type *type)\n \n   if (type->num_fields () == 2)\n     {\n-      struct type *type0 = TYPE_FIELD_TYPE (type, 0);\n-      struct type *type1 = TYPE_FIELD_TYPE (type, 1);\n+      struct type *type0 = type->field (0).type ();\n+      struct type *type1 = type->field (1).type ();\n \n       type0 = check_typedef (type0);\n       type1 = check_typedef (type1);"
    },
    {
      "sha": "df0c029785d5595d8af765a7cb99580a97519364",
      "filename": "gdb/go-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/go-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/go-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -44,7 +44,7 @@ print_go_string (struct type *type,\n \t\t const struct value_print_options *options)\n {\n   struct gdbarch *gdbarch = get_type_arch (type);\n-  struct type *elt_ptr_type = TYPE_FIELD_TYPE (type, 0);\n+  struct type *elt_ptr_type = type->field (0).type ();\n   struct type *elt_type = TYPE_TARGET_TYPE (elt_ptr_type);\n   LONGEST length;\n   /* TODO(dje): The encapsulation of what a pointer is belongs in value.c."
    },
    {
      "sha": "88f5757b98bee70dd88040889e92420da03813d3",
      "filename": "gdb/i386-darwin-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/i386-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/i386-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-darwin-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -139,7 +139,7 @@ i386_darwin_arg_type_alignment (struct type *type)\n       for (i = 0; i < type->num_fields (); i++)\n \t{\n \t  int align\n-\t    = i386_darwin_arg_type_alignment (TYPE_FIELD_TYPE (type, i));\n+\t    = i386_darwin_arg_type_alignment (type->field (i).type ());\n \n \t  res = std::max (res, align);\n \t}"
    },
    {
      "sha": "9b905c1996afdebf6a9df34f8868e714e0c0122d",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -2645,7 +2645,7 @@ i386_16_byte_align_p (struct type *type)\n       int i;\n       for (i = 0; i < type->num_fields (); i++)\n \t{\n-\t  if (i386_16_byte_align_p (TYPE_FIELD_TYPE (type, i)))\n+\t  if (i386_16_byte_align_p (type->field (i).type ()))\n \t    return 1;\n \t}\n     }\n@@ -2954,7 +2954,7 @@ i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n      double' member are returned in %st(0).  */\n   if (code == TYPE_CODE_STRUCT && type->num_fields () == 1)\n     {\n-      type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n+      type = check_typedef (type->field (0).type ());\n       if (type->code () == TYPE_CODE_FLT)\n \treturn (len == 4 || len == 8 || len == 12);\n     }\n@@ -3022,7 +3022,7 @@ i386_return_value (struct gdbarch *gdbarch, struct value *function,\n      here.  */\n   if (code == TYPE_CODE_STRUCT && type->num_fields () == 1)\n     {\n-      type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n+      type = check_typedef (type->field (0).type ());\n       return i386_return_value (gdbarch, function, type, regcache,\n \t\t\t\treadbuf, writebuf);\n     }"
    },
    {
      "sha": "ae61ed8291cd0e26dfb7abcdc049b84c6f5b941a",
      "filename": "gdb/i386-windows-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/i386-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/i386-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-windows-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -221,7 +221,7 @@ i386_windows_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   if (type->code () == TYPE_CODE_METHOD\n       && type->num_fields () > 0\n       && TYPE_FIELD_ARTIFICIAL (type, 0)\n-      && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_PTR)\n+      && type->field (0).type ()->code () == TYPE_CODE_PTR)\n     thiscall = 1;\n \n   return i386_thiscall_push_dummy_call (gdbarch, function, regcache, bp_addr,"
    },
    {
      "sha": "5d68f7fb4ffa0e2a24a947e734ce42f016cb8417",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -3342,7 +3342,7 @@ is_float_or_hfa_type_recurse (struct type *t, struct type **etp)\n \n \tfor (i = 0; i < t->num_fields (); i++)\n \t  if (!is_float_or_hfa_type_recurse\n-\t      (check_typedef (TYPE_FIELD_TYPE (t, i)), etp))\n+\t      (check_typedef (t->field (i).type ()), etp))\n \t    return 0;\n \treturn 1;\n       }\n@@ -3391,7 +3391,7 @@ slot_alignment_is_next_even (struct type *t)\n \n \tfor (i = 0; i < t->num_fields (); i++)\n \t  if (slot_alignment_is_next_even\n-\t      (check_typedef (TYPE_FIELD_TYPE (t, i))))\n+\t      (check_typedef (t->field (i).type ())))\n \t    return 1;\n \treturn 0;\n       }"
    },
    {
      "sha": "cdb30137c3585fcf6c102762af486e86b2098b80",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1048,7 +1048,7 @@ call_function_by_hand_dummy (struct value *function,\n \tprototyped = 0;\n \n       if (i < ftype->num_fields ())\n-\tparam_type = TYPE_FIELD_TYPE (ftype, i);\n+\tparam_type = ftype->field (i).type ();\n       else\n \tparam_type = NULL;\n "
    },
    {
      "sha": "3e1b74e3b15a41295dfdf73a83015dea5c57ba19",
      "filename": "gdb/m2-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/m2-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/m2-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -222,7 +222,7 @@ evaluate_subexp_modula2 (struct type *expect_type, struct expression *exp,\n \t    {\n \t      struct value *temp = arg1;\n \n-\t      type = TYPE_FIELD_TYPE (type, 1);\n+\t      type = type->field (1).type ();\n \t      /* i18n: Do not translate the \"_m2_high\" part!  */\n \t      arg1 = value_struct_elt (&temp, NULL, \"_m2_high\", NULL,\n \t\t\t\t       _(\"unbounded structure \"\n@@ -250,7 +250,7 @@ evaluate_subexp_modula2 (struct type *expect_type, struct expression *exp,\n       if (m2_is_unbounded_array (type))\n \t{\n \t  struct value *temp = arg1;\n-\t  type = TYPE_FIELD_TYPE (type, 0);\n+\t  type = type->field (0).type ();\n \t  if (type == NULL || (type->code () != TYPE_CODE_PTR))\n \t    {\n \t      warning (_(\"internal error: unbounded \""
    },
    {
      "sha": "fe041b48c53d99e0222c3a65b1c0c910d8be6fc4",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -294,7 +294,7 @@ m2_procedure (struct type *type, struct ui_file *stream,\n \t      fputs_filtered (\", \", stream);\n \t      wrap_here (\"    \");\n \t    }\n-\t  m2_print_type (TYPE_FIELD_TYPE (type, i), \"\", stream, -1, 0, flags);\n+\t  m2_print_type (type->field (i).type (), \"\", stream, -1, 0, flags);\n \t}\n       fprintf_filtered (stream, \") : \");\n       if (TYPE_TARGET_TYPE (type) != NULL)\n@@ -349,14 +349,14 @@ m2_is_long_set (struct type *type)\n       len = type->num_fields ();\n       for (i = TYPE_N_BASECLASSES (type); i < len; i++)\n \t{\n-\t  if (TYPE_FIELD_TYPE (type, i) == NULL)\n+\t  if (type->field (i).type () == NULL)\n \t    return 0;\n-\t  if (TYPE_FIELD_TYPE (type, i)->code () != TYPE_CODE_SET)\n+\t  if (type->field (i).type ()->code () != TYPE_CODE_SET)\n \t    return 0;\n \t  if (TYPE_FIELD_NAME (type, i) != NULL\n \t      && (strcmp (TYPE_FIELD_NAME (type, i), \"\") != 0))\n \t    return 0;\n-\t  range = TYPE_FIELD_TYPE (type, i)->index_type ();\n+\t  range = type->field (i).type ()->index_type ();\n \t  if ((i > TYPE_N_BASECLASSES (type))\n \t      && previous_high + 1 != TYPE_LOW_BOUND (range))\n \t    return 0;\n@@ -413,11 +413,11 @@ m2_is_long_set_of_type (struct type *type, struct type **of_type)\n       i = TYPE_N_BASECLASSES (type);\n       if (len == 0)\n \treturn 0;\n-      range = TYPE_FIELD_TYPE (type, i)->index_type ();\n+      range = type->field (i).type ()->index_type ();\n       target = TYPE_TARGET_TYPE (range);\n \n-      l1 = TYPE_LOW_BOUND (TYPE_FIELD_TYPE (type, i)->index_type ());\n-      h1 = TYPE_HIGH_BOUND (TYPE_FIELD_TYPE (type, len - 1)->index_type ());\n+      l1 = TYPE_LOW_BOUND (type->field (i).type ()->index_type ());\n+      h1 = TYPE_HIGH_BOUND (type->field (len - 1).type ()->index_type ());\n       *of_type = target;\n       if (m2_get_discrete_bounds (target, &l2, &h2) >= 0)\n \treturn (l1 == l2 && h1 == h2);\n@@ -457,12 +457,12 @@ m2_long_set (struct type *type, struct ui_file *stream, int show, int level,\n \t  else\n \t    {\n \t      fprintf_filtered(stream, \"[\");\n-\t      m2_print_bounds (TYPE_FIELD_TYPE (type, i)->index_type (),\n+\t      m2_print_bounds (type->field (i).type ()->index_type (),\n \t\t\t       stream, show - 1, level, 0);\n \n \t      fprintf_filtered(stream, \"..\");\n \n-\t      m2_print_bounds (TYPE_FIELD_TYPE (type, len - 1)->index_type (),\n+\t      m2_print_bounds (type->field (len - 1).type ()->index_type (),\n \t\t\t       stream, show - 1, level, 1);\n \t      fprintf_filtered(stream, \"]\");\n \t    }\n@@ -496,7 +496,7 @@ m2_is_unbounded_array (struct type *type)\n \treturn 0;\n       if (strcmp (TYPE_FIELD_NAME (type, 1), \"_m2_high\") != 0)\n \treturn 0;\n-      if (TYPE_FIELD_TYPE (type, 0)->code () != TYPE_CODE_PTR)\n+      if (type->field (0).type ()->code () != TYPE_CODE_PTR)\n \treturn 0;\n       return 1;\n     }\n@@ -517,7 +517,7 @@ m2_unbounded_array (struct type *type, struct ui_file *stream, int show,\n       if (show > 0)\n \t{\n \t  fputs_filtered (\"ARRAY OF \", stream);\n-\t  m2_print_type (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0)),\n+\t  m2_print_type (TYPE_TARGET_TYPE (type->field (0).type ()),\n \t\t\t \"\", stream, 0, level, flags);\n \t}\n       return 1;\n@@ -566,7 +566,7 @@ m2_record_fields (struct type *type, struct ui_file *stream, int show,\n \t  fputs_styled (TYPE_FIELD_NAME (type, i),\n \t\t\tvariable_name_style.style (), stream);\n \t  fputs_filtered (\" : \", stream);\n-\t  m2_print_type (TYPE_FIELD_TYPE (type, i),\n+\t  m2_print_type (type->field (i).type (),\n \t\t\t \"\",\n \t\t\t stream, 0, level + 4, flags);\n \t  if (TYPE_FIELD_PACKED (type, i))"
    },
    {
      "sha": "041bc18d3fd853a9b93c4877016d5ee94beca89b",
      "filename": "gdb/m2-valprint.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/m2-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/m2-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -55,8 +55,8 @@ get_long_set_bounds (struct type *type, LONGEST *low, LONGEST *high)\n       i = TYPE_N_BASECLASSES (type);\n       if (len == 0)\n \treturn 0;\n-      *low = TYPE_LOW_BOUND (TYPE_FIELD_TYPE (type, i)->index_type ());\n-      *high = TYPE_HIGH_BOUND (TYPE_FIELD_TYPE (type, len - 1)->index_type ());\n+      *low = TYPE_LOW_BOUND (type->field (i).type ()->index_type ());\n+      *high = TYPE_HIGH_BOUND (type->field (len - 1).type ()->index_type ());\n       return 1;\n     }\n   error (_(\"expecting long_set\"));\n@@ -86,7 +86,7 @@ m2_print_long_set (struct type *type, const gdb_byte *valaddr,\n   if (get_long_set_bounds (type, &low_bound, &high_bound))\n     {\n       field = TYPE_N_BASECLASSES (type);\n-      range = TYPE_FIELD_TYPE (type, field)->index_type ();\n+      range = type->field (field).type ()->index_type ();\n     }\n   else\n     {\n@@ -101,7 +101,7 @@ m2_print_long_set (struct type *type, const gdb_byte *valaddr,\n     {\n       for (i = low_bound; i <= high_bound; i++)\n \t{\n-\t  bitval = value_bit_index (TYPE_FIELD_TYPE (type, field),\n+\t  bitval = value_bit_index (type->field (field).type (),\n \t\t\t\t    (TYPE_FIELD_BITPOS (type, field) / 8) +\n \t\t\t\t    valaddr + embedded_offset, i);\n \t  if (bitval < 0)\n@@ -136,7 +136,7 @@ m2_print_long_set (struct type *type, const gdb_byte *valaddr,\n \t      field++;\n \t      if (field == len)\n \t\tbreak;\n-\t      range = TYPE_FIELD_TYPE (type, field)->index_type ();\n+\t      range = type->field (field).type ()->index_type ();\n \t      if (get_discrete_bounds (range, &field_low, &field_high) < 0)\n \t\tbreak;\n \t      target = TYPE_TARGET_TYPE (range);\n@@ -167,11 +167,11 @@ m2_print_unbounded_array (struct value *value,\n   struct type *type = check_typedef (value_type (value));\n   const gdb_byte *valaddr = value_contents_for_printing (value);\n \n-  addr = unpack_pointer (TYPE_FIELD_TYPE (type, 0),\n+  addr = unpack_pointer (type->field (0).type (),\n \t\t\t (TYPE_FIELD_BITPOS (type, 0) / 8) +\n \t\t\t valaddr);\n \n-  val = value_at_lazy (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0)),\n+  val = value_at_lazy (TYPE_TARGET_TYPE (type->field (0).type ()),\n \t\t       addr);\n   len = unpack_field_as_long (type, valaddr, 1);\n "
    },
    {
      "sha": "27870252a360024199eb468c61cd153363fd7280",
      "filename": "gdb/m68k-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/m68k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/m68k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -465,7 +465,7 @@ m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,\n      member, we don't bother to check the member's type here.  */\n   if (code == TYPE_CODE_STRUCT && type->num_fields () == 1)\n     {\n-      type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n+      type = check_typedef (type->field (0).type ());\n       return m68k_svr4_return_value (gdbarch, function, type, regcache,\n \t\t\t\t     readbuf, writebuf);\n     }"
    },
    {
      "sha": "e0f04888808d7641f559e2020c166dd2cce4fc5c",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -4408,7 +4408,7 @@ fp_register_arg_p (struct gdbarch *gdbarch, enum type_code typecode,\n \t       && (typecode == TYPE_CODE_STRUCT\n \t\t   || typecode == TYPE_CODE_UNION)\n \t       && arg_type->num_fields () == 1\n-\t       && check_typedef (TYPE_FIELD_TYPE (arg_type, 0))->code ()\n+\t       && check_typedef (arg_type->field (0).type ())->code ()\n \t       == TYPE_CODE_FLT))\n \t  && MIPS_FPU_TYPE(gdbarch) != MIPS_FPU_NONE);\n }\n@@ -4427,15 +4427,15 @@ mips_type_needs_double_align (struct type *type)\n     {\n       if (type->num_fields () < 1)\n \treturn 0;\n-      return mips_type_needs_double_align (TYPE_FIELD_TYPE (type, 0));\n+      return mips_type_needs_double_align (type->field (0).type ());\n     }\n   else if (typecode == TYPE_CODE_UNION)\n     {\n       int i, n;\n \n       n = type->num_fields ();\n       for (i = 0; i < n; i++)\n-\tif (mips_type_needs_double_align (TYPE_FIELD_TYPE (type, i)))\n+\tif (mips_type_needs_double_align (type->field (i).type ()))\n \t  return 1;\n       return 0;\n     }\n@@ -4790,7 +4790,7 @@ mips_eabi_return_value (struct gdbarch *gdbarch, struct value *function,\n \t   || type->code () == TYPE_CODE_UNION)\n \t  && type->num_fields () == 1)\n \t{\n-\t  struct type *fieldtype = TYPE_FIELD_TYPE (type, 0);\n+\t  struct type *fieldtype = type->field (0).type ();\n \n \t  if (check_typedef (fieldtype)->code () == TYPE_CODE_FLT)\n \t    fp_return_type = 1;\n@@ -4865,7 +4865,7 @@ mips_n32n64_fp_arg_chunk_p (struct gdbarch *gdbarch, struct type *arg_type,\n       if (pos > offset)\n \treturn 0;\n \n-      field_type = check_typedef (TYPE_FIELD_TYPE (arg_type, i));\n+      field_type = check_typedef (arg_type->field (i).type ());\n \n       /* If this field is entirely before the requested offset, go\n \t on to the next one.  */\n@@ -5229,12 +5229,12 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n \t   && type->num_fields () <= 2\n \t   && type->num_fields () >= 1\n \t   && ((type->num_fields () == 1\n-\t\t&& (check_typedef (TYPE_FIELD_TYPE (type, 0))->code ()\n+\t\t&& (check_typedef (type->field (0).type ())->code ()\n \t\t    == TYPE_CODE_FLT))\n \t       || (type->num_fields () == 2\n-\t\t   && (check_typedef (TYPE_FIELD_TYPE (type, 0))->code ()\n+\t\t   && (check_typedef (type->field (0).type ())->code ()\n \t\t       == TYPE_CODE_FLT)\n-\t\t   && (check_typedef (TYPE_FIELD_TYPE (type, 1))->code ()\n+\t\t   && (check_typedef (type->field (1).type ())->code ()\n \t\t       == TYPE_CODE_FLT))))\n     {\n       /* A struct that contains one or two floats.  Each value is part\n@@ -5252,7 +5252,7 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n \t  if (mips_debug)\n \t    fprintf_unfiltered (gdb_stderr, \"Return float struct+%d\\n\",\n \t\t\t\toffset);\n-\t  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)) == 16)\n+\t  if (TYPE_LENGTH (type->field (field).type ()) == 16)\n \t    {\n \t      /* A 16-byte long double field goes in two consecutive\n \t\t registers.  */\n@@ -5270,7 +5270,7 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n \t  else\n \t    mips_xfer_register (gdbarch, regcache,\n \t\t\t\tgdbarch_num_regs (gdbarch) + regnum,\n-\t\t\t\tTYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),\n+\t\t\t\tTYPE_LENGTH (type->field (field).type ()),\n \t\t\t\tgdbarch_byte_order (gdbarch),\n \t\t\t\treadbuf, writebuf, offset);\n \t}\n@@ -5782,12 +5782,12 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n \t   && type->num_fields () <= 2\n \t   && type->num_fields () >= 1\n \t   && ((type->num_fields () == 1\n-\t\t&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))\n+\t\t&& (TYPE_CODE (type->field (0).type ())\n \t\t    == TYPE_CODE_FLT))\n \t       || (type->num_fields () == 2\n-\t\t   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))\n+\t\t   && (TYPE_CODE (type->field (0).type ())\n \t\t       == TYPE_CODE_FLT)\n-\t\t   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))\n+\t\t   && (TYPE_CODE (type->field (1).type ())\n \t\t       == TYPE_CODE_FLT)))\n \t   && tdep->mips_fpu_type != MIPS_FPU_NONE)\n     {\n@@ -5806,7 +5806,7 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\toffset);\n \t  mips_xfer_register (gdbarch, regcache,\n \t\t\t      gdbarch_num_regs (gdbarch) + regnum,\n-\t\t\t      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),\n+\t\t\t      TYPE_LENGTH (type->field (field).type ()),\n \t\t\t      gdbarch_byte_order (gdbarch),\n \t\t\t      readbuf, writebuf, offset);\n \t}"
    },
    {
      "sha": "5d960347d21c9a41fdc810fdab5a320ab689ec65",
      "filename": "gdb/mn10300-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/mn10300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/mn10300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -109,7 +109,7 @@ mn10300_type_align (struct type *type)\n     case TYPE_CODE_UNION:\n       for (i = 0; i < type->num_fields (); i++)\n \t{\n-\t  int falign = mn10300_type_align (TYPE_FIELD_TYPE (type, i));\n+\t  int falign = mn10300_type_align (type->field (i).type ());\n \t  while (align < falign)\n \t    align <<= 1;\n \t}\n@@ -144,7 +144,7 @@ mn10300_use_struct_convention (struct type *type)\n       /* Structures with a single field are handled as the field\n \t itself.  */\n       if (type->num_fields () == 1)\n-\treturn mn10300_use_struct_convention (TYPE_FIELD_TYPE (type, 0));\n+\treturn mn10300_use_struct_convention (type->field (0).type ());\n \n       /* Structures with word or double-word size are passed in memory, as\n \t long as they require at least word alignment.  */"
    },
    {
      "sha": "94ac234d3fb20679afcaa86b0b7cc4b1ff447af7",
      "filename": "gdb/nds32-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/nds32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/nds32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nds32-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1408,7 +1408,7 @@ nds32_check_calling_use_fpr (struct type *type)\n       else if (t->num_fields () != 1)\n \treturn 0;\n       else\n-\tt = TYPE_FIELD_TYPE (t, 0);\n+\tt = t->field (0).type ();\n     }\n \n   return typecode == TYPE_CODE_FLT;"
    },
    {
      "sha": "85ef4bd385297a7ee2a31bbff27140f92aae2f6d",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -316,8 +316,9 @@ exp\t:\texp '['\n \t\t\t      stringsval.ptr = buf;\n \t\t\t      stringsval.length = strlen (arrayname);\n \t\t\t      strcpy (buf, arrayname);\n-\t\t\t      current_type = TYPE_FIELD_TYPE (current_type,\n-\t\t\t\tarrayfieldindex - 1);\n+\t\t\t      current_type\n+\t\t\t\t= (current_type\n+\t\t\t\t   ->field (arrayfieldindex - 1).type ());\n \t\t\t      write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t\t      write_exp_string (pstate, stringsval);\n \t\t\t      write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);"
    },
    {
      "sha": "f3d10d0ec6e5d08199e52cd02581c5f69f123e0b",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -113,11 +113,11 @@ is_pascal_string_type (struct type *type,int *length_pos,\n           if (length_pos)\n \t    *length_pos = TYPE_FIELD_BITPOS (type, 0) / TARGET_CHAR_BIT;\n           if (length_size)\n-\t    *length_size = TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0));\n+\t    *length_size = TYPE_LENGTH (type->field (0).type ());\n           if (string_pos)\n \t    *string_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;\n           if (char_type)\n-\t    *char_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 1));\n+\t    *char_type = TYPE_TARGET_TYPE (type->field (1).type ());\n  \t  if (arrayname)\n \t    *arrayname = TYPE_FIELD_NAME (type, 1);\n          return 2;\n@@ -133,13 +133,13 @@ is_pascal_string_type (struct type *type,int *length_pos,\n \t  if (length_pos)\n \t    *length_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;\n \t  if (length_size)\n-\t    *length_size = TYPE_LENGTH (TYPE_FIELD_TYPE (type, 1));\n+\t    *length_size = TYPE_LENGTH (type->field (1).type ());\n \t  if (string_pos)\n \t    *string_pos = TYPE_FIELD_BITPOS (type, 2) / TARGET_CHAR_BIT;\n           /* FIXME: how can I detect wide chars in GPC ??  */\n           if (char_type)\n \t    {\n-\t      *char_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 2));\n+\t      *char_type = TYPE_TARGET_TYPE (type->field (2).type ());\n \n \t      if ((*char_type)->code () == TYPE_CODE_ARRAY)\n \t\t*char_type = TYPE_TARGET_TYPE (*char_type);"
    },
    {
      "sha": "75c1e25f5faa110fb809e40cb38e8922a3409580",
      "filename": "gdb/p-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/p-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/p-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-typeprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -327,7 +327,7 @@ pascal_print_func_args (struct type *type, struct ui_file *stream,\n          {\n          fprintf_filtered (stream, \"var \");\n          } */\n-      pascal_print_type (TYPE_FIELD_TYPE (type, i), \"\"\t/* TYPE_FIELD_NAME\n+      pascal_print_type (type->field (i).type (), \"\"\t/* TYPE_FIELD_NAME\n \t\t\t\t\t\t\t   seems invalid!  */\n \t\t\t ,stream, -1, 0, flags);\n     }\n@@ -620,7 +620,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t      print_spaces_filtered (level + 4, stream);\n \t      if (field_is_static (&type->field (i)))\n \t\tfprintf_filtered (stream, \"static \");\n-\t      pascal_print_type (TYPE_FIELD_TYPE (type, i),\n+\t      pascal_print_type (type->field (i).type (),\n \t\t\t\t TYPE_FIELD_NAME (type, i),\n \t\t\t\t stream, show - 1, level + 4, flags);\n \t      if (!field_is_static (&type->field (i))"
    },
    {
      "sha": "3b1303d1248871214b2610bc74ef54b3a8e838a1",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -305,12 +305,10 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n \t  /* Extract the address, assume that it is unsigned.  */\n \t  print_address_demangle\n \t    (options, gdbarch,\n-\t     extract_unsigned_integer (valaddr\n-\t\t\t\t       + TYPE_FIELD_BITPOS (type,\n-\t\t\t\t\t\t\t    VTBL_FNADDR_OFFSET) / 8,\n-\t\t\t\t       TYPE_LENGTH (TYPE_FIELD_TYPE (type,\n-\t\t\t\t\t\t\t\t     VTBL_FNADDR_OFFSET)),\n-\t\t\t\t       byte_order),\n+\t     extract_unsigned_integer\n+\t       (valaddr + TYPE_FIELD_BITPOS (type, VTBL_FNADDR_OFFSET) / 8,\n+\t\tTYPE_LENGTH (type->field (VTBL_FNADDR_OFFSET).type ()),\n+\t\tbyte_order),\n \t     stream, demangle);\n \t}\n       else\n@@ -580,7 +578,7 @@ pascal_object_print_value_fields (struct value *val, struct ui_file *stream,\n \t      wrap_here (n_spaces (2 + 2 * recurse));\n \t    }\n \n-\t  annotate_field_begin (TYPE_FIELD_TYPE (type, i));\n+\t  annotate_field_begin (type->field (i).type ());\n \n \t  if (field_is_static (&type->field (i)))\n \t    {"
    },
    {
      "sha": "f0f618c5eba5e7e85a442df925bb733d876f362d",
      "filename": "gdb/ppc-sysv-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ppc-sysv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/ppc-sysv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-sysv-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1146,7 +1146,7 @@ ppc64_aggregate_candidate (struct type *type,\n \t\tcontinue;\n \n \t      sub_count = ppc64_aggregate_candidate\n-\t\t\t   (TYPE_FIELD_TYPE (type, i), field_type);\n+\t\t\t   (type->field (i).type (), field_type);\n \t      if (sub_count == -1)\n \t\treturn -1;\n \n@@ -1498,7 +1498,7 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n \t{\n \t  while (type->code () == TYPE_CODE_STRUCT\n \t\t && type->num_fields () == 1)\n-\t    type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n+\t    type = check_typedef (type->field (0).type ());\n \n \t  if (type->code () == TYPE_CODE_FLT)\n \t    ppc64_sysv_abi_push_freg (gdbarch, type, val, argpos);"
    },
    {
      "sha": "34cb849937cccde436442191d115a394ac3314c0",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -242,10 +242,10 @@ convert_field (struct type *type, int field)\n     return NULL;\n \n   /* A field can have a NULL type in some situations.  */\n-  if (TYPE_FIELD_TYPE (type, field) == NULL)\n+  if (type->field (field).type () == NULL)\n     arg = gdbpy_ref<>::new_reference (Py_None);\n   else\n-    arg.reset (type_to_type_object (TYPE_FIELD_TYPE (type, field)));\n+    arg.reset (type_to_type_object (type->field (field).type ()));\n   if (arg == NULL)\n     return NULL;\n   if (PyObject_SetAttrString (result.get (), \"type\", arg.get ()) < 0)"
    },
    {
      "sha": "fa43c8d02f2f873d5988bdd9bb85f5ee7d92b246",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -643,13 +643,13 @@ riscv_print_one_register_info (struct gdbarch *gdbarch,\n   if (regtype->code () == TYPE_CODE_FLT\n       || (regtype->code () == TYPE_CODE_UNION\n \t  && regtype->num_fields () == 2\n-\t  && TYPE_FIELD_TYPE (regtype, 0)->code () == TYPE_CODE_FLT\n-\t  && TYPE_FIELD_TYPE (regtype, 1)->code () == TYPE_CODE_FLT)\n+\t  && regtype->field (0).type ()->code () == TYPE_CODE_FLT\n+\t  && regtype->field (1).type ()->code () == TYPE_CODE_FLT)\n       || (regtype->code () == TYPE_CODE_UNION\n \t  && regtype->num_fields () == 3\n-\t  && TYPE_FIELD_TYPE (regtype, 0)->code () == TYPE_CODE_FLT\n-\t  && TYPE_FIELD_TYPE (regtype, 1)->code () == TYPE_CODE_FLT\n-\t  && TYPE_FIELD_TYPE (regtype, 2)->code () == TYPE_CODE_FLT))\n+\t  && regtype->field (0).type ()->code () == TYPE_CODE_FLT\n+\t  && regtype->field (1).type ()->code () == TYPE_CODE_FLT\n+\t  && regtype->field (2).type ()->code () == TYPE_CODE_FLT))\n     {\n       struct value_print_options opts;\n       const gdb_byte *valaddr = value_contents_for_printing (val);\n@@ -2052,7 +2052,7 @@ riscv_struct_info::analyse_inner (struct type *type, int offset)\n       if (TYPE_FIELD_LOC_KIND (type, i) != FIELD_LOC_KIND_BITPOS)\n \tcontinue;\n \n-      struct type *field_type = TYPE_FIELD_TYPE (type, i);\n+      struct type *field_type = type->field (i).type ();\n       field_type = check_typedef (field_type);\n       int field_offset\n \t= offset + TYPE_FIELD_BITPOS (type, i) / TARGET_CHAR_BIT;"
    },
    {
      "sha": "449dfca59e9c92f5d959dac4ba6bd9b528406144",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -486,7 +486,7 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n \n   int variant_fieldno = rust_enum_variant (type);\n   val = value_field (val, variant_fieldno);\n-  struct type *variant_type = TYPE_FIELD_TYPE (type, variant_fieldno);\n+  struct type *variant_type = type->field (variant_fieldno).type ();\n \n   int nfields = variant_type->num_fields ();\n \n@@ -775,7 +775,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n \t\t\t  styled_string (variable_name_style.style (),\n \t\t\t\t\t TYPE_FIELD_NAME (type, i)));\n \n-      rust_internal_print_type (TYPE_FIELD_TYPE (type, i), NULL,\n+      rust_internal_print_type (type->field (i).type (), NULL,\n \t\t\t\tstream, (is_enum ? show : show - 1),\n \t\t\t\tlevel + 2, flags, is_enum, podata);\n       if (!for_rust_enum || flags->print_offsets)\n@@ -860,7 +860,7 @@ rust_internal_print_type (struct type *type, const char *varstring,\n \t  QUIT;\n \t  if (i > 0)\n \t    fputs_filtered (\", \", stream);\n-\t  rust_internal_print_type (TYPE_FIELD_TYPE (type, i), \"\", stream,\n+\t  rust_internal_print_type (type->field (i).type (), \"\", stream,\n \t\t\t\t    -1, 0, flags, false, podata);\n \t}\n       fputs_filtered (\")\", stream);\n@@ -1015,7 +1015,7 @@ rust_composite_type (struct type *original,\n   if (i > 0)\n     TYPE_LENGTH (result)\n       = (TYPE_FIELD_BITPOS (result, i - 1) / TARGET_CHAR_BIT +\n-\t TYPE_LENGTH (TYPE_FIELD_TYPE (result, i - 1)));\n+\t TYPE_LENGTH (result->field (i - 1).type ()));\n   return result;\n }\n \n@@ -1119,7 +1119,7 @@ rust_evaluate_funcall (struct expression *exp, int *pos, enum noside noside)\n   if (fn_type->num_fields () == 0)\n     error (_(\"Function '%s' takes no arguments\"), name.c_str ());\n \n-  if (TYPE_FIELD_TYPE (fn_type, 0)->code () == TYPE_CODE_PTR)\n+  if (fn_type->field (0).type ()->code () == TYPE_CODE_PTR)\n     args[0] = value_addr (args[0]);\n \n   function = address_of_variable (sym.symbol, block);\n@@ -1314,7 +1314,7 @@ rust_subscript (struct expression *exp, int *pos, enum noside noside,\n \t    {\n \t      if (strcmp (TYPE_FIELD_NAME (type, i), \"data_ptr\") == 0)\n \t\t{\n-\t\t  base_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, i));\n+\t\t  base_type = TYPE_TARGET_TYPE (type->field (i).type ());\n \t\t  break;\n \t\t}\n \t    }"
    },
    {
      "sha": "1148eeae0e3ba61c4785bb4f2e4be7c39b3ded5c",
      "filename": "gdb/rx-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/rx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/rx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rx-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -799,7 +799,7 @@ rx_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t  && i < func_type->num_fields ())\n \t\t\t{\n \t\t\t  struct type *p_arg_type =\n-\t\t\t    TYPE_FIELD_TYPE (func_type, i);\n+\t\t\t    func_type->field (i).type ();\n \t\t\t  p_arg_size = TYPE_LENGTH (p_arg_type);\n \t\t\t}\n "
    },
    {
      "sha": "90cb0fa312a2bbdd4c51ca14a6ac6ad80b9f3b3e",
      "filename": "gdb/score-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/score-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/score-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/score-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -480,7 +480,7 @@ score_type_needs_double_align (struct type *type)\n \n       n = type->num_fields ();\n       for (i = 0; i < n; i++)\n-        if (score_type_needs_double_align (TYPE_FIELD_TYPE (type, i)))\n+        if (score_type_needs_double_align (type->field (i).type ()))\n           return 1;\n       return 0;\n     }"
    },
    {
      "sha": "7aadf9165ca5755c5a3411be4ef962dba133bc0b",
      "filename": "gdb/sh-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/sh-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/sh-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -832,13 +832,13 @@ sh_use_struct_convention (int renesas_abi, struct type *type)\n \n   /* If the first field in the aggregate has the same length as the entire\n      aggregate type, the type is returned in registers.  */\n-  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == len)\n+  if (TYPE_LENGTH (type->field (0).type ()) == len)\n     return 0;\n \n   /* If the size of the aggregate is 8 bytes and the first field is\n      of size 4 bytes its alignment is equal to long long's alignment,\n      so it's returned in registers.  */\n-  if (len == 8 && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)\n+  if (len == 8 && TYPE_LENGTH (type->field (0).type ()) == 4)\n     return 0;\n \n   /* Otherwise use struct convention.  */\n@@ -1050,7 +1050,7 @@ sh_treat_as_flt_p (struct type *type)\n     return 0;\n   /* Otherwise if the type of that member is float, the whole type is\n      treated as float.  */\n-  if (TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_FLT)\n+  if (type->field (0).type ()->code () == TYPE_CODE_FLT)\n     return 1;\n   /* Otherwise it's not treated as float.  */\n   return 0;"
    },
    {
      "sha": "f4810523dfaae13d2fc8b30532059be7044fe6e1",
      "filename": "gdb/sparc64-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/sparc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/sparc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1181,7 +1181,7 @@ sparc64_16_byte_align_p (struct type *type)\n \n       for (i = 0; i < type->num_fields (); i++)\n \t{\n-\t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n+\t  struct type *subtype = check_typedef (type->field (i).type ());\n \n \t  if (sparc64_16_byte_align_p (subtype))\n \t    return 1;\n@@ -1258,7 +1258,7 @@ sparc64_store_floating_fields (struct regcache *regcache, struct type *type,\n \n       for (i = 0; i < type->num_fields (); i++)\n \t{\n-\t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n+\t  struct type *subtype = check_typedef (type->field (i).type ());\n \t  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);\n \n \t  sparc64_store_floating_fields (regcache, subtype, valbuf,\n@@ -1276,7 +1276,7 @@ sparc64_store_floating_fields (struct regcache *regcache, struct type *type,\n          value in %f1 too (we already have stored in %f0).  */\n       if (type->num_fields () == 1)\n \t{\n-\t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, 0));\n+\t  struct type *subtype = check_typedef (type->field (0).type ());\n \n \t  if (sparc64_floating_p (subtype) && TYPE_LENGTH (subtype) == 4)\n \t    regcache->cooked_write (SPARC_F1_REGNUM, valbuf);\n@@ -1346,7 +1346,7 @@ sparc64_extract_floating_fields (struct regcache *regcache, struct type *type,\n \n       for (i = 0; i < type->num_fields (); i++)\n \t{\n-\t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n+\t  struct type *subtype = check_typedef (type->field (i).type ());\n \t  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);\n \n \t  sparc64_extract_floating_fields (regcache, subtype, valbuf, subpos);"
    },
    {
      "sha": "37409d9a21033a67e8b19a6b70498cdfefd5a6ba",
      "filename": "gdb/typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/typeprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -116,7 +116,7 @@ print_offset_data::update (struct type *type, unsigned int field_idx,\n       return;\n     }\n \n-  struct type *ftype = check_typedef (TYPE_FIELD_TYPE (type, field_idx));\n+  struct type *ftype = check_typedef (type->field (field_idx).type ());\n   if (type->code () == TYPE_CODE_UNION)\n     {\n       /* Since union fields don't have the concept of offsets, we just"
    },
    {
      "sha": "cba662c862d94b4afc316fd08a82b8de182419ac",
      "filename": "gdb/v850-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/v850-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/v850-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/v850-tdep.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -534,7 +534,7 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n        || type->code () == TYPE_CODE_UNION)\n        && type->num_fields () == 1)\n     {\n-      fld_type = TYPE_FIELD_TYPE (type, 0);\n+      fld_type = type->field (0).type ();\n       if (v850_type_is_scalar (fld_type) && TYPE_LENGTH (fld_type) >= 4)\n \treturn 0;\n \n@@ -550,12 +550,12 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n      and which contains no arrays of more than two elements -> returned in\n      register.  */\n   if (type->code () == TYPE_CODE_STRUCT\n-      && v850_type_is_scalar (TYPE_FIELD_TYPE (type, 0))\n-      && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)\n+      && v850_type_is_scalar (type->field (0).type ())\n+      && TYPE_LENGTH (type->field (0).type ()) == 4)\n     {\n       for (i = 1; i < type->num_fields (); ++i)\n         {\n-\t  fld_type = TYPE_FIELD_TYPE (type, 0);\n+\t  fld_type = type->field (0).type ();\n \t  if (fld_type->code () == TYPE_CODE_ARRAY)\n \t    {\n \t      tgt_type = TYPE_TARGET_TYPE (fld_type);\n@@ -574,7 +574,7 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n     {\n       for (i = 0; i < type->num_fields (); ++i)\n         {\n-\t  fld_type = TYPE_FIELD_TYPE (type, 0);\n+\t  fld_type = type->field (0).type ();\n \t  if (!v850_use_struct_convention (gdbarch, fld_type))\n \t    return 0;\n \t}\n@@ -983,7 +983,7 @@ v850_eight_byte_align_p (struct type *type)\n \n       for (i = 0; i < type->num_fields (); i++)\n \t{\n-\t  if (v850_eight_byte_align_p (TYPE_FIELD_TYPE (type, i)))\n+\t  if (v850_eight_byte_align_p (type->field (i).type ()))\n \t    return 1;\n \t}\n     }"
    },
    {
      "sha": "afdb429dc37711da3bf90b1099176df00321316c",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 9,
      "deletions": 10,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1824,7 +1824,7 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n \tif (t_field_name\n \t    && t_field_name[0] == '\\0')\n \t  {\n-\t    struct type *field_type = TYPE_FIELD_TYPE (type, i);\n+\t    struct type *field_type = type->field (i).type ();\n \n \t    if (field_type->code () == TYPE_CODE_UNION\n \t\t|| field_type->code () == TYPE_CODE_STRUCT)\n@@ -2223,7 +2223,7 @@ value_struct_elt_bitpos (struct value **argp, int bitpos, struct type *ftype,\n     {\n       if (!field_is_static (&t->field (i))\n \t  && bitpos == TYPE_FIELD_BITPOS (t, i)\n-\t  && types_equal (ftype, TYPE_FIELD_TYPE (t, i)))\n+\t  && types_equal (ftype, t->field (i).type ()))\n \treturn value_primitive_field (*argp, 0, i, t);\n     }\n \n@@ -2968,8 +2968,7 @@ find_oload_champ (gdb::array_view<value *> args,\n \t    {\n \t      type *t = (methods != NULL\n \t\t\t ? (TYPE_FN_FIELD_ARGS (methods, ix)[jj].type ())\n-\t\t\t : TYPE_FIELD_TYPE (SYMBOL_TYPE (functions[ix]),\n-\t\t\t\t\t    jj));\n+\t\t\t : SYMBOL_TYPE (functions[ix])->field (jj).type ());\n \t      parm_types.push_back (t);\n \t    }\n \t}\n@@ -3206,7 +3205,7 @@ compare_parameters (struct type *t1, struct type *t2, int skip_artificial)\n   /* Special case: a method taking void.  T1 will contain no\n      non-artificial fields, and T2 will contain TYPE_CODE_VOID.  */\n   if ((t1->num_fields () - start) == 0 && t2->num_fields () == 1\n-      && TYPE_FIELD_TYPE (t2, 0)->code () == TYPE_CODE_VOID)\n+      && t2->field (0).type ()->code () == TYPE_CODE_VOID)\n     return 1;\n \n   if ((t1->num_fields () - start) == t2->num_fields ())\n@@ -3215,8 +3214,8 @@ compare_parameters (struct type *t1, struct type *t2, int skip_artificial)\n \n       for (i = 0; i < t2->num_fields (); ++i)\n \t{\n-\t  if (compare_ranks (rank_one_type (TYPE_FIELD_TYPE (t1, start + i),\n-\t\t\t\t\t    TYPE_FIELD_TYPE (t2, i), NULL),\n+\t  if (compare_ranks (rank_one_type (t1->field (start + i).type (),\n+\t\t\t\t\t    t2->field (i).type (), NULL),\n \t                     EXACT_MATCH_BADNESS) != 0)\n \t    return 0;\n \t}\n@@ -3240,7 +3239,7 @@ get_baseclass_offset (struct type *vt, struct type *cls,\n {\n   for (int i = 0; i < TYPE_N_BASECLASSES (vt); i++)\n     {\n-      struct type *t = TYPE_FIELD_TYPE (vt, i);\n+      struct type *t = vt->field (i).type ();\n       if (types_equal (t, cls))\n         {\n           if (BASETYPE_VIA_VIRTUAL (vt, i))\n@@ -3311,10 +3310,10 @@ value_struct_elt_for_reference (struct type *domain, int offset,\n \n \t  if (want_address)\n \t    return value_from_longest\n-\t      (lookup_memberptr_type (TYPE_FIELD_TYPE (t, i), domain),\n+\t      (lookup_memberptr_type (t->field (i).type (), domain),\n \t       offset + (LONGEST) (TYPE_FIELD_BITPOS (t, i) >> 3));\n \t  else if (noside != EVAL_NORMAL)\n-\t    return allocate_value (TYPE_FIELD_TYPE (t, i));\n+\t    return allocate_value (t->field (i).type ());\n \t  else\n \t    {\n \t      /* Try to evaluate NAME as a qualified name with implicit"
    },
    {
      "sha": "d5490898b9be706b79fd536ae21af8c9df2f8c50",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -1139,7 +1139,7 @@ val_print_type_code_flags (struct type *type, struct value *original_value,\n     {\n       if (TYPE_FIELD_NAME (type, field)[0] != '\\0')\n \t{\n-\t  struct type *field_type = TYPE_FIELD_TYPE (type, field);\n+\t  struct type *field_type = type->field (field).type ();\n \n \t  if (field_type == bool_type\n \t      /* We require boolean types here to be one bit wide.  This is a"
    },
    {
      "sha": "97a099ddbd3eccb06bbf42b7d7fec1f3e5a6d2c8",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/940da03e32c28144134d0373faf7fd5ea158f1ae/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=940da03e32c28144134d0373faf7fd5ea158f1ae",
      "patch": "@@ -2838,7 +2838,7 @@ value_static_field (struct type *type, int fieldno)\n   switch (TYPE_FIELD_LOC_KIND (type, fieldno))\n     {\n     case FIELD_LOC_KIND_PHYSADDR:\n-      retval = value_at_lazy (TYPE_FIELD_TYPE (type, fieldno),\n+      retval = value_at_lazy (type->field (fieldno).type (),\n \t\t\t      TYPE_FIELD_STATIC_PHYSADDR (type, fieldno));\n       break;\n     case FIELD_LOC_KIND_PHYSNAME:\n@@ -2853,7 +2853,7 @@ value_static_field (struct type *type, int fieldno)\n \t     reported as non-debuggable symbols.  */\n \t  struct bound_minimal_symbol msym\n \t    = lookup_minimal_symbol (phys_name, NULL, NULL);\n-\t  struct type *field_type = TYPE_FIELD_TYPE (type, fieldno);\n+\t  struct type *field_type = type->field (fieldno).type ();\n \n \t  if (!msym.minsym)\n \t    retval = allocate_optimized_out_value (field_type);\n@@ -2906,7 +2906,7 @@ value_primitive_field (struct value *arg1, LONGEST offset,\n   int unit_size = gdbarch_addressable_memory_unit_size (arch);\n \n   arg_type = check_typedef (arg_type);\n-  type = TYPE_FIELD_TYPE (arg_type, fieldno);\n+  type = arg_type->field (fieldno).type ();\n \n   /* Call check_typedef on our type to make sure that, if TYPE\n      is a TYPE_CODE_TYPEDEF, its length is set to the length\n@@ -3158,7 +3158,7 @@ unpack_value_field_as_long (struct type *type, const gdb_byte *valaddr,\n {\n   int bitpos = TYPE_FIELD_BITPOS (type, fieldno);\n   int bitsize = TYPE_FIELD_BITSIZE (type, fieldno);\n-  struct type *field_type = TYPE_FIELD_TYPE (type, fieldno);\n+  struct type *field_type = type->field (fieldno).type ();\n   int bit_offset;\n \n   gdb_assert (val != NULL);\n@@ -3181,7 +3181,7 @@ unpack_field_as_long (struct type *type, const gdb_byte *valaddr, int fieldno)\n {\n   int bitpos = TYPE_FIELD_BITPOS (type, fieldno);\n   int bitsize = TYPE_FIELD_BITSIZE (type, fieldno);\n-  struct type *field_type = TYPE_FIELD_TYPE (type, fieldno);\n+  struct type *field_type = type->field (fieldno).type ();\n \n   return unpack_bits_as_long (field_type, valaddr, bitpos, bitsize);\n }\n@@ -3246,7 +3246,7 @@ value_field_bitfield (struct type *type, int fieldno,\n {\n   int bitpos = TYPE_FIELD_BITPOS (type, fieldno);\n   int bitsize = TYPE_FIELD_BITSIZE (type, fieldno);\n-  struct value *res_val = allocate_value (TYPE_FIELD_TYPE (type, fieldno));\n+  struct value *res_val = allocate_value (type->field (fieldno).type ());\n \n   unpack_value_bitfield (res_val, bitpos, bitsize,\n \t\t\t valaddr, embedded_offset, val);"
    }
  ]
}