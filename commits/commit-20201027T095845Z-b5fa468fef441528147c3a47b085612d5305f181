{
  "sha": "b5fa468fef441528147c3a47b085612d5305f181",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjVmYTQ2OGZlZjQ0MTUyODE0N2MzYTQ3YjA4NTYxMmQ1MzA1ZjE4MQ==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-10-27T09:56:03Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-10-27T09:58:45Z"
    },
    "message": "gdb/breakpoint: disable a bp location if condition is invalid at that location\n\nCurrently, for a conditional breakpoint, GDB checks if the condition\ncan be evaluated in the context of the first symtab and line (SAL).\nIn case of an error, defining the conditional breakpoint is aborted.\nThis prevents having a conditional breakpoint whose condition may\nactually be meaningful for some of the location contexts.  This patch\nmakes it possible to define conditional BPs by checking all location\ncontexts.  If the condition is meaningful for even one context, the\nbreakpoint is defined.  The locations for which the condition gives\nerrors are disabled.\n\nThe bp_location struct is introduced a new field, 'disabled_by_cond'.\nThis field denotes whether the location is disabled automatically\nbecause the condition was non-evaluatable.  Disabled-by-cond locations\ncannot be enabled by the user.  But locations that are not\ndisabled-by-cond can be enabled/disabled by the user manually as\nbefore.\n\nFor a concrete example, consider 3 contexts of a function 'func'.\n\n  class Base\n  {\n  public:\n    int b = 20;\n\n    void func () {}\n  };\n\n  class A : public Base\n  {\n  public:\n    int a = 10;\n\n    void func () {}\n  };\n\n  class C : public Base\n  {\n  public:\n    int c = 30;\n\n    void func () {}\n  };\n\nNote that\n\n* the variable 'a' is defined only in the context of A::func.\n* the variable 'c' is defined only in the context of C::func.\n* the variable 'b' is defined in all the three contexts.\n\nWith the existing GDB, it's not possible to define a conditional\nbreakpoint at 'func' if the condition refers to 'a' or 'c':\n\n  (gdb) break func if a == 10\n  No symbol \"a\" in current context.\n  (gdb) break func if c == 30\n  No symbol \"c\" in current context.\n  (gdb) info breakpoints\n  No breakpoints or watchpoints.\n\nWith this patch, it becomes possible:\n\n  (gdb) break func if a == 10\n  warning: failed to validate condition at location 1, disabling:\n    No symbol \"a\" in current context.\n  warning: failed to validate condition at location 3, disabling:\n    No symbol \"a\" in current context.\n  Breakpoint 1 at 0x11b6: func. (3 locations)\n  (gdb) break func if c == 30\n  Note: breakpoint 1 also set at pc 0x11ce.\n  Note: breakpoint 1 also set at pc 0x11c2.\n  Note: breakpoint 1 also set at pc 0x11b6.\n  warning: failed to validate condition at location 1, disabling:\n    No symbol \"c\" in current context.\n  warning: failed to validate condition at location 2, disabling:\n    No symbol \"c\" in current context.\n  Breakpoint 2 at 0x11b6: func. (3 locations)\n  (gdb) info breakpoints\n  Num     Type           Disp Enb Address            What\n  1       breakpoint     keep y   <MULTIPLE>\n          stop only if a == 10\n  1.1                         N*  0x00000000000011b6 in Base::func() at condbreak-multi-context.cc:23\n  1.2                         y   0x00000000000011c2 in A::func() at condbreak-multi-context.cc:31\n  1.3                         N*  0x00000000000011ce in C::func() at condbreak-multi-context.cc:39\n  2       breakpoint     keep y   <MULTIPLE>\n          stop only if c == 30\n  2.1                         N*  0x00000000000011b6 in Base::func() at condbreak-multi-context.cc:23\n  2.2                         N*  0x00000000000011c2 in A::func() at condbreak-multi-context.cc:31\n  2.3                         y   0x00000000000011ce in C::func() at condbreak-multi-context.cc:39\n  (*): Breakpoint condition is invalid at this location.\n\nHere, uppercase 'N' denotes that the location is disabled because of\nthe invalid condition, as mentioned with a footnote in the legend of\nthe table.  Locations that are disabled by the user are still denoted\nwith lowercase 'n'.  Executing the code hits the breakpoints 1.2 and\n2.3 as expected.\n\nDefining a condition on an unconditional breakpoint gives the same\nbehavior above:\n\n  (gdb) break func\n  Breakpoint 1 at 0x11b6: func. (3 locations)\n  (gdb) cond 1 a == 10\n  warning: failed to validate condition at location 1.1, disabling:\n    No symbol \"a\" in current context.\n  warning: failed to validate condition at location 1.3, disabling:\n    No symbol \"a\" in current context.\n  (gdb) info breakpoints\n  Num     Type           Disp Enb Address            What\n  1       breakpoint     keep y   <MULTIPLE>\n          stop only if a == 10\n  1.1                         N*  0x00000000000011b6 in Base::func() at condbreak-multi-context.cc:23\n  1.2                         y   0x00000000000011c2 in A::func() at condbreak-multi-context.cc:31\n  1.3                         N*  0x00000000000011ce in C::func() at condbreak-multi-context.cc:39\n  (*): Breakpoint condition is invalid at this location.\n\nLocations that are disabled because of a condition cannot be enabled\nby the user:\n\n  ...\n  (gdb) enable 1.1\n  Breakpoint 1's condition is invalid at location 1, cannot enable.\n\nResetting the condition enables the locations back:\n\n  ...\n  (gdb) cond 1\n  Breakpoint 1's condition is now valid at location 1, enabling.\n  Breakpoint 1's condition is now valid at location 3, enabling.\n  Breakpoint 1 now unconditional.\n  (gdb) info breakpoints\n  Num     Type           Disp Enb Address            What\n  1       breakpoint     keep y   <MULTIPLE>\n  1.1                         y   0x00000000000011b6 in Base::func() at condbreak-multi-context.cc:23\n  1.2                         y   0x00000000000011c2 in A::func() at condbreak-multi-context.cc:31\n  1.3                         y   0x00000000000011ce in C::func() at condbreak-multi-context.cc:39\n\nIf a location is disabled by the user, a condition can still be defined\nbut the location will remain disabled even if the condition is meaningful\nfor the disabled location:\n\n  ...\n  (gdb) disable 1.2\n  (gdb) cond 1 a == 10\n  warning: failed to validate condition at location 1.1, disabling:\n    No symbol \"a\" in current context.\n  warning: failed to validate condition at location 1.3, disabling:\n    No symbol \"a\" in current context.\n  (gdb) info breakpoints\n  Num     Type           Disp Enb Address            What\n  1       breakpoint     keep y   <MULTIPLE>\n          stop only if a == 10\n  1.1                         N*  0x00000000000011b6 in Base::func() at condbreak-multi-context.cc:23\n  1.2                         n   0x00000000000011c2 in A::func() at condbreak-multi-context.cc:31\n  1.3                         N*  0x00000000000011ce in C::func() at condbreak-multi-context.cc:39\n  (*): Breakpoint condition is invalid at this location.\n\nThe condition of a breakpoint can be changed.  Locations'\nenable/disable states are updated accordingly.\n\n  ...\n  (gdb) cond 1 c == 30\n  warning: failed to validate condition at location 1.1, disabling:\n    No symbol \"c\" in current context.\n  Breakpoint 1's condition is now valid at location 3, enabling.\n  (gdb) info breakpoints\n  Num     Type           Disp Enb Address            What\n  1       breakpoint     keep y   <MULTIPLE>\n          stop only if c == 30\n  1.1                         N*  0x00000000000011b6 in Base::func() at condbreak-multi-context.cc:23\n  1.2                         N*  0x00000000000011c2 in A::func() at condbreak-multi-context.cc:31\n  1.3                         y   0x00000000000011ce in C::func() at condbreak-multi-context.cc:39\n  (*): Breakpoint condition is invalid at this location.\n\n  (gdb) cond 1 b == 20\n  Breakpoint 1's condition is now valid at location 1, enabling.\n  (gdb) info breakpoints\n  Num     Type           Disp Enb Address            What\n  1       breakpoint     keep y   <MULTIPLE>\n          stop only if b == 20\n  1.1                         y   0x00000000000011b6 in Base::func() at condbreak-multi-context.cc:23\n  1.2                         n   0x00000000000011c2 in A::func() at condbreak-multi-context.cc:31\n  1.3                         y   0x00000000000011ce in C::func() at condbreak-multi-context.cc:39\n  # Note that location 1.2 was disabled by the user previously.\n\nIf the condition expression is bad for all the locations, it will be\nrejected.\n\n  (gdb) cond 1 garbage\n  No symbol \"garbage\" in current context.\n\nFor conditions that are invalid or valid for all the locations of a\nbreakpoint, the existing behavior is preserved.\n\nRegression-tested on X86_64 Linux.\n\ngdb/ChangeLog:\n2020-10-27  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* breakpoint.h (class bp_location) <disabled_by_cond>: New field.\n\t* breakpoint.c (set_breakpoint_location_condition): New function.\n\t(set_breakpoint_condition): Disable a breakpoint location if parsing\n\tthe condition string gives an error.\n\t(should_be_inserted): Update to consider the 'disabled_by_cond' field.\n\t(build_target_condition_list): Ditto.\n\t(build_target_command_list): Ditto.\n\t(build_bpstat_chain): Ditto.\n\t(print_one_breakpoint_location): Ditto.\n\t(print_one_breakpoint): Ditto.\n\t(breakpoint_1): Ditto.\n\t(bp_location::bp_location): Ditto.\n\t(locations_are_equal): Ditto.\n\t(update_breakpoint_locations): Ditto.\n\t(enable_disable_bp_num_loc): Ditto.\n\t(init_breakpoint_sal): Use set_breakpoint_location_condition.\n\t(find_condition_and_thread_for_sals): New static function.\n\t(create_breakpoint): Call find_condition_and_thread_for_sals.\n\t(location_to_sals): Call find_condition_and_thread_for_sals instead\n\tof find_condition_and_thread.\n\ngdb/testsuite/ChangeLog:\n2020-10-27  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* gdb.base/condbreak-multi-context.cc: New file.\n\t* gdb.base/condbreak-multi-context.exp: New file.\n\ngdb/doc/ChangeLog:\n2020-10-27  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* gdb.texinfo (Set Breaks): Document disabling of breakpoint\n\tlocations for which the breakpoint condition is invalid.",
    "tree": {
      "sha": "8cb19671c8ba66125d06239919fbe935222f5235",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8cb19671c8ba66125d06239919fbe935222f5235"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b5fa468fef441528147c3a47b085612d5305f181",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b5fa468fef441528147c3a47b085612d5305f181",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b5fa468fef441528147c3a47b085612d5305f181",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b5fa468fef441528147c3a47b085612d5305f181/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "afeee87bdc2b786804220949adbda5e331ec9b7a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/afeee87bdc2b786804220949adbda5e331ec9b7a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/afeee87bdc2b786804220949adbda5e331ec9b7a"
    }
  ],
  "stats": {
    "total": 598,
    "additions": 548,
    "deletions": 50
  },
  "files": [
    {
      "sha": "6b0a7c192ca4c35f8331884e52d54c7bd9c0e6fb",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b5fa468fef441528147c3a47b085612d5305f181/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b5fa468fef441528147c3a47b085612d5305f181/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b5fa468fef441528147c3a47b085612d5305f181",
      "patch": "@@ -1,3 +1,26 @@\n+2020-10-27  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* breakpoint.h (class bp_location) <disabled_by_cond>: New field.\n+\t* breakpoint.c (set_breakpoint_location_condition): New function.\n+\t(set_breakpoint_condition): Disable a breakpoint location if parsing\n+\tthe condition string gives an error.\n+\t(should_be_inserted): Update to consider the 'disabled_by_cond' field.\n+\t(build_target_condition_list): Ditto.\n+\t(build_target_command_list): Ditto.\n+\t(build_bpstat_chain): Ditto.\n+\t(print_one_breakpoint_location): Ditto.\n+\t(print_one_breakpoint): Ditto.\n+\t(breakpoint_1): Ditto.\n+\t(bp_location::bp_location): Ditto.\n+\t(locations_are_equal): Ditto.\n+\t(update_breakpoint_locations): Ditto.\n+\t(enable_disable_bp_num_loc): Ditto.\n+\t(init_breakpoint_sal): Use set_breakpoint_location_condition.\n+\t(find_condition_and_thread_for_sals): New static function.\n+\t(create_breakpoint): Call find_condition_and_thread_for_sals.\n+\t(location_to_sals): Call find_condition_and_thread_for_sals instead\n+\tof find_condition_and_thread.\n+\n 2020-10-26  Tom de Vries  <tdevries@suse.de>\n \n \t* dwarf2/read.c (process_full_comp_unit): Call"
    },
    {
      "sha": "0d3fd0c3d7e72e1e827ff3c64c5e114a7af3d1a0",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 185,
      "deletions": 50,
      "changes": 235,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b5fa468fef441528147c3a47b085612d5305f181/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b5fa468fef441528147c3a47b085612d5305f181/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=b5fa468fef441528147c3a47b085612d5305f181",
      "patch": "@@ -830,6 +830,56 @@ get_first_locp_gte_addr (CORE_ADDR address)\n   return locp_found;\n }\n \n+/* Parse COND_STRING in the context of LOC and set as the condition\n+   expression of LOC.  BP_NUM is the number of LOC's owner, LOC_NUM is\n+   the number of LOC within its owner.  In case of parsing error, mark\n+   LOC as DISABLED_BY_COND.  In case of success, unset DISABLED_BY_COND.  */\n+\n+static void\n+set_breakpoint_location_condition (const char *cond_string, bp_location *loc,\n+\t\t\t\t   int bp_num, int loc_num)\n+{\n+  bool has_junk = false;\n+  try\n+    {\n+      expression_up new_exp = parse_exp_1 (&cond_string, loc->address,\n+\t\t\t\t\t   block_for_pc (loc->address), 0);\n+      if (*cond_string != 0)\n+\thas_junk = true;\n+      else\n+\t{\n+\t  loc->cond = std::move (new_exp);\n+\t  if (loc->disabled_by_cond && loc->enabled)\n+\t    printf_filtered (_(\"Breakpoint %d's condition is now valid at \"\n+\t\t\t       \"location %d, enabling.\\n\"),\n+\t\t\t     bp_num, loc_num);\n+\n+\t  loc->disabled_by_cond = false;\n+\t}\n+    }\n+  catch (const gdb_exception_error &e)\n+    {\n+      if (loc->enabled)\n+\t{\n+\t  /* Warn if a user-enabled location is now becoming disabled-by-cond.\n+\t     BP_NUM is 0 if the breakpoint is being defined for the first\n+\t     time using the \"break ... if ...\" command, and non-zero if\n+\t     already defined.  */\n+\t  if (bp_num != 0)\n+\t    warning (_(\"failed to validate condition at location %d.%d, \"\n+\t\t       \"disabling:\\n  %s\"), bp_num, loc_num, e.what ());\n+\t  else\n+\t    warning (_(\"failed to validate condition at location %d, \"\n+\t\t       \"disabling:\\n  %s\"), loc_num, e.what ());\n+\t}\n+\n+      loc->disabled_by_cond = true;\n+    }\n+\n+  if (has_junk)\n+    error (_(\"Garbage '%s' follows condition\"), cond_string);\n+}\n+\n void\n set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \t\t\t  int from_tty)\n@@ -843,9 +893,16 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \tstatic_cast<watchpoint *> (b)->cond_exp.reset ();\n       else\n \t{\n+\t  int loc_num = 1;\n \t  for (bp_location *loc = b->loc; loc != nullptr; loc = loc->next)\n \t    {\n \t      loc->cond.reset ();\n+\t      if (loc->disabled_by_cond && loc->enabled)\n+\t\tprintf_filtered (_(\"Breakpoint %d's condition is now valid at \"\n+\t\t\t\t   \"location %d, enabling.\\n\"),\n+\t\t\t\t b->number, loc_num);\n+\t      loc->disabled_by_cond = false;\n+\t      loc_num++;\n \n \t      /* No need to free the condition agent expression\n \t\t bytecode (if we have one).  We will handle this\n@@ -873,29 +930,37 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \t{\n \t  /* Parse and set condition expressions.  We make two passes.\n \t     In the first, we parse the condition string to see if it\n-\t     is valid in all locations.  If so, the condition would be\n-\t     accepted.  So we go ahead and set the locations'\n-\t     conditions.  In case a failing case is found, we throw\n+\t     is valid in at least one location.  If so, the condition\n+\t     would be accepted.  So we go ahead and set the locations'\n+\t     conditions.  In case no valid case is found, we throw\n \t     the error and the condition string will be rejected.\n \t     This two-pass approach is taken to avoid setting the\n \t     state of locations in case of a reject.  */\n \t  for (bp_location *loc = b->loc; loc != nullptr; loc = loc->next)\n \t    {\n-\t      const char *arg = exp;\n-\t      parse_exp_1 (&arg, loc->address,\n-\t\t\t   block_for_pc (loc->address), 0);\n-\t      if (*arg != 0)\n-\t\terror (_(\"Junk at end of expression\"));\n+\t      try\n+\t\t{\n+\t\t  const char *arg = exp;\n+\t\t  parse_exp_1 (&arg, loc->address,\n+\t\t\t       block_for_pc (loc->address), 0);\n+\t\t  if (*arg != 0)\n+\t\t    error (_(\"Junk at end of expression\"));\n+\t\t  break;\n+\t\t}\n+\t      catch (const gdb_exception_error &e)\n+\t\t{\n+\t\t  /* Condition string is invalid.  If this happens to\n+\t\t     be the last loc, abandon.  */\n+\t\t  if (loc->next == nullptr)\n+\t\t    throw;\n+\t\t}\n \t    }\n \n-\t  /* If we reach here, the condition is valid at all locations.  */\n-\t  for (bp_location *loc = b->loc; loc != nullptr; loc = loc->next)\n-\t    {\n-\t      const char *arg = exp;\n-\t      loc->cond =\n-\t\tparse_exp_1 (&arg, loc->address,\n-\t\t\t     block_for_pc (loc->address), 0);\n-\t    }\n+\t  /* If we reach here, the condition is valid at some locations.  */\n+          int loc_num = 1;\n+          for (bp_location *loc = b->loc; loc != nullptr;\n+               loc = loc->next, loc_num++)\n+            set_breakpoint_location_condition (exp, loc, b->number, loc_num);\n \t}\n \n       /* We know that the new condition parsed successfully.  The\n@@ -2010,7 +2075,8 @@ should_be_inserted (struct bp_location *bl)\n   if (bl->owner->disposition == disp_del_at_next_stop)\n     return 0;\n \n-  if (!bl->enabled || bl->shlib_disabled || bl->duplicate)\n+  if (!bl->enabled || bl->disabled_by_cond\n+      || bl->shlib_disabled || bl->duplicate)\n     return 0;\n \n   if (user_breakpoint_p (bl->owner) && bl->pspace->executing_startup)\n@@ -2205,7 +2271,8 @@ build_target_condition_list (struct bp_location *bl)\n \t  && is_breakpoint (loc->owner)\n \t  && loc->pspace->num == bl->pspace->num\n \t  && loc->owner->enable_state == bp_enabled\n-\t  && loc->enabled)\n+\t  && loc->enabled\n+\t  && !loc->disabled_by_cond)\n \t{\n \t  /* Add the condition to the vector.  This will be used later\n \t     to send the conditions to the target.  */\n@@ -2395,7 +2462,8 @@ build_target_command_list (struct bp_location *bl)\n \t  && is_breakpoint (loc->owner)\n \t  && loc->pspace->num == bl->pspace->num\n \t  && loc->owner->enable_state == bp_enabled\n-\t  && loc->enabled)\n+\t  && loc->enabled\n+\t  && !loc->disabled_by_cond)\n \t{\n \t  /* Add the command to the vector.  This will be used later\n \t     to send the commands to the target.  */\n@@ -5278,7 +5346,7 @@ build_bpstat_chain (const address_space *aspace, CORE_ADDR bp_addr,\n \t  if (b->type == bp_hardware_watchpoint && bl != b->loc)\n \t    break;\n \n-\t  if (!bl->enabled || bl->shlib_disabled)\n+\t  if (!bl->enabled || bl->disabled_by_cond || bl->shlib_disabled)\n \t    continue;\n \n \t  if (!bpstat_check_location (bl, aspace, bp_addr, ws))\n@@ -5987,7 +6055,8 @@ print_one_breakpoint_location (struct breakpoint *b,\n      breakpoints with single disabled location.  */\n   if (loc == NULL \n       && (b->loc != NULL \n-\t  && (b->loc->next != NULL || !b->loc->enabled)))\n+\t  && (b->loc->next != NULL\n+\t      || !b->loc->enabled || b->loc->disabled_by_cond)))\n     header_of_multiple = 1;\n   if (loc == NULL)\n     loc = b->loc;\n@@ -6018,7 +6087,8 @@ print_one_breakpoint_location (struct breakpoint *b,\n   /* 4 */\n   annotate_field (3);\n   if (part_of_multiple)\n-    uiout->field_string (\"enabled\", loc->enabled ? \"y\" : \"n\");\n+    uiout->field_string (\"enabled\", (loc->disabled_by_cond ? \"N*\"\n+\t\t\t\t     : (loc->enabled ? \"y\" : \"n\")));\n   else\n     uiout->field_fmt (\"enabled\", \"%c\", bpenables[(int) b->enable_state]);\n \n@@ -6318,7 +6388,9 @@ print_one_breakpoint (struct breakpoint *b,\n \t  && (!is_catchpoint (b) || is_exception_catchpoint (b)\n \t      || is_ada_exception_catchpoint (b))\n \t  && (allflag\n-\t      || (b->loc && (b->loc->next || !b->loc->enabled))))\n+\t      || (b->loc && (b->loc->next\n+\t\t\t     || !b->loc->enabled\n+\t\t\t     || b->loc->disabled_by_cond))))\n \t{\n \t  gdb::optional<ui_out_emit_list> locations_list;\n \n@@ -6412,6 +6484,7 @@ breakpoint_1 (const char *bp_num_list, bool show_internal,\n   int print_address_bits = 0;\n   int print_type_col_width = 14;\n   struct ui_out *uiout = current_uiout;\n+  bool has_disabled_by_cond_location = false;\n \n   get_user_print_options (&opts);\n \n@@ -6512,7 +6585,12 @@ breakpoint_1 (const char *bp_num_list, bool show_internal,\n \t/* We only print out user settable breakpoints unless the\n \t   show_internal is set.  */\n \tif (show_internal || user_breakpoint_p (b))\n-\t  print_one_breakpoint (b, &last_loc, show_internal);\n+\t  {\n+\t    print_one_breakpoint (b, &last_loc, show_internal);\n+\t    for (bp_location *loc = b->loc; loc != NULL; loc = loc->next)\n+\t      if (loc->disabled_by_cond)\n+\t\thas_disabled_by_cond_location = true;\n+\t  }\n       }\n   }\n \n@@ -6533,6 +6611,10 @@ breakpoint_1 (const char *bp_num_list, bool show_internal,\n     {\n       if (last_loc && !server_command)\n \tset_next_address (last_loc->gdbarch, last_loc->address);\n+\n+      if (has_disabled_by_cond_location)\n+\tuiout->message (_(\"(*): Breakpoint condition is invalid at this \"\n+\t\t\t  \"location.\\n\"));\n     }\n \n   /* FIXME?  Should this be moved up so that it is only called when\n@@ -6960,6 +7042,7 @@ bp_location::bp_location (breakpoint *owner, bp_loc_type type)\n   this->cond_bytecode = NULL;\n   this->shlib_disabled = 0;\n   this->enabled = 1;\n+  this->disabled_by_cond = false;\n \n   this->loc_type = type;\n \n@@ -8832,15 +8915,9 @@ init_breakpoint_sal (struct breakpoint *b, struct gdbarch *gdbarch,\n \t    loc->inserted = 1;\n \t}\n \n-      if (b->cond_string)\n-\t{\n-\t  const char *arg = b->cond_string;\n-\n-\t  loc->cond = parse_exp_1 (&arg, loc->address,\n-\t\t\t\t   block_for_pc (loc->address), 0);\n-\t  if (*arg)\n-              error (_(\"Garbage '%s' follows condition\"), arg);\n-\t}\n+      /* Do not set breakpoint locations conditions yet.  As locations\n+\t are inserted, they get sorted based on their addresses.  Let\n+\t the list stabilize to have reliable location numbers.  */\n \n       /* Dynamic printf requires and uses additional arguments on the\n \t command line, otherwise it's an error.  */\n@@ -8855,6 +8932,19 @@ init_breakpoint_sal (struct breakpoint *b, struct gdbarch *gdbarch,\n \terror (_(\"Garbage '%s' at end of command\"), b->extra_string);\n     }\n \n+\n+  /* The order of the locations is now stable.  Set the location\n+     condition using the location's number.  */\n+  int loc_num = 1;\n+  for (bp_location *loc = b->loc; loc != nullptr; loc = loc->next)\n+    {\n+      if (b->cond_string != nullptr)\n+\tset_breakpoint_location_condition (b->cond_string, loc, b->number,\n+\t\t\t\t\t   loc_num);\n+\n+      ++loc_num;\n+    }\n+\n   b->display_canonical = display_canonical;\n   if (location != NULL)\n     b->location = std::move (location);\n@@ -9143,6 +9233,50 @@ find_condition_and_thread (const char *tok, CORE_ADDR pc,\n     }\n }\n \n+/* Call 'find_condition_and_thread' for each sal in SALS until a parse\n+   succeeds.  The parsed values are written to COND_STRING, THREAD,\n+   TASK, and REST.  See the comment of 'find_condition_and_thread'\n+   for the description of these parameters and INPUT.  */\n+\n+static void\n+find_condition_and_thread_for_sals (const std::vector<symtab_and_line> &sals,\n+\t\t\t\t    const char *input, char **cond_string,\n+\t\t\t\t    int *thread, int *task, char **rest)\n+{\n+  int num_failures = 0;\n+  for (auto &sal : sals)\n+    {\n+      char *cond = nullptr;\n+      int thread_id = 0;\n+      int task_id = 0;\n+      char *remaining = nullptr;\n+\n+      /* Here we want to parse 'arg' to separate condition from thread\n+\t number.  But because parsing happens in a context and the\n+\t contexts of sals might be different, try each until there is\n+\t success.  Finding one successful parse is sufficient for our\n+\t goal.  When setting the breakpoint we'll re-parse the\n+\t condition in the context of each sal.  */\n+      try\n+\t{\n+\t  find_condition_and_thread (input, sal.pc, &cond, &thread_id,\n+\t\t\t\t     &task_id, &remaining);\n+\t  *cond_string = cond;\n+\t  *thread = thread_id;\n+\t  *task = task_id;\n+\t  *rest = remaining;\n+\t  break;\n+\t}\n+      catch (const gdb_exception_error &e)\n+\t{\n+\t  num_failures++;\n+\t  /* If no sal remains, do not continue.  */\n+\t  if (num_failures == sals.size ())\n+\t    throw;\n+\t}\n+    }\n+}\n+\n /* Decode a static tracepoint marker spec.  */\n \n static std::vector<symtab_and_line>\n@@ -9306,13 +9440,8 @@ create_breakpoint (struct gdbarch *gdbarch,\n \n \t  const linespec_sals &lsal = canonical.lsals[0];\n \n-\t  /* Here we only parse 'arg' to separate condition\n-\t     from thread number, so parsing in context of first\n-\t     sal is OK.  When setting the breakpoint we'll\n-\t     re-parse it in context of each sal.  */\n-\n-\t  find_condition_and_thread (extra_string, lsal.sals[0].pc,\n-\t\t\t\t     &cond, &thread, &task, &rest);\n+\t  find_condition_and_thread_for_sals (lsal.sals, extra_string,\n+\t\t\t\t\t      &cond, &thread, &task, &rest);\n \t  cond_string_copy.reset (cond);\n \t  extra_string_copy.reset (rest);\n         }\n@@ -13414,6 +13543,9 @@ locations_are_equal (struct bp_location *a, struct bp_location *b)\n       if (a->enabled != b->enabled)\n \treturn 0;\n \n+      if (a->disabled_by_cond != b->disabled_by_cond)\n+\treturn 0;\n+\n       a = a->next;\n       b = b->next;\n     }\n@@ -13521,10 +13653,7 @@ update_breakpoint_locations (struct breakpoint *b,\n \t    }\n \t  catch (const gdb_exception_error &e)\n \t    {\n-\t      warning (_(\"failed to reevaluate condition \"\n-\t\t\t \"for breakpoint %d: %s\"), \n-\t\t       b->number, e.what ());\n-\t      new_loc->enabled = 0;\n+\t      new_loc->disabled_by_cond = true;\n \t    }\n \t}\n \n@@ -13549,7 +13678,7 @@ update_breakpoint_locations (struct breakpoint *b,\n \n     for (; e; e = e->next)\n       {\n-\tif (!e->enabled && e->function_name)\n+\tif ((!e->enabled || e->disabled_by_cond) && e->function_name)\n \t  {\n \t    struct bp_location *l = b->loc;\n \t    if (have_ambiguous_names)\n@@ -13565,7 +13694,8 @@ update_breakpoint_locations (struct breakpoint *b,\n \t\t       enough.  */\n \t\t    if (breakpoint_locations_match (e, l, true))\n \t\t      {\n-\t\t\tl->enabled = 0;\n+\t\t\tl->enabled = e->enabled;\n+\t\t\tl->disabled_by_cond = e->disabled_by_cond;\n \t\t\tbreak;\n \t\t      }\n \t\t  }\n@@ -13576,7 +13706,8 @@ update_breakpoint_locations (struct breakpoint *b,\n \t\t  if (l->function_name\n \t\t      && strcmp (e->function_name, l->function_name) == 0)\n \t\t    {\n-\t\t      l->enabled = 0;\n+\t\t      l->enabled = e->enabled;\n+\t\t      l->disabled_by_cond = e->disabled_by_cond;\n \t\t      break;\n \t\t    }\n \t      }\n@@ -13650,9 +13781,9 @@ location_to_sals (struct breakpoint *b, struct event_location *location,\n \t  char *cond_string, *extra_string;\n \t  int thread, task;\n \n-\t  find_condition_and_thread (b->extra_string, sals[0].pc,\n-\t\t\t\t     &cond_string, &thread, &task,\n-\t\t\t\t     &extra_string);\n+\t  find_condition_and_thread_for_sals (sals, b->extra_string,\n+\t\t\t\t\t      &cond_string, &thread,\n+\t\t\t\t\t      &task, &extra_string);\n \t  gdb_assert (b->cond_string == NULL);\n \t  if (cond_string)\n \t    b->cond_string = cond_string;\n@@ -14137,6 +14268,10 @@ enable_disable_bp_num_loc (int bp_num, int loc_num, bool enable)\n   struct bp_location *loc = find_location_by_number (bp_num, loc_num);\n   if (loc != NULL)\n     {\n+      if (loc->disabled_by_cond && enable)\n+\terror (_(\"Breakpoint %d's condition is invalid at location %d, \"\n+\t\t \"cannot enable.\"), bp_num, loc_num);\n+\n       if (loc->enabled != enable)\n \t{\n \t  loc->enabled = enable;"
    },
    {
      "sha": "7d02cedf2fa9f6134759edd146eb31b922a3a854",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b5fa468fef441528147c3a47b085612d5305f181/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b5fa468fef441528147c3a47b085612d5305f181/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=b5fa468fef441528147c3a47b085612d5305f181",
      "patch": "@@ -387,6 +387,12 @@ class bp_location\n   /* Is this particular location enabled.  */\n   bool enabled = false;\n   \n+  /* Is this particular location disabled because the condition\n+     expression is invalid at this location.  For a location to be\n+     reported as enabled, the ENABLED field above has to be true *and*\n+     the DISABLED_BY_COND field has to be false.  */\n+  bool disabled_by_cond = false;\n+\n   /* True if this breakpoint is now inserted.  */\n   bool inserted = false;\n "
    },
    {
      "sha": "84c173b94a34f1486c106367258c73149d59ba35",
      "filename": "gdb/doc/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b5fa468fef441528147c3a47b085612d5305f181/gdb/doc/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b5fa468fef441528147c3a47b085612d5305f181/gdb/doc/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/ChangeLog?ref=b5fa468fef441528147c3a47b085612d5305f181",
      "patch": "@@ -1,3 +1,8 @@\n+2020-10-27  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* gdb.texinfo (Set Breaks): Document disabling of breakpoint\n+\tlocations for which the breakpoint condition is invalid.\n+\n 2020-10-06  Michael Forney  <mforney@mforney.org>\n \n \t* Makefile.in (HAVE_NATIVE_GCORE_HOST): Add for gcore.1"
    },
    {
      "sha": "9da79ed5cde4edc7e0dd688c4c975db3915a07c4",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b5fa468fef441528147c3a47b085612d5305f181/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b5fa468fef441528147c3a47b085612d5305f181/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=b5fa468fef441528147c3a47b085612d5305f181",
      "patch": "@@ -4278,6 +4278,46 @@ value is nonzero---that is, if @var{cond} evaluates as true.\n above (or no argument) specifying where to break.  @xref{Conditions,\n ,Break Conditions}, for more information on breakpoint conditions.\n \n+The breakpoint may be mapped to multiple locations.  If the breakpoint\n+condition @var{cond} is invalid at some but not all of the locations,\n+the locations for which the condition is invalid are disabled.  For\n+example, @value{GDBN} reports below that two of the three locations\n+are disabled.\n+\n+@smallexample\n+(@value{GDBP}) break func if a == 10\n+warning: failed to validate condition at location 0x11ce, disabling:\n+  No symbol \"a\" in current context.\n+warning: failed to validate condition at location 0x11b6, disabling:\n+  No symbol \"a\" in current context.\n+Breakpoint 1 at 0x11b6: func. (3 locations)\n+@end smallexample\n+\n+Locations that are disabled because of the condition are denoted by an\n+uppercase @code{N} in the output of the @code{info breakpoints}\n+command:\n+\n+@smallexample\n+(@value{GDBP}) info breakpoints\n+Num     Type           Disp Enb Address            What\n+1       breakpoint     keep y   <MULTIPLE>\n+        stop only if a == 10\n+1.1                         N*  0x00000000000011b6 in ...\n+1.2                         y   0x00000000000011c2 in ...\n+1.3                         N*  0x00000000000011ce in ...\n+(*): Breakpoint condition is invalid at this location.\n+@end smallexample\n+\n+If the breakpoint condition @var{cond} is invalid in the context of\n+@emph{all} the locations of the breakpoint, @value{GDBN} refuses to\n+define the breakpoint.  For example, if variable @code{foo} is an\n+undefined variable:\n+\n+@smallexample\n+(@value{GDBP}) break func if foo\n+No symbol \"foo\" in current context.\n+@end smallexample\n+\n @kindex tbreak\n @item tbreak @var{args}\n Set a breakpoint enabled only for one stop.  The @var{args} are the"
    },
    {
      "sha": "4e5f5dcbe4ce94967df5122332e25f24f1f31e48",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b5fa468fef441528147c3a47b085612d5305f181/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b5fa468fef441528147c3a47b085612d5305f181/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=b5fa468fef441528147c3a47b085612d5305f181",
      "patch": "@@ -1,3 +1,8 @@\n+2020-10-27  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* gdb.base/condbreak-multi-context.cc: New file.\n+\t* gdb.base/condbreak-multi-context.exp: New file.\n+\n 2020-10-26  Tom Tromey  <tom@tromey.com>\n \n \t* lib/mi-support.exp (default_mi_gdb_start): Call"
    },
    {
      "sha": "5e994e2428ebf19f86f96c553efdb72730eb034f",
      "filename": "gdb/testsuite/gdb.base/condbreak-multi-context.cc",
      "status": "added",
      "additions": 54,
      "deletions": 0,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b5fa468fef441528147c3a47b085612d5305f181/gdb/testsuite/gdb.base/condbreak-multi-context.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b5fa468fef441528147c3a47b085612d5305f181/gdb/testsuite/gdb.base/condbreak-multi-context.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/condbreak-multi-context.cc?ref=b5fa468fef441528147c3a47b085612d5305f181",
      "patch": "@@ -0,0 +1,54 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2020 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+class Base\n+{\n+public:\n+  int b = 20;\n+\n+  void func () {}\n+};\n+\n+class A : public Base\n+{\n+public:\n+  int a = 10;\n+\n+  void func () {}\n+};\n+\n+class C : public Base\n+{\n+public:\n+  int c = 30;\n+\n+  void func () {}\n+};\n+\n+int\n+main ()\n+{\n+  Base bobj;\n+  A aobj;\n+  C cobj;\n+\n+  aobj.func ();\n+  bobj.func ();\n+  cobj.func ();\n+\n+  return 0;\n+}"
    },
    {
      "sha": "4e56d36fb43f37a25969460be30571d38ecf0e15",
      "filename": "gdb/testsuite/gdb.base/condbreak-multi-context.exp",
      "status": "added",
      "additions": 230,
      "deletions": 0,
      "changes": 230,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b5fa468fef441528147c3a47b085612d5305f181/gdb/testsuite/gdb.base/condbreak-multi-context.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b5fa468fef441528147c3a47b085612d5305f181/gdb/testsuite/gdb.base/condbreak-multi-context.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/condbreak-multi-context.exp?ref=b5fa468fef441528147c3a47b085612d5305f181",
      "patch": "@@ -0,0 +1,230 @@\n+# Copyright 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test defining a conditional breakpoint that applies to multiple\n+# locations with different contexts (e.g. different set of local vars).\n+\n+standard_testfile .cc\n+\n+if {[prepare_for_testing \"failed to prepare\" ${binfile} ${srcfile}]} {\n+    return\n+}\n+\n+set warning \"warning: failed to validate condition\"\n+set fill \"\\[^\\r\\n\\]*\"\n+\n+# Check that breakpoints are as expected.\n+\n+proc test_info_break {suffix} {\n+    global bpnum1 bpnum2 fill\n+\n+    set bp_hit_info \"${fill}(\\r\\n${fill}breakpoint already hit 1 time)?\"\n+\n+    gdb_test \"info break ${bpnum1} ${bpnum2}\" \\\n+\t[multi_line \\\n+\t     \"Num${fill}\" \\\n+\t     \"${bpnum1}${fill}breakpoint${fill}keep y${fill}MULTIPLE${fill}\" \\\n+\t     \"${fill}stop only if a == 10${bp_hit_info}\" \\\n+\t     \"${bpnum1}.1${fill}N\\\\*${fill}Base::func${fill}\" \\\n+\t     \"${bpnum1}.2${fill}y${fill}A::func${fill}\" \\\n+\t     \"${bpnum1}.3${fill}N\\\\*${fill}C::func${fill}\" \\\n+\t     \"${bpnum2}${fill}breakpoint${fill}keep y${fill}MULTIPLE${fill}\" \\\n+\t     \"${fill}stop only if c == 30${bp_hit_info}\" \\\n+\t     \"${bpnum2}.1${fill}N\\\\*${fill}Base::func${fill}\" \\\n+\t     \"${bpnum2}.2${fill}N\\\\*${fill}A::func${fill}\" \\\n+\t     \"${bpnum2}.3${fill}y${fill}C::func${fill}\" \\\n+\t     \"\\\\(\\\\*\\\\): Breakpoint condition is invalid at this location.\"] \\\n+\t\"info break $suffix\"\n+}\n+\n+# Scenario 1: Define breakpoints conditionally, using the \"break N if\n+# cond\" syntax.  Run the program, check that we hit those locations\n+# only.\n+\n+with_test_prefix \"scenario 1\" {\n+    # Define the conditional breakpoints.\n+    gdb_test \"break func if a == 10\" \\\n+\t[multi_line \\\n+\t     \"${warning} at location 1, disabling:\" \\\n+\t     \"  No symbol \\\"a\\\" in current context.\" \\\n+\t     \"${warning} at location 3, disabling:\" \\\n+\t     \"  No symbol \\\"a\\\" in current context.\" \\\n+\t     \"Breakpoint $decimal at $fill .3 locations.\"] \\\n+\t\"define bp with condition a == 10\"\n+    set bpnum1 [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum1\"]\n+\n+    gdb_test \"break func if c == 30\" \\\n+\t[multi_line \\\n+\t     \".*${warning} at location 1, disabling:\" \\\n+\t     \"  No symbol \\\"c\\\" in current context.\" \\\n+\t     \".*${warning} at location 2, disabling:\" \\\n+\t     \"  No symbol \\\"c\\\" in current context.\" \\\n+\t     \".*Breakpoint $decimal at $fill .3 locations.\"] \\\n+\t\"define bp with condition c == 30\"\n+    set bpnum2 [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum2\"]\n+\n+    test_info_break 1\n+\n+    # Do not use runto_main, it deletes all breakpoints.\n+    gdb_run_cmd\n+\n+    # Check our conditional breakpoints.\n+    gdb_test \"\" \".*Breakpoint \\[0-9\\]+, A::func .*\" \\\n+\t\"run until A::func\"\n+    gdb_test \"print a\" \" = 10\"\n+\n+    gdb_test \"continue\" \"Continuing.*Breakpoint \\[0-9\\]+, C::func .*\" \\\n+\t\"run until C::func\"\n+    gdb_test \"print c\" \" = 30\"\n+\n+    # No more hits!\n+    gdb_continue_to_end\n+\n+    test_info_break 2\n+}\n+\n+# Start GDB with two breakpoints and define the conditions separately.\n+\n+proc setup_bps {} {\n+    global srcfile binfile srcfile2\n+    global bpnum1 bpnum2 bp_location warning\n+\n+    clean_restart ${binfile}\n+\n+    # Define the breakpoints.\n+    gdb_breakpoint \"func\"\n+    set bpnum1 [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum1\"]\n+\n+    gdb_breakpoint \"func\"\n+    set bpnum2 [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum2\"]\n+\n+    # Defining a condition on 'a' disables 2 locations.\n+    gdb_test \"cond $bpnum1 a == 10\" \\\n+\t[multi_line \\\n+\t     \"$warning at location ${bpnum1}.1, disabling:\" \\\n+\t     \"  No symbol \\\"a\\\" in current context.\" \\\n+\t     \"$warning at location ${bpnum1}.3, disabling:\" \\\n+\t     \"  No symbol \\\"a\\\" in current context.\"]\n+\n+    # Defining a condition on 'c' disables 2 locations.\n+    gdb_test \"cond $bpnum2 c == 30\" \\\n+\t[multi_line \\\n+\t     \"$warning at location ${bpnum2}.1, disabling:\" \\\n+\t     \"  No symbol \\\"c\\\" in current context.\" \\\n+\t     \"$warning at location ${bpnum2}.2, disabling:\" \\\n+\t     \"  No symbol \\\"c\\\" in current context.\"]\n+}\n+\n+# Scenario 2: Define breakpoints unconditionally, and then define\n+# conditions using the \"cond N <cond>\" syntax.  Expect that the\n+# locations where <cond> is not evaluatable are disabled.  Run the\n+# program, check that we hit the enabled locations only.\n+\n+with_test_prefix \"scenario 2\" {\n+    setup_bps\n+\n+    test_info_break 1\n+\n+    # Do not use runto_main, it deletes all breakpoints.\n+    gdb_run_cmd\n+\n+    # Check that we hit enabled locations only.\n+    gdb_test \"\" \".*Breakpoint \\[0-9\\]+, A::func .*\" \\\n+\t\"run until A::func\"\n+    gdb_test \"print a\" \" = 10\"\n+\n+    gdb_test \"continue\" \"Continuing.*Breakpoint \\[0-9\\]+, C::func .*\" \\\n+\t\"run until C::func\"\n+    gdb_test \"print c\" \" = 30\"\n+\n+    # No more hits!\n+    gdb_continue_to_end\n+\n+    test_info_break 2\n+}\n+\n+# Test the breakpoint location enabled states.\n+\n+proc check_bp_locations {bpnum states msg} {\n+    global fill\n+\n+    set expected  \".*${bpnum}.1${fill} [lindex $states 0] ${fill}\\r\\n\"\n+    append expected \"${bpnum}.2${fill} [lindex $states 1] ${fill}\\r\\n\"\n+    append expected \"${bpnum}.3${fill} [lindex $states 2] ${fill}\"\n+    if {[lsearch $states N*] >= 0} {\n+\tappend expected \"\\r\\n\\\\(\\\\*\\\\): Breakpoint condition is invalid at this location.\"\n+    }\n+\n+    gdb_test \"info break $bpnum\" $expected \"check bp $bpnum $msg\"\n+}\n+\n+# Scenario 3: Apply misc. checks on the already-defined breakpoints.\n+\n+with_test_prefix \"scenario 3\" {\n+    setup_bps\n+\n+    gdb_test \"cond $bpnum1 c == 30\" \\\n+\t[multi_line \\\n+\t     \"${warning} at location ${bpnum1}.1, disabling:\" \\\n+\t     \"  No symbol \\\"c\\\" in current context.\" \\\n+\t     \"${warning} at location ${bpnum1}.2, disabling:\" \\\n+\t     \"  No symbol \\\"c\\\" in current context.\" \\\n+\t     \"Breakpoint ${bpnum1}'s condition is now valid at location 3, enabling.\"] \\\n+\t\"change the condition of bp 1\"\n+    check_bp_locations $bpnum1 {N* N* y} \"after changing the condition\"\n+\n+    gdb_test \"cond $bpnum1\" \\\n+\t[multi_line \\\n+\t     \"Breakpoint ${bpnum1}'s condition is now valid at location 1, enabling.\" \\\n+\t     \"Breakpoint ${bpnum1}'s condition is now valid at location 2, enabling.\" \\\n+\t     \"Breakpoint ${bpnum1} now unconditional.\"] \\\n+\t\"reset the condition of bp 1\"\n+    check_bp_locations $bpnum1 {y y y} \"after resetting the condition\"\n+\n+    gdb_test_no_output \"disable ${bpnum2}.2\"\n+    check_bp_locations $bpnum2 {N* N* y} \"after disabling loc 2\"\n+\n+    gdb_test \"cond $bpnum2\" \".*\" \"reset the condition of bp 2\"\n+    check_bp_locations $bpnum2 {y n y} \"loc 2 should remain disabled\"\n+\n+    gdb_test_no_output \"disable ${bpnum2}.3\"\n+    check_bp_locations $bpnum2 {y n n} \"after disabling loc 3\"\n+\n+    gdb_test \"cond $bpnum2 c == 30\" \\\n+\t[multi_line \\\n+\t     \"${warning} at location ${bpnum2}.1, disabling:\" \\\n+\t     \"  No symbol \\\"c\\\" in current context.\"] \\\n+\t\"re-define a condition\"\n+    check_bp_locations $bpnum2 {N* N* n} \"loc 3 should remain disabled\"\n+\n+    gdb_test \"enable ${bpnum2}.1\" \\\n+\t\"Breakpoint ${bpnum2}'s condition is invalid at location 1, cannot enable.\" \\\n+\t\"reject enabling a location that is disabled-by-cond\"\n+    check_bp_locations $bpnum2 {N* N* n} \"after enable attempt\"\n+\n+    gdb_test \"cond $bpnum2 garbage\" \\\n+\t\"No symbol \\\"garbage\\\" in current context.\" \\\n+\t\"reject condition if bad for all locations\"\n+\n+    gdb_test_no_output \"delete $bpnum1\"\n+\n+    # Do not use runto_main, it deletes all breakpoints.\n+    gdb_breakpoint \"main\"\n+    gdb_run_cmd\n+    gdb_test \"\" \".*reakpoint .*, main .*${srcfile}.*\" \"start\"\n+\n+    # The second BP's locations are all disabled.  No more hits!\n+    gdb_continue_to_end\n+}"
    }
  ]
}