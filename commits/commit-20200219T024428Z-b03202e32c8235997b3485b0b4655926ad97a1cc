{
  "sha": "b03202e32c8235997b3485b0b4655926ad97a1cc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjAzMjAyZTMyYzgyMzU5OTdiMzQ4NWIwYjQ2NTU5MjZhZDk3YTFjYw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-19T02:44:28Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-19T02:44:28Z"
    },
    "message": "bfd_get_size cache\n\nWe have calls to bfd_get_size when swapping in ELF section headers.\nSince object files can have a large number of sections, it's worth\ncaching the file size rather than making lots of stat system calls.\n\n\t* bfd.c (struct bfd): Move format and direction to other\n\tbitfields.  Add \"size\".\n\t* bfdio.c (bfd_get_size): Cache size when not writing file.\n\t* opncls.c (bfd_get_debug_link_info_1): Allow for bfd_get_size\n\treturning zero, ie. unknown.\n\t(bfd_get_alt_debug_link_info): Likewise.\n\t* bfd-in2.h: Regenerate.",
    "tree": {
      "sha": "0697dbbcfdd4c7b08d717ce5fcc5b640872e0367",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0697dbbcfdd4c7b08d717ce5fcc5b640872e0367"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b03202e32c8235997b3485b0b4655926ad97a1cc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b03202e32c8235997b3485b0b4655926ad97a1cc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b03202e32c8235997b3485b0b4655926ad97a1cc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b03202e32c8235997b3485b0b4655926ad97a1cc/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7c5fa58ea907c46817b915ec8b9b35a180e0e74c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7c5fa58ea907c46817b915ec8b9b35a180e0e74c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7c5fa58ea907c46817b915ec8b9b35a180e0e74c"
    }
  ],
  "stats": {
    "total": 79,
    "additions": 59,
    "deletions": 20
  },
  "files": [
    {
      "sha": "58dbb567f2f16544c0028862437bd50d7a8c2dfa",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=b03202e32c8235997b3485b0b4655926ad97a1cc",
      "patch": "@@ -1,3 +1,13 @@\n+2020-02-19  Alan Modra  <amodra@gmail.com>\n+\n+\t* bfd.c (struct bfd): Move format and direction to other\n+\tbitfields.  Add \"size\".\n+\t* bfdio.c (bfd_get_size): Cache size when not writing file.\n+\t* opncls.c (bfd_get_debug_link_info_1): Allow for bfd_get_size\n+\treturning zero, ie. unknown.\n+\t(bfd_get_alt_debug_link_info): Likewise.\n+\t* bfd-in2.h: Regenerate.\n+\n 2020-02-19  Alan Modra  <amodra@gmail.com>\n \n \t* coffgen.c (_bfd_coff_get_external_symbols): Don't call"
    },
    {
      "sha": "2d56fdad41dc97c366dcc3a01ebff725fb70eb74",
      "filename": "bfd/bfd-in2.h",
      "status": "modified",
      "additions": 12,
      "deletions": 7,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/bfd-in2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/bfd-in2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in2.h?ref=b03202e32c8235997b3485b0b4655926ad97a1cc",
      "patch": "@@ -6497,12 +6497,6 @@ struct bfd\n   /* A unique identifier of the BFD  */\n   unsigned int id;\n \n-  /* The format which belongs to the BFD. (object, core, etc.)  */\n-  ENUM_BITFIELD (bfd_format) format : 3;\n-\n-  /* The direction with which the BFD was opened.  */\n-  ENUM_BITFIELD (bfd_direction) direction : 2;\n-\n   /* Format_specific flags.  */\n   flagword flags;\n \n@@ -6606,6 +6600,12 @@ struct bfd\n    | BFD_PLUGIN | BFD_TRADITIONAL_FORMAT | BFD_DETERMINISTIC_OUTPUT \\\n    | BFD_COMPRESS_GABI | BFD_CONVERT_ELF_COMMON | BFD_USE_ELF_STT_COMMON)\n \n+  /* The format which belongs to the BFD. (object, core, etc.)  */\n+  ENUM_BITFIELD (bfd_format) format : 3;\n+\n+  /* The direction with which the BFD was opened.  */\n+  ENUM_BITFIELD (bfd_direction) direction : 2;\n+\n   /* Is the file descriptor being cached?  That is, can it be closed as\n      needed, and re-opened when accessed later?  */\n   unsigned int cacheable : 1;\n@@ -6695,7 +6695,7 @@ struct bfd\n \n   /* Symbol table for output BFD (with symcount entries).\n      Also used by the linker to cache input BFD symbols.  */\n-  struct bfd_symbol  **outsymbols;\n+  struct bfd_symbol **outsymbols;\n \n   /* Used for input and output.  */\n   unsigned int symcount;\n@@ -6706,6 +6706,11 @@ struct bfd\n   /* Pointer to structure which contains architecture information.  */\n   const struct bfd_arch_info *arch_info;\n \n+  /* Cached length of file for bfd_get_size.  0 until bfd_get_size is\n+     called, 1 if stat returns an error or the file size is too large to\n+     return in ufile_ptr.  Both 0 and 1 should be treated as \"unknown\".  */\n+  ufile_ptr size;\n+\n   /* Stuff only useful for archives.  */\n   void *arelt_data;\n   struct bfd *my_archive;      /* The containing archive BFD.  */"
    },
    {
      "sha": "463f94bb945ce1816f6442fe9c50c04c46c53413",
      "filename": "bfd/bfd.c",
      "status": "modified",
      "additions": 12,
      "deletions": 7,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd.c?ref=b03202e32c8235997b3485b0b4655926ad97a1cc",
      "patch": "@@ -85,12 +85,6 @@ CODE_FRAGMENT\n .  {* A unique identifier of the BFD  *}\n .  unsigned int id;\n .\n-.  {* The format which belongs to the BFD. (object, core, etc.)  *}\n-.  ENUM_BITFIELD (bfd_format) format : 3;\n-.\n-.  {* The direction with which the BFD was opened.  *}\n-.  ENUM_BITFIELD (bfd_direction) direction : 2;\n-.\n .  {* Format_specific flags.  *}\n .  flagword flags;\n .\n@@ -194,6 +188,12 @@ CODE_FRAGMENT\n .   | BFD_PLUGIN | BFD_TRADITIONAL_FORMAT | BFD_DETERMINISTIC_OUTPUT \\\n .   | BFD_COMPRESS_GABI | BFD_CONVERT_ELF_COMMON | BFD_USE_ELF_STT_COMMON)\n .\n+.  {* The format which belongs to the BFD. (object, core, etc.)  *}\n+.  ENUM_BITFIELD (bfd_format) format : 3;\n+.\n+.  {* The direction with which the BFD was opened.  *}\n+.  ENUM_BITFIELD (bfd_direction) direction : 2;\n+.\n .  {* Is the file descriptor being cached?  That is, can it be closed as\n .     needed, and re-opened when accessed later?  *}\n .  unsigned int cacheable : 1;\n@@ -283,7 +283,7 @@ CODE_FRAGMENT\n .\n .  {* Symbol table for output BFD (with symcount entries).\n .     Also used by the linker to cache input BFD symbols.  *}\n-.  struct bfd_symbol  **outsymbols;\n+.  struct bfd_symbol **outsymbols;\n .\n .  {* Used for input and output.  *}\n .  unsigned int symcount;\n@@ -294,6 +294,11 @@ CODE_FRAGMENT\n .  {* Pointer to structure which contains architecture information.  *}\n .  const struct bfd_arch_info *arch_info;\n .\n+.  {* Cached length of file for bfd_get_size.  0 until bfd_get_size is\n+.     called, 1 if stat returns an error or the file size is too large to\n+.     return in ufile_ptr.  Both 0 and 1 should be treated as \"unknown\".  *}\n+.  ufile_ptr size;\n+.\n .  {* Stuff only useful for archives.  *}\n .  void *arelt_data;\n .  struct bfd *my_archive;      {* The containing archive BFD.  *}"
    },
    {
      "sha": "49e09585264daeb43512a5cc16f02a9f1c434a0c",
      "filename": "bfd/bfdio.c",
      "status": "modified",
      "additions": 19,
      "deletions": 4,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/bfdio.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/bfdio.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfdio.c?ref=b03202e32c8235997b3485b0b4655926ad97a1cc",
      "patch": "@@ -415,17 +415,32 @@ DESCRIPTION\n \tof space for the 15 bazillon byte table it is about to read.\n \tThis function at least allows us to answer the question, \"is the\n \tsize reasonable?\".\n+\n+\tA return value of zero indicates the file size is unknown.\n */\n \n ufile_ptr\n bfd_get_size (bfd *abfd)\n {\n-  struct stat buf;\n+  /* A size of 0 means we haven't yet called bfd_stat.  A size of 1\n+     means we have a cached value of 0, ie. unknown.  */\n+  if (abfd->size <= 1 || bfd_write_p (abfd))\n+    {\n+      struct stat buf;\n \n-  if (bfd_stat (abfd, &buf) != 0)\n-    return 0;\n+      if (abfd->size == 1 && !bfd_write_p (abfd))\n+\treturn 0;\n \n-  return buf.st_size;\n+      if (bfd_stat (abfd, &buf) != 0\n+\t  || buf.st_size == 0\n+\t  || buf.st_size - (ufile_ptr) buf.st_size != 0)\n+\t{\n+\t  abfd->size = 1;\n+\t  return 0;\n+\t}\n+      abfd->size = buf.st_size;\n+    }\n+  return abfd->size;\n }\n \n /*"
    },
    {
      "sha": "796202d31a581bcab7992681ab74bd9f51e812ea",
      "filename": "bfd/opncls.c",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/opncls.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b03202e32c8235997b3485b0b4655926ad97a1cc/bfd/opncls.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/opncls.c?ref=b03202e32c8235997b3485b0b4655926ad97a1cc",
      "patch": "@@ -1209,6 +1209,7 @@ bfd_get_debug_link_info_1 (bfd *abfd, void *crc32_out)\n   unsigned int crc_offset;\n   char *name;\n   bfd_size_type size;\n+  ufile_ptr file_size;\n \n   BFD_ASSERT (abfd);\n   BFD_ASSERT (crc32_out);\n@@ -1219,9 +1220,10 @@ bfd_get_debug_link_info_1 (bfd *abfd, void *crc32_out)\n     return NULL;\n \n   size = bfd_section_size (sect);\n+  file_size = bfd_get_size (abfd);\n \n   /* PR 22794: Make sure that the section has a reasonable size.  */\n-  if (size < 8 || size >= bfd_get_size (abfd))\n+  if (size < 8 || (file_size != 0 && size >= file_size))\n     return NULL;\n \n   if (!bfd_malloc_and_get_section (abfd, sect, &contents))\n@@ -1298,6 +1300,7 @@ bfd_get_alt_debug_link_info (bfd * abfd, bfd_size_type *buildid_len,\n   unsigned int buildid_offset;\n   char *name;\n   bfd_size_type size;\n+  ufile_ptr file_size;\n \n   BFD_ASSERT (abfd);\n   BFD_ASSERT (buildid_len);\n@@ -1309,7 +1312,8 @@ bfd_get_alt_debug_link_info (bfd * abfd, bfd_size_type *buildid_len,\n     return NULL;\n \n   size = bfd_section_size (sect);\n-  if (size < 8 || size >= bfd_get_size (abfd))\n+  file_size = bfd_get_size (abfd);\n+  if (size < 8 || (file_size != 0 && size >= file_size))\n     return NULL;\n \n   if (!bfd_malloc_and_get_section (abfd, sect, & contents))"
    }
  ]
}