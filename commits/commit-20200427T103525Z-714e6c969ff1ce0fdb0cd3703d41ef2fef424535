{
  "sha": "714e6c969ff1ce0fdb0cd3703d41ef2fef424535",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzE0ZTZjOTY5ZmYxY2UwZmRiMGNkMzcwM2Q0MWVmMmZlZjQyNDUzNQ==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-04-27T10:35:25Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-04-27T10:35:25Z"
    },
    "message": "GAS: Allow automatically assigned entries in the file table to be reassigned if the source file specifically requests to use the assigned slot.\n\n\tPR 25878\n\t* dwarf2dbg.c (struct file_entry): Add auto_assigned field.\n\t(assign_file_to_slot): New function.  Fills in an entry in the\n\tfiles table.\n\t(allocate_filenum): Use new function.\n\t(allocate_filename_to_slot): Use new function.  If the specified\n\tslot entry is already in use, but was chosen automatically then\n\treassign the automatic entry.",
    "tree": {
      "sha": "993fe5d1a3ddcbb402591428cc30542028b4ee56",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/993fe5d1a3ddcbb402591428cc30542028b4ee56"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/714e6c969ff1ce0fdb0cd3703d41ef2fef424535",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/714e6c969ff1ce0fdb0cd3703d41ef2fef424535",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/714e6c969ff1ce0fdb0cd3703d41ef2fef424535",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/714e6c969ff1ce0fdb0cd3703d41ef2fef424535/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "25e29062d2c5f1488963ec9997e01886122354f6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/25e29062d2c5f1488963ec9997e01886122354f6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/25e29062d2c5f1488963ec9997e01886122354f6"
    }
  ],
  "stats": {
    "total": 122,
    "additions": 71,
    "deletions": 51
  },
  "files": [
    {
      "sha": "eeeb17dcf0a75ad63233d40db2d46a438981a5ee",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/714e6c969ff1ce0fdb0cd3703d41ef2fef424535/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/714e6c969ff1ce0fdb0cd3703d41ef2fef424535/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=714e6c969ff1ce0fdb0cd3703d41ef2fef424535",
      "patch": "@@ -1,3 +1,14 @@\n+2020-04-27  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR 25878\n+\t* dwarf2dbg.c (struct file_entry): Add auto_assigned field.\n+\t(assign_file_to_slot): New function.  Fills in an entry in the\n+\tfiles table.\n+\t(allocate_filenum): Use new function.\n+\t(allocate_filename_to_slot): Use new function.  If the specified\n+\tslot entry is already in use, but was chosen automatically then\n+\treassign the automatic entry.\n+\n 2020-04-26  Hongtao Liu  <hongtao.liu@intel.com\n \n \t* config/tc-i386.c (lfence_before_ret_shl): New member."
    },
    {
      "sha": "9fdb34f209b918a1436fff6ec0916598904b8e73",
      "filename": "gas/dwarf2dbg.c",
      "status": "modified",
      "additions": 60,
      "deletions": 51,
      "changes": 111,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/714e6c969ff1ce0fdb0cd3703d41ef2fef424535/gas/dwarf2dbg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/714e6c969ff1ce0fdb0cd3703d41ef2fef424535/gas/dwarf2dbg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/dwarf2dbg.c?ref=714e6c969ff1ce0fdb0cd3703d41ef2fef424535",
      "patch": "@@ -206,6 +206,7 @@ struct file_entry\n {\n   const char *   filename;\n   unsigned int   dir;\n+  bfd_boolean    auto_assigned;\n   unsigned char  md5[NUM_MD5_BYTES];\n };\n \n@@ -620,6 +621,36 @@ get_directory_table_entry (const char *  dirname,\n   return d;  \n }\n \n+static bfd_boolean\n+assign_file_to_slot (unsigned long i, const char *file, unsigned int dir, bfd_boolean auto_assign)\n+{\n+  if (i >= files_allocated)\n+    {\n+      unsigned int old = files_allocated;\n+\n+      files_allocated = i + 32;\n+      /* Catch wraparound.  */\n+      if (files_allocated <= old)\n+\t{\n+\t  as_bad (_(\"file number %lu is too big\"), (unsigned long) i);\n+\t  return FALSE;\n+\t}\n+\n+      files = XRESIZEVEC (struct file_entry, files, files_allocated);\n+      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));\n+    }\n+\n+  files[i].filename = file;\n+  files[i].dir = dir;\n+  files[i].auto_assigned = auto_assign;\n+  memset (files[i].md5, 0, NUM_MD5_BYTES);\n+\n+  if (files_in_use < i + 1)\n+    files_in_use = i + 1;\n+\n+  return TRUE;\n+}\n+\n /* Get a .debug_line file number for PATHNAME.  If there is a\n    directory component to PATHNAME, then this will be stored\n    in the directory table, if it is not already present.\n@@ -663,7 +694,7 @@ allocate_filenum (const char * pathname)\n \n   dir = get_directory_table_entry (pathname, dir_len, FALSE);\n \n-  /* Do not use slot-0.  That is specificailly reserved for use by\n+  /* Do not use slot-0.  That is specifically reserved for use by\n      the '.file 0 \"name\"' directive.  */\n   for (i = 1; i < files_in_use; ++i)\n     if (files[i].dir == dir\n@@ -675,28 +706,9 @@ allocate_filenum (const char * pathname)\n \treturn i;\n       }\n \n-  if (i >= files_allocated)\n-    {\n-      unsigned int old = files_allocated;\n-\n-      files_allocated = i + 32;\n-      /* Catch wraparound.  */\n-      if (files_allocated <= old)\n-\t{\n-\t  as_bad (_(\"file number %lu is too big\"), (unsigned long) i);\n-\t  return -1;\n-\t}\n-\n-      files = XRESIZEVEC (struct file_entry, files, files_allocated);\n-      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));\n-    }\n-\n-  files[i].filename = file;\n-  files[i].dir = dir;\n-  memset (files[i].md5, 0, NUM_MD5_BYTES);\n+  if (!assign_file_to_slot (i, file, dir, TRUE))\n+    return -1;\n \n-  if (files_in_use < i + 1)\n-    files_in_use = i + 1;  \n   last_used = i;\n   last_used_dir_len = dir_len;\n \n@@ -769,15 +781,30 @@ allocate_filename_to_slot (const char *  dirname,\n \t}\n \n     fail:\n-      as_bad (_(\"file table slot %u is already occupied by a different file (%s%s%s vs %s%s%s)\"),\n-\t      num,\n-\t      dir == NULL ? \"\" : dir,\n-\t      dir == NULL ? \"\" : \"/\",\n-\t      files[num].filename,\n-\t      dirname == NULL ? \"\" : dirname,\n-\t      dirname == NULL ? \"\" : \"/\",\n-\t      filename);\n-      return FALSE;\n+      /* If NUM was previously allocated automatically then\n+\t choose another slot for it, so that we can reuse NUM.  */\n+      if (files[num].auto_assigned)\n+\t{\n+\t  /* Find an unused slot.  */\n+\t  for (i = 1; i < files_in_use; ++i)\n+\t    if (files[i].filename == NULL)\n+\t      break;\n+\t  if (! assign_file_to_slot (i, files[num].filename, files[num].dir, TRUE))\n+\t    return FALSE;\n+\t  files[num].filename = NULL;\n+\t}\n+      else\n+\t{\n+\t  as_bad (_(\"file table slot %u is already occupied by a different file (%s%s%s vs %s%s%s)\"),\n+\t\t  num,\n+\t\t  dir == NULL ? \"\" : dir,\n+\t\t  dir == NULL ? \"\" : \"/\",\n+\t\t  files[num].filename,\n+\t\t  dirname == NULL ? \"\" : dirname,\n+\t\t  dirname == NULL ? \"\" : \"/\",\n+\t\t  filename);\n+\t  return FALSE;\n+\t}\n     }\n \n   if (dirname == NULL)\n@@ -795,24 +822,9 @@ allocate_filename_to_slot (const char *  dirname,\n   d = get_directory_table_entry (dirname, dirlen, num == 0);\n   i = num;\n \n-  if (i >= files_allocated)\n-    {\n-      unsigned int old = files_allocated;\n-\n-      files_allocated = i + 32;\n-      /* Catch wraparound.  */\n-      if (files_allocated <= old)\n-\t{\n-\t  as_bad (_(\"file number %lu is too big\"), (unsigned long) i);\n-\t  return FALSE;\n-\t}\n-\n-      files = XRESIZEVEC (struct file_entry, files, files_allocated);\n-      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));\n-    }\n+  if (! assign_file_to_slot (i, file, d, FALSE))\n+    return FALSE;\n \n-  files[i].filename = file;\n-  files[i].dir = d;\n   if (with_md5)\n     {\n       if (target_big_endian)\n@@ -863,9 +875,6 @@ allocate_filename_to_slot (const char *  dirname,\n   else\n     memset (files[i].md5, 0, NUM_MD5_BYTES);\n \n-  if (files_in_use < i + 1)\n-    files_in_use = i + 1;\n-\n   return TRUE;\n }\n "
    }
  ]
}