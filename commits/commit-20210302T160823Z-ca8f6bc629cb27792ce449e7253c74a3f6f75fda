{
  "sha": "ca8f6bc629cb27792ce449e7253c74a3f6f75fda",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2E4ZjZiYzYyOWNiMjc3OTJjZTQ0OWU3MjUzYzc0YTNmNmY3NWZkYQ==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-03-02T16:08:23Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-03-02T16:08:23Z"
    },
    "message": "Fix the BFD library's parsing of DIEs where specification attributes can refer to variables that are defined later on.\n\n\tPR 27484\n\t* dwarf2.c (scan_unit_for_symbols): Scan twice, once to accumulate\n\tfunction and variable tags and a second time to resolve their\n\tattributes.",
    "tree": {
      "sha": "e299aa4b18780df60bdf9bde1d685276b7be0167",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e299aa4b18780df60bdf9bde1d685276b7be0167"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ca8f6bc629cb27792ce449e7253c74a3f6f75fda",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ca8f6bc629cb27792ce449e7253c74a3f6f75fda",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ca8f6bc629cb27792ce449e7253c74a3f6f75fda",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ca8f6bc629cb27792ce449e7253c74a3f6f75fda/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "211bcd013331fcaefa9bb31b6145ae0df13a3363",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/211bcd013331fcaefa9bb31b6145ae0df13a3363",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/211bcd013331fcaefa9bb31b6145ae0df13a3363"
    }
  ],
  "stats": {
    "total": 140,
    "additions": 114,
    "deletions": 26
  },
  "files": [
    {
      "sha": "a056a146288b8d4ff2a5ddb1841796787e7b49bc",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ca8f6bc629cb27792ce449e7253c74a3f6f75fda/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ca8f6bc629cb27792ce449e7253c74a3f6f75fda/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=ca8f6bc629cb27792ce449e7253c74a3f6f75fda",
      "patch": "@@ -1,3 +1,10 @@\n+2021-03-02  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR 27484\n+\t* dwarf2.c (scan_unit_for_symbols): Scan twice, once to accumulate\n+\tfunction and variable tags and a second time to resolve their\n+\tattributes.\n+\n 2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* elf-strtab.c (_bfd_elf_strtab_str): Skip strings with zero refcount."
    },
    {
      "sha": "c0fb956e686fc5eea8b6cd3f1eacd24cd100e560",
      "filename": "bfd/dwarf2.c",
      "status": "modified",
      "additions": 107,
      "deletions": 26,
      "changes": 133,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ca8f6bc629cb27792ce449e7253c74a3f6f75fda/bfd/dwarf2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ca8f6bc629cb27792ce449e7253c74a3f6f75fda/bfd/dwarf2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf2.c?ref=ca8f6bc629cb27792ce449e7253c74a3f6f75fda",
      "patch": "@@ -1484,6 +1484,8 @@ struct funcinfo\n   struct arange\t\tarange;\n   /* Where the symbol is defined.  */\n   asection *\t\tsec;\n+  /* The offset of the funcinfo from the start of the unit.  */\n+  bfd_uint64_t          unit_offset;\n };\n \n struct lookup_funcinfo\n@@ -3304,6 +3306,15 @@ read_rangelist (struct comp_unit *unit, struct arange *arange,\n     return read_rnglists (unit, arange, offset);\n }\n \n+static struct funcinfo *\n+lookup_func_by_offset (bfd_uint64_t offset, struct funcinfo * table)\n+{\n+  for (; table != NULL; table = table->prev_func)\n+    if (table->unit_offset == offset)\n+      return table;\n+  return NULL;\n+}\n+\n static struct varinfo *\n lookup_var_by_offset (bfd_uint64_t offset, struct varinfo * table)\n {\n@@ -3330,7 +3341,8 @@ scan_unit_for_symbols (struct comp_unit *unit)\n   bfd_byte *info_ptr = unit->first_child_die_ptr;\n   bfd_byte *info_ptr_end = unit->end_ptr;\n   int nesting_level = 0;\n-  struct nest_funcinfo {\n+  struct nest_funcinfo\n+  {\n     struct funcinfo *func;\n   } *nested_funcs;\n   int nested_funcs_size;\n@@ -3344,16 +3356,16 @@ scan_unit_for_symbols (struct comp_unit *unit)\n     return FALSE;\n   nested_funcs[nesting_level].func = 0;\n \n+  /* PR 27484: We must scan the DIEs twice.  The first time we look for\n+     function and variable tags and accumulate them into their respective\n+     tables.  The second time through we process the attributes of the\n+     functions/variables and augment the table entries.  */\n   while (nesting_level >= 0)\n     {\n       unsigned int abbrev_number, bytes_read, i;\n       struct abbrev_info *abbrev;\n-      struct attribute attr;\n       struct funcinfo *func;\n       struct varinfo *var;\n-      bfd_vma low_pc = 0;\n-      bfd_vma high_pc = 0;\n-      bfd_boolean high_pc_relative = FALSE;\n       bfd_uint64_t current_offset;\n \n       /* PR 17512: file: 9f405d9d.  */\n@@ -3365,7 +3377,7 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t\t\t\t\t     FALSE, info_ptr_end);\n       info_ptr += bytes_read;\n \n-      if (! abbrev_number)\n+      if (abbrev_number == 0)\n \t{\n \t  nesting_level--;\n \t  continue;\n@@ -3400,6 +3412,7 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t    goto fail;\n \t  func->tag = abbrev->tag;\n \t  func->prev_func = unit->function_table;\n+\t  func->unit_offset = current_offset;\n \t  unit->function_table = func;\n \t  unit->number_of_functions++;\n \t  BFD_ASSERT (!unit->cached);\n@@ -3420,6 +3433,7 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t      || abbrev->tag == DW_TAG_member)\n \t    {\n \t      size_t amt = sizeof (struct varinfo);\n+\n \t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n \t      if (var == NULL)\n \t\tgoto fail;\n@@ -3438,6 +3452,89 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t  nested_funcs[nesting_level].func = 0;\n \t}\n \n+      for (i = 0; i < abbrev->num_attrs; ++i)\n+\t{\n+\t  struct attribute attr;\n+\n+\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n+\t\t\t\t     unit, info_ptr, info_ptr_end);\n+\t  if (info_ptr == NULL)\n+\t    goto fail;\n+\t}\n+\n+      if (abbrev->has_children)\n+\t{\n+\t  nesting_level++;\n+\n+\t  if (nesting_level >= nested_funcs_size)\n+\t    {\n+\t      struct nest_funcinfo *tmp;\n+\n+\t      nested_funcs_size *= 2;\n+\t      tmp = (struct nest_funcinfo *)\n+\t\tbfd_realloc (nested_funcs,\n+\t\t\t     nested_funcs_size * sizeof (*nested_funcs));\n+\t      if (tmp == NULL)\n+\t\tgoto fail;\n+\t      nested_funcs = tmp;\n+\t    }\n+\t  nested_funcs[nesting_level].func = 0;\n+\t}\n+    }\n+\n+  /* This is the second pass over the abbrevs.  */      \n+  info_ptr = unit->first_child_die_ptr;\n+  nesting_level = 0;\n+  \n+  while (nesting_level >= 0)\n+    {\n+      unsigned int abbrev_number, bytes_read, i;\n+      struct abbrev_info *abbrev;\n+      struct attribute attr;\n+      struct funcinfo *func;\n+      struct varinfo *var;\n+      bfd_vma low_pc = 0;\n+      bfd_vma high_pc = 0;\n+      bfd_boolean high_pc_relative = FALSE;\n+      bfd_uint64_t current_offset;\n+\n+      /* PR 17512: file: 9f405d9d.  */\n+      if (info_ptr >= info_ptr_end)\n+\tgoto fail;\n+\n+      current_offset = info_ptr - unit->info_ptr_unit;\n+      abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n+\t\t\t\t\t     FALSE, info_ptr_end);\n+      info_ptr += bytes_read;\n+\n+      if (! abbrev_number)\n+\t{\n+\t  nesting_level--;\n+\t  continue;\n+\t}\n+\n+      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n+      /* This should have been handled above.  */\n+      BFD_ASSERT (abbrev != NULL);\n+\n+      func = NULL;\n+      var = NULL;\n+      if (abbrev->tag == DW_TAG_subprogram\n+\t  || abbrev->tag == DW_TAG_entry_point\n+\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n+\t{\n+\t  func = lookup_func_by_offset (current_offset, unit->function_table);\n+\t  if (func == NULL)\n+\t    goto fail;\n+\t}\n+      else if (abbrev->tag == DW_TAG_variable\n+\t       || abbrev->tag == DW_TAG_member)\n+\t{\n+\t  var = lookup_var_by_offset (current_offset, unit->variable_table);\n+\t  if (var == NULL)\n+\t    goto fail;\n+\t}\n+\n       for (i = 0; i < abbrev->num_attrs; ++i)\n \t{\n \t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n@@ -3532,7 +3629,7 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t\t\t{\n \t\t\t  _bfd_error_handler (_(\"DWARF error: could not find \"\n \t\t\t\t\t\t\"variable specification \"\n-\t\t\t\t\t\t\"at offset %lx\"),\n+\t\t\t\t\t\t\"at offset 0x%lx\"),\n \t\t\t\t\t      (unsigned long) attr.u.val);\n \t\t\t  break;\n \t\t\t}\n@@ -3604,6 +3701,9 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t    }\n \t}\n \n+      if (abbrev->has_children)\n+\tnesting_level++;\n+\n       if (high_pc_relative)\n \thigh_pc += low_pc;\n \n@@ -3612,25 +3712,6 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t  if (!arange_add (unit, &func->arange, low_pc, high_pc))\n \t    goto fail;\n \t}\n-\n-      if (abbrev->has_children)\n-\t{\n-\t  nesting_level++;\n-\n-\t  if (nesting_level >= nested_funcs_size)\n-\t    {\n-\t      struct nest_funcinfo *tmp;\n-\n-\t      nested_funcs_size *= 2;\n-\t      tmp = (struct nest_funcinfo *)\n-\t\tbfd_realloc (nested_funcs,\n-\t\t\t     nested_funcs_size * sizeof (*nested_funcs));\n-\t      if (tmp == NULL)\n-\t\tgoto fail;\n-\t      nested_funcs = tmp;\n-\t    }\n-\t  nested_funcs[nesting_level].func = 0;\n-\t}\n     }\n \n   free (nested_funcs);"
    }
  ]
}