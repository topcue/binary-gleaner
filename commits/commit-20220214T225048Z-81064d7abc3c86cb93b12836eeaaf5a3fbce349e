{
  "sha": "81064d7abc3c86cb93b12836eeaaf5a3fbce349e",
  "node_id": "C_kwDOANOeidoAKDgxMDY0ZDdhYmMzYzg2Y2I5M2IxMjgzNmVlYWFmNWEzZmJjZTM0OWU",
  "commit": {
    "author": {
      "name": "Hans-Peter Nilsson",
      "email": "hp@axis.com",
      "date": "2022-02-14T22:50:48Z"
    },
    "committer": {
      "name": "Hans-Peter Nilsson",
      "email": "hp@bitrange.com",
      "date": "2022-02-14T22:50:48Z"
    },
    "message": "sim/testsuite: Support \"requires: simoption <--name-of-option>\"\n\nSimulator features can be present or not, typically\ndepending on different-valued configure options, like\n--enable-sim-hardware[=off|=on].  To avoid failures in\ntest-suite-runs when testing such configurations, a new\npredicate is needed, as neither \"target\", \"progos\" nor\n\"mach\" fits cleanly.\n\nThe immediate need was to check for presence of a simulator\noption, but rather than a specialized \"requires-simoption:\"\npredicate I thought I'd handle the general (parametrized)\nneed, so here's a generic predicate machinery and a (first)\npredicate to use together with it; checking whether a\nparticular option is supported, by looking at \"run --help\"\noutput.  This was inspired by the check_effective_target_\nmachinery in the gcc test-suite.\n\nMultiple \"requires: <requirement> <parameter>\" form a list of\npredicates (with parameters), to be used as a conjunction.\n\nsim/testsuite:\n\t* lib/sim-defs.exp (sim_check_requires_simoption): New function.\n\t(run_sim_test): Support \"requires: <requirement> <parameter>\".",
    "tree": {
      "sha": "794710802cf21bacedf2c94cb692a3d6752dde3d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/794710802cf21bacedf2c94cb692a3d6752dde3d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/81064d7abc3c86cb93b12836eeaaf5a3fbce349e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/81064d7abc3c86cb93b12836eeaaf5a3fbce349e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/81064d7abc3c86cb93b12836eeaaf5a3fbce349e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/81064d7abc3c86cb93b12836eeaaf5a3fbce349e/comments",
  "author": {
    "login": "hpataxisdotcom",
    "id": 80339731,
    "node_id": "MDQ6VXNlcjgwMzM5NzMx",
    "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hpataxisdotcom",
    "html_url": "https://github.com/hpataxisdotcom",
    "followers_url": "https://api.github.com/users/hpataxisdotcom/followers",
    "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}",
    "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions",
    "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs",
    "repos_url": "https://api.github.com/users/hpataxisdotcom/repos",
    "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": null,
  "parents": [
    {
      "sha": "46f238477f5e83cba9dc79d1e14c0f6acbeda37b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/46f238477f5e83cba9dc79d1e14c0f6acbeda37b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/46f238477f5e83cba9dc79d1e14c0f6acbeda37b"
    }
  ],
  "stats": {
    "total": 60,
    "additions": 60,
    "deletions": 0
  },
  "files": [
    {
      "sha": "d2750e08b0468accd53433c9966e85706ba83a36",
      "filename": "sim/testsuite/lib/sim-defs.exp",
      "status": "modified",
      "additions": 60,
      "deletions": 0,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/81064d7abc3c86cb93b12836eeaaf5a3fbce349e/sim/testsuite/lib/sim-defs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/81064d7abc3c86cb93b12836eeaaf5a3fbce349e/sim/testsuite/lib/sim-defs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/testsuite/lib/sim-defs.exp?ref=81064d7abc3c86cb93b12836eeaaf5a3fbce349e",
      "patch": "@@ -261,6 +261,41 @@ proc sim_run { prog sim_opts prog_opts redir options } {\n     return [list $return_code $output]\n }\n \n+# Support function for \"#requires: simoption <xx>\":\n+# Looks in \"run --help\" output for <xx>, returns 1 iff <xx> is mentioned\n+# there and looks like an option name, otherwise 0.\n+\n+proc sim_check_requires_simoption { optname } {\n+    global sim_path\n+    set testrun \"$sim_path --help\"\n+    verbose -log \"Checking for simoption `$optname'\" 3\n+    remote_spawn host $testrun\n+    set result [remote_wait host 240]\n+\n+    set return_code [lindex $result 0]\n+    if { $return_code != 0 } {\n+\tperror \"Can't execute `$testrun' to check for `$optname'\"\n+\treturn 0\n+    }\n+\n+    set output [lindex $result 1]\n+    # Remove \\r as for regular runs.\n+    regsub -all -- \"\\r\" $output \"\" output\n+\n+    # The option output format for --help for each line where an\n+    # option name is mentioned, is assumed to be two space followed\n+    # by the option name followed by a space or left square bracket,\n+    # like in (optname=--foo): \"  --foo \" or \"  --foo[this|that]\".\n+    # Beware not to match \"  --foo-bar\" nor \"  --foobar\".\n+    if [string match \"*\\n  $optname\\[\\[ \\]*\" $output] {\n+\tverbose -log \"Found `$optname'\" 3\n+\treturn 1\n+    }\n+    verbose -log \"Did not find `$optname'\" 3\n+\n+    return 0\n+}\n+\n # Run testcase NAME.\n # NAME is either a fully specified file name, or just the file name in which\n # case $srcdir/$subdir will be prepended.\n@@ -326,6 +361,7 @@ proc run_sim_test { name requested_machs } {\n     set opts(cc) \"\"\n     set opts(progopts) \"\"\n     set opts(progos) \"\"\n+    set opts(requires) {}\n     set opts(sim) \"\"\n     set opts(status) \"0\"\n     set opts(output) \"\"\n@@ -375,6 +411,14 @@ proc run_sim_test { name requested_machs } {\n \t    set opt_val \"$opts($opt_name) $opt_val\"\n \t}\n \n+\t# Similar for \"requires\", except we append a pair to a list, and\n+\t# that doesn't match the processing in the rest of the loop, so we\n+\t# \"continue\" early.\n+\tif { $opt_name == \"requires\" } {\n+\t    lappend opts($opt_name) [split $opt_val \" \"]\n+\t    continue\n+\t}\n+\n \tforeach m $opt_machs {\n \t    set opts($opt_name,$m) $opt_val\n \t}\n@@ -449,6 +493,22 @@ proc run_sim_test { name requested_machs } {\n \t    set opts(cc,$mach) $opts(cc)\n \t}\n \n+\tforeach req $opts(requires) {\n+\t    set what [lindex $req 0]\n+\t    set what_opt [lindex $req 1]\n+\t    verbose -log \"requires: <$what> <$what_opt>\"\n+\t    if { [info procs sim_check_requires_${what}] != [list] } {\n+\t\tif ![sim_check_requires_${what} $what_opt] {\n+\t\t    untested $subdir/$name\n+\t\t    return\n+\t\t}\n+\t    } {\n+\t\tperror \"unknown requirement `requires: $what' in file $file\"\n+\t\tunresolved $subdir/$name\n+\t\treturn\n+\t    }\n+\t}\n+\n \tif [string match \"*.c\" $sourcefile] {\n \t    # If we don't have a compiler available, skip tests :(.\n \t    if { $global_cc_works == 0 } {"
    }
  ]
}