{
  "sha": "8ca9c7eb6773dd3cc9c536787b3489d36356ccf7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGNhOWM3ZWI2NzczZGQzY2M5YzUzNjc4N2IzNDg5ZDM2MzU2Y2NmNw==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2021-01-14T13:23:58Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2021-01-14T13:24:10Z"
    },
    "message": "bfin: Skip non SEC_ALLOC section for R_BFIN_FUNCDESC\n\nLinker should never generate dynamic relocations for relocations in\nnon-SEC_ALLOC section which has no impact on run-time behavior.  Such\nrelocations should be resolved to 0.\n\n\tPR ld/26688\n\t* elf32-bfin.c (bfinfdpic_relocate_section): Skip non SEC_ALLOC\n\tsection for R_BFIN_FUNCDESC.",
    "tree": {
      "sha": "3084a04974633d66d8cd28c05682d67f203ada12",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3084a04974633d66d8cd28c05682d67f203ada12"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8ca9c7eb6773dd3cc9c536787b3489d36356ccf7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ca9c7eb6773dd3cc9c536787b3489d36356ccf7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8ca9c7eb6773dd3cc9c536787b3489d36356ccf7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ca9c7eb6773dd3cc9c536787b3489d36356ccf7/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5a10699ff38a272864067da46a3cb349d072c16c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5a10699ff38a272864067da46a3cb349d072c16c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5a10699ff38a272864067da46a3cb349d072c16c"
    }
  ],
  "stats": {
    "total": 241,
    "additions": 124,
    "deletions": 117
  },
  "files": [
    {
      "sha": "db49d6fdcd3505e7bdda97798646dcc6a4a6470a",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ca9c7eb6773dd3cc9c536787b3489d36356ccf7/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ca9c7eb6773dd3cc9c536787b3489d36356ccf7/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=8ca9c7eb6773dd3cc9c536787b3489d36356ccf7",
      "patch": "@@ -1,3 +1,9 @@\n+2021-01-14  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR ld/26688\n+\t* elf32-bfin.c (bfinfdpic_relocate_section): Skip non SEC_ALLOC\n+\tsection for R_BFIN_FUNCDESC.\n+\n 2021-01-14  Nick Clifton  <nickc@redhat.com>\n \n \t* elf.c (elfcore_grok_win32pstatus): Check for a note type of 0."
    },
    {
      "sha": "401683c536792ab1156dd941eca2631b027b8ba2",
      "filename": "bfd/elf32-bfin.c",
      "status": "modified",
      "additions": 118,
      "deletions": 117,
      "changes": 235,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ca9c7eb6773dd3cc9c536787b3489d36356ccf7/bfd/elf32-bfin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ca9c7eb6773dd3cc9c536787b3489d36356ccf7/bfd/elf32-bfin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-bfin.c?ref=8ca9c7eb6773dd3cc9c536787b3489d36356ccf7",
      "patch": "@@ -2727,129 +2727,130 @@ bfinfdpic_relocate_section (bfd * output_bfd,\n \t  break;\n \n \tcase R_BFIN_FUNCDESC:\n-\t  {\n-\t    int dynindx;\n-\t    bfd_vma addend = rel->r_addend;\n-\n-\t    if (! (h && h->root.type == bfd_link_hash_undefweak\n-\t\t   && BFINFDPIC_SYM_LOCAL (info, h)))\n-\t      {\n-\t\t/* If the symbol is dynamic and there may be dynamic\n-\t\t   symbol resolution because we are or are linked with a\n-\t\t   shared library, emit a FUNCDESC relocation such that\n-\t\t   the dynamic linker will allocate the function\n-\t\t   descriptor.  If the symbol needs a non-local function\n-\t\t   descriptor but binds locally (e.g., its visibility is\n-\t\t   protected, emit a dynamic relocation decayed to\n-\t\t   section+offset.  */\n-\t\tif (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h)\n-\t\t    && BFINFDPIC_SYM_LOCAL (info, h)\n-\t\t    && !bfd_link_pde (info))\n-\t\t  {\n-\t\t    dynindx = elf_section_data (h->root.u.def.section\n-\t\t\t\t\t\t->output_section)->dynindx;\n-\t\t    addend += h->root.u.def.section->output_offset\n-\t\t      + h->root.u.def.value;\n-\t\t  }\n-\t\telse if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h))\n-\t\t  {\n-\t\t    if (addend)\n-\t\t      {\n-\t\t\tinfo->callbacks->warning\n-\t\t\t  (info, _(\"R_BFIN_FUNCDESC references dynamic symbol with nonzero addend\"),\n-\t\t\t   name, input_bfd, input_section, rel->r_offset);\n-\t\t\treturn FALSE;\n-\t\t      }\n-\t\t    dynindx = h->dynindx;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    /* Otherwise, we know we have a private function\n-\t\t       descriptor, so reference it directly.  */\n-\t\t    BFD_ASSERT (picrel->privfd);\n-\t\t    r_type = R_BFIN_BYTE4_DATA;\n-\t\t    dynindx = elf_section_data (bfinfdpic_got_section (info)\n-\t\t\t\t\t\t->output_section)->dynindx;\n-\t\t    addend = bfinfdpic_got_section (info)->output_offset\n-\t\t      + bfinfdpic_got_initial_offset (info)\n-\t\t      + picrel->fd_entry;\n-\t\t  }\n-\n-\t\t/* If there is room for dynamic symbol resolution, emit\n-\t\t   the dynamic relocation.  However, if we're linking an\n-\t\t   executable at a fixed location, we won't have emitted a\n-\t\t   dynamic symbol entry for the got section, so idx will\n-\t\t   be zero, which means we can and should compute the\n-\t\t   address of the private descriptor ourselves.  */\n-\t\tif (bfd_link_pde (info)\n-\t\t    && (!h || BFINFDPIC_FUNCDESC_LOCAL (info, h)))\n-\t\t  {\n-\t\t    bfd_vma offset;\n-\n-\t\t    addend += bfinfdpic_got_section (info)->output_section->vma;\n-\t\t    if ((bfd_section_flags (input_section->output_section)\n-\t\t\t & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n-\t\t      {\n-\t\t\tif (_bfinfdpic_osec_readonly_p (output_bfd,\n-\t\t\t\t\t\t       input_section\n-\t\t\t\t\t\t       ->output_section))\n-\t\t\t  {\n-\t\t\t    info->callbacks->warning\n-\t\t\t      (info,\n-\t\t\t       _(\"cannot emit fixups in read-only section\"),\n-\t\t\t       name, input_bfd, input_section, rel->r_offset);\n-\t\t\t    return FALSE;\n-\t\t\t  }\n+\t  if ((input_section->flags & SEC_ALLOC) != 0)\n+\t    {\n+\t      int dynindx;\n+\t      bfd_vma addend = rel->r_addend;\n \n-\t\t\toffset = _bfd_elf_section_offset\n-\t\t\t  (output_bfd, info,\n-\t\t\t   input_section, rel->r_offset);\n+\t      if (! (h && h->root.type == bfd_link_hash_undefweak\n+\t\t     && BFINFDPIC_SYM_LOCAL (info, h)))\n+\t\t{\n+\t\t  /* If the symbol is dynamic and there may be dynamic\n+\t\t     symbol resolution because we are or are linked with a\n+\t\t     shared library, emit a FUNCDESC relocation such that\n+\t\t     the dynamic linker will allocate the function\n+\t\t     descriptor.  If the symbol needs a non-local function\n+\t\t     descriptor but binds locally (e.g., its visibility is\n+\t\t     protected, emit a dynamic relocation decayed to\n+\t\t     section+offset.  */\n+\t\t  if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h)\n+\t\t      && BFINFDPIC_SYM_LOCAL (info, h)\n+\t\t      && !bfd_link_pde (info))\n+\t\t    {\n+\t\t      dynindx = elf_section_data (h->root.u.def.section\n+\t\t\t\t\t\t  ->output_section)->dynindx;\n+\t\t      addend += h->root.u.def.section->output_offset\n+\t\t\t+ h->root.u.def.value;\n+\t\t    }\n+\t\t  else if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h))\n+\t\t    {\n+\t\t      if (addend)\n+\t\t\t{\n+\t\t\t  info->callbacks->warning\n+\t\t\t    (info, _(\"R_BFIN_FUNCDESC references dynamic symbol with nonzero addend\"),\n+\t\t\t     name, input_bfd, input_section, rel->r_offset);\n+\t\t\t  return FALSE;\n+\t\t\t}\n+\t\t      dynindx = h->dynindx;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* Otherwise, we know we have a private function\n+\t\t\t descriptor, so reference it directly.  */\n+\t\t      BFD_ASSERT (picrel->privfd);\n+\t\t      r_type = R_BFIN_BYTE4_DATA;\n+\t\t      dynindx = elf_section_data (bfinfdpic_got_section (info)\n+\t\t\t\t\t\t  ->output_section)->dynindx;\n+\t\t      addend = bfinfdpic_got_section (info)->output_offset\n+\t\t\t+ bfinfdpic_got_initial_offset (info)\n+\t\t\t+ picrel->fd_entry;\n+\t\t    }\n \n-\t\t\tif (offset != (bfd_vma)-1)\n-\t\t\t  _bfinfdpic_add_rofixup (output_bfd,\n-\t\t\t\t\t\t  bfinfdpic_gotfixup_section\n-\t\t\t\t\t\t  (info),\n+\t\t  /* If there is room for dynamic symbol resolution, emit\n+\t\t     the dynamic relocation.  However, if we're linking an\n+\t\t     executable at a fixed location, we won't have emitted a\n+\t\t     dynamic symbol entry for the got section, so idx will\n+\t\t     be zero, which means we can and should compute the\n+\t\t     address of the private descriptor ourselves.  */\n+\t\t  if (bfd_link_pde (info)\n+\t\t      && (!h || BFINFDPIC_FUNCDESC_LOCAL (info, h)))\n+\t\t    {\n+\t\t      bfd_vma offset;\n+\n+\t\t      addend += bfinfdpic_got_section (info)->output_section->vma;\n+\t\t      if ((bfd_section_flags (input_section->output_section)\n+\t\t\t   & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n+\t\t\t{\n+\t\t\t  if (_bfinfdpic_osec_readonly_p (output_bfd,\n+\t\t\t\t\t\t\t  input_section\n+\t\t\t\t\t\t\t  ->output_section))\n+\t\t\t    {\n+\t\t\t      info->callbacks->warning\n+\t\t\t\t(info,\n+\t\t\t\t _(\"cannot emit fixups in read-only section\"),\n+\t\t\t\t name, input_bfd, input_section, rel->r_offset);\n+\t\t\t      return FALSE;\n+\t\t\t    }\n+\n+\t\t\t  offset = _bfd_elf_section_offset\n+\t\t\t    (output_bfd, info,\n+\t\t\t     input_section, rel->r_offset);\n+\n+\t\t\t  if (offset != (bfd_vma)-1)\n+\t\t\t    _bfinfdpic_add_rofixup (output_bfd,\n+\t\t\t\t\t\t    bfinfdpic_gotfixup_section\n+\t\t\t\t\t\t    (info),\n+\t\t\t\t\t\t    offset + input_section\n+\t\t\t\t\t\t    ->output_section->vma\n+\t\t\t\t\t\t    + input_section->output_offset,\n+\t\t\t\t\t\t    picrel);\n+\t\t\t}\n+\t\t    }\n+\t\t  else if ((bfd_section_flags (input_section->output_section)\n+\t\t\t    & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n+\t\t    {\n+\t\t      bfd_vma offset;\n+\n+\t\t      if (_bfinfdpic_osec_readonly_p (output_bfd,\n+\t\t\t\t\t\t      input_section\n+\t\t\t\t\t\t      ->output_section))\n+\t\t\t{\n+\t\t\t  info->callbacks->warning\n+\t\t\t    (info,\n+\t\t\t     _(\"cannot emit dynamic relocations in read-only section\"),\n+\t\t\t     name, input_bfd, input_section, rel->r_offset);\n+\t\t\t  return FALSE;\n+\t\t\t}\n+\t\t      offset = _bfd_elf_section_offset (output_bfd, info,\n+\t\t\t\t\t\t\tinput_section, rel->r_offset);\n+\n+\t\t      if (offset != (bfd_vma)-1)\n+\t\t\t_bfinfdpic_add_dyn_reloc (output_bfd,\n+\t\t\t\t\t\t  bfinfdpic_gotrel_section (info),\n \t\t\t\t\t\t  offset + input_section\n \t\t\t\t\t\t  ->output_section->vma\n \t\t\t\t\t\t  + input_section->output_offset,\n-\t\t\t\t\t\t  picrel);\n-\t\t      }\n-\t\t  }\n-\t\telse if ((bfd_section_flags (input_section->output_section)\n-\t\t\t  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n-\t\t  {\n-\t\t    bfd_vma offset;\n-\n-\t\t    if (_bfinfdpic_osec_readonly_p (output_bfd,\n-\t\t\t\t\t\t   input_section\n-\t\t\t\t\t\t   ->output_section))\n-\t\t      {\n-\t\t\tinfo->callbacks->warning\n-\t\t\t  (info,\n-\t\t\t   _(\"cannot emit dynamic relocations in read-only section\"),\n-\t\t\t   name, input_bfd, input_section, rel->r_offset);\n-\t\t\treturn FALSE;\n-\t\t      }\n-\t\t    offset = _bfd_elf_section_offset (output_bfd, info,\n-\t\t\t\t\t\t      input_section, rel->r_offset);\n-\n-\t\t    if (offset != (bfd_vma)-1)\n-\t\t      _bfinfdpic_add_dyn_reloc (output_bfd,\n-\t\t\t\t\t\tbfinfdpic_gotrel_section (info),\n-\t\t\t\t\t\toffset + input_section\n-\t\t\t\t\t\t->output_section->vma\n-\t\t\t\t\t\t+ input_section->output_offset,\n-\t\t\t\t\t\tr_type,\n-\t\t\t\t\t\tdynindx, addend, picrel);\n-\t\t  }\n-\t\telse\n-\t\t  addend += bfinfdpic_got_section (info)->output_section->vma;\n-\t      }\n+\t\t\t\t\t\t  r_type,\n+\t\t\t\t\t\t  dynindx, addend, picrel);\n+\t\t    }\n+\t\t  else\n+\t\t    addend += bfinfdpic_got_section (info)->output_section->vma;\n+\t\t}\n \n-\t    /* We want the addend in-place because dynamic\n-\t       relocations are REL.  Setting relocation to it should\n-\t       arrange for it to be installed.  */\n-\t    relocation = addend - rel->r_addend;\n+\t      /* We want the addend in-place because dynamic\n+\t\t relocations are REL.  Setting relocation to it should\n+\t\t arrange for it to be installed.  */\n+\t      relocation = addend - rel->r_addend;\n \t  }\n \t  check_segment[0] = check_segment[1] = got_segment;\n \t  break;"
    }
  ]
}