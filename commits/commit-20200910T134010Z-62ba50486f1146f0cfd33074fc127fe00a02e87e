{
  "sha": "62ba50486f1146f0cfd33074fc127fe00a02e87e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjJiYTUwNDg2ZjExNDZmMGNmZDMzMDc0ZmMxMjdmZTAwYTAyZTg3ZQ==",
  "commit": {
    "author": {
      "name": "Kamil Rytarowski",
      "email": "n54@gmx.com",
      "date": "2020-09-02T17:35:42Z"
    },
    "committer": {
      "name": "Kamil Rytarowski",
      "email": "n54@gmx.com",
      "date": "2020-09-10T13:40:10Z"
    },
    "message": "Add minimal and functional NetBSD/amd64 gdbserver\n\nImplement the following functionality: create_inferior,\npost_create_inferior, attach, kill, detach, mourn, join, thread_alive,\nresume, wait, fetch_registers, store_registers, read_memory, write_memory,\nrequest_interrupt, supports_read_auxv, read_auxv,\nsupports_hardware_single_step, sw_breakpoint_from_kind,\nsupports_z_point_type, insert_point, remove_point,\nstopped_by_sw_breakpoint, supports_qxfer_siginfo, qxfer_siginfo,\nsupports_stopped_by_sw_breakpoint, supports_non_stop,\nsupports_multi_process, supports_fork_events, supports_vfork_events,\nsupports_exec_events, supports_disable_randomization,\nsupports_qxfer_libraries_svr4, qxfer_libraries_svr4,\nsupports_pid_to_exec_file, pid_to_exec_file, thread_name,\nsupports_catch_syscall.\n\nThe only CPU architecture supported: x86_64.\n\nImplement only support for hardware assisted single step and\nsoftware breakpoint.\n\nImplement support only for regular X86 registers, thus no FPU.\n\ngdbserver/ChangeLog:\n\n       * netbsd-low.cc: Add.\n       * netbsd-low.h: Likewise.\n       * netbsd-amd64-low.cc: Likewise.\n       * Makefile.in (SFILES): Register \"netbsd-low.cc\", \"netbsd-low.h\",\n       \"netbsd-amd64-low.cc\".\n       * configure.srv: Add x86_64-*-netbsd*.",
    "tree": {
      "sha": "85bf1a5ab4532bb4801f9aeb6d341481d5da4768",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/85bf1a5ab4532bb4801f9aeb6d341481d5da4768"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/62ba50486f1146f0cfd33074fc127fe00a02e87e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62ba50486f1146f0cfd33074fc127fe00a02e87e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/62ba50486f1146f0cfd33074fc127fe00a02e87e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62ba50486f1146f0cfd33074fc127fe00a02e87e/comments",
  "author": {
    "login": "krytarowski",
    "id": 6665730,
    "node_id": "MDQ6VXNlcjY2NjU3MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6665730?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/krytarowski",
    "html_url": "https://github.com/krytarowski",
    "followers_url": "https://api.github.com/users/krytarowski/followers",
    "following_url": "https://api.github.com/users/krytarowski/following{/other_user}",
    "gists_url": "https://api.github.com/users/krytarowski/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/krytarowski/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/krytarowski/subscriptions",
    "organizations_url": "https://api.github.com/users/krytarowski/orgs",
    "repos_url": "https://api.github.com/users/krytarowski/repos",
    "events_url": "https://api.github.com/users/krytarowski/events{/privacy}",
    "received_events_url": "https://api.github.com/users/krytarowski/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "krytarowski",
    "id": 6665730,
    "node_id": "MDQ6VXNlcjY2NjU3MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6665730?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/krytarowski",
    "html_url": "https://github.com/krytarowski",
    "followers_url": "https://api.github.com/users/krytarowski/followers",
    "following_url": "https://api.github.com/users/krytarowski/following{/other_user}",
    "gists_url": "https://api.github.com/users/krytarowski/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/krytarowski/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/krytarowski/subscriptions",
    "organizations_url": "https://api.github.com/users/krytarowski/orgs",
    "repos_url": "https://api.github.com/users/krytarowski/repos",
    "events_url": "https://api.github.com/users/krytarowski/events{/privacy}",
    "received_events_url": "https://api.github.com/users/krytarowski/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cf4ac4be12c311d387c8bce55f16f5ad3782d77c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cf4ac4be12c311d387c8bce55f16f5ad3782d77c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cf4ac4be12c311d387c8bce55f16f5ad3782d77c"
    }
  ],
  "stats": {
    "total": 1686,
    "additions": 1686,
    "deletions": 0
  },
  "files": [
    {
      "sha": "0c8af7c6c101dd286ff3aa6415708b71fac376ee",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=62ba50486f1146f0cfd33074fc127fe00a02e87e",
      "patch": "@@ -1,3 +1,12 @@\n+2020-09-10  Kamil Rytarowski  <n54@gmx.com>\n+\n+\t* netbsd-low.cc: Add.\n+\t* netbsd-low.h: Likewise.\n+\t* netbsd-amd64-low.cc: Likewise.\n+\t* Makefile.in (SFILES): Register \"netbsd-low.cc\", \"netbsd-low.h\",\n+\t\"netbsd-amd64-low.cc\".\n+\t* configure.srv: Add x86_64-*-netbsd*.\n+\n 2020-08-13  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* server.cc (captured_main): Accept multiple `--selftest=`"
    },
    {
      "sha": "b0bad0cdb09921c8c5d59c216467f31c2c12dc71",
      "filename": "gdbserver/Makefile.in",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/Makefile.in?ref=62ba50486f1146f0cfd33074fc127fe00a02e87e",
      "patch": "@@ -193,6 +193,9 @@ SFILES = \\\n \t$(srcdir)/linux-x86-low.cc \\\n \t$(srcdir)/linux-xtensa-low.cc \\\n \t$(srcdir)/mem-break.cc \\\n+\t$(srcdir)/netbsd-amd64-low.cc \\\n+\t$(srcdir)/netbsd-low.cc \\\n+\t$(srcdir)/netbsd-low.h \\\n \t$(srcdir)/proc-service.cc \\\n \t$(srcdir)/proc-service.list \\\n \t$(srcdir)/regcache.cc \\"
    },
    {
      "sha": "b9a3703d7544da409a15936bb2d240b220b384df",
      "filename": "gdbserver/configure.srv",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/configure.srv",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/configure.srv",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure.srv?ref=62ba50486f1146f0cfd33074fc127fe00a02e87e",
      "patch": "@@ -349,6 +349,12 @@ case \"${gdbserver_host}\" in\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} nat/windows-nat.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/amd64.o arch/i386.o\"\n \t\t\t;;\n+  x86_64-*-netbsd*)\tsrv_regobj=\"\"\n+\t\t\tsrv_tgtobj=\"netbsd-low.o netbsd-amd64-low.o fork-child.o\"\n+\t\t\tsrv_tgtobj=\"${srv_tgtobj} nat/fork-inferior.o\"\n+\t\t\tsrv_tgtobj=\"${srv_tgtobj} nat/netbsd-nat.o\"\n+\t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/amd64.o\"\n+\t\t\t;;\n \n   xtensa*-*-linux*)\tsrv_regobj=reg-xtensa.o\n \t\t\tsrv_tgtobj=\"$srv_linux_obj linux-xtensa-low.o\""
    },
    {
      "sha": "9b8ea9b8aa666632115a8138e5daa38ef236a46c",
      "filename": "gdbserver/netbsd-amd64-low.cc",
      "status": "added",
      "additions": 187,
      "deletions": 0,
      "changes": 187,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/netbsd-amd64-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/netbsd-amd64-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/netbsd-amd64-low.cc?ref=62ba50486f1146f0cfd33074fc127fe00a02e87e",
      "patch": "@@ -0,0 +1,187 @@\n+/* Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <sys/types.h>\n+#include <sys/ptrace.h>\n+#include <limits.h>\n+\n+#include \"server.h\"\n+#include \"netbsd-low.h\"\n+#include \"gdbsupport/x86-xstate.h\"\n+#include \"arch/amd64.h\"\n+#include \"x86-tdesc.h\"\n+#include \"tdesc.h\"\n+\n+/* The index of various registers inside the regcache.  */\n+\n+enum netbsd_x86_64_gdb_regnum\n+{\n+  AMD64_RAX_REGNUM,\t     /* %rax */\n+  AMD64_RBX_REGNUM,\t     /* %rbx */\n+  AMD64_RCX_REGNUM,\t     /* %rcx */\n+  AMD64_RDX_REGNUM,\t     /* %rdx */\n+  AMD64_RSI_REGNUM,\t     /* %rsi */\n+  AMD64_RDI_REGNUM,\t     /* %rdi */\n+  AMD64_RBP_REGNUM,\t     /* %rbp */\n+  AMD64_RSP_REGNUM,\t     /* %rsp */\n+  AMD64_R8_REGNUM,\t      /* %r8 */\n+  AMD64_R9_REGNUM,\t      /* %r9 */\n+  AMD64_R10_REGNUM,\t     /* %r10 */\n+  AMD64_R11_REGNUM,\t     /* %r11 */\n+  AMD64_R12_REGNUM,\t     /* %r12 */\n+  AMD64_R13_REGNUM,\t     /* %r13 */\n+  AMD64_R14_REGNUM,\t     /* %r14 */\n+  AMD64_R15_REGNUM,\t     /* %r15 */\n+  AMD64_RIP_REGNUM,\t     /* %rip */\n+  AMD64_EFLAGS_REGNUM,\t  /* %eflags */\n+  AMD64_CS_REGNUM,\t      /* %cs */\n+  AMD64_SS_REGNUM,\t      /* %ss */\n+  AMD64_DS_REGNUM,\t      /* %ds */\n+  AMD64_ES_REGNUM,\t      /* %es */\n+  AMD64_FS_REGNUM,\t      /* %fs */\n+  AMD64_GS_REGNUM,\t      /* %gs */\n+  AMD64_ST0_REGNUM = 24,     /* %st0 */\n+  AMD64_ST1_REGNUM,\t     /* %st1 */\n+  AMD64_FCTRL_REGNUM = AMD64_ST0_REGNUM + 8,\n+  AMD64_FSTAT_REGNUM = AMD64_ST0_REGNUM + 9,\n+  AMD64_FTAG_REGNUM = AMD64_ST0_REGNUM + 10,\n+  AMD64_XMM0_REGNUM = 40,   /* %xmm0 */\n+  AMD64_XMM1_REGNUM,\t    /* %xmm1 */\n+  AMD64_MXCSR_REGNUM = AMD64_XMM0_REGNUM + 16,\n+  AMD64_YMM0H_REGNUM,\t   /* %ymm0h */\n+  AMD64_YMM15H_REGNUM = AMD64_YMM0H_REGNUM + 15,\n+  AMD64_BND0R_REGNUM = AMD64_YMM15H_REGNUM + 1,\n+  AMD64_BND3R_REGNUM = AMD64_BND0R_REGNUM + 3,\n+  AMD64_BNDCFGU_REGNUM,\n+  AMD64_BNDSTATUS_REGNUM,\n+  AMD64_XMM16_REGNUM,\n+  AMD64_XMM31_REGNUM = AMD64_XMM16_REGNUM + 15,\n+  AMD64_YMM16H_REGNUM,\n+  AMD64_YMM31H_REGNUM = AMD64_YMM16H_REGNUM + 15,\n+  AMD64_K0_REGNUM,\n+  AMD64_K7_REGNUM = AMD64_K0_REGNUM + 7,\n+  AMD64_ZMM0H_REGNUM,\n+  AMD64_ZMM31H_REGNUM = AMD64_ZMM0H_REGNUM + 31,\n+  AMD64_PKRU_REGNUM,\n+  AMD64_FSBASE_REGNUM,\n+  AMD64_GSBASE_REGNUM\n+};\n+\n+/* The fill_function for the general-purpose register set.  */\n+\n+static void\n+netbsd_x86_64_fill_gregset (struct regcache *regcache, char *buf)\n+{\n+  struct reg *r = (struct reg *) buf;\n+\n+#define netbsd_x86_64_collect_gp(regnum, fld) do {\t\t\\\n+    collect_register (regcache, regnum, &r->regs[_REG_##fld]);\t\\\n+  } while (0)\n+\n+  netbsd_x86_64_collect_gp (AMD64_RAX_REGNUM, RAX);\n+  netbsd_x86_64_collect_gp (AMD64_RBX_REGNUM, RBX);\n+  netbsd_x86_64_collect_gp (AMD64_RCX_REGNUM, RCX);\n+  netbsd_x86_64_collect_gp (AMD64_RDX_REGNUM, RDX);\n+  netbsd_x86_64_collect_gp (AMD64_RSI_REGNUM, RSI);\n+  netbsd_x86_64_collect_gp (AMD64_RDI_REGNUM, RDI);\n+  netbsd_x86_64_collect_gp (AMD64_RBP_REGNUM, RBP);\n+  netbsd_x86_64_collect_gp (AMD64_RSP_REGNUM, RSP);\n+  netbsd_x86_64_collect_gp (AMD64_R8_REGNUM, R8);\n+  netbsd_x86_64_collect_gp (AMD64_R9_REGNUM, R9);\n+  netbsd_x86_64_collect_gp (AMD64_R10_REGNUM, R10);\n+  netbsd_x86_64_collect_gp (AMD64_R11_REGNUM, R11);\n+  netbsd_x86_64_collect_gp (AMD64_R12_REGNUM, R12);\n+  netbsd_x86_64_collect_gp (AMD64_R13_REGNUM, R13);\n+  netbsd_x86_64_collect_gp (AMD64_R14_REGNUM, R14);\n+  netbsd_x86_64_collect_gp (AMD64_R15_REGNUM, R15);\n+  netbsd_x86_64_collect_gp (AMD64_RIP_REGNUM, RIP);\n+  netbsd_x86_64_collect_gp (AMD64_EFLAGS_REGNUM, RFLAGS);\n+  netbsd_x86_64_collect_gp (AMD64_CS_REGNUM, CS);\n+  netbsd_x86_64_collect_gp (AMD64_SS_REGNUM, SS);\n+  netbsd_x86_64_collect_gp (AMD64_DS_REGNUM, DS);\n+  netbsd_x86_64_collect_gp (AMD64_ES_REGNUM, ES);\n+  netbsd_x86_64_collect_gp (AMD64_FS_REGNUM, FS);\n+  netbsd_x86_64_collect_gp (AMD64_GS_REGNUM, GS);\n+}\n+\n+/* The store_function for the general-purpose register set.  */\n+\n+static void\n+netbsd_x86_64_store_gregset (struct regcache *regcache, const char *buf)\n+{\n+  struct reg *r = (struct reg *) buf;\n+\n+#define netbsd_x86_64_supply_gp(regnum, fld) do {\t\t\\\n+    supply_register (regcache, regnum, &r->regs[_REG_##fld]);\t\\\n+  } while(0)\n+\n+  netbsd_x86_64_supply_gp (AMD64_RAX_REGNUM, RAX);\n+  netbsd_x86_64_supply_gp (AMD64_RBX_REGNUM, RBX);\n+  netbsd_x86_64_supply_gp (AMD64_RCX_REGNUM, RCX);\n+  netbsd_x86_64_supply_gp (AMD64_RDX_REGNUM, RDX);\n+  netbsd_x86_64_supply_gp (AMD64_RSI_REGNUM, RSI);\n+  netbsd_x86_64_supply_gp (AMD64_RDI_REGNUM, RDI);\n+  netbsd_x86_64_supply_gp (AMD64_RBP_REGNUM, RBP);\n+  netbsd_x86_64_supply_gp (AMD64_RSP_REGNUM, RSP);\n+  netbsd_x86_64_supply_gp (AMD64_R8_REGNUM, R8);\n+  netbsd_x86_64_supply_gp (AMD64_R9_REGNUM, R9);\n+  netbsd_x86_64_supply_gp (AMD64_R10_REGNUM, R10);\n+  netbsd_x86_64_supply_gp (AMD64_R11_REGNUM, R11);\n+  netbsd_x86_64_supply_gp (AMD64_R12_REGNUM, R12);\n+  netbsd_x86_64_supply_gp (AMD64_R13_REGNUM, R13);\n+  netbsd_x86_64_supply_gp (AMD64_R14_REGNUM, R14);\n+  netbsd_x86_64_supply_gp (AMD64_R15_REGNUM, R15);\n+  netbsd_x86_64_supply_gp (AMD64_RIP_REGNUM, RIP);\n+  netbsd_x86_64_supply_gp (AMD64_EFLAGS_REGNUM, RFLAGS);\n+  netbsd_x86_64_supply_gp (AMD64_CS_REGNUM, CS);\n+  netbsd_x86_64_supply_gp (AMD64_SS_REGNUM, SS);\n+  netbsd_x86_64_supply_gp (AMD64_DS_REGNUM, DS);\n+  netbsd_x86_64_supply_gp (AMD64_ES_REGNUM, ES);\n+  netbsd_x86_64_supply_gp (AMD64_FS_REGNUM, FS);\n+  netbsd_x86_64_supply_gp (AMD64_GS_REGNUM, GS);\n+}\n+\n+/* Implements the netbsd_target_ops.arch_setup routine.  */\n+\n+static void\n+netbsd_x86_64_arch_setup (void)\n+{\n+  struct target_desc *tdesc\n+    = amd64_create_target_description (X86_XSTATE_SSE_MASK, false, false, false);\n+\n+  init_target_desc (tdesc, amd64_expedite_regs);\n+\n+  netbsd_tdesc = tdesc;\n+}\n+\n+/* Description of all the x86-netbsd register sets.  */\n+\n+struct netbsd_regset_info netbsd_target_regsets[] =\n+{\n+ /* General Purpose Registers.  */\n+ {PT_GETREGS, PT_SETREGS, sizeof (struct reg),\n+  netbsd_x86_64_fill_gregset, netbsd_x86_64_store_gregset},\n+ /* End of list marker.  */\n+ {0, 0, -1, NULL, NULL }\n+};\n+\n+/* The netbsd_target_ops vector for x86-netbsd.  */\n+\n+struct netbsd_target_ops the_low_target =\n+{\n+ netbsd_x86_64_arch_setup,\n+};"
    },
    {
      "sha": "8b13b6741e9980c0a3ad63b2e32a3a2dcca5eab1",
      "filename": "gdbserver/netbsd-low.cc",
      "status": "added",
      "additions": 1327,
      "deletions": 0,
      "changes": 1327,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/netbsd-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/netbsd-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/netbsd-low.cc?ref=62ba50486f1146f0cfd33074fc127fe00a02e87e",
      "patch": "@@ -0,0 +1,1327 @@\n+/* Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"server.h\"\n+#include \"target.h\"\n+#include \"netbsd-low.h\"\n+#include \"nat/netbsd-nat.h\"\n+\n+#include <sys/param.h>\n+#include <sys/types.h>\n+\n+#include <sys/ptrace.h>\n+#include <sys/sysctl.h>\n+\n+#include <limits.h>\n+#include <unistd.h>\n+#include <signal.h>\n+\n+#include <elf.h>\n+\n+#include <type_traits>\n+\n+#include \"gdbsupport/eintr.h\"\n+#include \"gdbsupport/gdb_wait.h\"\n+#include \"gdbsupport/filestuff.h\"\n+#include \"gdbsupport/common-inferior.h\"\n+#include \"nat/fork-inferior.h\"\n+#include \"hostio.h\"\n+\n+int using_threads = 1;\n+\n+const struct target_desc *netbsd_tdesc;\n+\n+/* Call add_process with the given parameters, and initialize\n+   the process' private data.  */\n+\n+static void\n+netbsd_add_process (int pid, int attached)\n+{\n+  struct process_info *proc = add_process (pid, attached);\n+  proc->tdesc = netbsd_tdesc;\n+  proc->priv = nullptr;\n+}\n+\n+/* Callback used by fork_inferior to start tracing the inferior.  */\n+\n+static void\n+netbsd_ptrace_fun ()\n+{\n+  /* Switch child to its own process group so that signals won't\n+     directly affect GDBserver. */\n+  if (setpgid (0, 0) < 0)\n+    trace_start_error_with_name ((\"setpgid\"));\n+\n+  if (ptrace (PT_TRACE_ME, 0, nullptr, 0) < 0)\n+    trace_start_error_with_name ((\"ptrace\"));\n+\n+  /* If GDBserver is connected to gdb via stdio, redirect the inferior's\n+     stdout to stderr so that inferior i/o doesn't corrupt the connection.\n+     Also, redirect stdin to /dev/null.  */\n+  if (remote_connection_is_stdio ())\n+    {\n+      if (close (0) < 0)\n+\ttrace_start_error_with_name ((\"close\"));\n+      if (open (\"/dev/null\", O_RDONLY) < 0)\n+\ttrace_start_error_with_name ((\"open\"));\n+      if (dup2 (2, 1) < 0)\n+\ttrace_start_error_with_name ((\"dup2\"));\n+      if (write (2, \"stdin/stdout redirected\\n\",\n+\t\t sizeof (\"stdin/stdout redirected\\n\") - 1) < 0)\n+\t{\n+\t  /* Errors ignored.  */\n+\t}\n+    }\n+}\n+\n+/* Implement the create_inferior method of the target_ops vector.  */\n+\n+int\n+netbsd_process_target::create_inferior (const char *program,\n+\t\t\t\t\tconst std::vector<char *> &program_args)\n+{\n+  std::string str_program_args = construct_inferior_arguments (program_args);\n+\n+  pid_t pid = fork_inferior (program, str_program_args.c_str (),\n+\t\t\t     get_environ ()->envp (), netbsd_ptrace_fun,\n+\t\t\t     nullptr, nullptr, nullptr, nullptr);\n+\n+  netbsd_add_process (pid, 0);\n+\n+  post_fork_inferior (pid, program);\n+\n+  return pid;\n+}\n+\n+/* Implement the post_create_inferior target_ops method.  */\n+\n+void\n+netbsd_process_target::post_create_inferior ()\n+{\n+  pid_t pid = current_process ()->pid;\n+  netbsd_nat::enable_proc_events (pid);\n+}\n+\n+/* Implement the attach target_ops method.  */\n+\n+int\n+netbsd_process_target::attach (unsigned long pid)\n+{\n+  /* Unimplemented.  */\n+  return -1;\n+}\n+\n+/* Returns true if GDB is interested in any child syscalls.  */\n+\n+static bool\n+gdb_catching_syscalls_p (pid_t pid)\n+{\n+  struct process_info *proc = find_process_pid (pid);\n+  return !proc->syscalls_to_catch.empty ();\n+}\n+\n+/* Implement the resume target_ops method.  */\n+\n+void\n+netbsd_process_target::resume (struct thread_resume *resume_info, size_t n)\n+{\n+  ptid_t resume_ptid = resume_info[0].thread;\n+  const int signal = resume_info[0].sig;\n+  const bool step = resume_info[0].kind == resume_step;\n+\n+  if (resume_ptid == minus_one_ptid)\n+    resume_ptid = ptid_of (current_thread);\n+\n+  const pid_t pid = resume_ptid.pid ();\n+  const lwpid_t lwp = resume_ptid.lwp ();\n+  regcache_invalidate_pid (pid);\n+\n+  auto fn\n+    = [&] (ptid_t ptid)\n+      {\n+\tif (step)\n+\t  {\n+\t    if (ptid.lwp () == lwp || n != 1)\n+\t      {\n+\t\tif (ptrace (PT_SETSTEP, pid, NULL, ptid.lwp ()) == -1)\n+\t\t  perror_with_name ((\"ptrace\"));\n+\t\tif (ptrace (PT_RESUME, pid, NULL, ptid.lwp ()) == -1)\n+\t\t  perror_with_name ((\"ptrace\"));\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (ptrace (PT_CLEARSTEP, pid, NULL, ptid.lwp ()) == -1)\n+\t\t  perror_with_name ((\"ptrace\"));\n+\t\tif (ptrace (PT_SUSPEND, pid, NULL, ptid.lwp ()) == -1)\n+\t\t  perror_with_name ((\"ptrace\"));\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if (ptrace (PT_CLEARSTEP, pid, NULL, ptid.lwp ()) == -1)\n+\t      perror_with_name ((\"ptrace\"));\n+\t    if (ptrace (PT_RESUME, pid, NULL, ptid.lwp ()) == -1)\n+\t      perror_with_name ((\"ptrace\"));\n+\t  }\n+      };\n+\n+  netbsd_nat::for_each_thread (pid, fn);\n+\n+  int request = gdb_catching_syscalls_p (pid) ? PT_CONTINUE : PT_SYSCALL;\n+\n+  errno = 0;\n+  ptrace (request, pid, (void *)1, signal);\n+  if (errno)\n+    perror_with_name ((\"ptrace\"));\n+}\n+\n+/* Returns true if GDB is interested in the reported SYSNO syscall.  */\n+\n+static bool\n+netbsd_catch_this_syscall (int sysno)\n+{\n+  struct process_info *proc = current_process ();\n+\n+  if (proc->syscalls_to_catch.empty ())\n+    return false;\n+\n+  if (proc->syscalls_to_catch[0] == ANY_SYSCALL)\n+    return true;\n+\n+  for (int iter : proc->syscalls_to_catch)\n+    if (iter == sysno)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Helper function for child_wait and the derivatives of child_wait.\n+   HOSTSTATUS is the waitstatus from wait() or the equivalent; store our\n+   translation of that in OURSTATUS.  */\n+\n+static void\n+netbsd_store_waitstatus (struct target_waitstatus *ourstatus, int hoststatus)\n+{\n+  if (WIFEXITED (hoststatus))\n+    {\n+      ourstatus->kind = TARGET_WAITKIND_EXITED;\n+      ourstatus->value.integer = WEXITSTATUS (hoststatus);\n+    }\n+  else if (!WIFSTOPPED (hoststatus))\n+    {\n+      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n+      ourstatus->value.sig = gdb_signal_from_host (WTERMSIG (hoststatus));\n+    }\n+  else\n+    {\n+      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n+      ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (hoststatus));\n+    }\n+}\n+\n+/* Implement a safe wrapper around waitpid().  */\n+\n+static pid_t\n+netbsd_waitpid (ptid_t ptid, struct target_waitstatus *ourstatus, int options)\n+{\n+  int status;\n+\n+  pid_t pid\n+    = gdb::handle_eintr<int> (-1, ::waitpid, ptid.pid (), &status, options);\n+\n+  if (pid == -1)\n+    perror_with_name (_(\"Child process unexpectedly missing\"));\n+\n+  netbsd_store_waitstatus (ourstatus, status);\n+  return pid;\n+}\n+\n+\n+/* Implement the wait target_ops method.\n+\n+   Wait for the child specified by PTID to do something.  Return the\n+   process ID of the child, or MINUS_ONE_PTID in case of error; store\n+   the status in *OURSTATUS.  */\n+\n+static ptid_t\n+netbsd_wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n+\t     int target_options)\n+{\n+  pid_t pid = netbsd_waitpid (ptid, ourstatus, target_options);\n+  ptid_t wptid = ptid_t (pid);\n+\n+  if (pid == 0)\n+    {\n+      gdb_assert (target_options & TARGET_WNOHANG);\n+      ourstatus->kind = TARGET_WAITKIND_IGNORE;\n+      return null_ptid;\n+    }\n+\n+  gdb_assert (pid != -1);\n+\n+  /* If the child stopped, keep investigating its status.  */\n+  if (ourstatus->kind != TARGET_WAITKIND_STOPPED)\n+    return wptid;\n+\n+  /* Extract the event and thread that received a signal.  */\n+  ptrace_siginfo_t psi;\n+  if (ptrace (PT_GET_SIGINFO, pid, &psi, sizeof (psi)) == -1)\n+    perror_with_name ((\"ptrace\"));\n+\n+  /* Pick child's siginfo_t.  */\n+  siginfo_t *si = &psi.psi_siginfo;\n+\n+  lwpid_t lwp = psi.psi_lwpid;\n+\n+  int signo = si->si_signo;\n+  const int code = si->si_code;\n+\n+  /* Construct PTID with a specified thread that received the event.\n+     If a signal was targeted to the whole process, lwp is 0.  */\n+  wptid = ptid_t (pid, lwp, 0);\n+\n+  /* Bail out on non-debugger oriented signals.  */\n+  if (signo != SIGTRAP)\n+    return wptid;\n+\n+  /* Stop examining non-debugger oriented SIGTRAP codes.  */\n+  if (code <= SI_USER || code == SI_NOINFO)\n+    return wptid;\n+\n+  /* Process state for threading events.  */\n+  ptrace_state_t pst = {};\n+  if (code == TRAP_LWP)\n+    if (ptrace (PT_GET_PROCESS_STATE, pid, &pst, sizeof (pst)) == -1)\n+      perror_with_name ((\"ptrace\"));\n+\n+  if (code == TRAP_LWP && pst.pe_report_event == PTRACE_LWP_EXIT)\n+    {\n+      /* If GDB attaches to a multi-threaded process, exiting\n+\t threads might be skipped during post_attach that\n+\t have not yet reported their PTRACE_LWP_EXIT event.\n+\t Ignore exited events for an unknown LWP.  */\n+      thread_info *thr = find_thread_ptid (wptid);\n+      if (thr == nullptr)\n+\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+      else\n+\t{\n+\t  ourstatus->kind = TARGET_WAITKIND_THREAD_EXITED;\n+\t  /* NetBSD does not store an LWP exit status.  */\n+\t  ourstatus->value.integer = 0;\n+\n+\t  remove_thread (thr);\n+\t}\n+      return wptid;\n+    }\n+\n+  if (find_thread_ptid (ptid_t (pid)))\n+    current_thread = find_thread_ptid (wptid);\n+\n+  if (code == TRAP_LWP && pst.pe_report_event == PTRACE_LWP_CREATE)\n+    {\n+      /* If GDB attaches to a multi-threaded process, newborn\n+\t threads might be added by nbsd_add_threads that have\n+\t not yet reported their PTRACE_LWP_CREATE event.  Ignore\n+\t born events for an already-known LWP.  */\n+      if (find_thread_ptid (wptid))\n+\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+      else\n+\t{\n+\t  add_thread (wptid, NULL);\n+\t  ourstatus->kind = TARGET_WAITKIND_THREAD_CREATED;\n+\t}\n+      return wptid;\n+    }\n+\n+  if (code == TRAP_EXEC)\n+    {\n+      ourstatus->kind = TARGET_WAITKIND_EXECD;\n+      ourstatus->value.execd_pathname\n+\t= xstrdup (netbsd_nat::pid_to_exec_file (pid));\n+      return wptid;\n+    }\n+\n+  if (code == TRAP_TRACE)\n+      return wptid;\n+\n+  if (code == TRAP_SCE || code == TRAP_SCX)\n+    {\n+      int sysnum = si->si_sysnum;\n+\n+      if (!netbsd_catch_this_syscall(sysnum))\n+\t{\n+\t  /* If the core isn't interested in this event, ignore it.  */\n+\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  return wptid;\n+\t}\n+\n+      ourstatus->kind\n+\t= ((code == TRAP_SCE) ? TARGET_WAITKIND_SYSCALL_ENTRY :\n+\t   TARGET_WAITKIND_SYSCALL_RETURN);\n+      ourstatus->value.syscall_number = sysnum;\n+      return wptid;\n+    }\n+\n+  if (code == TRAP_BRKPT)\n+    {\n+#ifdef PTRACE_BREAKPOINT_ADJ\n+      CORE_ADDR pc;\n+      struct reg r;\n+      ptrace (PT_GETREGS, pid, &r, psi.psi_lwpid);\n+      pc = PTRACE_REG_PC (&r);\n+      PTRACE_REG_SET_PC (&r, pc - PTRACE_BREAKPOINT_ADJ);\n+      ptrace (PT_SETREGS, pid, &r, psi.psi_lwpid);\n+#endif\n+      return wptid;\n+    }\n+\n+  /* Unclassified SIGTRAP event.  */\n+  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+  return wptid;\n+}\n+\n+/* Implement the wait target_ops method.  */\n+\n+ptid_t\n+netbsd_process_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n+\t\t\t     int target_options)\n+{\n+  while (true)\n+    {\n+      ptid_t wptid = netbsd_wait (ptid, ourstatus, target_options);\n+\n+      /* Register thread in the gdbcore if a thread was not reported earlier.\n+\t This is required after ::create_inferior, when the gdbcore does not\n+\t know about the first internal thread.\n+\t This may also happen on attach, when an event is registered on a thread\n+\t that was not fully initialized during the attach stage.  */\n+      if (wptid.lwp () != 0 && !find_thread_ptid (wptid)\n+\t  && ourstatus->kind != TARGET_WAITKIND_THREAD_EXITED)\n+\tadd_thread (wptid, nullptr);\n+\n+      switch (ourstatus->kind)\n+\t{\n+\tcase TARGET_WAITKIND_EXITED:\n+\tcase TARGET_WAITKIND_STOPPED:\n+\tcase TARGET_WAITKIND_SIGNALLED:\n+\tcase TARGET_WAITKIND_FORKED:\n+\tcase TARGET_WAITKIND_VFORKED:\n+\tcase TARGET_WAITKIND_EXECD:\n+\tcase TARGET_WAITKIND_VFORK_DONE:\n+\tcase TARGET_WAITKIND_SYSCALL_ENTRY:\n+\tcase TARGET_WAITKIND_SYSCALL_RETURN:\n+\t  /* Pass the result to the generic code.  */\n+\t  return wptid;\n+\tcase TARGET_WAITKIND_THREAD_CREATED:\n+\tcase TARGET_WAITKIND_THREAD_EXITED:\n+\t  /* The core needlessly stops on these events.  */\n+\t  /* FALLTHROUGH */\n+\tcase TARGET_WAITKIND_SPURIOUS:\n+\t  /* Spurious events are unhandled by the gdbserver core.  */\n+\t  if (ptrace (PT_CONTINUE, current_process ()->pid, (void *) 1, 0)\n+\t      == -1)\n+\t    perror_with_name ((\"ptrace\"));\n+\t  break;\n+\tdefault:\n+\t  error ((\"Unknown stopped status\"));\n+\t}\n+    }\n+}\n+\n+/* Implement the kill target_ops method.  */\n+\n+int\n+netbsd_process_target::kill (process_info *process)\n+{\n+  pid_t pid = process->pid;\n+  if (ptrace (PT_KILL, pid, nullptr, 0) == -1)\n+    return -1;\n+\n+  int status;\n+  if (gdb::handle_eintr<int> (-1, ::waitpid, pid, &status, 0) == -1)\n+    return -1;\n+  mourn (process);\n+  return 0;\n+}\n+\n+/* Implement the detach target_ops method.  */\n+\n+int\n+netbsd_process_target::detach (process_info *process)\n+{\n+  pid_t pid = process->pid;\n+\n+  ptrace (PT_DETACH, pid, (void *) 1, 0);\n+  mourn (process);\n+  return 0;\n+}\n+\n+/* Implement the mourn target_ops method.  */\n+\n+void\n+netbsd_process_target::mourn (struct process_info *proc)\n+{\n+  for_each_thread (proc->pid, remove_thread);\n+\n+  remove_process (proc);\n+}\n+\n+/* Implement the join target_ops method.  */\n+\n+void\n+netbsd_process_target::join (int pid)\n+{\n+  /* The PT_DETACH is sufficient to detach from the process.\n+     So no need to do anything extra.  */\n+}\n+\n+/* Implement the thread_alive target_ops method.  */\n+\n+bool\n+netbsd_process_target::thread_alive (ptid_t ptid)\n+{\n+  return netbsd_nat::thread_alive (ptid);\n+}\n+\n+/* Implement the fetch_registers target_ops method.  */\n+\n+void\n+netbsd_process_target::fetch_registers (struct regcache *regcache, int regno)\n+{\n+  struct netbsd_regset_info *regset = netbsd_target_regsets;\n+  ptid_t inferior_ptid = ptid_of (current_thread);\n+\n+  while (regset->size >= 0)\n+    {\n+      std::vector<char> buf;\n+      buf.resize (regset->size);\n+      int res = ptrace (regset->get_request, inferior_ptid.pid (), buf.data (),\n+\t\t\tinferior_ptid.lwp ());\n+      if (res == -1)\n+\tperror_with_name ((\"ptrace\"));\n+      regset->store_function (regcache, buf.data ());\n+      regset++;\n+    }\n+}\n+\n+/* Implement the store_registers target_ops method.  */\n+\n+void\n+netbsd_process_target::store_registers (struct regcache *regcache, int regno)\n+{\n+  struct netbsd_regset_info *regset = netbsd_target_regsets;\n+  ptid_t inferior_ptid = ptid_of (current_thread);\n+\n+  while (regset->size >= 0)\n+    {\n+      std::vector<char> buf;\n+      buf.resize (regset->size);\n+      int res = ptrace (regset->get_request, inferior_ptid.pid (), buf.data (),\n+\t\t\tinferior_ptid.lwp ());\n+      if (res == -1)\n+\tperror_with_name ((\"ptrace\"));\n+\n+      /* Then overlay our cached registers on that.  */\n+      regset->fill_function (regcache, buf.data ());\n+      /* Only now do we write the register set.  */\n+      res = ptrace (regset->set_request, inferior_ptid.pid (), buf. data (),\n+\t\t    inferior_ptid.lwp ());\n+      if (res == -1)\n+\tperror_with_name ((\"ptrace\"));\n+      regset++;\n+    }\n+}\n+\n+/* Implement the read_memory target_ops method.  */\n+\n+int\n+netbsd_process_target::read_memory (CORE_ADDR memaddr, unsigned char *myaddr,\n+\t\t\t\t    int size)\n+{\n+  struct ptrace_io_desc io;\n+  io.piod_op = PIOD_READ_D;\n+  io.piod_len = size;\n+\n+  pid_t pid = current_process ()->pid;\n+\n+  int bytes_read = 0;\n+\n+  if (size == 0)\n+    {\n+      /* Zero length write always succeeds.  */\n+      return 0;\n+    }\n+  do\n+    {\n+      io.piod_offs = (void *)(memaddr + bytes_read);\n+      io.piod_addr = myaddr + bytes_read;\n+\n+      int rv = ptrace (PT_IO, pid, &io, 0);\n+      if (rv == -1)\n+\treturn errno;\n+      if (io.piod_len == 0)\n+\treturn 0;\n+\n+      bytes_read += io.piod_len;\n+      io.piod_len = size - bytes_read;\n+    }\n+  while (bytes_read < size);\n+\n+  return 0;\n+}\n+\n+/* Implement the write_memory target_ops method.  */\n+\n+int\n+netbsd_process_target::write_memory (CORE_ADDR memaddr,\n+\t\t\t\t     const unsigned char *myaddr, int size)\n+{\n+  struct ptrace_io_desc io;\n+  io.piod_op = PIOD_WRITE_D;\n+  io.piod_len = size;\n+\n+  pid_t pid = current_process ()->pid;\n+\n+  int bytes_written = 0;\n+\n+  if (size == 0)\n+    {\n+      /* Zero length write always succeeds.  */\n+      return 0;\n+    }\n+\n+  do\n+    {\n+      io.piod_addr = (void *)(myaddr + bytes_written);\n+      io.piod_offs = (void *)(memaddr + bytes_written);\n+\n+      int rv = ptrace (PT_IO, pid, &io, 0);\n+      if (rv == -1)\n+\treturn errno;\n+      if (io.piod_len == 0)\n+\treturn 0;\n+\n+      bytes_written += io.piod_len;\n+      io.piod_len = size - bytes_written;\n+    }\n+  while (bytes_written < size);\n+\n+  return 0;\n+}\n+\n+/* Implement the request_interrupt target_ops method.  */\n+\n+void\n+netbsd_process_target::request_interrupt ()\n+{\n+  ptid_t inferior_ptid = ptid_of (get_first_thread ());\n+\n+  ::kill (inferior_ptid.pid(), SIGINT);\n+}\n+\n+/* Read the AUX Vector for the specified PID, wrapping the ptrace(2) call\n+   with the PIOD_READ_AUXV operation and using the PT_IO standard input\n+   and output arguments.  */\n+\n+static size_t\n+netbsd_read_auxv(pid_t pid, void *offs, void *addr, size_t len)\n+{\n+  struct ptrace_io_desc pio;\n+\n+  pio.piod_op = PIOD_READ_AUXV;\n+  pio.piod_offs = offs;\n+  pio.piod_addr = addr;\n+  pio.piod_len = len;\n+\n+  if (ptrace (PT_IO, pid, &pio, 0) == -1)\n+    perror_with_name ((\"ptrace\"));\n+\n+  return pio.piod_len;\n+}\n+\n+/* Copy LEN bytes from inferior's auxiliary vector starting at OFFSET\n+   to debugger memory starting at MYADDR.  */\n+\n+int\n+netbsd_process_target::read_auxv (CORE_ADDR offset,\n+\t\t\t\t  unsigned char *myaddr, unsigned int len)\n+{\n+  pid_t pid = pid_of (current_thread);\n+\n+  return netbsd_read_auxv (pid, (void *) (intptr_t) offset, myaddr, len);\n+}\n+\n+bool\n+netbsd_process_target::supports_z_point_type (char z_type)\n+{\n+  switch (z_type)\n+    {\n+    case Z_PACKET_SW_BP:\n+      return true;\n+    case Z_PACKET_HW_BP:\n+    case Z_PACKET_WRITE_WP:\n+    case Z_PACKET_READ_WP:\n+    case Z_PACKET_ACCESS_WP:\n+    default:\n+      return false; /* Not supported.  */\n+    }\n+}\n+\n+/* Insert {break/watch}point at address ADDR.  SIZE is not used.  */\n+\n+int\n+netbsd_process_target::insert_point (enum raw_bkpt_type type, CORE_ADDR addr,\n+\t\t     int size, struct raw_breakpoint *bp)\n+{\n+  switch (type)\n+    {\n+    case raw_bkpt_type_sw:\n+      return insert_memory_breakpoint (bp);\n+    case raw_bkpt_type_hw:\n+    case raw_bkpt_type_write_wp:\n+    case raw_bkpt_type_read_wp:\n+    case raw_bkpt_type_access_wp:\n+    default:\n+      return 1; /* Not supported.  */\n+    }\n+}\n+\n+/* Remove {break/watch}point at address ADDR.  SIZE is not used.  */\n+\n+int\n+netbsd_process_target::remove_point (enum raw_bkpt_type type, CORE_ADDR addr,\n+\t\t\t\t     int size, struct raw_breakpoint *bp)\n+{\n+  switch (type)\n+    {\n+    case raw_bkpt_type_sw:\n+      return remove_memory_breakpoint (bp);\n+    case raw_bkpt_type_hw:\n+    case raw_bkpt_type_write_wp:\n+    case raw_bkpt_type_read_wp:\n+    case raw_bkpt_type_access_wp:\n+    default:\n+      return 1; /* Not supported.  */\n+    }\n+}\n+\n+/* Implement the stopped_by_sw_breakpoint target_ops method.  */\n+\n+bool\n+netbsd_process_target::stopped_by_sw_breakpoint ()\n+{\n+  ptrace_siginfo_t psi;\n+  pid_t pid = current_process ()->pid;\n+\n+  if (ptrace (PT_GET_SIGINFO, pid, &psi, sizeof (psi)) == -1)\n+    perror_with_name ((\"ptrace\"));\n+\n+  return psi.psi_siginfo.si_signo == SIGTRAP &&\n+\t psi.psi_siginfo.si_code == TRAP_BRKPT;\n+}\n+\n+/* Implement the supports_stopped_by_sw_breakpoint target_ops method.  */\n+\n+bool\n+netbsd_process_target::supports_stopped_by_sw_breakpoint ()\n+{\n+  return true;\n+}\n+\n+/* Implement the supports_qxfer_siginfo target_ops method.  */\n+\n+bool\n+netbsd_process_target::supports_qxfer_siginfo ()\n+{\n+  return true;\n+}\n+\n+/* Implement the qxfer_siginfo target_ops method.  */\n+\n+int\n+netbsd_process_target::qxfer_siginfo (const char *annex, unsigned char *readbuf,\n+\t\t\t\t      unsigned const char *writebuf,\n+\t\t\t\t      CORE_ADDR offset, int len)\n+{\n+  if (current_thread == nullptr)\n+    return -1;\n+\n+  pid_t pid = current_process ()->pid;\n+\n+  return netbsd_nat::qxfer_siginfo(pid, annex, readbuf, writebuf, offset, len);\n+}\n+\n+/* Implement the supports_non_stop target_ops method.  */\n+\n+bool\n+netbsd_process_target::supports_non_stop ()\n+{\n+  return false;\n+}\n+\n+/* Implement the supports_multi_process target_ops method.  */\n+\n+bool\n+netbsd_process_target::supports_multi_process ()\n+{\n+  return true;\n+}\n+\n+/* Check if fork events are supported.  */\n+\n+bool\n+netbsd_process_target::supports_fork_events ()\n+{\n+  return false;\n+}\n+\n+/* Check if vfork events are supported.  */\n+\n+bool\n+netbsd_process_target::supports_vfork_events ()\n+{\n+  return false;\n+}\n+\n+/* Check if exec events are supported.  */\n+\n+bool\n+netbsd_process_target::supports_exec_events ()\n+{\n+  return true;\n+}\n+\n+/* Implement the supports_disable_randomization target_ops method.  */\n+\n+bool\n+netbsd_process_target::supports_disable_randomization ()\n+{\n+  return false;\n+}\n+\n+/* Extract &phdr and num_phdr in the inferior.  Return 0 on success.  */\n+\n+template <typename T>\n+int get_phdr_phnum_from_proc_auxv (const pid_t pid,\n+\t\t\t\t   CORE_ADDR *phdr_memaddr, int *num_phdr)\n+{\n+  typedef typename std::conditional<sizeof(T) == sizeof(int64_t),\n+\t\t\t\t    Aux64Info, Aux32Info>::type auxv_type;\n+  const size_t auxv_size = sizeof (auxv_type);\n+  const size_t auxv_buf_size = 128 * sizeof (auxv_type);\n+\n+  std::vector<char> auxv_buf;\n+  auxv_buf.resize (auxv_buf_size);\n+\n+  netbsd_read_auxv (pid, nullptr, auxv_buf.data (), auxv_buf_size);\n+\n+  *phdr_memaddr = 0;\n+  *num_phdr = 0;\n+\n+  for (char *buf = auxv_buf.data ();\n+       buf < (auxv_buf.data () + auxv_buf_size);\n+       buf += auxv_size)\n+    {\n+      auxv_type *const aux = (auxv_type *) buf;\n+\n+      switch (aux->a_type)\n+\t{\n+\tcase AT_PHDR:\n+\t  *phdr_memaddr = aux->a_v;\n+\t  break;\n+\tcase AT_PHNUM:\n+\t  *num_phdr = aux->a_v;\n+\t  break;\n+\t}\n+\n+      if (*phdr_memaddr != 0 && *num_phdr != 0)\n+\tbreak;\n+    }\n+\n+  if (*phdr_memaddr == 0 || *num_phdr == 0)\n+    {\n+      warning (\"Unexpected missing AT_PHDR and/or AT_PHNUM: \"\n+\t       \"phdr_memaddr = %s, phdr_num = %d\",\n+\t       core_addr_to_string (*phdr_memaddr), *num_phdr);\n+      return 2;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return &_DYNAMIC (via PT_DYNAMIC) in the inferior, or 0 if not present.  */\n+\n+template <typename T>\n+static CORE_ADDR\n+get_dynamic (netbsd_process_target *target, const pid_t pid)\n+{\n+  typedef typename std::conditional<sizeof(T) == sizeof(int64_t),\n+\t\t\t\t    Elf64_Phdr, Elf32_Phdr>::type phdr_type;\n+  const int phdr_size = sizeof (phdr_type);\n+\n+  CORE_ADDR phdr_memaddr;\n+  int num_phdr;\n+  if (get_phdr_phnum_from_proc_auxv<T> (pid, &phdr_memaddr, &num_phdr))\n+    return 0;\n+\n+  std::vector<unsigned char> phdr_buf;\n+  phdr_buf.resize (num_phdr * phdr_size);\n+\n+  if (target->read_memory (phdr_memaddr, phdr_buf.data (), phdr_buf.size ()))\n+    return 0;\n+\n+  /* Compute relocation: it is expected to be 0 for \"regular\" executables,\n+     non-zero for PIE ones.  */\n+  CORE_ADDR relocation = -1;\n+  for (int i = 0; relocation == -1 && i < num_phdr; i++)\n+    {\n+      phdr_type *const p = (phdr_type *) (phdr_buf.data() + i * phdr_size);\n+\n+      if (p->p_type == PT_PHDR)\n+\trelocation = phdr_memaddr - p->p_vaddr;\n+    }\n+\n+  if (relocation == -1)\n+    {\n+      /* PT_PHDR is optional, but necessary for PIE in general.  Fortunately\n+\t any real world executables, including PIE executables, have always\n+\t PT_PHDR present.  PT_PHDR is not present in some shared libraries or\n+\t in fpc (Free Pascal 2.4) binaries but neither of those have a need for\n+\t or present DT_DEBUG anyway (fpc binaries are statically linked).\n+\n+\t Therefore if there exists DT_DEBUG there is always also PT_PHDR.\n+\n+\t GDB could find RELOCATION also from AT_ENTRY - e_entry.  */\n+\n+      return 0;\n+    }\n+\n+  for (int i = 0; i < num_phdr; i++)\n+    {\n+      phdr_type *const p = (phdr_type *) (phdr_buf.data () + i * phdr_size);\n+\n+      if (p->p_type == PT_DYNAMIC)\n+\treturn p->p_vaddr + relocation;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return &_r_debug in the inferior, or -1 if not present.  Return value\n+   can be 0 if the inferior does not yet have the library list initialized.\n+   We look for DT_MIPS_RLD_MAP first.  MIPS executables use this instead of\n+   DT_DEBUG, although they sometimes contain an unused DT_DEBUG entry too.  */\n+\n+template <typename T>\n+static CORE_ADDR\n+get_r_debug (netbsd_process_target *target, const int pid)\n+{\n+  typedef typename std::conditional<sizeof(T) == sizeof(int64_t),\n+\t\t\t\t    Elf64_Dyn, Elf32_Dyn>::type dyn_type;\n+  const int dyn_size = sizeof (dyn_type);\n+  unsigned char buf[sizeof (dyn_type)];  /* The larger of the two.  */\n+  CORE_ADDR map = -1;\n+\n+  CORE_ADDR dynamic_memaddr = get_dynamic<T> (target, pid);\n+  if (dynamic_memaddr == 0)\n+    return map;\n+\n+  while (target->read_memory (dynamic_memaddr, buf, dyn_size) == 0)\n+    {\n+      dyn_type *const dyn = (dyn_type *) buf;\n+#if defined DT_MIPS_RLD_MAP\n+      union\n+      {\n+\tT map;\n+\tunsigned char buf[sizeof (T)];\n+      }\n+      rld_map;\n+\n+      if (dyn->d_tag == DT_MIPS_RLD_MAP)\n+\t{\n+\t  if (read_memory (dyn->d_un.d_val,\n+\t\t\t   rld_map.buf, sizeof (rld_map.buf)) == 0)\n+\t    return rld_map.map;\n+\t  else\n+\t    break;\n+\t}\n+#endif  /* DT_MIPS_RLD_MAP */\n+\n+      if (dyn->d_tag == DT_DEBUG && map == -1)\n+\tmap = dyn->d_un.d_val;\n+\n+      if (dyn->d_tag == DT_NULL)\n+\tbreak;\n+\n+      dynamic_memaddr += dyn_size;\n+    }\n+\n+  return map;\n+}\n+\n+/* Read one pointer from MEMADDR in the inferior.  */\n+\n+static int\n+read_one_ptr (netbsd_process_target *target, CORE_ADDR memaddr, CORE_ADDR *ptr,\n+\t      int ptr_size)\n+{\n+  /* Go through a union so this works on either big or little endian\n+     hosts, when the inferior's pointer size is smaller than the size\n+     of CORE_ADDR.  It is assumed the inferior's endianness is the\n+     same of the superior's.  */\n+\n+  union\n+  {\n+    CORE_ADDR core_addr;\n+    unsigned int ui;\n+    unsigned char uc;\n+  } addr;\n+\n+  int ret = target->read_memory (memaddr, &addr.uc, ptr_size);\n+  if (ret == 0)\n+    {\n+      if (ptr_size == sizeof (CORE_ADDR))\n+\t*ptr = addr.core_addr;\n+      else if (ptr_size == sizeof (unsigned int))\n+\t*ptr = addr.ui;\n+      else\n+\tgdb_assert_not_reached (\"unhandled pointer size\");\n+    }\n+  return ret;\n+}\n+\n+/* Construct qXfer:libraries-svr4:read reply.  */\n+\n+template <typename T>\n+int\n+netbsd_qxfer_libraries_svr4 (netbsd_process_target *target,\n+\t\t\t     const pid_t pid, const char *annex,\n+\t\t\t     unsigned char *readbuf,\n+\t\t\t     unsigned const char *writebuf,\n+\t\t\t     CORE_ADDR offset, int len)\n+{\n+  struct link_map_offsets\n+  {\n+    /* Offset and size of r_debug.r_version.  */\n+    int r_version_offset;\n+\n+    /* Offset and size of r_debug.r_map.  */\n+    int r_map_offset;\n+\n+    /* Offset to l_addr field in struct link_map.  */\n+    int l_addr_offset;\n+\n+    /* Offset to l_name field in struct link_map.  */\n+    int l_name_offset;\n+\n+    /* Offset to l_ld field in struct link_map.  */\n+    int l_ld_offset;\n+\n+    /* Offset to l_next field in struct link_map.  */\n+    int l_next_offset;\n+\n+    /* Offset to l_prev field in struct link_map.  */\n+    int l_prev_offset;\n+  };\n+\n+  static const struct link_map_offsets lmo_32bit_offsets =\n+    {\n+      0,     /* r_version offset. */\n+      4,     /* r_debug.r_map offset.  */\n+      0,     /* l_addr offset in link_map.  */\n+      4,     /* l_name offset in link_map.  */\n+      8,     /* l_ld offset in link_map.  */\n+      12,    /* l_next offset in link_map.  */\n+      16     /* l_prev offset in link_map.  */\n+    };\n+\n+  static const struct link_map_offsets lmo_64bit_offsets =\n+    {\n+      0,     /* r_version offset. */\n+      8,     /* r_debug.r_map offset.  */\n+      0,     /* l_addr offset in link_map.  */\n+      8,     /* l_name offset in link_map.  */\n+      16,    /* l_ld offset in link_map.  */\n+      24,    /* l_next offset in link_map.  */\n+      32     /* l_prev offset in link_map.  */\n+    };\n+\n+  CORE_ADDR lm_addr = 0, lm_prev = 0;\n+  CORE_ADDR l_name, l_addr, l_ld, l_next, l_prev;\n+  int header_done = 0;\n+\n+  const struct link_map_offsets *lmo\n+    = ((sizeof (T) == sizeof (int64_t))\n+       ? &lmo_64bit_offsets : &lmo_32bit_offsets);\n+  int ptr_size = sizeof (T);\n+\n+  while (annex[0] != '\\0')\n+    {\n+      const char *sep = strchr (annex, '=');\n+      if (sep == nullptr)\n+\tbreak;\n+\n+      int name_len = sep - annex;\n+      CORE_ADDR *addrp;\n+      if (name_len == 5 && startswith (annex, \"start\"))\n+\taddrp = &lm_addr;\n+      else if (name_len == 4 && startswith (annex, \"prev\"))\n+\taddrp = &lm_prev;\n+      else\n+\t{\n+\t  annex = strchr (sep, ';');\n+\t  if (annex == nullptr)\n+\t    break;\n+\t  annex++;\n+\t  continue;\n+\t}\n+\n+      annex = decode_address_to_semicolon (addrp, sep + 1);\n+    }\n+\n+  if (lm_addr == 0)\n+    {\n+      CORE_ADDR r_debug = get_r_debug<T> (target, pid);\n+\n+      /* We failed to find DT_DEBUG.  Such situation will not change\n+\t for this inferior - do not retry it.  Report it to GDB as\n+\t E01, see for the reasons at the GDB solib-svr4.c side.  */\n+      if (r_debug == (CORE_ADDR) -1)\n+\treturn -1;\n+\n+      if (r_debug != 0)\n+\t{\n+\t  CORE_ADDR map_offset = r_debug + lmo->r_map_offset;\n+\t  if (read_one_ptr (target, map_offset, &lm_addr, ptr_size) != 0)\n+\t    warning (\"unable to read r_map from %s\",\n+\t\t     core_addr_to_string (map_offset));\n+\t}\n+    }\n+\n+  std::string document = \"<library-list-svr4 version=\\\"1.0\\\"\";\n+\n+  while (lm_addr\n+\t && read_one_ptr (target, lm_addr + lmo->l_name_offset,\n+\t\t\t  &l_name, ptr_size) == 0\n+\t && read_one_ptr (target, lm_addr + lmo->l_addr_offset,\n+\t\t\t  &l_addr, ptr_size) == 0\n+\t && read_one_ptr (target, lm_addr + lmo->l_ld_offset,\n+\t\t\t  &l_ld, ptr_size) == 0\n+\t && read_one_ptr (target, lm_addr + lmo->l_prev_offset,\n+\t\t\t  &l_prev, ptr_size) == 0\n+\t && read_one_ptr (target, lm_addr + lmo->l_next_offset,\n+\t\t\t  &l_next, ptr_size) == 0)\n+    {\n+      if (lm_prev != l_prev)\n+\t{\n+\t  warning (\"Corrupted shared library list: 0x%lx != 0x%lx\",\n+\t\t   (long) lm_prev, (long) l_prev);\n+\t  break;\n+\t}\n+\n+      /* Ignore the first entry even if it has valid name as the first entry\n+\t corresponds to the main executable.  The first entry should not be\n+\t skipped if the dynamic loader was loaded late by a static executable\n+\t (see solib-svr4.c parameter ignore_first).  But in such case the main\n+\t executable does not have PT_DYNAMIC present and this function already\n+\t exited above due to failed get_r_debug.  */\n+      if (lm_prev == 0)\n+\tstring_appendf (document, \" main-lm=\\\"0x%lx\\\"\",\n+\t\t\t(unsigned long) lm_addr);\n+      else\n+\t{\n+\t  unsigned char libname[PATH_MAX];\n+\n+\t  /* Not checking for error because reading may stop before\n+\t     we've got PATH_MAX worth of characters.  */\n+\t  libname[0] = '\\0';\n+\t  target->read_memory (l_name, libname, sizeof (libname) - 1);\n+\t  libname[sizeof (libname) - 1] = '\\0';\n+\t  if (libname[0] != '\\0')\n+\t    {\n+\t      if (!header_done)\n+\t\t{\n+\t\t  /* Terminate `<library-list-svr4'.  */\n+\t\t  document += '>';\n+\t\t  header_done = 1;\n+\t\t}\n+\n+\t      string_appendf (document, \"<library name=\\\"\");\n+\t      xml_escape_text_append (&document, (char *) libname);\n+\t      string_appendf (document, \"\\\" lm=\\\"0x%lx\\\" \"\n+\t\t\t      \"l_addr=\\\"0x%lx\\\" l_ld=\\\"0x%lx\\\"/>\",\n+\t\t\t      (unsigned long) lm_addr, (unsigned long) l_addr,\n+\t\t\t      (unsigned long) l_ld);\n+\t    }\n+\t}\n+\n+      lm_prev = lm_addr;\n+      lm_addr = l_next;\n+    }\n+\n+  if (!header_done)\n+    {\n+      /* Empty list; terminate `<library-list-svr4'.  */\n+      document += \"/>\";\n+    }\n+  else\n+    document += \"</library-list-svr4>\";\n+\n+  int document_len = document.length ();\n+  if (offset < document_len)\n+    document_len -= offset;\n+  else\n+    document_len = 0;\n+  if (len > document_len)\n+    len = document_len;\n+\n+  memcpy (readbuf, document.data () + offset, len);\n+\n+  return len;\n+}\n+\n+/* Return true if FILE is a 64-bit ELF file,\n+   false if the file is not a 64-bit ELF file,\n+   and error if the file is not accessible or doesn't exist.  */\n+\n+static bool\n+elf_64_file_p (const char *file)\n+{\n+  int fd = gdb::handle_eintr<int> (-1, ::open, file, O_RDONLY);\n+  if (fd < 0)\n+    perror_with_name ((\"open\"));\n+\n+  Elf64_Ehdr header;\n+  ssize_t ret = gdb::handle_eintr<ssize_t> (-1, ::read, fd, &header, sizeof (header));\n+  if (ret == -1)\n+    perror_with_name ((\"read\"));\n+  gdb::handle_eintr<int> (-1, ::close, fd);\n+  if (ret != sizeof (header))\n+    error (\"Cannot read ELF file header: %s\", file);\n+\n+  if (header.e_ident[EI_MAG0] != ELFMAG0\n+      || header.e_ident[EI_MAG1] != ELFMAG1\n+      || header.e_ident[EI_MAG2] != ELFMAG2\n+      || header.e_ident[EI_MAG3] != ELFMAG3)\n+    error (\"Unrecognized ELF file header: %s\", file);\n+\n+  return header.e_ident[EI_CLASS] == ELFCLASS64;\n+}\n+\n+/* Construct qXfer:libraries-svr4:read reply.  */\n+\n+int\n+netbsd_process_target::qxfer_libraries_svr4 (const char *annex,\n+\t\t\t\t\t     unsigned char *readbuf,\n+\t\t\t\t\t     unsigned const char *writebuf,\n+\t\t\t\t\t     CORE_ADDR offset, int len)\n+{\n+  if (writebuf != nullptr)\n+    return -2;\n+  if (readbuf == nullptr)\n+    return -1;\n+\n+  struct process_info *proc = current_process ();\n+  pid_t pid = proc->pid;\n+  bool is_elf64 = elf_64_file_p (netbsd_nat::pid_to_exec_file (pid));\n+\n+  if (is_elf64)\n+    return netbsd_qxfer_libraries_svr4<int64_t> (this, pid, annex, readbuf,\n+\t\t\t\t\t\t writebuf, offset, len);\n+  else\n+    return netbsd_qxfer_libraries_svr4<int32_t> (this, pid, annex, readbuf,\n+\t\t\t\t\t\t writebuf, offset, len);\n+}\n+\n+/* Implement the supports_qxfer_libraries_svr4 target_ops method.  */\n+\n+bool\n+netbsd_process_target::supports_qxfer_libraries_svr4 ()\n+{\n+  return true;\n+}\n+\n+/* Return the name of a file that can be opened to get the symbols for\n+   the child process identified by PID.  */\n+\n+char *\n+netbsd_process_target::pid_to_exec_file (pid_t pid)\n+{\n+  return const_cast<char *> (netbsd_nat::pid_to_exec_file (pid));\n+}\n+\n+/* Implementation of the target_ops method \"supports_pid_to_exec_file\".  */\n+\n+bool\n+netbsd_process_target::supports_pid_to_exec_file ()\n+{\n+  return true;\n+}\n+\n+/* Implementation of the target_ops method \"supports_hardware_single_step\".  */\n+bool\n+netbsd_process_target::supports_hardware_single_step ()\n+{\n+  return true;\n+}\n+\n+/* Implementation of the target_ops method \"sw_breakpoint_from_kind\".  */\n+\n+const gdb_byte *\n+netbsd_process_target::sw_breakpoint_from_kind (int kind, int *size)\n+{\n+  static gdb_byte brkpt[PTRACE_BREAKPOINT_SIZE] = {*PTRACE_BREAKPOINT};\n+\n+  *size = PTRACE_BREAKPOINT_SIZE;\n+\n+  return brkpt;\n+}\n+\n+/* Implement the thread_name target_ops method.  */\n+\n+const char *\n+netbsd_process_target::thread_name (ptid_t ptid)\n+{\n+  return netbsd_nat::thread_name (ptid);\n+}\n+\n+/* Implement the supports_catch_syscall target_ops method.  */\n+\n+bool\n+netbsd_process_target::supports_catch_syscall ()\n+{\n+  return true;\n+}\n+\n+/* Implement the supports_read_auxv target_ops method.  */\n+\n+bool\n+netbsd_process_target::supports_read_auxv ()\n+{\n+  return true;\n+}\n+\n+/* The NetBSD target ops object.  */\n+\n+static netbsd_process_target the_netbsd_target;\n+\n+void\n+initialize_low ()\n+{\n+  set_target_ops (&the_netbsd_target);\n+  the_low_target.arch_setup ();\n+}"
    },
    {
      "sha": "3d2ec345a41e873ddf5fb685dd0f82b4fe8c1ae1",
      "filename": "gdbserver/netbsd-low.h",
      "status": "added",
      "additions": 154,
      "deletions": 0,
      "changes": 154,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/netbsd-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62ba50486f1146f0cfd33074fc127fe00a02e87e/gdbserver/netbsd-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/netbsd-low.h?ref=62ba50486f1146f0cfd33074fc127fe00a02e87e",
      "patch": "@@ -0,0 +1,154 @@\n+/* Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDBSERVER_NETBSD_LOW_H\n+#define GDBSERVER_NETBSD_LOW_H\n+\n+struct regcache;\n+struct target_desc;\n+\n+/*  Some information relative to a given register set.   */\n+\n+struct netbsd_regset_info\n+{\n+  /* The ptrace request needed to get/set registers of this set.  */\n+  int get_request, set_request;\n+  /* The size of the register set.  */\n+  int size;\n+  /* Fill the buffer BUF from the contents of the given REGCACHE.  */\n+  void (*fill_function) (struct regcache *regcache, char *buf);\n+  /* Store the register value in BUF in the given REGCACHE.  */\n+  void (*store_function) (struct regcache *regcache, const char *buf);\n+};\n+\n+/* A list of regsets for the target being debugged, terminated by an entry\n+   where the size is negative.\n+\n+   This list should be created by the target-specific code.  */\n+\n+extern struct netbsd_regset_info netbsd_target_regsets[];\n+\n+/* The target-specific operations for NetBSD support.  */\n+\n+struct netbsd_target_ops\n+{\n+  /* Architecture-specific setup.  */\n+  void (*arch_setup) ();\n+};\n+\n+/* Target ops definitions for a NetBSD target.  */\n+\n+class netbsd_process_target : public process_stratum_target\n+{\n+public:\n+\n+  int create_inferior (const char *program,\n+\t\t       const std::vector<char *> &program_args) override;\n+\n+  void post_create_inferior () override;\n+\n+  int attach (unsigned long pid) override;\n+\n+  int kill (process_info *proc) override;\n+\n+  int detach (process_info *proc) override;\n+\n+  void mourn (process_info *proc) override;\n+\n+  void join (int pid) override;\n+\n+  bool thread_alive (ptid_t pid) override;\n+\n+  void resume (thread_resume *resume_info, size_t n) override;\n+\n+  ptid_t wait (ptid_t ptid, target_waitstatus *status,\n+\t       int options) override;\n+\n+  void fetch_registers (regcache *regcache, int regno) override;\n+\n+  void store_registers (regcache *regcache, int regno) override;\n+\n+  int read_memory (CORE_ADDR memaddr, unsigned char *myaddr,\n+\t\t   int len) override;\n+\n+  int write_memory (CORE_ADDR memaddr, const unsigned char *myaddr,\n+\t\t    int len) override;\n+\n+  void request_interrupt () override;\n+\n+  bool supports_read_auxv () override;\n+\n+  int read_auxv (CORE_ADDR offset, unsigned char *myaddr,\n+\t\t unsigned int len) override;\n+\n+  bool supports_hardware_single_step () override;\n+\n+  const gdb_byte *sw_breakpoint_from_kind (int kind, int *size) override;\n+\n+  bool supports_z_point_type (char z_type) override;\n+\n+  int insert_point (enum raw_bkpt_type type, CORE_ADDR addr,\n+\t\t    int size, struct raw_breakpoint *bp) override;\n+\n+  int remove_point (enum raw_bkpt_type type, CORE_ADDR addr,\n+\t\t    int size, struct raw_breakpoint *bp) override;\n+\n+  bool stopped_by_sw_breakpoint () override;\n+\n+  bool supports_qxfer_siginfo () override;\n+\n+  int qxfer_siginfo (const char *annex, unsigned char *readbuf,\n+\t\t     unsigned const char *writebuf, CORE_ADDR offset,\n+\t\t     int len) override;\n+\n+  bool supports_stopped_by_sw_breakpoint () override;\n+\n+  bool supports_non_stop () override;\n+\n+  bool supports_multi_process () override;\n+\n+  bool supports_fork_events () override;\n+\n+  bool supports_vfork_events () override;\n+\n+  bool supports_exec_events () override;\n+\n+  bool supports_disable_randomization () override;\n+\n+  bool supports_qxfer_libraries_svr4 () override;\n+\n+  int qxfer_libraries_svr4 (const char*, unsigned char*, const unsigned char*,\n+\t\t\t    CORE_ADDR, int) override;\n+\n+  bool supports_pid_to_exec_file () override;\n+\n+  char *pid_to_exec_file (int pid) override;\n+\n+  const char *thread_name (ptid_t thread) override;\n+\n+  bool supports_catch_syscall () override;\n+};\n+\n+/* The inferior's target description.  This is a global because the\n+   NetBSD ports support neither bi-arch nor multi-process.  */\n+\n+extern struct netbsd_target_ops the_low_target;\n+\n+/* XXX: multilib */\n+extern const struct target_desc *netbsd_tdesc;\n+\n+#endif /* GDBSERVER_NETBSD_LOW_H */"
    }
  ]
}