{
  "sha": "b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjIyYTdjNmFiNjE3M2ZlNGZhMTM1MmUxNGQwMGEyMzRiYmY1MDM0Ng==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2018-11-24T21:22:25Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-10T01:28:15Z"
    },
    "message": "Remove ALL_OBJFILE_PSYMTABS\n\nThis removes the ALL_OBJFILE_PSYMTABS macro, replacing its uses with\nranged for loops.\n\ngdb/ChangeLog\n2019-01-09  Tom Tromey  <tom@tromey.com>\n\n\t* dbxread.c (dbx_end_psymtab): Use objfile_psymtabs.\n\t* mdebugread.c (parse_partial_symbols): Use objfile_psymtabs.\n\t* psymtab.c (ALL_OBJFILE_PSYMTABS_REQUIRED): Remove.\n\t(psym_map_symtabs_matching_filename, find_pc_sect_psymtab)\n\t(psym_lookup_symbol, psym_find_last_source_symtab)\n\t(psym_forget_cached_source_info, psym_print_stats)\n\t(psym_expand_symtabs_for_function, psym_expand_all_symtabs)\n\t(psym_expand_symtabs_with_fullname, psym_map_symbol_filenames)\n\t(psym_map_matching_symbols, psym_expand_symtabs_matching)\n\t(psym_find_compunit_symtab_by_address)\n\t(maintenance_print_psymbols, maintenance_info_psymtabs)\n\t(maintenance_check_psymtabs): Use ranged for.\n\t* psymtab.h (class objfile_psymtabs): New.\n\t(require_partial_symbols): Return objfile_psymtabs.\n\t* psympriv.h (ALL_OBJFILE_PSYMTABS): Remove.",
    "tree": {
      "sha": "db8a06cfd47bf49629796ab9f06fc4a1947ef2e3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/db8a06cfd47bf49629796ab9f06fc4a1947ef2e3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3b9d3ac236dcc418619785e0660fc0063e6489b8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3b9d3ac236dcc418619785e0660fc0063e6489b8"
    }
  ],
  "stats": {
    "total": 351,
    "additions": 168,
    "deletions": 183
  },
  "files": [
    {
      "sha": "35c34d569126c7676aaa97ba3856afa49a351659",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
      "patch": "@@ -1,3 +1,21 @@\n+2019-01-09  Tom Tromey  <tom@tromey.com>\n+\n+\t* dbxread.c (dbx_end_psymtab): Use objfile_psymtabs.\n+\t* mdebugread.c (parse_partial_symbols): Use objfile_psymtabs.\n+\t* psymtab.c (ALL_OBJFILE_PSYMTABS_REQUIRED): Remove.\n+\t(psym_map_symtabs_matching_filename, find_pc_sect_psymtab)\n+\t(psym_lookup_symbol, psym_find_last_source_symtab)\n+\t(psym_forget_cached_source_info, psym_print_stats)\n+\t(psym_expand_symtabs_for_function, psym_expand_all_symtabs)\n+\t(psym_expand_symtabs_with_fullname, psym_map_symbol_filenames)\n+\t(psym_map_matching_symbols, psym_expand_symtabs_matching)\n+\t(psym_find_compunit_symtab_by_address)\n+\t(maintenance_print_psymbols, maintenance_info_psymtabs)\n+\t(maintenance_check_psymtabs): Use ranged for.\n+\t* psymtab.h (class objfile_psymtabs): New.\n+\t(require_partial_symbols): Return objfile_psymtabs.\n+\t* psympriv.h (ALL_OBJFILE_PSYMTABS): Remove.\n+\n 2019-01-09  Tom Tromey  <tom@tromey.com>\n \n \t* symfile.c (overlay_invalidate_all, find_pc_overlay)"
    },
    {
      "sha": "e3a952022cceb24b3a79235490ad4b4db54f6fcb",
      "filename": "gdb/dbxread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 5,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/dbxread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/dbxread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dbxread.c?ref=b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
      "patch": "@@ -2014,18 +2014,14 @@ dbx_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,\n     pst->set_text_low (pst->raw_text_high ());\n   else\n     {\n-      struct partial_symtab *p1;\n-\n       /* If we know our own starting text address, then walk through all other\n          psymtabs for this objfile, and if any didn't know their ending text\n          address, set it to our starting address.  Take care to not set our\n          own ending address to our starting address.  */\n \n-      ALL_OBJFILE_PSYMTABS (objfile, p1)\n-      {\n+      for (partial_symtab *p1 : objfile_psymtabs (objfile))\n \tif (!p1->text_high_valid && p1->text_low_valid && p1 != pst)\n \t  p1->set_text_high (pst->raw_text_low ());\n-      }\n     }\n \n   /* End of kludge for patching Solaris textlow and texthigh.  */"
    },
    {
      "sha": "0583ce2f3ac123f66bed9ec4bef30ee0aa635219",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
      "patch": "@@ -3681,17 +3681,17 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n \t  && save_pst->text_low_valid\n \t  && !(objfile->flags & OBJF_REORDERED))\n \t{\n-\t  ALL_OBJFILE_PSYMTABS (objfile, pst)\n-\t  {\n-\t    if (save_pst != pst\n-\t\t&& save_pst->raw_text_low () >= pst->raw_text_low ()\n-\t\t&& save_pst->raw_text_low () < pst->raw_text_high ()\n-\t\t&& save_pst->raw_text_high () > pst->raw_text_high ())\n-\t      {\n-\t\tobjfile->flags |= OBJF_REORDERED;\n-\t\tbreak;\n-\t      }\n-\t  }\n+\t  for (partial_symtab *iter : objfile_psymtabs (objfile))\n+\t    {\n+\t      if (save_pst != iter\n+\t\t  && save_pst->raw_text_low () >= iter->raw_text_low ()\n+\t\t  && save_pst->raw_text_low () < iter->raw_text_high ()\n+\t\t  && save_pst->raw_text_high () > iter->raw_text_high ())\n+\t\t{\n+\t\t  objfile->flags |= OBJF_REORDERED;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t}\n     }\n "
    },
    {
      "sha": "e28adfed4ab309346d3372dae21d8d784fc891dc",
      "filename": "gdb/psympriv.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/psympriv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/psympriv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psympriv.h?ref=b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
      "patch": "@@ -331,9 +331,4 @@ class psymtab_discarder\n   struct partial_symtab *m_psymtab;\n };\n \n-/* Traverse all psymtabs in one objfile.  */\n-\n-#define\tALL_OBJFILE_PSYMTABS(objfile, p) \\\n-    for ((p) = (objfile) -> psymtabs; (p) != NULL; (p) = (p) -> next)\n-\n #endif /* PSYMPRIV_H */"
    },
    {
      "sha": "d5bd5b1b2db44cd540feda0663f2ea85ca67598c",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 120,
      "deletions": 158,
      "changes": 278,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
      "patch": "@@ -19,8 +19,8 @@\n \n #include \"defs.h\"\n #include \"symtab.h\"\n-#include \"psympriv.h\"\n #include \"objfiles.h\"\n+#include \"psympriv.h\"\n #include \"block.h\"\n #include \"filenames.h\"\n #include \"source.h\"\n@@ -65,10 +65,9 @@ static struct partial_symbol *find_pc_sect_psymbol (struct objfile *,\n static struct compunit_symtab *psymtab_to_symtab (struct objfile *objfile,\n \t\t\t\t\t\t  struct partial_symtab *pst);\n \n-/* Ensure that the partial symbols for OBJFILE have been loaded.  This\n-   function always returns its argument, as a convenience.  */\n+/* See psymtab.h.  */\n \n-struct objfile *\n+objfile_psymtabs\n require_partial_symbols (struct objfile *objfile, int verbose)\n {\n   if ((objfile->flags & OBJF_PSYMTABS_READ) == 0)\n@@ -93,21 +92,9 @@ require_partial_symbols (struct objfile *objfile, int verbose)\n \t}\n     }\n \n-  return objfile;\n+  return objfile_psymtabs (objfile);\n }\n \n-/* Traverse all psymtabs in one objfile, requiring that the psymtabs\n-   be read in.  */\n-\n-#define ALL_OBJFILE_PSYMTABS_REQUIRED(objfile, p)\t\t\\\n-    for ((p) = require_partial_symbols (objfile, 1)->psymtabs;\t\\\n-\t (p) != NULL;\t\t\t\t\t\t\\\n-\t (p) = (p)->next)\n-\n-/* We want to make sure this file always requires psymtabs.  */\n-\n-#undef ALL_OBJFILE_PSYMTABS\n-\n /* Helper function for psym_map_symtabs_matching_filename that\n    expands the symtabs and calls the iterator.  */\n \n@@ -146,57 +133,56 @@ psym_map_symtabs_matching_filename\n    const char *real_path,\n    gdb::function_view<bool (symtab *)> callback)\n {\n-  struct partial_symtab *pst;\n   const char *name_basename = lbasename (name);\n \n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)\n-  {\n-    /* We can skip shared psymtabs here, because any file name will be\n-       attached to the unshared psymtab.  */\n-    if (pst->user != NULL)\n-      continue;\n-\n-    /* Anonymous psymtabs don't have a file name.  */\n-    if (pst->anonymous)\n-      continue;\n+  for (partial_symtab *pst : require_partial_symbols (objfile, 1))\n+    {\n+      /* We can skip shared psymtabs here, because any file name will be\n+\t attached to the unshared psymtab.  */\n+      if (pst->user != NULL)\n+\tcontinue;\n \n-    if (compare_filenames_for_search (pst->filename, name))\n-      {\n-\tif (partial_map_expand_apply (objfile, name, real_path,\n-\t\t\t\t      pst, callback))\n-\t  return true;\n+      /* Anonymous psymtabs don't have a file name.  */\n+      if (pst->anonymous)\n \tcontinue;\n-      }\n \n-    /* Before we invoke realpath, which can get expensive when many\n-       files are involved, do a quick comparison of the basenames.  */\n-    if (! basenames_may_differ\n-\t&& FILENAME_CMP (name_basename, lbasename (pst->filename)) != 0)\n-      continue;\n+      if (compare_filenames_for_search (pst->filename, name))\n+\t{\n+\t  if (partial_map_expand_apply (objfile, name, real_path,\n+\t\t\t\t\tpst, callback))\n+\t    return true;\n+\t  continue;\n+\t}\n \n-    if (compare_filenames_for_search (psymtab_to_fullname (pst), name))\n-      {\n-\tif (partial_map_expand_apply (objfile, name, real_path,\n-\t\t\t\t      pst, callback))\n-\t  return true;\n+      /* Before we invoke realpath, which can get expensive when many\n+\t files are involved, do a quick comparison of the basenames.  */\n+      if (! basenames_may_differ\n+\t  && FILENAME_CMP (name_basename, lbasename (pst->filename)) != 0)\n \tcontinue;\n-      }\n \n-    /* If the user gave us an absolute path, try to find the file in\n-       this symtab and use its absolute path.  */\n-    if (real_path != NULL)\n-      {\n-\tgdb_assert (IS_ABSOLUTE_PATH (real_path));\n-\tgdb_assert (IS_ABSOLUTE_PATH (name));\n-\tif (filename_cmp (psymtab_to_fullname (pst), real_path) == 0)\n-\t  {\n-\t    if (partial_map_expand_apply (objfile, name, real_path,\n-\t\t\t\t\t  pst, callback))\n-\t      return true;\n-\t    continue;\n-\t  }\n-      }\n-  }\n+      if (compare_filenames_for_search (psymtab_to_fullname (pst), name))\n+\t{\n+\t  if (partial_map_expand_apply (objfile, name, real_path,\n+\t\t\t\t\tpst, callback))\n+\t    return true;\n+\t  continue;\n+\t}\n+\n+      /* If the user gave us an absolute path, try to find the file in\n+\t this symtab and use its absolute path.  */\n+      if (real_path != NULL)\n+\t{\n+\t  gdb_assert (IS_ABSOLUTE_PATH (real_path));\n+\t  gdb_assert (IS_ABSOLUTE_PATH (name));\n+\t  if (filename_cmp (psymtab_to_fullname (pst), real_path) == 0)\n+\t    {\n+\t      if (partial_map_expand_apply (objfile, name, real_path,\n+\t\t\t\t\t    pst, callback))\n+\t\treturn true;\n+\t      continue;\n+\t    }\n+\t}\n+    }\n \n   return false;\n }\n@@ -289,7 +275,6 @@ find_pc_sect_psymtab (struct objfile *objfile, CORE_ADDR pc,\n \t\t      struct obj_section *section,\n \t\t      struct bound_minimal_symbol msymbol)\n {\n-  struct partial_symtab *pst;\n   CORE_ADDR baseaddr = ANOFFSET (objfile->section_offsets,\n \t\t\t\t SECT_OFF_TEXT (objfile));\n \n@@ -298,8 +283,9 @@ find_pc_sect_psymtab (struct objfile *objfile, CORE_ADDR pc,\n \n   if (objfile->psymtabs_addrmap != NULL)\n     {\n-      pst = ((struct partial_symtab *)\n-\t     addrmap_find (objfile->psymtabs_addrmap, pc - baseaddr));\n+      struct partial_symtab *pst\n+\t= ((struct partial_symtab *)\n+\t   addrmap_find (objfile->psymtabs_addrmap, pc - baseaddr));\n       if (pst != NULL)\n \t{\n \t  /* FIXME: addrmaps currently do not handle overlayed sections,\n@@ -341,7 +327,7 @@ find_pc_sect_psymtab (struct objfile *objfile, CORE_ADDR pc,\n      its CUs may be missing in PSYMTABS_ADDRMAP as they may be varying\n      debug info type in single OBJFILE.  */\n \n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)\n+  for (partial_symtab *pst : require_partial_symbols (objfile, 1))\n     if (!pst->psymtabs_addrmap_supported\n \t&& pc >= pst->text_low (objfile) && pc < pst->text_high (objfile))\n       {\n@@ -458,43 +444,42 @@ psym_lookup_symbol (struct objfile *objfile,\n \t\t    int block_index, const char *name,\n \t\t    const domain_enum domain)\n {\n-  struct partial_symtab *ps;\n   const int psymtab_index = (block_index == GLOBAL_BLOCK ? 1 : 0);\n   struct compunit_symtab *stab_best = NULL;\n \n   lookup_name_info lookup_name (name, symbol_name_match_type::FULL);\n \n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n-  {\n-    if (!ps->readin && lookup_partial_symbol (objfile, ps, name,\n-\t\t\t\t\t      psymtab_index, domain))\n-      {\n-\tstruct symbol *sym, *with_opaque = NULL;\n-\tstruct compunit_symtab *stab = psymtab_to_symtab (objfile, ps);\n-\t/* Note: While psymtab_to_symtab can return NULL if the partial symtab\n-\t   is empty, we can assume it won't here because lookup_partial_symbol\n-\t   succeeded.  */\n-\tconst struct blockvector *bv = COMPUNIT_BLOCKVECTOR (stab);\n-\tstruct block *block = BLOCKVECTOR_BLOCK (bv, block_index);\n-\n-\tsym = block_find_symbol (block, name, domain,\n-\t\t\t\t block_find_non_opaque_type_preferred,\n-\t\t\t\t &with_opaque);\n-\n-\t/* Some caution must be observed with overloaded functions\n-\t   and methods, since the index will not contain any overload\n-\t   information (but NAME might contain it).  */\n-\n-\tif (sym != NULL\n-\t    && SYMBOL_MATCHES_SEARCH_NAME (sym, lookup_name))\n-\t  return stab;\n-\tif (with_opaque != NULL\n-\t    && SYMBOL_MATCHES_SEARCH_NAME (with_opaque, lookup_name))\n-\t  stab_best = stab;\n-\n-\t/* Keep looking through other psymtabs.  */\n-      }\n-  }\n+  for (partial_symtab *ps : require_partial_symbols (objfile, 1))\n+    {\n+      if (!ps->readin && lookup_partial_symbol (objfile, ps, name,\n+\t\t\t\t\t\tpsymtab_index, domain))\n+\t{\n+\t  struct symbol *sym, *with_opaque = NULL;\n+\t  struct compunit_symtab *stab = psymtab_to_symtab (objfile, ps);\n+\t  /* Note: While psymtab_to_symtab can return NULL if the\n+\t     partial symtab is empty, we can assume it won't here\n+\t     because lookup_partial_symbol succeeded.  */\n+\t  const struct blockvector *bv = COMPUNIT_BLOCKVECTOR (stab);\n+\t  struct block *block = BLOCKVECTOR_BLOCK (bv, block_index);\n+\n+\t  sym = block_find_symbol (block, name, domain,\n+\t\t\t\t   block_find_non_opaque_type_preferred,\n+\t\t\t\t   &with_opaque);\n+\n+\t  /* Some caution must be observed with overloaded functions\n+\t     and methods, since the index will not contain any overload\n+\t     information (but NAME might contain it).  */\n+\n+\t  if (sym != NULL\n+\t      && SYMBOL_MATCHES_SEARCH_NAME (sym, lookup_name))\n+\t    return stab;\n+\t  if (with_opaque != NULL\n+\t      && SYMBOL_MATCHES_SEARCH_NAME (with_opaque, lookup_name))\n+\t    stab_best = stab;\n+\n+\t  /* Keep looking through other psymtabs.  */\n+\t}\n+    }\n \n   return stab_best;\n }\n@@ -752,10 +737,9 @@ psymtab_to_symtab (struct objfile *objfile, struct partial_symtab *pst)\n static struct symtab *\n psym_find_last_source_symtab (struct objfile *ofp)\n {\n-  struct partial_symtab *ps;\n   struct partial_symtab *cs_pst = NULL;\n \n-  ALL_OBJFILE_PSYMTABS_REQUIRED (ofp, ps)\n+  for (partial_symtab *ps : require_partial_symbols (ofp, 1))\n     {\n       const char *name = ps->filename;\n       int len = strlen (name);\n@@ -791,9 +775,7 @@ psym_find_last_source_symtab (struct objfile *ofp)\n static void\n psym_forget_cached_source_info (struct objfile *objfile)\n {\n-  struct partial_symtab *pst;\n-\n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)\n+  for (partial_symtab *pst : require_partial_symbols (objfile, 1))\n     {\n       if (pst->fullname != NULL)\n \t{\n@@ -973,10 +955,9 @@ static void\n psym_print_stats (struct objfile *objfile)\n {\n   int i;\n-  struct partial_symtab *ps;\n \n   i = 0;\n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n+  for (partial_symtab *ps : require_partial_symbols (objfile, 1))\n     {\n       if (ps->readin == 0)\n \ti++;\n@@ -1016,19 +997,17 @@ static void\n psym_expand_symtabs_for_function (struct objfile *objfile,\n \t\t\t\t  const char *func_name)\n {\n-  struct partial_symtab *ps;\n-\n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n-  {\n-    if (ps->readin)\n-      continue;\n+  for (partial_symtab *ps : require_partial_symbols (objfile, 1))\n+    {\n+      if (ps->readin)\n+\tcontinue;\n \n-    if ((lookup_partial_symbol (objfile, ps, func_name, 1, VAR_DOMAIN)\n-\t != NULL)\n-\t|| (lookup_partial_symbol (objfile, ps, func_name, 0, VAR_DOMAIN)\n-\t    != NULL))\n-      psymtab_to_symtab (objfile, ps);\n-  }\n+      if ((lookup_partial_symbol (objfile, ps, func_name, 1, VAR_DOMAIN)\n+\t   != NULL)\n+\t  || (lookup_partial_symbol (objfile, ps, func_name, 0, VAR_DOMAIN)\n+\t      != NULL))\n+\tpsymtab_to_symtab (objfile, ps);\n+    }\n }\n \n /* Psymtab version of expand_all_symtabs.  See its definition in\n@@ -1037,12 +1016,8 @@ psym_expand_symtabs_for_function (struct objfile *objfile,\n static void\n psym_expand_all_symtabs (struct objfile *objfile)\n {\n-  struct partial_symtab *psymtab;\n-\n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, psymtab)\n-    {\n-      psymtab_to_symtab (objfile, psymtab);\n-    }\n+  for (partial_symtab *psymtab : require_partial_symbols (objfile, 1))\n+    psymtab_to_symtab (objfile, psymtab);\n }\n \n /* Psymtab version of expand_symtabs_with_fullname.  See its definition in\n@@ -1052,9 +1027,7 @@ static void\n psym_expand_symtabs_with_fullname (struct objfile *objfile,\n \t\t\t\t   const char *fullname)\n {\n-  struct partial_symtab *p;\n-\n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, p)\n+  for (partial_symtab *p : require_partial_symbols (objfile, 1))\n     {\n       /* Anonymous psymtabs don't have a name of a source file.  */\n       if (p->anonymous)\n@@ -1077,9 +1050,7 @@ psym_map_symbol_filenames (struct objfile *objfile,\n \t\t\t   symbol_filename_ftype *fun, void *data,\n \t\t\t   int need_fullname)\n {\n-  struct partial_symtab *ps;\n-\n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n+  for (partial_symtab *ps : require_partial_symbols (objfile, 1))\n     {\n       const char *fullname;\n \n@@ -1192,9 +1163,8 @@ psym_map_matching_symbols (struct objfile *objfile,\n \t\t\t   symbol_compare_ftype *ordered_compare)\n {\n   const int block_kind = global ? GLOBAL_BLOCK : STATIC_BLOCK;\n-  struct partial_symtab *ps;\n \n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n+  for (partial_symtab *ps : require_partial_symbols (objfile, 1))\n     {\n       QUIT;\n       if (ps->readin\n@@ -1317,17 +1287,13 @@ psym_expand_symtabs_matching\n    gdb::function_view<expand_symtabs_exp_notify_ftype> expansion_notify,\n    enum search_domain domain)\n {\n-  struct partial_symtab *ps;\n-\n   lookup_name_info lookup_name = lookup_name_in.make_ignore_params ();\n \n   /* Clear the search flags.  */\n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n-    {\n-      ps->searched_flag = PST_NOT_SEARCHED;\n-    }\n+  for (partial_symtab *ps : require_partial_symbols (objfile, 1))\n+    ps->searched_flag = PST_NOT_SEARCHED;\n \n-  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n+  for (partial_symtab *ps : objfile_psymtabs (objfile))\n     {\n       QUIT;\n \n@@ -1416,23 +1382,21 @@ psym_find_compunit_symtab_by_address (struct objfile *objfile,\n {\n   if (objfile->psymbol_map.empty ())\n     {\n-      struct partial_symtab *pst;\n-\n       std::set<CORE_ADDR> seen_addrs;\n \n-      ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)\n-      {\n-\tpsym_fill_psymbol_map (objfile, pst,\n-\t\t\t       &seen_addrs,\n-\t\t\t       objfile->global_psymbols,\n-\t\t\t       pst->globals_offset,\n-\t\t\t       pst->n_global_syms);\n-\tpsym_fill_psymbol_map (objfile, pst,\n-\t\t\t       &seen_addrs,\n-\t\t\t       objfile->static_psymbols,\n-\t\t\t       pst->statics_offset,\n-\t\t\t       pst->n_static_syms);\n-      }\n+      for (partial_symtab *pst : require_partial_symbols (objfile, 1))\n+\t{\n+\t  psym_fill_psymbol_map (objfile, pst,\n+\t\t\t\t &seen_addrs,\n+\t\t\t\t objfile->global_psymbols,\n+\t\t\t\t pst->globals_offset,\n+\t\t\t\t pst->n_global_syms);\n+\t  psym_fill_psymbol_map (objfile, pst,\n+\t\t\t\t &seen_addrs,\n+\t\t\t\t objfile->static_psymbols,\n+\t\t\t\t pst->statics_offset,\n+\t\t\t\t pst->n_static_syms);\n+\t}\n \n       objfile->psymbol_map.shrink_to_fit ();\n \n@@ -1868,7 +1832,6 @@ maintenance_print_psymbols (const char *args, int from_tty)\n {\n   struct ui_file *outfile = gdb_stdout;\n   char *address_arg = NULL, *source_arg = NULL, *objfile_arg = NULL;\n-  struct partial_symtab *ps;\n   int i, outfile_idx, found;\n   CORE_ADDR pc = 0;\n   struct obj_section *section = NULL;\n@@ -1956,7 +1919,8 @@ maintenance_print_psymbols (const char *args, int from_tty)\n \n \t  /* We don't assume each pc has a unique objfile (this is for\n \t     debugging).  */\n-\t  ps = find_pc_sect_psymtab (objfile, pc, section, msymbol);\n+\t  struct partial_symtab *ps = find_pc_sect_psymtab (objfile, pc,\n+\t\t\t\t\t\t\t    section, msymbol);\n \t  if (ps != NULL)\n \t    {\n \t      if (!printed_objfile_header)\n@@ -1972,7 +1936,7 @@ maintenance_print_psymbols (const char *args, int from_tty)\n \t}\n       else\n \t{\n-\t  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n+\t  for (partial_symtab *ps : require_partial_symbols (objfile, 1))\n \t    {\n \t      int print_for_source = 0;\n \n@@ -2032,13 +1996,12 @@ maintenance_info_psymtabs (const char *regexp, int from_tty)\n     for (objfile *objfile : all_objfiles (pspace))\n       {\n \tstruct gdbarch *gdbarch = get_objfile_arch (objfile);\n-\tstruct partial_symtab *psymtab;\n \n \t/* We don't want to print anything for this objfile until we\n \t   actually find a symtab whose name matches.  */\n \tint printed_objfile_start = 0;\n \n-\tALL_OBJFILE_PSYMTABS_REQUIRED (objfile, psymtab)\n+\tfor (partial_symtab *psymtab : require_partial_symbols (objfile, 1))\n \t  {\n \t    QUIT;\n \n@@ -2139,13 +2102,12 @@ maintenance_check_psymtabs (const char *ignore, int from_tty)\n {\n   struct symbol *sym;\n   struct compunit_symtab *cust = NULL;\n-  struct partial_symtab *ps;\n   const struct blockvector *bv;\n   struct block *b;\n   int length;\n \n   for (objfile *objfile : all_objfiles (current_program_space))\n-    ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n+    for (partial_symtab *ps : require_partial_symbols (objfile, 1))\n       {\n \tstruct gdbarch *gdbarch = get_objfile_arch (objfile);\n "
    },
    {
      "sha": "a1cab96238f8670ff30c4e32e88114cbafe5237d",
      "filename": "gdb/psymtab.h",
      "status": "modified",
      "additions": 18,
      "deletions": 4,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/psymtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b22a7c6ab6173fe4fa1352e14d00a234bbf50346/gdb/psymtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.h?ref=b22a7c6ab6173fe4fa1352e14d00a234bbf50346",
      "patch": "@@ -21,6 +21,7 @@\n #define PSYMTAB_H\n \n #include \"symfile.h\"\n+#include \"common/next-iterator.h\"\n \n /* A bcache for partial symbols.  */\n \n@@ -35,12 +36,25 @@ extern const struct quick_symbol_functions psym_functions;\n extern const struct quick_symbol_functions dwarf2_gdb_index_functions;\n extern const struct quick_symbol_functions dwarf2_debug_names_functions;\n \n+/* A range adapter that makes it possible to iterate over all\n+   psymtabs in one objfile.  */\n+\n+class objfile_psymtabs : public next_adapter<struct partial_symtab>\n+{\n+public:\n+\n+  explicit objfile_psymtabs (struct objfile *objfile)\n+    : next_adapter<struct partial_symtab> (objfile->psymtabs)\n+  {\n+  }\n+};\n+\n /* Ensure that the partial symbols for OBJFILE have been loaded.  If\n    VERBOSE is non-zero, then this will print a message when symbols\n-   are loaded.  This function always returns its argument, as a\n-   convenience.  */\n+   are loaded.  This function returns a range adapter suitable for\n+   iterating over the psymtabs of OBJFILE.  */\n \n-extern struct objfile *require_partial_symbols (struct objfile *objfile,\n-\t\t\t\t\t\tint verbose);\n+extern objfile_psymtabs require_partial_symbols (struct objfile *objfile,\n+\t\t\t\t\t\t int verbose);\n \n #endif /* PSYMTAB_H */"
    }
  ]
}