{
  "sha": "9d2246fce014a0133882051f8527e2dbd869a31b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWQyMjQ2ZmNlMDE0YTAxMzM4ODIwNTFmODUyN2UyZGJkODY5YTMxYg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-30T00:49:08Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-30T02:29:06Z"
    },
    "message": "Remove DW_BLOCK\n\nThis removes the DW_BLOCK accessor in favor of methods on struct\nattribute.  The methods, unlike the access, check the form.\n\nNote that DW_FORM_data16 had to be handled by form_is_block, because\nin practice that is how we store values of this form.\n\ngdb/ChangeLog\n2020-09-29  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.c (read_call_site_scope)\n\t(handle_data_member_location, dwarf2_add_member_fn)\n\t(mark_common_block_symbol_computed, attr_to_dynamic_prop)\n\t(partial_die_info::read, read_attribute_value)\n\t(var_decode_location, dwarf2_const_value_attr, dump_die_shallow)\n\t(dwarf2_fetch_die_loc_sect_off, dwarf2_fetch_constant_bytes)\n\t(dwarf2_symbol_mark_computed): Update.\n\t* dwarf2/attribute.h (struct attribute) <as_block, set_block>: New\n\tmethods.\n\t(DW_BLOCK): Remove.\n\t* dwarf2/attribute.c (attribute::form_is_block): Add\n\tDW_FORM_data16.",
    "tree": {
      "sha": "e487374fac270b0558b4942962b803a56a909f0e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e487374fac270b0558b4942962b803a56a909f0e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9d2246fce014a0133882051f8527e2dbd869a31b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d2246fce014a0133882051f8527e2dbd869a31b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9d2246fce014a0133882051f8527e2dbd869a31b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d2246fce014a0133882051f8527e2dbd869a31b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c648120540c7a1550bd7e65e660fda419ecf23b3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c648120540c7a1550bd7e65e660fda419ecf23b3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c648120540c7a1550bd7e65e660fda419ecf23b3"
    }
  ],
  "stats": {
    "total": 198,
    "additions": 124,
    "deletions": 74
  },
  "files": [
    {
      "sha": "ed4fa186851a41b2b04a75c5e50033eee7deb106",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d2246fce014a0133882051f8527e2dbd869a31b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d2246fce014a0133882051f8527e2dbd869a31b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9d2246fce014a0133882051f8527e2dbd869a31b",
      "patch": "@@ -1,3 +1,18 @@\n+2020-09-29  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.c (read_call_site_scope)\n+\t(handle_data_member_location, dwarf2_add_member_fn)\n+\t(mark_common_block_symbol_computed, attr_to_dynamic_prop)\n+\t(partial_die_info::read, read_attribute_value)\n+\t(var_decode_location, dwarf2_const_value_attr, dump_die_shallow)\n+\t(dwarf2_fetch_die_loc_sect_off, dwarf2_fetch_constant_bytes)\n+\t(dwarf2_symbol_mark_computed): Update.\n+\t* dwarf2/attribute.h (struct attribute) <as_block, set_block>: New\n+\tmethods.\n+\t(DW_BLOCK): Remove.\n+\t* dwarf2/attribute.c (attribute::form_is_block): Add\n+\tDW_FORM_data16.\n+\n 2020-09-29  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (read_cutu_die_from_dwo)"
    },
    {
      "sha": "c8e556f0e41c532538effc0b5b9153d385f014ef",
      "filename": "gdb/dwarf2/attribute.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d2246fce014a0133882051f8527e2dbd869a31b/gdb/dwarf2/attribute.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d2246fce014a0133882051f8527e2dbd869a31b/gdb/dwarf2/attribute.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.c?ref=9d2246fce014a0133882051f8527e2dbd869a31b",
      "patch": "@@ -94,7 +94,8 @@ attribute::form_is_block () const\n \t  || form == DW_FORM_block2\n \t  || form == DW_FORM_block4\n \t  || form == DW_FORM_block\n-\t  || form == DW_FORM_exprloc);\n+\t  || form == DW_FORM_exprloc\n+\t  || form == DW_FORM_data16);\n }\n \n /* See attribute.h.  */"
    },
    {
      "sha": "0e2e86d65bfc17a60635f00df0e9686bc2cafa74",
      "filename": "gdb/dwarf2/attribute.h",
      "status": "modified",
      "additions": 14,
      "deletions": 1,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d2246fce014a0133882051f8527e2dbd869a31b/gdb/dwarf2/attribute.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d2246fce014a0133882051f8527e2dbd869a31b/gdb/dwarf2/attribute.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.h?ref=9d2246fce014a0133882051f8527e2dbd869a31b",
      "patch": "@@ -50,6 +50,13 @@ struct attribute\n      otherwise return NULL.  */\n   const char *as_string () const;\n \n+  /* Return the block value.  The attribute must have block form.  */\n+  dwarf_block *as_block () const\n+  {\n+    gdb_assert (form_is_block ());\n+    return u.blk;\n+  }\n+\n   /* Return non-zero if ATTR's value is a section offset --- classes\n      lineptr, loclistptr, macptr or rangelistptr --- or zero, otherwise.\n      You may use DW_UNSND (attr) to retrieve such offsets.\n@@ -146,6 +153,13 @@ struct attribute\n     string_is_canonical = 1;\n   }\n \n+  /* Set the block value for this attribute.  */\n+  void set_block (dwarf_block *blk)\n+  {\n+    gdb_assert (form_is_block ());\n+    u.blk = blk;\n+  }\n+\n \n   ENUM_BITFIELD(dwarf_attribute) name : 16;\n   ENUM_BITFIELD(dwarf_form) form : 15;\n@@ -176,7 +190,6 @@ struct attribute\n /* Get at parts of an attribute structure.  */\n \n #define DW_UNSND(attr)     ((attr)->u.unsnd)\n-#define DW_BLOCK(attr)     ((attr)->u.blk)\n #define DW_SND(attr)       ((attr)->u.snd)\n #define DW_ADDR(attr)\t   ((attr)->u.addr)\n #define DW_SIGNATURE(attr) ((attr)->u.signature)"
    },
    {
      "sha": "cd7f5c414fe0678939d8c4e492dfe0db8cc4d456",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 93,
      "deletions": 72,
      "changes": 165,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d2246fce014a0133882051f8527e2dbd869a31b/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d2246fce014a0133882051f8527e2dbd869a31b/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=9d2246fce014a0133882051f8527e2dbd869a31b",
      "patch": "@@ -13934,15 +13934,16 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n       attr = dwarf2_attr (die, DW_AT_abstract_origin, cu);\n     }\n   SET_FIELD_DWARF_BLOCK (call_site->target, NULL);\n-  if (!attr || (attr->form_is_block () && DW_BLOCK (attr)->size == 0))\n+  if (!attr || (attr->form_is_block () && attr->as_block ()->size == 0))\n     /* Keep NULL DWARF_BLOCK.  */;\n   else if (attr->form_is_block ())\n     {\n       struct dwarf2_locexpr_baton *dlbaton;\n+      struct dwarf_block *block = attr->as_block ();\n \n       dlbaton = XOBNEW (&objfile->objfile_obstack, struct dwarf2_locexpr_baton);\n-      dlbaton->data = DW_BLOCK (attr)->data;\n-      dlbaton->size = DW_BLOCK (attr)->size;\n+      dlbaton->data = block->data;\n+      dlbaton->size = block->size;\n       dlbaton->per_objfile = per_objfile;\n       dlbaton->per_cu = cu->per_cu;\n \n@@ -14052,12 +14053,14 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t}\n       else\n \t{\n+\t  struct dwarf_block *block = loc->as_block ();\n+\n \t  parameter->u.dwarf_reg = dwarf_block_to_dwarf_reg\n-\t    (DW_BLOCK (loc)->data, &DW_BLOCK (loc)->data[DW_BLOCK (loc)->size]);\n+\t    (block->data, &block->data[block->size]);\n \t  if (parameter->u.dwarf_reg != -1)\n \t    parameter->kind = CALL_SITE_PARAMETER_DWARF_REG;\n-\t  else if (dwarf_block_to_sp_offset (gdbarch, DW_BLOCK (loc)->data,\n-\t\t\t\t    &DW_BLOCK (loc)->data[DW_BLOCK (loc)->size],\n+\t  else if (dwarf_block_to_sp_offset (gdbarch, block->data,\n+\t\t\t\t    &block->data[block->size],\n \t\t\t\t\t     &parameter->u.fb_offset))\n \t    parameter->kind = CALL_SITE_PARAMETER_FB_OFFSET;\n \t  else\n@@ -14083,8 +14086,10 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t     objfile_name (objfile));\n \t  continue;\n \t}\n-      parameter->value = DW_BLOCK (attr)->data;\n-      parameter->value_size = DW_BLOCK (attr)->size;\n+\n+      struct dwarf_block *block = attr->as_block ();\n+      parameter->value = block->data;\n+      parameter->value_size = block->size;\n \n       /* Parameters are not pre-cleared by memset above.  */\n       parameter->data_value = NULL;\n@@ -14103,8 +14108,9 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t       objfile_name (objfile));\n \t  else\n \t    {\n-\t      parameter->data_value = DW_BLOCK (attr)->data;\n-\t      parameter->data_value_size = DW_BLOCK (attr)->size;\n+\t      block = attr->as_block ();\n+\t      parameter->data_value = block->data;\n+\t      parameter->data_value_size = block->size;\n \t    }\n \t}\n     }\n@@ -14914,7 +14920,7 @@ handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,\n       else if (attr->form_is_section_offset ())\n \tdwarf2_complex_location_expr_complaint ();\n       else if (attr->form_is_block ())\n-\t*offset = decode_locdesc (DW_BLOCK (attr), cu);\n+\t*offset = decode_locdesc (attr->as_block (), cu);\n       else\n \tdwarf2_complex_location_expr_complaint ();\n \n@@ -14945,7 +14951,7 @@ handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,\n       else if (attr->form_is_block ())\n \t{\n \t  bool handled;\n-\t  CORE_ADDR offset = decode_locdesc (DW_BLOCK (attr), cu, &handled);\n+\t  CORE_ADDR offset = decode_locdesc (attr->as_block (), cu, &handled);\n \t  if (handled)\n \t    SET_FIELD_BITPOS (*field, offset * bits_per_byte);\n \t  else\n@@ -14955,8 +14961,8 @@ handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,\n \t      struct dwarf2_locexpr_baton *dlbaton\n \t\t= XOBNEW (&objfile->objfile_obstack,\n \t\t\t  struct dwarf2_locexpr_baton);\n-\t      dlbaton->data = DW_BLOCK (attr)->data;\n-\t      dlbaton->size = DW_BLOCK (attr)->size;\n+\t      dlbaton->data = attr->as_block ()->data;\n+\t      dlbaton->size = attr->as_block ()->size;\n \t      /* When using this baton, we want to compute the address\n \t\t of the field, not the value.  This is why\n \t\t is_reference is set to false here.  */\n@@ -15684,19 +15690,21 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n   attr = dwarf2_attr (die, DW_AT_vtable_elem_location, cu);\n   if (attr != nullptr)\n     {\n-      if (attr->form_is_block () && DW_BLOCK (attr)->size > 0)\n+      if (attr->form_is_block () && attr->as_block ()->size > 0)\n         {\n-\t  if (DW_BLOCK (attr)->data[0] == DW_OP_constu)\n+\t  struct dwarf_block *block = attr->as_block ();\n+\n+\t  if (block->data[0] == DW_OP_constu)\n \t    {\n \t      /* Old-style GCC.  */\n-\t      fnp->voffset = decode_locdesc (DW_BLOCK (attr), cu) + 2;\n+\t      fnp->voffset = decode_locdesc (block, cu) + 2;\n \t    }\n-\t  else if (DW_BLOCK (attr)->data[0] == DW_OP_deref\n-\t\t   || (DW_BLOCK (attr)->size > 1\n-\t\t       && DW_BLOCK (attr)->data[0] == DW_OP_deref_size\n-\t\t       && DW_BLOCK (attr)->data[1] == cu->header.addr_size))\n+\t  else if (block->data[0] == DW_OP_deref\n+\t\t   || (block->size > 1\n+\t\t       && block->data[0] == DW_OP_deref_size\n+\t\t       && block->data[1] == cu->header.addr_size))\n \t    {\n-\t      fnp->voffset = decode_locdesc (DW_BLOCK (attr), cu);\n+\t      fnp->voffset = decode_locdesc (block, cu);\n \t      if ((fnp->voffset % cu->header.addr_size) != 0)\n \t\tdwarf2_complex_location_expr_complaint ();\n \t      else\n@@ -16202,10 +16210,10 @@ handle_variant (struct die_info *die, struct type *type,\n   if (discr == nullptr)\n     {\n       discr = dwarf2_attr (die, DW_AT_discr_list, cu);\n-      if (discr == nullptr || DW_BLOCK (discr)->size == 0)\n+      if (discr == nullptr || discr->as_block ()->size == 0)\n \tvariant.default_branch = true;\n       else\n-\tvariant.discr_list_data = DW_BLOCK (discr);\n+\tvariant.discr_list_data = discr->as_block ();\n     }\n   else\n     variant.discriminant_value = DW_UNSND (discr);\n@@ -16957,7 +16965,7 @@ mark_common_block_symbol_computed (struct symbol *sym,\n       baton->size += 1 /* DW_OP_addr */ + cu->header.addr_size;\n     }\n   else\n-    baton->size += DW_BLOCK (member_loc)->size;\n+    baton->size += member_loc->as_block ()->size;\n \n   ptr = (gdb_byte *) obstack_alloc (&objfile->objfile_obstack, baton->size);\n   baton->data = ptr;\n@@ -16977,8 +16985,9 @@ mark_common_block_symbol_computed (struct symbol *sym,\n     {\n       /* We have to copy the data here, because DW_OP_call4 will only\n \t use a DW_AT_location attribute.  */\n-      memcpy (ptr, DW_BLOCK (member_loc)->data, DW_BLOCK (member_loc)->size);\n-      ptr += DW_BLOCK (member_loc)->size;\n+      struct dwarf_block *block = member_loc->as_block ();\n+      memcpy (ptr, block->data, block->size);\n+      ptr += block->size;\n     }\n \n   *ptr++ = DW_OP_plus;\n@@ -18101,8 +18110,10 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n       baton->property_type = default_type;\n       baton->locexpr.per_cu = cu->per_cu;\n       baton->locexpr.per_objfile = per_objfile;\n-      baton->locexpr.size = DW_BLOCK (attr)->size;\n-      baton->locexpr.data = DW_BLOCK (attr)->data;\n+\n+      struct dwarf_block *block = attr->as_block ();\n+      baton->locexpr.size = block->size;\n+      baton->locexpr.data = block->data;\n       switch (attr->name)\n \t{\n \tcase DW_AT_string_length:\n@@ -18147,8 +18158,9 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t\tbaton->property_type = die_type (target_die, target_cu);\n \t\tbaton->locexpr.per_cu = cu->per_cu;\n \t\tbaton->locexpr.per_objfile = per_objfile;\n-\t\tbaton->locexpr.size = DW_BLOCK (target_attr)->size;\n-\t\tbaton->locexpr.data = DW_BLOCK (target_attr)->data;\n+\t\tstruct dwarf_block *block = target_attr->as_block ();\n+\t\tbaton->locexpr.size = block->size;\n+\t\tbaton->locexpr.data = block->data;\n \t\tbaton->locexpr.is_reference = true;\n \t\tprop->set_locexpr (baton);\n \t\tgdb_assert (prop->baton () != NULL);\n@@ -19045,7 +19057,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n           /* Support the .debug_loc offsets.  */\n           if (attr.form_is_block ())\n             {\n-\t       d.locdesc = DW_BLOCK (&attr);\n+\t      d.locdesc = attr.as_block ();\n             }\n           else if (attr.form_is_section_offset ())\n             {\n@@ -19701,15 +19713,15 @@ read_attribute_value (const struct die_reader_specs *reader,\n       info_ptr += 2;\n       blk->data = read_n_bytes (abfd, info_ptr, blk->size);\n       info_ptr += blk->size;\n-      DW_BLOCK (attr) = blk;\n+      attr->set_block (blk);\n       break;\n     case DW_FORM_block4:\n       blk = dwarf_alloc_block (cu);\n       blk->size = read_4_bytes (abfd, info_ptr);\n       info_ptr += 4;\n       blk->data = read_n_bytes (abfd, info_ptr, blk->size);\n       info_ptr += blk->size;\n-      DW_BLOCK (attr) = blk;\n+      attr->set_block (blk);\n       break;\n     case DW_FORM_data2:\n       DW_UNSND (attr) = read_2_bytes (abfd, info_ptr);\n@@ -19728,7 +19740,7 @@ read_attribute_value (const struct die_reader_specs *reader,\n       blk->size = 16;\n       blk->data = read_n_bytes (abfd, info_ptr, 16);\n       info_ptr += 16;\n-      DW_BLOCK (attr) = blk;\n+      attr->set_block (blk);\n       break;\n     case DW_FORM_sec_offset:\n       DW_UNSND (attr) = cu->header.read_offset (abfd, info_ptr, &bytes_read);\n@@ -19785,15 +19797,15 @@ read_attribute_value (const struct die_reader_specs *reader,\n       info_ptr += bytes_read;\n       blk->data = read_n_bytes (abfd, info_ptr, blk->size);\n       info_ptr += blk->size;\n-      DW_BLOCK (attr) = blk;\n+      attr->set_block (blk);\n       break;\n     case DW_FORM_block1:\n       blk = dwarf_alloc_block (cu);\n       blk->size = read_1_byte (abfd, info_ptr);\n       info_ptr += 1;\n       blk->data = read_n_bytes (abfd, info_ptr, blk->size);\n       info_ptr += blk->size;\n-      DW_BLOCK (attr) = blk;\n+      attr->set_block (blk);\n       break;\n     case DW_FORM_data1:\n       DW_UNSND (attr) = read_1_byte (abfd, info_ptr);\n@@ -21300,7 +21312,7 @@ var_decode_location (struct attribute *attr, struct symbol *sym,\n \n   /* A DW_AT_location attribute with no contents indicates that a\n      variable has been optimized away.  */\n-  if (attr->form_is_block () && DW_BLOCK (attr)->size == 0)\n+  if (attr->form_is_block () && attr->as_block ()->size == 0)\n     {\n       SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n       return;\n@@ -21311,32 +21323,36 @@ var_decode_location (struct attribute *attr, struct symbol *sym,\n      specified.  If this is just a DW_OP_addr, DW_OP_addrx, or\n      DW_OP_GNU_addr_index then mark this symbol as LOC_STATIC.  */\n \n-  if (attr->form_is_block ()\n-      && ((DW_BLOCK (attr)->data[0] == DW_OP_addr\n-\t   && DW_BLOCK (attr)->size == 1 + cu_header->addr_size)\n-\t  || ((DW_BLOCK (attr)->data[0] == DW_OP_GNU_addr_index\n-               || DW_BLOCK (attr)->data[0] == DW_OP_addrx)\n-\t      && (DW_BLOCK (attr)->size\n-\t\t  == 1 + leb128_size (&DW_BLOCK (attr)->data[1])))))\n-    {\n-      unsigned int dummy;\n-\n-      if (DW_BLOCK (attr)->data[0] == DW_OP_addr)\n-\tSET_SYMBOL_VALUE_ADDRESS\n-\t  (sym, cu->header.read_address (objfile->obfd,\n-\t\t\t\t\t DW_BLOCK (attr)->data + 1,\n-\t\t\t\t\t &dummy));\n-      else\n-\tSET_SYMBOL_VALUE_ADDRESS\n-\t  (sym, read_addr_index_from_leb128 (cu, DW_BLOCK (attr)->data + 1,\n+  if (attr->form_is_block ())\n+    {\n+      struct dwarf_block *block = attr->as_block ();\n+\n+      if ((block->data[0] == DW_OP_addr\n+\t   && block->size == 1 + cu_header->addr_size)\n+\t  || ((block->data[0] == DW_OP_GNU_addr_index\n+               || block->data[0] == DW_OP_addrx)\n+\t      && (block->size\n+\t\t  == 1 + leb128_size (&block->data[1]))))\n+\t{\n+\t  unsigned int dummy;\n+\n+\t  if (block->data[0] == DW_OP_addr)\n+\t    SET_SYMBOL_VALUE_ADDRESS\n+\t      (sym, cu->header.read_address (objfile->obfd,\n+\t\t\t\t\t     block->data + 1,\n \t\t\t\t\t     &dummy));\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n-      fixup_symbol_section (sym, objfile);\n-      SET_SYMBOL_VALUE_ADDRESS\n-\t(sym,\n-\t SYMBOL_VALUE_ADDRESS (sym)\n-\t + objfile->section_offsets[SYMBOL_SECTION (sym)]);\n-      return;\n+\t  else\n+\t    SET_SYMBOL_VALUE_ADDRESS\n+\t      (sym, read_addr_index_from_leb128 (cu, block->data + 1,\n+\t\t\t\t\t\t &dummy));\n+\t  SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+\t  fixup_symbol_section (sym, objfile);\n+\t  SET_SYMBOL_VALUE_ADDRESS\n+\t    (sym,\n+\t     SYMBOL_VALUE_ADDRESS (sym)\n+\t     + objfile->section_offsets[SYMBOL_SECTION (sym)]);\n+\t  return;\n+\t}\n     }\n \n   /* NOTE drow/2002-01-30: It might be worthwhile to have a static\n@@ -21868,7 +21884,7 @@ dwarf2_const_value_attr (const struct attribute *attr, struct type *type,\n     case DW_FORM_block:\n     case DW_FORM_exprloc:\n     case DW_FORM_data16:\n-      blk = DW_BLOCK (attr);\n+      blk = attr->as_block ();\n       if (TYPE_LENGTH (type) != blk->size)\n \tdwarf2_const_value_length_mismatch_complaint (name, blk->size,\n \t\t\t\t\t\t      TYPE_LENGTH (type));\n@@ -22726,11 +22742,11 @@ dump_die_shallow (struct ui_file *f, int indent, struct die_info *die)\n \tcase DW_FORM_block:\n \tcase DW_FORM_block1:\n \t  fprintf_unfiltered (f, \"block: size %s\",\n-\t\t\t      pulongest (DW_BLOCK (&die->attrs[i])->size));\n+\t\t\t      pulongest (die->attrs[i].as_block ()->size));\n \t  break;\n \tcase DW_FORM_exprloc:\n \t  fprintf_unfiltered (f, \"expression: size %s\",\n-\t\t\t      pulongest (DW_BLOCK (&die->attrs[i])->size));\n+\t\t\t      pulongest (die->attrs[i].as_block ()->size));\n \t  break;\n \tcase DW_FORM_data16:\n \t  fprintf_unfiltered (f, \"constant of 16 bytes\");\n@@ -23067,8 +23083,9 @@ dwarf2_fetch_die_loc_sect_off (sect_offset sect_off,\n \t\t \"is neither DW_FORM_block* nor DW_FORM_exprloc\"),\n \t       sect_offset_str (sect_off), objfile_name (objfile));\n \n-      retval.data = DW_BLOCK (attr)->data;\n-      retval.size = DW_BLOCK (attr)->size;\n+      struct dwarf_block *block = attr->as_block ();\n+      retval.data = block->data;\n+      retval.size = block->size;\n     }\n   retval.per_objfile = per_objfile;\n   retval.per_cu = cu->per_cu;\n@@ -23185,8 +23202,11 @@ dwarf2_fetch_constant_bytes (sect_offset sect_off,\n     case DW_FORM_block:\n     case DW_FORM_exprloc:\n     case DW_FORM_data16:\n-      result = DW_BLOCK (attr)->data;\n-      *len = DW_BLOCK (attr)->size;\n+      {\n+\tstruct dwarf_block *block = attr->as_block ();\n+\tresult = block->data;\n+\t*len = block->size;\n+      }\n       break;\n \n       /* The DW_AT_const_value attributes are supposed to carry the\n@@ -24013,8 +24033,9 @@ dwarf2_symbol_mark_computed (const struct attribute *attr, struct symbol *sym,\n \t     info_buffer for SYM's objfile; right now we never release\n \t     that buffer, but when we do clean up properly this may\n \t     need to change.  */\n-\t  baton->size = DW_BLOCK (attr)->size;\n-\t  baton->data = DW_BLOCK (attr)->data;\n+\t  struct dwarf_block *block = attr->as_block ();\n+\t  baton->size = block->size;\n+\t  baton->data = block->data;\n \t}\n       else\n \t{"
    }
  ]
}