{
  "sha": "7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2Q3MTY3Y2UxYjkzZjhiYjE1MWRhYTI1NzIzMTQ5ODdlYWViOWUzYw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-11-03T21:47:55Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-12-12T22:50:56Z"
    },
    "message": "Manage objfiles with shared_ptr\n\nThis changes objfiles to be managed using a shared_ptr.  shared_ptr is\nchosen because it enables the use of objfiles in background threads.\n\nThe simplest way to do this was to introduce a new iterator that will\nreturn the underlying objfile, rather than a shared_ptr.  (I also\ntried changing the rest of gdb to use shared_ptr, but this was quite\nlarge; and to using intrusive reference counting, but this also was\ntricky.)\n\ngdb/ChangeLog\n2019-12-12  Tom Tromey  <tom@tromey.com>\n\n\t* progspace.h (objfile_list): New typedef.\n\t(class unwrapping_objfile_iterator)\n\t(struct unwrapping_objfile_range): Newl\n\t(struct program_space) <objfiles_range>: Change type.\n\t<objfiles>: Change return type.\n\t<add_objfile>: Change type of \"objfile\" parameter.\n\t<objfiles_list>: Now a list of shared_ptr.\n\t* progspace.c (program_space::add_objfile): Change type of\n\t\"objfile\".  Update.\n\t(program_space::remove_objfile): Update.\n\t* objfiles.h (struct objfile) <~objfile>: Make public.\n\t* objfiles.c (objfile::make): Update.\n\t(objfile::unlink): Don't call delete.\n\nChange-Id: I6fb7fbf06efb7cb7474c525908365863eae27eb3",
    "tree": {
      "sha": "6380ce122f3651660f3df3ac30be6b01daf743be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6380ce122f3651660f3df3ac30be6b01daf743be"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "343cc95202fce70383551053f2efab09c5e02366",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/343cc95202fce70383551053f2efab09c5e02366",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/343cc95202fce70383551053f2efab09c5e02366"
    }
  ],
  "stats": {
    "total": 140,
    "additions": 123,
    "deletions": 17
  },
  "files": [
    {
      "sha": "8c26bb06add7d6ffde035cfa4e68314c895a685b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
      "patch": "@@ -1,3 +1,19 @@\n+2019-12-12  Tom Tromey  <tom@tromey.com>\n+\n+\t* progspace.h (objfile_list): New typedef.\n+\t(class unwrapping_objfile_iterator)\n+\t(struct unwrapping_objfile_range): Newl\n+\t(struct program_space) <objfiles_range>: Change type.\n+\t<objfiles>: Change return type.\n+\t<add_objfile>: Change type of \"objfile\" parameter.\n+\t<objfiles_list>: Now a list of shared_ptr.\n+\t* progspace.c (program_space::add_objfile): Change type of\n+\t\"objfile\".  Update.\n+\t(program_space::remove_objfile): Update.\n+\t* objfiles.h (struct objfile) <~objfile>: Make public.\n+\t* objfiles.c (objfile::make): Update.\n+\t(objfile::unlink): Don't call delete.\n+\n 2019-12-12  Tom Tromey  <tom@tromey.com>\n \n \t* symfile.c (symbol_file_clear): Update."
    },
    {
      "sha": "81e82124297f088653574fe0da59f55f64189163",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
      "patch": "@@ -486,7 +486,10 @@ objfile::make (bfd *bfd_, const char *name_, objfile_flags flags_,\n   if (parent != nullptr)\n     add_separate_debug_objfile (result, parent);\n \n-  current_program_space->add_objfile (result, parent);\n+  /* Using std::make_shared might be a bit nicer here, but that would\n+     require making the constructor public.  */\n+  current_program_space->add_objfile (std::shared_ptr<objfile> (result),\n+\t\t\t\t      parent);\n \n   /* Rebuild section map next time we need it.  */\n   get_objfile_pspace_data (current_program_space)->new_objfiles_available = 1;\n@@ -500,7 +503,6 @@ void\n objfile::unlink ()\n {\n   current_program_space->remove_objfile (this);\n-  delete this;\n }\n \n /* Free all separate debug objfile of OBJFILE, but don't free OBJFILE"
    },
    {
      "sha": "f0ee8037b6ddc374afef244479dafb71d57bdb15",
      "filename": "gdb/objfiles.h",
      "status": "modified",
      "additions": 10,
      "deletions": 3,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/objfiles.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/objfiles.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.h?ref=7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
      "patch": "@@ -28,12 +28,14 @@\n #include \"registry.h\"\n #include \"gdb_bfd.h\"\n #include \"psymtab.h\"\n+#include <atomic>\n #include <bitset>\n #include <vector>\n #include \"gdbsupport/next-iterator.h\"\n #include \"gdbsupport/safe-iterator.h\"\n #include \"bcache.h\"\n #include \"gdbarch.h\"\n+#include \"gdbsupport/refcounted-object.h\"\n \n struct htab;\n struct objfile_data;\n@@ -399,11 +401,16 @@ struct objfile\n   /* The only way to create an objfile is to call objfile::make.  */\n   objfile (bfd *, const char *, objfile_flags);\n \n-  /* The only way to free an objfile is via 'unlink'.  */\n-  ~objfile ();\n-\n public:\n \n+  /* Normally you should not call delete.  Instead, call 'unlink' to\n+     remove it from the program space's list.  In some cases, you may\n+     need to hold a reference to an objfile that is independent of its\n+     existence on the program space's list; for this case, the\n+     destructor must be public so that shared_ptr can reference\n+     it.  */\n+  ~objfile ();\n+\n   /* Create an objfile.  */\n   static objfile *make (bfd *bfd_, const char *name_, objfile_flags flags_,\n \t\t\tobjfile *parent = nullptr);"
    },
    {
      "sha": "1d8aaea2caa8d13737ba1be5e021be422f7cc0eb",
      "filename": "gdb/progspace.c",
      "status": "modified",
      "additions": 14,
      "deletions": 7,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/progspace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/progspace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/progspace.c?ref=7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
      "patch": "@@ -175,16 +175,20 @@ program_space::free_all_objfiles ()\n /* See progspace.h.  */\n \n void\n-program_space::add_objfile (struct objfile *objfile, struct objfile *before)\n+program_space::add_objfile (std::shared_ptr<objfile> &&objfile,\n+\t\t\t    struct objfile *before)\n {\n   if (before == nullptr)\n-    objfiles_list.push_back (objfile);\n+    objfiles_list.push_back (std::move (objfile));\n   else\n     {\n-      auto iter = std::find (objfiles_list.begin (), objfiles_list.end (),\n-\t\t\t     before);\n+      auto iter = std::find_if (objfiles_list.begin (), objfiles_list.end (),\n+\t\t\t\t[=] (const std::shared_ptr<::objfile> &objf)\n+\t\t\t\t{\n+\t\t\t\t  return objf.get () == before;\n+\t\t\t\t});\n       gdb_assert (iter != objfiles_list.end ());\n-      objfiles_list.insert (iter, objfile);\n+      objfiles_list.insert (iter, std::move (objfile));\n     }\n }\n \n@@ -193,8 +197,11 @@ program_space::add_objfile (struct objfile *objfile, struct objfile *before)\n void\n program_space::remove_objfile (struct objfile *objfile)\n {\n-  auto iter = std::find (objfiles_list.begin (), objfiles_list.end (),\n-\t\t\t objfile);\n+  auto iter = std::find_if (objfiles_list.begin (), objfiles_list.end (),\n+\t\t\t    [=] (const std::shared_ptr<::objfile> &objf)\n+\t\t\t    {\n+\t\t\t      return objf.get () == objfile;\n+\t\t\t    });\n   gdb_assert (iter != objfiles_list.end ());\n   objfiles_list.erase (iter);\n "
    },
    {
      "sha": "5fe2f6c755efd19491bc3701d2ba8aa105110164",
      "filename": "gdb/progspace.h",
      "status": "modified",
      "additions": 79,
      "deletions": 5,
      "changes": 84,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/progspace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d7167ce1b93f8bb151daa2572314987eaeb9e3c/gdb/progspace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/progspace.h?ref=7d7167ce1b93f8bb151daa2572314987eaeb9e3c",
      "patch": "@@ -38,6 +38,79 @@ struct address_space;\n struct program_space_data;\n struct address_space_data;\n \n+typedef std::list<std::shared_ptr<objfile>> objfile_list;\n+\n+/* An iterator that wraps an iterator over std::shared_ptr<objfile>,\n+   and dereferences the returned object.  This is useful for iterating\n+   over a list of shared pointers and returning raw pointers -- which\n+   helped avoid touching a lot of code when changing how objfiles are\n+   managed.  */\n+\n+class unwrapping_objfile_iterator\n+{\n+public:\n+\n+  typedef unwrapping_objfile_iterator self_type;\n+  typedef typename ::objfile *value_type;\n+  typedef typename ::objfile &reference;\n+  typedef typename ::objfile **pointer;\n+  typedef typename objfile_list::iterator::iterator_category iterator_category;\n+  typedef typename objfile_list::iterator::difference_type difference_type;\n+\n+  unwrapping_objfile_iterator (const objfile_list::iterator &iter)\n+    : m_iter (iter)\n+  {\n+  }\n+\n+  objfile *operator* () const\n+  {\n+    return m_iter->get ();\n+  }\n+\n+  unwrapping_objfile_iterator operator++ ()\n+  {\n+    ++m_iter;\n+    return *this;\n+  }\n+\n+  bool operator!= (const unwrapping_objfile_iterator &other) const\n+  {\n+    return m_iter != other.m_iter;\n+  }\n+\n+private:\n+\n+  /* The underlying iterator.  */\n+  objfile_list::iterator m_iter;\n+};\n+\n+\n+/* A range that returns unwrapping_objfile_iterators.  */\n+\n+struct unwrapping_objfile_range\n+{\n+  typedef unwrapping_objfile_iterator iterator;\n+\n+  unwrapping_objfile_range (objfile_list &ol)\n+    : m_list (ol)\n+  {\n+  }\n+\n+  iterator begin () const\n+  {\n+    return iterator (m_list.begin ());\n+  }\n+\n+  iterator end () const\n+  {\n+    return iterator (m_list.end ());\n+  }\n+\n+private:\n+\n+  objfile_list &m_list;\n+};\n+\n /* A program space represents a symbolic view of an address space.\n    Roughly speaking, it holds all the data associated with a\n    non-running-yet program (main executable, main symbols), and when\n@@ -139,15 +212,15 @@ struct program_space\n   program_space (address_space *aspace_);\n   ~program_space ();\n \n-  typedef std::list<struct objfile *> objfiles_range;\n+  typedef unwrapping_objfile_range objfiles_range;\n \n   /* Return an iterable object that can be used to iterate over all\n      objfiles.  The basic use is in a foreach, like:\n \n      for (objfile *objf : pspace->objfiles ()) { ... }  */\n-  objfiles_range &objfiles ()\n+  objfiles_range objfiles ()\n   {\n-    return objfiles_list;\n+    return unwrapping_objfile_range (objfiles_list);\n   }\n \n   typedef basic_safe_range<objfiles_range> objfiles_safe_range;\n@@ -167,7 +240,8 @@ struct program_space\n   /* Add OBJFILE to the list of objfiles, putting it just before\n      BEFORE.  If BEFORE is nullptr, it will go at the end of the\n      list.  */\n-  void add_objfile (struct objfile *objfile, struct objfile *before);\n+  void add_objfile (std::shared_ptr<objfile> &&objfile,\n+\t\t    struct objfile *before);\n \n   /* Remove OBJFILE from the list of objfiles.  */\n   void remove_objfile (struct objfile *objfile);\n@@ -234,7 +308,7 @@ struct program_space\n   struct objfile *symfile_object_file = NULL;\n \n   /* All known objfiles are kept in a linked list.  */\n-  std::list<struct objfile *> objfiles_list;\n+  std::list<std::shared_ptr<objfile>> objfiles_list;\n \n   /* The set of target sections matching the sections mapped into\n      this program space.  Managed by both exec_ops and solib.c.  */"
    }
  ]
}