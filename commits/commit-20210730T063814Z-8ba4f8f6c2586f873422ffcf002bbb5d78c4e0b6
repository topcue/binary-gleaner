{
  "sha": "8ba4f8f6c2586f873422ffcf002bbb5d78c4e0b6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGJhNGY4ZjZjMjU4NmY4NzM0MjJmZmNmMDAyYmJiNWQ3OGM0ZTBiNg==",
  "commit": {
    "author": {
      "name": "Cl\u00e9ment Chigot",
      "email": "clement.chigot@atos.net",
      "date": "2021-07-29T07:50:37Z"
    },
    "committer": {
      "name": "Cl\u00e9ment Chigot",
      "email": "clement.chigot@atos.net",
      "date": "2021-07-30T06:38:14Z"
    },
    "message": "bfd: ensure that symbols targeted by DWARF relocations are kept in XCOFF\n\nThis patch improves XCOFF garbage collector pass, in order to keep\nsymbols being referenced only by special sections like DWARF sections.\n\nbfd/\n\t* xcofflink.c (xcoff_mark): Replace SEC_MARK by gc_mark.\n\tLook through relocations even if xcoff_section_data is NULL.\n\t(xcoff_sweep): Check if any sections of a file is kept before\n\tadding its special sections.\n\tCall xcoff_mark for special sessions being kept instead of just\n\tmarking them.\n\t(SEC_MARK): Remove\n\t(xcoff_mark_symbol): Replace SEC_MARK by gc_mark.\n\t(xcoff_keep_symbol_p): Likewise.\n\t(bfd_xcoff_size_dynamic_sections): Likewise.\n\t(xcoff_find_tc0): Likewise.",
    "tree": {
      "sha": "de6a5a597f03a04a65cc82bb13b3e1ab78cf5c75",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/de6a5a597f03a04a65cc82bb13b3e1ab78cf5c75"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8ba4f8f6c2586f873422ffcf002bbb5d78c4e0b6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ba4f8f6c2586f873422ffcf002bbb5d78c4e0b6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8ba4f8f6c2586f873422ffcf002bbb5d78c4e0b6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ba4f8f6c2586f873422ffcf002bbb5d78c4e0b6/comments",
  "author": {
    "login": "Helflym",
    "id": 23002587,
    "node_id": "MDQ6VXNlcjIzMDAyNTg3",
    "avatar_url": "https://avatars.githubusercontent.com/u/23002587?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Helflym",
    "html_url": "https://github.com/Helflym",
    "followers_url": "https://api.github.com/users/Helflym/followers",
    "following_url": "https://api.github.com/users/Helflym/following{/other_user}",
    "gists_url": "https://api.github.com/users/Helflym/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Helflym/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Helflym/subscriptions",
    "organizations_url": "https://api.github.com/users/Helflym/orgs",
    "repos_url": "https://api.github.com/users/Helflym/repos",
    "events_url": "https://api.github.com/users/Helflym/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Helflym/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "Helflym",
    "id": 23002587,
    "node_id": "MDQ6VXNlcjIzMDAyNTg3",
    "avatar_url": "https://avatars.githubusercontent.com/u/23002587?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Helflym",
    "html_url": "https://github.com/Helflym",
    "followers_url": "https://api.github.com/users/Helflym/followers",
    "following_url": "https://api.github.com/users/Helflym/following{/other_user}",
    "gists_url": "https://api.github.com/users/Helflym/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Helflym/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Helflym/subscriptions",
    "organizations_url": "https://api.github.com/users/Helflym/orgs",
    "repos_url": "https://api.github.com/users/Helflym/repos",
    "events_url": "https://api.github.com/users/Helflym/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Helflym/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1417c848426871e767342ffbc673198145f4cec7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1417c848426871e767342ffbc673198145f4cec7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1417c848426871e767342ffbc673198145f4cec7"
    }
  ],
  "stats": {
    "total": 185,
    "additions": 106,
    "deletions": 79
  },
  "files": [
    {
      "sha": "3ca74ce02774f336442f683c329630c2e042b161",
      "filename": "bfd/xcofflink.c",
      "status": "modified",
      "additions": 106,
      "deletions": 79,
      "changes": 185,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ba4f8f6c2586f873422ffcf002bbb5d78c4e0b6/bfd/xcofflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ba4f8f6c2586f873422ffcf002bbb5d78c4e0b6/bfd/xcofflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/xcofflink.c?ref=8ba4f8f6c2586f873422ffcf002bbb5d78c4e0b6",
      "patch": "@@ -35,11 +35,6 @@\n #undef  STRING_SIZE_SIZE\n #define STRING_SIZE_SIZE 4\n \n-/* We reuse the SEC_ROM flag as a mark flag for garbage collection.\n-   This flag will only be used on input sections.  */\n-\n-#define SEC_MARK (SEC_ROM)\n-\n /* The list of import files.  */\n \n struct xcoff_import_file\n@@ -2880,15 +2875,15 @@ xcoff_mark_symbol (struct bfd_link_info *info, struct xcoff_link_hash_entry *h)\n \n       hsec = h->root.u.def.section;\n       if (! bfd_is_abs_section (hsec)\n-\t  && (hsec->flags & SEC_MARK) == 0)\n+\t  && hsec->gc_mark == 0)\n \t{\n \t  if (! xcoff_mark (info, hsec))\n \t    return false;\n \t}\n     }\n \n   if (h->toc_section != NULL\n-      && (h->toc_section->flags & SEC_MARK) == 0)\n+      && h->toc_section->gc_mark == 0)\n     {\n       if (! xcoff_mark (info, h->toc_section))\n \treturn false;\n@@ -2931,17 +2926,21 @@ static bool\n xcoff_mark (struct bfd_link_info *info, asection *sec)\n {\n   if (bfd_is_const_section (sec)\n-      || (sec->flags & SEC_MARK) != 0)\n+      || sec->gc_mark != 0)\n+    return true;\n+\n+  sec->gc_mark = 1;\n+\n+  if (sec->owner->xvec != info->output_bfd->xvec)\n+    return true;\n+\n+  if (coff_section_data (sec->owner, sec) == NULL)\n     return true;\n \n-  sec->flags |= SEC_MARK;\n \n-  if (sec->owner->xvec == info->output_bfd->xvec\n-      && coff_section_data (sec->owner, sec) != NULL\n-      && xcoff_section_data (sec->owner, sec) != NULL)\n+  if (xcoff_section_data (sec->owner, sec) != NULL)\n     {\n       struct xcoff_link_hash_entry **syms;\n-      struct internal_reloc *rel, *relend;\n       asection **csects;\n       unsigned long i, first, last;\n \n@@ -2958,64 +2957,67 @@ xcoff_mark (struct bfd_link_info *info, asection *sec)\n \t    if (!xcoff_mark_symbol (info, syms[i]))\n \t      return false;\n \t  }\n+    }\n+\n+  /* Look through the section relocs.  */\n+  if ((sec->flags & SEC_RELOC) != 0\n+      && sec->reloc_count > 0)\n+    {\n+      struct internal_reloc *rel, *relend;\n \n-      /* Look through the section relocs.  */\n-      if ((sec->flags & SEC_RELOC) != 0\n-\t  && sec->reloc_count > 0)\n+      rel = xcoff_read_internal_relocs (sec->owner, sec, true,\n+\t\t\t\t\tNULL, false, NULL);\n+      if (rel == NULL)\n+\treturn false;\n+      relend = rel + sec->reloc_count;\n+      for (; rel < relend; rel++)\n \t{\n-\t  rel = xcoff_read_internal_relocs (sec->owner, sec, true,\n-\t\t\t\t\t    NULL, false, NULL);\n-\t  if (rel == NULL)\n-\t    return false;\n-\t  relend = rel + sec->reloc_count;\n-\t  for (; rel < relend; rel++)\n-\t    {\n-\t      struct xcoff_link_hash_entry *h;\n+\t  struct xcoff_link_hash_entry *h;\n \n-\t      if ((unsigned int) rel->r_symndx\n-\t\t  > obj_raw_syment_count (sec->owner))\n-\t\tcontinue;\n+\t  if ((unsigned int) rel->r_symndx\n+\t      > obj_raw_syment_count (sec->owner))\n+\t    continue;\n \n-\t      h = obj_xcoff_sym_hashes (sec->owner)[rel->r_symndx];\n-\t      if (h != NULL)\n-\t\t{\n-\t\t  if ((h->flags & XCOFF_MARK) == 0)\n-\t\t    {\n-\t\t      if (!xcoff_mark_symbol (info, h))\n-\t\t\treturn false;\n-\t\t    }\n-\t\t}\n-\t      else\n+\t  h = obj_xcoff_sym_hashes (sec->owner)[rel->r_symndx];\n+\t  if (h != NULL)\n+\t    {\n+\t      if ((h->flags & XCOFF_MARK) == 0)\n \t\t{\n-\t\t  asection *rsec;\n-\n-\t\t  rsec = xcoff_data (sec->owner)->csects[rel->r_symndx];\n-\t\t  if (rsec != NULL\n-\t\t      && (rsec->flags & SEC_MARK) == 0)\n-\t\t    {\n-\t\t      if (!xcoff_mark (info, rsec))\n-\t\t\treturn false;\n-\t\t    }\n+\t\t  if (!xcoff_mark_symbol (info, h))\n+\t\t    return false;\n \t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      asection *rsec;\n \n-\t      /* See if this reloc needs to be copied into the .loader\n-\t\t section.  */\n-\t      if (xcoff_need_ldrel_p (info, rel, h, sec))\n+\t      rsec = xcoff_data (sec->owner)->csects[rel->r_symndx];\n+\t      if (rsec != NULL\n+\t\t  && rsec->gc_mark == 0)\n \t\t{\n-\t\t  ++xcoff_hash_table (info)->ldrel_count;\n-\t\t  if (h != NULL)\n-\t\t    h->flags |= XCOFF_LDREL;\n+\t\t  if (!xcoff_mark (info, rsec))\n+\t\t    return false;\n \t\t}\n \t    }\n \n-\t  if (! info->keep_memory\n-\t      && coff_section_data (sec->owner, sec) != NULL\n-\t      && ! coff_section_data (sec->owner, sec)->keep_relocs)\n+\t  /* See if this reloc needs to be copied into the .loader\n+\t     section.  */\n+\t  if ((sec->flags & SEC_DEBUGGING) == 0\n+\t      && xcoff_need_ldrel_p (info, rel, h, sec))\n \t    {\n-\t      free (coff_section_data (sec->owner, sec)->relocs);\n-\t      coff_section_data (sec->owner, sec)->relocs = NULL;\n+\t      ++xcoff_hash_table (info)->ldrel_count;\n+\t      if (h != NULL)\n+\t\th->flags |= XCOFF_LDREL;\n \t    }\n \t}\n+\n+      if (! info->keep_memory\n+\t  && coff_section_data (sec->owner, sec) != NULL\n+\t  && ! coff_section_data (sec->owner, sec)->keep_relocs)\n+\t{\n+\t  free (coff_section_data (sec->owner, sec)->relocs);\n+\t  coff_section_data (sec->owner, sec)->relocs = NULL;\n+\t}\n     }\n \n   return true;\n@@ -3035,27 +3037,52 @@ xcoff_sweep (struct bfd_link_info *info)\n   for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n     {\n       asection *o;\n+      bool some_kept = false;\n+\n+      /* As says below keep all sections from non-XCOFF\n+         input files.  */\n+      if (sub->xvec != info->output_bfd->xvec)\n+\tsome_kept = true;\n+      else\n+\t{\n+\t  /* See whether any section is already marked.  */\n+\t  for (o = sub->sections; o != NULL; o = o->next)\n+\t    if (o->gc_mark)\n+\t      some_kept = true;\n+\t}\n \n+      /* If no section in this file will be kept, then we can\n+\t toss out debug sections.  */\n+      if (!some_kept)\n+\t{\n+\t  for (o = sub->sections; o != NULL; o = o->next)\n+\t    {\n+\t      o->size = 0;\n+\t      o->reloc_count = 0;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* Keep all sections from non-XCOFF input files.  Keep\n+\t special sections.  Keep .debug sections for the\n+\t moment.  */\n       for (o = sub->sections; o != NULL; o = o->next)\n \t{\n-\t  if ((o->flags & SEC_MARK) == 0)\n+\t  if (o->gc_mark == 1)\n+\t    continue;\n+\n+\t  if (sub->xvec != info->output_bfd->xvec\n+\t      || o == xcoff_hash_table (info)->debug_section\n+\t      || o == xcoff_hash_table (info)->loader_section\n+\t      || o == xcoff_hash_table (info)->linkage_section\n+\t      || o == xcoff_hash_table (info)->descriptor_section\n+\t      || (bfd_section_flags (o) & SEC_DEBUGGING)\n+\t      || strcmp (o->name, \".debug\") == 0)\n+\t    xcoff_mark (info, o);\n+\t  else\n \t    {\n-\t      /* Keep all sections from non-XCOFF input files.  Keep\n-\t\t special sections.  Keep .debug sections for the\n-\t\t moment.  */\n-\t      if (sub->xvec != info->output_bfd->xvec\n-\t\t  || o == xcoff_hash_table (info)->debug_section\n-\t\t  || o == xcoff_hash_table (info)->loader_section\n-\t\t  || o == xcoff_hash_table (info)->linkage_section\n-\t\t  || o == xcoff_hash_table (info)->descriptor_section\n-\t\t  || (bfd_section_flags (o) & SEC_DEBUGGING)\n-\t\t  || strcmp (o->name, \".debug\") == 0)\n-\t\to->flags |= SEC_MARK;\n-\t      else\n-\t\t{\n-\t\t  o->size = 0;\n-\t\t  o->reloc_count = 0;\n-\t\t}\n+\t      o->size = 0;\n+\t      o->reloc_count = 0;\n \t    }\n \t}\n     }\n@@ -3457,7 +3484,7 @@ xcoff_keep_symbol_p (struct bfd_link_info *info, bfd *input_bfd,\n   if (xcoff_hash_table (info)->gc\n       && !bfd_is_abs_section (csect)\n       && !bfd_is_und_section (csect)\n-      && (csect->flags & SEC_MARK) == 0)\n+      && csect->gc_mark == 0)\n     return 0;\n \n   /* An XCOFF linker always removes C_STAT symbols.  */\n@@ -3769,7 +3796,7 @@ bfd_xcoff_size_dynamic_sections (bfd *output_bfd,\n \t\t (a) one of the input files did or (b) we end up\n \t\t creating TOC references as part of the link process.  */\n \t      if (o != xcoff_hash_table (info)->toc_section\n-\t\t  && (o->flags & SEC_MARK) == 0)\n+\t\t  && o->gc_mark == 0)\n \t\t{\n \t\t  if (! xcoff_mark (info, o))\n \t\t    goto error_return;\n@@ -3806,7 +3833,7 @@ bfd_xcoff_size_dynamic_sections (bfd *output_bfd,\n \n       if (sec != NULL\n \t  && gc\n-\t  && (sec->flags & SEC_MARK) == 0)\n+\t  && sec->gc_mark == 0)\n \tsec = NULL;\n \n       special_sections[i] = sec;\n@@ -5103,7 +5130,7 @@ xcoff_find_tc0 (bfd *output_bfd, struct xcoff_final_link_info *flinfo)\n        input_bfd != NULL;\n        input_bfd = input_bfd->link.next)\n     for (sec = input_bfd->sections; sec != NULL; sec = sec->next)\n-      if ((sec->flags & SEC_MARK) != 0 && xcoff_toc_section_p (sec))\n+      if (sec->gc_mark != 0 && xcoff_toc_section_p (sec))\n \t{\n \t  start = sec->output_section->vma + sec->output_offset;\n \t  if (toc_start > start)\n@@ -5135,7 +5162,7 @@ xcoff_find_tc0 (bfd *output_bfd, struct xcoff_final_link_info *flinfo)\n \t   input_bfd != NULL;\n \t   input_bfd = input_bfd->link.next)\n \tfor (sec = input_bfd->sections; sec != NULL; sec = sec->next)\n-\t  if ((sec->flags & SEC_MARK) != 0 && xcoff_toc_section_p (sec))\n+\t  if (sec->gc_mark != 0 && xcoff_toc_section_p (sec))\n \t    {\n \t      start = sec->output_section->vma + sec->output_offset;\n \t      if (start < best_address"
    }
  ]
}