{
  "sha": "db75b8f70c9546522e81fab557151e6499ed5862",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGI3NWI4ZjcwYzk1NDY1MjJlODFmYWI1NTcxNTFlNjQ5OWVkNTg2Mg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-10-15T22:57:10Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-10-15T23:02:56Z"
    },
    "message": "elf32-cr16.c tidy\n\nPrompted by two occurrences of -Wmisleading-indentation warnings.\n\n\t* elf32-cr16.c: Formatting.\n\t(cr16_elf_final_link_relocate): Sign extend rather than clumsy\n\t\"add or subtract\" of offset value.  Simplify range checks.  Move\n\tcommon code out of \"if\" branches.  Don't refetch insn fields\n\tneedlessly.",
    "tree": {
      "sha": "5cb6015bcc698cb607f9958e8cfe6823bbdc5daf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5cb6015bcc698cb607f9958e8cfe6823bbdc5daf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/db75b8f70c9546522e81fab557151e6499ed5862",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/db75b8f70c9546522e81fab557151e6499ed5862",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/db75b8f70c9546522e81fab557151e6499ed5862",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/db75b8f70c9546522e81fab557151e6499ed5862/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fba8689ad3b72a3e895ebd41485d747dba5da811",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fba8689ad3b72a3e895ebd41485d747dba5da811",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fba8689ad3b72a3e895ebd41485d747dba5da811"
    }
  ],
  "stats": {
    "total": 737,
    "additions": 365,
    "deletions": 372
  },
  "files": [
    {
      "sha": "9595da0db3b2bb19b5056c223fd3a518383c779f",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/db75b8f70c9546522e81fab557151e6499ed5862/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/db75b8f70c9546522e81fab557151e6499ed5862/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=db75b8f70c9546522e81fab557151e6499ed5862",
      "patch": "@@ -1,3 +1,11 @@\n+2020-10-16  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf32-cr16.c: Formatting.\n+\t(cr16_elf_final_link_relocate): Sign extend rather than clumsy\n+\t\"add or subtract\" of offset value.  Simplify range checks.  Move\n+\tcommon code out of \"if\" branches.  Don't refetch insn fields\n+\tneedlessly.\n+\n 2020-10-16  Alan Modra  <amodra@gmail.com>\n \n \t* elf64-ppc.c (ppc64_elf_relocate_section): Tighten sanity check"
    },
    {
      "sha": "c93fd9da8f84ccc4bf2f68f87cbaac3649d4a094",
      "filename": "bfd/elf32-cr16.c",
      "status": "modified",
      "additions": 357,
      "deletions": 372,
      "changes": 729,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/db75b8f70c9546522e81fab557151e6499ed5862/bfd/elf32-cr16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/db75b8f70c9546522e81fab557151e6499ed5862/bfd/elf32-cr16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-cr16.c?ref=db75b8f70c9546522e81fab557151e6499ed5862",
      "patch": "@@ -854,56 +854,56 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,\n \n   switch (r_type)\n     {\n-     case R_CR16_IMM4:\n-     case R_CR16_IMM20:\n-     case R_CR16_ABS20:\n-       break;\n-\n-     case R_CR16_IMM8:\n-     case R_CR16_IMM16:\n-     case R_CR16_IMM32:\n-     case R_CR16_IMM32a:\n-     case R_CR16_REGREL4:\n-     case R_CR16_REGREL4a:\n-     case R_CR16_REGREL14:\n-     case R_CR16_REGREL14a:\n-     case R_CR16_REGREL16:\n-     case R_CR16_REGREL20:\n-     case R_CR16_REGREL20a:\n-     case R_CR16_GOT_REGREL20:\n-     case R_CR16_GOTC_REGREL20:\n-     case R_CR16_ABS24:\n-     case R_CR16_DISP16:\n-     case R_CR16_DISP24:\n-       /* 'hit_data' is relative to the start of the instruction, not the\n-\t   relocation offset. Advance it to account for the exact offset.  */\n-       hit_data += 2;\n-       break;\n-\n-     case R_CR16_NONE:\n-       return bfd_reloc_ok;\n-       break;\n-\n-     case R_CR16_DISP4:\n-       if (is_local)\n+    case R_CR16_IMM4:\n+    case R_CR16_IMM20:\n+    case R_CR16_ABS20:\n+      break;\n+\n+    case R_CR16_IMM8:\n+    case R_CR16_IMM16:\n+    case R_CR16_IMM32:\n+    case R_CR16_IMM32a:\n+    case R_CR16_REGREL4:\n+    case R_CR16_REGREL4a:\n+    case R_CR16_REGREL14:\n+    case R_CR16_REGREL14a:\n+    case R_CR16_REGREL16:\n+    case R_CR16_REGREL20:\n+    case R_CR16_REGREL20a:\n+    case R_CR16_GOT_REGREL20:\n+    case R_CR16_GOTC_REGREL20:\n+    case R_CR16_ABS24:\n+    case R_CR16_DISP16:\n+    case R_CR16_DISP24:\n+      /* 'hit_data' is relative to the start of the instruction, not the\n+\t relocation offset.  Advance it to account for the exact offset.  */\n+      hit_data += 2;\n+      break;\n+\n+    case R_CR16_NONE:\n+      return bfd_reloc_ok;\n+      break;\n+\n+    case R_CR16_DISP4:\n+      if (is_local)\n \tRvalue += -1;\n-       break;\n+      break;\n \n-     case R_CR16_DISP8:\n-     case R_CR16_DISP24a:\n-       if (is_local)\n+    case R_CR16_DISP8:\n+    case R_CR16_DISP24a:\n+      if (is_local)\n \tRvalue -= -1;\n-       break;\n+      break;\n \n-     case R_CR16_SWITCH8:\n-     case R_CR16_SWITCH16:\n-     case R_CR16_SWITCH32:\n-       /* We only care about the addend, where the difference between\n-\t  expressions is kept.  */\n-       Rvalue = 0;\n+    case R_CR16_SWITCH8:\n+    case R_CR16_SWITCH16:\n+    case R_CR16_SWITCH32:\n+      /* We only care about the addend, where the difference between\n+\t expressions is kept.  */\n+      Rvalue = 0;\n \n-     default:\n-       break;\n+    default:\n+      break;\n     }\n \n   if (howto->pc_relative)\n@@ -926,24 +926,23 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,\n \n   /* For GOT and GOTC relocs no boundary checks applied.  */\n   if (!((r_type == R_CR16_GOT_REGREL20)\n-      || (r_type == R_CR16_GOTC_REGREL20)))\n+\t|| (r_type == R_CR16_GOTC_REGREL20)))\n     {\n       if (((bfd_vma) check & ~reloc_bits) != 0\n \t  && (((bfd_vma) check & ~reloc_bits)\n-\t  != (-(bfd_vma) 1 & ~reloc_bits)))\n+\t      != (-(bfd_vma) 1 & ~reloc_bits)))\n \t{\n \t  /* The above right shift is incorrect for a signed\n \t     value.  See if turning on the upper bits fixes the\n \t     overflow.  */\n \t  if (howto->rightshift && (bfd_signed_vma) Rvalue < 0)\n \t    {\n-\t      check |= ((bfd_vma) - 1\n-\t\t\t& ~((bfd_vma) - 1\n-\t\t\t >> howto->rightshift));\n+\t      check |= ((bfd_vma) -1\n+\t\t\t& ~((bfd_vma) -1 >> howto->rightshift));\n \n \t      if (((bfd_vma) check & ~reloc_bits)\n \t\t  != (-(bfd_vma) 1 & ~reloc_bits))\n-\t\t return bfd_reloc_overflow;\n+\t\treturn bfd_reloc_overflow;\n \t    }\n \t  else\n \t    return bfd_reloc_overflow;\n@@ -958,276 +957,248 @@ cr16_elf_final_link_relocate (reloc_howto_type *howto,\n \n   switch (howto->size)\n     {\n-      case 0:\n-\tif (r_type == R_CR16_DISP8)\n-\t  {\n-\t     Rvalue1 = bfd_get_16 (input_bfd, hit_data);\n-\t     Rvalue = ((Rvalue1 & 0xf000) | ((Rvalue << 4) & 0xf00)\n-\t\t       | (Rvalue1 & 0x00f0) | (Rvalue & 0xf));\n-\t     bfd_put_16 (input_bfd, Rvalue, hit_data);\n-\t  }\n-\telse if (r_type == R_CR16_IMM4)\n-\t  {\n-\t     Rvalue1 = bfd_get_16 (input_bfd, hit_data);\n-\t     Rvalue = (((Rvalue1 & 0xff) << 8) | ((Rvalue << 4) & 0xf0)\n-\t\t       | ((Rvalue1 & 0x0f00) >> 8));\n-\t     bfd_put_16 (input_bfd, Rvalue, hit_data);\n-\t  }\n-\telse if (r_type == R_CR16_DISP4)\n-\t  {\n-\t     Rvalue1 = bfd_get_16 (input_bfd, hit_data);\n-\t     Rvalue = (Rvalue1 | ((Rvalue & 0xf) << 4));\n-\t     bfd_put_16 (input_bfd, Rvalue, hit_data);\n-\t  }\n-\telse\n-\t  {\n-\t     bfd_put_8 (input_bfd, (unsigned char) Rvalue, hit_data);\n-\t  }\n-\tbreak;\n-\n-      case 1:\n-\tif (r_type == R_CR16_DISP16)\n-\t  {\n-\t    Rvalue |= (bfd_get_16 (input_bfd, hit_data));\n-\t    Rvalue = ((Rvalue & 0xfffe) | ((Rvalue >> 16) & 0x1));\n-\t  }\n-\tif (r_type == R_CR16_IMM16)\n-\t  {\n-\t    Rvalue1 = bfd_get_16 (input_bfd, hit_data);\n-\n-\t    /* Add or subtract the offset value.  */\n-\t    if (Rvalue1 & 0x8000)\n-\t      Rvalue -= (~Rvalue1 + 1) & 0xffff;\n-\t    else\n-\t      Rvalue += Rvalue1;\n+    case 0:\n+      if (r_type == R_CR16_DISP8)\n+\t{\n+\t  Rvalue1 = bfd_get_16 (input_bfd, hit_data);\n+\t  Rvalue = ((Rvalue1 & 0xf000) | ((Rvalue << 4) & 0xf00)\n+\t\t    | (Rvalue1 & 0x00f0) | (Rvalue & 0xf));\n+\t  bfd_put_16 (input_bfd, Rvalue, hit_data);\n+\t}\n+      else if (r_type == R_CR16_IMM4)\n+\t{\n+\t  Rvalue1 = bfd_get_16 (input_bfd, hit_data);\n+\t  Rvalue = (((Rvalue1 & 0xff) << 8) | ((Rvalue << 4) & 0xf0)\n+\t\t    | ((Rvalue1 & 0x0f00) >> 8));\n+\t  bfd_put_16 (input_bfd, Rvalue, hit_data);\n+\t}\n+      else if (r_type == R_CR16_DISP4)\n+\t{\n+\t  Rvalue1 = bfd_get_16 (input_bfd, hit_data);\n+\t  Rvalue = (Rvalue1 | ((Rvalue & 0xf) << 4));\n+\t  bfd_put_16 (input_bfd, Rvalue, hit_data);\n+\t}\n+      else\n+\t{\n+\t  bfd_put_8 (input_bfd, (unsigned char) Rvalue, hit_data);\n+\t}\n+      break;\n+\n+    case 1:\n+      if (r_type == R_CR16_DISP16)\n+\t{\n+\t  Rvalue |= (bfd_get_16 (input_bfd, hit_data));\n+\t  Rvalue = ((Rvalue & 0xfffe) | ((Rvalue >> 16) & 0x1));\n+\t}\n+      if (r_type == R_CR16_IMM16)\n+\t{\n+\t  Rvalue1 = bfd_get_16 (input_bfd, hit_data);\n+\n+\t  Rvalue1 = (Rvalue1 ^ 0x8000) - 0x8000;\n+\t  Rvalue += Rvalue1;\n \n-\t     /* Check for range.  */\n-\t     if ((long) Rvalue > 0xffff || (long) Rvalue < 0x0)\n-\t      return bfd_reloc_overflow;\n-\t  }\n+\t  /* Check for range.  */\n+\t  if (Rvalue > 0xffff)\n+\t    return bfd_reloc_overflow;\n+\t}\n \n-\tbfd_put_16 (input_bfd, Rvalue, hit_data);\n-\tbreak;\n+      bfd_put_16 (input_bfd, Rvalue, hit_data);\n+      break;\n \n-      case 2:\n-\tif ((r_type == R_CR16_ABS20) || (r_type == R_CR16_IMM20))\n-\t  {\n-\t     Rvalue1 = (bfd_get_16 (input_bfd, hit_data + 2)\n-\t\t\t| (((bfd_get_16 (input_bfd, hit_data) & 0xf) <<16)));\n+    case 2:\n+      if ((r_type == R_CR16_ABS20) || (r_type == R_CR16_IMM20))\n+\t{\n+\t  Rvalue1 = (bfd_get_16 (input_bfd, hit_data + 2)\n+\t\t     | (((bfd_get_16 (input_bfd, hit_data) & 0xf) << 16)));\n \n-\t     /* Add or subtract the offset value.  */\n-\t     if (Rvalue1 & 0x80000)\n-\t\tRvalue -= (~Rvalue1 + 1) & 0xfffff;\n-\t      else\n-\t\tRvalue += Rvalue1;\n+\t  Rvalue1 = (Rvalue1 ^ 0x80000) - 0x80000;\n+\t  Rvalue += Rvalue1;\n \n-\t      /* Check for range.  */\n-\t      if ((long) Rvalue > 0xfffff || (long) Rvalue < 0x0)\n-\t       return bfd_reloc_overflow;\n-\n-\t    bfd_put_16 (input_bfd, ((bfd_get_16 (input_bfd, hit_data) & 0xfff0)\n-\t\t\t| ((Rvalue >> 16) & 0xf)), hit_data);\n-\t    bfd_put_16 (input_bfd, (Rvalue) & 0xffff, hit_data + 2);\n-\t  }\n-\telse if (r_type == R_CR16_GOT_REGREL20)\n-\t  {\n-\t    asection *sgot = elf_hash_table (info)->sgot;\n-\n-\t    if (h != NULL)\n-\t      {\n-\t\tbfd_vma off;\n-\n-\t\toff = h->got.offset;\n-\t\tBFD_ASSERT (off != (bfd_vma) -1);\n-\n-\t\tif (! elf_hash_table (info)->dynamic_sections_created\n-\t\t     || SYMBOL_REFERENCES_LOCAL (info, h))\n-\t\t    /* This is actually a static link, or it is a\n-\t\t       -Bsymbolic link and the symbol is defined\n-\t\t       locally, or the symbol was forced to be local\n-\t\t       because of a version file.  We must initialize\n-\t\t       this entry in the global offset table.\n-\t\t       When doing a dynamic link, we create a .rela.got\n-\t\t       relocation entry to initialize the value.  This\n-\t\t       is done in the finish_dynamic_symbol routine.  */\n-\t\t  bfd_put_32 (output_bfd, Rvalue, sgot->contents + off);\n-\n-\t\t  Rvalue = sgot->output_offset + off;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t   bfd_vma off;\n+\t  /* Check for range.  */\n+\t  if (Rvalue > 0xfffff)\n+\t    return bfd_reloc_overflow;\n \n-\t\t   off = elf_local_got_offsets (input_bfd)[symndx];\n-\t\t   bfd_put_32 (output_bfd,Rvalue, sgot->contents + off);\n+\t  bfd_put_16 (input_bfd, ((bfd_get_16 (input_bfd, hit_data) & 0xfff0)\n+\t\t\t\t  | ((Rvalue >> 16) & 0xf)), hit_data);\n+\t  bfd_put_16 (input_bfd, (Rvalue) & 0xffff, hit_data + 2);\n+\t}\n+      else if (r_type == R_CR16_GOT_REGREL20)\n+\t{\n+\t  asection *sgot = elf_hash_table (info)->sgot;\n+\t  bfd_vma off;\n+\n+\t  if (h != NULL)\n+\t    {\n+\t      off = h->got.offset;\n+\t      BFD_ASSERT (off != (bfd_vma) -1);\n+\n+\t      if (! elf_hash_table (info)->dynamic_sections_created\n+\t\t  || SYMBOL_REFERENCES_LOCAL (info, h))\n+\t\t/* This is actually a static link, or it is a\n+\t\t   -Bsymbolic link and the symbol is defined\n+\t\t   locally, or the symbol was forced to be local\n+\t\t   because of a version file.  We must initialize\n+\t\t   this entry in the global offset table.\n+\t\t   When doing a dynamic link, we create a .rela.got\n+\t\t   relocation entry to initialize the value.  This\n+\t\t   is done in the finish_dynamic_symbol routine.  */\n+\t\tbfd_put_32 (output_bfd, Rvalue, sgot->contents + off);\n+\t    }\n+\t  else\n+\t    {\n+\t      off = elf_local_got_offsets (input_bfd)[symndx];\n+\t      bfd_put_32 (output_bfd, Rvalue, sgot->contents + off);\n+\t    }\n+\n+\t  Rvalue = sgot->output_offset + off;\n+\t  Rvalue += addend;\n+\n+\t  /* REVISIT: if ((long) Rvalue > 0xffffff ||\n+\t     (long) Rvalue < -0x800000).  */\n+\t  if (Rvalue > 0xffffff)\n+\t    return bfd_reloc_overflow;\n \n-\t\t   Rvalue = sgot->output_offset + off;\n-\t\t}\n \n-\t     Rvalue += addend;\n+\t  bfd_put_16 (input_bfd, (bfd_get_16 (input_bfd, hit_data))\n+\t\t      | (((Rvalue >> 16) & 0xf) << 8), hit_data);\n+\t  bfd_put_16 (input_bfd, (Rvalue) & 0xffff, hit_data + 2);\n \n-\t     /* REVISIT: if ((long) Rvalue > 0xffffff ||\n-\t\t\t\t    (long) Rvalue < -0x800000).  */\n-\t     if ((long) Rvalue > 0xffffff || (long) Rvalue < 0)\n-\t       return bfd_reloc_overflow;\n+\t}\n+      else if (r_type == R_CR16_GOTC_REGREL20)\n+\t{\n+\t  asection *sgot = elf_hash_table (info)->sgot;\n+\t  bfd_vma off;\n+\n+\t  if (h != NULL)\n+\t    {\n+\t      off = h->got.offset;\n+\t      BFD_ASSERT (off != (bfd_vma) -1);\n+\n+\t      Rvalue >>= 1; /* For code symbols.  */\n+\n+\t      if (! elf_hash_table (info)->dynamic_sections_created\n+\t\t  || SYMBOL_REFERENCES_LOCAL (info, h))\n+\t\t/* This is actually a static link, or it is a\n+\t\t   -Bsymbolic link and the symbol is defined\n+\t\t   locally, or the symbol was forced to be local\n+\t\t   because of a version file.  We must initialize\n+\t\t   this entry in the global offset table.\n+\t\t   When doing a dynamic link, we create a .rela.got\n+\t\t   relocation entry to initialize the value.  This\n+\t\t   is done in the finish_dynamic_symbol routine.  */\n+\t\tbfd_put_32 (output_bfd, Rvalue, sgot->contents + off);\n+\t    }\n+\t  else\n+\t    {\n+\t      off = elf_local_got_offsets (input_bfd)[symndx];\n+\t      Rvalue >>= 1;\n+\t      bfd_put_32 (output_bfd, Rvalue, sgot->contents + off);\n+\t    }\n \n+\t  Rvalue = sgot->output_offset + off;\n+\t  Rvalue += addend;\n \n-\t     bfd_put_16 (input_bfd, (bfd_get_16 (input_bfd, hit_data))\n-\t\t\t | (((Rvalue >> 16) & 0xf) << 8), hit_data);\n-\t     bfd_put_16 (input_bfd, (Rvalue) & 0xffff, hit_data + 2);\n+\t  /* Check if any value in DISP.  */\n+\t  Rvalue1 = bfd_get_32 (input_bfd, hit_data);\n+\t  Rvalue1 = ((Rvalue1 >> 16) | ((Rvalue1 & 0xfff) >> 8 << 16));\n \n-\t  }\n-\telse if (r_type == R_CR16_GOTC_REGREL20)\n-\t  {\n-\t     asection *sgot = elf_hash_table (info)->sgot;\n+\t  Rvalue1 = (Rvalue1 ^ 0x80000) - 0x80000;\n+\t  Rvalue += Rvalue1;\n \n-\t     if (h != NULL)\n-\t       {\n-\t\t bfd_vma off;\n+\t  /* Check for range.  */\n+\t  /* REVISIT: if ((long) Rvalue > 0xffffff\n+\t     || (long) Rvalue < -0x800000).  */\n+\t  if (Rvalue > 0xffffff)\n+\t    return bfd_reloc_overflow;\n \n-\t\t off = h->got.offset;\n-\t\t BFD_ASSERT (off != (bfd_vma) -1);\n+\t  bfd_put_16 (input_bfd, (bfd_get_16 (input_bfd, hit_data))\n+\t\t      | (((Rvalue >> 16) & 0xf) << 8), hit_data);\n+\t  bfd_put_16 (input_bfd, (Rvalue) & 0xffff, hit_data + 2);\n+\t}\n+      else\n+\t{\n+\t  if (r_type == R_CR16_ABS24)\n+\t    {\n+\t      Rvalue1 = bfd_get_32 (input_bfd, hit_data);\n+\t      Rvalue1 = ((Rvalue1 >> 16)\n+\t\t\t | ((Rvalue1 & 0xfff) >> 8 << 16)\n+\t\t\t | ((Rvalue1 & 0xf) << 20));\n \n-\t\t  Rvalue >>=1; /* For code symbols.  */\n+\t      Rvalue1 = (Rvalue1 ^ 0x800000) - 0x800000;\n+\t      Rvalue += Rvalue1;\n \n-\t\t if (! elf_hash_table (info)->dynamic_sections_created\n-\t\t      || SYMBOL_REFERENCES_LOCAL (info, h))\n-\t\t /* This is actually a static link, or it is a\n-\t\t    -Bsymbolic link and the symbol is defined\n-\t\t     locally, or the symbol was forced to be local\n-\t\t     because of a version file.  We must initialize\n-\t\t     this entry in the global offset table.\n-\t\t     When doing a dynamic link, we create a .rela.got\n-\t\t     relocation entry to initialize the value.  This\n-\t\t     is done in the finish_dynamic_symbol routine.  */\n-\t\t  bfd_put_32 (output_bfd, Rvalue, sgot->contents + off);\n+\t      /* Check for Range.  */\n+\t      if (Rvalue > 0xffffff)\n+\t\treturn bfd_reloc_overflow;\n \n-\t\t  Rvalue = sgot->output_offset + off;\n-\t       }\n-\t     else\n-\t       {\n-\t\t  bfd_vma off;\n+\t      Rvalue = ((((Rvalue >> 20) & 0xf) | (((Rvalue >> 16) & 0xf)<<8)\n+\t\t\t | (bfd_get_32 (input_bfd, hit_data) & 0xf0f0))\n+\t\t\t| ((Rvalue & 0xffff) << 16));\n+\t    }\n+\t  else if (r_type == R_CR16_DISP24)\n+\t    {\n+\t      Rvalue = ((((Rvalue >> 20)& 0xf) | (((Rvalue >>16) & 0xf)<<8)\n+\t\t\t | (bfd_get_16 (input_bfd, hit_data)))\n+\t\t\t| (((Rvalue & 0xfffe) | ((Rvalue >> 24) & 0x1)) << 16));\n+\t    }\n+\t  else if ((r_type == R_CR16_IMM32) || (r_type == R_CR16_IMM32a))\n+\t    {\n+\t      Rvalue1 = bfd_get_32 (input_bfd, hit_data);\n+\t      Rvalue1 = (((Rvalue1 >> 16) & 0xffff)\n+\t\t\t | ((Rvalue1 & 0xffff) << 16));\n \n-\t\t  off = elf_local_got_offsets (input_bfd)[symndx];\n-\t\t  Rvalue >>= 1;\n-\t\t  bfd_put_32 (output_bfd,Rvalue, sgot->contents + off);\n-\t\t  Rvalue = sgot->output_offset + off;\n-\t       }\n+\t      Rvalue1 = (Rvalue1 ^ 0x80000000) - 0x80000000;\n+\t      Rvalue += Rvalue1;\n \n-\t     Rvalue += addend;\n+\t      /* Check for range.  */\n+\t      if (Rvalue > 0xffffffff)\n+\t\treturn bfd_reloc_overflow;\n \n-\t     /* Check if any value in DISP.  */\n-\t     Rvalue1 =((bfd_get_32 (input_bfd, hit_data) >>16)\n-\t\t       | (((bfd_get_32 (input_bfd, hit_data) & 0xfff) >> 8) <<16));\n+\t      Rvalue = (((Rvalue >> 16) & 0xffff) | (Rvalue & 0xffff) << 16);\n+\t    }\n+\t  else if (r_type == R_CR16_DISP24a)\n+\t    {\n+\t      Rvalue = (((Rvalue & 0xfffffe) | (Rvalue >> 23)));\n+\t      Rvalue = (((Rvalue >> 16) & 0xff) | ((Rvalue & 0xffff) << 16)\n+\t\t\t| bfd_get_32 (input_bfd, hit_data));\n+\t    }\n+\t  else if ((r_type == R_CR16_REGREL20)\n+\t\t   || (r_type == R_CR16_REGREL20a))\n+\t    {\n+\t      Rvalue1 = bfd_get_32 (input_bfd, hit_data);\n+\t      Rvalue1 = (((Rvalue1 >> 16) & 0xffff)\n+\t\t\t | ((Rvalue1 & 0xfff) >> 8 << 16));\n \n-\t     /* Add or subtract the offset value.  */\n-\t     if (Rvalue1 & 0x80000)\n-\t       Rvalue -= (~Rvalue1 + 1) & 0xfffff;\n-\t     else\n-\t       Rvalue += Rvalue1;\n+\t      Rvalue1 = (Rvalue1 ^ 0x80000) - 0x80000;\n+\t      Rvalue += Rvalue1;\n \n \t      /* Check for range.  */\n-\t     /* REVISIT: if ((long) Rvalue > 0xffffff\n-\t\t\t     || (long) Rvalue < -0x800000).  */\n-\t     if ((long) Rvalue > 0xffffff || (long) Rvalue < 0)\n-\t       return bfd_reloc_overflow;\n-\n-\t     bfd_put_16 (input_bfd, (bfd_get_16 (input_bfd, hit_data))\n-\t\t\t | (((Rvalue >> 16) & 0xf) << 8), hit_data);\n-\t     bfd_put_16 (input_bfd, (Rvalue) & 0xffff, hit_data + 2);\n-\t  }\n-\telse\n-\t  {\n-\t     if (r_type == R_CR16_ABS24)\n-\t       {\n-\t\t  Rvalue1 = ((bfd_get_32 (input_bfd, hit_data) >> 16)\n-\t\t\t     | (((bfd_get_32 (input_bfd, hit_data) & 0xfff) >> 8) <<16)\n-\t\t\t     | (((bfd_get_32 (input_bfd, hit_data) & 0xf) <<20)));\n-\n-\t\t  /* Add or subtract the offset value.  */\n-\t\t  if (Rvalue1 & 0x800000)\n-\t\t    Rvalue -= (~Rvalue1 + 1) & 0xffffff;\n-\t\t  else\n-\t\t    Rvalue += Rvalue1;\n-\n-\t\t /* Check for Range.  */\n-\t\t if ((long) Rvalue > 0xffffff || (long) Rvalue < 0x0)\n-\t\t   return bfd_reloc_overflow;\n-\n-\t\t Rvalue = ((((Rvalue >> 20) & 0xf) | (((Rvalue >> 16) & 0xf)<<8)\n-\t\t\t   | (bfd_get_32 (input_bfd, hit_data) & 0xf0f0))\n-\t\t\t   | ((Rvalue & 0xffff) << 16));\n-\t       }\n-\t     else if (r_type == R_CR16_DISP24)\n-\t       {\n-\t\t  Rvalue = ((((Rvalue >> 20)& 0xf) | (((Rvalue >>16) & 0xf)<<8)\n-\t\t\t    | (bfd_get_16 (input_bfd, hit_data)))\n-\t\t\t    | (((Rvalue & 0xfffe) | ((Rvalue >> 24) & 0x1)) << 16));\n-\t       }\n-\t     else if ((r_type == R_CR16_IMM32) || (r_type == R_CR16_IMM32a))\n-\t       {\n-\t\t  Rvalue1 =((((bfd_get_32 (input_bfd, hit_data)) >> 16) &0xffff)\n-\t\t\t    | (((bfd_get_32 (input_bfd, hit_data)) &0xffff)) << 16);\n-\n-\t\t /* Add or subtract the offset value.  */\n-\t\t if (Rvalue1 & 0x80000000)\n-\t\t   Rvalue -= (~Rvalue1 + 1) & 0xffffffff;\n-\t\t else\n-\t\t   Rvalue += Rvalue1;\n-\n-\t\t /* Check for range.  */\n-\t\t if (Rvalue > 0xffffffff || (long) Rvalue < 0x0)\n-\t\t   return bfd_reloc_overflow;\n-\n-\t\t Rvalue = (((Rvalue >> 16)& 0xffff) | (Rvalue & 0xffff) << 16);\n-\t       }\n-\t     else if (r_type == R_CR16_DISP24a)\n-\t       {\n-\t\t  Rvalue = (((Rvalue & 0xfffffe) | (Rvalue >> 23)));\n-\t\t  Rvalue = ((Rvalue >> 16) & 0xff) | ((Rvalue & 0xffff) << 16)\n-\t\t\t    | (bfd_get_32 (input_bfd, hit_data));\n-\t       }\n-\t     else if ((r_type == R_CR16_REGREL20)\n-\t\t      || (r_type == R_CR16_REGREL20a))\n-\t       {\n-\t\t  Rvalue1 = ((bfd_get_32 (input_bfd, hit_data) >> 16)\n-\t\t\t     | (((bfd_get_32 (input_bfd, hit_data) & 0xfff) >> 8) <<16));\n-\t\t  /* Add or subtract the offset value.  */\n-\t\t  if (Rvalue1 & 0x80000)\n-\t\t     Rvalue -= (~Rvalue1 + 1) & 0xfffff;\n-\t\t  else\n-\t\t     Rvalue += Rvalue1;\n-\n-\t\t  /* Check for range.  */\n-\t\t  if ((long) Rvalue > 0xfffff || (long) Rvalue < 0x0)\n-\t\t    return bfd_reloc_overflow;\n-\n-\t\t  Rvalue = (((((Rvalue >> 20)& 0xf) | (((Rvalue >>16) & 0xf)<<8)\n-\t\t\t    | ((Rvalue & 0xffff) << 16)))\n-\t\t\t    | (bfd_get_32 (input_bfd, hit_data) & 0xf0ff));\n-\n-\t      }\n-\t    else if (r_type == R_CR16_NUM32)\n-\t      {\n-\t\t Rvalue1 = (bfd_get_32 (input_bfd, hit_data));\n-\n-\t\t /* Add or subtract the offset value */\n-\t\t if (Rvalue1 & 0x80000000)\n-\t\t   Rvalue -= (~Rvalue1 + 1) & 0xffffffff;\n-\t\t else\n-\t\t   Rvalue += Rvalue1;\n-\n-\t\t/* Check for Ranga */\n-\t\tif (Rvalue > 0xffffffff)\n-\t\t  return bfd_reloc_overflow;\n-\t      }\n-\n-\t    bfd_put_32 (input_bfd, Rvalue, hit_data);\n-\t  }\n-\tbreak;\n-\n-      default:\n-\treturn bfd_reloc_notsupported;\n+\t      if (Rvalue > 0xfffff)\n+\t\treturn bfd_reloc_overflow;\n+\n+\t      Rvalue = (((((Rvalue >> 20) & 0xf) | (((Rvalue >> 16) & 0xf) << 8)\n+\t\t\t  | ((Rvalue & 0xffff) << 16)))\n+\t\t\t| (bfd_get_32 (input_bfd, hit_data) & 0xf0ff));\n+\n+\t    }\n+\t  else if (r_type == R_CR16_NUM32)\n+\t    {\n+\t      Rvalue1 = (bfd_get_32 (input_bfd, hit_data));\n+\n+\t      Rvalue1 = (Rvalue1 ^ 0x80000000) - 0x80000000;\n+\t      Rvalue += Rvalue1;\n+\n+\t      /* Check for Range.  */\n+\t      if (Rvalue > 0xffffffff)\n+\t\treturn bfd_reloc_overflow;\n+\t    }\n+\n+\t  bfd_put_32 (input_bfd, Rvalue, hit_data);\n+\t}\n+      break;\n+\n+    default:\n+      return bfd_reloc_notsupported;\n     }\n \n   return bfd_reloc_ok;\n@@ -1269,7 +1240,7 @@ elf32_cr16_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,\n   for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)\n     /* Get the new reloc address.  */\n     if ((irel->r_offset > addr && irel->r_offset < toaddr))\n-\tirel->r_offset -= count;\n+      irel->r_offset -= count;\n \n   /* Adjust the local symbols defined in this section.  */\n   symtab_hdr = &elf_tdata (abfd)->symtab_hdr;\n@@ -1293,7 +1264,7 @@ elf32_cr16_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,\n \t      if (ELF32_R_TYPE (irel->r_info) != (int) R_CR16_SWITCH8\n \t\t  && ELF32_R_TYPE (irel->r_info) != (int) R_CR16_SWITCH16\n \t\t  && ELF32_R_TYPE (irel->r_info) != (int) R_CR16_SWITCH32)\n-\t\t continue;\n+\t\tcontinue;\n \n \t      r_symndx = ELF32_R_SYM (irel->r_info);\n \t      rsym = (Elf_Internal_Sym *) symtab_hdr->contents + r_symndx;\n@@ -1319,7 +1290,7 @@ elf32_cr16_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,\n \n   /* Now adjust the global symbols defined in this section.  */\n   symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)\n-\t       - symtab_hdr->sh_info);\n+\t      - symtab_hdr->sh_info);\n   sym_hashes = start_hashes = elf_sym_hashes (abfd);\n   end_hashes = sym_hashes + symcount;\n \n@@ -1352,7 +1323,7 @@ elf32_cr16_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,\n \t}\n \n       if ((sym_hash->root.type == bfd_link_hash_defined\n-\t  || sym_hash->root.type == bfd_link_hash_defweak)\n+\t   || sym_hash->root.type == bfd_link_hash_defweak)\n \t  && sym_hash->root.u.def.section == sec\n \t  && sym_hash->root.u.def.value > addr\n \t  && sym_hash->root.u.def.value < toaddr)\n@@ -1446,37 +1417,37 @@ elf32_cr16_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \n \t  switch (r)\n \t    {\n-\t     case bfd_reloc_overflow:\n-\t       (*info->callbacks->reloc_overflow)\n-\t\t (info, (h ? &h->root : NULL), name, howto->name,\n-\t\t  (bfd_vma) 0, input_bfd, input_section, rel->r_offset);\n-\t       break;\n-\n-\t     case bfd_reloc_undefined:\n-\t       (*info->callbacks->undefined_symbol)\n-\t\t (info, name, input_bfd, input_section, rel->r_offset, TRUE);\n-\t       break;\n-\n-\t     case bfd_reloc_outofrange:\n-\t       msg = _(\"internal error: out of range error\");\n-\t       goto common_error;\n-\n-\t     case bfd_reloc_notsupported:\n-\t       msg = _(\"internal error: unsupported relocation error\");\n-\t       goto common_error;\n-\n-\t     case bfd_reloc_dangerous:\n-\t       msg = _(\"internal error: dangerous error\");\n-\t       goto common_error;\n-\n-\t     default:\n-\t       msg = _(\"internal error: unknown error\");\n-\t       /* Fall through.  */\n-\n-\t     common_error:\n-\t       (*info->callbacks->warning) (info, msg, name, input_bfd,\n-\t\t\t\t\t    input_section, rel->r_offset);\n-\t       break;\n+\t    case bfd_reloc_overflow:\n+\t      (*info->callbacks->reloc_overflow)\n+\t\t(info, (h ? &h->root : NULL), name, howto->name,\n+\t\t (bfd_vma) 0, input_bfd, input_section, rel->r_offset);\n+\t      break;\n+\n+\t    case bfd_reloc_undefined:\n+\t      (*info->callbacks->undefined_symbol)\n+\t\t(info, name, input_bfd, input_section, rel->r_offset, TRUE);\n+\t      break;\n+\n+\t    case bfd_reloc_outofrange:\n+\t      msg = _(\"internal error: out of range error\");\n+\t      goto common_error;\n+\n+\t    case bfd_reloc_notsupported:\n+\t      msg = _(\"internal error: unsupported relocation error\");\n+\t      goto common_error;\n+\n+\t    case bfd_reloc_dangerous:\n+\t      msg = _(\"internal error: dangerous error\");\n+\t      goto common_error;\n+\n+\t    default:\n+\t      msg = _(\"internal error: unknown error\");\n+\t      /* Fall through.  */\n+\n+\t    common_error:\n+\t      (*info->callbacks->warning) (info, msg, name, input_bfd,\n+\t\t\t\t\t   input_section, rel->r_offset);\n+\t      break;\n \t    }\n \t}\n     }\n@@ -1564,8 +1535,8 @@ elf32_cr16_get_relocated_section_contents (bfd *output_bfd,\n \t}\n \n       if (! elf32_cr16_relocate_section (output_bfd, link_info, input_bfd,\n-\t\t\t\t     input_section, data, internal_relocs,\n-\t\t\t\t     isymbuf, sections))\n+\t\t\t\t\t input_section, data, internal_relocs,\n+\t\t\t\t\t isymbuf, sections))\n \tgoto error_return;\n \n       free (sections);\n@@ -1655,8 +1626,8 @@ elf_cr16_mach (flagword flags)\n {\n   switch (flags)\n     {\n-      case EM_CR16:\n-      default:\n+    case EM_CR16:\n+    default:\n       return bfd_mach_cr16;\n     }\n }\n@@ -1671,10 +1642,10 @@ _bfd_cr16_elf_final_write_processing (bfd *abfd)\n   unsigned long val;\n   switch (bfd_get_mach (abfd))\n     {\n-     default:\n-     case bfd_mach_cr16:\n-\tval = EM_CR16;\n-\tbreak;\n+    default:\n+    case bfd_mach_cr16:\n+      val = EM_CR16;\n+      break;\n     }\n   elf_elfheader (abfd)->e_flags |= val;\n   return _bfd_elf_final_write_processing (abfd);\n@@ -1706,8 +1677,8 @@ _bfd_cr16_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n     {\n       if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),\n \t\t\t       bfd_get_mach (ibfd)))\n-\t return FALSE;\n-     }\n+\treturn FALSE;\n+    }\n \n   return TRUE;\n }\n@@ -1861,11 +1832,13 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \t      unsigned int code;\n \n \t      /* Get the opcode.  */\n-\t      code = (unsigned int) bfd_get_32 (abfd, contents + irel->r_offset);\n+\t      code = (unsigned int) bfd_get_32 (abfd,\n+\t\t\t\t\t\tcontents + irel->r_offset);\n \n \t      /* Verify it's a 'bcond' and fix the opcode.  */\n \t      if ((code  & 0xffff) == 0x0010)\n-\t\tbfd_put_16 (abfd, 0x1800 | ((0xf & (code >> 20)) << 4), contents + irel->r_offset);\n+\t\tbfd_put_16 (abfd, 0x1800 | ((0xf & (code >> 20)) << 4),\n+\t\t\t    contents + irel->r_offset);\n \t      else\n \t\tcontinue;\n \n@@ -1880,7 +1853,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \n \t      /* Delete two bytes of data.  */\n \t      if (!elf32_cr16_relax_delete_bytes (link_info, abfd, sec,\n-\t\t\t\t\t\t   irel->r_offset + 2, 2))\n+\t\t\t\t\t\t  irel->r_offset + 2, 2))\n \t\tgoto error_return;\n \n \t      /* That will change things, so, we should relax again.\n@@ -1909,7 +1882,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \t      unsigned short code;\n \n \t      /* Get the opcode.  */\n-\t      code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);\n+\t      code = bfd_get_16 (abfd, contents + irel->r_offset);\n \n \t      /* Verify it's a 'bcond' and fix the opcode.  */\n \t      if ((code & 0xff0f) == 0x1800)\n@@ -1928,7 +1901,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \n \t      /* Delete two bytes of data.  */\n \t      if (!elf32_cr16_relax_delete_bytes (link_info, abfd, sec,\n-\t\t\t\t\t\t   irel->r_offset + 2, 2))\n+\t\t\t\t\t\t  irel->r_offset + 2, 2))\n \t\tgoto error_return;\n \n \t      /* That will change things, so, we should relax again.\n@@ -1945,22 +1918,22 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \t  bfd_vma value1 = 0;\n \n \t  /* Get the existing value from the mcode */\n-\t  value1 = ((bfd_get_32 (abfd, contents + irel->r_offset + 2) >> 16)\n-\t\t   |(((bfd_get_32 (abfd, contents + irel->r_offset + 2) & 0xffff) << 16)));\n+\t  value1 = bfd_get_32 (abfd, contents + irel->r_offset + 2);\n+\t  value1 = (value1 >> 16) | ((value1 & 0xffff) << 16);\n \n \t  /* See if the value will fit in 20 bits.  */\n \t  if ((long) (value + value1) < 0xfffff && (long) (value + value1) > 0)\n \t    {\n \t      unsigned short code;\n \n \t      /* Get the opcode.  */\n-\t      code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);\n+\t      code = bfd_get_16 (abfd, contents + irel->r_offset);\n \n \t      /* Verify it's a 'arithmetic ADDD or MOVD instruction'.\n \t\t For ADDD and MOVD only, convert to IMM32 -> IMM20.  */\n \n \t      if (((code & 0xfff0) == 0x0070) || ((code & 0xfff0) == 0x0020))\n-\t\t is_add_mov = 1;\n+\t\tis_add_mov = 1;\n \n \t      if (is_add_mov)\n \t\t{\n@@ -1982,9 +1955,16 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \t\t     place the 16-20bits (ie 4 bit) in new opcode,\n \t\t     as the 0xffffxxxx, the higher 2 byte values removed. */\n \t\t  if (value1 & 0x80000000)\n-\t\t    bfd_put_8 (abfd, (0x0f | (bfd_get_8(abfd, contents + irel->r_offset))), contents + irel->r_offset);\n+\t\t    bfd_put_8 (abfd,\n+\t\t\t       (0x0f | (bfd_get_8 (abfd,\n+\t\t\t\t\t\t   contents + irel->r_offset))),\n+\t\t\t       contents + irel->r_offset);\n \t\t  else\n-\t\t    bfd_put_8 (abfd, (((value1 >> 16)&0xf) | (bfd_get_8(abfd, contents + irel->r_offset))), contents + irel->r_offset);\n+\t\t    bfd_put_8 (abfd,\n+\t\t\t       (((value1 >> 16) & 0xf)\n+\t\t\t\t| (bfd_get_8 (abfd,\n+\t\t\t\t\t      contents + irel->r_offset))),\n+\t\t\t       contents + irel->r_offset);\n \n \t\t  /* Fix the relocation's type.  */\n \t\t  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),\n@@ -2008,7 +1988,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \t      unsigned short code;\n \n \t      /* Get the opcode.  */\n-\t      code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);\n+\t      code = bfd_get_16 (abfd, contents + irel->r_offset);\n \n \t      /* Note that we've changed the relocs, section contents, etc.  */\n \t      elf_section_data (sec)->relocs = internal_relocs;\n@@ -2031,7 +2011,10 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \t\t place the 12-16bits (ie 4 bit) in new opcode,\n \t\t as the 0xfffffxxx, the higher 2 byte values removed. */\n \t      if (value1 & 0x80000000)\n-\t\tbfd_put_8 (abfd, (0x0f | (bfd_get_8(abfd, contents + irel->r_offset))), contents + irel->r_offset);\n+\t\tbfd_put_8 (abfd,\n+\t\t\t   (0x0f | (bfd_get_8 (abfd,\n+\t\t\t\t\t       contents + irel->r_offset))),\n+\t\t\t   contents + irel->r_offset);\n \t      else\n \t\tbfd_put_16 (abfd, value1, contents + irel->r_offset + 2);\n \n@@ -2065,7 +2048,8 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \n \t  if (ELF32_R_TYPE (irel->r_info) == (int) R_CR16_IMM20)\n \t    {\n-\t      value1 |= ((bfd_get_16 (abfd, contents + irel->r_offset + 1) & 0xf000) << 0x4);\n+\t      value1 |= ((bfd_get_16 (abfd, contents + irel->r_offset + 1)\n+\t\t\t  & 0xf000) << 0x4);\n \t    }\n \n \t  /* See if the value will fit in 4 bits.  */\n@@ -2075,7 +2059,7 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \t      unsigned short code;\n \n \t      /* Get the opcode.  */\n-\t      code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);\n+\t      code = bfd_get_16 (abfd, contents + irel->r_offset);\n \n \t      /* Note that we've changed the relocs, section contents, etc.  */\n \t      elf_section_data (sec)->relocs = internal_relocs;\n@@ -2089,7 +2073,8 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n \t\t    bfd_put_8 (abfd, 0x60, contents + irel->r_offset);\n \t\t  else\t\t\t\t      /* For addd imm20.  */\n \t\t    bfd_put_8 (abfd, 0x54, contents + irel->r_offset);\n-\t\t  bfd_put_8 (abfd, (code & 0xf0) >> 4, contents + irel->r_offset + 1);\n+\t\t  bfd_put_8 (abfd, (code & 0xf0) >> 4,\n+\t\t\t     contents + irel->r_offset + 1);\n \t\t}\n \t      else\n \t\t{\n@@ -2150,8 +2135,8 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n       if (! link_info->keep_memory)\n \tfree (isymbuf);\n       else\n-       /* Cache the symbols for elf_link_input_bfd.  */\n-       symtab_hdr->contents = (unsigned char *) isymbuf;\n+\t/* Cache the symbols for elf_link_input_bfd.  */\n+\tsymtab_hdr->contents = (unsigned char *) isymbuf;\n     }\n \n   if (contents != NULL\n@@ -2160,8 +2145,8 @@ elf32_cr16_relax_section (bfd *abfd, asection *sec,\n       if (! link_info->keep_memory)\n \tfree (contents);\n       else\n-       /* Cache the section contents for elf_link_input_bfd.  */\n-       elf_section_data (sec)->this_hdr.contents = contents;\n+\t/* Cache the section contents for elf_link_input_bfd.  */\n+\telf_section_data (sec)->this_hdr.contents = contents;\n \n     }\n \n@@ -2488,8 +2473,8 @@ _bfd_cr16_elf_size_dynamic_sections (bfd * output_bfd,\n \t  continue;\n \t}\n \n-\tif ((s->flags & SEC_HAS_CONTENTS) == 0)\n-\t  continue;\n+      if ((s->flags & SEC_HAS_CONTENTS) == 0)\n+\tcontinue;\n \n       /* Allocate memory for the section contents.  We use bfd_zalloc\n \t here in case unused entries are not reclaimed before the\n@@ -2581,7 +2566,7 @@ _bfd_cr16_elf_finish_dynamic_symbol (bfd * output_bfd,\n       bfd_elf32_swap_reloca_out (output_bfd, &rel,\n \t\t\t\t (bfd_byte *) ((Elf32_External_Rela *) s->contents\n \t\t\t\t\t       + s->reloc_count));\n-     ++ s->reloc_count;\n+      ++ s->reloc_count;\n     }\n \n   /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */\n@@ -2716,14 +2701,14 @@ bfd_cr16_elf32_create_embedded_relocs (bfd *abfd,\n       asection *targetsec;\n \n       /* We are going to write a four byte longword into the runtime\n-       reloc section.  The longword will be the address in the data\n-       section which must be relocated.  It is followed by the name\n-       of the target section NUL-padded or truncated to 8\n-       characters.  */\n+\t reloc section.  The longword will be the address in the data\n+\t section which must be relocated.  It is followed by the name\n+\t of the target section NUL-padded or truncated to 8\n+\t characters.  */\n \n       /* We can only relocate absolute longword relocs at run time.  */\n       if (!((ELF32_R_TYPE (irel->r_info) == (int) R_CR16_NUM32a)\n-\t  || (ELF32_R_TYPE (irel->r_info) == (int) R_CR16_NUM32)))\n+\t    || (ELF32_R_TYPE (irel->r_info) == (int) R_CR16_NUM32)))\n \t{\n \t  *errmsg = _(\"unsupported relocation type\");\n \t  bfd_set_error (bfd_error_bad_value);\n@@ -2771,7 +2756,7 @@ bfd_cr16_elf32_create_embedded_relocs (bfd *abfd,\n       memset (p + 4, 0, 4);\n       if ((ELF32_R_TYPE (irel->r_info) == (int) R_CR16_NUM32a)\n \t  && (targetsec != NULL) )\n-\t strncpy ((char *) p + 4, targetsec->output_section->name, 4);\n+\tstrncpy ((char *) p + 4, targetsec->output_section->name, 4);\n     }\n \n   if (symtab_hdr->contents != (unsigned char *) isymbuf)"
    }
  ]
}