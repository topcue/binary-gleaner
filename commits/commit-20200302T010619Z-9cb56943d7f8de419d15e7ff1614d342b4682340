{
  "sha": "9cb56943d7f8de419d15e7ff1614d342b4682340",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWNiNTY5NDNkN2Y4ZGU0MTlkMTVlN2ZmMTYxNGQzNDJiNDY4MjM0MA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-01T23:44:57Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-02T01:06:19Z"
    },
    "message": "alpha-vms: error paths not freeing memory and malloc result checks\n\nWhen realloc fails it doesn't free the old memory.  In BFD we usually\nwill exit with an error on a realloc fail, so want to tidy up memory\non error paths.  That's done by bfd_realloc_or_free.\n\n\t* vms-alpha.c (vms_get_remaining_object_record): Use\n\tbfd_realloc_or_free rather than bfd_realloc.\n\t(add_symbol_entry, vector_grow1, alpha_vms_slurp_relocs): Likewise.\n\t(dst_define_location, parse_module): Likewise, and check realloc\n\treturn status before using memory.  Return status from function\n\tadjusting all callers.",
    "tree": {
      "sha": "97e8c2be1c5b51c25712dce6efcaca7903b4e149",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/97e8c2be1c5b51c25712dce6efcaca7903b4e149"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9cb56943d7f8de419d15e7ff1614d342b4682340",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9cb56943d7f8de419d15e7ff1614d342b4682340",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9cb56943d7f8de419d15e7ff1614d342b4682340",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9cb56943d7f8de419d15e7ff1614d342b4682340/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "363a2bc6dd2b034a669c26055e021a17c96067e2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/363a2bc6dd2b034a669c26055e021a17c96067e2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/363a2bc6dd2b034a669c26055e021a17c96067e2"
    }
  ],
  "stats": {
    "total": 50,
    "additions": 36,
    "deletions": 14
  },
  "files": [
    {
      "sha": "f57c759c32a3c4b8c26bfb692b96fa4ee3e897cc",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9cb56943d7f8de419d15e7ff1614d342b4682340/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9cb56943d7f8de419d15e7ff1614d342b4682340/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=9cb56943d7f8de419d15e7ff1614d342b4682340",
      "patch": "@@ -1,3 +1,12 @@\n+2020-03-02  Alan Modra  <amodra@gmail.com>\n+\n+\t* vms-alpha.c (vms_get_remaining_object_record): Use\n+\tbfd_realloc_or_free rather than bfd_realloc.\n+\t(add_symbol_entry, vector_grow1, alpha_vms_slurp_relocs): Likewise.\n+\t(dst_define_location, parse_module): Likewise, and check realloc\n+\treturn status before using memory.  Return status from function\n+\tadjusting all callers.\n+\n 2020-02-28  Alan Modra  <amodra@gmail.com>\n \n \t* vms-lib.c (_bfd_vms_lib_archive_p): Free memory on error paths."
    },
    {
      "sha": "272d80ab4c84af8919adf65344015c6dc326b624",
      "filename": "bfd/vms-alpha.c",
      "status": "modified",
      "additions": 27,
      "deletions": 14,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9cb56943d7f8de419d15e7ff1614d342b4682340/bfd/vms-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9cb56943d7f8de419d15e7ff1614d342b4682340/bfd/vms-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-alpha.c?ref=9cb56943d7f8de419d15e7ff1614d342b4682340",
      "patch": "@@ -863,7 +863,7 @@ vms_get_remaining_object_record (bfd *abfd, unsigned int read_so_far)\n   if (to_read > PRIV (recrd.buf_size))\n     {\n       PRIV (recrd.buf)\n-\t= (unsigned char *) bfd_realloc (PRIV (recrd.buf), to_read);\n+\t= (unsigned char *) bfd_realloc_or_free (PRIV (recrd.buf), to_read);\n       if (PRIV (recrd.buf) == NULL)\n \treturn 0;\n       PRIV (recrd.buf_size) = to_read;\n@@ -1126,7 +1126,7 @@ add_symbol_entry (bfd *abfd, struct vms_symbol_entry *sym)\n       else\n \t{\n \t  PRIV (max_sym_count) *= 2;\n-\t  PRIV (syms) = bfd_realloc\n+\t  PRIV (syms) = bfd_realloc_or_free\n \t    (PRIV (syms),\n \t     (PRIV (max_sym_count) * sizeof (struct vms_symbol_entry *)));\n \t}\n@@ -1548,20 +1548,24 @@ image_inc_ptr (bfd *abfd, bfd_vma offset)\n \n /* Save current DST location counter under specified index.  */\n \n-static void\n+static bfd_boolean\n dst_define_location (bfd *abfd, unsigned int loc)\n {\n   vms_debug2 ((4, \"dst_define_location (%d)\\n\", (int)loc));\n \n   /* Grow the ptr offset table if necessary.  */\n   if (loc + 1 > PRIV (dst_ptr_offsets_count))\n     {\n-      PRIV (dst_ptr_offsets) = bfd_realloc (PRIV (dst_ptr_offsets),\n-\t\t\t\t\t   (loc + 1) * sizeof (unsigned int));\n+      PRIV (dst_ptr_offsets)\n+\t= bfd_realloc_or_free (PRIV (dst_ptr_offsets),\n+\t\t\t       (loc + 1) * sizeof (unsigned int));\n+      if (PRIV (dst_ptr_offsets) == NULL)\n+\treturn FALSE;\n       PRIV (dst_ptr_offsets_count) = loc + 1;\n     }\n \n   PRIV (dst_ptr_offsets)[loc] = PRIV (image_offset);\n+  return TRUE;\n }\n \n /* Restore saved DST location counter from specified index.  */\n@@ -2311,7 +2315,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t    return FALSE;\n \t  if (rel1 != RELC_NONE)\n \t    goto bad_context;\n-\t  dst_define_location (abfd, op1);\n+\t  if (!dst_define_location (abfd, op1))\n+\t    return FALSE;\n \t  break;\n \n \t  /* Set location: pop index, restore location counter from index\n@@ -2950,7 +2955,7 @@ vector_grow1 (struct vector_type *vec, size_t elsz)\n \t      bfd_set_error (bfd_error_file_too_big);\n \t      return NULL;\n \t    }\n-\t  vec->els = bfd_realloc (vec->els, amt);\n+\t  vec->els = bfd_realloc_or_free (vec->els, amt);\n \t}\n     }\n   if (vec->els == NULL)\n@@ -4255,7 +4260,7 @@ new_module (bfd *abfd)\n \n /* Parse debug info for a module and internalize it.  */\n \n-static void\n+static bfd_boolean\n parse_module (bfd *abfd, struct module *module, unsigned char *ptr,\n \t      int length)\n {\n@@ -4367,9 +4372,11 @@ parse_module (bfd *abfd, struct module *module, unsigned char *ptr,\n \t\t      {\n \t\t\tmodule->file_table_count *= 2;\n \t\t\tmodule->file_table\n-\t\t\t  = bfd_realloc (module->file_table,\n-\t\t\t\t\t module->file_table_count\n-\t\t\t\t\t   * sizeof (struct fileinfo));\n+\t\t\t  = bfd_realloc_or_free (module->file_table,\n+\t\t\t\t\t\t module->file_table_count\n+\t\t\t\t\t\t * sizeof (struct fileinfo));\n+\t\t\tif (module->file_table == NULL)\n+\t\t\t  return FALSE;\n \t\t      }\n \n \t\t    module->file_table [fileid].name = filename;\n@@ -4691,6 +4698,7 @@ parse_module (bfd *abfd, struct module *module, unsigned char *ptr,\n      because parsing can be either performed at module creation\n      or deferred until debug info is consumed.  */\n   SET_MODULE_PARSED (module);\n+  return TRUE;\n }\n \n /* Build the list of modules for the specified BFD.  */\n@@ -4768,7 +4776,8 @@ build_module_list (bfd *abfd)\n \treturn NULL;\n \n       module = new_module (abfd);\n-      parse_module (abfd, module, PRIV (dst_section)->contents, -1);\n+      if (!parse_module (abfd, module, PRIV (dst_section)->contents, -1))\n+\treturn NULL;\n       list = module;\n     }\n \n@@ -4802,8 +4811,10 @@ module_find_nearest_line (bfd *abfd, struct module *module, bfd_vma addr,\n \t  return FALSE;\n \t}\n \n-      parse_module (abfd, module, buffer, size);\n+      ret = parse_module (abfd, module, buffer, size);\n       free (buffer);\n+      if (!ret)\n+\treturn ret;\n     }\n \n   /* Find out the function (if any) that contains the address.  */\n@@ -5277,8 +5288,10 @@ alpha_vms_slurp_relocs (bfd *abfd)\n \t\telse\n \t\t  {\n \t\t    vms_sec->reloc_max *= 2;\n-\t\t    sec->relocation = bfd_realloc\n+\t\t    sec->relocation = bfd_realloc_or_free\n \t\t      (sec->relocation, vms_sec->reloc_max * sizeof (arelent));\n+\t\t    if (sec->relocation == NULL)\n+\t\t      return FALSE;\n \t\t  }\n \t      }\n \t    reloc = &sec->relocation[sec->reloc_count];"
    }
  ]
}