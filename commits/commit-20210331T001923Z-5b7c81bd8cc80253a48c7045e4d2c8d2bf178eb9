{
  "sha": "5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWI3YzgxYmQ4Y2M4MDI1M2E0OGM3MDQ1ZTRkMmM4ZDJiZjE3OGViOQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:12:05Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:19:23Z"
    },
    "message": "Use bool in gas\n\n\t* as.h (POISON_BFD_BOOLEAN): Define.\n\t* as.c, * as.h, * atof-generic.c, * config/atof-ieee.c,\n\t* config/bfin-aux.h, * config/obj-coff.c, * config/obj-ecoff.c,\n\t* config/obj-elf.c, * config/obj-elf.h, * config/obj-som.c,\n\t* config/tc-aarch64.c, * config/tc-alpha.c, * config/tc-arc.c,\n\t* config/tc-arc.h, * config/tc-arm.c, * config/tc-arm.h,\n\t* config/tc-avr.c, * config/tc-avr.h, * config/tc-bfin.c,\n\t* config/tc-bfin.h, * config/tc-bpf.c, * config/tc-cris.c,\n\t* config/tc-csky.c, * config/tc-csky.h, * config/tc-d10v.c,\n\t* config/tc-d10v.h, * config/tc-d30v.c, * config/tc-d30v.h,\n\t* config/tc-dlx.c, * config/tc-dlx.h, * config/tc-epiphany.c,\n\t* config/tc-epiphany.h, * config/tc-fr30.c, * config/tc-fr30.h,\n\t* config/tc-frv.c, * config/tc-frv.h, * config/tc-ft32.c,\n\t* config/tc-ft32.h, * config/tc-h8300.c, * config/tc-hppa.c,\n\t* config/tc-i386-intel.c, * config/tc-i386.c, * config/tc-ia64.c,\n\t* config/tc-ip2k.c, * config/tc-iq2000.c, * config/tc-iq2000.h,\n\t* config/tc-lm32.c, * config/tc-lm32.h, * config/tc-m32c.c,\n\t* config/tc-m32c.h, * config/tc-m32r.c, * config/tc-m32r.h,\n\t* config/tc-m68hc11.c, * config/tc-m68k.c, * config/tc-mcore.c,\n\t* config/tc-mcore.h, * config/tc-mep.c, * config/tc-mep.h,\n\t* config/tc-metag.c, * config/tc-metag.h,\n\t* config/tc-microblaze.c, * config/tc-mips.c, * config/tc-mips.h,\n\t* config/tc-mmix.c, * config/tc-mn10200.c, * config/tc-mn10300.c,\n\t* config/tc-mn10300.h, * config/tc-moxie.c, * config/tc-msp430.c,\n\t* config/tc-msp430.h, * config/tc-mt.c, * config/tc-mt.h,\n\t* config/tc-nds32.c, * config/tc-nds32.h, * config/tc-nios2.c,\n\t* config/tc-ns32k.c, * config/tc-or1k.c, * config/tc-or1k.h,\n\t* config/tc-pdp11.c, * config/tc-ppc.c, * config/tc-pru.c,\n\t* config/tc-pru.h, * config/tc-riscv.c, * config/tc-riscv.h,\n\t* config/tc-rx.c, * config/tc-rx.h, * config/tc-s12z.c,\n\t* config/tc-s12z.h, * config/tc-s390.c, * config/tc-score.c,\n\t* config/tc-score.h, * config/tc-score7.c, * config/tc-sh.c,\n\t* config/tc-sh.h, * config/tc-spu.c, * config/tc-tic54x.c,\n\t* config/tc-tic6x.c, * config/tc-tic6x.h, * config/tc-tilegx.c,\n\t* config/tc-tilepro.c, * config/tc-v850.c, * config/tc-v850.h,\n\t* config/tc-visium.c, * config/tc-visium.h, * config/tc-wasm32.c,\n\t* config/tc-wasm32.h, * config/tc-xc16x.c, * config/tc-xgate.c,\n\t* config/tc-xstormy16.c, * config/tc-xstormy16.h,\n\t* config/tc-xtensa.c, * config/tc-xtensa.h, * config/tc-z80.c,\n\t* config/tc-z8k.c, * config/xtensa-istack.h,\n\t* config/xtensa-relax.c, * config/xtensa-relax.h, * dw2gencfi.c,\n\t* dwarf2dbg.c, * dwarf2dbg.h, * expr.c, * expr.h, * frags.c,\n\t* frags.h, * listing.c, * macro.c, * output-file.c, * read.c,\n\t* read.h, * stabs.c, * symbols.c, * write.c: Replace bfd_boolean\n\twith bool, FALSE with false, and TRUE with true.",
    "tree": {
      "sha": "d97ac6b8c17baeb684390888df2dd716cc125bb6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d97ac6b8c17baeb684390888df2dd716cc125bb6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc"
    }
  ],
  "stats": {
    "total": 8512,
    "additions": 4275,
    "deletions": 4237
  },
  "files": [
    {
      "sha": "8c4eab197ac4fe2540265cf89238f24efa7bfcb5",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 48,
      "deletions": 0,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -1,3 +1,51 @@\n+2021-03-31  Alan Modra  <amodra@gmail.com>\n+\n+\t* as.h (POISON_BFD_BOOLEAN): Define.\n+\t* as.c, * as.h, * atof-generic.c, * config/atof-ieee.c,\n+\t* config/bfin-aux.h, * config/obj-coff.c, * config/obj-ecoff.c,\n+\t* config/obj-elf.c, * config/obj-elf.h, * config/obj-som.c,\n+\t* config/tc-aarch64.c, * config/tc-alpha.c, * config/tc-arc.c,\n+\t* config/tc-arc.h, * config/tc-arm.c, * config/tc-arm.h,\n+\t* config/tc-avr.c, * config/tc-avr.h, * config/tc-bfin.c,\n+\t* config/tc-bfin.h, * config/tc-bpf.c, * config/tc-cris.c,\n+\t* config/tc-csky.c, * config/tc-csky.h, * config/tc-d10v.c,\n+\t* config/tc-d10v.h, * config/tc-d30v.c, * config/tc-d30v.h,\n+\t* config/tc-dlx.c, * config/tc-dlx.h, * config/tc-epiphany.c,\n+\t* config/tc-epiphany.h, * config/tc-fr30.c, * config/tc-fr30.h,\n+\t* config/tc-frv.c, * config/tc-frv.h, * config/tc-ft32.c,\n+\t* config/tc-ft32.h, * config/tc-h8300.c, * config/tc-hppa.c,\n+\t* config/tc-i386-intel.c, * config/tc-i386.c, * config/tc-ia64.c,\n+\t* config/tc-ip2k.c, * config/tc-iq2000.c, * config/tc-iq2000.h,\n+\t* config/tc-lm32.c, * config/tc-lm32.h, * config/tc-m32c.c,\n+\t* config/tc-m32c.h, * config/tc-m32r.c, * config/tc-m32r.h,\n+\t* config/tc-m68hc11.c, * config/tc-m68k.c, * config/tc-mcore.c,\n+\t* config/tc-mcore.h, * config/tc-mep.c, * config/tc-mep.h,\n+\t* config/tc-metag.c, * config/tc-metag.h,\n+\t* config/tc-microblaze.c, * config/tc-mips.c, * config/tc-mips.h,\n+\t* config/tc-mmix.c, * config/tc-mn10200.c, * config/tc-mn10300.c,\n+\t* config/tc-mn10300.h, * config/tc-moxie.c, * config/tc-msp430.c,\n+\t* config/tc-msp430.h, * config/tc-mt.c, * config/tc-mt.h,\n+\t* config/tc-nds32.c, * config/tc-nds32.h, * config/tc-nios2.c,\n+\t* config/tc-ns32k.c, * config/tc-or1k.c, * config/tc-or1k.h,\n+\t* config/tc-pdp11.c, * config/tc-ppc.c, * config/tc-pru.c,\n+\t* config/tc-pru.h, * config/tc-riscv.c, * config/tc-riscv.h,\n+\t* config/tc-rx.c, * config/tc-rx.h, * config/tc-s12z.c,\n+\t* config/tc-s12z.h, * config/tc-s390.c, * config/tc-score.c,\n+\t* config/tc-score.h, * config/tc-score7.c, * config/tc-sh.c,\n+\t* config/tc-sh.h, * config/tc-spu.c, * config/tc-tic54x.c,\n+\t* config/tc-tic6x.c, * config/tc-tic6x.h, * config/tc-tilegx.c,\n+\t* config/tc-tilepro.c, * config/tc-v850.c, * config/tc-v850.h,\n+\t* config/tc-visium.c, * config/tc-visium.h, * config/tc-wasm32.c,\n+\t* config/tc-wasm32.h, * config/tc-xc16x.c, * config/tc-xgate.c,\n+\t* config/tc-xstormy16.c, * config/tc-xstormy16.h,\n+\t* config/tc-xtensa.c, * config/tc-xtensa.h, * config/tc-z80.c,\n+\t* config/tc-z8k.c, * config/xtensa-istack.h,\n+\t* config/xtensa-relax.c, * config/xtensa-relax.h, * dw2gencfi.c,\n+\t* dwarf2dbg.c, * dwarf2dbg.h, * expr.c, * expr.h, * frags.c,\n+\t* frags.h, * listing.c, * macro.c, * output-file.c, * read.c,\n+\t* read.h, * stabs.c, * symbols.c, * write.c: Replace bfd_boolean\n+\twith bool, FALSE with false, and TRUE with true.\n+\n 2021-03-31  Alan Modra  <amodra@gmail.com>\n \n \t* config/tc-aarch64.c: Include stdint.h in place of bfd_stdint.h."
    },
    {
      "sha": "d12cb0fbacfe2d0683f93b06fd5f20aeb5bddc3b",
      "filename": "gas/as.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/as.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/as.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/as.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -108,7 +108,7 @@ unsigned int dwarf_level = 3;\n \n #if defined OBJ_ELF || defined OBJ_MAYBE_ELF\n int flag_use_elf_stt_common = DEFAULT_GENERATE_ELF_STT_COMMON;\n-bfd_boolean flag_generate_build_notes = DEFAULT_GENERATE_BUILD_NOTES;\n+bool flag_generate_build_notes = DEFAULT_GENERATE_BUILD_NOTES;\n #endif\n \n /* Keep the output file.  */\n@@ -862,7 +862,7 @@ This program has absolutely no warranty.\\n\"));\n \t  break;\n \n \tcase OPTION_GDWARF_SECTIONS:\n-\t  flag_dwarf_sections = TRUE;\n+\t  flag_dwarf_sections = true;\n \t  break;\n \n         case OPTION_GDWARF_CIE_VERSION:\n@@ -961,9 +961,9 @@ This program has absolutely no warranty.\\n\"));\n \n \tcase OPTION_SIZE_CHECK:\n \t  if (strcasecmp (optarg, \"error\") == 0)\n-\t    flag_allow_nonconst_size = FALSE;\n+\t    flag_allow_nonconst_size = false;\n \t  else if (strcasecmp (optarg, \"warning\") == 0)\n-\t    flag_allow_nonconst_size = TRUE;\n+\t    flag_allow_nonconst_size = true;\n \t  else\n \t    as_fatal (_(\"Invalid --size-check= option: `%s'\"), optarg);\n \t  break;\n@@ -984,9 +984,9 @@ This program has absolutely no warranty.\\n\"));\n \n \tcase OPTION_ELF_BUILD_NOTES:\n \t  if (strcasecmp (optarg, \"no\") == 0)\n-\t    flag_generate_build_notes = FALSE;\n+\t    flag_generate_build_notes = false;\n \t  else if (strcasecmp (optarg, \"yes\") == 0)\n-\t    flag_generate_build_notes = TRUE;\n+\t    flag_generate_build_notes = true;\n \t  else\n \t    as_fatal (_(\"Invalid --generate-missing-build-notes option: `%s'\"),\n \t\t      optarg);"
    },
    {
      "sha": "295d20ef467f84ce64c5d5a92717729352710b8e",
      "filename": "gas/as.h",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/as.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/as.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/as.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -411,7 +411,7 @@ enum debug_info_type\n \n extern enum debug_info_type debug_type;\n extern int use_gnu_debug_info_extensions;\n-COMMON bfd_boolean flag_dwarf_sections;\n+COMMON bool flag_dwarf_sections;\n extern int flag_dwarf_cie_version;\n extern unsigned int dwarf_level;\n \f\n@@ -487,7 +487,7 @@ char * app_push (void);\n \n char * atof_ieee (char *, int, LITTLENUM_TYPE *);\n char * atof_ieee_detail (char *, int, int, LITTLENUM_TYPE *, FLONUM_TYPE *);\n-const char * ieee_md_atof (int, char *, int *, bfd_boolean);\n+const char * ieee_md_atof (int, char *, int *, bool);\n const char * vax_md_atof (int, char *, int *);\n char * input_scrub_include_file (const char *, char *);\n void   input_scrub_insert_line (const char *);\n@@ -609,7 +609,7 @@ extern int flag_use_elf_stt_common;\n \n /* TRUE iff GNU Build attribute notes should\n    be generated if none are in the input files.  */\n-extern bfd_boolean flag_generate_build_notes;\n+extern bool flag_generate_build_notes;\n \n /* If section name substitution sequences should be honored */\n COMMON int flag_sectname_subst;\n@@ -662,4 +662,6 @@ COMMON int flag_sectname_subst;\n #define SEC_OCTETS 0\n #endif\n \n+#define POISON_BFD_BOOLEAN 1\n+\n #endif /* GAS */"
    },
    {
      "sha": "91d8aba4814efb06abeadae96e381978b90e1cd2",
      "filename": "gas/atof-generic.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/atof-generic.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/atof-generic.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/atof-generic.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -233,7 +233,7 @@ atof_generic (/* return pointer to just AFTER number we read.  */\n \n \t      if ( /* seen_significant_digit || */ c > '0')\n \t\t{\n-\t\t  seen_significant_digit = TRUE;\n+\t\t  seen_significant_digit = true;\n \t\t}\n \t    }\n \t  else"
    },
    {
      "sha": "fa988aa36ee1fa577b342fa707c45a7ff9d47159",
      "filename": "gas/config/atof-ieee.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/atof-ieee.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/atof-ieee.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/atof-ieee.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -755,7 +755,7 @@ const char *\n ieee_md_atof (int type,\n \t      char *litP,\n \t      int *sizeP,\n-\t      bfd_boolean big_wordian)\n+\t      bool big_wordian)\n {\n   LITTLENUM_TYPE words[MAX_LITTLENUMS];\n   LITTLENUM_TYPE *wordP;"
    },
    {
      "sha": "66532176a4b7476c447fb1da06349c7736399cdf",
      "filename": "gas/config/bfin-aux.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/bfin-aux.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/bfin-aux.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/bfin-aux.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -64,5 +64,5 @@ INSTR_T bfin_gen_linkage (int, int);\n INSTR_T bfin_gen_pseudodbg (int, int, int);\n INSTR_T bfin_gen_pseudodbg_assert (int, REG_T, int);\n INSTR_T bfin_gen_pseudochr (int);\n-bfd_boolean bfin_resource_conflict (INSTR_T, INSTR_T, INSTR_T);\n+bool bfin_resource_conflict (INSTR_T, INSTR_T, INSTR_T);\n INSTR_T bfin_gen_multi_instr (INSTR_T, INSTR_T, INSTR_T);"
    },
    {
      "sha": "3c008a3ef2d11b2d611b61822b505ee9d8371739",
      "filename": "gas/config/obj-coff.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-coff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-coff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-coff.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -374,7 +374,7 @@ coff_obj_symbol_new_hook (symbolS *symbolP)\n \n   memset (s, 0, sz);\n   coffsymbol (symbol_get_bfdsym (symbolP))->native = (combined_entry_type *) s;\n-  coffsymbol (symbol_get_bfdsym (symbolP))->native->is_sym = TRUE;\n+  coffsymbol (symbol_get_bfdsym (symbolP))->native->is_sym = true;\n \n   S_SET_DATA_TYPE (symbolP, T_NULL);\n   S_SET_STORAGE_CLASS (symbolP, 0);\n@@ -1527,7 +1527,7 @@ obj_coff_section (int ignore ATTRIBUTE_UNUSED)\n   unsigned int exp;\n   flagword flags, oldflags;\n   asection *sec;\n-  bfd_boolean is_bss = FALSE;\n+  bool is_bss = false;\n \n   if (flag_mri)\n     {\n@@ -1577,7 +1577,7 @@ obj_coff_section (int ignore ATTRIBUTE_UNUSED)\n \t\t  /* Uninitialised data section.  */\n \t\t  flags |= SEC_ALLOC;\n \t\t  flags &=~ SEC_LOAD;\n-\t\t  is_bss = TRUE;\n+\t\t  is_bss = true;\n \t\t  break;\n \n \t\tcase 'n':\n@@ -1800,7 +1800,7 @@ obj_coff_init_stab_section (segT seg)\n   memset (p, 0, 12);\n   file = as_where ((unsigned int *) NULL);\n   stabstr_name = concat (seg->name, \"str\", (char *) NULL);\n-  stroff = get_stab_string_offset (file, stabstr_name, TRUE);\n+  stroff = get_stab_string_offset (file, stabstr_name, true);\n   know (stroff == 1);\n   md_number_to_chars (p, stroff, 4);\n }"
    },
    {
      "sha": "adc707782fd2241e29b296a8deb84a7e9a2d7a04",
      "filename": "gas/config/obj-ecoff.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-ecoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-ecoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-ecoff.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -189,7 +189,7 @@ obj_ecoff_set_ext (symbolS *sym, EXTR *ext)\n   know (bfd_asymbol_flavour (symbol_get_bfdsym (sym))\n \t== bfd_target_ecoff_flavour);\n   esym = ecoffsymbol (symbol_get_bfdsym (sym));\n-  esym->local = FALSE;\n+  esym->local = false;\n   esym->native = xmalloc (debug_swap->external_ext_size);\n   (*debug_swap->swap_ext_out) (stdoutput, ext, esym->native);\n }"
    },
    {
      "sha": "8e8c6d50c2a8c820a8836ed20ab1a43b4a498ab7",
      "filename": "gas/config/obj-elf.c",
      "status": "modified",
      "additions": 29,
      "deletions": 29,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-elf.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -520,7 +520,7 @@ static struct section_stack *section_stack;\n \n /* Return TRUE iff SEC matches the section info INF.  */\n \n-static bfd_boolean\n+static bool\n get_section_by_match (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)\n {\n   struct elf_section_match *match = (struct elf_section_match *) inf;\n@@ -621,7 +621,7 @@ obj_elf_change_section (const char *name,\n \n   if (ssect != NULL)\n     {\n-      bfd_boolean override = FALSE;\n+      bool override = false;\n \n       if (type == SHT_NULL)\n \ttype = ssect->type;\n@@ -694,15 +694,15 @@ obj_elf_change_section (const char *name,\n \t\t   && (strcmp (name, \".interp\") == 0\n \t\t       || strcmp (name, \".strtab\") == 0\n \t\t       || strcmp (name, \".symtab\") == 0))\n-\t    override = TRUE;\n+\t    override = true;\n \t  /* .note.GNU-stack can have SHF_EXECINSTR.  */\n \t  else if (generic_attr == SHF_EXECINSTR\n \t\t   && strcmp (name, \".note.GNU-stack\") == 0)\n-\t    override = TRUE;\n+\t    override = true;\n #ifdef TC_ALPHA\n \t  /* A section on Alpha may have SHF_ALPHA_GPREL.  */\n \t  else if ((generic_attr & ~ssect->attr) == SHF_ALPHA_GPREL)\n-\t    override = TRUE;\n+\t    override = true;\n #endif\n #ifdef TC_RX\n \t  else if (generic_attr == (SHF_EXECINSTR | SHF_WRITE | SHF_ALLOC)\n@@ -717,7 +717,7 @@ obj_elf_change_section (const char *name,\n \t      if (match_p->group_name == NULL)\n \t\tas_warn (_(\"setting incorrect section attributes for %s\"),\n \t\t\t name);\n-\t      override = TRUE;\n+\t      override = true;\n \t    }\n \t}\n \n@@ -832,10 +832,10 @@ obj_elf_change_section (const char *name,\n \n static bfd_vma\n obj_elf_parse_section_letters (char *str, size_t len,\n-\t\t\t       bfd_boolean *is_clone, bfd_vma *gnu_attr)\n+\t\t\t       bool *is_clone, bfd_vma *gnu_attr)\n {\n   bfd_vma attr = 0;\n-  *is_clone = FALSE;\n+  *is_clone = false;\n \n   while (len > 0)\n     {\n@@ -875,7 +875,7 @@ obj_elf_parse_section_letters (char *str, size_t len,\n \t  *gnu_attr |= SHF_GNU_RETAIN;\n \t  break;\n \tcase '?':\n-\t  *is_clone = TRUE;\n+\t  *is_clone = true;\n \t  break;\n \t/* Compatibility.  */\n \tcase 'm':\n@@ -947,7 +947,7 @@ obj_elf_parse_section_letters (char *str, size_t len,\n }\n \n static int\n-obj_elf_section_type (char *str, size_t len, bfd_boolean warn)\n+obj_elf_section_type (char *str, size_t len, bool warn)\n {\n   if (len == 8 && strncmp (str, \"progbits\", 8) == 0)\n     return SHT_PROGBITS;\n@@ -1010,7 +1010,7 @@ obj_elf_section_word (char *str, size_t len, int *type)\n   }\n #endif\n \n-  ret = obj_elf_section_type (str, len, FALSE);\n+  ret = obj_elf_section_type (str, len, false);\n   if (ret != 0)\n     *type = ret;\n   else\n@@ -1184,7 +1184,7 @@ obj_elf_section (int push)\n \n       if (*input_line_pointer == '\"')\n \t{\n-\t  bfd_boolean is_clone;\n+\t  bool is_clone;\n \n \t  beg = demand_copy_C_string (&dummy);\n \t  if (beg == NULL)\n@@ -1212,7 +1212,7 @@ obj_elf_section (int push)\n \t\t      ignore_rest_of_line ();\n \t\t      return;\n \t\t    }\n-\t\t  type = obj_elf_section_type (beg, strlen (beg), TRUE);\n+\t\t  type = obj_elf_section_type (beg, strlen (beg), true);\n \t\t}\n \t      else if (c == '@' || c == '%')\n \t\t{\n@@ -1226,7 +1226,7 @@ obj_elf_section (int push)\n \t\t      (void) restore_line_pointer (c);\n \t\t      type = obj_elf_section_type (beg,\n \t\t\t\t\t\t   input_line_pointer - beg,\n-\t\t\t\t\t\t   TRUE);\n+\t\t\t\t\t\t   true);\n \t\t    }\n \t\t}\n \t      else\n@@ -1278,7 +1278,7 @@ obj_elf_section (int push)\n \t  if ((attr & SHF_GROUP) != 0 && is_clone)\n \t    {\n \t      as_warn (_(\"? section flag ignored with G present\"));\n-\t      is_clone = FALSE;\n+\t      is_clone = false;\n \t    }\n \n \t  if ((attr & SHF_GROUP) != 0 && *input_line_pointer == ',')\n@@ -1356,7 +1356,7 @@ obj_elf_section (int push)\n \t\t      if (ISDIGIT (* input_line_pointer))\n \t\t\t{\n \t\t\t  bfd_vma id;\n-\t\t\t  bfd_boolean overflow;\n+\t\t\t  bool overflow;\n \t\t\t  char *t = input_line_pointer;\n \t\t\t  if (sizeof (bfd_vma) <= sizeof (unsigned long))\n \t\t\t    {\n@@ -1430,7 +1430,7 @@ obj_elf_section (int push)\n   if ((gnu_attr & (SHF_GNU_MBIND | SHF_GNU_RETAIN)) != 0)\n     {\n       const struct elf_backend_data *bed;\n-      bfd_boolean mbind_p = (gnu_attr & SHF_GNU_MBIND) != 0;\n+      bool mbind_p = (gnu_attr & SHF_GNU_MBIND) != 0;\n \n       if (mbind_p && (attr & SHF_ALLOC) == 0)\n \tas_bad (_(\"SHF_ALLOC isn't set for GNU_MBIND section: %s\"), name);\n@@ -1654,7 +1654,7 @@ obj_elf_find_and_add_versioned_name (const char *version_name,\n \t      return NULL;\n \t    }\n \t}\n-      sy_obj->rename = TRUE;\n+      sy_obj->rename = true;\n       break;\n     default:\n       as_bad (_(\"invalid version name '%s' for symbol `%s'\"),\n@@ -1735,7 +1735,7 @@ obj_elf_symver (int ignore ATTRIBUTE_UNUSED)\n   if (obj_elf_find_and_add_versioned_name (name, sym_name,\n \t\t\t\t\t   p, sy_obj) == NULL)\n     {\n-      sy_obj->bad_version = TRUE;\n+      sy_obj->bad_version = true;\n       ignore_rest_of_line ();\n       return;\n     }\n@@ -1946,7 +1946,7 @@ record_attribute (int vendor, unsigned int tag)\n /* Return true if we have seen an explicit specification of attribute TAG\n    for vendor VENDOR.  */\n \n-bfd_boolean\n+bool\n obj_elf_seen_attribute (int vendor, unsigned int tag)\n {\n   unsigned int base;\n@@ -1958,7 +1958,7 @@ obj_elf_seen_attribute (int vendor, unsigned int tag)\n   for (rai = recorded_attributes; rai; rai = rai->next)\n     if (rai->vendor == vendor && rai->base == base)\n       return (rai->mask & mask) != 0;\n-  return FALSE;\n+  return false;\n }\n \n /* Parse an attribute directive for VENDOR.\n@@ -2489,7 +2489,7 @@ obj_elf_init_stab_section (segT seg)\n   memset (p, 0, 12);\n   file = remap_debug_filename (as_where (NULL));\n   stabstr_name = concat (segment_name (seg), \"str\", (char *) NULL);\n-  stroff = get_stab_string_offset (file, stabstr_name, TRUE);\n+  stroff = get_stab_string_offset (file, stabstr_name, true);\n   know (stroff == 1 || (stroff == 0 && file[0] == '\\0'));\n   md_number_to_chars (p, stroff, 4);\n   seg_info (seg)->stabu.p = p;\n@@ -2550,13 +2550,13 @@ elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)\n    supposed to *EXT to the external symbol information, and return\n    whether the symbol should be used at all.  */\n \n-static bfd_boolean\n+static bool\n elf_get_extr (asymbol *sym, EXTR *ext)\n {\n   if (sym->udata.p == NULL)\n-    return FALSE;\n+    return false;\n   *ext = *(EXTR *) sym->udata.p;\n-  return TRUE;\n+  return true;\n }\n \n /* This function is called by bfd_ecoff_debug_externals.  It has\n@@ -2613,7 +2613,7 @@ elf_frob_symbol (symbolS *symp, int *puntp)\n \n       /* We will have already reported an version error.  */\n       if (sy_obj->bad_version)\n-\t*puntp = TRUE;\n+\t*puntp = true;\n       /* elf_frob_file_before_adjust only allows one version symbol for\n \t renamed symbol.  */\n       else if (sy_obj->rename)\n@@ -2622,7 +2622,7 @@ elf_frob_symbol (symbolS *symp, int *puntp)\n \t{\n \t  as_bad (_(\"`%s' can't be versioned to common symbol '%s'\"),\n \t\t  versioned_name->name, S_GET_NAME (symp));\n-\t  *puntp = TRUE;\n+\t  *puntp = true;\n \t}\n       else\n \t{\n@@ -2912,7 +2912,7 @@ elf_frob_file_before_adjust (void)\n \t\t      return;\n \t\t    }\n \n-\t\t  sy_obj->rename = TRUE;\n+\t\t  sy_obj->rename = true;\n \t\t}\n \t    }\n \n@@ -2994,7 +2994,7 @@ elf_frob_file_after_relocs (void)\n       /* Set up the external symbols.  */\n       debug.ssext = debug.ssext_end = NULL;\n       debug.external_ext = debug.external_ext_end = NULL;\n-      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, TRUE,\n+      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, true,\n \t\t\t\t       elf_get_extr, elf_set_index))\n \tas_fatal (_(\"failed to set up debugging information: %s\"),\n \t\t  bfd_errmsg (bfd_get_error ()));"
    },
    {
      "sha": "c096cfc7258a5c385a2bb0f1de40af723775be5c",
      "filename": "gas/config/obj-elf.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-elf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-elf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-elf.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -198,7 +198,7 @@ extern void obj_elf_vtable_inherit (int);\n extern void obj_elf_vtable_entry (int);\n extern struct fix * obj_elf_get_vtable_inherit (void);\n extern struct fix * obj_elf_get_vtable_entry (void);\n-extern bfd_boolean obj_elf_seen_attribute\n+extern bool obj_elf_seen_attribute\n   (int, unsigned int);\n extern int obj_elf_vendor_attribute (int);\n "
    },
    {
      "sha": "19c364befce7d71e22fef4d1a3dcc55d48246c3d",
      "filename": "gas/config/obj-som.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-som.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/obj-som.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-som.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -247,7 +247,7 @@ obj_som_init_stab_section (segT seg)\n   p = frag_more (12);\n   memset (p, 0, 12);\n   file = as_where ((unsigned int *) NULL);\n-  stroff = get_stab_string_offset (file, \"$GDB_STRINGS$\", FALSE);\n+  stroff = get_stab_string_offset (file, \"$GDB_STRINGS$\", false);\n   know (stroff == 1);\n   md_number_to_chars (p, stroff, 4);\n   seg_info (seg)->stabu.p = p;"
    },
    {
      "sha": "fdc14403b3489a795f235f9912aa5263c4de3d2e",
      "filename": "gas/config/tc-aarch64.c",
      "status": "modified",
      "additions": 204,
      "deletions": 204,
      "changes": 408,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-aarch64.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -146,8 +146,8 @@ typedef struct aarch64_instruction aarch64_instruction;\n \n static aarch64_instruction inst;\n \n-static bfd_boolean parse_operands (char *, const aarch64_opcode *);\n-static bfd_boolean programmer_friendly_fixup (aarch64_instruction *);\n+static bool parse_operands (char *, const aarch64_opcode *);\n+static bool programmer_friendly_fixup (aarch64_instruction *);\n \n #ifdef OBJ_ELF\n #  define now_instr_sequence seg_info \\\n@@ -180,7 +180,7 @@ clear_error (void)\n   inst.parsing_error.error = NULL;\n }\n \n-static inline bfd_boolean\n+static inline bool\n error_p (void)\n {\n   return inst.parsing_error.kind != AARCH64_OPDE_NIL;\n@@ -532,23 +532,23 @@ const char FLT_CHARS[] = \"rRsSfFdDxXeEpPhH\";\n \n #define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)\n \n-static inline bfd_boolean\n+static inline bool\n skip_past_char (char **str, char c)\n {\n   if (**str == c)\n     {\n       (*str)++;\n-      return TRUE;\n+      return true;\n     }\n   else\n-    return FALSE;\n+    return false;\n }\n \n #define skip_past_comma(str) skip_past_char (str, ',')\n \n /* Arithmetic expressions (possibly involving symbols).\t */\n \n-static bfd_boolean in_my_get_expression_p = FALSE;\n+static bool in_my_get_expression_p = false;\n \n /* Third argument to my_get_expression.\t */\n #define GE_NO_PREFIX 0\n@@ -558,7 +558,7 @@ static bfd_boolean in_my_get_expression_p = FALSE;\n    as an valid expression; *EP will be filled with the information of\n    such an expression.  Otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n my_get_expression (expressionS * ep, char **str, int prefix_mode,\n \t\t   int reject_absent)\n {\n@@ -585,9 +585,9 @@ my_get_expression (expressionS * ep, char **str, int prefix_mode,\n \n   save_in = input_line_pointer;\n   input_line_pointer = *str;\n-  in_my_get_expression_p = TRUE;\n+  in_my_get_expression_p = true;\n   seg = expression (ep);\n-  in_my_get_expression_p = FALSE;\n+  in_my_get_expression_p = false;\n \n   if (ep->X_op == O_illegal || (reject_absent && ep->X_op == O_absent))\n     {\n@@ -598,7 +598,7 @@ my_get_expression (expressionS * ep, char **str, int prefix_mode,\n \tset_fatal_syntax_error (_(\"bad expression\"));\n       else\n \tset_first_syntax_error (_(\"bad expression\"));\n-      return FALSE;\n+      return false;\n     }\n \n #ifdef OBJ_AOUT\n@@ -610,15 +610,15 @@ my_get_expression (expressionS * ep, char **str, int prefix_mode,\n       set_syntax_error (_(\"bad segment\"));\n       *str = input_line_pointer;\n       input_line_pointer = save_in;\n-      return FALSE;\n+      return false;\n     }\n #else\n   (void) seg;\n #endif\n \n   *str = input_line_pointer;\n   input_line_pointer = save_in;\n-  return TRUE;\n+  return true;\n }\n \n /* Turn a string in input_line_pointer into a floating point constant\n@@ -769,7 +769,7 @@ parse_reg (char **ccp)\n \n /* Return TRUE if REG->TYPE is a valid type of TYPE; otherwise\n    return FALSE.  */\n-static bfd_boolean\n+static bool\n aarch64_check_reg_type (const reg_entry *reg, aarch64_reg_type type)\n {\n   return (reg_type_masks[type] & (1 << reg->type)) != 0;\n@@ -852,7 +852,7 @@ aarch64_reg_parse_32_64 (char **ccp, aarch64_opnd_qualifier_t *qualifier)\n    Accept only one occurrence of:\n    4b 8b 16b 2h 4h 8h 2s 4s 1d 2d\n    b h s d q  */\n-static bfd_boolean\n+static bool\n parse_vector_type_for_operand (aarch64_reg_type reg_type,\n \t\t\t       struct vector_type_el *parsed_type, char **str)\n {\n@@ -874,7 +874,7 @@ parse_vector_type_for_operand (aarch64_reg_type reg_type,\n   if (width != 1 && width != 2 && width != 4 && width != 8 && width != 16)\n     {\n       first_error_fmt (_(\"bad size %d in vector width specifier\"), width);\n-      return FALSE;\n+      return false;\n     }\n \n  elt_size:\n@@ -909,7 +909,7 @@ parse_vector_type_for_operand (aarch64_reg_type reg_type,\n \tfirst_error_fmt (_(\"unexpected character `%c' in element size\"), *ptr);\n       else\n \tfirst_error (_(\"missing element size\"));\n-      return FALSE;\n+      return false;\n     }\n   if (width != 0 && width * element_size != 64\n       && width * element_size != 128\n@@ -919,7 +919,7 @@ parse_vector_type_for_operand (aarch64_reg_type reg_type,\n       first_error_fmt (_\n \t\t       (\"invalid element size %d and vector size combination %c\"),\n \t\t       width, *ptr);\n-      return FALSE;\n+      return false;\n     }\n   ptr++;\n \n@@ -928,13 +928,13 @@ parse_vector_type_for_operand (aarch64_reg_type reg_type,\n \n   *str = ptr;\n \n-  return TRUE;\n+  return true;\n }\n \n /* *STR contains an SVE zero/merge predication suffix.  Parse it into\n    *PARSED_TYPE and point *STR at the end of the suffix.  */\n \n-static bfd_boolean\n+static bool\n parse_predication_for_operand (struct vector_type_el *parsed_type, char **str)\n {\n   char *ptr = *str;\n@@ -956,11 +956,11 @@ parse_predication_for_operand (struct vector_type_el *parsed_type, char **str)\n \t\t\t *ptr);\n       else\n \tfirst_error (_(\"missing predication type\"));\n-      return FALSE;\n+      return false;\n     }\n   parsed_type->width = 0;\n   *str = ptr + 1;\n-  return TRUE;\n+  return true;\n }\n \n /* Parse a register of the type TYPE.\n@@ -977,13 +977,13 @@ parse_predication_for_operand (struct vector_type_el *parsed_type, char **str)\n \n static int\n parse_typed_reg (char **ccp, aarch64_reg_type type, aarch64_reg_type *rtype,\n-\t\t struct vector_type_el *typeinfo, bfd_boolean in_reg_list)\n+\t\t struct vector_type_el *typeinfo, bool in_reg_list)\n {\n   char *str = *ccp;\n   const reg_entry *reg = parse_reg (&str);\n   struct vector_type_el atype;\n   struct vector_type_el parsetype;\n-  bfd_boolean is_typed_vecreg = FALSE;\n+  bool is_typed_vecreg = false;\n \n   atype.defined = 0;\n   atype.type = NT_invtype;\n@@ -1021,7 +1021,7 @@ parse_typed_reg (char **ccp, aarch64_reg_type type, aarch64_reg_type *rtype,\n \t}\n \n       /* Register if of the form Vn.[bhsdq].  */\n-      is_typed_vecreg = TRUE;\n+      is_typed_vecreg = true;\n \n       if (type == REG_TYPE_ZN || type == REG_TYPE_PN)\n \t{\n@@ -1118,7 +1118,7 @@ aarch64_reg_parse (char **ccp, aarch64_reg_type type,\n   struct vector_type_el atype;\n   char *str = *ccp;\n   int reg = parse_typed_reg (&str, type, rtype, &atype,\n-\t\t\t     /*in_reg_list= */ FALSE);\n+\t\t\t     /*in_reg_list= */ false);\n \n   if (reg == PARSE_FAIL)\n     return PARSE_FAIL;\n@@ -1131,7 +1131,7 @@ aarch64_reg_parse (char **ccp, aarch64_reg_type type,\n   return reg;\n }\n \n-static inline bfd_boolean\n+static inline bool\n eq_vector_type_el (struct vector_type_el e1, struct vector_type_el e2)\n {\n   return\n@@ -1172,8 +1172,8 @@ parse_vector_reg_list (char **ccp, aarch64_reg_type type,\n   int in_range;\n   int ret_val;\n   int i;\n-  bfd_boolean error = FALSE;\n-  bfd_boolean expect_index = FALSE;\n+  bool error = false;\n+  bool expect_index = false;\n \n   if (*str != '{')\n     {\n@@ -1199,31 +1199,31 @@ parse_vector_reg_list (char **ccp, aarch64_reg_type type,\n \t  val_range = val;\n \t}\n       val = parse_typed_reg (&str, type, NULL, &typeinfo,\n-\t\t\t     /*in_reg_list= */ TRUE);\n+\t\t\t     /*in_reg_list= */ true);\n       if (val == PARSE_FAIL)\n \t{\n \t  set_first_syntax_error (_(\"invalid vector register in list\"));\n-\t  error = TRUE;\n+\t  error = true;\n \t  continue;\n \t}\n       /* reject [bhsd]n */\n       if (type == REG_TYPE_VN && typeinfo.defined == 0)\n \t{\n \t  set_first_syntax_error (_(\"invalid scalar register in list\"));\n-\t  error = TRUE;\n+\t  error = true;\n \t  continue;\n \t}\n \n       if (typeinfo.defined & NTA_HASINDEX)\n-\texpect_index = TRUE;\n+\texpect_index = true;\n \n       if (in_range)\n \t{\n \t  if (val < val_range)\n \t    {\n \t      set_first_syntax_error\n \t\t(_(\"invalid range in vector register list\"));\n-\t      error = TRUE;\n+\t      error = true;\n \t    }\n \t  val_range++;\n \t}\n@@ -1236,7 +1236,7 @@ parse_vector_reg_list (char **ccp, aarch64_reg_type type,\n \t    {\n \t      set_first_syntax_error\n \t\t(_(\"type mismatch in vector register list\"));\n-\t      error = TRUE;\n+\t      error = true;\n \t    }\n \t}\n       if (! error)\n@@ -1253,7 +1253,7 @@ parse_vector_reg_list (char **ccp, aarch64_reg_type type,\n   if (*str != '}')\n     {\n       set_first_syntax_error (_(\"end of vector register list not found\"));\n-      error = TRUE;\n+      error = true;\n     }\n   str++;\n \n@@ -1269,29 +1269,29 @@ parse_vector_reg_list (char **ccp, aarch64_reg_type type,\n \t  if (exp.X_op != O_constant)\n \t    {\n \t      set_first_syntax_error (_(\"constant expression required.\"));\n-\t      error = TRUE;\n+\t      error = true;\n \t    }\n \t  if (! skip_past_char (&str, ']'))\n-\t    error = TRUE;\n+\t    error = true;\n \t  else\n \t    typeinfo_first.index = exp.X_add_number;\n \t}\n       else\n \t{\n \t  set_first_syntax_error (_(\"expected index\"));\n-\t  error = TRUE;\n+\t  error = true;\n \t}\n     }\n \n   if (nb_regs > 4)\n     {\n       set_first_syntax_error (_(\"too many registers in vector register list\"));\n-      error = TRUE;\n+      error = true;\n     }\n   else if (nb_regs == 0)\n     {\n       set_first_syntax_error (_(\"empty vector register list\"));\n-      error = TRUE;\n+      error = true;\n     }\n \n   *ccp = str;\n@@ -1329,7 +1329,7 @@ insert_reg_alias (char *str, int number, aarch64_reg_type type)\n   new->name = name;\n   new->number = number;\n   new->type = type;\n-  new->builtin = FALSE;\n+  new->builtin = false;\n \n   str_hash_insert (aarch64_reg_hsh, name, new, 0);\n \n@@ -1343,7 +1343,7 @@ insert_reg_alias (char *str, int number, aarch64_reg_type type)\n    If we find one, or if it looks sufficiently like one that we want to\n    handle any error here, return TRUE.  Otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n create_register_alias (char *newname, char *p)\n {\n   const reg_entry *old;\n@@ -1354,17 +1354,17 @@ create_register_alias (char *newname, char *p)\n      collapsed to single spaces.  */\n   oldname = p;\n   if (strncmp (oldname, \" .req \", 6) != 0)\n-    return FALSE;\n+    return false;\n \n   oldname += 6;\n   if (*oldname == '\\0')\n-    return FALSE;\n+    return false;\n \n   old = str_hash_find (aarch64_reg_hsh, oldname);\n   if (!old)\n     {\n       as_warn (_(\"unknown register '%s' -- .req ignored\"), oldname);\n-      return TRUE;\n+      return true;\n     }\n \n   /* If TC_CASE_SENSITIVE is defined, then newname already points to\n@@ -1401,7 +1401,7 @@ create_register_alias (char *newname, char *p)\n \t  if (insert_reg_alias (nbuf, old->number, old->type) == NULL)\n \t    {\n \t      free (nbuf);\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t}\n \n@@ -1413,7 +1413,7 @@ create_register_alias (char *newname, char *p)\n     }\n \n   free (nbuf);\n-  return TRUE;\n+  return true;\n }\n \n /* Should never be called, as .req goes between the alias and the\n@@ -1746,7 +1746,7 @@ find_or_make_literal_pool (int size)\n \n /* Add the literal of size SIZE in *EXP to the relevant literal pool.\n    Return TRUE on success, otherwise return FALSE.  */\n-static bfd_boolean\n+static bool\n add_to_lit_pool (expressionS *exp, int size)\n {\n   literal_pool *pool;\n@@ -1779,7 +1779,7 @@ add_to_lit_pool (expressionS *exp, int size)\n       if (entry >= MAX_LITERAL_POOL_SIZE)\n \t{\n \t  set_syntax_error (_(\"literal pool overflow\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       pool->literals[entry].exp = *exp;\n@@ -1801,7 +1801,7 @@ add_to_lit_pool (expressionS *exp, int size)\n   exp->X_add_number = ((int) entry) * size;\n   exp->X_add_symbol = pool->symbol;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Can't use symbol_new here, so have to create a symbol and then at\n@@ -2165,28 +2165,28 @@ const pseudo_typeS md_pseudo_table[] = {\n    state from being spoiled.\n    The function currently serves parse_constant_immediate and\n    parse_big_immediate only.  */\n-static bfd_boolean\n+static bool\n reg_name_p (char *str, aarch64_reg_type reg_type)\n {\n   int reg;\n \n   /* Prevent the diagnostics state from being spoiled.  */\n   if (error_p ())\n-    return FALSE;\n+    return false;\n \n   reg = aarch64_reg_parse (&str, reg_type, NULL, NULL);\n \n   /* Clear the parsing error that may be set by the reg parser.  */\n   clear_error ();\n \n   if (reg == PARSE_FAIL)\n-    return FALSE;\n+    return false;\n \n   skip_whitespace (str);\n   if (*str == ',' || is_end_of_line[(unsigned char) *str])\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Parser functions used exclusively in instruction operands.  */\n@@ -2198,25 +2198,25 @@ reg_name_p (char *str, aarch64_reg_type reg_type)\n    done to find out whether STR is a register of type REG_TYPE followed\n    by a comma or the end of line.  Return FALSE if STR is such a string.  */\n \n-static bfd_boolean\n+static bool\n parse_immediate_expression (char **str, expressionS *exp,\n \t\t\t    aarch64_reg_type reg_type)\n {\n   if (reg_name_p (*str, reg_type))\n     {\n       set_recoverable_error (_(\"immediate operand required\"));\n-      return FALSE;\n+      return false;\n     }\n \n   my_get_expression (exp, str, GE_OPT_PREFIX, 1);\n \n   if (exp->X_op == O_absent)\n     {\n       set_fatal_syntax_error (_(\"missing immediate expression\"));\n-      return FALSE;\n+      return false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Constant immediate-value read function for use in insn parsing.\n@@ -2226,22 +2226,22 @@ parse_immediate_expression (char **str, expressionS *exp,\n \n    Return TRUE on success; otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n parse_constant_immediate (char **str, int64_t *val, aarch64_reg_type reg_type)\n {\n   expressionS exp;\n \n   if (! parse_immediate_expression (str, &exp, reg_type))\n-    return FALSE;\n+    return false;\n \n   if (exp.X_op != O_constant)\n     {\n       set_syntax_error (_(\"constant expression required\"));\n-      return FALSE;\n+      return false;\n     }\n \n   *val = exp.X_add_number;\n-  return TRUE;\n+  return true;\n }\n \n static uint32_t\n@@ -2258,7 +2258,7 @@ encode_imm_float_bits (uint32_t imm)\n      (+/-) n / 16 * power (2, r)\n    where n and r are integers such that 16 <= n <=31 and -3 <= r <= 4.  */\n \n-static bfd_boolean\n+static bool\n aarch64_imm_float_p (uint32_t imm)\n {\n   /* If a single-precision floating-point value has the following bit\n@@ -2288,7 +2288,7 @@ aarch64_imm_float_p (uint32_t imm)\n    as an IEEE float without any loss of precision.  Store the value in\n    *FPWORD if so.  */\n \n-static bfd_boolean\n+static bool\n can_convert_double_to_float (uint64_t imm, uint32_t *fpword)\n {\n   /* If a double-precision floating-point value has the following bit\n@@ -2310,7 +2310,7 @@ can_convert_double_to_float (uint64_t imm, uint32_t *fpword)\n \n   /* Lower 29 bits need to be 0s.  */\n   if ((imm & 0x1fffffff) != 0)\n-    return FALSE;\n+    return false;\n \n   /* Prepare the pattern for 'Eeeeeeeee'.  */\n   if (((high32 >> 30) & 0x1) == 0)\n@@ -2320,21 +2320,21 @@ can_convert_double_to_float (uint64_t imm, uint32_t *fpword)\n \n   /* Check E~~~.  */\n   if ((high32 & 0x78000000) != pattern)\n-    return FALSE;\n+    return false;\n \n   /* Check Eeee_eeee != 1111_1111.  */\n   if ((high32 & 0x7ff00000) == 0x47f00000)\n-    return FALSE;\n+    return false;\n \n   *fpword = ((high32 & 0xc0000000)\t\t/* 1 n bit and 1 E bit.  */\n \t     | ((high32 << 3) & 0x3ffffff8)\t/* 7 e and 20 s bits.  */\n \t     | (low32 >> 29));\t\t\t/* 3 S bits.  */\n-  return TRUE;\n+  return true;\n }\n \n /* Return true if we should treat OPERAND as a double-precision\n    floating-point operand rather than a single-precision one.  */\n-static bfd_boolean\n+static bool\n double_precision_operand_p (const aarch64_opnd_info *operand)\n {\n   /* Check for unsuffixed SVE registers, which are allowed\n@@ -2356,16 +2356,16 @@ double_precision_operand_p (const aarch64_opnd_info *operand)\n    This routine accepts any IEEE float; it is up to the callers to reject\n    invalid ones.  */\n \n-static bfd_boolean\n-parse_aarch64_imm_float (char **ccp, int *immed, bfd_boolean dp_p,\n+static bool\n+parse_aarch64_imm_float (char **ccp, int *immed, bool dp_p,\n \t\t\t aarch64_reg_type reg_type)\n {\n   char *str = *ccp;\n   char *fpnum;\n   LITTLENUM_TYPE words[MAX_LITTLENUMS];\n   int64_t val = 0;\n   unsigned fpword = 0;\n-  bfd_boolean hex_p = FALSE;\n+  bool hex_p = false;\n \n   skip_past_char (&str, '#');\n \n@@ -2390,12 +2390,12 @@ parse_aarch64_imm_float (char **ccp, int *immed, bfd_boolean dp_p,\n       else\n \tfpword = val;\n \n-      hex_p = TRUE;\n+      hex_p = true;\n     }\n   else if (reg_name_p (str, reg_type))\n    {\n      set_recoverable_error (_(\"immediate operand required\"));\n-     return FALSE;\n+     return false;\n     }\n \n   if (! hex_p)\n@@ -2415,11 +2415,11 @@ parse_aarch64_imm_float (char **ccp, int *immed, bfd_boolean dp_p,\n \n   *immed = fpword;\n   *ccp = str;\n-  return TRUE;\n+  return true;\n \n  invalid_fp:\n   set_fatal_syntax_error (_(\"invalid floating-point constant\"));\n-  return FALSE;\n+  return false;\n }\n \n /* Less-generic immediate-value read function with the possibility of loading\n@@ -2431,15 +2431,15 @@ parse_aarch64_imm_float (char **ccp, int *immed, bfd_boolean dp_p,\n    out whether STR is a register of type REG_TYPE followed by a comma or\n    the end of line.  Return FALSE if STR is such a register.  */\n \n-static bfd_boolean\n+static bool\n parse_big_immediate (char **str, int64_t *imm, aarch64_reg_type reg_type)\n {\n   char *ptr = *str;\n \n   if (reg_name_p (ptr, reg_type))\n     {\n       set_syntax_error (_(\"immediate operand required\"));\n-      return FALSE;\n+      return false;\n     }\n \n   my_get_expression (&inst.reloc.exp, &ptr, GE_OPT_PREFIX, 1);\n@@ -2449,7 +2449,7 @@ parse_big_immediate (char **str, int64_t *imm, aarch64_reg_type reg_type)\n \n   *str = ptr;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Set operand IDX of the *INSTR that needs a GAS internal fixup.\n@@ -2470,7 +2470,7 @@ aarch64_set_gas_internal_fixup (struct reloc *reloc,\n /* Return TRUE if the instruction needs to be fixed up later internally by\n    the GAS; otherwise return FALSE.  */\n \n-static inline bfd_boolean\n+static inline bool\n aarch64_gas_internal_fixup_p (void)\n {\n   return inst.reloc.type == BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP;\n@@ -3096,7 +3096,7 @@ enum parse_shift_mode\n \n /* Parse a <shift> operator on an AArch64 data processing instruction.\n    Return TRUE on success; otherwise return FALSE.  */\n-static bfd_boolean\n+static bool\n parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n {\n   const struct aarch64_name_value_pair *shift_op;\n@@ -3112,31 +3112,31 @@ parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n   if (p == *str)\n     {\n       set_syntax_error (_(\"shift expression expected\"));\n-      return FALSE;\n+      return false;\n     }\n \n   shift_op = str_hash_find_n (aarch64_shift_hsh, *str, p - *str);\n \n   if (shift_op == NULL)\n     {\n       set_syntax_error (_(\"shift operator expected\"));\n-      return FALSE;\n+      return false;\n     }\n \n   kind = aarch64_get_operand_modifier (shift_op);\n \n   if (kind == AARCH64_MOD_MSL && mode != SHIFTED_LSL_MSL)\n     {\n       set_syntax_error (_(\"invalid use of 'MSL'\"));\n-      return FALSE;\n+      return false;\n     }\n \n   if (kind == AARCH64_MOD_MUL\n       && mode != SHIFTED_MUL\n       && mode != SHIFTED_MUL_VL)\n     {\n       set_syntax_error (_(\"invalid use of 'MUL'\"));\n-      return FALSE;\n+      return false;\n     }\n \n   switch (mode)\n@@ -3145,31 +3145,31 @@ parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n       if (aarch64_extend_operator_p (kind))\n \t{\n \t  set_syntax_error (_(\"extending shift is not permitted\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n \n     case SHIFTED_ARITH_IMM:\n       if (kind == AARCH64_MOD_ROR)\n \t{\n \t  set_syntax_error (_(\"'ROR' shift is not permitted\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n \n     case SHIFTED_LSL:\n       if (kind != AARCH64_MOD_LSL)\n \t{\n \t  set_syntax_error (_(\"only 'LSL' shift is permitted\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n \n     case SHIFTED_MUL:\n       if (kind != AARCH64_MOD_MUL)\n \t{\n \t  set_syntax_error (_(\"only 'MUL' is permitted\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n \n@@ -3187,23 +3187,23 @@ parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n \t    }\n \t}\n       set_syntax_error (_(\"only 'MUL VL' is permitted\"));\n-      return FALSE;\n+      return false;\n \n     case SHIFTED_REG_OFFSET:\n       if (kind != AARCH64_MOD_UXTW && kind != AARCH64_MOD_LSL\n \t  && kind != AARCH64_MOD_SXTW && kind != AARCH64_MOD_SXTX)\n \t{\n \t  set_fatal_syntax_error\n \t    (_(\"invalid shift for the register offset addressing mode\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n \n     case SHIFTED_LSL_MSL:\n       if (kind != AARCH64_MOD_LSL && kind != AARCH64_MOD_MSL)\n \t{\n \t  set_syntax_error (_(\"invalid shift operator\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n \n@@ -3236,14 +3236,14 @@ parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n       if (!aarch64_extend_operator_p (kind) || exp_has_prefix)\n \t{\n \t  set_syntax_error (_(\"missing shift amount\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       operand->shifter.amount = 0;\n     }\n   else if (exp.X_op != O_constant)\n     {\n       set_syntax_error (_(\"constant shift amount required\"));\n-      return FALSE;\n+      return false;\n     }\n   /* For parsing purposes, MUL #n has no inherent range.  The range\n      depends on the operand and will be checked by operand-specific\n@@ -3252,7 +3252,7 @@ parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n \t   && (exp.X_add_number < 0 || exp.X_add_number > 63))\n     {\n       set_fatal_syntax_error (_(\"shift amount out of range 0 to 63\"));\n-      return FALSE;\n+      return false;\n     }\n   else\n     {\n@@ -3264,7 +3264,7 @@ parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n   operand->shifter.kind = kind;\n \n   *str = p;\n-  return TRUE;\n+  return true;\n }\n \n /* Parse a <shifter_operand> for a data processing instruction:\n@@ -3276,36 +3276,36 @@ parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n \n    Return TRUE on success; otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n parse_shifter_operand_imm (char **str, aarch64_opnd_info *operand,\n \t\t\t   enum parse_shift_mode mode)\n {\n   char *p;\n \n   if (mode != SHIFTED_ARITH_IMM && mode != SHIFTED_LOGIC_IMM)\n-    return FALSE;\n+    return false;\n \n   p = *str;\n \n   /* Accept an immediate expression.  */\n   if (! my_get_expression (&inst.reloc.exp, &p, GE_OPT_PREFIX, 1))\n-    return FALSE;\n+    return false;\n \n   /* Accept optional LSL for arithmetic immediate values.  */\n   if (mode == SHIFTED_ARITH_IMM && skip_past_comma (&p))\n     if (! parse_shift (&p, operand, SHIFTED_LSL))\n-      return FALSE;\n+      return false;\n \n   /* Not accept any shifter for logical immediate values.  */\n   if (mode == SHIFTED_LOGIC_IMM && skip_past_comma (&p)\n       && parse_shift (&p, operand, mode))\n     {\n       set_syntax_error (_(\"unexpected shift operator\"));\n-      return FALSE;\n+      return false;\n     }\n \n   *str = p;\n-  return TRUE;\n+  return true;\n }\n \n /* Parse a <shifter_operand> for a data processing instruction:\n@@ -3322,7 +3322,7 @@ parse_shifter_operand_imm (char **str, aarch64_opnd_info *operand,\n \n    Return TRUE on success; otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n parse_shifter_operand (char **str, aarch64_opnd_info *operand,\n \t\t       enum parse_shift_mode mode)\n {\n@@ -3337,33 +3337,33 @@ parse_shifter_operand (char **str, aarch64_opnd_info *operand,\n       if (opd_class == AARCH64_OPND_CLASS_IMMEDIATE)\n \t{\n \t  set_syntax_error (_(\"unexpected register in the immediate operand\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (!aarch64_check_reg_type (reg, REG_TYPE_R_Z))\n \t{\n \t  set_syntax_error (_(get_reg_expected_msg (REG_TYPE_R_Z)));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       operand->reg.regno = reg->number;\n       operand->qualifier = qualifier;\n \n       /* Accept optional shift operation on register.  */\n       if (! skip_past_comma (str))\n-\treturn TRUE;\n+\treturn true;\n \n       if (! parse_shift (str, operand, mode))\n-\treturn FALSE;\n+\treturn false;\n \n-      return TRUE;\n+      return true;\n     }\n   else if (opd_class == AARCH64_OPND_CLASS_MODIFIED_REG)\n     {\n       set_syntax_error\n \t(_(\"integer register expected in the extended/shifted operand \"\n \t   \"register\"));\n-      return FALSE;\n+      return false;\n     }\n \n   /* We have a shifted immediate variable.  */\n@@ -3372,7 +3372,7 @@ parse_shifter_operand (char **str, aarch64_opnd_info *operand,\n \n /* Return TRUE on success; return FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n parse_shifter_operand_reloc (char **str, aarch64_opnd_info *operand,\n \t\t\t     enum parse_shift_mode mode)\n {\n@@ -3397,30 +3397,30 @@ parse_shifter_operand_reloc (char **str, aarch64_opnd_info *operand,\n       if (!(entry = find_reloc_table_entry (str)))\n \t{\n \t  set_syntax_error (_(\"unknown relocation modifier\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (entry->add_type == 0)\n \t{\n \t  set_syntax_error\n \t    (_(\"this relocation modifier is not allowed on this instruction\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       /* Save str before we decompose it.  */\n       p = *str;\n \n       /* Next, we parse the expression.  */\n       if (! my_get_expression (&inst.reloc.exp, str, GE_NO_PREFIX, 1))\n-\treturn FALSE;\n+\treturn false;\n \n       /* Record the relocation type (use the ADD variant here).  */\n       inst.reloc.type = entry->add_type;\n       inst.reloc.pc_rel = entry->pc_rel;\n \n       /* If str is empty, we've reached the end, stop here.  */\n       if (**str == '\\0')\n-\treturn TRUE;\n+\treturn true;\n \n       /* Otherwise, we have a shifted reloc modifier, so rewind to\n          recover the variable name and continue parsing for the shifter.  */\n@@ -3501,7 +3501,7 @@ parse_shifter_operand_reloc (char **str, aarch64_opnd_info *operand,\n    for addressing modes not supported by the instruction, and to set\n    inst.reloc.type.  */\n \n-static bfd_boolean\n+static bool\n parse_address_main (char **str, aarch64_opnd_info *operand,\n \t\t    aarch64_opnd_qualifier_t *base_qualifier,\n \t\t    aarch64_opnd_qualifier_t *offset_qualifier,\n@@ -3533,7 +3533,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t  if (! entry)\n \t    {\n \t      set_syntax_error (_(\"unknown relocation modifier\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  switch (operand->type)\n@@ -3553,14 +3553,14 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t      set_syntax_error\n \t\t(_(\"this relocation modifier is not allowed on this \"\n \t\t   \"instruction\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  /* #:<reloc_op>:  */\n \t  if (! my_get_expression (exp, &p, GE_NO_PREFIX, 1))\n \t    {\n \t      set_syntax_error (_(\"invalid relocation expression\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  /* #:<reloc_op>:<expr>  */\n@@ -3578,12 +3578,12 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t  if (!my_get_expression (exp, &p, GE_NO_PREFIX, 1))\n \t    {\n \t      set_syntax_error (_(\"invalid address\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \n       *str = p;\n-      return TRUE;\n+      return true;\n     }\n \n   /* [ */\n@@ -3592,7 +3592,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n   if (!reg || !aarch64_check_reg_type (reg, base_type))\n     {\n       set_syntax_error (_(get_reg_expected_msg (base_type)));\n-      return FALSE;\n+      return false;\n     }\n   operand->addr.base_regno = reg->number;\n \n@@ -3608,7 +3608,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t  if (!aarch64_check_reg_type (reg, offset_type))\n \t    {\n \t      set_syntax_error (_(get_reg_expected_msg (offset_type)));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  /* [Xn,Rm  */\n@@ -3621,7 +3621,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t      if (! parse_shift (&p, operand, SHIFTED_REG_OFFSET))\n \t\t/* Use the diagnostics set in parse_shift, so not set new\n \t\t   error message here.  */\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t  /* We only accept:\n \t     [base,Xm]  # For vector plus scalar SVE2 indexing.\n@@ -3635,7 +3635,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t      if (*offset_qualifier == AARCH64_OPND_QLF_W)\n \t\t{\n \t\t  set_syntax_error (_(\"invalid use of 32-bit register offset\"));\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t      if (aarch64_get_qualifier_esize (*base_qualifier)\n \t\t  != aarch64_get_qualifier_esize (*offset_qualifier)\n@@ -3644,13 +3644,13 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t\t      || *offset_qualifier != AARCH64_OPND_QLF_X))\n \t\t{\n \t\t  set_syntax_error (_(\"offset has different size from base\"));\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t    }\n \t  else if (*offset_qualifier == AARCH64_OPND_QLF_X)\n \t    {\n \t      set_syntax_error (_(\"invalid use of 64-bit register offset\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n       else\n@@ -3666,15 +3666,15 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t      if (!(entry = find_reloc_table_entry (&p)))\n \t\t{\n \t\t  set_syntax_error (_(\"unknown relocation modifier\"));\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \n \t      if (entry->ldst_type == 0)\n \t\t{\n \t\t  set_syntax_error\n \t\t    (_(\"this relocation modifier is not allowed on this \"\n \t\t       \"instruction\"));\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \n \t      /* [Xn,#:<reloc_op>:  */\n@@ -3684,7 +3684,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t      if (! my_get_expression (exp, &p, GE_NO_PREFIX, 1))\n \t\t{\n \t\t  set_syntax_error (_(\"invalid relocation expression\"));\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \n \t      /* [Xn,#:<reloc_op>:<expr>  */\n@@ -3697,21 +3697,21 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t      if (! my_get_expression (exp, &p, GE_OPT_PREFIX, 1))\n \t\t{\n \t\t  set_syntax_error (_(\"invalid expression in the address\"));\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t      /* [Xn,<expr>  */\n \t      if (imm_shift_mode != SHIFTED_NONE && skip_past_comma (&p))\n \t\t/* [Xn,<expr>,<shifter>  */\n \t\tif (! parse_shift (&p, operand, imm_shift_mode))\n-\t\t  return FALSE;\n+\t\t  return false;\n \t    }\n \t}\n     }\n \n   if (! skip_past_char (&p, ']'))\n     {\n       set_syntax_error (_(\"']' expected\"));\n-      return FALSE;\n+      return false;\n     }\n \n   if (skip_past_char (&p, '!'))\n@@ -3720,7 +3720,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t{\n \t  set_syntax_error (_(\"register offset not allowed in pre-indexed \"\n \t\t\t      \"addressing mode\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       /* [Xn]! */\n       operand->addr.writeback = 1;\n@@ -3734,7 +3734,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n       if (operand->addr.preind)\n \t{\n \t  set_syntax_error (_(\"cannot combine pre- and post-indexing\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       reg = aarch64_reg_parse_32_64 (&p, offset_qualifier);\n@@ -3744,7 +3744,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t  if (!aarch64_check_reg_type (reg, REG_TYPE_R_64))\n \t    {\n \t      set_syntax_error (_(get_reg_expected_msg (REG_TYPE_R_64)));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  operand->addr.offset.regno = reg->number;\n@@ -3754,7 +3754,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n \t{\n \t  /* [Xn],#expr */\n \t  set_syntax_error (_(\"invalid expression in the address\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n@@ -3778,7 +3778,7 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n            {\n \t     /* Reject [Rn]!   */\n \t     set_syntax_error (_(\"missing offset in the pre-indexed address\"));\n-\t     return FALSE;\n+\t     return false;\n \t   }\n \t}\n        else\n@@ -3799,12 +3799,12 @@ parse_address_main (char **str, aarch64_opnd_info *operand,\n     }\n \n   *str = p;\n-  return TRUE;\n+  return true;\n }\n \n /* Parse a base AArch64 address (as opposed to an SVE one).  Return TRUE\n    on success.  */\n-static bfd_boolean\n+static bool\n parse_address (char **str, aarch64_opnd_info *operand)\n {\n   aarch64_opnd_qualifier_t base_qualifier, offset_qualifier;\n@@ -3815,7 +3815,7 @@ parse_address (char **str, aarch64_opnd_info *operand)\n /* Parse an address in which SVE vector registers and MUL VL are allowed.\n    The arguments have the same meaning as for parse_address_main.\n    Return TRUE on success.  */\n-static bfd_boolean\n+static bool\n parse_sve_address (char **str, aarch64_opnd_info *operand,\n \t\t   aarch64_opnd_qualifier_t *base_qualifier,\n \t\t   aarch64_opnd_qualifier_t *offset_qualifier)\n@@ -3827,7 +3827,7 @@ parse_sve_address (char **str, aarch64_opnd_info *operand,\n \n /* Parse an operand for a MOVZ, MOVN or MOVK instruction.\n    Return TRUE on success; otherwise return FALSE.  */\n-static bfd_boolean\n+static bool\n parse_half (char **str, int *internal_fixup_p)\n {\n   char *p = *str;\n@@ -3846,14 +3846,14 @@ parse_half (char **str, int *internal_fixup_p)\n       if (!(entry = find_reloc_table_entry (&p)))\n \t{\n \t  set_syntax_error (_(\"unknown relocation modifier\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (entry->movw_type == 0)\n \t{\n \t  set_syntax_error\n \t    (_(\"this relocation modifier is not allowed on this instruction\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       inst.reloc.type = entry->movw_type;\n@@ -3862,17 +3862,17 @@ parse_half (char **str, int *internal_fixup_p)\n     *internal_fixup_p = 1;\n \n   if (! my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX, 1))\n-    return FALSE;\n+    return false;\n \n   *str = p;\n-  return TRUE;\n+  return true;\n }\n \n /* Parse an operand for an ADRP instruction:\n      ADRP <Xd>, <label>\n    Return TRUE on success; otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n parse_adrp (char **str)\n {\n   char *p;\n@@ -3887,14 +3887,14 @@ parse_adrp (char **str)\n       if (!(entry = find_reloc_table_entry (&p)))\n \t{\n \t  set_syntax_error (_(\"unknown relocation modifier\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (entry->adrp_type == 0)\n \t{\n \t  set_syntax_error\n \t    (_(\"this relocation modifier is not allowed on this instruction\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       inst.reloc.type = entry->adrp_type;\n@@ -3905,10 +3905,10 @@ parse_adrp (char **str)\n   inst.reloc.pc_rel = 1;\n \n   if (! my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX, 1))\n-    return FALSE;\n+    return false;\n \n   *str = p;\n-  return TRUE;\n+  return true;\n }\n \n /* Miscellaneous. */\n@@ -3941,22 +3941,22 @@ parse_enum_string (char **str, int64_t *val, const char *const *array,\n       {\n \t*val = i;\n \t*str = q;\n-\treturn TRUE;\n+\treturn true;\n       }\n \n   if (!parse_immediate_expression (&p, &exp, reg_type))\n-    return FALSE;\n+    return false;\n \n   if (exp.X_op == O_constant\n       && (uint64_t) exp.X_add_number < size)\n     {\n       *val = exp.X_add_number;\n       *str = p;\n-      return TRUE;\n+      return true;\n     }\n \n   /* Use the default error for this operand.  */\n-  return FALSE;\n+  return false;\n }\n \n /* Parse an option for a preload instruction.  Returns the encoding for the\n@@ -4389,7 +4389,7 @@ const char* operand_mismatch_kind_names[] =\n    line, only the error of the highest severity will be picked up for\n    issuing the diagnostics.  */\n \n-static inline bfd_boolean\n+static inline bool\n operand_error_higher_severity_p (enum aarch64_operand_error_kind lhs,\n \t\t\t\t enum aarch64_operand_error_kind rhs)\n {\n@@ -4492,7 +4492,7 @@ init_operand_error_report (void)\n /* Return TRUE if some operand error has been recorded during the\n    parsing of the current assembly line using the opcode *OPCODE;\n    otherwise return FALSE.  */\n-static inline bfd_boolean\n+static inline bool\n opcode_has_operand_error_p (const aarch64_opcode *opcode)\n {\n   operand_error_record *record = operand_error_report.head;\n@@ -4574,7 +4574,7 @@ record_operand_error (const aarch64_opcode *opcode, int idx,\n   info.index = idx;\n   info.kind = kind;\n   info.error = error;\n-  info.non_fatal = FALSE;\n+  info.non_fatal = false;\n   record_operand_error_info (opcode, &info);\n }\n \n@@ -4590,7 +4590,7 @@ record_operand_error_with_data (const aarch64_opcode *opcode, int idx,\n   info.data[0] = extra_data[0];\n   info.data[1] = extra_data[1];\n   info.data[2] = extra_data[2];\n-  info.non_fatal = FALSE;\n+  info.non_fatal = false;\n   record_operand_error_info (opcode, &info);\n }\n \n@@ -4817,7 +4817,7 @@ output_operand_error_record (const operand_error_record *record, char *str)\n \t     which is still not right.  */\n \t  size_t len = strlen (get_mnemonic_name (str));\n \t  int i, qlf_idx;\n-\t  bfd_boolean result;\n+\t  bool result;\n \t  char buf[2048];\n \t  aarch64_inst *inst_base = &inst.base;\n \t  const aarch64_opnd_qualifier_seq_t *qualifiers_list;\n@@ -4935,7 +4935,7 @@ output_operand_error_record (const operand_error_record *record, char *str)\n    print due to the different instruction templates.  */\n \n static void\n-output_operand_error_report (char *str, bfd_boolean non_fatal_only)\n+output_operand_error_report (char *str, bool non_fatal_only)\n {\n   int largest_error_pos;\n   const char *msg = NULL;\n@@ -5335,7 +5335,7 @@ process_omitted_operand (enum aarch64_opnd type, const aarch64_opcode *opcode,\n /* Process the relocation type for move wide instructions.\n    Return TRUE on success; otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n process_movw_reloc_info (void)\n {\n   int is32;\n@@ -5359,7 +5359,7 @@ process_movw_reloc_info (void)\n       case BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2:\n \tset_syntax_error\n \t  (_(\"the specified relocation type is not allowed for MOVK\"));\n-\treturn FALSE;\n+\treturn false;\n       default:\n \tbreak;\n       }\n@@ -5408,7 +5408,7 @@ process_movw_reloc_info (void)\n \t  set_fatal_syntax_error\n \t    (_(\"the specified relocation type is not allowed for 32-bit \"\n \t       \"register\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       shift = 32;\n       break;\n@@ -5419,7 +5419,7 @@ process_movw_reloc_info (void)\n \t  set_fatal_syntax_error\n \t    (_(\"the specified relocation type is not allowed for 32-bit \"\n \t       \"register\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       shift = 48;\n       break;\n@@ -5428,10 +5428,10 @@ process_movw_reloc_info (void)\n          are supported in GAS.  */\n       gas_assert (aarch64_gas_internal_fixup_p ());\n       /* The shift amount should have already been set by the parser.  */\n-      return TRUE;\n+      return true;\n     }\n   inst.base.operands[1].shifter.amount = shift;\n-  return TRUE;\n+  return true;\n }\n \n /* A primitive log calculator.  */\n@@ -5537,7 +5537,7 @@ ldst_lo12_determine_real_reloc_type (void)\n \n    Return FALSE if such a register list is invalid, otherwise return TRUE.  */\n \n-static bfd_boolean\n+static bool\n reg_list_valid_p (uint32_t reginfo, int accept_alternate)\n {\n   uint32_t i, nb_regs, prev_regno, incr;\n@@ -5553,19 +5553,19 @@ reg_list_valid_p (uint32_t reginfo, int accept_alternate)\n       reginfo >>= 5;\n       curr_regno = reginfo & 0x1f;\n       if (curr_regno != ((prev_regno + incr) & 0x1f))\n-\treturn FALSE;\n+\treturn false;\n       prev_regno = curr_regno;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Generic instruction operand parser.\tThis does no encoding and no\n    semantic validation; it merely squirrels values away in the inst\n    structure.  Returns TRUE or FALSE depending on whether the\n    specified grammar matched.  */\n \n-static bfd_boolean\n+static bool\n parse_operands (char *str, const aarch64_opcode *opcode)\n {\n   int i;\n@@ -5997,10 +5997,10 @@ parse_operands (char *str, const aarch64_opcode *opcode)\n \tcase AARCH64_OPND_FPIMM0:\n \t  {\n \t    int qfloat;\n-\t    bfd_boolean res1 = FALSE, res2 = FALSE;\n+\t    bool res1 = false, res2 = false;\n \t    /* N.B. -0.0 will be rejected; although -0.0 shouldn't be rejected,\n \t       it is probably not worth the effort to support it.  */\n-\t    if (!(res1 = parse_aarch64_imm_float (&str, &qfloat, FALSE,\n+\t    if (!(res1 = parse_aarch64_imm_float (&str, &qfloat, false,\n \t\t\t\t\t\t  imm_reg_type))\n \t\t&& (error_p ()\n \t\t    || !(res2 = parse_constant_immediate (&str, &val,\n@@ -6066,7 +6066,7 @@ parse_operands (char *str, const aarch64_opcode *opcode)\n \tcase AARCH64_OPND_SVE_FPIMM8:\n \t  {\n \t    int qfloat;\n-\t    bfd_boolean dp_p;\n+\t    bool dp_p;\n \n \t    dp_p = double_precision_operand_p (&inst.base.operands[0]);\n \t    if (!parse_aarch64_imm_float (&str, &qfloat, dp_p, imm_reg_type)\n@@ -6087,7 +6087,7 @@ parse_operands (char *str, const aarch64_opcode *opcode)\n \tcase AARCH64_OPND_SVE_I1_ZERO_ONE:\n \t  {\n \t    int qfloat;\n-\t    bfd_boolean dp_p;\n+\t    bool dp_p;\n \n \t    dp_p = double_precision_operand_p (&inst.base.operands[0]);\n \t    if (!parse_aarch64_imm_float (&str, &qfloat, dp_p, imm_reg_type))\n@@ -6857,12 +6857,12 @@ parse_operands (char *str, const aarch64_opcode *opcode)\n \t the problem.  */\n       record_operand_error (opcode, i, get_error_kind (),\n \t\t\t    get_error_message ());\n-      return FALSE;\n+      return false;\n     }\n   else\n     {\n       DEBUG_TRACE (\"parsing SUCCESS\");\n-      return TRUE;\n+      return true;\n     }\n }\n \n@@ -6871,7 +6871,7 @@ parse_operands (char *str, const aarch64_opcode *opcode)\n    the preferred architectural syntax.\n    Return FALSE if there is any failure; otherwise return TRUE.  */\n \n-static bfd_boolean\n+static bool\n programmer_friendly_fixup (aarch64_instruction *instr)\n {\n   aarch64_inst *base = &instr->base;\n@@ -6895,7 +6895,7 @@ programmer_friendly_fixup (aarch64_instruction *instr)\n \t    {\n \t      record_operand_out_of_range_error (opcode, 1, _(\"immediate value\"),\n \t\t\t\t\t\t 0, 31);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  operands[0].qualifier = AARCH64_OPND_QLF_X;\n \t}\n@@ -6920,14 +6920,14 @@ programmer_friendly_fixup (aarch64_instruction *instr)\n \t      record_operand_error (opcode, 1,\n \t\t\t\t    AARCH64_OPDE_FATAL_SYNTAX_ERROR,\n \t\t\t\t    _(\"constant expression expected\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  if (! add_to_lit_pool (&instr->reloc.exp, size))\n \t    {\n \t      record_operand_error (opcode, 1,\n \t\t\t\t    AARCH64_OPDE_OTHER_ERROR,\n \t\t\t\t    _(\"literal pool insertion failed\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n       break;\n@@ -6971,7 +6971,7 @@ programmer_friendly_fixup (aarch64_instruction *instr)\n     }\n \n   DEBUG_TRACE (\"exit with SUCCESS\");\n-  return TRUE;\n+  return true;\n }\n \n /* Check for loads and stores that will cause unpredictable behavior.  */\n@@ -7055,7 +7055,7 @@ force_automatic_sequence_close (void)\n \n    Return TRUE on success; otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n do_encode (const aarch64_opcode *opcode, aarch64_inst *instr,\n \t   aarch64_insn *code)\n {\n@@ -7064,7 +7064,7 @@ do_encode (const aarch64_opcode *opcode, aarch64_inst *instr,\n   error_info.kind = AARCH64_OPDE_NIL;\n   if (aarch64_opcode_encode (opcode, instr, code, NULL, &error_info, insn_sequence)\n       && !error_info.non_fatal)\n-    return TRUE;\n+    return true;\n \n   gas_assert (error_info.kind != AARCH64_OPDE_NIL);\n   record_operand_error_info (opcode, &error_info);\n@@ -7210,7 +7210,7 @@ md_assemble (char *str)\n \t    }\n \n \t  /* Issue non-fatal messages if any.  */\n-\t  output_operand_error_report (str, TRUE);\n+\t  output_operand_error_report (str, true);\n \t  return;\n \t}\n \n@@ -7224,7 +7224,7 @@ md_assemble (char *str)\n   while (template != NULL);\n \n   /* Issue the error messages if any.  */\n-  output_operand_error_report (str, FALSE);\n+  output_operand_error_report (str, false);\n }\n \n /* Various frobbings of labels and their addresses.  */\n@@ -7280,8 +7280,8 @@ aarch64_canonicalize_symbol_name (char *name)\n    should appear in both upper and lowercase variants.\tSome registers\n    also have mixed-case names.\t*/\n \n-#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, TRUE }\n-#define REGDEF_ALIAS(s, n, t) { #s, n, REG_TYPE_##t, FALSE}\n+#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, true }\n+#define REGDEF_ALIAS(s, n, t) { #s, n, REG_TYPE_##t, false}\n #define REGNUM(p,n,t) REGDEF(p##n, n, t)\n #define REGSET16(p,t) \\\n   REGNUM(p, 0,t), REGNUM(p, 1,t), REGNUM(p, 2,t), REGNUM(p, 3,t), \\\n@@ -7629,12 +7629,12 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n    range expressible by a unsigned number with the indicated number of\n    BITS.  */\n \n-static bfd_boolean\n+static bool\n unsigned_overflow (valueT value, unsigned bits)\n {\n   valueT lim;\n   if (bits >= sizeof (valueT) * 8)\n-    return FALSE;\n+    return false;\n   lim = (valueT) 1 << bits;\n   return (value >= lim);\n }\n@@ -7644,12 +7644,12 @@ unsigned_overflow (valueT value, unsigned bits)\n    range expressible by an signed number with the indicated number of\n    BITS.  */\n \n-static bfd_boolean\n+static bool\n signed_overflow (offsetT value, unsigned bits)\n {\n   offsetT lim;\n   if (bits >= sizeof (offsetT) * 8)\n-    return FALSE;\n+    return false;\n   lim = (offsetT) 1 << (bits - 1);\n   return (value < -lim || value >= lim);\n }\n@@ -7663,7 +7663,7 @@ signed_overflow (offsetT value, unsigned bits)\n    in response to the standard LDR/STR mnemonics when the immediate offset is\n    unambiguous, i.e. when it is negative or unaligned.  */\n \n-static bfd_boolean\n+static bool\n try_to_encode_as_unscaled_ldst (aarch64_inst *instr)\n {\n   int idx;\n@@ -7690,7 +7690,7 @@ try_to_encode_as_unscaled_ldst (aarch64_inst *instr)\n     }\n \n   if (new_op == OP_NIL)\n-    return FALSE;\n+    return false;\n \n   new_opcode = aarch64_get_opcode (new_op);\n   gas_assert (new_opcode != NULL);\n@@ -7712,9 +7712,9 @@ try_to_encode_as_unscaled_ldst (aarch64_inst *instr)\n \n   if (!aarch64_opcode_encode (instr->opcode, instr, &instr->value, NULL, NULL,\n \t\t\t      insn_sequence))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Called by fix_insn to fix a MOV immediate alias instruction.\n@@ -9252,7 +9252,7 @@ aarch64_feature_enable_set (aarch64_feature_set set)\n \n static int\n aarch64_parse_features (const char *str, const aarch64_feature_set **opt_p,\n-\t\t\tbfd_boolean ext_only)\n+\t\t\tbool ext_only)\n {\n   /* We insist on extensions being added before being removed.  We achieve\n      this by using the ADDING_VALUE variable to indicate whether we are\n@@ -9302,7 +9302,7 @@ aarch64_parse_features (const char *str, const aarch64_feature_set **opt_p,\n \t    {\n \t      as_bad (_(\"must specify extensions to add before specifying \"\n \t\t\t\"those to remove\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \n@@ -9368,7 +9368,7 @@ aarch64_parse_cpu (const char *str)\n       {\n \tmcpu_cpu_opt = &opt->value;\n \tif (ext != NULL)\n-\t  return aarch64_parse_features (ext, &mcpu_cpu_opt, FALSE);\n+\t  return aarch64_parse_features (ext, &mcpu_cpu_opt, false);\n \n \treturn 1;\n       }\n@@ -9400,7 +9400,7 @@ aarch64_parse_arch (const char *str)\n       {\n \tmarch_cpu_opt = &opt->value;\n \tif (ext != NULL)\n-\t  return aarch64_parse_features (ext, &march_cpu_opt, FALSE);\n+\t  return aarch64_parse_features (ext, &march_cpu_opt, false);\n \n \treturn 1;\n       }\n@@ -9581,7 +9581,7 @@ s_aarch64_cpu (int ignored ATTRIBUTE_UNUSED)\n       {\n \tmcpu_cpu_opt = &opt->value;\n \tif (ext != NULL)\n-\t  if (!aarch64_parse_features (ext, &mcpu_cpu_opt, FALSE))\n+\t  if (!aarch64_parse_features (ext, &mcpu_cpu_opt, false))\n \t    return;\n \n \tcpu_variant = *mcpu_cpu_opt;\n@@ -9627,7 +9627,7 @@ s_aarch64_arch (int ignored ATTRIBUTE_UNUSED)\n       {\n \tmcpu_cpu_opt = &opt->value;\n \tif (ext != NULL)\n-\t  if (!aarch64_parse_features (ext, &mcpu_cpu_opt, FALSE))\n+\t  if (!aarch64_parse_features (ext, &mcpu_cpu_opt, false))\n \t    return;\n \n \tcpu_variant = *mcpu_cpu_opt;\n@@ -9655,7 +9655,7 @@ s_aarch64_arch_extension (int ignored ATTRIBUTE_UNUSED)\n   saved_char = *input_line_pointer;\n   *input_line_pointer = 0;\n \n-  if (!aarch64_parse_features (ext, &mcpu_cpu_opt, TRUE))\n+  if (!aarch64_parse_features (ext, &mcpu_cpu_opt, true))\n     return;\n \n   cpu_variant = *mcpu_cpu_opt;"
    },
    {
      "sha": "968375593930e665941258220b6253e19a269173",
      "filename": "gas/config/tc-alpha.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-alpha.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -5584,7 +5584,7 @@ md_atof (int type, char *litP, int *sizeP)\n       return vax_md_atof (type, litP, sizeP);\n \n     default:\n-      return ieee_md_atof (type, litP, sizeP, FALSE);\n+      return ieee_md_atof (type, litP, sizeP, false);\n     }\n }\n "
    },
    {
      "sha": "8432c0c294e30d2d95df343c9507529ad43c1613",
      "filename": "gas/config/tc-arc.c",
      "status": "modified",
      "additions": 111,
      "deletions": 113,
      "changes": 224,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arc.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -312,7 +312,7 @@ struct arc_fixup\n   unsigned char pcrel;\n \n   /* TRUE if this fixup is for LIMM operand.  */\n-  bfd_boolean islong;\n+  bool islong;\n };\n \n struct arc_insn\n@@ -321,11 +321,9 @@ struct arc_insn\n   int nfixups;\n   struct arc_fixup fixups[MAX_INSN_FIXUPS];\n   long limm;\n-  unsigned int len;       /* Length of instruction in bytes.  */\n-  bfd_boolean has_limm;   /* Boolean value: TRUE if limm field is\n-\t\t\t     valid.  */\n-  bfd_boolean relax;\t  /* Boolean value: TRUE if needs\n-\t\t\t     relaxation.  */\n+  unsigned int len;     /* Length of instruction in bytes.  */\n+  bool has_limm;\t/* Boolean value: TRUE if limm field is valid.  */\n+  bool relax;\t\t/* Boolean value: TRUE if needs relaxation.  */\n };\n \n /* Structure to hold any last two instructions.  */\n@@ -335,10 +333,10 @@ static struct arc_last_insn\n   const struct arc_opcode *opcode;\n \n   /* Boolean value: TRUE if current insn is short.  */\n-  bfd_boolean has_limm;\n+  bool has_limm;\n \n   /* Boolean value: TRUE if current insn has delay slot.  */\n-  bfd_boolean has_delay_slot;\n+  bool has_delay_slot;\n } arc_last_insns[2];\n \n /* Extension instruction suffix classes.  */\n@@ -472,7 +470,7 @@ static const struct cpu_type\n static struct cpu_type selected_cpu = { 0, 0, 0, E_ARC_OSABI_CURRENT, 0 };\n \n /* TRUE if current assembly code uses RF16 only registers.  */\n-static bfd_boolean rf16_only = TRUE;\n+static bool rf16_only = true;\n \n /* MPY option.  */\n static unsigned mpy_option = 0;\n@@ -688,10 +686,10 @@ const unsigned arc_num_relaxable_ins = ARRAY_SIZE (arc_relaxable_insns);\n symbolS * GOT_symbol = 0;\n \n /* Set to TRUE when we assemble instructions.  */\n-static bfd_boolean assembling_insn = FALSE;\n+static bool assembling_insn = false;\n \n /* List with attributes set explicitly.  */\n-static bfd_boolean attributes_set_explicitly[NUM_KNOWN_OBJ_ATTRIBUTES];\n+static bool attributes_set_explicitly[NUM_KNOWN_OBJ_ATTRIBUTES];\n \n /* Functions implementation.  */\n \n@@ -946,7 +944,7 @@ arc_extra_reloc (int r_type)\n \t       0,\t\t/* size: 1, 2, or 4 usually.  */\n \t       sym,\t\t/* X_add_symbol.  */\n \t       0,\t\t/* X_add_number.  */\n-\t       FALSE,\t\t/* TRUE if PC-relative relocation.  */\n+\t       false,\t\t/* TRUE if PC-relative relocation.  */\n \t       r_type\t\t/* Relocation type.  */);\n   fixP->fx_subsy = lab;\n }\n@@ -1201,8 +1199,8 @@ tokenize_arguments (char *str,\n \t\t    int ntok)\n {\n   char *old_input_line_pointer;\n-  bfd_boolean saw_comma = FALSE;\n-  bfd_boolean saw_arg = FALSE;\n+  bool saw_comma = false;\n+  bool saw_arg = false;\n   int brk_lvl = 0;\n   int num_args = 0;\n \n@@ -1224,7 +1222,7 @@ tokenize_arguments (char *str,\n \t  input_line_pointer++;\n \t  if (saw_comma || !saw_arg)\n \t    goto err;\n-\t  saw_comma = TRUE;\n+\t  saw_comma = true;\n \t  break;\n \n \tcase '}':\n@@ -1254,7 +1252,7 @@ tokenize_arguments (char *str,\n           if (!saw_arg || num_args == ntok)\n             goto err;\n           tok->X_op = O_colon;\n-          saw_arg = FALSE;\n+          saw_arg = false;\n           ++tok;\n           ++num_args;\n           break;\n@@ -1281,8 +1279,8 @@ tokenize_arguments (char *str,\n               || num_args == ntok)\n \t    goto err;\n \n-\t  saw_comma = FALSE;\n-\t  saw_arg = TRUE;\n+\t  saw_comma = false;\n+\t  saw_arg = true;\n \t  tok++;\n \t  num_args++;\n \t  break;\n@@ -1313,8 +1311,8 @@ tokenize_arguments (char *str,\n               || num_args == ntok)\n \t    goto err;\n \n-\t  saw_comma = FALSE;\n-\t  saw_arg = TRUE;\n+\t  saw_comma = false;\n+\t  saw_arg = true;\n \t  tok++;\n \t  num_args++;\n \t  break;\n@@ -1349,8 +1347,8 @@ tokenize_flags (const char *str,\n \t\tint nflg)\n {\n   char *old_input_line_pointer;\n-  bfd_boolean saw_flg = FALSE;\n-  bfd_boolean saw_dot = FALSE;\n+  bool saw_flg = false;\n+  bool saw_dot = false;\n   int num_flags  = 0;\n   size_t flgnamelen;\n \n@@ -1372,8 +1370,8 @@ tokenize_flags (const char *str,\n \t  input_line_pointer++;\n \t  if (saw_dot)\n \t    goto err;\n-\t  saw_dot = TRUE;\n-\t  saw_flg = FALSE;\n+\t  saw_dot = true;\n+\t  saw_flg = false;\n \t  break;\n \n \tdefault:\n@@ -1392,8 +1390,8 @@ tokenize_flags (const char *str,\n \n \t  input_line_pointer += flgnamelen;\n \t  flags++;\n-\t  saw_dot = FALSE;\n-\t  saw_flg = TRUE;\n+\t  saw_dot = false;\n+\t  saw_flg = true;\n \t  num_flags++;\n \t  break;\n \t}\n@@ -1479,7 +1477,7 @@ offset %d + %d\\n\",\n /* Actually output an instruction with its fixup.  */\n \n static void\n-emit_insn0 (struct arc_insn *insn, char *where, bfd_boolean relax)\n+emit_insn0 (struct arc_insn *insn, char *where, bool relax)\n {\n   char *f = where;\n   size_t total_len;\n@@ -1550,12 +1548,12 @@ emit_insn (struct arc_insn *insn)\n   if (insn->relax)\n     emit_insn1 (insn);\n   else\n-    emit_insn0 (insn, NULL, FALSE);\n+    emit_insn0 (insn, NULL, false);\n }\n \n /* Check whether a symbol involves a register.  */\n \n-static bfd_boolean\n+static bool\n contains_register (symbolS *sym)\n {\n   if (sym)\n@@ -1567,7 +1565,7 @@ contains_register (symbolS *sym)\n \t      && !contains_register (ex->X_op_symbol));\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Returns the register number within a symbol.  */\n@@ -1585,11 +1583,11 @@ get_register (symbolS *sym)\n /* Return true if a RELOC is generic.  A generic reloc is PC-rel of a\n    simple ME relocation (e.g. RELOC_ARC_32_ME, BFD_RELOC_ARC_PC32.  */\n \n-static bfd_boolean\n+static bool\n generic_reloc_p (extended_bfd_reloc_code_real_type reloc)\n {\n   if (!reloc)\n-    return FALSE;\n+    return false;\n \n   switch (reloc)\n     {\n@@ -1601,9 +1599,9 @@ generic_reloc_p (extended_bfd_reloc_code_real_type reloc)\n     case BFD_RELOC_ARC_SDA16_LD2:\n     case BFD_RELOC_ARC_SDA16_ST2:\n     case BFD_RELOC_ARC_SDA32_ME:\n-      return FALSE;\n+      return false;\n     default:\n-      return TRUE;\n+      return true;\n     }\n }\n \n@@ -1627,25 +1625,25 @@ allocate_tok (expressionS *tok, int ntok, int cidx)\n \n /* Check if an particular ARC feature is enabled.  */\n \n-static bfd_boolean\n+static bool\n check_cpu_feature (insn_subclass_t sc)\n {\n   if (is_code_density_p (sc) && !(selected_cpu.features & CD))\n-    return FALSE;\n+    return false;\n \n   if (is_spfp_p (sc) && !(selected_cpu.features & SPX))\n-    return FALSE;\n+    return false;\n \n   if (is_dpfp_p (sc) && !(selected_cpu.features & DPX))\n-    return FALSE;\n+    return false;\n \n   if (is_fpuda_p (sc) && !(selected_cpu.features & DPA))\n-    return FALSE;\n+    return false;\n \n   if (is_nps400_p (sc) && !(selected_cpu.features & NPS400))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Parse the flags described by FIRST_PFLAG and NFLGS against the flag\n@@ -1654,7 +1652,7 @@ check_cpu_feature (insn_subclass_t sc)\n    returns FALSE, in which case the FIRST_PFLAG array may have been\n    modified.  */\n \n-static bfd_boolean\n+static bool\n parse_opcode_flags (const struct arc_opcode *opcode,\n                     int nflgs,\n                     struct arc_flags *first_pflag)\n@@ -1692,7 +1690,7 @@ parse_opcode_flags (const struct arc_opcode *opcode,\n                   if (!strcmp (pf->name, pflag->name))\n                     {\n                       if (pflag->flgp != NULL)\n-                        return FALSE;\n+                        return false;\n                       /* Found it.  */\n                       cl_matches++;\n                       pflag->flgp = pf;\n@@ -1716,7 +1714,7 @@ parse_opcode_flags (const struct arc_opcode *opcode,\n               if (!strcmp (flg_operand->name, pflag->name))\n                 {\n                   if (pflag->flgp != NULL)\n-                    return FALSE;\n+                    return false;\n                   cl_matches++;\n                   pflag->flgp = flg_operand;\n                   lnflg--;\n@@ -1726,9 +1724,9 @@ parse_opcode_flags (const struct arc_opcode *opcode,\n         }\n \n       if ((cl_flags->flag_class & F_CLASS_REQUIRED) && cl_matches == 0)\n-        return FALSE;\n+        return false;\n       if ((cl_flags->flag_class & F_CLASS_OPTIONAL) && cl_matches > 1)\n-        return FALSE;\n+        return false;\n     }\n \n   /* Did I check all the parsed flags?  */\n@@ -2131,15 +2129,15 @@ swap_operand (expressionS *operand_array,\n /* Check if *op matches *tok type.\n    Returns FALSE if they don't match, TRUE if they match.  */\n \n-static bfd_boolean\n+static bool\n pseudo_operand_match (const expressionS *tok,\n \t\t      const struct arc_operand_operation *op)\n {\n   offsetT min, max, val;\n-  bfd_boolean ret;\n+  bool ret;\n   const struct arc_operand *operand_real = &arc_operands[op->operand_idx];\n \n-  ret = FALSE;\n+  ret = false;\n   switch (tok->X_op)\n     {\n     case O_constant:\n@@ -2159,7 +2157,7 @@ pseudo_operand_match (const expressionS *tok,\n \t      min = 0;\n \t    }\n \t  if (min <= val && val <= max)\n-\t    ret = TRUE;\n+\t    ret = true;\n \t}\n       break;\n \n@@ -2168,17 +2166,17 @@ pseudo_operand_match (const expressionS *tok,\n       if (operand_real->flags & ARC_OPERAND_LIMM\n \t  || ((operand_real->flags & ARC_OPERAND_SIGNED)\n \t      && operand_real->bits == 9))\n-\tret = TRUE;\n+\tret = true;\n       break;\n \n     case O_register:\n       if (operand_real->flags & ARC_OPERAND_IR)\n-\tret = TRUE;\n+\tret = true;\n       break;\n \n     case O_bracket:\n       if (operand_real->flags & ARC_OPERAND_BRAKET)\n-\tret = TRUE;\n+\tret = true;\n       break;\n \n     default:\n@@ -2433,7 +2431,7 @@ autodetect_attributes (const struct arc_opcode *opcode,\n \tcase O_register:\n \t  if ((tok[i].X_add_number >= 4 && tok[i].X_add_number <= 9)\n \t      || (tok[i].X_add_number >= 16 && tok[i].X_add_number <= 25))\n-\t    rf16_only = FALSE;\n+\t    rf16_only = false;\n \t  break;\n \tdefault:\n \t  break;\n@@ -2451,7 +2449,7 @@ assemble_tokens (const char *opname,\n \t\t struct arc_flags *pflags,\n \t\t int nflgs)\n {\n-  bfd_boolean found_something = FALSE;\n+  bool found_something = false;\n   const struct arc_opcode_hash_entry *entry;\n   int cpumatch = 1;\n   const char *errmsg = NULL;\n@@ -2469,7 +2467,7 @@ assemble_tokens (const char *opname,\n \n       pr_debug (\"%s:%d: assemble_tokens: %s\\n\",\n \t\tfrag_now->fr_file, frag_now->fr_line, opname);\n-      found_something = TRUE;\n+      found_something = true;\n       opcode = find_opcode_match (entry, tok, &ntok, pflags,\n \t\t\t\t  nflgs, &cpumatch, &errmsg);\n       if (opcode != NULL)\n@@ -2514,7 +2512,7 @@ md_assemble (char *str)\n   opname = xmemdup0 (str, opnamelen);\n \n   /* Signalize we are assembling the instructions.  */\n-  assembling_insn = TRUE;\n+  assembling_insn = true;\n \n   /* Tokenize the flags.  */\n   if ((nflg = tokenize_flags (str + opnamelen, flags, MAX_INSN_FLGS)) == -1)\n@@ -2539,7 +2537,7 @@ md_assemble (char *str)\n \n   /* Finish it off.  */\n   assemble_tokens (opname, tok, ntok, flags, nflg);\n-  assembling_insn = FALSE;\n+  assembling_insn = false;\n }\n \n /* Callback to insert a register into the hash table.  */\n@@ -2957,19 +2955,19 @@ md_apply_fix (fixS *fixP,\n \t  value += S_GET_VALUE (fx_addsy);\n \t  value -= md_pcrel_from_section (fixP, seg);\n \t  fx_addsy = NULL;\n-\t  fixP->fx_pcrel = FALSE;\n+\t  fixP->fx_pcrel = false;\n \t}\n       else if (add_symbol_segment == absolute_section)\n \t{\n \t  value = fixP->fx_offset;\n \t  fx_offset += S_GET_VALUE (fixP->fx_addsy);\n \t  fx_addsy = NULL;\n-\t  fixP->fx_pcrel = FALSE;\n+\t  fixP->fx_pcrel = false;\n \t}\n     }\n \n   if (!fx_addsy)\n-    fixP->fx_done = TRUE;\n+    fixP->fx_done = true;\n \n   if (fixP->fx_pcrel)\n     {\n@@ -3316,7 +3314,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,\n \n   size = insn.len + (insn.has_limm ? 4 : 0);\n   gas_assert (table_entry->rlx_length == size);\n-  emit_insn0 (&insn, dest, TRUE);\n+  emit_insn0 (&insn, dest, true);\n \n   fragP->fr_fix += table_entry->rlx_length;\n   fragP->fr_var = 0;\n@@ -3383,36 +3381,36 @@ md_operand (expressionS *expressionP)\n    the expression with the identified register.  It returns TRUE if\n    it is a register and FALSE otherwise.  */\n \n-bfd_boolean\n+bool\n arc_parse_name (const char *name,\n \t\tstruct expressionS *e)\n {\n   struct symbol *sym;\n \n   if (!assembling_insn)\n-    return FALSE;\n+    return false;\n \n   if (e->X_op == O_symbol\n       && e->X_md == O_absent)\n-    return FALSE;\n+    return false;\n \n   sym = str_hash_find (arc_reg_hash, name);\n   if (sym)\n     {\n       e->X_op = O_register;\n       e->X_add_number = S_GET_VALUE (sym);\n-      return TRUE;\n+      return true;\n     }\n \n   sym = str_hash_find (arc_addrtype_hash, name);\n   if (sym)\n     {\n       e->X_op = O_addrtype;\n       e->X_add_number = S_GET_VALUE (sym);\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* md_parse_option\n@@ -3539,7 +3537,7 @@ arc_show_cpu_list (FILE *stream)\n   offset = strlen (space_buf);\n   for (i = 0; cpu_types[i].name != NULL; ++i)\n     {\n-      bfd_boolean last = (cpu_types[i + 1].name == NULL);\n+      bool last = (cpu_types[i + 1].name == NULL);\n \n       /* If displaying the new cpu name string, and the ', ' (for all\n          but the last one) will take us past a target width of 80\n@@ -3628,7 +3626,7 @@ find_reloc (const char *name,\n {\n   unsigned int i;\n   int j;\n-  bfd_boolean found_flag, tmp;\n+  bool found_flag, tmp;\n   extended_bfd_reloc_code_real_type ret = BFD_RELOC_UNUSED;\n \n   for (i = 0; i < arc_num_equiv_tab; i++)\n@@ -3644,26 +3642,26 @@ find_reloc (const char *name,\n \t{\n \t  if (!nflg)\n \t    continue;\n-\t  found_flag = FALSE;\n+\t  found_flag = false;\n \t  unsigned * psflg = (unsigned *)r->flags;\n \t  do\n \t    {\n-\t      tmp = FALSE;\n+\t      tmp = false;\n \t      for (j = 0; j < nflg; j++)\n \t\tif (!strcmp (pflags[j].name,\n \t\t\t     arc_flag_operands[*psflg].name))\n \t\t  {\n-\t\t    tmp = TRUE;\n+\t\t    tmp = true;\n \t\t    break;\n \t\t  }\n \t      if (!tmp)\n \t\t{\n-\t\t  found_flag = FALSE;\n+\t\t  found_flag = false;\n \t\t  break;\n \t\t}\n \t      else\n \t\t{\n-\t\t  found_flag = TRUE;\n+\t\t  found_flag = true;\n \t\t}\n \t      ++ psflg;\n \t    } while (*psflg);\n@@ -3688,7 +3686,7 @@ find_reloc (const char *name,\n /* All the symbol types that are allowed to be used for\n    relaxation.  */\n \n-static bfd_boolean\n+static bool\n may_relax_expr (expressionS tok)\n {\n   /* Check if we have unrelaxable relocs.  */\n@@ -3697,7 +3695,7 @@ may_relax_expr (expressionS tok)\n     default:\n       break;\n     case O_plt:\n-      return FALSE;\n+      return false;\n     }\n \n   switch (tok.X_op)\n@@ -3711,14 +3709,14 @@ may_relax_expr (expressionS tok)\n       break;\n \n     default:\n-      return FALSE;\n+      return false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Checks if flags are in line with relaxable insn.  */\n \n-static bfd_boolean\n+static bool\n relaxable_flag (const struct arc_relaxable_ins *ins,\n \t\tconst struct arc_flags *pflags,\n \t\tint nflgs)\n@@ -3759,7 +3757,7 @@ relaxable_flag (const struct arc_relaxable_ins *ins,\n \n /* Checks if operands are in line with relaxable insn.  */\n \n-static bfd_boolean\n+static bool\n relaxable_operand (const struct arc_relaxable_ins *ins,\n \t\t   const expressionS *tok,\n \t\t   int ntok)\n@@ -3772,7 +3770,7 @@ relaxable_operand (const struct arc_relaxable_ins *ins,\n       const expressionS *epr = &tok[i];\n \n       if (i != 0 && i >= ntok)\n-\treturn FALSE;\n+\treturn false;\n \n       switch (*operand)\n \t{\n@@ -3783,47 +3781,47 @@ relaxable_operand (const struct arc_relaxable_ins *ins,\n \t\t|| epr->X_op == O_add\n \t\t|| epr->X_op == O_subtract\n \t\t|| epr->X_op == O_symbol))\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \n \tcase REGISTER_DUP:\n \t  if ((i <= 0)\n \t      || (epr->X_add_number != tok[i - 1].X_add_number))\n-\t    return FALSE;\n+\t    return false;\n \t  /* Fall through.  */\n \tcase REGISTER:\n \t  if (epr->X_op != O_register)\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \n \tcase REGISTER_S:\n \t  if (epr->X_op != O_register)\n-\t    return FALSE;\n+\t    return false;\n \n \t  switch (epr->X_add_number)\n \t    {\n \t    case 0: case 1: case 2: case 3:\n \t    case 12: case 13: case 14: case 15:\n \t      break;\n \t    default:\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  break;\n \n \tcase REGISTER_NO_GP:\n \t  if ((epr->X_op != O_register)\n \t      || (epr->X_add_number == 26)) /* 26 is the gp register.  */\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \n \tcase BRACKET:\n \t  if (epr->X_op != O_bracket)\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \n \tdefault:\n \t  /* Don't understand, bail out.  */\n-\t  return FALSE;\n+\t  return false;\n \t  break;\n \t}\n \n@@ -3836,15 +3834,15 @@ relaxable_operand (const struct arc_relaxable_ins *ins,\n \n /* Return TRUE if this OPDCODE is a candidate for relaxation.  */\n \n-static bfd_boolean\n+static bool\n relax_insn_p (const struct arc_opcode *opcode,\n \t      const expressionS *tok,\n \t      int ntok,\n \t      const struct arc_flags *pflags,\n \t      int nflg)\n {\n   unsigned i;\n-  bfd_boolean rv = FALSE;\n+  bool rv = false;\n \n   /* Check the relaxation table.  */\n   for (i = 0; i < arc_num_relaxable_ins && relaxation_state; ++i)\n@@ -3856,7 +3854,7 @@ relax_insn_p (const struct arc_opcode *opcode,\n \t  && relaxable_operand (arc_rlx_ins, tok, ntok)\n \t  && relaxable_flag (arc_rlx_ins, pflags, nflg))\n \t{\n-\t  rv = TRUE;\n+\t  rv = true;\n \t  frag_now->fr_subtype = arc_relaxable_insns[i].subtype;\n \t  memcpy (&frag_now->tc_frag_data.tok, tok,\n \t\tsizeof (expressionS) * ntok);\n@@ -3888,8 +3886,8 @@ assemble_insn (const struct arc_opcode *opcode,\n   int i;\n   int tokidx = 0;\n   unsigned char pcrel = 0;\n-  bfd_boolean needGOTSymbol;\n-  bfd_boolean has_delay_slot = FALSE;\n+  bool needGOTSymbol;\n+  bool has_delay_slot = false;\n   extended_bfd_reloc_code_real_type reloc = BFD_RELOC_UNUSED;\n \n   memset (insn, 0, sizeof (*insn));\n@@ -3925,7 +3923,7 @@ assemble_insn (const struct arc_opcode *opcode,\n       /* Regardless if we have a reloc or not mark the instruction\n \t limm if it is the case.  */\n       if (operand->flags & ARC_OPERAND_LIMM)\n-\tinsn->has_limm = TRUE;\n+\tinsn->has_limm = true;\n \n       switch (t->X_op)\n \t{\n@@ -3969,23 +3967,23 @@ assemble_insn (const struct arc_opcode *opcode,\n \n \tdefault:\n \t  /* This operand needs a relocation.  */\n-\t  needGOTSymbol = FALSE;\n+\t  needGOTSymbol = false;\n \n \t  switch (t->X_md)\n \t    {\n \t    case O_plt:\n \t      if (opcode->insn_class == JUMP)\n \t\tas_bad (_(\"Unable to use @plt relocation for insn %s\"),\n \t\t\topcode->name);\n-\t      needGOTSymbol = TRUE;\n+\t      needGOTSymbol = true;\n \t      reloc = find_reloc (\"plt\", opcode->name,\n \t\t\t\t  pflags, nflg,\n \t\t\t\t  operand->default_reloc);\n \t      break;\n \n \t    case O_gotoff:\n \t    case O_gotpc:\n-\t      needGOTSymbol = TRUE;\n+\t      needGOTSymbol = true;\n \t      reloc = ARC_RELOC_TABLE (t->X_md)->reloc;\n \t      break;\n \t    case O_pcl:\n@@ -4012,7 +4010,7 @@ assemble_insn (const struct arc_opcode *opcode,\n \t      break;\n \t    case O_tlsgd:\n \t    case O_tlsie:\n-\t      needGOTSymbol = TRUE;\n+\t      needGOTSymbol = true;\n \t      /* Fall-through.  */\n \n \t    case O_tpoff:\n@@ -4085,7 +4083,7 @@ assemble_insn (const struct arc_opcode *opcode,\n \n       /* Check if the instruction has a delay slot.  */\n       if (!strcmp (flg_operand->name, \"d\"))\n-\thas_delay_slot = TRUE;\n+\thas_delay_slot = true;\n \n       /* There is an exceptional case when we cannot insert a flag just as\n \t it is.  On ARCv2 the '.t' and '.nt' flags must be handled in\n@@ -4136,7 +4134,7 @@ assemble_insn (const struct arc_opcode *opcode,\n \t      fixup->exp = *reloc_exp;\n \t      fixup->reloc = -bitYoperand;\n \t      fixup->pcrel = pcrel;\n-\t      fixup->islong = FALSE;\n+\t      fixup->islong = false;\n \t    }\n \t}\n       else\n@@ -4666,16 +4664,16 @@ arc_extinsn (int ignore ATTRIBUTE_UNUSED)\n   create_extinst_section (&einsn);\n }\n \n-static bfd_boolean\n+static bool\n tokenize_extregister (extRegister_t *ereg, int opertype)\n {\n   char *name;\n   char *mode;\n   char c;\n   char *p;\n   int number, imode = 0;\n-  bfd_boolean isCore_p = opertype == EXT_CORE_REGISTER;\n-  bfd_boolean isReg_p = opertype == EXT_CORE_REGISTER || opertype == EXT_AUX_REGISTER;\n+  bool isCore_p = opertype == EXT_CORE_REGISTER;\n+  bool isReg_p = opertype == EXT_CORE_REGISTER || opertype == EXT_AUX_REGISTER;\n \n   /* 1st: get register name.  */\n   SKIP_WHITESPACE ();\n@@ -4693,7 +4691,7 @@ tokenize_extregister (extRegister_t *ereg, int opertype)\n       as_bad (_(\"expected comma after name\"));\n       ignore_rest_of_line ();\n       free (name);\n-      return FALSE;\n+      return false;\n     }\n   input_line_pointer++;\n   number = get_absolute_expression ();\n@@ -4706,7 +4704,7 @@ tokenize_extregister (extRegister_t *ereg, int opertype)\n \t      number);\n       ignore_rest_of_line ();\n       free (name);\n-      return FALSE;\n+      return false;\n     }\n \n   if (isReg_p)\n@@ -4719,7 +4717,7 @@ tokenize_extregister (extRegister_t *ereg, int opertype)\n \t  as_bad (_(\"expected comma after register number\"));\n \t  ignore_rest_of_line ();\n \t  free (name);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       input_line_pointer++;\n@@ -4740,7 +4738,7 @@ tokenize_extregister (extRegister_t *ereg, int opertype)\n \t  as_bad (_(\"invalid mode\"));\n \t  ignore_rest_of_line ();\n \t  free (name);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       else\n \t{\n@@ -4758,7 +4756,7 @@ tokenize_extregister (extRegister_t *ereg, int opertype)\n \t  as_bad (_(\"expected comma after register mode\"));\n \t  ignore_rest_of_line ();\n \t  free (name);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       input_line_pointer++;\n@@ -4773,7 +4771,7 @@ tokenize_extregister (extRegister_t *ereg, int opertype)\n \t  as_bad (_(\"shortcut designator invalid\"));\n \t  ignore_rest_of_line ();\n \t  free (name);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       else\n \t{\n@@ -4785,7 +4783,7 @@ tokenize_extregister (extRegister_t *ereg, int opertype)\n   ereg->name = name;\n   ereg->number = number;\n   ereg->imode  = imode;\n-  return TRUE;\n+  return true;\n }\n \n /* Create an extension register/condition description in the arc\n@@ -4916,7 +4914,7 @@ arc_attribute (int ignored ATTRIBUTE_UNUSED)\n   int tag = obj_elf_vendor_attribute (OBJ_ATTR_PROC);\n \n   if (tag < NUM_KNOWN_OBJ_ATTRIBUTES)\n-    attributes_set_explicitly[tag] = TRUE;\n+    attributes_set_explicitly[tag] = true;\n }\n \n /* Set an attribute if it has not already been set by the user.  */"
    },
    {
      "sha": "15dac8e3d7b0fbc2f2f85f4b10b356762c3c5e9a",
      "filename": "gas/config/tc-arc.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-arc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-arc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arc.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -202,7 +202,7 @@ extern int arc_convert_symbolic_attribute (const char *);\n extern void arc_md_end (void);\n extern void arc_adjust_symtab (void);\n extern int arc_pcrel_adjust (fragS *);\n-extern bfd_boolean arc_parse_name (const char *, struct expressionS *);\n+extern bool arc_parse_name (const char *, struct expressionS *);\n extern int tc_arc_fix_adjustable (struct fix *);\n extern void arc_handle_align (fragS *);\n extern void arc_cons_fix_new (fragS *, int, int, expressionS *,"
    },
    {
      "sha": "ed5e9d92ae4d62f5d4b1342dada4920841bc982e",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 428,
      "deletions": 428,
      "changes": 856,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "dfa7f4a20cd3f28cfbe715cee0e39f31ecf81fb7",
      "filename": "gas/config/tc-arm.h",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-arm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-arm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -67,7 +67,7 @@ struct fix;\n \n /* We conditionally support labels without a colon.  */\n #define LABELS_WITHOUT_COLONS codecomposer_syntax\n-extern bfd_boolean codecomposer_syntax;\n+extern bool codecomposer_syntax;\n \n #define tc_symbol_chars arm_symbol_chars\n extern const char arm_symbol_chars[];\n@@ -82,15 +82,15 @@ extern unsigned int arm_frag_max_var (struct frag *);\n extern int arm_relax_frag (asection *, struct frag *, long);\n \n #define md_optimize_expr(l,o,r)\t\tarm_optimize_expr (l, o, r)\n-extern bfd_boolean arm_optimize_expr (expressionS *, operatorT, expressionS *);\n+extern bool arm_optimize_expr (expressionS *, operatorT, expressionS *);\n \n #define md_cleanup() arm_cleanup ()\n \n #define md_start_line_hook() arm_start_line_hook ()\n \n #define TC_START_LABEL_WITHOUT_COLON(NUL_CHAR, NEXT_CHAR) \\\n   tc_start_label_without_colon ()\n-extern bfd_boolean tc_start_label_without_colon (void);\n+extern bool tc_start_label_without_colon (void);\n \n #define tc_frob_label(S) arm_frob_label (S)\n \n@@ -100,7 +100,7 @@ extern bfd_boolean tc_start_label_without_colon (void);\n #ifdef OBJ_ELF\n #define md_end arm_md_end\n extern void arm_md_end (void);\n-bfd_boolean arm_is_eabi (void);\n+bool arm_is_eabi (void);\n \n #define md_post_relax_hook\t\tarm_md_post_relax ()\n extern void arm_md_post_relax (void);\n@@ -348,15 +348,15 @@ extern int arm_force_relocation (struct fix *);\n extern void arm_cleanup (void);\n extern void arm_start_line_hook (void);\n extern void arm_frob_label (symbolS *);\n-extern bfd_boolean arm_data_in_code (void);\n+extern bool arm_data_in_code (void);\n extern char * arm_canonicalize_symbol_name (char *);\n extern void arm_adjust_symtab (void);\n extern void armelf_frob_symbol (symbolS *, int *);\n extern void cons_fix_new_arm (fragS *, int, int, expressionS *,\n \t\t\t      bfd_reloc_code_real_type);\n extern void arm_init_frag (struct frag *, int);\n extern void arm_handle_align (struct frag *);\n-extern bfd_boolean arm_fix_adjustable (struct fix *);\n+extern bool arm_fix_adjustable (struct fix *);\n extern int arm_elf_section_type (const char *, size_t);\n extern int tc_arm_regname_to_dw2regnum (char *regname);\n extern void tc_arm_frame_initial_instructions (void);\n@@ -383,7 +383,7 @@ extern char arm_comment_chars[];\n extern char arm_line_separator_chars[];\n \n #define TC_EQUAL_IN_INSN(c, s) arm_tc_equal_in_insn ((c), (s))\n-extern bfd_boolean arm_tc_equal_in_insn (int, char *);\n+extern bool arm_tc_equal_in_insn (int, char *);\n \n #define TC_LARGEST_EXPONENT_IS_NORMAL(PRECISION) \\\n \tarm_is_largest_exponent_ok ((PRECISION))"
    },
    {
      "sha": "7d6bfdea038d3e762a8f669aa9619157a77e4bae",
      "filename": "gas/config/tc-avr.c",
      "status": "modified",
      "additions": 32,
      "deletions": 32,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-avr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-avr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-avr.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -37,12 +37,12 @@ struct avr_property_record_link\n \n struct avr_opcodes_s\n {\n-  const char *        name;\n-  const char *        constraints;\n-  const char *        opcode;\n-  int           insn_size;\t\t/* In words.  */\n-  int           isa;\n-  unsigned int  bin_opcode;\n+  const char *name;\n+  const char *constraints;\n+  const char *opcode;\n+  int insn_size;\t\t/* In words.  */\n+  int isa;\n+  unsigned int bin_opcode;\n };\n \n #define AVR_INSN(NAME, CONSTR, OPCODE, SIZE, ISA, BIN) \\\n@@ -791,7 +791,7 @@ avr_undefined_symbol (char *name)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \n void\n@@ -1206,39 +1206,39 @@ avr_operand (struct avr_opcodes_s *opcode,\n \t    avr_offset_expression (& op_expr);\n \t    str = input_line_pointer;\n \t    fix_new_exp (frag_now, where, 3,\n-\t\t\t &op_expr, FALSE, BFD_RELOC_AVR_6);\n+\t\t\t &op_expr, false, BFD_RELOC_AVR_6);\n \t  }\n       }\n       break;\n \n     case 'h':\n       str = parse_exp (str, &op_expr);\n       fix_new_exp (frag_now, where, opcode->insn_size * 2,\n-\t\t   &op_expr, FALSE, BFD_RELOC_AVR_CALL);\n+\t\t   &op_expr, false, BFD_RELOC_AVR_CALL);\n       break;\n \n     case 'L':\n       str = parse_exp (str, &op_expr);\n       fix_new_exp (frag_now, where, opcode->insn_size * 2,\n-\t\t   &op_expr, TRUE, BFD_RELOC_AVR_13_PCREL);\n+\t\t   &op_expr, true, BFD_RELOC_AVR_13_PCREL);\n       break;\n \n     case 'l':\n       str = parse_exp (str, &op_expr);\n       fix_new_exp (frag_now, where, opcode->insn_size * 2,\n-\t\t   &op_expr, TRUE, BFD_RELOC_AVR_7_PCREL);\n+\t\t   &op_expr, true, BFD_RELOC_AVR_7_PCREL);\n       break;\n \n     case 'i':\n       str = parse_exp (str, &op_expr);\n       fix_new_exp (frag_now, where + 2, opcode->insn_size * 2,\n-\t\t   &op_expr, FALSE, BFD_RELOC_16);\n+\t\t   &op_expr, false, BFD_RELOC_16);\n       break;\n \n     case 'j':\n       str = parse_exp (str, &op_expr);\n       fix_new_exp (frag_now, where, opcode->insn_size * 2,\n-\t\t   &op_expr, FALSE, BFD_RELOC_AVR_LDS_STS_16);\n+\t\t   &op_expr, false, BFD_RELOC_AVR_LDS_STS_16);\n       break;\n \n     case 'M':\n@@ -1249,7 +1249,7 @@ avr_operand (struct avr_opcodes_s *opcode,\n \tr_type = avr_ldi_expression (&op_expr);\n \tstr = input_line_pointer;\n \tfix_new_exp (frag_now, where, 3,\n-\t\t     &op_expr, FALSE, r_type);\n+\t\t     &op_expr, false, r_type);\n       }\n       break;\n \n@@ -1278,7 +1278,7 @@ avr_operand (struct avr_opcodes_s *opcode,\n       avr_offset_expression (& op_expr);\n       str = input_line_pointer;\n       fix_new_exp (frag_now, where, 3,\n-\t\t   & op_expr, FALSE, BFD_RELOC_AVR_6_ADIW);\n+\t\t   & op_expr, false, BFD_RELOC_AVR_6_ADIW);\n       break;\n \n     case 'S':\n@@ -1297,13 +1297,13 @@ avr_operand (struct avr_opcodes_s *opcode,\n     case 'P':\n       str = parse_exp (str, &op_expr);\n       fix_new_exp (frag_now, where, opcode->insn_size * 2,\n-\t\t     &op_expr, FALSE, BFD_RELOC_AVR_PORT6);\n+\t\t     &op_expr, false, BFD_RELOC_AVR_PORT6);\n       break;\n \n     case 'p':\n       str = parse_exp (str, &op_expr);\n       fix_new_exp (frag_now, where, opcode->insn_size * 2,\n-\t\t     &op_expr, FALSE, BFD_RELOC_AVR_PORT5);\n+\t\t     &op_expr, false, BFD_RELOC_AVR_PORT5);\n       break;\n \n     case 'E':\n@@ -1452,7 +1452,7 @@ md_pcrel_from_section (fixS *fixp, segT sec)\n   return fixp->fx_frag->fr_address + fixp->fx_where;\n }\n \n-static bfd_boolean\n+static bool\n relaxable_section (asection *sec)\n {\n   return ((sec->flags & SEC_DEBUGGING) == 0\n@@ -2020,11 +2020,11 @@ avr_cons_fix_new (fragS *frag,\n     {\n     default:\n       if (nbytes == 1)\n-\tfix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_8);\n+\tfix_new_exp (frag, where, nbytes, exp, false, BFD_RELOC_8);\n       else if (nbytes == 2)\n-\tfix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_16);\n+\tfix_new_exp (frag, where, nbytes, exp, false, BFD_RELOC_16);\n       else if (nbytes == 4)\n-\tfix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_32);\n+\tfix_new_exp (frag, where, nbytes, exp, false, BFD_RELOC_32);\n       else\n \tbad = 1;\n       break;\n@@ -2034,7 +2034,7 @@ avr_cons_fix_new (fragS *frag,\n     case BFD_RELOC_AVR_8_HI:\n     case BFD_RELOC_AVR_8_HLO:\n       if (nbytes == pexp_mod_data->nbytes)\n-        fix_new_exp (frag, where, nbytes, exp, FALSE, pexp_mod_data->reloc);\n+        fix_new_exp (frag, where, nbytes, exp, false, pexp_mod_data->reloc);\n       else\n         bad = 1;\n       break;\n@@ -2044,7 +2044,7 @@ avr_cons_fix_new (fragS *frag,\n     as_bad (_(\"illegal %s relocation size: %d\"), pexp_mod_data->error, nbytes);\n }\n \n-static bfd_boolean\n+static bool\n mcu_has_3_byte_pc (void)\n {\n   int mach = avr_mcu->mach;\n@@ -2069,26 +2069,26 @@ tc_cfi_frame_initial_instructions (void)\n   cfi_add_CFA_offset (DWARF2_DEFAULT_RETURN_COLUMN, 1-return_size);\n }\n \n-bfd_boolean\n+bool\n avr_allow_local_subtract (expressionS * left,\n \t\t\t     expressionS * right,\n \t\t\t     segT section)\n {\n   /* If we are not in relaxation mode, subtraction is OK.  */\n   if (!linkrelax)\n-    return TRUE;\n+    return true;\n \n   /* If the symbols are not in a code section then they are OK.  */\n   if ((section->flags & SEC_CODE) == 0)\n-    return TRUE;\n+    return true;\n \n   if (left->X_add_symbol == right->X_add_symbol)\n-    return TRUE;\n+    return true;\n \n   /* We have to assume that there may be instructions between the\n      two symbols and that relaxation may increase the distance between\n      them.  */\n-  return FALSE;\n+  return false;\n }\n \n void\n@@ -2178,7 +2178,7 @@ avr_output_property_record (char * const frag_base, char *frag_ptr,\n   where = frag_ptr - frag_base;\n   fix = fix_new (frag_now, where, 4,\n                  section_symbol (record->section),\n-                 record->offset, FALSE, BFD_RELOC_32);\n+                 record->offset, false, BFD_RELOC_32);\n   fix->fx_file = \"<internal>\";\n   fix->fx_line = 0;\n   frag_ptr += 4;\n@@ -2253,7 +2253,7 @@ avr_handle_align (fragS *fragP)\n         {\n           char *p = fragP->fr_literal + fragP->fr_fix;\n \n-          fragP->tc_frag_data.is_align = TRUE;\n+          fragP->tc_frag_data.is_align = true;\n           fragP->tc_frag_data.alignment = fragP->fr_offset;\n           fragP->tc_frag_data.fill = *p;\n           fragP->tc_frag_data.has_fill = (fragP->tc_frag_data.fill != 0);\n@@ -2263,7 +2263,7 @@ avr_handle_align (fragS *fragP)\n         {\n           char *p = fragP->fr_literal + fragP->fr_fix;\n \n-          fragP->tc_frag_data.is_org = TRUE;\n+          fragP->tc_frag_data.is_org = true;\n           fragP->tc_frag_data.fill = *p;\n           fragP->tc_frag_data.has_fill = (fragP->tc_frag_data.fill != 0);\n         }\n@@ -2273,7 +2273,7 @@ avr_handle_align (fragS *fragP)\n /* Return TRUE if this section is not one for which we need to record\n    information in the avr property section.  */\n \n-static bfd_boolean\n+static bool\n exclude_section_from_property_tables (segT sec)\n {\n   /* Only generate property information for sections on which linker"
    },
    {
      "sha": "0f85099abf71b5b54a46b14d5f19a6d1c526472c",
      "filename": "gas/config/tc-avr.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-avr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-avr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-avr.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -214,7 +214,7 @@ extern void tc_cfi_frame_initial_instructions (void);\n /* The difference between same-section symbols may be affected by linker\n    relaxation, so do not resolve such expressions in the assembler.  */\n #define md_allow_local_subtract(l,r,s) avr_allow_local_subtract (l, r, s)\n-extern bfd_boolean avr_allow_local_subtract (expressionS *, expressionS *, segT);\n+extern bool avr_allow_local_subtract (expressionS *, expressionS *, segT);\n \n #define elf_tc_final_processing \tavr_elf_final_processing\n extern void avr_elf_final_processing (void);"
    },
    {
      "sha": "5524dc8bd2c97e948124139012a49aae3d931770",
      "filename": "gas/config/tc-bfin.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-bfin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-bfin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-bfin.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -700,7 +700,7 @@ md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)\n \n     case BFD_RELOC_BFIN_16_LOW:\n     case BFD_RELOC_BFIN_16_HIGH:\n-      fixP->fx_done = FALSE;\n+      fixP->fx_done = false;\n       break;\n \n     case BFD_RELOC_BFIN_24_PCREL_JUMP_L:\n@@ -769,7 +769,7 @@ md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)\n     case BFD_RELOC_BFIN_FUNCDESC:\n     case BFD_RELOC_VTABLE_INHERIT:\n     case BFD_RELOC_VTABLE_ENTRY:\n-      fixP->fx_done = FALSE;\n+      fixP->fx_done = false;\n       break;\n \n     default:\n@@ -781,7 +781,7 @@ md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)\n     }\n \n   if (!fixP->fx_addsy)\n-    fixP->fx_done = TRUE;\n+    fixP->fx_done = true;\n \n }\n \n@@ -797,7 +797,7 @@ md_section_align (segT segment, valueT size)\n const char *\n md_atof (int type, char * litP, int * sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \n \n@@ -852,7 +852,7 @@ md_pcrel_from_section (fixS *fixP, segT sec)\n /* Return true if the fix can be handled by GAS, false if it must\n    be passed through to the linker.  */\n \n-bfd_boolean\n+bool\n bfin_fix_adjustable (fixS *fixP)\n {\n   switch (fixP->fx_r_type)\n@@ -1932,52 +1932,52 @@ bfin_loop_beginend (Expr_Node *exp, int begin)\n     *symbol_X_add_number (linelabel) -= last_insn_size;\n }\n \n-bfd_boolean\n+bool\n bfin_eol_in_insn (char *line)\n {\n    /* Allow a new-line to appear in the middle of a multi-issue instruction.  */\n \n    char *temp = line;\n \n   if (*line != '\\n')\n-    return FALSE;\n+    return false;\n \n   /* A semi-colon followed by a newline is always the end of a line.  */\n   if (line[-1] == ';')\n-    return FALSE;\n+    return false;\n \n   if (line[-1] == '|')\n-    return TRUE;\n+    return true;\n \n   /* If the || is on the next line, there might be leading whitespace.  */\n   temp++;\n   while (*temp == ' ' || *temp == '\\t') temp++;\n \n   if (*temp == '|')\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n bfin_start_label (char *s)\n {\n   while (*s != 0)\n     {\n       if (*s == '(' || *s == '[')\n-\treturn FALSE;\n+\treturn false;\n       s++;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n int\n bfin_force_relocation (struct fix *fixp)\n {\n   if (fixp->fx_r_type ==BFD_RELOC_BFIN_16_LOW\n       || fixp->fx_r_type == BFD_RELOC_BFIN_16_HIGH)\n-    return TRUE;\n+    return true;\n \n   return generic_force_reloc (fixp);\n }"
    },
    {
      "sha": "3a72436ffd627494fc3ac19dafd767af1f91872f",
      "filename": "gas/config/tc-bfin.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-bfin.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-bfin.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-bfin.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -38,7 +38,7 @@\n \n #define WORKING_DOT_WORD\n \n-extern bfd_boolean bfin_start_label (char *);\n+extern bool bfin_start_label (char *);\n \n #define md_number_to_chars\tnumber_to_chars_littleendian\n #define md_convert_frag(b,s,f)\tas_fatal (\"bfin convert_frag\\n\");\n@@ -47,7 +47,7 @@ extern bfd_boolean bfin_start_label (char *);\n #define LEX_BR 6\n \n #define TC_EOL_IN_INSN(PTR) (bfin_eol_in_insn(PTR) ? 1 : 0)\n-extern bfd_boolean bfin_eol_in_insn (char *);\n+extern bool bfin_eol_in_insn (char *);\n \n /* Almost all instructions of Blackfin contain an = character.  */\n #define TC_EQUAL_IN_INSN(C, NAME) (NAME[0] != '.' || NAME[1] != 0)\n@@ -61,7 +61,7 @@ extern bfd_boolean bfin_eol_in_insn (char *);\n #define TC_START_LABEL(STR, NUL_CHAR, NEXT_CHAR)\t\\\n   (NEXT_CHAR == ':' && bfin_start_label (STR))\n #define tc_fix_adjustable(FIX) bfin_fix_adjustable (FIX)\n-extern bfd_boolean bfin_fix_adjustable (struct fix *);\n+extern bool bfin_fix_adjustable (struct fix *);\n \n #define TC_FORCE_RELOCATION(FIX) bfin_force_relocation (FIX)\n extern int bfin_force_relocation (struct fix *);"
    },
    {
      "sha": "48a0ebc48c019b60f6dfe2eb2d77d2eed1a93701",
      "filename": "gas/config/tc-bpf.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-bpf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-bpf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-bpf.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -419,5 +419,5 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }"
    },
    {
      "sha": "94a32e3340deae8b5cb40d85cd8d3e002b52da13",
      "filename": "gas/config/tc-cris.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-cris.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-cris.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-cris.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -166,23 +166,23 @@ static htab_t op_hash = NULL;\n    we default to no underscore and required register-prefixes.  The\n    difference is in the default values.  */\n #ifdef TE_LINUX\n-#define DEFAULT_CRIS_AXIS_LINUX_GNU TRUE\n+#define DEFAULT_CRIS_AXIS_LINUX_GNU true\n #else\n-#define DEFAULT_CRIS_AXIS_LINUX_GNU FALSE\n+#define DEFAULT_CRIS_AXIS_LINUX_GNU false\n #endif\n \n /* Whether we demand that registers have a `$' prefix.  Default here.  */\n-static bfd_boolean demand_register_prefix = DEFAULT_CRIS_AXIS_LINUX_GNU;\n+static bool demand_register_prefix = DEFAULT_CRIS_AXIS_LINUX_GNU;\n \n /* Whether global user symbols have a leading underscore.  Default here.  */\n-static bfd_boolean symbols_have_leading_underscore\n+static bool symbols_have_leading_underscore\n   = !DEFAULT_CRIS_AXIS_LINUX_GNU;\n \n /* Whether or not we allow PIC, and expand to PIC-friendly constructs.  */\n-static bfd_boolean pic = FALSE;\n+static bool pic = false;\n \n /* Whether or not we allow TLS suffixes.  For the moment, we always do.  */\n-static const bfd_boolean tls = TRUE;\n+static const bool tls = true;\n \n /* If we're configured for \"cris\", default to allow all v0..v10\n    instructions and register names.  */\n@@ -3491,14 +3491,14 @@ cris_get_reloc_suffix (char **cPP, bfd_reloc_code_real_type *relocp,\n     const char *const suffix;\n     unsigned int len;\n     bfd_reloc_code_real_type reloc;\n-    bfd_boolean pic_p;\n-    bfd_boolean tls_p;\n+    bool pic_p;\n+    bool tls_p;\n   } pic_suffixes[] =\n     {\n #undef PICMAP\n-#define PICMAP(s, r) {s, sizeof (s) - 1, r, TRUE, FALSE}\n-#define PICTLSMAP(s, r) {s, sizeof (s) - 1, r, TRUE, TRUE}\n-#define TLSMAP(s, r) {s, sizeof (s) - 1, r, FALSE, TRUE}\n+#define PICMAP(s, r) {s, sizeof (s) - 1, r, true, false}\n+#define PICTLSMAP(s, r) {s, sizeof (s) - 1, r, true, true}\n+#define TLSMAP(s, r) {s, sizeof (s) - 1, r, false, true}\n       /* Keep this in order with longest unambiguous prefix first.  */\n       PICMAP (\"GOTPLT16\", BFD_RELOC_CRIS_16_GOTPLT),\n       PICMAP (\"GOTPLT\", BFD_RELOC_CRIS_32_GOTPLT),\n@@ -3811,23 +3811,23 @@ md_parse_option (int arg, const char *argp ATTRIBUTE_UNUSED)\n       break;\n \n     case OPTION_NO_US:\n-      demand_register_prefix = TRUE;\n+      demand_register_prefix = true;\n \n       if (OUTPUT_FLAVOR == bfd_target_aout_flavour)\n \tas_bad (_(\"--no-underscore is invalid with a.out format\"));\n       else\n-\tsymbols_have_leading_underscore = FALSE;\n+\tsymbols_have_leading_underscore = false;\n       break;\n \n     case OPTION_US:\n-      demand_register_prefix = FALSE;\n-      symbols_have_leading_underscore = TRUE;\n+      demand_register_prefix = false;\n+      symbols_have_leading_underscore = true;\n       break;\n \n     case OPTION_PIC:\n       if (OUTPUT_FLAVOR != bfd_target_elf_flavour)\n \tas_bad (_(\"--pic is invalid for this object format\"));\n-      pic = TRUE;\n+      pic = true;\n       if (cris_arch != arch_crisv32)\n \tmd_long_jump_size = cris_any_v0_v10_long_jump_size_pic;\n       else\n@@ -4133,15 +4133,15 @@ tc_cris_check_adjusted_broken_word (offsetT new_offset, struct broken_word *brok\n static void\n cris_force_reg_prefix (void)\n {\n-  demand_register_prefix = TRUE;\n+  demand_register_prefix = true;\n }\n \n /* Do not demand a leading REGISTER_PREFIX_CHAR for all registers.  */\n \n static void\n cris_relax_reg_prefix (void)\n {\n-  demand_register_prefix = FALSE;\n+  demand_register_prefix = false;\n }\n \n /* Adjust for having a leading '_' on all user symbols.  */\n@@ -4244,7 +4244,7 @@ s_cris_dtpoff (int bytes)\n \n   p = frag_more (bytes);\n   md_number_to_chars (p, 0, bytes);\n-  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE,\n+  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, false,\n \t       BFD_RELOC_CRIS_32_DTPREL);\n \n   demand_empty_rest_of_line ();"
    },
    {
      "sha": "3069b40b774dc2d134664ca3fb9f9af1506a0f03",
      "filename": "gas/config/tc-csky.c",
      "status": "modified",
      "additions": 333,
      "deletions": 333,
      "changes": 666,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-csky.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -146,35 +146,35 @@\n #define LRW_DISP16_LEN    4   /* lrw32.  */\n \n /* Declare worker functions.  */\n-bfd_boolean v1_work_lrw (void);\n-bfd_boolean v1_work_jbsr (void);\n-bfd_boolean v1_work_fpu_fo (void);\n-bfd_boolean v1_work_fpu_fo_fc (void);\n-bfd_boolean v1_work_fpu_write (void);\n-bfd_boolean v1_work_fpu_read (void);\n-bfd_boolean v1_work_fpu_writed (void);\n-bfd_boolean v1_work_fpu_readd (void);\n-bfd_boolean v2_work_istack (void);\n-bfd_boolean v2_work_btsti (void);\n-bfd_boolean v2_work_addi (void);\n-bfd_boolean v2_work_subi (void);\n-bfd_boolean v2_work_add_sub (void);\n-bfd_boolean v2_work_rotlc (void);\n-bfd_boolean v2_work_bgeni (void);\n-bfd_boolean v2_work_not (void);\n-bfd_boolean v2_work_jbtf (void);\n-bfd_boolean v2_work_jbr (void);\n-bfd_boolean v2_work_lrw (void);\n-bfd_boolean v2_work_lrsrsw (void);\n-bfd_boolean v2_work_jbsr (void);\n-bfd_boolean v2_work_jsri (void);\n-bfd_boolean v2_work_movih (void);\n-bfd_boolean v2_work_ori (void);\n-bfd_boolean float_work_fmovi (void);\n-bfd_boolean dsp_work_bloop (void);\n-bfd_boolean float_work_fpuv3_fmovi (void);\n-bfd_boolean float_work_fpuv3_fstore (void);\n-bfd_boolean v2_work_addc (void);\n+bool v1_work_lrw (void);\n+bool v1_work_jbsr (void);\n+bool v1_work_fpu_fo (void);\n+bool v1_work_fpu_fo_fc (void);\n+bool v1_work_fpu_write (void);\n+bool v1_work_fpu_read (void);\n+bool v1_work_fpu_writed (void);\n+bool v1_work_fpu_readd (void);\n+bool v2_work_istack (void);\n+bool v2_work_btsti (void);\n+bool v2_work_addi (void);\n+bool v2_work_subi (void);\n+bool v2_work_add_sub (void);\n+bool v2_work_rotlc (void);\n+bool v2_work_bgeni (void);\n+bool v2_work_not (void);\n+bool v2_work_jbtf (void);\n+bool v2_work_jbr (void);\n+bool v2_work_lrw (void);\n+bool v2_work_lrsrsw (void);\n+bool v2_work_jbsr (void);\n+bool v2_work_jsri (void);\n+bool v2_work_movih (void);\n+bool v2_work_ori (void);\n+bool float_work_fmovi (void);\n+bool dsp_work_bloop (void);\n+bool float_work_fpuv3_fmovi (void);\n+bool float_work_fpuv3_fstore (void);\n+bool v2_work_addc (void);\n \n /* csky-opc.h must be included after workers are declared.  */\n #include \"opcodes/csky-opc.h\"\n@@ -501,8 +501,8 @@ static int do_noliteraldump = 0;\n static symbolS * poolsym;\n static char poolname[8];\n \n-static bfd_boolean mov_r1_before;\n-static bfd_boolean mov_r1_after;\n+static bool mov_r1_before;\n+static bool mov_r1_after;\n \n const relax_typeS csky_relax_table [] =\n {\n@@ -1249,7 +1249,7 @@ static const struct csky_option_value_table csky_float_abis[] =\n   {NULL,\t0}\n };\n \n-static bfd_boolean\n+static bool\n parse_float_abi (const char *str)\n {\n   const struct csky_option_value_table * opt;\n@@ -1258,11 +1258,11 @@ parse_float_abi (const char *str)\n     if (strcasecmp (opt->name, str) == 0)\n       {\n \tfloat_abi = opt->value;\n-\treturn TRUE;\n+\treturn true;\n       }\n \n   as_bad (_(\"unknown floating point abi `%s'\\n\"), str);\n-  return FALSE;\n+  return false;\n }\n \n #ifdef OBJ_ELF\n@@ -2506,7 +2506,7 @@ parse_rtf (char *s, int ispcrel, expressionS *ep)\n   return s;\n }\n \n-static bfd_boolean\n+static bool\n parse_type_ctrlreg (char** oper)\n {\n   int i = -1;\n@@ -2546,21 +2546,21 @@ parse_type_ctrlreg (char** oper)\n \t  if (*s != '<')\n \t    {\n \t      SET_ERROR_STRING (ERROR_CREG_ILLEGAL, s);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  s++;\n \t  crx = strtol(s, &s, 10);\n \t  if (crx < 0 || crx > 31 || *s != ',')\n \t    {\n \t      SET_ERROR_STRING (ERROR_CREG_ILLEGAL, s);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  s++;\n \t  sel = strtol(s, &s, 10);\n \t  if (sel < 0 || sel > 31 || *s != '>')\n \t    {\n \t      SET_ERROR_STRING (ERROR_CREG_ILLEGAL, s);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  s++;\n \t}\n@@ -2570,7 +2570,7 @@ parse_type_ctrlreg (char** oper)\n \t  if (crx < 0)\n \t    {\n \t      SET_ERROR_STRING (ERROR_CREG_ILLEGAL, s);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \ti = (sel << 5) | crx;\n@@ -2581,12 +2581,12 @@ parse_type_ctrlreg (char** oper)\n       if (i < 0)\n \t{\n \t  SET_ERROR_STRING (ERROR_CREG_ILLEGAL, s);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   *oper = s;\n   csky_insn.val[csky_insn.idx++] = i;\n-  return TRUE;\n+  return true;\n }\n \n static int\n@@ -2599,7 +2599,7 @@ csky_get_reg_val (char *str, int *len)\n   return regno;\n }\n \n-static bfd_boolean\n+static bool\n is_reg_sp_with_bracket (char **oper)\n {\n   int reg;\n@@ -2612,7 +2612,7 @@ is_reg_sp_with_bracket (char **oper)\n     sp_idx = 14;\n \n   if (**oper != '(')\n-      return FALSE;\n+      return false;\n   *oper += 1;\n   reg = csky_get_reg_val (*oper, &len);\n   *oper += len;\n@@ -2622,19 +2622,19 @@ is_reg_sp_with_bracket (char **oper)\n         {\n           SET_ERROR_STRING (ERROR_UNDEFINE,\n \t\t\t    \"Operand format is error. '(sp)' expected\");\n-          return FALSE;\n+          return false;\n         }\n       *oper += 1;\n       csky_insn.val[csky_insn.idx++] = sp_idx;\n-      return TRUE;\n+      return true;\n     }\n \n   SET_ERROR_STRING (ERROR_UNDEFINE,\n \t\t    \"Operand format is error. '(sp)' expected\");\n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n is_reg_sp (char **oper)\n {\n   char sp_name[16];\n@@ -2650,18 +2650,18 @@ is_reg_sp (char **oper)\n     {\n       *oper += 2;\n       csky_insn.val[csky_insn.idx++] = sp_idx;\n-      return TRUE;\n+      return true;\n     }\n \n   len = sprintf (sp_name, \"r%d\", sp_idx);\n   if (memcmp (*oper, sp_name, len) == 0)\n     {\n       *oper += len;\n       csky_insn.val[csky_insn.idx++] = sp_idx;\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n static int\n@@ -2688,7 +2688,7 @@ csky_get_freg_val (char *str, int *len)\n   return reg;\n }\n \n-static bfd_boolean\n+static bool\n is_reglist_legal (char **oper)\n {\n   int reg1 = -1;\n@@ -2701,14 +2701,14 @@ is_reglist_legal (char **oper)\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The first reg must not be r0/r15\");\n-      return FALSE;\n+      return false;\n     }\n \n   if (**oper != '-')\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The operand format must be rx-ry\");\n-      return FALSE;\n+      return false;\n     }\n   *oper += 1;\n \n@@ -2719,25 +2719,25 @@ is_reglist_legal (char **oper)\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The operand format must be r15 in C-SKY V1\");\n-      return FALSE;\n+      return false;\n     }\n   if (IS_CSKY_V2 (mach_flag))\n     {\n       if (reg2 < reg1)\n \t{\n \t  SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t    \"The operand format must be rx-ry (rx < ry)\");\n-\t  return FALSE;\n+\t  return false;\n \t}\n       reg2 = reg2 - reg1;\n       reg1 <<= 5;\n       reg1 |= reg2;\n     }\n   csky_insn.val[csky_insn.idx++] = reg1;\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n is_freglist_legal (char **oper)\n {\n   int reg1 = -1;\n@@ -2751,14 +2751,14 @@ is_freglist_legal (char **oper)\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The fpu register format is not recognized.\");\n-      return FALSE;\n+      return false;\n     }\n \n   if (**oper != '-')\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The operand format must be vrx-vry/frx-fry.\");\n-      return FALSE;\n+      return false;\n     }\n   *oper += 1;\n \n@@ -2769,13 +2769,13 @@ is_freglist_legal (char **oper)\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The fpu register format is not recognized.\");\n-      return FALSE;\n+      return false;\n     }\n   if (reg2 < reg1)\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\"The operand format must be rx-ry(rx < ry)\");\n-      return FALSE;\n+      return false;\n     }\n \n   reg2 = reg2 - reg1;\n@@ -2792,7 +2792,7 @@ is_freglist_legal (char **oper)\n \t  /* ISA_FLOAT_E1 fstm/fldm fry-frx is within 15.\n \t     ISA_FLOAT_7E60 fstm(u)/fldm(u) frx-fry is within 31.  */\n \t  SET_ERROR_STRING(ERROR_REG_FORMAT, (void *)\"frx-fry is over range\");\n-\t  return FALSE;\n+\t  return false;\n \t}\n       if ((mach_flag & CSKY_ARCH_MASK) == CSKY_ARCH_860)\n \t{\n@@ -2803,16 +2803,16 @@ is_freglist_legal (char **oper)\n     {\n       if (reg2 > (int)0x3) {\n         SET_ERROR_STRING(ERROR_REG_FORMAT, (void *)\"vry-vrx is over range\");\n-        return FALSE;\n+        return false;\n       }\n     }\n   reg2 <<= shift;\n   reg1 |= reg2;\n   csky_insn.val[csky_insn.idx++] = reg1;\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n {\n   int reg1 = -1;\n@@ -2827,7 +2827,7 @@ is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n       if (reg1 == -1)\n \t{\n \t  SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       flag |= (1 << reg1);\n       *oper += len;\n@@ -2838,13 +2838,13 @@ is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n \t  if (reg2 == -1)\n \t    {\n \t      SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  *oper += len;\n \t  if (reg1 > reg2)\n \t    {\n \t      SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  while (reg2 >= reg1)\n \t    {\n@@ -2860,7 +2860,7 @@ is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n   if (flag & ~(REGLIST_BITS))\n     {\n       SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n-      return FALSE;\n+      return false;\n     }\n   /* Check r4-r11.  */\n   int i = 4;\n@@ -2893,13 +2893,13 @@ is_reglist_dash_comma_legal (char **oper, struct operand *oprnd)\n   if (oprnd->mask == OPRND_MASK_0_4 && (list & ~OPRND_MASK_0_4))\n     {\n       SET_ERROR_STRING (ERROR_REG_LIST, NULL);\n-      return FALSE;\n+      return false;\n     }\n   csky_insn.val[csky_insn.idx++] = list;\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n is_reg_lshift_illegal (char **oper, int is_float)\n {\n   int value;\n@@ -2909,15 +2909,15 @@ is_reg_lshift_illegal (char **oper, int is_float)\n   if (reg == -1)\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT, \"The register must be r0-r31.\");\n-      return FALSE;\n+      return false;\n     }\n \n   *oper += len;\n   if ((*oper)[0] != '<' || (*oper)[1] != '<')\n     {\n       SET_ERROR_STRING (ERROR_UNDEFINE,\n \t\t\t\"Operand format error; should be (rx, ry << n)\");\n-      return FALSE;\n+      return false;\n     }\n   *oper += 2;\n \n@@ -2930,36 +2930,36 @@ is_reg_lshift_illegal (char **oper, int is_float)\n       if (e.X_add_number < 0 || e.X_add_number > 3)\n \t{\n \t  SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   else\n     {\n       SET_ERROR_STRING (ERROR_EXP_CONSTANT, NULL);\n-      return FALSE;\n+      return false;\n     }\n   if (is_float)\n     value = (reg << 2) | e.X_add_number;\n   else\n     value = (reg << 5) | (1 << e.X_add_number);\n   csky_insn.val[csky_insn.idx++] = value;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n is_imm_within_range (char **oper, int min, int max)\n {\n   expressionS e;\n-  bfd_boolean ret = FALSE;\n+  bool ret = false;\n   char *new_oper = parse_exp (*oper, &e);\n   if (e.X_op == O_constant)\n     {\n-      ret = TRUE;\n+      ret = true;\n       *oper = new_oper;\n       if (e.X_add_number < min || e.X_add_number > max)\n \t{\n-\t  ret = FALSE;\n+\t  ret = false;\n \t  SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n \t}\n       if (!e.X_unsigned)\n@@ -2972,20 +2972,20 @@ is_imm_within_range (char **oper, int min, int max)\n   return ret;\n }\n \n-static bfd_boolean\n+static bool\n is_imm_within_range_ext (char **oper, int min, int max, int ext)\n {\n   expressionS e;\n-  bfd_boolean ret = FALSE;\n+  bool ret = false;\n   char *new_oper = parse_exp (*oper, &e);\n   if (e.X_op == O_constant)\n     {\n-      ret = TRUE;\n+      ret = true;\n       *oper = new_oper;\n       if ((int)e.X_add_number != ext\n \t  && (e.X_add_number < min || e.X_add_number > max))\n \t{\n-\t  ret = FALSE;\n+\t  ret = false;\n \t  SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n \t}\n       csky_insn.val[csky_insn.idx++] = e.X_add_number;\n@@ -2997,19 +2997,19 @@ is_imm_within_range_ext (char **oper, int min, int max, int ext)\n   return ret;\n }\n \n-static bfd_boolean\n+static bool\n is_oimm_within_range (char **oper, int min, int max)\n {\n   expressionS e;\n-  bfd_boolean ret = FALSE;\n+  bool ret = false;\n   char *new_oper = parse_exp (*oper, &e);\n   if (e.X_op == O_constant)\n     {\n-      ret = TRUE;\n+      ret = true;\n       *oper = new_oper;\n       if (e.X_add_number < min || e.X_add_number > max)\n \t{\n-\t  ret = FALSE;\n+\t  ret = false;\n \t  SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n \t}\n       csky_insn.val[csky_insn.idx++] = e.X_add_number - 1;\n@@ -3020,7 +3020,7 @@ is_oimm_within_range (char **oper, int min, int max)\n   return ret;\n }\n \n-static bfd_boolean\n+static bool\n is_psr_bit (char **oper)\n {\n   const struct psrbit *bits;\n@@ -3042,15 +3042,15 @@ is_psr_bit (char **oper)\n \t{\n \t  *oper += strlen (bits[i].name);\n \t  csky_insn.val[csky_insn.idx] |= bits[i].value;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       i++;\n     }\n   SET_ERROR_STRING (ERROR_OPCODE_PSRBIT, NULL);\n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n parse_type_cpidx (char** oper)\n {\n   char *s = *oper;\n@@ -3068,7 +3068,7 @@ parse_type_cpidx (char** oper)\n \t  *oper += 3;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n     }\n   else\n     {\n@@ -3077,25 +3077,25 @@ parse_type_cpidx (char** oper)\n       if (e.X_op != O_constant)\n \t{\n \t  /* Can not recognize the operand.  */\n-\t  return FALSE;\n+\t  return false;\n \t}\n       idx = e.X_add_number;\n     }\n \n   csky_insn.val[csky_insn.idx++] = idx;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n parse_type_cpreg (char** oper)\n {\n   expressionS e;\n \n   if (strncasecmp (*oper, \"cpr\", 3) != 0)\n     {\n       SET_ERROR_STRING(ERROR_CPREG_ILLEGAL, *oper);\n-      return FALSE;\n+      return false;\n     }\n \n   *oper += 3;\n@@ -3104,23 +3104,23 @@ parse_type_cpreg (char** oper)\n   if (e.X_op != O_constant)\n     {\n       SET_ERROR_STRING(ERROR_CPREG_ILLEGAL, *oper);\n-      return FALSE;\n+      return false;\n     }\n \n   csky_insn.val[csky_insn.idx++] = e.X_add_number;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n parse_type_cpcreg (char** oper)\n {\n   expressionS e;\n \n   if (strncasecmp (*oper, \"cpcr\", 4) != 0)\n     {\n       SET_ERROR_STRING(ERROR_CPREG_ILLEGAL, *oper);\n-      return FALSE;\n+      return false;\n     }\n \n   *oper += 4;\n@@ -3129,15 +3129,15 @@ parse_type_cpcreg (char** oper)\n   if (e.X_op != O_constant)\n     {\n       SET_ERROR_STRING(ERROR_CPREG_ILLEGAL, *oper);\n-      return FALSE;\n+      return false;\n     }\n \n   csky_insn.val[csky_insn.idx++] = e.X_add_number;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n parse_type_areg (char** oper)\n {\n   int i = 0;\n@@ -3146,15 +3146,15 @@ parse_type_areg (char** oper)\n   if (i == -1)\n     {\n       SET_ERROR_STRING (ERROR_GREG_ILLEGAL, NULL);\n-      return FALSE;\n+      return false;\n     }\n   *oper += len;\n   csky_insn.val[csky_insn.idx++] = i;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n parse_type_freg (char** oper, int even)\n {\n   int reg;\n@@ -3164,14 +3164,14 @@ parse_type_freg (char** oper, int even)\n     {\n       SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t(void *)\"The fpu register format is not recognized.\");\n-      return FALSE;\n+      return false;\n     }\n   *oper += len;\n   csky_insn.opcode_end = *oper;\n   if (even && reg & 0x1)\n     {\n       SET_ERROR_STRING (ERROR_EXP_EVEN_FREG, NULL);\n-      return FALSE;\n+      return false;\n     }\n \n   if (IS_CSKY_V2 (mach_flag)\n@@ -3187,18 +3187,18 @@ parse_type_freg (char** oper, int even)\n \t{\n \t  SET_ERROR_INTEGER (ERROR_FREG_OVER_RANGE, reg);\n \t}\n-      return FALSE;\n+      return false;\n     }\n   /* TODO: recognize vreg or freg.  */\n   if (reg > 31)\n     {\n       SET_ERROR_INTEGER (ERROR_VREG_OVER_RANGE, reg);\n     }\n   csky_insn.val[csky_insn.idx++] = reg;\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n parse_ldst_imm (char **oper, struct csky_opcode_info *op ATTRIBUTE_UNUSED,\n \t\tstruct operand *oprnd)\n {\n@@ -3219,7 +3219,7 @@ parse_ldst_imm (char **oper, struct csky_opcode_info *op ATTRIBUTE_UNUSED,\n   if (**oper == '\\0' || **oper == ')')\n     {\n       csky_insn.val[csky_insn.idx++] = 0;\n-      return TRUE;\n+      return true;\n     }\n \n   expressionS e;\n@@ -3228,24 +3228,24 @@ parse_ldst_imm (char **oper, struct csky_opcode_info *op ATTRIBUTE_UNUSED,\n     {\n     /* Not a constant.  */\n       SET_ERROR_STRING(ERROR_UNDEFINE, (void *)\"Operand format is error. eg. \\\"ld rz, (rx, n)\\\"\");\n-    return FALSE;\n+    return false;\n     }\n   else if (e.X_add_number < 0 || e.X_add_number >= max)\n     {\n       /* Out of range.  */\n       SET_ERROR_STRING(ERROR_IMM_OVERFLOW, NULL);\n-      return FALSE;\n+      return false;\n     }\n   if ((e.X_add_number % (1 << shift)) != 0)\n     {\n       /* Not aligned.  */\n       SET_ERROR_INTEGER (ERROR_OFFSET_UNALIGNED, ((unsigned long)1 << shift));\n-      return FALSE;\n+      return false;\n     }\n \n   csky_insn.val[csky_insn.idx++] = e.X_add_number >> shift;\n \n-  return TRUE;\n+  return true;\n \n }\n \n@@ -3289,14 +3289,14 @@ csky_count_operands (char *str)\n /* Parse the opcode part of an instruction.  Fill in the csky_insn\n    state and return true on success, false otherwise.  */\n \n-static bfd_boolean\n+static bool\n parse_opcode (char *str)\n {\n #define IS_OPCODE32F(a) (*(a - 2) == '3' && *(a - 1) == '2')\n #define IS_OPCODE16F(a) (*(a - 2) == '1' && *(a - 1) == '6')\n \n   /* TRUE if this opcode has a suffix, like 'lrw.h'.  */\n-  unsigned int has_suffix = FALSE;\n+  unsigned int has_suffix = false;\n   unsigned int nlen = 0;\n   char *opcode_end;\n   char name[OPCODE_MAX_LEN + 1];\n@@ -3316,7 +3316,7 @@ parse_opcode (char *str)\n       if (IS_CSKY_V2 (mach_flag)\n \t  && *opcode_end == '.' && !has_suffix)\n \t{\n-\t  has_suffix = TRUE;\n+\t  has_suffix = true;\n \t  if (IS_OPCODE32F (opcode_end))\n \t    {\n \t      csky_insn.flag_force = INSN_OPCODE32F;\n@@ -3370,14 +3370,14 @@ parse_opcode (char *str)\n \t\t\t\t\t\t\t   name);\n \n   if (csky_insn.macro == NULL && csky_insn.opcode == NULL)\n-    return FALSE;\n-  return TRUE;\n+    return false;\n+  return true;\n }\n \n /* Main dispatch routine to parse operand OPRND for opcode OP from string\n    *OPER.  */\n \n-static bfd_boolean\n+static bool\n get_operand_value (struct csky_opcode_info *op,\n \t\t   char **oper, struct operand *oprnd)\n {\n@@ -3415,7 +3415,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t  SET_ERROR_STRING ((oprnd->type == OPRND_TYPE_BRACKET\n \t\t\t     ? ERROR_MISSING_LBRACKET\n \t\t\t     : ERROR_MISSING_LANGLE_BRACKETS), NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       /* If the oprnd2 is an immediate, it can not be parsed\n@@ -3436,31 +3436,31 @@ get_operand_value (struct csky_opcode_info *op,\n \t  SET_ERROR_STRING ((oprnd->type == OPRND_TYPE_BRACKET\n \t\t\t     ? ERROR_MISSING_RBRACKET\n \t\t\t     : ERROR_MISSING_RANGLE_BRACKETS), NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (!get_operand_value (op, oper, &soprnd->subs[0]))\n \t{\n \t  *s = rc;\n-\t  return FALSE;\n+\t  return false;\n \t}\n       if (**oper == ',')\n \t*oper += 1;\n       else if (**oper != '\\0')\n \t{\n \t  SET_ERROR_STRING (ERROR_MISSING_COMMA, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (!get_operand_value (op, oper, &soprnd->subs[1]))\n \t{\n \t  *s = rc;\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       *s = rc;\n       *oper += 1;\n-      return TRUE;\n+      return true;\n     }\n \n   switch (oprnd->type)\n@@ -3495,17 +3495,17 @@ get_operand_value (struct csky_opcode_info *op,\n \tif (reg == -1)\n \t  {\n \t    SET_ERROR_STRING (ERROR_GREG_ILLEGAL, NULL);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \telse if ((oprnd->type == OPRND_TYPE_GREG0_7 && reg > 7)\n \t\t || (oprnd->type == OPRND_TYPE_GREG0_15 && reg > 15))\n \t  {\n \t    SET_ERROR_INTEGER (ERROR_REG_OVER_RANGE, reg);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \t*oper += len;\n \tcsky_insn.val[csky_insn.idx++] = reg;\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_REGnsplr:\n       {\n@@ -3518,11 +3518,11 @@ get_operand_value (struct csky_opcode_info *op,\n \t\t&& (reg == V1_REG_SP || reg == V1_REG_LR)))\n \t  {\n \t    SET_ERROR_STRING (ERROR_REG_OVER_RANGE, reg);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \tcsky_insn.val[csky_insn.idx++] = reg;\n \t*oper += len;\n-\treturn TRUE;;\n+\treturn true;;\n       }\n     case OPRND_TYPE_REGnr4_r7:\n       {\n@@ -3532,24 +3532,24 @@ get_operand_value (struct csky_opcode_info *op,\n \t  *oper += 1;\n \treg = csky_get_reg_val (*oper, &len);\n \tif (reg == -1 || (reg <= 7 && reg >= 4))\n-\t  return FALSE;\n+\t  return false;\n \n \tcsky_insn.val[csky_insn.idx++] = reg;\n \t*oper += len;\n \n \tif (**oper == ')')\n \t  *oper += 1;\n-\treturn TRUE;;\n+\treturn true;;\n       }\n     case OPRND_TYPE_REGr4_r7:\n       if (memcmp (*oper, \"r4-r7\", sizeof (\"r4-r7\") - 1) == 0)\n \t{\n \t  *oper += sizeof (\"r4-r7\") - 1;\n \t  csky_insn.val[csky_insn.idx++] = 0;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       SET_ERROR_STRING (ERROR_OPCODE_ILLEGAL, NULL);\n-      return FALSE;\n+      return false;\n     case OPRND_TYPE_IMM_LDST:\n       return parse_ldst_imm (oper, op, oprnd);\n     case OPRND_TYPE_IMM_FLDST:\n@@ -3564,7 +3564,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t  && (op->opcode & 0xffff0000) != 0)\n \t{\n \t  SET_ERROR_STRING (ERROR_OPCODE_ILLEGAL, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       *oper = parse_exp (*oper, &csky_insn.e1);\n       if (csky_insn.e1.X_op == O_constant)\n@@ -3573,12 +3573,12 @@ get_operand_value (struct csky_opcode_info *op,\n \t  if (csky_insn.e1.X_add_number & 0x7)\n \t    {\n \t      SET_ERROR_STRING (ERROR_JMPIX_OVER_RANGE, NULL);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  csky_insn.val[csky_insn.idx++]\n \t    = (csky_insn.e1.X_add_number >> 3) - 2;\n \t}\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_IMM4b:\n       return is_imm_within_range (oper, 0, 15);\n     case OPRND_TYPE_IMM5b:\n@@ -3596,10 +3596,10 @@ get_operand_value (struct csky_opcode_info *op,\n \t\tstr_hash_find (csky_opcodes_hash, name);\n \t      csky_insn.val[csky_insn.idx - 1] = 1 << val;\n \t    }\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case OPRND_TYPE_IMM5b_1_31:\n       return is_imm_within_range (oper, 1, 31);\n@@ -3613,7 +3613,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t  return log != -1;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n       /* This type for \"mgeni\" in csky v1 ISA.  */\n       case OPRND_TYPE_IMM5b_7_31_POWER:\n@@ -3635,7 +3635,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t    return log != -1;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n \n     case OPRND_TYPE_IMM5b_LS:\n       return is_imm_within_range (oper,\n@@ -3649,10 +3649,10 @@ get_operand_value (struct csky_opcode_info *op,\n \t  {\n \t    int i = csky_insn.idx - 1;\n \t    csky_insn.val[i] = 32 - csky_insn.val[i];\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case OPRND_TYPE_IMM5b_BMASKI:\n@@ -3667,12 +3667,12 @@ get_operand_value (struct csky_opcode_info *op,\n \t      csky_insn.opcode = (struct csky_opcode *)\n \t\tstr_hash_find (csky_opcodes_hash, op_movi);\n \t      if (csky_insn.opcode == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      csky_insn.val[csky_insn.idx - 1] = (1 << mask_val) - 1;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t}\n-      return TRUE;\n+      return true;\n \n     case OPRND_TYPE_IMM5b_VSH:\n     /* For vshri.T and vshli.T.  */\n@@ -3682,18 +3682,18 @@ get_operand_value (struct csky_opcode_info *op,\n \t  val =  (val << 1) | (val >> 4);\n \t  val &= 0x1f;\n \t  csky_insn.val[csky_insn.idx - 1] = val;\n-\t  return TRUE;\n+\t  return true;\n \t}\n-      return FALSE;\n+      return false;\n       case OPRND_TYPE_IMM8b_BMASKI:\n       /* For csky v2 bmask, which will transfer to 16bits movi.  */\n \tif (is_imm_within_range (oper, 1, 8))\n \t  {\n \t    unsigned int mask_val = csky_insn.val[csky_insn.idx - 1];\n \t    csky_insn.val[csky_insn.idx - 1] = (1 << mask_val) - 1;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n-\treturn FALSE;\n+\treturn false;\n     case OPRND_TYPE_OIMM4b:\n       return is_oimm_within_range (oper, 1, 16);\n     case OPRND_TYPE_OIMM5b:\n@@ -3710,30 +3710,30 @@ get_operand_value (struct csky_opcode_info *op,\n \t    }\n \t  else imm--;\n \t  csky_insn.val[csky_insn.idx - 1] = imm;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n       /* For csky v2 bmask inst.  */\n     case OPRND_TYPE_OIMM5b_BMASKI:\n       if (!is_oimm_within_range (oper, 17, 32))\n \t{\n \t  int mask_val = csky_insn.val[csky_insn.idx - 1];\n \t  if (mask_val + 1 == 0)\n-\t    return TRUE;\n+\t    return true;\n \t  if (mask_val > 0 && mask_val < 16)\n \t    {\n \t      const char *op_movi = \"movi\";\n \t      csky_insn.opcode = (struct csky_opcode *)\n \t\tstr_hash_find (csky_opcodes_hash, op_movi);\n \t      if (csky_insn.opcode == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      csky_insn.val[csky_insn.idx - 1] = (1 << (mask_val + 1)) - 1;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t}\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_IMM7b:\n       return is_imm_within_range (oper, 0, 127);\n     case OPRND_TYPE_IMM8b:\n@@ -3756,9 +3756,9 @@ get_operand_value (struct csky_opcode_info *op,\n \t  {\n \t    *oper = new_oper;\n \t    csky_insn.val[csky_insn.idx++] = e.X_add_number;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n-\treturn FALSE;\n+\treturn false;\n       }\n     case OPRND_TYPE_IMM16b_MOVIH:\n     case OPRND_TYPE_IMM16b_ORI:\n@@ -3784,13 +3784,13 @@ get_operand_value (struct csky_opcode_info *op,\n \t  }\n \tinput_line_pointer = save;\n \t*oper = parse_exp (curr, &csky_insn.e1);\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_PSR_BITS_LIST:\n       {\n-\tint ret = TRUE;\n+\tint ret = true;\n \tif (csky_insn.number == 0)\n-\t  ret = FALSE;\n+\t  ret = false;\n \telse\n \t  {\n \t    csky_insn.val[csky_insn.idx] = 0;\n@@ -3800,15 +3800,15 @@ get_operand_value (struct csky_opcode_info *op,\n \t\t  *oper += 1;\n \t\t  if (!is_psr_bit (oper))\n \t\t    {\n-\t\t      ret = FALSE;\n+\t\t      ret = false;\n \t\t      break;\n \t\t    }\n \t\t}\n \t    else\n-\t      ret = FALSE;\n+\t      ret = false;\n \t    if (ret && IS_CSKY_V1 (mach_flag)\n \t\t&& csky_insn.val[csky_insn.idx] > 8)\n-\t      ret = FALSE;\n+\t      ret = false;\n \t  }\n \tif (!ret)\n \t  SET_ERROR_STRING (ERROR_OPERANDS_ILLEGAL, csky_insn.opcode_end);\n@@ -3831,9 +3831,9 @@ get_operand_value (struct csky_opcode_info *op,\n \t    {\n \t      *oper += strlen (round_mode[i]);\n \t      csky_insn.val[csky_insn.idx++] = i;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case OPRND_TYPE_REGLIST_COMMA:\n@@ -3852,24 +3852,24 @@ get_operand_value (struct csky_opcode_info *op,\n \tif (**oper != '(')\n \t  {\n \t    SET_ERROR_STRING (ERROR_MISSING_LBRACKET, NULL);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \t*oper += 1;\n \treg = csky_get_reg_val (*oper, &len);\n \tif (reg == -1)\n \t  {\n \t    SET_ERROR_STRING (ERROR_EXP_GREG, NULL);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \t*oper += len;\n \tif (**oper != ')')\n \t  {\n \t    SET_ERROR_STRING (ERROR_MISSING_RBRACKET, NULL);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \t*oper += 1;\n \tcsky_insn.val[csky_insn.idx++] = reg;\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_REGsp:\n       return is_reg_sp (oper);\n@@ -3880,7 +3880,7 @@ get_operand_value (struct csky_opcode_info *op,\n     case OPRND_TYPE_OFF16b:\n       *oper = parse_rt (*oper, 1, &csky_insn.e1, -1);\n       csky_insn.val[csky_insn.idx++] = 0;\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_LABEL_WITH_BRACKET:\n     case OPRND_TYPE_CONSTANT:\n     case OPRND_TYPE_ELRW_CONSTANT:\n@@ -3889,10 +3889,10 @@ get_operand_value (struct csky_opcode_info *op,\n       else\n \tcsky_insn.val[csky_insn.idx++] = NEED_OUTPUT_LITERAL;\n       *oper = parse_rt (*oper, 0, &csky_insn.e1, -1);\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_FCONSTANT:\n       *oper = parse_rtf (*oper, 0, &csky_insn.e1);\n-      return TRUE;\n+      return true;\n \n     case OPRND_TYPE_SFLOAT:\n     case OPRND_TYPE_DFLOAT:\n@@ -3904,7 +3904,7 @@ get_operand_value (struct csky_opcode_info *op,\n \n \t*oper = parse_fexp (*oper, &csky_insn.e1, 1, &dbnum);\n \tif (csky_insn.e1.X_op == O_absent)\n-\t  return FALSE;\n+\t  return false;\n \n \t/* Convert the representation from IEEE double to the 13-bit\n \t   encoding used internally for fmovis and fmovid.  */\n@@ -3913,15 +3913,15 @@ get_operand_value (struct csky_opcode_info *op,\n \tif ((dbnum & 0x00000fffffffffffULL) || imm4 < 0 || imm4 > 15)\n \t  {\n \t    csky_show_error (ERROR_IMM_OVERFLOW, 2, NULL, NULL);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \timm8 = (dbnum & 0x000ff00000000000ULL) >> 44;\n \tcsky_insn.e1.X_add_number\n \t  = (((imm8 & 0xf) << 4)\n \t     | ((imm8 & 0xf0) << 17)\n \t     | ((imm4 & 0xf) << 16)\n \t     | ((dbnum & 0x8000000000000000ULL) >> 43));\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_HFLOAT_FMOVI:\n     case OPRND_TYPE_SFLOAT_FMOVI:\n@@ -3934,7 +3934,7 @@ get_operand_value (struct csky_opcode_info *op,\n \n \t*oper = parse_fexp (*oper, &csky_insn.e1, 1, &dbnum);\n \tif (csky_insn.e1.X_op == O_absent)\n-\t  return FALSE;\n+\t  return false;\n \n \t/* Convert the representation from IEEE double to the 13-bit\n \t   encoding used internally for fmovis and fmovid.  */\n@@ -3943,7 +3943,7 @@ get_operand_value (struct csky_opcode_info *op,\n \tif ((dbnum & 0x00000fffffffffffULL) || imm4 < 0 || imm4 > 15)\n \t  {\n \t    csky_show_error (ERROR_IMM_OVERFLOW, 2, NULL, NULL);\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \timm8 = (dbnum & 0x000ff00000000000ULL) >> 44;\n \tsign = (dbnum & 0x8000000000000000ULL) >> 58;\n@@ -3952,22 +3952,22 @@ get_operand_value (struct csky_opcode_info *op,\n \t     | ((imm8 & 0xfc) << 18)\n \t     | ((imm4 & 0xf) << 16)\n \t     | sign);\n-\treturn TRUE;\n+\treturn true;\n       }\n       /* For grs v2.  */\n     case OPRND_TYPE_IMM_OFF18b:\n       *oper = parse_exp (*oper, &csky_insn.e1);\n-      return TRUE;\n+      return true;\n \n     case OPRND_TYPE_BLOOP_OFF4b:\n       *oper = parse_exp (*oper, &csky_insn.e2);\n       if (csky_insn.e2.X_op == O_symbol)\n \t{\n \t  csky_insn.opcode_end = *oper;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case OPRND_TYPE_BLOOP_OFF12b:\n     case OPRND_TYPE_OFF10b:\n@@ -3978,10 +3978,10 @@ get_operand_value (struct csky_opcode_info *op,\n       if (csky_insn.e1.X_op == O_symbol)\n \t{\n \t  csky_insn.opcode_end = *oper;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n       /* For xtrb0(1)(2)(3) and div in csky v1 ISA.  */\n     case OPRND_TYPE_REG_r1a:\n       {\n@@ -3992,14 +3992,14 @@ get_operand_value (struct csky_opcode_info *op,\n \t  {\n \t    SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t      \"The first operand must be register r1.\");\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \tif (reg != 1)\n-\t  mov_r1_after = TRUE;\n+\t  mov_r1_after = true;\n \t*oper += len;\n \tcsky_insn.opcode_end = *oper;\n \tcsky_insn.val[csky_insn.idx++] = reg;\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_REG_r1b:\n       {\n@@ -4010,21 +4010,21 @@ get_operand_value (struct csky_opcode_info *op,\n \t  {\n \t    SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t      \"The second operand must be register r1.\");\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \tif (reg != 1)\n \t  {\n \t    unsigned int mov_insn = CSKYV1_INST_MOV_R1_RX;\n \t    mov_insn |= reg << 4;\n-\t    mov_r1_before = TRUE;\n+\t    mov_r1_before = true;\n \t    csky_insn.output = frag_more (2);\n \t    dwarf2_emit_insn (0);\n \t    md_number_to_chars (csky_insn.output, mov_insn, 2);\n \t  }\n \t*oper += len;\n \tcsky_insn.opcode_end = *oper;\n \tcsky_insn.val[csky_insn.idx++] = reg;\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_DUMMY_REG:\n       {\n@@ -4034,18 +4034,18 @@ get_operand_value (struct csky_opcode_info *op,\n \tif (reg == -1)\n \t  {\n \t    SET_ERROR_STRING (ERROR_GREG_ILLEGAL, NULL);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \tif (reg != csky_insn.val[0])\n \t  {\n \t    SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t      \"The second register must be the same as the first.\");\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \t*oper += len;\n \tcsky_insn.opcode_end = *oper;\n \tcsky_insn.val[csky_insn.idx++] = reg;\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_2IN1_DUMMY:\n       {\n@@ -4057,17 +4057,17 @@ get_operand_value (struct csky_opcode_info *op,\n \tif (reg == -1)\n \t  {\n \t    SET_ERROR_STRING (ERROR_GREG_ILLEGAL, NULL);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \t/* dummy reg's real type should be same with first operand.  */\n \tif (op->oprnd.oprnds[0].type == OPRND_TYPE_GREG0_15)\n \t  max = 15;\n \telse if (op->oprnd.oprnds[0].type == OPRND_TYPE_GREG0_7)\n \t  max = 7;\n \telse\n-\t  return FALSE;\n+\t  return false;\n \tif (reg < min || reg > max)\n-\t  return FALSE;\n+\t  return false;\n \tcsky_insn.val[csky_insn.idx++] = reg;\n \t/* if it is the last operands.  */\n \tif (csky_insn.idx > 2)\n@@ -4079,11 +4079,11 @@ get_operand_value (struct csky_opcode_info *op,\n \t    else if (csky_insn.val[0] ==  csky_insn.val[2])\n \t      csky_insn.val[2] = 0;\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \t  }\n \t*oper += len;\n \tcsky_insn.opcode_end = *oper;\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_DUP_GREG0_7:\n     case OPRND_TYPE_DUP_GREG0_15:\n@@ -4117,47 +4117,47 @@ get_operand_value (struct csky_opcode_info *op,\n \t    else\n \t      SET_ERROR_STRING (ERROR_REG_FORMAT,\n \t\t\t\t\"The register must be r0-r15\");\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \tif (reg > max_reg)\n \t  {\n \t    SET_ERROR_STRING (ERROR_REG_OVER_RANGE, reg);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \treg |= reg << shift_num;\n \t*oper += len;\n \tcsky_insn.opcode_end = *oper;\n \tcsky_insn.val[csky_insn.idx++] = reg;\n-\treturn TRUE;\n+\treturn true;\n       }\n     case OPRND_TYPE_CONST1:\n       *oper = parse_exp (*oper, &csky_insn.e1);\n       if (csky_insn.e1.X_op == O_constant)\n \t{\n \t  csky_insn.opcode_end = *oper;\n \t  if (csky_insn.e1.X_add_number != 1)\n-\t    return FALSE;\n+\t    return false;\n \t  csky_insn.val[csky_insn.idx++] = 1;\n-\t  return TRUE;\n+\t  return true;\n \t}\n-      return FALSE;\n+      return false;\n     case OPRND_TYPE_UNCOND10b:\n     case OPRND_TYPE_UNCOND16b:\n       *oper = parse_exp (*oper, &csky_insn.e1);\n       if (csky_insn.e1.X_op == O_constant)\n-\treturn FALSE;\n+\treturn false;\n       input_line_pointer = *oper;\n       csky_insn.opcode_end = *oper;\n       csky_insn.relax.max = UNCD_DISP16_LEN;\n       csky_insn.relax.var = UNCD_DISP10_LEN;\n       csky_insn.relax.subtype = UNCD_DISP10;\n       csky_insn.val[csky_insn.idx++] = 0;\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_COND10b:\n     case OPRND_TYPE_COND16b:\n       *oper = parse_exp (*oper, &csky_insn.e1);\n       if (csky_insn.e1.X_op == O_constant)\n-\treturn FALSE;\n+\treturn false;\n       input_line_pointer = *oper;\n       csky_insn.opcode_end = *oper;\n       /* CK801 doesn't have 32-bit bt/bf insns; relax to a short\n@@ -4175,19 +4175,19 @@ get_operand_value (struct csky_opcode_info *op,\n \t  csky_insn.relax.subtype = COND_DISP10;\n \t}\n       csky_insn.val[csky_insn.idx++] = 0;\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_JCOMPZ:\n       *oper = parse_exp (*oper, &csky_insn.e1);\n       if (csky_insn.e1.X_op == O_constant)\n-\treturn FALSE;\n+\treturn false;\n       input_line_pointer = *oper;\n       csky_insn.opcode_end = *oper;\n       csky_insn.relax.max = JCOMPZ_DISP32_LEN;\n       csky_insn.relax.var = JCOMPZ_DISP16_LEN;\n       csky_insn.relax.subtype = JCOMPZ_DISP16;\n       csky_insn.max = JCOMPZ_DISP32_LEN;\n       csky_insn.val[csky_insn.idx++] = 0;\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_JBTF:\n       *oper = parse_exp (*oper, &csky_insn.e1);\n       input_line_pointer = *oper;\n@@ -4197,7 +4197,7 @@ get_operand_value (struct csky_opcode_info *op,\n       csky_insn.relax.subtype = C (COND_JUMP_S, 0);\n       csky_insn.val[csky_insn.idx++] = 0;\n       csky_insn.max = C32_LEN_S + 2;\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_JBR:\n       *oper = parse_exp (*oper, &csky_insn.e1);\n       input_line_pointer = *oper;\n@@ -4207,7 +4207,7 @@ get_operand_value (struct csky_opcode_info *op,\n       csky_insn.relax.subtype = C (UNCD_JUMP_S, 0);\n       csky_insn.val[csky_insn.idx++] = 0;\n       csky_insn.max = U32_LEN_S + 2;\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_JBSR:\n       if (do_force2bsr)\n \t*oper = parse_exp (*oper, &csky_insn.e1);\n@@ -4216,7 +4216,7 @@ get_operand_value (struct csky_opcode_info *op,\n       input_line_pointer = *oper;\n       csky_insn.opcode_end = *oper;\n       csky_insn.val[csky_insn.idx++] = 0;\n-      return TRUE;\n+      return true;\n     case OPRND_TYPE_REGLIST_DASH_COMMA:\n       return is_reglist_dash_comma_legal (oper, oprnd);\n \n@@ -4231,21 +4231,21 @@ get_operand_value (struct csky_opcode_info *op,\n \t    if (e.X_add_number > 31)\n \t      {\n \t\tSET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      }\n \t    csky_insn.val[csky_insn.idx++] = e.X_add_number;\n \t    if (oprnd->type == OPRND_TYPE_LSB2SIZE)\n \t      {\n \t\tif (csky_insn.val[csky_insn.idx - 1] > csky_insn.val[csky_insn.idx - 2])\n \t\t  {\n \t\t    SET_ERROR_STRING (ERROR_IMM_OVERFLOW, NULL);\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t  }\n \t\tcsky_insn.val[csky_insn.idx - 2] -= e.X_add_number;\n \t      }\n-\t    return TRUE;\n+\t    return true;\n \t  }\n-\treturn FALSE;\n+\treturn false;\n       }\n     case OPRND_TYPE_AREG_WITH_LSHIFT:\n       return is_reg_lshift_illegal (oper, 0);\n@@ -4266,7 +4266,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t\t      unsigned int val = csky_insn.val[idx];\n \t\t      (*oper)++;\n \t\t      csky_insn.val[idx - 1] |= val << 4;\n-\t\t      return TRUE;\n+\t\t      return true;\n \t\t    }\n \t\t  else\n \t\t    SET_ERROR_STRING (ERROR_MISSING_RSQUARE_BRACKETS, NULL);\n@@ -4275,18 +4275,18 @@ get_operand_value (struct csky_opcode_info *op,\n \t  else\n \t    SET_ERROR_STRING (ERROR_MISSING_LSQUARE_BRACKETS, NULL);\n \t}\n-      return FALSE;\n+      return false;\n \n     default:\n       break;\n       /* error code.  */\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Subroutine of parse_operands.  */\n \n-static bfd_boolean\n+static bool\n parse_operands_op (char *str, struct csky_opcode_info *op)\n {\n   int i;\n@@ -4296,7 +4296,7 @@ parse_operands_op (char *str, struct csky_opcode_info *op)\n \n   for (i = 0; i < OP_TABLE_NUM && op[i].operand_num != -2; i++)\n     {\n-      flag_pass = TRUE;\n+      flag_pass = true;\n       csky_insn.idx = 0;\n       oper = str;\n       /* if operand_num = -1, it is a insn with a REGLIST type operand.i.  */\n@@ -4305,7 +4305,7 @@ parse_operands_op (char *str, struct csky_opcode_info *op)\n \t{\n \t  /* The smaller err_num is more serious.  */\n \t  SET_ERROR_INTEGER (ERROR_OPERANDS_NUMBER, op[i].operand_num);\n-\t  flag_pass = FALSE;\n+\t  flag_pass = false;\n \t  continue;\n \t}\n \n@@ -4327,14 +4327,14 @@ parse_operands_op (char *str, struct csky_opcode_info *op)\n \t      else\n \t\t{\n \t\t  SET_ERROR_STRING (ERROR_MISSING_COMMA, NULL);\n-\t\t  flag_pass = FALSE;\n+\t\t  flag_pass = false;\n \t\t  break;\n \t\t}\n \t    }\n \t  else if (!is_end_of_line[(unsigned char) *oper])\n \t    {\n \t      SET_ERROR_STRING (ERROR_BAD_END, NULL);\n-\t      flag_pass = FALSE;\n+\t      flag_pass = false;\n \t      break;\n \t    }\n \t  else\n@@ -4346,18 +4346,18 @@ parse_operands_op (char *str, struct csky_opcode_info *op)\n \t{\n \t  /* Parse operands success, set opcode_idx.  */\n \t  csky_insn.opcode_idx = i;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n \terror_state.opnum = j + 1;\n     }\n   /* Parse operands in ALL tables end.  */\n-  return FALSE;\n+  return false;\n }\n \n /* Parse the operands according to operand type.  */\n \n-static bfd_boolean\n+static bool\n parse_operands (char *str)\n {\n   char *oper = str;\n@@ -4369,39 +4369,39 @@ parse_operands (char *str)\n       if (parse_operands_op (oper, csky_insn.opcode->op16))\n \t{\n \t  csky_insn.isize = 2;\n-\t  return TRUE;\n+\t  return true;\n \t}\n-      return FALSE;\n+      return false;\n     }\n   else if (csky_insn.flag_force == INSN_OPCODE32F\n \t   && (csky_insn.opcode->isa_flag32 & isa_flag) != 0)\n     {\n       if (parse_operands_op (oper, csky_insn.opcode->op32))\n \t{\n \t  csky_insn.isize = 4;\n-\t  return TRUE;\n+\t  return true;\n \t}\n-      return FALSE;\n+      return false;\n     }\n   else\n     {\n       if ((csky_insn.opcode->isa_flag16 & isa_flag) != 0\n \t  && parse_operands_op (oper, csky_insn.opcode->op16))\n \t{\n \t  csky_insn.isize = 2;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       if ((csky_insn.opcode->isa_flag32 & isa_flag) != 0\n \t  && parse_operands_op (oper, csky_insn.opcode->op32))\n \t{\n \t  csky_insn.isize = 4;\n-\t  return TRUE;\n+\t  return true;\n \t}\n-      return FALSE;\n+      return false;\n     }\n }\n \n-static bfd_boolean\n+static bool\n csky_generate_frags (void)\n {\n   /* frag more relax reloc.  */\n@@ -4463,7 +4463,7 @@ csky_generate_frags (void)\n \t\t       csky_insn.opcode->reloc32);\n \t}\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Return the bits of VAL shifted according to MASK.  The bits of MASK\n@@ -4511,7 +4511,7 @@ generate_masked_operand (struct operand *oprnd, int *oprnd_idx)\n   return 0;\n }\n \n-static bfd_boolean\n+static bool\n csky_generate_insn (void)\n {\n   int i = 0;\n@@ -4540,7 +4540,7 @@ csky_generate_insn (void)\n void\n md_assemble (char *str)\n {\n-  bfd_boolean must_check_literals = TRUE;\n+  bool must_check_literals = true;\n   csky_insn.isize = 0;\n   csky_insn.idx = 0;\n   csky_insn.max = 0;\n@@ -4550,8 +4550,8 @@ md_assemble (char *str)\n   memset (csky_insn.val, 0, sizeof (int) * MAX_OPRND_NUM);\n   /* Initialize err_num.  */\n   error_state.err_num = ERROR_NONE;\n-  mov_r1_before = FALSE;\n-  mov_r1_after = FALSE;\n+  mov_r1_before = false;\n+  mov_r1_after = false;\n \n   mapping_state (MAP_TEXT);\n   /* Tie dwarf2 debug info to every insn if set option --gdwarf2.  */\n@@ -4612,7 +4612,7 @@ md_assemble (char *str)\n     {\n       unsigned int mov_insn = CSKYV1_INST_MOV_RX_R1;\n       mov_insn |= csky_insn.val[0];\n-      mov_r1_before = TRUE;\n+      mov_r1_before = true;\n       csky_insn.output = frag_more (2);\n       dwarf2_emit_insn (0);\n       md_number_to_chars (csky_insn.output, mov_insn, 2);\n@@ -5319,7 +5319,7 @@ csky_force_relocation (fixS * fix)\n /* Return true if the fix can be handled by GAS, false if it must\n    be passed through to the linker.  */\n \n-bfd_boolean\n+bool\n csky_fix_adjustable (fixS * fixP)\n {\n   if (fixP->fx_addsy == NULL)\n@@ -5964,7 +5964,7 @@ csky_movtf (void)\n   return;\n }\n \n-static bfd_boolean\n+static bool\n get_macro_reg_vals (int *reg1, int *reg2, int *reg3)\n {\n   int nlen;\n@@ -5975,40 +5975,40 @@ get_macro_reg_vals (int *reg1, int *reg2, int *reg3)\n   if (*s != ',')\n     {\n       csky_show_error (ERROR_MISSING_COMMA, 0, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n   s++;\n   *reg2 = csky_get_reg_val (s, &nlen);\n   s += nlen;\n   if (*s != ',')\n     {\n       csky_show_error (ERROR_MISSING_COMMA, 0, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n   s++;\n   *reg3 = csky_get_reg_val (s, &nlen);\n   s += nlen;\n   if (*s != '\\0')\n     {\n       csky_show_error (ERROR_BAD_END, 0, s, NULL);\n-      return FALSE;\n+      return false;\n     }\n   if (*reg1 == -1 || *reg2 == -1 || *reg3 == -1)\n     {\n       as_bad (_(\"register number out of range\"));\n-      return FALSE;\n+      return false;\n     }\n   if (*reg1 != *reg2)\n     {\n       as_bad (_(\"dest and source1 must be the same register\"));\n-      return FALSE;\n+      return false;\n     }\n   if (*reg1 >= 15 || *reg3 >= 15)\n     {\n       as_bad (_(\"64-bit operator src/dst register must be less than 15\"));\n-      return FALSE;\n+      return false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* addc64 rx, rx, ry -> cmplt rx, rx, addc  rx, ry, addc  rx+1, ry+1.  */\n@@ -6234,7 +6234,7 @@ csky_lrw (void)\n \n /* The following are worker functions for C-SKY v1.  */\n \n-bfd_boolean\n+bool\n v1_work_lrw (void)\n {\n   int reg;\n@@ -6276,10 +6276,10 @@ v1_work_lrw (void)\n     }\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v1_work_fpu_fo (void)\n {\n   int i = 0;\n@@ -6308,10 +6308,10 @@ v1_work_fpu_fo (void)\n   md_assemble (buff);\n   sprintf (buff, \"cpwir r%d\", greg);\n   md_assemble (buff);\n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n v1_work_fpu_fo_fc (void)\n {\n   int i = 0;\n@@ -6343,10 +6343,10 @@ v1_work_fpu_fo_fc (void)\n   sprintf (buff, \"cprc\");\n   md_assemble (buff);\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n v1_work_fpu_write (void)\n {\n   int greg;\n@@ -6360,10 +6360,10 @@ v1_work_fpu_write (void)\n   sprintf (buff, \"cpwgr r%d,cpr%d\", greg, freg);\n   md_assemble (buff);\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n v1_work_fpu_read (void)\n {\n   int greg;\n@@ -6376,10 +6376,10 @@ v1_work_fpu_read (void)\n   sprintf (buff, \"cprgr r%d,cpr%d\", greg, freg);\n   md_assemble (buff);\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n v1_work_fpu_writed (void)\n {\n   int greg;\n@@ -6392,7 +6392,7 @@ v1_work_fpu_writed (void)\n   if (greg & 0x1)\n     {\n       as_bad (_(\"even register number required\"));\n-      return FALSE;\n+      return false;\n     }\n   /* Now get greg and freg, we can write instruction to floating unit.  */\n   if (target_big_endian)\n@@ -6405,10 +6405,10 @@ v1_work_fpu_writed (void)\n   else\n     sprintf (buff, \"cpwgr r%d,cpr%d\", greg+1, freg + 1);\n   md_assemble (buff);\n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n v1_work_fpu_readd (void)\n {\n   int greg;\n@@ -6421,7 +6421,7 @@ v1_work_fpu_readd (void)\n   if (greg & 0x1)\n     {\n       as_bad (_(\"even register number required\"));\n-      return FALSE;\n+      return false;\n     }\n   /* Now get greg and freg, we can write instruction to floating unit.  */\n   if (target_big_endian)\n@@ -6435,12 +6435,12 @@ v1_work_fpu_readd (void)\n     sprintf (buff, \"cprgr r%d,cpr%d\", greg+1, freg + 1);\n   md_assemble (buff);\n \n-  return FALSE;\n+  return false;\n }\n \n /* The following are for csky pseudo handling.  */\n \n-bfd_boolean\n+bool\n v1_work_jbsr (void)\n {\n   csky_insn.output = frag_more (2);\n@@ -6478,36 +6478,36 @@ v1_work_jbsr (void)\n \n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n \n-  return TRUE;\n+  return true;\n }\n \n /* The following are worker functions for csky v2 instruction handling.  */\n \n /* For nie/nir/ipush/ipop.  */\n \n-bfd_boolean\n+bool\n v2_work_istack (void)\n {\n   if (!do_intr_stack)\n     {\n       csky_show_error (ERROR_OPCODE_ILLEGAL, 0, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n   csky_insn.output = frag_more (csky_insn.isize);\n   csky_insn.inst = csky_insn.opcode->op16[0].opcode;\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_btsti (void)\n {\n   if (!do_extend_lrw\n       && (csky_insn.flag_force == INSN_OPCODE16F\n \t  || IS_CSKY_ARCH_801 (mach_flag)))\n     {\n       csky_show_error (ERROR_OPCODE_ILLEGAL, 0, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n   if (!do_extend_lrw && csky_insn.isize == 2)\n     csky_insn.isize = 4;\n@@ -6517,10 +6517,10 @@ v2_work_btsti (void)\n   csky_generate_insn ();\n   /* Write inst to frag.  */\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_addi (void)\n {\n   csky_insn.isize = 2;\n@@ -6558,7 +6558,7 @@ v2_work_addi (void)\n \t{\n \t  csky_show_error (ERROR_OPERANDS_ILLEGAL, 0,\n \t\t\t   csky_insn.opcode_end, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   else if (csky_insn.number == 3)\n@@ -6632,15 +6632,15 @@ v2_work_addi (void)\n \t{\n \t  csky_show_error (ERROR_OPERANDS_ILLEGAL, 0,\n \t\t\t   (char *)csky_insn.opcode_end, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_subi (void)\n {\n   csky_insn.isize = 2;\n@@ -6674,7 +6674,7 @@ v2_work_subi (void)\n \t{\n \t  csky_show_error (ERROR_OPERANDS_ILLEGAL, 0,\n \t\t\t   (char *)csky_insn.opcode_end, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   else if (csky_insn.number == 3)\n@@ -6719,16 +6719,16 @@ v2_work_subi (void)\n \t{\n \t  csky_show_error (ERROR_OPERANDS_ILLEGAL, 0,\n \t\t\t   (char *)csky_insn.opcode_end, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   csky_insn.output = frag_more (csky_insn.isize);\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_add_sub (void)\n {\n   if (csky_insn.number == 3\n@@ -6784,7 +6784,7 @@ v2_work_add_sub (void)\n \t      csky_show_error (ERROR_REG_OVER_RANGE, 2, NULL, NULL);\n \t    }\n \t}\n-      return FALSE;\n+      return false;\n     }\n   /* sub rz, rx.  */\n   /* Generate relax or reloc if necessary.  */\n@@ -6793,10 +6793,10 @@ v2_work_add_sub (void)\n   csky_generate_insn ();\n   /* Write inst to frag.  */\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_rotlc (void)\n {\n   const char *name = \"addc\";\n@@ -6822,10 +6822,10 @@ v2_work_rotlc (void)\n   csky_generate_insn ();\n   /* Write inst to frag.  */\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_bgeni (void)\n {\n   const char *name = NULL;\n@@ -6849,10 +6849,10 @@ v2_work_bgeni (void)\n   csky_generate_insn ();\n   /* Write inst to frag.  */\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_not (void)\n {\n   const char *name = \"nor\";\n@@ -6898,16 +6898,16 @@ v2_work_not (void)\n   csky_generate_insn ();\n   /* Write inst to frag.  */\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_jbtf (void)\n {\n   if (csky_insn.e1.X_add_symbol == NULL || csky_insn.e1.X_op == O_constant)\n     {\n       csky_show_error (ERROR_UNDEFINE, 0, (void *)\"operand is invalid\", NULL);\n-      return FALSE;\n+      return false;\n     }\n \n   if (IS_CSKY_ARCH_801 (mach_flag))\n@@ -6958,16 +6958,16 @@ v2_work_jbtf (void)\n     }\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_jbr (void)\n {\n   if (csky_insn.e1.X_add_symbol == NULL || csky_insn.e1.X_op == O_constant)\n     {\n       csky_show_error (ERROR_UNDEFINE, 0, (void *)\"operand is invalid\", NULL);\n-      return FALSE;\n+      return false;\n     }\n \n   if (do_long_jump\n@@ -7002,14 +7002,14 @@ v2_work_jbr (void)\n \n     }\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n #define SIZE_V2_MOVI16(x)         ((addressT)x <= 0xff)\n #define SIZE_V2_MOVI32(x)         ((addressT)x <= 0xffff)\n #define SIZE_V2_MOVIH(x)          ((addressT)x <= 0xffffffff && (((addressT)x & 0xffff) == 0))\n \n-bfd_boolean\n+bool\n v2_work_lrw (void)\n {\n   int reg = csky_insn.val[0];\n@@ -7055,7 +7055,7 @@ v2_work_lrw (void)\n   if (is_done)\n     {\n       csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-      return TRUE;\n+      return true;\n     }\n \n   if (output_literal)\n@@ -7074,7 +7074,7 @@ v2_work_lrw (void)\n \t{\n \t  csky_show_error (ERROR_UNDEFINE, 0,\n \t\t\t   (void *)\"The register is out of range.\", NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       csky_insn.isize = 2;\n       csky_insn.output = frag_more (2);\n@@ -7160,10 +7160,10 @@ v2_work_lrw (void)\n     }\n \n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_lrsrsw (void)\n {\n   int reg = csky_insn.val[0];\n@@ -7187,10 +7187,10 @@ v2_work_lrsrsw (void)\n \tbreak;\n     }\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_jbsr (void)\n {\n   if (do_force2bsr\n@@ -7232,10 +7232,10 @@ v2_work_jbsr (void)\n     }\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_jsri (void)\n {\n   /* dump literal.  */\n@@ -7267,10 +7267,10 @@ v2_work_jsri (void)\n       csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n       csky_insn.max = 8;\n     }\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_movih (void)\n {\n   int rz = csky_insn.val[0];\n@@ -7281,12 +7281,12 @@ v2_work_movih (void)\n       if (csky_insn.e1.X_unsigned == 1 && csky_insn.e1.X_add_number > 0xffff)\n \t{\n \t  csky_show_error (ERROR_IMM_OVERFLOW, 2, NULL, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       else if (csky_insn.e1.X_unsigned == 0 && csky_insn.e1.X_add_number < 0)\n \t{\n \t  csky_show_error (ERROR_IMM_OVERFLOW, 2, NULL, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       else\n \tcsky_insn.inst |= (csky_insn.e1.X_add_number & 0xffff);\n@@ -7317,16 +7317,16 @@ v2_work_movih (void)\n \t{\n \t  void *arg = (void *)\"the second operand must be \\\"SYMBOL >> 16\\\"\";\n \t  csky_show_error (ERROR_UNDEFINE, 0, arg, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   csky_insn.isize = 4;\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_ori (void)\n {\n   int rz = csky_insn.val[0];\n@@ -7341,7 +7341,7 @@ v2_work_ori (void)\n       else\n \t{\n \t  csky_show_error (ERROR_IMM_OVERFLOW, 3, NULL, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   else if (csky_insn.e1.X_op == O_bit_and)\n@@ -7368,12 +7368,12 @@ v2_work_ori (void)\n \t{\n \t  void *arg = (void *)\"the third operand must be \\\"SYMBOL & 0xffff\\\"\";\n \t  csky_show_error (ERROR_UNDEFINE, 0, arg, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   csky_insn.isize = 4;\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n /* Helper function to encode a single/double floating point constant\n@@ -7384,7 +7384,7 @@ v2_work_ori (void)\n    rounding when converting to the smaller format, just an error if there\n    is excess precision or the number is too small/large to be represented.  */\n \n-bfd_boolean\n+bool\n float_work_fmovi (void)\n {\n   int rx = csky_insn.val[0];\n@@ -7397,13 +7397,13 @@ float_work_fmovi (void)\n   csky_insn.output = frag_more (4);\n   csky_insn.isize = 4;\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n /* Like float_work_fmovi, but for FPUV3 fmovi.16, fmovi.32 and fmovi.64\n    instructions.  */\n \n-bfd_boolean\n+bool\n float_work_fpuv3_fmovi (void)\n {\n   int rx = csky_insn.val[0];\n@@ -7428,7 +7428,7 @@ float_work_fpuv3_fmovi (void)\n       if (imm8 > 255)\n \t{\n \t  csky_show_error (ERROR_IMM_OVERFLOW, 2, NULL, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       /* imm8 store at bit [25:20] and [9:8].  */\n@@ -7448,10 +7448,10 @@ float_work_fpuv3_fmovi (void)\n   csky_insn.output = frag_more(4);\n   csky_insn.isize = 4;\n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n dsp_work_bloop (void)\n {\n   int reg = csky_insn.val[0];\n@@ -7489,10 +7489,10 @@ dsp_work_bloop (void)\n     }\n \n   csky_write_insn (csky_insn.output, csky_insn.inst, csky_insn.isize);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n float_work_fpuv3_fstore(void)\n {\n   /* Generate relax or reloc if necessary.  */\n@@ -7505,10 +7505,10 @@ float_work_fpuv3_fstore(void)\n                    csky_insn.isize);\n \n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n v2_work_addc (void)\n {\n   int reg1;\n@@ -7568,7 +7568,7 @@ v2_work_addc (void)\n \t\t   csky_insn.inst,\n \t\t   csky_insn.isize);\n \n-  return TRUE;\n+  return true;\n }\n \n /* The following are for assembler directive handling.  */"
    },
    {
      "sha": "cbc25d7f009dc47bbd0f0ec7276e944685619c80",
      "filename": "gas/config/tc-csky.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-csky.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-csky.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-csky.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -97,7 +97,7 @@ extern void csky_cons_fix_new (fragS *,\n \t\t\t       expressionS *,\n \t\t\t       bfd_reloc_code_real_type);\n extern int csky_force_relocation (fixS *);\n-extern bfd_boolean csky_fix_adjustable (fixS *);\n+extern bool csky_fix_adjustable (fixS *);\n extern void csky_cfi_frame_initial_instructions (void);\n extern int tc_csky_regname_to_dw2regnum (char *);\n extern long csky_relax_frag (segT, fragS *, long);"
    },
    {
      "sha": "1d92f34c43c373897d0b85362479204e4ddec367",
      "filename": "gas/config/tc-d10v.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-d10v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-d10v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-d10v.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -73,11 +73,11 @@ static packing_type etype = PACK_UNSPEC; /* Used by d10v_cleanup.  */\n \n /* TRUE if instruction swapping warnings should be inhibited.\n    --nowarnswap.  */\n-static bfd_boolean flag_warn_suppress_instructionswap;\n+static bool flag_warn_suppress_instructionswap;\n \n /* TRUE if instruction packing should be performed when --gstabs is specified.\n    --gstabs-packing, --no-gstabs-packing.  */\n-static bfd_boolean flag_allow_gstabs_packing = 1;\n+static bool flag_allow_gstabs_packing = 1;\n \n /* Local functions.  */\n \n@@ -254,7 +254,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n void\n@@ -1216,14 +1216,14 @@ find_opcode (struct d10v_opcode *opcode, expressionS myops[])\n \t\t  unsigned long current_position;\n \t\t  unsigned long symbol_position;\n \t\t  unsigned long value;\n-\t\t  bfd_boolean found_symbol;\n+\t\t  bool found_symbol;\n \n \t\t  /* Calculate the address of the current instruction\n \t\t     and the address of the symbol.  Do this by summing\n \t\t     the offsets of previous frags until we reach the\n \t\t     frag containing the symbol, and the current frag.  */\n \t\t  sym_frag = symbol_get_frag (myops[opnum].X_add_symbol);\n-\t\t  found_symbol = FALSE;\n+\t\t  found_symbol = false;\n \n \t\t  current_position = frag_now_fix_octets ();\n \t\t  symbol_position = S_GET_VALUE (myops[opnum].X_add_symbol);\n@@ -1233,7 +1233,7 @@ find_opcode (struct d10v_opcode *opcode, expressionS myops[])\n \t\t      current_position += f->fr_fix + f->fr_offset;\n \n \t\t      if (f == sym_frag)\n-\t\t\tfound_symbol = TRUE;\n+\t\t\tfound_symbol = true;\n \n \t\t      if (! found_symbol)\n \t\t\tsymbol_position += f->fr_fix + f->fr_offset;\n@@ -1698,7 +1698,7 @@ md_operand (expressionS *expressionP)\n     }\n }\n \n-bfd_boolean\n+bool\n d10v_fix_adjustable (fixS *fixP)\n {\n   /* We need the symbol name for the VTABLE entries.  */"
    },
    {
      "sha": "3b3ebfda3b9b7c6736ed6bf04bd341dcdb75cdff",
      "filename": "gas/config/tc-d10v.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-d10v.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-d10v.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-d10v.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -51,7 +51,7 @@ void d10v_frob_label (symbolS *);\n #define tc_frob_label(sym)\t     d10v_frob_label (sym)\n \n #define tc_fix_adjustable(FIX) d10v_fix_adjustable(FIX)\n-bfd_boolean d10v_fix_adjustable (struct fix *);\n+bool d10v_fix_adjustable (struct fix *);\n \n /* Values passed to md_apply_fix don't include the symbol value.  */\n #define MD_APPLY_SYM_VALUE(FIX) 0"
    },
    {
      "sha": "23b0b2a5bebc533e5cd9655a777718c8a6545056",
      "filename": "gas/config/tc-d30v.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-d30v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-d30v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-d30v.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -288,7 +288,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n void\n@@ -953,7 +953,7 @@ write_2_short (struct d30v_insn *opcode1,\n \t we are not optimizing, then we have been asked to produce\n \t an error about such constructs.  For the purposes of this\n \t test, subroutine calls are considered to be branches.  */\n-      write_1_short (opcode1, insn1, fx->next, FALSE);\n+      write_1_short (opcode1, insn1, fx->next, false);\n       return 1;\n     }\n \n@@ -993,14 +993,14 @@ write_2_short (struct d30v_insn *opcode1,\n \t  /* We must treat repeat instructions likewise, since the\n \t     following instruction has to be separate from the repeat\n \t     in order to be repeated.  */\n-\t  write_1_short (opcode1, insn1, fx->next, FALSE);\n+\t  write_1_short (opcode1, insn1, fx->next, false);\n \t  return 1;\n \t}\n       else if (prev_left_kills_right_p)\n \t{\n \t  /* The left instruction kills the right slot, so we\n \t     must leave it empty.  */\n-\t  write_1_short (opcode1, insn1, fx->next, FALSE);\n+\t  write_1_short (opcode1, insn1, fx->next, false);\n \t  return 1;\n \t}\n       else if (opcode1->op->unit == IU)\n@@ -1010,7 +1010,7 @@ write_2_short (struct d30v_insn *opcode1,\n \t      /* Case 103810 is a request from Mitsubishi that opcodes\n \t\t with EITHER_BUT_PREFER_MU should not be executed in\n \t\t reverse sequential order.  */\n-\t      write_1_short (opcode1, insn1, fx->next, FALSE);\n+\t      write_1_short (opcode1, insn1, fx->next, false);\n \t      return 1;\n \t    }\n \n@@ -1485,7 +1485,7 @@ d30v_align (int n, char *pfill, symbolS *label)\n      this alignment request.  The alignment of the current frag\n      can be changed under our feet, for example by a .ascii\n      directive in the source code.  cf testsuite/gas/d30v/reloc.s  */\n-  d30v_cleanup (FALSE);\n+  d30v_cleanup (false);\n \n   if (pfill == NULL)\n     {\n@@ -1512,7 +1512,7 @@ d30v_align (int n, char *pfill, symbolS *label)\n   if (label != NULL)\n     {\n       symbolS     *sym;\n-      int          label_seen = FALSE;\n+      int          label_seen = false;\n       struct frag *old_frag;\n       valueT       old_value;\n       valueT       new_value;\n@@ -1539,7 +1539,7 @@ d30v_align (int n, char *pfill, symbolS *label)\n \t  if (symbol_get_frag (sym) == old_frag\n \t      && S_GET_VALUE (sym) == old_value)\n \t    {\n-\t      label_seen = TRUE;\n+\t      label_seen = true;\n \t      symbol_set_frag (sym, frag_now);\n \t      S_SET_VALUE (sym, new_value);\n \t    }\n@@ -1575,7 +1575,7 @@ md_assemble (char *str)\n \n   if ((prev_insn != -1) && prev_seg\n       && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))\n-    d30v_cleanup (FALSE);\n+    d30v_cleanup (false);\n \n   if (d30v_current_align < 3)\n     d30v_align (3, NULL, d30v_last_label);\n@@ -1614,7 +1614,7 @@ md_assemble (char *str)\n \n \t  /* If two instructions are present and we already have one saved,\n \t     then first write it out.  */\n-\t  d30v_cleanup (FALSE);\n+\t  d30v_cleanup (false);\n \n \t  /* Assemble first instruction and save it.  */\n \t  prev_insn = do_assemble (str, &prev_opcode, 1, 0);\n@@ -1675,13 +1675,13 @@ md_assemble (char *str)\n \t     of NOPs for us.  */\n \n \t  if (prev_insn != -1 && (strcmp (prev_opcode.op->name, \"nop\") == 0))\n-\t    d30v_cleanup (FALSE);\n+\t    d30v_cleanup (false);\n \t  else\n \t    {\n \t      char *f;\n \n \t      if (prev_insn != -1)\n-\t\td30v_cleanup (TRUE);\n+\t\td30v_cleanup (true);\n \t      else\n \t\t{\n \t\t  f = frag_more (8);\n@@ -1707,7 +1707,7 @@ md_assemble (char *str)\n     {\n       /* Can't parallelize, flush current instruction and add a\n          sequential NOP.  */\n-      write_1_short (&opcode, (long) insn, fixups->next->next, TRUE);\n+      write_1_short (&opcode, (long) insn, fixups->next->next, true);\n \n       /* Make the previous instruction the current one.  */\n       extype = EXEC_UNKNOWN;\n@@ -1726,7 +1726,7 @@ md_assemble (char *str)\n     {\n       if (extype != EXEC_UNKNOWN)\n \tas_bad (_(\"Instruction uses long version, so it cannot be mixed as specified\"));\n-      d30v_cleanup (FALSE);\n+      d30v_cleanup (false);\n       write_long (&opcode, insn, fixups);\n       prev_insn = -1;\n     }\n@@ -1817,7 +1817,7 @@ d30v_cleanup (int use_sequential)\n       subseg_set (seg, subseg);\n       prev_insn = -1;\n       if (use_sequential)\n-\tprev_mul32_p = FALSE;\n+\tprev_mul32_p = false;\n     }\n \n   return 1;\n@@ -1836,7 +1836,7 @@ d30v_start_line (void)\n     c++;\n \n   if (*c == '.')\n-    d30v_cleanup (FALSE);\n+    d30v_cleanup (false);\n }\n \n static void\n@@ -1861,7 +1861,7 @@ void\n d30v_frob_label (symbolS *lab)\n {\n   /* Emit any pending instructions.  */\n-  d30v_cleanup (FALSE);\n+  d30v_cleanup (false);\n \n   /* Update the label's address with the current output pointer.  */\n   symbol_set_frag (lab, frag_now);"
    },
    {
      "sha": "1538c34452a2d4b6374738583d39c5922de50afc",
      "filename": "gas/config/tc-d30v.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-d30v.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-d30v.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-d30v.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -43,9 +43,9 @@\n #define md_number_to_chars           number_to_chars_bigendian\n \n int d30v_cleanup (int);\n-#define md_cleanup()\t\t     d30v_cleanup (FALSE)\n+#define md_cleanup()\t\t     d30v_cleanup (false)\n #define TC_START_LABEL(STR, NUL_CHAR, NEXT_CHAR)\t\\\n-  (NEXT_CHAR == ':' && d30v_cleanup (FALSE))\n+  (NEXT_CHAR == ':' && d30v_cleanup (false))\n void d30v_start_line (void);\n #define md_start_line_hook()\t     d30v_start_line ()\n "
    },
    {
      "sha": "56f576d562d2b3a11edfdebd0ac095cbfb9dd845",
      "filename": "gas/config/tc-dlx.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-dlx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-dlx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-dlx.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -968,7 +968,7 @@ md_assemble (char *str)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n /* Write out big-endian.  */\n@@ -978,7 +978,7 @@ md_number_to_chars (char *buf, valueT val, int n)\n   number_to_chars_bigendian (buf, val, n);\n }\n \n-bfd_boolean\n+bool\n md_dlx_fix_adjustable (fixS *fixP)\n {\n   /* We need the symbol name for the VTABLE entries.  */"
    },
    {
      "sha": "d91d0d1e3f18703fca4b419dcfd2ef499d003bd4",
      "filename": "gas/config/tc-dlx.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-dlx.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-dlx.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-dlx.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -39,7 +39,7 @@\n \n extern void dlx_pop_insert         (void);\n extern int dlx_unrecognized_line   (int);\n-extern bfd_boolean md_dlx_fix_adjustable  (struct fix *);\n+extern bool md_dlx_fix_adjustable  (struct fix *);\n \n #define md_pop_insert()\t\t        dlx_pop_insert ()\n "
    },
    {
      "sha": "d253bc2d49ec5738eb44f1ed245f2ceab653021e",
      "filename": "gas/config/tc-epiphany.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-epiphany.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-epiphany.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-epiphany.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -59,7 +59,7 @@ const char FLT_CHARS[]            = \"fFdD\";\n \n /* Flag to detect when switching to code section where insn alignment is\n    implied.  */\n-static bfd_boolean force_code_align = FALSE;\n+static bool force_code_align = false;\n \n static void\n epiphany_elf_section_rtn (int i)\n@@ -69,7 +69,7 @@ epiphany_elf_section_rtn (int i)\n   if (force_code_align)\n     {\n       do_align (1, NULL, 0, 0);\n-      force_code_align = FALSE;\n+      force_code_align = false;\n     }\n }\n \n@@ -79,7 +79,7 @@ epiphany_elf_section_text (int i)\n   obj_elf_text (i);\n \n   do_align (1, NULL, 0, 0);\n-  force_code_align = FALSE;\n+  force_code_align = false;\n }\n \n /* The target specific pseudo-ops which we support.  */\n@@ -146,7 +146,7 @@ md_begin (void)\n   /* Set the machine type.  */\n   bfd_default_set_arch_mach (stdoutput, bfd_arch_epiphany, bfd_mach_epiphany32);\n \n-  literal_prefix_dollar_hex = TRUE;\n+  literal_prefix_dollar_hex = true;\n }\n \n valueT\n@@ -184,7 +184,7 @@ epiphany_elf_section_flags (int flags,\n      executable section specifier we set an internal flag to denote when\n      word alignment should be forced.  */\n   if (flags & SEC_CODE)\n-    force_code_align = TRUE;\n+    force_code_align = true;\n \n   return flags;\n }\n@@ -222,16 +222,16 @@ struct epiphany_hi_fixup\n #define GOT_NAME \"_GLOBAL_OFFSET_TABLE_\"\n static symbolS * GOT_symbol;\n \n-static inline bfd_boolean\n+static inline bool\n epiphany_PIC_related_p (symbolS *sym)\n {\n   expressionS *exp;\n \n   if (! sym)\n-    return FALSE;\n+    return false;\n \n   if (sym == GOT_symbol)\n-    return TRUE;\n+    return true;\n \n   exp = symbol_get_value_expression (sym);\n \n@@ -1018,13 +1018,13 @@ md_cgen_lookup_reloc (const CGEN_INSN *insn ATTRIBUTE_UNUSED,\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \n /* Return true if can adjust the reloc to be relative to its section\n    (such as .data) instead of relative to some symbol.  */\n \n-bfd_boolean\n+bool\n epiphany_fix_adjustable (fixS *fixP)\n {\n  bfd_reloc_code_real_type reloc_type;\n@@ -1042,28 +1042,28 @@ epiphany_fix_adjustable (fixS *fixP)\n     reloc_type = fixP->fx_r_type;\n \n   if (fixP->fx_addsy == NULL)\n-    return TRUE;\n+    return true;\n \n   /* Prevent all adjustments to global symbols.  */\n   if (S_IS_EXTERNAL (fixP->fx_addsy))\n-    return FALSE;\n+    return false;\n \n   if (S_IS_WEAK (fixP->fx_addsy))\n-    return FALSE;\n+    return false;\n \n   if (pic_code\n       && (reloc_type == BFD_RELOC_EPIPHANY_SIMM24\n \t  || reloc_type == BFD_RELOC_EPIPHANY_SIMM8\n \t  || reloc_type == BFD_RELOC_EPIPHANY_HIGH\n \t  || reloc_type == BFD_RELOC_EPIPHANY_LOW))\n-    return FALSE;\n+    return false;\n \n   /* Since we don't use partial_inplace, we must not reduce symbols in\n      mergeable sections to their section symbol.  */\n   if ((S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n void"
    },
    {
      "sha": "e5412e84824955ce5bb18375a24a38b4ed724020",
      "filename": "gas/config/tc-epiphany.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-epiphany.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-epiphany.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-epiphany.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -46,7 +46,7 @@\n #define MD_APPLY_SYM_VALUE(FIX) 0\n \n #define tc_fix_adjustable(FIX) epiphany_fix_adjustable (FIX)\n-extern bfd_boolean epiphany_fix_adjustable (struct fix *);\n+extern bool epiphany_fix_adjustable (struct fix *);\n \n #define MD_PCREL_FROM_SECTION(FIXP, SEC) md_pcrel_from_section (FIXP,SEC)\n "
    },
    {
      "sha": "17416d83597186906cf2c89a68b178464cedd401",
      "filename": "gas/config/tc-fr30.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-fr30.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-fr30.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-fr30.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -320,7 +320,7 @@ md_number_to_chars (char * buf, valueT val, int n)\n const char *\n md_atof (int type, char * litP, int * sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n /* Worker function for fr30_is_colon_insn().  */\n@@ -409,7 +409,7 @@ fr30_is_colon_insn (char *start, char *nul_char)\n   return 0;\n }\n \n-bfd_boolean\n+bool\n fr30_fix_adjustable (fixS * fixP)\n {\n   /* We need the symbol name for the VTABLE entries.  */"
    },
    {
      "sha": "a652a6b14cb066a3cd30d8f1f9d6e4359e3c5ad9",
      "filename": "gas/config/tc-fr30.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-fr30.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-fr30.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-fr30.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -44,7 +44,7 @@\n \n #define tc_fix_adjustable(FIX) fr30_fix_adjustable (FIX)\n struct fix;\n-extern bfd_boolean fr30_fix_adjustable (struct fix *);\n+extern bool fr30_fix_adjustable (struct fix *);\n \n #define tc_gen_reloc gas_cgen_tc_gen_reloc\n "
    },
    {
      "sha": "7b31263ec4c5502148c4a0abf4f904dff25a6d5d",
      "filename": "gas/config/tc-frv.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-frv.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -65,8 +65,8 @@ enum vliw_insn_type\n #define NOP_KEEP 1\t\t/* Keep these NOPS.  */\n #define NOP_DELETE 2\t\t/* Delete these NOPS.  */\n \n-#define DO_COUNT    TRUE\n-#define DONT_COUNT  FALSE\n+#define DO_COUNT    true\n+#define DONT_COUNT  false\n \n /* A list of insns within a VLIW insn.  */\n struct vliw_insn_list\n@@ -168,7 +168,7 @@ static FRV_VLIW vliw;\n #endif\n \n static unsigned long frv_mach = bfd_mach_frv;\n-static bfd_boolean fr400_audio;\n+static bool fr400_audio;\n \n /* Flags to set in the elf header */\n static flagword frv_flags = DEFAULT_FLAGS | DEFAULT_FDPIC;\n@@ -369,14 +369,14 @@ md_parse_option (int c, const char *arg)\n \t  {\n \t    cpu_flags = EF_FRV_CPU_FR405;\n \t    frv_mach = bfd_mach_fr400;\n-\t    fr400_audio = TRUE;\n+\t    fr400_audio = true;\n \t  }\n \n \telse if (strcmp (p, \"fr400\") == 0)\n \t  {\n \t    cpu_flags = EF_FRV_CPU_FR400;\n \t    frv_mach = bfd_mach_fr400;\n-\t    fr400_audio = FALSE;\n+\t    fr400_audio = false;\n \t  }\n \n \telse if (strcmp (p, \"fr300\") == 0)\n@@ -507,7 +507,7 @@ md_begin (void)\n   frv_vliw_reset (& vliw, frv_mach, frv_flags);\n }\n \n-bfd_boolean\n+bool\n frv_md_fdpic_enabled (void)\n {\n   return (frv_flags & EF_FRV_FDPIC) != 0;\n@@ -516,7 +516,7 @@ frv_md_fdpic_enabled (void)\n int chain_num = 0;\n \n static struct vliw_insn_list *\n-frv_insert_vliw_insn (bfd_boolean count)\n+frv_insert_vliw_insn (bool count)\n {\n   struct vliw_insn_list *vliw_insn_list_entry;\n   struct vliw_chain     *vliw_chain_entry;\n@@ -672,7 +672,7 @@ frv_tomcat_shuffle (enum vliw_nop_type this_nop_type,\n \t\t    struct vliw_insn_list *insert_before_insn)\n {\n \n-  bfd_boolean pack_prev = FALSE;\n+  bool pack_prev = false;\n   struct vliw_chain *return_me = NULL;\n   struct vliw_insn_list *prev_insn = NULL;\n   struct vliw_insn_list *curr_insn = vliw_to_split->insn_list;\n@@ -693,7 +693,7 @@ frv_tomcat_shuffle (enum vliw_nop_type this_nop_type,\n \tThen don't set pack bit later.  */\n \n       if (curr_insn->type != VLIW_LABEL_TYPE)\n-\tpack_prev = TRUE;\n+\tpack_prev = true;\n       prev_insn = curr_insn;\n       curr_insn = curr_insn->next;\n     }\n@@ -1055,14 +1055,14 @@ fr550_check_acc_range (FRV_VLIW *vlw, frv_insn *insn)\n \n /* Return true if the target implements instruction INSN.  */\n \n-static bfd_boolean\n+static bool\n target_implements_insn_p (const CGEN_INSN *insn)\n {\n   switch (frv_mach)\n     {\n     default:\n       /* bfd_mach_frv or generic.  */\n-      return TRUE;\n+      return true;\n \n     case bfd_mach_fr300:\n     case bfd_mach_frvsimple:\n@@ -1336,11 +1336,11 @@ md_cgen_lookup_reloc (const CGEN_INSN *insn ATTRIBUTE_UNUSED,\n   switch (operand->type)\n     {\n     case FRV_OPERAND_LABEL16:\n-      fixP->fx_pcrel = TRUE;\n+      fixP->fx_pcrel = true;\n       return BFD_RELOC_FRV_LABEL16;\n \n     case FRV_OPERAND_LABEL24:\n-      fixP->fx_pcrel = TRUE;\n+      fixP->fx_pcrel = true;\n \n       if (fixP->fx_cgen.opinfo != 0)\n \treturn fixP->fx_cgen.opinfo;\n@@ -1515,10 +1515,10 @@ frv_md_number_to_chars (char *buf, valueT val, int n)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n-bfd_boolean\n+bool\n frv_fix_adjustable (fixS *fixP)\n {\n   bfd_reloc_code_real_type reloc_type;"
    },
    {
      "sha": "8b6cdd9de3eedb2586b3b2dedefa4f10791202b6",
      "filename": "gas/config/tc-frv.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-frv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-frv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-frv.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -27,7 +27,7 @@\n \n #define TARGET_FORMAT (frv_md_fdpic_enabled () \\\n \t\t       ? \"elf32-frvfdpic\" : \"elf32-frv\")\n-extern bfd_boolean frv_md_fdpic_enabled (void);\n+extern bool frv_md_fdpic_enabled (void);\n \n #define TARGET_BYTES_BIG_ENDIAN 1\n \n@@ -53,7 +53,7 @@ extern long frv_relax_frag (fragS *, long);\n \n #define tc_fix_adjustable(FIX) frv_fix_adjustable (FIX)\n struct fix;\n-extern bfd_boolean frv_fix_adjustable (struct fix *);\n+extern bool frv_fix_adjustable (struct fix *);\n \n /* When relaxing, we need to emit various relocs we otherwise wouldn't.  */\n #define TC_FORCE_RELOCATION(fix) frv_force_relocation (fix)"
    },
    {
      "sha": "91b8c36ec1836744951bd54b3d3bfd731a808c47",
      "filename": "gas/config/tc-ft32.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ft32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ft32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ft32.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -207,9 +207,9 @@ md_assemble (char *str)\n   unsigned int b;\n   int f;\n   expressionS arg;\n-  bfd_boolean fixed = FALSE;\n+  bool fixed = false;\n   unsigned int sc;\n-  bfd_boolean can_sc;\n+  bool can_sc;\n \n   /* Drop leading whitespace.  */\n   while (*str == ' ')\n@@ -313,7 +313,7 @@ md_assemble (char *str)\n \t\t{\n \t\t  b |= 0x400 << FT32_FLD_RIMM_BIT;\n \t\t  op_end = parse_exp_save_ilp (op_end, &arg);\n-\t\t  fixed = TRUE;\n+\t\t  fixed = true;\n \t\t  fix_new_exp (frag_now,\n \t\t\t       (output - frag_now->fr_literal),\n \t\t\t       2,\n@@ -327,7 +327,7 @@ md_assemble (char *str)\n \t      break;\n \t    case  FT32_FLD_K20:\n \t      op_end = parse_exp_save_ilp (op_end, &arg);\n-\t      fixed = TRUE;\n+\t      fixed = true;\n \t      fix_new_exp (frag_now,\n \t\t\t   (output - frag_now->fr_literal),\n \t\t\t   3,\n@@ -337,7 +337,7 @@ md_assemble (char *str)\n \t      break;\n \t    case  FT32_FLD_PA:\n \t      op_end = parse_exp_save_ilp (op_end, &arg);\n-\t      fixed = TRUE;\n+\t      fixed = true;\n \t      fix_new_exp (frag_now,\n \t\t\t   (output - frag_now->fr_literal),\n \t\t\t   3,\n@@ -347,7 +347,7 @@ md_assemble (char *str)\n \t      break;\n \t    case  FT32_FLD_AA:\n \t      op_end = parse_exp_save_ilp (op_end, &arg);\n-\t      fixed = TRUE;\n+\t      fixed = true;\n \t      fix_new_exp (frag_now,\n \t\t\t   (output - frag_now->fr_literal),\n \t\t\t   3,\n@@ -357,7 +357,7 @@ md_assemble (char *str)\n \t      break;\n \t    case  FT32_FLD_K16:\n \t      op_end = parse_exp_save_ilp (op_end, &arg);\n-\t      fixed = TRUE;\n+\t      fixed = true;\n \t      fix_new_exp (frag_now,\n \t\t\t   (output - frag_now->fr_literal),\n \t\t\t   2,\n@@ -369,7 +369,7 @@ md_assemble (char *str)\n \t      op_end = parse_exp_save_ilp (op_end, &arg);\n \t      if (arg.X_add_number & 0x80)\n \t\targ.X_add_number ^= 0x7f00;\n-\t      fixed = TRUE;\n+\t      fixed = true;\n \t      fix_new_exp (frag_now,\n \t\t\t   (output - frag_now->fr_literal),\n \t\t\t   2,\n@@ -716,7 +716,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixP)\n \n /* TC_FORCE_RELOCATION hook */\n \n-static bfd_boolean\n+static bool\n relaxable_section (asection *sec)\n {\n   return ((sec->flags & SEC_DEBUGGING) == 0\n@@ -769,24 +769,24 @@ ft32_force_relocation (fixS *fix)\n   return generic_force_reloc (fix);\n }\n \n-bfd_boolean\n+bool\n ft32_allow_local_subtract (expressionS * left,\n \t\t\t   expressionS * right,\n \t\t\t   segT section)\n {\n   /* If we are not in relaxation mode, subtraction is OK.  */\n   if (!linkrelax)\n-    return TRUE;\n+    return true;\n \n   /* If the symbols are not in a code section then they are OK.  */\n   if ((section->flags & SEC_CODE) == 0)\n-    return TRUE;\n+    return true;\n \n   if (left->X_add_symbol == right->X_add_symbol)\n-    return TRUE;\n+    return true;\n \n   /* We have to assume that there may be instructions between the\n      two symbols and that relaxation may increase the distance between\n      them.  */\n-  return FALSE;\n+  return false;\n }"
    },
    {
      "sha": "93d497f083970bb7ff6798b9413b4c8423b8678d",
      "filename": "gas/config/tc-ft32.h",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ft32.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ft32.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ft32.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -61,8 +61,6 @@ extern int ft32_validate_fix_sub (struct fix *);\n /* The difference between same-section symbols may be affected by linker\n    relaxation, so do not resolve such expressions in the assembler.  */\n #define md_allow_local_subtract(l,r,s) ft32_allow_local_subtract (l, r, s)\n-extern bfd_boolean ft32_allow_local_subtract (expressionS *,\n-                                              expressionS *,\n-                                              segT);\n+extern bool ft32_allow_local_subtract (expressionS *, expressionS *, segT);\n \n #define md_operand(x)"
    },
    {
      "sha": "b75b9433fdecc4c7faca2fb43c62001798f164ce",
      "filename": "gas/config/tc-h8300.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-h8300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-h8300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-h8300.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -2074,7 +2074,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \f\n #define OPTION_H_TICK_HEX      (OPTION_MD_BASE)"
    },
    {
      "sha": "b90d62221bff282a68f3533d2f37484492dc8bad",
      "filename": "gas/config/tc-hppa.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-hppa.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -1322,7 +1322,7 @@ pa_parse_nullif (char **s)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n /* Write out big-endian.  */\n@@ -2029,7 +2029,7 @@ pa_parse_number (char **s, int is_float)\n   symbolS *sym;\n   int status;\n   char *p = *s;\n-  bfd_boolean have_prefix;\n+  bool have_prefix;\n \n   /* Skip whitespace before the number.  */\n   while (*p == ' ' || *p == '\\t')\n@@ -2168,7 +2168,7 @@ pa_parse_number (char **s, int is_float)\n \t      num = S_GET_VALUE (sym);\n \t      /* Well, we don't really have one, but we do have a\n \t\t register, so...  */\n-\t      have_prefix = TRUE;\n+\t      have_prefix = true;\n \t    }\n \t  else if (S_GET_SEGMENT (sym) == bfd_abs_section_ptr)\n \t    num = S_GET_VALUE (sym);\n@@ -2223,10 +2223,10 @@ need_pa11_opcode (void)\n \t  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, pa11))\n \t    as_warn (_(\"could not update architecture and machine\"));\n \t}\n-      return TRUE;\n+      return true;\n     }\n   else\n-    return FALSE;\n+    return false;\n }\n \n /* Parse a condition for a fcmp instruction.  Return the numerical\n@@ -3170,7 +3170,7 @@ pa_ip (char *str)\n   const char *error_message = \"\";\n   char *s, c, *argstart, *name, *save_s;\n   const char *args;\n-  int match = FALSE;\n+  int match = false;\n   int comma = 0;\n   int cmpltr, nullif, flag, cond, need_cond, num;\n   int immediate_check = 0, pos = -1, len = -1;\n@@ -3253,7 +3253,7 @@ pa_ip (char *str)\n \t    /* End of arguments.  */\n \t    case '\\0':\n \t      if (*s == '\\0')\n-\t\tmatch = TRUE;\n+\t\tmatch = true;\n \t      break;\n \n \t    case '+':\n@@ -5690,7 +5690,7 @@ pa_ip (char *str)\n \t  && !bfd_set_arch_mach (stdoutput, bfd_arch_hppa, insn->arch))\n \t{\n \t  as_warn (_(\"could not update architecture and machine\"));\n-\t  match = FALSE;\n+\t  match = false;\n \t}\n \n  failed:\n@@ -6070,7 +6070,7 @@ pa_callinfo (int unused ATTRIBUTE_UNUSED)\n \n   /* Mark the fact that we found the .CALLINFO for the\n      current procedure.  */\n-  callinfo_found = TRUE;\n+  callinfo_found = true;\n \n   /* Iterate over the .CALLINFO arguments.  */\n   while (!is_end_of_statement ())\n@@ -6304,7 +6304,7 @@ pa_entry (int unused ATTRIBUTE_UNUSED)\n \tas_bad (_(\"Missing .callinfo.\"));\n     }\n   demand_empty_rest_of_line ();\n-  within_entry_exit = TRUE;\n+  within_entry_exit = true;\n \n #ifdef OBJ_SOM\n   /* SOM defers building of unwind descriptors until the link phase.\n@@ -6510,7 +6510,7 @@ pa_exit (int unused ATTRIBUTE_UNUSED)\n \t    as_bad (_(\"No .ENTRY for this .EXIT\"));\n \t  else\n \t    {\n-\t      within_entry_exit = FALSE;\n+\t      within_entry_exit = false;\n \t      process_exit ();\n \t    }\n \t}\n@@ -6907,8 +6907,8 @@ pa_proc (int unused ATTRIBUTE_UNUSED)\n     as_fatal (_(\"Nested procedures\"));\n \n   /* Reset global variables for new procedure.  */\n-  callinfo_found = FALSE;\n-  within_procedure = TRUE;\n+  callinfo_found = false;\n+  within_procedure = true;\n \n   /* Create another call_info structure.  */\n   call_info = XNEW (struct call_info);\n@@ -7026,7 +7026,7 @@ pa_procend (int unused ATTRIBUTE_UNUSED)\n   hppa_elf_mark_end_of_function ();\n #endif\n \n-  within_procedure = FALSE;\n+  within_procedure = false;\n   demand_empty_rest_of_line ();\n   pa_undefine_label ();\n }\n@@ -7077,9 +7077,9 @@ pa_parse_space_stmt (const char *space_name, int create_flag)\n   /* Load default values.  */\n   spnum = 0;\n   sort = 0;\n-  loadable = TRUE;\n-  defined = TRUE;\n-  private = FALSE;\n+  loadable = true;\n+  defined = true;\n+  private = false;\n   if (strcmp (space_name, \"$TEXT$\") == 0)\n     {\n       seg = pa_def_spaces[0].segment;\n@@ -7099,7 +7099,7 @@ pa_parse_space_stmt (const char *space_name, int create_flag)\n \n   if (!is_end_of_statement ())\n     {\n-      print_errors = FALSE;\n+      print_errors = false;\n       ptemp = input_line_pointer + 1;\n       /* First see if the space was specified as a number rather than\n \t as a name.  According to the PA assembly manual the rest of\n@@ -7132,17 +7132,17 @@ pa_parse_space_stmt (const char *space_name, int create_flag)\n \t      else if ((strncasecmp (name, \"unloadable\", 10) == 0))\n \t\t{\n \t\t  (void) restore_line_pointer (c);\n-\t\t  loadable = FALSE;\n+\t\t  loadable = false;\n \t\t}\n \t      else if ((strncasecmp (name, \"notdefined\", 10) == 0))\n \t\t{\n \t\t  (void) restore_line_pointer (c);\n-\t\t  defined = FALSE;\n+\t\t  defined = false;\n \t\t}\n \t      else if ((strncasecmp (name, \"private\", 7) == 0))\n \t\t{\n \t\t  (void) restore_line_pointer (c);\n-\t\t  private = TRUE;\n+\t\t  private = true;\n \t\t}\n \t      else\n \t\t{\n@@ -7153,7 +7153,7 @@ pa_parse_space_stmt (const char *space_name, int create_flag)\n \t\t}\n \t    }\n \t}\n-      print_errors = TRUE;\n+      print_errors = true;\n     }\n \n   if (create_flag && seg == NULL)"
    },
    {
      "sha": "3c01b5ee9e27696b3bfc5e8a4311c2b4b126e7f0",
      "filename": "gas/config/tc-i386-intel.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-i386-intel.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-i386-intel.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386-intel.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -767,19 +767,19 @@ i386_intel_operand (char *operand_string, int got_a_float)\n       || current_templates->start->opcode_modifier.jump == JUMP_DWORD\n       || current_templates->start->opcode_modifier.jump == JUMP_INTERSEGMENT)\n     {\n-      bfd_boolean jumpabsolute = FALSE;\n+      bool jumpabsolute = false;\n \n       if (i.op[this_operand].regs\n \t  || intel_state.base\n \t  || intel_state.index\n \t  || intel_state.is_mem > 1)\n-\tjumpabsolute = TRUE;\n+\tjumpabsolute = true;\n       else\n \tswitch (intel_state.op_modifier)\n \t  {\n \t  case O_near_ptr:\n \t    if (intel_state.seg)\n-\t      jumpabsolute = TRUE;\n+\t      jumpabsolute = true;\n \t    else\n \t      intel_state.is_mem = 1;\n \t    break;\n@@ -791,14 +791,14 @@ i386_intel_operand (char *operand_string, int got_a_float)\n \t\tif (intel_state.op_modifier == O_absent)\n \t\t  {\n \t\t    if (intel_state.is_indirect == 1)\n-\t\t      jumpabsolute = TRUE;\n+\t\t      jumpabsolute = true;\n \t\t    break;\n \t\t  }\n \t\tas_bad (_(\"cannot infer the segment part of the operand\"));\n \t\treturn 0;\n \t      }\n \t    else if (S_GET_SEGMENT (intel_state.seg) == reg_section)\n-\t      jumpabsolute = TRUE;\n+\t      jumpabsolute = true;\n \t    else\n \t      {\n \t\ti386_operand_type types;\n@@ -832,12 +832,12 @@ i386_intel_operand (char *operand_string, int got_a_float)\n \t      }\n \t    break;\n \t  default:\n-\t    jumpabsolute = TRUE;\n+\t    jumpabsolute = true;\n \t    break;\n \t  }\n       if (jumpabsolute)\n \t{\n-\t  i.jumpabsolute = TRUE;\n+\t  i.jumpabsolute = true;\n \t  intel_state.is_mem |= 1;\n \t}\n     }"
    },
    {
      "sha": "8937ddfce1e21950e8d5fd8c225c447d03b336a8",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 68,
      "deletions": 68,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -322,10 +322,10 @@ struct _i386_insn\n     unsigned char prefix[MAX_PREFIXES];\n \n     /* Register is in low 3 bits of opcode.  */\n-    bfd_boolean short_form;\n+    bool short_form;\n \n     /* The operand to a branch insn indicates an absolute branch.  */\n-    bfd_boolean jumpabsolute;\n+    bool jumpabsolute;\n \n     /* Extended states.  */\n     enum\n@@ -345,7 +345,7 @@ struct _i386_insn\n       } xstate;\n \n     /* Has GOTPC or TLS relocation.  */\n-    bfd_boolean has_gotpc_tls_reloc;\n+    bool has_gotpc_tls_reloc;\n \n     /* RM and SIB are the modrm byte and the sib byte where the\n        addressing modes of this insn are encoded.  */\n@@ -422,10 +422,10 @@ struct _i386_insn\n       } disp_encoding;\n \n     /* Prefer the REX byte in encoding.  */\n-    bfd_boolean rex_encoding;\n+    bool rex_encoding;\n \n     /* Disable instruction size optimization.  */\n-    bfd_boolean no_optimize;\n+    bool no_optimize;\n \n     /* How to encode vector instructions.  */\n     enum\n@@ -3806,15 +3806,15 @@ build_vex_prefix (const insn_template *t)\n     }\n }\n \n-static INLINE bfd_boolean\n+static INLINE bool\n is_evex_encoding (const insn_template *t)\n {\n   return t->opcode_modifier.evex || t->opcode_modifier.disp8memshift\n \t || t->opcode_modifier.broadcast || t->opcode_modifier.masking\n \t || t->opcode_modifier.sae;\n }\n \n-static INLINE bfd_boolean\n+static INLINE bool\n is_any_vex_encoding (const insn_template *t)\n {\n   return t->opcode_modifier.vex || is_evex_encoding (t);\n@@ -5022,7 +5022,7 @@ md_assemble (char *line)\n \t    && i.op[x].regs->reg_num > 3)\n \t  {\n \t    gas_assert (!(i.op[x].regs->reg_flags & RegRex));\n-\t    i.rex_encoding = FALSE;\n+\t    i.rex_encoding = false;\n \t    break;\n \t  }\n \n@@ -5164,11 +5164,11 @@ parse_insn (char *line, char *mnemonic)\n \t\t  break;\n \t\tcase Prefix_REX:\n \t\t  /* {rex} */\n-\t\t  i.rex_encoding = TRUE;\n+\t\t  i.rex_encoding = true;\n \t\t  break;\n \t\tcase Prefix_NoOptimize:\n \t\t  /* {nooptimize} */\n-\t\t  i.no_optimize = TRUE;\n+\t\t  i.no_optimize = true;\n \t\t  break;\n \t\tdefault:\n \t\t  abort ();\n@@ -6375,7 +6375,7 @@ match_template (char mnem_suffix)\n \t      break;\n \t  if (j < MAX_OPERANDS)\n \t    {\n-\t      bfd_boolean override = (i.prefix[ADDR_PREFIX] != 0);\n+\t      bool override = (i.prefix[ADDR_PREFIX] != 0);\n \n \t      addr_prefix_disp = j;\n \n@@ -6785,7 +6785,7 @@ check_string (void)\n static int\n process_suffix (void)\n {\n-  bfd_boolean is_crc32 = FALSE, is_movx = FALSE;\n+  bool is_crc32 = false, is_movx = false;\n \n   /* If matched instruction specifies an explicit instruction mnemonic\n      suffix, use it.  */\n@@ -7810,7 +7810,7 @@ process_operands (void)\n }\n \n static INLINE void set_rex_vrex (const reg_entry *r, unsigned int rex_bit,\n-\t\t\t\t bfd_boolean do_sse2avx)\n+\t\t\t\t bool do_sse2avx)\n {\n   if (r->reg_flags & RegRex)\n     {\n@@ -8042,14 +8042,14 @@ build_modrm_byte (void)\n \t  i.rm.reg = i.op[dest].regs->reg_num;\n \t  i.rm.regmem = i.op[source].regs->reg_num;\n \t  set_rex_vrex (i.op[dest].regs, REX_R, i.tm.opcode_modifier.sse2avx);\n-\t  set_rex_vrex (i.op[source].regs, REX_B, FALSE);\n+\t  set_rex_vrex (i.op[source].regs, REX_B, false);\n \t}\n       else\n \t{\n \t  i.rm.reg = i.op[source].regs->reg_num;\n \t  i.rm.regmem = i.op[dest].regs->reg_num;\n \t  set_rex_vrex (i.op[dest].regs, REX_B, i.tm.opcode_modifier.sse2avx);\n-\t  set_rex_vrex (i.op[source].regs, REX_R, FALSE);\n+\t  set_rex_vrex (i.op[source].regs, REX_R, false);\n \t}\n       if (flag_code != CODE_64BIT && (i.rex & REX_R))\n \t{\n@@ -8111,7 +8111,7 @@ build_modrm_byte (void)\n \t\t    i.sib.index = NO_INDEX_REGISTER;\n \t\t  else\n \t\t    i.sib.index = i.index_reg->reg_num;\n-\t\t  set_rex_vrex (i.index_reg, REX_X, FALSE);\n+\t\t  set_rex_vrex (i.index_reg, REX_X, false);\n \t\t}\n \t    }\n \n@@ -8628,41 +8628,41 @@ output_branch (void)\n /* Return TRUE iff PLT32 relocation should be used for branching to\n    symbol S.  */\n \n-static bfd_boolean\n+static bool\n need_plt32_p (symbolS *s)\n {\n   /* PLT32 relocation is ELF only.  */\n   if (!IS_ELF)\n-    return FALSE;\n+    return false;\n \n #ifdef TE_SOLARIS\n   /* Don't emit PLT32 relocation on Solaris: neither native linker nor\n      krtld support it.  */\n-  return FALSE;\n+  return false;\n #endif\n \n   /* Since there is no need to prepare for PLT branch on x86-64, we\n      can generate R_X86_64_PLT32, instead of R_X86_64_PC32, which can\n      be used as a marker for 32-bit PC-relative branches.  */\n   if (!object_64bit)\n-    return FALSE;\n+    return false;\n \n   if (s == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Weak or undefined symbol need PLT32 relocation.  */\n   if (S_IS_WEAK (s) || !S_IS_DEFINED (s))\n-    return TRUE;\n+    return true;\n \n   /* Non-global symbol doesn't need PLT32 relocation.  */\n   if (! S_IS_EXTERNAL (s))\n-    return FALSE;\n+    return false;\n \n   /* Other global symbols need PLT32 relocation.  NB: Symbol with\n      non-default visibilities are treated as normal global symbol\n      so that PLT32 relocation can be used as a marker for 32-bit\n      PC-relative branches.  It is useful for linker relaxation.  */\n-  return TRUE;\n+  return true;\n }\n #endif\n \n@@ -9815,7 +9815,7 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)\n \t\t  if (!object_64bit)\n \t\t    {\n \t\t      reloc_type = BFD_RELOC_386_GOTPC;\n-\t\t      i.has_gotpc_tls_reloc = TRUE;\n+\t\t      i.has_gotpc_tls_reloc = true;\n \t\t      i.op[n].imms->X_add_number +=\n \t\t\tencoding_length (insn_start_frag, insn_start_off, p);\n \t\t    }\n@@ -9843,7 +9843,7 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)\n \t\t    case BFD_RELOC_X86_64_GOTTPOFF:\n \t\t    case BFD_RELOC_X86_64_GOTPC32_TLSDESC:\n \t\t    case BFD_RELOC_X86_64_TLSDESC_CALL:\n-\t\t      i.has_gotpc_tls_reloc = TRUE;\n+\t\t      i.has_gotpc_tls_reloc = true;\n \t\t    default:\n \t\t      break;\n \t\t    }\n@@ -9992,7 +9992,7 @@ output_imm (fragS *insn_start_frag, offsetT insn_start_off)\n \t\t    reloc_type = BFD_RELOC_X86_64_GOTPC32;\n \t\t  else if (size == 8)\n \t\t    reloc_type = BFD_RELOC_X86_64_GOTPC64;\n-\t\t  i.has_gotpc_tls_reloc = TRUE;\n+\t\t  i.has_gotpc_tls_reloc = true;\n \t\t  i.op[n].imms->X_add_number +=\n \t\t    encoding_length (insn_start_frag, insn_start_off, p);\n \t\t}\n@@ -10063,64 +10063,64 @@ lex_got (enum bfd_reloc_code_real *rel,\n     int len;\n     const enum bfd_reloc_code_real rel[2];\n     const i386_operand_type types64;\n-    bfd_boolean need_GOT_symbol;\n+    bool need_GOT_symbol;\n   } gotrel[] = {\n #if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)\n     { STRING_COMMA_LEN (\"SIZE\"),      { BFD_RELOC_SIZE32,\n \t\t\t\t\tBFD_RELOC_SIZE32 },\n-      OPERAND_TYPE_IMM32_64, FALSE },\n+      OPERAND_TYPE_IMM32_64, false },\n #endif\n     { STRING_COMMA_LEN (\"PLTOFF\"),   { _dummy_first_bfd_reloc_code_real,\n \t\t\t\t       BFD_RELOC_X86_64_PLTOFF64 },\n-      OPERAND_TYPE_IMM64, TRUE },\n+      OPERAND_TYPE_IMM64, true },\n     { STRING_COMMA_LEN (\"PLT\"),      { BFD_RELOC_386_PLT32,\n \t\t\t\t       BFD_RELOC_X86_64_PLT32    },\n-      OPERAND_TYPE_IMM32_32S_DISP32, FALSE },\n+      OPERAND_TYPE_IMM32_32S_DISP32, false },\n     { STRING_COMMA_LEN (\"GOTPLT\"),   { _dummy_first_bfd_reloc_code_real,\n \t\t\t\t       BFD_RELOC_X86_64_GOTPLT64 },\n-      OPERAND_TYPE_IMM64_DISP64, TRUE },\n+      OPERAND_TYPE_IMM64_DISP64, true },\n     { STRING_COMMA_LEN (\"GOTOFF\"),   { BFD_RELOC_386_GOTOFF,\n \t\t\t\t       BFD_RELOC_X86_64_GOTOFF64 },\n-      OPERAND_TYPE_IMM64_DISP64, TRUE },\n+      OPERAND_TYPE_IMM64_DISP64, true },\n     { STRING_COMMA_LEN (\"GOTPCREL\"), { _dummy_first_bfd_reloc_code_real,\n \t\t\t\t       BFD_RELOC_X86_64_GOTPCREL },\n-      OPERAND_TYPE_IMM32_32S_DISP32, TRUE },\n+      OPERAND_TYPE_IMM32_32S_DISP32, true },\n     { STRING_COMMA_LEN (\"TLSGD\"),    { BFD_RELOC_386_TLS_GD,\n \t\t\t\t       BFD_RELOC_X86_64_TLSGD    },\n-      OPERAND_TYPE_IMM32_32S_DISP32, TRUE },\n+      OPERAND_TYPE_IMM32_32S_DISP32, true },\n     { STRING_COMMA_LEN (\"TLSLDM\"),   { BFD_RELOC_386_TLS_LDM,\n \t\t\t\t       _dummy_first_bfd_reloc_code_real },\n-      OPERAND_TYPE_NONE, TRUE },\n+      OPERAND_TYPE_NONE, true },\n     { STRING_COMMA_LEN (\"TLSLD\"),    { _dummy_first_bfd_reloc_code_real,\n \t\t\t\t       BFD_RELOC_X86_64_TLSLD    },\n-      OPERAND_TYPE_IMM32_32S_DISP32, TRUE },\n+      OPERAND_TYPE_IMM32_32S_DISP32, true },\n     { STRING_COMMA_LEN (\"GOTTPOFF\"), { BFD_RELOC_386_TLS_IE_32,\n \t\t\t\t       BFD_RELOC_X86_64_GOTTPOFF },\n-      OPERAND_TYPE_IMM32_32S_DISP32, TRUE },\n+      OPERAND_TYPE_IMM32_32S_DISP32, true },\n     { STRING_COMMA_LEN (\"TPOFF\"),    { BFD_RELOC_386_TLS_LE_32,\n \t\t\t\t       BFD_RELOC_X86_64_TPOFF32  },\n-      OPERAND_TYPE_IMM32_32S_64_DISP32_64, TRUE },\n+      OPERAND_TYPE_IMM32_32S_64_DISP32_64, true },\n     { STRING_COMMA_LEN (\"NTPOFF\"),   { BFD_RELOC_386_TLS_LE,\n \t\t\t\t       _dummy_first_bfd_reloc_code_real },\n-      OPERAND_TYPE_NONE, TRUE },\n+      OPERAND_TYPE_NONE, true },\n     { STRING_COMMA_LEN (\"DTPOFF\"),   { BFD_RELOC_386_TLS_LDO_32,\n \t\t\t\t       BFD_RELOC_X86_64_DTPOFF32 },\n-      OPERAND_TYPE_IMM32_32S_64_DISP32_64, TRUE },\n+      OPERAND_TYPE_IMM32_32S_64_DISP32_64, true },\n     { STRING_COMMA_LEN (\"GOTNTPOFF\"),{ BFD_RELOC_386_TLS_GOTIE,\n \t\t\t\t       _dummy_first_bfd_reloc_code_real },\n-      OPERAND_TYPE_NONE, TRUE },\n+      OPERAND_TYPE_NONE, true },\n     { STRING_COMMA_LEN (\"INDNTPOFF\"),{ BFD_RELOC_386_TLS_IE,\n \t\t\t\t       _dummy_first_bfd_reloc_code_real },\n-      OPERAND_TYPE_NONE, TRUE },\n+      OPERAND_TYPE_NONE, true },\n     { STRING_COMMA_LEN (\"GOT\"),      { BFD_RELOC_386_GOT32,\n \t\t\t\t       BFD_RELOC_X86_64_GOT32    },\n-      OPERAND_TYPE_IMM32_32S_64_DISP32, TRUE },\n+      OPERAND_TYPE_IMM32_32S_64_DISP32, true },\n     { STRING_COMMA_LEN (\"TLSDESC\"),  { BFD_RELOC_386_TLS_GOTDESC,\n \t\t\t\t       BFD_RELOC_X86_64_GOTPC32_TLSDESC },\n-      OPERAND_TYPE_IMM32_32S_DISP32, TRUE },\n+      OPERAND_TYPE_IMM32_32S_DISP32, true },\n     { STRING_COMMA_LEN (\"TLSCALL\"),  { BFD_RELOC_386_TLS_DESC_CALL,\n \t\t\t\t       BFD_RELOC_X86_64_TLSDESC_CALL },\n-      OPERAND_TYPE_IMM32_32S_DISP32, TRUE },\n+      OPERAND_TYPE_IMM32_32S_DISP32, true },\n   };\n   char *cp;\n   unsigned int j;\n@@ -10757,7 +10757,7 @@ i386_displacement (char *disp_start, char *disp_end)\n \t branch template.  */\n       static templates aux_templates;\n       const insn_template *t = current_templates->start;\n-      bfd_boolean has_intel64 = FALSE;\n+      bool has_intel64 = false;\n \n       aux_templates.start = t;\n       while (++t < current_templates->end)\n@@ -10766,7 +10766,7 @@ i386_displacement (char *disp_start, char *disp_end)\n \t      != current_templates->start->opcode_modifier.jump)\n \t    break;\n \t  if ((t->opcode_modifier.isa64 >= INTEL64))\n-\t    has_intel64 = TRUE;\n+\t    has_intel64 = true;\n \t}\n       if (t < current_templates->end)\n \t{\n@@ -11272,7 +11272,7 @@ maybe_adjust_templates (void)\n   if (t < current_templates->end)\n     {\n       static templates aux_templates;\n-      bfd_boolean recheck;\n+      bool recheck;\n \n       aux_templates.start = t;\n       for (; t < current_templates->end; ++t)\n@@ -11319,7 +11319,7 @@ i386_att_operand (char *operand_string)\n       ++op_string;\n       if (is_space_char (*op_string))\n \t++op_string;\n-      i.jumpabsolute = TRUE;\n+      i.jumpabsolute = true;\n     }\n \n   /* Check if operand is a register.  */\n@@ -11358,7 +11358,7 @@ i386_att_operand (char *operand_string)\n \t      ++op_string;\n \t      if (is_space_char (*op_string))\n \t\t++op_string;\n-\t      i.jumpabsolute = TRUE;\n+\t      i.jumpabsolute = true;\n \t    }\n \t  goto do_memory_reference;\n \t}\n@@ -12593,7 +12593,7 @@ md_atof (int type, char *litP, int *sizeP)\n {\n   /* This outputs the LITTLENUMs in REVERSE order;\n      in accord with the bigendian 386.  */\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \f\n static char output_invalid_buf[sizeof (unsigned char) * 2 + 6];\n@@ -12612,66 +12612,66 @@ output_invalid (int c)\n \n /* Verify that @r can be used in the current context.  */\n \n-static bfd_boolean check_register (const reg_entry *r)\n+static bool check_register (const reg_entry *r)\n {\n   if (allow_pseudo_reg)\n-    return TRUE;\n+    return true;\n \n   if (operand_type_all_zero (&r->reg_type))\n-    return FALSE;\n+    return false;\n \n   if ((r->reg_type.bitfield.dword\n        || (r->reg_type.bitfield.class == SReg && r->reg_num > 3)\n        || r->reg_type.bitfield.class == RegCR\n        || r->reg_type.bitfield.class == RegDR)\n       && !cpu_arch_flags.bitfield.cpui386)\n-    return FALSE;\n+    return false;\n \n   if (r->reg_type.bitfield.class == RegTR\n       && (flag_code == CODE_64BIT\n \t  || !cpu_arch_flags.bitfield.cpui386\n \t  || cpu_arch_isa_flags.bitfield.cpui586\n \t  || cpu_arch_isa_flags.bitfield.cpui686))\n-    return FALSE;\n+    return false;\n \n   if (r->reg_type.bitfield.class == RegMMX && !cpu_arch_flags.bitfield.cpummx)\n-    return FALSE;\n+    return false;\n \n   if (!cpu_arch_flags.bitfield.cpuavx512f)\n     {\n       if (r->reg_type.bitfield.zmmword\n \t  || r->reg_type.bitfield.class == RegMask)\n-\treturn FALSE;\n+\treturn false;\n \n       if (!cpu_arch_flags.bitfield.cpuavx)\n \t{\n \t  if (r->reg_type.bitfield.ymmword)\n-\t    return FALSE;\n+\t    return false;\n \n \t  if (!cpu_arch_flags.bitfield.cpusse && r->reg_type.bitfield.xmmword)\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n   if (r->reg_type.bitfield.tmmword\n       && (!cpu_arch_flags.bitfield.cpuamx_tile\n           || flag_code != CODE_64BIT))\n-    return FALSE;\n+    return false;\n \n   if (r->reg_type.bitfield.class == RegBND && !cpu_arch_flags.bitfield.cpumpx)\n-    return FALSE;\n+    return false;\n \n   /* Don't allow fake index register unless allow_index_reg isn't 0. */\n   if (!allow_index_reg && r->reg_num == RegIZ)\n-    return FALSE;\n+    return false;\n \n   /* Upper 16 vector registers are only available with VREX in 64bit\n      mode, and require EVEX encoding.  */\n   if (r->reg_flags & RegVRex)\n     {\n       if (!cpu_arch_flags.bitfield.cpuavx512f\n \t  || flag_code != CODE_64BIT)\n-\treturn FALSE;\n+\treturn false;\n \n       if (i.vec_encoding == vex_encoding_default)\n \ti.vec_encoding = vex_encoding_evex;\n@@ -12682,13 +12682,13 @@ static bfd_boolean check_register (const reg_entry *r)\n   if (((r->reg_flags & (RegRex64 | RegRex)) || r->reg_type.bitfield.qword)\n       && (!cpu_arch_flags.bitfield.cpulm || r->reg_type.bitfield.class != RegCR)\n       && flag_code != CODE_64BIT)\n-    return FALSE;\n+    return false;\n \n   if (r->reg_type.bitfield.class == SReg && r->reg_num == RegFlat\n       && !intel_syntax)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* REG_STRING starts *before* REGISTER_PREFIX.  */"
    },
    {
      "sha": "2da73b0b99b0b08c03d96b27050bf7063e0d13de",
      "filename": "gas/config/tc-ia64.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ia64.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -164,7 +164,7 @@ struct label_fix\n {\n   struct label_fix *next;\n   struct symbol *sym;\n-  bfd_boolean dw2_mark_labels;\n+  bool dw2_mark_labels;\n };\n \n #ifdef TE_VMS\n@@ -947,7 +947,7 @@ ia64_flush_insns (void)\n   segT saved_seg;\n   subsegT saved_subseg;\n   unw_rec_list *ptr;\n-  bfd_boolean mark;\n+  bool mark;\n \n   if (!md.last_text_seg)\n     return;\n@@ -962,7 +962,7 @@ ia64_flush_insns (void)\n \n   /* In case there are labels following the last instruction, resolve\n      those now.  */\n-  mark = FALSE;\n+  mark = false;\n   for (lfix = CURR_SLOT.label_fixups; lfix; lfix = lfix->next)\n     {\n       symbol_set_value_now (lfix->sym);\n@@ -6520,7 +6520,7 @@ emit_one_bundle (void)\n   int n, i, j, first, curr, last_slot;\n   bfd_vma t0 = 0, t1 = 0;\n   struct label_fix *lfix;\n-  bfd_boolean mark_label;\n+  bool mark_label;\n   struct insn_fix *ifix;\n   char mnemonic[16];\n   fixS *fix;\n@@ -6847,7 +6847,7 @@ emit_one_bundle (void)\n \tcontinue;\t\t/* Try next slot.  */\n \n       /* Now is a good time to fix up the labels for this insn.  */\n-      mark_label = FALSE;\n+      mark_label = false;\n       for (lfix = md.slot[curr].label_fixups; lfix; lfix = lfix->next)\n \t{\n \t  S_SET_VALUE (lfix->sym, frag_now_fix () - 16);\n@@ -7755,7 +7755,7 @@ ia64_frob_label (struct symbol *sym)\n       fix = XOBNEW (&notes, struct label_fix);\n       fix->sym = sym;\n       fix->next = CURR_SLOT.tag_fixups;\n-      fix->dw2_mark_labels = FALSE;\n+      fix->dw2_mark_labels = false;\n       CURR_SLOT.tag_fixups = fix;\n \n       return;"
    },
    {
      "sha": "0adc672a12044fbd3af7d7b0a5089726836ec806",
      "filename": "gas/config/tc-ip2k.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ip2k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ip2k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ip2k.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -161,7 +161,7 @@ md_begin (void)\n   /* Set the machine type.  */\n   bfd_default_set_arch_mach (stdoutput, bfd_arch_ip2k, ip2k_mach);\n \n-  literal_prefix_dollar_hex = TRUE;\n+  literal_prefix_dollar_hex = true;\n }\n \n \n@@ -315,7 +315,7 @@ md_number_to_chars (char * buf, valueT val, int n)\n const char *\n md_atof (int type, char * litP, int *  sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n "
    },
    {
      "sha": "f586441f1cf46056790f21f21d61f9396d563477",
      "filename": "gas/config/tc-iq2000.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-iq2000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-iq2000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-iq2000.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -731,10 +731,10 @@ md_operand (expressionS * exp)\n const char *\n md_atof (int type, char * litP, int * sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n-bfd_boolean\n+bool\n iq2000_fix_adjustable (fixS * fixP)\n {\n   bfd_reloc_code_real_type reloc_type;\n@@ -751,21 +751,21 @@ iq2000_fix_adjustable (fixS * fixP)\n     reloc_type = fixP->fx_r_type;\n \n   if (fixP->fx_addsy == NULL)\n-    return TRUE;\n+    return true;\n \n   /* Prevent all adjustments to global symbols.  */\n   if (S_IS_EXTERNAL (fixP->fx_addsy))\n-    return FALSE;\n+    return false;\n \n   if (S_IS_WEAK (fixP->fx_addsy))\n-    return FALSE;\n+    return false;\n \n   /* We need the symbol name for the VTABLE entries.  */\n   if (   reloc_type == BFD_RELOC_VTABLE_INHERIT\n       || reloc_type == BFD_RELOC_VTABLE_ENTRY)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n static void"
    },
    {
      "sha": "a7be4b3222d75fdff18daf17daec1048053f787c",
      "filename": "gas/config/tc-iq2000.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-iq2000.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-iq2000.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-iq2000.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -57,6 +57,6 @@\n \n #define tc_gen_reloc gas_cgen_tc_gen_reloc\n \n-extern void         iq2000_frob_file         (void);\n-extern bfd_boolean  iq2000_fix_adjustable    (struct fix *);\n-extern int          iq2000_force_relocation  (struct fix *);\n+extern void iq2000_frob_file (void);\n+extern bool iq2000_fix_adjustable (struct fix *);\n+extern int iq2000_force_relocation (struct fix *);"
    },
    {
      "sha": "3a5b3e770742f6e95cbcdf04a8175033f14e4f61",
      "filename": "gas/config/tc-lm32.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-lm32.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -380,15 +380,15 @@ md_pcrel_from_section (fixS * fixP, segT sec)\n \n /* Return true if we can partially resolve a relocation now.  */\n \n-bfd_boolean\n+bool\n lm32_fix_adjustable (fixS * fixP)\n {\n   /* We need the symbol name for the VTABLE entries */\n   if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT\n       || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Relaxation isn't required/supported on this target.  */"
    },
    {
      "sha": "229000218034d00f9e9ec49b72d9ff795d806793",
      "filename": "gas/config/tc-lm32.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-lm32.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-lm32.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-lm32.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -42,7 +42,7 @@\n /* Call md_pcrel_from_section(), not md_pcrel_from().  */\n #define MD_PCREL_FROM_SECTION(FIXP, SEC) md_pcrel_from_section (FIXP, SEC)\n \n-extern bfd_boolean lm32_fix_adjustable (struct fix *);\n+extern bool lm32_fix_adjustable (struct fix *);\n #define tc_fix_adjustable(FIX) lm32_fix_adjustable (FIX)\n \n #endif /* TC_LM32_H */"
    },
    {
      "sha": "370817e55e0dfb1c7b5e74456653da98268402f7",
      "filename": "gas/config/tc-m32c.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m32c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m32c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m32c.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -215,7 +215,7 @@ m32c_start_line_hook (void)\n \n /* Process [[indirect-operands]] in instruction str.  */\n \n-static bfd_boolean\n+static bool\n m32c_indirect_operand (char *str)\n {\n   char *new_str;\n@@ -245,7 +245,7 @@ m32c_indirect_operand (char *str)\n     }\n \n   if (indirection[1] == none && indirection[2] == none)\n-    return FALSE;\n+    return false;\n \n   operand = 1;\n   ns_len = strlen (str);\n@@ -287,7 +287,7 @@ m32c_indirect_operand (char *str)\n       *ns = s[0];\n       ns += 1;\n       if (ns >= ns_end)\n-\treturn FALSE;\n+\treturn false;\n       if (s[0] == 0)\n \tbreak;\n     }\n@@ -307,7 +307,7 @@ m32c_indirect_operand (char *str)\n \n   md_assemble (new_str);\n   free (new_str);\n-  return TRUE;\n+  return true;\n }\n \n void\n@@ -1138,10 +1138,10 @@ md_number_to_chars (char * buf, valueT val, int n)\n const char *\n md_atof (int type, char * litP, int * sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n-bfd_boolean\n+bool\n m32c_fix_adjustable (fixS * fixP)\n {\n   int reloc;"
    },
    {
      "sha": "4817c714c247f448e4d117cda8138545ab87e1b6",
      "filename": "gas/config/tc-m32c.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m32c.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m32c.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m32c.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -44,7 +44,7 @@ extern void m32c_start_line_hook (void);\n extern void m32c_apply_fix (struct fix *, valueT *, segT);\n \n #define tc_fix_adjustable(fixP) m32c_fix_adjustable (fixP)\n-extern bfd_boolean m32c_fix_adjustable (struct fix *);\n+extern bool m32c_fix_adjustable (struct fix *);\n \n /* When relaxing, we need to emit various relocs we otherwise wouldn't.  */\n #define TC_FORCE_RELOCATION(fix) m32c_force_relocation (fix)"
    },
    {
      "sha": "74bcbf631ad1752c0f5cc391c7085f4833d1a0ba",
      "filename": "gas/config/tc-m32r.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m32r.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -844,7 +844,7 @@ can_make_parallel (m32r_insn *a, m32r_insn *b)\n       || CGEN_FIELDS_BITSIZE (&b->fields) != 16)\n     abort ();\n \n-  if (first_writes_to_seconds_operands (a, b, TRUE))\n+  if (first_writes_to_seconds_operands (a, b, true))\n     return _(\"instructions write to the same destination register.\");\n \n   a_pipe = CGEN_INSN_ATTR_VALUE (a->insn, CGEN_INSN_PIPE);\n@@ -1118,11 +1118,11 @@ assemble_two_insns (char *str1, char *str2, int parallel_p)\n \n   if (parallel_p && warn_explicit_parallel_conflicts)\n     {\n-      if (first_writes_to_seconds_operands (&first, &second, FALSE))\n+      if (first_writes_to_seconds_operands (&first, &second, false))\n \t/* xgettext:c-format  */\n \tas_warn (_(\"%s: output of 1st instruction is the same as an input to 2nd instruction - is this intentional ?\"), str2);\n \n-      if (first_writes_to_seconds_operands (&second, &first, FALSE))\n+      if (first_writes_to_seconds_operands (&second, &first, false))\n \t/* xgettext:c-format  */\n \tas_warn (_(\"%s: output of 2nd instruction is the same as an input to 1st instruction - is this intentional ?\"), str2);\n     }\n@@ -1287,7 +1287,7 @@ md_assemble (char *str)\n   else\n     {\n       int on_32bit_boundary_p;\n-      int swap = FALSE;\n+      int swap = false;\n \n       if (CGEN_INSN_BITSIZE (insn.insn) != 16)\n \tabort ();\n@@ -1342,12 +1342,12 @@ md_assemble (char *str)\n \t  && parallel ()\n \t  && CGEN_INSN_ATTR_VALUE (insn.orig_insn, CGEN_INSN_RELAXABLE) == 0\n \t  && ! writes_to_pc (&prev_insn)\n-\t  && ! first_writes_to_seconds_operands (&prev_insn, &insn, FALSE))\n+\t  && ! first_writes_to_seconds_operands (&prev_insn, &insn, false))\n \t{\n \t  if (can_make_parallel (&prev_insn, &insn) == NULL)\n \t    make_parallel (insn.buffer);\n \t  else if (can_make_parallel (&insn, &prev_insn) == NULL)\n-\t    swap = TRUE;\n+\t    swap = true;\n \t}\n \n       expand_debug_syms (insn.debug_sym_link, 1);\n@@ -2125,7 +2125,7 @@ m32r_elf_section_change_hook (void)\n /* Return true if can adjust the reloc to be relative to its section\n    (such as .data) instead of relative to some symbol.  */\n \n-bfd_boolean\n+bool\n m32r_fix_adjustable (fixS *fixP)\n {\n   bfd_reloc_code_real_type reloc_type;"
    },
    {
      "sha": "3ddabda998b7cc53cfa00bf64d7ac8b12401f483",
      "filename": "gas/config/tc-m32r.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m32r.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m32r.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m32r.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -70,7 +70,7 @@ extern void m32r_handle_align (fragS *);\n #define md_apply_fix gas_cgen_md_apply_fix\n \n #define tc_fix_adjustable(FIX) m32r_fix_adjustable (FIX)\n-extern bfd_boolean m32r_fix_adjustable (struct fix *);\n+extern bool m32r_fix_adjustable (struct fix *);\n \n /* After creating a fixup for an instruction operand, we need to check for\n    HI16 relocs and queue them up for later sorting.  */"
    },
    {
      "sha": "c60e736f36b372ad20227a61849c2ee2ad27cbcd",
      "filename": "gas/config/tc-m68hc11.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m68hc11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m68hc11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m68hc11.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -577,7 +577,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n valueT\n@@ -1599,7 +1599,7 @@ fixup8 (expressionS *oper, int mode, int opmode)\n       if (mode == M6811_OP_JUMP_REL)\n \t{\n \t  fix_new_exp (frag_now, f - frag_now->fr_literal, 1,\n-\t\t       oper, TRUE, BFD_RELOC_8_PCREL);\n+\t\t       oper, true, BFD_RELOC_8_PCREL);\n \t}\n       else\n \t{\n@@ -1618,7 +1618,7 @@ fixup8 (expressionS *oper, int mode, int opmode)\n             reloc = BFD_RELOC_8;\n \n \t  fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,\n-                              oper, FALSE, reloc);\n+                              oper, false, reloc);\n           if (reloc != BFD_RELOC_8)\n             fixp->fx_no_overflow = 1;\n \t}\n@@ -1700,7 +1700,7 @@ fixup24 (expressionS *oper, int mode, int opmode ATTRIBUTE_UNUSED)\n     {\n       /* Now create a 24-bit fixup.  */\n       fix_new_exp (frag_now, f - frag_now->fr_literal, 3,\n-\t\t   oper, FALSE, BFD_RELOC_M68HC11_24);\n+\t\t   oper, false, BFD_RELOC_M68HC11_24);\n       number_to_chars_bigendian (f, 0, 3);\n     }\n   else\n@@ -1731,7 +1731,7 @@ fixup8_xg (expressionS *oper, int mode, int opmode)\n             reloc = BFD_RELOC_M68HC11_LO8;\n \n           fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,\n-\t\t\t      oper, FALSE, reloc);\n+\t\t\t      oper, false, reloc);\n           fixp->fx_no_overflow = 1;\n           number_to_chars_bigendian (f, 0, 1);\n         }\n@@ -1750,14 +1750,14 @@ fixup8_xg (expressionS *oper, int mode, int opmode)\n           /* Future improvement:\n \t     This fixup/reloc isn't adding on constants to symbols.  */\n           fix_new_exp (frag_now, f - frag_now->fr_literal -1, 2,\n-\t\t       oper, TRUE, BFD_RELOC_M68HC12_9_PCREL);\n+\t\t       oper, true, BFD_RELOC_M68HC12_9_PCREL);\n       \t}\n       else if (mode == M68XG_OP_REL10)\n         {\n           /* Future improvement:\n \t     This fixup/reloc isn't adding on constants to symbols.  */\n           fix_new_exp (frag_now, f - frag_now->fr_literal -1, 2,\n-    \t               oper, TRUE, BFD_RELOC_M68HC12_10_PCREL);\n+    \t               oper, true, BFD_RELOC_M68HC12_10_PCREL);\n         }\n       else\n         {\n@@ -1774,7 +1774,7 @@ fixup8_xg (expressionS *oper, int mode, int opmode)\n             reloc = BFD_RELOC_8;\n \n           fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,\n-            oper, FALSE, reloc);\n+            oper, false, reloc);\n           if (reloc != BFD_RELOC_8)\n               fixp->fx_no_overflow = 1;\n         }\n@@ -2398,7 +2398,7 @@ build_insn_xg (struct m68hc11_opcode *opcode,\n       operands[0].mode = M6811_OP_LOW_ADDR;\n       f = frag_more (1);\n       fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,\n-                          &operands[0].exp, FALSE, BFD_RELOC_M68HC12_LO8XG);\n+                          &operands[0].exp, false, BFD_RELOC_M68HC12_LO8XG);\n       fixp->fx_no_overflow = 1;\n       number_to_chars_bigendian (f, 0, 1);\n \n@@ -2408,7 +2408,7 @@ build_insn_xg (struct m68hc11_opcode *opcode,\n       operands[0].mode = M6811_OP_HIGH_ADDR;\n       f = frag_more (1);\n       fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 1,\n-                          &operands[0].exp, FALSE, BFD_RELOC_M68HC12_HI8XG);\n+                          &operands[0].exp, false, BFD_RELOC_M68HC12_HI8XG);\n       fixp->fx_no_overflow = 1;\n       number_to_chars_bigendian (f, 0, 1);\n "
    },
    {
      "sha": "4d3987de19bc490746f12dff899110738ef8aa50",
      "filename": "gas/config/tc-m68k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m68k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-m68k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m68k.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -4790,7 +4790,7 @@ m68k_mri_mode_change (int on)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n void"
    },
    {
      "sha": "d81e0be5b2bd5c2076b9003a01fc57830362f786",
      "filename": "gas/config/tc-mcore.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mcore.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -2229,7 +2229,7 @@ mcore_force_relocation (fixS * fix)\n /* Return true if the fix can be handled by GAS, false if it must\n    be passed through to the linker.  */\n \n-bfd_boolean\n+bool\n mcore_fix_adjustable (fixS * fixP)\n {\n   /* We need the symbol name for the VTABLE entries.  */"
    },
    {
      "sha": "7c3ae8172a9991be146ac2488bcb6b205c31d5fe",
      "filename": "gas/config/tc-mcore.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mcore.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mcore.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mcore.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -86,9 +86,9 @@ struct mcore_tc_sy\n \n #include \"write.h\"        /* For definition of fixS */\n \n-extern void        md_mcore_end           (void);\n-extern arelent *   tc_gen_reloc           (asection *, fixS *);\n-extern int         mcore_force_relocation (fixS *);\n-extern bfd_boolean mcore_fix_adjustable   (fixS *);\n+extern void md_mcore_end (void);\n+extern arelent *tc_gen_reloc (asection *, fixS *);\n+extern int mcore_force_relocation (fixS *);\n+extern bool mcore_fix_adjustable (fixS *);\n \n #endif /* TC_MCORE */"
    },
    {
      "sha": "fffd8706fff6fc0b92a393ef230e38fb247b34e2",
      "filename": "gas/config/tc-mep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mep.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -2043,10 +2043,10 @@ md_number_to_chars (char *buf, valueT val, int n)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n-bfd_boolean\n+bool\n mep_fix_adjustable (fixS *fixP)\n {\n   bfd_reloc_code_real_type reloc_type;"
    },
    {
      "sha": "fcd4c5dfdc92fee9ff4b08984f58315f22384a01",
      "filename": "gas/config/tc-mep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mep.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -58,7 +58,7 @@ extern void mep_apply_fix (struct fix *, valueT *, segT);\n extern void mep_frob_file (void);\n \n #define tc_fix_adjustable(fixP) mep_fix_adjustable (fixP)\n-extern bfd_boolean mep_fix_adjustable (struct fix *);\n+extern bool mep_fix_adjustable (struct fix *);\n \n /* After creating a fixup for an instruction operand, we need\n    to check for HI16 relocs and queue them up for later sorting.  */"
    },
    {
      "sha": "961c11f3b0ddc14130a9eafdb67de1b78c11913e",
      "filename": "gas/config/tc-metag.c",
      "status": "modified",
      "additions": 174,
      "deletions": 174,
      "changes": 348,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-metag.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -380,7 +380,7 @@ parse_fpu_regs (const char *line, const metag_reg **regs, size_t count)\n }\n \n /* Return TRUE if REG1 and REG2 are in paired units.  */\n-static bfd_boolean\n+static bool\n is_unit_pair (const metag_reg *reg1, const metag_reg *reg2)\n {\n   if ((reg1->unit == UNIT_A0 &&\n@@ -391,22 +391,22 @@ is_unit_pair (const metag_reg *reg1, const metag_reg *reg2)\n        (reg2->unit == UNIT_D1)) ||\n       (reg1->unit == UNIT_D1 &&\n        (reg2->unit == UNIT_D0)))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return TRUE if REG1 and REG2 form a register pair.  */\n-static bfd_boolean\n+static bool\n is_reg_pair (const metag_reg *reg1, const metag_reg *reg2)\n {\n   if (reg1->unit == UNIT_FX &&\n       reg2->unit == UNIT_FX &&\n       reg2->no == reg1->no + 1)\n-    return TRUE;\n+    return true;\n \n   if (reg1->no != reg2->no)\n-    return FALSE;\n+    return false;\n \n   return is_unit_pair (reg1, reg2);\n }\n@@ -472,7 +472,7 @@ parse_mov_port (const char *line, metag_insn *insn,\n \t\tconst insn_template *template)\n {\n   const char *l = line;\n-  bfd_boolean is_movl = MINOR_OPCODE (template->meta_opcode) == MOVL_MINOR;\n+  bool is_movl = MINOR_OPCODE (template->meta_opcode) == MOVL_MINOR;\n   const metag_reg *dest_regs[2];\n   const metag_reg *port_regs[1];\n \n@@ -847,7 +847,7 @@ parse_addr (const char *line, metag_addr *addr, unsigned int size)\n /* Parse a GET or pipeline MOV instruction.  */\n static const char *\n parse_get (const char *line, const metag_reg **regs, metag_addr *addr,\n-\t   unsigned int size, bfd_boolean is_mov)\n+\t   unsigned int size, bool is_mov)\n {\n   const char *l = line;\n \n@@ -946,7 +946,7 @@ parse_set (const char *line, const metag_reg **regs, metag_addr *addr,\n \n /* Check a signed integer value can be represented in the given number\n    of bits.  */\n-static bfd_boolean\n+static bool\n within_signed_range (int value, unsigned int bits)\n {\n   int min_val = -(1 << (bits - 1));\n@@ -956,14 +956,14 @@ within_signed_range (int value, unsigned int bits)\n \n /* Check an unsigned integer value can be represented in the given number\n    of bits.  */\n-static bfd_boolean\n+static bool\n within_unsigned_range (unsigned int value, unsigned int bits)\n {\n   return value < (unsigned int)(1 << bits);\n }\n \n /* Return TRUE if UNIT can be expressed using a short code.  */\n-static bfd_boolean\n+static bool\n is_short_unit (enum metag_unit unit)\n {\n   switch (unit)\n@@ -972,9 +972,9 @@ is_short_unit (enum metag_unit unit)\n     case UNIT_A1:\n     case UNIT_D0:\n     case UNIT_D1:\n-      return TRUE;\n+      return true;\n     default:\n-      return FALSE;\n+      return false;\n     }\n }\n \n@@ -995,15 +995,15 @@ parse_get_set (const char *line, metag_insn *insn,\n   const metag_reg *regs[2];\n   metag_addr addr;\n   unsigned int size = metag_get_set_size_bytes (template->meta_opcode);\n-  bfd_boolean is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n+  bool is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n   unsigned int reg_no;\n \n   memset(&addr, 0, sizeof(addr));\n   addr.reloc_type = BFD_RELOC_UNUSED;\n \n   if (is_get)\n     {\n-      bfd_boolean is_mov = strncmp (template->name, \"MOV\", 3) == 0;\n+      bool is_mov = strncmp (template->name, \"MOV\", 3) == 0;\n \n       l = parse_get (l, regs, &addr, size, is_mov);\n \n@@ -1139,8 +1139,8 @@ parse_get_set_ext (const char *line, metag_insn *insn,\n   const metag_reg *regs[2];\n   metag_addr addr;\n   unsigned int size = metag_get_set_ext_size_bytes (template->meta_opcode);\n-  bfd_boolean is_get = MINOR_OPCODE (template->meta_opcode) == GET_EXT_MINOR;\n-  bfd_boolean is_mov = MINOR_OPCODE (template->meta_opcode) == MOV_EXT_MINOR;\n+  bool is_get = MINOR_OPCODE (template->meta_opcode) == GET_EXT_MINOR;\n+  bool is_mov = MINOR_OPCODE (template->meta_opcode) == MOV_EXT_MINOR;\n   unsigned int reg_unit;\n \n   memset(&addr, 0, sizeof(addr));\n@@ -1334,9 +1334,9 @@ parse_mset (const char *line, const metag_reg **regs, metag_addr *addr,\n    rmask value if possible. Return the rmask value in RMASK and the\n    lowest numbered register in LOWEST_REG. Return TRUE if the conversion\n    was successful.  */\n-static bfd_boolean\n-check_rmask (const metag_reg **regs, size_t regs_read, bfd_boolean is_fpu,\n-\t     bfd_boolean is_64bit, unsigned int *lowest_reg,\n+static bool\n+check_rmask (const metag_reg **regs, size_t regs_read, bool is_fpu,\n+\t     bool is_64bit, unsigned int *lowest_reg,\n \t     unsigned int *rmask)\n {\n   unsigned int reg_unit = regs[0]->unit;\n@@ -1349,13 +1349,13 @@ check_rmask (const metag_reg **regs, size_t regs_read, bfd_boolean is_fpu,\n \t  if (is_64bit && regs[i]->no % 2)\n \t    {\n \t      as_bad (_(\"register list must be even numbered\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n       else if (regs[i]->unit != reg_unit)\n \t{\n \t  as_bad (_(\"register list must be from the same unit\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (regs[i]->no < *lowest_reg)\n@@ -1378,13 +1378,13 @@ check_rmask (const metag_reg **regs, size_t regs_read, bfd_boolean is_fpu,\n       if (*rmask & next_bit)\n \t{\n \t  as_bad (_(\"register list must not contain duplicates\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       *rmask |= next_bit;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Parse an MGET or MSET instruction.  */\n@@ -1395,9 +1395,9 @@ parse_mget_mset (const char *line, metag_insn *insn,\n   const char *l = line;\n   const metag_reg *regs[MGET_MSET_MAX_REGS];\n   metag_addr addr;\n-  bfd_boolean is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n-  bfd_boolean is_fpu = (MINOR_OPCODE (template->meta_opcode) & 0x6) == 0x6;\n-  bfd_boolean is_64bit = (MINOR_OPCODE (template->meta_opcode) & 0x1) == 0x1;\n+  bool is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n+  bool is_fpu = (MINOR_OPCODE (template->meta_opcode) & 0x6) == 0x6;\n+  bool is_64bit = (MINOR_OPCODE (template->meta_opcode) & 0x1) == 0x1;\n   size_t regs_read = 0;\n   unsigned int rmask = 0, reg_unit = 0, lowest_reg = 0xffffffff;\n \n@@ -1501,9 +1501,9 @@ parse_mmov (const char *line, metag_insn *insn,\n \t    const insn_template *template)\n {\n   const char *l = line;\n-  bfd_boolean is_fpu = template->insn_type == INSN_FPU;\n-  bfd_boolean is_prime = (MINOR_OPCODE (template->meta_opcode) & 0x2) != 0 && !is_fpu;\n-  bfd_boolean is_64bit = (MINOR_OPCODE (template->meta_opcode) & 0x1) != 0;\n+  bool is_fpu = template->insn_type == INSN_FPU;\n+  bool is_prime = (MINOR_OPCODE (template->meta_opcode) & 0x2) != 0 && !is_fpu;\n+  bool is_64bit = (MINOR_OPCODE (template->meta_opcode) & 0x1) != 0;\n   unsigned int rmask = 0;\n \n   if (is_prime)\n@@ -1834,8 +1834,8 @@ parse_imm16 (const char *line, metag_insn *insn, int *value)\n   const char *l = line;\n   char *save_input_line_pointer;\n   expressionS *exp = &insn->reloc_exp;\n-  bfd_boolean is_hi = FALSE;\n-  bfd_boolean is_lo = FALSE;\n+  bool is_hi = false;\n+  bool is_lo = false;\n \n   /* Skip #. */\n   if (*l == '#')\n@@ -1845,12 +1845,12 @@ parse_imm16 (const char *line, metag_insn *insn, int *value)\n \n   if (strncasecmp (l, \"HI\", 2) == 0)\n     {\n-      is_hi = TRUE;\n+      is_hi = true;\n       l += 2;\n     }\n   else if (strncasecmp (l, \"LO\", 2) == 0)\n     {\n-      is_lo = TRUE;\n+      is_lo = true;\n       l += 2;\n     }\n \n@@ -1965,9 +1965,9 @@ parse_mov_ct (const char *line, metag_insn *insn,\n {\n   const char *l = line;\n   const metag_reg *regs[1];\n-  bfd_boolean top = (template->meta_opcode & 0x1) != 0;\n-  bfd_boolean is_trace = ((template->meta_opcode >> 2) & 0x1) != 0;\n-  bfd_boolean sign_extend = 0;\n+  bool top = (template->meta_opcode & 0x1) != 0;\n+  bool is_trace = ((template->meta_opcode >> 2) & 0x1) != 0;\n+  bool sign_extend = 0;\n   int value = 0;\n \n   l = parse_gp_regs (l, regs, 1);\n@@ -2078,7 +2078,7 @@ parse_jump (const char *line, metag_insn *insn,\n   if (!is_short_unit (regs[0]->unit))\n     {\n       as_bad (_(\"register unit must be one of %s\"), SHORT_UNITS);\n-      return FALSE;\n+      return false;\n     }\n \n   l = skip_comma (l);\n@@ -2290,16 +2290,16 @@ parse_alu (const char *line, metag_insn *insn,\n   const metag_reg *dest_regs[1];\n   const metag_reg *src_regs[2];\n   int value = 0;\n-  bfd_boolean o1z = 0;\n-  bfd_boolean imm = ((template->meta_opcode >> 25) & 0x1) != 0;\n-  bfd_boolean cond = ((template->meta_opcode >> 26) & 0x1) != 0;\n-  bfd_boolean ca = ((template->meta_opcode >> 5) & 0x1) != 0;\n-  bfd_boolean top = (template->meta_opcode & 0x1) != 0;\n-  bfd_boolean sign_extend = 0;\n-  bfd_boolean is_addr_op = MAJOR_OPCODE (template->meta_opcode) == OPC_ADDR;\n-  bfd_boolean is_mul = MAJOR_OPCODE (template->meta_opcode) == OPC_MUL;\n+  bool o1z = 0;\n+  bool imm = ((template->meta_opcode >> 25) & 0x1) != 0;\n+  bool cond = ((template->meta_opcode >> 26) & 0x1) != 0;\n+  bool ca = ((template->meta_opcode >> 5) & 0x1) != 0;\n+  bool top = (template->meta_opcode & 0x1) != 0;\n+  bool sign_extend = 0;\n+  bool is_addr_op = MAJOR_OPCODE (template->meta_opcode) == OPC_ADDR;\n+  bool is_mul = MAJOR_OPCODE (template->meta_opcode) == OPC_MUL;\n   unsigned int unit_bit = 0;\n-  bfd_boolean is_quickrot = (template->arg_type & GP_ARGS_QR) != 0;\n+  bool is_quickrot = (template->arg_type & GP_ARGS_QR) != 0;\n \n   l = parse_gp_regs (l, dest_regs, 1);\n \n@@ -2510,7 +2510,7 @@ parse_alu (const char *line, metag_insn *insn,\n     }\n   else\n     {\n-      bfd_boolean o2r = 0;\n+      bool o2r = 0;\n       int rs2;\n \n       if (cond || !o1z)\n@@ -2652,7 +2652,7 @@ parse_alu (const char *line, metag_insn *insn,\n   if (is_quickrot)\n     {\n       const metag_reg *qr_regs[1];\n-      bfd_boolean limit_regs = imm && cond;\n+      bool limit_regs = imm && cond;\n \n       l = skip_comma (l);\n \n@@ -2786,8 +2786,8 @@ parse_shift (const char *line, metag_insn *insn,\n   const metag_reg *regs[2];\n   const metag_reg *src2_regs[1];\n   int value = 0;\n-  bfd_boolean cond = ((template->meta_opcode >> 26) & 0x1) != 0;\n-  bfd_boolean ca = ((template->meta_opcode >> 5) & 0x1) != 0;\n+  bool cond = ((template->meta_opcode >> 26) & 0x1) != 0;\n+  bool ca = ((template->meta_opcode >> 5) & 0x1) != 0;\n   unsigned int unit_bit = 0;\n \n   l = parse_gp_regs (l, regs, 2);\n@@ -2909,8 +2909,8 @@ parse_bitop (const char *line, metag_insn *insn,\n {\n   const char *l = line;\n   const metag_reg *regs[2];\n-  bfd_boolean swap_inst = MAJOR_OPCODE (template->meta_opcode) == OPC_MISC;\n-  bfd_boolean is_bexl = 0;\n+  bool swap_inst = MAJOR_OPCODE (template->meta_opcode) == OPC_MISC;\n+  bool is_bexl = 0;\n \n   if (swap_inst && ((template->meta_opcode >> 1) & 0xb) == 0xa)\n     is_bexl = 1;\n@@ -2964,10 +2964,10 @@ parse_cmp (const char *line, metag_insn *insn,\n   const metag_reg *dest_regs[1];\n   const metag_reg *src_regs[1];\n   int value = 0;\n-  bfd_boolean imm = ((template->meta_opcode >> 25) & 0x1) != 0;\n-  bfd_boolean cond = ((template->meta_opcode >> 26) & 0x1) != 0;\n-  bfd_boolean top = (template->meta_opcode & 0x1) != 0;\n-  bfd_boolean sign_extend = 0;\n+  bool imm = ((template->meta_opcode >> 25) & 0x1) != 0;\n+  bool cond = ((template->meta_opcode >> 26) & 0x1) != 0;\n+  bool top = (template->meta_opcode & 0x1) != 0;\n+  bool sign_extend = 0;\n   unsigned int unit_bit = 0;\n \n   l = parse_gp_regs (l, dest_regs, 1);\n@@ -3037,7 +3037,7 @@ parse_cmp (const char *line, metag_insn *insn,\n     }\n   else\n     {\n-      bfd_boolean o2r = 0;\n+      bool o2r = 0;\n       int rs2;\n \n       l = parse_gp_regs (l, src_regs, 1);\n@@ -3343,8 +3343,8 @@ parse_fmmov (const char *line, metag_insn *insn,\n \t     const insn_template *template)\n {\n   const char *l = line;\n-  bfd_boolean to_fpu = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n-  bfd_boolean is_mmovl = (MINOR_OPCODE (template->meta_opcode) & 0x1) != 0;\n+  bool to_fpu = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n+  bool is_mmovl = (MINOR_OPCODE (template->meta_opcode) & 0x1) != 0;\n   size_t regs_read = 0;\n   const metag_reg *regs[16];\n   unsigned int lowest_data_reg = 0xffffffff;\n@@ -3397,7 +3397,7 @@ parse_fmmov (const char *line, metag_insn *insn,\n       else\n \treturn NULL;\n \n-      if (!check_rmask (&regs[i], regs_read / 2, TRUE, FALSE, &lowest_data_reg,\n+      if (!check_rmask (&regs[i], regs_read / 2, true, false, &lowest_data_reg,\n \t\t\t&rmask))\n \treturn NULL;\n     }\n@@ -3410,7 +3410,7 @@ parse_fmmov (const char *line, metag_insn *insn,\n       else\n \treturn NULL;\n \n-      if (!check_rmask (regs, regs_read / 2, TRUE, FALSE, &lowest_data_reg,\n+      if (!check_rmask (regs, regs_read / 2, true, false, &lowest_data_reg,\n \t\t\t&rmask))\n \treturn NULL;\n \n@@ -3455,7 +3455,7 @@ parse_fmov_data (const char *line, metag_insn *insn,\n \t    const insn_template *template)\n {\n   const char *l = line;\n-  bfd_boolean to_fpu = ((template->meta_opcode >> 7) & 0x1) != 0;\n+  bool to_fpu = ((template->meta_opcode >> 7) & 0x1) != 0;\n   const metag_reg *regs[2];\n   unsigned int base_unit;\n \n@@ -3862,11 +3862,11 @@ parse_fearith (const char *line, metag_insn *insn,\n {\n   const char *l = line;\n   const metag_reg *regs[3];\n-  bfd_boolean is_muz = (MINOR_OPCODE (template->meta_opcode) == 0x6\n-\t\t\t&& ((template->meta_opcode >> 4) & 0x1) != 0);\n-  bfd_boolean is_o3o = (template->meta_opcode & 0x1) != 0;\n-  bfd_boolean is_mac = 0;\n-  bfd_boolean is_maw = 0;\n+  bool is_muz = (MINOR_OPCODE (template->meta_opcode) == 0x6\n+\t\t && ((template->meta_opcode >> 4) & 0x1) != 0);\n+  bool is_o3o = (template->meta_opcode & 0x1) != 0;\n+  bool is_mac = 0;\n+  bool is_maw = 0;\n \n   if (!strncasecmp (template->name, \"MAW\", 3))\n     is_maw = 1;\n@@ -4014,7 +4014,7 @@ parse_fget_set_acf (const char *line, metag_insn *insn,\n   const char *l = line;\n   int part;\n   metag_addr addr;\n-  bfd_boolean is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n+  bool is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n \n   memset(&addr, 0, sizeof(addr));\n   addr.reloc_type = BFD_RELOC_UNUSED;\n@@ -4138,15 +4138,15 @@ parse_dsp_insn_reg (const char *line, const metag_reg **reg)\n    definition. \"load\" specifies which table to look at.  */\n static const char *\n parse_dsp_template_reg (const char *line, const metag_reg **reg,\n-\t\t\tbfd_boolean load)\n+\t\t\tbool load)\n {\n   return __parse_dsp_reg (line, reg, dsp_tmpl_reg_htab[load]);\n }\n \n /* Parse a single DSP register from LINE.  */\n static const char *\n parse_dsp_reg (const char *line, const metag_reg **reg,\n-\t       bfd_boolean tmpl, bfd_boolean load)\n+\t       bool tmpl, bool load)\n {\n   if (tmpl)\n     return parse_dsp_template_reg (line, reg, load);\n@@ -4155,95 +4155,95 @@ parse_dsp_reg (const char *line, const metag_reg **reg,\n }\n \n /* Return TRUE if UNIT is an address unit.  */\n-static bfd_boolean\n+static bool\n is_addr_unit (enum metag_unit unit)\n {\n   switch (unit)\n     {\n     case UNIT_A0:\n     case UNIT_A1:\n-      return TRUE;\n+      return true;\n     default:\n-      return FALSE;\n+      return false;\n     }\n }\n \n /* Return TRUE if UNIT1 and UNIT2 are equivalent units.  */\n-static bfd_boolean\n+static bool\n is_same_data_unit (enum metag_unit unit1, enum metag_unit unit2)\n {\n   if (unit1 == unit2)\n-    return TRUE;\n+    return true;\n \n   switch (unit1)\n     {\n     case UNIT_D0:\n       if (unit2 == UNIT_ACC_D0 || unit2 == UNIT_RAM_D0)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case UNIT_D1:\n       if (unit2 == UNIT_ACC_D1 || unit2 == UNIT_RAM_D1)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case UNIT_ACC_D0:\n       if (unit2 == UNIT_D0 || unit2 == UNIT_RAM_D0)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case UNIT_ACC_D1:\n       if (unit2 == UNIT_D1 || unit2 == UNIT_RAM_D1)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case UNIT_RAM_D0:\n       if (unit2 == UNIT_ACC_D0 || unit2 == UNIT_D0)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case UNIT_RAM_D1:\n       if (unit2 == UNIT_ACC_D1 || unit2 == UNIT_D1)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n-      return FALSE;\n+      return false;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return TRUE if the register NUM is a quickrot control register.  */\n-static bfd_boolean\n+static bool\n is_quickrot_reg (unsigned int num)\n {\n   switch (num)\n     {\n     case 2:\n     case 3:\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return TRUE if REG is an accumulator register.  */\n-static bfd_boolean\n+static bool\n is_accumulator_reg (const metag_reg *reg)\n {\n   if (reg->unit == UNIT_ACC_D0 || reg->unit == UNIT_ACC_D1)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return TRUE if REG is a DSP RAM register.  */\n-static bfd_boolean\n+static bool\n is_dspram_reg (const metag_reg *reg)\n {\n   if (reg->unit == UNIT_RAM_D0 || reg->unit == UNIT_RAM_D1)\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n static const char *\n-__parse_gp_reg (const char *line, const metag_reg **reg, bfd_boolean load)\n+__parse_gp_reg (const char *line, const metag_reg **reg, bool load)\n {\n   const char *l = line;\n   char reg_buf[MAX_REG_LEN];\n@@ -4260,7 +4260,7 @@ __parse_gp_reg (const char *line, const metag_reg **reg, bfd_boolean load)\n       if (l == NULL)\n \treturn NULL;\n \n-      l = parse_dsp_reg (l, reg, TRUE, load);\n+      l = parse_dsp_reg (l, reg, true, load);\n       if (l == NULL)\n \treturn NULL;\n \n@@ -4299,8 +4299,8 @@ __parse_gp_reg (const char *line, const metag_reg **reg, bfd_boolean load)\n    a destination operand.  */\n static const char *\n parse_dsp_regs_list (const char *line, const metag_reg **regs, size_t count,\n-\t\t     size_t *regs_read, bfd_boolean try_gp, bfd_boolean tmpl,\n-\t\t     bfd_boolean load, bfd_boolean first_dst)\n+\t\t     size_t *regs_read, bool try_gp, bool tmpl,\n+\t\t     bool load, bool first_dst)\n {\n   const char *l = line;\n   int seen_regs = 0;\n@@ -4370,7 +4370,7 @@ parse_dsp_regs_list (const char *line, const metag_reg **regs, size_t count,\n      - [DSPRam-DSPRam--]  */\n static const char *\n parse_dsp_addr (const char *line, metag_addr *addr, unsigned int size,\n-\t\tbfd_boolean load)\n+\t\tbool load)\n {\n   const char *l = line, *ll;\n   const metag_reg *regs[1];\n@@ -4379,7 +4379,7 @@ parse_dsp_addr (const char *line, metag_addr *addr, unsigned int size,\n   /* Skip opening square bracket.  */\n   l++;\n \n-  l = parse_dsp_regs_list (l, regs, 1, &regs_read, TRUE, TRUE, load, FALSE);\n+  l = parse_dsp_regs_list (l, regs, 1, &regs_read, true, true, load, false);\n \n   if (l == NULL)\n     return NULL;\n@@ -4433,7 +4433,7 @@ parse_dsp_addr (const char *line, metag_addr *addr, unsigned int size,\n   if (l == NULL)\n     return NULL;\n \n-  l = parse_dsp_regs_list (l, regs, 1, &regs_read, TRUE, TRUE, load, FALSE);\n+  l = parse_dsp_regs_list (l, regs, 1, &regs_read, true, true, load, false);\n \n   if (l == NULL)\n     return NULL;\n@@ -4475,9 +4475,9 @@ parse_dget_set (const char *line, metag_insn *insn,\n   metag_addr addr;\n   int unit = 0;\n   int rd_reg = 0;\n-  bfd_boolean is_get = (template->meta_opcode & 0x100) != 0;\n-  bfd_boolean is_dual = (template->meta_opcode & 0x4) != 0;\n-  bfd_boolean is_template = FALSE;\n+  bool is_get = (template->meta_opcode & 0x100) != 0;\n+  bool is_dual = (template->meta_opcode & 0x4) != 0;\n+  bool is_template = false;\n   const metag_reg *regs[2];\n   unsigned int size;\n   size_t count, regs_read;\n@@ -4494,8 +4494,8 @@ parse_dget_set (const char *line, metag_insn *insn,\n       if (*l == 'T')\n \tcount = 1;\n \n-      l = parse_dsp_regs_list (l, regs, count, &regs_read, FALSE,\n-\t\t\t       FALSE, FALSE, FALSE);\n+      l = parse_dsp_regs_list (l, regs, count, &regs_read, false,\n+\t\t\t       false, false, false);\n       l = skip_comma (l);\n \n       if (l == NULL)\n@@ -4519,16 +4519,16 @@ parse_dget_set (const char *line, metag_insn *insn,\n       if (*l == 'T')\n \tcount = 1;\n \n-      l = parse_dsp_regs_list (l, regs, count, &regs_read, FALSE, FALSE,\n-\t\t\t       FALSE, FALSE);\n+      l = parse_dsp_regs_list (l, regs, count, &regs_read, false, false,\n+\t\t\t       false, false);\n     }\n \n   if (l == NULL)\n     return NULL;\n \n   /* The first register dictates the unit.  */\n   if (regs[0]->unit == UNIT_DT)\n-      is_template = TRUE;\n+      is_template = true;\n   else\n     {\n       if (regs[0]->unit == UNIT_D0 || regs[0]->unit == UNIT_RAM_D0 ||\n@@ -4619,7 +4619,7 @@ parse_dtemplate (const char *line, metag_insn *insn,\n {\n   const char *l = line;\n   const metag_reg *regs[TEMPLATE_NUM_REGS];\n-  bfd_boolean daop_only = FALSE;\n+  bool daop_only = false;\n   int regs_val[4];\n   int regs_which[4] = { -1, -1, -1, -1};\t/* Register or immediate?  */\n   int i;\n@@ -4635,7 +4635,7 @@ parse_dtemplate (const char *line, metag_insn *insn,\n       /* We may only have 3 register operands.  */\n       if (*l == END_OF_INSN && i == 3)\n \t{\n-\t  daop_only = TRUE;\n+\t  daop_only = true;\n \t  break;\n \t}\n \n@@ -4662,11 +4662,11 @@ parse_dtemplate (const char *line, metag_insn *insn,\n \t     this is a load or store. So we have to try looking up the\n \t     register name in both the load and store tables.  */\n \t  const char *l2 = l;\n-\t  l = __parse_gp_reg (l, &regs[i], TRUE);\n+\t  l = __parse_gp_reg (l, &regs[i], true);\n \t  if (l == NULL)\n \t    {\n \t      /* Try the store table too.  */\n-\t      l = __parse_gp_reg (l2, &regs[i], FALSE);\n+\t      l = __parse_gp_reg (l2, &regs[i], false);\n \t      if (l == NULL)\n \t\t{\n \t\t  /* Then try a DSP register.  */\n@@ -4720,7 +4720,7 @@ parse_dtemplate (const char *line, metag_insn *insn,\n    template definition is a DSP RAM template definition.  */\n static const char *\n template_mem_ref(const char *line, metag_addr *addr,\n-\t\t bfd_boolean *dspram, int size, bfd_boolean load)\n+\t\t bool *dspram, int size, bool load)\n {\n   const char *l = line;\n \n@@ -4729,9 +4729,9 @@ template_mem_ref(const char *line, metag_addr *addr,\n   if (l != NULL)\n     {\n       if (is_addr_unit(addr->base_reg->unit))\n-\t*dspram = FALSE;\n+\t*dspram = false;\n       else\n-\t*dspram = TRUE;\n+\t*dspram = true;\n     }\n \n   return l;\n@@ -4740,10 +4740,10 @@ template_mem_ref(const char *line, metag_addr *addr,\n /* Sets LOAD to TRUE if this is a Template load definition (otherwise\n    it's a store). Fills out ADDR, TEMPLATE_REG and ADDR_UNIT.  */\n static const char *\n-parse_template_regs (const char *line, bfd_boolean *load,\n+parse_template_regs (const char *line, bool *load,\n \t\t     unsigned int *addr_unit,\n \t\t     const metag_reg **template_reg, metag_addr *addr,\n-\t\t     bfd_boolean *dspram, int size)\n+\t\t     bool *dspram, int size)\n {\n   const char *l = line;\n \n@@ -4753,8 +4753,8 @@ parse_template_regs (const char *line, bfd_boolean *load,\n   /* DSP Template load definition (Tx, [Ax]) */\n   if (*l == 'T')\n     {\n-      *load = TRUE;\n-      l = parse_dsp_reg (l, &template_reg[0], FALSE, FALSE);\n+      *load = true;\n+      l = parse_dsp_reg (l, &template_reg[0], false, false);\n       if (l == NULL)\n \treturn NULL;\n \n@@ -4768,14 +4768,14 @@ parse_template_regs (const char *line, bfd_boolean *load,\n     }\n   else if (*l == ADDR_BEGIN_CHAR) /* DSP Template store ([Ax], Tx) */\n     {\n-      *load = FALSE;\n+      *load = false;\n       l = template_mem_ref (l, addr, dspram, size, *load);\n       l = skip_comma(l);\n \n       if (l == NULL)\n \treturn NULL;\n \n-      l = parse_dsp_reg (l, &template_reg[0], FALSE, FALSE);\n+      l = parse_dsp_reg (l, &template_reg[0], false, false);\n       if (l == NULL)\n \treturn NULL;\n \n@@ -4799,7 +4799,7 @@ static metag_reg _reg;\n static const char *\n interpret_template_regs(const char *line, metag_insn *insn,\n \t\t\tconst metag_reg **regs,\n-\t\t\tint *regs_shift, bfd_boolean *load, bfd_boolean *dspram,\n+\t\t\tint *regs_shift, bool *load, bool *dspram,\n \t\t\tint size, int *ls_shift, int *au_shift,\n \t\t\tunsigned int *au, int *imm, int *imm_shift,\n \t\t\tunsigned int *imm_mask)\n@@ -4888,51 +4888,51 @@ interpret_template_regs(const char *line, metag_insn *insn,\n }\n \n /* Does this combination of units need the O2R bit and can it be encoded?  */\n-static bfd_boolean\n+static bool\n units_need_o2r (enum metag_unit unit1, enum metag_unit unit2)\n {\n   if (unit1 == unit2)\n-    return FALSE;\n+    return false;\n \n   if (unit1 == UNIT_D0 || unit1 == UNIT_ACC_D0 || unit1 == UNIT_RAM_D0)\n     {\n       if (unit2 == UNIT_ACC_D0 || unit2 == UNIT_RAM_D0 || unit2 == UNIT_D0)\n-\treturn FALSE;\n+\treturn false;\n \n       switch (unit2)\n \t{\n \tcase UNIT_A1:\n \tcase UNIT_D1:\n \tcase UNIT_RD:\n \tcase UNIT_A0:\n-\t  return TRUE;\n+\t  return true;\n \tdefault:\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n   if (unit1 == UNIT_D1 || unit1 == UNIT_ACC_D1 || unit1 == UNIT_RAM_D1)\n     {\n       if (unit2 == UNIT_ACC_D1 || unit2 == UNIT_RAM_D1 || unit2 == UNIT_D1)\n-\treturn FALSE;\n+\treturn false;\n \n       switch (unit2)\n \t{\n \tcase UNIT_A1:\n \tcase UNIT_D0:\n \tcase UNIT_RD:\n \tcase UNIT_A0:\n-\t  return TRUE;\n+\t  return true;\n \tdefault:\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return TRUE if this is a DSP data unit.  */\n-static bfd_boolean\n+static bool\n is_dsp_data_unit (const metag_reg *reg)\n {\n   switch (reg->unit)\n@@ -4943,9 +4943,9 @@ is_dsp_data_unit (const metag_reg *reg)\n     case UNIT_ACC_D1:\n     case UNIT_RAM_D0:\n     case UNIT_RAM_D1:\n-      return TRUE;\n+      return true;\n     default:\n-      return FALSE;\n+      return false;\n     }\n }\n \n@@ -4961,15 +4961,15 @@ parse_dalu (const char *line, metag_insn *insn,\n   const metag_reg *regs[4];\n   metag_addr addr;\n   size_t regs_read;\n-  bfd_boolean is_mov = MAJOR_OPCODE (template->meta_opcode) == OPC_ADD;\n-  bfd_boolean is_cmp = ((MAJOR_OPCODE (template->meta_opcode) == OPC_CMP) &&\n-\t\t\t((template->meta_opcode & 0xee) == 0));\n-  bfd_boolean is_dual = insn->dsp_width == DSP_WIDTH_DUAL;\n-  bfd_boolean is_quickrot64 = ((insn->dsp_action_flags & DSP_ACTION_QR64) != 0);\n+  bool is_mov = MAJOR_OPCODE (template->meta_opcode) == OPC_ADD;\n+  bool is_cmp = (MAJOR_OPCODE (template->meta_opcode) == OPC_CMP\n+\t\t && (template->meta_opcode & 0xee) == 0);\n+  bool is_dual = insn->dsp_width == DSP_WIDTH_DUAL;\n+  bool is_quickrot64 = (insn->dsp_action_flags & DSP_ACTION_QR64) != 0;\n   int l1_shift = INVALID_SHIFT;\n-  bfd_boolean load = FALSE;\n+  bool load = false;\n   int ls_shift = INVALID_SHIFT;\n-  bfd_boolean ar = FALSE;\n+  bool ar = false;\n   int ar_shift = INVALID_SHIFT;\n   int regs_shift[3] = { INVALID_SHIFT, INVALID_SHIFT, INVALID_SHIFT };\n   int imm = 0;\n@@ -5002,8 +5002,8 @@ parse_dalu (const char *line, metag_insn *insn,\n \t\t     (insn->dsp_daoppame_flags & DSP_DAOPPAME_16) != 0);\n   int mx_shift = INVALID_SHIFT;\n   int size = is_dual ? 8 : 4;\n-  bfd_boolean dspram;\n-  bfd_boolean conditional = (MINOR_OPCODE (template->meta_opcode) & 0x4) != 0;\n+  bool dspram;\n+  bool conditional = (MINOR_OPCODE (template->meta_opcode) & 0x4) != 0;\n \n   /* XFIXME: check the flags are valid with the instruction.  */\n   if (is_quickrot64 && !(template->arg_type & DSP_ARGS_QR))\n@@ -5056,8 +5056,8 @@ parse_dalu (const char *line, metag_insn *insn,\n \t e.g. ACe.e,ACx.r,ACo.e */\n       if (template->arg_type & DSP_ARGS_XACC)\n \t{\n-\t  ll = parse_dsp_regs_list (l, regs, 3, &regs_read, FALSE, FALSE,\n-\t\t\t\t    FALSE, FALSE);\n+\t  ll = parse_dsp_regs_list (l, regs, 3, &regs_read, false, false,\n+\t\t\t\t    false, false);\n \t  if (ll != NULL && regs_read == 3\n \t      && is_accumulator_reg (regs[0]))\n \t    {\n@@ -5098,7 +5098,7 @@ parse_dalu (const char *line, metag_insn *insn,\n \t  a1_shift = 2;\n \t  om_shift = 3;\n \n-\t  ll = parse_dsp_reg (l, &regs[0], FALSE, FALSE);\n+\t  ll = parse_dsp_reg (l, &regs[0], false, false);\n \t  if (ll != NULL)\n \t    {\n \t      /* Using ACe.r as the dst requires one of the P,N or Z\n@@ -5113,7 +5113,7 @@ parse_dalu (const char *line, metag_insn *insn,\n \t      l = ll;\n \t      l = skip_comma (l);\n \t      l = parse_dsp_regs_list (l, &regs[1], 2, &regs_read,\n-\t\t\t\t       TRUE, FALSE, FALSE, FALSE);\n+\t\t\t\t       true, false, false, false);\n \t      if (l == NULL || regs_read != 2)\n \t\t{\n \t\t  as_bad (_(\"invalid register\"));\n@@ -5142,7 +5142,7 @@ parse_dalu (const char *line, metag_insn *insn,\n       regs_shift[0] = 19;\n \n \n-      l = parse_dsp_regs_list (l, regs, 2, &regs_read, TRUE, FALSE, FALSE, TRUE);\n+      l = parse_dsp_regs_list (l, regs, 2, &regs_read, true, false, false, true);\n       if (l == NULL || regs_read != 2)\n \treturn NULL;\n \n@@ -5202,7 +5202,7 @@ parse_dalu (const char *line, metag_insn *insn,\n \t  regs_shift[2] = 9;\n \n \t  /* Is Rs2 an accumulator reg, e.g. De.r,Dx.r,De.r|ACe.r */\n-\t  ll = parse_dsp_reg (l, &regs[2], FALSE, FALSE);\n+\t  ll = parse_dsp_reg (l, &regs[2], false, false);\n \t  if (ll != NULL)\n \t    {\n \t      l = ll;\n@@ -5215,12 +5215,12 @@ parse_dalu (const char *line, metag_insn *insn,\n \n \t      om_shift = 3;\n \t      ar_shift = 7;\n-\t      ar = TRUE;\n+\t      ar = true;\n \t    }\n \t  else\n \t    {\n \t      /* De.r,Dx.r,De.r */\n-\t      l = __parse_gp_reg (l, &regs[2], TRUE);\n+\t      l = __parse_gp_reg (l, &regs[2], true);\n \t      if (l == NULL)\n \t\treturn NULL;\n \t    }\n@@ -5247,7 +5247,7 @@ parse_dalu (const char *line, metag_insn *insn,\n \t\t  return NULL;\n \t\t}\n \n-\t      l = __parse_gp_reg (l, &regs[3], TRUE);\n+\t      l = __parse_gp_reg (l, &regs[3], true);\n \t      if (l == NULL)\n \t\t{\n \t\t  as_bad (_(\"invalid fourth register\"));\n@@ -5309,10 +5309,10 @@ parse_dalu (const char *line, metag_insn *insn,\n   /* Group 2.  */\n   if (template->arg_type & DSP_ARGS_2)\n     {\n-      bfd_boolean is_xsd = (MAJOR_OPCODE (template->meta_opcode) == OPC_MISC\n-\t\t\t    && MINOR_OPCODE (template->meta_opcode) == 0xa);\n-      bfd_boolean is_fpu_mov = template->insn_type == INSN_DSP_FPU;\n-      bfd_boolean to_fpu = ((template->meta_opcode >> 7) & 0x1) != 0;\n+      bool is_xsd = (MAJOR_OPCODE (template->meta_opcode) == OPC_MISC\n+\t\t     && MINOR_OPCODE (template->meta_opcode) == 0xa);\n+      bool is_fpu_mov = template->insn_type == INSN_DSP_FPU;\n+      bool to_fpu = ((template->meta_opcode >> 7) & 0x1) != 0;\n \n       if (is_xsd)\n \tdu_shift = 0;\n@@ -5328,7 +5328,7 @@ parse_dalu (const char *line, metag_insn *insn,\n \t  /* DSPe.r,Dx.r or DSPx.r,#I16 */\n \t  if (template->arg_type & DSP_ARGS_DSP_SRC1)\n \t    {\n-\t      l = parse_dsp_reg (l, regs, FALSE, FALSE);\n+\t      l = parse_dsp_reg (l, regs, false, false);\n \t      if (l == NULL)\n \t\t{\n \t\t  as_bad (_(\"invalid register operand #1\"));\n@@ -5421,12 +5421,12 @@ parse_dalu (const char *line, metag_insn *insn,\n \t      l1_shift = 4;\n \t    }\n \n-\t  ll = __parse_gp_reg (l, &regs[1], TRUE);\n+\t  ll = __parse_gp_reg (l, &regs[1], true);\n \t  if (ll == NULL)\n \t    {\n \t      if (template->arg_type & DSP_ARGS_DSP_SRC2)\n \t\t{\n-\t\t  l = parse_dsp_reg (l, &regs[1], FALSE, FALSE);\n+\t\t  l = parse_dsp_reg (l, &regs[1], false, false);\n \t\t  if (l == NULL)\n \t\t    {\n \t\t      as_bad (_(\"invalid register operand #3\"));\n@@ -5522,7 +5522,7 @@ parse_dalu (const char *line, metag_insn *insn,\n   du_shift = 24;\n   l1_shift = 4;\n \n-  l = __parse_gp_reg (l, regs, FALSE);\n+  l = __parse_gp_reg (l, regs, false);\n   if (l == NULL)\n     {\n       as_bad (_(\"invalid register operand\"));\n@@ -5533,7 +5533,7 @@ parse_dalu (const char *line, metag_insn *insn,\n \n   if (*l == 'A')\n     {\n-      l = parse_dsp_reg (l, &regs[1], FALSE, FALSE);\n+      l = parse_dsp_reg (l, &regs[1], false, false);\n       if (l == NULL)\n \t{\n \t  as_bad (_(\"invalid accumulator register\"));\n@@ -5544,7 +5544,7 @@ parse_dalu (const char *line, metag_insn *insn,\n     }\n   else\n     {\n-      l = __parse_gp_reg (l, &regs[1], TRUE);\n+      l = __parse_gp_reg (l, &regs[1], true);\n       if (l == NULL)\n \t{\n \t  as_bad (_(\"invalid register operand\"));\n@@ -5581,7 +5581,7 @@ parse_dalu (const char *line, metag_insn *insn,\n   else\n     {\n       regs_shift[2] = 9;\n-      l = __parse_gp_reg (l, &regs[2], TRUE);\n+      l = __parse_gp_reg (l, &regs[2], true);\n       if (l == NULL)\n \treturn NULL;\n     }\n@@ -5819,7 +5819,7 @@ static const struct metag_core_option metag_dsps[] =\n   };\n \n /* Parse a CPU command line option.  */\n-static bfd_boolean\n+static bool\n metag_parse_cpu (const char * str)\n {\n   const struct metag_core_option * opt;\n@@ -5845,7 +5845,7 @@ metag_parse_cpu (const char * str)\n }\n \n /* Parse an FPU command line option.  */\n-static bfd_boolean\n+static bool\n metag_parse_fpu (const char * str)\n {\n   const struct metag_core_option * opt;\n@@ -5871,7 +5871,7 @@ metag_parse_fpu (const char * str)\n }\n \n /* Parse a DSP command line option.  */\n-static bfd_boolean\n+static bool\n metag_parse_dsp (const char * str)\n {\n   const struct metag_core_option * opt;\n@@ -5900,7 +5900,7 @@ struct metag_long_option\n {\n   const char *option;\t\t\t/* Substring to match.  */\n   const char *help;\t\t\t/* Help information.  */\n-  bfd_boolean (*func) (const char *subopt);\t/* Function to decode sub-option.  */\n+  bool (*func) (const char *subopt);\t/* Function to decode sub-option.  */\n   const char *deprecated;\t\t/* If non-null, print this message.  */\n };\n \n@@ -6491,7 +6491,7 @@ create_scond_htab (void)\n }\n \n /* Entry point for instruction parsing.  */\n-static bfd_boolean\n+static bool\n parse_insn (const char *line, metag_insn *insn)\n {\n   char mnemonic[MAX_MNEMONIC_LEN];\n@@ -6510,7 +6510,7 @@ parse_insn (const char *line, metag_insn *insn)\n   if (mnemonic_len >= MAX_MNEMONIC_LEN)\n     {\n       as_bad (_(\"instruction mnemonic too long: %s\"), line);\n-      return FALSE;\n+      return false;\n     }\n \n   strncpy(mnemonic, line, mnemonic_len);\n@@ -6566,7 +6566,7 @@ parse_insn (const char *line, metag_insn *insn)\n \t\t  if (*end != END_OF_INSN)\n \t\t    as_bad (_(\"junk at end of line: \\\"%s\\\"\"), line);\n \t\t  else\n-\t\t    return TRUE;\n+\t\t    return true;\n \t\t}\n \t    }\n \t}\n@@ -6580,7 +6580,7 @@ parse_insn (const char *line, metag_insn *insn)\n       else\n \tas_bad (_(\"unknown mnemonic: \\\"%s\\\"\"), mnemonic);\n     }\n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -6773,7 +6773,7 @@ metag_force_relocation (fixS * fix)\n   return generic_force_reloc (fix);\n }\n \n-bfd_boolean\n+bool\n metag_fix_adjustable (fixS * fixP)\n {\n   if (fixP->fx_addsy == NULL)\n@@ -7063,7 +7063,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n     case BFD_RELOC_METAG_LOADDR16:\n     case BFD_RELOC_VTABLE_INHERIT:\n     case BFD_RELOC_VTABLE_ENTRY:\n-      fixP->fx_done = FALSE;\n+      fixP->fx_done = false;\n       break;\n \n     case BFD_RELOC_METAG_REL8:\n@@ -7132,5 +7132,5 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n     }\n \n   if (fixP->fx_addsy == NULL)\n-    fixP->fx_done = TRUE;\n+    fixP->fx_done = true;\n }"
    },
    {
      "sha": "320e0056cb8820929bb0fe2b1b2ffb49f45017a9",
      "filename": "gas/config/tc-metag.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-metag.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-metag.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-metag.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -42,7 +42,7 @@\n #define MD_APPLY_SYM_VALUE(FIX) 0\n \n #define tc_fix_adjustable(FIX) metag_fix_adjustable (FIX)\n-extern bfd_boolean metag_fix_adjustable (struct fix *);\n+extern bool metag_fix_adjustable (struct fix *);\n \n #define TC_FORCE_RELOCATION(fix) metag_force_relocation (fix)\n extern int metag_force_relocation (struct fix *);"
    },
    {
      "sha": "fcac519ca69872b3425938ba21938257fd536663",
      "filename": "gas/config/tc-microblaze.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-microblaze.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -39,7 +39,7 @@\n #define OPTION_EL (OPTION_MD_BASE + 1)\n \n void microblaze_generate_symbol (char *sym);\n-static bfd_boolean check_spl_reg (unsigned *);\n+static bool check_spl_reg (unsigned *);\n \n /* Several places in this file insert raw instructions into the\n    object. They should generate the instruction\n@@ -858,7 +858,7 @@ parse_cons_expression_microblaze (expressionS *exp, int size)\n static const char * str_microblaze_ro_anchor = \"RO\";\n static const char * str_microblaze_rw_anchor = \"RW\";\n \n-static bfd_boolean\n+static bool\n check_spl_reg (unsigned * reg)\n {\n   if ((*reg == REG_MSR)   || (*reg == REG_PC)\n@@ -869,9 +869,9 @@ check_spl_reg (unsigned * reg)\n       || (*reg == REG_TLBHI) || (*reg == REG_TLBSX)\n       || (*reg == REG_SHR)   || (*reg == REG_SLR)\n       || (*reg >= REG_PVR+MIN_PVR_REGNUM && *reg <= REG_PVR+MAX_PVR_REGNUM))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Here we decide which fixups can be adjusted to make them relative to\n@@ -1894,91 +1894,91 @@ md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED,\n     {\n     case UNDEFINED_PC_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, TRUE, BFD_RELOC_64_PCREL);\n+\t       fragP->fr_offset, true, BFD_RELOC_64_PCREL);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case DEFINED_ABS_SEGMENT:\n       if (fragP->fr_symbol == GOT_symbol)\n         fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t         fragP->fr_offset, TRUE, BFD_RELOC_MICROBLAZE_64_GOTPC);\n+\t         fragP->fr_offset, true, BFD_RELOC_MICROBLAZE_64_GOTPC);\n       else\n         fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t         fragP->fr_offset, FALSE, BFD_RELOC_64);\n+\t         fragP->fr_offset, false, BFD_RELOC_64);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case DEFINED_RO_SEGMENT:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_32_ROSDA);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_32_ROSDA);\n       fragP->fr_fix += INST_WORD_SIZE;\n       fragP->fr_var = 0;\n       break;\n     case DEFINED_RW_SEGMENT:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_32_RWSDA);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_32_RWSDA);\n       fragP->fr_fix += INST_WORD_SIZE;\n       fragP->fr_var = 0;\n       break;\n     case DEFINED_PC_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE, fragP->fr_symbol,\n-\t       fragP->fr_offset, TRUE, BFD_RELOC_MICROBLAZE_32_LO_PCREL);\n+\t       fragP->fr_offset, true, BFD_RELOC_MICROBLAZE_32_LO_PCREL);\n       fragP->fr_fix += INST_WORD_SIZE;\n       fragP->fr_var = 0;\n       break;\n     case LARGE_DEFINED_PC_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, TRUE, BFD_RELOC_64_PCREL);\n+\t       fragP->fr_offset, true, BFD_RELOC_64_PCREL);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case GOT_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_GOT);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_64_GOT);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case TEXT_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_TEXTREL);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_64_TEXTREL);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case TEXT_PC_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_TEXTPCREL);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_64_TEXTPCREL);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case PLT_OFFSET:\n       fixP = fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t              fragP->fr_offset, TRUE, BFD_RELOC_MICROBLAZE_64_PLT);\n+\t              fragP->fr_offset, true, BFD_RELOC_MICROBLAZE_64_PLT);\n       /* fixP->fx_plt = 1; */\n       (void) fixP;\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case GOTOFF_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_GOTOFF);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_64_GOTOFF);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case TLSGD_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_TLSGD);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_64_TLSGD);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case TLSLD_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_TLSLD);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_64_TLSLD);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;\n     case TLSDTPREL_OFFSET:\n       fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,\n-\t       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_TLSDTPREL);\n+\t       fragP->fr_offset, false, BFD_RELOC_MICROBLAZE_64_TLSDTPREL);\n       fragP->fr_fix += INST_WORD_SIZE * 2;\n       fragP->fr_var = 0;\n       break;"
    },
    {
      "sha": "8d8cf9963969fec75ff2c8b8d20c828f716cf57e",
      "filename": "gas/config/tc-mips.c",
      "status": "modified",
      "additions": 517,
      "deletions": 518,
      "changes": 1035,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mips.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "8f85996ecdd92d0132b388b406bb75b2a7cb8ccb",
      "filename": "gas/config/tc-mips.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mips.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mips.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mips.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -149,7 +149,7 @@ extern int mips_force_relocation (struct fix *);\n    || mips_force_relocation (FIX))\n \n #define TC_FORCE_RELOCATION_ABS(FIX) mips_force_relocation_abs (FIX)\n-extern bfd_boolean mips_force_relocation_abs (struct fix *);\n+extern bool mips_force_relocation_abs (struct fix *);\n \n /* Register mask variables.  These are set by the MIPS assembly code\n    and used by ECOFF and possibly other object file formats.  */"
    },
    {
      "sha": "495fc5a988947a21368d69d330bc2d34cc41e206",
      "filename": "gas/config/tc-mmix.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mmix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mmix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mmix.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -2287,7 +2287,7 @@ md_atof (int type, char *litP, int *sizeP)\n      The testsuite wants it, and it's customary.\n      We'll deal with the real problems when they come; we share the\n      problem with most other ports.  */\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n /* Convert variable-sized frags into one or more fixups.  */"
    },
    {
      "sha": "6323e54dc27091e0c4f821d2943983f83d3c4b64",
      "filename": "gas/config/tc-mn10200.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mn10200.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mn10200.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mn10200.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -172,7 +172,7 @@ reg_name_search (const struct reg_name *regs,\n   \tInput_line_pointer->(next non-blank) char after operand, or is in\n   \tits original state.  */\n \n-static bfd_boolean\n+static bool\n data_register_name (expressionS *expressionP)\n {\n   int reg_number;\n@@ -198,12 +198,12 @@ data_register_name (expressionS *expressionP)\n       expressionP->X_add_symbol = NULL;\n       expressionP->X_op_symbol = NULL;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n-  return FALSE;\n+  return false;\n }\n \n /* Summary of register_name().\n@@ -216,7 +216,7 @@ data_register_name (expressionS *expressionP)\n   \tInput_line_pointer->(next non-blank) char after operand, or is in\n   \tits original state.  */\n \n-static bfd_boolean\n+static bool\n address_register_name (expressionS *expressionP)\n {\n   int reg_number;\n@@ -242,12 +242,12 @@ address_register_name (expressionS *expressionP)\n       expressionP->X_add_symbol = NULL;\n       expressionP->X_op_symbol = NULL;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n-  return FALSE;\n+  return false;\n }\n \n /* Summary of register_name().\n@@ -260,7 +260,7 @@ address_register_name (expressionS *expressionP)\n   \tInput_line_pointer->(next non-blank) char after operand, or is in\n   \tits original state.  */\n \n-static bfd_boolean\n+static bool\n other_register_name (expressionS *expressionP)\n {\n   int reg_number;\n@@ -286,12 +286,12 @@ other_register_name (expressionS *expressionP)\n       expressionP->X_add_symbol = NULL;\n       expressionP->X_op_symbol = NULL;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n-  return FALSE;\n+  return false;\n }\n \n void\n@@ -317,7 +317,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litp, int *sizep)\n {\n-  return ieee_md_atof (type, litp, sizep, FALSE);\n+  return ieee_md_atof (type, litp, sizep, false);\n }\n \n void"
    },
    {
      "sha": "37f6733b275b64c81967630cf93fce5336bf04f6",
      "filename": "gas/config/tc-mn10300.c",
      "status": "modified",
      "additions": 36,
      "deletions": 36,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mn10300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mn10300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mn10300.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -323,7 +323,7 @@ reg_name_search (const struct reg_name *regs,\n    the name and the function returns TRUE.  Otherwise the input pointer\n    is left alone and the function returns FALSE.  */\n \n-static bfd_boolean\n+static bool\n get_register_name (expressionS *           expressionP,\n \t\t   const struct reg_name * table,\n \t\t   size_t                  table_length)\n@@ -352,52 +352,52 @@ get_register_name (expressionS *           expressionP,\n       expressionP->X_add_symbol = NULL;\n       expressionP->X_op_symbol = NULL;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n r_register_name (expressionS *expressionP)\n {\n   return get_register_name (expressionP, r_registers, ARRAY_SIZE (r_registers));\n }\n \n \n-static bfd_boolean\n+static bool\n xr_register_name (expressionS *expressionP)\n {\n   return get_register_name (expressionP, xr_registers, ARRAY_SIZE (xr_registers));\n }\n \n-static bfd_boolean\n+static bool\n data_register_name (expressionS *expressionP)\n {\n   return get_register_name (expressionP, data_registers, ARRAY_SIZE (data_registers));\n }\n \n-static bfd_boolean\n+static bool\n address_register_name (expressionS *expressionP)\n {\n   return get_register_name (expressionP, address_registers, ARRAY_SIZE (address_registers));\n }\n \n-static bfd_boolean\n+static bool\n float_register_name (expressionS *expressionP)\n {\n   return get_register_name (expressionP, float_registers, ARRAY_SIZE (float_registers));\n }\n \n-static bfd_boolean\n+static bool\n double_register_name (expressionS *expressionP)\n {\n   return get_register_name (expressionP, double_registers, ARRAY_SIZE (double_registers));\n }\n \n-static bfd_boolean\n+static bool\n other_register_name (expressionS *expressionP)\n {\n   int reg_number;\n@@ -425,12 +425,12 @@ other_register_name (expressionS *expressionP)\n       expressionP->X_add_symbol = NULL;\n       expressionP->X_op_symbol = NULL;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n-  return FALSE;\n+  return false;\n }\n \n void\n@@ -455,7 +455,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litp, int *sizep)\n {\n-  return ieee_md_atof (type, litp, sizep, FALSE);\n+  return ieee_md_atof (type, litp, sizep, false);\n }\n \n void\n@@ -1073,7 +1073,7 @@ mn10300_cons_fix_new (fragS *frag, int off, int size, expressionS *exp,\n   fix_new_exp (frag, off, size, &fixup.exp, 0, fixup.reloc);\n }\n \n-static bfd_boolean\n+static bool\n check_operand (const struct mn10300_operand *operand,\n \t       offsetT val)\n {\n@@ -1104,9 +1104,9 @@ check_operand (const struct mn10300_operand *operand,\n       test = val;\n \n       if (test < (offsetT) min || test > (offsetT) max)\n-\treturn FALSE;\n+\treturn false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Insert an operand value into an instruction.  */\n@@ -2155,7 +2155,7 @@ md_assemble (char *str)\n     }\n \n   /* Label this frag as one that contains instructions.  */\n-  frag_now->tc_frag_data = TRUE;\n+  frag_now->tc_frag_data = true;\n }\n \n /* If while processing a fixup, a reloc really needs to be created\n@@ -2278,7 +2278,7 @@ tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)\n /* Returns true iff the symbol attached to the frag is at a known location\n    in the given section, (and hence the relocation to it can be relaxed by\n    the assembler).  */\n-static inline bfd_boolean\n+static inline bool\n has_known_symbol_location (fragS * fragp, asection * sec)\n {\n   symbolS * sym = fragp->fr_symbol;\n@@ -2400,37 +2400,37 @@ md_apply_fix (fixS * fixP, valueT * valP, segT seg)\n /* Return zero if the fixup in fixp should be left alone and not\n    adjusted.  */\n \n-bfd_boolean\n+bool\n mn10300_fix_adjustable (struct fix *fixp)\n {\n   if (fixp->fx_pcrel)\n     {\n       if (TC_FORCE_RELOCATION_LOCAL (fixp))\n-\treturn FALSE;\n+\treturn false;\n     }\n   /* Non-relative relocs can (and must) be adjusted if they do\n      not meet the criteria below, or the generic criteria.  */\n   else if (TC_FORCE_RELOCATION (fixp))\n-    return FALSE;\n+    return false;\n \n   /* Do not adjust relocations involving symbols in code sections,\n      because it breaks linker relaxations.  This could be fixed in the\n      linker, but this fix is simpler, and it pretty much only affects\n      object size a little bit.  */\n   if (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_CODE)\n-    return FALSE;\n+    return false;\n \n   /* Likewise, do not adjust symbols that won't be merged, or debug\n      symbols, because they too break relaxation.  We do want to adjust\n      other mergeable symbols, like .rodata, because code relaxations\n      need section-relative symbols to properly relax them.  */\n   if (! (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE))\n-    return FALSE;\n+    return false;\n \n   if (strncmp (S_GET_SEGMENT (fixp->fx_addsy)->name, \".debug\", 6) == 0)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n static void\n@@ -2549,22 +2549,22 @@ const pseudo_typeS md_pseudo_table[] =\n    subtraction of two same-section symbols cannot be computed by\n    the assembler.  */\n \n-bfd_boolean\n+bool\n mn10300_allow_local_subtract (expressionS * left, expressionS * right, segT section)\n {\n-  bfd_boolean result;\n+  bool result;\n   fragS * left_frag;\n   fragS * right_frag;\n   fragS * frag;\n \n   /* If we are not performing linker relaxation then we have nothing\n      to worry about.  */\n   if (linkrelax == 0)\n-    return TRUE;\n+    return true;\n \n   /* If the symbols are not in a code section then they are OK.  */\n   if ((section->flags & SEC_CODE) == 0)\n-    return TRUE;\n+    return true;\n \n   /* Otherwise we have to scan the fragments between the two symbols.\n      If any instructions are found then we have to assume that linker\n@@ -2576,11 +2576,11 @@ mn10300_allow_local_subtract (expressionS * left, expressionS * right, segT sect\n   if (left_frag == right_frag)\n     return ! left_frag->tc_frag_data;\n \n-  result = TRUE;\n+  result = true;\n   for (frag = left_frag; frag != NULL; frag = frag->fr_next)\n     {\n       if (frag->tc_frag_data)\n-\tresult = FALSE;\n+\tresult = false;\n       if (frag == right_frag)\n \tbreak;\n     }\n@@ -2589,15 +2589,15 @@ mn10300_allow_local_subtract (expressionS * left, expressionS * right, segT sect\n     for (frag = right_frag; frag != NULL; frag = frag->fr_next)\n       {\n \tif (frag->tc_frag_data)\n-\t  result = FALSE;\n+\t  result = false;\n \tif (frag == left_frag)\n \t  break;\n       }\n \n   if (frag == NULL)\n     /* The two symbols are on disjoint fragment chains\n        - we cannot possibly compute their difference.  */\n-    return FALSE;\n+    return false;\n \n   return result;\n }\n@@ -2622,17 +2622,17 @@ mn10300_handle_align (fragS *frag)\n        The offset from the symbol is used to record the power-of-two alignment\n        value.  The size is set to 0 because the frag may already be aligned,\n        thus causing cvt_frag_to_fill to reduce the size of the frag to zero.  */\n-    fix_new (frag, frag->fr_fix, 0, & abs_symbol, frag->fr_offset, FALSE,\n+    fix_new (frag, frag->fr_fix, 0, & abs_symbol, frag->fr_offset, false,\n \t     BFD_RELOC_MN10300_ALIGN);\n }\n \n-bfd_boolean\n+bool\n mn10300_force_relocation (struct fix * fixp)\n {\n   if (linkrelax\n       && (fixp->fx_pcrel\n \t  || fixp->fx_r_type == BFD_RELOC_MN10300_ALIGN))\n-    return TRUE;\n+    return true;\n \n   return generic_force_reloc (fixp);\n }"
    },
    {
      "sha": "07735a47745bb26312eded592619b970542525db",
      "filename": "gas/config/tc-mn10300.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mn10300.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mn10300.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mn10300.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -26,7 +26,7 @@\n #define GLOBAL_OFFSET_TABLE_NAME \"_GLOBAL_OFFSET_TABLE_\"\n \n #define TC_FORCE_RELOCATION(FIX) mn10300_force_relocation (FIX)\n-extern bfd_boolean mn10300_force_relocation (struct fix *);\n+extern bool mn10300_force_relocation (struct fix *);\n \n /* tc-mn10300.c uses TC_FORCE_RELOCATION_LOCAL, a macro that should\n    only appear in write.c.  The use is likely incorrect.  Duplicating\n@@ -107,7 +107,7 @@ void mn10300_cons_fix_new (fragS *, int, int, expressionS *,\n #define md_number_to_chars number_to_chars_littleendian\n \n #define tc_fix_adjustable(FIX) mn10300_fix_adjustable (FIX)\n-extern bfd_boolean mn10300_fix_adjustable (struct fix *);\n+extern bool mn10300_fix_adjustable (struct fix *);\n \n /* We do relaxing in the assembler as well as the linker.  */\n extern const struct relax_type md_relax_table[];\n@@ -118,12 +118,12 @@ extern const struct relax_type md_relax_table[];\n /* The difference between same-section symbols may be affected by linker\n    relaxation, so do not resolve such expressions in the assembler.  */\n #define md_allow_local_subtract(l,r,s) mn10300_allow_local_subtract (l, r, s)\n-extern bfd_boolean mn10300_allow_local_subtract (expressionS *, expressionS *, segT);\n+extern bool mn10300_allow_local_subtract (expressionS *, expressionS *, segT);\n \n #define RELOC_EXPANSION_POSSIBLE\n #define MAX_RELOC_EXPANSION 2\n \n-#define TC_FRAG_TYPE bfd_boolean\n+#define TC_FRAG_TYPE bool\n \n #define HANDLE_ALIGN(frag) mn10300_handle_align (frag)\n extern void mn10300_handle_align (fragS *);"
    },
    {
      "sha": "22a29a0b74d0d1fdb12623e73826e5d554eb7a8c",
      "filename": "gas/config/tc-moxie.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-moxie.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-moxie.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-moxie.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -529,7 +529,7 @@ md_assemble (char *str)\n \t\t     (p - frag_now->fr_literal),\n \t\t     2,\n \t\t     &arg,\n-\t\t     TRUE,\n+\t\t     true,\n \t\t     BFD_RELOC_MOXIE_10_PCREL);\n       }\n       break;"
    },
    {
      "sha": "d834c00cd0ab86cf18b42b5c1469303e8e99f81b",
      "filename": "gas/config/tc-msp430.c",
      "status": "modified",
      "additions": 138,
      "deletions": 138,
      "changes": 276,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-msp430.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-msp430.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-msp430.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -263,13 +263,13 @@ typedef enum msp_isa\n \n static enum msp_isa selected_isa = MSP_ISA_430Xv2;\n \n-static inline bfd_boolean\n+static inline bool\n target_is_430x (void)\n {\n   return selected_isa >= MSP_ISA_430X;\n }\n \n-static inline bfd_boolean\n+static inline bool\n target_is_430xv2 (void)\n {\n   return selected_isa == MSP_ISA_430Xv2;\n@@ -674,21 +674,21 @@ extract_word (char * from, char * to, int limit)\n #define OPTION_RELAX 'Q'\n #define OPTION_POLYMORPHS 'P'\n #define OPTION_LARGE 'l'\n-static bfd_boolean large_model = FALSE;\n+static bool large_model = false;\n #define OPTION_NO_INTR_NOPS 'N'\n #define OPTION_INTR_NOPS 'n'\n-static bfd_boolean gen_interrupt_nops = FALSE;\n+static bool gen_interrupt_nops = false;\n #define OPTION_WARN_INTR_NOPS 'y'\n #define OPTION_NO_WARN_INTR_NOPS 'Y'\n-static bfd_boolean warn_interrupt_nops = TRUE;\n+static bool warn_interrupt_nops = true;\n #define OPTION_UNKNOWN_INTR_NOPS 'u'\n #define OPTION_NO_UNKNOWN_INTR_NOPS 'U'\n-static bfd_boolean do_unknown_interrupt_nops = TRUE;\n+static bool do_unknown_interrupt_nops = true;\n #define OPTION_MCPU 'c'\n #define OPTION_DATA_REGION 'r'\n-static bfd_boolean upper_data_region_in_use = FALSE;\n+static bool upper_data_region_in_use = false;\n /* The default is to use the lower region only.  */\n-static bfd_boolean lower_data_region_only = TRUE;\n+static bool lower_data_region_only = true;\n \n /* Deprecated option, silently ignore it for compatibility with GCC <= 10.  */\n #define OPTION_MOVE_DATA 'd'\n@@ -1444,28 +1444,28 @@ md_parse_option (int c, const char * arg)\n       return 1;\n \n     case OPTION_LARGE:\n-      large_model = TRUE;\n+      large_model = true;\n       return 1;\n \n     case OPTION_NO_INTR_NOPS:\n-      gen_interrupt_nops = FALSE;\n+      gen_interrupt_nops = false;\n       return 1;\n     case OPTION_INTR_NOPS:\n-      gen_interrupt_nops = TRUE;\n+      gen_interrupt_nops = true;\n       return 1;\n \n     case OPTION_WARN_INTR_NOPS:\n-      warn_interrupt_nops = TRUE;\n+      warn_interrupt_nops = true;\n       return 1;\n     case OPTION_NO_WARN_INTR_NOPS:\n-      warn_interrupt_nops = FALSE;\n+      warn_interrupt_nops = false;\n       return 1;\n \n     case OPTION_UNKNOWN_INTR_NOPS:\n-      do_unknown_interrupt_nops = TRUE;\n+      do_unknown_interrupt_nops = true;\n       return 1;\n     case OPTION_NO_UNKNOWN_INTR_NOPS:\n-      do_unknown_interrupt_nops = FALSE;\n+      do_unknown_interrupt_nops = false;\n       return 1;\n \n     case OPTION_MOVE_DATA:\n@@ -1475,14 +1475,14 @@ md_parse_option (int c, const char * arg)\n     case OPTION_DATA_REGION:\n       if (strcmp (arg, \"upper\") == 0\n \t  || strcmp (arg, \"either\") == 0)\n-\tupper_data_region_in_use = TRUE;\n+\tupper_data_region_in_use = true;\n       if (strcmp (arg, \"upper\") == 0\n \t  || strcmp (arg, \"either\") == 0\n \t  /* With data-region=none, the compiler has generated code assuming\n \t     data could be in the upper region, but nothing has been explicitly\n \t     placed there.  */\n \t  || strcmp (arg, \"none\") == 0)\n-\tlower_data_region_only = FALSE;\n+\tlower_data_region_only = false;\n       return 1;\n     }\n \n@@ -1826,7 +1826,7 @@ extract_cmd (char * from, char * to, int limit)\n const char *\n md_atof (int type, char * litP, int * sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \n void\n@@ -1845,7 +1845,7 @@ md_begin (void)\n   linkrelax = 1;\n }\n \n-static inline bfd_boolean\n+static inline bool\n is_regname_end (char c)\n {\n   return (c == 0 || ! ISALNUM (c));\n@@ -1895,9 +1895,9 @@ static int\n msp430_srcoperand (struct msp430_operand_s * op,\n \t\t   char * l,\n \t\t   int bin,\n-\t\t   bfd_boolean * imm_op,\n-\t\t   bfd_boolean allow_20bit_values,\n-\t\t   bfd_boolean constants_allowed)\n+\t\t   bool * imm_op,\n+\t\t   bool allow_20bit_values,\n+\t\t   bool constants_allowed)\n {\n   char * end;\n   char *__tl = l;\n@@ -1918,7 +1918,7 @@ msp430_srcoperand (struct msp430_operand_s * op,\n \t hhi(x) - x = (x >> 48) & 0xffff\n \t The value _MUST_ be an immediate expression: #hlo(1231231231).  */\n \n-      *imm_op = TRUE;\n+      *imm_op = true;\n \n       if (strncasecmp (h, \"#llo(\", 5) == 0)\n \t{\n@@ -2250,7 +2250,7 @@ msp430_srcoperand (struct msp430_operand_s * op,\n       char *m = strrchr (l, ')');\n       char *t;\n \n-      *imm_op = TRUE;\n+      *imm_op = true;\n \n       if (!h)\n \tbreak;\n@@ -2374,10 +2374,10 @@ static int\n msp430_dstoperand (struct msp430_operand_s * op,\n \t\t   char * l,\n \t\t   int bin,\n-\t\t   bfd_boolean allow_20bit_values,\n-\t\t   bfd_boolean constants_allowed)\n+\t\t   bool allow_20bit_values,\n+\t\t   bool constants_allowed)\n {\n-  bfd_boolean dummy;\n+  bool dummy;\n   int ret = msp430_srcoperand (op, l, bin, & dummy,\n \t\t\t       allow_20bit_values,\n \t\t\t       constants_allowed);\n@@ -2420,7 +2420,7 @@ msp430_dstoperand (struct msp430_operand_s * op,\n    will be returned if a pointer is provided.  */\n \n static int\n-try_encode_mova (bfd_boolean imm_op,\n+try_encode_mova (bool imm_op,\n \t\t int bin,\n \t\t struct msp430_operand_s * op1,\n \t\t struct msp430_operand_s * op2,\n@@ -2458,7 +2458,7 @@ try_encode_mova (bfd_boolean imm_op,\n \t      else\n \t\t{\n \t\t  bfd_putl16 ((bfd_vma) bin, frag);\n-\t\t  fix_new_exp (frag_now, where, 4, &(op1->exp), FALSE,\n+\t\t  fix_new_exp (frag_now, where, 4, &(op1->exp), false,\n \t\t\t       BFD_RELOC_MSP430X_ABS20_ADR_SRC);\n \t\t  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);\n \t\t}\n@@ -2486,7 +2486,7 @@ try_encode_mova (bfd_boolean imm_op,\n \t      else\n \t\t{\n \t\t  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);\n-\t\t  fix_new_exp (frag_now, where + 2, 2, &(op1->exp), FALSE,\n+\t\t  fix_new_exp (frag_now, where + 2, 2, &(op1->exp), false,\n \t\t\t       op1->reg == 0 ?\n \t\t\t       BFD_RELOC_MSP430X_PCR16 :\n \t\t\t       BFD_RELOC_MSP430X_ABS16);\n@@ -2527,7 +2527,7 @@ try_encode_mova (bfd_boolean imm_op,\n \t\t    {\n \t\t      bfd_putl16 ((bfd_vma) bin, frag);\n \t\t      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);\n-\t\t      fix_new_exp (frag_now, where, 4, &(op2->exp), FALSE,\n+\t\t      fix_new_exp (frag_now, where, 4, &(op2->exp), false,\n \t\t\t\t   BFD_RELOC_MSP430X_ABS20_ADR_DST);\n \t\t    }\n \t\t  return 4;\n@@ -2552,7 +2552,7 @@ try_encode_mova (bfd_boolean imm_op,\n \t      else\n \t\t{\n \t\t  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);\n-\t\t  fix_new_exp (frag_now, where + 2, 2, &(op2->exp), FALSE,\n+\t\t  fix_new_exp (frag_now, where + 2, 2, &(op2->exp), false,\n \t\t\t       op2->reg == 0 ?\n \t\t\t       BFD_RELOC_MSP430X_PCR16 :\n \t\t\t       BFD_RELOC_MSP430X_ABS16);\n@@ -2566,7 +2566,7 @@ try_encode_mova (bfd_boolean imm_op,\n \t}\n     }\n \n-  /* imm_op == FALSE.  */\n+  /* imm_op == false.  */\n \n   if (op1->reg == 2 && op1->am == 1 && op1->mode == OP_EXP)\n     {\n@@ -2598,7 +2598,7 @@ try_encode_mova (bfd_boolean imm_op,\n \t{\n \t  bfd_putl16 ((bfd_vma) bin, frag);\n \t  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);\n-\t  fix_new_exp (frag_now, where, 4, &(op1->exp), FALSE,\n+\t  fix_new_exp (frag_now, where, 4, &(op1->exp), false,\n \t\t       BFD_RELOC_MSP430X_ABS20_ADR_SRC);\n \t}\n       return 4;\n@@ -2720,7 +2720,7 @@ gen_nop (void)\n /* Insert/inform about adding a NOP if this insn enables interrupts.  */\n \n static void\n-warn_eint_nop (bfd_boolean prev_insn_is_nop, bfd_boolean prev_insn_is_dint)\n+warn_eint_nop (bool prev_insn_is_nop, bool prev_insn_is_dint)\n {\n   if (prev_insn_is_nop\n       /* If the last insn was a DINT, we will have already warned that a NOP is\n@@ -2744,8 +2744,8 @@ warn_eint_nop (bfd_boolean prev_insn_is_nop, bfd_boolean prev_insn_is_dint)\n    to insert/warn about adding a NOP before the current insn.  */\n \n static void\n-warn_unsure_interrupt (bfd_boolean prev_insn_is_nop,\n-\t\t       bfd_boolean prev_insn_is_dint)\n+warn_unsure_interrupt (bool prev_insn_is_nop,\n+\t\t       bool prev_insn_is_dint)\n {\n   if (prev_insn_is_nop\n       /* If the last insn was a DINT, we will have already warned that a NOP is\n@@ -2780,55 +2780,55 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n   struct msp430_operand_s op1, op2;\n   int res = 0;\n   static short ZEROS = 0;\n-  bfd_boolean byte_op, imm_op;\n+  bool byte_op, imm_op;\n   int op_length = 0;\n   int fmt;\n   int extended = 0x1800;\n-  bfd_boolean extended_op = FALSE;\n-  bfd_boolean addr_op;\n+  bool extended_op = false;\n+  bool addr_op;\n   const char * error_message;\n   static signed int repeat_count = 0;\n-  static bfd_boolean prev_insn_is_nop = FALSE;\n-  static bfd_boolean prev_insn_is_dint = FALSE;\n-  static bfd_boolean prev_insn_is_eint = FALSE;\n+  static bool prev_insn_is_nop = false;\n+  static bool prev_insn_is_dint = false;\n+  static bool prev_insn_is_eint = false;\n   /* We might decide before the end of the function that the current insn is\n      equivalent to DINT/EINT.  */\n-  bfd_boolean this_insn_is_dint = FALSE;\n-  bfd_boolean this_insn_is_eint = FALSE;\n-  bfd_boolean fix_emitted;\n+  bool this_insn_is_dint = false;\n+  bool this_insn_is_eint = false;\n+  bool fix_emitted;\n \n   /* Opcode is the one from opcodes table\n      line contains something like\n      [.w] @r2+, 5(R1)\n      or\n      .b @r2+, 5(R1).  */\n \n-  byte_op = FALSE;\n-  addr_op = FALSE;\n+  byte_op = false;\n+  addr_op = false;\n   if (*line == '.')\n     {\n-      bfd_boolean check = FALSE;\n+      bool check = false;\n       ++ line;\n \n       switch (TOLOWER (* line))\n \t{\n \tcase 'b':\n \t  /* Byte operation.  */\n \t  bin |= BYTE_OPERATION;\n-\t  byte_op = TRUE;\n-\t  check = TRUE;\n+\t  byte_op = true;\n+\t  check = true;\n \t  break;\n \n \tcase 'a':\n \t  /* \"Address\" ops work on 20-bit values.  */\n-\t  addr_op = TRUE;\n+\t  addr_op = true;\n \t  bin |= BYTE_OPERATION;\n-\t  check = TRUE;\n+\t  check = true;\n \t  break;\n \n \tcase 'w':\n \t  /* Word operation - this is the default.  */\n-\t  check = TRUE;\n+\t  check = true;\n \t  break;\n \n \tcase 0:\n@@ -2879,7 +2879,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n #if 0 /* Enable for debugging.  */\n       as_warn (\"treating %s.a as %s\", old_name, real_name);\n #endif\n-      addr_op = FALSE;\n+      addr_op = false;\n       bin = opcode->bin_opcode;\n     }\n \n@@ -2899,7 +2899,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n   memset (&op1, 0, sizeof (op1));\n   memset (&op2, 0, sizeof (op2));\n \n-  imm_op = FALSE;\n+  imm_op = false;\n \n   if ((fmt = opcode->fmt) < 0)\n     {\n@@ -2911,7 +2911,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t}\n \n       fmt = (-fmt) - 1;\n-      extended_op = TRUE;\n+      extended_op = true;\n     }\n \n   if (repeat_count)\n@@ -3053,7 +3053,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \tcase 1:\n \t  /* Something which works with destination operand.  */\n \t  line = extract_operand (line, l1, sizeof (l1));\n-\t  res = msp430_dstoperand (&op1, l1, opcode->bin_opcode, extended_op, TRUE);\n+\t  res = msp430_dstoperand (&op1, l1, opcode->bin_opcode, extended_op, true);\n \t  if (res)\n \t    break;\n \n@@ -3111,10 +3111,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t    extended |= ((op1.exp.X_add_number >> 16) & 0xf) << 7;\n \n \t\t  else if (op1.reg || op1.am == 3)\t/* Not PC relative.  */\n-\t\t    fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,\n+\t\t    fix_new_exp (frag_now, where, 6, &(op1.exp), false,\n \t\t\t\t BFD_RELOC_MSP430X_ABS20_EXT_SRC);\n \t\t  else\n-\t\t    fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,\n+\t\t    fix_new_exp (frag_now, where, 6, &(op1.exp), false,\n \t\t\t\t BFD_RELOC_MSP430X_PCR20_EXT_SRC);\n \t\t}\n \n@@ -3142,10 +3142,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t    {\n \t\t      if (op1.reg)\n \t\t\tfix_new_exp (frag_now, where, 2,\n-\t\t\t\t     &(op1.exp), FALSE, CHECK_RELOC_MSP430 (op1));\n+\t\t\t\t     &(op1.exp), false, CHECK_RELOC_MSP430 (op1));\n \t\t      else\n \t\t\tfix_new_exp (frag_now, where, 2,\n-\t\t\t\t     &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);\n+\t\t\t\t     &(op1.exp), true, CHECK_RELOC_MSP430_PCREL);\n \t\t    }\n \t\t}\n \t    }\n@@ -3158,8 +3158,8 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t  line = extract_operand (line, l1, sizeof (l1));\n \t  strncpy (l2, l1, sizeof (l2));\n \t  l2[sizeof (l2) - 1] = '\\0';\n-\t  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, TRUE);\n-\t  res += msp430_dstoperand (&op2, l2, opcode->bin_opcode, extended_op, TRUE);\n+\t  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, true);\n+\t  res += msp430_dstoperand (&op2, l2, opcode->bin_opcode, extended_op, true);\n \n \t  if (res)\n \t    break;\t/* An error occurred.  All warnings were done before.  */\n@@ -3212,10 +3212,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t    extended |= ((op1.exp.X_add_number >> 16) & 0xf) << 7;\n \n \t\t  else if (op1.reg || op1.am == 3)\t/* Not PC relative.  */\n-\t\t    fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,\n+\t\t    fix_new_exp (frag_now, where, 6, &(op1.exp), false,\n \t\t\t\t BFD_RELOC_MSP430X_ABS20_EXT_SRC);\n \t\t  else\n-\t\t    fix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,\n+\t\t    fix_new_exp (frag_now, where, 6, &(op1.exp), false,\n \t\t\t\t BFD_RELOC_MSP430X_PCR20_EXT_SRC);\n \t\t}\n \n@@ -3225,11 +3225,11 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t    extended |= (op2.exp.X_add_number >> 16) & 0xf;\n \n \t\t  else if (op1.mode == OP_EXP)\n-\t\t    fix_new_exp (frag_now, where, 8, &(op2.exp), FALSE,\n+\t\t    fix_new_exp (frag_now, where, 8, &(op2.exp), false,\n \t\t\t\t op2.reg ? BFD_RELOC_MSP430X_ABS20_EXT_ODST\n \t\t\t\t : BFD_RELOC_MSP430X_PCR20_EXT_ODST);\n \t\t  else\n-\t\t    fix_new_exp (frag_now, where, 6, &(op2.exp), FALSE,\n+\t\t    fix_new_exp (frag_now, where, 6, &(op2.exp), false,\n \t\t\t\t op2.reg ? BFD_RELOC_MSP430X_ABS20_EXT_DST\n \t\t\t\t : BFD_RELOC_MSP430X_PCR20_EXT_DST);\n \t\t}\n@@ -3259,10 +3259,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t    {\n \t\t      if (op1.reg || op1.am == 3)\t/* Not PC relative.  */\n \t\t\tfix_new_exp (frag_now, where, 2,\n-\t\t\t\t     &(op1.exp), FALSE, CHECK_RELOC_MSP430 (op1));\n+\t\t\t\t     &(op1.exp), false, CHECK_RELOC_MSP430 (op1));\n \t\t      else\n \t\t\tfix_new_exp (frag_now, where, 2,\n-\t\t\t\t     &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);\n+\t\t\t\t     &(op1.exp), true, CHECK_RELOC_MSP430_PCREL);\n \t\t    }\n \t\t}\n \t      frag += 2;\n@@ -3283,10 +3283,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t    {\n \t\t      if (op2.reg)\t/* Not PC relative.  */\n \t\t\tfix_new_exp (frag_now, where, 2,\n-\t\t\t\t     &(op2.exp), FALSE, CHECK_RELOC_MSP430 (op2));\n+\t\t\t\t     &(op2.exp), false, CHECK_RELOC_MSP430 (op2));\n \t\t      else\n \t\t\tfix_new_exp (frag_now, where, 2,\n-\t\t\t\t     &(op2.exp), TRUE, CHECK_RELOC_MSP430_PCREL);\n+\t\t\t\t     &(op2.exp), true, CHECK_RELOC_MSP430_PCREL);\n \t\t    }\n \t\t}\n \t    }\n@@ -3303,12 +3303,12 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t    }\n \n \t  line = extract_operand (line, l1, sizeof (l1));\n-\t  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, FALSE);\n+\t  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, false);\n \t  if (res)\n \t    break;\n \n-\t  byte_op = FALSE;\n-\t  imm_op = FALSE;\n+\t  byte_op = false;\n+\t  imm_op = false;\n \t  bin |= ((op1.reg << 8) | (op1.am << 4));\n \t  op_length = 2 + 2 * op1.ol;\n \t  frag = frag_more (op_length);\n@@ -3329,10 +3329,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \n \t\t  if (op1.reg || op1.am == 3)\n \t\t    fix_new_exp (frag_now, where, 2,\n-\t\t\t\t &(op1.exp), FALSE, CHECK_RELOC_MSP430 (op1));\n+\t\t\t\t &(op1.exp), false, CHECK_RELOC_MSP430 (op1));\n \t\t  else\n \t\t    fix_new_exp (frag_now, where, 2,\n-\t\t\t\t &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);\n+\t\t\t\t &(op1.exp), true, CHECK_RELOC_MSP430_PCREL);\n \t\t}\n \t    }\n \n@@ -3341,17 +3341,17 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \n \tcase 4:\n \t  /* CALLA instructions.  */\n-\t  fix_emitted = FALSE;\n+\t  fix_emitted = false;\n \n \t  line = extract_operand (line, l1, sizeof (l1));\n-\t  imm_op = FALSE;\n+\t  imm_op = false;\n \n \t  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op,\n-\t\t\t\t   extended_op, FALSE);\n+\t\t\t\t   extended_op, false);\n \t  if (res)\n \t    break;\n \n-\t  byte_op = FALSE;\n+\t  byte_op = false;\n \n \t  op_length = 2 + 2 * op1.ol;\n \t  frag = frag_more (op_length);\n@@ -3363,19 +3363,19 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t{\n \t\t  bin |= 0xb0;\n \n-\t\t  fix_new_exp (frag_now, where, 4, &(op1.exp), FALSE,\n+\t\t  fix_new_exp (frag_now, where, 4, &(op1.exp), false,\n \t\t\t       BFD_RELOC_MSP430X_ABS20_ADR_DST);\n-\t\t  fix_emitted = TRUE;\n+\t\t  fix_emitted = true;\n \t\t}\n \t      else if (op1.am == 1)\n \t\t{\n \t\t  if (op1.reg == 0)\n \t\t    {\n \t\t      bin |=  0x90;\n \n-\t\t      fix_new_exp (frag_now, where, 4, &(op1.exp), FALSE,\n+\t\t      fix_new_exp (frag_now, where, 4, &(op1.exp), false,\n \t\t\t\t   BFD_RELOC_MSP430X_PCR20_CALL);\n-\t\t      fix_emitted = TRUE;\n+\t\t      fix_emitted = true;\n \t\t    }\n \t\t  else\n \t\t    bin |=  0x50 | op1.reg;\n@@ -3387,9 +3387,9 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t    {\n \t      bin |= 0x80;\n \n-\t      fix_new_exp (frag_now, where, 4, &(op1.exp), FALSE,\n+\t      fix_new_exp (frag_now, where, 4, &(op1.exp), false,\n \t\t\t   BFD_RELOC_MSP430X_ABS20_ADR_DST);\n-\t      fix_emitted = TRUE;\n+\t      fix_emitted = true;\n \t    }\n \t  else if (op1.am == 2)\n \t    bin |= 0x60 | op1.reg;\n@@ -3410,7 +3410,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \n \t      if (! fix_emitted)\n \t\tfix_new_exp (frag_now, where + 2, 2,\n-\t\t\t     &(op1.exp), FALSE, BFD_RELOC_16);\n+\t\t\t     &(op1.exp), false, BFD_RELOC_16);\n \t    }\n \n \t  dwarf2_emit_insn (insn_length + op_length);\n@@ -3556,7 +3556,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \n \tcase 8:\n \t  {\n-\t    bfd_boolean need_reloc = FALSE;\n+\t    bool need_reloc = false;\n \t    int n;\n \t    int reg;\n \n@@ -3596,7 +3596,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\telse\n \t\t  {\n \t\t    n = 0;\n-\t\t    need_reloc = TRUE;\n+\t\t    need_reloc = true;\n \t\t  }\n \n \t\top_length = 4;\n@@ -3625,7 +3625,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t    where = frag - frag_now->fr_literal;\n \t    bin |= reg;\n \t    if (need_reloc)\n-\t      fix_new_exp (frag_now, where, 4, &(op1.exp), FALSE,\n+\t      fix_new_exp (frag_now, where, 4, &(op1.exp), false,\n \t\t\t   BFD_RELOC_MSP430X_ABS20_ADR_SRC);\n \n \t    bfd_putl16 ((bfd_vma) bin, frag);\n@@ -3636,7 +3636,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t  }\n \n \tcase 9: /* MOVA, BRA, RETA.  */\n-\t  imm_op = FALSE;\n+\t  imm_op = false;\n \t  bin = opcode->bin_opcode;\n \n \t  if (is_opcode (\"reta\"))\n@@ -3655,7 +3655,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t    {\n \t      line = extract_operand (line, l1, sizeof (l1));\n \t      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode,\n-\t\t\t\t       &imm_op, extended_op, FALSE);\n+\t\t\t\t       &imm_op, extended_op, false);\n \n \t      if (is_opcode (\"bra\"))\n \t\t{\n@@ -3668,7 +3668,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t{\n \t\t  line = extract_operand (line, l2, sizeof (l2));\n \t\t  res += msp430_dstoperand (&op2, l2, opcode->bin_opcode,\n-\t\t\t\t\t    extended_op, TRUE);\n+\t\t\t\t\t    extended_op, true);\n \t\t}\n \n \t      if (res)\n@@ -3747,8 +3747,8 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n     case 1:\t\t\t/* Format 1, double operand.  */\n       line = extract_operand (line, l1, sizeof (l1));\n       line = extract_operand (line, l2, sizeof (l2));\n-      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, TRUE);\n-      res += msp430_dstoperand (&op2, l2, opcode->bin_opcode, extended_op, TRUE);\n+      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op, extended_op, true);\n+      res += msp430_dstoperand (&op2, l2, opcode->bin_opcode, extended_op, true);\n \n       if (res)\n \tbreak;\t\t\t/* Error occurred.  All warnings were done before.  */\n@@ -3819,11 +3819,11 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t{\n \t\t  /* The GIE bit is being set.  */\n \t\t  warn_eint_nop (prev_insn_is_nop, prev_insn_is_dint);\n-\t\t  this_insn_is_eint = TRUE;\n+\t\t  this_insn_is_eint = true;\n \t\t}\n \t      else\n \t\t/* The GIE bit is being cleared.  */\n-\t\tthis_insn_is_dint = TRUE;\n+\t\tthis_insn_is_dint = true;\n \t    }\n \t  /* If an immediate value which is covered by the constant generator\n \t     is the src, then op1 will have been changed to either R2 or R3 by\n@@ -3837,13 +3837,13 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t   && (bin & 0x30) == 0x30)\n \t    {\n \t      warn_eint_nop (prev_insn_is_nop, prev_insn_is_dint);\n-\t      this_insn_is_eint = TRUE;\n+\t      this_insn_is_eint = true;\n \t    }\n \t  /* Any other use of the constant generator with destination R2, will\n \t     disable interrupts.  */\n \t  else if (op1.mode == OP_REG\n \t\t   && (op1.reg == 2 || op1.reg == 3))\n-\t    this_insn_is_dint = TRUE;\n+\t    this_insn_is_dint = true;\n \t  else if (do_unknown_interrupt_nops)\n \t    {\n \t      /* FIXME: Couldn't work out whether the insn is enabling or\n@@ -3891,10 +3891,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\textended |= ((op1.exp.X_add_number >> 16) & 0xf) << 7;\n \n \t      else  if (op1.reg || op1.am == 3)\t/* Not PC relative.  */\n-\t\tfix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,\n+\t\tfix_new_exp (frag_now, where, 6, &(op1.exp), false,\n \t\t\t     BFD_RELOC_MSP430X_ABS20_EXT_SRC);\n \t      else\n-\t\tfix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,\n+\t\tfix_new_exp (frag_now, where, 6, &(op1.exp), false,\n \t\t\t     BFD_RELOC_MSP430X_PCR20_EXT_SRC);\n \t    }\n \n@@ -3904,12 +3904,12 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\textended |= (op2.exp.X_add_number >> 16) & 0xf;\n \n \t      else if (op1.mode == OP_EXP)\n-\t\tfix_new_exp (frag_now, where, 8, &(op2.exp), FALSE,\n+\t\tfix_new_exp (frag_now, where, 8, &(op2.exp), false,\n \t\t\t     op2.reg ? BFD_RELOC_MSP430X_ABS20_EXT_ODST\n \t\t\t     : BFD_RELOC_MSP430X_PCR20_EXT_ODST);\n \n \t      else\n-\t\tfix_new_exp (frag_now, where, 6, &(op2.exp), FALSE,\n+\t\tfix_new_exp (frag_now, where, 6, &(op2.exp), false,\n \t\t\t     op2.reg ? BFD_RELOC_MSP430X_ABS20_EXT_DST\n \t\t\t     : BFD_RELOC_MSP430X_PCR20_EXT_DST);\n \t    }\n@@ -3938,10 +3938,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t{\n \t\t  if (op1.reg || op1.am == 3)\t/* Not PC relative.  */\n \t\t    fix_new_exp (frag_now, where, 2,\n-\t\t\t\t &(op1.exp), FALSE, CHECK_RELOC_MSP430 (op1));\n+\t\t\t\t &(op1.exp), false, CHECK_RELOC_MSP430 (op1));\n \t\t  else\n \t\t    fix_new_exp (frag_now, where, 2,\n-\t\t\t\t &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);\n+\t\t\t\t &(op1.exp), true, CHECK_RELOC_MSP430_PCREL);\n \t\t}\n \t    }\n \n@@ -3963,10 +3963,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t{\n \t\t  if (op2.reg)\t\t/* Not PC relative.  */\n \t\t    fix_new_exp (frag_now, where, 2,\n-\t\t\t\t &(op2.exp), FALSE, CHECK_RELOC_MSP430 (op2));\n+\t\t\t\t &(op2.exp), false, CHECK_RELOC_MSP430 (op2));\n \t\t  else\n \t\t    fix_new_exp (frag_now, where, 2,\n-\t\t\t\t &(op2.exp), TRUE, CHECK_RELOC_MSP430_PCREL);\n+\t\t\t\t &(op2.exp), true, CHECK_RELOC_MSP430_PCREL);\n \t\t}\n \t    }\n \t}\n@@ -3993,7 +3993,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \n       line = extract_operand (line, l1, sizeof (l1));\n       res = msp430_srcoperand (&op1, l1, opcode->bin_opcode,\n-\t\t\t       &imm_op, extended_op, TRUE);\n+\t\t\t       &imm_op, extended_op, true);\n       if (res)\n \tbreak;\t\t/* Error in operand.  */\n \n@@ -4059,10 +4059,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\textended |= ((op1.exp.X_add_number >> 16) & 0xf) << 7;\n \n \t      else if (op1.reg || op1.am == 3)\t/* Not PC relative.  */\n-\t\tfix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,\n+\t\tfix_new_exp (frag_now, where, 6, &(op1.exp), false,\n \t\t\t     BFD_RELOC_MSP430X_ABS20_EXT_SRC);\n \t      else\n-\t\tfix_new_exp (frag_now, where, 6, &(op1.exp), FALSE,\n+\t\tfix_new_exp (frag_now, where, 6, &(op1.exp), false,\n \t\t\t     BFD_RELOC_MSP430X_PCR20_EXT_SRC);\n \t    }\n \n@@ -4091,10 +4091,10 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t\t{\n \t\t  if (op1.reg || op1.am == 3)\t/* Not PC relative.  */\n \t\t    fix_new_exp (frag_now, where, 2,\n-\t\t\t\t &(op1.exp), FALSE, CHECK_RELOC_MSP430 (op1));\n+\t\t\t\t &(op1.exp), false, CHECK_RELOC_MSP430 (op1));\n \t\t  else\n \t\t    fix_new_exp (frag_now, where, 2,\n-\t\t\t\t &(op1.exp), TRUE, CHECK_RELOC_MSP430_PCREL);\n+\t\t\t\t &(op1.exp), true, CHECK_RELOC_MSP430_PCREL);\n \t\t}\n \t    }\n \t}\n@@ -4174,7 +4174,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \t      frag = frag_more (2);\t/* Instr size is 1 word.  */\n \t      where = frag - frag_now->fr_literal;\n \t      fix_new_exp (frag_now, where, 2,\n-\t\t\t   &exp, TRUE, BFD_RELOC_MSP430_10_PCREL);\n+\t\t\t   &exp, true, BFD_RELOC_MSP430_10_PCREL);\n \n \t      bfd_putl16 ((bfd_vma) bin, frag);\n \t    }\n@@ -4301,30 +4301,30 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n \n     if (is_opcode (\"nop\"))\n       {\n-\tprev_insn_is_nop = TRUE;\n-\tprev_insn_is_dint = FALSE;\n-\tprev_insn_is_eint = FALSE;\n+\tprev_insn_is_nop = true;\n+\tprev_insn_is_dint = false;\n+\tprev_insn_is_eint = false;\n       }\n     else if (this_insn_is_dint || is_dint (opcode->name, bin))\n       {\n-\tprev_insn_is_dint = TRUE;\n-\tprev_insn_is_eint = FALSE;\n-\tprev_insn_is_nop = FALSE;\n+\tprev_insn_is_dint = true;\n+\tprev_insn_is_eint = false;\n+\tprev_insn_is_nop = false;\n \tcheck_for_nop |= NOP_CHECK_INTERRUPT;\n       }\n     /* NOP is not needed after EINT for 430 ISA.  */\n     else if (target_is_430x () && (this_insn_is_eint || is_eint (opcode->name, bin)))\n       {\n-\tprev_insn_is_eint = TRUE;\n-\tprev_insn_is_nop = FALSE;\n-\tprev_insn_is_dint = FALSE;\n+\tprev_insn_is_eint = true;\n+\tprev_insn_is_nop = false;\n+\tprev_insn_is_dint = false;\n \tcheck_for_nop |= NOP_CHECK_INTERRUPT;\n       }\n     else\n       {\n-\tprev_insn_is_nop = FALSE;\n-\tprev_insn_is_dint = FALSE;\n-\tprev_insn_is_eint = FALSE;\n+\tprev_insn_is_nop = false;\n+\tprev_insn_is_dint = false;\n+\tprev_insn_is_eint = false;\n       }\n \n   input_line_pointer = line;\n@@ -4603,14 +4603,14 @@ md_apply_fix (fixS * fixp, valueT * valuep, segT seg)\n     }\n }\n \n-static bfd_boolean\n+static bool\n S_IS_GAS_LOCAL (symbolS * s)\n {\n   const char * name;\n   unsigned int len;\n \n   if (s == NULL)\n-    return FALSE;\n+    return false;\n   name = S_GET_NAME (s);\n   len = strlen (name) - 1;\n \n@@ -4916,7 +4916,7 @@ md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED,\n \t   another fix will be applied to the next word of insn anyway.  */\n \tif (hc->tlab == 2)\n \t  fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,\n-\t\t   fragP->fr_offset, TRUE, rela);\n+\t\t   fragP->fr_offset, true, rela);\n \tfragP->fr_fix += 2;\n       }\n \n@@ -4960,7 +4960,7 @@ md_convert_frag (bfd * abfd ATTRIBUTE_UNUSED,\n \n   /* Now apply fix.  */\n   fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,\n-\t   fragP->fr_offset, TRUE, rela);\n+\t   fragP->fr_offset, true, rela);\n   /* Just fixed 2 bytes.  */\n   fragP->fr_fix += 2;\n }\n@@ -5045,15 +5045,15 @@ msp430_relax_frag (segT seg ATTRIBUTE_UNUSED, fragS * fragP,\n    adjusted.   We return FALSE here so that linker relaxation will\n    work.  */\n \n-bfd_boolean\n+bool\n msp430_fix_adjustable (struct fix *fixp ATTRIBUTE_UNUSED)\n {\n   /* If the symbol is in a non-code section then it should be OK.  */\n   if (fixp->fx_addsy\n       && ((S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_CODE) == 0))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Scan uleb128 subtraction expressions and insert fixups for them.\n@@ -5152,23 +5152,23 @@ msp430_md_end (void)\n    subtraction of two same-section symbols cannot be computed by\n    the assembler.  */\n \n-bfd_boolean\n+bool\n msp430_allow_local_subtract (expressionS * left,\n \t\t\t     expressionS * right,\n \t\t\t     segT section)\n {\n   /* If the symbols are not in a code section then they are OK.  */\n   if ((section->flags & SEC_CODE) == 0)\n-    return TRUE;\n+    return true;\n \n   if (S_IS_GAS_LOCAL (left->X_add_symbol) || S_IS_GAS_LOCAL (right->X_add_symbol))\n-    return TRUE;\n+    return true;\n \n   if (left->X_add_symbol == right->X_add_symbol)\n-    return TRUE;\n+    return true;\n \n   /* We have to assume that there may be instructions between the\n      two symbols and that relaxation may increase the distance between\n      them.  */\n-  return FALSE;\n+  return false;\n }"
    },
    {
      "sha": "f4791156ed9779a382434ae99616d9d8e083c838",
      "filename": "gas/config/tc-msp430.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-msp430.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-msp430.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-msp430.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -127,7 +127,7 @@ extern int msp430_enable_relax;\n extern int msp430_enable_polys;\n \n #define tc_fix_adjustable(FIX) msp430_fix_adjustable (FIX)\n-extern bfd_boolean             msp430_fix_adjustable (struct fix *);\n+extern bool msp430_fix_adjustable (struct fix *);\n \n /* Allow hexadecimal numbers with 'h' suffix.  Note that if the number\n    starts with a letter it will be interpreted as a symbol name not a\n@@ -146,7 +146,7 @@ extern void    msp430_md_end (void);\n /* The difference between same-section symbols may be affected by linker\n    relaxation, so do not resolve such expressions in the assembler.  */\n #define md_allow_local_subtract(l,r,s) msp430_allow_local_subtract (l, r, s)\n-extern bfd_boolean msp430_allow_local_subtract (expressionS *, expressionS *, segT);\n+extern bool msp430_allow_local_subtract (expressionS *, expressionS *, segT);\n \n #define RELOC_EXPANSION_POSSIBLE\n #define MAX_RELOC_EXPANSION 2"
    },
    {
      "sha": "49878991899eade65bdc8125dba4f7c1b401a451",
      "filename": "gas/config/tc-mt.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mt.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -179,7 +179,7 @@ md_begin (void)\n   /* Set the machine type.  */\n   bfd_default_set_arch_mach (stdoutput, bfd_arch_mt, mt_mach);\n \n-  literal_prefix_dollar_hex = TRUE;\n+  literal_prefix_dollar_hex = true;\n }\n \n void\n@@ -438,7 +438,7 @@ md_number_to_chars (char * buf, valueT val, int n)\n const char *\n md_atof (int type, char * litP, int * sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \n /* See whether we need to force a relocation into the output file.  */\n@@ -458,7 +458,7 @@ mt_apply_fix (fixS *fixP, valueT *valueP, segT seg)\n   gas_cgen_md_apply_fix (fixP, valueP, seg);\n }\n \n-bfd_boolean\n+bool\n mt_fix_adjustable (fixS * fixP)\n {\n   if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)\n@@ -472,14 +472,14 @@ mt_fix_adjustable (fixS * fixP)\n     }\n \n   if (fixP->fx_addsy == NULL)\n-    return TRUE;\n+    return true;\n \n   /* Prevent all adjustments to global symbols.  */\n   if (S_IS_EXTERNAL (fixP->fx_addsy))\n-    return FALSE;\n+    return false;\n \n   if (S_IS_WEAK (fixP->fx_addsy))\n-    return FALSE;\n+    return false;\n \n-  return 1;\n+  return true;\n }"
    },
    {
      "sha": "77bb7d29ed4d5a255730d84547abfb8884370e03",
      "filename": "gas/config/tc-mt.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mt.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-mt.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mt.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -61,5 +61,5 @@ extern void gas_cgen_md_operand (expressionS *);\n extern int mt_force_relocation (struct fix *);\n \n #define tc_fix_adjustable(fixP) mt_fix_adjustable (fixP)\n-extern bfd_boolean mt_fix_adjustable (struct fix *);\n+extern bool mt_fix_adjustable (struct fix *);\n "
    },
    {
      "sha": "29ef3dfa7f9e79c030b4f683f517b9634b26a1cc",
      "filename": "gas/config/tc-nds32.c",
      "status": "modified",
      "additions": 275,
      "deletions": 275,
      "changes": 550,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-nds32.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -54,7 +54,7 @@ const char FLT_CHARS[] = \"dDfF\";\n static int enable_16bit = 1;\n /* Save for md_assemble to distinguish if this instruction is\n    expanded from the pseudo instruction.  */\n-static bfd_boolean pseudo_opcode = FALSE;\n+static bool pseudo_opcode = false;\n static struct nds32_relocs_pattern *relocs_list = NULL;\n /* Save instruction relation to inserting relaxation relocation.  */\n struct nds32_relocs_pattern\n@@ -99,7 +99,7 @@ static int label_exist = 0;\n static int in_omit_fp = 0;\n extern struct nds32_keyword keyword_gpr[];\n /* Tag there is relax relocation having to link.  */\n-static bfd_boolean relaxing = FALSE;\n+static bool relaxing = false;\n /* ICT model.  */\n enum ict_option {\n   ICT_NONE = 0,\n@@ -119,7 +119,7 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S16M,\n     .cond_field =\n       {\n-\t{0, 0, 0, FALSE}\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n@@ -194,17 +194,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S64K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \t  INSN_BGEZAL\t/* bgezal $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -220,8 +220,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -237,8 +237,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -255,8 +255,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -277,8 +277,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -301,17 +301,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S64K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \t  INSN_BLTZAL\t/* bltzal $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -327,8 +327,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -344,8 +344,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -362,8 +362,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -384,8 +384,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -408,7 +408,7 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S16M,\n     .cond_field =\n       {\n-\t{0, 0, 0, FALSE}\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n@@ -483,7 +483,7 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 0, 0, FALSE}\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n@@ -558,8 +558,8 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S64K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     /* We do not use beqz38 and beqzs8 here directly because we\n        don't want to check register number for specail condition.  */\n@@ -569,8 +569,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -587,8 +587,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -604,8 +604,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -622,8 +622,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -650,8 +650,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -675,17 +675,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S64K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BGEZ\t/* bgez $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -701,8 +701,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -718,8 +718,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -736,8 +736,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -757,8 +757,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -781,17 +781,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S64K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BNEZ\t/* bnez $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -808,8 +808,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -825,8 +825,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -843,8 +843,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -867,8 +867,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -892,17 +892,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S64K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BGTZ\t/* bgtz $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -918,8 +918,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -935,8 +935,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -953,8 +953,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -975,8 +975,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -999,17 +999,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S64K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BLEZ\t/* blez $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -1025,8 +1025,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -1042,8 +1042,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -1060,8 +1060,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -1082,8 +1082,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -1106,17 +1106,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S64K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BLTZ\t/* bltz $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -1132,8 +1132,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -1149,8 +1149,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -1167,8 +1167,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -1189,8 +1189,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false},\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -1213,19 +1213,19 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S16K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BEQ\t/* beq $rt, $ra, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -1242,9 +1242,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -1261,9 +1261,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S64K] = 8,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -1284,9 +1284,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -1309,9 +1309,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -1335,19 +1335,19 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S16K,\n     .cond_field =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BNE\t/* bne $rt, $ra, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -1364,9 +1364,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -1383,9 +1383,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S64K] = 8,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -1406,9 +1406,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -1431,9 +1431,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 15, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 15, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -1457,17 +1457,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 8, 0x7, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BEQZ38 << 16\t/* beqz $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 8, 0x7, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S256] = 2,\n     .relax_branch_isize[BR_RANGE_S256] = 2,\n@@ -1483,8 +1483,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -1500,8 +1500,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -1518,8 +1518,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -1542,8 +1542,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -1567,17 +1567,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 8, 0x7, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BNEZ38 << 16\t/* bnez $rt, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 8, 0x7, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S256] = 2,\n     .relax_branch_isize[BR_RANGE_S256] = 2,\n@@ -1593,8 +1593,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -1610,8 +1610,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S64K] = 4,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -1628,8 +1628,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -1652,8 +1652,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -1677,7 +1677,7 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 0, 0, FALSE}\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n@@ -1761,7 +1761,7 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 0, 0, FALSE}\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n@@ -1845,17 +1845,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 8, 0x7, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BNES38 << 16\t/* bne $rt, $r5, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 8, 0x7, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S256] = 2,\n     .relax_branch_isize[BR_RANGE_S256] = 2,\n@@ -1871,8 +1871,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -1889,8 +1889,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S64K] = 8,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -1911,8 +1911,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -1935,8 +1935,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -1960,17 +1960,17 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 8, 0x7, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BEQS38 << 16\t/* beq $rt, $r5, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 8, 0x7, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S256] = 2,\n     .relax_branch_isize[BR_RANGE_S256] = 2,\n@@ -1986,8 +1986,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16K] = 4,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -2004,8 +2004,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S64K] = 8,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -2026,8 +2026,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -2050,8 +2050,8 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -2075,19 +2075,19 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 8, 0x7FF, TRUE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, true},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \tINSN_BEQC\t/* beqc $rt, imm11s, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 8, 0x7FF, FALSE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, false},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -2104,9 +2104,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 0, 0xFFFFF, FALSE},\n-\t{4, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 0, 0xFFFFF, false},\n+\t{4, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16K] = 8,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -2125,9 +2125,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 8, 0x7FF, FALSE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, false},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S64K] = 8,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -2145,9 +2145,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 8, 0x7FF, FALSE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, false},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -2167,9 +2167,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 8, 0x7FF, FALSE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, false},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -2187,19 +2187,19 @@ static relax_info_t relax_table[] =\n     .br_range = BR_RANGE_S256,\n     .cond_field =\n       {\n-\t{0, 8, 0x7FF, TRUE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, true},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_seq[BR_RANGE_S256] =\n       {\n \t  INSN_BNEC\t/* bnec $rt, imm11s, label */\n       },\n     .relax_code_condition[BR_RANGE_S256] =\n       {\n-\t{0, 8, 0x7FF, FALSE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, false},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S256] = 4,\n     .relax_branch_isize[BR_RANGE_S256] = 4,\n@@ -2216,9 +2216,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16K] =\n       {\n-\t{0, 0, 0xFFFFF, FALSE},\n-\t{4, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 0, 0xFFFFF, false},\n+\t{4, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16K] = 8,\n     .relax_branch_isize[BR_RANGE_S16K] = 4,\n@@ -2237,9 +2237,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S64K] =\n       {\n-\t{0, 8, 0x7FF, FALSE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, false},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S64K] = 8,\n     .relax_branch_isize[BR_RANGE_S64K] = 4,\n@@ -2257,9 +2257,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_S16M] =\n       {\n-\t{0, 8, 0x7FF, FALSE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, false},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_S16M] = 8,\n     .relax_branch_isize[BR_RANGE_S16M] = 4,\n@@ -2279,9 +2279,9 @@ static relax_info_t relax_table[] =\n       },\n     .relax_code_condition[BR_RANGE_U4G] =\n       {\n-\t{0, 8, 0x7FF, FALSE},\n-\t{0, 20, 0x1F, FALSE},\n-\t{0, 0, 0, FALSE}\n+\t{0, 8, 0x7FF, false},\n+\t{0, 20, 0x1F, false},\n+\t{0, 0, 0, false}\n       },\n     .relax_code_size[BR_RANGE_U4G] = 16,\n     .relax_branch_isize[BR_RANGE_U4G] = 4,\n@@ -2632,7 +2632,7 @@ do_pseudo_b (int argc ATTRIBUTE_UNUSED, char *argv[],\n \t     unsigned int pv ATTRIBUTE_UNUSED)\n {\n   char *arg_label = argv[0];\n-  relaxing = TRUE;\n+  relaxing = true;\n   /* b   label */\n   if (nds32_pic)\n     {\n@@ -2645,15 +2645,15 @@ do_pseudo_b (int argc ATTRIBUTE_UNUSED, char *argv[],\n     {\n       md_assemblef (\"j %s\", arg_label);\n     }\n-  relaxing = FALSE;\n+  relaxing = false;\n }\n \n static void\n do_pseudo_bal (int argc ATTRIBUTE_UNUSED, char *argv[], \n \t       unsigned int pv ATTRIBUTE_UNUSED)\n {\n   char *arg_label = argv[0];\n-  relaxing = TRUE;\n+  relaxing = true;\n   /* bal|call  label */\n   if (nds32_pic)\n     {\n@@ -2666,7 +2666,7 @@ do_pseudo_bal (int argc ATTRIBUTE_UNUSED, char *argv[],\n     {\n       md_assemblef (\"jal %s\", arg_label);\n     }\n-  relaxing = FALSE;\n+  relaxing = false;\n }\n \n static void\n@@ -2771,7 +2771,7 @@ do_pseudo_la_internal (const char *arg_reg, char *arg_label,\n       return;\n     }\n \n-  relaxing = TRUE;\n+  relaxing = true;\n   /* rt, label */\n   if (!nds32_pic && !strstr (arg_label, \"@\"))\n     {\n@@ -2821,7 +2821,7 @@ do_pseudo_la_internal (const char *arg_reg, char *arg_label,\n     }\n    else\n       as_bad (_(\"need PIC qualifier with symbol. '%s'\"), line);\n-  relaxing = FALSE;\n+  relaxing = false;\n }\n \n static void\n@@ -2892,7 +2892,7 @@ do_pseudo_ls_bhw (int argc ATTRIBUTE_UNUSED, char *argv[],\n     }\n   else if (!nds32_pic)\n     {\n-      relaxing = TRUE;\n+      relaxing = true;\n       if (strstr (argv[1], \"@TPOFF\"))\n \t{\n \t  /* ls.w $rt, sym@TPOFF  */\n@@ -2913,11 +2913,11 @@ do_pseudo_ls_bhw (int argc ATTRIBUTE_UNUSED, char *argv[],\n \t  md_assemblef (\"sethi $ta,hi20(%s)\", argv[1]);\n \t  md_assemblef (\"%c%c%si %s,[$ta+lo12(%s)]\", ls, size, sign, argv[0], argv[1]);\n \t}\n-      relaxing = FALSE;\n+      relaxing = false;\n     }\n   else\n     {\n-      relaxing = TRUE;\n+      relaxing = true;\n       /* PIC code.  */\n       if (strstr (argv[1], \"@GOTOFF\"))\n \t{\n@@ -2948,7 +2948,7 @@ do_pseudo_ls_bhw (int argc ATTRIBUTE_UNUSED, char *argv[],\n \t{\n \t  as_bad (_(\"needs @GOT or @GOTOFF. %s\"), argv[argc]);\n \t}\n-      relaxing = FALSE;\n+      relaxing = false;\n     }\n }\n \n@@ -3913,7 +3913,7 @@ nds32_adjust_label (int n)\n   if (label != NULL)\n     {\n       symbolS *sym;\n-      int label_seen = FALSE;\n+      int label_seen = false;\n       struct frag *old_frag;\n       valueT old_value, new_value;\n \n@@ -3933,7 +3933,7 @@ nds32_adjust_label (int n)\n \t      && S_GET_VALUE (sym) == old_value)\n \t    {\n \t      /* Warning HERE! */\n-\t      label_seen = TRUE;\n+\t      label_seen = true;\n \t      symbol_set_frag (sym, frag_now);\n \t      S_SET_VALUE (sym, new_value);\n \t    }\n@@ -4320,7 +4320,7 @@ nds32_relax_hint (int mode ATTRIBUTE_UNUSED)\n \tgroup = group->next;\n       group->next = new;\n     }\n-  relaxing = TRUE;\n+  relaxing = true;\n }\n \n /* Decide the size of vector entries, only accepts 4 or 16 now.  */\n@@ -4945,7 +4945,7 @@ static void\n nds32_elf_build_relax_relation (fixS *fixP, expressionS *pexp, char* out,\n \t\t\t\tstruct nds32_asm_insn *insn, fragS *fragP,\n \t\t\t\tconst struct nds32_field *fld,\n-\t\t\t\tbfd_boolean pseudo_hint)\n+\t\t\t\tbool pseudo_hint)\n {\n   struct nds32_relocs_pattern *reloc_ptr;\n   struct nds32_relocs_group *group;\n@@ -5008,7 +5008,7 @@ nds32_elf_build_relax_relation (fixS *fixP, expressionS *pexp, char* out,\n \n   /* Set relaxing false only for relax_hint trigger it.  */\n   if (!pseudo_opcode)\n-    relaxing = FALSE;\n+    relaxing = false;\n }\n \n #define N32_MEM_EXT(insn) ((N32_OP6_MEM << 25) | insn)\n@@ -5662,7 +5662,7 @@ static struct nds32_hint_map hint_map [] =\n \n /* Find the relaxation pattern according to instructions.  */\n \n-static bfd_boolean\n+static bool\n nds32_find_reloc_table (struct nds32_relocs_pattern *relocs_pattern,\n \t\t\tstruct nds32_relax_hint_table *hint_info)\n {\n@@ -5742,7 +5742,7 @@ nds32_find_reloc_table (struct nds32_relocs_pattern *relocs_pattern,\n \t    default:\n \t      as_warn (_(\"relax hint unrecognized instruction: line %d.\"),\n \t\t       pattern->frag->fr_line);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n       else\n@@ -5797,7 +5797,7 @@ nds32_find_reloc_table (struct nds32_relocs_pattern *relocs_pattern,\n       if (!nds32_pic)\n \tas_warn (_(\"Can not find match relax hint.  Line: %d\"),\n \t\t relocs_pattern->frag->fr_line);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Get the match table.  */\n@@ -5806,7 +5806,7 @@ nds32_find_reloc_table (struct nds32_relocs_pattern *relocs_pattern,\n       /* Branch relax pattern.  */\n       relax_info = str_hash_find (nds32_relax_info_hash, opc);\n       if (!relax_info)\n-\treturn FALSE;\n+\treturn false;\n       fixup_info = relax_info->relax_fixup[range];\n       code_seq = relax_info->relax_code_seq[range];\n       seq_size = relax_info->relax_code_size[range];\n@@ -5827,10 +5827,10 @@ nds32_find_reloc_table (struct nds32_relocs_pattern *relocs_pattern,\n \t  table_ptr++;\n \t}\n       if (table_ptr->main_type == 0)\n-\treturn FALSE;\n+\treturn false;\n     }\n   else\n-    return FALSE;\n+    return false;\n \n   hint_fixup = hint_info->relax_fixup;\n   hint_code = hint_info->relax_code_seq;\n@@ -5849,7 +5849,7 @@ nds32_find_reloc_table (struct nds32_relocs_pattern *relocs_pattern,\n   memset (hint_fixup, 0, sizeof (nds32_relax_fixup_info_t));\n   /* Copy code sequence.  */\n   memcpy (hint_code, code_seq, seq_size);\n-  return TRUE;\n+  return true;\n }\n \n /* Because there are a lot of variant of load-store, check\n@@ -5858,7 +5858,7 @@ nds32_find_reloc_table (struct nds32_relocs_pattern *relocs_pattern,\n #define CLEAN_REG(insn) ((insn) & 0xfe0003ff)\n #define GET_OPCODE(insn) ((insn) & 0xfe000000)\n \n-static bfd_boolean\n+static bool\n nds32_match_hint_insn (struct nds32_opcode *opcode, uint32_t seq)\n {\n   const char *check_insn[] =\n@@ -5868,7 +5868,7 @@ nds32_match_hint_insn (struct nds32_opcode *opcode, uint32_t seq)\n \n   insn = CLEAN_REG (opcode->value);\n   if (insn == seq)\n-    return TRUE;\n+    return true;\n \n   switch (seq)\n     {\n@@ -5880,52 +5880,52 @@ nds32_match_hint_insn (struct nds32_opcode *opcode, uint32_t seq)\n \t  || insn == OP6 (LWI) || insn == OP6 (SWI)\n \t  || insn == OP6 (LWC) || insn == OP6 (SWC)\n \t  || insn == OP6 (LDC) || insn == OP6 (SDC))\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case OP6 (BR2):\n       /* This is for LONGCALL5 and LONGCALL6.  */\n       if (insn == OP6 (BR2))\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case OP6 (BR1):\n       /* This is for LONGJUMP5 and LONGJUMP6.  */\n       if (opcode->isize == 4\n \t  && (insn == OP6 (BR1) || insn == OP6 (BR2) || insn == OP6 (BR3)))\n-\treturn TRUE;\n+\treturn true;\n       else if (opcode->isize == 2)\n \t{\n \t  for (i = 0; i < ARRAY_SIZE (check_insn); i++)\n \t    if (strcmp (opcode->opcode, check_insn[i]) == 0)\n-\t      return TRUE;\n+\t      return true;\n \t}\n       break;\n     case OP6 (MOVI):\n       /* This is for LONGJUMP7.  */\n       if (opcode->isize == 2 && strcmp (opcode->opcode, \"movi55\") == 0)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case OP6 (MEM):\n       if (OP6 (MEM) == GET_OPCODE (insn))\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case OP6 (JREG):\n       /* bit 24: N32_JI_JAL  */ /* feed me!  */\n       if ((insn & ~(N32_BIT (24))) == JREG (JRAL))\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n       if (opcode->isize == 2)\n \t{\n \t  for (i = 0; i < ARRAY_SIZE (check_insn); i++)\n \t    if (strcmp (opcode->opcode, check_insn[i]) == 0)\n-\t      return TRUE;\n+\t      return true;\n \n \t  if ((strcmp (opcode->opcode, \"add5.pc\") == 0) ||\n \t      (strcmp (opcode->opcode, \"add45\") == 0))\n-\t    return TRUE;\n+\t    return true;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Append relax relocation for link time relaxing.  */\n@@ -6290,7 +6290,7 @@ nds32_str_tolower (const char *src, char *dest)\n \n /* Check instruction if it can be used for the baseline.  */\n \n-static bfd_boolean\n+static bool\n nds32_check_insn_available (struct nds32_asm_insn insn, const char *str)\n {\n   int attr = insn.attr & ATTR_ALL;\n@@ -6308,19 +6308,19 @@ nds32_check_insn_available (struct nds32_asm_insn insn, const char *str)\n \t  || (insn.attr & NASM_ATTR_ZOL)))\n     {\n       as_bad (_(\"Not support instruction %s in verbatim.\"), str);\n-      return FALSE;\n+      return false;\n     }\n   free (s);\n \n   if (!enable_16bit && insn.opcode->isize == 2)\n     {\n       as_bad (_(\"16-bit instruction is disabled: %s.\"), str);\n-      return FALSE;\n+      return false;\n     }\n \n   /* No isa setting or all isa can use.  */\n   if (attr == 0 || attr == ATTR_ALL)\n-    return TRUE;\n+    return true;\n \n   if (baseline_isa == 0)\n     {\n@@ -6342,9 +6342,9 @@ nds32_check_insn_available (struct nds32_asm_insn insn, const char *str)\n   if  ((baseline_isa & attr) == 0)\n     {\n       as_bad (_(\"Instruction %s not supported in the baseline.\"), str);\n-      return FALSE;\n+      return false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Stub of machine dependent.  */\n@@ -6362,7 +6362,7 @@ md_assemble (char *str)\n   struct nds32_relocs_group *group_temp;\n   fragS *fragP;\n   int label = label_exist;\n-  static bfd_boolean pseudo_hint = FALSE;\n+  static bool pseudo_hint = false;\n \n   popcode = nds32_lookup_pseudo_opcode (str);\n   /* Note that we need to check 'verbatim' and\n@@ -6373,11 +6373,11 @@ md_assemble (char *str)\n     {\n       /* Pseudo instruction is with relax_hint.  */\n       if (relaxing)\n-\tpseudo_hint = TRUE;\n-      pseudo_opcode = TRUE;\n+\tpseudo_hint = true;\n+      pseudo_opcode = true;\n       nds32_pseudo_opcode_wrapper (str, popcode);\n-      pseudo_opcode = FALSE;\n-      pseudo_hint = FALSE;\n+      pseudo_opcode = false;\n+      pseudo_hint = false;\n       nds32_elf_append_relax_relocs (NULL, relocs_list);\n \n       /* Free relax_hint group list.  */\n@@ -6876,7 +6876,7 @@ nds32_get_align (addressT address, int align)\n \n /* Check the prev_frag is legal.  */\n static void\n-invalid_prev_frag (fragS * fragP, fragS **prev_frag, bfd_boolean relax)\n+invalid_prev_frag (fragS * fragP, fragS **prev_frag, bool relax)\n {\n   addressT address;\n   fragS *frag_start = *prev_frag;\n@@ -6949,7 +6949,7 @@ nds32_relax_frag (segT segment, fragS *fragP, long stretch ATTRIBUTE_UNUSED)\n   static fragS *prev_frag = NULL;\n   int adjust = 0;\n \n-  invalid_prev_frag (fragP, &prev_frag, TRUE);\n+  invalid_prev_frag (fragP, &prev_frag, true);\n \n   if (fragP->tc_frag_data.flag & NDS32_FRAG_BRANCH)\n     adjust = nds32_relax_branch_instructions (segment, fragP, stretch, 0);\n@@ -6986,7 +6986,7 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)\n   static fragS *prev_frag = NULL;\n   int adjust = 0;\n \n-  invalid_prev_frag (fragP, &prev_frag, FALSE);\n+  invalid_prev_frag (fragP, &prev_frag, false);\n \n   if (fragP->tc_frag_data.flag & NDS32_FRAG_BRANCH)\n     adjust = nds32_relax_branch_instructions (segment, fragP, 0, 1);\n@@ -7236,7 +7236,7 @@ nds32_frob_file_before_fix (void)\n {\n }\n \n-static bfd_boolean\n+static bool\n nds32_relaxable_section (asection *sec)\n {\n   return ((sec->flags & SEC_DEBUGGING) == 0\n@@ -7529,13 +7529,13 @@ md_end (void)\n \n /* Implement md_allow_local_subtract.  */\n \n-bfd_boolean\n+bool\n nds32_allow_local_subtract (expressionS *expr_l ATTRIBUTE_UNUSED,\n \t\t\t    expressionS *expr_r ATTRIBUTE_UNUSED,\n \t\t\t    segT sec ATTRIBUTE_UNUSED)\n {\n   /* Don't allow any subtraction, because relax may change the code.  */\n-  return FALSE;\n+  return false;\n }\n \n /* Sort relocation by address.\n@@ -7604,7 +7604,7 @@ nds32_post_relax_hook (void)\n    Return whether this symbol (fixup) can be replaced with\n    section symbols.  */\n \n-bfd_boolean\n+bool\n nds32_fix_adjustable (fixS *fixP)\n {\n   switch (fixP->fx_r_type)"
    },
    {
      "sha": "fb4bcacf12cddb2bd5f6e5e6ea413b96147efc9e",
      "filename": "gas/config/tc-nds32.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-nds32.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-nds32.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-nds32.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -71,7 +71,7 @@ extern const char * nds32_target_format (void);\n \n /* expr.c */\n extern int nds32_parse_name (char const *, expressionS *, enum expr_mode, char *);\n-extern bfd_boolean nds32_allow_local_subtract (expressionS *, expressionS *, segT);\n+extern bool nds32_allow_local_subtract (expressionS *, expressionS *, segT);\n #define md_parse_name(name, exprP, mode, nextcharP) \\\n \tnds32_parse_name (name, exprP, mode, nextcharP)\n #define md_allow_local_subtract(lhs,rhs,sect)\tnds32_allow_local_subtract (lhs, rhs, sect)\n@@ -81,7 +81,7 @@ extern bfd_boolean nds32_allow_local_subtract (expressionS *, expressionS *, seg\n \n /* write.c.  */\n extern long nds32_pcrel_from_section (struct fix *, segT);\n-extern bfd_boolean nds32_fix_adjustable (struct fix *);\n+extern bool nds32_fix_adjustable (struct fix *);\n extern void nds32_frob_file (void);\n extern void nds32_post_relax_hook (void);\n extern void nds32_frob_file_before_fix (void);\n@@ -264,7 +264,7 @@ typedef struct nds32_cond_field\n   int offset;\n   int bitpos; /* Register position.  */\n   int bitmask; /* Number of register bits.  */\n-  bfd_boolean signed_extend;\n+  bool signed_extend;\n } nds32_cond_field_t;\n \n /* The max relaxation pattern is 20-bytes including the nop.  */"
    },
    {
      "sha": "7e2a3985c29cfd4c275328806c3558d4e9407266",
      "filename": "gas/config/tc-nios2.c",
      "status": "modified",
      "additions": 30,
      "deletions": 30,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-nios2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-nios2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-nios2.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -103,12 +103,12 @@ static struct\n      and macro expansions generate a warning.\n      .set at -> noat = 0, assembly code using at warn but macro expansions\n      do not generate warnings.  */\n-  bfd_boolean noat;\n+  bool noat;\n \n   /* .set nobreak -> nobreak = 1 allows assembly code to use ba,bt without\n \t\t\t\t warning.\n      .set break -> nobreak = 0, assembly code using ba,bt warns.  */\n-  bfd_boolean nobreak;\n+  bool nobreak;\n \n   /* .cmd line option -relax-all allows all branches and calls to be replaced\n      with longer versions.\n@@ -117,7 +117,7 @@ static struct\n      a section.  */\n   relax_optionT relax;\n \n-} nios2_as_options = {FALSE, FALSE, relax_section};\n+} nios2_as_options = {false, false, relax_section};\n \n \n typedef struct nios2_insn_reloc\n@@ -391,7 +391,7 @@ nios2_align (int log_size, const char *pfill, symbolS *label)\n       if (label != NULL && !switched_seg_p)\n \t{\n \t  symbolS *sym;\n-\t  int label_seen = FALSE;\n+\t  int label_seen = false;\n \t  struct frag *old_frag;\n \t  valueT old_value;\n \t  valueT new_value;\n@@ -417,7 +417,7 @@ nios2_align (int log_size, const char *pfill, symbolS *label)\n \t    if (symbol_get_frag (sym) == old_frag\n \t\t&& S_GET_VALUE (sym) == old_value)\n \t      {\n-\t\tlabel_seen = TRUE;\n+\t\tlabel_seen = true;\n \t\tsymbol_set_frag (sym, frag_now);\n \t\tS_SET_VALUE (sym, new_value);\n \t      }\n@@ -579,25 +579,25 @@ s_nios2_set (int equiv)\n   SKIP_WHITESPACE ();\n   if (is_end_of_line[(unsigned char) *input_line_pointer])\n     {\n-      bfd_boolean done = TRUE;\n+      bool done = true;\n       *endline = 0;\n \n       if (!strcmp (directive, \"noat\"))\n-\t  nios2_as_options.noat = TRUE;\n+\t  nios2_as_options.noat = true;\n       else if (!strcmp (directive, \"at\"))\n-\t  nios2_as_options.noat = FALSE;\n+\t  nios2_as_options.noat = false;\n       else if (!strcmp (directive, \"nobreak\"))\n-\t  nios2_as_options.nobreak = TRUE;\n+\t  nios2_as_options.nobreak = true;\n       else if (!strcmp (directive, \"break\"))\n-\t  nios2_as_options.nobreak = FALSE;\n+\t  nios2_as_options.nobreak = false;\n       else if (!strcmp (directive, \"norelax\"))\n \t  nios2_as_options.relax = relax_none;\n       else if (!strcmp (directive, \"relaxsection\"))\n \t  nios2_as_options.relax = relax_section;\n       else if (!strcmp (directive, \"relaxall\"))\n \t  nios2_as_options.relax = relax_all;\n       else\n-\tdone = FALSE;\n+\tdone = false;\n \n       if (done)\n \t{\n@@ -789,7 +789,7 @@ nios2_relax_frag (segT segment, fragS *fragp, long stretch)\n       fragS *sym_frag = symbol_get_frag (symbolp);\n       offsetT offset;\n       int n;\n-      bfd_boolean is_cdx = FALSE;\n+      bool is_cdx = false;\n \n       target += S_GET_VALUE (symbolp);\n \n@@ -809,11 +809,11 @@ nios2_relax_frag (segT segment, fragS *fragp, long stretch)\n       if (IS_CDXBRANCH (subtype) && IS_UBRANCH (subtype)\n \t  && offset >= -1024 && offset < 1024)\n \t/* PC-relative CDX branch with 11-bit offset.  */\n-\tis_cdx = TRUE;\n+\tis_cdx = true;\n       else if (IS_CDXBRANCH (subtype) && IS_CBRANCH (subtype)\n \t       && offset >= -128 && offset < 128)\n \t/* PC-relative CDX branch with 8-bit offset.  */\n-\tis_cdx = TRUE;\n+\tis_cdx = true;\n       else if (offset >= -32768 && offset < 32768)\n \t/* Fits in PC-relative branch.  */\n \tn = 0;\n@@ -883,7 +883,7 @@ md_convert_frag (bfd *headers ATTRIBUTE_UNUSED, segT segment ATTRIBUTE_UNUSED,\n   unsigned int addend_mask, addi_mask, op;\n   offsetT addend, remainder;\n   int i;\n-  bfd_boolean is_r2 = (bfd_get_mach (stdoutput) == bfd_mach_nios2r2);\n+  bool is_r2 = (bfd_get_mach (stdoutput) == bfd_mach_nios2r2);\n \n   /* If this is a CDX branch we're not relaxing, just generate the fixup.  */\n   if (IS_CDXBRANCH (subtype))\n@@ -1100,7 +1100,7 @@ md_convert_frag (bfd *headers ATTRIBUTE_UNUSED, segT segment ATTRIBUTE_UNUSED,\n /** Fixups and overflow checking.  */\n \n /* Check a fixup for overflow. */\n-static bfd_boolean\n+static bool\n nios2_check_overflow (valueT fixup, reloc_howto_type *howto)\n {\n   /* If there is a rightshift, check that the low-order bits are\n@@ -1109,7 +1109,7 @@ nios2_check_overflow (valueT fixup, reloc_howto_type *howto)\n     {\n       if ((~(~((valueT) 0) << howto->rightshift) & fixup)\n \t  && howto->complain_on_overflow != complain_overflow_dont)\n-\treturn TRUE;\n+\treturn true;\n       fixup = ((signed)fixup) >> howto->rightshift;\n     }\n \n@@ -1121,31 +1121,31 @@ nios2_check_overflow (valueT fixup, reloc_howto_type *howto)\n     case complain_overflow_bitfield:\n       if ((fixup >> howto->bitsize) != 0\n \t  && ((signed) fixup >> howto->bitsize) != -1)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case complain_overflow_signed:\n       if ((fixup & 0x80000000) > 0)\n \t{\n \t  /* Check for negative overflow.  */\n \t  if ((signed) fixup < (signed) (~0U << (howto->bitsize - 1)))\n-\t    return TRUE;\n+\t    return true;\n \t}\n       else\n \t{\n \t  /* Check for positive overflow.  */\n \t  if (fixup >= ((unsigned) 1 << (howto->bitsize - 1)))\n-\t    return TRUE;\n+\t    return true;\n \t}\n       break;\n     case complain_overflow_unsigned:\n       if ((fixup >> howto->bitsize) != 0)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n       as_bad (_(\"error checking for overflow - broken assembler\"));\n       break;\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Emit diagnostic for fixup overflow.  */\n@@ -3099,7 +3099,7 @@ nios2_parse_args (nios2_insn_infoS *insn, char *argstr,\n   int i;\n   p = argstr;\n   i = 0;\n-  bfd_boolean terminate = FALSE;\n+  bool terminate = false;\n \n   /* This rest of this function is it too fragile and it mostly works,\n      therefore special case this one.  */\n@@ -3136,7 +3136,7 @@ nios2_parse_args (nios2_insn_infoS *insn, char *argstr,\n \t}\n \n       if (*parsestr == '\\0' || (p != NULL && *p == '\\0'))\n-\tterminate = TRUE;\n+\tterminate = true;\n       ++i;\n     }\n \n@@ -3350,7 +3350,7 @@ output_ubranch (nios2_insn_infoS *insn)\n       symbolS *symp = reloc->reloc_expression.X_add_symbol;\n       offsetT offset = reloc->reloc_expression.X_add_number;\n       char *f;\n-      bfd_boolean is_cdx = (insn->insn_nios2_opcode->size == 2);\n+      bool is_cdx = (insn->insn_nios2_opcode->size == 2);\n \n       /* Tag dwarf2 debug info to the address at the start of the insn.\n \t We must do it before frag_var() below closes off the frag.  */\n@@ -3382,7 +3382,7 @@ output_cbranch (nios2_insn_infoS *insn)\n       symbolS *symp = reloc->reloc_expression.X_add_symbol;\n       offsetT offset = reloc->reloc_expression.X_add_number;\n       char *f;\n-      bfd_boolean is_cdx = (insn->insn_nios2_opcode->size == 2);\n+      bool is_cdx = (insn->insn_nios2_opcode->size == 2);\n \n       /* Tag dwarf2 debug info to the address at the start of the insn.\n \t We must do it before frag_var() below closes off the frag.  */\n@@ -3640,8 +3640,8 @@ md_begin (void)\n       as_fatal (_(\"duplicate %s\"), nios2_ps_insn_info_structs[i].pseudo_insn);\n \n   /* Assembler option defaults.  */\n-  nios2_as_options.noat = FALSE;\n-  nios2_as_options.nobreak = FALSE;\n+  nios2_as_options.noat = false;\n+  nios2_as_options.nobreak = false;\n \n   /* Initialize the alignment data.  */\n   nios2_current_align_seg = now_seg;\n@@ -3660,7 +3660,7 @@ md_assemble (char *op_str)\n   unsigned long saved_pinfo = 0;\n   nios2_insn_infoS thisinsn;\n   nios2_insn_infoS *insn = &thisinsn;\n-  bfd_boolean ps_error = FALSE;\n+  bool ps_error = false;\n \n   /* Make sure we are aligned on an appropriate boundary.  */\n   if (nios2_current_align < nios2_min_align)\n@@ -3710,7 +3710,7 @@ md_assemble (char *op_str)\n \t{\n \t  ps_insn = nios2_translate_pseudo_insn (insn);\n \t  if (!ps_insn)\n-\t    ps_error = TRUE;\n+\t    ps_error = true;\n \t}\n \n       /* If we found invalid pseudo-instruction syntax, the error's already"
    },
    {
      "sha": "04d840e2eaf7a2fda6ecfb2d84c30f0aaa056e76",
      "filename": "gas/config/tc-ns32k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ns32k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ns32k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ns32k.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -1917,7 +1917,7 @@ md_begin (void)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \f\n int"
    },
    {
      "sha": "4e75a0a07a339c83827646b0c462b9999d0a4113",
      "filename": "gas/config/tc-or1k.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-or1k.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -83,11 +83,11 @@ ignore_pseudo (int val ATTRIBUTE_UNUSED)\n   discard_rest_of_line ();\n }\n \n-static bfd_boolean nodelay = FALSE;\n+static bool nodelay = false;\n static void\n s_nodelay (int val ATTRIBUTE_UNUSED)\n {\n-  nodelay = TRUE;\n+  nodelay = true;\n }\n \n const char or1k_comment_chars [] = \";#\";\n@@ -278,18 +278,18 @@ md_number_to_chars (char * buf, valueT val, int n)\n const char *\n md_atof (int type, char * litP, int *  sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n-bfd_boolean\n+bool\n or1k_fix_adjustable (fixS * fixP)\n {\n   /* We need the symbol name for the VTABLE entries.  */\n   if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT\n       || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n #define GOT_NAME \"_GLOBAL_OFFSET_TABLE_\""
    },
    {
      "sha": "a5782fd8f352a0bf24e1fea9f0ba0650e6aaac62",
      "filename": "gas/config/tc-or1k.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-or1k.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-or1k.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-or1k.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -46,7 +46,7 @@ extern const char or1k_comment_chars [];\n #define md_apply_fix or1k_apply_fix\n extern void or1k_apply_fix (struct fix *, valueT *, segT);\n \n-extern bfd_boolean or1k_fix_adjustable (struct fix *);\n+extern bool or1k_fix_adjustable (struct fix *);\n #define tc_fix_adjustable(FIX) or1k_fix_adjustable (FIX)\n \n /* Call md_pcrel_from_section(), not md_pcrel_from().  */"
    },
    {
      "sha": "2ce8684487aecc29b82723f01e52da1fc5e97851",
      "filename": "gas/config/tc-pdp11.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-pdp11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-pdp11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-pdp11.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -484,7 +484,7 @@ parse_op_no_deferred (char *str, struct pdp11_code *operand)\n       str = parse_expression (str + 1, operand);\n       if (operand->error)\n \treturn str;\n-      operand->additional = TRUE;\n+      operand->additional = true;\n       operand->word = operand->reloc.exp.X_add_number;\n       switch (operand->reloc.exp.X_op)\n \t{\n@@ -566,7 +566,7 @@ parse_op_no_deferred (char *str, struct pdp11_code *operand)\n \t  }\n \n \tstr++;\n-\toperand->additional = TRUE;\n+\toperand->additional = true;\n \toperand->code |= 060;\n \tswitch (operand->reloc.exp.X_op)\n \t  {\n@@ -728,10 +728,10 @@ md_assemble (char *instruction_string)\n   insn.code = op->opcode;\n   insn.reloc.type = BFD_RELOC_NONE;\n   op1.error = NULL;\n-  op1.additional = FALSE;\n+  op1.additional = false;\n   op1.reloc.type = BFD_RELOC_NONE;\n   op2.error = NULL;\n-  op2.additional = FALSE;\n+  op2.additional = false;\n   op2.reloc.type = BFD_RELOC_NONE;\n \n   str = p;"
    },
    {
      "sha": "8d1142c94285030d9b25ee20475d3f452d08e9ad",
      "filename": "gas/config/tc-ppc.c",
      "status": "modified",
      "additions": 59,
      "deletions": 59,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ppc.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -46,7 +46,7 @@ static int set_target_endian = 0;\n \n /* Whether to use user friendly register names.  */\n #ifndef TARGET_REG_NAMES_P\n-#define TARGET_REG_NAMES_P FALSE\n+#define TARGET_REG_NAMES_P false\n #endif\n \n /* Macros for calculating LO, HI, HA, HIGHER, HIGHERA, HIGHEST,\n@@ -83,7 +83,7 @@ static int set_target_endian = 0;\n    applied to constants.  */\n #define REPORT_OVERFLOW_HI 0\n \n-static bfd_boolean reg_names_p = TARGET_REG_NAMES_P;\n+static bool reg_names_p = TARGET_REG_NAMES_P;\n \n static void ppc_macro (char *, const struct powerpc_macro *);\n static void ppc_byte (int);\n@@ -816,7 +816,7 @@ reg_name_search (const struct pd_reg *regs, int regcount, const char *name)\n  *      original state.\n  */\n \n-static bfd_boolean\n+static bool\n register_name (expressionS *expressionP)\n {\n   const struct pd_reg *reg;\n@@ -830,7 +830,7 @@ register_name (expressionS *expressionP)\n     name = ++input_line_pointer;\n \n   else if (!reg_names_p || !ISALPHA (name[0]))\n-    return FALSE;\n+    return false;\n \n   c = get_symbol_name (&name);\n   reg = reg_name_search (pre_defined_registers, REG_NAME_CNT, name);\n@@ -848,20 +848,20 @@ register_name (expressionS *expressionP)\n       /* Make the rest nice.  */\n       expressionP->X_add_symbol = NULL;\n       expressionP->X_op_symbol = NULL;\n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n-  return FALSE;\n+  return false;\n }\n \f\n /* This function is called for each symbol seen in an expression.  It\n    handles the special parsing which PowerPC assemblers are supposed\n    to use for condition codes.  */\n \n /* Whether to do the special parsing.  */\n-static bfd_boolean cr_operand;\n+static bool cr_operand;\n \n /* Names to recognize in a condition code.  This table is sorted.  */\n static const struct pd_reg cr_names[] =\n@@ -980,12 +980,12 @@ static flagword ppc_flags = 0;\n \n /* Whether this is Solaris or not.  */\n #ifdef TARGET_SOLARIS_COMMENT\n-#define SOLARIS_P TRUE\n+#define SOLARIS_P true\n #else\n-#define SOLARIS_P FALSE\n+#define SOLARIS_P false\n #endif\n \n-static bfd_boolean msolaris = SOLARIS_P;\n+static bool msolaris = SOLARIS_P;\n #endif\n \n #ifdef OBJ_XCOFF\n@@ -1006,7 +1006,7 @@ struct ppc_xcoff_section ppc_xcoff_tbss_section;\n \n /* Return true if the ppc_xcoff_section structure is already\n    initialized.  */\n-static bfd_boolean\n+static bool\n ppc_xcoff_section_is_initialized (struct ppc_xcoff_section *section)\n {\n   return section->segment != NULL;\n@@ -1017,7 +1017,7 @@ ppc_xcoff_section_is_initialized (struct ppc_xcoff_section *section)\n    and .tdata.  These symbols won't be output.  */\n static void\n ppc_init_xcoff_section (struct ppc_xcoff_section *s, segT seg,\n-\t\t\tbfd_boolean need_dummy)\n+\t\t\tbool need_dummy)\n {\n   s->segment = seg;\n   s->next_subsegment = 2;\n@@ -1194,10 +1194,10 @@ md_parse_option (int c, const char *arg)\n \t}\n \n       else if (strcmp (arg, \"regnames\") == 0)\n-\treg_names_p = TRUE;\n+\treg_names_p = true;\n \n       else if (strcmp (arg, \"no-regnames\") == 0)\n-\treg_names_p = FALSE;\n+\treg_names_p = false;\n \n #ifdef OBJ_ELF\n       /* -mrelocatable/-mrelocatable-lib -- warn about initializations\n@@ -1236,13 +1236,13 @@ md_parse_option (int c, const char *arg)\n \n       else if (strcmp (arg, \"solaris\") == 0)\n \t{\n-\t  msolaris = TRUE;\n+\t  msolaris = true;\n \t  ppc_comment_chars = ppc_solaris_comment_chars;\n \t}\n \n       else if (strcmp (arg, \"no-solaris\") == 0)\n \t{\n-\t  msolaris = FALSE;\n+\t  msolaris = false;\n \t  ppc_comment_chars = ppc_eabi_comment_chars;\n \t}\n       else if (strcmp (arg, \"spe2\") == 0)\n@@ -1545,7 +1545,7 @@ ppc_target_format (void)\n /* Validate one entry in powerpc_opcodes[] or vle_opcodes[].\n    Return TRUE if there's a problem, otherwise FALSE.  */\n \n-static bfd_boolean\n+static bool\n insn_validate (const struct powerpc_opcode *op)\n {\n   const unsigned char *o;\n@@ -1555,17 +1555,17 @@ insn_validate (const struct powerpc_opcode *op)\n   if ((op->opcode & omask) != op->opcode)\n     {\n       as_bad (_(\"mask trims opcode bits for %s\"), op->name);\n-      return TRUE;\n+      return true;\n     }\n \n   /* The operands must not overlap the opcode or each other.  */\n   for (o = op->operands; *o; ++o)\n     {\n-      bfd_boolean optional = FALSE;\n+      bool optional = false;\n       if (*o >= num_powerpc_operands)\n         {\n \t  as_bad (_(\"operand index error for %s\"), op->name);\n-\t  return TRUE;\n+\t  return true;\n         }\n       else\n         {\n@@ -1592,20 +1592,20 @@ insn_validate (const struct powerpc_opcode *op)\n \t    {\n \t      as_bad (_(\"operand %d overlap in %s\"),\n \t\t      (int) (o - op->operands), op->name);\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  omask |= mask;\n \t  if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0)\n-\t    optional = TRUE;\n+\t    optional = true;\n \t  else if (optional)\n \t    {\n \t      as_bad (_(\"non-optional operand %d follows optional operand in %s\"),\n \t\t      (int) (o - op->operands), op->name);\n-\t      return TRUE;\n+\t      return true;\n \t    }\n         }\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Insert opcodes and macros into hash tables.  Called at startup and\n@@ -1618,7 +1618,7 @@ ppc_setup_opcodes (void)\n   const struct powerpc_opcode *op_end;\n   const struct powerpc_macro *macro;\n   const struct powerpc_macro *macro_end;\n-  bfd_boolean bad_insn = FALSE;\n+  bool bad_insn = false;\n \n   if (ppc_hash != NULL)\n     htab_delete (ppc_hash);\n@@ -1650,15 +1650,15 @@ ppc_setup_opcodes (void)\n \t  if (mask != right_bit)\n \t    {\n \t      as_bad (_(\"powerpc_operands[%d].bitm invalid\"), i);\n-\t      bad_insn = TRUE;\n+\t      bad_insn = true;\n \t    }\n \t  for (j = i + 1; j < num_powerpc_operands; ++j)\n \t    if (memcmp (&powerpc_operands[i], &powerpc_operands[j],\n \t\t\tsizeof (powerpc_operands[0])) == 0)\n \t      {\n \t\tas_bad (_(\"powerpc_operands[%d] duplicates powerpc_operands[%d]\"),\n \t\t\tj, i);\n-\t\tbad_insn = TRUE;\n+\t\tbad_insn = true;\n \t      }\n \t}\n     }\n@@ -1683,20 +1683,20 @@ ppc_setup_opcodes (void)\n \t      && new_opcode < PPC_OP (op[-1].opcode))\n \t    {\n \t      as_bad (_(\"major opcode is not sorted for %s\"), op->name);\n-\t      bad_insn = TRUE;\n+\t      bad_insn = true;\n \t    }\n \n \t  if ((op->flags & PPC_OPCODE_VLE) != 0)\n \t    {\n \t      as_bad (_(\"%s is enabled by vle flag\"), op->name);\n-\t      bad_insn = TRUE;\n+\t      bad_insn = true;\n \t    }\n \t  if (PPC_OP (op->opcode) != 4\n \t      && PPC_OP (op->opcode) != 31\n \t      && (op->deprecated & PPC_OPCODE_VLE) == 0)\n \t    {\n \t      as_bad (_(\"%s not disabled by vle flag\"), op->name);\n-\t      bad_insn = TRUE;\n+\t      bad_insn = true;\n \t    }\n \t  bad_insn |= insn_validate (op);\n \t}\n@@ -1706,7 +1706,7 @@ ppc_setup_opcodes (void)\n \t  && str_hash_insert (ppc_hash, op->name, op, 0) != NULL)\n \t{\n \t  as_bad (_(\"duplicate %s\"), op->name);\n-\t  bad_insn = TRUE;\n+\t  bad_insn = true;\n \t}\n     }\n \n@@ -1734,7 +1734,7 @@ ppc_setup_opcodes (void)\n \t      && new_opcode < PPC_PREFIX_SEG (op[-1].opcode))\n \t    {\n \t      as_bad (_(\"major opcode is not sorted for %s\"), op->name);\n-\t      bad_insn = TRUE;\n+\t      bad_insn = true;\n \t    }\n \t  bad_insn |= insn_validate (op);\n \t}\n@@ -1744,7 +1744,7 @@ ppc_setup_opcodes (void)\n \t  && str_hash_insert (ppc_hash, op->name, op, 0) != NULL)\n \t{\n \t  as_bad (_(\"duplicate %s\"), op->name);\n-\t  bad_insn = TRUE;\n+\t  bad_insn = true;\n \t}\n     }\n \n@@ -1772,7 +1772,7 @@ ppc_setup_opcodes (void)\n \t      && new_seg < VLE_OP_TO_SEG (VLE_OP (op[-1].opcode, op[-1].mask)))\n \t    {\n \t      as_bad (_(\"major opcode is not sorted for %s\"), op->name);\n-\t      bad_insn = TRUE;\n+\t      bad_insn = true;\n \t    }\n \n \t  bad_insn |= insn_validate (op);\n@@ -1783,7 +1783,7 @@ ppc_setup_opcodes (void)\n \t  && str_hash_insert (ppc_hash, op->name, op, 0) != NULL)\n \t{\n \t  as_bad (_(\"duplicate %s\"), op->name);\n-\t  bad_insn = TRUE;\n+\t  bad_insn = true;\n \t}\n     }\n \n@@ -1810,7 +1810,7 @@ ppc_setup_opcodes (void)\n \t\tif (new_seg < old_seg)\n \t\t  {\n \t\t  as_bad (_(\"major opcode is not sorted for %s\"), op->name);\n-\t\t  bad_insn = TRUE;\n+\t\t  bad_insn = true;\n \t\t  }\n \t\t}\n \n@@ -1822,7 +1822,7 @@ ppc_setup_opcodes (void)\n \t      && str_hash_insert (ppc_hash, op->name, op, 0) != NULL)\n \t    {\n \t      as_bad (_(\"duplicate %s\"), op->name);\n-\t      bad_insn = TRUE;\n+\t      bad_insn = true;\n \t    }\n \t}\n \n@@ -1840,7 +1840,7 @@ ppc_setup_opcodes (void)\n \t&& str_hash_insert (ppc_macro_hash, macro->name, macro, 0) != NULL)\n       {\n \tas_bad (_(\"duplicate %s\"), macro->name);\n-\tbad_insn = TRUE;\n+\tbad_insn = true;\n       }\n \n   if (bad_insn)\n@@ -1881,9 +1881,9 @@ md_begin (void)\n   /* Create XCOFF sections with .text in first, as it's creating dummy symbols\n      to serve as initial csects.  This forces the text csects to precede the\n      data csects.  These symbols will not be output.  */\n-  ppc_init_xcoff_section (&ppc_xcoff_text_section, text_section, TRUE);\n-  ppc_init_xcoff_section (&ppc_xcoff_data_section, data_section, TRUE);\n-  ppc_init_xcoff_section (&ppc_xcoff_bss_section, bss_section, FALSE);\n+  ppc_init_xcoff_section (&ppc_xcoff_text_section, text_section, true);\n+  ppc_init_xcoff_section (&ppc_xcoff_data_section, data_section, true);\n+  ppc_init_xcoff_section (&ppc_xcoff_bss_section, bss_section, false);\n #endif\n }\n \n@@ -2930,10 +2930,10 @@ struct ppc_fixup\n    pc-relative in PC_RELATIVE.  */\n \n static unsigned int\n-fixup_size (bfd_reloc_code_real_type reloc, bfd_boolean *pc_relative)\n+fixup_size (bfd_reloc_code_real_type reloc, bool *pc_relative)\n {\n   unsigned int size = 0;\n-  bfd_boolean pcrel = FALSE;\n+  bool pcrel = false;\n \n   switch (reloc)\n     {\n@@ -3077,7 +3077,7 @@ fixup_size (bfd_reloc_code_real_type reloc, bfd_boolean *pc_relative)\n #endif\n     case BFD_RELOC_PPC_VLE_REL8:\n       size = 2;\n-      pcrel = TRUE;\n+      pcrel = true;\n       break;\n \n     case BFD_RELOC_32:\n@@ -3137,7 +3137,7 @@ fixup_size (bfd_reloc_code_real_type reloc, bfd_boolean *pc_relative)\n     case BFD_RELOC_PPC_VLE_REL15:\n     case BFD_RELOC_PPC_VLE_REL24:\n       size = 4;\n-      pcrel = TRUE;\n+      pcrel = true;\n       break;\n \n #ifndef OBJ_XCOFF\n@@ -3182,7 +3182,7 @@ fixup_size (bfd_reloc_code_real_type reloc, bfd_boolean *pc_relative)\n     case BFD_RELOC_PPC64_PCREL34:\n     case BFD_RELOC_PPC64_PLT_PCREL34:\n       size = 8;\n-      pcrel = TRUE;\n+      pcrel = true;\n       break;\n \n     default:\n@@ -3430,11 +3430,11 @@ md_assemble (char *str)\n \t  if (((operand->flags & PPC_OPERAND_CR_REG) != 0)\n \t      || (operand->flags & PPC_OPERAND_CR_BIT) != 0)\n \t    {\n-\t      cr_operand = TRUE;\n+\t      cr_operand = true;\n \t      lex_type['%'] |= LEX_BEGIN_NAME;\n \t    }\n \t  expression (&ex);\n-\t  cr_operand = FALSE;\n+\t  cr_operand = false;\n \t  lex_type['%'] = save_lex;\n \t}\n \n@@ -4071,7 +4071,7 @@ md_assemble (char *str)\n       fixS *fixP;\n       if (fixups[i].reloc != BFD_RELOC_NONE)\n \t{\n-\t  bfd_boolean pcrel;\n+\t  bool pcrel;\n \t  unsigned int size = fixup_size (fixups[i].reloc, &pcrel);\n \t  int offset = target_big_endian ? (insn_length - size) : 0;\n \n@@ -4257,7 +4257,7 @@ ppc_byte (int ignore ATTRIBUTE_UNUSED)\n \n /* This is set if we are creating a .stabx symbol, since we don't want\n    to handle symbol suffixes for such symbols.  */\n-static bfd_boolean ppc_stab_symbol;\n+static bool ppc_stab_symbol;\n \n /* The .comm and .lcomm pseudo-ops for XCOFF.  XCOFF puts common\n    symbols in the .bss segment as though they were local common\n@@ -4379,7 +4379,7 @@ ppc_comm (int lcomm)\n       if (!ppc_xcoff_section_is_initialized (section))\n \t{\n \t  ppc_init_xcoff_section (section,\n-\t\t\t\t  subseg_new (\".tbss\", 0), FALSE);\n+\t\t\t\t  subseg_new (\".tbss\", 0), false);\n \t  bfd_set_section_flags (section->segment,\n \t\t\t\t SEC_ALLOC | SEC_THREAD_LOCAL);\n \t  seg_info (section->segment)->bss = 1;\n@@ -4537,7 +4537,7 @@ ppc_change_csect (symbolS *sym, offsetT align)\n \t  if (!ppc_xcoff_section_is_initialized (section))\n \t    {\n \t      ppc_init_xcoff_section (section, subseg_new (\".tdata\", 0),\n-\t\t\t\t\tTRUE);\n+\t\t\t\t      true);\n \t      bfd_set_section_flags (section->segment, SEC_ALLOC\n \t\t\t\t     | SEC_LOAD | SEC_RELOC | SEC_DATA\n \t\t\t\t     | SEC_THREAD_LOCAL);\n@@ -4549,7 +4549,7 @@ ppc_change_csect (symbolS *sym, offsetT align)\n \t  if (!ppc_xcoff_section_is_initialized (section))\n \t    {\n \t      ppc_init_xcoff_section (section, subseg_new (\".tbss\", 0),\n-\t\t\t\t      FALSE);\n+\t\t\t\t      false);\n \t      bfd_set_section_flags (section->segment, SEC_ALLOC |\n \t\t\t\t     SEC_THREAD_LOCAL);\n \t      seg_info (section->segment)->bss = 1;\n@@ -4879,7 +4879,7 @@ ppc_ref (int ignore ATTRIBUTE_UNUSED)\n       c = get_symbol_name (&name);\n \n       fix_at_start (symbol_get_frag (ppc_current_csect), 0,\n-\t\t    symbol_find_or_make (name), 0, FALSE, BFD_RELOC_NONE);\n+\t\t    symbol_find_or_make (name), 0, false, BFD_RELOC_NONE);\n \n       *input_line_pointer = c;\n       SKIP_WHITESPACE_AFTER_NAME ();\n@@ -4955,9 +4955,9 @@ ppc_stabx (int ignore ATTRIBUTE_UNUSED)\n     }\n   ++input_line_pointer;\n \n-  ppc_stab_symbol = TRUE;\n+  ppc_stab_symbol = true;\n   sym = symbol_make (name);\n-  ppc_stab_symbol = FALSE;\n+  ppc_stab_symbol = false;\n \n   symbol_get_tc (sym)->real_name = name;\n \n@@ -5836,7 +5836,7 @@ ppc_symbol_new_hook (symbolS *sym)\n    seen.  It tells ppc_adjust_symtab whether it needs to look through\n    the symbols.  */\n \n-static bfd_boolean ppc_saw_abs;\n+static bool ppc_saw_abs;\n \n /* Change the name of a symbol just before writing it out.  Set the\n    real name if the .rename pseudo-op was used.  Otherwise, remove any\n@@ -5979,7 +5979,7 @@ ppc_frob_symbol (symbolS *sym)\n \t{\n \t  /* This is an absolute symbol.  The csect will be created by\n \t     ppc_adjust_symtab.  */\n-\t  ppc_saw_abs = TRUE;\n+\t  ppc_saw_abs = true;\n \t  a->x_csect.x_smtyp = XTY_LD;\n \t  if (symbol_get_tc (sym)->symbol_class == -1)\n \t    symbol_get_tc (sym)->symbol_class = XMC_XO;\n@@ -6157,7 +6157,7 @@ ppc_adjust_symtab (void)\n       coffsymbol (symbol_get_bfdsym (sym))->native[i].fix_scnlen = 1;\n     }\n \n-  ppc_saw_abs = FALSE;\n+  ppc_saw_abs = false;\n }\n \n /* Set the VMA for a section.  This is called on all the sections in"
    },
    {
      "sha": "14876f4fe4fcdbb95c52102d438b4fb6b58c0227",
      "filename": "gas/config/tc-pru.c",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-pru.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-pru.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-pru.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -66,14 +66,14 @@ struct pru_opt_s\n {\n   /* -mno-link-relax / -mlink-relax: generate (or not)\n      relocations for linker relaxation.  */\n-  bfd_boolean link_relax;\n+  bool link_relax;\n \n   /* -mno-warn-regname-label: do not output a warning that a label name\n      matches a register name.  */\n-  bfd_boolean warn_regname_label;\n+  bool warn_regname_label;\n };\n \n-static struct pru_opt_s pru_opt = { TRUE, TRUE };\n+static struct pru_opt_s pru_opt = { true, true };\n \n const char *md_shortopts = \"r\";\n \n@@ -188,7 +188,7 @@ md_number_to_chars (char *buf, valueT val, int n)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \n /* Return true if STR starts with PREFIX, which should be a string literal.  */\n@@ -246,7 +246,7 @@ pru_align (int log_size, const char *pfill, symbolS *label)\n       if (label != NULL && !switched_seg_p)\n \t{\n \t  symbolS *sym;\n-\t  int label_seen = FALSE;\n+\t  int label_seen = false;\n \t  struct frag *old_frag;\n \t  valueT old_value;\n \t  valueT new_value;\n@@ -272,7 +272,7 @@ pru_align (int log_size, const char *pfill, symbolS *label)\n \t    if (symbol_get_frag (sym) == old_frag\n \t\t&& S_GET_VALUE (sym) == old_value)\n \t      {\n-\t\tlabel_seen = TRUE;\n+\t\tlabel_seen = true;\n \t\tsymbol_set_frag (sym, frag_now);\n \t\tS_SET_VALUE (sym, new_value);\n \t      }\n@@ -425,13 +425,13 @@ s_pru_set (int equiv)\n   SKIP_WHITESPACE ();\n   if (is_end_of_line[(unsigned char) *input_line_pointer])\n     {\n-      bfd_boolean done = TRUE;\n+      bool done = true;\n       *endline = 0;\n \n       if (!strcmp (directive, \"no_warn_regname_label\"))\n-\t  pru_opt.warn_regname_label = FALSE;\n+\t  pru_opt.warn_regname_label = false;\n       else\n-\tdone = FALSE;\n+\tdone = false;\n \n       if (done)\n \t{\n@@ -491,7 +491,7 @@ md_convert_frag (bfd *headers ATTRIBUTE_UNUSED, segT segment ATTRIBUTE_UNUSED,\n }\n \n \f\n-static bfd_boolean\n+static bool\n relaxable_section (asection *sec)\n {\n   return ((sec->flags & SEC_DEBUGGING) == 0\n@@ -1404,7 +1404,7 @@ pru_parse_args (pru_insn_infoS *insn ATTRIBUTE_UNUSED, char *argstr,\n   int i;\n   p = argstr;\n   i = 0;\n-  bfd_boolean terminate = FALSE;\n+  bool terminate = false;\n \n   /* This rest of this function is it too fragile and it mostly works,\n      therefore special case this one.  */\n@@ -1439,7 +1439,7 @@ pru_parse_args (pru_insn_infoS *insn ATTRIBUTE_UNUSED, char *argstr,\n \t}\n \n       if (*parsestr == '\\0' || (p != NULL && *p == '\\0'))\n-\tterminate = TRUE;\n+\tterminate = true;\n       ++i;\n     }\n \n@@ -1516,13 +1516,13 @@ md_parse_option (int c, const char *arg ATTRIBUTE_UNUSED)\n       pru_mode = PRU_MODE_TEST;\n       break;\n     case OPTION_LINK_RELAX:\n-      pru_opt.link_relax = TRUE;\n+      pru_opt.link_relax = true;\n       break;\n     case OPTION_NO_LINK_RELAX:\n-      pru_opt.link_relax = FALSE;\n+      pru_opt.link_relax = false;\n       break;\n     case OPTION_NO_WARN_REGNAME_LABEL:\n-      pru_opt.warn_regname_label = FALSE;\n+      pru_opt.warn_regname_label = false;\n       break;\n     default:\n       return 0;\n@@ -1835,7 +1835,7 @@ skip_space (char *s)\n int\n pru_parse_cons_expression (expressionS *exp, int nbytes)\n {\n-  int is_pmem = FALSE;\n+  int is_pmem = false;\n   char *tmp;\n \n   tmp = input_line_pointer = skip_space (input_line_pointer);\n@@ -1852,15 +1852,15 @@ pru_parse_cons_expression (expressionS *exp, int nbytes)\n \t  if (*input_line_pointer == '(')\n \t    {\n \t      input_line_pointer = skip_space (input_line_pointer + 1);\n-\t      is_pmem = TRUE;\n+\t      is_pmem = true;\n \t      expression (exp);\n \n \t      if (*input_line_pointer == ')')\n \t\t++input_line_pointer;\n \t      else\n \t\t{\n \t\t  as_bad (_(\"`)' required\"));\n-\t\t  is_pmem = FALSE;\n+\t\t  is_pmem = false;\n \t\t}\n \n \t      return is_pmem;\n@@ -1933,24 +1933,24 @@ pru_frame_initial_instructions (void)\n   cfi_add_CFA_def_cfa (fp_regno, 0);\n }\n \n-bfd_boolean\n+bool\n pru_allow_local_subtract (expressionS * left,\n \t\t\t     expressionS * right,\n \t\t\t     segT section)\n {\n   /* If we are not in relaxation mode, subtraction is OK.  */\n   if (!linkrelax)\n-    return TRUE;\n+    return true;\n \n   /* If the symbols are not in a code section then they are OK.  */\n   if ((section->flags & SEC_CODE) == 0)\n-    return TRUE;\n+    return true;\n \n   if (left->X_add_symbol == right->X_add_symbol)\n-    return TRUE;\n+    return true;\n \n   /* We have to assume that there may be instructions between the\n      two symbols and that relaxation may increase the distance between\n      them.  */\n-  return FALSE;\n+  return false;\n }"
    },
    {
      "sha": "7930cefc497c0b52250ff8a4cde1f01dfa666af1",
      "filename": "gas/config/tc-pru.h",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-pru.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-pru.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-pru.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -154,7 +154,6 @@ extern void pru_frame_initial_instructions (void);\n /* The difference between same-section symbols may be affected by linker\n    relaxation, so do not resolve such expressions in the assembler.  */\n #define md_allow_local_subtract(l,r,s) pru_allow_local_subtract (l, r, s)\n-extern bfd_boolean pru_allow_local_subtract (expressionS *, expressionS *,\n-\t\t\t\t\t     segT);\n+extern bool pru_allow_local_subtract (expressionS *, expressionS *, segT);\n \n #endif /* __TC_PRU__ */"
    },
    {
      "sha": "2bce5e81d924a3dde10dac45a88f4b942aa4d948",
      "filename": "gas/config/tc-riscv.c",
      "status": "modified",
      "additions": 114,
      "deletions": 114,
      "changes": 228,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-riscv.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -176,7 +176,7 @@ static enum riscv_spec_class default_priv_spec = PRIV_SPEC_CLASS_NONE;\n \n static unsigned xlen = 0; /* The width of an x-register.  */\n static unsigned abi_xlen = 0; /* The width of a pointer in the ABI.  */\n-static bfd_boolean rve_abi = FALSE;\n+static bool rve_abi = false;\n enum float_abi\n {\n   FLOAT_ABI_DEFAULT = -1,\n@@ -280,7 +280,7 @@ static struct riscv_set_options riscv_opts =\n };\n \n static void\n-riscv_set_rvc (bfd_boolean rvc_value)\n+riscv_set_rvc (bool rvc_value)\n {\n   if (rvc_value)\n     elf_flags |= EF_RISCV_RVC;\n@@ -289,25 +289,25 @@ riscv_set_rvc (bfd_boolean rvc_value)\n }\n \n static void\n-riscv_set_rve (bfd_boolean rve_value)\n+riscv_set_rve (bool rve_value)\n {\n   riscv_opts.rve = rve_value;\n }\n \n static riscv_subset_list_t riscv_subsets;\n \n-static bfd_boolean\n+static bool\n riscv_subset_supports (const char *feature)\n {\n   struct riscv_subset_t *subset;\n \n   if (riscv_opts.rvc && (strcasecmp (feature, \"c\") == 0))\n-    return TRUE;\n+    return true;\n \n   return riscv_lookup_subset (&riscv_subsets, feature, &subset);\n }\n \n-static bfd_boolean\n+static bool\n riscv_multi_subset_supports (enum riscv_insn_class insn_class)\n {\n   switch (insn_class)\n@@ -345,7 +345,7 @@ riscv_multi_subset_supports (enum riscv_insn_class insn_class)\n \n     default:\n       as_fatal (\"internal: unreachable\");\n-      return FALSE;\n+      return false;\n     }\n }\n \n@@ -419,10 +419,10 @@ riscv_set_arch (const char *s)\n }\n \n /* Indicate -mabi option is explictly set.  */\n-static bfd_boolean explicit_mabi = FALSE;\n+static bool explicit_mabi = false;\n \n static void\n-riscv_set_abi (unsigned new_xlen, enum float_abi new_float_abi, bfd_boolean rve)\n+riscv_set_abi (unsigned new_xlen, enum float_abi new_float_abi, bool rve)\n {\n   abi_xlen = new_xlen;\n   float_abi = new_float_abi;\n@@ -438,11 +438,11 @@ riscv_set_abi_by_arch (void)\n   if (!explicit_mabi)\n     {\n       if (riscv_subset_supports (\"q\"))\n-\triscv_set_abi (xlen, FLOAT_ABI_QUAD, FALSE);\n+\triscv_set_abi (xlen, FLOAT_ABI_QUAD, false);\n       else if (riscv_subset_supports (\"d\"))\n-\triscv_set_abi (xlen, FLOAT_ABI_DOUBLE, FALSE);\n+\triscv_set_abi (xlen, FLOAT_ABI_DOUBLE, false);\n       else\n-\triscv_set_abi (xlen, FLOAT_ABI_SOFT, FALSE);\n+\triscv_set_abi (xlen, FLOAT_ABI_SOFT, false);\n     }\n   else\n     {\n@@ -493,13 +493,13 @@ const char EXP_CHARS[] = \"eE\";\n const char FLT_CHARS[] = \"rRsSfFdDxXpP\";\n \n /* Indicate we are already assemble any instructions or not.  */\n-static bfd_boolean start_assemble = FALSE;\n+static bool start_assemble = false;\n \n /* Indicate ELF attributes are explicitly set.  */\n-static bfd_boolean explicit_attr = FALSE;\n+static bool explicit_attr = false;\n \n /* Indicate CSR or priv instructions are explicitly used.  */\n-static bfd_boolean explicit_priv_attr = FALSE;\n+static bool explicit_priv_attr = false;\n \n /* Macros for encoding relaxation state for RVC branches and far jumps.  */\n #define RELAX_BRANCH_ENCODE(uncond, rvc, length)\t\\\n@@ -795,7 +795,7 @@ riscv_init_csr_hash (const char *name,\n \t\t     enum riscv_spec_class abort_version)\n {\n   struct riscv_csr_extra *entry, *pre_entry;\n-  bfd_boolean need_enrty = TRUE;\n+  bool need_enrty = true;\n \n   pre_entry = NULL;\n   entry = (struct riscv_csr_extra *) str_hash_find (csr_extra_hash, name);\n@@ -805,7 +805,7 @@ riscv_init_csr_hash (const char *name,\n \t  && entry->address == address\n \t  && entry->define_version == define_version\n \t  && entry->abort_version == abort_version)\n-\tneed_enrty = FALSE;\n+\tneed_enrty = false;\n       pre_entry = entry;\n       entry = entry->next;\n     }\n@@ -843,8 +843,8 @@ riscv_csr_address (const char *csr_name,\n {\n   struct riscv_csr_extra *saved_entry = entry;\n   enum riscv_csr_class csr_class = entry->csr_class;\n-  bfd_boolean need_check_version = TRUE;\n-  bfd_boolean result = TRUE;\n+  bool need_check_version = true;\n+  bool result = true;\n \n   switch (csr_class)\n     {\n@@ -856,10 +856,10 @@ riscv_csr_address (const char *csr_name,\n       break;\n     case CSR_CLASS_F:\n       result = riscv_subset_supports (\"f\");\n-      need_check_version = FALSE;\n+      need_check_version = false;\n       break;\n     case CSR_CLASS_DEBUG:\n-      need_check_version = FALSE;\n+      need_check_version = false;\n       break;\n     default:\n       as_bad (_(\"internal: bad RISC-V CSR class (0x%x)\"), csr_class);\n@@ -927,7 +927,7 @@ reg_lookup_internal (const char *s, enum reg_class class)\n   return DECODE_REG_NUM (r);\n }\n \n-static bfd_boolean\n+static bool\n reg_lookup (char **s, enum reg_class class, unsigned int *regnop)\n {\n   char *e;\n@@ -955,31 +955,31 @@ reg_lookup (char **s, enum reg_class class, unsigned int *regnop)\n   return reg >= 0;\n }\n \n-static bfd_boolean\n+static bool\n arg_lookup (char **s, const char *const *array, size_t size, unsigned *regnop)\n {\n   const char *p = strchr (*s, ',');\n   size_t i, len = p ? (size_t)(p - *s) : strlen (*s);\n \n   if (len == 0)\n-    return FALSE;\n+    return false;\n \n   for (i = 0; i < size; i++)\n     if (array[i] != NULL && strncmp (array[i], *s, len) == 0)\n       {\n \t*regnop = i;\n \t*s += len;\n-\treturn TRUE;\n+\treturn true;\n       }\n \n-  return FALSE;\n+  return false;\n }\n \n /* For consistency checking, verify that all bits are specified either\n    by the match/mask part of the instruction definition, or by the\n    operand list. The `length` could be 0, 4 or 8, 0 for auto detection.  */\n \n-static bfd_boolean\n+static bool\n validate_riscv_insn (const struct riscv_opcode *opc, int length)\n {\n   const char *p = opc->args;\n@@ -999,7 +999,7 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n     {\n       as_bad (_(\"internal: bad RISC-V opcode (mask error): %s %s\"),\n \t      opc->name, opc->args);\n-      return FALSE;\n+      return false;\n     }\n \n #define USE_BITS(mask,shift)\t(used_bits |= ((insn_t)(mask) << (shift)))\n@@ -1050,14 +1050,14 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n \t\t  as_bad (_(\"internal: bad RISC-V opcode \"\n \t\t\t    \"(unknown operand type `CF%c'): %s %s\"),\n \t\t\t  c, opc->name, opc->args);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t      }\n \t    break;\n \t  default:\n \t    as_bad (_(\"internal: bad RISC-V opcode \"\n \t\t      \"(unknown operand type `C%c'): %s %s\"),\n \t\t    c, opc->name, opc->args);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \tbreak;\n       case ',': break;\n@@ -1105,7 +1105,7 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n \t      as_bad (_(\"internal: bad RISC-V opcode \"\n \t\t\t\"(unknown operand type `F%c'): %s %s\"),\n \t\t      c, opc->name, opc->args);\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \tbreak;\n       case 'O': /* Opcode for .insn directive.  */\n@@ -1117,14 +1117,14 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n \t      as_bad (_(\"internal: bad RISC-V opcode \"\n \t\t\t\"(unknown operand type `F%c'): %s %s\"),\n \t\t      c, opc->name, opc->args);\n-\t     return FALSE;\n+\t     return false;\n \t  }\n \tbreak;\n       default:\n \tas_bad (_(\"internal: bad RISC-V opcode \"\n \t\t  \"(unknown operand type `%c'): %s %s\"),\n \t\tc, opc->name, opc->args);\n-\treturn FALSE;\n+\treturn false;\n       }\n #undef USE_BITS\n   if (used_bits != required_bits)\n@@ -1133,9 +1133,9 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n \t\t\"(bits 0x%lx undefined): %s %s\"),\n \t      ~(unsigned long)(used_bits & required_bits),\n \t      opc->name, opc->args);\n-      return FALSE;\n+      return false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n struct percent_op_match\n@@ -1149,7 +1149,7 @@ struct percent_op_match\n \n static htab_t\n init_opcode_hash (const struct riscv_opcode *opcodes,\n-\t\t  bfd_boolean insn_directive_p)\n+\t\t  bool insn_directive_p)\n {\n   int i = 0;\n   int length;\n@@ -1193,8 +1193,8 @@ md_begin (void)\n   if (! bfd_set_arch_mach (stdoutput, bfd_arch_riscv, mach))\n     as_warn (_(\"could not set architecture and machine\"));\n \n-  op_hash = init_opcode_hash (riscv_opcodes, FALSE);\n-  insn_type_hash = init_opcode_hash (riscv_insn_types, TRUE);\n+  op_hash = init_opcode_hash (riscv_opcodes, false);\n+  insn_type_hash = init_opcode_hash (riscv_insn_types, true);\n \n   reg_names_hash = str_htab_create ();\n   hash_reg_names (RCLASS_GPR, riscv_gpr_names_numeric, NGPR);\n@@ -1285,7 +1285,7 @@ append_insn (struct riscv_cl_insn *ip, expressionS *address_expr,\n \n \t  ip->fixp = fix_new_exp (ip->frag, ip->where,\n \t\t\t\t  bfd_get_reloc_size (howto),\n-\t\t\t\t  address_expr, FALSE, reloc_type);\n+\t\t\t\t  address_expr, false, reloc_type);\n \n \t  ip->fixp->fx_tcbit = riscv_opts.relax;\n \t}\n@@ -1414,7 +1414,7 @@ normalize_constant_expr (expressionS *ex)\n \n static void\n check_absolute_expr (struct riscv_cl_insn *ip, expressionS *ex,\n-\t\t     bfd_boolean maybe_csr)\n+\t\t     bool maybe_csr)\n {\n   if (ex->X_op == O_big)\n     as_bad (_(\"unsupported large constant\"));\n@@ -1536,7 +1536,7 @@ load_const (int reg, expressionS *ep)\n /* Zero extend and sign extend byte/half-word/word.  */\n \n static void\n-riscv_ext (int destreg, int srcreg, unsigned shift, bfd_boolean sign)\n+riscv_ext (int destreg, int srcreg, unsigned shift, bool sign)\n {\n   if (sign)\n     {\n@@ -1673,19 +1673,19 @@ macro (struct riscv_cl_insn *ip, expressionS *imm_expr,\n       break;\n \n     case M_ZEXTH:\n-      riscv_ext (rd, rs1, xlen - 16, FALSE);\n+      riscv_ext (rd, rs1, xlen - 16, false);\n       break;\n \n     case M_ZEXTW:\n-      riscv_ext (rd, rs1, xlen - 32, FALSE);\n+      riscv_ext (rd, rs1, xlen - 32, false);\n       break;\n \n     case M_SEXTB:\n-      riscv_ext (rd, rs1, xlen - 8, TRUE);\n+      riscv_ext (rd, rs1, xlen - 8, true);\n       break;\n \n     case M_SEXTH:\n-      riscv_ext (rd, rs1, xlen - 16, TRUE);\n+      riscv_ext (rd, rs1, xlen - 16, true);\n       break;\n \n     default:\n@@ -1736,7 +1736,7 @@ static const struct percent_op_match percent_op_null[] =\n    move *STR over the operator and store its relocation code in *RELOC.\n    Leave both *STR and *RELOC alone when returning false.  */\n \n-static bfd_boolean\n+static bool\n parse_relocation (char **str, bfd_reloc_code_real_type *reloc,\n \t\t  const struct percent_op_match *percent_op)\n {\n@@ -1760,9 +1760,9 @@ parse_relocation (char **str, bfd_reloc_code_real_type *reloc,\n \t\t    \"current ABI\", percent_op->str);\n \t    *reloc = BFD_RELOC_UNUSED;\n \t  }\n-\treturn TRUE;\n+\treturn true;\n       }\n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -1863,7 +1863,7 @@ my_getOpcodeExpression (expressionS *ep, bfd_reloc_code_real_type *reloc,\n    \"lw t0, (t1)\" is shorthand for \"lw t0, 0(t1)\".  Return TRUE iff such\n    an implicit offset was detected.  */\n \n-static bfd_boolean\n+static bool\n riscv_handle_implicit_zero_offset (expressionS *ep, const char *s)\n {\n   /* Check whether there is only a single bracketed expression left.\n@@ -1872,10 +1872,10 @@ riscv_handle_implicit_zero_offset (expressionS *ep, const char *s)\n     {\n       ep->X_op = O_constant;\n       ep->X_add_number = 0;\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* All RISC-V CSR instructions belong to one of these classes.  */\n@@ -1909,7 +1909,7 @@ riscv_csr_insn_type (insn_t insn)\n    CSR when RS1 isn't zero.  The CSR is read only if the [11:10] bits of\n    CSR address is 0x3.  */\n \n-static bfd_boolean\n+static bool\n riscv_csr_read_only_check (insn_t insn)\n {\n   int csr = (insn & (OP_MASK_CSR << OP_SH_CSR)) >> OP_SH_CSR;\n@@ -1922,9 +1922,9 @@ riscv_csr_read_only_check (insn_t insn)\n \t    || csr_insn == INSN_CSRRC)\n \t   && rs1 != 0)\n \t  || csr_insn == INSN_CSRRW))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Return True if it is a privileged instruction.  Otherwise, return FALSE.\n@@ -1940,7 +1940,7 @@ riscv_csr_read_only_check (insn_t insn)\n    dret is defined in the debug spec, so it should be checked in the future,\n    too.  */\n \n-static bfd_boolean\n+static bool\n riscv_is_priv_insn (insn_t insn)\n {\n   return (((insn ^ MATCH_SRET) & MASK_SRET) == 0\n@@ -1971,7 +1971,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n   const struct percent_op_match *p;\n   const char *error = \"unrecognized opcode\";\n   /* Indicate we are assembling instruction with CSR.  */\n-  bfd_boolean insn_with_csr = FALSE;\n+  bool insn_with_csr = false;\n \n   /* Parse the name of the instruction.  Terminate the string if whitespace\n      is found so that str_hash_find only sees the name part of the string.  */\n@@ -2020,7 +2020,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t    break;\n \n \t\t  if (riscv_is_priv_insn (ip->insn_opcode))\n-\t\t    explicit_priv_attr = TRUE;\n+\t\t    explicit_priv_attr = true;\n \n \t\t  /* Check if we write a read-only CSR by the CSR\n \t\t     instruction.  */\n@@ -2033,14 +2033,14 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t      if (save_c)\n \t\t\t*(argsStart - 1) = save_c;\n \t\t      as_warn (_(\"read-only CSR is written `%s'\"), str);\n-\t\t      insn_with_csr = FALSE;\n+\t\t      insn_with_csr = false;\n \t\t    }\n \t\t}\n \t      if (*s != '\\0')\n \t\tbreak;\n \t      /* Successful assembly.  */\n \t      error = NULL;\n-\t      insn_with_csr = FALSE;\n+\t      insn_with_csr = false;\n \t      goto out;\n \n \t    case 'C': /* RVC */\n@@ -2355,7 +2355,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \n \t    case '<': /* Shift amount, 0 - 31.  */\n \t      my_getExpression (imm_expr, s);\n-\t      check_absolute_expr (ip, imm_expr, FALSE);\n+\t      check_absolute_expr (ip, imm_expr, false);\n \t      if ((unsigned long) imm_expr->X_add_number > 31)\n \t\tas_bad (_(\"improper shift amount (%lu)\"),\n \t\t\t(unsigned long) imm_expr->X_add_number);\n@@ -2366,7 +2366,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \n \t    case '>': /* Shift amount, 0 - (XLEN-1).  */\n \t      my_getExpression (imm_expr, s);\n-\t      check_absolute_expr (ip, imm_expr, FALSE);\n+\t      check_absolute_expr (ip, imm_expr, false);\n \t      if ((unsigned long) imm_expr->X_add_number >= xlen)\n \t\tas_bad (_(\"improper shift amount (%lu)\"),\n \t\t\t(unsigned long) imm_expr->X_add_number);\n@@ -2377,7 +2377,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \n \t    case 'Z': /* CSRRxI immediate.  */\n \t      my_getExpression (imm_expr, s);\n-\t      check_absolute_expr (ip, imm_expr, FALSE);\n+\t      check_absolute_expr (ip, imm_expr, false);\n \t      if ((unsigned long) imm_expr->X_add_number > 31)\n \t\tas_bad (_(\"improper CSRxI immediate (%lu)\"),\n \t\t\t(unsigned long) imm_expr->X_add_number);\n@@ -2387,14 +2387,14 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      continue;\n \n \t    case 'E': /* Control register.  */\n-\t      insn_with_csr = TRUE;\n-\t      explicit_priv_attr = TRUE;\n+\t      insn_with_csr = true;\n+\t      explicit_priv_attr = true;\n \t      if (reg_lookup (&s, RCLASS_CSR, &regno))\n \t\tINSERT_OPERAND (CSR, *ip, regno);\n \t      else\n \t\t{\n \t\t  my_getExpression (imm_expr, s);\n-\t\t  check_absolute_expr (ip, imm_expr, TRUE);\n+\t\t  check_absolute_expr (ip, imm_expr, true);\n \t\t  if ((unsigned long) imm_expr->X_add_number > 0xfff)\n \t\t    as_bad (_(\"improper CSR address (%lu)\"),\n \t\t\t    (unsigned long) imm_expr->X_add_number);\n@@ -2712,7 +2712,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t}\n       s = argsStart;\n       error = _(\"illegal operands\");\n-      insn_with_csr = FALSE;\n+      insn_with_csr = false;\n     }\n \n  out:\n@@ -2734,7 +2734,7 @@ md_assemble (char *str)\n      before assembling.  */\n   if (!start_assemble)\n     {\n-      start_assemble = TRUE;\n+      start_assemble = true;\n \n       riscv_set_abi_by_arch ();\n       if (!riscv_set_default_priv_spec (NULL))\n@@ -2823,59 +2823,59 @@ md_parse_option (int c, const char *arg)\n       break;\n \n     case OPTION_NO_PIC:\n-      riscv_opts.pic = FALSE;\n+      riscv_opts.pic = false;\n       break;\n \n     case OPTION_PIC:\n-      riscv_opts.pic = TRUE;\n+      riscv_opts.pic = true;\n       break;\n \n     case OPTION_MABI:\n       if (strcmp (arg, \"ilp32\") == 0)\n-\triscv_set_abi (32, FLOAT_ABI_SOFT, FALSE);\n+\triscv_set_abi (32, FLOAT_ABI_SOFT, false);\n       else if (strcmp (arg, \"ilp32e\") == 0)\n-\triscv_set_abi (32, FLOAT_ABI_SOFT, TRUE);\n+\triscv_set_abi (32, FLOAT_ABI_SOFT, true);\n       else if (strcmp (arg, \"ilp32f\") == 0)\n-\triscv_set_abi (32, FLOAT_ABI_SINGLE, FALSE);\n+\triscv_set_abi (32, FLOAT_ABI_SINGLE, false);\n       else if (strcmp (arg, \"ilp32d\") == 0)\n-\triscv_set_abi (32, FLOAT_ABI_DOUBLE, FALSE);\n+\triscv_set_abi (32, FLOAT_ABI_DOUBLE, false);\n       else if (strcmp (arg, \"ilp32q\") == 0)\n-\triscv_set_abi (32, FLOAT_ABI_QUAD, FALSE);\n+\triscv_set_abi (32, FLOAT_ABI_QUAD, false);\n       else if (strcmp (arg, \"lp64\") == 0)\n-\triscv_set_abi (64, FLOAT_ABI_SOFT, FALSE);\n+\triscv_set_abi (64, FLOAT_ABI_SOFT, false);\n       else if (strcmp (arg, \"lp64f\") == 0)\n-\triscv_set_abi (64, FLOAT_ABI_SINGLE, FALSE);\n+\triscv_set_abi (64, FLOAT_ABI_SINGLE, false);\n       else if (strcmp (arg, \"lp64d\") == 0)\n-\triscv_set_abi (64, FLOAT_ABI_DOUBLE, FALSE);\n+\triscv_set_abi (64, FLOAT_ABI_DOUBLE, false);\n       else if (strcmp (arg, \"lp64q\") == 0)\n-\triscv_set_abi (64, FLOAT_ABI_QUAD, FALSE);\n+\triscv_set_abi (64, FLOAT_ABI_QUAD, false);\n       else\n \treturn 0;\n-      explicit_mabi = TRUE;\n+      explicit_mabi = true;\n       break;\n \n     case OPTION_RELAX:\n-      riscv_opts.relax = TRUE;\n+      riscv_opts.relax = true;\n       break;\n \n     case OPTION_NO_RELAX:\n-      riscv_opts.relax = FALSE;\n+      riscv_opts.relax = false;\n       break;\n \n     case OPTION_ARCH_ATTR:\n-      riscv_opts.arch_attr = TRUE;\n+      riscv_opts.arch_attr = true;\n       break;\n \n     case OPTION_NO_ARCH_ATTR:\n-      riscv_opts.arch_attr = FALSE;\n+      riscv_opts.arch_attr = false;\n       break;\n \n     case OPTION_CSR_CHECK:\n-      riscv_opts.csr_check = TRUE;\n+      riscv_opts.csr_check = true;\n       break;\n \n     case OPTION_NO_CSR_CHECK:\n-      riscv_opts.csr_check = FALSE;\n+      riscv_opts.csr_check = false;\n       break;\n \n     case OPTION_MISA_SPEC:\n@@ -2928,14 +2928,14 @@ riscv_after_parse_args (void)\n   riscv_set_arch (default_arch_with_ext);\n \n   /* Add the RVC extension, regardless of -march, to support .option rvc.  */\n-  riscv_set_rvc (FALSE);\n+  riscv_set_rvc (false);\n   if (riscv_subset_supports (\"c\"))\n-    riscv_set_rvc (TRUE);\n+    riscv_set_rvc (true);\n \n   /* Enable RVE if specified by the -march option.  */\n-  riscv_set_rve (FALSE);\n+  riscv_set_rve (false);\n   if (riscv_subset_supports (\"e\"))\n-    riscv_set_rve (TRUE);\n+    riscv_set_rve (true);\n \n   /* If the CIE to be produced has not been overridden on the command line,\n      then produce version 3 by default.  This allows us to use the full\n@@ -2957,7 +2957,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n {\n   unsigned int subtype;\n   bfd_byte *buf = (bfd_byte *) (fixP->fx_frag->fr_literal + fixP->fx_where);\n-  bfd_boolean relaxable = FALSE;\n+  bool relaxable = false;\n   offsetT loc;\n   segT sub_segment;\n \n@@ -2972,8 +2972,8 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n       bfd_putl32 (riscv_apply_const_reloc (fixP->fx_r_type, *valP)\n \t\t  | bfd_getl32 (buf), buf);\n       if (fixP->fx_addsy == NULL)\n-\tfixP->fx_done = TRUE;\n-      relaxable = TRUE;\n+\tfixP->fx_done = true;\n+      relaxable = true;\n       break;\n \n     case BFD_RELOC_RISCV_GOT_HI20:\n@@ -2993,7 +2993,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n     case BFD_RELOC_RISCV_TPREL_LO12_I:\n     case BFD_RELOC_RISCV_TPREL_LO12_S:\n     case BFD_RELOC_RISCV_TPREL_ADD:\n-      relaxable = TRUE;\n+      relaxable = true;\n       /* Fall through.  */\n \n     case BFD_RELOC_RISCV_TLS_GOT_HI20:\n@@ -3166,7 +3166,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n \n     case BFD_RELOC_RISCV_CALL:\n     case BFD_RELOC_RISCV_CALL_PLT:\n-      relaxable = TRUE;\n+      relaxable = true;\n       break;\n \n     case BFD_RELOC_RISCV_PCREL_HI20:\n@@ -3265,21 +3265,21 @@ s_riscv_option (int x ATTRIBUTE_UNUSED)\n   *input_line_pointer = '\\0';\n \n   if (strcmp (name, \"rvc\") == 0)\n-    riscv_set_rvc (TRUE);\n+    riscv_set_rvc (true);\n   else if (strcmp (name, \"norvc\") == 0)\n-    riscv_set_rvc (FALSE);\n+    riscv_set_rvc (false);\n   else if (strcmp (name, \"pic\") == 0)\n-    riscv_opts.pic = TRUE;\n+    riscv_opts.pic = true;\n   else if (strcmp (name, \"nopic\") == 0)\n-    riscv_opts.pic = FALSE;\n+    riscv_opts.pic = false;\n   else if (strcmp (name, \"relax\") == 0)\n-    riscv_opts.relax = TRUE;\n+    riscv_opts.relax = true;\n   else if (strcmp (name, \"norelax\") == 0)\n-    riscv_opts.relax = FALSE;\n+    riscv_opts.relax = false;\n   else if (strcmp (name, \"csr-check\") == 0)\n-    riscv_opts.csr_check = TRUE;\n+    riscv_opts.csr_check = true;\n   else if (strcmp (name, \"no-csr-check\") == 0)\n-    riscv_opts.csr_check = FALSE;\n+    riscv_opts.csr_check = false;\n   else if (strcmp (name, \"push\") == 0)\n     {\n       struct riscv_option_stack *s;\n@@ -3333,7 +3333,7 @@ s_dtprel (int bytes)\n \n   p = frag_more (bytes);\n   md_number_to_chars (p, 0, bytes);\n-  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE,\n+  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, false,\n \t       (bytes == 8\n \t\t? BFD_RELOC_RISCV_TLS_DTPREL64\n \t\t: BFD_RELOC_RISCV_TLS_DTPREL32));\n@@ -3378,7 +3378,7 @@ riscv_make_nops (char *buf, bfd_vma bytes)\n    will later relax to the correct number of NOPs.  We can't compute\n    the correct alignment now because of other linker relaxations.  */\n \n-bfd_boolean\n+bool\n riscv_frag_align_code (int n)\n {\n   bfd_vma bytes = (bfd_vma) 1 << n;\n@@ -3390,11 +3390,11 @@ riscv_frag_align_code (int n)\n   /* If we are moving to a smaller alignment than the instruction size, then no\n      alignment is required. */\n   if (bytes <= insn_alignment)\n-    return TRUE;\n+    return true;\n \n   /* When not relaxing, riscv_handle_align handles code alignment.  */\n   if (!riscv_opts.relax)\n-    return FALSE;\n+    return false;\n \n   nops = frag_more (worst_case_bytes);\n \n@@ -3404,9 +3404,9 @@ riscv_frag_align_code (int n)\n   riscv_make_nops (nops, worst_case_bytes);\n \n   fix_new_exp (frag_now, nops - frag_now->fr_literal, 0,\n-\t       &ex, FALSE, BFD_RELOC_RISCV_ALIGN);\n+\t       &ex, false, BFD_RELOC_RISCV_ALIGN);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Implement HANDLE_ALIGN.  */\n@@ -3452,7 +3452,7 @@ riscv_handle_align (fragS *fragP)\n int\n md_estimate_size_before_relax (fragS *fragp, asection *segtype)\n {\n-  return (fragp->fr_var = relaxed_branch_length (fragp, segtype, FALSE));\n+  return (fragp->fr_var = relaxed_branch_length (fragp, segtype, false));\n }\n \n /* Translate internal representation of relocation info to BFD target\n@@ -3494,7 +3494,7 @@ riscv_relax_frag (asection *sec, fragS *fragp, long stretch ATTRIBUTE_UNUSED)\n   if (RELAX_BRANCH_P (fragp->fr_subtype))\n     {\n       offsetT old_var = fragp->fr_var;\n-      fragp->fr_var = relaxed_branch_length (fragp, sec, TRUE);\n+      fragp->fr_var = relaxed_branch_length (fragp, sec, true);\n       return fragp->fr_var - old_var;\n     }\n \n@@ -3556,7 +3556,7 @@ md_convert_frag_branch (fragS *fragp)\n \t    reloc = RELAX_BRANCH_UNCOND (fragp->fr_subtype)\n \t\t    ? BFD_RELOC_RISCV_RVC_JUMP : BFD_RELOC_RISCV_RVC_BRANCH;\n \t    fixp = fix_new_exp (fragp, buf - (bfd_byte *)fragp->fr_literal,\n-\t\t\t\t2, &exp, FALSE, reloc);\n+\t\t\t\t2, &exp, false, reloc);\n \t    buf += 2;\n \t    goto done;\n \n@@ -3580,7 +3580,7 @@ md_convert_frag_branch (fragS *fragp)\n     jump:\n       /* Jump to the target.  */\n       fixp = fix_new_exp (fragp, buf - (bfd_byte *)fragp->fr_literal,\n-\t\t\t  4, &exp, FALSE, BFD_RELOC_RISCV_JMP);\n+\t\t\t  4, &exp, false, BFD_RELOC_RISCV_JMP);\n       bfd_putl32 (MATCH_JAL, buf);\n       buf += 4;\n       break;\n@@ -3589,7 +3589,7 @@ md_convert_frag_branch (fragS *fragp)\n       reloc = RELAX_BRANCH_UNCOND (fragp->fr_subtype)\n \t      ? BFD_RELOC_RISCV_JMP : BFD_RELOC_12_PCREL;\n       fixp = fix_new_exp (fragp, buf - (bfd_byte *)fragp->fr_literal,\n-\t\t\t  4, &exp, FALSE, reloc);\n+\t\t\t  4, &exp, false, reloc);\n       buf += 4;\n       break;\n \n@@ -3840,7 +3840,7 @@ s_riscv_attribute (int ignored ATTRIBUTE_UNUSED)\n   unsigned old_xlen;\n   obj_attribute *attr;\n \n-  explicit_attr = TRUE;\n+  explicit_attr = true;\n   switch (tag)\n     {\n     case Tag_RISCV_arch:"
    },
    {
      "sha": "1de138458d8b073a89045f57f3431ba230e66e81",
      "filename": "gas/config/tc-riscv.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-riscv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-riscv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-riscv.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -53,7 +53,7 @@ extern int riscv_relax_frag (asection *, struct frag *, long);\n #define md_undefined_symbol(name)\t(0)\n #define md_operand(x)\n \n-extern bfd_boolean riscv_frag_align_code (int);\n+extern bool riscv_frag_align_code (int);\n #define md_do_align(N, FILL, LEN, MAX, LABEL)\t\t\t\t\\\n   if ((N) != 0 && !(FILL) && !need_pass_2 && subseg_text_p (now_seg))\t\\\n     {\t\t\t\t\t\t\t\t\t\\"
    },
    {
      "sha": "d0ecd90fb32562a148b976f208a77f7a7a67f75c",
      "filename": "gas/config/tc-rx.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-rx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-rx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-rx.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -42,15 +42,15 @@ const char EXP_CHARS[]            = \"eE\";\n const char FLT_CHARS[]            = \"dD\";\n \f\n #ifndef TE_LINUX\n-bfd_boolean rx_use_conventional_section_names = FALSE;\n+bool rx_use_conventional_section_names = false;\n static int elf_flags = E_FLAG_RX_ABI;\n #else\n-bfd_boolean rx_use_conventional_section_names = TRUE;\n+bool rx_use_conventional_section_names = true;\n static int elf_flags;\n #endif\n \n-static bfd_boolean rx_use_small_data_limit = FALSE;\n-static bfd_boolean rx_pid_mode = FALSE;\n+static bool rx_use_small_data_limit = false;\n+static bool rx_pid_mode = false;\n static int rx_num_int_regs = 0;\n int rx_pid_register;\n int rx_gp_register;\n@@ -147,23 +147,23 @@ md_parse_option (int c ATTRIBUTE_UNUSED, const char * arg ATTRIBUTE_UNUSED)\n       return 1;\n \n     case OPTION_CONVENTIONAL_SECTION_NAMES:\n-      rx_use_conventional_section_names = TRUE;\n+      rx_use_conventional_section_names = true;\n       return 1;\n \n     case OPTION_RENESAS_SECTION_NAMES:\n-      rx_use_conventional_section_names = FALSE;\n+      rx_use_conventional_section_names = false;\n       return 1;\n \n     case OPTION_SMALL_DATA_LIMIT:\n-      rx_use_small_data_limit = TRUE;\n+      rx_use_small_data_limit = true;\n       return 1;\n \n     case OPTION_RELAX:\n       linkrelax = 1;\n       return 1;\n \n     case OPTION_PID:\n-      rx_pid_mode = TRUE;\n+      rx_pid_mode = true;\n       elf_flags |= E_FLAG_RX_PID;\n       return 1;\n \n@@ -289,7 +289,7 @@ rx_include (int ignore)\n \n   /* Get the filename.  Spaces are allowed, NUL characters are not.  */\n   filename = input_line_pointer;\n-  last_char = find_end_of_line (filename, FALSE);\n+  last_char = find_end_of_line (filename, false);\n   input_line_pointer = last_char;\n \n   while (last_char >= filename && (* last_char == ' ' || * last_char == '\\n'))\n@@ -490,7 +490,7 @@ parse_rx_section (char * name)\n       else\n \ttype = SHT_NOBITS;\n \n-      obj_elf_change_section (name, type, attr, 0, NULL, FALSE, FALSE);\n+      obj_elf_change_section (name, type, attr, 0, NULL, false, false);\n     }\n   else /* Try not to redefine a section, especially B_1.  */\n     {\n@@ -505,7 +505,7 @@ parse_rx_section (char * name)\n \t| ((flags & SEC_STRINGS) ? SHF_STRINGS : 0)\n \t| ((flags & SEC_THREAD_LOCAL) ? SHF_TLS : 0);\n \n-      obj_elf_change_section (name, type, attr, 0, NULL, FALSE, FALSE);\n+      obj_elf_change_section (name, type, attr, 0, NULL, false, false);\n     }\n \n   bfd_set_section_alignment (now_seg, align);\n@@ -1096,24 +1096,24 @@ rx_equ (char * name, char * expression)\n    rather than at the start of a line.  (eg .EQU or .DEFINE).  If one\n    is found, process it and return TRUE otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n scan_for_infix_rx_pseudo_ops (char * str)\n {\n   char * p;\n   char * pseudo_op;\n   char * dot = strchr (str, '.');\n \n   if (dot == NULL || dot == str)\n-    return FALSE;\n+    return false;\n \n   /* A real pseudo-op must be preceded by whitespace.  */\n   if (dot[-1] != ' ' && dot[-1] != '\\t')\n-    return FALSE;\n+    return false;\n \n   pseudo_op = dot + 1;\n \n   if (!ISALNUM (* pseudo_op))\n-    return FALSE;\n+    return false;\n \n   for (p = pseudo_op + 1; ISALNUM (* p); p++)\n     ;\n@@ -1127,9 +1127,9 @@ scan_for_infix_rx_pseudo_ops (char * str)\n   else if (strncasecmp (\"BTEQU\", pseudo_op, p - pseudo_op) == 0)\n     as_warn (_(\"The .BTEQU pseudo-op is not implemented.\"));\n   else\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n void\n@@ -2464,7 +2464,7 @@ arelent **\n tc_gen_reloc (asection * sec ATTRIBUTE_UNUSED, fixS * fixp)\n {\n   static arelent * reloc[5];\n-  bfd_boolean is_opcode = FALSE;\n+  bool is_opcode = false;\n \n   if (fixp->fx_r_type == BFD_RELOC_NONE)\n     {\n@@ -2489,7 +2489,7 @@ tc_gen_reloc (asection * sec ATTRIBUTE_UNUSED, fixS * fixp)\n       && fixp->fx_subsy)\n     {\n       fixp->fx_r_type = BFD_RELOC_RX_DIFF;\n-      is_opcode = TRUE;\n+      is_opcode = true;\n     }\n   else if (sec)\n     is_opcode = sec->flags & SEC_CODE;"
    },
    {
      "sha": "ecdad54daf5a4b82c0afaf6b36eb270a63fbab77",
      "filename": "gas/config/tc-rx.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-rx.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-rx.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-rx.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -106,7 +106,7 @@ extern void rx_handle_align (fragS *);\n #define elf_tc_final_processing\trx_elf_final_processing\n extern void rx_elf_final_processing (void);\n \n-extern bfd_boolean rx_use_conventional_section_names;\n+extern bool rx_use_conventional_section_names;\n #define TEXT_SECTION_NAME\t(rx_use_conventional_section_names ? \".text\" : \"P\")\n #define DATA_SECTION_NAME\t(rx_use_conventional_section_names ? \".data\" : \"D_1\")\n #define BSS_SECTION_NAME\t(rx_use_conventional_section_names ? \".bss\"  : \"B_1\")"
    },
    {
      "sha": "71d01b97cc66b0dc352920a5e0a3d72635a7fdfb",
      "filename": "gas/config/tc-s12z.c",
      "status": "modified",
      "additions": 85,
      "deletions": 87,
      "changes": 172,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-s12z.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-s12z.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-s12z.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -23,9 +23,7 @@\n #include \"subsegs.h\"\n #include \"dwarf2dbg.h\"\n #include \"opcode/s12z.h\"\n-#include <stdint.h>\n #include <limits.h>\n-#include <stdbool.h>\n \n const char comment_chars[] = \";\";\n \n@@ -164,7 +162,7 @@ md_parse_option (int c, const char *arg)\n       register_prefix = xstrdup (arg);\n       break;\n     case OPTION_DOLLAR_HEX:\n-      literal_prefix_dollar_hex = TRUE;\n+      literal_prefix_dollar_hex = true;\n       break;\n     default:\n       return 0;\n@@ -181,7 +179,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n valueT\n@@ -200,7 +198,7 @@ void\n s12z_init_after_args (void)\n {\n   if (flag_traditional_format)\n-    literal_prefix_dollar_hex = TRUE;\n+    literal_prefix_dollar_hex = true;\n }\n \f\n /* Builtin help.  */\n@@ -231,9 +229,9 @@ s12z_new_insn (int size)\n \n \f\n \n-static bfd_boolean lex_reg_name (uint16_t which, int *reg);\n+static bool lex_reg_name (uint16_t which, int *reg);\n \n-static bfd_boolean\n+static bool\n lex_constant (long *v)\n {\n   char *end = NULL;\n@@ -259,7 +257,7 @@ lex_constant (long *v)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n lex_match (char x)\n {\n   char *p = input_line_pointer;\n@@ -271,7 +269,7 @@ lex_match (char x)\n }\n \n \n-static bfd_boolean\n+static bool\n lex_expression (expressionS *exp)\n {\n   char *ilp = input_line_pointer;\n@@ -298,7 +296,7 @@ lex_expression (expressionS *exp)\n    If EXP_O is non-null, then a symbolic expression is permitted,\n    in which case, EXP_O will be populated with the parsed expression.\n  */\n-static bfd_boolean\n+static bool\n lex_imm (long *v, expressionS *exp_o)\n {\n   char *ilp = input_line_pointer;\n@@ -329,7 +327,7 @@ lex_imm (long *v, expressionS *exp_o)\n }\n \n /* Short mmediate operand */\n-static bfd_boolean\n+static bool\n lex_imm_e4 (long *val)\n {\n   char *ilp = input_line_pointer;\n@@ -345,7 +343,7 @@ lex_imm_e4 (long *val)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n lex_match_string (const char *s)\n {\n   char *p = input_line_pointer;\n@@ -373,7 +371,7 @@ lex_match_string (const char *s)\n    On success, REG will be filled with the index of the register which\n    was successfully scanned.\n */\n-static bfd_boolean\n+static bool\n lex_reg_name (uint16_t which, int *reg)\n {\n   char *p = input_line_pointer;\n@@ -425,7 +423,7 @@ lex_reg_name (uint16_t which, int *reg)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n lex_force_match (char x)\n {\n   char *p = input_line_pointer;\n@@ -439,7 +437,7 @@ lex_force_match (char x)\n   return true;\n }\n \n-static bfd_boolean\n+static bool\n lex_opr (uint8_t *buffer, int *n_bytes, expressionS *exp,\n \t bool immediate_ok)\n {\n@@ -751,7 +749,7 @@ lex_opr (uint8_t *buffer, int *n_bytes, expressionS *exp,\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n lex_offset (long *val)\n {\n   char *end = NULL;\n@@ -783,7 +781,7 @@ lex_offset (long *val)\n \n struct instruction;\n \n-typedef bfd_boolean (*parse_operand_func) (const struct instruction *);\n+typedef bool (*parse_operand_func) (const struct instruction *);\n \n struct instruction\n {\n@@ -805,7 +803,7 @@ struct instruction\n   uint8_t alt_opc;\n };\n \n-static bfd_boolean\n+static bool\n no_operands (const struct instruction *insn)\n {\n   if (*input_line_pointer != '\\0')\n@@ -833,7 +831,7 @@ emit_reloc (expressionS *exp, char *f, int size, enum bfd_reloc_code_real reloc)\n \t\t\t       f - frag_now->fr_literal,\n \t\t\t       size,\n \t\t\t       exp,\n-\t\t\t       FALSE,\n+\t\t\t       false,\n                                reloc);\n       /* Some third party tools seem to use the lower bits\n          of this addend for flags.   They don't get added\n@@ -867,7 +865,7 @@ emit_ext24 (char *f, long v)\n   return f + 3;\n }\n \n-static bfd_boolean \n+static bool\n opr (const struct instruction *insn)\n {\n   uint8_t buffer[4];\n@@ -906,7 +904,7 @@ opr (const struct instruction *insn)\n /* Parse a 15 bit offset, as an expression.\n    LONG_DISPLACEMENT will be set to true if the offset is wider than 7 bits.\n    */\n-static bfd_boolean\n+static bool\n lex_15_bit_offset (bool *long_displacement, expressionS *exp)\n {\n   char *ilp = input_line_pointer;\n@@ -964,7 +962,7 @@ emit_15_bit_offset (char *f, int where, expressionS *exp)\n \t\t   f - frag_now->fr_literal,\n \t\t   2,\n \t\t   exp,\n-\t\t   TRUE,\n+\t\t   true,\n \t\t   BFD_RELOC_16_PCREL);\n       fix->fx_addnumber = where - 2;\n     }\n@@ -981,7 +979,7 @@ emit_15_bit_offset (char *f, int where, expressionS *exp)\n     }\n }\n \n-static bfd_boolean\n+static bool\n rel (const struct instruction *insn)\n {\n   bool long_displacement;\n@@ -996,7 +994,7 @@ rel (const struct instruction *insn)\n   return true;\n }\n \n-static bfd_boolean\n+static bool\n reg_inh (const struct instruction *insn)\n {\n   int reg;\n@@ -1015,7 +1013,7 @@ reg_inh (const struct instruction *insn)\n \n \n /* Special case for CLR X and CLR Y */\n-static bfd_boolean\n+static bool\n clr_xy (const struct instruction *insn ATTRIBUTE_UNUSED)\n {\n   int reg;\n@@ -1061,7 +1059,7 @@ size_from_suffix  (const struct instruction *insn, int idx)\n   return size;\n }\n \n-static bfd_boolean\n+static bool\n mul_reg_reg_reg (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1118,7 +1116,7 @@ mul_reg_reg_reg (const struct instruction *insn)\n }\n \n \n-static bfd_boolean\n+static bool\n mul_reg_reg_imm (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1179,7 +1177,7 @@ mul_reg_reg_imm (const struct instruction *insn)\n }\n \n \n-static bfd_boolean\n+static bool\n mul_reg_reg_opr (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1241,7 +1239,7 @@ mul_reg_reg_opr (const struct instruction *insn)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n mul_reg_opr_opr (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1342,7 +1340,7 @@ static const uint8_t reg_map [] =\n     0x00\n   };\n \n-static bfd_boolean\n+static bool\n lex_reg_list (uint16_t grp, uint16_t *reg_bits)\n {\n   if (lex_match (','))\n@@ -1358,7 +1356,7 @@ lex_reg_list (uint16_t grp, uint16_t *reg_bits)\n   return true;\n }\n \n-static bfd_boolean\n+static bool\n psh_pull (const struct instruction *insn)\n {\n   uint8_t pb =\n@@ -1410,7 +1408,7 @@ psh_pull (const struct instruction *insn)\n }\n \n \n-static bfd_boolean\n+static bool\n tfr (const struct instruction *insn)\n {\n   int reg1;\n@@ -1446,7 +1444,7 @@ tfr (const struct instruction *insn)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n imm8 (const struct instruction *insn)\n {\n   long imm;\n@@ -1465,7 +1463,7 @@ imm8 (const struct instruction *insn)\n   return true;\n }\n \n-static bfd_boolean\n+static bool\n reg_imm (const struct instruction *insn, int allowed_reg)\n {\n   char *ilp = input_line_pointer;\n@@ -1495,26 +1493,26 @@ reg_imm (const struct instruction *insn, int allowed_reg)\n }\n \n \n-static bfd_boolean\n+static bool\n regd_imm (const struct instruction *insn)\n {\n   return reg_imm (insn, REG_BIT_Dn);\n }\n \n-static bfd_boolean\n+static bool\n regdxy_imm (const struct instruction *insn)\n {\n   return reg_imm (insn, REG_BIT_Dn | REG_BIT_XY);\n }\n \n \n-static bfd_boolean\n+static bool\n regs_imm (const struct instruction *insn)\n {\n   return reg_imm (insn, 0x1U << REG_S);\n }\n \n-static bfd_boolean\n+static bool\n trap_imm (const struct instruction *insn ATTRIBUTE_UNUSED)\n {\n   long imm = -1;\n@@ -1546,7 +1544,7 @@ trap_imm (const struct instruction *insn ATTRIBUTE_UNUSED)\n \n \n /* Special one byte instruction CMP X, Y */\n-static bfd_boolean\n+static bool\n regx_regy (const struct instruction *insn)\n {\n   int reg;\n@@ -1566,7 +1564,7 @@ regx_regy (const struct instruction *insn)\n }\n \n /* Special one byte instruction SUB D6, X, Y */\n-static bfd_boolean\n+static bool\n regd6_regx_regy (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1597,7 +1595,7 @@ regd6_regx_regy (const struct instruction *insn)\n }\n \n /* Special one byte instruction SUB D6, Y, X */\n-static bfd_boolean\n+static bool\n regd6_regy_regx (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1627,7 +1625,7 @@ regd6_regy_regx (const struct instruction *insn)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n reg_opr (const struct instruction *insn, int allowed_regs,\n \t bool immediate_ok)\n {\n@@ -1681,41 +1679,41 @@ reg_opr (const struct instruction *insn, int allowed_regs,\n }\n \n \n-static bfd_boolean\n+static bool\n regdxy_opr_dest (const struct instruction *insn)\n {\n   return reg_opr (insn, REG_BIT_Dn | REG_BIT_XY, false);\n }\n \n-static bfd_boolean\n+static bool\n regdxy_opr_src (const struct instruction *insn)\n {\n   return reg_opr (insn, REG_BIT_Dn | REG_BIT_XY, true);\n }\n \n \n-static bfd_boolean\n+static bool\n regd_opr (const struct instruction *insn)\n {\n   return reg_opr (insn, REG_BIT_Dn, true);\n }\n \n \n /* OP0: S; OP1: destination OPR */\n-static bfd_boolean\n+static bool\n regs_opr_dest (const struct instruction *insn)\n {\n   return reg_opr (insn, 0x1U << REG_S, false);\n }\n \n /* OP0: S; OP1: source OPR */\n-static bfd_boolean\n+static bool\n regs_opr_src (const struct instruction *insn)\n {\n   return reg_opr (insn, 0x1U << REG_S, true);\n }\n \n-static bfd_boolean\n+static bool\n imm_opr  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1763,7 +1761,7 @@ imm_opr  (const struct instruction *insn)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n opr_opr  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1798,7 +1796,7 @@ opr_opr  (const struct instruction *insn)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n reg67sxy_opr  (const struct instruction *insn)\n {\n   int reg;\n@@ -1821,7 +1819,7 @@ reg67sxy_opr  (const struct instruction *insn)\n   return true;\n }\n \n-static bfd_boolean\n+static bool\n rotate  (const struct instruction *insn, short dir)\n {\n   uint8_t buffer[4];\n@@ -1847,13 +1845,13 @@ rotate  (const struct instruction *insn, short dir)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n rol  (const struct instruction *insn)\n {\n   return rotate (insn, 1);\n }\n \n-static bfd_boolean\n+static bool\n ror  (const struct instruction *insn)\n {\n   return rotate (insn, 0);\n@@ -1864,7 +1862,7 @@ ror  (const struct instruction *insn)\n    left = 1; right = 0;\n    logical = 0; arithmetic = 1;\n */\n-static bfd_boolean\n+static bool\n lex_shift_reg_imm1  (const struct instruction *insn, short type, short dir)\n {\n   /*\n@@ -1925,7 +1923,7 @@ lex_shift_reg_imm1  (const struct instruction *insn, short type, short dir)\n /* Shift instruction with a register operand.\n    left = 1; right = 0;\n    logical = 0; arithmetic = 1; */\n-static bfd_boolean\n+static bool\n lex_shift_reg  (const struct instruction *insn, short type, short dir)\n {\n   int Dd, Ds, Dn;\n@@ -2031,7 +2029,7 @@ impute_shift_dir_and_type (const struct instruction *insn, short *type, short *d\n }\n \n /* Shift instruction with a OPR operand */\n-static bfd_boolean\n+static bool\n shift_two_operand  (const struct instruction *insn)\n {\n   uint8_t sb = 0x34;\n@@ -2079,7 +2077,7 @@ shift_two_operand  (const struct instruction *insn)\n }\n \n /* Shift instruction with a OPR operand */\n-static bfd_boolean\n+static bool\n shift_opr_imm  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2176,7 +2174,7 @@ shift_opr_imm  (const struct instruction *insn)\n }\n \n /* Shift instruction with a register operand */\n-static bfd_boolean\n+static bool\n shift_reg  (const struct instruction *insn)\n {\n   short dir = -1;\n@@ -2189,7 +2187,7 @@ shift_reg  (const struct instruction *insn)\n   return lex_shift_reg (insn, type, dir);\n }\n \n-static bfd_boolean\n+static bool\n bm_regd_imm  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2220,7 +2218,7 @@ bm_regd_imm  (const struct instruction *insn)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n bm_opr_reg  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2259,7 +2257,7 @@ bm_opr_reg  (const struct instruction *insn)\n }\n \n \n-static bfd_boolean\n+static bool\n bm_opr_imm  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2310,7 +2308,7 @@ bm_opr_imm  (const struct instruction *insn)\n }\n \n \n-static bfd_boolean\n+static bool\n bm_regd_reg  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2347,7 +2345,7 @@ bm_regd_reg  (const struct instruction *insn)\n \f\n \n \n-static bfd_boolean\n+static bool\n bf_reg_opr_imm  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2417,7 +2415,7 @@ bf_reg_opr_imm  (const struct instruction *insn, short ie)\n }\n \n \n-static bfd_boolean\n+static bool\n bf_opr_reg_imm  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2487,7 +2485,7 @@ bf_opr_reg_imm  (const struct instruction *insn, short ie)\n \n \n \n-static bfd_boolean\n+static bool\n bf_reg_reg_imm  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2550,7 +2548,7 @@ bf_reg_reg_imm  (const struct instruction *insn, short ie)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n bf_reg_reg_reg  (const struct instruction *insn ATTRIBUTE_UNUSED, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2593,7 +2591,7 @@ bf_reg_reg_reg  (const struct instruction *insn ATTRIBUTE_UNUSED, short ie)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n bf_opr_reg_reg  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2646,7 +2644,7 @@ bf_opr_reg_reg  (const struct instruction *insn, short ie)\n }\n \n \n-static bfd_boolean\n+static bool\n bf_reg_opr_reg  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2698,75 +2696,75 @@ bf_reg_opr_reg  (const struct instruction *insn, short ie)\n \n \n \n-static bfd_boolean\n+static bool\n bfe_reg_reg_reg  (const struct instruction *insn)\n {\n   return bf_reg_reg_reg (insn, 0);\n }\n \n-static bfd_boolean\n+static bool\n bfi_reg_reg_reg  (const struct instruction *insn)\n {\n   return bf_reg_reg_reg (insn, 1);\n }\n \n-static bfd_boolean\n+static bool\n bfe_reg_reg_imm  (const struct instruction *insn)\n {\n   return bf_reg_reg_imm (insn, 0);\n }\n \n-static bfd_boolean\n+static bool\n bfi_reg_reg_imm  (const struct instruction *insn)\n {\n   return bf_reg_reg_imm (insn, 1);\n }\n \n \n-static bfd_boolean\n+static bool\n bfe_reg_opr_reg  (const struct instruction *insn)\n {\n   return bf_reg_opr_reg (insn, 0);\n }\n \n-static bfd_boolean\n+static bool\n bfi_reg_opr_reg  (const struct instruction *insn)\n {\n   return bf_reg_opr_reg (insn, 1);\n }\n \n \n-static bfd_boolean\n+static bool\n bfe_opr_reg_reg  (const struct instruction *insn)\n {\n   return bf_opr_reg_reg (insn, 0);\n }\n \n-static bfd_boolean\n+static bool\n bfi_opr_reg_reg  (const struct instruction *insn)\n {\n   return bf_opr_reg_reg (insn, 1);\n }\n \n-static bfd_boolean\n+static bool\n bfe_reg_opr_imm  (const struct instruction *insn)\n {\n   return bf_reg_opr_imm (insn, 0);\n }\n \n-static bfd_boolean\n+static bool\n bfi_reg_opr_imm  (const struct instruction *insn)\n {\n   return bf_reg_opr_imm (insn, 1);\n }\n \n-static bfd_boolean\n+static bool\n bfe_opr_reg_imm  (const struct instruction *insn)\n {\n   return bf_opr_reg_imm (insn, 0);\n }\n \n-static bfd_boolean\n+static bool\n bfi_opr_reg_imm  (const struct instruction *insn)\n {\n   return bf_opr_reg_imm (insn, 1);\n@@ -2775,7 +2773,7 @@ bfi_opr_reg_imm  (const struct instruction *insn)\n \f\n \n \n-static bfd_boolean\n+static bool\n tb_reg_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2844,7 +2842,7 @@ tb_reg_rel  (const struct instruction *insn)\n }\n \n \n-static bfd_boolean\n+static bool\n tb_opr_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2912,7 +2910,7 @@ tb_opr_rel  (const struct instruction *insn)\n \f\n \n \n-static bfd_boolean\n+static bool\n test_br_reg_reg_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2959,7 +2957,7 @@ test_br_reg_reg_rel  (const struct instruction *insn)\n   return false;\n }\n \n-static bfd_boolean\n+static bool\n test_br_opr_reg_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -3008,7 +3006,7 @@ test_br_opr_reg_rel  (const struct instruction *insn)\n }\n \n \n-static bfd_boolean\n+static bool\n test_br_opr_imm_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -3063,7 +3061,7 @@ test_br_opr_imm_rel  (const struct instruction *insn)\n }\n \n \n-static bfd_boolean\n+static bool\n test_br_reg_imm_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -3919,7 +3917,7 @@ tc_s12z_force_relocation (fixS *fixP)\n    we need to make sure that the linker relaxation is done\n    correctly, so in some cases we force the original symbol to be\n    used.  */\n-bfd_boolean\n+bool\n tc_s12z_fix_adjustable (fixS *fixP ATTRIBUTE_UNUSED)\n {\n   return true;"
    },
    {
      "sha": "d33fba15425a96ff3a54d6d551a891a20683e4d6",
      "filename": "gas/config/tc-s12z.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-s12z.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-s12z.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-s12z.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -91,7 +91,7 @@ extern long s12z_relax_frag (segT, fragS*, long);\n extern int tc_s12z_force_relocation (struct fix *);\n \n #define tc_fix_adjustable(X) tc_s12z_fix_adjustable(X)\n-extern bfd_boolean tc_s12z_fix_adjustable (struct fix *);\n+extern bool tc_s12z_fix_adjustable (struct fix *);\n \n #define md_operand(x)\n "
    },
    {
      "sha": "564418e4c1c4f2def2893b1edf9a90717cc2a92c",
      "filename": "gas/config/tc-s390.c",
      "status": "modified",
      "additions": 32,
      "deletions": 32,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-s390.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -48,17 +48,17 @@ static unsigned int current_mode_mask = 0;\n \n /* Set to TRUE if the highgprs flag in the ELF header needs to be set\n    for the output file.  */\n-static bfd_boolean set_highgprs_p = FALSE;\n+static bool set_highgprs_p = false;\n \n /* Whether to use user friendly register names. Default is TRUE.  */\n #ifndef TARGET_REG_NAMES_P\n-#define TARGET_REG_NAMES_P TRUE\n+#define TARGET_REG_NAMES_P true\n #endif\n \n-static bfd_boolean reg_names_p = TARGET_REG_NAMES_P;\n+static bool reg_names_p = TARGET_REG_NAMES_P;\n \n /* Set to TRUE if we want to warn about zero base/index registers.  */\n-static bfd_boolean warn_areg_zero = FALSE;\n+static bool warn_areg_zero = false;\n \n /* Generic assembler global variables which must be defined by all\n    targets.  */\n@@ -156,7 +156,7 @@ reg_name_search (const char *name)\n  *      original state.\n  */\n \n-static bfd_boolean\n+static bool\n register_name (expressionS *expressionP)\n {\n   int reg_number;\n@@ -169,7 +169,7 @@ register_name (expressionS *expressionP)\n   if (name[0] == '%' && ISALPHA (name[1]))\n     name = ++input_line_pointer;\n   else\n-    return FALSE;\n+    return false;\n \n   c = get_symbol_name (&name);\n   reg_number = reg_name_search (name);\n@@ -186,12 +186,12 @@ register_name (expressionS *expressionP)\n       /* Make the rest nice.  */\n       expressionP->X_add_symbol = NULL;\n       expressionP->X_op_symbol = NULL;\n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n-  return FALSE;\n+  return false;\n }\n \n /* Local variables.  */\n@@ -264,9 +264,9 @@ s390_target_format (void)\n    In case of an error, S390_OPCODE_MAXCPU is returned.  */\n \n static unsigned int\n-s390_parse_cpu (const char *         arg,\n-\t\tunsigned int * ret_flags,\n-\t\tbfd_boolean    allow_extensions)\n+s390_parse_cpu (const char *arg,\n+\t\tunsigned int *ret_flags,\n+\t\tbool allow_extensions)\n {\n   static struct\n   {\n@@ -298,15 +298,15 @@ s390_parse_cpu (const char *         arg,\n   };\n   static struct\n   {\n-    const char * name;\n+    const char *name;\n     unsigned int mask;\n-    bfd_boolean  on;\n+    bool on;\n   } cpu_flags[] =\n   {\n-    { \"htm\",   S390_INSTR_FLAG_HTM, TRUE },\n-    { \"nohtm\", S390_INSTR_FLAG_HTM, FALSE },\n-    { \"vx\",    S390_INSTR_FLAG_VX, TRUE },\n-    { \"novx\",  S390_INSTR_FLAG_VX, FALSE }\n+    { \"htm\",   S390_INSTR_FLAG_HTM, true },\n+    { \"nohtm\", S390_INSTR_FLAG_HTM, false },\n+    { \"vx\",    S390_INSTR_FLAG_VX, true },\n+    { \"novx\",  S390_INSTR_FLAG_VX, false }\n   };\n   unsigned int icpu;\n   char *ilp_bak;\n@@ -403,13 +403,13 @@ md_parse_option (int c, const char *arg)\n       break;\n     case 'm':\n       if (arg != NULL && strcmp (arg, \"regnames\") == 0)\n-\treg_names_p = TRUE;\n+\treg_names_p = true;\n \n       else if (arg != NULL && strcmp (arg, \"no-regnames\") == 0)\n-\treg_names_p = FALSE;\n+\treg_names_p = false;\n \n       else if (arg != NULL && strcmp (arg, \"warn-areg-zero\") == 0)\n-\twarn_areg_zero = TRUE;\n+\twarn_areg_zero = true;\n \n       else if (arg != NULL && strcmp (arg, \"31\") == 0)\n \ts390_arch_size = 32;\n@@ -423,13 +423,13 @@ md_parse_option (int c, const char *arg)\n       else if (arg != NULL && strcmp (arg, \"zarch\") == 0)\n \t{\n \t  if (s390_arch_size == 32)\n-\t    set_highgprs_p = TRUE;\n+\t    set_highgprs_p = true;\n \t  current_mode_mask = 1 << S390_OPCODE_ZARCH;\n \t}\n \n       else if (arg != NULL && strncmp (arg, \"arch=\", 5) == 0)\n \t{\n-\t  current_cpu = s390_parse_cpu (arg + 5, &current_flags, FALSE);\n+\t  current_cpu = s390_parse_cpu (arg + 5, &current_flags, false);\n \t  if (current_cpu == S390_OPCODE_MAXCPU)\n \t    {\n \t      as_bad (_(\"invalid switch -m%s\"), arg);\n@@ -495,7 +495,7 @@ s390_setup_opcodes (void)\n {\n   const struct s390_opcode *op;\n   const struct s390_opcode *op_end;\n-  bfd_boolean dup_insn = FALSE;\n+  bool dup_insn = false;\n \n   if (s390_opcode_hash != NULL)\n     htab_delete (s390_opcode_hash);\n@@ -536,7 +536,7 @@ s390_setup_opcodes (void)\n \t  && str_hash_insert (s390_opcode_hash, op->name, op, 0) != NULL)\n \t{\n \t  as_bad (_(\"duplicate %s\"), op->name);\n-\t  dup_insn = TRUE;\n+\t  dup_insn = true;\n \t}\n \n       while (op < op_end - 1 && strcmp (op->name, op[1].name) == 0)\n@@ -1208,7 +1208,7 @@ s390_elf_cons (int nbytes /* 1=.byte, 2=.word, 4=.long */)\n \t      /* To make fixup_segment do the pc relative conversion the\n \t\t pcrel parameter on the fix_new_exp call needs to be FALSE.  */\n \t      fix_new_exp (frag_now, where - frag_now->fr_literal,\n-\t\t\t   size, &exp, FALSE, reloc);\n+\t\t\t   size, &exp, false, reloc);\n \t    }\n \t  else\n \t    as_bad (_(\"relocation not applicable\"));\n@@ -1224,20 +1224,20 @@ s390_elf_cons (int nbytes /* 1=.byte, 2=.word, 4=.long */)\n \n /* Return true if all remaining operands in the opcode with\n    OPCODE_FLAGS can be skipped.  */\n-static bfd_boolean\n+static bool\n skip_optargs_p (unsigned int opcode_flags, const unsigned char *opindex_ptr)\n {\n   if ((opcode_flags & (S390_INSTR_FLAG_OPTPARM | S390_INSTR_FLAG_OPTPARM2))\n       && opindex_ptr[0] != '\\0'\n       && opindex_ptr[1] == '\\0')\n-    return TRUE;\n+    return true;\n \n   if ((opcode_flags & S390_INSTR_FLAG_OPTPARM2)\n       && opindex_ptr[0] != '\\0'\n       && opindex_ptr[1] != '\\0'\n       && opindex_ptr[2] == '\\0')\n-    return TRUE;\n-  return FALSE;\n+    return true;\n+  return false;\n }\n \n /* We need to keep a list of fixups.  We can't simply generate them as\n@@ -1977,7 +1977,7 @@ s390_machine (int ignore ATTRIBUTE_UNUSED)\n \t    }\n \t}\n       else\n-\tnew_cpu = s390_parse_cpu (cpu_string, &new_flags, TRUE);\n+\tnew_cpu = s390_parse_cpu (cpu_string, &new_flags, true);\n \n       if (new_cpu == S390_OPCODE_MAXCPU)\n \tas_bad (_(\"invalid machine `%s'\"), cpu_string);\n@@ -2047,7 +2047,7 @@ s390_machinemode (int ignore ATTRIBUTE_UNUSED)\n \t  else if (strcmp (mode_string, \"zarch\") == 0)\n \t    {\n \t      if (s390_arch_size == 32)\n-\t\tset_highgprs_p = TRUE;\n+\t\tset_highgprs_p = true;\n \t      current_mode_mask = 1 << S390_OPCODE_ZARCH;\n \t    }\n \t  else if (strcmp (mode_string, \"zarch_nohighgprs\") == 0)\n@@ -2068,7 +2068,7 @@ s390_machinemode (int ignore ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litp, int *sizep)\n {\n-  return ieee_md_atof (type, litp, sizep, TRUE);\n+  return ieee_md_atof (type, litp, sizep, true);\n }\n \n /* Align a section (I don't know why this is machine dependent).  */"
    },
    {
      "sha": "7252e7ad5a44316bb6439da0b30dab1d49c78419",
      "filename": "gas/config/tc-score.c",
      "status": "modified",
      "additions": 55,
      "deletions": 55,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-score.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-score.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-score.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -65,7 +65,7 @@ static const char *s3_atof (int type, char *litP, int *sizeP);\n static void s3_frag_check (fragS * fragp ATTRIBUTE_UNUSED);\n static void s3_validate_fix (fixS *fixP);\n static int s3_force_relocation (struct fix *fixp);\n-static bfd_boolean s3_fix_adjustable (fixS * fixP);\n+static bool s3_fix_adjustable (fixS * fixP);\n static void s3_elf_final_processing (void);\n static int s3_estimate_size_before_relax (fragS * fragp, asection * sec ATTRIBUTE_UNUSED);\n static int s3_relax_frag (asection * sec ATTRIBUTE_UNUSED, fragS * fragp, long stretch ATTRIBUTE_UNUSED);\n@@ -2544,7 +2544,7 @@ static void\n s3_gen_insn_frag (struct s3_score_it *part_1, struct s3_score_it *part_2)\n {\n   char *p;\n-  bfd_boolean pce_p = FALSE;\n+  bool pce_p = false;\n   int relaxable_p = s3_g_opt;\n   int relax_size = 0;\n   struct s3_score_it *inst1 = part_1;\n@@ -2643,7 +2643,7 @@ s3_gen_insn_frag (struct s3_score_it *part_1, struct s3_score_it *part_2)\n }\n \n static void\n-s3_parse_16_32_inst (char *insnstr, bfd_boolean gen_frag_p)\n+s3_parse_16_32_inst (char *insnstr, bool gen_frag_p)\n {\n   char c;\n   char *p;\n@@ -2693,7 +2693,7 @@ s3_parse_16_32_inst (char *insnstr, bfd_boolean gen_frag_p)\n }\n \n static void\n-s3_parse_48_inst (char *insnstr, bfd_boolean gen_frag_p)\n+s3_parse_48_inst (char *insnstr, bool gen_frag_p)\n {\n   char c;\n   char *p;\n@@ -2740,7 +2740,7 @@ s3_parse_48_inst (char *insnstr, bfd_boolean gen_frag_p)\n }\n \n static int\n-s3_append_insn (char *str, bfd_boolean gen_frag_p)\n+s3_append_insn (char *str, bool gen_frag_p)\n {\n   int retval = s3_SUCCESS;\n \n@@ -4099,7 +4099,7 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n          For an external symbol: lw rD, <sym>($gp)\n \t (BFD_RELOC_SCORE_GOT15 or BFD_RELOC_SCORE_CALL15)  */\n       sprintf (tmp, \"lw_pic r%d, %s\", reg_rd, S_GET_NAME (add_symbol));\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n \treturn;\n \n       if (reg_rd == s3_PIC_CALL_REG)\n@@ -4113,7 +4113,7 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n       s3_inst.reloc.type = BFD_RELOC_SCORE_GOT15;\n       memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));\n       sprintf (tmp, \"addi_s_pic r%d, %s\", reg_rd, S_GET_NAME (add_symbol));\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n \treturn;\n \n       memcpy (&var_insts[1], &s3_inst, sizeof (struct s3_score_it));\n@@ -4123,7 +4123,7 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n     {\n       /* Insn 1: lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */\n       sprintf (tmp, \"lw_pic r%d, %s\", reg_rd, S_GET_NAME (add_symbol));\n-      if (s3_append_insn (tmp, TRUE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, true) == (int) s3_FAIL)\n \treturn;\n \n       /* Insn 2  */\n@@ -4132,7 +4132,7 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n       /* Fix part\n          For an external symbol: addi rD, <constant> */\n       sprintf (tmp, \"addi r%d, %d\", reg_rd, (int)add_number);\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n \treturn;\n \n       memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));\n@@ -4141,7 +4141,7 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n  \t For a local symbol: addi rD, <sym>+<constant>    (BFD_RELOC_GOT_LO16)  */\n       sprintf (tmp, \"addi_s_pic r%d, %s + %d\", reg_rd,\n \t       S_GET_NAME (add_symbol), (int) add_number);\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n \treturn;\n \n       memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));\n@@ -4154,7 +4154,7 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n \n       /* Insn 1: lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */\n       sprintf (tmp, \"lw_pic r%d, %s\", reg_rd, S_GET_NAME (add_symbol));\n-      if (s3_append_insn (tmp, TRUE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, true) == (int) s3_FAIL)\n \treturn;\n \n       /* Insn 2  */\n@@ -4163,7 +4163,7 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n       /* Fix part\n \t For an external symbol: ldis r1, HI%<constant>  */\n       sprintf (tmp, \"ldis r1, %d\", hi);\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n \treturn;\n \n       memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));\n@@ -4176,7 +4176,7 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n \t  hi += 1;\n \t}\n       sprintf (tmp, \"ldis_pic r1, %d\", hi);\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n \treturn;\n \n       memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));\n@@ -4188,23 +4188,23 @@ s3_build_la_pic (int reg_rd, expressionS exp)\n       /* Fix part\n \t For an external symbol: ori r1, LO%<constant>  */\n       sprintf (tmp, \"ori r1, %d\", lo);\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n \treturn;\n \n       memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));\n \n       /* Var part\n   \t For a local symbol: addi r1, <sym>+LO%<constant>    (BFD_RELOC_GOT_LO16)  */\n       sprintf (tmp, \"addi_u_pic r1, %s + %d\", S_GET_NAME (add_symbol), lo);\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n \treturn;\n \n       memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));\n       s3_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);\n \n       /* Insn 4: add rD, rD, r1  */\n       sprintf (tmp, \"add r%d, r%d, r1\", reg_rd, reg_rd);\n-      if (s3_append_insn (tmp, TRUE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, true) == (int) s3_FAIL)\n \treturn;\n \n       /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -4270,11 +4270,11 @@ s3_do_macro_la_rdi32 (char *str)\n               if ((s3_score_pic == s3_NO_PIC) || (!s3_inst.reloc.exp.X_add_symbol))\n                 {\n                   sprintf (append_str, \"ld_i32hi r%d, %s\", reg_rd, keep_data);\n-                  if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+                  if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t\t    return;\n \n                   sprintf (append_str, \"ld_i32lo r%d, %s\", reg_rd, keep_data);\n-                  if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+                  if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t\t    return;\n \t\t}\n \t      else\n@@ -4352,12 +4352,12 @@ s3_do_macro_li_rdi32 (char *str)\n             {\n               sprintf (append_str, \"ld_i32hi r%d, %s\", reg_rd, keep_data);\n \n-              if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+              if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t\treturn;\n               else\n                 {\n                   sprintf (append_str, \"ld_i32lo r%d, %s\", reg_rd, keep_data);\n-                  if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+                  if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t\t    return;\n \n                   /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -4435,11 +4435,11 @@ s3_do_macro_mul_rdrsrs (char *str)\n             }\n \n           /* Output mul/mulu or div/divu or rem/remu.  */\n-          if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+          if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t    return;\n \n           /* Output mfcel or mfceh.  */\n-          if (s3_append_insn (append_str1, TRUE) == (int) s3_FAIL)\n+          if (s3_append_insn (append_str1, true) == (int) s3_FAIL)\n \t    return;\n \n           /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -4474,7 +4474,7 @@ s3_exp_macro_ldst_abs (char *str)\n \n   backupstr = tmp;\n   sprintf (append_str, \"li r1  %s\", backupstr);\n-  s3_append_insn (append_str, TRUE);\n+  s3_append_insn (append_str, true);\n \n   memcpy (&s3_inst, &inst_backup, sizeof (struct s3_score_it));\n   sprintf (append_str, \" r%d, [r1,0]\", reg_rd);\n@@ -4537,14 +4537,14 @@ s3_do_macro_bcmp (char *str)\n           if (s3_score_pic == s3_NO_PIC)\n             {\n \t      sprintf (append_str, \"cmp! r%d, r%d\", reg_a, reg_b);\n-\t      if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+\t      if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t\tgoto out;\n \t      if ((inst_main.instruction & 0x3e00007e) == 0x0000004c)\n \t\tmemcpy (append_str, \"beq \", 4);\n \t      else\n \t\tmemcpy (append_str, \"bne \", 4);\n \t      memmove (append_str + 4, keep_data, strlen (keep_data) + 1);\n-\t      if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+\t      if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t\tgoto out;\n \t    }\n \t  else\n@@ -4569,7 +4569,7 @@ s3_do_macro_bcmp (char *str)\n       if (s3_score_pic == s3_NO_PIC)\n         {\n \t  sprintf (append_str, \"cmp! r%d, r%d\", reg_a, reg_b);\n-\t  if (s3_append_insn (append_str, FALSE) == (int) s3_FAIL)\n+\t  if (s3_append_insn (append_str, false) == (int) s3_FAIL)\n \t    goto out;\n \t  memcpy (&inst_expand[0], &s3_inst, sizeof (struct s3_score_it));\n \n@@ -4578,7 +4578,7 @@ s3_do_macro_bcmp (char *str)\n \t  else\n \t    memcpy (append_str, \"bne \", 4);\n \t  memmove (append_str + 4, keep_data, strlen (keep_data) + 1);\n-\t  if (s3_append_insn (append_str, FALSE) == (int) s3_FAIL)\n+\t  if (s3_append_insn (append_str, false) == (int) s3_FAIL)\n \t    goto out;\n \t  memcpy (&inst_expand[1], &s3_inst, sizeof (struct s3_score_it));\n         }\n@@ -4687,14 +4687,14 @@ s3_do_macro_bcmpz (char *str)\n           if (s3_score_pic == s3_NO_PIC)\n             {\n \t      sprintf (append_str, \"cmpi! r%d, 0\", reg_a);\n-\t      if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+\t      if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t\tgoto out;\n \t      if ((inst_main.instruction & 0x3e00007e) == 0x0000004c)\n \t\tmemcpy (append_str, \"beq \", 4);\n \t      else\n \t\tmemcpy (append_str, \"bne \", 4);\n \t      memmove (append_str + 4, keep_data, strlen (keep_data) + 1);\n-\t      if (s3_append_insn (append_str, TRUE) == (int) s3_FAIL)\n+\t      if (s3_append_insn (append_str, true) == (int) s3_FAIL)\n \t\tgoto out;\n             }\n           else\n@@ -4719,15 +4719,15 @@ s3_do_macro_bcmpz (char *str)\n       if (s3_score_pic == s3_NO_PIC)\n         {\n \t  sprintf (append_str, \"cmpi! r%d, 0\", reg_a);\n-\t  if (s3_append_insn (append_str, FALSE) == (int) s3_FAIL)\n+\t  if (s3_append_insn (append_str, false) == (int) s3_FAIL)\n \t    goto out;\n \t  memcpy (&inst_expand[0], &s3_inst, sizeof (struct s3_score_it));\n \t  if ((inst_main.instruction & 0x3e00007e) == 0x0000004c)\n \t    memcpy (append_str, \"beq \", 4);\n \t  else\n \t    memcpy (append_str, \"bne \", 4);\n \t  memmove (append_str + 4, keep_data, strlen (keep_data) + 1);\n-\t  if (s3_append_insn (append_str, FALSE) == (int) s3_FAIL)\n+\t  if (s3_append_insn (append_str, false) == (int) s3_FAIL)\n \t    goto out;\n \t  memcpy (&inst_expand[1], &s3_inst, sizeof (struct s3_score_it));\n         }\n@@ -4868,7 +4868,7 @@ s3_build_lwst_pic (int reg_rd, expressionS exp, const char *insn_name)\n          For an external symbol: lw rD, <sym>($gp)\n \t (BFD_RELOC_SCORE_GOT15)  */\n       sprintf (tmp, \"lw_pic r1, %s\", S_GET_NAME (add_symbol));\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n         return;\n \n       memcpy (&fix_insts[0], &s3_inst, sizeof (struct s3_score_it));\n@@ -4880,15 +4880,15 @@ s3_build_lwst_pic (int reg_rd, expressionS exp, const char *insn_name)\n       s3_inst.reloc.type = BFD_RELOC_SCORE_GOT15;\n       memcpy (&var_insts[0], &s3_inst, sizeof (struct s3_score_it));\n       sprintf (tmp, \"addi_s_pic r1, %s\", S_GET_NAME (add_symbol));\n-      if (s3_append_insn (tmp, FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, false) == (int) s3_FAIL)\n         return;\n \n       memcpy (&var_insts[1], &s3_inst, sizeof (struct s3_score_it));\n       s3_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);\n \n       /* Insn 2 or Insn 3: lw/st rD, [r1, constant]  */\n       sprintf (tmp, \"%s r%d, [r1, %d]\", insn_name, reg_rd, add_number);\n-      if (s3_append_insn (tmp, TRUE) == (int) s3_FAIL)\n+      if (s3_append_insn (tmp, true) == (int) s3_FAIL)\n         return;\n \n       /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -5032,7 +5032,7 @@ s3_do_macro_ldst_label (char *str)\n      ld/st rd, [r1, 0]  */\n   for (i = 0; i < 3; i++)\n     {\n-      if (s3_append_insn (append_str[i], FALSE) == (int) s3_FAIL)\n+      if (s3_append_insn (append_str[i], false) == (int) s3_FAIL)\n \treturn;\n \n       memcpy (&inst_expand[i], &s3_inst, sizeof (struct s3_score_it));\n@@ -5282,11 +5282,11 @@ s3_do16_branch (char *str)\n }\n \n /* Return true if the given symbol should be considered local for s3_PIC.  */\n-static bfd_boolean\n+static bool\n s3_pic_need_relax (symbolS *sym, asection *segtype)\n {\n   asection *symsec;\n-  bfd_boolean linkonce;\n+  bool linkonce;\n \n   /* Handle the case of a symbol equated to another symbol.  */\n   while (symbol_equated_reloc_p (sym))\n@@ -5304,18 +5304,18 @@ s3_pic_need_relax (symbolS *sym, asection *segtype)\n   symsec = S_GET_SEGMENT (sym);\n \n   /* duplicate the test for LINK_ONCE sections as in adjust_reloc_syms */\n-  linkonce = FALSE;\n+  linkonce = false;\n   if (symsec != segtype && ! S_IS_LOCAL (sym))\n     {\n       if ((bfd_section_flags (symsec) & SEC_LINK_ONCE) != 0)\n-\tlinkonce = TRUE;\n+\tlinkonce = true;\n \n       /* The GNU toolchain uses an extension for ELF: a section\n \t beginning with the magic string .gnu.linkonce is a linkonce\n \t section.  */\n       if (strncmp (segment_name (symsec), \".gnu.linkonce\",\n \t\t   sizeof \".gnu.linkonce\" - 1) == 0)\n-\tlinkonce = TRUE;\n+\tlinkonce = true;\n     }\n \n   /* This must duplicate the test in adjust_reloc_syms.  */\n@@ -5351,13 +5351,13 @@ s3_parse_pce_inst (char *insnstr)\n   p += 2;\n   sprintf (second, \"%s\", p);\n \n-  s3_parse_16_32_inst (first, FALSE);\n+  s3_parse_16_32_inst (first, false);\n   if (s3_inst.error)\n     return;\n \n   memcpy (&pec_part_1, &s3_inst, sizeof (s3_inst));\n \n-  s3_parse_16_32_inst (second, FALSE);\n+  s3_parse_16_32_inst (second, false);\n   if (s3_inst.error)\n     return;\n \n@@ -5933,15 +5933,15 @@ s3_s_score_cpload (int ignore ATTRIBUTE_UNUSED)\n   demand_empty_rest_of_line ();\n \n   sprintf (insn_str, \"ld_i32hi r%d, %s\", s3_GP, GP_DISP_LABEL);\n-  if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)\n+  if (s3_append_insn (insn_str, true) == (int) s3_FAIL)\n     return;\n \n   sprintf (insn_str, \"ld_i32lo r%d, %s\", s3_GP, GP_DISP_LABEL);\n-  if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)\n+  if (s3_append_insn (insn_str, true) == (int) s3_FAIL)\n     return;\n \n   sprintf (insn_str, \"add r%d, r%d, r%d\", s3_GP, s3_GP, reg);\n-  if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)\n+  if (s3_append_insn (insn_str, true) == (int) s3_FAIL)\n     return;\n }\n \n@@ -5973,7 +5973,7 @@ s3_s_score_cprestore (int ignore ATTRIBUTE_UNUSED)\n   if (cprestore_offset <= 0x3fff)\n     {\n       sprintf (insn_str, \"sw r%d, [r%d, %d]\", s3_GP, reg, cprestore_offset);\n-      if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)\n+      if (s3_append_insn (insn_str, true) == (int) s3_FAIL)\n         return;\n     }\n   else\n@@ -5984,15 +5984,15 @@ s3_s_score_cprestore (int ignore ATTRIBUTE_UNUSED)\n       s3_nor1 = 0;\n \n       sprintf (insn_str, \"li r1, %d\", cprestore_offset);\n-      if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)\n+      if (s3_append_insn (insn_str, true) == (int) s3_FAIL)\n         return;\n \n       sprintf (insn_str, \"add r1, r1, r%d\", reg);\n-      if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)\n+      if (s3_append_insn (insn_str, true) == (int) s3_FAIL)\n         return;\n \n       sprintf (insn_str, \"sw r%d, [r1]\", s3_GP);\n-      if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)\n+      if (s3_append_insn (insn_str, true) == (int) s3_FAIL)\n         return;\n \n       s3_nor1 = r1_bak;\n@@ -6023,7 +6023,7 @@ s3_s_score_gpword (int ignore ATTRIBUTE_UNUSED)\n     }\n   p = frag_more (4);\n   s3_md_number_to_chars (p, (valueT) 0, 4);\n-  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, FALSE, BFD_RELOC_GPREL32);\n+  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, false, BFD_RELOC_GPREL32);\n   demand_empty_rest_of_line ();\n }\n \n@@ -6050,7 +6050,7 @@ s3_s_score_cpadd (int ignore ATTRIBUTE_UNUSED)\n \n   /* Add $gp to the register named as an argument.  */\n   sprintf (insn_str, \"add r%d, r%d, r%d\", reg, reg, s3_GP);\n-  if (s3_append_insn (insn_str, TRUE) == (int) s3_FAIL)\n+  if (s3_append_insn (insn_str, true) == (int) s3_FAIL)\n     return;\n }\n \n@@ -6474,9 +6474,9 @@ s3_assemble (char *str)\n   if (s3_INSN_IS_PCE_P (str))\n     s3_parse_pce_inst (str);\n   else if (s3_INSN_IS_48_P (str))\n-    s3_parse_48_inst (str, TRUE);\n+    s3_parse_48_inst (str, true);\n   else\n-    s3_parse_16_32_inst (str, TRUE);\n+    s3_parse_16_32_inst (str, true);\n \n   if (s3_inst.error)\n     as_bad (_(\"%s -- `%s'\"), s3_inst.error, s3_inst.str);\n@@ -6723,7 +6723,7 @@ s3_force_relocation (struct fix *fixp)\n   return retval;\n }\n \n-static bfd_boolean\n+static bool\n s3_fix_adjustable (fixS * fixP)\n {\n   if (fixP->fx_addsy == NULL)\n@@ -7552,7 +7552,7 @@ score_force_relocation (struct fix *fixp)\n \n /* Implementation of md_frag_check.\n    Called after md_convert_frag().  */\n-bfd_boolean\n+bool\n score_fix_adjustable (fixS * fixP)\n {\n   if (score3)"
    },
    {
      "sha": "bfd19e3b3b4b09c6f1c80a65e1415f28ae50b89e",
      "filename": "gas/config/tc-score.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-score.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-score.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-score.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -49,7 +49,7 @@ extern void score_validate_fix (struct fix *);\n extern int score_force_relocation (struct fix *);\n \n #define tc_fix_adjustable(fixp)  score_fix_adjustable (fixp)\n-extern bfd_boolean score_fix_adjustable (struct fix *);\n+extern bool score_fix_adjustable (struct fix *);\n \n #define elf_tc_final_processing  score_elf_final_processing\n extern void score_elf_final_processing (void);"
    },
    {
      "sha": "01a1d73771d164b5f8c2e2cb525be3f61cf3a814",
      "filename": "gas/config/tc-score7.c",
      "status": "modified",
      "additions": 46,
      "deletions": 46,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-score7.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-score7.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-score7.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -2665,7 +2665,7 @@ static void\n s7_gen_insn_frag (struct s7_score_it *part_1, struct s7_score_it *part_2)\n {\n   char *p;\n-  bfd_boolean pce_p = FALSE;\n+  bool pce_p = false;\n   int relaxable_p = s7_g_opt;\n   int relax_size = 0;\n   struct s7_score_it *inst1 = part_1;\n@@ -2770,7 +2770,7 @@ s7_gen_insn_frag (struct s7_score_it *part_1, struct s7_score_it *part_2)\n }\n \n static void\n-s7_parse_16_32_inst (char *insnstr, bfd_boolean gen_frag_p)\n+s7_parse_16_32_inst (char *insnstr, bool gen_frag_p)\n {\n   char c;\n   char *p;\n@@ -2820,7 +2820,7 @@ s7_parse_16_32_inst (char *insnstr, bfd_boolean gen_frag_p)\n }\n \n static int\n-s7_append_insn (char *str, bfd_boolean gen_frag_p)\n+s7_append_insn (char *str, bool gen_frag_p)\n {\n   int retval = s7_SUCCESS;\n \n@@ -2872,7 +2872,7 @@ s7_do16_mv_rdrs (char *str)\n               char append_str[s7_MAX_LITERAL_POOL_SIZE];\n \n               sprintf (append_str, \"mlfh! %s\", backupstr);\n-              if (s7_append_insn (append_str, TRUE) == (int) s7_FAIL)\n+              if (s7_append_insn (append_str, true) == (int) s7_FAIL)\n \t\treturn;\n               /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n               s7_inst.bwarn = -1;\n@@ -2891,7 +2891,7 @@ s7_do16_mv_rdrs (char *str)\n               char append_str[s7_MAX_LITERAL_POOL_SIZE];\n \n               sprintf (append_str, \"mhfl! %s\", backupstr);\n-              if (s7_append_insn (append_str, TRUE) == (int) s7_FAIL)\n+              if (s7_append_insn (append_str, true) == (int) s7_FAIL)\n \t\treturn;\n \n               /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -4201,7 +4201,7 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n          For an external symbol: lw rD, <sym>($gp)\n                                  (BFD_RELOC_SCORE_GOT15 or BFD_RELOC_SCORE_CALL15)  */\n       sprintf (tmp, \"lw_pic r%d, %s\", reg_rd, S_GET_NAME (add_symbol));\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n \treturn;\n \n       if (reg_rd == s7_PIC_CALL_REG)\n@@ -4215,7 +4215,7 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n       s7_inst.reloc.type = BFD_RELOC_SCORE_GOT15;\n       memcpy (&var_insts[0], &s7_inst, sizeof (struct s7_score_it));\n       sprintf (tmp, \"addi_s_pic r%d, %s\", reg_rd, S_GET_NAME (add_symbol));\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n \treturn;\n \n       memcpy (&var_insts[1], &s7_inst, sizeof (struct s7_score_it));\n@@ -4225,7 +4225,7 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n     {\n       /* Insn 1: lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */\n       sprintf (tmp, \"lw_pic r%d, %s\", reg_rd, S_GET_NAME (add_symbol));\n-      if (s7_append_insn (tmp, TRUE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, true) == (int) s7_FAIL)\n \treturn;\n \n       /* Insn 2  */\n@@ -4234,7 +4234,7 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n       /* Fix part\n          For an external symbol: addi rD, <constant> */\n       sprintf (tmp, \"addi r%d, %d\", reg_rd, (int) add_number);\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n \treturn;\n \n       memcpy (&fix_insts[0], &s7_inst, sizeof (struct s7_score_it));\n@@ -4243,7 +4243,7 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n  \t For a local symbol: addi rD, <sym>+<constant>    (BFD_RELOC_GOT_LO16)  */\n       sprintf (tmp, \"addi_s_pic r%d, %s + %d\", reg_rd,\n \t       S_GET_NAME (add_symbol), (int) add_number);\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n \treturn;\n \n       memcpy (&var_insts[0], &s7_inst, sizeof (struct s7_score_it));\n@@ -4256,7 +4256,7 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n \n       /* Insn 1: lw rD, <sym>($gp)    (BFD_RELOC_SCORE_GOT15)  */\n       sprintf (tmp, \"lw_pic r%d, %s\", reg_rd, S_GET_NAME (add_symbol));\n-      if (s7_append_insn (tmp, TRUE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, true) == (int) s7_FAIL)\n \treturn;\n \n       /* Insn 2  */\n@@ -4265,7 +4265,7 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n       /* Fix part\n \t For an external symbol: ldis r1, HI%<constant>  */\n       sprintf (tmp, \"ldis r1, %d\", hi);\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n \treturn;\n \n       memcpy (&fix_insts[0], &s7_inst, sizeof (struct s7_score_it));\n@@ -4278,7 +4278,7 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n \t  hi += 1;\n \t}\n       sprintf (tmp, \"ldis_pic r1, %d\", hi);\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n \treturn;\n \n       memcpy (&var_insts[0], &s7_inst, sizeof (struct s7_score_it));\n@@ -4290,23 +4290,23 @@ s7_build_la_pic (int reg_rd, expressionS exp)\n       /* Fix part\n \t For an external symbol: ori r1, LO%<constant>  */\n       sprintf (tmp, \"ori r1, %d\", lo);\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n \treturn;\n \n       memcpy (&fix_insts[0], &s7_inst, sizeof (struct s7_score_it));\n \n       /* Var part\n   \t For a local symbol: addi r1, <sym>+LO%<constant>    (BFD_RELOC_GOT_LO16)  */\n       sprintf (tmp, \"addi_u_pic r1, %s + %d\", S_GET_NAME (add_symbol), lo);\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n \treturn;\n \n       memcpy (&var_insts[0], &s7_inst, sizeof (struct s7_score_it));\n       s7_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);\n \n       /* Insn 4: add rD, rD, r1  */\n       sprintf (tmp, \"add r%d, r%d, r1\", reg_rd, reg_rd);\n-      if (s7_append_insn (tmp, TRUE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, true) == (int) s7_FAIL)\n \treturn;\n \n      /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -4371,11 +4371,11 @@ s7_do_macro_la_rdi32 (char *str)\n               if ((s7_score_pic == s7_NO_PIC) || (!s7_inst.reloc.exp.X_add_symbol))\n                 {\n                   sprintf (append_str, \"ld_i32hi r%d, %s\", reg_rd, keep_data);\n-                  if (s7_append_insn (append_str, TRUE) == (int) s7_FAIL)\n+                  if (s7_append_insn (append_str, true) == (int) s7_FAIL)\n \t\t    return;\n \n                   sprintf (append_str, \"ld_i32lo r%d, %s\", reg_rd, keep_data);\n-                  if (s7_append_insn (append_str, TRUE) == (int) s7_FAIL)\n+                  if (s7_append_insn (append_str, true) == (int) s7_FAIL)\n \t\t    return;\n \t\t}\n \t      else\n@@ -4451,12 +4451,12 @@ s7_do_macro_li_rdi32 (char *str)\n             {\n               sprintf (append_str, \"ld_i32hi r%d, %s\", reg_rd, keep_data);\n \n-              if (s7_append_insn (append_str, TRUE) == (int) s7_FAIL)\n+              if (s7_append_insn (append_str, true) == (int) s7_FAIL)\n \t\treturn;\n               else\n                 {\n                   sprintf (append_str, \"ld_i32lo r%d, %s\", reg_rd, keep_data);\n-                  if (s7_append_insn (append_str, TRUE) == (int) s7_FAIL)\n+                  if (s7_append_insn (append_str, true) == (int) s7_FAIL)\n \t\t    return;\n \n                   /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -4535,11 +4535,11 @@ s7_do_macro_mul_rdrsrs (char *str)\n             }\n \n           /* Output mul/mulu or div/divu or rem/remu.  */\n-          if (s7_append_insn (append_str, TRUE) == (int) s7_FAIL)\n+          if (s7_append_insn (append_str, true) == (int) s7_FAIL)\n \t    return;\n \n           /* Output mfcel or mfceh.  */\n-          if (s7_append_insn (append_str1, TRUE) == (int) s7_FAIL)\n+          if (s7_append_insn (append_str1, true) == (int) s7_FAIL)\n \t    return;\n \n           /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -4574,7 +4574,7 @@ s7_exp_macro_ldst_abs (char *str)\n \n   backupstr = tmp;\n   sprintf (append_str, \"li r1  %s\", backupstr);\n-  s7_append_insn (append_str, TRUE);\n+  s7_append_insn (append_str, true);\n \n   memcpy (&s7_inst, &inst_backup, sizeof (struct s7_score_it));\n   sprintf (append_str, \" r%d, [r1,0]\", reg_rd);\n@@ -4663,7 +4663,7 @@ s7_build_lwst_pic (int reg_rd, expressionS exp, const char *insn_name)\n          For an external symbol: lw rD, <sym>($gp)\n                                  (BFD_RELOC_SCORE_GOT15)  */\n       sprintf (tmp, \"lw_pic r1, %s\", S_GET_NAME (add_symbol));\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n         return;\n \n       memcpy (&fix_insts[0], &s7_inst, sizeof (struct s7_score_it));\n@@ -4675,15 +4675,15 @@ s7_build_lwst_pic (int reg_rd, expressionS exp, const char *insn_name)\n       s7_inst.reloc.type = BFD_RELOC_SCORE_GOT15;\n       memcpy (&var_insts[0], &s7_inst, sizeof (struct s7_score_it));\n       sprintf (tmp, \"addi_s_pic r1, %s\", S_GET_NAME (add_symbol));\n-      if (s7_append_insn (tmp, FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, false) == (int) s7_FAIL)\n         return;\n \n       memcpy (&var_insts[1], &s7_inst, sizeof (struct s7_score_it));\n       s7_build_relax_frag (fix_insts, fix_num, var_insts, var_num, add_symbol);\n \n       /* Insn 2 or Insn 3: lw/st rD, [r1, constant]  */\n       sprintf (tmp, \"%s r%d, [r1, %d]\", insn_name, reg_rd, add_number);\n-      if (s7_append_insn (tmp, TRUE) == (int) s7_FAIL)\n+      if (s7_append_insn (tmp, true) == (int) s7_FAIL)\n         return;\n \n       /* Set bwarn as -1, so macro instruction itself will not be generated frag.  */\n@@ -4827,7 +4827,7 @@ s7_do_macro_ldst_label (char *str)\n      ld/st rd, [r1, 0]  */\n   for (i = 0; i < 3; i++)\n     {\n-      if (s7_append_insn (append_str[i], FALSE) == (int) s7_FAIL)\n+      if (s7_append_insn (append_str[i], false) == (int) s7_FAIL)\n \treturn;\n \n       memcpy (&inst_expand[i], &s7_inst, sizeof (struct s7_score_it));\n@@ -5164,11 +5164,11 @@ s7_md_chars_to_number (char *buf, int n)\n \n /* Return true if the given symbol should be considered local for s7_PIC.  */\n \n-static bfd_boolean\n+static bool\n s7_pic_need_relax (symbolS *sym, asection *segtype)\n {\n   asection *symsec;\n-  bfd_boolean linkonce;\n+  bool linkonce;\n \n   /* Handle the case of a symbol equated to another symbol.  */\n   while (symbol_equated_reloc_p (sym))\n@@ -5186,18 +5186,18 @@ s7_pic_need_relax (symbolS *sym, asection *segtype)\n   symsec = S_GET_SEGMENT (sym);\n \n   /* Duplicate the test for LINK_ONCE sections as in adjust_reloc_syms */\n-  linkonce = FALSE;\n+  linkonce = false;\n   if (symsec != segtype && ! S_IS_LOCAL (sym))\n     {\n       if ((bfd_section_flags (symsec) & SEC_LINK_ONCE) != 0)\n-\tlinkonce = TRUE;\n+\tlinkonce = true;\n \n       /* The GNU toolchain uses an extension for ELF: a section\n \t  beginning with the magic string .gnu.linkonce is a linkonce\n \t  section.  */\n       if (strncmp (segment_name (symsec), \".gnu.linkonce\",\n \t\t   sizeof \".gnu.linkonce\" - 1) == 0)\n-\tlinkonce = TRUE;\n+\tlinkonce = true;\n     }\n \n   /* This must duplicate the test in adjust_reloc_syms.  */\n@@ -5313,7 +5313,7 @@ s7_parse_pce_inst (char *insnstr)\n   p += 2;\n   strcpy (second, p);\n \n-  s7_parse_16_32_inst (first, FALSE);\n+  s7_parse_16_32_inst (first, false);\n   if (s7_inst.error)\n     return;\n \n@@ -5326,7 +5326,7 @@ s7_parse_pce_inst (char *insnstr)\n       q++;\n     }\n \n-  s7_parse_16_32_inst (second, FALSE);\n+  s7_parse_16_32_inst (second, false);\n   if (s7_inst.error)\n     return;\n \n@@ -5779,15 +5779,15 @@ s7_s_score_cpload (int ignore ATTRIBUTE_UNUSED)\n   demand_empty_rest_of_line ();\n \n   sprintf (insn_str, \"ld_i32hi r%d, %s\", s7_GP, GP_DISP_LABEL);\n-  if (s7_append_insn (insn_str, TRUE) == (int) s7_FAIL)\n+  if (s7_append_insn (insn_str, true) == (int) s7_FAIL)\n     return;\n \n   sprintf (insn_str, \"ld_i32lo r%d, %s\", s7_GP, GP_DISP_LABEL);\n-  if (s7_append_insn (insn_str, TRUE) == (int) s7_FAIL)\n+  if (s7_append_insn (insn_str, true) == (int) s7_FAIL)\n     return;\n \n   sprintf (insn_str, \"add r%d, r%d, r%d\", s7_GP, s7_GP, reg);\n-  if (s7_append_insn (insn_str, TRUE) == (int) s7_FAIL)\n+  if (s7_append_insn (insn_str, true) == (int) s7_FAIL)\n     return;\n }\n \n@@ -5820,7 +5820,7 @@ s7_s_score_cprestore (int ignore ATTRIBUTE_UNUSED)\n   if (cprestore_offset <= 0x3fff)\n     {\n       sprintf (insn_str, \"sw r%d, [r%d, %d]\", s7_GP, reg, cprestore_offset);\n-      if (s7_append_insn (insn_str, TRUE) == (int) s7_FAIL)\n+      if (s7_append_insn (insn_str, true) == (int) s7_FAIL)\n         return;\n     }\n   else\n@@ -5831,15 +5831,15 @@ s7_s_score_cprestore (int ignore ATTRIBUTE_UNUSED)\n       s7_nor1 = 0;\n \n       sprintf (insn_str, \"li r1, %d\", cprestore_offset);\n-      if (s7_append_insn (insn_str, TRUE) == (int) s7_FAIL)\n+      if (s7_append_insn (insn_str, true) == (int) s7_FAIL)\n         return;\n \n       sprintf (insn_str, \"add r1, r1, r%d\", reg);\n-      if (s7_append_insn (insn_str, TRUE) == (int) s7_FAIL)\n+      if (s7_append_insn (insn_str, true) == (int) s7_FAIL)\n         return;\n \n       sprintf (insn_str, \"sw r%d, [r1]\", s7_GP);\n-      if (s7_append_insn (insn_str, TRUE) == (int) s7_FAIL)\n+      if (s7_append_insn (insn_str, true) == (int) s7_FAIL)\n         return;\n \n       s7_nor1 = r1_bak;\n@@ -5871,7 +5871,7 @@ s7_s_score_gpword (int ignore ATTRIBUTE_UNUSED)\n     }\n   p = frag_more (4);\n   s7_number_to_chars (p, (valueT) 0, 4);\n-  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, FALSE, BFD_RELOC_GPREL32);\n+  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, false, BFD_RELOC_GPREL32);\n   demand_empty_rest_of_line ();\n }\n \n@@ -5899,7 +5899,7 @@ s7_s_score_cpadd (int ignore ATTRIBUTE_UNUSED)\n \n   /* Add $gp to the register named as an argument.  */\n   sprintf (insn_str, \"add r%d, r%d, r%d\", reg, reg, s7_GP);\n-  if (s7_append_insn (insn_str, TRUE) == (int) s7_FAIL)\n+  if (s7_append_insn (insn_str, true) == (int) s7_FAIL)\n     return;\n }\n \n@@ -6147,7 +6147,7 @@ s7_assemble (char *str)\n   if (s7_INSN_IS_PCE_P (str))\n     s7_parse_pce_inst (str);\n   else\n-    s7_parse_16_32_inst (str, TRUE);\n+    s7_parse_16_32_inst (str, true);\n \n   if (s7_inst.error)\n     as_bad (_(\"%s -- `%s'\"), s7_inst.error, s7_inst.str);\n@@ -6276,7 +6276,7 @@ s7_force_relocation (struct fix *fixp)\n   return retval;\n }\n \n-static bfd_boolean\n+static bool\n s7_fix_adjustable (fixS * fixP)\n {\n   if (fixP->fx_addsy == NULL)\n@@ -6342,7 +6342,7 @@ s7_relax_frag (asection * sec ATTRIBUTE_UNUSED,\n   int insn_size;\n   int do_relax_p = 0;           /* Indicate doing relaxation for this frag.  */\n   int relaxable_p = 0;\n-  bfd_boolean word_align_p = FALSE;\n+  bool word_align_p = false;\n   fragS *next_fragp;\n \n   /* If the instruction address is odd, make it half word align first.  */"
    },
    {
      "sha": "bda23b37da17035bffa9f9358e8c03bf3dd65a8e",
      "filename": "gas/config/tc-sh.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-sh.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -461,7 +461,7 @@ sh_elf_cons (int nbytes)\n /* The regular frag_offset_fixed_p doesn't work for rs_align_test\n    frags.  */\n \n-static bfd_boolean\n+static bool\n align_test_frag_offset_fixed_p (const fragS *frag1, const fragS *frag2,\n \t\t\t\tbfd_vma *offset)\n {\n@@ -474,7 +474,7 @@ align_test_frag_offset_fixed_p (const fragS *frag1, const fragS *frag2,\n   if (frag1 == frag2)\n     {\n       *offset = off;\n-      return TRUE;\n+      return true;\n     }\n \n   /* Maybe frag2 is after frag1.  */\n@@ -492,7 +492,7 @@ align_test_frag_offset_fixed_p (const fragS *frag1, const fragS *frag2,\n       if (frag == frag2)\n \t{\n \t  *offset = off;\n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n \n@@ -512,11 +512,11 @@ align_test_frag_offset_fixed_p (const fragS *frag1, const fragS *frag2,\n       if (frag == frag1)\n \t{\n \t  *offset = off;\n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Optimize a difference of symbols which have rs_align_test frag if\n@@ -2526,7 +2526,7 @@ md_assemble (char *str)\n       char *name = initial_str;\n       int name_length = 0;\n       const sh_opcode_info *op;\n-      bfd_boolean found = FALSE;\n+      bool found = false;\n \n       /* Identify opcode in string.  */\n       while (ISSPACE (*name))\n@@ -2541,7 +2541,7 @@ md_assemble (char *str)\n \t  if (strncasecmp (op->name, name, name_length) == 0\n \t      && op->name[name_length] == '\\0')\n \t    {\n-\t      found = TRUE;\n+\t      found = true;\n \t      break;\n \t    }\n \t}\n@@ -2824,7 +2824,7 @@ md_parse_option (int c, const char *arg ATTRIBUTE_UNUSED)\n \n #ifdef OBJ_ELF\n     case OPTION_FDPIC:\n-      sh_fdpic = TRUE;\n+      sh_fdpic = true;\n       break;\n #endif /* OBJ_ELF */\n \n@@ -3278,7 +3278,7 @@ sh_handle_align (fragS *frag)\n \n /* See whether the relocation should be resolved locally.  */\n \n-static bfd_boolean\n+static bool\n sh_local_pcrel (fixS *fix)\n {\n   return (! sh_relax\n@@ -3327,7 +3327,7 @@ sh_force_relocation (fixS *fix)\n }\n \n #ifdef OBJ_ELF\n-bfd_boolean\n+bool\n sh_fix_adjustable (fixS *fixP)\n {\n   if (fixP->fx_r_type == BFD_RELOC_32_PLT_PCREL"
    },
    {
      "sha": "de36987b2f1a4efcfcb0a928ace67fb803306351",
      "filename": "gas/config/tc-sh.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-sh.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-sh.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-sh.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -185,7 +185,7 @@ extern void sh_elf_final_processing (void);\n #define TC_RELOC_GLOBAL_OFFSET_TABLE BFD_RELOC_SH_GOTPC\n \n #define tc_fix_adjustable(FIX) sh_fix_adjustable(FIX)\n-extern bfd_boolean sh_fix_adjustable (struct fix *);\n+extern bool sh_fix_adjustable (struct fix *);\n \n /* Values passed to md_apply_fix don't include symbol values.  */\n #define MD_APPLY_SYM_VALUE(FIX) 0"
    },
    {
      "sha": "f9055a55d2d8b1d66ae8a7d4704fca089a704615",
      "filename": "gas/config/tc-spu.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-spu.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -707,7 +707,7 @@ get_imm (const char *param, struct spu_insn *insn, int arg)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n #ifndef WORKING_DOT_WORD"
    },
    {
      "sha": "f41cc0534a1509a3c42f75783c6c28e95d336380",
      "filename": "gas/config/tc-tic54x.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tic54x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tic54x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic54x.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -3986,7 +3986,7 @@ emit_insn (tic54x_insn *insn)\n       if (insn->opcode[i].unresolved)\n \tfix_new_exp (frag_now, p - frag_now->fr_literal,\n \t\t     insn->opcode[i].r_nchars, &insn->opcode[i].addr_expr,\n-\t\t     FALSE, insn->opcode[i].r_type);\n+\t\t     false, insn->opcode[i].r_type);\n     }\n }\n \n@@ -5037,7 +5037,7 @@ md_atof (int type, char *literalP, int *sizeP)\n {\n   /* Target data is little-endian, but floats are stored\n      big-\"word\"ian.  ugh.  */\n-  return ieee_md_atof (type, literalP, sizeP, TRUE);\n+  return ieee_md_atof (type, literalP, sizeP, true);\n }\n \n arelent *"
    },
    {
      "sha": "bd72137383c8aa3b4fb2ba41a7d2fa953f9e915b",
      "filename": "gas/config/tc-tic6x.c",
      "status": "modified",
      "additions": 179,
      "deletions": 180,
      "changes": 359,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic6x.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -98,30 +98,30 @@ static int tic6x_arch_attribute = C6XABI_Tag_ISA_none;\n /* Whether any instructions at all have been seen.  Once any\n    instructions have been seen, architecture attributes merge into the\n    previous attribute value rather than replacing it.  */\n-static bfd_boolean tic6x_seen_insns = FALSE;\n+static bool tic6x_seen_insns = false;\n \n /* The number of registers in each register file supported by the\n    current architecture.  */\n static unsigned int tic6x_num_registers;\n \n /* Whether predication on A0 is possible.  */\n-static bfd_boolean tic6x_predicate_a0;\n+static bool tic6x_predicate_a0;\n \n /* Whether execute packets can cross fetch packet boundaries.  */\n-static bfd_boolean tic6x_can_cross_fp_boundary;\n+static bool tic6x_can_cross_fp_boundary;\n \n /* Whether there are constraints on simultaneous reads and writes of\n    40-bit data.  */\n-static bfd_boolean tic6x_long_data_constraints;\n+static bool tic6x_long_data_constraints;\n \n /* Whether compact instructions are available.  */\n-static bfd_boolean tic6x_compact_insns;\n+static bool tic6x_compact_insns;\n \n /* Whether to generate RELA relocations.  */\n-static bfd_boolean tic6x_generate_rela = TRUE;\n+static bool tic6x_generate_rela = true;\n \n /* Whether the code uses DSBT addressing.  */\n-static bfd_boolean tic6x_dsbt;\n+static bool tic6x_dsbt;\n \n /* Types of position-independent data (attribute values for\n    Tag_ABI_PID).  */\n@@ -136,7 +136,7 @@ typedef enum\n static tic6x_pid_type tic6x_pid;\n \n /* Whether the code uses position-independent code.  */\n-static bfd_boolean tic6x_pic;\n+static bool tic6x_pic;\n \n /* Table of supported architecture variants.  */\n typedef struct\n@@ -184,7 +184,7 @@ enum\n   UNWIND_A10\n };\n \n-static void tic6x_output_unwinding (bfd_boolean need_extab);\n+static void tic6x_output_unwinding (bool need_extab);\n \n /* Return the frame unwind state for the current function, allocating\n    as necessary.  */\n@@ -302,7 +302,7 @@ md_parse_option (int c, const char *arg)\n       break;\n \n     case OPTION_MGENERATE_REL:\n-      tic6x_generate_rela = FALSE;\n+      tic6x_generate_rela = false;\n       break;\n \n     default:\n@@ -417,7 +417,7 @@ s_tic6x_handlerdata (int ignored ATTRIBUTE_UNUSED)\n       return;\n     }\n \n-  tic6x_output_unwinding (TRUE);\n+  tic6x_output_unwinding (true);\n }\n \n /* Parse a .endp directive.  */\n@@ -431,7 +431,7 @@ s_tic6x_endp (int ignored ATTRIBUTE_UNUSED)\n       /* Output a .exidx entry if we have not already done so.\n \t Then switch back to the text section.  */\n       if (!unwind->table_entry)\n-\ttic6x_output_unwinding (FALSE);\n+\ttic6x_output_unwinding (false);\n \n       subseg_set (unwind->saved_seg, unwind->saved_subseg);\n     }\n@@ -544,7 +544,7 @@ s_tic6x_ehtype (int ignored ATTRIBUTE_UNUSED)\n static void\n s_tic6x_nocmp (int ignored ATTRIBUTE_UNUSED)\n {\n-  seg_info (now_seg)->tc_segment_info_data.nocmp = TRUE;\n+  seg_info (now_seg)->tc_segment_info_data.nocmp = true;\n   demand_empty_rest_of_line ();\n }\n \n@@ -681,7 +681,7 @@ s_tic6x_scomm (int ignore ATTRIBUTE_UNUSED)\n \n /* Track for each attribute whether it has been set explicitly (and so\n    should not have a default value set by the assembler).  */\n-static bfd_boolean tic6x_attributes_set_explicitly[NUM_KNOWN_OBJ_ATTRIBUTES];\n+static bool tic6x_attributes_set_explicitly[NUM_KNOWN_OBJ_ATTRIBUTES];\n \n /* Parse a .c6xabi_attribute directive.  */\n \n@@ -691,7 +691,7 @@ s_tic6x_c6xabi_attribute (int ignored ATTRIBUTE_UNUSED)\n   int tag = obj_elf_vendor_attribute (OBJ_ATTR_PROC);\n \n   if (tag < NUM_KNOWN_OBJ_ATTRIBUTES)\n-    tic6x_attributes_set_explicitly[tag] = TRUE;\n+    tic6x_attributes_set_explicitly[tag] = true;\n }\n \n typedef struct\n@@ -793,11 +793,11 @@ md_begin (void)\n }\n \n /* Whether the current line being parsed had the \"||\" parallel bars.  */\n-static bfd_boolean tic6x_line_parallel;\n+static bool tic6x_line_parallel;\n \n /* Whether the current line being parsed started \"||^\" to indicate an\n    SPMASKed parallel instruction.  */\n-static bfd_boolean tic6x_line_spmask;\n+static bool tic6x_line_spmask;\n \n /* If the current line being parsed had an instruction predicate, the\n    creg value for that predicate (which must be nonzero); otherwise\n@@ -817,8 +817,8 @@ tic6x_unrecognized_line (int c)\n {\n   char *p, *endp;\n   unsigned int z;\n-  bfd_boolean areg;\n-  bfd_boolean bad_predicate;\n+  bool areg;\n+  bool bad_predicate;\n \n   switch (c)\n     {\n@@ -827,14 +827,14 @@ tic6x_unrecognized_line (int c)\n \t{\n \t  if (input_line_pointer[1] == '^')\n \t    {\n-\t      tic6x_line_spmask = TRUE;\n+\t      tic6x_line_spmask = true;\n \t      input_line_pointer += 2;\n \t    }\n \t  else\n \t    input_line_pointer += 1;\n \t  if (tic6x_line_parallel)\n \t    as_bad (_(\"multiple '||' on same line\"));\n-\t  tic6x_line_parallel = TRUE;\n+\t  tic6x_line_parallel = true;\n \t  if (tic6x_line_creg)\n \t    as_bad (_(\"'||' after predicate\"));\n \t  return 1;\n@@ -853,28 +853,28 @@ tic6x_unrecognized_line (int c)\n       endp = p + 1;\n       p = input_line_pointer;\n       z = 0;\n-      bad_predicate = FALSE;\n+      bad_predicate = false;\n       if (*p == '!')\n \t{\n \t  z = 1;\n \t  p++;\n \t}\n       if (*p == 'A' || *p == 'a')\n-\tareg = TRUE;\n+\tareg = true;\n       else if (*p == 'B' || *p == 'b')\n-\tareg = FALSE;\n+\tareg = false;\n       else\n \t{\n-\t  areg = TRUE; /* Avoid uninitialized warning.  */\n-\t  bad_predicate = TRUE;\n+\t  areg = true; /* Avoid uninitialized warning.  */\n+\t  bad_predicate = true;\n \t}\n       if (!bad_predicate)\n \t{\n \t  p++;\n \t  if (*p != '0' && *p != '1' && *p != '2')\n-\t    bad_predicate = TRUE;\n+\t    bad_predicate = true;\n \t  else if (p[1] != ']')\n-\t    bad_predicate = TRUE;\n+\t    bad_predicate = true;\n \t  else\n \t    input_line_pointer = p + 2;\n \t}\n@@ -931,8 +931,8 @@ tic6x_frob_label (symbolS *sym)\n   if (tic6x_line_parallel)\n     {\n       as_bad (_(\"label after '||'\"));\n-      tic6x_line_parallel = FALSE;\n-      tic6x_line_spmask = FALSE;\n+      tic6x_line_parallel = false;\n+      tic6x_line_spmask = false;\n     }\n   if (tic6x_line_creg)\n     {\n@@ -961,8 +961,8 @@ tic6x_end_of_line (void)\n   if (tic6x_line_parallel)\n     {\n       as_bad (_(\"'||' not followed by instruction\"));\n-      tic6x_line_parallel = FALSE;\n-      tic6x_line_spmask = FALSE;\n+      tic6x_line_parallel = false;\n+      tic6x_line_spmask = false;\n     }\n   if (tic6x_line_creg)\n     {\n@@ -1033,7 +1033,7 @@ tic6x_cons_align (int n ATTRIBUTE_UNUSED)\n /* Handle an alignment directive.  Return TRUE if the\n    machine-independent frag generation should be skipped.  */\n \n-bfd_boolean\n+bool\n tic6x_do_align (int n, char *fill, int len ATTRIBUTE_UNUSED, int max)\n {\n   /* Given code alignments of 4, 8, 16 or 32 bytes, we try to handle\n@@ -1055,7 +1055,7 @@ tic6x_do_align (int n, char *fill, int len ATTRIBUTE_UNUSED, int max)\n       char *p;\n \n       if (n > 5)\n-\treturn FALSE;\n+\treturn false;\n \n       /* Machine-independent code would generate a frag here, but we\n \t wish to handle it in a machine-dependent way.  */\n@@ -1073,11 +1073,11 @@ tic6x_do_align (int n, char *fill, int len ATTRIBUTE_UNUSED, int max)\n \t saved.  */\n       if (p != align_frag->fr_literal)\n \tabort ();\n-      align_frag->tc_frag_data.is_insns = FALSE;\n-      return TRUE;\n+      align_frag->tc_frag_data.is_insns = false;\n+      return true;\n     }\n   else\n-    return FALSE;\n+    return false;\n }\n \n /* Types of operand for parsing purposes.  These are used as bit-masks\n@@ -1140,7 +1140,7 @@ typedef struct\n   tic6x_mem_scaling scaled;\n   /* Whether the offset is a register (TRUE) or an expression\n      (FALSE).  */\n-  bfd_boolean offset_is_reg;\n+  bool offset_is_reg;\n   /* The offset.  */\n   union\n   {\n@@ -1191,7 +1191,7 @@ typedef struct\n    without changing *P (but possibly changing *REG).  Do not print any\n    diagnostics.  */\n \n-static bfd_boolean\n+static bool\n tic6x_parse_register (char **p, tic6x_register *reg)\n {\n   char *r = *p;\n@@ -1209,7 +1209,7 @@ tic6x_parse_register (char **p, tic6x_register *reg)\n       break;\n \n     default:\n-      return FALSE;\n+      return false;\n     }\n   r++;\n \n@@ -1219,7 +1219,7 @@ tic6x_parse_register (char **p, tic6x_register *reg)\n       r++;\n     }\n   else\n-    return FALSE;\n+    return false;\n \n   if (reg->num > 0 && *r >= '0' && *r <= '9')\n     {\n@@ -1228,23 +1228,23 @@ tic6x_parse_register (char **p, tic6x_register *reg)\n     }\n \n   if (*r >= '0' && *r <= '9')\n-    return FALSE;\n+    return false;\n \n   if (reg->num >= 32)\n-    return FALSE;\n+    return false;\n   *p = r;\n-  return TRUE;\n+  return true;\n }\n \n /* Parse the initial two characters of a functional unit name starting\n-   at *P.  If OK, set *BASE and *SIDE and return TRUE; otherwise,\n+   at *P.  If OK, set *BASE and *SIDE and return true; otherwise,\n    return FALSE.  */\n \n-static bfd_boolean\n+static bool\n tic6x_parse_func_unit_base (char *p, tic6x_func_unit_base *base,\n \t\t\t    unsigned int *side)\n {\n-  bfd_boolean good_func_unit = TRUE;\n+  bool good_func_unit = true;\n   tic6x_func_unit_base maybe_base = tic6x_func_unit_nfu;\n   unsigned int maybe_side = 0;\n \n@@ -1271,7 +1271,7 @@ tic6x_parse_func_unit_base (char *p, tic6x_func_unit_base *base,\n       break;\n \n     default:\n-      good_func_unit = FALSE;\n+      good_func_unit = false;\n       break;\n     }\n \n@@ -1287,7 +1287,7 @@ tic6x_parse_func_unit_base (char *p, tic6x_func_unit_base *base,\n \tbreak;\n \n       default:\n-\tgood_func_unit = FALSE;\n+\tgood_func_unit = false;\n \tbreak;\n       }\n \n@@ -1307,11 +1307,11 @@ tic6x_parse_func_unit_base (char *p, tic6x_func_unit_base *base,\n    OP_FORMS.  For diagnostics, this is operand OPNO of an opcode\n    starting at STR, length OPC_LEN.  */\n \n-static bfd_boolean\n+static bool\n tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t\t     char *str, int opc_len, unsigned int opno)\n {\n-  bfd_boolean operand_parsed = FALSE;\n+  bool operand_parsed = false;\n   char *q = *p;\n \n   if ((op_forms & (TIC6X_OP_MEM_NOUNREG | TIC6X_OP_MEM_UNREG))\n@@ -1334,7 +1334,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t      op->form = TIC6X_OP_FUNC_UNIT;\n \t      op->value.func_unit.base = base;\n \t      op->value.func_unit.side = side;\n-\t      operand_parsed = TRUE;\n+\t      operand_parsed = true;\n \t      q = rq;\n \t    }\n \t}\n@@ -1353,7 +1353,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t  if (is_end_of_line[(unsigned char) *rq] || *rq == ',')\n \t    {\n \t      op->form = TIC6X_OP_IRP;\n-\t      operand_parsed = TRUE;\n+\t      operand_parsed = true;\n \t      q = rq;\n \t    }\n \t}\n@@ -1372,7 +1372,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t  if (is_end_of_line[(unsigned char) *rq] || *rq == ',')\n \t    {\n \t      op->form = TIC6X_OP_NRP;\n-\t      operand_parsed = TRUE;\n+\t      operand_parsed = true;\n \t      q = rq;\n \t    }\n \t}\n@@ -1396,7 +1396,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t\t{\n \t\t  op->form = TIC6X_OP_CTRL;\n \t\t  op->value.ctrl = crid;\n-\t\t  operand_parsed = TRUE;\n+\t\t  operand_parsed = true;\n \t\t  q = rq;\n \t\t  if (!(tic6x_ctrl_table[crid].isa_variants & tic6x_features))\n \t\t    as_bad (_(\"control register '%s' not supported \"\n@@ -1411,20 +1411,20 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n   if (!operand_parsed\n       && (op_forms & (TIC6X_OP_MEM_NOUNREG | TIC6X_OP_MEM_UNREG)))\n     {\n-      bfd_boolean mem_ok = TRUE;\n+      bool mem_ok = true;\n       char *mq = q;\n       tic6x_mem_mod mem_mod = tic6x_mem_mod_none;\n       tic6x_register base_reg;\n-      bfd_boolean require_offset, permit_offset;\n+      bool require_offset, permit_offset;\n       tic6x_mem_scaling scaled;\n-      bfd_boolean offset_is_reg;\n+      bool offset_is_reg;\n       expressionS offset_exp;\n       tic6x_register offset_reg;\n \n       if (*mq == '*')\n \tmq++;\n       else\n-\tmem_ok = FALSE;\n+\tmem_ok = false;\n \n       if (mem_ok)\n \t{\n@@ -1484,15 +1484,15 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t}\n \n       if (mem_mod == tic6x_mem_mod_none)\n-\tpermit_offset = FALSE;\n+\tpermit_offset = false;\n       else\n-\tpermit_offset = TRUE;\n+\tpermit_offset = true;\n       if (mem_mod == tic6x_mem_mod_plus || mem_mod == tic6x_mem_mod_minus)\n-\trequire_offset = TRUE;\n+\trequire_offset = true;\n       else\n-\trequire_offset = FALSE;\n+\trequire_offset = false;\n       scaled = tic6x_offset_none;\n-      offset_is_reg = FALSE;\n+      offset_is_reg = false;\n \n       if (mem_ok && permit_offset)\n \t{\n@@ -1522,7 +1522,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t      if (scaled == tic6x_offset_scaled\n \t\t  || (op_forms & TIC6X_OP_MEM_UNREG))\n \t\t{\n-\t\t  bfd_boolean reg_ok;\n+\t\t  bool reg_ok;\n \t\t  char *rq = mq;\n \n \t\t  reg_ok = tic6x_parse_register (&rq, &offset_reg);\n@@ -1532,7 +1532,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t\t      if (*rq == endc)\n \t\t\t{\n \t\t\t  mq = rq;\n-\t\t\t  offset_is_reg = TRUE;\n+\t\t\t  offset_is_reg = true;\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -1550,18 +1550,18 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t      if (*mq == endc)\n \t\tmq++;\n \t      else\n-\t\tmem_ok = FALSE;\n+\t\tmem_ok = false;\n \t    }\n \t}\n \n       if (mem_ok && require_offset && scaled == tic6x_offset_none)\n-\tmem_ok = FALSE;\n+\tmem_ok = false;\n \n       if (mem_ok)\n \t{\n \t  skip_whitespace (mq);\n \t  if (!is_end_of_line[(unsigned char) *mq] && *mq != ',')\n-\t    mem_ok = FALSE;\n+\t    mem_ok = false;\n \t}\n \n       if (mem_ok)\n@@ -1575,7 +1575,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t    op->value.mem.offset.reg = offset_reg;\n \t  else\n \t    op->value.mem.offset.exp = offset_exp;\n-\t  operand_parsed = TRUE;\n+\t  operand_parsed = true;\n \t  q = mq;\n \t  if (base_reg.num >= tic6x_num_registers)\n \t    as_bad (_(\"register number %u not supported on this architecture\"),\n@@ -1590,7 +1590,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n   if (!operand_parsed && (op_forms & (TIC6X_OP_REG | TIC6X_OP_REGPAIR)))\n     {\n       tic6x_register first_reg, second_reg;\n-      bfd_boolean reg_ok;\n+      bool reg_ok;\n       char *rq = q;\n \n       reg_ok = tic6x_parse_register (&rq, &first_reg);\n@@ -1614,7 +1614,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t\t\t\topc_len, str);\n \t\t      op->form = TIC6X_OP_REGPAIR;\n \t\t      op->value.reg = second_reg;\n-\t\t      operand_parsed = TRUE;\n+\t\t      operand_parsed = true;\n \t\t      q = rq;\n \t\t    }\n \t\t}\n@@ -1626,7 +1626,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n \t\t{\n \t\t  op->form = TIC6X_OP_REG;\n \t\t  op->value.reg = first_reg;\n-\t\t  operand_parsed = TRUE;\n+\t\t  operand_parsed = true;\n \t\t  q = rq;\n \t\t}\n \t    }\n@@ -1654,7 +1654,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n       expression (&op->value.exp);\n       q = input_line_pointer;\n       input_line_pointer = save_input_line_pointer;\n-      operand_parsed = TRUE;\n+      operand_parsed = true;\n     }\n \n   if (operand_parsed)\n@@ -1664,7 +1664,7 @@ tic6x_parse_operand (char **p, tic6x_operand *op, unsigned int op_forms,\n       skip_whitespace (q);\n       if (!is_end_of_line[(unsigned char) *q] && *q != ',')\n \t{\n-\t  operand_parsed = FALSE;\n+\t  operand_parsed = false;\n \t  as_bad (_(\"junk after operand %u of '%.*s'\"), opno,\n \t\t  opc_len, str);\n \t  while (!is_end_of_line[(unsigned char) *q] && *q != ',')\n@@ -1855,7 +1855,7 @@ tic6x_parse_name (const char *name, expressionS *exprP,\n static void\n tic6x_fix_new_exp (fragS *frag, int where, int size, expressionS *exp,\n \t\t   int pcrel, bfd_reloc_code_real_type r_type,\n-\t\t   bfd_boolean fix_adda)\n+\t\t   bool fix_adda)\n {\n   bfd_reloc_code_real_type new_reloc = BFD_RELOC_UNUSED;\n   symbolS *subsy = NULL;\n@@ -2027,22 +2027,22 @@ tic6x_cons_fix_new (fragS *frag, int where, int size, expressionS *exp,\n       return;\n     }\n \n-  tic6x_fix_new_exp (frag, where, size, exp, 0, r_type, FALSE);\n+  tic6x_fix_new_exp (frag, where, size, exp, 0, r_type, false);\n }\n \n /* Initialize target-specific fix data.  */\n \n void\n tic6x_init_fix_data (fixS *fixP)\n {\n-  fixP->tc_fix_data.fix_adda = FALSE;\n+  fixP->tc_fix_data.fix_adda = false;\n   fixP->tc_fix_data.fix_subsy = NULL;\n }\n \n /* Return true if the fix can be handled by GAS, false if it must\n    be passed through to the linker.  */\n \n-bfd_boolean\n+bool\n tic6x_fix_adjustable (fixS *fixP)\n {\n   switch (fixP->fx_r_type)\n@@ -2377,7 +2377,7 @@ tic6x_default_mem_ref (tic6x_mem_ref *mem_ref)\n \tabort ();\n       mem_ref->mod = tic6x_mem_mod_plus;\n       mem_ref->scaled = tic6x_offset_unscaled;\n-      mem_ref->offset_is_reg = FALSE;\n+      mem_ref->offset_is_reg = false;\n       memset (&mem_ref->offset.exp, 0, sizeof mem_ref->offset.exp);\n       mem_ref->offset.exp.X_op = O_constant;\n       mem_ref->offset.exp.X_add_number = 0;\n@@ -2397,7 +2397,7 @@ tic6x_default_mem_ref (tic6x_mem_ref *mem_ref)\n       if (mem_ref->scaled != tic6x_offset_none)\n \tbreak;\n       mem_ref->scaled = tic6x_offset_scaled;\n-      mem_ref->offset_is_reg = FALSE;\n+      mem_ref->offset_is_reg = false;\n       memset (&mem_ref->offset.exp, 0, sizeof mem_ref->offset.exp);\n       mem_ref->offset.exp.X_op = O_constant;\n       mem_ref->offset.exp.X_add_number = 1;\n@@ -2442,10 +2442,10 @@ tic6x_encode_spmask (tic6x_func_unit_base unit, unsigned int side)\n    instruction, or 0 if not in such a loop; the only possible problems\n    are operands being out of range (they already match the\n    fine-grained form), and inappropriate predication.  If this\n-   succeeds, return the encoding and set *OK to TRUE; otherwise return\n+   succeeds, return the encoding and set *OK to true; otherwise return\n    0 and set *OK to FALSE.  If a fix is needed, set *FIX_NEEDED to\n    true and fill in *FIX_EXP, *FIX_PCREL, *FX_R_TYPE and *FIX_ADDA.\n-   Print error messages for failure if PRINT_ERRORS is TRUE; the\n+   Print error messages for failure if PRINT_ERRORS is true; the\n    opcode starts at STR and has length OPC_LEN.  */\n \n static unsigned int\n@@ -2455,9 +2455,9 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t  unsigned int func_unit_cross,\n \t\t  unsigned int func_unit_data_side, int sploop_ii,\n \t\t  expressionS **fix_exp, int *fix_pcrel,\n-\t\t  bfd_reloc_code_real_type *fx_r_type, bfd_boolean *fix_adda,\n-\t\t  bfd_boolean *fix_needed, bfd_boolean *ok,\n-\t\t  bfd_boolean print_errors, char *str, int opc_len)\n+\t\t  bfd_reloc_code_real_type *fx_r_type, bool *fix_adda,\n+\t\t  bool *fix_needed, bool *ok,\n+\t\t  bool print_errors, char *str, int opc_len)\n {\n   const tic6x_opcode *opct;\n   const tic6x_insn_format *fmt;\n@@ -2512,7 +2512,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t      if (print_errors)\n \t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n \t\t\topc_len, str);\n-\t      *ok = FALSE;\n+\t      *ok = false;\n \t      return 0;\n \t    }\n \t  value = ucexp.X_add_number;\n@@ -2528,11 +2528,11 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t a known relocation for them.  */\n \t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n \t\tabort ();\n-\t      *fix_needed = TRUE;\n+\t      *fix_needed = true;\n \t      *fix_exp = &operands[opno].value.exp;\n \t      *fix_pcrel = 0;\n \t      *fx_r_type = BFD_RELOC_C6000_ABS_S16;\n-\t      *fix_adda = FALSE;\n+\t      *fix_adda = false;\n \t      break;\n \t    }\n \t  sign_value = SEXT (operands[opno].value.exp.X_add_number);\n@@ -2543,7 +2543,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t      if (print_errors)\n \t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n \t\t\topc_len, str);\n-\t      *ok = FALSE;\n+\t      *ok = false;\n \t      return 0;\n \t    }\n \t  value = sign_value + (1 << (fldd->bitfields[0].width - 1));\n@@ -2561,7 +2561,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t      if (print_errors)\n \t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n \t\t\topc_len, str);\n-\t      *ok = FALSE;\n+\t      *ok = false;\n \t      return 0;\n \t    }\n \t  value = operands[opno].value.exp.X_add_number - 1;\n@@ -2606,7 +2606,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t\t    as_bad (_(\"offset in operand %u of '%.*s' not \"\n \t\t\t\t      \"divisible by %u\"), opno + 1, opc_len,\n \t\t\t\t    str, 1u << bits);\n-\t\t\t  *ok = FALSE;\n+\t\t\t  *ok = false;\n \t\t\t  return 0;\n \t\t\t}\n \t\t      ucexp.X_add_number >>= bits;\n@@ -2634,15 +2634,15 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t     check is not needed at this point to encode the value,\n \t     and if there is eventually a problem it will be detected\n \t     either in md_apply_fix or at link time.  */\n-\t  *fix_needed = TRUE;\n+\t  *fix_needed = true;\n \t  *fix_exp = expp;\n \t  *fix_pcrel = 0;\n \t  *fx_r_type\n \t    = tic6x_dpr_reloc (opct->variable_fields[fld].coding_method);\n \t  if (operands[opno].form == TIC6X_OP_EXP)\n-\t    *fix_adda = TRUE;\n+\t    *fix_adda = true;\n \t  else\n-\t    *fix_adda = FALSE;\n+\t    *fix_adda = false;\n \t  break;\n \n \tcase tic6x_coding_lcst_low16:\n@@ -2657,11 +2657,11 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t known relocation.  */\n \t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n \t\tabort ();\n-\t      *fix_needed = TRUE;\n+\t      *fix_needed = true;\n \t      *fix_exp = &operands[opno].value.exp;\n \t      *fix_pcrel = 0;\n \t      *fx_r_type = BFD_RELOC_C6000_ABS_L16;\n-\t      *fix_adda = FALSE;\n+\t      *fix_adda = false;\n \t    }\n \t  break;\n \n@@ -2677,11 +2677,11 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t known relocation.  */\n \t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n \t\tabort ();\n-\t      *fix_needed = TRUE;\n+\t      *fix_needed = true;\n \t      *fix_exp = &operands[opno].value.exp;\n \t      *fix_pcrel = 0;\n \t      *fx_r_type = BFD_RELOC_C6000_ABS_H16;\n-\t      *fix_adda = FALSE;\n+\t      *fix_adda = false;\n \t    }\n \t  break;\n \n@@ -2690,7 +2690,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t  if (operands[opno].form != TIC6X_OP_EXP)\n \t    abort ();\n \t  value = 0;\n-\t  *fix_needed = TRUE;\n+\t  *fix_needed = true;\n \t  *fix_exp = &operands[opno].value.exp;\n \t  *fix_pcrel = 1;\n \t  if (fldd->bitfields[0].low_pos == 7 && fldd->bitfields[0].width == 21)\n@@ -2705,7 +2705,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t    /* Opcode table should not use this encoding without a\n \t       known relocation.  */\n \t    abort ();\n-\t  *fix_adda = FALSE;\n+\t  *fix_adda = false;\n \t  break;\n \n \tcase tic6x_coding_regpair_lsb:\n@@ -2822,7 +2822,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t  if (print_errors)\n \t\t    as_bad (_(\"offset in operand %u of '%.*s' out of range\"),\n \t\t\t    opno + 1, opc_len, str);\n-\t\t  *ok = FALSE;\n+\t\t  *ok = false;\n \t\t  return 0;\n \t\t}\n \t      if (mem.offset.exp.X_add_number % scale)\n@@ -2831,7 +2831,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t    as_bad (_(\"offset in operand %u of '%.*s' not \"\n \t\t\t      \"divisible by %u\"),\n \t\t\t    opno + 1, opc_len, str, scale);\n-\t\t  *ok = FALSE;\n+\t\t  *ok = false;\n \t\t  return 0;\n \t\t}\n \t      value = mem.offset.exp.X_add_number / scale;\n@@ -2855,7 +2855,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t  if (print_errors)\n \t\t    as_bad (_(\"offset in operand %u of '%.*s' out of range\"),\n \t\t\t    opno + 1, opc_len, str);\n-\t\t  *ok = FALSE;\n+\t\t  *ok = false;\n \t\t  return 0;\n \t\t}\n \t      value = mem.offset.exp.X_add_number;\n@@ -2937,7 +2937,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t  if (print_errors)\n \t\t    as_bad (_(\"functional unit already masked for operand \"\n \t\t\t      \"%u of '%.*s'\"), opno + 1, opc_len, str);\n-\t\t  *ok = FALSE;\n+\t\t  *ok = false;\n \t\t  return 0;\n \t\t}\n \t      value |= v;\n@@ -2962,7 +2962,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\tas_bad (_(\"'%.*s' instruction not in a software \"\n \t\t\t  \"pipelined loop\"),\n \t\t\topc_len, str);\n-\t      *ok = FALSE;\n+\t      *ok = false;\n \t      return 0;\n \t    }\n \n@@ -2991,7 +2991,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t  if (print_errors)\n \t\t    as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n \t\t\t    opc_len, str);\n-\t\t  *ok = FALSE;\n+\t\t  *ok = false;\n \t\t  return 0;\n \t\t}\n \t      value = operands[opno].value.exp.X_add_number;\n@@ -3010,7 +3010,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t\t  if (print_errors)\n \t\t    as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n \t\t\t    opc_len, str);\n-\t\t  *ok = FALSE;\n+\t\t  *ok = false;\n \t\t  return 0;\n \t\t}\n \t      value = operands[opno].value.exp.X_add_number;\n@@ -3042,7 +3042,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t    if (print_errors)\n \t      as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n \t\t      opc_len, str);\n-\t    *ok = FALSE;\n+\t    *ok = false;\n \t    return 0;\n \t  }\n \n@@ -3060,7 +3060,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n \t  if (print_errors)\n \t    as_bad (_(\"instruction '%.*s' cannot be predicated\"),\n \t\t    opc_len, str);\n-\t  *ok = FALSE;\n+\t  *ok = false;\n \t  return 0;\n \t}\n       z = tic6x_field_from_fmt (fmt, tic6x_field_z);\n@@ -3073,7 +3073,7 @@ tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n       opcode_value |= this_line_z << z->bitfields[0].low_pos;\n     }\n \n-  *ok = TRUE;\n+  *ok = true;\n   return opcode_value;\n }\n \n@@ -3114,8 +3114,8 @@ md_assemble (char *str)\n {\n   char *p;\n   int opc_len;\n-  bfd_boolean this_line_parallel;\n-  bfd_boolean this_line_spmask;\n+  bool this_line_parallel;\n+  bool this_line_spmask;\n   unsigned int this_line_creg;\n   unsigned int this_line_z;\n   tic6x_label_list *this_insn_label_list;\n@@ -3131,21 +3131,20 @@ md_assemble (char *str)\n   unsigned int opc_rank[TIC6X_NUM_PREFER];\n   const tic6x_opcode *opct = NULL;\n   int min_rank, try_rank, max_rank;\n-  bfd_boolean num_operands_permitted[TIC6X_MAX_SOURCE_OPERANDS + 1]\n-    = { FALSE };\n+  bool num_operands_permitted[TIC6X_MAX_SOURCE_OPERANDS + 1] = { false };\n   unsigned int operand_forms[TIC6X_MAX_SOURCE_OPERANDS] = { 0 };\n   tic6x_operand operands[TIC6X_MAX_SOURCE_OPERANDS];\n   unsigned int max_num_operands;\n   unsigned int num_operands_read;\n-  bfd_boolean ok_this_arch, ok_this_fu, ok_this_arch_fu;\n-  bfd_boolean bad_operands = FALSE;\n+  bool ok_this_arch, ok_this_fu, ok_this_arch_fu;\n+  bool bad_operands = false;\n   unsigned int opcode_value;\n-  bfd_boolean encoded_ok;\n-  bfd_boolean fix_needed = FALSE;\n+  bool encoded_ok;\n+  bool fix_needed = false;\n   expressionS *fix_exp = NULL;\n   int fix_pcrel = 0;\n   bfd_reloc_code_real_type fx_r_type = BFD_RELOC_UNUSED;\n-  bfd_boolean fix_adda = FALSE;\n+  bool fix_adda = false;\n   fragS *insn_frag;\n   char *output;\n \n@@ -3161,7 +3160,7 @@ md_assemble (char *str)\n   /* Now an instruction has been seen, architecture attributes from\n      .arch directives merge with rather than overriding the previous\n      value.  */\n-  tic6x_seen_insns = TRUE;\n+  tic6x_seen_insns = true;\n   /* If no .arch directives or -march options have been seen, we are\n      assessing instruction validity based on the C674X default, so set\n      the attribute accordingly.  */\n@@ -3174,8 +3173,8 @@ md_assemble (char *str)\n   this_line_spmask = tic6x_line_spmask;\n   this_line_creg = tic6x_line_creg;\n   this_line_z = tic6x_line_z;\n-  tic6x_line_parallel = FALSE;\n-  tic6x_line_spmask = FALSE;\n+  tic6x_line_parallel = false;\n+  tic6x_line_spmask = false;\n   tic6x_line_creg = 0;\n   tic6x_line_z = 0;\n   seginfo = seg_info (now_seg);\n@@ -3199,7 +3198,7 @@ md_assemble (char *str)\n      specifier.  */\n   if (*p == '.')\n     {\n-      bfd_boolean good_func_unit;\n+      bool good_func_unit;\n       tic6x_func_unit_base maybe_base = tic6x_func_unit_nfu;\n       unsigned int maybe_side = 0;\n       unsigned int maybe_cross = 0;\n@@ -3227,7 +3226,7 @@ md_assemble (char *str)\n \t      p += 5;\n \t    }\n \t  else\n-\t    good_func_unit = FALSE;\n+\t    good_func_unit = false;\n \t}\n \n       if (good_func_unit)\n@@ -3250,47 +3249,47 @@ md_assemble (char *str)\n   num_matching_opcodes = 0;\n   opcm = XNEWVEC (tic6x_opcode_id, max_matching_opcodes);\n   max_num_operands = 0;\n-  ok_this_arch = FALSE;\n-  ok_this_fu = FALSE;\n-  ok_this_arch_fu = FALSE;\n+  ok_this_arch = false;\n+  ok_this_fu = false;\n+  ok_this_arch_fu = false;\n   for (opc = opc_list; opc; opc = opc->next)\n     {\n       unsigned int num_operands;\n       unsigned int i;\n-      bfd_boolean this_opc_arch_ok = TRUE;\n-      bfd_boolean this_opc_fu_ok = TRUE;\n+      bool this_opc_arch_ok = true;\n+      bool this_opc_fu_ok = true;\n \n       if (tic6x_insn_format_table[tic6x_opcode_table[opc->id].format].num_bits\n \t  != 32)\n \tcontinue;\n       if (!(tic6x_opcode_table[opc->id].isa_variants & tic6x_features))\n-\tthis_opc_arch_ok = FALSE;\n+\tthis_opc_arch_ok = false;\n       if (tic6x_opcode_table[opc->id].func_unit != func_unit_base)\n-\tthis_opc_fu_ok = FALSE;\n+\tthis_opc_fu_ok = false;\n       if (func_unit_side == 1\n \t  && (tic6x_opcode_table[opc->id].flags & TIC6X_FLAG_SIDE_B_ONLY))\n-\tthis_opc_fu_ok = FALSE;\n+\tthis_opc_fu_ok = false;\n       if (func_unit_cross\n \t  && (tic6x_opcode_table[opc->id].flags & TIC6X_FLAG_NO_CROSS))\n-\tthis_opc_fu_ok = FALSE;\n+\tthis_opc_fu_ok = false;\n       if (!func_unit_data_side\n \t  && (tic6x_opcode_table[opc->id].flags\n \t      & (TIC6X_FLAG_LOAD | TIC6X_FLAG_STORE)))\n-\tthis_opc_fu_ok = FALSE;\n+\tthis_opc_fu_ok = false;\n       if (func_unit_data_side\n \t  && !(tic6x_opcode_table[opc->id].flags\n \t       & (TIC6X_FLAG_LOAD | TIC6X_FLAG_STORE)))\n-\tthis_opc_fu_ok = FALSE;\n+\tthis_opc_fu_ok = false;\n       if (func_unit_data_side == 1\n \t  && (tic6x_opcode_table[opc->id].flags & TIC6X_FLAG_SIDE_T2_ONLY))\n-\tthis_opc_fu_ok = FALSE;\n+\tthis_opc_fu_ok = false;\n       if (this_opc_arch_ok)\n-\tok_this_arch = TRUE;\n+\tok_this_arch = true;\n       if (this_opc_fu_ok)\n-\tok_this_fu = TRUE;\n+\tok_this_fu = true;\n       if (!this_opc_arch_ok || !this_opc_fu_ok)\n \tcontinue;\n-      ok_this_arch_fu = TRUE;\n+      ok_this_arch_fu = true;\n       opcm[num_matching_opcodes] = opc->id;\n       num_matching_opcodes++;\n       num_operands = tic6x_opcode_table[opc->id].num_operands;\n@@ -3306,7 +3305,7 @@ md_assemble (char *str)\n \t    {\n \t      operand_forms[i]\n \t\t|= tic6x_coarse_operand_form (tic6x_operand_func_unit);\n-\t      num_operands_permitted[i] = TRUE;\n+\t      num_operands_permitted[i] = true;\n \t    }\n \t}\n       else\n@@ -3319,7 +3318,7 @@ md_assemble (char *str)\n \t      operand_forms[i] |= tic6x_coarse_operand_form (f);\n \t    }\n \t}\n-      num_operands_permitted[num_operands] = TRUE;\n+      num_operands_permitted[num_operands] = true;\n       if (num_operands > max_num_operands)\n \tmax_num_operands = num_operands;\n     }\n@@ -3355,30 +3354,30 @@ md_assemble (char *str)\n     abort ();\n \n   num_operands_read = 0;\n-  while (TRUE)\n+  while (true)\n     {\n       skip_whitespace (p);\n       if (is_end_of_line[(unsigned char) *p])\n \t{\n \t  if (num_operands_read > 0)\n \t    {\n \t      as_bad (_(\"missing operand after comma\"));\n-\t      bad_operands = TRUE;\n+\t      bad_operands = true;\n \t    }\n \t  break;\n \t}\n \n       if (max_num_operands == 0)\n \t{\n \t  as_bad (_(\"too many operands to '%.*s'\"), opc_len, str);\n-\t  bad_operands = TRUE;\n+\t  bad_operands = true;\n \t  break;\n \t}\n \n       if (!tic6x_parse_operand (&p, &operands[num_operands_read],\n \t\t\t\toperand_forms[num_operands_read], str, opc_len,\n \t\t\t\tnum_operands_read + 1))\n-\tbad_operands = TRUE;\n+\tbad_operands = true;\n       num_operands_read++;\n \n       if (is_end_of_line[(unsigned char) *p])\n@@ -3389,7 +3388,7 @@ md_assemble (char *str)\n \t  if (num_operands_read == max_num_operands)\n \t    {\n \t      as_bad (_(\"too many operands to '%.*s'\"), opc_len, str);\n-\t      bad_operands = TRUE;\n+\t      bad_operands = true;\n \t      break;\n \t    }\n \t  continue;\n@@ -3402,7 +3401,7 @@ md_assemble (char *str)\n   if (!bad_operands && !num_operands_permitted[num_operands_read])\n     {\n       as_bad (_(\"bad number of operands to '%.*s'\"), opc_len, str);\n-      bad_operands = TRUE;\n+      bad_operands = true;\n     }\n \n   if (!bad_operands)\n@@ -3415,8 +3414,8 @@ md_assemble (char *str)\n \n       for (i = 0; i < num_operands_read; i++)\n \t{\n-\t  bfd_boolean coarse_ok = FALSE;\n-\t  bfd_boolean fine_ok = FALSE;\n+\t  bool coarse_ok = false;\n+\t  bool fine_ok = false;\n \t  tic6x_operand_match fine_failure = tic6x_match_matches;\n \t  unsigned int j;\n \n@@ -3446,15 +3445,15 @@ md_assemble (char *str)\n \t      if (operands[i].form != cf)\n \t\tcontinue;\n \n-\t      coarse_ok = TRUE;\n+\t      coarse_ok = true;\n \t      this_fine_failure\n \t\t= tic6x_operand_matches_form (&operands[i], f, rw,\n \t\t\t\t\t      func_unit_side,\n \t\t\t\t\t      cross_side,\n \t\t\t\t\t      func_unit_data_side);\n \t      if (this_fine_failure == tic6x_match_matches)\n \t\t{\n-\t\t  fine_ok = TRUE;\n+\t\t  fine_ok = true;\n \t\t  break;\n \t\t}\n \t      if (fine_failure == tic6x_match_matches\n@@ -3513,7 +3512,7 @@ md_assemble (char *str)\n \t\tdefault:\n \t\t  abort ();\n \t\t}\n-\t      bad_operands = TRUE;\n+\t      bad_operands = true;\n \t      break;\n \t    }\n \t}\n@@ -3525,7 +3524,7 @@ md_assemble (char *str)\n \t operands is valid.  Check whether there is an opcode choice\n \t for which all operands are simultaneously valid.  */\n       unsigned int i;\n-      bfd_boolean found_match = FALSE;\n+      bool found_match = false;\n \n       for (i = 0; i < TIC6X_NUM_PREFER; i++)\n \topc_rank[i] = (unsigned int) -1;\n@@ -3536,7 +3535,7 @@ md_assemble (char *str)\n       for (i = 0; i < num_matching_opcodes; i++)\n \t{\n \t  unsigned int j;\n-\t  bfd_boolean this_matches = TRUE;\n+\t  bool this_matches = true;\n \n \t  if (!(tic6x_opcode_table[opcm[i]].flags & TIC6X_FLAG_SPMASK)\n \t      && tic6x_opcode_table[opcm[i]].num_operands != num_operands_read)\n@@ -3563,7 +3562,7 @@ md_assemble (char *str)\n \t\t\t\t\t      func_unit_data_side)\n \t\t  != tic6x_match_matches)\n \t\t{\n-\t\t  this_matches = FALSE;\n+\t\t  this_matches = false;\n \t\t  break;\n \t\t}\n \t    }\n@@ -3585,14 +3584,14 @@ md_assemble (char *str)\n \t\t   here.  */\n \t\tabort ();\n \n-\t      found_match = TRUE;\n+\t      found_match = true;\n \t    }\n \t}\n \n       if (!found_match)\n \t{\n \t  as_bad (_(\"bad operand combination for '%.*s'\"), opc_len, str);\n-\t  bad_operands = TRUE;\n+\t  bad_operands = true;\n \t}\n     }\n \n@@ -3603,10 +3602,10 @@ md_assemble (char *str)\n     }\n \n   opcode_value = 0;\n-  encoded_ok = FALSE;\n+  encoded_ok = false;\n   for (try_rank = max_rank; try_rank >= min_rank; try_rank--)\n     {\n-      fix_needed = FALSE;\n+      fix_needed = false;\n \n       if (opc_rank[try_rank] == (unsigned int) -1)\n \tcontinue;\n@@ -3687,7 +3686,7 @@ md_assemble (char *str)\n \t saved.  */\n       if (output != insn_frag->fr_literal)\n \tabort ();\n-      insn_frag->tc_frag_data.is_insns = TRUE;\n+      insn_frag->tc_frag_data.is_insns = true;\n       insn_frag->tc_frag_data.can_cross_fp_boundary\n \t= tic6x_can_cross_fp_boundary;\n     }\n@@ -4088,8 +4087,8 @@ tic6x_adjust_section (bfd *abfd ATTRIBUTE_UNUSED, segT section,\n   segment_info_type *info;\n   frchainS *frchp;\n   fragS *fragp;\n-  bfd_boolean have_code = FALSE;\n-  bfd_boolean have_non_code = FALSE;\n+  bool have_code = false;\n+  bool have_non_code = false;\n \n   info = seg_info (section);\n   if (info == NULL)\n@@ -4101,17 +4100,17 @@ tic6x_adjust_section (bfd *abfd ATTRIBUTE_UNUSED, segT section,\n \t{\n \tcase rs_machine_dependent:\n \t  if (fragp->tc_frag_data.is_insns)\n-\t    have_code = TRUE;\n+\t    have_code = true;\n \t  break;\n \n \tcase rs_dummy:\n \tcase rs_fill:\n \t  if (fragp->fr_fix > 0)\n-\t    have_non_code = TRUE;\n+\t    have_non_code = true;\n \t  break;\n \n \tdefault:\n-\t  have_non_code = TRUE;\n+\t  have_non_code = true;\n \t  break;\n \t}\n \n@@ -4175,7 +4174,7 @@ tic6x_adjust_section (bfd *abfd ATTRIBUTE_UNUSED, segT section,\n \tfor (fragp = frchp->frch_root; fragp; fragp = fragp->fr_next)\n \tlook_at_frag:\n \t  {\n-\t    bfd_boolean go_back = FALSE;\n+\t    bool go_back = false;\n \t    frchainS *frchp_next;\n \t    fragS *fragp_next;\n \n@@ -4198,7 +4197,7 @@ tic6x_adjust_section (bfd *abfd ATTRIBUTE_UNUSED, segT section,\n \t\tif (want_insert > 7)\n \t\t  abort ();\n \t\twant_insert_done_so_far = 0;\n-\t\tgo_back = TRUE;\n+\t\tgo_back = true;\n \t      }\n \n \t    if (!fragp->tc_frag_data.is_insns)\n@@ -4240,7 +4239,7 @@ tic6x_adjust_section (bfd *abfd ATTRIBUTE_UNUSED, segT section,\n \t\tif (want_insert > 7)\n \t\t  abort ();\n \t\twant_insert_done_so_far = 0;\n-\t\tgo_back = TRUE;\n+\t\tgo_back = true;\n \t      }\n \t    else if (want_insert && !go_back)\n \t      {\n@@ -4282,7 +4281,7 @@ tic6x_adjust_section (bfd *abfd ATTRIBUTE_UNUSED, segT section,\n \t\t\twant_insert -= want_insert_done_so_far;\n \t\t\twant_insert_done_so_far = 0;\n \t\t\tif (want_insert)\n-\t\t\t  go_back = TRUE;\n+\t\t\t  go_back = true;\n \t\t      }\n \t\t  }\n \t      }\n@@ -4369,8 +4368,8 @@ tic6x_adjust_section (bfd *abfd ATTRIBUTE_UNUSED, segT section,\n void\n tic6x_frag_init (fragS *fragp)\n {\n-  fragp->tc_frag_data.is_insns = FALSE;\n-  fragp->tc_frag_data.can_cross_fp_boundary = FALSE;\n+  fragp->tc_frag_data.is_insns = false;\n+  fragp->tc_frag_data.can_cross_fp_boundary = false;\n }\n \n /* Set an attribute if it has not already been set by the user.  */\n@@ -4550,7 +4549,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)\n int\n tic6x_regname_to_dw2regnum (char *regname)\n {\n-  bfd_boolean reg_ok;\n+  bool reg_ok;\n   tic6x_register reg;\n   char *rq = regname;\n \n@@ -4874,7 +4873,7 @@ tic6x_output_exidx_entry (void)\n }\n \n static void\n-tic6x_output_unwinding (bfd_boolean need_extab)\n+tic6x_output_unwinding (bool need_extab)\n {\n   tic6x_unwind_info *unwind = tic6x_get_unwind ();\n   unsigned safe_mask = unwind->safe_mask;\n@@ -5085,13 +5084,13 @@ tic6x_cfi_endproc (struct fde_entry *fde)\n   unwind->cfa_reg = 31;\n   unwind->return_reg = UNWIND_B3;\n   unwind->saved_reg_count = 0;\n-  unwind->pop_rts = FALSE;\n+  unwind->pop_rts = false;\n \n   unwind->saved_seg = now_seg;\n   unwind->saved_subseg = now_subseg;\n \n   for (reg = 0; reg < TIC6X_NUM_UNWIND_REGS; reg++)\n-    unwind->reg_saved[reg] = FALSE;\n+    unwind->reg_saved[reg] = false;\n \n   /* Scan FDE instructions to build up stack frame layout.  */\n   for (insn = fde->data; insn; insn = insn->next)\n@@ -5118,7 +5117,7 @@ tic6x_cfi_endproc (struct fde_entry *fde)\n \tcase DW_CFA_same_value:\n \t  reg = tic6x_unwind_reg_from_dwarf (insn->u.r);\n \t  if (reg >= 0)\n-\t    unwind->reg_saved[reg] = FALSE;\n+\t    unwind->reg_saved[reg] = false;\n \t  break;\n \n \tcase DW_CFA_offset:\n@@ -5129,7 +5128,7 @@ tic6x_cfi_endproc (struct fde_entry *fde)\n \t\t      insn->u.ri.reg);\n \t      return;\n \t    }\n-\t  unwind->reg_saved[reg] = TRUE;\n+\t  unwind->reg_saved[reg] = true;\n \t  unwind->reg_offset[reg] = insn->u.ri.offset;\n \t  if (insn->u.ri.reg == UNWIND_B3)\n \t    unwind->return_reg = UNWIND_B3;\n@@ -5152,7 +5151,7 @@ tic6x_cfi_endproc (struct fde_entry *fde)\n \t    }\n \n \t  unwind->return_reg = reg;\n-\t  unwind->reg_saved[UNWIND_B3] = FALSE;\n+\t  unwind->reg_saved[UNWIND_B3] = false;\n \t  if (unwind->reg_saved[reg])\n \t    {\n \t      as_bad (_(\"unable to restore return address from \"\n@@ -5318,7 +5317,7 @@ tic6x_cfi_endproc (struct fde_entry *fde)\n \n       if (reg == TIC6X_NUM_UNWIND_REGS)\n \t{\n-\t  unwind->pop_rts = TRUE;\n+\t  unwind->pop_rts = true;\n \t  reg_saved_mask = 0;\n \t}\n     }"
    },
    {
      "sha": "a25c04590aec7902d070e7fbe0a2208363edb1df",
      "filename": "gas/config/tc-tic6x.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tic6x.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tic6x.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic6x.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -62,14 +62,14 @@ typedef struct tic6x_unwind_info {\n     int data_bytes;\n \n     offsetT reg_offset[TIC6X_NUM_UNWIND_REGS];\n-    bfd_boolean reg_saved[TIC6X_NUM_UNWIND_REGS];\n+    bool reg_saved[TIC6X_NUM_UNWIND_REGS];\n     int cfa_reg;\n     int return_reg;\n     unsigned safe_mask;\n     unsigned compact_mask;\n     unsigned reg_saved_mask;\n     offsetT cfa_offset;\n-    bfd_boolean pop_rts;\n+    bool pop_rts;\n     /* Only valid for UNWIND_OP_POP_REG */\n     int saved_reg_count;\n } tic6x_unwind_info;\n@@ -82,7 +82,7 @@ typedef struct\n   tic6x_label_list *label_list;\n \n   /* Whether compact instructions are forbidden here.  */\n-  bfd_boolean nocmp;\n+  bool nocmp;\n \n   /* If there is a current execute packet, the frag being used for\n      that execute packet.  */\n@@ -123,11 +123,11 @@ typedef struct\n {\n   /* Whether this machine-dependent frag is used for instructions (as\n      opposed to code alignment).  */\n-  bfd_boolean is_insns;\n+  bool is_insns;\n \n   /* For a frag used for instructions, whether it is may cross a fetch\n      packet boundary (subject to alignment requirements).  */\n-  bfd_boolean can_cross_fp_boundary;\n+  bool can_cross_fp_boundary;\n } tic6x_frag_info;\n #define TC_FRAG_TYPE tic6x_frag_info\n #define TC_FRAG_INIT(fragP, max_bytes) tic6x_frag_init (fragP)\n@@ -140,7 +140,7 @@ typedef struct\n      left (it represents a value to be encoded literally in the\n      instruction, whereas a non-constant represents a DP-relative\n      value counting in the appropriate units).  */\n-  bfd_boolean fix_adda;\n+  bool fix_adda;\n   /* The symbol to be subtracted in case of a PCR_H16 or PCR_L16\n      reloc.  */\n   symbolS *fix_subsy;\n@@ -164,7 +164,7 @@ extern void tic6x_cons_align (int n);\n     if (tic6x_do_align (n, fill, len, max))\t\\\n       goto label;\t\t\t\t\\\n   } while (0)\n-extern bfd_boolean tic6x_do_align (int n, char *fill, int len, int max);\n+extern bool tic6x_do_align (int n, char *fill, int len, int max);\n \n #define CONVERT_SYMBOLIC_ATTRIBUTE(name)\t\\\n   tic6x_convert_symbolic_attribute (name)\n@@ -190,7 +190,7 @@ extern void tic6x_cons_fix_new (fragS *, int, int, expressionS *,\n \t\t\t\tbfd_reloc_code_real_type);\n \n #define tc_fix_adjustable(FIX) tic6x_fix_adjustable (FIX)\n-extern bfd_boolean tic6x_fix_adjustable (struct fix *);\n+extern bool tic6x_fix_adjustable (struct fix *);\n \n #define tc_frob_label(sym) tic6x_frob_label (sym)\n extern void tic6x_frob_label (symbolS *sym);"
    },
    {
      "sha": "e041b4a64d714f045d8103a893a4625b9005c926",
      "filename": "gas/config/tc-tilegx.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tilegx.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -891,7 +891,7 @@ tilegx_flush_bundle (void)\n \t  /* Make sure all instructions can be bundled with other\n \t     instructions.  */\n \t  const struct tilegx_opcode *cannot_bundle = NULL;\n-\t  bfd_boolean seen_non_nop = FALSE;\n+\t  bool seen_non_nop = false;\n \n \t  for (j = 0; j < current_bundle_index; j++)\n \t    {\n@@ -902,7 +902,7 @@ tilegx_flush_bundle (void)\n \t      else if (op->mnemonic != TILEGX_OPC_NOP\n \t\t       && op->mnemonic != TILEGX_OPC_INFO\n \t\t       && op->mnemonic != TILEGX_OPC_INFOL)\n-\t\tseen_non_nop = TRUE;\n+\t\tseen_non_nop = true;\n \t    }\n \n \t  if (cannot_bundle != NULL && seen_non_nop)"
    },
    {
      "sha": "365b621ccdd14239582a47a8d6bc1e209a578e34",
      "filename": "gas/config/tc-tilepro.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tilepro.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -778,7 +778,7 @@ tilepro_flush_bundle (void)\n \t  /* Make sure all instructions can be bundled with other\n \t     instructions.  */\n \t  const struct tilepro_opcode *cannot_bundle = NULL;\n-\t  bfd_boolean seen_non_nop = FALSE;\n+\t  bool seen_non_nop = false;\n \n \t  for (j = 0; j < current_bundle_index; j++)\n \t    {\n@@ -789,7 +789,7 @@ tilepro_flush_bundle (void)\n \t      else if (op->mnemonic != TILEPRO_OPC_NOP\n \t\t       && op->mnemonic != TILEPRO_OPC_INFO\n \t\t       && op->mnemonic != TILEPRO_OPC_INFOL)\n-\t\tseen_non_nop = TRUE;\n+\t\tseen_non_nop = true;\n \t    }\n \n \t  if (cannot_bundle != NULL && seen_non_nop)"
    },
    {
      "sha": "496fd9b12326db0f4e67c4610e6f4a889772ffd1",
      "filename": "gas/config/tc-v850.c",
      "status": "modified",
      "additions": 61,
      "deletions": 61,
      "changes": 122,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-v850.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-v850.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-v850.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -28,8 +28,8 @@\n #define SEXT16(x)\t((((x) & 0xffff) ^ (~0x7fff)) + 0x8000)\n \n /* Set to TRUE if we want to be pedantic about signed overflows.  */\n-static bfd_boolean warn_signed_overflows   = FALSE;\n-static bfd_boolean warn_unsigned_overflows = FALSE;\n+static bool warn_signed_overflows   = false;\n+static bool warn_unsigned_overflows = false;\n \n /* Non-zero if floating point insns are not being used.  */\n static signed int soft_float = -1;\n@@ -942,7 +942,7 @@ static int\n reg_name_search (const struct reg_name *regs,\n \t\t int regcount,\n \t\t const char *name,\n-\t\t bfd_boolean accept_numbers)\n+\t\t bool accept_numbers)\n {\n   int middle, low, high;\n   int cmp;\n@@ -995,7 +995,7 @@ reg_name_search (const struct reg_name *regs,\n   \tInput_line_pointer->(next non-blank) char after operand, or is in\n   \tits original state.  */\n \n-static bfd_boolean\n+static bool\n register_name (expressionS *expressionP)\n {\n   int reg_number;\n@@ -1008,7 +1008,7 @@ register_name (expressionS *expressionP)\n   c = get_symbol_name (&name);\n \n   reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT,\n-\t\t\t\tname, FALSE);\n+\t\t\t\tname, false);\n \n   /* Put back the delimiting char.  */\n   (void) restore_line_pointer (c);\n@@ -1022,15 +1022,15 @@ register_name (expressionS *expressionP)\n       expressionP->X_op\t\t= O_register;\n       expressionP->X_add_number = reg_number;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n \n   expressionP->X_op = O_illegal;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Summary of system_register_name().\n@@ -1045,9 +1045,9 @@ register_name (expressionS *expressionP)\n   \tInput_line_pointer->(next non-blank) char after operand, or is in\n   \tits original state.  */\n \n-static bfd_boolean\n+static bool\n system_register_name (expressionS *expressionP,\n-\t\t      bfd_boolean accept_numbers)\n+\t\t      bool accept_numbers)\n {\n   int reg_number;\n   char *name;\n@@ -1084,15 +1084,15 @@ system_register_name (expressionS *expressionP,\n       expressionP->X_op\t\t= O_register;\n       expressionP->X_add_number = reg_number;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n \n   expressionP->X_op = O_illegal;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Summary of cc_name().\n@@ -1105,9 +1105,9 @@ system_register_name (expressionS *expressionP,\n   \tInput_line_pointer->(next non-blank) char after operand, or is in\n   \tits original state.  */\n \n-static bfd_boolean\n+static bool\n cc_name (expressionS *expressionP,\n-\t bfd_boolean accept_numbers)\n+\t bool accept_numbers)\n {\n   int reg_number;\n   char *name;\n@@ -1143,7 +1143,7 @@ cc_name (expressionS *expressionP,\n       expressionP->X_op\t\t= O_constant;\n       expressionP->X_add_number = reg_number;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n@@ -1152,12 +1152,12 @@ cc_name (expressionS *expressionP,\n   expressionP->X_op = O_illegal;\n   expressionP->X_add_number = 0;\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n float_cc_name (expressionS *expressionP,\n-\t       bfd_boolean accept_numbers)\n+\t       bool accept_numbers)\n {\n   int reg_number;\n   char *name;\n@@ -1193,7 +1193,7 @@ float_cc_name (expressionS *expressionP,\n       expressionP->X_op\t\t= O_constant;\n       expressionP->X_add_number = reg_number;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n@@ -1202,12 +1202,12 @@ float_cc_name (expressionS *expressionP,\n   expressionP->X_op = O_illegal;\n   expressionP->X_add_number = 0;\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n cacheop_name (expressionS * expressionP,\n-\t      bfd_boolean accept_numbers)\n+\t      bool accept_numbers)\n {\n   int reg_number;\n   char *name;\n@@ -1241,7 +1241,7 @@ cacheop_name (expressionS * expressionP,\n       expressionP->X_op\t\t= O_constant;\n       expressionP->X_add_number = reg_number;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n@@ -1250,12 +1250,12 @@ cacheop_name (expressionS * expressionP,\n   expressionP->X_op = O_illegal;\n   expressionP->X_add_number = 0;\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n prefop_name (expressionS * expressionP,\n-\t     bfd_boolean accept_numbers)\n+\t     bool accept_numbers)\n {\n   int reg_number;\n   char *name;\n@@ -1289,7 +1289,7 @@ prefop_name (expressionS * expressionP,\n       expressionP->X_op\t\t= O_constant;\n       expressionP->X_add_number = reg_number;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n@@ -1298,10 +1298,10 @@ prefop_name (expressionS * expressionP,\n   expressionP->X_op = O_illegal;\n   expressionP->X_add_number = 0;\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n vector_register_name (expressionS *expressionP)\n {\n   int reg_number;\n@@ -1314,7 +1314,7 @@ vector_register_name (expressionS *expressionP)\n   c = get_symbol_name (&name);\n \n   reg_number = reg_name_search (vector_registers, VREG_NAME_CNT,\n-\t\t\t\tname, FALSE);\n+\t\t\t\tname, false);\n \n   /* Put back the delimiting char.  */\n   (void) restore_line_pointer (c);\n@@ -1328,15 +1328,15 @@ vector_register_name (expressionS *expressionP)\n       expressionP->X_op\t\t= O_register;\n       expressionP->X_add_number = reg_number;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Reset the line as if we had not done anything.  */\n   input_line_pointer = start;\n \n   expressionP->X_op = O_illegal;\n \n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -1452,7 +1452,7 @@ parse_register_list (unsigned long *insn,\n \t  if (i == 32)\n \t    return _(\"illegal register included in list\");\n \t}\n-      else if (system_register_name (&exp, TRUE))\n+      else if (system_register_name (&exp, true))\n \t{\n \t  if (regs == type1_regs)\n \t    {\n@@ -1532,7 +1532,7 @@ struct option md_longopts[] =\n \n size_t md_longopts_size = sizeof (md_longopts);\n \n-static bfd_boolean v850_data_8 = FALSE;\n+static bool v850_data_8 = false;\n \n void\n md_show_usage (FILE *stream)\n@@ -1580,10 +1580,10 @@ md_parse_option (int c, const char *arg)\n     }\n \n   if (strcmp (arg, \"warn-signed-overflow\") == 0)\n-    warn_signed_overflows = TRUE;\n+    warn_signed_overflows = true;\n \n   else if (strcmp (arg, \"warn-unsigned-overflow\") == 0)\n-    warn_unsigned_overflows = TRUE;\n+    warn_unsigned_overflows = true;\n \n   else if (strcmp (arg, \"v850\") == 0)\n     {\n@@ -1646,12 +1646,12 @@ md_parse_option (int c, const char *arg)\n     }\n   else if (strcmp (arg, \"8byte-align\") == 0)\n     {\n-      v850_data_8 = TRUE;\n+      v850_data_8 = true;\n       v850_e_flags |= EF_RH850_DATA_ALIGN8;\n     }\n   else if (strcmp (arg, \"4byte-align\") == 0)\n     {\n-      v850_data_8 = FALSE;\n+      v850_data_8 = false;\n       v850_e_flags &= ~ EF_RH850_DATA_ALIGN8;\n     }\n   else if (strcmp (arg, \"soft-float\") == 0)\n@@ -1673,7 +1673,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litp, int *sizep)\n {\n-  return ieee_md_atof (type, litp, sizep, FALSE);\n+  return ieee_md_atof (type, litp, sizep, false);\n }\n \n /* Very gross.  */\n@@ -2141,13 +2141,13 @@ handle_tdaoff (const struct v850_operand *operand, const char **errmsg)\n static bfd_reloc_code_real_type\n v850_reloc_prefix (const struct v850_operand *operand, const char **errmsg)\n {\n-  bfd_boolean paren_skipped = FALSE;\n+  bool paren_skipped = false;\n \n   /* Skip leading opening parenthesis.  */\n   if (*input_line_pointer == '(')\n     {\n       ++input_line_pointer;\n-      paren_skipped = TRUE;\n+      paren_skipped = true;\n     }\n \n #define CHECK_(name, reloc) \t\t\t\t\t\t\\\n@@ -2303,7 +2303,7 @@ md_assemble (char *str)\n   char *f = NULL;\n   int i;\n   int match;\n-  bfd_boolean extra_data_after_insn = FALSE;\n+  bool extra_data_after_insn = false;\n   unsigned extra_data_len = 0;\n   unsigned long extra_data = 0;\n   char *saved_input_line_pointer;\n@@ -2371,7 +2371,7 @@ md_assemble (char *str)\n       next_opindex = 0;\n       insn = opcode->opcode;\n       extra_data_len = 0;\n-      extra_data_after_insn = FALSE;\n+      extra_data_after_insn = false;\n \n       input_line_pointer = str = start_of_operands;\n \n@@ -2497,7 +2497,7 @@ md_assemble (char *str)\n \n \t\t  if (operand->flags & V850E_IMMEDIATE32)\n \t\t    {\n-\t\t      extra_data_after_insn = TRUE;\n+\t\t      extra_data_after_insn = true;\n \t\t      extra_data_len\t    = 4;\n \t\t      extra_data\t    = 0;\n \t\t    }\n@@ -2508,7 +2508,7 @@ md_assemble (char *str)\n \t\t\t  errmsg = _(\"immediate operand is too large\");\n \t\t\t  goto error;\n \t\t\t}\n-\t\t      extra_data_after_insn = TRUE;\n+\t\t      extra_data_after_insn = true;\n \t\t      extra_data_len\t    = 2;\n \t\t      extra_data\t    = 0;\n \t\t    }\n@@ -2529,7 +2529,7 @@ md_assemble (char *str)\n \t\t\t  goto error;\n \t\t\t}\n \n-\t\t      extra_data_after_insn = TRUE;\n+\t\t      extra_data_after_insn = true;\n \t\t      extra_data_len\t    = 2;\n \t\t      extra_data\t    = 0;\n \t\t    }\n@@ -2568,7 +2568,7 @@ md_assemble (char *str)\n \n \t\t  if (operand->flags & V850E_IMMEDIATE32)\n \t\t    {\n-\t\t      extra_data_after_insn = TRUE;\n+\t\t      extra_data_after_insn = true;\n \t\t      extra_data_len\t    = 4;\n \t\t      extra_data\t    = 0;\n \t\t    }\n@@ -2579,7 +2579,7 @@ md_assemble (char *str)\n \t\t\t  errmsg = _(\"immediate operand is too large\");\n \t\t\t  goto error;\n \t\t\t}\n-\t\t      extra_data_after_insn = TRUE;\n+\t\t      extra_data_after_insn = true;\n \t\t      extra_data_len\t    = 2;\n \t\t      extra_data\t    = 0;\n \t\t    }\n@@ -2600,7 +2600,7 @@ md_assemble (char *str)\n \t\t\t  goto error;\n \t\t\t}\n \n-\t\t      extra_data_after_insn = TRUE;\n+\t\t      extra_data_after_insn = true;\n \t\t      extra_data_len\t    = 2;\n \t\t      extra_data\t    = 0;\n \t\t    }\n@@ -2664,7 +2664,7 @@ md_assemble (char *str)\n \t\t  break;\n \t\t}\n \n-\t      extra_data_after_insn = TRUE;\n+\t      extra_data_after_insn = true;\n \t      extra_data_len        = 2;\n \t      extra_data            = ex.X_add_number;\n \t    }\n@@ -2697,7 +2697,7 @@ md_assemble (char *str)\n \t      fixups[fc].reloc   = operand->default_reloc;\n \t      ++fc;\n \n-\t      extra_data_after_insn = TRUE;\n+\t      extra_data_after_insn = true;\n \t      extra_data_len        = 2;\n \t      extra_data            = 0;\n \t    }\n@@ -2738,7 +2738,7 @@ md_assemble (char *str)\n \t\t  break;\n \t\t}\n \n-\t      extra_data_after_insn = TRUE;\n+\t      extra_data_after_insn = true;\n \t      extra_data_len        = 4;\n \t      extra_data            = ex.X_add_number;\n \t    }\n@@ -2776,7 +2776,7 @@ md_assemble (char *str)\n \t\t}\n \t      else if ((operand->flags & V850_OPERAND_SRG) != 0)\n \t\t{\n-\t\t  if (!system_register_name (&ex, TRUE))\n+\t\t  if (!system_register_name (&ex, true))\n \t\t    {\n \t\t      errmsg = _(\"invalid system register name\");\n \t\t    }\n@@ -2807,7 +2807,7 @@ md_assemble (char *str)\n \t\t}\n \t      else if ((operand->flags & V850_OPERAND_CC) != 0)\n \t\t{\n-\t\t  if (!cc_name (&ex, TRUE))\n+\t\t  if (!cc_name (&ex, true))\n \t\t    {\n \t\t      errmsg = _(\"invalid condition code name\");\n \t\t    }\n@@ -2820,19 +2820,19 @@ md_assemble (char *str)\n \t\t}\n \t      else if ((operand->flags & V850_OPERAND_FLOAT_CC) != 0)\n \t\t{\n-\t\t  if (!float_cc_name (&ex, TRUE))\n+\t\t  if (!float_cc_name (&ex, true))\n \t\t    {\n \t\t      errmsg = _(\"invalid condition code name\");\n \t\t    }\n \t\t}\n \t      else if ((operand->flags & V850_OPERAND_CACHEOP) != 0)\n \t\t{\n-\t\t  if (!cacheop_name (&ex, TRUE))\n+\t\t  if (!cacheop_name (&ex, true))\n \t\t    errmsg = _(\"invalid cache operation name\");\n \t\t}\n \t      else if ((operand->flags & V850_OPERAND_PREFOP) != 0)\n \t\t{\n-\t\t  if (!prefop_name (&ex, TRUE))\n+\t\t  if (!prefop_name (&ex, true))\n \t\t    errmsg = _(\"invalid pref operation name\");\n \t\t}\n \t      else if ((operand->flags & V850_OPERAND_VREG) != 0)\n@@ -2889,17 +2889,17 @@ md_assemble (char *str)\n \t\t\t\t       &symbol_rootP, &symbol_lastP);\n \t\t    }\n \t\t}\n-\t      else if (system_register_name (&ex, FALSE)\n+\t      else if (system_register_name (&ex, false)\n \t\t       && (operand->flags & V850_OPERAND_SRG) == 0)\n \t\t{\n \t\t  errmsg = _(\"syntax error: system register not expected\");\n \t\t}\n-\t      else if (cc_name (&ex, FALSE)\n+\t      else if (cc_name (&ex, false)\n \t\t       && (operand->flags & V850_OPERAND_CC) == 0)\n \t\t{\n \t\t  errmsg = _(\"syntax error: condition code not expected\");\n \t\t}\n-\t      else if (float_cc_name (&ex, FALSE)\n+\t      else if (float_cc_name (&ex, false)\n \t\t       && (operand->flags & V850_OPERAND_FLOAT_CC) == 0)\n \t\t{\n \t\t  errmsg = _(\"syntax error: condition code not expected\");\n@@ -3236,7 +3236,7 @@ md_assemble (char *str)\n \t  f = frag_more (extra_data_len);\n \t  md_number_to_chars (f, extra_data, extra_data_len);\n \n-\t  extra_data_after_insn = FALSE;\n+\t  extra_data_after_insn = false;\n \t}\n     }\n \n@@ -3691,7 +3691,7 @@ cons_fix_new_v850 (fragS *frag,\n     fix_new (frag, where, size, NULL, 0, 0, r);\n }\n \n-bfd_boolean\n+bool\n v850_fix_adjustable (fixS *fixP)\n {\n   if (fixP->fx_addsy == NULL)"
    },
    {
      "sha": "7bcfd5ecc757b0fdd98ca4ac07565dfed791f342",
      "filename": "gas/config/tc-v850.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-v850.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-v850.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-v850.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -35,7 +35,7 @@ extern const char * v850_target_format;\n #define md_operand(x)\n \n #define tc_fix_adjustable(FIX) v850_fix_adjustable (FIX)\n-extern bfd_boolean v850_fix_adjustable (struct fix *);\n+extern bool v850_fix_adjustable (struct fix *);\n \n #define TC_FORCE_RELOCATION(FIX) v850_force_relocation(FIX)\n extern int v850_force_relocation (struct fix *);"
    },
    {
      "sha": "95b86067aa533ad9a1efc0e95138c8acb53b4ad8",
      "filename": "gas/config/tc-visium.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-visium.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-visium.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-visium.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -532,7 +532,7 @@ visium_pcrel_from_section (fixS *fixP, segT sec)\n /* Indicate whether a fixup against a locally defined\n    symbol should be adjusted to be against the section\n    symbol.  */\n-bfd_boolean\n+bool\n visium_fix_adjustable (fixS *fix)\n {\n   /* We need the symbol name for the VTABLE entries.  */"
    },
    {
      "sha": "3f937e727c881bc26711dc4ce2e417a0c19c253f",
      "filename": "gas/config/tc-visium.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-visium.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-visium.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-visium.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -43,7 +43,7 @@\n #define WORKING_DOT_WORD\n \n #define tc_fix_adjustable(FIXP) visium_fix_adjustable (FIXP)\n-extern bfd_boolean visium_fix_adjustable (struct fix *);\n+extern bool visium_fix_adjustable (struct fix *);\n \n #define HANDLE_ALIGN(FRAGP)\t\t \\\n   if ((FRAGP)->fr_type == rs_align_code) \\"
    },
    {
      "sha": "6e17b0b115b134a6be85cbd2b614253ec127c130",
      "filename": "gas/config/tc-wasm32.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-wasm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-wasm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-wasm32.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -138,7 +138,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \n /* No machine-dependent frags.  */\n@@ -184,17 +184,17 @@ md_section_align (asection * seg, valueT addr)\n /* Apply a fixup, return TRUE if done (and no relocation is\n    needed).  */\n \n-static bfd_boolean\n+static bool\n apply_full_field_fix (fixS * fixP, char *buf, bfd_vma val, int size)\n {\n   if (fixP->fx_addsy != NULL || fixP->fx_pcrel)\n     {\n       fixP->fx_addnumber = val;\n-      return FALSE;\n+      return false;\n     }\n \n   number_to_chars_littleendian (buf, val, size);\n-  return TRUE;\n+  return true;\n }\n \n /* Apply a fixup (potentially PC-relative), set the fx_done flag if\n@@ -236,7 +236,7 @@ skip_space (char *s)\n \n /* Allow '/' in opcodes.  */\n \n-static inline bfd_boolean\n+static inline bool\n is_part_of_opcode (char c)\n {\n   return is_part_of_name (c) || (c == '/');\n@@ -333,7 +333,7 @@ wasm32_put_uleb128 (unsigned long value)\n    symbol, or a special relocation for <expr>@got, <expr>@gotcode, and\n    <expr>@plt{__sigchar_<signature>}.  */\n \n-static bfd_boolean\n+static bool\n wasm32_leb128 (char **line, int bits, int sign)\n {\n   char *t = input_line_pointer;\n@@ -455,7 +455,7 @@ wasm32_leb128 (char **line, int bits, int sign)\n /* Read an integer expression and produce an unsigned LEB128 integer,\n    or a relocation for it.  */\n \n-static bfd_boolean\n+static bool\n wasm32_uleb128 (char **line, int bits)\n {\n   return wasm32_leb128 (line, bits, 0);\n@@ -464,7 +464,7 @@ wasm32_uleb128 (char **line, int bits)\n /* Read an integer expression and produce a signed LEB128 integer, or\n    a relocation for it.  */\n \n-static bfd_boolean\n+static bool\n wasm32_sleb128 (char **line, int bits)\n {\n   return wasm32_leb128 (line, bits, 1);\n@@ -777,17 +777,17 @@ wasm32_force_relocation (fixS * f)\n /* Don't replace PLT/GOT relocations with section symbols, so they\n    don't get an addend.  */\n \n-bfd_boolean\n+bool\n wasm32_fix_adjustable (fixS * fixP)\n {\n   if (fixP->fx_addsy == NULL)\n-    return TRUE;\n+    return true;\n \n   if (fixP->fx_r_type == BFD_RELOC_WASM32_LEB128_PLT\n       || fixP->fx_r_type == BFD_RELOC_WASM32_LEB128_GOT)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Generate a reloc for FIXP.  */"
    },
    {
      "sha": "60f6ada72be40fe6b009ca58b9a493ab5d3e26ef",
      "filename": "gas/config/tc-wasm32.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-wasm32.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-wasm32.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-wasm32.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -78,7 +78,7 @@ extern int wasm32_force_relocation (struct fix *);\n #define HANDLE_ALIGN(fragP)\n \n \n-extern bfd_boolean wasm32_fix_adjustable (struct fix *);\n+extern bool wasm32_fix_adjustable (struct fix *);\n #define tc_fix_adjustable(FIX) wasm32_fix_adjustable (FIX)\n \n /* Type names for blocks and signatures.  */"
    },
    {
      "sha": "7d89a37166d623bea0afa32875280f69912b666f",
      "filename": "gas/config/tc-xc16x.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xc16x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xc16x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xc16x.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -228,7 +228,7 @@ md_parse_option (int c ATTRIBUTE_UNUSED,\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }\n \n valueT"
    },
    {
      "sha": "5f5d16521918dffd8b47a6209daff44da8d28ffa",
      "filename": "gas/config/tc-xgate.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xgate.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xgate.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xgate.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -196,7 +196,7 @@ size_t md_longopts_size = sizeof (md_longopts);\n const char *\n md_atof (int type, char *litP, int *sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, TRUE);\n+  return ieee_md_atof (type, litP, sizeP, true);\n }\n \n int\n@@ -1292,24 +1292,24 @@ xgate_parse_operand (struct xgate_opcode *opcode,\n \t    {\n \t      if (((opcode->name[strlen (opcode->name) - 1] == 'l')\n \t\t   && autoHiLo) || operand.mod == MOD_LOAD_LOW)\n-\t\tfix_new_exp (frag_now, where, 2, &operand.exp, FALSE,\n+\t\tfix_new_exp (frag_now, where, 2, &operand.exp, false,\n \t\t\t     BFD_RELOC_XGATE_24);\n \t      else if (((opcode->name[strlen (opcode->name) - 1]) == 'h'\n \t\t\t&& autoHiLo) || operand.mod == MOD_LOAD_HIGH )\n-\t\tfix_new_exp (frag_now, where, 2, &operand.exp, FALSE,\n+\t\tfix_new_exp (frag_now, where, 2, &operand.exp, false,\n \t\t\t     BFD_RELOC_XGATE_IMM8_HI);\n \t      else\n \t\tas_bad (_(\"you must use a hi/lo directive or 16-bit macro \"\n \t\t\t  \"to load a 16-bit value.\"));\n \t    }\n \t  else if (*op_constraint == '5')\n-\t    fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,\n+\t    fix_new_exp (frag_now, where, 2, &operand.exp, false,\n \t\t\t BFD_RELOC_XGATE_IMM5);\n \t  else if (*op_constraint == '4')\n-\t    fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,\n+\t    fix_new_exp (frag_now, where, 2, &operand.exp, false,\n \t\t\t BFD_RELOC_XGATE_IMM4);\n \t  else if (*op_constraint == '3')\n-\t    fix_new_exp (frag_now, where, 2, &operand.exp, FALSE,\n+\t    fix_new_exp (frag_now, where, 2, &operand.exp, false,\n \t\t\t BFD_RELOC_XGATE_IMM3);\n \t  else\n \t    as_bad (_(\":unknown relocation constraint size\"));\n@@ -1335,10 +1335,10 @@ xgate_parse_operand (struct xgate_opcode *opcode,\n       if (operand.exp.X_op != O_register)\n \t{\n \t  if (*op_constraint == '9')\n-\t    fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,\n+\t    fix_new_exp (frag_now, where, 2, &operand.exp, true,\n \t\t\t BFD_RELOC_XGATE_PCREL_9);\n \t  else if (*op_constraint == 'a')\n-\t    fix_new_exp (frag_now, where, 2, &operand.exp, TRUE,\n+\t    fix_new_exp (frag_now, where, 2, &operand.exp, true,\n \t\t\t BFD_RELOC_XGATE_PCREL_10);\n \t}\n       else"
    },
    {
      "sha": "487e981e6a84b164f3b651c70d2bc9b4532fcc86",
      "filename": "gas/config/tc-xstormy16.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xstormy16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xstormy16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xstormy16.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -101,7 +101,7 @@ md_begin (void)\n   cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);\n }\n \n-static bfd_boolean skipping_fptr = FALSE;\n+static bool skipping_fptr = false;\n \n void\n md_assemble (char * str)\n@@ -111,7 +111,7 @@ md_assemble (char * str)\n \n   /* Make sure that if we had an erroneous input line which triggered\n      the skipping_fptr boolean that it does not affect following lines.  */\n-  skipping_fptr = FALSE;\n+  skipping_fptr = false;\n \n   /* Initialize GAS's cgen interface for a new instruction.  */\n   gas_cgen_init_parse ();\n@@ -174,9 +174,9 @@ md_operand (expressionS * e)\n \t  example) might be local symbols and we want the expression\n \t  to be evaluated now.  This kind of thing can happen when\n \t  gcc is generating computed gotos.  */\n-\tskipping_fptr = TRUE;\n+\tskipping_fptr = true;\n       else if (skipping_fptr)\n-\tskipping_fptr = FALSE;\n+\tskipping_fptr = false;\n       else\n         e->X_op = O_fptr_symbol;\n     }\n@@ -417,18 +417,18 @@ xstormy16_force_relocation (fixS * fix)\n /* Return true if a relocation against a symbol may be replaced with\n    a relocation against section+offset.  */\n \n-bfd_boolean\n+bool\n xstormy16_fix_adjustable (fixS * fixP)\n {\n   /* We need the symbol name for the VTABLE entries.  */\n   if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT\n       || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)\n-    return FALSE;\n+    return false;\n \n   if (fixP->fx_r_type == BFD_RELOC_XSTORMY16_FPTR16)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* This is a copy of gas_cgen_md_apply_fix, with some enhancements to\n@@ -602,5 +602,5 @@ md_number_to_chars (char * buf, valueT val, int n)\n const char *\n md_atof (int type, char * litP, int * sizeP)\n {\n-  return ieee_md_atof (type, litP, sizeP, FALSE);\n+  return ieee_md_atof (type, litP, sizeP, false);\n }"
    },
    {
      "sha": "151fb34bb9a500ae45527701d37226cee418b67a",
      "filename": "gas/config/tc-xstormy16.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xstormy16.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xstormy16.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xstormy16.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9",
      "patch": "@@ -43,7 +43,7 @@\n #define md_apply_fix xstormy16_md_apply_fix\n \n #define tc_fix_adjustable(FIX) xstormy16_fix_adjustable (FIX)\n-extern bfd_boolean xstormy16_fix_adjustable (struct fix *);\n+extern bool xstormy16_fix_adjustable (struct fix *);\n \n #define TC_FORCE_RELOCATION(fix) xstormy16_force_relocation (fix)\n extern int xstormy16_force_relocation (struct fix *);"
    },
    {
      "sha": "978704e5c842b2957371684dfdf8b66baccd8c8c",
      "filename": "gas/config/tc-xtensa.c",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xtensa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xtensa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xtensa.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "1441246cf6115af15fd877ff6aa0a8595a5db52c",
      "filename": "gas/config/tc-xtensa.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xtensa.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-xtensa.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xtensa.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "e9c664db63e5d49c89c3017cef3a70955e3e633d",
      "filename": "gas/config/tc-z80.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-z80.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-z80.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-z80.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "3ff90d52b13ed05dca59efbe83f8c7d70b44dfaf",
      "filename": "gas/config/tc-z8k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-z8k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/tc-z8k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-z8k.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "088285defb78ca569c225ce25c0727e65311ace8",
      "filename": "gas/config/xtensa-istack.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/xtensa-istack.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/xtensa-istack.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/xtensa-istack.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "88e29988df713ed5c0b3fc6385c9d9c97bcc7cd1",
      "filename": "gas/config/xtensa-relax.c",
      "status": "modified",
      "additions": 57,
      "deletions": 57,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/xtensa-relax.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/xtensa-relax.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/xtensa-relax.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "99ad22f1446cbf730ec028435b47d0bdf8426e8b",
      "filename": "gas/config/xtensa-relax.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/xtensa-relax.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/config/xtensa-relax.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/xtensa-relax.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "24dfee9e9c312e0bb2ce8fd7692da6b5b917defe",
      "filename": "gas/dw2gencfi.c",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/dw2gencfi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/dw2gencfi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/dw2gencfi.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "60ed2190548765d24f205ce1d20301230a81a24f",
      "filename": "gas/dwarf2dbg.c",
      "status": "modified",
      "additions": 38,
      "deletions": 38,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/dwarf2dbg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/dwarf2dbg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/dwarf2dbg.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "14d770c40dd8cd3a07146ddccc8c49ec0841cde7",
      "filename": "gas/dwarf2dbg.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/dwarf2dbg.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/dwarf2dbg.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/dwarf2dbg.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "4d7b2ce380d8186cca3ef1413321b64721ca6450",
      "filename": "gas/expr.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/expr.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "5537039edd626894dc42acb97af67133eb00aa5f",
      "filename": "gas/expr.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/expr.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "ca84b2181da0dddc0dd5952f2c8de606cecd4721",
      "filename": "gas/frags.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/frags.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/frags.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/frags.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "bddb9e9efc7313796b771f848efad2bcde4bea9f",
      "filename": "gas/frags.h",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/frags.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/frags.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/frags.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "88f0edf32176b215fdea6a16da80b0481206c15f",
      "filename": "gas/listing.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/listing.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/listing.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/listing.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "72195f7c676557772379b629c59f9dbbf205c650",
      "filename": "gas/macro.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/macro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/macro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/macro.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "80c91fdaad8a09ba43c7555ed4deff270caed65e",
      "filename": "gas/output-file.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/output-file.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/output-file.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/output-file.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "dd7b3e6e4a9a212ded3239a669d476451a8bd155",
      "filename": "gas/read.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/read.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "72919baedc5e856b006e845f0c7d1e6f8bdabd3e",
      "filename": "gas/read.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/read.h?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "8da1147c561cef285218605799e2616c02a78166",
      "filename": "gas/stabs.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/stabs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/stabs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/stabs.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "f3632f13200790fd6b6eaf54f9ba7922b2064e9c",
      "filename": "gas/symbols.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/symbols.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    },
    {
      "sha": "acc7c19b53f3b096e1139c081fe0e5d4bb767bf5",
      "filename": "gas/write.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9/gas/write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/write.c?ref=5b7c81bd8cc80253a48c7045e4d2c8d2bf178eb9"
    }
  ]
}