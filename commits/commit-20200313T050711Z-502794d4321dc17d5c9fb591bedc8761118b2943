{
  "sha": "502794d4321dc17d5c9fb591bedc8761118b2943",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTAyNzk0ZDQzMjFkYzE3ZDVjOWZiNTkxYmVkYzg3NjExMThiMjk0Mw==",
  "commit": {
    "author": {
      "name": "Christian Eggers",
      "email": "ceggers@gmx.de",
      "date": "2020-03-02T20:11:00Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-13T05:07:11Z"
    },
    "message": "Fix several mix up between octets and bytes in ELF program headers\n\nWhen converting between addresses in ELF headers [octets] and bfd\nLMA/VMA [bytes], the number of octets per byte needs to be\nincorporated.\n\nIn ld, the SIZEOF_HEADERS linker script statement must be resolved to\nbytes instead of octets.\n\ninclude/\n\t* elf/internal.h (struct elf_internal_phdr): Add unit (octets)\n\tto several member field comments.\n\t(Elf_Internal_Shdr): likewise.\nbfd/\n\t* elf.c (_bfd_elf_make_section_from_shdr): Introduce new temp\n\topb.  Divide Elf_Internal_Shdr::sh_addr by opb when setting\n\tsection LMA/VMA.\n\t(_bfd_elf_make_section_from_phdr): Similarly.\n\t(elf_fake_sections): Fix calculation of\n\tElf_Internal_shdr::sh_addr from section VMA.\n\t(_bfd_elf_map_sections_to_segments): Fix mixup between octets\n\tand bytes.\n\t(assign_file_positions_for_load_sections): Fix calculations of\n\tElf_Internal_shdr::p_vaddr and p_paddr from section LMA/VMA.  Fix\n\tcomparison between program header address and section LMA.\n\t(assign_file_positions_for_non_load_sections): Likewise.\n\t(rewrite_elf_program_header): Likewise.  Introduce new temp opb.\n\t(IS_CONTAINED_BY_VMA): Add parameter opb.\n\t(IS_CONTAINED_BY_LMA,IS_SECTION_IN_INPUT_SEGMENT,\n\tINCLUDE_SECTION_IN_SEGMENT): Likewise.\n\t(copy_elf_program_header): Update call to ELF_SECTION_IN_SEGMENT.\n\tFix calculations of p_addr_valid and p_vaddr_offset.\n\t* elflink.c (elf_link_add_object_symbols): Multiply section VMA\n\twith octets per byte when comparing against p_vaddr.\nld/\n\t* ldexp.c (fold_name): Return SIZEOF_HEADERS in bytes.",
    "tree": {
      "sha": "626a0ece2f89964ed943c8ebe689573e522734f1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/626a0ece2f89964ed943c8ebe689573e522734f1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/502794d4321dc17d5c9fb591bedc8761118b2943",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/502794d4321dc17d5c9fb591bedc8761118b2943",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/502794d4321dc17d5c9fb591bedc8761118b2943",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/502794d4321dc17d5c9fb591bedc8761118b2943/comments",
  "author": null,
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fd486f32d15e3299b905084a697fac6349c43f76",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd486f32d15e3299b905084a697fac6349c43f76",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fd486f32d15e3299b905084a697fac6349c43f76"
    }
  ],
  "stats": {
    "total": 204,
    "additions": 131,
    "deletions": 73
  },
  "files": [
    {
      "sha": "32549b352086530763dce23ac9b8f834a237eaab",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502794d4321dc17d5c9fb591bedc8761118b2943/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502794d4321dc17d5c9fb591bedc8761118b2943/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=502794d4321dc17d5c9fb591bedc8761118b2943",
      "patch": "@@ -1,3 +1,26 @@\n+2020-03-13  Christian Eggers  <ceggers@gmx.de>\n+\n+\t* elf.c (_bfd_elf_make_section_from_shdr): Introduce new temp\n+\topb.  Divide Elf_Internal_Shdr::sh_addr by opb when setting\n+\tsection LMA/VMA.\n+\t(_bfd_elf_make_section_from_phdr): Similarly.\n+\t(elf_fake_sections): Fix calculation of\n+\tElf_Internal_shdr::sh_addr from section VMA.\n+\t(_bfd_elf_map_sections_to_segments): Fix mixup between octets\n+\tand bytes.\n+\t(assign_file_positions_for_load_sections): Fix calculations of\n+\tElf_Internal_shdr::p_vaddr and p_paddr from section LMA/VMA.  Fix\n+\tcomparison between program header address and section LMA.\n+\t(assign_file_positions_for_non_load_sections): Likewise.\n+\t(rewrite_elf_program_header): Likewise.  Introduce new temp opb.\n+\t(IS_CONTAINED_BY_VMA): Add parameter opb.\n+\t(IS_CONTAINED_BY_LMA,IS_SECTION_IN_INPUT_SEGMENT,\n+\tINCLUDE_SECTION_IN_SEGMENT): Likewise.\n+\t(copy_elf_program_header): Update call to ELF_SECTION_IN_SEGMENT.\n+\tFix calculations of p_addr_valid and p_vaddr_offset.\n+\t* elflink.c (elf_link_add_object_symbols): Multiply section VMA\n+\twith octets per byte when comparing against p_vaddr.\n+\n 2020-03-11  Alan Modra  <amodra@gmail.com>\n \n \t* som.c (setup_sections): Sanity check subspace.name."
    },
    {
      "sha": "049882b87e5a17df240593d5e6dade0d85d8acda",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 75,
      "deletions": 56,
      "changes": 131,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502794d4321dc17d5c9fb591bedc8761118b2943/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502794d4321dc17d5c9fb591bedc8761118b2943/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=502794d4321dc17d5c9fb591bedc8761118b2943",
      "patch": "@@ -1016,6 +1016,7 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,\n   asection *newsect;\n   flagword flags;\n   const struct elf_backend_data *bed;\n+  unsigned int opb = bfd_octets_per_byte (abfd, NULL);\n \n   if (hdr->bfd_section != NULL)\n     return TRUE;\n@@ -1034,11 +1035,6 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,\n \n   newsect->filepos = hdr->sh_offset;\n \n-  if (!bfd_set_section_vma (newsect, hdr->sh_addr)\n-      || !bfd_set_section_size (newsect, hdr->sh_size)\n-      || !bfd_set_section_alignment (newsect, bfd_log2 (hdr->sh_addralign)))\n-    return FALSE;\n-\n   flags = SEC_NO_FLAGS;\n   if (hdr->sh_type != SHT_NOBITS)\n     flags |= SEC_HAS_CONTENTS;\n@@ -1096,14 +1092,22 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,\n \t    flags |= SEC_DEBUGGING | SEC_ELF_OCTETS;\n \t  else if (strncmp (name, GNU_BUILD_ATTRS_SECTION_NAME, 21) == 0\n \t\t   || strncmp (name, \".note.gnu\", 9) == 0)\n-\t    flags |= SEC_ELF_OCTETS;\n+\t    {\n+\t      flags |= SEC_ELF_OCTETS;\n+\t      opb = 1;\n+\t    }\n \t  else if (strncmp (name, \".line\", 5) == 0\n \t\t   || strncmp (name, \".stab\", 5) == 0\n \t\t   || strcmp (name, \".gdb_index\") == 0)\n \t    flags |= SEC_DEBUGGING;\n \t}\n     }\n \n+  if (!bfd_set_section_vma (newsect, hdr->sh_addr / opb)\n+      || !bfd_set_section_size (newsect, hdr->sh_size)\n+      || !bfd_set_section_alignment (newsect, bfd_log2 (hdr->sh_addralign)))\n+    return FALSE;\n+\n   /* As a GNU extension, if the name begins with .gnu.linkonce, we\n      only link a single copy of the section.  This is used to support\n      g++.  g++ will emit each template expansion in its own section.\n@@ -1165,7 +1169,7 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,\n \t    {\n \t      if ((newsect->flags & SEC_LOAD) == 0)\n \t\tnewsect->lma = (phdr->p_paddr\n-\t\t\t\t+ hdr->sh_addr - phdr->p_vaddr);\n+\t\t\t\t+ hdr->sh_addr - phdr->p_vaddr) / opb;\n \t      else\n \t\t/* We used to use the same adjustment for SEC_LOAD\n \t\t   sections, but that doesn't work if the segment\n@@ -1175,7 +1179,7 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,\n \t\t   segment will contain sections with contiguous\n \t\t   LMAs, even if the VMAs are not.  */\n \t\tnewsect->lma = (phdr->p_paddr\n-\t\t\t\t+ hdr->sh_offset - phdr->p_offset);\n+\t\t\t\t+ hdr->sh_offset - phdr->p_offset) / opb;\n \n \t      /* With contiguous segments, we can't tell from file\n \t\t offsets whether a section with zero size should\n@@ -2949,6 +2953,7 @@ _bfd_elf_make_section_from_phdr (bfd *abfd,\n   char namebuf[64];\n   size_t len;\n   int split;\n+  unsigned int opb = bfd_octets_per_byte (abfd, NULL);\n \n   split = ((hdr->p_memsz > 0)\n \t    && (hdr->p_filesz > 0)\n@@ -2965,8 +2970,8 @@ _bfd_elf_make_section_from_phdr (bfd *abfd,\n       newsect = bfd_make_section (abfd, name);\n       if (newsect == NULL)\n \treturn FALSE;\n-      newsect->vma = hdr->p_vaddr;\n-      newsect->lma = hdr->p_paddr;\n+      newsect->vma = hdr->p_vaddr / opb;\n+      newsect->lma = hdr->p_paddr / opb;\n       newsect->size = hdr->p_filesz;\n       newsect->filepos = hdr->p_offset;\n       newsect->flags |= SEC_HAS_CONTENTS;\n@@ -3001,8 +3006,8 @@ _bfd_elf_make_section_from_phdr (bfd *abfd,\n       newsect = bfd_make_section (abfd, name);\n       if (newsect == NULL)\n \treturn FALSE;\n-      newsect->vma = hdr->p_vaddr + hdr->p_filesz;\n-      newsect->lma = hdr->p_paddr + hdr->p_filesz;\n+      newsect->vma = (hdr->p_vaddr + hdr->p_filesz) / opb;\n+      newsect->lma = (hdr->p_paddr + hdr->p_filesz) / opb;\n       newsect->size = hdr->p_memsz - hdr->p_filesz;\n       newsect->filepos = hdr->p_offset + hdr->p_filesz;\n       align = newsect->vma & -newsect->vma;\n@@ -3278,7 +3283,7 @@ elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)\n \n   if ((asect->flags & SEC_ALLOC) != 0\n       || asect->user_set_vma)\n-    this_hdr->sh_addr = asect->vma;\n+    this_hdr->sh_addr = asect->vma * bfd_octets_per_byte (abfd, asect);\n   else\n     this_hdr->sh_addr = 0;\n \n@@ -4669,6 +4674,7 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n       size_t amt;\n       bfd_vma addr_mask, wrap_to = 0;\n       bfd_size_type phdr_size;\n+      unsigned int opb = bfd_octets_per_byte (abfd, NULL);\n \n       /* Select the allocated sections, and sort them.  */\n \n@@ -4708,6 +4714,8 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n       if (phdr_size == (bfd_size_type) -1)\n \tphdr_size = get_program_header_size (abfd, info);\n       phdr_size += bed->s->sizeof_ehdr;\n+      /* phdr_size is compared to LMA values which are in bytes.  */\n+      phdr_size /= opb;\n       maxpagesize = bed->maxpagesize;\n       if (maxpagesize == 0)\n \tmaxpagesize = 1;\n@@ -4932,7 +4940,7 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n \t\texecutable = TRUE;\n \t      last_hdr = hdr;\n \t      /* .tbss sections effectively have zero size.  */\n-\t      last_size = !IS_TBSS (hdr) ? hdr->size : 0;\n+\t      last_size = (!IS_TBSS (hdr) ? hdr->size : 0) / opb;\n \t      continue;\n \t    }\n \n@@ -4958,7 +4966,7 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n \n \t  last_hdr = hdr;\n \t  /* .tbss sections effectively have zero size.  */\n-\t  last_size = !IS_TBSS (hdr) ? hdr->size : 0;\n+\t  last_size = (!IS_TBSS (hdr) ? hdr->size : 0) / opb;\n \t  hdr_index = i;\n \t  phdr_in_segment = FALSE;\n \t}\n@@ -5412,11 +5420,12 @@ assign_file_positions_for_load_sections (bfd *abfd,\n   struct elf_segment_map *phdr_load_seg;\n   Elf_Internal_Phdr *phdrs;\n   Elf_Internal_Phdr *p;\n-  file_ptr off;\n+  file_ptr off;  /* Octets.  */\n   bfd_size_type maxpagesize;\n   unsigned int alloc, actual;\n   unsigned int i, j;\n   struct elf_segment_map **sorted_seg_map;\n+  unsigned int opb = bfd_octets_per_byte (abfd, NULL);\n \n   if (link_info == NULL\n       && !_bfd_elf_map_sections_to_segments (abfd, link_info))\n@@ -5524,7 +5533,7 @@ assign_file_positions_for_load_sections (bfd *abfd,\n   for (j = 0; j < alloc; j++)\n     {\n       asection **secpp;\n-      bfd_vma off_adjust;\n+      bfd_vma off_adjust;  /* Octets.  */\n       bfd_boolean no_contents;\n \n       /* An ELF segment (described by Elf_Internal_Phdr) may contain a\n@@ -5538,16 +5547,16 @@ assign_file_positions_for_load_sections (bfd *abfd,\n       p->p_flags = m->p_flags;\n \n       if (m->count == 0)\n-\tp->p_vaddr = m->p_vaddr_offset;\n+\tp->p_vaddr = m->p_vaddr_offset * opb;\n       else\n-\tp->p_vaddr = m->sections[0]->vma + m->p_vaddr_offset;\n+\tp->p_vaddr = (m->sections[0]->vma + m->p_vaddr_offset) * opb;\n \n       if (m->p_paddr_valid)\n \tp->p_paddr = m->p_paddr;\n       else if (m->count == 0)\n \tp->p_paddr = 0;\n       else\n-\tp->p_paddr = m->sections[0]->lma + m->p_vaddr_offset;\n+\tp->p_paddr = (m->sections[0]->lma + m->p_vaddr_offset) * opb;\n \n       if (p->p_type == PT_LOAD\n \t  && (abfd->flags & D_PAGED) != 0)\n@@ -5628,7 +5637,8 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t      && (abfd->flags & D_PAGED) != 0\n \t      && bed->no_page_alias\n \t      && (off & (maxpagesize - 1)) != 0\n-\t      && (off & -maxpagesize) == ((off + off_adjust) & -maxpagesize))\n+\t      && ((off & -maxpagesize)\n+\t\t  == ((off + off_adjust) & -maxpagesize)))\n \t    off_adjust += maxpagesize;\n \t  off += off_adjust;\n \t  if (no_contents)\n@@ -5719,7 +5729,7 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t      else if (phdr_load_seg != NULL)\n \t\t{\n \t\t  Elf_Internal_Phdr *phdr = phdrs + phdr_load_seg->idx;\n-\t\t  bfd_vma phdr_off = 0;\n+\t\t  bfd_vma phdr_off = 0;  /* Octets.  */\n \t\t  if (phdr_load_seg->includes_filehdr)\n \t\t    phdr_off = bed->s->sizeof_ehdr;\n \t\t  p->p_vaddr = phdr->p_vaddr + phdr_off;\n@@ -5753,7 +5763,7 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t    }\n \t  else\n \t    {\n-\t      file_ptr adjust;\n+\t      file_ptr adjust;  /* Octets.  */\n \n \t      adjust = off - (p->p_offset + p->p_filesz);\n \t      if (!no_contents)\n@@ -5784,10 +5794,10 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t\t      && ((this_hdr->sh_flags & SHF_TLS) == 0\n \t\t\t  || p->p_type == PT_TLS))))\n \t    {\n-\t      bfd_vma p_start = p->p_paddr;\n-\t      bfd_vma p_end = p_start + p->p_memsz;\n-\t      bfd_vma s_start = sec->lma;\n-\t      bfd_vma adjust = s_start - p_end;\n+\t      bfd_vma p_start = p->p_paddr;                /* Octets.  */\n+\t      bfd_vma p_end = p_start + p->p_memsz;        /* Octets.  */\n+\t      bfd_vma s_start = sec->lma * opb;            /* Octets.  */\n+\t      bfd_vma adjust = s_start - p_end;            /* Octets.  */\n \n \t      if (adjust != 0\n \t\t  && (s_start < p_end\n@@ -5796,9 +5806,10 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t\t  _bfd_error_handler\n \t\t    /* xgettext:c-format */\n \t\t    (_(\"%pB: section %pA lma %#\" PRIx64 \" adjusted to %#\" PRIx64),\n-\t\t     abfd, sec, (uint64_t) s_start, (uint64_t) p_end);\n+\t\t     abfd, sec, (uint64_t) s_start / opb,\n+\t\t     (uint64_t) p_end / opb);\n \t\t  adjust = 0;\n-\t\t  sec->lma = p_end;\n+\t\t  sec->lma = p_end / opb;\n \t\t}\n \t      p->p_memsz += adjust;\n \n@@ -6188,8 +6199,11 @@ assign_file_positions_for_non_load_sections (bfd *abfd,\n \n \t\t  if (i < lm->count)\n \t\t    {\n-\t\t      p->p_vaddr = lm->sections[i]->vma;\n-\t\t      p->p_paddr = lm->sections[i]->lma;\n+\t\t      unsigned int opb = bfd_octets_per_byte (abfd,\n+\t\t\t\t\t\t\t      lm->sections[i]);\n+\n+\t\t      p->p_vaddr = lm->sections[i]->vma * opb;\n+\t\t      p->p_paddr = lm->sections[i]->lma * opb;\n \t\t      p->p_offset = lm->sections[i]->filepos;\n \t\t      p->p_memsz = end - p->p_vaddr;\n \t\t      p->p_filesz = p->p_memsz;\n@@ -6788,6 +6802,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n   struct elf_segment_map *phdr_adjust_seg = NULL;\n   unsigned int phdr_adjust_num = 0;\n   const struct elf_backend_data *bed;\n+  unsigned int opb = bfd_octets_per_byte (ibfd, NULL);\n \n   bed = get_elf_backend_data (ibfd);\n   iehdr = elf_elfheader (ibfd);\n@@ -6810,17 +6825,17 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \n   /* Returns TRUE if the given section is contained within\n      the given segment.  VMA addresses are compared.  */\n-#define IS_CONTAINED_BY_VMA(section, segment)\t\t\t\t\\\n-  (section->vma >= segment->p_vaddr\t\t\t\t\t\\\n-   && (section->vma + SECTION_SIZE (section, segment)\t\t\t\\\n+#define IS_CONTAINED_BY_VMA(section, segment, opb)\t\t\t\\\n+  (section->vma * (opb) >= segment->p_vaddr\t\t\t\t\\\n+   && (section->vma * (opb) + SECTION_SIZE (section, segment)\t\t\\\n        <= (SEGMENT_END (segment, segment->p_vaddr))))\n \n   /* Returns TRUE if the given section is contained within\n      the given segment.  LMA addresses are compared.  */\n-#define IS_CONTAINED_BY_LMA(section, segment, base)\t\t\t\\\n-  (section->lma >= base\t\t\t\t\t\t\t\\\n-   && (section->lma + SECTION_SIZE (section, segment) >= section->lma)\t\\\n-   && (section->lma + SECTION_SIZE (section, segment)\t\t\t\\\n+#define IS_CONTAINED_BY_LMA(section, segment, base, opb)\t\t\\\n+  (section->lma * (opb) >= base\t\t\t\t\t\t\\\n+   && (section->lma + SECTION_SIZE (section, segment) / (opb) >= section->lma) \\\n+   && (section->lma * (opb) + SECTION_SIZE (section, segment)\t\t\\\n        <= SEGMENT_END (segment, base)))\n \n   /* Handle PT_NOTE segment.  */\n@@ -6866,10 +6881,10 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n        7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.\n        8. PT_DYNAMIC should not contain empty sections at the beginning\n \t  (with the possible exception of .dynamic).  */\n-#define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed)\t\t\\\n+#define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)\t\t\\\n   ((((segment->p_paddr\t\t\t\t\t\t\t\\\n-      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)\t\\\n-      : IS_CONTAINED_BY_VMA (section, segment))\t\t\t\t\\\n+      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr, opb)\t\\\n+      : IS_CONTAINED_BY_VMA (section, segment, opb))\t\t\t\\\n      && (section->flags & SEC_ALLOC) != 0)\t\t\t\t\\\n     || IS_NOTE (segment, section))\t\t\t\t\t\\\n    && segment->p_type != PT_GNU_STACK\t\t\t\t\t\\\n@@ -6881,15 +6896,15 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n    && (segment->p_type != PT_DYNAMIC\t\t\t\t\t\\\n        || SECTION_SIZE (section, segment) > 0\t\t\t\t\\\n        || (segment->p_paddr\t\t\t\t\t\t\\\n-\t   ? segment->p_paddr != section->lma\t\t\t\t\\\n-\t   : segment->p_vaddr != section->vma)\t\t\t\t\\\n+\t   ? segment->p_paddr != section->lma * (opb)\t\t\t\\\n+\t   : segment->p_vaddr != section->vma * (opb))\t\t\t\\\n        || (strcmp (bfd_section_name (section), \".dynamic\") == 0))\t\\\n    && (segment->p_type != PT_LOAD || !section->segment_mark))\n \n /* If the output section of a section in the input segment is NULL,\n    it is removed from the corresponding output segment.   */\n-#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed)\t\t\\\n-  (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed)\t\t\\\n+#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed, opb)\t\t\\\n+  (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb)\t\t\\\n    && section->output_section != NULL)\n \n   /* Returns TRUE iff seg1 starts after the end of seg2.  */\n@@ -6943,7 +6958,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \t    {\n \t      /* Mininal change so that the normal section to segment\n \t\t assignment code will work.  */\n-\t      segment->p_vaddr = section->vma;\n+\t      segment->p_vaddr = section->vma * opb;\n \t      break;\n \t    }\n \n@@ -7029,7 +7044,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \t{\n \t  /* Find the first section in the input segment, which may be\n \t     removed from the corresponding output segment.   */\n-\t  if (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed))\n+\t  if (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb))\n \t    {\n \t      if (first_section == NULL)\n \t\tfirst_section = section;\n@@ -7097,7 +7112,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \t\t \" at vaddr=%#\" PRIx64 \", is this intentional?\"),\n \t       ibfd, (uint64_t) segment->p_vaddr);\n \n-\t  map->p_vaddr_offset = segment->p_vaddr;\n+\t  map->p_vaddr_offset = segment->p_vaddr / opb;\n \t  map->count = 0;\n \t  *pointer_to_map = map;\n \t  pointer_to_map = &map->next;\n@@ -7152,7 +7167,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \t   section != NULL;\n \t   section = section->next)\n \t{\n-\t  if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))\n+\t  if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed, opb))\n \t    {\n \t      output_section = section->output_section;\n \n@@ -7179,10 +7194,11 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \n \t      /* Match up the physical address of the segment with the\n \t\t LMA address of the output section.  */\n-\t      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr)\n+\t      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,\n+\t\t\t\t       opb)\n \t\t  || IS_COREFILE_NOTE (segment, section)\n \t\t  || (bed->want_p_paddr_set_to_zero\n-\t\t      && IS_CONTAINED_BY_VMA (output_section, segment)))\n+\t\t      && IS_CONTAINED_BY_VMA (output_section, segment, opb)))\n \t\t{\n \t\t  if (matching_lma == NULL\n \t\t      || output_section->lma < matching_lma->lma)\n@@ -7226,7 +7242,8 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \n \t      /* Account for padding before the first section in the\n \t\t segment.  */\n-\t      map->p_vaddr_offset = map->p_paddr + hdr_size - matching_lma->lma;\n+\t      map->p_vaddr_offset = ((map->p_paddr + hdr_size) / opb\n+\t\t\t\t     - matching_lma->lma);\n \t    }\n \n \t  free (sections);\n@@ -7297,7 +7314,8 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \n \t      BFD_ASSERT (output_section != NULL);\n \n-\t      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr)\n+\t      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,\n+\t\t\t\t       opb)\n \t\t  || IS_COREFILE_NOTE (segment, section))\n \t\t{\n \t\t  if (map->count == 0)\n@@ -7449,6 +7467,7 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)\n   unsigned int num_segments;\n   bfd_boolean phdr_included = FALSE;\n   bfd_boolean p_paddr_valid;\n+  unsigned int opb = bfd_octets_per_byte (ibfd, NULL);\n \n   iehdr = elf_elfheader (ibfd);\n \n@@ -7574,7 +7593,7 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)\n \t\t\tseg_off = this_hdr->sh_offset - segment->p_offset;\n \t\t      else\n \t\t\tseg_off = this_hdr->sh_addr - segment->p_vaddr;\n-\t\t      if (section->lma - segment->p_paddr != seg_off)\n+\t\t      if (section->lma * opb - segment->p_paddr != seg_off)\n \t\t\tmap->p_paddr_valid = FALSE;\n \t\t    }\n \t\t  if (isec == section_count)\n@@ -7584,7 +7603,7 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)\n \t}\n \n       if (section_count == 0)\n-\tmap->p_vaddr_offset = segment->p_vaddr;\n+\tmap->p_vaddr_offset = segment->p_vaddr / opb;\n       else if (map->p_paddr_valid)\n \t{\n \t  /* Account for padding before the first section in the segment.  */\n@@ -7594,7 +7613,7 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)\n \t  if (map->includes_phdrs)\n \t    hdr_size += iehdr->e_phnum * iehdr->e_phentsize;\n \n-\t  map->p_vaddr_offset = (map->p_paddr + hdr_size\n+\t  map->p_vaddr_offset = ((map->p_paddr + hdr_size) / opb\n \t\t\t\t - (lowest_section ? lowest_section->lma : 0));\n \t}\n "
    },
    {
      "sha": "369f3cb3e7bef6baa0e5e23d4bb2bfe2a7b20db0",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502794d4321dc17d5c9fb591bedc8761118b2943/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502794d4321dc17d5c9fb591bedc8761118b2943/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=502794d4321dc17d5c9fb591bedc8761118b2943",
      "patch": "@@ -4218,10 +4218,14 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n \tif (phdr->p_type == PT_GNU_RELRO)\n \t  {\n \t    for (s = abfd->sections; s != NULL; s = s->next)\n-\t      if ((s->flags & SEC_ALLOC) != 0\n-\t\t  && s->vma >= phdr->p_vaddr\n-\t\t  && s->vma + s->size <= phdr->p_vaddr + phdr->p_memsz)\n-\t\ts->flags |= SEC_READONLY;\n+\t      {\n+\t\tunsigned int opb = bfd_octets_per_byte (abfd, s);\n+\n+\t\tif ((s->flags & SEC_ALLOC) != 0\n+\t\t    && s->vma * opb >= phdr->p_vaddr\n+\t\t    && s->vma * opb + s->size <= phdr->p_vaddr + phdr->p_memsz)\n+\t\t  s->flags |= SEC_READONLY;\n+\t      }\n \t    break;\n \t  }\n "
    },
    {
      "sha": "aa2c5516723008766dfad0110627b13402fd2e9b",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502794d4321dc17d5c9fb591bedc8761118b2943/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502794d4321dc17d5c9fb591bedc8761118b2943/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=502794d4321dc17d5c9fb591bedc8761118b2943",
      "patch": "@@ -1,3 +1,9 @@\n+2020-03-13  Christian Eggers  <ceggers@gmx.de>\n+\n+\t* elf/internal.h (struct elf_internal_phdr): Add unit (octets)\n+\tto several member field comments.\n+\t(Elf_Internal_Shdr): likewise.\n+\n 2020-03-10  Alan Modra  <amodra@gmail.com>\n \n \t* som/aout.h (SOM_AUX_ID_MANDATORY, SOM_SPACE_IS_LOADABLE),"
    },
    {
      "sha": "d626adece5bd98255875b687019b3ab9d155129a",
      "filename": "include/elf/internal.h",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502794d4321dc17d5c9fb591bedc8761118b2943/include/elf/internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502794d4321dc17d5c9fb591bedc8761118b2943/include/elf/internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/elf/internal.h?ref=502794d4321dc17d5c9fb591bedc8761118b2943",
      "patch": "@@ -84,14 +84,14 @@ typedef struct elf_internal_ehdr {\n /* Program header */\n \n struct elf_internal_phdr {\n-  unsigned long\tp_type;\t\t\t/* Identifies program segment type */\n-  unsigned long\tp_flags;\t\t/* Segment flags */\n-  bfd_vma\tp_offset;\t\t/* Segment file offset */\n-  bfd_vma\tp_vaddr;\t\t/* Segment virtual address */\n-  bfd_vma\tp_paddr;\t\t/* Segment physical address */\n-  bfd_vma\tp_filesz;\t\t/* Segment size in file */\n-  bfd_vma\tp_memsz;\t\t/* Segment size in memory */\n-  bfd_vma\tp_align;\t\t/* Segment alignment, file & memory */\n+  unsigned long\tp_type;\t\t     /* Identifies program segment type.  */\n+  unsigned long\tp_flags;\t     /* Segment flags.  */\n+  bfd_vma\tp_offset;\t     /* Segment file offset in octets.  */\n+  bfd_vma\tp_vaddr;\t     /* Segment virtual address in octets.  */\n+  bfd_vma\tp_paddr;\t     /* Segment physical address in octets.  */\n+  bfd_vma\tp_filesz;\t     /* Segment size in file in octets.  */\n+  bfd_vma\tp_memsz;\t     /* Segment size in memory in octets.  */\n+  bfd_vma\tp_align;\t     /* Segment alignment, file & memory.  */\n };\n \n typedef struct elf_internal_phdr Elf_Internal_Phdr;\n@@ -102,9 +102,10 @@ typedef struct elf_internal_shdr {\n   unsigned int\tsh_name;\t\t/* Section name, index in string tbl */\n   unsigned int\tsh_type;\t\t/* Type of section */\n   bfd_vma\tsh_flags;\t\t/* Miscellaneous section attributes */\n-  bfd_vma\tsh_addr;\t\t/* Section virtual addr at execution */\n-  file_ptr\tsh_offset;\t\t/* Section file offset */\n-  bfd_size_type\tsh_size;\t\t/* Size of section in bytes */\n+  bfd_vma\tsh_addr;\t\t/* Section virtual addr at execution in\n+\t\t\t\t\t   octets.  */\n+  file_ptr\tsh_offset;\t\t/* Section file offset in octets.  */\n+  bfd_size_type\tsh_size;\t\t/* Size of section in octets.  */\n   unsigned int\tsh_link;\t\t/* Index of another section */\n   unsigned int\tsh_info;\t\t/* Additional section information */\n   bfd_vma\tsh_addralign;\t\t/* Section alignment */\n@@ -267,7 +268,7 @@ struct elf_segment_map\n   unsigned long p_flags;\n   /* Program segment physical address.  */\n   bfd_vma p_paddr;\n-  /* Program segment virtual address offset from section vma.  */\n+  /* Program segment virtual address offset from section vma in bytes.  */\n   bfd_vma p_vaddr_offset;\n   /* Program segment alignment.  */\n   bfd_vma p_align;"
    },
    {
      "sha": "8ac66fc2e58bdca2aea702b7022d97d9a4de74e3",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502794d4321dc17d5c9fb591bedc8761118b2943/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502794d4321dc17d5c9fb591bedc8761118b2943/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=502794d4321dc17d5c9fb591bedc8761118b2943",
      "patch": "@@ -1,3 +1,7 @@\n+2020-03-13  Christian Eggers  <ceggers@gmx.de>\n+\n+\t* ldexp.c (fold_name): Return SIZEOF_HEADERS in bytes.\n+\n 2020-03-11  Alan Modra  <amodra@gmail.com>\n \n \t* ldelf.c (elf_orphan_compatible): Return false when two sections"
    },
    {
      "sha": "3ffabb8c1da6e2f2677b1dc63e25e7ee92221c03",
      "filename": "ld/ldexp.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502794d4321dc17d5c9fb591bedc8761118b2943/ld/ldexp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502794d4321dc17d5c9fb591bedc8761118b2943/ld/ldexp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldexp.c?ref=502794d4321dc17d5c9fb591bedc8761118b2943",
      "patch": "@@ -700,7 +700,8 @@ fold_name (etree_type *tree)\n \t  /* Don't find the real header size if only marking sections;\n \t     The bfd function may cache incorrect data.  */\n \t  if (expld.phase != lang_mark_phase_enum)\n-\t    hdr_size = bfd_sizeof_headers (link_info.output_bfd, &link_info);\n+\t    hdr_size = (bfd_sizeof_headers (link_info.output_bfd, &link_info)\n+\t\t\t/ bfd_octets_per_byte (link_info.output_bfd, NULL));\n \t  new_number (hdr_size);\n \t}\n       break;"
    }
  ]
}