{
  "sha": "6d1ad6f7834d62bedec138aaf3ac872c60702ecd",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmQxYWQ2Zjc4MzRkNjJiZWRlYzEzOGFhZjNhYzg3MmM2MDcwMmVjZA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-12T03:21:52Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-12T11:47:35Z"
    },
    "message": "SAFE_BYTE_GET\n\nThis rearranges SAFE_BYTE_GET* macros, eliminating some duplication,\nand making sure that the _INC variants never increment their PTR arg\npast END.  I've added an assertion that should show us places where we\nuse them improperly with user derived PTR args, which I'm sure the\nfuzzers will find for us.\n\n\t* dwarf.c (SAFE_BYTE_GET_INTERNAL): Define.\n\t(SAFE_BYTE_GET, SAFE_BYTE_GET_AND_INC): Define using the above.\n\t(SAFE_SIGNED_BYTE_GET, SAFE_SIGNED_BYTE_GET_AND_INC): Likewise.\n\t(display_discr_list): Use SAFE_BYTE_GET_AND_INC rather than\n\tSAFE_BYTE_GET followed by increment.\n\t(process_debug_info): Likewise, and test bytes remaining before\n\tincrementing section_begin rather than using pointer comparison.\n\t(display_debug_names): Pass lvalue as SAFE_BYTE_GET PTR.\n\t(process_cu_tu_index): Likewise for SAFE_BYTE_GET_AND_INC.",
    "tree": {
      "sha": "5cc97c318071d405f410fd3c295269811a3a1f1b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5cc97c318071d405f410fd3c295269811a3a1f1b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6d1ad6f7834d62bedec138aaf3ac872c60702ecd",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d1ad6f7834d62bedec138aaf3ac872c60702ecd",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6d1ad6f7834d62bedec138aaf3ac872c60702ecd",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d1ad6f7834d62bedec138aaf3ac872c60702ecd/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a"
    }
  ],
  "stats": {
    "total": 155,
    "additions": 73,
    "deletions": 82
  },
  "files": [
    {
      "sha": "a100b7047b4f6d6e6b4b2301163436bd5b280f4c",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d1ad6f7834d62bedec138aaf3ac872c60702ecd/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d1ad6f7834d62bedec138aaf3ac872c60702ecd/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=6d1ad6f7834d62bedec138aaf3ac872c60702ecd",
      "patch": "@@ -1,3 +1,15 @@\n+2021-05-12  Alan Modra  <amodra@gmail.com>\n+\n+\t* dwarf.c (SAFE_BYTE_GET_INTERNAL): Define.\n+\t(SAFE_BYTE_GET, SAFE_BYTE_GET_AND_INC): Define using the above.\n+\t(SAFE_SIGNED_BYTE_GET, SAFE_SIGNED_BYTE_GET_AND_INC): Likewise.\n+\t(display_discr_list): Use SAFE_BYTE_GET_AND_INC rather than\n+\tSAFE_BYTE_GET followed by increment.\n+\t(process_debug_info): Likewise, and test bytes remaining before\n+\tincrementing section_begin rather than using pointer comparison.\n+\t(display_debug_names): Pass lvalue as SAFE_BYTE_GET PTR.\n+\t(process_cu_tu_index): Likewise for SAFE_BYTE_GET_AND_INC.\n+\n 2021-05-12  Alan Modra  <amodra@gmail.com>\n \n \t* dwarf.c (dwarf_vmatoa64, SAFE_BYTE_GET64, add64): Delete."
    },
    {
      "sha": "e297a3d0dcca8d1675932baf409bb3d5d2741348",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 61,
      "deletions": 82,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d1ad6f7834d62bedec138aaf3ac872c60702ecd/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d1ad6f7834d62bedec138aaf3ac872c60702ecd/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=6d1ad6f7834d62bedec138aaf3ac872c60702ecd",
      "patch": "@@ -368,73 +368,52 @@ read_leb128 (unsigned char *data,\n   return result;\n }\n \n-/* Read AMOUNT bytes from PTR and store them in VAL as an unsigned value.\n-   Checks to make sure that the read will not reach or pass END\n-   and that VAL is big enough to hold AMOUNT bytes.  */\n-#define SAFE_BYTE_GET(VAL, PTR, AMOUNT, END)\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      unsigned int amount = (AMOUNT);\t\t\\\n-      if (sizeof (VAL) < amount)\t\t\\\n-\t{\t\t\t\t\t\\\n+/* Read AMOUNT bytes from PTR and store them in VAL.\n+   Checks to make sure that the read will not reach or pass END.\n+   FUNC chooses whether the value read is unsigned or signed, and may\n+   be either byte_get or byte_get_signed.  If INC is true, PTR is\n+   incremented after reading the value.\n+   This macro cannot protect against PTR values derived from user input.\n+   The C standard sections 6.5.6 and 6.5.8 say attempts to do so using\n+   pointers is undefined behaviour.  */\n+#define SAFE_BYTE_GET_INTERNAL(VAL, PTR, AMOUNT, END, FUNC, INC)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      size_t amount = (AMOUNT);\t\t\t\t\t\t\\\n+      if (sizeof (VAL) < amount)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n \t  error (ngettext (\"internal error: attempt to read %d byte \"\t\\\n \t\t\t   \"of data in to %d sized variable\",\t\t\\\n \t\t\t   \"internal error: attempt to read %d bytes \"\t\\\n \t\t\t   \"of data in to %d sized variable\",\t\t\\\n \t\t\t   amount),\t\t\t\t\t\\\n-\t\t amount, (int) sizeof (VAL));\t\\\n-\t  amount = sizeof (VAL);\t\t\\\n-\t}\t\t\t\t\t\\\n-      if ((PTR) >= (END) - amount)\t\t\\\n-\t{\t\t\t\t\t\\\n-\t  if ((PTR) < (END))\t\t\t\\\n-\t    amount = (END) - (PTR);\t\t\\\n-\t  else\t\t\t\t\t\\\n-\t    amount = 0;\t\t\t\t\\\n-\t}\t\t\t\t\t\\\n-      if (amount == 0 || amount > 8)\t\t\\\n-\tVAL = 0;\t\t\t\t\\\n-      else\t\t\t\t\t\\\n-\tVAL = byte_get ((PTR), amount);\t\t\\\n-    }\t\t\t\t\t\t\\\n+\t\t (int) amount, (int) sizeof (VAL));\t\t\t\\\n+\t  amount = sizeof (VAL);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      assert ((PTR) <= (END));\t\t\t\t\t\t\\\n+      size_t avail = (END) - (PTR);\t\t\t\t\t\\\n+      if (amount > avail)\t\t\t\t\t\t\\\n+\tamount = avail;\t\t\t\t\t\t\t\\\n+      if (amount == 0)\t\t\t\t\t\t\t\\\n+\t(VAL) = 0;\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t(VAL) = (FUNC) ((PTR), amount);\t\t\t\t\t\\\n+      if (INC)\t\t\t\t\t\t\t\t\\\n+\t(PTR) += amount;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* Like SAFE_BYTE_GET, but also increments PTR by AMOUNT.  */\n+#define SAFE_BYTE_GET(VAL, PTR, AMOUNT, END)\t\\\n+  SAFE_BYTE_GET_INTERNAL (VAL, PTR, AMOUNT, END, byte_get, false)\n+\n #define SAFE_BYTE_GET_AND_INC(VAL, PTR, AMOUNT, END)\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      SAFE_BYTE_GET (VAL, PTR, AMOUNT, END);\t\t\\\n-      PTR += AMOUNT;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n+  SAFE_BYTE_GET_INTERNAL (VAL, PTR, AMOUNT, END, byte_get, true)\n \n-/* Like SAFE_BYTE_GET, but reads a signed value.  */\n #define SAFE_SIGNED_BYTE_GET(VAL, PTR, AMOUNT, END)\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      unsigned int amount = (AMOUNT);\t\t\t\\\n-      if ((PTR) >= (END) - amount)\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  if ((PTR) < (END))\t\t\t\t\\\n-\t    amount = (END) - (PTR);\t\t\t\\\n-\t  else\t\t\t\t\t\t\\\n-\t    amount = 0;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      if (amount)\t\t\t\t\t\\\n-\tVAL = byte_get_signed ((PTR), amount);\t\t\\\n-      else\t\t\t\t\t\t\\\n-\tVAL = 0;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n+  SAFE_BYTE_GET_INTERNAL (VAL, PTR, AMOUNT, END, byte_get_signed, false)\n \n-/* Like SAFE_SIGNED_BYTE_GET, but also increments PTR by AMOUNT.  */\n #define SAFE_SIGNED_BYTE_GET_AND_INC(VAL, PTR, AMOUNT, END)\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      SAFE_SIGNED_BYTE_GET (VAL, PTR, AMOUNT, END);\t\t\\\n-      PTR += AMOUNT;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n+  SAFE_BYTE_GET_INTERNAL (VAL, PTR, AMOUNT, END, byte_get_signed, true)\n \n typedef struct State_Machine_Registers\n {\n@@ -2336,9 +2315,8 @@ display_discr_list (unsigned long          form,\n       unsigned char     discriminant;\n       unsigned int      bytes_read;\n \n-      SAFE_BYTE_GET (discriminant, data, 1, end);\n+      SAFE_BYTE_GET_AND_INC (discriminant, data, 1, end);\n       -- uvalue;\n-      data ++;\n \n       assert (uvalue > 0);\n       switch (discriminant)\n@@ -3455,31 +3433,27 @@ process_debug_info (struct dwarf_section * section,\n \t  /* Read the first 4 bytes.  For a 32-bit DWARF section, this\n \t     will be the length.  For a 64-bit DWARF section, it'll be\n \t     the escape code 0xffffffff followed by an 8 byte length.  */\n-\t  SAFE_BYTE_GET (length, section_begin, 4, end);\n+\t  SAFE_BYTE_GET_AND_INC (length, section_begin, 4, end);\n \n \t  if (length == 0xffffffff)\n-\t    {\n-\t      SAFE_BYTE_GET (length, section_begin + 4, 8, end);\n-\t      section_begin += length + 12;\n-\t    }\n+\t    SAFE_BYTE_GET_AND_INC (length, section_begin, 8, end);\n \t  else if (length >= 0xfffffff0 && length < 0xffffffff)\n \t    {\n \t      warn (_(\"Reserved length value (0x%s) found in section %s\\n\"),\n \t\t    dwarf_vmatoa (\"x\", length), section->name);\n \t      return false;\n \t    }\n-\t  else\n-\t    section_begin += length + 4;\n \n \t  /* Negative values are illegal, they may even cause infinite\n \t     looping.  This can happen if we can't accurately apply\n \t     relocations to an object file, or if the file is corrupt.  */\n-\t  if ((signed long) length <= 0 || section_begin < start)\n+\t  if (length > (size_t) (end - section_begin))\n \t    {\n \t      warn (_(\"Corrupt unit length (0x%s) found in section %s\\n\"),\n \t\t    dwarf_vmatoa (\"x\", length), section->name);\n \t      return false;\n \t    }\n+\t  section_begin += length;\n \t}\n \n       if (num_units == 0)\n@@ -9829,13 +9803,12 @@ display_debug_names (struct dwarf_section *section, void *file)\n       for (namei = 0; namei < name_count; ++namei)\n \t{\n \t  uint64_t string_offset, entry_offset;\n+\t  unsigned char *p;\n \n-\t  SAFE_BYTE_GET (string_offset,\n-\t\t\t name_table_string_offsets + namei * offset_size,\n-\t\t\t offset_size, unit_end);\n-\t  SAFE_BYTE_GET (entry_offset,\n-\t\t\t name_table_entry_offsets + namei * offset_size,\n-\t\t\t offset_size, unit_end);\n+\t  p = name_table_string_offsets + namei * offset_size;\n+\t  SAFE_BYTE_GET (string_offset, p, offset_size, unit_end);\n+\t  p = name_table_entry_offsets + namei * offset_size;\n+\t  SAFE_BYTE_GET (entry_offset, p, offset_size, unit_end);\n \n \t  printf (\"[%3u] #%08x %s:\", namei, hash_table_hashes[namei],\n \t\t  fetch_indirect_string (string_offset));\n@@ -10333,13 +10306,13 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n       return 0;\n     }\n \n-  SAFE_BYTE_GET (version, phdr, 4, limit);\n+  phash = phdr;\n+  SAFE_BYTE_GET_AND_INC (version, phash, 4, limit);\n   if (version >= 2)\n-    SAFE_BYTE_GET (ncols, phdr + 4, 4, limit);\n-  SAFE_BYTE_GET (nused, phdr + 8, 4, limit);\n-  SAFE_BYTE_GET (nslots, phdr + 12, 4, limit);\n+    SAFE_BYTE_GET_AND_INC (ncols, phash, 4, limit);\n+  SAFE_BYTE_GET_AND_INC (nused, phash, 4, limit);\n+  SAFE_BYTE_GET_AND_INC (nslots, phash, 4, limit);\n \n-  phash = phdr + 16;\n   pindex = phash + (size_t) nslots * 8;\n   ppool = pindex + (size_t) nslots * 4;\n \n@@ -10474,7 +10447,8 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \t{\n \t  for (j = 0; j < ncols; j++)\n \t    {\n-\t      SAFE_BYTE_GET (dw_sect, ppool + j * 4, 4, limit);\n+\t      unsigned char *p = ppool + j * 4;\n+\t      SAFE_BYTE_GET (dw_sect, p, 4, limit);\n \t      printf (\" %8s\", get_DW_SECT_short_name (dw_sect));\n \t    }\n \t  printf (\"\\n\");\n@@ -10523,12 +10497,14 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \t\t\ti, dwarf_vmatoa (\"x\", signature));\n \t      for (j = 0; j < ncols; j++)\n \t\t{\n-\t\t  SAFE_BYTE_GET (val, prow + j * 4, 4, limit);\n+\t\t  unsigned char *p = prow + j * 4;\n+\t\t  SAFE_BYTE_GET (val, p, 4, limit);\n \t\t  if (do_display)\n \t\t    printf (\" %8d\", val);\n \t\t  else\n \t\t    {\n-\t\t      SAFE_BYTE_GET (dw_sect, ppool + j * 4, 4, limit);\n+\t\t      p = ppool + j * 4;\n+\t\t      SAFE_BYTE_GET (dw_sect, p, 4, limit);\n \n \t\t      /* PR 17531: file: 10796eb3.  */\n \t\t      if (dw_sect >= DW_SECT_MAX)\n@@ -10557,7 +10533,8 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \n       for (j = 0; j < ncols; j++)\n \t{\n-\t  SAFE_BYTE_GET (val, ppool + j * 4, 4, limit);\n+\t  unsigned char *p = ppool + j * 4;\n+\t  SAFE_BYTE_GET (val, p, 4, limit);\n \t  if (do_display)\n \t    printf (\" %8s\", get_DW_SECT_short_name (val));\n \t}\n@@ -10580,12 +10557,14 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \n \t      for (j = 0; j < ncols; j++)\n \t\t{\n-\t\t  SAFE_BYTE_GET (val, prow + j * 4, 4, limit);\n+\t\t  unsigned char *p = prow + j * 4;\n+\t\t  SAFE_BYTE_GET (val, p, 4, limit);\n \t\t  if (do_display)\n \t\t    printf (\" %8d\", val);\n \t\t  else\n \t\t    {\n-\t\t      SAFE_BYTE_GET (dw_sect, ppool + j * 4, 4, limit);\n+\t\t      p = ppool + j * 4;\n+\t\t      SAFE_BYTE_GET (dw_sect, p, 4, limit);\n \t\t      if (dw_sect >= DW_SECT_MAX)\n \t\t\twarn (_(\"Overlarge Dwarf section index detected: %u\\n\"), dw_sect);\n \t\t      else"
    }
  ]
}