{
  "sha": "bab37966cfd192a12d5d1d259c7009a02cefe8b3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmFiMzc5NjZjZmQxOTJhMTJkNWQxZDI1OWM3MDA5YTAyY2VmZThiMw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-04T21:43:54Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-04T21:43:54Z"
    },
    "message": "gdb: introduce status enum for displaced step prepare/finish\n\nThis is a preparatory patch to reduce the size of the diff of the\nupcoming main patch.  It introduces enum types for the return values of\ndisplaced step \"prepare\" and \"finish\" operations.  I find that this\nexpresses better the intention of the code, rather than returning\narbitrary integer values (-1, 0 and 1) which are difficult to remember.\nThat makes the code easier to read.\n\nI put the new enum types in a new displaced-stepping.h file, because I\nintroduce that file in a later patch anyway.  Putting it there avoids\nhaving to move it later.\n\nThere is one change in behavior for displaced_step_finish: it currently\nreturns 0 if the thread wasn't doing a displaced step and 1 if the\nthread was doing a displaced step which was executed successfully.  It\nturns out that this distinction is not needed by any caller, so I've\nmerged these two cases into \"_OK\", rather than adding an extra\nenumerator.\n\ngdb/ChangeLog:\n\n\t* infrun.c (displaced_step_prepare_throw): Change return type to\n\tdisplaced_step_prepare_status.\n\t(displaced_step_prepare): Likewise.\n\t(displaced_step_finish): Change return type to\n\tdisplaced_step_finish_status.\n\t(resume_1): Adjust.\n\t(stop_all_threads): Adjust.\n\t* displaced-stepping.h: New file.\n\nChange-Id: I5c8fe07212cd398d5b486b5936d9d0807acd3788",
    "tree": {
      "sha": "cd931b82c874bb51a037e25c5a887282f34fff4f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cd931b82c874bb51a037e25c5a887282f34fff4f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bab37966cfd192a12d5d1d259c7009a02cefe8b3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bab37966cfd192a12d5d1d259c7009a02cefe8b3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bab37966cfd192a12d5d1d259c7009a02cefe8b3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bab37966cfd192a12d5d1d259c7009a02cefe8b3/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7def77a1cf6bfd9d3640701dc3414feb0034a858",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7def77a1cf6bfd9d3640701dc3414feb0034a858",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7def77a1cf6bfd9d3640701dc3414feb0034a858"
    }
  ],
  "stats": {
    "total": 130,
    "additions": 100,
    "deletions": 30
  },
  "files": [
    {
      "sha": "0fe4b27c585e4d424a12218415ed10a054824f5c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab37966cfd192a12d5d1d259c7009a02cefe8b3/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab37966cfd192a12d5d1d259c7009a02cefe8b3/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=bab37966cfd192a12d5d1d259c7009a02cefe8b3",
      "patch": "@@ -1,3 +1,14 @@\n+2020-12-04  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* infrun.c (displaced_step_prepare_throw): Change return type to\n+\tdisplaced_step_prepare_status.\n+\t(displaced_step_prepare): Likewise.\n+\t(displaced_step_finish): Change return type to\n+\tdisplaced_step_finish_status.\n+\t(resume_1): Adjust.\n+\t(stop_all_threads): Adjust.\n+\t* displaced-stepping.h: New file.\n+\n 2020-12-04  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* infrun.c (displaced_step_fixup): Rename to..."
    },
    {
      "sha": "44aca74111d2d6d134efe14e996cc1dd8c6e6411",
      "filename": "gdb/displaced-stepping.h",
      "status": "added",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab37966cfd192a12d5d1d259c7009a02cefe8b3/gdb/displaced-stepping.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab37966cfd192a12d5d1d259c7009a02cefe8b3/gdb/displaced-stepping.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/displaced-stepping.h?ref=bab37966cfd192a12d5d1d259c7009a02cefe8b3",
      "patch": "@@ -0,0 +1,47 @@\n+/* Displaced stepping related things.\n+\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef DISPLACED_STEPPING_H\n+#define DISPLACED_STEPPING_H\n+\n+enum displaced_step_prepare_status\n+{\n+  /* A displaced stepping buffer was successfully allocated and prepared.  */\n+  DISPLACED_STEP_PREPARE_STATUS_OK,\n+\n+  /* This particular instruction can't be displaced stepped, GDB should fall\n+     back on in-line stepping.  */\n+  DISPLACED_STEP_PREPARE_STATUS_CANT,\n+\n+  /* Not enough resources are available at this time, try again later.  */\n+  DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE,\n+};\n+\n+enum displaced_step_finish_status\n+{\n+  /* Either the instruction was stepped and fixed up, or the specified thread\n+     wasn't executing a displaced step (in which case there's nothing to\n+     finish). */\n+  DISPLACED_STEP_FINISH_STATUS_OK,\n+\n+  /* The thread started a displaced step, but didn't complete it.  */\n+  DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED,\n+};\n+\n+#endif /* DISPLACED_STEPPING_H */"
    },
    {
      "sha": "29bbc209d188c8ee03360f12cf149d6172cd3482",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 42,
      "deletions": 30,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab37966cfd192a12d5d1d259c7009a02cefe8b3/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab37966cfd192a12d5d1d259c7009a02cefe8b3/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=bab37966cfd192a12d5d1d259c7009a02cefe8b3",
      "patch": "@@ -19,6 +19,7 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n+#include \"displaced-stepping.h\"\n #include \"infrun.h\"\n #include <ctype.h>\n #include \"symtab.h\"\n@@ -1650,11 +1651,13 @@ displaced_step_dump_bytes (const gdb_byte *buf, size_t len)\n    Comments in the code for 'random signals' in handle_inferior_event\n    explain how we handle this case instead.\n \n-   Returns 1 if preparing was successful -- this thread is going to be\n-   stepped now; 0 if displaced stepping this thread got queued; or -1\n-   if this instruction can't be displaced stepped.  */\n+   Returns DISPLACED_STEP_PREPARE_STATUS_OK if preparing was successful -- this\n+   thread is going to be stepped now; DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE\n+   if displaced stepping this thread got queued; or\n+   DISPLACED_STEP_PREPARE_STATUS_CANT if this instruction can't be displaced\n+   stepped.  */\n \n-static int\n+static displaced_step_prepare_status\n displaced_step_prepare_throw (thread_info *tp)\n {\n   regcache *regcache = get_thread_regcache (tp);\n@@ -1691,7 +1694,7 @@ displaced_step_prepare_throw (thread_info *tp)\n \t\t\t      target_pid_to_str (tp->ptid).c_str ());\n \n       global_thread_step_over_chain_enqueue (tp);\n-      return 0;\n+      return DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE;\n     }\n   else\n     displaced_debug_printf (\"stepping %s now\",\n@@ -1722,7 +1725,7 @@ displaced_step_prepare_throw (thread_info *tp)\n       displaced_debug_printf (\"breakpoint set in scratch pad.  \"\n \t\t\t      \"Stepping over breakpoint in-line instead.\");\n \n-      return -1;\n+      return DISPLACED_STEP_PREPARE_STATUS_CANT;\n     }\n \n   /* Save the original contents of the copy area.  */\n@@ -1746,7 +1749,7 @@ displaced_step_prepare_throw (thread_info *tp)\n       /* The architecture doesn't know how or want to displaced step\n \t this instruction or instruction sequence.  Fallback to\n \t stepping over the breakpoint in-line.  */\n-      return -1;\n+      return DISPLACED_STEP_PREPARE_STATUS_CANT;\n     }\n \n   /* Save the information we need to fix things up if the step\n@@ -1767,20 +1770,21 @@ displaced_step_prepare_throw (thread_info *tp)\n \n   displaced_debug_printf (\"displaced pc to %s\", paddress (gdbarch, copy));\n \n-  return 1;\n+  return DISPLACED_STEP_PREPARE_STATUS_OK;\n }\n \n /* Wrapper for displaced_step_prepare_throw that disabled further\n    attempts at displaced stepping if we get a memory error.  */\n \n-static int\n+static displaced_step_prepare_status\n displaced_step_prepare (thread_info *thread)\n {\n-  int prepared = -1;\n+  displaced_step_prepare_status status\n+    = DISPLACED_STEP_PREPARE_STATUS_CANT;\n \n   try\n     {\n-      prepared = displaced_step_prepare_throw (thread);\n+      status = displaced_step_prepare_throw (thread);\n     }\n   catch (const gdb_exception_error &ex)\n     {\n@@ -1803,7 +1807,7 @@ displaced_step_prepare (thread_info *thread)\n       thread->inf->displaced_step_state.failed_before = 1;\n     }\n \n-  return prepared;\n+  return status;\n }\n \n static void\n@@ -1833,22 +1837,24 @@ displaced_step_restore (struct displaced_step_inferior_state *displaced,\n \t\t\t\t    displaced->step_copy));\n }\n \n-/* If we displaced stepped an instruction successfully, adjust\n-   registers and memory to yield the same effect the instruction would\n-   have had if we had executed it at its original address, and return\n-   1.  If the instruction didn't complete, relocate the PC and return\n-   -1.  If the thread wasn't displaced stepping, return 0.  */\n+/* If we displaced stepped an instruction successfully, adjust registers and\n+   memory to yield the same effect the instruction would have had if we had\n+   executed it at its original address, and return\n+   DISPLACED_STEP_FINISH_STATUS_OK.  If the instruction didn't complete,\n+   relocate the PC and return DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED.\n \n-static int\n+   If the thread wasn't displaced stepping, return\n+   DISPLACED_STEP_FINISH_STATUS_OK as well.  */\n+\n+static displaced_step_finish_status\n displaced_step_finish (thread_info *event_thread, enum gdb_signal signal)\n {\n   displaced_step_inferior_state *displaced\n     = &event_thread->inf->displaced_step_state;\n-  int ret;\n \n   /* Was this event for the thread we displaced?  */\n   if (displaced->step_thread != event_thread)\n-    return 0;\n+    return DISPLACED_STEP_FINISH_STATUS_OK;\n \n   /* Fixup may need to read memory/registers.  Switch to the thread\n      that we're fixing up.  Also, target_stopped_by_watchpoint checks\n@@ -1872,7 +1878,8 @@ displaced_step_finish (thread_info *event_thread, enum gdb_signal signal)\n \t\t\t\t    displaced->step_original,\n \t\t\t\t    displaced->step_copy,\n \t\t\t\t    get_thread_regcache (displaced->step_thread));\n-      ret = 1;\n+\n+      return DISPLACED_STEP_FINISH_STATUS_OK;\n     }\n   else\n     {\n@@ -1883,10 +1890,9 @@ displaced_step_finish (thread_info *event_thread, enum gdb_signal signal)\n \n       pc = displaced->step_original + (pc - displaced->step_copy);\n       regcache_write_pc (regcache, pc);\n-      ret = -1;\n-    }\n \n-  return ret;\n+      return DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED;\n+    }\n }\n \n /* Data to be passed around while handling an event.  This data is\n@@ -2410,16 +2416,17 @@ resume_1 (enum gdb_signal sig)\n       && sig == GDB_SIGNAL_0\n       && !current_inferior ()->waiting_for_vfork_done)\n     {\n-      int prepared = displaced_step_prepare (tp);\n+      displaced_step_prepare_status prepare_status\n+\t= displaced_step_prepare (tp);\n \n-      if (prepared == 0)\n+      if (prepare_status == DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE)\n \t{\n \t  infrun_debug_printf (\"Got placed in step-over queue\");\n \n \t  tp->control.trap_expected = 0;\n \t  return;\n \t}\n-      else if (prepared < 0)\n+      else if (prepare_status == DISPLACED_STEP_PREPARE_STATUS_CANT)\n \t{\n \t  /* Fallback to stepping over the breakpoint in-line.  */\n \n@@ -2433,14 +2440,17 @@ resume_1 (enum gdb_signal sig)\n \n \t  insert_breakpoints ();\n \t}\n-      else if (prepared > 0)\n+      else if (prepare_status == DISPLACED_STEP_PREPARE_STATUS_OK)\n \t{\n \t  /* Update pc to reflect the new address from which we will\n \t     execute instructions due to displaced stepping.  */\n \t  pc = regcache_read_pc (get_thread_regcache (tp));\n \n \t  step = gdbarch_displaced_step_hw_singlestep (gdbarch);\n \t}\n+      else\n+\tgdb_assert_not_reached (_(\"Invalid displaced_step_prepare_status \"\n+\t\t\t\t  \"value.\"));\n     }\n \n   /* Do we need to do it the hard way, w/temp breakpoints?  */\n@@ -4815,7 +4825,8 @@ stop_all_threads (void)\n \t\t      t->suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n \t\t      t->suspend.waitstatus_pending_p = 0;\n \n-\t\t      if (displaced_step_finish (t, GDB_SIGNAL_0) < 0)\n+\t\t      if (displaced_step_finish (t, GDB_SIGNAL_0)\n+\t\t\t  == DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED)\n \t\t\t{\n \t\t\t  /* Add it back to the step-over queue.  */\n \t\t\t  infrun_debug_printf\n@@ -4843,7 +4854,8 @@ stop_all_threads (void)\n \t\t      sig = (event.ws.kind == TARGET_WAITKIND_STOPPED\n \t\t\t     ? event.ws.value.sig : GDB_SIGNAL_0);\n \n-\t\t      if (displaced_step_finish (t, sig) < 0)\n+\t\t      if (displaced_step_finish (t, sig)\n+\t\t\t  == DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED)\n \t\t\t{\n \t\t\t  /* Add it back to the step-over queue.  */\n \t\t\t  t->control.trap_expected = 0;"
    }
  ]
}