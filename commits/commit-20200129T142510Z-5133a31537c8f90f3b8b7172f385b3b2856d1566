{
  "sha": "5133a31537c8f90f3b8b7172f385b3b2856d1566",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTEzM2EzMTUzN2M4ZjkwZjNiOGI3MTcyZjM4NWIzYjI4NTZkMTU2Ng==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2019-12-23T15:04:26Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-01-29T14:25:10Z"
    },
    "message": "Recognize more program breakpoint patterns\n\nNew in v3:\n\n- Code cleanups based on reviews.\n\nNew in v2:\n\n- Fixed misc problems based on reviews.\n- Switched to using gdbarch_program_breakpoint_here_p as opposed to\ngdbarch_insn_is_breakpoint.\n- Fixed matching of brk instructions. Previously the mask was incorrect, which\nwas showing up as a few failures in the testsuite. Now it is clean.\n- New testcase (separate patch).\n- Moved program_breakpoint_here () to arch-utils.c and made it the default\nimplementation of gdbarch_program_breakpoint_here_p.\n\n--\n\nIt was reported to me that program breakpoints (permanent ones inserted into\nthe code itself) other than the one GDB uses for AArch64 (0xd4200000) do not\ngenerate visible stops when continuing, and GDB will continue spinning\ninfinitely.\n\nThis happens because GDB, upon hitting one of those program breakpoints, thinks\nthe SIGTRAP came from a delayed breakpoint hit...\n\n(gdb) x/i $pc\n=> 0x4005c0 <problem_function>: brk     #0x90f\n(gdb) c\nContinuing.\ninfrun: clear_proceed_status_thread (process 14198)\ninfrun: proceed (addr=0xffffffffffffffff, signal=GDB_SIGNAL_DEFAULT)\ninfrun: proceed: resuming process 14198\ninfrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [process 14198] at 0x4005c0\ninfrun: infrun_async(1)\ninfrun: prepare_to_wait\ninfrun: target_wait (-1.0.0, status) =\ninfrun:   14198.14198.0 [process 14198],\ninfrun:   status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: handle_inferior_event status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: stop_pc = 0x4005c0\ninfrun: delayed software breakpoint trap, ignoring\ninfrun: no stepping, continue\ninfrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [process 14198] at 0x4005c0\ninfrun: prepare_to_wait\ninfrun: target_wait (-1.0.0, status) =\ninfrun:   14198.14198.0 [process 14198],\ninfrun:   status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: handle_inferior_event status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: stop_pc = 0x4005c0\ninfrun: delayed software breakpoint trap, ignoring\ninfrun: no stepping, continue\ninfrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [process 14198] at 0x4005c0\ninfrun: prepare_to_wait\ninfrun: target_wait (-1.0.0, status) =\ninfrun:   14198.14198.0 [process 14198],\ninfrun:   status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: handle_inferior_event status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: stop_pc = 0x4005c0\ninfrun: delayed software breakpoint trap, ignoring\ninfrun: no stepping, continue\ninfrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [process 14198] at 0x4005c0\ninfrun: prepare_to_wait\ninfrun: target_wait (-1.0.0, status) =\ninfrun:   14198.14198.0 [process 14198],\ninfrun:   status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: handle_inferior_event status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: stop_pc = 0x4005c0\ninfrun: delayed software breakpoint trap, ignoring\ninfrun: no stepping, continue\ninfrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [process 14198] at 0x4005c0\ninfrun: prepare_to_wait\ninfrun: target_wait (-1.0.0, status) =\ninfrun:   14198.14198.0 [process 14198],\ninfrun:   status->kind = stopped, signal = GDB_SIGNAL_TRAP\n...\n\n... which is not the case.\n\nIf the program breakpoint is one GDB recognizes, then it will stop when it\nhits it.\n\n(gdb) x/i $pc\n=> 0x4005c0 <problem_function>: brk     #0x0\n(gdb) c\nContinuing.\ninfrun: clear_proceed_status_thread (process 14193)\ninfrun: proceed (addr=0xffffffffffffffff, signal=GDB_SIGNAL_DEFAULT)\ninfrun: proceed: resuming process 14193\ninfrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [process 14193] at 0x4005c0\ninfrun: infrun_async(1)\ninfrun: prepare_to_wait\ninfrun: target_wait (-1.0.0, status) =\ninfrun:   14193.14193.0 [process 14193],\ninfrun:   status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: handle_inferior_event status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: stop_pc = 0x4005c0\ninfrun: random signal (GDB_SIGNAL_TRAP)\ninfrun: stop_waiting\ninfrun: stop_all_threads\ninfrun: stop_all_threads, pass=0, iterations=0\ninfrun:   process 14193 not executing\ninfrun: stop_all_threads, pass=1, iterations=1\ninfrun:   process 14193 not executing\ninfrun: stop_all_threads done\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nproblem_function () at brk_0.c:7\n7        asm(\"brk %0\\n\\t\" ::\"n\"(0x0));\ninfrun: infrun_async(0)\n\nOtherwise GDB will keep trying to resume the inferior and will keep\nseeing the SIGTRAP's, without stopping.\n\nTo the user it appears GDB has gone into an infinite loop, interruptible only\nby Ctrl-C.\n\nAlso, windbg seems to use a different variation of AArch64 breakpoint compared\nto GDB. This causes problems when debugging Windows on ARM binaries, when\nprogram breakpoints are being used.\n\nThe proposed patch creates a new gdbarch method (gdbarch_program_breakpoint_here_p)\nthat tells GDB whether the underlying instruction is a breakpoint instruction\nor not.\n\nThis is more general than only checking for the instruction GDB uses as\nbreakpoint.\n\nThe existing logic is still preserved for targets that do not implement this\nnew gdbarch method.\n\nThe end result is like so:\n\n(gdb) x/i $pc\n=> 0x4005c0 <problem_function>: brk     #0x90f\n(gdb) c\nContinuing.\ninfrun: clear_proceed_status_thread (process 16417)\ninfrun: proceed (addr=0xffffffffffffffff, signal=GDB_SIGNAL_DEFAULT)\ninfrun: proceed: resuming process 16417\ninfrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [process 16417] at 0x4005c0\ninfrun: infrun_async(1)\ninfrun: prepare_to_wait\ninfrun: target_wait (-1.0.0, status) =\ninfrun:   16417.16417.0 [process 16417],\ninfrun:   status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: handle_inferior_event status->kind = stopped, signal = GDB_SIGNAL_TRAP\ninfrun: stop_pc = 0x4005c0\ninfrun: random signal (GDB_SIGNAL_TRAP)\ninfrun: stop_waiting\ninfrun: stop_all_threads\ninfrun: stop_all_threads, pass=0, iterations=0\ninfrun:   process 16417 not executing\ninfrun: stop_all_threads, pass=1, iterations=1\ninfrun:   process 16417 not executing\ninfrun: stop_all_threads done\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nproblem_function () at brk.c:7\n7        asm(\"brk %0\\n\\t\" ::\"n\"(0x900 + 0xf));\ninfrun: infrun_async(0)\n\ngdb/ChangeLog:\n\n2020-01-29  Luis Machado  <luis.machado@linaro.org>\n\n\t* aarch64-tdep.c (BRK_INSN_MASK): Define to 0xffe0001f.\n\t(BRK_INSN_MASK): Define to 0xd4200000.\n\t(aarch64_program_breakpoint_here_p): New function.\n\t(aarch64_gdbarch_init): Set gdbarch_program_breakpoint_here_p hook.\n\t* arch-utils.c (default_program_breakpoint_here_p): Moved from\n\tbreakpoint.c.\n\t* arch-utils.h (default_program_breakpoint_here_p): Moved from\n\tbreakpoint.h\n\t* breakpoint.c (bp_loc_is_permanent): Changed return type to bool and\n\tcall gdbarch_program_breakpoint_here_p.\n\t(program_breakpoint_here): Moved to arch-utils.c, renamed to\n\tdefault_program_breakpoint_here_p, changed return type to bool and\n\tsimplified.\n\t* breakpoint.h (program_breakpoint_here): Moved prototype to\n\tarch-utils.h, renamed to default_program_breakpoint_here_p and changed\n\treturn type to bool.\n\t* gdbarch.c: Regenerate.\n\t* gdbarch.h: Regenerate.\n\t* gdbarch.sh (program_breakpoint_here_p): New method.\n\t* infrun.c (handle_signal_stop): Call\n\tgdbarch_program_breakpoint_here_p.",
    "tree": {
      "sha": "08e7fd6e47c14de5f93ba01e0af947db0b7b089f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/08e7fd6e47c14de5f93ba01e0af947db0b7b089f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5133a31537c8f90f3b8b7172f385b3b2856d1566",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5133a31537c8f90f3b8b7172f385b3b2856d1566",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5133a31537c8f90f3b8b7172f385b3b2856d1566",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5133a31537c8f90f3b8b7172f385b3b2856d1566/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5f440116e87a4613b888ab3f42c014468bd625d9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f440116e87a4613b888ab3f42c014468bd625d9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5f440116e87a4613b888ab3f42c014468bd625d9"
    }
  ],
  "stats": {
    "total": 186,
    "additions": 140,
    "deletions": 46
  },
  "files": [
    {
      "sha": "ee2ba1c38dba82c3ad20f632e97a7ff8570d44be",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -1,3 +1,27 @@\n+2020-01-29  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* aarch64-tdep.c (BRK_INSN_MASK): Define to 0xffe0001f.\n+\t(BRK_INSN_MASK): Define to 0xd4200000.\n+\t(aarch64_program_breakpoint_here_p): New function.\n+\t(aarch64_gdbarch_init): Set gdbarch_program_breakpoint_here_p hook.\n+\t* arch-utils.c (default_program_breakpoint_here_p): Moved from\n+\tbreakpoint.c.\n+\t* arch-utils.h (default_program_breakpoint_here_p): Moved from\n+\tbreakpoint.h\n+\t* breakpoint.c (bp_loc_is_permanent): Changed return type to bool and\n+\tcall gdbarch_program_breakpoint_here_p.\n+\t(program_breakpoint_here): Moved to arch-utils.c, renamed to\n+\tdefault_program_breakpoint_here_p, changed return type to bool and\n+\tsimplified.\n+\t* breakpoint.h (program_breakpoint_here): Moved prototype to\n+\tarch-utils.h, renamed to default_program_breakpoint_here_p and changed\n+\treturn type to bool.\n+\t* gdbarch.c: Regenerate.\n+\t* gdbarch.h: Regenerate.\n+\t* gdbarch.sh (program_breakpoint_here_p): New method.\n+\t* infrun.c (handle_signal_stop): Call\n+\tgdbarch_program_breakpoint_here_p.\n+\n 2020-01-26  Tom Tromey  <tom@tromey.com>\n \n \t* ctfread.c (struct ctf_fp_info): Reindent."
    },
    {
      "sha": "120c5db627083cdf1dcc05d6b5e0291587118b3e",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -1201,6 +1201,39 @@ aarch64_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdb_byte op,\n   return false;\n }\n \n+/* Used for matching BRK instructions for AArch64.  */\n+static constexpr uint32_t BRK_INSN_MASK = 0xffe0001f;\n+static constexpr uint32_t BRK_INSN_BASE = 0xd4200000;\n+\n+/* Implementation of gdbarch_program_breakpoint_here_p for aarch64.  */\n+\n+static bool\n+aarch64_program_breakpoint_here_p (gdbarch *gdbarch, CORE_ADDR address)\n+{\n+  const uint32_t insn_len = 4;\n+  gdb_byte target_mem[4];\n+\n+  /* Enable the automatic memory restoration from breakpoints while\n+     we read the memory.  Otherwise we may find temporary breakpoints, ones\n+     inserted by GDB, and flag them as permanent breakpoints.  */\n+  scoped_restore restore_memory\n+    = make_scoped_restore_show_memory_breakpoints (0);\n+\n+  if (target_read_memory (address, target_mem, insn_len) == 0)\n+    {\n+      uint32_t insn =\n+\t(uint32_t) extract_unsigned_integer (target_mem, insn_len,\n+\t\t\t\t\t     gdbarch_byte_order_for_code (gdbarch));\n+\n+      /* Check if INSN is a BRK instruction pattern.  There are multiple choices\n+\t of such instructions with different immediate values.  Different OS'\n+\t may use a different variation, but they have the same outcome.  */\n+\treturn ((insn & BRK_INSN_MASK) == BRK_INSN_BASE);\n+    }\n+\n+  return false;\n+}\n+\n /* When arguments must be pushed onto the stack, they go on in reverse\n    order.  The code below implements a FILO (stack) to do this.  */\n \n@@ -3389,6 +3422,10 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   set_gdbarch_execute_dwarf_cfa_vendor_op (gdbarch,\n \t\t\t\t\t   aarch64_execute_dwarf_cfa_vendor_op);\n \n+  /* Permanent/Program breakpoint handling.  */\n+  set_gdbarch_program_breakpoint_here_p (gdbarch,\n+\t\t\t\t\t aarch64_program_breakpoint_here_p);\n+\n   /* Add some default predicates.  */\n   frame_unwind_append_unwinder (gdbarch, &aarch64_stub_unwind);\n   dwarf2_append_unwinders (gdbarch);"
    },
    {
      "sha": "04955ea847b2eb93602b2bf82d2741284cd0912e",
      "filename": "gdb/arch-utils.c",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/arch-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/arch-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.c?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -876,6 +876,38 @@ int default_insn_is_jump (struct gdbarch *gdbarch, CORE_ADDR addr)\n   return 0;\n }\n \n+/*  See arch-utils.h.  */\n+\n+bool\n+default_program_breakpoint_here_p (struct gdbarch *gdbarch,\n+\t\t\t\t   CORE_ADDR address)\n+{\n+  int len;\n+  const gdb_byte *bpoint = gdbarch_breakpoint_from_pc (gdbarch, &address, &len);\n+\n+  /* Software breakpoints unsupported?  */\n+  if (bpoint == nullptr)\n+    return false;\n+\n+  gdb_byte *target_mem = (gdb_byte *) alloca (len);\n+\n+  /* Enable the automatic memory restoration from breakpoints while\n+     we read the memory.  Otherwise we may find temporary breakpoints, ones\n+     inserted by GDB, and flag them as permanent breakpoints.  */\n+  scoped_restore restore_memory\n+    = make_scoped_restore_show_memory_breakpoints (0);\n+\n+  if (target_read_memory (address, target_mem, len) == 0)\n+    {\n+      /* Check if this is a breakpoint instruction for this architecture,\n+\t including ones used by GDB.  */\n+      if (memcmp (target_mem, bpoint, len) == 0)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n void\n default_skip_permanent_breakpoint (struct regcache *regcache)\n {"
    },
    {
      "sha": "43d64b1f4f24933cd98ac41c5dfb8e4db3101b10",
      "filename": "gdb/arch-utils.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/arch-utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/arch-utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.h?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -228,6 +228,10 @@ extern int default_insn_is_call (struct gdbarch *, CORE_ADDR);\n extern int default_insn_is_ret (struct gdbarch *, CORE_ADDR);\n extern int default_insn_is_jump (struct gdbarch *, CORE_ADDR);\n \n+/* Default implementation of gdbarch_program_breakpoint_here_p.  */\n+extern bool default_program_breakpoint_here_p (struct gdbarch *gdbarch,\n+\t\t\t\t\t       CORE_ADDR addr);\n+\n /* Do-nothing version of vsyscall_range.  Returns false.  */\n \n extern int default_vsyscall_range (struct gdbarch *gdbarch, struct mem_range *range);"
    },
    {
      "sha": "5a9352c26fef592e293e4d5155780665e2c20151",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 7,
      "deletions": 39,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -8515,7 +8515,7 @@ mention (struct breakpoint *b)\n }\n \f\n \n-static int bp_loc_is_permanent (struct bp_location *loc);\n+static bool bp_loc_is_permanent (struct bp_location *loc);\n \n static struct bp_location *\n add_location_to_breakpoint (struct breakpoint *b,\n@@ -8581,57 +8581,25 @@ add_location_to_breakpoint (struct breakpoint *b,\n }\n \f\n \n-/* See breakpoint.h.  */\n-\n-int\n-program_breakpoint_here_p (struct gdbarch *gdbarch, CORE_ADDR address)\n-{\n-  int len;\n-  CORE_ADDR addr;\n-  const gdb_byte *bpoint;\n-  gdb_byte *target_mem;\n-\n-  addr = address;\n-  bpoint = gdbarch_breakpoint_from_pc (gdbarch, &addr, &len);\n-\n-  /* Software breakpoints unsupported?  */\n-  if (bpoint == NULL)\n-    return 0;\n-\n-  target_mem = (gdb_byte *) alloca (len);\n-\n-  /* Enable the automatic memory restoration from breakpoints while\n-     we read the memory.  Otherwise we could say about our temporary\n-     breakpoints they are permanent.  */\n-  scoped_restore restore_memory\n-    = make_scoped_restore_show_memory_breakpoints (0);\n+/* Return true if LOC is pointing to a permanent breakpoint,\n+   return false otherwise.  */\n \n-  if (target_read_memory (address, target_mem, len) == 0\n-      && memcmp (target_mem, bpoint, len) == 0)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return 1 if LOC is pointing to a permanent breakpoint,\n-   return 0 otherwise.  */\n-\n-static int\n+static bool\n bp_loc_is_permanent (struct bp_location *loc)\n {\n   gdb_assert (loc != NULL);\n \n   /* If we have a non-breakpoint-backed catchpoint or a software\n      watchpoint, just return 0.  We should not attempt to read from\n      the addresses the locations of these breakpoint types point to.\n-     program_breakpoint_here_p, below, will attempt to read\n+     gdbarch_program_breakpoint_here_p, below, will attempt to read\n      memory.  */\n   if (!bl_address_is_meaningful (loc))\n-    return 0;\n+    return false;\n \n   scoped_restore_current_pspace_and_thread restore_pspace_thread;\n   switch_to_program_space_and_thread (loc->pspace);\n-  return program_breakpoint_here_p (loc->gdbarch, loc->address);\n+  return gdbarch_program_breakpoint_here_p (loc->gdbarch, loc->address);\n }\n \n /* Build a command list for the dprintf corresponding to the current"
    },
    {
      "sha": "347aeb75f301972d1e39e9fcf801cc1008dec4af",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -1194,11 +1194,6 @@ enum breakpoint_here\n \n /* Prototypes for breakpoint-related functions.  */\n \n-/* Return 1 if there's a program/permanent breakpoint planted in\n-   memory at ADDRESS, return 0 otherwise.  */\n-\n-extern int program_breakpoint_here_p (struct gdbarch *gdbarch, CORE_ADDR address);\n-\n extern enum breakpoint_here breakpoint_here_p (const address_space *,\n \t\t\t\t\t       CORE_ADDR);\n "
    },
    {
      "sha": "d763fc85e6f743b6c2a9c91b58cda3757c97e4a0",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -345,6 +345,7 @@ struct gdbarch\n   gdbarch_insn_is_call_ftype *insn_is_call;\n   gdbarch_insn_is_ret_ftype *insn_is_ret;\n   gdbarch_insn_is_jump_ftype *insn_is_jump;\n+  gdbarch_program_breakpoint_here_p_ftype *program_breakpoint_here_p;\n   gdbarch_auxv_parse_ftype *auxv_parse;\n   gdbarch_print_auxv_entry_ftype *print_auxv_entry;\n   gdbarch_vsyscall_range_ftype *vsyscall_range;\n@@ -464,6 +465,7 @@ gdbarch_alloc (const struct gdbarch_info *info,\n   gdbarch->insn_is_call = default_insn_is_call;\n   gdbarch->insn_is_ret = default_insn_is_ret;\n   gdbarch->insn_is_jump = default_insn_is_jump;\n+  gdbarch->program_breakpoint_here_p = default_program_breakpoint_here_p;\n   gdbarch->print_auxv_entry = default_print_auxv_entry;\n   gdbarch->vsyscall_range = default_vsyscall_range;\n   gdbarch->infcall_mmap = default_infcall_mmap;\n@@ -708,6 +710,7 @@ verify_gdbarch (struct gdbarch *gdbarch)\n   /* Skip verify of insn_is_call, invalid_p == 0 */\n   /* Skip verify of insn_is_ret, invalid_p == 0 */\n   /* Skip verify of insn_is_jump, invalid_p == 0 */\n+  /* Skip verify of program_breakpoint_here_p, invalid_p == 0 */\n   /* Skip verify of auxv_parse, has predicate.  */\n   /* Skip verify of print_auxv_entry, invalid_p == 0 */\n   /* Skip verify of vsyscall_range, invalid_p == 0 */\n@@ -1248,6 +1251,9 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: process_record_signal = <%s>\\n\",\n                       host_address_to_string (gdbarch->process_record_signal));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: program_breakpoint_here_p = <%s>\\n\",\n+                      host_address_to_string (gdbarch->program_breakpoint_here_p));\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: ps_regnum = %s\\n\",\n                       plongest (gdbarch->ps_regnum));\n@@ -4928,6 +4934,23 @@ set_gdbarch_insn_is_jump (struct gdbarch *gdbarch,\n   gdbarch->insn_is_jump = insn_is_jump;\n }\n \n+bool\n+gdbarch_program_breakpoint_here_p (struct gdbarch *gdbarch, CORE_ADDR address)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->program_breakpoint_here_p != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_program_breakpoint_here_p called\\n\");\n+  return gdbarch->program_breakpoint_here_p (gdbarch, address);\n+}\n+\n+void\n+set_gdbarch_program_breakpoint_here_p (struct gdbarch *gdbarch,\n+                                       gdbarch_program_breakpoint_here_p_ftype program_breakpoint_here_p)\n+{\n+  gdbarch->program_breakpoint_here_p = program_breakpoint_here_p;\n+}\n+\n int\n gdbarch_auxv_parse_p (struct gdbarch *gdbarch)\n {"
    },
    {
      "sha": "800a4e8b16140cd6d1dad4475be1d3a95c94b569",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -1545,6 +1545,13 @@ typedef int (gdbarch_insn_is_jump_ftype) (struct gdbarch *gdbarch, CORE_ADDR add\n extern int gdbarch_insn_is_jump (struct gdbarch *gdbarch, CORE_ADDR addr);\n extern void set_gdbarch_insn_is_jump (struct gdbarch *gdbarch, gdbarch_insn_is_jump_ftype *insn_is_jump);\n \n+/* Return true if there's a program/permanent breakpoint planted in\n+   memory at ADDRESS, return false otherwise. */\n+\n+typedef bool (gdbarch_program_breakpoint_here_p_ftype) (struct gdbarch *gdbarch, CORE_ADDR address);\n+extern bool gdbarch_program_breakpoint_here_p (struct gdbarch *gdbarch, CORE_ADDR address);\n+extern void set_gdbarch_program_breakpoint_here_p (struct gdbarch *gdbarch, gdbarch_program_breakpoint_here_p_ftype *program_breakpoint_here_p);\n+\n /* Read one auxv entry from *READPTR, not reading locations >= ENDPTR.\n    Return 0 if *READPTR is already at the end of the buffer.\n    Return -1 if there is insufficient buffer for a whole entry."
    },
    {
      "sha": "a86de961196bb1c6c937ab3fefe317377763b392",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -1152,6 +1152,10 @@ m;int;insn_is_ret;CORE_ADDR addr;addr;;default_insn_is_ret;;0\n # Return non-zero if the instruction at ADDR is a jump; zero otherwise.\n m;int;insn_is_jump;CORE_ADDR addr;addr;;default_insn_is_jump;;0\n \n+# Return true if there's a program/permanent breakpoint planted in\n+# memory at ADDRESS, return false otherwise.\n+m;bool;program_breakpoint_here_p;CORE_ADDR address;address;;default_program_breakpoint_here_p;;0\n+\n # Read one auxv entry from *READPTR, not reading locations >= ENDPTR.\n # Return 0 if *READPTR is already at the end of the buffer.\n # Return -1 if there is insufficient buffer for a whole entry."
    },
    {
      "sha": "c8369cbee2e8f003a9eb767662bab7f0cbd69f42",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5133a31537c8f90f3b8b7172f385b3b2856d1566/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=5133a31537c8f90f3b8b7172f385b3b2856d1566",
      "patch": "@@ -6147,8 +6147,8 @@ handle_signal_stop (struct execution_control_state *ecs)\n      been removed.  */\n   if (random_signal && target_stopped_by_sw_breakpoint ())\n     {\n-      if (program_breakpoint_here_p (gdbarch,\n-\t\t\t\t     ecs->event_thread->suspend.stop_pc))\n+      if (gdbarch_program_breakpoint_here_p (gdbarch,\n+\t\t\t\t\t     ecs->event_thread->suspend.stop_pc))\n \t{\n \t  struct regcache *regcache;\n \t  int decr_pc;"
    }
  ]
}