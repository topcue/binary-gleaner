{
  "sha": "87a37e5e078f506fa9905b74e9238593c537fcd5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODdhMzdlNWUwNzhmNTA2ZmE5OTA1Yjc0ZTkyMzg1OTNjNTM3ZmNkNQ==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-08-28T20:10:59Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-10-12T17:06:09Z"
    },
    "message": "Reject ambiguous C++ field accesses (PR exp/26602)\n\nThe gdb.cp/ambiguous.exp testcase had been disabled for many years,\nbut recently it was re-enabled.  However, it is failing everywhere.\nThat is because it is testing an old feature that is gone from GDB.\n\nThe testcase is expecting to see an ambiguous field warning, like:\n\n # X is derived from A1 and A2; both A1 and A2 have a member 'x'\n send_gdb \"print x.x\\n\"\n gdb_expect {\n    -re \"warning: x ambiguous; using X::A2::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n\tpass \"print x.x\"\n    }\n    -re \"warning: x ambiguous; using X::A1::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n\tpass \"print x.x\"\n    }\n    -re \".*$gdb_prompt $\" { fail \"print x.x\" }\n    timeout { fail \"(timeout) print x.x\" }\n  }\n\nHowever, GDB just accesses one of the candidates without warning or\nerror:\n\n print x.x\n $1 = 1431655296\n (gdb) FAIL: gdb.cp/ambiguous.exp: print x.x\n\n(The weird number is because the testcase does not initialize the\nvariables.)\n\nThe testcase come in originally with the big HP merge:\n\n +Sun Jan 10 23:44:11 1999  David Taylor  <taylor@texas.cygnus.com>\n +\n +\n +       The following files are part of the HP merge; some had longer\n +       names at HP, but have been renamed to be no more than 14\n +       characters in length.\n\nLooking at the tree back then, we find that warning:\n\n /* Helper function used by value_struct_elt to recurse through baseclasses.\n    Look for a field NAME in ARG1. Adjust the address of ARG1 by OFFSET bytes,\n    and search in it assuming it has (class) type TYPE.\n    If found, return value, else return NULL.\n\n    If LOOKING_FOR_BASECLASS, then instead of looking for struct fields,\n    look for a baseclass named NAME.  */\n\n static value_ptr\n search_struct_field (name, arg1, offset, type, looking_for_baseclass)\n      char *name;\n      register value_ptr arg1;\n      int offset;\n      register struct type *type;\n      int looking_for_baseclass;\n {\n   int found = 0;\n   char found_class[1024];\n   value_ptr v;\n   struct type *vbase = NULL;\n\n   found_class[0] = '\\000';\n\n   v = search_struct_field_aux (name, arg1, offset, type, looking_for_baseclass, &found, found_class, &vbase);\n   if (found > 1)\n     warning (\"%s ambiguous; using %s::%s. Use a cast to disambiguate.\",\n              name, found_class, name);\n\n   return v;\n }\n\n\nHowever, in current GDB, search_struct_field does not handle the\nambiguous field case, nor is that warning found anywhere.  Somehow it\ngot lost over the years.  That seems like a regression, because the\ncompiler (as per language rules) rejects the ambiguous accesses as\nwell.  E.g.:\n\n gdb.cp/ambiguous.cc:98:5: error: request for member 'x' is ambiguous\n    98 |   x.x = 1;\n       |     ^\n gdb.cp/ambiguous.cc:10:7: note: candidates are: 'int A2::x'\n    10 |   int x;\n       |       ^\n gdb.cp/ambiguous.cc:4:7: note:                 'int A1::x'\n     4 |   int x;\n       |       ^\n\n\nThis patch restores the feature, though implemented differently and\nwith better user experience, IMHO.  An ambiguous access is now an\nerror instead of a warning, and also GDB shows you all the candidates,\nlike:\n\n (gdb) print x.x\n Request for member 'x' is ambiguous in type 'X'. Candidates are:\n   'int A1::x' (X -> A1)\n   'int A2::x' (X -> A2)\n (gdb) print j.x\n Request for member 'x' is ambiguous in type 'J'. Candidates are:\n   'int A1::x' (J -> K -> A1)\n   'int A1::x' (J -> L -> A1)\n\nUsers can then fix their commands by casting or by specifying the\nbaseclass explicitly, like:\n\n (gdb) p x.A1::x\n $1 = 1\n (gdb) p x.A2::x\n $2 = 2\n (gdb) p ((A1) x).x\n $3 = 1\n (gdb) p ((A2) x).x\n $4 = 2\n (gdb) p j.K::x\n $12 = 1\n (gdb) p j.L::x\n $13 = 2\n (gdb) p j.A1::x\n base class 'A1' is ambiguous in type 'J'\n\nThe last error I've not touched; could be improved to also list the\nbaseclass candidates.\n\nThe showing the class \"path\" for each candidate was inspired by GCC's\noutput when you try an ambiguous cast:\n\n  gdb.cp/ambiguous.cc:161:8: error: ambiguous conversion from derived class 'const JVA1' to base class 'const A1':\n      class JVA1 -> class KV -> class A1\n      class JVA1 -> class A1\n    (A1) jva1;\n\t ^~~~\n\nI did not include the \"class\" word as it seemed unnecessarily\nrepetitive, but I can include it if people prefer it:\n\n (gdb) print j.x\n Request for member 'x' is ambiguous in type 'J'. Candidates are:\n   'int A1::x' (class J -> class K -> class A1)\n   'int A1::x' (class J -> class L -> class A1)\n\nThe testcase is adjusted accordingly.  I also took the chance to\nmodernize it at the same time.\n\nAlso, as mentioned above, the testcase doesn't currently initialize\nthe tested variables.  This patch inializes them all, giving each\nfield a distinct value, so that we can be sure that GDB is accessing\nthe right fields / offsets.  The testcase is extended accordingly.\n\nUnfortunately, this exposes a bug, not addressed in this patch.  The\nbug is around a class that inherits from A1 directly and also inherits\nfrom two other distinct base classes that inherit virtually from A1 in\nturn:\n\n print jva1.KV::x\n $51 = 1431665544\n (gdb) FAIL: gdb.cp/ambiguous.exp: all fields: print jva1.KV::x\n print jva1.KV::y\n $52 = 21845\n (gdb) FAIL: gdb.cp/ambiguous.exp: all fields: print jva1.KV::y\n\n (gdb) print /x (KV)jva1\n $4 = {<A1> = <invalid address>, _vptr.KV = 0x555555557b88 <vtable for JVA1+24>, i = 0x457}\n (gdb) print /x (A1)(KV)jva1\n Cannot access memory at address 0x0\n\nSince that's an orthogonal issue, I filed PR c++/26550 and kfailed the\ntests that fail because of it.\n\ngdb/ChangeLog:\n\n\tPR exp/26602\n\t* valops.c (struct struct_field_searcher): New.\n\t(update_search_result): Rename to ...\n\t(struct_field_searcher::update_result): ... this.  Simplify\n\tprototype.  Record all found fields.\n\t(do_search_struct_field): Rename to ...\n\t(struct_field_searcher::search): ... this.  Simplify prototype.\n\tMaintain stack of visited baseclass path.  Call update_result for\n\tfields too.  Keep searching fields in baseclasses instead of\n\tstopping at the first found field.\n\t(search_struct_field): Use struct_field_searcher.  When looking\n\tfor fields, report ambiguous access attempts.\n\ngdb/testsuite/ChangeLog:\n\n\tPR exp/26602\n\tPR c++/26550\n\t* gdb.cp/ambiguous.cc (marker1): Delete.\n\t(main): Initialize all the fields of the locals.  Replace marker1\n\tcall with a \"set breakpoint here\" marker.\n\t* gdb.cp/ambiguous.exp: Modernize.  Use gdb_continue_to_breakpoint\n\tinstead of running to marker1.  Add tests printing all the\n\tvariables and all the fields of the variables.\n\t(test_ambiguous): New proc, expecting the new GDB output when a\n\tfield access is ambiguous.  Change all \"warning: X ambiguous\"\n\ttests to use it.",
    "tree": {
      "sha": "0932e1430659ea8fe441479d43dbe14e02708ca3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0932e1430659ea8fe441479d43dbe14e02708ca3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/87a37e5e078f506fa9905b74e9238593c537fcd5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/87a37e5e078f506fa9905b74e9238593c537fcd5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/87a37e5e078f506fa9905b74e9238593c537fcd5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/87a37e5e078f506fa9905b74e9238593c537fcd5/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "71e1b6b0ac9403d7fda91890f0d2881b6d1697d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/71e1b6b0ac9403d7fda91890f0d2881b6d1697d6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/71e1b6b0ac9403d7fda91890f0d2881b6d1697d6"
    }
  ],
  "stats": {
    "total": 670,
    "additions": 451,
    "deletions": 219
  },
  "files": [
    {
      "sha": "63ed7e4a5a4286a37aa529cb6e4a6a35fbc016ca",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=87a37e5e078f506fa9905b74e9238593c537fcd5",
      "patch": "@@ -1,3 +1,18 @@\n+2020-10-12  Pedro Alves  <pedro@palves.net>\n+\n+\tPR exp/26602\n+\t* valops.c (struct struct_field_searcher): New.\n+\t(update_search_result): Rename to ...\n+\t(struct_field_searcher::update_result): ... this.  Simplify\n+\tprototype.  Record all found fields.\n+\t(do_search_struct_field): Rename to ...\n+\t(struct_field_searcher::search): ... this.  Simplify prototype.\n+\tMaintain stack of visited baseclass path.  Call update_result for\n+\tfields too.  Keep searching fields in baseclasses instead of\n+\tstopping at the first found field.\n+\t(search_struct_field): Use struct_field_searcher.  When looking\n+\tfor fields, report ambiguous access attempts.\n+\n 2020-10-11  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* frame.c (inside_main_func): Check full symbols as well as"
    },
    {
      "sha": "d50870105ea25f97beaef9e11a71bf4451b7bd36",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=87a37e5e078f506fa9905b74e9238593c537fcd5",
      "patch": "@@ -1,3 +1,17 @@\n+2020-10-12  Pedro Alves  <pedro@palves.net>\n+\n+\tPR exp/26602\n+\tPR c++/26550\n+\t* gdb.cp/ambiguous.cc (marker1): Delete.\n+\t(main): Initialize all the fields of the locals.  Replace marker1\n+\tcall with a \"set breakpoint here\" marker.\n+\t* gdb.cp/ambiguous.exp: Modernize.  Use gdb_continue_to_breakpoint\n+\tinstead of running to marker1.  Add tests printing all the\n+\tvariables and all the fields of the variables.\n+\t(test_ambiguous): New proc, expecting the new GDB output when a\n+\tfield access is ambiguous.  Change all \"warning: X ambiguous\"\n+\ttests to use it.\n+\n 2020-10-12  Gary Benson <gbenson@redhat.com>\n \n \t* gdb.base/msym-bp.c (foo): Add __attribute__ ((used))."
    },
    {
      "sha": "a55686547f2222d97b7509a0e59e0434754972f8",
      "filename": "gdb/testsuite/gdb.cp/ambiguous.cc",
      "status": "modified",
      "additions": 77,
      "deletions": 8,
      "changes": 85,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/testsuite/gdb.cp/ambiguous.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/testsuite/gdb.cp/ambiguous.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/ambiguous.cc?ref=87a37e5e078f506fa9905b74e9238593c537fcd5",
      "patch": "@@ -1,9 +1,4 @@\n \n-void marker1()\n-{\n-  return;\n-}\n-\n class A1 {\n public:\n   int x;\n@@ -102,7 +97,81 @@ int main()\n \n   i += k.i + m.w + a1.x + a2.x + a3.x + x.z + l.z + n.r + j.j;\n \n-  marker1();\n-\n-  return 0;\n+  /* Initialize all the fields.  Keep the order the same as in the\n+     .exp file.  */\n+\n+  a1.x = 1;\n+  a1.y = 2;\n+\n+  a2.x = 1;\n+  a2.y = 2;\n+\n+  a3.x = 1;\n+  a3.y = 2;\n+\n+  x.A1::x = 1;\n+  x.A1::y = 2;\n+  x.A2::x = 3;\n+  x.A2::y = 4;\n+  x.z = 5;\n+\n+  l.x = 1;\n+  l.y = 2;\n+  l.z = 3;\n+\n+  m.x = 1;\n+  m.y = 2;\n+  m.w = 3;\n+\n+  n.A1::x = 1;\n+  n.A1::y = 2;\n+  n.A2::x = 3;\n+  n.A2::y = 4;\n+  n.w = 5;\n+  n.r = 6;\n+  n.z = 7;\n+\n+  k.x = 1;\n+  k.y = 2;\n+  k.i = 3;\n+\n+  j.K::x = 1;\n+  j.K::y = 2;\n+  j.L::x = 3;\n+  j.L::y = 4;\n+  j.i = 5;\n+  j.z = 6;\n+  j.j = 7;\n+\n+  jv.x = 1;\n+  jv.y = 2;\n+  jv.i = 3;\n+  jv.z = 4;\n+  jv.jv = 5;\n+\n+  jva1.KV::x = 1;\n+  jva1.KV::y = 2;\n+  jva1.LV::x = 3;\n+  jva1.LV::y = 4;\n+  jva1.z = 5;\n+  jva1.i = 6;\n+  jva1.jva1 = 7;\n+\n+  jva2.KV::x = 1;\n+  jva2.KV::y = 2;\n+  jva2.LV::x = 3;\n+  jva2.LV::y = 4;\n+  jva2.A2::x = 5;\n+  jva2.A2::y = 6;\n+  jva2.z = 7;\n+  jva2.i = 8;\n+  jva2.jva2 = 9;\n+\n+  jva1v.x = 1;\n+  jva1v.y = 2;\n+  jva1v.z = 3;\n+  jva1v.i = 4;\n+  jva1v.jva1v = 5;\n+\n+  return 0; /* set breakpoint here */\n }"
    },
    {
      "sha": "b7fec1b2bb3d9bb523ea4203d745ace2ca4841f2",
      "filename": "gdb/testsuite/gdb.cp/ambiguous.exp",
      "status": "modified",
      "additions": 181,
      "deletions": 148,
      "changes": 329,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/testsuite/gdb.cp/ambiguous.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/testsuite/gdb.cp/ambiguous.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/ambiguous.exp?ref=87a37e5e078f506fa9905b74e9238593c537fcd5",
      "patch": "@@ -15,15 +15,9 @@\n \n # This file is part of the gdb testsuite\n \n-# tests relating to ambiguous class members\n-# Written by Satish Pai <pai@apollo.hp.com> 1997-07-28\n-\n-# This file is part of the gdb testsuite\n-\n-#\n-# test running programs\n-#\n-\n+# Print out various class objects' members and check that the error\n+# about the field or baseclass being ambiguous is emitted at the right\n+# times.\n \n if { [skip_cplus_tests] } { continue }\n \n@@ -47,187 +41,226 @@ if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile \\\n     return -1\n }\n \n-#\n-# set it up at a breakpoint so we can play with the variable values\n-#\n if ![runto_main] then {\n     perror \"couldn't run to breakpoint\"\n     continue\n }\n \n-send_gdb \"break marker1\\n\" ; gdb_expect -re \".*$gdb_prompt $\"\n-    send_gdb \"cont\\n\"\n-    gdb_expect {\n-        -re \"Break.* marker1 \\\\(\\\\) at .*:$decimal.*$gdb_prompt $\" {\n-            send_gdb \"up\\n\"\n-            gdb_expect {\n-                -re \".*$gdb_prompt $\" { pass \"up from marker1\" }\n-                timeout { fail \"up from marker1\" }\n-            }\n-        }\n-        -re \"$gdb_prompt $\" { fail \"continue to marker1\"  }\n-        timeout { fail \"(timeout) continue to marker1\"  }\n+# Run to a breakpoint after the variables have been initialized so we\n+# can play with the variable values.\n+\n+set lineno [gdb_get_line_number \"set breakpoint here\"]\n+\n+gdb_breakpoint $lineno\n+gdb_continue_to_breakpoint \"breakpoint here\"\n+\n+set number -?$decimal\n+\n+with_test_prefix \"all vars\" {\n+    gdb_test \"print a1\" \\\n+\t\" = \\{x = 1, y = 2\\}\"\n+\n+    gdb_test \"print a2\" \\\n+\t\" = \\{x = 1, y = 2\\}\"\n+\n+    gdb_test \"print a3\" \\\n+\t\" = \\{x = 1, y = 2\\}\"\n+\n+    gdb_test \"print x\" \\\n+\t\" = \\{<A1> = \\{x = 1, y = 2\\}, <A2> = \\{x = 3, y = 4\\}, z = 5\\}\"\n+\n+    gdb_test \"print l\" \\\n+\t\" = \\{<A1> = \\{x = 1, y = 2\\}, z = 3\\}\"\n+\n+    gdb_test \"print m\" \\\n+\t\" = \\{<A2> = \\{x = 1, y = 2\\}, w = 3\\}\"\n+\n+    gdb_test \"print n\" \\\n+\t\" = \\{<L> = \\{<A1> = \\{x = 1, y = 2\\}, z = 7\\}, <M> = \\{<A2> = \\{x = 3, y = 4\\}, w = 5\\}, r = 6\\}\"\n+\n+    gdb_test \"print k\" \\\n+\t\" = \\{<A1> = \\{x = 1, y = 2\\}, i = 3\\}\"\n+\n+    gdb_test \"print j\" \\\n+\t\" = {<K> = {<A1> = {x = 1, y = 2}, i = 5}, <L> = {<A1> = {x = 3, y = 4}, z = 6}, j = 7}\"\n+\n+    gdb_test \"print jv\" \\\n+\t\" = \\{<KV> = \\{<A1> = \\{x = 1, y = 2\\}, _vptr.KV = $hex <vtable for JV.*>, i = 3\\}, <LV> = \\{_vptr.LV = $hex <VTT for JV>, z = 4\\}, jv = 5\\}\"\n+\n+    # No way to initialize one of the A1's, so just take any number there.\n+    gdb_test \"print jva1\" \\\n+\t\" = \\{<KV> = \\{<A1> = \\{x = 3, y = 4\\}, _vptr.KV = $hex <vtable for JVA1.*>, i = 6\\}, <LV> = \\{_vptr.LV = $hex <VTT for JVA1>, z = 5\\}, <A1> = \\{x = $number, y = $number\\}, jva1 = 7\\}\"\n+\n+    gdb_test \"print jva2\" \\\n+\t\" = \\{<KV> = \\{<A1> = \\{x = 3, y = 4\\}, _vptr.KV = $hex <vtable for JVA2.*>, i = 8\\}, <LV> = \\{_vptr.LV = $hex <VTT for JVA2>, z = 7\\}, <A2> = \\{x = 5, y = 6\\}, jva2 = 9\\}\"\n+\n+    gdb_test \"print jva1v\" \\\n+\t\" = \\{<KV> = \\{<A1> = \\{x = 1, y = 2\\}, _vptr.KV = $hex <vtable for JVA1V+.*>, i = 4\\}, <LV> = \\{_vptr.LV = $hex <VTT for JVA1V>, z = 3\\}, jva1v = 5\\}\"\n+}\n+\n+# Check that we can access all the fields correctly, using the same\n+# syntax as used in the .cc file.  Keep the order here in sync with\n+# the .cc file.\n+with_test_prefix \"all fields\" {\n+    gdb_test \"print a1.x\" \" = 1\"\n+    gdb_test \"print a1.y\" \" = 2\"\n+\n+    gdb_test \"print a2.x\" \" = 1\"\n+    gdb_test \"print a2.y\" \" = 2\"\n+\n+    gdb_test \"print a3.x\" \" = 1\"\n+    gdb_test \"print a3.y\" \" = 2\"\n+\n+    gdb_test \"print x.A1::x\" \" = 1\"\n+    gdb_test \"print x.A1::y\" \" = 2\"\n+    gdb_test \"print x.A2::x\" \" = 3\"\n+    gdb_test \"print x.A2::y\" \" = 4\"\n+    gdb_test \"print x.z\" \" = 5\"\n+\n+    gdb_test \"print l.x\" \" = 1\"\n+    gdb_test \"print l.y\" \" = 2\"\n+    gdb_test \"print l.z\" \" = 3\"\n+\n+    gdb_test \"print m.x\" \" = 1\"\n+    gdb_test \"print m.y\" \" = 2\"\n+    gdb_test \"print m.w\" \" = 3\"\n+\n+    gdb_test \"print n.A1::x\" \" = 1\"\n+    gdb_test \"print n.A1::y\" \" = 2\"\n+    gdb_test \"print n.A2::x\" \" = 3\"\n+    gdb_test \"print n.A2::y\" \" = 4\"\n+    gdb_test \"print n.w\" \" = 5\"\n+    gdb_test \"print n.r\" \" = 6\"\n+    gdb_test \"print n.z\" \" = 7\"\n+\n+    gdb_test \"print k.x\" \" = 1\"\n+    gdb_test \"print k.y\" \" = 2\"\n+    gdb_test \"print k.i\" \" = 3\"\n+\n+    gdb_test \"print j.K::x\" \" = 1\"\n+    gdb_test \"print j.K::y\" \" = 2\"\n+    gdb_test \"print j.L::x\" \" = 3\"\n+    gdb_test \"print j.L::y\" \" = 4\"\n+    gdb_test \"print j.i\" \" = 5\"\n+    gdb_test \"print j.z\" \" = 6\"\n+    gdb_test \"print j.j\" \" = 7\"\n+\n+    gdb_test \"print jv.x\" \" = 1\"\n+    gdb_test \"print jv.y\" \" = 2\"\n+    gdb_test \"print jv.i\" \" = 3\"\n+    gdb_test \"print jv.z\" \" = 4\"\n+    gdb_test \"print jv.jv\" \" = 5\"\n+\n+    setup_kfail \"c++/26550\" *-*-*\n+    gdb_test \"print jva1.KV::x\" \" = 1\"\n+    setup_kfail \"c++/26550\" *-*-*\n+    gdb_test \"print jva1.KV::y\" \" = 2\"\n+    setup_kfail \"c++/26550\" *-*-*\n+    gdb_test \"print jva1.LV::x\" \" = 3\"\n+    setup_kfail \"c++/26550\" *-*-*\n+    gdb_test \"print jva1.LV::y\" \" = 4\"\n+    gdb_test \"print jva1.z\" \" = 5\"\n+    gdb_test \"print jva1.i\" \" = 6\"\n+    gdb_test \"print jva1.jva1\" \"= 7\"\n+\n+    setup_kfail \"c++/26550\" *-*-*\n+    gdb_test \"print jva2.KV::x\" \" = 1\"\n+    setup_kfail \"c++/26550\" *-*-*\n+    gdb_test \"print jva2.KV::y\" \" = 2\"\n+    setup_kfail \"c++/26550\" *-*-*\n+    gdb_test \"print jva2.LV::x\" \" = 3\"\n+    setup_kfail \"c++/26550\" *-*-*\n+    gdb_test \"print jva2.LV::y\" \" = 4\"\n+    gdb_test \"print jva2.A2::x\" \" = 5\"\n+    gdb_test \"print jva2.A2::y\" \" = 6\"\n+    gdb_test \"print jva2.z\" \" = 7\"\n+    gdb_test \"print jva2.i\" \" = 8\"\n+    gdb_test \"print jva2.jva2\" \"= 9\"\n+\n+    gdb_test \"print jva1v.x\" \" = 1\"\n+    gdb_test \"print jva1v.y\" \" = 2\"\n+    gdb_test \"print jva1v.z\" \" = 3\"\n+    gdb_test \"print jva1v.i\" \" = 4\"\n+    gdb_test \"print jva1v.jva1v\" \" = 5\"\n+}\n+\n+# Test that printing WHAT reports an error about FIELD being ambiguous\n+# in TYPE, and that the candidates are CANDIDATES.\n+proc test_ambiguous {what field type candidates} {\n+    set msg \"Request for member '$field' is ambiguous in type '$type'. Candidates are:\"\n+\n+    foreach c $candidates {\n+\tset c_re [string_to_regexp $c]\n+\tappend msg \"\\r\\n  $c_re\"\n     }\n \n-# print out various class objects' members.  The values aren't\n-# important, just check that the warning is emitted at the\n-# right times. \n+    gdb_test \"print $what\" $msg\n+}\n \n # X is derived from A1 and A2; both A1 and A2 have a member 'x'\n-setup_kfail gdb/26602 *-*-*\n-send_gdb \"print x.x\\n\"\n-gdb_expect {\n-   -re \"warning: x ambiguous; using X::A2::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print x.x\"\n-   }\n-   -re \"warning: x ambiguous; using X::A1::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print x.x\"\n-   }\n-   -re \".*$gdb_prompt $\" { fail \"print x.x\" }\n-   timeout { fail \"(timeout) print x.x\" }\n+test_ambiguous \"x.x\" \"x\" \"X\" {\n+    \"'int A1::x' (X -> A1)\"\n+    \"'int A2::x' (X -> A2)\"\n }\n \n-\n # N is derived from A1 and A2, but not immediately -- two steps\n # up in the hierarchy. Both A1 and A2 have a member 'x'.\n-setup_kfail gdb/26602 *-*-*\n-send_gdb \"print n.x\\n\"\n-gdb_expect {\n-   -re \"warning: x ambiguous; using N::M::A2::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print n.x\"\n-   }\n-   -re \"warning: x ambiguous; using N::L::A1::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print n.x\"\n-   }\n-   -re \".*$gdb_prompt $\" { fail \"print n.x\" }\n-   timeout { fail \"(timeout) print n.x\" }\n+test_ambiguous \"n.x\" \"x\" \"N\" {\n+    \"'int A1::x' (N -> L -> A1)\"\n+    \"'int A2::x' (N -> M -> A2)\"\n }\n \n-# J is derived from A1 twice.  A1 has a member x. \n-setup_kfail gdb/26602 *-*-*\n-send_gdb \"print j.x\\n\"\n-gdb_expect {\n-   -re \"warning: x ambiguous; using J::L::A1::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print j.x\"\n-   }\n-   -re \"warning: x ambiguous; using J::K::A1::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print j.x\"\n-   }\n-   -re \".*$gdb_prompt $\" { fail \"print j.x\" }\n-   timeout { fail \"(timeout) print j.x\" }\n+# J is derived from A1 twice.  A1 has a member x.\n+test_ambiguous \"j.x\" \"x\" \"J\" {\n+    \"'int A1::x' (J -> K -> A1)\"\n+    \"'int A1::x' (J -> L -> A1)\"\n }\n \n # JV is derived from A1 but A1 is a virtual base. Should not\n-# report an ambiguity in this case. \n-send_gdb \"print jv.x\\n\"\n-gdb_expect {\n-   -re \"warning: x ambiguous.*Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       fail \"print jv.x (ambiguity reported)\"\n-   }\n-   -re \"\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" { pass \"print jv.x\" }\n-   -re \".*$gdb_prompt $\" { fail \"print jv.x (??)\" }\n-   timeout { fail \"(timeout) print jv.x\" }\n-}\n+# report an ambiguity in this case.\n+gdb_test \"print jv.x\" \" = 1\"\n \n # JVA1 is derived from A1; A1 occurs as a virtual base in two\n # ancestors, and as a non-virtual immediate base. Ambiguity must\n-# be reported. \n-setup_kfail gdb/26602 *-*-*\n-send_gdb \"print jva1.x\\n\"\n-gdb_expect {\n-   -re \"warning: x ambiguous; using JVA1::A1::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print jva1.x\"\n-   }\n-   -re \"warning: x ambiguous; using JVA1::KV::A1::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print jva1.x\"\n-   }\n-   -re \".*$gdb_prompt $\" { fail \"print jva1.x\" }\n-   timeout { fail \"(timeout) print jva1.x\" }\n+# be reported.\n+test_ambiguous \"jva1.x\" \"x\" \"JVA1\" {\n+    \"'int A1::x' (JVA1 -> KV -> A1)\"\n+    \"'int A1::x' (JVA1 -> A1)\"\n }\n \n # JVA2 is derived from A1 & A2; A1 occurs as a virtual base in two\n # ancestors, and A2 is a non-virtual immediate base. Ambiguity must\n # be reported as A1 and A2 both have a member 'x'.\n-setup_kfail gdb/26602 *-*-*\n-send_gdb \"print jva2.x\\n\"\n-gdb_expect {\n-   -re \"warning: x ambiguous; using JVA2::A2::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print jva2.x\"\n-   }\n-   -re \"warning: x ambiguous; using JVA2::KV::A1::x. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       pass \"print jva2.x\"\n-   }\n-   -re \".*$gdb_prompt $\" { fail \"print jva2.x\" }\n-   timeout { fail \"(timeout) print jva2.x\" }\n+test_ambiguous \"jva2.x\" \"x\" \"JVA2\" {\n+    \"'int A1::x' (JVA2 -> KV -> A1)\"\n+    \"'int A2::x' (JVA2 -> A2)\"\n }\n \n # JVA1V is derived from A1; A1 occurs as a virtual base in two\n # ancestors, and also as a virtual immediate base. Ambiguity must\n # not be reported.\n-send_gdb \"print jva1v.x\\n\"\n-gdb_expect {\n-   -re \"warning: x ambiguous.*Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" {\n-       fail \"print jva1v.x (ambiguity reported)\"\n-   }\n-   -re \"\\\\$\\[0-9\\]* = \\[-\\]*\\[0-9\\]*\\r\\n$gdb_prompt $\" { pass \"print jva1v.x\" }\n-   -re \".*$gdb_prompt $\" { fail \"print jva1v.x (??)\" }\n-   timeout { fail \"(timeout) print jva1v.x\" }\n-}\n+gdb_test \"print jva1v.x\" \" = 1\"\n \n # Now check for ambiguous bases.\n \n # J is derived from A1 twice; report ambiguity if a J is\n # cast to an A1.\n-setup_kfail gdb/26602 *-*-*\n-send_gdb \"print (A1)j\\n\"\n-gdb_expect {\n-   -re \"warning: A1 ambiguous; using J::L::A1. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\{x = \\[-\\]*\\[0-9\\]*, y = \\[-\\]*\\[0-9\\]*\\}\\r\\n$gdb_prompt $\" {\n-       pass \"print (A1)j\"\n-   }\n-   -re \"warning: A1 ambiguous; using J::K::A1. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\{x = \\[-\\]*\\[0-9\\]*, y = \\[-\\]*\\[0-9\\]*\\}\\r\\n$gdb_prompt $\" {\n-       pass \"print (A1)j\"\n-   }\n-   -re \".*$gdb_prompt $\" { fail \"print (A1)j\" }\n-   timeout { fail \"(timeout) print (A1)j\" }\n-}\n+gdb_test \"print (A1)j\" \"base class 'A1' is ambiguous in type 'J'\"\n \n # JV is derived from A1 twice, but A1 is a virtual base; should\n # not report ambiguity when a JV is cast to an A1.\n-send_gdb \"print (A1)jv\\n\"\n-gdb_expect {\n-   -re \"warning: A1 ambiguous.*Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\{x = \\[-\\]*\\[0-9\\]*, y = \\[-\\]*\\[0-9\\]*\\}\\r\\n$gdb_prompt $\" {\n-       fail \"print (A1)jv (ambiguity reported)\"\n-   }\n-   -re \"\\\\$\\[0-9\\]* = \\{x = \\[-\\]*\\[0-9\\]*, y = \\[-\\]*\\[0-9\\]*\\}\\r\\n$gdb_prompt $\" { pass \"print (A1)jv\" }\n-   -re \".*$gdb_prompt $\" { fail \"print (A1)jv (??)\" }\n-   timeout { fail \"(timeout) print (A1)jv\" }\n-}\n+gdb_test \"print (A1)jv\" \" = {x = 1, y = 2}\"\n \n # JVA1 is derived from A1; A1 is a virtual base and also a\n # non-virtual base.  Must report ambiguity if a JVA1 is cast to an A1.\n-setup_kfail gdb/26602 *-*-*\n-send_gdb \"print (A1)jva1\\n\"\n-gdb_expect {\n-   -re \"warning: A1 ambiguous; using JVA1::A1. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\{x = \\[-\\]*\\[0-9\\]*, y = \\[-\\]*\\[0-9\\]*\\}\\r\\n$gdb_prompt $\" {\n-       pass \"print (A1)jva1\"\n-   }\n-   -re \"warning: A1 ambiguous; using JVA1::KV::A1. Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\{x = \\[-\\]*\\[0-9\\]*, y = \\[-\\]*\\[0-9\\]*\\}\\r\\n$gdb_prompt $\" {\n-       pass \"print (A1)jva1\"\n-   }\n-   -re \".*$gdb_prompt $\" { fail \"print (A1)jva1\" }\n-   timeout { fail \"(timeout) print (A1)jva1\" }\n-}\n+gdb_test \"print (A1)jva1\" \"base class 'A1' is ambiguous in type 'JVA1'\"\n+\n+# Add an intermediate cast to KV, and it should work.\n+setup_kfail \"c++/26550\" *-*-*\n+gdb_test \"print (KV)jva1\" \" = \\{<A1> = \\{x = 3, y = 4\\}, _vptr.KV = $hex <VTT for KV>, i = 6\\}\"\n+setup_kfail \"c++/26550\" *-*-*\n+gdb_test \"print (A1)(KV)jva1\" \" = \\{x = 3, y = 4\\}\"\n \n # JVA1V is derived from A1; A1 is a virtual base indirectly\n # and also directly; must not report ambiguity when a JVA1V is cast to an A1.\n-send_gdb \"print (A1)jva1v\\n\"\n-gdb_expect {\n-   -re \"warning: A1 ambiguous.*Use a cast to disambiguate.\\r\\n\\\\$\\[0-9\\]* = \\{x = \\[-\\]*\\[0-9\\]*, y = \\[-\\]*\\[0-9\\]*\\}\\r\\n$gdb_prompt $\" {\n-       fail \"print (A1)jva1v (ambiguity reported)\"\n-   }\n-   -re \"\\\\$\\[0-9\\]* = \\{x = \\[-\\]*\\[0-9\\]*, y = \\[-\\]*\\[0-9\\]*\\}\\r\\n$gdb_prompt $\" { pass \"print (A1)jva1v\"\n-   }\n-   -re \".*$gdb_prompt $\" { fail \"print (A1)jva1v (??)\" }\n-   timeout { fail \"(timeout) print (A1)jva1v\" }\n-}\n-\n+gdb_test \"print (A1)jva1v\" \" = {x = 1, y = 2}\""
    },
    {
      "sha": "65496131f91f572a927bc7b7864b813946e22e53",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 164,
      "deletions": 63,
      "changes": 227,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/87a37e5e078f506fa9905b74e9238593c537fcd5/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=87a37e5e078f506fa9905b74e9238593c537fcd5",
      "patch": "@@ -1766,62 +1766,141 @@ typecmp (int staticp, int varargs, int nargs,\n   return i + 1;\n }\n \n-/* Helper class for do_search_struct_field that updates *RESULT_PTR\n-   and *LAST_BOFFSET, and possibly throws an exception if the field\n-   search has yielded ambiguous results.  */\n+/* Helper class for search_struct_field that keeps track of found\n+   results and possibly throws an exception if the search yields\n+   ambiguous results.  See search_struct_field for description of\n+   LOOKING_FOR_BASECLASS.  */\n \n-static void\n-update_search_result (struct value **result_ptr, struct value *v,\n-\t\t      LONGEST *last_boffset, LONGEST boffset,\n-\t\t      const char *name, struct type *type)\n+struct struct_field_searcher\n+{\n+  /* A found field.  */\n+  struct found_field\n+  {\n+    /* Path to the structure where the field was found.  */\n+    std::vector<struct type *> path;\n+\n+    /* The field found.  */\n+    struct value *field_value;\n+  };\n+\n+  /* See corresponding fields for description of parameters.  */\n+  struct_field_searcher (const char *name,\n+\t\t\t struct type *outermost_type,\n+\t\t\t bool looking_for_baseclass)\n+    : m_name (name),\n+      m_looking_for_baseclass (looking_for_baseclass),\n+      m_outermost_type (outermost_type)\n+  {\n+  }\n+\n+  /* The search entry point.  If LOOKING_FOR_BASECLASS is true and the\n+     base class search yields ambiguous results, this throws an\n+     exception.  If LOOKING_FOR_BASECLASS is false, the found fields\n+     are accumulated and the caller (search_struct_field) takes care\n+     of throwing an error if the field search yields ambiguous\n+     results.  The latter is done that way so that the error message\n+     can include a list of all the found candidates.  */\n+  void search (struct value *arg, LONGEST offset, struct type *type);\n+\n+  const std::vector<found_field> &fields ()\n+  {\n+    return m_fields;\n+  }\n+\n+  struct value *baseclass ()\n+  {\n+    return m_baseclass;\n+  }\n+\n+private:\n+  /* Update results to include V, a found field/baseclass.  */\n+  void update_result (struct value *v, LONGEST boffset);\n+\n+  /* The name of the field/baseclass we're searching for.  */\n+  const char *m_name;\n+\n+  /* Whether we're looking for a baseclass, or a field.  */\n+  const bool m_looking_for_baseclass;\n+\n+  /* The offset of the baseclass containing the field/baseclass we\n+     last recorded.  */\n+  LONGEST m_last_boffset = 0;\n+\n+  /* If looking for a baseclass, then the result is stored here.  */\n+  struct value *m_baseclass = nullptr;\n+\n+  /* When looking for fields, the found candidates are stored\n+     here.  */\n+  std::vector<found_field> m_fields;\n+\n+  /* The type of the initial type passed to search_struct_field; this\n+     is used for error reporting when the lookup is ambiguous.  */\n+  struct type *m_outermost_type;\n+\n+  /* The full path to the struct being inspected.  E.g. for field 'x'\n+     defined in class B inherited by class A, we have A and B pushed\n+     on the path.  */\n+  std::vector <struct type *> m_struct_path;\n+};\n+\n+void\n+struct_field_searcher::update_result (struct value *v, LONGEST boffset)\n {\n   if (v != NULL)\n     {\n-      if (*result_ptr != NULL\n-\t  /* The result is not ambiguous if all the classes that are\n-\t     found occupy the same space.  */\n-\t  && *last_boffset != boffset)\n-\terror (_(\"base class '%s' is ambiguous in type '%s'\"),\n-\t       name, TYPE_SAFE_NAME (type));\n-      *result_ptr = v;\n-      *last_boffset = boffset;\n+      if (m_looking_for_baseclass)\n+\t{\n+\t  if (m_baseclass != nullptr\n+\t      /* The result is not ambiguous if all the classes that are\n+\t\t found occupy the same space.  */\n+\t      && m_last_boffset != boffset)\n+\t    error (_(\"base class '%s' is ambiguous in type '%s'\"),\n+\t\t   m_name, TYPE_SAFE_NAME (m_outermost_type));\n+\n+\t  m_baseclass = v;\n+\t  m_last_boffset = boffset;\n+\t}\n+      else\n+\t{\n+\t  /* The field is not ambiguous if it occupies the same\n+\t     space.  */\n+\t  if (m_fields.empty () || m_last_boffset != boffset)\n+\t    m_fields.push_back ({m_struct_path, v});\n+\t}\n     }\n }\n \n /* A helper for search_struct_field.  This does all the work; most\n-   arguments are as passed to search_struct_field.  The result is\n-   stored in *RESULT_PTR, which must be initialized to NULL.\n-   OUTERMOST_TYPE is the type of the initial type passed to\n-   search_struct_field; this is used for error reporting when the\n-   lookup is ambiguous.  */\n+   arguments are as passed to search_struct_field.  */\n \n-static void\n-do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n-\t\t\tstruct type *type, int looking_for_baseclass,\n-\t\t\tstruct value **result_ptr,\n-\t\t\tLONGEST *last_boffset,\n-\t\t\tstruct type *outermost_type)\n+void\n+struct_field_searcher::search (struct value *arg1, LONGEST offset,\n+\t\t\t       struct type *type)\n {\n   int i;\n   int nbases;\n \n+  m_struct_path.push_back (type);\n+  SCOPE_EXIT { m_struct_path.pop_back (); };\n+\n   type = check_typedef (type);\n   nbases = TYPE_N_BASECLASSES (type);\n \n-  if (!looking_for_baseclass)\n+  if (!m_looking_for_baseclass)\n     for (i = type->num_fields () - 1; i >= nbases; i--)\n       {\n \tconst char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n-\tif (t_field_name && (strcmp_iw (t_field_name, name) == 0))\n+\tif (t_field_name && (strcmp_iw (t_field_name, m_name) == 0))\n \t  {\n \t    struct value *v;\n \n \t    if (field_is_static (&type->field (i)))\n \t      v = value_static_field (type, i);\n \t    else\n \t      v = value_primitive_field (arg1, offset, i, type);\n-\t    *result_ptr = v;\n+\n+\t    update_result (v, offset);\n \t    return;\n \t  }\n \n@@ -1845,7 +1924,6 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n \t\t   represented as a struct, with a member for each\n \t\t   <variant field>.  */\n \n-\t\tstruct value *v = NULL;\n \t\tLONGEST new_offset = offset;\n \n \t\t/* This is pretty gross.  In G++, the offset in an\n@@ -1859,16 +1937,7 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n \t\t\t&& TYPE_FIELD_BITPOS (field_type, 0) == 0))\n \t\t  new_offset += TYPE_FIELD_BITPOS (type, i) / 8;\n \n-\t\tdo_search_struct_field (name, arg1, new_offset, \n-\t\t\t\t\tfield_type,\n-\t\t\t\t\tlooking_for_baseclass, &v,\n-\t\t\t\t\tlast_boffset,\n-\t\t\t\t\toutermost_type);\n-\t\tif (v)\n-\t\t  {\n-\t\t    *result_ptr = v;\n-\t\t    return;\n-\t\t  }\n+\t\tsearch (arg1, new_offset, field_type);\n \t      }\n \t  }\n       }\n@@ -1880,10 +1949,10 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n       /* If we are looking for baseclasses, this is what we get when\n          we hit them.  But it could happen that the base part's member\n          name is not yet filled in.  */\n-      int found_baseclass = (looking_for_baseclass\n+      int found_baseclass = (m_looking_for_baseclass\n \t\t\t     && TYPE_BASECLASS_NAME (type, i) != NULL\n-\t\t\t     && (strcmp_iw (name, \n-\t\t\t\t\t    TYPE_BASECLASS_NAME (type, \n+\t\t\t     && (strcmp_iw (m_name,\n+\t\t\t\t\t    TYPE_BASECLASS_NAME (type,\n \t\t\t\t\t\t\t\t i)) == 0));\n       LONGEST boffset = value_embedded_offset (arg1) + offset;\n \n@@ -1924,28 +1993,17 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n \t  if (found_baseclass)\n \t    v = v2;\n \t  else\n-\t    {\n-\t      do_search_struct_field (name, v2, 0,\n-\t\t\t\t      TYPE_BASECLASS (type, i),\n-\t\t\t\t      looking_for_baseclass,\n-\t\t\t\t      result_ptr, last_boffset,\n-\t\t\t\t      outermost_type);\n-\t    }\n+\t    search (v2, 0, TYPE_BASECLASS (type, i));\n \t}\n       else if (found_baseclass)\n \tv = value_primitive_field (arg1, offset, i, type);\n       else\n \t{\n-\t  do_search_struct_field (name, arg1,\n-\t\t\t\t  offset + TYPE_BASECLASS_BITPOS (type, \n-\t\t\t\t\t\t\t\t  i) / 8,\n-\t\t\t\t  basetype, looking_for_baseclass,\n-\t\t\t\t  result_ptr, last_boffset,\n-\t\t\t\t  outermost_type);\n+\t  search (arg1, offset + TYPE_BASECLASS_BITPOS (type, i) / 8,\n+\t\t  basetype);\n \t}\n \n-      update_search_result (result_ptr, v, last_boffset,\n-\t\t\t    boffset, name, outermost_type);\n+      update_result (v, boffset);\n     }\n }\n \n@@ -1960,12 +2018,55 @@ static struct value *\n search_struct_field (const char *name, struct value *arg1,\n \t\t     struct type *type, int looking_for_baseclass)\n {\n-  struct value *result = NULL;\n-  LONGEST boffset = 0;\n+  struct_field_searcher searcher (name, type, looking_for_baseclass);\n \n-  do_search_struct_field (name, arg1, 0, type, looking_for_baseclass,\n-\t\t\t  &result, &boffset, type);\n-  return result;\n+  searcher.search (arg1, 0, type);\n+\n+  if (!looking_for_baseclass)\n+    {\n+      const auto &fields = searcher.fields ();\n+\n+      if (fields.empty ())\n+\treturn nullptr;\n+      else if (fields.size () == 1)\n+\treturn fields[0].field_value;\n+      else\n+\t{\n+\t  std::string candidates;\n+\n+\t  for (auto &&candidate : fields)\n+\t    {\n+\t      gdb_assert (!candidate.path.empty ());\n+\n+\t      struct type *field_type = value_type (candidate.field_value);\n+\t      struct type *struct_type = candidate.path.back ();\n+\n+\t      std::string path;\n+\t      bool first = true;\n+\t      for (struct type *t : candidate.path)\n+\t\t{\n+\t\t  if (first)\n+\t\t    first = false;\n+\t\t  else\n+\t\t    path += \" -> \";\n+\t\t  path += t->name ();\n+\t\t}\n+\n+\t      candidates += string_printf (\"\\n  '%s %s::%s' (%s)\",\n+\t\t\t\t\t   TYPE_SAFE_NAME (field_type),\n+\t\t\t\t\t   TYPE_SAFE_NAME (struct_type),\n+\t\t\t\t\t   name,\n+\t\t\t\t\t   path.c_str ());\n+\t    }\n+\n+\t  error (_(\"Request for member '%s' is ambiguous in type '%s'.\"\n+\t\t   \" Candidates are:%s\"),\n+\t\t name, TYPE_SAFE_NAME (type),\n+\t\t candidates.c_str ());\n+\t}\n+    }\n+  else\n+    return searcher.baseclass ();\n }\n \n /* Helper function used by value_struct_elt to recurse through"
    }
  ]
}