{
  "sha": "bf4c3185a5a031824855a93c3476ae276236df12",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmY0YzMxODVhNWEwMzE4MjQ4NTVhOTNjMzQ3NmFlMjc2MjM2ZGYxMg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:37:52Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:37:53Z"
    },
    "message": "libctf: split serialization and file writeout into its own file\n\nThe code to serialize CTF dicts just gets bigger and bigger as the\ndictionary's complexity grows: adding symtypetabs almost doubled it on\nits own.  It's long past time to split this out into its own source\nfile, accompanied by the functions that do the actual writeout.\n\nThis leaves ctf-create.c populated exclusively by functions related to\nactual writable dict creation (ctf_add_*, ctf_create etc), and leaves\nboth files a much more reasonable size.\n\nlibctf/ChangeLog\n2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-create.c (symtypetab_delete_nonstatic_vars): Move\n\tinto ctf-serialize.c.\n\t(ctf_symtab_skippable): Likewise.\n\t(CTF_SYMTYPETAB_EMIT_FUNCTION): Likewise.\n\t(CTF_SYMTYPETAB_EMIT_PAD): Likewise.\n\t(CTF_SYMTYPETAB_FORCE_INDEXED): Likewise.\n\t(symtypetab_density): Likewise.\n\t(emit_symtypetab): Likewise.\n\t(emit_symtypetab_index): Likewise.\n\t(ctf_copy_smembers): Likewise.\n\t(ctf_copy_lmembers): Likewise.\n\t(ctf_copy_emembers): Likewise.\n\t(ctf_sort_var): Likewise.\n\t(ctf_serialize): Likewise.\n\t(ctf_gzwrite): Likewise.\n\t(ctf_compress_write): Likewise.\n\t(ctf_write_mem): Likewise.\n\t(ctf_write): Likewise.\n\t* ctf-serialize.c: New file.\n\t* Makefile.am (libctf_nobfd_la_SOURCES): Add it.\n\t* Makefile.in: Regenerate.",
    "tree": {
      "sha": "a1837dd0d4e692dbe182840e0623f3a648515814",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a1837dd0d4e692dbe182840e0623f3a648515814"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bf4c3185a5a031824855a93c3476ae276236df12",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf4c3185a5a031824855a93c3476ae276236df12",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bf4c3185a5a031824855a93c3476ae276236df12",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf4c3185a5a031824855a93c3476ae276236df12/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "087945261c7523ed895e48a97418ec6dee6cdb67",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/087945261c7523ed895e48a97418ec6dee6cdb67",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/087945261c7523ed895e48a97418ec6dee6cdb67"
    }
  ],
  "stats": {
    "total": 2715,
    "additions": 1391,
    "deletions": 1324
  },
  "files": [
    {
      "sha": "bd2563da18edade56ebfb4e9c561c67559ba38a2",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf4c3185a5a031824855a93c3476ae276236df12/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf4c3185a5a031824855a93c3476ae276236df12/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=bf4c3185a5a031824855a93c3476ae276236df12",
      "patch": "@@ -1,3 +1,27 @@\n+2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-create.c (symtypetab_delete_nonstatic_vars): Move\n+\tinto ctf-serialize.c.\n+\t(ctf_symtab_skippable): Likewise.\n+\t(CTF_SYMTYPETAB_EMIT_FUNCTION): Likewise.\n+\t(CTF_SYMTYPETAB_EMIT_PAD): Likewise.\n+\t(CTF_SYMTYPETAB_FORCE_INDEXED): Likewise.\n+\t(symtypetab_density): Likewise.\n+\t(emit_symtypetab): Likewise.\n+\t(emit_symtypetab_index): Likewise.\n+\t(ctf_copy_smembers): Likewise.\n+\t(ctf_copy_lmembers): Likewise.\n+\t(ctf_copy_emembers): Likewise.\n+\t(ctf_sort_var): Likewise.\n+\t(ctf_serialize): Likewise.\n+\t(ctf_gzwrite): Likewise.\n+\t(ctf_compress_write): Likewise.\n+\t(ctf_write_mem): Likewise.\n+\t(ctf_write): Likewise.\n+\t* ctf-serialize.c: New file.\n+\t* Makefile.am (libctf_nobfd_la_SOURCES): Add it.\n+\t* Makefile.in: Regenerate.\n+\n 2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-link.c (ctf_link_lazy_open): Move up in the file, to near"
    },
    {
      "sha": "e586d25fb37184907d8a1046d9bc5afce08406a3",
      "filename": "libctf/Makefile.am",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf4c3185a5a031824855a93c3476ae276236df12/libctf/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf4c3185a5a031824855a93c3476ae276236df12/libctf/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/Makefile.am?ref=bf4c3185a5a031824855a93c3476ae276236df12",
      "patch": "@@ -46,8 +46,8 @@ libctf_nobfd_la_LDFLAGS = -version-info 0:0:0 @SHARED_LDFLAGS@ @VERSION_FLAGS@\n libctf_nobfd_la_CPPFLAGS = $(AM_CPPFLAGS) -DNOBFD=1\n libctf_nobfd_la_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c ctf-decl.c ctf-error.c \\\n \t\t\t  ctf-hash.c ctf-labels.c ctf-dedup.c ctf-link.c ctf-lookup.c \\\n-\t\t\t  ctf-open.c ctf-sha1.c ctf-string.c ctf-subr.c ctf-types.c \\\n-\t\t\t  ctf-util.c\n+\t\t\t  ctf-open.c ctf-serialize.c ctf-sha1.c ctf-string.c ctf-subr.c \\\n+\t\t\t  ctf-types.c ctf-util.c\n if NEED_CTF_QSORT_R\n libctf_nobfd_la_SOURCES += ctf-qsort_r.c\n endif"
    },
    {
      "sha": "5cfa100f9cc4582cb40767d099f8d5307ddd2ac7",
      "filename": "libctf/Makefile.in",
      "status": "modified",
      "additions": 32,
      "deletions": 12,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf4c3185a5a031824855a93c3476ae276236df12/libctf/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf4c3185a5a031824855a93c3476ae276236df12/libctf/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/Makefile.in?ref=bf4c3185a5a031824855a93c3476ae276236df12",
      "patch": "@@ -168,18 +168,20 @@ am__DEPENDENCIES_1 =\n libctf_nobfd_la_DEPENDENCIES = $(am__DEPENDENCIES_1)\n am__libctf_nobfd_la_SOURCES_DIST = ctf-archive.c ctf-dump.c \\\n \tctf-create.c ctf-decl.c ctf-error.c ctf-hash.c ctf-labels.c \\\n-\tctf-dedup.c ctf-link.c ctf-lookup.c ctf-open.c ctf-sha1.c \\\n-\tctf-string.c ctf-subr.c ctf-types.c ctf-util.c ctf-qsort_r.c\n+\tctf-dedup.c ctf-link.c ctf-lookup.c ctf-open.c ctf-serialize.c \\\n+\tctf-sha1.c ctf-string.c ctf-subr.c ctf-types.c ctf-util.c \\\n+\tctf-qsort_r.c\n @NEED_CTF_QSORT_R_TRUE@am__objects_1 = libctf_nobfd_la-ctf-qsort_r.lo\n am_libctf_nobfd_la_OBJECTS = libctf_nobfd_la-ctf-archive.lo \\\n \tlibctf_nobfd_la-ctf-dump.lo libctf_nobfd_la-ctf-create.lo \\\n \tlibctf_nobfd_la-ctf-decl.lo libctf_nobfd_la-ctf-error.lo \\\n \tlibctf_nobfd_la-ctf-hash.lo libctf_nobfd_la-ctf-labels.lo \\\n \tlibctf_nobfd_la-ctf-dedup.lo libctf_nobfd_la-ctf-link.lo \\\n \tlibctf_nobfd_la-ctf-lookup.lo libctf_nobfd_la-ctf-open.lo \\\n-\tlibctf_nobfd_la-ctf-sha1.lo libctf_nobfd_la-ctf-string.lo \\\n-\tlibctf_nobfd_la-ctf-subr.lo libctf_nobfd_la-ctf-types.lo \\\n-\tlibctf_nobfd_la-ctf-util.lo $(am__objects_1)\n+\tlibctf_nobfd_la-ctf-serialize.lo libctf_nobfd_la-ctf-sha1.lo \\\n+\tlibctf_nobfd_la-ctf-string.lo libctf_nobfd_la-ctf-subr.lo \\\n+\tlibctf_nobfd_la-ctf-types.lo libctf_nobfd_la-ctf-util.lo \\\n+\t$(am__objects_1)\n libctf_nobfd_la_OBJECTS = $(am_libctf_nobfd_la_OBJECTS)\n AM_V_lt = $(am__v_lt_@AM_V@)\n am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)\n@@ -195,17 +197,19 @@ am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)\n libctf_la_DEPENDENCIES = ../bfd/libbfd.la $(am__DEPENDENCIES_2)\n am__libctf_la_SOURCES_DIST = ctf-archive.c ctf-dump.c ctf-create.c \\\n \tctf-decl.c ctf-error.c ctf-hash.c ctf-labels.c ctf-dedup.c \\\n-\tctf-link.c ctf-lookup.c ctf-open.c ctf-sha1.c ctf-string.c \\\n-\tctf-subr.c ctf-types.c ctf-util.c ctf-qsort_r.c ctf-open-bfd.c\n+\tctf-link.c ctf-lookup.c ctf-open.c ctf-serialize.c ctf-sha1.c \\\n+\tctf-string.c ctf-subr.c ctf-types.c ctf-util.c ctf-qsort_r.c \\\n+\tctf-open-bfd.c\n @NEED_CTF_QSORT_R_TRUE@am__objects_2 = libctf_la-ctf-qsort_r.lo\n am__objects_3 = libctf_la-ctf-archive.lo libctf_la-ctf-dump.lo \\\n \tlibctf_la-ctf-create.lo libctf_la-ctf-decl.lo \\\n \tlibctf_la-ctf-error.lo libctf_la-ctf-hash.lo \\\n \tlibctf_la-ctf-labels.lo libctf_la-ctf-dedup.lo \\\n \tlibctf_la-ctf-link.lo libctf_la-ctf-lookup.lo \\\n-\tlibctf_la-ctf-open.lo libctf_la-ctf-sha1.lo \\\n-\tlibctf_la-ctf-string.lo libctf_la-ctf-subr.lo \\\n-\tlibctf_la-ctf-types.lo libctf_la-ctf-util.lo $(am__objects_2)\n+\tlibctf_la-ctf-open.lo libctf_la-ctf-serialize.lo \\\n+\tlibctf_la-ctf-sha1.lo libctf_la-ctf-string.lo \\\n+\tlibctf_la-ctf-subr.lo libctf_la-ctf-types.lo \\\n+\tlibctf_la-ctf-util.lo $(am__objects_2)\n am_libctf_la_OBJECTS = $(am__objects_3) libctf_la-ctf-open-bfd.lo\n libctf_la_OBJECTS = $(am_libctf_la_OBJECTS)\n libctf_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -470,8 +474,8 @@ libctf_nobfd_la_LDFLAGS = -version-info 0:0:0 @SHARED_LDFLAGS@ @VERSION_FLAGS@\n libctf_nobfd_la_CPPFLAGS = $(AM_CPPFLAGS) -DNOBFD=1\n libctf_nobfd_la_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c \\\n \tctf-decl.c ctf-error.c ctf-hash.c ctf-labels.c ctf-dedup.c \\\n-\tctf-link.c ctf-lookup.c ctf-open.c ctf-sha1.c ctf-string.c \\\n-\tctf-subr.c ctf-types.c ctf-util.c $(am__append_1)\n+\tctf-link.c ctf-lookup.c ctf-open.c ctf-serialize.c ctf-sha1.c \\\n+\tctf-string.c ctf-subr.c ctf-types.c ctf-util.c $(am__append_1)\n libctf_la_LIBADD = ../bfd/libbfd.la $(libctf_nobfd_la_LIBADD)\n libctf_la_CPPFLAGS = $(AM_CPPFLAGS) -DNOBFD=0\n libctf_la_LDFLAGS = $(libctf_nobfd_la_LDFLAGS)\n@@ -623,6 +627,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_la-ctf-open-bfd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_la-ctf-open.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_la-ctf-qsort_r.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_la-ctf-serialize.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_la-ctf-sha1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_la-ctf-string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_la-ctf-subr.Plo@am__quote@\n@@ -640,6 +645,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_nobfd_la-ctf-lookup.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_nobfd_la-ctf-open.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_nobfd_la-ctf-qsort_r.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_nobfd_la-ctf-serialize.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_nobfd_la-ctf-sha1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_nobfd_la-ctf-string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libctf_nobfd_la-ctf-subr.Plo@am__quote@\n@@ -744,6 +750,13 @@ libctf_nobfd_la-ctf-open.lo: ctf-open.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_nobfd_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libctf_nobfd_la-ctf-open.lo `test -f 'ctf-open.c' || echo '$(srcdir)/'`ctf-open.c\n \n+libctf_nobfd_la-ctf-serialize.lo: ctf-serialize.c\n+@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_nobfd_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libctf_nobfd_la-ctf-serialize.lo -MD -MP -MF $(DEPDIR)/libctf_nobfd_la-ctf-serialize.Tpo -c -o libctf_nobfd_la-ctf-serialize.lo `test -f 'ctf-serialize.c' || echo '$(srcdir)/'`ctf-serialize.c\n+@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libctf_nobfd_la-ctf-serialize.Tpo $(DEPDIR)/libctf_nobfd_la-ctf-serialize.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='ctf-serialize.c' object='libctf_nobfd_la-ctf-serialize.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_nobfd_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libctf_nobfd_la-ctf-serialize.lo `test -f 'ctf-serialize.c' || echo '$(srcdir)/'`ctf-serialize.c\n+\n libctf_nobfd_la-ctf-sha1.lo: ctf-sha1.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_nobfd_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libctf_nobfd_la-ctf-sha1.lo -MD -MP -MF $(DEPDIR)/libctf_nobfd_la-ctf-sha1.Tpo -c -o libctf_nobfd_la-ctf-sha1.lo `test -f 'ctf-sha1.c' || echo '$(srcdir)/'`ctf-sha1.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libctf_nobfd_la-ctf-sha1.Tpo $(DEPDIR)/libctf_nobfd_la-ctf-sha1.Plo\n@@ -863,6 +876,13 @@ libctf_la-ctf-open.lo: ctf-open.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libctf_la-ctf-open.lo `test -f 'ctf-open.c' || echo '$(srcdir)/'`ctf-open.c\n \n+libctf_la-ctf-serialize.lo: ctf-serialize.c\n+@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libctf_la-ctf-serialize.lo -MD -MP -MF $(DEPDIR)/libctf_la-ctf-serialize.Tpo -c -o libctf_la-ctf-serialize.lo `test -f 'ctf-serialize.c' || echo '$(srcdir)/'`ctf-serialize.c\n+@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libctf_la-ctf-serialize.Tpo $(DEPDIR)/libctf_la-ctf-serialize.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='ctf-serialize.c' object='libctf_la-ctf-serialize.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libctf_la-ctf-serialize.lo `test -f 'ctf-serialize.c' || echo '$(srcdir)/'`ctf-serialize.c\n+\n libctf_la-ctf-sha1.lo: ctf-sha1.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libctf_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libctf_la-ctf-sha1.lo -MD -MP -MF $(DEPDIR)/libctf_la-ctf-sha1.Tpo -c -o libctf_la-ctf-sha1.lo `test -f 'ctf-sha1.c' || echo '$(srcdir)/'`ctf-sha1.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libctf_la-ctf-sha1.Tpo $(DEPDIR)/libctf_la-ctf-sha1.Plo"
    },
    {
      "sha": "b2e08623f2236309331b526761b4d7020ec02c2b",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1310,
      "changes": 1311,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf4c3185a5a031824855a93c3476ae276236df12/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf4c3185a5a031824855a93c3476ae276236df12/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=bf4c3185a5a031824855a93c3476ae276236df12",
      "patch": "@@ -1,4 +1,4 @@\n-/* CTF file creation.\n+/* CTF dict creation.\n    Copyright (C) 2019-2021 Free Software Foundation, Inc.\n \n    This file is part of libctf.\n@@ -19,13 +19,8 @@\n \n #include <ctf-impl.h>\n #include <sys/param.h>\n-#include <assert.h>\n #include <string.h>\n #include <unistd.h>\n-#include <zlib.h>\n-\n-#include <elf.h>\n-#include \"elf-bfd.h\"\n \n #ifndef EOVERFLOW\n #define EOVERFLOW ERANGE\n@@ -167,497 +162,6 @@ ctf_create (int *errp)\n   return NULL;\n }\n \n-/* Delete data symbols that have been assigned names from the variable section.\n-   Must be called from within ctf_serialize, because that is the only place\n-   you can safely delete variables without messing up ctf_rollback.  */\n-\n-static int\n-symtypetab_delete_nonstatic_vars (ctf_dict_t *fp, ctf_dict_t *symfp)\n-{\n-  ctf_dvdef_t *dvd, *nvd;\n-  ctf_id_t type;\n-\n-  for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL; dvd = nvd)\n-    {\n-      nvd = ctf_list_next (dvd);\n-\n-      if (((type = (ctf_id_t) (uintptr_t)\n-\t    ctf_dynhash_lookup (fp->ctf_objthash, dvd->dvd_name)) > 0)\n-\t  && ctf_dynhash_lookup (symfp->ctf_dynsyms, dvd->dvd_name) != NULL\n-\t  && type == dvd->dvd_type)\n-\tctf_dvd_delete (fp, dvd);\n-    }\n-\n-  return 0;\n-}\n-\n-/* Determine if a symbol is \"skippable\" and should never appear in the\n-   symtypetab sections.  */\n-\n-int\n-ctf_symtab_skippable (ctf_link_sym_t *sym)\n-{\n-  /* Never skip symbols whose name is not yet known.  */\n-  if (sym->st_nameidx_set)\n-    return 0;\n-\n-  return (sym->st_name == NULL || sym->st_name[0] == 0\n-\t  || sym->st_shndx == SHN_UNDEF\n-\t  || strcmp (sym->st_name, \"_START_\") == 0\n-\t  || strcmp (sym->st_name, \"_END_\") == 0\n-\t  || (sym->st_type == STT_OBJECT && sym->st_shndx == SHN_EXTABS\n-\t      && sym->st_value == 0));\n-}\n-\n-/* Symtypetab emission flags.  */\n-\n-#define CTF_SYMTYPETAB_EMIT_FUNCTION 0x1\n-#define CTF_SYMTYPETAB_EMIT_PAD 0x2\n-#define CTF_SYMTYPETAB_FORCE_INDEXED 0x4\n-\n-/* Get the number of symbols in a symbol hash, the count of symbols, the maximum\n-   seen, the eventual size, without any padding elements, of the func/data and\n-   (if generated) index sections, and the size of accumulated padding elements.\n-   The linker-reported set of symbols is found in SYMFP: it may be NULL if\n-   symbol filtering is not desired, in which case CTF_SYMTYPETAB_FORCE_INDEXED\n-   will always be set in the flags.\n-\n-   Also figure out if any symbols need to be moved to the variable section, and\n-   add them (if not already present).  */\n-\n-_libctf_nonnull_ ((1,3,4,5,6,7,8))\n-static int\n-symtypetab_density (ctf_dict_t *fp, ctf_dict_t *symfp, ctf_dynhash_t *symhash,\n-\t\t    size_t *count, size_t *max, size_t *unpadsize,\n-\t\t    size_t *padsize, size_t *idxsize, int flags)\n-{\n-  ctf_next_t *i = NULL;\n-  const void *name;\n-  const void *ctf_sym;\n-  ctf_dynhash_t *linker_known = NULL;\n-  int err;\n-  int beyond_max = 0;\n-\n-  *count = 0;\n-  *max = 0;\n-  *unpadsize = 0;\n-  *idxsize = 0;\n-  *padsize = 0;\n-\n-  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n-    {\n-      /* Make a dynhash citing only symbols reported by the linker of the\n-\t appropriate type, then traverse all potential-symbols we know the types\n-\t of, removing them from linker_known as we go.  Once this is done, the\n-\t only symbols remaining in linker_known are symbols we don't know the\n-\t types of: we must emit pads for those symbols that are below the\n-\t maximum symbol we will emit (any beyond that are simply skipped).\n-\n-\t If there are none, this symtypetab will be empty: just report that.  */\n-\n-      if (!symfp->ctf_dynsyms)\n-\treturn 0;\n-\n-      if ((linker_known = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n-\t\t\t\t\t      NULL, NULL)) == NULL)\n-\treturn (ctf_set_errno (fp, ENOMEM));\n-\n-      while ((err = ctf_dynhash_cnext (symfp->ctf_dynsyms, &i,\n-\t\t\t\t       &name, &ctf_sym)) == 0)\n-\t{\n-\t  ctf_link_sym_t *sym = (ctf_link_sym_t *) ctf_sym;\n-\n-\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-\t       && sym->st_type != STT_FUNC)\n-\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-\t\t  && sym->st_type != STT_OBJECT))\n-\t    continue;\n-\n-\t  if (ctf_symtab_skippable (sym))\n-\t    continue;\n-\n-\t  /* This should only be true briefly before all the names are\n-\t     finalized, long before we get this far.  */\n-\t  if (!ctf_assert (fp, !sym->st_nameidx_set))\n-\t    return -1;\t\t\t\t/* errno is set for us.  */\n-\n-\t  if (ctf_dynhash_cinsert (linker_known, name, ctf_sym) < 0)\n-\t    {\n-\t      ctf_dynhash_destroy (linker_known);\n-\t      return (ctf_set_errno (fp, ENOMEM));\n-\t    }\n-\t}\n-      if (err != ECTF_NEXT_END)\n-\t{\n-\t  ctf_err_warn (fp, 0, err, _(\"iterating over linker-known symbols during \"\n-\t\t\t\t  \"serialization\"));\n-\t  ctf_dynhash_destroy (linker_known);\n-\t  return (ctf_set_errno (fp, err));\n-\t}\n-    }\n-\n-  while ((err = ctf_dynhash_cnext (symhash, &i, &name, NULL)) == 0)\n-    {\n-      ctf_link_sym_t *sym;\n-\n-      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n-\t{\n-\t  /* Linker did not report symbol in symtab.  Remove it from the\n-\t     set of known data symbols and continue.  */\n-\t  if ((sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, name)) == NULL)\n-\t    {\n-\t      ctf_dynhash_remove (symhash, name);\n-\t      continue;\n-\t    }\n-\n-\t  /* We don't remove skippable symbols from the symhash because we don't\n-\t     want them to be migrated into variables.  */\n-\t  if (ctf_symtab_skippable (sym))\n-\t    continue;\n-\n-\t  if ((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-\t      && sym->st_type != STT_FUNC)\n-\t    {\n-\t      ctf_err_warn (fp, 1, 0, _(\"symbol %s (%x) added to CTF as a \"\n-\t\t\t\t\t\"function but is of type %x.  \"\n-\t\t\t\t\t\"The symbol type lookup tables \"\n-\t\t\t\t\t\"are probably corrupted\"),\n-\t\t\t    sym->st_name, sym->st_symidx, sym->st_type);\n-\t      ctf_dynhash_remove (symhash, name);\n-\t      continue;\n-\t    }\n-\t  else if (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-\t\t   && sym->st_type != STT_OBJECT)\n-\t    {\n-\t      ctf_err_warn (fp, 1, 0, _(\"symbol %s (%x) added to CTF as a \"\n-\t\t\t\t\t\"data object but is of type %x.  \"\n-\t\t\t\t\t\"The symbol type lookup tables \"\n-\t\t\t\t\t\"are probably corrupted\"),\n-\t\t\t    sym->st_name, sym->st_symidx, sym->st_type);\n-\t      ctf_dynhash_remove (symhash, name);\n-\t      continue;\n-\t    }\n-\n-\t  ctf_dynhash_remove (linker_known, name);\n-\t}\n-      *unpadsize += sizeof (uint32_t);\n-      (*count)++;\n-\n-      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n-\t{\n-\t  if (*max < sym->st_symidx)\n-\t    *max = sym->st_symidx;\n-\t}\n-      else\n-\t(*max)++;\n-    }\n-  if (err != ECTF_NEXT_END)\n-    {\n-      ctf_err_warn (fp, 0, err, _(\"iterating over CTF symtypetab during \"\n-\t\t\t\t  \"serialization\"));\n-      ctf_dynhash_destroy (linker_known);\n-      return (ctf_set_errno (fp, err));\n-    }\n-\n-  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n-    {\n-      while ((err = ctf_dynhash_cnext (linker_known, &i, NULL, &ctf_sym)) == 0)\n-\t{\n-\t  ctf_link_sym_t *sym = (ctf_link_sym_t *) ctf_sym;\n-\n-\t  if (sym->st_symidx > *max)\n-\t    beyond_max++;\n-\t}\n-      if (err != ECTF_NEXT_END)\n-\t{\n-\t  ctf_err_warn (fp, 0, err, _(\"iterating over linker-known symbols \"\n-\t\t\t\t      \"during CTF serialization\"));\n-\t  ctf_dynhash_destroy (linker_known);\n-\t  return (ctf_set_errno (fp, err));\n-\t}\n-    }\n-\n-  *idxsize = *count * sizeof (uint32_t);\n-  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n-    *padsize = (ctf_dynhash_elements (linker_known) - beyond_max) * sizeof (uint32_t);\n-\n-  ctf_dynhash_destroy (linker_known);\n-  return 0;\n-}\n-\n-/* Emit an objt or func symtypetab into DP in a particular order defined by an\n-   array of ctf_link_sym_t or symbol names passed in.  The index has NIDX\n-   elements in it: unindexed output would terminate at symbol OUTMAX and is in\n-   any case no larger than SIZE bytes.  Some index elements are expected to be\n-   skipped: see symtypetab_density.  The linker-reported set of symbols (if any)\n-   is found in SYMFP. */\n-static int\n-emit_symtypetab (ctf_dict_t *fp, ctf_dict_t *symfp, uint32_t *dp,\n-\t\t ctf_link_sym_t **idx, const char **nameidx, uint32_t nidx,\n-\t\t uint32_t outmax, int size, int flags)\n-{\n-  uint32_t i;\n-  uint32_t *dpp = dp;\n-  ctf_dynhash_t *symhash;\n-\n-  ctf_dprintf (\"Emitting table of size %i, outmax %u, %u symtypetab entries, \"\n-\t       \"flags %i\\n\", size, outmax, nidx, flags);\n-\n-  /* Empty table? Nothing to do.  */\n-  if (size == 0)\n-    return 0;\n-\n-  if (flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-    symhash = fp->ctf_funchash;\n-  else\n-    symhash = fp->ctf_objthash;\n-\n-  for (i = 0; i < nidx; i++)\n-    {\n-      const char *sym_name;\n-      void *type;\n-\n-      /* If we have a linker-reported set of symbols, we may be given that set\n-\t to work from, or a set of symbol names.  In both cases we want to look\n-\t at the corresponding linker-reported symbol (if any).  */\n-      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n-\t{\n-\t  ctf_link_sym_t *this_link_sym;\n-\n-\t  if (idx)\n-\t    this_link_sym = idx[i];\n-\t  else\n-\t    this_link_sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, nameidx[i]);\n-\n-\t  /* Unreported symbol number.  No pad, no nothing.  */\n-\t  if (!this_link_sym)\n-\t    continue;\n-\n-\t  /* Symbol of the wrong type, or skippable?  This symbol is not in this\n-\t     table.  */\n-\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-\t       && this_link_sym->st_type != STT_FUNC)\n-\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-\t\t  && this_link_sym->st_type != STT_OBJECT))\n-\t    continue;\n-\n-\t  if (ctf_symtab_skippable (this_link_sym))\n-\t    continue;\n-\n-\t  sym_name = this_link_sym->st_name;\n-\n-\t  /* Linker reports symbol of a different type to the symbol we actually\n-\t     added?  Skip the symbol.  No pad, since the symbol doesn't actually\n-\t     belong in this table at all.  (Warned about in\n-\t     symtypetab_density.)  */\n-\t  if ((this_link_sym->st_type == STT_FUNC)\n-\t      && (ctf_dynhash_lookup (fp->ctf_objthash, sym_name)))\n-\t    continue;\n-\n-\t  if ((this_link_sym->st_type == STT_OBJECT)\n-\t      && (ctf_dynhash_lookup (fp->ctf_funchash, sym_name)))\n-\t    continue;\n-\t}\n-      else\n-\tsym_name = nameidx[i];\n-\n-      /* Symbol in index but no type set? Silently skip and (optionally)\n-\t pad.  (In force-indexed mode, this is also where we track symbols of\n-\t the wrong type for this round of insertion.)  */\n-      if ((type = ctf_dynhash_lookup (symhash, sym_name)) == NULL)\n-\t{\n-\t  if (flags & CTF_SYMTYPETAB_EMIT_PAD)\n-\t    *dpp++ = 0;\n-\t  continue;\n-\t}\n-\n-      if (!ctf_assert (fp, (((char *) dpp) - (char *) dp) < size))\n-\treturn -1;\t\t\t\t/* errno is set for us.  */\n-\n-      *dpp++ = (ctf_id_t) (uintptr_t) type;\n-\n-      /* When emitting unindexed output, all later symbols are pads: stop\n-\t early.  */\n-      if ((flags & CTF_SYMTYPETAB_EMIT_PAD) && idx[i]->st_symidx == outmax)\n-\tbreak;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Emit an objt or func symtypetab index into DP in a paticular order defined by\n-   an array of symbol names passed in.  Stop at NIDX.  The linker-reported set\n-   of symbols (if any) is found in SYMFP. */\n-static int\n-emit_symtypetab_index (ctf_dict_t *fp, ctf_dict_t *symfp, uint32_t *dp,\n-\t\t       const char **idx, uint32_t nidx, int size, int flags)\n-{\n-  uint32_t i;\n-  uint32_t *dpp = dp;\n-  ctf_dynhash_t *symhash;\n-\n-  ctf_dprintf (\"Emitting index of size %i, %u entries reported by linker, \"\n-\t       \"flags %i\\n\", size, nidx, flags);\n-\n-  /* Empty table? Nothing to do.  */\n-  if (size == 0)\n-    return 0;\n-\n-  if (flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-    symhash = fp->ctf_funchash;\n-  else\n-    symhash = fp->ctf_objthash;\n-\n-  /* Indexes should always be unpadded.  */\n-  if (!ctf_assert (fp, !(flags & CTF_SYMTYPETAB_EMIT_PAD)))\n-    return -1;\t\t\t\t\t/* errno is set for us.  */\n-\n-  for (i = 0; i < nidx; i++)\n-    {\n-      const char *sym_name;\n-      void *type;\n-\n-      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n-\t{\n-\t  ctf_link_sym_t *this_link_sym;\n-\n-\t  this_link_sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, idx[i]);\n-\n-\t  /* This is an index: unreported symbols should never appear in it.  */\n-\t  if (!ctf_assert (fp, this_link_sym != NULL))\n-\t    return -1;\t\t\t\t/* errno is set for us.  */\n-\n-\t  /* Symbol of the wrong type, or skippable?  This symbol is not in this\n-\t     table.  */\n-\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-\t       && this_link_sym->st_type != STT_FUNC)\n-\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n-\t\t  && this_link_sym->st_type != STT_OBJECT))\n-\t    continue;\n-\n-\t  if (ctf_symtab_skippable (this_link_sym))\n-\t    continue;\n-\n-\t  sym_name = this_link_sym->st_name;\n-\n-\t  /* Linker reports symbol of a different type to the symbol we actually\n-\t     added?  Skip the symbol.  */\n-\t  if ((this_link_sym->st_type == STT_FUNC)\n-\t      && (ctf_dynhash_lookup (fp->ctf_objthash, sym_name)))\n-\t    continue;\n-\n-\t  if ((this_link_sym->st_type == STT_OBJECT)\n-\t      && (ctf_dynhash_lookup (fp->ctf_funchash, sym_name)))\n-\t    continue;\n-\t}\n-      else\n-\tsym_name = idx[i];\n-\n-      /* Symbol in index and reported by linker, but no type set? Silently skip\n-\t and (optionally) pad.  (In force-indexed mode, this is also where we\n-\t track symbols of the wrong type for this round of insertion.)  */\n-      if ((type = ctf_dynhash_lookup (symhash, sym_name)) == NULL)\n-\tcontinue;\n-\n-      ctf_str_add_ref (fp, sym_name, dpp++);\n-\n-      if (!ctf_assert (fp, (((char *) dpp) - (char *) dp) <= size))\n-\treturn -1;\t\t\t\t/* errno is set for us.  */\n-    }\n-\n-  return 0;\n-}\n-\n-static unsigned char *\n-ctf_copy_smembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n-{\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  ctf_member_t ctm;\n-\n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n-    {\n-      ctf_member_t *copied;\n-\n-      ctm.ctm_name = 0;\n-      ctm.ctm_type = (uint32_t) dmd->dmd_type;\n-      ctm.ctm_offset = (uint32_t) dmd->dmd_offset;\n-\n-      memcpy (t, &ctm, sizeof (ctm));\n-      copied = (ctf_member_t *) t;\n-      if (dmd->dmd_name)\n-\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctm_name);\n-\n-      t += sizeof (ctm);\n-    }\n-\n-  return t;\n-}\n-\n-static unsigned char *\n-ctf_copy_lmembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n-{\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  ctf_lmember_t ctlm;\n-\n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n-    {\n-      ctf_lmember_t *copied;\n-\n-      ctlm.ctlm_name = 0;\n-      ctlm.ctlm_type = (uint32_t) dmd->dmd_type;\n-      ctlm.ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (dmd->dmd_offset);\n-      ctlm.ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (dmd->dmd_offset);\n-\n-      memcpy (t, &ctlm, sizeof (ctlm));\n-      copied = (ctf_lmember_t *) t;\n-      if (dmd->dmd_name)\n-\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctlm_name);\n-\n-      t += sizeof (ctlm);\n-    }\n-\n-  return t;\n-}\n-\n-static unsigned char *\n-ctf_copy_emembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n-{\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  ctf_enum_t cte;\n-\n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n-    {\n-      ctf_enum_t *copied;\n-\n-      cte.cte_value = dmd->dmd_value;\n-      memcpy (t, &cte, sizeof (cte));\n-      copied = (ctf_enum_t *) t;\n-      ctf_str_add_ref (fp, dmd->dmd_name, &copied->cte_name);\n-      t += sizeof (cte);\n-    }\n-\n-  return t;\n-}\n-\n-/* Sort a newly-constructed static variable array.  */\n-\n-typedef struct ctf_sort_var_arg_cb\n-{\n-  ctf_dict_t *fp;\n-  ctf_strs_t *strtab;\n-} ctf_sort_var_arg_cb_t;\n-\n-static int\n-ctf_sort_var (const void *one_, const void *two_, void *arg_)\n-{\n-  const ctf_varent_t *one = one_;\n-  const ctf_varent_t *two = two_;\n-  ctf_sort_var_arg_cb_t *arg = arg_;\n-\n-  return (strcmp (ctf_strraw_explicit (arg->fp, one->ctv_name, arg->strtab),\n-\t\t  ctf_strraw_explicit (arg->fp, two->ctv_name, arg->strtab)));\n-}\n-\n /* Compatibility: just update the threshold for ctf_discard.  */\n int\n ctf_update (ctf_dict_t *fp)\n@@ -669,627 +173,6 @@ ctf_update (ctf_dict_t *fp)\n   return 0;\n }\n \n-/* If the specified CTF dict is writable and has been modified, reload this dict\n-   with the updated type definitions, ready for serialization.  In order to make\n-   this code and the rest of libctf as simple as possible, we perform updates by\n-   taking the dynamic type definitions and creating an in-memory CTF dict\n-   containing the definitions, and then call ctf_simple_open_internal() on it.\n-   We perform one extra trick here for the benefit of callers and to keep our\n-   code simple: ctf_simple_open_internal() will return a new ctf_dict_t, but we\n-   want to keep the fp constant for the caller, so after\n-   ctf_simple_open_internal() returns, we use memcpy to swap the interior of the\n-   old and new ctf_dict_t's, and then free the old.  */\n-int\n-ctf_serialize (ctf_dict_t *fp)\n-{\n-  ctf_dict_t ofp, *nfp;\n-  ctf_header_t hdr, *hdrp;\n-  ctf_dtdef_t *dtd;\n-  ctf_dvdef_t *dvd;\n-  ctf_varent_t *dvarents;\n-  ctf_strs_writable_t strtab;\n-\n-  unsigned char *t;\n-  unsigned long i;\n-  size_t buf_size, type_size, objt_size, func_size;\n-  size_t objt_unpadsize, func_unpadsize, objt_padsize, func_padsize;\n-  size_t funcidx_size, objtidx_size;\n-  size_t nvars, nfuncs, nobjts, maxobjt, maxfunc;\n-  size_t nsymtypes = 0;\n-  const char **sym_name_order = NULL;\n-  unsigned char *buf = NULL, *newbuf;\n-  int err;\n-\n-  /* Symtab filtering. If filter_syms is true, symfp is set: otherwise,\n-     CTF_SYMTYPETAB_FORCE_INDEXED is set in symflags.  */\n-  int filter_syms = 0;\n-  int sort_syms = 1;\n-  int symflags = 0;\n-  ctf_dict_t *symfp = NULL;\n-\n-  if (!(fp->ctf_flags & LCTF_RDWR))\n-    return (ctf_set_errno (fp, ECTF_RDONLY));\n-\n-  /* Update required?  */\n-  if (!(fp->ctf_flags & LCTF_DIRTY))\n-    return 0;\n-\n-  /* If doing a writeout as part of linking, and the link flags request it,\n-     filter out reported symbols from the variable section, and filter out all\n-     other symbols from the symtypetab sections.  (If we are not linking, the\n-     symbols are sorted; if we are linking, don't bother sorting if we are not\n-     filtering out reported symbols: this is almost certaily an ld -r and only\n-     the linker is likely to consume these symtypetabs again.  The linker\n-     doesn't care what order the symtypetab entries is in, since it only\n-     iterates over symbols and does not use the ctf_lookup_by_symbol* API.)  */\n-\n-  if (fp->ctf_flags & LCTF_LINKING)\n-    {\n-      filter_syms = !(fp->ctf_link_flags & CTF_LINK_NO_FILTER_REPORTED_SYMS);\n-      if (!filter_syms)\n-\tsort_syms = 0;\n-    }\n-\n-  /* Fill in an initial CTF header.  We will leave the label, object,\n-     and function sections empty and only output a header, type section,\n-     and string table.  The type section begins at a 4-byte aligned\n-     boundary past the CTF header itself (at relative offset zero).  The flag\n-     indicating a new-style function info section (an array of CTF_K_FUNCTION\n-     type IDs in the types section) is flipped on.  */\n-\n-  memset (&hdr, 0, sizeof (hdr));\n-  hdr.cth_magic = CTF_MAGIC;\n-  hdr.cth_version = CTF_VERSION;\n-\n-  /* This is a new-format func info section, and the symtab and strtab come out\n-     of the dynsym and dynstr these days.  */\n-  hdr.cth_flags = (CTF_F_NEWFUNCINFO | CTF_F_DYNSTR);\n-\n-  /* Iterate through the dynamic type definition list and compute the\n-     size of the CTF type section we will need to generate.  */\n-\n-  for (type_size = 0, dtd = ctf_list_next (&fp->ctf_dtdefs);\n-       dtd != NULL; dtd = ctf_list_next (dtd))\n-    {\n-      uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n-      uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n-\n-      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n-\ttype_size += sizeof (ctf_stype_t);\n-      else\n-\ttype_size += sizeof (ctf_type_t);\n-\n-      switch (kind)\n-\t{\n-\tcase CTF_K_INTEGER:\n-\tcase CTF_K_FLOAT:\n-\t  type_size += sizeof (uint32_t);\n-\t  break;\n-\tcase CTF_K_ARRAY:\n-\t  type_size += sizeof (ctf_array_t);\n-\t  break;\n-\tcase CTF_K_SLICE:\n-\t  type_size += sizeof (ctf_slice_t);\n-\t  break;\n-\tcase CTF_K_FUNCTION:\n-\t  type_size += sizeof (uint32_t) * (vlen + (vlen & 1));\n-\t  break;\n-\tcase CTF_K_STRUCT:\n-\tcase CTF_K_UNION:\n-\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n-\t    type_size += sizeof (ctf_member_t) * vlen;\n-\t  else\n-\t    type_size += sizeof (ctf_lmember_t) * vlen;\n-\t  break;\n-\tcase CTF_K_ENUM:\n-\t  type_size += sizeof (ctf_enum_t) * vlen;\n-\t  break;\n-\t}\n-    }\n-\n-  /* Find the dict to which the linker has reported symbols, if any.  */\n-\n-  if (filter_syms)\n-    {\n-      if (!fp->ctf_dynsyms && fp->ctf_parent && fp->ctf_parent->ctf_dynsyms)\n-\tsymfp = fp->ctf_parent;\n-      else\n-\tsymfp = fp;\n-    }\n-\n-  /* If not filtering, keep all potential symbols in an unsorted, indexed\n-     dict.  */\n-  if (!filter_syms)\n-    symflags = CTF_SYMTYPETAB_FORCE_INDEXED;\n-  else\n-    hdr.cth_flags |= CTF_F_IDXSORTED;\n-\n-  if (!ctf_assert (fp, (filter_syms && symfp)\n-\t\t   || (!filter_syms && !symfp\n-\t\t       && ((symflags & CTF_SYMTYPETAB_FORCE_INDEXED) != 0))))\n-    return -1;\n-\n-  /* Work out the sizes of the object and function sections, and work out the\n-     number of pad (unassigned) symbols in each, and the overall size of the\n-     sections.  */\n-\n-  if (symtypetab_density (fp, symfp, fp->ctf_objthash, &nobjts, &maxobjt,\n-\t\t\t  &objt_unpadsize, &objt_padsize, &objtidx_size,\n-\t\t\t  symflags) < 0)\n-    return -1;\t\t\t\t\t/* errno is set for us.  */\n-\n-  ctf_dprintf (\"Object symtypetab: %i objects, max %i, unpadded size %i, \"\n-\t       \"%i bytes of pads, index size %i\\n\", (int) nobjts, (int) maxobjt,\n-\t       (int) objt_unpadsize, (int) objt_padsize, (int) objtidx_size);\n-\n-  if (symtypetab_density (fp, symfp, fp->ctf_funchash, &nfuncs, &maxfunc,\n-\t\t\t  &func_unpadsize, &func_padsize, &funcidx_size,\n-\t\t\t  symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n-    return -1;\t\t\t\t\t/* errno is set for us.  */\n-\n-  ctf_dprintf (\"Function symtypetab: %i functions, max %i, unpadded size %i, \"\n-\t       \"%i bytes of pads, index size %i\\n\", (int) nfuncs, (int) maxfunc,\n-\t       (int) func_unpadsize, (int) func_padsize, (int) funcidx_size);\n-\n-  /* If we are filtering symbols out, those symbols that the linker has not\n-     reported have now been removed from the ctf_objthash and ctf_funchash.\n-     Delete entries from the variable section that duplicate newly-added data\n-     symbols.  There's no need to migrate new ones in, because the compiler\n-     always emits both a variable and a data symbol simultaneously, and\n-     filtering only happens at final link time.  */\n-\n-  if (filter_syms && symfp->ctf_dynsyms &&\n-      symtypetab_delete_nonstatic_vars (fp, symfp) < 0)\n-    return -1;\n-\n-  /* It is worth indexing each section if it would save space to do so, due to\n-     reducing the number of pads sufficiently.  A pad is the same size as a\n-     single index entry: but index sections compress relatively poorly compared\n-     to constant pads, so it takes a lot of contiguous padding to equal one\n-     index section entry.  It would be nice to be able to *verify* whether we\n-     would save space after compression rather than guessing, but this seems\n-     difficult, since it would require complete reserialization.  Regardless, if\n-     the linker has not reported any symbols (e.g. if this is not a final link\n-     but just an ld -r), we must emit things in indexed fashion just as the\n-     compiler does.  */\n-\n-  objt_size = objt_unpadsize;\n-  if (!(symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n-      && ((objt_padsize + objt_unpadsize) * CTF_INDEX_PAD_THRESHOLD\n-\t  > objt_padsize))\n-    {\n-      objt_size += objt_padsize;\n-      objtidx_size = 0;\n-    }\n-\n-  func_size = func_unpadsize;\n-  if (!(symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n-      && ((func_padsize + func_unpadsize) * CTF_INDEX_PAD_THRESHOLD\n-\t  > func_padsize))\n-    {\n-      func_size += func_padsize;\n-      funcidx_size = 0;\n-    }\n-\n-  /* Computing the number of entries in the CTF variable section is much\n-     simpler.  */\n-\n-  for (nvars = 0, dvd = ctf_list_next (&fp->ctf_dvdefs);\n-       dvd != NULL; dvd = ctf_list_next (dvd), nvars++);\n-\n-  /* Compute the size of the CTF buffer we need, sans only the string table,\n-     then allocate a new buffer and memcpy the finished header to the start of\n-     the buffer.  (We will adjust this later with strtab length info.)  */\n-\n-  hdr.cth_lbloff = hdr.cth_objtoff = 0;\n-  hdr.cth_funcoff = hdr.cth_objtoff + objt_size;\n-  hdr.cth_objtidxoff = hdr.cth_funcoff + func_size;\n-  hdr.cth_funcidxoff = hdr.cth_objtidxoff + objtidx_size;\n-  hdr.cth_varoff = hdr.cth_funcidxoff + funcidx_size;\n-  hdr.cth_typeoff = hdr.cth_varoff + (nvars * sizeof (ctf_varent_t));\n-  hdr.cth_stroff = hdr.cth_typeoff + type_size;\n-  hdr.cth_strlen = 0;\n-\n-  buf_size = sizeof (ctf_header_t) + hdr.cth_stroff + hdr.cth_strlen;\n-\n-  if ((buf = malloc (buf_size)) == NULL)\n-    return (ctf_set_errno (fp, EAGAIN));\n-\n-  memcpy (buf, &hdr, sizeof (ctf_header_t));\n-  t = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_objtoff;\n-\n-  hdrp = (ctf_header_t *) buf;\n-  if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parname != NULL))\n-    ctf_str_add_ref (fp, fp->ctf_parname, &hdrp->cth_parname);\n-  if (fp->ctf_cuname != NULL)\n-    ctf_str_add_ref (fp, fp->ctf_cuname, &hdrp->cth_cuname);\n-\n-  /* Sort the linker's symbols into name order if need be.  */\n-\n-  if ((objtidx_size != 0) || (funcidx_size != 0))\n-    {\n-      ctf_next_t *i = NULL;\n-      void *symname;\n-      const char **walk;\n-\n-      if (filter_syms)\n-\t{\n-\t  if (symfp->ctf_dynsyms)\n-\t    nsymtypes = ctf_dynhash_elements (symfp->ctf_dynsyms);\n-\t  else\n-\t    nsymtypes = 0;\n-\t}\n-      else\n-\tnsymtypes = ctf_dynhash_elements (fp->ctf_objthash)\n-\t  + ctf_dynhash_elements (fp->ctf_funchash);\n-\n-      if ((sym_name_order = calloc (nsymtypes, sizeof (const char *))) == NULL)\n-\tgoto oom;\n-\n-      walk = sym_name_order;\n-\n-      if (filter_syms)\n-\t{\n-\t  if (symfp->ctf_dynsyms)\n-\t    {\n-\t      while ((err = ctf_dynhash_next_sorted (symfp->ctf_dynsyms, &i,\n-\t\t\t\t\t\t     &symname, NULL,\n-\t\t\t\t\t\t     ctf_dynhash_sort_by_name,\n-\t\t\t\t\t\t     NULL)) == 0)\n-\t\t*walk++ = (const char *) symname;\n-\t      if (err != ECTF_NEXT_END)\n-\t\tgoto symerr;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  ctf_hash_sort_f sort_fun = NULL;\n-\n-\t  /* Since we partition the set of symbols back into objt and func,\n-\t     we can sort the two independently without harm.  */\n-\t  if (sort_syms)\n-\t    sort_fun = ctf_dynhash_sort_by_name;\n-\n-\t  while ((err = ctf_dynhash_next_sorted (fp->ctf_objthash, &i, &symname,\n-\t\t\t\t\t\t NULL, sort_fun, NULL)) == 0)\n-\t    *walk++ = (const char *) symname;\n-\t  if (err != ECTF_NEXT_END)\n-\t    goto symerr;\n-\n-\t  while ((err = ctf_dynhash_next_sorted (fp->ctf_funchash, &i, &symname,\n-\t\t\t\t\t\t NULL, sort_fun, NULL)) == 0)\n-\t    *walk++ = (const char *) symname;\n-\t  if (err != ECTF_NEXT_END)\n-\t    goto symerr;\n-\t}\n-    }\n-\n-  /* Emit the object and function sections, and if necessary their indexes.\n-     Emission is done in symtab order if there is no index, and in index\n-     (name) order otherwise.  */\n-\n-  if ((objtidx_size == 0) && symfp && symfp->ctf_dynsymidx)\n-    {\n-      ctf_dprintf (\"Emitting unindexed objt symtypetab\\n\");\n-      if (emit_symtypetab (fp, symfp, (uint32_t *) t, symfp->ctf_dynsymidx,\n-\t\t\t   NULL, symfp->ctf_dynsymmax + 1, maxobjt, objt_size,\n-\t\t\t   symflags | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n-\tgoto err;\t\t\t\t/* errno is set for us.  */\n-    }\n-  else\n-    {\n-      ctf_dprintf (\"Emitting indexed objt symtypetab\\n\");\n-      if (emit_symtypetab (fp, symfp, (uint32_t *) t, NULL, sym_name_order,\n-\t\t\t   nsymtypes, maxobjt, objt_size, symflags) < 0)\n-\tgoto err;\t\t\t\t/* errno is set for us.  */\n-    }\n-\n-  t += objt_size;\n-\n-  if ((funcidx_size == 0) && symfp && symfp->ctf_dynsymidx)\n-    {\n-      ctf_dprintf (\"Emitting unindexed func symtypetab\\n\");\n-      if (emit_symtypetab (fp, symfp, (uint32_t *) t, symfp->ctf_dynsymidx,\n-\t\t\t   NULL, symfp->ctf_dynsymmax + 1, maxfunc,\n-\t\t\t   func_size, symflags | CTF_SYMTYPETAB_EMIT_FUNCTION\n-\t\t\t   | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n-\tgoto err;\t\t\t\t/* errno is set for us.  */\n-    }\n-  else\n-    {\n-      ctf_dprintf (\"Emitting indexed func symtypetab\\n\");\n-      if (emit_symtypetab (fp, symfp, (uint32_t *) t, NULL, sym_name_order,\n-\t\t\t   nsymtypes, maxfunc, func_size,\n-\t\t\t   symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n-\tgoto err;\t\t\t\t/* errno is set for us.  */\n-    }\n-\n-  t += func_size;\n-\n-  if (objtidx_size > 0)\n-    if (emit_symtypetab_index (fp, symfp, (uint32_t *) t, sym_name_order,\n-\t\t\t       nsymtypes, objtidx_size, symflags) < 0)\n-      goto err;\n-\n-  t += objtidx_size;\n-\n-  if (funcidx_size > 0)\n-    if (emit_symtypetab_index (fp, symfp, (uint32_t *) t, sym_name_order,\n-\t\t\t       nsymtypes, funcidx_size,\n-\t\t\t       symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n-      goto err;\n-\n-  t += funcidx_size;\n-  free (sym_name_order);\n-  sym_name_order = NULL;\n-\n-  /* Work over the variable list, translating everything into ctf_varent_t's and\n-     prepping the string table.  */\n-\n-  dvarents = (ctf_varent_t *) t;\n-  for (i = 0, dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL;\n-       dvd = ctf_list_next (dvd), i++)\n-    {\n-      ctf_varent_t *var = &dvarents[i];\n-\n-      ctf_str_add_ref (fp, dvd->dvd_name, &var->ctv_name);\n-      var->ctv_type = (uint32_t) dvd->dvd_type;\n-    }\n-  assert (i == nvars);\n-\n-  t += sizeof (ctf_varent_t) * nvars;\n-\n-  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_typeoff);\n-\n-  /* We now take a final lap through the dynamic type definition list and copy\n-     the appropriate type records to the output buffer, noting down the\n-     strings as we go.  */\n-\n-  for (dtd = ctf_list_next (&fp->ctf_dtdefs);\n-       dtd != NULL; dtd = ctf_list_next (dtd))\n-    {\n-      uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n-      uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n-\n-      ctf_array_t cta;\n-      uint32_t encoding;\n-      size_t len;\n-      ctf_stype_t *copied;\n-      const char *name;\n-\n-      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n-\tlen = sizeof (ctf_stype_t);\n-      else\n-\tlen = sizeof (ctf_type_t);\n-\n-      memcpy (t, &dtd->dtd_data, len);\n-      copied = (ctf_stype_t *) t;  /* name is at the start: constant offset.  */\n-      if (copied->ctt_name\n-\t  && (name = ctf_strraw (fp, copied->ctt_name)) != NULL)\n-\tctf_str_add_ref (fp, name, &copied->ctt_name);\n-      t += len;\n-\n-      switch (kind)\n-\t{\n-\tcase CTF_K_INTEGER:\n-\tcase CTF_K_FLOAT:\n-\t  if (kind == CTF_K_INTEGER)\n-\t    {\n-\t      encoding = CTF_INT_DATA (dtd->dtd_u.dtu_enc.cte_format,\n-\t\t\t\t       dtd->dtd_u.dtu_enc.cte_offset,\n-\t\t\t\t       dtd->dtd_u.dtu_enc.cte_bits);\n-\t    }\n-\t  else\n-\t    {\n-\t      encoding = CTF_FP_DATA (dtd->dtd_u.dtu_enc.cte_format,\n-\t\t\t\t      dtd->dtd_u.dtu_enc.cte_offset,\n-\t\t\t\t      dtd->dtd_u.dtu_enc.cte_bits);\n-\t    }\n-\t  memcpy (t, &encoding, sizeof (encoding));\n-\t  t += sizeof (encoding);\n-\t  break;\n-\n-\tcase CTF_K_SLICE:\n-\t  memcpy (t, &dtd->dtd_u.dtu_slice, sizeof (struct ctf_slice));\n-\t  t += sizeof (struct ctf_slice);\n-\t  break;\n-\n-\tcase CTF_K_ARRAY:\n-\t  cta.cta_contents = (uint32_t) dtd->dtd_u.dtu_arr.ctr_contents;\n-\t  cta.cta_index = (uint32_t) dtd->dtd_u.dtu_arr.ctr_index;\n-\t  cta.cta_nelems = dtd->dtd_u.dtu_arr.ctr_nelems;\n-\t  memcpy (t, &cta, sizeof (cta));\n-\t  t += sizeof (cta);\n-\t  break;\n-\n-\tcase CTF_K_FUNCTION:\n-\t  {\n-\t    uint32_t *argv = (uint32_t *) (uintptr_t) t;\n-\t    uint32_t argc;\n-\n-\t    for (argc = 0; argc < vlen; argc++)\n-\t      *argv++ = dtd->dtd_u.dtu_argv[argc];\n-\n-\t    if (vlen & 1)\n-\t      *argv++ = 0;\t/* Pad to 4-byte boundary.  */\n-\n-\t    t = (unsigned char *) argv;\n-\t    break;\n-\t  }\n-\n-\tcase CTF_K_STRUCT:\n-\tcase CTF_K_UNION:\n-\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n-\t    t = ctf_copy_smembers (fp, dtd, t);\n-\t  else\n-\t    t = ctf_copy_lmembers (fp, dtd, t);\n-\t  break;\n-\n-\tcase CTF_K_ENUM:\n-\t  t = ctf_copy_emembers (fp, dtd, t);\n-\t  break;\n-\t}\n-    }\n-  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_stroff);\n-\n-  /* Construct the final string table and fill out all the string refs with the\n-     final offsets.  Then purge the refs list, because we're about to move this\n-     strtab onto the end of the buf, invalidating all the offsets.  */\n-  strtab = ctf_str_write_strtab (fp);\n-  ctf_str_purge_refs (fp);\n-\n-  if (strtab.cts_strs == NULL)\n-    goto oom;\n-\n-  /* Now the string table is constructed, we can sort the buffer of\n-     ctf_varent_t's.  */\n-  ctf_sort_var_arg_cb_t sort_var_arg = { fp, (ctf_strs_t *) &strtab };\n-  ctf_qsort_r (dvarents, nvars, sizeof (ctf_varent_t), ctf_sort_var,\n-\t       &sort_var_arg);\n-\n-  if ((newbuf = ctf_realloc (fp, buf, buf_size + strtab.cts_len)) == NULL)\n-    {\n-      free (strtab.cts_strs);\n-      goto oom;\n-    }\n-  buf = newbuf;\n-  memcpy (buf + buf_size, strtab.cts_strs, strtab.cts_len);\n-  hdrp = (ctf_header_t *) buf;\n-  hdrp->cth_strlen = strtab.cts_len;\n-  buf_size += hdrp->cth_strlen;\n-  free (strtab.cts_strs);\n-\n-  /* Finally, we are ready to ctf_simple_open() the new dict.  If this is\n-     successful, we then switch nfp and fp and free the old dict.  */\n-\n-  if ((nfp = ctf_simple_open_internal ((char *) buf, buf_size, NULL, 0,\n-\t\t\t\t       0, NULL, 0, fp->ctf_syn_ext_strtab,\n-\t\t\t\t       1, &err)) == NULL)\n-    {\n-      free (buf);\n-      return (ctf_set_errno (fp, err));\n-    }\n-\n-  (void) ctf_setmodel (nfp, ctf_getmodel (fp));\n-\n-  nfp->ctf_parent = fp->ctf_parent;\n-  nfp->ctf_parent_unreffed = fp->ctf_parent_unreffed;\n-  nfp->ctf_refcnt = fp->ctf_refcnt;\n-  nfp->ctf_flags |= fp->ctf_flags & ~LCTF_DIRTY;\n-  if (nfp->ctf_dynbase == NULL)\n-    nfp->ctf_dynbase = buf;\t\t/* Make sure buf is freed on close.  */\n-  nfp->ctf_dthash = fp->ctf_dthash;\n-  nfp->ctf_dtdefs = fp->ctf_dtdefs;\n-  nfp->ctf_dvhash = fp->ctf_dvhash;\n-  nfp->ctf_dvdefs = fp->ctf_dvdefs;\n-  nfp->ctf_dtoldid = fp->ctf_dtoldid;\n-  nfp->ctf_add_processing = fp->ctf_add_processing;\n-  nfp->ctf_snapshots = fp->ctf_snapshots + 1;\n-  nfp->ctf_specific = fp->ctf_specific;\n-  nfp->ctf_nfuncidx = fp->ctf_nfuncidx;\n-  nfp->ctf_nobjtidx = fp->ctf_nobjtidx;\n-  nfp->ctf_objthash = fp->ctf_objthash;\n-  nfp->ctf_funchash = fp->ctf_funchash;\n-  nfp->ctf_dynsyms = fp->ctf_dynsyms;\n-  nfp->ctf_ptrtab = fp->ctf_ptrtab;\n-  nfp->ctf_pptrtab = fp->ctf_pptrtab;\n-  nfp->ctf_dynsymidx = fp->ctf_dynsymidx;\n-  nfp->ctf_dynsymmax = fp->ctf_dynsymmax;\n-  nfp->ctf_ptrtab_len = fp->ctf_ptrtab_len;\n-  nfp->ctf_pptrtab_len = fp->ctf_pptrtab_len;\n-  nfp->ctf_link_inputs = fp->ctf_link_inputs;\n-  nfp->ctf_link_outputs = fp->ctf_link_outputs;\n-  nfp->ctf_errs_warnings = fp->ctf_errs_warnings;\n-  nfp->ctf_funcidx_names = fp->ctf_funcidx_names;\n-  nfp->ctf_objtidx_names = fp->ctf_objtidx_names;\n-  nfp->ctf_funcidx_sxlate = fp->ctf_funcidx_sxlate;\n-  nfp->ctf_objtidx_sxlate = fp->ctf_objtidx_sxlate;\n-  nfp->ctf_str_prov_offset = fp->ctf_str_prov_offset;\n-  nfp->ctf_syn_ext_strtab = fp->ctf_syn_ext_strtab;\n-  nfp->ctf_pptrtab_typemax = fp->ctf_pptrtab_typemax;\n-  nfp->ctf_in_flight_dynsyms = fp->ctf_in_flight_dynsyms;\n-  nfp->ctf_link_in_cu_mapping = fp->ctf_link_in_cu_mapping;\n-  nfp->ctf_link_out_cu_mapping = fp->ctf_link_out_cu_mapping;\n-  nfp->ctf_link_type_mapping = fp->ctf_link_type_mapping;\n-  nfp->ctf_link_memb_name_changer = fp->ctf_link_memb_name_changer;\n-  nfp->ctf_link_memb_name_changer_arg = fp->ctf_link_memb_name_changer_arg;\n-  nfp->ctf_link_variable_filter = fp->ctf_link_variable_filter;\n-  nfp->ctf_link_variable_filter_arg = fp->ctf_link_variable_filter_arg;\n-  nfp->ctf_symsect_little_endian = fp->ctf_symsect_little_endian;\n-  nfp->ctf_link_flags = fp->ctf_link_flags;\n-  nfp->ctf_dedup_atoms = fp->ctf_dedup_atoms;\n-  nfp->ctf_dedup_atoms_alloc = fp->ctf_dedup_atoms_alloc;\n-  memcpy (&nfp->ctf_dedup, &fp->ctf_dedup, sizeof (fp->ctf_dedup));\n-\n-  nfp->ctf_snapshot_lu = fp->ctf_snapshots;\n-\n-  memcpy (&nfp->ctf_lookups, fp->ctf_lookups, sizeof (fp->ctf_lookups));\n-  nfp->ctf_structs = fp->ctf_structs;\n-  nfp->ctf_unions = fp->ctf_unions;\n-  nfp->ctf_enums = fp->ctf_enums;\n-  nfp->ctf_names = fp->ctf_names;\n-\n-  fp->ctf_dthash = NULL;\n-  ctf_str_free_atoms (nfp);\n-  nfp->ctf_str_atoms = fp->ctf_str_atoms;\n-  nfp->ctf_prov_strtab = fp->ctf_prov_strtab;\n-  fp->ctf_str_atoms = NULL;\n-  fp->ctf_prov_strtab = NULL;\n-  memset (&fp->ctf_dtdefs, 0, sizeof (ctf_list_t));\n-  memset (&fp->ctf_errs_warnings, 0, sizeof (ctf_list_t));\n-  fp->ctf_add_processing = NULL;\n-  fp->ctf_ptrtab = NULL;\n-  fp->ctf_pptrtab = NULL;\n-  fp->ctf_funcidx_names = NULL;\n-  fp->ctf_objtidx_names = NULL;\n-  fp->ctf_funcidx_sxlate = NULL;\n-  fp->ctf_objtidx_sxlate = NULL;\n-  fp->ctf_objthash = NULL;\n-  fp->ctf_funchash = NULL;\n-  fp->ctf_dynsyms = NULL;\n-  fp->ctf_dynsymidx = NULL;\n-  fp->ctf_link_inputs = NULL;\n-  fp->ctf_link_outputs = NULL;\n-  fp->ctf_syn_ext_strtab = NULL;\n-  fp->ctf_link_in_cu_mapping = NULL;\n-  fp->ctf_link_out_cu_mapping = NULL;\n-  fp->ctf_link_type_mapping = NULL;\n-  fp->ctf_dedup_atoms = NULL;\n-  fp->ctf_dedup_atoms_alloc = NULL;\n-  fp->ctf_parent_unreffed = 1;\n-\n-  fp->ctf_dvhash = NULL;\n-  memset (&fp->ctf_dvdefs, 0, sizeof (ctf_list_t));\n-  memset (fp->ctf_lookups, 0, sizeof (fp->ctf_lookups));\n-  memset (&fp->ctf_in_flight_dynsyms, 0, sizeof (fp->ctf_in_flight_dynsyms));\n-  memset (&fp->ctf_dedup, 0, sizeof (fp->ctf_dedup));\n-  fp->ctf_structs.ctn_writable = NULL;\n-  fp->ctf_unions.ctn_writable = NULL;\n-  fp->ctf_enums.ctn_writable = NULL;\n-  fp->ctf_names.ctn_writable = NULL;\n-\n-  memcpy (&ofp, fp, sizeof (ctf_dict_t));\n-  memcpy (fp, nfp, sizeof (ctf_dict_t));\n-  memcpy (nfp, &ofp, sizeof (ctf_dict_t));\n-\n-  nfp->ctf_refcnt = 1;\t\t\t\t/* Force nfp to be freed.  */\n-  ctf_dict_close (nfp);\n-\n-  return 0;\n-\n-symerr:\n-  ctf_err_warn (fp, 0, err, _(\"error serializing symtypetabs\"));\n-  goto err;\n-oom:\n-  free (buf);\n-  free (sym_name_order);\n-  return (ctf_set_errno (fp, EAGAIN));\n-err:\n-  free (buf);\n-  free (sym_name_order);\n-  return -1;\t\t\t\t\t/* errno is set for us.  */\n-}\n-\n ctf_names_t *\n ctf_name_table (ctf_dict_t *fp, int kind)\n {\n@@ -3038,195 +1921,3 @@ ctf_add_type (ctf_dict_t *dst_fp, ctf_dict_t *src_fp, ctf_id_t src_type)\n \n   return id;\n }\n-\n-/* Write the compressed CTF data stream to the specified gzFile descriptor.  */\n-int\n-ctf_gzwrite (ctf_dict_t *fp, gzFile fd)\n-{\n-  const unsigned char *buf;\n-  ssize_t resid;\n-  ssize_t len;\n-\n-  resid = sizeof (ctf_header_t);\n-  buf = (unsigned char *) fp->ctf_header;\n-  while (resid != 0)\n-    {\n-      if ((len = gzwrite (fd, buf, resid)) <= 0)\n-\treturn (ctf_set_errno (fp, errno));\n-      resid -= len;\n-      buf += len;\n-    }\n-\n-  resid = fp->ctf_size;\n-  buf = fp->ctf_buf;\n-  while (resid != 0)\n-    {\n-      if ((len = gzwrite (fd, buf, resid)) <= 0)\n-\treturn (ctf_set_errno (fp, errno));\n-      resid -= len;\n-      buf += len;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Compress the specified CTF data stream and write it to the specified file\n-   descriptor.  */\n-int\n-ctf_compress_write (ctf_dict_t *fp, int fd)\n-{\n-  unsigned char *buf;\n-  unsigned char *bp;\n-  ctf_header_t h;\n-  ctf_header_t *hp = &h;\n-  ssize_t header_len = sizeof (ctf_header_t);\n-  ssize_t compress_len;\n-  ssize_t len;\n-  int rc;\n-  int err = 0;\n-\n-  if (ctf_serialize (fp) < 0)\n-    return -1;\t\t\t\t\t/* errno is set for us.  */\n-\n-  memcpy (hp, fp->ctf_header, header_len);\n-  hp->cth_flags |= CTF_F_COMPRESS;\n-  compress_len = compressBound (fp->ctf_size);\n-\n-  if ((buf = malloc (compress_len)) == NULL)\n-    {\n-      ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: cannot allocate %li bytes\"),\n-\t\t    (unsigned long) compress_len);\n-      return (ctf_set_errno (fp, ECTF_ZALLOC));\n-    }\n-\n-  if ((rc = compress (buf, (uLongf *) &compress_len,\n-\t\t      fp->ctf_buf, fp->ctf_size)) != Z_OK)\n-    {\n-      err = ctf_set_errno (fp, ECTF_COMPRESS);\n-      ctf_err_warn (fp, 0, 0, _(\"zlib deflate err: %s\"), zError (rc));\n-      goto ret;\n-    }\n-\n-  while (header_len > 0)\n-    {\n-      if ((len = write (fd, hp, header_len)) < 0)\n-\t{\n-\t  err = ctf_set_errno (fp, errno);\n-\t  ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: error writing header\"));\n-\t  goto ret;\n-\t}\n-      header_len -= len;\n-      hp += len;\n-    }\n-\n-  bp = buf;\n-  while (compress_len > 0)\n-    {\n-      if ((len = write (fd, bp, compress_len)) < 0)\n-\t{\n-\t  err = ctf_set_errno (fp, errno);\n-\t  ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: error writing\"));\n-\t  goto ret;\n-\t}\n-      compress_len -= len;\n-      bp += len;\n-    }\n-\n-ret:\n-  free (buf);\n-  return err;\n-}\n-\n-/* Optionally compress the specified CTF data stream and return it as a new\n-   dynamically-allocated string.  */\n-unsigned char *\n-ctf_write_mem (ctf_dict_t *fp, size_t *size, size_t threshold)\n-{\n-  unsigned char *buf;\n-  unsigned char *bp;\n-  ctf_header_t *hp;\n-  ssize_t header_len = sizeof (ctf_header_t);\n-  ssize_t compress_len;\n-  int rc;\n-\n-  if (ctf_serialize (fp) < 0)\n-    return NULL;\t\t\t\t/* errno is set for us.  */\n-\n-  compress_len = compressBound (fp->ctf_size);\n-  if (fp->ctf_size < threshold)\n-    compress_len = fp->ctf_size;\n-  if ((buf = malloc (compress_len\n-\t\t     + sizeof (struct ctf_header))) == NULL)\n-    {\n-      ctf_set_errno (fp, ENOMEM);\n-      ctf_err_warn (fp, 0, 0, _(\"ctf_write_mem: cannot allocate %li bytes\"),\n-\t\t    (unsigned long) (compress_len + sizeof (struct ctf_header)));\n-      return NULL;\n-    }\n-\n-  hp = (ctf_header_t *) buf;\n-  memcpy (hp, fp->ctf_header, header_len);\n-  bp = buf + sizeof (struct ctf_header);\n-  *size = sizeof (struct ctf_header);\n-\n-  if (fp->ctf_size < threshold)\n-    {\n-      hp->cth_flags &= ~CTF_F_COMPRESS;\n-      memcpy (bp, fp->ctf_buf, fp->ctf_size);\n-      *size += fp->ctf_size;\n-    }\n-  else\n-    {\n-      hp->cth_flags |= CTF_F_COMPRESS;\n-      if ((rc = compress (bp, (uLongf *) &compress_len,\n-\t\t\t  fp->ctf_buf, fp->ctf_size)) != Z_OK)\n-\t{\n-\t  ctf_set_errno (fp, ECTF_COMPRESS);\n-\t  ctf_err_warn (fp, 0, 0, _(\"zlib deflate err: %s\"), zError (rc));\n-\t  free (buf);\n-\t  return NULL;\n-\t}\n-      *size += compress_len;\n-    }\n-  return buf;\n-}\n-\n-/* Write the uncompressed CTF data stream to the specified file descriptor.  */\n-int\n-ctf_write (ctf_dict_t *fp, int fd)\n-{\n-  const unsigned char *buf;\n-  ssize_t resid;\n-  ssize_t len;\n-\n-  if (ctf_serialize (fp) < 0)\n-    return -1;\t\t\t\t\t/* errno is set for us.  */\n-\n-  resid = sizeof (ctf_header_t);\n-  buf = (unsigned char *) fp->ctf_header;\n-  while (resid != 0)\n-    {\n-      if ((len = write (fd, buf, resid)) <= 0)\n-\t{\n-\t  ctf_err_warn (fp, 0, errno, _(\"ctf_write: error writing header\"));\n-\t  return (ctf_set_errno (fp, errno));\n-\t}\n-      resid -= len;\n-      buf += len;\n-    }\n-\n-  resid = fp->ctf_size;\n-  buf = fp->ctf_buf;\n-  while (resid != 0)\n-    {\n-      if ((len = write (fd, buf, resid)) <= 0)\n-\t{\n-\t  ctf_err_warn (fp, 0, errno, _(\"ctf_write: error writing\"));\n-\t  return (ctf_set_errno (fp, errno));\n-\t}\n-      resid -= len;\n-      buf += len;\n-    }\n-\n-  return 0;\n-}"
    },
    {
      "sha": "e0bd98c51a83cda1043c14fb153cb5b987379ad7",
      "filename": "libctf/ctf-serialize.c",
      "status": "added",
      "additions": 1332,
      "deletions": 0,
      "changes": 1332,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf4c3185a5a031824855a93c3476ae276236df12/libctf/ctf-serialize.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf4c3185a5a031824855a93c3476ae276236df12/libctf/ctf-serialize.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-serialize.c?ref=bf4c3185a5a031824855a93c3476ae276236df12",
      "patch": "@@ -0,0 +1,1332 @@\n+/* CTF dict creation.\n+   Copyright (C) 2019-2021 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <assert.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <zlib.h>\n+\n+#include <elf.h>\n+#include \"elf-bfd.h\"\n+\n+/* Delete data symbols that have been assigned names from the variable section.\n+   Must be called from within ctf_serialize, because that is the only place\n+   you can safely delete variables without messing up ctf_rollback.  */\n+\n+static int\n+symtypetab_delete_nonstatic_vars (ctf_dict_t *fp, ctf_dict_t *symfp)\n+{\n+  ctf_dvdef_t *dvd, *nvd;\n+  ctf_id_t type;\n+\n+  for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL; dvd = nvd)\n+    {\n+      nvd = ctf_list_next (dvd);\n+\n+      if (((type = (ctf_id_t) (uintptr_t)\n+\t    ctf_dynhash_lookup (fp->ctf_objthash, dvd->dvd_name)) > 0)\n+\t  && ctf_dynhash_lookup (symfp->ctf_dynsyms, dvd->dvd_name) != NULL\n+\t  && type == dvd->dvd_type)\n+\tctf_dvd_delete (fp, dvd);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Determine if a symbol is \"skippable\" and should never appear in the\n+   symtypetab sections.  */\n+\n+int\n+ctf_symtab_skippable (ctf_link_sym_t *sym)\n+{\n+  /* Never skip symbols whose name is not yet known.  */\n+  if (sym->st_nameidx_set)\n+    return 0;\n+\n+  return (sym->st_name == NULL || sym->st_name[0] == 0\n+\t  || sym->st_shndx == SHN_UNDEF\n+\t  || strcmp (sym->st_name, \"_START_\") == 0\n+\t  || strcmp (sym->st_name, \"_END_\") == 0\n+\t  || (sym->st_type == STT_OBJECT && sym->st_shndx == SHN_EXTABS\n+\t      && sym->st_value == 0));\n+}\n+\n+/* Symtypetab emission flags.  */\n+\n+#define CTF_SYMTYPETAB_EMIT_FUNCTION 0x1\n+#define CTF_SYMTYPETAB_EMIT_PAD 0x2\n+#define CTF_SYMTYPETAB_FORCE_INDEXED 0x4\n+\n+/* Get the number of symbols in a symbol hash, the count of symbols, the maximum\n+   seen, the eventual size, without any padding elements, of the func/data and\n+   (if generated) index sections, and the size of accumulated padding elements.\n+   The linker-reported set of symbols is found in SYMFP: it may be NULL if\n+   symbol filtering is not desired, in which case CTF_SYMTYPETAB_FORCE_INDEXED\n+   will always be set in the flags.\n+\n+   Also figure out if any symbols need to be moved to the variable section, and\n+   add them (if not already present).  */\n+\n+_libctf_nonnull_ ((1,3,4,5,6,7,8))\n+static int\n+symtypetab_density (ctf_dict_t *fp, ctf_dict_t *symfp, ctf_dynhash_t *symhash,\n+\t\t    size_t *count, size_t *max, size_t *unpadsize,\n+\t\t    size_t *padsize, size_t *idxsize, int flags)\n+{\n+  ctf_next_t *i = NULL;\n+  const void *name;\n+  const void *ctf_sym;\n+  ctf_dynhash_t *linker_known = NULL;\n+  int err;\n+  int beyond_max = 0;\n+\n+  *count = 0;\n+  *max = 0;\n+  *unpadsize = 0;\n+  *idxsize = 0;\n+  *padsize = 0;\n+\n+  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+    {\n+      /* Make a dynhash citing only symbols reported by the linker of the\n+\t appropriate type, then traverse all potential-symbols we know the types\n+\t of, removing them from linker_known as we go.  Once this is done, the\n+\t only symbols remaining in linker_known are symbols we don't know the\n+\t types of: we must emit pads for those symbols that are below the\n+\t maximum symbol we will emit (any beyond that are simply skipped).\n+\n+\t If there are none, this symtypetab will be empty: just report that.  */\n+\n+      if (!symfp->ctf_dynsyms)\n+\treturn 0;\n+\n+      if ((linker_known = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t\t\t      NULL, NULL)) == NULL)\n+\treturn (ctf_set_errno (fp, ENOMEM));\n+\n+      while ((err = ctf_dynhash_cnext (symfp->ctf_dynsyms, &i,\n+\t\t\t\t       &name, &ctf_sym)) == 0)\n+\t{\n+\t  ctf_link_sym_t *sym = (ctf_link_sym_t *) ctf_sym;\n+\n+\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t       && sym->st_type != STT_FUNC)\n+\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t\t  && sym->st_type != STT_OBJECT))\n+\t    continue;\n+\n+\t  if (ctf_symtab_skippable (sym))\n+\t    continue;\n+\n+\t  /* This should only be true briefly before all the names are\n+\t     finalized, long before we get this far.  */\n+\t  if (!ctf_assert (fp, !sym->st_nameidx_set))\n+\t    return -1;\t\t\t\t/* errno is set for us.  */\n+\n+\t  if (ctf_dynhash_cinsert (linker_known, name, ctf_sym) < 0)\n+\t    {\n+\t      ctf_dynhash_destroy (linker_known);\n+\t      return (ctf_set_errno (fp, ENOMEM));\n+\t    }\n+\t}\n+      if (err != ECTF_NEXT_END)\n+\t{\n+\t  ctf_err_warn (fp, 0, err, _(\"iterating over linker-known symbols during \"\n+\t\t\t\t  \"serialization\"));\n+\t  ctf_dynhash_destroy (linker_known);\n+\t  return (ctf_set_errno (fp, err));\n+\t}\n+    }\n+\n+  while ((err = ctf_dynhash_cnext (symhash, &i, &name, NULL)) == 0)\n+    {\n+      ctf_link_sym_t *sym;\n+\n+      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+\t{\n+\t  /* Linker did not report symbol in symtab.  Remove it from the\n+\t     set of known data symbols and continue.  */\n+\t  if ((sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, name)) == NULL)\n+\t    {\n+\t      ctf_dynhash_remove (symhash, name);\n+\t      continue;\n+\t    }\n+\n+\t  /* We don't remove skippable symbols from the symhash because we don't\n+\t     want them to be migrated into variables.  */\n+\t  if (ctf_symtab_skippable (sym))\n+\t    continue;\n+\n+\t  if ((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t      && sym->st_type != STT_FUNC)\n+\t    {\n+\t      ctf_err_warn (fp, 1, 0, _(\"symbol %s (%x) added to CTF as a \"\n+\t\t\t\t\t\"function but is of type %x.  \"\n+\t\t\t\t\t\"The symbol type lookup tables \"\n+\t\t\t\t\t\"are probably corrupted\"),\n+\t\t\t    sym->st_name, sym->st_symidx, sym->st_type);\n+\t      ctf_dynhash_remove (symhash, name);\n+\t      continue;\n+\t    }\n+\t  else if (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t\t   && sym->st_type != STT_OBJECT)\n+\t    {\n+\t      ctf_err_warn (fp, 1, 0, _(\"symbol %s (%x) added to CTF as a \"\n+\t\t\t\t\t\"data object but is of type %x.  \"\n+\t\t\t\t\t\"The symbol type lookup tables \"\n+\t\t\t\t\t\"are probably corrupted\"),\n+\t\t\t    sym->st_name, sym->st_symidx, sym->st_type);\n+\t      ctf_dynhash_remove (symhash, name);\n+\t      continue;\n+\t    }\n+\n+\t  ctf_dynhash_remove (linker_known, name);\n+\t}\n+      *unpadsize += sizeof (uint32_t);\n+      (*count)++;\n+\n+      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+\t{\n+\t  if (*max < sym->st_symidx)\n+\t    *max = sym->st_symidx;\n+\t}\n+      else\n+\t(*max)++;\n+    }\n+  if (err != ECTF_NEXT_END)\n+    {\n+      ctf_err_warn (fp, 0, err, _(\"iterating over CTF symtypetab during \"\n+\t\t\t\t  \"serialization\"));\n+      ctf_dynhash_destroy (linker_known);\n+      return (ctf_set_errno (fp, err));\n+    }\n+\n+  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+    {\n+      while ((err = ctf_dynhash_cnext (linker_known, &i, NULL, &ctf_sym)) == 0)\n+\t{\n+\t  ctf_link_sym_t *sym = (ctf_link_sym_t *) ctf_sym;\n+\n+\t  if (sym->st_symidx > *max)\n+\t    beyond_max++;\n+\t}\n+      if (err != ECTF_NEXT_END)\n+\t{\n+\t  ctf_err_warn (fp, 0, err, _(\"iterating over linker-known symbols \"\n+\t\t\t\t      \"during CTF serialization\"));\n+\t  ctf_dynhash_destroy (linker_known);\n+\t  return (ctf_set_errno (fp, err));\n+\t}\n+    }\n+\n+  *idxsize = *count * sizeof (uint32_t);\n+  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+    *padsize = (ctf_dynhash_elements (linker_known) - beyond_max) * sizeof (uint32_t);\n+\n+  ctf_dynhash_destroy (linker_known);\n+  return 0;\n+}\n+\n+/* Emit an objt or func symtypetab into DP in a particular order defined by an\n+   array of ctf_link_sym_t or symbol names passed in.  The index has NIDX\n+   elements in it: unindexed output would terminate at symbol OUTMAX and is in\n+   any case no larger than SIZE bytes.  Some index elements are expected to be\n+   skipped: see symtypetab_density.  The linker-reported set of symbols (if any)\n+   is found in SYMFP. */\n+static int\n+emit_symtypetab (ctf_dict_t *fp, ctf_dict_t *symfp, uint32_t *dp,\n+\t\t ctf_link_sym_t **idx, const char **nameidx, uint32_t nidx,\n+\t\t uint32_t outmax, int size, int flags)\n+{\n+  uint32_t i;\n+  uint32_t *dpp = dp;\n+  ctf_dynhash_t *symhash;\n+\n+  ctf_dprintf (\"Emitting table of size %i, outmax %u, %u symtypetab entries, \"\n+\t       \"flags %i\\n\", size, outmax, nidx, flags);\n+\n+  /* Empty table? Nothing to do.  */\n+  if (size == 0)\n+    return 0;\n+\n+  if (flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+    symhash = fp->ctf_funchash;\n+  else\n+    symhash = fp->ctf_objthash;\n+\n+  for (i = 0; i < nidx; i++)\n+    {\n+      const char *sym_name;\n+      void *type;\n+\n+      /* If we have a linker-reported set of symbols, we may be given that set\n+\t to work from, or a set of symbol names.  In both cases we want to look\n+\t at the corresponding linker-reported symbol (if any).  */\n+      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+\t{\n+\t  ctf_link_sym_t *this_link_sym;\n+\n+\t  if (idx)\n+\t    this_link_sym = idx[i];\n+\t  else\n+\t    this_link_sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, nameidx[i]);\n+\n+\t  /* Unreported symbol number.  No pad, no nothing.  */\n+\t  if (!this_link_sym)\n+\t    continue;\n+\n+\t  /* Symbol of the wrong type, or skippable?  This symbol is not in this\n+\t     table.  */\n+\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t       && this_link_sym->st_type != STT_FUNC)\n+\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t\t  && this_link_sym->st_type != STT_OBJECT))\n+\t    continue;\n+\n+\t  if (ctf_symtab_skippable (this_link_sym))\n+\t    continue;\n+\n+\t  sym_name = this_link_sym->st_name;\n+\n+\t  /* Linker reports symbol of a different type to the symbol we actually\n+\t     added?  Skip the symbol.  No pad, since the symbol doesn't actually\n+\t     belong in this table at all.  (Warned about in\n+\t     symtypetab_density.)  */\n+\t  if ((this_link_sym->st_type == STT_FUNC)\n+\t      && (ctf_dynhash_lookup (fp->ctf_objthash, sym_name)))\n+\t    continue;\n+\n+\t  if ((this_link_sym->st_type == STT_OBJECT)\n+\t      && (ctf_dynhash_lookup (fp->ctf_funchash, sym_name)))\n+\t    continue;\n+\t}\n+      else\n+\tsym_name = nameidx[i];\n+\n+      /* Symbol in index but no type set? Silently skip and (optionally)\n+\t pad.  (In force-indexed mode, this is also where we track symbols of\n+\t the wrong type for this round of insertion.)  */\n+      if ((type = ctf_dynhash_lookup (symhash, sym_name)) == NULL)\n+\t{\n+\t  if (flags & CTF_SYMTYPETAB_EMIT_PAD)\n+\t    *dpp++ = 0;\n+\t  continue;\n+\t}\n+\n+      if (!ctf_assert (fp, (((char *) dpp) - (char *) dp) < size))\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+\n+      *dpp++ = (ctf_id_t) (uintptr_t) type;\n+\n+      /* When emitting unindexed output, all later symbols are pads: stop\n+\t early.  */\n+      if ((flags & CTF_SYMTYPETAB_EMIT_PAD) && idx[i]->st_symidx == outmax)\n+\tbreak;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Emit an objt or func symtypetab index into DP in a paticular order defined by\n+   an array of symbol names passed in.  Stop at NIDX.  The linker-reported set\n+   of symbols (if any) is found in SYMFP. */\n+static int\n+emit_symtypetab_index (ctf_dict_t *fp, ctf_dict_t *symfp, uint32_t *dp,\n+\t\t       const char **idx, uint32_t nidx, int size, int flags)\n+{\n+  uint32_t i;\n+  uint32_t *dpp = dp;\n+  ctf_dynhash_t *symhash;\n+\n+  ctf_dprintf (\"Emitting index of size %i, %u entries reported by linker, \"\n+\t       \"flags %i\\n\", size, nidx, flags);\n+\n+  /* Empty table? Nothing to do.  */\n+  if (size == 0)\n+    return 0;\n+\n+  if (flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+    symhash = fp->ctf_funchash;\n+  else\n+    symhash = fp->ctf_objthash;\n+\n+  /* Indexes should always be unpadded.  */\n+  if (!ctf_assert (fp, !(flags & CTF_SYMTYPETAB_EMIT_PAD)))\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  for (i = 0; i < nidx; i++)\n+    {\n+      const char *sym_name;\n+      void *type;\n+\n+      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+\t{\n+\t  ctf_link_sym_t *this_link_sym;\n+\n+\t  this_link_sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, idx[i]);\n+\n+\t  /* This is an index: unreported symbols should never appear in it.  */\n+\t  if (!ctf_assert (fp, this_link_sym != NULL))\n+\t    return -1;\t\t\t\t/* errno is set for us.  */\n+\n+\t  /* Symbol of the wrong type, or skippable?  This symbol is not in this\n+\t     table.  */\n+\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t       && this_link_sym->st_type != STT_FUNC)\n+\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t\t  && this_link_sym->st_type != STT_OBJECT))\n+\t    continue;\n+\n+\t  if (ctf_symtab_skippable (this_link_sym))\n+\t    continue;\n+\n+\t  sym_name = this_link_sym->st_name;\n+\n+\t  /* Linker reports symbol of a different type to the symbol we actually\n+\t     added?  Skip the symbol.  */\n+\t  if ((this_link_sym->st_type == STT_FUNC)\n+\t      && (ctf_dynhash_lookup (fp->ctf_objthash, sym_name)))\n+\t    continue;\n+\n+\t  if ((this_link_sym->st_type == STT_OBJECT)\n+\t      && (ctf_dynhash_lookup (fp->ctf_funchash, sym_name)))\n+\t    continue;\n+\t}\n+      else\n+\tsym_name = idx[i];\n+\n+      /* Symbol in index and reported by linker, but no type set? Silently skip\n+\t and (optionally) pad.  (In force-indexed mode, this is also where we\n+\t track symbols of the wrong type for this round of insertion.)  */\n+      if ((type = ctf_dynhash_lookup (symhash, sym_name)) == NULL)\n+\tcontinue;\n+\n+      ctf_str_add_ref (fp, sym_name, dpp++);\n+\n+      if (!ctf_assert (fp, (((char *) dpp) - (char *) dp) <= size))\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+    }\n+\n+  return 0;\n+}\n+\n+static unsigned char *\n+ctf_copy_smembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_member_t ctm;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      ctf_member_t *copied;\n+\n+      ctm.ctm_name = 0;\n+      ctm.ctm_type = (uint32_t) dmd->dmd_type;\n+      ctm.ctm_offset = (uint32_t) dmd->dmd_offset;\n+\n+      memcpy (t, &ctm, sizeof (ctm));\n+      copied = (ctf_member_t *) t;\n+      if (dmd->dmd_name)\n+\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctm_name);\n+\n+      t += sizeof (ctm);\n+    }\n+\n+  return t;\n+}\n+\n+static unsigned char *\n+ctf_copy_lmembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_lmember_t ctlm;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      ctf_lmember_t *copied;\n+\n+      ctlm.ctlm_name = 0;\n+      ctlm.ctlm_type = (uint32_t) dmd->dmd_type;\n+      ctlm.ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (dmd->dmd_offset);\n+      ctlm.ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (dmd->dmd_offset);\n+\n+      memcpy (t, &ctlm, sizeof (ctlm));\n+      copied = (ctf_lmember_t *) t;\n+      if (dmd->dmd_name)\n+\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctlm_name);\n+\n+      t += sizeof (ctlm);\n+    }\n+\n+  return t;\n+}\n+\n+static unsigned char *\n+ctf_copy_emembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_enum_t cte;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      ctf_enum_t *copied;\n+\n+      cte.cte_value = dmd->dmd_value;\n+      memcpy (t, &cte, sizeof (cte));\n+      copied = (ctf_enum_t *) t;\n+      ctf_str_add_ref (fp, dmd->dmd_name, &copied->cte_name);\n+      t += sizeof (cte);\n+    }\n+\n+  return t;\n+}\n+\n+/* Sort a newly-constructed static variable array.  */\n+\n+typedef struct ctf_sort_var_arg_cb\n+{\n+  ctf_dict_t *fp;\n+  ctf_strs_t *strtab;\n+} ctf_sort_var_arg_cb_t;\n+\n+static int\n+ctf_sort_var (const void *one_, const void *two_, void *arg_)\n+{\n+  const ctf_varent_t *one = one_;\n+  const ctf_varent_t *two = two_;\n+  ctf_sort_var_arg_cb_t *arg = arg_;\n+\n+  return (strcmp (ctf_strraw_explicit (arg->fp, one->ctv_name, arg->strtab),\n+\t\t  ctf_strraw_explicit (arg->fp, two->ctv_name, arg->strtab)));\n+}\n+\n+/* If the specified CTF dict is writable and has been modified, reload this dict\n+   with the updated type definitions, ready for serialization.  In order to make\n+   this code and the rest of libctf as simple as possible, we perform updates by\n+   taking the dynamic type definitions and creating an in-memory CTF dict\n+   containing the definitions, and then call ctf_simple_open_internal() on it.\n+   We perform one extra trick here for the benefit of callers and to keep our\n+   code simple: ctf_simple_open_internal() will return a new ctf_dict_t, but we\n+   want to keep the fp constant for the caller, so after\n+   ctf_simple_open_internal() returns, we use memcpy to swap the interior of the\n+   old and new ctf_dict_t's, and then free the old.  */\n+int\n+ctf_serialize (ctf_dict_t *fp)\n+{\n+  ctf_dict_t ofp, *nfp;\n+  ctf_header_t hdr, *hdrp;\n+  ctf_dtdef_t *dtd;\n+  ctf_dvdef_t *dvd;\n+  ctf_varent_t *dvarents;\n+  ctf_strs_writable_t strtab;\n+\n+  unsigned char *t;\n+  unsigned long i;\n+  size_t buf_size, type_size, objt_size, func_size;\n+  size_t objt_unpadsize, func_unpadsize, objt_padsize, func_padsize;\n+  size_t funcidx_size, objtidx_size;\n+  size_t nvars, nfuncs, nobjts, maxobjt, maxfunc;\n+  size_t nsymtypes = 0;\n+  const char **sym_name_order = NULL;\n+  unsigned char *buf = NULL, *newbuf;\n+  int err;\n+\n+  /* Symtab filtering. If filter_syms is true, symfp is set: otherwise,\n+     CTF_SYMTYPETAB_FORCE_INDEXED is set in symflags.  */\n+  int filter_syms = 0;\n+  int sort_syms = 1;\n+  int symflags = 0;\n+  ctf_dict_t *symfp = NULL;\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  /* Update required?  */\n+  if (!(fp->ctf_flags & LCTF_DIRTY))\n+    return 0;\n+\n+  /* If doing a writeout as part of linking, and the link flags request it,\n+     filter out reported symbols from the variable section, and filter out all\n+     other symbols from the symtypetab sections.  (If we are not linking, the\n+     symbols are sorted; if we are linking, don't bother sorting if we are not\n+     filtering out reported symbols: this is almost certaily an ld -r and only\n+     the linker is likely to consume these symtypetabs again.  The linker\n+     doesn't care what order the symtypetab entries is in, since it only\n+     iterates over symbols and does not use the ctf_lookup_by_symbol* API.)  */\n+\n+  if (fp->ctf_flags & LCTF_LINKING)\n+    {\n+      filter_syms = !(fp->ctf_link_flags & CTF_LINK_NO_FILTER_REPORTED_SYMS);\n+      if (!filter_syms)\n+\tsort_syms = 0;\n+    }\n+\n+  /* Fill in an initial CTF header.  We will leave the label, object,\n+     and function sections empty and only output a header, type section,\n+     and string table.  The type section begins at a 4-byte aligned\n+     boundary past the CTF header itself (at relative offset zero).  The flag\n+     indicating a new-style function info section (an array of CTF_K_FUNCTION\n+     type IDs in the types section) is flipped on.  */\n+\n+  memset (&hdr, 0, sizeof (hdr));\n+  hdr.cth_magic = CTF_MAGIC;\n+  hdr.cth_version = CTF_VERSION;\n+\n+  /* This is a new-format func info section, and the symtab and strtab come out\n+     of the dynsym and dynstr these days.  */\n+  hdr.cth_flags = (CTF_F_NEWFUNCINFO | CTF_F_DYNSTR);\n+\n+  /* Iterate through the dynamic type definition list and compute the\n+     size of the CTF type section we will need to generate.  */\n+\n+  for (type_size = 0, dtd = ctf_list_next (&fp->ctf_dtdefs);\n+       dtd != NULL; dtd = ctf_list_next (dtd))\n+    {\n+      uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+      uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n+\n+      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n+\ttype_size += sizeof (ctf_stype_t);\n+      else\n+\ttype_size += sizeof (ctf_type_t);\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_INTEGER:\n+\tcase CTF_K_FLOAT:\n+\t  type_size += sizeof (uint32_t);\n+\t  break;\n+\tcase CTF_K_ARRAY:\n+\t  type_size += sizeof (ctf_array_t);\n+\t  break;\n+\tcase CTF_K_SLICE:\n+\t  type_size += sizeof (ctf_slice_t);\n+\t  break;\n+\tcase CTF_K_FUNCTION:\n+\t  type_size += sizeof (uint32_t) * (vlen + (vlen & 1));\n+\t  break;\n+\tcase CTF_K_STRUCT:\n+\tcase CTF_K_UNION:\n+\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n+\t    type_size += sizeof (ctf_member_t) * vlen;\n+\t  else\n+\t    type_size += sizeof (ctf_lmember_t) * vlen;\n+\t  break;\n+\tcase CTF_K_ENUM:\n+\t  type_size += sizeof (ctf_enum_t) * vlen;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Find the dict to which the linker has reported symbols, if any.  */\n+\n+  if (filter_syms)\n+    {\n+      if (!fp->ctf_dynsyms && fp->ctf_parent && fp->ctf_parent->ctf_dynsyms)\n+\tsymfp = fp->ctf_parent;\n+      else\n+\tsymfp = fp;\n+    }\n+\n+  /* If not filtering, keep all potential symbols in an unsorted, indexed\n+     dict.  */\n+  if (!filter_syms)\n+    symflags = CTF_SYMTYPETAB_FORCE_INDEXED;\n+  else\n+    hdr.cth_flags |= CTF_F_IDXSORTED;\n+\n+  if (!ctf_assert (fp, (filter_syms && symfp)\n+\t\t   || (!filter_syms && !symfp\n+\t\t       && ((symflags & CTF_SYMTYPETAB_FORCE_INDEXED) != 0))))\n+    return -1;\n+\n+  /* Work out the sizes of the object and function sections, and work out the\n+     number of pad (unassigned) symbols in each, and the overall size of the\n+     sections.  */\n+\n+  if (symtypetab_density (fp, symfp, fp->ctf_objthash, &nobjts, &maxobjt,\n+\t\t\t  &objt_unpadsize, &objt_padsize, &objtidx_size,\n+\t\t\t  symflags) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  ctf_dprintf (\"Object symtypetab: %i objects, max %i, unpadded size %i, \"\n+\t       \"%i bytes of pads, index size %i\\n\", (int) nobjts, (int) maxobjt,\n+\t       (int) objt_unpadsize, (int) objt_padsize, (int) objtidx_size);\n+\n+  if (symtypetab_density (fp, symfp, fp->ctf_funchash, &nfuncs, &maxfunc,\n+\t\t\t  &func_unpadsize, &func_padsize, &funcidx_size,\n+\t\t\t  symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  ctf_dprintf (\"Function symtypetab: %i functions, max %i, unpadded size %i, \"\n+\t       \"%i bytes of pads, index size %i\\n\", (int) nfuncs, (int) maxfunc,\n+\t       (int) func_unpadsize, (int) func_padsize, (int) funcidx_size);\n+\n+  /* If we are filtering symbols out, those symbols that the linker has not\n+     reported have now been removed from the ctf_objthash and ctf_funchash.\n+     Delete entries from the variable section that duplicate newly-added data\n+     symbols.  There's no need to migrate new ones in, because the compiler\n+     always emits both a variable and a data symbol simultaneously, and\n+     filtering only happens at final link time.  */\n+\n+  if (filter_syms && symfp->ctf_dynsyms &&\n+      symtypetab_delete_nonstatic_vars (fp, symfp) < 0)\n+    return -1;\n+\n+  /* It is worth indexing each section if it would save space to do so, due to\n+     reducing the number of pads sufficiently.  A pad is the same size as a\n+     single index entry: but index sections compress relatively poorly compared\n+     to constant pads, so it takes a lot of contiguous padding to equal one\n+     index section entry.  It would be nice to be able to *verify* whether we\n+     would save space after compression rather than guessing, but this seems\n+     difficult, since it would require complete reserialization.  Regardless, if\n+     the linker has not reported any symbols (e.g. if this is not a final link\n+     but just an ld -r), we must emit things in indexed fashion just as the\n+     compiler does.  */\n+\n+  objt_size = objt_unpadsize;\n+  if (!(symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n+      && ((objt_padsize + objt_unpadsize) * CTF_INDEX_PAD_THRESHOLD\n+\t  > objt_padsize))\n+    {\n+      objt_size += objt_padsize;\n+      objtidx_size = 0;\n+    }\n+\n+  func_size = func_unpadsize;\n+  if (!(symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n+      && ((func_padsize + func_unpadsize) * CTF_INDEX_PAD_THRESHOLD\n+\t  > func_padsize))\n+    {\n+      func_size += func_padsize;\n+      funcidx_size = 0;\n+    }\n+\n+  /* Computing the number of entries in the CTF variable section is much\n+     simpler.  */\n+\n+  for (nvars = 0, dvd = ctf_list_next (&fp->ctf_dvdefs);\n+       dvd != NULL; dvd = ctf_list_next (dvd), nvars++);\n+\n+  /* Compute the size of the CTF buffer we need, sans only the string table,\n+     then allocate a new buffer and memcpy the finished header to the start of\n+     the buffer.  (We will adjust this later with strtab length info.)  */\n+\n+  hdr.cth_lbloff = hdr.cth_objtoff = 0;\n+  hdr.cth_funcoff = hdr.cth_objtoff + objt_size;\n+  hdr.cth_objtidxoff = hdr.cth_funcoff + func_size;\n+  hdr.cth_funcidxoff = hdr.cth_objtidxoff + objtidx_size;\n+  hdr.cth_varoff = hdr.cth_funcidxoff + funcidx_size;\n+  hdr.cth_typeoff = hdr.cth_varoff + (nvars * sizeof (ctf_varent_t));\n+  hdr.cth_stroff = hdr.cth_typeoff + type_size;\n+  hdr.cth_strlen = 0;\n+\n+  buf_size = sizeof (ctf_header_t) + hdr.cth_stroff + hdr.cth_strlen;\n+\n+  if ((buf = malloc (buf_size)) == NULL)\n+    return (ctf_set_errno (fp, EAGAIN));\n+\n+  memcpy (buf, &hdr, sizeof (ctf_header_t));\n+  t = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_objtoff;\n+\n+  hdrp = (ctf_header_t *) buf;\n+  if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parname != NULL))\n+    ctf_str_add_ref (fp, fp->ctf_parname, &hdrp->cth_parname);\n+  if (fp->ctf_cuname != NULL)\n+    ctf_str_add_ref (fp, fp->ctf_cuname, &hdrp->cth_cuname);\n+\n+  /* Sort the linker's symbols into name order if need be.  */\n+\n+  if ((objtidx_size != 0) || (funcidx_size != 0))\n+    {\n+      ctf_next_t *i = NULL;\n+      void *symname;\n+      const char **walk;\n+\n+      if (filter_syms)\n+\t{\n+\t  if (symfp->ctf_dynsyms)\n+\t    nsymtypes = ctf_dynhash_elements (symfp->ctf_dynsyms);\n+\t  else\n+\t    nsymtypes = 0;\n+\t}\n+      else\n+\tnsymtypes = ctf_dynhash_elements (fp->ctf_objthash)\n+\t  + ctf_dynhash_elements (fp->ctf_funchash);\n+\n+      if ((sym_name_order = calloc (nsymtypes, sizeof (const char *))) == NULL)\n+\tgoto oom;\n+\n+      walk = sym_name_order;\n+\n+      if (filter_syms)\n+\t{\n+\t  if (symfp->ctf_dynsyms)\n+\t    {\n+\t      while ((err = ctf_dynhash_next_sorted (symfp->ctf_dynsyms, &i,\n+\t\t\t\t\t\t     &symname, NULL,\n+\t\t\t\t\t\t     ctf_dynhash_sort_by_name,\n+\t\t\t\t\t\t     NULL)) == 0)\n+\t\t*walk++ = (const char *) symname;\n+\t      if (err != ECTF_NEXT_END)\n+\t\tgoto symerr;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  ctf_hash_sort_f sort_fun = NULL;\n+\n+\t  /* Since we partition the set of symbols back into objt and func,\n+\t     we can sort the two independently without harm.  */\n+\t  if (sort_syms)\n+\t    sort_fun = ctf_dynhash_sort_by_name;\n+\n+\t  while ((err = ctf_dynhash_next_sorted (fp->ctf_objthash, &i, &symname,\n+\t\t\t\t\t\t NULL, sort_fun, NULL)) == 0)\n+\t    *walk++ = (const char *) symname;\n+\t  if (err != ECTF_NEXT_END)\n+\t    goto symerr;\n+\n+\t  while ((err = ctf_dynhash_next_sorted (fp->ctf_funchash, &i, &symname,\n+\t\t\t\t\t\t NULL, sort_fun, NULL)) == 0)\n+\t    *walk++ = (const char *) symname;\n+\t  if (err != ECTF_NEXT_END)\n+\t    goto symerr;\n+\t}\n+    }\n+\n+  /* Emit the object and function sections, and if necessary their indexes.\n+     Emission is done in symtab order if there is no index, and in index\n+     (name) order otherwise.  */\n+\n+  if ((objtidx_size == 0) && symfp && symfp->ctf_dynsymidx)\n+    {\n+      ctf_dprintf (\"Emitting unindexed objt symtypetab\\n\");\n+      if (emit_symtypetab (fp, symfp, (uint32_t *) t, symfp->ctf_dynsymidx,\n+\t\t\t   NULL, symfp->ctf_dynsymmax + 1, maxobjt, objt_size,\n+\t\t\t   symflags | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n+\tgoto err;\t\t\t\t/* errno is set for us.  */\n+    }\n+  else\n+    {\n+      ctf_dprintf (\"Emitting indexed objt symtypetab\\n\");\n+      if (emit_symtypetab (fp, symfp, (uint32_t *) t, NULL, sym_name_order,\n+\t\t\t   nsymtypes, maxobjt, objt_size, symflags) < 0)\n+\tgoto err;\t\t\t\t/* errno is set for us.  */\n+    }\n+\n+  t += objt_size;\n+\n+  if ((funcidx_size == 0) && symfp && symfp->ctf_dynsymidx)\n+    {\n+      ctf_dprintf (\"Emitting unindexed func symtypetab\\n\");\n+      if (emit_symtypetab (fp, symfp, (uint32_t *) t, symfp->ctf_dynsymidx,\n+\t\t\t   NULL, symfp->ctf_dynsymmax + 1, maxfunc,\n+\t\t\t   func_size, symflags | CTF_SYMTYPETAB_EMIT_FUNCTION\n+\t\t\t   | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n+\tgoto err;\t\t\t\t/* errno is set for us.  */\n+    }\n+  else\n+    {\n+      ctf_dprintf (\"Emitting indexed func symtypetab\\n\");\n+      if (emit_symtypetab (fp, symfp, (uint32_t *) t, NULL, sym_name_order,\n+\t\t\t   nsymtypes, maxfunc, func_size,\n+\t\t\t   symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+\tgoto err;\t\t\t\t/* errno is set for us.  */\n+    }\n+\n+  t += func_size;\n+\n+  if (objtidx_size > 0)\n+    if (emit_symtypetab_index (fp, symfp, (uint32_t *) t, sym_name_order,\n+\t\t\t       nsymtypes, objtidx_size, symflags) < 0)\n+      goto err;\n+\n+  t += objtidx_size;\n+\n+  if (funcidx_size > 0)\n+    if (emit_symtypetab_index (fp, symfp, (uint32_t *) t, sym_name_order,\n+\t\t\t       nsymtypes, funcidx_size,\n+\t\t\t       symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+      goto err;\n+\n+  t += funcidx_size;\n+  free (sym_name_order);\n+  sym_name_order = NULL;\n+\n+  /* Work over the variable list, translating everything into ctf_varent_t's and\n+     prepping the string table.  */\n+\n+  dvarents = (ctf_varent_t *) t;\n+  for (i = 0, dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL;\n+       dvd = ctf_list_next (dvd), i++)\n+    {\n+      ctf_varent_t *var = &dvarents[i];\n+\n+      ctf_str_add_ref (fp, dvd->dvd_name, &var->ctv_name);\n+      var->ctv_type = (uint32_t) dvd->dvd_type;\n+    }\n+  assert (i == nvars);\n+\n+  t += sizeof (ctf_varent_t) * nvars;\n+\n+  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_typeoff);\n+\n+  /* We now take a final lap through the dynamic type definition list and copy\n+     the appropriate type records to the output buffer, noting down the\n+     strings as we go.  */\n+\n+  for (dtd = ctf_list_next (&fp->ctf_dtdefs);\n+       dtd != NULL; dtd = ctf_list_next (dtd))\n+    {\n+      uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+      uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n+\n+      ctf_array_t cta;\n+      uint32_t encoding;\n+      size_t len;\n+      ctf_stype_t *copied;\n+      const char *name;\n+\n+      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n+\tlen = sizeof (ctf_stype_t);\n+      else\n+\tlen = sizeof (ctf_type_t);\n+\n+      memcpy (t, &dtd->dtd_data, len);\n+      copied = (ctf_stype_t *) t;  /* name is at the start: constant offset.  */\n+      if (copied->ctt_name\n+\t  && (name = ctf_strraw (fp, copied->ctt_name)) != NULL)\n+\tctf_str_add_ref (fp, name, &copied->ctt_name);\n+      t += len;\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_INTEGER:\n+\tcase CTF_K_FLOAT:\n+\t  if (kind == CTF_K_INTEGER)\n+\t    {\n+\t      encoding = CTF_INT_DATA (dtd->dtd_u.dtu_enc.cte_format,\n+\t\t\t\t       dtd->dtd_u.dtu_enc.cte_offset,\n+\t\t\t\t       dtd->dtd_u.dtu_enc.cte_bits);\n+\t    }\n+\t  else\n+\t    {\n+\t      encoding = CTF_FP_DATA (dtd->dtd_u.dtu_enc.cte_format,\n+\t\t\t\t      dtd->dtd_u.dtu_enc.cte_offset,\n+\t\t\t\t      dtd->dtd_u.dtu_enc.cte_bits);\n+\t    }\n+\t  memcpy (t, &encoding, sizeof (encoding));\n+\t  t += sizeof (encoding);\n+\t  break;\n+\n+\tcase CTF_K_SLICE:\n+\t  memcpy (t, &dtd->dtd_u.dtu_slice, sizeof (struct ctf_slice));\n+\t  t += sizeof (struct ctf_slice);\n+\t  break;\n+\n+\tcase CTF_K_ARRAY:\n+\t  cta.cta_contents = (uint32_t) dtd->dtd_u.dtu_arr.ctr_contents;\n+\t  cta.cta_index = (uint32_t) dtd->dtd_u.dtu_arr.ctr_index;\n+\t  cta.cta_nelems = dtd->dtd_u.dtu_arr.ctr_nelems;\n+\t  memcpy (t, &cta, sizeof (cta));\n+\t  t += sizeof (cta);\n+\t  break;\n+\n+\tcase CTF_K_FUNCTION:\n+\t  {\n+\t    uint32_t *argv = (uint32_t *) (uintptr_t) t;\n+\t    uint32_t argc;\n+\n+\t    for (argc = 0; argc < vlen; argc++)\n+\t      *argv++ = dtd->dtd_u.dtu_argv[argc];\n+\n+\t    if (vlen & 1)\n+\t      *argv++ = 0;\t/* Pad to 4-byte boundary.  */\n+\n+\t    t = (unsigned char *) argv;\n+\t    break;\n+\t  }\n+\n+\tcase CTF_K_STRUCT:\n+\tcase CTF_K_UNION:\n+\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n+\t    t = ctf_copy_smembers (fp, dtd, t);\n+\t  else\n+\t    t = ctf_copy_lmembers (fp, dtd, t);\n+\t  break;\n+\n+\tcase CTF_K_ENUM:\n+\t  t = ctf_copy_emembers (fp, dtd, t);\n+\t  break;\n+\t}\n+    }\n+  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_stroff);\n+\n+  /* Construct the final string table and fill out all the string refs with the\n+     final offsets.  Then purge the refs list, because we're about to move this\n+     strtab onto the end of the buf, invalidating all the offsets.  */\n+  strtab = ctf_str_write_strtab (fp);\n+  ctf_str_purge_refs (fp);\n+\n+  if (strtab.cts_strs == NULL)\n+    goto oom;\n+\n+  /* Now the string table is constructed, we can sort the buffer of\n+     ctf_varent_t's.  */\n+  ctf_sort_var_arg_cb_t sort_var_arg = { fp, (ctf_strs_t *) &strtab };\n+  ctf_qsort_r (dvarents, nvars, sizeof (ctf_varent_t), ctf_sort_var,\n+\t       &sort_var_arg);\n+\n+  if ((newbuf = ctf_realloc (fp, buf, buf_size + strtab.cts_len)) == NULL)\n+    {\n+      free (strtab.cts_strs);\n+      goto oom;\n+    }\n+  buf = newbuf;\n+  memcpy (buf + buf_size, strtab.cts_strs, strtab.cts_len);\n+  hdrp = (ctf_header_t *) buf;\n+  hdrp->cth_strlen = strtab.cts_len;\n+  buf_size += hdrp->cth_strlen;\n+  free (strtab.cts_strs);\n+\n+  /* Finally, we are ready to ctf_simple_open() the new dict.  If this is\n+     successful, we then switch nfp and fp and free the old dict.  */\n+\n+  if ((nfp = ctf_simple_open_internal ((char *) buf, buf_size, NULL, 0,\n+\t\t\t\t       0, NULL, 0, fp->ctf_syn_ext_strtab,\n+\t\t\t\t       1, &err)) == NULL)\n+    {\n+      free (buf);\n+      return (ctf_set_errno (fp, err));\n+    }\n+\n+  (void) ctf_setmodel (nfp, ctf_getmodel (fp));\n+\n+  nfp->ctf_parent = fp->ctf_parent;\n+  nfp->ctf_parent_unreffed = fp->ctf_parent_unreffed;\n+  nfp->ctf_refcnt = fp->ctf_refcnt;\n+  nfp->ctf_flags |= fp->ctf_flags & ~LCTF_DIRTY;\n+  if (nfp->ctf_dynbase == NULL)\n+    nfp->ctf_dynbase = buf;\t\t/* Make sure buf is freed on close.  */\n+  nfp->ctf_dthash = fp->ctf_dthash;\n+  nfp->ctf_dtdefs = fp->ctf_dtdefs;\n+  nfp->ctf_dvhash = fp->ctf_dvhash;\n+  nfp->ctf_dvdefs = fp->ctf_dvdefs;\n+  nfp->ctf_dtoldid = fp->ctf_dtoldid;\n+  nfp->ctf_add_processing = fp->ctf_add_processing;\n+  nfp->ctf_snapshots = fp->ctf_snapshots + 1;\n+  nfp->ctf_specific = fp->ctf_specific;\n+  nfp->ctf_nfuncidx = fp->ctf_nfuncidx;\n+  nfp->ctf_nobjtidx = fp->ctf_nobjtidx;\n+  nfp->ctf_objthash = fp->ctf_objthash;\n+  nfp->ctf_funchash = fp->ctf_funchash;\n+  nfp->ctf_dynsyms = fp->ctf_dynsyms;\n+  nfp->ctf_ptrtab = fp->ctf_ptrtab;\n+  nfp->ctf_pptrtab = fp->ctf_pptrtab;\n+  nfp->ctf_dynsymidx = fp->ctf_dynsymidx;\n+  nfp->ctf_dynsymmax = fp->ctf_dynsymmax;\n+  nfp->ctf_ptrtab_len = fp->ctf_ptrtab_len;\n+  nfp->ctf_pptrtab_len = fp->ctf_pptrtab_len;\n+  nfp->ctf_link_inputs = fp->ctf_link_inputs;\n+  nfp->ctf_link_outputs = fp->ctf_link_outputs;\n+  nfp->ctf_errs_warnings = fp->ctf_errs_warnings;\n+  nfp->ctf_funcidx_names = fp->ctf_funcidx_names;\n+  nfp->ctf_objtidx_names = fp->ctf_objtidx_names;\n+  nfp->ctf_funcidx_sxlate = fp->ctf_funcidx_sxlate;\n+  nfp->ctf_objtidx_sxlate = fp->ctf_objtidx_sxlate;\n+  nfp->ctf_str_prov_offset = fp->ctf_str_prov_offset;\n+  nfp->ctf_syn_ext_strtab = fp->ctf_syn_ext_strtab;\n+  nfp->ctf_pptrtab_typemax = fp->ctf_pptrtab_typemax;\n+  nfp->ctf_in_flight_dynsyms = fp->ctf_in_flight_dynsyms;\n+  nfp->ctf_link_in_cu_mapping = fp->ctf_link_in_cu_mapping;\n+  nfp->ctf_link_out_cu_mapping = fp->ctf_link_out_cu_mapping;\n+  nfp->ctf_link_type_mapping = fp->ctf_link_type_mapping;\n+  nfp->ctf_link_memb_name_changer = fp->ctf_link_memb_name_changer;\n+  nfp->ctf_link_memb_name_changer_arg = fp->ctf_link_memb_name_changer_arg;\n+  nfp->ctf_link_variable_filter = fp->ctf_link_variable_filter;\n+  nfp->ctf_link_variable_filter_arg = fp->ctf_link_variable_filter_arg;\n+  nfp->ctf_symsect_little_endian = fp->ctf_symsect_little_endian;\n+  nfp->ctf_link_flags = fp->ctf_link_flags;\n+  nfp->ctf_dedup_atoms = fp->ctf_dedup_atoms;\n+  nfp->ctf_dedup_atoms_alloc = fp->ctf_dedup_atoms_alloc;\n+  memcpy (&nfp->ctf_dedup, &fp->ctf_dedup, sizeof (fp->ctf_dedup));\n+\n+  nfp->ctf_snapshot_lu = fp->ctf_snapshots;\n+\n+  memcpy (&nfp->ctf_lookups, fp->ctf_lookups, sizeof (fp->ctf_lookups));\n+  nfp->ctf_structs = fp->ctf_structs;\n+  nfp->ctf_unions = fp->ctf_unions;\n+  nfp->ctf_enums = fp->ctf_enums;\n+  nfp->ctf_names = fp->ctf_names;\n+\n+  fp->ctf_dthash = NULL;\n+  ctf_str_free_atoms (nfp);\n+  nfp->ctf_str_atoms = fp->ctf_str_atoms;\n+  nfp->ctf_prov_strtab = fp->ctf_prov_strtab;\n+  fp->ctf_str_atoms = NULL;\n+  fp->ctf_prov_strtab = NULL;\n+  memset (&fp->ctf_dtdefs, 0, sizeof (ctf_list_t));\n+  memset (&fp->ctf_errs_warnings, 0, sizeof (ctf_list_t));\n+  fp->ctf_add_processing = NULL;\n+  fp->ctf_ptrtab = NULL;\n+  fp->ctf_pptrtab = NULL;\n+  fp->ctf_funcidx_names = NULL;\n+  fp->ctf_objtidx_names = NULL;\n+  fp->ctf_funcidx_sxlate = NULL;\n+  fp->ctf_objtidx_sxlate = NULL;\n+  fp->ctf_objthash = NULL;\n+  fp->ctf_funchash = NULL;\n+  fp->ctf_dynsyms = NULL;\n+  fp->ctf_dynsymidx = NULL;\n+  fp->ctf_link_inputs = NULL;\n+  fp->ctf_link_outputs = NULL;\n+  fp->ctf_syn_ext_strtab = NULL;\n+  fp->ctf_link_in_cu_mapping = NULL;\n+  fp->ctf_link_out_cu_mapping = NULL;\n+  fp->ctf_link_type_mapping = NULL;\n+  fp->ctf_dedup_atoms = NULL;\n+  fp->ctf_dedup_atoms_alloc = NULL;\n+  fp->ctf_parent_unreffed = 1;\n+\n+  fp->ctf_dvhash = NULL;\n+  memset (&fp->ctf_dvdefs, 0, sizeof (ctf_list_t));\n+  memset (fp->ctf_lookups, 0, sizeof (fp->ctf_lookups));\n+  memset (&fp->ctf_in_flight_dynsyms, 0, sizeof (fp->ctf_in_flight_dynsyms));\n+  memset (&fp->ctf_dedup, 0, sizeof (fp->ctf_dedup));\n+  fp->ctf_structs.ctn_writable = NULL;\n+  fp->ctf_unions.ctn_writable = NULL;\n+  fp->ctf_enums.ctn_writable = NULL;\n+  fp->ctf_names.ctn_writable = NULL;\n+\n+  memcpy (&ofp, fp, sizeof (ctf_dict_t));\n+  memcpy (fp, nfp, sizeof (ctf_dict_t));\n+  memcpy (nfp, &ofp, sizeof (ctf_dict_t));\n+\n+  nfp->ctf_refcnt = 1;\t\t\t\t/* Force nfp to be freed.  */\n+  ctf_dict_close (nfp);\n+\n+  return 0;\n+\n+symerr:\n+  ctf_err_warn (fp, 0, err, _(\"error serializing symtypetabs\"));\n+  goto err;\n+oom:\n+  free (buf);\n+  free (sym_name_order);\n+  return (ctf_set_errno (fp, EAGAIN));\n+err:\n+  free (buf);\n+  free (sym_name_order);\n+  return -1;\t\t\t\t\t/* errno is set for us.  */\n+}\n+\n+\n+/* Write the compressed CTF data stream to the specified gzFile descriptor.  */\n+int\n+ctf_gzwrite (ctf_dict_t *fp, gzFile fd)\n+{\n+  const unsigned char *buf;\n+  ssize_t resid;\n+  ssize_t len;\n+\n+  resid = sizeof (ctf_header_t);\n+  buf = (unsigned char *) fp->ctf_header;\n+  while (resid != 0)\n+    {\n+      if ((len = gzwrite (fd, buf, resid)) <= 0)\n+\treturn (ctf_set_errno (fp, errno));\n+      resid -= len;\n+      buf += len;\n+    }\n+\n+  resid = fp->ctf_size;\n+  buf = fp->ctf_buf;\n+  while (resid != 0)\n+    {\n+      if ((len = gzwrite (fd, buf, resid)) <= 0)\n+\treturn (ctf_set_errno (fp, errno));\n+      resid -= len;\n+      buf += len;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Compress the specified CTF data stream and write it to the specified file\n+   descriptor.  */\n+int\n+ctf_compress_write (ctf_dict_t *fp, int fd)\n+{\n+  unsigned char *buf;\n+  unsigned char *bp;\n+  ctf_header_t h;\n+  ctf_header_t *hp = &h;\n+  ssize_t header_len = sizeof (ctf_header_t);\n+  ssize_t compress_len;\n+  ssize_t len;\n+  int rc;\n+  int err = 0;\n+\n+  if (ctf_serialize (fp) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  memcpy (hp, fp->ctf_header, header_len);\n+  hp->cth_flags |= CTF_F_COMPRESS;\n+  compress_len = compressBound (fp->ctf_size);\n+\n+  if ((buf = malloc (compress_len)) == NULL)\n+    {\n+      ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: cannot allocate %li bytes\"),\n+\t\t    (unsigned long) compress_len);\n+      return (ctf_set_errno (fp, ECTF_ZALLOC));\n+    }\n+\n+  if ((rc = compress (buf, (uLongf *) &compress_len,\n+\t\t      fp->ctf_buf, fp->ctf_size)) != Z_OK)\n+    {\n+      err = ctf_set_errno (fp, ECTF_COMPRESS);\n+      ctf_err_warn (fp, 0, 0, _(\"zlib deflate err: %s\"), zError (rc));\n+      goto ret;\n+    }\n+\n+  while (header_len > 0)\n+    {\n+      if ((len = write (fd, hp, header_len)) < 0)\n+\t{\n+\t  err = ctf_set_errno (fp, errno);\n+\t  ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: error writing header\"));\n+\t  goto ret;\n+\t}\n+      header_len -= len;\n+      hp += len;\n+    }\n+\n+  bp = buf;\n+  while (compress_len > 0)\n+    {\n+      if ((len = write (fd, bp, compress_len)) < 0)\n+\t{\n+\t  err = ctf_set_errno (fp, errno);\n+\t  ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: error writing\"));\n+\t  goto ret;\n+\t}\n+      compress_len -= len;\n+      bp += len;\n+    }\n+\n+ret:\n+  free (buf);\n+  return err;\n+}\n+\n+/* Optionally compress the specified CTF data stream and return it as a new\n+   dynamically-allocated string.  */\n+unsigned char *\n+ctf_write_mem (ctf_dict_t *fp, size_t *size, size_t threshold)\n+{\n+  unsigned char *buf;\n+  unsigned char *bp;\n+  ctf_header_t *hp;\n+  ssize_t header_len = sizeof (ctf_header_t);\n+  ssize_t compress_len;\n+  int rc;\n+\n+  if (ctf_serialize (fp) < 0)\n+    return NULL;\t\t\t\t/* errno is set for us.  */\n+\n+  compress_len = compressBound (fp->ctf_size);\n+  if (fp->ctf_size < threshold)\n+    compress_len = fp->ctf_size;\n+  if ((buf = malloc (compress_len\n+\t\t     + sizeof (struct ctf_header))) == NULL)\n+    {\n+      ctf_set_errno (fp, ENOMEM);\n+      ctf_err_warn (fp, 0, 0, _(\"ctf_write_mem: cannot allocate %li bytes\"),\n+\t\t    (unsigned long) (compress_len + sizeof (struct ctf_header)));\n+      return NULL;\n+    }\n+\n+  hp = (ctf_header_t *) buf;\n+  memcpy (hp, fp->ctf_header, header_len);\n+  bp = buf + sizeof (struct ctf_header);\n+  *size = sizeof (struct ctf_header);\n+\n+  if (fp->ctf_size < threshold)\n+    {\n+      hp->cth_flags &= ~CTF_F_COMPRESS;\n+      memcpy (bp, fp->ctf_buf, fp->ctf_size);\n+      *size += fp->ctf_size;\n+    }\n+  else\n+    {\n+      hp->cth_flags |= CTF_F_COMPRESS;\n+      if ((rc = compress (bp, (uLongf *) &compress_len,\n+\t\t\t  fp->ctf_buf, fp->ctf_size)) != Z_OK)\n+\t{\n+\t  ctf_set_errno (fp, ECTF_COMPRESS);\n+\t  ctf_err_warn (fp, 0, 0, _(\"zlib deflate err: %s\"), zError (rc));\n+\t  free (buf);\n+\t  return NULL;\n+\t}\n+      *size += compress_len;\n+    }\n+  return buf;\n+}\n+\n+/* Write the uncompressed CTF data stream to the specified file descriptor.  */\n+int\n+ctf_write (ctf_dict_t *fp, int fd)\n+{\n+  const unsigned char *buf;\n+  ssize_t resid;\n+  ssize_t len;\n+\n+  if (ctf_serialize (fp) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  resid = sizeof (ctf_header_t);\n+  buf = (unsigned char *) fp->ctf_header;\n+  while (resid != 0)\n+    {\n+      if ((len = write (fd, buf, resid)) <= 0)\n+\t{\n+\t  ctf_err_warn (fp, 0, errno, _(\"ctf_write: error writing header\"));\n+\t  return (ctf_set_errno (fp, errno));\n+\t}\n+      resid -= len;\n+      buf += len;\n+    }\n+\n+  resid = fp->ctf_size;\n+  buf = fp->ctf_buf;\n+  while (resid != 0)\n+    {\n+      if ((len = write (fd, buf, resid)) <= 0)\n+\t{\n+\t  ctf_err_warn (fp, 0, errno, _(\"ctf_write: error writing\"));\n+\t  return (ctf_set_errno (fp, errno));\n+\t}\n+      resid -= len;\n+      buf += len;\n+    }\n+\n+  return 0;\n+}"
    }
  ]
}