{
  "sha": "8fdd972c3002e45458edc1b32ac880c137762cf7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGZkZDk3MmMzMDAyZTQ1NDU4ZWRjMWIzMmFjODgwYzEzNzc2MmNmNw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:43:24Z"
    },
    "message": "Move DWARF line_header to new file\n\nThis moves the line_header class to a pair of new files, making\ndwarf2/read.c somewhat smaller.\n\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.h (dwarf_line_debug): Declare.\n\t* Makefile.in (COMMON_SFILES): Add dwarf2/line-header.c.\n\t* dwarf2/read.c: Move line_header code to new files.\n\t(dwarf_line_debug): No longer static.\n\t* dwarf2/line-header.c: New file.\n\t* dwarf2/line-header.h: New file.\n\nChange-Id: I8d9d8a2398b4e888e20cc5dd68d041c28b5a06e3",
    "tree": {
      "sha": "96214417a372da188233ac1f83833be0e88255d3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/96214417a372da188233ac1f83833be0e88255d3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8fdd972c3002e45458edc1b32ac880c137762cf7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8fdd972c3002e45458edc1b32ac880c137762cf7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8fdd972c3002e45458edc1b32ac880c137762cf7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8fdd972c3002e45458edc1b32ac880c137762cf7/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "03075812752042ebea6ac3108829b46e272d3ad9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/03075812752042ebea6ac3108829b46e272d3ad9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/03075812752042ebea6ac3108829b46e272d3ad9"
    }
  ],
  "stats": {
    "total": 570,
    "additions": 317,
    "deletions": 253
  },
  "files": [
    {
      "sha": "81e97461be86cee57e39ce95b0522dbabc8eb55f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8fdd972c3002e45458edc1b32ac880c137762cf7",
      "patch": "@@ -1,3 +1,12 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.h (dwarf_line_debug): Declare.\n+\t* Makefile.in (COMMON_SFILES): Add dwarf2/line-header.c.\n+\t* dwarf2/read.c: Move line_header code to new files.\n+\t(dwarf_line_debug): No longer static.\n+\t* dwarf2/line-header.c: New file.\n+\t* dwarf2/line-header.h: New file.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (struct line_header) <file_full_name,"
    },
    {
      "sha": "b4bd9d4b9929fb7ed0290f8328192b3b61b29900",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=8fdd972c3002e45458edc1b32ac880c137762cf7",
      "patch": "@@ -1003,6 +1003,7 @@ COMMON_SFILES = \\\n \tdwarf2/index-common.c \\\n \tdwarf2/index-write.c \\\n \tdwarf2/leb.c \\\n+\tdwarf2/line-header.c \\\n \tdwarf2/loc.c \\\n \tdwarf2/read.c \\\n \tdwarf2/section.c \\"
    },
    {
      "sha": "56dfb5c2dd2ef71401bfe3dbe25e6ef3f0866fe8",
      "filename": "gdb/dwarf2/line-header.c",
      "status": "added",
      "additions": 114,
      "deletions": 0,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/dwarf2/line-header.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/dwarf2/line-header.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/line-header.c?ref=8fdd972c3002e45458edc1b32ac880c137762cf7",
      "patch": "@@ -0,0 +1,114 @@\n+/* DWARF 2 debugging format support for GDB.\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"dwarf2/line-header.h\"\n+#include \"dwarf2/read.h\"\n+#include \"complaints.h\"\n+#include \"filenames.h\"\n+\n+void\n+line_header::add_include_dir (const char *include_dir)\n+{\n+  if (dwarf_line_debug >= 2)\n+    {\n+      size_t new_size;\n+      if (version >= 5)\n+        new_size = m_include_dirs.size ();\n+      else\n+        new_size = m_include_dirs.size () + 1;\n+      fprintf_unfiltered (gdb_stdlog, \"Adding dir %zu: %s\\n\",\n+\t\t\t  new_size, include_dir);\n+    }\n+  m_include_dirs.push_back (include_dir);\n+}\n+\n+void\n+line_header::add_file_name (const char *name,\n+\t\t\t    dir_index d_index,\n+\t\t\t    unsigned int mod_time,\n+\t\t\t    unsigned int length)\n+{\n+  if (dwarf_line_debug >= 2)\n+    {\n+      size_t new_size;\n+      if (version >= 5)\n+        new_size = file_names_size ();\n+      else\n+        new_size = file_names_size () + 1;\n+      fprintf_unfiltered (gdb_stdlog, \"Adding file %zu: %s\\n\",\n+\t\t\t  new_size, name);\n+    }\n+  m_file_names.emplace_back (name, d_index, mod_time, length);\n+}\n+\n+gdb::unique_xmalloc_ptr<char>\n+line_header::file_file_name (int file)\n+{\n+  /* Is the file number a valid index into the line header's file name\n+     table?  Remember that file numbers start with one, not zero.  */\n+  if (is_valid_file_index (file))\n+    {\n+      const file_entry *fe = file_name_at (file);\n+\n+      if (!IS_ABSOLUTE_PATH (fe->name))\n+\t{\n+\t  const char *dir = fe->include_dir (this);\n+\t  if (dir != NULL)\n+\t    return gdb::unique_xmalloc_ptr<char> (concat (dir, SLASH_STRING,\n+\t\t\t\t\t\t\t  fe->name,\n+\t\t\t\t\t\t\t  (char *) NULL));\n+\t}\n+      return make_unique_xstrdup (fe->name);\n+    }\n+  else\n+    {\n+      /* The compiler produced a bogus file number.  We can at least\n+         record the macro definitions made in the file, even if we\n+         won't be able to find the file by name.  */\n+      char fake_name[80];\n+\n+      xsnprintf (fake_name, sizeof (fake_name),\n+\t\t \"<bad macro file number %d>\", file);\n+\n+      complaint (_(\"bad file number in macro information (%d)\"),\n+                 file);\n+\n+      return make_unique_xstrdup (fake_name);\n+    }\n+}\n+\n+gdb::unique_xmalloc_ptr<char>\n+line_header::file_full_name (int file, const char *comp_dir)\n+{\n+  /* Is the file number a valid index into the line header's file name\n+     table?  Remember that file numbers start with one, not zero.  */\n+  if (is_valid_file_index (file))\n+    {\n+      gdb::unique_xmalloc_ptr<char> relative = file_file_name (file);\n+\n+      if (IS_ABSOLUTE_PATH (relative.get ()) || comp_dir == NULL)\n+\treturn relative;\n+      return gdb::unique_xmalloc_ptr<char> (concat (comp_dir, SLASH_STRING,\n+\t\t\t\t\t\t    relative.get (),\n+\t\t\t\t\t\t    (char *) NULL));\n+    }\n+  else\n+    return file_file_name (file);\n+}"
    },
    {
      "sha": "08cf7b0810f44570f03e81d000f2eb47c4add8ac",
      "filename": "gdb/dwarf2/line-header.h",
      "status": "added",
      "additions": 188,
      "deletions": 0,
      "changes": 188,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/dwarf2/line-header.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/dwarf2/line-header.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/line-header.h?ref=8fdd972c3002e45458edc1b32ac880c137762cf7",
      "patch": "@@ -0,0 +1,188 @@\n+/* DWARF 2 debugging format support for GDB.\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef DWARF2_LINE_HEADER_H\n+#define DWARF2_LINE_HEADER_H\n+\n+#include \"gdbtypes.h\"\n+\n+/* dir_index is 1-based in DWARF 4 and before, and is 0-based in DWARF 5 and\n+   later.  */\n+typedef int dir_index;\n+\n+/* file_name_index is 1-based in DWARF 4 and before, and is 0-based in DWARF 5\n+   and later.  */\n+typedef int file_name_index;\n+\n+struct line_header;\n+\n+struct file_entry\n+{\n+  file_entry () = default;\n+\n+  file_entry (const char *name_, dir_index d_index_,\n+\t      unsigned int mod_time_, unsigned int length_)\n+    : name (name_),\n+      d_index (d_index_),\n+      mod_time (mod_time_),\n+      length (length_)\n+  {}\n+\n+  /* Return the include directory at D_INDEX stored in LH.  Returns\n+     NULL if D_INDEX is out of bounds.  */\n+  const char *include_dir (const line_header *lh) const;\n+\n+  /* The file name.  Note this is an observing pointer.  The memory is\n+     owned by debug_line_buffer.  */\n+  const char *name {};\n+\n+  /* The directory index (1-based).  */\n+  dir_index d_index {};\n+\n+  unsigned int mod_time {};\n+\n+  unsigned int length {};\n+\n+  /* True if referenced by the Line Number Program.  */\n+  bool included_p {};\n+\n+  /* The associated symbol table, if any.  */\n+  struct symtab *symtab {};\n+};\n+\n+/* The line number information for a compilation unit (found in the\n+   .debug_line section) begins with a \"statement program header\",\n+   which contains the following information.  */\n+struct line_header\n+{\n+  line_header ()\n+    : offset_in_dwz {}\n+  {}\n+\n+  /* Add an entry to the include directory table.  */\n+  void add_include_dir (const char *include_dir);\n+\n+  /* Add an entry to the file name table.  */\n+  void add_file_name (const char *name, dir_index d_index,\n+\t\t      unsigned int mod_time, unsigned int length);\n+\n+  /* Return the include dir at INDEX (0-based in DWARF 5 and 1-based before).\n+     Returns NULL if INDEX is out of bounds.  */\n+  const char *include_dir_at (dir_index index) const\n+  {\n+    int vec_index;\n+    if (version >= 5)\n+      vec_index = index;\n+    else\n+      vec_index = index - 1;\n+    if (vec_index < 0 || vec_index >= m_include_dirs.size ())\n+      return NULL;\n+    return m_include_dirs[vec_index];\n+  }\n+\n+  bool is_valid_file_index (int file_index)\n+  {\n+    if (version >= 5)\n+      return 0 <= file_index && file_index < file_names_size ();\n+    return 1 <= file_index && file_index <= file_names_size ();\n+  }\n+\n+  /* Return the file name at INDEX (0-based in DWARF 5 and 1-based before).\n+     Returns NULL if INDEX is out of bounds.  */\n+  file_entry *file_name_at (file_name_index index)\n+  {\n+    int vec_index;\n+    if (version >= 5)\n+      vec_index = index;\n+    else\n+      vec_index = index - 1;\n+    if (vec_index < 0 || vec_index >= m_file_names.size ())\n+      return NULL;\n+    return &m_file_names[vec_index];\n+  }\n+\n+  /* The indexes are 0-based in DWARF 5 and 1-based in DWARF 4. Therefore,\n+     this method should only be used to iterate through all file entries in an\n+     index-agnostic manner.  */\n+  std::vector<file_entry> &file_names ()\n+  { return m_file_names; }\n+\n+  /* Offset of line number information in .debug_line section.  */\n+  sect_offset sect_off {};\n+\n+  /* OFFSET is for struct dwz_file associated with dwarf2_per_objfile.  */\n+  unsigned offset_in_dwz : 1; /* Can't initialize bitfields in-class.  */\n+\n+  unsigned int total_length {};\n+  unsigned short version {};\n+  unsigned int header_length {};\n+  unsigned char minimum_instruction_length {};\n+  unsigned char maximum_ops_per_instruction {};\n+  unsigned char default_is_stmt {};\n+  int line_base {};\n+  unsigned char line_range {};\n+  unsigned char opcode_base {};\n+\n+  /* standard_opcode_lengths[i] is the number of operands for the\n+     standard opcode whose value is i.  This means that\n+     standard_opcode_lengths[0] is unused, and the last meaningful\n+     element is standard_opcode_lengths[opcode_base - 1].  */\n+  std::unique_ptr<unsigned char[]> standard_opcode_lengths;\n+\n+  int file_names_size ()\n+  { return m_file_names.size(); }\n+\n+  /* The start and end of the statement program following this\n+     header.  These point into dwarf2_per_objfile->line_buffer.  */\n+  const gdb_byte *statement_program_start {}, *statement_program_end {};\n+\n+  /* Return the full name of file number I in this object's file name\n+     table.  Use COMP_DIR as the name of the current directory of the\n+     compilation.  The result is allocated using xmalloc; the caller\n+     is responsible for freeing it.  */\n+  gdb::unique_xmalloc_ptr<char> file_full_name (int file,\n+\t\t\t\t\t\tconst char *comp_dir);\n+\n+  /* Return file name relative to the compilation directory of file\n+     number I in this object's file name table.  The result is\n+     allocated using xmalloc; the caller is responsible for freeing\n+     it.  */\n+  gdb::unique_xmalloc_ptr<char> file_file_name (int file);\n+\n+ private:\n+  /* The include_directories table.  Note these are observing\n+     pointers.  The memory is owned by debug_line_buffer.  */\n+  std::vector<const char *> m_include_dirs;\n+\n+  /* The file_names table. This is private because the meaning of indexes\n+     differs among DWARF versions (The first valid index is 1 in DWARF 4 and\n+     before, and is 0 in DWARF 5 and later).  So the client should use\n+     file_name_at method for access.  */\n+  std::vector<file_entry> m_file_names;\n+};\n+\n+typedef std::unique_ptr<line_header> line_header_up;\n+\n+inline const char *\n+file_entry::include_dir (const line_header *lh) const\n+{\n+  return lh->include_dir_at (d_index);\n+}\n+\n+#endif /* DWARF2_LINE_HEADER_H */"
    },
    {
      "sha": "9501a9eff59eaeab9652a69601ae5512462b6af4",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 2,
      "deletions": 253,
      "changes": 255,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=8fdd972c3002e45458edc1b32ac880c137762cf7",
      "patch": "@@ -35,6 +35,7 @@\n #include \"dwarf2/index-cache.h\"\n #include \"dwarf2/index-common.h\"\n #include \"dwarf2/leb.h\"\n+#include \"dwarf2/line-header.h\"\n #include \"bfd.h\"\n #include \"elf-bfd.h\"\n #include \"symtab.h\"\n@@ -90,7 +91,7 @@ static unsigned int dwarf_read_debug = 0;\n static unsigned int dwarf_die_debug = 0;\n \n /* When non-zero, dump line number entries as they are read in.  */\n-static unsigned int dwarf_line_debug = 0;\n+unsigned int dwarf_line_debug = 0;\n \n /* When true, cross-check physname against demangler.  */\n static bool check_physname = false;\n@@ -946,167 +947,6 @@ class cutu_reader : public die_reader_specs\n   abbrev_table_up m_dwo_abbrev_table;\n };\n \n-/* dir_index is 1-based in DWARF 4 and before, and is 0-based in DWARF 5 and\n-   later.  */\n-typedef int dir_index;\n-\n-/* file_name_index is 1-based in DWARF 4 and before, and is 0-based in DWARF 5\n-   and later.  */\n-typedef int file_name_index;\n-\n-struct file_entry\n-{\n-  file_entry () = default;\n-\n-  file_entry (const char *name_, dir_index d_index_,\n-\t      unsigned int mod_time_, unsigned int length_)\n-    : name (name_),\n-      d_index (d_index_),\n-      mod_time (mod_time_),\n-      length (length_)\n-  {}\n-\n-  /* Return the include directory at D_INDEX stored in LH.  Returns\n-     NULL if D_INDEX is out of bounds.  */\n-  const char *include_dir (const line_header *lh) const;\n-\n-  /* The file name.  Note this is an observing pointer.  The memory is\n-     owned by debug_line_buffer.  */\n-  const char *name {};\n-\n-  /* The directory index (1-based).  */\n-  dir_index d_index {};\n-\n-  unsigned int mod_time {};\n-\n-  unsigned int length {};\n-\n-  /* True if referenced by the Line Number Program.  */\n-  bool included_p {};\n-\n-  /* The associated symbol table, if any.  */\n-  struct symtab *symtab {};\n-};\n-\n-/* The line number information for a compilation unit (found in the\n-   .debug_line section) begins with a \"statement program header\",\n-   which contains the following information.  */\n-struct line_header\n-{\n-  line_header ()\n-    : offset_in_dwz {}\n-  {}\n-\n-  /* Add an entry to the include directory table.  */\n-  void add_include_dir (const char *include_dir);\n-\n-  /* Add an entry to the file name table.  */\n-  void add_file_name (const char *name, dir_index d_index,\n-\t\t      unsigned int mod_time, unsigned int length);\n-\n-  /* Return the include dir at INDEX (0-based in DWARF 5 and 1-based before).\n-     Returns NULL if INDEX is out of bounds.  */\n-  const char *include_dir_at (dir_index index) const\n-  {\n-    int vec_index;\n-    if (version >= 5)\n-      vec_index = index;\n-    else\n-      vec_index = index - 1;\n-    if (vec_index < 0 || vec_index >= m_include_dirs.size ())\n-      return NULL;\n-    return m_include_dirs[vec_index];\n-  }\n-\n-  bool is_valid_file_index (int file_index)\n-  {\n-    if (version >= 5)\n-      return 0 <= file_index && file_index < file_names_size ();\n-    return 1 <= file_index && file_index <= file_names_size ();\n-  }\n-\n-  /* Return the file name at INDEX (0-based in DWARF 5 and 1-based before).\n-     Returns NULL if INDEX is out of bounds.  */\n-  file_entry *file_name_at (file_name_index index)\n-  {\n-    int vec_index;\n-    if (version >= 5)\n-      vec_index = index;\n-    else\n-      vec_index = index - 1;\n-    if (vec_index < 0 || vec_index >= m_file_names.size ())\n-      return NULL;\n-    return &m_file_names[vec_index];\n-  }\n-\n-  /* The indexes are 0-based in DWARF 5 and 1-based in DWARF 4. Therefore,\n-     this method should only be used to iterate through all file entries in an\n-     index-agnostic manner.  */\n-  std::vector<file_entry> &file_names ()\n-  { return m_file_names; }\n-\n-  /* Offset of line number information in .debug_line section.  */\n-  sect_offset sect_off {};\n-\n-  /* OFFSET is for struct dwz_file associated with dwarf2_per_objfile.  */\n-  unsigned offset_in_dwz : 1; /* Can't initialize bitfields in-class.  */\n-\n-  unsigned int total_length {};\n-  unsigned short version {};\n-  unsigned int header_length {};\n-  unsigned char minimum_instruction_length {};\n-  unsigned char maximum_ops_per_instruction {};\n-  unsigned char default_is_stmt {};\n-  int line_base {};\n-  unsigned char line_range {};\n-  unsigned char opcode_base {};\n-\n-  /* standard_opcode_lengths[i] is the number of operands for the\n-     standard opcode whose value is i.  This means that\n-     standard_opcode_lengths[0] is unused, and the last meaningful\n-     element is standard_opcode_lengths[opcode_base - 1].  */\n-  std::unique_ptr<unsigned char[]> standard_opcode_lengths;\n-\n-  int file_names_size ()\n-  { return m_file_names.size(); }\n-\n-  /* The start and end of the statement program following this\n-     header.  These point into dwarf2_per_objfile->line_buffer.  */\n-  const gdb_byte *statement_program_start {}, *statement_program_end {};\n-\n-  /* Return the full name of file number I in this object's file name\n-     table.  Use COMP_DIR as the name of the current directory of the\n-     compilation.  The result is allocated using xmalloc; the caller\n-     is responsible for freeing it.  */\n-  gdb::unique_xmalloc_ptr<char> file_full_name (int file,\n-\t\t\t\t\t\tconst char *comp_dir);\n-\n-  /* Return file name relative to the compilation directory of file\n-     number I in this object's file name table.  The result is\n-     allocated using xmalloc; the caller is responsible for freeing\n-     it.  */\n-  gdb::unique_xmalloc_ptr<char> file_file_name (int file);\n-\n- private:\n-  /* The include_directories table.  Note these are observing\n-     pointers.  The memory is owned by debug_line_buffer.  */\n-  std::vector<const char *> m_include_dirs;\n-\n-  /* The file_names table. This is private because the meaning of indexes\n-     differs among DWARF versions (The first valid index is 1 in DWARF 4 and\n-     before, and is 0 in DWARF 5 and later).  So the client should use\n-     file_name_at method for access.  */\n-  std::vector<file_entry> m_file_names;\n-};\n-\n-typedef std::unique_ptr<line_header> line_header_up;\n-\n-const char *\n-file_entry::include_dir (const line_header *lh) const\n-{\n-  return lh->include_dir_at (d_index);\n-}\n-\n /* When we construct a partial symbol table entry we only\n    need this much information.  */\n struct partial_die_info : public allocate_on_obstack\n@@ -19850,41 +19690,6 @@ free_line_header_voidp (void *arg)\n   delete lh;\n }\n \n-void\n-line_header::add_include_dir (const char *include_dir)\n-{\n-  if (dwarf_line_debug >= 2)\n-    {\n-      size_t new_size;\n-      if (version >= 5)\n-        new_size = m_include_dirs.size ();\n-      else\n-        new_size = m_include_dirs.size () + 1;\n-      fprintf_unfiltered (gdb_stdlog, \"Adding dir %zu: %s\\n\",\n-\t\t\t  new_size, include_dir);\n-    }\n-  m_include_dirs.push_back (include_dir);\n-}\n-\n-void\n-line_header::add_file_name (const char *name,\n-\t\t\t    dir_index d_index,\n-\t\t\t    unsigned int mod_time,\n-\t\t\t    unsigned int length)\n-{\n-  if (dwarf_line_debug >= 2)\n-    {\n-      size_t new_size;\n-      if (version >= 5)\n-        new_size = file_names_size ();\n-      else\n-        new_size = file_names_size () + 1;\n-      fprintf_unfiltered (gdb_stdlog, \"Adding file %zu: %s\\n\",\n-\t\t\t  new_size, name);\n-    }\n-  m_file_names.emplace_back (name, d_index, mod_time, length);\n-}\n-\n /* A convenience function to find the proper .debug_line section for a CU.  */\n \n static struct dwarf2_section_info *\n@@ -23756,62 +23561,6 @@ dwarf_alloc_die (struct dwarf2_cu *cu, int num_attrs)\n \f\n /* Macro support.  */\n \n-gdb::unique_xmalloc_ptr<char>\n-line_header::file_file_name (int file)\n-{\n-  /* Is the file number a valid index into the line header's file name\n-     table?  Remember that file numbers start with one, not zero.  */\n-  if (is_valid_file_index (file))\n-    {\n-      const file_entry *fe = file_name_at (file);\n-\n-      if (!IS_ABSOLUTE_PATH (fe->name))\n-\t{\n-\t  const char *dir = fe->include_dir (this);\n-\t  if (dir != NULL)\n-\t    return gdb::unique_xmalloc_ptr<char> (concat (dir, SLASH_STRING,\n-\t\t\t\t\t\t\t  fe->name,\n-\t\t\t\t\t\t\t  (char *) NULL));\n-\t}\n-      return make_unique_xstrdup (fe->name);\n-    }\n-  else\n-    {\n-      /* The compiler produced a bogus file number.  We can at least\n-         record the macro definitions made in the file, even if we\n-         won't be able to find the file by name.  */\n-      char fake_name[80];\n-\n-      xsnprintf (fake_name, sizeof (fake_name),\n-\t\t \"<bad macro file number %d>\", file);\n-\n-      complaint (_(\"bad file number in macro information (%d)\"),\n-                 file);\n-\n-      return make_unique_xstrdup (fake_name);\n-    }\n-}\n-\n-gdb::unique_xmalloc_ptr<char>\n-line_header::file_full_name (int file, const char *comp_dir)\n-{\n-  /* Is the file number a valid index into the line header's file name\n-     table?  Remember that file numbers start with one, not zero.  */\n-  if (is_valid_file_index (file))\n-    {\n-      gdb::unique_xmalloc_ptr<char> relative = file_file_name (file);\n-\n-      if (IS_ABSOLUTE_PATH (relative.get ()) || comp_dir == NULL)\n-\treturn relative;\n-      return gdb::unique_xmalloc_ptr<char> (concat (comp_dir, SLASH_STRING,\n-\t\t\t\t\t\t    relative.get (),\n-\t\t\t\t\t\t    (char *) NULL));\n-    }\n-  else\n-    return file_file_name (file);\n-}\n-\n-\n static struct macro_source_file *\n macro_start_file (struct dwarf2_cu *cu,\n \t\t  int file, int line,"
    },
    {
      "sha": "2dc657f5c361f387c8240524697aa81e61595e49",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8fdd972c3002e45458edc1b32ac880c137762cf7/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=8fdd972c3002e45458edc1b32ac880c137762cf7",
      "patch": "@@ -473,4 +473,7 @@ struct dwz_file\n extern struct dwz_file *dwarf2_get_dwz_file\n     (struct dwarf2_per_objfile *dwarf2_per_objfile);\n \n+/* When non-zero, dump line number entries as they are read in.  */\n+extern unsigned int dwarf_line_debug;\n+\n #endif /* DWARF2READ_H */"
    }
  ]
}