{
  "sha": "b3885679dd71bed069e7e6fc2ae8b9eb05f90d62",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjM4ODU2NzlkZDcxYmVkMDY5ZTdlNmZjMmFlOGI5ZWIwNWY5MGQ2Mg==",
  "commit": {
    "author": {
      "name": "Eli Zaretskii",
      "email": "eliz@gnu.org",
      "date": "2021-04-10T08:33:08Z"
    },
    "committer": {
      "name": "Eli Zaretskii",
      "email": "eliz@gnu.org",
      "date": "2021-04-10T08:42:54Z"
    },
    "message": "Fix handling DLL loads at run time\n\nThis patch makes handling a DLL load at run time (using LoadLibrary)\nmuch more reliable when its file name cannot be obtained using the\nlpImageName pointer provided by the DLL load debug event.  The\nsolution is to enumerate all the DLLs loaded by the inferior, looking\nfor the DLL that's loaded at base address provided by the lpBaseOfDll\npointer of the debug event.  Correctly resolving the DLL file name is\nimportant, because without that GDB doesn't record the DLL in the list\nof solibs, and then later is unable to show functions in that DLL in\nthe backtraces, which produces corrupted and truncated backtraces.\nSee this thread for the problems that causes:\n\n  https://sourceware.org/pipermail/gdb-patches/2021-March/177022.html\n\ngdb/ChangeLog:\n\n2021-04-10  Eli Zaretskii  <eliz@gnu.org>\n\n\t* windows-nat.c (windows_nat::handle_load_dll): Call\n\twindows_add_dll if get_image_name failed to glean the name of the\n\tDLL by using the lpImageName pointer.\n\t(windows_add_all_dlls): Now a thin wrapper around windows_add_dll.\n\t(windows_add_dll): Now does what windows_add_all_dlls did before,\n\tbut also accepts an argument LOAD_ADDR, which, if non-NULL,\n\tspecifies the address where the DLL was loaded into the inferior,\n\tand looks for the single DLL loaded at that address.",
    "tree": {
      "sha": "e60abdb20d8719e937151f481882d2bcacacc978",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e60abdb20d8719e937151f481882d2bcacacc978"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b3885679dd71bed069e7e6fc2ae8b9eb05f90d62",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3885679dd71bed069e7e6fc2ae8b9eb05f90d62",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b3885679dd71bed069e7e6fc2ae8b9eb05f90d62",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3885679dd71bed069e7e6fc2ae8b9eb05f90d62/comments",
  "author": {
    "login": "Eli-Zaretskii",
    "id": 20908835,
    "node_id": "MDQ6VXNlcjIwOTA4ODM1",
    "avatar_url": "https://avatars.githubusercontent.com/u/20908835?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Eli-Zaretskii",
    "html_url": "https://github.com/Eli-Zaretskii",
    "followers_url": "https://api.github.com/users/Eli-Zaretskii/followers",
    "following_url": "https://api.github.com/users/Eli-Zaretskii/following{/other_user}",
    "gists_url": "https://api.github.com/users/Eli-Zaretskii/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Eli-Zaretskii/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Eli-Zaretskii/subscriptions",
    "organizations_url": "https://api.github.com/users/Eli-Zaretskii/orgs",
    "repos_url": "https://api.github.com/users/Eli-Zaretskii/repos",
    "events_url": "https://api.github.com/users/Eli-Zaretskii/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Eli-Zaretskii/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "Eli-Zaretskii",
    "id": 20908835,
    "node_id": "MDQ6VXNlcjIwOTA4ODM1",
    "avatar_url": "https://avatars.githubusercontent.com/u/20908835?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Eli-Zaretskii",
    "html_url": "https://github.com/Eli-Zaretskii",
    "followers_url": "https://api.github.com/users/Eli-Zaretskii/followers",
    "following_url": "https://api.github.com/users/Eli-Zaretskii/following{/other_user}",
    "gists_url": "https://api.github.com/users/Eli-Zaretskii/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Eli-Zaretskii/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Eli-Zaretskii/subscriptions",
    "organizations_url": "https://api.github.com/users/Eli-Zaretskii/orgs",
    "repos_url": "https://api.github.com/users/Eli-Zaretskii/repos",
    "events_url": "https://api.github.com/users/Eli-Zaretskii/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Eli-Zaretskii/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ac4d7c7bfa59e47d0bcb58031c15d888158a4dfa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ac4d7c7bfa59e47d0bcb58031c15d888158a4dfa",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ac4d7c7bfa59e47d0bcb58031c15d888158a4dfa"
    }
  ],
  "stats": {
    "total": 67,
    "additions": 56,
    "deletions": 11
  },
  "files": [
    {
      "sha": "5c38a4ed164bc0dfba948597b3dd05461ef2338c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3885679dd71bed069e7e6fc2ae8b9eb05f90d62/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3885679dd71bed069e7e6fc2ae8b9eb05f90d62/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b3885679dd71bed069e7e6fc2ae8b9eb05f90d62",
      "patch": "@@ -1,3 +1,14 @@\n+2021-04-10  Eli Zaretskii  <eliz@gnu.org>\n+\n+\t* windows-nat.c (windows_nat::handle_load_dll): Call\n+\twindows_add_dll if get_image_name failed to glean the name of the\n+\tDLL by using the lpImageName pointer.\n+\t(windows_add_all_dlls): Now a thin wrapper around windows_add_dll.\n+\t(windows_add_dll): Now does what windows_add_all_dlls did before,\n+\tbut also accepts an argument LOAD_ADDR, which, if non-NULL,\n+\tspecifies the address where the DLL was loaded into the inferior,\n+\tand looks for the single DLL loaded at that address.\n+\n 2021-04-09  Luis Machado  <luis.machado@linaro.org>\n \n \t* nat/aarch64-mte-linux-ptrace.c: Update include file order."
    },
    {
      "sha": "c0f64f879108b1acb96e789e9b13788c564c98d4",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 45,
      "deletions": 11,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3885679dd71bed069e7e6fc2ae8b9eb05f90d62/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3885679dd71bed069e7e6fc2ae8b9eb05f90d62/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=b3885679dd71bed069e7e6fc2ae8b9eb05f90d62",
      "patch": "@@ -869,6 +869,8 @@ windows_make_so (const char *name, LPVOID load_addr)\n   return so;\n }\n \n+static bool windows_add_dll (LPVOID);\n+\n /* See nat/windows-nat.h.  */\n \n void\n@@ -884,11 +886,21 @@ windows_nat::handle_load_dll ()\n      (source: MSDN LOAD_DLL_DEBUG_INFO structure).  */\n   dll_name = get_image_name (current_process_handle,\n \t\t\t     event->lpImageName, event->fUnicode);\n-  if (!dll_name)\n-    return;\n+  /* If the DLL name could not be gleaned via lpImageName, try harder\n+     by enumerating all the DLLs loaded into the inferior, looking for\n+     one that is loaded at base address = lpBaseOfDll. */\n+  if (dll_name != nullptr)\n+    {\n \n-  solib_end->next = windows_make_so (dll_name, event->lpBaseOfDll);\n-  solib_end = solib_end->next;\n+      solib_end->next = windows_make_so (dll_name, event->lpBaseOfDll);\n+      solib_end = solib_end->next;\n+    }\n+  else if (event->lpBaseOfDll != nullptr\n+\t   && windows_add_dll (event->lpBaseOfDll))\n+    dll_name = solib_end->so_name;\n+\n+  if (dll_name == nullptr)\n+    return;\n \n   lm_info_windows *li = (lm_info_windows *) solib_end->lm_info;\n \n@@ -1898,6 +1910,19 @@ windows_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n static void\n windows_add_all_dlls (void)\n+{\n+  windows_add_dll (NULL);\n+}\n+\n+/* Iterate over all DLLs currently mapped by our inferior, looking for\n+   a DLL which is loaded at LOAD_ADDR.  If found, add the DLL to our\n+   list of solibs and return 'true'; otherwise do nothing and return\n+   'false'.  LOAD_ADDR NULL means add all DLLs to the list of solibs;\n+   this is used when the inferior finishes its initialization, and all\n+   the DLLs it statically depends on are presumed loaded.  */\n+\n+static bool\n+windows_add_dll (LPVOID load_addr)\n {\n   HMODULE dummy_hmodule;\n   DWORD cb_needed;\n@@ -1910,18 +1935,18 @@ windows_add_all_dlls (void)\n       if (EnumProcessModulesEx (current_process_handle, &dummy_hmodule,\n \t\t\t\tsizeof (HMODULE), &cb_needed,\n \t\t\t\tLIST_MODULES_32BIT) == 0)\n-\treturn;\n+\treturn false;\n     }\n   else\n #endif\n     {\n       if (EnumProcessModules (current_process_handle, &dummy_hmodule,\n \t\t\t      sizeof (HMODULE), &cb_needed) == 0)\n-\treturn;\n+\treturn false;\n     }\n \n   if (cb_needed < 1)\n-    return;\n+    return false;\n \n   hmodules = (HMODULE *) alloca (cb_needed);\n #ifdef __x86_64__\n@@ -1930,14 +1955,14 @@ windows_add_all_dlls (void)\n       if (EnumProcessModulesEx (current_process_handle, hmodules,\n \t\t\t\tcb_needed, &cb_needed,\n \t\t\t\tLIST_MODULES_32BIT) == 0)\n-\treturn;\n+\treturn false;\n     }\n   else\n #endif\n     {\n       if (EnumProcessModules (current_process_handle, hmodules,\n \t\t\t      cb_needed, &cb_needed) == 0)\n-\treturn;\n+\treturn false;\n     }\n \n   char system_dir[__PMAX];\n@@ -1983,6 +2008,7 @@ windows_add_all_dlls (void)\n       if (GetModuleInformation (current_process_handle, hmodules[i],\n \t\t\t\t&mi, sizeof (mi)) == 0)\n \tcontinue;\n+\n       if (GetModuleFileNameEx (current_process_handle, hmodules[i],\n \t\t\t       dll_name, sizeof (dll_name)) == 0)\n \tcontinue;\n@@ -2005,9 +2031,17 @@ windows_add_all_dlls (void)\n \t  name = syswow_dll_path.c_str();\n \t}\n \n-      solib_end->next = windows_make_so (name, mi.lpBaseOfDll);\n-      solib_end = solib_end->next;\n+      /* Record the DLL if either LOAD_ADDR is NULL or the address\n+\t at which the DLL was loaded is equal to LOAD_ADDR.  */\n+      if (!(load_addr != nullptr && mi.lpBaseOfDll != load_addr))\n+\t{\n+\t  solib_end->next = windows_make_so (name, mi.lpBaseOfDll);\n+\t  solib_end = solib_end->next;\n+\t  if (load_addr != nullptr)\n+\t    return true;\n+\t}\n     }\n+  return load_addr == nullptr ? true : false;\n }\n \n void"
    }
  ]
}