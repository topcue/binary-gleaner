{
  "sha": "a4543480c5e7879955c57e20ab4e8935961153b5",
  "node_id": "C_kwDOANOeidoAKGE0NTQzNDgwYzVlNzg3OTk1NWM1N2UyMGFiNGU4OTM1OTYxMTUzYjU",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-01T14:40:02Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-09T02:00:39Z"
    },
    "message": "gdb/remote.c: move some things up\n\nMove the stop_reply and a few functions up.  Some code above them in the\nfile will need to use them in a following patch.  No behavior changes\nexpected here.\n\nChange-Id: I3ca57d0e3ec253f56e1ba401289d9d167de14ad2",
    "tree": {
      "sha": "26ab9c2187df595d2e8e6a45454ee36960e92c78",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/26ab9c2187df595d2e8e6a45454ee36960e92c78"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a4543480c5e7879955c57e20ab4e8935961153b5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a4543480c5e7879955c57e20ab4e8935961153b5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a4543480c5e7879955c57e20ab4e8935961153b5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a4543480c5e7879955c57e20ab4e8935961153b5/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4a3ee32a402c865d2abec9bd6b708bc315a0fff8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a3ee32a402c865d2abec9bd6b708bc315a0fff8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4a3ee32a402c865d2abec9bd6b708bc315a0fff8"
    }
  ],
  "stats": {
    "total": 144,
    "additions": 71,
    "deletions": 73
  },
  "files": [
    {
      "sha": "f78417b5de779659e1e3117a01cfd119916f42ce",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 71,
      "deletions": 73,
      "changes": 144,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a4543480c5e7879955c57e20ab4e8935961153b5/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a4543480c5e7879955c57e20ab4e8935961153b5/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=a4543480c5e7879955c57e20ab4e8935961153b5",
      "patch": "@@ -996,6 +996,36 @@ class extended_remote_target final : public remote_target\n   bool supports_disable_randomization () override;\n };\n \n+struct stop_reply : public notif_event\n+{\n+  ~stop_reply ();\n+\n+  /* The identifier of the thread about this event  */\n+  ptid_t ptid;\n+\n+  /* The remote state this event is associated with.  When the remote\n+     connection, represented by a remote_state object, is closed,\n+     all the associated stop_reply events should be released.  */\n+  struct remote_state *rs;\n+\n+  struct target_waitstatus ws;\n+\n+  /* The architecture associated with the expedited registers.  */\n+  gdbarch *arch;\n+\n+  /* Expedited registers.  This makes remote debugging a bit more\n+     efficient for those targets that provide critical registers as\n+     part of their normal status mechanism (as another roundtrip to\n+     fetch them is avoided).  */\n+  std::vector<cached_reg_t> regcache;\n+\n+  enum target_stop_reason stop_reason;\n+\n+  CORE_ADDR watch_data_address;\n+\n+  int core;\n+};\n+\n /* See remote.h.  */\n \n bool\n@@ -5846,6 +5876,47 @@ remote_target::open_1 (const char *name, int from_tty, int extended_p)\n     rs->wait_forever_enabled_p = 1;\n }\n \n+/* Determine if THREAD_PTID is a pending fork parent thread.  ARG contains\n+   the pid of the process that owns the threads we want to check, or\n+   -1 if we want to check all threads.  */\n+\n+static int\n+is_pending_fork_parent (const target_waitstatus &ws, int event_pid,\n+\t\t\tptid_t thread_ptid)\n+{\n+  if (ws.kind () == TARGET_WAITKIND_FORKED\n+      || ws.kind () == TARGET_WAITKIND_VFORKED)\n+    {\n+      if (event_pid == -1 || event_pid == thread_ptid.pid ())\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return the thread's pending status used to determine whether the\n+   thread is a fork parent stopped at a fork event.  */\n+\n+static const target_waitstatus &\n+thread_pending_fork_status (struct thread_info *thread)\n+{\n+  if (thread->has_pending_waitstatus ())\n+    return thread->pending_waitstatus ();\n+  else\n+    return thread->pending_follow;\n+}\n+\n+/* Determine if THREAD is a pending fork parent thread.  */\n+\n+static int\n+is_pending_fork_parent_thread (struct thread_info *thread)\n+{\n+  const target_waitstatus &ws = thread_pending_fork_status (thread);\n+  int pid = -1;\n+\n+  return is_pending_fork_parent (ws, pid, thread->ptid);\n+}\n+\n /* Detach the specified process.  */\n \n void\n@@ -6538,8 +6609,6 @@ remote_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n     rs->waiting_for_stop_reply = 1;\n }\n \n-static int is_pending_fork_parent_thread (struct thread_info *thread);\n-\n /* Private per-inferior info for target remote processes.  */\n \n struct remote_inferior : public private_inferior\n@@ -6559,36 +6628,6 @@ get_remote_inferior (inferior *inf)\n   return static_cast<remote_inferior *> (inf->priv.get ());\n }\n \n-struct stop_reply : public notif_event\n-{\n-  ~stop_reply ();\n-\n-  /* The identifier of the thread about this event  */\n-  ptid_t ptid;\n-\n-  /* The remote state this event is associated with.  When the remote\n-     connection, represented by a remote_state object, is closed,\n-     all the associated stop_reply events should be released.  */\n-  struct remote_state *rs;\n-\n-  struct target_waitstatus ws;\n-\n-  /* The architecture associated with the expedited registers.  */\n-  gdbarch *arch;\n-\n-  /* Expedited registers.  This makes remote debugging a bit more\n-     efficient for those targets that provide critical registers as\n-     part of their normal status mechanism (as another roundtrip to\n-     fetch them is avoided).  */\n-  std::vector<cached_reg_t> regcache;\n-\n-  enum target_stop_reason stop_reason;\n-\n-  CORE_ADDR watch_data_address;\n-\n-  int core;\n-};\n-\n /* Class used to track the construction of a vCont packet in the\n    outgoing packet buffer.  This is used to send multiple vCont\n    packets if we have more actions than would fit a single packet.  */\n@@ -7255,47 +7294,6 @@ struct notif_client notif_client_stop =\n   REMOTE_NOTIF_STOP,\n };\n \n-/* Determine if THREAD_PTID is a pending fork parent thread.  ARG contains\n-   the pid of the process that owns the threads we want to check, or\n-   -1 if we want to check all threads.  */\n-\n-static int\n-is_pending_fork_parent (const target_waitstatus &ws, int event_pid,\n-\t\t\tptid_t thread_ptid)\n-{\n-  if (ws.kind () == TARGET_WAITKIND_FORKED\n-      || ws.kind () == TARGET_WAITKIND_VFORKED)\n-    {\n-      if (event_pid == -1 || event_pid == thread_ptid.pid ())\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return the thread's pending status used to determine whether the\n-   thread is a fork parent stopped at a fork event.  */\n-\n-static const target_waitstatus &\n-thread_pending_fork_status (struct thread_info *thread)\n-{\n-  if (thread->has_pending_waitstatus ())\n-    return thread->pending_waitstatus ();\n-  else\n-    return thread->pending_follow;\n-}\n-\n-/* Determine if THREAD is a pending fork parent thread.  */\n-\n-static int\n-is_pending_fork_parent_thread (struct thread_info *thread)\n-{\n-  const target_waitstatus &ws = thread_pending_fork_status (thread);\n-  int pid = -1;\n-\n-  return is_pending_fork_parent (ws, pid, thread->ptid);\n-}\n-\n /* If CONTEXT contains any fork child threads that have not been\n    reported yet, remove them from the CONTEXT list.  If such a\n    thread exists it is because we are stopped at a fork catchpoint"
    }
  ]
}