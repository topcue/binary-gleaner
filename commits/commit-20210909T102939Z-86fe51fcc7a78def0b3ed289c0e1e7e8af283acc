{
  "sha": "86fe51fcc7a78def0b3ed289c0e1e7e8af283acc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODZmZTUxZmNjN2E3OGRlZjBiM2VkMjg5YzBlMWU3ZThhZjI4M2FjYw==",
  "commit": {
    "author": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-09-09T10:29:39Z"
    },
    "committer": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-09-09T10:29:39Z"
    },
    "message": "[gdb/testsuite] Reimplement gdb.gdb/complaints.exp as unittest\n\nWhen building gdb with \"-Wall -O2 -g -flto=auto\", I run into:\n...\n(gdb) call clear_complaints()^M\nNo symbol \"clear_complaints\" in current context.^M\n(gdb) FAIL: gdb.gdb/complaints.exp: clear complaints\n...\n\nThe problem is that lto has optimized away the clear_complaints function\nand consequently the selftest doesn't work.\n\nFix this by reimplementing the selftest as a unit test.\n\nFactor out two new functions:\n- void\n  execute_fn_to_ui_file (struct ui_file *file, std::function<void(void)> fn);\n- std::string\n  execute_fn_to_string (std::function<void(void)> fn, bool term_out);\nand use the latter to capture the complaints output.\n\nTested on x86_64-linux.",
    "tree": {
      "sha": "253f4db9ce3f893e710d1163aabb08179dee46bc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/253f4db9ce3f893e710d1163aabb08179dee46bc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc/comments",
  "author": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0b233e34c801eac78a5e03b66f18585cf368e4d5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0b233e34c801eac78a5e03b66f18585cf368e4d5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0b233e34c801eac78a5e03b66f18585cf368e4d5"
    }
  ],
  "stats": {
    "total": 246,
    "additions": 94,
    "deletions": 152
  },
  "files": [
    {
      "sha": "525a3a7eacf4bd1cb020863664f573cdbf4b9d0c",
      "filename": "gdb/complaints.c",
      "status": "modified",
      "additions": 52,
      "deletions": 0,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc/gdb/complaints.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc/gdb/complaints.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/complaints.c?ref=86fe51fcc7a78def0b3ed289c0e1e7e8af283acc",
      "patch": "@@ -21,6 +21,7 @@\n #include \"complaints.h\"\n #include \"command.h\"\n #include \"gdbcmd.h\"\n+#include \"gdbsupport/selftest.h\"\n #include <unordered_map>\n \n /* Map format strings to counters.  */\n@@ -74,6 +75,53 @@ complaints_show_value (struct ui_file *file, int from_tty,\n \t\t    value);\n }\n \n+#if GDB_SELF_TEST\n+namespace selftests {\n+\n+/* Entry point for complaints unit tests.  */\n+\n+static void\n+test_complaints ()\n+{\n+  std::unordered_map<const char *, int> tmp;\n+  scoped_restore reset_counters = make_scoped_restore (&counters, tmp);\n+  scoped_restore reset_stop_whining = make_scoped_restore (&stop_whining, 2);\n+\n+#define CHECK_COMPLAINT(STR, CNT)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      std::string output;\t\t\t\t\t\t\\\n+      output = execute_fn_to_string ([]() { complaint (STR); }, false);\t\\\n+      std::string expected\t\t\t\t\t\t\\\n+\t= _(\"During symbol reading: \") + std::string (STR \"\\n\");\t\\\n+      SELF_CHECK (output == expected);\t\t\t\t\t\\\n+      SELF_CHECK (counters[STR] == CNT);\t\t\t\t\\\n+    } while (0)\n+\n+#define CHECK_COMPLAINT_SILENT(STR, CNT)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      std::string output;\t\t\t\t\t\t\\\n+      output = execute_fn_to_string ([]() { complaint (STR); }, false);\t\\\n+      SELF_CHECK (output.empty ());\t\t\t\t\t\\\n+      SELF_CHECK (counters[STR] == CNT);\t\t\t\t\\\n+    } while (0)\n+\n+  CHECK_COMPLAINT (\"maintenance complaint 0\", 1);\n+  CHECK_COMPLAINT (\"maintenance complaint 0\", 2);\n+  CHECK_COMPLAINT_SILENT (\"maintenance complaint 0\", 3);\n+  CHECK_COMPLAINT (\"maintenance complaint 1\", 1);\n+  clear_complaints ();\n+  CHECK_COMPLAINT (\"maintenance complaint 0\", 1);\n+\n+#undef CHECK_COMPLAINT\n+#undef CHECK_COMPLAINT_SILENT\n+}\n+\n+\n+} // namespace selftests\n+#endif /* GDB_SELF_TEST */\n+\n void _initialize_complaints ();\n void\n _initialize_complaints ()\n@@ -84,4 +132,8 @@ Set max number of complaints about incorrect symbols.\"), _(\"\\\n Show max number of complaints about incorrect symbols.\"), NULL,\n \t\t\t    NULL, complaints_show_value,\n \t\t\t    &setlist, &showlist);\n+\n+#if GDB_SELF_TEST\n+  selftests::register_test (\"complaints\", selftests::test_complaints);\n+#endif /* GDB_SELF_TEST */\n }"
    },
    {
      "sha": "27550c1faeebedde95764aa8aca657f767ef42d3",
      "filename": "gdb/gdbcmd.h",
      "status": "modified",
      "additions": 19,
      "deletions": 7,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc/gdb/gdbcmd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc/gdb/gdbcmd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbcmd.h?ref=86fe51fcc7a78def0b3ed289c0e1e7e8af283acc",
      "patch": "@@ -134,17 +134,29 @@ extern struct cmd_list_element *save_cmdlist;\n \n extern void execute_command (const char *, int);\n \n-/* Run execute_command for P and FROM_TTY.  Capture its output into the\n-   returned string, do not display it to the screen.  The global BATCH_FLAG\n-   will temporarily be set to true.  When TERM_OUT is true the output is\n-   collected with terminal behaviour (e.g. with styling).  When TERM_OUT is\n-   false raw output will be collected (e.g. no styling).  */\n+/* Run FN.  Sends its output to FILE, do not display it to the screen.\n+   The global BATCH_FLAG will be temporarily set to true.  */\n+\n+extern void execute_fn_to_ui_file (struct ui_file *file, std::function<void(void)> fn);\n+\n+/* Run FN.  Capture its output into the returned string, do not display it\n+   to the screen.  The global BATCH_FLAG will temporarily be set to true.\n+   When TERM_OUT is true the output is collected with terminal behaviour\n+   (e.g. with styling).  When TERM_OUT is false raw output will be collected\n+   (e.g. no styling).  */\n+\n+extern std::string execute_fn_to_string (std::function<void(void)> fn, bool term_out);\n+\n+/* As execute_fn_to_ui_file, but run execute_command for P and FROM_TTY.  */\n \n-extern std::string execute_command_to_string (const char *p, int from_tty,\n-\t\t\t\t\t      bool term_out);\n extern void execute_command_to_ui_file (struct ui_file *file,\n \t\t\t\t\tconst char *p, int from_tty);\n \n+/* As execute_fn_to_string, but run execute_command for P and FROM_TTY.  */\n+\n+extern std::string execute_command_to_string (const char *p, int from_tty,\n+\t\t\t\t\t      bool term_out);\n+\n extern void print_command_line (struct command_line *, unsigned int,\n \t\t\t\tstruct ui_file *);\n extern void print_command_lines (struct ui_out *,"
    },
    {
      "sha": "2391d66125076a651eb2cc7bee23a9a9ea8f9d78",
      "filename": "gdb/testsuite/gdb.gdb/complaints.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 137,
      "changes": 137,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0b233e34c801eac78a5e03b66f18585cf368e4d5/gdb/testsuite/gdb.gdb/complaints.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0b233e34c801eac78a5e03b66f18585cf368e4d5/gdb/testsuite/gdb.gdb/complaints.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.gdb/complaints.exp?ref=0b233e34c801eac78a5e03b66f18585cf368e4d5",
      "patch": "@@ -1,137 +0,0 @@\n-# Copyright 2002-2021 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-# This file was written by Andrew Cagney (cagney at redhat dot com),\n-# derived from xfullpath.exp (written by Joel Brobecker), derived from\n-# selftest.exp (written by Rob Savoye).\n-\n-load_lib selftest-support.exp\n-\n-if [target_info exists gdb,noinferiorio] {\n-    verbose \"Skipping because of no inferiorio capabilities.\"\n-    return\n-}\n-\n-# Similar to gdb_test_stdio, except no \\r\\n is expected before\n-# $gdb_prompt in the $gdb_spawn_id.\n-\n-proc test_complaint {test inferior_io_re msg} {\n-    global inferior_spawn_id gdb_spawn_id\n-    global gdb_prompt\n-\n-    set inferior_matched 0\n-    set gdb_matched 0\n-\n-    gdb_test_multiple $test $msg {\n-\t-i $inferior_spawn_id -re \"$inferior_io_re\" {\n-\t    set inferior_matched 1\n-\t    if {!$gdb_matched} {\n-\t\texp_continue\n-\t    }\n-\t}\n-\t-i $gdb_spawn_id -re \"$gdb_prompt $\" {\n-\t    set gdb_matched 1\n-\t    if {!$inferior_matched} {\n-\t\texp_continue\n-\t    }\n-\t}\n-    }\n-\n-    verbose -log \"inferior_matched=$inferior_matched, gdb_matched=$gdb_matched\"\n-    gdb_assert {$inferior_matched && $gdb_matched} $msg\n-}\n-\n-proc test_initial_complaints { } {\n-    # Unsupress complaints\n-    gdb_test \"set stop_whining = 2\"\n-\n-    gdb_test_no_output \"set var \\$cstr = \\\"Register a complaint\\\"\"\n-\n-    # Prime the system\n-    gdb_test_stdio \\\n-\t\"call complaint_internal (\\$cstr)\" \\\n-\t\"During symbol reading: Register a complaint\"\n-\n-    # Re-issue the first message #1\n-    with_test_prefix \"re-issue\" {\n-\tgdb_test_stdio \\\n-\t    \"call complaint_internal (\\$cstr)\" \\\n-\t    \"During symbol reading: Register a complaint\"\n-    }\n-\n-    # Add a second complaint, expect it\n-    gdb_test_stdio \\\n-\t\"call complaint_internal (\\\"Testing! Testing! Testing!\\\")\" \\\n-\t\"During symbol reading: Testing. Testing. Testing.\"\n-\n-    return 0\n-}\n-\n-# Check that nothing comes out when there haven't been any real\n-# complaints.  Note that each test is really checking the previous\n-# command.\n-\n-proc test_empty_complaint { cmd msg } {\n-    global gdb_prompt\n-    global inferior_spawn_id gdb_spawn_id\n-\n-    if {$gdb_spawn_id == $inferior_spawn_id} {\n-\tgdb_test_no_output $cmd $msg\n-    } else {\n-\tset seen_output 0\n-\tgdb_test_multiple $cmd $msg {\n-\t    -i $inferior_spawn_id -re \".\" {\n-\t\tset seen_output 1\n-\t\texp_continue\n-\t    }\n-\t    -i $gdb_spawn_id \"$gdb_prompt $\" {\n-\t\tgdb_assert !$seen_output $msg\n-\t    }\n-\t}\n-    }\n-}\n-\n-proc test_empty_complaints { } {\n-    global decimal\n-\n-    set re [multi_line \\\n-\t\t\"All functions matching regular expression \\[^:\\]*:\" \\\n-\t\t\"\" \\\n-\t\t\"File \\[^\\r\\n\\]*/complaints\\\\.c:\" \\\n-\t\t\"$decimal:\\tvoid clear_complaints\\\\(\\\\);\"]\n-\n-    set found 0\n-    gdb_test_multiple \"info function ^clear_complaints()$\" \"\" {\n-\t-re -wrap $re {\n-\t    set found 1\n-\t}\n-\t-re -wrap \"\" {\n-\t}\n-    }\n-    if { ! $found } {\n-\tuntested \"Cannot find clear_complaints, skipping test\"\n-\treturn 0\n-    }\n-\n-    test_empty_complaint \"call clear_complaints()\" \\\n-\t    \"clear complaints\"\n-\n-    return 0\n-}\n-\n-do_self_tests captured_command_loop {\n-    test_initial_complaints\n-    test_empty_complaints\n-}"
    },
    {
      "sha": "7e95ed3969ce94fba47d1067519b27d1929362f9",
      "filename": "gdb/top.c",
      "status": "modified",
      "additions": 23,
      "deletions": 8,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc/gdb/top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/86fe51fcc7a78def0b3ed289c0e1e7e8af283acc/gdb/top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/top.c?ref=86fe51fcc7a78def0b3ed289c0e1e7e8af283acc",
      "patch": "@@ -696,12 +696,10 @@ execute_command (const char *p, int from_tty)\n   cleanup_if_error.release ();\n }\n \n-/* Run execute_command for P and FROM_TTY.  Sends its output to FILE,\n-   do not display it to the screen.  BATCH_FLAG will be\n-   temporarily set to true.  */\n+/* See gdbcmd.h.  */\n \n void\n-execute_command_to_ui_file (struct ui_file *file, const char *p, int from_tty)\n+execute_fn_to_ui_file (struct ui_file *file, std::function<void(void)> fn)\n {\n   /* GDB_STDOUT should be better already restored during these\n      restoration callbacks.  */\n@@ -724,22 +722,39 @@ execute_command_to_ui_file (struct ui_file *file, const char *p, int from_tty)\n     scoped_restore save_stdtargerr\n       = make_scoped_restore (&gdb_stdtargerr, file);\n \n-    execute_command (p, from_tty);\n+    fn ();\n   }\n }\n \n /* See gdbcmd.h.  */\n \n std::string\n-execute_command_to_string (const char *p, int from_tty,\n-\t\t\t   bool term_out)\n+execute_fn_to_string (std::function<void(void)> fn, bool term_out)\n {\n   string_file str_file (term_out);\n \n-  execute_command_to_ui_file (&str_file, p, from_tty);\n+  execute_fn_to_ui_file (&str_file, fn);\n   return std::move (str_file.string ());\n }\n \n+/* See gdbcmd.h.  */\n+\n+void\n+execute_command_to_ui_file (struct ui_file *file,\n+\t\t\t    const char *p, int from_tty)\n+{\n+  execute_fn_to_ui_file (file, [=]() { execute_command (p, from_tty); });\n+}\n+\n+/* See gdbcmd.h.  */\n+\n+std::string\n+execute_command_to_string (const char *p, int from_tty,\n+\t\t\t   bool term_out)\n+{\n+  return\n+    execute_fn_to_string ([=]() { execute_command (p, from_tty); }, term_out);\n+}\n \f\n /* When nonzero, cause dont_repeat to do nothing.  This should only be\n    set via prevent_dont_repeat.  */"
    }
  ]
}