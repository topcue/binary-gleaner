{
  "sha": "c507f10b0711f24e1b82b8bd096e605317cf77fe",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzUwN2YxMGIwNzExZjI0ZTFiODJiOGJkMDk2ZTYwNTMxN2NmNzdmZQ==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T13:29:36Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T15:37:35Z"
    },
    "message": "[PATCH 45/57][Arm][OBJDUMP] Add support for MVE instructions: vmov, vmvn, vorr, vorn, vmovx and vbic\n\nopcodes/ChangeLog:\n2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t    Michael Collison <michael.collison@arm.com>\n\n\t* arm-dis.c (enum mve_instructions): Add new instructions.\n\t(enum mve_unpredictable): Add new reasons.\n\t(enum mve_undefined): Likewise.\n\t(is_mve_okay_in_it): Handle new isntructions.\n\t(is_mve_encoding_conflict): Likewise.\n\t(is_mve_undefined): Likewise.\n\t(is_mve_unpredictable): Likewise.\n\t(print_mve_vmov_index): Likewise.\n\t(print_simd_imm8): Likewise.\n\t(print_mve_undefined): Likewise.\n\t(print_mve_unpredictable): Likewise.\n\t(print_mve_size): Likewise.\n\t(print_insn_mve): Likewise.",
    "tree": {
      "sha": "e8ac6e00aa1097c4659fe75006ecd4e799b6a8f2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e8ac6e00aa1097c4659fe75006ecd4e799b6a8f2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c507f10b0711f24e1b82b8bd096e605317cf77fe",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c507f10b0711f24e1b82b8bd096e605317cf77fe",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c507f10b0711f24e1b82b8bd096e605317cf77fe",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c507f10b0711f24e1b82b8bd096e605317cf77fe/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bf0b396de71b76c02f6dd37e61e4044cdccb28d3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf0b396de71b76c02f6dd37e61e4044cdccb28d3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bf0b396de71b76c02f6dd37e61e4044cdccb28d3"
    }
  ],
  "stats": {
    "total": 626,
    "additions": 621,
    "deletions": 5
  },
  "files": [
    {
      "sha": "571dd3de3ecf18daf26c7ccc78afb559f34dbbdc",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c507f10b0711f24e1b82b8bd096e605317cf77fe/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c507f10b0711f24e1b82b8bd096e605317cf77fe/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=c507f10b0711f24e1b82b8bd096e605317cf77fe",
      "patch": "@@ -1,3 +1,20 @@\n+2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Michael Collison <michael.collison@arm.com>\n+\n+\t* arm-dis.c (enum mve_instructions): Add new instructions.\n+\t(enum mve_unpredictable): Add new reasons.\n+\t(enum mve_undefined): Likewise.\n+\t(is_mve_okay_in_it): Handle new isntructions.\n+\t(is_mve_encoding_conflict): Likewise.\n+\t(is_mve_undefined): Likewise.\n+\t(is_mve_unpredictable): Likewise.\n+\t(print_mve_vmov_index): Likewise.\n+\t(print_simd_imm8): Likewise.\n+\t(print_mve_undefined): Likewise.\n+\t(print_mve_unpredictable): Likewise.\n+\t(print_mve_size): Likewise.\n+\t(print_insn_mve): Likewise.\n+\n 2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Michael Collison <michael.collison@arm.com>\n "
    },
    {
      "sha": "a779138db0c267ac759d711240426f9c138ffc6e",
      "filename": "opcodes/arm-dis.c",
      "status": "modified",
      "additions": 604,
      "deletions": 5,
      "changes": 609,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c507f10b0711f24e1b82b8bd096e605317cf77fe/opcodes/arm-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c507f10b0711f24e1b82b8bd096e605317cf77fe/opcodes/arm-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arm-dis.c?ref=c507f10b0711f24e1b82b8bd096e605317cf77fe",
      "patch": "@@ -129,6 +129,21 @@ enum mve_instructions\n   MVE_VCVT_FP_HALF_FP,\n   MVE_VCVT_FROM_FP_TO_INT,\n   MVE_VRINT_FP,\n+  MVE_VMOV_HFP_TO_GP,\n+  MVE_VMOV_GP_TO_VEC_LANE,\n+  MVE_VMOV_IMM_TO_VEC,\n+  MVE_VMOV_VEC_TO_VEC,\n+  MVE_VMOV2_VEC_LANE_TO_GP,\n+  MVE_VMOV2_GP_TO_VEC_LANE,\n+  MVE_VMOV_VEC_LANE_TO_GP,\n+  MVE_VMVN_IMM,\n+  MVE_VMVN_REG,\n+  MVE_VORR_IMM,\n+  MVE_VORR_REG,\n+  MVE_VORN,\n+  MVE_VBIC_IMM,\n+  MVE_VBIC_REG,\n+  MVE_VMOVX,\n   MVE_NONE\n };\n \n@@ -152,12 +167,17 @@ enum mve_unpredictable\n   UNPRED_OS,\t\t\t/* Unpredictable because offset scaled == 1.  */\n   UNPRED_GP_REGS_EQUAL,\t\t/* Unpredictable because gp registers are the\n \t\t\t\t   same.  */\n+  UNPRED_Q_REGS_EQ_AND_SIZE_1,\t/* Unpredictable because q regs equal and\n+\t\t\t\t   size = 1.  */\n+  UNPRED_Q_REGS_EQ_AND_SIZE_2,\t/* Unpredictable because q regs equal and\n+\t\t\t\t   size = 2.  */\n   UNPRED_NONE\t\t\t/* No unpredictable behavior.  */\n };\n \n enum mve_undefined\n {\n   UNDEF_SIZE_0,\t\t\t/* undefined because size == 0.  */\n+  UNDEF_SIZE_2,\t\t\t/* undefined because size == 2.  */\n   UNDEF_SIZE_3,\t\t\t/* undefined because size == 3.  */\n   UNDEF_SIZE_LE_1,\t\t/* undefined because size <= 1.  */\n   UNDEF_SIZE_NOT_2,\t\t/* undefined because size != 2.  */\n@@ -169,6 +189,12 @@ enum mve_undefined\n   UNDEF_NOT_UNSIGNED,\t\t/* undefined because U == 0.  */\n   UNDEF_VCVT_IMM6,\t\t/* imm6 < 32.  */\n   UNDEF_VCVT_FSI_IMM6,\t\t/* fsi = 0 and 32 >= imm6 <= 47.  */\n+  UNDEF_BAD_OP1_OP2,\t\t/* undefined with op2 = 2 and\n+\t\t\t\t   op1 == (0 or 1).  */\n+  UNDEF_BAD_U_OP1_OP2,\t\t/* undefined with U = 1 and\n+\t\t\t\t   op2 == 0 and op1 == (0 or 1).  */\n+  UNDEF_OP_0_BAD_CMODE,\t\t/* undefined because op == 0 and cmode\n+\t\t\t\t   in {0xx1, x0x1}.  */\n   UNDEF_NONE\t\t\t/* no undefined behavior.  */\n };\n \n@@ -1885,15 +1911,19 @@ static const struct opcode32 neon_opcodes[] =\n    %o\t\t\tprint offset scaled for vldr[hwd] and vstr[hwd]\n    %w\t\t\tprint writeback mode for MVE v{st,ld}[24]\n    %B\t\t\tprint v{st,ld}[24] any one operands\n+   %E\t\t\tprint vmov, vmvn, vorr, vbic encoded constant\n+   %N\t\t\tprint generic index for vmov\n \n    %<bitfield>r\t\tprint as an ARM register\n    %<bitfield>d\t\tprint the bitfield in decimal\n    %<bitfield>Q\t\tprint as a MVE Q register\n+   %<bitfield>F\t\tprint as a MVE S register\n    %<bitfield>Z\t\tas %<>r but r15 is ZR instead of PC and r13 is\n \t\t\tUNPREDICTABLE\n    %<bitfield>s\t\tprint size for vector predicate & non VMOV instructions\n    %<bitfield>i\t\tprint immediate for vstr/vldr reg +/- imm\n    %<bitfield>k\t\tprint immediate for vector conversion instruction\n+   %<bitfield>x\t\tprint the bitfield in hex.\n  */\n \n static const struct mopcode32 mve_opcodes[] =\n@@ -1948,6 +1978,18 @@ static const struct mopcode32 mve_opcodes[] =\n    0xfe011f40, 0xff811f50,\n    \"vpt%i.s%20-21s\\t%n, %17-19Q, %0-3Z\"},\n \n+  /* Vector VBIC immediate.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VBIC_IMM,\n+   0xef800070, 0xefb81070,\n+   \"vbic%v.i%8-11s\\t%13-15,22Q, %E\"},\n+\n+  /* Vector VBIC register.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VBIC_REG,\n+   0xef100150, 0xffb11f51,\n+   \"vbic%v\\t%13-15,22Q, %17-19,7Q, %1-3,5Q\"},\n+\n   /* Vector VCMP floating point T1.  */\n   {ARM_FEATURE_COPROC (FPU_MVE_FP),\n    MVE_VCMP_FP_T1,\n@@ -2171,6 +2213,103 @@ static const struct mopcode32 mve_opcodes[] =\n    0xec101f00, 0xfe101f80,\n    \"vldrw%v.u32\\t%13-15,22Q, %d\"},\n \n+  /* Vector VMOV between gpr and half precision register, op == 0.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VMOV_HFP_TO_GP,\n+   0xee000910, 0xfff00f7f,\n+   \"vmov.f16\\t%7,16-19F, %12-15r\"},\n+\n+  /* Vector VMOV between gpr and half precision register, op == 1.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VMOV_HFP_TO_GP,\n+   0xee100910, 0xfff00f7f,\n+   \"vmov.f16\\t%12-15r, %7,16-19F\"},\n+\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VMOV_GP_TO_VEC_LANE,\n+   0xee000b10, 0xff900f1f,\n+   \"vmov%c.%5-6,21-22s\\t%17-19,7Q[%N], %12-15r\"},\n+\n+  /* Vector VORR immediate to vector.\n+     NOTE: MVE_VORR_IMM must appear in the table\n+     before MVE_VMOV_IMM_TO_VEC due to opcode aliasing.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VORR_IMM,\n+   0xef800050, 0xefb810f0,\n+   \"vorr%v.i%8-11s\\t%13-15,22Q, %E\"},\n+\n+  /* Vector VMOV immediate to vector,\n+     cmode == 11x1 -> VMVN which is UNDEFINED\n+     for such a cmode.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VMVN_IMM, 0xef800d50, 0xefb81dd0, UNDEFINED_INSTRUCTION},\n+\n+  /* Vector VMOV immediate to vector.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VMOV_IMM_TO_VEC,\n+   0xef800050, 0xefb810d0,\n+   \"vmov%v.%5,8-11s\\t%13-15,22Q, %E\"},\n+\n+  /* Vector VMOV two 32-bit lanes to two gprs, idx = 0.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VMOV2_VEC_LANE_TO_GP,\n+   0xec000f00, 0xffb01ff0,\n+   \"vmov%c\\t%0-3r, %16-19r, %13-15,22Q[2], %13-15,22Q[0]\"},\n+\n+  /* Vector VMOV two 32-bit lanes to two gprs, idx = 1.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VMOV2_VEC_LANE_TO_GP,\n+   0xec000f10, 0xffb01ff0,\n+   \"vmov%c\\t%0-3r, %16-19r, %13-15,22Q[3], %13-15,22Q[1]\"},\n+\n+  /* Vector VMOV Two gprs to two 32-bit lanes, idx = 0.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VMOV2_GP_TO_VEC_LANE,\n+   0xec100f00, 0xffb01ff0,\n+   \"vmov%c\\t%13-15,22Q[2], %13-15,22Q[0], %0-3r, %16-19r\"},\n+\n+  /* Vector VMOV Two gprs to two 32-bit lanes, idx = 1.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VMOV2_GP_TO_VEC_LANE,\n+   0xec100f10, 0xffb01ff0,\n+   \"vmov%c\\t%13-15,22Q[2], %13-15,22Q[0], %0-3r, %16-19r\"},\n+\n+  /* Vector VMOV Vector lane to gpr.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VMOV_VEC_LANE_TO_GP,\n+   0xee100b10, 0xff100f1f,\n+   \"vmov%c.%u%5-6,21-22s\\t%12-15r, %17-19,7Q[%N]\"},\n+\n+  /* Floating point move extract.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VMOVX,\n+   0xfeb00a40, 0xffbf0fd0,\n+   \"vmovx.f16\\t%22,12-15F, %5,0-3F\"},\n+\n+  /* Vector VMVN immediate to vector.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VMVN_IMM,\n+   0xef800070, 0xefb810f0,\n+   \"vmvn%v.i%8-11s\\t%13-15,22Q, %E\"},\n+\n+  /* Vector VMVN register.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VMVN_REG,\n+   0xffb005c0, 0xffbf1fd1,\n+   \"vmvn%v\\t%13-15,22Q, %1-3,5Q\"},\n+\n+  /* Vector VORN, vector bitwise or not.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VORN,\n+   0xef300150, 0xffb11f51,\n+   \"vorn%v\\t%13-15,22Q, %17-19,7Q, %1-3,5Q\"},\n+\n+  /* Vector VORR register.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VORR_REG,\n+   0xef200150, 0xffb11f51,\n+   \"vorr%v\\t%13-15,22Q, %17-19,7Q, %1-3,5Q\"},\n+\n   /* Vector VRINT floating point.  */\n   {ARM_FEATURE_COPROC (FPU_MVE_FP),\n    MVE_VRINT_FP,\n@@ -4127,7 +4266,16 @@ arm_decode_shift (long given, fprintf_ftype func, void *stream,\n static bfd_boolean\n is_mve_okay_in_it (enum mve_instructions matched_insn)\n {\n-  return FALSE;\n+  switch (matched_insn)\n+    {\n+    case MVE_VMOV_GP_TO_VEC_LANE:\n+    case MVE_VMOV2_VEC_LANE_TO_GP:\n+    case MVE_VMOV2_GP_TO_VEC_LANE:\n+    case MVE_VMOV_VEC_LANE_TO_GP:\n+      return TRUE;\n+    default:\n+      return FALSE;\n+    }\n }\n \n static bfd_boolean\n@@ -4320,6 +4468,40 @@ is_mve_encoding_conflict (unsigned long given,\n     case MVE_VCVT_FP_FIX_VEC:\n       return (arm_decode_field (given, 16, 21) & 0x38) == 0;\n \n+    case MVE_VBIC_IMM:\n+    case MVE_VORR_IMM:\n+      {\n+\tunsigned long cmode = arm_decode_field (given, 8, 11);\n+\n+\tif ((cmode & 1) == 0)\n+\t  return TRUE;\n+\telse if ((cmode & 0xc) == 0xc)\n+\t  return TRUE;\n+\telse\n+\t  return FALSE;\n+      }\n+\n+    case MVE_VMVN_IMM:\n+      {\n+\tunsigned long cmode = arm_decode_field (given, 8, 11);\n+\n+\tif ((cmode & 9) == 1)\n+\t  return TRUE;\n+\telse if ((cmode & 5) == 1)\n+\t  return TRUE;\n+\telse if ((cmode & 0xe) == 0xe)\n+\t  return TRUE;\n+\telse\n+\t  return FALSE;\n+      }\n+\n+    case MVE_VMOV_IMM_TO_VEC:\n+      if ((arm_decode_field (given, 5, 5) == 1)\n+\t  && (arm_decode_field (given, 8, 11) != 0xe))\n+\treturn TRUE;\n+      else\n+\treturn FALSE;\n+\n     default:\n       return FALSE;\n \n@@ -4612,6 +4794,67 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n \t  return FALSE;\n       }\n \n+    case MVE_VMOV_VEC_LANE_TO_GP:\n+      {\n+\tunsigned long op1 = arm_decode_field (given, 21, 22);\n+\tunsigned long op2 = arm_decode_field (given, 5, 6);\n+\tunsigned long u = arm_decode_field (given, 23, 23);\n+\n+\tif ((op2 == 0) && (u == 1))\n+\t  {\n+\t    if ((op1 == 0) || (op1 == 1))\n+\t      {\n+\t\t*undefined_code = UNDEF_BAD_U_OP1_OP2;\n+\t\treturn TRUE;\n+\t      }\n+\t    else\n+\t      return FALSE;\n+\t  }\n+\telse if (op2 == 2)\n+\t  {\n+\t    if ((op1 == 0) || (op1 == 1))\n+\t      {\n+\t\t*undefined_code = UNDEF_BAD_OP1_OP2;\n+\t\treturn TRUE;\n+\t      }\n+\t    else\n+\t      return FALSE;\n+\t  }\n+\n+\treturn FALSE;\n+      }\n+\n+    case MVE_VMOV_GP_TO_VEC_LANE:\n+      if (arm_decode_field (given, 5, 6) == 2)\n+\t{\n+\t  unsigned long op1 = arm_decode_field (given, 21, 22);\n+\t  if ((op1 == 0) || (op1 == 1))\n+\t    {\n+\t      *undefined_code = UNDEF_BAD_OP1_OP2;\n+\t      return TRUE;\n+\t    }\n+\t  else\n+\t    return FALSE;\n+\t}\n+      else\n+\treturn FALSE;\n+\n+    case MVE_VMOV_IMM_TO_VEC:\n+      if (arm_decode_field (given, 5, 5) == 0)\n+      {\n+\tunsigned long cmode = arm_decode_field (given, 8, 11);\n+\n+\tif (((cmode & 9) == 1) || ((cmode & 5) == 1))\n+\t  {\n+\t    *undefined_code = UNDEF_OP_0_BAD_CMODE;\n+\t    return TRUE;\n+\t  }\n+\telse\n+\t  return FALSE;\n+      }\n+      else\n+\treturn FALSE;\n+\n     default:\n       return FALSE;\n     }\n@@ -4837,6 +5080,8 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n       else\n \treturn FALSE;\n \n+    case MVE_VMOV2_VEC_LANE_TO_GP:\n+    case MVE_VMOV2_GP_TO_VEC_LANE:\n     case MVE_VCVT_BETWEEN_FP_INT:\n     case MVE_VCVT_FROM_FP_TO_INT:\n       {\n@@ -4862,11 +5107,224 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \treturn FALSE;\n       }\n \n+    case MVE_VMOV_HFP_TO_GP:\n+    case MVE_VMOV_GP_TO_VEC_LANE:\n+    case MVE_VMOV_VEC_LANE_TO_GP:\n+      {\n+\tunsigned long rda = arm_decode_field (given, 12, 15);\n+\tif (rda == 0xd)\n+\t  {\n+\t    *unpredictable_code = UNPRED_R13;\n+\t    return TRUE;\n+\t  }\n+\telse if (rda == 0xf)\n+\t  {\n+\t    *unpredictable_code = UNPRED_R15;\n+\t    return TRUE;\n+\t  }\n+\n+\treturn FALSE;\n+      }\n+\n     default:\n       return FALSE;\n     }\n }\n \n+static void\n+print_mve_vmov_index (struct disassemble_info *info, unsigned long given)\n+{\n+  unsigned long op1 = arm_decode_field (given, 21, 22);\n+  unsigned long op2 = arm_decode_field (given, 5, 6);\n+  unsigned long h = arm_decode_field (given, 16, 16);\n+  unsigned long index, esize, targetBeat, idx;\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+\n+  if ((op1 & 0x2) == 0x2)\n+    {\n+      index = op2;\n+      esize = 8;\n+    }\n+  else if (((op1 & 0x2) == 0x0) && ((op2 & 0x1) == 0x1))\n+    {\n+      index = op2  >> 1;\n+      esize = 16;\n+    }\n+  else if (((op1 & 0x2) == 0) && ((op2 & 0x3) == 0))\n+    {\n+      index = 0;\n+      esize = 32;\n+    }\n+  else\n+    {\n+      func (stream, \"<undefined index>\");\n+      return;\n+    }\n+\n+  targetBeat =  (op1 & 0x1) | (h << 1);\n+  idx = index + targetBeat * (32/esize);\n+\n+  func (stream, \"%lu\", idx);\n+}\n+\n+/* Print neon and mve 8-bit immediate that can be a 8, 16, 32, or 64-bits\n+   in length and integer of floating-point type.  */\n+static void\n+print_simd_imm8 (struct disassemble_info *info, unsigned long given,\n+\t\t unsigned int ibit_loc, const struct mopcode32 *insn)\n+{\n+  int bits = 0;\n+  int cmode = (given >> 8) & 0xf;\n+  int op = (given >> 5) & 0x1;\n+  unsigned long value = 0, hival = 0;\n+  unsigned shift;\n+  int size = 0;\n+  int isfloat = 0;\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+\n+  /* On Neon the 'i' bit is at bit 24, on mve it is\n+     at bit 28.  */\n+  bits |= ((given >> ibit_loc) & 1) << 7;\n+  bits |= ((given >> 16) & 7) << 4;\n+  bits |= ((given >> 0) & 15) << 0;\n+\n+  if (cmode < 8)\n+    {\n+      shift = (cmode >> 1) & 3;\n+      value = (unsigned long) bits << (8 * shift);\n+      size = 32;\n+    }\n+  else if (cmode < 12)\n+    {\n+      shift = (cmode >> 1) & 1;\n+      value = (unsigned long) bits << (8 * shift);\n+      size = 16;\n+    }\n+  else if (cmode < 14)\n+    {\n+      shift = (cmode & 1) + 1;\n+      value = (unsigned long) bits << (8 * shift);\n+      value |= (1ul << (8 * shift)) - 1;\n+      size = 32;\n+    }\n+  else if (cmode == 14)\n+    {\n+      if (op)\n+\t{\n+\t  /* Bit replication into bytes.  */\n+\t  int ix;\n+\t  unsigned long mask;\n+\n+\t  value = 0;\n+\t  hival = 0;\n+\t  for (ix = 7; ix >= 0; ix--)\n+\t    {\n+\t      mask = ((bits >> ix) & 1) ? 0xff : 0;\n+\t      if (ix <= 3)\n+\t\tvalue = (value << 8) | mask;\n+\t      else\n+\t\thival = (hival << 8) | mask;\n+\t    }\n+\t  size = 64;\n+\t}\n+      else\n+\t{\n+\t  /* Byte replication.  */\n+\t  value = (unsigned long) bits;\n+\t  size = 8;\n+\t}\n+    }\n+  else if (!op)\n+    {\n+      /* Floating point encoding.  */\n+      int tmp;\n+\n+      value = (unsigned long)  (bits & 0x7f) << 19;\n+      value |= (unsigned long) (bits & 0x80) << 24;\n+      tmp = bits & 0x40 ? 0x3c : 0x40;\n+      value |= (unsigned long) tmp << 24;\n+      size = 32;\n+      isfloat = 1;\n+    }\n+  else\n+    {\n+      func (stream, \"<illegal constant %.8x:%x:%x>\",\n+\t    bits, cmode, op);\n+      size = 32;\n+      return;\n+    }\n+\n+  // printU determines whether the immediate value should be printed as\n+  // unsigned.\n+  unsigned printU = 0;\n+  switch (insn->mve_op)\n+    {\n+    default:\n+      break;\n+    // We want this for instructions that don't have a 'signed' type\n+    case MVE_VBIC_IMM:\n+    case MVE_VORR_IMM:\n+    case MVE_VMVN_IMM:\n+    case MVE_VMOV_IMM_TO_VEC:\n+      printU = 1;\n+      break;\n+    }\n+  switch (size)\n+    {\n+    case 8:\n+      func (stream, \"#%ld\\t; 0x%.2lx\", value, value);\n+      break;\n+\n+    case 16:\n+      func (stream,\n+\t    printU\n+\t    ? \"#%lu\\t; 0x%.4lx\"\n+\t    : \"#%ld\\t; 0x%.4lx\", value, value);\n+      break;\n+\n+    case 32:\n+      if (isfloat)\n+\t{\n+\t  unsigned char valbytes[4];\n+\t  double fvalue;\n+\n+\t  /* Do this a byte at a time so we don't have to\n+\t     worry about the host's endianness.  */\n+\t  valbytes[0] = value & 0xff;\n+\t  valbytes[1] = (value >> 8) & 0xff;\n+\t  valbytes[2] = (value >> 16) & 0xff;\n+\t  valbytes[3] = (value >> 24) & 0xff;\n+\n+\t  floatformat_to_double\n+\t    (& floatformat_ieee_single_little, valbytes,\n+\t     & fvalue);\n+\n+\t  func (stream, \"#%.7g\\t; 0x%.8lx\", fvalue,\n+\t\tvalue);\n+\t}\n+      else\n+\tfunc (stream,\n+\t      printU\n+\t      ? \"#%lu\\t; 0x%.8lx\"\n+\t      : \"#%ld\\t; 0x%.8lx\",\n+\t      (long) (((value & 0x80000000L) != 0)\n+\t\t      && !printU\n+\t\t      ? value | ~0xffffffffL : value),\n+\t      value);\n+      break;\n+\n+    case 64:\n+      func (stream, \"#0x%.8lx%.8lx\", hival, value);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+}\n+\n static void\n print_mve_undefined (struct disassemble_info *info,\n \t\t     enum mve_undefined undefined_code)\n@@ -4882,6 +5340,10 @@ print_mve_undefined (struct disassemble_info *info,\n       func (stream, \"size equals zero\");\n       break;\n \n+    case UNDEF_SIZE_2:\n+      func (stream, \"size equals two\");\n+      break;\n+\n     case UNDEF_SIZE_3:\n       func (stream, \"size equals three\");\n       break;\n@@ -4918,6 +5380,18 @@ print_mve_undefined (struct disassemble_info *info,\n       func (stream, \"fsi = 0 and invalid imm6\");\n       break;\n \n+    case UNDEF_BAD_OP1_OP2:\n+      func (stream, \"bad size with op2 = 2 and op1 = 0 or 1\");\n+      break;\n+\n+    case UNDEF_BAD_U_OP1_OP2:\n+      func (stream, \"unsigned with op2 = 0 and op1 = 0 or 1\");\n+      break;\n+\n+    case UNDEF_OP_0_BAD_CMODE:\n+      func (stream, \"op field equal 0 and bad cmode\");\n+      break;\n+\n     case UNDEF_NONE:\n       break;\n     }\n@@ -4976,6 +5450,14 @@ print_mve_unpredictable (struct disassemble_info *info,\n       func (stream, \"same general-purpose register used for both operands\");\n       break;\n \n+    case UNPRED_Q_REGS_EQ_AND_SIZE_1:\n+      func (stream, \"use of identical q registers and size = 1\");\n+      break;\n+\n+    case UNPRED_Q_REGS_EQ_AND_SIZE_2:\n+      func (stream, \"use of identical q registers and size = 1\");\n+      break;\n+\n     case UNPRED_NONE:\n       break;\n     }\n@@ -5339,6 +5821,88 @@ print_mve_size (struct disassemble_info *info,\n \t}\n       break;\n \n+    case MVE_VMOV_GP_TO_VEC_LANE:\n+    case MVE_VMOV_VEC_LANE_TO_GP:\n+      switch (size)\n+\t{\n+\tcase 0: case 4:\n+\t  func (stream, \"32\");\n+\t  break;\n+\n+\tcase 1: case 3:\n+\tcase 5: case 7:\n+\t  func (stream, \"16\");\n+\t  break;\n+\n+\tcase 8: case 9: case 10: case 11:\n+\tcase 12: case 13: case 14: case 15:\n+\t  func (stream, \"8\");\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n+    case MVE_VMOV_IMM_TO_VEC:\n+      switch (size)\n+\t{\n+\tcase 0: case 4: case 8:\n+\tcase 12: case 24: case 26:\n+\t  func (stream, \"i32\");\n+\t  break;\n+\tcase 16: case 20:\n+\t  func (stream, \"i16\");\n+\t  break;\n+\tcase 28:\n+\t  func (stream, \"i8\");\n+\t  break;\n+\tcase 29:\n+\t  func (stream, \"i64\");\n+\t  break;\n+\tcase 30:\n+\t  func (stream, \"f32\");\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n+    case MVE_VMVN_IMM:\n+      switch (size)\n+\t{\n+\tcase 0: case 2: case 4:\n+\tcase 6: case 12: case 13:\n+\t  func (stream, \"32\");\n+\t  break;\n+\n+\tcase 8: case 10:\n+\t  func (stream, \"16\");\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n+    case MVE_VBIC_IMM:\n+    case MVE_VORR_IMM:\n+      switch (size)\n+\t{\n+\tcase 1: case 3:\n+\tcase 5: case 7:\n+\t  func (stream, \"32\");\n+\t  break;\n+\n+\tcase 9: case 11:\n+\t  func (stream, \"16\");\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n     default:\n       break;\n     }\n@@ -5563,7 +6127,6 @@ print_insn_coprocessor (bfd_vma pc,\n \t   don't let it match here.  */\n \tcontinue;\n \n-\n       for (c = insn->assembler; *c; c++)\n \t{\n \t  if (*c == '%')\n@@ -6830,10 +7393,30 @@ print_insn_mve (struct disassemble_info *info, long given)\n \n \t\t    case 'u':\n \t\t      {\n-\t\t\tif (arm_decode_field (given, 28, 28) == 0)\n-\t\t\t  func (stream, \"s\");\n+\t\t\tunsigned long op1 = arm_decode_field (given, 21, 22);\n+\n+\t\t\tif ((insn->mve_op == MVE_VMOV_VEC_LANE_TO_GP))\n+\t\t\t  {\n+\t\t\t    /* Check for signed.  */\n+\t\t\t    if (arm_decode_field (given, 23, 23) == 0)\n+\t\t\t      {\n+\t\t\t\t/* We don't print 's' for S32.  */\n+\t\t\t\tif ((arm_decode_field (given, 5, 6) == 0)\n+\t\t\t\t    && ((op1 == 0) || (op1 == 1)))\n+\t\t\t\t  ;\n+\t\t\t\telse\n+\t\t\t\t  func (stream, \"s\");\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      func (stream, \"u\");\n+\t\t\t  }\n \t\t\telse\n-\t\t\t  func (stream, \"u\");\n+\t\t\t  {\n+\t\t\t    if (arm_decode_field (given, 28, 28) == 0)\n+\t\t\t      func (stream, \"s\");\n+\t\t\t    else\n+\t\t\t      func (stream, \"u\");\n+\t\t\t  }\n \t\t      }\n \t\t      break;\n \n@@ -6850,6 +7433,16 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t\t      print_mve_register_blocks (info, given, insn->mve_op);\n \t\t      break;\n \n+\t\t    case 'E':\n+\t\t      /* SIMD encoded constant for mov, mvn, vorr, vbic.  */\n+\n+\t\t      print_simd_imm8 (info, given, 28, insn);\n+\t\t      break;\n+\n+\t\t    case 'N':\n+\t\t      print_mve_vmov_index (info, given);\n+\t\t      break;\n+\n \t\t    case '0': case '1': case '2': case '3': case '4':\n \t\t    case '5': case '6': case '7': case '8': case '9':\n \t\t      {\n@@ -6907,12 +7500,18 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t\t\t    func (stream, \"%ld\", value);\n \t\t\t    value_in_comment = value;\n \t\t\t    break;\n+\t\t\t  case 'F':\n+\t\t\t    func (stream, \"s%ld\", value);\n+\t\t\t    break;\n \t\t\t  case 'Q':\n \t\t\t    if (value & 0x8)\n \t\t\t      func (stream, \"<illegal reg q%ld.5>\", value);\n \t\t\t    else\n \t\t\t      func (stream, \"q%ld\", value);\n \t\t\t    break;\n+\t\t\t  case 'x':\n+\t\t\t    func (stream, \"0x%08lx\", value);\n+\t\t\t    break;\n \t\t\t  default:\n \t\t\t    abort ();\n \t\t\t  }"
    }
  ]
}