{
  "sha": "844a72efbced876d079b7a152fcab05f3ad72c5a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODQ0YTcyZWZiY2VkODc2ZDA3OWI3YTE1MmZjYWIwNWYzYWQ3MmM1YQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-05-28T22:25:32Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-07-05T18:23:41Z"
    },
    "message": "Simplify gdb_index writing\n\nwrite_gdbindex writes the CUs first, then walks the signatured type\nhash table to write out the TUs.  However, now that CUs and TUs are\nunified in the DWARF reader, it's simpler to handle both of these in\nthe same loop.",
    "tree": {
      "sha": "fdf461b1e4a2bbdf80e1b6b66726452292ef8be2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fdf461b1e4a2bbdf80e1b6b66726452292ef8be2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/844a72efbced876d079b7a152fcab05f3ad72c5a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/844a72efbced876d079b7a152fcab05f3ad72c5a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/844a72efbced876d079b7a152fcab05f3ad72c5a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/844a72efbced876d079b7a152fcab05f3ad72c5a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "870c2204a2b69bfeaa298a280e450d20cbfeb890",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/870c2204a2b69bfeaa298a280e450d20cbfeb890",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/870c2204a2b69bfeaa298a280e450d20cbfeb890"
    }
  ],
  "stats": {
    "total": 84,
    "additions": 24,
    "deletions": 60
  },
  "files": [
    {
      "sha": "0eb43c3f907b4f7d410dc5bc629ba64997a28aed",
      "filename": "gdb/dwarf2/index-write.c",
      "status": "modified",
      "additions": 24,
      "deletions": 60,
      "changes": 84,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/844a72efbced876d079b7a152fcab05f3ad72c5a/gdb/dwarf2/index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/844a72efbced876d079b7a152fcab05f3ad72c5a/gdb/dwarf2/index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-write.c?ref=844a72efbced876d079b7a152fcab05f3ad72c5a",
      "patch": "@@ -601,43 +601,6 @@ struct signatured_type_index_data\n   int cu_index;\n };\n \n-/* A helper function that writes a single signatured_type to an\n-   obstack.  */\n-\n-static int\n-write_one_signatured_type (void **slot, void *d)\n-{\n-  struct signatured_type_index_data *info\n-    = (struct signatured_type_index_data *) d;\n-  struct signatured_type *entry = (struct signatured_type *) *slot;\n-  partial_symtab *psymtab = entry->v.psymtab;\n-\n-  if (psymtab == nullptr)\n-    {\n-      /* We can end up here when processing a skeleton CU referring to a\n-\t .dwo file that hasn't been found.  There's not much we can do in\n-\t such a case, so skip this CU.  */\n-      return 1;\n-    }\n-\n-  write_psymbols (info->symtab, info->psyms_seen,\n-\t\t  psymtab->global_psymbols, info->cu_index,\n-\t\t  0);\n-  write_psymbols (info->symtab, info->psyms_seen,\n-\t\t  psymtab->static_psymbols, info->cu_index,\n-\t\t  1);\n-\n-  info->types_list.append_uint (8, BFD_ENDIAN_LITTLE,\n-\t\t\t\tto_underlying (entry->sect_off));\n-  info->types_list.append_uint (8, BFD_ENDIAN_LITTLE,\n-\t\t\t\tto_underlying (entry->type_offset_in_tu));\n-  info->types_list.append_uint (8, BFD_ENDIAN_LITTLE, entry->signature);\n-\n-  ++info->cu_index;\n-\n-  return 1;\n-}\n-\n /* Recurse into all \"included\" dependencies and count their symbols as\n    if they appeared in this psymtab.  */\n \n@@ -1421,61 +1384,62 @@ write_gdbindex (dwarf2_per_objfile *per_objfile, FILE *out_file,\n   psym_index_map cu_index_htab;\n   cu_index_htab.reserve (per_objfile->per_bfd->all_comp_units.size ());\n \n+  /* Store out the .debug_type CUs, if any.  */\n+  data_buf types_cu_list;\n+\n   /* The CU list is already sorted, so we don't need to do additional\n      work here.  Also, the debug_types entries do not appear in\n      all_comp_units, but only in their own hash table.  */\n \n   std::unordered_set<partial_symbol *> psyms_seen\n     (psyms_seen_size (per_objfile));\n   int counter = 0;\n+  int types_counter = 0;\n   for (int i = 0; i < per_objfile->per_bfd->all_comp_units.size (); ++i)\n     {\n       dwarf2_per_cu_data *per_cu\n \t= per_objfile->per_bfd->all_comp_units[i].get ();\n-      if (per_cu->is_debug_types)\n-\tcontinue;\n-\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n+      int &this_counter = per_cu->is_debug_types ? types_counter : counter;\n+\n       if (psymtab != NULL)\n \t{\n \t  if (psymtab->user == NULL)\n \t    recursively_write_psymbols (objfile, psymtab, &symtab,\n-\t\t\t\t\tpsyms_seen, counter);\n+\t\t\t\t\tpsyms_seen, this_counter);\n \n-\t  const auto insertpair = cu_index_htab.emplace (psymtab, counter);\n+\t  const auto insertpair = cu_index_htab.emplace (psymtab,\n+\t\t\t\t\t\t\t this_counter);\n \t  gdb_assert (insertpair.second);\n \t}\n \n       /* The all_comp_units list contains CUs read from the objfile as well as\n \t from the eventual dwz file.  We need to place the entry in the\n \t corresponding index.  */\n-      data_buf &cu_list = per_cu->is_dwz ? dwz_cu_list : objfile_cu_list;\n+      data_buf &cu_list = (per_cu->is_debug_types\n+\t\t\t   ? types_cu_list\n+\t\t\t   : per_cu->is_dwz ? dwz_cu_list : objfile_cu_list);\n       cu_list.append_uint (8, BFD_ENDIAN_LITTLE,\n \t\t\t   to_underlying (per_cu->sect_off));\n-      cu_list.append_uint (8, BFD_ENDIAN_LITTLE, per_cu->length);\n-      ++counter;\n+      if (per_cu->is_debug_types)\n+\t{\n+\t  signatured_type *sig_type = (signatured_type *) per_cu;\n+\t  cu_list.append_uint (8, BFD_ENDIAN_LITTLE,\n+\t\t\t       to_underlying (sig_type->type_offset_in_tu));\n+\t  cu_list.append_uint (8, BFD_ENDIAN_LITTLE,\n+\t\t\t       sig_type->signature);\n+\t}\n+      else\n+\tcu_list.append_uint (8, BFD_ENDIAN_LITTLE, per_cu->length);\n+\n+      ++this_counter;\n     }\n \n   /* Dump the address map.  */\n   data_buf addr_vec;\n   write_address_map (per_objfile->per_bfd, addr_vec, cu_index_htab);\n \n-  /* Write out the .debug_type entries, if any.  */\n-  data_buf types_cu_list;\n-  if (per_objfile->per_bfd->signatured_types)\n-    {\n-      signatured_type_index_data sig_data (types_cu_list,\n-\t\t\t\t\t   psyms_seen);\n-\n-      sig_data.objfile = objfile;\n-      sig_data.symtab = &symtab;\n-      sig_data.cu_index = (per_objfile->per_bfd->all_comp_units.size ()\n-\t\t\t   - per_objfile->per_bfd->tu_stats.nr_tus);\n-      htab_traverse_noresize (per_objfile->per_bfd->signatured_types.get (),\n-\t\t\t      write_one_signatured_type, &sig_data);\n-    }\n-\n   /* Now that we've processed all symbols we can shrink their cu_indices\n      lists.  */\n   uniquify_cu_indices (&symtab);"
    }
  ]
}