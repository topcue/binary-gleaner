{
  "sha": "0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGM5NTFjMjVjNmM3Y2ZiZjBmMzk5ZDM0Mjc3ZjczYjBmZGZjMThjZA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-06-27T00:05:15Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-07-13T00:27:50Z"
    },
    "message": "[GOLD] PowerPC R_PPC64_PCREL_OPT support\n\n\t* powerpc.cc (xlate_pcrel_opt): New function.\n\t(Target_powerpc::Relocate::relocate): Optimise PCREL34 and\n\tGOT_PCREL34 sequences marked with PCREL_OPT.",
    "tree": {
      "sha": "2f0e971ecacf5a9364ad11bb69619871c021869e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2f0e971ecacf5a9364ad11bb69619871c021869e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c9b8abb7af46c9da4b50ad8495ab2824c4125962",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c9b8abb7af46c9da4b50ad8495ab2824c4125962",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c9b8abb7af46c9da4b50ad8495ab2824c4125962"
    }
  ],
  "stats": {
    "total": 189,
    "additions": 177,
    "deletions": 12
  },
  "files": [
    {
      "sha": "67f908885dd94a86185e24e1bfed17bc090a7f52",
      "filename": "gold/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd/gold/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd/gold/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/ChangeLog?ref=0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd",
      "patch": "@@ -1,3 +1,9 @@\n+2019-07-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* powerpc.cc (xlate_pcrel_opt): New function.\n+\t(Target_powerpc::Relocate::relocate): Optimise PCREL34 and\n+\tGOT_PCREL34 sequences marked with PCREL_OPT.\n+\n 2019-07-13  Alan Modra  <amodra@gmail.com>\n \n \t* powerpc.cc (Powerpc_relobj::make_got_relative): New function."
    },
    {
      "sha": "688f7243d328120fcd6f05919ed8d02be6049770",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 171,
      "deletions": 12,
      "changes": 183,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=0c951c25c6c7cfbf0f399d34277f73b0fdfc18cd",
      "patch": "@@ -9716,6 +9716,114 @@ relative_value_is_known(const Symbol_value<size>* psymval)\n   return is_ordinary && shndx != elfcpp::SHN_UNDEF;\n }\n \n+// PCREL_OPT in one instance flags to the linker that a pair of insns:\n+//   pld ra,symbol@got@pcrel\n+//   load/store rt,0(ra)\n+// or\n+//   pla ra,symbol@pcrel\n+//   load/store rt,0(ra)\n+// may be translated to\n+//   pload/pstore rt,symbol@pcrel\n+//   nop.\n+// This function returns true if the optimization is possible, placing\n+// the prefix insn in *PINSN1 and a NOP in *PINSN2.\n+//\n+// On entry to this function, the linker has already determined that\n+// the pld can be replaced with pla: *PINSN1 is that pla insn,\n+// while *PINSN2 is the second instruction.\n+\n+inline bool\n+xlate_pcrel_opt(uint64_t *pinsn1, uint64_t *pinsn2)\n+{\n+  uint32_t insn2 = *pinsn2 >> 32;\n+  uint64_t i1new;\n+\n+  // Check that regs match.\n+  if (((insn2 >> 16) & 31) != ((*pinsn1 >> 21) & 31))\n+    return false;\n+\n+  switch ((insn2 >> 26) & 63)\n+    {\n+    default:\n+      return false;\n+\n+    case 32: // lwz\n+    case 34: // lbz\n+    case 36: // stw\n+    case 38: // stb\n+    case 40: // lhz\n+    case 42: // lha\n+    case 44: // sth\n+    case 48: // lfs\n+    case 50: // lfd\n+    case 52: // stfs\n+    case 54: // stfd\n+      // These are the PMLS cases, where we just need to tack a prefix\n+      // on the insn.  Check that the D field is zero.\n+      if ((insn2 & 0xffff) != 0)\n+\treturn false;\n+      i1new = ((1ULL << 58) | (2ULL << 56) | (1ULL << 52)\n+\t       | (insn2 & ((63ULL << 26) | (31ULL << 21))));\n+      break;\n+\n+    case 58: // lwa, ld\n+      if ((insn2 & 0xfffd) != 0)\n+\treturn false;\n+      i1new = ((1ULL << 58) | (1ULL << 52)\n+\t       | (insn2 & 2 ? 41ULL << 26 : 57ULL << 26)\n+\t       | (insn2 & (31ULL << 21)));\n+      break;\n+\n+    case 57: // lxsd, lxssp\n+      if ((insn2 & 0xfffc) != 0 || (insn2 & 3) < 2)\n+\treturn false;\n+      i1new = ((1ULL << 58) | (1ULL << 52)\n+\t       | ((40ULL | (insn2 & 3)) << 26)\n+\t       | (insn2 & (31ULL << 21)));\n+      break;\n+\n+    case 61: // stxsd, stxssp, lxv, stxv\n+      if ((insn2 & 3) == 0)\n+\treturn false;\n+      else if ((insn2 & 3) >= 2)\n+\t{\n+\t  if ((insn2 & 0xfffc) != 0)\n+\t    return false;\n+\t  i1new = ((1ULL << 58) | (1ULL << 52)\n+\t\t   | ((44ULL | (insn2 & 3)) << 26)\n+\t\t   | (insn2 & (31ULL << 21)));\n+\t}\n+      else\n+\t{\n+\t  if ((insn2 & 0xfff0) != 0)\n+\t    return false;\n+\t  i1new = ((1ULL << 58) | (1ULL << 52)\n+\t\t   | ((50ULL | (insn2 & 4) | ((insn2 & 8) >> 3)) << 26)\n+\t\t   | (insn2 & (31ULL << 21)));\n+\t}\n+      break;\n+\n+    case 56: // lq\n+      if ((insn2 & 0xffff) != 0)\n+\treturn false;\n+      i1new = ((1ULL << 58) | (1ULL << 52)\n+\t       | (insn2 & ((63ULL << 26) | (31ULL << 21))));\n+      break;\n+\n+    case 62: // std, stq\n+      if ((insn2 & 0xfffd) != 0)\n+\treturn false;\n+      i1new = ((1ULL << 58) | (1ULL << 52)\n+\t       | ((insn2 & 2) == 0 ? 61ULL << 26 : 60ULL << 26)\n+\t       | (insn2 & (31ULL << 21)));\n+      break;\n+    }\n+\n+  *pinsn1 = i1new;\n+  *pinsn2 = (uint64_t) nop << 32;\n+  return true;\n+}\n+\n // Perform a relocation.\n \n template<int size, bool big_endian>\n@@ -10507,6 +10615,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t  ? relative_value_is_known(gsym)\n \t  : relative_value_is_known(psymval)))\n     {\n+      Insn* iview;\n+      Insn* iview2;\n+      Insn insn;\n+      uint64_t pinsn, pinsn2;\n+\n       switch (r_type)\n \t{\n \tdefault:\n@@ -10527,8 +10640,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \tcase elfcpp::R_PPC64_TOC16_HA:\n \t  if (parameters->options().toc_optimize())\n \t    {\n-\t      Insn* iview = reinterpret_cast<Insn*>(view - d_offset);\n-\t      Insn insn = elfcpp::Swap<32, big_endian>::readval(iview);\n+\t      iview = reinterpret_cast<Insn*>(view - d_offset);\n+\t      insn = elfcpp::Swap<32, big_endian>::readval(iview);\n \t      if ((r_type == elfcpp::R_PPC64_TOC16_HA\n \t\t   && object->make_toc_relative(target, &value))\n \t\t  || (r_type == elfcpp::R_POWERPC_GOT16_HA\n@@ -10559,8 +10672,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \tcase elfcpp::R_PPC64_TOC16_LO_DS:\n \t  if (parameters->options().toc_optimize())\n \t    {\n-\t      Insn* iview = reinterpret_cast<Insn*>(view - d_offset);\n-\t      Insn insn = elfcpp::Swap<32, big_endian>::readval(iview);\n+\t      iview = reinterpret_cast<Insn*>(view - d_offset);\n+\t      insn = elfcpp::Swap<32, big_endian>::readval(iview);\n \t      bool changed = false;\n \t      if ((r_type == elfcpp::R_PPC64_TOC16_LO_DS\n \t\t   && object->make_toc_relative(target, &value))\n@@ -10598,11 +10711,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \tcase elfcpp::R_PPC64_GOT_PCREL34:\n \t  if (parameters->options().toc_optimize())\n \t    {\n-\t      Insn* iview = reinterpret_cast<Insn*>(view);\n-\t      uint64_t insn = elfcpp::Swap<32, big_endian>::readval(iview);\n-\t      insn <<= 32;\n-\t      insn |= elfcpp::Swap<32, big_endian>::readval(iview + 1);\n-\t      if ((insn & ((-1ULL << 50) | (63ULL << 26)))\n+\t      iview = reinterpret_cast<Insn*>(view);\n+\t      pinsn = elfcpp::Swap<32, big_endian>::readval(iview);\n+\t      pinsn <<= 32;\n+\t      pinsn |= elfcpp::Swap<32, big_endian>::readval(iview + 1);\n+\t      if ((pinsn & ((-1ULL << 50) | (63ULL << 26)))\n \t\t   != ((1ULL << 58) | (1ULL << 52) | (57ULL << 26) /* pld */))\n \t\tbreak;\n \n@@ -10612,14 +10725,60 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t\t{\n \t\t  value = relval;\n \t\t  // Replace with paddi\n-\t\t  insn += (2ULL << 56) + (14ULL << 26) - (57ULL << 26);\n-\t\t  elfcpp::Swap<32, big_endian>::writeval(iview, insn >> 32);\n+\t\t  pinsn += (2ULL << 56) + (14ULL << 26) - (57ULL << 26);\n+\t\t  elfcpp::Swap<32, big_endian>::writeval(iview, pinsn >> 32);\n \t\t  elfcpp::Swap<32, big_endian>::writeval(iview + 1,\n-\t\t\t\t\t\t\t insn & 0xffffffff);\n+\t\t\t\t\t\t\t pinsn & 0xffffffff);\n+\t\t  goto pcrelopt;\n \t\t}\n \t    }\n \t  break;\n \n+\tcase elfcpp::R_PPC64_PCREL34:\n+\t  {\n+\t    iview = reinterpret_cast<Insn*>(view);\n+\t    pinsn = elfcpp::Swap<32, big_endian>::readval(iview);\n+\t    pinsn <<= 32;\n+\t    pinsn |= elfcpp::Swap<32, big_endian>::readval(iview + 1);\n+\t    if ((pinsn & ((-1ULL << 50) | (63ULL << 26)))\n+\t\t!= ((1ULL << 58) | (2ULL << 56) | (1ULL << 52)\n+\t\t    | (14ULL << 26) /* paddi */))\n+\t      break;\n+\n+\t  pcrelopt:\n+\t    const int reloc_size = elfcpp::Elf_sizes<size>::rela_size;\n+\t    elfcpp::Shdr<size, big_endian> shdr(relinfo->reloc_shdr);\n+\t    size_t reloc_count = shdr.get_sh_size() / reloc_size;\n+\t    if (relnum >= reloc_count - 1)\n+\t      break;\n+\n+\t    Reltype next_rela(preloc + reloc_size);\n+\t    if ((elfcpp::elf_r_type<size>(next_rela.get_r_info())\n+\t\t != elfcpp::R_PPC64_PCREL_OPT)\n+\t\t|| next_rela.get_r_offset() != rela.get_r_offset())\n+\t      break;\n+\n+\t    Address off = next_rela.get_r_addend();\n+\t    if (off == 0)\n+\t      off = 8; // zero means next insn.\n+\t    if (off + rela.get_r_offset() + 4 > view_size)\n+\t      break;\n+\n+\t    iview2 = reinterpret_cast<Insn*>(view + off);\n+\t    pinsn2 = elfcpp::Swap<32, big_endian>::readval(iview2);\n+\t    pinsn2 <<= 32;\n+\t    if ((pinsn2 & (63ULL << 58)) == 1ULL << 58)\n+\t      break;\n+\t    if (xlate_pcrel_opt(&pinsn, &pinsn2))\n+\t      {\n+\t\telfcpp::Swap<32, big_endian>::writeval(iview, pinsn >> 32);\n+\t\telfcpp::Swap<32, big_endian>::writeval(iview + 1,\n+\t\t\t\t\t\t       pinsn & 0xffffffff);\n+\t\telfcpp::Swap<32, big_endian>::writeval(iview2, pinsn2 >> 32);\n+\t      }\n+\t  }\n+\t  break;\n+\n \tcase elfcpp::R_POWERPC_TPREL16_HA:\n \t  if (parameters->options().tls_optimize() && value + 0x8000 < 0x10000)\n \t    {"
    }
  ]
}