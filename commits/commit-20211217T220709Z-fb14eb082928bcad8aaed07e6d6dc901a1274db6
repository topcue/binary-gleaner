{
  "sha": "fb14eb082928bcad8aaed07e6d6dc901a1274db6",
  "node_id": "C_kwDOANOeidoAKGZiMTRlYjA4MjkyOGJjYWQ4YWFlZDA3ZTZkNmRjOTAxYTEyNzRkYjY",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-15T21:38:30Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-17T22:07:09Z"
    },
    "message": "Remove gdbarch.sh\n\nThis patch runs gdbarch.py and removes gdbarch.sh.",
    "tree": {
      "sha": "fdf140956a096cbbb90f8026d316b8c1cbf8d6cf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fdf140956a096cbbb90f8026d316b8c1cbf8d6cf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fb14eb082928bcad8aaed07e6d6dc901a1274db6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fb14eb082928bcad8aaed07e6d6dc901a1274db6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fb14eb082928bcad8aaed07e6d6dc901a1274db6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fb14eb082928bcad8aaed07e6d6dc901a1274db6/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb"
    }
  ],
  "stats": {
    "total": 1945,
    "additions": 66,
    "deletions": 1879
  },
  "files": [
    {
      "sha": "7d4b83ad12a1ec27a941edb862ae0f5ea6772544",
      "filename": "gdb/gdbarch-gen.h",
      "status": "modified",
      "additions": 64,
      "deletions": 64,
      "changes": 128,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fb14eb082928bcad8aaed07e6d6dc901a1274db6/gdb/gdbarch-gen.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fb14eb082928bcad8aaed07e6d6dc901a1274db6/gdb/gdbarch-gen.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch-gen.h?ref=fb14eb082928bcad8aaed07e6d6dc901a1274db6",
      "patch": "@@ -20,7 +20,7 @@\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n-/* This file was created with the aid of ``gdbarch.sh''.  */\n+/* This file was created with the aid of ``gdbarch.py''.  */\n \n \n \n@@ -124,11 +124,11 @@ extern void set_gdbarch_floatformat_for_type (struct gdbarch *gdbarch, gdbarch_f\n    address in GDB have the same size and \"look the same\".  For such a\n    target, you need only set gdbarch_ptr_bit and gdbarch_addr_bit\n    / addr_bit will be set from it.\n-  \n+\n    If gdbarch_ptr_bit and gdbarch_addr_bit are different, you'll probably\n    also need to set gdbarch_dwarf2_addr_size, gdbarch_pointer_to_address and\n    gdbarch_address_to_pointer as well.\n-  \n+\n    ptr_bit is the size of a pointer on the target */\n \n extern int gdbarch_ptr_bit (struct gdbarch *gdbarch);\n@@ -145,10 +145,10 @@ extern void set_gdbarch_addr_bit (struct gdbarch *gdbarch, int addr_bit);\n    DWARF2_ADDR_SIZE as defined by the target specific GCC back-end.\n    Unfortunately there is no good way to determine this value.  Therefore\n    dwarf2_addr_size simply defaults to the target pointer size.\n-  \n+\n    dwarf2_addr_size is not used for .eh_frame FDEs, which are generally\n    defined using the target's pointer size so far.\n-  \n+\n    Note that dwarf2_addr_size only needs to be redefined by a target if the\n    GCC back-end defines a DWARF2_ADDR_SIZE other than the target pointer size,\n    and if Dwarf versions < 4 need to be supported. */\n@@ -371,7 +371,7 @@ extern void set_gdbarch_cannot_store_register (struct gdbarch *gdbarch, gdbarch_\n \n /* Determine the address where a longjmp will land and save this address\n    in PC.  Return nonzero on success.\n-  \n+\n    FRAME corresponds to the longjmp frame. */\n \n extern bool gdbarch_get_longjmp_target_p (struct gdbarch *gdbarch);\n@@ -421,9 +421,9 @@ extern void set_gdbarch_integer_to_address (struct gdbarch *gdbarch, gdbarch_int\n /* Return the return-value convention that will be used by FUNCTION\n    to return a value of type VALTYPE.  FUNCTION may be NULL in which\n    case the return convention is computed based only on VALTYPE.\n-  \n+\n    If READBUF is not NULL, extract the return value and save it in this buffer.\n-  \n+\n    If WRITEBUF is not NULL, it contains a return value which will be\n    stored into the appropriate register.  This can be used when we want\n    to force the value returned by a function (see the \"return\" command\n@@ -663,10 +663,10 @@ extern void set_gdbarch_memtag_granule_size (struct gdbarch *gdbarch, CORE_ADDR\n /* FIXME/cagney/2001-01-18: This should be split in two.  A target method that\n    indicates if the target needs software single step.  An ISA method to\n    implement it.\n-  \n+\n    FIXME/cagney/2001-01-18: The logic is backwards.  It should be asking if the\n    target can single step.  If not, then implement single step using breakpoints.\n-  \n+\n    Return a vector of addresses on which the software single step\n    breakpoints should be inserted.  NULL means software single step is\n    not used.\n@@ -956,24 +956,24 @@ extern void set_gdbarch_max_insn_length (struct gdbarch *gdbarch, ULONGEST max_i\n \n /* Copy the instruction at FROM to TO, and make any adjustments\n    necessary to single-step it at that address.\n-  \n+\n    REGS holds the state the thread's registers will have before\n    executing the copied instruction; the PC in REGS will refer to FROM,\n    not the copy at TO.  The caller should update it to point at TO later.\n-  \n+\n    Return a pointer to data of the architecture's choice to be passed\n    to gdbarch_displaced_step_fixup.\n-  \n+\n    For a general explanation of displaced stepping and how GDB uses it,\n    see the comments in infrun.c.\n-  \n+\n    The TO area is only guaranteed to have space for\n    gdbarch_max_insn_length (arch) bytes, so this function must not\n    write more bytes than that to that area.\n-  \n+\n    If you do not provide this function, GDB assumes that the\n    architecture does not support displaced stepping.\n-  \n+\n    If the instruction cannot execute out of line, return NULL.  The\n    core falls back to stepping past the instruction in-line instead in\n    that case. */\n@@ -989,7 +989,7 @@ extern void set_gdbarch_displaced_step_copy_insn (struct gdbarch *gdbarch, gdbar\n    displaced instruction location, and it is up to the target to ensure GDB will\n    receive control again (e.g. by placing a software breakpoint instruction into\n    the displaced instruction buffer).\n-  \n+\n    The default implementation returns false on all targets that provide a\n    gdbarch_software_single_step routine, and true otherwise. */\n \n@@ -1000,17 +1000,17 @@ extern void set_gdbarch_displaced_step_hw_singlestep (struct gdbarch *gdbarch, g\n /* Fix up the state resulting from successfully single-stepping a\n    displaced instruction, to give the result we would have gotten from\n    stepping the instruction in its original location.\n-  \n+\n    REGS is the register state resulting from single-stepping the\n    displaced instruction.\n-  \n+\n    CLOSURE is the result from the matching call to\n    gdbarch_displaced_step_copy_insn.\n-  \n+\n    If you provide gdbarch_displaced_step_copy_insn.but not this\n    function, then GDB assumes that no fixup is needed after\n    single-stepping the instruction.\n-  \n+\n    For a general explanation of displaced stepping and how GDB uses it,\n    see the comments in infrun.c. */\n \n@@ -1021,7 +1021,7 @@ extern void gdbarch_displaced_step_fixup (struct gdbarch *gdbarch, struct displa\n extern void set_gdbarch_displaced_step_fixup (struct gdbarch *gdbarch, gdbarch_displaced_step_fixup_ftype *displaced_step_fixup);\n \n /* Prepare THREAD for it to displaced step the instruction at its current PC.\n-  \n+\n    Throw an exception if any unexpected error happens. */\n \n extern bool gdbarch_displaced_step_prepare_p (struct gdbarch *gdbarch);\n@@ -1137,7 +1137,7 @@ extern int gdbarch_gdb_signal_to_target (struct gdbarch *gdbarch, enum gdb_signa\n extern void set_gdbarch_gdb_signal_to_target (struct gdbarch *gdbarch, gdbarch_gdb_signal_to_target_ftype *gdb_signal_to_target);\n \n /* Extra signal info inspection.\n-  \n+\n    Return a type suitable to inspect extra signal information. */\n \n extern bool gdbarch_get_siginfo_type_p (struct gdbarch *gdbarch);\n@@ -1177,9 +1177,9 @@ extern void set_gdbarch_syscalls_info (struct gdbarch *gdbarch, struct syscalls_\n    A NULL-terminated array of prefixes used to mark an integer constant\n    on the architecture's assembly.\n    For example, on x86 integer constants are written as:\n-  \n-    $10 ;; integer constant 10\n-  \n+\n+   $10 ;; integer constant 10\n+\n    in this case, this prefix would be the character `$'. */\n \n extern const char *const * gdbarch_stap_integer_prefixes (struct gdbarch *gdbarch);\n@@ -1194,9 +1194,9 @@ extern void set_gdbarch_stap_integer_suffixes (struct gdbarch *gdbarch, const ch\n /* A NULL-terminated array of prefixes used to mark a register name on\n    the architecture's assembly.\n    For example, on x86 the register name is written as:\n-  \n-    %eax ;; register eax\n-  \n+\n+   %eax ;; register eax\n+\n    in this case, this prefix would be the character `%'. */\n \n extern const char *const * gdbarch_stap_register_prefixes (struct gdbarch *gdbarch);\n@@ -1211,11 +1211,11 @@ extern void set_gdbarch_stap_register_suffixes (struct gdbarch *gdbarch, const c\n /* A NULL-terminated array of prefixes used to mark a register\n    indirection on the architecture's assembly.\n    For example, on x86 the register indirection is written as:\n-  \n-    (%eax) ;; indirecting eax\n-  \n+\n+   (%eax) ;; indirecting eax\n+\n    in this case, this prefix would be the charater `('.\n-  \n+\n    Please note that we use the indirection prefix also for register\n    displacement, e.g., `4(%eax)' on x86. */\n \n@@ -1225,19 +1225,19 @@ extern void set_gdbarch_stap_register_indirection_prefixes (struct gdbarch *gdba\n /* A NULL-terminated array of suffixes used to mark a register\n    indirection on the architecture's assembly.\n    For example, on x86 the register indirection is written as:\n-  \n-    (%eax) ;; indirecting eax\n-  \n+\n+   (%eax) ;; indirecting eax\n+\n    in this case, this prefix would be the charater `)'.\n-  \n+\n    Please note that we use the indirection suffix also for register\n    displacement, e.g., `4(%eax)' on x86. */\n \n extern const char *const * gdbarch_stap_register_indirection_suffixes (struct gdbarch *gdbarch);\n extern void set_gdbarch_stap_register_indirection_suffixes (struct gdbarch *gdbarch, const char *const * stap_register_indirection_suffixes);\n \n /* Prefix(es) used to name a register using GDB's nomenclature.\n-  \n+\n    For example, on PPC a register is represented by a number in the assembly\n    language (e.g., `10' is the 10th general-purpose register).  However,\n    inside GDB this same register has an `r' appended to its name, so the 10th\n@@ -1252,13 +1252,13 @@ extern const char * gdbarch_stap_gdb_register_suffix (struct gdbarch *gdbarch);\n extern void set_gdbarch_stap_gdb_register_suffix (struct gdbarch *gdbarch, const char * stap_gdb_register_suffix);\n \n /* Check if S is a single operand.\n-  \n+\n    Single operands can be:\n-    - Literal integers, e.g. `$10' on x86\n-    - Register access, e.g. `%eax' on x86\n-    - Register indirection, e.g. `(%eax)' on x86\n-    - Register displacement, e.g. `4(%eax)' on x86\n-  \n+   - Literal integers, e.g. `$10' on x86\n+   - Register access, e.g. `%eax' on x86\n+   - Register indirection, e.g. `(%eax)' on x86\n+   - Register displacement, e.g. `4(%eax)' on x86\n+\n    This function should check for these patterns on the string\n    and return 1 if some were found, or zero otherwise.  Please try to match\n    as much info as you can from the string, i.e., if you have to match\n@@ -1271,20 +1271,20 @@ extern int gdbarch_stap_is_single_operand (struct gdbarch *gdbarch, const char *\n extern void set_gdbarch_stap_is_single_operand (struct gdbarch *gdbarch, gdbarch_stap_is_single_operand_ftype *stap_is_single_operand);\n \n /* Function used to handle a \"special case\" in the parser.\n-  \n+\n    A \"special case\" is considered to be an unknown token, i.e., a token\n    that the parser does not know how to parse.  A good example of special\n    case would be ARM's register displacement syntax:\n-  \n-    [R0, #4]  ;; displacing R0 by 4\n-  \n+\n+   [R0, #4]  ;; displacing R0 by 4\n+\n    Since the parser assumes that a register displacement is of the form:\n-  \n-    <number> <indirection_prefix> <register_name> <indirection_suffix>\n-  \n+\n+   <number> <indirection_prefix> <register_name> <indirection_suffix>\n+\n    it means that it will not be able to recognize and parse this odd syntax.\n    Therefore, we should add a special case function that will handle this token.\n-  \n+\n    This function should generate the proper expression form of the expression\n    using GDB's internal expression mechanism (e.g., `write_exp_elt_opcode'\n    and so on).  It should also return 1 if the parsing was successful, or zero\n@@ -1299,27 +1299,27 @@ extern expr::operation_up gdbarch_stap_parse_special_token (struct gdbarch *gdba\n extern void set_gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, gdbarch_stap_parse_special_token_ftype *stap_parse_special_token);\n \n /* Perform arch-dependent adjustments to a register name.\n-  \n+\n    In very specific situations, it may be necessary for the register\n    name present in a SystemTap probe's argument to be handled in a\n    special way.  For example, on i386, GCC may over-optimize the\n    register allocation and use smaller registers than necessary.  In\n    such cases, the client that is reading and evaluating the SystemTap\n    probe (ourselves) will need to actually fetch values from the wider\n    version of the register in question.\n-  \n+\n    To illustrate the example, consider the following probe argument\n    (i386):\n-  \n-      4@%ax\n-  \n+\n+   4@%ax\n+\n    This argument says that its value can be found at the %ax register,\n    which is a 16-bit register.  However, the argument's prefix says\n    that its type is \"uint32_t\", which is 32-bit in size.  Therefore, in\n    this case, GDB should actually fetch the probe's value from register\n    %eax, not %ax.  In this scenario, this function would actually\n    replace the register name from %ax to %eax.\n-  \n+\n    The rationale for this can be found at PR breakpoints/24541. */\n \n extern bool gdbarch_stap_adjust_register_p (struct gdbarch *gdbarch);\n@@ -1403,19 +1403,19 @@ extern void set_gdbarch_guess_tracepoint_registers (struct gdbarch *gdbarch, gdb\n \n /* Return the \"auto\" target charset. */\n \n-typedef const char * (gdbarch_auto_charset_ftype) (void);\n+typedef const char * (gdbarch_auto_charset_ftype) ();\n extern const char * gdbarch_auto_charset (struct gdbarch *gdbarch);\n extern void set_gdbarch_auto_charset (struct gdbarch *gdbarch, gdbarch_auto_charset_ftype *auto_charset);\n \n /* Return the \"auto\" target wide charset. */\n \n-typedef const char * (gdbarch_auto_wide_charset_ftype) (void);\n+typedef const char * (gdbarch_auto_wide_charset_ftype) ();\n extern const char * gdbarch_auto_wide_charset (struct gdbarch *gdbarch);\n extern void set_gdbarch_auto_wide_charset (struct gdbarch *gdbarch, gdbarch_auto_wide_charset_ftype *auto_wide_charset);\n \n /* If non-empty, this is a file extension that will be opened in place\n    of the file extension reported by the shared library list.\n-  \n+\n    This is most useful for toolchains that use a post-linker tool,\n    where the names of the files run on the target differ in extension\n    compared to the names of the files GDB should load for debug info. */\n@@ -1460,15 +1460,15 @@ extern void set_gdbarch_core_info_proc (struct gdbarch *gdbarch, gdbarch_core_in\n \n /* Iterate over all objfiles in the order that makes the most sense\n    for the architecture to make global symbol searches.\n-  \n+\n    CB is a callback function where OBJFILE is the objfile to be searched,\n    and CB_DATA a pointer to user-defined data (the same data that is passed\n    when calling this gdbarch method).  The iteration stops if this function\n    returns nonzero.\n-  \n+\n    CB_DATA is a pointer to some user-defined data to be passed to\n    the callback.\n-  \n+\n    If not NULL, CURRENT_OBJFILE corresponds to the objfile being\n    inspected when the symbol search was requested. */\n "
    },
    {
      "sha": "5575ba2a1a131f05f4097015ca72ff454ada7c50",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 2,
      "deletions": 25,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fb14eb082928bcad8aaed07e6d6dc901a1274db6/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fb14eb082928bcad8aaed07e6d6dc901a1274db6/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=fb14eb082928bcad8aaed07e6d6dc901a1274db6",
      "patch": "@@ -20,7 +20,7 @@\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n-/* This file was created with the aid of ``gdbarch.sh''.  */\n+/* This file was created with the aid of ``gdbarch.py''.  */\n \n \n /* Maintain the struct gdbarch object.  */\n@@ -48,29 +48,6 @@ struct gdbarch\n   unsigned nr_data;\n   void **data;\n \n-  /* Multi-arch values.\n-\n-     When extending this structure you must:\n-\n-     Add the field below.\n-\n-     Declare set/get functions and define the corresponding\n-     macro in gdbarch.h.\n-\n-     gdbarch_alloc(): If zero/NULL is not a suitable default,\n-     initialize the new field.\n-\n-     verify_gdbarch(): Confirm that the target updated the field\n-     correctly.\n-\n-     gdbarch_dump(): Add a fprintf_unfiltered call so that the new\n-     field is dumped out\n-\n-     get_gdbarch(): Implement the set/get functions (probably using\n-     the macro's as shortcuts).\n-\n-     */\n-\n   int short_bit;\n   int int_bit;\n   int long_bit;\n@@ -3876,7 +3853,7 @@ gdbarch_core_xfer_siginfo (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST\n   gdb_assert (gdbarch->core_xfer_siginfo != NULL);\n   if (gdbarch_debug >= 2)\n     fprintf_unfiltered (gdb_stdlog, \"gdbarch_core_xfer_siginfo called\\n\");\n-  return gdbarch->core_xfer_siginfo (gdbarch,  readbuf, offset, len);\n+  return gdbarch->core_xfer_siginfo (gdbarch, readbuf, offset, len);\n }\n \n void"
    },
    {
      "sha": "9675ef51228dd05b5f32294e059d67261afd21e1",
      "filename": "gdb/gdbarch.sh",
      "status": "removed",
      "additions": 0,
      "deletions": 1790,
      "changes": 1790,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb",
      "patch": "@@ -1,1790 +0,0 @@\n-#!/bin/sh -u\n-\n-# Architecture commands for GDB, the GNU debugger.\n-#\n-# Copyright (C) 1998-2021 Free Software Foundation, Inc.\n-#\n-# This file is part of GDB.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-# Make certain that the script is not running in an internationalized\n-# environment.\n-LANG=C ; export LANG\n-LC_ALL=C ; export LC_ALL\n-\n-# Format of the input table\n-read=\"class returntype function formal actual staticdefault predefault postdefault invalid_p print garbage_at_eol\"\n-\n-do_read ()\n-{\n-    comment=\"\"\n-    class=\"\"\n-    # On some SH's, 'read' trims leading and trailing whitespace by\n-    # default (e.g., bash), while on others (e.g., dash), it doesn't.\n-    # Set IFS to empty to disable the trimming everywhere.\n-    # shellcheck disable=SC2162\n-    while IFS='' read line\n-    do\n-\tif test \"${line}\" = \"\"\n-\tthen\n-\t    continue\n-\telif test \"${line}\" = \"#\" -a \"${comment}\" = \"\"\n-\tthen\n-\t    continue\n-\telif expr \"${line}\" : \"#\" > /dev/null\n-\tthen\n-\t    comment=\"${comment}\n-${line}\"\n-\telse\n-\n-\t    # The semantics of IFS varies between different SH's.  Some\n-\t    # treat ``;;' as three fields while some treat it as just two.\n-\t    # Work around this by eliminating ``;;'' ....\n-\t    line=\"$(echo \"${line}\" | sed -e 's/;;/; ;/g' -e 's/;;/; ;/g')\"\n-\n-\t    OFS=\"${IFS}\" ; IFS=\"[;]\"\n-\t    eval read \"${read}\" <<EOF\n-${line}\n-EOF\n-\t    IFS=\"${OFS}\"\n-\n-\t    if test -n \"${garbage_at_eol:-}\"\n-\t    then\n-\t\techo \"Garbage at end-of-line in ${line}\" 1>&2\n-\t\tkill $$\n-\t\texit 1\n-\t    fi\n-\n-\t    # .... and then going back through each field and strip out those\n-\t    # that ended up with just that space character.\n-\t    for r in ${read}\n-\t    do\n-\t\tif eval test \"\\\"\\${${r}}\\\" = ' '\"\n-\t\tthen\n-\t\t    eval \"${r}=\"\n-\t\tfi\n-\t    done\n-\n-\t    case \"${class}\" in\n-\t\tm ) staticdefault=\"${predefault:-}\" ;;\n-\t\tM ) staticdefault=\"0\" ;;\n-\t\t* ) test \"${staticdefault}\" || staticdefault=0 ;;\n-\t    esac\n-\n-\t    case \"${class}\" in\n-\t    F | V | M )\n-\t\tcase \"${invalid_p:-}\" in\n-\t\t\"\" )\n-\t\t    if test -n \"${predefault}\"\n-\t\t    then\n-\t\t\t#invalid_p=\"gdbarch->${function} == ${predefault}\"\n-\t\t\tpredicate=\"gdbarch->${function:-} != ${predefault}\"\n-\t\t    elif class_is_variable_p\n-\t\t    then\n-\t\t\tpredicate=\"gdbarch->${function} != 0\"\n-\t\t    elif class_is_function_p\n-\t\t    then\n-\t\t\tpredicate=\"gdbarch->${function} != NULL\"\n-\t\t    fi\n-\t\t    ;;\n-\t\t* )\n-\t\t    echo \"Predicate function ${function} with invalid_p.\" 1>&2\n-\t\t    kill $$\n-\t\t    exit 1\n-\t\t    ;;\n-\t\tesac\n-\t    esac\n-\n-\t    #NOT YET: See gdbarch.log for basic verification of\n-\t    # database\n-\n-\t    break\n-\tfi\n-    done\n-    if [ -n \"${class}\" ]\n-    then\n-\ttrue\n-    else\n-\tfalse\n-    fi\n-}\n-\n-\n-fallback_default_p ()\n-{\n-    { [ -n \"${postdefault:-}\" ] && [ \"x${invalid_p}\" != \"x0\" ]; } \\\n-\t|| { [ -n \"${predefault}\" ] && [ \"x${invalid_p}\" = \"x0\" ]; }\n-}\n-\n-class_is_variable_p ()\n-{\n-    case \"${class}\" in\n-\t*v* | *V* ) true ;;\n-\t* ) false ;;\n-    esac\n-}\n-\n-class_is_function_p ()\n-{\n-    case \"${class}\" in\n-\t*f* | *F* | *m* | *M* ) true ;;\n-\t* ) false ;;\n-    esac\n-}\n-\n-class_is_multiarch_p ()\n-{\n-    case \"${class}\" in\n-\t*m* | *M* ) true ;;\n-\t* ) false ;;\n-    esac\n-}\n-\n-class_is_predicate_p ()\n-{\n-    case \"${class}\" in\n-\t*F* | *V* | *M* ) true ;;\n-\t* ) false ;;\n-    esac\n-}\n-\n-class_is_info_p ()\n-{\n-    case \"${class}\" in\n-\t*i* ) true ;;\n-\t* ) false ;;\n-    esac\n-}\n-\n-\n-# dump out/verify the doco\n-for field in ${read}\n-do\n-  case ${field} in\n-\n-    class ) : ;;\n-\n-\t# # -> line disable\n-\t# f -> function\n-\t#   hiding a function\n-\t# F -> function + predicate\n-\t#   hiding a function + predicate to test function validity\n-\t# v -> variable\n-\t#   hiding a variable\n-\t# V -> variable + predicate\n-\t#   hiding a variable + predicate to test variables validity\n-\t# i -> set from info\n-\t#   hiding something from the ``struct info'' object\n-\t# m -> multi-arch function\n-\t#   hiding a multi-arch function (parameterised with the architecture)\n-\t# M -> multi-arch function + predicate\n-\t#   hiding a multi-arch function + predicate to test function validity\n-\n-    returntype ) : ;;\n-\n-\t# For functions, the return type; for variables, the data type\n-\n-    function ) : ;;\n-\n-\t# For functions, the member function name; for variables, the\n-\t# variable name.  Member function names are always prefixed with\n-\t# ``gdbarch_'' for name-space purity.\n-\n-    formal ) : ;;\n-\n-\t# The formal argument list.  It is assumed that the formal\n-\t# argument list includes the actual name of each list element.\n-\t# A function with no arguments shall have ``void'' as the\n-\t# formal argument list.\n-\n-    actual ) : ;;\n-\n-\t# The list of actual arguments.  The arguments specified shall\n-\t# match the FORMAL list given above.  Functions with out\n-\t# arguments leave this blank.\n-\n-    staticdefault ) : ;;\n-\n-\t# To help with the GDB startup a static gdbarch object is\n-\t# created.  STATICDEFAULT is the value to insert into that\n-\t# static gdbarch object.  Since this a static object only\n-\t# simple expressions can be used.\n-\n-\t# If STATICDEFAULT is empty, zero is used.\n-\n-    predefault ) : ;;\n-\n-\t# An initial value to assign to MEMBER of the freshly\n-\t# malloc()ed gdbarch object.  After initialization, the\n-\t# freshly malloc()ed object is passed to the target\n-\t# architecture code for further updates.\n-\n-\t# If PREDEFAULT is empty, zero is used.\n-\n-\t# A non-empty PREDEFAULT, an empty POSTDEFAULT and a zero\n-\t# INVALID_P are specified, PREDEFAULT will be used as the\n-\t# default for the non- multi-arch target.\n-\n-\t# A zero PREDEFAULT function will force the fallback to call\n-\t# internal_error().\n-\n-\t# Variable declarations can refer to ``gdbarch'' which will\n-\t# contain the current architecture.  Care should be taken.\n-\n-    postdefault ) : ;;\n-\n-\t# A value to assign to MEMBER of the new gdbarch object should\n-\t# the target architecture code fail to change the PREDEFAULT\n-\t# value.\n-\n-\t# If POSTDEFAULT is empty, no post update is performed.\n-\n-\t# If both INVALID_P and POSTDEFAULT are non-empty then\n-\t# INVALID_P will be used to determine if MEMBER should be\n-\t# changed to POSTDEFAULT.\n-\n-\t# If a non-empty POSTDEFAULT and a zero INVALID_P are\n-\t# specified, POSTDEFAULT will be used as the default for the\n-\t# non- multi-arch target (regardless of the value of\n-\t# PREDEFAULT).\n-\n-\t# You cannot specify both a zero INVALID_P and a POSTDEFAULT.\n-\n-\t# Variable declarations can refer to ``gdbarch'' which\n-\t# will contain the current architecture.  Care should be\n-\t# taken.\n-\n-    invalid_p ) : ;;\n-\n-\t# A predicate equation that validates MEMBER.  Non-zero is\n-\t# returned if the code creating the new architecture failed to\n-\t# initialize MEMBER or the initialized the member is invalid.\n-\t# If POSTDEFAULT is non-empty then MEMBER will be updated to\n-\t# that value.  If POSTDEFAULT is empty then internal_error()\n-\t# is called.\n-\n-\t# If INVALID_P is empty, a check that MEMBER is no longer\n-\t# equal to PREDEFAULT is used.\n-\n-\t# The expression ``0'' disables the INVALID_P check making\n-\t# PREDEFAULT a legitimate value.\n-\n-\t# See also PREDEFAULT and POSTDEFAULT.\n-\n-    print ) : ;;\n-\n-\t# An optional expression that convers MEMBER to a value\n-\t# suitable for formatting using %s.\n-\n-\t# If PRINT is empty, core_addr_to_string_nz (for CORE_ADDR)\n-\t# or plongest (anything else) is used.\n-\n-    garbage_at_eol ) : ;;\n-\n-\t# Catches stray fields.\n-\n-    *)\n-\techo \"Bad field ${field}\"\n-\texit 1;;\n-  esac\n-done\n-\n-\n-function_list ()\n-{\n-  # See below (DOCO) for description of each field\n-  cat <<EOF\n-i;const struct bfd_arch_info *;bfd_arch_info;;;&bfd_default_arch_struct;;;;gdbarch_bfd_arch_info (gdbarch)->printable_name\n-#\n-i;enum bfd_endian;byte_order;;;BFD_ENDIAN_BIG\n-i;enum bfd_endian;byte_order_for_code;;;BFD_ENDIAN_BIG\n-#\n-i;enum gdb_osabi;osabi;;;GDB_OSABI_UNKNOWN\n-#\n-i;const struct target_desc *;target_desc;;;;;;;host_address_to_string (gdbarch->target_desc)\n-\n-# Number of bits in a short or unsigned short for the target machine.\n-v;int;short_bit;;;8 * sizeof (short);2*TARGET_CHAR_BIT;;0\n-# Number of bits in an int or unsigned int for the target machine.\n-v;int;int_bit;;;8 * sizeof (int);4*TARGET_CHAR_BIT;;0\n-# Number of bits in a long or unsigned long for the target machine.\n-v;int;long_bit;;;8 * sizeof (long);4*TARGET_CHAR_BIT;;0\n-# Number of bits in a long long or unsigned long long for the target\n-# machine.\n-v;int;long_long_bit;;;8 * sizeof (LONGEST);2*gdbarch->long_bit;;0\n-\n-# The ABI default bit-size and format for \"bfloat16\", \"half\", \"float\", \"double\", and\n-# \"long double\".  These bit/format pairs should eventually be combined\n-# into a single object.  For the moment, just initialize them as a pair.\n-# Each format describes both the big and little endian layouts (if\n-# useful).\n-\n-v;int;bfloat16_bit;;;16;2*TARGET_CHAR_BIT;;0\n-v;const struct floatformat **;bfloat16_format;;;;;floatformats_bfloat16;;pformat (gdbarch->bfloat16_format)\n-v;int;half_bit;;;16;2*TARGET_CHAR_BIT;;0\n-v;const struct floatformat **;half_format;;;;;floatformats_ieee_half;;pformat (gdbarch->half_format)\n-v;int;float_bit;;;8 * sizeof (float);4*TARGET_CHAR_BIT;;0\n-v;const struct floatformat **;float_format;;;;;floatformats_ieee_single;;pformat (gdbarch->float_format)\n-v;int;double_bit;;;8 * sizeof (double);8*TARGET_CHAR_BIT;;0\n-v;const struct floatformat **;double_format;;;;;floatformats_ieee_double;;pformat (gdbarch->double_format)\n-v;int;long_double_bit;;;8 * sizeof (long double);8*TARGET_CHAR_BIT;;0\n-v;const struct floatformat **;long_double_format;;;;;floatformats_ieee_double;;pformat (gdbarch->long_double_format)\n-\n-# The ABI default bit-size for \"wchar_t\".  wchar_t is a built-in type\n-# starting with C++11.\n-v;int;wchar_bit;;;8 * sizeof (wchar_t);4*TARGET_CHAR_BIT;;0\n-# One if \\`wchar_t' is signed, zero if unsigned.\n-v;int;wchar_signed;;;1;-1;1\n-\n-# Returns the floating-point format to be used for values of length LENGTH.\n-# NAME, if non-NULL, is the type name, which may be used to distinguish\n-# different target formats of the same length.\n-m;const struct floatformat **;floatformat_for_type;const char *name, int length;name, length;0;default_floatformat_for_type;;0\n-\n-# For most targets, a pointer on the target and its representation as an\n-# address in GDB have the same size and \"look the same\".  For such a\n-# target, you need only set gdbarch_ptr_bit and gdbarch_addr_bit\n-# / addr_bit will be set from it.\n-#\n-# If gdbarch_ptr_bit and gdbarch_addr_bit are different, you'll probably\n-# also need to set gdbarch_dwarf2_addr_size, gdbarch_pointer_to_address and\n-# gdbarch_address_to_pointer as well.\n-#\n-# ptr_bit is the size of a pointer on the target\n-v;int;ptr_bit;;;8 * sizeof (void*);gdbarch->int_bit;;0\n-# addr_bit is the size of a target address as represented in gdb\n-v;int;addr_bit;;;8 * sizeof (void*);0;gdbarch_ptr_bit (gdbarch);\n-#\n-# dwarf2_addr_size is the target address size as used in the Dwarf debug\n-# info.  For .debug_frame FDEs, this is supposed to be the target address\n-# size from the associated CU header, and which is equivalent to the\n-# DWARF2_ADDR_SIZE as defined by the target specific GCC back-end.\n-# Unfortunately there is no good way to determine this value.  Therefore\n-# dwarf2_addr_size simply defaults to the target pointer size.\n-#\n-# dwarf2_addr_size is not used for .eh_frame FDEs, which are generally\n-# defined using the target's pointer size so far.\n-#\n-# Note that dwarf2_addr_size only needs to be redefined by a target if the\n-# GCC back-end defines a DWARF2_ADDR_SIZE other than the target pointer size,\n-# and if Dwarf versions < 4 need to be supported.\n-v;int;dwarf2_addr_size;;;sizeof (void*);0;gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT;\n-#\n-# One if \\`char' acts like \\`signed char', zero if \\`unsigned char'.\n-v;int;char_signed;;;1;-1;1\n-#\n-F;CORE_ADDR;read_pc;readable_regcache *regcache;regcache\n-F;void;write_pc;struct regcache *regcache, CORE_ADDR val;regcache, val\n-# Function for getting target's idea of a frame pointer.  FIXME: GDB's\n-# whole scheme for dealing with \"frames\" and \"frame pointers\" needs a\n-# serious shakedown.\n-m;void;virtual_frame_pointer;CORE_ADDR pc, int *frame_regnum, LONGEST *frame_offset;pc, frame_regnum, frame_offset;0;legacy_virtual_frame_pointer;;0\n-#\n-M;enum register_status;pseudo_register_read;readable_regcache *regcache, int cookednum, gdb_byte *buf;regcache, cookednum, buf\n-# Read a register into a new struct value.  If the register is wholly\n-# or partly unavailable, this should call mark_value_bytes_unavailable\n-# as appropriate.  If this is defined, then pseudo_register_read will\n-# never be called.\n-M;struct value *;pseudo_register_read_value;readable_regcache *regcache, int cookednum;regcache, cookednum\n-M;void;pseudo_register_write;struct regcache *regcache, int cookednum, const gdb_byte *buf;regcache, cookednum, buf\n-#\n-v;int;num_regs;;;0;-1\n-# This macro gives the number of pseudo-registers that live in the\n-# register namespace but do not get fetched or stored on the target.\n-# These pseudo-registers may be aliases for other registers,\n-# combinations of other registers, or they may be computed by GDB.\n-v;int;num_pseudo_regs;;;0;0;;0\n-\n-# Assemble agent expression bytecode to collect pseudo-register REG.\n-# Return -1 if something goes wrong, 0 otherwise.\n-M;int;ax_pseudo_register_collect;struct agent_expr *ax, int reg;ax, reg\n-\n-# Assemble agent expression bytecode to push the value of pseudo-register\n-# REG on the interpreter stack.\n-# Return -1 if something goes wrong, 0 otherwise.\n-M;int;ax_pseudo_register_push_stack;struct agent_expr *ax, int reg;ax, reg\n-\n-# Some architectures can display additional information for specific\n-# signals.\n-# UIOUT is the output stream where the handler will place information.\n-M;void;report_signal_info;struct ui_out *uiout, enum gdb_signal siggnal;uiout, siggnal\n-\n-# GDB's standard (or well known) register numbers.  These can map onto\n-# a real register or a pseudo (computed) register or not be defined at\n-# all (-1).\n-# gdbarch_sp_regnum will hopefully be replaced by UNWIND_SP.\n-v;int;sp_regnum;;;-1;-1;;0\n-v;int;pc_regnum;;;-1;-1;;0\n-v;int;ps_regnum;;;-1;-1;;0\n-v;int;fp0_regnum;;;0;-1;;0\n-# Convert stab register number (from \\`r\\' declaration) to a gdb REGNUM.\n-m;int;stab_reg_to_regnum;int stab_regnr;stab_regnr;;no_op_reg_to_regnum;;0\n-# Provide a default mapping from a ecoff register number to a gdb REGNUM.\n-m;int;ecoff_reg_to_regnum;int ecoff_regnr;ecoff_regnr;;no_op_reg_to_regnum;;0\n-# Convert from an sdb register number to an internal gdb register number.\n-m;int;sdb_reg_to_regnum;int sdb_regnr;sdb_regnr;;no_op_reg_to_regnum;;0\n-# Provide a default mapping from a DWARF2 register number to a gdb REGNUM.\n-# Return -1 for bad REGNUM.  Note: Several targets get this wrong.\n-m;int;dwarf2_reg_to_regnum;int dwarf2_regnr;dwarf2_regnr;;no_op_reg_to_regnum;;0\n-m;const char *;register_name;int regnr;regnr;;0\n-\n-# Return the type of a register specified by the architecture.  Only\n-# the register cache should call this function directly; others should\n-# use \"register_type\".\n-M;struct type *;register_type;int reg_nr;reg_nr\n-\n-# Generate a dummy frame_id for THIS_FRAME assuming that the frame is\n-# a dummy frame.  A dummy frame is created before an inferior call,\n-# the frame_id returned here must match the frame_id that was built\n-# for the inferior call.  Usually this means the returned frame_id's\n-# stack address should match the address returned by\n-# gdbarch_push_dummy_call, and the returned frame_id's code address\n-# should match the address at which the breakpoint was set in the dummy\n-# frame.\n-m;struct frame_id;dummy_id;struct frame_info *this_frame;this_frame;;default_dummy_id;;0\n-# Implement DUMMY_ID and PUSH_DUMMY_CALL, then delete\n-# deprecated_fp_regnum.\n-v;int;deprecated_fp_regnum;;;-1;-1;;0\n-\n-M;CORE_ADDR;push_dummy_call;struct value *function, struct regcache *regcache, CORE_ADDR bp_addr, int nargs, struct value **args, CORE_ADDR sp, function_call_return_method return_method, CORE_ADDR struct_addr;function, regcache, bp_addr, nargs, args, sp, return_method, struct_addr\n-v;int;call_dummy_location;;;;AT_ENTRY_POINT;;0\n-M;CORE_ADDR;push_dummy_code;CORE_ADDR sp, CORE_ADDR funaddr, struct value **args, int nargs, struct type *value_type, CORE_ADDR *real_pc, CORE_ADDR *bp_addr, struct regcache *regcache;sp, funaddr, args, nargs, value_type, real_pc, bp_addr, regcache\n-\n-# Return true if the code of FRAME is writable.\n-m;int;code_of_frame_writable;struct frame_info *frame;frame;;default_code_of_frame_writable;;0\n-\n-m;void;print_registers_info;struct ui_file *file, struct frame_info *frame, int regnum, int all;file, frame, regnum, all;;default_print_registers_info;;0\n-m;void;print_float_info;struct ui_file *file, struct frame_info *frame, const char *args;file, frame, args;;default_print_float_info;;0\n-M;void;print_vector_info;struct ui_file *file, struct frame_info *frame, const char *args;file, frame, args\n-# MAP a GDB RAW register number onto a simulator register number.  See\n-# also include/...-sim.h.\n-m;int;register_sim_regno;int reg_nr;reg_nr;;legacy_register_sim_regno;;0\n-m;int;cannot_fetch_register;int regnum;regnum;;cannot_register_not;;0\n-m;int;cannot_store_register;int regnum;regnum;;cannot_register_not;;0\n-\n-# Determine the address where a longjmp will land and save this address\n-# in PC.  Return nonzero on success.\n-#\n-# FRAME corresponds to the longjmp frame.\n-F;int;get_longjmp_target;struct frame_info *frame, CORE_ADDR *pc;frame, pc\n-\n-#\n-v;int;believe_pcc_promotion;;;;;;;\n-#\n-m;int;convert_register_p;int regnum, struct type *type;regnum, type;0;generic_convert_register_p;;0\n-f;int;register_to_value;struct frame_info *frame, int regnum, struct type *type, gdb_byte *buf, int *optimizedp, int *unavailablep;frame, regnum, type, buf, optimizedp, unavailablep;0\n-f;void;value_to_register;struct frame_info *frame, int regnum, struct type *type, const gdb_byte *buf;frame, regnum, type, buf;0\n-# Construct a value representing the contents of register REGNUM in\n-# frame FRAME_ID, interpreted as type TYPE.  The routine needs to\n-# allocate and return a struct value with all value attributes\n-# (but not the value contents) filled in.\n-m;struct value *;value_from_register;struct type *type, int regnum, struct frame_id frame_id;type, regnum, frame_id;;default_value_from_register;;0\n-#\n-m;CORE_ADDR;pointer_to_address;struct type *type, const gdb_byte *buf;type, buf;;unsigned_pointer_to_address;;0\n-m;void;address_to_pointer;struct type *type, gdb_byte *buf, CORE_ADDR addr;type, buf, addr;;unsigned_address_to_pointer;;0\n-M;CORE_ADDR;integer_to_address;struct type *type, const gdb_byte *buf;type, buf\n-\n-# Return the return-value convention that will be used by FUNCTION\n-# to return a value of type VALTYPE.  FUNCTION may be NULL in which\n-# case the return convention is computed based only on VALTYPE.\n-#\n-# If READBUF is not NULL, extract the return value and save it in this buffer.\n-#\n-# If WRITEBUF is not NULL, it contains a return value which will be\n-# stored into the appropriate register.  This can be used when we want\n-# to force the value returned by a function (see the \"return\" command\n-# for instance).\n-M;enum return_value_convention;return_value;struct value *function, struct type *valtype, struct regcache *regcache, gdb_byte *readbuf, const gdb_byte *writebuf;function, valtype, regcache, readbuf, writebuf\n-\n-# Return true if the return value of function is stored in the first hidden\n-# parameter.  In theory, this feature should be language-dependent, specified\n-# by language and its ABI, such as C++.  Unfortunately, compiler may\n-# implement it to a target-dependent feature.  So that we need such hook here\n-# to be aware of this in GDB.\n-m;int;return_in_first_hidden_param_p;struct type *type;type;;default_return_in_first_hidden_param_p;;0\n-\n-m;CORE_ADDR;skip_prologue;CORE_ADDR ip;ip;0;0\n-M;CORE_ADDR;skip_main_prologue;CORE_ADDR ip;ip\n-# On some platforms, a single function may provide multiple entry points,\n-# e.g. one that is used for function-pointer calls and a different one\n-# that is used for direct function calls.\n-# In order to ensure that breakpoints set on the function will trigger\n-# no matter via which entry point the function is entered, a platform\n-# may provide the skip_entrypoint callback.  It is called with IP set\n-# to the main entry point of a function (as determined by the symbol table),\n-# and should return the address of the innermost entry point, where the\n-# actual breakpoint needs to be set.  Note that skip_entrypoint is used\n-# by GDB common code even when debugging optimized code, where skip_prologue\n-# is not used.\n-M;CORE_ADDR;skip_entrypoint;CORE_ADDR ip;ip\n-\n-f;int;inner_than;CORE_ADDR lhs, CORE_ADDR rhs;lhs, rhs;0;0\n-m;const gdb_byte *;breakpoint_from_pc;CORE_ADDR *pcptr, int *lenptr;pcptr, lenptr;0;default_breakpoint_from_pc;;0\n-\n-# Return the breakpoint kind for this target based on *PCPTR.\n-m;int;breakpoint_kind_from_pc;CORE_ADDR *pcptr;pcptr;;0;\n-\n-# Return the software breakpoint from KIND.  KIND can have target\n-# specific meaning like the Z0 kind parameter.\n-# SIZE is set to the software breakpoint's length in memory.\n-m;const gdb_byte *;sw_breakpoint_from_kind;int kind, int *size;kind, size;;NULL;;0\n-\n-# Return the breakpoint kind for this target based on the current\n-# processor state (e.g. the current instruction mode on ARM) and the\n-# *PCPTR.  In default, it is gdbarch->breakpoint_kind_from_pc.\n-m;int;breakpoint_kind_from_current_state;struct regcache *regcache, CORE_ADDR *pcptr;regcache, pcptr;0;default_breakpoint_kind_from_current_state;;0\n-\n-M;CORE_ADDR;adjust_breakpoint_address;CORE_ADDR bpaddr;bpaddr\n-m;int;memory_insert_breakpoint;struct bp_target_info *bp_tgt;bp_tgt;0;default_memory_insert_breakpoint;;0\n-m;int;memory_remove_breakpoint;struct bp_target_info *bp_tgt;bp_tgt;0;default_memory_remove_breakpoint;;0\n-v;CORE_ADDR;decr_pc_after_break;;;0;;;0\n-\n-# A function can be addressed by either it's \"pointer\" (possibly a\n-# descriptor address) or \"entry point\" (first executable instruction).\n-# The method \"convert_from_func_ptr_addr\" converting the former to the\n-# latter.  gdbarch_deprecated_function_start_offset is being used to implement\n-# a simplified subset of that functionality - the function's address\n-# corresponds to the \"function pointer\" and the function's start\n-# corresponds to the \"function entry point\" - and hence is redundant.\n-\n-v;CORE_ADDR;deprecated_function_start_offset;;;0;;;0\n-\n-# Return the remote protocol register number associated with this\n-# register.  Normally the identity mapping.\n-m;int;remote_register_number;int regno;regno;;default_remote_register_number;;0\n-\n-# Fetch the target specific address used to represent a load module.\n-F;CORE_ADDR;fetch_tls_load_module_address;struct objfile *objfile;objfile\n-\n-# Return the thread-local address at OFFSET in the thread-local\n-# storage for the thread PTID and the shared library or executable\n-# file given by LM_ADDR.  If that block of thread-local storage hasn't\n-# been allocated yet, this function may throw an error.  LM_ADDR may\n-# be zero for statically linked multithreaded inferiors.\n-\n-M;CORE_ADDR;get_thread_local_address;ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset;ptid, lm_addr, offset\n-#\n-v;CORE_ADDR;frame_args_skip;;;0;;;0\n-m;CORE_ADDR;unwind_pc;struct frame_info *next_frame;next_frame;;default_unwind_pc;;0\n-m;CORE_ADDR;unwind_sp;struct frame_info *next_frame;next_frame;;default_unwind_sp;;0\n-# DEPRECATED_FRAME_LOCALS_ADDRESS as been replaced by the per-frame\n-# frame-base.  Enable frame-base before frame-unwind.\n-F;int;frame_num_args;struct frame_info *frame;frame\n-#\n-M;CORE_ADDR;frame_align;CORE_ADDR address;address\n-m;int;stabs_argument_has_addr;struct type *type;type;;default_stabs_argument_has_addr;;0\n-v;int;frame_red_zone_size\n-#\n-m;CORE_ADDR;convert_from_func_ptr_addr;CORE_ADDR addr, struct target_ops *targ;addr, targ;;convert_from_func_ptr_addr_identity;;0\n-# On some machines there are bits in addresses which are not really\n-# part of the address, but are used by the kernel, the hardware, etc.\n-# for special purposes.  gdbarch_addr_bits_remove takes out any such bits so\n-# we get a \"real\" address such as one would find in a symbol table.\n-# This is used only for addresses of instructions, and even then I'm\n-# not sure it's used in all contexts.  It exists to deal with there\n-# being a few stray bits in the PC which would mislead us, not as some\n-# sort of generic thing to handle alignment or segmentation (it's\n-# possible it should be in TARGET_READ_PC instead).\n-m;CORE_ADDR;addr_bits_remove;CORE_ADDR addr;addr;;core_addr_identity;;0\n-\n-# On some machines, not all bits of an address word are significant.\n-# For example, on AArch64, the top bits of an address known as the \"tag\"\n-# are ignored by the kernel, the hardware, etc. and can be regarded as\n-# additional data associated with the address.\n-v;int;significant_addr_bit;;;;;;0\n-\n-# Return a string representation of the memory tag TAG.\n-m;std::string;memtag_to_string;struct value *tag;tag;;default_memtag_to_string;;0\n-\n-# Return true if ADDRESS contains a tag and false otherwise.  ADDRESS\n-# must be either a pointer or a reference type.\n-m;bool;tagged_address_p;struct value *address;address;;default_tagged_address_p;;0\n-\n-# Return true if the tag from ADDRESS matches the memory tag for that\n-# particular address.  Return false otherwise.\n-m;bool;memtag_matches_p;struct value *address;address;;default_memtag_matches_p;;0\n-\n-# Set the tags of type TAG_TYPE, for the memory address range\n-# [ADDRESS, ADDRESS + LENGTH) to TAGS.\n-# Return true if successful and false otherwise.\n-m;bool;set_memtags;struct value *address, size_t length, const gdb::byte_vector \\&tags, memtag_type tag_type;address, length, tags, tag_type;;default_set_memtags;;0\n-\n-# Return the tag of type TAG_TYPE associated with the memory address ADDRESS,\n-# assuming ADDRESS is tagged.\n-m;struct value *;get_memtag;struct value *address, memtag_type tag_type;address, tag_type;;default_get_memtag;;0\n-\n-# memtag_granule_size is the size of the allocation tag granule, for\n-# architectures that support memory tagging.\n-# This is 0 for architectures that do not support memory tagging.\n-# For a non-zero value, this represents the number of bytes of memory per tag.\n-v;CORE_ADDR;memtag_granule_size;;;;;;0\n-\n-# FIXME/cagney/2001-01-18: This should be split in two.  A target method that\n-# indicates if the target needs software single step.  An ISA method to\n-# implement it.\n-#\n-# FIXME/cagney/2001-01-18: The logic is backwards.  It should be asking if the\n-# target can single step.  If not, then implement single step using breakpoints.\n-#\n-# Return a vector of addresses on which the software single step\n-# breakpoints should be inserted.  NULL means software single step is\n-# not used.\n-# Multiple breakpoints may be inserted for some instructions such as\n-# conditional branch.  However, each implementation must always evaluate\n-# the condition and only put the breakpoint at the branch destination if\n-# the condition is true, so that we ensure forward progress when stepping\n-# past a conditional branch to self.\n-F;std::vector<CORE_ADDR>;software_single_step;struct regcache *regcache;regcache\n-\n-# Return non-zero if the processor is executing a delay slot and a\n-# further single-step is needed before the instruction finishes.\n-M;int;single_step_through_delay;struct frame_info *frame;frame\n-# FIXME: cagney/2003-08-28: Need to find a better way of selecting the\n-# disassembler.  Perhaps objdump can handle it?\n-f;int;print_insn;bfd_vma vma, struct disassemble_info *info;vma, info;;default_print_insn;;0\n-f;CORE_ADDR;skip_trampoline_code;struct frame_info *frame, CORE_ADDR pc;frame, pc;;generic_skip_trampoline_code;;0\n-\n-\n-# If in_solib_dynsym_resolve_code() returns true, and SKIP_SOLIB_RESOLVER\n-# evaluates non-zero, this is the address where the debugger will place\n-# a step-resume breakpoint to get us past the dynamic linker.\n-m;CORE_ADDR;skip_solib_resolver;CORE_ADDR pc;pc;;generic_skip_solib_resolver;;0\n-# Some systems also have trampoline code for returning from shared libs.\n-m;int;in_solib_return_trampoline;CORE_ADDR pc, const char *name;pc, name;;generic_in_solib_return_trampoline;;0\n-\n-# Return true if PC lies inside an indirect branch thunk.\n-m;bool;in_indirect_branch_thunk;CORE_ADDR pc;pc;;default_in_indirect_branch_thunk;;0\n-\n-# A target might have problems with watchpoints as soon as the stack\n-# frame of the current function has been destroyed.  This mostly happens\n-# as the first action in a function's epilogue.  stack_frame_destroyed_p()\n-# is defined to return a non-zero value if either the given addr is one\n-# instruction after the stack destroying instruction up to the trailing\n-# return instruction or if we can figure out that the stack frame has\n-# already been invalidated regardless of the value of addr.  Targets\n-# which don't suffer from that problem could just let this functionality\n-# untouched.\n-m;int;stack_frame_destroyed_p;CORE_ADDR addr;addr;0;generic_stack_frame_destroyed_p;;0\n-# Process an ELF symbol in the minimal symbol table in a backend-specific\n-# way.  Normally this hook is supposed to do nothing, however if required,\n-# then this hook can be used to apply tranformations to symbols that are\n-# considered special in some way.  For example the MIPS backend uses it\n-# to interpret \\`st_other' information to mark compressed code symbols so\n-# that they can be treated in the appropriate manner in the processing of\n-# the main symbol table and DWARF-2 records.\n-F;void;elf_make_msymbol_special;asymbol *sym, struct minimal_symbol *msym;sym, msym\n-f;void;coff_make_msymbol_special;int val, struct minimal_symbol *msym;val, msym;;default_coff_make_msymbol_special;;0\n-# Process a symbol in the main symbol table in a backend-specific way.\n-# Normally this hook is supposed to do nothing, however if required,\n-# then this hook can be used to apply tranformations to symbols that\n-# are considered special in some way.  This is currently used by the\n-# MIPS backend to make sure compressed code symbols have the ISA bit\n-# set.  This in turn is needed for symbol values seen in GDB to match\n-# the values used at the runtime by the program itself, for function\n-# and label references.\n-f;void;make_symbol_special;struct symbol *sym, struct objfile *objfile;sym, objfile;;default_make_symbol_special;;0\n-# Adjust the address retrieved from a DWARF-2 record other than a line\n-# entry in a backend-specific way.  Normally this hook is supposed to\n-# return the address passed unchanged, however if that is incorrect for\n-# any reason, then this hook can be used to fix the address up in the\n-# required manner.  This is currently used by the MIPS backend to make\n-# sure addresses in FDE, range records, etc. referring to compressed\n-# code have the ISA bit set, matching line information and the symbol\n-# table.\n-f;CORE_ADDR;adjust_dwarf2_addr;CORE_ADDR pc;pc;;default_adjust_dwarf2_addr;;0\n-# Adjust the address updated by a line entry in a backend-specific way.\n-# Normally this hook is supposed to return the address passed unchanged,\n-# however in the case of inconsistencies in these records, this hook can\n-# be used to fix them up in the required manner.  This is currently used\n-# by the MIPS backend to make sure all line addresses in compressed code\n-# are presented with the ISA bit set, which is not always the case.  This\n-# in turn ensures breakpoint addresses are correctly matched against the\n-# stop PC.\n-f;CORE_ADDR;adjust_dwarf2_line;CORE_ADDR addr, int rel;addr, rel;;default_adjust_dwarf2_line;;0\n-v;int;cannot_step_breakpoint;;;0;0;;0\n-# See comment in target.h about continuable, steppable and\n-# non-steppable watchpoints.\n-v;int;have_nonsteppable_watchpoint;;;0;0;;0\n-F;type_instance_flags;address_class_type_flags;int byte_size, int dwarf2_addr_class;byte_size, dwarf2_addr_class\n-M;const char *;address_class_type_flags_to_name;type_instance_flags type_flags;type_flags\n-# Execute vendor-specific DWARF Call Frame Instruction.  OP is the instruction.\n-# FS are passed from the generic execute_cfa_program function.\n-m;bool;execute_dwarf_cfa_vendor_op;gdb_byte op, struct dwarf2_frame_state *fs;op, fs;;default_execute_dwarf_cfa_vendor_op;;0\n-\n-# Return the appropriate type_flags for the supplied address class.\n-# This function should return true if the address class was recognized and\n-# type_flags was set, false otherwise.\n-M;bool;address_class_name_to_type_flags;const char *name, type_instance_flags *type_flags_ptr;name, type_flags_ptr\n-# Is a register in a group\n-m;int;register_reggroup_p;int regnum, struct reggroup *reggroup;regnum, reggroup;;default_register_reggroup_p;;0\n-# Fetch the pointer to the ith function argument.\n-F;CORE_ADDR;fetch_pointer_argument;struct frame_info *frame, int argi, struct type *type;frame, argi, type\n-\n-# Iterate over all supported register notes in a core file.  For each\n-# supported register note section, the iterator must call CB and pass\n-# CB_DATA unchanged.  If REGCACHE is not NULL, the iterator can limit\n-# the supported register note sections based on the current register\n-# values.  Otherwise it should enumerate all supported register note\n-# sections.\n-M;void;iterate_over_regset_sections;iterate_over_regset_sections_cb *cb, void *cb_data, const struct regcache *regcache;cb, cb_data, regcache\n-\n-# Create core file notes\n-M;gdb::unique_xmalloc_ptr<char>;make_corefile_notes;bfd *obfd, int *note_size;obfd, note_size\n-\n-# Find core file memory regions\n-M;int;find_memory_regions;find_memory_region_ftype func, void *data;func, data\n-\n-# Read offset OFFSET of TARGET_OBJECT_LIBRARIES formatted shared libraries list from\n-# core file into buffer READBUF with length LEN.  Return the number of bytes read\n-# (zero indicates failure).\n-# failed, otherwise, return the red length of READBUF.\n-M;ULONGEST;core_xfer_shared_libraries;gdb_byte *readbuf, ULONGEST offset, ULONGEST len;readbuf, offset, len\n-\n-# Read offset OFFSET of TARGET_OBJECT_LIBRARIES_AIX formatted shared\n-# libraries list from core file into buffer READBUF with length LEN.\n-# Return the number of bytes read (zero indicates failure).\n-M;ULONGEST;core_xfer_shared_libraries_aix;gdb_byte *readbuf, ULONGEST offset, ULONGEST len;readbuf, offset, len\n-\n-# How the core target converts a PTID from a core file to a string.\n-M;std::string;core_pid_to_str;ptid_t ptid;ptid\n-\n-# How the core target extracts the name of a thread from a core file.\n-M;const char *;core_thread_name;struct thread_info *thr;thr\n-\n-# Read offset OFFSET of TARGET_OBJECT_SIGNAL_INFO signal information\n-# from core file into buffer READBUF with length LEN.  Return the number\n-# of bytes read (zero indicates EOF, a negative value indicates failure).\n-M;LONGEST;core_xfer_siginfo;gdb_byte *readbuf, ULONGEST offset, ULONGEST len; readbuf, offset, len\n-\n-# BFD target to use when generating a core file.\n-V;const char *;gcore_bfd_target;;;0;0;;;pstring (gdbarch->gcore_bfd_target)\n-\n-# If the elements of C++ vtables are in-place function descriptors rather\n-# than normal function pointers (which may point to code or a descriptor),\n-# set this to one.\n-v;int;vtable_function_descriptors;;;0;0;;0\n-\n-# Set if the least significant bit of the delta is used instead of the least\n-# significant bit of the pfn for pointers to virtual member functions.\n-v;int;vbit_in_delta;;;0;0;;0\n-\n-# Advance PC to next instruction in order to skip a permanent breakpoint.\n-f;void;skip_permanent_breakpoint;struct regcache *regcache;regcache;default_skip_permanent_breakpoint;default_skip_permanent_breakpoint;;0\n-\n-# The maximum length of an instruction on this architecture in bytes.\n-V;ULONGEST;max_insn_length;;;0;0\n-\n-# Copy the instruction at FROM to TO, and make any adjustments\n-# necessary to single-step it at that address.\n-#\n-# REGS holds the state the thread's registers will have before\n-# executing the copied instruction; the PC in REGS will refer to FROM,\n-# not the copy at TO.  The caller should update it to point at TO later.\n-#\n-# Return a pointer to data of the architecture's choice to be passed\n-# to gdbarch_displaced_step_fixup.\n-#\n-# For a general explanation of displaced stepping and how GDB uses it,\n-# see the comments in infrun.c.\n-#\n-# The TO area is only guaranteed to have space for\n-# gdbarch_max_insn_length (arch) bytes, so this function must not\n-# write more bytes than that to that area.\n-#\n-# If you do not provide this function, GDB assumes that the\n-# architecture does not support displaced stepping.\n-#\n-# If the instruction cannot execute out of line, return NULL.  The\n-# core falls back to stepping past the instruction in-line instead in\n-# that case.\n-M;displaced_step_copy_insn_closure_up;displaced_step_copy_insn;CORE_ADDR from, CORE_ADDR to, struct regcache *regs;from, to, regs\n-\n-# Return true if GDB should use hardware single-stepping to execute a displaced\n-# step instruction.  If false, GDB will simply restart execution at the\n-# displaced instruction location, and it is up to the target to ensure GDB will\n-# receive control again (e.g. by placing a software breakpoint instruction into\n-# the displaced instruction buffer).\n-#\n-# The default implementation returns false on all targets that provide a\n-# gdbarch_software_single_step routine, and true otherwise.\n-m;bool;displaced_step_hw_singlestep;void;;;default_displaced_step_hw_singlestep;;0\n-\n-# Fix up the state resulting from successfully single-stepping a\n-# displaced instruction, to give the result we would have gotten from\n-# stepping the instruction in its original location.\n-#\n-# REGS is the register state resulting from single-stepping the\n-# displaced instruction.\n-#\n-# CLOSURE is the result from the matching call to\n-# gdbarch_displaced_step_copy_insn.\n-#\n-# If you provide gdbarch_displaced_step_copy_insn.but not this\n-# function, then GDB assumes that no fixup is needed after\n-# single-stepping the instruction.\n-#\n-# For a general explanation of displaced stepping and how GDB uses it,\n-# see the comments in infrun.c.\n-M;void;displaced_step_fixup;struct displaced_step_copy_insn_closure *closure, CORE_ADDR from, CORE_ADDR to, struct regcache *regs;closure, from, to, regs;;NULL\n-\n-# Prepare THREAD for it to displaced step the instruction at its current PC.\n-#\n-# Throw an exception if any unexpected error happens.\n-M;displaced_step_prepare_status;displaced_step_prepare;thread_info *thread, CORE_ADDR &displaced_pc;thread, displaced_pc\n-\n-# Clean up after a displaced step of THREAD.\n-m;displaced_step_finish_status;displaced_step_finish;thread_info *thread, gdb_signal sig;thread, sig;;NULL;;(! gdbarch->displaced_step_finish) != (! gdbarch->displaced_step_prepare)\n-\n-# Return the closure associated to the displaced step buffer that is at ADDR.\n-F;const displaced_step_copy_insn_closure *;displaced_step_copy_insn_closure_by_addr;inferior *inf, CORE_ADDR addr;inf, addr\n-\n-# PARENT_INF has forked and CHILD_PTID is the ptid of the child.  Restore the\n-# contents of all displaced step buffers in the child's address space.\n-f;void;displaced_step_restore_all_in_ptid;inferior *parent_inf, ptid_t child_ptid;parent_inf, child_ptid\n-\n-# Relocate an instruction to execute at a different address.  OLDLOC\n-# is the address in the inferior memory where the instruction to\n-# relocate is currently at.  On input, TO points to the destination\n-# where we want the instruction to be copied (and possibly adjusted)\n-# to.  On output, it points to one past the end of the resulting\n-# instruction(s).  The effect of executing the instruction at TO shall\n-# be the same as if executing it at FROM.  For example, call\n-# instructions that implicitly push the return address on the stack\n-# should be adjusted to return to the instruction after OLDLOC;\n-# relative branches, and other PC-relative instructions need the\n-# offset adjusted; etc.\n-M;void;relocate_instruction;CORE_ADDR *to, CORE_ADDR from;to, from;;NULL\n-\n-# Refresh overlay mapped state for section OSECT.\n-F;void;overlay_update;struct obj_section *osect;osect\n-\n-M;const struct target_desc *;core_read_description;struct target_ops *target, bfd *abfd;target, abfd\n-\n-# Set if the address in N_SO or N_FUN stabs may be zero.\n-v;int;sofun_address_maybe_missing;;;0;0;;0\n-\n-# Parse the instruction at ADDR storing in the record execution log\n-# the registers REGCACHE and memory ranges that will be affected when\n-# the instruction executes, along with their current values.\n-# Return -1 if something goes wrong, 0 otherwise.\n-M;int;process_record;struct regcache *regcache, CORE_ADDR addr;regcache, addr\n-\n-# Save process state after a signal.\n-# Return -1 if something goes wrong, 0 otherwise.\n-M;int;process_record_signal;struct regcache *regcache, enum gdb_signal signal;regcache, signal\n-\n-# Signal translation: translate inferior's signal (target's) number\n-# into GDB's representation.  The implementation of this method must\n-# be host independent.  IOW, don't rely on symbols of the NAT_FILE\n-# header (the nm-*.h files), the host <signal.h> header, or similar\n-# headers.  This is mainly used when cross-debugging core files ---\n-# \"Live\" targets hide the translation behind the target interface\n-# (target_wait, target_resume, etc.).\n-M;enum gdb_signal;gdb_signal_from_target;int signo;signo\n-\n-# Signal translation: translate the GDB's internal signal number into\n-# the inferior's signal (target's) representation.  The implementation\n-# of this method must be host independent.  IOW, don't rely on symbols\n-# of the NAT_FILE header (the nm-*.h files), the host <signal.h>\n-# header, or similar headers.\n-# Return the target signal number if found, or -1 if the GDB internal\n-# signal number is invalid.\n-M;int;gdb_signal_to_target;enum gdb_signal signal;signal\n-\n-# Extra signal info inspection.\n-#\n-# Return a type suitable to inspect extra signal information.\n-M;struct type *;get_siginfo_type;void;\n-\n-# Record architecture-specific information from the symbol table.\n-M;void;record_special_symbol;struct objfile *objfile, asymbol *sym;objfile, sym\n-\n-# Function for the 'catch syscall' feature.\n-\n-# Get architecture-specific system calls information from registers.\n-M;LONGEST;get_syscall_number;thread_info *thread;thread\n-\n-# The filename of the XML syscall for this architecture.\n-v;const char *;xml_syscall_file;;;0;0;;0;pstring (gdbarch->xml_syscall_file)\n-\n-# Information about system calls from this architecture\n-v;struct syscalls_info *;syscalls_info;;;0;0;;0;host_address_to_string (gdbarch->syscalls_info)\n-\n-# SystemTap related fields and functions.\n-\n-# A NULL-terminated array of prefixes used to mark an integer constant\n-# on the architecture's assembly.\n-# For example, on x86 integer constants are written as:\n-#\n-#  \\$10 ;; integer constant 10\n-#\n-# in this case, this prefix would be the character \\`\\$\\'.\n-v;const char *const *;stap_integer_prefixes;;;0;0;;0;pstring_list (gdbarch->stap_integer_prefixes)\n-\n-# A NULL-terminated array of suffixes used to mark an integer constant\n-# on the architecture's assembly.\n-v;const char *const *;stap_integer_suffixes;;;0;0;;0;pstring_list (gdbarch->stap_integer_suffixes)\n-\n-# A NULL-terminated array of prefixes used to mark a register name on\n-# the architecture's assembly.\n-# For example, on x86 the register name is written as:\n-#\n-#  \\%eax ;; register eax\n-#\n-# in this case, this prefix would be the character \\`\\%\\'.\n-v;const char *const *;stap_register_prefixes;;;0;0;;0;pstring_list (gdbarch->stap_register_prefixes)\n-\n-# A NULL-terminated array of suffixes used to mark a register name on\n-# the architecture's assembly.\n-v;const char *const *;stap_register_suffixes;;;0;0;;0;pstring_list (gdbarch->stap_register_suffixes)\n-\n-# A NULL-terminated array of prefixes used to mark a register\n-# indirection on the architecture's assembly.\n-# For example, on x86 the register indirection is written as:\n-#\n-#  \\(\\%eax\\) ;; indirecting eax\n-#\n-# in this case, this prefix would be the charater \\`\\(\\'.\n-#\n-# Please note that we use the indirection prefix also for register\n-# displacement, e.g., \\`4\\(\\%eax\\)\\' on x86.\n-v;const char *const *;stap_register_indirection_prefixes;;;0;0;;0;pstring_list (gdbarch->stap_register_indirection_prefixes)\n-\n-# A NULL-terminated array of suffixes used to mark a register\n-# indirection on the architecture's assembly.\n-# For example, on x86 the register indirection is written as:\n-#\n-#  \\(\\%eax\\) ;; indirecting eax\n-#\n-# in this case, this prefix would be the charater \\`\\)\\'.\n-#\n-# Please note that we use the indirection suffix also for register\n-# displacement, e.g., \\`4\\(\\%eax\\)\\' on x86.\n-v;const char *const *;stap_register_indirection_suffixes;;;0;0;;0;pstring_list (gdbarch->stap_register_indirection_suffixes)\n-\n-# Prefix(es) used to name a register using GDB's nomenclature.\n-#\n-# For example, on PPC a register is represented by a number in the assembly\n-# language (e.g., \\`10\\' is the 10th general-purpose register).  However,\n-# inside GDB this same register has an \\`r\\' appended to its name, so the 10th\n-# register would be represented as \\`r10\\' internally.\n-v;const char *;stap_gdb_register_prefix;;;0;0;;0;pstring (gdbarch->stap_gdb_register_prefix)\n-\n-# Suffix used to name a register using GDB's nomenclature.\n-v;const char *;stap_gdb_register_suffix;;;0;0;;0;pstring (gdbarch->stap_gdb_register_suffix)\n-\n-# Check if S is a single operand.\n-#\n-# Single operands can be:\n-#  \\- Literal integers, e.g. \\`\\$10\\' on x86\n-#  \\- Register access, e.g. \\`\\%eax\\' on x86\n-#  \\- Register indirection, e.g. \\`\\(\\%eax\\)\\' on x86\n-#  \\- Register displacement, e.g. \\`4\\(\\%eax\\)\\' on x86\n-#\n-# This function should check for these patterns on the string\n-# and return 1 if some were found, or zero otherwise.  Please try to match\n-# as much info as you can from the string, i.e., if you have to match\n-# something like \\`\\(\\%\\', do not match just the \\`\\(\\'.\n-M;int;stap_is_single_operand;const char *s;s\n-\n-# Function used to handle a \"special case\" in the parser.\n-#\n-# A \"special case\" is considered to be an unknown token, i.e., a token\n-# that the parser does not know how to parse.  A good example of special\n-# case would be ARM's register displacement syntax:\n-#\n-#  [R0, #4]  ;; displacing R0 by 4\n-#\n-# Since the parser assumes that a register displacement is of the form:\n-#\n-#  <number> <indirection_prefix> <register_name> <indirection_suffix>\n-#\n-# it means that it will not be able to recognize and parse this odd syntax.\n-# Therefore, we should add a special case function that will handle this token.\n-#\n-# This function should generate the proper expression form of the expression\n-# using GDB\\'s internal expression mechanism (e.g., \\`write_exp_elt_opcode\\'\n-# and so on).  It should also return 1 if the parsing was successful, or zero\n-# if the token was not recognized as a special token (in this case, returning\n-# zero means that the special parser is deferring the parsing to the generic\n-# parser), and should advance the buffer pointer (p->arg).\n-M;expr::operation_up;stap_parse_special_token;struct stap_parse_info *p;p\n-\n-# Perform arch-dependent adjustments to a register name.\n-#\n-# In very specific situations, it may be necessary for the register\n-# name present in a SystemTap probe's argument to be handled in a\n-# special way.  For example, on i386, GCC may over-optimize the\n-# register allocation and use smaller registers than necessary.  In\n-# such cases, the client that is reading and evaluating the SystemTap\n-# probe (ourselves) will need to actually fetch values from the wider\n-# version of the register in question.\n-#\n-# To illustrate the example, consider the following probe argument\n-# (i386):\n-#\n-#    4@%ax\n-#\n-# This argument says that its value can be found at the %ax register,\n-# which is a 16-bit register.  However, the argument's prefix says\n-# that its type is \"uint32_t\", which is 32-bit in size.  Therefore, in\n-# this case, GDB should actually fetch the probe's value from register\n-# %eax, not %ax.  In this scenario, this function would actually\n-# replace the register name from %ax to %eax.\n-#\n-# The rationale for this can be found at PR breakpoints/24541.\n-M;std::string;stap_adjust_register;struct stap_parse_info *p, const std::string \\&regname, int regnum;p, regname, regnum\n-\n-# DTrace related functions.\n-\n-# The expression to compute the NARTGth+1 argument to a DTrace USDT probe.\n-# NARG must be >= 0.\n-M;expr::operation_up;dtrace_parse_probe_argument;int narg;narg\n-\n-# True if the given ADDR does not contain the instruction sequence\n-# corresponding to a disabled DTrace is-enabled probe.\n-M;int;dtrace_probe_is_enabled;CORE_ADDR addr;addr\n-\n-# Enable a DTrace is-enabled probe at ADDR.\n-M;void;dtrace_enable_probe;CORE_ADDR addr;addr\n-\n-# Disable a DTrace is-enabled probe at ADDR.\n-M;void;dtrace_disable_probe;CORE_ADDR addr;addr\n-\n-# True if the list of shared libraries is one and only for all\n-# processes, as opposed to a list of shared libraries per inferior.\n-# This usually means that all processes, although may or may not share\n-# an address space, will see the same set of symbols at the same\n-# addresses.\n-v;int;has_global_solist;;;0;0;;0\n-\n-# On some targets, even though each inferior has its own private\n-# address space, the debug interface takes care of making breakpoints\n-# visible to all address spaces automatically.  For such cases,\n-# this property should be set to true.\n-v;int;has_global_breakpoints;;;0;0;;0\n-\n-# True if inferiors share an address space (e.g., uClinux).\n-m;int;has_shared_address_space;void;;;default_has_shared_address_space;;0\n-\n-# True if a fast tracepoint can be set at an address.\n-m;int;fast_tracepoint_valid_at;CORE_ADDR addr, std::string *msg;addr, msg;;default_fast_tracepoint_valid_at;;0\n-\n-# Guess register state based on tracepoint location.  Used for tracepoints\n-# where no registers have been collected, but there's only one location,\n-# allowing us to guess the PC value, and perhaps some other registers.\n-# On entry, regcache has all registers marked as unavailable.\n-m;void;guess_tracepoint_registers;struct regcache *regcache, CORE_ADDR addr;regcache, addr;;default_guess_tracepoint_registers;;0\n-\n-# Return the \"auto\" target charset.\n-f;const char *;auto_charset;void;;default_auto_charset;default_auto_charset;;0\n-# Return the \"auto\" target wide charset.\n-f;const char *;auto_wide_charset;void;;default_auto_wide_charset;default_auto_wide_charset;;0\n-\n-# If non-empty, this is a file extension that will be opened in place\n-# of the file extension reported by the shared library list.\n-#\n-# This is most useful for toolchains that use a post-linker tool,\n-# where the names of the files run on the target differ in extension\n-# compared to the names of the files GDB should load for debug info.\n-v;const char *;solib_symbols_extension;;;;;;;pstring (gdbarch->solib_symbols_extension)\n-\n-# If true, the target OS has DOS-based file system semantics.  That\n-# is, absolute paths include a drive name, and the backslash is\n-# considered a directory separator.\n-v;int;has_dos_based_file_system;;;0;0;;0\n-\n-# Generate bytecodes to collect the return address in a frame.\n-# Since the bytecodes run on the target, possibly with GDB not even\n-# connected, the full unwinding machinery is not available, and\n-# typically this function will issue bytecodes for one or more likely\n-# places that the return address may be found.\n-m;void;gen_return_address;struct agent_expr *ax, struct axs_value *value, CORE_ADDR scope;ax, value, scope;;default_gen_return_address;;0\n-\n-# Implement the \"info proc\" command.\n-M;void;info_proc;const char *args, enum info_proc_what what;args, what\n-\n-# Implement the \"info proc\" command for core files.  Noe that there\n-# are two \"info_proc\"-like methods on gdbarch -- one for core files,\n-# one for live targets.\n-M;void;core_info_proc;const char *args, enum info_proc_what what;args, what\n-\n-# Iterate over all objfiles in the order that makes the most sense\n-# for the architecture to make global symbol searches.\n-#\n-# CB is a callback function where OBJFILE is the objfile to be searched,\n-# and CB_DATA a pointer to user-defined data (the same data that is passed\n-# when calling this gdbarch method).  The iteration stops if this function\n-# returns nonzero.\n-#\n-# CB_DATA is a pointer to some user-defined data to be passed to\n-# the callback.\n-#\n-# If not NULL, CURRENT_OBJFILE corresponds to the objfile being\n-# inspected when the symbol search was requested.\n-m;void;iterate_over_objfiles_in_search_order;iterate_over_objfiles_in_search_order_cb_ftype *cb, void *cb_data, struct objfile *current_objfile;cb, cb_data, current_objfile;0;default_iterate_over_objfiles_in_search_order;;0\n-\n-# Ravenscar arch-dependent ops.\n-v;struct ravenscar_arch_ops *;ravenscar_ops;;;NULL;NULL;;0;host_address_to_string (gdbarch->ravenscar_ops)\n-\n-# Return non-zero if the instruction at ADDR is a call; zero otherwise.\n-m;int;insn_is_call;CORE_ADDR addr;addr;;default_insn_is_call;;0\n-\n-# Return non-zero if the instruction at ADDR is a return; zero otherwise.\n-m;int;insn_is_ret;CORE_ADDR addr;addr;;default_insn_is_ret;;0\n-\n-# Return non-zero if the instruction at ADDR is a jump; zero otherwise.\n-m;int;insn_is_jump;CORE_ADDR addr;addr;;default_insn_is_jump;;0\n-\n-# Return true if there's a program/permanent breakpoint planted in\n-# memory at ADDRESS, return false otherwise.\n-m;bool;program_breakpoint_here_p;CORE_ADDR address;address;;default_program_breakpoint_here_p;;0\n-\n-# Read one auxv entry from *READPTR, not reading locations >= ENDPTR.\n-# Return 0 if *READPTR is already at the end of the buffer.\n-# Return -1 if there is insufficient buffer for a whole entry.\n-# Return 1 if an entry was read into *TYPEP and *VALP.\n-M;int;auxv_parse;gdb_byte **readptr, gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp;readptr, endptr, typep, valp\n-\n-# Print the description of a single auxv entry described by TYPE and VAL\n-# to FILE.\n-m;void;print_auxv_entry;struct ui_file *file, CORE_ADDR type, CORE_ADDR val;file, type, val;;default_print_auxv_entry;;0\n-\n-# Find the address range of the current inferior's vsyscall/vDSO, and\n-# write it to *RANGE.  If the vsyscall's length can't be determined, a\n-# range with zero length is returned.  Returns true if the vsyscall is\n-# found, false otherwise.\n-m;int;vsyscall_range;struct mem_range *range;range;;default_vsyscall_range;;0\n-\n-# Allocate SIZE bytes of PROT protected page aligned memory in inferior.\n-# PROT has GDB_MMAP_PROT_* bitmask format.\n-# Throw an error if it is not possible.  Returned address is always valid.\n-f;CORE_ADDR;infcall_mmap;CORE_ADDR size, unsigned prot;size, prot;;default_infcall_mmap;;0\n-\n-# Deallocate SIZE bytes of memory at ADDR in inferior from gdbarch_infcall_mmap.\n-# Print a warning if it is not possible.\n-f;void;infcall_munmap;CORE_ADDR addr, CORE_ADDR size;addr, size;;default_infcall_munmap;;0\n-\n-# Return string (caller has to use xfree for it) with options for GCC\n-# to produce code for this target, typically \"-m64\", \"-m32\" or \"-m31\".\n-# These options are put before CU's DW_AT_producer compilation options so that\n-# they can override it.\n-m;std::string;gcc_target_options;void;;;default_gcc_target_options;;0\n-\n-# Return a regular expression that matches names used by this\n-# architecture in GNU configury triplets.  The result is statically\n-# allocated and must not be freed.  The default implementation simply\n-# returns the BFD architecture name, which is correct in nearly every\n-# case.\n-m;const char *;gnu_triplet_regexp;void;;;default_gnu_triplet_regexp;;0\n-\n-# Return the size in 8-bit bytes of an addressable memory unit on this\n-# architecture.  This corresponds to the number of 8-bit bytes associated to\n-# each address in memory.\n-m;int;addressable_memory_unit_size;void;;;default_addressable_memory_unit_size;;0\n-\n-# Functions for allowing a target to modify its disassembler options.\n-v;const char *;disassembler_options_implicit;;;0;0;;0;pstring (gdbarch->disassembler_options_implicit)\n-v;char **;disassembler_options;;;0;0;;0;pstring_ptr (gdbarch->disassembler_options)\n-v;const disasm_options_and_args_t *;valid_disassembler_options;;;0;0;;0;host_address_to_string (gdbarch->valid_disassembler_options)\n-\n-# Type alignment override method.  Return the architecture specific\n-# alignment required for TYPE.  If there is no special handling\n-# required for TYPE then return the value 0, GDB will then apply the\n-# default rules as laid out in gdbtypes.c:type_align.\n-m;ULONGEST;type_align;struct type *type;type;;default_type_align;;0\n-\n-# Return a string containing any flags for the given PC in the given FRAME.\n-f;std::string;get_pc_address_flags;frame_info *frame, CORE_ADDR pc;frame, pc;;default_get_pc_address_flags;;0\n-\n-# Read core file mappings\n-m;void;read_core_file_mappings;struct bfd *cbfd, read_core_file_mappings_pre_loop_ftype pre_loop_cb, read_core_file_mappings_loop_ftype loop_cb;cbfd, pre_loop_cb, loop_cb;;default_read_core_file_mappings;;0\n-\n-EOF\n-}\n-\n-#\n-# The .log file\n-#\n-exec > gdbarch.log\n-function_list | while do_read\n-do\n-    cat <<EOF\n-${class} ${returntype:-} ${function} (${formal:-})\n-EOF\n-    for r in ${read}\n-    do\n-\teval echo \"\\\"    ${r}=\\${${r}}\\\"\"\n-    done\n-    if class_is_predicate_p && fallback_default_p\n-    then\n-\techo \"Error: predicate function ${function} can not have a non- multi-arch default\" 1>&2\n-\tkill $$\n-\texit 1\n-    fi\n-    if [ \"x${invalid_p}\" = \"x0\" ] && [ -n \"${postdefault}\" ]\n-    then\n-\techo \"Error: postdefault is useless when invalid_p=0\" 1>&2\n-\tkill $$\n-\texit 1\n-    fi\n-    if class_is_multiarch_p\n-    then\n-\tif class_is_predicate_p ; then :\n-\telif test \"x${predefault}\" = \"x\"\n-\tthen\n-\t    echo \"Error: pure multi-arch function ${function} must have a predefault\" 1>&2\n-\t    kill $$\n-\t    exit 1\n-\tfi\n-    fi\n-    echo \"\"\n-done\n-\n-exec 1>&2\n-\n-\n-copyright ()\n-{\n-cat <<EOF\n-/* *INDENT-OFF* */ /* THIS FILE IS GENERATED -*- buffer-read-only: t -*- */\n-/* vi:set ro: */\n-\n-/* Dynamic architecture support for GDB, the GNU debugger.\n-\n-   Copyright (C) 1998-2021 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-/* This file was created with the aid of \\`\\`gdbarch.sh''.  */\n-\n-EOF\n-}\n-\n-exec > new-gdbarch-gen.h\n-copyright\n-\n-# function typedef's\n-printf \"\\n\"\n-printf \"\\n\"\n-printf \"/* The following are pre-initialized by GDBARCH.  */\\n\"\n-function_list | while do_read\n-do\n-    if class_is_info_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n-\tprintf \"/* set_gdbarch_%s() - not applicable - pre-initialized.  */\\n\" \"$function\"\n-    fi\n-done\n-\n-# function typedef's\n-printf \"\\n\"\n-printf \"\\n\"\n-printf \"/* The following are initialized by the target dependent code.  */\\n\"\n-function_list | while do_read\n-do\n-    if [ -n \"${comment}\" ]\n-    then\n-\techo \"${comment}\" | sed \\\n-\t    -e '2 s,#,/*,' \\\n-\t    -e '3,$ s,#,  ,' \\\n-\t    -e '$ s,$, */,'\n-    fi\n-\n-    if class_is_predicate_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"extern bool gdbarch_%s_p (struct gdbarch *gdbarch);\\n\" \"$function\"\n-    fi\n-    if class_is_variable_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n-\tprintf \"extern void set_gdbarch_%s (struct gdbarch *gdbarch, %s %s);\\n\" \"$function\" \"$returntype\" \"$function\"\n-    fi\n-    if class_is_function_p\n-    then\n-\tprintf \"\\n\"\n-\tif [ \"x${formal}\" = \"xvoid\" ] && class_is_multiarch_p\n-\tthen\n-\t    printf \"typedef %s (gdbarch_%s_ftype) (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n-\telif class_is_multiarch_p\n-\tthen\n-\t    printf \"typedef %s (gdbarch_%s_ftype) (struct gdbarch *gdbarch, %s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n-\telse\n-\t    printf \"typedef %s (gdbarch_%s_ftype) (%s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n-\tfi\n-\tif [ \"x${formal}\" = \"xvoid\" ]\n-\tthen\n-\t  printf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n-\telse\n-\t  printf \"extern %s gdbarch_%s (struct gdbarch *gdbarch, %s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n-\tfi\n-\tprintf \"extern void set_gdbarch_%s (struct gdbarch *gdbarch, gdbarch_%s_ftype *%s);\\n\" \"$function\" \"$function\" \"$function\"\n-    fi\n-done\n-\n-exec 1>&2\n-../move-if-change new-gdbarch-gen.h gdbarch-gen.h\n-rm -f new-gdbarch-gen.h\n-\n-\n-#\n-# C file\n-#\n-\n-exec > new-gdbarch.c\n-copyright\n-\n-# gdbarch open the gdbarch object\n-printf \"\\n\"\n-printf \"/* Maintain the struct gdbarch object.  */\\n\"\n-printf \"\\n\"\n-printf \"struct gdbarch\\n\"\n-printf \"{\\n\"\n-printf \"  /* Has this architecture been fully initialized?  */\\n\"\n-printf \"  int initialized_p;\\n\"\n-printf \"\\n\"\n-printf \"  /* An obstack bound to the lifetime of the architecture.  */\\n\"\n-printf \"  struct obstack *obstack;\\n\"\n-printf \"\\n\"\n-printf \"  /* basic architectural information.  */\\n\"\n-function_list | while do_read\n-do\n-    if class_is_info_p\n-    then\n-\tprintf \"  %s %s;\\n\" \"$returntype\" \"$function\"\n-    fi\n-done\n-printf \"\\n\"\n-printf \"  /* target specific vector.  */\\n\"\n-printf \"  struct gdbarch_tdep *tdep;\\n\"\n-printf \"  gdbarch_dump_tdep_ftype *dump_tdep;\\n\"\n-printf \"\\n\"\n-printf \"  /* per-architecture data-pointers.  */\\n\"\n-printf \"  unsigned nr_data;\\n\"\n-printf \"  void **data;\\n\"\n-printf \"\\n\"\n-cat <<EOF\n-  /* Multi-arch values.\n-\n-     When extending this structure you must:\n-\n-     Add the field below.\n-\n-     Declare set/get functions and define the corresponding\n-     macro in gdbarch.h.\n-\n-     gdbarch_alloc(): If zero/NULL is not a suitable default,\n-     initialize the new field.\n-\n-     verify_gdbarch(): Confirm that the target updated the field\n-     correctly.\n-\n-     gdbarch_dump(): Add a fprintf_unfiltered call so that the new\n-     field is dumped out\n-\n-     get_gdbarch(): Implement the set/get functions (probably using\n-     the macro's as shortcuts).\n-\n-     */\n-\n-EOF\n-function_list | while do_read\n-do\n-    if class_is_variable_p\n-    then\n-\tprintf \"  %s %s;\\n\" \"$returntype\" \"$function\"\n-    elif class_is_function_p\n-    then\n-\tprintf \"  gdbarch_%s_ftype *%s;\\n\" \"$function\" \"$function\"\n-    fi\n-done\n-printf \"};\\n\"\n-\n-# Create a new gdbarch struct\n-cat <<EOF\n-\n-/* Create a new \\`\\`struct gdbarch'' based on information provided by\n-   \\`\\`struct gdbarch_info''.  */\n-EOF\n-printf \"\\n\"\n-cat <<EOF\n-struct gdbarch *\n-gdbarch_alloc (const struct gdbarch_info *info,\n-\t       struct gdbarch_tdep *tdep)\n-{\n-  struct gdbarch *gdbarch;\n-\n-  /* Create an obstack for allocating all the per-architecture memory,\n-     then use that to allocate the architecture vector.  */\n-  struct obstack *obstack = XNEW (struct obstack);\n-  obstack_init (obstack);\n-  gdbarch = XOBNEW (obstack, struct gdbarch);\n-  memset (gdbarch, 0, sizeof (*gdbarch));\n-  gdbarch->obstack = obstack;\n-\n-  alloc_gdbarch_data (gdbarch);\n-\n-  gdbarch->tdep = tdep;\n-EOF\n-printf \"\\n\"\n-function_list | while do_read\n-do\n-    if class_is_info_p\n-    then\n-\tprintf \"  gdbarch->%s = info->%s;\\n\" \"$function\" \"$function\"\n-    fi\n-done\n-printf \"\\n\"\n-printf \"  /* Force the explicit initialization of these.  */\\n\"\n-function_list | while do_read\n-do\n-    if class_is_function_p || class_is_variable_p\n-    then\n-\tif [ -n \"${predefault}\" ] && [ \"x${predefault}\" != \"x0\" ]\n-\tthen\n-\t  printf \"  gdbarch->%s = %s;\\n\" \"$function\" \"$predefault\"\n-\tfi\n-    fi\n-done\n-cat <<EOF\n-  /* gdbarch_alloc() */\n-\n-  return gdbarch;\n-}\n-EOF\n-\n-# Free a gdbarch struct.\n-printf \"\\n\"\n-\n-# verify a new architecture\n-cat <<EOF\n-\n-\n-/* Ensure that all values in a GDBARCH are reasonable.  */\n-\n-static void\n-verify_gdbarch (struct gdbarch *gdbarch)\n-{\n-  string_file log;\n-\n-  /* fundamental */\n-  if (gdbarch->byte_order == BFD_ENDIAN_UNKNOWN)\n-    log.puts (\"\\n\\tbyte-order\");\n-  if (gdbarch->bfd_arch_info == NULL)\n-    log.puts (\"\\n\\tbfd_arch_info\");\n-  /* Check those that need to be defined for the given multi-arch level.  */\n-EOF\n-function_list | while do_read\n-do\n-    if class_is_function_p || class_is_variable_p\n-    then\n-\tif [ \"x${invalid_p}\" = \"x0\" ]\n-\tthen\n-\t    printf \"  /* Skip verify of %s, invalid_p == 0 */\\n\" \"$function\"\n-\telif class_is_predicate_p\n-\tthen\n-\t    printf \"  /* Skip verify of %s, has predicate.  */\\n\" \"$function\"\n-\t# FIXME: See do_read for potential simplification\n-\telif [ -n \"${invalid_p}\" ] && [ -n \"${postdefault}\" ]\n-\tthen\n-\t    printf \"  if (%s)\\n\" \"$invalid_p\"\n-\t    printf \"    gdbarch->%s = %s;\\n\" \"$function\" \"$postdefault\"\n-\telif [ -n \"${predefault}\" ] && [ -n \"${postdefault}\" ]\n-\tthen\n-\t    printf \"  if (gdbarch->%s == %s)\\n\" \"$function\" \"$predefault\"\n-\t    printf \"    gdbarch->%s = %s;\\n\" \"$function\" \"$postdefault\"\n-\telif [ -n \"${postdefault}\" ]\n-\tthen\n-\t    printf \"  if (gdbarch->%s == 0)\\n\" \"$function\"\n-\t    printf \"    gdbarch->%s = %s;\\n\" \"$function\" \"$postdefault\"\n-\telif [ -n \"${invalid_p}\" ]\n-\tthen\n-\t    printf \"  if (%s)\\n\" \"$invalid_p\"\n-\t    printf \"    log.puts (\\\"\\\\\\\\n\\\\\\\\t%s\\\");\\n\" \"$function\"\n-\telif [ -n \"${predefault}\" ]\n-\tthen\n-\t    printf \"  if (gdbarch->%s == %s)\\n\" \"$function\" \"$predefault\"\n-\t    printf \"    log.puts (\\\"\\\\\\\\n\\\\\\\\t%s\\\");\\n\" \"$function\"\n-\tfi\n-    fi\n-done\n-cat <<EOF\n-  if (!log.empty ())\n-    internal_error (__FILE__, __LINE__,\n-\t\t    _(\"verify_gdbarch: the following are invalid ...%s\"),\n-\t\t    log.c_str ());\n-}\n-EOF\n-\n-# dump the structure\n-printf \"\\n\"\n-printf \"\\n\"\n-cat <<EOF\n-/* Print out the details of the current architecture.  */\n-\n-void\n-gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n-{\n-  const char *gdb_nm_file = \"<not-defined>\";\n-\n-#if defined (GDB_NM_FILE)\n-  gdb_nm_file = GDB_NM_FILE;\n-#endif\n-  fprintf_unfiltered (file,\n-\t\t      \"gdbarch_dump: GDB_NM_FILE = %s\\\\n\",\n-\t\t      gdb_nm_file);\n-EOF\n-function_list | while do_read\n-do\n-    # First the predicate\n-    if class_is_predicate_p\n-    then\n-\tprintf \"  fprintf_unfiltered (file,\\n\"\n-\tprintf \"                      \\\"gdbarch_dump: gdbarch_%s_p() = %%d\\\\\\\\n\\\",\\n\" \"$function\"\n-\tprintf \"                      gdbarch_%s_p (gdbarch));\\n\" \"$function\"\n-    fi\n-    # Print the corresponding value.\n-    if class_is_function_p\n-    then\n-\tprintf \"  fprintf_unfiltered (file,\\n\"\n-\tprintf \"                      \\\"gdbarch_dump: %s = <%%s>\\\\\\\\n\\\",\\n\" \"$function\"\n-\tprintf \"                      host_address_to_string (gdbarch->%s));\\n\" \"$function\"\n-    else\n-\t# It is a variable\n-\tcase \"${print}:${returntype}\" in\n-\t    :CORE_ADDR )\n-\t\tfmt=\"%s\"\n-\t\tprint=\"core_addr_to_string_nz (gdbarch->${function})\"\n-\t\t;;\n-\t    :* )\n-\t\tfmt=\"%s\"\n-\t\tprint=\"plongest (gdbarch->${function})\"\n-\t\t;;\n-\t    * )\n-\t\tfmt=\"%s\"\n-\t\t;;\n-\tesac\n-\tprintf \"  fprintf_unfiltered (file,\\n\"\n-\tprintf \"                      \\\"gdbarch_dump: %s = %s\\\\\\\\n\\\",\\n\" \"$function\" \"$fmt\"\n-\tprintf \"                      %s);\\n\" \"$print\"\n-    fi\n-done\n-cat <<EOF\n-  if (gdbarch->dump_tdep != NULL)\n-    gdbarch->dump_tdep (gdbarch, file);\n-}\n-EOF\n-\n-\n-printf \"\\n\"\n-function_list | while do_read\n-do\n-    if class_is_predicate_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"bool\\n\"\n-\tprintf \"gdbarch_%s_p (struct gdbarch *gdbarch)\\n\" \"$function\"\n-\tprintf \"{\\n\"\n-\tprintf \"  gdb_assert (gdbarch != NULL);\\n\"\n-\tprintf \"  return %s;\\n\" \"$predicate\"\n-\tprintf \"}\\n\"\n-    fi\n-    if class_is_function_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"%s\\n\" \"$returntype\"\n-\tif [ \"x${formal}\" = \"xvoid\" ]\n-\tthen\n-\t  printf \"gdbarch_%s (struct gdbarch *gdbarch)\\n\" \"$function\"\n-\telse\n-\t  printf \"gdbarch_%s (struct gdbarch *gdbarch, %s)\\n\" \"$function\" \"$formal\"\n-\tfi\n-\tprintf \"{\\n\"\n-\tprintf \"  gdb_assert (gdbarch != NULL);\\n\"\n-\tprintf \"  gdb_assert (gdbarch->%s != NULL);\\n\" \"$function\"\n-\tif class_is_predicate_p && test -n \"${predefault}\"\n-\tthen\n-\t    # Allow a call to a function with a predicate.\n-\t    printf \"  /* Do not check predicate: %s, allow call.  */\\n\" \"$predicate\"\n-\tfi\n-\tprintf \"  if (gdbarch_debug >= 2)\\n\"\n-\tprintf \"    fprintf_unfiltered (gdb_stdlog, \\\"gdbarch_%s called\\\\\\\\n\\\");\\n\" \"$function\"\n-\tif [ \"x${actual:-}\" = \"x-\" ] || [ \"x${actual:-}\" = \"x\" ]\n-\tthen\n-\t    if class_is_multiarch_p\n-\t    then\n-\t\tparams=\"gdbarch\"\n-\t    else\n-\t\tparams=\"\"\n-\t    fi\n-\telse\n-\t    if class_is_multiarch_p\n-\t    then\n-\t\tparams=\"gdbarch, ${actual}\"\n-\t    else\n-\t\tparams=\"${actual}\"\n-\t    fi\n-\tfi\n-       \tif [ \"x${returntype}\" = \"xvoid\" ]\n-\tthen\n-\t  printf \"  gdbarch->%s (%s);\\n\" \"$function\" \"$params\"\n-\telse\n-\t  printf \"  return gdbarch->%s (%s);\\n\" \"$function\" \"$params\"\n-\tfi\n-\tprintf \"}\\n\"\n-\tprintf \"\\n\"\n-\tprintf \"void\\n\"\n-\tprintf \"set_gdbarch_%s (struct gdbarch *gdbarch,\\n\" \"$function\"\n-\tprintf \"            %s  gdbarch_%s_ftype %s)\\n\" \"$(echo \"$function\" | sed -e 's/./ /g')\" \"$function\" \"$function\"\n-\tprintf \"{\\n\"\n-\tprintf \"  gdbarch->%s = %s;\\n\" \"$function\" \"$function\"\n-\tprintf \"}\\n\"\n-    elif class_is_variable_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"%s\\n\" \"$returntype\"\n-\tprintf \"gdbarch_%s (struct gdbarch *gdbarch)\\n\" \"$function\"\n-\tprintf \"{\\n\"\n-\tprintf \"  gdb_assert (gdbarch != NULL);\\n\"\n-\tif [ \"x${invalid_p}\" = \"x0\" ]\n-\tthen\n-\t    printf \"  /* Skip verify of %s, invalid_p == 0 */\\n\" \"$function\"\n-\telif [ -n \"${invalid_p}\" ]\n-\tthen\n-\t    printf \"  /* Check variable is valid.  */\\n\"\n-\t    printf \"  gdb_assert (!(%s));\\n\" \"$invalid_p\"\n-\telif [ -n \"${predefault}\" ]\n-\tthen\n-\t    printf \"  /* Check variable changed from pre-default.  */\\n\"\n-\t    printf \"  gdb_assert (gdbarch->%s != %s);\\n\" \"$function\" \"$predefault\"\n-\tfi\n-\tprintf \"  if (gdbarch_debug >= 2)\\n\"\n-\tprintf \"    fprintf_unfiltered (gdb_stdlog, \\\"gdbarch_%s called\\\\\\\\n\\\");\\n\" \"$function\"\n-\tprintf \"  return gdbarch->%s;\\n\" \"$function\"\n-\tprintf \"}\\n\"\n-\tprintf \"\\n\"\n-\tprintf \"void\\n\"\n-\tprintf \"set_gdbarch_%s (struct gdbarch *gdbarch,\\n\" \"$function\"\n-\tprintf \"            %s  %s %s)\\n\" \"$(echo \"$function\" | sed -e 's/./ /g')\" \"$returntype\" \"$function\"\n-\tprintf \"{\\n\"\n-\tprintf \"  gdbarch->%s = %s;\\n\" \"$function\" \"$function\"\n-\tprintf \"}\\n\"\n-    elif class_is_info_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"%s\\n\" \"$returntype\"\n-\tprintf \"gdbarch_%s (struct gdbarch *gdbarch)\\n\" \"$function\"\n-\tprintf \"{\\n\"\n-\tprintf \"  gdb_assert (gdbarch != NULL);\\n\"\n-\tprintf \"  if (gdbarch_debug >= 2)\\n\"\n-\tprintf \"    fprintf_unfiltered (gdb_stdlog, \\\"gdbarch_%s called\\\\\\\\n\\\");\\n\" \"$function\"\n-\tprintf \"  return gdbarch->%s;\\n\" \"$function\"\n-\tprintf \"}\\n\"\n-    fi\n-done\n-\n-# close things off\n-exec 1>&2\n-../move-if-change new-gdbarch.c gdbarch.c\n-rm -f new-gdbarch.c\n-\n-exec > gdbarch-components.py\n-copyright | sed 1,3d | grep -v 'was created' |\n-    sed -e 's,/\\*,  ,' -e 's, *\\*/,,' -e 's/^  /#/'\n-\n-function_list | while do_read\n-do\n-    printf \"\\n\"\n-    if class_is_info_p; then\n-\tprintf Info\n-    elif class_is_variable_p; then\n-\tprintf Value\n-    elif class_is_multiarch_p; then\n-\tprintf Method\n-    elif class_is_function_p; then\n-\tprintf Function\n-    else\n-\techo FAILURE 1>&2\n-\texit 1\n-    fi\n-    printf \"(\\n\"\n-    if [ -n \"${comment}\" ]\n-    then\n-\tprintf \"    comment=\\\"\\\"\\\"\"\n-\techo \"${comment}\" | sed 's/^# *//'\n-\tprintf \"\\\"\\\"\\\",\\n\"\n-    fi\n-\n-    # The order here is picked to be type, name, params -- that way\n-    # it's relatively \"C-like\".\n-    printf \"    type=\\\"%s\\\",\\n\" \"$returntype\"\n-    printf \"    name=\\\"%s\\\",\\n\" \"$function\"\n-    if class_is_function_p; then\n-\tif test -n \"$formal\" && test \"$formal\" != void; then\n-\t    printf \"    params=[\\n\"\n-\t    # Turn TYPE NAME into (\"TYPE\", \"NAME\").\n-\t    echo \"$formal\" | sed -e \"s/, */,\\n/g\" |\n-\t\tsed -e 's/ *\\([a-zA-Z_][a-zA-Z0-9_]*\\)\\(,*\\)$/\", \"\\1\")\\2/' |\n-\t\tsed -e 's/^/        (\"/'\n-\t    printf \"    ],\\n\"\n-\telse\n-\t    printf \"    params=(),\\n\"\n-\tfi\n-    fi\n-    if class_is_predicate_p; then\n-\tprintf \"    predicate=True,\\n\"\n-    fi\n-    if ! class_is_info_p; then\n-\tif test -n \"$predefault\"; then\n-\t    printf \"    predefault=\\\"%s\\\",\\n\" \"$predefault\"\n-\tfi\n-\t# We can ignore 'actual' and 'staticdefault'.\n-\tif test -n \"$postdefault\"; then\n-\t    printf \"    postdefault=\\\"%s\\\",\\n\" \"$postdefault\"\n-\tfi\n-\t# Let's arrange for False to mean suppress checking, and True\n-\t# to mean default checking.\n-\tif test \"$invalid_p\" = \"0\"; then\n-\t    printf \"    invalid=False,\\n\"\n-\telif test \"$invalid_p\" = \"\"; then\n-\t    printf \"    invalid=True,\\n\"\n-\telse\n-\t    printf \"    invalid=\\\"%s\\\",\\n\" \"$invalid_p\"\n-\tfi\n-    fi\n-    if test -n \"$print\"; then\n-\tprintf \"    printer=\\\"%s\\\",\\n\" \"$print\"\n-    fi\n-    printf \")\\n\"\n-done\n-\n-exec 1>&2\n-black gdbarch-components.py"
    }
  ]
}