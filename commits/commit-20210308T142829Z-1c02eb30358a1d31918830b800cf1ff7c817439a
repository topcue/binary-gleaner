{
  "sha": "1c02eb30358a1d31918830b800cf1ff7c817439a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWMwMmViMzAzNThhMWQzMTkxODgzMGI4MDBjZjFmZjdjODE3NDM5YQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:29Z"
    },
    "message": "Introduce array_operation\n\nThis adds class array_operation, which implements OP_ARRAY.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* expop.h (class array_operation): New.\n\t* eval.c (array_operation::evaluate_struct_tuple)\n\t(array_operation::evaluate): New methods.",
    "tree": {
      "sha": "2fcec413594288270f0d80ffae631aff7f95f36e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2fcec413594288270f0d80ffae631aff7f95f36e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1c02eb30358a1d31918830b800cf1ff7c817439a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1c02eb30358a1d31918830b800cf1ff7c817439a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1c02eb30358a1d31918830b800cf1ff7c817439a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1c02eb30358a1d31918830b800cf1ff7c817439a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e447908052f54164eec481d15a5274ddf385569d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e447908052f54164eec481d15a5274ddf385569d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e447908052f54164eec481d15a5274ddf385569d"
    }
  ],
  "stats": {
    "total": 228,
    "additions": 228,
    "deletions": 0
  },
  "files": [
    {
      "sha": "03a7ff1fab27bdfbd82b8162699d21c4c8c8b223",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c02eb30358a1d31918830b800cf1ff7c817439a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c02eb30358a1d31918830b800cf1ff7c817439a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1c02eb30358a1d31918830b800cf1ff7c817439a",
      "patch": "@@ -1,3 +1,9 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* expop.h (class array_operation): New.\n+\t* eval.c (array_operation::evaluate_struct_tuple)\n+\t(array_operation::evaluate): New methods.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* expop.h (class adl_func_operation): New."
    },
    {
      "sha": "812068465d7be1da44aa74d597945944558dcb6a",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 200,
      "deletions": 0,
      "changes": 200,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c02eb30358a1d31918830b800cf1ff7c817439a/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c02eb30358a1d31918830b800cf1ff7c817439a/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=1c02eb30358a1d31918830b800cf1ff7c817439a",
      "patch": "@@ -2572,6 +2572,206 @@ adl_func_operation::evaluate (struct type *expect_type,\n \n }\n \n+/* This function evaluates brace-initializers (in C/C++) for\n+   structure types.  */\n+\n+struct value *\n+array_operation::evaluate_struct_tuple (struct value *struct_val,\n+\t\t\t\t\tstruct expression *exp,\n+\t\t\t\t\tenum noside noside, int nargs)\n+{\n+  const std::vector<operation_up> &in_args = std::get<2> (m_storage);\n+  struct type *struct_type = check_typedef (value_type (struct_val));\n+  struct type *field_type;\n+  int fieldno = -1;\n+\n+  int idx = 0;\n+  while (--nargs >= 0)\n+    {\n+      struct value *val = NULL;\n+      int bitpos, bitsize;\n+      bfd_byte *addr;\n+\n+      fieldno++;\n+      /* Skip static fields.  */\n+      while (fieldno < struct_type->num_fields ()\n+\t     && field_is_static (&struct_type->field (fieldno)))\n+\tfieldno++;\n+      if (fieldno >= struct_type->num_fields ())\n+\terror (_(\"too many initializers\"));\n+      field_type = struct_type->field (fieldno).type ();\n+      if (field_type->code () == TYPE_CODE_UNION\n+\t  && TYPE_FIELD_NAME (struct_type, fieldno)[0] == '0')\n+\terror (_(\"don't know which variant you want to set\"));\n+\n+      /* Here, struct_type is the type of the inner struct,\n+\t while substruct_type is the type of the inner struct.\n+\t These are the same for normal structures, but a variant struct\n+\t contains anonymous union fields that contain substruct fields.\n+\t The value fieldno is the index of the top-level (normal or\n+\t anonymous union) field in struct_field, while the value\n+\t subfieldno is the index of the actual real (named inner) field\n+\t in substruct_type.  */\n+\n+      field_type = struct_type->field (fieldno).type ();\n+      if (val == 0)\n+\tval = in_args[idx++]->evaluate (field_type, exp, noside);\n+\n+      /* Now actually set the field in struct_val.  */\n+\n+      /* Assign val to field fieldno.  */\n+      if (value_type (val) != field_type)\n+\tval = value_cast (field_type, val);\n+\n+      bitsize = TYPE_FIELD_BITSIZE (struct_type, fieldno);\n+      bitpos = TYPE_FIELD_BITPOS (struct_type, fieldno);\n+      addr = value_contents_writeable (struct_val) + bitpos / 8;\n+      if (bitsize)\n+\tmodify_field (struct_type, addr,\n+\t\t      value_as_long (val), bitpos % 8, bitsize);\n+      else\n+\tmemcpy (addr, value_contents (val),\n+\t\tTYPE_LENGTH (value_type (val)));\n+\n+    }\n+  return struct_val;\n+}\n+\n+value *\n+array_operation::evaluate (struct type *expect_type,\n+\t\t\t   struct expression *exp,\n+\t\t\t   enum noside noside)\n+{\n+  int tem;\n+  int tem2 = std::get<0> (m_storage);\n+  int tem3 = std::get<1> (m_storage);\n+  const std::vector<operation_up> &in_args = std::get<2> (m_storage);\n+  int nargs = tem3 - tem2 + 1;\n+  struct type *type = expect_type ? check_typedef (expect_type) : nullptr;\n+\n+  if (expect_type != nullptr && noside != EVAL_SKIP\n+      && type->code () == TYPE_CODE_STRUCT)\n+    {\n+      struct value *rec = allocate_value (expect_type);\n+\n+      memset (value_contents_raw (rec), '\\0', TYPE_LENGTH (type));\n+      return evaluate_struct_tuple (rec, exp, noside, nargs);\n+    }\n+\n+  if (expect_type != nullptr && noside != EVAL_SKIP\n+      && type->code () == TYPE_CODE_ARRAY)\n+    {\n+      struct type *range_type = type->index_type ();\n+      struct type *element_type = TYPE_TARGET_TYPE (type);\n+      struct value *array = allocate_value (expect_type);\n+      int element_size = TYPE_LENGTH (check_typedef (element_type));\n+      LONGEST low_bound, high_bound, index;\n+\n+      if (!get_discrete_bounds (range_type, &low_bound, &high_bound))\n+\t{\n+\t  low_bound = 0;\n+\t  high_bound = (TYPE_LENGTH (type) / element_size) - 1;\n+\t}\n+      index = low_bound;\n+      memset (value_contents_raw (array), 0, TYPE_LENGTH (expect_type));\n+      for (tem = nargs; --nargs >= 0;)\n+\t{\n+\t  struct value *element;\n+\n+\t  element = in_args[index - low_bound]->evaluate (element_type,\n+\t\t\t\t\t\t\t  exp, noside);\n+\t  if (value_type (element) != element_type)\n+\t    element = value_cast (element_type, element);\n+\t  if (index > high_bound)\n+\t    /* To avoid memory corruption.  */\n+\t    error (_(\"Too many array elements\"));\n+\t  memcpy (value_contents_raw (array)\n+\t\t  + (index - low_bound) * element_size,\n+\t\t  value_contents (element),\n+\t\t  element_size);\n+\t  index++;\n+\t}\n+      return array;\n+    }\n+\n+  if (expect_type != nullptr && noside != EVAL_SKIP\n+      && type->code () == TYPE_CODE_SET)\n+    {\n+      struct value *set = allocate_value (expect_type);\n+      gdb_byte *valaddr = value_contents_raw (set);\n+      struct type *element_type = type->index_type ();\n+      struct type *check_type = element_type;\n+      LONGEST low_bound, high_bound;\n+\n+      /* Get targettype of elementtype.  */\n+      while (check_type->code () == TYPE_CODE_RANGE\n+\t     || check_type->code () == TYPE_CODE_TYPEDEF)\n+\tcheck_type = TYPE_TARGET_TYPE (check_type);\n+\n+      if (!get_discrete_bounds (element_type, &low_bound, &high_bound))\n+\terror (_(\"(power)set type with unknown size\"));\n+      memset (valaddr, '\\0', TYPE_LENGTH (type));\n+      int idx = 0;\n+      for (tem = 0; tem < nargs; tem++)\n+\t{\n+\t  LONGEST range_low, range_high;\n+\t  struct type *range_low_type, *range_high_type;\n+\t  struct value *elem_val;\n+\n+\t  elem_val = in_args[idx++]->evaluate (element_type, exp, noside);\n+\t  range_low_type = range_high_type = value_type (elem_val);\n+\t  range_low = range_high = value_as_long (elem_val);\n+\n+\t  /* Check types of elements to avoid mixture of elements from\n+\t     different types. Also check if type of element is \"compatible\"\n+\t     with element type of powerset.  */\n+\t  if (range_low_type->code () == TYPE_CODE_RANGE)\n+\t    range_low_type = TYPE_TARGET_TYPE (range_low_type);\n+\t  if (range_high_type->code () == TYPE_CODE_RANGE)\n+\t    range_high_type = TYPE_TARGET_TYPE (range_high_type);\n+\t  if ((range_low_type->code () != range_high_type->code ())\n+\t      || (range_low_type->code () == TYPE_CODE_ENUM\n+\t\t  && (range_low_type != range_high_type)))\n+\t    /* different element modes.  */\n+\t    error (_(\"POWERSET tuple elements of different mode\"));\n+\t  if ((check_type->code () != range_low_type->code ())\n+\t      || (check_type->code () == TYPE_CODE_ENUM\n+\t\t  && range_low_type != check_type))\n+\t    error (_(\"incompatible POWERSET tuple elements\"));\n+\t  if (range_low > range_high)\n+\t    {\n+\t      warning (_(\"empty POWERSET tuple range\"));\n+\t      continue;\n+\t    }\n+\t  if (range_low < low_bound || range_high > high_bound)\n+\t    error (_(\"POWERSET tuple element out of range\"));\n+\t  range_low -= low_bound;\n+\t  range_high -= low_bound;\n+\t  for (; range_low <= range_high; range_low++)\n+\t    {\n+\t      int bit_index = (unsigned) range_low % TARGET_CHAR_BIT;\n+\n+\t      if (gdbarch_byte_order (exp->gdbarch) == BFD_ENDIAN_BIG)\n+\t\tbit_index = TARGET_CHAR_BIT - 1 - bit_index;\n+\t      valaddr[(unsigned) range_low / TARGET_CHAR_BIT]\n+\t\t|= 1 << bit_index;\n+\t    }\n+\t}\n+      return set;\n+    }\n+\n+  value **argvec = XALLOCAVEC (struct value *, nargs);\n+  for (tem = 0; tem < nargs; tem++)\n+    {\n+      /* Ensure that array expressions are coerced into pointer\n+\t objects.  */\n+      argvec[tem] = in_args[tem]->evaluate_with_coercion (exp, noside);\n+    }\n+  if (noside == EVAL_SKIP)\n+    return eval_skip_value (exp);\n+  return value_array (tem2, tem3, argvec);\n+}\n+\n }\n \n struct value *"
    },
    {
      "sha": "9b5c4ea35e44b6f771a4385bba03c15f72685d20",
      "filename": "gdb/expop.h",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c02eb30358a1d31918830b800cf1ff7c817439a/gdb/expop.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c02eb30358a1d31918830b800cf1ff7c817439a/gdb/expop.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expop.h?ref=1c02eb30358a1d31918830b800cf1ff7c817439a",
      "patch": "@@ -2049,6 +2049,28 @@ class adl_func_operation\n   { return OP_ADL_FUNC; }\n };\n \n+/* The OP_ARRAY operation.  */\n+class array_operation\n+  : public tuple_holding_operation<int, int, std::vector<operation_up>>\n+{\n+public:\n+\n+  using tuple_holding_operation::tuple_holding_operation;\n+\n+  value *evaluate (struct type *expect_type,\n+\t\t   struct expression *exp,\n+\t\t   enum noside noside) override;\n+\n+  enum exp_opcode opcode () const override\n+  { return OP_ARRAY; }\n+\n+private:\n+\n+  struct value *evaluate_struct_tuple (struct value *struct_val,\n+\t\t\t\t       struct expression *exp,\n+\t\t\t\t       enum noside noside, int nargs);\n+};\n+\n } /* namespace expr */\n \n #endif /* EXPOP_H */"
    }
  ]
}