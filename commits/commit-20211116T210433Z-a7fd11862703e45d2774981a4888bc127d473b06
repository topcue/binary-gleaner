{
  "sha": "a7fd11862703e45d2774981a4888bc127d473b06",
  "node_id": "C_kwDOANOeidoAKGE3ZmQxMTg2MjcwM2U0NWQyNzc0OTgxYTQ4ODhiYzEyN2Q0NzNiMDY",
  "commit": {
    "author": {
      "name": "Fangrui Song",
      "email": "maskray@google.com",
      "date": "2021-11-16T21:03:57Z"
    },
    "committer": {
      "name": "Fangrui Song",
      "email": "maskray@google.com",
      "date": "2021-11-16T21:04:33Z"
    },
    "message": "readelf: Support SHT_RELR/DT_RELR for -r\n\nThe -r output for SHT_RELR looks like:\n\nRelocation section '.relr.dyn' at offset 0x530 contains 4 entries:\n  7 offsets\n00000000000028c0\n00000000000028c8\n0000000000003ad0\n0000000000003ad8\n0000000000003ae0\n0000000000003ae8\n0000000000003af0\n\nFor --use-dynamic, the header looks like\n\n    'RELR' relocation section at offset 0x530 contains 32 bytes:\n\ninclude/\n    * elf/common.h (DT_ENCODING): Bump to 38.\n    * elf/external.h (Elf32_External_Relr): New.\n    (Elf64_External_Relr): New.\nbinutils/\n    * readelf.c (enum relocation_type): New.\n    (slurp_relr_relocs): New.\n    (dump_relocations): Change is_rela to rel_type.\n    Dump RELR.\n    (dynamic_relocations): Add DT_RELR.\n    (process_relocs): Check SHT_RELR and DT_RELR.\n    (process_dynamic_section): Store into dynamic_info for\n    DT_RELR/DT_RELRENT/DT_RELRSZ.",
    "tree": {
      "sha": "6caa5fcbd7a7b71a0b6ab895a2bf9a4a00193fa9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6caa5fcbd7a7b71a0b6ab895a2bf9a4a00193fa9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a7fd11862703e45d2774981a4888bc127d473b06",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a7fd11862703e45d2774981a4888bc127d473b06",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a7fd11862703e45d2774981a4888bc127d473b06",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a7fd11862703e45d2774981a4888bc127d473b06/comments",
  "author": {
    "login": "MaskRay",
    "id": 416322,
    "node_id": "MDQ6VXNlcjQxNjMyMg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/416322?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MaskRay",
    "html_url": "https://github.com/MaskRay",
    "followers_url": "https://api.github.com/users/MaskRay/followers",
    "following_url": "https://api.github.com/users/MaskRay/following{/other_user}",
    "gists_url": "https://api.github.com/users/MaskRay/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MaskRay/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MaskRay/subscriptions",
    "organizations_url": "https://api.github.com/users/MaskRay/orgs",
    "repos_url": "https://api.github.com/users/MaskRay/repos",
    "events_url": "https://api.github.com/users/MaskRay/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MaskRay/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "MaskRay",
    "id": 416322,
    "node_id": "MDQ6VXNlcjQxNjMyMg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/416322?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MaskRay",
    "html_url": "https://github.com/MaskRay",
    "followers_url": "https://api.github.com/users/MaskRay/followers",
    "following_url": "https://api.github.com/users/MaskRay/following{/other_user}",
    "gists_url": "https://api.github.com/users/MaskRay/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MaskRay/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MaskRay/subscriptions",
    "organizations_url": "https://api.github.com/users/MaskRay/orgs",
    "repos_url": "https://api.github.com/users/MaskRay/repos",
    "events_url": "https://api.github.com/users/MaskRay/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MaskRay/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "830070c66d25e6749b7159009f1d87d85f02eaa3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/830070c66d25e6749b7159009f1d87d85f02eaa3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/830070c66d25e6749b7159009f1d87d85f02eaa3"
    }
  ],
  "stats": {
    "total": 183,
    "additions": 153,
    "deletions": 30
  },
  "files": [
    {
      "sha": "8d2f0413f9f4a7c2322fb0f9966147189213849a",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a7fd11862703e45d2774981a4888bc127d473b06/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a7fd11862703e45d2774981a4888bc127d473b06/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=a7fd11862703e45d2774981a4888bc127d473b06",
      "patch": "@@ -1,3 +1,14 @@\n+2021-11-16  Fangrui Song  <maskray@google.com>\n+\n+\t* readelf.c (enum relocation_type): New.\n+\t(slurp_relr_relocs): New.\n+\t(dump_relocations): Change is_rela to rel_type.\n+\tDump RELR.\n+\t(dynamic_relocations): Add DT_RELR.\n+\t(process_relocs): Check SHT_RELR and DT_RELR.\n+\t(process_dynamic_section): Store into dynamic_info for\n+\tDT_RELR/DT_RELRENT/DT_RELRSZ.\n+\n 2021-11-09  Nick Clifton  <nickc@redhat.com>\n \n \t* nm.c: Add --unicode option to control how unicode characters are"
    },
    {
      "sha": "f3881250fce4dc02b498a4e20205068c235b68ed",
      "filename": "binutils/NEWS",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a7fd11862703e45d2774981a4888bc127d473b06/binutils/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a7fd11862703e45d2774981a4888bc127d473b06/binutils/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/NEWS?ref=a7fd11862703e45d2774981a4888bc127d473b06",
      "patch": "@@ -11,6 +11,8 @@\n   using --unicode=highlight will display them as unicode escape sequences\n   highlighted in red (if supported by the output device).\n \n+* readelf -r dumps RELR relative relocations now.\n+\n Changes in 2.37:\n \n * The readelf tool has a new command line option which can be used to specify"
    },
    {
      "sha": "116f879c892a05e3297332c17194a5d1a540f659",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 125,
      "deletions": 29,
      "changes": 154,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a7fd11862703e45d2774981a4888bc127d473b06/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a7fd11862703e45d2774981a4888bc127d473b06/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=a7fd11862703e45d2774981a4888bc127d473b06",
      "patch": "@@ -342,7 +342,14 @@ typedef enum unicode_display_type\n \n static unicode_display_type unicode_display = unicode_default;\n \n-  \n+typedef enum\n+{\n+  reltype_unknown,\n+  reltype_rel,\n+  reltype_rela,\n+  reltype_relr\n+} relocation_type;\n+\n /* Versioned symbol info.  */\n enum versioned_symbol_info\n {\n@@ -1354,6 +1361,76 @@ slurp_rel_relocs (Filedata *            filedata,\n   return true;\n }\n \n+static bool\n+slurp_relr_relocs (Filedata * filedata,\n+\t\t   unsigned long relr_offset,\n+\t\t   unsigned long relr_size,\n+\t\t   bfd_vma ** relrsp,\n+\t\t   unsigned long * nrelrsp)\n+{\n+  void *relrs;\n+  size_t size = 0, nentries, i;\n+  bfd_vma base = 0, addr, entry;\n+\n+  relrs = get_data (NULL, filedata, relr_offset, 1, relr_size,\n+\t\t    _(\"RELR relocation data\"));\n+  if (!relrs)\n+    return false;\n+\n+  if (is_32bit_elf)\n+    nentries = relr_size / sizeof (Elf32_External_Relr);\n+  else\n+    nentries = relr_size / sizeof (Elf64_External_Relr);\n+  for (i = 0; i < nentries; i++)\n+    {\n+      if (is_32bit_elf)\n+\tentry = BYTE_GET (((Elf32_External_Relr *)relrs)[i].r_data);\n+      else\n+\tentry = BYTE_GET (((Elf64_External_Relr *)relrs)[i].r_data);\n+      if ((entry & 1) == 0)\n+\tsize++;\n+      else\n+\twhile ((entry >>= 1) != 0)\n+\t  if ((entry & 1) == 1)\n+\t    size++;\n+    }\n+\n+  *relrsp = (bfd_vma *) xmalloc (size * sizeof (bfd_vma));\n+  if (*relrsp == NULL)\n+    {\n+      free (relrs);\n+      error (_(\"out of memory parsing relocs\\n\"));\n+      return false;\n+    }\n+\n+  size = 0;\n+  for (i = 0; i < nentries; i++)\n+    {\n+      const bfd_vma entry_bytes = is_32bit_elf ? 4 : 8;\n+\n+      if (is_32bit_elf)\n+\tentry = BYTE_GET (((Elf32_External_Relr *)relrs)[i].r_data);\n+      else\n+\tentry = BYTE_GET (((Elf64_External_Relr *)relrs)[i].r_data);\n+      if ((entry & 1) == 0)\n+\t{\n+\t  (*relrsp)[size++] = entry;\n+\t  base = entry + entry_bytes;\n+\t}\n+      else\n+\t{\n+\t  for (addr = base; (entry >>= 1) != 0; addr += entry_bytes)\n+\t    if ((entry & 1) != 0)\n+\t      (*relrsp)[size++] = addr;\n+\t  base += entry_bytes * (entry_bytes * CHAR_BIT - 1);\n+\t}\n+    }\n+\n+  *nrelrsp = size;\n+  free (relrs);\n+  return true;\n+}\n+\n /* Returns the reloc type extracted from the reloc info field.  */\n \n static unsigned int\n@@ -1406,30 +1483,46 @@ dump_relocations (Filedata *          filedata,\n \t\t  unsigned long       nsyms,\n \t\t  char *              strtab,\n \t\t  unsigned long       strtablen,\n-\t\t  int                 is_rela,\n+\t\t  relocation_type     rel_type,\n \t\t  bool                is_dynsym)\n {\n   unsigned long i;\n   Elf_Internal_Rela * rels;\n   bool res = true;\n \n-  if (is_rela == UNKNOWN)\n-    is_rela = guess_is_rela (filedata->file_header.e_machine);\n+  if (rel_type == reltype_unknown)\n+    rel_type = guess_is_rela (filedata->file_header.e_machine) ? reltype_rela : reltype_rel;\n \n-  if (is_rela)\n+  if (rel_type == reltype_rela)\n     {\n       if (!slurp_rela_relocs (filedata, rel_offset, rel_size, &rels, &rel_size))\n \treturn false;\n     }\n-  else\n+  else if (rel_type == reltype_rel)\n     {\n       if (!slurp_rel_relocs (filedata, rel_offset, rel_size, &rels, &rel_size))\n \treturn false;\n     }\n+  else if (rel_type == reltype_relr)\n+    {\n+      bfd_vma * relrs;\n+      const char *format\n+\t  = is_32bit_elf ? \"%08\" BFD_VMA_FMT \"x\\n\" : \"%016\" BFD_VMA_FMT \"x\\n\";\n+\n+      if (!slurp_relr_relocs (filedata, rel_offset, rel_size, &relrs,\n+\t\t\t      &rel_size))\n+\treturn false;\n+\n+      printf (ngettext (\"  %lu offset\\n\", \"  %lu offsets\\n\", rel_size), rel_size);\n+      for (i = 0; i < rel_size; i++)\n+\tprintf (format, relrs[i]);\n+      free (relrs);\n+      return true;\n+    }\n \n   if (is_32bit_elf)\n     {\n-      if (is_rela)\n+      if (rel_type == reltype_rela)\n \t{\n \t  if (do_wide)\n \t    printf (_(\" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\\n\"));\n@@ -1446,7 +1539,7 @@ dump_relocations (Filedata *          filedata,\n     }\n   else\n     {\n-      if (is_rela)\n+      if (rel_type == reltype_rela)\n \t{\n \t  if (do_wide)\n \t    printf (_(\"    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\\n\"));\n@@ -1841,7 +1934,7 @@ dump_relocations (Filedata *          filedata,\n       if (filedata->file_header.e_machine == EM_ALPHA\n \t  && rtype != NULL\n \t  && streq (rtype, \"R_ALPHA_LITUSE\")\n-\t  && is_rela)\n+\t  && rel_type == reltype_rela)\n \t{\n \t  switch (rels[i].r_addend)\n \t    {\n@@ -1989,7 +2082,7 @@ dump_relocations (Filedata *          filedata,\n \t\t\t    version_string);\n \t\t}\n \n-\t      if (is_rela)\n+\t      if (rel_type == reltype_rela)\n \t\t{\n \t\t  bfd_vma off = rels[i].r_addend;\n \n@@ -2000,7 +2093,7 @@ dump_relocations (Filedata *          filedata,\n \t\t}\n \t    }\n \t}\n-      else if (is_rela)\n+      else if (rel_type == reltype_rela)\n \t{\n \t  bfd_vma off = rels[i].r_addend;\n \n@@ -8021,13 +8114,14 @@ static struct\n   const char * name;\n   int reloc;\n   int size;\n-  int rela;\n+  relocation_type rel_type;\n }\n   dynamic_relocations [] =\n {\n-  { \"REL\", DT_REL, DT_RELSZ, false },\n-  { \"RELA\", DT_RELA, DT_RELASZ, true },\n-  { \"PLT\", DT_JMPREL, DT_PLTRELSZ, UNKNOWN }\n+  { \"REL\", DT_REL, DT_RELSZ, reltype_rel },\n+  { \"RELA\", DT_RELA, DT_RELASZ, reltype_rela },\n+  { \"RELR\", DT_RELR, DT_RELRSZ, reltype_relr },\n+  { \"PLT\", DT_JMPREL, DT_PLTRELSZ, reltype_unknown }\n };\n \n /* Process the reloc section.  */\n@@ -8043,7 +8137,7 @@ process_relocs (Filedata * filedata)\n \n   if (do_using_dynamic)\n     {\n-      int          is_rela;\n+      relocation_type rel_type;\n       const char * name;\n       bool  has_dynamic_reloc;\n       unsigned int i;\n@@ -8052,24 +8146,24 @@ process_relocs (Filedata * filedata)\n \n       for (i = 0; i < ARRAY_SIZE (dynamic_relocations); i++)\n \t{\n-\t  is_rela = dynamic_relocations [i].rela;\n+\t  rel_type = dynamic_relocations [i].rel_type;\n \t  name = dynamic_relocations [i].name;\n \t  rel_size = filedata->dynamic_info[dynamic_relocations [i].size];\n \t  rel_offset = filedata->dynamic_info[dynamic_relocations [i].reloc];\n \n \t  if (rel_size)\n \t    has_dynamic_reloc = true;\n \n-\t  if (is_rela == UNKNOWN)\n+\t  if (rel_type == reltype_unknown)\n \t    {\n \t      if (dynamic_relocations [i].reloc == DT_JMPREL)\n \t\tswitch (filedata->dynamic_info[DT_PLTREL])\n \t\t  {\n \t\t  case DT_REL:\n-\t\t    is_rela = false;\n+\t\t    rel_type = reltype_rel;\n \t\t    break;\n \t\t  case DT_RELA:\n-\t\t    is_rela = true;\n+\t\t    rel_type = reltype_rela;\n \t\t    break;\n \t\t  }\n \t    }\n@@ -8092,7 +8186,7 @@ process_relocs (Filedata * filedata)\n \t\t\t\tfiledata->num_dynamic_syms,\n \t\t\t\tfiledata->dynamic_strings,\n \t\t\t\tfiledata->dynamic_strings_length,\n-\t\t\t\tis_rela, true /* is_dynamic */);\n+\t\t\t\trel_type, true /* is_dynamic */);\n \t    }\n \t}\n \n@@ -8120,15 +8214,16 @@ process_relocs (Filedata * filedata)\n \t   i++, section++)\n \t{\n \t  if (   section->sh_type != SHT_RELA\n-\t      && section->sh_type != SHT_REL)\n+\t      && section->sh_type != SHT_REL\n+\t      && section->sh_type != SHT_RELR)\n \t    continue;\n \n \t  rel_offset = section->sh_offset;\n \t  rel_size   = section->sh_size;\n \n \t  if (rel_size)\n \t    {\n-\t      int is_rela;\n+\t      relocation_type rel_type;\n \t      unsigned long num_rela;\n \n \t      if (filedata->is_separate)\n@@ -8148,7 +8243,8 @@ process_relocs (Filedata * filedata)\n \t\t\t\tnum_rela),\n \t\t      rel_offset, num_rela);\n \n-\t      is_rela = section->sh_type == SHT_RELA;\n+\t      rel_type = section->sh_type == SHT_RELA ? reltype_rela :\n+\t\tsection->sh_type == SHT_REL ? reltype_rel : reltype_relr;\n \n \t      if (section->sh_link != 0\n \t\t  && section->sh_link < filedata->file_header.e_shnum)\n@@ -8170,15 +8266,14 @@ process_relocs (Filedata * filedata)\n \n \t\t  dump_relocations (filedata, rel_offset, rel_size,\n \t\t\t\t    symtab, nsyms, strtab, strtablen,\n-\t\t\t\t    is_rela,\n+\t\t\t\t    rel_type,\n \t\t\t\t    symsec->sh_type == SHT_DYNSYM);\n \t\t  free (strtab);\n \t\t  free (symtab);\n \t\t}\n \t      else\n \t\tdump_relocations (filedata, rel_offset, rel_size,\n-\t\t\t\t  NULL, 0, NULL, 0, is_rela,\n-\t\t\t\t  false /* is_dynamic */);\n+\t\t\t\t  NULL, 0, NULL, 0, rel_type, false /* is_dynamic */);\n \n \t      found = true;\n \t    }\n@@ -11499,6 +11594,7 @@ the .dynstr section doesn't match the DT_STRTAB and DT_STRSZ tags\\n\"));\n \tcase DT_RPATH\t:\n \tcase DT_SYMBOLIC:\n \tcase DT_REL\t:\n+\tcase DT_RELR    :\n \tcase DT_DEBUG\t:\n \tcase DT_TEXTREL\t:\n \tcase DT_JMPREL\t:\n@@ -11555,15 +11651,15 @@ the .dynstr section doesn't match the DT_STRTAB and DT_STRSZ tags\\n\"));\n \tcase DT_STRSZ\t:\n \tcase DT_RELSZ\t:\n \tcase DT_RELAENT\t:\n+\tcase DT_RELRENT\t:\n+\tcase DT_RELRSZ\t:\n \tcase DT_SYMENT\t:\n \tcase DT_RELENT\t:\n \t  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;\n \t  /* Fall through.  */\n \tcase DT_PLTPADSZ:\n \tcase DT_MOVEENT\t:\n \tcase DT_MOVESZ\t:\n-\tcase DT_RELRENT\t:\n-\tcase DT_RELRSZ\t:\n \tcase DT_PREINIT_ARRAYSZ:\n \tcase DT_INIT_ARRAYSZ:\n \tcase DT_FINI_ARRAYSZ:"
    },
    {
      "sha": "52483238ffb7508a4aa8e66a357f299dc450fef3",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a7fd11862703e45d2774981a4888bc127d473b06/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a7fd11862703e45d2774981a4888bc127d473b06/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=a7fd11862703e45d2774981a4888bc127d473b06",
      "patch": "@@ -1,3 +1,9 @@\n+2021-11-16  Fangrui Song  <maskray@google.com>\n+\n+\t* elf/common.h (DT_ENCODING): Bump to 38.\n+\t* elf/external.h (Elf32_External_Relr): New.\n+\t(Elf64_External_Relr): New.\n+\n 2021-09-07  Luis Machado  <luis.machado@linaro.org>\n \n \tRevert: [AArch64] MTE corefile support"
    },
    {
      "sha": "5d31e35ec8953f97e7bf0b7a4c06ecc6ec0c5b8b",
      "filename": "include/elf/common.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a7fd11862703e45d2774981a4888bc127d473b06/include/elf/common.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a7fd11862703e45d2774981a4888bc127d473b06/include/elf/common.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/elf/common.h?ref=a7fd11862703e45d2774981a4888bc127d473b06",
      "patch": "@@ -1102,13 +1102,13 @@\n #define DT_FINI_ARRAYSZ 28\n #define DT_RUNPATH\t29\n #define DT_FLAGS\t30\n-#define DT_ENCODING\t32\n #define DT_PREINIT_ARRAY   32\n #define DT_PREINIT_ARRAYSZ 33\n #define DT_SYMTAB_SHNDX    34\n #define DT_RELRSZ\t35\n #define DT_RELR\t\t36\n #define DT_RELRENT\t37\n+#define DT_ENCODING\t38\n \n /* Note, the Oct 4, 1999 draft of the ELF ABI changed the values\n    for DT_LOOS and DT_HIOS.  Some implementations however, use"
    },
    {
      "sha": "815e39c2837690330409d2694fb93025887a6e20",
      "filename": "include/elf/external.h",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a7fd11862703e45d2774981a4888bc127d473b06/include/elf/external.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a7fd11862703e45d2774981a4888bc127d473b06/include/elf/external.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/elf/external.h?ref=a7fd11862703e45d2774981a4888bc127d473b06",
      "patch": "@@ -211,6 +211,10 @@ typedef struct {\n   unsigned char\tr_addend[4];\t/* Constant addend used to compute value */\n } Elf32_External_Rela;\n \n+typedef struct {\n+  unsigned char r_data[4];\t/* RELR entry */\n+} Elf32_External_Relr;\n+\n typedef struct {\n   unsigned char r_offset[8];\t/* Location at which to apply the action */\n   unsigned char\tr_info[8];\t/* index and type of relocation */\n@@ -222,6 +226,10 @@ typedef struct {\n   unsigned char\tr_addend[8];\t/* Constant addend used to compute value */\n } Elf64_External_Rela;\n \n+typedef struct {\n+  unsigned char r_data[8];\t/* RELR entry */\n+} Elf64_External_Relr;\n+\n /* dynamic section structure */\n \n typedef struct {"
    }
  ]
}