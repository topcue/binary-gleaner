{
  "sha": "1f8d2881175920d389078852bb1ff0799d744599",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWY4ZDI4ODExNzU5MjBkMzg5MDc4ODUyYmIxZmYwNzk5ZDc0NDU5OQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-09T18:51:57Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-12-09T18:51:57Z"
    },
    "message": "gdb: make get_discrete_bounds return bool\n\nget_discrete_bounds currently has three possible return values (see its\ncurrent doc for details).  It appears that for all callers, it would be\nsufficient to have a boolean \"worked\" / \"didn't work\" return value.\n\nChange the return type of get_discrete_bounds to bool and adjust all\ncallers.  Doing so simplifies the following patch.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (get_discrete_bounds): Return bool, adjust all\n\tcallers.\n\t* gdbtypes.c (get_discrete_bounds): Return bool.\n\nChange-Id: Ie51feee23c75f0cd7939742604282d745db59172",
    "tree": {
      "sha": "983b6e53db1f95649e8f90c94fe01f7f15b4c443",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/983b6e53db1f95649e8f90c94fe01f7f15b4c443"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1f8d2881175920d389078852bb1ff0799d744599",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f8d2881175920d389078852bb1ff0799d744599",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1f8d2881175920d389078852bb1ff0799d744599",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f8d2881175920d389078852bb1ff0799d744599/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6244c1196a49a5732ac3667b4df0f157cf681d7b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6244c1196a49a5732ac3667b4df0f157cf681d7b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6244c1196a49a5732ac3667b4df0f157cf681d7b"
    }
  ],
  "stats": {
    "total": 108,
    "additions": 58,
    "deletions": 50
  },
  "files": [
    {
      "sha": "e7f083ca58f5c8a4ec43ea469e60cf08a6f8d8bc",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -1,3 +1,9 @@\n+2020-12-09  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (get_discrete_bounds): Return bool, adjust all\n+\tcallers.\n+\t* gdbtypes.c (get_discrete_bounds): Return bool.\n+\n 2020-12-09  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* ada-lang.c (ada_value_slice_from_ptr): Adjust."
    },
    {
      "sha": "5e2f1ece9654513bdc2218578c79f674d77c8048",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -2112,7 +2112,7 @@ constrained_packed_array_type (struct type *type, long *elt_bits)\n \n   if ((check_typedef (index_type)->code () == TYPE_CODE_RANGE\n        && is_dynamic_type (check_typedef (index_type)))\n-      || get_discrete_bounds (index_type, &low_bound, &high_bound) < 0)\n+      || !get_discrete_bounds (index_type, &low_bound, &high_bound))\n     low_bound = high_bound = 0;\n   if (high_bound < low_bound)\n     *elt_bits = TYPE_LENGTH (new_type) = 0;\n@@ -2182,7 +2182,7 @@ recursively_update_array_bitsize (struct type *type)\n   gdb_assert (type->code () == TYPE_CODE_ARRAY);\n \n   LONGEST low, high;\n-  if (get_discrete_bounds (type->index_type (), &low, &high) < 0\n+  if (!get_discrete_bounds (type->index_type (), &low, &high)\n       || low > high)\n     return 0;\n   LONGEST our_len = high - low + 1;\n@@ -2299,7 +2299,7 @@ value_subscript_packed (struct value *arr, int arity, struct value **ind)\n \t  LONGEST lowerbound, upperbound;\n \t  LONGEST idx;\n \n-\t  if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)\n+\t  if (!get_discrete_bounds (range_type, &lowerbound, &upperbound))\n \t    {\n \t      lim_warning (_(\"don't know bounds of array\"));\n \t      lowerbound = upperbound = 0;"
    },
    {
      "sha": "7d17f410c9268362872169144e7b4e84ed6db8eb",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -136,7 +136,7 @@ val_print_packed_array_elements (struct type *type, const gdb_byte *valaddr,\n   {\n     LONGEST high;\n \n-    if (get_discrete_bounds (index_type, &low, &high) < 0)\n+    if (!get_discrete_bounds (index_type, &low, &high))\n       len = 1;\n     else if (low > high)\n       {"
    },
    {
      "sha": "c2db47e11e251963f81b83cb327ef02ce211aed9",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -698,8 +698,8 @@ evaluate_subexp_c (struct type *expect_type, struct expression *exp,\n \t\tLONGEST low_bound, high_bound;\n \t\tint element_size = TYPE_LENGTH (type);\n \n-\t\tif (get_discrete_bounds (expect_type->index_type (),\n-\t\t\t\t\t &low_bound, &high_bound) < 0)\n+\t\tif (!get_discrete_bounds (expect_type->index_type (),\n+\t\t\t\t\t  &low_bound, &high_bound))\n \t\t  {\n \t\t    low_bound = 0;\n \t\t    high_bound = (TYPE_LENGTH (expect_type) / element_size) - 1;"
    },
    {
      "sha": "5eb6ce1a2638ae98fba114a5cfb25492f17446aa",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -1386,7 +1386,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t  int element_size = TYPE_LENGTH (check_typedef (element_type));\n \t  LONGEST low_bound, high_bound, index;\n \n-\t  if (get_discrete_bounds (range_type, &low_bound, &high_bound) < 0)\n+\t  if (!get_discrete_bounds (range_type, &low_bound, &high_bound))\n \t    {\n \t      low_bound = 0;\n \t      high_bound = (TYPE_LENGTH (type) / element_size) - 1;\n@@ -1426,7 +1426,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t\t || check_type->code () == TYPE_CODE_TYPEDEF)\n \t    check_type = TYPE_TARGET_TYPE (check_type);\n \n-\t  if (get_discrete_bounds (element_type, &low_bound, &high_bound) < 0)\n+\t  if (!get_discrete_bounds (element_type, &low_bound, &high_bound))\n \t    error (_(\"(power)set type with unknown size\"));\n \t  memset (valaddr, '\\0', TYPE_LENGTH (type));\n \t  for (tem = 0; tem < nargs; tem++)"
    },
    {
      "sha": "c202df6c65fbacdf780a5e2c9ad1e330aaa0cda3",
      "filename": "gdb/f-array-walker.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/f-array-walker.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/f-array-walker.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-array-walker.h?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -42,7 +42,7 @@ class fortran_array_offset_calculator\n \n     /* Get the range, and extract the bounds.  */\n     struct type *range_type = type->index_type ();\n-    if (get_discrete_bounds (range_type, &m_lowerbound, &m_upperbound) < 0)\n+    if (!get_discrete_bounds (range_type, &m_lowerbound, &m_upperbound))\n       error (\"unable to read array bounds\");\n \n     /* Figure out the stride for this array.  */\n@@ -198,7 +198,7 @@ class fortran_array_walker\n     /* Extract the range, and get lower and upper bounds.  */\n     struct type *range_type = check_typedef (type)->index_type ();\n     LONGEST lowerbound, upperbound;\n-    if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)\n+    if (!get_discrete_bounds (range_type, &lowerbound, &upperbound))\n       error (\"failed to get range bounds\");\n \n     /* CALC is used to calculate the offsets for each element in this"
    },
    {
      "sha": "bbece501799378a1897748a9c40c2847dfc702ae",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -1404,7 +1404,7 @@ fortran_adjust_dynamic_array_base_address_hack (struct type *type,\n       tmp_type = check_typedef (tmp_type);\n       struct type *range_type = tmp_type->index_type ();\n       LONGEST lowerbound, upperbound, stride;\n-      if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)\n+      if (!get_discrete_bounds (range_type, &lowerbound, &upperbound))\n \terror (\"failed to get range bounds\");\n \n       /* Figure out the stride for this dimension.  */"
    },
    {
      "sha": "f1b19b58aab4f805067f80417b8190e2d677f2cc",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 24,
      "deletions": 29,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -1036,15 +1036,9 @@ has_static_range (const struct range_bounds *bounds)\n \t  && bounds->stride.kind () == PROP_CONST);\n }\n \n+/* See gdbtypes.h.  */\n \n-/* Set *LOWP and *HIGHP to the lower and upper bounds of discrete type\n-   TYPE.\n-\n-   Return 1 if type is a range type with two defined, constant bounds.\n-   Else, return 0 if it is discrete (and bounds will fit in LONGEST).\n-   Else, return -1.  */\n-\n-int\n+bool\n get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n {\n   type = check_typedef (type);\n@@ -1055,7 +1049,7 @@ get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n \t constant bounds.  */\n       if (type->bounds ()->low.kind () != PROP_CONST\n \t  || type->bounds ()->high.kind () != PROP_CONST)\n-\treturn -1;\n+\treturn false;\n \n       *lowp = type->bounds ()->low.const_val ();\n       *highp = type->bounds ()->high.const_val ();\n@@ -1065,20 +1059,17 @@ get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n \t  gdb::optional<LONGEST> low_pos\n \t    = discrete_position (TYPE_TARGET_TYPE (type), *lowp);\n \n-\t  if (!low_pos.has_value ())\n-\t    return 0;\n-\n-\t  *lowp = *low_pos;\n+\t  if (low_pos.has_value ())\n+\t    *lowp = *low_pos;\n \n \t  gdb::optional<LONGEST> high_pos\n \t    = discrete_position (TYPE_TARGET_TYPE (type), *highp);\n \n-\t  if (!high_pos.has_value ())\n-\t    return 0;\n-\n-\t  *highp = *high_pos;\n+\t  if (high_pos.has_value ())\n+\t    *highp = *high_pos;\n \t}\n-      return 1;\n+      return true;\n+\n     case TYPE_CODE_ENUM:\n       if (type->num_fields () > 0)\n \t{\n@@ -1104,19 +1095,22 @@ get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n \t  *lowp = 0;\n \t  *highp = -1;\n \t}\n-      return 0;\n+      return true;\n+\n     case TYPE_CODE_BOOL:\n       *lowp = 0;\n       *highp = 1;\n-      return 0;\n+      return true;\n+\n     case TYPE_CODE_INT:\n       if (TYPE_LENGTH (type) > sizeof (LONGEST))\t/* Too big */\n-\treturn -1;\n+\treturn false;\n+\n       if (!type->is_unsigned ())\n \t{\n \t  *lowp = -(1 << (TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1));\n \t  *highp = -*lowp - 1;\n-\t  return 0;\n+\t  return true;\n \t}\n       /* fall through */\n     case TYPE_CODE_CHAR:\n@@ -1126,9 +1120,10 @@ get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n \t if TYPE_LENGTH (type) == sizeof (LONGEST).  */\n       *highp = 1 << (TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1);\n       *highp = (*highp - 1) | *highp;\n-      return 0;\n+      return true;\n+\n     default:\n-      return -1;\n+      return false;\n     }\n }\n \n@@ -1140,13 +1135,11 @@ get_array_bounds (struct type *type, LONGEST *low_bound, LONGEST *high_bound)\n   struct type *index = type->index_type ();\n   LONGEST low = 0;\n   LONGEST high = 0;\n-  int res;\n \n   if (index == NULL)\n     return false;\n \n-  res = get_discrete_bounds (index, &low, &high);\n-  if (res == -1)\n+  if (!get_discrete_bounds (index, &low, &high))\n     return false;\n \n   if (low_bound)\n@@ -1223,8 +1216,9 @@ update_static_array_size (struct type *type)\n       if (stride == 0)\n \tstride = range_type->bit_stride ();\n \n-      if (get_discrete_bounds (range_type, &low_bound, &high_bound) < 0)\n+      if (!get_discrete_bounds (range_type, &low_bound, &high_bound))\n \tlow_bound = high_bound = 0;\n+\n       element_type = check_typedef (TYPE_TARGET_TYPE (type));\n       /* Be careful when setting the array length.  Ada arrays can be\n \t empty arrays with the high_bound being smaller than the low_bound.\n@@ -1420,8 +1414,9 @@ create_set_type (struct type *result_type, struct type *domain_type)\n     {\n       LONGEST low_bound, high_bound, bit_length;\n \n-      if (get_discrete_bounds (domain_type, &low_bound, &high_bound) < 0)\n+      if (!get_discrete_bounds (domain_type, &low_bound, &high_bound))\n \tlow_bound = high_bound = 0;\n+\n       bit_length = high_bound - low_bound + 1;\n       TYPE_LENGTH (result_type)\n \t= (bit_length + TARGET_CHAR_BIT - 1) / TARGET_CHAR_BIT;"
    },
    {
      "sha": "19d07405d63d7a82fcad04437256401be4a38b3a",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -2466,7 +2466,13 @@ extern struct type *lookup_template_type (const char *, struct type *,\n \n extern int get_vptr_fieldno (struct type *, struct type **);\n \n-extern int get_discrete_bounds (struct type *, LONGEST *, LONGEST *);\n+/* Set *LOWP and *HIGHP to the lower and upper bounds of discrete type\n+   TYPE.\n+\n+   Return true if the two bounds are available, false otherwise.  */\n+\n+extern bool get_discrete_bounds (struct type *type, LONGEST *lowp,\n+\t\t\t\t LONGEST *highp);\n \n /* Assuming TYPE is a simple, non-empty array type, compute its upper\n    and lower bound.  Save the low bound into LOW_BOUND if not NULL."
    },
    {
      "sha": "20a3d131476adfbdccada9751df83c3271c3ce53",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -372,7 +372,7 @@ m2_is_long_set (struct type *type)\n \t\t\t    This should be integrated into gdbtypes.c\n \t\t\t    inside get_discrete_bounds.  */\n \n-static int\n+static bool\n m2_get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n {\n   type = check_typedef (type);\n@@ -419,7 +419,7 @@ m2_is_long_set_of_type (struct type *type, struct type **of_type)\n       l1 = type->field (i).type ()->bounds ()->low.const_val ();\n       h1 = type->field (len - 1).type ()->bounds ()->high.const_val ();\n       *of_type = target;\n-      if (m2_get_discrete_bounds (target, &l2, &h2) >= 0)\n+      if (m2_get_discrete_bounds (target, &l2, &h2))\n \treturn (l1 == l2 && h1 == h2);\n       error (_(\"long_set failed to find discrete bounds for its subtype\"));\n       return 0;"
    },
    {
      "sha": "542fa492d068e077e0f348373e3b3825b32544b3",
      "filename": "gdb/m2-valprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/m2-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/m2-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-valprint.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -97,7 +97,7 @@ m2_print_long_set (struct type *type, const gdb_byte *valaddr,\n \n   target = TYPE_TARGET_TYPE (range);\n \n-  if (get_discrete_bounds (range, &field_low, &field_high) >= 0)\n+  if (get_discrete_bounds (range, &field_low, &field_high))\n     {\n       for (i = low_bound; i <= high_bound; i++)\n \t{\n@@ -137,7 +137,7 @@ m2_print_long_set (struct type *type, const gdb_byte *valaddr,\n \t      if (field == len)\n \t\tbreak;\n \t      range = type->field (field).type ()->index_type ();\n-\t      if (get_discrete_bounds (range, &field_low, &field_high) < 0)\n+\t      if (!get_discrete_bounds (range, &field_low, &field_high))\n \t\tbreak;\n \t      target = TYPE_TARGET_TYPE (range);\n \t    }\n@@ -399,7 +399,7 @@ m2_language::value_print_inner (struct value *val, struct ui_file *stream,\n \n \t  fputs_filtered (\"{\", stream);\n \n-\t  i = get_discrete_bounds (range, &low_bound, &high_bound);\n+\t  i = get_discrete_bounds (range, &low_bound, &high_bound) ? 0 : -1;\n \tmaybe_bad_bstring:\n \t  if (i < 0)\n \t    {"
    },
    {
      "sha": "8f785b71ea43333308702fd45530736a1c3b6b91",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -343,7 +343,8 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n \n \t  fputs_filtered (\"[\", stream);\n \n-\t  int bound_info = get_discrete_bounds (range, &low_bound, &high_bound);\n+\t  int bound_info = (get_discrete_bounds (range, &low_bound, &high_bound)\n+\t\t\t    ? 0 : -1);\n \t  if (low_bound == 0 && high_bound == -1 && TYPE_LENGTH (type) > 0)\n \t    {\n \t      /* If we know the size of the set type, we can figure out the"
    },
    {
      "sha": "077bcb41dd822928533c090f0b4981f1f647af35",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -1949,7 +1949,7 @@ value_bit_index (struct type *type, const gdb_byte *valaddr, int index)\n   unsigned rel_index;\n   struct type *range = type->index_type ();\n \n-  if (get_discrete_bounds (range, &low_bound, &high_bound) < 0)\n+  if (!get_discrete_bounds (range, &low_bound, &high_bound))\n     return -2;\n   if (index < low_bound || index > high_bound)\n     return -1;"
    },
    {
      "sha": "09e97d2d3b9797f8b587aea7f12ac653d26f2028",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f8d2881175920d389078852bb1ff0799d744599/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f8d2881175920d389078852bb1ff0799d744599/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=1f8d2881175920d389078852bb1ff0799d744599",
      "patch": "@@ -453,7 +453,7 @@ value_cast (struct type *type, struct value *arg2)\n \t  int val_length = TYPE_LENGTH (type2);\n \t  LONGEST low_bound, high_bound, new_length;\n \n-\t  if (get_discrete_bounds (range_type, &low_bound, &high_bound) < 0)\n+\t  if (!get_discrete_bounds (range_type, &low_bound, &high_bound))\n \t    low_bound = 0, high_bound = 0;\n \t  new_length = val_length / element_length;\n \t  if (val_length % element_length != 0)\n@@ -3948,7 +3948,7 @@ value_slice (struct value *array, int lowbound, int length)\n     error (_(\"array not associated\"));\n \n   range_type = array_type->index_type ();\n-  if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)\n+  if (!get_discrete_bounds (range_type, &lowerbound, &upperbound))\n     error (_(\"slice from bad array or bitstring\"));\n \n   if (lowbound < lowerbound || length < 0"
    }
  ]
}