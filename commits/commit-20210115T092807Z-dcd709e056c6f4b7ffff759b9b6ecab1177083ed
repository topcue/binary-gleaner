{
  "sha": "dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGNkNzA5ZTA1NmM2ZjRiN2ZmZmY3NTliOWI2ZWNhYjExNzcwODNlZA==",
  "commit": {
    "author": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-01-13T02:05:48Z"
    },
    "committer": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-01-15T09:28:07Z"
    },
    "message": "RISC-V: Comments tidy and improvement.\n\nThe GNU coding standards said the comments should be complete sentences\nand end with a period and two spaces.  But sometimes it should be more\ncleaner when the comments only include a word or codes.  Therefore, I made\nthe following changes after referring to other target/generic codes,\n\n* Try to write sentences in comments, must end with a period and two spaces.\n* End with two spaces without a period for codes/instructions only.\n* End with one space without a period for a single word/variable only.\n\nBesids, also rewrite/remove some comments which are obsolete or too long,\nand fix indents for comments.\n\nbfd/\n    * elfnn-riscv.c: Comments tidy and improvement.\n    * elfxx-riscv.c: Likewise.\n    * elfxx-riscv.h: Likewise.\ngas/\n    * config/tc-riscv.c: Comments tidy and improvement.  Also update\n    comment \"fallthru\" to \"Fall through\" that end with a period and\n    two spaces.\ninclude/\n    * elf/riscv.h: Comments tidy and improvement.\n    * opcode/riscv-opc.h: Likewise.\n    * opcode/riscv.h: Likewise.\nopcodes/\n    * riscv-dis.c: Comments tidy and improvement.\n    * riscv-opc.c: Likewise.",
    "tree": {
      "sha": "57ecb316b9099ab4d0be806f9c0ab281816801f7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/57ecb316b9099ab4d0be806f9c0ab281816801f7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "bb3eddb5bd60b56cf19a0aacfd6b56a1b32d21a7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb3eddb5bd60b56cf19a0aacfd6b56a1b32d21a7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bb3eddb5bd60b56cf19a0aacfd6b56a1b32d21a7"
    }
  ],
  "stats": {
    "total": 582,
    "additions": 275,
    "deletions": 307
  },
  "files": [
    {
      "sha": "3f349ac1009bb9e8ac81d9814050f2d617551123",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -1,3 +1,9 @@\n+2021-01-15  Nelson Chu  <nelson.chu@sifive.com>\n+\n+\t* elfnn-riscv.c: Comments tidy and improvement.\n+\t* elfxx-riscv.c: Likewise.\n+\t* elfxx-riscv.h: Likewise.\n+\n 2021-01-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR ld/26688"
    },
    {
      "sha": "c0864c9de11f658b9b72700a6d1c9c4295bde359",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 49,
      "deletions": 49,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -133,7 +133,6 @@ struct riscv_elf_link_hash_table\n };\n \n /* Instruction access functions. */\n-\n #define riscv_get_insn(bits, ptr)\t\t\\\n   ((bits) == 16 ? bfd_getl16 (ptr)\t\t\\\n    : (bits) == 32 ? bfd_getl32 (ptr)\t\t\\\n@@ -185,14 +184,11 @@ riscv_is_insn_reloc (const reloc_howto_type *howto)\n }\n \n /* PLT/GOT stuff.  */\n-\n #define PLT_HEADER_INSNS 8\n #define PLT_ENTRY_INSNS 4\n #define PLT_HEADER_SIZE (PLT_HEADER_INSNS * 4)\n #define PLT_ENTRY_SIZE (PLT_ENTRY_INSNS * 4)\n-\n #define GOT_ENTRY_SIZE RISCV_ELF_WORD_BYTES\n-\n /* Reserve two entries of GOTPLT for ld.so, one is used for PLT resolver,\n    the other is used for link map.  Other targets also reserve one more\n    entry used for runtime profile?  */\n@@ -230,7 +226,7 @@ riscv_make_plt_header (bfd *output_bfd, bfd_vma gotplt_addr, bfd_vma addr,\n      addi   t0, t2, %lo(.got.plt)    # &.got.plt\n      srli   t1, t1, log2(16/PTRSIZE) # .got.plt offset\n      l[w|d] t0, PTRSIZE(t0)\t     # link map\n-     jr\t    t3 */\n+     jr\t    t3  */\n \n   entry[0] = RISCV_UTYPE (AUIPC, X_T2, gotplt_offset_high);\n   entry[1] = RISCV_RTYPE (SUB, X_T1, X_T1, X_T3);\n@@ -261,7 +257,7 @@ riscv_make_plt_entry (bfd *output_bfd, bfd_vma got, bfd_vma addr,\n   /* auipc  t3, %hi(.got.plt entry)\n      l[w|d] t3, %lo(.got.plt entry)(t3)\n      jalr   t1, t3\n-     nop */\n+     nop  */\n \n   entry[0] = RISCV_UTYPE (AUIPC, X_T3, RISCV_PCREL_HIGH_PART (got, addr));\n   entry[1] = RISCV_ITYPE (LREG,  X_T3, X_T3, RISCV_PCREL_LOW_PART (got, addr));\n@@ -302,9 +298,9 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n }\n \n /* Compute a hash of a local hash entry.  We use elf_link_hash_entry\n-  for local symbol so that we can handle local STT_GNU_IFUNC symbols\n-  as global symbol.  We reuse indx and dynstr_index for local symbol\n-  hash since they aren't used by global symbols in this backend.  */\n+   for local symbol so that we can handle local STT_GNU_IFUNC symbols\n+   as global symbol.  We reuse indx and dynstr_index for local symbol\n+   hash since they aren't used by global symbols in this backend.  */\n \n static hashval_t\n riscv_elf_local_htab_hash (const void *ptr)\n@@ -618,6 +614,7 @@ bad_static_reloc (bfd *abfd, unsigned r_type, struct elf_link_hash_entry *h)\n   bfd_set_error (bfd_error_bad_value);\n   return FALSE;\n }\n+\n /* Look through the relocs for a section during the first phase, and\n    allocate space in the global offset table or procedure linkage\n    table.  */\n@@ -743,8 +740,8 @@ riscv_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \n \tcase R_RISCV_CALL:\n \tcase R_RISCV_CALL_PLT:\n-\t  /* These symbol requires a procedure linkage table entry.  We\n-\t     actually build the entry in adjust_dynamic_symbol,\n+\t  /* These symbol requires a procedure linkage table entry.\n+\t     We actually build the entry in adjust_dynamic_symbol,\n \t     because these might be a case of linking PIC code without\n \t     linking in any dynamic objects, in which case we don't\n \t     need to generate a procedure linkage table after all.  */\n@@ -1806,24 +1803,24 @@ riscv_zero_pcrel_hi_reloc (Elf_Internal_Rela *rel,\n \t\t\t   bfd *input_bfd ATTRIBUTE_UNUSED)\n {\n   /* We may need to reference low addreses in PC-relative modes even when the\n-   * PC is far away from these addresses.  For example, undefweak references\n-   * need to produce the address 0 when linked.  As 0 is far from the arbitrary\n-   * addresses that we can link PC-relative programs at, the linker can't\n-   * actually relocate references to those symbols.  In order to allow these\n-   * programs to work we simply convert the PC-relative auipc sequences to\n-   * 0-relative lui sequences.  */\n+     PC is far away from these addresses.  For example, undefweak references\n+     need to produce the address 0 when linked.  As 0 is far from the arbitrary\n+     addresses that we can link PC-relative programs at, the linker can't\n+     actually relocate references to those symbols.  In order to allow these\n+     programs to work we simply convert the PC-relative auipc sequences to\n+     0-relative lui sequences.  */\n   if (bfd_link_pic (info))\n     return FALSE;\n \n   /* If it's possible to reference the symbol using auipc we do so, as that's\n-   * more in the spirit of the PC-relative relocations we're processing.  */\n+     more in the spirit of the PC-relative relocations we're processing.  */\n   bfd_vma offset = addr - pc;\n   if (ARCH_SIZE == 32 || VALID_UTYPE_IMM (RISCV_CONST_HIGH_PART (offset)))\n     return FALSE;\n \n   /* If it's impossible to reference this with a LUI-based offset then don't\n-   * bother to convert it at all so users still see the PC-relative relocation\n-   * in the truncation message.  */\n+     bother to convert it at all so users still see the PC-relative relocation\n+     in the truncation message.  */\n   if (ARCH_SIZE > 32 && !VALID_UTYPE_IMM (RISCV_CONST_HIGH_PART (addr)))\n     return FALSE;\n \n@@ -3305,7 +3302,7 @@ riscv_float_abi_string (flagword flags)\n     }\n }\n \n-/* The information of architecture attribute.  */\n+/* The information of architecture elf attributes.  */\n static riscv_subset_list_t in_subsets;\n static riscv_subset_list_t out_subsets;\n static riscv_subset_list_t merged_subsets;\n@@ -3382,11 +3379,10 @@ riscv_i_or_e_p (bfd *ibfd,\n \n    Arguments:\n      `bfd`: bfd handler.\n-     `in_arch`: Raw arch string for input object.\n-     `out_arch`: Raw arch string for output object.\n-     `pin`: subset list for input object, and it'll skip all merged subset after\n-            merge.\n-     `pout`: Like `pin`, but for output object.  */\n+     `in_arch`: Raw ISA string for input object.\n+     `out_arch`: Raw ISA string for output object.\n+     `pin`: Subset list for input object.\n+     `pout`: Subset list for output object.  */\n \n static bfd_boolean\n riscv_merge_std_ext (bfd *ibfd,\n@@ -3555,7 +3551,7 @@ riscv_merge_arch_attr_info (bfd *ibfd, char *in_arch, char *out_arch)\n   if (in_arch != NULL && out_arch == NULL)\n     return in_arch;\n \n-  /* Parse subset from arch string.  */\n+  /* Parse subset from ISA string.  */\n   if (!riscv_parse_subset (&rpe_in, in_arch))\n     return NULL;\n \n@@ -3660,7 +3656,7 @@ riscv_merge_attributes (bfd *ibfd, struct bfd_link_info *info)\n \telse if (in_attr[Tag_RISCV_arch].s\n \t\t && out_attr[Tag_RISCV_arch].s)\n \t  {\n-\t    /* Check arch compatible.  */\n+\t    /* Check compatible.  */\n \t    char *merged_arch =\n \t\triscv_merge_arch_attr_info (ibfd,\n \t\t\t\t\t    in_attr[Tag_RISCV_arch].s,\n@@ -3678,7 +3674,7 @@ riscv_merge_attributes (bfd *ibfd, struct bfd_link_info *info)\n       case Tag_RISCV_priv_spec:\n       case Tag_RISCV_priv_spec_minor:\n       case Tag_RISCV_priv_spec_revision:\n-\t/* If we have handled the priv attributes, then skip it.  */\n+\t/* If we have handled the privileged elf attributes, then skip it.  */\n \tif (!priv_attrs_merged)\n \t  {\n \t    unsigned int Tag_a = Tag_RISCV_priv_spec;\n@@ -3687,7 +3683,7 @@ riscv_merge_attributes (bfd *ibfd, struct bfd_link_info *info)\n \t    enum riscv_priv_spec_class in_priv_spec;\n \t    enum riscv_priv_spec_class out_priv_spec;\n \n-\t    /* Get the priv spec class from elf attribute numbers.  */\n+\t    /* Get the privileged spec class from elf attributes.  */\n \t    riscv_get_priv_spec_class_from_numbers (in_attr[Tag_a].i,\n \t\t\t\t\t\t    in_attr[Tag_b].i,\n \t\t\t\t\t\t    in_attr[Tag_c].i,\n@@ -3697,7 +3693,7 @@ riscv_merge_attributes (bfd *ibfd, struct bfd_link_info *info)\n \t\t\t\t\t\t    out_attr[Tag_c].i,\n \t\t\t\t\t\t    &out_priv_spec);\n \n-\t    /* Allow to link the object without the priv specs.  */\n+\t    /* Allow to link the object without the privileged specs.  */\n \t    if (out_priv_spec == PRIV_SPEC_CLASS_NONE)\n \t      {\n \t\tout_attr[Tag_a].i = in_attr[Tag_a].i;\n@@ -3718,10 +3714,9 @@ riscv_merge_attributes (bfd *ibfd, struct bfd_link_info *info)\n \t\t   out_attr[Tag_b].i,\n \t\t   out_attr[Tag_c].i);\n \n-\t\t/* The priv spec v1.9.1 can not be linked with other spec\n-\t\t   versions since the conflicts.  We plan to drop the\n-\t\t   v1.9.1 in a year or two, so this confict should be\n-\t\t   removed in the future.  */\n+\t\t/* The privileged spec v1.9.1 can not be linked with others\n+\t\t   since the conflicts, so we plan to drop it in a year or\n+\t\t   two.  */\n \t\tif (in_priv_spec == PRIV_SPEC_CLASS_1P9P1\n \t\t    || out_priv_spec == PRIV_SPEC_CLASS_1P9P1)\n \t\t  {\n@@ -3730,7 +3725,7 @@ riscv_merge_attributes (bfd *ibfd, struct bfd_link_info *info)\n \t\t\t \"linked with other spec versions\"));\n \t\t  }\n \n-\t\t/* Update the output priv spec to the newest one.  */\n+\t\t/* Update the output privileged spec to the newest one.  */\n \t\tif (in_priv_spec > out_priv_spec)\n \t\t  {\n \t\t    out_attr[Tag_a].i = in_attr[Tag_a].i;\n@@ -3938,8 +3933,9 @@ riscv_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr, size_t count,\n \t call to SYMBOL as well. Since both __wrap_SYMBOL and SYMBOL reference\n \t the same symbol (which is __wrap_SYMBOL), but still exist as two\n \t different symbols in 'sym_hashes', we don't want to adjust\n-\t the global symbol __wrap_SYMBOL twice.  */\n-      /* The same problem occurs with symbols that are versioned_hidden, as\n+\t the global symbol __wrap_SYMBOL twice.\n+\n+         The same problem occurs with symbols that are versioned_hidden, as\n \t foo becomes an alias for foo@BAR, and hence they need the same\n \t treatment.  */\n       if (link_info->wrap_hash != NULL\n@@ -4177,9 +4173,9 @@ _bfd_riscv_relax_call (bfd *abfd, asection *sec, asection *sym_sec,\n       r_type = R_RISCV_JAL;\n       auipc = MATCH_JAL | (rd << OP_SH_RD);\n     }\n-  else /* near_zero */\n+  else\n     {\n-      /* Relax to JALR rd, x0, addr.  */\n+      /* Near zero, relax to JALR rd, x0, addr.  */\n       r_type = R_RISCV_LO12_I;\n       auipc = MATCH_JALR | (rd << OP_SH_RD);\n     }\n@@ -4212,7 +4208,7 @@ _bfd_riscv_get_max_alignment (asection *sec)\n   return (bfd_vma) 1 << max_alignment_power;\n }\n \n-/* Relax non-PIC global variable references.  */\n+/* Relax non-PIC global variable references to GP-relative references.  */\n \n static bfd_boolean\n _bfd_riscv_relax_lui (bfd *abfd,\n@@ -4325,7 +4321,7 @@ _bfd_riscv_relax_lui (bfd *abfd,\n   return TRUE;\n }\n \n-/* Relax non-PIC TLS references.  */\n+/* Relax non-PIC TLS references to TP-relative references.  */\n \n static bfd_boolean\n _bfd_riscv_relax_tls_le (bfd *abfd,\n@@ -4446,7 +4442,7 @@ _bfd_riscv_relax_pc  (bfd *abfd ATTRIBUTE_UNUSED,\n   BFD_ASSERT (rel->r_offset + 4 <= sec->size);\n \n   /* Chain the _LO relocs to their cooresponding _HI reloc to compute the\n-   * actual target address.  */\n+     actual target address.  */\n   riscv_pcgp_hi_reloc hi_reloc;\n   memset (&hi_reloc, 0, sizeof (hi_reloc));\n   switch (ELFNN_R_TYPE (rel->r_info))\n@@ -4486,7 +4482,7 @@ _bfd_riscv_relax_pc  (bfd *abfd ATTRIBUTE_UNUSED,\n \treturn TRUE;\n \n       /* If the cooresponding lo relocation has already been seen then it's not\n-       * safe to relax this relocation.  */\n+         safe to relax this relocation.  */\n       if (riscv_find_pcgp_lo_reloc (pcgp_relocs, rel->r_offset))\n \treturn TRUE;\n \n@@ -4577,7 +4573,7 @@ _bfd_riscv_relax_pc  (bfd *abfd ATTRIBUTE_UNUSED,\n   return TRUE;\n }\n \n-/* Relax PC-relative references to GP-relative references.  */\n+/* Delete the bytes for R_RISCV_DELETE.  */\n \n static bfd_boolean\n _bfd_riscv_relax_delete (bfd *abfd,\n@@ -4599,9 +4595,12 @@ _bfd_riscv_relax_delete (bfd *abfd,\n   return TRUE;\n }\n \n-/* Relax a section.  Pass 0 shortens code sequences unless disabled.  Pass 1\n-   deletes the bytes that pass 0 made obselete.  Pass 2, which cannot be\n-   disabled, handles code alignment directives.  */\n+/* Relax a section.\n+\n+   Pass 0: Shortens code sequences for LUI/CALL/TPREL relocs.\n+   Pass 1: Shortens code sequences for PCREL relocs.\n+   Pass 2: Deletes the bytes that pass 1 made obselete.\n+   Pass 3: Which cannot be disabled, handles code alignment directives.  */\n \n static bfd_boolean\n _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n@@ -4898,7 +4897,7 @@ riscv_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)\n       default:\n \treturn FALSE;\n \n-      case PRSTATUS_SIZE:  /* sizeof(struct elf_prstatus) on Linux/RISC-V.  */\n+      case PRSTATUS_SIZE: /* sizeof(struct elf_prstatus) on Linux/RISC-V.  */\n \t/* pr_cursig */\n \telf_tdata (abfd)->core->signal\n \t  = bfd_get_16 (abfd, note->descdata + PRSTATUS_OFFSET_PR_CURSIG);\n@@ -4953,6 +4952,7 @@ riscv_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)\n }\n \n /* Set the right mach type.  */\n+\n static bfd_boolean\n riscv_elf_object_p (bfd *abfd)\n {"
    },
    {
      "sha": "0000bf0f84432ee7304aafa9f71e4ee6c38a25c8",
      "filename": "bfd/elfxx-riscv.c",
      "status": "modified",
      "additions": 25,
      "deletions": 29,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/bfd/elfxx-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/bfd/elfxx-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-riscv.c?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -872,7 +872,6 @@ static reloc_howto_type howto_table[] =\n };\n \n /* A mapping from BFD reloc types to RISC-V ELF reloc types.  */\n-\n struct elf_reloc_map\n {\n   bfd_reloc_code_real_type bfd_val;\n@@ -1025,11 +1024,11 @@ riscv_elf_add_sub_reloc (bfd *abfd,\n   return bfd_reloc_ok;\n }\n \n-/* Array is used to compare the all extensions' order quickly.\n+/* Array is used to compare the orders of all extensions quickly.\n \n-   Zero     number means it is a preserved keyword.\n-   Negative number means it is a prefix keyword (s, h, x, z).\n-   Positive number means it is a standard extension.  */\n+   Zero value: Preserved keyword.\n+   Negative value: Prefixed keyword (s, h, x, z).\n+   Positive value: Standard extension.  */\n \n static int riscv_ext_order[26] = {0};\n \n@@ -1093,7 +1092,7 @@ riscv_lookup_subset (const riscv_subset_list_t *subset_list,\n   return FALSE;\n }\n \n-/* Add arch string extension to the last of the subset list.  */\n+/* Add extension from ISA string to the last of the subset list.  */\n \n void\n riscv_add_subset (riscv_subset_list_t *subset_list,\n@@ -1150,7 +1149,7 @@ riscv_add_implicit_subset (riscv_subset_list_t *subset_list,\n \n /* These extensions are added to the subset list for special purposes,\n    with the explicit versions or the RISCV_UNKNOWN_VERSION versions.\n-   Therefore, we won't output them to the output arch string in the\n+   Therefore, we won't output them to the output ISA string in the\n    riscv_arch_str1, if the versions are unknown.  */\n \n static bfd_boolean\n@@ -1163,8 +1162,8 @@ riscv_ext_dont_care_version (const char *subset)\n   return FALSE;\n }\n \n-/* We have to add all arch string extensions first, and then start to\n-   add their implicit extensions.  The arch string extensions must be\n+/* We have to add all extensions from ISA string first, and then start to\n+   add their implicit extensions.  The extensions from ISA string must be\n    set in order, so we can add them to the last of the subset list\n    directly, without searching.\n \n@@ -1238,7 +1237,7 @@ riscv_release_subset_list (riscv_subset_list_t *subset_list)\n \n    Arguments:\n      `rps`: Hooks and status for parsing extensions.\n-     `march`: Full arch string.\n+     `march`: Full ISA string.\n      `p`: Curent parsing position.\n      `major_version`: Parsed major version.\n      `minor_version`: Parsed minor version.\n@@ -1323,7 +1322,7 @@ riscv_supported_std_ext (void)\n \n    Arguments:\n      `rps`: Hooks and status for parsing extensions.\n-     `march`: Full arch string.\n+     `march`: Full ISA string.\n      `p`: Curent parsing position.  */\n \n static const char *\n@@ -1379,7 +1378,7 @@ riscv_parse_std_ext (riscv_parse_subset_t *rps,\n \t\t\t\tRISCV_UNKNOWN_VERSION,\n \t\t\t\tRISCV_UNKNOWN_VERSION, FALSE);\n \t/* g-ext is used to add the implicit extensions, but will\n-\t   not be output to the arch string.  */\n+\t   not be output to the ISA string.  */\n \triscv_parse_add_subset (rps, \"g\",\n \t\t\t\tmajor_version,\n \t\t\t\tminor_version, FALSE);\n@@ -1441,7 +1440,7 @@ riscv_parse_std_ext (riscv_parse_subset_t *rps,\n   return p;\n }\n \n-/* Classify the argument 'arch' into one of riscv_isa_ext_class_t.  */\n+/* Classify ARCH into one of riscv_isa_ext_class_t.  */\n \n riscv_isa_ext_class_t\n riscv_get_prefix_class (const char *arch)\n@@ -1457,9 +1456,8 @@ riscv_get_prefix_class (const char *arch)\n }\n \n /* Structure describing parameters to use when parsing a particular\n-   riscv_isa_ext_class_t. One of these should be provided for each\n+   riscv_isa_ext_class_t.  One of these should be provided for each\n    possible class, except RV_ISA_CLASS_UNKNOWN.  */\n-\n typedef struct riscv_parse_config\n {\n   /* Class of the extension. */\n@@ -1481,7 +1479,7 @@ typedef struct riscv_parse_config\n \n    Arguments:\n      `rps`: Hooks and status for parsing extensions.\n-     `march`: Full architecture string.\n+     `march`: Full ISA string.\n      `p`: Curent parsing position.\n      `config`: What class and predicate function to use for the\n      extension.  */\n@@ -1667,7 +1665,6 @@ riscv_ext_h_valid_p (const char *arg)\n \n /* Parsing order of the prefixed extensions that is specified by\n    the ISA spec.  */\n-\n static const riscv_parse_config_t parse_config[] =\n {\n   {RV_ISA_CLASS_S, \"s\", riscv_ext_s_valid_p},\n@@ -1692,7 +1689,7 @@ riscv_init_ext_order (void)\n   if (inited)\n     return;\n \n-  /* All standard extensions' orders are positive numbers.  */\n+  /* The orders of all standard extensions are positive.  */\n   order = 1;\n \n   /* Init the standard base extensions first.  */\n@@ -1703,8 +1700,7 @@ riscv_init_ext_order (void)\n   for (ext = std_remain_exts; *ext; ext++)\n     riscv_ext_order[(*ext - 'a')] = order++;\n \n-  /* Init the order for prefixed keywords.  The orders are\n-     negative numbers.  */\n+  /* Init the order for prefixed keywords.  The orders are negative.  */\n   order = -1;\n   for (i = 0; parse_config[i].class != RV_ISA_CLASS_UNKNOWN; i++)\n     {\n@@ -1715,7 +1711,7 @@ riscv_init_ext_order (void)\n   inited = TRUE;\n }\n \n-/* Add the implicit extensions according to the arch string extensions.  */\n+/* Add the implicit extensions.  */\n \n static void\n riscv_parse_add_implicit_subsets (riscv_parse_subset_t *rps)\n@@ -1773,14 +1769,14 @@ riscv_parse_add_implicit_subsets (riscv_parse_subset_t *rps)\n     }\n }\n \n-/* Function for parsing arch string.\n+/* Function for parsing ISA string.\n \n    Return Value:\n      Return TRUE on success.\n \n    Arguments:\n      `rps`: Hooks and status for parsing extensions.\n-     `arch`: Full arch string.  */\n+     `arch`: Full ISA string.  */\n \n bfd_boolean\n riscv_parse_subset (riscv_parse_subset_t *rps,\n@@ -1815,11 +1811,11 @@ riscv_parse_subset (riscv_parse_subset_t *rps,\n     }\n   else\n     {\n-      /* Arch string shouldn't be NULL or empty here.  However,\n-\t it might be empty only when we failed to merge the arch\n+      /* ISA string shouldn't be NULL or empty here.  However,\n+\t it might be empty only when we failed to merge the ISA\n \t string in the riscv_merge_attributes.  We have already\n \t issued the correct error message in another side, so do\n-\t not issue this error when the arch string is empty.  */\n+\t not issue this error when the ISA string is empty.  */\n       if (strlen (arch))\n \trps->error_handler (\n \t  _(\"-march=%s: ISA string must begin with rv32 or rv64\"),\n@@ -1903,7 +1899,7 @@ riscv_estimate_arch_strlen1 (const riscv_subset_t *subset)\n   return riscv_estimate_arch_strlen1 (subset->next)\n \t + strlen (subset->name)\n \t + riscv_estimate_digit (subset->major_version)\n-\t + 1 /* For version seperator: 'p'.  */\n+\t + 1 /* For version seperator 'p'.  */\n \t + riscv_estimate_digit (subset->minor_version)\n \t + 1 /* For underscore.  */;\n }\n@@ -1928,7 +1924,7 @@ riscv_arch_str1 (riscv_subset_t *subset,\n   if (subset_t == NULL)\n     return;\n \n-  /* No underline between rvXX and i/e.   */\n+  /* No underline between rvXX and i/e.  */\n   if ((strcasecmp (subset_t->name, \"i\") == 0)\n       || (strcasecmp (subset_t->name, \"e\") == 0))\n     underline = \"\";\n@@ -1953,7 +1949,7 @@ riscv_arch_str1 (riscv_subset_t *subset,\n   riscv_arch_str1 (subset_t->next, attr_str, buf, bufsz);\n }\n \n-/* Convert subset info to string with explicit version info.  */\n+/* Convert subset information into string with explicit versions.  */\n \n char *\n riscv_arch_str (unsigned xlen, const riscv_subset_list_t *subset)"
    },
    {
      "sha": "87ebaf4930f860a5d36b737eebdde3858465e797",
      "filename": "bfd/elfxx-riscv.h",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/bfd/elfxx-riscv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/bfd/elfxx-riscv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-riscv.h?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -90,9 +90,7 @@ riscv_arch_str (unsigned, const riscv_subset_list_t *);\n extern size_t\n riscv_estimate_digit (unsigned);\n \n-/* ISA extension name class. E.g. \"zbb\" corresponds to RV_ISA_CLASS_Z,\n-   \"xargs\" corresponds to RV_ISA_CLASS_X, etc.  */\n-\n+/* ISA extension prefixed name class.  */\n typedef enum riscv_isa_ext_class\n {\n   RV_ISA_CLASS_S,"
    },
    {
      "sha": "b1687c12e460b9a2f9f8b59aa413232263408ff7",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -1,3 +1,9 @@\n+2021-01-15  Nelson Chu  <nelson.chu@sifive.com>\n+\n+\t* config/tc-riscv.c: Comments tidy and improvement.  Also update\n+\tcomment \"fallthru\" to \"Fall through\" that end with a period and\n+\ttwo spaces.\n+\n 2021-01-14  Mike Frysinger  <vapier@gentoo.org>\n \n \t* doc/as.texi: Delete @ifset ELF wrapping around [248]byte entries."
    },
    {
      "sha": "e9f5ab8ab42ce8332839219a8cb2c4255ab1c250",
      "filename": "gas/config/tc-riscv.c",
      "status": "modified",
      "additions": 130,
      "deletions": 161,
      "changes": 291,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/gas/config/tc-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/gas/config/tc-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-riscv.c?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -64,17 +64,11 @@ struct riscv_cl_insn\n #endif\n \n /* Let riscv_after_parse_args set the default value according to xlen.  */\n-\n #ifndef DEFAULT_RISCV_ARCH_WITH_EXT\n #define DEFAULT_RISCV_ARCH_WITH_EXT NULL\n #endif\n \n-/* The default ISA spec is set to 2.2 rather than the lastest version.\n-   The reason is that compiler generates the ISA string with fixed 2p0\n-   verisons only for the RISCV ELF architecture attributes, but not for\n-   the -march option.  Therefore, we should update the compiler or linker\n-   to resolve this problem.  */\n-\n+/* Need to sync the version with RISC-V compiler.  */\n #ifndef DEFAULT_RISCV_ISA_SPEC\n #define DEFAULT_RISCV_ISA_SPEC \"2.2\"\n #endif\n@@ -88,8 +82,8 @@ static const char *default_arch_with_ext = DEFAULT_RISCV_ARCH_WITH_EXT;\n static enum riscv_isa_spec_class default_isa_spec = ISA_SPEC_CLASS_NONE;\n static enum riscv_priv_spec_class default_priv_spec = PRIV_SPEC_CLASS_NONE;\n \n-static unsigned xlen = 0; /* width of an x-register */\n-static unsigned abi_xlen = 0; /* width of a pointer in the ABI */\n+static unsigned xlen = 0; /* The width of an x-register.  */\n+static unsigned abi_xlen = 0; /* The width of a pointer in the ABI.  */\n static bfd_boolean rve_abi = FALSE;\n enum float_abi {\n   FLOAT_ABI_DEFAULT = -1,\n@@ -105,8 +99,8 @@ static enum float_abi float_abi = FLOAT_ABI_DEFAULT;\n \n static unsigned elf_flags = 0;\n \n-/* Set the default_isa_spec.  Return 0 if the input spec string isn't\n-   supported.  Otherwise, return 1.  */\n+/* Set the default_isa_spec.  Return 0 if the spec isn't supported.\n+   Otherwise, return 1.  */\n \n static int\n riscv_set_default_isa_spec (const char *s)\n@@ -123,10 +117,9 @@ riscv_set_default_isa_spec (const char *s)\n   return 1;\n }\n \n-/* Set the default_priv_spec, assembler will find the suitable CSR address\n-   according to default_priv_spec.  We will try to check priv attributes if\n-   the input string is NULL.  Return 0 if the input priv spec string isn't\n-   supported.  Otherwise, return 1.  */\n+/* Set the default_priv_spec.  Find the privileged elf attributes when\n+   the input string is NULL.  Return 0 if the spec isn't supported.\n+   Otherwise, return 1.  */\n \n static int\n riscv_set_default_priv_spec (const char *s)\n@@ -135,7 +128,6 @@ riscv_set_default_priv_spec (const char *s)\n   unsigned major, minor, revision;\n   obj_attribute *attr;\n \n-  /* Find the corresponding priv spec class.  */\n   if (riscv_get_priv_spec_class (s, &class))\n     {\n       default_priv_spec = class;\n@@ -149,53 +141,49 @@ riscv_set_default_priv_spec (const char *s)\n       return 0;\n     }\n \n-  /* Try to set the default_priv_spec according to the priv attributes.  */\n+  /* Set the default_priv_spec by the privileged elf attributes.  */\n   attr = elf_known_obj_attributes_proc (stdoutput);\n   major = (unsigned) attr[Tag_RISCV_priv_spec].i;\n   minor = (unsigned) attr[Tag_RISCV_priv_spec_minor].i;\n   revision = (unsigned) attr[Tag_RISCV_priv_spec_revision].i;\n-\n   if (riscv_get_priv_spec_class_from_numbers (major,\n \t\t\t\t\t      minor,\n \t\t\t\t\t      revision,\n \t\t\t\t\t      &class))\n     {\n-      /* The priv attributes setting 0.0.0 is meaningless.  We should have set\n-\t the default_priv_spec by md_parse_option and riscv_after_parse_args,\n-\t so just skip the following setting.  */\n+      /* 0.0.0 is meaningless.  */\n       if (class == PRIV_SPEC_CLASS_NONE)\n \treturn 1;\n \n       default_priv_spec = class;\n       return 1;\n     }\n \n-  /* Still can not find the priv spec class.  */\n+  /* Still can not find the privileged spec class.  */\n   as_bad (_(\"Unknown default privilege spec `%d.%d.%d' set by \"\n            \"privilege attributes\"),  major, minor, revision);\n   return 0;\n }\n \n /* This is the set of options which the .option pseudo-op may modify.  */\n-\n struct riscv_set_options\n {\n   int pic; /* Generate position-independent code.  */\n   int rvc; /* Generate RVC code.  */\n   int rve; /* Generate RVE code.  */\n   int relax; /* Emit relocs the linker is allowed to relax.  */\n-  int arch_attr; /* Emit arch attribute.  */\n+  int arch_attr; /* Emit architecture and privileged elf attributes.  */\n   int csr_check; /* Enable the CSR checking.  */\n };\n \n static struct riscv_set_options riscv_opts =\n {\n-  0,\t/* pic */\n-  0,\t/* rvc */\n-  0,\t/* rve */\n-  1,\t/* relax */\n+  0, /* pic */\n+  0, /* rvc */\n+  0, /* rve */\n+  1, /* relax */\n   DEFAULT_RISCV_ATTR, /* arch_attr */\n-  0.\t/* csr_check */\n+  0, /* csr_check */\n };\n \n static void\n@@ -337,7 +325,7 @@ riscv_set_arch (const char *s)\n   riscv_parse_subset (&rps, s);\n }\n \n-/* Indicate -mabi= option is explictly set.  */\n+/* Indicate -mabi option is explictly set.  */\n static bfd_boolean explicit_mabi = FALSE;\n \n static void\n@@ -348,9 +336,8 @@ riscv_set_abi (unsigned new_xlen, enum float_abi new_float_abi, bfd_boolean rve)\n   rve_abi = rve;\n }\n \n-/* If the -mabi option isn't set, then we set the abi according to the arch\n-   string.  Otherwise, check if there are conflicts between architecture\n-   and abi setting.  */\n+/* If the -mabi option isn't set, then set the abi according to the\n+   ISA string.  Otherwise, check if there is any conflict.  */\n \n static void\n riscv_set_abi_by_arch (void)\n@@ -388,27 +375,28 @@ static htab_t op_hash = NULL;\n static htab_t insn_type_hash = NULL;\n \n /* This array holds the chars that always start a comment.  If the\n-    pre-processor is disabled, these aren't very useful */\n+   pre-processor is disabled, these aren't very useful.  */\n const char comment_chars[] = \"#\";\n \n /* This array holds the chars that only start a comment at the beginning of\n    a line.  If the line seems to have the form '# 123 filename'\n-   .line and .file directives will appear in the pre-processed output */\n-/* Note that input_file.c hand checks for '#' at the beginning of the\n+   .line and .file directives will appear in the pre-processed output\n+\n+   Note that input_file.c hand checks for '#' at the beginning of the\n    first line of the input file.  This is because the compiler outputs\n-   #NO_APP at the beginning of its output.  */\n-/* Also note that C style comments are always supported.  */\n+   #NO_APP at the beginning of its output.\n+\n+   Also note that C style comments are always supported.  */\n const char line_comment_chars[] = \"#\";\n \n /* This array holds machine specific line separator characters.  */\n const char line_separator_chars[] = \";\";\n \n-/* Chars that can be used to separate mant from exp in floating point nums */\n+/* Chars that can be used to separate mant from exp in floating point nums.  */\n const char EXP_CHARS[] = \"eE\";\n \n-/* Chars that mean this number is a floating point constant */\n-/* As in 0f12.456 */\n-/* or    0d1.2345e12 */\n+/* Chars that mean this number is a floating point constant.\n+   As in 0f12.456 or 0d1.2345e12.  */\n const char FLT_CHARS[] = \"rRsSfFdDxXpP\";\n \n /* Indicate we are already assemble any instructions or not.  */\n@@ -626,6 +614,7 @@ static const struct opcode_name_t opcode_name_list[] =\n static htab_t opcode_names_hash = NULL;\n \n /* Initialization for hash table of opcode name.  */\n+\n static void\n init_opcode_names_hash (void)\n {\n@@ -636,8 +625,9 @@ init_opcode_names_hash (void)\n       as_fatal (_(\"duplicate %s\"), opcode->name);\n }\n \n-/* Find `s` is a valid opcode name or not,\n-   return the opcode name info if found.  */\n+/* Find `s` is a valid opcode name or not, return the opcode name info\n+   if found.  */\n+\n static const struct opcode_name_t *\n opcode_name_lookup (char **s)\n {\n@@ -703,6 +693,7 @@ hash_reg_names (enum reg_class class, const char * const names[], unsigned n)\n }\n \n /* Init hash table csr_extra_hash to handle CSR.  */\n+\n static void\n riscv_init_csr_hash (const char *name,\n                     unsigned address,\n@@ -726,7 +717,7 @@ riscv_init_csr_hash (const char *name,\n       entry = entry->next;\n     }\n  \n-  /* Duplicate setting for the CSR, just return and do nothing.  */\n+  /* Duplicate CSR.  */\n   if (!need_enrty)\n     return;\n \n@@ -737,17 +728,21 @@ riscv_init_csr_hash (const char *name,\n   entry->abort_version = abort_version;\n   entry->next = NULL;\n \n-  /* If the CSR hasn't been inserted in the hash table, then insert it.\n-     Otherwise, attach the extra information to the entry which is already\n-     in the hash table.  */\n   if (pre_entry == NULL)\n     str_hash_insert (csr_extra_hash, name, entry, 0);\n   else\n     pre_entry->next = entry;\n }\n \n-/* Return the suitable CSR address after checking the ISA dependency and\n-   priv spec versions.  */\n+/* Return the CSR address after checking the ISA dependency and\n+   the privileged spec version.\n+\n+   There are one warning and two errors for CSR,\n+\n+   Invalid CSR: the CSR was defined, but isn't allowed for the current ISA\n+   or the privileged spec, report warning only if -mcsr-check is set.\n+   Unknown CSR: the CSR has never been defined, report error.\n+   Improper CSR: the CSR number over the range (> 0xfff), report error.  */\n \n static unsigned int\n riscv_csr_address (const char *csr_name,\n@@ -777,7 +772,6 @@ riscv_csr_address (const char *csr_name,\n       as_bad (_(\"internal: bad RISC-V CSR class (0x%x)\"), csr_class);\n     }\n \n-  /* Don't report the ISA conflict when -mcsr-check isn't set.  */\n   if (riscv_opts.csr_check && !result)\n     as_warn (_(\"Invalid CSR `%s' for the current ISA\"), csr_name);\n \n@@ -787,16 +781,14 @@ riscv_csr_address (const char *csr_name,\n \t  || (default_priv_spec >= entry->define_version\n \t      && default_priv_spec < entry->abort_version))\n        {\n-         /* Find the suitable CSR according to the specific version.  */\n+         /* Find the CSR according to the specific version.  */\n          return entry->address;\n        }\n       entry = entry->next;\n     }\n \n-  /* We can not find the suitable CSR address according to the privilege\n-     version.  Therefore, we use the last defined value.  Report the warning\n-     only when the -mcsr-check is set.  Enable the -mcsr-check is recommended,\n-     otherwise, you may get the unexpected CSR address.  */\n+  /* Can not find the CSR address from the chosen privileged version,\n+     so use the newly defined value.  */\n   if (riscv_opts.csr_check)\n     {\n       const char *priv_name = riscv_get_priv_spec_name (default_priv_spec);\n@@ -809,10 +801,8 @@ riscv_csr_address (const char *csr_name,\n   return saved_entry->address;\n }\n \n-/* Once the CSR is defined, including the old privilege spec, then we call\n-   riscv_csr_class_check and riscv_csr_version_check to do the further checking\n-   and get the corresponding address.  Return -1 if the CSR is never been\n-   defined.  Otherwise, return the address.  */\n+/* Return -1 if the CSR has never been defined.  Otherwise, return\n+   the address.  */\n \n static unsigned int\n reg_csr_lookup_internal (const char *s)\n@@ -823,12 +813,6 @@ reg_csr_lookup_internal (const char *s)\n   if (r == NULL)\n     return -1U;\n \n-  /* We just report the warning when the CSR is invalid.  \"Invalid CSR\" means\n-     the CSR was defined, but isn't allowed for the current ISA setting or\n-     the privilege spec.  If the CSR is never been defined, then assembler\n-     will regard it as a \"Unknown CSR\" and report error.  If user use number\n-     to set the CSR, but over the range (> 0xfff), then assembler will report\n-     \"Improper CSR\" error for it.  */\n   return riscv_csr_address (s, r);\n }\n \n@@ -900,9 +884,8 @@ arg_lookup (char **s, const char *const *array, size_t size, unsigned *regnop)\n \n /* For consistency checking, verify that all bits are specified either\n    by the match/mask part of the instruction definition, or by the\n-   operand list.\n+   operand list. The `length` could be 0, 4 or 8, 0 for auto detection.  */\n \n-   `length` could be 0, 4 or 8, 0 for auto detection.  */\n static bfd_boolean\n validate_riscv_insn (const struct riscv_opcode *opc, int length)\n {\n@@ -934,7 +917,7 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n \tswitch (c = *p++)\n \t  {\n \t  case 'a': used_bits |= ENCODE_RVC_J_IMM (-1U); break;\n-\t  case 'c': break; /* RS1, constrained to equal sp */\n+\t  case 'c': break; /* RS1, constrained to equal sp.  */\n \t  case 'i': used_bits |= ENCODE_RVC_SIMM3(-1U); break;\n \t  case 'j': used_bits |= ENCODE_RVC_IMM (-1U); break;\n \t  case 'o': used_bits |= ENCODE_RVC_IMM (-1U); break;\n@@ -947,22 +930,22 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n \t  case 't': USE_BITS (OP_MASK_CRS2S, OP_SH_CRS2S); break;\n \t  case 'u': used_bits |= ENCODE_RVC_IMM (-1U); break;\n \t  case 'v': used_bits |= ENCODE_RVC_IMM (-1U); break;\n-\t  case 'w': break; /* RS1S, constrained to equal RD */\n-\t  case 'x': break; /* RS2S, constrained to equal RD */\n-\t  case 'z': break; /* RS2S, contrained to be x0 */\n+\t  case 'w': break; /* RS1S, constrained to equal RD.  */\n+\t  case 'x': break; /* RS2S, constrained to equal RD.  */\n+\t  case 'z': break; /* RS2S, constrained to be x0.  */\n \t  case 'K': used_bits |= ENCODE_RVC_ADDI4SPN_IMM (-1U); break;\n \t  case 'L': used_bits |= ENCODE_RVC_ADDI16SP_IMM (-1U); break;\n \t  case 'M': used_bits |= ENCODE_RVC_SWSP_IMM (-1U); break;\n \t  case 'N': used_bits |= ENCODE_RVC_SDSP_IMM (-1U); break;\n-\t  case 'U': break; /* RS1, constrained to equal RD */\n+\t  case 'U': break; /* RS1, constrained to equal RD.  */\n \t  case 'V': USE_BITS (OP_MASK_CRS2, OP_SH_CRS2); break;\n \t  case '<': used_bits |= ENCODE_RVC_IMM (-1U); break;\n \t  case '>': used_bits |= ENCODE_RVC_IMM (-1U); break;\n \t  case '8': used_bits |= ENCODE_RVC_UIMM8 (-1U); break;\n \t  case 'S': USE_BITS (OP_MASK_CRS1S, OP_SH_CRS1S); break;\n \t  case 'T': USE_BITS (OP_MASK_CRS2, OP_SH_CRS2); break;\n \t  case 'D': USE_BITS (OP_MASK_CRS2S, OP_SH_CRS2S); break;\n-\t  case 'F': /* funct */\n+\t  case 'F': /* RVC funct for .insn directive.  */\n \t    switch (c = *p++)\n \t      {\n \t\tcase '6': USE_BITS (OP_MASK_CFUNCT6, OP_SH_CFUNCT6); break;\n@@ -994,7 +977,8 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n       case 'I': break;\n       case 'R':\tUSE_BITS (OP_MASK_RS3,\t\tOP_SH_RS3);\tbreak;\n       case 'S':\tUSE_BITS (OP_MASK_RS1,\t\tOP_SH_RS1);\tbreak;\n-      case 'U':\tUSE_BITS (OP_MASK_RS1,\t\tOP_SH_RS1);\t/* fallthru */\n+      case 'U':\tUSE_BITS (OP_MASK_RS1,\t\tOP_SH_RS1);\n+\t/* Fall through.  */\n       case 'T':\tUSE_BITS (OP_MASK_RS2,\t\tOP_SH_RS2);\tbreak;\n       case 'd':\tUSE_BITS (OP_MASK_RD,\t\tOP_SH_RD);\tbreak;\n       case 'm':\tUSE_BITS (OP_MASK_RM,\t\tOP_SH_RM);\tbreak;\n@@ -1014,7 +998,7 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n       case ']': break;\n       case '0': break;\n       case '1': break;\n-      case 'F': /* funct */\n+      case 'F': /* Funct for .insn directive.  */\n \tswitch (c = *p++)\n \t  {\n \t    case '7': USE_BITS (OP_MASK_FUNCT7, OP_SH_FUNCT7); break;\n@@ -1027,7 +1011,7 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n \t    return FALSE;\n \t  }\n \tbreak;\n-      case 'O': /* opcode */\n+      case 'O': /* Opcode for .insn directive.  */\n \tswitch (c = *p++)\n \t  {\n \t    case '4': USE_BITS (OP_MASK_OP, OP_SH_OP); break;\n@@ -1062,8 +1046,9 @@ struct percent_op_match\n   bfd_reloc_code_real_type reloc;\n };\n \n-/* Common hash table initialization function for\n-   instruction and .insn directive.  */\n+/* Common hash table initialization function for instruction and .insn\n+   directive.  */\n+\n static htab_t\n init_opcode_hash (const struct riscv_opcode *opcodes,\n \t\t  bfd_boolean insn_directive_p)\n@@ -1084,7 +1069,7 @@ init_opcode_hash (const struct riscv_opcode *opcodes,\n \t      if (insn_directive_p)\n \t\tlength = ((name[0] == 'c') ? 2 : 4);\n \t      else\n-\t\tlength = 0; /* Let assembler determine the length. */\n+\t\tlength = 0; /* Let assembler determine the length.  */\n \t      if (!validate_riscv_insn (&opcodes[i], length))\n \t\tas_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n \t    }\n@@ -1224,9 +1209,9 @@ append_insn (struct riscv_cl_insn *ip, expressionS *address_expr,\n }\n \n /* Build an instruction created by a macro expansion.  This is passed\n-   a pointer to the count of instructions created so far, an\n-   expression, the name of the instruction to build, an operand format\n-   string, and corresponding arguments.  */\n+   a pointer to the count of instructions created so far, an expression,\n+   the name of the instruction to build, an operand format string, and\n+   corresponding arguments.  */\n \n static void\n macro_build (expressionS *ep, const char *name, const char *fmt, ...)\n@@ -1316,6 +1301,7 @@ md_assemblef (const char *format, ...)\n \n /* Sign-extend 32-bit mode constants that have bit 31 set and all higher bits\n    unset.  */\n+\n static void\n normalize_constant_expr (expressionS *ex)\n {\n@@ -1353,6 +1339,7 @@ make_internal_label (void)\n }\n \n /* Load an entry from the GOT.  */\n+\n static void\n pcrel_access (int destreg, int tempreg, expressionS *ep,\n \t      const char *lo_insn, const char *lo_pattern,\n@@ -1385,6 +1372,7 @@ pcrel_store (int srcreg, int tempreg, expressionS *ep, const char *lo_insn,\n }\n \n /* PC-relative function call using AUIPC/JALR, relaxed to JAL.  */\n+\n static void\n riscv_call (int destreg, int tempreg, expressionS *ep,\n \t    bfd_reloc_code_real_type reloc)\n@@ -1491,10 +1479,10 @@ macro (struct riscv_cl_insn *ip, expressionS *imm_expr,\n \n       if (imm_expr->X_op == O_constant)\n \tload_const (rd, imm_expr);\n-      else if (riscv_opts.pic && mask == M_LA) /* Global PIC symbol */\n+      else if (riscv_opts.pic && mask == M_LA) /* Global PIC symbol.  */\n \tpcrel_load (rd, rd, imm_expr, LOAD_ADDRESS_INSN,\n \t\t    BFD_RELOC_RISCV_GOT_HI20, BFD_RELOC_RISCV_PCREL_LO12_I);\n-      else /* Local PIC symbol, or any non-PIC symbol */\n+      else /* Local PIC symbol, or any non-PIC symbol.  */\n \tpcrel_load (rd, rd, imm_expr, \"addi\",\n \t\t    BFD_RELOC_RISCV_PCREL_HI20, BFD_RELOC_RISCV_PCREL_LO12_I);\n       break;\n@@ -1720,9 +1708,9 @@ my_getSmallExpression (expressionS *ep, bfd_reloc_code_real_type *reloc,\n     }\n \n   /* Search for the start of the main expression.\n-     End the loop with CRUX pointing to the start\n-     of the main expression and with CRUX_DEPTH containing the number\n-     of open brackets at that point.  */\n+\n+     End the loop with CRUX pointing to the start of the main expression and\n+     with CRUX_DEPTH containing the number of open brackets at that point.  */\n   reloc_index = -1;\n   str_depth = 0;\n   do\n@@ -1758,6 +1746,7 @@ my_getSmallExpression (expressionS *ep, bfd_reloc_code_real_type *reloc,\n }\n \n /* Parse opcode name, could be an mnemonics or number.  */\n+\n static size_t\n my_getOpcodeExpression (expressionS *ep, bfd_reloc_code_real_type *reloc,\n \t\t\tchar *str, const struct percent_op_match *percent_op)\n@@ -1794,7 +1783,6 @@ riscv_handle_implicit_zero_offset (expressionS *ep, const char *s)\n }\n \n /* All RISC-V CSR instructions belong to one of these classes.  */\n-\n enum csr_insn_type\n {\n   INSN_NOT_CSR,\n@@ -1864,11 +1852,7 @@ riscv_is_priv_insn (insn_t insn)\n \t  || ((insn ^ MATCH_SFENCE_VMA) & MASK_SFENCE_VMA) == 0\n \t  || ((insn ^ MATCH_WFI) & MASK_WFI) == 0\n   /* The sfence.vm is dropped in the v1.10 priv specs, but we still need to\n-     check it here to keep the compatible.  Maybe we should issue warning\n-     if sfence.vm is used, but the priv spec newer than v1.10 is chosen.\n-     We already have a similar check for CSR, but not yet for instructions.\n-     It would be good if we could check the spec versions both for CSR and\n-     instructions, but not here.  */\n+     check it here to keep the compatible.  */\n \t  || ((insn ^ MATCH_SFENCE_VM) & MASK_SFENCE_VM) == 0);\n }\n \n@@ -1926,7 +1910,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t  s += strspn (s, \" \\t\");\n \t  switch (*args)\n \t    {\n-\t    case '\\0': \t/* End of args.  */\n+\t    case '\\0': /* End of args.  */\n \t      if (insn->pinfo != INSN_MACRO)\n \t\t{\n \t\t  if (!insn->match_func (insn, ip->insn_opcode))\n@@ -1966,7 +1950,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t    case 'C': /* RVC */\n \t      switch (*++args)\n \t\t{\n-\t\tcase 's': /* RS1 x8-x15 */\n+\t\tcase 's': /* RS1 x8-x15.  */\n \t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n \t\t      || !(regno >= 8 && regno <= 15))\n \t\t    break;\n@@ -1977,7 +1961,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t      || EXTRACT_OPERAND (CRS1S, ip->insn_opcode) + 8 != regno)\n \t\t    break;\n \t\t  continue;\n-\t\tcase 't': /* RS2 x8-x15 */\n+\t\tcase 't': /* RS2 x8-x15.  */\n \t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n \t\t      || !(regno >= 8 && regno <= 15))\n \t\t    break;\n@@ -2003,7 +1987,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t      || regno != X_SP)\n \t\t    break;\n \t\t  continue;\n-\t\tcase 'z': /* RS2, contrained to equal x0.  */\n+\t\tcase 'z': /* RS2, constrained to equal x0.  */\n \t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n \t\t      || regno != 0)\n \t\t    break;\n@@ -2271,7 +2255,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\tcontinue;\n \t      break;\n \n-\t    case '<':\t\t/* Shift amount, 0 - 31.  */\n+\t    case '<': /* Shift amount, 0 - 31.  */\n \t      my_getExpression (imm_expr, s);\n \t      check_absolute_expr (ip, imm_expr, FALSE);\n \t      if ((unsigned long) imm_expr->X_add_number > 31)\n@@ -2282,7 +2266,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      s = expr_end;\n \t      continue;\n \n-\t    case '>':\t\t/* Shift amount, 0 - (XLEN-1).  */\n+\t    case '>': /* Shift amount, 0 - (XLEN-1).  */\n \t      my_getExpression (imm_expr, s);\n \t      check_absolute_expr (ip, imm_expr, FALSE);\n \t      if ((unsigned long) imm_expr->X_add_number >= xlen)\n@@ -2293,7 +2277,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      s = expr_end;\n \t      continue;\n \n-\t    case 'Z':\t\t/* CSRRxI immediate.  */\n+\t    case 'Z': /* CSRRxI immediate.  */\n \t      my_getExpression (imm_expr, s);\n \t      check_absolute_expr (ip, imm_expr, FALSE);\n \t      if ((unsigned long) imm_expr->X_add_number > 31)\n@@ -2304,7 +2288,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      s = expr_end;\n \t      continue;\n \n-\t    case 'E':\t\t/* Control register.  */\n+\t    case 'E': /* Control register.  */\n \t      insn_with_csr = TRUE;\n \t      explicit_priv_attr = TRUE;\n \t      if (reg_lookup (&s, RCLASS_CSR, &regno))\n@@ -2322,7 +2306,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t}\n \t      continue;\n \n-\t    case 'm':\t\t/* Rounding mode.  */\n+\t    case 'm': /* Rounding mode.  */\n \t      if (arg_lookup (&s, riscv_rm, ARRAY_SIZE (riscv_rm), &regno))\n \t\t{\n \t\t  INSERT_OPERAND (RM, *ip, regno);\n@@ -2331,7 +2315,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      break;\n \n \t    case 'P':\n-\t    case 'Q':\t\t/* Fence predecessor/successor.  */\n+\t    case 'Q': /* Fence predecessor/successor.  */\n \t      if (arg_lookup (&s, riscv_pred_succ, ARRAY_SIZE (riscv_pred_succ),\n \t\t\t      &regno))\n \t\t{\n@@ -2343,10 +2327,10 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t}\n \t      break;\n \n-\t    case 'd':\t\t/* Destination register.  */\n-\t    case 's':\t\t/* Source register.  */\n-\t    case 't':\t\t/* Target register.  */\n-\t    case 'r':\t\t/* rs3.  */\n+\t    case 'd': /* Destination register.  */\n+\t    case 's': /* Source register.  */\n+\t    case 't': /* Target register.  */\n+\t    case 'r': /* RS3 */\n \t      if (reg_lookup (&s, RCLASS_GPR, &regno))\n \t\t{\n \t\t  c = *args;\n@@ -2374,11 +2358,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t}\n \t      break;\n \n-\t    case 'D':\t\t/* Floating point rd.  */\n-\t    case 'S':\t\t/* Floating point rs1.  */\n-\t    case 'T':\t\t/* Floating point rs2.  */\n-\t    case 'U':\t\t/* Floating point rs1 and rs2.  */\n-\t    case 'R':\t\t/* Floating point rs3.  */\n+\t    case 'D': /* Floating point RD.  */\n+\t    case 'S': /* Floating point RS1.  */\n+\t    case 'T': /* Floating point RS2.  */\n+\t    case 'U': /* Floating point RS1 and RS2.  */\n+\t    case 'R': /* Floating point RS3.  */\n \t      if (reg_lookup (&s, RCLASS_FPR, &regno))\n \t\t{\n \t\t  c = *args;\n@@ -2394,7 +2378,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t      break;\n \t\t    case 'U':\n \t\t      INSERT_OPERAND (RS1, *ip, regno);\n-\t\t      /* fallthru */\n+\t\t      /* Fall through.  */\n \t\t    case 'T':\n \t\t      INSERT_OPERAND (RS2, *ip, regno);\n \t\t      break;\n@@ -2449,10 +2433,13 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      p = percent_op_itype;\n \t      *imm_reloc = BFD_RELOC_RISCV_LO12_I;\n \t      goto load_store;\n-\t    case '1': /* 4-operand add, must be %tprel_add.  */\n+\t    case '1':\n+\t      /* This is used for TLS, where the fourth operand is\n+\t\t %tprel_add, to get a relocation applied to an add\n+\t\t instruction, for relaxation to use.  */\n \t      p = percent_op_rtype;\n \t      goto alu_op;\n-\t    case '0': /* AMO \"displacement,\" which must be zero.  */\n+\t    case '0': /* AMO displacement, which must be zero.  */\n \t      p = percent_op_null;\n \t    load_store:\n \t      if (riscv_handle_implicit_zero_offset (imm_expr, s))\n@@ -2475,14 +2462,14 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      s = expr_end;\n \t      continue;\n \n-\t    case 'p':\t\t/* PC-relative offset.  */\n+\t    case 'p': /* PC-relative offset.  */\n \t    branch:\n \t      *imm_reloc = BFD_RELOC_12_PCREL;\n \t      my_getExpression (imm_expr, s);\n \t      s = expr_end;\n \t      continue;\n \n-\t    case 'u':\t\t/* Upper 20 bits.  */\n+\t    case 'u': /* Upper 20 bits.  */\n \t      p = percent_op_utype;\n \t      if (!my_getSmallExpression (imm_expr, imm_reloc, s, p))\n \t\t{\n@@ -2499,7 +2486,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      s = expr_end;\n \t      continue;\n \n-\t    case 'a':\t\t/* 20-bit PC-relative offset.  */\n+\t    case 'a': /* 20-bit PC-relative offset.  */\n \t    jump:\n \t      my_getExpression (imm_expr, s);\n \t      s = expr_end;\n@@ -2645,13 +2632,13 @@ md_assemble (char *str)\n   expressionS imm_expr;\n   bfd_reloc_code_real_type imm_reloc = BFD_RELOC_UNUSED;\n \n-  /* The arch and priv attributes should be set before assembling.  */\n+  /* The architecture and privileged elf attributes should be set\n+     before assembling.  */\n   if (!start_assemble)\n     {\n       start_assemble = TRUE;\n-      riscv_set_abi_by_arch ();\n \n-      /* Set the default_priv_spec according to the priv attributes.  */\n+      riscv_set_abi_by_arch ();\n       if (!riscv_set_default_priv_spec (NULL))\n        return;\n     }\n@@ -2734,8 +2721,6 @@ md_parse_option (int c, const char *arg)\n   switch (c)\n     {\n     case OPTION_MARCH:\n-      /* riscv_after_parse_args will call riscv_set_arch to parse\n-        the architecture.  */\n       default_arch_with_ext = arg;\n       break;\n \n@@ -2819,10 +2804,8 @@ md_parse_option (int c, const char *arg)\n void\n riscv_after_parse_args (void)\n {\n-  /* The --with-arch is optional for now, so we have to set the xlen\n-     according to the default_arch, which is set by the --targte, first.\n-     Then, we use the xlen to set the default_arch_with_ext if the\n-     -march and --with-arch are not set.  */\n+  /* The --with-arch is optional for now, so we still need to set the xlen\n+     according to the default_arch, which is set by the --target.  */\n   if (xlen == 0)\n     {\n       if (strcmp (default_arch, \"riscv32\") == 0)\n@@ -2838,12 +2821,12 @@ riscv_after_parse_args (void)\n   /* Initialize the hash table for extensions with default version.  */\n   ext_version_hash = init_ext_version_hash (riscv_ext_version_table);\n \n-  /* If the -misa-spec isn't set, then we set the default ISA spec according\n-     to DEFAULT_RISCV_ISA_SPEC.  */\n+  /* Set default specs.  */\n   if (default_isa_spec == ISA_SPEC_CLASS_NONE)\n     riscv_set_default_isa_spec (DEFAULT_RISCV_ISA_SPEC);\n+  if (default_priv_spec == PRIV_SPEC_CLASS_NONE)\n+    riscv_set_default_priv_spec (DEFAULT_RISCV_PRIV_SPEC);\n \n-  /* Set the architecture according to -march or or --with-arch.  */\n   riscv_set_arch (default_arch_with_ext);\n \n   /* Add the RVC extension, regardless of -march, to support .option rvc.  */\n@@ -2856,11 +2839,6 @@ riscv_after_parse_args (void)\n   if (riscv_subset_supports (\"e\"))\n     riscv_set_rve (TRUE);\n \n-  /* If the -mpriv-spec isn't set, then we set the default privilege spec\n-     according to DEFAULT_PRIV_SPEC.  */\n-  if (default_priv_spec == PRIV_SPEC_CLASS_NONE)\n-    riscv_set_default_priv_spec (DEFAULT_RISCV_PRIV_SPEC);\n-\n   /* If the CIE to be produced has not been overridden on the command line,\n      then produce version 3 by default.  This allows us to use the full\n      range of registers in a .cfi_return_column directive.  */\n@@ -2937,7 +2915,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n \t _bfd_elf_discard_section_eh_frame, and the content of\n \t .eh_frame will be adjusted in _bfd_elf_write_section_eh_frame.\n \t Therefore, we cannot insert a relocation whose addend symbol is\n-\t in .eh_frame. Othrewise, the value may be adjusted twice.*/\n+\t in .eh_frame.  Othrewise, the value may be adjusted twice.  */\n       if (fixP->fx_addsy && fixP->fx_subsy\n \t  && (sub_segment = S_GET_SEGMENT (fixP->fx_subsy))\n \t  && strcmp (sub_segment->name, \".eh_frame\") == 0\n@@ -3167,9 +3145,7 @@ riscv_pre_output_hook (void)\n   subseg_set (seg, subseg);\n }\n \n-\n /* This structure is used to hold a stack of .option values.  */\n-\n struct riscv_option_stack\n {\n   struct riscv_option_stack *next;\n@@ -3563,6 +3539,7 @@ RISC-V options:\\n\\\n }\n \n /* Standard calling conventions leave the CFA at SP on entry.  */\n+\n void\n riscv_cfi_frame_initial_instructions (void)\n {\n@@ -3647,41 +3624,37 @@ s_riscv_insn (int x ATTRIBUTE_UNUSED)\n   demand_empty_rest_of_line ();\n }\n \n-/* Update arch and priv attributes.  If we don't set the corresponding ELF\n-   attributes, then try to output the default ones.  */\n+/* Update architecture and privileged elf attributes.  If we don't set\n+   them, then try to output the default ones.  */\n \n static void\n riscv_write_out_attrs (void)\n {\n   const char *arch_str, *priv_str, *p;\n-  /* versions[0] is major, versions[1] is minor,\n-     and versions[3] is revision.  */\n+  /* versions[0]: major version.\n+     versions[1]: minor version.\n+     versions[2]: revision version.  */\n   unsigned versions[3] = {0}, number = 0;\n   unsigned int i;\n \n-  /* Re-write arch attribute to normalize the arch string.  */\n+  /* Re-write architecture elf attribute.  */\n   arch_str = riscv_arch_str (xlen, &riscv_subsets);\n   bfd_elf_add_proc_attr_string (stdoutput, Tag_RISCV_arch, arch_str);\n   xfree ((void *)arch_str);\n \n   /* For the file without any instruction, we don't set the default_priv_spec\n-     according to the priv attributes since the md_assemble isn't called.\n-     Call riscv_set_default_priv_spec here for the above case, although\n-     it seems strange.  */\n+     according to the privileged elf attributes since the md_assemble isn't\n+     called.  */\n   if (!start_assemble\n       && !riscv_set_default_priv_spec (NULL))\n     return;\n \n-  /* If we already have set elf priv attributes, then no need to do anything,\n-     assembler will generate them according to what you set.  Otherwise, don't\n-     generate or update them when no CSR and priv instructions are used.\n-     Generate the priv attributes according to default_priv_spec, which can be\n-     set by -mpriv-spec and --with-priv-spec, and be updated by the original\n-     priv attribute sets.  */\n+  /* If we already have set privileged elf attributes, then no need to do\n+     anything.  Otherwise, don't generate or update them when no CSR and\n+     privileged instructions are used.  */\n   if (!explicit_priv_attr)\n     return;\n \n-  /* Re-write priv attributes by default_priv_spec.  */\n   priv_str = riscv_get_priv_spec_name (default_priv_spec);\n   p = priv_str;\n   for (i = 0; *p; ++p)\n@@ -3701,15 +3674,13 @@ riscv_write_out_attrs (void)\n     }\n   versions[i] = number;\n \n-  /* Set the priv attributes.  */\n+  /* Re-write privileged elf attributes.  */\n   bfd_elf_add_proc_attr_int (stdoutput, Tag_RISCV_priv_spec, versions[0]);\n   bfd_elf_add_proc_attr_int (stdoutput, Tag_RISCV_priv_spec_minor, versions[1]);\n   bfd_elf_add_proc_attr_int (stdoutput, Tag_RISCV_priv_spec_revision, versions[2]);\n }\n \n-/* Add the default contents for the .riscv.attributes section.  If any\n-   ELF attribute or -march-attr options is set, call riscv_write_out_attrs\n-   to update the arch and priv attributes.  */\n+/* Add the default contents for the .riscv.attributes section.  */\n \n static void\n riscv_set_public_attributes (void)\n@@ -3806,11 +3777,9 @@ s_riscv_attribute (int ignored ATTRIBUTE_UNUSED)\n     }\n }\n \n-/* Pseudo-op table.  */\n-\n+/* RISC-V pseudo-ops table.  */\n static const pseudo_typeS riscv_pseudo_table[] =\n {\n-  /* RISC-V-specific pseudo-ops.  */\n   {\"option\", s_riscv_option, 0},\n   {\"half\", cons, 2},\n   {\"word\", cons, 4},"
    },
    {
      "sha": "6ac5d9f196d314cbc65286245d8d281d4a80aac7",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -1,3 +1,9 @@\n+2021-01-15  Nelson Chu  <nelson.chu@sifive.com>\n+\n+\t* elf/riscv.h: Comments tidy and improvement.\n+\t* opcode/riscv-opc.h: Likewise.\n+\t* opcode/riscv.h: Likewise.\n+\n 2021-01-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* opcode/aarch64.h (AARCH64_FEATURE_CSRE): Delete."
    },
    {
      "sha": "fb376a096abd79763fb4e6196db2e0405b4fe454",
      "filename": "include/elf/riscv.h",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/include/elf/riscv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/include/elf/riscv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/elf/riscv.h?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -118,10 +118,9 @@ END_RELOC_NUMBERS (R_RISCV_max)\n #define RISCV_GP_SYMBOL \"__global_pointer$\"\n \n /* Additional section types.  */\n-#define SHT_RISCV_ATTRIBUTES   0x70000003  /* Section holds attributes.  */\n+#define SHT_RISCV_ATTRIBUTES 0x70000003 /* Section holds attributes.  */\n \n /* Object attributes.  */\n-\n enum\n {\n   /* 0-3 are generic.  */"
    },
    {
      "sha": "c16f3f4e7ac0b0515d93523eb2f5d552623e47e8",
      "filename": "include/opcode/riscv-opc.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/include/opcode/riscv-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/include/opcode/riscv-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/opcode/riscv-opc.h?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -669,7 +669,7 @@\n #define MASK_CUSTOM3_RD_RS1  0x707f\n #define MATCH_CUSTOM3_RD_RS1_RS2 0x707b\n #define MASK_CUSTOM3_RD_RS1_RS2  0x707f\n-/* Privileged CSR addresses (v1.11).  */\n+/* Privileged CSR addresses.  */\n #define CSR_USTATUS 0x0\n #define CSR_UIE 0x4\n #define CSR_UTVEC 0x5\n@@ -916,7 +916,7 @@\n #define CSR_TCONTROL 0x7a5\n #define CSR_MCONTEXT 0x7a8\n #define CSR_SCONTEXT 0x7aa\n-#endif /* RISCV_ENCODING_H.  */\n+#endif /* RISCV_ENCODING_H */\n #ifdef DECLARE_INSN\n DECLARE_INSN(slli_rv32, MATCH_SLLI_RV32, MASK_SLLI_RV32)\n DECLARE_INSN(srli_rv32, MATCH_SRLI_RV32, MASK_SRLI_RV32)\n@@ -1238,9 +1238,9 @@ DECLARE_INSN(custom3_rs1_rs2, MATCH_CUSTOM3_RS1_RS2, MASK_CUSTOM3_RS1_RS2)\n DECLARE_INSN(custom3_rd, MATCH_CUSTOM3_RD, MASK_CUSTOM3_RD)\n DECLARE_INSN(custom3_rd_rs1, MATCH_CUSTOM3_RD_RS1, MASK_CUSTOM3_RD_RS1)\n DECLARE_INSN(custom3_rd_rs1_rs2, MATCH_CUSTOM3_RD_RS1_RS2, MASK_CUSTOM3_RD_RS1_RS2)\n-#endif /* DECLARE_INSN.  */\n+#endif /* DECLARE_INSN */\n #ifdef DECLARE_CSR\n-/* Privileged.  */\n+/* Privileged CSRs.  */\n DECLARE_CSR(ustatus, CSR_USTATUS, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_DRAFT)\n DECLARE_CSR(uie, CSR_UIE, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_DRAFT)\n DECLARE_CSR(utvec, CSR_UTVEC, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_DRAFT)\n@@ -1453,7 +1453,7 @@ DECLARE_CSR(mhpmevent28, CSR_MHPMEVENT28, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PR\n DECLARE_CSR(mhpmevent29, CSR_MHPMEVENT29, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_DRAFT)\n DECLARE_CSR(mhpmevent30, CSR_MHPMEVENT30, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_DRAFT)\n DECLARE_CSR(mhpmevent31, CSR_MHPMEVENT31, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_DRAFT)\n-/* Dropped.  */\n+/* Dropped CSRs.  */\n DECLARE_CSR(hstatus, CSR_HSTATUS, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_1P10)\n DECLARE_CSR(hedeleg, CSR_HEDELEG, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_1P10)\n DECLARE_CSR(hideleg, CSR_HIDELEG, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_1P10)\n@@ -1472,7 +1472,7 @@ DECLARE_CSR(mdbase, CSR_MDBASE, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CL\n DECLARE_CSR(mdbound, CSR_MDBOUND, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_1P10)\n DECLARE_CSR(mscounteren, CSR_MSCOUNTEREN, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_1P10)\n DECLARE_CSR(mhcounteren, CSR_MHCOUNTEREN, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_1P10)\n-/* Unprivileged.  */\n+/* Unprivileged CSRs.  */\n DECLARE_CSR(fflags, CSR_FFLAGS, CSR_CLASS_F, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n DECLARE_CSR(frm, CSR_FRM, CSR_CLASS_F, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n DECLARE_CSR(fcsr, CSR_FCSR, CSR_CLASS_F, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n@@ -1488,7 +1488,7 @@ DECLARE_CSR(tinfo, CSR_TINFO, CSR_CLASS_DEBUG, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_C\n DECLARE_CSR(tcontrol, CSR_TCONTROL, CSR_CLASS_DEBUG, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n DECLARE_CSR(mcontext, CSR_MCONTEXT, CSR_CLASS_DEBUG, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n DECLARE_CSR(scontext, CSR_SCONTEXT, CSR_CLASS_DEBUG, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n-#endif /* DECLARE_CSR.  */\n+#endif /* DECLARE_CSR */\n #ifdef DECLARE_CSR_ALIAS\n DECLARE_CSR_ALIAS(ubadaddr, CSR_UTVAL, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_1P10)\n DECLARE_CSR_ALIAS(sbadaddr, CSR_STVAL, CSR_CLASS_I, PRIV_SPEC_CLASS_1P9P1, PRIV_SPEC_CLASS_1P10)\n@@ -1502,4 +1502,4 @@ DECLARE_CSR_ALIAS(itrigger, CSR_TDATA1, CSR_CLASS_DEBUG, PRIV_SPEC_CLASS_NONE, P\n DECLARE_CSR_ALIAS(etrigger, CSR_TDATA1, CSR_CLASS_DEBUG, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n DECLARE_CSR_ALIAS(textra32, CSR_TDATA3, CSR_CLASS_DEBUG, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n DECLARE_CSR_ALIAS(textra64, CSR_TDATA3, CSR_CLASS_DEBUG, PRIV_SPEC_CLASS_NONE, PRIV_SPEC_CLASS_NONE)\n-#endif /* DECLARE_CSR_ALIAS.  */\n+#endif /* DECLARE_CSR_ALIAS */"
    },
    {
      "sha": "e7dc2c79cbbf49bf85c1c1a57dbb70b4f80918d8",
      "filename": "include/opcode/riscv.h",
      "status": "modified",
      "additions": 9,
      "deletions": 23,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/include/opcode/riscv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/include/opcode/riscv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/opcode/riscv.h?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -29,13 +29,13 @@ typedef uint64_t insn_t;\n \n static inline unsigned int riscv_insn_length (insn_t insn)\n {\n-  if ((insn & 0x3) != 0x3) /* RVC.  */\n+  if ((insn & 0x3) != 0x3) /* RVC instructions.  */\n     return 2;\n-  if ((insn & 0x1f) != 0x1f) /* Base ISA and extensions in 32-bit space.  */\n+  if ((insn & 0x1f) != 0x1f) /* 32-bit instructions.  */\n     return 4;\n-  if ((insn & 0x3f) == 0x1f) /* 48-bit extensions.  */\n+  if ((insn & 0x3f) == 0x1f) /* 48-bit instructions.  */\n     return 6;\n-  if ((insn & 0x7f) == 0x3f) /* 64-bit extensions.  */\n+  if ((insn & 0x7f) == 0x3f) /* 64-bit instructions.  */\n     return 8;\n   /* Longer instructions not supported at the moment.  */\n   return 2;\n@@ -291,11 +291,10 @@ static const char * const riscv_pred_succ[16] =\n #define EXTRACT_OPERAND(FIELD, INSN) \\\n   EXTRACT_BITS ((INSN), OP_MASK_##FIELD, OP_SH_##FIELD)\n \n-/* The maximal number of subset can be required. */\n+/* The maximal number of subset can be required.  */\n #define MAX_SUBSET_NUM 4\n \n /* All RISC-V instructions belong to at least one of these classes.  */\n-\n enum riscv_insn_class\n   {\n    INSN_CLASS_NONE,\n@@ -319,7 +318,6 @@ enum riscv_insn_class\n   };\n \n /* This structure holds information for a particular instruction.  */\n-\n struct riscv_opcode\n {\n   /* The name of the instruction.  */\n@@ -351,7 +349,6 @@ struct riscv_opcode\n };\n \n /* The current supported ISA spec versions.  */\n-\n enum riscv_isa_spec_class\n {\n   ISA_SPEC_CLASS_NONE,\n@@ -365,7 +362,6 @@ enum riscv_isa_spec_class\n #define RISCV_UNKNOWN_VERSION -1\n \n /* This structure holds version information for specific ISA.  */\n-\n struct riscv_ext_version\n {\n   const char *name;\n@@ -375,19 +371,17 @@ struct riscv_ext_version\n };\n \n /* All RISC-V CSR belong to one of these classes.  */\n-\n enum riscv_csr_class\n {\n   CSR_CLASS_NONE,\n \n   CSR_CLASS_I,\n-  CSR_CLASS_I_32,      /* rv32 only */\n-  CSR_CLASS_F,         /* f-ext only */\n-  CSR_CLASS_DEBUG      /* debug CSR */\n+  CSR_CLASS_I_32, /* RV32 only.  */\n+  CSR_CLASS_F, /* F extension only.  */\n+  CSR_CLASS_DEBUG /* Debug CSR.  */\n };\n \n /* The current supported privilege spec versions.  */\n-\n enum riscv_priv_spec_class\n {\n   PRIV_SPEC_CLASS_NONE,\n@@ -399,7 +393,6 @@ enum riscv_priv_spec_class\n };\n \n /* This structure holds all restricted conditions for a CSR.  */\n-\n struct riscv_csr_extra\n {\n   /* Class to which this CSR belongs.  Used to decide whether or\n@@ -452,14 +445,7 @@ struct riscv_csr_extra\n    disassembler, and requires special treatment by the assembler.  */\n #define INSN_MACRO\t\t0xffffffff\n \n-/* This is a list of macro expanded instructions.\n-\n-   _I appended means immediate\n-   _A appended means address\n-   _AB appended means address with base register\n-   _D appended means 64 bit floating point constant\n-   _S appended means 32 bit floating point constant.  */\n-\n+/* This is a list of macro expanded instructions.  */\n enum\n {\n   M_LA,"
    },
    {
      "sha": "6a449ff25bd0d3a95b3cd1834bfdd12ab48bf9b3",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -1,3 +1,8 @@\n+2021-01-15  Nelson Chu  <nelson.chu@sifive.com>\n+\n+\t* riscv-dis.c: Comments tidy and improvement.\n+\t* riscv-opc.c: Likewise.\n+\n 2021-01-13  Alan Modra  <amodra@gmail.com>\n \n \t* Makefile.in: Regenerate."
    },
    {
      "sha": "d6d66e4c0a1f5f03d314adf5555a917a70d40e16",
      "filename": "opcodes/riscv-dis.c",
      "status": "modified",
      "additions": 13,
      "deletions": 15,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/opcodes/riscv-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/opcodes/riscv-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/riscv-dis.c?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -44,8 +44,8 @@ struct riscv_private_data\n static const char * const *riscv_gpr_names;\n static const char * const *riscv_fpr_names;\n \n-/* Other options.  */\n-static int no_aliases;\t/* If set disassemble as most general inst.  */\n+/* If set, disassemble as most general instruction.  */\n+static int no_aliases;\n \n static void\n set_default_riscv_dis_options (void)\n@@ -179,20 +179,20 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n \tcase 'C': /* RVC */\n \t  switch (*++d)\n \t    {\n-\t    case 's': /* RS1 x8-x15 */\n-\t    case 'w': /* RS1 x8-x15 */\n+\t    case 's': /* RS1 x8-x15.  */\n+\t    case 'w': /* RS1 x8-x15.  */\n \t      print (info->stream, \"%s\",\n \t\t     riscv_gpr_names[EXTRACT_OPERAND (CRS1S, l) + 8]);\n \t      break;\n-\t    case 't': /* RS2 x8-x15 */\n-\t    case 'x': /* RS2 x8-x15 */\n+\t    case 't': /* RS2 x8-x15.  */\n+\t    case 'x': /* RS2 x8-x15.  */\n \t      print (info->stream, \"%s\",\n \t\t     riscv_gpr_names[EXTRACT_OPERAND (CRS2S, l) + 8]);\n \t      break;\n-\t    case 'U': /* RS1, constrained to equal RD */\n+\t    case 'U': /* RS1, constrained to equal RD.  */\n \t      print (info->stream, \"%s\", riscv_gpr_names[rd]);\n \t      break;\n-\t    case 'c': /* RS1, constrained to equal sp */\n+\t    case 'c': /* RS1, constrained to equal sp.  */\n \t      print (info->stream, \"%s\", riscv_gpr_names[X_SP]);\n \t      break;\n \t    case 'V': /* RS2 */\n@@ -248,11 +248,11 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n \t    case '<':\n \t      print (info->stream, \"0x%x\", (int)EXTRACT_RVC_IMM (l) & 0x1f);\n \t      break;\n-\t    case 'T': /* floating-point RS2 */\n+\t    case 'T': /* Floating-point RS2.  */\n \t      print (info->stream, \"%s\",\n \t\t     riscv_fpr_names[EXTRACT_OPERAND (CRS2, l)]);\n \t      break;\n-\t    case 'D': /* floating-point RS2 x8-x15 */\n+\t    case 'D': /* Floating-point RS2 x8-x15.  */\n \t      print (info->stream, \"%s\",\n \t\t     riscv_fpr_names[EXTRACT_OPERAND (CRS2S, l) + 8]);\n \t      break;\n@@ -268,7 +268,7 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n \t  break;\n \n \tcase '0':\n-\t  /* Only print constant 0 if it is the last argument */\n+\t  /* Only print constant 0 if it is the last argument.  */\n \t  if (!d[1])\n \t    print (info->stream, \"0\");\n \t  break;\n@@ -371,7 +371,7 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n \n \tcase 'E':\n \t  {\n-\t    static const char *riscv_csr_hash[4096];    /* Total 2^12 CSR.  */\n+\t    static const char *riscv_csr_hash[4096]; /* Total 2^12 CSRs.  */\n \t    static bfd_boolean init_csr = FALSE;\n \t    unsigned int csr = EXTRACT_OPERAND (CSR, l);\n \n@@ -381,7 +381,7 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n \t\tfor (i = 0; i < 4096; i++)\n \t\t  riscv_csr_hash[i] = NULL;\n \n-\t\t/* Set to the newest privilege version.  */\n+\t\t/* Set to the newest privileged version.  */\n \t\tif (default_priv_spec == PRIV_SPEC_CLASS_NONE)\n \t\t  default_priv_spec = PRIV_SPEC_CLASS_DRAFT - 1;\n \n@@ -593,8 +593,6 @@ print_insn_riscv (bfd_vma memaddr, struct disassemble_info *info)\n disassembler_ftype\n riscv_get_disassembler (bfd *abfd)\n {\n-  /* If -Mpriv-spec= isn't set, then try to set it by checking the elf\n-     privileged attributes.  */\n   if (abfd)\n     {\n       const char *sec_name = get_elf_backend_data (abfd)->obj_attrs_section;"
    },
    {
      "sha": "34aa3c8e1b494e4487cf319eba0c6c78f46609fa",
      "filename": "opcodes/riscv-opc.c",
      "status": "modified",
      "additions": 16,
      "deletions": 17,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/opcodes/riscv-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dcd709e056c6f4b7ffff759b9b6ecab1177083ed/opcodes/riscv-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/riscv-opc.c?ref=dcd709e056c6f4b7ffff759b9b6ecab1177083ed",
      "patch": "@@ -198,9 +198,9 @@ match_srxi_as_c_srxi (const struct riscv_opcode *op, insn_t insn)\n \n const struct riscv_opcode riscv_opcodes[] =\n {\n-/* name,     xlen, isa,   operands, match, mask, match_func, pinfo.  */\n+/* name, xlen, isa, operands, match, mask, match_func, pinfo.  */\n {\"unimp\",       0, INSN_CLASS_C,   \"\",  0, 0xffffU,  match_opcode, INSN_ALIAS },\n-{\"unimp\",       0, INSN_CLASS_I,   \"\",  MATCH_CSRRW | (CSR_CYCLE << OP_SH_CSR), 0xffffffffU,  match_opcode, 0 }, /* csrw cycle, x0 */\n+{\"unimp\",       0, INSN_CLASS_I,   \"\",  MATCH_CSRRW | (CSR_CYCLE << OP_SH_CSR), 0xffffffffU,  match_opcode, 0 }, /* csrw cycle, x0  */\n {\"ebreak\",      0, INSN_CLASS_C,   \"\",  MATCH_C_EBREAK, MASK_C_EBREAK, match_opcode, INSN_ALIAS },\n {\"ebreak\",      0, INSN_CLASS_I,   \"\",    MATCH_EBREAK, MASK_EBREAK, match_opcode, 0 },\n {\"sbreak\",      0, INSN_CLASS_C,   \"\",  MATCH_C_EBREAK, MASK_C_EBREAK, match_opcode, INSN_ALIAS },\n@@ -233,7 +233,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"lui\",         0, INSN_CLASS_I,   \"d,u\",  MATCH_LUI, MASK_LUI, match_opcode, 0 },\n {\"li\",          0, INSN_CLASS_C,   \"d,Cv\",  MATCH_C_LUI, MASK_C_LUI, match_c_lui, INSN_ALIAS },\n {\"li\",          0, INSN_CLASS_C,   \"d,Co\",  MATCH_C_LI, MASK_C_LI, match_rd_nonzero, INSN_ALIAS },\n-{\"li\",          0, INSN_CLASS_I,   \"d,j\",      MATCH_ADDI, MASK_ADDI | MASK_RS1, match_opcode, INSN_ALIAS }, /* addi */\n+{\"li\",          0, INSN_CLASS_I,   \"d,j\",      MATCH_ADDI, MASK_ADDI | MASK_RS1, match_opcode, INSN_ALIAS }, /* addi  */\n {\"li\",          0, INSN_CLASS_I,   \"d,I\",  0,    (int) M_LI,  match_never, INSN_MACRO },\n {\"mv\",          0, INSN_CLASS_C,   \"d,CV\",  MATCH_C_MV, MASK_C_MV, match_c_add, INSN_ALIAS },\n {\"mv\",          0, INSN_CLASS_I,   \"d,s\",  MATCH_ADDI, MASK_ADDI | MASK_IMM, match_opcode, INSN_ALIAS },\n@@ -280,15 +280,13 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"add\",         0, INSN_CLASS_C,   \"Cc,Cc,CL\", MATCH_C_ADDI16SP, MASK_C_ADDI16SP, match_c_addi16sp, INSN_ALIAS },\n {\"add\",         0, INSN_CLASS_C,   \"d,Cz,CV\",  MATCH_C_MV, MASK_C_MV, match_c_add, INSN_ALIAS },\n {\"add\",         0, INSN_CLASS_I,   \"d,s,t\",  MATCH_ADD, MASK_ADD, match_opcode, 0 },\n-/* This is used for TLS, where the fourth arg is %tprel_add, to get a reloc\n-   applied to an add instruction, for relaxation to use.  */\n {\"add\",         0, INSN_CLASS_I,   \"d,s,t,1\",MATCH_ADD, MASK_ADD, match_opcode, 0 },\n {\"add\",         0, INSN_CLASS_I,   \"d,s,j\",  MATCH_ADDI, MASK_ADDI, match_opcode, INSN_ALIAS },\n {\"la\",          0, INSN_CLASS_I,   \"d,B\",  0,    (int) M_LA,  match_never, INSN_MACRO },\n {\"lla\",         0, INSN_CLASS_I,   \"d,B\",  0,    (int) M_LLA,  match_never, INSN_MACRO },\n {\"la.tls.gd\",   0, INSN_CLASS_I,   \"d,A\",  0,    (int) M_LA_TLS_GD,  match_never, INSN_MACRO },\n {\"la.tls.ie\",   0, INSN_CLASS_I,   \"d,A\",  0,    (int) M_LA_TLS_IE,  match_never, INSN_MACRO },\n-{\"neg\",         0, INSN_CLASS_I,   \"d,t\",  MATCH_SUB, MASK_SUB | MASK_RS1, match_opcode, INSN_ALIAS }, /* sub 0 */\n+{\"neg\",         0, INSN_CLASS_I,   \"d,t\",  MATCH_SUB, MASK_SUB | MASK_RS1, match_opcode, INSN_ALIAS }, /* sub 0  */\n {\"slli\",        0, INSN_CLASS_C,   \"d,CU,C>\",  MATCH_C_SLLI, MASK_C_SLLI, match_slli_as_c_slli, INSN_ALIAS },\n {\"slli\",        0, INSN_CLASS_I,   \"d,s,>\",   MATCH_SLLI, MASK_SLLI, match_opcode, 0 },\n {\"sll\",         0, INSN_CLASS_C,   \"d,CU,C>\",  MATCH_C_SLLI, MASK_C_SLLI, match_slli_as_c_slli, INSN_ALIAS },\n@@ -382,7 +380,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"addw\",       64, INSN_CLASS_C, \"d,CU,Co\",  MATCH_C_ADDIW, MASK_C_ADDIW, match_rd_nonzero, INSN_ALIAS },\n {\"addw\",       64, INSN_CLASS_I, \"d,s,t\",  MATCH_ADDW, MASK_ADDW, match_opcode, 0 },\n {\"addw\",       64, INSN_CLASS_I, \"d,s,j\",  MATCH_ADDIW, MASK_ADDIW, match_opcode, INSN_ALIAS },\n-{\"negw\",       64, INSN_CLASS_I, \"d,t\",  MATCH_SUBW, MASK_SUBW | MASK_RS1, match_opcode, INSN_ALIAS }, /* sub 0 */\n+{\"negw\",       64, INSN_CLASS_I, \"d,t\",  MATCH_SUBW, MASK_SUBW | MASK_RS1, match_opcode, INSN_ALIAS }, /* sub 0  */\n {\"slliw\",      64, INSN_CLASS_I, \"d,s,<\",   MATCH_SLLIW, MASK_SLLIW, match_opcode, 0 },\n {\"sllw\",       64, INSN_CLASS_I, \"d,s,t\",   MATCH_SLLW, MASK_SLLW, match_opcode, 0 },\n {\"sllw\",       64, INSN_CLASS_I, \"d,s,<\",   MATCH_SLLIW, MASK_SLLIW, match_opcode, INSN_ALIAS },\n@@ -395,7 +393,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"subw\",       64, INSN_CLASS_C, \"Cs,Cw,Ct\",  MATCH_C_SUBW, MASK_C_SUBW, match_opcode, INSN_ALIAS },\n {\"subw\",       64, INSN_CLASS_I, \"d,s,t\",  MATCH_SUBW, MASK_SUBW, match_opcode, 0 },\n \n-/* Atomic memory operation instruction subset */\n+/* Atomic memory operation instruction subset.  */\n {\"lr.w\",         0, INSN_CLASS_A,   \"d,0(s)\",    MATCH_LR_W, MASK_LR_W | MASK_AQRL, match_opcode, INSN_DREF|INSN_4_BYTE },\n {\"sc.w\",         0, INSN_CLASS_A,   \"d,t,0(s)\",  MATCH_SC_W, MASK_SC_W | MASK_AQRL, match_opcode, INSN_DREF|INSN_4_BYTE },\n {\"amoadd.w\",     0, INSN_CLASS_A,   \"d,t,0(s)\",  MATCH_AMOADD_W, MASK_AMOADD_W | MASK_AQRL, match_opcode, INSN_DREF|INSN_4_BYTE },\n@@ -485,7 +483,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"amomin.d.aqrl\",  64, INSN_CLASS_A , \"d,t,0(s)\",  MATCH_AMOMIN_D | MASK_AQRL, MASK_AMOMIN_D | MASK_AQRL, match_opcode, INSN_DREF|INSN_8_BYTE },\n {\"amominu.d.aqrl\", 64, INSN_CLASS_A , \"d,t,0(s)\",  MATCH_AMOMINU_D | MASK_AQRL, MASK_AMOMINU_D | MASK_AQRL, match_opcode, INSN_DREF|INSN_8_BYTE },\n \n-/* Multiply/Divide instruction subset */\n+/* Multiply/Divide instruction subset.  */\n {\"mul\",       0, INSN_CLASS_M,   \"d,s,t\",  MATCH_MUL, MASK_MUL, match_opcode, 0 },\n {\"mulh\",      0, INSN_CLASS_M,   \"d,s,t\",  MATCH_MULH, MASK_MULH, match_opcode, 0 },\n {\"mulhu\",     0, INSN_CLASS_M,   \"d,s,t\",  MATCH_MULHU, MASK_MULHU, match_opcode, 0 },\n@@ -500,7 +498,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"remw\",     64, INSN_CLASS_M, \"d,s,t\",  MATCH_REMW, MASK_REMW, match_opcode, 0 },\n {\"remuw\",    64, INSN_CLASS_M, \"d,s,t\",  MATCH_REMUW, MASK_REMUW, match_opcode, 0 },\n \n-/* Bitmanip instruction subset - ZBA/ZBB/ZBC  */\n+/* Bitmanip instruction subset - ZBA/ZBB/ZBC.  */\n {\"sh1add\",    0, INSN_CLASS_ZBA,   \"d,s,t\",  MATCH_SH1ADD, MASK_SH1ADD, match_opcode, 0 },\n {\"sh2add\",    0, INSN_CLASS_ZBA,   \"d,s,t\",  MATCH_SH2ADD, MASK_SH2ADD, match_opcode, 0 },\n {\"sh3add\",    0, INSN_CLASS_ZBA,   \"d,s,t\",  MATCH_SH3ADD, MASK_SH3ADD, match_opcode, 0 },\n@@ -548,7 +546,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"clmulh\",    0, INSN_CLASS_ZBC,   \"d,s,t\",  MATCH_CLMULH, MASK_CLMULH, match_opcode, 0 },\n {\"clmulr\",    0, INSN_CLASS_ZBC,   \"d,s,t\",  MATCH_CLMULR, MASK_CLMULR, match_opcode, 0 },\n \n-/* Single-precision floating-point instruction subset */\n+/* Single-precision floating-point instruction subset.  */\n {\"frcsr\",     0, INSN_CLASS_F,   \"d\",  MATCH_FRCSR, MASK_FRCSR, match_opcode, INSN_ALIAS },\n {\"frsr\",      0, INSN_CLASS_F,   \"d\",  MATCH_FRCSR, MASK_FRCSR, match_opcode, INSN_ALIAS },\n {\"fscsr\",     0, INSN_CLASS_F,   \"s\",  MATCH_FSCSR, MASK_FSCSR | MASK_RD, match_opcode, INSN_ALIAS },\n@@ -629,7 +627,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"fcvt.s.lu\", 64, INSN_CLASS_F, \"D,s\",  MATCH_FCVT_S_LU | MASK_RM, MASK_FCVT_S_L | MASK_RM, match_opcode, 0 },\n {\"fcvt.s.lu\", 64, INSN_CLASS_F, \"D,s,m\",  MATCH_FCVT_S_LU, MASK_FCVT_S_LU, match_opcode, 0 },\n \n-/* Double-precision floating-point instruction subset */\n+/* Double-precision floating-point instruction subset.  */\n {\"fld\",        0, INSN_CLASS_D_AND_C,   \"D,Cn(Cc)\",  MATCH_C_FLDSP, MASK_C_FLDSP, match_opcode, INSN_ALIAS|INSN_DREF|INSN_8_BYTE },\n {\"fld\",        0, INSN_CLASS_D_AND_C,   \"CD,Cl(Cs)\",  MATCH_C_FLD, MASK_C_FLD, match_opcode, INSN_ALIAS|INSN_DREF|INSN_8_BYTE },\n {\"fld\",        0, INSN_CLASS_D,   \"D,o(s)\",  MATCH_FLD, MASK_FLD, match_opcode, INSN_DREF|INSN_8_BYTE },\n@@ -690,7 +688,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"fcvt.d.lu\", 64, INSN_CLASS_D, \"D,s\",  MATCH_FCVT_D_LU | MASK_RM, MASK_FCVT_D_L | MASK_RM, match_opcode, 0 },\n {\"fcvt.d.lu\", 64, INSN_CLASS_D, \"D,s,m\",  MATCH_FCVT_D_LU, MASK_FCVT_D_LU, match_opcode, 0 },\n \n-/* Quad-precision floating-point instruction subset */\n+/* Quad-precision floating-point instruction subset.  */\n {\"flq\",        0, INSN_CLASS_Q,   \"D,o(s)\",  MATCH_FLQ, MASK_FLQ, match_opcode, INSN_DREF|INSN_16_BYTE },\n {\"flq\",        0, INSN_CLASS_Q,   \"D,A,s\",  0, (int) M_FLQ, match_never, INSN_MACRO },\n {\"fsq\",        0, INSN_CLASS_Q,   \"T,q(s)\",  MATCH_FSQ, MASK_FSQ, match_opcode, INSN_DREF|INSN_16_BYTE },\n@@ -799,7 +797,7 @@ const struct riscv_opcode riscv_opcodes[] =\n {\"c.fswsp\",   32, INSN_CLASS_F_AND_C, \"CT,CM(Cc)\",  MATCH_C_FSWSP, MASK_C_FSWSP, match_opcode, INSN_DREF|INSN_4_BYTE },\n {\"c.fsw\",     32, INSN_CLASS_F_AND_C, \"CD,Ck(Cs)\",  MATCH_C_FSW, MASK_C_FSW, match_opcode, INSN_DREF|INSN_4_BYTE },\n \n-/* Supervisor instructions */\n+/* Supervisor instructions.  */\n {\"csrr\",       0, INSN_CLASS_ZICSR,   \"d,E\",  MATCH_CSRRS, MASK_CSRRS | MASK_RS1, match_opcode, INSN_ALIAS },\n {\"csrwi\",      0, INSN_CLASS_ZICSR,   \"E,Z\",  MATCH_CSRRWI, MASK_CSRRWI | MASK_RD, match_opcode, INSN_ALIAS },\n {\"csrsi\",      0, INSN_CLASS_ZICSR,   \"E,Z\",  MATCH_CSRRSI, MASK_CSRRSI | MASK_RD, match_opcode, INSN_ALIAS },\n@@ -838,7 +836,7 @@ const struct riscv_opcode riscv_opcodes[] =\n /* Instruction format for .insn directive.  */\n const struct riscv_opcode riscv_insn_types[] =\n {\n-/* name, xlen, isa,          operands, match, mask,    match_func, pinfo.  */\n+/* name, xlen, isa, operands, match, mask, match_func, pinfo.  */\n {\"r\",       0, INSN_CLASS_I,  \"O4,F3,F7,d,s,t\",     0,    0,  match_opcode, 0 },\n {\"r\",       0, INSN_CLASS_F,  \"O4,F3,F7,D,s,t\",     0,    0,  match_opcode, 0 },\n {\"r\",       0, INSN_CLASS_F,  \"O4,F3,F7,d,S,t\",     0,    0,  match_opcode, 0 },\n@@ -932,14 +930,15 @@ const struct riscv_opcode riscv_insn_types[] =\n {\"cb\",      0, INSN_CLASS_F_AND_C,  \"O2,CF3,CS,Cp\",       0,    0,  match_opcode, 0 },\n \n {\"cj\",      0, INSN_CLASS_C,  \"O2,CF3,Ca\",          0,    0,  match_opcode, 0 },\n+\n /* Terminate the list.  */\n {0, 0, INSN_CLASS_NONE, 0, 0, 0, 0, 0}\n };\n \n /* All standard extensions defined in all supported ISA spec.  */\n const struct riscv_ext_version riscv_ext_version_table[] =\n {\n-/* name, ISA spec, major version, minor_version.  */\n+/* name, ISA spec, major version, minor version.  */\n {\"e\", ISA_SPEC_CLASS_20191213, 1, 9},\n {\"e\", ISA_SPEC_CLASS_20190608, 1, 9},\n {\"e\", ISA_SPEC_CLASS_2P2,      1, 9},\n@@ -1001,7 +1000,7 @@ static const struct isa_spec_t isa_specs[] =\n   {\"20190608\", ISA_SPEC_CLASS_20190608},\n   {\"20191213\", ISA_SPEC_CLASS_20191213},\n \n-/* Terminate the list.  */\n+  /* Terminate the list.  */\n   {NULL, 0}\n };\n "
    }
  ]
}