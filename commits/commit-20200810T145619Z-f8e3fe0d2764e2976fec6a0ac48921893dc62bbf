{
  "sha": "f8e3fe0d2764e2976fec6a0ac48921893dc62bbf",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjhlM2ZlMGQyNzY0ZTI5NzZmZWM2YTBhYzQ4OTIxODkzZGM2MmJiZg==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-08-10T14:56:19Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-08-10T14:56:19Z"
    },
    "message": "[AArch64] Improve prologue handling (and fix PR26310)\n\nI initially noticed the problem with the addition of\ngdb.dwarf2/dw2-line-number-zero.exp.  The following failures showed up:\n\nFAIL: gdb.dwarf2/dw2-line-number-zero.exp: continue to breakpoint: bar1\nFAIL: gdb.dwarf2/dw2-line-number-zero.exp: bar1, 1st next\nFAIL: gdb.dwarf2/dw2-line-number-zero.exp: bar1, 2nd next\nFAIL: gdb.dwarf2/dw2-line-number-zero.exp: continue to breakpoint: bar2\nFAIL: gdb.dwarf2/dw2-line-number-zero.exp: bar2, 1st next\nFAIL: gdb.dwarf2/dw2-line-number-zero.exp: bar2, 2nd next\n\nThey happen because AArch64's prologue analyzer skips too many instructions\nand ends up indicating a stopping point further into user code.\n\nDump of assembler code for function bar1:\n   0x00000000000006f8 <+0>:\tstp\tx29, x30, [sp, #-16]!\n   0x00000000000006fc <+4>:\tmov\tx29, sp\n   0x0000000000000700 <+8>:\tmov\tw0, #0x1                   \t// #1\n   0x0000000000000704 <+12>:\tbl\t0x6e4 <foo>\n   0x0000000000000708 <+16>:\tmov\tw0, #0x2                   \t// #2\n\nWe should've stopped at 0x700, but the analyzer actually skips\nthat instruction and stops at 0x704.  Then GDB ends up adjusting\nthe address further, and pushes the stopping point to 0x708 based on the\nSAL information.\n\nI'm not sure if this adjustment to 0x708 is correct though, as it ends up\nskipping past a branch. But I'm leaving that aside for now.\n\nOne other complicating factor is that GCC seems to be hoisting up instructions\nfrom user code, mixing them up with prologue instructions.\n\nThe following patch adjusts the heuristics a little bit, and tracks when the\nSP and FP get used.  If we notice an instruction that is not supposed to be\nin the prologue, and this happens *after* SP/FP adjustments and saving of\nregisters, we stop the analysis.\n\nThis means, for PR26310, that we will now stop at 0x700.\n\nI've also added a few more unit tests to make sure the updated behavior is\nvalidated.\n\ngdb/ChangeLog:\n\n2020-08-10  Luis Machado  <luis.machado@linaro.org>\n\n\tPR gdb/26310\n\n\t* aarch64-tdep.c (aarch64_analyze_prologue): Track use of SP/FP and\n\tact accordingly.\n\t(aarch64_analyze_prologue_test): Add more unit tests to exercise\n\tmovz/str/stur/stp skipping behavior.",
    "tree": {
      "sha": "1d11b79297b0789d4af22f4ff6ca50288c2d13c3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1d11b79297b0789d4af22f4ff6ca50288c2d13c3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f8e3fe0d2764e2976fec6a0ac48921893dc62bbf",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f8e3fe0d2764e2976fec6a0ac48921893dc62bbf",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f8e3fe0d2764e2976fec6a0ac48921893dc62bbf",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f8e3fe0d2764e2976fec6a0ac48921893dc62bbf/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cc308722fba3741a26993afe029078571604c2bd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cc308722fba3741a26993afe029078571604c2bd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cc308722fba3741a26993afe029078571604c2bd"
    }
  ],
  "stats": {
    "total": 148,
    "additions": 148,
    "deletions": 0
  },
  "files": [
    {
      "sha": "1306bd5f787d3d49fe5ae5214e096fadb30f2726",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f8e3fe0d2764e2976fec6a0ac48921893dc62bbf/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f8e3fe0d2764e2976fec6a0ac48921893dc62bbf/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f8e3fe0d2764e2976fec6a0ac48921893dc62bbf",
      "patch": "@@ -1,3 +1,12 @@\n+2020-08-10  Luis Machado  <luis.machado@linaro.org>\n+\n+\tPR gdb/26310\n+\n+\t* aarch64-tdep.c (aarch64_analyze_prologue): Track use of SP/FP and\n+\tact accordingly.\n+\t(aarch64_analyze_prologue_test): Add more unit tests to exercise\n+\tmovz/str/stur/stp skipping behavior.\n+\n 2020-08-10  Luis Machado  <luis.machado@linaro.org>\n \n \t* nat/aarch64-sve-linux-sigcontext.h (SVE_PT_REGS_OFFSET): Use"
    },
    {
      "sha": "106939a1222ab20648f6a11feb833e36deb461ed",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 139,
      "deletions": 0,
      "changes": 139,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f8e3fe0d2764e2976fec6a0ac48921893dc62bbf/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f8e3fe0d2764e2976fec6a0ac48921893dc62bbf/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=f8e3fe0d2764e2976fec6a0ac48921893dc62bbf",
      "patch": "@@ -287,6 +287,12 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n {\n   enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);\n   int i;\n+\n+  /* Whether the stack has been set.  This should be true when we notice a SP\n+     to FP move or if we are using the SP as the base register for storing\n+     data, in case the FP is ommitted.  */\n+  bool seen_stack_set = false;\n+\n   /* Track X registers and D registers in prologue.  */\n   pv_t regs[AARCH64_X_REGISTER_COUNT + AARCH64_D_REGISTER_COUNT];\n \n@@ -326,6 +332,10 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n \t      regs[rd] = pv_add_constant (regs[rn],\n \t\t\t\t\t  -inst.operands[2].imm.value);\n \t    }\n+\n+\t  /* Did we move SP to FP?  */\n+\t  if (rn == AARCH64_SP_REGNUM && rd == AARCH64_FP_REGNUM)\n+\t    seen_stack_set = true;\n \t}\n       else if (inst.opcode->iclass == pcreladdr\n \t       && inst.operands[1].type == AARCH64_OPND_ADDR_ADRP)\n@@ -358,6 +368,12 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n       else if (inst.opcode->op == OP_MOVZ)\n \t{\n \t  gdb_assert (inst.operands[0].type == AARCH64_OPND_Rd);\n+\n+\t  /* If this shows up before we set the stack, keep going.  Otherwise\n+\t     stop the analysis.  */\n+\t  if (seen_stack_set)\n+\t    break;\n+\n \t  regs[inst.operands[0].reg.regno] = pv_unknown ();\n \t}\n       else if (inst.opcode->iclass == log_shift\n@@ -399,6 +415,10 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n \t  stack.store\n \t    (pv_add_constant (regs[rn], inst.operands[1].addr.offset.imm),\n \t     size, regs[rt]);\n+\n+\t  /* Are we storing with SP as a base?  */\n+\t  if (rn == AARCH64_SP_REGNUM)\n+\t    seen_stack_set = true;\n \t}\n       else if ((inst.opcode->iclass == ldstpair_off\n \t\t|| (inst.opcode->iclass == ldstpair_indexed\n@@ -442,6 +462,10 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n \t  if (inst.operands[2].addr.writeback)\n \t    regs[rn] = pv_add_constant (regs[rn], imm);\n \n+\t  /* Ignore the instruction that allocates stack space and sets\n+\t     the SP.  */\n+\t  if (rn == AARCH64_SP_REGNUM && !inst.operands[2].addr.writeback)\n+\t    seen_stack_set = true;\n \t}\n       else if ((inst.opcode->iclass == ldst_imm9 /* Signed immediate.  */\n \t\t|| (inst.opcode->iclass == ldst_pos /* Unsigned immediate.  */\n@@ -464,6 +488,10 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n \t  stack.store (pv_add_constant (regs[rn], imm), size, regs[rt]);\n \t  if (inst.operands[1].addr.writeback)\n \t    regs[rn] = pv_add_constant (regs[rn], imm);\n+\n+\t  /* Are we storing with SP as a base?  */\n+\t  if (rn == AARCH64_SP_REGNUM)\n+\t    seen_stack_set = true;\n \t}\n       else if (inst.opcode->iclass == testbranch)\n \t{\n@@ -690,6 +718,117 @@ aarch64_analyze_prologue_test (void)\n       }\n   }\n \n+  /* Test handling of movz before setting the frame pointer.  */\n+  {\n+    static const uint32_t insns[] = {\n+      0xa9bf7bfd, /* stp     x29, x30, [sp, #-16]! */\n+      0x52800020, /* mov     w0, #0x1 */\n+      0x910003fd, /* mov     x29, sp */\n+      0x528000a2, /* mov     w2, #0x5 */\n+      0x97fffff8, /* bl      6e4 */\n+    };\n+\n+    instruction_reader_test reader (insns);\n+\n+    trad_frame_reset_saved_regs (gdbarch, cache.saved_regs);\n+    CORE_ADDR end = aarch64_analyze_prologue (gdbarch, 0, 128, &cache, reader);\n+\n+    /* We should stop at the 4th instruction.  */\n+    SELF_CHECK (end == (4 - 1) * 4);\n+    SELF_CHECK (cache.framereg == AARCH64_FP_REGNUM);\n+    SELF_CHECK (cache.framesize == 16);\n+  }\n+\n+  /* Test handling of movz/stp when using the stack pointer as frame\n+     pointer.  */\n+  {\n+    static const uint32_t insns[] = {\n+      0xa9bc7bfd, /* stp     x29, x30, [sp, #-64]! */\n+      0x52800020, /* mov     w0, #0x1 */\n+      0x290207e0, /* stp     w0, w1, [sp, #16] */\n+      0xa9018fe2, /* stp     x2, x3, [sp, #24] */\n+      0x528000a2, /* mov     w2, #0x5 */\n+      0x97fffff8, /* bl      6e4 */\n+    };\n+\n+    instruction_reader_test reader (insns);\n+\n+    trad_frame_reset_saved_regs (gdbarch, cache.saved_regs);\n+    CORE_ADDR end = aarch64_analyze_prologue (gdbarch, 0, 128, &cache, reader);\n+\n+    /* We should stop at the 5th instruction.  */\n+    SELF_CHECK (end == (5 - 1) * 4);\n+    SELF_CHECK (cache.framereg == AARCH64_SP_REGNUM);\n+    SELF_CHECK (cache.framesize == 64);\n+  }\n+\n+  /* Test handling of movz/str when using the stack pointer as frame\n+     pointer  */\n+  {\n+    static const uint32_t insns[] = {\n+      0xa9bc7bfd, /* stp     x29, x30, [sp, #-64]! */\n+      0x52800020, /* mov     w0, #0x1 */\n+      0xb9002be4, /* str     w4, [sp, #40] */\n+      0xf9001be5, /* str     x5, [sp, #48] */\n+      0x528000a2, /* mov     w2, #0x5 */\n+      0x97fffff8, /* bl      6e4 */\n+    };\n+\n+    instruction_reader_test reader (insns);\n+\n+    trad_frame_reset_saved_regs (gdbarch, cache.saved_regs);\n+    CORE_ADDR end = aarch64_analyze_prologue (gdbarch, 0, 128, &cache, reader);\n+\n+    /* We should stop at the 5th instruction.  */\n+    SELF_CHECK (end == (5 - 1) * 4);\n+    SELF_CHECK (cache.framereg == AARCH64_SP_REGNUM);\n+    SELF_CHECK (cache.framesize == 64);\n+  }\n+\n+  /* Test handling of movz/stur when using the stack pointer as frame\n+     pointer.  */\n+  {\n+    static const uint32_t insns[] = {\n+      0xa9bc7bfd, /* stp     x29, x30, [sp, #-64]! */\n+      0x52800020, /* mov     w0, #0x1 */\n+      0xb80343e6, /* stur    w6, [sp, #52] */\n+      0xf80383e7, /* stur    x7, [sp, #56] */\n+      0x528000a2, /* mov     w2, #0x5 */\n+      0x97fffff8, /* bl      6e4 */\n+    };\n+\n+    instruction_reader_test reader (insns);\n+\n+    trad_frame_reset_saved_regs (gdbarch, cache.saved_regs);\n+    CORE_ADDR end = aarch64_analyze_prologue (gdbarch, 0, 128, &cache, reader);\n+\n+    /* We should stop at the 5th instruction.  */\n+    SELF_CHECK (end == (5 - 1) * 4);\n+    SELF_CHECK (cache.framereg == AARCH64_SP_REGNUM);\n+    SELF_CHECK (cache.framesize == 64);\n+  }\n+\n+  /* Test handling of movz when there is no frame pointer set or no stack\n+     pointer used.  */\n+  {\n+    static const uint32_t insns[] = {\n+      0xa9bf7bfd, /* stp     x29, x30, [sp, #-16]! */\n+      0x52800020, /* mov     w0, #0x1 */\n+      0x528000a2, /* mov     w2, #0x5 */\n+      0x97fffff8, /* bl      6e4 */\n+    };\n+\n+    instruction_reader_test reader (insns);\n+\n+    trad_frame_reset_saved_regs (gdbarch, cache.saved_regs);\n+    CORE_ADDR end = aarch64_analyze_prologue (gdbarch, 0, 128, &cache, reader);\n+\n+    /* We should stop at the 4th instruction.  */\n+    SELF_CHECK (end == (4 - 1) * 4);\n+    SELF_CHECK (cache.framereg == AARCH64_SP_REGNUM);\n+    SELF_CHECK (cache.framesize == 16);\n+  }\n+\n   /* Test a prologue in which there is a return address signing instruction.  */\n   if (tdep->has_pauth ())\n     {"
    }
  ]
}