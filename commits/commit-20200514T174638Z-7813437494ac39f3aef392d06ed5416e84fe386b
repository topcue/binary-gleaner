{
  "sha": "7813437494ac39f3aef392d06ed5416e84fe386b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzgxMzQzNzQ5NGFjMzlmM2FlZjM5MmQwNmVkNTQxNmU4NGZlMzg2Yg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-14T17:46:38Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-14T17:46:38Z"
    },
    "message": "gdb: remove TYPE_CODE macro\n\nRemove TYPE_CODE, changing all the call sites to use type::code\ndirectly.  This is quite a big diff, but this was mostly done using sed\nand coccinelle.  A few call sites were done by hand.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (TYPE_CODE): Remove.  Change all call sites to use\n\ttype::code instead.",
    "tree": {
      "sha": "15290bf5b2bd9d23c59103a6a42b99adc0111d6d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/15290bf5b2bd9d23c59103a6a42b99adc0111d6d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7813437494ac39f3aef392d06ed5416e84fe386b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7813437494ac39f3aef392d06ed5416e84fe386b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7813437494ac39f3aef392d06ed5416e84fe386b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7813437494ac39f3aef392d06ed5416e84fe386b/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/67607e24d0413828acdfa9bc38f6fbac40b860b9"
    }
  ],
  "stats": {
    "total": 3490,
    "additions": 1744,
    "deletions": 1746
  },
  "files": [
    {
      "sha": "5533db5d5c742360a7a50ff41f226082e23c17c9",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1,3 +1,8 @@\n+2020-05-14  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (TYPE_CODE): Remove.  Change all call sites to use\n+\ttype::code instead.\n+\n 2020-05-14  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (struct type) <code, set_code>: New methods."
    },
    {
      "sha": "37d75a81f08a4d80c0e93d46f71edcf9943e5036",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1254,7 +1254,7 @@ static ULONGEST\n aarch64_type_align (gdbarch *gdbarch, struct type *t)\n {\n   t = check_typedef (t);\n-  if (TYPE_CODE (t) == TYPE_CODE_ARRAY && TYPE_VECTOR (t))\n+  if (t->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (t))\n     {\n       /* Use the natural alignment for vector types (the same for\n \t scalar type), but the maximum alignment is 128-bit.  */\n@@ -1283,7 +1283,7 @@ aapcs_is_vfp_call_or_return_candidate_1 (struct type *type,\n   if (type == nullptr)\n     return -1;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_FLT:\n       if (TYPE_LENGTH (type) > 16)\n@@ -1292,7 +1292,7 @@ aapcs_is_vfp_call_or_return_candidate_1 (struct type *type,\n       if (*fundamental_type == nullptr)\n \t*fundamental_type = type;\n       else if (TYPE_LENGTH (type) != TYPE_LENGTH (*fundamental_type)\n-\t       || TYPE_CODE (type) != TYPE_CODE (*fundamental_type))\n+\t       || type->code () != (*fundamental_type)->code ())\n \treturn -1;\n \n       return 1;\n@@ -1306,7 +1306,7 @@ aapcs_is_vfp_call_or_return_candidate_1 (struct type *type,\n \tif (*fundamental_type == nullptr)\n \t  *fundamental_type = target_type;\n \telse if (TYPE_LENGTH (target_type) != TYPE_LENGTH (*fundamental_type)\n-\t\t || TYPE_CODE (target_type) != TYPE_CODE (*fundamental_type))\n+\t\t || target_type->code () != (*fundamental_type)->code ())\n \t  return -1;\n \n \treturn 2;\n@@ -1322,7 +1322,7 @@ aapcs_is_vfp_call_or_return_candidate_1 (struct type *type,\n \t    if (*fundamental_type == nullptr)\n \t      *fundamental_type = type;\n \t    else if (TYPE_LENGTH (type) != TYPE_LENGTH (*fundamental_type)\n-\t\t     || TYPE_CODE (type) != TYPE_CODE (*fundamental_type))\n+\t\t     || type->code () != (*fundamental_type)->code ())\n \t      return -1;\n \n \t    return 1;\n@@ -1449,7 +1449,7 @@ pass_in_x (struct gdbarch *gdbarch, struct regcache *regcache,\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int len = TYPE_LENGTH (type);\n-  enum type_code typecode = TYPE_CODE (type);\n+  enum type_code typecode = type->code ();\n   int regnum = AARCH64_X0_REGNUM + info->ngrn;\n   const bfd_byte *buf = value_contents (arg);\n \n@@ -1600,7 +1600,7 @@ pass_in_v_vfp_candidate (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t struct aarch64_call_info *info, struct type *arg_type,\n \t\t\t struct value *arg)\n {\n-  switch (TYPE_CODE (arg_type))\n+  switch (arg_type->code ())\n     {\n     case TYPE_CODE_FLT:\n       return pass_in_v (gdbarch, regcache, info, TYPE_LENGTH (arg_type),\n@@ -1736,7 +1736,7 @@ aarch64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  continue;\n \t}\n \n-      switch (TYPE_CODE (arg_type))\n+      switch (arg_type->code ())\n \t{\n \tcase TYPE_CODE_INT:\n \tcase TYPE_CODE_BOOL:\n@@ -2120,12 +2120,12 @@ aarch64_extract_return_value (struct type *type, struct regcache *regs,\n \t  valbuf += len;\n \t}\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_INT\n-\t   || TYPE_CODE (type) == TYPE_CODE_CHAR\n-\t   || TYPE_CODE (type) == TYPE_CODE_BOOL\n-\t   || TYPE_CODE (type) == TYPE_CODE_PTR\n+  else if (type->code () == TYPE_CODE_INT\n+\t   || type->code () == TYPE_CODE_CHAR\n+\t   || type->code () == TYPE_CODE_BOOL\n+\t   || type->code () == TYPE_CODE_PTR\n \t   || TYPE_IS_REFERENCE (type)\n-\t   || TYPE_CODE (type) == TYPE_CODE_ENUM)\n+\t   || type->code () == TYPE_CODE_ENUM)\n     {\n       /* If the type is a plain integer, then the access is\n \t straight-forward.  Otherwise we have to play around a bit\n@@ -2233,12 +2233,12 @@ aarch64_store_return_value (struct type *type, struct regcache *regs,\n \t  valbuf += len;\n \t}\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_INT\n-\t   || TYPE_CODE (type) == TYPE_CODE_CHAR\n-\t   || TYPE_CODE (type) == TYPE_CODE_BOOL\n-\t   || TYPE_CODE (type) == TYPE_CODE_PTR\n+  else if (type->code () == TYPE_CODE_INT\n+\t   || type->code () == TYPE_CODE_CHAR\n+\t   || type->code () == TYPE_CODE_BOOL\n+\t   || type->code () == TYPE_CODE_PTR\n \t   || TYPE_IS_REFERENCE (type)\n-\t   || TYPE_CODE (type) == TYPE_CODE_ENUM)\n+\t   || type->code () == TYPE_CODE_ENUM)\n     {\n       if (TYPE_LENGTH (type) <= X_REGISTER_SIZE)\n \t{\n@@ -2294,9 +2294,9 @@ aarch64_return_value (struct gdbarch *gdbarch, struct value *func_value,\n \t\t      gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n \n-  if (TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (valtype) == TYPE_CODE_UNION\n-      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY)\n+  if (valtype->code () == TYPE_CODE_STRUCT\n+      || valtype->code () == TYPE_CODE_UNION\n+      || valtype->code () == TYPE_CODE_ARRAY)\n     {\n       if (aarch64_return_in_memory (gdbarch, valtype))\n \t{"
    },
    {
      "sha": "15b28ac807d855d71999521cf7065297463da829",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1386,7 +1386,7 @@ convert_char_literal (struct type *type, LONGEST val)\n   if (type == NULL)\n     return val;\n   type = check_typedef (type);\n-  if (TYPE_CODE (type) != TYPE_CODE_ENUM)\n+  if (type->code () != TYPE_CODE_ENUM)\n     return val;\n \n   if ((val >= 'a' && val <= 'z') || (val >= '0' && val <= '9'))"
    },
    {
      "sha": "02e3404430175496227f6aaff65d34602b5cfece",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 191,
      "deletions": 193,
      "changes": 384,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -451,7 +451,7 @@ get_ada_pspace_data (struct program_space *pspace)\n static struct type *\n ada_typedef_target_type (struct type *type)\n {\n-  while (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+  while (type->code () == TYPE_CODE_TYPEDEF)\n     type = TYPE_TARGET_TYPE (type);\n   return type;\n }\n@@ -750,7 +750,7 @@ LONGEST\n ada_discrete_type_high_bound (struct type *type)\n {\n   type = resolve_dynamic_type (type, {}, 0);\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_RANGE:\n       return TYPE_HIGH_BOUND (type);\n@@ -771,7 +771,7 @@ LONGEST\n ada_discrete_type_low_bound (struct type *type)\n {\n   type = resolve_dynamic_type (type, {}, 0);\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_RANGE:\n       return TYPE_LOW_BOUND (type);\n@@ -793,7 +793,7 @@ ada_discrete_type_low_bound (struct type *type)\n static struct type *\n get_base_type (struct type *type)\n {\n-  while (type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE)\n+  while (type != NULL && type->code () == TYPE_CODE_RANGE)\n     {\n       if (type == TYPE_TARGET_TYPE (type) || TYPE_TARGET_TYPE (type) == NULL)\n         return type;\n@@ -814,9 +814,9 @@ ada_get_decoded_value (struct value *value)\n \n   if (ada_is_array_descriptor_type (type)\n       || (ada_is_constrained_packed_array_type (type)\n-          && TYPE_CODE (type) != TYPE_CODE_PTR))\n+          && type->code () != TYPE_CODE_PTR))\n     {\n-      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)  /* array access type.  */\n+      if (type->code () == TYPE_CODE_TYPEDEF)  /* array access type.  */\n         value = ada_coerce_to_simple_array_ptr (value);\n       else\n         value = ada_coerce_to_simple_array (value);\n@@ -1510,12 +1510,12 @@ desc_base_type (struct type *type)\n   if (type == NULL)\n     return NULL;\n   type = ada_check_typedef (type);\n-  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+  if (type->code () == TYPE_CODE_TYPEDEF)\n     type = ada_typedef_target_type (type);\n \n   if (type != NULL\n-      && (TYPE_CODE (type) == TYPE_CODE_PTR\n-          || TYPE_CODE (type) == TYPE_CODE_REF))\n+      && (type->code () == TYPE_CODE_PTR\n+          || type->code () == TYPE_CODE_REF))\n     return ada_check_typedef (TYPE_TARGET_TYPE (type));\n   else\n     return type;\n@@ -1563,7 +1563,7 @@ thin_data_pntr (struct value *val)\n \n   data_type = lookup_pointer_type (data_type);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     return value_cast (data_type, value_copy (val));\n   else\n     return value_from_longest (data_type, value_address (val));\n@@ -1575,7 +1575,7 @@ static int\n is_thick_pntr (struct type *type)\n {\n   type = desc_base_type (type);\n-  return (type != NULL && TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  return (type != NULL && type->code () == TYPE_CODE_STRUCT\n           && lookup_struct_elt_type (type, \"P_BOUNDS\", 1) != NULL);\n }\n \n@@ -1600,7 +1600,7 @@ desc_bounds_type (struct type *type)\n       if (r != NULL)\n         return ada_check_typedef (r);\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  else if (type->code () == TYPE_CODE_STRUCT)\n     {\n       r = lookup_struct_elt_type (type, \"P_BOUNDS\", 1);\n       if (r != NULL)\n@@ -1629,7 +1629,7 @@ desc_bounds (struct value *arr)\n       /* NOTE: The following calculation is not really kosher, but\n          since desc_type is an XVE-encoded type (and shouldn't be),\n          the correct calculation is a real pain.  FIXME (and fix GCC).  */\n-      if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+      if (type->code () == TYPE_CODE_PTR)\n         addr = value_as_long (arr);\n       else\n         addr = value_address (arr);\n@@ -1646,7 +1646,7 @@ desc_bounds (struct value *arr)\n       struct type *p_bounds_type = value_type (p_bounds);\n \n       if (p_bounds_type\n-\t  && TYPE_CODE (p_bounds_type) == TYPE_CODE_PTR)\n+\t  && p_bounds_type->code () == TYPE_CODE_PTR)\n \t{\n \t  struct type *target_type = TYPE_TARGET_TYPE (p_bounds_type);\n \n@@ -1705,7 +1705,7 @@ desc_data_target_type (struct type *type)\n       struct type *data_type = lookup_struct_elt_type (type, \"P_ARRAY\", 1);\n \n       if (data_type\n-\t  && TYPE_CODE (ada_check_typedef (data_type)) == TYPE_CODE_PTR)\n+\t  && ada_check_typedef (data_type)->code () == TYPE_CODE_PTR)\n \treturn ada_check_typedef (TYPE_TARGET_TYPE (data_type));\n     }\n \n@@ -1797,7 +1797,7 @@ desc_index_type (struct type *type, int i)\n {\n   type = desc_base_type (type);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     return lookup_struct_elt_type (type, bound_name[2 * i - 2], 1);\n   else\n     return NULL;\n@@ -1826,7 +1826,7 @@ ada_is_direct_array_type (struct type *type)\n   if (type == NULL)\n     return 0;\n   type = ada_check_typedef (type);\n-  return (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+  return (type->code () == TYPE_CODE_ARRAY\n           || ada_is_array_descriptor_type (type));\n }\n \n@@ -1836,9 +1836,9 @@ ada_is_direct_array_type (struct type *type)\n static int\n ada_is_array_type (struct type *type)\n {\n-  while (type != NULL \n-\t && (TYPE_CODE (type) == TYPE_CODE_PTR \n-\t     || TYPE_CODE (type) == TYPE_CODE_REF))\n+  while (type != NULL\n+\t && (type->code () == TYPE_CODE_PTR\n+\t     || type->code () == TYPE_CODE_REF))\n     type = TYPE_TARGET_TYPE (type);\n   return ada_is_direct_array_type (type);\n }\n@@ -1851,10 +1851,10 @@ ada_is_simple_array_type (struct type *type)\n   if (type == NULL)\n     return 0;\n   type = ada_check_typedef (type);\n-  return (TYPE_CODE (type) == TYPE_CODE_ARRAY\n-          || (TYPE_CODE (type) == TYPE_CODE_PTR\n-              && TYPE_CODE (ada_check_typedef (TYPE_TARGET_TYPE (type)))\n-                 == TYPE_CODE_ARRAY));\n+  return (type->code () == TYPE_CODE_ARRAY\n+\t  || (type->code () == TYPE_CODE_PTR\n+\t      && (ada_check_typedef (TYPE_TARGET_TYPE (type))->code ()\n+\t\t  == TYPE_CODE_ARRAY)));\n }\n \n /* Non-zero iff TYPE belongs to a GNAT array descriptor.  */\n@@ -1868,7 +1868,7 @@ ada_is_array_descriptor_type (struct type *type)\n     return 0;\n   type = ada_check_typedef (type);\n   return (data_type != NULL\n-\t  && TYPE_CODE (data_type) == TYPE_CODE_ARRAY\n+\t  && data_type->code () == TYPE_CODE_ARRAY\n \t  && desc_arity (desc_bounds_type (type)) > 0);\n }\n \n@@ -1882,7 +1882,7 @@ ada_is_bogus_array_descriptor (struct type *type)\n {\n   return\n     type != NULL\n-    && TYPE_CODE (type) == TYPE_CODE_STRUCT\n+    && type->code () == TYPE_CODE_STRUCT\n     && (lookup_struct_elt_type (type, \"P_BOUNDS\", 1) != NULL\n         || lookup_struct_elt_type (type, \"P_ARRAY\", 1) != NULL)\n     && !ada_is_array_descriptor_type (type);\n@@ -2078,7 +2078,7 @@ decode_packed_array_bitsize (struct type *type)\n   /* Access to arrays implemented as fat pointers are encoded as a typedef\n      of the fat pointer type.  We need the name of the fat pointer type\n      to do the decoding, so strip the typedef layer.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+  if (type->code () == TYPE_CODE_TYPEDEF)\n     type = ada_typedef_target_type (type);\n \n   raw_name = ada_type_name (ada_check_typedef (type));\n@@ -2128,7 +2128,7 @@ constrained_packed_array_type (struct type *type, long *elt_bits)\n   LONGEST low_bound, high_bound;\n \n   type = ada_check_typedef (type);\n-  if (TYPE_CODE (type) != TYPE_CODE_ARRAY)\n+  if (type->code () != TYPE_CODE_ARRAY)\n     return type;\n \n   index_type_desc = ada_find_parallel_type (type, \"___XA\");\n@@ -2146,7 +2146,7 @@ constrained_packed_array_type (struct type *type, long *elt_bits)\n   TYPE_FIELD_BITSIZE (new_type, 0) = *elt_bits;\n   TYPE_NAME (new_type) = ada_type_name (type);\n \n-  if ((TYPE_CODE (check_typedef (index_type)) == TYPE_CODE_RANGE\n+  if ((check_typedef (index_type)->code () == TYPE_CODE_RANGE\n        && is_dynamic_type (check_typedef (index_type)))\n       || get_discrete_bounds (index_type, &low_bound, &high_bound) < 0)\n     low_bound = high_bound = 0;\n@@ -2197,7 +2197,7 @@ decode_constrained_packed_array_type (struct type *type)\n     }\n   shadow_type = check_typedef (shadow_type);\n \n-  if (TYPE_CODE (shadow_type) != TYPE_CODE_ARRAY)\n+  if (shadow_type->code () != TYPE_CODE_ARRAY)\n     {\n       lim_warning (_(\"could not understand bounds \"\n \t\t     \"information on packed array\"));\n@@ -2227,7 +2227,7 @@ decode_constrained_packed_array (struct value *arr)\n      and \"value_ind\" routines to perform the dereferencing, as opposed\n      to using \"ada_coerce_ref\" or \"ada_value_ind\".  */\n   arr = coerce_ref (arr);\n-  if (TYPE_CODE (ada_check_typedef (value_type (arr))) == TYPE_CODE_PTR)\n+  if (ada_check_typedef (value_type (arr))->code () == TYPE_CODE_PTR)\n     arr = value_ind (arr);\n \n   type = decode_constrained_packed_array_type (value_type (arr));\n@@ -2283,7 +2283,7 @@ value_subscript_packed (struct value *arr, int arity, struct value **ind)\n   elt_type = ada_check_typedef (value_type (arr));\n   for (i = 0; i < arity; i += 1)\n     {\n-      if (TYPE_CODE (elt_type) != TYPE_CODE_ARRAY\n+      if (elt_type->code () != TYPE_CODE_ARRAY\n           || TYPE_FIELD_BITSIZE (elt_type, 0) == 0)\n         error\n           (_(\"attempt to do packed indexing of \"\n@@ -2322,7 +2322,7 @@ value_subscript_packed (struct value *arr, int arity, struct value **ind)\n static int\n has_negatives (struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     default:\n       return 0;\n@@ -2607,8 +2607,8 @@ ada_value_assign (struct value *toval, struct value *fromval)\n \n   if (VALUE_LVAL (toval) == lval_memory\n       && bits > 0\n-      && (TYPE_CODE (type) == TYPE_CODE_FLT\n-          || TYPE_CODE (type) == TYPE_CODE_STRUCT))\n+      && (type->code () == TYPE_CODE_FLT\n+          || type->code () == TYPE_CODE_STRUCT))\n     {\n       int len = (value_bitpos (toval)\n \t\t + bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;\n@@ -2617,7 +2617,7 @@ ada_value_assign (struct value *toval, struct value *fromval)\n       struct value *val;\n       CORE_ADDR to_addr = value_address (toval);\n \n-      if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+      if (type->code () == TYPE_CODE_FLT)\n         fromval = value_cast (type, fromval);\n \n       read_memory (to_addr, buffer, len);\n@@ -2698,7 +2698,7 @@ value_assign_to_component (struct value *container, struct value *component,\n bool\n ada_is_access_to_unconstrained_array (struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_TYPEDEF\n+  return (type->code () == TYPE_CODE_TYPEDEF\n \t  && is_thick_pntr (ada_typedef_target_type (type)));\n }\n \n@@ -2716,21 +2716,21 @@ ada_value_subscript (struct value *arr, int arity, struct value **ind)\n   elt = ada_coerce_to_simple_array (arr);\n \n   elt_type = ada_check_typedef (value_type (elt));\n-  if (TYPE_CODE (elt_type) == TYPE_CODE_ARRAY\n+  if (elt_type->code () == TYPE_CODE_ARRAY\n       && TYPE_FIELD_BITSIZE (elt_type, 0) > 0)\n     return value_subscript_packed (elt, arity, ind);\n \n   for (k = 0; k < arity; k += 1)\n     {\n       struct type *saved_elt_type = TYPE_TARGET_TYPE (elt_type);\n \n-      if (TYPE_CODE (elt_type) != TYPE_CODE_ARRAY)\n+      if (elt_type->code () != TYPE_CODE_ARRAY)\n         error (_(\"too many subscripts (%d expected)\"), k);\n \n       elt = value_subscript (elt, pos_atr (ind[k]));\n \n       if (ada_is_access_to_unconstrained_array (saved_elt_type)\n-\t  && TYPE_CODE (value_type (elt)) != TYPE_CODE_TYPEDEF)\n+\t  && value_type (elt)->code () != TYPE_CODE_TYPEDEF)\n \t{\n \t  /* The element is a typedef to an unconstrained array,\n \t     except that the value_subscript call stripped the\n@@ -2773,7 +2773,7 @@ ada_value_ptr_subscript (struct value *arr, int arity, struct value **ind)\n   struct type *type\n     = check_typedef (value_enclosing_type (array_ind));\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+  if (type->code () == TYPE_CODE_ARRAY\n       && TYPE_FIELD_BITSIZE (type, 0) > 0)\n     return value_subscript_packed (array_ind, arity, ind);\n \n@@ -2782,12 +2782,12 @@ ada_value_ptr_subscript (struct value *arr, int arity, struct value **ind)\n       LONGEST lwb, upb;\n       struct value *lwb_value;\n \n-      if (TYPE_CODE (type) != TYPE_CODE_ARRAY)\n+      if (type->code () != TYPE_CODE_ARRAY)\n         error (_(\"too many subscripts (%d expected)\"), k);\n       arr = value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (type)),\n                         value_copy (arr));\n       get_discrete_bounds (TYPE_INDEX_TYPE (type), &lwb, &upb);\n-      lwb_value = value_from_longest (value_type(ind[k]), lwb);\n+      lwb_value = value_from_longest (value_type (ind[k]), lwb);\n       arr = value_ptradd (arr, pos_atr (ind[k]) - pos_atr (lwb_value));\n       type = TYPE_TARGET_TYPE (type);\n     }\n@@ -2871,10 +2871,10 @@ ada_array_arity (struct type *type)\n   type = desc_base_type (type);\n \n   arity = 0;\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     return desc_arity (desc_bounds_type (type));\n   else\n-    while (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+    while (type->code () == TYPE_CODE_ARRAY)\n       {\n         arity += 1;\n         type = ada_check_typedef (TYPE_TARGET_TYPE (type));\n@@ -2893,7 +2893,7 @@ ada_array_element_type (struct type *type, int nindices)\n {\n   type = desc_base_type (type);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     {\n       int k;\n       struct type *p_array_type;\n@@ -2914,9 +2914,9 @@ ada_array_element_type (struct type *type, int nindices)\n         }\n       return p_array_type;\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  else if (type->code () == TYPE_CODE_ARRAY)\n     {\n-      while (nindices != 0 && TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+      while (nindices != 0 && type->code () == TYPE_CODE_ARRAY)\n         {\n           type = TYPE_TARGET_TYPE (type);\n           nindices -= 1;\n@@ -2953,7 +2953,7 @@ ada_index_type (struct type *type, int n, const char *name)\n       /* FIXME: The stabs type r(0,0);bound;bound in an array type\n          has a target type of TYPE_CODE_UNDEF.  We compensate here, but\n          perhaps stabsread.c would make more sense.  */\n-      if (result_type && TYPE_CODE (result_type) == TYPE_CODE_UNDEF)\n+      if (result_type && result_type->code () == TYPE_CODE_UNDEF)\n         result_type = NULL;\n     }\n   else\n@@ -2986,7 +2986,7 @@ ada_array_bound_from_type (struct type *arr_type, int n, int which)\n   if (arr_type == NULL || !ada_is_simple_array_type (arr_type))\n     return (LONGEST) - which;\n \n-  if (TYPE_CODE (arr_type) == TYPE_CODE_PTR)\n+  if (arr_type->code () == TYPE_CODE_PTR)\n     type = TYPE_TARGET_TYPE (arr_type);\n   else\n     type = arr_type;\n@@ -3033,7 +3033,7 @@ ada_array_bound (struct value *arr, int n, int which)\n {\n   struct type *arr_type;\n \n-  if (TYPE_CODE (check_typedef (value_type (arr))) == TYPE_CODE_PTR)\n+  if (check_typedef (value_type (arr))->code () == TYPE_CODE_PTR)\n     arr = value_ind (arr);\n   arr_type = value_enclosing_type (arr);\n \n@@ -3057,7 +3057,7 @@ ada_array_length (struct value *arr, int n)\n   struct type *arr_type, *index_type;\n   int low, high;\n \n-  if (TYPE_CODE (check_typedef (value_type (arr))) == TYPE_CODE_PTR)\n+  if (check_typedef (value_type (arr))->code () == TYPE_CODE_PTR)\n     arr = value_ind (arr);\n   arr_type = value_enclosing_type (arr);\n \n@@ -3080,7 +3080,7 @@ ada_array_length (struct value *arr, int n)\n   if (index_type != NULL)\n     {\n       struct type *base_type;\n-      if (TYPE_CODE (index_type) == TYPE_CODE_RANGE)\n+      if (index_type->code () == TYPE_CODE_RANGE)\n \tbase_type = TYPE_TARGET_TYPE (index_type);\n       else\n \tbase_type = index_type;\n@@ -3208,7 +3208,7 @@ ada_print_symbol_signature (struct ui_file *stream, struct symbol *sym,\n   fprintf_filtered (stream, \"%s\", sym->print_name ());\n   if (!print_signatures\n       || type == NULL\n-      || TYPE_CODE (type) != TYPE_CODE_FUNC)\n+      || type->code () != TYPE_CODE_FUNC)\n     return;\n \n   if (TYPE_NFIELDS (type) > 0)\n@@ -3226,7 +3226,7 @@ ada_print_symbol_signature (struct ui_file *stream, struct symbol *sym,\n       fprintf_filtered (stream, \")\");\n     }\n   if (TYPE_TARGET_TYPE (type) != NULL\n-      && TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n+      && TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n     {\n       fprintf_filtered (stream, \" return \");\n       ada_print_type (TYPE_TARGET_TYPE (type), NULL, stream, -1, 0, flags);\n@@ -3389,7 +3389,7 @@ See set/show multiple-symbol.\"));\n           int is_enumeral =\n             (SYMBOL_CLASS (syms[i].symbol) == LOC_CONST\n              && SYMBOL_TYPE (syms[i].symbol) != NULL\n-             && TYPE_CODE (SYMBOL_TYPE (syms[i].symbol)) == TYPE_CODE_ENUM);\n+             && SYMBOL_TYPE (syms[i].symbol)->code () == TYPE_CODE_ENUM);\n \t  struct symtab *symtab = NULL;\n \n \t  if (SYMBOL_OBJFILE_OWNED (syms[i].symbol))\n@@ -3725,7 +3725,7 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n         }\n \n       if (deprocedure_p\n-          && (TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol))\n+          && (SYMBOL_TYPE (exp->elts[pc + 2].symbol)->code ()\n               == TYPE_CODE_FUNC))\n         {\n           replace_operator_with_call (expp, pc, 0, 4,\n@@ -3838,17 +3838,17 @@ ada_type_match (struct type *ftype, struct type *atype, int may_deref)\n   ftype = ada_check_typedef (ftype);\n   atype = ada_check_typedef (atype);\n \n-  if (TYPE_CODE (ftype) == TYPE_CODE_REF)\n+  if (ftype->code () == TYPE_CODE_REF)\n     ftype = TYPE_TARGET_TYPE (ftype);\n-  if (TYPE_CODE (atype) == TYPE_CODE_REF)\n+  if (atype->code () == TYPE_CODE_REF)\n     atype = TYPE_TARGET_TYPE (atype);\n \n-  switch (TYPE_CODE (ftype))\n+  switch (ftype->code ())\n     {\n     default:\n-      return TYPE_CODE (ftype) == TYPE_CODE (atype);\n+      return ftype->code () == atype->code ();\n     case TYPE_CODE_PTR:\n-      if (TYPE_CODE (atype) == TYPE_CODE_PTR)\n+      if (atype->code () == TYPE_CODE_PTR)\n         return ada_type_match (TYPE_TARGET_TYPE (ftype),\n                                TYPE_TARGET_TYPE (atype), 0);\n       else\n@@ -3857,7 +3857,7 @@ ada_type_match (struct type *ftype, struct type *atype, int may_deref)\n     case TYPE_CODE_INT:\n     case TYPE_CODE_ENUM:\n     case TYPE_CODE_RANGE:\n-      switch (TYPE_CODE (atype))\n+      switch (atype->code ())\n         {\n         case TYPE_CODE_INT:\n         case TYPE_CODE_ENUM:\n@@ -3868,20 +3868,20 @@ ada_type_match (struct type *ftype, struct type *atype, int may_deref)\n         }\n \n     case TYPE_CODE_ARRAY:\n-      return (TYPE_CODE (atype) == TYPE_CODE_ARRAY\n+      return (atype->code () == TYPE_CODE_ARRAY\n               || ada_is_array_descriptor_type (atype));\n \n     case TYPE_CODE_STRUCT:\n       if (ada_is_array_descriptor_type (ftype))\n-        return (TYPE_CODE (atype) == TYPE_CODE_ARRAY\n+        return (atype->code () == TYPE_CODE_ARRAY\n                 || ada_is_array_descriptor_type (atype));\n       else\n-        return (TYPE_CODE (atype) == TYPE_CODE_STRUCT\n+        return (atype->code () == TYPE_CODE_STRUCT\n                 && !ada_is_array_descriptor_type (atype));\n \n     case TYPE_CODE_UNION:\n     case TYPE_CODE_FLT:\n-      return (TYPE_CODE (atype) == TYPE_CODE (ftype));\n+      return (atype->code () == ftype->code ());\n     }\n }\n \n@@ -3897,9 +3897,9 @@ ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)\n   struct type *func_type = SYMBOL_TYPE (func);\n \n   if (SYMBOL_CLASS (func) == LOC_CONST\n-      && TYPE_CODE (func_type) == TYPE_CODE_ENUM)\n+      && func_type->code () == TYPE_CODE_ENUM)\n     return (n_actuals == 0);\n-  else if (func_type == NULL || TYPE_CODE (func_type) != TYPE_CODE_FUNC)\n+  else if (func_type == NULL || func_type->code () != TYPE_CODE_FUNC)\n     return 0;\n \n   if (TYPE_NFIELDS (func_type) != n_actuals)\n@@ -3935,7 +3935,7 @@ return_match (struct type *func_type, struct type *context_type)\n   if (func_type == NULL)\n     return 1;\n \n-  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)\n+  if (func_type->code () == TYPE_CODE_FUNC)\n     return_type = get_base_type (TYPE_TARGET_TYPE (func_type));\n   else\n     return_type = get_base_type (func_type);\n@@ -3944,12 +3944,12 @@ return_match (struct type *func_type, struct type *context_type)\n \n   context_type = get_base_type (context_type);\n \n-  if (TYPE_CODE (return_type) == TYPE_CODE_ENUM)\n+  if (return_type->code () == TYPE_CODE_ENUM)\n     return context_type == NULL || return_type == context_type;\n   else if (context_type == NULL)\n-    return TYPE_CODE (return_type) != TYPE_CODE_VOID;\n+    return return_type->code () != TYPE_CODE_VOID;\n   else\n-    return TYPE_CODE (return_type) == TYPE_CODE (context_type);\n+    return return_type->code () == context_type->code ();\n }\n \n \n@@ -4054,7 +4054,7 @@ numeric_type_p (struct type *type)\n     return 0;\n   else\n     {\n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n         {\n         case TYPE_CODE_INT:\n         case TYPE_CODE_FLT:\n@@ -4077,7 +4077,7 @@ integer_type_p (struct type *type)\n     return 0;\n   else\n     {\n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n         {\n         case TYPE_CODE_INT:\n           return 1;\n@@ -4099,7 +4099,7 @@ scalar_type_p (struct type *type)\n     return 0;\n   else\n     {\n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n         {\n         case TYPE_CODE_INT:\n         case TYPE_CODE_RANGE:\n@@ -4121,7 +4121,7 @@ discrete_type_p (struct type *type)\n     return 0;\n   else\n     {\n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n         {\n         case TYPE_CODE_INT:\n         case TYPE_CODE_RANGE:\n@@ -4342,26 +4342,26 @@ ada_value_struct_elt (struct value *arg, const char *name, int no_err)\n \n   v = NULL;\n   t1 = t = ada_check_typedef (value_type (arg));\n-  if (TYPE_CODE (t) == TYPE_CODE_REF)\n+  if (t->code () == TYPE_CODE_REF)\n     {\n       t1 = TYPE_TARGET_TYPE (t);\n       if (t1 == NULL)\n \tgoto BadValue;\n       t1 = ada_check_typedef (t1);\n-      if (TYPE_CODE (t1) == TYPE_CODE_PTR)\n+      if (t1->code () == TYPE_CODE_PTR)\n         {\n           arg = coerce_ref (arg);\n           t = t1;\n         }\n     }\n \n-  while (TYPE_CODE (t) == TYPE_CODE_PTR)\n+  while (t->code () == TYPE_CODE_PTR)\n     {\n       t1 = TYPE_TARGET_TYPE (t);\n       if (t1 == NULL)\n \tgoto BadValue;\n       t1 = ada_check_typedef (t1);\n-      if (TYPE_CODE (t1) == TYPE_CODE_PTR)\n+      if (t1->code () == TYPE_CODE_PTR)\n         {\n           arg = value_ind (arg);\n           t = t1;\n@@ -4370,7 +4370,7 @@ ada_value_struct_elt (struct value *arg, const char *name, int no_err)\n         break;\n     }\n \n-  if (TYPE_CODE (t1) != TYPE_CODE_STRUCT && TYPE_CODE (t1) != TYPE_CODE_UNION)\n+  if (t1->code () != TYPE_CODE_STRUCT && t1->code () != TYPE_CODE_UNION)\n     goto BadValue;\n \n   if (t1 == t)\n@@ -4381,7 +4381,7 @@ ada_value_struct_elt (struct value *arg, const char *name, int no_err)\n       struct type *field_type;\n       CORE_ADDR address;\n \n-      if (TYPE_CODE (t) == TYPE_CODE_PTR)\n+      if (t->code () == TYPE_CODE_PTR)\n \taddress = value_address (ada_value_ind (arg));\n       else\n \taddress = value_address (ada_coerce_ref (arg));\n@@ -4393,7 +4393,7 @@ ada_value_struct_elt (struct value *arg, const char *name, int no_err)\n          a reference should mostly be transparent to the user.  */\n \n       if (ada_is_tagged_type (t1, 0)\n-          || (TYPE_CODE (t1) == TYPE_CODE_REF\n+          || (t1->code () == TYPE_CODE_REF\n               && ada_is_tagged_type (TYPE_TARGET_TYPE (t1), 0)))\n         {\n           /* We first try to find the searched field in the current type.\n@@ -4420,7 +4420,7 @@ ada_value_struct_elt (struct value *arg, const char *name, int no_err)\n         {\n           if (bit_size != 0)\n             {\n-              if (TYPE_CODE (t) == TYPE_CODE_REF)\n+              if (t->code () == TYPE_CODE_REF)\n                 arg = ada_coerce_ref (arg);\n               else\n                 arg = ada_value_ind (arg);\n@@ -4457,24 +4457,24 @@ ada_convert_actual (struct value *actual, struct type *formal_type0)\n   struct type *actual_type = ada_check_typedef (value_type (actual));\n   struct type *formal_type = ada_check_typedef (formal_type0);\n   struct type *formal_target =\n-    TYPE_CODE (formal_type) == TYPE_CODE_PTR\n+    formal_type->code () == TYPE_CODE_PTR\n     ? ada_check_typedef (TYPE_TARGET_TYPE (formal_type)) : formal_type;\n   struct type *actual_target =\n-    TYPE_CODE (actual_type) == TYPE_CODE_PTR\n+    actual_type->code () == TYPE_CODE_PTR\n     ? ada_check_typedef (TYPE_TARGET_TYPE (actual_type)) : actual_type;\n \n   if (ada_is_array_descriptor_type (formal_target)\n-      && TYPE_CODE (actual_target) == TYPE_CODE_ARRAY)\n+      && actual_target->code () == TYPE_CODE_ARRAY)\n     return make_array_descriptor (formal_type, actual);\n-  else if (TYPE_CODE (formal_type) == TYPE_CODE_PTR\n-\t   || TYPE_CODE (formal_type) == TYPE_CODE_REF)\n+  else if (formal_type->code () == TYPE_CODE_PTR\n+\t   || formal_type->code () == TYPE_CODE_REF)\n     {\n       struct value *result;\n \n-      if (TYPE_CODE (formal_target) == TYPE_CODE_ARRAY\n+      if (formal_target->code () == TYPE_CODE_ARRAY\n           && ada_is_array_descriptor_type (actual_target))\n \tresult = desc_data (actual);\n-      else if (TYPE_CODE (formal_type) != TYPE_CODE_PTR)\n+      else if (formal_type->code () != TYPE_CODE_PTR)\n         {\n           if (VALUE_LVAL (actual) != lval_memory)\n             {\n@@ -4493,7 +4493,7 @@ ada_convert_actual (struct value *actual, struct type *formal_type0)\n \treturn actual;\n       return value_cast_pointers (formal_type, result, 0);\n     }\n-  else if (TYPE_CODE (actual_type) == TYPE_CODE_PTR)\n+  else if (actual_type->code () == TYPE_CODE_PTR)\n     return ada_value_ind (actual);\n   else if (ada_is_aligner_type (formal_type))\n     {\n@@ -4575,7 +4575,7 @@ make_array_descriptor (struct type *type, struct value *arr)\n \n   descriptor = ensure_lval (descriptor);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     return value_addr (descriptor);\n   else\n     return descriptor;\n@@ -4761,8 +4761,8 @@ is_nonfunction (struct block_symbol syms[], int n)\n   int i;\n \n   for (i = 0; i < n; i += 1)\n-    if (TYPE_CODE (SYMBOL_TYPE (syms[i].symbol)) != TYPE_CODE_FUNC\n-        && (TYPE_CODE (SYMBOL_TYPE (syms[i].symbol)) != TYPE_CODE_ENUM\n+    if (SYMBOL_TYPE (syms[i].symbol)->code () != TYPE_CODE_FUNC\n+        && (SYMBOL_TYPE (syms[i].symbol)->code () != TYPE_CODE_ENUM\n             || SYMBOL_CLASS (syms[i].symbol) != LOC_CONST))\n       return 1;\n \n@@ -4778,10 +4778,10 @@ equiv_types (struct type *type0, struct type *type1)\n   if (type0 == type1)\n     return 1;\n   if (type0 == NULL || type1 == NULL\n-      || TYPE_CODE (type0) != TYPE_CODE (type1))\n+      || type0->code () != type1->code ())\n     return 0;\n-  if ((TYPE_CODE (type0) == TYPE_CODE_STRUCT\n-       || TYPE_CODE (type0) == TYPE_CODE_ENUM)\n+  if ((type0->code () == TYPE_CODE_STRUCT\n+       || type0->code () == TYPE_CODE_ENUM)\n       && ada_type_name (type0) != NULL && ada_type_name (type1) != NULL\n       && strcmp (ada_type_name (type0), ada_type_name (type1)) == 0)\n     return 1;\n@@ -4814,7 +4814,7 @@ lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)\n         int len0 = strlen (name0);\n \n         return\n-          TYPE_CODE (type0) == TYPE_CODE (type1)\n+          type0->code () == type1->code ()\n           && (equiv_types (type0, type1)\n               || (len0 < strlen (name1) && strncmp (name0, name1, len0) == 0\n                   && startswith (name1 + len0, \"___XV\")));\n@@ -5035,7 +5035,7 @@ symbols_are_identical_enums (const std::vector<struct block_symbol> &syms)\n \n   /* Quick check: All symbols should have an enum type.  */\n   for (i = 0; i < syms.size (); i++)\n-    if (TYPE_CODE (SYMBOL_TYPE (syms[i].symbol)) != TYPE_CODE_ENUM)\n+    if (SYMBOL_TYPE (syms[i].symbol)->code () != TYPE_CODE_ENUM)\n       return 0;\n \n   /* Quick check: They should all have the same value.  */\n@@ -6503,7 +6503,7 @@ ada_is_dispatch_table_ptr_type (struct type *type)\n {\n   const char *name;\n \n-  if (TYPE_CODE (type) != TYPE_CODE_PTR)\n+  if (type->code () != TYPE_CODE_PTR)\n     return 0;\n \n   name = TYPE_NAME (TYPE_TARGET_TYPE (type));\n@@ -6583,7 +6583,7 @@ ada_is_tag_type (struct type *type)\n {\n   type = ada_check_typedef (type);\n \n-  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_PTR)\n+  if (type == NULL || type->code () != TYPE_CODE_PTR)\n     return 0;\n   else\n     {\n@@ -6673,8 +6673,7 @@ ada_tag_value_at_base_address (struct value *obj)\n \n   /* It is the responsability of the caller to deref pointers.  */\n \n-  if (TYPE_CODE (obj_type) == TYPE_CODE_PTR\n-      || TYPE_CODE (obj_type) == TYPE_CODE_REF)\n+  if (obj_type->code () == TYPE_CODE_PTR || obj_type->code () == TYPE_CODE_REF)\n     return obj;\n \n   tag = ada_value_tag (obj);\n@@ -6866,7 +6865,7 @@ ada_parent_type (struct type *type)\n \n   type = ada_check_typedef (type);\n \n-  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)\n+  if (type == NULL || type->code () != TYPE_CODE_STRUCT)\n     return NULL;\n \n   for (i = 0; i < TYPE_NFIELDS (type); i += 1)\n@@ -6875,7 +6874,7 @@ ada_parent_type (struct type *type)\n         struct type *parent_type = TYPE_FIELD_TYPE (type, i);\n \n         /* If the _parent field is a pointer, then dereference it.  */\n-        if (TYPE_CODE (parent_type) == TYPE_CODE_PTR)\n+        if (parent_type->code () == TYPE_CODE_PTR)\n           parent_type = TYPE_TARGET_TYPE (parent_type);\n         /* If there is a parallel XVS type, get the actual base type.  */\n         parent_type = ada_get_base_type (parent_type);\n@@ -6942,9 +6941,9 @@ ada_is_variant_part (struct type *type, int field_num)\n \n   struct type *field_type = TYPE_FIELD_TYPE (type, field_num);\n \n-  return (TYPE_CODE (field_type) == TYPE_CODE_UNION\n-          || (is_dynamic_field (type, field_num)\n-              && (TYPE_CODE (TYPE_TARGET_TYPE (field_type)) \n+  return (field_type->code () == TYPE_CODE_UNION\n+\t  || (is_dynamic_field (type, field_num)\n+\t      && (TYPE_TARGET_TYPE (field_type)->code ()\n \t\t  == TYPE_CODE_UNION)));\n }\n \n@@ -6987,7 +6986,7 @@ ada_variant_discrim_name (struct type *type0)\n   const char *discrim_end;\n   const char *discrim_start;\n \n-  if (TYPE_CODE (type0) == TYPE_CODE_PTR)\n+  if (type0->code () == TYPE_CODE_PTR)\n     type = TYPE_TARGET_TYPE (type0);\n   else\n     type = type0;\n@@ -7520,15 +7519,14 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n     while (1)\n       {\n         type = ada_check_typedef (type);\n-        if (TYPE_CODE (type) != TYPE_CODE_PTR\n-            && TYPE_CODE (type) != TYPE_CODE_REF)\n+        if (type->code () != TYPE_CODE_PTR && type->code () != TYPE_CODE_REF)\n           break;\n         type = TYPE_TARGET_TYPE (type);\n       }\n \n   if (type == NULL\n-      || (TYPE_CODE (type) != TYPE_CODE_STRUCT\n-          && TYPE_CODE (type) != TYPE_CODE_UNION))\n+      || (type->code () != TYPE_CODE_STRUCT\n+\t  && type->code () != TYPE_CODE_UNION))\n     {\n       if (noerr)\n         return NULL;\n@@ -7731,7 +7729,7 @@ ada_value_ind (struct value *val0)\n static struct value *\n ada_coerce_ref (struct value *val0)\n {\n-  if (TYPE_CODE (value_type (val0)) == TYPE_CODE_REF)\n+  if (value_type (val0)->code () == TYPE_CODE_REF)\n     {\n       struct value *val = val0;\n \n@@ -7832,9 +7830,9 @@ ada_prefer_type (struct type *type0, struct type *type1)\n     return 1;\n   else if (type0 == NULL)\n     return 0;\n-  else if (TYPE_CODE (type1) == TYPE_CODE_VOID)\n+  else if (type1->code () == TYPE_CODE_VOID)\n     return 1;\n-  else if (TYPE_CODE (type0) == TYPE_CODE_VOID)\n+  else if (type0->code () == TYPE_CODE_VOID)\n     return 0;\n   else if (TYPE_NAME (type1) == NULL && TYPE_NAME (type0) != NULL)\n     return 1;\n@@ -7974,7 +7972,7 @@ dynamic_template_type (struct type *type)\n {\n   type = ada_check_typedef (type);\n \n-  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT\n+  if (type == NULL || type->code () != TYPE_CODE_STRUCT\n       || ada_type_name (type) == NULL)\n     return NULL;\n   else\n@@ -7997,7 +7995,7 @@ is_dynamic_field (struct type *templ_type, int field_num)\n   const char *name = TYPE_FIELD_NAME (templ_type, field_num);\n \n   return name != NULL\n-    && TYPE_CODE (TYPE_FIELD_TYPE (templ_type, field_num)) == TYPE_CODE_PTR\n+    && TYPE_FIELD_TYPE (templ_type, field_num)->code () == TYPE_CODE_PTR\n     && strstr (name, \"___XVL\") != NULL;\n }\n \n@@ -8009,7 +8007,7 @@ variant_field_index (struct type *type)\n {\n   int f;\n \n-  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)\n+  if (type == NULL || type->code () != TYPE_CODE_STRUCT)\n     return -1;\n \n   for (f = 0; f < TYPE_NFIELDS (type); f += 1)\n@@ -8208,7 +8206,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t\t the length of our field.  If this is a typedef,\n \t\t get the length of the target type, not the length\n \t\t of the typedef.  */\n-\t      if (TYPE_CODE (field_type) == TYPE_CODE_TYPEDEF)\n+\t      if (field_type->code () == TYPE_CODE_TYPEDEF)\n \t\tfield_type = ada_typedef_target_type (field_type);\n \n               fld_bit_len =\n@@ -8358,7 +8356,7 @@ template_to_static_fixed_type (struct type *type0)\n \t  if (type == type0)\n \t    {\n \t      TYPE_TARGET_TYPE (type0) = type = alloc_type_copy (type0);\n-\t      type->set_code (TYPE_CODE(type0));\n+\t      type->set_code (type0->code ());\n \t      INIT_NONE_SPECIFIC (type);\n \t      TYPE_NFIELDS (type) = nfields;\n \t      TYPE_FIELDS (type) = (struct field *)\n@@ -8509,7 +8507,7 @@ to_fixed_variant_branch_type (struct type *var_type0, const gdb_byte *valaddr,\n   struct type *templ_type;\n   struct type *var_type;\n \n-  if (TYPE_CODE (var_type0) == TYPE_CODE_PTR)\n+  if (var_type0->code () == TYPE_CODE_PTR)\n     var_type = TYPE_TARGET_TYPE (var_type0);\n   else\n     var_type = var_type0;\n@@ -8549,10 +8547,10 @@ ada_is_redundant_range_encoding (struct type *range_type,\n   int n;\n   LONGEST lo, hi;\n \n-  gdb_assert (TYPE_CODE (range_type) == TYPE_CODE_RANGE);\n+  gdb_assert (range_type->code () == TYPE_CODE_RANGE);\n \n-  if (TYPE_CODE (get_base_type (range_type))\n-      != TYPE_CODE (get_base_type (encoding_type)))\n+  if (get_base_type (range_type)->code ()\n+      != get_base_type (encoding_type)->code ())\n     {\n       /* The compiler probably used a simple base type to describe\n \t the range type instead of the range's actual base type,\n@@ -8780,7 +8778,7 @@ ada_to_fixed_type_1 (struct type *type, const gdb_byte *valaddr,\n   if (!HAVE_GNAT_AUX_INFO (type))\n     return type;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     default:\n       return type;\n@@ -8928,7 +8926,7 @@ ada_to_fixed_type (struct type *type, const gdb_byte *valaddr,\n       only in that situation.  But this seems unnecessary so far, probably\n       because we call check_typedef/ada_check_typedef pretty much everywhere.\n       */\n-  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF\n+  if (type->code () == TYPE_CODE_TYPEDEF\n       && (TYPE_MAIN_TYPE (ada_typedef_target_type (type))\n \t  == TYPE_MAIN_TYPE (fixed_type)))\n     return type;\n@@ -8952,7 +8950,7 @@ to_static_fixed_type (struct type *type0)\n \n   type0 = ada_check_typedef (type0);\n \n-  switch (TYPE_CODE (type0))\n+  switch (type0->code ())\n     {\n     default:\n       return type0;\n@@ -9025,7 +9023,7 @@ ada_check_typedef (struct type *type)\n     return type;\n \n   type = check_typedef (type);\n-  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_ENUM\n+  if (type == NULL || type->code () != TYPE_CODE_ENUM\n       || !TYPE_STUB (type)\n       || TYPE_NAME (type) == NULL)\n     return type;\n@@ -9041,7 +9039,7 @@ ada_check_typedef (struct type *type)\n \t stubs pointing to arrays, as we don't create symbols for array\n \t types, only for the typedef-to-array types).  If that's the case,\n \t strip the typedef layer.  */\n-      if (TYPE_CODE (type1) == TYPE_CODE_TYPEDEF)\n+      if (type1->code () == TYPE_CODE_TYPEDEF)\n \ttype1 = ada_check_typedef (type1);\n \n       return type1;\n@@ -9152,7 +9150,7 @@ value_val_atr (struct type *type, struct value *arg)\n   if (!integer_type_p (value_type (arg)))\n     error (_(\"'VAL requires integral argument\"));\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ENUM)\n+  if (type->code () == TYPE_CODE_ENUM)\n     {\n       long pos = value_as_long (arg);\n \n@@ -9178,15 +9176,15 @@ ada_is_character_type (struct type *type)\n \n   /* If the type code says it's a character, then assume it really is,\n      and don't check any further.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_CHAR)\n+  if (type->code () == TYPE_CODE_CHAR)\n     return true;\n   \n   /* Otherwise, assume it's a character type iff it is a discrete type\n      with a known character type name.  */\n   name = ada_type_name (type);\n   return (name != NULL\n-          && (TYPE_CODE (type) == TYPE_CODE_INT\n-              || TYPE_CODE (type) == TYPE_CODE_RANGE)\n+          && (type->code () == TYPE_CODE_INT\n+              || type->code () == TYPE_CODE_RANGE)\n           && (strcmp (name, \"character\") == 0\n               || strcmp (name, \"wide_character\") == 0\n               || strcmp (name, \"wide_wide_character\") == 0\n@@ -9200,7 +9198,7 @@ ada_is_string_type (struct type *type)\n {\n   type = ada_check_typedef (type);\n   if (type != NULL\n-      && TYPE_CODE (type) != TYPE_CODE_PTR\n+      && type->code () != TYPE_CODE_PTR\n       && (ada_is_simple_array_type (type)\n           || ada_is_array_descriptor_type (type))\n       && ada_array_arity (type) == 1)\n@@ -9236,7 +9234,7 @@ ada_is_aligner_type (struct type *type)\n   if (!trust_pad_over_xvs && ada_find_parallel_type (type, \"___XVS\") != NULL)\n     return 0;\n \n-  return (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  return (type->code () == TYPE_CODE_STRUCT\n           && TYPE_NFIELDS (type) == 1\n           && strcmp (TYPE_FIELD_NAME (type, 0), \"F\") == 0);\n }\n@@ -9250,7 +9248,7 @@ ada_get_base_type (struct type *raw_type)\n   struct type *real_type_namer;\n   struct type *raw_real_type;\n \n-  if (raw_type == NULL || TYPE_CODE (raw_type) != TYPE_CODE_STRUCT)\n+  if (raw_type == NULL || raw_type->code () != TYPE_CODE_STRUCT)\n     return raw_type;\n \n   if (ada_is_aligner_type (raw_type))\n@@ -9270,11 +9268,11 @@ ada_get_base_type (struct type *raw_type)\n \n   real_type_namer = ada_find_parallel_type (raw_type, \"___XVS\");\n   if (real_type_namer == NULL\n-      || TYPE_CODE (real_type_namer) != TYPE_CODE_STRUCT\n+      || real_type_namer->code () != TYPE_CODE_STRUCT\n       || TYPE_NFIELDS (real_type_namer) != 1)\n     return raw_type;\n \n-  if (TYPE_CODE (TYPE_FIELD_TYPE (real_type_namer, 0)) != TYPE_CODE_REF)\n+  if (TYPE_FIELD_TYPE (real_type_namer, 0)->code () != TYPE_CODE_REF)\n     {\n       /* This is an older encoding form where the base type needs to be\n \t looked up by name.  We prefer the newer encoding because it is\n@@ -9513,9 +9511,9 @@ ada_promote_array_of_integrals (struct type *type, struct value *val)\n   /* Verify that both val and type are arrays of scalars, and\n      that the size of val's elements is smaller than the size\n      of type's element.  */\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_ARRAY);\n+  gdb_assert (type->code () == TYPE_CODE_ARRAY);\n   gdb_assert (is_integral_type (TYPE_TARGET_TYPE (type)));\n-  gdb_assert (TYPE_CODE (value_type (val)) == TYPE_CODE_ARRAY);\n+  gdb_assert (value_type (val)->code () == TYPE_CODE_ARRAY);\n   gdb_assert (is_integral_type (TYPE_TARGET_TYPE (value_type (val))));\n   gdb_assert (TYPE_LENGTH (TYPE_TARGET_TYPE (type))\n \t      > TYPE_LENGTH (TYPE_TARGET_TYPE (value_type (val))));\n@@ -9551,15 +9549,15 @@ coerce_for_assign (struct type *type, struct value *val)\n   type2 = ada_check_typedef (type2);\n   type = ada_check_typedef (type);\n \n-  if (TYPE_CODE (type2) == TYPE_CODE_PTR\n-      && TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type2->code () == TYPE_CODE_PTR\n+      && type->code () == TYPE_CODE_ARRAY)\n     {\n       val = ada_value_ind (val);\n       type2 = value_type (val);\n     }\n \n-  if (TYPE_CODE (type2) == TYPE_CODE_ARRAY\n-      && TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type2->code () == TYPE_CODE_ARRAY\n+      && type->code () == TYPE_CODE_ARRAY)\n     {\n       if (!ada_same_array_size_p (type, type2))\n \terror (_(\"cannot assign arrays of different length\"));\n@@ -9594,8 +9592,8 @@ ada_value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n   type1 = get_base_type (ada_check_typedef (value_type (arg1)));\n   type2 = get_base_type (ada_check_typedef (value_type (arg2)));\n \n-  if (TYPE_CODE (type1) != TYPE_CODE_INT\n-      || TYPE_CODE (type2) != TYPE_CODE_INT)\n+  if (type1->code () != TYPE_CODE_INT\n+      || type2->code () != TYPE_CODE_INT)\n     return value_binop (arg1, arg2, op);\n \n   switch (op)\n@@ -9659,8 +9657,8 @@ ada_value_equal (struct value *arg1, struct value *arg2)\n       arg1_type = ada_check_typedef (value_type (arg1));\n       arg2_type = ada_check_typedef (value_type (arg2));\n \n-      if (TYPE_CODE (arg1_type) != TYPE_CODE_ARRAY\n-          || TYPE_CODE (arg2_type) != TYPE_CODE_ARRAY)\n+      if (arg1_type->code () != TYPE_CODE_ARRAY\n+          || arg2_type->code () != TYPE_CODE_ARRAY)\n         error (_(\"Attempt to compare array with non-array\"));\n       /* FIXME: The following works only for types whose\n          representations use all bits (no padding or undefined bits)\n@@ -9714,7 +9712,7 @@ assign_component (struct value *container, struct value *lhs, LONGEST index,\n   struct value *elt;\n   struct type *lhs_type = check_typedef (value_type (lhs));\n \n-  if (TYPE_CODE (lhs_type) == TYPE_CODE_ARRAY)\n+  if (lhs_type->code () == TYPE_CODE_ARRAY)\n     {\n       struct type *index_type = builtin_type (exp->gdbarch)->builtin_int;\n       struct value *index_val = value_from_longest (index_type, index);\n@@ -9781,7 +9779,7 @@ assign_aggregate (struct value *container,\n       low_index = TYPE_ARRAY_LOWER_BOUND_VALUE (lhs_type);\n       high_index = TYPE_ARRAY_UPPER_BOUND_VALUE (lhs_type);\n     }\n-  else if (TYPE_CODE (lhs_type) == TYPE_CODE_STRUCT)\n+  else if (lhs_type->code () == TYPE_CODE_STRUCT)\n     {\n       low_index = 0;\n       high_index = num_visible_fields (lhs_type) - 1;\n@@ -10375,7 +10373,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n         result = evaluate_subexp_standard (expect_type, exp, pos, noside);\n         /* The result type will have code OP_STRING, bashed there from \n            OP_ARRAY.  Bash it back.  */\n-        if (TYPE_CODE (value_type (result)) == TYPE_CODE_STRING)\n+        if (value_type (result)->code () == TYPE_CODE_STRING)\n           value_type (result)->set_code (TYPE_CODE_ARRAY);\n         return result;\n       }\n@@ -10427,11 +10425,11 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n-      if (TYPE_CODE (value_type (arg1)) == TYPE_CODE_PTR)\n+      if (value_type (arg1)->code () == TYPE_CODE_PTR)\n         return (value_from_longest\n                  (value_type (arg1),\n                   value_as_long (arg1) + value_as_long (arg2)));\n-      if (TYPE_CODE (value_type (arg2)) == TYPE_CODE_PTR)\n+      if (value_type (arg2)->code () == TYPE_CODE_PTR)\n         return (value_from_longest\n                  (value_type (arg2),\n                   value_as_long (arg1) + value_as_long (arg2)));\n@@ -10443,7 +10441,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n          argument.  We cannot cast the result to a reference type, so if\n          ARG1 is a reference type, find its underlying type.  */\n       type = value_type (arg1);\n-      while (TYPE_CODE (type) == TYPE_CODE_REF)\n+      while (type->code () == TYPE_CODE_REF)\n         type = TYPE_TARGET_TYPE (type);\n       binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n       return value_cast (type, value_binop (arg1, arg2, BINOP_ADD));\n@@ -10453,11 +10451,11 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n-      if (TYPE_CODE (value_type (arg1)) == TYPE_CODE_PTR)\n+      if (value_type (arg1)->code () == TYPE_CODE_PTR)\n         return (value_from_longest\n                  (value_type (arg1),\n                   value_as_long (arg1) - value_as_long (arg2)));\n-      if (TYPE_CODE (value_type (arg2)) == TYPE_CODE_PTR)\n+      if (value_type (arg2)->code () == TYPE_CODE_PTR)\n         return (value_from_longest\n                  (value_type (arg2),\n                   value_as_long (arg1) - value_as_long (arg2)));\n@@ -10470,7 +10468,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n          argument.  We cannot cast the result to a reference type, so if\n          ARG1 is a reference type, find its underlying type.  */\n       type = value_type (arg1);\n-      while (TYPE_CODE (type) == TYPE_CODE_REF)\n+      while (type->code () == TYPE_CODE_REF)\n         type = TYPE_TARGET_TYPE (type);\n       binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n       return value_cast (type, value_binop (arg1, arg2, BINOP_SUB));\n@@ -10579,7 +10577,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n              The latter should be shown as usual (as a pointer), whereas\n              a reference should mostly be transparent to the user.  */\n           if (ada_is_tagged_type (type, 0)\n-              || (TYPE_CODE (type) == TYPE_CODE_REF\n+              || (type->code () == TYPE_CODE_REF\n                   && ada_is_tagged_type (TYPE_TARGET_TYPE (type), 0)))\n \t    {\n \t      /* Tagged types are a little special in the fact that the real\n@@ -10601,7 +10599,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t\t type in the type description.  */\n \t      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_NORMAL);\n \n-\t      if (TYPE_CODE (type) != TYPE_CODE_REF)\n+\t      if (type->code () != TYPE_CODE_REF)\n \t\t{\n \t\t  struct type *actual_type;\n \n@@ -10634,9 +10632,9 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t     For instance, a case statement in a variant record would be\n \t     replaced by the relevant components based on the actual\n \t     value of the discriminants.  */\n-\t  if ((TYPE_CODE (type) == TYPE_CODE_STRUCT\n+\t  if ((type->code () == TYPE_CODE_STRUCT\n \t       && dynamic_template_type (type) != NULL)\n-\t      || (TYPE_CODE (type) == TYPE_CODE_UNION\n+\t      || (type->code () == TYPE_CODE_UNION\n \t\t  && ada_find_parallel_type (type, \"___XVU\") != NULL))\n \t    {\n \t      *pos += 4;\n@@ -10672,21 +10670,21 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       if (ada_is_constrained_packed_array_type\n \t  (desc_base_type (value_type (argvec[0]))))\n         argvec[0] = ada_coerce_to_simple_array (argvec[0]);\n-      else if (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_ARRAY\n+      else if (value_type (argvec[0])->code () == TYPE_CODE_ARRAY\n                && TYPE_FIELD_BITSIZE (value_type (argvec[0]), 0) != 0)\n         /* This is a packed array that has already been fixed, and\n \t   therefore already coerced to a simple array.  Nothing further\n \t   to do.  */\n         ;\n-      else if (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_REF)\n+      else if (value_type (argvec[0])->code () == TYPE_CODE_REF)\n \t{\n \t  /* Make sure we dereference references so that all the code below\n \t     feels like it's really handling the referenced value.  Wrapping\n \t     types (for alignment) may be there, so make sure we strip them as\n \t     well.  */\n \t  argvec[0] = ada_to_fixed_value (coerce_ref (argvec[0]));\n \t}\n-      else if (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_ARRAY\n+      else if (value_type (argvec[0])->code () == TYPE_CODE_ARRAY\n \t       && VALUE_LVAL (argvec[0]) == lval_memory)\n \targvec[0] = value_addr (argvec[0]);\n \n@@ -10695,12 +10693,12 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       /* Ada allows us to implicitly dereference arrays when subscripting\n \t them.  So, if this is an array typedef (encoding use for array\n \t access types encoded as fat pointers), strip it now.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+      if (type->code () == TYPE_CODE_TYPEDEF)\n \ttype = ada_typedef_target_type (type);\n \n-      if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+      if (type->code () == TYPE_CODE_PTR)\n         {\n-          switch (TYPE_CODE (ada_check_typedef (TYPE_TARGET_TYPE (type))))\n+          switch (ada_check_typedef (TYPE_TARGET_TYPE (type))->code ())\n             {\n             case TYPE_CODE_FUNC:\n               type = ada_check_typedef (TYPE_TARGET_TYPE (type));\n@@ -10719,7 +10717,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n             }\n         }\n \n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n         {\n         case TYPE_CODE_FUNC:\n           if (noside == EVAL_AVOID_SIDE_EFFECTS)\n@@ -10810,7 +10808,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n         /* If this is a reference to an aligner type, then remove all\n            the aligners.  */\n-        if (TYPE_CODE (value_type (array)) == TYPE_CODE_REF\n+        if (value_type (array)->code () == TYPE_CODE_REF\n             && ada_is_aligner_type (TYPE_TARGET_TYPE (value_type (array))))\n           TYPE_TARGET_TYPE (value_type (array)) =\n             ada_aligned_type (TYPE_TARGET_TYPE (value_type (array)));\n@@ -10820,8 +10818,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n         /* If this is a reference to an array or an array lvalue,\n            convert to a pointer.  */\n-        if (TYPE_CODE (value_type (array)) == TYPE_CODE_REF\n-            || (TYPE_CODE (value_type (array)) == TYPE_CODE_ARRAY\n+        if (value_type (array)->code () == TYPE_CODE_REF\n+            || (value_type (array)->code () == TYPE_CODE_ARRAY\n                 && VALUE_LVAL (array) == lval_memory))\n           array = value_addr (array);\n \n@@ -10835,8 +10833,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n         /* If we have more than one level of pointer indirection,\n            dereference the value until we get only one level.  */\n-        while (TYPE_CODE (value_type (array)) == TYPE_CODE_PTR\n-               && (TYPE_CODE (TYPE_TARGET_TYPE (value_type (array)))\n+        while (value_type (array)->code () == TYPE_CODE_PTR\n+               && (TYPE_TARGET_TYPE (value_type (array))->code ()\n                      == TYPE_CODE_PTR))\n           array = value_ind (array);\n \n@@ -10847,7 +10845,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n         if (!ada_is_simple_array_type (value_type (array)))\n           error (_(\"cannot take slice of non-array\"));\n \n-        if (TYPE_CODE (ada_check_typedef (value_type (array)))\n+        if (ada_check_typedef (value_type (array))->code ()\n             == TYPE_CODE_PTR)\n           {\n             struct type *type0 = ada_check_typedef (value_type (array));\n@@ -10881,7 +10879,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n \n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n         {\n         default:\n           lim_warning (_(\"Membership test incompletely implemented; \"\n@@ -11044,7 +11042,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n             const char *name = ada_type_name (type_arg);\n \n             range_type = NULL;\n-            if (name != NULL && TYPE_CODE (type_arg) != TYPE_CODE_ENUM)\n+            if (name != NULL && type_arg->code () != TYPE_CODE_ENUM)\n               range_type = to_fixed_range_type (type_arg, NULL);\n             if (range_type == NULL)\n               range_type = type_arg;\n@@ -11062,7 +11060,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n                 error (_(\"the 'length attribute applies only to array types\"));\n               }\n           }\n-        else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)\n+        else if (type_arg->code () == TYPE_CODE_FLT)\n           error (_(\"unimplemented type attribute\"));\n         else\n           {\n@@ -11158,7 +11156,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       /* If the argument is a reference, then dereference its type, since\n          the user is really asking for the size of the actual object,\n          not the size of the pointer.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_REF)\n+      if (type->code () == TYPE_CODE_REF)\n         type = TYPE_TARGET_TYPE (type);\n \n       if (noside == EVAL_SKIP)\n@@ -11233,18 +11231,18 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n                 error (_(\"Attempt to dereference null array pointer.\"));\n               return value_at_lazy (arrType, 0);\n             }\n-          else if (TYPE_CODE (type) == TYPE_CODE_PTR\n-                   || TYPE_CODE (type) == TYPE_CODE_REF\n+          else if (type->code () == TYPE_CODE_PTR\n+                   || type->code () == TYPE_CODE_REF\n                    /* In C you can dereference an array to get the 1st elt.  */\n-                   || TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+                   || type->code () == TYPE_CODE_ARRAY)\n             {\n             /* As mentioned in the OP_VAR_VALUE case, tagged types can\n                only be determined by inspecting the object's tag.\n                This means that we need to evaluate completely the\n                expression in order to get its type.  */\n \n-\t      if ((TYPE_CODE (type) == TYPE_CODE_REF\n-\t\t   || TYPE_CODE (type) == TYPE_CODE_PTR)\n+\t      if ((type->code () == TYPE_CODE_REF\n+\t\t   || type->code () == TYPE_CODE_PTR)\n \t\t  && ada_is_tagged_type (TYPE_TARGET_TYPE (type), 0))\n \t\t{\n \t\t  arg1 = evaluate_subexp (NULL_TYPE, exp, &preeval_pos,\n@@ -11260,7 +11258,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t      ada_ensure_varsize_limit (type);\n               return value_zero (type, lval_memory);\n             }\n-          else if (TYPE_CODE (type) == TYPE_CODE_INT)\n+          else if (type->code () == TYPE_CODE_INT)\n \t    {\n \t      /* GDB allows dereferencing an int.  */\n \t      if (expect_type == NULL)\n@@ -11279,7 +11277,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       arg1 = ada_coerce_ref (arg1);     /* FIXME: What is this for??  */\n       type = ada_check_typedef (value_type (arg1));\n \n-      if (TYPE_CODE (type) == TYPE_CODE_INT)\n+      if (type->code () == TYPE_CODE_INT)\n           /* GDB allows dereferencing an int.  If we were given\n              the expect_type, then use that as the target type.\n              Otherwise, assume that the target type is an int.  */\n@@ -11396,7 +11394,7 @@ static const char *\n fixed_type_info (struct type *type)\n {\n   const char *name = ada_type_name (type);\n-  enum type_code code = (type == NULL) ? TYPE_CODE_UNDEF : TYPE_CODE (type);\n+  enum type_code code = (type == NULL) ? TYPE_CODE_UNDEF : type->code ();\n \n   if ((code == TYPE_CODE_INT || code == TYPE_CODE_RANGE) && name != NULL)\n     {\n@@ -11597,7 +11595,7 @@ to_fixed_range_type (struct type *raw_type, struct value *dval)\n   gdb_assert (raw_type != NULL);\n   gdb_assert (TYPE_NAME (raw_type) != NULL);\n \n-  if (TYPE_CODE (raw_type) == TYPE_CODE_RANGE)\n+  if (raw_type->code () == TYPE_CODE_RANGE)\n     base_type = TYPE_TARGET_TYPE (raw_type);\n   else\n     base_type = raw_type;\n@@ -11699,8 +11697,8 @@ ada_is_modular_type (struct type *type)\n {\n   struct type *subranged_type = get_base_type (type);\n \n-  return (subranged_type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE\n-          && TYPE_CODE (subranged_type) == TYPE_CODE_INT\n+  return (subranged_type != NULL && type->code () == TYPE_CODE_RANGE\n+          && subranged_type->code () == TYPE_CODE_INT\n           && TYPE_UNSIGNED (subranged_type));\n }\n \n@@ -13662,7 +13660,7 @@ ada_print_subexp (struct expression *exp, int *pos,\n     case OP_ATR_VAL:\n       if (exp->elts[*pos].opcode == OP_TYPE)\n         {\n-          if (TYPE_CODE (exp->elts[*pos + 1].type) != TYPE_CODE_VOID)\n+          if (exp->elts[*pos + 1].type->code () != TYPE_CODE_VOID)\n             LA_PRINT_TYPE (exp->elts[*pos + 1].type, \"\", stream, 0, 0,\n \t\t\t   &type_print_raw_options);\n           *pos += 3;"
    },
    {
      "sha": "1288e1608f57f7377d49b86b5ced72a91a41cef7",
      "filename": "gdb/ada-tasks.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-tasks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-tasks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-tasks.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -431,9 +431,9 @@ read_fat_string_value (char *dest, struct value *val, int max_len)\n       bounds_fieldno = ada_get_field_index (type, \"P_BOUNDS\", 0);\n \n       bounds_type = TYPE_FIELD_TYPE (type, bounds_fieldno);\n-      if (TYPE_CODE (bounds_type) == TYPE_CODE_PTR)\n+      if (bounds_type->code () == TYPE_CODE_PTR)\n         bounds_type = TYPE_TARGET_TYPE (bounds_type);\n-      if (TYPE_CODE (bounds_type) != TYPE_CODE_STRUCT)\n+      if (bounds_type->code () != TYPE_CODE_STRUCT)\n         error (_(\"Unknown task name format. Aborting\"));\n       upper_bound_fieldno = ada_get_field_index (bounds_type, \"UB0\", 0);\n \n@@ -890,10 +890,10 @@ ada_tasks_inferior_data_sniffer (struct ada_tasks_inferior_data *data)\n \t  struct type *eltype = NULL;\n \t  struct type *idxtype = NULL;\n \n-\t  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+\t  if (type->code () == TYPE_CODE_ARRAY)\n \t    eltype = check_typedef (TYPE_TARGET_TYPE (type));\n \t  if (eltype != NULL\n-\t      && TYPE_CODE (eltype) == TYPE_CODE_PTR)\n+\t      && eltype->code () == TYPE_CODE_PTR)\n \t    idxtype = check_typedef (TYPE_INDEX_TYPE (type));\n \t  if (idxtype != NULL\n \t      && !TYPE_LOW_BOUND_UNDEFINED (idxtype)\n@@ -933,7 +933,7 @@ ada_tasks_inferior_data_sniffer (struct ada_tasks_inferior_data *data)\n \t  /* Validate.  */\n \t  struct type *type = check_typedef (SYMBOL_TYPE (sym));\n \n-\t  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+\t  if (type->code () == TYPE_CODE_PTR)\n \t    {\n \t      data->known_tasks_element = type;\n \t      return;"
    },
    {
      "sha": "0ae8f9314514662277fa0d4bb6edd3c47124a594",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -101,7 +101,7 @@ type_is_full_subrange_of_target_type (struct type *type)\n {\n   struct type *subtype;\n \n-  if (TYPE_CODE (type) != TYPE_CODE_RANGE)\n+  if (type->code () != TYPE_CODE_RANGE)\n     return 0;\n \n   subtype = TYPE_TARGET_TYPE (type);\n@@ -146,7 +146,7 @@ print_range (struct type *type, struct ui_file *stream,\n \ttype = TYPE_TARGET_TYPE (type);\n     }\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_RANGE:\n     case TYPE_CODE_ENUM:\n@@ -208,7 +208,7 @@ print_range_bound (struct type *type, const char *bounds, int *n,\n          to indicate default output when we detect that the bound is negative,\n          and the type is a TYPE_CODE_INT.  The bound is negative when\n          'm' is the last character of the number scanned in BOUNDS.  */\n-      if (bounds[*n - 1] == 'm' && TYPE_CODE (type) == TYPE_CODE_INT)\n+      if (bounds[*n - 1] == 'm' && type->code () == TYPE_CODE_INT)\n \ttype = NULL;\n       ada_print_scalar (type, B, stream);\n       if (bounds[*n] == '_')\n@@ -270,7 +270,7 @@ print_range_type (struct type *raw_type, struct ui_file *stream,\n   name = TYPE_NAME (raw_type);\n   gdb_assert (name != NULL);\n \n-  if (TYPE_CODE (raw_type) == TYPE_CODE_RANGE)\n+  if (raw_type->code () == TYPE_CODE_RANGE)\n     base_type = TYPE_TARGET_TYPE (raw_type);\n   else\n     base_type = raw_type;\n@@ -402,7 +402,7 @@ print_array_type (struct type *type, struct ui_file *stream, int show,\n       bitsize = 0;\n       if (range_desc_type == NULL)\n \t{\n-\t  for (arr_type = type; TYPE_CODE (arr_type) == TYPE_CODE_ARRAY;\n+\t  for (arr_type = type; arr_type->code () == TYPE_CODE_ARRAY;\n \t       arr_type = TYPE_TARGET_TYPE (arr_type))\n \t    {\n \t      if (arr_type != type)\n@@ -552,10 +552,10 @@ print_variant_clauses (struct type *type, int field_num,\n   var_type = TYPE_FIELD_TYPE (type, field_num);\n   discr_type = ada_variant_discrim_type (var_type, outer_type);\n \n-  if (TYPE_CODE (var_type) == TYPE_CODE_PTR)\n+  if (var_type->code () == TYPE_CODE_PTR)\n     {\n       var_type = TYPE_TARGET_TYPE (var_type);\n-      if (var_type == NULL || TYPE_CODE (var_type) != TYPE_CODE_UNION)\n+      if (var_type == NULL || var_type->code () != TYPE_CODE_UNION)\n \treturn;\n     }\n \n@@ -898,7 +898,7 @@ print_func_type (struct type *type, struct ui_file *stream, const char *name,\n   int i, len = TYPE_NFIELDS (type);\n \n   if (TYPE_TARGET_TYPE (type) != NULL\n-      && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)\n+      && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_VOID)\n     fprintf_filtered (stream, \"procedure\");\n   else\n     fprintf_filtered (stream, \"function\");\n@@ -928,7 +928,7 @@ print_func_type (struct type *type, struct ui_file *stream, const char *name,\n \n   if (TYPE_TARGET_TYPE (type) == NULL)\n     fprintf_filtered (stream, \" return <unknown return type>\");\n-  else if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n+  else if (TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n     {\n       fprintf_filtered (stream, \" return \");\n       ada_print_type (TYPE_TARGET_TYPE (type), \"\", stream, 0, 0, flags);\n@@ -970,7 +970,7 @@ ada_print_type (struct type *type0, const char *varstring,\n   if (show > 0)\n     type = ada_check_typedef (type);\n \n-  if (is_var_decl && TYPE_CODE (type) != TYPE_CODE_FUNC)\n+  if (is_var_decl && type->code () != TYPE_CODE_FUNC)\n     fprintf_filtered (stream, \"%.*s: \",\n \t\t      ada_name_prefix_len (varstring), varstring);\n \n@@ -984,10 +984,10 @@ ada_print_type (struct type *type0, const char *varstring,\n   if (ada_is_aligner_type (type))\n     ada_print_type (ada_aligned_type (type), \"\", stream, show, level, flags);\n   else if (ada_is_constrained_packed_array_type (type)\n-\t   && TYPE_CODE (type) != TYPE_CODE_PTR)\n+\t   && type->code () != TYPE_CODE_PTR)\n     print_array_type (type, stream, show, level, flags);\n   else\n-    switch (TYPE_CODE (type))\n+    switch (type->code ())\n       {\n       default:\n \tfprintf_filtered (stream, \"<\");"
    },
    {
      "sha": "4ad4b5409fd6134d7ca124e2d1beabd08df69fe2",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -41,7 +41,7 @@ static int print_field_values (struct value *, struct value *,\n static void\n adjust_type_signedness (struct type *type)\n {\n-  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE\n+  if (type != NULL && type->code () == TYPE_CODE_RANGE\n       && TYPE_LOW_BOUND (type) >= 0)\n     TYPE_UNSIGNED (type) = 1;\n }\n@@ -73,7 +73,7 @@ print_optional_low_bound (struct ui_file *stream, struct type *type,\n \n   index_type = TYPE_INDEX_TYPE (type);\n \n-  while (TYPE_CODE (index_type) == TYPE_CODE_RANGE)\n+  while (index_type->code () == TYPE_CODE_RANGE)\n     {\n       /* We need to know what the base type is, in order to do the\n          appropriate check below.  Otherwise, if this is a subrange\n@@ -84,7 +84,7 @@ print_optional_low_bound (struct ui_file *stream, struct type *type,\n     }\n \n   /* Don't print the lower bound if it's the default one.  */\n-  switch (TYPE_CODE (index_type))\n+  switch (index_type->code ())\n     {\n     case TYPE_CODE_BOOL:\n     case TYPE_CODE_CHAR:\n@@ -141,12 +141,12 @@ val_print_packed_array_elements (struct type *type, const gdb_byte *valaddr,\n     else\n       len = high - low + 1;\n \n-    if (TYPE_CODE (index_type) == TYPE_CODE_RANGE)\n+    if (index_type->code () == TYPE_CODE_RANGE)\n         base_index_type = TYPE_TARGET_TYPE (index_type);\n       else\n         base_index_type = index_type;\n \n-    if (TYPE_CODE (base_index_type) == TYPE_CODE_ENUM)\n+    if (base_index_type->code () == TYPE_CODE_ENUM)\n       {\n         LONGEST low_pos, high_pos;\n \n@@ -396,7 +396,7 @@ ada_print_scalar (struct type *type, LONGEST val, struct ui_file *stream)\n \n   type = ada_check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n \n     case TYPE_CODE_ENUM:\n@@ -749,13 +749,13 @@ ada_val_print_gnat_array (struct value *val,\n      of the case where ADDRESS is meaningless because original_value\n      was not an lval.  */\n   val = coerce_ref (val);\n-  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)  /* array access type.  */\n+  if (type->code () == TYPE_CODE_TYPEDEF)  /* array access type.  */\n     val = ada_coerce_to_simple_array_ptr (val);\n   else\n     val = ada_coerce_to_simple_array (val);\n   if (val == NULL)\n     {\n-      gdb_assert (TYPE_CODE (type) == TYPE_CODE_TYPEDEF);\n+      gdb_assert (type->code () == TYPE_CODE_TYPEDEF);\n       fprintf_filtered (stream, \"0x0\");\n     }\n   else\n@@ -805,10 +805,10 @@ ada_value_print_num (struct value *val, struct ui_file *stream, int recurse,\n       fputs_filtered (str.c_str (), stream);\n       return;\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_RANGE\n-\t   && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ENUM\n-\t       || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_BOOL\n-\t       || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_CHAR))\n+  else if (type->code () == TYPE_CODE_RANGE\n+\t   && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ENUM\n+\t       || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_BOOL\n+\t       || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_CHAR))\n     {\n       /* For enum-valued ranges, we want to recurse, because we'll end\n \t up printing the constant's name rather than its numeric\n@@ -992,7 +992,7 @@ ada_val_print_ref (struct type *type, const gdb_byte *valaddr,\n   struct value *deref_val;\n   CORE_ADDR deref_val_int;\n \n-  if (TYPE_CODE (elttype) == TYPE_CODE_UNDEF)\n+  if (elttype->code () == TYPE_CODE_UNDEF)\n     {\n       fputs_styled (\"<ref to undefined type>\", metadata_style.style (),\n \t\t    stream);\n@@ -1048,7 +1048,7 @@ ada_value_print_1 (struct value *val, struct ui_file *stream, int recurse,\n \n   if (ada_is_array_descriptor_type (type)\n       || (ada_is_constrained_packed_array_type (type)\n-\t  && TYPE_CODE (type) != TYPE_CODE_PTR))\n+\t  && type->code () != TYPE_CODE_PTR))\n     {\n       ada_val_print_gnat_array (val, stream, recurse, options);\n       return;\n@@ -1069,7 +1069,7 @@ ada_value_print_1 (struct value *val, struct ui_file *stream, int recurse,\n       deprecated_set_value_type (val, type);\n     }\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     default:\n       common_val_print (val, stream, recurse, options,\n@@ -1145,12 +1145,12 @@ ada_value_print (struct value *val0, struct ui_file *stream,\n   struct value_print_options opts;\n \n   /* If it is a pointer, indicate what it points to.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     {\n       /* Hack:  don't print (char *) for char strings.  Their\n          type is indicated by the quoted string anyway.  */\n       if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) != sizeof (char)\n-\t  || TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_INT \n+\t  || TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_INT\n \t  || TYPE_UNSIGNED (TYPE_TARGET_TYPE (type)))\n \t{\n \t  fprintf_filtered (stream, \"(\");\n@@ -1163,7 +1163,7 @@ ada_value_print (struct value *val0, struct ui_file *stream,\n       /* We do not print the type description unless TYPE is an array\n \t access type (this is encoded by the compiler as a typedef to\n \t a fat pointer - hence the check against TYPE_CODE_TYPEDEF).  */\n-      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+      if (type->code () == TYPE_CODE_TYPEDEF)\n         {\n \t  fprintf_filtered (stream, \"(\");\n \t  type_print (type, \"\", stream, -1);"
    },
    {
      "sha": "98dc9d199008b39235f16d7314cde2982b3c825a",
      "filename": "gdb/ada-varobj.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ada-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-varobj.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -132,11 +132,11 @@ ada_varobj_ind (struct value *parent_value,\n \t ada_get_decoded_value would have transformed our parent_type\n \t into a simple array pointer type.  */\n       gdb_assert (parent_value == NULL);\n-      gdb_assert (TYPE_CODE (parent_type) == TYPE_CODE_TYPEDEF);\n+      gdb_assert (parent_type->code () == TYPE_CODE_TYPEDEF);\n \n       /* Decode parent_type by the equivalent pointer to (decoded)\n \t array.  */\n-      while (TYPE_CODE (parent_type) == TYPE_CODE_TYPEDEF)\n+      while (parent_type->code () == TYPE_CODE_TYPEDEF)\n \tparent_type = TYPE_TARGET_TYPE (parent_type);\n       parent_type = ada_coerce_to_simple_array_type (parent_type);\n       parent_type = lookup_pointer_type (parent_type);\n@@ -206,9 +206,9 @@ ada_varobj_adjust_for_child_access (struct value **value,\n       one child (the struct), their children are the components of\n       the struct/union type.  We handle this situation by dereferencing\n       the (value, type) couple.  */\n-  if (TYPE_CODE (*type) == TYPE_CODE_PTR\n-      && (TYPE_CODE (TYPE_TARGET_TYPE (*type)) == TYPE_CODE_STRUCT\n-          || TYPE_CODE (TYPE_TARGET_TYPE (*type)) == TYPE_CODE_UNION)\n+  if ((*type)->code () == TYPE_CODE_PTR\n+      && (TYPE_TARGET_TYPE (*type)->code () == TYPE_CODE_STRUCT\n+          || TYPE_TARGET_TYPE (*type)->code () == TYPE_CODE_UNION)\n       && !ada_is_array_descriptor_type (TYPE_TARGET_TYPE (*type))\n       && !ada_is_constrained_packed_array_type (TYPE_TARGET_TYPE (*type)))\n     ada_varobj_ind (*value, *type, value, type);\n@@ -270,8 +270,8 @@ ada_varobj_get_struct_number_of_children (struct value *parent_value,\n   int n_children = 0;\n   int i;\n \n-  gdb_assert (TYPE_CODE (parent_type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (parent_type) == TYPE_CODE_UNION);\n+  gdb_assert (parent_type->code () == TYPE_CODE_STRUCT\n+\t      || parent_type->code () == TYPE_CODE_UNION);\n \n   for (i = 0; i < TYPE_NFIELDS (parent_type); i++)\n     {\n@@ -329,8 +329,8 @@ ada_varobj_get_ptr_number_of_children (struct value *parent_value,\n \n   /* Pointer to functions and to void do not have a child, since\n      you cannot print what they point to.  */\n-  if (TYPE_CODE (child_type) == TYPE_CODE_FUNC\n-      || TYPE_CODE (child_type) == TYPE_CODE_VOID)\n+  if (child_type->code () == TYPE_CODE_FUNC\n+      || child_type->code () == TYPE_CODE_VOID)\n     return 0;\n \n   /* All other types have 1 child.  */\n@@ -353,16 +353,16 @@ ada_varobj_get_number_of_children (struct value *parent_value,\n   if (ada_is_access_to_unconstrained_array (parent_type))\n     return 1;\n \n-  if (TYPE_CODE (parent_type) == TYPE_CODE_ARRAY)\n+  if (parent_type->code () == TYPE_CODE_ARRAY)\n     return ada_varobj_get_array_number_of_children (parent_value,\n \t\t\t\t\t\t    parent_type);\n \n-  if (TYPE_CODE (parent_type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (parent_type) == TYPE_CODE_UNION)\n+  if (parent_type->code () == TYPE_CODE_STRUCT\n+      || parent_type->code () == TYPE_CODE_UNION)\n     return ada_varobj_get_struct_number_of_children (parent_value,\n \t\t\t\t\t\t     parent_type);\n \n-  if (TYPE_CODE (parent_type) == TYPE_CODE_PTR)\n+  if (parent_type->code () == TYPE_CODE_PTR)\n     return ada_varobj_get_ptr_number_of_children (parent_value,\n \t\t\t\t\t\t  parent_type);\n \n@@ -418,8 +418,8 @@ ada_varobj_describe_struct_child (struct value *parent_value,\n   int fieldno;\n   int childno = 0;\n \n-  gdb_assert (TYPE_CODE (parent_type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (parent_type) == TYPE_CODE_UNION);\n+  gdb_assert (parent_type->code () == TYPE_CODE_STRUCT\n+\t      || parent_type->code () == TYPE_CODE_UNION);\n \n   for (fieldno = 0; fieldno < TYPE_NFIELDS (parent_type); fieldno++)\n     {\n@@ -587,7 +587,7 @@ ada_varobj_describe_simple_array_child (struct value *parent_value,\n   struct type *index_type;\n   int real_index;\n \n-  gdb_assert (TYPE_CODE (parent_type) == TYPE_CODE_ARRAY);\n+  gdb_assert (parent_type->code () == TYPE_CODE_ARRAY);\n \n   index_type = TYPE_INDEX_TYPE (parent_type);\n   real_index = child_index + ada_discrete_type_low_bound (index_type);\n@@ -627,11 +627,11 @@ ada_varobj_describe_simple_array_child (struct value *parent_value,\n       std::string decoded;\n \n       /* If the index type is a range type, find the base type.  */\n-      while (TYPE_CODE (index_type) == TYPE_CODE_RANGE)\n+      while (index_type->code () == TYPE_CODE_RANGE)\n \tindex_type = TYPE_TARGET_TYPE (index_type);\n \n-      if (TYPE_CODE (index_type) == TYPE_CODE_ENUM\n-\t  || TYPE_CODE (index_type) == TYPE_CODE_BOOL)\n+      if (index_type->code () == TYPE_CODE_ENUM\n+\t  || index_type->code () == TYPE_CODE_BOOL)\n \t{\n \t  index_type_name = ada_type_name (index_type);\n \t  if (index_type_name)\n@@ -693,7 +693,7 @@ ada_varobj_describe_child (struct value *parent_value,\n       return;\n     }\n \n-  if (TYPE_CODE (parent_type) == TYPE_CODE_ARRAY)\n+  if (parent_type->code () == TYPE_CODE_ARRAY)\n     {\n       ada_varobj_describe_simple_array_child\n \t(parent_value, parent_type, parent_name, parent_path_expr,\n@@ -702,8 +702,8 @@ ada_varobj_describe_child (struct value *parent_value,\n       return;\n     }\n \n-  if (TYPE_CODE (parent_type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (parent_type) == TYPE_CODE_UNION)\n+  if (parent_type->code () == TYPE_CODE_STRUCT\n+      || parent_type->code () == TYPE_CODE_UNION)\n     {\n       ada_varobj_describe_struct_child (parent_value, parent_type,\n \t\t\t\t\tparent_name, parent_path_expr,\n@@ -713,7 +713,7 @@ ada_varobj_describe_child (struct value *parent_value,\n       return;\n     }\n \n-  if (TYPE_CODE (parent_type) == TYPE_CODE_PTR)\n+  if (parent_type->code () == TYPE_CODE_PTR)\n     {\n       ada_varobj_describe_ptr_child (parent_value, parent_type,\n \t\t\t\t     parent_name, parent_path_expr,\n@@ -856,7 +856,7 @@ ada_varobj_get_value_of_variable (struct value *value,\n {\n   ada_varobj_decode_var (&value, &type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n@@ -939,7 +939,7 @@ ada_value_is_changeable_p (const struct varobj *var)\n   struct type *type = (var->value != nullptr\n \t\t       ? value_type (var->value.get ()) : var->type);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_REF)\n+  if (type->code () == TYPE_CODE_REF)\n     type = TYPE_TARGET_TYPE (type);\n \n   if (ada_is_access_to_unconstrained_array (type))"
    },
    {
      "sha": "377d7b1ac1a3db90d78f846eddf506488a7fb3da",
      "filename": "gdb/alpha-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/alpha-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/alpha-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -327,7 +327,7 @@ alpha_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct type *arg_type = check_typedef (value_type (arg));\n \n       /* Cast argument to long if necessary as the compiler does it too.  */\n-      switch (TYPE_CODE (arg_type))\n+      switch (arg_type->code ())\n \t{\n \tcase TYPE_CODE_INT:\n \tcase TYPE_CODE_BOOL:\n@@ -478,7 +478,7 @@ alpha_extract_return_value (struct type *valtype, struct regcache *regcache,\n   gdb_byte raw_buffer[ALPHA_REGISTER_SIZE];\n   ULONGEST l;\n \n-  switch (TYPE_CODE (valtype))\n+  switch (valtype->code ())\n     {\n     case TYPE_CODE_FLT:\n       switch (TYPE_LENGTH (valtype))\n@@ -546,7 +546,7 @@ alpha_store_return_value (struct type *valtype, struct regcache *regcache,\n   gdb_byte raw_buffer[ALPHA_REGISTER_SIZE];\n   ULONGEST l;\n \n-  switch (TYPE_CODE (valtype))\n+  switch (valtype->code ())\n     {\n     case TYPE_CODE_FLT:\n       switch (TYPE_LENGTH (valtype))\n@@ -614,7 +614,7 @@ alpha_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t    struct type *type, struct regcache *regcache,\n \t\t    gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n \n   if ((code == TYPE_CODE_STRUCT\n        || code == TYPE_CODE_UNION"
    },
    {
      "sha": "9fa5d2b83df829e502832d518575fad7e36fda69",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -546,8 +546,8 @@ static void amd64_classify (struct type *type, enum amd64_reg_class theclass[2])\n static bool\n amd64_has_unaligned_fields (struct type *type)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION)\n     {\n       for (int i = 0; i < TYPE_NFIELDS (type); i++)\n \t{\n@@ -603,8 +603,8 @@ amd64_classify_aggregate_field (struct type *type, int i,\n   if (field_is_static (&TYPE_FIELD (type, i)) || bitsize == 0)\n     return;\n \n-  if (TYPE_CODE (subtype) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (subtype) == TYPE_CODE_UNION)\n+  if (subtype->code () == TYPE_CODE_STRUCT\n+      || subtype->code () == TYPE_CODE_UNION)\n     {\n       /* Each field of an object is classified recursively.  */\n       int j;\n@@ -667,7 +667,7 @@ amd64_classify_aggregate (struct type *type, enum amd64_reg_class theclass[2])\n         calculated according to the classes of the fields in the\n         eightbyte: */\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_ARRAY)\n     {\n       struct type *subtype = check_typedef (TYPE_TARGET_TYPE (type));\n \n@@ -681,8 +681,8 @@ amd64_classify_aggregate (struct type *type, enum amd64_reg_class theclass[2])\n       int i;\n \n       /* Structure or union.  */\n-      gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t\t  || TYPE_CODE (type) == TYPE_CODE_UNION);\n+      gdb_assert (type->code () == TYPE_CODE_STRUCT\n+\t\t  || type->code () == TYPE_CODE_UNION);\n \n       for (i = 0; i < TYPE_NFIELDS (type); i++)\n \tamd64_classify_aggregate_field (type, i, theclass, 0);\n@@ -708,7 +708,7 @@ amd64_classify_aggregate (struct type *type, enum amd64_reg_class theclass[2])\n static void\n amd64_classify (struct type *type, enum amd64_reg_class theclass[2])\n {\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n   int len = TYPE_LENGTH (type);\n \n   theclass[0] = theclass[1] = AMD64_NO_CLASS;"
    },
    {
      "sha": "487dfd45fc79250db041b1d92bb87b571e9a414c",
      "filename": "gdb/amd64-windows-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/amd64-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/amd64-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-windows-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -48,7 +48,7 @@ static int amd64_windows_dummy_call_integer_regs[] =\n static int\n amd64_windows_passed_by_integer_register (struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n       case TYPE_CODE_INT:\n       case TYPE_CODE_ENUM:\n@@ -76,8 +76,8 @@ amd64_windows_passed_by_integer_register (struct type *type)\n static int\n amd64_windows_passed_by_xmm_register (struct type *type)\n {\n-  return ((TYPE_CODE (type) == TYPE_CODE_FLT\n-\t   || TYPE_CODE (type) == TYPE_CODE_DECFLOAT)\n+  return ((type->code () == TYPE_CODE_FLT\n+\t   || type->code () == TYPE_CODE_DECFLOAT)\n           && (TYPE_LENGTH (type) == 4 || TYPE_LENGTH (type) == 8));\n }\n \n@@ -296,7 +296,7 @@ amd64_windows_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   /* See if our value is returned through a register.  If it is, then\n      store the associated register number in REGNUM.  */\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n       case TYPE_CODE_FLT:\n       case TYPE_CODE_DECFLOAT:"
    },
    {
      "sha": "7e6d29c334bb5b2e784fdd4dd5b6e79561f0868c",
      "filename": "gdb/arc-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/arc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/arc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -893,8 +893,8 @@ arc_return_value (struct gdbarch *gdbarch, struct value *function,\n      function passes a hidden first parameter to the callee (in R0).  That\n      parameter is the address at which the value being returned should be\n      stored.  Otherwise, the result is returned in registers.  */\n-  int is_struct_return = (TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-\t\t\t  || TYPE_CODE (valtype) == TYPE_CODE_UNION\n+  int is_struct_return = (valtype->code () == TYPE_CODE_STRUCT\n+\t\t\t  || valtype->code () == TYPE_CODE_UNION\n \t\t\t  || TYPE_LENGTH (valtype) > 2 * ARC_REGISTER_SIZE);\n \n   if (arc_debug)\n@@ -1916,7 +1916,7 @@ arc_tdesc_init (struct gdbarch_info info, const struct target_desc **tdesc,\n static ULONGEST\n arc_type_align (struct gdbarch *gdbarch, struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_FUNC:"
    },
    {
      "sha": "40bffbb2dd1b23855f7df51672f582f076d618d7",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 24,
      "deletions": 25,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -3306,7 +3306,7 @@ static ULONGEST\n arm_type_align (gdbarch *gdbarch, struct type *t)\n {\n   t = check_typedef (t);\n-  if (TYPE_CODE (t) == TYPE_CODE_ARRAY && TYPE_VECTOR (t))\n+  if (t->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (t))\n     {\n       /* Use the natural alignment for vector types (the same for\n \t scalar type), but the maximum alignment is 64-bit.  */\n@@ -3393,7 +3393,7 @@ arm_vfp_cprc_sub_candidate (struct type *t,\n \t\t\t    enum arm_vfp_cprc_base_type *base_type)\n {\n   t = check_typedef (t);\n-  switch (TYPE_CODE (t))\n+  switch (t->code ())\n     {\n     case TYPE_CODE_FLT:\n       switch (TYPE_LENGTH (t))\n@@ -3615,7 +3615,7 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   /* Determine the type of this function and whether the VFP ABI\n      applies.  */\n   ftype = check_typedef (value_type (function));\n-  if (TYPE_CODE (ftype) == TYPE_CODE_PTR)\n+  if (ftype->code () == TYPE_CODE_PTR)\n     ftype = check_typedef (TYPE_TARGET_TYPE (ftype));\n   use_vfp_abi = arm_vfp_abi_for_function (gdbarch, ftype);\n \n@@ -3660,7 +3660,7 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       arg_type = check_typedef (value_type (args[argnum]));\n       len = TYPE_LENGTH (arg_type);\n       target_type = TYPE_TARGET_TYPE (arg_type);\n-      typecode = TYPE_CODE (arg_type);\n+      typecode = arg_type->code ();\n       val = value_contents (args[argnum]);\n \n       align = type_align (arg_type);\n@@ -3758,7 +3758,7 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t the THUMB bit in it.  */\n       if (TYPE_CODE_PTR == typecode\n \t  && target_type != NULL\n-\t  && TYPE_CODE_FUNC == TYPE_CODE (check_typedef (target_type)))\n+\t  && TYPE_CODE_FUNC == check_typedef (target_type)->code ())\n \t{\n \t  CORE_ADDR regval = extract_unsigned_integer (val, len, byte_order);\n \t  if (arm_pc_is_thumb (gdbarch, regval))\n@@ -3990,7 +3990,7 @@ arm_register_type (struct gdbarch *gdbarch, int regnum)\n       struct type *t = tdesc_register_type (gdbarch, regnum);\n \n       if (regnum >= ARM_D0_REGNUM && regnum < ARM_D0_REGNUM + 32\n-\t  && TYPE_CODE (t) == TYPE_CODE_FLT\n+\t  && t->code () == TYPE_CODE_FLT\n \t  && gdbarch_tdep (gdbarch)->have_neon)\n \treturn arm_neon_double_type (gdbarch);\n       else\n@@ -7805,7 +7805,7 @@ arm_extract_return_value (struct type *type, struct regcache *regs,\n   struct gdbarch *gdbarch = regs->arch ();\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n-  if (TYPE_CODE_FLT == TYPE_CODE (type))\n+  if (TYPE_CODE_FLT == type->code ())\n     {\n       switch (gdbarch_tdep (gdbarch)->fp_model)\n \t{\n@@ -7840,12 +7840,12 @@ arm_extract_return_value (struct type *type, struct regcache *regs,\n \t  break;\n \t}\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_INT\n-\t   || TYPE_CODE (type) == TYPE_CODE_CHAR\n-\t   || TYPE_CODE (type) == TYPE_CODE_BOOL\n-\t   || TYPE_CODE (type) == TYPE_CODE_PTR\n+  else if (type->code () == TYPE_CODE_INT\n+\t   || type->code () == TYPE_CODE_CHAR\n+\t   || type->code () == TYPE_CODE_BOOL\n+\t   || type->code () == TYPE_CODE_PTR\n \t   || TYPE_IS_REFERENCE (type)\n-\t   || TYPE_CODE (type) == TYPE_CODE_ENUM)\n+\t   || type->code () == TYPE_CODE_ENUM)\n     {\n       /* If the type is a plain integer, then the access is\n \t straight-forward.  Otherwise we have to play around a bit\n@@ -7901,7 +7901,7 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n \n   /* Simple, non-aggregate types (ie not including vectors and\n      complex) are always returned in a register (or registers).  */\n-  code = TYPE_CODE (type);\n+  code = type->code ();\n   if (TYPE_CODE_STRUCT != code && TYPE_CODE_UNION != code\n       && TYPE_CODE_ARRAY != code && TYPE_CODE_COMPLEX != code)\n     return 0;\n@@ -7975,8 +7975,7 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n \t      enum type_code field_type_code;\n \n \t      field_type_code\n-\t\t= TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type,\n-\t\t\t\t\t\t\t     i)));\n+\t\t= check_typedef (TYPE_FIELD_TYPE (type, i))->code ();\n \n \t      /* Is it a floating point type field?  */\n \t      if (field_type_code == TYPE_CODE_FLT)\n@@ -8014,7 +8013,7 @@ arm_store_return_value (struct type *type, struct regcache *regs,\n   struct gdbarch *gdbarch = regs->arch ();\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (type->code () == TYPE_CODE_FLT)\n     {\n       gdb_byte buf[ARM_FP_REGISTER_SIZE];\n \n@@ -8044,12 +8043,12 @@ arm_store_return_value (struct type *type, struct regcache *regs,\n \t  break;\n \t}\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_INT\n-\t   || TYPE_CODE (type) == TYPE_CODE_CHAR\n-\t   || TYPE_CODE (type) == TYPE_CODE_BOOL\n-\t   || TYPE_CODE (type) == TYPE_CODE_PTR\n+  else if (type->code () == TYPE_CODE_INT\n+\t   || type->code () == TYPE_CODE_CHAR\n+\t   || type->code () == TYPE_CODE_BOOL\n+\t   || type->code () == TYPE_CODE_PTR\n \t   || TYPE_IS_REFERENCE (type)\n-\t   || TYPE_CODE (type) == TYPE_CODE_ENUM)\n+\t   || type->code () == TYPE_CODE_ENUM)\n     {\n       if (TYPE_LENGTH (type) <= 4)\n \t{\n@@ -8145,15 +8144,15 @@ arm_return_value (struct gdbarch *gdbarch, struct value *function,\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n \n-  if (TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (valtype) == TYPE_CODE_UNION\n-      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY)\n+  if (valtype->code () == TYPE_CODE_STRUCT\n+      || valtype->code () == TYPE_CODE_UNION\n+      || valtype->code () == TYPE_CODE_ARRAY)\n     {\n       if (tdep->struct_return == pcc_struct_return\n \t  || arm_return_in_memory (gdbarch, valtype))\n \treturn RETURN_VALUE_STRUCT_CONVENTION;\n     }\n-  else if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX)\n+  else if (valtype->code () == TYPE_CODE_COMPLEX)\n     {\n       if (arm_return_in_memory (gdbarch, valtype))\n \treturn RETURN_VALUE_STRUCT_CONVENTION;"
    },
    {
      "sha": "fd602e35e50da18e81a9ea3c69da4b1aab972d05",
      "filename": "gdb/avr-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/avr-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/avr-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/avr-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -314,8 +314,8 @@ avr_address_to_pointer (struct gdbarch *gdbarch,\n \t\t\t      avr_convert_iaddr_to_raw (addr));\n     }\n   /* Is it a code address?  */\n-  else if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC\n-\t   || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD)\n+  else if (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC\n+\t   || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_METHOD)\n     {\n       /* A code pointer is word (16 bits) addressed.  We shift the address down\n \t by 1 bit to convert it to a pointer.  */\n@@ -345,8 +345,8 @@ avr_pointer_to_address (struct gdbarch *gdbarch,\n       return avr_make_iaddr (addr);\n     }\n   /* Is it a code address?  */\n-  else if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC\n-\t   || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD\n+  else if (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC\n+\t   || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_METHOD\n \t   || TYPE_CODE_SPACE (TYPE_TARGET_TYPE (type)))\n     {\n       /* A code pointer is word (16 bits) addressed so we shift it up\n@@ -935,9 +935,9 @@ avr_return_value (struct gdbarch *gdbarch, struct value *function,\n      register holds the LSB.  */\n   int lsb_reg;\n \n-  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-       || TYPE_CODE (valtype) == TYPE_CODE_UNION\n-       || TYPE_CODE (valtype) == TYPE_CODE_ARRAY)\n+  if ((valtype->code () == TYPE_CODE_STRUCT\n+       || valtype->code () == TYPE_CODE_UNION\n+       || valtype->code () == TYPE_CODE_ARRAY)\n       && TYPE_LENGTH (valtype) > 8)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n "
    },
    {
      "sha": "57ba2107973beaaa1c0f2b6959cb3a6e40161a4f",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 37,
      "deletions": 37,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -362,7 +362,7 @@ gen_traced_pop (struct agent_expr *ax, struct axs_value *value)\n {\n   int string_trace = 0;\n   if (ax->trace_string\n-      && TYPE_CODE (value->type) == TYPE_CODE_PTR\n+      && value->type->code () == TYPE_CODE_PTR\n       && c_textual_element_type (check_typedef (TYPE_TARGET_TYPE (value->type)),\n \t\t\t\t 's'))\n     string_trace = 1;\n@@ -429,8 +429,8 @@ gen_traced_pop (struct agent_expr *ax, struct axs_value *value)\n \n   /* To trace C++ classes with static fields stored elsewhere.  */\n   if (ax->tracing\n-      && (TYPE_CODE (value->type) == TYPE_CODE_STRUCT\n-\t  || TYPE_CODE (value->type) == TYPE_CODE_UNION))\n+      && (value->type->code () == TYPE_CODE_STRUCT\n+\t  || value->type->code () == TYPE_CODE_UNION))\n     gen_trace_static_fields (ax, value->type);\n }\n \f\n@@ -474,10 +474,10 @@ gen_fetch (struct agent_expr *ax, struct type *type)\n       ax_trace_quick (ax, TYPE_LENGTH (type));\n     }\n \n-  if (TYPE_CODE (type) == TYPE_CODE_RANGE)\n+  if (type->code () == TYPE_CODE_RANGE)\n     type = TYPE_TARGET_TYPE (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_REF:\n@@ -775,10 +775,10 @@ require_rvalue (struct agent_expr *ax, struct axs_value *value)\n   /* Only deal with scalars, structs and such may be too large\n      to fit in a stack entry.  */\n   value->type = check_typedef (value->type);\n-  if (TYPE_CODE (value->type) == TYPE_CODE_ARRAY\n-      || TYPE_CODE (value->type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (value->type) == TYPE_CODE_UNION\n-      || TYPE_CODE (value->type) == TYPE_CODE_FUNC)\n+  if (value->type->code () == TYPE_CODE_ARRAY\n+      || value->type->code () == TYPE_CODE_STRUCT\n+      || value->type->code () == TYPE_CODE_UNION\n+      || value->type->code () == TYPE_CODE_FUNC)\n     error (_(\"Value not scalar: cannot be an rvalue.\"));\n \n   switch (value->kind)\n@@ -831,7 +831,7 @@ gen_usual_unary (struct agent_expr *ax, struct axs_value *value)\n      the stack.  Should we tweak the type?  */\n \n   /* Some types require special handling.  */\n-  switch (TYPE_CODE (value->type))\n+  switch (value->type->code ())\n     {\n       /* Functions get converted to a pointer to the function.  */\n     case TYPE_CODE_FUNC:\n@@ -943,8 +943,8 @@ gen_usual_arithmetic (struct agent_expr *ax, struct axs_value *value1,\n \t\t      struct axs_value *value2)\n {\n   /* Do the usual binary conversions.  */\n-  if (TYPE_CODE (value1->type) == TYPE_CODE_INT\n-      && TYPE_CODE (value2->type) == TYPE_CODE_INT)\n+  if (value1->type->code () == TYPE_CODE_INT\n+      && value2->type->code () == TYPE_CODE_INT)\n     {\n       /* The ANSI integral promotions seem to work this way: Order the\n          integer types by size, and then by signedness: an n-bit\n@@ -1003,7 +1003,7 @@ gen_cast (struct agent_expr *ax, struct axs_value *value, struct type *type)\n   /* Dereference typedefs.  */\n   type = check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_REF:\n@@ -1070,7 +1070,7 @@ gen_ptradd (struct agent_expr *ax, struct axs_value *value,\n \t    struct axs_value *value1, struct axs_value *value2)\n {\n   gdb_assert (pointer_type (value1->type));\n-  gdb_assert (TYPE_CODE (value2->type) == TYPE_CODE_INT);\n+  gdb_assert (value2->type->code () == TYPE_CODE_INT);\n \n   gen_scale (ax, aop_mul, value1->type);\n   ax_simple (ax, aop_add);\n@@ -1086,7 +1086,7 @@ gen_ptrsub (struct agent_expr *ax, struct axs_value *value,\n \t    struct axs_value *value1, struct axs_value *value2)\n {\n   gdb_assert (pointer_type (value1->type));\n-  gdb_assert (TYPE_CODE (value2->type) == TYPE_CODE_INT);\n+  gdb_assert (value2->type->code () == TYPE_CODE_INT);\n \n   gen_scale (ax, aop_mul, value1->type);\n   ax_simple (ax, aop_sub);\n@@ -1158,8 +1158,8 @@ gen_binop (struct agent_expr *ax, struct axs_value *value,\n \t   int may_carry, const char *name)\n {\n   /* We only handle INT op INT.  */\n-  if ((TYPE_CODE (value1->type) != TYPE_CODE_INT)\n-      || (TYPE_CODE (value2->type) != TYPE_CODE_INT))\n+  if ((value1->type->code () != TYPE_CODE_INT)\n+      || (value2->type->code () != TYPE_CODE_INT))\n     error (_(\"Invalid combination of types in %s.\"), name);\n \n   ax_simple (ax,\n@@ -1175,8 +1175,8 @@ static void\n gen_logical_not (struct agent_expr *ax, struct axs_value *value,\n \t\t struct type *result_type)\n {\n-  if (TYPE_CODE (value->type) != TYPE_CODE_INT\n-      && TYPE_CODE (value->type) != TYPE_CODE_PTR)\n+  if (value->type->code () != TYPE_CODE_INT\n+      && value->type->code () != TYPE_CODE_PTR)\n     error (_(\"Invalid type of operand to `!'.\"));\n \n   ax_simple (ax, aop_log_not);\n@@ -1187,7 +1187,7 @@ gen_logical_not (struct agent_expr *ax, struct axs_value *value,\n static void\n gen_complement (struct agent_expr *ax, struct axs_value *value)\n {\n-  if (TYPE_CODE (value->type) != TYPE_CODE_INT)\n+  if (value->type->code () != TYPE_CODE_INT)\n     error (_(\"Invalid type of operand to `~'.\"));\n \n   ax_simple (ax, aop_bit_not);\n@@ -1214,9 +1214,9 @@ gen_deref (struct axs_value *value)\n      T\" to \"T\", and mark the value as an lvalue in memory.  Leave it\n      to the consumer to actually dereference it.  */\n   value->type = check_typedef (TYPE_TARGET_TYPE (value->type));\n-  if (TYPE_CODE (value->type) == TYPE_CODE_VOID)\n+  if (value->type->code () == TYPE_CODE_VOID)\n     error (_(\"Attempt to dereference a generic pointer.\"));\n-  value->kind = ((TYPE_CODE (value->type) == TYPE_CODE_FUNC)\n+  value->kind = ((value->type->code () == TYPE_CODE_FUNC)\n \t\t ? axs_rvalue : axs_lvalue_memory);\n }\n \n@@ -1228,7 +1228,7 @@ gen_address_of (struct axs_value *value)\n   /* Special case for taking the address of a function.  The ANSI\n      standard describes this as a special case, too, so this\n      arrangement is not without motivation.  */\n-  if (TYPE_CODE (value->type) == TYPE_CODE_FUNC)\n+  if (value->type->code () == TYPE_CODE_FUNC)\n     /* The value's already an rvalue on the stack, so we just need to\n        change the type.  */\n     value->type = lookup_pointer_type (value->type);\n@@ -1518,8 +1518,8 @@ gen_struct_ref (struct agent_expr *ax, struct axs_value *value,\n   type = check_typedef (value->type);\n \n   /* This must yield a structure or a union.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (type) != TYPE_CODE_UNION)\n+  if (type->code () != TYPE_CODE_STRUCT\n+      && type->code () != TYPE_CODE_UNION)\n     error (_(\"The left operand of `%s' is not a %s.\"),\n \t   operator_name, operand_name);\n \n@@ -1583,8 +1583,8 @@ gen_struct_elt_for_reference (struct agent_expr *ax, struct axs_value *value,\n   struct type *t = type;\n   int i;\n \n-  if (TYPE_CODE (t) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (t) != TYPE_CODE_UNION)\n+  if (t->code () != TYPE_CODE_STRUCT\n+      && t->code () != TYPE_CODE_UNION)\n     internal_error (__FILE__, __LINE__,\n \t\t    _(\"non-aggregate type to gen_struct_elt_for_reference\"));\n \n@@ -1668,7 +1668,7 @@ static int\n gen_aggregate_elt_ref (struct agent_expr *ax, struct axs_value *value,\n \t\t       struct type *type, char *field)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n@@ -1716,7 +1716,7 @@ gen_repeat (struct expression *exp, union exp_element **pc,\n     if (!v)\n       error (_(\"Right operand of `@' must be a \"\n \t       \"constant, in agent expressions.\"));\n-    if (TYPE_CODE (value_type (v)) != TYPE_CODE_INT)\n+    if (value_type (v)->code () != TYPE_CODE_INT)\n       error (_(\"Right operand of `@' must be an integer.\"));\n     length = value_as_long (v);\n     if (length <= 0)\n@@ -1788,7 +1788,7 @@ gen_expr_for_cast (struct expression *exp, union exp_element **pc,\n \t}\n       else\n \tgen_msym_var_ref (ax, value, (*pc)[2].msymbol, (*pc)[1].objfile);\n-      if (TYPE_CODE (value->type) == TYPE_CODE_ERROR)\n+      if (value->type->code () == TYPE_CODE_ERROR)\n \tvalue->type = to_type;\n       (*pc) += 4;\n     }\n@@ -2010,7 +2010,7 @@ gen_expr (struct expression *exp, union exp_element **pc,\n \terror (_(\"`%s' has been optimized out, cannot use\"),\n \t       (*pc)[2].symbol->print_name ());\n \n-      if (TYPE_CODE (value->type) == TYPE_CODE_ERROR)\n+      if (value->type->code () == TYPE_CODE_ERROR)\n \terror_unknown_type ((*pc)[2].symbol->print_name ());\n \n       (*pc) += 4;\n@@ -2019,7 +2019,7 @@ gen_expr (struct expression *exp, union exp_element **pc,\n     case OP_VAR_MSYM_VALUE:\n       gen_msym_var_ref (ax, value, (*pc)[2].msymbol, (*pc)[1].objfile);\n \n-      if (TYPE_CODE (value->type) == TYPE_CODE_ERROR)\n+      if (value->type->code () == TYPE_CODE_ERROR)\n \terror_unknown_type ((*pc)[2].msymbol->linkage_name ());\n \n       (*pc) += 4;\n@@ -2289,23 +2289,23 @@ gen_expr_binop_rest (struct expression *exp,\n   switch (op)\n     {\n     case BINOP_ADD:\n-      if (TYPE_CODE (value1->type) == TYPE_CODE_INT\n+      if (value1->type->code () == TYPE_CODE_INT\n \t  && pointer_type (value2->type))\n \t{\n \t  /* Swap the values and proceed normally.  */\n \t  ax_simple (ax, aop_swap);\n \t  gen_ptradd (ax, value, value2, value1);\n \t}\n       else if (pointer_type (value1->type)\n-\t       && TYPE_CODE (value2->type) == TYPE_CODE_INT)\n+\t       && value2->type->code () == TYPE_CODE_INT)\n \tgen_ptradd (ax, value, value1, value2);\n       else\n \tgen_binop (ax, value, value1, value2,\n \t\t   aop_add, aop_add, 1, \"addition\");\n       break;\n     case BINOP_SUB:\n       if (pointer_type (value1->type)\n-\t  && TYPE_CODE (value2->type) == TYPE_CODE_INT)\n+\t  && value2->type->code () == TYPE_CODE_INT)\n \tgen_ptrsub (ax,value, value1, value2);\n       else if (pointer_type (value1->type)\n \t       && pointer_type (value2->type))\n@@ -2351,8 +2351,8 @@ gen_expr_binop_rest (struct expression *exp,\n \t       an array or pointer type (like a plain int variable for\n \t       example), then report this as an error.  */\n \t    type = check_typedef (value1->type);\n-\t    if (TYPE_CODE (type) != TYPE_CODE_ARRAY\n-\t\t&& TYPE_CODE (type) != TYPE_CODE_PTR)\n+\t    if (type->code () != TYPE_CODE_ARRAY\n+\t\t&& type->code () != TYPE_CODE_PTR)\n \t      {\n \t\tif (TYPE_NAME (type))\n \t\t  error (_(\"cannot subscript something of type `%s'\"),"
    },
    {
      "sha": "05c26bc2c2a208cbd97f4d7e141515705d790735",
      "filename": "gdb/blockframe.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/blockframe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/blockframe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/blockframe.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -429,11 +429,11 @@ find_gnu_ifunc_target_type (CORE_ADDR resolver_funaddr)\n \n       /* If we found a pointer to function, then the resolved type\n \t is the type of the pointed-to function.  */\n-      if (TYPE_CODE (resolver_ret_type) == TYPE_CODE_PTR)\n+      if (resolver_ret_type->code () == TYPE_CODE_PTR)\n \t{\n \t  struct type *resolved_type\n \t    = TYPE_TARGET_TYPE (resolver_ret_type);\n-\t  if (TYPE_CODE (check_typedef (resolved_type)) == TYPE_CODE_FUNC)\n+\t  if (check_typedef (resolved_type)->code () == TYPE_CODE_FUNC)\n \t    return resolved_type;\n \t}\n     }"
    },
    {
      "sha": "480f095876985b4f680a149dc8c7f7df3fcb4d1c",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1806,8 +1806,8 @@ update_watchpoint (struct watchpoint *b, int reparse)\n \t\t for it explicitly, never if they just happen to\n \t\t appear in the middle of some value chain.  */\n \t      if (v == result\n-\t\t  || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT\n-\t\t      && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))\n+\t\t  || (vtype->code () != TYPE_CODE_STRUCT\n+\t\t      && vtype->code () != TYPE_CODE_ARRAY))\n \t\t{\n \t\t  CORE_ADDR addr;\n \t\t  enum target_hw_bp_type type;\n@@ -10806,8 +10806,8 @@ can_use_hardware_watchpoint (const std::vector<value_ref_ptr> &vals)\n \t\t explicitly, never if they just happen to appear in a\n \t\t middle of some value chain.  */\n \t      if (v == head\n-\t\t  || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT\n-\t\t      && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))\n+\t\t  || (vtype->code () != TYPE_CODE_STRUCT\n+\t\t      && vtype->code () != TYPE_CODE_ARRAY))\n \t\t{\n \t\t  CORE_ADDR vaddr = value_address (v);\n \t\t  int len;"
    },
    {
      "sha": "e737c667cf429bea0045714a327f232636d0a96f",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1852,10 +1852,10 @@ typename_stoken (const char *type)\n static int\n type_aggregate_p (struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t  || TYPE_CODE (type) == TYPE_CODE_UNION\n-\t  || TYPE_CODE (type) == TYPE_CODE_NAMESPACE\n-\t  || (TYPE_CODE (type) == TYPE_CODE_ENUM\n+  return (type->code () == TYPE_CODE_STRUCT\n+\t  || type->code () == TYPE_CODE_UNION\n+\t  || type->code () == TYPE_CODE_NAMESPACE\n+\t  || (type->code () == TYPE_CODE_ENUM\n \t      && TYPE_DECLARED_CLASS (type)));\n }\n \n@@ -1870,7 +1870,7 @@ check_parameter_typelist (std::vector<struct type *> *params)\n   for (ix = 0; ix < params->size (); ++ix)\n     {\n       type = (*params)[ix];\n-      if (type != NULL && TYPE_CODE (check_typedef (type)) == TYPE_CODE_VOID)\n+      if (type != NULL && check_typedef (type)->code () == TYPE_CODE_VOID)\n \t{\n \t  if (ix == 0)\n \t    {"
    },
    {
      "sha": "9d4064f152cba238f5a9db0d6bc73254eb91d57e",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -86,7 +86,7 @@ classify_type (struct type *elttype, struct gdbarch *gdbarch,\n     {\n       const char *name = TYPE_NAME (elttype);\n \n-      if (TYPE_CODE (elttype) == TYPE_CODE_CHAR || !name)\n+      if (elttype->code () == TYPE_CODE_CHAR || !name)\n \t{\n \t  result = C_CHAR;\n \t  goto done;\n@@ -110,7 +110,7 @@ classify_type (struct type *elttype, struct gdbarch *gdbarch,\n \t  goto done;\n \t}\n \n-      if (TYPE_CODE (elttype) != TYPE_CODE_TYPEDEF)\n+      if (elttype->code () != TYPE_CODE_TYPEDEF)\n \tbreak;\n \n       /* Call for side effects.  */\n@@ -250,12 +250,12 @@ c_get_string (struct value *value, gdb::unique_xmalloc_ptr<gdb_byte> *buffer,\n   if (element_type == NULL)\n     goto error;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_ARRAY)\n     {\n       /* If we know the size of the array, we can use it as a limit on\n \t the number of characters to be fetched.  */\n       if (TYPE_NFIELDS (type) == 1\n-\t  && TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_RANGE)\n+\t  && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_RANGE)\n \t{\n \t  LONGEST low_bound, high_bound;\n \n@@ -266,7 +266,7 @@ c_get_string (struct value *value, gdb::unique_xmalloc_ptr<gdb_byte> *buffer,\n       else\n \tfetchlimit = UINT_MAX;\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  else if (type->code () == TYPE_CODE_PTR)\n     fetchlimit = UINT_MAX;\n   else\n     /* We work only with arrays and pointers.  */\n@@ -292,7 +292,7 @@ c_get_string (struct value *value, gdb::unique_xmalloc_ptr<gdb_byte> *buffer,\n      avoids running off the end of the value's contents.  */\n   if ((VALUE_LVAL (value) == not_lval\n        || VALUE_LVAL (value) == lval_internalvar\n-       || TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+       || type->code () == TYPE_CODE_ARRAY)\n       && fetchlimit != UINT_MAX\n       && (*length < 0 || *length <= fetchlimit))\n     {\n@@ -322,7 +322,7 @@ c_get_string (struct value *value, gdb::unique_xmalloc_ptr<gdb_byte> *buffer,\n \t c_style_arrays is false, so we handle that specially\n \t here.  */\n       CORE_ADDR addr;\n-      if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+      if (type->code () == TYPE_CODE_ARRAY)\n \t{\n \t  if (VALUE_LVAL (value) != lval_memory)\n \t    error (_(\"Attempt to take address of value \"\n@@ -629,13 +629,13 @@ evaluate_subexp_c (struct type *expect_type, struct expression *exp,\n \t/* If the caller expects an array of some integral type,\n \t   satisfy them.  If something odder is expected, rely on the\n \t   caller to cast.  */\n-\tif (expect_type && TYPE_CODE (expect_type) == TYPE_CODE_ARRAY)\n+\tif (expect_type && expect_type->code () == TYPE_CODE_ARRAY)\n \t  {\n \t    struct type *element_type\n \t      = check_typedef (TYPE_TARGET_TYPE (expect_type));\n \n-\t    if (TYPE_CODE (element_type) == TYPE_CODE_INT\n-\t\t|| TYPE_CODE (element_type) == TYPE_CODE_CHAR)\n+\t    if (element_type->code () == TYPE_CODE_INT\n+\t\t|| element_type->code () == TYPE_CODE_CHAR)\n \t      {\n \t\ttype = element_type;\n \t\tsatisfy_expected = 1;\n@@ -742,13 +742,13 @@ bool\n c_is_string_type_p (struct type *type)\n {\n   type = check_typedef (type);\n-  while (TYPE_CODE (type) == TYPE_CODE_REF)\n+  while (type->code () == TYPE_CODE_REF)\n     {\n       type = TYPE_TARGET_TYPE (type);\n       type = check_typedef (type);\n     }\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       {"
    },
    {
      "sha": "356e605d0a469881df6dc439f366c1be3331aa9f",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -116,7 +116,7 @@ c_print_type_1 (struct type *type,\n     type = check_typedef (type);\n \n   local_name = typedef_hash_table::find_typedef (flags, type);\n-  code = TYPE_CODE (type);\n+  code = type->code ();\n   if (local_name != NULL)\n     {\n       fputs_filtered (local_name, stream);\n@@ -209,7 +209,7 @@ c_print_typedef (struct type *type,\n   if (TYPE_NAME ((SYMBOL_TYPE (new_symbol))) == 0\n       || strcmp (TYPE_NAME ((SYMBOL_TYPE (new_symbol))),\n \t\t new_symbol->linkage_name ()) != 0\n-      || TYPE_CODE (SYMBOL_TYPE (new_symbol)) == TYPE_CODE_TYPEDEF)\n+      || SYMBOL_TYPE (new_symbol)->code () == TYPE_CODE_TYPEDEF)\n     fprintf_filtered (stream, \" %s\", new_symbol->print_name ());\n   fprintf_filtered (stream, \";\");\n }\n@@ -327,7 +327,7 @@ cp_type_print_method_args (struct type *mtype, const char *prefix,\n       struct type *domain;\n \n       gdb_assert (nargs > 0);\n-      gdb_assert (TYPE_CODE (args[0].type) == TYPE_CODE_PTR);\n+      gdb_assert (args[0].type->code () == TYPE_CODE_PTR);\n       domain = TYPE_TARGET_TYPE (args[0].type);\n \n       if (TYPE_CONST (domain))\n@@ -378,7 +378,7 @@ c_type_print_varspec_prefix (struct type *type,\n \n   QUIT;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n       c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),\n@@ -421,7 +421,7 @@ c_type_print_varspec_prefix (struct type *type,\n       c_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),\n \t\t\t\t   stream, show, 1, 0, language, flags,\n \t\t\t\t   podata);\n-      fprintf_filtered (stream, TYPE_CODE(type) == TYPE_CODE_REF ? \"&\" : \"&&\");\n+      fprintf_filtered (stream, type->code () == TYPE_CODE_REF ? \"&\" : \"&&\");\n       c_type_print_modifier (type, stream, 1, need_post_space, language);\n       break;\n \n@@ -767,7 +767,7 @@ c_type_print_varspec_suffix (struct type *type,\n \n   QUIT;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       {\n@@ -1056,7 +1056,7 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n     }\n \n   c_type_print_modifier (type, stream, 0, 1, language);\n-  if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if (type->code () == TYPE_CODE_UNION)\n     fprintf_filtered (stream, \"union \");\n   else if (TYPE_DECLARED_CLASS (type))\n     fprintf_filtered (stream, \"class \");\n@@ -1179,8 +1179,8 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \t  int newshow = show - 1;\n \n \t  if (!is_static && flags->print_offsets\n-\t      && (TYPE_CODE (TYPE_FIELD_TYPE (type, i)) == TYPE_CODE_STRUCT\n-\t\t  || TYPE_CODE (TYPE_FIELD_TYPE (type, i)) == TYPE_CODE_UNION))\n+\t      && (TYPE_FIELD_TYPE (type, i)->code () == TYPE_CODE_STRUCT\n+\t\t  || TYPE_FIELD_TYPE (type, i)->code () == TYPE_CODE_UNION))\n \t    {\n \t      /* If we're printing offsets and this field's type is\n \t\t either a struct or an union, then we're interested in\n@@ -1401,7 +1401,7 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \t      struct type *target = TYPE_TYPEDEF_FIELD_TYPE (type, i);\n \n \t      /* Dereference the typedef declaration itself.  */\n-\t      gdb_assert (TYPE_CODE (target) == TYPE_CODE_TYPEDEF);\n+\t      gdb_assert (target->code () == TYPE_CODE_TYPEDEF);\n \t      target = TYPE_TARGET_TYPE (target);\n \n \t      if (need_access_label)\n@@ -1492,16 +1492,16 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t way. */\n       if (language == language_c || language == language_minimal)\n \t{\n-\t  if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+\t  if (type->code () == TYPE_CODE_UNION)\n \t    fprintf_filtered (stream, \"union \");\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+\t  else if (type->code () == TYPE_CODE_STRUCT)\n \t    {\n \t      if (TYPE_DECLARED_CLASS (type))\n \t\tfprintf_filtered (stream, \"class \");\n \t      else\n \t\tfprintf_filtered (stream, \"struct \");\n \t    }\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_ENUM)\n+\t  else if (type->code () == TYPE_CODE_ENUM)\n \t    fprintf_filtered (stream, \"enum \");\n \t}\n \n@@ -1511,7 +1511,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \n   type = check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_TYPEDEF:\n       /* If we get here, the typedef doesn't have a name, and we\n@@ -1702,7 +1702,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t  /* At least for dump_symtab, it is important that this not\n \t     be an error ().  */\n \t  fprintf_styled (stream, metadata_style.style (),\n-\t\t\t  _(\"<invalid type code %d>\"), TYPE_CODE (type));\n+\t\t\t  _(\"<invalid type code %d>\"), type->code ());\n \t}\n       break;\n     }"
    },
    {
      "sha": "d117248c44285f991970dabc4fceb46f7cf0788d",
      "filename": "gdb/c-valprint.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -66,11 +66,11 @@ c_textual_element_type (struct type *type, char format)\n   true_type = check_typedef (type);\n \n   /* TYPE_CODE_CHAR is always textual.  */\n-  if (TYPE_CODE (true_type) == TYPE_CODE_CHAR)\n+  if (true_type->code () == TYPE_CODE_CHAR)\n     return 1;\n \n   /* Any other character-like types must be integral.  */\n-  if (TYPE_CODE (true_type) != TYPE_CODE_INT)\n+  if (true_type->code () != TYPE_CODE_INT)\n     return 0;\n \n   /* We peel typedefs one by one, looking for a match.  */\n@@ -81,7 +81,7 @@ c_textual_element_type (struct type *type, char format)\n       if (TYPE_NAME (iter_type) && textual_name (TYPE_NAME (iter_type)))\n \treturn 1;\n \n-      if (TYPE_CODE (iter_type) != TYPE_CODE_TYPEDEF)\n+      if (iter_type->code () != TYPE_CODE_TYPEDEF)\n \tbreak;\n \n       /* Peel a single typedef.  If the typedef doesn't have a target\n@@ -97,7 +97,7 @@ c_textual_element_type (struct type *type, char format)\n     {\n       /* Print this as a string if we can manage it.  For now, no wide\n \t character support.  */\n-      if (TYPE_CODE (true_type) == TYPE_CODE_INT\n+      if (true_type->code () == TYPE_CODE_INT\n \t  && TYPE_LENGTH (true_type) == 1)\n \treturn 1;\n     }\n@@ -106,7 +106,7 @@ c_textual_element_type (struct type *type, char format)\n       /* If a one-byte TYPE_CODE_INT is missing the not-a-character\n \t flag, then we treat it as text; otherwise, we assume it's\n \t being used as data.  */\n-      if (TYPE_CODE (true_type) == TYPE_CODE_INT\n+      if (true_type->code () == TYPE_CODE_INT\n \t  && TYPE_LENGTH (true_type) == 1\n \t  && !TYPE_NOTTEXT (true_type))\n \treturn 1;\n@@ -146,7 +146,7 @@ print_unpacked_pointer (struct type *type, struct type *elttype,\n   int want_space = 0;\n   struct gdbarch *gdbarch = get_type_arch (type);\n \n-  if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)\n+  if (elttype->code () == TYPE_CODE_FUNC)\n     {\n       /* Try to print what function it points to.  */\n       print_function_pointer_address (options, gdbarch, address, stream);\n@@ -365,7 +365,7 @@ c_value_print_struct (struct value *val, struct ui_file *stream, int recurse,\n {\n   struct type *type = check_typedef (value_type (val));\n \n-  if (TYPE_CODE (type) == TYPE_CODE_UNION && recurse && !options->unionprint)\n+  if (type->code () == TYPE_CODE_UNION && recurse && !options->unionprint)\n     fprintf_filtered (stream, \"{...}\");\n   else if (options->vtblprint && cp_is_vtbl_ptr_type (type))\n     {\n@@ -443,7 +443,7 @@ c_value_print_inner (struct value *val, struct ui_file *stream, int recurse,\n   const gdb_byte *valaddr = value_contents_for_printing (val);\n \n   type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       c_value_print_array (val, stream, recurse, options);\n@@ -512,15 +512,15 @@ c_value_print (struct value *val, struct ui_file *stream,\n \n   type = check_typedef (value_type (val));\n \n-  if (TYPE_CODE (type) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (type))\n+  if (type->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (type))\n     {\n       struct type *original_type = value_type (val);\n \n       /* Hack:  remove (char *) for char strings.  Their\n          type is indicated by the quoted string anyway.\n          (Don't use c_textual_element_type here; quoted strings\n          are always exactly (char *), (wchar_t *), or the like.  */\n-      if (TYPE_CODE (original_type) == TYPE_CODE_PTR\n+      if (original_type->code () == TYPE_CODE_PTR\n \t  && TYPE_NAME (original_type) == NULL\n \t  && TYPE_NAME (TYPE_TARGET_TYPE (original_type)) != NULL\n \t  && (strcmp (TYPE_NAME (TYPE_TARGET_TYPE (original_type)),\n@@ -530,15 +530,15 @@ c_value_print (struct value *val, struct ui_file *stream,\n \t  /* Print nothing.  */\n \t}\n       else if (options->objectprint\n-\t       && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_STRUCT))\n+\t       && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_STRUCT))\n \t{\n \t  int is_ref = TYPE_IS_REFERENCE (type);\n \t  enum type_code refcode = TYPE_CODE_UNDEF;\n \n \t  if (is_ref)\n \t    {\n \t      val = value_addr (val);\n-\t      refcode = TYPE_CODE (type);\n+\t      refcode = type->code ();\n \t    }\n \n \t  /* Pointer to class, check real type of object.  */\n@@ -581,7 +581,7 @@ c_value_print (struct value *val, struct ui_file *stream,\n   if (!value_initialized (val))\n     fprintf_filtered (stream, \" [uninitialized] \");\n \n-  if (options->objectprint && (TYPE_CODE (type) == TYPE_CODE_STRUCT))\n+  if (options->objectprint && (type->code () == TYPE_CODE_STRUCT))\n     {\n       /* Attempt to determine real type of object.  */\n       real_type = value_rtti_type (val, &full, &top, &using_enc);"
    },
    {
      "sha": "156f622b1b34bffd6c1e82b6a359272ac4357dfc",
      "filename": "gdb/c-varobj.c",
      "status": "modified",
      "additions": 24,
      "deletions": 24,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/c-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-varobj.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -83,11 +83,11 @@ adjust_value_for_child_access (struct value **value,\n   /* Pointers to structures are treated just like\n      structures when accessing children.  Don't\n      dereference pointers to other types.  */\n-  if (TYPE_CODE (*type) == TYPE_CODE_PTR)\n+  if ((*type)->code () == TYPE_CODE_PTR)\n     {\n       struct type *target_type = get_target_type (*type);\n-      if (TYPE_CODE (target_type) == TYPE_CODE_STRUCT\n-\t  || TYPE_CODE (target_type) == TYPE_CODE_UNION)\n+      if (target_type->code () == TYPE_CODE_STRUCT\n+\t  || target_type->code () == TYPE_CODE_UNION)\n \t{\n \t  if (value && *value)\n \t    {\n@@ -142,8 +142,8 @@ c_is_path_expr_parent (const struct varobj *var)\n   type = varobj_get_gdb_type (var);\n \n   /* Anonymous unions and structs are also not path_expr parents.  */\n-  if ((TYPE_CODE (type) == TYPE_CODE_STRUCT\n-       || TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if ((type->code () == TYPE_CODE_STRUCT\n+       || type->code () == TYPE_CODE_UNION)\n       && TYPE_NAME (type) == NULL)\n     {\n       const struct varobj *parent = var->parent;\n@@ -159,8 +159,8 @@ c_is_path_expr_parent (const struct varobj *var)\n \t  parent_type = varobj_get_value_type (parent);\n \t  adjust_value_for_child_access (NULL, &parent_type, &was_ptr, 0);\n \n-\t  if (TYPE_CODE (parent_type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (parent_type) == TYPE_CODE_UNION)\n+\t  if (parent_type->code () == TYPE_CODE_STRUCT\n+\t      || parent_type->code () == TYPE_CODE_UNION)\n \t    {\n \t      const char *field_name;\n \n@@ -188,7 +188,7 @@ c_number_of_children (const struct varobj *var)\n   adjust_value_for_child_access (NULL, &type, NULL, 0);\n   target = get_target_type (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (target) > 0\n@@ -214,8 +214,8 @@ c_number_of_children (const struct varobj *var)\n          to test for it, please mind that a little magic is necessary to\n          properly identify it: char* has TYPE_CODE == TYPE_CODE_INT and \n          TYPE_NAME == \"char\".  */\n-      if (TYPE_CODE (target) == TYPE_CODE_FUNC\n-\t  || TYPE_CODE (target) == TYPE_CODE_VOID)\n+      if (target->code () == TYPE_CODE_FUNC\n+\t  || target->code () == TYPE_CODE_VOID)\n \tchildren = 0;\n       else\n \tchildren = 1;\n@@ -249,8 +249,8 @@ value_struct_element_index (struct value *value, int type_index)\n \n   type = check_typedef (type);\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (type) == TYPE_CODE_UNION);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT\n+\t      || type->code () == TYPE_CODE_UNION);\n \n   try\n     {\n@@ -302,7 +302,7 @@ c_describe_child (const struct varobj *parent, int index,\n     }\n   adjust_value_for_child_access (&value, &type, &was_ptr, 0);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       if (cname)\n@@ -348,7 +348,7 @@ c_describe_child (const struct varobj *parent, int index,\n \t  {\n \t    if (cname)\n \t      {\n-\t\tif (TYPE_CODE (TYPE_FIELD_TYPE (type, index))\n+\t\tif (TYPE_FIELD_TYPE (type, index)->code ()\n \t\t    == TYPE_CODE_STRUCT)\n \t\t  *cname = ANONYMOUS_STRUCT_NAME;\n \t\telse\n@@ -486,7 +486,7 @@ c_value_of_variable (const struct varobj *var,\n   while (TYPE_IS_REFERENCE (type))\n     type = check_typedef (TYPE_TARGET_TYPE (type));\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n@@ -577,12 +577,12 @@ cplus_number_of_children (const struct varobj *var)\n         {\n           value = var->value.get ();\n           lookup_actual_type = (TYPE_IS_REFERENCE (var->type)\n-\t\t\t\t|| TYPE_CODE (var->type) == TYPE_CODE_PTR);\n+\t\t\t\t|| var->type->code () == TYPE_CODE_PTR);\n         }\n       adjust_value_for_child_access (&value, &type, NULL, lookup_actual_type);\n \n-      if (((TYPE_CODE (type)) == TYPE_CODE_STRUCT)\n-\t  || ((TYPE_CODE (type)) == TYPE_CODE_UNION))\n+      if (((type->code ()) == TYPE_CODE_STRUCT)\n+\t  || ((type->code ()) == TYPE_CODE_UNION))\n \t{\n \t  int kids[3];\n \n@@ -614,7 +614,7 @@ cplus_number_of_children (const struct varobj *var)\n \n \t  value = parent->value.get ();\n \t  lookup_actual_type = (TYPE_IS_REFERENCE (parent->type)\n-\t\t\t\t|| TYPE_CODE (parent->type) == TYPE_CODE_PTR);\n+\t\t\t\t|| parent->type->code () == TYPE_CODE_PTR);\n         }\n       adjust_value_for_child_access (&value, &type, NULL, lookup_actual_type);\n \n@@ -719,7 +719,7 @@ cplus_describe_child (const struct varobj *parent, int index,\n   var = (CPLUS_FAKE_CHILD (parent)) ? parent->parent : parent;\n   if (opts.objectprint)\n     lookup_actual_type = (TYPE_IS_REFERENCE (var->type)\n-\t\t\t  || TYPE_CODE (var->type) == TYPE_CODE_PTR);\n+\t\t\t  || var->type->code () == TYPE_CODE_PTR);\n   value = var->value.get ();\n   type = varobj_get_value_type (var);\n   if (cfull_expression)\n@@ -728,8 +728,8 @@ cplus_describe_child (const struct varobj *parent, int index,\n \n   adjust_value_for_child_access (&value, &type, &was_ptr, lookup_actual_type);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION)\n     {\n       const char *join = was_ptr ? \"->\" : \".\";\n \n@@ -771,10 +771,10 @@ cplus_describe_child (const struct varobj *parent, int index,\n \t    {\n \t      if (cname)\n \t\t{\n-\t\t  if (TYPE_CODE (TYPE_FIELD_TYPE (type, type_index))\n+\t\t  if (TYPE_FIELD_TYPE (type, type_index)->code ()\n \t\t      == TYPE_CODE_STRUCT)\n \t\t    *cname = ANONYMOUS_STRUCT_NAME;\n-\t\t  else if (TYPE_CODE (TYPE_FIELD_TYPE (type, type_index))\n+\t\t  else if (TYPE_FIELD_TYPE (type, type_index)->code ()\n \t\t\t   == TYPE_CODE_UNION)\n \t\t    *cname = ANONYMOUS_UNION_NAME;\n \t\t}"
    },
    {
      "sha": "58e9cf319569a390b0765da4e3bc34614293d7fc",
      "filename": "gdb/cli/cli-cmds.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cli/cli-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cli/cli-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-cmds.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1912,8 +1912,8 @@ setting_cmd (const char *fnname, struct cmd_list_element *showlist,\n \n   struct type *type0 = check_typedef (value_type (argv[0]));\n \n-  if (TYPE_CODE (type0) != TYPE_CODE_ARRAY\n-      && TYPE_CODE (type0) != TYPE_CODE_STRING)\n+  if (type0->code () != TYPE_CODE_ARRAY\n+      && type0->code () != TYPE_CODE_STRING)\n     error (_(\"First argument of %s must be a string.\"), fnname);\n \n   const char *a0 = (const char *) value_contents (argv[0]);"
    },
    {
      "sha": "710fd520a5c25ca72456f10052246d8c05b23648",
      "filename": "gdb/cli/cli-utils.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cli/cli-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cli/cli-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-utils.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -37,7 +37,7 @@ get_ulongest (const char **pp, int trailer)\n \n       if (val != NULL)\t/* Value history reference */\n \t{\n-\t  if (TYPE_CODE (value_type (val)) == TYPE_CODE_INT)\n+\t  if (value_type (val)->code () == TYPE_CODE_INT)\n \t    retval = value_as_long (val);\n \t  else\n \t    error (_(\"History value must have integer type.\"));\n@@ -96,7 +96,7 @@ get_number_trailer (const char **pp, int trailer)\n \n       if (val)\t/* Value history reference */\n \t{\n-\t  if (TYPE_CODE (value_type (val)) == TYPE_CODE_INT)\n+\t  if (value_type (val)->code () == TYPE_CODE_INT)\n \t    retval = value_as_long (val);\n \t  else\n \t    {"
    },
    {
      "sha": "d320332f3af0384a59e640dc13fc4b0a9553b968",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1494,7 +1494,7 @@ patch_opaque_types (struct symtab *s)\n          from different files with the same name.  */\n       if (SYMBOL_CLASS (real_sym) == LOC_TYPEDEF\n \t  && SYMBOL_DOMAIN (real_sym) == VAR_DOMAIN\n-\t  && TYPE_CODE (SYMBOL_TYPE (real_sym)) == TYPE_CODE_PTR\n+\t  && SYMBOL_TYPE (real_sym)->code () == TYPE_CODE_PTR\n \t  && TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (real_sym))) != 0)\n \t{\n \t  const char *name = real_sym->linkage_name ();\n@@ -1660,8 +1660,8 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  /* If type has no name, give it one.  */\n \t  if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)\n \t    {\n-\t      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR\n-\t\t  || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FUNC)\n+\t      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_PTR\n+\t\t  || SYMBOL_TYPE (sym)->code () == TYPE_CODE_FUNC)\n \t\t{\n \t\t  /* If we are giving a name to a type such as\n \t\t     \"pointer to foo\" or \"function returning foo\", we\n@@ -1694,10 +1694,10 @@ process_coff_symbol (struct coff_symbol *cs,\n \t     not an empty structured type, though; the forward\n \t     references work themselves out via the magic of\n \t     coff_lookup_type.  */\n-\t  if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR\n+\t  if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_PTR\n \t      && TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) == 0\n-\t      && TYPE_CODE (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym)))\n-\t         != TYPE_CODE_UNDEF)\n+\t      && TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))->code ()\n+\t      != TYPE_CODE_UNDEF)\n \t    {\n \t      int i = hashname (sym->linkage_name ());\n "
    },
    {
      "sha": "8499300179c06e121540a9743516c16a0a8874e2",
      "filename": "gdb/compile/compile-c-support.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-c-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-c-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-support.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -242,7 +242,7 @@ generate_register_struct (struct ui_file *stream, struct gdbarch *gdbarch,\n \t       maximally-aligned array of the correct size.  */\n \n \t    fputs_unfiltered (\"  \", stream);\n-\t    switch (TYPE_CODE (regtype))\n+\t    switch (regtype->code ())\n \t      {\n \t      case TYPE_CODE_PTR:\n \t\tfprintf_filtered (stream, \"__gdb_uintptr %s\","
    },
    {
      "sha": "ab9f4425b7c7badd4330adb5026ddc2c9802c5d1",
      "filename": "gdb/compile/compile-c-symbols.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-c-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-c-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-symbols.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -99,7 +99,7 @@ convert_one_symbol (compile_c_instance *context,\n \t  break;\n \n \tcase LOC_CONST:\n-\t  if (TYPE_CODE (SYMBOL_TYPE (sym.symbol)) == TYPE_CODE_ENUM)\n+\t  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_ENUM)\n \t    {\n \t      /* Already handled by convert_enum.  */\n \t      return;\n@@ -497,7 +497,7 @@ generate_vla_size (compile_instance *compiler,\n   if (TYPE_IS_REFERENCE (type))\n     type = check_typedef (TYPE_TARGET_TYPE (type));\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_RANGE:\n       {"
    },
    {
      "sha": "ed4a6e93b6ce399b9643ae45e652166174bb4740",
      "filename": "gdb/compile/compile-c-types.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-c-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-c-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-types.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -94,11 +94,11 @@ convert_struct_or_union (compile_c_instance *context, struct type *type)\n \n   /* First we create the resulting type and enter it into our hash\n      table.  This lets recursive types work.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     result = context->plugin ().build_record_type ();\n   else\n     {\n-      gdb_assert (TYPE_CODE (type) == TYPE_CODE_UNION);\n+      gdb_assert (type->code () == TYPE_CODE_UNION);\n       result = context->plugin ().build_union_type ();\n     }\n   context->insert_type (type, result);\n@@ -282,7 +282,7 @@ convert_type_basic (compile_c_instance *context, struct type *type)\n \t\t\t\t     | TYPE_INSTANCE_FLAG_RESTRICT)) != 0)\n     return convert_qualified (context, type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n       return convert_pointer (context, type);"
    },
    {
      "sha": "11a2d3234586f542ba259ae60157a93514345a25",
      "filename": "gdb/compile/compile-cplus-symbols.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-cplus-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-cplus-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-symbols.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -73,9 +73,9 @@ convert_one_symbol (compile_cplus_instance *instance,\n       switch (SYMBOL_CLASS (sym.symbol))\n \t{\n \tcase LOC_TYPEDEF:\n-\t  if (TYPE_CODE (SYMBOL_TYPE (sym.symbol)) == TYPE_CODE_TYPEDEF)\n+\t  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_TYPEDEF)\n \t    kind = GCC_CP_SYMBOL_TYPEDEF;\n-\t  else  if (TYPE_CODE (SYMBOL_TYPE (sym.symbol)) == TYPE_CODE_NAMESPACE)\n+\t  else  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_NAMESPACE)\n \t    return;\n \t  break;\n \n@@ -94,7 +94,7 @@ convert_one_symbol (compile_cplus_instance *instance,\n \t  break;\n \n \tcase LOC_CONST:\n-\t  if (TYPE_CODE (SYMBOL_TYPE (sym.symbol)) == TYPE_CODE_ENUM)\n+\t  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_ENUM)\n \t    {\n \t      /* Already handled by convert_enum.  */\n \t      return;"
    },
    {
      "sha": "3dec3b2a3055ae46677b90bd34417e37181d3fc2",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -88,7 +88,7 @@ get_field_access_flag (const struct type *type, int num)\n enum gcc_cp_symbol_kind\n get_method_access_flag (const struct type *type, int fni, int num)\n {\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT);\n \n   /* If this type was not declared a class, everything is public.  */\n   if (!TYPE_DECLARED_CLASS (type))\n@@ -161,7 +161,7 @@ type_name_to_scope (const char *type_name, const struct block *block)\n \n \t  scope.push_back (comp);\n \n-\t  if (TYPE_CODE (SYMBOL_TYPE (bsymbol.symbol)) != TYPE_CODE_NAMESPACE)\n+\t  if (SYMBOL_TYPE (bsymbol.symbol)->code () != TYPE_CODE_NAMESPACE)\n \t    {\n \t      /* We're done.  */\n \t      break;\n@@ -271,7 +271,7 @@ compile_cplus_instance::enter_scope (compile_scope &&new_scope)\n \t(m_scopes.back ().begin (), m_scopes.back ().end () - 1,\n \t [this] (const scope_component &comp)\n \t {\n-\t  gdb_assert (TYPE_CODE (SYMBOL_TYPE (comp.bsymbol.symbol))\n+\t  gdb_assert (SYMBOL_TYPE (comp.bsymbol.symbol)->code ()\n \t\t      == TYPE_CODE_NAMESPACE);\n \n \t  const char *ns = (comp.name == CP_ANONYMOUS_NAMESPACE_STR ? nullptr\n@@ -313,7 +313,7 @@ compile_cplus_instance::leave_scope ()\n       std::for_each\n \t(current.begin (),current.end () - 1,\n \t [this] (const scope_component &comp) {\n-\t  gdb_assert (TYPE_CODE (SYMBOL_TYPE (comp.bsymbol.symbol))\n+\t  gdb_assert (SYMBOL_TYPE (comp.bsymbol.symbol)->code ()\n \t\t      == TYPE_CODE_NAMESPACE);\n \t  this->plugin ().pop_binding_level (comp.name.c_str ());\n \t});\n@@ -413,7 +413,7 @@ compile_cplus_convert_reference (compile_cplus_instance *instance,\n   gcc_type target = instance->convert_type (TYPE_TARGET_TYPE (type));\n \n   enum gcc_cp_ref_qualifiers quals = GCC_CP_REF_QUAL_NONE;\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_REF:\n       quals = GCC_CP_REF_QUAL_LVALUE;\n@@ -826,7 +826,7 @@ compile_cplus_convert_struct_or_union (compile_cplus_instance *instance,\n      table.  This lets recursive types work.  */\n \n   gcc_decl resuld;\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     {\n       const char *what = TYPE_DECLARED_CLASS (type) ? \"struct\" : \"class\";\n \n@@ -839,14 +839,14 @@ compile_cplus_convert_struct_or_union (compile_cplus_instance *instance,\n     }\n   else\n     {\n-      gdb_assert (TYPE_CODE (type) == TYPE_CODE_UNION);\n+      gdb_assert (type->code () == TYPE_CODE_UNION);\n       resuld = instance->plugin ().build_decl\n \t(\"union\", name.get (), GCC_CP_SYMBOL_UNION | nested_access,\n \t 0, nullptr, 0, filename, line);\n     }\n \n   gcc_type result;\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     {\n       struct gcc_vbase_array bases;\n       int num_baseclasses = TYPE_N_BASECLASSES (type);\n@@ -878,7 +878,7 @@ compile_cplus_convert_struct_or_union (compile_cplus_instance *instance,\n     }\n   else\n     {\n-      gdb_assert (TYPE_CODE (type) == TYPE_CODE_UNION);\n+      gdb_assert (type->code () == TYPE_CODE_UNION);\n       result = instance->plugin ().start_class_type\n \t(name.get (), resuld, nullptr, filename, line);\n     }\n@@ -1140,7 +1140,7 @@ convert_type_cplus_basic (compile_cplus_instance *instance,\n \t\t\t\t     | TYPE_INSTANCE_FLAG_RESTRICT)) != 0)\n     return compile_cplus_convert_qualified (instance, type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_REF:\n     case TYPE_CODE_RVALUE_REF:\n@@ -1198,7 +1198,7 @@ convert_type_cplus_basic (compile_cplus_instance *instance,\n     }\n \n   std::string s = string_printf (_(\"unhandled TYPE_CODE %d\"),\n-\t\t\t\t TYPE_CODE (type));\n+\t\t\t\t type->code ());\n \n   return instance->plugin ().error (s.c_str ());\n }"
    },
    {
      "sha": "55a46a31dba3a31b0b2bf3401f22d1b13d6836f4",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -452,7 +452,7 @@ get_out_value_type (struct symbol *func_sym, struct objfile *objfile,\n     error (_(\"No \\\"%s\\\" symbol found\"), COMPILE_I_EXPR_PTR_TYPE);\n   gdb_ptr_type = SYMBOL_TYPE (gdb_ptr_type_sym);\n   gdb_ptr_type = check_typedef (gdb_ptr_type);\n-  if (TYPE_CODE (gdb_ptr_type) != TYPE_CODE_PTR)\n+  if (gdb_ptr_type->code () != TYPE_CODE_PTR)\n     error (_(\"Type of \\\"%s\\\" is not a pointer\"), COMPILE_I_EXPR_PTR_TYPE);\n   gdb_type_from_ptr = check_typedef (TYPE_TARGET_TYPE (gdb_ptr_type));\n \n@@ -464,14 +464,14 @@ get_out_value_type (struct symbol *func_sym, struct objfile *objfile,\n       return gdb_type;\n     }\n \n-  if (TYPE_CODE (gdb_type) != TYPE_CODE_PTR)\n+  if (gdb_type->code () != TYPE_CODE_PTR)\n     error (_(\"Invalid type code %d of symbol \\\"%s\\\" \"\n \t     \"in compiled module \\\"%s\\\".\"),\n-\t   TYPE_CODE (gdb_type_from_ptr), COMPILE_I_EXPR_VAL,\n+\t   gdb_type_from_ptr->code (), COMPILE_I_EXPR_VAL,\n \t   objfile_name (objfile));\n   \n   retval = gdb_type_from_ptr;\n-  switch (TYPE_CODE (gdb_type_from_ptr))\n+  switch (gdb_type_from_ptr->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       gdb_type_from_ptr = TYPE_TARGET_TYPE (gdb_type_from_ptr);\n@@ -481,7 +481,7 @@ get_out_value_type (struct symbol *func_sym, struct objfile *objfile,\n     default:\n       error (_(\"Invalid type code %d of symbol \\\"%s\\\" \"\n \t       \"in compiled module \\\"%s\\\".\"),\n-\t     TYPE_CODE (gdb_type_from_ptr), COMPILE_I_EXPR_PTR_TYPE,\n+\t     gdb_type_from_ptr->code (), COMPILE_I_EXPR_PTR_TYPE,\n \t     objfile_name (objfile));\n     }\n   if (!types_deeply_equal (gdb_type_from_ptr,\n@@ -509,17 +509,17 @@ get_regs_type (struct symbol *func_sym, struct objfile *objfile)\n     return NULL;\n \n   regsp_type = check_typedef (TYPE_FIELD_TYPE (func_type, 0));\n-  if (TYPE_CODE (regsp_type) != TYPE_CODE_PTR)\n+  if (regsp_type->code () != TYPE_CODE_PTR)\n     error (_(\"Invalid type code %d of first parameter of function \\\"%s\\\" \"\n \t     \"in compiled module \\\"%s\\\".\"),\n-\t   TYPE_CODE (regsp_type), GCC_FE_WRAPPER_FUNCTION,\n+\t   regsp_type->code (), GCC_FE_WRAPPER_FUNCTION,\n \t   objfile_name (objfile));\n \n   regs_type = check_typedef (TYPE_TARGET_TYPE (regsp_type));\n-  if (TYPE_CODE (regs_type) != TYPE_CODE_STRUCT)\n+  if (regs_type->code () != TYPE_CODE_STRUCT)\n     error (_(\"Invalid type code %d of dereferenced first parameter \"\n \t     \"of function \\\"%s\\\" in compiled module \\\"%s\\\".\"),\n-\t   TYPE_CODE (regs_type), GCC_FE_WRAPPER_FUNCTION,\n+\t   regs_type->code (), GCC_FE_WRAPPER_FUNCTION,\n \t   objfile_name (objfile));\n \n   return regs_type;\n@@ -555,10 +555,10 @@ store_regs (struct type *regs_type, CORE_ADDR regs_base)\n \t       reg_name, pulongest (reg_bitpos), pulongest (reg_bitsize));\n       reg_offset = reg_bitpos / 8;\n \n-      if (TYPE_CODE (reg_type) != TYPE_CODE_INT\n-\t  && TYPE_CODE (reg_type) != TYPE_CODE_PTR)\n+      if (reg_type->code () != TYPE_CODE_INT\n+\t  && reg_type->code () != TYPE_CODE_PTR)\n \terror (_(\"Invalid register \\\"%s\\\" type code %d\"), reg_name,\n-\t       TYPE_CODE (reg_type));\n+\t       reg_type->code ());\n \n       regnum = compile_register_name_demangle (gdbarch, reg_name);\n \n@@ -646,10 +646,10 @@ compile_object_load (const compile_file_names &file_names,\n     error (_(\"Cannot find function \\\"%s\\\" in compiled module \\\"%s\\\".\"),\n \t   GCC_FE_WRAPPER_FUNCTION, objfile_name (objfile));\n   func_type = SYMBOL_TYPE (func_sym);\n-  if (TYPE_CODE (func_type) != TYPE_CODE_FUNC)\n+  if (func_type->code () != TYPE_CODE_FUNC)\n     error (_(\"Invalid type code %d of function \\\"%s\\\" in compiled \"\n \t     \"module \\\"%s\\\".\"),\n-\t   TYPE_CODE (func_type), GCC_FE_WRAPPER_FUNCTION,\n+\t   func_type->code (), GCC_FE_WRAPPER_FUNCTION,\n \t   objfile_name (objfile));\n \n   switch (scope)"
    },
    {
      "sha": "cef1d06adf70ed2029432e64acdf4895f90857b0",
      "filename": "gdb/compile/compile-object-run.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-object-run.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/compile/compile-object-run.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-run.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -149,7 +149,7 @@ compile_object_run (struct compile_module *module)\n       func_type = copy_type_recursive (objfile, func_type, copied_types);\n       htab_delete (copied_types);\n \n-      gdb_assert (TYPE_CODE (func_type) == TYPE_CODE_FUNC);\n+      gdb_assert (func_type->code () == TYPE_CODE_FUNC);\n       func_val = value_from_pointer (lookup_pointer_type (func_type),\n \t\t\t\t   BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (func_sym)));\n "
    },
    {
      "sha": "71e31cf6df8f0a9df24cfe3890d78f234a4e5e02",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1103,7 +1103,7 @@ add_struct_fields (struct type *type, completion_list &output,\n \t\t\t     fieldname, namelen))\n \t\toutput.emplace_back (xstrdup (TYPE_FIELD_NAME (type, i)));\n \t    }\n-\t  else if (TYPE_CODE (TYPE_FIELD_TYPE (type, i)) == TYPE_CODE_UNION)\n+\t  else if (TYPE_FIELD_TYPE (type, i)->code () == TYPE_CODE_UNION)\n \t    {\n \t      /* Recurse into anonymous unions.  */\n \t      add_struct_fields (TYPE_FIELD_TYPE (type, i),\n@@ -1156,13 +1156,13 @@ complete_expression (completion_tracker &tracker,\n       for (;;)\n \t{\n \t  type = check_typedef (type);\n-\t  if (TYPE_CODE (type) != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n+\t  if (type->code () != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n \t    break;\n \t  type = TYPE_TARGET_TYPE (type);\n \t}\n \n-      if (TYPE_CODE (type) == TYPE_CODE_UNION\n-\t  || TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      if (type->code () == TYPE_CODE_UNION\n+\t  || type->code () == TYPE_CODE_STRUCT)\n \t{\n \t  completion_list result;\n "
    },
    {
      "sha": "517a0711d9d3f84a160da547b05cbb0b2ff298f3",
      "filename": "gdb/cp-namespace.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cp-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cp-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-namespace.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -278,8 +278,8 @@ cp_search_static_and_baseclasses (const char *name,\n \n   /* If the scope is a function/method, then look up NESTED as a local\n      static variable.  E.g., \"print 'function()::static_var'\".  */\n-  if ((TYPE_CODE (scope_type) == TYPE_CODE_FUNC\n-       || TYPE_CODE (scope_type) == TYPE_CODE_METHOD)\n+  if ((scope_type->code () == TYPE_CODE_FUNC\n+       || scope_type->code () == TYPE_CODE_METHOD)\n       && domain == VAR_DOMAIN)\n     return lookup_symbol (nested, SYMBOL_BLOCK_VALUE (scope_sym.symbol),\n \t\t\t  VAR_DOMAIN, NULL);\n@@ -927,7 +927,7 @@ cp_lookup_nested_symbol (struct type *parent_type,\n \t\t\t  domain_name (domain));\n     }\n \n-  switch (TYPE_CODE (parent_type))\n+  switch (parent_type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_NAMESPACE:"
    },
    {
      "sha": "bc9e8d4eda503a6712aa3217b4de1cec8b0ebece",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -183,8 +183,8 @@ inspect_type (struct demangle_parse_info *info,\n \t}\n \n       /* If the type is a typedef or namespace alias, replace it.  */\n-      if (TYPE_CODE (otype) == TYPE_CODE_TYPEDEF\n-\t  || TYPE_CODE (otype) == TYPE_CODE_NAMESPACE)\n+      if (otype->code () == TYPE_CODE_TYPEDEF\n+\t  || otype->code () == TYPE_CODE_NAMESPACE)\n \t{\n \t  long len;\n \t  int is_anon;\n@@ -212,16 +212,16 @@ inspect_type (struct demangle_parse_info *info,\n \t    return 0;\n \n \t  is_anon = (TYPE_NAME (type) == NULL\n-\t\t     && (TYPE_CODE (type) == TYPE_CODE_ENUM\n-\t\t\t || TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t\t\t || TYPE_CODE (type) == TYPE_CODE_UNION));\n+\t\t     && (type->code () == TYPE_CODE_ENUM\n+\t\t\t || type->code () == TYPE_CODE_STRUCT\n+\t\t\t || type->code () == TYPE_CODE_UNION));\n \t  if (is_anon)\n \t    {\n \t      struct type *last = otype;\n \n \t      /* Find the last typedef for the type.  */\n \t      while (TYPE_TARGET_TYPE (last) != NULL\n-\t\t     && (TYPE_CODE (TYPE_TARGET_TYPE (last))\n+\t\t     && (TYPE_TARGET_TYPE (last)->code ()\n \t\t\t == TYPE_CODE_TYPEDEF))\n \t\tlast = TYPE_TARGET_TYPE (last);\n \n@@ -1267,13 +1267,13 @@ add_symbol_overload_list_adl_namespace (struct type *type,\n   const char *type_name;\n   int i, prefix_len;\n \n-  while (TYPE_CODE (type) == TYPE_CODE_PTR\n+  while (type->code () == TYPE_CODE_PTR\n \t || TYPE_IS_REFERENCE (type)\n-         || TYPE_CODE (type) == TYPE_CODE_ARRAY\n-         || TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+         || type->code () == TYPE_CODE_ARRAY\n+         || type->code () == TYPE_CODE_TYPEDEF)\n     {\n-      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n-\ttype = check_typedef(type);\n+      if (type->code () == TYPE_CODE_TYPEDEF)\n+\ttype = check_typedef (type);\n       else\n \ttype = TYPE_TARGET_TYPE (type);\n     }\n@@ -1296,7 +1296,7 @@ add_symbol_overload_list_adl_namespace (struct type *type,\n     }\n \n   /* Check public base type */\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     for (i = 0; i < TYPE_N_BASECLASSES (type); i++)\n       {\n \tif (BASETYPE_VIA_PUBLIC (type, i))\n@@ -1450,7 +1450,7 @@ cp_lookup_rtti_type (const char *name, const struct block *block)\n \n   rtti_type = check_typedef (SYMBOL_TYPE (rtti_sym));\n \n-  switch (TYPE_CODE (rtti_type))\n+  switch (rtti_type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n       break;"
    },
    {
      "sha": "799bdb10ef720e7b0669d666dcdedef0ce945f6a",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -74,25 +74,25 @@ cp_is_vtbl_member (struct type *type)\n {\n   /* With older versions of g++, the vtbl field pointed to an array of\n      structures.  Nowadays it points directly to the structure.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     {\n       type = TYPE_TARGET_TYPE (type);\n-      if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+      if (type->code () == TYPE_CODE_ARRAY)\n \t{\n \t  type = TYPE_TARGET_TYPE (type);\n-\t  if (TYPE_CODE (type) == TYPE_CODE_STRUCT    /* if not using thunks */\n-\t      || TYPE_CODE (type) == TYPE_CODE_PTR)   /* if using thunks */\n+\t  if (type->code () == TYPE_CODE_STRUCT    /* if not using thunks */\n+\t      || type->code () == TYPE_CODE_PTR)   /* if using thunks */\n \t    {\n \t      /* Virtual functions tables are full of pointers\n \t         to virtual functions.  */\n \t      return cp_is_vtbl_ptr_type (type);\n \t    }\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)  /* if not using thunks */\n+      else if (type->code () == TYPE_CODE_STRUCT)  /* if not using thunks */\n \t{\n \t  return cp_is_vtbl_ptr_type (type);\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_PTR)     /* if using thunks */\n+      else if (type->code () == TYPE_CODE_PTR)     /* if using thunks */\n \t{\n \t  /* The type name of the thunk pointer is NULL when using\n \t     dwarf2.  We could test for a pointer to a function, but\n@@ -563,7 +563,7 @@ cp_print_static_field (struct type *type,\n     }\n \n   struct type *real_type = check_typedef (type);\n-  if (TYPE_CODE (real_type) == TYPE_CODE_STRUCT)\n+  if (real_type->code () == TYPE_CODE_STRUCT)\n     {\n       CORE_ADDR *first_dont_print;\n       CORE_ADDR addr = value_address (val);\n@@ -591,7 +591,7 @@ cp_print_static_field (struct type *type,\n       return;\n     }\n \n-  if (TYPE_CODE (real_type) == TYPE_CODE_ARRAY)\n+  if (real_type->code () == TYPE_CODE_ARRAY)\n     {\n       struct type **first_dont_print;\n       int i;"
    },
    {
      "sha": "068ae9908d734dcdf659b17c3fb94610cb626ee3",
      "filename": "gdb/cris-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cris-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/cris-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1805,8 +1805,8 @@ cris_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t   struct type *type, struct regcache *regcache,\n \t\t   gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT \n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n       || TYPE_LENGTH (type) > 8)\n     /* Structs, unions, and anything larger than 8 bytes (2 registers)\n        goes on the stack.  */"
    },
    {
      "sha": "1efa47b2f4c7609fcf793e4fb8d5096e98c4f492",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -460,7 +460,7 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n \t    SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n \t    break;\n \t  case CTF_K_CONST:\n-\t    if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_VOID)\n+\t    if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_VOID)\n \t      SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_int;\n \t    break;\n \t  case CTF_K_TYPEDEF:\n@@ -726,7 +726,7 @@ add_array_cv_type (struct ctf_context *ccp,\n   base_type = copy_type (base_type);\n   inner_array = base_type;\n \n-  while (TYPE_CODE (TYPE_TARGET_TYPE (inner_array)) == TYPE_CODE_ARRAY)\n+  while (TYPE_TARGET_TYPE (inner_array)->code () == TYPE_CODE_ARRAY)\n     {\n       TYPE_TARGET_TYPE (inner_array)\n \t= copy_type (TYPE_TARGET_TYPE (inner_array));"
    },
    {
      "sha": "fdd68a51db1e38fe8e4e83c5425d4f96b161710c",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -462,7 +462,7 @@ PrimaryExpression:\n \t\t\t  /* Check if the qualified name is in the global\n \t\t\t     context.  However if the symbol has not already\n \t\t\t     been resolved, it's not likely to be found.  */\n-\t\t\t  if (TYPE_CODE (type) == TYPE_CODE_MODULE)\n+\t\t\t  if (type->code () == TYPE_CODE_MODULE)\n \t\t\t    {\n \t\t\t      struct bound_minimal_symbol msymbol;\n \t\t\t      struct block_symbol sym;\n@@ -644,10 +644,10 @@ BasicType:\n static int\n type_aggregate_p (struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t  || TYPE_CODE (type) == TYPE_CODE_UNION\n-\t  || TYPE_CODE (type) == TYPE_CODE_MODULE\n-\t  || (TYPE_CODE (type) == TYPE_CODE_ENUM\n+  return (type->code () == TYPE_CODE_STRUCT\n+\t  || type->code () == TYPE_CODE_UNION\n+\t  || type->code () == TYPE_CODE_MODULE\n+\t  || (type->code () == TYPE_CODE_ENUM\n \t      && TYPE_DECLARED_CLASS (type)));\n }\n "
    },
    {
      "sha": "f15708b60bfa0c9448404947a4c4f588088b3d94",
      "filename": "gdb/d-namespace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/d-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/d-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-namespace.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -308,7 +308,7 @@ d_lookup_nested_symbol (struct type *parent_type,\n \n   parent_type = check_typedef (parent_type);\n \n-  switch (TYPE_CODE (parent_type))\n+  switch (parent_type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:"
    },
    {
      "sha": "cb0f5095dfc02dfbc056587439bc66eba53fa55d",
      "filename": "gdb/d-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/d-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/d-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -35,7 +35,7 @@ dynamic_array_type (struct type *type,\n \t\t    const struct value_print_options *options)\n {\n   if (TYPE_NFIELDS (type) == 2\n-      && TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_INT\n+      && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_INT\n       && strcmp (TYPE_FIELD_NAME (type, 0), \"length\") == 0\n       && strcmp (TYPE_FIELD_NAME (type, 1), \"ptr\") == 0\n       && !value_bits_any_optimized_out (val,\n@@ -78,7 +78,7 @@ d_value_print_inner (struct value *val, struct ui_file *stream, int recurse,\n   int ret;\n \n   struct type *type = check_typedef (value_type (val));\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n       case TYPE_CODE_STRUCT:\n \tret = dynamic_array_type (type, value_embedded_offset (val),"
    },
    {
      "sha": "14ffae43841b8d285de73461aafca46054600e03",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -146,9 +146,9 @@ dwarf_expr_context::fetch (int n)\n static void\n dwarf_require_integral (struct type *type)\n {\n-  if (TYPE_CODE (type) != TYPE_CODE_INT\n-      && TYPE_CODE (type) != TYPE_CODE_CHAR\n-      && TYPE_CODE (type) != TYPE_CODE_BOOL)\n+  if (type->code () != TYPE_CODE_INT\n+      && type->code () != TYPE_CODE_CHAR\n+      && type->code () != TYPE_CODE_BOOL)\n     error (_(\"integral type expected in DWARF expression\"));\n }\n \n@@ -363,7 +363,7 @@ dwarf_expr_require_composition (const gdb_byte *op_ptr, const gdb_byte *op_end,\n static int\n base_types_equal_p (struct type *t1, struct type *t2)\n {\n-  if (TYPE_CODE (t1) != TYPE_CODE (t2))\n+  if (t1->code () != t2->code ())\n     return 0;\n   if (TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n     return 0;"
    },
    {
      "sha": "616fce987de3978081139cf094f0f9084b983f34",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -605,8 +605,8 @@ sect_variable_value (struct dwarf_expr_context *ctx, sect_offset sect_off,\n \n   /* Note: Things still work when the following test is removed.  This\n      test and error is here to conform to the proposed specification.  */\n-  if (TYPE_CODE (die_type) != TYPE_CODE_INT\n-      && TYPE_CODE (die_type) != TYPE_CODE_PTR)\n+  if (die_type->code () != TYPE_CODE_INT\n+      && die_type->code () != TYPE_CODE_PTR)\n     error (_(\"Type of DW_OP_GNU_variable_value DIE must be an integer or pointer.\"));\n \n   struct type *type = lookup_pointer_type (die_type);\n@@ -915,7 +915,7 @@ func_addr_to_tail_call_list (struct gdbarch *gdbarch, CORE_ADDR addr)\n \t\t paddress (gdbarch, addr));\n \n   type = SYMBOL_TYPE (sym);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FUNC);\n+  gdb_assert (type->code () == TYPE_CODE_FUNC);\n   gdb_assert (TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_FUNC);\n \n   return sym;\n@@ -2027,7 +2027,7 @@ indirect_pieced_value (struct value *value)\n   enum bfd_endian byte_order;\n \n   type = check_typedef (value_type (value));\n-  if (TYPE_CODE (type) != TYPE_CODE_PTR)\n+  if (type->code () != TYPE_CODE_PTR)\n     return NULL;\n \n   bit_length = 8 * TYPE_LENGTH (type);\n@@ -2289,7 +2289,7 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n \t       the operation.  Therefore, we do the conversion here\n \t       since the type is readily available.  */\n \n-\t    switch (TYPE_CODE (subobj_type))\n+\t    switch (subobj_type->code ())\n \t      {\n \t\tcase TYPE_CODE_FUNC:\n \t\tcase TYPE_CODE_METHOD:"
    },
    {
      "sha": "ab21ab0d13a960c581f001a2c0370a8621a88856",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -9285,7 +9285,7 @@ alloc_rust_variant (struct obstack *obstack, struct type *type,\n static void\n quirk_rust_enum (struct type *type, struct objfile *objfile)\n {\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_UNION);\n+  gdb_assert (type->code () == TYPE_CODE_UNION);\n \n   /* We don't need to deal with empty enums.  */\n   if (TYPE_NFIELDS (type) == 0)\n@@ -9385,7 +9385,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t{\n \t  disr_type = TYPE_FIELD_TYPE (type, i);\n \n-\t  if (TYPE_CODE (disr_type) != TYPE_CODE_STRUCT)\n+\t  if (disr_type->code () != TYPE_CODE_STRUCT)\n \t    {\n \t      /* All fields of a true enum will be structs.  */\n \t      return;\n@@ -10299,7 +10299,7 @@ dwarf2_compute_name (const char *name,\n \t\t     the two cases.  */\n \t\t  if (TYPE_NFIELDS (type) > 0\n \t\t      && TYPE_FIELD_ARTIFICIAL (type, 0)\n-\t\t      && TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_PTR\n+\t\t      && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_PTR\n \t\t      && TYPE_CONST (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type,\n \t\t\t\t\t\t\t\t\t0))))\n \t\t    buf.puts (\" const\");\n@@ -10483,7 +10483,7 @@ read_namespace_alias (struct die_info *die, struct dwarf2_cu *cu)\n \t  sect_offset sect_off = attr->get_ref_die_offset ();\n \n \t  type = get_die_type_at_offset (sect_off, cu->per_cu);\n-\t  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_NAMESPACE)\n+\t  if (type != NULL && type->code () == TYPE_CODE_NAMESPACE)\n \t    {\n \t      /* This declaration is a global namespace alias.  Add\n \t\t a symbol for it whose type is the aliased namespace.  */\n@@ -13308,7 +13308,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t    func_type = get_die_type (func_die, cu);\n \t  if (func_type != NULL)\n \t    {\n-\t      gdb_assert (TYPE_CODE (func_type) == TYPE_CODE_FUNC);\n+\t      gdb_assert (func_type->code () == TYPE_CODE_FUNC);\n \n \t      /* Enlist this call site to the function.  */\n \t      call_site->tail_call_next = TYPE_TAIL_CALL_LIST (func_type);\n@@ -14959,7 +14959,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n \n   fnp->type = alloc_type (objfile);\n   this_type = read_type_die (die, cu);\n-  if (this_type && TYPE_CODE (this_type) == TYPE_CODE_FUNC)\n+  if (this_type && this_type->code () == TYPE_CODE_FUNC)\n     {\n       int nparams = TYPE_NFIELDS (this_type);\n \n@@ -15157,7 +15157,7 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n   struct type *pfn_type, *self_type, *new_type;\n \n   /* Check for a structure with no name and two children.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT || TYPE_NFIELDS (type) != 2)\n+  if (type->code () != TYPE_CODE_STRUCT || TYPE_NFIELDS (type) != 2)\n     return;\n \n   /* Check for __pfn and __delta members.  */\n@@ -15170,15 +15170,15 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n   /* Find the type of the method.  */\n   pfn_type = TYPE_FIELD_TYPE (type, 0);\n   if (pfn_type == NULL\n-      || TYPE_CODE (pfn_type) != TYPE_CODE_PTR\n-      || TYPE_CODE (TYPE_TARGET_TYPE (pfn_type)) != TYPE_CODE_FUNC)\n+      || pfn_type->code () != TYPE_CODE_PTR\n+      || TYPE_TARGET_TYPE (pfn_type)->code () != TYPE_CODE_FUNC)\n     return;\n \n   /* Look for the \"this\" argument.  */\n   pfn_type = TYPE_TARGET_TYPE (pfn_type);\n   if (TYPE_NFIELDS (pfn_type) == 0\n       /* || TYPE_FIELD_TYPE (pfn_type, 0) == NULL */\n-      || TYPE_CODE (TYPE_FIELD_TYPE (pfn_type, 0)) != TYPE_CODE_PTR)\n+      || TYPE_FIELD_TYPE (pfn_type, 0)->code () != TYPE_CODE_PTR)\n     return;\n \n   self_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (pfn_type, 0));\n@@ -16679,9 +16679,9 @@ read_tag_ptr_to_member_type (struct die_info *die, struct dwarf2_cu *cu)\n   if (type)\n     return type;\n \n-  if (TYPE_CODE (check_typedef (to_type)) == TYPE_CODE_METHOD)\n+  if (check_typedef (to_type)->code () == TYPE_CODE_METHOD)\n     type = lookup_methodptr_type (to_type);\n-  else if (TYPE_CODE (check_typedef (to_type)) == TYPE_CODE_FUNC)\n+  else if (check_typedef (to_type)->code () == TYPE_CODE_FUNC)\n     {\n       struct type *new_type\n \t= alloc_type (cu->per_cu->dwarf2_per_objfile->objfile);\n@@ -16746,7 +16746,7 @@ add_array_cv_type (struct die_info *die, struct dwarf2_cu *cu,\n   base_type = copy_type (base_type);\n   inner_array = base_type;\n \n-  while (TYPE_CODE (TYPE_TARGET_TYPE (inner_array)) == TYPE_CODE_ARRAY)\n+  while (TYPE_TARGET_TYPE (inner_array)->code () == TYPE_CODE_ARRAY)\n     {\n       TYPE_TARGET_TYPE (inner_array) =\n \tcopy_type (TYPE_TARGET_TYPE (inner_array));\n@@ -16775,7 +16775,7 @@ read_tag_const_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   /* In case the const qualifier is applied to an array type, the element type\n      is so qualified, not the array type (section 6.7.3 of C99).  */\n-  if (TYPE_CODE (base_type) == TYPE_CODE_ARRAY)\n+  if (base_type->code () == TYPE_CODE_ARRAY)\n     return add_array_cv_type (die, cu, base_type, 1, 0);\n \n   cv_type = make_cv_type (1, TYPE_VOLATILE (base_type), base_type, 0);\n@@ -16797,7 +16797,7 @@ read_tag_volatile_type (struct die_info *die, struct dwarf2_cu *cu)\n   /* In case the volatile qualifier is applied to an array type, the\n      element type is so qualified, not the array type (section 6.7.3\n      of C99).  */\n-  if (TYPE_CODE (base_type) == TYPE_CODE_ARRAY)\n+  if (base_type->code () == TYPE_CODE_ARRAY)\n     return add_array_cv_type (die, cu, base_type, 0, 1);\n \n   cv_type = make_cv_type (TYPE_CONST (base_type), 1, base_type, 0);\n@@ -17323,7 +17323,7 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n       case DW_ATE_complex_float:\n \ttype = dwarf2_init_complex_target_type (cu, objfile, bits / 2, name,\n \t\t\t\t\t\tbyte_order);\n-\tif (TYPE_CODE (type) == TYPE_CODE_ERROR)\n+\tif (type->code () == TYPE_CODE_ERROR)\n \t  {\n \t    if (name == nullptr)\n \t      {\n@@ -17578,7 +17578,7 @@ read_subrange_index_type (struct die_info *die, struct dwarf2_cu *cu)\n      GCC produces an empty range DIE.\n      FIXME: muller/2010-05-28: Possible references to object for low bound,\n      high bound or count are not yet handled by this code.  */\n-  if (TYPE_CODE (index_type) == TYPE_CODE_VOID)\n+  if (index_type->code () == TYPE_CODE_VOID)\n     index_type = cu->per_cu->addr_sized_int_type (false);\n \n   return index_type;\n@@ -20717,7 +20717,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  /* Compilation with minimal debug info may result in\n \t     variables with missing type entries.  Change the\n \t     misleading `void' type to something sensible.  */\n-\t  if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_VOID)\n+\t  if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_VOID)\n \t    SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_int;\n \n \t  attr = dwarf2_attr (die, DW_AT_const_value, cu);\n@@ -23639,11 +23639,11 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n      But this is not a problem, because the gnat-specific information\n      is actually not needed for these types.  */\n   if (need_gnat_info (cu)\n-      && TYPE_CODE (type) != TYPE_CODE_FUNC\n-      && TYPE_CODE (type) != TYPE_CODE_FLT\n-      && TYPE_CODE (type) != TYPE_CODE_METHODPTR\n-      && TYPE_CODE (type) != TYPE_CODE_MEMBERPTR\n-      && TYPE_CODE (type) != TYPE_CODE_METHOD\n+      && type->code () != TYPE_CODE_FUNC\n+      && type->code () != TYPE_CODE_FLT\n+      && type->code () != TYPE_CODE_METHODPTR\n+      && type->code () != TYPE_CODE_MEMBERPTR\n+      && type->code () != TYPE_CODE_METHOD\n       && !HAVE_GNAT_AUX_INFO (type))\n     INIT_GNAT_SPECIFIC (type);\n "
    },
    {
      "sha": "7c45df0b3db050cc537404fd3f226600c2be6a42",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 74,
      "deletions": 74,
      "changes": 148,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -302,7 +302,7 @@ evaluate_struct_tuple (struct value *struct_val,\n       if (fieldno >= TYPE_NFIELDS (struct_type))\n \terror (_(\"too many initializers\"));\n       field_type = TYPE_FIELD_TYPE (struct_type, fieldno);\n-      if (TYPE_CODE (field_type) == TYPE_CODE_UNION\n+      if (field_type->code () == TYPE_CODE_UNION\n \t  && TYPE_FIELD_NAME (struct_type, fieldno)[0] == '0')\n \terror (_(\"don't know which variant you want to set\"));\n \n@@ -450,21 +450,21 @@ binop_promote (const struct language_defn *language, struct gdbarch *gdbarch,\n   type1 = check_typedef (value_type (*arg1));\n   type2 = check_typedef (value_type (*arg2));\n \n-  if ((TYPE_CODE (type1) != TYPE_CODE_FLT\n-       && TYPE_CODE (type1) != TYPE_CODE_DECFLOAT\n+  if ((type1->code () != TYPE_CODE_FLT\n+       && type1->code () != TYPE_CODE_DECFLOAT\n        && !is_integral_type (type1))\n-      || (TYPE_CODE (type2) != TYPE_CODE_FLT\n-\t  && TYPE_CODE (type2) != TYPE_CODE_DECFLOAT\n+      || (type2->code () != TYPE_CODE_FLT\n+\t  && type2->code () != TYPE_CODE_DECFLOAT\n \t  && !is_integral_type (type2)))\n     return;\n \n-  if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT\n-      || TYPE_CODE (type2) == TYPE_CODE_DECFLOAT)\n+  if (type1->code () == TYPE_CODE_DECFLOAT\n+      || type2->code () == TYPE_CODE_DECFLOAT)\n     {\n       /* No promotion required.  */\n     }\n-  else if (TYPE_CODE (type1) == TYPE_CODE_FLT\n-\t   || TYPE_CODE (type2) == TYPE_CODE_FLT)\n+  else if (type1->code () == TYPE_CODE_FLT\n+\t   || type2->code () == TYPE_CODE_FLT)\n     {\n       switch (language->la_language)\n \t{\n@@ -489,8 +489,8 @@ binop_promote (const struct language_defn *language, struct gdbarch *gdbarch,\n \t  break;\n \t}\n     }\n-  else if (TYPE_CODE (type1) == TYPE_CODE_BOOL\n-\t   && TYPE_CODE (type2) == TYPE_CODE_BOOL)\n+  else if (type1->code () == TYPE_CODE_BOOL\n+\t   && type2->code () == TYPE_CODE_BOOL)\n     {\n       /* No promotion required.  */\n     }\n@@ -616,7 +616,7 @@ ptrmath_type_p (const struct language_defn *lang, struct type *type)\n   if (TYPE_IS_REFERENCE (type))\n     type = TYPE_TARGET_TYPE (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_FUNC:\n@@ -668,7 +668,7 @@ fake_method::fake_method (type_instance_flags flags,\n \t  --num_types;\n \t  TYPE_VARARGS (type) = 1;\n \t}\n-      else if (TYPE_CODE (check_typedef (param_types[num_types - 1]))\n+      else if (check_typedef (param_types[num_types - 1])->code ()\n \t       == TYPE_CODE_VOID)\n \t{\n \t  --num_types;\n@@ -772,15 +772,15 @@ eval_call (expression *exp, enum noside noside,\n \n       type *ftype = value_type (argvec[0]);\n \n-      if (TYPE_CODE (ftype) == TYPE_CODE_INTERNAL_FUNCTION)\n+      if (ftype->code () == TYPE_CODE_INTERNAL_FUNCTION)\n \t{\n \t  /* We don't know anything about what the internal\n \t     function might return, but we have to return\n \t     something.  */\n \t  return value_zero (builtin_type (exp->gdbarch)->builtin_int,\n \t\t\t     not_lval);\n \t}\n-      else if (TYPE_CODE (ftype) == TYPE_CODE_XMETHOD)\n+      else if (ftype->code () == TYPE_CODE_XMETHOD)\n \t{\n \t  type *return_type\n \t    = result_type_of_xmethod (argvec[0],\n@@ -791,8 +791,8 @@ eval_call (expression *exp, enum noside noside,\n \t    error (_(\"Xmethod is missing return type.\"));\n \t  return value_zero (return_type, not_lval);\n \t}\n-      else if (TYPE_CODE (ftype) == TYPE_CODE_FUNC\n-\t       || TYPE_CODE (ftype) == TYPE_CODE_METHOD)\n+      else if (ftype->code () == TYPE_CODE_FUNC\n+\t       || ftype->code () == TYPE_CODE_METHOD)\n \t{\n \t  if (TYPE_GNU_IFUNC (ftype))\n \t    {\n@@ -817,7 +817,7 @@ eval_call (expression *exp, enum noside noside,\n \terror (_(\"Expression of type other than \"\n \t\t \"\\\"Function returning ...\\\" used as function\"));\n     }\n-  switch (TYPE_CODE (value_type (argvec[0])))\n+  switch (value_type (argvec[0])->code ())\n     {\n     case TYPE_CODE_INTERNAL_FUNCTION:\n       return call_internal_function (exp->gdbarch, exp->language_defn,\n@@ -879,7 +879,7 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n       if (noside == EVAL_SKIP)\n \ttem = 1;  /* Set it to the right arg index so that all\n \t\t     arguments can also be skipped.  */\n-      else if (TYPE_CODE (a1_type) == TYPE_CODE_METHODPTR)\n+      else if (a1_type->code () == TYPE_CODE_METHODPTR)\n \t{\n \t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t    arg1 = value_zero (TYPE_TARGET_TYPE (a1_type), not_lval);\n@@ -891,7 +891,7 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \t  tem = 2;\n \t  argvec[1] = arg2;\n \t}\n-      else if (TYPE_CODE (a1_type) == TYPE_CODE_MEMBERPTR)\n+      else if (a1_type->code () == TYPE_CODE_MEMBERPTR)\n \t{\n \t  struct type *type_ptr\n \t    = lookup_pointer_type (TYPE_SELF_TYPE (a1_type));\n@@ -987,7 +987,7 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \n       function = NULL;\n       function_name = NULL;\n-      if (TYPE_CODE (type) == TYPE_CODE_NAMESPACE)\n+      if (type->code () == TYPE_CODE_NAMESPACE)\n \t{\n \t  function = cp_lookup_symbol_namespace (TYPE_NAME (type),\n \t\t\t\t\t\t name,\n@@ -1002,8 +1002,8 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \t}\n       else\n \t{\n-\t  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t\t      || TYPE_CODE (type) == TYPE_CODE_UNION);\n+\t  gdb_assert (type->code () == TYPE_CODE_STRUCT\n+\t\t      || type->code () == TYPE_CODE_UNION);\n \t  function_name = name;\n \n \t  /* We need a properly typed value for method lookup.  For\n@@ -1054,9 +1054,9 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \n \t  argvec[0] = evaluate_subexp_with_coercion (exp, pos, noside);\n \t  type *type = value_type (argvec[0]);\n-\t  if (type && TYPE_CODE (type) == TYPE_CODE_PTR)\n+\t  if (type && type->code () == TYPE_CODE_PTR)\n \t    type = TYPE_TARGET_TYPE (type);\n-\t  if (type && TYPE_CODE (type) == TYPE_CODE_FUNC)\n+\t  if (type && type->code () == TYPE_CODE_FUNC)\n \t    {\n \t      for (; tem <= nargs && tem <= TYPE_NFIELDS (type); tem++)\n \t\t{\n@@ -1313,7 +1313,7 @@ evaluate_subexp_standard (struct type *expect_type,\n       {\n \t(*pos) += 3;\n \tsymbol *var = exp->elts[pc + 2].symbol;\n-\tif (TYPE_CODE (SYMBOL_TYPE (var)) == TYPE_CODE_ERROR)\n+\tif (SYMBOL_TYPE (var)->code () == TYPE_CODE_ERROR)\n \t  error_unknown_type (var->print_name ());\n \tif (noside != EVAL_SKIP)\n \t    return evaluate_var_value (noside, exp->elts[pc + 1].block, var);\n@@ -1335,7 +1335,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t\t\t\t\t      msymbol);\n \n \ttype = value_type (val);\n-\tif (TYPE_CODE (type) == TYPE_CODE_ERROR\n+\tif (type->code () == TYPE_CODE_ERROR\n \t    && (noside != EVAL_AVOID_SIDE_EFFECTS || pc != 0))\n \t  error_unknown_type (msymbol->print_name ());\n \treturn val;\n@@ -1449,7 +1449,7 @@ evaluate_subexp_standard (struct type *expect_type,\n       type = expect_type ? check_typedef (expect_type) : NULL_TYPE;\n \n       if (expect_type != NULL_TYPE && noside != EVAL_SKIP\n-\t  && TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+\t  && type->code () == TYPE_CODE_STRUCT)\n \t{\n \t  struct value *rec = allocate_value (expect_type);\n \n@@ -1458,7 +1458,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n       if (expect_type != NULL_TYPE && noside != EVAL_SKIP\n-\t  && TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+\t  && type->code () == TYPE_CODE_ARRAY)\n \t{\n \t  struct type *range_type = TYPE_INDEX_TYPE (type);\n \t  struct type *element_type = TYPE_TARGET_TYPE (type);\n@@ -1506,7 +1506,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n       if (expect_type != NULL_TYPE && noside != EVAL_SKIP\n-\t  && TYPE_CODE (type) == TYPE_CODE_SET)\n+\t  && type->code () == TYPE_CODE_SET)\n \t{\n \t  struct value *set = allocate_value (expect_type);\n \t  gdb_byte *valaddr = value_contents_raw (set);\n@@ -1515,8 +1515,8 @@ evaluate_subexp_standard (struct type *expect_type,\n \t  LONGEST low_bound, high_bound;\n \n \t  /* Get targettype of elementtype.  */\n-\t  while (TYPE_CODE (check_type) == TYPE_CODE_RANGE\n-\t\t || TYPE_CODE (check_type) == TYPE_CODE_TYPEDEF)\n+\t  while (check_type->code () == TYPE_CODE_RANGE\n+\t\t || check_type->code () == TYPE_CODE_TYPEDEF)\n \t    check_type = TYPE_TARGET_TYPE (check_type);\n \n \t  if (get_discrete_bounds (element_type, &low_bound, &high_bound) < 0)\n@@ -1535,17 +1535,17 @@ evaluate_subexp_standard (struct type *expect_type,\n \t      /* Check types of elements to avoid mixture of elements from\n \t         different types. Also check if type of element is \"compatible\"\n \t         with element type of powerset.  */\n-\t      if (TYPE_CODE (range_low_type) == TYPE_CODE_RANGE)\n+\t      if (range_low_type->code () == TYPE_CODE_RANGE)\n \t\trange_low_type = TYPE_TARGET_TYPE (range_low_type);\n-\t      if (TYPE_CODE (range_high_type) == TYPE_CODE_RANGE)\n+\t      if (range_high_type->code () == TYPE_CODE_RANGE)\n \t\trange_high_type = TYPE_TARGET_TYPE (range_high_type);\n-\t      if ((TYPE_CODE (range_low_type) != TYPE_CODE (range_high_type))\n-\t\t  || (TYPE_CODE (range_low_type) == TYPE_CODE_ENUM\n+\t      if ((range_low_type->code () != range_high_type->code ())\n+\t\t  || (range_low_type->code () == TYPE_CODE_ENUM\n \t\t      && (range_low_type != range_high_type)))\n \t\t/* different element modes.  */\n \t\terror (_(\"POWERSET tuple elements of different mode\"));\n-\t      if ((TYPE_CODE (check_type) != TYPE_CODE (range_low_type))\n-\t\t  || (TYPE_CODE (check_type) == TYPE_CODE_ENUM\n+\t      if ((check_type->code () != range_low_type->code ())\n+\t\t  || (check_type->code () == TYPE_CODE_ENUM\n \t\t      && range_low_type != check_type))\n \t\terror (_(\"incompatible POWERSET tuple elements\"));\n \t      if (range_low > range_high)\n@@ -1799,9 +1799,9 @@ evaluate_subexp_standard (struct type *expect_type,\n \t    block_for_pc (funaddr);\n \n \t    val_type = check_typedef (val_type);\n-\t  \n-\t    if ((val_type == NULL) \n-\t\t|| (TYPE_CODE(val_type) == TYPE_CODE_ERROR))\n+\n+\t    if ((val_type == NULL)\n+\t\t|| (val_type->code () == TYPE_CODE_ERROR))\n \t      {\n \t\tif (expect_type != NULL)\n \t\t  val_type = expect_type;\n@@ -1815,7 +1815,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t    struct_return = using_struct_return (exp->gdbarch, NULL,\n \t\t\t\t\t\t check_typedef (expect_type));\n \t  }\n-\t\n+\n \t/* Found a function symbol.  Now we will substitute its\n \t   value in place of the message dispatcher (obj_msgSend),\n \t   so that we call the method directly instead of thru\n@@ -1831,7 +1831,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t\n \tif (method)\n \t  {\n-\t    if (TYPE_CODE (value_type (method)) != TYPE_CODE_FUNC)\n+\t    if (value_type (method)->code () != TYPE_CODE_FUNC)\n \t      error (_(\"method address has symbol information \"\n \t\t       \"with non-function type; skipping\"));\n \n@@ -1873,13 +1873,13 @@ evaluate_subexp_standard (struct type *expect_type,\n \n \t    struct type *callee_type = value_type (called_method);\n \n-\t    if (callee_type && TYPE_CODE (callee_type) == TYPE_CODE_PTR)\n+\t    if (callee_type && callee_type->code () == TYPE_CODE_PTR)\n \t      callee_type = TYPE_TARGET_TYPE (callee_type);\n \t    callee_type = TYPE_TARGET_TYPE (callee_type);\n \n \t    if (callee_type)\n \t    {\n-\t      if ((TYPE_CODE (callee_type) == TYPE_CODE_ERROR) && expect_type)\n+\t      if ((callee_type->code () == TYPE_CODE_ERROR) && expect_type)\n \t\treturn allocate_value (expect_type);\n \t      else\n \t\treturn allocate_value (callee_type);\n@@ -1933,7 +1933,7 @@ evaluate_subexp_standard (struct type *expect_type,\n       /* First determine the type code we are dealing with.  */\n       arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n       type = check_typedef (value_type (arg1));\n-      code = TYPE_CODE (type);\n+      code = type->code ();\n \n       if (code == TYPE_CODE_PTR)\n \t{\n@@ -1943,13 +1943,13 @@ evaluate_subexp_standard (struct type *expect_type,\n \t     to the target value the original one points to.  */ \n \t  struct type *target_type = check_typedef (TYPE_TARGET_TYPE (type));\n \n-\t  if (TYPE_CODE (target_type) == TYPE_CODE_ARRAY\n-\t      || TYPE_CODE (target_type) == TYPE_CODE_STRING\n-\t      || TYPE_CODE (target_type) == TYPE_CODE_FUNC)\n+\t  if (target_type->code () == TYPE_CODE_ARRAY\n+\t      || target_type->code () == TYPE_CODE_STRING\n+\t      || target_type->code () == TYPE_CODE_FUNC)\n \t    {\n \t      arg1 = value_ind (arg1);\n \t      type = check_typedef (value_type (arg1));\n-\t      code = TYPE_CODE (type);\n+\t      code = type->code ();\n \t    }\n \t} \n \n@@ -2082,7 +2082,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \n \tget_user_print_options (&opts);\n         if (opts.objectprint && TYPE_TARGET_TYPE (arg_type)\n-            && (TYPE_CODE (TYPE_TARGET_TYPE (arg_type)) == TYPE_CODE_STRUCT))\n+            && (TYPE_TARGET_TYPE (arg_type)->code () == TYPE_CODE_STRUCT))\n           {\n             real_type = value_rtti_indirect_type (arg1, &full, &top,\n \t\t\t\t\t\t  &using_enc);\n@@ -2110,15 +2110,15 @@ evaluate_subexp_standard (struct type *expect_type,\n \treturn eval_skip_value (exp);\n \n       type = check_typedef (value_type (arg2));\n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n \t{\n \tcase TYPE_CODE_METHODPTR:\n \t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t    return value_zero (TYPE_TARGET_TYPE (type), not_lval);\n \t  else\n \t    {\n \t      arg2 = cplus_method_ptr_to_value (&arg1, arg2);\n-\t      gdb_assert (TYPE_CODE (value_type (arg2)) == TYPE_CODE_PTR);\n+\t      gdb_assert (value_type (arg2)->code () == TYPE_CODE_PTR);\n \t      return value_ind (arg2);\n \t    }\n \n@@ -2324,8 +2324,8 @@ evaluate_subexp_standard (struct type *expect_type,\n \n \t  arg1 = coerce_ref (arg1);\n \t  type = check_typedef (value_type (arg1));\n-\t  if (TYPE_CODE (type) != TYPE_CODE_ARRAY\n-\t      && TYPE_CODE (type) != TYPE_CODE_PTR)\n+\t  if (type->code () != TYPE_CODE_ARRAY\n+\t      && type->code () != TYPE_CODE_PTR)\n \t    {\n \t      if (TYPE_NAME (type))\n \t\terror (_(\"cannot subscript something of type `%s'\"),\n@@ -2383,7 +2383,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t      arg1 = coerce_ref (arg1);\n \t      type = check_typedef (value_type (arg1));\n \n-\t      switch (TYPE_CODE (type))\n+\t      switch (type->code ())\n \t\t{\n \t\tcase TYPE_CODE_PTR:\n \t\tcase TYPE_CODE_ARRAY:\n@@ -2607,8 +2607,8 @@ evaluate_subexp_standard (struct type *expect_type,\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       type = check_typedef (value_type (arg2));\n-      if (TYPE_CODE (type) != TYPE_CODE_INT\n-          && TYPE_CODE (type) != TYPE_CODE_ENUM)\n+      if (type->code () != TYPE_CODE_INT\n+          && type->code () != TYPE_CODE_ENUM)\n \terror (_(\"Non-integral right operand for \\\"@\\\" operator.\"));\n       if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t{\n@@ -2673,12 +2673,12 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case UNOP_IND:\n-      if (expect_type && TYPE_CODE (expect_type) == TYPE_CODE_PTR)\n+      if (expect_type && expect_type->code () == TYPE_CODE_PTR)\n \texpect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));\n       arg1 = evaluate_subexp (expect_type, exp, pos, noside);\n       type = check_typedef (value_type (arg1));\n-      if (TYPE_CODE (type) == TYPE_CODE_METHODPTR\n-\t  || TYPE_CODE (type) == TYPE_CODE_MEMBERPTR)\n+      if (type->code () == TYPE_CODE_METHODPTR\n+\t  || type->code () == TYPE_CODE_MEMBERPTR)\n \terror (_(\"Attempt to dereference pointer \"\n \t\t \"to member without an object\"));\n       if (noside == EVAL_SKIP)\n@@ -2688,14 +2688,14 @@ evaluate_subexp_standard (struct type *expect_type,\n       else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t{\n \t  type = check_typedef (value_type (arg1));\n-\t  if (TYPE_CODE (type) == TYPE_CODE_PTR\n+\t  if (type->code () == TYPE_CODE_PTR\n \t      || TYPE_IS_REFERENCE (type)\n \t  /* In C you can dereference an array to get the 1st elt.  */\n-\t      || TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t      || type->code () == TYPE_CODE_ARRAY\n \t    )\n \t    return value_zero (TYPE_TARGET_TYPE (type),\n \t\t\t       lval_memory);\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_INT)\n+\t  else if (type->code () == TYPE_CODE_INT)\n \t    /* GDB allows dereferencing an int.  */\n \t    return value_zero (builtin_type (exp->gdbarch)->builtin_int,\n \t\t\t       lval_memory);\n@@ -2707,7 +2707,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t This returns an int, which seems like the most C-like thing to\n \t do.  \"long long\" variables are rare enough that\n \t BUILTIN_TYPE_LONGEST would seem to be a mistake.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_INT)\n+      if (type->code () == TYPE_CODE_INT)\n \treturn value_at_lazy (builtin_type (exp->gdbarch)->builtin_int,\n \t\t\t      (CORE_ADDR) value_as_address (arg1));\n       return value_ind (arg1);\n@@ -3140,7 +3140,7 @@ evaluate_subexp_with_coercion (struct expression *exp,\n     case OP_VAR_VALUE:\n       var = exp->elts[pc + 2].symbol;\n       type = check_typedef (SYMBOL_TYPE (var));\n-      if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+      if (type->code () == TYPE_CODE_ARRAY\n \t  && !TYPE_VECTOR (type)\n \t  && CAST_IS_CONVERSION (exp->language_defn))\n \t{\n@@ -3186,9 +3186,9 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n       (*pos)++;\n       val = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n       type = check_typedef (value_type (val));\n-      if (TYPE_CODE (type) != TYPE_CODE_PTR\n+      if (type->code () != TYPE_CODE_PTR\n \t  && !TYPE_IS_REFERENCE (type)\n-\t  && TYPE_CODE (type) != TYPE_CODE_ARRAY)\n+\t  && type->code () != TYPE_CODE_ARRAY)\n \terror (_(\"Attempt to take contents of a non-pointer value.\"));\n       type = TYPE_TARGET_TYPE (type);\n       if (is_dynamic_type (type))\n@@ -3212,7 +3212,7 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n \t{\n \t  val = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_NORMAL);\n \t  type = value_type (val);\n-\t  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t  if (type->code () == TYPE_CODE_ARRAY\n               && is_dynamic_type (TYPE_INDEX_TYPE (type))\n               && TYPE_HIGH_BOUND_UNDEFINED (TYPE_INDEX_TYPE (type)))\n \t    return allocate_optimized_out_value (size_type);\n@@ -3231,7 +3231,7 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n \t\t\t\t\t       msymbol);\n \n \ttype = value_type (mval);\n-\tif (TYPE_CODE (type) == TYPE_CODE_ERROR)\n+\tif (type->code () == TYPE_CODE_ERROR)\n \t  error_unknown_type (msymbol->print_name ());\n \n \treturn value_from_longest (size_type, TYPE_LENGTH (type));\n@@ -3249,10 +3249,10 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n \n \t  val = evaluate_subexp (NULL_TYPE, exp, &npc, EVAL_AVOID_SIDE_EFFECTS);\n \t  type = check_typedef (value_type (val));\n-\t  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+\t  if (type->code () == TYPE_CODE_ARRAY)\n \t    {\n \t      type = check_typedef (TYPE_TARGET_TYPE (type));\n-\t      if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+\t      if (type->code () == TYPE_CODE_ARRAY)\n \t\t{\n \t\t  type = TYPE_INDEX_TYPE (type);\n \t\t  /* Only re-evaluate the right hand side if the resulting type\n@@ -3364,14 +3364,14 @@ calc_f77_array_dims (struct type *array_type)\n   int ndimen = 1;\n   struct type *tmp_type;\n \n-  if ((TYPE_CODE (array_type) != TYPE_CODE_ARRAY))\n+  if ((array_type->code () != TYPE_CODE_ARRAY))\n     error (_(\"Can't get dimensions for a non-array type\"));\n \n   tmp_type = array_type;\n \n   while ((tmp_type = TYPE_TARGET_TYPE (tmp_type)))\n     {\n-      if (TYPE_CODE (tmp_type) == TYPE_CODE_ARRAY)\n+      if (tmp_type->code () == TYPE_CODE_ARRAY)\n \t++ndimen;\n     }\n   return ndimen;"
    },
    {
      "sha": "a190d8ce21be9588b54b347710773faa9ab46b0e",
      "filename": "gdb/expprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/expprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/expprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -448,7 +448,7 @@ print_subexp_standard (struct expression *exp, int *pos,\n       (*pos) += 2;\n       if ((int) prec > (int) PREC_PREFIX)\n \tfputs_filtered (\"(\", stream);\n-      if (TYPE_CODE (exp->elts[pc + 1].type) == TYPE_CODE_FUNC\n+      if (exp->elts[pc + 1].type->code () == TYPE_CODE_FUNC\n \t  && exp->elts[pc + 3].opcode == OP_LONG)\n \t{\n \t  struct value_print_options opts;"
    },
    {
      "sha": "3c3e6ab34ba6d7ea1064879506e4addbde116211",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -268,7 +268,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       type = value_type (arg1);\n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n \t{\n \tcase TYPE_CODE_FLT:\n \t  {\n@@ -292,9 +292,9 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       type = value_type (arg1);\n-      if (TYPE_CODE (type) != TYPE_CODE (value_type (arg2)))\n+      if (type->code () != value_type (arg2)->code ())\n \terror (_(\"non-matching types for parameters to MOD ()\"));\n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n \t{\n \tcase TYPE_CODE_FLT:\n \t  {\n@@ -325,7 +325,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \tif (noside == EVAL_SKIP)\n \t  return eval_skip_value (exp);\n \ttype = value_type (arg1);\n-\tif (TYPE_CODE (type) != TYPE_CODE_FLT)\n+\tif (type->code () != TYPE_CODE_FLT)\n \t  error (_(\"argument to CEILING must be of type float\"));\n \tdouble val\n \t  = target_float_to_host_double (value_contents (arg1),\n@@ -340,7 +340,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \tif (noside == EVAL_SKIP)\n \t  return eval_skip_value (exp);\n \ttype = value_type (arg1);\n-\tif (TYPE_CODE (type) != TYPE_CODE_FLT)\n+\tif (type->code () != TYPE_CODE_FLT)\n \t  error (_(\"argument to FLOOR must be of type float\"));\n \tdouble val\n \t  = target_float_to_host_double (value_contents (arg1),\n@@ -356,10 +356,10 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \tif (noside == EVAL_SKIP)\n \t  return eval_skip_value (exp);\n \ttype = value_type (arg1);\n-\tif (TYPE_CODE (type) != TYPE_CODE (value_type (arg2)))\n+\tif (type->code () != value_type (arg2)->code ())\n \t  error (_(\"non-matching types for parameters to MODULO ()\"));\n         /* MODULO(A, P) = A - FLOOR (A / P) * P */\n-\tswitch (TYPE_CODE (type))\n+\tswitch (type->code ())\n \t  {\n \t  case TYPE_CODE_INT:\n \t    {\n@@ -399,7 +399,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n       arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n       type = value_type (arg1);\n \n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n         {\n           case TYPE_CODE_STRUCT:\n           case TYPE_CODE_UNION:\n@@ -412,7 +412,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n         return value_from_longest (builtin_type (exp->gdbarch)->builtin_int,\n \t\t\t\t   TYPE_LENGTH (type));\n       return value_from_longest (builtin_type (exp->gdbarch)->builtin_int,\n-\t\t\t\t TYPE_LENGTH (TYPE_TARGET_TYPE(type)));\n+\t\t\t\t TYPE_LENGTH (TYPE_TARGET_TYPE (type)));\n     }\n \n   /* Should be unreachable.  */\n@@ -425,9 +425,9 @@ static bool\n f_is_string_type_p (struct type *type)\n {\n   type = check_typedef (type);\n-  return (TYPE_CODE (type) == TYPE_CODE_STRING\n-\t  || (TYPE_CODE (type) == TYPE_CODE_ARRAY\n-\t      && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_CHAR));\n+  return (type->code () == TYPE_CODE_STRING\n+\t  || (type->code () == TYPE_CODE_ARRAY\n+\t      && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_CHAR));\n }\n \n /* Special expression lengths for Fortran.  */\n@@ -745,7 +745,7 @@ build_fortran_types (struct gdbarch *gdbarch)\n   builtin_f_type->builtin_complex_s16\n     = init_complex_type (\"complex*16\", builtin_f_type->builtin_real_s8);\n \n-  if (TYPE_CODE (builtin_f_type->builtin_real_s16) == TYPE_CODE_ERROR)\n+  if (builtin_f_type->builtin_real_s16->code () == TYPE_CODE_ERROR)\n     builtin_f_type->builtin_complex_s32\n       = arch_type (gdbarch, TYPE_CODE_ERROR, 256, \"complex*32\");\n   else\n@@ -802,7 +802,7 @@ fortran_argument_convert (struct value *value, bool is_artificial)\n struct type *\n fortran_preserve_arg_pointer (struct value *arg, struct type *type)\n {\n-  if (TYPE_CODE (value_type (arg)) == TYPE_CODE_PTR)\n+  if (value_type (arg)->code () == TYPE_CODE_PTR)\n     return value_type (arg);\n   return type;\n }"
    },
    {
      "sha": "200896b6d05d2bce76263bb7961d33e3cec96203",
      "filename": "gdb/f-typeprint.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/f-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/f-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-typeprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -65,7 +65,7 @@ f_print_type (struct type *type, const char *varstring, struct ui_file *stream,\n   enum type_code code;\n \n   f_type_print_base (type, stream, show, level);\n-  code = TYPE_CODE (type);\n+  code = type->code ();\n   if ((varstring != NULL && *varstring != '\\0')\n       /* Need a space if going to print stars or brackets; but not if we\n \t will print just a type name.  */\n@@ -76,10 +76,10 @@ f_print_type (struct type *type, const char *varstring, struct ui_file *stream,\n \t      || code == TYPE_CODE_ARRAY\n \t      || ((code == TYPE_CODE_PTR\n \t\t   || code == TYPE_CODE_REF)\n-\t\t  && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC\n-\t\t      || (TYPE_CODE (TYPE_TARGET_TYPE (type))\n+\t\t  && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC\n+\t\t      || (TYPE_TARGET_TYPE (type)->code ()\n \t\t\t  == TYPE_CODE_METHOD)\n-\t\t      || (TYPE_CODE (TYPE_TARGET_TYPE (type))\n+\t\t      || (TYPE_TARGET_TYPE (type)->code ()\n \t\t\t  == TYPE_CODE_ARRAY))))))\n     fputs_filtered (\" \", stream);\n   f_type_print_varspec_prefix (type, stream, show, 0);\n@@ -119,7 +119,7 @@ f_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n \n   QUIT;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n       f_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1);\n@@ -183,7 +183,7 @@ f_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n \n   QUIT;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       arrayprint_recurse_level++;\n@@ -207,7 +207,7 @@ f_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n \t  print_rank_only = true;\n \t}\n \n-      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY)\n+      if (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ARRAY)\n \tf_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0,\n \t\t\t\t     0, 0, arrayprint_recurse_level,\n \t\t\t\t     print_rank_only);\n@@ -233,7 +233,7 @@ f_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n \t    }\n \t}\n \n-      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_ARRAY)\n+      if (TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_ARRAY)\n \tf_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0,\n \t\t\t\t     0, 0, arrayprint_recurse_level,\n \t\t\t\t     print_rank_only);\n@@ -335,18 +335,18 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n   if ((show <= 0) && (TYPE_NAME (type) != NULL))\n     {\n       const char *prefix = \"\";\n-      if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+      if (type->code () == TYPE_CODE_UNION)\n \tprefix = \"Type, C_Union :: \";\n-      else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      else if (type->code () == TYPE_CODE_STRUCT)\n \tprefix = \"Type \";\n       fprintfi_filtered (level, stream, \"%s%s\", prefix, TYPE_NAME (type));\n       return;\n     }\n \n-  if (TYPE_CODE (type) != TYPE_CODE_TYPEDEF)\n+  if (type->code () != TYPE_CODE_TYPEDEF)\n     type = check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_TYPEDEF:\n       f_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);\n@@ -420,7 +420,7 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n \n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n-      if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+      if (type->code () == TYPE_CODE_UNION)\n \tfprintfi_filtered (level, stream, \"Type, C_Union :: \");\n       else\n \tfprintfi_filtered (level, stream, \"Type \");\n@@ -459,7 +459,7 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n       if (TYPE_NAME (type) != NULL)\n \tfprintfi_filtered (level, stream, \"%s\", TYPE_NAME (type));\n       else\n-\terror (_(\"Invalid type code (%d) in symbol table.\"), TYPE_CODE (type));\n+\terror (_(\"Invalid type code (%d) in symbol table.\"), type->code ());\n       break;\n     }\n "
    },
    {
      "sha": "76981fa4117163f3d3cfd2cdf970f49db0d1cb9c",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -85,8 +85,8 @@ f77_get_dynamic_length_of_aggregate (struct type *type)\n      This function also works for strings which behave very \n      similarly to arrays.  */\n \n-  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY\n-      || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_STRING)\n+  if (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ARRAY\n+      || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_STRING)\n     f77_get_dynamic_length_of_aggregate (TYPE_TARGET_TYPE (type));\n \n   /* Recursion ends here, start setting up lengths.  */\n@@ -223,7 +223,7 @@ f_value_print_innner (struct value *val, struct ui_file *stream, int recurse,\n   const gdb_byte *valaddr = value_contents_for_printing (val);\n   const CORE_ADDR address = value_address (val);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRING:\n       f77_get_dynamic_length_of_aggregate (type);\n@@ -232,7 +232,7 @@ f_value_print_innner (struct value *val, struct ui_file *stream, int recurse,\n       break;\n \n     case TYPE_CODE_ARRAY:\n-      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_CHAR)\n+      if (TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_CHAR)\n \t{\n \t  fprintf_filtered (stream, \"(\");\n \t  f77_print_array (type, valaddr, 0,\n@@ -263,7 +263,7 @@ f_value_print_innner (struct value *val, struct ui_file *stream, int recurse,\n \t  addr = unpack_pointer (type, valaddr);\n \t  elttype = check_typedef (TYPE_TARGET_TYPE (type));\n \n-\t  if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)\n+\t  if (elttype->code () == TYPE_CODE_FUNC)\n \t    {\n \t      /* Try to print what function it points to.  */\n \t      print_function_pointer_address (options, gdbarch, addr, stream);\n@@ -282,7 +282,7 @@ f_value_print_innner (struct value *val, struct ui_file *stream, int recurse,\n \t  /* For a pointer to char or unsigned char, also print the string\n \t     pointed to, unless pointer is null.  */\n \t  if (TYPE_LENGTH (elttype) == 1\n-\t      && TYPE_CODE (elttype) == TYPE_CODE_INT\n+\t      && elttype->code () == TYPE_CODE_INT\n \t      && (options->format == 0 || options->format == 's')\n \t      && addr != 0)\n \t    {\n@@ -320,7 +320,7 @@ f_value_print_innner (struct value *val, struct ui_file *stream, int recurse,\n \t  struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, index));\n \n \n-\t  if (TYPE_CODE (field_type) != TYPE_CODE_FUNC)\n+\t  if (field_type->code () != TYPE_CODE_FUNC)\n \t    {\n \t      const char *field_name;\n "
    },
    {
      "sha": "5deb251a3acf13ac45cadb4163da3d82738816b7",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1983,9 +1983,9 @@ fbsd_fetch_rtld_offsets (struct gdbarch *gdbarch, struct fbsd_pspace_data *data)\n \t\t\t\t     language_c, NULL).symbol;\n       if (obj_entry_sym == NULL)\n \terror (_(\"Unable to find Struct_Obj_Entry symbol\"));\n-      data->off_linkmap = lookup_struct_elt (SYMBOL_TYPE(obj_entry_sym),\n+      data->off_linkmap = lookup_struct_elt (SYMBOL_TYPE (obj_entry_sym),\n \t\t\t\t\t     \"linkmap\", 0).offset / 8;\n-      data->off_tlsindex = lookup_struct_elt (SYMBOL_TYPE(obj_entry_sym),\n+      data->off_tlsindex = lookup_struct_elt (SYMBOL_TYPE (obj_entry_sym),\n \t\t\t\t\t      \"tlsindex\", 0).offset / 8;\n       data->rtld_offsets_valid = true;\n       return;"
    },
    {
      "sha": "40cbe8b48f42a03d9d93806454137ab0fe48a21d",
      "filename": "gdb/findvar.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/findvar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/findvar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/findvar.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -153,7 +153,7 @@ extract_long_unsigned_integer (const gdb_byte *addr, int orig_len,\n CORE_ADDR\n extract_typed_address (const gdb_byte *buf, struct type *type)\n {\n-  if (TYPE_CODE (type) != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n+  if (type->code () != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n     internal_error (__FILE__, __LINE__,\n \t\t    _(\"extract_typed_address: \"\n \t\t    \"type is not a pointer or reference\"));\n@@ -206,7 +206,7 @@ template void store_integer (gdb_byte *addr, int len,\n void\n store_typed_address (gdb_byte *buf, struct type *type, CORE_ADDR addr)\n {\n-  if (TYPE_CODE (type) != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n+  if (type->code () != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n     internal_error (__FILE__, __LINE__,\n \t\t    _(\"store_typed_address: \"\n \t\t    \"type is not a pointer or reference\"));\n@@ -257,7 +257,7 @@ copy_integer_to_size (gdb_byte *dest, int dest_size, const gdb_byte *source,\n \n /* Return a `value' with the contents of (virtual or cooked) register\n    REGNUM as found in the specified FRAME.  The register's type is\n-   determined by register_type().  */\n+   determined by register_type ().  */\n \n struct value *\n value_of_register (int regnum, struct frame_info *frame)\n@@ -277,7 +277,7 @@ value_of_register (int regnum, struct frame_info *frame)\n \n /* Return a `value' with the contents of (virtual or cooked) register\n    REGNUM as found in the specified FRAME.  The register's type is\n-   determined by register_type().  The value is not fetched.  */\n+   determined by register_type ().  The value is not fetched.  */\n \n struct value *\n value_of_register_lazy (struct frame_info *frame, int regnum)"
    },
    {
      "sha": "fd76e522ba50fd8c3d7ca11d1cbe2a7b2a65bac8",
      "filename": "gdb/frv-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/frv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/frv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frv-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1240,7 +1240,7 @@ frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       arg = args[argnum];\n       arg_type = check_typedef (value_type (arg));\n       len = TYPE_LENGTH (arg_type);\n-      typecode = TYPE_CODE (arg_type);\n+      typecode = arg_type->code ();\n \n       if (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)\n \t{\n@@ -1253,7 +1253,7 @@ frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       else if (abi == FRV_ABI_FDPIC\n \t       && len == 4\n                && typecode == TYPE_CODE_PTR\n-               && TYPE_CODE (TYPE_TARGET_TYPE (arg_type)) == TYPE_CODE_FUNC)\n+               && TYPE_TARGET_TYPE (arg_type)->code () == TYPE_CODE_FUNC)\n \t{\n \t  /* The FDPIC ABI requires function descriptors to be passed instead\n \t     of entry points.  */\n@@ -1345,9 +1345,9 @@ frv_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t  struct type *valtype, struct regcache *regcache,\n \t\t  gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  int struct_return = TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-\t\t      || TYPE_CODE (valtype) == TYPE_CODE_UNION\n-\t\t      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY;\n+  int struct_return = valtype->code () == TYPE_CODE_STRUCT\n+\t\t      || valtype->code () == TYPE_CODE_UNION\n+\t\t      || valtype->code () == TYPE_CODE_ARRAY;\n \n   if (writebuf != NULL)\n     {"
    },
    {
      "sha": "24a7515a3151d677f54e654f38c71d8a55cb2aaf",
      "filename": "gdb/gdbarch-selftests.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gdbarch-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gdbarch-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch-selftests.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -118,7 +118,7 @@ register_to_value_test (struct gdbarch *gdbarch)\n \t    {\n \t      std::vector<gdb_byte> expected (TYPE_LENGTH (type), 0);\n \n-\t      if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+\t      if (type->code () == TYPE_CODE_FLT)\n \t\t{\n \t\t  /* Generate valid float format.  */\n \t\t  target_float_from_string (expected.data (), type, \"1.25\");"
    },
    {
      "sha": "8f45af6ae7a0d407258b93f911086bec277f6502",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 103,
      "deletions": 103,
      "changes": 206,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -550,7 +550,7 @@ lookup_function_type_with_arguments (struct type *type,\n \t  --nparams;\n \t  TYPE_VARARGS (fn) = 1;\n \t}\n-      else if (TYPE_CODE (check_typedef (param_types[nparams - 1]))\n+      else if (check_typedef (param_types[nparams - 1])->code ()\n \t       == TYPE_CODE_VOID)\n \t{\n \t  --nparams;\n@@ -923,7 +923,7 @@ create_range_type (struct type *result_type, struct type *index_type,\n {\n   /* The INDEX_TYPE should be a type capable of holding the upper and lower\n      bounds, as such a zero sized, or void type makes no sense.  */\n-  gdb_assert (TYPE_CODE (index_type) != TYPE_CODE_VOID);\n+  gdb_assert (index_type->code () != TYPE_CODE_VOID);\n   gdb_assert (TYPE_LENGTH (index_type) > 0);\n \n   if (result_type == NULL)\n@@ -1033,7 +1033,7 @@ int\n get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n {\n   type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_RANGE:\n       *lowp = TYPE_LOW_BOUND (type);\n@@ -1155,7 +1155,7 @@ get_array_bounds (struct type *type, LONGEST *low_bound, LONGEST *high_bound)\n int\n discrete_position (struct type *type, LONGEST val, LONGEST *pos)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_ENUM)\n+  if (type->code () == TYPE_CODE_ENUM)\n     {\n       int i;\n \n@@ -1184,7 +1184,7 @@ discrete_position (struct type *type, LONGEST val, LONGEST *pos)\n static bool\n update_static_array_size (struct type *type)\n {\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_ARRAY);\n+  gdb_assert (type->code () == TYPE_CODE_ARRAY);\n \n   struct type *range_type = TYPE_INDEX_TYPE (type);\n \n@@ -1413,11 +1413,11 @@ make_vector_type (struct type *array_type)\n   /* Find the innermost array type, in case the array is\n      multi-dimensional.  */\n   inner_array = array_type;\n-  while (TYPE_CODE (TYPE_TARGET_TYPE (inner_array)) == TYPE_CODE_ARRAY)\n+  while (TYPE_TARGET_TYPE (inner_array)->code () == TYPE_CODE_ARRAY)\n     inner_array = TYPE_TARGET_TYPE (inner_array);\n \n   elt_type = TYPE_TARGET_TYPE (inner_array);\n-  if (TYPE_CODE (elt_type) == TYPE_CODE_INT)\n+  if (elt_type->code () == TYPE_CODE_INT)\n     {\n       flags = TYPE_INSTANCE_FLAGS (elt_type) | TYPE_INSTANCE_FLAG_NOTTEXT;\n       elt_type = make_qualified_type (elt_type, flags, NULL);\n@@ -1446,7 +1446,7 @@ init_vector_type (struct type *elt_type, int n)\n struct type *\n internal_type_self_type (struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_METHODPTR:\n     case TYPE_CODE_MEMBERPTR:\n@@ -1472,7 +1472,7 @@ internal_type_self_type (struct type *type)\n void\n set_type_self_type (struct type *type, struct type *self_type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_METHODPTR:\n     case TYPE_CODE_MEMBERPTR:\n@@ -1644,7 +1644,7 @@ lookup_struct (const char *name, const struct block *block)\n     {\n       error (_(\"No struct type named %s.\"), name);\n     }\n-  if (TYPE_CODE (SYMBOL_TYPE (sym)) != TYPE_CODE_STRUCT)\n+  if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_STRUCT)\n     {\n       error (_(\"This context has class, union or enum %s, not a struct.\"),\n \t     name);\n@@ -1668,7 +1668,7 @@ lookup_union (const char *name, const struct block *block)\n \n   t = SYMBOL_TYPE (sym);\n \n-  if (TYPE_CODE (t) == TYPE_CODE_UNION)\n+  if (t->code () == TYPE_CODE_UNION)\n     return t;\n \n   /* If we get here, it's not a union.  */\n@@ -1689,7 +1689,7 @@ lookup_enum (const char *name, const struct block *block)\n     {\n       error (_(\"No enum type named %s.\"), name);\n     }\n-  if (TYPE_CODE (SYMBOL_TYPE (sym)) != TYPE_CODE_ENUM)\n+  if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_ENUM)\n     {\n       error (_(\"This context has class, struct or union %s, not an enum.\"), \n \t     name);\n@@ -1719,7 +1719,7 @@ lookup_template_type (const char *name, struct type *type,\n     {\n       error (_(\"No template type named %s.\"), name);\n     }\n-  if (TYPE_CODE (SYMBOL_TYPE (sym)) != TYPE_CODE_STRUCT)\n+  if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_STRUCT)\n     {\n       error (_(\"This context has class, union or enum %s, not a struct.\"),\n \t     name);\n@@ -1737,14 +1737,14 @@ lookup_struct_elt (struct type *type, const char *name, int noerr)\n   for (;;)\n     {\n       type = check_typedef (type);\n-      if (TYPE_CODE (type) != TYPE_CODE_PTR\n-\t  && TYPE_CODE (type) != TYPE_CODE_REF)\n+      if (type->code () != TYPE_CODE_PTR\n+\t  && type->code () != TYPE_CODE_REF)\n \tbreak;\n       type = TYPE_TARGET_TYPE (type);\n     }\n \n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT \n-      && TYPE_CODE (type) != TYPE_CODE_UNION)\n+  if (type->code () != TYPE_CODE_STRUCT\n+      && type->code () != TYPE_CODE_UNION)\n     {\n       std::string type_name = type_to_string (type);\n       error (_(\"Type %s is not a structure or union type.\"),\n@@ -1807,7 +1807,7 @@ get_unsigned_type_max (struct type *type, ULONGEST *max)\n   unsigned int n;\n \n   type = check_typedef (type);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_INT && TYPE_UNSIGNED (type));\n+  gdb_assert (type->code () == TYPE_CODE_INT && TYPE_UNSIGNED (type));\n   gdb_assert (TYPE_LENGTH (type) <= sizeof (ULONGEST));\n \n   /* Written this way to avoid overflow.  */\n@@ -1824,7 +1824,7 @@ get_signed_type_minmax (struct type *type, LONGEST *min, LONGEST *max)\n   unsigned int n;\n \n   type = check_typedef (type);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_INT && !TYPE_UNSIGNED (type));\n+  gdb_assert (type->code () == TYPE_CODE_INT && !TYPE_UNSIGNED (type));\n   gdb_assert (TYPE_LENGTH (type) <= sizeof (LONGEST));\n \n   n = TYPE_LENGTH (type) * TARGET_CHAR_BIT;\n@@ -1843,8 +1843,8 @@ int\n internal_type_vptr_fieldno (struct type *type)\n {\n   type = check_typedef (type);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (type) == TYPE_CODE_UNION);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT\n+\t      || type->code () == TYPE_CODE_UNION);\n   if (!HAVE_CPLUS_STRUCT (type))\n     return -1;\n   return TYPE_RAW_CPLUS_SPECIFIC (type)->vptr_fieldno;\n@@ -1856,8 +1856,8 @@ void\n set_type_vptr_fieldno (struct type *type, int fieldno)\n {\n   type = check_typedef (type);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (type) == TYPE_CODE_UNION);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT\n+\t      || type->code () == TYPE_CODE_UNION);\n   if (!HAVE_CPLUS_STRUCT (type))\n     ALLOCATE_CPLUS_STRUCT_TYPE (type);\n   TYPE_RAW_CPLUS_SPECIFIC (type)->vptr_fieldno = fieldno;\n@@ -1870,8 +1870,8 @@ struct type *\n internal_type_vptr_basetype (struct type *type)\n {\n   type = check_typedef (type);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (type) == TYPE_CODE_UNION);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT\n+\t      || type->code () == TYPE_CODE_UNION);\n   gdb_assert (TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_CPLUS_STUFF);\n   return TYPE_RAW_CPLUS_SPECIFIC (type)->vptr_basetype;\n }\n@@ -1882,8 +1882,8 @@ void\n set_type_vptr_basetype (struct type *type, struct type *basetype)\n {\n   type = check_typedef (type);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (type) == TYPE_CODE_UNION);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT\n+\t      || type->code () == TYPE_CODE_UNION);\n   if (!HAVE_CPLUS_STRUCT (type))\n     ALLOCATE_CPLUS_STRUCT_TYPE (type);\n   TYPE_RAW_CPLUS_SPECIFIC (type)->vptr_basetype = basetype;\n@@ -1970,7 +1970,7 @@ is_dynamic_type_internal (struct type *type, int top_level)\n   type = check_typedef (type);\n \n   /* We only want to recognize references at the outermost level.  */\n-  if (top_level && TYPE_CODE (type) == TYPE_CODE_REF)\n+  if (top_level && type->code () == TYPE_CODE_REF)\n     type = check_typedef (TYPE_TARGET_TYPE (type));\n \n   /* Types that have a dynamic TYPE_DATA_LOCATION are considered\n@@ -1997,7 +1997,7 @@ is_dynamic_type_internal (struct type *type, int top_level)\n   if (TYPE_HAS_DYNAMIC_LENGTH (type))\n     return 1;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_RANGE:\n       {\n@@ -2086,7 +2086,7 @@ resolve_dynamic_range (struct type *dyn_range_type,\n   const struct dynamic_prop *prop;\n   struct dynamic_prop low_bound, high_bound, stride;\n \n-  gdb_assert (TYPE_CODE (dyn_range_type) == TYPE_CODE_RANGE);\n+  gdb_assert (dyn_range_type->code () == TYPE_CODE_RANGE);\n \n   prop = &TYPE_RANGE_DATA (dyn_range_type)->low;\n   if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n@@ -2168,8 +2168,8 @@ resolve_dynamic_array_or_string (struct type *type,\n \n   /* For dynamic type resolution strings can be treated like arrays of\n      characters.  */\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_ARRAY\n-\t      || TYPE_CODE (type) == TYPE_CODE_STRING);\n+  gdb_assert (type->code () == TYPE_CODE_ARRAY\n+\t      || type->code () == TYPE_CODE_STRING);\n \n   type = copy_type (type);\n \n@@ -2194,7 +2194,7 @@ resolve_dynamic_array_or_string (struct type *type,\n \n   ary_dim = check_typedef (TYPE_TARGET_TYPE (elt_type));\n \n-  if (ary_dim != NULL && TYPE_CODE (ary_dim) == TYPE_CODE_ARRAY)\n+  if (ary_dim != NULL && ary_dim->code () == TYPE_CODE_ARRAY)\n     elt_type = resolve_dynamic_array_or_string (ary_dim, addr_stack);\n   else\n     elt_type = TYPE_TARGET_TYPE (type);\n@@ -2235,7 +2235,7 @@ resolve_dynamic_union (struct type *type,\n   int i;\n   unsigned int max_len = 0;\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_UNION);\n+  gdb_assert (type->code () == TYPE_CODE_UNION);\n \n   resolved_type = copy_type (type);\n   TYPE_FIELDS (resolved_type)\n@@ -2431,7 +2431,7 @@ resolve_dynamic_struct (struct type *type,\n   int i;\n   unsigned resolved_type_bit_length = 0;\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT);\n   gdb_assert (TYPE_NFIELDS (type) > 0);\n \n   resolved_type = copy_type (type);\n@@ -2560,7 +2560,7 @@ resolve_dynamic_type_internal (struct type *type,\n       && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n     type_length = value;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+  if (type->code () == TYPE_CODE_TYPEDEF)\n     {\n       resolved_type = copy_type (type);\n       TYPE_TARGET_TYPE (resolved_type)\n@@ -2572,7 +2572,7 @@ resolve_dynamic_type_internal (struct type *type,\n       /* Before trying to resolve TYPE, make sure it is not a stub.  */\n       type = real_type;\n \n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n \t{\n \tcase TYPE_CODE_REF:\n \t  {\n@@ -2752,7 +2752,7 @@ check_typedef (struct type *type)\n \n   gdb_assert (type);\n \n-  while (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+  while (type->code () == TYPE_CODE_TYPEDEF)\n     {\n       if (!TYPE_TARGET_TYPE (type))\n \t{\n@@ -2867,7 +2867,7 @@ check_typedef (struct type *type)\n           /* Same as above for opaque types, we can replace the stub\n              with the complete type only if they are in the same\n              objfile.  */\n-\t  if (TYPE_OBJFILE (SYMBOL_TYPE(sym)) == TYPE_OBJFILE (type))\n+\t  if (TYPE_OBJFILE (SYMBOL_TYPE (sym)) == TYPE_OBJFILE (type))\n             type = make_qualified_type (SYMBOL_TYPE (sym),\n \t\t\t\t\tTYPE_INSTANCE_FLAGS (type),\n \t\t\t\t\ttype);\n@@ -2884,12 +2884,12 @@ check_typedef (struct type *type)\n \t{\n \t  /* Nothing we can do.  */\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_RANGE)\n+      else if (type->code () == TYPE_CODE_RANGE)\n \t{\n \t  TYPE_LENGTH (type) = TYPE_LENGTH (target_type);\n \t  TYPE_TARGET_STUB (type) = 0;\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+      else if (type->code () == TYPE_CODE_ARRAY\n \t       && update_static_array_size (type))\n \tTYPE_TARGET_STUB (type) = 0;\n     }\n@@ -3153,7 +3153,7 @@ verify_floatformat (int bit, const struct floatformat *floatformat)\n const struct floatformat *\n floatformat_from_type (const struct type *type)\n {\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);\n+  gdb_assert (type->code () == TYPE_CODE_FLT);\n   gdb_assert (TYPE_FLOATFORMAT (type));\n   return TYPE_FLOATFORMAT (type);\n }\n@@ -3288,8 +3288,8 @@ init_complex_type (const char *name, struct type *target_type)\n {\n   struct type *t;\n \n-  gdb_assert (TYPE_CODE (target_type) == TYPE_CODE_INT\n-\t      || TYPE_CODE (target_type) == TYPE_CODE_FLT);\n+  gdb_assert (target_type->code () == TYPE_CODE_INT\n+\t      || target_type->code () == TYPE_CODE_FLT);\n \n   if (TYPE_MAIN_TYPE (target_type)->flds_bnds.complex_type == nullptr)\n     {\n@@ -3359,7 +3359,7 @@ type_align (struct type *type)\n   if (align != 0)\n     return align;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_FUNC:\n@@ -3469,8 +3469,8 @@ can_dereference (struct type *t)\n   t = check_typedef (t);\n   return\n     (t != NULL\n-     && TYPE_CODE (t) == TYPE_CODE_PTR\n-     && TYPE_CODE (TYPE_TARGET_TYPE (t)) != TYPE_CODE_VOID);\n+     && t->code () == TYPE_CODE_PTR\n+     && TYPE_TARGET_TYPE (t)->code () != TYPE_CODE_VOID);\n }\n \n int\n@@ -3479,12 +3479,12 @@ is_integral_type (struct type *t)\n   t = check_typedef (t);\n   return\n     ((t != NULL)\n-     && ((TYPE_CODE (t) == TYPE_CODE_INT)\n-\t || (TYPE_CODE (t) == TYPE_CODE_ENUM)\n-\t || (TYPE_CODE (t) == TYPE_CODE_FLAGS)\n-\t || (TYPE_CODE (t) == TYPE_CODE_CHAR)\n-\t || (TYPE_CODE (t) == TYPE_CODE_RANGE)\n-\t || (TYPE_CODE (t) == TYPE_CODE_BOOL)));\n+     && ((t->code () == TYPE_CODE_INT)\n+\t || (t->code () == TYPE_CODE_ENUM)\n+\t || (t->code () == TYPE_CODE_FLAGS)\n+\t || (t->code () == TYPE_CODE_CHAR)\n+\t || (t->code () == TYPE_CODE_RANGE)\n+\t || (t->code () == TYPE_CODE_BOOL)));\n }\n \n int\n@@ -3493,8 +3493,8 @@ is_floating_type (struct type *t)\n   t = check_typedef (t);\n   return\n     ((t != NULL)\n-     && ((TYPE_CODE (t) == TYPE_CODE_FLT)\n-\t || (TYPE_CODE (t) == TYPE_CODE_DECFLOAT)));\n+     && ((t->code () == TYPE_CODE_FLT)\n+\t || (t->code () == TYPE_CODE_DECFLOAT)));\n }\n \n /* Return true if TYPE is scalar.  */\n@@ -3504,7 +3504,7 @@ is_scalar_type (struct type *type)\n {\n   type = check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n     case TYPE_CODE_STRUCT:\n@@ -3529,9 +3529,9 @@ is_scalar_type_recursive (struct type *t)\n   if (is_scalar_type (t))\n     return 1;\n   /* Are we dealing with an array or string of known dimensions?  */\n-  else if ((TYPE_CODE (t) == TYPE_CODE_ARRAY\n-\t    || TYPE_CODE (t) == TYPE_CODE_STRING) && TYPE_NFIELDS (t) == 1\n-\t   && TYPE_CODE (TYPE_INDEX_TYPE (t)) == TYPE_CODE_RANGE)\n+  else if ((t->code () == TYPE_CODE_ARRAY\n+\t    || t->code () == TYPE_CODE_STRING) && TYPE_NFIELDS (t) == 1\n+\t   && TYPE_INDEX_TYPE(t)->code () == TYPE_CODE_RANGE)\n     {\n       LONGEST low_bound, high_bound;\n       struct type *elt_type = check_typedef (TYPE_TARGET_TYPE (t));\n@@ -3541,9 +3541,9 @@ is_scalar_type_recursive (struct type *t)\n       return high_bound == low_bound && is_scalar_type_recursive (elt_type);\n     }\n   /* Are we dealing with a struct with one element?  */\n-  else if (TYPE_CODE (t) == TYPE_CODE_STRUCT && TYPE_NFIELDS (t) == 1)\n+  else if (t->code () == TYPE_CODE_STRUCT && TYPE_NFIELDS (t) == 1)\n     return is_scalar_type_recursive (TYPE_FIELD_TYPE (t, 0));\n-  else if (TYPE_CODE (t) == TYPE_CODE_UNION)\n+  else if (t->code () == TYPE_CODE_UNION)\n     {\n       int i, n = TYPE_NFIELDS (t);\n \n@@ -3563,8 +3563,8 @@ is_scalar_type_recursive (struct type *t)\n int\n class_or_union_p (const struct type *t)\n {\n-  return (TYPE_CODE (t) == TYPE_CODE_STRUCT\n-          || TYPE_CODE (t) == TYPE_CODE_UNION);\n+  return (t->code () == TYPE_CODE_STRUCT\n+          || t->code () == TYPE_CODE_UNION);\n }\n \n /* A helper function which returns true if types A and B represent the\n@@ -3906,21 +3906,21 @@ types_equal (struct type *a, struct type *b)\n     return true;\n \n   /* Resolve typedefs */\n-  if (TYPE_CODE (a) == TYPE_CODE_TYPEDEF)\n+  if (a->code () == TYPE_CODE_TYPEDEF)\n     a = check_typedef (a);\n-  if (TYPE_CODE (b) == TYPE_CODE_TYPEDEF)\n+  if (b->code () == TYPE_CODE_TYPEDEF)\n     b = check_typedef (b);\n \n   /* If after resolving typedefs a and b are not of the same type\n      code then they are not equal.  */\n-  if (TYPE_CODE (a) != TYPE_CODE (b))\n+  if (a->code () != b->code ())\n     return false;\n \n   /* If a and b are both pointers types or both reference types then\n      they are equal of the same type iff the objects they refer to are\n      of the same type.  */\n-  if (TYPE_CODE (a) == TYPE_CODE_PTR\n-      || TYPE_CODE (a) == TYPE_CODE_REF)\n+  if (a->code () == TYPE_CODE_PTR\n+      || a->code () == TYPE_CODE_REF)\n     return types_equal (TYPE_TARGET_TYPE (a),\n                         TYPE_TARGET_TYPE (b));\n \n@@ -3939,7 +3939,7 @@ types_equal (struct type *a, struct type *b)\n \n   /* Two function types are equal if their argument and return types\n      are equal.  */\n-  if (TYPE_CODE (a) == TYPE_CODE_FUNC)\n+  if (a->code () == TYPE_CODE_FUNC)\n     {\n       int i;\n \n@@ -3999,7 +3999,7 @@ check_types_equal (struct type *type1, struct type *type2,\n   if (type1 == type2)\n     return true;\n \n-  if (TYPE_CODE (type1) != TYPE_CODE (type2)\n+  if (type1->code () != type2->code ()\n       || TYPE_LENGTH (type1) != TYPE_LENGTH (type2)\n       || TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2)\n       || TYPE_NOSIGN (type1) != TYPE_NOSIGN (type2)\n@@ -4016,7 +4016,7 @@ check_types_equal (struct type *type1, struct type *type2,\n   if (!compare_maybe_null_strings (TYPE_NAME (type1), TYPE_NAME (type2)))\n     return false;\n \n-  if (TYPE_CODE (type1) == TYPE_CODE_RANGE)\n+  if (type1->code () == TYPE_CODE_RANGE)\n     {\n       if (*TYPE_RANGE_DATA (type1) != *TYPE_RANGE_DATA (type2))\n \treturn false;\n@@ -4170,13 +4170,13 @@ rank_one_type_parm_ptr (struct type *parm, struct type *arg, struct value *value\n {\n   struct rank rank = {0,0};\n \n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_PTR:\n \n       /* Allowed pointer conversions are:\n \t (a) pointer to void-pointer conversion.  */\n-      if (TYPE_CODE (TYPE_TARGET_TYPE (parm)) == TYPE_CODE_VOID)\n+      if (TYPE_TARGET_TYPE (parm)->code () == TYPE_CODE_VOID)\n \treturn VOID_PTR_CONVERSION_BADNESS;\n \n       /* (b) pointer to ancestor-pointer conversion.  */\n@@ -4208,7 +4208,7 @@ rank_one_type_parm_ptr (struct type *parm, struct type *arg, struct value *value\n     case TYPE_CODE_FUNC:\n       return rank_one_type (TYPE_TARGET_TYPE (parm), arg, NULL);\n     case TYPE_CODE_INT:\n-      if (value != NULL && TYPE_CODE (value_type (value)) == TYPE_CODE_INT)\n+      if (value != NULL && value_type (value)->code () == TYPE_CODE_INT)\n \t{\n \t  if (value_as_long (value) == 0)\n \t    {\n@@ -4239,7 +4239,7 @@ rank_one_type_parm_ptr (struct type *parm, struct type *arg, struct value *value\n static struct rank\n rank_one_type_parm_array (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_ARRAY:\n@@ -4255,7 +4255,7 @@ rank_one_type_parm_array (struct type *parm, struct type *arg, struct value *val\n static struct rank\n rank_one_type_parm_func (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_PTR:\t/* funcptr -> func */\n       return rank_one_type (parm, TYPE_TARGET_TYPE (arg), NULL);\n@@ -4269,7 +4269,7 @@ rank_one_type_parm_func (struct type *parm, struct type *arg, struct value *valu\n static struct rank\n rank_one_type_parm_int (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_INT:\n       if (TYPE_LENGTH (arg) == TYPE_LENGTH (parm))\n@@ -4358,7 +4358,7 @@ rank_one_type_parm_int (struct type *parm, struct type *arg, struct value *value\n static struct rank\n rank_one_type_parm_enum (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_CHAR:\n@@ -4380,7 +4380,7 @@ rank_one_type_parm_enum (struct type *parm, struct type *arg, struct value *valu\n static struct rank\n rank_one_type_parm_char (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_RANGE:\n     case TYPE_CODE_BOOL:\n@@ -4427,7 +4427,7 @@ rank_one_type_parm_char (struct type *parm, struct type *arg, struct value *valu\n static struct rank\n rank_one_type_parm_range (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_CHAR:\n@@ -4447,7 +4447,7 @@ rank_one_type_parm_range (struct type *parm, struct type *arg, struct value *val\n static struct rank\n rank_one_type_parm_bool (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n       /* n3290 draft, section 4.12.1 (conv.bool):\n \n@@ -4478,7 +4478,7 @@ rank_one_type_parm_bool (struct type *parm, struct type *arg, struct value *valu\n static struct rank\n rank_one_type_parm_float (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_FLT:\n       if (TYPE_LENGTH (arg) < TYPE_LENGTH (parm))\n@@ -4503,7 +4503,7 @@ rank_one_type_parm_float (struct type *parm, struct type *arg, struct value *val\n static struct rank\n rank_one_type_parm_complex (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\t\t/* Strictly not needed for C++, but...  */\n     case TYPE_CODE_FLT:\n       return FLOAT_PROMOTION_BADNESS;\n@@ -4521,7 +4521,7 @@ rank_one_type_parm_struct (struct type *parm, struct type *arg, struct value *va\n {\n   struct rank rank = {0, 0};\n \n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n     case TYPE_CODE_STRUCT:\n       /* Check for derivation */\n@@ -4539,7 +4539,7 @@ rank_one_type_parm_struct (struct type *parm, struct type *arg, struct value *va\n static struct rank\n rank_one_type_parm_set (struct type *parm, struct type *arg, struct value *value)\n {\n-  switch (TYPE_CODE (arg))\n+  switch (arg->code ())\n     {\n       /* Not in C++ */\n     case TYPE_CODE_SET:\n@@ -4567,9 +4567,9 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n   struct rank rank = {0,0};\n \n   /* Resolve typedefs */\n-  if (TYPE_CODE (parm) == TYPE_CODE_TYPEDEF)\n+  if (parm->code () == TYPE_CODE_TYPEDEF)\n     parm = check_typedef (parm);\n-  if (TYPE_CODE (arg) == TYPE_CODE_TYPEDEF)\n+  if (arg->code () == TYPE_CODE_TYPEDEF)\n     arg = check_typedef (arg);\n \n   if (TYPE_IS_REFERENCE (parm) && value != NULL)\n@@ -4578,7 +4578,7 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n \t{\n \t  /* Rvalues should preferably bind to rvalue references or const\n \t     lvalue references.  */\n-\t  if (TYPE_CODE (parm) == TYPE_CODE_RVALUE_REF)\n+\t  if (parm->code () == TYPE_CODE_RVALUE_REF)\n \t    rank.subrank = REFERENCE_CONVERSION_RVALUE;\n \t  else if (TYPE_CONST (TYPE_TARGET_TYPE (parm)))\n \t    rank.subrank = REFERENCE_CONVERSION_CONST_LVALUE;\n@@ -4589,7 +4589,7 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n       else\n \t{\n \t  /* It's illegal to pass an lvalue as an rvalue.  */\n-\t  if (TYPE_CODE (parm) == TYPE_CODE_RVALUE_REF)\n+\t  if (parm->code () == TYPE_CODE_RVALUE_REF)\n \t    return INCOMPATIBLE_TYPE_BADNESS;\n \t}\n     }\n@@ -4600,7 +4600,7 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n       struct type *t2 = arg;\n \n       /* For pointers and references, compare target type.  */\n-      if (TYPE_CODE (parm) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (parm))\n+      if (parm->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (parm))\n \t{\n \t  t1 = TYPE_TARGET_TYPE (parm);\n \t  t2 = TYPE_TARGET_TYPE (arg);\n@@ -4627,14 +4627,14 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n                        REFERENCE_SEE_THROUGH_BADNESS));\n   if (overload_debug)\n   /* Debugging only.  */\n-    fprintf_filtered (gdb_stderr, \n+    fprintf_filtered (gdb_stderr,\n \t\t      \"------ Arg is %s [%d], parm is %s [%d]\\n\",\n-\t\t      TYPE_NAME (arg), TYPE_CODE (arg), \n-\t\t      TYPE_NAME (parm), TYPE_CODE (parm));\n+\t\t      TYPE_NAME (arg), arg->code (),\n+\t\t      TYPE_NAME (parm), parm->code ());\n \n   /* x -> y means arg of type x being supplied for parameter of type y.  */\n \n-  switch (TYPE_CODE (parm))\n+  switch (parm->code ())\n     {\n     case TYPE_CODE_PTR:\n       return rank_one_type_parm_ptr (parm, arg, value);\n@@ -4662,7 +4662,7 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n       return rank_one_type_parm_set (parm, arg, value);\n     default:\n       return INCOMPATIBLE_TYPE_BADNESS;\n-    }\t\t\t\t/* switch (TYPE_CODE (arg)) */\n+    }\t\t\t\t/* switch (arg->code ()) */\n }\n \n /* End of functions for overload resolution.  */\n@@ -4908,8 +4908,8 @@ recursive_dump_type (struct type *type, int spaces)\n \t\t    TYPE_NAME (type) ? TYPE_NAME (type) : \"<NULL>\");\n   gdb_print_host_address (TYPE_NAME (type), gdb_stdout);\n   printf_filtered (\")\\n\");\n-  printfi_filtered (spaces, \"code 0x%x \", TYPE_CODE (type));\n-  switch (TYPE_CODE (type))\n+  printfi_filtered (spaces, \"code 0x%x \", type->code ());\n+  switch (type->code ())\n     {\n     case TYPE_CODE_UNDEF:\n       printf_filtered (\"(TYPE_CODE_UNDEF)\");\n@@ -5106,7 +5106,7 @@ recursive_dump_type (struct type *type, int spaces)\n   puts_filtered (\"\\n\");\n   for (idx = 0; idx < TYPE_NFIELDS (type); idx++)\n     {\n-      if (TYPE_CODE (type) == TYPE_CODE_ENUM)\n+      if (type->code () == TYPE_CODE_ENUM)\n \tprintfi_filtered (spaces + 2,\n \t\t\t  \"[%d] enumval %s type \",\n \t\t\t  idx, plongest (TYPE_FIELD_ENUMVAL (type, idx)));\n@@ -5127,7 +5127,7 @@ recursive_dump_type (struct type *type, int spaces)\n \t  recursive_dump_type (TYPE_FIELD_TYPE (type, idx), spaces + 4);\n \t}\n     }\n-  if (TYPE_CODE (type) == TYPE_CODE_RANGE)\n+  if (type->code () == TYPE_CODE_RANGE)\n     {\n       printfi_filtered (spaces, \"low %s%s  high %s%s\\n\",\n \t\t\tplongest (TYPE_LOW_BOUND (type)), \n@@ -5343,7 +5343,7 @@ copy_type_recursive (struct objfile *objfile,\n     }\n \n   /* For range types, copy the bounds information.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_RANGE)\n+  if (type->code () == TYPE_CODE_RANGE)\n     {\n       TYPE_RANGE_DATA (new_type) = (struct range_bounds *)\n         TYPE_ALLOC (new_type, sizeof (struct range_bounds));\n@@ -5577,7 +5577,7 @@ append_flags_type_field (struct type *type, int start_bitpos, int nr_bits,\n   int type_bitsize = TYPE_LENGTH (type) * TARGET_CHAR_BIT;\n   int field_nr = TYPE_NFIELDS (type);\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLAGS);\n+  gdb_assert (type->code () == TYPE_CODE_FLAGS);\n   gdb_assert (TYPE_NFIELDS (type) + 1 <= type_bitsize);\n   gdb_assert (start_bitpos >= 0 && start_bitpos < type_bitsize);\n   gdb_assert (nr_bits >= 1 && nr_bits <= type_bitsize);\n@@ -5649,12 +5649,12 @@ append_composite_type_field_aligned (struct type *t, const char *name,\n {\n   struct field *f = append_composite_type_field_raw (t, name, field);\n \n-  if (TYPE_CODE (t) == TYPE_CODE_UNION)\n+  if (t->code () == TYPE_CODE_UNION)\n     {\n       if (TYPE_LENGTH (t) < TYPE_LENGTH (field))\n \tTYPE_LENGTH (t) = TYPE_LENGTH (field);\n     }\n-  else if (TYPE_CODE (t) == TYPE_CODE_STRUCT)\n+  else if (t->code () == TYPE_CODE_STRUCT)\n     {\n       TYPE_LENGTH (t) = TYPE_LENGTH (t) + TYPE_LENGTH (field);\n       if (TYPE_NFIELDS (t) > 1)"
    },
    {
      "sha": "a8cd44a75bf6b1c032c4ea09535e5a75d8443830",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -335,7 +335,7 @@ DEF_ENUM_FLAGS_TYPE (enum type_instance_flag_value, type_instance_flags);\n /* * True if this type represents either an lvalue or lvalue reference type.  */\n \n #define TYPE_IS_REFERENCE(t) \\\n-  (TYPE_CODE (t) == TYPE_CODE_REF || TYPE_CODE (t) == TYPE_CODE_RVALUE_REF)\n+  ((t)->code () == TYPE_CODE_REF || (t)->code () == TYPE_CODE_RVALUE_REF)\n \n /* * True if this type is allocatable.  */\n #define TYPE_IS_ALLOCATABLE(t) \\\n@@ -1435,7 +1435,6 @@ extern unsigned type_align (struct type *);\n    space in struct type.  */\n extern bool set_type_align (struct type *, ULONGEST);\n \n-#define TYPE_CODE(thistype) ((thistype)->code ())\n #define TYPE_NFIELDS(thistype) TYPE_MAIN_TYPE(thistype)->nfields\n #define TYPE_FIELDS(thistype) TYPE_MAIN_TYPE(thistype)->flds_bnds.fields\n \n@@ -1681,8 +1680,8 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n   TYPE_NESTED_TYPES_FIELD (thistype, n).is_private\n \n #define TYPE_IS_OPAQUE(thistype) \\\n-  (((TYPE_CODE (thistype) == TYPE_CODE_STRUCT) \\\n-    || (TYPE_CODE (thistype) == TYPE_CODE_UNION)) \\\n+  ((((thistype)->code () == TYPE_CODE_STRUCT) \\\n+    || ((thistype)->code () == TYPE_CODE_UNION)) \\\n    && (TYPE_NFIELDS (thistype) == 0) \\\n    && (!HAVE_CPLUS_STRUCT (thistype) \\\n        || TYPE_NFN_FIELDS (thistype) == 0) \\"
    },
    {
      "sha": "bf438a8ea6e8e8dc506fdc0bc5c791ccd5bacdba",
      "filename": "gdb/gnu-v2-abi.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gnu-v2-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gnu-v2-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v2-abi.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -132,8 +132,8 @@ gnuv2_virtual_fn_field (struct value **arg1p, struct fn_field * f, int j,\n \n   /* With older versions of g++, the vtbl field pointed to an array\n      of structures.  Nowadays it points directly to the structure.  */\n-  if (TYPE_CODE (value_type (vtbl)) == TYPE_CODE_PTR\n-      && TYPE_CODE (TYPE_TARGET_TYPE (value_type (vtbl))) == TYPE_CODE_ARRAY)\n+  if (value_type (vtbl)->code () == TYPE_CODE_PTR\n+      && TYPE_TARGET_TYPE (value_type (vtbl))->code () == TYPE_CODE_ARRAY)\n     {\n       /* Handle the case where the vtbl field points to an\n          array of structures.  */\n@@ -155,7 +155,7 @@ gnuv2_virtual_fn_field (struct value **arg1p, struct fn_field * f, int j,\n \n   entry_type = check_typedef (value_type (entry));\n \n-  if (TYPE_CODE (entry_type) == TYPE_CODE_STRUCT)\n+  if (entry_type->code () == TYPE_CODE_STRUCT)\n     {\n       /* Move the `this' pointer according to the virtual function table.  */\n       set_value_offset (arg1, value_offset (arg1)\n@@ -169,7 +169,7 @@ gnuv2_virtual_fn_field (struct value **arg1p, struct fn_field * f, int j,\n \n       vfn = value_field (entry, 2);\n     }\n-  else if (TYPE_CODE (entry_type) == TYPE_CODE_PTR)\n+  else if (entry_type->code () == TYPE_CODE_PTR)\n     vfn = entry;\n   else\n     error (_(\"I'm confused:  virtual function table has bad type\"));\n@@ -206,7 +206,7 @@ gnuv2_value_rtti_type (struct value *v, int *full, LONGEST *top, int *using_enc)\n   known_type = value_type (v);\n   known_type = check_typedef (known_type);\n   /* RTTI works only or class objects.  */\n-  if (TYPE_CODE (known_type) != TYPE_CODE_STRUCT)\n+  if (known_type->code () != TYPE_CODE_STRUCT)\n     return NULL;\n \n   /* Plan on this changing in the future as i get around to setting\n@@ -314,7 +314,7 @@ vb_match (struct type *type, int index, struct type *basetype)\n      it is for this baseclass.  */\n   fieldtype = TYPE_FIELD_TYPE (type, index);\n   if (fieldtype == NULL\n-      || TYPE_CODE (fieldtype) != TYPE_CODE_PTR)\n+      || fieldtype->code () != TYPE_CODE_PTR)\n     /* \"Can't happen\".  */\n     return 0;\n "
    },
    {
      "sha": "1fe3a9670cfe44f49e127d5a611b0b8a106571e7",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -208,10 +208,10 @@ gnuv3_dynamic_class (struct type *type)\n   int fieldnum, fieldelem;\n \n   type = check_typedef (type);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (type) == TYPE_CODE_UNION);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT\n+\t      || type->code () == TYPE_CODE_UNION);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if (type->code () == TYPE_CODE_UNION)\n     return 0;\n \n   if (TYPE_CPLUS_DYNAMIC (type))\n@@ -259,7 +259,7 @@ gnuv3_get_vtable (struct gdbarch *gdbarch,\n   CORE_ADDR vtable_address;\n \n   container_type = check_typedef (container_type);\n-  gdb_assert (TYPE_CODE (container_type) == TYPE_CODE_STRUCT);\n+  gdb_assert (container_type->code () == TYPE_CODE_STRUCT);\n \n   /* If this type does not have a virtual table, don't read the first\n      field.  */\n@@ -303,7 +303,7 @@ gnuv3_rtti_type (struct value *value,\n   const char *atsign;\n \n   /* We only have RTTI for dynamic class objects.  */\n-  if (TYPE_CODE (values_type) != TYPE_CODE_STRUCT\n+  if (values_type->code () != TYPE_CODE_STRUCT\n       || !gnuv3_dynamic_class (values_type))\n     return NULL;\n \n@@ -418,7 +418,7 @@ gnuv3_virtual_fn_field (struct value **value_p,\n   struct gdbarch *gdbarch;\n \n   /* Some simple sanity checks.  */\n-  if (TYPE_CODE (values_type) != TYPE_CODE_STRUCT)\n+  if (values_type->code () != TYPE_CODE_STRUCT)\n     error (_(\"Only classes can have virtual functions.\"));\n \n   /* Determine architecture.  */\n@@ -849,7 +849,7 @@ compute_vtable_size (htab_t offset_hash,\n   void **slot;\n   struct value_and_voffset search_vo, *current_vo;\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT);\n+  gdb_assert (type->code () == TYPE_CODE_STRUCT);\n \n   /* If the object is not dynamic, then we are done; as it cannot have\n      dynamic base types either.  */\n@@ -964,7 +964,7 @@ gnuv3_print_vtable (struct value *value)\n \n   value = coerce_ref (value);\n   type = check_typedef (value_type (value));\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     {\n       value = value_ind (value);\n       type = check_typedef (value_type (value));\n@@ -982,7 +982,7 @@ gnuv3_print_vtable (struct value *value)\n   gdbarch = get_type_arch (type);\n \n   vtable = NULL;\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     vtable = gnuv3_get_vtable (gdbarch, type,\n \t\t\t       value_as_address (value_addr (value)));\n \n@@ -1103,7 +1103,7 @@ gnuv3_get_typeid (struct value *value)\n \n   /* In the non_lvalue case, a reference might have slipped through\n      here.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_REF)\n+  if (type->code () == TYPE_CODE_REF)\n     type = check_typedef (TYPE_TARGET_TYPE (type));\n \n   /* Ignore top-level cv-qualifiers.  */\n@@ -1127,7 +1127,7 @@ gnuv3_get_typeid (struct value *value)\n \n   /* We check for lval_memory because in the \"typeid (type-id)\" case,\n      the type is passed via a not_lval value object.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  if (type->code () == TYPE_CODE_STRUCT\n       && value_lval_const (value) == lval_memory\n       && gnuv3_dynamic_class (type))\n     {\n@@ -1333,7 +1333,7 @@ is_copy_or_move_constructor_type (struct type *class_type,\n      type, with the expected type code...  */\n   struct type *arg_type = TYPE_FIELD_TYPE (method_type, 1);\n \n-  if (TYPE_CODE (arg_type) != expected)\n+  if (arg_type->code () != expected)\n     return false;\n \n   struct type *target = check_typedef (TYPE_TARGET_TYPE (arg_type));\n@@ -1417,8 +1417,8 @@ gnuv3_pass_by_reference (struct type *type)\n   definition_style mctor_def = DOES_NOT_EXIST_IN_SOURCE;\n \n   /* We're only interested in things that can have methods.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (type) != TYPE_CODE_UNION)\n+  if (type->code () != TYPE_CODE_STRUCT\n+      && type->code () != TYPE_CODE_UNION)\n     return info;\n \n   /* The compiler may have emitted the calling convention attribute.\n@@ -1533,7 +1533,7 @@ gnuv3_pass_by_reference (struct type *type)\n \tstruct type *field_type = TYPE_FIELD_TYPE (type, fieldnum);\n \n \t/* For arrays, make the decision based on the element type.  */\n-\tif (TYPE_CODE (field_type) == TYPE_CODE_ARRAY)\n+\tif (field_type->code () == TYPE_CODE_ARRAY)\n \t  field_type = check_typedef (TYPE_TARGET_TYPE (field_type));\n \n \tstruct language_pass_by_ref_info field_info"
    },
    {
      "sha": "17c76ac02ab07dc2baa073cb00304af9b8c061e1",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1333,7 +1333,7 @@ package_name_p (const char *name, const struct block *block)\n \n   if (sym\n       && SYMBOL_CLASS (sym) == LOC_TYPEDEF\n-      && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_MODULE)\n+      && SYMBOL_TYPE (sym)->code () == TYPE_CODE_MODULE)\n     return 1;\n \n   return 0;"
    },
    {
      "sha": "373c12db516069c6db5754b722d1394b48140fa6",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -81,16 +81,16 @@ gccgo_string_p (struct type *type)\n       type0 = check_typedef (type0);\n       type1 = check_typedef (type1);\n \n-      if (TYPE_CODE (type0) == TYPE_CODE_PTR\n+      if (type0->code () == TYPE_CODE_PTR\n \t  && strcmp (TYPE_FIELD_NAME (type, 0), \"__data\") == 0\n-\t  && TYPE_CODE (type1) == TYPE_CODE_INT\n+\t  && type1->code () == TYPE_CODE_INT\n \t  && strcmp (TYPE_FIELD_NAME (type, 1), \"__length\") == 0)\n \t{\n \t  struct type *target_type = TYPE_TARGET_TYPE (type0);\n \n \t  target_type = check_typedef (target_type);\n \n-\t  if (TYPE_CODE (target_type) == TYPE_CODE_INT\n+\t  if (target_type->code () == TYPE_CODE_INT\n \t      && TYPE_LENGTH (target_type) == 1\n \t      && strcmp (TYPE_NAME (target_type), \"uint8\") == 0)\n \t    return 1;\n@@ -137,7 +137,7 @@ static bool\n go_is_string_type_p (struct type *type)\n {\n   type = check_typedef (type);\n-  return (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  return (type->code () == TYPE_CODE_STRUCT\n \t  && go_classify_struct_type (type) == GO_TYPE_STRING);\n }\n "
    },
    {
      "sha": "c334914398d1a027ef9fbf4079c2b27fc46d54d6",
      "filename": "gdb/go-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/go-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/go-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-typeprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -51,8 +51,8 @@ go_print_type (struct type *type, const char *varstring,\n     type = check_typedef (type);\n \n   /* Print the type of \"abc\" as \"string\", not char[4].  */\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n-      && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_CHAR)\n+  if (type->code () == TYPE_CODE_ARRAY\n+      && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_CHAR)\n     {\n       fputs_filtered (\"string\", stream);\n       return;"
    },
    {
      "sha": "1933e98ed29e3daca53082e9722ee44b4a865eed",
      "filename": "gdb/go-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/go-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/go-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -92,7 +92,7 @@ go_value_print_inner (struct value *val, struct ui_file *stream,\n {\n   struct type *type = check_typedef (value_type (val));\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n       case TYPE_CODE_STRUCT:\n \t{"
    },
    {
      "sha": "0df1b3a0f81d1916f7f40c54fd5c6a745d0ccd41",
      "filename": "gdb/guile/scm-lazy-string.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/guile/scm-lazy-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/guile/scm-lazy-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-lazy-string.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -201,7 +201,7 @@ lsscm_elt_type (lazy_string_smob *ls_smob)\n \n   realtype = check_typedef (type);\n \n-  switch (TYPE_CODE (realtype))\n+  switch (realtype->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_ARRAY:\n@@ -314,7 +314,7 @@ lsscm_safe_lazy_string_to_value (SCM string, int arg_pos,\n       struct type *type = tyscm_scm_to_type (ls_smob->type);\n       struct type *realtype = check_typedef (type);\n \n-      switch (TYPE_CODE (realtype))\n+      switch (realtype->code ())\n \t{\n \tcase TYPE_CODE_PTR:\n \t  /* If a length is specified we need to convert this to an array"
    },
    {
      "sha": "7c63fa2ae046e6883c248fc56668543103a88990",
      "filename": "gdb/guile/scm-math.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/guile/scm-math.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/guile/scm-math.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-math.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -65,7 +65,7 @@ enum valscm_binary_opcode\n \n /* If TYPE is a reference, return the target; otherwise return TYPE.  */\n #define STRIP_REFERENCE(TYPE) \\\n-  ((TYPE_CODE (TYPE) == TYPE_CODE_REF) ? (TYPE_TARGET_TYPE (TYPE)) : (TYPE))\n+  ((TYPE->code () == TYPE_CODE_REF) ? (TYPE_TARGET_TYPE (TYPE)) : (TYPE))\n \n /* Helper for vlscm_unop.  Contains all the code that may throw a GDB\n    exception.  */\n@@ -168,10 +168,10 @@ vlscm_binop_gdbthrow (enum valscm_binary_opcode opcode, SCM x, SCM y,\n \trtype = check_typedef (rtype);\n \trtype = STRIP_REFERENCE (rtype);\n \n-\tif (TYPE_CODE (ltype) == TYPE_CODE_PTR\n+\tif (ltype->code () == TYPE_CODE_PTR\n \t    && is_integral_type (rtype))\n \t  res_val = value_ptradd (arg1, value_as_long (arg2));\n-\telse if (TYPE_CODE (rtype) == TYPE_CODE_PTR\n+\telse if (rtype->code () == TYPE_CODE_PTR\n \t\t && is_integral_type (ltype))\n \t  res_val = value_ptradd (arg2, value_as_long (arg1));\n \telse\n@@ -188,15 +188,15 @@ vlscm_binop_gdbthrow (enum valscm_binary_opcode opcode, SCM x, SCM y,\n \trtype = check_typedef (rtype);\n \trtype = STRIP_REFERENCE (rtype);\n \n-\tif (TYPE_CODE (ltype) == TYPE_CODE_PTR\n-\t    && TYPE_CODE (rtype) == TYPE_CODE_PTR)\n+\tif (ltype->code () == TYPE_CODE_PTR\n+\t    && rtype->code () == TYPE_CODE_PTR)\n \t  {\n \t    /* A ptrdiff_t for the target would be preferable here.  */\n \t    res_val\n \t      = value_from_longest (builtin_type (gdbarch)->builtin_long,\n \t\t\t\t    value_ptrdiff (arg1, arg2));\n \t  }\n-\telse if (TYPE_CODE (ltype) == TYPE_CODE_PTR\n+\telse if (ltype->code () == TYPE_CODE_PTR\n \t\t && is_integral_type (rtype))\n \t  res_val = value_ptradd (arg1, - value_as_long (arg2));\n \telse\n@@ -525,7 +525,7 @@ vlscm_convert_typed_number (const char *func_name, int obj_arg_pos, SCM obj,\n \t\t\t    struct gdbarch *gdbarch, SCM *except_scmp)\n {\n   if (is_integral_type (type)\n-      || TYPE_CODE (type) == TYPE_CODE_PTR)\n+      || type->code () == TYPE_CODE_PTR)\n     {\n       if (TYPE_UNSIGNED (type))\n \t{\n@@ -558,7 +558,7 @@ vlscm_convert_typed_number (const char *func_name, int obj_arg_pos, SCM obj,\n \t  return value_from_longest (type, gdbscm_scm_to_longest (obj));\n \t}\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+  else if (type->code () == TYPE_CODE_FLT)\n     return value_from_host_double (type, scm_to_double (obj));\n   else\n     {"
    },
    {
      "sha": "521f484b0812efa7c676d33a0b9c1d64a83cf807",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -529,7 +529,7 @@ gdbscm_type_code (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  return scm_from_int (TYPE_CODE (type));\n+  return scm_from_int (type->code ());\n }\n \n /* (type-fields <gdb:type>) -> list\n@@ -577,9 +577,9 @@ gdbscm_type_tag (SCM self)\n   struct type *type = t_smob->type;\n   const char *tagname = nullptr;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || TYPE_CODE (type) == TYPE_CODE_ENUM)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || type->code () == TYPE_CODE_ENUM)\n     tagname = TYPE_NAME (type);\n \n   if (tagname == nullptr)\n@@ -685,17 +685,17 @@ tyscm_get_composite (struct type *type)\n \t}\n \n       GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n-      if (TYPE_CODE (type) != TYPE_CODE_PTR\n-\t  && TYPE_CODE (type) != TYPE_CODE_REF)\n+      if (type->code () != TYPE_CODE_PTR\n+\t  && type->code () != TYPE_CODE_REF)\n \tbreak;\n       type = TYPE_TARGET_TYPE (type);\n     }\n \n   /* If this is not a struct, union, or enum type, raise TypeError\n      exception.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (type) != TYPE_CODE_UNION\n-      && TYPE_CODE (type) != TYPE_CODE_ENUM)\n+  if (type->code () != TYPE_CODE_STRUCT\n+      && type->code () != TYPE_CODE_UNION\n+      && type->code () != TYPE_CODE_ENUM)\n     return NULL;\n \n   return type;\n@@ -817,12 +817,12 @@ gdbscm_type_range (SCM self)\n   /* Initialize these to appease GCC warnings.  */\n   LONGEST low = 0, high = 0;\n \n-  SCM_ASSERT_TYPE (TYPE_CODE (type) == TYPE_CODE_ARRAY\n-\t\t   || TYPE_CODE (type) == TYPE_CODE_STRING\n-\t\t   || TYPE_CODE (type) == TYPE_CODE_RANGE,\n+  SCM_ASSERT_TYPE (type->code () == TYPE_CODE_ARRAY\n+\t\t   || type->code () == TYPE_CODE_STRING\n+\t\t   || type->code () == TYPE_CODE_RANGE,\n \t\t   self, SCM_ARG1, FUNC_NAME, _(\"ranged type\"));\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n     case TYPE_CODE_STRING:\n@@ -1163,7 +1163,7 @@ gdbscm_field_enumval (SCM self)\n   struct field *field = tyscm_field_smob_to_field (f_smob);\n   struct type *type = tyscm_field_smob_containing_type (f_smob);\n \n-  SCM_ASSERT_TYPE (TYPE_CODE (type) == TYPE_CODE_ENUM,\n+  SCM_ASSERT_TYPE (type->code () == TYPE_CODE_ENUM,\n \t\t   self, SCM_ARG1, FUNC_NAME, _(\"enum type\"));\n \n   return scm_from_long (FIELD_ENUMVAL (*field));\n@@ -1180,7 +1180,7 @@ gdbscm_field_bitpos (SCM self)\n   struct field *field = tyscm_field_smob_to_field (f_smob);\n   struct type *type = tyscm_field_smob_containing_type (f_smob);\n \n-  SCM_ASSERT_TYPE (TYPE_CODE (type) != TYPE_CODE_ENUM,\n+  SCM_ASSERT_TYPE (type->code () != TYPE_CODE_ENUM,\n \t\t   self, SCM_ARG1, FUNC_NAME, _(\"non-enum type\"));\n \n   return scm_from_long (FIELD_BITPOS (*field));\n@@ -1222,7 +1222,7 @@ gdbscm_field_baseclass_p (SCM self)\n     = tyscm_get_field_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = tyscm_field_smob_containing_type (f_smob);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     return scm_from_bool (f_smob->field_num < TYPE_N_BASECLASSES (type));\n   return SCM_BOOL_F;\n }"
    },
    {
      "sha": "c4d4045917c46e92502e608b2375ac71f4ad1118",
      "filename": "gdb/guile/scm-value.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/guile/scm-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/guile/scm-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-value.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -470,7 +470,7 @@ gdbscm_value_referenced_value (SCM self)\n \n       struct value *res_val;\n \n-      switch (TYPE_CODE (check_typedef (value_type (value))))\n+      switch (check_typedef (value_type (value))->code ())\n         {\n         case TYPE_CODE_PTR:\n           res_val = value_ind (value);\n@@ -523,12 +523,12 @@ gdbscm_value_dynamic_type (SCM self)\n       type = value_type (value);\n       type = check_typedef (type);\n \n-      if (((TYPE_CODE (type) == TYPE_CODE_PTR)\n-\t   || (TYPE_CODE (type) == TYPE_CODE_REF))\n-\t  && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_STRUCT))\n+      if (((type->code () == TYPE_CODE_PTR)\n+\t   || (type->code () == TYPE_CODE_REF))\n+\t  && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_STRUCT))\n \t{\n \t  struct value *target;\n-\t  int was_pointer = TYPE_CODE (type) == TYPE_CODE_PTR;\n+\t  int was_pointer = type->code () == TYPE_CODE_PTR;\n \n \t  if (was_pointer)\n \t    target = value_ind (value);\n@@ -544,7 +544,7 @@ gdbscm_value_dynamic_type (SCM self)\n \t\ttype = lookup_lvalue_reference_type (type);\n \t    }\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      else if (type->code () == TYPE_CODE_STRUCT)\n \ttype = value_rtti_type (value, NULL, NULL, NULL);\n       else\n \t{\n@@ -682,8 +682,8 @@ gdbscm_value_subscript (SCM self, SCM index_scm)\n \t a subscript.  */\n       struct value *tmp = coerce_ref (value);\n       struct type *tmp_type = check_typedef (value_type (tmp));\n-      if (TYPE_CODE (tmp_type) != TYPE_CODE_ARRAY\n-\t  && TYPE_CODE (tmp_type) != TYPE_CODE_PTR)\n+      if (tmp_type->code () != TYPE_CODE_ARRAY\n+\t  && tmp_type->code () != TYPE_CODE_PTR)\n \terror (_(\"Cannot subscript requested type\"));\n \n       struct value *res_val = value_subscript (tmp, value_as_long (index));\n@@ -715,7 +715,7 @@ gdbscm_value_call (SCM self, SCM args)\n     }\n \n   GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n-  SCM_ASSERT_TYPE (TYPE_CODE (ftype) == TYPE_CODE_FUNC, self,\n+  SCM_ASSERT_TYPE (ftype->code () == TYPE_CODE_FUNC, self,\n \t\t   SCM_ARG1, FUNC_NAME,\n \t\t   _(\"function (value of TYPE_CODE_FUNC)\"));\n \n@@ -796,11 +796,11 @@ gdbscm_value_to_bytevector (SCM self)\n static int\n is_intlike (struct type *type, int ptr_ok)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_INT\n-\t  || TYPE_CODE (type) == TYPE_CODE_ENUM\n-\t  || TYPE_CODE (type) == TYPE_CODE_BOOL\n-\t  || TYPE_CODE (type) == TYPE_CODE_CHAR\n-\t  || (ptr_ok && TYPE_CODE (type) == TYPE_CODE_PTR));\n+  return (type->code () == TYPE_CODE_INT\n+\t  || type->code () == TYPE_CODE_ENUM\n+\t  || type->code () == TYPE_CODE_BOOL\n+\t  || type->code () == TYPE_CODE_CHAR\n+\t  || (ptr_ok && type->code () == TYPE_CODE_PTR));\n }\n \n /* (value->bool <gdb:value>) -> boolean\n@@ -833,7 +833,7 @@ gdbscm_value_to_bool (SCM self)\n \n   try\n     {\n-      if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+      if (type->code () == TYPE_CODE_PTR)\n \tl = value_as_address (value);\n       else\n \tl = value_as_long (value);\n@@ -877,7 +877,7 @@ gdbscm_value_to_integer (SCM self)\n \n   try\n     {\n-      if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+      if (type->code () == TYPE_CODE_PTR)\n \tl = value_as_address (value);\n       else\n \tl = value_as_long (value);\n@@ -920,7 +920,7 @@ gdbscm_value_to_real (SCM self)\n     }\n \n   GDBSCM_HANDLE_GDB_EXCEPTION (exc);\n-  SCM_ASSERT_TYPE (is_intlike (type, 0) || TYPE_CODE (type) == TYPE_CODE_FLT,\n+  SCM_ASSERT_TYPE (is_intlike (type, 0) || type->code () == TYPE_CODE_FLT,\n \t\t   self, SCM_ARG1, FUNC_NAME, _(\"number\"));\n \n   try\n@@ -1113,7 +1113,7 @@ gdbscm_value_to_lazy_string (SCM self, SCM rest)\n       type = value_type (value);\n       realtype = check_typedef (type);\n \n-      switch (TYPE_CODE (realtype))\n+      switch (realtype->code ())\n \t{\n \tcase TYPE_CODE_ARRAY:\n \t  {"
    },
    {
      "sha": "3c2f502a124dec4d0d5c60209a6039aa6ea3f2a8",
      "filename": "gdb/h8300-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/h8300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/h8300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/h8300-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -740,7 +740,7 @@ h8300_extract_return_value (struct type *type, struct regcache *regcache,\n       store_unsigned_integer (valbuf + 2, 2, byte_order, c);\n       break;\n     case 8:\t\t\t/* long long is now 8 bytes.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_INT)\n+      if (type->code () == TYPE_CODE_INT)\n \t{\n \t  regcache_cooked_read_unsigned (regcache, E_RET0_REGNUM, &addr);\n \t  c = read_memory_unsigned_integer ((CORE_ADDR) addr, len, byte_order);\n@@ -771,7 +771,7 @@ h8300h_extract_return_value (struct type *type, struct regcache *regcache,\n       store_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order, c);\n       break;\n     case 8:\t\t\t/* long long is now 8 bytes.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_INT)\n+      if (type->code () == TYPE_CODE_INT)\n \t{\n \t  regcache_cooked_read_unsigned (regcache, E_RET0_REGNUM, &c);\n \t  store_unsigned_integer (valbuf, 4, byte_order, c);\n@@ -792,8 +792,8 @@ h8300_use_struct_convention (struct type *value_type)\n   /* Types of 1, 2 or 4 bytes are returned in R0/R1, everything else on the\n      stack.  */\n \n-  if (TYPE_CODE (value_type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (value_type) == TYPE_CODE_UNION)\n+  if (value_type->code () == TYPE_CODE_STRUCT\n+      || value_type->code () == TYPE_CODE_UNION)\n     return 1;\n   return !(TYPE_LENGTH (value_type) == 1\n \t   || TYPE_LENGTH (value_type) == 2\n@@ -805,14 +805,14 @@ h8300h_use_struct_convention (struct type *value_type)\n {\n   /* Types of 1, 2 or 4 bytes are returned in R0, INT types of 8 bytes are\n      returned in R0/R1, everything else on the stack.  */\n-  if (TYPE_CODE (value_type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (value_type) == TYPE_CODE_UNION)\n+  if (value_type->code () == TYPE_CODE_STRUCT\n+      || value_type->code () == TYPE_CODE_UNION)\n     return 1;\n   return !(TYPE_LENGTH (value_type) == 1\n \t   || TYPE_LENGTH (value_type) == 2\n \t   || TYPE_LENGTH (value_type) == 4\n \t   || (TYPE_LENGTH (value_type) == 8\n-\t       && TYPE_CODE (value_type) == TYPE_CODE_INT));\n+\t       && value_type->code () == TYPE_CODE_INT));\n }\n \n /* Function: store_return_value"
    },
    {
      "sha": "b063cf1b575687c48f7297bb91bce522699af765",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -763,8 +763,8 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      store_unsigned_integer (param_val, 4, byte_order,\n \t\t\t\t      struct_end - struct_ptr);\n \t    }\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_INT\n-\t\t   || TYPE_CODE (type) == TYPE_CODE_ENUM)\n+\t  else if (type->code () == TYPE_CODE_INT\n+\t\t   || type->code () == TYPE_CODE_ENUM)\n \t    {\n \t      /* Integer value store, right aligned.  \"unpack_long\"\n \t\t takes care of any sign-extension problems.  */\n@@ -773,7 +773,7 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\t      unpack_long (type,\n \t\t\t\t\t\t   value_contents (arg)));\n \t    }\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+\t  else if (type->code () == TYPE_CODE_FLT)\n             {\n \t      /* Floating point value store, right aligned.  */\n \t      param_len = align_up (TYPE_LENGTH (type), 4);\n@@ -876,7 +876,7 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n static int\n hppa64_integral_or_pointer_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_BOOL:\n@@ -903,7 +903,7 @@ hppa64_integral_or_pointer_p (const struct type *type)\n static int\n hppa64_floating_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_FLT:\n       {\n@@ -1064,8 +1064,8 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n       /* If we are passing a function pointer, make sure we pass a function\n          descriptor instead of the function entry address.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_PTR\n-          && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC)\n+      if (type->code () == TYPE_CODE_PTR\n+          && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC)\n         {\n \t  ULONGEST codeptr, fptr;\n \n@@ -1144,7 +1144,7 @@ hppa32_return_value (struct gdbarch *gdbarch, struct value *function,\n       /* The value always lives in the right hand end of the register\n \t (or register pair)?  */\n       int b;\n-      int reg = TYPE_CODE (type) == TYPE_CODE_FLT ? HPPA_FP4_REGNUM : 28;\n+      int reg = type->code () == TYPE_CODE_FLT ? HPPA_FP4_REGNUM : 28;\n       int part = TYPE_LENGTH (type) % 4;\n       /* The left hand register contains only part of the value,\n \t transfer that first so that the rest can be xfered as entire"
    },
    {
      "sha": "39081481790d1121b665d764ca7b14e0edd45ece",
      "filename": "gdb/i386-darwin-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/i386-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/i386-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-darwin-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -109,7 +109,7 @@ darwin_dwarf_signal_frame_p (struct gdbarch *gdbarch,\n static int\n i386_m128_p (struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+  return (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n           && TYPE_LENGTH (type) == 16);\n }\n \n@@ -124,15 +124,15 @@ i386_darwin_arg_type_alignment (struct type *type)\n          aligned to 8-byte boundaries.\n      7.  [...]  The caller aligns 128-bit vectors in the parameter area to\n          16-byte boundaries.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n     return TYPE_LENGTH (type);\n   /* 4.  The caller places all the fields of structures (or unions) with no\n          vector elements in the parameter area.  These structures are 4-byte\n          aligned.\n      5.  The caller places structures with vector elements on the stack,\n          16-byte aligned.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION)\n     {\n       int i;\n       int res = 4;"
    },
    {
      "sha": "0f8d9aa7409933b83ea921a8b9743bedfd004fc1",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -2633,14 +2633,14 @@ static int\n i386_16_byte_align_p (struct type *type)\n {\n   type = check_typedef (type);\n-  if ((TYPE_CODE (type) == TYPE_CODE_DECFLOAT\n-       || (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)))\n+  if ((type->code () == TYPE_CODE_DECFLOAT\n+       || (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)))\n       && TYPE_LENGTH (type) == 16)\n     return 1;\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_ARRAY)\n     return i386_16_byte_align_p (TYPE_TARGET_TYPE (type));\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION)\n     {\n       int i;\n       for (i = 0; i < TYPE_NFIELDS (type); i++)\n@@ -2811,7 +2811,7 @@ i386_extract_return_value (struct gdbarch *gdbarch, struct type *type,\n   int len = TYPE_LENGTH (type);\n   gdb_byte buf[I386_MAX_REGISTER_SIZE];\n \n-  if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (type->code () == TYPE_CODE_FLT)\n     {\n       if (tdep->st0_regnum < 0)\n \t{\n@@ -2861,7 +2861,7 @@ i386_store_return_value (struct gdbarch *gdbarch, struct type *type,\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n   int len = TYPE_LENGTH (type);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (type->code () == TYPE_CODE_FLT)\n     {\n       ULONGEST fstat;\n       gdb_byte buf[I386_MAX_REGISTER_SIZE];\n@@ -2938,7 +2938,7 @@ static int\n i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n   int len = TYPE_LENGTH (type);\n \n   gdb_assert (code == TYPE_CODE_STRUCT\n@@ -2955,7 +2955,7 @@ i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n   if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)\n     {\n       type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n-      if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+      if (type->code () == TYPE_CODE_FLT)\n \treturn (len == 4 || len == 8 || len == 12);\n     }\n \n@@ -2973,7 +2973,7 @@ i386_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t   struct type *type, struct regcache *regcache,\n \t\t   gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n \n   if (((code == TYPE_CODE_STRUCT\n \t|| code == TYPE_CODE_UNION\n@@ -8398,13 +8398,13 @@ i386_type_align (struct gdbarch *gdbarch, struct type *type)\n \n   if (gdbarch_ptr_bit (gdbarch) == 32)\n     {\n-      if ((TYPE_CODE (type) == TYPE_CODE_INT\n-\t   || TYPE_CODE (type) == TYPE_CODE_FLT)\n+      if ((type->code () == TYPE_CODE_INT\n+\t   || type->code () == TYPE_CODE_FLT)\n \t  && TYPE_LENGTH (type) > 4)\n \treturn 4;\n \n       /* Handle x86's funny long double.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_FLT\n+      if (type->code () == TYPE_CODE_FLT\n \t  && gdbarch_long_double_bit (gdbarch) == TYPE_LENGTH (type) * 8)\n \treturn 4;\n     }"
    },
    {
      "sha": "7233b1f28f51754e6a81033b292c6daa2cef42e1",
      "filename": "gdb/i386-windows-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/i386-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/i386-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-windows-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -214,15 +214,15 @@ i386_windows_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   bool thiscall = false;\n \n   struct type *type = check_typedef (value_type (function));\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     type = check_typedef (TYPE_TARGET_TYPE (type));\n \n   /* read_subroutine_type sets for non-static member functions the\n      artificial flag of the first parameter ('this' pointer).  */\n-  if (TYPE_CODE (type) == TYPE_CODE_METHOD\n+  if (type->code () == TYPE_CODE_METHOD\n       && TYPE_NFIELDS (type) > 0\n       && TYPE_FIELD_ARTIFICIAL (type, 0)\n-      && TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_PTR)\n+      && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_PTR)\n     thiscall = 1;\n \n   return i386_thiscall_push_dummy_call (gdbarch, function, regcache, bp_addr,"
    },
    {
      "sha": "b8c342d22aaee73f8fea66b87d322b2e40c6e69d",
      "filename": "gdb/i387-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/i387-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/i387-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i387-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -332,7 +332,7 @@ i387_convert_register_p (struct gdbarch *gdbarch, int regnum,\n       /* Floating point registers must be converted unless we are\n \t accessing them in their hardware type or TYPE is not float.  */\n       if (type == i387_ext_type (gdbarch)\n-\t  || TYPE_CODE (type) != TYPE_CODE_FLT)\n+\t  || type->code () != TYPE_CODE_FLT)\n \treturn 0;\n       else\n \treturn 1;\n@@ -355,7 +355,7 @@ i387_register_to_value (struct frame_info *frame, int regnum,\n   gdb_assert (i386_fp_regnum_p (gdbarch, regnum));\n \n   /* We only support floating-point values.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_FLT)\n+  if (type->code () != TYPE_CODE_FLT)\n     {\n       warning (_(\"Cannot convert floating-point register value \"\n \t       \"to non-floating-point type.\"));\n@@ -387,7 +387,7 @@ i387_value_to_register (struct frame_info *frame, int regnum,\n   gdb_assert (i386_fp_regnum_p (gdbarch, regnum));\n \n   /* We only support floating-point values.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_FLT)\n+  if (type->code () != TYPE_CODE_FLT)\n     {\n       warning (_(\"Cannot convert non-floating-point type \"\n \t       \"to floating-point register value.\"));"
    },
    {
      "sha": "de6273c8cc7626d3463e1e486ce78a7df416e148",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -330,7 +330,7 @@ ia64_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n   if (group == all_reggroup)\n     return 1;\n   vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));\n-  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;\n+  float_p = register_type (gdbarch, regnum)->code () == TYPE_CODE_FLT;\n   raw_p = regnum < NUM_IA64_RAW_REGS;\n   if (group == float_reggroup)\n     return float_p;\n@@ -1212,7 +1212,7 @@ static int\n ia64_convert_register_p (struct gdbarch *gdbarch, int regno, struct type *type)\n {\n   return (regno >= IA64_FR0_REGNUM && regno <= IA64_FR127_REGNUM\n-\t  && TYPE_CODE (type) == TYPE_CODE_FLT\n+\t  && type->code () == TYPE_CODE_FLT\n \t  && type != ia64_ext_type (gdbarch));\n }\n \n@@ -3149,9 +3149,9 @@ ia64_use_struct_convention (struct type *type)\n \n   /* Don't use the struct convention for anything but structure,\n      union, or array types.  */\n-  if (!(TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t|| TYPE_CODE (type) == TYPE_CODE_UNION\n-\t|| TYPE_CODE (type) == TYPE_CODE_ARRAY))\n+  if (!(type->code () == TYPE_CODE_STRUCT\n+\t|| type->code () == TYPE_CODE_UNION\n+\t|| type->code () == TYPE_CODE_ARRAY))\n     return 0;\n \n   /* HFAs are structures (or arrays) consisting entirely of floating\n@@ -3173,8 +3173,8 @@ ia64_use_struct_convention (struct type *type)\n static int\n ia64_struct_type_p (const struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-          || TYPE_CODE (type) == TYPE_CODE_UNION);\n+  return (type->code () == TYPE_CODE_STRUCT\n+          || type->code () == TYPE_CODE_UNION);\n }\n \n static void\n@@ -3320,7 +3320,7 @@ ia64_return_value (struct gdbarch *gdbarch, struct value *function,\n static int\n is_float_or_hfa_type_recurse (struct type *t, struct type **etp)\n {\n-  switch (TYPE_CODE (t))\n+  switch (t->code ())\n     {\n     case TYPE_CODE_FLT:\n       if (*etp)\n@@ -3374,7 +3374,7 @@ is_float_or_hfa_type (struct type *t)\n static int\n slot_alignment_is_next_even (struct type *t)\n {\n-  switch (TYPE_CODE (t))\n+  switch (t->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_FLT:\n@@ -3699,7 +3699,7 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       if ((nslots & 1) && slot_alignment_is_next_even (type))\n \tnslots++;\n \n-      if (TYPE_CODE (type) == TYPE_CODE_FUNC)\n+      if (type->code () == TYPE_CODE_FUNC)\n \tnfuncargs++;\n \n       nslots += (len + 7) / 8;\n@@ -3740,9 +3740,9 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       len = TYPE_LENGTH (type);\n \n       /* Special handling for function parameters.  */\n-      if (len == 8 \n-          && TYPE_CODE (type) == TYPE_CODE_PTR \n-\t  && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC)\n+      if (len == 8\n+          && type->code () == TYPE_CODE_PTR\n+          && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC)\n \t{\n \t  gdb_byte val_buf[8];\n \t  ULONGEST faddr = extract_unsigned_integer (value_contents (arg),"
    },
    {
      "sha": "818b6cb94835a0d506dd5ab782dba575e0cbf1fe",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -169,7 +169,7 @@ value_arg_coerce (struct gdbarch *gdbarch, struct value *arg,\n      saved by the called function.  */\n   arg = value_coerce_to_target (arg);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_REF:\n     case TYPE_CODE_RVALUE_REF:\n@@ -184,7 +184,7 @@ value_arg_coerce (struct gdbarch *gdbarch, struct value *arg,\n \t   if the value was not previously in memory - in some cases\n \t   we should clearly be allowing this, but how?  */\n \tnew_value = value_cast (TYPE_TARGET_TYPE (type), arg);\n-\tnew_value = value_ref (new_value, TYPE_CODE (type));\n+\tnew_value = value_ref (new_value, type->code ());\n \treturn new_value;\n       }\n     case TYPE_CODE_INT:\n@@ -260,20 +260,20 @@ find_function_addr (struct value *function,\n      part of it.  */\n \n   /* Determine address to call.  */\n-  if (TYPE_CODE (ftype) == TYPE_CODE_FUNC\n-      || TYPE_CODE (ftype) == TYPE_CODE_METHOD)\n+  if (ftype->code () == TYPE_CODE_FUNC\n+      || ftype->code () == TYPE_CODE_METHOD)\n     funaddr = value_address (function);\n-  else if (TYPE_CODE (ftype) == TYPE_CODE_PTR)\n+  else if (ftype->code () == TYPE_CODE_PTR)\n     {\n       funaddr = value_as_address (function);\n       ftype = check_typedef (TYPE_TARGET_TYPE (ftype));\n-      if (TYPE_CODE (ftype) == TYPE_CODE_FUNC\n-\t  || TYPE_CODE (ftype) == TYPE_CODE_METHOD)\n+      if (ftype->code () == TYPE_CODE_FUNC\n+\t  || ftype->code () == TYPE_CODE_METHOD)\n \tfunaddr = gdbarch_convert_from_func_ptr_addr (gdbarch, funaddr,\n \t\t\t\t\t\t      current_top_target ());\n     }\n-  if (TYPE_CODE (ftype) == TYPE_CODE_FUNC\n-      || TYPE_CODE (ftype) == TYPE_CODE_METHOD)\n+  if (ftype->code () == TYPE_CODE_FUNC\n+      || ftype->code () == TYPE_CODE_METHOD)\n     {\n       if (TYPE_GNU_IFUNC (ftype))\n \t{\n@@ -303,7 +303,7 @@ find_function_addr (struct value *function,\n       else\n \tvalue_type = TYPE_TARGET_TYPE (ftype);\n     }\n-  else if (TYPE_CODE (ftype) == TYPE_CODE_INT)\n+  else if (ftype->code () == TYPE_CODE_INT)\n     {\n       /* Handle the case of functions lacking debugging info.\n          Their values are characters since their addresses are char.  */\n@@ -438,7 +438,7 @@ get_call_return_value (struct call_return_meta_info *ri)\n   thread_info *thr = inferior_thread ();\n   bool stack_temporaries = thread_stack_temporaries_enabled_p (thr);\n \n-  if (TYPE_CODE (ri->value_type) == TYPE_CODE_VOID)\n+  if (ri->value_type->code () == TYPE_CODE_VOID)\n     retval = allocate_value (ri->value_type);\n   else if (ri->struct_return_p)\n     {\n@@ -1025,7 +1025,7 @@ call_function_by_hand_dummy (struct value *function,\n \n       /* FIXME drow/2002-05-31: Should just always mark methods as\n \t prototyped.  Can we respect TYPE_VARARGS?  Probably not.  */\n-      if (TYPE_CODE (ftype) == TYPE_CODE_METHOD)\n+      if (ftype->code () == TYPE_CODE_METHOD)\n \tprototyped = 1;\n       if (TYPE_TARGET_TYPE (ftype) == NULL && TYPE_NFIELDS (ftype) == 0\n \t  && default_return_type != NULL)"
    },
    {
      "sha": "8b01f45828e8424b17e0fa9286e27985616d9204",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1589,7 +1589,7 @@ get_return_value (struct value *function, struct type *value_type)\n   struct value *value;\n \n   value_type = check_typedef (value_type);\n-  gdb_assert (TYPE_CODE (value_type) != TYPE_CODE_VOID);\n+  gdb_assert (value_type->code () != TYPE_CODE_VOID);\n \n   /* FIXME: 2003-09-27: When returning from a nested inferior function\n      call, it's possible (with no help from the architecture vector)\n@@ -1680,7 +1680,7 @@ void\n print_return_value (struct ui_out *uiout, struct return_value_info *rv)\n {\n   if (rv->type == NULL\n-      || TYPE_CODE (check_typedef (rv->type)) == TYPE_CODE_VOID)\n+      || check_typedef (rv->type)->code () == TYPE_CODE_VOID)\n     return;\n \n   try\n@@ -1744,7 +1744,7 @@ finish_command_fsm::should_stop (struct thread_info *tp)\n \tinternal_error (__FILE__, __LINE__,\n \t\t\t_(\"finish_command: function has no target type\"));\n \n-      if (TYPE_CODE (check_typedef (rv->type)) != TYPE_CODE_VOID)\n+      if (check_typedef (rv->type)->code () != TYPE_CODE_VOID)\n \t{\n \t  struct value *func;\n \n@@ -2250,8 +2250,8 @@ default_print_one_register_info (struct ui_file *file,\n \n   /* If virtual format is floating, print it that way, and in raw\n      hex.  */\n-  if (TYPE_CODE (regtype) == TYPE_CODE_FLT\n-      || TYPE_CODE (regtype) == TYPE_CODE_DECFLOAT)\n+  if (regtype->code () == TYPE_CODE_FLT\n+      || regtype->code () == TYPE_CODE_DECFLOAT)\n     {\n       struct value_print_options opts;\n       const gdb_byte *valaddr = value_contents_for_printing (val);"
    },
    {
      "sha": "1767a457ca7ed2b3bfc83016988c99b3da2be308",
      "filename": "gdb/iq2000-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/iq2000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/iq2000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/iq2000-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -89,7 +89,7 @@ iq2000_pointer_to_address (struct gdbarch *gdbarch,\n \t\t\t   struct type * type, const gdb_byte * buf)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  enum type_code target = TYPE_CODE (TYPE_TARGET_TYPE (type));\n+  enum type_code target = TYPE_TARGET_TYPE (type)->code ();\n   CORE_ADDR addr\n     = extract_unsigned_integer (buf, TYPE_LENGTH (type), byte_order);\n \n@@ -109,7 +109,7 @@ iq2000_address_to_pointer (struct gdbarch *gdbarch,\n \t\t\t   struct type *type, gdb_byte *buf, CORE_ADDR addr)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  enum type_code target = TYPE_CODE (TYPE_TARGET_TYPE (type));\n+  enum type_code target = TYPE_TARGET_TYPE (type)->code ();\n \n   if (target == TYPE_CODE_FUNC || target == TYPE_CODE_METHOD)\n     addr = insn_ptr_from_addr (addr);\n@@ -504,8 +504,8 @@ iq2000_store_return_value (struct type *type, struct regcache *regcache,\n static int\n iq2000_use_struct_convention (struct type *type)\n {\n-  return ((TYPE_CODE (type) == TYPE_CODE_STRUCT)\n-\t  || (TYPE_CODE (type) == TYPE_CODE_UNION))\n+  return ((type->code () == TYPE_CODE_STRUCT)\n+\t  || (type->code () == TYPE_CODE_UNION))\n \t && TYPE_LENGTH (type) > 8;\n }\n \n@@ -597,11 +597,11 @@ iq2000_pass_8bytetype_by_address (struct type *type)\n   struct type *ftype;\n \n   /* Skip typedefs.  */\n-  while (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+  while (type->code () == TYPE_CODE_TYPEDEF)\n     type = TYPE_TARGET_TYPE (type);\n   /* Non-struct and non-union types are always passed by value.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (type) != TYPE_CODE_UNION)\n+  if (type->code () != TYPE_CODE_STRUCT\n+      && type->code () != TYPE_CODE_UNION)\n     return 0;\n   /* Structs with more than 1 field are always passed by address.  */\n   if (TYPE_NFIELDS (type) != 1)\n@@ -612,11 +612,11 @@ iq2000_pass_8bytetype_by_address (struct type *type)\n   if (TYPE_LENGTH (ftype) != 8)\n     return 1;\n   /* Skip typedefs of field type.  */\n-  while (TYPE_CODE (ftype) == TYPE_CODE_TYPEDEF)\n+  while (ftype->code () == TYPE_CODE_TYPEDEF)\n     ftype = TYPE_TARGET_TYPE (ftype);\n   /* If field is int or float, pass by value.  */\n-  if (TYPE_CODE (ftype) == TYPE_CODE_FLT\n-      || TYPE_CODE (ftype) == TYPE_CODE_INT)\n+  if (ftype->code () == TYPE_CODE_FLT\n+      || ftype->code () == TYPE_CODE_INT)\n     return 0;\n   /* Everything else, pass by address.  */\n   return 1;"
    },
    {
      "sha": "a7ecb7963ba85aa0ae6ca44d45f0f47ffcf6f590",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -410,7 +410,7 @@ language_info (int quietly)\n int\n pointer_type (struct type *type)\n {\n-  return TYPE_CODE (type) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (type);\n+  return type->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (type);\n }\n \n \f\n@@ -710,12 +710,12 @@ bool\n default_is_string_type_p (struct type *type)\n {\n   type = check_typedef (type);\n-  while (TYPE_CODE (type) == TYPE_CODE_REF)\n+  while (type->code () == TYPE_CODE_REF)\n     {\n       type = TYPE_TARGET_TYPE (type);\n       type = check_typedef (type);\n     }\n-  return (TYPE_CODE (type)  == TYPE_CODE_STRING);\n+  return (type->code ()  == TYPE_CODE_STRING);\n }\n \n /* See language.h.  */\n@@ -981,7 +981,7 @@ language_bool_type (const struct language_defn *la,\n \t{\n \t  struct type *type = SYMBOL_TYPE (sym);\n \n-\t  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)\n+\t  if (type && type->code () == TYPE_CODE_BOOL)\n \t    return type;\n \t}\n     }"
    },
    {
      "sha": "1e70cdb0dca17c313a65916298862419464b231e",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -3491,9 +3491,9 @@ decode_compound_collector::operator () (block_symbol *bsym)\n \n   t = SYMBOL_TYPE (sym);\n   t = check_typedef (t);\n-  if (TYPE_CODE (t) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (t) != TYPE_CODE_UNION\n-      && TYPE_CODE (t) != TYPE_CODE_NAMESPACE)\n+  if (t->code () != TYPE_CODE_STRUCT\n+      && t->code () != TYPE_CODE_UNION\n+      && t->code () != TYPE_CODE_NAMESPACE)\n     return true; /* Continue iterating.  */\n \n   slot = htab_find_slot (m_unique_syms, sym, INSERT);\n@@ -4164,7 +4164,7 @@ linespec_parse_variable (struct linespec_state *self, const char *variable)\n       sscanf ((variable[1] == '$') ? variable + 2 : variable + 1, \"%d\", &index);\n       val_history\n \t= access_value_history ((variable[1] == '$') ? -index : index);\n-      if (TYPE_CODE (value_type (val_history)) != TYPE_CODE_INT)\n+      if (value_type (val_history)->code () != TYPE_CODE_INT)\n \terror (_(\"History values used in line \"\n \t\t \"specs must have integer values.\"));\n       offset.offset = value_as_long (val_history);"
    },
    {
      "sha": "6b5bb1507ff37d788ec759f7991a2c533207239d",
      "filename": "gdb/lm32-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/lm32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/lm32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/lm32-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -258,7 +258,7 @@ lm32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       ULONGEST val;\n \n       /* Promote small integer types to int.  */\n-      switch (TYPE_CODE (arg_type))\n+      switch (arg_type->code ())\n \t{\n \tcase TYPE_CODE_INT:\n \tcase TYPE_CODE_BOOL:\n@@ -309,15 +309,15 @@ lm32_extract_return_value (struct type *type, struct regcache *regcache,\n   ULONGEST l;\n   CORE_ADDR return_buffer;\n \n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (type) != TYPE_CODE_UNION\n-      && TYPE_CODE (type) != TYPE_CODE_ARRAY && TYPE_LENGTH (type) <= 4)\n+  if (type->code () != TYPE_CODE_STRUCT\n+      && type->code () != TYPE_CODE_UNION\n+      && type->code () != TYPE_CODE_ARRAY && TYPE_LENGTH (type) <= 4)\n     {\n       /* Return value is returned in a single register.  */\n       regcache_cooked_read_unsigned (regcache, SIM_LM32_R1_REGNUM, &l);\n       store_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order, l);\n     }\n-  else if ((TYPE_CODE (type) == TYPE_CODE_INT) && (TYPE_LENGTH (type) == 8))\n+  else if ((type->code () == TYPE_CODE_INT) && (TYPE_LENGTH (type) == 8))\n     {\n       /* 64-bit values are returned in a register pair.  */\n       regcache_cooked_read_unsigned (regcache, SIM_LM32_R1_REGNUM, &l);\n@@ -368,7 +368,7 @@ lm32_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t   struct type *valtype, struct regcache *regcache,\n \t\t   gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  enum type_code code = TYPE_CODE (valtype);\n+  enum type_code code = valtype->code ();\n \n   if (code == TYPE_CODE_STRUCT\n       || code == TYPE_CODE_UNION"
    },
    {
      "sha": "7f0255b22d86b2d129e13a54a2576ecb0a1730b9",
      "filename": "gdb/m2-lang.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m2-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m2-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -181,15 +181,15 @@ static bool\n m2_is_string_type_p (struct type *type)\n {\n   type = check_typedef (type);\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+  if (type->code () == TYPE_CODE_ARRAY\n       && TYPE_LENGTH (type) > 0\n       && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)\n     {\n       struct type *elttype = check_typedef (TYPE_TARGET_TYPE (type));\n \n       if (TYPE_LENGTH (elttype) == 1\n-\t  && (TYPE_CODE (elttype) == TYPE_CODE_INT\n-\t      || TYPE_CODE (elttype) == TYPE_CODE_CHAR))\n+\t  && (elttype->code () == TYPE_CODE_INT\n+\t      || elttype->code () == TYPE_CODE_CHAR))\n \treturn true;\n     }\n \n@@ -251,7 +251,7 @@ evaluate_subexp_modula2 (struct type *expect_type, struct expression *exp,\n \t{\n \t  struct value *temp = arg1;\n \t  type = TYPE_FIELD_TYPE (type, 0);\n-\t  if (type == NULL || (TYPE_CODE (type) != TYPE_CODE_PTR))\n+\t  if (type == NULL || (type->code () != TYPE_CODE_PTR))\n \t    {\n \t      warning (_(\"internal error: unbounded \"\n \t\t\t \"array structure is unknown\"));\n@@ -269,7 +269,7 @@ evaluate_subexp_modula2 (struct type *expect_type, struct expression *exp,\n \t  return value_ind (value_ptradd (arg1, value_as_long (arg2)));\n \t}\n       else\n-\tif (TYPE_CODE (type) != TYPE_CODE_ARRAY)\n+\tif (type->code () != TYPE_CODE_ARRAY)\n \t  {\n \t    if (TYPE_NAME (type))\n \t      error (_(\"cannot subscript something of type `%s'\"),"
    },
    {
      "sha": "1f1300c8f23da0017e4b661378bd2325e828755e",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -86,7 +86,7 @@ m2_print_type (struct type *type, const char *varstring,\n       return;\n     }\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_SET:\n       m2_short_set(type, stream, show, level);\n@@ -282,7 +282,7 @@ m2_procedure (struct type *type, struct ui_file *stream,\n   fprintf_filtered (stream, \"PROCEDURE \");\n   m2_type_name (type, stream);\n   if (TYPE_TARGET_TYPE (type) == NULL\n-      || TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n+      || TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n     {\n       int i, len = TYPE_NFIELDS (type);\n \n@@ -341,7 +341,7 @@ m2_is_long_set (struct type *type)\n   int len, i;\n   struct type *range;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     {\n \n       /* check if all fields of the RECORD are consecutive sets.  */\n@@ -351,7 +351,7 @@ m2_is_long_set (struct type *type)\n \t{\n \t  if (TYPE_FIELD_TYPE (type, i) == NULL)\n \t    return 0;\n-\t  if (TYPE_CODE (TYPE_FIELD_TYPE (type, i)) != TYPE_CODE_SET)\n+\t  if (TYPE_FIELD_TYPE (type, i)->code () != TYPE_CODE_SET)\n \t    return 0;\n \t  if (TYPE_FIELD_NAME (type, i) != NULL\n \t      && (strcmp (TYPE_FIELD_NAME (type, i), \"\") != 0))\n@@ -376,7 +376,7 @@ static int\n m2_get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n {\n   type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_CHAR:\n       if (TYPE_LENGTH (type) < sizeof (LONGEST))\n@@ -407,7 +407,7 @@ m2_is_long_set_of_type (struct type *type, struct type **of_type)\n   LONGEST l1, l2;\n   LONGEST h1, h2;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     {\n       len = TYPE_NFIELDS (type);\n       i = TYPE_N_BASECLASSES (type);\n@@ -482,7 +482,7 @@ m2_long_set (struct type *type, struct ui_file *stream, int show, int level,\n int\n m2_is_unbounded_array (struct type *type)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     {\n       /*\n        *  check if we have a structure with exactly two fields named\n@@ -496,7 +496,7 @@ m2_is_unbounded_array (struct type *type)\n \treturn 0;\n       if (strcmp (TYPE_FIELD_NAME (type, 1), \"_m2_high\") != 0)\n \treturn 0;\n-      if (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) != TYPE_CODE_PTR)\n+      if (TYPE_FIELD_TYPE (type, 0)->code () != TYPE_CODE_PTR)\n \treturn 0;\n       return 1;\n     }\n@@ -542,19 +542,19 @@ m2_record_fields (struct type *type, struct ui_file *stream, int show,\n   wrap_here (\"    \");\n   if (show < 0)\n     {\n-      if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      if (type->code () == TYPE_CODE_STRUCT)\n \tfprintf_filtered (stream, \"RECORD ... END \");\n-      else if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+      else if (type->code () == TYPE_CODE_UNION)\n \tfprintf_filtered (stream, \"CASE ... END \");\n     }\n   else if (show > 0)\n     {\n       int i;\n       int len = TYPE_NFIELDS (type);\n \n-      if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      if (type->code () == TYPE_CODE_STRUCT)\n \tfprintf_filtered (stream, \"RECORD\\n\");\n-      else if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+      else if (type->code () == TYPE_CODE_UNION)\n \t/* i18n: Do not translate \"CASE\" and \"OF\".  */\n \tfprintf_filtered (stream, _(\"CASE <variant> OF\\n\"));\n "
    },
    {
      "sha": "f0166118634ce1212a90b3c87eef8a3161328fde",
      "filename": "gdb/m2-valprint.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m2-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m2-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -49,7 +49,7 @@ get_long_set_bounds (struct type *type, LONGEST *low, LONGEST *high)\n {\n   int len, i;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     {\n       len = TYPE_NFIELDS (type);\n       i = TYPE_N_BASECLASSES (type);\n@@ -191,7 +191,7 @@ print_unpacked_pointer (struct type *type,\n   struct type *elttype = check_typedef (TYPE_TARGET_TYPE (type));\n   int want_space = 0;\n \n-  if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)\n+  if (elttype->code () == TYPE_CODE_FUNC)\n     {\n       /* Try to print what function it points to.  */\n       print_function_pointer_address (options, gdbarch, addr, stream);\n@@ -209,7 +209,7 @@ print_unpacked_pointer (struct type *type,\n      pointed to, unless pointer is null.  */\n \n   if (TYPE_LENGTH (elttype) == 1\n-      && TYPE_CODE (elttype) == TYPE_CODE_INT\n+      && elttype->code () == TYPE_CODE_INT\n       && (options->format == 0 || options->format == 's')\n       && addr != 0)\n     {\n@@ -237,7 +237,7 @@ print_variable_at_address (struct type *type,\n   fputs_filtered (paddress (gdbarch, addr), stream);\n   fprintf_filtered (stream, \"] : \");\n   \n-  if (TYPE_CODE (elttype) != TYPE_CODE_UNDEF)\n+  if (elttype->code () != TYPE_CODE_UNDEF)\n     {\n       struct value *deref_val =\n \tvalue_at (TYPE_TARGET_TYPE (type), unpack_pointer (type, valaddr));\n@@ -267,9 +267,9 @@ m2_print_array_contents (struct value *val,\n     {\n       /* For an array of chars, print with string syntax.  */\n       if (TYPE_LENGTH (type) == 1 &&\n-\t  ((TYPE_CODE (type) == TYPE_CODE_INT)\n+\t  ((type->code () == TYPE_CODE_INT)\n \t   || ((current_language->la_language == language_m2)\n-\t       && (TYPE_CODE (type) == TYPE_CODE_CHAR)))\n+\t       && (type->code () == TYPE_CODE_CHAR)))\n \t  && (options->format == 0 || options->format == 's'))\n \tval_print_string (type, NULL, value_address (val), len+1, stream,\n \t\t\t  options);\n@@ -309,7 +309,7 @@ m2_value_print_inner (struct value *val, struct ui_file *stream, int recurse,\n   const CORE_ADDR address = value_address (val);\n \n   struct type *type = check_typedef (value_type (val));\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)\n@@ -318,9 +318,9 @@ m2_value_print_inner (struct value *val, struct ui_file *stream, int recurse,\n \t  len = TYPE_LENGTH (type) / TYPE_LENGTH (elttype);\n \t  /* For an array of chars, print with string syntax.  */\n \t  if (TYPE_LENGTH (elttype) == 1 &&\n-\t      ((TYPE_CODE (elttype) == TYPE_CODE_INT)\n+\t      ((elttype->code () == TYPE_CODE_INT)\n \t       || ((current_language->la_language == language_m2)\n-\t\t   && (TYPE_CODE (elttype) == TYPE_CODE_CHAR)))\n+\t\t   && (elttype->code () == TYPE_CODE_CHAR)))\n \t      && (options->format == 0 || options->format == 's'))\n \t    {\n \t      /* If requested, look for the first null char and only print"
    },
    {
      "sha": "a49937a7bd25115d90b432ab9b30eb919999f2f0",
      "filename": "gdb/m32c-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m32c-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m32c-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32c-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1986,7 +1986,7 @@ static const struct frame_unwind m32c_unwind = {\n static int\n m32c_reg_arg_type (struct type *type)\n {\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n \n   return (code == TYPE_CODE_INT\n \t  || code == TYPE_CODE_ENUM\n@@ -2021,11 +2021,11 @@ m32c_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n     struct type *func_type = value_type (function);\n \n     /* Dereference function pointer types.  */\n-    if (TYPE_CODE (func_type) == TYPE_CODE_PTR)\n+    if (func_type->code () == TYPE_CODE_PTR)\n       func_type = TYPE_TARGET_TYPE (func_type);\n \n-    gdb_assert (TYPE_CODE (func_type) == TYPE_CODE_FUNC ||\n-\t\tTYPE_CODE (func_type) == TYPE_CODE_METHOD);\n+    gdb_assert (func_type->code () == TYPE_CODE_FUNC ||\n+\t\tfunc_type->code () == TYPE_CODE_METHOD);\n \n #if 0\n     /* The ABI description in gcc/config/m32c/m32c.abi says that\n@@ -2153,7 +2153,7 @@ m32c_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n static int\n m32c_return_by_passed_buf (struct type *type)\n {\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n \n   return (code == TYPE_CODE_STRUCT\n \t  || code == TYPE_CODE_UNION);\n@@ -2399,9 +2399,9 @@ m32c_m16c_address_to_pointer (struct gdbarch *gdbarch,\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   enum type_code target_code;\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (type));\n+  gdb_assert (type->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (type));\n \n-  target_code = TYPE_CODE (TYPE_TARGET_TYPE (type));\n+  target_code = TYPE_TARGET_TYPE (type)->code ();\n \n   if (target_code == TYPE_CODE_FUNC || target_code == TYPE_CODE_METHOD)\n     {\n@@ -2478,11 +2478,11 @@ m32c_m16c_pointer_to_address (struct gdbarch *gdbarch,\n   CORE_ADDR ptr;\n   enum type_code target_code;\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (type));\n+  gdb_assert (type->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (type));\n \n   ptr = extract_unsigned_integer (buf, TYPE_LENGTH (type), byte_order);\n \n-  target_code = TYPE_CODE (TYPE_TARGET_TYPE (type));\n+  target_code = TYPE_TARGET_TYPE (type)->code ();\n \n   if (target_code == TYPE_CODE_FUNC || target_code == TYPE_CODE_METHOD)\n     {"
    },
    {
      "sha": "011a0d2a9c347b659850314c9b83180ac65806aa",
      "filename": "gdb/m32r-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m32r-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m32r-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -690,7 +690,7 @@ m32r_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)\n     {\n       type = value_type (args[argnum]);\n-      typecode = TYPE_CODE (type);\n+      typecode = type->code ();\n       len = TYPE_LENGTH (type);\n \n       memset (valbuf, 0, sizeof (valbuf));"
    },
    {
      "sha": "84d475b5f7a46df7a4e9484aa53a8c6bb3438a20",
      "filename": "gdb/m68hc11-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m68hc11-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m68hc11-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68hc11-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1290,9 +1290,9 @@ m68hc11_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t      struct type *valtype, struct regcache *regcache,\n \t\t      gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  if (TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (valtype) == TYPE_CODE_UNION\n-      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY \n+  if (valtype->code () == TYPE_CODE_STRUCT\n+      || valtype->code () == TYPE_CODE_UNION\n+      || valtype->code () == TYPE_CODE_ARRAY\n       || TYPE_LENGTH (valtype) > 4)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n   else"
    },
    {
      "sha": "46a0f093201c2b923330a95fd23f13629a9cbe77",
      "filename": "gdb/m68k-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m68k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/m68k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -191,7 +191,7 @@ m68k_convert_register_p (struct gdbarch *gdbarch,\n     return 0;\n   return (regnum >= M68K_FP0_REGNUM && regnum <= M68K_FP0_REGNUM + 7\n \t  /* We only support floating-point values.  */\n-\t  && TYPE_CODE (type) == TYPE_CODE_FLT\n+\t  && type->code () == TYPE_CODE_FLT\n \t  && type != register_type (gdbarch, M68K_FP0_REGNUM));\n }\n \n@@ -207,7 +207,7 @@ m68k_register_to_value (struct frame_info *frame, int regnum,\n   gdb_byte from[M68K_MAX_REGISTER_SIZE];\n   struct type *fpreg_type = register_type (gdbarch, M68K_FP0_REGNUM);\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);\n+  gdb_assert (type->code () == TYPE_CODE_FLT);\n \n   /* Convert to TYPE.  */\n   if (!get_frame_register_bytes (frame, regnum, 0,\n@@ -232,7 +232,7 @@ m68k_value_to_register (struct frame_info *frame, int regnum,\n \t\t\t\t\t   M68K_FP0_REGNUM);\n \n   /* We only support floating-point values.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_FLT)\n+  if (type->code () != TYPE_CODE_FLT)\n     {\n       warning (_(\"Cannot convert non-floating-point type \"\n \t       \"to floating-point register value.\"));\n@@ -308,13 +308,13 @@ m68k_svr4_extract_return_value (struct type *type, struct regcache *regcache,\n   struct gdbarch *gdbarch = regcache->arch ();\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  if (tdep->float_return && TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (tdep->float_return && type->code () == TYPE_CODE_FLT)\n     {\n       struct type *fpreg_type = register_type (gdbarch, M68K_FP0_REGNUM);\n       regcache->raw_read (M68K_FP0_REGNUM, buf);\n       target_float_convert (buf, fpreg_type, valbuf, type);\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)\n+  else if (type->code () == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)\n     regcache->raw_read (M68K_A0_REGNUM, valbuf);\n   else\n     m68k_extract_return_value (type, regcache, valbuf);\n@@ -347,14 +347,14 @@ m68k_svr4_store_return_value (struct type *type, struct regcache *regcache,\n   struct gdbarch *gdbarch = regcache->arch ();\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  if (tdep->float_return && TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (tdep->float_return && type->code () == TYPE_CODE_FLT)\n     {\n       struct type *fpreg_type = register_type (gdbarch, M68K_FP0_REGNUM);\n       gdb_byte buf[M68K_MAX_REGISTER_SIZE];\n       target_float_convert (valbuf, type, buf, fpreg_type);\n       regcache->raw_write (M68K_FP0_REGNUM, buf);\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)\n+  else if (type->code () == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)\n     {\n       regcache->raw_write (M68K_A0_REGNUM, valbuf);\n       regcache->raw_write (M68K_D0_REGNUM, valbuf);\n@@ -371,7 +371,7 @@ static int\n m68k_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n   int len = TYPE_LENGTH (type);\n \n   gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION\n@@ -394,7 +394,7 @@ m68k_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t   struct type *type, struct regcache *regcache,\n \t\t   gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n \n   /* GCC returns a `long double' in memory too.  */\n   if (((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION\n@@ -430,7 +430,7 @@ m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\tstruct type *type, struct regcache *regcache,\n \t\t\tgdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n \n   if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION\n        || code == TYPE_CODE_COMPLEX)\n@@ -511,9 +511,9 @@ m68k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n       /* Non-scalars bigger than 4 bytes are left aligned, others are\n \t right aligned.  */\n-      if ((TYPE_CODE (value_type) == TYPE_CODE_STRUCT\n-\t   || TYPE_CODE (value_type) == TYPE_CODE_UNION\n-\t   || TYPE_CODE (value_type) == TYPE_CODE_ARRAY)\n+      if ((value_type->code () == TYPE_CODE_STRUCT\n+\t   || value_type->code () == TYPE_CODE_UNION\n+\t   || value_type->code () == TYPE_CODE_ARRAY)\n \t  && len > 4)\n \toffset = 0;\n       else"
    },
    {
      "sha": "eab52c70f17ea057c90756f3f62f7e36dad0e7aa",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -747,7 +747,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t{\n \t  t = parse_type (cur_fd, ax, sh->index + 1, 0, bigend, name);\n \t  if (strcmp (name, \"malloc\") == 0\n-\t      && TYPE_CODE (t) == TYPE_CODE_VOID)\n+\t      && t->code () == TYPE_CODE_VOID)\n \t    {\n \t      /* I don't know why, but, at least under Alpha GNU/Linux,\n \t         when linking against a malloc without debugging\n@@ -1298,11 +1298,11 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n       /* Incomplete definitions of structs should not get a name.  */\n       if (TYPE_NAME (SYMBOL_TYPE (s)) == NULL\n \t  && (TYPE_NFIELDS (SYMBOL_TYPE (s)) != 0\n-\t      || (TYPE_CODE (SYMBOL_TYPE (s)) != TYPE_CODE_STRUCT\n-\t\t  && TYPE_CODE (SYMBOL_TYPE (s)) != TYPE_CODE_UNION)))\n+\t      || (SYMBOL_TYPE (s)->code () != TYPE_CODE_STRUCT\n+\t\t  && SYMBOL_TYPE (s)->code () != TYPE_CODE_UNION)))\n \t{\n-\t  if (TYPE_CODE (SYMBOL_TYPE (s)) == TYPE_CODE_PTR\n-\t      || TYPE_CODE (SYMBOL_TYPE (s)) == TYPE_CODE_FUNC)\n+\t  if (SYMBOL_TYPE (s)->code () == TYPE_CODE_PTR\n+\t      || SYMBOL_TYPE (s)->code () == TYPE_CODE_FUNC)\n \t    {\n \t      /* If we are giving a name to a type such as \"pointer to\n \t         foo\" or \"function returning foo\", we better not set\n@@ -1639,16 +1639,16 @@ parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,\n \n       /* DEC c89 produces cross references to qualified aggregate types,\n          dereference them.  */\n-      while (TYPE_CODE (tp) == TYPE_CODE_PTR\n-\t     || TYPE_CODE (tp) == TYPE_CODE_ARRAY)\n+      while (tp->code () == TYPE_CODE_PTR\n+\t     || tp->code () == TYPE_CODE_ARRAY)\n \ttp = TYPE_TARGET_TYPE (tp);\n \n       /* Make sure that TYPE_CODE(tp) has an expected type code.\n          Any type may be returned from cross_ref if file indirect entries\n          are corrupted.  */\n-      if (TYPE_CODE (tp) != TYPE_CODE_STRUCT\n-\t  && TYPE_CODE (tp) != TYPE_CODE_UNION\n-\t  && TYPE_CODE (tp) != TYPE_CODE_ENUM)\n+      if (tp->code () != TYPE_CODE_STRUCT\n+\t  && tp->code () != TYPE_CODE_UNION\n+\t  && tp->code () != TYPE_CODE_ENUM)\n \t{\n \t  unexpected_type_code_complaint (sym_name);\n \t}\n@@ -1658,15 +1658,15 @@ parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,\n \t     exception is if we guessed wrong re struct/union/enum.\n \t     But for struct vs. union a wrong guess is harmless, so\n \t     don't complain().  */\n-\t  if ((TYPE_CODE (tp) == TYPE_CODE_ENUM\n+\t  if ((tp->code () == TYPE_CODE_ENUM\n \t       && type_code != TYPE_CODE_ENUM)\n-\t      || (TYPE_CODE (tp) != TYPE_CODE_ENUM\n+\t      || (tp->code () != TYPE_CODE_ENUM\n \t\t  && type_code == TYPE_CODE_ENUM))\n \t    {\n \t      bad_tag_guess_complaint (sym_name);\n \t    }\n \n-\t  if (TYPE_CODE (tp) != type_code)\n+\t  if (tp->code () != type_code)\n \t    {\n \t      tp->set_code (type_code);\n \t    }\n@@ -1698,15 +1698,15 @@ parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,\n       /* Make sure that TYPE_CODE(tp) has an expected type code.\n          Any type may be returned from cross_ref if file indirect entries\n          are corrupted.  */\n-      if (TYPE_CODE (tp) != TYPE_CODE_RANGE)\n+      if (tp->code () != TYPE_CODE_RANGE)\n \t{\n \t  unexpected_type_code_complaint (sym_name);\n \t}\n       else\n \t{\n \t  /* Usually, TYPE_CODE(tp) is already type_code.  The main\n \t     exception is if we guessed wrong re struct/union/enum.  */\n-\t  if (TYPE_CODE (tp) != type_code)\n+\t  if (tp->code () != type_code)\n \t    {\n \t      bad_tag_guess_complaint (sym_name);\n \t      tp->set_code (type_code);\n@@ -1831,7 +1831,7 @@ upgrade_type (int fd, struct type **tpp, int tq, union aux_ext *ax, int bigend,\n \n       /* The bounds type should be an integer type, but might be anything\n          else due to corrupt aux entries.  */\n-      if (TYPE_CODE (indx) != TYPE_CODE_INT)\n+      if (indx->code () != TYPE_CODE_INT)\n \t{\n \t  complaint (_(\"illegal array index type for %s, assuming int\"),\n \t\t     sym_name);\n@@ -2038,7 +2038,7 @@ parse_procedure (PDR *pr, struct compunit_symtab *search_symtab,\n \n   if (processing_gcc_compilation == 0\n       && found_ecoff_debugging_info == 0\n-      && TYPE_CODE (TYPE_TARGET_TYPE (SYMBOL_TYPE (s))) == TYPE_CODE_VOID)\n+      && TYPE_TARGET_TYPE (SYMBOL_TYPE (s))->code () == TYPE_CODE_VOID)\n     SYMBOL_TYPE (s) = objfile_type (mdebugread_objfile)->nodebug_text_symbol;\n }\n "
    },
    {
      "sha": "ef0910936209c319192e378de1e9237497eb6c10",
      "filename": "gdb/mi/mi-cmd-stack.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mi/mi-cmd-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mi/mi-cmd-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-stack.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -650,9 +650,9 @@ list_args_or_locals (const frame_print_options &fp_opts,\n \t\t{\n \t\tcase PRINT_SIMPLE_VALUES:\n \t\t  type = check_typedef (sym2->type);\n-\t\t  if (TYPE_CODE (type) != TYPE_CODE_ARRAY\n-\t\t      && TYPE_CODE (type) != TYPE_CODE_STRUCT\n-\t\t      && TYPE_CODE (type) != TYPE_CODE_UNION)\n+\t\t  if (type->code () != TYPE_CODE_ARRAY\n+\t\t      && type->code () != TYPE_CODE_STRUCT\n+\t\t      && type->code () != TYPE_CODE_UNION)\n \t\t    {\n \t\tcase PRINT_ALL_VALUES:\n \t\t  if (SYMBOL_IS_ARGUMENT (sym))"
    },
    {
      "sha": "da5bf2d7fac1e6bddd706f97cb2629486ad65aa7",
      "filename": "gdb/mi/mi-cmd-var.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mi/mi-cmd-var.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mi/mi-cmd-var.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-var.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -340,9 +340,9 @@ mi_print_value_p (struct varobj *var, enum print_values print_values)\n \n       /* For PRINT_SIMPLE_VALUES, only print the value if it has a type\n \t and that type is not a compound type.  */\n-      return (TYPE_CODE (type) != TYPE_CODE_ARRAY\n-\t      && TYPE_CODE (type) != TYPE_CODE_STRUCT\n-\t      && TYPE_CODE (type) != TYPE_CODE_UNION);\n+      return (type->code () != TYPE_CODE_ARRAY\n+\t      && type->code () != TYPE_CODE_STRUCT\n+\t      && type->code () != TYPE_CODE_UNION);\n     }\n }\n "
    },
    {
      "sha": "55bb777ef7704ce2c05bf553d1a6f706c513acdd",
      "filename": "gdb/mi/mi-main.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mi/mi-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mi/mi-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -2458,9 +2458,9 @@ print_variable_or_computed (const char *expression, enum print_values values)\n       type = check_typedef (value_type (val));\n       type_print (value_type (val), \"\", &stb, -1);\n       uiout->field_stream (\"type\", stb);\n-      if (TYPE_CODE (type) != TYPE_CODE_ARRAY\n-\t  && TYPE_CODE (type) != TYPE_CODE_STRUCT\n-\t  && TYPE_CODE (type) != TYPE_CODE_UNION)\n+      if (type->code () != TYPE_CODE_ARRAY\n+\t  && type->code () != TYPE_CODE_STRUCT\n+\t  && type->code () != TYPE_CODE_UNION)\n \t{\n \t  struct value_print_options opts;\n "
    },
    {
      "sha": "df59f416b8e142d12b29c38c2dd6ebe550f59685",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 35,
      "deletions": 35,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -687,7 +687,7 @@ mips_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n   if (reggroup == all_reggroup)\n     return pseudo;\n   vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));\n-  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;\n+  float_p = register_type (gdbarch, regnum)->code () == TYPE_CODE_FLT;\n   /* FIXME: cagney/2003-04-13: Can't yet use gdbarch_num_regs\n      (gdbarch), as not all architectures are multi-arch.  */\n   raw_p = rawnum < gdbarch_num_regs (gdbarch);\n@@ -889,7 +889,7 @@ mips_convert_register_float_case_p (struct gdbarch *gdbarch, int regnum,\n   return (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG\n \t  && register_size (gdbarch, regnum) == 4\n \t  && mips_float_register_p (gdbarch, regnum)\n-\t  && TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8);\n+\t  && type->code () == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8);\n }\n \n /* This predicate tests for the case of a value of less than 8\n@@ -4408,7 +4408,7 @@ fp_register_arg_p (struct gdbarch *gdbarch, enum type_code typecode,\n \t       && (typecode == TYPE_CODE_STRUCT\n \t\t   || typecode == TYPE_CODE_UNION)\n \t       && TYPE_NFIELDS (arg_type) == 1\n-\t       && TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (arg_type, 0))) \n+\t       && check_typedef (TYPE_FIELD_TYPE (arg_type, 0))->code ()\n \t       == TYPE_CODE_FLT))\n \t  && MIPS_FPU_TYPE(gdbarch) != MIPS_FPU_NONE);\n }\n@@ -4419,7 +4419,7 @@ fp_register_arg_p (struct gdbarch *gdbarch, enum type_code typecode,\n static int\n mips_type_needs_double_align (struct type *type)\n {\n-  enum type_code typecode = TYPE_CODE (type);\n+  enum type_code typecode = type->code ();\n \n   if (typecode == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8)\n     return 1;\n@@ -4562,7 +4562,7 @@ mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n \n       if (mips_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n@@ -4782,17 +4782,17 @@ mips_eabi_return_value (struct gdbarch *gdbarch, struct value *function,\n   /* Floating point type?  */\n   if (tdep->mips_fpu_type != MIPS_FPU_NONE)\n     {\n-      if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+      if (type->code () == TYPE_CODE_FLT)\n \tfp_return_type = 1;\n       /* Structs with a single field of float type \n \t are returned in a floating point register.  */\n-      if ((TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t   || TYPE_CODE (type) == TYPE_CODE_UNION)\n+      if ((type->code () == TYPE_CODE_STRUCT\n+\t   || type->code () == TYPE_CODE_UNION)\n \t  && TYPE_NFIELDS (type) == 1)\n \t{\n \t  struct type *fieldtype = TYPE_FIELD_TYPE (type, 0);\n \n-\t  if (TYPE_CODE (check_typedef (fieldtype)) == TYPE_CODE_FLT)\n+\t  if (check_typedef (fieldtype)->code () == TYPE_CODE_FLT)\n \t    fp_return_type = 1;\n \t}\n     }\n@@ -4841,7 +4841,7 @@ mips_n32n64_fp_arg_chunk_p (struct gdbarch *gdbarch, struct type *arg_type,\n {\n   int i;\n \n-  if (TYPE_CODE (arg_type) != TYPE_CODE_STRUCT)\n+  if (arg_type->code () != TYPE_CODE_STRUCT)\n     return 0;\n \n   if (MIPS_FPU_TYPE (gdbarch) != MIPS_FPU_DOUBLE)\n@@ -4873,7 +4873,7 @@ mips_n32n64_fp_arg_chunk_p (struct gdbarch *gdbarch, struct type *arg_type,\n \tcontinue;\n \n       /* If this is our special aligned double, we can stop.  */\n-      if (TYPE_CODE (field_type) == TYPE_CODE_FLT\n+      if (field_type->code () == TYPE_CODE_FLT\n \t  && TYPE_LENGTH (field_type) == MIPS64_REGSIZE)\n \treturn 1;\n \n@@ -4952,7 +4952,7 @@ mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n \n       if (mips_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n@@ -5189,7 +5189,7 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   if (TYPE_LENGTH (type) > 2 * MIPS64_REGSIZE)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n-  else if (TYPE_CODE (type) == TYPE_CODE_FLT\n+  else if (type->code () == TYPE_CODE_FLT\n \t   && TYPE_LENGTH (type) == 16\n \t   && tdep->mips_fpu_type != MIPS_FPU_NONE)\n     {\n@@ -5211,7 +5211,7 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\t  writebuf ? writebuf + 8 : writebuf, 0);\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_FLT\n+  else if (type->code () == TYPE_CODE_FLT\n \t   && tdep->mips_fpu_type != MIPS_FPU_NONE)\n     {\n       /* A single or double floating-point value that fits in FP0.  */\n@@ -5225,16 +5225,16 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\t  readbuf, writebuf, 0);\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  else if (type->code () == TYPE_CODE_STRUCT\n \t   && TYPE_NFIELDS (type) <= 2\n \t   && TYPE_NFIELDS (type) >= 1\n \t   && ((TYPE_NFIELDS (type) == 1\n-\t\t&& (TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, 0)))\n+\t\t&& (check_typedef (TYPE_FIELD_TYPE (type, 0))->code ()\n \t\t    == TYPE_CODE_FLT))\n \t       || (TYPE_NFIELDS (type) == 2\n-\t\t   && (TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, 0)))\n+\t\t   && (check_typedef (TYPE_FIELD_TYPE (type, 0))->code ()\n \t\t       == TYPE_CODE_FLT)\n-\t\t   && (TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, 1)))\n+\t\t   && (check_typedef (TYPE_FIELD_TYPE (type, 1))->code ()\n \t\t       == TYPE_CODE_FLT))))\n     {\n       /* A struct that contains one or two floats.  Each value is part\n@@ -5276,9 +5276,9 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n \t}\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t   || TYPE_CODE (type) == TYPE_CODE_UNION\n-\t   || TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  else if (type->code () == TYPE_CODE_STRUCT\n+\t   || type->code () == TYPE_CODE_UNION\n+\t   || type->code () == TYPE_CODE_ARRAY)\n     {\n       /* A composite type.  Extract the left justified value,\n          regardless of the byte order.  I.e. DO NOT USE\n@@ -5419,7 +5419,7 @@ mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n \n       if (mips_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n@@ -5663,11 +5663,11 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n   enum mips_fval_reg fval_reg;\n \n   fval_reg = readbuf ? mips16 ? mips_fval_gpr : mips_fval_fpr : mips_fval_both;\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || type->code () == TYPE_CODE_ARRAY)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n-  else if (TYPE_CODE (type) == TYPE_CODE_FLT\n+  else if (type->code () == TYPE_CODE_FLT\n \t   && TYPE_LENGTH (type) == 4 && tdep->mips_fpu_type != MIPS_FPU_NONE)\n     {\n       /* A single-precision floating-point value.  If reading in or copying,\n@@ -5704,7 +5704,7 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\t    readbuf, writebuf, 0);\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_FLT\n+  else if (type->code () == TYPE_CODE_FLT\n \t   && TYPE_LENGTH (type) == 8 && tdep->mips_fpu_type != MIPS_FPU_NONE)\n     {\n       /* A double-precision floating-point value.  If reading in or copying,\n@@ -5778,7 +5778,7 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n #if 0\n-  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  else if (type->code () == TYPE_CODE_STRUCT\n \t   && TYPE_NFIELDS (type) <= 2\n \t   && TYPE_NFIELDS (type) >= 1\n \t   && ((TYPE_NFIELDS (type) == 1\n@@ -5814,8 +5814,8 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n     }\n #endif\n #if 0\n-  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t   || TYPE_CODE (type) == TYPE_CODE_UNION)\n+  else if (type->code () == TYPE_CODE_STRUCT\n+\t   || type->code () == TYPE_CODE_UNION)\n     {\n       /* A structure or union.  Extract the left justified value,\n          regardless of the byte order.  I.e. DO NOT USE\n@@ -5941,7 +5941,7 @@ mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n \n       if (mips_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n@@ -6109,11 +6109,11 @@ mips_o64_return_value (struct gdbarch *gdbarch, struct value *function,\n   enum mips_fval_reg fval_reg;\n \n   fval_reg = readbuf ? mips16 ? mips_fval_gpr : mips_fval_fpr : mips_fval_both;\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || type->code () == TYPE_CODE_ARRAY)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n-  else if (fp_register_arg_p (gdbarch, TYPE_CODE (type), type))\n+  else if (fp_register_arg_p (gdbarch, type->code (), type))\n     {\n       /* A floating-point value.  If reading in or copying, then we get it\n          from/put it to FP0 for standard MIPS code or GPR2 for MIPS16 code."
    },
    {
      "sha": "98660485f7ca7a325a468202f52b76906316d04f",
      "filename": "gdb/mn10300-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mn10300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/mn10300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -88,7 +88,7 @@ mn10300_type_align (struct type *type)\n {\n   int i, align = 1;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_ENUM:\n@@ -137,7 +137,7 @@ mn10300_use_struct_convention (struct type *type)\n   if (TYPE_LENGTH (type) > 8)\n     return 1;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n@@ -174,7 +174,7 @@ mn10300_store_return_value (struct gdbarch *gdbarch, struct type *type,\n   int len = TYPE_LENGTH (type);\n   int reg, regsz;\n   \n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     reg = 4;\n   else\n     reg = 0;\n@@ -202,7 +202,7 @@ mn10300_extract_return_value (struct gdbarch *gdbarch, struct type *type,\n   int len = TYPE_LENGTH (type);\n   int reg, regsz;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     reg = 4;\n   else\n     reg = 0;\n@@ -1208,7 +1208,7 @@ mn10300_push_dummy_call (struct gdbarch *gdbarch,\n   for (argnum = 0; argnum < nargs; argnum++)\n     {\n       /* FIXME what about structs?  Unions?  */\n-      if (TYPE_CODE (value_type (*args)) == TYPE_CODE_STRUCT\n+      if (value_type (*args)->code () == TYPE_CODE_STRUCT\n \t  && TYPE_LENGTH (value_type (*args)) > 8)\n \t{\n \t  /* Change to pointer-to-type.  */"
    },
    {
      "sha": "9119b5f2429725f60bfb5136c1bdd661da7157de",
      "filename": "gdb/msp430-tdep.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/msp430-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/msp430-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/msp430-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -570,8 +570,8 @@ msp430_return_value (struct gdbarch *gdbarch,\n   int code_model = gdbarch_tdep (gdbarch)->code_model;\n \n   if (TYPE_LENGTH (valtype) > 8\n-      || TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (valtype) == TYPE_CODE_UNION)\n+      || valtype->code () == TYPE_CODE_STRUCT\n+      || valtype->code () == TYPE_CODE_UNION)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n \n   if (readbuf)\n@@ -585,7 +585,7 @@ msp430_return_value (struct gdbarch *gdbarch,\n \t  int size = 2;\n \n \t  if (code_model == MSP_LARGE_CODE_MODEL\n-\t      && TYPE_CODE (valtype) == TYPE_CODE_PTR)\n+\t      && valtype->code () == TYPE_CODE_PTR)\n \t    {\n \t      size = 4;\n \t    }\n@@ -609,7 +609,7 @@ msp430_return_value (struct gdbarch *gdbarch,\n \t  int size = 2;\n \n \t  if (code_model == MSP_LARGE_CODE_MODEL\n-\t      && TYPE_CODE (valtype) == TYPE_CODE_PTR)\n+\t      && valtype->code () == TYPE_CODE_PTR)\n \t    {\n \t      size = 4;\n \t    }\n@@ -652,12 +652,12 @@ msp430_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   struct type *func_type = value_type (function);\n \n   /* Dereference function pointer types.  */\n-  while (TYPE_CODE (func_type) == TYPE_CODE_PTR)\n+  while (func_type->code () == TYPE_CODE_PTR)\n     func_type = TYPE_TARGET_TYPE (func_type);\n \n   /* The end result had better be a function or a method.  */\n-  gdb_assert (TYPE_CODE (func_type) == TYPE_CODE_FUNC\n-\t      || TYPE_CODE (func_type) == TYPE_CODE_METHOD);\n+  gdb_assert (func_type->code () == TYPE_CODE_FUNC\n+\t      || func_type->code () == TYPE_CODE_METHOD);\n \n   /* We make two passes; the first does the stack allocation,\n      the second actually stores the arguments.  */\n@@ -691,8 +691,8 @@ msp430_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n \t  current_arg_on_stack = 0;\n \n-\t  if (TYPE_CODE (arg_type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (arg_type) == TYPE_CODE_UNION)\n+\t  if (arg_type->code () == TYPE_CODE_STRUCT\n+\t      || arg_type->code () == TYPE_CODE_UNION)\n \t    {\n \t      /* Aggregates of any size are passed by reference.  */\n \t      store_unsigned_integer (struct_addr_buf, 4, byte_order,\n@@ -723,10 +723,10 @@ msp430_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t  int size = 2;\n \n \t\t  if (code_model == MSP_LARGE_CODE_MODEL\n-\t\t      && (TYPE_CODE (arg_type) == TYPE_CODE_PTR\n+\t\t      && (arg_type->code () == TYPE_CODE_PTR\n \t\t          || TYPE_IS_REFERENCE (arg_type)\n-\t\t\t  || TYPE_CODE (arg_type) == TYPE_CODE_STRUCT\n-\t\t\t  || TYPE_CODE (arg_type) == TYPE_CODE_UNION))\n+\t\t\t  || arg_type->code () == TYPE_CODE_STRUCT\n+\t\t\t  || arg_type->code () == TYPE_CODE_UNION))\n \t\t    {\n \t\t      /* When using the large memory model, pointer,\n \t\t\t reference, struct, and union arguments are"
    },
    {
      "sha": "d4d07c030f1bd95bad99485aa0a6f0c06704ed71",
      "filename": "gdb/nds32-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/nds32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/nds32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nds32-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1402,7 +1402,7 @@ nds32_check_calling_use_fpr (struct type *type)\n   while (1)\n     {\n       t = check_typedef (t);\n-      typecode = TYPE_CODE (t);\n+      typecode = t->code ();\n       if (typecode != TYPE_CODE_STRUCT)\n \tbreak;\n       else if (TYPE_NFIELDS (t) != 1)"
    },
    {
      "sha": "acc287350354b0fe14da665be2a1abda14d7a05a",
      "filename": "gdb/nios2-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/nios2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/nios2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -2236,7 +2236,7 @@ nios2_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n static ULONGEST\n nios2_type_align (struct gdbarch *gdbarch, struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_FUNC:"
    },
    {
      "sha": "d724433d565acc25de4d7cc3ab4733b2ad51f855",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -95,7 +95,7 @@ lookup_struct_typedef (const char *name, const struct block *block, int noerr)\n       else \n \terror (_(\"No struct type named %s.\"), name);\n     }\n-  if (TYPE_CODE (SYMBOL_TYPE (sym)) != TYPE_CODE_STRUCT)\n+  if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_STRUCT)\n     {\n       if (noerr)\n \treturn 0;"
    },
    {
      "sha": "0cd3501c4d9906c70288b5ea5bdd95b164dc69df",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -96,9 +96,9 @@ lookup_opencl_vector_type (struct gdbarch *gdbarch, enum type_code code,\n     {\n       LONGEST lowb, highb;\n \n-      if (TYPE_CODE (types[i]) == TYPE_CODE_ARRAY && TYPE_VECTOR (types[i])\n+      if (types[i]->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (types[i])\n \t  && get_array_bounds (types[i], &lowb, &highb)\n-\t  && TYPE_CODE (TYPE_TARGET_TYPE (types[i])) == code\n+\t  && TYPE_TARGET_TYPE (types[i])->code () == code\n \t  && TYPE_UNSIGNED (TYPE_TARGET_TYPE (types[i])) == flag_unsigned\n \t  && TYPE_LENGTH (TYPE_TARGET_TYPE (types[i])) == el_length\n \t  && TYPE_LENGTH (types[i]) == length\n@@ -177,7 +177,7 @@ lval_func_read (struct value *v)\n   LONGEST lowb = 0;\n   LONGEST highb = 0;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+  if (type->code () == TYPE_CODE_ARRAY\n       && !get_array_bounds (type, &lowb, &highb))\n     error (_(\"Could not determine the vector bounds\"));\n \n@@ -206,7 +206,7 @@ lval_func_write (struct value *v, struct value *fromval)\n   LONGEST lowb = 0;\n   LONGEST highb = 0;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+  if (type->code () == TYPE_CODE_ARRAY\n       && !get_array_bounds (type, &lowb, &highb))\n     error (_(\"Could not determine the vector bounds\"));\n \n@@ -336,7 +336,7 @@ create_value (struct gdbarch *gdbarch, struct value *val, enum noside noside,\n       /* Multiple components of the vector are requested which means the\n \t resulting type is a vector as well.  */\n       struct type *dst_type =\n-\tlookup_opencl_vector_type (gdbarch, TYPE_CODE (elm_type),\n+\tlookup_opencl_vector_type (gdbarch, elm_type->code (),\n \t\t\t\t   TYPE_LENGTH (elm_type),\n \t\t\t\t   TYPE_UNSIGNED (elm_type), n);\n \n@@ -497,7 +497,7 @@ opencl_logical_not (struct expression *exp, struct value *arg)\n   struct type *rettype;\n   struct value *ret;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n     {\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));\n       LONGEST lowb, highb;\n@@ -586,8 +586,8 @@ vector_relop (struct expression *exp, struct value *val1, struct value *val2,\n   type1 = check_typedef (value_type (val1));\n   type2 = check_typedef (value_type (val2));\n \n-  t1_is_vec = (TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1));\n-  t2_is_vec = (TYPE_CODE (type2) == TYPE_CODE_ARRAY && TYPE_VECTOR (type2));\n+  t1_is_vec = (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1));\n+  t2_is_vec = (type2->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type2));\n \n   if (!t1_is_vec || !t2_is_vec)\n     error (_(\"Vector operations are not supported on scalar types\"));\n@@ -600,7 +600,7 @@ vector_relop (struct expression *exp, struct value *val1, struct value *val2,\n     error (_(\"Could not determine the vector bounds\"));\n \n   /* Check whether the vector types are compatible.  */\n-  if (TYPE_CODE (eltype1) != TYPE_CODE (eltype2)\n+  if (eltype1->code () != eltype2->code ()\n       || TYPE_LENGTH (eltype1) != TYPE_LENGTH (eltype2)\n       || TYPE_UNSIGNED (eltype1) != TYPE_UNSIGNED (eltype2)\n       || lowb1 != lowb2 || highb1 != highb2)\n@@ -647,11 +647,11 @@ opencl_value_cast (struct type *type, struct value *arg)\n \n       to_type = check_typedef (type);\n \n-      code1 = TYPE_CODE (to_type);\n-      code2 = TYPE_CODE (check_typedef (value_type (arg)));\n+      code1 = to_type->code ();\n+      code2 = check_typedef (value_type (arg))->code ();\n \n       if (code2 == TYPE_CODE_REF)\n-\tcode2 = TYPE_CODE (check_typedef (value_type (coerce_ref (arg))));\n+\tcode2 = check_typedef (value_type (coerce_ref(arg)))->code ();\n \n       scalar = (code2 == TYPE_CODE_INT || code2 == TYPE_CODE_BOOL\n \t\t|| code2 == TYPE_CODE_CHAR || code2 == TYPE_CODE_FLT\n@@ -687,9 +687,9 @@ opencl_relop (struct expression *exp, struct value *arg1, struct value *arg2,\n   struct value *val;\n   struct type *type1 = check_typedef (value_type (arg1));\n   struct type *type2 = check_typedef (value_type (arg2));\n-  int t1_is_vec = (TYPE_CODE (type1) == TYPE_CODE_ARRAY\n+  int t1_is_vec = (type1->code () == TYPE_CODE_ARRAY\n \t\t   && TYPE_VECTOR (type1));\n-  int t2_is_vec = (TYPE_CODE (type2) == TYPE_CODE_ARRAY\n+  int t2_is_vec = (type2->code () == TYPE_CODE_ARRAY\n \t\t   && TYPE_VECTOR (type2));\n \n   if (!t1_is_vec && !t2_is_vec)\n@@ -710,7 +710,7 @@ opencl_relop (struct expression *exp, struct value *arg1, struct value *arg2,\n       struct value **v = t1_is_vec ? &arg2 : &arg1;\n       struct type *t = t1_is_vec ? type2 : type1;\n \n-      if (TYPE_CODE (t) != TYPE_CODE_FLT && !is_integral_type (t))\n+      if (t->code () != TYPE_CODE_FLT && !is_integral_type (t))\n \terror (_(\"Argument to operation not a number or boolean.\"));\n \n       *v = opencl_value_cast (t1_is_vec ? type1 : type2, *v);\n@@ -832,8 +832,8 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n \t  type1 = check_typedef (value_type (arg1));\n \t  type2 = check_typedef (value_type (arg2));\n \n-\t  if ((TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n-\t      || (TYPE_CODE (type2) == TYPE_CODE_ARRAY && TYPE_VECTOR (type2)))\n+\t  if ((type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n+\t      || (type2->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type2)))\n \t    {\n \t      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n \n@@ -868,7 +868,7 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n       (*pos)++;\n       arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n       type1 = check_typedef (value_type (arg1));\n-      if (TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n+      if (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n \t{\n \t  struct value *arg3, *tmp, *ret;\n \t  struct type *eltype2, *type3, *eltype3;\n@@ -880,9 +880,9 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n \t  type2 = check_typedef (value_type (arg2));\n \t  type3 = check_typedef (value_type (arg3));\n \t  t2_is_vec\n-\t    = TYPE_CODE (type2) == TYPE_CODE_ARRAY && TYPE_VECTOR (type2);\n+\t    = type2->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type2);\n \t  t3_is_vec\n-\t    = TYPE_CODE (type3) == TYPE_CODE_ARRAY && TYPE_VECTOR (type3);\n+\t    = type3->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type3);\n \n \t  /* Widen the scalar operand to a vector if necessary.  */\n \t  if (t2_is_vec || !t3_is_vec)\n@@ -911,7 +911,7 @@ Cannot perform conditional operation on incompatible types\"));\n \t    error (_(\"Could not determine the vector bounds\"));\n \n \t  /* Throw an error if the types of arg2 or arg3 are incompatible.  */\n-\t  if (TYPE_CODE (eltype2) != TYPE_CODE (eltype3)\n+\t  if (eltype2->code () != eltype3->code ()\n \t      || TYPE_LENGTH (eltype2) != TYPE_LENGTH (eltype3)\n \t      || TYPE_UNSIGNED (eltype2) != TYPE_UNSIGNED (eltype3)\n \t      || lowb2 != lowb3 || highb2 != highb3)\n@@ -971,7 +971,7 @@ Cannot perform conditional operation on vectors with different sizes\"));\n \t    return value_from_longest (builtin_type (exp->gdbarch)->\n \t\t\t\t       builtin_int, 1);\n \t  }\n-\telse if (TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n+\telse if (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n \t  {\n \t    return opencl_component_ref (exp, arg1, &exp->elts[pc + 2].string,\n \t\t\t\t\t noside);\n@@ -1007,7 +1007,7 @@ opencl_print_type (struct type *type, const char *varstring,\n   if (show > 0)\n     {\n       type = check_typedef (type);\n-      if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+      if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n \t  && TYPE_NAME (type) != NULL)\n \tshow = 0;\n     }"
    },
    {
      "sha": "37fb90c391d2f4ec259d08951e47c3863ddb2a60",
      "filename": "gdb/or1k-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/or1k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/or1k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/or1k-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -245,7 +245,7 @@ or1k_return_value (struct gdbarch *gdbarch, struct value *functype,\n \t\t   gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  enum type_code rv_type = TYPE_CODE (valtype);\n+  enum type_code rv_type = valtype->code ();\n   unsigned int rv_size = TYPE_LENGTH (valtype);\n   int bpw = (gdbarch_tdep (gdbarch))->bytes_per_word;\n \n@@ -633,7 +633,7 @@ or1k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n \n       if (TYPE_VARARGS (func_type) && argnum >= TYPE_NFIELDS (func_type))\n \tbreak; /* end or regular args, varargs go to stack.  */\n@@ -723,7 +723,7 @@ or1k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n \n       if ((TYPE_CODE_STRUCT == typecode) || (TYPE_CODE_UNION == typecode)\n \t  || (len > bpw * 2))\n@@ -755,7 +755,7 @@ or1k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n       /* The EABI passes structures that do not fit in a register by\n          reference.  In all other cases, pass the structure by value.  */\n       if ((TYPE_CODE_STRUCT == typecode) || (TYPE_CODE_UNION == typecode)"
    },
    {
      "sha": "e332fe9e0db5822eb598efea8c7b16600baca34b",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -257,7 +257,7 @@ exp\t:\tfield_exp FIELDNAME\n \t\t\t  search_field = 0;\n \t\t\t  if (current_type)\n \t\t\t    {\n-\t\t\t      while (TYPE_CODE (current_type)\n+\t\t\t      while (current_type->code ()\n \t\t\t\t     == TYPE_CODE_PTR)\n \t\t\t\tcurrent_type =\n \t\t\t\t  TYPE_TARGET_TYPE (current_type);\n@@ -275,7 +275,7 @@ exp\t:\tfield_exp name\n \t\t\t  search_field = 0;\n \t\t\t  if (current_type)\n \t\t\t    {\n-\t\t\t      while (TYPE_CODE (current_type)\n+\t\t\t      while (current_type->code ()\n \t\t\t\t     == TYPE_CODE_PTR)\n \t\t\t\tcurrent_type =\n \t\t\t\t  TYPE_TARGET_TYPE (current_type);\n@@ -357,9 +357,9 @@ exp\t:\ttype '(' exp ')' %prec UNARY\n \t\t\t{ if (current_type)\n \t\t\t    {\n \t\t\t      /* Allow automatic dereference of classes.  */\n-\t\t\t      if ((TYPE_CODE (current_type) == TYPE_CODE_PTR)\n-\t\t\t\t  && (TYPE_CODE (TYPE_TARGET_TYPE (current_type)) == TYPE_CODE_STRUCT)\n-\t\t\t\t  && (TYPE_CODE ($1) == TYPE_CODE_STRUCT))\n+\t\t\t      if ((current_type->code () == TYPE_CODE_PTR)\n+\t\t\t\t  && (TYPE_TARGET_TYPE (current_type)->code () == TYPE_CODE_STRUCT)\n+\t\t\t\t  && (($1)->code () == TYPE_CODE_STRUCT))\n \t\t\t\twrite_exp_elt_opcode (pstate, UNOP_IND);\n \t\t\t    }\n \t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST);\n@@ -601,7 +601,7 @@ exp\t:\tTHIS\n \t\t\t    this_type = NULL;\n \t\t\t  if (this_type)\n \t\t\t    {\n-\t\t\t      if (TYPE_CODE (this_type) == TYPE_CODE_PTR)\n+\t\t\t      if (this_type->code () == TYPE_CODE_PTR)\n \t\t\t\t{\n \t\t\t\t  this_type = TYPE_TARGET_TYPE (this_type);\n \t\t\t\t  write_exp_elt_opcode (pstate, UNOP_IND);\n@@ -666,8 +666,8 @@ qualified_name:\ttypebase COLONCOLON name\n \t\t\t{\n \t\t\t  struct type *type = $1;\n \n-\t\t\t  if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n-\t\t\t      && TYPE_CODE (type) != TYPE_CODE_UNION)\n+\t\t\t  if (type->code () != TYPE_CODE_STRUCT\n+\t\t\t      && type->code () != TYPE_CODE_UNION)\n \t\t\t    error (_(\"`%s' is not defined as an aggregate type.\"),\n \t\t\t\t   TYPE_NAME (type));\n "
    },
    {
      "sha": "19dd850733552e1fc36a8d7b27b40d9553080bcc",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -100,7 +100,7 @@ is_pascal_string_type (struct type *type,int *length_pos,\n \t\t       struct type **char_type,\n \t\t       const char **arrayname)\n {\n-  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type != NULL && type->code () == TYPE_CODE_STRUCT)\n     {\n       /* Old Borland type pascal strings from Free Pascal Compiler.  */\n       /* Two fields: length and st.  */\n@@ -141,7 +141,7 @@ is_pascal_string_type (struct type *type,int *length_pos,\n \t    {\n \t      *char_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 2));\n \n-\t      if (TYPE_CODE (*char_type) == TYPE_CODE_ARRAY)\n+\t      if ((*char_type)->code () == TYPE_CODE_ARRAY)\n \t\t*char_type = TYPE_TARGET_TYPE (*char_type);\n \t    }\n  \t  if (arrayname)"
    },
    {
      "sha": "4d6eb26404484c7e88e0dcf05ebfb96af48800d8",
      "filename": "gdb/p-typeprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 14,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/p-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/p-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-typeprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -53,7 +53,7 @@ pascal_print_type (struct type *type, const char *varstring,\n   enum type_code code;\n   int demangled_args;\n \n-  code = TYPE_CODE (type);\n+  code = type->code ();\n \n   if (show > 0)\n     type = check_typedef (type);\n@@ -216,7 +216,7 @@ pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n \n   QUIT;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n       fprintf_filtered (stream, \"^\");\n@@ -229,7 +229,7 @@ pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n       if (passed_a_ptr)\n \tfprintf_filtered (stream, \"(\");\n       if (TYPE_TARGET_TYPE (type) != NULL\n-\t  && TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n+\t  && TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n \t{\n \t  fprintf_filtered (stream, \"function  \");\n \t}\n@@ -258,7 +258,7 @@ pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n \tfprintf_filtered (stream, \"(\");\n \n       if (TYPE_TARGET_TYPE (type) != NULL\n-\t  && TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n+\t  && TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n \t{\n \t  fprintf_filtered (stream, \"function  \");\n \t}\n@@ -347,7 +347,7 @@ pascal_type_print_func_varspec_suffix  (struct type *type, struct ui_file *strea\n \t\t\t\t\tconst struct type_print_options *flags)\n {\n   if (TYPE_TARGET_TYPE (type) == NULL\n-      || TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n+      || TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n     {\n       fprintf_filtered (stream, \" : \");\n       pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),\n@@ -382,7 +382,7 @@ pascal_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n \n   QUIT;\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       if (passed_a_ptr)\n@@ -476,8 +476,8 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n     }\n \n   /* void pointer */\n-  if ((TYPE_CODE (type) == TYPE_CODE_PTR)\n-      && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID))\n+  if ((type->code () == TYPE_CODE_PTR)\n+      && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_VOID))\n     {\n       fputs_filtered (TYPE_NAME (type) ? TYPE_NAME (type) : \"pointer\",\n \t\t      stream);\n@@ -495,7 +495,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \n   type = check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_TYPEDEF:\n     case TYPE_CODE_PTR:\n@@ -707,8 +707,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t\t      fprintf_filtered (stream, \"destructor  \");\n \t\t    }\n \t\t  else if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) != 0\n-\t\t\t   && TYPE_CODE (TYPE_TARGET_TYPE (\n-\t\t\t\tTYPE_FN_FIELD_TYPE (f, j))) != TYPE_CODE_VOID)\n+\t\t\t   && TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE(f, j))->code () != TYPE_CODE_VOID)\n \t\t    {\n \t\t      fprintf_filtered (stream, \"function  \");\n \t\t    }\n@@ -723,8 +722,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t\t\t\t\t\t stream);\n \n \t\t  if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) != 0\n-\t\t      && TYPE_CODE (TYPE_TARGET_TYPE (\n-\t\t\t   TYPE_FN_FIELD_TYPE (f, j))) != TYPE_CODE_VOID)\n+\t\t      && TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE(f, j))->code () != TYPE_CODE_VOID)\n \t\t    {\n \t\t      fputs_filtered (\" : \", stream);\n \t\t      type_print (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)),\n@@ -830,7 +828,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t     an error ().  */\n \t  fprintf_styled (stream, metadata_style.style (),\n \t\t\t  \"<invalid unnamed pascal type code %d>\",\n-\t\t\t  TYPE_CODE (type));\n+\t\t\t  type->code ());\n \t}\n       break;\n     }"
    },
    {
      "sha": "8172e049233ca5731fdaa8ef58517479753a5587",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -82,7 +82,7 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n   int want_space = 0;\n   const gdb_byte *valaddr = value_contents_for_printing (val);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       {\n@@ -98,7 +98,7 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n \t       is of TYPE_CODE_CHAR and element size is 1,2 or 4.  */\n \t    if (options->format == 's'\n \t\t|| ((eltlen == 1 || eltlen == 2 || eltlen == 4)\n-\t\t    && TYPE_CODE (elttype) == TYPE_CODE_CHAR\n+\t\t    && elttype->code () == TYPE_CODE_CHAR\n \t\t    && options->format == 0))\n \t      {\n \t\t/* If requested, look for the first null char and only print\n@@ -167,7 +167,7 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n     print_unpacked_pointer:\n       elttype = check_typedef (TYPE_TARGET_TYPE (type));\n \n-      if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)\n+      if (elttype->code () == TYPE_CODE_FUNC)\n \t{\n \t  /* Try to print what function it points to.  */\n \t  print_address_demangle (options, gdbarch, addr, stream, demangle);\n@@ -183,10 +183,10 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n       /* For a pointer to char or unsigned char, also print the string\n \t pointed to, unless pointer is null.  */\n       if (((TYPE_LENGTH (elttype) == 1\n-\t   && (TYPE_CODE (elttype) == TYPE_CODE_INT\n-\t      || TYPE_CODE (elttype) == TYPE_CODE_CHAR))\n-\t  || ((TYPE_LENGTH (elttype) == 2 || TYPE_LENGTH (elttype) == 4)\n-\t      && TYPE_CODE (elttype) == TYPE_CODE_CHAR))\n+\t   && (elttype->code () == TYPE_CODE_INT\n+               || elttype->code () == TYPE_CODE_CHAR))\n+           || ((TYPE_LENGTH (elttype) == 2 || TYPE_LENGTH (elttype) == 4)\n+               && elttype->code () == TYPE_CODE_CHAR))\n \t  && (options->format == 0 || options->format == 's')\n \t  && addr != 0)\n \t{\n@@ -397,7 +397,7 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n \n     default:\n       error (_(\"Invalid pascal type code %d in symbol table.\"),\n-\t     TYPE_CODE (type));\n+\t     type->code ());\n     }\n }\n \n@@ -417,12 +417,12 @@ pascal_value_print (struct value *val, struct ui_file *stream,\n \n      Object pascal: if it is a member pointer, we will take care\n      of that when we print it.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR\n-      || TYPE_CODE (type) == TYPE_CODE_REF)\n+  if (type->code () == TYPE_CODE_PTR\n+      || type->code () == TYPE_CODE_REF)\n     {\n       /* Hack:  remove (char *) for char strings.  Their\n          type is indicated by the quoted string anyway.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_PTR\n+      if (type->code () == TYPE_CODE_PTR\n \t  && TYPE_NAME (type) == NULL\n \t  && TYPE_NAME (TYPE_TARGET_TYPE (type)) != NULL\n \t  && strcmp (TYPE_NAME (TYPE_TARGET_TYPE (type)), \"char\") == 0)\n@@ -481,15 +481,15 @@ pascal_object_is_vtbl_ptr_type (struct type *type)\n int\n pascal_object_is_vtbl_member (struct type *type)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     {\n       type = TYPE_TARGET_TYPE (type);\n-      if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+      if (type->code () == TYPE_CODE_ARRAY)\n \t{\n \t  type = TYPE_TARGET_TYPE (type);\n-\t  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\t/* If not using\n+\t  if (type->code () == TYPE_CODE_STRUCT\t/* If not using\n \t\t\t\t\t\t\t   thunks.  */\n-\t      || TYPE_CODE (type) == TYPE_CODE_PTR)\t/* If using thunks.  */\n+\t      || type->code () == TYPE_CODE_PTR)\t/* If using thunks.  */\n \t    {\n \t      /* Virtual functions tables are full of pointers\n \t         to virtual functions.  */\n@@ -826,7 +826,7 @@ pascal_object_print_static_field (struct value *val,\n       return;\n     }\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     {\n       CORE_ADDR *first_dont_print, addr;\n       int i;"
    },
    {
      "sha": "4c4bdacf4d1f917709fd3baf690c3371cf3fc0d3",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -250,8 +250,8 @@ ppc_linux_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\tstruct type *valtype, struct regcache *regcache,\n \t\t\tgdb_byte *readbuf, const gdb_byte *writebuf)\n {  \n-  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-       || TYPE_CODE (valtype) == TYPE_CODE_UNION)\n+  if ((valtype->code () == TYPE_CODE_STRUCT\n+       || valtype->code () == TYPE_CODE_UNION)\n       && !((TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 8)\n \t   && TYPE_VECTOR (valtype)))\n     return RETURN_VALUE_STRUCT_CONVENTION;"
    },
    {
      "sha": "ba4e943a01a82a2c3c6dd847c6dd612227159b82",
      "filename": "gdb/ppc-nbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ppc-nbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ppc-nbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-nbsd-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -75,8 +75,8 @@ ppcnbsd_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t      gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n #if 0\n-  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-       || TYPE_CODE (valtype) == TYPE_CODE_UNION)\n+  if ((valtype->code () == TYPE_CODE_STRUCT\n+       || valtype->code () == TYPE_CODE_UNION)\n       && !((TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 8)\n \t    && TYPE_VECTOR (valtype))\n       && !(TYPE_LENGTH (valtype) == 1"
    },
    {
      "sha": "9dcf84c94c1655bfc52f1a72ba47a1d23f09e067",
      "filename": "gdb/ppc-sysv-tdep.c",
      "status": "modified",
      "additions": 99,
      "deletions": 99,
      "changes": 198,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ppc-sysv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/ppc-sysv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-sysv-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -40,10 +40,10 @@ ppc_sysv_use_opencl_abi (struct type *ftype)\n {\n   ftype = check_typedef (ftype);\n \n-  if (TYPE_CODE (ftype) == TYPE_CODE_PTR)\n+  if (ftype->code () == TYPE_CODE_PTR)\n     ftype = check_typedef (TYPE_TARGET_TYPE (ftype));\n \n-  return (TYPE_CODE (ftype) == TYPE_CODE_FUNC\n+  return (ftype->code () == TYPE_CODE_FUNC\n \t  && TYPE_CALLING_CONVENTION (ftype) == DW_CC_GDB_IBM_OpenCL);\n }\n \n@@ -124,7 +124,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  int len = TYPE_LENGTH (type);\n \t  const bfd_byte *val = value_contents (arg);\n \n-\t  if (TYPE_CODE (type) == TYPE_CODE_FLT && len <= 8\n+\t  if (type->code () == TYPE_CODE_FLT && len <= 8\n \t      && !tdep->soft_float)\n \t    {\n \t      /* Floating point value converted to \"double\" then\n@@ -164,7 +164,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t  argoffset += len;\n \t\t}\n \t    }\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_FLT\n+\t  else if (type->code () == TYPE_CODE_FLT\n \t\t   && len == 16\n \t\t   && !tdep->soft_float\n \t\t   && (gdbarch_long_double_format (gdbarch)\n@@ -191,9 +191,9 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t}\n \t    }\n \t  else if (len == 8\n-\t\t   && (TYPE_CODE (type) == TYPE_CODE_INT\t/* long long */\n-\t\t       || TYPE_CODE (type) == TYPE_CODE_FLT\t/* double */\n-\t\t       || (TYPE_CODE (type) == TYPE_CODE_DECFLOAT\n+\t\t   && (type->code () == TYPE_CODE_INT\t/* long long */\n+\t\t       || type->code () == TYPE_CODE_FLT\t/* double */\n+\t\t       || (type->code () == TYPE_CODE_DECFLOAT\n \t\t\t   && tdep->soft_float)))\n \t    {\n \t      /* \"long long\" or soft-float \"double\" or \"_Decimal64\"\n@@ -227,10 +227,10 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t}\n \t    }\n \t  else if (len == 16\n-\t\t   && ((TYPE_CODE (type) == TYPE_CODE_FLT\n+\t\t   && ((type->code () == TYPE_CODE_FLT\n \t\t\t&& (gdbarch_long_double_format (gdbarch)\n \t\t\t    == floatformats_ibm_long_double))\n-\t\t       || (TYPE_CODE (type) == TYPE_CODE_DECFLOAT\n+\t\t       || (type->code () == TYPE_CODE_DECFLOAT\n \t\t\t   && tdep->soft_float)))\n \t    {\n \t      /* Soft-float IBM long double or _Decimal128 passed in\n@@ -260,7 +260,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t  greg += 4;\n \t\t}\n \t    }\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && len <= 8\n+\t  else if (type->code () == TYPE_CODE_DECFLOAT && len <= 8\n \t\t   && !tdep->soft_float)\n \t    {\n \t      /* 32-bit and 64-bit decimal floats go in f1 .. f8.  They can\n@@ -299,7 +299,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t  argoffset += len;\n \t\t}\n \t    }\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && len == 16\n+\t  else if (type->code () == TYPE_CODE_DECFLOAT && len == 16\n \t\t   && !tdep->soft_float)\n \t    {\n \t      /* 128-bit decimal floats go in f2 .. f7, always in even/odd\n@@ -334,7 +334,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      freg += 2;\n \t    }\n \t  else if (len < 16\n-\t\t   && TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t\t   && type->code () == TYPE_CODE_ARRAY\n \t\t   && TYPE_VECTOR (type)\n \t\t   && opencl_abi)\n \t    {\n@@ -347,7 +347,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t{\n \t\t  const gdb_byte *elval = val + i * TYPE_LENGTH (eltype);\n \n-\t\t  if (TYPE_CODE (eltype) == TYPE_CODE_FLT && !tdep->soft_float)\n+\t\t  if (eltype->code () == TYPE_CODE_FLT && !tdep->soft_float)\n \t\t    {\n \t\t      if (freg <= 8)\n \t\t\t{\n@@ -421,7 +421,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t}\n \t    }\n \t  else if (len >= 16\n-\t\t   && TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t\t   && type->code () == TYPE_CODE_ARRAY\n \t\t   && TYPE_VECTOR (type)\n \t\t   && opencl_abi)\n \t    {\n@@ -450,7 +450,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t}\n \t    }\n \t  else if (len == 16\n-\t\t   && TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t\t   && type->code () == TYPE_CODE_ARRAY\n \t\t   && TYPE_VECTOR (type)\n \t\t   && tdep->vector_abi == POWERPC_VEC_ALTIVEC)\n \t    {\n@@ -471,7 +471,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t}\n \t    }\n \t  else if (len == 8\n-\t\t   && TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t\t   && type->code () == TYPE_CODE_ARRAY\n \t\t   && TYPE_VECTOR (type)\n \t\t   && tdep->vector_abi == POWERPC_VEC_SPE)\n \t    {\n@@ -503,12 +503,12 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      gdb_byte word[PPC_MAX_REGISTER_SIZE];\n \t      memset (word, 0, PPC_MAX_REGISTER_SIZE);\n \t      if (len > tdep->wordsize\n-\t\t  || TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t\t  || TYPE_CODE (type) == TYPE_CODE_UNION)\n+\t\t  || type->code () == TYPE_CODE_STRUCT\n+\t\t  || type->code () == TYPE_CODE_UNION)\n \t\t{\n \t\t  /* Structs and large values are put in an\n \t\t     aligned stack slot ...  */\n-\t\t  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t\t  if (type->code () == TYPE_CODE_ARRAY\n \t\t      && TYPE_VECTOR (type)\n \t\t      && len >= 16)\n \t\t    structoffset = align_up (structoffset, 16);\n@@ -523,7 +523,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\t\t  sp + structoffset);\n \t\t  structoffset += len;\n \t\t}\n-\t      else if (TYPE_CODE (type) == TYPE_CODE_INT)\n+\t      else if (type->code () == TYPE_CODE_INT)\n \t\t/* Sign or zero extend the \"int\" into a \"word\".  */\n \t\tstore_unsigned_integer (word, tdep->wordsize, byte_order,\n \t\t\t\t\tunpack_long (type, val));\n@@ -599,7 +599,7 @@ get_decimal_float_return_value (struct gdbarch *gdbarch, struct type *valtype,\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  gdb_assert (TYPE_CODE (valtype) == TYPE_CODE_DECFLOAT);\n+  gdb_assert (valtype->code () == TYPE_CODE_DECFLOAT);\n \n   /* 32-bit and 64-bit decimal floats in f1.  */\n   if (TYPE_LENGTH (valtype) <= 8)\n@@ -681,7 +681,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n \n   gdb_assert (tdep->wordsize == 4);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_FLT\n+  if (type->code () == TYPE_CODE_FLT\n       && TYPE_LENGTH (type) <= 8\n       && !tdep->soft_float)\n     {\n@@ -706,7 +706,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n \t}\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n-  if (TYPE_CODE (type) == TYPE_CODE_FLT\n+  if (type->code () == TYPE_CODE_FLT\n       && TYPE_LENGTH (type) == 16\n       && !tdep->soft_float\n       && (gdbarch_long_double_format (gdbarch)\n@@ -726,10 +726,10 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n   if (TYPE_LENGTH (type) == 16\n-      && ((TYPE_CODE (type) == TYPE_CODE_FLT\n+      && ((type->code () == TYPE_CODE_FLT\n \t   && (gdbarch_long_double_format (gdbarch)\n \t       == floatformats_ibm_long_double))\n-\t  || (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && tdep->soft_float)))\n+\t  || (type->code () == TYPE_CODE_DECFLOAT && tdep->soft_float)))\n     {\n       /* Soft-float IBM long double or _Decimal128 stored in r3, r4,\n \t r5, r6.  */\n@@ -749,9 +749,9 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n \t}\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n-  if ((TYPE_CODE (type) == TYPE_CODE_INT && TYPE_LENGTH (type) == 8)\n-      || (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8)\n-      || (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && TYPE_LENGTH (type) == 8\n+  if ((type->code () == TYPE_CODE_INT && TYPE_LENGTH (type) == 8)\n+      || (type->code () == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8)\n+      || (type->code () == TYPE_CODE_DECFLOAT && TYPE_LENGTH (type) == 8\n \t  && tdep->soft_float))\n     {\n       if (readbuf)\n@@ -770,15 +770,15 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n \t}\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n-  if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && !tdep->soft_float)\n+  if (type->code () == TYPE_CODE_DECFLOAT && !tdep->soft_float)\n     return get_decimal_float_return_value (gdbarch, type, regcache, readbuf,\n \t\t\t\t\t   writebuf);\n-  else if ((TYPE_CODE (type) == TYPE_CODE_INT\n-\t    || TYPE_CODE (type) == TYPE_CODE_CHAR\n-\t    || TYPE_CODE (type) == TYPE_CODE_BOOL\n-\t    || TYPE_CODE (type) == TYPE_CODE_PTR\n+  else if ((type->code () == TYPE_CODE_INT\n+\t    || type->code () == TYPE_CODE_CHAR\n+\t    || type->code () == TYPE_CODE_BOOL\n+\t    || type->code () == TYPE_CODE_PTR\n \t    || TYPE_IS_REFERENCE (type)\n-\t    || TYPE_CODE (type) == TYPE_CODE_ENUM)\n+\t    || type->code () == TYPE_CODE_ENUM)\n \t   && TYPE_LENGTH (type) <= tdep->wordsize)\n     {\n       if (readbuf)\n@@ -803,7 +803,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n     }\n   /* OpenCL vectors < 16 bytes are returned as distinct\n      scalars in f1..f2 or r3..r10.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+  if (type->code () == TYPE_CODE_ARRAY\n       && TYPE_VECTOR (type)\n       && TYPE_LENGTH (type) < 16\n       && opencl_abi)\n@@ -815,7 +815,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n \t{\n \t  int offset = i * TYPE_LENGTH (eltype);\n \n-\t  if (TYPE_CODE (eltype) == TYPE_CODE_FLT)\n+\t  if (eltype->code () == TYPE_CODE_FLT)\n \t    {\n \t      int regnum = tdep->ppc_fp0_regnum + 1 + i;\n \t      gdb_byte regval[PPC_MAX_REGISTER_SIZE];\n@@ -857,7 +857,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n   /* OpenCL vectors >= 16 bytes are returned in v2..v9.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+  if (type->code () == TYPE_CODE_ARRAY\n       && TYPE_VECTOR (type)\n       && TYPE_LENGTH (type) >= 16\n       && opencl_abi)\n@@ -879,7 +879,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n   if (TYPE_LENGTH (type) == 16\n-      && TYPE_CODE (type) == TYPE_CODE_ARRAY\n+      && type->code () == TYPE_CODE_ARRAY\n       && TYPE_VECTOR (type)\n       && tdep->vector_abi == POWERPC_VEC_ALTIVEC)\n     {\n@@ -896,7 +896,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n   if (TYPE_LENGTH (type) == 16\n-      && TYPE_CODE (type) == TYPE_CODE_ARRAY\n+      && type->code () == TYPE_CODE_ARRAY\n       && TYPE_VECTOR (type)\n       && tdep->vector_abi == POWERPC_VEC_GENERIC)\n     {\n@@ -920,7 +920,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n   if (TYPE_LENGTH (type) == 8\n-      && TYPE_CODE (type) == TYPE_CODE_ARRAY\n+      && type->code () == TYPE_CODE_ARRAY\n       && TYPE_VECTOR (type)\n       && tdep->vector_abi == POWERPC_VEC_SPE)\n     {\n@@ -1076,25 +1076,25 @@ ppc64_aggregate_candidate (struct type *type,\n {\n   type = check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_FLT:\n     case TYPE_CODE_DECFLOAT:\n       if (!*field_type)\n \t*field_type = type;\n-      if (TYPE_CODE (*field_type) == TYPE_CODE (type)\n+      if ((*field_type)->code () == type->code ()\n \t  && TYPE_LENGTH (*field_type) == TYPE_LENGTH (type))\n \treturn 1;\n       break;\n \n     case TYPE_CODE_COMPLEX:\n       type = TYPE_TARGET_TYPE (type);\n-      if (TYPE_CODE (type) == TYPE_CODE_FLT\n-\t  || TYPE_CODE (type) == TYPE_CODE_DECFLOAT)\n+      if (type->code () == TYPE_CODE_FLT\n+\t  || type->code () == TYPE_CODE_DECFLOAT)\n \t{\n \t  if (!*field_type)\n \t    *field_type = type;\n-\t  if (TYPE_CODE (*field_type) == TYPE_CODE (type)\n+\t  if ((*field_type)->code () == type->code ()\n \t      && TYPE_LENGTH (*field_type) == TYPE_LENGTH (type))\n \t    return 2;\n \t}\n@@ -1105,7 +1105,7 @@ ppc64_aggregate_candidate (struct type *type,\n \t{\n \t  if (!*field_type)\n \t    *field_type = type;\n-\t  if (TYPE_CODE (*field_type) == TYPE_CODE (type)\n+\t  if ((*field_type)->code () == type->code ()\n \t      && TYPE_LENGTH (*field_type) == TYPE_LENGTH (type))\n \t    return 1;\n \t}\n@@ -1150,7 +1150,7 @@ ppc64_aggregate_candidate (struct type *type,\n \t      if (sub_count == -1)\n \t\treturn -1;\n \n-\t      if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+\t      if (type->code () == TYPE_CODE_STRUCT)\n \t\tcount += sub_count;\n \t      else\n \t\tcount = std::max (count, sub_count);\n@@ -1184,17 +1184,17 @@ ppc64_elfv2_abi_homogeneous_aggregate (struct type *type,\n {\n   /* Complex types at the top level are treated separately.  However,\n      complex types can be elements of homogeneous aggregates.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || (TYPE_CODE (type) == TYPE_CODE_ARRAY && !TYPE_VECTOR (type)))\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || (type->code () == TYPE_CODE_ARRAY && !TYPE_VECTOR (type)))\n     {\n       struct type *field_type = NULL;\n       LONGEST field_count = ppc64_aggregate_candidate (type, &field_type);\n \n       if (field_count > 0)\n \t{\n-\t  int n_regs = ((TYPE_CODE (field_type) == TYPE_CODE_FLT\n-\t\t\t || TYPE_CODE (field_type) == TYPE_CODE_DECFLOAT)?\n+\t  int n_regs = ((field_type->code () == TYPE_CODE_FLT\n+\t\t\t || field_type->code () == TYPE_CODE_DECFLOAT)?\n \t\t\t(TYPE_LENGTH (field_type) + 7) >> 3 : 1);\n \n \t  /* The ELFv2 ABI allows homogeneous aggregates to occupy\n@@ -1323,7 +1323,7 @@ ppc64_sysv_abi_push_freg (struct gdbarch *gdbarch,\n     return;\n \n   if (TYPE_LENGTH (type) <= 8\n-      && TYPE_CODE (type) == TYPE_CODE_FLT)\n+      && type->code () == TYPE_CODE_FLT)\n     {\n       /* Floats and doubles go in f1 .. f13.  32-bit floats are converted\n  \t to double first.  */\n@@ -1340,7 +1340,7 @@ ppc64_sysv_abi_push_freg (struct gdbarch *gdbarch,\n       argpos->freg++;\n     }\n   else if (TYPE_LENGTH (type) <= 8\n-\t   && TYPE_CODE (type) == TYPE_CODE_DECFLOAT)\n+\t   && type->code () == TYPE_CODE_DECFLOAT)\n     {\n       /* Floats and doubles go in f1 .. f13.  32-bit decimal floats are\n \t placed in the least significant word.  */\n@@ -1359,7 +1359,7 @@ ppc64_sysv_abi_push_freg (struct gdbarch *gdbarch,\n       argpos->freg++;\n     }\n   else if (TYPE_LENGTH (type) == 16\n-\t   && TYPE_CODE (type) == TYPE_CODE_FLT\n+\t   && type->code () == TYPE_CODE_FLT\n \t   && (gdbarch_long_double_format (gdbarch)\n \t       == floatformats_ibm_long_double))\n     {\n@@ -1376,7 +1376,7 @@ ppc64_sysv_abi_push_freg (struct gdbarch *gdbarch,\n       argpos->freg += 2;\n     }\n   else if (TYPE_LENGTH (type) == 16\n-\t   && TYPE_CODE (type) == TYPE_CODE_DECFLOAT)\n+\t   && type->code () == TYPE_CODE_DECFLOAT)\n     {\n       /* 128-bit decimal floating-point values are stored in and even/odd\n \t pair of FPRs, with the even FPR holding the most significant half.  */\n@@ -1421,22 +1421,22 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_FLT\n-      || TYPE_CODE (type) == TYPE_CODE_DECFLOAT)\n+  if (type->code () == TYPE_CODE_FLT\n+      || type->code () == TYPE_CODE_DECFLOAT)\n     {\n       /* Floating-point scalars are passed in floating-point registers.  */\n       ppc64_sysv_abi_push_val (gdbarch, val, TYPE_LENGTH (type), 0, argpos);\n       ppc64_sysv_abi_push_freg (gdbarch, type, val, argpos);\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n \t   && tdep->vector_abi == POWERPC_VEC_ALTIVEC\n \t   && TYPE_LENGTH (type) == 16)\n     {\n       /* AltiVec vectors are passed aligned, and in vector registers.  */\n       ppc64_sysv_abi_push_val (gdbarch, val, TYPE_LENGTH (type), 16, argpos);\n       ppc64_sysv_abi_push_vreg (gdbarch, val, argpos);\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n \t   && TYPE_LENGTH (type) >= 16)\n     {\n       /* Non-Altivec vectors are passed by reference.  */\n@@ -1450,11 +1450,11 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n       /* ... and pass a pointer to the copy as parameter.  */\n       ppc64_sysv_abi_push_integer (gdbarch, addr, argpos);\n     }\n-  else if ((TYPE_CODE (type) == TYPE_CODE_INT\n-\t    || TYPE_CODE (type) == TYPE_CODE_ENUM\n-\t    || TYPE_CODE (type) == TYPE_CODE_BOOL\n-\t    || TYPE_CODE (type) == TYPE_CODE_CHAR\n-\t    || TYPE_CODE (type) == TYPE_CODE_PTR\n+  else if ((type->code () == TYPE_CODE_INT\n+\t    || type->code () == TYPE_CODE_ENUM\n+\t    || type->code () == TYPE_CODE_BOOL\n+\t    || type->code () == TYPE_CODE_CHAR\n+\t    || type->code () == TYPE_CODE_PTR\n \t    || TYPE_IS_REFERENCE (type))\n \t   && TYPE_LENGTH (type) <= tdep->wordsize)\n     {\n@@ -1467,14 +1467,14 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n \n \t  /* Convert any function code addresses into descriptors.  */\n \t  if (tdep->elf_abi == POWERPC_ELF_V1\n-\t      && (TYPE_CODE (type) == TYPE_CODE_PTR\n-\t\t  || TYPE_CODE (type) == TYPE_CODE_REF))\n+\t      && (type->code () == TYPE_CODE_PTR\n+\t\t  || type->code () == TYPE_CODE_REF))\n \t    {\n \t      struct type *target_type\n \t\t= check_typedef (TYPE_TARGET_TYPE (type));\n \n-\t      if (TYPE_CODE (target_type) == TYPE_CODE_FUNC\n-\t\t  || TYPE_CODE (target_type) == TYPE_CODE_METHOD)\n+\t      if (target_type->code () == TYPE_CODE_FUNC\n+\t\t  || target_type->code () == TYPE_CODE_METHOD)\n \t\t{\n \t\t  CORE_ADDR desc = word;\n \n@@ -1493,14 +1493,14 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n       /* The ABI (version 1.9) specifies that structs containing a\n \t single floating-point value, at any level of nesting of\n \t single-member structs, are passed in floating-point registers.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+      if (type->code () == TYPE_CODE_STRUCT\n \t  && TYPE_NFIELDS (type) == 1)\n \t{\n-\t  while (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+\t  while (type->code () == TYPE_CODE_STRUCT\n \t\t && TYPE_NFIELDS (type) == 1)\n \t    type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n \n-\t  if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+\t  if (type->code () == TYPE_CODE_FLT)\n \t    ppc64_sysv_abi_push_freg (gdbarch, type, val, argpos);\n \t}\n \n@@ -1516,10 +1516,10 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n \t      {\n \t\tconst gdb_byte *elval = val + i * TYPE_LENGTH (eltype);\n \n-\t\tif (TYPE_CODE (eltype) == TYPE_CODE_FLT\n-\t\t    || TYPE_CODE (eltype) == TYPE_CODE_DECFLOAT)\n+\t\tif (eltype->code () == TYPE_CODE_FLT\n+\t\t    || eltype->code () == TYPE_CODE_DECFLOAT)\n \t\t  ppc64_sysv_abi_push_freg (gdbarch, eltype, elval, argpos);\n-\t\telse if (TYPE_CODE (eltype) == TYPE_CODE_ARRAY\n+\t\telse if (eltype->code () == TYPE_CODE_ARRAY\n \t\t\t && TYPE_VECTOR (eltype)\n \t\t\t && tdep->vector_abi == POWERPC_VEC_ALTIVEC\n \t\t\t && TYPE_LENGTH (eltype) == 16)\n@@ -1635,7 +1635,7 @@ ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch,\n \t  struct type *type = check_typedef (value_type (arg));\n \t  const bfd_byte *val = value_contents (arg);\n \n-\t  if (TYPE_CODE (type) == TYPE_CODE_COMPLEX)\n+\t  if (type->code () == TYPE_CODE_COMPLEX)\n \t    {\n \t      /* Complex types are passed as if two independent scalars.  */\n \t      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));\n@@ -1644,7 +1644,7 @@ ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch,\n \t      ppc64_sysv_abi_push_param (gdbarch, eltype,\n \t\t\t\t \t val + TYPE_LENGTH (eltype), &argpos);\n \t    }\n-\t  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+\t  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n \t\t   && opencl_abi)\n \t    {\n \t      /* OpenCL vectors shorter than 16 bytes are passed as if\n@@ -1704,7 +1704,7 @@ ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch,\n       struct type *ftype = check_typedef (value_type (function));\n       CORE_ADDR desc_addr = value_as_address (function);\n \n-      if (TYPE_CODE (ftype) == TYPE_CODE_PTR\n+      if (ftype->code () == TYPE_CODE_PTR\n \t  || convert_code_addr_to_desc_addr (func_addr, &desc_addr))\n \t{\n \t  /* The TOC is the second double word in the descriptor.  */\n@@ -1742,10 +1742,10 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n   /* Integers live in GPRs starting at r3.  */\n-  if ((TYPE_CODE (valtype) == TYPE_CODE_INT\n-       || TYPE_CODE (valtype) == TYPE_CODE_ENUM\n-       || TYPE_CODE (valtype) == TYPE_CODE_CHAR\n-       || TYPE_CODE (valtype) == TYPE_CODE_BOOL)\n+  if ((valtype->code () == TYPE_CODE_INT\n+       || valtype->code () == TYPE_CODE_ENUM\n+       || valtype->code () == TYPE_CODE_CHAR\n+       || valtype->code () == TYPE_CODE_BOOL)\n       && TYPE_LENGTH (valtype) <= 8)\n     {\n       int regnum = tdep->ppc_gp0_regnum + 3 + index;\n@@ -1772,7 +1772,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n   /* Floats and doubles go in f1 .. f13.  32-bit floats are converted\n      to double first.  */\n   if (TYPE_LENGTH (valtype) <= 8\n-      && TYPE_CODE (valtype) == TYPE_CODE_FLT)\n+      && valtype->code () == TYPE_CODE_FLT)\n     {\n       int regnum = tdep->ppc_fp0_regnum + 1 + index;\n       struct type *regtype = register_type (gdbarch, regnum);\n@@ -1794,7 +1794,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n   /* Floats and doubles go in f1 .. f13.  32-bit decimal floats are\n      placed in the least significant word.  */\n   if (TYPE_LENGTH (valtype) <= 8\n-      && TYPE_CODE (valtype) == TYPE_CODE_DECFLOAT)\n+      && valtype->code () == TYPE_CODE_DECFLOAT)\n     {\n       int regnum = tdep->ppc_fp0_regnum + 1 + index;\n       int offset = 0;\n@@ -1813,7 +1813,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n \n   /* IBM long double stored in two consecutive FPRs.  */\n   if (TYPE_LENGTH (valtype) == 16\n-      && TYPE_CODE (valtype) == TYPE_CODE_FLT\n+      && valtype->code () == TYPE_CODE_FLT\n       && (gdbarch_long_double_format (gdbarch)\n \t  == floatformats_ibm_long_double))\n     {\n@@ -1835,7 +1835,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n   /* 128-bit decimal floating-point values are stored in an even/odd\n      pair of FPRs, with the even FPR holding the most significant half.  */\n   if (TYPE_LENGTH (valtype) == 16\n-      && TYPE_CODE (valtype) == TYPE_CODE_DECFLOAT)\n+      && valtype->code () == TYPE_CODE_DECFLOAT)\n     {\n       int regnum = tdep->ppc_fp0_regnum + 2 + 2 * index;\n       int lopart = gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG ? 8 : 0;\n@@ -1856,7 +1856,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n \n   /* AltiVec vectors are returned in VRs starting at v2.  */\n   if (TYPE_LENGTH (valtype) == 16\n-      && TYPE_CODE (valtype) == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n+      && valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n       && tdep->vector_abi == POWERPC_VEC_ALTIVEC)\n     {\n       int regnum = tdep->ppc_vr0_regnum + 2 + index;\n@@ -1870,7 +1870,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n \n   /* Short vectors are returned in GPRs starting at r3.  */\n   if (TYPE_LENGTH (valtype) <= 8\n-      && TYPE_CODE (valtype) == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype))\n+      && valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype))\n     {\n       int regnum = tdep->ppc_gp0_regnum + 3 + index;\n       int offset = 0;\n@@ -1917,7 +1917,7 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n   gdb_assert (ppc_floating_point_unit_p (gdbarch));\n \n   /* Complex types are returned as if two independent scalars.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX)\n+  if (valtype->code () == TYPE_CODE_COMPLEX)\n     {\n       eltype = check_typedef (TYPE_TARGET_TYPE (valtype));\n \n@@ -1938,7 +1938,7 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n   /* OpenCL vectors shorter than 16 bytes are returned as if\n      a series of independent scalars; OpenCL vectors 16 bytes\n      or longer are returned as if a series of AltiVec vectors.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n+  if (valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n       && opencl_abi)\n     {\n       if (TYPE_LENGTH (valtype) < 16)\n@@ -1962,7 +1962,7 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n     }\n \n   /* All pointers live in r3.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (valtype))\n+  if (valtype->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (valtype))\n     {\n       int regnum = tdep->ppc_gp0_regnum + 3;\n \n@@ -1974,10 +1974,10 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n     }\n \n   /* Small character arrays are returned, right justified, in r3.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY\n+  if (valtype->code () == TYPE_CODE_ARRAY\n       && !TYPE_VECTOR (valtype)\n       && TYPE_LENGTH (valtype) <= 8\n-      && TYPE_CODE (TYPE_TARGET_TYPE (valtype)) == TYPE_CODE_INT\n+      && TYPE_TARGET_TYPE (valtype)->code () == TYPE_CODE_INT\n       && TYPE_LENGTH (TYPE_TARGET_TYPE (valtype)) == 1)\n     {\n       int regnum = tdep->ppc_gp0_regnum + 3;\n@@ -1996,9 +1996,9 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n      aggregates are returned in registers.  */\n   if (tdep->elf_abi == POWERPC_ELF_V2\n       && ppc64_elfv2_abi_homogeneous_aggregate (valtype, &eltype, &nelt)\n-      && (TYPE_CODE (eltype) == TYPE_CODE_FLT\n-\t  || TYPE_CODE (eltype) == TYPE_CODE_DECFLOAT\n-\t  || (TYPE_CODE (eltype) == TYPE_CODE_ARRAY\n+      && (eltype->code () == TYPE_CODE_FLT\n+\t  || eltype->code () == TYPE_CODE_DECFLOAT\n+\t  || (eltype->code () == TYPE_CODE_ARRAY\n \t      && TYPE_VECTOR (eltype)\n \t      && tdep->vector_abi == POWERPC_VEC_ALTIVEC\n \t      && TYPE_LENGTH (eltype) == 16)))\n@@ -2022,9 +2022,9 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n      returned in registers r3:r4.  */\n   if (tdep->elf_abi == POWERPC_ELF_V2\n       && TYPE_LENGTH (valtype) <= 16\n-      && (TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-\t  || TYPE_CODE (valtype) == TYPE_CODE_UNION\n-\t  || (TYPE_CODE (valtype) == TYPE_CODE_ARRAY\n+      && (valtype->code () == TYPE_CODE_STRUCT\n+\t  || valtype->code () == TYPE_CODE_UNION\n+\t  || (valtype->code () == TYPE_CODE_ARRAY\n \t      && !TYPE_VECTOR (valtype))))\n     {\n       int n_regs = ((TYPE_LENGTH (valtype) + tdep->wordsize - 1)"
    },
    {
      "sha": "c94ad0a56005462b8a0969d6d230ee1dd276b869",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 17,
      "deletions": 18,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -311,12 +311,12 @@ print_formatted (struct value *val, int size,\n     }\n \n   if (options->format == 0 || options->format == 's'\n-      || TYPE_CODE (type) == TYPE_CODE_REF\n-      || TYPE_CODE (type) == TYPE_CODE_ARRAY\n-      || TYPE_CODE (type) == TYPE_CODE_STRING\n-      || TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || TYPE_CODE (type) == TYPE_CODE_NAMESPACE)\n+      || type->code () == TYPE_CODE_REF\n+      || type->code () == TYPE_CODE_ARRAY\n+      || type->code () == TYPE_CODE_STRING\n+      || type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || type->code () == TYPE_CODE_NAMESPACE)\n     value_print (val, stream, options);\n   else\n     /* User specified format, so don't look to the type to tell us\n@@ -361,7 +361,7 @@ print_scalar_formatted (const gdb_byte *valaddr, struct type *type,\n   /* If the value is a pointer, and pointers and addresses are not the\n      same, then at this point, the value's length (in target bytes) is\n      gdbarch_addr_bit/TARGET_CHAR_BIT, not TYPE_LENGTH (type).  */\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     len = gdbarch_addr_bit (gdbarch) / TARGET_CHAR_BIT;\n \n   /* If we are printing it as unsigned, truncate it in case it is actually\n@@ -411,14 +411,14 @@ print_scalar_formatted (const gdb_byte *valaddr, struct type *type,\n      range case, we want to avoid this, so we store the unpacked value\n      here for possible use later.  */\n   gdb::optional<LONGEST> val_long;\n-  if ((TYPE_CODE (type) == TYPE_CODE_FLT\n+  if ((type->code () == TYPE_CODE_FLT\n        && (options->format == 'o'\n \t   || options->format == 'x'\n \t   || options->format == 't'\n \t   || options->format == 'z'\n \t   || options->format == 'd'\n \t   || options->format == 'u'))\n-      || (TYPE_CODE (type) == TYPE_CODE_RANGE\n+      || (type->code () == TYPE_CODE_RANGE\n \t  && TYPE_RANGE_DATA (type)->bias != 0))\n     {\n       val_long.emplace (unpack_long (type, valaddr));\n@@ -432,10 +432,10 @@ print_scalar_formatted (const gdb_byte *valaddr, struct type *type,\n      of a floating-point type of the same length, if that exists.  Otherwise,\n      the data is printed as integer.  */\n   char format = options->format;\n-  if (format == 'f' && TYPE_CODE (type) != TYPE_CODE_FLT)\n+  if (format == 'f' && type->code () != TYPE_CODE_FLT)\n     {\n       type = float_type_from_length (type);\n-      if (TYPE_CODE (type) != TYPE_CODE_FLT)\n+      if (type->code () != TYPE_CODE_FLT)\n         format = 0;\n     }\n \n@@ -451,7 +451,7 @@ print_scalar_formatted (const gdb_byte *valaddr, struct type *type,\n       print_decimal_chars (stream, valaddr, len, false, byte_order);\n       break;\n     case 0:\n-      if (TYPE_CODE (type) != TYPE_CODE_FLT)\n+      if (type->code () != TYPE_CODE_FLT)\n \t{\n \t  print_decimal_chars (stream, valaddr, len, !TYPE_UNSIGNED (type),\n \t\t\t       byte_order);\n@@ -1218,7 +1218,7 @@ print_command_1 (const char *args, int voidprint)\n     val = access_value_history (0);\n \n   if (voidprint || (val && value_type (val) &&\n-\t\t    TYPE_CODE (value_type (val)) != TYPE_CODE_VOID))\n+\t\t    value_type (val)->code () != TYPE_CODE_VOID))\n     print_value (val, print_opts);\n }\n \n@@ -1681,8 +1681,7 @@ x_command (const char *exp, int from_tty)\n \tval = coerce_ref (val);\n       /* In rvalue contexts, such as this, functions are coerced into\n          pointers to functions.  This makes \"x/i main\" work.  */\n-      if (/* last_format == 'i'  && */ \n-\t  TYPE_CODE (value_type (val)) == TYPE_CODE_FUNC\n+      if (value_type (val)->code () == TYPE_CODE_FUNC\n \t   && VALUE_LVAL (val) == lval_memory)\n \tnext_address = value_address (val);\n       else\n@@ -2198,7 +2197,7 @@ printf_c_string (struct ui_file *stream, const char *format,\n {\n   const gdb_byte *str;\n \n-  if (TYPE_CODE (value_type (value)) != TYPE_CODE_PTR\n+  if (value_type (value)->code () != TYPE_CODE_PTR\n       && VALUE_LVAL (value) == lval_internalvar\n       && c_is_string_type_p (value_type (value)))\n     {\n@@ -2379,7 +2378,7 @@ printf_floating (struct ui_file *stream, const char *format,\n      In either case, the result of the conversion is a byte buffer\n      formatted in the target format for the target type.  */\n \n-  if (TYPE_CODE (fmt_type) == TYPE_CODE_FLT)\n+  if (fmt_type->code () == TYPE_CODE_FLT)\n     {\n       param_type = float_type_from_length (param_type);\n       if (param_type != value_type (value))\n@@ -2549,7 +2548,7 @@ ui_printf (const char *arg, struct ui_file *stream)\n \n \t      valtype = value_type (val_args[i]);\n \t      if (TYPE_LENGTH (valtype) != TYPE_LENGTH (wctype)\n-\t\t  || TYPE_CODE (valtype) != TYPE_CODE_INT)\n+\t\t  || valtype->code () != TYPE_CODE_INT)\n \t\terror (_(\"expected wchar_t argument for %%lc\"));\n \n \t      bytes = value_contents (val_args[i]);"
    },
    {
      "sha": "92ac5557d76312fdc19dc28ccf3af724b1787e40",
      "filename": "gdb/python/py-finishbreakpoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-finishbreakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-finishbreakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-finishbreakpoint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -253,7 +253,7 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n \t\tcheck_typedef (TYPE_TARGET_TYPE (SYMBOL_TYPE (function)));\n \n               /* Remember only non-void return types.  */\n-              if (TYPE_CODE (ret_type) != TYPE_CODE_VOID)\n+              if (ret_type->code () != TYPE_CODE_VOID)\n                 {\n                   struct value *func_value;\n "
    },
    {
      "sha": "45bf51b935c78ce074821c764f65a8968fe8b544",
      "filename": "gdb/python/py-framefilter.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-framefilter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-framefilter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-framefilter.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -240,9 +240,9 @@ py_print_value (struct ui_out *out, struct value *val,\n       if (args_type == MI_PRINT_ALL_VALUES)\n \tshould_print = 1;\n       else if (args_type == MI_PRINT_SIMPLE_VALUES\n-\t       && TYPE_CODE (type) != TYPE_CODE_ARRAY\n-\t       && TYPE_CODE (type) != TYPE_CODE_STRUCT\n-\t       && TYPE_CODE (type) != TYPE_CODE_UNION)\n+\t       && type->code () != TYPE_CODE_ARRAY\n+\t       && type->code () != TYPE_CODE_STRUCT\n+\t       && type->code () != TYPE_CODE_UNION)\n \tshould_print = 1;\n     }\n   else if (args_type != NO_VALUES)"
    },
    {
      "sha": "f71bb1d613dcdbebcd378b12bc4d929480ebdfba",
      "filename": "gdb/python/py-lazy-string.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-lazy-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-lazy-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-lazy-string.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -120,7 +120,7 @@ stpy_convert_to_value (PyObject *self, PyObject *args)\n \n       gdb_assert (type != NULL);\n       realtype = check_typedef (type);\n-      switch (TYPE_CODE (realtype))\n+      switch (realtype->code ())\n \t{\n \tcase TYPE_CODE_PTR:\n \t  /* If a length is specified we need to convert this to an array\n@@ -194,7 +194,7 @@ gdbpy_create_lazy_string_object (CORE_ADDR address, long length,\n     }\n \n   realtype = check_typedef (type);\n-  switch (TYPE_CODE (realtype))\n+  switch (realtype->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       {\n@@ -258,7 +258,7 @@ stpy_lazy_string_elt_type (lazy_string_object *lazy)\n   gdb_assert (type != NULL);\n   realtype = check_typedef (type);\n \n-  switch (TYPE_CODE (realtype))\n+  switch (realtype->code ())\n     {\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_ARRAY:"
    },
    {
      "sha": "e62ff57d0fca429bcefe4985a790454a13033220",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -157,7 +157,7 @@ typy_get_code (PyObject *self, void *closure)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  return PyInt_FromLong (TYPE_CODE (type));\n+  return PyInt_FromLong (type->code ());\n }\n \n /* Helper function for typy_fields which converts a single field to a\n@@ -181,7 +181,7 @@ convert_field (struct type *type, int field)\n     {\n       const char *attrstring;\n \n-      if (TYPE_CODE (type) == TYPE_CODE_ENUM)\n+      if (type->code () == TYPE_CODE_ENUM)\n \t{\n \t  arg.reset (gdb_py_long_from_longest (TYPE_FIELD_ENUMVAL (type,\n \t\t\t\t\t\t\t\t   field)));\n@@ -227,7 +227,7 @@ convert_field (struct type *type, int field)\n   if (PyObject_SetAttrString (result.get (), \"artificial\", arg.get ()) < 0)\n     return NULL;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  if (type->code () == TYPE_CODE_STRUCT)\n     arg = gdbpy_ref<>::new_reference (field < TYPE_N_BASECLASSES (type)\n \t\t\t\t      ? Py_True : Py_False);\n   else\n@@ -356,7 +356,7 @@ typy_fields (PyObject *self, PyObject *args)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  if (TYPE_CODE (type) != TYPE_CODE_ARRAY)\n+  if (type->code () != TYPE_CODE_ARRAY)\n     return typy_fields_items (self, iter_values);\n \n   /* Array type.  Handle this as a special case because the common\n@@ -405,9 +405,9 @@ typy_get_tag (PyObject *self, void *closure)\n   struct type *type = ((type_object *) self)->type;\n   const char *tagname = nullptr;\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || TYPE_CODE (type) == TYPE_CODE_ENUM)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || type->code () == TYPE_CODE_ENUM)\n     tagname = TYPE_NAME (type);\n \n   if (tagname == nullptr)\n@@ -463,17 +463,17 @@ typy_get_composite (struct type *type)\n \t  GDB_PY_HANDLE_EXCEPTION (except);\n \t}\n \n-      if (TYPE_CODE (type) != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n+      if (type->code () != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n \tbreak;\n       type = TYPE_TARGET_TYPE (type);\n     }\n \n   /* If this is not a struct, union, or enum type, raise TypeError\n      exception.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (type) != TYPE_CODE_UNION\n-      && TYPE_CODE (type) != TYPE_CODE_ENUM\n-      && TYPE_CODE (type) != TYPE_CODE_FUNC)\n+  if (type->code () != TYPE_CODE_STRUCT\n+      && type->code () != TYPE_CODE_UNION\n+      && type->code () != TYPE_CODE_ENUM\n+      && type->code () != TYPE_CODE_FUNC)\n     {\n       PyErr_SetString (PyExc_TypeError,\n \t\t       \"Type is not a structure, union, enum, or function type.\");\n@@ -579,16 +579,16 @@ typy_range (PyObject *self, PyObject *args)\n   /* Initialize these to appease GCC warnings.  */\n   LONGEST low = 0, high = 0;\n \n-  if (TYPE_CODE (type) != TYPE_CODE_ARRAY\n-      && TYPE_CODE (type) != TYPE_CODE_STRING\n-      && TYPE_CODE (type) != TYPE_CODE_RANGE)\n+  if (type->code () != TYPE_CODE_ARRAY\n+      && type->code () != TYPE_CODE_STRING\n+      && type->code () != TYPE_CODE_RANGE)\n     {\n       PyErr_SetString (PyExc_RuntimeError,\n \t\t       _(\"This type does not have a range.\"));\n       return NULL;\n     }\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n     case TYPE_CODE_STRING:"
    },
    {
      "sha": "2ebbe0a3569b99792b1e3d68958edba92448bf96",
      "filename": "gdb/python/py-value.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-value.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -251,7 +251,7 @@ valpy_referenced_value (PyObject *self, PyObject *args)\n       scoped_value_mark free_values;\n \n       self_val = ((value_object *) self)->value;\n-      switch (TYPE_CODE (check_typedef (value_type (self_val))))\n+      switch (check_typedef (value_type (self_val))->code ())\n         {\n         case TYPE_CODE_PTR:\n           res_val = value_ind (self_val);\n@@ -400,11 +400,11 @@ valpy_get_dynamic_type (PyObject *self, void *closure)\n       type = value_type (val);\n       type = check_typedef (type);\n \n-      if (((TYPE_CODE (type) == TYPE_CODE_PTR) || TYPE_IS_REFERENCE (type))\n-\t  && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_STRUCT))\n+      if (((type->code () == TYPE_CODE_PTR) || TYPE_IS_REFERENCE (type))\n+\t  && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_STRUCT))\n \t{\n \t  struct value *target;\n-\t  int was_pointer = TYPE_CODE (type) == TYPE_CODE_PTR;\n+\t  int was_pointer = type->code () == TYPE_CODE_PTR;\n \n \t  if (was_pointer)\n \t    target = value_ind (val);\n@@ -420,7 +420,7 @@ valpy_get_dynamic_type (PyObject *self, void *closure)\n \t\ttype = lookup_lvalue_reference_type (type);\n \t    }\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      else if (type->code () == TYPE_CODE_STRUCT)\n \ttype = value_rtti_type (val, NULL, NULL, NULL);\n       else\n \t{\n@@ -488,7 +488,7 @@ valpy_lazy_string (PyObject *self, PyObject *args, PyObject *kw)\n       type = value_type (value);\n       realtype = check_typedef (type);\n \n-      switch (TYPE_CODE (realtype))\n+      switch (realtype->code ())\n \t{\n \tcase TYPE_CODE_ARRAY:\n \t  {\n@@ -846,10 +846,10 @@ value_has_field (struct value *v, PyObject *field)\n     {\n       val_type = value_type (v);\n       val_type = check_typedef (val_type);\n-      if (TYPE_IS_REFERENCE (val_type) || TYPE_CODE (val_type) == TYPE_CODE_PTR)\n+      if (TYPE_IS_REFERENCE (val_type) || val_type->code () == TYPE_CODE_PTR)\n \tval_type = check_typedef (TYPE_TARGET_TYPE (val_type));\n \n-      type_code = TYPE_CODE (val_type);\n+      type_code = val_type->code ();\n       if ((type_code == TYPE_CODE_STRUCT || type_code == TYPE_CODE_UNION)\n \t  && types_equal (val_type, parent_type))\n \thas_field = 1;\n@@ -997,12 +997,12 @@ valpy_getitem (PyObject *self, PyObject *key)\n \t  struct type *val_type;\n \n \t  val_type = check_typedef (value_type (tmp));\n-\t  if (TYPE_CODE (val_type) == TYPE_CODE_PTR)\n+\t  if (val_type->code () == TYPE_CODE_PTR)\n \t    res_val = value_cast (lookup_pointer_type (base_class_type), tmp);\n-\t  else if (TYPE_CODE (val_type) == TYPE_CODE_REF)\n+\t  else if (val_type->code () == TYPE_CODE_REF)\n \t    res_val = value_cast (lookup_lvalue_reference_type (base_class_type),\n \t                          tmp);\n-\t  else if (TYPE_CODE (val_type) == TYPE_CODE_RVALUE_REF)\n+\t  else if (val_type->code () == TYPE_CODE_RVALUE_REF)\n \t    res_val = value_cast (lookup_rvalue_reference_type (base_class_type),\n \t                          tmp);\n \t  else\n@@ -1023,8 +1023,8 @@ valpy_getitem (PyObject *self, PyObject *key)\n \n \t      tmp = coerce_ref (tmp);\n \t      type = check_typedef (value_type (tmp));\n-\t      if (TYPE_CODE (type) != TYPE_CODE_ARRAY\n-\t\t  && TYPE_CODE (type) != TYPE_CODE_PTR)\n+\t      if (type->code () != TYPE_CODE_ARRAY\n+\t\t  && type->code () != TYPE_CODE_PTR)\n \t\t  error (_(\"Cannot subscript requested type.\"));\n \t      else\n \t\tres_val = value_subscript (tmp, value_as_long (idx));\n@@ -1072,7 +1072,7 @@ valpy_call (PyObject *self, PyObject *args, PyObject *keywords)\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n \n-  if (TYPE_CODE (ftype) != TYPE_CODE_FUNC)\n+  if (ftype->code () != TYPE_CODE_FUNC)\n     {\n       PyErr_SetString (PyExc_RuntimeError,\n \t\t       _(\"Value is not callable (not TYPE_CODE_FUNC).\"));\n@@ -1279,10 +1279,10 @@ valpy_binop_throw (enum valpy_opcode opcode, PyObject *self, PyObject *other)\n \trtype = STRIP_REFERENCE (rtype);\n \n \thandled = 1;\n-\tif (TYPE_CODE (ltype) == TYPE_CODE_PTR\n+\tif (ltype->code () == TYPE_CODE_PTR\n \t    && is_integral_type (rtype))\n \t  res_val = value_ptradd (arg1, value_as_long (arg2));\n-\telse if (TYPE_CODE (rtype) == TYPE_CODE_PTR\n+\telse if (rtype->code () == TYPE_CODE_PTR\n \t\t && is_integral_type (ltype))\n \t  res_val = value_ptradd (arg2, value_as_long (arg1));\n \telse\n@@ -1303,12 +1303,12 @@ valpy_binop_throw (enum valpy_opcode opcode, PyObject *self, PyObject *other)\n \trtype = STRIP_REFERENCE (rtype);\n \n \thandled = 1;\n-\tif (TYPE_CODE (ltype) == TYPE_CODE_PTR\n-\t    && TYPE_CODE (rtype) == TYPE_CODE_PTR)\n+\tif (ltype->code () == TYPE_CODE_PTR\n+\t    && rtype->code () == TYPE_CODE_PTR)\n \t  /* A ptrdiff_t for the target would be preferable here.  */\n \t  res_val = value_from_longest (builtin_type_pyint,\n \t\t\t\t\tvalue_ptrdiff (arg1, arg2));\n-\telse if (TYPE_CODE (ltype) == TYPE_CODE_PTR\n+\telse if (ltype->code () == TYPE_CODE_PTR\n \t\t && is_integral_type (rtype))\n \t  res_val = value_ptradd (arg1, - value_as_long (arg2));\n \telse\n@@ -1492,7 +1492,7 @@ valpy_nonzero (PyObject *self)\n     {\n       type = check_typedef (value_type (self_value->value));\n \n-      if (is_integral_type (type) || TYPE_CODE (type) == TYPE_CODE_PTR)\n+      if (is_integral_type (type) || type->code () == TYPE_CODE_PTR)\n \tnonzero = !!value_as_long (self_value->value);\n       else if (is_floating_value (self_value->value))\n \tnonzero = !target_float_is_zero (value_contents (self_value->value),\n@@ -1684,7 +1684,7 @@ valpy_int (PyObject *self)\n \t}\n \n       if (!is_integral_type (type)\n-\t  && TYPE_CODE (type) != TYPE_CODE_PTR)\n+\t  && type->code () != TYPE_CODE_PTR)\n \terror (_(\"Cannot convert value to int.\"));\n \n       l = value_as_long (value);\n@@ -1720,7 +1720,7 @@ valpy_long (PyObject *self)\n       type = check_typedef (type);\n \n       if (!is_integral_type (type)\n-\t  && TYPE_CODE (type) != TYPE_CODE_PTR)\n+\t  && type->code () != TYPE_CODE_PTR)\n \terror (_(\"Cannot convert value to long.\"));\n \n       l = value_as_long (value);\n@@ -1748,9 +1748,9 @@ valpy_float (PyObject *self)\n     {\n       type = check_typedef (type);\n \n-      if (TYPE_CODE (type) == TYPE_CODE_FLT && is_floating_value (value))\n+      if (type->code () == TYPE_CODE_FLT && is_floating_value (value))\n \td = target_float_to_host_double (value_contents (value), type);\n-      else if (TYPE_CODE (type) == TYPE_CODE_INT)\n+      else if (type->code () == TYPE_CODE_INT)\n \t{\n \t  /* Note that valpy_long accepts TYPE_CODE_PTR and some\n \t     others here here -- but casting a pointer or bool to a\n@@ -1972,7 +1972,7 @@ gdbpy_convenience_variable (PyObject *self, PyObject *args)\n       if (var != NULL)\n \t{\n \t  res_val = value_of_internalvar (python_gdbarch, var);\n-\t  if (TYPE_CODE (value_type (res_val)) == TYPE_CODE_VOID)\n+\t  if (value_type (res_val)->code () == TYPE_CODE_VOID)\n \t    res_val = NULL;\n \t}\n     }"
    },
    {
      "sha": "d223d49efe208f7c70f333c9043b7f6b9b5f3de8",
      "filename": "gdb/python/py-xmethods.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-xmethods.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/python/py-xmethods.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-xmethods.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -425,7 +425,7 @@ python_xmethod_worker::do_get_result_type (value *obj,\n \n   obj_type = check_typedef (value_type (obj));\n   this_type = check_typedef (type_object_to_type (m_this_type));\n-  if (TYPE_CODE (obj_type) == TYPE_CODE_PTR)\n+  if (obj_type->code () == TYPE_CODE_PTR)\n     {\n       struct type *this_ptr = lookup_pointer_type (this_type);\n \n@@ -435,7 +435,7 @@ python_xmethod_worker::do_get_result_type (value *obj,\n   else if (TYPE_IS_REFERENCE (obj_type))\n     {\n       struct type *this_ref\n-        = lookup_reference_type (this_type, TYPE_CODE (obj_type));\n+        = lookup_reference_type (this_type, obj_type->code ());\n \n       if (!types_equal (obj_type, this_ref))\n \tobj = value_cast (this_ref, obj);\n@@ -510,7 +510,7 @@ python_xmethod_worker::invoke (struct value *obj,\n \n   obj_type = check_typedef (value_type (obj));\n   this_type = check_typedef (type_object_to_type (m_this_type));\n-  if (TYPE_CODE (obj_type) == TYPE_CODE_PTR)\n+  if (obj_type->code () == TYPE_CODE_PTR)\n     {\n       struct type *this_ptr = lookup_pointer_type (this_type);\n \n@@ -520,7 +520,7 @@ python_xmethod_worker::invoke (struct value *obj,\n   else if (TYPE_IS_REFERENCE (obj_type))\n     {\n       struct type *this_ref\n-\t= lookup_reference_type (this_type, TYPE_CODE (obj_type));\n+\t= lookup_reference_type (this_type, obj_type->code ());\n \n       if (!types_equal (obj_type, this_ref))\n \tobj = value_cast (this_ref, obj);"
    },
    {
      "sha": "417d61cf178d5c747e4552b9af29a9aa52a46740",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -101,7 +101,7 @@ init_regcache_descr (struct gdbarch *gdbarch)\n \n   /* Lay out the register cache.\n \n-     NOTE: cagney/2002-05-22: Only register_type() is used when\n+     NOTE: cagney/2002-05-22: Only register_type () is used when\n      constructing the register cache.  It is assumed that the\n      register's raw size, virtual size and type length are all the\n      same.  */\n@@ -1810,17 +1810,17 @@ cooked_write_test (struct gdbarch *gdbarch)\n       std::vector<gdb_byte> buf (register_size (gdbarch, regnum), 0);\n       const auto type = register_type (gdbarch, regnum);\n \n-      if (TYPE_CODE (type) == TYPE_CODE_FLT\n-\t  || TYPE_CODE (type) == TYPE_CODE_DECFLOAT)\n+      if (type->code () == TYPE_CODE_FLT\n+\t  || type->code () == TYPE_CODE_DECFLOAT)\n \t{\n \t  /* Generate valid float format.  */\n \t  target_float_from_string (expected.data (), type, \"1.25\");\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_INT\n-\t       || TYPE_CODE (type) == TYPE_CODE_ARRAY\n-\t       || TYPE_CODE (type) == TYPE_CODE_PTR\n-\t       || TYPE_CODE (type) == TYPE_CODE_UNION\n-\t       || TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      else if (type->code () == TYPE_CODE_INT\n+\t       || type->code () == TYPE_CODE_ARRAY\n+\t       || type->code () == TYPE_CODE_PTR\n+\t       || type->code () == TYPE_CODE_UNION\n+\t       || type->code () == TYPE_CODE_STRUCT)\n \t{\n \t  if (bfd_arch == bfd_arch_ia64\n \t      || (regnum >= gdbarch_num_regs (gdbarch)\n@@ -1850,7 +1850,7 @@ cooked_write_test (struct gdbarch *gdbarch)\n \t\texpected[j] = j;\n \t    }\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_FLAGS)\n+      else if (type->code () == TYPE_CODE_FLAGS)\n \t{\n \t  /* No idea how to test flags.  */\n \t  continue;"
    },
    {
      "sha": "83d7b49e330b9424eb93ea6694e52ca68d5407ca",
      "filename": "gdb/reggroups.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/reggroups.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/reggroups.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/reggroups.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -202,8 +202,8 @@ default_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n   if (group == all_reggroup)\n     return 1;\n   vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));\n-  float_p = (TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT\n-\t     || (TYPE_CODE (register_type (gdbarch, regnum))\n+  float_p = (register_type (gdbarch, regnum)->code () == TYPE_CODE_FLT\n+\t     || (register_type (gdbarch, regnum)->code ()\n \t\t == TYPE_CODE_DECFLOAT));\n   raw_p = regnum < gdbarch_num_regs (gdbarch);\n   if (group == float_reggroup)"
    },
    {
      "sha": "c1c466f1a10317702e0f9afe5f2e077d99097e78",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -574,7 +574,7 @@ riscv_register_type (struct gdbarch *gdbarch, int regnum)\n          present the registers using a union type.  */\n       int flen = riscv_isa_flen (gdbarch);\n       if (flen == 8\n-          && TYPE_CODE (type) == TYPE_CODE_FLT\n+          && type->code () == TYPE_CODE_FLT\n           && TYPE_LENGTH (type) == flen\n           && (strcmp (TYPE_NAME (type), \"builtin_type_ieee_double\") == 0\n               || strcmp (TYPE_NAME (type), \"double\") == 0))\n@@ -587,7 +587,7 @@ riscv_register_type (struct gdbarch *gdbarch, int regnum)\n        || regnum == RISCV_SP_REGNUM\n        || regnum == RISCV_GP_REGNUM\n        || regnum == RISCV_TP_REGNUM)\n-      && TYPE_CODE (type) == TYPE_CODE_INT\n+      && type->code () == TYPE_CODE_INT\n       && TYPE_LENGTH (type) == xlen)\n     {\n       /* This spots the case where some interesting registers are defined\n@@ -640,16 +640,16 @@ riscv_print_one_register_info (struct gdbarch *gdbarch,\n   print_raw_format = (value_entirely_available (val)\n \t\t      && !value_optimized_out (val));\n \n-  if (TYPE_CODE (regtype) == TYPE_CODE_FLT\n-      || (TYPE_CODE (regtype) == TYPE_CODE_UNION\n+  if (regtype->code () == TYPE_CODE_FLT\n+      || (regtype->code () == TYPE_CODE_UNION\n \t  && TYPE_NFIELDS (regtype) == 2\n-\t  && TYPE_CODE (TYPE_FIELD_TYPE (regtype, 0)) == TYPE_CODE_FLT\n-\t  && TYPE_CODE (TYPE_FIELD_TYPE (regtype, 1)) == TYPE_CODE_FLT)\n-      || (TYPE_CODE (regtype) == TYPE_CODE_UNION\n+\t  && TYPE_FIELD_TYPE (regtype, 0)->code () == TYPE_CODE_FLT\n+\t  && TYPE_FIELD_TYPE (regtype, 1)->code () == TYPE_CODE_FLT)\n+      || (regtype->code () == TYPE_CODE_UNION\n \t  && TYPE_NFIELDS (regtype) == 3\n-\t  && TYPE_CODE (TYPE_FIELD_TYPE (regtype, 0)) == TYPE_CODE_FLT\n-\t  && TYPE_CODE (TYPE_FIELD_TYPE (regtype, 1)) == TYPE_CODE_FLT\n-\t  && TYPE_CODE (TYPE_FIELD_TYPE (regtype, 2)) == TYPE_CODE_FLT))\n+\t  && TYPE_FIELD_TYPE (regtype, 0)->code () == TYPE_CODE_FLT\n+\t  && TYPE_FIELD_TYPE (regtype, 1)->code () == TYPE_CODE_FLT\n+\t  && TYPE_FIELD_TYPE (regtype, 2)->code () == TYPE_CODE_FLT))\n     {\n       struct value_print_options opts;\n       const gdb_byte *valaddr = value_contents_for_printing (val);\n@@ -1628,7 +1628,7 @@ static ULONGEST\n riscv_type_align (gdbarch *gdbarch, type *type)\n {\n   type = check_typedef (type);\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n     return std::min (TYPE_LENGTH (type), (ULONGEST) BIGGEST_ALIGNMENT);\n \n   /* Anything else will be aligned by the generic code.  */\n@@ -2057,7 +2057,7 @@ riscv_struct_info::analyse_inner (struct type *type, int offset)\n       int field_offset\n \t= offset + TYPE_FIELD_BITPOS (type, i) / TARGET_CHAR_BIT;\n \n-      switch (TYPE_CODE (field_type))\n+      switch (field_type->code ())\n \t{\n \tcase TYPE_CODE_STRUCT:\n \t  analyse_inner (field_type, field_offset);\n@@ -2104,7 +2104,7 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n \n       sinfo.analyse (ainfo->type);\n       if (sinfo.number_of_fields () == 1\n-\t  && TYPE_CODE (sinfo.field_type (0)) == TYPE_CODE_COMPLEX)\n+\t  && sinfo.field_type(0)->code () == TYPE_CODE_COMPLEX)\n \t{\n \t  /* The following is similar to RISCV_CALL_ARG_COMPLEX_FLOAT,\n \t     except we use the type of the complex field instead of the\n@@ -2134,7 +2134,7 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n \t}\n \n       if (sinfo.number_of_fields () == 1\n-\t  && TYPE_CODE (sinfo.field_type (0)) == TYPE_CODE_FLT)\n+\t  && sinfo.field_type(0)->code () == TYPE_CODE_FLT)\n \t{\n \t  /* The following is similar to RISCV_CALL_ARG_SCALAR_FLOAT,\n \t     except we use the type of the first scalar field instead of\n@@ -2157,9 +2157,9 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n \t}\n \n       if (sinfo.number_of_fields () == 2\n-\t  && TYPE_CODE (sinfo.field_type (0)) == TYPE_CODE_FLT\n+\t  && sinfo.field_type(0)->code () == TYPE_CODE_FLT\n \t  && TYPE_LENGTH (sinfo.field_type (0)) <= cinfo->flen\n-\t  && TYPE_CODE (sinfo.field_type (1)) == TYPE_CODE_FLT\n+\t  && sinfo.field_type(1)->code () == TYPE_CODE_FLT\n \t  && TYPE_LENGTH (sinfo.field_type (1)) <= cinfo->flen\n \t  && riscv_arg_regs_available (&cinfo->float_regs) >= 2)\n \t{\n@@ -2183,7 +2183,7 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n \n       if (sinfo.number_of_fields () == 2\n \t  && riscv_arg_regs_available (&cinfo->int_regs) >= 1\n-\t  && (TYPE_CODE (sinfo.field_type (0)) == TYPE_CODE_FLT\n+\t  && (sinfo.field_type(0)->code () == TYPE_CODE_FLT\n \t      && TYPE_LENGTH (sinfo.field_type (0)) <= cinfo->flen\n \t      && is_integral_type (sinfo.field_type (1))\n \t      && TYPE_LENGTH (sinfo.field_type (1)) <= cinfo->xlen))\n@@ -2207,7 +2207,7 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n \t  && riscv_arg_regs_available (&cinfo->int_regs) >= 1\n \t  && (is_integral_type (sinfo.field_type (0))\n \t      && TYPE_LENGTH (sinfo.field_type (0)) <= cinfo->xlen\n-\t      && TYPE_CODE (sinfo.field_type (1)) == TYPE_CODE_FLT\n+\t      && sinfo.field_type(1)->code () == TYPE_CODE_FLT\n \t      && TYPE_LENGTH (sinfo.field_type (1)) <= cinfo->flen))\n \t{\n \t  int len0 = TYPE_LENGTH (sinfo.field_type (0));\n@@ -2260,7 +2260,7 @@ riscv_arg_location (struct gdbarch *gdbarch,\n   ainfo->argloc[0].c_length = 0;\n   ainfo->argloc[1].c_length = 0;\n \n-  switch (TYPE_CODE (ainfo->type))\n+  switch (ainfo->type->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_BOOL:\n@@ -2428,7 +2428,7 @@ riscv_push_dummy_call (struct gdbarch *gdbarch,\n \n   struct type *ftype = check_typedef (value_type (function));\n \n-  if (TYPE_CODE (ftype) == TYPE_CODE_PTR)\n+  if (ftype->code () == TYPE_CODE_PTR)\n     ftype = check_typedef (TYPE_TARGET_TYPE (ftype));\n \n   /* We'll use register $a0 if we're returning a struct.  */"
    },
    {
      "sha": "ba54454c74277503a92f4cebcf347e012f186c93",
      "filename": "gdb/rl78-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rl78-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rl78-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rl78-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1048,8 +1048,8 @@ rl78_pointer_to_address (struct gdbarch *gdbarch,\n     = extract_unsigned_integer (buf, TYPE_LENGTH (type), byte_order);\n \n   /* Is it a code address?  */\n-  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC\n-      || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD\n+  if (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC\n+      || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_METHOD\n       || TYPE_CODE_SPACE (TYPE_TARGET_TYPE (type))\n       || TYPE_LENGTH (type) == 4)\n     return rl78_make_instruction_address (addr);"
    },
    {
      "sha": "66b75a70249486bd0afdb9733a93670d9e8fbf83",
      "filename": "gdb/rs6000-aix-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rs6000-aix-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rs6000-aix-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-aix-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -349,7 +349,7 @@ rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       type = check_typedef (value_type (arg));\n       len = TYPE_LENGTH (type);\n \n-      if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+      if (type->code () == TYPE_CODE_FLT)\n \t{\n \t  /* Floating point arguments are passed in fpr's, as well as gpr's.\n \t     There are 13 fpr's reserved for passing parameters.  At this point\n@@ -473,7 +473,7 @@ rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n \t  /* Float types should be passed in fpr's, as well as in the\n              stack.  */\n-\t  if (TYPE_CODE (type) == TYPE_CODE_FLT && f_argno < 13)\n+\t  if (type->code () == TYPE_CODE_FLT && f_argno < 13)\n \t    {\n \n \t      gdb_assert (len <= 8);\n@@ -527,7 +527,7 @@ rs6000_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   /* AltiVec extension: Functions that declare a vector data type as a\n      return value place that return value in VR2.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n+  if (valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n       && TYPE_LENGTH (valtype) == 16)\n     {\n       if (readbuf)\n@@ -543,16 +543,16 @@ rs6000_return_value (struct gdbarch *gdbarch, struct value *function,\n      allocated buffer into which the callee is assumed to store its\n      return value.  All explicit parameters are appropriately\n      relabeled.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (valtype) == TYPE_CODE_UNION\n-      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY)\n+  if (valtype->code () == TYPE_CODE_STRUCT\n+      || valtype->code () == TYPE_CODE_UNION\n+      || valtype->code () == TYPE_CODE_ARRAY)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n \n   /* Scalar floating-point values are returned in FPR1 for float or\n      double, and in FPR1:FPR2 for quadword precision.  Fortran\n      complex*8 and complex*16 are returned in FPR1:FPR2, and\n      complex*32 is returned in FPR1:FPR4.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_FLT\n+  if (valtype->code () == TYPE_CODE_FLT\n       && (TYPE_LENGTH (valtype) == 4 || TYPE_LENGTH (valtype) == 8))\n     {\n       struct type *regtype = register_type (gdbarch, tdep->ppc_fp0_regnum);\n@@ -608,7 +608,7 @@ rs6000_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   if (TYPE_LENGTH (valtype) == 8)\n     {\n-      gdb_assert (TYPE_CODE (valtype) != TYPE_CODE_FLT);\n+      gdb_assert (valtype->code () != TYPE_CODE_FLT);\n       gdb_assert (tdep->wordsize == 4);\n \n       if (readbuf)"
    },
    {
      "sha": "7f1825dc4535e439579ff7f3734e8100a21e495c",
      "filename": "gdb/rs6000-lynx178-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rs6000-lynx178-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rs6000-lynx178-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-lynx178-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -96,7 +96,7 @@ rs6000_lynx178_push_dummy_call (struct gdbarch *gdbarch,\n       type = check_typedef (value_type (arg));\n       len = TYPE_LENGTH (type);\n \n-      if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+      if (type->code () == TYPE_CODE_FLT)\n \t{\n \n \t  /* Floating point arguments are passed in fpr's, as well as gpr's.\n@@ -222,7 +222,7 @@ rs6000_lynx178_push_dummy_call (struct gdbarch *gdbarch,\n \n \t  /* Float types should be passed in fpr's, as well as in the\n              stack.  */\n-\t  if (TYPE_CODE (type) == TYPE_CODE_FLT && f_argno < 13)\n+\t  if (type->code () == TYPE_CODE_FLT && f_argno < 13)\n \t    {\n \n \t      gdb_assert (len <= 8);\n@@ -274,7 +274,7 @@ rs6000_lynx178_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   /* AltiVec extension: Functions that declare a vector data type as a\n      return value place that return value in VR2.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n+  if (valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n       && TYPE_LENGTH (valtype) == 16)\n     {\n       if (readbuf)\n@@ -290,16 +290,16 @@ rs6000_lynx178_return_value (struct gdbarch *gdbarch, struct value *function,\n      allocated buffer into which the callee is assumed to store its\n      return value.  All explicit parameters are appropriately\n      relabeled.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (valtype) == TYPE_CODE_UNION\n-      || TYPE_CODE (valtype) == TYPE_CODE_ARRAY)\n+  if (valtype->code () == TYPE_CODE_STRUCT\n+      || valtype->code () == TYPE_CODE_UNION\n+      || valtype->code () == TYPE_CODE_ARRAY)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n \n   /* Scalar floating-point values are returned in FPR1 for float or\n      double, and in FPR1:FPR2 for quadword precision.  Fortran\n      complex*8 and complex*16 are returned in FPR1:FPR2, and\n      complex*32 is returned in FPR1:FPR4.  */\n-  if (TYPE_CODE (valtype) == TYPE_CODE_FLT\n+  if (valtype->code () == TYPE_CODE_FLT\n       && (TYPE_LENGTH (valtype) == 4 || TYPE_LENGTH (valtype) == 8))\n     {\n       struct type *regtype = register_type (gdbarch, tdep->ppc_fp0_regnum);\n@@ -355,7 +355,7 @@ rs6000_lynx178_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   if (TYPE_LENGTH (valtype) == 8)\n     {\n-      gdb_assert (TYPE_CODE (valtype) != TYPE_CODE_FLT);\n+      gdb_assert (valtype->code () != TYPE_CODE_FLT);\n       gdb_assert (tdep->wordsize == 4);\n \n       if (readbuf)"
    },
    {
      "sha": "3ccb307ec29f13138391c0dfa773c7070c3cfa34",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -2531,7 +2531,7 @@ rs6000_convert_register_p (struct gdbarch *gdbarch, int regnum,\n   return (tdep->ppc_fp0_regnum >= 0\n \t  && regnum >= tdep->ppc_fp0_regnum\n \t  && regnum < tdep->ppc_fp0_regnum + ppc_num_fprs\n-\t  && TYPE_CODE (type) == TYPE_CODE_FLT\n+\t  && type->code () == TYPE_CODE_FLT\n \t  && TYPE_LENGTH (type)\n \t     != TYPE_LENGTH (builtin_type (gdbarch)->builtin_double));\n }\n@@ -2546,7 +2546,7 @@ rs6000_register_to_value (struct frame_info *frame,\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n   gdb_byte from[PPC_MAX_REGISTER_SIZE];\n   \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);\n+  gdb_assert (type->code () == TYPE_CODE_FLT);\n \n   if (!get_frame_register_bytes (frame, regnum, 0,\n \t\t\t\t register_size (gdbarch, regnum),\n@@ -2568,7 +2568,7 @@ rs6000_value_to_register (struct frame_info *frame,\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n   gdb_byte to[PPC_MAX_REGISTER_SIZE];\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);\n+  gdb_assert (type->code () == TYPE_CODE_FLT);\n \n   target_float_convert (from, type,\n \t\t\tto, builtin_type (gdbarch)->builtin_double);"
    },
    {
      "sha": "6e3e49259d09f8390d3a996c5da6bb5af49d4b2a",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -2334,7 +2334,7 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t\t   call expression.  */\n \t\trust_op_vector *params = operation->right.params;\n \n-\t\tif (TYPE_CODE (type) != TYPE_CODE_NAMESPACE)\n+\t\tif (type->code () != TYPE_CODE_NAMESPACE)\n \t\t  {\n \t\t    if (!rust_tuple_struct_type_p (type))\n \t\t      error (_(\"Type %s is not a tuple struct\"), varname);\n@@ -2413,7 +2413,7 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t      error (_(\"No symbol '%s' in current context\"), varname);\n \n \t    if (!want_type\n-\t\t&& TYPE_CODE (type) == TYPE_CODE_STRUCT\n+\t\t&& type->code () == TYPE_CODE_STRUCT\n \t\t&& TYPE_NFIELDS (type) == 0)\n \t      {\n \t\t/* A unit-like struct.  */\n@@ -2470,7 +2470,7 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \tif (type == NULL)\n \t  error (_(\"Could not find type '%s'\"), operation->left.sval.ptr);\n \n-\tif (TYPE_CODE (type) != TYPE_CODE_STRUCT\n+\tif (type->code () != TYPE_CODE_STRUCT\n \t    || rust_tuple_type_p (type)\n \t    || rust_tuple_struct_type_p (type))\n \t  error (_(\"Struct expression applied to non-struct type\"));"
    },
    {
      "sha": "b8cc4daab558dbc07186513688193d3aae4f382a",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 29,
      "deletions": 29,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -109,7 +109,7 @@ rust_tuple_type_p (struct type *type)\n   /* The current implementation is a bit of a hack, but there's\n      nothing else in the debuginfo to distinguish a tuple from a\n      struct.  */\n-  return (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  return (type->code () == TYPE_CODE_STRUCT\n \t  && TYPE_NAME (type) != NULL\n \t  && TYPE_NAME (type)[0] == '(');\n }\n@@ -124,7 +124,7 @@ rust_underscore_fields (struct type *type)\n \n   field_number = 0;\n \n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT)\n+  if (type->code () != TYPE_CODE_STRUCT)\n     return false;\n   for (i = 0; i < TYPE_NFIELDS (type); ++i)\n     {\n@@ -157,7 +157,7 @@ rust_tuple_struct_type_p (struct type *type)\n static bool\n rust_slice_type_p (struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  return (type->code () == TYPE_CODE_STRUCT\n \t  && TYPE_NAME (type) != NULL\n \t  && (strncmp (TYPE_NAME (type), \"&[\", 2) == 0\n \t      || strcmp (TYPE_NAME (type), \"&str\") == 0));\n@@ -170,7 +170,7 @@ rust_range_type_p (struct type *type)\n {\n   int i;\n \n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n+  if (type->code () != TYPE_CODE_STRUCT\n       || TYPE_NFIELDS (type) > 2\n       || TYPE_NAME (type) == NULL\n       || strstr (TYPE_NAME (type), \"::Range\") == NULL)\n@@ -211,7 +211,7 @@ rust_inclusive_range_type_p (struct type *type)\n static bool\n rust_u8_type_p (struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_INT\n+  return (type->code () == TYPE_CODE_INT\n \t  && TYPE_UNSIGNED (type)\n \t  && TYPE_LENGTH (type) == 1);\n }\n@@ -221,7 +221,7 @@ rust_u8_type_p (struct type *type)\n static bool\n rust_chartype_p (struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_CHAR\n+  return (type->code () == TYPE_CODE_CHAR\n \t  && TYPE_LENGTH (type) == 4\n \t  && TYPE_UNSIGNED (type));\n }\n@@ -234,13 +234,13 @@ rust_is_string_type_p (struct type *type)\n   LONGEST low_bound, high_bound;\n \n   type = check_typedef (type);\n-  return ((TYPE_CODE (type) == TYPE_CODE_STRING)\n-\t  || (TYPE_CODE (type) == TYPE_CODE_PTR\n-\t      && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY\n+  return ((type->code () == TYPE_CODE_STRING)\n+\t  || (type->code () == TYPE_CODE_PTR\n+\t      && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ARRAY\n \t\t  && rust_u8_type_p (TYPE_TARGET_TYPE (TYPE_TARGET_TYPE (type)))\n \t\t  && get_array_bounds (TYPE_TARGET_TYPE (type), &low_bound,\n \t\t\t\t       &high_bound)))\n-\t  || (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+\t  || (type->code () == TYPE_CODE_STRUCT\n \t      && !rust_enum_p (type)\n \t      && rust_slice_type_p (type)\n \t      && strcmp (TYPE_NAME (type), \"&str\") == 0));\n@@ -255,7 +255,7 @@ rust_get_trait_object_pointer (struct value *value)\n {\n   struct type *type = check_typedef (value_type (value));\n \n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT || TYPE_NFIELDS (type) != 2)\n+  if (type->code () != TYPE_CODE_STRUCT || TYPE_NFIELDS (type) != 2)\n     return NULL;\n \n   /* Try to be a bit resilient if the ABI changes.  */\n@@ -559,13 +559,13 @@ rust_value_print_inner (struct value *val, struct ui_file *stream,\n \t\t\t ? Val_prettyformat : Val_no_prettyformat);\n \n   struct type *type = check_typedef (value_type (val));\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_PTR:\n       {\n \tLONGEST low_bound, high_bound;\n \t\n-\tif (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY\n+\tif (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ARRAY\n \t    && rust_u8_type_p (TYPE_TARGET_TYPE (TYPE_TARGET_TYPE (type)))\n \t    && get_array_bounds (TYPE_TARGET_TYPE (type), &low_bound,\n \t\t\t\t &high_bound))\n@@ -712,7 +712,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n \t  if (prop != nullptr && prop->kind == PROP_TYPE)\n \t    type = prop->data.original_type;\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      else if (type->code () == TYPE_CODE_STRUCT)\n \tfputs_filtered (\"struct \", stream);\n       else\n \tfputs_filtered (\"union \", stream);\n@@ -828,15 +828,15 @@ rust_internal_print_type (struct type *type, const char *varstring,\n     {\n       /* Rust calls the unit type \"void\" in its debuginfo,\n          but we don't want to print it as that.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_VOID)\n+      if (type->code () == TYPE_CODE_VOID)\n         fputs_filtered (\"()\", stream);\n       else\n         fputs_filtered (TYPE_NAME (type), stream);\n       return;\n     }\n \n   type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_VOID:\n       /* If we have an enum, we've already printed the type's\n@@ -865,7 +865,7 @@ rust_internal_print_type (struct type *type, const char *varstring,\n \t}\n       fputs_filtered (\")\", stream);\n       /* If it returns unit, we can omit the return type.  */\n-      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n+      if (TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n         {\n           fputs_filtered (\" -> \", stream);\n           rust_internal_print_type (TYPE_TARGET_TYPE (type), \"\", stream,\n@@ -1151,13 +1151,13 @@ rust_evaluate_funcall (struct expression *exp, int *pos, enum noside noside)\n   args[0] = arg0;\n \n   /* We don't yet implement real Deref semantics.  */\n-  while (TYPE_CODE (value_type (args[0])) == TYPE_CODE_PTR)\n+  while (value_type (args[0])->code () == TYPE_CODE_PTR)\n     args[0] = value_ind (args[0]);\n \n   type = value_type (args[0]);\n-  if ((TYPE_CODE (type) != TYPE_CODE_STRUCT\n-       && TYPE_CODE (type) != TYPE_CODE_UNION\n-       && TYPE_CODE (type) != TYPE_CODE_ENUM)\n+  if ((type->code () != TYPE_CODE_STRUCT\n+       && type->code () != TYPE_CODE_UNION\n+       && type->code () != TYPE_CODE_ENUM)\n       || rust_tuple_type_p (type))\n     error (_(\"Method calls only supported on struct or enum types\"));\n   if (TYPE_NAME (type) == NULL)\n@@ -1174,7 +1174,7 @@ rust_evaluate_funcall (struct expression *exp, int *pos, enum noside noside)\n   if (TYPE_NFIELDS (fn_type) == 0)\n     error (_(\"Function '%s' takes no arguments\"), name.c_str ());\n \n-  if (TYPE_CODE (TYPE_FIELD_TYPE (fn_type, 0)) == TYPE_CODE_PTR)\n+  if (TYPE_FIELD_TYPE (fn_type, 0)->code () == TYPE_CODE_PTR)\n     args[0] = value_addr (args[0]);\n \n   function = address_of_variable (sym.symbol, block);\n@@ -1361,7 +1361,7 @@ rust_subscript (struct expression *exp, int *pos, enum noside noside,\n   if (noside == EVAL_AVOID_SIDE_EFFECTS)\n     {\n       struct type *base_type = nullptr;\n-      if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+      if (type->code () == TYPE_CODE_ARRAY)\n \tbase_type = TYPE_TARGET_TYPE (type);\n       else if (rust_slice_type_p (type))\n \t{\n@@ -1376,7 +1376,7 @@ rust_subscript (struct expression *exp, int *pos, enum noside noside,\n \t  if (base_type == nullptr)\n \t    error (_(\"Could not find 'data_ptr' in slice type\"));\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+      else if (type->code () == TYPE_CODE_PTR)\n \tbase_type = TYPE_TARGET_TYPE (type);\n       else\n \terror (_(\"Cannot subscript non-array type\"));\n@@ -1405,7 +1405,7 @@ rust_subscript (struct expression *exp, int *pos, enum noside noside,\n       LONGEST low_bound;\n       struct value *base;\n \n-      if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+      if (type->code () == TYPE_CODE_ARRAY)\n \t{\n \t  base = lhs;\n \t  if (!get_array_bounds (type, &low_bound, &high_bound))\n@@ -1423,7 +1423,7 @@ rust_subscript (struct expression *exp, int *pos, enum noside noside,\n \t  low_bound = 0;\n \t  high_bound = value_as_long (len);\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+      else if (type->code () == TYPE_CODE_PTR)\n \t{\n \t  base = lhs;\n \t  low_bound = 0;\n@@ -1526,7 +1526,7 @@ rust_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t    /* Preserving the type is enough.  */\n \t    return value;\n \t  }\n-\tif (TYPE_CODE (value_type (value)) == TYPE_CODE_BOOL)\n+\tif (value_type (value)->code () == TYPE_CODE_BOOL)\n \t  result = value_from_longest (value_type (value),\n \t\t\t\t       value_logical_not (value));\n \telse\n@@ -1655,7 +1655,7 @@ rust_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n         type = value_type (lhs);\n \n-\tif (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+\tif (type->code () == TYPE_CODE_STRUCT)\n \t  {\n \t    struct type *outer_type = NULL;\n \n@@ -1727,7 +1727,7 @@ tuple structs, and tuple-like enum variants\"));\n \n \tconst char *field_name = &exp->elts[pc + 2].string;\n         type = value_type (lhs);\n-        if (TYPE_CODE (type) == TYPE_CODE_STRUCT && rust_enum_p (type))\n+        if (type->code () == TYPE_CODE_STRUCT && rust_enum_p (type))\n \t  {\n \t    gdb::array_view<const gdb_byte> view (value_contents (lhs),\n \t\t\t\t\t\t  TYPE_LENGTH (type));"
    },
    {
      "sha": "9963bc358d4544f79a9e0c98fdf78903ced5e916",
      "filename": "gdb/rx-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/rx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rx-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -668,12 +668,12 @@ rx_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   struct type *func_type = value_type (function);\n \n   /* Dereference function pointer types.  */\n-  while (TYPE_CODE (func_type) == TYPE_CODE_PTR)\n+  while (func_type->code () == TYPE_CODE_PTR)\n     func_type = TYPE_TARGET_TYPE (func_type);\n \n   /* The end result had better be a function or a method.  */\n-  gdb_assert (TYPE_CODE (func_type) == TYPE_CODE_FUNC\n-\t      || TYPE_CODE (func_type) == TYPE_CODE_METHOD);\n+  gdb_assert (func_type->code () == TYPE_CODE_FUNC\n+\t      || func_type->code () == TYPE_CODE_METHOD);\n \n   /* Functions with a variable number of arguments have all of their\n      variable arguments and the last non-variable argument passed\n@@ -706,8 +706,8 @@ rx_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t{\n \t  struct type *return_type = TYPE_TARGET_TYPE (func_type);\n \n-\t  gdb_assert (TYPE_CODE (return_type) == TYPE_CODE_STRUCT\n-\t\t      || TYPE_CODE (func_type) == TYPE_CODE_UNION);\n+\t  gdb_assert (return_type->code () == TYPE_CODE_STRUCT\n+\t\t      || func_type->code () == TYPE_CODE_UNION);\n \n \t  if (TYPE_LENGTH (return_type) > 16\n \t      || TYPE_LENGTH (return_type) % 4 != 0)\n@@ -728,7 +728,7 @@ rx_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n \t  if (i == 0 && struct_addr != 0\n \t      && return_method != return_method_struct\n-\t      && TYPE_CODE (arg_type) == TYPE_CODE_PTR\n+\t      && arg_type->code () == TYPE_CODE_PTR\n \t      && extract_unsigned_integer (arg_bits, 4,\n \t\t\t\t\t   byte_order) == struct_addr)\n \t    {\n@@ -739,8 +739,8 @@ rx_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\tregcache_cooked_write_unsigned (regcache, RX_R15_REGNUM,\n \t\t\t\t\t\tstruct_addr);\n \t    }\n-\t  else if (TYPE_CODE (arg_type) != TYPE_CODE_STRUCT\n-\t\t   && TYPE_CODE (arg_type) != TYPE_CODE_UNION\n+\t  else if (arg_type->code () != TYPE_CODE_STRUCT\n+\t\t   && arg_type->code () != TYPE_CODE_UNION\n \t\t   && arg_size <= 8)\n \t    {\n \t      /* Argument is a scalar.  */\n@@ -874,8 +874,8 @@ rx_return_value (struct gdbarch *gdbarch,\n   ULONGEST valtype_len = TYPE_LENGTH (valtype);\n \n   if (TYPE_LENGTH (valtype) > 16\n-      || ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-\t   || TYPE_CODE (valtype) == TYPE_CODE_UNION)\n+      || ((valtype->code () == TYPE_CODE_STRUCT\n+\t   || valtype->code () == TYPE_CODE_UNION)\n \t  && TYPE_LENGTH (valtype) % 4 != 0))\n     return RETURN_VALUE_STRUCT_CONVENTION;\n "
    },
    {
      "sha": "607652c61a32ade9c3c4591481b91cfda49a04da",
      "filename": "gdb/s12z-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/s12z-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/s12z-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s12z-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -614,9 +614,9 @@ s12z_return_value (struct gdbarch *gdbarch, struct value *function,\n                    struct type *type, struct regcache *regcache,\n                    gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || TYPE_CODE (type) == TYPE_CODE_ARRAY\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || type->code () == TYPE_CODE_ARRAY\n       || TYPE_LENGTH (type) > 4)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n "
    },
    {
      "sha": "e94bf59b44d792408c5c8bb6b95c6caec48dda0b",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -63,7 +63,7 @@ s390_type_align (gdbarch *gdbarch, struct type *t)\n \n   if (TYPE_LENGTH (t) > 8)\n     {\n-      switch (TYPE_CODE (t))\n+      switch (t->code ())\n \t{\n \tcase TYPE_CODE_INT:\n \tcase TYPE_CODE_RANGE:\n@@ -1638,7 +1638,7 @@ s390_address_class_name_to_type_flags (struct gdbarch *gdbarch,\n static struct type *\n s390_effective_inner_type (struct type *type, unsigned int min_size)\n {\n-  while (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+  while (type->code () == TYPE_CODE_STRUCT)\n     {\n       struct type *inner = NULL;\n \n@@ -1681,8 +1681,8 @@ s390_function_arg_float (struct type *type)\n      or double.  */\n   type = s390_effective_inner_type (type, 0);\n \n-  return (TYPE_CODE (type) == TYPE_CODE_FLT\n-\t  || TYPE_CODE (type) == TYPE_CODE_DECFLOAT);\n+  return (type->code () == TYPE_CODE_FLT\n+\t  || type->code () == TYPE_CODE_DECFLOAT);\n }\n \n /* Return non-zero if TYPE should be passed like a vector.  */\n@@ -1696,7 +1696,7 @@ s390_function_arg_vector (struct type *type)\n   /* Structs containing just a vector are passed like a vector.  */\n   type = s390_effective_inner_type (type, TYPE_LENGTH (type));\n \n-  return TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type);\n+  return type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type);\n }\n \n /* Determine whether N is a power of two.  */\n@@ -1714,7 +1714,7 @@ is_power_of_two (unsigned int n)\n static int\n s390_function_arg_integer (struct type *type)\n {\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n \n   if (TYPE_LENGTH (type) > 8)\n     return 0;\n@@ -1921,7 +1921,7 @@ s390_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   CORE_ADDR param_area_start, new_sp;\n   struct type *ftype = check_typedef (value_type (function));\n \n-  if (TYPE_CODE (ftype) == TYPE_CODE_PTR)\n+  if (ftype->code () == TYPE_CODE_PTR)\n     ftype = check_typedef (TYPE_TARGET_TYPE (ftype));\n \n   arg_prep.copy = sp;\n@@ -2021,7 +2021,7 @@ s390_register_return_value (struct gdbarch *gdbarch, struct type *type,\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int word_size = gdbarch_ptr_bit (gdbarch) / 8;\n   int length = TYPE_LENGTH (type);\n-  int code = TYPE_CODE (type);\n+  int code = type->code ();\n \n   if (code == TYPE_CODE_FLT || code == TYPE_CODE_DECFLOAT)\n     {\n@@ -2083,7 +2083,7 @@ s390_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   type = check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:"
    },
    {
      "sha": "98ebeb2fcfcc01d7b3a569def98c888c4c9de568",
      "filename": "gdb/score-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/score-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/score-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/score-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -442,9 +442,9 @@ score_return_value (struct gdbarch *gdbarch, struct value *function,\n                     struct type *type, struct regcache *regcache,\n                     gdb_byte * readbuf, const gdb_byte * writebuf)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || type->code () == TYPE_CODE_ARRAY)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n   else\n     {\n@@ -469,7 +469,7 @@ score_return_value (struct gdbarch *gdbarch, struct value *function,\n static int\n score_type_needs_double_align (struct type *type)\n {\n-  enum type_code typecode = TYPE_CODE (type);\n+  enum type_code typecode = type->code ();\n \n   if ((typecode == TYPE_CODE_INT && TYPE_LENGTH (type) == 8)\n       || (typecode == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8))\n@@ -529,7 +529,7 @@ score_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n     {\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n       const gdb_byte *val = value_contents (arg);\n       int downward_offset = 0;\n       int arg_last_part_p = 0;"
    },
    {
      "sha": "c6bef85588ea091ee34abd9a87a193871b759203",
      "filename": "gdb/sh-tdep.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/sh-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/sh-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -92,10 +92,10 @@ sh_is_renesas_calling_convention (struct type *func_type)\n     {\n       func_type = check_typedef (func_type);\n \n-      if (TYPE_CODE (func_type) == TYPE_CODE_PTR)\n+      if (func_type->code () == TYPE_CODE_PTR)\n         func_type = check_typedef (TYPE_TARGET_TYPE (func_type));\n \n-      if (TYPE_CODE (func_type) == TYPE_CODE_FUNC\n+      if (func_type->code () == TYPE_CODE_FUNC\n           && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GNU_renesas_sh)\n         val = 1;\n     }\n@@ -816,8 +816,8 @@ sh_use_struct_convention (int renesas_abi, struct type *type)\n   int nelem = TYPE_NFIELDS (type);\n \n   /* The Renesas ABI returns aggregate types always on stack.  */\n-  if (renesas_abi && (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t\t      || TYPE_CODE (type) == TYPE_CODE_UNION))\n+  if (renesas_abi && (type->code () == TYPE_CODE_STRUCT\n+\t\t      || type->code () == TYPE_CODE_UNION))\n     return 1;\n \n   /* Non-power of 2 length types and types bigger than 8 bytes (which don't\n@@ -1040,17 +1040,17 @@ static int\n sh_treat_as_flt_p (struct type *type)\n {\n   /* Ordinary float types are obviously treated as float.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (type->code () == TYPE_CODE_FLT)\n     return 1;\n   /* Otherwise non-struct types are not treated as float.  */\n-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT)\n+  if (type->code () != TYPE_CODE_STRUCT)\n     return 0;\n   /* Otherwise structs with more than one member are not treated as float.  */\n   if (TYPE_NFIELDS (type) != 1)\n     return 0;\n   /* Otherwise if the type of that member is float, the whole type is\n      treated as float.  */\n-  if (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_FLT)\n+  if (TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_FLT)\n     return 1;\n   /* Otherwise it's not treated as float.  */\n   return 0;\n@@ -1115,9 +1115,9 @@ sh_push_dummy_call_fpu (struct gdbarch *gdbarch,\n       /* In Renesas ABI, long longs and aggregate types are always passed\n \t on stack.  */\n       else if (sh_is_renesas_calling_convention (func_type)\n-\t       && ((TYPE_CODE (type) == TYPE_CODE_INT && len == 8)\n-\t\t   || TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t\t   || TYPE_CODE (type) == TYPE_CODE_UNION))\n+\t       && ((type->code () == TYPE_CODE_INT && len == 8)\n+\t\t   || type->code () == TYPE_CODE_STRUCT\n+\t\t   || type->code () == TYPE_CODE_UNION))\n \tpass_on_stack = 1;\n       /* In contrast to non-FPU CPUs, arguments are never split between\n \t registers and stack.  If an argument doesn't fit in the remaining\n@@ -1248,10 +1248,10 @@ sh_push_dummy_call_nofpu (struct gdbarch *gdbarch,\n       /* Renesas ABI pushes doubles and long longs entirely on stack.\n \t Same goes for aggregate types.  */\n       if (sh_is_renesas_calling_convention (func_type)\n-\t  && ((TYPE_CODE (type) == TYPE_CODE_INT && len >= 8)\n-\t      || (TYPE_CODE (type) == TYPE_CODE_FLT && len >= 8)\n-\t      || TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t      || TYPE_CODE (type) == TYPE_CODE_UNION))\n+\t  && ((type->code () == TYPE_CODE_INT && len >= 8)\n+\t      || (type->code () == TYPE_CODE_FLT && len >= 8)\n+\t      || type->code () == TYPE_CODE_STRUCT\n+\t      || type->code () == TYPE_CODE_UNION))\n \tpass_on_stack = 1;\n       while (len > 0)\n \t{"
    },
    {
      "sha": "9e00a678a19dc29d6b5b814dce0a01bd3fb03890",
      "filename": "gdb/sparc-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/sparc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/sparc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -214,7 +214,7 @@ sparc_integral_or_pointer_p (const struct type *type)\n {\n   int len = TYPE_LENGTH (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_BOOL:\n@@ -242,7 +242,7 @@ sparc_integral_or_pointer_p (const struct type *type)\n static int\n sparc_floating_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_FLT:\n       {\n@@ -261,7 +261,7 @@ sparc_floating_p (const struct type *type)\n static int\n sparc_complex_floating_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_COMPLEX:\n       {\n@@ -284,7 +284,7 @@ sparc_complex_floating_p (const struct type *type)\n static int\n sparc_structure_or_union_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n@@ -303,7 +303,7 @@ sparc_structure_or_union_p (const struct type *type)\n static bool\n sparc_structure_return_p (const struct type *type)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n     {\n       /* Float vectors are always returned by memory.  */\n       if (sparc_floating_p (check_typedef (TYPE_TARGET_TYPE (type))))\n@@ -331,7 +331,7 @@ sparc_structure_return_p (const struct type *type)\n static bool\n sparc_arg_by_memory_p (const struct type *type)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n     {\n       /* Float vectors are always passed by memory.  */\n       if (sparc_floating_p (check_typedef (TYPE_TARGET_TYPE (type))))\n@@ -1228,7 +1228,7 @@ static int\n sparc32_struct_return_from_sym (struct symbol *sym)\n {\n   struct type *type = check_typedef (SYMBOL_TYPE (sym));\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n \n   if (code == TYPE_CODE_FUNC || code == TYPE_CODE_METHOD)\n     {\n@@ -1402,7 +1402,7 @@ sparc32_extract_return_value (struct type *type, struct regcache *regcache,\n   gdb_assert (!sparc_structure_return_p (type));\n \n   if (sparc_floating_p (type) || sparc_complex_floating_p (type)\n-      || TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+      || type->code () == TYPE_CODE_ARRAY)\n     {\n       /* Floating return values.  */\n       regcache->cooked_read (SPARC_F0_REGNUM, buf);"
    },
    {
      "sha": "39ba455e6fb16ac5c4ead8efc038dadc03cb0b7a",
      "filename": "gdb/sparc64-tdep.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/sparc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/sparc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -550,7 +550,7 @@ _initialize_sparc64_adi_tdep ()\n static int\n sparc64_integral_or_pointer_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_BOOL:\n@@ -582,7 +582,7 @@ sparc64_integral_or_pointer_p (const struct type *type)\n static int\n sparc64_floating_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_FLT:\n       {\n@@ -602,7 +602,7 @@ sparc64_floating_p (const struct type *type)\n static int\n sparc64_complex_floating_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_COMPLEX:\n       {\n@@ -626,7 +626,7 @@ sparc64_complex_floating_p (const struct type *type)\n static int\n sparc64_structure_or_union_p (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n@@ -1165,7 +1165,7 @@ static const struct frame_base sparc64_frame_base =\n static int\n sparc64_16_byte_align_p (struct type *type)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_ARRAY)\n     {\n       struct type *t = check_typedef (TYPE_TARGET_TYPE (type));\n \n@@ -1206,7 +1206,7 @@ sparc64_store_floating_fields (struct regcache *regcache, struct type *type,\n \n   gdb_assert (element < 16);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_ARRAY)\n     {\n       gdb_byte buf[8];\n       int regnum = SPARC_F0_REGNUM + element * 2 + bitpos / 32;\n@@ -1295,7 +1295,7 @@ sparc64_extract_floating_fields (struct regcache *regcache, struct type *type,\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n \n-  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_ARRAY)\n     {\n       int len = TYPE_LENGTH (type);\n       int regnum =  SPARC_F0_REGNUM + bitpos / 32;\n@@ -1656,7 +1656,7 @@ sparc64_extract_return_value (struct type *type, struct regcache *regcache,\n \n       for (i = 0; i < ((len + 7) / 8); i++)\n \tregcache->cooked_read (SPARC_O0_REGNUM + i, buf + i * 8);\n-      if (TYPE_CODE (type) != TYPE_CODE_UNION)\n+      if (type->code () != TYPE_CODE_UNION)\n \tsparc64_extract_floating_fields (regcache, type, buf, 0);\n       memcpy (valbuf, buf, len);\n     }\n@@ -1667,7 +1667,7 @@ sparc64_extract_return_value (struct type *type, struct regcache *regcache,\n \tregcache->cooked_read (SPARC_F0_REGNUM + i, buf + i * 4);\n       memcpy (valbuf, buf, len);\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  else if (type->code () == TYPE_CODE_ARRAY)\n     {\n       /* Small arrays are returned the same way as small structures.  */\n       gdb_assert (len <= 32);\n@@ -1711,7 +1711,7 @@ sparc64_store_return_value (struct type *type, struct regcache *regcache,\n       memcpy (buf, valbuf, len);\n       for (i = 0; i < ((len + 7) / 8); i++)\n \tregcache->cooked_write (SPARC_O0_REGNUM + i, buf + i * 8);\n-      if (TYPE_CODE (type) != TYPE_CODE_UNION)\n+      if (type->code () != TYPE_CODE_UNION)\n \tsparc64_store_floating_fields (regcache, type, buf, 0, 0);\n     }\n   else if (sparc64_floating_p (type) || sparc64_complex_floating_p (type))\n@@ -1721,7 +1721,7 @@ sparc64_store_return_value (struct type *type, struct regcache *regcache,\n       for (i = 0; i < len / 4; i++)\n \tregcache->cooked_write (SPARC_F0_REGNUM + i, buf + i * 4);\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  else if (type->code () == TYPE_CODE_ARRAY)\n     {\n       /* Small arrays are returned the same way as small structures.  */\n       gdb_assert (len <= 32);"
    },
    {
      "sha": "77f105d07b359cbf426ed1ea2ec69d1b188d236a",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -955,7 +955,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       /* Function result types are described as the result type in stabs.\n          We need to convert this to the function-returning-type-X type\n          in GDB.  E.g. \"int\" is converted to \"function returning int\".  */\n-      if (TYPE_CODE (SYMBOL_TYPE (sym)) != TYPE_CODE_FUNC)\n+      if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_FUNC)\n \tSYMBOL_TYPE (sym) = lookup_function_type (SYMBOL_TYPE (sym));\n \n       /* All functions in C++ have prototypes.  Stabs does not offer an\n@@ -1004,7 +1004,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t         a TYPE_CODE_VOID type by read_type, and we have to turn\n \t         it back into builtin_int here.\n \t         FIXME: Do we need a new builtin_promoted_int_arg ?  */\n-\t      if (TYPE_CODE (ptype) == TYPE_CODE_VOID)\n+\t      if (ptype->code () == TYPE_CODE_VOID)\n \t\tptype = objfile_type (objfile)->builtin_int;\n \t      TYPE_FIELD_TYPE (ftype, nparams) = ptype;\n \t      TYPE_FIELD_ARTIFICIAL (ftype, nparams++) = 0;\n@@ -1093,7 +1093,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t     really an int.  */\n \t  if (TYPE_LENGTH (SYMBOL_TYPE (sym))\n \t      < gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT\n-\t      && TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_INT)\n+\t      && SYMBOL_TYPE (sym)->code () == TYPE_CODE_INT)\n \t    {\n \t      SYMBOL_TYPE (sym) =\n \t\tTYPE_UNSIGNED (SYMBOL_TYPE (sym))\n@@ -1239,8 +1239,8 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n          derived class was output.  We fill in the derived class's\n          base part member's name here in that case.  */\n       if (TYPE_NAME (SYMBOL_TYPE (sym)) != NULL)\n-\tif ((TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_STRUCT\n-\t     || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_UNION)\n+\tif ((SYMBOL_TYPE (sym)->code () == TYPE_CODE_STRUCT\n+\t     || SYMBOL_TYPE (sym)->code () == TYPE_CODE_UNION)\n \t    && TYPE_N_BASECLASSES (SYMBOL_TYPE (sym)))\n \t  {\n \t    int j;\n@@ -1253,9 +1253,9 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n       if (TYPE_NAME (SYMBOL_TYPE (sym)) == NULL)\n \t{\n-\t  if ((TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR\n+\t  if ((SYMBOL_TYPE (sym)->code () == TYPE_CODE_PTR\n \t       && strcmp (sym->linkage_name (), vtbl_ptr_name))\n-\t      || TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FUNC)\n+\t      || SYMBOL_TYPE (sym)->code () == TYPE_CODE_FUNC)\n \t    {\n \t      /* If we are giving a name to a type such as \"pointer to\n \t         foo\" or \"function returning foo\", we better not set\n@@ -1548,7 +1548,7 @@ read_type (const char **pp, struct objfile *objfile)\n           /* If this is a forward reference, arrange to complain if it\n              doesn't get patched up by the time we're done\n              reading.  */\n-          if (TYPE_CODE (type) == TYPE_CODE_UNDEF)\n+          if (type->code () == TYPE_CODE_UNDEF)\n             add_undefined_type (type, typenums);\n \n           return type;\n@@ -1670,7 +1670,7 @@ read_type (const char **pp, struct objfile *objfile)\n \n \t      if (SYMBOL_CLASS (sym) == LOC_TYPEDEF\n \t\t  && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN\n-\t\t  && (TYPE_CODE (SYMBOL_TYPE (sym)) == code)\n+\t\t  && (SYMBOL_TYPE (sym)->code () == code)\n \t\t  && strcmp (sym->linkage_name (), type_name) == 0)\n \t\t{\n \t\t  obstack_free (&objfile->objfile_obstack, type_name);\n@@ -1835,7 +1835,7 @@ read_type (const char **pp, struct objfile *objfile)\n            that's just an empty argument list.  */\n         if (arg_types\n             && ! arg_types->next\n-            && TYPE_CODE (arg_types->type) == TYPE_CODE_VOID)\n+            && arg_types->type->code () == TYPE_CODE_VOID)\n           num_args = 0;\n \n         TYPE_FIELDS (func_type)\n@@ -2369,10 +2369,10 @@ read_member_functions (struct stab_field_info *fip, const char **pp,\n \t    }\n \n \t  /* These are methods, not functions.  */\n-\t  if (TYPE_CODE (new_sublist->fn_field.type) == TYPE_CODE_FUNC)\n+\t  if (new_sublist->fn_field.type->code () == TYPE_CODE_FUNC)\n \t    new_sublist->fn_field.type->set_code (TYPE_CODE_METHOD);\n \t  else\n-\t    gdb_assert (TYPE_CODE (new_sublist->fn_field.type)\n+\t    gdb_assert (new_sublist->fn_field.type->code ()\n \t\t\t== TYPE_CODE_METHOD);\n \n \t  /* If this is just a stub, then we don't have the real name here.  */\n@@ -2920,16 +2920,16 @@ read_one_struct_field (struct stab_field_info *fip, const char **pp,\n \n       struct type *field_type = check_typedef (FIELD_TYPE (fip->list->field));\n \n-      if (TYPE_CODE (field_type) != TYPE_CODE_INT\n-\t  && TYPE_CODE (field_type) != TYPE_CODE_RANGE\n-\t  && TYPE_CODE (field_type) != TYPE_CODE_BOOL\n-\t  && TYPE_CODE (field_type) != TYPE_CODE_ENUM)\n+      if (field_type->code () != TYPE_CODE_INT\n+\t  && field_type->code () != TYPE_CODE_RANGE\n+\t  && field_type->code () != TYPE_CODE_BOOL\n+\t  && field_type->code () != TYPE_CODE_ENUM)\n \t{\n \t  FIELD_BITSIZE (fip->list->field) = 0;\n \t}\n       if ((FIELD_BITSIZE (fip->list->field)\n \t   == TARGET_CHAR_BIT * TYPE_LENGTH (field_type)\n-\t   || (TYPE_CODE (field_type) == TYPE_CODE_ENUM\n+\t   || (field_type->code () == TYPE_CODE_ENUM\n \t       && FIELD_BITSIZE (fip->list->field)\n \t\t  == gdbarch_int_bit (gdbarch))\n \t  )\n@@ -3382,7 +3382,7 @@ complain_about_struct_wipeout (struct type *type)\n   if (TYPE_NAME (type))\n     {\n       name = TYPE_NAME (type);\n-      switch (TYPE_CODE (type))\n+      switch (type->code ())\n         {\n         case TYPE_CODE_STRUCT: kind = \"struct \"; break;\n         case TYPE_CODE_UNION:  kind = \"union \";  break;\n@@ -3467,7 +3467,7 @@ read_struct_type (const char **pp, struct type *type, enum type_code type_code,\n      Obviously, GDB can't fix this by itself, but it can at least avoid\n      scribbling on existing structure type objects when new definitions\n      appear.  */\n-  if (! (TYPE_CODE (type) == TYPE_CODE_UNDEF\n+  if (! (type->code () == TYPE_CODE_UNDEF\n          || TYPE_STUB (type)))\n     {\n       complain_about_struct_wipeout (type);\n@@ -4231,7 +4231,7 @@ read_args (const char **pp, int end, struct objfile *objfile, int *nargsp,\n       complaint (_(\"Invalid (empty) method arguments\"));\n       *varargsp = 0;\n     }\n-  else if (TYPE_CODE (types[n - 1]) != TYPE_CODE_VOID)\n+  else if (types[n - 1]->code () != TYPE_CODE_VOID)\n     *varargsp = 1;\n   else\n     {\n@@ -4429,7 +4429,7 @@ cleanup_undefined_types_noname (struct objfile *objfile)\n       struct type **type;\n \n       type = dbx_lookup_type (nat.typenums, objfile);\n-      if (nat.type != *type && TYPE_CODE (*type) != TYPE_CODE_UNDEF)\n+      if (nat.type != *type && (*type)->code () != TYPE_CODE_UNDEF)\n         {\n           /* The instance flags of the undefined type are still unset,\n              and needs to be copied over from the reference type.\n@@ -4479,7 +4479,7 @@ cleanup_undefined_types_1 (void)\n \n   for (type = undef_types; type < undef_types + undef_types_length; type++)\n     {\n-      switch (TYPE_CODE (*type))\n+      switch ((*type)->code ())\n \t{\n \n \tcase TYPE_CODE_STRUCT:\n@@ -4510,8 +4510,8 @@ cleanup_undefined_types_1 (void)\n \n \t\t\tif (SYMBOL_CLASS (sym) == LOC_TYPEDEF\n \t\t\t    && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN\n-\t\t\t    && (TYPE_CODE (SYMBOL_TYPE (sym)) ==\n-\t\t\t\tTYPE_CODE (*type))\n+\t\t\t    && (SYMBOL_TYPE (sym)->code () ==\n+\t\t\t\t(*type)->code ())\n \t\t\t    && (TYPE_INSTANCE_FLAGS (*type) ==\n \t\t\t\tTYPE_INSTANCE_FLAGS (SYMBOL_TYPE (sym)))\n \t\t\t    && strcmp (sym->linkage_name (), type_name) == 0)\n@@ -4526,7 +4526,7 @@ cleanup_undefined_types_1 (void)\n \t  {\n \t    complaint (_(\"forward-referenced types left unresolved, \"\n                        \"type code %d.\"),\n-\t\t       TYPE_CODE (*type));\n+\t\t       (*type)->code ());\n \t  }\n \t  break;\n \t}"
    },
    {
      "sha": "f67a151aeee96f45bdebeae6f9e96c1def4d58c9",
      "filename": "gdb/stack.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stack.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -2769,7 +2769,7 @@ return_command (const char *retval_exp, int from_tty)\n \tfunction = read_var_value (thisfun, NULL, thisframe);\n \n       rv_conv = RETURN_VALUE_REGISTER_CONVENTION;\n-      if (TYPE_CODE (return_type) == TYPE_CODE_VOID)\n+      if (return_type->code () == TYPE_CODE_VOID)\n \t/* If the return-type is \"void\", don't try to find the\n            return-value's location.  However, do still evaluate the\n            return expression so that, even when the expression result"
    },
    {
      "sha": "ebbedef7b97b0bac3ef6a8810581e70532fdebee",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -564,9 +564,9 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n       else\n \t{\n \t  fprintf_filtered (outfile, \"%s %s = \",\n-\t\t\t (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_ENUM\n+\t\t\t (SYMBOL_TYPE (symbol)->code () == TYPE_CODE_ENUM\n \t\t\t  ? \"enum\"\n-\t\t     : (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_STRUCT\n+\t\t     : (SYMBOL_TYPE (symbol)->code () == TYPE_CODE_STRUCT\n \t\t\t? \"struct\" : \"union\")),\n \t\t\t    symbol->linkage_name ());\n \t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), \"\", outfile, 1, depth,\n@@ -583,7 +583,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \t  /* Print details of types, except for enums where it's clutter.  */\n \t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), symbol->print_name (),\n \t\t\t outfile,\n-\t\t\t TYPE_CODE (SYMBOL_TYPE (symbol)) != TYPE_CODE_ENUM,\n+\t\t\t SYMBOL_TYPE (symbol)->code () != TYPE_CODE_ENUM,\n \t\t\t depth,\n \t\t\t &type_print_raw_options);\n \t  fprintf_filtered (outfile, \"; \");"
    },
    {
      "sha": "2043d084140ca68ab7e7e8eab30e515bf1820a5e",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -2062,11 +2062,11 @@ lookup_symbol_aux (const char *name, symbol_name_match_type match_type,\n \t  /* I'm not really sure that type of this can ever\n \t     be typedefed; just be safe.  */\n \t  t = check_typedef (t);\n-\t  if (TYPE_CODE (t) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (t))\n+\t  if (t->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (t))\n \t    t = TYPE_TARGET_TYPE (t);\n \n-\t  if (TYPE_CODE (t) != TYPE_CODE_STRUCT\n-\t      && TYPE_CODE (t) != TYPE_CODE_UNION)\n+\t  if (t->code () != TYPE_CODE_STRUCT\n+\t      && t->code () != TYPE_CODE_UNION)\n \t    error (_(\"Internal error: `%s' is not an aggregate\"),\n \t\t   langdef->la_name_of_this);\n \n@@ -4652,7 +4652,7 @@ global_symbol_searcher::add_matching_symbols\n \t\t\t      members.  We only want to skip enums\n \t\t\t      here.  */\n \t\t\t   && !(SYMBOL_CLASS (sym) == LOC_CONST\n-\t\t\t\t&& (TYPE_CODE (SYMBOL_TYPE (sym))\n+\t\t\t\t&& (SYMBOL_TYPE (sym)->code ()\n \t\t\t\t    == TYPE_CODE_ENUM))\n \t\t\t   && (!treg.has_value ()\n \t\t\t       || treg_matches_sym_type_name (*treg, sym)))\n@@ -4858,7 +4858,7 @@ symbol_to_info_string (struct symbol *sym, int block,\n \t For the struct printing case below, things are worse, we force\n \t printing of the \";\" in this function, which is going to be wrong\n \t for languages that don't require a \";\" between statements.  */\n-      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_TYPEDEF)\n+      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_TYPEDEF)\n \ttypedef_print (SYMBOL_TYPE (sym), sym, &tmp_stream);\n       else\n \ttype_print (SYMBOL_TYPE (sym), \"\", &tmp_stream, -1);\n@@ -5484,7 +5484,7 @@ completion_list_add_fields (completion_tracker &tracker,\n   if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n     {\n       struct type *t = SYMBOL_TYPE (sym);\n-      enum type_code c = TYPE_CODE (t);\n+      enum type_code c = t->code ();\n       int j;\n \n       if (c == TYPE_CODE_UNION || c == TYPE_CODE_STRUCT)\n@@ -5501,7 +5501,7 @@ completion_list_add_fields (completion_tracker &tracker,\n bool\n symbol_is_function_or_method (symbol *sym)\n {\n-  switch (TYPE_CODE (SYMBOL_TYPE (sym)))\n+  switch (SYMBOL_TYPE (sym)->code ())\n     {\n     case TYPE_CODE_FUNC:\n     case TYPE_CODE_METHOD:\n@@ -5601,7 +5601,7 @@ add_symtab_completions (struct compunit_symtab *cust,\n \n \t  if (code == TYPE_CODE_UNDEF\n \t      || (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN\n-\t\t  && TYPE_CODE (SYMBOL_TYPE (sym)) == code))\n+\t\t  && SYMBOL_TYPE (sym)->code () == code))\n \t    completion_list_add_symbol (tracker, sym,\n \t\t\t\t\tlookup_name,\n \t\t\t\t\ttext, word);\n@@ -5752,7 +5752,7 @@ default_collect_symbol_completion_matches_break_on\n \t\t\t\t\t    sym_text, word);\n \t      }\n \t    else if (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN\n-\t\t     && TYPE_CODE (SYMBOL_TYPE (sym)) == code)\n+\t\t     && SYMBOL_TYPE (sym)->code () == code)\n \t      completion_list_add_symbol (tracker, sym, lookup_name,\n \t\t\t\t\t  sym_text, word);\n \t  }"
    },
    {
      "sha": "83ef98ab8199f5e5d546446e65947f14cfd47053",
      "filename": "gdb/target-float.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/target-float.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/target-float.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-float.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1742,7 +1742,7 @@ mpfr_float_ops::compare (const gdb_byte *x, const struct type *type_x,\n static void\n match_endianness (const gdb_byte *from, const struct type *type, gdb_byte *to)\n {\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_DECFLOAT);\n+  gdb_assert (type->code () == TYPE_CODE_DECFLOAT);\n \n   int len = TYPE_LENGTH (type);\n   int i;\n@@ -1768,7 +1768,7 @@ match_endianness (const gdb_byte *from, const struct type *type, gdb_byte *to)\n static void\n set_decnumber_context (decContext *ctx, const struct type *type)\n {\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_DECFLOAT);\n+  gdb_assert (type->code () == TYPE_CODE_DECFLOAT);\n \n   switch (TYPE_LENGTH (type))\n     {\n@@ -2142,7 +2142,7 @@ static bool\n target_float_same_category_p (const struct type *type1,\n \t\t\t      const struct type *type2)\n {\n-  return TYPE_CODE (type1) == TYPE_CODE (type2);\n+  return type1->code () == type2->code ();\n }\n \n /* Return whether TYPE1 and TYPE2 use the same floating-point format.  */\n@@ -2153,7 +2153,7 @@ target_float_same_format_p (const struct type *type1,\n   if (!target_float_same_category_p (type1, type2))\n     return false;\n \n-  switch (TYPE_CODE (type1))\n+  switch (type1->code ())\n     {\n       case TYPE_CODE_FLT:\n \treturn floatformat_from_type (type1) == floatformat_from_type (type2);\n@@ -2173,7 +2173,7 @@ target_float_same_format_p (const struct type *type1,\n static int\n target_float_format_length (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n       case TYPE_CODE_FLT:\n \treturn floatformat_totalsize_bytes (floatformat_from_type (type));\n@@ -2205,7 +2205,7 @@ enum target_float_ops_kind\n static enum target_float_ops_kind\n get_target_float_ops_kind (const struct type *type)\n {\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n       case TYPE_CODE_FLT:\n         {\n@@ -2300,7 +2300,7 @@ get_target_float_ops (const struct type *type)\n static const target_float_ops *\n get_target_float_ops (const struct type *type1, const struct type *type2)\n {\n-  gdb_assert (TYPE_CODE (type1) == TYPE_CODE (type2));\n+  gdb_assert (type1->code () == type2->code ());\n \n   enum target_float_ops_kind kind1 = get_target_float_ops_kind (type1);\n   enum target_float_ops_kind kind2 = get_target_float_ops_kind (type2);\n@@ -2315,10 +2315,10 @@ get_target_float_ops (const struct type *type1, const struct type *type2)\n bool\n target_float_is_valid (const gdb_byte *addr, const struct type *type)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (type->code () == TYPE_CODE_FLT)\n     return floatformat_is_valid (floatformat_from_type (type), addr);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT)\n+  if (type->code () == TYPE_CODE_DECFLOAT)\n     return true;\n \n   gdb_assert_not_reached (\"unexpected type code\");\n@@ -2329,11 +2329,11 @@ target_float_is_valid (const gdb_byte *addr, const struct type *type)\n bool\n target_float_is_zero (const gdb_byte *addr, const struct type *type)\n {\n-  if (TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (type->code () == TYPE_CODE_FLT)\n     return (floatformat_classify (floatformat_from_type (type), addr)\n \t    == float_zero);\n \n-  if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT)\n+  if (type->code () == TYPE_CODE_DECFLOAT)\n     return decimal_is_zero (addr, type);\n \n   gdb_assert_not_reached (\"unexpected type code\");\n@@ -2347,7 +2347,7 @@ target_float_to_string (const gdb_byte *addr, const struct type *type,\n {\n   /* Unless we need to adhere to a specific format, provide special\n      output for special cases of binary floating-point numbers.  */\n-  if (format == nullptr && TYPE_CODE (type) == TYPE_CODE_FLT)\n+  if (format == nullptr && type->code () == TYPE_CODE_FLT)\n     {\n       const struct floatformat *fmt = floatformat_from_type (type);\n "
    },
    {
      "sha": "eb9701548ce7b66c0f58d59ffdcdf55c3c33a0eb",
      "filename": "gdb/tic6x-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/tic6x-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/tic6x-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tic6x-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -808,7 +808,7 @@ static int\n tic6x_arg_type_alignment (struct type *type)\n {\n   int len = TYPE_LENGTH (check_typedef (type));\n-  enum type_code typecode = TYPE_CODE (check_typedef (type));\n+  enum type_code typecode = check_typedef (type)->code ();\n \n   if (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)\n     {\n@@ -881,11 +881,11 @@ tic6x_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n   /* Determine the type of this function.  */\n   func_type = check_typedef (func_type);\n-  if (TYPE_CODE (func_type) == TYPE_CODE_PTR)\n+  if (func_type->code () == TYPE_CODE_PTR)\n     func_type = check_typedef (TYPE_TARGET_TYPE (func_type));\n \n-  gdb_assert (TYPE_CODE (func_type) == TYPE_CODE_FUNC\n-\t      || TYPE_CODE (func_type) == TYPE_CODE_METHOD);\n+  gdb_assert (func_type->code () == TYPE_CODE_FUNC\n+\t      || func_type->code () == TYPE_CODE_METHOD);\n \n   /* For a variadic C function, the last explicitly declared argument and all\n      remaining arguments are passed on the stack.  */\n@@ -915,7 +915,7 @@ tic6x_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n-      enum type_code typecode = TYPE_CODE (arg_type);\n+      enum type_code typecode = arg_type->code ();\n \n       val = value_contents (arg);\n "
    },
    {
      "sha": "4e46d098c735e3d4a6fa9fd82caac47ac6dd46ac",
      "filename": "gdb/tilegx-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/tilegx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/tilegx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tilegx-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -188,9 +188,9 @@ tilegx_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int num)\n static int\n tilegx_type_is_scalar (struct type *t)\n {\n-  return (TYPE_CODE(t) != TYPE_CODE_STRUCT\n-\t  && TYPE_CODE(t) != TYPE_CODE_UNION\n-\t  && TYPE_CODE(t) != TYPE_CODE_ARRAY);\n+  return (t->code () != TYPE_CODE_STRUCT\n+\t  && t->code () != TYPE_CODE_UNION\n+\t  && t->code () != TYPE_CODE_ARRAY);\n }\n \n /* Returns non-zero if the given struct type will be returned using"
    },
    {
      "sha": "2e0f0df9ff4cca2f5810113a9e989614987fa34a",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -942,7 +942,7 @@ collection_list::collect_symbol (struct symbol *sym,\n \t}\n       /* A struct may be a C++ class with static fields, go to general\n \t expression handling.  */\n-      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_STRUCT)\n+      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_STRUCT)\n \ttreat_as_expr = 1;\n       else\n \tadd_memrange (gdbarch, memrange_absolute, offset, len, scope);\n@@ -954,7 +954,7 @@ collection_list::collect_symbol (struct symbol *sym,\n       add_local_register (gdbarch, reg, scope);\n       /* Check for doubles stored in two registers.  */\n       /* FIXME: how about larger types stored in 3 or more regs?  */\n-      if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_FLT &&\n+      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_FLT &&\n \t  len > register_size (gdbarch, reg))\n \tadd_local_register (gdbarch, reg + 1, scope);\n       break;"
    },
    {
      "sha": "e5009ea3800167af48ec4b11415201c88907848a",
      "filename": "gdb/typeprint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/typeprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -117,7 +117,7 @@ print_offset_data::update (struct type *type, unsigned int field_idx,\n     }\n \n   struct type *ftype = check_typedef (TYPE_FIELD_TYPE (type, field_idx));\n-  if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if (type->code () == TYPE_CODE_UNION)\n     {\n       /* Since union fields don't have the concept of offsets, we just\n \t print their sizes.  */\n@@ -515,7 +515,7 @@ whatis_exp (const char *exp, int show)\n \t     Use check_typedef to resolve stubs, but ignore its result\n \t     because we do not want to dig past all typedefs.  */\n \t  check_typedef (type);\n-\t  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)\n+\t  if (type->code () == TYPE_CODE_TYPEDEF)\n \t    type = TYPE_TARGET_TYPE (type);\n \n \t  /* If the expression is actually a type, then there's no\n@@ -540,16 +540,16 @@ whatis_exp (const char *exp, int show)\n   get_user_print_options (&opts);\n   if (val != NULL && opts.objectprint)\n     {\n-      if (((TYPE_CODE (type) == TYPE_CODE_PTR) || TYPE_IS_REFERENCE (type))\n-\t  && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_STRUCT))\n+      if (((type->code () == TYPE_CODE_PTR) || TYPE_IS_REFERENCE (type))\n+\t  && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_STRUCT))\n         real_type = value_rtti_indirect_type (val, &full, &top, &using_enc);\n-      else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n+      else if (type->code () == TYPE_CODE_STRUCT)\n \treal_type = value_rtti_type (val, &full, &top, &using_enc);\n     }\n \n   if (flags.print_offsets\n-      && (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t  || TYPE_CODE (type) == TYPE_CODE_UNION))\n+      && (type->code () == TYPE_CODE_STRUCT\n+\t  || type->code () == TYPE_CODE_UNION))\n     fprintf_filtered (gdb_stdout, \"/* offset    |  size */  \");\n \n   printf_filtered (\"type = \");\n@@ -615,7 +615,7 @@ print_type_scalar (struct type *type, LONGEST val, struct ui_file *stream)\n \n   type = check_typedef (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n \n     case TYPE_CODE_ENUM:"
    },
    {
      "sha": "1e0fd41a532b1ea9b8fc498285b426b90285398a",
      "filename": "gdb/v850-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/v850-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/v850-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/v850-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -498,9 +498,9 @@ v850_register_type (struct gdbarch *gdbarch, int regnum)\n static int\n v850_type_is_scalar (struct type *t)\n {\n-  return (TYPE_CODE (t) != TYPE_CODE_STRUCT\n-\t  && TYPE_CODE (t) != TYPE_CODE_UNION\n-\t  && TYPE_CODE (t) != TYPE_CODE_ARRAY);\n+  return (t->code () != TYPE_CODE_STRUCT\n+\t  && t->code () != TYPE_CODE_UNION\n+\t  && t->code () != TYPE_CODE_ARRAY);\n }\n \n /* Should call_function allocate stack space for a struct return?  */\n@@ -530,15 +530,15 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n   /* The value is a structure or union with a single element and that\n      element is either a single basic type or an array of a single basic\n      type whose size is greater than or equal to 4 -> returned in register.  */\n-  if ((TYPE_CODE (type) == TYPE_CODE_STRUCT\n-       || TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if ((type->code () == TYPE_CODE_STRUCT\n+       || type->code () == TYPE_CODE_UNION)\n        && TYPE_NFIELDS (type) == 1)\n     {\n       fld_type = TYPE_FIELD_TYPE (type, 0);\n       if (v850_type_is_scalar (fld_type) && TYPE_LENGTH (fld_type) >= 4)\n \treturn 0;\n \n-      if (TYPE_CODE (fld_type) == TYPE_CODE_ARRAY)\n+      if (fld_type->code () == TYPE_CODE_ARRAY)\n         {\n \t  tgt_type = TYPE_TARGET_TYPE (fld_type);\n \t  if (v850_type_is_scalar (tgt_type) && TYPE_LENGTH (tgt_type) >= 4)\n@@ -549,14 +549,14 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n   /* The value is a structure whose first element is an integer or a float,\n      and which contains no arrays of more than two elements -> returned in\n      register.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n+  if (type->code () == TYPE_CODE_STRUCT\n       && v850_type_is_scalar (TYPE_FIELD_TYPE (type, 0))\n       && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)\n     {\n       for (i = 1; i < TYPE_NFIELDS (type); ++i)\n         {\n \t  fld_type = TYPE_FIELD_TYPE (type, 0);\n-\t  if (TYPE_CODE (fld_type) == TYPE_CODE_ARRAY)\n+\t  if (fld_type->code () == TYPE_CODE_ARRAY)\n \t    {\n \t      tgt_type = TYPE_TARGET_TYPE (fld_type);\n \t      if (TYPE_LENGTH (tgt_type) > 0\n@@ -570,7 +570,7 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n   /* The value is a union which contains at least one field which\n      would be returned in registers according to these rules ->\n      returned in register.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_UNION)\n+  if (type->code () == TYPE_CODE_UNION)\n     {\n       for (i = 0; i < TYPE_NFIELDS (type); ++i)\n         {"
    },
    {
      "sha": "f1e1d6e9cce19c175e46f3c25a97caf316d17632",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 60,
      "deletions": 60,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -48,13 +48,13 @@ find_size_for_pointer_math (struct type *ptr_type)\n   LONGEST sz = -1;\n   struct type *ptr_target;\n \n-  gdb_assert (TYPE_CODE (ptr_type) == TYPE_CODE_PTR);\n+  gdb_assert (ptr_type->code () == TYPE_CODE_PTR);\n   ptr_target = check_typedef (TYPE_TARGET_TYPE (ptr_type));\n \n   sz = type_length_units (ptr_target);\n   if (sz == 0)\n     {\n-      if (TYPE_CODE (ptr_type) == TYPE_CODE_VOID)\n+      if (ptr_type->code () == TYPE_CODE_VOID)\n \tsz = 1;\n       else\n \t{\n@@ -107,8 +107,8 @@ value_ptrdiff (struct value *arg1, struct value *arg2)\n   type1 = check_typedef (value_type (arg1));\n   type2 = check_typedef (value_type (arg2));\n \n-  gdb_assert (TYPE_CODE (type1) == TYPE_CODE_PTR);\n-  gdb_assert (TYPE_CODE (type2) == TYPE_CODE_PTR);\n+  gdb_assert (type1->code () == TYPE_CODE_PTR);\n+  gdb_assert (type2->code () == TYPE_CODE_PTR);\n \n   if (TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type1)))\n       != TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type2))))\n@@ -146,8 +146,8 @@ value_subscript (struct value *array, LONGEST index)\n   array = coerce_ref (array);\n   tarray = check_typedef (value_type (array));\n \n-  if (TYPE_CODE (tarray) == TYPE_CODE_ARRAY\n-      || TYPE_CODE (tarray) == TYPE_CODE_STRING)\n+  if (tarray->code () == TYPE_CODE_ARRAY\n+      || tarray->code () == TYPE_CODE_STRING)\n     {\n       struct type *range_type = TYPE_INDEX_TYPE (tarray);\n       LONGEST lowerbound, upperbound;\n@@ -248,8 +248,8 @@ binop_types_user_defined_p (enum exp_opcode op,\n   if (TYPE_IS_REFERENCE (type2))\n     type2 = check_typedef (TYPE_TARGET_TYPE (type2));\n \n-  return (TYPE_CODE (type1) == TYPE_CODE_STRUCT\n-\t  || TYPE_CODE (type2) == TYPE_CODE_STRUCT);\n+  return (type1->code () == TYPE_CODE_STRUCT\n+\t  || type2->code () == TYPE_CODE_STRUCT);\n }\n \n /* Check to see if either argument is a structure, or a reference to\n@@ -281,7 +281,7 @@ unop_user_defined_p (enum exp_opcode op, struct value *arg1)\n   type1 = check_typedef (value_type (arg1));\n   if (TYPE_IS_REFERENCE (type1))\n     type1 = check_typedef (TYPE_TARGET_TYPE (type1));\n-  return TYPE_CODE (type1) == TYPE_CODE_STRUCT;\n+  return type1->code () == TYPE_CODE_STRUCT;\n }\n \n /* Try to find an operator named OPERATOR which takes NARGS arguments\n@@ -364,7 +364,7 @@ value_x_binop (struct value *arg1, struct value *arg2, enum exp_opcode op,\n   /* now we know that what we have to do is construct our\n      arg vector and find the right function to call it with.  */\n \n-  if (TYPE_CODE (check_typedef (value_type (arg1))) != TYPE_CODE_STRUCT)\n+  if (check_typedef (value_type (arg1))->code () != TYPE_CODE_STRUCT)\n     error (_(\"Can't do that binary op on that type\"));\t/* FIXME be explicit */\n \n   value *argvec_storage[3];\n@@ -491,7 +491,7 @@ value_x_binop (struct value *arg1, struct value *arg2, enum exp_opcode op,\n \t  argvec[1] = argvec[0];\n \t  argvec = argvec.slice (1);\n \t}\n-      if (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_XMETHOD)\n+      if (value_type (argvec[0])->code () == TYPE_CODE_XMETHOD)\n \t{\n \t  /* Static xmethods are not supported yet.  */\n \t  gdb_assert (static_memfuncp == 0);\n@@ -540,7 +540,7 @@ value_x_unop (struct value *arg1, enum exp_opcode op, enum noside noside)\n   /* now we know that what we have to do is construct our\n      arg vector and find the right function to call it with.  */\n \n-  if (TYPE_CODE (check_typedef (value_type (arg1))) != TYPE_CODE_STRUCT)\n+  if (check_typedef (value_type (arg1))->code () != TYPE_CODE_STRUCT)\n     error (_(\"Can't do that unary op on that type\"));\t/* FIXME be explicit */\n \n   value *argvec_storage[3];\n@@ -605,7 +605,7 @@ value_x_unop (struct value *arg1, enum exp_opcode op, enum noside noside)\n \t  argvec[1] = argvec[0];\n \t  argvec = argvec.slice (1);\n \t}\n-      if (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_XMETHOD)\n+      if (value_type (argvec[0])->code () == TYPE_CODE_XMETHOD)\n \t{\n \t  /* Static xmethods are not supported yet.  */\n \t  gdb_assert (static_memfuncp == 0);\n@@ -675,7 +675,7 @@ value_concat (struct value *arg1, struct value *arg2)\n      to the second of the two concatenated values or the value to be \n      repeated.  */\n \n-  if (TYPE_CODE (type2) == TYPE_CODE_INT)\n+  if (type2->code () == TYPE_CODE_INT)\n     {\n       struct type *tmp = type1;\n \n@@ -692,17 +692,17 @@ value_concat (struct value *arg1, struct value *arg2)\n \n   /* Now process the input values.  */\n \n-  if (TYPE_CODE (type1) == TYPE_CODE_INT)\n+  if (type1->code () == TYPE_CODE_INT)\n     {\n       /* We have a repeat count.  Validate the second value and then\n          construct a value repeated that many times.  */\n-      if (TYPE_CODE (type2) == TYPE_CODE_STRING\n-\t  || TYPE_CODE (type2) == TYPE_CODE_CHAR)\n+      if (type2->code () == TYPE_CODE_STRING\n+\t  || type2->code () == TYPE_CODE_CHAR)\n \t{\n \t  count = longest_to_int (value_as_long (inval1));\n \t  inval2len = TYPE_LENGTH (type2);\n \t  std::vector<char> ptr (count * inval2len);\n-\t  if (TYPE_CODE (type2) == TYPE_CODE_CHAR)\n+\t  if (type2->code () == TYPE_CODE_CHAR)\n \t    {\n \t      char_type = type2;\n \n@@ -725,7 +725,7 @@ value_concat (struct value *arg1, struct value *arg2)\n \t    }\n \t  outval = value_string (ptr.data (), count * inval2len, char_type);\n \t}\n-      else if (TYPE_CODE (type2) == TYPE_CODE_BOOL)\n+      else if (type2->code () == TYPE_CODE_BOOL)\n \t{\n \t  error (_(\"unimplemented support for boolean repeats\"));\n \t}\n@@ -734,19 +734,19 @@ value_concat (struct value *arg1, struct value *arg2)\n \t  error (_(\"can't repeat values of that type\"));\n \t}\n     }\n-  else if (TYPE_CODE (type1) == TYPE_CODE_STRING\n-\t   || TYPE_CODE (type1) == TYPE_CODE_CHAR)\n+  else if (type1->code () == TYPE_CODE_STRING\n+\t   || type1->code () == TYPE_CODE_CHAR)\n     {\n       /* We have two character strings to concatenate.  */\n-      if (TYPE_CODE (type2) != TYPE_CODE_STRING\n-\t  && TYPE_CODE (type2) != TYPE_CODE_CHAR)\n+      if (type2->code () != TYPE_CODE_STRING\n+\t  && type2->code () != TYPE_CODE_CHAR)\n \t{\n \t  error (_(\"Strings can only be concatenated with other strings.\"));\n \t}\n       inval1len = TYPE_LENGTH (type1);\n       inval2len = TYPE_LENGTH (type2);\n       std::vector<char> ptr (inval1len + inval2len);\n-      if (TYPE_CODE (type1) == TYPE_CODE_CHAR)\n+      if (type1->code () == TYPE_CODE_CHAR)\n \t{\n \t  char_type = type1;\n \n@@ -758,7 +758,7 @@ value_concat (struct value *arg1, struct value *arg2)\n \n \t  memcpy (ptr.data (), value_contents (inval1), inval1len);\n \t}\n-      if (TYPE_CODE (type2) == TYPE_CODE_CHAR)\n+      if (type2->code () == TYPE_CODE_CHAR)\n \t{\n \t  ptr[inval1len] =\n \t    (char) unpack_long (type2, value_contents (inval2));\n@@ -769,10 +769,10 @@ value_concat (struct value *arg1, struct value *arg2)\n \t}\n       outval = value_string (ptr.data (), inval1len + inval2len, char_type);\n     }\n-  else if (TYPE_CODE (type1) == TYPE_CODE_BOOL)\n+  else if (type1->code () == TYPE_CODE_BOOL)\n     {\n       /* We have two bitstrings to concatenate.  */\n-      if (TYPE_CODE (type2) != TYPE_CODE_BOOL)\n+      if (type2->code () != TYPE_CODE_BOOL)\n \t{\n \t  error (_(\"Booleans can only be concatenated \"\n \t\t   \"with other bitstrings or booleans.\"));\n@@ -865,7 +865,7 @@ value_args_as_target_float (struct value *arg1, struct value *arg2,\n   gdb_assert (is_floating_type (type1) || is_floating_type (type2));\n \n   if (is_floating_type (type1) && is_floating_type (type2)\n-      && TYPE_CODE (type1) != TYPE_CODE (type2))\n+      && type1->code () != type2->code ())\n     /* The DFP extension to the C language does not allow mixing of\n      * decimal float types with other float types in expressions\n      * (see WDTR 24732, page 12).  */\n@@ -962,7 +962,7 @@ complex_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n   struct type *arg2_type = check_typedef (value_type (arg2));\n \n   struct value *arg1_real, *arg1_imag, *arg2_real, *arg2_imag;\n-  if (TYPE_CODE (arg1_type) == TYPE_CODE_COMPLEX)\n+  if (arg1_type->code () == TYPE_CODE_COMPLEX)\n     {\n       arg1_real = value_real_part (arg1);\n       arg1_imag = value_imaginary_part (arg1);\n@@ -972,7 +972,7 @@ complex_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n       arg1_real = arg1;\n       arg1_imag = value_zero (arg1_type, not_lval);\n     }\n-  if (TYPE_CODE (arg2_type) == TYPE_CODE_COMPLEX)\n+  if (arg2_type->code () == TYPE_CODE_COMPLEX)\n     {\n       arg2_real = value_real_part (arg2);\n       arg2_imag = value_imaginary_part (arg2);\n@@ -1015,7 +1015,7 @@ complex_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n \n     case BINOP_DIV:\n       {\n-\tif (TYPE_CODE (arg2_type) == TYPE_CODE_COMPLEX)\n+\tif (arg2_type->code () == TYPE_CODE_COMPLEX)\n \t  {\n \t    struct value *conjugate = value_complement (arg2);\n \t    /* We have to reconstruct ARG1, in case the type was\n@@ -1080,8 +1080,8 @@ scalar_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n   type1 = check_typedef (value_type (arg1));\n   type2 = check_typedef (value_type (arg2));\n \n-  if (TYPE_CODE (type1) == TYPE_CODE_COMPLEX\n-      || TYPE_CODE (type2) == TYPE_CODE_COMPLEX)\n+  if (type1->code () == TYPE_CODE_COMPLEX\n+      || type2->code () == TYPE_CODE_COMPLEX)\n     return complex_binop (arg1, arg2, op);\n \n   if ((!is_floating_value (arg1) && !is_integral_type (type1))\n@@ -1105,8 +1105,8 @@ scalar_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n \t\t\t      v2.data (), eff_type_v2,\n \t\t\t      value_contents_raw (val), result_type);\n     }\n-  else if (TYPE_CODE (type1) == TYPE_CODE_BOOL\n-\t   || TYPE_CODE (type2) == TYPE_CODE_BOOL)\n+  else if (type1->code () == TYPE_CODE_BOOL\n+\t   || type2->code () == TYPE_CODE_BOOL)\n     {\n       LONGEST v1, v2, v = 0;\n \n@@ -1438,7 +1438,7 @@ value_vector_widen (struct value *scalar_value, struct type *vector_type)\n \n   vector_type = check_typedef (vector_type);\n \n-  gdb_assert (TYPE_CODE (vector_type) == TYPE_CODE_ARRAY\n+  gdb_assert (vector_type->code () == TYPE_CODE_ARRAY\n \t      && TYPE_VECTOR (vector_type));\n \n   if (!get_array_bounds (vector_type, &low_bound, &high_bound))\n@@ -1478,9 +1478,9 @@ vector_binop (struct value *val1, struct value *val2, enum exp_opcode op)\n   type1 = check_typedef (value_type (val1));\n   type2 = check_typedef (value_type (val2));\n \n-  t1_is_vec = (TYPE_CODE (type1) == TYPE_CODE_ARRAY\n+  t1_is_vec = (type1->code () == TYPE_CODE_ARRAY\n \t       && TYPE_VECTOR (type1)) ? 1 : 0;\n-  t2_is_vec = (TYPE_CODE (type2) == TYPE_CODE_ARRAY\n+  t2_is_vec = (type2->code () == TYPE_CODE_ARRAY\n \t       && TYPE_VECTOR (type2)) ? 1 : 0;\n \n   if (!t1_is_vec || !t2_is_vec)\n@@ -1494,7 +1494,7 @@ vector_binop (struct value *val1, struct value *val2, enum exp_opcode op)\n   eltype2 = check_typedef (TYPE_TARGET_TYPE (type2));\n   elsize = TYPE_LENGTH (eltype1);\n \n-  if (TYPE_CODE (eltype1) != TYPE_CODE (eltype2)\n+  if (eltype1->code () != eltype2->code ()\n       || elsize != TYPE_LENGTH (eltype2)\n       || TYPE_UNSIGNED (eltype1) != TYPE_UNSIGNED (eltype2)\n       || low_bound1 != low_bound2 || high_bound1 != high_bound2)\n@@ -1523,9 +1523,9 @@ value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n   struct value *val;\n   struct type *type1 = check_typedef (value_type (arg1));\n   struct type *type2 = check_typedef (value_type (arg2));\n-  int t1_is_vec = (TYPE_CODE (type1) == TYPE_CODE_ARRAY\n+  int t1_is_vec = (type1->code () == TYPE_CODE_ARRAY\n \t\t   && TYPE_VECTOR (type1));\n-  int t2_is_vec = (TYPE_CODE (type2) == TYPE_CODE_ARRAY\n+  int t2_is_vec = (type2->code () == TYPE_CODE_ARRAY\n \t\t   && TYPE_VECTOR (type2));\n \n   if (!t1_is_vec && !t2_is_vec)\n@@ -1538,8 +1538,8 @@ value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n       struct value **v = t1_is_vec ? &arg2 : &arg1;\n       struct type *t = t1_is_vec ? type2 : type1;\n       \n-      if (TYPE_CODE (t) != TYPE_CODE_FLT\n-\t  && TYPE_CODE (t) != TYPE_CODE_DECFLOAT\n+      if (t->code () != TYPE_CODE_FLT\n+\t  && t->code () != TYPE_CODE_DECFLOAT\n \t  && !is_integral_type (t))\n \terror (_(\"Argument to operation not a number or boolean.\"));\n \n@@ -1628,8 +1628,8 @@ value_equal (struct value *arg1, struct value *arg2)\n \n   type1 = check_typedef (value_type (arg1));\n   type2 = check_typedef (value_type (arg2));\n-  code1 = TYPE_CODE (type1);\n-  code2 = TYPE_CODE (type2);\n+  code1 = type1->code ();\n+  code2 = type2->code ();\n   is_int1 = is_integral_type (type1);\n   is_int2 = is_integral_type (type2);\n \n@@ -1692,7 +1692,7 @@ value_equal_contents (struct value *arg1, struct value *arg2)\n   type1 = check_typedef (value_type (arg1));\n   type2 = check_typedef (value_type (arg2));\n \n-  return (TYPE_CODE (type1) == TYPE_CODE (type2)\n+  return (type1->code () == type2->code ()\n \t  && TYPE_LENGTH (type1) == TYPE_LENGTH (type2)\n \t  && memcmp (value_contents (arg1), value_contents (arg2),\n \t\t     TYPE_LENGTH (type1)) == 0);\n@@ -1714,8 +1714,8 @@ value_less (struct value *arg1, struct value *arg2)\n \n   type1 = check_typedef (value_type (arg1));\n   type2 = check_typedef (value_type (arg2));\n-  code1 = TYPE_CODE (type1);\n-  code2 = TYPE_CODE (type2);\n+  code1 = type1->code ();\n+  code2 = type2->code ();\n   is_int1 = is_integral_type (type1);\n   is_int2 = is_integral_type (type2);\n \n@@ -1766,8 +1766,8 @@ value_pos (struct value *arg1)\n   type = check_typedef (value_type (arg1));\n \n   if (is_integral_type (type) || is_floating_value (arg1)\n-      || (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n-      || TYPE_CODE (type) == TYPE_CODE_COMPLEX)\n+      || (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+      || type->code () == TYPE_CODE_COMPLEX)\n     return value_from_contents (type, value_contents (arg1));\n   else\n     error (_(\"Argument to positive operation not a number.\"));\n@@ -1783,7 +1783,7 @@ value_neg (struct value *arg1)\n \n   if (is_integral_type (type) || is_floating_type (type))\n     return value_binop (value_from_longest (type, 0), arg1, BINOP_SUB);\n-  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n     {\n       struct value *tmp, *val = allocate_value (type);\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));\n@@ -1801,7 +1801,7 @@ value_neg (struct value *arg1)\n \t}\n       return val;\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_COMPLEX)\n+  else if (type->code () == TYPE_CODE_COMPLEX)\n     {\n       struct value *real = value_real_part (arg1);\n       struct value *imag = value_imaginary_part (arg1);\n@@ -1825,7 +1825,7 @@ value_complement (struct value *arg1)\n \n   if (is_integral_type (type))\n     val = value_from_longest (type, ~value_as_long (arg1));\n-  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n     {\n       struct value *tmp;\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));\n@@ -1843,7 +1843,7 @@ value_complement (struct value *arg1)\n                   value_contents_all (tmp), TYPE_LENGTH (eltype));\n         }\n     }\n-  else if (TYPE_CODE (type) == TYPE_CODE_COMPLEX)\n+  else if (type->code () == TYPE_CODE_COMPLEX)\n     {\n       /* GCC has an extension that treats ~complex as the complex\n \t conjugate.  */\n@@ -1892,14 +1892,14 @@ value_in (struct value *element, struct value *set)\n   struct type *settype = check_typedef (value_type (set));\n   struct type *eltype = check_typedef (value_type (element));\n \n-  if (TYPE_CODE (eltype) == TYPE_CODE_RANGE)\n+  if (eltype->code () == TYPE_CODE_RANGE)\n     eltype = TYPE_TARGET_TYPE (eltype);\n-  if (TYPE_CODE (settype) != TYPE_CODE_SET)\n+  if (settype->code () != TYPE_CODE_SET)\n     error (_(\"Second argument of 'IN' has wrong type\"));\n-  if (TYPE_CODE (eltype) != TYPE_CODE_INT\n-      && TYPE_CODE (eltype) != TYPE_CODE_CHAR\n-      && TYPE_CODE (eltype) != TYPE_CODE_ENUM\n-      && TYPE_CODE (eltype) != TYPE_CODE_BOOL)\n+  if (eltype->code () != TYPE_CODE_INT\n+      && eltype->code () != TYPE_CODE_CHAR\n+      && eltype->code () != TYPE_CODE_ENUM\n+      && eltype->code () != TYPE_CODE_BOOL)\n     error (_(\"First argument of 'IN' has wrong type\"));\n   member = value_bit_index (settype, value_contents (set),\n \t\t\t    value_as_long (element));"
    },
    {
      "sha": "5e294823ffd494c09e5727bdbe1d71dee9a5dd69",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 92,
      "deletions": 92,
      "changes": 184,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -215,11 +215,11 @@ value_cast_structs (struct type *type, struct value *v2)\n   t2 = check_typedef (value_type (v2));\n \n   /* Check preconditions.  */\n-  gdb_assert ((TYPE_CODE (t1) == TYPE_CODE_STRUCT\n-\t       || TYPE_CODE (t1) == TYPE_CODE_UNION)\n+  gdb_assert ((t1->code () == TYPE_CODE_STRUCT\n+\t       || t1->code () == TYPE_CODE_UNION)\n \t      && !!\"Precondition is that type is of STRUCT or UNION kind.\");\n-  gdb_assert ((TYPE_CODE (t2) == TYPE_CODE_STRUCT\n-\t       || TYPE_CODE (t2) == TYPE_CODE_UNION)\n+  gdb_assert ((t2->code () == TYPE_CODE_STRUCT\n+\t       || t2->code () == TYPE_CODE_UNION)\n \t      && !!\"Precondition is that value is of STRUCT or UNION kind\");\n \n   if (TYPE_NAME (t1) != NULL\n@@ -300,8 +300,8 @@ value_cast_pointers (struct type *type, struct value *arg2,\n   struct type *t1 = check_typedef (TYPE_TARGET_TYPE (type1));\n   struct type *t2 = check_typedef (TYPE_TARGET_TYPE (type2));\n \n-  if (TYPE_CODE (t1) == TYPE_CODE_STRUCT\n-      && TYPE_CODE (t2) == TYPE_CODE_STRUCT\n+  if (t1->code () == TYPE_CODE_STRUCT\n+      && t2->code () == TYPE_CODE_STRUCT\n       && (subclass_check || !value_logical_not (arg2)))\n     {\n       struct value *v2;\n@@ -310,7 +310,7 @@ value_cast_pointers (struct type *type, struct value *arg2,\n \tv2 = coerce_ref (arg2);\n       else\n \tv2 = value_ind (arg2);\n-      gdb_assert (TYPE_CODE (check_typedef (value_type (v2)))\n+      gdb_assert (check_typedef (value_type (v2))->code ()\n \t\t  == TYPE_CODE_STRUCT && !!\"Why did coercion fail?\");\n       v2 = value_cast_structs (t1, v2);\n       /* At this point we have what we can have, un-dereference if needed.  */\n@@ -359,7 +359,7 @@ value_cast (struct type *type, struct value *arg2)\n       struct type *dereftype = check_typedef (TYPE_TARGET_TYPE (t1));\n       struct value *val = value_cast (dereftype, arg2);\n \n-      return value_ref (val, TYPE_CODE (t1));\n+      return value_ref (val, t1->code ());\n     }\n \n   if (TYPE_IS_REFERENCE (check_typedef (value_type (arg2))))\n@@ -372,7 +372,7 @@ value_cast (struct type *type, struct value *arg2)\n   struct type *to_type = type;\n \n   type = check_typedef (type);\n-  code1 = TYPE_CODE (type);\n+  code1 = type->code ();\n   arg2 = coerce_ref (arg2);\n   type2 = check_typedef (value_type (arg2));\n \n@@ -415,15 +415,15 @@ value_cast (struct type *type, struct value *arg2)\n     }\n \n   if (current_language->c_style_arrays\n-      && TYPE_CODE (type2) == TYPE_CODE_ARRAY\n+      && type2->code () == TYPE_CODE_ARRAY\n       && !TYPE_VECTOR (type2))\n     arg2 = value_coerce_array (arg2);\n \n-  if (TYPE_CODE (type2) == TYPE_CODE_FUNC)\n+  if (type2->code () == TYPE_CODE_FUNC)\n     arg2 = value_coerce_function (arg2);\n \n   type2 = check_typedef (value_type (arg2));\n-  code2 = TYPE_CODE (type2);\n+  code2 = type2->code ();\n \n   if (code1 == TYPE_CODE_COMPLEX)\n     return cast_into_complex (to_type, arg2);\n@@ -590,8 +590,8 @@ value_reinterpret_cast (struct type *type, struct value *arg)\n \n   arg_type = value_type (arg);\n \n-  dest_code = TYPE_CODE (real_type);\n-  arg_code = TYPE_CODE (arg_type);\n+  dest_code = real_type->code ();\n+  arg_code = arg_type->code ();\n \n   /* We can convert pointer types, or any pointer type to int, or int\n      type to pointer.  */\n@@ -611,7 +611,7 @@ value_reinterpret_cast (struct type *type, struct value *arg)\n \n   if (is_ref)\n     result = value_cast (type, value_ref (value_ind (result),\n-                                          TYPE_CODE (type)));\n+                                          type->code ()));\n \n   return result;\n }\n@@ -722,24 +722,24 @@ value_dynamic_cast (struct type *type, struct value *arg)\n   CORE_ADDR addr;\n   int is_ref = TYPE_IS_REFERENCE (resolved_type);\n \n-  if (TYPE_CODE (resolved_type) != TYPE_CODE_PTR\n+  if (resolved_type->code () != TYPE_CODE_PTR\n       && !TYPE_IS_REFERENCE (resolved_type))\n     error (_(\"Argument to dynamic_cast must be a pointer or reference type\"));\n-  if (TYPE_CODE (TYPE_TARGET_TYPE (resolved_type)) != TYPE_CODE_VOID\n-      && TYPE_CODE (TYPE_TARGET_TYPE (resolved_type)) != TYPE_CODE_STRUCT)\n+  if (TYPE_TARGET_TYPE (resolved_type)->code () != TYPE_CODE_VOID\n+      && TYPE_TARGET_TYPE (resolved_type)->code () != TYPE_CODE_STRUCT)\n     error (_(\"Argument to dynamic_cast must be pointer to class or `void *'\"));\n \n   class_type = check_typedef (TYPE_TARGET_TYPE (resolved_type));\n-  if (TYPE_CODE (resolved_type) == TYPE_CODE_PTR)\n+  if (resolved_type->code () == TYPE_CODE_PTR)\n     {\n-      if (TYPE_CODE (arg_type) != TYPE_CODE_PTR\n-\t  && ! (TYPE_CODE (arg_type) == TYPE_CODE_INT\n+      if (arg_type->code () != TYPE_CODE_PTR\n+\t  && ! (arg_type->code () == TYPE_CODE_INT\n \t\t&& value_as_long (arg) == 0))\n \terror (_(\"Argument to dynamic_cast does not have pointer type\"));\n-      if (TYPE_CODE (arg_type) == TYPE_CODE_PTR)\n+      if (arg_type->code () == TYPE_CODE_PTR)\n \t{\n \t  arg_type = check_typedef (TYPE_TARGET_TYPE (arg_type));\n-\t  if (TYPE_CODE (arg_type) != TYPE_CODE_STRUCT)\n+\t  if (arg_type->code () != TYPE_CODE_STRUCT)\n \t    error (_(\"Argument to dynamic_cast does \"\n \t\t     \"not have pointer to class type\"));\n \t}\n@@ -752,7 +752,7 @@ value_dynamic_cast (struct type *type, struct value *arg)\n     }\n   else\n     {\n-      if (TYPE_CODE (arg_type) != TYPE_CODE_STRUCT)\n+      if (arg_type->code () != TYPE_CODE_STRUCT)\n \terror (_(\"Argument to dynamic_cast does not have class type\"));\n     }\n \n@@ -786,8 +786,8 @@ value_dynamic_cast (struct type *type, struct value *arg)\n \n   /* dynamic_cast<void *> means to return a pointer to the\n      most-derived object.  */\n-  if (TYPE_CODE (resolved_type) == TYPE_CODE_PTR\n-      && TYPE_CODE (TYPE_TARGET_TYPE (resolved_type)) == TYPE_CODE_VOID)\n+  if (resolved_type->code () == TYPE_CODE_PTR\n+      && TYPE_TARGET_TYPE (resolved_type)->code () == TYPE_CODE_VOID)\n     return value_at_lazy (type, addr);\n \n   tem = value_at (type, addr);\n@@ -808,7 +808,7 @@ value_dynamic_cast (struct type *type, struct value *arg)\n \t\t\t\t&result) == 1)\n \treturn value_cast (type,\n \t\t\t   is_ref\n-\t\t\t   ? value_ref (result, TYPE_CODE (resolved_type))\n+\t\t\t   ? value_ref (result, resolved_type->code ())\n \t\t\t   : value_addr (result));\n     }\n \n@@ -822,10 +822,10 @@ value_dynamic_cast (struct type *type, struct value *arg)\n \t\t\t       rtti_type, &result) == 1)\n     return value_cast (type,\n \t\t       is_ref\n-\t\t       ? value_ref (result, TYPE_CODE (resolved_type))\n+\t\t       ? value_ref (result, resolved_type->code ())\n \t\t       : value_addr (result));\n \n-  if (TYPE_CODE (resolved_type) == TYPE_CODE_PTR)\n+  if (resolved_type->code () == TYPE_CODE_PTR)\n     return value_zero (type, not_lval);\n \n   error (_(\"dynamic_cast failed\"));\n@@ -854,7 +854,7 @@ value_one (struct type *type)\n     {\n       val = value_from_longest (type, (LONGEST) 1);\n     }\n-  else if (TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n+  else if (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n     {\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type1));\n       int i;\n@@ -893,7 +893,7 @@ get_value_at (struct type *type, CORE_ADDR addr, int lazy)\n {\n   struct value *val;\n \n-  if (TYPE_CODE (check_typedef (type)) == TYPE_CODE_VOID)\n+  if (check_typedef (type)->code () == TYPE_CODE_VOID)\n     error (_(\"Attempt to dereference a generic pointer.\"));\n \n   val = value_from_contents_and_address (type, NULL, addr);\n@@ -1249,7 +1249,7 @@ value_assign (struct value *toval, struct value *fromval)\n      in the case of pointer types.  For object types, the enclosing type\n      and embedded offset must *not* be copied: the target object refered\n      to by TOVAL retains its original dynamic type after assignment.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  if (type->code () == TYPE_CODE_PTR)\n     {\n       set_value_enclosing_type (val, value_enclosing_type (fromval));\n       set_value_pointed_to_offset (val, value_pointed_to_offset (fromval));\n@@ -1306,7 +1306,7 @@ address_of_variable (struct symbol *var, const struct block *b)\n   type = value_type (val);\n \n   if ((VALUE_LVAL (val) == lval_memory && value_lazy (val))\n-      || TYPE_CODE (type) == TYPE_CODE_FUNC)\n+      || type->code () == TYPE_CODE_FUNC)\n     {\n       CORE_ADDR addr = value_address (val);\n \n@@ -1358,7 +1358,7 @@ value_must_coerce_to_target (struct value *val)\n \n   valtype = check_typedef (value_type (val));\n \n-  switch (TYPE_CODE (valtype))\n+  switch (valtype->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       return TYPE_VECTOR (valtype) ? 0 : 1;\n@@ -1478,7 +1478,7 @@ value_addr (struct value *arg1)\n \t  return arg2;\n \t}\n     }\n-  if (TYPE_CODE (type) == TYPE_CODE_FUNC)\n+  if (type->code () == TYPE_CODE_FUNC)\n     return value_coerce_function (arg1);\n \n   /* If this is an array that has not yet been pushed to the target,\n@@ -1514,9 +1514,9 @@ value_ref (struct value *arg1, enum type_code refcode)\n \n   gdb_assert (refcode == TYPE_CODE_REF || refcode == TYPE_CODE_RVALUE_REF);\n \n-  if ((TYPE_CODE (type) == TYPE_CODE_REF\n-       || TYPE_CODE (type) == TYPE_CODE_RVALUE_REF)\n-      && TYPE_CODE (type) == refcode)\n+  if ((type->code () == TYPE_CODE_REF\n+       || type->code () == TYPE_CODE_RVALUE_REF)\n+      && type->code () == refcode)\n     return arg1;\n \n   arg2 = value_addr (arg1);\n@@ -1550,7 +1550,7 @@ value_ind (struct value *arg1)\n \t}\n     }\n \n-  if (TYPE_CODE (base_type) == TYPE_CODE_PTR)\n+  if (base_type->code () == TYPE_CODE_PTR)\n     {\n       struct type *enc_type;\n \n@@ -1559,8 +1559,8 @@ value_ind (struct value *arg1)\n       enc_type = check_typedef (value_enclosing_type (arg1));\n       enc_type = TYPE_TARGET_TYPE (enc_type);\n \n-      if (TYPE_CODE (check_typedef (enc_type)) == TYPE_CODE_FUNC\n-\t  || TYPE_CODE (check_typedef (enc_type)) == TYPE_CODE_METHOD)\n+      if (check_typedef (enc_type)->code () == TYPE_CODE_FUNC\n+\t  || check_typedef (enc_type)->code () == TYPE_CODE_METHOD)\n \t/* For functions, go through find_function_addr, which knows\n \t   how to handle function descriptors.  */\n \targ2 = value_at_lazy (enc_type, \n@@ -1707,7 +1707,7 @@ typecmp (int staticp, int varargs, int nargs,\n     t2 ++;\n \n   for (i = 0;\n-       (i < nargs) && TYPE_CODE (t1[i].type) != TYPE_CODE_VOID;\n+       (i < nargs) && t1[i].type->code () != TYPE_CODE_VOID;\n        i++)\n     {\n       struct type *tt1, *tt2;\n@@ -1720,13 +1720,13 @@ typecmp (int staticp, int varargs, int nargs,\n \n       if (TYPE_IS_REFERENCE (tt1)\n \t  /* We should be doing hairy argument matching, as below.  */\n-\t  && (TYPE_CODE (check_typedef (TYPE_TARGET_TYPE (tt1)))\n-\t      == TYPE_CODE (tt2)))\n+\t  && (check_typedef (TYPE_TARGET_TYPE (tt1))->code ()\n+\t      == tt2->code ()))\n \t{\n-\t  if (TYPE_CODE (tt2) == TYPE_CODE_ARRAY)\n+\t  if (tt2->code () == TYPE_CODE_ARRAY)\n \t    t2[i] = value_coerce_array (t2[i]);\n \t  else\n-\t    t2[i] = value_ref (t2[i], TYPE_CODE (tt1));\n+\t    t2[i] = value_ref (t2[i], tt1->code ());\n \t  continue;\n \t}\n \n@@ -1736,25 +1736,25 @@ typecmp (int staticp, int varargs, int nargs,\n \t char *>, and properly access map[\"hello\"], because the\n \t argument to [] will be a reference to a pointer to a char,\n \t and the argument will be a pointer to a char.  */\n-      while (TYPE_IS_REFERENCE (tt1) || TYPE_CODE (tt1) == TYPE_CODE_PTR)\n+      while (TYPE_IS_REFERENCE (tt1) || tt1->code () == TYPE_CODE_PTR)\n \t{\n-\t  tt1 = check_typedef( TYPE_TARGET_TYPE(tt1) );\n+\t  tt1 = check_typedef ( TYPE_TARGET_TYPE (tt1) );\n \t}\n-      while (TYPE_CODE(tt2) == TYPE_CODE_ARRAY\n-\t     || TYPE_CODE(tt2) == TYPE_CODE_PTR\n+      while (tt2->code () == TYPE_CODE_ARRAY\n+\t     || tt2->code () == TYPE_CODE_PTR\n \t     || TYPE_IS_REFERENCE (tt2))\n \t{\n-\t  tt2 = check_typedef (TYPE_TARGET_TYPE(tt2));\n+\t  tt2 = check_typedef (TYPE_TARGET_TYPE (tt2));\n \t}\n-      if (TYPE_CODE (tt1) == TYPE_CODE (tt2))\n+      if (tt1->code () == tt2->code ())\n \tcontinue;\n       /* Array to pointer is a `trivial conversion' according to the\n \t ARM.  */\n \n       /* We should be doing much hairier argument matching (see\n          section 13.2 of the ARM), but as a quick kludge, just check\n          for the same type code.  */\n-      if (TYPE_CODE (t1[i].type) != TYPE_CODE (value_type (t2[i])))\n+      if (t1[i].type->code () != value_type (t2[i])->code ())\n \treturn i + 1;\n     }\n   if (varargs || t2[i] == NULL)\n@@ -1826,8 +1826,8 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n \t  {\n \t    struct type *field_type = TYPE_FIELD_TYPE (type, i);\n \n-\t    if (TYPE_CODE (field_type) == TYPE_CODE_UNION\n-\t\t|| TYPE_CODE (field_type) == TYPE_CODE_STRUCT)\n+\t    if (field_type->code () == TYPE_CODE_UNION\n+\t\t|| field_type->code () == TYPE_CODE_STRUCT)\n \t      {\n \t\t/* Look for a match through the fields of an anonymous\n \t\t   union, or anonymous struct.  C++ provides anonymous\n@@ -1850,7 +1850,7 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n \t\t   from GDB) implementation of variant records, the\n \t\t   bitpos is zero in an anonymous union field, so we\n \t\t   have to add the offset of the union here.  */\n-\t\tif (TYPE_CODE (field_type) == TYPE_CODE_STRUCT\n+\t\tif (field_type->code () == TYPE_CODE_STRUCT\n \t\t    || (TYPE_NFIELDS (field_type) > 0\n \t\t\t&& TYPE_FIELD_BITPOS (field_type, 0) == 0))\n \t\t  new_offset += TYPE_FIELD_BITPOS (type, i) / 8;\n@@ -2119,17 +2119,17 @@ value_struct_elt (struct value **argp, struct value **args,\n \n   /* Follow pointers until we get to a non-pointer.  */\n \n-  while (TYPE_CODE (t) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (t))\n+  while (t->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (t))\n     {\n       *argp = value_ind (*argp);\n       /* Don't coerce fn pointer to fn and then back again!  */\n-      if (TYPE_CODE (check_typedef (value_type (*argp))) != TYPE_CODE_FUNC)\n+      if (check_typedef (value_type (*argp))->code () != TYPE_CODE_FUNC)\n \t*argp = coerce_array (*argp);\n       t = check_typedef (value_type (*argp));\n     }\n \n-  if (TYPE_CODE (t) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (t) != TYPE_CODE_UNION)\n+  if (t->code () != TYPE_CODE_STRUCT\n+      && t->code () != TYPE_CODE_UNION)\n     error (_(\"Attempt to extract a component of a value that is not a %s.\"),\n \t   err);\n \n@@ -2206,16 +2206,16 @@ value_struct_elt_bitpos (struct value **argp, int bitpos, struct type *ftype,\n \n   t = check_typedef (value_type (*argp));\n \n-  while (TYPE_CODE (t) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (t))\n+  while (t->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (t))\n     {\n       *argp = value_ind (*argp);\n-      if (TYPE_CODE (check_typedef (value_type (*argp))) != TYPE_CODE_FUNC)\n+      if (check_typedef (value_type (*argp))->code () != TYPE_CODE_FUNC)\n \t*argp = coerce_array (*argp);\n       t = check_typedef (value_type (*argp));\n     }\n \n-  if (TYPE_CODE (t) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (t) != TYPE_CODE_UNION)\n+  if (t->code () != TYPE_CODE_STRUCT\n+      && t->code () != TYPE_CODE_UNION)\n     error (_(\"Attempt to extract a component of a value that is not a %s.\"),\n \t   err);\n \n@@ -2359,17 +2359,17 @@ value_find_oload_method_list (struct value **argp, const char *method,\n   t = check_typedef (value_type (*argp));\n \n   /* Code snarfed from value_struct_elt.  */\n-  while (TYPE_CODE (t) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (t))\n+  while (t->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (t))\n     {\n       *argp = value_ind (*argp);\n       /* Don't coerce fn pointer to fn and then back again!  */\n-      if (TYPE_CODE (check_typedef (value_type (*argp))) != TYPE_CODE_FUNC)\n+      if (check_typedef (value_type (*argp))->code () != TYPE_CODE_FUNC)\n \t*argp = coerce_array (*argp);\n       t = check_typedef (value_type (*argp));\n     }\n \n-  if (TYPE_CODE (t) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (t) != TYPE_CODE_UNION)\n+  if (t->code () != TYPE_CODE_STRUCT\n+      && t->code () != TYPE_CODE_UNION)\n     error (_(\"Attempt to extract a component of a \"\n \t     \"value that is not a struct or union\"));\n \n@@ -2477,13 +2477,13 @@ find_overload_match (gdb::array_view<value *> args,\n \n       /* OBJ may be a pointer value rather than the object itself.  */\n       obj = coerce_ref (obj);\n-      while (TYPE_CODE (check_typedef (value_type (obj))) == TYPE_CODE_PTR)\n+      while (check_typedef (value_type (obj))->code () == TYPE_CODE_PTR)\n \tobj = coerce_ref (value_ind (obj));\n       obj_type_name = TYPE_NAME (value_type (obj));\n \n       /* First check whether this is a data member, e.g. a pointer to\n \t a function.  */\n-      if (TYPE_CODE (check_typedef (value_type (obj))) == TYPE_CODE_STRUCT)\n+      if (check_typedef (value_type (obj))->code () == TYPE_CODE_STRUCT)\n \t{\n \t  *valp = search_struct_field (name, obj,\n \t\t\t\t       check_typedef (value_type (obj)), 0);\n@@ -2606,8 +2606,8 @@ find_overload_match (gdb::array_view<value *> args,\n \t     the function part.  Do not try this for non-functions (e.g.\n \t     function pointers).  */\n           if (qualified_name\n-              && TYPE_CODE (check_typedef (SYMBOL_TYPE (fsym)))\n-\t      == TYPE_CODE_FUNC)\n+              && (check_typedef (SYMBOL_TYPE (fsym))->code ()\n+\t\t  == TYPE_CODE_FUNC))\n             {\n \t      temp_func = cp_func_name (qualified_name);\n \n@@ -2752,8 +2752,8 @@ find_overload_match (gdb::array_view<value *> args,\n       struct type *temp_type = check_typedef (value_type (temp));\n       struct type *objtype = check_typedef (obj_type);\n \n-      if (TYPE_CODE (temp_type) != TYPE_CODE_PTR\n-\t  && (TYPE_CODE (objtype) == TYPE_CODE_PTR\n+      if (temp_type->code () != TYPE_CODE_PTR\n+\t  && (objtype->code () == TYPE_CODE_PTR\n \t      || TYPE_IS_REFERENCE (objtype)))\n \t{\n \t  temp = value_addr (temp);\n@@ -3118,7 +3118,7 @@ enum_constant_from_type (struct type *type, const char *name)\n   int i;\n   int name_len = strlen (name);\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_ENUM\n+  gdb_assert (type->code () == TYPE_CODE_ENUM\n \t      && TYPE_DECLARED_CLASS (type));\n \n   for (i = TYPE_N_BASECLASSES (type); i < TYPE_NFIELDS (type); ++i)\n@@ -3155,7 +3155,7 @@ value_aggregate_elt (struct type *curtype, const char *name,\n \t\t     struct type *expect_type, int want_address,\n \t\t     enum noside noside)\n {\n-  switch (TYPE_CODE (curtype))\n+  switch (curtype->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n@@ -3206,7 +3206,7 @@ compare_parameters (struct type *t1, struct type *t2, int skip_artificial)\n   /* Special case: a method taking void.  T1 will contain no\n      non-artificial fields, and T2 will contain TYPE_CODE_VOID.  */\n   if ((TYPE_NFIELDS (t1) - start) == 0 && TYPE_NFIELDS (t2) == 1\n-      && TYPE_CODE (TYPE_FIELD_TYPE (t2, 0)) == TYPE_CODE_VOID)\n+      && TYPE_FIELD_TYPE (t2, 0)->code () == TYPE_CODE_VOID)\n     return 1;\n \n   if ((TYPE_NFIELDS (t1) - start) == TYPE_NFIELDS (t2))\n@@ -3288,8 +3288,8 @@ value_struct_elt_for_reference (struct type *domain, int offset,\n   int i;\n   struct value *result;\n \n-  if (TYPE_CODE (t) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (t) != TYPE_CODE_UNION)\n+  if (t->code () != TYPE_CODE_STRUCT\n+      && t->code () != TYPE_CODE_UNION)\n     error (_(\"Internal error: non-aggregate type \"\n \t     \"to value_struct_elt_for_reference\"));\n \n@@ -3330,7 +3330,7 @@ value_struct_elt_for_reference (struct type *domain, int offset,\n \t\t  ptr = value_aggregate_elt (domain, name, NULL, 1, noside);\n \t\t  type = check_typedef (value_type (ptr));\n \t\t  gdb_assert (type != NULL\n-\t\t\t      && TYPE_CODE (type) == TYPE_CODE_MEMBERPTR);\n+\t\t\t      && type->code () == TYPE_CODE_MEMBERPTR);\n \t\t  tmp = lookup_pointer_type (TYPE_SELF_TYPE (type));\n \t\t  v = value_cast_pointers (tmp, v, 1);\n \t\t  mem_offset = value_as_long (ptr);\n@@ -3367,7 +3367,7 @@ value_struct_elt_for_reference (struct type *domain, int offset,\n      as a pointer to a method.  */\n \n   /* Perform all necessary dereferencing.  */\n-  while (intype && TYPE_CODE (intype) == TYPE_CODE_PTR)\n+  while (intype && intype->code () == TYPE_CODE_PTR)\n     intype = TYPE_TARGET_TYPE (intype);\n \n   for (i = TYPE_NFN_FIELDS (t) - 1; i >= 0; --i)\n@@ -3581,7 +3581,7 @@ value_rtti_indirect_type (struct value *v, int *full,\n   type = check_typedef (type);\n   if (TYPE_IS_REFERENCE (type))\n     target = coerce_ref (v);\n-  else if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+  else if (type->code () == TYPE_CODE_PTR)\n     {\n \n       try\n@@ -3612,8 +3612,8 @@ value_rtti_indirect_type (struct value *v, int *full,\n       real_type = make_cv_type (TYPE_CONST (target_type),\n \t\t\t\tTYPE_VOLATILE (target_type), real_type, NULL);\n       if (TYPE_IS_REFERENCE (type))\n-        real_type = lookup_reference_type (real_type, TYPE_CODE (type));\n-      else if (TYPE_CODE (type) == TYPE_CODE_PTR)\n+        real_type = lookup_reference_type (real_type, type->code ());\n+      else if (type->code () == TYPE_CODE_PTR)\n         real_type = lookup_pointer_type (real_type);\n       else\n         internal_error (__FILE__, __LINE__, _(\"Unexpected value type.\"));\n@@ -3760,8 +3760,8 @@ value_slice (struct value *array, int lowbound, int length)\n   struct type *array_type;\n \n   array_type = check_typedef (value_type (array));\n-  if (TYPE_CODE (array_type) != TYPE_CODE_ARRAY\n-      && TYPE_CODE (array_type) != TYPE_CODE_STRING)\n+  if (array_type->code () != TYPE_CODE_ARRAY\n+      && array_type->code () != TYPE_CODE_STRING)\n     error (_(\"cannot take slice of non-array\"));\n \n   if (type_not_allocated (array_type))\n@@ -3792,7 +3792,7 @@ value_slice (struct value *array, int lowbound, int length)\n     slice_type = create_array_type (NULL,\n \t\t\t\t    element_type,\n \t\t\t\t    slice_range_type);\n-    slice_type->set_code (TYPE_CODE (array_type));\n+    slice_type->set_code (array_type->code ());\n \n     if (VALUE_LVAL (array) == lval_memory && value_lazy (array))\n       slice = allocate_value_lazy (slice_type);\n@@ -3839,7 +3839,7 @@ value_real_part (struct value *value)\n   struct type *type = check_typedef (value_type (value));\n   struct type *ttype = TYPE_TARGET_TYPE (type);\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_COMPLEX);\n+  gdb_assert (type->code () == TYPE_CODE_COMPLEX);\n   return value_from_component (value, ttype, 0);\n }\n \n@@ -3851,7 +3851,7 @@ value_imaginary_part (struct value *value)\n   struct type *type = check_typedef (value_type (value));\n   struct type *ttype = TYPE_TARGET_TYPE (type);\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_COMPLEX);\n+  gdb_assert (type->code () == TYPE_CODE_COMPLEX);\n   return value_from_component (value, ttype,\n \t\t\t       TYPE_LENGTH (check_typedef (ttype)));\n }\n@@ -3863,7 +3863,7 @@ cast_into_complex (struct type *type, struct value *val)\n {\n   struct type *real_type = TYPE_TARGET_TYPE (type);\n \n-  if (TYPE_CODE (value_type (val)) == TYPE_CODE_COMPLEX)\n+  if (value_type (val)->code () == TYPE_CODE_COMPLEX)\n     {\n       struct type *val_real_type = TYPE_TARGET_TYPE (value_type (val));\n       struct value *re_val = allocate_value (val_real_type);\n@@ -3877,8 +3877,8 @@ cast_into_complex (struct type *type, struct value *val)\n \n       return value_literal_complex (re_val, im_val, type);\n     }\n-  else if (TYPE_CODE (value_type (val)) == TYPE_CODE_FLT\n-\t   || TYPE_CODE (value_type (val)) == TYPE_CODE_INT)\n+  else if (value_type (val)->code () == TYPE_CODE_FLT\n+\t   || value_type (val)->code () == TYPE_CODE_INT)\n     return value_literal_complex (val, \n \t\t\t\t  value_zero (real_type, not_lval), \n \t\t\t\t  type);"
    },
    {
      "sha": "4bd643e938df5ecd8441ad40e9dd64f10fff1be1",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -276,7 +276,7 @@ val_print_scalar_type_p (struct type *type)\n       type = TYPE_TARGET_TYPE (type);\n       type = check_typedef (type);\n     }\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n     case TYPE_CODE_STRUCT:\n@@ -323,9 +323,9 @@ valprint_check_validity (struct ui_file *stream,\n       return 0;\n     }\n \n-  if (TYPE_CODE (type) != TYPE_CODE_UNION\n-      && TYPE_CODE (type) != TYPE_CODE_STRUCT\n-      && TYPE_CODE (type) != TYPE_CODE_ARRAY)\n+  if (type->code () != TYPE_CODE_UNION\n+      && type->code () != TYPE_CODE_STRUCT\n+      && type->code () != TYPE_CODE_ARRAY)\n     {\n       if (value_bits_any_optimized_out (val,\n \t\t\t\t\tTARGET_CHAR_BIT * embedded_offset,\n@@ -338,7 +338,7 @@ valprint_check_validity (struct ui_file *stream,\n       if (value_bits_synthetic_pointer (val, TARGET_CHAR_BIT * embedded_offset,\n \t\t\t\t\tTARGET_CHAR_BIT * TYPE_LENGTH (type)))\n \t{\n-\t  const int is_ref = TYPE_CODE (type) == TYPE_CODE_REF;\n+\t  const int is_ref = type->code () == TYPE_CODE_REF;\n \t  int ref_is_addressable = 0;\n \n \t  if (is_ref)\n@@ -408,7 +408,7 @@ print_unpacked_pointer (struct type *type, struct type *elttype,\n {\n   struct gdbarch *gdbarch = get_type_arch (type);\n \n-  if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)\n+  if (elttype->code () == TYPE_CODE_FUNC)\n     {\n       /* Try to print what function it points to.  */\n       print_function_pointer_address (options, gdbarch, address, stream);\n@@ -527,7 +527,7 @@ generic_val_print_ref (struct type *type,\n \t\t\t\t    TARGET_CHAR_BIT * TYPE_LENGTH (type));\n   const int must_coerce_ref = ((options->addressprint && value_is_synthetic)\n \t\t\t       || options->deref_ref);\n-  const int type_is_defined = TYPE_CODE (elttype) != TYPE_CODE_UNDEF;\n+  const int type_is_defined = elttype->code () != TYPE_CODE_UNDEF;\n   const gdb_byte *valaddr = value_contents_for_printing (original_value);\n \n   if (must_coerce_ref && type_is_defined)\n@@ -825,7 +825,7 @@ generic_value_print (struct value *val, struct ui_file *stream, int recurse,\n   struct type *type = value_type (val);\n \n   type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       generic_val_print_array (val, stream, recurse, options, decorations);\n@@ -924,7 +924,7 @@ generic_value_print (struct value *val, struct ui_file *stream, int recurse,\n     case TYPE_CODE_METHODPTR:\n     default:\n       error (_(\"Unhandled type code %d in symbol table.\"),\n-\t     TYPE_CODE (type));\n+\t     type->code ());\n     }\n }\n \n@@ -1043,7 +1043,7 @@ value_check_printable (struct value *val, struct ui_file *stream,\n       return 0;\n     }\n \n-  if (TYPE_CODE (value_type (val)) == TYPE_CODE_INTERNAL_FUNCTION)\n+  if (value_type (val)->code () == TYPE_CODE_INTERNAL_FUNCTION)\n     {\n       fprintf_styled (stream, metadata_style.style (),\n \t\t      _(\"<internal function %s>\"),\n@@ -1170,7 +1170,7 @@ val_print_type_code_flags (struct type *type, struct value *original_value,\n \t      fprintf_filtered (stream, \" %ps=\",\n \t\t\t\tstyled_string (variable_name_style.style (),\n \t\t\t\t\t       TYPE_FIELD_NAME (type, field)));\n-\t      if (TYPE_CODE (field_type) == TYPE_CODE_ENUM)\n+\t      if (field_type->code () == TYPE_CODE_ENUM)\n \t\tgeneric_val_print_enum_1 (field_type, field_val, stream);\n \t      else\n \t\tprint_longest (stream, 'd', 0, field_val);\n@@ -1889,7 +1889,7 @@ value_print_array_elements (struct value *val, struct ui_file *stream,\n \n   if (get_array_bounds (type, &low_bound, &high_bound))\n     {\n-      if (TYPE_CODE (index_type) == TYPE_CODE_RANGE)\n+      if (index_type->code () == TYPE_CODE_RANGE)\n \tbase_index_type = TYPE_TARGET_TYPE (index_type);\n       else\n \tbase_index_type = index_type;"
    },
    {
      "sha": "df14232acd0b7a6d6061e18f2e0dc7953308c788",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1177,9 +1177,9 @@ value_actual_type (struct value *value, int resolve_simple_types,\n     {\n       /* If result's target type is TYPE_CODE_STRUCT, proceed to\n \t fetch its rtti type.  */\n-      if ((TYPE_CODE (result) == TYPE_CODE_PTR || TYPE_IS_REFERENCE (result))\n-\t  && TYPE_CODE (check_typedef (TYPE_TARGET_TYPE (result)))\n-\t     == TYPE_CODE_STRUCT\n+      if ((result->code () == TYPE_CODE_PTR || TYPE_IS_REFERENCE (result))\n+\t  && (check_typedef (TYPE_TARGET_TYPE (result))->code ()\n+\t      == TYPE_CODE_STRUCT)\n \t  && !value_optimized_out (value))\n         {\n           struct type *real_type;\n@@ -2189,7 +2189,7 @@ get_internalvar_integer (struct internalvar *var, LONGEST *result)\n     {\n       struct type *type = check_typedef (value_type (var->u.value));\n \n-      if (TYPE_CODE (type) == TYPE_CODE_INT)\n+      if (type->code () == TYPE_CODE_INT)\n \t{\n \t  *result = value_as_long (var->u.value);\n \t  return 1;\n@@ -2254,7 +2254,7 @@ set_internalvar (struct internalvar *var, struct value *val)\n     error (_(\"Cannot overwrite convenience function %s\"), var->name);\n \n   /* Prepare new contents.  */\n-  switch (TYPE_CODE (check_typedef (value_type (val))))\n+  switch (check_typedef (value_type (val))->code ())\n     {\n     case TYPE_CODE_VOID:\n       new_kind = INTERNALVAR_VOID;\n@@ -2591,7 +2591,7 @@ value_from_xmethod (xmethod_worker_up &&worker)\n struct type *\n result_type_of_xmethod (struct value *method, gdb::array_view<value *> argv)\n {\n-  gdb_assert (TYPE_CODE (value_type (method)) == TYPE_CODE_XMETHOD\n+  gdb_assert (value_type (method)->code () == TYPE_CODE_XMETHOD\n \t      && method->lval == lval_xcallable && !argv.empty ());\n \n   return method->location.xm_worker->get_result_type (argv[0], argv.slice (1));\n@@ -2602,7 +2602,7 @@ result_type_of_xmethod (struct value *method, gdb::array_view<value *> argv)\n struct value *\n call_xmethod (struct value *method, gdb::array_view<value *> argv)\n {\n-  gdb_assert (TYPE_CODE (value_type (method)) == TYPE_CODE_XMETHOD\n+  gdb_assert (value_type (method)->code () == TYPE_CODE_XMETHOD\n \t      && method->lval == lval_xcallable && !argv.empty ());\n \n   return method->location.xm_worker->invoke (argv[0], argv.slice (1));\n@@ -2677,8 +2677,8 @@ value_as_address (struct value *val)\n \n      The following shortcut avoids this whole mess.  If VAL is a\n      function, just return its address directly.  */\n-  if (TYPE_CODE (value_type (val)) == TYPE_CODE_FUNC\n-      || TYPE_CODE (value_type (val)) == TYPE_CODE_METHOD)\n+  if (value_type (val)->code () == TYPE_CODE_FUNC\n+      || value_type (val)->code () == TYPE_CODE_METHOD)\n     return value_address (val);\n \n   val = coerce_array (val);\n@@ -2720,7 +2720,7 @@ value_as_address (struct value *val)\n      converted to pointers; usually, the ABI doesn't either, but\n      ABI-specific code is a more reasonable place to handle it.  */\n \n-  if (TYPE_CODE (value_type (val)) != TYPE_CODE_PTR\n+  if (value_type (val)->code () != TYPE_CODE_PTR\n       && !TYPE_IS_REFERENCE (value_type (val))\n       && gdbarch_integer_to_address_p (gdbarch))\n     return gdbarch_integer_to_address (gdbarch, value_type (val),\n@@ -2748,7 +2748,7 @@ LONGEST\n unpack_long (struct type *type, const gdb_byte *valaddr)\n {\n   enum bfd_endian byte_order = type_byte_order (type);\n-  enum type_code code = TYPE_CODE (type);\n+  enum type_code code = type->code ();\n   int len = TYPE_LENGTH (type);\n   int nosign = TYPE_UNSIGNED (type);\n \n@@ -3317,7 +3317,7 @@ pack_long (gdb_byte *buf, struct type *type, LONGEST num)\n   type = check_typedef (type);\n   len = TYPE_LENGTH (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_RANGE:\n       num -= TYPE_RANGE_DATA (type)->bias;\n@@ -3344,7 +3344,7 @@ pack_long (gdb_byte *buf, struct type *type, LONGEST num)\n \n     default:\n       error (_(\"Unexpected type (%d) encountered for integer constant.\"),\n-\t     TYPE_CODE (type));\n+\t     type->code ());\n     }\n }\n \n@@ -3361,7 +3361,7 @@ pack_unsigned_long (gdb_byte *buf, struct type *type, ULONGEST num)\n   len = TYPE_LENGTH (type);\n   byte_order = type_byte_order (type);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_INT:\n     case TYPE_CODE_CHAR:\n@@ -3387,7 +3387,7 @@ pack_unsigned_long (gdb_byte *buf, struct type *type, ULONGEST num)\n     default:\n       error (_(\"Unexpected type (%d) encountered \"\n \t       \"for unsigned integer constant.\"),\n-\t     TYPE_CODE (type));\n+\t     type->code ());\n     }\n }\n \n@@ -3438,7 +3438,7 @@ struct value *\n value_from_host_double (struct type *type, double d)\n {\n   struct value *value = allocate_value (type);\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);\n+  gdb_assert (type->code () == TYPE_CODE_FLT);\n   target_float_from_host_double (value_contents_raw (value),\n \t\t\t\t value_type (value), d);\n   return value;\n@@ -3664,7 +3664,7 @@ coerce_array (struct value *arg)\n   arg = coerce_ref (arg);\n   type = check_typedef (value_type (arg));\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n       if (!TYPE_VECTOR (type) && current_language->c_style_arrays)\n@@ -3685,7 +3685,7 @@ enum return_value_convention\n struct_return_convention (struct gdbarch *gdbarch,\n \t\t\t  struct value *function, struct type *value_type)\n {\n-  enum type_code code = TYPE_CODE (value_type);\n+  enum type_code code = value_type->code ();\n \n   if (code == TYPE_CODE_ERROR)\n     error (_(\"Function return type unknown.\"));\n@@ -3703,7 +3703,7 @@ int\n using_struct_return (struct gdbarch *gdbarch,\n \t\t     struct value *function, struct type *value_type)\n {\n-  if (TYPE_CODE (value_type) == TYPE_CODE_VOID)\n+  if (value_type->code () == TYPE_CODE_VOID)\n     /* A void return value is never in memory.  See also corresponding\n        code in \"print_return_value\".  */\n     return 0;\n@@ -3931,7 +3931,7 @@ isvoid_internal_fn (struct gdbarch *gdbarch,\n   if (argc != 1)\n     error (_(\"You must provide one argument for $_isvoid.\"));\n \n-  ret = TYPE_CODE (value_type (argv[0])) == TYPE_CODE_VOID;\n+  ret = value_type (argv[0])->code () == TYPE_CODE_VOID;\n \n   return value_from_longest (builtin_type (gdbarch)->builtin_int, ret);\n }\n@@ -3949,7 +3949,7 @@ creal_internal_fn (struct gdbarch *gdbarch,\n \n   value *cval = argv[0];\n   type *ctype = check_typedef (value_type (cval));\n-  if (TYPE_CODE (ctype) != TYPE_CODE_COMPLEX)\n+  if (ctype->code () != TYPE_CODE_COMPLEX)\n     error (_(\"expected a complex number\"));\n   return value_real_part (cval);\n }\n@@ -3968,7 +3968,7 @@ cimag_internal_fn (struct gdbarch *gdbarch,\n \n   value *cval = argv[0];\n   type *ctype = check_typedef (value_type (cval));\n-  if (TYPE_CODE (ctype) != TYPE_CODE_COMPLEX)\n+  if (ctype->code () != TYPE_CODE_COMPLEX)\n     error (_(\"expected a complex number\"));\n   return value_imaginary_part (cval);\n }"
    },
    {
      "sha": "3358be4e77b48886f66301a592dad6e01d10938a",
      "filename": "gdb/varobj.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/varobj.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1271,7 +1271,7 @@ install_new_value (struct varobj *var, struct value *value, bool initial)\n   if (value)\n     value = coerce_ref (value);\n \n-  if (var->type && TYPE_CODE (var->type) == TYPE_CODE_UNION)\n+  if (var->type && var->type->code () == TYPE_CODE_UNION)\n     /* For unions, we need to fetch the value implicitly because\n        of implementation of union member fetch.  When gdb\n        creates a value for a field and the value of the enclosing\n@@ -2398,7 +2398,7 @@ varobj_editable_p (const struct varobj *var)\n \n   type = varobj_get_value_type (var);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n@@ -2445,7 +2445,7 @@ varobj_default_value_is_changeable_p (const struct varobj *var)\n \n   type = varobj_get_value_type (var);\n \n-  switch (TYPE_CODE (type))\n+  switch (type->code ())\n     {\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:"
    },
    {
      "sha": "1e60fba5101d952251207e4a57f09043d17a82a8",
      "filename": "gdb/vax-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/vax-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/vax-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/vax-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -206,9 +206,9 @@ vax_return_value (struct gdbarch *gdbarch, struct value *function,\n   int len = TYPE_LENGTH (type);\n   gdb_byte buf[8];\n \n-  if (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-      || TYPE_CODE (type) == TYPE_CODE_UNION\n-      || TYPE_CODE (type) == TYPE_CODE_ARRAY)\n+  if (type->code () == TYPE_CODE_STRUCT\n+      || type->code () == TYPE_CODE_UNION\n+      || type->code () == TYPE_CODE_ARRAY)\n     {\n       /* The default on VAX is to return structures in static memory.\n          Consequently a function must return the address where we can"
    },
    {
      "sha": "9818d97d44a768fa9c33e6d0f8971cc6588e1b63",
      "filename": "gdb/xstormy16-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/xstormy16-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/xstormy16-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xstormy16-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -133,9 +133,9 @@ xstormy16_register_type (struct gdbarch *gdbarch, int regnum)\n static int\n xstormy16_type_is_scalar (struct type *t)\n {\n-  return (TYPE_CODE(t) != TYPE_CODE_STRUCT\n-\t  && TYPE_CODE(t) != TYPE_CODE_UNION\n-\t  && TYPE_CODE(t) != TYPE_CODE_ARRAY);\n+  return (t->code () != TYPE_CODE_STRUCT\n+\t  && t->code () != TYPE_CODE_UNION\n+\t  && t->code () != TYPE_CODE_ARRAY);\n }\n \n /* Function: xstormy16_use_struct_convention \n@@ -610,7 +610,7 @@ xstormy16_pointer_to_address (struct gdbarch *gdbarch,\n \t\t\t      struct type *type, const gdb_byte *buf)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  enum type_code target = TYPE_CODE (TYPE_TARGET_TYPE (type));\n+  enum type_code target = TYPE_TARGET_TYPE (type)->code ();\n   CORE_ADDR addr\n     = extract_unsigned_integer (buf, TYPE_LENGTH (type), byte_order);\n \n@@ -629,7 +629,7 @@ xstormy16_address_to_pointer (struct gdbarch *gdbarch,\n \t\t\t      struct type *type, gdb_byte *buf, CORE_ADDR addr)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  enum type_code target = TYPE_CODE (TYPE_TARGET_TYPE (type));\n+  enum type_code target = TYPE_TARGET_TYPE (type)->code ();\n \n   if (target == TYPE_CODE_FUNC || target == TYPE_CODE_METHOD)\n     {"
    },
    {
      "sha": "97486dea602231b3fbd90529c36c600633122e2b",
      "filename": "gdb/xtensa-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/xtensa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7813437494ac39f3aef392d06ed5416e84fe386b/gdb/xtensa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xtensa-tdep.c?ref=7813437494ac39f3aef392d06ed5416e84fe386b",
      "patch": "@@ -1651,9 +1651,9 @@ xtensa_return_value (struct gdbarch *gdbarch,\n {\n   /* Structures up to 16 bytes are returned in registers.  */\n \n-  int struct_return = ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT\n-\t\t\t|| TYPE_CODE (valtype) == TYPE_CODE_UNION\n-\t\t\t|| TYPE_CODE (valtype) == TYPE_CODE_ARRAY)\n+  int struct_return = ((valtype->code () == TYPE_CODE_STRUCT\n+\t\t\t|| valtype->code () == TYPE_CODE_UNION\n+\t\t\t|| valtype->code () == TYPE_CODE_ARRAY)\n \t\t       && TYPE_LENGTH (valtype) > 16);\n \n   if (struct_return)\n@@ -1726,7 +1726,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n \t  fprintf_unfiltered (gdb_stdlog, \"%2d: %s %3s \", i,\n \t\t\t      host_address_to_string (arg),\n \t\t\t      pulongest (TYPE_LENGTH (arg_type)));\n-\t  switch (TYPE_CODE (arg_type))\n+\t  switch (arg_type->code ())\n \t    {\n \t    case TYPE_CODE_INT:\n \t      fprintf_unfiltered (gdb_stdlog, \"int\");\n@@ -1735,7 +1735,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n \t      fprintf_unfiltered (gdb_stdlog, \"struct\");\n \t      break;\n \t    default:\n-\t      fprintf_unfiltered (gdb_stdlog, \"%3d\", TYPE_CODE (arg_type));\n+\t      fprintf_unfiltered (gdb_stdlog, \"%3d\", arg_type->code ());\n \t      break;\n \t    }\n \t  fprintf_unfiltered (gdb_stdlog, \" %s\\n\",\n@@ -1760,7 +1760,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n       struct value *arg = args[i];\n       struct type *arg_type = check_typedef (value_type (arg));\n \n-      switch (TYPE_CODE (arg_type))\n+      switch (arg_type->code ())\n \t{\n \tcase TYPE_CODE_INT:\n \tcase TYPE_CODE_BOOL:"
    }
  ]
}