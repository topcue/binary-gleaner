{
  "sha": "6ac373717c28cc2befebd1e926dc5fcf39dda39f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmFjMzczNzE3YzI4Y2MyYmVmZWJkMWU5MjZkYzVmY2YzOWRkYTM5Zg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-28T15:09:02Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-28T15:09:02Z"
    },
    "message": "gdb: rename type::{arch,objfile} -> type::{arch_owner,objfile_owner}\n\nI think this makes the names of the methods clearer, especially for the\narch.  The type::arch method (which gets the arch owner, or NULL if the\ntype is not arch owned) is easily confused with the get_type_arch method\n(which returns an arch no matter what).  The name \"arch_owner\" will make\nit intuitive that the method returns NULL if the type is not arch-owned.\n\nAlso, this frees the type::arch name, so we will be able to morph the\nget_type_arch function into the type::arch method.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (struct type) <arch>: Rename to...\n\t<arch_owner>: ... this, update all users.\n\t<objfile>: Rename to...\n\t<objfile_owner>: ... this, update all users.\n\nChange-Id: Ie7c28684c7b565adec05a7619c418c69429bd8c0",
    "tree": {
      "sha": "56a4b7f247510cc9a5b087722b0fd034f06ee0d0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/56a4b7f247510cc9a5b087722b0fd034f06ee0d0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6ac373717c28cc2befebd1e926dc5fcf39dda39f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6ac373717c28cc2befebd1e926dc5fcf39dda39f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6ac373717c28cc2befebd1e926dc5fcf39dda39f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6ac373717c28cc2befebd1e926dc5fcf39dda39f/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cc3edc52747fd8b184ee48f1b0cc1ac0aca7832e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cc3edc52747fd8b184ee48f1b0cc1ac0aca7832e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cc3edc52747fd8b184ee48f1b0cc1ac0aca7832e"
    }
  ],
  "stats": {
    "total": 108,
    "additions": 58,
    "deletions": 50
  },
  "files": [
    {
      "sha": "88dfba7c5f0103029d885a7599d22b14073bd5a7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -1,3 +1,10 @@\n+2021-01-28  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* gdbtypes.h (struct type) <arch>: Rename to...\n+\t<arch_owner>: ... this, update all users.\n+\t<objfile>: Rename to...\n+\t<objfile_owner>: ... this, update all users.\n+\n 2021-01-28  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdbcmd.h (execute_command_to_string): Update comment."
    },
    {
      "sha": "d0baf5a183fb537a096fa0fe3e3a179bea455799",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -13269,8 +13269,8 @@ ada_operator_check (struct expression *exp, int pos,\n \n   /* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */\n \n-  if (type != nullptr && type->objfile () != nullptr\n-      && objfile_func (type->objfile (), data))\n+  if (type != nullptr && type->objfile_owner () != nullptr\n+      && objfile_func (type->objfile_owner (), data))\n     return 1;\n \n   return 0;"
    },
    {
      "sha": "eaeb83284d4e146f01f8c21292ccc250e49e82ec",
      "filename": "gdb/compile/compile-c-types.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/compile/compile-c-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/compile/compile-c-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-types.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -165,9 +165,9 @@ convert_func (compile_c_instance *context, struct type *type)\n   if (target_type == NULL)\n     {\n       if (type->is_objfile_owned ())\n-\ttarget_type = objfile_type (type->objfile ())->builtin_int;\n+\ttarget_type = objfile_type (type->objfile_owner ())->builtin_int;\n       else\n-\ttarget_type = builtin_type (type->arch ())->builtin_int;\n+\ttarget_type = builtin_type (type->arch_owner ())->builtin_int;\n       warning (_(\"function has unknown return type; assuming int\"));\n     }\n \n@@ -324,9 +324,9 @@ convert_type_basic (compile_c_instance *context, struct type *type)\n \t   built-in parser used to do, but at least warn.  */\n \tstruct type *fallback;\n \tif (type->is_objfile_owned ())\n-\t  fallback = objfile_type (type->objfile ())->builtin_int;\n+\t  fallback = objfile_type (type->objfile_owner ())->builtin_int;\n \telse\n-\t  fallback = builtin_type (type->arch ())->builtin_int;\n+\t  fallback = builtin_type (type->arch_owner ())->builtin_int;\n \twarning (_(\"variable has unknown type; assuming int\"));\n \treturn convert_int (context, fallback);\n       }"
    },
    {
      "sha": "d666ac3a83ed3b7169ef58ad42e6ea4e40475e7b",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -971,9 +971,9 @@ compile_cplus_convert_func (compile_cplus_instance *instance,\n   if (target_type == nullptr)\n     {\n       if (type->is_objfile_owned ())\n-\ttarget_type = objfile_type (type->objfile ())->builtin_int;\n+\ttarget_type = objfile_type (type->objfile_owner ())->builtin_int;\n       else\n-\ttarget_type = builtin_type (type->arch ())->builtin_int;\n+\ttarget_type = builtin_type (type->arch_owner ())->builtin_int;\n       warning (_(\"function has unknown return type; assuming int\"));\n     }\n "
    },
    {
      "sha": "638c8a66af91b2c4ca720b2110163f7f0857be46",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -227,9 +227,9 @@ struct type *\n alloc_type_copy (const struct type *type)\n {\n   if (type->is_objfile_owned ())\n-    return alloc_type (type->objfile ());\n+    return alloc_type (type->objfile_owner ());\n   else\n-    return alloc_type_arch (type->arch ());\n+    return alloc_type_arch (type->arch_owner ());\n }\n \n /* If TYPE is gdbarch-associated, return that architecture.\n@@ -241,9 +241,9 @@ get_type_arch (const struct type *type)\n   struct gdbarch *arch;\n \n   if (type->is_objfile_owned ())\n-    arch = type->objfile ()->arch ();\n+    arch = type->objfile_owner ()->arch ();\n   else\n-    arch = type->arch ();\n+    arch = type->arch_owner ();\n \n   /* The ARCH can be NULL if TYPE is associated with neither an objfile nor\n      a gdbarch, however, this is very rare, and even then, in most cases\n@@ -293,7 +293,7 @@ alloc_type_instance (struct type *oldtype)\n   if (!oldtype->is_objfile_owned ())\n     type = GDBARCH_OBSTACK_ZALLOC (get_type_arch (oldtype), struct type);\n   else\n-    type = OBSTACK_ZALLOC (&oldtype->objfile ()->objfile_obstack,\n+    type = OBSTACK_ZALLOC (&oldtype->objfile_owner ()->objfile_obstack,\n \t\t\t   struct type);\n \n   TYPE_MAIN_TYPE (type) = TYPE_MAIN_TYPE (oldtype);\n@@ -310,8 +310,8 @@ static void\n smash_type (struct type *type)\n {\n   bool objfile_owned = type->is_objfile_owned ();\n-  objfile *objfile = type->objfile ();\n-  gdbarch *arch = type->arch ();\n+  objfile *objfile = type->objfile_owner ();\n+  gdbarch *arch = type->arch_owner ();\n \n   memset (TYPE_MAIN_TYPE (type), 0, sizeof (struct main_type));\n \n@@ -648,7 +648,7 @@ make_qualified_type (struct type *type, type_instance_flags new_flags,\n \t as TYPE.  Otherwise, we can't link it into TYPE's cv chain:\n \t if one objfile is freed and the other kept, we'd have\n \t dangling pointers.  */\n-      gdb_assert (type->objfile () == storage->objfile ());\n+      gdb_assert (type->objfile_owner () == storage->objfile_owner ());\n \n       ntype = storage;\n       TYPE_MAIN_TYPE (ntype) = TYPE_MAIN_TYPE (type);\n@@ -738,7 +738,7 @@ make_cv_type (int cnst, int voltl,\n \t can't have inter-objfile pointers.  The only thing to do is\n \t to leave stub types as stub types, and look them up afresh by\n \t name each time you encounter them.  */\n-      gdb_assert ((*typeptr)->objfile () == type->objfile ());\n+      gdb_assert ((*typeptr)->objfile_owner () == type->objfile_owner ());\n     }\n   \n   ntype = make_qualified_type (type, new_flags, \n@@ -804,7 +804,7 @@ replace_type (struct type *ntype, struct type *type)\n      the assignment of one type's main type structure to the other\n      will produce a type with references to objects (names; field\n      lists; etc.) allocated on an objfile other than its own.  */\n-  gdb_assert (ntype->objfile () == type->objfile ());\n+  gdb_assert (ntype->objfile_owner () == type->objfile_owner ());\n \n   *TYPE_MAIN_TYPE (ntype) = *TYPE_MAIN_TYPE (type);\n \n@@ -1430,9 +1430,9 @@ lookup_array_range_type (struct type *element_type,\n   struct type *range_type;\n \n   if (element_type->is_objfile_owned ())\n-    index_type = objfile_type (element_type->objfile ())->builtin_int;\n+    index_type = objfile_type (element_type->objfile_owner ())->builtin_int;\n   else\n-    index_type = builtin_type (element_type->arch ())->builtin_int;\n+    index_type = builtin_type (element_type->arch_owner ())->builtin_int;\n \n   range_type = create_static_range_type (NULL, index_type,\n \t\t\t\t\t low_bound, high_bound);\n@@ -1681,7 +1681,7 @@ type_name_or_error (struct type *type)\n     return name;\n \n   name = saved_type->name ();\n-  objfile = saved_type->objfile ();\n+  objfile = saved_type->objfile_owner ();\n   error (_(\"Invalid anonymous type %s [in module %s], GCC PR debug/47510 bug?\"),\n \t name ? name : \"<anonymous>\",\n \t objfile ? objfile_name (objfile) : \"<arch>\");\n@@ -2027,7 +2027,7 @@ get_vptr_fieldno (struct type *type, struct type **basetypep)\n \t    {\n \t      /* If the type comes from a different objfile we can't cache\n \t\t it, it may have a different lifetime.  PR 2384 */\n-\t      if (type->objfile () == basetype->objfile ())\n+\t      if (type->objfile_owner () == basetype->objfile_owner ())\n \t\t{\n \t\t  set_type_vptr_fieldno (type, fieldno);\n \t\t  set_type_vptr_basetype (type, basetype);\n@@ -2800,7 +2800,7 @@ type::add_dyn_prop (dynamic_prop_node_kind prop_kind, dynamic_prop prop)\n \n   gdb_assert (this->is_objfile_owned ());\n \n-  temp = XOBNEW (&this->objfile ()->objfile_obstack,\n+  temp = XOBNEW (&this->objfile_owner ()->objfile_obstack,\n \t\t struct dynamic_prop_list);\n   temp->prop_kind = prop_kind;\n   temp->prop = prop;\n@@ -2969,7 +2969,7 @@ check_typedef (struct type *type)\n \t     TYPE's objfile is pointless, too, since you'll have to\n \t     move over any other types NEWTYPE refers to, which could\n \t     be an unbounded amount of stuff.  */\n-\t  if (newtype->objfile () == type->objfile ())\n+\t  if (newtype->objfile_owner () == type->objfile_owner ())\n \t    type = make_qualified_type (newtype, type->instance_flags (), type);\n \t  else\n \t    type = newtype;\n@@ -2995,7 +2995,7 @@ check_typedef (struct type *type)\n \t  /* Same as above for opaque types, we can replace the stub\n \t     with the complete type only if they are in the same\n \t     objfile.  */\n-\t  if (SYMBOL_TYPE (sym)->objfile () == type->objfile ())\n+\t  if (SYMBOL_TYPE (sym)->objfile_owner () == type->objfile_owner ())\n \t    type = make_qualified_type (SYMBOL_TYPE (sym),\n \t\t\t\t\ttype->instance_flags (), type);\n \t  else\n@@ -5192,12 +5192,12 @@ recursive_dump_type (struct type *type, int spaces)\n   if (type->is_objfile_owned ())\n     {\n       printf_filtered (\"%*sobjfile \", spaces, \"\");\n-      gdb_print_host_address (type->objfile (), gdb_stdout);\n+      gdb_print_host_address (type->objfile_owner (), gdb_stdout);\n     }\n   else\n     {\n       printf_filtered (\"%*sgdbarch \", spaces, \"\");\n-      gdb_print_host_address (type->arch (), gdb_stdout);\n+      gdb_print_host_address (type->arch_owner (), gdb_stdout);\n     }\n   printf_filtered (\"\\n\");\n   printf_filtered (\"%*starget_type \", spaces, \"\");\n@@ -5497,7 +5497,7 @@ copy_type_recursive (struct objfile *objfile,\n \n   /* This type shouldn't be pointing to any types in other objfiles;\n      if it did, the type might disappear unexpectedly.  */\n-  gdb_assert (type->objfile () == objfile);\n+  gdb_assert (type->objfile_owner () == objfile);\n \n   struct type_pair pair (type, nullptr);\n \n@@ -5667,7 +5667,7 @@ copy_type (const struct type *type)\n \t  sizeof (struct main_type));\n   if (type->main_type->dyn_prop_list != NULL)\n     new_type->main_type->dyn_prop_list\n-      = copy_dynamic_prop_list (&type->objfile ()->objfile_obstack,\n+      = copy_dynamic_prop_list (&type->objfile_owner ()->objfile_obstack,\n \t\t\t\ttype->main_type->dyn_prop_list);\n \n   return new_type;\n@@ -5963,9 +5963,9 @@ allocate_fixed_point_type_info (struct type *type)\n   if (type->is_objfile_owned ())\n     {\n       fixed_point_type_storage *storage\n-\t= fixed_point_objfile_key.get (type->objfile ());\n+\t= fixed_point_objfile_key.get (type->objfile_owner ());\n       if (storage == nullptr)\n-\tstorage = fixed_point_objfile_key.emplace (type->objfile ());\n+\tstorage = fixed_point_objfile_key.emplace (type->objfile_owner ());\n       info = up.get ();\n       storage->push_back (std::move (up));\n     }"
    },
    {
      "sha": "df3b84ba838af58970c43e466c658b6c8b3bf6d5",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -1263,7 +1263,7 @@ struct type\n   /* Return the objfile owner of this type.\n \n      Return nullptr if this type is not objfile-owned.  */\n-  struct objfile *objfile () const\n+  struct objfile *objfile_owner () const\n   {\n     if (!this->is_objfile_owned ())\n       return nullptr;\n@@ -1274,7 +1274,7 @@ struct type\n   /* Return the gdbarch owner of this type.\n \n      Return nullptr if this type is not gdbarch-owned.  */\n-  gdbarch *arch () const\n+  gdbarch *arch_owner () const\n   {\n     if (this->is_objfile_owned ())\n       return nullptr;\n@@ -2240,8 +2240,8 @@ extern const struct floatformat *floatformats_bfloat16[BFD_ENDIAN_UNKNOWN];\n \n #define TYPE_ALLOC(t,size)                                              \\\n   (obstack_alloc (((t)->is_objfile_owned ()                             \\\n-\t\t   ? &((t)->objfile ()->objfile_obstack)                \\\n-\t\t   : gdbarch_obstack ((t)->arch ())),                   \\\n+\t\t   ? &((t)->objfile_owner ()->objfile_obstack)          \\\n+\t\t   : gdbarch_obstack ((t)->arch_owner ())),             \\\n \t\t  size))\n \n "
    },
    {
      "sha": "dd45d8e8b35c0cb6ad5413dc7a2c9bd7db110c71",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -151,7 +151,7 @@ tyscm_eq_type_smob (const void *ap, const void *bp)\n static htab_t\n tyscm_type_map (struct type *type)\n {\n-  struct objfile *objfile = type->objfile ();\n+  struct objfile *objfile = type->objfile_owner ();\n   htab_t htab;\n \n   if (objfile == NULL)\n@@ -351,7 +351,7 @@ tyscm_copy_type_recursive (void **slot, void *info)\n {\n   type_smob *t_smob = (type_smob *) *slot;\n   htab_t copied_types = (htab_t) info;\n-  struct objfile *objfile = t_smob->type->objfile ();\n+  struct objfile *objfile = t_smob->type->objfile_owner ();\n   htab_t htab;\n   eqable_gdb_smob **new_slot;\n   type_smob t_smob_for_lookup;"
    },
    {
      "sha": "8dde5046264019f4795ceb957e79620b0ee3d3eb",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -1037,7 +1037,7 @@ language_arch_info::type_and_symbol::alloc_type_symbol\n   struct symbol *symbol;\n   struct gdbarch *gdbarch;\n   gdb_assert (!type->is_objfile_owned ());\n-  gdbarch = type->arch ();\n+  gdbarch = type->arch_owner ();\n   symbol = new (gdbarch_obstack (gdbarch)) struct symbol ();\n   symbol->m_name = type->name ();\n   symbol->set_language (lang, nullptr);"
    },
    {
      "sha": "933960fa30ce5cba3e19c93dc294b98045a94473",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -1320,7 +1320,7 @@ operator_check_standard (struct expression *exp, int pos,\n \tfor (arg = 0; arg < nargs; arg++)\n \t  {\n \t    struct type *inst_type = elts[pos + 3 + arg].type;\n-\t    struct objfile *inst_objfile = inst_type->objfile ();\n+\t    struct objfile *inst_objfile = inst_type->objfile_owner ();\n \n \t    if (inst_objfile && (*objfile_func) (inst_objfile, data))\n \t      return 1;\n@@ -1351,8 +1351,8 @@ operator_check_standard (struct expression *exp, int pos,\n \n   /* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */\n \n-  if (type != nullptr && type->objfile () != nullptr\n-      && objfile_func (type->objfile (), data))\n+  if (type != nullptr && type->objfile_owner () != nullptr\n+      && objfile_func (type->objfile_owner (), data))\n     return 1;\n \n   if (objfile && (*objfile_func) (objfile, data))"
    },
    {
      "sha": "bf707078841fedf9065cc73af25759efb3bdd05f",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -418,7 +418,7 @@ static PyObject *\n typy_get_objfile (PyObject *self, void *closure)\n {\n   struct type *type = ((type_object *) self)->type;\n-  struct objfile *objfile = type->objfile ();\n+  struct objfile *objfile = type->objfile_owner ();\n \n   if (objfile == nullptr)\n     Py_RETURN_NONE;\n@@ -1098,9 +1098,9 @@ set_type (type_object *obj, struct type *type)\n {\n   obj->type = type;\n   obj->prev = NULL;\n-  if (type != nullptr && type->objfile () != nullptr)\n+  if (type != nullptr && type->objfile_owner () != nullptr)\n     {\n-      struct objfile *objfile = type->objfile ();\n+      struct objfile *objfile = type->objfile_owner ();\n \n       obj->next = ((type_object *)\n \t\t   objfile_data (objfile, typy_objfile_data_key));\n@@ -1119,10 +1119,10 @@ typy_dealloc (PyObject *obj)\n \n   if (type->prev)\n     type->prev->next = type->next;\n-  else if (type->type != nullptr && type->type->objfile () != nullptr)\n+  else if (type->type != nullptr && type->type->objfile_owner () != nullptr)\n     {\n       /* Must reset head of list.  */\n-      struct objfile *objfile = type->type->objfile ();\n+      struct objfile *objfile = type->type->objfile_owner ();\n \n       if (objfile)\n \tset_objfile_data (objfile, typy_objfile_data_key, type->next);"
    },
    {
      "sha": "ca9a74903e80dd4d670403261474d6fbcad9fe4e",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -1825,7 +1825,7 @@ rust_operator_check (struct expression *exp, int pos,\n     case OP_AGGREGATE:\n       {\n \tstruct type *type = exp->elts[pos + 1].type;\n-\tstruct objfile *objfile = type->objfile ();\n+\tstruct objfile *objfile = type->objfile_owner ();\n \n \tif (objfile != NULL && (*objfile_func) (objfile, data))\n \t  return 1;"
    },
    {
      "sha": "3551b80ef9ebfac056c1afc0a249beb3e4016d9e",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ac373717c28cc2befebd1e926dc5fcf39dda39f/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=6ac373717c28cc2befebd1e926dc5fcf39dda39f",
      "patch": "@@ -2514,10 +2514,10 @@ void\n preserve_one_value (struct value *value, struct objfile *objfile,\n \t\t    htab_t copied_types)\n {\n-  if (value->type->objfile () == objfile)\n+  if (value->type->objfile_owner () == objfile)\n     value->type = copy_type_recursive (objfile, value->type, copied_types);\n \n-  if (value->enclosing_type->objfile () == objfile)\n+  if (value->enclosing_type->objfile_owner () == objfile)\n     value->enclosing_type = copy_type_recursive (objfile,\n \t\t\t\t\t\t value->enclosing_type,\n \t\t\t\t\t\t copied_types);\n@@ -2532,7 +2532,8 @@ preserve_one_internalvar (struct internalvar *var, struct objfile *objfile,\n   switch (var->kind)\n     {\n     case INTERNALVAR_INTEGER:\n-      if (var->u.integer.type && var->u.integer.type->objfile () == objfile)\n+      if (var->u.integer.type\n+\t  && var->u.integer.type->objfile_owner () == objfile)\n \tvar->u.integer.type\n \t  = copy_type_recursive (objfile, var->u.integer.type, copied_types);\n       break;"
    }
  ]
}