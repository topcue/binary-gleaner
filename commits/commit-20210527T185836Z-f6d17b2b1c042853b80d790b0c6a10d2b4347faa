{
  "sha": "f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjZkMTdiMmIxYzA0Mjg1M2I4MGQ3OTBiMGM2YTEwZDJiNDM0N2ZhYQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:36Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:36Z"
    },
    "message": "gdb: add all_tracepoints function\n\nSame idea as the previous patches, but to replace the ALL_TRACEPOINTS\nmacro.  Define a new filtered_iterator that only keeps the breakpoints\nfor which is_tracepoint returns true (just like the macro did).\n\nI would have like to make it so tracepoint_range yields some\n`tracepoint *` instead of some `breakpoint *`, that would help simplify\nthe callers, who wouldn't have to do the cast themselves.  But I didn't\nfind an obvious way to do it.  It can always be added later.\n\nIt turns out there is already an all_tracepoints function, which returns\na vector containing all the breakpoints that are tracepoint.  Remove it,\nmost users will just work seamlessly with the new function.  The\nexception is start_tracing, which iterated multiple times on the vector.\nAdapt this one so it iterates multiple times on the returned range.\n\nSince the existing users of all_tracepoints are outside of breakpoint.c,\nthis requires defining all_tracepoints and a few supporting types in\nbreakpoint.h.  So, move breakpoint_iterator from breakpoint.c to\nbreakpoint.h.\n\ngdb/ChangeLog:\n\n\t* breakpoint.h (all_tracepoints): Remove.\n\t(breakpoint_iterator): Move here.\n\t(struct tracepoint_filter): New.\n\t(tracepoint_iterator): New.\n\t(tracepoint_range): New.\n\t(all_tracepoints): New.\n\t* breakpoint.c (ALL_TRACEPOINTS): Remove, replace all users with\n\tall_tracepoints.\n\t(breakpoint_iterator): Move to header.\n\t(all_tracepoints): New.\n\t* tracepoint.c (start_tracing): Adjust.\n\nChange-Id: I76b1bba4215dbec7a03846c568368aeef7f1e05a",
    "tree": {
      "sha": "9acfbff036d0df6246c8a45f501c90bd6883d8f3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9acfbff036d0df6246c8a45f501c90bd6883d8f3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1428b37afbd8a5199e1c4b2a53ef8700208a12d4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1428b37afbd8a5199e1c4b2a53ef8700208a12d4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1428b37afbd8a5199e1c4b2a53ef8700208a12d4"
    }
  ],
  "stats": {
    "total": 106,
    "additions": 58,
    "deletions": 48
  },
  "files": [
    {
      "sha": "ca6418b3029c2674d558e71ee552bea0d34b0beb",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
      "patch": "@@ -1,3 +1,17 @@\n+2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* breakpoint.h (all_tracepoints): Remove.\n+\t(breakpoint_iterator): Move here.\n+\t(struct tracepoint_filter): New.\n+\t(tracepoint_iterator): New.\n+\t(tracepoint_range): New.\n+\t(all_tracepoints): New.\n+\t* breakpoint.c (ALL_TRACEPOINTS): Remove, replace all users with\n+\tall_tracepoints.\n+\t(breakpoint_iterator): Move to header.\n+\t(all_tracepoints): New.\n+\t* tracepoint.c (start_tracing): Adjust.\n+\n 2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* breakpoint.c (breakpoint_safe_range): New."
    },
    {
      "sha": "7ada790753ea7580cfcb0090769d2249d1aec731",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 14,
      "deletions": 41,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
      "patch": "@@ -514,20 +514,10 @@ bool target_exact_watchpoints = false;\n \t     && (*BP_LOCP_TMP)->address == ADDRESS);\t\t\t\\\n \t     BP_LOCP_TMP++)\n \n-/* Iterator for tracepoints only.  */\n-\n-#define ALL_TRACEPOINTS(B)  \\\n-  for (B = breakpoint_chain; B; B = B->next)  \\\n-    if (is_tracepoint (B))\n-\n /* Chains of all breakpoints defined.  */\n \n static struct breakpoint *breakpoint_chain;\n \n-/* Breakpoint linked list iterator.  */\n-\n-using breakpoint_iterator = next_iterator<breakpoint>;\n-\n /* Breakpoint linked list range.  */\n \n using breakpoint_range = next_adapter<breakpoint, breakpoint_iterator>;\n@@ -554,6 +544,14 @@ all_breakpoints_safe ()\n   return breakpoint_safe_range (all_breakpoints ());\n }\n \n+/* See breakpoint.h.  */\n+\n+tracepoint_range\n+all_tracepoints ()\n+{\n+  return tracepoint_range (breakpoint_chain);\n+}\n+\n /* Array is sorted by bp_location_is_less_than - primarily by the ADDRESS.  */\n \n static struct bp_location **bp_locations;\n@@ -11714,12 +11712,11 @@ bp_locations_target_extensions_update (void)\n static void\n download_tracepoint_locations (void)\n {\n-  struct breakpoint *b;\n   enum tribool can_download_tracepoint = TRIBOOL_UNKNOWN;\n \n   scoped_restore_current_pspace_and_thread restore_pspace_thread;\n \n-  ALL_TRACEPOINTS (b)\n+  for (breakpoint *b : all_tracepoints ())\n     {\n       struct bp_location *bl;\n       struct tracepoint *t;\n@@ -14910,13 +14907,12 @@ delete_trace_command (const char *arg, int from_tty)\n   if (arg == 0)\n     {\n       int breaks_to_delete = 0;\n-      breakpoint *tp;\n \n       /* Delete all breakpoints if no argument.\n \t Do not delete internal or call-dummy breakpoints, these\n \t have to be deleted with an explicit breakpoint number \n \t argument.  */\n-      ALL_TRACEPOINTS (tp)\n+      for (breakpoint *tp : all_tracepoints ())\n \tif (is_tracepoint (tp) && user_breakpoint_p (tp))\n \t  {\n \t    breaks_to_delete = 1;\n@@ -14973,13 +14969,11 @@ trace_pass_command (const char *args, int from_tty)\n   args = skip_spaces (args);\n   if (*args && strncasecmp (args, \"all\", 3) == 0)\n     {\n-      struct breakpoint *b;\n-\n       args += 3;\t\t\t/* Skip special argument \"all\".  */\n       if (*args)\n \terror (_(\"Junk at end of arguments.\"));\n \n-      ALL_TRACEPOINTS (b)\n+      for (breakpoint *b : all_tracepoints ())\n       {\n \tt1 = (struct tracepoint *) b;\n \ttrace_pass_set_count (t1, count, from_tty);\n@@ -15006,9 +15000,7 @@ trace_pass_command (const char *args, int from_tty)\n struct tracepoint *\n get_tracepoint (int num)\n {\n-  struct breakpoint *t;\n-\n-  ALL_TRACEPOINTS (t)\n+  for (breakpoint *t : all_tracepoints ())\n     if (t->number == num)\n       return (struct tracepoint *) t;\n \n@@ -15022,9 +15014,7 @@ get_tracepoint (int num)\n struct tracepoint *\n get_tracepoint_by_number_on_target (int num)\n {\n-  struct breakpoint *b;\n-\n-  ALL_TRACEPOINTS (b)\n+  for (breakpoint *b : all_tracepoints ())\n     {\n       struct tracepoint *t = (struct tracepoint *) b;\n \n@@ -15044,7 +15034,6 @@ struct tracepoint *\n get_tracepoint_by_number (const char **arg,\n \t\t\t  number_or_range_parser *parser)\n {\n-  struct breakpoint *t;\n   int tpnum;\n   const char *instring = arg == NULL ? NULL : *arg;\n \n@@ -15068,7 +15057,7 @@ get_tracepoint_by_number (const char **arg,\n       return NULL;\n     }\n \n-  ALL_TRACEPOINTS (t)\n+  for (breakpoint *t : all_tracepoints ())\n     if (t->number == tpnum)\n     {\n       return (struct tracepoint *) t;\n@@ -15225,22 +15214,6 @@ save_tracepoints_command (const char *args, int from_tty)\n   save_breakpoints (args, from_tty, is_tracepoint);\n }\n \n-/* Create a vector of all tracepoints.  */\n-\n-std::vector<breakpoint *>\n-all_tracepoints (void)\n-{\n-  std::vector<breakpoint *> tp_vec;\n-  struct breakpoint *tp;\n-\n-  ALL_TRACEPOINTS (tp)\n-  {\n-    tp_vec.push_back (tp);\n-  }\n-\n-  return tp_vec;\n-}\n-\n \f\n /* This help string is used to consolidate all the help string for specifying\n    locations used by several commands.  */"
    },
    {
      "sha": "5a10839603d7842a830f63dd9f44457bb9f5b8d7",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 26,
      "deletions": 3,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
      "patch": "@@ -28,6 +28,7 @@\n #include \"location.h\"\n #include <vector>\n #include \"gdbsupport/array-view.h\"\n+#include \"gdbsupport/filtered-iterator.h\"\n #include \"gdbsupport/function-view.h\"\n #include \"gdbsupport/refcounted-object.h\"\n #include \"cli/cli-script.h\"\n@@ -1683,9 +1684,6 @@ extern struct tracepoint *\n   get_tracepoint_by_number (const char **arg,\n \t\t\t    number_or_range_parser *parser);\n \n-/* Return a vector of all tracepoints currently defined.  */\n-extern std::vector<breakpoint *> all_tracepoints (void);\n-\n /* Return true if B is of tracepoint kind.  */\n \n extern bool is_tracepoint (const struct breakpoint *b);\n@@ -1717,6 +1715,31 @@ class scoped_rbreak_breakpoints\n extern struct breakpoint *iterate_over_breakpoints\n   (gdb::function_view<bool (breakpoint *)>);\n \n+/* Breakpoint linked list iterator.  */\n+\n+using breakpoint_iterator = next_iterator<breakpoint>;\n+\n+/* Breakpoint filter to only keep tracepoints.  */\n+\n+struct tracepoint_filter\n+{\n+  bool operator() (breakpoint *b)\n+  { return is_tracepoint (b); }\n+};\n+\n+/* Breakpoint linked list iterator, filtering to only keep tracepoints.  */\n+\n+using tracepoint_iterator\n+  = filtered_iterator<breakpoint_iterator, tracepoint_filter>;\n+\n+/* Breakpoint linked list range, filtering to only keep tracepoints.  */\n+\n+using tracepoint_range = next_adapter<breakpoint, tracepoint_iterator>;\n+\n+/* Return a range to iterate over all tracepoints.  */\n+\n+tracepoint_range all_tracepoints ();\n+\n /* Nonzero if the specified PC cannot be a location where functions\n    have been inlined.  */\n "
    },
    {
      "sha": "4f69caf309a107ba20e4529eb24d3bd91c1025d7",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f6d17b2b1c042853b80d790b0c6a10d2b4347faa/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
      "patch": "@@ -1603,13 +1603,13 @@ start_tracing (const char *notes)\n   int any_enabled = 0, num_to_download = 0;\n   int ret;\n \n-  std::vector<breakpoint *> tp_vec = all_tracepoints ();\n+  auto tracepoint_range = all_tracepoints ();\n \n   /* No point in tracing without any tracepoints...  */\n-  if (tp_vec.empty ())\n+  if (tracepoint_range.begin () == tracepoint_range.end ())\n     error (_(\"No tracepoints defined, not starting trace\"));\n \n-  for (breakpoint *b : tp_vec)\n+  for (breakpoint *b : tracepoint_range)\n     {\n       if (b->enable_state == bp_enabled)\n \tany_enabled = 1;\n@@ -1640,7 +1640,7 @@ start_tracing (const char *notes)\n \n   target_trace_init ();\n \n-  for (breakpoint *b : tp_vec)\n+  for (breakpoint *b : tracepoint_range)\n     {\n       struct tracepoint *t = (struct tracepoint *) b;\n       struct bp_location *loc;"
    }
  ]
}