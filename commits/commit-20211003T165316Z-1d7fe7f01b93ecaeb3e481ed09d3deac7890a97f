{
  "sha": "1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
  "node_id": "C_kwDOANOeidoAKDFkN2ZlN2YwMWI5M2VjYWViM2U0ODFlZDA5ZDNkZWFjNzg5MGE5N2Y",
  "commit": {
    "author": {
      "name": "Lancelot SIX",
      "email": "lsix@lancelotsix.com",
      "date": "2021-09-13T21:32:19Z"
    },
    "committer": {
      "name": "Lancelot SIX",
      "email": "lsix@lancelotsix.com",
      "date": "2021-10-03T16:53:16Z"
    },
    "message": "gdb: Introduce setting construct within cmd_list_element\n\ncmd_list_element can contain a pointer to data that can be set and / or\nshown.  This is achieved with the void* VAR member which points to the\ndata that can be accessed, while the VAR_TYPE member (of type enum\nvar_types) indicates how to interpret the data pointed to.\n\nWith this pattern, the user of the cmd_list_element needs to know what\nis the storage type associated with a given VAR_TYPES in order to do\nthe proper casting.  No automatic safeguard is available to prevent\nmiss-use of the pointer.  Client code typically looks something like:\n\n\tswitch (c->var_type)\n\t{\n\t  case var_zuinteger:\n\t    unsigned int v = *(unsigned int*) c->var;\n\t    ...\n\t    break;\n\t  case var_boolean:\n\t    bool v = *(bool *) c->var;\n\t    ...\n\t    break;\n\t  ...\n\t}\n\nThis patch proposes to add an abstraction around the var_types and void*\npointer pair.  The abstraction is meant to prevent the user from having\nto handle the cast and verify that the data is read or written as a type\nthat is coherent with the setting's var_type.  This is achieved by\nintroducing the struct setting which exposes a set of templated get /\nset member functions.  The template parameter is the type of the\nvariable that holds the referred variable.\n\nUsing those accessors allows runtime checks to be inserted in order to\nensure that the data pointed to has the expected type.  For example,\ninstantiating the member functions with bool will yield something\nsimilar to:\n\n\tconst bool &get<bool> () const\n\t{\n\t  gdb_assert (m_var_type == var_boolean);\n\t  gdb_assert (m_var != nullptr);\n\t  return *static_cast<bool *> (m_var);\n\t}\n\tvoid set<bool> (const bool &var)\n\t{\n\t  gdb_assert (m_var_type == var_boolean);\n\t  gdb_assert (m_var != nullptr);\n\t  *static_cast<bool *> (m_var) = var;\n\t}\n\nUsing the new abstraction, our initial example becomes:\n\n\tswitch (c->var_type)\n\t{\n\t  case var_zuinteger:\n\t    unsigned int v = c->var->get<unsigned int> ();\n\t    ...\n\t    break;\n\t  case var_boolean:\n\t    bool v = c->var->get<bool> ();\n\t    ...\n\t    break;\n\t  ...\n\t}\n\nWhile the call site is still similar, the introduction of runtime checks\nhelp ensure correct usage of the data.\n\nIn order to avoid turning the bulk of add_setshow_cmd_full into a\ntemplated function, and following a suggestion from Pedro Alves, a\nsetting can be constructed from a pre validated type erased reference to\na variable.  This is what setting::erased_args is used for.\n\nIntroducing an opaque abstraction to describe a setting will also make\nit possible to use callbacks to retrieve or set the value of the setting\non the fly instead of pointing to a static chunk of memory.  This will\nbe done added in a later commit.\n\nGiven that a cmd_list_element may or may not reference a setting, the\nVAR and VAR_TYPES members of the struct are replaced with a\ngdb::optional<setting> named VAR.\n\nFew internal function signatures have been modified to take into account\nthis new abstraction:\n\n-The functions value_from_setting, str_value_from_setting and\n get_setshow_command_value_string used to have a 'cmd_list_element *'\n parameter but only used it for the VAR and VAR_TYPE member. They now\n take a 'const setting &' parameter instead.\n- Similarly, the 'void *' and a 'enum var_types' parameters of\n  pascm_param_value and gdbpy_parameter_value have been replaced with a\n  'const setting &' parameter.\n\nNo user visible change is expected after this patch.\n\nTested on GNU/Linux x86_64, with no regression noticed.\n\nCo-authored-by: Simon Marchi <simon.marchi@polymtl.ca>\nChange-Id: Ie1d08c3ceb8b30b3d7bf1efe036eb8acffcd2f34",
    "tree": {
      "sha": "18849feb1ba77bfe2be1cce3e95c75c981cec765",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/18849feb1ba77bfe2be1cce3e95c75c981cec765"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/comments",
  "author": {
    "login": "lsix",
    "id": 724339,
    "node_id": "MDQ6VXNlcjcyNDMzOQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/724339?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lsix",
    "html_url": "https://github.com/lsix",
    "followers_url": "https://api.github.com/users/lsix/followers",
    "following_url": "https://api.github.com/users/lsix/following{/other_user}",
    "gists_url": "https://api.github.com/users/lsix/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lsix/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lsix/subscriptions",
    "organizations_url": "https://api.github.com/users/lsix/orgs",
    "repos_url": "https://api.github.com/users/lsix/repos",
    "events_url": "https://api.github.com/users/lsix/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lsix/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "lsix",
    "id": 724339,
    "node_id": "MDQ6VXNlcjcyNDMzOQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/724339?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lsix",
    "html_url": "https://github.com/lsix",
    "followers_url": "https://api.github.com/users/lsix/followers",
    "following_url": "https://api.github.com/users/lsix/following{/other_user}",
    "gists_url": "https://api.github.com/users/lsix/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lsix/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lsix/subscriptions",
    "organizations_url": "https://api.github.com/users/lsix/orgs",
    "repos_url": "https://api.github.com/users/lsix/repos",
    "events_url": "https://api.github.com/users/lsix/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lsix/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "39d53d04357606a15efd400147fa7369d71baf2c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/39d53d04357606a15efd400147fa7369d71baf2c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/39d53d04357606a15efd400147fa7369d71baf2c"
    }
  ],
  "stats": {
    "total": 804,
    "additions": 547,
    "deletions": 257
  },
  "files": [
    {
      "sha": "7f0bb74c32ad918c73497b54ddb07bef1307ef4e",
      "filename": "gdb/auto-load.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/auto-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/auto-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/auto-load.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -1408,7 +1408,7 @@ set_auto_load_cmd (const char *args, int from_tty)\n \t     \"otherwise check the auto-load sub-commands.\"));\n \n   for (list = *auto_load_set_cmdlist_get (); list != NULL; list = list->next)\n-    if (list->var_type == var_boolean)\n+    if (list->var->type () == var_boolean)\n       {\n \tgdb_assert (list->type == set_cmd);\n \tdo_set_command (args, from_tty, list);"
    },
    {
      "sha": "8110f10e1e9e5c6e9b77cf68e6e985336d6a4e75",
      "filename": "gdb/bt-utils.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/bt-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/bt-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bt-utils.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -29,15 +29,13 @@ gdb_internal_backtrace_set_cmd (const char *args, int from_tty,\n \t\t\t\tcmd_list_element *c)\n {\n   gdb_assert (c->type == set_cmd);\n-  gdb_assert (c->var_type == var_boolean);\n-  gdb_assert (c->var != nullptr);\n+  gdb_assert (c->var.has_value ());\n+  gdb_assert (c->var->type () == var_boolean);\n \n #ifndef GDB_PRINT_INTERNAL_BACKTRACE\n-  bool *var_ptr = (bool *) c->var;\n-\n-  if (*var_ptr)\n+  if (c->var->get<bool> ())\n     {\n-      *var_ptr = false;\n+      c->var->set<bool> (false);\n       error (_(\"support for this feature is not compiled into GDB\"));\n     }\n #endif"
    },
    {
      "sha": "ecbe5a4b43cfa818ca3f2d7413e81109a9b33945",
      "filename": "gdb/cli/cli-cmds.c",
      "status": "modified",
      "additions": 71,
      "deletions": 44,
      "changes": 115,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-cmds.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -236,7 +236,7 @@ with_command_1 (const char *set_cmd_prefix,\n \t\t\t\t\t  /*ignore_help_classes=*/ 1);\n   gdb_assert (set_cmd != nullptr);\n \n-  if (set_cmd->var == nullptr)\n+  if (!set_cmd->var.has_value ())\n     error (_(\"Cannot use this setting with the \\\"with\\\" command\"));\n \n   std::string temp_value\n@@ -245,7 +245,8 @@ with_command_1 (const char *set_cmd_prefix,\n   if (nested_cmd == nullptr)\n     nested_cmd = skip_spaces (delim + 2);\n \n-  std::string org_value = get_setshow_command_value_string (set_cmd);\n+  gdb_assert (set_cmd->var.has_value ());\n+  std::string org_value = get_setshow_command_value_string (*set_cmd->var);\n \n   /* Tweak the setting to the new temporary value.  */\n   do_set_command (temp_value.c_str (), from_tty, set_cmd);\n@@ -2092,31 +2093,31 @@ setting_cmd (const char *fnname, struct cmd_list_element *showlist,\n /* Builds a value from the show CMD.  */\n \n static struct value *\n-value_from_setting (const cmd_list_element *cmd, struct gdbarch *gdbarch)\n+value_from_setting (const setting &var, struct gdbarch *gdbarch)\n {\n-  switch (cmd->var_type)\n+  switch (var.type ())\n     {\n     case var_integer:\n-      if (*(int *) cmd->var == INT_MAX)\n+      if (var.get<int> () == INT_MAX)\n \treturn value_from_longest (builtin_type (gdbarch)->builtin_int,\n \t\t\t\t   0);\n       else\n \treturn value_from_longest (builtin_type (gdbarch)->builtin_int,\n-\t\t\t\t   *(int *) cmd->var);\n+\t\t\t\t   var.get<int> ());\n     case var_zinteger:\n       return value_from_longest (builtin_type (gdbarch)->builtin_int,\n-\t\t\t\t *(int *) cmd->var);\n+\t\t\t\t var.get<int> ());\n     case var_boolean:\n       return value_from_longest (builtin_type (gdbarch)->builtin_int,\n-\t\t\t\t *(bool *) cmd->var ? 1 : 0);\n+\t\t\t\t var.get<bool> () ? 1 : 0);\n     case var_zuinteger_unlimited:\n       return value_from_longest (builtin_type (gdbarch)->builtin_int,\n-\t\t\t\t *(int *) cmd->var);\n+\t\t\t\t var.get<int> ());\n     case var_auto_boolean:\n       {\n \tint val;\n \n-\tswitch (*(enum auto_boolean*) cmd->var)\n+\tswitch (var.get<enum auto_boolean> ())\n \t  {\n \t  case AUTO_BOOLEAN_TRUE:\n \t    val = 1;\n@@ -2134,27 +2135,35 @@ value_from_setting (const cmd_list_element *cmd, struct gdbarch *gdbarch)\n \t\t\t\t   val);\n       }\n     case var_uinteger:\n-      if (*(unsigned int *) cmd->var == UINT_MAX)\n+      if (var.get<unsigned int> () == UINT_MAX)\n \treturn value_from_ulongest\n \t  (builtin_type (gdbarch)->builtin_unsigned_int, 0);\n       else\n \treturn value_from_ulongest\n \t  (builtin_type (gdbarch)->builtin_unsigned_int,\n-\t   *(unsigned int *) cmd->var);\n+\t   var.get<unsigned int> ());\n     case var_zuinteger:\n       return value_from_ulongest (builtin_type (gdbarch)->builtin_unsigned_int,\n-\t\t\t\t  *(unsigned int *) cmd->var);\n+\t\t\t\t  var.get<unsigned int> ());\n     case var_string:\n     case var_string_noescape:\n     case var_optional_filename:\n     case var_filename:\n     case var_enum:\n-      if (*(char **) cmd->var)\n-\treturn value_cstring (*(char **) cmd->var, strlen (*(char **) cmd->var),\n-\t\t\t      builtin_type (gdbarch)->builtin_char);\n-      else\n-\treturn value_cstring (\"\", 1,\n-\t\t\t      builtin_type (gdbarch)->builtin_char);\n+      {\n+\tconst char *value;\n+\tif (var.type () == var_enum)\n+\t  value = var.get<const char *> ();\n+\telse\n+\t  value = var.get<char *> ();\n+\n+\tif (value != nullptr)\n+\t  return value_cstring (value, strlen (value),\n+\t\t\t\tbuiltin_type (gdbarch)->builtin_char);\n+\telse\n+\t  return value_cstring (\"\", 1,\n+\t\t\t\tbuiltin_type (gdbarch)->builtin_char);\n+      }\n     default:\n       gdb_assert_not_reached (\"bad var_type\");\n     }\n@@ -2167,9 +2176,12 @@ gdb_setting_internal_fn (struct gdbarch *gdbarch,\n \t\t\t const struct language_defn *language,\n \t\t\t void *cookie, int argc, struct value **argv)\n {\n-  return value_from_setting (setting_cmd (\"$_gdb_setting\", showlist,\n-\t\t\t\t\t  argc, argv),\n-\t\t\t     gdbarch);\n+  cmd_list_element *show_cmd\n+    = setting_cmd (\"$_gdb_setting\", showlist, argc, argv);\n+\n+  gdb_assert (show_cmd->var.has_value ());\n+\n+  return value_from_setting (*show_cmd->var, gdbarch);\n }\n \n /* Implementation of the convenience function $_gdb_maint_setting.  */\n@@ -2179,18 +2191,20 @@ gdb_maint_setting_internal_fn (struct gdbarch *gdbarch,\n \t\t\t       const struct language_defn *language,\n \t\t\t       void *cookie, int argc, struct value **argv)\n {\n-  return value_from_setting (setting_cmd (\"$_gdb_maint_setting\",\n-\t\t\t\t\t  maintenance_show_cmdlist,\n-\t\t\t\t\t  argc, argv),\n-\t\t\t     gdbarch);\n+  cmd_list_element *show_cmd\n+    = setting_cmd (\"$_gdb_maint_setting\", maintenance_show_cmdlist, argc, argv);\n+\n+  gdb_assert (show_cmd->var.has_value ());\n+\n+  return value_from_setting (*show_cmd->var, gdbarch);\n }\n \n /* Builds a string value from the show CMD.  */\n \n static struct value *\n-str_value_from_setting (const cmd_list_element *cmd, struct gdbarch *gdbarch)\n+str_value_from_setting (const setting &var, struct gdbarch *gdbarch)\n {\n-  switch (cmd->var_type)\n+  switch (var.type ())\n     {\n     case var_integer:\n     case var_zinteger:\n@@ -2200,7 +2214,7 @@ str_value_from_setting (const cmd_list_element *cmd, struct gdbarch *gdbarch)\n     case var_uinteger:\n     case var_zuinteger:\n       {\n-\tstd::string cmd_val = get_setshow_command_value_string (cmd);\n+\tstd::string cmd_val = get_setshow_command_value_string (var);\n \n \treturn value_cstring (cmd_val.c_str (), cmd_val.size (),\n \t\t\t      builtin_type (gdbarch)->builtin_char);\n@@ -2213,15 +2227,22 @@ str_value_from_setting (const cmd_list_element *cmd, struct gdbarch *gdbarch)\n     case var_enum:\n       /* For these cases, we do not use get_setshow_command_value_string,\n \t as this function handle some characters specially, e.g. by\n-\t escaping quotes.  So, we directly use the cmd->var string value,\n-\t similarly to the value_from_setting code for these cases.  */\n-      if (*(char **) cmd->var)\n-\treturn value_cstring (*(char **) cmd->var, strlen (*(char **) cmd->var),\n-\t\t\t      builtin_type (gdbarch)->builtin_char);\n-      else\n-\treturn value_cstring (\"\", 1,\n-\t\t\t      builtin_type (gdbarch)->builtin_char);\n+\t escaping quotevar.  So, we directly use the var string value,\n+\t similarly to the value_from_setting code for these casevar.  */\n+      {\n+\tconst char *value;\n+\tif (var.type () == var_enum)\n+\t  value = var.get<const char *> ();\n+\telse\n+\t  value = var.get<char *> ();\n \n+\tif (value != nullptr)\n+\t  return value_cstring (value, strlen (value),\n+\t\t\t\tbuiltin_type (gdbarch)->builtin_char);\n+\telse\n+\t  return value_cstring (\"\", 1,\n+\t\t\t\tbuiltin_type (gdbarch)->builtin_char);\n+      }\n     default:\n       gdb_assert_not_reached (\"bad var_type\");\n     }\n@@ -2234,9 +2255,12 @@ gdb_setting_str_internal_fn (struct gdbarch *gdbarch,\n \t\t\t     const struct language_defn *language,\n \t\t\t     void *cookie, int argc, struct value **argv)\n {\n-  return str_value_from_setting (setting_cmd (\"$_gdb_setting_str\",\n-\t\t\t\t\t      showlist, argc, argv),\n-\t\t\t\t gdbarch);\n+  cmd_list_element *show_cmd\n+    = setting_cmd (\"$_gdb_setting_str\", showlist, argc, argv);\n+\n+  gdb_assert (show_cmd->var.has_value ());\n+\n+  return str_value_from_setting (*show_cmd->var, gdbarch);\n }\n \n \n@@ -2247,10 +2271,13 @@ gdb_maint_setting_str_internal_fn (struct gdbarch *gdbarch,\n \t\t\t\t   const struct language_defn *language,\n \t\t\t\t   void *cookie, int argc, struct value **argv)\n {\n-  return str_value_from_setting (setting_cmd (\"$_gdb_maint_setting_str\",\n-\t\t\t\t\t      maintenance_show_cmdlist,\n-\t\t\t\t\t      argc, argv),\n-\t\t\t\t gdbarch);\n+  cmd_list_element *show_cmd\n+    = setting_cmd (\"$_gdb_maint_setting_str\", maintenance_show_cmdlist, argc,\n+\t\t   argv);\n+\n+  gdb_assert (show_cmd->var.has_value ());\n+\n+  return str_value_from_setting (*show_cmd->var, gdbarch);\n }\n \n void _initialize_cli_cmds ();"
    },
    {
      "sha": "56befc979dcf2a1c4e7851766cd607eb90ba9b9a",
      "filename": "gdb/cli/cli-decode.c",
      "status": "modified",
      "additions": 87,
      "deletions": 63,
      "changes": 150,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-decode.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-decode.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -467,16 +467,16 @@ add_set_or_show_cmd (const char *name,\n \t\t     enum cmd_types type,\n \t\t     enum command_class theclass,\n \t\t     var_types var_type,\n-\t\t     void *var,\n+\t\t     const setting::erased_args &arg,\n \t\t     const char *doc,\n \t\t     struct cmd_list_element **list)\n {\n   struct cmd_list_element *c = add_cmd (name, theclass, doc, list);\n \n   gdb_assert (type == set_cmd || type == show_cmd);\n   c->type = type;\n-  c->var_type = var_type;\n-  c->var = var;\n+  c->var.emplace (var_type, arg);\n+\n   /* This needs to be something besides NULL so that this isn't\n      treated as a help class.  */\n   c->func = empty_func;\n@@ -493,15 +493,16 @@ add_set_or_show_cmd (const char *name,\n    Return the newly created set and show commands.  */\n \n static set_show_commands\n-add_setshow_cmd_full (const char *name,\n-\t\t      enum command_class theclass,\n-\t\t      var_types var_type, void *var,\n-\t\t      const char *set_doc, const char *show_doc,\n-\t\t      const char *help_doc,\n-\t\t      cmd_func_ftype *set_func,\n-\t\t      show_value_ftype *show_func,\n-\t\t      struct cmd_list_element **set_list,\n-\t\t      struct cmd_list_element **show_list)\n+add_setshow_cmd_full_erased (const char *name,\n+\t\t\t     enum command_class theclass,\n+\t\t\t     var_types var_type,\n+\t\t\t     const setting::erased_args &args,\n+\t\t\t     const char *set_doc, const char *show_doc,\n+\t\t\t     const char *help_doc,\n+\t\t\t     cmd_func_ftype *set_func,\n+\t\t\t     show_value_ftype *show_func,\n+\t\t\t     struct cmd_list_element **set_list,\n+\t\t\t     struct cmd_list_element **show_list)\n {\n   struct cmd_list_element *set;\n   struct cmd_list_element *show;\n@@ -518,14 +519,14 @@ add_setshow_cmd_full (const char *name,\n       full_set_doc = xstrdup (set_doc);\n       full_show_doc = xstrdup (show_doc);\n     }\n-  set = add_set_or_show_cmd (name, set_cmd, theclass, var_type, var,\n+  set = add_set_or_show_cmd (name, set_cmd, theclass, var_type, args,\n \t\t\t     full_set_doc, set_list);\n   set->doc_allocated = 1;\n \n   if (set_func != NULL)\n     set->func = set_func;\n \n-  show = add_set_or_show_cmd (name, show_cmd, theclass, var_type, var,\n+  show = add_set_or_show_cmd (name, show_cmd, theclass, var_type, args,\n \t\t\t      full_show_doc, show_list);\n   show->doc_allocated = 1;\n   show->show_value_func = show_func;\n@@ -536,6 +537,32 @@ add_setshow_cmd_full (const char *name,\n   return {set, show};\n }\n \n+template<typename T>\n+static set_show_commands\n+add_setshow_cmd_full (const char *name,\n+\t\t      enum command_class theclass,\n+\t\t      var_types var_type, T *var,\n+\t\t      const char *set_doc, const char *show_doc,\n+\t\t      const char *help_doc,\n+\t\t      cmd_func_ftype *set_func,\n+\t\t      show_value_ftype *show_func,\n+\t\t      struct cmd_list_element **set_list,\n+\t\t      struct cmd_list_element **show_list)\n+{\n+  auto erased_args\n+    = setting::erase_args (var_type, var);\n+\n+  return add_setshow_cmd_full_erased (name,\n+\t\t\t\t      theclass,\n+\t\t\t\t      var_type, erased_args,\n+\t\t\t\t      set_doc, show_doc,\n+\t\t\t\t      help_doc,\n+\t\t\t\t      set_func,\n+\t\t\t\t      show_func,\n+\t\t\t\t      set_list,\n+\t\t\t\t      show_list);\n+}\n+\n /* Add element named NAME to command list LIST (the list for set or\n    some sublist thereof).  CLASS is as in add_cmd.  ENUMLIST is a list\n    of strings which may follow NAME.  VAR is address of the variable\n@@ -555,10 +582,10 @@ add_setshow_enum_cmd (const char *name,\n \t\t      struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    =  add_setshow_cmd_full (name, theclass, var_enum, var,\n-\t\t\t     set_doc, show_doc, help_doc,\n-\t\t\t     set_func, show_func,\n-\t\t\t     set_list, show_list);\n+    =  add_setshow_cmd_full<const char *> (name, theclass, var_enum, var,\n+\t\t\t\t\t   set_doc, show_doc, help_doc,\n+\t\t\t\t\t   set_func, show_func,\n+\t\t\t\t\t   set_list, show_list);\n   commands.set->enums = enumlist;\n   return commands;\n }\n@@ -583,10 +610,11 @@ add_setshow_auto_boolean_cmd (const char *name,\n \t\t\t      struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_auto_boolean, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n+    = add_setshow_cmd_full<enum auto_boolean> (name, theclass,\n+\t\t\t\t\t       var_auto_boolean,var,\n+\t\t\t\t\t       set_doc, show_doc, help_doc,\n+\t\t\t\t\t       set_func, show_func,\n+\t\t\t\t\t       set_list, show_list);\n \n   commands.set->enums = auto_boolean_enums;\n \n@@ -612,10 +640,10 @@ add_setshow_boolean_cmd (const char *name, enum command_class theclass, bool *va\n \t\t\t struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_boolean, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n+    = add_setshow_cmd_full<bool> (name, theclass, var_boolean, var,\n+\t\t\t\t  set_doc, show_doc, help_doc,\n+\t\t\t\t  set_func, show_func,\n+\t\t\t\t  set_list, show_list);\n \n   commands.set->enums = boolean_enums;\n \n@@ -636,10 +664,10 @@ add_setshow_filename_cmd (const char *name, enum command_class theclass,\n \t\t\t  struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_filename, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n+    = add_setshow_cmd_full<char *> (name, theclass, var_filename, var,\n+\t\t\t\t    set_doc, show_doc, help_doc,\n+\t\t\t\t    set_func, show_func,\n+\t\t\t\t    set_list, show_list);\n \n   set_cmd_completer (commands.set, filename_completer);\n \n@@ -660,10 +688,10 @@ add_setshow_string_cmd (const char *name, enum command_class theclass,\n \t\t\tstruct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_string, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n+    = add_setshow_cmd_full<char *> (name, theclass, var_string, var,\n+\t\t\t\t    set_doc, show_doc, help_doc,\n+\t\t\t\t    set_func, show_func,\n+\t\t\t\t    set_list, show_list);\n \n   /* Disable the default symbol completer.  */\n   set_cmd_completer (commands.set, nullptr);\n@@ -685,10 +713,9 @@ add_setshow_string_noescape_cmd (const char *name, enum command_class theclass,\n \t\t\t\t struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_string_noescape, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n+    = add_setshow_cmd_full<char *> (name, theclass, var_string_noescape, var,\n+\t\t\t\t    set_doc, show_doc, help_doc, set_func,\n+\t\t\t\t    show_func, set_list, show_list);\n \n   /* Disable the default symbol completer.  */\n   set_cmd_completer (commands.set, nullptr);\n@@ -710,11 +737,10 @@ add_setshow_optional_filename_cmd (const char *name, enum command_class theclass\n \t\t\t\t   struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_optional_filename, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n-\t\t\n+    = add_setshow_cmd_full<char *> (name, theclass, var_optional_filename,\n+\t\t\t\t    var, set_doc, show_doc, help_doc,\n+\t\t\t\t    set_func, show_func, set_list, show_list);\n+\n   set_cmd_completer (commands.set, filename_completer);\n \n   return commands;\n@@ -754,10 +780,9 @@ add_setshow_integer_cmd (const char *name, enum command_class theclass,\n \t\t\t struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_integer, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n+    = add_setshow_cmd_full<int> (name, theclass, var_integer, var, set_doc,\n+\t\t\t\t show_doc, help_doc, set_func, show_func,\n+\t\t\t\t set_list, show_list);\n \n   set_cmd_completer (commands.set, integer_unlimited_completer);\n \n@@ -780,10 +805,10 @@ add_setshow_uinteger_cmd (const char *name, enum command_class theclass,\n \t\t\t  struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_uinteger, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n+    = add_setshow_cmd_full<unsigned int> (name, theclass, var_uinteger, var,\n+\t\t\t\t\t  set_doc, show_doc, help_doc,\n+\t\t\t\t\t  set_func, show_func,\n+\t\t\t\t\t  set_list, show_list);\n \n   set_cmd_completer (commands.set, integer_unlimited_completer);\n \n@@ -805,10 +830,10 @@ add_setshow_zinteger_cmd (const char *name, enum command_class theclass,\n \t\t\t  struct cmd_list_element **set_list,\n \t\t\t  struct cmd_list_element **show_list)\n {\n-  return add_setshow_cmd_full (name, theclass, var_zinteger, var,\n-\t\t\t       set_doc, show_doc, help_doc,\n-\t\t\t       set_func, show_func,\n-\t\t\t       set_list, show_list);\n+  return add_setshow_cmd_full<int> (name, theclass, var_zinteger, var,\n+\t\t\t\t    set_doc, show_doc, help_doc,\n+\t\t\t\t    set_func, show_func,\n+\t\t\t\t    set_list, show_list);\n }\n \n set_show_commands\n@@ -824,10 +849,9 @@ add_setshow_zuinteger_unlimited_cmd (const char *name,\n \t\t\t\t     struct cmd_list_element **show_list)\n {\n   set_show_commands commands\n-    = add_setshow_cmd_full (name, theclass, var_zuinteger_unlimited, var,\n-\t\t\t    set_doc, show_doc, help_doc,\n-\t\t\t    set_func, show_func,\n-\t\t\t    set_list, show_list);\n+    = add_setshow_cmd_full<int> (name, theclass, var_zuinteger_unlimited, var,\n+\t\t\t\t set_doc, show_doc, help_doc, set_func,\n+\t\t\t\t show_func, set_list, show_list);\n \n   set_cmd_completer (commands.set, integer_unlimited_completer);\n \n@@ -849,10 +873,10 @@ add_setshow_zuinteger_cmd (const char *name, enum command_class theclass,\n \t\t\t   struct cmd_list_element **set_list,\n \t\t\t   struct cmd_list_element **show_list)\n {\n-  return add_setshow_cmd_full (name, theclass, var_zuinteger, var,\n-\t\t\t       set_doc, show_doc, help_doc,\n-\t\t\t       set_func, show_func,\n-\t\t\t       set_list, show_list);\n+  return add_setshow_cmd_full<unsigned int> (name, theclass, var_zuinteger,\n+\t\t\t\t\t     var, set_doc, show_doc, help_doc,\n+\t\t\t\t\t     set_func, show_func, set_list,\n+\t\t\t\t\t     show_list);\n }\n \n /* Remove the command named NAME from the command list.  Return the"
    },
    {
      "sha": "f7945ba2bf5fd21c1d132ae1666fb7944cb6688c",
      "filename": "gdb/cli/cli-decode.h",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-decode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-decode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.h?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -55,7 +55,6 @@ struct cmd_list_element\n       allow_unknown (0),\n       abbrev_flag (0),\n       type (not_set_cmd),\n-      var_type (var_boolean),\n       doc (doc_)\n   {\n     memset (&function, 0, sizeof (function));\n@@ -160,9 +159,6 @@ struct cmd_list_element\n      or \"show\").  */\n   ENUM_BITFIELD (cmd_types) type : 2;\n \n-  /* What kind of variable is *VAR?  */\n-  ENUM_BITFIELD (var_types) var_type : 4;\n-\n   /* Function definition of this command.  NULL for command class\n      names and for help topics that are not really commands.  NOTE:\n      cagney/2002-02-02: This function signature is evolving.  For\n@@ -228,9 +224,8 @@ struct cmd_list_element\n      used to finalize the CONTEXT field, if needed.  */\n   void (*destroyer) (struct cmd_list_element *self, void *context) = nullptr;\n \n-  /* Pointer to variable affected by \"set\" and \"show\".  Doesn't\n-     matter if type is not_set.  */\n-  void *var = nullptr;\n+  /* Setting affected by \"set\" and \"show\".  Not used if type is not_set_cmd.  */\n+  gdb::optional<setting> var;\n \n   /* Pointer to NULL terminated list of enumerated values (like\n      argv).  */"
    },
    {
      "sha": "86ab553f48cc389dbe584dc9d20c3505051436de",
      "filename": "gdb/cli/cli-setshow.c",
      "status": "modified",
      "additions": 106,
      "deletions": 62,
      "changes": 168,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-setshow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-setshow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-setshow.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -130,10 +130,14 @@ deprecated_show_value_hack (struct ui_file *ignore_file,\n   /* If there's no command or value, don't try to print it out.  */\n   if (c == NULL || value == NULL)\n     return;\n+\n   /* Print doc minus \"Show \" at start.  Tell print_doc_line that\n      this is for a 'show value' prefix.  */\n   print_doc_line (gdb_stdout, c->doc + 5, true);\n-  switch (c->var_type)\n+\n+  gdb_assert (c->var.has_value ());\n+\n+  switch (c->var->type ())\n     {\n     case var_string:\n     case var_string_noescape:\n@@ -142,6 +146,7 @@ deprecated_show_value_hack (struct ui_file *ignore_file,\n     case var_enum:\n       printf_filtered ((\" is \\\"%s\\\".\\n\"), value);\n       break;\n+\n     default:\n       printf_filtered ((\" is %s.\\n\"), value);\n       break;\n@@ -312,7 +317,9 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n   if (arg == NULL)\n     arg = \"\";\n \n-  switch (c->var_type)\n+  gdb_assert (c->var.has_value ());\n+\n+  switch (c->var->type ())\n     {\n     case var_string:\n       {\n@@ -353,11 +360,12 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \t*q++ = '\\0';\n \tnewobj = (char *) xrealloc (newobj, q - newobj);\n \n-\tif (*(char **) c->var == NULL\n-\t    || strcmp (*(char **) c->var, newobj) != 0)\n+\tchar * const var = c->var->get<char *> ();\n+\tif (var == nullptr\n+\t    || strcmp (var, newobj) != 0)\n \t  {\n-\t    xfree (*(char **) c->var);\n-\t    *(char **) c->var = newobj;\n+\t    xfree (var);\n+\t    c->var->set<char *> (newobj);\n \n \t    option_changed = true;\n \t  }\n@@ -366,13 +374,17 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n       }\n       break;\n     case var_string_noescape:\n-      if (*(char **) c->var == NULL || strcmp (*(char **) c->var, arg) != 0)\n-\t{\n-\t  xfree (*(char **) c->var);\n-\t  *(char **) c->var = xstrdup (arg);\n+      {\n+\tchar * const var = c->var->get<char *> ();\n+\tif (var == nullptr\n+\t    || strcmp (var, arg) != 0)\n+\t  {\n+\t    xfree (var);\n+\t    c->var->set<char *> (xstrdup (arg));\n \n-\t  option_changed = true;\n-\t}\n+\t    option_changed = true;\n+\t  }\n+      }\n       break;\n     case var_filename:\n       if (*arg == '\\0')\n@@ -398,11 +410,12 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \telse\n \t  val = xstrdup (\"\");\n \n-\tif (*(char **) c->var == NULL\n-\t    || strcmp (*(char **) c->var, val) != 0)\n+\tchar * const var = c->var->get<char *> ();\n+\tif (var == nullptr\n+\t    || strcmp (var, val) != 0)\n \t  {\n-\t    xfree (*(char **) c->var);\n-\t    *(char **) c->var = val;\n+\t    xfree (var);\n+\t    c->var->set<char *> (val);\n \n \t    option_changed = true;\n \t  }\n@@ -416,9 +429,9 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \n \tif (val < 0)\n \t  error (_(\"\\\"on\\\" or \\\"off\\\" expected.\"));\n-\tif (val != *(bool *) c->var)\n+\tif (val != c->var->get<bool> ())\n \t  {\n-\t    *(bool *) c->var = val;\n+\t    c->var->set<bool> (val);\n \n \t    option_changed = true;\n \t  }\n@@ -428,9 +441,9 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n       {\n \tenum auto_boolean val = parse_auto_binary_operation (arg);\n \n-\tif (*(enum auto_boolean *) c->var != val)\n+\tif (c->var->get<enum auto_boolean> () != val)\n \t  {\n-\t    *(enum auto_boolean *) c->var = val;\n+\t    c->var->set<enum auto_boolean> (val);\n \n \t    option_changed = true;\n \t  }\n@@ -439,11 +452,12 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n     case var_uinteger:\n     case var_zuinteger:\n       {\n-\tunsigned int val = parse_cli_var_uinteger (c->var_type, &arg, true);\n+\tunsigned int val\n+\t  = parse_cli_var_uinteger (c->var->type (), &arg, true);\n \n-\tif (*(unsigned int *) c->var != val)\n+\tif (c->var->get<unsigned int> () != val)\n \t  {\n-\t    *(unsigned int *) c->var = val;\n+\t    c->var->set<unsigned int> (val);\n \n \t    option_changed = true;\n \t  }\n@@ -456,35 +470,35 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \n \tif (*arg == '\\0')\n \t  {\n-\t    if (c->var_type == var_integer)\n+\t    if (c->var->type () == var_integer)\n \t      error_no_arg (_(\"integer to set it to, or \\\"unlimited\\\".\"));\n \t    else\n \t      error_no_arg (_(\"integer to set it to.\"));\n \t  }\n \n-\tif (c->var_type == var_integer && is_unlimited_literal (&arg, true))\n+\tif (c->var->type () == var_integer && is_unlimited_literal (&arg, true))\n \t  val = 0;\n \telse\n \t  val = parse_and_eval_long (arg);\n \n-\tif (val == 0 && c->var_type == var_integer)\n+\tif (val == 0 && c->var->type () == var_integer)\n \t  val = INT_MAX;\n \telse if (val < INT_MIN\n \t\t /* For var_integer, don't let the user set the value\n \t\t    to INT_MAX directly, as that exposes an\n \t\t    implementation detail to the user interface.  */\n-\t\t || (c->var_type == var_integer && val >= INT_MAX)\n-\t\t || (c->var_type == var_zinteger && val > INT_MAX))\n+\t\t || (c->var->type () == var_integer && val >= INT_MAX)\n+\t\t || (c->var->type () == var_zinteger && val > INT_MAX))\n \t  error (_(\"integer %s out of range\"), plongest (val));\n \n-\tif (*(int *) c->var != val)\n+\tif (c->var->get<int> () != val)\n \t  {\n-\t    *(int *) c->var = val;\n+\t    c->var->set<int> (val);\n \n \t    option_changed = true;\n \t  }\n-\tbreak;\n       }\n+      break;\n     case var_enum:\n       {\n \tconst char *end_arg = arg;\n@@ -495,9 +509,9 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \tif (*after != '\\0')\n \t  error (_(\"Junk after item \\\"%.*s\\\": %s\"), len, arg, after);\n \n-\tif (*(const char **) c->var != match)\n+\tif (c->var->get<const char *> () != match)\n \t  {\n-\t    *(const char **) c->var = match;\n+\t    c->var->set<const char *> (match);\n \n \t    option_changed = true;\n \t  }\n@@ -507,9 +521,9 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n       {\n \tint val = parse_cli_var_zuinteger_unlimited (&arg, true);\n \n-\tif (*(int *) c->var != val)\n+\tif (c->var->get<int> () != val)\n \t  {\n-\t    *(int *) c->var = val;\n+\t    c->var->set<int> (val);\n \t    option_changed = true;\n \t  }\n       }\n@@ -578,25 +592,33 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \n       xfree (cmds);\n \n-      switch (c->var_type)\n+      switch (c->var->type ())\n \t{\n \tcase var_string:\n \tcase var_string_noescape:\n \tcase var_filename:\n \tcase var_optional_filename:\n \tcase var_enum:\n-\t  gdb::observers::command_param_changed.notify (name, *(char **) c->var);\n+\t  {\n+\t    const char *var;\n+\t    if (c->var->type () == var_enum)\n+\t      var = c->var->get<const char *> ();\n+\t    else\n+\t      var = c->var->get<char *> ();\n+\t    gdb::observers::command_param_changed.notify (name, var);\n+\t  }\n \t  break;\n \tcase var_boolean:\n \t  {\n-\t    const char *opt = *(bool *) c->var ? \"on\" : \"off\";\n+\t    const char *opt = c->var->get<bool> () ? \"on\" : \"off\";\n \n \t    gdb::observers::command_param_changed.notify (name, opt);\n \t  }\n \t  break;\n \tcase var_auto_boolean:\n \t  {\n-\t    const char *s = auto_boolean_enums[*(enum auto_boolean *) c->var];\n+\t    const char *s\n+\t      = auto_boolean_enums[c->var->get<enum auto_boolean> ()];\n \n \t    gdb::observers::command_param_changed.notify (name, s);\n \t  }\n@@ -606,7 +628,7 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \t  {\n \t    char s[64];\n \n-\t    xsnprintf (s, sizeof s, \"%u\", *(unsigned int *) c->var);\n+\t    xsnprintf (s, sizeof s, \"%u\", c->var->get<unsigned int> ());\n \t    gdb::observers::command_param_changed.notify (name, s);\n \t  }\n \t  break;\n@@ -616,7 +638,7 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \t  {\n \t    char s[64];\n \n-\t    xsnprintf (s, sizeof s, \"%d\", *(int *) c->var);\n+\t    xsnprintf (s, sizeof s, \"%d\", c->var->get<int> ());\n \t    gdb::observers::command_param_changed.notify (name, s);\n \t  }\n \t  break;\n@@ -628,28 +650,40 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n /* See cli/cli-setshow.h.  */\n \n std::string\n-get_setshow_command_value_string (const cmd_list_element *c)\n+get_setshow_command_value_string (const setting &var)\n {\n   string_file stb;\n \n-  switch (c->var_type)\n+  switch (var.type ())\n     {\n     case var_string:\n-      if (*(char **) c->var)\n-\tstb.putstr (*(char **) c->var, '\"');\n+      {\n+\tchar *value = var.get<char *> ();\n+\n+\tif (value != nullptr)\n+\t  stb.putstr (value, '\"');\n+      }\n       break;\n     case var_string_noescape:\n     case var_optional_filename:\n     case var_filename:\n     case var_enum:\n-      if (*(char **) c->var)\n-\tstb.puts (*(char **) c->var);\n+      {\n+\tconst char *value;\n+\tif (var.type () == var_enum)\n+\t  value = var.get<const char *> ();\n+\telse\n+\t  value = var.get<char *> ();\n+\n+\tif (value != nullptr)\n+\t  stb.puts (value);\n+      }\n       break;\n     case var_boolean:\n-      stb.puts (*(bool *) c->var ? \"on\" : \"off\");\n+      stb.puts (var.get<bool> () ? \"on\" : \"off\");\n       break;\n     case var_auto_boolean:\n-      switch (*(enum auto_boolean*) c->var)\n+      switch (var.get<enum auto_boolean> ())\n \t{\n \tcase AUTO_BOOLEAN_TRUE:\n \t  stb.puts (\"on\");\n@@ -667,26 +701,35 @@ get_setshow_command_value_string (const cmd_list_element *c)\n       break;\n     case var_uinteger:\n     case var_zuinteger:\n-      if (c->var_type == var_uinteger\n-\t  && *(unsigned int *) c->var == UINT_MAX)\n-\tstb.puts (\"unlimited\");\n-      else\n-\tstb.printf (\"%u\", *(unsigned int *) c->var);\n+      {\n+\tconst unsigned int value = var.get<unsigned int> ();\n+\n+\tif (var.type () == var_uinteger\n+\t    && value == UINT_MAX)\n+\t  stb.puts (\"unlimited\");\n+\telse\n+\t  stb.printf (\"%u\", value);\n+      }\n       break;\n     case var_integer:\n     case var_zinteger:\n-      if (c->var_type == var_integer\n-\t  && *(int *) c->var == INT_MAX)\n-\tstb.puts (\"unlimited\");\n-      else\n-\tstb.printf (\"%d\", *(int *) c->var);\n+      {\n+\tconst int value = var.get<int> ();\n+\n+\tif (var.type () == var_integer\n+\t    && value == INT_MAX)\n+\t  stb.puts (\"unlimited\");\n+\telse\n+\t  stb.printf (\"%d\", value);\n+      }\n       break;\n     case var_zuinteger_unlimited:\n       {\n-\tif (*(int *) c->var == -1)\n+\tconst int value = var.get<int> ();\n+\tif (value == -1)\n \t  stb.puts (\"unlimited\");\n \telse\n-\t  stb.printf (\"%d\", *(int *) c->var);\n+\t  stb.printf (\"%d\", value);\n       }\n       break;\n     default:\n@@ -708,8 +751,9 @@ do_show_command (const char *arg, int from_tty, struct cmd_list_element *c)\n   struct ui_out *uiout = current_uiout;\n \n   gdb_assert (c->type == show_cmd);\n+  gdb_assert (c->var.has_value ());\n \n-  std::string val = get_setshow_command_value_string (c);\n+  std::string val = get_setshow_command_value_string (*c->var);\n \n   /* FIXME: cagney/2005-02-10: There should be MI and CLI specific\n      versions of code to print the value out.  */"
    },
    {
      "sha": "5a8f32189faa4b67b9d03f2aa4430ae734de065e",
      "filename": "gdb/cli/cli-setshow.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-setshow.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/cli/cli-setshow.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-setshow.h?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -57,8 +57,8 @@ extern void do_set_command (const char *arg, int from_tty,\n extern void do_show_command (const char *arg, int from_tty,\n \t\t\t     struct cmd_list_element *c);\n \n-/* Get a string version of C's current value.  */\n-extern std::string get_setshow_command_value_string (const cmd_list_element *c);\n+/* Get a string version of VAR's value.  */\n+extern std::string get_setshow_command_value_string (const setting &var);\n \n extern void cmd_show_list (struct cmd_list_element *list, int from_tty);\n "
    },
    {
      "sha": "e7b81100f26e98cee7c4822b5be2edbc848bf389",
      "filename": "gdb/command.h",
      "status": "modified",
      "additions": 143,
      "deletions": 0,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/command.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/command.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/command.h?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -125,6 +125,149 @@ typedef enum var_types\n   }\n var_types;\n \n+/* Return true if a setting of type VAR_TYPE is backed with type T.\n+\n+   This function is left without definition intentionally.  This template is\n+   specialized for all valid types that are used to back var_types.  Therefore\n+   if one tries to instantiate this un-specialized template it means the T\n+   parameter is not a type used to back a var_type and it is most likely a\n+   programming error.  */\n+template<typename T>\n+bool var_type_uses (var_types var_type) = delete;\n+\n+/* Return true if a setting of type T is backed by a bool variable.  */\n+template<>\n+inline bool var_type_uses<bool> (var_types t)\n+{\n+  return t == var_boolean;\n+};\n+\n+/* Return true if a setting of type T is backed by a auto_boolean variable.\n+*/\n+template<>\n+inline bool var_type_uses<enum auto_boolean> (var_types t)\n+{\n+  return t == var_auto_boolean;\n+}\n+\n+/* Return true if a setting of type T is backed by an unsigned int variable.\n+*/\n+template<>\n+inline bool var_type_uses<unsigned int> (var_types t)\n+{\n+  return (t == var_uinteger || t == var_zinteger || t == var_zuinteger);\n+}\n+\n+/* Return true if a setting of type T is backed by an int variable.  */\n+template<>\n+inline bool var_type_uses<int> (var_types t)\n+{\n+  return (t == var_integer || t == var_zinteger\n+\t  || t == var_zuinteger_unlimited);\n+}\n+\n+/* Return true if a setting of type T is backed by a char * variable.  */\n+template<>\n+inline bool var_type_uses<char *> (var_types t)\n+{\n+  return (t == var_string || t == var_string_noescape\n+\t  || t == var_optional_filename || t == var_filename);\n+}\n+\n+/* Return true if a setting of type T is backed by a const char * variable.\n+*/\n+template<>\n+inline bool var_type_uses<const char *> (var_types t)\n+{\n+  return t == var_enum;\n+}\n+\n+/* Interface for getting and setting a setting's value.\n+\n+   The underlying data can be of any VAR_TYPES type.  */\n+struct setting\n+{\n+  /* Create a setting backed by a variable of type T.\n+\n+     Type T must match the var type VAR_TYPE (see VAR_TYPE_USES).  */\n+  template<typename T>\n+  setting (var_types var_type, T *var)\n+    : m_var_type (var_type), m_var (var)\n+  {\n+    gdb_assert (var != nullptr);\n+    gdb_assert (var_type_uses<T> (var_type));\n+  }\n+\n+  /* A setting can also be constructed with a pre-validated\n+     type-erased variable.  Use the following function to\n+     validate & type-erase said variable/function pointers.  */\n+\n+  struct erased_args\n+  {\n+    void *var;\n+  };\n+\n+  template<typename T>\n+  static erased_args erase_args (var_types var_type, T *var)\n+  {\n+    gdb_assert (var_type_uses<T> (var_type));\n+\n+    return {var};\n+  }\n+\n+  /* Create a setting backed by pre-validated type-erased args.\n+     ERASED_VAR's fields' real types must match the var type VAR_TYPE\n+     (see VAR_TYPE_USES).  */\n+  setting (var_types var_type, const erased_args &args)\n+    : m_var_type (var_type),\n+      m_var (args.var)\n+  {\n+  }\n+\n+  /* Access the type of the current setting.  */\n+  var_types type () const\n+  {\n+    return m_var_type;\n+  }\n+\n+  /* Return the current value.\n+\n+     The template parameter T is the type of the variable used to store the\n+     setting.  */\n+  template<typename T>\n+  const T &get () const\n+  {\n+    gdb_assert (var_type_uses<T> (m_var_type));\n+    gdb_assert (m_var != nullptr);\n+\n+    return *static_cast<const T *> (m_var);\n+  }\n+\n+  /* Sets the value of the setting to V.\n+\n+     The template parameter T indicates the type of the variable used to\n+     store the setting.\n+\n+     The var_type of the setting must match T.  */\n+  template<typename T>\n+  void set (const T &v)\n+  {\n+    /* Check that the current instance is of one of the supported types for\n+       this instantiation.  */\n+    gdb_assert (var_type_uses<T> (m_var_type));\n+\n+    *static_cast<T *> (m_var) = v;\n+  }\n+\n+private:\n+  /* The type of the variable M_VAR is pointing to.  */\n+  var_types m_var_type;\n+\n+  /* Pointer to the enclosed variable.  The type of the variable is encoded\n+     in M_VAR_TYPE.  */\n+  void *m_var;\n+};\n+\n /* This structure records one command'd definition.  */\n struct cmd_list_element;\n "
    },
    {
      "sha": "0ae368a1e64c4c4ae27b66253e6a7c26abe9ba16",
      "filename": "gdb/guile/scm-param.c",
      "status": "modified",
      "additions": 85,
      "deletions": 56,
      "changes": 141,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/guile/scm-param.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/guile/scm-param.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-param.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -113,6 +113,30 @@ struct param_smob\n   SCM containing_scm;\n };\n \n+/* Wraps a setting around an existing param_smob.  This abstraction\n+   is used to manipulate the value in S->VALUE in a type safe manner using\n+   the setting interface.  */\n+\n+static setting\n+make_setting (param_smob *s)\n+{\n+\n+  if (var_type_uses<bool> (s->type))\n+    return setting (s->type, &s->value.boolval);\n+  else if (var_type_uses<int> (s->type))\n+    return setting (s->type, &s->value.intval);\n+  else if (var_type_uses<auto_boolean> (s->type))\n+    return setting (s->type, &s->value.autoboolval);\n+  else if (var_type_uses<unsigned int> (s->type))\n+    return setting (s->type, &s->value.uintval);\n+  else if (var_type_uses<char *> (s->type))\n+    return setting (s->type, &s->value.stringval);\n+  else if (var_type_uses<const char *> (s->type))\n+    return setting (s->type, &s->value.cstringval);\n+  else\n+    gdb_assert_not_reached (\"unhandled var type\");\n+}\n+\n static const char param_smob_name[] = \"gdb:parameter\";\n \n /* The tag Guile knows the param smob by.  */\n@@ -133,8 +157,8 @@ static SCM unlimited_keyword;\n \n static int pascm_is_valid (param_smob *);\n static const char *pascm_param_type_name (enum var_types type);\n-static SCM pascm_param_value (enum var_types type, void *var,\n-\t\t\t      int arg_pos, const char *func_name);\n+static SCM pascm_param_value (const setting &var, int arg_pos,\n+\t\t\t      const char *func_name);\n \f\n /* Administrivia for parameter smobs.  */\n \n@@ -153,8 +177,7 @@ pascm_print_param_smob (SCM self, SCM port, scm_print_state *pstate)\n \n   gdbscm_printf (port, \" %s \", pascm_param_type_name (p_smob->type));\n \n-  value = pascm_param_value (p_smob->type, &p_smob->value,\n-\t\t\t     GDBSCM_ARG_NONE, NULL);\n+  value = pascm_param_value (make_setting (p_smob), GDBSCM_ARG_NONE, NULL);\n   scm_display (value, port);\n \n   scm_puts (\">\", port);\n@@ -444,7 +467,7 @@ add_setshow_generic (enum var_types param_type, enum command_class cmd_class,\n \t\t\t\t       show_doc, help_doc, set_func, show_func,\n \t\t\t\t       set_list, show_list);\n       /* Initialize the value, just in case.  */\n-      self->value.cstringval = self->enumeration[0];\n+      make_setting (self).set<const char *> (self->enumeration[0]);\n       break;\n \n     default:\n@@ -563,42 +586,46 @@ pascm_param_type_name (enum var_types param_type)\n }\n \n /* Return the value of a gdb parameter as a Scheme value.\n-   If TYPE is not supported, then a <gdb:exception> object is returned.  */\n+   If the var_type of VAR is not supported, then a <gdb:exception> object is\n+   returned.  */\n \n static SCM\n-pascm_param_value (enum var_types type, void *var,\n-\t\t   int arg_pos, const char *func_name)\n+pascm_param_value (const setting &var, int arg_pos, const char *func_name)\n {\n   /* Note: We *could* support var_integer here in case someone is trying to get\n      the value of a Python-created parameter (which is the only place that\n      still supports var_integer).  To further discourage its use we do not.  */\n \n-  switch (type)\n+  switch (var.type ())\n     {\n     case var_string:\n     case var_string_noescape:\n     case var_optional_filename:\n     case var_filename:\n     case var_enum:\n       {\n-\tconst char *str = *(char **) var;\n+\tconst char *str;\n+\tif (var.type () == var_enum)\n+\t  str = var.get<const char *> ();\n+\telse\n+\t  str = var.get<char *> ();\n \n-\tif (str == NULL)\n+\tif (str == nullptr)\n \t  str = \"\";\n \treturn gdbscm_scm_from_host_string (str, strlen (str));\n       }\n \n     case var_boolean:\n       {\n-\tif (* (bool *) var)\n+\tif (var.get<bool> ())\n \t  return SCM_BOOL_T;\n \telse\n \t  return SCM_BOOL_F;\n       }\n \n     case var_auto_boolean:\n       {\n-\tenum auto_boolean ab = * (enum auto_boolean *) var;\n+\tenum auto_boolean ab = var.get<enum auto_boolean> ();\n \n \tif (ab == AUTO_BOOLEAN_TRUE)\n \t  return SCM_BOOL_T;\n@@ -609,67 +636,69 @@ pascm_param_value (enum var_types type, void *var,\n       }\n \n     case var_zuinteger_unlimited:\n-      if (* (int *) var == -1)\n+      if (var.get<int> () == -1)\n \treturn unlimited_keyword;\n-      gdb_assert (* (int *) var >= 0);\n+      gdb_assert (var.get<int> () >= 0);\n       /* Fall through.  */\n     case var_zinteger:\n-      return scm_from_int (* (int *) var);\n+      return scm_from_int (var.get<int> ());\n \n     case var_uinteger:\n-      if (* (unsigned int *) var == UINT_MAX)\n+      if (var.get<unsigned int> ()== UINT_MAX)\n \treturn unlimited_keyword;\n       /* Fall through.  */\n     case var_zuinteger:\n-      return scm_from_uint (* (unsigned int *) var);\n+      return scm_from_uint (var.get<unsigned int> ());\n \n     default:\n       break;\n     }\n \n   return gdbscm_make_out_of_range_error (func_name, arg_pos,\n-\t\t\t\t\t scm_from_int (type),\n+\t\t\t\t\t scm_from_int (var.type ()),\n \t\t\t\t\t _(\"program error: unhandled type\"));\n }\n \n-/* Set the value of a parameter of type TYPE in VAR from VALUE.\n+/* Set the value of a parameter of type P_SMOB->TYPE in P_SMOB->VAR from VALUE.\n    ENUMERATION is the list of enum values for enum parameters, otherwise NULL.\n    Throws a Scheme exception if VALUE_SCM is invalid for TYPE.  */\n \n static void\n-pascm_set_param_value_x (enum var_types type, union pascm_variable *var,\n+pascm_set_param_value_x (param_smob *p_smob,\n \t\t\t const char * const *enumeration,\n \t\t\t SCM value, int arg_pos, const char *func_name)\n {\n-  switch (type)\n+  setting var = make_setting (p_smob);\n+\n+  switch (var.type ())\n     {\n     case var_string:\n     case var_string_noescape:\n     case var_optional_filename:\n     case var_filename:\n       SCM_ASSERT_TYPE (scm_is_string (value)\n-\t\t       || (type != var_filename\n+\t\t       || (var.type () != var_filename\n \t\t\t   && gdbscm_is_false (value)),\n \t\t       value, arg_pos, func_name,\n \t\t       _(\"string or #f for non-PARAM_FILENAME parameters\"));\n       if (gdbscm_is_false (value))\n \t{\n-\t  xfree (var->stringval);\n-\t  if (type == var_optional_filename)\n-\t    var->stringval = xstrdup (\"\");\n+\t  xfree (var.get<char *> ());\n+\t  if (var.type () == var_optional_filename)\n+\t    var.set<char *> (xstrdup (\"\"));\n \t  else\n-\t    var->stringval = NULL;\n+\t    var.set<char *> (nullptr);\n \t}\n       else\n \t{\n \t  SCM exception;\n \n \t  gdb::unique_xmalloc_ptr<char> string\n-\t    = gdbscm_scm_to_host_string (value, NULL, &exception);\n-\t  if (string == NULL)\n+\t    = gdbscm_scm_to_host_string (value, nullptr, &exception);\n+\t  if (string == nullptr)\n \t    gdbscm_throw (exception);\n-\t  xfree (var->stringval);\n-\t  var->stringval = string.release ();\n+\t  xfree (var.get<char *> ());\n+\t  var.set<char *> (string.release ());\n \t}\n       break;\n \n@@ -681,27 +710,27 @@ pascm_set_param_value_x (enum var_types type, union pascm_variable *var,\n \tSCM_ASSERT_TYPE (scm_is_string (value), value, arg_pos, func_name,\n \t\t       _(\"string\"));\n \tgdb::unique_xmalloc_ptr<char> str\n-\t  = gdbscm_scm_to_host_string (value, NULL, &exception);\n-\tif (str == NULL)\n+\t  = gdbscm_scm_to_host_string (value, nullptr, &exception);\n+\tif (str == nullptr)\n \t  gdbscm_throw (exception);\n \tfor (i = 0; enumeration[i]; ++i)\n \t  {\n \t    if (strcmp (enumeration[i], str.get ()) == 0)\n \t      break;\n \t  }\n-\tif (enumeration[i] == NULL)\n+\tif (enumeration[i] == nullptr)\n \t  {\n \t    gdbscm_out_of_range_error (func_name, arg_pos, value,\n \t\t\t\t       _(\"not member of enumeration\"));\n \t  }\n-\tvar->cstringval = enumeration[i];\n+\tvar.set<const char *> (enumeration[i]);\n \tbreak;\n       }\n \n     case var_boolean:\n       SCM_ASSERT_TYPE (gdbscm_is_bool (value), value, arg_pos, func_name,\n \t\t       _(\"boolean\"));\n-      var->boolval = gdbscm_is_true (value);\n+      var.set<bool> (gdbscm_is_true (value));\n       break;\n \n     case var_auto_boolean:\n@@ -710,30 +739,30 @@ pascm_set_param_value_x (enum var_types type, union pascm_variable *var,\n \t\t       value, arg_pos, func_name,\n \t\t       _(\"boolean or #:auto\"));\n       if (scm_is_eq (value, auto_keyword))\n-\tvar->autoboolval = AUTO_BOOLEAN_AUTO;\n+\tvar.set<enum auto_boolean> (AUTO_BOOLEAN_AUTO);\n       else if (gdbscm_is_true (value))\n-\tvar->autoboolval = AUTO_BOOLEAN_TRUE;\n+\tvar.set<enum auto_boolean> (AUTO_BOOLEAN_TRUE);\n       else\n-\tvar->autoboolval = AUTO_BOOLEAN_FALSE;\n+\tvar.set<enum auto_boolean> (AUTO_BOOLEAN_FALSE);\n       break;\n \n     case var_zinteger:\n     case var_uinteger:\n     case var_zuinteger:\n     case var_zuinteger_unlimited:\n-      if (type == var_uinteger\n-\t  || type == var_zuinteger_unlimited)\n+      if (var.type () == var_uinteger\n+\t  || var.type () == var_zuinteger_unlimited)\n \t{\n \t  SCM_ASSERT_TYPE (gdbscm_is_bool (value)\n \t\t\t   || scm_is_eq (value, unlimited_keyword),\n \t\t\t   value, arg_pos, func_name,\n \t\t\t   _(\"integer or #:unlimited\"));\n \t  if (scm_is_eq (value, unlimited_keyword))\n \t    {\n-\t      if (type == var_uinteger)\n-\t\tvar->intval = UINT_MAX;\n+\t      if (var.type () == var_uinteger)\n+\t\tvar.set<unsigned int> (UINT_MAX);\n \t      else\n-\t\tvar->intval = -1;\n+\t\tvar.set<int> (-1);\n \t      break;\n \t    }\n \t}\n@@ -743,25 +772,25 @@ pascm_set_param_value_x (enum var_types type, union pascm_variable *var,\n \t\t\t   _(\"integer\"));\n \t}\n \n-      if (type == var_uinteger\n-\t  || type == var_zuinteger)\n+      if (var.type () == var_uinteger\n+\t  || var.type () == var_zuinteger)\n \t{\n \t  unsigned int u = scm_to_uint (value);\n \n-\t  if (type == var_uinteger && u == 0)\n+\t  if (var.type () == var_uinteger && u == 0)\n \t    u = UINT_MAX;\n-\t  var->uintval = u;\n+\t  var.set<unsigned int> (u);\n \t}\n       else\n \t{\n \t  int i = scm_to_int (value);\n \n-\t  if (type == var_zuinteger_unlimited && i < -1)\n+\t  if (var.type () == var_zuinteger_unlimited && i < -1)\n \t    {\n \t      gdbscm_out_of_range_error (func_name, arg_pos, value,\n \t\t\t\t\t _(\"must be >= -1\"));\n \t    }\n-\t  var->intval = i;\n+\t  var.set<int> (i);\n \t}\n       break;\n \n@@ -934,7 +963,7 @@ gdbscm_make_parameter (SCM name_scm, SCM rest)\n \t  if (gdbscm_is_exception (initial_value_scm))\n \t    gdbscm_throw (initial_value_scm);\n \t}\n-      pascm_set_param_value_x (p_smob->type, &p_smob->value, enum_list,\n+      pascm_set_param_value_x (p_smob, enum_list,\n \t\t\t       initial_value_scm,\n \t\t\t       initial_value_arg_pos, FUNC_NAME);\n     }\n@@ -1030,8 +1059,7 @@ gdbscm_parameter_value (SCM self)\n       param_smob *p_smob = pascm_get_param_smob_arg_unsafe (self, SCM_ARG1,\n \t\t\t\t\t\t\t    FUNC_NAME);\n \n-      return pascm_param_value (p_smob->type, &p_smob->value,\n-\t\t\t\tSCM_ARG1, FUNC_NAME);\n+      return pascm_param_value (make_setting (p_smob), SCM_ARG1, FUNC_NAME);\n     }\n   else\n     {\n@@ -1062,13 +1090,14 @@ gdbscm_parameter_value (SCM self)\n \t  gdbscm_out_of_range_error (FUNC_NAME, SCM_ARG1, self,\n \t\t\t\t     _(\"parameter not found\"));\n \t}\n-      if (cmd->var == NULL)\n+\n+      if (!cmd->var.has_value ())\n \t{\n \t  gdbscm_out_of_range_error (FUNC_NAME, SCM_ARG1, self,\n \t\t\t\t     _(\"not a parameter\"));\n \t}\n \n-      return pascm_param_value (cmd->var_type, cmd->var, SCM_ARG1, FUNC_NAME);\n+      return pascm_param_value (*cmd->var, SCM_ARG1, FUNC_NAME);\n     }\n }\n \n@@ -1080,7 +1109,7 @@ gdbscm_set_parameter_value_x (SCM self, SCM value)\n   param_smob *p_smob = pascm_get_param_smob_arg_unsafe (self, SCM_ARG1,\n \t\t\t\t\t\t\tFUNC_NAME);\n \n-  pascm_set_param_value_x (p_smob->type, &p_smob->value, p_smob->enumeration,\n+  pascm_set_param_value_x (p_smob, p_smob->enumeration,\n \t\t\t   value, SCM_ARG2, FUNC_NAME);\n \n   return SCM_UNSPECIFIED;"
    },
    {
      "sha": "8aae53bdd657a0f01a606832bb791a61c9d5eb40",
      "filename": "gdb/maint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/maint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/maint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/maint.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -1112,7 +1112,7 @@ set_per_command_cmd (const char *args, int from_tty)\n     error (_(\"Bad value for 'mt set per-command no'.\"));\n \n   for (list = per_command_setlist; list != NULL; list = list->next)\n-    if (list->var_type == var_boolean)\n+    if (list->var->type () == var_boolean)\n       {\n \tgdb_assert (list->type == set_cmd);\n \tdo_set_command (args, from_tty, list);"
    },
    {
      "sha": "1dd716bba145227977e613e1f66108acd821d888",
      "filename": "gdb/python/py-param.c",
      "status": "modified",
      "additions": 25,
      "deletions": 1,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/python/py-param.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/python/py-param.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-param.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -88,6 +88,30 @@ struct parmpy_object\n   const char **enumeration;\n };\n \n+/* Wraps a setting around an existing parmpy_object.  This abstraction\n+   is used to manipulate the value in S->VALUE in a type safe manner using\n+   the setting interface.  */\n+\n+static setting\n+make_setting (parmpy_object *s)\n+{\n+\n+  if (var_type_uses<bool> (s->type))\n+    return setting (s->type, &s->value.boolval);\n+  else if (var_type_uses<int> (s->type))\n+    return setting (s->type, &s->value.intval);\n+  else if (var_type_uses<auto_boolean> (s->type))\n+    return setting (s->type, &s->value.autoboolval);\n+  else if (var_type_uses<unsigned int> (s->type))\n+    return setting (s->type, &s->value.uintval);\n+  else if (var_type_uses<char *> (s->type))\n+    return setting (s->type, &s->value.stringval);\n+  else if (var_type_uses<const char *> (s->type))\n+    return setting (s->type, &s->value.cstringval);\n+  else\n+    gdb_assert_not_reached (\"unhandled var type\");\n+}\n+\n extern PyTypeObject parmpy_object_type\n     CPYCHECKER_TYPE_OBJECT_FOR_TYPEDEF (\"parmpy_object\");\n \n@@ -110,7 +134,7 @@ get_attr (PyObject *obj, PyObject *attr_name)\n     {\n       parmpy_object *self = (parmpy_object *) obj;\n \n-      return gdbpy_parameter_value (self->type, &self->value);\n+      return gdbpy_parameter_value (make_setting (self));\n     }\n \n   return PyObject_GenericGetAttr (obj, attr_name);"
    },
    {
      "sha": "022d4a67172c295db3cfbf001b7aa9f095b79ddd",
      "filename": "gdb/python/python-internal.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/python/python-internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/python/python-internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/python-internal.h?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -438,7 +438,7 @@ PyObject *gdbpy_create_ptid_object (ptid_t ptid);\n PyObject *gdbpy_selected_thread (PyObject *self, PyObject *args);\n PyObject *gdbpy_selected_inferior (PyObject *self, PyObject *args);\n PyObject *gdbpy_string_to_argv (PyObject *self, PyObject *args);\n-PyObject *gdbpy_parameter_value (enum var_types type, void *var);\n+PyObject *gdbpy_parameter_value (const setting &var);\n gdb::unique_xmalloc_ptr<char> gdbpy_parse_command_name\n   (const char *name, struct cmd_list_element ***base_list,\n    struct cmd_list_element **start_list);"
    },
    {
      "sha": "a26c37352ff02d2bd2a4fabe86c852acb2667dd2",
      "filename": "gdb/python/python.c",
      "status": "modified",
      "additions": 17,
      "deletions": 12,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/python/python.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/python/python.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/python.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -449,34 +449,38 @@ python_command (const char *arg, int from_tty)\n    NULL (and set a Python exception) on error.  Helper function for\n    get_parameter.  */\n PyObject *\n-gdbpy_parameter_value (enum var_types type, void *var)\n+gdbpy_parameter_value (const setting &var)\n {\n-  switch (type)\n+  switch (var.type ())\n     {\n     case var_string:\n     case var_string_noescape:\n     case var_optional_filename:\n     case var_filename:\n     case var_enum:\n       {\n-\tconst char *str = *(char **) var;\n+\tconst char *str;\n+        if (var.type () == var_enum)\n+          str = var.get<const char *> ();\n+        else\n+          str = var.get<char *> ();\n \n-\tif (! str)\n+\tif (str == nullptr)\n \t  str = \"\";\n \treturn host_string_to_python_string (str).release ();\n       }\n \n     case var_boolean:\n       {\n-\tif (* (bool *) var)\n+\tif (var.get<bool> ())\n \t  Py_RETURN_TRUE;\n \telse\n \t  Py_RETURN_FALSE;\n       }\n \n     case var_auto_boolean:\n       {\n-\tenum auto_boolean ab = * (enum auto_boolean *) var;\n+\tenum auto_boolean ab = var.get<enum auto_boolean> ();\n \n \tif (ab == AUTO_BOOLEAN_TRUE)\n \t  Py_RETURN_TRUE;\n@@ -487,16 +491,16 @@ gdbpy_parameter_value (enum var_types type, void *var)\n       }\n \n     case var_integer:\n-      if ((* (int *) var) == INT_MAX)\n+      if (var.get<int> () == INT_MAX)\n \tPy_RETURN_NONE;\n       /* Fall through.  */\n     case var_zinteger:\n     case var_zuinteger_unlimited:\n-      return gdb_py_object_from_longest (* (int *) var).release ();\n+      return gdb_py_object_from_longest (var.get<int> ()).release ();\n \n     case var_uinteger:\n       {\n-\tunsigned int val = * (unsigned int *) var;\n+\tunsigned int val = var.get<unsigned int> ();\n \n \tif (val == UINT_MAX)\n \t  Py_RETURN_NONE;\n@@ -505,7 +509,7 @@ gdbpy_parameter_value (enum var_types type, void *var)\n \n     case var_zuinteger:\n       {\n-\tunsigned int val = * (unsigned int *) var;\n+\tunsigned int val = var.get<unsigned int> ();\n \treturn gdb_py_object_from_ulongest (val).release ();\n       }\n     }\n@@ -542,10 +546,11 @@ gdbpy_parameter (PyObject *self, PyObject *args)\n     return PyErr_Format (PyExc_RuntimeError,\n \t\t\t _(\"Could not find parameter `%s'.\"), arg);\n \n-  if (! cmd->var)\n+  if (!cmd->var.has_value ())\n     return PyErr_Format (PyExc_RuntimeError,\n \t\t\t _(\"`%s' is not a parameter.\"), arg);\n-  return gdbpy_parameter_value (cmd->var_type, cmd->var);\n+\n+  return gdbpy_parameter_value (*cmd->var);\n }\n \n /* Wrapper for target_charset.  */"
    },
    {
      "sha": "29b18c9427f67b7dc518a94002d5e886f53335ea",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=1d7fe7f01b93ecaeb3e481ed09d3deac7890a97f",
      "patch": "@@ -2239,12 +2239,13 @@ show_remote_protocol_packet_cmd (struct ui_file *file, int from_tty,\n \t\t\t\t const char *value)\n {\n   struct packet_config *packet;\n+  gdb_assert (c->var.has_value ());\n \n   for (packet = remote_protocol_packets;\n        packet < &remote_protocol_packets[PACKET_MAX];\n        packet++)\n     {\n-      if (&packet->detect == c->var)\n+      if (&packet->detect == &c->var->get<enum auto_boolean> ())\n \t{\n \t  show_packet_config_cmd (packet);\n \t  return;"
    }
  ]
}