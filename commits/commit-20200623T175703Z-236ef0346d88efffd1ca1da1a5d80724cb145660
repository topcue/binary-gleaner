{
  "sha": "236ef0346d88efffd1ca1da1a5d80724cb145660",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjM2ZWYwMzQ2ZDg4ZWZmZmQxY2ExZGExYTVkODA3MjRjYjE0NTY2MA==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-06-23T14:18:41Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-06-23T17:57:03Z"
    },
    "message": "Fix \"maint selftest\" regression, add struct scoped_mock_context\n\nThis commit:\n\n commit 3922b302645fda04da42a5279399578ae2f6206c\n Author:     Pedro Alves <palves@redhat.com>\n AuthorDate: Thu Jun 18 21:28:37 2020 +0100\n\n    Decouple inferior_ptid/inferior_thread(); dup ptids in thread list (PR 25412)\n\ncaused a regression for gdb.gdb/unittest.exp when GDB is configured\nwith --enable-targets=all.  The failure is:\n\n  gdb/thread.c:95: internal-error: thread_info* inferior_thread(): Assertion `current_thread_ != nullptr' failed.\n\nThe problem is in this line in regcache.c:cooked_read_test:\n\n  /* Switch to the mock thread.  */\n  scoped_restore restore_inferior_ptid\n    = make_scoped_restore (&inferior_ptid, mock_ptid);\n\nBoth gdbarch-selftest.c and regcache.c set up a similar mock context,\nbut the series the patch above belongs to only updated the\ngdbarch-selftest.c context to not write to inferior_ptid directly, and\nmissed updating regcache.c's.\n\nInstead of copying the fix over to regcache.c, share the mock context\nsetup code in a new RAII class, based on gdbarch-selftest.c's version.\n\nAlso remove the \"target already pushed\" error from regcache.c, like it\nhad been removed from gdbarch-selftest.c in the multi-target series.\nThat check is unnecessary because each inferior now has its own target\nstack, and the unit test pushes a target on a separate (mock)\ninferior, not the current inferior on entry.\n\ngdb/ChangeLog:\n2020-06-23  Pedro Alves  <palves@redhat.com>\n\n\t* gdbarch-selftests.c: Don't include inferior.h, gdbthread.h or\n\tprogspace-and-thread.h.  Include scoped-mock-context.h instead.\n\t(register_to_value_test): Use scoped_mock_context.\n\t* regcache.c: Include \"scoped-mock-context.h\".\n\t(cooked_read_test): Don't error out if a target is already pushed.\n\tUse scoped_mock_context.  Adjust.\n\t* scoped-mock-context.h: New file.",
    "tree": {
      "sha": "476ad3f4157021679bdb39747e460371c2d45283",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/476ad3f4157021679bdb39747e460371c2d45283"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/236ef0346d88efffd1ca1da1a5d80724cb145660",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/236ef0346d88efffd1ca1da1a5d80724cb145660",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/236ef0346d88efffd1ca1da1a5d80724cb145660",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/236ef0346d88efffd1ca1da1a5d80724cb145660/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bb8d126033bc7982808323da80ac8649e27bb3eb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb8d126033bc7982808323da80ac8649e27bb3eb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bb8d126033bc7982808323da80ac8649e27bb3eb"
    }
  ],
  "stats": {
    "total": 202,
    "additions": 109,
    "deletions": 93
  },
  "files": [
    {
      "sha": "1219f65b5afa5a4ece71ac97379f5b54c7c860d4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/236ef0346d88efffd1ca1da1a5d80724cb145660/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/236ef0346d88efffd1ca1da1a5d80724cb145660/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=236ef0346d88efffd1ca1da1a5d80724cb145660",
      "patch": "@@ -1,3 +1,13 @@\n+2020-06-23  Pedro Alves  <palves@redhat.com>\n+\n+\t* gdbarch-selftests.c: Don't include inferior.h, gdbthread.h or\n+\tprogspace-and-thread.h.  Include scoped-mock-context.h instead.\n+\t(register_to_value_test): Use scoped_mock_context.\n+\t* regcache.c: Include \"scoped-mock-context.h\".\n+\t(cooked_read_test): Don't error out if a target is already pushed.\n+\tUse scoped_mock_context.  Adjust.\n+\t* scoped-mock-context.h: New file.\n+\n 2020-06-23  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* ada-lang.c (ada_language_data): Delete la_is_string_type_p"
    },
    {
      "sha": "4f9adbd9e9c453d190e175410603ab182e8d59d2",
      "filename": "gdb/gdbarch-selftests.c",
      "status": "modified",
      "additions": 2,
      "deletions": 37,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/236ef0346d88efffd1ca1da1a5d80724cb145660/gdb/gdbarch-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/236ef0346d88efffd1ca1da1a5d80724cb145660/gdb/gdbarch-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch-selftests.c?ref=236ef0346d88efffd1ca1da1a5d80724cb145660",
      "patch": "@@ -20,14 +20,12 @@\n #include \"defs.h\"\n #include \"gdbsupport/selftest.h\"\n #include \"selftest-arch.h\"\n-#include \"inferior.h\"\n-#include \"gdbthread.h\"\n #include \"target.h\"\n #include \"test-target.h\"\n #include \"target-float.h\"\n #include \"gdbsupport/def-vector.h\"\n #include \"gdbarch.h\"\n-#include \"progspace-and-thread.h\"\n+#include \"scoped-mock-context.h\"\n \n namespace selftests {\n \n@@ -71,40 +69,7 @@ register_to_value_test (struct gdbarch *gdbarch)\n       builtin->builtin_char32,\n     };\n \n-  /* Create a mock environment.  An inferior with a thread, with a\n-     process_stratum target pushed.  */\n-\n-  test_target_ops mock_target;\n-  ptid_t mock_ptid (1, 1);\n-  program_space mock_pspace (new_address_space ());\n-  inferior mock_inferior (mock_ptid.pid ());\n-  mock_inferior.gdbarch = gdbarch;\n-  mock_inferior.aspace = mock_pspace.aspace;\n-  mock_inferior.pspace = &mock_pspace;\n-  thread_info mock_thread (&mock_inferior, mock_ptid);\n-\n-  scoped_restore_current_pspace_and_thread restore_pspace_thread;\n-\n-  scoped_restore restore_thread_list\n-    = make_scoped_restore (&mock_inferior.thread_list, &mock_thread);\n-\n-  /* Add the mock inferior to the inferior list so that look ups by\n-     target+ptid can find it.  */\n-  scoped_restore restore_inferior_list\n-    = make_scoped_restore (&inferior_list, &mock_inferior);\n-\n-  /* Switch to the mock inferior.  */\n-  switch_to_inferior_no_thread (&mock_inferior);\n-\n-  /* Push the process_stratum target so we can mock accessing\n-     registers.  */\n-  push_target (&mock_target);\n-\n-  /* Pop it again on exit (return/exception).  */\n-  SCOPE_EXIT { pop_all_targets_at_and_above (process_stratum); };\n-\n-  /* Switch to the mock thread.  */\n-  switch_to_thread (&mock_thread);\n+  scoped_mock_context<test_target_ops> mockctx (gdbarch);\n \n   struct frame_info *frame = get_current_frame ();\n   const int num_regs = gdbarch_num_cooked_regs (gdbarch);"
    },
    {
      "sha": "4ebb8cb045274be87b8e2f82598253ed40198bd8",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 15,
      "deletions": 56,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/236ef0346d88efffd1ca1da1a5d80724cb145660/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/236ef0346d88efffd1ca1da1a5d80724cb145660/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=236ef0346d88efffd1ca1da1a5d80724cb145660",
      "patch": "@@ -22,6 +22,7 @@\n #include \"gdbthread.h\"\n #include \"target.h\"\n #include \"test-target.h\"\n+#include \"scoped-mock-context.h\"\n #include \"gdbarch.h\"\n #include \"gdbcmd.h\"\n #include \"regcache.h\"\n@@ -1596,49 +1597,7 @@ class readwrite_regcache : public regcache\n static void\n cooked_read_test (struct gdbarch *gdbarch)\n {\n-  /* Error out if debugging something, because we're going to push the\n-     test target, which would pop any existing target.  */\n-  if (current_top_target ()->stratum () >= process_stratum)\n-    error (_(\"target already pushed\"));\n-\n-  /* Create a mock environment.  An inferior with a thread, with a\n-     process_stratum target pushed.  */\n-\n-  target_ops_no_register mock_target;\n-  ptid_t mock_ptid (1, 1);\n-  inferior mock_inferior (mock_ptid.pid ());\n-  address_space mock_aspace {};\n-  mock_inferior.gdbarch = gdbarch;\n-  mock_inferior.aspace = &mock_aspace;\n-  thread_info mock_thread (&mock_inferior, mock_ptid);\n-  mock_inferior.thread_list = &mock_thread;\n-\n-  /* Add the mock inferior to the inferior list so that look ups by\n-     target+ptid can find it.  */\n-  scoped_restore restore_inferior_list\n-    = make_scoped_restore (&inferior_list);\n-  inferior_list = &mock_inferior;\n-\n-  /* Switch to the mock inferior.  */\n-  scoped_restore_current_inferior restore_current_inferior;\n-  set_current_inferior (&mock_inferior);\n-\n-  /* Push the process_stratum target so we can mock accessing\n-     registers.  */\n-  push_target (&mock_target);\n-\n-  /* Pop it again on exit (return/exception).  */\n-  struct on_exit\n-  {\n-    ~on_exit ()\n-    {\n-      pop_all_targets_at_and_above (process_stratum);\n-    }\n-  } pop_targets;\n-\n-  /* Switch to the mock thread.  */\n-  scoped_restore restore_inferior_ptid\n-    = make_scoped_restore (&inferior_ptid, mock_ptid);\n+  scoped_mock_context<target_ops_no_register> mockctx (gdbarch);\n \n   /* Test that read one raw register from regcache_no_target will go\n      to the target layer.  */\n@@ -1653,21 +1612,21 @@ cooked_read_test (struct gdbarch *gdbarch)\n \tbreak;\n     }\n \n-  readwrite_regcache readwrite (&mock_target, gdbarch);\n+  readwrite_regcache readwrite (&mockctx.mock_target, gdbarch);\n   gdb::def_vector<gdb_byte> buf (register_size (gdbarch, nonzero_regnum));\n \n   readwrite.raw_read (nonzero_regnum, buf.data ());\n \n   /* raw_read calls target_fetch_registers.  */\n-  SELF_CHECK (mock_target.fetch_registers_called > 0);\n-  mock_target.reset ();\n+  SELF_CHECK (mockctx.mock_target.fetch_registers_called > 0);\n+  mockctx.mock_target.reset ();\n \n   /* Mark all raw registers valid, so the following raw registers\n      accesses won't go to target.  */\n   for (auto i = 0; i < gdbarch_num_regs (gdbarch); i++)\n     readwrite.raw_update (i);\n \n-  mock_target.reset ();\n+  mockctx.mock_target.reset ();\n   /* Then, read all raw and pseudo registers, and don't expect calling\n      to_{fetch,store}_registers.  */\n   for (int regnum = 0; regnum < gdbarch_num_cooked_regs (gdbarch); regnum++)\n@@ -1680,18 +1639,18 @@ cooked_read_test (struct gdbarch *gdbarch)\n       SELF_CHECK (REG_VALID == readwrite.cooked_read (regnum,\n \t\t\t\t\t\t      inner_buf.data ()));\n \n-      SELF_CHECK (mock_target.fetch_registers_called == 0);\n-      SELF_CHECK (mock_target.store_registers_called == 0);\n-      SELF_CHECK (mock_target.xfer_partial_called == 0);\n+      SELF_CHECK (mockctx.mock_target.fetch_registers_called == 0);\n+      SELF_CHECK (mockctx.mock_target.store_registers_called == 0);\n+      SELF_CHECK (mockctx.mock_target.xfer_partial_called == 0);\n \n-      mock_target.reset ();\n+      mockctx.mock_target.reset ();\n     }\n \n   readonly_detached_regcache readonly (readwrite);\n \n   /* GDB may go to target layer to fetch all registers and memory for\n      readonly regcache.  */\n-  mock_target.reset ();\n+  mockctx.mock_target.reset ();\n \n   for (int regnum = 0; regnum < gdbarch_num_cooked_regs (gdbarch); regnum++)\n     {\n@@ -1749,11 +1708,11 @@ cooked_read_test (struct gdbarch *gdbarch)\n \t    }\n \t}\n \n-      SELF_CHECK (mock_target.fetch_registers_called == 0);\n-      SELF_CHECK (mock_target.store_registers_called == 0);\n-      SELF_CHECK (mock_target.xfer_partial_called == 0);\n+      SELF_CHECK (mockctx.mock_target.fetch_registers_called == 0);\n+      SELF_CHECK (mockctx.mock_target.store_registers_called == 0);\n+      SELF_CHECK (mockctx.mock_target.xfer_partial_called == 0);\n \n-      mock_target.reset ();\n+      mockctx.mock_target.reset ();\n     }\n }\n "
    },
    {
      "sha": "461c2a353881136f1613c43edc430e4659215257",
      "filename": "gdb/scoped-mock-context.h",
      "status": "added",
      "additions": 82,
      "deletions": 0,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/236ef0346d88efffd1ca1da1a5d80724cb145660/gdb/scoped-mock-context.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/236ef0346d88efffd1ca1da1a5d80724cb145660/gdb/scoped-mock-context.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/scoped-mock-context.h?ref=236ef0346d88efffd1ca1da1a5d80724cb145660",
      "patch": "@@ -0,0 +1,82 @@\n+/* RAII type to create a temporary mock context.\n+\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef SCOPED_MOCK_CONTEXT_H\n+#define SCOPED_MOCK_CONTEXT_H\n+\n+#include \"inferior.h\"\n+#include \"gdbthread.h\"\n+#include \"progspace.h\"\n+#include \"progspace-and-thread.h\"\n+\n+#if GDB_SELF_TEST\n+namespace selftests {\n+\n+/* RAII type to create (and switch to) a temporary mock context.  An\n+   inferior with a thread, with a process_stratum target pushed.  */\n+\n+template<typename Target>\n+struct scoped_mock_context\n+{\n+  /* Order here is important.  */\n+\n+  Target mock_target;\n+  ptid_t mock_ptid {1, 1};\n+  program_space mock_pspace {new_address_space ()};\n+  inferior mock_inferior {mock_ptid.pid ()};\n+  thread_info mock_thread {&mock_inferior, mock_ptid};\n+\n+  scoped_restore_current_pspace_and_thread restore_pspace_thread;\n+\n+  scoped_restore_tmpl<thread_info *> restore_thread_list\n+    {&mock_inferior.thread_list, &mock_thread};\n+\n+  /* Add the mock inferior to the inferior list so that look ups by\n+     target+ptid can find it.  */\n+  scoped_restore_tmpl<inferior *> restore_inferior_list\n+    {&inferior_list, &mock_inferior};\n+\n+  explicit scoped_mock_context (gdbarch *gdbarch)\n+  {\n+    mock_inferior.gdbarch = gdbarch;\n+    mock_inferior.aspace = mock_pspace.aspace;\n+    mock_inferior.pspace = &mock_pspace;\n+\n+    /* Switch to the mock inferior.  */\n+    switch_to_inferior_no_thread (&mock_inferior);\n+\n+    /* Push the process_stratum target so we can mock accessing\n+       registers.  */\n+    gdb_assert (mock_target.stratum () == process_stratum);\n+    push_target (&mock_target);\n+\n+    /* Switch to the mock thread.  */\n+    switch_to_thread (&mock_thread);\n+  }\n+\n+  ~scoped_mock_context ()\n+  {\n+    pop_all_targets_at_and_above (process_stratum);\n+  }\n+};\n+\n+} // namespace selftests\n+#endif /* GDB_SELF_TEST */\n+\n+#endif /* !defined (SCOPED_MOCK_CONTEXT_H) */"
    }
  ]
}