{
  "sha": "0c1e6e265b276542ccb3f392c3070c3dd9339303",
  "node_id": "C_kwDOANOeidoAKDBjMWU2ZTI2NWIyNzY1NDJjY2IzZjM5MmMzMDcwYzNkZDkzMzkzMDM",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-24T11:15:55Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-25T09:54:58Z"
    },
    "message": "gdb: introduce a new overload of target_can_async_p\n\nThere are a few places where we call the target_ops::can_async_p\nmember function directly, instead of using the target_can_async_p\nwrapper.\n\nIn some of these places this is because we need to ask before the\ntarget has been pushed, and in another location (in target.c) it seems\nunnecessary to go through the wrapper when we are already in target.c\ncode.\n\nHowever, in the next commit I'd like to hoist some common checks out\nof target specific code into target.c.  To achieve this, in this\ncommit, I introduce a new overload of target_can_async_p which takes a\ntarget_ops pointer, and calls the ::can_async_p method directly.  I\nthen make use of the new overload where appropriate.\n\nThere should be no user visible changes after this commit.",
    "tree": {
      "sha": "3b45413e28d99ab95b068db30e0365c6c9ebc5ad",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3b45413e28d99ab95b068db30e0365c6c9ebc5ad"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0c1e6e265b276542ccb3f392c3070c3dd9339303",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0c1e6e265b276542ccb3f392c3070c3dd9339303",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0c1e6e265b276542ccb3f392c3070c3dd9339303",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0c1e6e265b276542ccb3f392c3070c3dd9339303/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "eec685f8a6e1a654bb82b0f20134689861589866",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/eec685f8a6e1a654bb82b0f20134689861589866",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/eec685f8a6e1a654bb82b0f20134689861589866"
    }
  ],
  "stats": {
    "total": 22,
    "additions": 17,
    "deletions": 5
  },
  "files": [
    {
      "sha": "984ce4e042ba0d782979a6181a307b02aef3f392",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0c1e6e265b276542ccb3f392c3070c3dd9339303/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0c1e6e265b276542ccb3f392c3070c3dd9339303/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=0c1e6e265b276542ccb3f392c3070c3dd9339303",
      "patch": "@@ -336,7 +336,7 @@ prepare_execution_command (struct target_ops *target, int background)\n {\n   /* If we get a request for running in the bg but the target\n      doesn't support it, error out.  */\n-  if (background && !target->can_async_p ())\n+  if (background && !target_can_async_p (target))\n     error (_(\"Asynchronous execution not supported on this target.\"));\n \n   if (!background)"
    },
    {
      "sha": "311697b2d58ebbfb0d7dc3e7f88939c23e58b87f",
      "filename": "gdb/mi/mi-main.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0c1e6e265b276542ccb3f392c3070c3dd9339303/gdb/mi/mi-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0c1e6e265b276542ccb3f392c3070c3dd9339303/gdb/mi/mi-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.c?ref=0c1e6e265b276542ccb3f392c3070c3dd9339303",
      "patch": "@@ -408,7 +408,7 @@ run_one_inferior (inferior *inf, bool start_p)\n {\n   const char *run_cmd = start_p ? \"start\" : \"run\";\n   struct target_ops *run_target = find_run_target ();\n-  int async_p = mi_async && run_target->can_async_p ();\n+  int async_p = mi_async && target_can_async_p (run_target);\n \n   if (inf->pid != 0)\n     {\n@@ -473,7 +473,7 @@ mi_cmd_exec_run (const char *command, char **argv, int argc)\n     {\n       const char *run_cmd = start_p ? \"start\" : \"run\";\n       struct target_ops *run_target = find_run_target ();\n-      int async_p = mi_async && run_target->can_async_p ();\n+      int async_p = mi_async && target_can_async_p (run_target);\n \n       mi_execute_cli_command (run_cmd, async_p,\n \t\t\t      async_p ? \"&\" : NULL);"
    },
    {
      "sha": "970e2a784b59dc87039d4a53f59d97582a72b4a2",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 10,
      "deletions": 2,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0c1e6e265b276542ccb3f392c3070c3dd9339303/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0c1e6e265b276542ccb3f392c3070c3dd9339303/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=0c1e6e265b276542ccb3f392c3070c3dd9339303",
      "patch": "@@ -391,7 +391,15 @@ target_can_lock_scheduler ()\n bool\n target_can_async_p ()\n {\n-  return current_inferior ()->top_target ()->can_async_p ();\n+  return target_can_async_p (current_inferior ()->top_target ());\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_can_async_p (struct target_ops *target)\n+{\n+  return target->can_async_p ();\n }\n \n /* See target.h.  */\n@@ -2602,7 +2610,7 @@ target_wait (ptid_t ptid, struct target_waitstatus *status,\n \n   gdb_assert (!proc_target->commit_resumed_state);\n \n-  if (!target->can_async_p ())\n+  if (!target_can_async_p (target))\n     gdb_assert ((options & TARGET_WNOHANG) == 0);\n \n   return target->wait (ptid, status, options);"
    },
    {
      "sha": "e709b7d7cfdcf3517537fd6ca633bb7373241380",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0c1e6e265b276542ccb3f392c3070c3dd9339303/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0c1e6e265b276542ccb3f392c3070c3dd9339303/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=0c1e6e265b276542ccb3f392c3070c3dd9339303",
      "patch": "@@ -1886,6 +1886,10 @@ extern bool target_async_permitted;\n /* Can the target support asynchronous execution?  */\n extern bool target_can_async_p ();\n \n+/* An overload of the above that can be called when the target is not yet\n+   pushed, this calls TARGET::can_async_p directly.  */\n+extern bool target_can_async_p (struct target_ops *target);\n+\n /* Is the target in asynchronous execution mode?  */\n extern bool target_is_async_p ();\n "
    }
  ]
}