{
  "sha": "b585e899960202fbe3c137cbf765f75b088592fe",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjU4NWU4OTk5NjAyMDJmYmUzYzEzN2NiZjc2NWY3NWIwODg1OTJmZQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-04-12T07:46:58Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-04-12T11:49:02Z"
    },
    "message": "elf_backend_archive_symbol_lookup\n\nelf_backend_archive_symbol_lookup might be called when the linker hash\ntable has entries of type generic_link_hash_entry.  This happens for\ninstance when running the mmix target linker testsuite where the\noutput is mmo but input is elf64-mmix.\n\n\t* elf-bfd.h (struct elf_backend_data): Return bfd_link_hash_entry*\n\tfrom elf_backend_archive_symbol_lookup.\n\t(_bfd_elf_archive_symbol_lookup): Return bfd_link_hash_entry*.\n\t* elf64-ppc.c (ppc64_elf_archive_symbol_lookup): Likewise.  Check\n\twe have a ppc_hash_table before accessing ppc_link_hash_entry\n\tfields.\n\t* elflink.c (_bfd_elf_archive_symbol_lookup): Return\n\tbfd_link_hash_entry*.\n\t(elf_link_add_archive_symbols): Adjust to suit.",
    "tree": {
      "sha": "fe63d180fe988f6a6cd54eea6706eac2ae792328",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fe63d180fe988f6a6cd54eea6706eac2ae792328"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b585e899960202fbe3c137cbf765f75b088592fe",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b585e899960202fbe3c137cbf765f75b088592fe",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b585e899960202fbe3c137cbf765f75b088592fe",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b585e899960202fbe3c137cbf765f75b088592fe/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f5b10973531cdda7e1aba7496f70476b5146fcf8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5b10973531cdda7e1aba7496f70476b5146fcf8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f5b10973531cdda7e1aba7496f70476b5146fcf8"
    }
  ],
  "stats": {
    "total": 53,
    "additions": 33,
    "deletions": 20
  },
  "files": [
    {
      "sha": "68224f86fe90f794853a8b60c69d21f6f5a1f21d",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b585e899960202fbe3c137cbf765f75b088592fe/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b585e899960202fbe3c137cbf765f75b088592fe/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=b585e899960202fbe3c137cbf765f75b088592fe",
      "patch": "@@ -1,3 +1,15 @@\n+2021-04-12  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf-bfd.h (struct elf_backend_data): Return bfd_link_hash_entry*\n+\tfrom elf_backend_archive_symbol_lookup.\n+\t(_bfd_elf_archive_symbol_lookup): Return bfd_link_hash_entry*.\n+\t* elf64-ppc.c (ppc64_elf_archive_symbol_lookup): Likewise.  Check\n+\twe have a ppc_hash_table before accessing ppc_link_hash_entry\n+\tfields.\n+\t* elflink.c (_bfd_elf_archive_symbol_lookup): Return\n+\tbfd_link_hash_entry*.\n+\t(elf_link_add_archive_symbols): Adjust to suit.\n+\n 2021-04-12  Nelson Chu  <nelson.chu@sifive.com>\n \n \t* elfxx-riscv.c (riscv_parse_std_ext): Fixed the wrong versions of"
    },
    {
      "sha": "6f9d7375eaf4db2067081b45f643d57a4b15dec4",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b585e899960202fbe3c137cbf765f75b088592fe/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b585e899960202fbe3c137cbf765f75b088592fe/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=b585e899960202fbe3c137cbf765f75b088592fe",
      "patch": "@@ -975,7 +975,7 @@ struct elf_backend_data\n \n   /* A function to return the linker hash table entry of a symbol that\n      might be satisfied by an archive symbol.  */\n-  struct elf_link_hash_entry * (*elf_backend_archive_symbol_lookup)\n+  struct bfd_link_hash_entry * (*elf_backend_archive_symbol_lookup)\n     (bfd *, struct bfd_link_info *, const char *);\n \n   /* Return true if local section symbols should have a non-null st_name.\n@@ -2581,7 +2581,7 @@ extern bool _bfd_elf_relocs_compatible\n extern bool _bfd_elf_notice_as_needed\n   (bfd *, struct bfd_link_info *, enum notice_asneeded_action);\n \n-extern struct elf_link_hash_entry *_bfd_elf_archive_symbol_lookup\n+extern struct bfd_link_hash_entry *_bfd_elf_archive_symbol_lookup\n   (bfd *, struct bfd_link_info *, const char *);\n extern bool bfd_elf_link_add_symbols\n   (bfd *, struct bfd_link_info *);"
    },
    {
      "sha": "7873f97ab32fd4b2c71b7857c08075e4cb5c82d1",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b585e899960202fbe3c137cbf765f75b088592fe/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b585e899960202fbe3c137cbf765f75b088592fe/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=b585e899960202fbe3c137cbf765f75b088592fe",
      "patch": "@@ -4196,20 +4196,21 @@ ppc64_elf_merge_symbol (struct elf_link_hash_entry *h,\n    NAME is a symbol defined in an archive.  Return a symbol in the hash\n    table that might be satisfied by the archive symbols.  */\n \n-static struct elf_link_hash_entry *\n+static struct bfd_link_hash_entry *\n ppc64_elf_archive_symbol_lookup (bfd *abfd,\n \t\t\t\t struct bfd_link_info *info,\n \t\t\t\t const char *name)\n {\n-  struct elf_link_hash_entry *h;\n+  struct bfd_link_hash_entry *h;\n   char *dot_name;\n   size_t len;\n \n   h = _bfd_elf_archive_symbol_lookup (abfd, info, name);\n   if (h != NULL\n+      && ppc_hash_table (info) != NULL\n       /* Don't return this sym if it is a fake function descriptor\n \t created by add_symbol_adjust.  */\n-      && !ppc_elf_hash_entry (h)->fake)\n+      && !((struct ppc_link_hash_entry *) h)->fake)\n     return h;\n \n   if (name[0] == '.')\n@@ -4218,7 +4219,7 @@ ppc64_elf_archive_symbol_lookup (bfd *abfd,\n   len = strlen (name);\n   dot_name = bfd_alloc (abfd, len + 2);\n   if (dot_name == NULL)\n-    return (struct elf_link_hash_entry *) -1;\n+    return (struct bfd_link_hash_entry *) -1;\n   dot_name[0] = '.';\n   memcpy (dot_name + 1, name, len + 1);\n   h = _bfd_elf_archive_symbol_lookup (abfd, info, dot_name);"
    },
    {
      "sha": "3acf7951b5bd07efe653aefa85b7df1c69b82f0d",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b585e899960202fbe3c137cbf765f75b088592fe/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b585e899960202fbe3c137cbf765f75b088592fe/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=b585e899960202fbe3c137cbf765f75b088592fe",
      "patch": "@@ -5742,16 +5742,16 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n /* Return the linker hash table entry of a symbol that might be\n    satisfied by an archive symbol.  Return -1 on error.  */\n \n-struct elf_link_hash_entry *\n+struct bfd_link_hash_entry *\n _bfd_elf_archive_symbol_lookup (bfd *abfd,\n \t\t\t\tstruct bfd_link_info *info,\n \t\t\t\tconst char *name)\n {\n-  struct elf_link_hash_entry *h;\n+  struct bfd_link_hash_entry *h;\n   char *p, *copy;\n   size_t len, first;\n \n-  h = elf_link_hash_lookup (elf_hash_table (info), name, false, false, true);\n+  h = bfd_link_hash_lookup (info->hash, name, false, false, true);\n   if (h != NULL)\n     return h;\n \n@@ -5768,20 +5768,19 @@ _bfd_elf_archive_symbol_lookup (bfd *abfd,\n   len = strlen (name);\n   copy = (char *) bfd_alloc (abfd, len);\n   if (copy == NULL)\n-    return (struct elf_link_hash_entry *) -1;\n+    return (struct bfd_link_hash_entry *) -1;\n \n   first = p - name + 1;\n   memcpy (copy, name, first);\n   memcpy (copy + first, name + first + 1, len - first);\n \n-  h = elf_link_hash_lookup (elf_hash_table (info), copy, false, false, true);\n+  h = bfd_link_hash_lookup (info->hash, copy, false, false, true);\n   if (h == NULL)\n     {\n       /* We also need to check references to the symbol without the\n \t version.  */\n       copy[first - 1] = '\\0';\n-      h = elf_link_hash_lookup (elf_hash_table (info), copy,\n-\t\t\t\tfalse, false, true);\n+      h = bfd_link_hash_lookup (info->hash, copy, false, false, true);\n     }\n \n   bfd_release (abfd, copy);\n@@ -5810,7 +5809,7 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)\n   bool loop;\n   size_t amt;\n   const struct elf_backend_data *bed;\n-  struct elf_link_hash_entry * (*archive_symbol_lookup)\n+  struct bfd_link_hash_entry * (*archive_symbol_lookup)\n     (bfd *, struct bfd_link_info *, const char *);\n \n   if (! bfd_has_map (abfd))\n@@ -5851,7 +5850,7 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)\n       symdefend = symdef + c;\n       for (i = 0; symdef < symdefend; symdef++, i++)\n \t{\n-\t  struct elf_link_hash_entry *h;\n+\t  struct bfd_link_hash_entry *h;\n \t  bfd *element;\n \t  struct bfd_link_hash_entry *undefs_tail;\n \t  symindex mark;\n@@ -5865,21 +5864,22 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)\n \t    }\n \n \t  h = archive_symbol_lookup (abfd, info, symdef->name);\n-\t  if (h == (struct elf_link_hash_entry *) -1)\n+\t  if (h == (struct bfd_link_hash_entry *) -1)\n \t    goto error_return;\n \n \t  if (h == NULL)\n \t    continue;\n \n-\t  if (h->root.type == bfd_link_hash_undefined)\n+\t  if (h->type == bfd_link_hash_undefined)\n \t    {\n \t      /* If the archive element has already been loaded then one\n \t\t of the symbols defined by that element might have been\n \t\t made undefined due to being in a discarded section.  */\n-\t      if (h->indx == -3)\n+\t      if (is_elf_hash_table (info->hash)\n+\t\t  && ((struct elf_link_hash_entry *) h)->indx == -3)\n \t\tcontinue;\n \t    }\n-\t  else if (h->root.type == bfd_link_hash_common)\n+\t  else if (h->type == bfd_link_hash_common)\n \t    {\n \t      /* We currently have a common symbol.  The archive map contains\n \t\t a reference to this symbol, so we may want to include it.  We\n@@ -5898,7 +5898,7 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)\n \t    }\n \t  else\n \t    {\n-\t      if (h->root.type != bfd_link_hash_undefweak)\n+\t      if (h->type != bfd_link_hash_undefweak)\n \t\t/* Symbol must be defined.  Don't check it again.  */\n \t\tincluded[i] = true;\n \t      continue;"
    }
  ]
}