{
  "sha": "d750c713c9a34c8835e8e60370708cae675edb40",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDc1MGM3MTNjOWEzNGM4ODM1ZThlNjAzNzA3MDhjYWU2NzVlZGI0MA==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-01-05T12:36:09Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-01-05T12:36:09Z"
    },
    "message": "Update libiberty with latest sources from gcc mainline",
    "tree": {
      "sha": "5698bd80d455c9662f4c7fe90d580c38bce7798b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5698bd80d455c9662f4c7fe90d580c38bce7798b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d750c713c9a34c8835e8e60370708cae675edb40",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d750c713c9a34c8835e8e60370708cae675edb40",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d750c713c9a34c8835e8e60370708cae675edb40",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d750c713c9a34c8835e8e60370708cae675edb40/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5f8c2a1507c052384ce700ad7c7fb9c0c10a2421",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f8c2a1507c052384ce700ad7c7fb9c0c10a2421",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5f8c2a1507c052384ce700ad7c7fb9c0c10a2421"
    }
  ],
  "stats": {
    "total": 1543,
    "additions": 1467,
    "deletions": 76
  },
  "files": [
    {
      "sha": "7e57a54dbb142d7da57ae526d415624085437d2f",
      "filename": "ChangeLog",
      "status": "modified",
      "additions": 86,
      "deletions": 0,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ChangeLog?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -1,3 +1,89 @@\n+2021-01-05  Nick Clifton  <nickc@redhat.com>\n+\n+\t* libiberty: Sync with gcc.  Bring in:\n+\t2021-01-04  Martin Liska  <mliska@suse.cz>\n+\n+\t* strverscmp.c: Convert to utf8 from iso8859.\n+\n+\t2020-12-22  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/67343\n+\t* cp-demangle.h (struct d_info): Add unresolved_name_state.\n+\t* cp-demangle.c (d_prefix): Add subst parm.\n+\t(d_nested_name): Pass it.\n+\t(d_unresolved_name): Split out from...\n+\t(d_expression_1): ...here.\n+\t(d_demangle_callback): Maybe retry with old sr mangling.\n+\t* testsuite/demangle-expected: Add test.\n+\n+\t2020-12-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_expression_1): Recognize qualified-id\n+\ton RHS of dt/pt.\n+\t* testsuite/demangle-expected: Add test.\n+\n+\t2020-12-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_unqualified_name): Clear is_expression.\n+\t* testsuite/demangle-expected: Add tests.\n+\n+\t2020-11-25  Matthew Malcomson  <matthew.malcomson@arm.com>\n+\n+\t* configure: Regenerate.\n+\t* configure.ac: Avoid using sanitizer.\n+\n+\t2020-11-13  Eduard-Mihai Burtescu  <eddyb@lyken.rs>\n+\n+\t* rust-demangle.c (struct rust_demangler): Add\n+\tskipping_printing and bound_lifetime_depth fields.\n+\t(eat): Add (v0-only).\n+\t(parse_integer_62): Add (v0-only).\n+\t(parse_opt_integer_62): Add (v0-only).\n+\t(parse_disambiguator): Add (v0-only).\n+\t(struct rust_mangled_ident): Add punycode{,_len} fields.\n+\t(parse_ident): Support v0 identifiers.\n+\t(print_str): Respect skipping_printing.\n+\t(print_uint64): Add (v0-only).\n+\t(print_uint64_hex): Add (v0-only).\n+\t(print_ident): Respect skipping_printing,\n+\tSupport v0 identifiers.\n+\t(print_lifetime_from_index): Add (v0-only).\n+\t(demangle_binder): Add (v0-only).\n+\t(demangle_path): Add (v0-only).\n+\t(demangle_generic_arg): Add (v0-only).\n+\t(demangle_type): Add (v0-only).\n+\t(demangle_path_maybe_open_generics): Add (v0-only).\n+\t(demangle_dyn_trait): Add (v0-only).\n+\t(demangle_const): Add (v0-only).\n+\t(demangle_const_uint): Add (v0-only).\n+\t(basic_type): Add (v0-only).\n+\t(rust_demangle_callback): Support v0 symbols.\n+\t* testsuite/rust-demangle-expected: Add v0 testcases.\n+\n+\t2020-11-13  Seija Kijin  <doremylover456@gmail.com>\n+\n+\t* strstr.c (strstr): Make implementation ANSI/POSIX compliant.\n+\n+\t2020-11-11  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/88115\n+\t* cp-demangle.c (d_print_comp_inner)\n+\t<case DEMANGLE_COMPONENT_EXTENDED_OPERATOR>: Don't print the\n+\t\"operator \" prefix for __alignof__.\n+\t<case DEMANGLE_COMPONENT_UNARY>: Always print parens around the\n+\toperand of __alignof__.\n+\t* testsuite/demangle-expected: Test demangling for __alignof__.\n+\n+\t2020-11-09  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* pex-win32.c (pex_win32_exec_child): Initialize orig_err.\n+\n+\t2020-10-06  Martin Liska  <mliska@suse.cz>\n+\n+\tPR lto/97290\n+\t* simple-object-elf.c (simple_object_elf_copy_lto_debug_sections):\n+\tUse sh_link of a .symtab_shndx section.\n+\n 2021-01-05  Alan Modra  <amodra@gmail.com>\n \n \t* config.guess: Import from upstream."
    },
    {
      "sha": "a6f82ef6ec9daa5331b711fb63a1a3c81b56cb50",
      "filename": "libiberty/ChangeLog",
      "status": "modified",
      "additions": 101,
      "deletions": 16,
      "changes": 117,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/ChangeLog?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -1,23 +1,98 @@\n-2020-09-23  Mark Wielaard  <mark@klomp.org>\n+2021-01-04  Martin Liska  <mliska@suse.cz>\n+\n+\t* strverscmp.c: Convert to utf8 from iso8859.\n+\n+2020-12-22  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/67343\n+\t* cp-demangle.h (struct d_info): Add unresolved_name_state.\n+\t* cp-demangle.c (d_prefix): Add subst parm.\n+\t(d_nested_name): Pass it.\n+\t(d_unresolved_name): Split out from...\n+\t(d_expression_1): ...here.\n+\t(d_demangle_callback): Maybe retry with old sr mangling.\n+\t* testsuite/demangle-expected: Add test.\n+\n+2020-12-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_expression_1): Recognize qualified-id\n+\ton RHS of dt/pt.\n+\t* testsuite/demangle-expected: Add test.\n+\n+2020-12-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_unqualified_name): Clear is_expression.\n+\t* testsuite/demangle-expected: Add tests.\n+\n+2020-11-25  Matthew Malcomson  <matthew.malcomson@arm.com>\n+\n+\t* configure: Regenerate.\n+\t* configure.ac: Avoid using sanitizer.\n+\n+2020-11-13  Eduard-Mihai Burtescu  <eddyb@lyken.rs>\n+\n+\t* rust-demangle.c (struct rust_demangler): Add\n+\tskipping_printing and bound_lifetime_depth fields.\n+\t(eat): Add (v0-only).\n+\t(parse_integer_62): Add (v0-only).\n+\t(parse_opt_integer_62): Add (v0-only).\n+\t(parse_disambiguator): Add (v0-only).\n+\t(struct rust_mangled_ident): Add punycode{,_len} fields.\n+\t(parse_ident): Support v0 identifiers.\n+\t(print_str): Respect skipping_printing.\n+\t(print_uint64): Add (v0-only).\n+\t(print_uint64_hex): Add (v0-only).\n+\t(print_ident): Respect skipping_printing,\n+\tSupport v0 identifiers.\n+\t(print_lifetime_from_index): Add (v0-only).\n+\t(demangle_binder): Add (v0-only).\n+\t(demangle_path): Add (v0-only).\n+\t(demangle_generic_arg): Add (v0-only).\n+\t(demangle_type): Add (v0-only).\n+\t(demangle_path_maybe_open_generics): Add (v0-only).\n+\t(demangle_dyn_trait): Add (v0-only).\n+\t(demangle_const): Add (v0-only).\n+\t(demangle_const_uint): Add (v0-only).\n+\t(basic_type): Add (v0-only).\n+\t(rust_demangle_callback): Support v0 symbols.\n+\t* testsuite/rust-demangle-expected: Add v0 testcases.\n+\n+2020-11-13  Seija Kijin  <doremylover456@gmail.com>\n+\n+\t* strstr.c (strstr): Make implementation ANSI/POSIX compliant.\n+\n+2020-11-11  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/88115\n+\t* cp-demangle.c (d_print_comp_inner)\n+\t<case DEMANGLE_COMPONENT_EXTENDED_OPERATOR>: Don't print the\n+\t\"operator \" prefix for __alignof__.\n+\t<case DEMANGLE_COMPONENT_UNARY>: Always print parens around the\n+\toperand of __alignof__.\n+\t* testsuite/demangle-expected: Test demangling for __alignof__.\n+\n+2020-11-09  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* pex-win32.c (pex_win32_exec_child): Initialize orig_err.\n+\n+2020-10-06  Martin Liska  <mliska@suse.cz>\n+\n+\tPR lto/97290\n+\t* simple-object-elf.c (simple_object_elf_copy_lto_debug_sections):\n+\tUse sh_link of a .symtab_shndx section.\n+\n+2020-09-24  Mark Wielaard  <mark@klomp.org>\n \n-\tSync with GCC\n \t* dwarfnames.c (get_DW_UT_name): Define using DW_UT_FIRST, DW_UT\n \tand DW_UT_END.\n \n-2020-09-11  Felix Willgerodt  <felix.willgerodt@intel.com>\n-\n-\tSync with GCC\n-\t2020-09-08  Felix Willgerodt  <felix.willgerodt@intel.com>\n+2020-09-08  Felix Willgerodt  <felix.willgerodt@intel.com>\n \n \t* floatformat.c (floatformat_bfloat16_big): New.\n \t(floatformat_bfloat16_little): New.\n \n 2020-09-08  Alan Modra  <amodra@gmail.com>\n \n-\t* configure: Regenerate.\n-\n-\tSync from gcc\n-\t2020-09-08  Alan Modra  <amodra@gmail.com>\n \t* d-demangle.c: Include limits.h.\n \t(ULONG_MAX, UINT_MAX): Provide fall-back definition.\n \t(dlang_number): Simplify and correct overflow test.  Only\n@@ -42,32 +117,42 @@\n \tunsigned long variables.\n \t* testsuite/d-demangle-expected: Add new tests.\n \n-\t2020-08-04  Iain Buclaw  <ibuclaw@gdcproject.org>\n+2020-08-26  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n \t* d-demangle.c (dlang_function_args): Handle 'in' and 'in ref'\n \tparameter storage classes.\n \t(dlang_type): Remove identifier type.\n \t* testsuite/d-demangle-expected: Update tests.\n \n-\t2020-08-03  Richard Biener  <rguenther@suse.de>\n+2020-08-03  Richard Biener  <rguenther@suse.de>\n+\n \tPR lto/96385\n \t* simple-object-elf.c\n \t(simple_object_elf_copy_lto_debug_sections): Localize global\n \tUNDEFs and reuse the prevailing name.\n \n-\t2020-07-10  Ian Lance Taylor  <iant@golang.org>\n+2020-07-30  H.J. Lu  <hjl.tools@gmail.com>\n+\n+\tPR bootstrap/96202\n+\t* configure: Regenerated.\n+\n+2020-07-14  Ian Lance Taylor  <iant@golang.org>\n+\n \tPR demangler/96143\n \t* cp-demangle.c (d_lambda): Don't add substitution candidate.\n \t* testsuite/demangle-expected: Update a few existing test cases\n \taccordingly, and add a new test case.\n \n-\t2020-07-04  Jason Merrill  <jason@redhat.com>\n+2020-07-10  Jason Merrill  <jason@redhat.com>\n+\n \t* cp-demangle.c (cplus_demangle_operators): Add di, dx, dX.\n \t(d_expression_1): Handle di and dX.\n \t(is_designated_init, d_maybe_print_designated_init): New.\n \t(d_print_comp_inner): Use d_maybe_print_designated_init.\n \t* testsuite/demangle-expected: Add designator tests.\n \n-\t2020-06-25  Nick Clifton  <nickc@redhat.com>\n+2020-06-26  Nick Clifton  <nickc@redhat.com>\n+\n \t* bsearch.c (bsearch): Remove use of register keyword.\n \t* bsearch_r.c (bsearch_r): Likewise.\n \n@@ -3296,7 +3381,7 @@\n \t(find_executable): Likewise.\n \t(win32_spawn): Cast alloca return to (char**).\n \tReplace malloc with XNEWVEC.\n-\tbcopy.c (bcopy): Add explicit casts in assignments.\n+\tbcopy.c (bcopy): Add explict casts in assignments.\n \n 2006-10-25  Ben Elliston  <bje@au.ibm.com>\n "
    },
    {
      "sha": "b6af9baf21204a323cad0e7b40a426c72988ba3b",
      "filename": "libiberty/configure",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/configure?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -5264,6 +5264,7 @@ fi\n NOASANFLAG=\n case \" ${CFLAGS} \" in\n   *\\ -fsanitize=address\\ *) NOASANFLAG=-fno-sanitize=address ;;\n+  *\\ -fsanitize=hwaddress\\ *) NOASANFLAG=-fno-sanitize=hwaddress ;;\n esac\n \n "
    },
    {
      "sha": "ad952963971a31968b5d109661b9cab0aa4b95fc",
      "filename": "libiberty/configure.ac",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/configure.ac?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -240,6 +240,7 @@ AC_SUBST(PICFLAG)\n NOASANFLAG=\n case \" ${CFLAGS} \" in\n   *\\ -fsanitize=address\\ *) NOASANFLAG=-fno-sanitize=address ;;\n+  *\\ -fsanitize=hwaddress\\ *) NOASANFLAG=-fno-sanitize=hwaddress ;;\n esac\n AC_SUBST(NOASANFLAG)\n "
    },
    {
      "sha": "d3e798455cc6a3a21f19314a76af26b189c44a3e",
      "filename": "libiberty/cp-demangle.c",
      "status": "modified",
      "additions": 108,
      "deletions": 32,
      "changes": 140,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/cp-demangle.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/cp-demangle.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/cp-demangle.c?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -429,7 +429,7 @@ static struct demangle_component *d_name (struct d_info *);\n \n static struct demangle_component *d_nested_name (struct d_info *);\n \n-static struct demangle_component *d_prefix (struct d_info *);\n+static struct demangle_component *d_prefix (struct d_info *, int);\n \n static struct demangle_component *d_unqualified_name (struct d_info *);\n \n@@ -1510,7 +1510,7 @@ d_nested_name (struct d_info *di)\n      once we have something to attach it to.  */\n   rqual = d_ref_qualifier (di, NULL);\n \n-  *pret = d_prefix (di);\n+  *pret = d_prefix (di, 1);\n   if (*pret == NULL)\n     return NULL;\n \n@@ -1536,10 +1536,12 @@ d_nested_name (struct d_info *di)\n    <template-prefix> ::= <prefix> <(template) unqualified-name>\n                      ::= <template-param>\n                      ::= <substitution>\n-*/\n+\n+   SUBST is true if we should add substitutions (as normal), false\n+   if not (in an unresolved-name).  */\n \n static struct demangle_component *\n-d_prefix (struct d_info *di)\n+d_prefix (struct d_info *di, int subst)\n {\n   struct demangle_component *ret = NULL;\n \n@@ -1605,7 +1607,7 @@ d_prefix (struct d_info *di)\n       else\n \tret = d_make_comp (di, comb_type, ret, dc);\n \n-      if (peek != 'S' && d_peek_char (di) != 'E')\n+      if (peek != 'S' && d_peek_char (di) != 'E' && subst)\n \t{\n \t  if (! d_add_substitution (di, ret))\n \t    return NULL;\n@@ -1632,9 +1634,15 @@ d_unqualified_name (struct d_info *di)\n     ret = d_source_name (di);\n   else if (IS_LOWER (peek))\n     {\n+      int was_expr = di->is_expression;\n       if (peek == 'o' && d_peek_next_char (di) == 'n')\n-\td_advance (di, 2);\n+\t{\n+\t  d_advance (di, 2);\n+\t  /* Treat cv as naming a conversion operator.  */\n+\t  di->is_expression = 0;\n+\t}\n       ret = d_operator_name (di);\n+      di->is_expression = was_expr;\n       if (ret != NULL && ret->type == DEMANGLE_COMPONENT_OPERATOR)\n \t{\n \t  di->expansion += sizeof \"operator\" + ret->u.s_operator.op->len - 2;\n@@ -3285,14 +3293,58 @@ op_is_new_cast (struct demangle_component *op)\n \t      || code[0] == 'c' || code[0] == 'r'));\n }\n \n+/*   <unresolved-name> ::= [gs] <base-unresolved-name> # x or (with \"gs\") ::x\n+       ::= sr <unresolved-type> <base-unresolved-name> # T::x / decltype(p)::x\n+       # T::N::x /decltype(p)::N::x\n+       ::= srN <unresolved-type> <unresolved-qualifier-level>+ E <base-unresolved-name>\n+       # A::x, N::y, A<T>::z; \"gs\" means leading \"::\"\n+       ::= [gs] sr <unresolved-qualifier-level>+ E <base-unresolved-name>\n+\n+     \"gs\" is handled elsewhere, as a unary operator.  */\n+\n+static struct demangle_component *\n+d_unresolved_name (struct d_info *di)\n+{\n+  struct demangle_component *type;\n+  struct demangle_component *name;\n+  char peek;\n+\n+  /* Consume the \"sr\".  */\n+  d_advance (di, 2);\n+\n+  peek = d_peek_char (di);\n+  if (di->unresolved_name_state\n+      && (IS_DIGIT (peek)\n+\t  || IS_LOWER (peek)\n+\t  || peek == 'C'\n+\t  || peek == 'U'\n+\t  || peek == 'L'))\n+    {\n+      /* The third production is ambiguous with the old unresolved-name syntax\n+\t of <type> <base-unresolved-name>; in the old mangling, A::x was mangled\n+\t as sr1A1x, now sr1AE1x.  So we first try to demangle using the new\n+\t mangling, then with the old if that fails.  */\n+      di->unresolved_name_state = -1;\n+      type = d_prefix (di, 0);\n+      if (d_peek_char (di) == 'E')\n+\td_advance (di, 1);\n+    }\n+  else\n+    type = cplus_demangle_type (di);\n+  name = d_unqualified_name (di);\n+  if (d_peek_char (di) == 'I')\n+    name = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n+\t\t\td_template_args (di));\n+  return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n+}\n+\n /* <expression> ::= <(unary) operator-name> <expression>\n                 ::= <(binary) operator-name> <expression> <expression>\n                 ::= <(trinary) operator-name> <expression> <expression> <expression>\n \t\t::= cl <expression>+ E\n                 ::= st <type>\n                 ::= <template-param>\n-                ::= sr <type> <unqualified-name>\n-                ::= sr <type> <unqualified-name> <template-args>\n+\t\t::= <unresolved-name>\n                 ::= <expr-primary>\n \n   <braced-expression> ::= <expression>\n@@ -3302,7 +3354,7 @@ op_is_new_cast (struct demangle_component *op)\n \t\t\t\t\t\t\t\t\t# [expr ... expr] = expr\n */\n \n-static inline struct demangle_component *\n+static struct demangle_component *\n d_expression_1 (struct d_info *di)\n {\n   char peek;\n@@ -3313,20 +3365,7 @@ d_expression_1 (struct d_info *di)\n   else if (peek == 'T')\n     return d_template_param (di);\n   else if (peek == 's' && d_peek_next_char (di) == 'r')\n-    {\n-      struct demangle_component *type;\n-      struct demangle_component *name;\n-\n-      d_advance (di, 2);\n-      type = cplus_demangle_type (di);\n-      name = d_unqualified_name (di);\n-      if (d_peek_char (di) != 'I')\n-\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n-      else\n-\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,\n-\t\t\t    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n-\t\t\t\t\t d_template_args (di)));\n-    }\n+    return d_unresolved_name (di);\n   else if (peek == 's' && d_peek_next_char (di) == 'p')\n     {\n       d_advance (di, 2);\n@@ -3470,10 +3509,22 @@ d_expression_1 (struct d_info *di)\n \t      right = d_exprlist (di, 'E');\n \t    else if (!strcmp (code, \"dt\") || !strcmp (code, \"pt\"))\n \t      {\n-\t\tright = d_unqualified_name (di);\n-\t\tif (d_peek_char (di) == 'I')\n-\t\t  right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n-\t\t\t\t       right, d_template_args (di));\n+\t\tpeek = d_peek_char (di);\n+\t\t/* These codes start a qualified name.  */\n+\t\tif ((peek == 'g' && d_peek_next_char (di) == 's')\n+\t\t    || (peek == 's' && d_peek_next_char (di) == 'r'))\n+\t\t  right = d_expression_1 (di);\n+\t\telse\n+\t\t  {\n+\t\t    /* Otherwise it's an unqualified name.  We use\n+\t\t       d_unqualified_name rather than d_expression_1 here for\n+\t\t       old mangled names that didn't add 'on' before operator\n+\t\t       names.  */\n+\t\t    right = d_unqualified_name (di);\n+\t\t    if (d_peek_char (di) == 'I')\n+\t\t      right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n+\t\t\t\t\t   right, d_template_args (di));\n+\t\t  }\n \t      }\n \t    else\n \t      right = d_expression_1 (di);\n@@ -5458,9 +5509,18 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       }\n \n     case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n-      d_append_string (dpi, \"operator \");\n-      d_print_comp (dpi, options, dc->u.s_extended_operator.name);\n-      return;\n+      {\n+\tstruct demangle_component *name = dc->u.s_extended_operator.name;\n+\tif (name->type == DEMANGLE_COMPONENT_NAME\n+\t    && !strncmp (name->u.s_name.s, \"__alignof__\", name->u.s_name.len))\n+\t  d_print_comp (dpi, options, dc->u.s_extended_operator.name);\n+\telse\n+\t  {\n+\t    d_append_string (dpi, \"operator \");\n+\t    d_print_comp (dpi, options, dc->u.s_extended_operator.name);\n+\t  }\n+\treturn;\n+      }\n \n     case DEMANGLE_COMPONENT_CONVERSION:\n       d_append_string (dpi, \"operator \");\n@@ -5525,8 +5585,14 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \tif (code && !strcmp (code, \"gs\"))\n \t  /* Avoid parens after '::'.  */\n \t  d_print_comp (dpi, options, operand);\n-\telse if (code && !strcmp (code, \"st\"))\n-\t  /* Always print parens for sizeof (type).  */\n+\telse if ((code && !strcmp (code, \"st\"))\n+\t\t || (op->type == DEMANGLE_COMPONENT_EXTENDED_OPERATOR\n+\t\t     && (op->u.s_extended_operator.name->type\n+\t\t\t == DEMANGLE_COMPONENT_NAME)\n+\t\t     && !strncmp (op->u.s_extended_operator.name->u.s_name.s,\n+\t\t\t\t  \"__alignof__\",\n+\t\t\t\t  op->u.s_extended_operator.name->u.s_name.len)))\n+\t  /* Always print parens for sizeof (type) and __alignof__.  */\n \t  {\n \t    d_append_char (dpi, '(');\n \t    d_print_comp (dpi, options, operand);\n@@ -6364,6 +6430,9 @@ d_demangle_callback (const char *mangled, int options,\n       type = DCT_TYPE;\n     }\n \n+  di.unresolved_name_state = 1;\n+\n+ again:\n   cplus_demangle_init_info (mangled, options, strlen (mangled), &di);\n \n   /* PR 87675 - Check for a mangled string that is so long\n@@ -6422,6 +6491,13 @@ d_demangle_callback (const char *mangled, int options,\n     if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\\0')\n       dc = NULL;\n \n+    /* See discussion in d_unresolved_name.  */\n+    if (dc == NULL && di.unresolved_name_state == -1)\n+      {\n+\tdi.unresolved_name_state = 0;\n+\tgoto again;\n+      }\n+\n #ifdef CP_DEMANGLE_DEBUG\n     d_dump (dc, 0);\n #endif"
    },
    {
      "sha": "cb47bdf0d2e4554832f038d0571238b846562c88",
      "filename": "libiberty/cp-demangle.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/cp-demangle.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/cp-demangle.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/cp-demangle.h?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -122,6 +122,10 @@ struct d_info\n   /* Non-zero if we are parsing the type operand of a conversion\n      operator, but not when in an expression.  */\n   int is_conversion;\n+  /*  1: using new unresolved-name grammar.\n+     -1: using new unresolved-name grammar and saw an unresolved-name.\n+      0: using old unresolved-name grammar.  */\n+  int unresolved_name_state;\n   /* If DMGL_NO_RECURSE_LIMIT is not active then this is set to\n      the current recursion level.  */\n   unsigned int recursion_level;"
    },
    {
      "sha": "ecfe7f160e5c8cd741f0ce79986f15a55709fe38",
      "filename": "libiberty/pex-win32.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/pex-win32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/pex-win32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/pex-win32.c?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -771,7 +771,7 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n   OSVERSIONINFO version_info;\n   STARTUPINFO si;\n   PROCESS_INFORMATION pi;\n-  int orig_out, orig_in, orig_err;\n+  int orig_out, orig_in, orig_err = 0;\n   BOOL separate_stderr = !(flags & PEX_STDERR_TO_STDOUT);\n \n   /* Ensure we have inheritable descriptors to pass to the child.  */"
    },
    {
      "sha": "6fd8f6a4db0541615cedc72e1668c421b207bca4",
      "filename": "libiberty/rust-demangle.c",
      "status": "modified",
      "additions": 1000,
      "deletions": 10,
      "changes": 1010,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/rust-demangle.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/rust-demangle.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/rust-demangle.c?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -1,6 +1,7 @@\n /* Demangler for the Rust programming language\n    Copyright (C) 2016-2021 Free Software Foundation, Inc.\n    Written by David Tolnay (dtolnay@gmail.com).\n+   Rewritten by Eduard-Mihai Burtescu (eddyb@lyken.rs) for v0 support.\n \n This file is part of the libiberty library.\n Libiberty is free software; you can redistribute it and/or\n@@ -64,11 +65,16 @@ struct rust_demangler\n   /* Non-zero if any error occurred. */\n   int errored;\n \n+  /* Non-zero if nothing should be printed. */\n+  int skipping_printing;\n+\n   /* Non-zero if printing should be verbose (e.g. include hashes). */\n   int verbose;\n \n   /* Rust mangling version, with legacy mangling being -1. */\n   int version;\n+\n+  uint64_t bound_lifetime_depth;\n };\n \n /* Parsing functions. */\n@@ -81,6 +87,18 @@ peek (const struct rust_demangler *rdm)\n   return 0;\n }\n \n+static int\n+eat (struct rust_demangler *rdm, char c)\n+{\n+  if (peek (rdm) == c)\n+    {\n+      rdm->next++;\n+      return 1;\n+    }\n+  else\n+    return 0;\n+}\n+\n static char\n next (struct rust_demangler *rdm)\n {\n@@ -92,22 +110,104 @@ next (struct rust_demangler *rdm)\n   return c;\n }\n \n+static uint64_t\n+parse_integer_62 (struct rust_demangler *rdm)\n+{\n+  char c;\n+  uint64_t x;\n+\n+  if (eat (rdm, '_'))\n+    return 0;\n+\n+  x = 0;\n+  while (!eat (rdm, '_'))\n+    {\n+      c = next (rdm);\n+      x *= 62;\n+      if (ISDIGIT (c))\n+        x += c - '0';\n+      else if (ISLOWER (c))\n+        x += 10 + (c - 'a');\n+      else if (ISUPPER (c))\n+        x += 10 + 26 + (c - 'A');\n+      else\n+        {\n+          rdm->errored = 1;\n+          return 0;\n+        }\n+    }\n+  return x + 1;\n+}\n+\n+static uint64_t\n+parse_opt_integer_62 (struct rust_demangler *rdm, char tag)\n+{\n+  if (!eat (rdm, tag))\n+    return 0;\n+  return 1 + parse_integer_62 (rdm);\n+}\n+\n+static uint64_t\n+parse_disambiguator (struct rust_demangler *rdm)\n+{\n+  return parse_opt_integer_62 (rdm, 's');\n+}\n+\n+static size_t\n+parse_hex_nibbles (struct rust_demangler *rdm, uint64_t *value)\n+{\n+  char c;\n+  size_t hex_len;\n+\n+  hex_len = 0;\n+  *value = 0;\n+\n+  while (!eat (rdm, '_'))\n+    {\n+      *value <<= 4;\n+\n+      c = next (rdm);\n+      if (ISDIGIT (c))\n+        *value |= c - '0';\n+      else if (c >= 'a' && c <= 'f')\n+        *value |= 10 + (c - 'a');\n+      else\n+        {\n+          rdm->errored = 1;\n+          return 0;\n+        }\n+      hex_len++;\n+    }\n+\n+  return hex_len;\n+}\n+\n struct rust_mangled_ident\n {\n   /* ASCII part of the identifier. */\n   const char *ascii;\n   size_t ascii_len;\n+\n+  /* Punycode insertion codes for Unicode codepoints, if any. */\n+  const char *punycode;\n+  size_t punycode_len;\n };\n \n static struct rust_mangled_ident\n parse_ident (struct rust_demangler *rdm)\n {\n   char c;\n   size_t start, len;\n+  int is_punycode = 0;\n   struct rust_mangled_ident ident;\n \n   ident.ascii = NULL;\n   ident.ascii_len = 0;\n+  ident.punycode = NULL;\n+  ident.punycode_len = 0;\n+\n+  if (rdm->version != -1)\n+    is_punycode = eat (rdm, 'u');\n \n   c = next (rdm);\n   if (!ISDIGIT (c))\n@@ -121,6 +221,10 @@ parse_ident (struct rust_demangler *rdm)\n     while (ISDIGIT (peek (rdm)))\n       len = len * 10 + (next (rdm) - '0');\n \n+  /* Skip past the optional `_` separator (v0). */\n+  if (rdm->version != -1)\n+    eat (rdm, '_');\n+\n   start = rdm->next;\n   rdm->next += len;\n   /* Check for overflows. */\n@@ -133,6 +237,27 @@ parse_ident (struct rust_demangler *rdm)\n   ident.ascii = rdm->sym + start;\n   ident.ascii_len = len;\n \n+  if (is_punycode)\n+    {\n+      ident.punycode_len = 0;\n+      while (ident.ascii_len > 0)\n+        {\n+          ident.ascii_len--;\n+\n+          /* The last '_' is a separator between ascii & punycode. */\n+          if (ident.ascii[ident.ascii_len] == '_')\n+            break;\n+\n+          ident.punycode_len++;\n+        }\n+      if (!ident.punycode_len)\n+        {\n+          rdm->errored = 1;\n+          return ident;\n+        }\n+      ident.punycode = ident.ascii + (len - ident.punycode_len);\n+    }\n+\n   if (ident.ascii_len == 0)\n     ident.ascii = NULL;\n \n@@ -144,12 +269,28 @@ parse_ident (struct rust_demangler *rdm)\n static void\n print_str (struct rust_demangler *rdm, const char *data, size_t len)\n {\n-  if (!rdm->errored)\n+  if (!rdm->errored && !rdm->skipping_printing)\n     rdm->callback (data, len, rdm->callback_opaque);\n }\n \n #define PRINT(s) print_str (rdm, s, strlen (s))\n \n+static void\n+print_uint64 (struct rust_demangler *rdm, uint64_t x)\n+{\n+  char s[21];\n+  snprintf (s, 21, \"%\" PRIu64, x);\n+  PRINT (s);\n+}\n+\n+static void\n+print_uint64_hex (struct rust_demangler *rdm, uint64_t x)\n+{\n+  char s[17];\n+  snprintf (s, 17, \"%\" PRIx64, x);\n+  PRINT (s);\n+}\n+\n /* Return a 0x0-0xf value if the char is 0-9a-f, and -1 otherwise. */\n static int\n decode_lower_hex_nibble (char nibble)\n@@ -230,9 +371,14 @@ static void\n print_ident (struct rust_demangler *rdm, struct rust_mangled_ident ident)\n {\n   char unescaped;\n-  size_t len;\n-\n-  if (rdm->errored)\n+  uint8_t *out, *p, d;\n+  size_t len, cap, punycode_pos, j;\n+  /* Punycode parameters and state. */\n+  uint32_t c;\n+  size_t base, t_min, t_max, skew, damp, bias, i;\n+  size_t delta, w, k, t;\n+\n+  if (rdm->errored || rdm->skipping_printing)\n     return;\n \n   if (rdm->version == -1)\n@@ -273,8 +419,7 @@ print_ident (struct rust_demangler *rdm, struct rust_mangled_ident ident)\n                 }\n               else\n                 {\n-                  /* \".\" becomes \"-\" */\n-                  PRINT (\"-\");\n+                  PRINT (\".\");\n                   len = 1;\n                 }\n             }\n@@ -294,6 +439,830 @@ print_ident (struct rust_demangler *rdm, struct rust_mangled_ident ident)\n \n       return;\n     }\n+\n+  if (!ident.punycode)\n+    {\n+      print_str (rdm, ident.ascii, ident.ascii_len);\n+      return;\n+    }\n+\n+  len = 0;\n+  cap = 4;\n+  while (cap < ident.ascii_len)\n+    {\n+      cap *= 2;\n+      /* Check for overflows. */\n+      if ((cap * 4) / 4 != cap)\n+        {\n+          rdm->errored = 1;\n+          return;\n+        }\n+    }\n+\n+  /* Store the output codepoints as groups of 4 UTF-8 bytes. */\n+  out = (uint8_t *)malloc (cap * 4);\n+  if (!out)\n+    {\n+      rdm->errored = 1;\n+      return;\n+    }\n+\n+  /* Populate initial output from ASCII fragment. */\n+  for (len = 0; len < ident.ascii_len; len++)\n+    {\n+      p = out + 4 * len;\n+      p[0] = 0;\n+      p[1] = 0;\n+      p[2] = 0;\n+      p[3] = ident.ascii[len];\n+    }\n+\n+  /* Punycode parameters and initial state. */\n+  base = 36;\n+  t_min = 1;\n+  t_max = 26;\n+  skew = 38;\n+  damp = 700;\n+  bias = 72;\n+  i = 0;\n+  c = 0x80;\n+\n+  punycode_pos = 0;\n+  while (punycode_pos < ident.punycode_len)\n+    {\n+      /* Read one delta value. */\n+      delta = 0;\n+      w = 1;\n+      k = 0;\n+      do\n+        {\n+          k += base;\n+          t = k < bias ? 0 : (k - bias);\n+          if (t < t_min)\n+            t = t_min;\n+          if (t > t_max)\n+            t = t_max;\n+\n+          if (punycode_pos >= ident.punycode_len)\n+            goto cleanup;\n+          d = ident.punycode[punycode_pos++];\n+\n+          if (ISLOWER (d))\n+            d = d - 'a';\n+          else if (ISDIGIT (d))\n+            d = 26 + (d - '0');\n+          else\n+            {\n+              rdm->errored = 1;\n+              goto cleanup;\n+            }\n+\n+          delta += d * w;\n+          w *= base - t;\n+        }\n+      while (d >= t);\n+\n+      /* Compute the new insert position and character. */\n+      len++;\n+      i += delta;\n+      c += i / len;\n+      i %= len;\n+\n+      /* Ensure enough space is available. */\n+      if (cap < len)\n+        {\n+          cap *= 2;\n+          /* Check for overflows. */\n+          if ((cap * 4) / 4 != cap || cap < len)\n+            {\n+              rdm->errored = 1;\n+              goto cleanup;\n+            }\n+        }\n+      p = (uint8_t *)realloc (out, cap * 4);\n+      if (!p)\n+        {\n+          rdm->errored = 1;\n+          goto cleanup;\n+        }\n+      out = p;\n+\n+      /* Move the characters after the insert position. */\n+      p = out + i * 4;\n+      memmove (p + 4, p, (len - i - 1) * 4);\n+\n+      /* Insert the new character, as UTF-8 bytes. */\n+      p[0] = c >= 0x10000 ? 0xf0 | (c >> 18) : 0;\n+      p[1] = c >= 0x800 ? (c < 0x10000 ? 0xe0 : 0x80) | ((c >> 12) & 0x3f) : 0;\n+      p[2] = (c < 0x800 ? 0xc0 : 0x80) | ((c >> 6) & 0x3f);\n+      p[3] = 0x80 | (c & 0x3f);\n+\n+      /* If there are no more deltas, decoding is complete. */\n+      if (punycode_pos == ident.punycode_len)\n+        break;\n+\n+      i++;\n+\n+      /* Perform bias adaptation. */\n+      delta /= damp;\n+      damp = 2;\n+\n+      delta += delta / len;\n+      k = 0;\n+      while (delta > ((base - t_min) * t_max) / 2)\n+        {\n+          delta /= base - t_min;\n+          k += base;\n+        }\n+      bias = k + ((base - t_min + 1) * delta) / (delta + skew);\n+    }\n+\n+  /* Remove all the 0 bytes to leave behind an UTF-8 string. */\n+  for (i = 0, j = 0; i < len * 4; i++)\n+    if (out[i] != 0)\n+      out[j++] = out[i];\n+\n+  print_str (rdm, (const char *)out, j);\n+\n+cleanup:\n+  free (out);\n+}\n+\n+/* Print the lifetime according to the previously decoded index.\n+   An index of `0` always refers to `'_`, but starting with `1`,\n+   indices refer to late-bound lifetimes introduced by a binder. */\n+static void\n+print_lifetime_from_index (struct rust_demangler *rdm, uint64_t lt)\n+{\n+  char c;\n+  uint64_t depth;\n+\n+  PRINT (\"'\");\n+  if (lt == 0)\n+    {\n+      PRINT (\"_\");\n+      return;\n+    }\n+\n+  depth = rdm->bound_lifetime_depth - lt;\n+  /* Try to print lifetimes alphabetically first. */\n+  if (depth < 26)\n+    {\n+      c = 'a' + depth;\n+      print_str (rdm, &c, 1);\n+    }\n+  else\n+    {\n+      /* Use `'_123` after running out of letters. */\n+      PRINT (\"_\");\n+      print_uint64 (rdm, depth);\n+    }\n+}\n+\n+/* Demangling functions. */\n+\n+static void demangle_binder (struct rust_demangler *rdm);\n+static void demangle_path (struct rust_demangler *rdm, int in_value);\n+static void demangle_generic_arg (struct rust_demangler *rdm);\n+static void demangle_type (struct rust_demangler *rdm);\n+static int demangle_path_maybe_open_generics (struct rust_demangler *rdm);\n+static void demangle_dyn_trait (struct rust_demangler *rdm);\n+static void demangle_const (struct rust_demangler *rdm);\n+static void demangle_const_uint (struct rust_demangler *rdm);\n+static void demangle_const_int (struct rust_demangler *rdm);\n+static void demangle_const_bool (struct rust_demangler *rdm);\n+static void demangle_const_char (struct rust_demangler *rdm);\n+\n+/* Optionally enter a binder ('G') for late-bound lifetimes,\n+   printing e.g. `for<'a, 'b> `, and make those lifetimes visible\n+   to the caller (via depth level, which the caller should reset). */\n+static void\n+demangle_binder (struct rust_demangler *rdm)\n+{\n+  uint64_t i, bound_lifetimes;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  bound_lifetimes = parse_opt_integer_62 (rdm, 'G');\n+  if (bound_lifetimes > 0)\n+    {\n+      PRINT (\"for<\");\n+      for (i = 0; i < bound_lifetimes; i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          rdm->bound_lifetime_depth++;\n+          print_lifetime_from_index (rdm, 1);\n+        }\n+      PRINT (\"> \");\n+    }\n+}\n+\n+static void\n+demangle_path (struct rust_demangler *rdm, int in_value)\n+{\n+  char tag, ns;\n+  int was_skipping_printing;\n+  size_t i, backref, old_next;\n+  uint64_t dis;\n+  struct rust_mangled_ident name;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  switch (tag = next (rdm))\n+    {\n+    case 'C':\n+      dis = parse_disambiguator (rdm);\n+      name = parse_ident (rdm);\n+\n+      print_ident (rdm, name);\n+      if (rdm->verbose)\n+        {\n+          PRINT (\"[\");\n+          print_uint64_hex (rdm, dis);\n+          PRINT (\"]\");\n+        }\n+      break;\n+    case 'N':\n+      ns = next (rdm);\n+      if (!ISLOWER (ns) && !ISUPPER (ns))\n+        {\n+          rdm->errored = 1;\n+          return;\n+        }\n+\n+      demangle_path (rdm, in_value);\n+\n+      dis = parse_disambiguator (rdm);\n+      name = parse_ident (rdm);\n+\n+      if (ISUPPER (ns))\n+        {\n+          /* Special namespaces, like closures and shims. */\n+          PRINT (\"::{\");\n+          switch (ns)\n+            {\n+            case 'C':\n+              PRINT (\"closure\");\n+              break;\n+            case 'S':\n+              PRINT (\"shim\");\n+              break;\n+            default:\n+              print_str (rdm, &ns, 1);\n+            }\n+          if (name.ascii || name.punycode)\n+            {\n+              PRINT (\":\");\n+              print_ident (rdm, name);\n+            }\n+          PRINT (\"#\");\n+          print_uint64 (rdm, dis);\n+          PRINT (\"}\");\n+        }\n+      else\n+        {\n+          /* Implementation-specific/unspecified namespaces. */\n+\n+          if (name.ascii || name.punycode)\n+            {\n+              PRINT (\"::\");\n+              print_ident (rdm, name);\n+            }\n+        }\n+      break;\n+    case 'M':\n+    case 'X':\n+      /* Ignore the `impl`'s own path.*/\n+      parse_disambiguator (rdm);\n+      was_skipping_printing = rdm->skipping_printing;\n+      rdm->skipping_printing = 1;\n+      demangle_path (rdm, in_value);\n+      rdm->skipping_printing = was_skipping_printing;\n+      /* fallthrough */\n+    case 'Y':\n+      PRINT (\"<\");\n+      demangle_type (rdm);\n+      if (tag != 'M')\n+        {\n+          PRINT (\" as \");\n+          demangle_path (rdm, 0);\n+        }\n+      PRINT (\">\");\n+      break;\n+    case 'I':\n+      demangle_path (rdm, in_value);\n+      if (in_value)\n+        PRINT (\"::\");\n+      PRINT (\"<\");\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          demangle_generic_arg (rdm);\n+        }\n+      PRINT (\">\");\n+      break;\n+    case 'B':\n+      backref = parse_integer_62 (rdm);\n+      if (!rdm->skipping_printing)\n+        {\n+          old_next = rdm->next;\n+          rdm->next = backref;\n+          demangle_path (rdm, in_value);\n+          rdm->next = old_next;\n+        }\n+      break;\n+    default:\n+      rdm->errored = 1;\n+      return;\n+    }\n+}\n+\n+static void\n+demangle_generic_arg (struct rust_demangler *rdm)\n+{\n+  uint64_t lt;\n+  if (eat (rdm, 'L'))\n+    {\n+      lt = parse_integer_62 (rdm);\n+      print_lifetime_from_index (rdm, lt);\n+    }\n+  else if (eat (rdm, 'K'))\n+    demangle_const (rdm);\n+  else\n+    demangle_type (rdm);\n+}\n+\n+static const char *\n+basic_type (char tag)\n+{\n+  switch (tag)\n+    {\n+    case 'b':\n+      return \"bool\";\n+    case 'c':\n+      return \"char\";\n+    case 'e':\n+      return \"str\";\n+    case 'u':\n+      return \"()\";\n+    case 'a':\n+      return \"i8\";\n+    case 's':\n+      return \"i16\";\n+    case 'l':\n+      return \"i32\";\n+    case 'x':\n+      return \"i64\";\n+    case 'n':\n+      return \"i128\";\n+    case 'i':\n+      return \"isize\";\n+    case 'h':\n+      return \"u8\";\n+    case 't':\n+      return \"u16\";\n+    case 'm':\n+      return \"u32\";\n+    case 'y':\n+      return \"u64\";\n+    case 'o':\n+      return \"u128\";\n+    case 'j':\n+      return \"usize\";\n+    case 'f':\n+      return \"f32\";\n+    case 'd':\n+      return \"f64\";\n+    case 'z':\n+      return \"!\";\n+    case 'p':\n+      return \"_\";\n+    case 'v':\n+      return \"...\";\n+\n+    default:\n+      return NULL;\n+    }\n+}\n+\n+static void\n+demangle_type (struct rust_demangler *rdm)\n+{\n+  char tag;\n+  size_t i, old_next, backref;\n+  uint64_t lt, old_bound_lifetime_depth;\n+  const char *basic;\n+  struct rust_mangled_ident abi;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  tag = next (rdm);\n+\n+  basic = basic_type (tag);\n+  if (basic)\n+    {\n+      PRINT (basic);\n+      return;\n+    }\n+\n+  switch (tag)\n+    {\n+    case 'R':\n+    case 'Q':\n+      PRINT (\"&\");\n+      if (eat (rdm, 'L'))\n+        {\n+          lt = parse_integer_62 (rdm);\n+          if (lt)\n+            {\n+              print_lifetime_from_index (rdm, lt);\n+              PRINT (\" \");\n+            }\n+        }\n+      if (tag != 'R')\n+        PRINT (\"mut \");\n+      demangle_type (rdm);\n+      break;\n+    case 'P':\n+    case 'O':\n+      PRINT (\"*\");\n+      if (tag != 'P')\n+        PRINT (\"mut \");\n+      else\n+        PRINT (\"const \");\n+      demangle_type (rdm);\n+      break;\n+    case 'A':\n+    case 'S':\n+      PRINT (\"[\");\n+      demangle_type (rdm);\n+      if (tag == 'A')\n+        {\n+          PRINT (\"; \");\n+          demangle_const (rdm);\n+        }\n+      PRINT (\"]\");\n+      break;\n+    case 'T':\n+      PRINT (\"(\");\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          demangle_type (rdm);\n+        }\n+      if (i == 1)\n+        PRINT (\",\");\n+      PRINT (\")\");\n+      break;\n+    case 'F':\n+      old_bound_lifetime_depth = rdm->bound_lifetime_depth;\n+      demangle_binder (rdm);\n+\n+      if (eat (rdm, 'U'))\n+        PRINT (\"unsafe \");\n+\n+      if (eat (rdm, 'K'))\n+        {\n+          if (eat (rdm, 'C'))\n+            {\n+              abi.ascii = \"C\";\n+              abi.ascii_len = 1;\n+            }\n+          else\n+            {\n+              abi = parse_ident (rdm);\n+              if (!abi.ascii || abi.punycode)\n+                {\n+                  rdm->errored = 1;\n+                  goto restore;\n+                }\n+            }\n+\n+          PRINT (\"extern \\\"\");\n+\n+          /* If the ABI had any `-`, they were replaced with `_`,\n+             so the parts between `_` have to be re-joined with `-`. */\n+          for (i = 0; i < abi.ascii_len; i++)\n+            {\n+              if (abi.ascii[i] == '_')\n+                {\n+                  print_str (rdm, abi.ascii, i);\n+                  PRINT (\"-\");\n+                  abi.ascii += i + 1;\n+                  abi.ascii_len -= i + 1;\n+                  i = 0;\n+                }\n+            }\n+          print_str (rdm, abi.ascii, abi.ascii_len);\n+\n+          PRINT (\"\\\" \");\n+        }\n+\n+      PRINT (\"fn(\");\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          demangle_type (rdm);\n+        }\n+      PRINT (\")\");\n+\n+      if (eat (rdm, 'u'))\n+        {\n+          /* Skip printing the return type if it's 'u', i.e. `()`. */\n+        }\n+      else\n+        {\n+          PRINT (\" -> \");\n+          demangle_type (rdm);\n+        }\n+\n+    /* Restore `bound_lifetime_depth` to outside the binder. */\n+    restore:\n+      rdm->bound_lifetime_depth = old_bound_lifetime_depth;\n+      break;\n+    case 'D':\n+      PRINT (\"dyn \");\n+\n+      old_bound_lifetime_depth = rdm->bound_lifetime_depth;\n+      demangle_binder (rdm);\n+\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\" + \");\n+          demangle_dyn_trait (rdm);\n+        }\n+\n+      /* Restore `bound_lifetime_depth` to outside the binder. */\n+      rdm->bound_lifetime_depth = old_bound_lifetime_depth;\n+\n+      if (!eat (rdm, 'L'))\n+        {\n+          rdm->errored = 1;\n+          return;\n+        }\n+      lt = parse_integer_62 (rdm);\n+      if (lt)\n+        {\n+          PRINT (\" + \");\n+          print_lifetime_from_index (rdm, lt);\n+        }\n+      break;\n+    case 'B':\n+      backref = parse_integer_62 (rdm);\n+      if (!rdm->skipping_printing)\n+        {\n+          old_next = rdm->next;\n+          rdm->next = backref;\n+          demangle_type (rdm);\n+          rdm->next = old_next;\n+        }\n+      break;\n+    default:\n+      /* Go back to the tag, so `demangle_path` also sees it. */\n+      rdm->next--;\n+      demangle_path (rdm, 0);\n+    }\n+}\n+\n+/* A trait in a trait object may have some \"existential projections\"\n+   (i.e. associated type bindings) after it, which should be printed\n+   in the `<...>` of the trait, e.g. `dyn Trait<T, U, Assoc=X>`.\n+   To this end, this method will keep the `<...>` of an 'I' path\n+   open, by omitting the `>`, and return `Ok(true)` in that case. */\n+static int\n+demangle_path_maybe_open_generics (struct rust_demangler *rdm)\n+{\n+  int open;\n+  size_t i, old_next, backref;\n+\n+  open = 0;\n+\n+  if (rdm->errored)\n+    return open;\n+\n+  if (eat (rdm, 'B'))\n+    {\n+      backref = parse_integer_62 (rdm);\n+      if (!rdm->skipping_printing)\n+        {\n+          old_next = rdm->next;\n+          rdm->next = backref;\n+          open = demangle_path_maybe_open_generics (rdm);\n+          rdm->next = old_next;\n+        }\n+    }\n+  else if (eat (rdm, 'I'))\n+    {\n+      demangle_path (rdm, 0);\n+      PRINT (\"<\");\n+      open = 1;\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          demangle_generic_arg (rdm);\n+        }\n+    }\n+  else\n+    demangle_path (rdm, 0);\n+  return open;\n+}\n+\n+static void\n+demangle_dyn_trait (struct rust_demangler *rdm)\n+{\n+  int open;\n+  struct rust_mangled_ident name;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  open = demangle_path_maybe_open_generics (rdm);\n+\n+  while (eat (rdm, 'p'))\n+    {\n+      if (!open)\n+        PRINT (\"<\");\n+      else\n+        PRINT (\", \");\n+      open = 1;\n+\n+      name = parse_ident (rdm);\n+      print_ident (rdm, name);\n+      PRINT (\" = \");\n+      demangle_type (rdm);\n+    }\n+\n+  if (open)\n+    PRINT (\">\");\n+}\n+\n+static void\n+demangle_const (struct rust_demangler *rdm)\n+{\n+  char ty_tag;\n+  size_t old_next, backref;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  if (eat (rdm, 'B'))\n+    {\n+      backref = parse_integer_62 (rdm);\n+      if (!rdm->skipping_printing)\n+        {\n+          old_next = rdm->next;\n+          rdm->next = backref;\n+          demangle_const (rdm);\n+          rdm->next = old_next;\n+        }\n+      return;\n+    }\n+\n+  ty_tag = next (rdm);\n+  switch (ty_tag)\n+    {\n+    /* Placeholder. */\n+    case 'p':\n+      PRINT (\"_\");\n+      return;\n+\n+    /* Unsigned integer types. */\n+    case 'h':\n+    case 't':\n+    case 'm':\n+    case 'y':\n+    case 'o':\n+    case 'j':\n+      demangle_const_uint (rdm);\n+      break;\n+\n+    /* Signed integer types. */\n+    case 'a':\n+    case 's':\n+    case 'l':\n+    case 'x':\n+    case 'n':\n+    case 'i':\n+      demangle_const_int (rdm);\n+      break;\n+\n+    /* Boolean. */\n+    case 'b':\n+      demangle_const_bool (rdm);\n+      break;\n+\n+    /* Character. */\n+    case 'c':\n+      demangle_const_char (rdm);\n+      break;\n+\n+    default:\n+      rdm->errored = 1;\n+      return;\n+    }\n+\n+  if (rdm->errored)\n+    return;\n+\n+  if (rdm->verbose)\n+    {\n+      PRINT (\": \");\n+      PRINT (basic_type (ty_tag));\n+    }\n+}\n+\n+static void\n+demangle_const_uint (struct rust_demangler *rdm)\n+{\n+  size_t hex_len;\n+  uint64_t value;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  hex_len = parse_hex_nibbles (rdm, &value);\n+\n+  if (hex_len > 16)\n+    {\n+      /* Print anything that doesn't fit in `uint64_t` verbatim. */\n+      PRINT (\"0x\");\n+      print_str (rdm, rdm->sym + (rdm->next - hex_len), hex_len);\n+    }\n+  else if (hex_len > 0)\n+    print_uint64 (rdm, value);\n+  else\n+    rdm->errored = 1;\n+}\n+\n+static void\n+demangle_const_int (struct rust_demangler *rdm)\n+{\n+  if (eat (rdm, 'n'))\n+    PRINT (\"-\");\n+  demangle_const_uint (rdm);\n+}\n+\n+static void\n+demangle_const_bool (struct rust_demangler *rdm)\n+{\n+  uint64_t value;\n+\n+  if (parse_hex_nibbles (rdm, &value) != 1)\n+    {\n+      rdm->errored = 1;\n+      return;\n+    }\n+\n+  if (value == 0)\n+    PRINT (\"false\");\n+  else if (value == 1)\n+    PRINT (\"true\");\n+  else\n+    rdm->errored = 1;\n+}\n+\n+static void\n+demangle_const_char (struct rust_demangler *rdm)\n+{\n+  size_t hex_len;\n+  uint64_t value;\n+\n+  hex_len = parse_hex_nibbles (rdm, &value);\n+\n+  if (hex_len == 0 || hex_len > 8)\n+    {\n+      rdm->errored = 1;\n+      return;\n+    }\n+\n+  /* Match Rust's character \"debug\" output as best as we can. */\n+  PRINT (\"'\");\n+  if (value == '\\t')\n+    PRINT (\"\\\\t\");\n+  else if (value == '\\r')\n+    PRINT (\"\\\\r\");\n+  else if (value == '\\n')\n+    PRINT (\"\\\\n\");\n+  else if (value > ' ' && value < '~')\n+    /* Rust also considers many non-ASCII codepoints to be printable, but\n+       that logic is not easily ported to C. */\n+    print_str (rdm, (char *) &value, 1);\n+  else\n+    {\n+      PRINT (\"\\\\u{\");\n+      print_uint64_hex (rdm, value);\n+      PRINT (\"}\");\n+    }\n+  PRINT (\"'\");\n }\n \n /* A legacy hash is the prefix \"h\" followed by 16 lowercase hex digits.\n@@ -345,26 +1314,35 @@ rust_demangle_callback (const char *mangled, int options,\n \n   rdm.next = 0;\n   rdm.errored = 0;\n+  rdm.skipping_printing = 0;\n   rdm.verbose = (options & DMGL_VERBOSE) != 0;\n   rdm.version = 0;\n+  rdm.bound_lifetime_depth = 0;\n \n-  /* Rust symbols always start with _ZN (legacy). */\n-  if (rdm.sym[0] == '_' && rdm.sym[1] == 'Z' && rdm.sym[2] == 'N')\n+  /* Rust symbols always start with _R (v0) or _ZN (legacy). */\n+  if (rdm.sym[0] == '_' && rdm.sym[1] == 'R')\n+    rdm.sym += 2;\n+  else if (rdm.sym[0] == '_' && rdm.sym[1] == 'Z' && rdm.sym[2] == 'N')\n     {\n       rdm.sym += 3;\n       rdm.version = -1;\n     }\n   else\n     return 0;\n \n-  /* Legacy Rust symbols use only [_0-9a-zA-Z.:$] characters. */\n+  /* Paths (v0) always start with uppercase characters. */\n+  if (rdm.version != -1 && !ISUPPER (rdm.sym[0]))\n+    return 0;\n+\n+  /* Rust symbols (v0) use only [_0-9a-zA-Z] characters. */\n   for (p = rdm.sym; *p; p++)\n     {\n       rdm.sym_len++;\n \n       if (*p == '_' || ISALNUM (*p))\n         continue;\n \n+      /* Legacy Rust symbols can also contain [.:$] characters. */\n       if (rdm.version == -1 && (*p == '$' || *p == '.' || *p == ':'))\n         continue;\n \n@@ -418,7 +1396,19 @@ rust_demangle_callback (const char *mangled, int options,\n       while (rdm.next < rdm.sym_len);\n     }\n   else\n-    return 0;\n+    {\n+      demangle_path (&rdm, 1);\n+\n+      /* Skip instantiating crate. */\n+      if (!rdm.errored && rdm.next < rdm.sym_len)\n+        {\n+          rdm.skipping_printing = 1;\n+          demangle_path (&rdm, 0);\n+        }\n+\n+      /* It's an error to not reach the end. */\n+      rdm.errored |= rdm.next != rdm.sym_len;\n+    }\n \n   return !rdm.errored;\n }"
    },
    {
      "sha": "a421177f0c2077b809680c7d8168a9a208b59f30",
      "filename": "libiberty/simple-object-elf.c",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/simple-object-elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/simple-object-elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/simple-object-elf.c?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -1191,7 +1191,7 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n \t  unsigned int sh_link;\n \t  sh_link = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t\t     shdr, sh_link, Elf_Word);\n-\t  symtab_indices_shndx[sh_link - 1] = i;\n+\t  symtab_indices_shndx[sh_link - 1] = i - 1;\n \t  /* Always discard the extended index sections, after\n \t     copying it will not be needed.  This way we don't need to\n \t     update it and deal with the ordering constraints of\n@@ -1372,19 +1372,22 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n \t{\n \t  unsigned entsize = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t\t\t      shdr, sh_entsize, Elf_Addr);\n-\t  unsigned strtab = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n-\t\t\t\t\t     shdr, sh_link, Elf_Word);\n \t  size_t prevailing_name_idx = 0;\n \t  unsigned char *ent;\n \t  unsigned *shndx_table = NULL;\n \t  /* Read the section index table if present.  */\n \t  if (symtab_indices_shndx[i - 1] != 0)\n \t    {\n-\t      unsigned char *sidxhdr = shdrs + (strtab - 1) * shdr_size;\n+\t      unsigned char *sidxhdr = shdrs + symtab_indices_shndx[i - 1] * shdr_size;\n \t      off_t sidxoff = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t\t\t       sidxhdr, sh_offset, Elf_Addr);\n \t      size_t sidxsz = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t\t\t       sidxhdr, sh_size, Elf_Addr);\n+\t      unsigned int shndx_type\n+\t\t= ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t   sidxhdr, sh_type, Elf_Word);\n+\t      if (shndx_type != SHT_SYMTAB_SHNDX)\n+\t\treturn \"Wrong section type of a SYMTAB SECTION INDICES section\";\n \t      shndx_table = (unsigned *)XNEWVEC (char, sidxsz);\n \t      simple_object_internal_read (sobj->descriptor,\n \t\t\t\t\t   sobj->offset + sidxoff,"
    },
    {
      "sha": "c6f68495a33d124cec901251812150c52e2d0ea3",
      "filename": "libiberty/strstr.c",
      "status": "modified",
      "additions": 5,
      "deletions": 11,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/strstr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/strstr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/strstr.c?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -16,26 +16,20 @@ length, the function returns @var{string}.\n \n */\n \n-\n-/* FIXME:  The above description is ANSI compiliant.  This routine has not\n-   been validated to comply with it.  -fnf */\n-\n #include <stddef.h>\n \n-extern char *strchr (const char *, int);\n-extern int strncmp (const void *, const void *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n extern size_t strlen (const char *);\n \n char *\n strstr (const char *s1, const char *s2)\n {\n-  const char *p = s1;\n   const size_t len = strlen (s2);\n-\n-  for (; (p = strchr (p, *s2)) != 0; p++)\n+  while (*s1)\n     {\n-      if (strncmp (p, s2, len) == 0)\n-\treturn (char *)p;\n+      if (!memcmp (s1, s2, len))\n+\treturn (char *)s1;\n+      ++s1;\n     }\n   return (0);\n }"
    },
    {
      "sha": "57a71da06feb370923b62da26d163599d3d9e86a",
      "filename": "libiberty/strverscmp.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/strverscmp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/strverscmp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/strverscmp.c?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -1,7 +1,7 @@\n /* Compare strings while treating digits characters numerically.\n    Copyright (C) 1997-2021 Free Software Foundation, Inc.\n    This file is part of the libiberty library.\n-   Contributed by Jean-Fran\ufffdois Bignolles <bignolle@ecoledoc.ibp.fr>, 1997.\n+   Contributed by Jean-Fran\u00e7ois Bignolles <bignolle@ecoledoc.ibp.fr>, 1997.\n \n    Libiberty is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public"
    },
    {
      "sha": "e6b5b64b9a9bc31a1cbf75b80e4b25407116dd82",
      "filename": "libiberty/testsuite/demangle-expected",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/testsuite/demangle-expected",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/testsuite/demangle-expected",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/testsuite/demangle-expected?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -1469,3 +1469,22 @@ f(A<X{.a.b[3 ... 4]=(1)}>)\n # PR 96143\n _Z2F2IZ1FvEUlvE_EN1AIT_E1XES2_\n A<F()::{lambda()#1}>::X F2<F()::{lambda()#1}>(F()::{lambda()#1})\n+\n+# PR 88115\n+_Z1fIiEvDTv111__alignof__T_E\n+void f<int>(decltype (__alignof__(int)))\n+\n+_Z1fIiEvDTv111__alignof__tlT_EE\n+void f<int>(decltype (__alignof__(int{})))\n+\n+_Z1gI1AEv1SIXadsrT_oncviEE\n+void g<A>(S<&A::operator int>)\n+\n+_Z1jI1AEDTcldtfp_oncvPT_EES1_\n+decltype (({parm#1}.(operator A*))()) j<A>(A)\n+\n+_Z1fI1AEDtdtfp_srT_1xES1_\n+decltype ({parm#1}.A::x) f<A>(A)\n+\n+_Z2f6IP1AEDtptfp_gssr1A1BE1xET_\n+decltype ({parm#1}->(::A::B::x)) f6<A*>(A*)"
    },
    {
      "sha": "7dca315d0054801636f1563c19f42da517ad67e0",
      "filename": "libiberty/testsuite/rust-demangle-expected",
      "status": "modified",
      "additions": 133,
      "deletions": 1,
      "changes": 134,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/testsuite/rust-demangle-expected",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d750c713c9a34c8835e8e60370708cae675edb40/libiberty/testsuite/rust-demangle-expected",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/testsuite/rust-demangle-expected?ref=d750c713c9a34c8835e8e60370708cae675edb40",
      "patch": "@@ -11,7 +11,7 @@\n #\n ############\n #\n-# Coverage Tests\n+# Coverage Tests (legacy)\n #\n #\n # Demangles as rust symbol.\n@@ -163,3 +163,135 @@ _ZN63_$LT$core..ptr..Unique$LT$T$GT$$u20$as$u20$core..ops..Deref$GT$5deref17h19f\n --format=rust\n _ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17h059a991a004536adE\n issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo\n+--format=rust\n+_ZN4core3ops8function6FnOnce40call_once$u7b$$u7b$vtable.shim$u7d$$u7d$17h000b1ad6c4f30bd6E\n+core::ops::function::FnOnce::call_once{{vtable.shim}}\n+#\n+############\n+#\n+# Coverage Tests (v0)\n+#\n+#\n+# Crate with a leading digit.\n+--format=rust\n+_RNvC6_123foo3bar\n+123foo::bar\n+# UTF-8 identifiers.\n+--format=rust\n+_RNqCs4fqI2P2rA04_11utf8_identsu30____7hkackfecea1cbdathfdh9hlq6y\n+utf8_idents::\u10e1\u10d0\u10ed\u10db\u10d4\u10da\u10d0\u10d3_\u10d2\u10d4\u10db\u10e0\u10d8\u10d4\u10da\u10d8_\u10e1\u10d0\u10d3\u10d8\u10da\u10d8\n+# Closure path elements.\n+--format=rust\n+_RNCNCNgCs6DXkGYLi8lr_2cc5spawn00B5_\n+cc::spawn::{closure#0}::{closure#0}\n+#\n+--format=rust\n+_RNCINkXs25_NgCsbmNqQUJIY6D_4core5sliceINyB9_4IterhENuNgNoBb_4iter8iterator8Iterator9rpositionNCNgNpB9_6memchr7memrchrs_0E0Bb_\n+<core::slice::Iter<u8> as core::iter::iterator::Iterator>::rposition::<core::slice::memchr::memrchr::{closure#1}>::{closure#0}\n+# dyn Trait (\"trait object\") types.\n+--format=rust\n+_RINbNbCskIICzLVDPPb_5alloc5alloc8box_freeDINbNiB4_5boxed5FnBoxuEp6OutputuEL_ECs1iopQbuBiw2_3std\n+alloc::alloc::box_free::<dyn alloc::boxed::FnBox<(), Output = ()>>\n+# Types with const generics parameters.\n+--format=rust\n+_RNvMC0INtC8arrayvec8ArrayVechKj7b_E3new\n+<arrayvec::ArrayVec<u8, 123>>::new\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_8UnsignedKhb_E\n+<const_generic::Unsigned<11>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_6SignedKs98_E\n+<const_generic::Signed<152>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_6SignedKanb_E\n+<const_generic::Signed<-11>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4BoolKb0_E\n+<const_generic::Bool<false>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4BoolKb1_E\n+<const_generic::Bool<true>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKc76_E\n+<const_generic::Char<'v'>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKca_E\n+<const_generic::Char<'\\n'>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKc2202_E\n+<const_generic::Char<'\\u{2202}'>>\n+#\n+--format=rust\n+_RNvNvMCs4fqI2P2rA04_13const_genericINtB4_3FooKpE3foo3FOO\n+<const_generic::Foo<_>>::foo::FOO\n+#\n+# All of the tests above but in auto mode instead:\n+#\n+# Crate with a leading digit.\n+--format=auto\n+_RNvC6_123foo3bar\n+123foo::bar\n+# UTF-8 identifiers.\n+--format=auto\n+_RNqCs4fqI2P2rA04_11utf8_identsu30____7hkackfecea1cbdathfdh9hlq6y\n+utf8_idents::\u10e1\u10d0\u10ed\u10db\u10d4\u10da\u10d0\u10d3_\u10d2\u10d4\u10db\u10e0\u10d8\u10d4\u10da\u10d8_\u10e1\u10d0\u10d3\u10d8\u10da\u10d8\n+# Closure path elements.\n+--format=auto\n+_RNCNCNgCs6DXkGYLi8lr_2cc5spawn00B5_\n+cc::spawn::{closure#0}::{closure#0}\n+#\n+--format=auto\n+_RNCINkXs25_NgCsbmNqQUJIY6D_4core5sliceINyB9_4IterhENuNgNoBb_4iter8iterator8Iterator9rpositionNCNgNpB9_6memchr7memrchrs_0E0Bb_\n+<core::slice::Iter<u8> as core::iter::iterator::Iterator>::rposition::<core::slice::memchr::memrchr::{closure#1}>::{closure#0}\n+# dyn Trait (\"trait object\") types.\n+--format=auto\n+_RINbNbCskIICzLVDPPb_5alloc5alloc8box_freeDINbNiB4_5boxed5FnBoxuEp6OutputuEL_ECs1iopQbuBiw2_3std\n+alloc::alloc::box_free::<dyn alloc::boxed::FnBox<(), Output = ()>>\n+# Types with const generics parameters.\n+--format=auto\n+_RNvMC0INtC8arrayvec8ArrayVechKj7b_E3new\n+<arrayvec::ArrayVec<u8, 123>>::new\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_8UnsignedKhb_E\n+<const_generic::Unsigned<11>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_6SignedKs98_E\n+<const_generic::Signed<152>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_6SignedKanb_E\n+<const_generic::Signed<-11>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4BoolKb0_E\n+<const_generic::Bool<false>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4BoolKb1_E\n+<const_generic::Bool<true>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKc76_E\n+<const_generic::Char<'v'>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKca_E\n+<const_generic::Char<'\\n'>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKc2202_E\n+<const_generic::Char<'\\u{2202}'>>\n+#\n+--format=auto\n+_RNvNvMCs4fqI2P2rA04_13const_genericINtB4_3FooKpE3foo3FOO\n+<const_generic::Foo<_>>::foo::FOO"
    }
  ]
}