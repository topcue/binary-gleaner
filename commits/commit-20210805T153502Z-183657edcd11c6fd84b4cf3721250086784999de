{
  "sha": "183657edcd11c6fd84b4cf3721250086784999de",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTgzNjU3ZWRjZDExYzZmZDg0YjRjZjM3MjEyNTAwODY3ODQ5OTlkZQ==",
  "commit": {
    "author": {
      "name": "Zoran Zaric",
      "email": "Zoran.Zaric@amd.com",
      "date": "2020-08-14T10:28:13Z"
    },
    "committer": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2021-08-05T15:35:02Z"
    },
    "message": "Replace the symbol needs evaluator with a parser\n\nThis patch addresses a design problem with the symbol_needs_eval_context\nclass. It exposes the problem by introducing two new testsuite test\ncases.\n\nTo explain the issue, I first need to explain the dwarf_expr_context\nclass that the symbol_needs_eval_context class derives from.\n\nThe intention behind the dwarf_expr_context class is to commonize the\nDWARF expression evaluation mechanism for different evaluation\ncontexts. Currently in gdb, the evaluation context can contain some or\nall of the following information: architecture, object file, frame and\ncompilation unit.\n\nDepending on the information needed to evaluate a given expression,\nthere are currently three distinct DWARF expression evaluators:\n\n\u00a0- Frame: designed to evaluate an expression in the context of a call\n\u00a0\u00a0 frame information (dwarf_expr_executor class). This evaluator doesn't\n\u00a0\u00a0 need a compilation unit information.\n\n\u00a0- Location description: designed to evaluate an expression in the\n\u00a0\u00a0 context of a source level information (dwarf_evaluate_loc_desc\n\u00a0\u00a0 class). This evaluator expects all information needed for the\n\u00a0\u00a0 evaluation of the given expression to be present.\n\n\u00a0- Symbol needs: designed to answer a question about the parts of the\n\u00a0\u00a0 context information required to evaluate a DWARF expression behind a\n\u00a0\u00a0 given symbol (symbol_needs_eval_context class). This evaluator\n\u00a0\u00a0 doesn't need a frame information.\n\nThe functional difference between the symbol needs evaluator and the\nothers is that this evaluator is not meant to interact with the actual\ntarget. Instead, it is supposed to check which parts of the context\ninformation are needed for the given DWARF expression to be evaluated by\nthe location description evaluator.\n\nThe idea is to take advantage of the existing dwarf_expr_context\nevaluation mechanism and to fake all required interactions with the\nactual target, by returning back dummy values. The evaluation result is\nreturned as one of three possible values, based on operations found in a\ngiven expression:\n\n- SYMBOL_NEEDS_NONE,\n- SYMBOL_NEEDS_REGISTERS and\n- SYMBOL_NEEDS_FRAME.\n\nThe problem here is that faking results of target interactions can yield\nan incorrect evaluation result.\n\nFor example, if we have a conditional DWARF expression, where the\ncondition depends on a value read from an actual target, and the true\nbranch of the condition requires a frame information to be evaluated,\nwhile the false branch doesn't, fake target reads could conclude that a\nframe information is not needed, where in fact it is. This wrong\ninformation would then cause the expression to be actually evaluated (by\nthe location description evaluator) with a missing frame information.\nThis would then crash the debugger.\n\nThe gdb.dwarf2/symbol_needs_eval_fail.exp test introduces this\nscenario, with the following DWARF expression:\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_addr $some_variable\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_deref\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # conditional jump to DW_OP_bregx\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_bra 4\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_lit0\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # jump to DW_OP_stack_value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_skip 3\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_bregx $dwarf_regnum 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_stack_value\n\nThis expression describes a case where some variable dictates the\nlocation of another variable. Depending on a value of some_variable, the\nvariable whose location is described by this expression is either read\nfrom a register or it is defined as a constant value 0. In both cases,\nthe value will be returned as an implicit location description on the\nDWARF stack.\n\nCurrently, when the symbol needs evaluator fakes a memory read from the\naddress behind the some_variable variable, the constant value 0 is used\nas the value of the variable A, and the check returns the\nSYMBOL_NEEDS_NONE result.\n\nThis is clearly a wrong result and it causes the debugger to crash.\n\nThe scenario might sound strange to some people, but it comes from a\nSIMD/SIMT architecture where $some_variable is an execution mask.\u00a0 In\nany case, it is a valid DWARF expression, and GDB shouldn't crash while\nevaluating it. Also, a similar example could be made based on a\ncondition of the frame base value, where if that value is concluded to\nbe 0, the variable location could be defaulted to a TLS based memory\naddress.\n\nThe gdb.dwarf2/symbol_needs_eval_timeout.exp test introduces a second\nscenario. This scenario is a bit more abstract due to the DWARF\nassembler lacking the CFI support, but it exposes a different\nmanifestation of the same problem. Like in the previous scenario, the\nDWARF expression used in the test is valid:\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_lit1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_addr $some_variable\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_deref\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # jump to DW_OP_fbreg\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_skip 4\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_drop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_fbreg 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_dup\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_lit0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_eq\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # conditional jump to DW_OP_drop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_bra -9\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DW_OP_stack_value\n\nSimilarly to the previous scenario, the location of a variable A is an\nimplicit location description with a constant value that depends on a\nvalue held by a global variable. The difference from the previous case\nis that DWARF expression contains a loop instead of just one branch. The\nend condition of that loop depends on the expectation that a frame base\nvalue is never zero. Currently, the act of faking the target reads will\ncause the symbol needs evaluator to get stuck in an infinite loop.\n\nSomebody could argue that we could change the fake reads to return\nsomething else, but that would only hide the real problem.\n\nThe general impression seems to be that the desired design is to have\none class that deals with parsing of the DWARF expression, while there\nare virtual methods that deal with specifics of some operations.\n\nUsing an evaluator mechanism here doesn't seem to be correct, because\nthe act of evaluation relies on accessing the data from the actual\ntarget with the possibility of skipping the evaluation of some parts of\nthe expression.\n\nTo better explain the proposed solution for the issue, I first need to\nexplain a couple more details behind the current design:\n\nThere are multiple places in gdb that handle DWARF expression parsing\nfor different purposes. Some are in charge of converting the expression\nto some other internal representation (decode_location_expression,\ndisassemble_dwarf_expression and dwarf2_compile_expr_to_ax), some are\nanalysing the expression for specific information\n(compute_stack_depth_worker) and some are in charge of evaluating the\nexpression in a given context (dwarf_expr_context::execute_stack_op\nand decode_locdesc).\n\nThe problem is that all those functions have a similar (large) switch\nstatement that handles each DWARF expression operation. The result of\nthis is a code duplication and harder maintenance.\n\nAs a step into the right direction to solve this problem (at least for\nthe purpose of a DWARF expression evaluation) the expression parsing was\ncommonized inside of an evaluator base class (dwarf_expr_context). This\nmakes sense for all derived classes, except for the symbol needs\nevaluator (symbol_needs_eval_context) class.\n\nAs described previously the problem with this evaluator is that if the\nevaluator is not allowed to access the actual target, it is not really\nevaluating.\n\nInstead, the desired function of a symbol needs evaluator seems to fall\nmore into expression analysis category. This means that a more natural\nfit for this evaluator is to be a symbol needs analysis, similar to the\nexisting compute_stack_depth_worker analysis.\n\nAnother problem is that using a heavyweight mechanism of an evaluator\nto do an expression analysis seems to be an unneeded overhead. It also\nrequires a more complicated design of the parent class to support fake\ntarget reads.\n\nThe reality is that the whole symbol_needs_eval_context class can be\nreplaced with a lightweight recursive analysis function, that will give\nmore correct result without compromising the design of the\ndwarf_expr_context class. The analysis treats the expression byte\nstream as a DWARF operation graph, where each graph node can be\nvisited only once and each operation can decide if the frame context\nis needed for their evaluation.\n\nThe downside of this approach is adding of one more similar switch\nstatement, but at least this way the new symbol needs analysis will be\na lightweight mechnism and it will provide a correct result for any\ngiven DWARF expression.\n\nA more desired long term design would be to have one class that deals\nwith parsing of the DWARF expression, while there would be a virtual\nmethods that deal with specifics of some DWARF operations. Then that\nclass would be used as a base for all DWARF expression parsing mentioned\nat the beginning.\n\nThis however, requires a far bigger changes that are out of the scope\nof this patch series.\n\nThe new analysis requires the DWARF location description for the\nargc argument of the main function to change in the assembly file\ngdb.python/amd64-py-framefilter-invalidarg.S. Originally, expression\nended with a 0 value byte, which was never reached by the symbol needs\nevaluator, because it was detecting a stack underflow when evaluating\nthe operation before. The new approach does not simulate a DWARF\nstack anymore, so the 0 value byte needs to be removed because it\nmakes the DWARF expression invalid.\n\ngdb/ChangeLog:\n\n        * dwarf2/loc.c (class symbol_needs_eval_context): Remove.\n        (dwarf2_get_symbol_read_needs): New function.\n        (dwarf2_loc_desc_get_symbol_read_needs): Remove.\n        (locexpr_get_symbol_read_needs): Use\n        dwarf2_get_symbol_read_needs.\n\ngdb/testsuite/ChangeLog:\n\n        * gdb.python/amd64-py-framefilter-invalidarg.S : Update argc\n          DWARF location expression.\n        * lib/dwarf.exp (_location): Handle DW_OP_fbreg.\n        * gdb.dwarf2/symbol_needs_eval.c: New file.\n        * gdb.dwarf2/symbol_needs_eval_fail.exp: New file.\n        * gdb.dwarf2/symbol_needs_eval_timeout.exp: New file.",
    "tree": {
      "sha": "097185211674b5c119fd3644338d3ce75112f9e5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/097185211674b5c119fd3644338d3ce75112f9e5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/183657edcd11c6fd84b4cf3721250086784999de",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/183657edcd11c6fd84b4cf3721250086784999de",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/183657edcd11c6fd84b4cf3721250086784999de",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/183657edcd11c6fd84b4cf3721250086784999de/comments",
  "author": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "17a089ffda6045908a30c86066748d239a5616d0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/17a089ffda6045908a30c86066748d239a5616d0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/17a089ffda6045908a30c86066748d239a5616d0"
    }
  ],
  "stats": {
    "total": 794,
    "additions": 678,
    "deletions": 116
  },
  "files": [
    {
      "sha": "cf52b1e1a368261701408d14359e7f8555e9b548",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 406,
      "deletions": 115,
      "changes": 521,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183657edcd11c6fd84b4cf3721250086784999de/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183657edcd11c6fd84b4cf3721250086784999de/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=183657edcd11c6fd84b4cf3721250086784999de",
      "patch": "@@ -2789,151 +2789,436 @@ dwarf2_compile_property_to_c (string_file *stream,\n \t\t\t     data, data + size, per_cu, per_objfile);\n }\n \n-\f\n-/* Helper functions and baton for dwarf2_loc_desc_get_symbol_read_needs.  */\n+/* Compute the correct symbol_needs_kind value for the location\n+   expression in EXPR.\n+\n+   Implemented by traversing the logical control flow graph of the\n+   expression.  */\n \n-class symbol_needs_eval_context : public dwarf_expr_context\n+static enum symbol_needs_kind\n+dwarf2_get_symbol_read_needs (gdb::array_view<const gdb_byte> expr,\n+\t\t\t      dwarf2_per_cu_data *per_cu,\n+\t\t\t      dwarf2_per_objfile *per_objfile,\n+\t\t\t      bfd_endian byte_order,\n+\t\t\t      int addr_size,\n+\t\t\t      int ref_addr_size,\n+\t\t\t      int depth = 0)\n {\n-public:\n-  symbol_needs_eval_context (dwarf2_per_objfile *per_objfile)\n-    : dwarf_expr_context (per_objfile)\n-  {}\n+  enum symbol_needs_kind symbol_needs = SYMBOL_NEEDS_NONE;\n \n-  enum symbol_needs_kind needs;\n-  struct dwarf2_per_cu_data *per_cu;\n+  /* If the expression is empty, we have nothing to do.  */\n+  if (expr.empty ())\n+    return symbol_needs;\n \n-  /* Reads from registers do require a frame.  */\n-  CORE_ADDR read_addr_from_reg (int regnum) override\n-  {\n-    needs = SYMBOL_NEEDS_FRAME;\n-    return 1;\n-  }\n+  const gdb_byte *expr_end = expr.data () + expr.size ();\n \n-  /* \"get_reg_value\" callback: Reads from registers do require a\n-     frame.  */\n+  /* List of operations to visit.  Operations in this list are not visited yet,\n+     so are not in VISITED_OPS (and vice-versa).  */\n+  std::vector<const gdb_byte *> ops_to_visit;\n \n-  struct value *get_reg_value (struct type *type, int regnum) override\n-  {\n-    needs = SYMBOL_NEEDS_FRAME;\n-    return value_zero (type, not_lval);\n-  }\n+  /* Operations already visited.  */\n+  std::unordered_set<const gdb_byte *> visited_ops;\n \n-  /* Reads from memory do not require a frame.  */\n-  void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t len) override\n-  {\n-    memset (buf, 0, len);\n-  }\n+  /* Insert OP in OPS_TO_VISIT if it is within the expression's range and\n+     hasn't been visited yet.  */\n+  auto insert_in_ops_to_visit\n+    = [expr_end, &visited_ops, &ops_to_visit] (const gdb_byte *op_ptr)\n+      {\n+\tif (op_ptr >= expr_end)\n+\t  return;\n \n-  /* Frame-relative accesses do require a frame.  */\n-  void get_frame_base (const gdb_byte **start, size_t *length) override\n-  {\n-    static gdb_byte lit0 = DW_OP_lit0;\n+\tif (visited_ops.find (op_ptr) != visited_ops.end ())\n+\t  return;\n \n-    *start = &lit0;\n-    *length = 1;\n+\tops_to_visit.push_back (op_ptr);\n+      };\n \n-    needs = SYMBOL_NEEDS_FRAME;\n-  }\n+  /* Expressions can invoke other expressions with DW_OP_call*.  Protect against\n+     a loop of calls.  */\n+  const int max_depth = 256;\n \n-  /* CFA accesses require a frame.  */\n-  CORE_ADDR get_frame_cfa () override\n-  {\n-    needs = SYMBOL_NEEDS_FRAME;\n-    return 1;\n-  }\n+  if (depth > max_depth)\n+    error (_(\"DWARF-2 expression error: Loop detected.\"));\n \n-  CORE_ADDR get_frame_pc () override\n-  {\n-    needs = SYMBOL_NEEDS_FRAME;\n-    return 1;\n-  }\n+  depth++;\n \n-  /* Thread-local accesses require registers, but not a frame.  */\n-  CORE_ADDR get_tls_address (CORE_ADDR offset) override\n-  {\n-    if (needs <= SYMBOL_NEEDS_REGISTERS)\n-      needs = SYMBOL_NEEDS_REGISTERS;\n-    return 1;\n-  }\n+  /* Initialize the to-visit list with the first operation.  */\n+  insert_in_ops_to_visit (&expr[0]);\n \n-  /* Helper interface of per_cu_dwarf_call for\n-     dwarf2_loc_desc_get_symbol_read_needs.  */\n+  while (!ops_to_visit.empty ())\n+    {\n+      /* Pop one op to visit, mark it as visited.  */\n+      const gdb_byte *op_ptr = ops_to_visit.back ();\n+      ops_to_visit.pop_back ();\n+      gdb_assert (visited_ops.find (op_ptr) == visited_ops.end ());\n+      visited_ops.insert (op_ptr);\n \n-  void dwarf_call (cu_offset die_offset) override\n-  {\n-    per_cu_dwarf_call (this, die_offset, per_cu, per_objfile);\n-  }\n+      dwarf_location_atom op = (dwarf_location_atom) *op_ptr;\n \n-  /* Helper interface of sect_variable_value for\n-     dwarf2_loc_desc_get_symbol_read_needs.  */\n+      /* Most operations have a single possible following operation\n+\t (they are not conditional branches).  The code below updates\n+\t OP_PTR to point to that following operation, which is pushed\n+\t back to OPS_TO_VISIT, if needed, at the bottom.  Here, leave\n+\t OP_PTR pointing just after the operand.  */\n+      op_ptr++;\n \n-  struct value *dwarf_variable_value (sect_offset sect_off) override\n-  {\n-    return sect_variable_value (this, sect_off, per_cu, per_objfile);\n-  }\n+      /* The DWARF expression might have a bug causing an infinite\n+\t loop.  In that case, quitting is the only way out.  */\n+      QUIT;\n \n-  /* DW_OP_entry_value accesses require a caller, therefore a\n-     frame.  */\n+      switch (op)\n+\t{\n+\tcase DW_OP_lit0:\n+\tcase DW_OP_lit1:\n+\tcase DW_OP_lit2:\n+\tcase DW_OP_lit3:\n+\tcase DW_OP_lit4:\n+\tcase DW_OP_lit5:\n+\tcase DW_OP_lit6:\n+\tcase DW_OP_lit7:\n+\tcase DW_OP_lit8:\n+\tcase DW_OP_lit9:\n+\tcase DW_OP_lit10:\n+\tcase DW_OP_lit11:\n+\tcase DW_OP_lit12:\n+\tcase DW_OP_lit13:\n+\tcase DW_OP_lit14:\n+\tcase DW_OP_lit15:\n+\tcase DW_OP_lit16:\n+\tcase DW_OP_lit17:\n+\tcase DW_OP_lit18:\n+\tcase DW_OP_lit19:\n+\tcase DW_OP_lit20:\n+\tcase DW_OP_lit21:\n+\tcase DW_OP_lit22:\n+\tcase DW_OP_lit23:\n+\tcase DW_OP_lit24:\n+\tcase DW_OP_lit25:\n+\tcase DW_OP_lit26:\n+\tcase DW_OP_lit27:\n+\tcase DW_OP_lit28:\n+\tcase DW_OP_lit29:\n+\tcase DW_OP_lit30:\n+\tcase DW_OP_lit31:\n+\tcase DW_OP_stack_value:\n+\tcase DW_OP_dup:\n+\tcase DW_OP_drop:\n+\tcase DW_OP_swap:\n+\tcase DW_OP_over:\n+\tcase DW_OP_rot:\n+\tcase DW_OP_deref:\n+\tcase DW_OP_abs:\n+\tcase DW_OP_neg:\n+\tcase DW_OP_not:\n+\tcase DW_OP_and:\n+\tcase DW_OP_div:\n+\tcase DW_OP_minus:\n+\tcase DW_OP_mod:\n+\tcase DW_OP_mul:\n+\tcase DW_OP_or:\n+\tcase DW_OP_plus:\n+\tcase DW_OP_shl:\n+\tcase DW_OP_shr:\n+\tcase DW_OP_shra:\n+\tcase DW_OP_xor:\n+\tcase DW_OP_le:\n+\tcase DW_OP_ge:\n+\tcase DW_OP_eq:\n+\tcase DW_OP_lt:\n+\tcase DW_OP_gt:\n+\tcase DW_OP_ne:\n+\tcase DW_OP_GNU_push_tls_address:\n+\tcase DW_OP_nop:\n+\tcase DW_OP_GNU_uninit:\n+\tcase DW_OP_push_object_address:\n+\t  break;\n \n-  void push_dwarf_reg_entry_value (enum call_site_parameter_kind kind,\n-\t\t\t\t   union call_site_parameter_u kind_u,\n-\t\t\t\t   int deref_size) override\n-  {\n-    needs = SYMBOL_NEEDS_FRAME;\n+\tcase DW_OP_form_tls_address:\n+\t  if (symbol_needs <= SYMBOL_NEEDS_REGISTERS)\n+\t    symbol_needs = SYMBOL_NEEDS_REGISTERS;\n+\t  break;\n \n-    /* The expression may require some stub values on DWARF stack.  */\n-    push_address (0, 0);\n-  }\n+\tcase DW_OP_convert:\n+\tcase DW_OP_GNU_convert:\n+\tcase DW_OP_reinterpret:\n+\tcase DW_OP_GNU_reinterpret:\n+\tcase DW_OP_addrx:\n+\tcase DW_OP_GNU_addr_index:\n+\tcase DW_OP_GNU_const_index:\n+\tcase DW_OP_constu:\n+\tcase DW_OP_plus_uconst:\n+\tcase DW_OP_piece:\n+\t  op_ptr = safe_skip_leb128 (op_ptr, expr_end);\n+\t  break;\n \n-  /* DW_OP_addrx and DW_OP_GNU_addr_index doesn't require a frame.  */\n+\tcase DW_OP_consts:\n+\t  op_ptr = safe_skip_leb128 (op_ptr, expr_end);\n+\t  break;\n \n-  CORE_ADDR get_addr_index (unsigned int index) override\n-  {\n-    /* Nothing to do.  */\n-    return 1;\n-  }\n+\tcase DW_OP_bit_piece:\n+\t  op_ptr = safe_skip_leb128 (op_ptr, expr_end);\n+\t  op_ptr = safe_skip_leb128 (op_ptr, expr_end);\n+\t  break;\n \n-  /* DW_OP_push_object_address has a frame already passed through.  */\n+\tcase DW_OP_deref_type:\n+\tcase DW_OP_GNU_deref_type:\n+\t  op_ptr++;\n+\t  op_ptr = safe_skip_leb128 (op_ptr, expr_end);\n+\t  break;\n \n-  CORE_ADDR get_object_address () override\n-  {\n-    /* Nothing to do.  */\n-    return 1;\n-  }\n-};\n+\tcase DW_OP_addr:\n+\t  op_ptr += addr_size;\n+\t  break;\n \n-/* Compute the correct symbol_needs_kind value for the location\n-   expression at DATA (length SIZE).  */\n+\tcase DW_OP_const1u:\n+\tcase DW_OP_const1s:\n+\t  op_ptr += 1;\n+\t  break;\n \n-static enum symbol_needs_kind\n-dwarf2_loc_desc_get_symbol_read_needs (const gdb_byte *data, size_t size,\n-\t\t\t\t       dwarf2_per_cu_data *per_cu,\n-\t\t\t\t       dwarf2_per_objfile *per_objfile)\n-{\n-  scoped_value_mark free_values;\n+\tcase DW_OP_const2u:\n+\tcase DW_OP_const2s:\n+\t  op_ptr += 2;\n+\t  break;\n \n-  symbol_needs_eval_context ctx (per_objfile);\n+\tcase DW_OP_const4s:\n+\tcase DW_OP_const4u:\n+\t  op_ptr += 4;\n+\t  break;\n \n-  ctx.needs = SYMBOL_NEEDS_NONE;\n-  ctx.per_cu = per_cu;\n-  ctx.gdbarch = per_objfile->objfile->arch ();\n-  ctx.addr_size = per_cu->addr_size ();\n-  ctx.ref_addr_size = per_cu->ref_addr_size ();\n+\tcase DW_OP_const8s:\n+\tcase DW_OP_const8u:\n+\t  op_ptr += 8;\n+\t  break;\n+\n+\tcase DW_OP_reg0:\n+\tcase DW_OP_reg1:\n+\tcase DW_OP_reg2:\n+\tcase DW_OP_reg3:\n+\tcase DW_OP_reg4:\n+\tcase DW_OP_reg5:\n+\tcase DW_OP_reg6:\n+\tcase DW_OP_reg7:\n+\tcase DW_OP_reg8:\n+\tcase DW_OP_reg9:\n+\tcase DW_OP_reg10:\n+\tcase DW_OP_reg11:\n+\tcase DW_OP_reg12:\n+\tcase DW_OP_reg13:\n+\tcase DW_OP_reg14:\n+\tcase DW_OP_reg15:\n+\tcase DW_OP_reg16:\n+\tcase DW_OP_reg17:\n+\tcase DW_OP_reg18:\n+\tcase DW_OP_reg19:\n+\tcase DW_OP_reg20:\n+\tcase DW_OP_reg21:\n+\tcase DW_OP_reg22:\n+\tcase DW_OP_reg23:\n+\tcase DW_OP_reg24:\n+\tcase DW_OP_reg25:\n+\tcase DW_OP_reg26:\n+\tcase DW_OP_reg27:\n+\tcase DW_OP_reg28:\n+\tcase DW_OP_reg29:\n+\tcase DW_OP_reg30:\n+\tcase DW_OP_reg31:\n+\tcase DW_OP_regx:\n+\tcase DW_OP_breg0:\n+\tcase DW_OP_breg1:\n+\tcase DW_OP_breg2:\n+\tcase DW_OP_breg3:\n+\tcase DW_OP_breg4:\n+\tcase DW_OP_breg5:\n+\tcase DW_OP_breg6:\n+\tcase DW_OP_breg7:\n+\tcase DW_OP_breg8:\n+\tcase DW_OP_breg9:\n+\tcase DW_OP_breg10:\n+\tcase DW_OP_breg11:\n+\tcase DW_OP_breg12:\n+\tcase DW_OP_breg13:\n+\tcase DW_OP_breg14:\n+\tcase DW_OP_breg15:\n+\tcase DW_OP_breg16:\n+\tcase DW_OP_breg17:\n+\tcase DW_OP_breg18:\n+\tcase DW_OP_breg19:\n+\tcase DW_OP_breg20:\n+\tcase DW_OP_breg21:\n+\tcase DW_OP_breg22:\n+\tcase DW_OP_breg23:\n+\tcase DW_OP_breg24:\n+\tcase DW_OP_breg25:\n+\tcase DW_OP_breg26:\n+\tcase DW_OP_breg27:\n+\tcase DW_OP_breg28:\n+\tcase DW_OP_breg29:\n+\tcase DW_OP_breg30:\n+\tcase DW_OP_breg31:\n+\tcase DW_OP_bregx:\n+\tcase DW_OP_fbreg:\n+\tcase DW_OP_call_frame_cfa:\n+\tcase DW_OP_entry_value:\n+\tcase DW_OP_GNU_entry_value:\n+\tcase DW_OP_GNU_parameter_ref:\n+\tcase DW_OP_regval_type:\n+\tcase DW_OP_GNU_regval_type:\n+\t  symbol_needs = SYMBOL_NEEDS_FRAME;\n+\t  break;\n+\n+\tcase DW_OP_implicit_value:\n+\t  {\n+\t    uint64_t uoffset;\n+\t    op_ptr = safe_read_uleb128 (op_ptr, expr_end, &uoffset);\n+\t    op_ptr += uoffset;\n+\t    break;\n+\t  }\n+\n+\tcase DW_OP_implicit_pointer:\n+\tcase DW_OP_GNU_implicit_pointer:\n+\t  op_ptr += ref_addr_size;\n+\t  op_ptr = safe_skip_leb128 (op_ptr, expr_end);\n+\t  break;\n+\n+\tcase DW_OP_deref_size:\n+\tcase DW_OP_pick:\n+\t  op_ptr++;\n+\t  break;\n+\n+\tcase DW_OP_skip:\n+\t  {\n+\t    int64_t offset = extract_signed_integer (op_ptr, 2, byte_order);\n+\t    op_ptr += 2;\n+\t    op_ptr += offset;\n+\t    break;\n+\t  }\n+\n+\tcase DW_OP_bra:\n+\t  {\n+\t    /* This is the only operation that pushes two operations in\n+\t       the to-visit list, so handle it all here.  */\n+\t    LONGEST offset = extract_signed_integer (op_ptr, 2, byte_order);\n+\t    op_ptr += 2;\n+\n+\t    insert_in_ops_to_visit (op_ptr + offset);\n+\t    insert_in_ops_to_visit (op_ptr);\n+\t    continue;\n+\t  }\n \n-  ctx.eval (data, size);\n+\tcase DW_OP_call2:\n+\tcase DW_OP_call4:\n+\t  {\n+\t    unsigned int len = op == DW_OP_call2 ? 2 : 4;\n+\t    cu_offset cu_off\n+\t      = (cu_offset) extract_unsigned_integer (op_ptr, len, byte_order);\n+\t    op_ptr += len;\n \n-  bool in_reg = ctx.location == DWARF_VALUE_REGISTER;\n+\t    auto get_frame_pc = [&symbol_needs] ()\n+\t      {\n+\t\tsymbol_needs = SYMBOL_NEEDS_FRAME;\n+\t\treturn 0;\n+\t      };\n \n-  /* If the location has several pieces, and any of them are in\n-     registers, then we will need a frame to fetch them from.  */\n-  for (dwarf_expr_piece &p : ctx.pieces)\n-    if (p.location == DWARF_VALUE_REGISTER)\n-      in_reg = true;\n+\t    struct dwarf2_locexpr_baton baton\n+\t      = dwarf2_fetch_die_loc_cu_off (cu_off, per_cu,\n+\t\t\t\t\t     per_objfile,\n+\t\t\t\t\t     get_frame_pc);\n \n-  if (in_reg)\n-    ctx.needs = SYMBOL_NEEDS_FRAME;\n+\t    /* If SYMBOL_NEEDS_FRAME is returned from the previous call,\n+\t       we dont have to check the baton content.  */\n+\t    if (symbol_needs != SYMBOL_NEEDS_FRAME)\n+\t      {\n+\t\tgdbarch *arch = baton.per_objfile->objfile->arch ();\n+\t\tgdb::array_view<const gdb_byte> sub_expr (baton.data,\n+\t\t\t\t\t\t\t  baton.size);\n+\t\tsymbol_needs\n+\t\t  = dwarf2_get_symbol_read_needs (sub_expr,\n+\t\t\t\t\t\t  baton.per_cu,\n+\t\t\t\t\t\t  baton.per_objfile,\n+\t\t\t\t\t\t  gdbarch_byte_order (arch),\n+\t\t\t\t\t\t  baton.per_cu->addr_size (),\n+\t\t\t\t\t\t  baton.per_cu->ref_addr_size (),\n+\t\t\t\t\t\t  depth);\n+\t      }\n+\t    break;\n+\t  }\n \n-  return ctx.needs;\n+\tcase DW_OP_GNU_variable_value:\n+\t  {\n+\t    sect_offset sect_off\n+\t      = (sect_offset) extract_unsigned_integer (op_ptr,\n+\t\t\t\t\t\t\tref_addr_size,\n+\t\t\t\t\t\t\tbyte_order);\n+\t    op_ptr += ref_addr_size;\n+\n+\t    struct type *die_type\n+\t      = dwarf2_fetch_die_type_sect_off (sect_off, per_cu,\n+\t\t\t\t\t\tper_objfile);\n+\n+\t    if (die_type == NULL)\n+\t      error (_(\"Bad DW_OP_GNU_variable_value DIE.\"));\n+\n+\t    /* Note: Things still work when the following test is\n+\t       removed.  This test and error is here to conform to the\n+\t       proposed specification.  */\n+\t    if (die_type->code () != TYPE_CODE_INT\n+\t       && die_type->code () != TYPE_CODE_PTR)\n+\t      error (_(\"Type of DW_OP_GNU_variable_value DIE must be \"\n+\t\t       \"an integer or pointer.\"));\n+\n+\t    auto get_frame_pc = [&symbol_needs] ()\n+\t      {\n+\t\tsymbol_needs = SYMBOL_NEEDS_FRAME;\n+\t\treturn 0;\n+\t      };\n+\n+\t    struct dwarf2_locexpr_baton baton\n+\t      = dwarf2_fetch_die_loc_sect_off (sect_off, per_cu,\n+\t\t\t\t\t       per_objfile,\n+\t\t\t\t\t       get_frame_pc, true);\n+\n+\t    /* If SYMBOL_NEEDS_FRAME is returned from the previous call,\n+\t       we dont have to check the baton content.  */\n+\t    if (symbol_needs != SYMBOL_NEEDS_FRAME)\n+\t      {\n+\t\tgdbarch *arch = baton.per_objfile->objfile->arch ();\n+\t\tgdb::array_view<const gdb_byte> sub_expr (baton.data,\n+\t\t\t\t\t\t\t  baton.size);\n+\t\tsymbol_needs\n+\t\t  = dwarf2_get_symbol_read_needs (sub_expr,\n+\t\t\t\t\t\t  baton.per_cu,\n+\t\t\t\t\t\t  baton.per_objfile,\n+\t\t\t\t\t\t  gdbarch_byte_order (arch),\n+\t\t\t\t\t\t  baton.per_cu->addr_size (),\n+\t\t\t\t\t\t  baton.per_cu->ref_addr_size (),\n+\t\t\t\t\t\t  depth);\n+\t      }\n+\t    break;\n+\t  }\n+\n+\tcase DW_OP_const_type:\n+\tcase DW_OP_GNU_const_type:\n+\t  {\n+\t    uint64_t uoffset;\n+\t    op_ptr = safe_read_uleb128 (op_ptr, expr_end, &uoffset);\n+\t    gdb_byte offset = *op_ptr++;\n+\t    op_ptr += offset;\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  error (_(\"Unhandled DWARF expression opcode 0x%x\"), op);\n+\t}\n+\n+      /* If it is known that a frame information is\n+\t needed we can stop parsing the expression.  */\n+      if (symbol_needs == SYMBOL_NEEDS_FRAME)\n+\tbreak;\n+\n+      insert_in_ops_to_visit (op_ptr);\n+    }\n+\n+  return symbol_needs;\n }\n \n /* A helper function that throws an unimplemented error mentioning a\n@@ -3775,9 +4060,15 @@ locexpr_get_symbol_read_needs (struct symbol *symbol)\n   struct dwarf2_locexpr_baton *dlbaton\n     = (struct dwarf2_locexpr_baton *) SYMBOL_LOCATION_BATON (symbol);\n \n-  return dwarf2_loc_desc_get_symbol_read_needs (dlbaton->data, dlbaton->size,\n-\t\t\t\t\t\tdlbaton->per_cu,\n-\t\t\t\t\t\tdlbaton->per_objfile);\n+  gdbarch *arch = dlbaton->per_objfile->objfile->arch ();\n+  gdb::array_view<const gdb_byte> expr (dlbaton->data, dlbaton->size);\n+\n+  return dwarf2_get_symbol_read_needs (expr,\n+\t\t\t\t       dlbaton->per_cu,\n+\t\t\t\t       dlbaton->per_objfile,\n+\t\t\t\t       gdbarch_byte_order (arch),\n+\t\t\t\t       dlbaton->per_cu->addr_size (),\n+\t\t\t\t       dlbaton->per_cu->ref_addr_size ());\n }\n \n /* Return true if DATA points to the end of a piece.  END is one past"
    },
    {
      "sha": "9740944a73cd72aca0f19f9c17173c1291155fb0",
      "filename": "gdb/testsuite/gdb.dwarf2/symbol_needs_eval.c",
      "status": "added",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/gdb.dwarf2/symbol_needs_eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/gdb.dwarf2/symbol_needs_eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/symbol_needs_eval.c?ref=183657edcd11c6fd84b4cf3721250086784999de",
      "patch": "@@ -0,0 +1,25 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2017-2020 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+int exec_mask = 1;\n+\n+int\n+main (void)\n+{\n+  asm volatile (\"main_label: .globl main_label\");\n+  return 0;\n+}"
    },
    {
      "sha": "033e04263478def6207d3c415f683631b1c6de13",
      "filename": "gdb/testsuite/gdb.dwarf2/symbol_needs_eval_fail.exp",
      "status": "added",
      "additions": 112,
      "deletions": 0,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/gdb.dwarf2/symbol_needs_eval_fail.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/gdb.dwarf2/symbol_needs_eval_fail.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/symbol_needs_eval_fail.exp?ref=183657edcd11c6fd84b4cf3721250086784999de",
      "patch": "@@ -0,0 +1,112 @@\n+# Copyright 2017-2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test the symbol needs check mechanism if it assumes that faking\n+# reads from a target is a safe thing to do.\n+#\n+# In particular, the test uses a relative branch DWARF operation to\n+# hide a register read. If the target reads are indeed faked, the\n+# result returned will be wrong.\n+\n+load_lib dwarf.exp\n+\n+# This test can only be run on targets which support DWARF-2 and use gas.\n+if {![dwarf2_support]} {\n+    return 0\n+}\n+\n+# Choose suitable integer registers for the test.\n+\n+set dwarf_regnum 0\n+\n+if { [is_aarch64_target] } {\n+    set regname x0\n+} elseif { [is_aarch32_target]\n+\t   || [istarget \"s390*-*-*\" ]\n+\t   || [istarget \"powerpc*-*-*\"]\n+\t   || [istarget \"rs6000*-*-aix*\"] } {\n+    set regname r0\n+} elseif { [is_x86_like_target] } {\n+    set regname eax\n+} elseif { [is_amd64_regs_target] } {\n+    set regname rax\n+} else {\n+    verbose \"Skipping ${gdb_test_file_name}.\"\n+    return\n+}\n+\n+standard_testfile symbol_needs_eval.c ${gdb_test_file_name}-dw.S\n+\n+# Make some DWARF for the test.\n+\n+set asm_file [standard_output_file $srcfile2]\n+Dwarf::assemble $asm_file {\n+    global dwarf_regnum regname\n+\n+    set exec_mask_var [gdb_target_symbol exec_mask]\n+\n+    cu {} {\n+\tDW_TAG_compile_unit {\n+\t    {DW_AT_name symbol_needs_eval.c}\n+\t    {DW_AT_comp_dir /tmp}\n+\t} {\n+\t    declare_labels int_type_label\n+\n+\t    # define int type\n+\t    int_type_label: DW_TAG_base_type {\n+\t\t{DW_AT_name \"int\"}\n+\t\t{DW_AT_encoding @DW_ATE_signed}\n+\t\t{DW_AT_byte_size 4 DW_FORM_sdata}\n+\t    }\n+\n+\t    # define artificial variable a\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name a}\n+\t\t{DW_AT_type :$int_type_label}\n+\t\t{DW_AT_location {\n+\t\t    DW_OP_addr $exec_mask_var\n+\t\t    DW_OP_deref\n+\n+\t\t    # conditional jump to DW_OP_bregx\n+\t\t    DW_OP_bra 4\n+\t\t    DW_OP_lit0\n+\n+\t\t    # jump to DW_OP_stack_value\n+\t\t    DW_OP_skip 3\n+\t\t    DW_OP_bregx $dwarf_regnum 0\n+\t\t    DW_OP_stack_value\n+\t\t} SPECIAL_expr}\n+\t\t{external 1 flag}\n+\t    }\n+\t}\n+    }\n+}\n+\n+if { [prepare_for_testing ${testfile}.exp ${testfile} \\\n+     [list $srcfile $asm_file] {nodebug}] } {\n+    return -1\n+}\n+\n+# The variable's location expression requires a frame,\n+# so an error should be reported.\n+gdb_test \"print/d a\" \"No frame selected.\" \"variable a can't be printed\"\n+\n+if ![runto_main] {\n+    return -1\n+}\n+\n+gdb_test_no_output \"set var \\$$regname = 2\" \"init reg to 2\"\n+\n+gdb_test \"print/d a\" \" = 2\" \"a == 2\""
    },
    {
      "sha": "4189b4486b3bb25a7bea2fa6a612b3eee976daa7",
      "filename": "gdb/testsuite/gdb.dwarf2/symbol_needs_eval_timeout.exp",
      "status": "added",
      "additions": 131,
      "deletions": 0,
      "changes": 131,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/gdb.dwarf2/symbol_needs_eval_timeout.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/gdb.dwarf2/symbol_needs_eval_timeout.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/symbol_needs_eval_timeout.exp?ref=183657edcd11c6fd84b4cf3721250086784999de",
      "patch": "@@ -0,0 +1,131 @@\n+# Copyright 2017-2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test the symbol needs check mechanism if it assumes that faking\n+# reads from a target is a safe thing to do.\n+#\n+# In particular, the test uses a relative branch DWARF operation to\n+# potentially cause an infinite loop, if the target reads are indeed\n+# faked.\n+\n+load_lib dwarf.exp\n+\n+# This test can only be run on targets which support DWARF-2 and use gas.\n+if {![dwarf2_support]} {\n+    return 0\n+}\n+\n+# Choose suitable integer registers for the test.\n+\n+set dwarf_regnum 0\n+\n+if { [is_aarch64_target] } {\n+    set regname x0\n+} elseif { [is_aarch32_target]\n+\t   || [istarget \"s390*-*-*\" ]\n+\t   || [istarget \"powerpc*-*-*\"]\n+\t   || [istarget \"rs6000*-*-aix*\"] } {\n+    set regname r0\n+} elseif { [is_x86_like_target] } {\n+    set regname eax\n+} elseif { [is_amd64_regs_target] } {\n+    set regname rax\n+} else {\n+    verbose \"Skipping ${gdb_test_file_name}.\"\n+    return\n+}\n+\n+standard_testfile symbol_needs_eval.c ${gdb_test_file_name}-dw.S\n+\n+# Make some DWARF for the test.\n+\n+set asm_file [standard_output_file $srcfile2]\n+Dwarf::assemble $asm_file {\n+    global dwarf_regnum regname\n+\n+    set exec_mask_var [gdb_target_symbol exec_mask]\n+\n+    cu {} {\n+\tDW_TAG_compile_unit {\n+\t    {DW_AT_name symbol_needs_eval.c}\n+\t    {DW_AT_comp_dir /tmp}\n+\t} {\n+\t    declare_labels int_type_label\n+\n+\t    # define int type\n+\t    int_type_label: DW_TAG_base_type {\n+\t\t{DW_AT_name \"int\"}\n+\t\t{DW_AT_encoding @DW_ATE_signed}\n+\t\t{DW_AT_byte_size 4 DW_FORM_sdata}\n+\t    }\n+\n+\t    # add info for variable exec_mask\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name exec_mask}\n+\t\t{DW_AT_type :$int_type_label}\n+\t\t{DW_AT_location {\n+\t\t    DW_OP_addr $exec_mask_var\n+\t\t} SPECIAL_expr}\n+\t\t{external 1 flag}\n+\t    }\n+\n+\t    # add info for subprogram main\n+\t    DW_TAG_subprogram {\n+\t\t{MACRO_AT_func { main }}\n+\t\t{DW_AT_frame_base {\n+\t\t    DW_OP_regx $dwarf_regnum\n+\t\t} SPECIAL_expr}\n+\t    } {\n+\t\t# define artificial variable a\n+\t\tDW_TAG_variable {\n+\t\t    {DW_AT_name a}\n+\t\t    {DW_AT_type :$int_type_label}\n+\t\t    {DW_AT_location {\n+\t\t\tDW_OP_lit1\n+\t\t\tDW_OP_addr $exec_mask_var\n+\t\t\tDW_OP_deref\n+\n+\t\t\t# jump to DW_OP_fbreg\n+\t\t\tDW_OP_skip 4\n+\t\t\tDW_OP_drop\n+\t\t\tDW_OP_fbreg 0\n+\t\t\tDW_OP_dup\n+\t\t\tDW_OP_lit0\n+\t\t\tDW_OP_eq\n+\n+\t\t\t# conditional jump to DW_OP_drop\n+\t\t\tDW_OP_bra -9\n+\t\t\tDW_OP_stack_value\n+\t\t    } SPECIAL_expr}\n+\t\t    {external 1 flag}\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+if { [prepare_for_testing ${testfile}.exp ${testfile} \\\n+\t  [list $srcfile $asm_file] {nodebug}] } {\n+    return -1\n+}\n+\n+if ![runto_main] {\n+    return -1\n+}\n+\n+gdb_test_no_output \"set var \\$$regname = 2\" \"init reg to 2\"\n+gdb_test_no_output \"set var exec_mask = 0\" \"init exec_mask to 0\"\n+\n+gdb_test \"print/d a\" \" = 2\" \"a == 2\""
    },
    {
      "sha": "c8cb9e5aca8b4e0a851a272678c96abbf78e93ac",
      "filename": "gdb/testsuite/gdb.python/amd64-py-framefilter-invalidarg.S",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/gdb.python/amd64-py-framefilter-invalidarg.S",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/gdb.python/amd64-py-framefilter-invalidarg.S",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/amd64-py-framefilter-invalidarg.S?ref=183657edcd11c6fd84b4cf3721250086784999de",
      "patch": "@@ -102,7 +102,6 @@ die4e:\n \t.uleb128 1f - 2f\t# DW_AT_location\n 2:\n \t.byte\t0x13\t# DW_OP_drop\n-\t.quad 0\n 1:\n #endif\n die5c:"
    },
    {
      "sha": "52886d0701beef2c07a3ba80f2990afe7396e869",
      "filename": "gdb/testsuite/lib/dwarf.exp",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/lib/dwarf.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183657edcd11c6fd84b4cf3721250086784999de/gdb/testsuite/lib/dwarf.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/dwarf.exp?ref=183657edcd11c6fd84b4cf3721250086784999de",
      "patch": "@@ -1216,6 +1216,10 @@ namespace eval Dwarf {\n \t\t    _op .sleb128 $argvec(offset)\n \t\t}\n \n+\t\tDW_OP_fbreg {\n+\t\t    _op .sleb128 [lindex $line 1]\n+\t\t}\n+\n \t\tdefault {\n \t\t    if {[llength $line] > 1} {\n \t\t\terror \"Unimplemented: operands in location for $opcode\""
    }
  ]
}