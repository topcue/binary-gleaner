{
  "sha": "b146ba14d7019e046f5691ffbffa1d852b798c72",
  "node_id": "C_kwDOANOeidoAKGIxNDZiYTE0ZDcwMTllMDQ2ZjU2OTFmZmJmZmExZDg1MmI3OThjNzI",
  "commit": {
    "author": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-02-22T19:22:14Z"
    },
    "committer": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-02-22T19:22:14Z"
    },
    "message": "inf-ptrace: Add an event_pipe to be used for async mode in subclasses.\n\nSubclasses of inf_ptrace_target have to opt-in to using the event_pipe\nby implementing the can_async_p and async methods.  For subclasses\nwhich do this, inf_ptrace_target provides is_async_p, async_wait_fd\nand closes the pipe in the close target method.\n\ninf_ptrace_target also provides wrapper routines around the event pipe\n(async_file_open, async_file_close, async_file_flush, and\nasync_file_mark) for use in target methods such as async.\ninf_ptrace_target also exports a static async_file_mark_if_open\nfunction which can be used in SIGCHLD signal handlers.",
    "tree": {
      "sha": "864815823848712c9bd97a6503e5f34772e6b446",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/864815823848712c9bd97a6503e5f34772e6b446"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b146ba14d7019e046f5691ffbffa1d852b798c72",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b146ba14d7019e046f5691ffbffa1d852b798c72",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b146ba14d7019e046f5691ffbffa1d852b798c72",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b146ba14d7019e046f5691ffbffa1d852b798c72/comments",
  "author": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e05523bd2411bac0277da73556f4d01f6c7448aa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e05523bd2411bac0277da73556f4d01f6c7448aa",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e05523bd2411bac0277da73556f4d01f6c7448aa"
    }
  ],
  "stats": {
    "total": 226,
    "additions": 78,
    "deletions": 148
  },
  "files": [
    {
      "sha": "ba84265dd58f5b94248bcc6b2badb6ddb31c2edd",
      "filename": "gdb/fbsd-nat.c",
      "status": "modified",
      "additions": 9,
      "deletions": 41,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.c?ref=b146ba14d7019e046f5691ffbffa1d852b798c72",
      "patch": "@@ -21,7 +21,6 @@\n #include \"gdbsupport/block-signals.h\"\n #include \"gdbsupport/byte-vector.h\"\n #include \"gdbsupport/event-loop.h\"\n-#include \"gdbsupport/event-pipe.h\"\n #include \"gdbcore.h\"\n #include \"inferior.h\"\n #include \"regcache.h\"\n@@ -932,8 +931,6 @@ fbsd_nat_target::update_thread_list ()\n \n /* Async mode support.  */\n \n-static event_pipe fbsd_nat_event_pipe;\n-\n /* Implement the \"can_async_p\" target method.  */\n \n bool\n@@ -946,31 +943,14 @@ fbsd_nat_target::can_async_p ()\n   return true;\n }\n \n-/* Implement the \"is_async_p\" target method.  */\n-\n-bool\n-fbsd_nat_target::is_async_p ()\n-{\n-  return fbsd_nat_event_pipe.is_open ();\n-}\n-\n-/* Implement the \"async_wait_fd\" target method.  */\n-\n-int\n-fbsd_nat_target::async_wait_fd ()\n-{\n-  return fbsd_nat_event_pipe.event_fd ();\n-}\n-\n /* SIGCHLD handler notifies the event-loop in async mode.  */\n \n static void\n sigchld_handler (int signo)\n {\n   int old_errno = errno;\n \n-  if (fbsd_nat_event_pipe.is_open ())\n-    fbsd_nat_event_pipe.mark ();\n+  fbsd_nat_target::async_file_mark_if_open ();\n \n   errno = old_errno;\n }\n@@ -997,34 +977,22 @@ fbsd_nat_target::async (int enable)\n \n   if (enable)\n     {\n-      if (!fbsd_nat_event_pipe.open ())\n+      if (!async_file_open ())\n \tinternal_error (__FILE__, __LINE__, \"failed to create event pipe.\");\n \n-      add_file_handler (fbsd_nat_event_pipe.event_fd (),\n-\t\t\thandle_target_event, NULL, \"fbsd-nat\");\n+      add_file_handler (async_wait_fd (), handle_target_event, NULL, \"fbsd-nat\");\n \n       /* Trigger a poll in case there are pending events to\n \t handle.  */\n-      fbsd_nat_event_pipe.mark ();\n+      async_file_mark ();\n     }\n   else\n     {\n-      delete_file_handler (fbsd_nat_event_pipe.event_fd ());\n-      fbsd_nat_event_pipe.close ();\n+      delete_file_handler (async_wait_fd ());\n+      async_file_close ();\n     }\n }\n \n-/* Implement the \"close\" target method.  */\n-\n-void\n-fbsd_nat_target::close ()\n-{\n-  if (is_async_p ())\n-    async (0);\n-\n-  inf_ptrace_target::close ();\n-}\n-\n #ifdef TDP_RFPPWAIT\n /*\n   To catch fork events, PT_FOLLOW_FORK is set on every traced process\n@@ -1100,7 +1068,7 @@ fbsd_add_vfork_done (ptid_t pid)\n   /* If we're in async mode, need to tell the event loop there's\n      something here to process.  */\n   if (target_is_async_p ())\n-    fbsd_nat_event_pipe.mark ();\n+    async_file_mark ();\n }\n \n /* Check for a pending vfork done event for a specific PID.  */\n@@ -1499,7 +1467,7 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n   /* Ensure any subsequent events trigger a new event in the loop.  */\n   if (is_async_p ())\n-    fbsd_nat_event_pipe.flush ();\n+    async_file_flush ();\n \n   wptid = wait_1 (ptid, ourstatus, target_options);\n \n@@ -1510,7 +1478,7 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n       && ((ourstatus->kind () != TARGET_WAITKIND_IGNORE\n \t  && ourstatus->kind() != TARGET_WAITKIND_NO_RESUMED)\n \t  || ptid != minus_one_ptid))\n-    fbsd_nat_event_pipe.mark ();\n+    async_file_mark ();\n \n   fbsd_nat_debug_printf (\"returning [%s], [%s]\",\n \t\t\t target_pid_to_str (wptid).c_str (),"
    },
    {
      "sha": "2d9c6e19a2c752aefe7ff0d6217483ac5b411504",
      "filename": "gdb/fbsd-nat.h",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/fbsd-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/fbsd-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.h?ref=b146ba14d7019e046f5691ffbffa1d852b798c72",
      "patch": "@@ -67,13 +67,9 @@ class fbsd_nat_target : public inf_ptrace_target\n   void update_thread_list () override;\n \n   bool can_async_p () override;\n-  bool is_async_p () override;\n \n-  int async_wait_fd () override;\n   void async (int) override;\n \n-  void close () override;\n-\n   thread_control_capabilities get_thread_control_capabilities () override\n   { return tc_schedlock; }\n "
    },
    {
      "sha": "ea1fe4541f05691dc8338f31b6917b2c12c0739a",
      "filename": "gdb/inf-ptrace.c",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/inf-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/inf-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-ptrace.c?ref=b146ba14d7019e046f5691ffbffa1d852b798c72",
      "patch": "@@ -48,6 +48,9 @@ gdb_ptrace (PTRACE_TYPE_ARG1 request, ptid_t ptid, PTRACE_TYPE_ARG3 addr,\n #endif\n }\n \n+/* The event pipe registered as a waitable file in the event loop.  */\n+event_pipe inf_ptrace_target::m_event_pipe;\n+\n inf_ptrace_target::~inf_ptrace_target ()\n {}\n \n@@ -527,3 +530,15 @@ inf_ptrace_target::pid_to_str (ptid_t ptid)\n {\n   return normal_pid_to_str (ptid);\n }\n+\n+/* Implement the \"close\" target method.  */\n+\n+void\n+inf_ptrace_target::close ()\n+{\n+  /* Unregister from the event loop.  */\n+  if (is_async_p ())\n+    async (0);\n+\n+  inf_child_target::close ();\n+}"
    },
    {
      "sha": "62cc7778767565793f458ced93975a26925fef17",
      "filename": "gdb/inf-ptrace.h",
      "status": "modified",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/inf-ptrace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/inf-ptrace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-ptrace.h?ref=b146ba14d7019e046f5691ffbffa1d852b798c72",
      "patch": "@@ -20,6 +20,7 @@\n #ifndef INF_PTRACE_H\n #define INF_PTRACE_H\n \n+#include \"gdbsupport/event-pipe.h\"\n #include \"inf-child.h\"\n \n /* An abstract prototype ptrace target.  The client can override it\n@@ -33,6 +34,8 @@ struct inf_ptrace_target : public inf_child_target\n \n   void detach (inferior *inf, int) override;\n \n+  void close () override;\n+\n   void resume (ptid_t, int, enum gdb_signal) override;\n \n   ptid_t wait (ptid_t, struct target_waitstatus *, target_wait_flags) override;\n@@ -57,7 +60,31 @@ struct inf_ptrace_target : public inf_child_target\n \t\t\t\t\tULONGEST offset, ULONGEST len,\n \t\t\t\t\tULONGEST *xfered_len) override;\n \n+  bool is_async_p () override\n+  { return m_event_pipe.is_open (); }\n+\n+  int async_wait_fd () override\n+  { return m_event_pipe.event_fd (); }\n+\n+  /* Helper routine used from SIGCHLD handlers to signal the async\n+     event pipe.  */\n+  static void async_file_mark_if_open ()\n+  {\n+    if (m_event_pipe.is_open ())\n+      m_event_pipe.mark ();\n+  }\n+\n protected:\n+  /* Helper routines for interacting with the async event pipe.  */\n+  bool async_file_open ()\n+  { return m_event_pipe.open (); }\n+  void async_file_close ()\n+  { m_event_pipe.close (); }\n+  void async_file_flush ()\n+  { m_event_pipe.flush (); }\n+  void async_file_mark ()\n+  { m_event_pipe.mark (); }\n+\n   /* Cleanup the inferior after a successful ptrace detach.  */\n   void detach_success (inferior *inf);\n \n@@ -71,6 +98,9 @@ struct inf_ptrace_target : public inf_child_target\n      Such targets will supply an appropriate definition for this\n      function.  */\n   virtual void post_startup_inferior (ptid_t ptid) = 0;\n+\n+private:\n+  static event_pipe m_event_pipe;\n };\n \n #ifndef __NetBSD__"
    },
    {
      "sha": "13682fcff436df9b3dbc5580072adcf440df2f7e",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 24,
      "deletions": 99,
      "changes": 123,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=b146ba14d7019e046f5691ffbffa1d852b798c72",
      "patch": "@@ -48,7 +48,6 @@\n #include <fcntl.h>\t\t/* for O_RDONLY */\n #include \"inf-loop.h\"\n #include \"gdbsupport/event-loop.h\"\n-#include \"gdbsupport/event-pipe.h\"\n #include \"event-top.h\"\n #include <pwd.h>\n #include <sys/types.h>\n@@ -66,6 +65,7 @@\n #include \"gdbsupport/filestuff.h\"\n #include \"objfiles.h\"\n #include \"nat/linux-namespaces.h\"\n+#include \"gdbsupport/block-signals.h\"\n #include \"gdbsupport/fileio.h\"\n #include \"gdbsupport/scope-exit.h\"\n #include \"gdbsupport/gdb-sigmask.h\"\n@@ -227,32 +227,6 @@ static struct simple_pid_list *stopped_pids;\n /* Whether target_thread_events is in effect.  */\n static int report_thread_events;\n \n-/* Async mode support.  */\n-\n-/* The event pipe registered as a waitable file in the event loop.  */\n-static event_pipe linux_nat_event_pipe;\n-\n-/* True if we're currently in async mode.  */\n-#define linux_is_async_p() (linux_nat_event_pipe.is_open ())\n-\n-/* Flush the event pipe.  */\n-\n-static void\n-async_file_flush (void)\n-{\n-  linux_nat_event_pipe.flush ();\n-}\n-\n-/* Put something (anything, doesn't matter what, or how much) in event\n-   pipe, so that the select/poll in the event-loop realizes we have\n-   something to process.  */\n-\n-static void\n-async_file_mark (void)\n-{\n-  linux_nat_event_pipe.mark ();\n-}\n-\n static int kill_lwp (int lwpid, int signo);\n \n static int stop_callback (struct lwp_info *lp);\n@@ -4054,14 +4028,6 @@ linux_nat_target::static_tracepoint_markers_by_strid (const char *strid)\n   return markers;\n }\n \n-/* target_is_async_p implementation.  */\n-\n-bool\n-linux_nat_target::is_async_p ()\n-{\n-  return linux_is_async_p ();\n-}\n-\n /* target_can_async_p implementation.  */\n \n bool\n@@ -4113,10 +4079,11 @@ sigchld_handler (int signo)\n   if (debug_linux_nat)\n     gdb_stdlog->write_async_safe (\"sigchld\\n\", sizeof (\"sigchld\\n\") - 1);\n \n-  if (signo == SIGCHLD\n-      && linux_nat_event_pipe.is_open ())\n-    async_file_mark (); /* Let the event loop know that there are\n-\t\t\t   events to handle.  */\n+  if (signo == SIGCHLD)\n+    {\n+      /* Let the event loop know that there are events to handle.  */\n+      linux_nat_target::async_file_mark_if_open ();\n+    }\n \n   errno = old_errno;\n }\n@@ -4129,67 +4096,35 @@ handle_target_event (int error, gdb_client_data client_data)\n   inferior_event_handler (INF_REG_EVENT);\n }\n \n-/* Create/destroy the target events pipe.  Returns previous state.  */\n-\n-static int\n-linux_async_pipe (int enable)\n-{\n-  int previous = linux_is_async_p ();\n-\n-  if (previous != enable)\n-    {\n-      sigset_t prev_mask;\n-\n-      /* Block child signals while we create/destroy the pipe, as\n-\t their handler writes to it.  */\n-      block_child_signals (&prev_mask);\n-\n-      if (enable)\n-\t{\n-\t  if (!linux_nat_event_pipe.open ())\n-\t    internal_error (__FILE__, __LINE__,\n-\t\t\t    \"creating event pipe failed.\");\n-\t}\n-      else\n-\t{\n-\t  linux_nat_event_pipe.close ();\n-\t}\n-\n-      restore_child_signals_mask (&prev_mask);\n-    }\n-\n-  return previous;\n-}\n-\n-int\n-linux_nat_target::async_wait_fd ()\n-{\n-  return linux_nat_event_pipe.event_fd ();\n-}\n-\n /* target_async implementation.  */\n \n void\n linux_nat_target::async (int enable)\n {\n+  if ((enable != 0) == is_async_p ())\n+    return;\n+\n+  /* Block child signals while we create/destroy the pipe, as their\n+     handler writes to it.  */\n+  gdb::block_signals blocker;\n+\n   if (enable)\n     {\n-      if (!linux_async_pipe (1))\n-\t{\n-\t  add_file_handler (linux_nat_event_pipe.event_fd (),\n-\t\t\t    handle_target_event, NULL,\n-\t\t\t    \"linux-nat\");\n-\t  /* There may be pending events to handle.  Tell the event loop\n-\t     to poll them.  */\n-\t  async_file_mark ();\n-\t}\n+      if (!async_file_open ())\n+\tinternal_error (__FILE__, __LINE__, \"creating event pipe failed.\");\n+\n+      add_file_handler (async_wait_fd (), handle_target_event, NULL,\n+\t\t\t\"linux-nat\");\n+\n+      /* There may be pending events to handle.  Tell the event loop\n+\t to poll them.  */\n+      async_file_mark ();\n     }\n   else\n     {\n-      delete_file_handler (linux_nat_event_pipe.event_fd ());\n-      linux_async_pipe (0);\n+      delete_file_handler (async_wait_fd ());\n+      async_file_close ();\n     }\n-  return;\n }\n \n /* Stop an LWP, and push a GDB_SIGNAL_0 stop status if no other\n@@ -4238,16 +4173,6 @@ linux_nat_target::stop (ptid_t ptid)\n   iterate_over_lwps (ptid, linux_nat_stop_lwp);\n }\n \n-void\n-linux_nat_target::close ()\n-{\n-  /* Unregister from the event loop.  */\n-  if (is_async_p ())\n-    async (0);\n-\n-  inf_ptrace_target::close ();\n-}\n-\n /* When requests are passed down from the linux-nat layer to the\n    single threaded inf-ptrace layer, ptids of (lwpid,0,0) form are\n    used.  The address space pointer is stored in the inferior object,"
    },
    {
      "sha": "12a90eccb2828262f86a4ad2b1bd431108a353fb",
      "filename": "gdb/linux-nat.h",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/linux-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b146ba14d7019e046f5691ffbffa1d852b798c72/gdb/linux-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.h?ref=b146ba14d7019e046f5691ffbffa1d852b798c72",
      "patch": "@@ -83,16 +83,12 @@ class linux_nat_target : public inf_ptrace_target\n   void thread_events (int) override;\n \n   bool can_async_p () override;\n-  bool is_async_p () override;\n \n   bool supports_non_stop () override;\n   bool always_non_stop_p () override;\n \n-  int async_wait_fd () override;\n   void async (int) override;\n \n-  void close () override;\n-\n   void stop (ptid_t) override;\n \n   bool supports_multi_process () override;"
    }
  ]
}