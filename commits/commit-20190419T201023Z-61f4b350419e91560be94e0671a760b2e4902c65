{
  "sha": "61f4b350419e91560be94e0671a760b2e4902c65",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjFmNGIzNTA0MTllOTE1NjBiZTk0ZTA2NzFhNzYwYjJlNDkwMmM2NQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-07T21:29:58Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-19T20:10:23Z"
    },
    "message": "Make copy_name return std::string\n\nThis changes copy_name to return a std::string, updating all the\ncallers.  In some cases, an extra copy was removed.  This also\nrequired a little bit of constification.\n\nTested by the buildbot.\n\ngdb/ChangeLog\n2019-04-19  Tom Tromey  <tom@tromey.com>\n\n\t* type-stack.h (struct type_stack) <insert>: Constify string.\n\t* type-stack.c (type_stack::insert): Constify string.\n\t* gdbtypes.h (lookup_template_type): Update.\n\t(address_space_name_to_int): Update.\n\t* gdbtypes.c (address_space_name_to_int): Make space_identifier\n\tconst.\n\t(lookup_template_type): Make name const.\n\t* c-exp.y: Update rules.\n\t(lex_one_token, classify_name, classify_inner_name)\n\t(c_print_token): Update.\n\t* p-exp.y: Update rules.\n\t(yylex): Update.\n\t* f-exp.y: Update rules.\n\t(yylex): Update.\n\t* d-exp.y: Update rules.\n\t(lex_one_token, classify_name, classify_inner_name): Update.\n\t* parse.c (write_dollar_variable, copy_name): Return std::string.\n\t* parser-defs.h (copy_name): Change return type.\n\t* m2-exp.y: Update rules.\n\t(yylex): Update.\n\t* go-exp.y (lex_one_token): Update.\n\tUpdate rules.\n\t(classify_unsafe_function, classify_packaged_name)\n\t(classify_name, yylex): Update.",
    "tree": {
      "sha": "f1cc08b31b813c81d730ccd69974772d82cbcd12",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f1cc08b31b813c81d730ccd69974772d82cbcd12"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/61f4b350419e91560be94e0671a760b2e4902c65",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/61f4b350419e91560be94e0671a760b2e4902c65",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/61f4b350419e91560be94e0671a760b2e4902c65",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/61f4b350419e91560be94e0671a760b2e4902c65/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "189b8c2e104017600104457b97315da74a22f549",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/189b8c2e104017600104457b97315da74a22f549",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/189b8c2e104017600104457b97315da74a22f549"
    }
  ],
  "stats": {
    "total": 371,
    "additions": 195,
    "deletions": 176
  },
  "files": [
    {
      "sha": "45f8fa50b209b7b512241e22c165509a1452922c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -1,3 +1,30 @@\n+2019-04-19  Tom Tromey  <tom@tromey.com>\n+\n+\t* type-stack.h (struct type_stack) <insert>: Constify string.\n+\t* type-stack.c (type_stack::insert): Constify string.\n+\t* gdbtypes.h (lookup_template_type): Update.\n+\t(address_space_name_to_int): Update.\n+\t* gdbtypes.c (address_space_name_to_int): Make space_identifier\n+\tconst.\n+\t(lookup_template_type): Make name const.\n+\t* c-exp.y: Update rules.\n+\t(lex_one_token, classify_name, classify_inner_name)\n+\t(c_print_token): Update.\n+\t* p-exp.y: Update rules.\n+\t(yylex): Update.\n+\t* f-exp.y: Update rules.\n+\t(yylex): Update.\n+\t* d-exp.y: Update rules.\n+\t(lex_one_token, classify_name, classify_inner_name): Update.\n+\t* parse.c (write_dollar_variable, copy_name): Return std::string.\n+\t* parser-defs.h (copy_name): Change return type.\n+\t* m2-exp.y: Update rules.\n+\t(yylex): Update.\n+\t* go-exp.y (lex_one_token): Update.\n+\tUpdate rules.\n+\t(classify_unsafe_function, classify_packaged_name)\n+\t(classify_name, yylex): Update.\n+\n 2019-04-19  Sergei Trofimovich <siarheit@google.com>\n \n \t* configure.ac: add --enable-source-highlight switch."
    },
    {
      "sha": "47e82b698b418e467f114b03dc1400c0a3e297a7",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 57,
      "deletions": 47,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -474,14 +474,15 @@ exp\t: \tOBJC_LBRAC TYPENAME\n \t\t\t{\n \t\t\t  CORE_ADDR theclass;\n \n+\t\t\t  std::string copy = copy_name ($2.stoken);\n \t\t\t  theclass = lookup_objc_class (pstate->gdbarch (),\n-\t\t\t\t\t\t     copy_name ($2.stoken));\n+\t\t\t\t\t\t\tcopy.c_str ());\n \t\t\t  if (theclass == 0)\n \t\t\t    error (_(\"%s is not an ObjC Class\"),\n-\t\t\t\t   copy_name ($2.stoken));\n+\t\t\t\t   copy.c_str ());\n \t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n \t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t    parse_type (pstate)->builtin_int);\n+\t\t\t\t\t      parse_type (pstate)->builtin_int);\n \t\t\t  write_exp_elt_longcst (pstate, (LONGEST) theclass);\n \t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n \t\t\t  start_msglist();\n@@ -959,7 +960,7 @@ block\t:\tBLOCKNAME\n \t\t\t    $$ = SYMBOL_BLOCK_VALUE ($1.sym.symbol);\n \t\t\t  else\n \t\t\t    error (_(\"No file or function \\\"%s\\\".\"),\n-\t\t\t\t   copy_name ($1.stoken));\n+\t\t\t\t   copy_name ($1.stoken).c_str ());\n \t\t\t}\n \t|\tFILENAME\n \t\t\t{\n@@ -968,13 +969,15 @@ block\t:\tBLOCKNAME\n \t;\n \n block\t:\tblock COLONCOLON name\n-\t\t\t{ struct symbol *tem\n-\t\t\t    = lookup_symbol (copy_name ($3), $1,\n+\t\t\t{\n+\t\t\t  std::string copy = copy_name ($3);\n+\t\t\t  struct symbol *tem\n+\t\t\t    = lookup_symbol (copy.c_str (), $1,\n \t\t\t\t\t     VAR_DOMAIN, NULL).symbol;\n \n \t\t\t  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)\n \t\t\t    error (_(\"No function \\\"%s\\\" in specified context.\"),\n-\t\t\t\t   copy_name ($3));\n+\t\t\t\t   copy.c_str ());\n \t\t\t  $$ = SYMBOL_BLOCK_VALUE (tem); }\n \t;\n \n@@ -985,7 +988,7 @@ variable:\tname_not_typename ENTRY\n \t\t\t      || !symbol_read_needs_frame (sym))\n \t\t\t    error (_(\"@entry can be used only for function \"\n \t\t\t\t     \"parameters, not for \\\"%s\\\"\"),\n-\t\t\t\t   copy_name ($1.stoken));\n+\t\t\t\t   copy_name ($1.stoken).c_str ());\n \n \t\t\t  write_exp_elt_opcode (pstate, OP_VAR_ENTRY_VALUE);\n \t\t\t  write_exp_elt_sym (pstate, sym);\n@@ -994,13 +997,15 @@ variable:\tname_not_typename ENTRY\n \t;\n \n variable:\tblock COLONCOLON name\n-\t\t\t{ struct block_symbol sym\n-\t\t\t    = lookup_symbol (copy_name ($3), $1,\n+\t\t\t{\n+\t\t\t  std::string copy = copy_name ($3);\n+\t\t\t  struct block_symbol sym\n+\t\t\t    = lookup_symbol (copy.c_str (), $1,\n \t\t\t\t\t     VAR_DOMAIN, NULL);\n \n \t\t\t  if (sym.symbol == 0)\n \t\t\t    error (_(\"No symbol \\\"%s\\\" in specified context.\"),\n-\t\t\t\t   copy_name ($3));\n+\t\t\t\t   copy.c_str ());\n \t\t\t  if (symbol_read_needs_frame (sym.symbol))\n \t\t\t    pstate->block_tracker->update (sym);\n \n@@ -1049,22 +1054,23 @@ qualified_name:\tTYPENAME COLONCOLON name\n \t\t\t}\n \t|\tTYPENAME COLONCOLON name COLONCOLON name\n \t\t\t{\n-\t\t\t  char *copy = copy_name ($3);\n+\t\t\t  std::string copy = copy_name ($3);\n \t\t\t  error (_(\"No type \\\"%s\\\" within class \"\n \t\t\t\t   \"or namespace \\\"%s\\\".\"),\n-\t\t\t\t copy, TYPE_SAFE_NAME ($1.type));\n+\t\t\t\t copy.c_str (), TYPE_SAFE_NAME ($1.type));\n \t\t\t}\n \t;\n \n variable:\tqualified_name\n \t|\tCOLONCOLON name_not_typename\n \t\t\t{\n-\t\t\t  char *name = copy_name ($2.stoken);\n+\t\t\t  std::string name = copy_name ($2.stoken);\n \t\t\t  struct symbol *sym;\n \t\t\t  struct bound_minimal_symbol msymbol;\n \n \t\t\t  sym\n-\t\t\t    = lookup_symbol (name, (const struct block *) NULL,\n+\t\t\t    = lookup_symbol (name.c_str (),\n+\t\t\t\t\t     (const struct block *) NULL,\n \t\t\t\t\t     VAR_DOMAIN, NULL).symbol;\n \t\t\t  if (sym)\n \t\t\t    {\n@@ -1075,13 +1081,14 @@ variable:\tqualified_name\n \t\t\t      break;\n \t\t\t    }\n \n-\t\t\t  msymbol = lookup_bound_minimal_symbol (name);\n+\t\t\t  msymbol = lookup_bound_minimal_symbol (name.c_str ());\n \t\t\t  if (msymbol.minsym != NULL)\n \t\t\t    write_exp_msymbol (pstate, msymbol);\n \t\t\t  else if (!have_full_symbols () && !have_partial_symbols ())\n \t\t\t    error (_(\"No symbol table is loaded.  Use the \\\"file\\\" command.\"));\n \t\t\t  else\n-\t\t\t    error (_(\"No symbol \\\"%s\\\" in current context.\"), name);\n+\t\t\t    error (_(\"No symbol \\\"%s\\\" in current context.\"),\n+\t\t\t\t   name.c_str ());\n \t\t\t}\n \t;\n \n@@ -1124,17 +1131,17 @@ variable:\tname_not_typename\n \t\t\t    }\n \t\t\t  else\n \t\t\t    {\n-\t\t\t      char *arg = copy_name ($1.stoken);\n+\t\t\t      std::string arg = copy_name ($1.stoken);\n \n \t\t\t      bound_minimal_symbol msymbol\n-\t\t\t\t= lookup_bound_minimal_symbol (arg);\n+\t\t\t\t= lookup_bound_minimal_symbol (arg.c_str ());\n \t\t\t      if (msymbol.minsym == NULL)\n \t\t\t\t{\n \t\t\t\t  if (!have_full_symbols () && !have_partial_symbols ())\n \t\t\t\t    error (_(\"No symbol table is loaded.  Use the \\\"file\\\" command.\"));\n \t\t\t\t  else\n \t\t\t\t    error (_(\"No symbol \\\"%s\\\" in current context.\"),\n-\t\t\t\t\t   copy_name ($1.stoken));\n+\t\t\t\t\t   arg.c_str ());\n \t\t\t\t}\n \n \t\t\t      /* This minsym might be an alias for\n@@ -1165,7 +1172,8 @@ variable:\tname_not_typename\n \n space_identifier : '@' NAME\n \t\t{\n-\t\t  cpstate->type_stack.insert (pstate, copy_name ($2.stoken));\n+\t\t  cpstate->type_stack.insert (pstate,\n+\t\t\t\t\t      copy_name ($2.stoken).c_str ());\n \t\t}\n \t;\n \n@@ -1409,7 +1417,7 @@ typebase\n \t\t\t\t\t\t0); }\n \t|\tSTRUCT name\n \t\t\t{ $$\n-\t\t\t    = lookup_struct (copy_name ($2),\n+\t\t\t    = lookup_struct (copy_name ($2).c_str (),\n \t\t\t\t\t     pstate->expression_context_block);\n \t\t\t}\n \t|\tSTRUCT COMPLETE\n@@ -1426,7 +1434,8 @@ typebase\n \t\t\t}\n \t|\tCLASS name\n \t\t\t{ $$ = lookup_struct\n-\t\t\t    (copy_name ($2), pstate->expression_context_block);\n+\t\t\t    (copy_name ($2).c_str (),\n+\t\t\t     pstate->expression_context_block);\n \t\t\t}\n \t|\tCLASS COMPLETE\n \t\t\t{\n@@ -1442,7 +1451,7 @@ typebase\n \t\t\t}\n \t|\tUNION name\n \t\t\t{ $$\n-\t\t\t    = lookup_union (copy_name ($2),\n+\t\t\t    = lookup_union (copy_name ($2).c_str (),\n \t\t\t\t\t    pstate->expression_context_block);\n \t\t\t}\n \t|\tUNION COMPLETE\n@@ -1458,7 +1467,7 @@ typebase\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tENUM name\n-\t\t\t{ $$ = lookup_enum (copy_name ($2),\n+\t\t\t{ $$ = lookup_enum (copy_name ($2).c_str (),\n \t\t\t\t\t    pstate->expression_context_block);\n \t\t\t}\n \t|\tENUM COMPLETE\n@@ -1493,7 +1502,7 @@ typebase\n                    in the token processing code in yylex. */\n \t|\tTEMPLATE name '<' type '>'\n \t\t\t{ $$ = lookup_template_type\n-\t\t\t    (copy_name($2), $4,\n+\t\t\t    (copy_name($2).c_str (), $4,\n \t\t\t     pstate->expression_context_block);\n \t\t\t}\n \t| const_or_volatile_or_space_identifier_noopt typebase\n@@ -2551,7 +2560,6 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n   unsigned int i;\n   const char *tokstart;\n   bool saw_structop = last_was_structop;\n-  char *copy;\n \n   last_was_structop = false;\n   *is_quoted_name = false;\n@@ -2879,9 +2887,9 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n   yylval.sval.length = namelen;\n \n   /* Catch specific keywords.  */\n-  copy = copy_name (yylval.sval);\n+  std::string copy = copy_name (yylval.sval);\n   for (i = 0; i < sizeof ident_tokens / sizeof ident_tokens[0]; i++)\n-    if (strcmp (copy, ident_tokens[i].oper) == 0)\n+    if (copy == ident_tokens[i].oper)\n       {\n \tif ((ident_tokens[i].flags & FLAG_CXX) != 0\n \t    && par_state->language ()->la_language != language_cplus)\n@@ -2891,7 +2899,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t  {\n \t    struct field_of_this_result is_a_field_of_this;\n \n-\t    if (lookup_symbol (copy,\n+\t    if (lookup_symbol (copy.c_str (),\n \t\t\t       pstate->expression_context_block,\n \t\t\t       VAR_DOMAIN,\n \t\t\t       (par_state->language ()->la_language\n@@ -2953,16 +2961,15 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t       bool is_quoted_name, bool is_after_structop)\n {\n   struct block_symbol bsym;\n-  char *copy;\n   struct field_of_this_result is_a_field_of_this;\n \n-  copy = copy_name (yylval.sval);\n+  std::string copy = copy_name (yylval.sval);\n \n   /* Initialize this in case we *don't* use it in this call; that way\n      we can refer to it unconditionally below.  */\n   memset (&is_a_field_of_this, 0, sizeof (is_a_field_of_this));\n \n-  bsym = lookup_symbol (copy, block, VAR_DOMAIN,\n+  bsym = lookup_symbol (copy.c_str (), block, VAR_DOMAIN,\n \t\t\tpar_state->language ()->la_name_of_this\n \t\t\t? &is_a_field_of_this : NULL);\n \n@@ -2985,7 +2992,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t{\n \t  struct field_of_this_result inner_is_a_field_of_this;\n \n-\t  bsym = lookup_symbol (copy, block, STRUCT_DOMAIN,\n+\t  bsym = lookup_symbol (copy.c_str (), block, STRUCT_DOMAIN,\n \t\t\t\t&inner_is_a_field_of_this);\n \t  if (bsym.symbol != NULL)\n \t    {\n@@ -3005,7 +3012,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t  /* See if it's a file name. */\n \t  struct symtab *symtab;\n \n-\t  symtab = lookup_symtab (copy);\n+\t  symtab = lookup_symtab (copy.c_str ());\n \t  if (symtab)\n \t    {\n \t      yylval.bval = BLOCKVECTOR_BLOCK (SYMTAB_BLOCKVECTOR (symtab),\n@@ -3024,13 +3031,14 @@ classify_name (struct parser_state *par_state, const struct block *block,\n   /* See if it's an ObjC classname.  */\n   if (par_state->language ()->la_language == language_objc && !bsym.symbol)\n     {\n-      CORE_ADDR Class = lookup_objc_class (par_state->gdbarch (), copy);\n+      CORE_ADDR Class = lookup_objc_class (par_state->gdbarch (),\n+\t\t\t\t\t   copy.c_str ());\n       if (Class)\n \t{\n \t  struct symbol *sym;\n \n \t  yylval.theclass.theclass = Class;\n-\t  sym = lookup_struct_typedef (copy,\n+\t  sym = lookup_struct_typedef (copy.c_str (),\n \t\t\t\t       par_state->expression_context_block, 1);\n \t  if (sym)\n \t    yylval.theclass.type = SYMBOL_TYPE (sym);\n@@ -3046,7 +3054,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t  || (copy[0] >= 'A' && copy[0] < 'A' + input_radix - 10)))\n     {\n       YYSTYPE newlval;\t/* Its value is ignored.  */\n-      int hextype = parse_number (par_state, copy, yylval.sval.length,\n+      int hextype = parse_number (par_state, copy.c_str (), yylval.sval.length,\n \t\t\t\t  0, &newlval);\n \n       if (hextype == INT)\n@@ -3064,7 +3072,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n   if (bsym.symbol == NULL\n       && par_state->language ()->la_language == language_cplus\n       && is_a_field_of_this.type == NULL\n-      && lookup_minimal_symbol (copy, NULL, NULL).minsym == NULL)\n+      && lookup_minimal_symbol (copy.c_str (), NULL, NULL).minsym == NULL)\n     return UNKNOWN_CPP_NAME;\n \n   return NAME;\n@@ -3079,7 +3087,6 @@ classify_inner_name (struct parser_state *par_state,\n \t\t     const struct block *block, struct type *context)\n {\n   struct type *type;\n-  char *copy;\n \n   if (context == NULL)\n     return classify_name (par_state, block, false, false);\n@@ -3088,16 +3095,18 @@ classify_inner_name (struct parser_state *par_state,\n   if (!type_aggregate_p (type))\n     return ERROR;\n \n-  copy = copy_name (yylval.ssym.stoken);\n+  std::string copy = copy_name (yylval.ssym.stoken);\n   /* N.B. We assume the symbol can only be in VAR_DOMAIN.  */\n-  yylval.ssym.sym = cp_lookup_nested_symbol (type, copy, block, VAR_DOMAIN);\n+  yylval.ssym.sym = cp_lookup_nested_symbol (type, copy.c_str (), block,\n+\t\t\t\t\t     VAR_DOMAIN);\n \n   /* If no symbol was found, search for a matching base class named\n      COPY.  This will allow users to enter qualified names of class members\n      relative to the `this' pointer.  */\n   if (yylval.ssym.sym.symbol == NULL)\n     {\n-      struct type *base_type = cp_find_type_baseclass_by_name (type, copy);\n+      struct type *base_type = cp_find_type_baseclass_by_name (type,\n+\t\t\t\t\t\t\t       copy.c_str ());\n \n       if (base_type != NULL)\n \t{\n@@ -3116,7 +3125,8 @@ classify_inner_name (struct parser_state *par_state,\n \t named COPY when we really wanted a base class of the same name.\n \t Double-check this case by looking for a base class.  */\n       {\n-\tstruct type *base_type = cp_find_type_baseclass_by_name (type, copy);\n+\tstruct type *base_type\n+\t  = cp_find_type_baseclass_by_name (type, copy.c_str ());\n \n \tif (base_type != NULL)\n \t  {\n@@ -3368,21 +3378,21 @@ c_print_token (FILE *file, int type, YYSTYPE value)\n \n     case NSSTRING:\n     case DOLLAR_VARIABLE:\n-      parser_fprintf (file, \"sval<%s>\", copy_name (value.sval));\n+      parser_fprintf (file, \"sval<%s>\", copy_name (value.sval).c_str ());\n       break;\n \n     case TYPENAME:\n       parser_fprintf (file, \"tsym<type=%s, name=%s>\",\n \t\t      TYPE_SAFE_NAME (value.tsym.type),\n-\t\t      copy_name (value.tsym.stoken));\n+\t\t      copy_name (value.tsym.stoken).c_str ());\n       break;\n \n     case NAME:\n     case UNKNOWN_CPP_NAME:\n     case NAME_OR_INT:\n     case BLOCKNAME:\n       parser_fprintf (file, \"ssym<name=%s, sym=%s, field_of_this=%d>\",\n-\t\t       copy_name (value.ssym.stoken),\n+\t\t       copy_name (value.ssym.stoken).c_str (),\n \t\t       (value.ssym.sym.symbol == NULL\n \t\t\t? \"(null)\" : SYMBOL_PRINT_NAME (value.ssym.sym.symbol)),\n \t\t       value.ssym.is_a_field_of_this);"
    },
    {
      "sha": "6b25ee298d4eaf2e56a7bfdbeb56af26c11e7995",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 15,
      "deletions": 16,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -415,12 +415,13 @@ PrimaryExpression:\n \t\t{ /* Do nothing.  */ }\n |\tIdentifierExp\n \t\t{ struct bound_minimal_symbol msymbol;\n-\t\t  char *copy = copy_name ($1);\n+\t\t  std::string copy = copy_name ($1);\n \t\t  struct field_of_this_result is_a_field_of_this;\n \t\t  struct block_symbol sym;\n \n \t\t  /* Handle VAR, which could be local or global.  */\n-\t\t  sym = lookup_symbol (copy, pstate->expression_context_block,\n+\t\t  sym = lookup_symbol (copy.c_str (),\n+\t\t\t\t       pstate->expression_context_block,\n \t\t\t\t       VAR_DOMAIN, &is_a_field_of_this);\n \t\t  if (sym.symbol && SYMBOL_CLASS (sym.symbol) != LOC_TYPEDEF)\n \t\t    {\n@@ -445,13 +446,14 @@ PrimaryExpression:\n \t\t  else\n \t\t    {\n \t\t      /* Lookup foreign name in global static symbols.  */\n-\t\t      msymbol = lookup_bound_minimal_symbol (copy);\n+\t\t      msymbol = lookup_bound_minimal_symbol (copy.c_str ());\n \t\t      if (msymbol.minsym != NULL)\n \t\t\twrite_exp_msymbol (pstate, msymbol);\n \t\t      else if (!have_full_symbols () && !have_partial_symbols ())\n \t\t\terror (_(\"No symbol table is loaded.  Use the \\\"file\\\" command\"));\n \t\t      else\n-\t\t\terror (_(\"No symbol \\\"%s\\\" in current context.\"), copy);\n+\t\t\terror (_(\"No symbol \\\"%s\\\" in current context.\"),\n+\t\t\t       copy.c_str ());\n \t\t    }\n \t\t  }\n |\tTypeExp '.' IdentifierExp\n@@ -1037,7 +1039,6 @@ lex_one_token (struct parser_state *par_state)\n   unsigned int i;\n   const char *tokstart;\n   int saw_structop = last_was_structop;\n-  char *copy;\n \n   last_was_structop = 0;\n \n@@ -1281,9 +1282,9 @@ lex_one_token (struct parser_state *par_state)\n   yylval.sval.length = namelen;\n \n   /* Catch specific keywords.  */\n-  copy = copy_name (yylval.sval);\n+  std::string copy = copy_name (yylval.sval);\n   for (i = 0; i < sizeof ident_tokens / sizeof ident_tokens[0]; i++)\n-    if (strcmp (copy, ident_tokens[i].oper) == 0)\n+    if (copy == ident_tokens[i].oper)\n       {\n \t/* It is ok to always set this, even though we don't always\n \t   strictly need to.  */\n@@ -1296,7 +1297,7 @@ lex_one_token (struct parser_state *par_state)\n \n   yylval.tsym.type\n     = language_lookup_primitive_type (par_state->language (),\n-\t\t\t\t      par_state->gdbarch (), copy);\n+\t\t\t\t      par_state->gdbarch (), copy.c_str ());\n   if (yylval.tsym.type != NULL)\n     return TYPENAME;\n \n@@ -1345,12 +1346,11 @@ static int\n classify_name (struct parser_state *par_state, const struct block *block)\n {\n   struct block_symbol sym;\n-  char *copy;\n   struct field_of_this_result is_a_field_of_this;\n \n-  copy = copy_name (yylval.sval);\n+  std::string copy = copy_name (yylval.sval);\n \n-  sym = lookup_symbol (copy, block, VAR_DOMAIN, &is_a_field_of_this);\n+  sym = lookup_symbol (copy.c_str (), block, VAR_DOMAIN, &is_a_field_of_this);\n   if (sym.symbol && SYMBOL_CLASS (sym.symbol) == LOC_TYPEDEF)\n     {\n       yylval.tsym.type = SYMBOL_TYPE (sym.symbol);\n@@ -1359,9 +1359,9 @@ classify_name (struct parser_state *par_state, const struct block *block)\n   else if (sym.symbol == NULL)\n     {\n       /* Look-up first for a module name, then a type.  */\n-      sym = lookup_symbol (copy, block, MODULE_DOMAIN, NULL);\n+      sym = lookup_symbol (copy.c_str (), block, MODULE_DOMAIN, NULL);\n       if (sym.symbol == NULL)\n-\tsym = lookup_symbol (copy, block, STRUCT_DOMAIN, NULL);\n+\tsym = lookup_symbol (copy.c_str (), block, STRUCT_DOMAIN, NULL);\n \n       if (sym.symbol != NULL)\n \t{\n@@ -1384,7 +1384,6 @@ classify_inner_name (struct parser_state *par_state,\n \t\t     const struct block *block, struct type *context)\n {\n   struct type *type;\n-  char *copy;\n \n   if (context == NULL)\n     return classify_name (par_state, block);\n@@ -1393,8 +1392,8 @@ classify_inner_name (struct parser_state *par_state,\n   if (!type_aggregate_p (type))\n     return ERROR;\n \n-  copy = copy_name (yylval.ssym.stoken);\n-  yylval.ssym.sym = d_lookup_nested_symbol (type, copy, block);\n+  std::string copy = copy_name (yylval.ssym.stoken);\n+  yylval.ssym.sym = d_lookup_nested_symbol (type, copy.c_str (), block);\n \n   if (yylval.ssym.sym.symbol == NULL)\n     return ERROR;"
    },
    {
      "sha": "b326d09c44e0ecf4c557cca2cceb64aafe362bd8",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -490,17 +490,17 @@ variable:\tname_not_typename\n \t\t\t  else\n \t\t\t    {\n \t\t\t      struct bound_minimal_symbol msymbol;\n-\t\t\t      char *arg = copy_name ($1.stoken);\n+\t\t\t      std::string arg = copy_name ($1.stoken);\n \n \t\t\t      msymbol =\n-\t\t\t\tlookup_bound_minimal_symbol (arg);\n+\t\t\t\tlookup_bound_minimal_symbol (arg.c_str ());\n \t\t\t      if (msymbol.minsym != NULL)\n \t\t\t\twrite_exp_msymbol (pstate, msymbol);\n \t\t\t      else if (!have_full_symbols () && !have_partial_symbols ())\n \t\t\t\terror (_(\"No symbol table is loaded.  Use the \\\"file\\\" command.\"));\n \t\t\t      else\n \t\t\t\terror (_(\"No symbol \\\"%s\\\" in current context.\"),\n-\t\t\t\t       copy_name ($1.stoken));\n+\t\t\t\t       arg.c_str ());\n \t\t\t    }\n \t\t\t}\n \t;\n@@ -1264,7 +1264,7 @@ yylex (void)\n      currently as names of types; NAME for other symbols.\n      The caller is not constrained to care about the distinction.  */\n   {\n-    char *tmp = copy_name (yylval.sval);\n+    std::string tmp = copy_name (yylval.sval);\n     struct block_symbol result;\n     struct field_of_this_result is_a_field_of_this;\n     enum domain_enum_tag lookup_domains[] =\n@@ -1281,7 +1281,7 @@ yylex (void)\n \t   way we can refer to it unconditionally below.  */\n \tmemset (&is_a_field_of_this, 0, sizeof (is_a_field_of_this));\n \n-\tresult = lookup_symbol (tmp, pstate->expression_context_block,\n+\tresult = lookup_symbol (tmp.c_str (), pstate->expression_context_block,\n \t\t\t\tlookup_domains[i],\n \t\t\t\tpstate->language ()->la_language\n \t\t\t\t== language_cplus\n@@ -1298,7 +1298,7 @@ yylex (void)\n \n     yylval.tsym.type\n       = language_lookup_primitive_type (pstate->language (),\n-\t\t\t\t\tpstate->gdbarch (), tmp);\n+\t\t\t\t\tpstate->gdbarch (), tmp.c_str ());\n     if (yylval.tsym.type != NULL)\n       return TYPENAME;\n     "
    },
    {
      "sha": "b3424d81be45fe53a208fe11e18a40abffb4237d",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -574,7 +574,8 @@ lookup_function_type_with_arguments (struct type *type,\n    return the integer flag defined in gdbtypes.h.  */\n \n int\n-address_space_name_to_int (struct gdbarch *gdbarch, char *space_identifier)\n+address_space_name_to_int (struct gdbarch *gdbarch,\n+\t\t\t   const char *space_identifier)\n {\n   int type_flags;\n \n@@ -1618,7 +1619,7 @@ lookup_enum (const char *name, const struct block *block)\n    visible in lexical block BLOCK.  */\n \n struct type *\n-lookup_template_type (char *name, struct type *type, \n+lookup_template_type (const char *name, struct type *type, \n \t\t      const struct block *block)\n {\n   struct symbol *sym;"
    },
    {
      "sha": "147a2de355edc72eed5f91a84d4f95050325bb40",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -1859,7 +1859,7 @@ extern struct type *make_atomic_type (struct type *);\n \n extern void replace_type (struct type *, struct type *);\n \n-extern int address_space_name_to_int (struct gdbarch *, char *);\n+extern int address_space_name_to_int (struct gdbarch *, const char *);\n \n extern const char *address_space_int_to_name (struct gdbarch *, int);\n \n@@ -2005,7 +2005,7 @@ extern struct type *lookup_typename (const struct language_defn *,\n \t\t\t\t     struct gdbarch *, const char *,\n \t\t\t\t     const struct block *, int);\n \n-extern struct type *lookup_template_type (char *, struct type *,\n+extern struct type *lookup_template_type (const char *, struct type *,\n \t\t\t\t\t  const struct block *);\n \n extern int get_vptr_fieldno (struct type *, struct type **);"
    },
    {
      "sha": "ad174119abb57cc4da35241c9fbf830d48a2b4d9",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 20,
      "deletions": 25,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -538,7 +538,7 @@ variable:\tname_not_typename ENTRY\n \t\t\t      || !symbol_read_needs_frame (sym))\n \t\t\t    error (_(\"@entry can be used only for function \"\n \t\t\t\t     \"parameters, not for \\\"%s\\\"\"),\n-\t\t\t\t   copy_name ($1.stoken));\n+\t\t\t\t   copy_name ($1.stoken).c_str ());\n \n \t\t\t  write_exp_elt_opcode (pstate, OP_VAR_ENTRY_VALUE);\n \t\t\t  write_exp_elt_sym (pstate, sym);\n@@ -568,10 +568,10 @@ variable:\tname_not_typename\n \t\t\t  else\n \t\t\t    {\n \t\t\t      struct bound_minimal_symbol msymbol;\n-\t\t\t      char *arg = copy_name ($1.stoken);\n+\t\t\t      std::string arg = copy_name ($1.stoken);\n \n \t\t\t      msymbol =\n-\t\t\t\tlookup_bound_minimal_symbol (arg);\n+\t\t\t\tlookup_bound_minimal_symbol (arg.c_str ());\n \t\t\t      if (msymbol.minsym != NULL)\n \t\t\t\twrite_exp_msymbol (pstate, msymbol);\n \t\t\t      else if (!have_full_symbols ()\n@@ -580,7 +580,7 @@ variable:\tname_not_typename\n \t\t\t\t       \"Use the \\\"file\\\" command.\"));\n \t\t\t      else\n \t\t\t\terror (_(\"No symbol \\\"%s\\\" in current context.\"),\n-\t\t\t\t       copy_name ($1.stoken));\n+\t\t\t\t       arg.c_str ());\n \t\t\t    }\n \t\t\t}\n \t;\n@@ -1014,7 +1014,6 @@ lex_one_token (struct parser_state *par_state)\n   unsigned int i;\n   const char *tokstart;\n   int saw_structop = last_was_structop;\n-  char *copy;\n \n   last_was_structop = 0;\n \n@@ -1263,9 +1262,9 @@ lex_one_token (struct parser_state *par_state)\n   yylval.sval.length = namelen;\n \n   /* Catch specific keywords.  */\n-  copy = copy_name (yylval.sval);\n+  std::string copy = copy_name (yylval.sval);\n   for (i = 0; i < sizeof (ident_tokens) / sizeof (ident_tokens[0]); i++)\n-    if (strcmp (copy, ident_tokens[i].oper) == 0)\n+    if (copy == ident_tokens[i].oper)\n       {\n \t/* It is ok to always set this, even though we don't always\n \t   strictly need to.  */\n@@ -1347,15 +1346,15 @@ package_name_p (const char *name, const struct block *block)\n static int\n classify_unsafe_function (struct stoken function_name)\n {\n-  char *copy = copy_name (function_name);\n+  std::string copy = copy_name (function_name);\n \n-  if (strcmp (copy, \"Sizeof\") == 0)\n+  if (copy == \"Sizeof\")\n     {\n       yylval.sval = function_name;\n       return SIZEOF_KEYWORD;\n     }\n \n-  error (_(\"Unknown function in `unsafe' package: %s\"), copy);\n+  error (_(\"Unknown function in `unsafe' package: %s\"), copy.c_str ());\n }\n \n /* Classify token(s) \"name1.name2\" where name1 is known to be a package.\n@@ -1367,13 +1366,12 @@ classify_unsafe_function (struct stoken function_name)\n static int\n classify_packaged_name (const struct block *block)\n {\n-  char *copy;\n   struct block_symbol sym;\n   struct field_of_this_result is_a_field_of_this;\n \n-  copy = copy_name (yylval.sval);\n+  std::string copy = copy_name (yylval.sval);\n \n-  sym = lookup_symbol (copy, block, VAR_DOMAIN, &is_a_field_of_this);\n+  sym = lookup_symbol (copy.c_str (), block, VAR_DOMAIN, &is_a_field_of_this);\n \n   if (sym.symbol)\n     {\n@@ -1397,15 +1395,14 @@ classify_name (struct parser_state *par_state, const struct block *block)\n {\n   struct type *type;\n   struct block_symbol sym;\n-  char *copy;\n   struct field_of_this_result is_a_field_of_this;\n \n-  copy = copy_name (yylval.sval);\n+  std::string copy = copy_name (yylval.sval);\n \n   /* Try primitive types first so they win over bad/weird debug info.  */\n   type = language_lookup_primitive_type (par_state->language (),\n \t\t\t\t\t par_state->gdbarch (),\n-\t\t\t\t\t copy);\n+\t\t\t\t\t copy.c_str ());\n   if (type != NULL)\n     {\n       /* NOTE: We take advantage of the fact that yylval coming in was a\n@@ -1417,7 +1414,7 @@ classify_name (struct parser_state *par_state, const struct block *block)\n \n   /* TODO: What about other types?  */\n \n-  sym = lookup_symbol (copy, block, VAR_DOMAIN, &is_a_field_of_this);\n+  sym = lookup_symbol (copy.c_str (), block, VAR_DOMAIN, &is_a_field_of_this);\n \n   if (sym.symbol)\n     {\n@@ -1439,7 +1436,7 @@ classify_name (struct parser_state *par_state, const struct block *block)\n \tstruct stoken sval =\n \t  build_packaged_name (current_package_name,\n \t\t\t       strlen (current_package_name),\n-\t\t\t       copy, strlen (copy));\n+\t\t\t       copy.c_str (), copy.size ());\n \n \txfree (current_package_name);\n \tsym = lookup_symbol (sval.ptr, block, VAR_DOMAIN,\n@@ -1461,8 +1458,8 @@ classify_name (struct parser_state *par_state, const struct block *block)\n       || (copy[0] >= 'A' && copy[0] < 'A' + input_radix - 10))\n     {\n       YYSTYPE newlval;\t/* Its value is ignored.  */\n-      int hextype = parse_number (par_state, copy, yylval.sval.length,\n-\t\t\t\t  0, &newlval);\n+      int hextype = parse_number (par_state, copy.c_str (),\n+\t\t\t\t  yylval.sval.length, 0, &newlval);\n       if (hextype == INT)\n \t{\n \t  yylval.ssym.sym.symbol = NULL;\n@@ -1521,17 +1518,15 @@ yylex (void)\n       if (name2.token == NAME)\n \t{\n \t  /* Ok, we have \"name1 . name2\".  */\n-\t  char *copy;\n+\t  std::string copy = copy_name (current.value.sval);\n \n-\t  copy = copy_name (current.value.sval);\n-\n-\t  if (strcmp (copy, \"unsafe\") == 0)\n+\t  if (copy == \"unsafe\")\n \t    {\n \t      popping = 1;\n \t      return classify_unsafe_function (name2.value.sval);\n \t    }\n \n-\t  if (package_name_p (copy, pstate->expression_context_block))\n+\t  if (package_name_p (copy.c_str (), pstate->expression_context_block))\n \t    {\n \t      popping = 1;\n \t      yylval.sval = build_packaged_name (current.value.sval.ptr,"
    },
    {
      "sha": "6a0173b251de7c7e8b9baef0444fa3240bc4f25a",
      "filename": "gdb/m2-exp.y",
      "status": "modified",
      "additions": 14,
      "deletions": 17,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/m2-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/m2-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-exp.y?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -507,7 +507,7 @@ block\t:\tfblock\n \n fblock\t:\tBLOCKNAME\n \t\t\t{ struct symbol *sym\n-\t\t\t    = lookup_symbol (copy_name ($1),\n+\t\t\t    = lookup_symbol (copy_name ($1).c_str (),\n \t\t\t\t\t     pstate->expression_context_block,\n \t\t\t\t\t     VAR_DOMAIN, 0).symbol;\n \t\t\t  $$ = sym;}\n@@ -517,11 +517,11 @@ fblock\t:\tBLOCKNAME\n /* GDB scope operator */\n fblock\t:\tblock COLONCOLON BLOCKNAME\n \t\t\t{ struct symbol *tem\n-\t\t\t    = lookup_symbol (copy_name ($3), $1,\n+\t\t\t    = lookup_symbol (copy_name ($3).c_str (), $1,\n \t\t\t\t\t     VAR_DOMAIN, 0).symbol;\n \t\t\t  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)\n \t\t\t    error (_(\"No function \\\"%s\\\" in specified context.\"),\n-\t\t\t\t   copy_name ($3));\n+\t\t\t\t   copy_name ($3).c_str ());\n \t\t\t  $$ = tem;\n \t\t\t}\n \t;\n@@ -541,12 +541,12 @@ variable:\tDOLLAR_VARIABLE\n /* GDB scope operator */\n variable:\tblock COLONCOLON NAME\n \t\t\t{ struct block_symbol sym\n-\t\t\t    = lookup_symbol (copy_name ($3), $1,\n+\t\t\t    = lookup_symbol (copy_name ($3).c_str (), $1,\n \t\t\t\t\t     VAR_DOMAIN, 0);\n \n \t\t\t  if (sym.symbol == 0)\n \t\t\t    error (_(\"No symbol \\\"%s\\\" in specified context.\"),\n-\t\t\t\t   copy_name ($3));\n+\t\t\t\t   copy_name ($3).c_str ());\n \t\t\t  if (symbol_read_needs_frame (sym.symbol))\n \t\t\t    pstate->block_tracker->update (sym);\n \n@@ -562,7 +562,7 @@ variable:\tNAME\n \t\t\t  struct field_of_this_result is_a_field_of_this;\n \n \t\t\t  sym\n-\t\t\t    = lookup_symbol (copy_name ($1),\n+\t\t\t    = lookup_symbol (copy_name ($1).c_str (),\n \t\t\t\t\t     pstate->expression_context_block,\n \t\t\t\t\t     VAR_DOMAIN,\n \t\t\t\t\t     &is_a_field_of_this);\n@@ -580,17 +580,17 @@ variable:\tNAME\n \t\t\t  else\n \t\t\t    {\n \t\t\t      struct bound_minimal_symbol msymbol;\n-\t\t\t      char *arg = copy_name ($1);\n+\t\t\t      std::string arg = copy_name ($1);\n \n \t\t\t      msymbol =\n-\t\t\t\tlookup_bound_minimal_symbol (arg);\n+\t\t\t\tlookup_bound_minimal_symbol (arg.c_str ());\n \t\t\t      if (msymbol.minsym != NULL)\n \t\t\t\twrite_exp_msymbol (pstate, msymbol);\n \t\t\t      else if (!have_full_symbols () && !have_partial_symbols ())\n \t\t\t\terror (_(\"No symbol table is loaded.  Use the \\\"symbol-file\\\" command.\"));\n \t\t\t      else\n \t\t\t\terror (_(\"No symbol \\\"%s\\\" in current context.\"),\n-\t\t\t\t       copy_name ($1));\n+\t\t\t\t       arg.c_str ());\n \t\t\t    }\n \t\t\t}\n \t;\n@@ -600,7 +600,7 @@ type\n \t\t\t{ $$\n \t\t\t    = lookup_typename (pstate->language (),\n \t\t\t\t\t       pstate->gdbarch (),\n-\t\t\t\t\t       copy_name ($1),\n+\t\t\t\t\t       copy_name ($1).c_str (),\n \t\t\t\t\t       pstate->expression_context_block,\n \t\t\t\t\t       0);\n \t\t\t}\n@@ -965,20 +965,17 @@ yylex (void)\n      currently as names of types; NAME for other symbols.\n      The caller is not constrained to care about the distinction.  */\n  {\n-\n-\n-    char *tmp = copy_name (yylval.sval);\n+    std::string tmp = copy_name (yylval.sval);\n     struct symbol *sym;\n \n-    if (lookup_symtab (tmp))\n+    if (lookup_symtab (tmp.c_str ()))\n       return BLOCKNAME;\n-    sym = lookup_symbol (tmp, pstate->expression_context_block,\n+    sym = lookup_symbol (tmp.c_str (), pstate->expression_context_block,\n \t\t\t VAR_DOMAIN, 0).symbol;\n     if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)\n       return BLOCKNAME;\n     if (lookup_typename (pstate->language (), pstate->gdbarch (),\n-\t\t\t copy_name (yylval.sval),\n-\t\t\t pstate->expression_context_block, 1))\n+\t\t\t tmp.c_str (), pstate->expression_context_block, 1))\n       return TYPENAME;\n \n     if(sym)"
    },
    {
      "sha": "2d11ff077ac02419fd8e26e199ecf00b62e18594",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 39,
      "deletions": 30,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -620,37 +620,41 @@ block\t:\tBLOCKNAME\n \t\t\t      $$ = SYMBOL_BLOCK_VALUE ($1.sym.symbol);\n \t\t\t  else\n \t\t\t    {\n+\t\t\t      std::string copy = copy_name ($1.stoken);\n \t\t\t      struct symtab *tem =\n-\t\t\t\t  lookup_symtab (copy_name ($1.stoken));\n+\t\t\t\t  lookup_symtab (copy.c_str ());\n \t\t\t      if (tem)\n \t\t\t\t$$ = BLOCKVECTOR_BLOCK (SYMTAB_BLOCKVECTOR (tem),\n \t\t\t\t\t\t\tSTATIC_BLOCK);\n \t\t\t      else\n \t\t\t\terror (_(\"No file or function \\\"%s\\\".\"),\n-\t\t\t\t       copy_name ($1.stoken));\n+\t\t\t\t       copy.c_str ());\n \t\t\t    }\n \t\t\t}\n \t;\n \n block\t:\tblock COLONCOLON name\n-\t\t\t{ struct symbol *tem\n-\t\t\t    = lookup_symbol (copy_name ($3), $1,\n+\t\t\t{\n+\t\t\t  std::string copy = copy_name ($3);\n+\t\t\t  struct symbol *tem\n+\t\t\t    = lookup_symbol (copy.c_str (), $1,\n \t\t\t\t\t     VAR_DOMAIN, NULL).symbol;\n \n \t\t\t  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)\n \t\t\t    error (_(\"No function \\\"%s\\\" in specified context.\"),\n-\t\t\t\t   copy_name ($3));\n+\t\t\t\t   copy.c_str ());\n \t\t\t  $$ = SYMBOL_BLOCK_VALUE (tem); }\n \t;\n \n variable:\tblock COLONCOLON name\n \t\t\t{ struct block_symbol sym;\n \n-\t\t\t  sym = lookup_symbol (copy_name ($3), $1,\n+\t\t\t  std::string copy = copy_name ($3);\n+\t\t\t  sym = lookup_symbol (copy.c_str (), $1,\n \t\t\t\t\t       VAR_DOMAIN, NULL);\n \t\t\t  if (sym.symbol == 0)\n \t\t\t    error (_(\"No symbol \\\"%s\\\" in specified context.\"),\n-\t\t\t\t   copy_name ($3));\n+\t\t\t\t   copy.c_str ());\n \n \t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n \t\t\t  write_exp_elt_block (pstate, sym.block);\n@@ -677,12 +681,13 @@ qualified_name:\ttypebase COLONCOLON name\n variable:\tqualified_name\n \t|\tCOLONCOLON name\n \t\t\t{\n-\t\t\t  char *name = copy_name ($2);\n+\t\t\t  std::string name = copy_name ($2);\n \t\t\t  struct symbol *sym;\n \t\t\t  struct bound_minimal_symbol msymbol;\n \n \t\t\t  sym =\n-\t\t\t    lookup_symbol (name, (const struct block *) NULL,\n+\t\t\t    lookup_symbol (name.c_str (),\n+\t\t\t\t\t   (const struct block *) NULL,\n \t\t\t\t\t   VAR_DOMAIN, NULL).symbol;\n \t\t\t  if (sym)\n \t\t\t    {\n@@ -693,7 +698,8 @@ variable:\tqualified_name\n \t\t\t      break;\n \t\t\t    }\n \n-\t\t\t  msymbol = lookup_bound_minimal_symbol (name);\n+\t\t\t  msymbol\n+\t\t\t    = lookup_bound_minimal_symbol (name.c_str ());\n \t\t\t  if (msymbol.minsym != NULL)\n \t\t\t    write_exp_msymbol (pstate, msymbol);\n \t\t\t  else if (!have_full_symbols ()\n@@ -702,7 +708,7 @@ variable:\tqualified_name\n \t\t\t\t   \"Use the \\\"file\\\" command.\"));\n \t\t\t  else\n \t\t\t    error (_(\"No symbol \\\"%s\\\" in current context.\"),\n-\t\t\t\t   name);\n+\t\t\t\t   name.c_str ());\n \t\t\t}\n \t;\n \n@@ -742,17 +748,17 @@ variable:\tname_not_typename\n \t\t\t      if (this_type)\n \t\t\t\tcurrent_type = lookup_struct_elt_type (\n \t\t\t\t  this_type,\n-\t\t\t\t  copy_name ($1.stoken), 0);\n+\t\t\t\t  copy_name ($1.stoken).c_str (), 0);\n \t\t\t      else\n \t\t\t\tcurrent_type = NULL;\n \t\t\t    }\n \t\t\t  else\n \t\t\t    {\n \t\t\t      struct bound_minimal_symbol msymbol;\n-\t\t\t      char *arg = copy_name ($1.stoken);\n+\t\t\t      std::string arg = copy_name ($1.stoken);\n \n \t\t\t      msymbol =\n-\t\t\t\tlookup_bound_minimal_symbol (arg);\n+\t\t\t\tlookup_bound_minimal_symbol (arg.c_str ());\n \t\t\t      if (msymbol.minsym != NULL)\n \t\t\t\twrite_exp_msymbol (pstate, msymbol);\n \t\t\t      else if (!have_full_symbols ()\n@@ -761,7 +767,7 @@ variable:\tname_not_typename\n \t\t\t\t       \"Use the \\\"file\\\" command.\"));\n \t\t\t      else\n \t\t\t\terror (_(\"No symbol \\\"%s\\\" in current context.\"),\n-\t\t\t\t       copy_name ($1.stoken));\n+\t\t\t\t       arg.c_str ());\n \t\t\t    }\n \t\t\t}\n \t;\n@@ -788,12 +794,12 @@ typebase  /* Implements (approximately): (type-qualifier)* type-specifier */\n \t\t\t{ $$ = $1.type; }\n \t|\tSTRUCT name\n \t\t\t{ $$\n-\t\t\t    = lookup_struct (copy_name ($2),\n+\t\t\t    = lookup_struct (copy_name ($2).c_str (),\n \t\t\t\t\t     pstate->expression_context_block);\n \t\t\t}\n \t|\tCLASS name\n \t\t\t{ $$\n-\t\t\t    = lookup_struct (copy_name ($2),\n+\t\t\t    = lookup_struct (copy_name ($2).c_str (),\n \t\t\t\t\t     pstate->expression_context_block);\n \t\t\t}\n \t/* \"const\" and \"volatile\" are curently ignored.  A type qualifier\n@@ -1508,19 +1514,20 @@ yylex (void)\n      currently as names of types; NAME for other symbols.\n      The caller is not constrained to care about the distinction.  */\n   {\n-    char *tmp = copy_name (yylval.sval);\n+    std::string tmp = copy_name (yylval.sval);\n     struct symbol *sym;\n     struct field_of_this_result is_a_field_of_this;\n     int is_a_field = 0;\n     int hextype;\n \n     is_a_field_of_this.type = NULL;\n     if (search_field && current_type)\n-      is_a_field = (lookup_struct_elt_type (current_type, tmp, 1) != NULL);\n+      is_a_field = (lookup_struct_elt_type (current_type,\n+\t\t\t\t\t    tmp.c_str (), 1) != NULL);\n     if (is_a_field)\n       sym = NULL;\n     else\n-      sym = lookup_symbol (tmp, pstate->expression_context_block,\n+      sym = lookup_symbol (tmp.c_str (), pstate->expression_context_block,\n \t\t\t   VAR_DOMAIN, &is_a_field_of_this).symbol;\n     /* second chance uppercased (as Free Pascal does).  */\n     if (!sym && is_a_field_of_this.type == NULL && !is_a_field)\n@@ -1531,11 +1538,12 @@ yylex (void)\n              tmp[i] -= ('a'-'A');\n          }\n        if (search_field && current_type)\n-\t is_a_field = (lookup_struct_elt_type (current_type, tmp, 1) != NULL);\n+\t is_a_field = (lookup_struct_elt_type (current_type,\n+\t\t\t\t\t       tmp.c_str (), 1) != NULL);\n        if (is_a_field)\n \t sym = NULL;\n        else\n-\t sym = lookup_symbol (tmp, pstate->expression_context_block,\n+\t sym = lookup_symbol (tmp.c_str (), pstate->expression_context_block,\n \t\t\t      VAR_DOMAIN, &is_a_field_of_this).symbol;\n       }\n     /* Third chance Capitalized (as GPC does).  */\n@@ -1553,18 +1561,19 @@ yylex (void)\n              tmp[i] -= ('A'-'a');\n           }\n        if (search_field && current_type)\n-\t is_a_field = (lookup_struct_elt_type (current_type, tmp, 1) != NULL);\n+\t is_a_field = (lookup_struct_elt_type (current_type,\n+\t\t\t\t\t       tmp.c_str (), 1) != NULL);\n        if (is_a_field)\n \t sym = NULL;\n        else\n-\t sym = lookup_symbol (tmp, pstate->expression_context_block,\n+\t sym = lookup_symbol (tmp.c_str (), pstate->expression_context_block,\n \t\t\t      VAR_DOMAIN, &is_a_field_of_this).symbol;\n       }\n \n     if (is_a_field || (is_a_field_of_this.type != NULL))\n       {\n \ttempbuf = (char *) realloc (tempbuf, namelen + 1);\n-\tstrncpy (tempbuf, tmp, namelen);\n+\tstrncpy (tempbuf, tmp.c_str (), namelen);\n \ttempbuf [namelen] = 0;\n \tyylval.sval.ptr = tempbuf;\n \tyylval.sval.length = namelen;\n@@ -1581,7 +1590,7 @@ yylex (void)\n        no psymtabs (coff, xcoff, or some future change to blow away the\n        psymtabs once once symbols are read).  */\n     if ((sym && SYMBOL_CLASS (sym) == LOC_BLOCK)\n-        || lookup_symtab (tmp))\n+        || lookup_symtab (tmp.c_str ()))\n       {\n \tyylval.ssym.sym.symbol = sym;\n \tyylval.ssym.sym.block = NULL;\n@@ -1641,13 +1650,13 @@ yylex (void)\n \t\t      /* As big as the whole rest of the expression, which is\n \t\t\t at least big enough.  */\n \t\t      char *ncopy\n-\t\t\t= (char *) alloca (strlen (tmp) + strlen (namestart)\n+\t\t\t= (char *) alloca (tmp.size () + strlen (namestart)\n \t\t\t\t\t   + 3);\n \t\t      char *tmp1;\n \n \t\t      tmp1 = ncopy;\n-\t\t      memcpy (tmp1, tmp, strlen (tmp));\n-\t\t      tmp1 += strlen (tmp);\n+\t\t      memcpy (tmp1, tmp.c_str (), tmp.size ());\n+\t\t      tmp1 += tmp.size ();\n \t\t      memcpy (tmp1, \"::\", 2);\n \t\t      tmp1 += 2;\n \t\t      memcpy (tmp1, namestart, p - namestart);\n@@ -1685,7 +1694,7 @@ yylex (void)\n         }\n     yylval.tsym.type\n       = language_lookup_primitive_type (pstate->language (),\n-\t\t\t\t\tpstate->gdbarch (), tmp);\n+\t\t\t\t\tpstate->gdbarch (), tmp.c_str ());\n     if (yylval.tsym.type != NULL)\n       {\n \tfree (uptokstart);"
    },
    {
      "sha": "52f29757231c92e416821b3d550da46329a9aabb",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 9,
      "deletions": 28,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -548,6 +548,7 @@ write_dollar_variable (struct parser_state *ps, struct stoken str)\n   struct block_symbol sym;\n   struct bound_minimal_symbol msym;\n   struct internalvar *isym = NULL;\n+  std::string copy;\n \n   /* Handle the tokens $digits; also $ (short for $0) and $$ (short for $$1)\n      and $$digits (equivalent to $<-digits> if you could type that).  */\n@@ -588,7 +589,8 @@ write_dollar_variable (struct parser_state *ps, struct stoken str)\n \n   /* Any names starting with $ are probably debugger internal variables.  */\n \n-  isym = lookup_only_internalvar (copy_name (str) + 1);\n+  copy = copy_name (str);\n+  isym = lookup_only_internalvar (copy.c_str () + 1);\n   if (isym)\n     {\n       write_exp_elt_opcode (ps, OP_INTERNALVAR);\n@@ -600,7 +602,7 @@ write_dollar_variable (struct parser_state *ps, struct stoken str)\n   /* On some systems, such as HP-UX and hppa-linux, certain system routines \n      have names beginning with $ or $$.  Check for those, first.  */\n \n-  sym = lookup_symbol (copy_name (str), NULL, VAR_DOMAIN, NULL);\n+  sym = lookup_symbol (copy.c_str (), NULL, VAR_DOMAIN, NULL);\n   if (sym.symbol)\n     {\n       write_exp_elt_opcode (ps, OP_VAR_VALUE);\n@@ -609,7 +611,7 @@ write_dollar_variable (struct parser_state *ps, struct stoken str)\n       write_exp_elt_opcode (ps, OP_VAR_VALUE);\n       return;\n     }\n-  msym = lookup_bound_minimal_symbol (copy_name (str));\n+  msym = lookup_bound_minimal_symbol (copy.c_str ());\n   if (msym.minsym)\n     {\n       write_exp_msymbol (ps, msym);\n@@ -619,7 +621,7 @@ write_dollar_variable (struct parser_state *ps, struct stoken str)\n   /* Any other names are assumed to be debugger internal variables.  */\n \n   write_exp_elt_opcode (ps, OP_INTERNALVAR);\n-  write_exp_elt_intern (ps, create_internalvar (copy_name (str) + 1));\n+  write_exp_elt_intern (ps, create_internalvar (copy.c_str () + 1));\n   write_exp_elt_opcode (ps, OP_INTERNALVAR);\n   return;\n handle_last:\n@@ -706,33 +708,12 @@ find_template_name_end (const char *p)\n    so they can share the storage that lexptr is parsing.\n    When it is necessary to pass a name to a function that expects\n    a null-terminated string, the substring is copied out\n-   into a separate block of storage.\n+   into a separate block of storage.  */\n \n-   N.B. A single buffer is reused on each call.  */\n-\n-char *\n+std::string\n copy_name (struct stoken token)\n {\n-  /* A temporary buffer for identifiers, so we can null-terminate them.\n-     We allocate this with xrealloc.  parse_exp_1 used to allocate with\n-     alloca, using the size of the whole expression as a conservative\n-     estimate of the space needed.  However, macro expansion can\n-     introduce names longer than the original expression; there's no\n-     practical way to know beforehand how large that might be.  */\n-  static char *namecopy;\n-  static size_t namecopy_size;\n-\n-  /* Make sure there's enough space for the token.  */\n-  if (namecopy_size < token.length + 1)\n-    {\n-      namecopy_size = token.length + 1;\n-      namecopy = (char *) xrealloc (namecopy, token.length + 1);\n-    }\n-      \n-  memcpy (namecopy, token.ptr, token.length);\n-  namecopy[token.length] = 0;\n-\n-  return namecopy;\n+  return std::string (token.ptr, token.length);\n }\n \f\n "
    },
    {
      "sha": "4254ef60e621b010797ded1d162823868c038e94",
      "filename": "gdb/parser-defs.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/parser-defs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/parser-defs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parser-defs.h?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -331,7 +331,7 @@ extern void write_dollar_variable (struct parser_state *, struct stoken str);\n \n extern const char *find_template_name_end (const char *);\n \n-extern char *copy_name (struct stoken);\n+extern std::string copy_name (struct stoken);\n \n extern int dump_subexp (struct expression *, struct ui_file *, int);\n "
    },
    {
      "sha": "7c2a7046ca24c70c5aa7b2ee5012b39a318447e5",
      "filename": "gdb/type-stack.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/type-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/type-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/type-stack.c?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -50,7 +50,7 @@ type_stack::insert (enum type_pieces tp)\n /* See type-stack.h.  */\n \n void\n-type_stack::insert (struct expr_builder *pstate, char *string)\n+type_stack::insert (struct expr_builder *pstate, const char *string)\n {\n   union type_stack_elt element;\n   int slot;"
    },
    {
      "sha": "762afde0bf7b882e91bd7339abe7b2475fde26a1",
      "filename": "gdb/type-stack.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/61f4b350419e91560be94e0671a760b2e4902c65/gdb/type-stack.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/61f4b350419e91560be94e0671a760b2e4902c65/gdb/type-stack.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/type-stack.h?ref=61f4b350419e91560be94e0671a760b2e4902c65",
      "patch": "@@ -160,7 +160,7 @@ struct type_stack\n      tp_pointer, and the new values are inserted above the first\n      item.  */\n \n-  void insert (struct expr_builder *pstate, char *string);\n+  void insert (struct expr_builder *pstate, const char *string);\n \n   /* Append the elements of the type stack FROM to the type stack\n      THIS.  Always returns THIS.  */"
    }
  ]
}