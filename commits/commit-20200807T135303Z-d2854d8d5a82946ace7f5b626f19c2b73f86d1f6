{
  "sha": "d2854d8d5a82946ace7f5b626f19c2b73f86d1f6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDI4NTRkOGQ1YTgyOTQ2YWNlN2Y1YjYyNmYxOWMyYjczZjg2ZDFmNg==",
  "commit": {
    "author": {
      "name": "Caroline Tice",
      "email": "cmtice@google.com",
      "date": "2020-08-07T00:16:45Z"
    },
    "committer": {
      "name": "Caroline Tice",
      "email": "cmtice@google.com",
      "date": "2020-08-07T13:53:03Z"
    },
    "message": "Add code for processing version 5 DWP files (for use with DWARF v5).\n\nThe DWARF v5 Spec describes a (slightly) new format for V5 .dwp files.\n    This patch updates GDB to allow it to read/process .dwp files in the\n    new DWARF v5 format, while continuing to be able to read/process .dwp files\n    in the older V1 & V2 formats (older, pre-standard formats).\n\n    The two major differences between the V2 and the V5 format are:\n        - The inclusion of DWARF-v5-specific sections:\n              .debug_loclists.dwo\n              .debug_rnglists.dwo\n        - The .dwp section identifier encodings have changed.  The table below\n          shows the old & new encodings.  Notice the re-purposing of 5, 7 & 8\n          in particular.\n\n    Val  DW4 section       DW4 section id  DW5 section         DW5 section id\n    --- -----------------  --------------  -----------------   --------------\n     1  .debug_info.dwo    DW_SECT_INFO    .debug_info.dwo     DW_SECT_INFO\n     2  .debug_types.dwo   DW_SECT_TYPES         --              reserved\n     3  .debug_abbrev.dwo  DW_SECT_ABBREV  .debug_abbrev.dwo   DW_SECT_ABBREV\n     4  .debug_line.dwo    DW_SECT_LINE    .debug_line.dwo     DW_SECT_LINE\n     5  .debug_loc.dwo     DW_SECT_LOC     .debug_loclists.dwo DW_SECT_LOCLISTS\n     6  .debug_str_offsets.dwo             .debug_str_offsets.dwo\n                           DW_SECT_STR_OFFSETS                 DW_SECT_STR_OFFSETS\n     7  .debug_macinfo.dwo DW_SECT_MACINFO .debug_macro.dwo    DW_SECT_MACRO\n     8  .debug_macro.dwo   DW_SECT_MACRO   .debug_rnglists.dwo DW_SECT_RNGLISTS",
    "tree": {
      "sha": "06e90569161108233607d827001f9e2877b1ce49",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/06e90569161108233607d827001f9e2877b1ce49"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d2854d8d5a82946ace7f5b626f19c2b73f86d1f6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d2854d8d5a82946ace7f5b626f19c2b73f86d1f6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d2854d8d5a82946ace7f5b626f19c2b73f86d1f6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d2854d8d5a82946ace7f5b626f19c2b73f86d1f6/comments",
  "author": {
    "login": "cmtice",
    "id": 5561162,
    "node_id": "MDQ6VXNlcjU1NjExNjI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5561162?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cmtice",
    "html_url": "https://github.com/cmtice",
    "followers_url": "https://api.github.com/users/cmtice/followers",
    "following_url": "https://api.github.com/users/cmtice/following{/other_user}",
    "gists_url": "https://api.github.com/users/cmtice/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cmtice/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cmtice/subscriptions",
    "organizations_url": "https://api.github.com/users/cmtice/orgs",
    "repos_url": "https://api.github.com/users/cmtice/repos",
    "events_url": "https://api.github.com/users/cmtice/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cmtice/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "cmtice",
    "id": 5561162,
    "node_id": "MDQ6VXNlcjU1NjExNjI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5561162?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cmtice",
    "html_url": "https://github.com/cmtice",
    "followers_url": "https://api.github.com/users/cmtice/followers",
    "following_url": "https://api.github.com/users/cmtice/following{/other_user}",
    "gists_url": "https://api.github.com/users/cmtice/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cmtice/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cmtice/subscriptions",
    "organizations_url": "https://api.github.com/users/cmtice/orgs",
    "repos_url": "https://api.github.com/users/cmtice/repos",
    "events_url": "https://api.github.com/users/cmtice/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cmtice/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7bb178ecf80918d664954c5f2be911d07afae474",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7bb178ecf80918d664954c5f2be911d07afae474",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7bb178ecf80918d664954c5f2be911d07afae474"
    }
  ],
  "stats": {
    "total": 512,
    "additions": 460,
    "deletions": 52
  },
  "files": [
    {
      "sha": "66d08fc13c0bf30659844c516a4a7ae4eaa00205",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d2854d8d5a82946ace7f5b626f19c2b73f86d1f6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d2854d8d5a82946ace7f5b626f19c2b73f86d1f6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d2854d8d5a82946ace7f5b626f19c2b73f86d1f6",
      "patch": "@@ -1,3 +1,35 @@\n+2020-08-06  Caroline Tice <cmtice@google.com>\n+\n+        * dwarf2/read.c (struct dwo_file): Update comment on 'sections' field.\n+        (struct dwp_sections): Update field comments.  Add loclists and\n+        rnglists fields.\n+        (struct virtual_v2_dwo_sections): Rename struct to\n+        'virtual_v2_or_v5_dwo_sections'; update comments at top of struct; add\n+        size & offset fields for loclists and rnglists.\n+        (struct dwp_hash_table): Add a 'v5' struct field to the union section.\n+        (create_debug_type_hash_table): Add 'DW_UT_split_type' to the check for\n+        skipping dummy type units.\n+        (create_dwp_hash_table): Update the large comment above the function to\n+        discuss Version 5 DWP files as well, with references.  Update all the\n+        version checks in the function to check for version 5 as well.  Add new\n+        section at the end to create dwp hash table for version 5.\n+        (create_dwp_v2_section): Rename function to\n+        'create_dwp_v2_or_v5_section'.  Update function comment appropriately.\n+        Add V5 to error message text.\n+        (create_dwo_unit_in_dwp_v2): Change calls to create_dwp_v2_section\n+        into calls to create_dwp_v2_or_v5_section.\n+        (create_dwo_unit_in_dwp_v5): New function.\n+        (lookup_dwo_unit_in_dwp): Update conditional statement to explicitly\n+        check for version2; add else clause to handle version 5.\n+        (open_and_init_dwo_file): Add code to check dwarf version & only call\n+        create_debug_types_hash_table (with sections.types) if version is not 5;\n+        else call create_debug_type_hash_table, with sections.info.\n+        (dwarf2_locate_v2_dwp_sections): Update function comment to mention\n+        version 5.\n+        (dwarf2_locate_v5_dwp_sections): New function.\n+        (open_and_init_dwp_file): Add else-if clause for version 5 to call\n+        bfd_map_over_sections with dwarf2_locate_v5_dwp_sections.\n+\n 2020-08-06  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* regcache.h (class regcache): Remove friend"
    },
    {
      "sha": "ff1c25b9487ccf606da0323030e01f8a2ead558c",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 428,
      "deletions": 52,
      "changes": 480,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d2854d8d5a82946ace7f5b626f19c2b73f86d1f6/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d2854d8d5a82946ace7f5b626f19c2b73f86d1f6/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=d2854d8d5a82946ace7f5b626f19c2b73f86d1f6",
      "patch": "@@ -728,7 +728,7 @@ struct dwo_file\n   gdb_bfd_ref_ptr dbfd;\n \n   /* The sections that make up this DWO file.\n-     Remember that for virtual DWO files in DWP V2, these are virtual\n+     Remember that for virtual DWO files in DWP V2 or DWP V5, these are virtual\n      sections (for lack of a better name).  */\n   struct dwo_sections sections {};\n \n@@ -747,25 +747,27 @@ struct dwo_file\n \n struct dwp_sections\n {\n-  /* These are used by both DWP version 1 and 2.  */\n+  /* These are used by all DWP versions (1, 2 and 5).  */\n   struct dwarf2_section_info str;\n   struct dwarf2_section_info cu_index;\n   struct dwarf2_section_info tu_index;\n \n-  /* These are only used by DWP version 2 files.\n+  /* These are only used by DWP version 2 and version 5 files.\n      In DWP version 1 the .debug_info.dwo, .debug_types.dwo, and other\n      sections are referenced by section number, and are not recorded here.\n-     In DWP version 2 there is at most one copy of all these sections, each\n-     section being (effectively) comprised of the concatenation of all of the\n-     individual sections that exist in the version 1 format.\n+     In DWP version 2 or 5 there is at most one copy of all these sections,\n+     each section being (effectively) comprised of the concatenation of all of\n+     the individual sections that exist in the version 1 format.\n      To keep the code simple we treat each of these concatenated pieces as a\n      section itself (a virtual section?).  */\n   struct dwarf2_section_info abbrev;\n   struct dwarf2_section_info info;\n   struct dwarf2_section_info line;\n   struct dwarf2_section_info loc;\n+  struct dwarf2_section_info loclists;\n   struct dwarf2_section_info macinfo;\n   struct dwarf2_section_info macro;\n+  struct dwarf2_section_info rnglists;\n   struct dwarf2_section_info str_offsets;\n   struct dwarf2_section_info types;\n };\n@@ -786,12 +788,12 @@ struct virtual_v1_dwo_sections\n   struct dwarf2_section_info info_or_types;\n };\n \n-/* Similar to virtual_v1_dwo_sections, but for DWP version 2.\n+/* Similar to virtual_v1_dwo_sections, but for DWP version 2 or 5.\n    In version 2, the sections of the DWO files are concatenated together\n    and stored in one section of that name.  Thus each ELF section contains\n    several \"virtual\" sections.  */\n \n-struct virtual_v2_dwo_sections\n+struct virtual_v2_or_v5_dwo_sections\n {\n   bfd_size_type abbrev_offset;\n   bfd_size_type abbrev_size;\n@@ -802,12 +804,18 @@ struct virtual_v2_dwo_sections\n   bfd_size_type loc_offset;\n   bfd_size_type loc_size;\n \n+  bfd_size_type loclists_offset;\n+  bfd_size_type loclists_size;\n+\n   bfd_size_type macinfo_offset;\n   bfd_size_type macinfo_size;\n \n   bfd_size_type macro_offset;\n   bfd_size_type macro_size;\n \n+  bfd_size_type rnglists_offset;\n+  bfd_size_type rnglists_size;\n+\n   bfd_size_type str_offsets_offset;\n   bfd_size_type str_offsets_size;\n \n@@ -845,6 +853,22 @@ struct dwp_hash_table\n       const gdb_byte *offsets;\n       const gdb_byte *sizes;\n     } v2;\n+    struct\n+    {\n+      /* This is indexed by column number and gives the id of the section\n+\t in that column.  */\n+#define MAX_NR_V5_DWO_SECTIONS \\\n+  (1 /* .debug_info */ \\\n+   + 1 /* .debug_abbrev */ \\\n+   + 1 /* .debug_line */ \\\n+   + 1 /* .debug_loclists */ \\\n+   + 1 /* .debug_str_offsets */ \\\n+   + 1 /* .debug_macro */ \\\n+   + 1 /* .debug_rnglists */)\n+      int section_ids[MAX_NR_V5_DWO_SECTIONS];\n+      const gdb_byte *offsets;\n+      const gdb_byte *sizes;\n+    } v5;\n   } section_pool;\n };\n \n@@ -6396,7 +6420,8 @@ create_debug_type_hash_table (dwarf2_per_objfile *per_objfile,\n       /* Skip dummy type units.  */\n       if (ptr >= info_ptr + length\n \t  || peek_abbrev_code (abfd, ptr) == 0\n-\t  || header.unit_type != DW_UT_type)\n+\t  || (header.unit_type != DW_UT_type\n+\t      && header.unit_type != DW_UT_split_type))\n \t{\n \t  info_ptr += length;\n \t  continue;\n@@ -11519,6 +11544,11 @@ create_cus_hash_table (dwarf2_per_objfile *per_objfile,\n \n /* DWP file .debug_{cu,tu}_index section format:\n    [ref: http://gcc.gnu.org/wiki/DebugFissionDWP]\n+   [ref: http://dwarfstd.org/doc/DWARF5.pdf, sect 7.3.5 \"DWARF Package Files\"]\n+\n+   DWP Versions 1 & 2 are older, pre-standard format versions.  The first\n+   officially standard DWP format was published with DWARF v5 and is called\n+   Version 5.  There are no versions 3 or 4.\n \n    DWP Version 1:\n \n@@ -11563,9 +11593,9 @@ create_cus_hash_table (dwarf2_per_objfile *per_objfile,\n \n    ---\n \n-   DWP Version 2:\n+   DWP Versions 2 and 5:\n \n-   DWP Version 2 combines all the .debug_info, etc. sections into one,\n+   DWP Versions 2 and 5 combine all the .debug_info, etc. sections into one,\n    and the entries in the index tables are now offsets into these sections.\n    CU offsets begin at 0.  TU offsets begin at the size of the .debug_info\n    section.\n@@ -11574,8 +11604,8 @@ create_cus_hash_table (dwarf2_per_objfile *per_objfile,\n     Header\n     Hash Table of Signatures   dwp_hash_table.hash_table\n     Parallel Table of Indices  dwp_hash_table.unit_table\n-    Table of Section Offsets   dwp_hash_table.v2.{section_ids,offsets}\n-    Table of Section Sizes     dwp_hash_table.v2.sizes\n+    Table of Section Offsets   dwp_hash_table.{v2|v5}.{section_ids,offsets}\n+    Table of Section Sizes     dwp_hash_table.{v2|v5}.sizes\n \n    The index section header consists of:\n \n@@ -11598,7 +11628,7 @@ create_cus_hash_table (dwarf2_per_objfile *per_objfile,\n    Each row in the array is indexed starting from 0.  The first row provides\n    a key to the remaining rows: each column in this row provides an identifier\n    for a debug section, and the offsets in the same column of subsequent rows\n-   refer to that section.  The section identifiers are:\n+   refer to that section.  The section identifiers for Version 2 are:\n \n     DW_SECT_INFO         1  .debug_info.dwo\n     DW_SECT_TYPES        2  .debug_types.dwo\n@@ -11609,6 +11639,17 @@ create_cus_hash_table (dwarf2_per_objfile *per_objfile,\n     DW_SECT_MACINFO      7  .debug_macinfo.dwo\n     DW_SECT_MACRO        8  .debug_macro.dwo\n \n+   The section identifiers for Version 5 are:\n+\n+    DW_SECT_INFO_V5         1  .debug_info.dwo\n+    DW_SECT_RESERVED_V5     2  --\n+    DW_SECT_ABBREV_V5       3  .debug_abbrev.dwo\n+    DW_SECT_LINE_V5         4  .debug_line.dwo\n+    DW_SECT_LOCLISTS_V5     5  .debug_loclists.dwo\n+    DW_SECT_STR_OFFSETS_V5  6  .debug_str_offsets.dwo\n+    DW_SECT_MACRO_V5        7  .debug_macro.dwo\n+    DW_SECT_RNGLISTS_V5     8  .debug_rnglists.dwo\n+\n    The offsets provided by the CU and TU index sections are the base offsets\n    for the contributions made by each CU or TU to the corresponding section\n    in the package file.  Each CU and TU header contains an abbrev_offset\n@@ -11677,9 +11718,12 @@ create_dwp_hash_table (dwarf2_per_objfile *per_objfile,\n   index_ptr = index->buffer;\n   index_end = index_ptr + index->size;\n \n+  /* For Version 5, the version is really 2 bytes of data & 2 bytes of padding.\n+     For now it's safe to just read 4 bytes (particularly as it's difficult to\n+     tell if you're dealing with Version 5 before you've read the version).   */\n   version = read_4_bytes (dbfd, index_ptr);\n   index_ptr += 4;\n-  if (version == 2)\n+  if (version == 2 || version == 5)\n     nr_columns = read_4_bytes (dbfd, index_ptr);\n   else\n     nr_columns = 0;\n@@ -11689,7 +11733,7 @@ create_dwp_hash_table (dwarf2_per_objfile *per_objfile,\n   nr_slots = read_4_bytes (dbfd, index_ptr);\n   index_ptr += 4;\n \n-  if (version != 1 && version != 2)\n+  if (version != 1 && version != 2 && version != 5)\n     {\n       error (_(\"Dwarf Error: unsupported DWP file version (%s)\"\n \t       \" [in module %s]\"),\n@@ -11712,11 +11756,13 @@ create_dwp_hash_table (dwarf2_per_objfile *per_objfile,\n \n   /* Exit early if the table is empty.  */\n   if (nr_slots == 0 || nr_units == 0\n-      || (version == 2 && nr_columns == 0))\n+      || (version == 2 && nr_columns == 0)\n+      || (version == 5 && nr_columns == 0))\n     {\n       /* All must be zero.  */\n       if (nr_slots != 0 || nr_units != 0\n-\t  || (version == 2 && nr_columns != 0))\n+\t  || (version == 2 && nr_columns != 0)\n+\t  || (version == 5 && nr_columns != 0))\n \t{\n \t  complaint (_(\"Empty DWP but nr_slots,nr_units,nr_columns not\"\n \t\t       \" all zero [in modules %s]\"),\n@@ -11732,7 +11778,7 @@ create_dwp_hash_table (dwarf2_per_objfile *per_objfile,\n       /* It's harder to decide whether the section is too small in v1.\n \t V1 is deprecated anyway so we punt.  */\n     }\n-  else\n+  else if (version == 2)\n     {\n       const gdb_byte *ids_ptr = htab->unit_table + sizeof (uint32_t) * nr_slots;\n       int *ids = htab->section_pool.v2.section_ids;\n@@ -11803,6 +11849,74 @@ create_dwp_hash_table (dwarf2_per_objfile *per_objfile,\n \t\t dwp_file->name);\n \t}\n     }\n+  else /* version == 5  */\n+    {\n+      const gdb_byte *ids_ptr = htab->unit_table + sizeof (uint32_t) * nr_slots;\n+      int *ids = htab->section_pool.v5.section_ids;\n+      size_t sizeof_ids = sizeof (htab->section_pool.v5.section_ids);\n+      /* Reverse map for error checking.  */\n+      int ids_seen[DW_SECT_MAX_V5 + 1];\n+\n+      if (nr_columns < 2)\n+\t{\n+\t  error (_(\"Dwarf Error: bad DWP hash table, too few columns\"\n+\t\t   \" in section table [in module %s]\"),\n+\t\t dwp_file->name);\n+\t}\n+      if (nr_columns > MAX_NR_V5_DWO_SECTIONS)\n+\t{\n+\t  error (_(\"Dwarf Error: bad DWP hash table, too many columns\"\n+\t\t   \" in section table [in module %s]\"),\n+\t\t dwp_file->name);\n+\t}\n+      memset (ids, 255, sizeof_ids);\n+      memset (ids_seen, 255, sizeof (ids_seen));\n+      for (int i = 0; i < nr_columns; ++i)\n+\t{\n+\t  int id = read_4_bytes (dbfd, ids_ptr + i * sizeof (uint32_t));\n+\n+\t  if (id < DW_SECT_MIN || id > DW_SECT_MAX_V5)\n+\t    {\n+\t      error (_(\"Dwarf Error: bad DWP hash table, bad section id %d\"\n+\t\t       \" in section table [in module %s]\"),\n+\t\t     id, dwp_file->name);\n+\t    }\n+\t  if (ids_seen[id] != -1)\n+\t    {\n+\t      error (_(\"Dwarf Error: bad DWP hash table, duplicate section\"\n+\t\t       \" id %d in section table [in module %s]\"),\n+\t\t     id, dwp_file->name);\n+\t    }\n+\t  ids_seen[id] = i;\n+\t  ids[i] = id;\n+\t}\n+      /* Must have seen an info section.  */\n+      if (ids_seen[DW_SECT_INFO_V5] == -1)\n+\t{\n+\t  error (_(\"Dwarf Error: bad DWP hash table, missing/duplicate\"\n+\t\t   \" DWO info/types section [in module %s]\"),\n+\t\t dwp_file->name);\n+\t}\n+      /* Must have an abbrev section.  */\n+      if (ids_seen[DW_SECT_ABBREV_V5] == -1)\n+\t{\n+\t  error (_(\"Dwarf Error: bad DWP hash table, missing DWO abbrev\"\n+\t\t   \" section [in module %s]\"),\n+\t\t dwp_file->name);\n+\t}\n+      htab->section_pool.v5.offsets = ids_ptr + sizeof (uint32_t) * nr_columns;\n+      htab->section_pool.v5.sizes\n+\t= htab->section_pool.v5.offsets + (sizeof (uint32_t)\n+\t\t\t\t\t * nr_units * nr_columns);\n+      if ((htab->section_pool.v5.sizes + (sizeof (uint32_t)\n+\t\t\t\t\t  * nr_units * nr_columns))\n+\t  > index_end)\n+\t{\n+\t  error (_(\"Dwarf Error: DWP index section is corrupt (too small)\"\n+\t\t   \" [in module %s]\"),\n+\t\t dwp_file->name);\n+\t}\n+    }\n \n   return htab;\n }\n@@ -12042,15 +12156,15 @@ create_dwo_unit_in_dwp_v1 (dwarf2_per_objfile *per_objfile,\n   return dwo_unit;\n }\n \n-/* Subroutine of create_dwo_unit_in_dwp_v2 to simplify it.\n-   Given a pointer to the containing section SECTION, and OFFSET,SIZE of the\n-   piece within that section used by a TU/CU, return a virtual section\n-   of just that piece.  */\n+/* Subroutine of create_dwo_unit_in_dwp_v2 and create_dwo_unit_in_dwp_v5 to\n+   simplify them.  Given a pointer to the containing section SECTION, and\n+   OFFSET,SIZE of the piece within that section used by a TU/CU, return a\n+   virtual section of just that piece.  */\n \n static struct dwarf2_section_info\n-create_dwp_v2_section (dwarf2_per_objfile *per_objfile,\n-\t\t       struct dwarf2_section_info *section,\n-\t\t       bfd_size_type offset, bfd_size_type size)\n+create_dwp_v2_or_v5_section (dwarf2_per_objfile *per_objfile,\n+\t\t\t     struct dwarf2_section_info *section,\n+\t\t\t     bfd_size_type offset, bfd_size_type size)\n {\n   struct dwarf2_section_info result;\n   asection *sectp;\n@@ -12073,7 +12187,7 @@ create_dwp_v2_section (dwarf2_per_objfile *per_objfile,\n   if (sectp == NULL\n       || offset + size > bfd_section_size (sectp))\n     {\n-      error (_(\"Dwarf Error: Bad DWP V2 section info, doesn't fit\"\n+      error (_(\"Dwarf Error: Bad DWP V2 or V5 section info, doesn't fit\"\n \t       \" in section %s [in module %s]\"),\n \t     sectp ? bfd_section_name (sectp) : \"<unknown>\",\n \t     objfile_name (per_objfile->objfile));\n@@ -12102,7 +12216,7 @@ create_dwo_unit_in_dwp_v2 (dwarf2_per_objfile *per_objfile,\n   const char *kind = is_debug_types ? \"TU\" : \"CU\";\n   struct dwo_file *dwo_file;\n   struct dwo_unit *dwo_unit;\n-  struct virtual_v2_dwo_sections sections;\n+  struct virtual_v2_or_v5_dwo_sections sections;\n   void **dwo_file_slot;\n   int i;\n \n@@ -12198,25 +12312,29 @@ create_dwo_unit_in_dwp_v2 (dwarf2_per_objfile *per_objfile,\n       dwo_file->dwo_name = per_objfile->objfile->intern (virtual_dwo_name);\n       dwo_file->comp_dir = comp_dir;\n       dwo_file->sections.abbrev =\n-\tcreate_dwp_v2_section (per_objfile, &dwp_file->sections.abbrev,\n-\t\t\t       sections.abbrev_offset, sections.abbrev_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile, &dwp_file->sections.abbrev,\n+\t\t\t\t     sections.abbrev_offset,\n+\t\t\t\t     sections.abbrev_size);\n       dwo_file->sections.line =\n-\tcreate_dwp_v2_section (per_objfile, &dwp_file->sections.line,\n-\t\t\t       sections.line_offset, sections.line_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile, &dwp_file->sections.line,\n+\t\t\t\t     sections.line_offset,\n+\t\t\t\t     sections.line_size);\n       dwo_file->sections.loc =\n-\tcreate_dwp_v2_section (per_objfile, &dwp_file->sections.loc,\n-\t\t\t       sections.loc_offset, sections.loc_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile, &dwp_file->sections.loc,\n+\t\t\t\t     sections.loc_offset, sections.loc_size);\n       dwo_file->sections.macinfo =\n-\tcreate_dwp_v2_section (per_objfile, &dwp_file->sections.macinfo,\n-\t\t\t       sections.macinfo_offset, sections.macinfo_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile, &dwp_file->sections.macinfo,\n+\t\t\t\t     sections.macinfo_offset,\n+\t\t\t\t     sections.macinfo_size);\n       dwo_file->sections.macro =\n-\tcreate_dwp_v2_section (per_objfile, &dwp_file->sections.macro,\n-\t\t\t       sections.macro_offset, sections.macro_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile, &dwp_file->sections.macro,\n+\t\t\t\t     sections.macro_offset,\n+\t\t\t\t     sections.macro_size);\n       dwo_file->sections.str_offsets =\n-\tcreate_dwp_v2_section (per_objfile,\n-\t\t\t       &dwp_file->sections.str_offsets,\n-\t\t\t       sections.str_offsets_offset,\n-\t\t\t       sections.str_offsets_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile,\n+\t\t\t\t     &dwp_file->sections.str_offsets,\n+\t\t\t\t     sections.str_offsets_offset,\n+\t\t\t\t     sections.str_offsets_size);\n       /* The \"str\" section is global to the entire DWP file.  */\n       dwo_file->sections.str = dwp_file->sections.str;\n       /* The info or types section is assigned below to dwo_unit,\n@@ -12243,12 +12361,195 @@ create_dwo_unit_in_dwp_v2 (dwarf2_per_objfile *per_objfile,\n   dwo_unit->signature = signature;\n   dwo_unit->section =\n     XOBNEW (&per_objfile->per_bfd->obstack, struct dwarf2_section_info);\n-  *dwo_unit->section = create_dwp_v2_section (per_objfile,\n-\t\t\t\t\t      is_debug_types\n-\t\t\t\t\t      ? &dwp_file->sections.types\n-\t\t\t\t\t      : &dwp_file->sections.info,\n-\t\t\t\t\t      sections.info_or_types_offset,\n-\t\t\t\t\t      sections.info_or_types_size);\n+  *dwo_unit->section = create_dwp_v2_or_v5_section\n+                         (per_objfile,\n+\t\t\t  is_debug_types\n+\t\t\t  ? &dwp_file->sections.types\n+\t\t\t  : &dwp_file->sections.info,\n+\t\t\t  sections.info_or_types_offset,\n+\t\t\t  sections.info_or_types_size);\n+  /* dwo_unit->{offset,length,type_offset_in_tu} are set later.  */\n+\n+  return dwo_unit;\n+}\n+\n+/* Create a dwo_unit object for the DWO unit with signature SIGNATURE.\n+   UNIT_INDEX is the index of the DWO unit in the DWP hash table.\n+   COMP_DIR is the DW_AT_comp_dir attribute of the referencing CU.\n+   This is for DWP version 5 files.  */\n+\n+static struct dwo_unit *\n+create_dwo_unit_in_dwp_v5 (dwarf2_per_objfile *per_objfile,\n+\t\t\t   struct dwp_file *dwp_file,\n+\t\t\t   uint32_t unit_index,\n+\t\t\t   const char *comp_dir,\n+\t\t\t   ULONGEST signature, int is_debug_types)\n+{\n+  const struct dwp_hash_table *dwp_htab\n+    = is_debug_types ? dwp_file->tus : dwp_file->cus;\n+  bfd *dbfd = dwp_file->dbfd.get ();\n+  const char *kind = is_debug_types ? \"TU\" : \"CU\";\n+  struct dwo_file *dwo_file;\n+  struct dwo_unit *dwo_unit;\n+  struct virtual_v2_or_v5_dwo_sections sections {};\n+  void **dwo_file_slot;\n+\n+  gdb_assert (dwp_file->version == 5);\n+\n+  if (dwarf_read_debug)\n+    {\n+      fprintf_unfiltered (gdb_stdlog, \"Reading %s %s/%s in DWP V5 file: %s\\n\",\n+                          kind,\n+                          pulongest (unit_index), hex_string (signature),\n+                          dwp_file->name);\n+    }\n+\n+  /* Fetch the section offsets of this DWO unit.  */\n+\n+  /*  memset (&sections, 0, sizeof (sections)); */\n+\n+  for (int i = 0; i < dwp_htab->nr_columns; ++i)\n+    {\n+      uint32_t offset = read_4_bytes (dbfd,\n+                                      dwp_htab->section_pool.v5.offsets\n+                                      + (((unit_index - 1)\n+                                          * dwp_htab->nr_columns\n+                                          + i)\n+                                         * sizeof (uint32_t)));\n+      uint32_t size = read_4_bytes (dbfd,\n+                                    dwp_htab->section_pool.v5.sizes\n+                                    + (((unit_index - 1) * dwp_htab->nr_columns\n+                                        + i)\n+                                       * sizeof (uint32_t)));\n+\n+      switch (dwp_htab->section_pool.v5.section_ids[i])\n+        {\n+          case DW_SECT_ABBREV_V5:\n+            sections.abbrev_offset = offset;\n+            sections.abbrev_size = size;\n+            break;\n+          case DW_SECT_INFO_V5:\n+            sections.info_or_types_offset = offset;\n+            sections.info_or_types_size = size;\n+            break;\n+          case DW_SECT_LINE_V5:\n+            sections.line_offset = offset;\n+            sections.line_size = size;\n+            break;\n+          case DW_SECT_LOCLISTS_V5:\n+            sections.loclists_offset = offset;\n+            sections.loclists_size = size;\n+            break;\n+          case DW_SECT_MACRO_V5:\n+            sections.macro_offset = offset;\n+            sections.macro_size = size;\n+            break;\n+          case DW_SECT_RNGLISTS_V5:\n+            sections.rnglists_offset = offset;\n+            sections.rnglists_size = size;\n+            break;\n+          case DW_SECT_STR_OFFSETS_V5:\n+            sections.str_offsets_offset = offset;\n+            sections.str_offsets_size = size;\n+            break;\n+          case DW_SECT_RESERVED_V5:\n+          default:\n+            break;\n+        }\n+    }\n+\n+  /* It's easier for the rest of the code if we fake a struct dwo_file and\n+     have dwo_unit \"live\" in that.  At least for now.\n+\n+     The DWP file can be made up of a random collection of CUs and TUs.\n+     However, for each CU + set of TUs that came from the same original DWO\n+     file, we can combine them back into a virtual DWO file to save space\n+     (fewer struct dwo_file objects to allocate).  Remember that for really\n+     large apps there can be on the order of 8K CUs and 200K TUs, or more.  */\n+\n+  std::string virtual_dwo_name =\n+    string_printf (\"virtual-dwo/%ld-%ld-%ld-%ld-%ld-%ld\",\n+                 (long) (sections.abbrev_size ? sections.abbrev_offset : 0),\n+                 (long) (sections.line_size ? sections.line_offset : 0),\n+                 (long) (sections.loclists_size ? sections.loclists_offset : 0),\n+                 (long) (sections.str_offsets_size\n+                            ? sections.str_offsets_offset : 0),\n+                 (long) (sections.macro_size ? sections.macro_offset : 0),\n+                 (long) (sections.rnglists_size ? sections.rnglists_offset: 0));\n+  /* Can we use an existing virtual DWO file?  */\n+  dwo_file_slot = lookup_dwo_file_slot (per_objfile,\n+                                        virtual_dwo_name.c_str (),\n+                                        comp_dir);\n+  /* Create one if necessary.  */\n+  if (*dwo_file_slot == NULL)\n+    {\n+      if (dwarf_read_debug)\n+        {\n+          fprintf_unfiltered (gdb_stdlog, \"Creating virtual DWO: %s\\n\",\n+                              virtual_dwo_name.c_str ());\n+        }\n+      dwo_file = new struct dwo_file;\n+      dwo_file->dwo_name = per_objfile->objfile->intern (virtual_dwo_name);\n+      dwo_file->comp_dir = comp_dir;\n+      dwo_file->sections.abbrev =\n+        create_dwp_v2_or_v5_section (per_objfile,\n+                                     &dwp_file->sections.abbrev,\n+                                     sections.abbrev_offset,\n+                                     sections.abbrev_size);\n+      dwo_file->sections.line =\n+        create_dwp_v2_or_v5_section (per_objfile,\n+                                     &dwp_file->sections.line,\n+                                     sections.line_offset, sections.line_size);\n+      dwo_file->sections.macro =\n+        create_dwp_v2_or_v5_section (per_objfile,\n+                                     &dwp_file->sections.macro,\n+                                     sections.macro_offset,\n+                                     sections.macro_size);\n+      dwo_file->sections.loclists =\n+        create_dwp_v2_or_v5_section (per_objfile,\n+                                     &dwp_file->sections.loclists,\n+                                     sections.loclists_offset,\n+                                     sections.loclists_size);\n+      dwo_file->sections.rnglists =\n+        create_dwp_v2_or_v5_section (per_objfile,\n+                                     &dwp_file->sections.rnglists,\n+                                     sections.rnglists_offset,\n+                                     sections.rnglists_size);\n+      dwo_file->sections.str_offsets =\n+        create_dwp_v2_or_v5_section (per_objfile,\n+                                     &dwp_file->sections.str_offsets,\n+                                     sections.str_offsets_offset,\n+                                     sections.str_offsets_size);\n+      /* The \"str\" section is global to the entire DWP file.  */\n+      dwo_file->sections.str = dwp_file->sections.str;\n+      /* The info or types section is assigned below to dwo_unit,\n+         there's no need to record it in dwo_file.\n+         Also, we can't simply record type sections in dwo_file because\n+         we record a pointer into the vector in dwo_unit.  As we collect more\n+         types we'll grow the vector and eventually have to reallocate space\n+         for it, invalidating all copies of pointers into the previous\n+         contents.  */\n+      *dwo_file_slot = dwo_file;\n+    }\n+  else\n+    {\n+      if (dwarf_read_debug)\n+        {\n+          fprintf_unfiltered (gdb_stdlog, \"Using existing virtual DWO: %s\\n\",\n+                              virtual_dwo_name.c_str ());\n+        }\n+      dwo_file = (struct dwo_file *) *dwo_file_slot;\n+    }\n+\n+  dwo_unit = OBSTACK_ZALLOC (&per_objfile->per_bfd->obstack, struct dwo_unit);\n+  dwo_unit->dwo_file = dwo_file;\n+  dwo_unit->signature = signature;\n+  dwo_unit->section\n+    = XOBNEW (&per_objfile->per_bfd->obstack, struct dwarf2_section_info);\n+  *dwo_unit->section = create_dwp_v2_or_v5_section (per_objfile,\n+                                              &dwp_file->sections.info,\n+                                              sections.info_or_types_offset,\n+                                              sections.info_or_types_size);\n   /* dwo_unit->{offset,length,type_offset_in_tu} are set later.  */\n \n   return dwo_unit;\n@@ -12301,12 +12602,18 @@ lookup_dwo_unit_in_dwp (dwarf2_per_objfile *per_objfile,\n \t\t\t\t\t\t unit_index, comp_dir,\n \t\t\t\t\t\t signature, is_debug_types);\n \t    }\n-\t  else\n+\t  else if (dwp_file->version == 2)\n \t    {\n \t      *slot = create_dwo_unit_in_dwp_v2 (per_objfile, dwp_file,\n \t\t\t\t\t\t unit_index, comp_dir,\n \t\t\t\t\t\t signature, is_debug_types);\n \t    }\n+\t  else /* version == 5  */\n+\t    {\n+\t      *slot = create_dwo_unit_in_dwp_v5 (per_objfile, dwp_file,\n+\t\t\t\t\t\t unit_index, comp_dir,\n+\t\t\t\t\t\t signature, is_debug_types);\n+\t    }\n \t  return (struct dwo_unit *) *slot;\n \t}\n       if (signature_in_table == 0)\n@@ -12526,8 +12833,17 @@ open_and_init_dwo_file (dwarf2_cu *cu, const char *dwo_name,\n   create_cus_hash_table (per_objfile, cu, *dwo_file, dwo_file->sections.info,\n \t\t\t dwo_file->cus);\n \n-  create_debug_types_hash_table (per_objfile, dwo_file.get (),\n-\t\t\t\t dwo_file->sections.types, dwo_file->tus);\n+  if (cu->per_cu->dwarf_version < 5)\n+    {\n+      create_debug_types_hash_table (per_objfile, dwo_file.get (),\n+\t\t\t\t     dwo_file->sections.types, dwo_file->tus);\n+    }\n+  else\n+    {\n+      create_debug_type_hash_table (per_objfile, dwo_file.get (),\n+\t\t\t\t    &dwo_file->sections.info, dwo_file->tus,\n+\t\t\t\t    rcuh_kind::TYPE);\n+    }\n \n   if (dwarf_read_debug)\n     fprintf_unfiltered (gdb_stdlog, \"DWO file found: %s\\n\", dwo_name);\n@@ -12573,7 +12889,7 @@ dwarf2_locate_common_dwp_sections (bfd *abfd, asection *sectp,\n /* This function is mapped across the sections and remembers the offset and\n    size of each of the DWP version 2 debugging sections that we are interested\n    in.  This is split into a separate function because we don't know if we\n-   have version 1 or 2 until we parse the cu_index/tu_index sections.  */\n+   have version 1 or 2 or 5 until we parse the cu_index/tu_index sections.  */\n \n static void\n dwarf2_locate_v2_dwp_sections (bfd *abfd, asection *sectp, void *dwp_file_ptr)\n@@ -12630,6 +12946,61 @@ dwarf2_locate_v2_dwp_sections (bfd *abfd, asection *sectp, void *dwp_file_ptr)\n     }\n }\n \n+/* This function is mapped across the sections and remembers the offset and\n+   size of each of the DWP version 5 debugging sections that we are interested\n+   in.  This is split into a separate function because we don't know if we\n+   have version 1 or 2 or 5 until we parse the cu_index/tu_index sections.  */\n+\n+static void\n+dwarf2_locate_v5_dwp_sections (bfd *abfd, asection *sectp, void *dwp_file_ptr)\n+{\n+  struct dwp_file *dwp_file = (struct dwp_file *) dwp_file_ptr;\n+  const struct dwop_section_names *names = &dwop_section_names;\n+  unsigned int elf_section_nr = elf_section_data (sectp)->this_idx;\n+\n+  /* Record the ELF section number for later lookup: this is what the\n+     .debug_cu_index,.debug_tu_index tables use in DWP V1.  */\n+  gdb_assert (elf_section_nr < dwp_file->num_sections);\n+  dwp_file->elf_sections[elf_section_nr] = sectp;\n+\n+  /* Look for specific sections that we need.  */\n+  if (section_is_p (sectp->name, &names->abbrev_dwo))\n+    {\n+      dwp_file->sections.abbrev.s.section = sectp;\n+      dwp_file->sections.abbrev.size = bfd_section_size (sectp);\n+    }\n+  else if (section_is_p (sectp->name, &names->info_dwo))\n+    {\n+      dwp_file->sections.info.s.section = sectp;\n+      dwp_file->sections.info.size = bfd_section_size (sectp);\n+    }\n+  else if (section_is_p (sectp->name, &names->line_dwo))\n+   {\n+     dwp_file->sections.line.s.section = sectp;\n+     dwp_file->sections.line.size = bfd_section_size (sectp);\n+    }\n+  else if (section_is_p (sectp->name, &names->loclists_dwo))\n+    {\n+      dwp_file->sections.loclists.s.section = sectp;\n+      dwp_file->sections.loclists.size = bfd_section_size (sectp);\n+    }\n+  else if (section_is_p (sectp->name, &names->macro_dwo))\n+    {\n+      dwp_file->sections.macro.s.section = sectp;\n+      dwp_file->sections.macro.size = bfd_section_size (sectp);\n+    }\n+  else if (section_is_p (sectp->name, &names->rnglists_dwo))\n+    {\n+      dwp_file->sections.rnglists.s.section = sectp;\n+      dwp_file->sections.rnglists.size = bfd_section_size (sectp);\n+    }\n+  else if (section_is_p (sectp->name, &names->str_offsets_dwo))\n+    {\n+      dwp_file->sections.str_offsets.s.section = sectp;\n+      dwp_file->sections.str_offsets.size = bfd_section_size (sectp);\n+    }\n+}\n+\n /* Hash function for dwp_file loaded CUs/TUs.  */\n \n static hashval_t\n@@ -12784,6 +13155,11 @@ open_and_init_dwp_file (dwarf2_per_objfile *per_objfile)\n     bfd_map_over_sections (dwp_file->dbfd.get (),\n \t\t\t   dwarf2_locate_v2_dwp_sections,\n \t\t\t   dwp_file.get ());\n+  else if (dwp_file->version == 5)\n+    bfd_map_over_sections (dwp_file->dbfd.get (),\n+\t\t\t   dwarf2_locate_v5_dwp_sections,\n+\t\t\t   dwp_file.get ());\n+\n \n   dwp_file->loaded_cus = allocate_dwp_loaded_cutus_table ();\n   dwp_file->loaded_tus = allocate_dwp_loaded_cutus_table ();"
    }
  ]
}