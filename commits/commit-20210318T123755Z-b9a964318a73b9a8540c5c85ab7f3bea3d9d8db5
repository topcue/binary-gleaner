{
  "sha": "b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjlhOTY0MzE4YTczYjlhODU0MGM1Yzg1YWI3ZjNiZWEzZDlkOGRiNQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:37:52Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:37:55Z"
    },
    "message": "libctf: split up ctf_serialize\n\nctf_serialize and its various pieces may be split out into a separate\nfile now, but ctf_serialize is still far too long and disordered, mixing\nheader initialization, sizing of multiple CTF sections, sorting and\nemission of multiple CTF sections, strtab construction and ctf_dict_t\ncopying into a single ugly organically-grown mess.\n\nFix the worst of this by migrating all section sizing and emission into\nseparate functions, two per section (or class of section in the case of\nthe symtypetabs).  Only the variable section is now sized and emitted\ndirectly in ctf_serialize (because it only takes about three lines to do\nso).\n\nThe section sizes themselves are still maintained by ctf_serialize so\nthat it can work out the header offsets, but ctf_symtypetab_sect_sizes\nand ctf_emit_symtypetab_sects share a lot of extra state: migrate that\ninto a shared structure, emit_symtypetab_state_t.\n\n(Test results unchanged.)\n\nlibctf/ChangeLog\n2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-serialize.c: General reshuffling, and...\n\t(emit_symtypetab_state_t): New, migrated from\n\tlocal variables in ctf_serialize.\n\t(ctf_serialize): Split out most section sizing and\n\temission.\n\t(ctf_symtypetab_sect_sizes): New (split out).\n\t(ctf_emit_symtypetab_sects): Likewise.\n\t(ctf_type_sect_size): Likewise.\n\t(ctf_emit_type_sect): Likewise.",
    "tree": {
      "sha": "b43db32ade45f17a1ea5e1713ede83bcf79e657b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b43db32ade45f17a1ea5e1713ede83bcf79e657b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "01cbfcba4bc74fb04904ad395a346549853bd189",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/01cbfcba4bc74fb04904ad395a346549853bd189",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/01cbfcba4bc74fb04904ad395a346549853bd189"
    }
  ],
  "stats": {
    "total": 743,
    "additions": 425,
    "deletions": 318
  },
  "files": [
    {
      "sha": "4e4e9af0686dbd95684dc946fa641dea9cf56508",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5",
      "patch": "@@ -1,3 +1,15 @@\n+2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-serialize.c: General reshuffling, and...\n+\t(emit_symtypetab_state_t): New, migrated from\n+\tlocal variables in ctf_serialize.\n+\t(ctf_serialize): Split out most section sizing and\n+\temission.\n+\t(ctf_symtypetab_sect_sizes): New (split out).\n+\t(ctf_emit_symtypetab_sects): Likewise.\n+\t(ctf_type_sect_size): Likewise.\n+\t(ctf_emit_type_sect): Likewise.\n+\n 2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.h (ctf_dict_t): Fix comment."
    },
    {
      "sha": "1e2c98b473a00a98ab9dd16ac2ac65cd58d7c585",
      "filename": "libctf/ctf-serialize.c",
      "status": "modified",
      "additions": 413,
      "deletions": 318,
      "changes": 731,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5/libctf/ctf-serialize.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5/libctf/ctf-serialize.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-serialize.c?ref=b9a964318a73b9a8540c5c85ab7f3bea3d9d8db5",
      "patch": "@@ -26,29 +26,39 @@\n #include <elf.h>\n #include \"elf-bfd.h\"\n \n-/* Delete data symbols that have been assigned names from the variable section.\n-   Must be called from within ctf_serialize, because that is the only place\n-   you can safely delete variables without messing up ctf_rollback.  */\n+/* Symtypetab sections.  */\n \n-static int\n-symtypetab_delete_nonstatic_vars (ctf_dict_t *fp, ctf_dict_t *symfp)\n+/* Symtypetab emission flags.  */\n+\n+#define CTF_SYMTYPETAB_EMIT_FUNCTION 0x1\n+#define CTF_SYMTYPETAB_EMIT_PAD 0x2\n+#define CTF_SYMTYPETAB_FORCE_INDEXED 0x4\n+\n+/* Properties of symtypetab emission, shared by symtypetab section\n+   sizing and symtypetab emission itself.  */\n+\n+typedef struct emit_symtypetab_state\n {\n-  ctf_dvdef_t *dvd, *nvd;\n-  ctf_id_t type;\n+  /* True if linker-reported symbols are being filtered out.  symfp is set if\n+     this is true: otherwise, indexing is forced and the symflags indicate as\n+     much. */\n+  int filter_syms;\n \n-  for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL; dvd = nvd)\n-    {\n-      nvd = ctf_list_next (dvd);\n+  /* True if symbols are being sorted.  */\n+  int sort_syms;\n \n-      if (((type = (ctf_id_t) (uintptr_t)\n-\t    ctf_dynhash_lookup (fp->ctf_objthash, dvd->dvd_name)) > 0)\n-\t  && ctf_dynhash_lookup (symfp->ctf_dynsyms, dvd->dvd_name) != NULL\n-\t  && type == dvd->dvd_type)\n-\tctf_dvd_delete (fp, dvd);\n-    }\n+  /* Flags for symtypetab emission.  */\n+  int symflags;\n \n-  return 0;\n-}\n+  /* The dict to which the linker has reported symbols.  */\n+  ctf_dict_t *symfp;\n+\n+  /* The maximum number of objects seen.  */\n+  size_t maxobjt;\n+\n+  /* The maximum number of func info entris seen.  */\n+  size_t maxfunc;\n+} emit_symtypetab_state_t;\n \n /* Determine if a symbol is \"skippable\" and should never appear in the\n    symtypetab sections.  */\n@@ -68,12 +78,6 @@ ctf_symtab_skippable (ctf_link_sym_t *sym)\n \t      && sym->st_value == 0));\n }\n \n-/* Symtypetab emission flags.  */\n-\n-#define CTF_SYMTYPETAB_EMIT_FUNCTION 0x1\n-#define CTF_SYMTYPETAB_EMIT_PAD 0x2\n-#define CTF_SYMTYPETAB_FORCE_INDEXED 0x4\n-\n /* Get the number of symbols in a symbol hash, the count of symbols, the maximum\n    seen, the eventual size, without any padding elements, of the func/data and\n    (if generated) index sections, and the size of accumulated padding elements.\n@@ -427,140 +431,40 @@ emit_symtypetab_index (ctf_dict_t *fp, ctf_dict_t *symfp, uint32_t *dp,\n   return 0;\n }\n \n-static unsigned char *\n-ctf_copy_smembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n-{\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  ctf_member_t ctm;\n-\n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n-    {\n-      ctf_member_t *copied;\n-\n-      ctm.ctm_name = 0;\n-      ctm.ctm_type = (uint32_t) dmd->dmd_type;\n-      ctm.ctm_offset = (uint32_t) dmd->dmd_offset;\n-\n-      memcpy (t, &ctm, sizeof (ctm));\n-      copied = (ctf_member_t *) t;\n-      if (dmd->dmd_name)\n-\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctm_name);\n-\n-      t += sizeof (ctm);\n-    }\n-\n-  return t;\n-}\n-\n-static unsigned char *\n-ctf_copy_lmembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n-{\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  ctf_lmember_t ctlm;\n-\n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n-    {\n-      ctf_lmember_t *copied;\n-\n-      ctlm.ctlm_name = 0;\n-      ctlm.ctlm_type = (uint32_t) dmd->dmd_type;\n-      ctlm.ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (dmd->dmd_offset);\n-      ctlm.ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (dmd->dmd_offset);\n-\n-      memcpy (t, &ctlm, sizeof (ctlm));\n-      copied = (ctf_lmember_t *) t;\n-      if (dmd->dmd_name)\n-\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctlm_name);\n-\n-      t += sizeof (ctlm);\n-    }\n-\n-  return t;\n-}\n+/* Delete data symbols that have been assigned names from the variable section.\n+   Must be called from within ctf_serialize, because that is the only place\n+   you can safely delete variables without messing up ctf_rollback.  */\n \n-static unsigned char *\n-ctf_copy_emembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+static int\n+symtypetab_delete_nonstatic_vars (ctf_dict_t *fp, ctf_dict_t *symfp)\n {\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  ctf_enum_t cte;\n+  ctf_dvdef_t *dvd, *nvd;\n+  ctf_id_t type;\n \n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+  for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL; dvd = nvd)\n     {\n-      ctf_enum_t *copied;\n+      nvd = ctf_list_next (dvd);\n \n-      cte.cte_value = dmd->dmd_value;\n-      memcpy (t, &cte, sizeof (cte));\n-      copied = (ctf_enum_t *) t;\n-      ctf_str_add_ref (fp, dmd->dmd_name, &copied->cte_name);\n-      t += sizeof (cte);\n+      if (((type = (ctf_id_t) (uintptr_t)\n+\t    ctf_dynhash_lookup (fp->ctf_objthash, dvd->dvd_name)) > 0)\n+\t  && ctf_dynhash_lookup (symfp->ctf_dynsyms, dvd->dvd_name) != NULL\n+\t  && type == dvd->dvd_type)\n+\tctf_dvd_delete (fp, dvd);\n     }\n \n-  return t;\n+  return 0;\n }\n \n-/* Sort a newly-constructed static variable array.  */\n-\n-typedef struct ctf_sort_var_arg_cb\n-{\n-  ctf_dict_t *fp;\n-  ctf_strs_t *strtab;\n-} ctf_sort_var_arg_cb_t;\n-\n+/* Figure out the sizes of the symtypetab sections, their indexed state,\n+   etc.  */\n static int\n-ctf_sort_var (const void *one_, const void *two_, void *arg_)\n-{\n-  const ctf_varent_t *one = one_;\n-  const ctf_varent_t *two = two_;\n-  ctf_sort_var_arg_cb_t *arg = arg_;\n-\n-  return (strcmp (ctf_strraw_explicit (arg->fp, one->ctv_name, arg->strtab),\n-\t\t  ctf_strraw_explicit (arg->fp, two->ctv_name, arg->strtab)));\n-}\n-\n-/* If the specified CTF dict is writable and has been modified, reload this dict\n-   with the updated type definitions, ready for serialization.  In order to make\n-   this code and the rest of libctf as simple as possible, we perform updates by\n-   taking the dynamic type definitions and creating an in-memory CTF dict\n-   containing the definitions, and then call ctf_simple_open_internal() on it.\n-   We perform one extra trick here for the benefit of callers and to keep our\n-   code simple: ctf_simple_open_internal() will return a new ctf_dict_t, but we\n-   want to keep the fp constant for the caller, so after\n-   ctf_simple_open_internal() returns, we use memcpy to swap the interior of the\n-   old and new ctf_dict_t's, and then free the old.  */\n-int\n-ctf_serialize (ctf_dict_t *fp)\n+ctf_symtypetab_sect_sizes (ctf_dict_t *fp, emit_symtypetab_state_t *s,\n+\t\t\t   ctf_header_t *hdr, size_t *objt_size,\n+\t\t\t   size_t *func_size, size_t *objtidx_size,\n+\t\t\t   size_t *funcidx_size)\n {\n-  ctf_dict_t ofp, *nfp;\n-  ctf_header_t hdr, *hdrp;\n-  ctf_dtdef_t *dtd;\n-  ctf_dvdef_t *dvd;\n-  ctf_varent_t *dvarents;\n-  ctf_strs_writable_t strtab;\n-\n-  unsigned char *t;\n-  unsigned long i;\n-  size_t buf_size, type_size, objt_size, func_size;\n+  size_t nfuncs, nobjts;\n   size_t objt_unpadsize, func_unpadsize, objt_padsize, func_padsize;\n-  size_t funcidx_size, objtidx_size;\n-  size_t nvars, nfuncs, nobjts, maxobjt, maxfunc;\n-  size_t nsymtypes = 0;\n-  const char **sym_name_order = NULL;\n-  unsigned char *buf = NULL, *newbuf;\n-  int err;\n-\n-  /* Symtab filtering. If filter_syms is true, symfp is set: otherwise,\n-     CTF_SYMTYPETAB_FORCE_INDEXED is set in symflags.  */\n-  int filter_syms = 0;\n-  int sort_syms = 1;\n-  int symflags = 0;\n-  ctf_dict_t *symfp = NULL;\n-\n-  if (!(fp->ctf_flags & LCTF_RDWR))\n-    return (ctf_set_errno (fp, ECTF_RDONLY));\n-\n-  /* Update required?  */\n-  if (!(fp->ctf_flags & LCTF_DIRTY))\n-    return 0;\n \n   /* If doing a writeout as part of linking, and the link flags request it,\n      filter out reported symbols from the variable section, and filter out all\n@@ -571,124 +475,59 @@ ctf_serialize (ctf_dict_t *fp)\n      doesn't care what order the symtypetab entries is in, since it only\n      iterates over symbols and does not use the ctf_lookup_by_symbol* API.)  */\n \n+  s->sort_syms = 1;\n   if (fp->ctf_flags & LCTF_LINKING)\n     {\n-      filter_syms = !(fp->ctf_link_flags & CTF_LINK_NO_FILTER_REPORTED_SYMS);\n-      if (!filter_syms)\n-\tsort_syms = 0;\n-    }\n-\n-  /* Fill in an initial CTF header.  We will leave the label, object,\n-     and function sections empty and only output a header, type section,\n-     and string table.  The type section begins at a 4-byte aligned\n-     boundary past the CTF header itself (at relative offset zero).  The flag\n-     indicating a new-style function info section (an array of CTF_K_FUNCTION\n-     type IDs in the types section) is flipped on.  */\n-\n-  memset (&hdr, 0, sizeof (hdr));\n-  hdr.cth_magic = CTF_MAGIC;\n-  hdr.cth_version = CTF_VERSION;\n-\n-  /* This is a new-format func info section, and the symtab and strtab come out\n-     of the dynsym and dynstr these days.  */\n-  hdr.cth_flags = (CTF_F_NEWFUNCINFO | CTF_F_DYNSTR);\n-\n-  /* Iterate through the dynamic type definition list and compute the\n-     size of the CTF type section we will need to generate.  */\n-\n-  for (type_size = 0, dtd = ctf_list_next (&fp->ctf_dtdefs);\n-       dtd != NULL; dtd = ctf_list_next (dtd))\n-    {\n-      uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n-      uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n-\n-      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n-\ttype_size += sizeof (ctf_stype_t);\n-      else\n-\ttype_size += sizeof (ctf_type_t);\n-\n-      switch (kind)\n-\t{\n-\tcase CTF_K_INTEGER:\n-\tcase CTF_K_FLOAT:\n-\t  type_size += sizeof (uint32_t);\n-\t  break;\n-\tcase CTF_K_ARRAY:\n-\t  type_size += sizeof (ctf_array_t);\n-\t  break;\n-\tcase CTF_K_SLICE:\n-\t  type_size += sizeof (ctf_slice_t);\n-\t  break;\n-\tcase CTF_K_FUNCTION:\n-\t  type_size += sizeof (uint32_t) * (vlen + (vlen & 1));\n-\t  break;\n-\tcase CTF_K_STRUCT:\n-\tcase CTF_K_UNION:\n-\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n-\t    type_size += sizeof (ctf_member_t) * vlen;\n-\t  else\n-\t    type_size += sizeof (ctf_lmember_t) * vlen;\n-\t  break;\n-\tcase CTF_K_ENUM:\n-\t  type_size += sizeof (ctf_enum_t) * vlen;\n-\t  break;\n-\t}\n+      s->filter_syms = !(fp->ctf_link_flags & CTF_LINK_NO_FILTER_REPORTED_SYMS);\n+      if (!s->filter_syms)\n+\ts->sort_syms = 0;\n     }\n \n   /* Find the dict to which the linker has reported symbols, if any.  */\n \n-  if (filter_syms)\n+  if (s->filter_syms)\n     {\n       if (!fp->ctf_dynsyms && fp->ctf_parent && fp->ctf_parent->ctf_dynsyms)\n-\tsymfp = fp->ctf_parent;\n+\ts->symfp = fp->ctf_parent;\n       else\n-\tsymfp = fp;\n+\ts->symfp = fp;\n     }\n \n   /* If not filtering, keep all potential symbols in an unsorted, indexed\n      dict.  */\n-  if (!filter_syms)\n-    symflags = CTF_SYMTYPETAB_FORCE_INDEXED;\n+  if (!s->filter_syms)\n+    s->symflags = CTF_SYMTYPETAB_FORCE_INDEXED;\n   else\n-    hdr.cth_flags |= CTF_F_IDXSORTED;\n+    hdr->cth_flags |= CTF_F_IDXSORTED;\n \n-  if (!ctf_assert (fp, (filter_syms && symfp)\n-\t\t   || (!filter_syms && !symfp\n-\t\t       && ((symflags & CTF_SYMTYPETAB_FORCE_INDEXED) != 0))))\n+  if (!ctf_assert (fp, (s->filter_syms && s->symfp)\n+\t\t   || (!s->filter_syms && !s->symfp\n+\t\t       && ((s->symflags & CTF_SYMTYPETAB_FORCE_INDEXED) != 0))))\n     return -1;\n \n   /* Work out the sizes of the object and function sections, and work out the\n      number of pad (unassigned) symbols in each, and the overall size of the\n      sections.  */\n \n-  if (symtypetab_density (fp, symfp, fp->ctf_objthash, &nobjts, &maxobjt,\n-\t\t\t  &objt_unpadsize, &objt_padsize, &objtidx_size,\n-\t\t\t  symflags) < 0)\n+  if (symtypetab_density (fp, s->symfp, fp->ctf_objthash, &nobjts, &s->maxobjt,\n+\t\t\t  &objt_unpadsize, &objt_padsize, objtidx_size,\n+\t\t\t  s->symflags) < 0)\n     return -1;\t\t\t\t\t/* errno is set for us.  */\n \n   ctf_dprintf (\"Object symtypetab: %i objects, max %i, unpadded size %i, \"\n-\t       \"%i bytes of pads, index size %i\\n\", (int) nobjts, (int) maxobjt,\n-\t       (int) objt_unpadsize, (int) objt_padsize, (int) objtidx_size);\n+\t       \"%i bytes of pads, index size %i\\n\", (int) nobjts,\n+\t       (int) s->maxobjt, (int) objt_unpadsize, (int) objt_padsize,\n+\t       (int) *objtidx_size);\n \n-  if (symtypetab_density (fp, symfp, fp->ctf_funchash, &nfuncs, &maxfunc,\n-\t\t\t  &func_unpadsize, &func_padsize, &funcidx_size,\n-\t\t\t  symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+  if (symtypetab_density (fp, s->symfp, fp->ctf_funchash, &nfuncs, &s->maxfunc,\n+\t\t\t  &func_unpadsize, &func_padsize, funcidx_size,\n+\t\t\t  s->symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n     return -1;\t\t\t\t\t/* errno is set for us.  */\n \n   ctf_dprintf (\"Function symtypetab: %i functions, max %i, unpadded size %i, \"\n-\t       \"%i bytes of pads, index size %i\\n\", (int) nfuncs, (int) maxfunc,\n-\t       (int) func_unpadsize, (int) func_padsize, (int) funcidx_size);\n-\n-  /* If we are filtering symbols out, those symbols that the linker has not\n-     reported have now been removed from the ctf_objthash and ctf_funchash.\n-     Delete entries from the variable section that duplicate newly-added data\n-     symbols.  There's no need to migrate new ones in, because the compiler\n-     always emits both a variable and a data symbol simultaneously, and\n-     filtering only happens at final link time.  */\n-\n-  if (filter_syms && symfp->ctf_dynsyms &&\n-      symtypetab_delete_nonstatic_vars (fp, symfp) < 0)\n-    return -1;\n+\t       \"%i bytes of pads, index size %i\\n\", (int) nfuncs,\n+\t       (int) s->maxfunc, (int) func_unpadsize, (int) func_padsize,\n+\t       (int) *funcidx_size);\n \n   /* It is worth indexing each section if it would save space to do so, due to\n      reducing the number of pads sufficiently.  A pad is the same size as a\n@@ -701,69 +540,61 @@ ctf_serialize (ctf_dict_t *fp)\n      but just an ld -r), we must emit things in indexed fashion just as the\n      compiler does.  */\n \n-  objt_size = objt_unpadsize;\n-  if (!(symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n+  *objt_size = objt_unpadsize;\n+  if (!(s->symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n       && ((objt_padsize + objt_unpadsize) * CTF_INDEX_PAD_THRESHOLD\n \t  > objt_padsize))\n     {\n-      objt_size += objt_padsize;\n-      objtidx_size = 0;\n+      *objt_size += objt_padsize;\n+      *objtidx_size = 0;\n     }\n \n-  func_size = func_unpadsize;\n-  if (!(symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n+  *func_size = func_unpadsize;\n+  if (!(s->symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n       && ((func_padsize + func_unpadsize) * CTF_INDEX_PAD_THRESHOLD\n \t  > func_padsize))\n     {\n-      func_size += func_padsize;\n-      funcidx_size = 0;\n+      *func_size += func_padsize;\n+      *funcidx_size = 0;\n     }\n \n-  /* Computing the number of entries in the CTF variable section is much\n-     simpler.  */\n+  /* If we are filtering symbols out, those symbols that the linker has not\n+     reported have now been removed from the ctf_objthash and ctf_funchash.\n+     Delete entries from the variable section that duplicate newly-added data\n+     symbols.  There's no need to migrate new ones in, because the compiler\n+     always emits both a variable and a data symbol simultaneously, and\n+     filtering only happens at final link time.  */\n \n-  for (nvars = 0, dvd = ctf_list_next (&fp->ctf_dvdefs);\n-       dvd != NULL; dvd = ctf_list_next (dvd), nvars++);\n+  if (s->filter_syms && s->symfp->ctf_dynsyms &&\n+      symtypetab_delete_nonstatic_vars (fp, s->symfp) < 0)\n+    return -1;\n \n-  /* Compute the size of the CTF buffer we need, sans only the string table,\n-     then allocate a new buffer and memcpy the finished header to the start of\n-     the buffer.  (We will adjust this later with strtab length info.)  */\n+  return 0;\n+}\n \n-  hdr.cth_lbloff = hdr.cth_objtoff = 0;\n-  hdr.cth_funcoff = hdr.cth_objtoff + objt_size;\n-  hdr.cth_objtidxoff = hdr.cth_funcoff + func_size;\n-  hdr.cth_funcidxoff = hdr.cth_objtidxoff + objtidx_size;\n-  hdr.cth_varoff = hdr.cth_funcidxoff + funcidx_size;\n-  hdr.cth_typeoff = hdr.cth_varoff + (nvars * sizeof (ctf_varent_t));\n-  hdr.cth_stroff = hdr.cth_typeoff + type_size;\n-  hdr.cth_strlen = 0;\n+static int\n+ctf_emit_symtypetab_sects (ctf_dict_t *fp, emit_symtypetab_state_t *s,\n+\t\t\t   unsigned char **tptr, size_t objt_size,\n+\t\t\t   size_t func_size, size_t objtidx_size,\n+\t\t\t   size_t funcidx_size)\n+{\n+  unsigned char *t = *tptr;\n+  size_t nsymtypes = 0;\n+  const char **sym_name_order = NULL;\n+  int err;\n \n-  buf_size = sizeof (ctf_header_t) + hdr.cth_stroff + hdr.cth_strlen;\n-\n-  if ((buf = malloc (buf_size)) == NULL)\n-    return (ctf_set_errno (fp, EAGAIN));\n-\n-  memcpy (buf, &hdr, sizeof (ctf_header_t));\n-  t = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_objtoff;\n-\n-  hdrp = (ctf_header_t *) buf;\n-  if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parname != NULL))\n-    ctf_str_add_ref (fp, fp->ctf_parname, &hdrp->cth_parname);\n-  if (fp->ctf_cuname != NULL)\n-    ctf_str_add_ref (fp, fp->ctf_cuname, &hdrp->cth_cuname);\n-\n-  /* Sort the linker's symbols into name order if need be.  */\n+  /* Sort the linker's symbols into name order if need be.  */\n \n   if ((objtidx_size != 0) || (funcidx_size != 0))\n     {\n       ctf_next_t *i = NULL;\n       void *symname;\n       const char **walk;\n \n-      if (filter_syms)\n+      if (s->filter_syms)\n \t{\n-\t  if (symfp->ctf_dynsyms)\n-\t    nsymtypes = ctf_dynhash_elements (symfp->ctf_dynsyms);\n+\t  if (s->symfp->ctf_dynsyms)\n+\t    nsymtypes = ctf_dynhash_elements (s->symfp->ctf_dynsyms);\n \t  else\n \t    nsymtypes = 0;\n \t}\n@@ -776,11 +607,11 @@ ctf_serialize (ctf_dict_t *fp)\n \n       walk = sym_name_order;\n \n-      if (filter_syms)\n+      if (s->filter_syms)\n \t{\n-\t  if (symfp->ctf_dynsyms)\n+\t  if (s->symfp->ctf_dynsyms)\n \t    {\n-\t      while ((err = ctf_dynhash_next_sorted (symfp->ctf_dynsyms, &i,\n+\t      while ((err = ctf_dynhash_next_sorted (s->symfp->ctf_dynsyms, &i,\n \t\t\t\t\t\t     &symname, NULL,\n \t\t\t\t\t\t     ctf_dynhash_sort_by_name,\n \t\t\t\t\t\t     NULL)) == 0)\n@@ -795,7 +626,7 @@ ctf_serialize (ctf_dict_t *fp)\n \n \t  /* Since we partition the set of symbols back into objt and func,\n \t     we can sort the two independently without harm.  */\n-\t  if (sort_syms)\n+\t  if (s->sort_syms)\n \t    sort_fun = ctf_dynhash_sort_by_name;\n \n \t  while ((err = ctf_dynhash_next_sorted (fp->ctf_objthash, &i, &symname,\n@@ -816,82 +647,209 @@ ctf_serialize (ctf_dict_t *fp)\n      Emission is done in symtab order if there is no index, and in index\n      (name) order otherwise.  */\n \n-  if ((objtidx_size == 0) && symfp && symfp->ctf_dynsymidx)\n+  if ((objtidx_size == 0) && s->symfp && s->symfp->ctf_dynsymidx)\n     {\n       ctf_dprintf (\"Emitting unindexed objt symtypetab\\n\");\n-      if (emit_symtypetab (fp, symfp, (uint32_t *) t, symfp->ctf_dynsymidx,\n-\t\t\t   NULL, symfp->ctf_dynsymmax + 1, maxobjt, objt_size,\n-\t\t\t   symflags | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n+      if (emit_symtypetab (fp, s->symfp, (uint32_t *) t,\n+\t\t\t   s->symfp->ctf_dynsymidx, NULL,\n+\t\t\t   s->symfp->ctf_dynsymmax + 1, s->maxobjt,\n+\t\t\t   objt_size, s->symflags | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n \tgoto err;\t\t\t\t/* errno is set for us.  */\n     }\n   else\n     {\n       ctf_dprintf (\"Emitting indexed objt symtypetab\\n\");\n-      if (emit_symtypetab (fp, symfp, (uint32_t *) t, NULL, sym_name_order,\n-\t\t\t   nsymtypes, maxobjt, objt_size, symflags) < 0)\n+      if (emit_symtypetab (fp, s->symfp, (uint32_t *) t, NULL,\n+\t\t\t   sym_name_order, nsymtypes, s->maxobjt,\n+\t\t\t   objt_size, s->symflags) < 0)\n \tgoto err;\t\t\t\t/* errno is set for us.  */\n     }\n \n   t += objt_size;\n \n-  if ((funcidx_size == 0) && symfp && symfp->ctf_dynsymidx)\n+  if ((funcidx_size == 0) && s->symfp && s->symfp->ctf_dynsymidx)\n     {\n       ctf_dprintf (\"Emitting unindexed func symtypetab\\n\");\n-      if (emit_symtypetab (fp, symfp, (uint32_t *) t, symfp->ctf_dynsymidx,\n-\t\t\t   NULL, symfp->ctf_dynsymmax + 1, maxfunc,\n-\t\t\t   func_size, symflags | CTF_SYMTYPETAB_EMIT_FUNCTION\n+      if (emit_symtypetab (fp, s->symfp, (uint32_t *) t,\n+\t\t\t   s->symfp->ctf_dynsymidx, NULL,\n+\t\t\t   s->symfp->ctf_dynsymmax + 1, s->maxfunc,\n+\t\t\t   func_size, s->symflags | CTF_SYMTYPETAB_EMIT_FUNCTION\n \t\t\t   | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n \tgoto err;\t\t\t\t/* errno is set for us.  */\n     }\n   else\n     {\n       ctf_dprintf (\"Emitting indexed func symtypetab\\n\");\n-      if (emit_symtypetab (fp, symfp, (uint32_t *) t, NULL, sym_name_order,\n-\t\t\t   nsymtypes, maxfunc, func_size,\n-\t\t\t   symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+      if (emit_symtypetab (fp, s->symfp, (uint32_t *) t, NULL, sym_name_order,\n+\t\t\t   nsymtypes, s->maxfunc, func_size,\n+\t\t\t   s->symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n \tgoto err;\t\t\t\t/* errno is set for us.  */\n     }\n \n   t += func_size;\n \n   if (objtidx_size > 0)\n-    if (emit_symtypetab_index (fp, symfp, (uint32_t *) t, sym_name_order,\n-\t\t\t       nsymtypes, objtidx_size, symflags) < 0)\n+    if (emit_symtypetab_index (fp, s->symfp, (uint32_t *) t, sym_name_order,\n+\t\t\t       nsymtypes, objtidx_size, s->symflags) < 0)\n       goto err;\n \n   t += objtidx_size;\n \n   if (funcidx_size > 0)\n-    if (emit_symtypetab_index (fp, symfp, (uint32_t *) t, sym_name_order,\n+    if (emit_symtypetab_index (fp, s->symfp, (uint32_t *) t, sym_name_order,\n \t\t\t       nsymtypes, funcidx_size,\n-\t\t\t       symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+\t\t\t       s->symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n       goto err;\n \n   t += funcidx_size;\n   free (sym_name_order);\n-  sym_name_order = NULL;\n+  *tptr = t;\n \n-  /* Work over the variable list, translating everything into ctf_varent_t's and\n-     prepping the string table.  */\n+  return 0;\n \n-  dvarents = (ctf_varent_t *) t;\n-  for (i = 0, dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL;\n-       dvd = ctf_list_next (dvd), i++)\n+ oom:\n+  ctf_set_errno (fp, EAGAIN);\n+  goto err;\n+symerr:\n+  ctf_err_warn (fp, 0, err, _(\"error serializing symtypetabs\"));\n+ err:\n+  free (sym_name_order);\n+  return -1;\n+}\n+\n+/* Type section.  */\n+\n+static unsigned char *\n+ctf_copy_smembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_member_t ctm;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n     {\n-      ctf_varent_t *var = &dvarents[i];\n+      ctf_member_t *copied;\n \n-      ctf_str_add_ref (fp, dvd->dvd_name, &var->ctv_name);\n-      var->ctv_type = (uint32_t) dvd->dvd_type;\n+      ctm.ctm_name = 0;\n+      ctm.ctm_type = (uint32_t) dmd->dmd_type;\n+      ctm.ctm_offset = (uint32_t) dmd->dmd_offset;\n+\n+      memcpy (t, &ctm, sizeof (ctm));\n+      copied = (ctf_member_t *) t;\n+      if (dmd->dmd_name)\n+\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctm_name);\n+\n+      t += sizeof (ctm);\n     }\n-  assert (i == nvars);\n \n-  t += sizeof (ctf_varent_t) * nvars;\n+  return t;\n+}\n \n-  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_typeoff);\n+static unsigned char *\n+ctf_copy_lmembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_lmember_t ctlm;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      ctf_lmember_t *copied;\n+\n+      ctlm.ctlm_name = 0;\n+      ctlm.ctlm_type = (uint32_t) dmd->dmd_type;\n+      ctlm.ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (dmd->dmd_offset);\n+      ctlm.ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (dmd->dmd_offset);\n+\n+      memcpy (t, &ctlm, sizeof (ctlm));\n+      copied = (ctf_lmember_t *) t;\n+      if (dmd->dmd_name)\n+\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctlm_name);\n+\n+      t += sizeof (ctlm);\n+    }\n+\n+  return t;\n+}\n+\n+static unsigned char *\n+ctf_copy_emembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_enum_t cte;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      ctf_enum_t *copied;\n+\n+      cte.cte_value = dmd->dmd_value;\n+      memcpy (t, &cte, sizeof (cte));\n+      copied = (ctf_enum_t *) t;\n+      ctf_str_add_ref (fp, dmd->dmd_name, &copied->cte_name);\n+      t += sizeof (cte);\n+    }\n+\n+  return t;\n+}\n+\n+/* Iterate through the dynamic type definition list and compute the\n+   size of the CTF type section.  */\n+\n+static size_t\n+ctf_type_sect_size (ctf_dict_t *fp)\n+{\n+  ctf_dtdef_t *dtd;\n+  size_t type_size;\n+\n+  for (type_size = 0, dtd = ctf_list_next (&fp->ctf_dtdefs);\n+       dtd != NULL; dtd = ctf_list_next (dtd))\n+    {\n+      uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+      uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n+\n+      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n+\ttype_size += sizeof (ctf_stype_t);\n+      else\n+\ttype_size += sizeof (ctf_type_t);\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_INTEGER:\n+\tcase CTF_K_FLOAT:\n+\t  type_size += sizeof (uint32_t);\n+\t  break;\n+\tcase CTF_K_ARRAY:\n+\t  type_size += sizeof (ctf_array_t);\n+\t  break;\n+\tcase CTF_K_SLICE:\n+\t  type_size += sizeof (ctf_slice_t);\n+\t  break;\n+\tcase CTF_K_FUNCTION:\n+\t  type_size += sizeof (uint32_t) * (vlen + (vlen & 1));\n+\t  break;\n+\tcase CTF_K_STRUCT:\n+\tcase CTF_K_UNION:\n+\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n+\t    type_size += sizeof (ctf_member_t) * vlen;\n+\t  else\n+\t    type_size += sizeof (ctf_lmember_t) * vlen;\n+\t  break;\n+\tcase CTF_K_ENUM:\n+\t  type_size += sizeof (ctf_enum_t) * vlen;\n+\t  break;\n+\t}\n+    }\n \n-  /* We now take a final lap through the dynamic type definition list and copy\n-     the appropriate type records to the output buffer, noting down the\n-     strings as we go.  */\n+  return type_size;\n+}\n+\n+/* Take a final lap through the dynamic type definition list and copy the\n+   appropriate type records to the output buffer, noting down the strings as\n+   we go.  */\n+\n+static void\n+ctf_emit_type_sect (ctf_dict_t *fp, unsigned char **tptr)\n+{\n+  unsigned char *t = *tptr;\n+  ctf_dtdef_t *dtd;\n \n   for (dtd = ctf_list_next (&fp->ctf_dtdefs);\n        dtd != NULL; dtd = ctf_list_next (dtd))\n@@ -978,6 +936,147 @@ ctf_serialize (ctf_dict_t *fp)\n \t  break;\n \t}\n     }\n+\n+  *tptr = t;\n+}\n+\n+/* Variable section.  */\n+\n+/* Sort a newly-constructed static variable array.  */\n+\n+typedef struct ctf_sort_var_arg_cb\n+{\n+  ctf_dict_t *fp;\n+  ctf_strs_t *strtab;\n+} ctf_sort_var_arg_cb_t;\n+\n+static int\n+ctf_sort_var (const void *one_, const void *two_, void *arg_)\n+{\n+  const ctf_varent_t *one = one_;\n+  const ctf_varent_t *two = two_;\n+  ctf_sort_var_arg_cb_t *arg = arg_;\n+\n+  return (strcmp (ctf_strraw_explicit (arg->fp, one->ctv_name, arg->strtab),\n+\t\t  ctf_strraw_explicit (arg->fp, two->ctv_name, arg->strtab)));\n+}\n+\n+/* Overall serialization.  */\n+\n+/* If the specified CTF dict is writable and has been modified, reload this dict\n+   with the updated type definitions, ready for serialization.  In order to make\n+   this code and the rest of libctf as simple as possible, we perform updates by\n+   taking the dynamic type definitions and creating an in-memory CTF dict\n+   containing the definitions, and then call ctf_simple_open_internal() on it.\n+   We perform one extra trick here for the benefit of callers and to keep our\n+   code simple: ctf_simple_open_internal() will return a new ctf_dict_t, but we\n+   want to keep the fp constant for the caller, so after\n+   ctf_simple_open_internal() returns, we use memcpy to swap the interior of the\n+   old and new ctf_dict_t's, and then free the old.  */\n+int\n+ctf_serialize (ctf_dict_t *fp)\n+{\n+  ctf_dict_t ofp, *nfp;\n+  ctf_header_t hdr, *hdrp;\n+  ctf_dvdef_t *dvd;\n+  ctf_varent_t *dvarents;\n+  ctf_strs_writable_t strtab;\n+  int err;\n+\n+  unsigned char *t;\n+  unsigned long i;\n+  size_t buf_size, type_size, objt_size, func_size;\n+  size_t funcidx_size, objtidx_size;\n+  size_t nvars;\n+  unsigned char *buf = NULL, *newbuf;\n+\n+  emit_symtypetab_state_t symstate;\n+  memset (&symstate, 0, sizeof (emit_symtypetab_state_t));\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  /* Update required?  */\n+  if (!(fp->ctf_flags & LCTF_DIRTY))\n+    return 0;\n+\n+  /* Fill in an initial CTF header.  We will leave the label, object,\n+     and function sections empty and only output a header, type section,\n+     and string table.  The type section begins at a 4-byte aligned\n+     boundary past the CTF header itself (at relative offset zero).  The flag\n+     indicating a new-style function info section (an array of CTF_K_FUNCTION\n+     type IDs in the types section) is flipped on.  */\n+\n+  memset (&hdr, 0, sizeof (hdr));\n+  hdr.cth_magic = CTF_MAGIC;\n+  hdr.cth_version = CTF_VERSION;\n+\n+  /* This is a new-format func info section, and the symtab and strtab come out\n+     of the dynsym and dynstr these days.  */\n+  hdr.cth_flags = (CTF_F_NEWFUNCINFO | CTF_F_DYNSTR);\n+\n+  if (ctf_symtypetab_sect_sizes (fp, &symstate, &hdr, &objt_size, &func_size,\n+\t\t\t\t &objtidx_size, &funcidx_size) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  for (nvars = 0, dvd = ctf_list_next (&fp->ctf_dvdefs);\n+       dvd != NULL; dvd = ctf_list_next (dvd), nvars++);\n+\n+  type_size = ctf_type_sect_size (fp);\n+\n+  /* Compute the size of the CTF buffer we need, sans only the string table,\n+     then allocate a new buffer and memcpy the finished header to the start of\n+     the buffer.  (We will adjust this later with strtab length info.)  */\n+\n+  hdr.cth_lbloff = hdr.cth_objtoff = 0;\n+  hdr.cth_funcoff = hdr.cth_objtoff + objt_size;\n+  hdr.cth_objtidxoff = hdr.cth_funcoff + func_size;\n+  hdr.cth_funcidxoff = hdr.cth_objtidxoff + objtidx_size;\n+  hdr.cth_varoff = hdr.cth_funcidxoff + funcidx_size;\n+  hdr.cth_typeoff = hdr.cth_varoff + (nvars * sizeof (ctf_varent_t));\n+  hdr.cth_stroff = hdr.cth_typeoff + type_size;\n+  hdr.cth_strlen = 0;\n+\n+  buf_size = sizeof (ctf_header_t) + hdr.cth_stroff + hdr.cth_strlen;\n+\n+  if ((buf = malloc (buf_size)) == NULL)\n+    return (ctf_set_errno (fp, EAGAIN));\n+\n+  memcpy (buf, &hdr, sizeof (ctf_header_t));\n+  t = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_objtoff;\n+\n+  hdrp = (ctf_header_t *) buf;\n+  if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parname != NULL))\n+    ctf_str_add_ref (fp, fp->ctf_parname, &hdrp->cth_parname);\n+  if (fp->ctf_cuname != NULL)\n+    ctf_str_add_ref (fp, fp->ctf_cuname, &hdrp->cth_cuname);\n+\n+  if (ctf_emit_symtypetab_sects (fp, &symstate, &t, objt_size, func_size,\n+\t\t\t\t objtidx_size, funcidx_size) < 0)\n+    goto err;\n+\n+  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_varoff);\n+\n+  /* Work over the variable list, translating everything into ctf_varent_t's and\n+     prepping the string table.  */\n+\n+  dvarents = (ctf_varent_t *) t;\n+  for (i = 0, dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL;\n+       dvd = ctf_list_next (dvd), i++)\n+    {\n+      ctf_varent_t *var = &dvarents[i];\n+\n+      ctf_str_add_ref (fp, dvd->dvd_name, &var->ctv_name);\n+      var->ctv_type = (uint32_t) dvd->dvd_type;\n+    }\n+  assert (i == nvars);\n+\n+  t += sizeof (ctf_varent_t) * nvars;\n+\n+  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_typeoff);\n+\n+  ctf_emit_type_sect (fp, &t);\n+\n   assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_stroff);\n \n   /* Construct the final string table and fill out all the string refs with the\n@@ -1125,19 +1224,15 @@ ctf_serialize (ctf_dict_t *fp)\n \n   return 0;\n \n-symerr:\n-  ctf_err_warn (fp, 0, err, _(\"error serializing symtypetabs\"));\n-  goto err;\n oom:\n   free (buf);\n-  free (sym_name_order);\n   return (ctf_set_errno (fp, EAGAIN));\n err:\n   free (buf);\n-  free (sym_name_order);\n   return -1;\t\t\t\t\t/* errno is set for us.  */\n }\n \n+/* File writing.  */\n \n /* Write the compressed CTF data stream to the specified gzFile descriptor.  */\n int"
    }
  ]
}