{
  "sha": "68337b8be308cd309727bbe022ce9ce5d38f426a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjgzMzdiOGJlMzA4Y2QzMDk3MjdiYmUwMjJjZTljZTVkMzhmNDI2YQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-11-13T10:39:23Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-25T10:33:12Z"
    },
    "message": "gdb/fortran: don't access non-existent type fields\n\nWhen attempting to call a Fortran function for which there is no debug\ninformation we currently trigger undefined behaviour in GDB by\naccessing non-existent type fields.\n\nThe reason is that in order to prepare the arguments, for a call to a\nFortran function, we need to know the type of each argument.  If the\nfunction being called has no debug information then obviously GDB\ndoesn't know about the argument types and we should either give the\nuser an error or pick a suitable default.  What we currently do is\njust assume the field exist and access undefined memory, which is\nclearly wrong.\n\nThe reason GDB needs to know the argument type is to tell if the\nargument is artificial or not, artificial arguments will be passed by\nvalue while non-artificial arguments will be passed by reference.\n\nAn ideal solution for this problem would be to allow the user to cast\nthe function to the correct type, we already do this to some degree\nwith the return value, for example:\n\n  (gdb) print some_func_ ()\n  'some_func_' has unknown return type; cast the call to its declared return type\n  (gdb) print (integer) some_func_ ()\n  $1 = 1\n\nBut if we could extend this to allow casting to the full function\ntype, GDB could figure out from the signature what are real\nparameters, and what are artificial parameters.  Maybe something like\nthis:\n\n  (gdb) print ((integer () (integer, double)) some_other_func_ (1, 2.3)\n\nAlas, right now the Fortran expression parser doesn't seem to support\nparsing function signatures, and we certainly don't have support for\nfiguring out real vs artificial arguments from a signature.\n\nStill, I think we can prevent GDB from accessing undefined memory and\nprovide a reasonable default behaviour.\n\nIn this commit I:\n\n  - Only ask if the argument is artificial if the type of the argument\n  is actually known.\n\n  - Unknown arguments are assumed to be artificial and passed by\n  value (non-artificial arguments are pass by reference).\n\n  - If an artificial argument is prefixed with '&' by the user then we\n  treat the argument as pass-by-reference.\n\nWith these three changes we avoid undefined behaviour in GDB, and\nallow the user, in most cases, to get a reasonably natural default\nbehaviour.\n\ngdb/ChangeLog:\n\n\tPR fortran/26155\n\t* f-lang.c (fortran_argument_convert): Delete declaration.\n\t(fortran_prepare_argument): New function.\n\t(evaluate_subexp_f): Move logic to new function\n\tfortran_prepare_argument.\n\ngdb/testsuite/ChangeLog:\n\n\tPR fortran/26155\n\t* gdb.fortran/call-no-debug-func.f90: New file.\n\t* gdb.fortran/call-no-debug-prog.f90: New file.\n\t* gdb.fortran/call-no-debug.exp: New file.",
    "tree": {
      "sha": "fefefff5707c44b4902c881df5a649e7d870c6c1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fefefff5707c44b4902c881df5a649e7d870c6c1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/68337b8be308cd309727bbe022ce9ce5d38f426a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/68337b8be308cd309727bbe022ce9ce5d38f426a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/68337b8be308cd309727bbe022ce9ce5d38f426a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/68337b8be308cd309727bbe022ce9ce5d38f426a/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/faeb9f13c179a4c78bc295a0d0bbd788239704d9"
    }
  ],
  "stats": {
    "total": 261,
    "additions": 243,
    "deletions": 18
  },
  "files": [
    {
      "sha": "a6a842f40eb9da29ae8482dfe0347abf50169cf4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=68337b8be308cd309727bbe022ce9ce5d38f426a",
      "patch": "@@ -1,3 +1,11 @@\n+2021-02-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\tPR fortran/26155\n+\t* f-lang.c (fortran_argument_convert): Delete declaration.\n+\t(fortran_prepare_argument): New function.\n+\t(evaluate_subexp_f): Move logic to new function\n+\tfortran_prepare_argument.\n+\n 2021-02-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* f-exp.y (f77_keywords): Add 'associated'."
    },
    {
      "sha": "01de51837f6ab7b25347b125e4696a52e0052aaf",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 62,
      "deletions": 18,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=68337b8be308cd309727bbe022ce9ce5d38f426a",
      "patch": "@@ -68,8 +68,10 @@ show_fortran_array_slicing_debug (struct ui_file *file, int from_tty,\n \n /* Local functions */\n \n-static struct value *fortran_argument_convert (struct value *value,\n-\t\t\t\t\t       bool is_artificial);\n+static value *fortran_prepare_argument (struct expression *exp, int *pos,\n+\t\t\t\t\tint arg_num, bool is_internal_call_p,\n+\t\t\t\t\tstruct type *func_type,\n+\t\t\t\t\tenum noside noside);\n \n /* Return the encoding that should be used for the character type\n    TYPE.  */\n@@ -1278,22 +1280,11 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \t    int tem = 1;\n \t    for (; tem <= nargs; tem++)\n \t      {\n-\t\targvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);\n-\t\t/* Arguments in Fortran are passed by address.  Coerce the\n-\t\t   arguments here rather than in value_arg_coerce as\n-\t\t   otherwise the call to malloc to place the non-lvalue\n-\t\t   parameters in target memory is hit by this Fortran\n-\t\t   specific logic.  This results in malloc being called\n-\t\t   with a pointer to an integer followed by an attempt to\n-\t\t   malloc the arguments to malloc in target memory.\n-\t\t   Infinite recursion ensues.  */\n-\t\tif (code == TYPE_CODE_PTR || code == TYPE_CODE_FUNC)\n-\t\t  {\n-\t\t    bool is_artificial\n-\t\t      = TYPE_FIELD_ARTIFICIAL (value_type (arg1), tem - 1);\n-\t\t    argvec[tem] = fortran_argument_convert (argvec[tem],\n-\t\t\t\t\t\t\t    is_artificial);\n-\t\t  }\n+\t\tbool is_internal_func = (code == TYPE_CODE_INTERNAL_FUNCTION);\n+\t\targvec[tem]\n+\t\t  = fortran_prepare_argument (exp, pos, (tem - 1),\n+\t\t\t\t\t      is_internal_func,\n+\t\t\t\t\t      value_type (arg1), noside);\n \t      }\n \t    argvec[tem] = 0;\t/* signal end of arglist */\n \t    if (noside == EVAL_SKIP)\n@@ -1780,6 +1771,59 @@ fortran_argument_convert (struct value *value, bool is_artificial)\n     return value;\n }\n \n+/* Prepare (and return) an argument value ready for an inferior function\n+   call to a Fortran function.  EXP and POS are the expressions describing\n+   the argument to prepare.  ARG_NUM is the argument number being\n+   prepared, with 0 being the first argument and so on.  FUNC_TYPE is the\n+   type of the function being called.\n+\n+   IS_INTERNAL_CALL_P is true if this is a call to a function of type\n+   TYPE_CODE_INTERNAL_FUNCTION, otherwise this parameter is false.\n+\n+   NOSIDE has its usual meaning for expression parsing (see eval.c).\n+\n+   Arguments in Fortran are normally passed by address, we coerce the\n+   arguments here rather than in value_arg_coerce as otherwise the call to\n+   malloc (to place the non-lvalue parameters in target memory) is hit by\n+   this Fortran specific logic.  This results in malloc being called with a\n+   pointer to an integer followed by an attempt to malloc the arguments to\n+   malloc in target memory.  Infinite recursion ensues.  */\n+\n+static value *\n+fortran_prepare_argument (struct expression *exp, int *pos,\n+                         int arg_num, bool is_internal_call_p,\n+                         struct type *func_type, enum noside noside)\n+{\n+  if (is_internal_call_p)\n+    return evaluate_subexp_with_coercion (exp, pos, noside);\n+\n+  bool is_artificial = ((arg_num >= func_type->num_fields ())\n+\t\t\t? true\n+\t\t\t: TYPE_FIELD_ARTIFICIAL (func_type, arg_num));\n+\n+  /* If this is an artificial argument, then either, this is an argument\n+     beyond the end of the known arguments, or possibly, there are no known\n+     arguments (maybe missing debug info).\n+\n+     For these artificial arguments, if the user has prefixed it with '&'\n+     (for address-of), then lets always allow this to succeed, even if the\n+     argument is not actually in inferior memory.  This will allow the user\n+     to pass arguments to a Fortran function even when there's no debug\n+     information.\n+\n+     As we already pass the address of non-artificial arguments, all we\n+     need to do if skip the UNOP_ADDR operator in the expression and mark\n+     the argument as non-artificial.  */\n+  if (is_artificial && exp->elts[*pos].opcode == UNOP_ADDR)\n+    {\n+      (*pos)++;\n+      is_artificial = false;\n+    }\n+\n+  struct value *arg_val = evaluate_subexp_with_coercion (exp, pos, noside);\n+  return fortran_argument_convert (arg_val, is_artificial);\n+}\n+\n /* See f-lang.h.  */\n \n struct type *"
    },
    {
      "sha": "bbe4e5cbfebe9bd27d6c7aea353d7be7eb4b288a",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=68337b8be308cd309727bbe022ce9ce5d38f426a",
      "patch": "@@ -1,3 +1,10 @@\n+2021-02-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\tPR fortran/26155\n+\t* gdb.fortran/call-no-debug-func.f90: New file.\n+\t* gdb.fortran/call-no-debug-prog.f90: New file.\n+\t* gdb.fortran/call-no-debug.exp: New file.\n+\n 2021-02-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.fortran/associated.exp: New file."
    },
    {
      "sha": "0075c0797c5b0935caa4f3a8f2551cd615add04f",
      "filename": "gdb/testsuite/gdb.fortran/call-no-debug-func.f90",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/testsuite/gdb.fortran/call-no-debug-func.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/testsuite/gdb.fortran/call-no-debug-func.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/call-no-debug-func.f90?ref=68337b8be308cd309727bbe022ce9ce5d38f426a",
      "patch": "@@ -0,0 +1,29 @@\n+! Copyright 2020-2021 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+! Return ARG plus 1.\n+integer function some_func (arg)\n+  integer :: arg\n+\n+  some_func = (arg + 1)\n+end function some_func\n+\n+! Print STR.\n+integer function string_func (str)\n+  character(len=*) :: str\n+\n+  print *, str\n+  string_func = 0\n+end function string_func"
    },
    {
      "sha": "514c9c8d5641b2d42bbc5baeeb24ee20cc331a89",
      "filename": "gdb/testsuite/gdb.fortran/call-no-debug-prog.f90",
      "status": "added",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/testsuite/gdb.fortran/call-no-debug-prog.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/testsuite/gdb.fortran/call-no-debug-prog.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/call-no-debug-prog.f90?ref=68337b8be308cd309727bbe022ce9ce5d38f426a",
      "patch": "@@ -0,0 +1,35 @@\n+! Copyright 2020-2021 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+program main\n+  implicit none\n+\n+  interface\n+     integer function some_func (arg)\n+       integer :: arg\n+     end function some_func\n+\n+     integer function string_func (str)\n+       character(len=*) :: str\n+     end function string_func\n+  end interface\n+\n+  integer :: val\n+\n+  val = some_func (1)\n+  print *, val\n+  val = string_func ('hello')\n+  print *, val\n+end program main"
    },
    {
      "sha": "82bf32c82c701213218cbf4efd23f00a673da657",
      "filename": "gdb/testsuite/gdb.fortran/call-no-debug.exp",
      "status": "added",
      "additions": 102,
      "deletions": 0,
      "changes": 102,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/testsuite/gdb.fortran/call-no-debug.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68337b8be308cd309727bbe022ce9ce5d38f426a/gdb/testsuite/gdb.fortran/call-no-debug.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/call-no-debug.exp?ref=68337b8be308cd309727bbe022ce9ce5d38f426a",
      "patch": "@@ -0,0 +1,102 @@\n+# Copyright 2020-2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/> .\n+\n+# Test calling Fortran functions that are compiled without debug\n+# information.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+\n+standard_testfile call-no-debug-prog.f90 call-no-debug-func.f90\n+load_lib fortran.exp\n+\n+if {[prepare_for_testing_full \"failed to prepare\" \\\n+\t [list ${binfile} [list debug f90] \\\n+\t      $srcfile [list debug f90] \\\n+\t      $srcfile2 [list nodebug f90]]]} {\n+    return -1\n+}\n+\n+if ![fortran_runto_main] {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+# Find a possibly mangled version of NAME, a function we want to call\n+# that has no debug information available.  We hope that the mangled\n+# version of NAME contains the pattern NAME, and so we use 'info\n+# functions' to find a possible suitable symbol.\n+#\n+# If no suitable function is found then return the empty string.\n+proc find_mangled_name { name } {\n+    global hex gdb_prompt\n+\n+    set into_non_debug_symbols false\n+    set symbol_name \"*unknown*\"\n+    gdb_test_multiple \"info function $name\" \"\" {\n+\t-re \".*Non-debugging symbols:\\r\\n\" {\n+\t    set into_non_debug_symbols true\n+\t    exp_continue\n+\t}\n+\t-re \"$hex.*\\[ \\t\\]+(\\[^\\r\\n\\]+)\\r\\n\" {\n+\t    set symbol_name $expect_out(1,string)\n+\t    exp_continue\n+\t}\n+\t-re \"^$gdb_prompt $\" {\n+\t    # Done.\n+\t}\n+    }\n+\n+    # If we couldn't find a suitable symbol name return the empty\n+    # string.\n+    if { $symbol_name == \"*unknown*\" } {\n+\treturn \"\"\n+    }\n+\n+    return $symbol_name\n+}\n+\n+# Call the function SOME_FUNC, that takes a single integer and returns\n+# an integer.  As the function has no debug information then we have\n+# to pass the integer argument as '&1' so that GDB will send the\n+# address of an integer '1' (as Fortran arguments are pass by\n+# reference).\n+set symbol_name [find_mangled_name \"some_func\"]\n+if { $symbol_name == \"\" } {\n+    untested \"couldn't find suitable name for 'some_func'\"\n+} else {\n+    gdb_test \"ptype ${symbol_name}\" \"type = <unknown return type> \\\\(\\\\)\"\n+    gdb_test \"print ${symbol_name} (&1)\" \\\n+\t\"'${symbol_name}' has unknown return type; cast the call to its declared return type\"\n+    gdb_test \"print (integer) ${symbol_name} (&1)\" \" = 2\"\n+}\n+\n+# Call the function STRING_FUNC which takes an assumed shape character\n+# array (i.e. a string), and returns an integer.\n+#\n+# At least for gfortran, passing the string will pass both the data\n+# pointer and an artificial argument, the length of the string.\n+#\n+# The compiled program is expecting the address of the string, so we\n+# prefix that argument with '&', but the artificial length parameter\n+# is pass by value, so there's no need for '&' in that case.\n+set symbol_name [find_mangled_name \"string_func\"]\n+if { $symbol_name == \"\" } {\n+    untested \"couldn't find suitable name for 'string_func'\"\n+} else {\n+    gdb_test \"ptype ${symbol_name}\" \"type = <unknown return type> \\\\(\\\\)\"\n+    gdb_test \"print ${symbol_name} (&'abcdefg', 3)\" \\\n+\t\"'${symbol_name}' has unknown return type; cast the call to its declared return type\"\n+    gdb_test \"call (integer) ${symbol_name} (&'abcdefg', 3)\" \" abc\\r\\n\\\\\\$\\\\d+ = 0\"\n+}"
    }
  ]
}