{
  "sha": "db082f5979ff95409b7de7a2a96d083f2642c8c3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGIwODJmNTk3OWZmOTU0MDliN2RlN2EyYTk2ZDA4M2YyNjQyYzhjMw==",
  "commit": {
    "author": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2020-06-12T02:20:03Z"
    },
    "committer": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2020-07-22T19:45:29Z"
    },
    "message": "Use NT_FILE note section for reading core target memory\n\nIn his reviews of my v1 and v2 corefile related patches, Pedro\nidentified two cases which weren't handled by those patches.\n\nIn https://sourceware.org/pipermail/gdb-patches/2020-May/168826.html,\nPedro showed that debugging a core file in which mmap() is used to\ncreate a new mapping over an existing file-backed mapping will\nproduce incorrect results.  I.e, for his example, GDB would\nshow:\n\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x00000000004004e6 <+0>:\tpush   %rbp\n   0x00000000004004e7 <+1>:\tmov    %rsp,%rbp\n=> 0x00000000004004ea <+4>:\tcallq  0x4003f0 <abort@plt>\nEnd of assembler dump.\n\nThis sort of looks like it might be correct, but is not due to the\nfact that mmap(...MAP_FIXED...) was used to create a mapping (of all\nzeros) on top of the .text section.  So, the correct result should be:\n\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x00000000004004e6 <+0>:\tadd    %al,(%rax)\n   0x00000000004004e8 <+2>:\tadd    %al,(%rax)\n=> 0x00000000004004ea <+4>:\tadd    %al,(%rax)\n   0x00000000004004ec <+6>:\tadd    %al,(%rax)\n   0x00000000004004ee <+8>:\tadd    %al,(%rax)\nEnd of assembler dump.\n\nThe other case that Pedro found involved an attempted examination of a\nparticular section in the test case from gdb.base/corefile.exp.  On\nFedora 27 or 28, the following behavior may be observed:\n\n(gdb) info proc mappings\nMapped address spaces:\n\n          Start Addr           End Addr       Size     Offset objfile\n...\n      0x7ffff7839000     0x7ffff7a38000   0x1ff000   0x1b5000 /usr/lib64/libc-2.27.so\n...\n(gdb) x/4x 0x7ffff7839000\n0x7ffff7839000:\tCannot access memory at address 0x7ffff7839000\n\nFYI, this section appears to be unrelocated vtable data.  See\nhttps://sourceware.org/pipermail/gdb-patches/2020-May/168331.html for\na detailed analysis.\n\nThe important thing here is that GDB should be able to access this\naddress since it should be backed by the shared library.  I.e. it\nshould do this:\n\n(gdb) x/4x 0x7ffff7839000\n0x7ffff7839000:\t0x0007ddf0\t0x00000000\t0x0007dba0\t0x00000000\n\nBoth of these cases are fixed with this commit.\n\nIn a nutshell, this commit opens a \"binary\" target BFD for each of the\nfiles that are mentioned in an NT_FILE / .note.linuxcore.file note\nsection.  It then uses these mappings instead of the file stratum\nmappings that GDB has used in the past.\n\nIf this note section doesn't exist or is mangled for some reason, then\nGDB will use the file stratum as before.  Should this happen, then\nwe can expect both of the above problems to again be present.\n\nSee the code comments in the commit for other details.\n\ngdb/ChangeLog:\n\n\t* corelow.c (solist.h, unordered_map): Include.\n\t(class core_target): Add field m_core_file_mappings and\n\tmethod build_file_mappings.\n\t(core_target::core_target): Call build_file_mappings.\n\t(core_target::~core_target): Free memory associated with\n\tm_core_file_mappings.\n\t(core_target::build_file_mappings): New method.\n\t(core_target::xfer_partial): Use m_core_file_mappings\n\tfor memory transfers.\n\t* linux-tdep.c (linux_read_core_file_mappings): New\n\tfunction.\n\t(linux_core_info_proc_mappings): Rewrite to use\n\tlinux_read_core_file_mappings.\n\t(linux_init_abi): Register linux_read_core_file_mappings.",
    "tree": {
      "sha": "83e9b070f4550bd9102d5b5f6c2f104d1c74c02e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/83e9b070f4550bd9102d5b5f6c2f104d1c74c02e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/db082f5979ff95409b7de7a2a96d083f2642c8c3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/db082f5979ff95409b7de7a2a96d083f2642c8c3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/db082f5979ff95409b7de7a2a96d083f2642c8c3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/db082f5979ff95409b7de7a2a96d083f2642c8c3/comments",
  "author": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7e183d273682fe94c6b9777ae2f3d981f415b8cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7e183d273682fe94c6b9777ae2f3d981f415b8cd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7e183d273682fe94c6b9777ae2f3d981f415b8cd"
    }
  ],
  "stats": {
    "total": 357,
    "additions": 286,
    "deletions": 71
  },
  "files": [
    {
      "sha": "e773891c764dcb80f2d3908eee63f4e639532bb7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/db082f5979ff95409b7de7a2a96d083f2642c8c3/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/db082f5979ff95409b7de7a2a96d083f2642c8c3/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=db082f5979ff95409b7de7a2a96d083f2642c8c3",
      "patch": "@@ -1,3 +1,20 @@\n+2020-07-22  Kevin Buettner  <kevinb@redhat.com>\n+\n+\t* corelow.c (solist.h, unordered_map): Include.\n+\t(class core_target): Add field m_core_file_mappings and\n+\tmethod build_file_mappings.\n+\t(core_target::core_target): Call build_file_mappings.\n+\t(core_target::~core_target): Free memory associated with\n+\tm_core_file_mappings.\n+\t(core_target::build_file_mappings): New method.\n+\t(core_target::xfer_partial): Use m_core_file_mappings\n+\tfor memory transfers.\n+\t* linux-tdep.c (linux_read_core_file_mappings): New\n+\tfunction.\n+\t(linux_core_info_proc_mappings): Rewrite to use\n+\tlinux_read_core_file_mappings.\n+\t(linux_init_abi): Register linux_read_core_file_mappings.\n+\n 2020-07-22  Kevin Buettner  <kevinb@redhat.com>\n \n \t* arch-utils.c (default_read_core_file_mappings): New function."
    },
    {
      "sha": "64a7613f2959b5dd184da0e44b6a134119e495fb",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 133,
      "deletions": 4,
      "changes": 137,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/db082f5979ff95409b7de7a2a96d083f2642c8c3/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/db082f5979ff95409b7de7a2a96d083f2642c8c3/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=db082f5979ff95409b7de7a2a96d083f2642c8c3",
      "patch": "@@ -37,6 +37,7 @@\n #include \"exec.h\"\n #include \"readline/tilde.h\"\n #include \"solib.h\"\n+#include \"solist.h\"\n #include \"filenames.h\"\n #include \"progspace.h\"\n #include \"objfiles.h\"\n@@ -45,6 +46,7 @@\n #include \"gdbsupport/filestuff.h\"\n #include \"build-id.h\"\n #include \"gdbsupport/pathstuff.h\"\n+#include <unordered_map>\n \n #ifndef O_LARGEFILE\n #define O_LARGEFILE 0\n@@ -121,6 +123,13 @@ class core_target final : public process_stratum_target\n      targets.  */\n   target_section_table m_core_section_table {};\n \n+  /* File-backed address space mappings: some core files include\n+     information about memory mapped files.  */\n+  target_section_table m_core_file_mappings {};\n+\n+  /* Build m_core_file_mappings.  Called from the constructor.  */\n+  void build_file_mappings ();\n+\n   /* FIXME: kettenis/20031023: Eventually this field should\n      disappear.  */\n   struct gdbarch *m_core_gdbarch = NULL;\n@@ -141,11 +150,120 @@ core_target::core_target ()\n \t\t\t   &m_core_section_table.sections_end))\n     error (_(\"\\\"%s\\\": Can't find sections: %s\"),\n \t   bfd_get_filename (core_bfd), bfd_errmsg (bfd_get_error ()));\n+\n+  build_file_mappings ();\n }\n \n core_target::~core_target ()\n {\n   xfree (m_core_section_table.sections);\n+  xfree (m_core_file_mappings.sections);\n+}\n+\n+/* Construct the target_section_table for file-backed mappings if\n+   they exist.\n+\n+   For each unique path in the note, we'll open a BFD with a bfd\n+   target of \"binary\".  This is an unstructured bfd target upon which\n+   we'll impose a structure from the mappings in the architecture-specific\n+   mappings note.  A BFD section is allocated and initialized for each\n+   file-backed mapping.\n+\n+   We take care to not share already open bfds with other parts of\n+   GDB; in particular, we don't want to add new sections to existing\n+   BFDs.  We do, however, ensure that the BFDs that we allocate here\n+   will go away (be deallocated) when the core target is detached.  */\n+\n+void\n+core_target::build_file_mappings ()\n+{\n+  std::unordered_map<std::string, struct bfd *> bfd_map;\n+\n+  /* See linux_read_core_file_mappings() in linux-tdep.c for an example\n+     read_core_file_mappings method.  */\n+  gdbarch_read_core_file_mappings (m_core_gdbarch, core_bfd,\n+\n+    /* After determining the number of mappings, read_core_file_mappings\n+       will invoke this lambda which allocates target_section storage for\n+       the mappings.  */\n+    [&] (ULONGEST count)\n+      {\n+\tm_core_file_mappings.sections = XNEWVEC (struct target_section, count);\n+\tm_core_file_mappings.sections_end = m_core_file_mappings.sections;\n+      },\n+\n+    /* read_core_file_mappings will invoke this lambda for each mapping\n+       that it finds.  */\n+    [&] (int num, ULONGEST start, ULONGEST end, ULONGEST file_ofs,\n+         const char *filename, const void *other)\n+      {\n+\t/* Architecture-specific read_core_mapping methods are expected to\n+\t   weed out non-file-backed mappings.  */\n+\tgdb_assert (filename != nullptr);\n+\n+\tstruct bfd *bfd = bfd_map[filename];\n+\tif (bfd == nullptr)\n+\t  {\n+\t    /* Use exec_file_find() to do sysroot expansion.  It'll\n+\t       also strip the potential sysroot \"target:\" prefix.  If\n+\t       there is no sysroot, an equivalent (possibly more\n+\t       canonical) pathname will be provided.  */\n+\t    gdb::unique_xmalloc_ptr<char> expanded_fname\n+\t      = exec_file_find (filename, NULL);\n+\t    if (expanded_fname == nullptr)\n+\t      {\n+\t\twarning (_(\"Can't open file %s during file-backed mapping \"\n+\t\t\t   \"note processing\"),\n+\t\t\t expanded_fname.get ());\n+\t\treturn;\n+\t      }\n+\n+\t    bfd = bfd_map[filename] = bfd_openr (expanded_fname.get (),\n+\t                                         \"binary\");\n+\n+\t    if (bfd == nullptr || !bfd_check_format (bfd, bfd_object))\n+\t      {\n+\t\t/* If we get here, there's a good chance that it's due to\n+\t\t   an internal error.  We issue a warning instead of an\n+\t\t   internal error because of the possibility that the\n+\t\t   file was removed in between checking for its\n+\t\t   existence during the expansion in exec_file_find()\n+\t\t   and the calls to bfd_openr() / bfd_check_format(). \n+\t\t   Output both the path from the core file note along\n+\t\t   with its expansion to make debugging this problem\n+\t\t   easier.  */\n+\t\twarning (_(\"Can't open file %s which was expanded to %s \"\n+\t\t\t   \"during file-backed mapping note processing\"),\n+\t\t\t filename, expanded_fname.get ());\n+\t\tif (bfd != nullptr)\n+\t\t  bfd_close (bfd);\n+\t\treturn;\n+\t      }\n+\t    /* Ensure that the bfd will be closed when core_bfd is closed. \n+\t       This can be checked before/after a core file detach via\n+\t       \"maint info bfds\".  */\n+\t    gdb_bfd_record_inclusion (core_bfd, bfd);\n+\t  }\n+\n+\t/* Make new BFD section.  All sections have the same name,\n+\t   which is permitted by bfd_make_section_anyway().  */\n+\tasection *sec = bfd_make_section_anyway (bfd, \"load\");\n+\tif (sec == nullptr)\n+\t  error (_(\"Can't make section\"));\n+\tsec->filepos = file_ofs;\n+\tbfd_set_section_flags (sec, SEC_READONLY | SEC_HAS_CONTENTS);\n+\tbfd_set_section_size (sec, end - start);\n+\tbfd_set_section_vma (sec, start);\n+\tbfd_set_section_lma (sec, start);\n+\tbfd_set_section_alignment (sec, 2);\n+\n+\t/* Set target_section fields.  */\n+\tstruct target_section *ts = m_core_file_mappings.sections_end++;\n+\tts->addr = start;\n+\tts->endaddr = end;\n+\tts->owner = nullptr;\n+\tts->the_bfd_section = sec;\n+      });\n }\n \n static void add_to_thread_list (bfd *, asection *, void *);\n@@ -633,10 +751,21 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \tif (xfer_status == TARGET_XFER_OK)\n \t  return TARGET_XFER_OK;\n \n-\t/* Now check the stratum beneath us; this should be file_stratum.  */\n-\txfer_status = this->beneath ()->xfer_partial (object, annex, readbuf,\n-\t\t\t\t\t\t      writebuf, offset, len,\n-\t\t\t\t\t\t      xfered_len);\n+\t/* Check file backed mappings.  If they're available, use\n+\t   core file provided mappings (e.g. from .note.linuxcore.file\n+\t   or the like) as this should provide a more accurate\n+\t   result.  If not, check the stratum beneath us, which should\n+\t   be the file stratum.  */\n+\tif (m_core_file_mappings.sections != nullptr)\n+\t  xfer_status = section_table_xfer_memory_partial\n+\t\t\t  (readbuf, writebuf,\n+\t\t\t   offset, len, xfered_len,\n+\t\t\t   m_core_file_mappings.sections,\n+\t\t\t   m_core_file_mappings.sections_end);\n+\telse\n+\t  xfer_status = this->beneath ()->xfer_partial (object, annex, readbuf,\n+\t\t\t\t\t\t\twritebuf, offset, len,\n+\t\t\t\t\t\t\txfered_len);\n \tif (xfer_status == TARGET_XFER_OK)\n \t  return TARGET_XFER_OK;\n "
    },
    {
      "sha": "2ca9f599a5b4982f5efbc19e3ebb3d8d42a114b3",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 136,
      "deletions": 67,
      "changes": 203,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/db082f5979ff95409b7de7a2a96d083f2642c8c3/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/db082f5979ff95409b7de7a2a96d083f2642c8c3/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=db082f5979ff95409b7de7a2a96d083f2642c8c3",
      "patch": "@@ -1018,106 +1018,174 @@ linux_info_proc (struct gdbarch *gdbarch, const char *args,\n     }\n }\n \n-/* Implement \"info proc mappings\" for a corefile.  */\n+/* Implementation of `gdbarch_read_core_file_mappings', as defined in\n+   gdbarch.h.\n+   \n+   This function reads the NT_FILE note (which BFD turns into the\n+   section \".note.linuxcore.file\").  The format of this note / section\n+   is described as follows in the Linux kernel sources in\n+   fs/binfmt_elf.c:\n+   \n+      long count     -- how many files are mapped\n+      long page_size -- units for file_ofs\n+      array of [COUNT] elements of\n+\tlong start\n+\tlong end\n+\tlong file_ofs\n+      followed by COUNT filenames in ASCII: \"FILE1\" NUL \"FILE2\" NUL...\n+      \n+   CBFD is the BFD of the core file.\n+\n+   PRE_LOOP_CB is the callback function to invoke prior to starting\n+   the loop which processes individual entries.  This callback will\n+   only be executed after the note has been examined in enough\n+   detail to verify that it's not malformed in some way.\n+   \n+   LOOP_CB is the callback function that will be executed once\n+   for each mapping.  */\n \n static void\n-linux_core_info_proc_mappings (struct gdbarch *gdbarch, const char *args)\n+linux_read_core_file_mappings (struct gdbarch *gdbarch,\n+\t\t\t       struct bfd *cbfd,\n+\t\t\t       gdb::function_view<void (ULONGEST count)>\n+\t\t\t         pre_loop_cb,\n+\t\t\t       gdb::function_view<void (int num,\n+\t\t\t                                ULONGEST start,\n+\t\t\t\t\t\t\tULONGEST end,\n+\t\t\t\t\t\t\tULONGEST file_ofs,\n+\t\t\t\t\t\t\tconst char *filename,\n+\t\t\t\t\t\t\tconst void *other)>\n+\t\t\t\t loop_cb)\n {\n-  asection *section;\n-  ULONGEST count, page_size;\n-  unsigned char *descdata, *filenames, *descend;\n-  size_t note_size;\n-  unsigned int addr_size_bits, addr_size;\n-  struct gdbarch *core_gdbarch = gdbarch_from_bfd (core_bfd);\n-  /* We assume this for reading 64-bit core files.  */\n+  /* Ensure that ULONGEST is big enough for reading 64-bit core files.  */\n   gdb_static_assert (sizeof (ULONGEST) >= 8);\n \n-  section = bfd_get_section_by_name (core_bfd, \".note.linuxcore.file\");\n-  if (section == NULL)\n-    {\n-      warning (_(\"unable to find mappings in core file\"));\n-      return;\n-    }\n+  /* It's not required that the NT_FILE note exists, so return silently\n+     if it's not found.  Beyond this point though, we'll complain\n+     if problems are found.  */\n+  asection *section = bfd_get_section_by_name (cbfd, \".note.linuxcore.file\");\n+  if (section == nullptr)\n+    return;\n \n-  addr_size_bits = gdbarch_addr_bit (core_gdbarch);\n-  addr_size = addr_size_bits / 8;\n-  note_size = bfd_section_size (section);\n+  unsigned int addr_size_bits = gdbarch_addr_bit (gdbarch);\n+  unsigned int addr_size = addr_size_bits / 8;\n+  size_t note_size = bfd_section_size (section);\n \n   if (note_size < 2 * addr_size)\n-    error (_(\"malformed core note - too short for header\"));\n+    {\n+      warning (_(\"malformed core note - too short for header\"));\n+      return;\n+    }\n \n-  gdb::def_vector<unsigned char> contents (note_size);\n+  gdb::def_vector<gdb_byte> contents (note_size);\n   if (!bfd_get_section_contents (core_bfd, section, contents.data (),\n \t\t\t\t 0, note_size))\n-    error (_(\"could not get core note contents\"));\n+    {\n+      warning (_(\"could not get core note contents\"));\n+      return;\n+    }\n \n-  descdata = contents.data ();\n-  descend = descdata + note_size;\n+  gdb_byte *descdata = contents.data ();\n+  char *descend = (char *) descdata + note_size;\n \n   if (descdata[note_size - 1] != '\\0')\n-    error (_(\"malformed note - does not end with \\\\0\"));\n+    {\n+      warning (_(\"malformed note - does not end with \\\\0\"));\n+      return;\n+    }\n \n-  count = bfd_get (addr_size_bits, core_bfd, descdata);\n+  ULONGEST count = bfd_get (addr_size_bits, core_bfd, descdata);\n   descdata += addr_size;\n \n-  page_size = bfd_get (addr_size_bits, core_bfd, descdata);\n+  ULONGEST page_size = bfd_get (addr_size_bits, core_bfd, descdata);\n   descdata += addr_size;\n \n   if (note_size < 2 * addr_size + count * 3 * addr_size)\n-    error (_(\"malformed note - too short for supplied file count\"));\n-\n-  printf_filtered (_(\"Mapped address spaces:\\n\\n\"));\n-  if (gdbarch_addr_bit (gdbarch) == 32)\n-    {\n-      printf_filtered (\"\\t%10s %10s %10s %10s %s\\n\",\n-\t\t       \"Start Addr\",\n-\t\t       \"  End Addr\",\n-\t\t       \"      Size\", \"    Offset\", \"objfile\");\n-    }\n-  else\n     {\n-      printf_filtered (\"  %18s %18s %10s %10s %s\\n\",\n-\t\t       \"Start Addr\",\n-\t\t       \"  End Addr\",\n-\t\t       \"      Size\", \"    Offset\", \"objfile\");\n+      warning (_(\"malformed note - too short for supplied file count\"));\n+      return;\n     }\n \n-  filenames = descdata + count * 3 * addr_size;\n-  while (--count > 0)\n+  char *filenames = (char *) descdata + count * 3 * addr_size;\n+\n+  /* Make sure that the correct number of filenames exist.  Complain\n+     if there aren't enough or are too many.  */\n+  char *f = filenames;\n+  for (int i = 0; i < count; i++)\n     {\n-      ULONGEST start, end, file_ofs;\n+      if (f >= descend)\n+        {\n+\t  warning (_(\"malformed note - filename area is too small\"));\n+\t  return;\n+\t}\n+      f += strnlen (f, descend - f) + 1;\n+    }\n+  /* Complain, but don't return early if the filename area is too big.  */\n+  if (f != descend)\n+    warning (_(\"malformed note - filename area is too big\"));\n \n-      if (filenames == descend)\n-\terror (_(\"malformed note - filenames end too early\"));\n+  pre_loop_cb (count);\n \n-      start = bfd_get (addr_size_bits, core_bfd, descdata);\n+  for (int i = 0; i < count; i++)\n+    {\n+      ULONGEST start = bfd_get (addr_size_bits, core_bfd, descdata);\n       descdata += addr_size;\n-      end = bfd_get (addr_size_bits, core_bfd, descdata);\n+      ULONGEST end = bfd_get (addr_size_bits, core_bfd, descdata);\n       descdata += addr_size;\n-      file_ofs = bfd_get (addr_size_bits, core_bfd, descdata);\n+      ULONGEST file_ofs\n+        = bfd_get (addr_size_bits, core_bfd, descdata) * page_size;\n       descdata += addr_size;\n+      char * filename = filenames;\n+      filenames += strlen ((char *) filenames) + 1;\n \n-      file_ofs *= page_size;\n-\n-      if (gdbarch_addr_bit (gdbarch) == 32)\n-\tprintf_filtered (\"\\t%10s %10s %10s %10s %s\\n\",\n-\t\t\t paddress (gdbarch, start),\n-\t\t\t paddress (gdbarch, end),\n-\t\t\t hex_string (end - start),\n-\t\t\t hex_string (file_ofs),\n-\t\t\t filenames);\n-      else\n-\tprintf_filtered (\"  %18s %18s %10s %10s %s\\n\",\n-\t\t\t paddress (gdbarch, start),\n-\t\t\t paddress (gdbarch, end),\n-\t\t\t hex_string (end - start),\n-\t\t\t hex_string (file_ofs),\n-\t\t\t filenames);\n-\n-      filenames += 1 + strlen ((char *) filenames);\n+      loop_cb (i, start, end, file_ofs, filename, nullptr);\n     }\n }\n \n+/* Implement \"info proc mappings\" for a corefile.  */\n+\n+static void\n+linux_core_info_proc_mappings (struct gdbarch *gdbarch, const char *args)\n+{\n+  linux_read_core_file_mappings (gdbarch, core_bfd,\n+    [=] (ULONGEST count)\n+      {\n+\tprintf_filtered (_(\"Mapped address spaces:\\n\\n\"));\n+\tif (gdbarch_addr_bit (gdbarch) == 32)\n+\t  {\n+\t    printf_filtered (\"\\t%10s %10s %10s %10s %s\\n\",\n+\t\t\t     \"Start Addr\",\n+\t\t\t     \"  End Addr\",\n+\t\t\t     \"      Size\", \"    Offset\", \"objfile\");\n+\t  }\n+\telse\n+\t  {\n+\t    printf_filtered (\"  %18s %18s %10s %10s %s\\n\",\n+\t\t\t     \"Start Addr\",\n+\t\t\t     \"  End Addr\",\n+\t\t\t     \"      Size\", \"    Offset\", \"objfile\");\n+\t  }\n+      },\n+    [=] (int num, ULONGEST start, ULONGEST end, ULONGEST file_ofs,\n+         const char *filename, const void *other)\n+      {\n+\tif (gdbarch_addr_bit (gdbarch) == 32)\n+\t  printf_filtered (\"\\t%10s %10s %10s %10s %s\\n\",\n+\t\t\t   paddress (gdbarch, start),\n+\t\t\t   paddress (gdbarch, end),\n+\t\t\t   hex_string (end - start),\n+\t\t\t   hex_string (file_ofs),\n+\t\t\t   filename);\n+\telse\n+\t  printf_filtered (\"  %18s %18s %10s %10s %s\\n\",\n+\t\t\t   paddress (gdbarch, start),\n+\t\t\t   paddress (gdbarch, end),\n+\t\t\t   hex_string (end - start),\n+\t\t\t   hex_string (file_ofs),\n+\t\t\t   filename);\n+      });\n+}\n+\n /* Implement \"info proc\" for a corefile.  */\n \n static void\n@@ -2472,6 +2540,7 @@ linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   set_gdbarch_info_proc (gdbarch, linux_info_proc);\n   set_gdbarch_core_info_proc (gdbarch, linux_core_info_proc);\n   set_gdbarch_core_xfer_siginfo (gdbarch, linux_core_xfer_siginfo);\n+  set_gdbarch_read_core_file_mappings (gdbarch, linux_read_core_file_mappings);\n   set_gdbarch_find_memory_regions (gdbarch, linux_find_memory_regions);\n   set_gdbarch_make_corefile_notes (gdbarch, linux_make_corefile_notes);\n   set_gdbarch_has_shared_address_space (gdbarch,"
    }
  ]
}