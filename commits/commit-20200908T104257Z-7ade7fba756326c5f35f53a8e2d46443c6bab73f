{
  "sha": "7ade7fba756326c5f35f53a8e2d46443c6bab73f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2FkZTdmYmE3NTYzMjZjNWYzNWY1M2E4ZTJkNDY0NDNjNmJhYjczZg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-09-08T09:27:15Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-09-08T10:42:57Z"
    },
    "message": "sync libiberty from gcc\n\nconfig/\n\tSync from gcc\n\t2020-07-15  H.J. Lu  <hjl.tools@gmail.com>\n\tPR bootstrap/96202\n\t* cet.m4 (GCC_CET_HOST_FLAGS): Don't enable CET without CET\n\tsupport in stage1 nor for build support.\nlibiberty/\n\t* configure: Regenerate.\n\n\tSync from gcc\n\t2020-09-08  Alan Modra  <amodra@gmail.com>\n\t* d-demangle.c: Include limits.h.\n\t(ULONG_MAX, UINT_MAX): Provide fall-back definition.\n\t(dlang_number): Simplify and correct overflow test.  Only\n\twrite *ret on returning non-NULL.  Make \"ret\" an unsigned long*.\n\tOnly succeed for result of [0,UINT_MAX].\n\t(dlang_decode_backref): Simplify and correct overflow test.\n\tOnly write *ret on returning non-NULL.  Only succeed for\n\tresult [1,MAX_LONG].\n\t(dlang_backref): Remove now unnecessary range check.\n\t(dlang_symbol_name_p): Likewise.\n\t(string_need): Take a size_t n arg, and use size_t tem.\n\t(string_append): Use size_t n.\n\t(string_appendn, string_prependn): Take a size_t n arg.\n\t(TEMPLATE_LENGTH_UNKNOWN): Define as -1UL.\n\t(dlang_lname, dlang_parse_template): Take an unsigned long len\n\targ.\n\t(dlang_symbol_backref, dlang_identifier, dlang_parse_integer),\n\t(dlang_parse_integer, dlang_parse_string),\n\t(dlang_parse_arrayliteral, dlang_parse_assocarray),\n\t(dlang_parse_structlit, dlang_parse_tuple),\n\t(dlang_template_symbol_param, dlang_template_args): Use\n\tunsigned long variables.\n\t* testsuite/d-demangle-expected: Add new tests.\n\n\t2020-08-04  Iain Buclaw  <ibuclaw@gdcproject.org>\n\t* d-demangle.c (dlang_function_args): Handle 'in' and 'in ref'\n\tparameter storage classes.\n\t(dlang_type): Remove identifier type.\n\t* testsuite/d-demangle-expected: Update tests.\n\n\t2020-08-03  Richard Biener  <rguenther@suse.de>\n\tPR lto/96385\n\t* simple-object-elf.c\n\t(simple_object_elf_copy_lto_debug_sections): Localize global\n\tUNDEFs and reuse the prevailing name.\n\n\t2020-07-10  Ian Lance Taylor  <iant@golang.org>\n\tPR demangler/96143\n\t* cp-demangle.c (d_lambda): Don't add substitution candidate.\n\t* testsuite/demangle-expected: Update a few existing test cases\n\taccordingly, and add a new test case.\n\n\t2020-07-04  Jason Merrill  <jason@redhat.com>\n\t* cp-demangle.c (cplus_demangle_operators): Add di, dx, dX.\n\t(d_expression_1): Handle di and dX.\n\t(is_designated_init, d_maybe_print_designated_init): New.\n\t(d_print_comp_inner): Use d_maybe_print_designated_init.\n\t* testsuite/demangle-expected: Add designator tests.\n\n\t2020-06-25  Nick Clifton  <nickc@redhat.com>\n\t* bsearch.c (bsearch): Remove use of register keyword.\n\t* bsearch_r.c (bsearch_r): Likewise.",
    "tree": {
      "sha": "ae2410807141a852931d34ec7598af91f6d5694a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ae2410807141a852931d34ec7598af91f6d5694a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7ade7fba756326c5f35f53a8e2d46443c6bab73f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7ade7fba756326c5f35f53a8e2d46443c6bab73f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7ade7fba756326c5f35f53a8e2d46443c6bab73f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7ade7fba756326c5f35f53a8e2d46443c6bab73f/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cac1e71dbd365fd59c916600b654b0920a7475cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cac1e71dbd365fd59c916600b654b0920a7475cd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cac1e71dbd365fd59c916600b654b0920a7475cd"
    }
  ],
  "stats": {
    "total": 383,
    "additions": 299,
    "deletions": 84
  },
  "files": [
    {
      "sha": "a6454d33092140ccfb7a9229122206f17417391d",
      "filename": "config/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/config/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/config/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/config/ChangeLog?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -1,3 +1,11 @@\n+2020-09-08  Alan Modra  <amodra@gmail.com>\n+\n+\tSync from gcc\n+\t2020-07-15  H.J. Lu  <hjl.tools@gmail.com>\n+\tPR bootstrap/96202\n+\t* cet.m4 (GCC_CET_HOST_FLAGS): Don't enable CET without CET\n+\tsupport in stage1 nor for build support.\n+\n 2020-07-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* largefile.m4 (ACX_LARGEFILE) <sparc-*-solaris*|i?86-*-solaris*>:"
    },
    {
      "sha": "c67fb4f35b65b84a88bcbebadaf8d12781025a75",
      "filename": "config/cet.m4",
      "status": "modified",
      "additions": 18,
      "deletions": 5,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/config/cet.m4",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/config/cet.m4",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/config/cet.m4?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -13,7 +13,7 @@ case \"$host\" in\n     case \"$enable_cet\" in\n       auto)\n \t# Check if target supports multi-byte NOPs\n-\t# and if assembler supports CET insn.\n+\t# and if compiler and assembler support CET insn.\n \tcet_save_CFLAGS=\"$CFLAGS\"\n \tCFLAGS=\"$CFLAGS -fcf-protection\"\n \tAC_COMPILE_IFELSE(\n@@ -70,7 +70,7 @@ case \"$host\" in\n     case \"$enable_cet\" in\n       auto)\n \t# Check if target supports multi-byte NOPs\n-\t# and if assembler supports CET insn.\n+\t# and if compiler and assembler support CET.\n \tAC_COMPILE_IFELSE(\n \t [AC_LANG_PROGRAM(\n \t  [],\n@@ -85,13 +85,26 @@ asm (\"setssbsy\");\n \t [enable_cet=no])\n \t;;\n       yes)\n-\t# Check if assembler supports CET.\n+\t# Check if compiler and assembler support CET.\n \tAC_COMPILE_IFELSE(\n \t [AC_LANG_PROGRAM(\n \t  [],\n \t  [asm (\"setssbsy\");])],\n-\t [],\n-\t [AC_MSG_ERROR([assembler with CET support is required for --enable-cet])])\n+\t [support_cet=yes],\n+\t [support_cet=no])\n+\tif test $support_cet = \"no\"; then\n+\t  if test x$enable_bootstrap != xno \\\n+\t     && test -z \"${with_build_subdir}\" \\\n+\t     && (test ! -f ../stage_current \\\n+\t         || test `cat ../stage_current` != \"stage1\"); then\n+\t    # Require CET support only for the final GCC build.\n+\t    AC_MSG_ERROR([compiler and assembler with CET support are required for --enable-cet])\n+\t  else\n+\t    # Don't enable CET without CET support for non-bootstrap\n+\t    # build, in stage1 nor for build support.\n+\t    enable_cet=no\n+\t  fi\n+\tfi\n \t;;\n     esac\n     CFLAGS=\"$cet_save_CFLAGS\""
    },
    {
      "sha": "6b46642fd35bbd851d90fd20d88308874a2589db",
      "filename": "libiberty/ChangeLog",
      "status": "modified",
      "additions": 59,
      "deletions": 0,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/ChangeLog?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -1,3 +1,62 @@\n+2020-09-08  Alan Modra  <amodra@gmail.com>\n+\n+\t* configure: Regenerate.\n+\n+\tSync from gcc\n+\t2020-09-08  Alan Modra  <amodra@gmail.com>\n+\t* d-demangle.c: Include limits.h.\n+\t(ULONG_MAX, UINT_MAX): Provide fall-back definition.\n+\t(dlang_number): Simplify and correct overflow test.  Only\n+\twrite *ret on returning non-NULL.  Make \"ret\" an unsigned long*.\n+\tOnly succeed for result of [0,UINT_MAX].\n+\t(dlang_decode_backref): Simplify and correct overflow test.\n+\tOnly write *ret on returning non-NULL.  Only succeed for\n+\tresult [1,MAX_LONG].\n+\t(dlang_backref): Remove now unnecessary range check.\n+\t(dlang_symbol_name_p): Likewise.\n+\t(string_need): Take a size_t n arg, and use size_t tem.\n+\t(string_append): Use size_t n.\n+\t(string_appendn, string_prependn): Take a size_t n arg.\n+\t(TEMPLATE_LENGTH_UNKNOWN): Define as -1UL.\n+\t(dlang_lname, dlang_parse_template): Take an unsigned long len\n+\targ.\n+\t(dlang_symbol_backref, dlang_identifier, dlang_parse_integer),\n+\t(dlang_parse_integer, dlang_parse_string),\n+\t(dlang_parse_arrayliteral, dlang_parse_assocarray),\n+\t(dlang_parse_structlit, dlang_parse_tuple),\n+\t(dlang_template_symbol_param, dlang_template_args): Use\n+\tunsigned long variables.\n+\t* testsuite/d-demangle-expected: Add new tests.\n+\n+\t2020-08-04  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\t* d-demangle.c (dlang_function_args): Handle 'in' and 'in ref'\n+\tparameter storage classes.\n+\t(dlang_type): Remove identifier type.\n+\t* testsuite/d-demangle-expected: Update tests.\n+\n+\t2020-08-03  Richard Biener  <rguenther@suse.de>\n+\tPR lto/96385\n+\t* simple-object-elf.c\n+\t(simple_object_elf_copy_lto_debug_sections): Localize global\n+\tUNDEFs and reuse the prevailing name.\n+\n+\t2020-07-10  Ian Lance Taylor  <iant@golang.org>\n+\tPR demangler/96143\n+\t* cp-demangle.c (d_lambda): Don't add substitution candidate.\n+\t* testsuite/demangle-expected: Update a few existing test cases\n+\taccordingly, and add a new test case.\n+\n+\t2020-07-04  Jason Merrill  <jason@redhat.com>\n+\t* cp-demangle.c (cplus_demangle_operators): Add di, dx, dX.\n+\t(d_expression_1): Handle di and dX.\n+\t(is_designated_init, d_maybe_print_designated_init): New.\n+\t(d_print_comp_inner): Use d_maybe_print_designated_init.\n+\t* testsuite/demangle-expected: Add designator tests.\n+\n+\t2020-06-25  Nick Clifton  <nickc@redhat.com>\n+\t* bsearch.c (bsearch): Remove use of register keyword.\n+\t* bsearch_r.c (bsearch_r): Likewise.\n+\n 2020-06-23  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* bsearch_r.c: New file."
    },
    {
      "sha": "18158b9591b98d23d67d882170f769e3627b129c",
      "filename": "libiberty/bsearch.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/bsearch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/bsearch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/bsearch.c?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -69,13 +69,13 @@ is respectively less than, matching, or greater than the array member.\n  * look at item 3.\n  */\n void *\n-bsearch (register const void *key, const void *base0,\n-         size_t nmemb, register size_t size,\n-         register int (*compar)(const void *, const void *))\n+bsearch (const void *key, const void *base0,\n+         size_t nmemb, size_t size,\n+         int (*compar)(const void *, const void *))\n {\n-\tregister const char *base = (const char *) base0;\n-\tregister int lim, cmp;\n-\tregister const void *p;\n+\tconst char *base = (const char *) base0;\n+\tint lim, cmp;\n+\tconst void *p;\n \n \tfor (lim = nmemb; lim != 0; lim >>= 1) {\n \t\tp = base + (lim >> 1) * size;"
    },
    {
      "sha": "2a2ca6f5e2373966e5bac3d0b2f67aa373b69f76",
      "filename": "libiberty/bsearch_r.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/bsearch_r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/bsearch_r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/bsearch_r.c?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -70,14 +70,14 @@ is respectively less than, matching, or greater than the array member.\n  * look at item 3.\n  */\n void *\n-bsearch_r (register const void *key, const void *base0,\n-\t   size_t nmemb, register size_t size,\n-\t   register int (*compar)(const void *, const void *, void *),\n+bsearch_r (const void *key, const void *base0,\n+\t   size_t nmemb, size_t size,\n+\t   int (*compar)(const void *, const void *, void *),\n \t   void *arg)\n {\n-\tregister const char *base = (const char *) base0;\n-\tregister int lim, cmp;\n-\tregister const void *p;\n+\tconst char *base = (const char *) base0;\n+\tint lim, cmp;\n+\tconst void *p;\n \n \tfor (lim = nmemb; lim != 0; lim >>= 1) {\n \t\tp = base + (lim >> 1) * size;"
    },
    {
      "sha": "ff93c9ee9a6fa9c6bb1938bcdfffb2d0ae8c9698",
      "filename": "libiberty/configure",
      "status": "modified",
      "additions": 17,
      "deletions": 4,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/configure?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -5291,7 +5291,7 @@ case \"$host\" in\n     case \"$enable_cet\" in\n       auto)\n \t# Check if target supports multi-byte NOPs\n-\t# and if assembler supports CET insn.\n+\t# and if compiler and assembler support CET.\n \tcat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n \n@@ -5317,7 +5317,7 @@ fi\n rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n \t;;\n       yes)\n-\t# Check if assembler supports CET.\n+\t# Check if compiler and assembler support CET.\n \tcat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n \n@@ -5330,11 +5330,24 @@ asm (\"setssbsy\");\n }\n _ACEOF\n if ac_fn_c_try_compile \"$LINENO\"; then :\n-\n+  support_cet=yes\n else\n-  as_fn_error $? \"assembler with CET support is required for --enable-cet\" \"$LINENO\" 5\n+  support_cet=no\n fi\n rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+\tif test $support_cet = \"no\"; then\n+\t  if test x$enable_bootstrap != xno \\\n+\t     && test -z \"${with_build_subdir}\" \\\n+\t     && (test ! -f ../stage_current \\\n+\t         || test `cat ../stage_current` != \"stage1\"); then\n+\t    # Require CET support only for the final GCC build.\n+\t    as_fn_error $? \"compiler and assembler with CET support are required for --enable-cet\" \"$LINENO\" 5\n+\t  else\n+\t    # Don't enable CET without CET support for non-bootstrap\n+\t    # build, in stage1 nor for build support.\n+\t    enable_cet=no\n+\t  fi\n+\tfi\n \t;;\n     esac\n     CFLAGS=\"$cet_save_CFLAGS\""
    },
    {
      "sha": "aede23fbf6b6c7a8a05e44f8f5df1d0ce580ffb9",
      "filename": "libiberty/cp-demangle.c",
      "status": "modified",
      "additions": 76,
      "deletions": 4,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/cp-demangle.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/cp-demangle.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/cp-demangle.c?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -1809,13 +1809,16 @@ const struct demangle_operator_info cplus_demangle_operators[] =\n   { \"cm\", NL (\",\"),         2 },\n   { \"co\", NL (\"~\"),         1 },\n   { \"dV\", NL (\"/=\"),        2 },\n+  { \"dX\", NL (\"[...]=\"),     3 }, /* [expr...expr] = expr */\n   { \"da\", NL (\"delete[] \"), 1 },\n   { \"dc\", NL (\"dynamic_cast\"), 2 },\n   { \"de\", NL (\"*\"),         1 },\n+  { \"di\", NL (\"=\"),         2 }, /* .name = expr */\n   { \"dl\", NL (\"delete \"),   1 },\n   { \"ds\", NL (\".*\"),        2 },\n   { \"dt\", NL (\".\"),         2 },\n   { \"dv\", NL (\"/\"),         2 },\n+  { \"dx\", NL (\"]=\"),        2 }, /* [expr] = expr */\n   { \"eO\", NL (\"^=\"),        2 },\n   { \"eo\", NL (\"^\"),         2 },\n   { \"eq\", NL (\"==\"),        2 },\n@@ -3291,6 +3294,12 @@ op_is_new_cast (struct demangle_component *op)\n                 ::= sr <type> <unqualified-name>\n                 ::= sr <type> <unqualified-name> <template-args>\n                 ::= <expr-primary>\n+\n+  <braced-expression> ::= <expression>\n+\t\t      ::= di <field source-name> <braced-expression>\t# .name = expr\n+\t\t      ::= dx <index expression> <braced-expression>\t# [expr] = expr\n+\t\t      ::= dX <range begin expression> <range end expression> <braced-expression>\n+\t\t\t\t\t\t\t\t\t# [expr ... expr] = expr\n */\n \n static inline struct demangle_component *\n@@ -3453,6 +3462,8 @@ d_expression_1 (struct d_info *di)\n \t    else if (code[0] == 'f')\n \t      /* fold-expression.  */\n \t      left = d_operator_name (di);\n+\t    else if (!strcmp (code, \"di\"))\n+\t      left = d_unqualified_name (di);\n \t    else\n \t      left = d_expression_1 (di);\n \t    if (!strcmp (code, \"cl\"))\n@@ -3480,7 +3491,8 @@ d_expression_1 (struct d_info *di)\n \n \t    if (code == NULL)\n \t      return NULL;\n-\t    else if (!strcmp (code, \"qu\"))\n+\t    else if (!strcmp (code, \"qu\")\n+\t\t     || !strcmp (code, \"dX\"))\n \t      {\n \t\t/* ?: expression.  */\n \t\tfirst = d_expression_1 (di);\n@@ -3764,9 +3776,6 @@ d_lambda (struct d_info *di)\n       ret->u.s_unary_num.num = num;\n     }\n \n-  if (! d_add_substitution (di, ret))\n-    return NULL;\n-\n   return ret;\n }\n \n@@ -4675,6 +4684,64 @@ d_maybe_print_fold_expression (struct d_print_info *dpi, int options,\n   return 1;\n }\n \n+/* True iff DC represents a C99-style designated initializer.  */\n+\n+static int\n+is_designated_init (struct demangle_component *dc)\n+{\n+  if (dc->type != DEMANGLE_COMPONENT_BINARY\n+      && dc->type != DEMANGLE_COMPONENT_TRINARY)\n+    return 0;\n+\n+  struct demangle_component *op = d_left (dc);\n+  const char *code = op->u.s_operator.op->code;\n+  return (code[0] == 'd'\n+\t  && (code[1] == 'i' || code[1] == 'x' || code[1] == 'X'));\n+}\n+\n+/* If DC represents a C99-style designated initializer, print it and return\n+   true; otherwise, return false.  */\n+\n+static int\n+d_maybe_print_designated_init (struct d_print_info *dpi, int options,\n+\t\t\t       struct demangle_component *dc)\n+{\n+  if (!is_designated_init (dc))\n+    return 0;\n+\n+  const char *code = d_left (dc)->u.s_operator.op->code;\n+\n+  struct demangle_component *operands = d_right (dc);\n+  struct demangle_component *op1 = d_left (operands);\n+  struct demangle_component *op2 = d_right (operands);\n+\n+  if (code[1] == 'i')\n+    d_append_char (dpi, '.');\n+  else\n+    d_append_char (dpi, '[');\n+\n+  d_print_comp (dpi, options, op1);\n+  if (code[1] == 'X')\n+    {\n+      d_append_string (dpi, \" ... \");\n+      d_print_comp (dpi, options, d_left (op2));\n+      op2 = d_right (op2);\n+    }\n+  if (code[1] != 'i')\n+    d_append_char (dpi, ']');\n+  if (is_designated_init (op2))\n+    {\n+      /* Don't put '=' or '(' between chained designators.  */\n+      d_print_comp (dpi, options, op2);\n+    }\n+  else\n+    {\n+      d_append_char (dpi, '=');\n+      d_print_subexpr (dpi, options, op2);\n+    }\n+  return 1;\n+}\n+\n /* Subroutine to handle components.  */\n \n static void\n@@ -5491,6 +5558,9 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       if (d_maybe_print_fold_expression (dpi, options, dc))\n \treturn;\n \n+      if (d_maybe_print_designated_init (dpi, options, dc))\n+\treturn;\n+\n       /* We wrap an expression which uses the greater-than operator in\n \t an extra layer of parens so that it does not get confused\n \t with the '>' which ends the template parameters.  */\n@@ -5548,6 +5618,8 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t}\n       if (d_maybe_print_fold_expression (dpi, options, dc))\n \treturn;\n+      if (d_maybe_print_designated_init (dpi, options, dc))\n+\treturn;\n       {\n \tstruct demangle_component *op = d_left (dc);\n \tstruct demangle_component *first = d_left (d_right (dc));"
    },
    {
      "sha": "cd3bc96303ecfbc4b1c998f76dfff46ed37e5572",
      "filename": "libiberty/d-demangle.c",
      "status": "modified",
      "additions": 70,
      "deletions": 46,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/d-demangle.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/d-demangle.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/d-demangle.c?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -31,6 +31,9 @@ If not, see <http://www.gnu.org/licenses/>.  */\n #ifdef HAVE_CONFIG_H\n #include \"config.h\"\n #endif\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n \n #include \"safe-ctype.h\"\n \n@@ -45,6 +48,13 @@ If not, see <http://www.gnu.org/licenses/>.  */\n #include <demangle.h>\n #include \"libiberty.h\"\n \n+#ifndef ULONG_MAX\n+#define\tULONG_MAX\t(~0UL)\n+#endif\n+#ifndef UINT_MAX\n+#define\tUINT_MAX\t(~0U)\n+#endif\n+\n /* A mini string-handling package */\n \n typedef struct string\t\t/* Beware: these aren't required to be */\n@@ -55,9 +65,9 @@ typedef struct string\t\t/* Beware: these aren't required to be */\n } string;\n \n static void\n-string_need (string *s, int n)\n+string_need (string *s, size_t n)\n {\n-  int tem;\n+  size_t tem;\n \n   if (s->b == NULL)\n     {\n@@ -68,7 +78,7 @@ string_need (string *s, int n)\n       s->p = s->b = XNEWVEC (char, n);\n       s->e = s->b + n;\n     }\n-  else if (s->e - s->p < n)\n+  else if ((size_t) (s->e - s->p) < n)\n     {\n       tem = s->p - s->b;\n       n += tem;\n@@ -117,14 +127,14 @@ string_setlength (string *s, int n)\n static void\n string_append (string *p, const char *s)\n {\n-  int n = strlen (s);\n+  size_t n = strlen (s);\n   string_need (p, n);\n   memcpy (p->p, s, n);\n   p->p += n;\n }\n \n static void\n-string_appendn (string *p, const char *s, int n)\n+string_appendn (string *p, const char *s, size_t n)\n {\n   if (n != 0)\n     {\n@@ -135,7 +145,7 @@ string_appendn (string *p, const char *s, int n)\n }\n \n static void\n-string_prependn (string *p, const char *s, int n)\n+string_prependn (string *p, const char *s, size_t n)\n {\n   char *q;\n \n@@ -170,7 +180,7 @@ struct dlang_info\n };\n \n /* Pass as the LEN to dlang_parse_template if symbol length is not known.  */\n-enum { TEMPLATE_LENGTH_UNKNOWN = -1 };\n+#define TEMPLATE_LENGTH_UNKNOWN (-1UL)\n \n /* Prototypes for forward referenced functions */\n static const char *dlang_function_type (string *, const char *,\n@@ -193,38 +203,39 @@ static const char *dlang_parse_tuple (string *, const char *,\n \t\t\t\t      struct dlang_info *);\n \n static const char *dlang_parse_template (string *, const char *,\n-\t\t\t\t\t struct dlang_info *, long);\n+\t\t\t\t\t struct dlang_info *, unsigned long);\n \n-static const char *dlang_lname (string *, const char *, long);\n+static const char *dlang_lname (string *, const char *, unsigned long);\n \n \n /* Extract the number from MANGLED, and assign the result to RET.\n-   Return the remaining string on success or NULL on failure.  */\n+   Return the remaining string on success or NULL on failure.\n+   A result larger than UINT_MAX is considered a failure.  */\n static const char *\n-dlang_number (const char *mangled, long *ret)\n+dlang_number (const char *mangled, unsigned long *ret)\n {\n   /* Return NULL if trying to extract something that isn't a digit.  */\n   if (mangled == NULL || !ISDIGIT (*mangled))\n     return NULL;\n \n-  (*ret) = 0;\n+  unsigned long val = 0;\n \n   while (ISDIGIT (*mangled))\n     {\n-      (*ret) *= 10;\n+      unsigned long digit = mangled[0] - '0';\n \n-      /* If an overflow occured when multiplying by ten, the result\n-\t will not be a multiple of ten.  */\n-      if ((*ret % 10) != 0)\n+      /* Check for overflow.  */\n+      if (val > (UINT_MAX - digit) / 10)\n \treturn NULL;\n \n-      (*ret) += mangled[0] - '0';\n+      val = val * 10 + digit;\n       mangled++;\n     }\n \n-  if (*mangled == '\\0' || *ret < 0)\n+  if (*mangled == '\\0')\n     return NULL;\n \n+  *ret = val;\n   return mangled;\n }\n \n@@ -273,7 +284,8 @@ dlang_call_convention_p (const char *mangled)\n }\n \n /* Extract the back reference position from MANGLED, and assign the result\n-   to RET.  Return the remaining string on success or NULL on failure.  */\n+   to RET.  Return the remaining string on success or NULL on failure.\n+   A result <= 0 is a failure.  */\n static const char *\n dlang_decode_backref (const char *mangled, long *ret)\n {\n@@ -294,24 +306,26 @@ dlang_decode_backref (const char *mangled, long *ret)\n \t    [A-Z] NumberBackRef\n \t    ^\n    */\n-  (*ret) = 0;\n+  unsigned long val = 0;\n \n   while (ISALPHA (*mangled))\n     {\n-      (*ret) *= 26;\n+      /* Check for overflow.  */\n+      if (val > (ULONG_MAX - 25) / 26)\n+\tbreak;\n \n-      /* If an overflow occured when multiplying by 26, the result\n-\t will not be a multiple of 26.  */\n-      if ((*ret % 26) != 0)\n-\treturn NULL;\n+      val *= 26;\n \n       if (mangled[0] >= 'a' && mangled[0] <= 'z')\n \t{\n-\t  (*ret) += mangled[0] - 'a';\n+\t  val += mangled[0] - 'a';\n+\t  if ((long) val <= 0)\n+\t    break;\n+\t  *ret = val;\n \t  return mangled + 1;\n \t}\n \n-      (*ret) += mangled[0] - 'A';\n+      val += mangled[0] - 'A';\n       mangled++;\n     }\n \n@@ -337,7 +351,7 @@ dlang_backref (const char *mangled, const char **ret, struct dlang_info *info)\n   if (mangled == NULL)\n     return NULL;\n \n-  if (refpos <= 0 || refpos > qpos - info->s)\n+  if (refpos > qpos - info->s)\n     return NULL;\n \n   /* Set the position of the back reference.  */\n@@ -359,7 +373,7 @@ dlang_symbol_backref (string *decl, const char *mangled,\n \t    ^\n    */\n   const char *backref;\n-  long len;\n+  unsigned long len;\n \n   /* Get position of the back reference.  */\n   mangled = dlang_backref (mangled, &backref, info);\n@@ -435,7 +449,7 @@ dlang_symbol_name_p (const char *mangled, struct dlang_info *info)\n     return 0;\n \n   mangled = dlang_decode_backref (mangled + 1, &ret);\n-  if (mangled == NULL || ret <= 0 || ret > qref - info->s)\n+  if (mangled == NULL || ret > qref - info->s)\n     return 0;\n \n   return ISDIGIT (qref[-ret]);\n@@ -699,6 +713,15 @@ dlang_function_args (string *decl, const char *mangled, struct dlang_info *info)\n \n       switch (*mangled)\n \t{\n+\tcase 'I': /* in(T) */\n+\t  mangled++;\n+\t  string_append (decl, \"in \");\n+\t  if (*mangled == 'K') /* in ref(T) */\n+\t    {\n+\t      mangled++;\n+\t      string_append (decl, \"ref \");\n+\t    }\n+\t  break;\n \tcase 'J': /* out(T) */\n \t  mangled++;\n \t  string_append (decl, \"out \");\n@@ -826,7 +849,6 @@ dlang_type (string *decl, const char *mangled, struct dlang_info *info)\n       mangled = dlang_function_type (decl, mangled, info);\n       string_append (decl, \"function\");\n       return mangled;\n-    case 'I': /* ident T */\n     case 'C': /* class T */\n     case 'S': /* struct T */\n     case 'E': /* enum T */\n@@ -985,7 +1007,7 @@ dlang_type (string *decl, const char *mangled, struct dlang_info *info)\n static const char *\n dlang_identifier (string *decl, const char *mangled, struct dlang_info *info)\n {\n-  long len;\n+  unsigned long len;\n \n   if (mangled == NULL || *mangled == '\\0')\n     return NULL;\n@@ -1003,7 +1025,7 @@ dlang_identifier (string *decl, const char *mangled, struct dlang_info *info)\n   if (endptr == NULL || len == 0)\n     return NULL;\n \n-  if (strlen (endptr) < (size_t) len)\n+  if (strlen (endptr) < len)\n     return NULL;\n \n   mangled = endptr;\n@@ -1020,7 +1042,7 @@ dlang_identifier (string *decl, const char *mangled, struct dlang_info *info)\n    with special treatment for some magic compiler generted symbols.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_lname (string *decl, const char *mangled, long len)\n+dlang_lname (string *decl, const char *mangled, unsigned long len)\n {\n   switch (len)\n     {\n@@ -1119,7 +1141,7 @@ dlang_parse_integer (string *decl, const char *mangled, char type)\n       char value[20];\n       int pos = sizeof(value);\n       int width = 0;\n-      long val;\n+      unsigned long val;\n \n       mangled = dlang_number (mangled, &val);\n       if (mangled == NULL)\n@@ -1175,7 +1197,7 @@ dlang_parse_integer (string *decl, const char *mangled, char type)\n   else if (type == 'b')\n     {\n       /* Parse boolean value.  */\n-      long val;\n+      unsigned long val;\n \n       mangled = dlang_number (mangled, &val);\n       if (mangled == NULL)\n@@ -1294,7 +1316,7 @@ static const char *\n dlang_parse_string (string *decl, const char *mangled)\n {\n   char type = *mangled;\n-  long len;\n+  unsigned long len;\n \n   mangled++;\n   mangled = dlang_number (mangled, &len);\n@@ -1358,7 +1380,7 @@ dlang_parse_string (string *decl, const char *mangled)\n static const char *\n dlang_parse_arrayliteral (string *decl, const char *mangled)\n {\n-  long elements;\n+  unsigned long elements;\n \n   mangled = dlang_number (mangled, &elements);\n   if (mangled == NULL)\n@@ -1384,7 +1406,7 @@ dlang_parse_arrayliteral (string *decl, const char *mangled)\n static const char *\n dlang_parse_assocarray (string *decl, const char *mangled)\n {\n-  long elements;\n+  unsigned long elements;\n \n   mangled = dlang_number (mangled, &elements);\n   if (mangled == NULL)\n@@ -1415,7 +1437,7 @@ dlang_parse_assocarray (string *decl, const char *mangled)\n static const char *\n dlang_parse_structlit (string *decl, const char *mangled, const char *name)\n {\n-  long args;\n+  unsigned long args;\n \n   mangled = dlang_number (mangled, &args);\n   if (mangled == NULL)\n@@ -1642,7 +1664,7 @@ dlang_parse_qualified (string *decl, const char *mangled,\n static const char *\n dlang_parse_tuple (string *decl, const char *mangled, struct dlang_info *info)\n {\n-  long elements;\n+  unsigned long elements;\n \n   mangled = dlang_number (mangled, &elements);\n   if (mangled == NULL)\n@@ -1677,7 +1699,7 @@ dlang_template_symbol_param (string *decl, const char *mangled,\n   if (*mangled == 'Q')\n     return dlang_parse_qualified (decl, mangled, info, 0);\n \n-  long len;\n+  unsigned long len;\n   const char *endptr = dlang_number (mangled, &len);\n \n   if (endptr == NULL || len == 0)\n@@ -1790,12 +1812,12 @@ dlang_template_args (string *decl, const char *mangled, struct dlang_info *info)\n \t}\n \tcase 'X': /* Externally mangled parameter.  */\n \t{\n-\t  long len;\n+\t  unsigned long len;\n \t  const char *endptr;\n \n \t  mangled++;\n \t  endptr = dlang_number (mangled, &len);\n-\t  if (endptr == NULL || strlen (endptr) < (size_t) len)\n+\t  if (endptr == NULL || strlen (endptr) < len)\n \t    return NULL;\n \n \t  string_appendn (decl, endptr, len);\n@@ -1815,7 +1837,7 @@ dlang_template_args (string *decl, const char *mangled, struct dlang_info *info)\n    Returns the remaining signature on success or NULL on failure.  */\n static const char *\n dlang_parse_template (string *decl, const char *mangled,\n-\t\t      struct dlang_info *info, long len)\n+\t\t      struct dlang_info *info, unsigned long len)\n {\n   const char *start = mangled;\n   string args;\n@@ -1851,7 +1873,9 @@ dlang_parse_template (string *decl, const char *mangled,\n   string_delete (&args);\n \n   /* Check for template name length mismatch.  */\n-  if (len != TEMPLATE_LENGTH_UNKNOWN && mangled && (mangled - start) != len)\n+  if (len != TEMPLATE_LENGTH_UNKNOWN\n+      && mangled\n+      && (unsigned long) (mangled - start) != len)\n     return NULL;\n \n   return mangled;"
    },
    {
      "sha": "7c9d492f6a42d32f921f65f7dac20139b4283d31",
      "filename": "libiberty/simple-object-elf.c",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/simple-object-elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/simple-object-elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/simple-object-elf.c?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -1467,6 +1467,11 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n \t\t       && st_shndx < shnum\n \t\t       && pfnret[st_shndx - 1] == -1)\n \t\tdiscard = 1;\n+\t      /* We also need to remove global UNDEFs which can\n+\t\t cause link fails later.  */\n+\t      else if (st_shndx == SHN_UNDEF\n+\t\t       && ELF_ST_BIND (*st_info) == STB_GLOBAL)\n+\t\tdiscard = 1;\n \n \t      if (discard)\n \t\t{"
    },
    {
      "sha": "ba0ffed5c8d6b9898b53f3556cd5278b38e1e4f4",
      "filename": "libiberty/testsuite/d-demangle-expected",
      "status": "modified",
      "additions": 16,
      "deletions": 8,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/testsuite/d-demangle-expected",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/testsuite/d-demangle-expected",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/testsuite/d-demangle-expected?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -274,14 +274,6 @@ _D8demangle4testFNhG4dZv\n demangle.test(__vector(double[4]))\n #\n --format=dlang\n-_D8demangle4testFI5identZv\n-demangle.test(ident)\n-#\n---format=dlang\n-_D8demangle4testFI5ident4testZv\n-demangle.test(ident.test)\n-#\n---format=dlang\n _D8demangle4testFC5classZv\n demangle.test(class)\n #\n@@ -314,6 +306,14 @@ _D8demangle4testFT7typedef4testZv\n demangle.test(typedef.test)\n #\n --format=dlang\n+_D8demangle4testFIaZv\n+demangle.test(in char)\n+#\n+--format=dlang\n+_D8demangle4testFIKaZv\n+demangle.test(in ref char)\n+#\n+--format=dlang\n _D8demangle4testFJaZv\n demangle.test(out char)\n #\n@@ -1140,6 +1140,14 @@ _D4test34__T3barVG3uw3_616263VG3wd3_646566Z1xi\n test.bar!(\"abc\"w, \"def\"d).x\n #\n --format=dlang\n+_D4test21__T3funVwi4294967295Z3funFNaNbNiNfZv\n+test.fun!('\\Uffffffff').fun()\n+#\n+--format=dlang\n+_D4test21__T3funVwi4294967296Z3funFNaNbNiNfZv\n+_D4test21__T3funVwi4294967296Z3funFNaNbNiNfZv\n+#\n+--format=dlang\n _D6plugin8generateFiiZAya\n plugin.generate(int, int)\n #"
    },
    {
      "sha": "0850db3d6dd448e254a85e7e941eb9604dcf5dc6",
      "filename": "libiberty/testsuite/demangle-expected",
      "status": "modified",
      "additions": 18,
      "deletions": 5,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/testsuite/demangle-expected",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ade7fba756326c5f35f53a8e2d46443c6bab73f/libiberty/testsuite/demangle-expected",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/testsuite/demangle-expected?ref=7ade7fba756326c5f35f53a8e2d46443c6bab73f",
      "patch": "@@ -1114,7 +1114,7 @@ DFA\n # http://sourceware.org/bugzilla/show_bug.cgi?id=11572\n --format=auto\n _ZN3Psi7VariantIIcPKcEE5visitIIRZN11VariantTest9TestVisit11test_methodEvEUlS2_E0_RZNS6_11test_methodEvEUlcE1_RZNS6_11test_methodEvEUlNS_4NoneEE_EEENS_13VariantDetail19SelectVisitorResultIIDpT_EE4typeEDpOSG_\n-Psi::VariantDetail::SelectVisitorResult<VariantTest::TestVisit::test_method()::{lambda(char const*)#2}&, VariantTest::TestVisit::test_method()::{lambda(char)#3}&, VariantTest::TestVisit::test_method()::{lambda(Psi::None)#1}&>::type Psi::Variant<char, char const*>::visit<VariantTest::TestVisit::test_method()::{lambda(char const*)#2}&, VariantTest::TestVisit::test_method()::{lambda(char)#3}&, VariantTest::TestVisit::test_method()::{lambda(Psi::None)#1}&>((VariantTest::TestVisit::test_method()::{lambda(Psi::None)#1}&)...)\n+Psi::VariantDetail::SelectVisitorResult<VariantTest::TestVisit::test_method()::{lambda(char const*)#2}&, VariantTest::TestVisit::test_method()::{lambda(char)#3}&, VariantTest::TestVisit::test_method()::{lambda(Psi::None)#1}&>::type Psi::Variant<char, char const*>::visit<VariantTest::TestVisit::test_method()::{lambda(char const*)#2}&, VariantTest::TestVisit::test_method()::{lambda(char)#3}&, VariantTest::TestVisit::test_method()::{lambda(Psi::None)#1}&>(VariantTest::TestVisit::test_method()::{lambda(char const*)#2}&, VariantTest::TestVisit::test_method()::{lambda(char)#3}&, VariantTest::TestVisit::test_method()::{lambda(Psi::None)#1}&)\n #\n # Clone suffix tests\n #\n@@ -1170,7 +1170,7 @@ f<void () const, void () const>\n #\n --format=gnu-v3\n _ZN4modc6parser8sequenceINS_9astParser13LocatedParserINS0_9ParserRefINS2_UlRNS2_16TokenParserInputEE_EEEEEINS0_14OptionalParserINS2_18ListParserTemplateILNS_6tokens5Token4TypeE4EXadL_ZNSD_Ut_13parenthesizedEEEE6ParserINS4_INS0_6ParserIS5_NS_3ast10ExpressionEEEEEEEEENSA_INS4_INS2_22OneOfKeywordsToTParserINSJ_5StyleEEEEEEENS0_14SequenceParserIS5_INS0_18ExactElementParserIS5_EENSA_ISM_EEEEENS0_14RepeatedParserINS4_INS0_15TransformParserINSU_IS5_INS4_INSP_INSJ_10Annotation12RelationshipEEEEESX_EEENS2_UlNS2_3LocES12_ONS_5MaybeISK_EEE19_EEEEELb0EEEEEENSU_INS0_17ExtractParserTypeIT_E9InputTypeEINS0_8MaybeRefIS1F_E4TypeEDpNS1I_IT0_E4TypeEEEEOS1F_DpOS1L_\n-modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> ><modc::parser::ExtractParserType<modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> > >::InputType, modc::parser::MaybeRef<modc::astParser::{lambda(modc::astParser::Loc, modc::parser::RepeatedParser, modc::Maybe<modc::parser::Parser>&&)#21}>::Type, modc::parser::RepeatedParser<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > ><modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser> >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::RepeatedParser, modc::Maybe<modc::parser::Parser>&&)#21}> >, false><modc::parser::OptionalParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > > >::Type, modc::parser::RepeatedParser<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > ><modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser> >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::RepeatedParser, modc::Maybe<modc::parser::Parser>&&)#21}> >, false><modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> ><modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> > > >::Type, modc::parser::RepeatedParser<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > ><modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser> >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::RepeatedParser, modc::Maybe<modc::parser::Parser>&&)#21}> >, false><modc::parser::SequenceParser<modc::astParser::TokenParserInput<modc::parser::ExactElementParser<modc::astParser::TokenParserInput>, modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> ><modc::ast::Expression> > > >::Type, modc::parser::RepeatedParser<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > ><modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser> >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::RepeatedParser, modc::Maybe<modc::parser::Parser>&&)#21}> >, false><modc::parser::RepeatedParser<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > ><modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser> >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::RepeatedParser, modc::Maybe<modc::parser::Parser>&&)#21}> >, false> >::Type> modc::parser::sequence<modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> >, modc::parser::OptionalParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > >, modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> ><modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> > >, modc::parser::SequenceParser<modc::astParser::TokenParserInput<modc::parser::ExactElementParser<modc::astParser::TokenParserInput>, modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> ><modc::ast::Expression> > >, modc::parser::RepeatedParser<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Style> ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > ><modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::{unnamed type#1}::parenthesized>::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser> >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::RepeatedParser, modc::Maybe<modc::parser::Parser>&&)#21}> >, false> >(modc::astParser::{lambda(modc::astParser::Loc, modc::parser::RepeatedParser, modc::Maybe<modc::parser::Parser>&&)#21}&&, (modc::parser::ExtractParserType<modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> > >&&)...)\n+modc::parser::OptionalParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::parser::Parser::Style> > ><modc::parser::ExtractParserType<modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> > >::InputType, modc::parser::MaybeRef<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::OptionalParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::parser::Parser::Style> > ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::parser::OptionalParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::Token::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > ><modc::parser::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser<modc::astParser::TokenParserInput> > >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::TransformParser, modc::Maybe<modc::ast>&&)#21}> > >::Type, modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> ><modc::parser::OptionalParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::Token::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > > >::Type, modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> ><modc::parser::OptionalParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::parser::Parser::Style> > > >::Type, modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> ><modc::parser::SequenceParser<modc::astParser::TokenParserInput<modc::parser::ExactElementParser<modc::astParser::TokenParserInput>, modc::parser::OptionalParser<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > > >::Type, modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> ><modc::parser::RepeatedParser<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::OptionalParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::parser::Parser::Style> > ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::parser::OptionalParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::Token::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > ><modc::parser::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser<modc::astParser::TokenParserInput> > >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::TransformParser, modc::Maybe<modc::ast>&&)#21}> >, false> >::Type> modc::parser::sequence<modc::astParser::LocatedParser<modc::parser::ParserRef<modc::astParser::{lambda(modc::astParser::TokenParserInput&)#1}> >, modc::parser::OptionalParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::Token::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > >, modc::parser::OptionalParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::parser::Parser::Style> > >, modc::parser::SequenceParser<modc::astParser::TokenParserInput<modc::parser::ExactElementParser<modc::astParser::TokenParserInput>, modc::parser::OptionalParser<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > >, modc::parser::RepeatedParser<modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::OptionalParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::parser::Parser::Style> > ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::parser::OptionalParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::Token::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > ><modc::parser::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser<modc::astParser::TokenParserInput> > >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::TransformParser, modc::Maybe<modc::ast>&&)#21}> >, false> >(modc::parser::ParserRef<modc::parser::TransformParser<modc::parser::OptionalParser<modc::parser::ParserRef<modc::astParser::OneOfKeywordsToTParser<modc::parser::Parser::Style> > ><modc::astParser::TokenParserInput<modc::parser::ParserRef<modc::parser::OptionalParser<modc::astParser::ListParserTemplate<(modc::tokens::Token::Type)4, &modc::tokens::Token::{unnamed type#1}::parenthesized>::Parser<modc::parser::ParserRef<modc::parser::Parser<modc::astParser::TokenParserInput, modc::ast::Expression> > > ><modc::parser::Parser::Annotation::Relationship> >, modc::parser::ExactElementParser<modc::astParser::TokenParserInput> > >, modc::astParser::{lambda(modc::astParser::Loc, modc::parser::TransformParser, modc::Maybe<modc::ast>&&)#21}> >&&, (modc::parser::MaybeRef&&)...)\n --format=gnu-v3\n _ZNKR1A1hEv\n A::h() const &\n@@ -1189,7 +1189,7 @@ void f<int>()\n # https://sourceware.org/bugzilla/show_bug.cgi?id=14963#c3\n --format=gnu-v3\n _ZSt7forwardIRN1x14refobjiteratorINS0_3refINS0_4mime30multipart_section_processorObjIZ15get_body_parserIZZN14mime_processor21make_section_iteratorERKNS2_INS3_10sectionObjENS0_10ptrrefBaseEEEbENKUlvE_clEvEUlSB_bE_ZZNS6_21make_section_iteratorESB_bENKSC_clEvEUlSB_E0_ENS1_INS2_INS0_20outputrefiteratorObjIiEES8_EEEERKSsSB_OT_OT0_EUlmE_NS3_32make_multipart_default_discarderISP_EEEES8_EEEEEOT_RNSt16remove_referenceISW_E4typeE\n-x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> >, x::ptrrefBase> >& std::forward<x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> >, x::ptrrefBase> >&>(std::remove_reference<x::mime::multipart_section_processorObj<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> > >::type&)\n+x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}> >, x::ptrrefBase> >& std::forward<x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}> >, x::ptrrefBase> >&>(std::remove_reference<x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}> >, x::ptrrefBase> >&>::type&)\n #\n --format=gnu-v3 --no-params\n _ZNK7strings8internal8SplitterINS_9delimiter5AnyOfENS_9SkipEmptyEEcvT_ISt6vectorI12basic_stringIcSt11char_traitsIcESaIcEESaISD_EEvEEv\n@@ -1213,7 +1213,7 @@ A::operator C<int><C>\n # https://sourceware.org/bugzilla/show_bug.cgi?id=14963#c16\n --format=gnu-v3\n _ZN3mdr16in_cached_threadIRZNK4cudr6GPUSet17parallel_for_eachIZN5tns3d20shape_representation7compute7GPUImpl7executeERKNS_1AINS_7ptr_refIKjEELl3ELl3ENS_8c_strideILl1ELl0EEEEERKNS8_INS9_IjEELl4ELl1ESD_EEEUliRKNS1_7ContextERNS7_5StateEE_JSt6vectorISO_SaISO_EEEEEvOT_DpRT0_EUlSP_E_JSt17reference_wrapperISO_EEEENS_12ScopedFutureIDTclfp_spcl7forwardISW_Efp0_EEEEESV_DpOSW_\n-mdr::ScopedFuture<decltype ({parm#1}(((forward<cudr::GPUSet::parallel_for_each<tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> > >(tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}&&, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> >&) const::{lambda(tns3d::shape_representation::compute::GPUImpl::State&)#1}&>)({parm#2}))...))> mdr::in_cached_thread<cudr::GPUSet::parallel_for_each<tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> > >(cudr::GPUSet::parallel_for_each<tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> > >(tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}&&, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> >&) const::{lambda(tns3d::shape_representation::compute::GPUImpl::State&)#1}&, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> >&) const::{lambda(tns3d::shape_representation::compute::GPUImpl::State&)#1}&, std::reference_wrapper<tns3d::shape_representation::compute::GPUImpl::State> >(cudr::GPUSet::parallel_for_each<tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> > >(tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}&&, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> >&) const::{lambda(tns3d::shape_representation::compute::GPUImpl::State&)#1}&, (cudr::GPUSet::parallel_for_each<tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> > >(tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}&&, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> >&) const::{lambda(tns3d::shape_representation::compute::GPUImpl::State&)#1}&&&)...)\n+mdr::ScopedFuture<decltype ({parm#1}((forward<std::reference_wrapper<tns3d::shape_representation::compute::GPUImpl::State> >)({parm#2})))> mdr::in_cached_thread<cudr::GPUSet::parallel_for_each<tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> > >(tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}&&, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> >&) const::{lambda(tns3d::shape_representation::compute::GPUImpl::State&)#1}&, std::reference_wrapper<tns3d::shape_representation::compute::GPUImpl::State> >(tns3d::shape_representation::compute::GPUImpl::execute(mdr::A<mdr::ptr_ref<unsigned int const>, 3l, 3l, mdr::c_stride<1l, 0l> > const&, mdr::A<mdr::ptr_ref<unsigned int>, 4l, 1l, mdr::c_stride<1l, 0l> > const&)::{lambda(int, cudr::Context const&, tns3d::shape_representation::compute::GPUImpl::State&)#1}&&, std::vector<tns3d::shape_representation::compute::GPUImpl::State, std::allocator<tns3d::shape_representation::compute::GPUImpl::State> >&&)\n # https://sourceware.org/bugzilla/show_bug.cgi?id=14963#c18\n --format=gnu-v3\n _ZNSt9_Any_data9_M_accessIPZN13ThreadManager10futureTaskISt5_BindIFSt7_Mem_fnIM6RunnerFvvEEPS5_EEEEvOT_EUlvE_EERSC_v\n@@ -1269,7 +1269,7 @@ void function_temp<int>(A<sizeof ((int)(999))>)\n #\n --format=gnu-v3\n _Z7ZipWithI7QStringS0_5QListZN4oral6detail16AdaptCreateTableI7AccountEES0_RKNS3_16CachedFieldsDataEEUlRKS0_SA_E_ET1_IDTclfp1_cvT__EcvT0__EEEERKT1_ISC_ERKT1_ISD_ET2_\n-QList<decltype ({parm#3}((QString)(), (QString)()))> ZipWith<QString, QString, QList, oral::detail::AdaptCreateTable<Account>(oral::detail::CachedFieldsData const&)::{lambda(QString const&, QString const&)#1}>(QList<oral::detail::AdaptCreateTable<Account>(oral::detail::CachedFieldsData const&)::{lambda(QString const&, QString const&)#1}> const&, QList<QList> const&, oral::detail::AdaptCreateTable<Account>(oral::detail::CachedFieldsData const&)::{lambda(QString const&, QString const&)#1})\n+QList<decltype ({parm#3}((QString)(), (QString)()))> ZipWith<QString, QString, QList, oral::detail::AdaptCreateTable<Account>(oral::detail::CachedFieldsData const&)::{lambda(QString const&, QString const&)#1}>(QList<QList> const&, QList<QString> const&, oral::detail::AdaptCreateTable<Account>(oral::detail::CachedFieldsData const&)::{lambda(QString const&, QString const&)#1})\n #\n # These three are symbols generated by g++'s testsuite, which triggered the same bug as above.\n --format=gnu-v3\n@@ -1456,3 +1456,16 @@ coro1::empty::operator co_await() const\n \n _ZNK3FoossERKS_\n Foo::operator<=>(Foo const&) const\n+\n+_Z1f1AIXtl1Udi1iLi0EEEE\n+f(A<U{.i=(0)}>)\n+\n+_Z1f1AIXtl1Xdi1adi1bdxLi3ELi1EEEE\n+f(A<X{.a.b[3]=(1)}>)\n+\n+_Z1f1AIXtl1Xdi1adi1bdXLi3ELi4ELi1EEEE\n+f(A<X{.a.b[3 ... 4]=(1)}>)\n+\n+# PR 96143\n+_Z2F2IZ1FvEUlvE_EN1AIT_E1XES2_\n+A<F()::{lambda()#1}>::X F2<F()::{lambda()#1}>(F()::{lambda()#1})"
    }
  ]
}