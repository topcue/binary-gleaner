{
  "sha": "696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
  "node_id": "C_kwDOANOeidoAKDY5NmQ2ZjRkNWMxYmM5YjM2ZDA0MDJjMjM5M2VmZTYyZTQ5MzkyZDk",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-03T21:45:37Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-08T20:20:30Z"
    },
    "message": "Use for-each more in gdb\n\nThere are some loops in gdb that use ARRAY_SIZE (or a wordier\nequivalent) to loop over a static array.  This patch changes some of\nthese to use foreach instead.\n\nRegression tested on x86-64 Fedora 34.",
    "tree": {
      "sha": "e0a5c7edfce36b065afc1f443a15906936c44660",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e0a5c7edfce36b065afc1f443a15906936c44660"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "621f8c42d3df079ca5781cdb0925c5ec3498f59c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/621f8c42d3df079ca5781cdb0925c5ec3498f59c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/621f8c42d3df079ca5781cdb0925c5ec3498f59c"
    }
  ],
  "stats": {
    "total": 228,
    "additions": 106,
    "deletions": 122
  },
  "files": [
    {
      "sha": "e636c84758421b037b8f2d7b54e0320ad8ecdcee",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 8,
      "deletions": 14,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -12202,7 +12202,6 @@ static std::string\n ada_exception_catchpoint_cond_string (const char *excep_string,\n \t\t\t\t      enum ada_exception_catchpoint_kind ex)\n {\n-  int i;\n   bool is_standard_exc = false;\n   std::string result;\n \n@@ -12235,9 +12234,9 @@ ada_exception_catchpoint_cond_string (const char *excep_string,\n      breakpoint condition is to use its fully-qualified named:\n      e.g. my_package.constraint_error.  */\n \n-  for (i = 0; i < sizeof (standard_exc) / sizeof (char *); i++)\n+  for (const char *name : standard_exc)\n     {\n-      if (strcmp (standard_exc [i], excep_string) == 0)\n+      if (strcmp (name, excep_string) == 0)\n \t{\n \t  is_standard_exc = true;\n \t  break;\n@@ -12467,13 +12466,11 @@ ada_is_exception_sym (struct symbol *sym)\n static int\n ada_is_non_standard_exception_sym (struct symbol *sym)\n {\n-  int i;\n-\n   if (!ada_is_exception_sym (sym))\n     return 0;\n \n-  for (i = 0; i < ARRAY_SIZE (standard_exc); i++)\n-    if (strcmp (sym->linkage_name (), standard_exc[i]) == 0)\n+  for (const char *name : standard_exc)\n+    if (strcmp (sym->linkage_name (), name) == 0)\n       return 0;  /* A standard exception.  */\n \n   /* Numeric_Error is also a standard exception, so exclude it.\n@@ -12538,20 +12535,17 @@ static void\n ada_add_standard_exceptions (compiled_regex *preg,\n \t\t\t     std::vector<ada_exc_info> *exceptions)\n {\n-  int i;\n-\n-  for (i = 0; i < ARRAY_SIZE (standard_exc); i++)\n+  for (const char *name : standard_exc)\n     {\n-      if (preg == NULL\n-\t  || preg->exec (standard_exc[i], 0, NULL, 0) == 0)\n+      if (preg == NULL || preg->exec (name, 0, NULL, 0) == 0)\n \t{\n \t  struct bound_minimal_symbol msymbol\n-\t    = ada_lookup_simple_minsym (standard_exc[i]);\n+\t    = ada_lookup_simple_minsym (name);\n \n \t  if (msymbol.minsym != NULL)\n \t    {\n \t      struct ada_exc_info info\n-\t\t= {standard_exc[i], BMSYMBOL_VALUE_ADDRESS (msymbol)};\n+\t\t= {name, BMSYMBOL_VALUE_ADDRESS (msymbol)};\n \n \t      exceptions->push_back (info);\n \t    }"
    },
    {
      "sha": "ae43853adaabf3ccfe6b05f32d9400e1f257168d",
      "filename": "gdb/bcache.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/bcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/bcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bcache.c?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -68,7 +68,7 @@ bcache::expand_hash_table ()\n      so we roughly double the table size each time.  After we fall off \n      the end of this table, we just double.  Don't laugh --- there have\n      been executables sighted with a gigabyte of debug info.  */\n-  static unsigned long sizes[] = { \n+  static const unsigned long sizes[] = {\n     1021, 2053, 4099, 8191, 16381, 32771,\n     65537, 131071, 262144, 524287, 1048573, 2097143,\n     4194301, 8388617, 16777213, 33554467, 67108859, 134217757,\n@@ -85,10 +85,10 @@ bcache::expand_hash_table ()\n \n   /* Find the next size.  */\n   new_num_buckets = m_num_buckets * 2;\n-  for (i = 0; i < (sizeof (sizes) / sizeof (sizes[0])); i++)\n-    if (sizes[i] > m_num_buckets)\n+  for (unsigned long a_size : sizes)\n+    if (a_size > m_num_buckets)\n       {\n-\tnew_num_buckets = sizes[i];\n+\tnew_num_buckets = a_size;\n \tbreak;\n       }\n "
    },
    {
      "sha": "22cd50ab1e24ce3cf2f057ad7441f55529ac3277",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 20,
      "deletions": 21,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -2644,7 +2644,6 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n {\n   int c;\n   int namelen;\n-  unsigned int i;\n   const char *tokstart;\n   bool saw_structop = last_was_structop;\n \n@@ -2667,33 +2666,33 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \n   tokstart = pstate->lexptr;\n   /* See if it is a special token of length 3.  */\n-  for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)\n-    if (strncmp (tokstart, tokentab3[i].oper, 3) == 0)\n+  for (const auto &token : tokentab3)\n+    if (strncmp (tokstart, token.oper, 3) == 0)\n       {\n-\tif ((tokentab3[i].flags & FLAG_CXX) != 0\n+\tif ((token.flags & FLAG_CXX) != 0\n \t    && par_state->language ()->la_language != language_cplus)\n \t  break;\n-\tgdb_assert ((tokentab3[i].flags & FLAG_C) == 0);\n+\tgdb_assert ((token.flags & FLAG_C) == 0);\n \n \tpstate->lexptr += 3;\n-\tyylval.opcode = tokentab3[i].opcode;\n-\treturn tokentab3[i].token;\n+\tyylval.opcode = token.opcode;\n+\treturn token.token;\n       }\n \n   /* See if it is a special token of length 2.  */\n-  for (i = 0; i < sizeof tokentab2 / sizeof tokentab2[0]; i++)\n-    if (strncmp (tokstart, tokentab2[i].oper, 2) == 0)\n+  for (const auto &token : tokentab2)\n+    if (strncmp (tokstart, token.oper, 2) == 0)\n       {\n-\tif ((tokentab2[i].flags & FLAG_CXX) != 0\n+\tif ((token.flags & FLAG_CXX) != 0\n \t    && par_state->language ()->la_language != language_cplus)\n \t  break;\n-\tgdb_assert ((tokentab2[i].flags & FLAG_C) == 0);\n+\tgdb_assert ((token.flags & FLAG_C) == 0);\n \n \tpstate->lexptr += 2;\n-\tyylval.opcode = tokentab2[i].opcode;\n-\tif (tokentab2[i].token == ARROW)\n+\tyylval.opcode = token.opcode;\n+\tif (token.token == ARROW)\n \t  last_was_structop = 1;\n-\treturn tokentab2[i].token;\n+\treturn token.token;\n       }\n \n   switch (c = *tokstart)\n@@ -2979,18 +2978,18 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \n   /* Catch specific keywords.  */\n   std::string copy = copy_name (yylval.sval);\n-  for (i = 0; i < sizeof ident_tokens / sizeof ident_tokens[0]; i++)\n-    if (copy == ident_tokens[i].oper)\n+  for (const auto &token : ident_tokens)\n+    if (copy == token.oper)\n       {\n-\tif ((ident_tokens[i].flags & FLAG_CXX) != 0\n+\tif ((token.flags & FLAG_CXX) != 0\n \t    && par_state->language ()->la_language != language_cplus)\n \t  break;\n-\tif ((ident_tokens[i].flags & FLAG_C) != 0\n+\tif ((token.flags & FLAG_C) != 0\n \t    && par_state->language ()->la_language != language_c\n \t    && par_state->language ()->la_language != language_objc)\n \t  break;\n \n-\tif ((ident_tokens[i].flags & FLAG_SHADOW) != 0)\n+\tif ((token.flags & FLAG_SHADOW) != 0)\n \t  {\n \t    struct field_of_this_result is_a_field_of_this;\n \n@@ -3009,8 +3008,8 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \n \t/* It is ok to always set this, even though we don't always\n \t   strictly need to.  */\n-\tyylval.opcode = ident_tokens[i].opcode;\n-\treturn ident_tokens[i].token;\n+\tyylval.opcode = token.opcode;\n+\treturn token.token;\n       }\n \n   if (*tokstart == '$')"
    },
    {
      "sha": "0e506f5b46e6e8f0ed88ace32380bd91fd603faa",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -147,9 +147,9 @@ inspect_type (struct demangle_parse_info *info,\n   name[ret_comp->u.s_name.len] = '\\0';\n \n   /* Ignore any typedefs that should not be substituted.  */\n-  for (int i = 0; i < ARRAY_SIZE (ignore_typedefs); ++i)\n+  for (const char *ignorable : ignore_typedefs)\n     {\n-      if (strcmp (name, ignore_typedefs[i]) == 0)\n+      if (strcmp (name, ignorable) == 0)\n \treturn 0;\n     }\n "
    },
    {
      "sha": "637bc8cd7df759ff48924665504ce3b46e0ff1ad",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 12,
      "deletions": 13,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -1027,7 +1027,6 @@ lex_one_token (struct parser_state *par_state)\n {\n   int c;\n   int namelen;\n-  unsigned int i;\n   const char *tokstart;\n   int saw_structop = last_was_structop;\n \n@@ -1039,21 +1038,21 @@ lex_one_token (struct parser_state *par_state)\n \n   tokstart = pstate->lexptr;\n   /* See if it is a special token of length 3.  */\n-  for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)\n-    if (strncmp (tokstart, tokentab3[i].oper, 3) == 0)\n+  for (const auto &token : tokentab3)\n+    if (strncmp (tokstart, token.oper, 3) == 0)\n       {\n \tpstate->lexptr += 3;\n-\tyylval.opcode = tokentab3[i].opcode;\n-\treturn tokentab3[i].token;\n+\tyylval.opcode = token.opcode;\n+\treturn token.token;\n       }\n \n   /* See if it is a special token of length 2.  */\n-  for (i = 0; i < sizeof tokentab2 / sizeof tokentab2[0]; i++)\n-    if (strncmp (tokstart, tokentab2[i].oper, 2) == 0)\n+  for (const auto &token : tokentab2)\n+    if (strncmp (tokstart, token.oper, 2) == 0)\n       {\n \tpstate->lexptr += 2;\n-\tyylval.opcode = tokentab2[i].opcode;\n-\treturn tokentab2[i].token;\n+\tyylval.opcode = token.opcode;\n+\treturn token.token;\n       }\n \n   switch (c = *tokstart)\n@@ -1274,13 +1273,13 @@ lex_one_token (struct parser_state *par_state)\n \n   /* Catch specific keywords.  */\n   std::string copy = copy_name (yylval.sval);\n-  for (i = 0; i < sizeof ident_tokens / sizeof ident_tokens[0]; i++)\n-    if (copy == ident_tokens[i].oper)\n+  for (const auto &token : ident_tokens)\n+    if (copy == token.oper)\n       {\n \t/* It is ok to always set this, even though we don't always\n \t   strictly need to.  */\n-\tyylval.opcode = ident_tokens[i].opcode;\n-\treturn ident_tokens[i].token;\n+\tyylval.opcode = token.opcode;\n+\treturn token.token;\n       }\n \n   if (*tokstart == '$')"
    },
    {
      "sha": "e0d576fe5332f9c5a1e145a30a0bbb83b5275739",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -1269,27 +1269,27 @@ yylex (void)\n \n   if (*pstate->lexptr == '.')\n     {\n-      for (int i = 0; i < ARRAY_SIZE (boolean_values); i++)\n+      for (const auto &candidate : boolean_values)\n \t{\n-\t  if (strncasecmp (tokstart, boolean_values[i].name,\n-\t\t\t   strlen (boolean_values[i].name)) == 0)\n+\t  if (strncasecmp (tokstart, candidate.name,\n+\t\t\t   strlen (candidate.name)) == 0)\n \t    {\n-\t      pstate->lexptr += strlen (boolean_values[i].name);\n-\t      yylval.lval = boolean_values[i].value;\n+\t      pstate->lexptr += strlen (candidate.name);\n+\t      yylval.lval = candidate.value;\n \t      return BOOLEAN_LITERAL;\n \t    }\n \t}\n     }\n \n   /* See if it is a Fortran operator.  */\n-  for (int i = 0; i < ARRAY_SIZE (fortran_operators); i++)\n-    if (strncasecmp (tokstart, fortran_operators[i].oper,\n-\t\t     strlen (fortran_operators[i].oper)) == 0)\n+  for (const auto &candidate : fortran_operators)\n+    if (strncasecmp (tokstart, candidate.oper,\n+\t\t     strlen (candidate.oper)) == 0)\n       {\n-\tgdb_assert (!fortran_operators[i].case_sensitive);\n-\tpstate->lexptr += strlen (fortran_operators[i].oper);\n-\tyylval.opcode = fortran_operators[i].opcode;\n-\treturn fortran_operators[i].token;\n+\tgdb_assert (!candidate.case_sensitive);\n+\tpstate->lexptr += strlen (candidate.oper);\n+\tyylval.opcode = candidate.opcode;\n+\treturn candidate.token;\n       }\n \n   switch (c = *tokstart)\n@@ -1452,15 +1452,15 @@ yylex (void)\n   \n   /* Catch specific keywords.  */\n \n-  for (int i = 0; i < ARRAY_SIZE (f77_keywords); i++)\n-    if (strlen (f77_keywords[i].oper) == namelen\n-\t&& ((!f77_keywords[i].case_sensitive\n-\t     && strncasecmp (tokstart, f77_keywords[i].oper, namelen) == 0)\n-\t    || (f77_keywords[i].case_sensitive\n-\t\t&& strncmp (tokstart, f77_keywords[i].oper, namelen) == 0)))\n+  for (const auto &keyword : f77_keywords)\n+    if (strlen (keyword.oper) == namelen\n+\t&& ((!keyword.case_sensitive\n+\t     && strncasecmp (tokstart, keyword.oper, namelen) == 0)\n+\t    || (keyword.case_sensitive\n+\t\t&& strncmp (tokstart, keyword.oper, namelen) == 0)))\n       {\n-\tyylval.opcode = f77_keywords[i].opcode;\n-\treturn f77_keywords[i].token;\n+\tyylval.opcode = keyword.opcode;\n+\treturn keyword.token;\n       }\n \n   yylval.sval.ptr = tokstart;\n@@ -1475,18 +1475,18 @@ yylex (void)\n   {\n     std::string tmp = copy_name (yylval.sval);\n     struct block_symbol result;\n-    enum domain_enum_tag lookup_domains[] =\n+    const enum domain_enum_tag lookup_domains[] =\n     {\n       STRUCT_DOMAIN,\n       VAR_DOMAIN,\n       MODULE_DOMAIN\n     };\n     int hextype;\n \n-    for (int i = 0; i < ARRAY_SIZE (lookup_domains); ++i)\n+    for (const auto &domain : lookup_domains)\n       {\n \tresult = lookup_symbol (tmp.c_str (), pstate->expression_context_block,\n-\t\t\t\tlookup_domains[i], NULL);\n+\t\t\t\tdomain, NULL);\n \tif (result.symbol && SYMBOL_CLASS (result.symbol) == LOC_TYPEDEF)\n \t  {\n \t    yylval.tsym.type = SYMBOL_TYPE (result.symbol);"
    },
    {
      "sha": "209e0a756b3ec3d805943ebd9b7cd56f746bc15c",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 12,
      "deletions": 13,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -1018,7 +1018,6 @@ lex_one_token (struct parser_state *par_state)\n {\n   int c;\n   int namelen;\n-  unsigned int i;\n   const char *tokstart;\n   int saw_structop = last_was_structop;\n \n@@ -1030,23 +1029,23 @@ lex_one_token (struct parser_state *par_state)\n \n   tokstart = par_state->lexptr;\n   /* See if it is a special token of length 3.  */\n-  for (i = 0; i < sizeof (tokentab3) / sizeof (tokentab3[0]); i++)\n-    if (strncmp (tokstart, tokentab3[i].oper, 3) == 0)\n+  for (const auto &token : tokentab3)\n+    if (strncmp (tokstart, token.oper, 3) == 0)\n       {\n \tpar_state->lexptr += 3;\n-\tyylval.opcode = tokentab3[i].opcode;\n-\treturn tokentab3[i].token;\n+\tyylval.opcode = token.opcode;\n+\treturn token.token;\n       }\n \n   /* See if it is a special token of length 2.  */\n-  for (i = 0; i < sizeof (tokentab2) / sizeof (tokentab2[0]); i++)\n-    if (strncmp (tokstart, tokentab2[i].oper, 2) == 0)\n+  for (const auto &token : tokentab2)\n+    if (strncmp (tokstart, token.oper, 2) == 0)\n       {\n \tpar_state->lexptr += 2;\n-\tyylval.opcode = tokentab2[i].opcode;\n+\tyylval.opcode = token.opcode;\n \t/* NOTE: -> doesn't exist in Go, so we don't need to watch for\n \t   setting last_was_structop here.  */\n-\treturn tokentab2[i].token;\n+\treturn token.token;\n       }\n \n   switch (c = *tokstart)\n@@ -1270,13 +1269,13 @@ lex_one_token (struct parser_state *par_state)\n \n   /* Catch specific keywords.  */\n   std::string copy = copy_name (yylval.sval);\n-  for (i = 0; i < sizeof (ident_tokens) / sizeof (ident_tokens[0]); i++)\n-    if (copy == ident_tokens[i].oper)\n+  for (const auto &token : ident_tokens)\n+    if (copy == token.oper)\n       {\n \t/* It is ok to always set this, even though we don't always\n \t   strictly need to.  */\n-\tyylval.opcode = ident_tokens[i].opcode;\n-\treturn ident_tokens[i].token;\n+\tyylval.opcode = token.opcode;\n+\treturn token.token;\n       }\n \n   if (*tokstart == '$')"
    },
    {
      "sha": "e9ebf1fa61415092f1d440a0ae7638ac7146081d",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -1107,28 +1107,28 @@ yylex (void)\n \n   /* See if it is a special token of length 3.  */\n   if (explen > 2)\n-    for (int i = 0; i < sizeof (tokentab3) / sizeof (tokentab3[0]); i++)\n-      if (strncasecmp (tokstart, tokentab3[i].oper, 3) == 0\n-\t  && (!isalpha (tokentab3[i].oper[0]) || explen == 3\n+    for (const auto &token : tokentab3)\n+      if (strncasecmp (tokstart, token.oper, 3) == 0\n+\t  && (!isalpha (token.oper[0]) || explen == 3\n \t      || (!isalpha (tokstart[3])\n \t\t  && !isdigit (tokstart[3]) && tokstart[3] != '_')))\n \t{\n \t  pstate->lexptr += 3;\n-\t  yylval.opcode = tokentab3[i].opcode;\n-\t  return tokentab3[i].token;\n+\t  yylval.opcode = token.opcode;\n+\t  return token.token;\n \t}\n \n   /* See if it is a special token of length 2.  */\n   if (explen > 1)\n-  for (int i = 0; i < sizeof (tokentab2) / sizeof (tokentab2[0]); i++)\n-      if (strncasecmp (tokstart, tokentab2[i].oper, 2) == 0\n-\t  && (!isalpha (tokentab2[i].oper[0]) || explen == 2\n+    for (const auto &token : tokentab2)\n+      if (strncasecmp (tokstart, token.oper, 2) == 0\n+\t  && (!isalpha (token.oper[0]) || explen == 2\n \t      || (!isalpha (tokstart[2])\n \t\t  && !isdigit (tokstart[2]) && tokstart[2] != '_')))\n \t{\n \t  pstate->lexptr += 2;\n-\t  yylval.opcode = tokentab2[i].opcode;\n-\t  return tokentab2[i].token;\n+\t  yylval.opcode = token.opcode;\n+\t  return token.token;\n \t}\n \n   switch (c = *tokstart)"
    },
    {
      "sha": "82ee382c2e3af0fb9272b8d3e35801fe2581d913",
      "filename": "gdb/rust-parse.c",
      "status": "modified",
      "additions": 13,
      "deletions": 19,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/rust-parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/rust-parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-parse.c?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -756,7 +756,6 @@ rust_parser::lex_identifier ()\n {\n   unsigned int length;\n   const struct token_info *token;\n-  int i;\n   int is_gdb_var = pstate->lexptr[0] == '$';\n \n   bool is_raw = false;\n@@ -787,12 +786,12 @@ rust_parser::lex_identifier ()\n   token = NULL;\n   if (!is_raw)\n     {\n-      for (i = 0; i < ARRAY_SIZE (identifier_tokens); ++i)\n+      for (const auto &candidate : identifier_tokens)\n \t{\n-\t  if (length == strlen (identifier_tokens[i].name)\n-\t      && strncmp (identifier_tokens[i].name, start, length) == 0)\n+\t  if (length == strlen (candidate.name)\n+\t      && strncmp (candidate.name, start, length) == 0)\n \t    {\n-\t      token = &identifier_tokens[i];\n+\t      token = &candidate;\n \t      break;\n \t    }\n \t}\n@@ -845,15 +844,14 @@ int\n rust_parser::lex_operator ()\n {\n   const struct token_info *token = NULL;\n-  int i;\n \n-  for (i = 0; i < ARRAY_SIZE (operator_tokens); ++i)\n+  for (const auto &candidate : operator_tokens)\n     {\n-      if (strncmp (operator_tokens[i].name, pstate->lexptr,\n-\t\t   strlen (operator_tokens[i].name)) == 0)\n+      if (strncmp (candidate.name, pstate->lexptr,\n+\t\t   strlen (candidate.name)) == 0)\n \t{\n-\t  pstate->lexptr += strlen (operator_tokens[i].name);\n-\t  token = &operator_tokens[i];\n+\t  pstate->lexptr += strlen (candidate.name);\n+\t  token = &candidate;\n \t  break;\n \t}\n     }\n@@ -2246,8 +2244,6 @@ rust_lex_test_push_back (rust_parser *parser)\n static void\n rust_lex_tests (void)\n {\n-  int i;\n-\n   /* Set up dummy \"parser\", so that rust_type works.  */\n   struct parser_state ps (language_def (language_rust), target_gdbarch (),\n \t\t\t  nullptr, 0, 0, nullptr, 0, nullptr, false);\n@@ -2342,13 +2338,11 @@ rust_lex_tests (void)\n   rust_lex_stringish_test (&parser, \"br####\\\"\\\\x73tring\\\"####\", \"\\\\x73tring\",\n \t\t\t   BYTESTRING);\n \n-  for (i = 0; i < ARRAY_SIZE (identifier_tokens); ++i)\n-    rust_lex_test_one (&parser, identifier_tokens[i].name,\n-\t\t       identifier_tokens[i].value);\n+  for (const auto &candidate : identifier_tokens)\n+    rust_lex_test_one (&parser, candidate.name, candidate.value);\n \n-  for (i = 0; i < ARRAY_SIZE (operator_tokens); ++i)\n-    rust_lex_test_one (&parser, operator_tokens[i].name,\n-\t\t       operator_tokens[i].value);\n+  for (const auto &candidate : operator_tokens)\n+    rust_lex_test_one (&parser, candidate.name, candidate.value);\n \n   rust_lex_test_completion (&parser);\n   rust_lex_test_push_back (&parser);"
    },
    {
      "sha": "d38628faf7c077a6888d40c166e1d376a6480b1b",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/696d6f4d5c1bc9b36d0402c2393efe62e49392d9/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=696d6f4d5c1bc9b36d0402c2393efe62e49392d9",
      "patch": "@@ -6375,13 +6375,12 @@ producer_is_realview (const char *producer)\n     \"ARM/Thumb C/C++ Compiler, RVCT\",\n     \"ARM C/C++ Compiler, RVCT\"\n   };\n-  int i;\n \n   if (producer == NULL)\n     return false;\n \n-  for (i = 0; i < ARRAY_SIZE (arm_idents); i++)\n-    if (startswith (producer, arm_idents[i]))\n+  for (const char *ident : arm_idents)\n+    if (startswith (producer, ident))\n       return true;\n \n   return false;"
    }
  ]
}