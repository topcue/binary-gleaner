{
  "sha": "96d3b80f5498c0aa40099f37f6384f2041df045f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTZkM2I4MGY1NDk4YzBhYTQwMDk5ZjM3ZjYzODRmMjA0MWRmMDQ1Zg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-19T02:42:52Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-19T02:42:52Z"
    },
    "message": "Check return status of memory alloc functions\n\nThis fixes a number of places that call a memory allocation function\nwithout checking for a NULL return before using.\n\n\t* mach-o.c (bfd_mach_o_flatten_sections): Return a bfd_boolean,\n\tFALSE if memory alloc fails.  Adjust calls.\n\t* som.c (som_prep_for_fixups): Likewise.\n\t* vms-alpha.c (alpha_vms_add_fixup_lp, alpha_vms_add_fixup_ca),\n\t(alpha_vms_add_fixup_qr, alpha_vms_add_fixup_lr),\n\t(alpha_vms_add_lw_reloc, alpha_vms_add_qw_reloc): Likewise.\n\t* som.c (som_build_and_write_symbol_table): Return via error_return\n\ton seek failure.\n\t* vms-alpha.c (VEC_APPEND): Adjust for vector_grow1 changes.\n\t(VEC_APPEND_EL): Delete.\n\t(vector_grow1): Return pointer to element.  Catch overflow.\n\tReturn NULL on memory allocation failure.\n\t(alpha_vms_add_fixup_lp): Replace VEC_APPEND_EL with VEC_APPEND.\n\t(alpha_vms_add_fixup_ca): Likewise.\n\t(alpha_vms_link_add_object_symbols): Check VEC_APPEND result\n\tbefore using.\n\t* elf.c (bfd_section_from_shdr): Check bfd_zalloc2 result.",
    "tree": {
      "sha": "af27c606e933b65af33c3fdd2e02cc6ef0dff8c3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/af27c606e933b65af33c3fdd2e02cc6ef0dff8c3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/96d3b80f5498c0aa40099f37f6384f2041df045f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/96d3b80f5498c0aa40099f37f6384f2041df045f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/96d3b80f5498c0aa40099f37f6384f2041df045f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/96d3b80f5498c0aa40099f37f6384f2041df045f/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "986f078366b193ed9f5bd02af965f3af958ba859",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/986f078366b193ed9f5bd02af965f3af958ba859",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/986f078366b193ed9f5bd02af965f3af958ba859"
    }
  ],
  "stats": {
    "total": 166,
    "additions": 112,
    "deletions": 54
  },
  "files": [
    {
      "sha": "c7335ab3c3a75eed84f1603efa5fab631c115ed9",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=96d3b80f5498c0aa40099f37f6384f2041df045f",
      "patch": "@@ -1,3 +1,23 @@\n+2020-02-19  Alan Modra  <amodra@gmail.com>\n+\n+\t* mach-o.c (bfd_mach_o_flatten_sections): Return a bfd_boolean,\n+\tFALSE if memory alloc fails.  Adjust calls.\n+\t* som.c (som_prep_for_fixups): Likewise.\n+\t* vms-alpha.c (alpha_vms_add_fixup_lp, alpha_vms_add_fixup_ca),\n+\t(alpha_vms_add_fixup_qr, alpha_vms_add_fixup_lr),\n+\t(alpha_vms_add_lw_reloc, alpha_vms_add_qw_reloc): Likewise.\n+\t* som.c (som_build_and_write_symbol_table): Return via error_return\n+\ton seek failure.\n+\t* vms-alpha.c (VEC_APPEND): Adjust for vector_grow1 changes.\n+\t(VEC_APPEND_EL): Delete.\n+\t(vector_grow1): Return pointer to element.  Catch overflow.\n+\tReturn NULL on memory allocation failure.\n+\t(alpha_vms_add_fixup_lp): Replace VEC_APPEND_EL with VEC_APPEND.\n+\t(alpha_vms_add_fixup_ca): Likewise.\n+\t(alpha_vms_link_add_object_symbols): Check VEC_APPEND result\n+\tbefore using.\n+\t* elf.c (bfd_section_from_shdr): Check bfd_zalloc2 result.\n+\n 2020-02-19  Alan Modra  <amodra@gmail.com>\n \n \t* aix386-core.c (aix386_core_file_p): Use size_t for \"amt\"."
    },
    {
      "sha": "31c89c9431afa1bd97f701bd7516a245fa8f9db0",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=96d3b80f5498c0aa40099f37f6384f2041df045f",
      "patch": "@@ -2071,6 +2071,8 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)\n \t{\n \t  sections_being_created = (bfd_boolean *)\n \t    bfd_zalloc2 (abfd, elf_numsections (abfd), sizeof (bfd_boolean));\n+\t  if (sections_being_created == NULL)\n+\t    return FALSE;\n \t  sections_being_created_abfd = abfd;\n \t}\n       if (sections_being_created [shindex])"
    },
    {
      "sha": "a18c68c6d89d2814c7edd4d464f8dcced124b971",
      "filename": "bfd/mach-o.c",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/mach-o.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/mach-o.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o.c?ref=96d3b80f5498c0aa40099f37f6384f2041df045f",
      "patch": "@@ -4999,7 +4999,7 @@ bfd_mach_o_read_command (bfd *abfd, bfd_mach_o_load_command *command)\n   return TRUE;\n }\n \n-static void\n+static bfd_boolean\n bfd_mach_o_flatten_sections (bfd *abfd)\n {\n   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);\n@@ -5023,6 +5023,8 @@ bfd_mach_o_flatten_sections (bfd *abfd)\n   /* Allocate sections array.  */\n   mdata->sections = bfd_alloc2 (abfd,\n \t\t\t\tmdata->nsects, sizeof (bfd_mach_o_section *));\n+  if (mdata->sections == NULL && mdata->nsects != 0)\n+    return FALSE;\n \n   /* Fill the array.  */\n   csect = 0;\n@@ -5041,6 +5043,7 @@ bfd_mach_o_flatten_sections (bfd *abfd)\n \t    mdata->sections[csect++] = sec;\n \t}\n     }\n+  return TRUE;\n }\n \n static bfd_boolean\n@@ -5220,7 +5223,8 @@ bfd_mach_o_scan (bfd *abfd,\n     }\n \n   /* Sections should be flatten before scanning start address.  */\n-  bfd_mach_o_flatten_sections (abfd);\n+  if (!bfd_mach_o_flatten_sections (abfd))\n+    return FALSE;\n   if (!bfd_mach_o_scan_start_address (abfd))\n     return FALSE;\n "
    },
    {
      "sha": "9c29230ece1fc89674d58425f5ca7e2522695799",
      "filename": "bfd/som.c",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/som.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/som.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/som.c?ref=96d3b80f5498c0aa40099f37f6384f2041df045f",
      "patch": "@@ -2798,7 +2798,7 @@ compare_subspaces (const void *arg1, const void *arg2)\n \n /* Perform various work in preparation for emitting the fixup stream.  */\n \n-static void\n+static bfd_boolean\n som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)\n {\n   unsigned long i;\n@@ -2876,6 +2876,8 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)\n   /* Sort a copy of the symbol table, rather than the canonical\n      output symbol table.  */\n   sorted_syms = bfd_zalloc2 (abfd, num_syms, sizeof (asymbol *));\n+  if (sorted_syms == NULL)\n+    return FALSE;\n   memcpy (sorted_syms, syms, num_syms * sizeof (asymbol *));\n   qsort (sorted_syms, num_syms, sizeof (asymbol *), compare_syms);\n   obj_som_sorted_syms (abfd) = sorted_syms;\n@@ -2891,6 +2893,7 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)\n       else\n \tsom_symbol_data (sorted_syms[i])->index = i;\n     }\n+  return TRUE;\n }\n \n static bfd_boolean\n@@ -4009,9 +4012,10 @@ som_finish_writing (bfd *abfd)\n   current_offset += strings_size;\n \n   /* Do prep work before handling fixups.  */\n-  som_prep_for_fixups (abfd,\n-\t\t       bfd_get_outsymbols (abfd),\n-\t\t       bfd_get_symcount (abfd));\n+  if (!som_prep_for_fixups (abfd,\n+\t\t\t    bfd_get_outsymbols (abfd),\n+\t\t\t    bfd_get_symcount (abfd)))\n+    return FALSE;\n \n   /* At the end of the file is the fixup stream which starts on a\n      word boundary.  */\n@@ -4500,7 +4504,7 @@ som_build_and_write_symbol_table (bfd *abfd)\n   /* Everything is ready, seek to the right location and\n      scribble out the symbol table.  */\n   if (bfd_seek (abfd, symtab_location, SEEK_SET) != 0)\n-    return FALSE;\n+    goto error_return;\n \n   symtab_size = num_syms;\n   symtab_size *= sizeof (struct som_external_symbol_dictionary_record);"
    },
    {
      "sha": "ac01c4dac8a69e008897d72fbf95fbdda5286397",
      "filename": "bfd/vms-alpha.c",
      "status": "modified",
      "additions": 75,
      "deletions": 47,
      "changes": 122,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/vms-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/96d3b80f5498c0aa40099f37f6384f2041df045f/bfd/vms-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-alpha.c?ref=96d3b80f5498c0aa40099f37f6384f2041df045f",
      "patch": "@@ -368,14 +368,16 @@ struct vms_private_data_struct *bfd_vms_get_data (bfd *);\n \n static int vms_get_remaining_object_record (bfd *, unsigned int);\n static bfd_boolean _bfd_vms_slurp_object_records (bfd * abfd);\n-static void alpha_vms_add_fixup_lp (struct bfd_link_info *, bfd *, bfd *);\n-static void alpha_vms_add_fixup_ca (struct bfd_link_info *, bfd *, bfd *);\n-static void alpha_vms_add_fixup_qr (struct bfd_link_info *, bfd *, bfd *,\n-\t\t\t\t    bfd_vma);\n-static void alpha_vms_add_fixup_lr (struct bfd_link_info *, unsigned int,\n-\t\t\t\t    bfd_vma);\n-static void alpha_vms_add_lw_reloc (struct bfd_link_info *);\n-static void alpha_vms_add_qw_reloc (struct bfd_link_info *);\n+static bfd_boolean alpha_vms_add_fixup_lp (struct bfd_link_info *,\n+\t\t\t\t\t   bfd *, bfd *);\n+static bfd_boolean alpha_vms_add_fixup_ca (struct bfd_link_info *,\n+\t\t\t\t\t   bfd *, bfd *);\n+static bfd_boolean alpha_vms_add_fixup_qr (struct bfd_link_info *,\n+\t\t\t\t\t   bfd *, bfd *, bfd_vma);\n+static bfd_boolean alpha_vms_add_fixup_lr (struct bfd_link_info *,\n+\t\t\t\t\t   unsigned int, bfd_vma);\n+static bfd_boolean alpha_vms_add_lw_reloc (struct bfd_link_info *);\n+static bfd_boolean alpha_vms_add_qw_reloc (struct bfd_link_info *);\n \n struct vector_type\n {\n@@ -401,17 +403,12 @@ struct vector_type\n \n /* Be sure there is room for a new element.  */\n \n-static void vector_grow1 (struct vector_type *vec, size_t elsz);\n+static void *vector_grow1 (struct vector_type *vec, size_t elsz);\n \n /* Allocate room for a new element and return its address.  */\n \n #define VEC_APPEND(VEC, TYPE)\t\t\t\t\t\\\n-  (vector_grow1 (&VEC, sizeof (TYPE)), &VEC_EL(VEC, TYPE, (VEC).nbr_el++))\n-\n-/* Append an element.  */\n-\n-#define VEC_APPEND_EL(VEC, TYPE, EL)\t\t\\\n-  (*(VEC_APPEND (VEC, TYPE)) = EL)\n+  ((TYPE *) vector_grow1 (&VEC, sizeof (TYPE)))\n \n struct alpha_vms_vma_ref\n {\n@@ -2004,14 +2001,16 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t    }\n \t  else if (rel1 & RELC_SHR_BASE)\n \t    {\n-\t      alpha_vms_add_fixup_lr (info, rel1 & RELC_MASK, op1);\n+\t      if (!alpha_vms_add_fixup_lr (info, rel1 & RELC_MASK, op1))\n+\t\treturn FALSE;\n \t      rel1 = RELC_NONE;\n \t    }\n \t  if (rel1 != RELC_NONE)\n \t    {\n \t      if (rel1 != RELC_REL)\n \t\tabort ();\n-\t      alpha_vms_add_lw_reloc (info);\n+\t      if (!alpha_vms_add_lw_reloc (info))\n+\t\treturn FALSE;\n \t    }\n \t  image_write_l (abfd, op1);\n \t  break;\n@@ -2032,7 +2031,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t    {\n \t      if (rel1 != RELC_REL)\n \t\tabort ();\n-\t      alpha_vms_add_qw_reloc (info);\n+\t      if (!alpha_vms_add_qw_reloc (info))\n+\t\treturn FALSE;\n \t    }\n \t  image_write_q (abfd, op1);\n \t  break;\n@@ -2064,15 +2064,17 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t    {\n \t      if (h->sym->typ == EGSD__C_SYMG)\n \t\t{\n-\t\t  alpha_vms_add_fixup_qr\n-\t\t    (info, abfd, h->sym->owner, h->sym->symbol_vector);\n+\t\t  if (!alpha_vms_add_fixup_qr (info, abfd, h->sym->owner,\n+\t\t\t\t\t       h->sym->symbol_vector))\n+\t\t    return FALSE;\n \t\t  op1 = 0;\n \t\t}\n \t      else\n \t\t{\n \t\t  op1 = alpha_vms_get_sym_value (h->sym->section,\n \t\t\t\t\t\t h->sym->value);\n-\t\t  alpha_vms_add_qw_reloc (info);\n+\t\t  if (!alpha_vms_add_qw_reloc (info))\n+\t\t    return FALSE;\n \t\t}\n \t    }\n \t  image_write_q (abfd, op1);\n@@ -2089,14 +2091,16 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t\t  /* That's really a procedure.  */\n \t\t  if (h->sym->typ == EGSD__C_SYMG)\n \t\t    {\n-\t\t      alpha_vms_add_fixup_ca (info, abfd, h->sym->owner);\n+\t\t      if (!alpha_vms_add_fixup_ca (info, abfd, h->sym->owner))\n+\t\t\treturn FALSE;\n \t\t      op1 = h->sym->symbol_vector;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      op1 = alpha_vms_get_sym_value (h->sym->code_section,\n \t\t\t\t\t\t     h->sym->code_value);\n-\t\t      alpha_vms_add_qw_reloc (info);\n+\t\t      if (!alpha_vms_add_qw_reloc (info))\n+\t\t\treturn FALSE;\n \t\t    }\n \t\t}\n \t      else\n@@ -2201,7 +2205,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t    {\n \t      if (h->sym->typ == EGSD__C_SYMG)\n \t\t{\n-\t\t  alpha_vms_add_fixup_lp (info, abfd, h->sym->owner);\n+\t\t  if (!alpha_vms_add_fixup_lp (info, abfd, h->sym->owner))\n+\t\t    return FALSE;\n \t\t  op1 = h->sym->symbol_vector;\n \t\t  op2 = 0;\n \t\t}\n@@ -2950,22 +2955,30 @@ _bfd_vms_write_eeom (bfd *abfd)\n   return TRUE;\n }\n \n-static void\n+static void *\n vector_grow1 (struct vector_type *vec, size_t elsz)\n {\n-  if (vec->nbr_el + 1 < vec->max_el)\n-    return;\n-\n-  if (vec->max_el == 0)\n+  if (vec->nbr_el >= vec->max_el)\n     {\n-      vec->max_el = 16;\n-      vec->els = bfd_malloc2 (vec->max_el, elsz);\n-    }\n-  else\n-    {\n-      vec->max_el *= 2;\n-      vec->els = bfd_realloc2 (vec->els, vec->max_el, elsz);\n+      if (vec->max_el == 0)\n+\t{\n+\t  vec->max_el = 16;\n+\t  vec->els = bfd_malloc2 (vec->max_el, elsz);\n+\t}\n+      else\n+\t{\n+\t  if (vec->max_el > -1u / 2)\n+\t    {\n+\t      bfd_set_error (bfd_error_file_too_big);\n+\t      return NULL;\n+\t    }\n+\t  vec->max_el *= 2;\n+\t  vec->els = bfd_realloc2 (vec->els, vec->max_el, elsz);\n+\t}\n     }\n+  if (vec->els == NULL)\n+    return NULL;\n+  return (char *) vec->els + elsz * vec->nbr_el++;\n }\n \n /* Bump ABFD file position to next block.  */\n@@ -8330,41 +8343,49 @@ alpha_vms_sizeof_headers (bfd *abfd ATTRIBUTE_UNUSED,\n \n /* Add a linkage pair fixup at address SECT + OFFSET to SHLIB. */\n \n-static void\n+static bfd_boolean\n alpha_vms_add_fixup_lp (struct bfd_link_info *info, bfd *src, bfd *shlib)\n {\n   struct alpha_vms_shlib_el *sl;\n   asection *sect = PRIV2 (src, image_section);\n   file_ptr offset = PRIV2 (src, image_offset);\n+  bfd_vma *p;\n \n   sl = &VEC_EL (alpha_vms_link_hash (info)->shrlibs,\n \t\tstruct alpha_vms_shlib_el, PRIV2 (shlib, shr_index));\n   sl->has_fixups = TRUE;\n-  VEC_APPEND_EL (sl->lp, bfd_vma,\n-\t\t sect->output_section->vma + sect->output_offset + offset);\n+  p = VEC_APPEND (sl->lp, bfd_vma);\n+  if (p == NULL)\n+    return FALSE;\n+  *p = sect->output_section->vma + sect->output_offset + offset;\n   sect->output_section->flags |= SEC_RELOC;\n+  return TRUE;\n }\n \n /* Add a code address fixup at address SECT + OFFSET to SHLIB. */\n \n-static void\n+static bfd_boolean\n alpha_vms_add_fixup_ca (struct bfd_link_info *info, bfd *src, bfd *shlib)\n {\n   struct alpha_vms_shlib_el *sl;\n   asection *sect = PRIV2 (src, image_section);\n   file_ptr offset = PRIV2 (src, image_offset);\n+  bfd_vma *p;\n \n   sl = &VEC_EL (alpha_vms_link_hash (info)->shrlibs,\n \t\tstruct alpha_vms_shlib_el, PRIV2 (shlib, shr_index));\n   sl->has_fixups = TRUE;\n-  VEC_APPEND_EL (sl->ca, bfd_vma,\n-\t\t sect->output_section->vma + sect->output_offset + offset);\n+  p = VEC_APPEND (sl->ca, bfd_vma);\n+  if (p == NULL)\n+    return FALSE;\n+  *p = sect->output_section->vma + sect->output_offset + offset;\n   sect->output_section->flags |= SEC_RELOC;\n+  return TRUE;\n }\n \n /* Add a quad word relocation fixup at address SECT + OFFSET to SHLIB. */\n \n-static void\n+static bfd_boolean\n alpha_vms_add_fixup_qr (struct bfd_link_info *info, bfd *src,\n \t\t\tbfd *shlib, bfd_vma vec)\n {\n@@ -8377,30 +8398,35 @@ alpha_vms_add_fixup_qr (struct bfd_link_info *info, bfd *src,\n \t\tstruct alpha_vms_shlib_el, PRIV2 (shlib, shr_index));\n   sl->has_fixups = TRUE;\n   r = VEC_APPEND (sl->qr, struct alpha_vms_vma_ref);\n+  if (r == NULL)\n+    return FALSE;\n   r->vma = sect->output_section->vma + sect->output_offset + offset;\n   r->ref = vec;\n   sect->output_section->flags |= SEC_RELOC;\n+  return TRUE;\n }\n \n-static void\n+static bfd_boolean\n alpha_vms_add_fixup_lr (struct bfd_link_info *info ATTRIBUTE_UNUSED,\n \t\t\tunsigned int shr ATTRIBUTE_UNUSED,\n \t\t\tbfd_vma vec ATTRIBUTE_UNUSED)\n {\n   /* Not yet supported.  */\n-  abort ();\n+  return FALSE;\n }\n \n /* Add relocation.  FIXME: Not yet emitted.  */\n \n-static void\n+static bfd_boolean\n alpha_vms_add_lw_reloc (struct bfd_link_info *info ATTRIBUTE_UNUSED)\n {\n+  return FALSE;\n }\n \n-static void\n+static bfd_boolean\n alpha_vms_add_qw_reloc (struct bfd_link_info *info ATTRIBUTE_UNUSED)\n {\n+  return FALSE;\n }\n \n static struct bfd_hash_entry *\n@@ -8527,6 +8553,8 @@ alpha_vms_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n \n       shlib = VEC_APPEND (alpha_vms_link_hash (info)->shrlibs,\n \t\t\t  struct alpha_vms_shlib_el);\n+      if (shlib == NULL)\n+\treturn FALSE;\n       shlib->abfd = abfd;\n       VEC_INIT (shlib->ca);\n       VEC_INIT (shlib->lp);"
    }
  ]
}