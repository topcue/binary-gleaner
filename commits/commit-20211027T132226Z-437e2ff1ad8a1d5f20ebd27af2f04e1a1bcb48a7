{
  "sha": "437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7",
  "node_id": "C_kwDOANOeidoAKDQzN2UyZmYxYWQ4YTFkNWYyMGViZDI3YWYyZjA0ZTFhMWJjYjQ4YTc",
  "commit": {
    "author": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-10-27T10:54:41Z"
    },
    "committer": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-10-27T13:22:26Z"
    },
    "message": "RISC-V: Tidy riscv assembler and disassembler.\n\nTidy the gas/config/tc-riscv.c and opcodes/riscv-dis.c, to prepare for\nmoving the released extensions (including released vendor extensions)\nfrom integration branch back to mainline.\n\n* Added parts of missing comments.\n\n* Updated md_show_usage.\n\n* For validate_riscv_insn, riscv_ip and print_insn_args, unify the\n  following pointer names,\n  - oparg: pointed to the parsed operand defined in the riscv_opcodes.\n  - asarg: pointed to the parsed operand from assembly.\n  - opargStart: recorded the parsed operand name from riscv_opcodes.\n  - asargStart: recorded the parsed operand name from assembly.\n\ngas/\n\t* config/tc-riscv.c: Added parts of missind comments and updated\n\tthe md_show_usage.\n\t(riscv_multi_subset_supports): Tidy codes.\n\t(validate_riscv_insn): Unify the pointer names, oparg, asarg,\n\topargStart and asargStart, to prepare for moving the released\n\textensions from integration branch back to mainline.\n\t(riscv_ip): Likewise.\n\t(macro_build): Added fmtStart, also used to prepare for moving\n\treleased extensions.\n\t(md_show_usage): Added missing descriptions for new options.\nopcodes/\n\t* riscv-dis.c (print_insn_args): Unify the pointer names,\n\toparg and opargStart, to prepare for moving the released\n\textensions from integration branch back to mainline.",
    "tree": {
      "sha": "1927f533f9650a3bd1662aa4d2c4c5d781339f40",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1927f533f9650a3bd1662aa4d2c4c5d781339f40"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "2b677209fe127b44c1920779a6fca2598c66c1d3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b677209fe127b44c1920779a6fca2598c66c1d3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2b677209fe127b44c1920779a6fca2598c66c1d3"
    }
  ],
  "stats": {
    "total": 610,
    "additions": 314,
    "deletions": 296
  },
  "files": [
    {
      "sha": "eb626f8e1d58a56ed7ca4ea0f9de367cf1799ed3",
      "filename": "gas/config/tc-riscv.c",
      "status": "modified",
      "additions": 304,
      "deletions": 288,
      "changes": 592,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7/gas/config/tc-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7/gas/config/tc-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-riscv.c?ref=437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7",
      "patch": "@@ -219,6 +219,9 @@ static struct riscv_set_options riscv_opts =\n   0, /* csr_check */\n };\n \n+/* Enable or disable the rvc flags for riscv_opts.  Turn on the rvc flag\n+   for elf_flags once we have enabled c extension.  */\n+\n static void\n riscv_set_rvc (bool rvc_value)\n {\n@@ -228,14 +231,23 @@ riscv_set_rvc (bool rvc_value)\n   riscv_opts.rvc = rvc_value;\n }\n \n+/* Enable or disable the rve flags for riscv_opts.  */\n+\n static void\n riscv_set_rve (bool rve_value)\n {\n   riscv_opts.rve = rve_value;\n }\n \n+/* This linked list records all enabled extensions, which are parsed from\n+   the architecture string.  The architecture string can be set by the\n+   -march option, the elf architecture attributes, and the --with-arch\n+   configure option.  */\n static riscv_subset_list_t riscv_subsets;\n \n+/* Check if the FEATURE subset is supported or not in the subset list.\n+   Return true if it is supported; Otherwise, return false.  */\n+\n static bool\n riscv_subset_supports (const char *feature)\n {\n@@ -247,45 +259,48 @@ riscv_subset_supports (const char *feature)\n   return riscv_lookup_subset (&riscv_subsets, feature, &subset);\n }\n \n+/* Each instuction is belonged to an instruction class INSN_CLASS_*.\n+   Call riscv_subset_supports to make sure if the instuction is valid.  */\n+\n static bool\n riscv_multi_subset_supports (enum riscv_insn_class insn_class)\n {\n   switch (insn_class)\n     {\n-    case INSN_CLASS_I: return riscv_subset_supports (\"i\");\n-    case INSN_CLASS_C: return riscv_subset_supports (\"c\");\n-    case INSN_CLASS_A: return riscv_subset_supports (\"a\");\n-    case INSN_CLASS_M: return riscv_subset_supports (\"m\");\n-    case INSN_CLASS_F: return riscv_subset_supports (\"f\");\n-    case INSN_CLASS_D: return riscv_subset_supports (\"d\");\n-    case INSN_CLASS_Q: return riscv_subset_supports (\"q\");\n-\n-    case INSN_CLASS_F_AND_C:\n-      return (riscv_subset_supports (\"f\")\n-\t      && riscv_subset_supports (\"c\"));\n-    case INSN_CLASS_D_AND_C:\n-      return (riscv_subset_supports (\"d\")\n-\t      && riscv_subset_supports (\"c\"));\n-\n+    case INSN_CLASS_I:\n+      return riscv_subset_supports (\"i\");\n     case INSN_CLASS_ZICSR:\n       return riscv_subset_supports (\"zicsr\");\n     case INSN_CLASS_ZIFENCEI:\n       return riscv_subset_supports (\"zifencei\");\n     case INSN_CLASS_ZIHINTPAUSE:\n       return riscv_subset_supports (\"zihintpause\");\n-\n-    case INSN_CLASS_ZBB:\n-      return riscv_subset_supports (\"zbb\");\n-\n+    case INSN_CLASS_M:\n+      return riscv_subset_supports (\"m\");\n+    case INSN_CLASS_A:\n+      return riscv_subset_supports (\"a\");\n+    case INSN_CLASS_F:\n+      return riscv_subset_supports (\"f\");\n+    case INSN_CLASS_D:\n+      return riscv_subset_supports (\"d\");\n+    case INSN_CLASS_Q:\n+      return riscv_subset_supports (\"q\");\n+    case INSN_CLASS_C:\n+      return riscv_subset_supports (\"c\");\n+    case INSN_CLASS_F_AND_C:\n+      return (riscv_subset_supports (\"f\")\n+\t      && riscv_subset_supports (\"c\"));\n+    case INSN_CLASS_D_AND_C:\n+      return (riscv_subset_supports (\"d\")\n+\t      && riscv_subset_supports (\"c\"));\n     case INSN_CLASS_ZBA:\n       return riscv_subset_supports (\"zba\");\n-\n+    case INSN_CLASS_ZBB:\n+      return riscv_subset_supports (\"zbb\");\n     case INSN_CLASS_ZBC:\n       return riscv_subset_supports (\"zbc\");\n-\n     case INSN_CLASS_ZBS:\n       return riscv_subset_supports (\"zbs\");\n-\n     default:\n       as_fatal (\"internal: unreachable\");\n       return false;\n@@ -326,6 +341,8 @@ riscv_set_arch (const char *s)\n /* Indicate -mabi option is explictly set.  */\n static bool explicit_mabi = false;\n \n+/* Set the abi information.  */\n+\n static void\n riscv_set_abi (unsigned new_xlen, enum float_abi new_float_abi, bool rve)\n {\n@@ -424,6 +441,8 @@ static bool explicit_attr = false;\n /* Indicate CSR or priv instructions are explicitly used.  */\n static bool explicit_priv_attr = false;\n \n+static char *expr_end;\n+\n /* Macros for encoding relaxation state for RVC branches and far jumps.  */\n #define RELAX_BRANCH_ENCODE(uncond, rvc, length)\t\\\n   ((relax_substateT) \t\t\t\t\t\\\n@@ -455,8 +474,6 @@ static bool explicit_priv_attr = false;\n #define OPCODE_MATCHES(OPCODE, OP) \\\n   (((OPCODE) & MASK_##OP) == MATCH_##OP)\n \n-static char *expr_end;\n-\n /* Create a new mapping symbol for the transition to STATE.  */\n \n static void\n@@ -825,6 +842,7 @@ opcode_name_lookup (char **s)\n   return o;\n }\n \n+/* All RISC-V registers belong to one of these classes.  */\n enum reg_class\n {\n   RCLASS_GPR,\n@@ -1049,15 +1067,16 @@ arg_lookup (char **s, const char *const *array, size_t size, unsigned *regnop)\n   return false;\n }\n \n+#define USE_BITS(mask,shift) (used_bits |= ((insn_t)(mask) << (shift)))\n+\n /* For consistency checking, verify that all bits are specified either\n    by the match/mask part of the instruction definition, or by the\n    operand list. The `length` could be 0, 4 or 8, 0 for auto detection.  */\n \n static bool\n validate_riscv_insn (const struct riscv_opcode *opc, int length)\n {\n-  const char *p = opc->args;\n-  char c;\n+  const char *oparg, *opargStart;\n   insn_t used_bits = opc->mask;\n   int insn_width;\n   insn_t required_bits;\n@@ -1076,131 +1095,122 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n       return false;\n     }\n \n-#define USE_BITS(mask,shift)\t(used_bits |= ((insn_t)(mask) << (shift)))\n-  while (*p)\n-    switch (c = *p++)\n-      {\n-      case 'C': /* RVC */\n-\tswitch (c = *p++)\n-\t  {\n-\t  case 'U': break; /* CRS1, constrained to equal RD.  */\n-\t  case 'c': break; /* CRS1, constrained to equal sp.  */\n-\t  case 'T': /* CRS2, floating point.  */\n-\t  case 'V': USE_BITS (OP_MASK_CRS2, OP_SH_CRS2); break;\n-\t  case 'S': /* CRS1S, floating point.  */\n-\t  case 's': USE_BITS (OP_MASK_CRS1S, OP_SH_CRS1S); break;\n-\t  case 'w': break; /* CRS1S, constrained to equal RD.  */\n-\t  case 'D': /* CRS2S, floating point.  */\n-\t  case 't': USE_BITS (OP_MASK_CRS2S, OP_SH_CRS2S); break;\n-\t  case 'x': break; /* CRS2S, constrained to equal RD.  */\n-\t  case 'z': break; /* CRS2S, constrained to be x0.  */\n-\t  case '>': /* CITYPE immediate, compressed shift.  */\n-\t  case 'u': /* CITYPE immediate, compressed lui.  */\n-\t  case 'v': /* CITYPE immediate, li to compressed lui.  */\n-\t  case 'o': /* CITYPE immediate, allow zero.  */\n-\t  case 'j': used_bits |= ENCODE_CITYPE_IMM (-1U); break;\n-\t  case 'L': used_bits |= ENCODE_CITYPE_ADDI16SP_IMM (-1U); break;\n-\t  case 'm': used_bits |= ENCODE_CITYPE_LWSP_IMM (-1U); break;\n-\t  case 'n': used_bits |= ENCODE_CITYPE_LDSP_IMM (-1U); break;\n-\t  case '6': used_bits |= ENCODE_CSSTYPE_IMM (-1U); break;\n-\t  case 'M': used_bits |= ENCODE_CSSTYPE_SWSP_IMM (-1U); break;\n-\t  case 'N': used_bits |= ENCODE_CSSTYPE_SDSP_IMM (-1U); break;\n-\t  case '8': used_bits |= ENCODE_CIWTYPE_IMM (-1U); break;\n-\t  case 'K': used_bits |= ENCODE_CIWTYPE_ADDI4SPN_IMM (-1U); break;\n-\t  /* CLTYPE and CSTYPE have the same immediate encoding.  */\n-\t  case '5': used_bits |= ENCODE_CLTYPE_IMM (-1U); break;\n-\t  case 'k': used_bits |= ENCODE_CLTYPE_LW_IMM (-1U); break;\n-\t  case 'l': used_bits |= ENCODE_CLTYPE_LD_IMM (-1U); break;\n-\t  case 'p': used_bits |= ENCODE_CBTYPE_IMM (-1U); break;\n-\t  case 'a': used_bits |= ENCODE_CJTYPE_IMM (-1U); break;\n-\t  case 'F': /* Compressed funct for .insn directive.  */\n-\t    switch (c = *p++)\n-\t      {\n-\t\tcase '6': USE_BITS (OP_MASK_CFUNCT6, OP_SH_CFUNCT6); break;\n-\t\tcase '4': USE_BITS (OP_MASK_CFUNCT4, OP_SH_CFUNCT4); break;\n-\t\tcase '3': USE_BITS (OP_MASK_CFUNCT3, OP_SH_CFUNCT3); break;\n-\t\tcase '2': USE_BITS (OP_MASK_CFUNCT2, OP_SH_CFUNCT2); break;\n-\t\tdefault:\n-\t\t  as_bad (_(\"internal: bad RISC-V opcode \"\n-\t\t\t    \"(unknown operand type `CF%c'): %s %s\"),\n-\t\t\t  c, opc->name, opc->args);\n-\t\t  return false;\n-\t      }\n-\t    break;\n-\t  default:\n-\t    as_bad (_(\"internal: bad RISC-V opcode \"\n-\t\t      \"(unknown operand type `C%c'): %s %s\"),\n-\t\t    c, opc->name, opc->args);\n-\t    return false;\n-\t  }\n-\tbreak;\n-      case ',': break;\n-      case '(': break;\n-      case ')': break;\n-      case '<': USE_BITS (OP_MASK_SHAMTW, OP_SH_SHAMTW); break;\n-      case '>': USE_BITS (OP_MASK_SHAMT, OP_SH_SHAMT); break;\n-      case 'A': break; /* Macro operand, must be symbol.  */\n-      case 'B': break; /* Macro operand, must be symbol or constant.  */\n-      case 'I': break; /* Macro operand, must be constant.  */\n-      case 'D': /* RD, floating point.  */\n-      case 'd': USE_BITS (OP_MASK_RD, OP_SH_RD); break;\n-      case 'Z': /* RS1, CSR number.  */\n-      case 'S': /* RS1, floating point.  */\n-      case 's': USE_BITS (OP_MASK_RS1, OP_SH_RS1); break;\n-      case 'U': /* RS1 and RS2 are the same, floating point.  */\n-\tUSE_BITS (OP_MASK_RS1, OP_SH_RS1);\n-\t/* Fall through.  */\n-      case 'T': /* RS2, floating point.  */\n-      case 't': USE_BITS (OP_MASK_RS2, OP_SH_RS2); break;\n-      case 'R': /* RS3, floating point.  */\n-      case 'r': USE_BITS (OP_MASK_RS3, OP_SH_RS3); break;\n-      case 'm': USE_BITS (OP_MASK_RM, OP_SH_RM); break;\n-      case 'E': USE_BITS (OP_MASK_CSR, OP_SH_CSR); break;\n-      case 'P': USE_BITS (OP_MASK_PRED, OP_SH_PRED); break;\n-      case 'Q': USE_BITS (OP_MASK_SUCC, OP_SH_SUCC); break;\n-      case 'o': /* ITYPE immediate, load displacement.  */\n-      case 'j': used_bits |= ENCODE_ITYPE_IMM (-1U); break;\n-      case 'a': used_bits |= ENCODE_JTYPE_IMM (-1U); break;\n-      case 'p': used_bits |= ENCODE_BTYPE_IMM (-1U); break;\n-      case 'q': used_bits |= ENCODE_STYPE_IMM (-1U); break;\n-      case 'u': used_bits |= ENCODE_UTYPE_IMM (-1U); break;\n-      case 'z': break; /* Zero immediate.  */\n-      case '[': break; /* Unused operand.  */\n-      case ']': break; /* Unused operand.  */\n-      case '0': break; /* AMO displacement, must to zero.  */\n-      case '1': break; /* Relaxation operand.  */\n-      case 'F': /* Funct for .insn directive.  */\n-\tswitch (c = *p++)\n-\t  {\n-\t    case '7': USE_BITS (OP_MASK_FUNCT7, OP_SH_FUNCT7); break;\n-\t    case '3': USE_BITS (OP_MASK_FUNCT3, OP_SH_FUNCT3); break;\n-\t    case '2': USE_BITS (OP_MASK_FUNCT2, OP_SH_FUNCT2); break;\n-\t    default:\n-\t      as_bad (_(\"internal: bad RISC-V opcode \"\n-\t\t\t\"(unknown operand type `F%c'): %s %s\"),\n-\t\t      c, opc->name, opc->args);\n-\t    return false;\n-\t  }\n-\tbreak;\n-      case 'O': /* Opcode for .insn directive.  */\n-\tswitch (c = *p++)\n-\t  {\n-\t    case '4': USE_BITS (OP_MASK_OP, OP_SH_OP); break;\n-\t    case '2': USE_BITS (OP_MASK_OP2, OP_SH_OP2); break;\n+  for (oparg = opc->args; *oparg; ++oparg)\n+    {\n+      opargStart = oparg;\n+      switch (*oparg)\n+\t{\n+\tcase 'C': /* RVC */\n+\t  switch (*++oparg)\n+\t    {\n+\t    case 'U': break; /* CRS1, constrained to equal RD.  */\n+\t    case 'c': break; /* CRS1, constrained to equal sp.  */\n+\t    case 'T': /* CRS2, floating point.  */\n+\t    case 'V': USE_BITS (OP_MASK_CRS2, OP_SH_CRS2); break;\n+\t    case 'S': /* CRS1S, floating point.  */\n+\t    case 's': USE_BITS (OP_MASK_CRS1S, OP_SH_CRS1S); break;\n+\t    case 'w': break; /* CRS1S, constrained to equal RD.  */\n+\t    case 'D': /* CRS2S, floating point.  */\n+\t    case 't': USE_BITS (OP_MASK_CRS2S, OP_SH_CRS2S); break;\n+\t    case 'x': break; /* CRS2S, constrained to equal RD.  */\n+\t    case 'z': break; /* CRS2S, constrained to be x0.  */\n+\t    case '>': /* CITYPE immediate, compressed shift.  */\n+\t    case 'u': /* CITYPE immediate, compressed lui.  */\n+\t    case 'v': /* CITYPE immediate, li to compressed lui.  */\n+\t    case 'o': /* CITYPE immediate, allow zero.  */\n+\t    case 'j': used_bits |= ENCODE_CITYPE_IMM (-1U); break;\n+\t    case 'L': used_bits |= ENCODE_CITYPE_ADDI16SP_IMM (-1U); break;\n+\t    case 'm': used_bits |= ENCODE_CITYPE_LWSP_IMM (-1U); break;\n+\t    case 'n': used_bits |= ENCODE_CITYPE_LDSP_IMM (-1U); break;\n+\t    case '6': used_bits |= ENCODE_CSSTYPE_IMM (-1U); break;\n+\t    case 'M': used_bits |= ENCODE_CSSTYPE_SWSP_IMM (-1U); break;\n+\t    case 'N': used_bits |= ENCODE_CSSTYPE_SDSP_IMM (-1U); break;\n+\t    case '8': used_bits |= ENCODE_CIWTYPE_IMM (-1U); break;\n+\t    case 'K': used_bits |= ENCODE_CIWTYPE_ADDI4SPN_IMM (-1U); break;\n+\t    /* CLTYPE and CSTYPE have the same immediate encoding.  */\n+\t    case '5': used_bits |= ENCODE_CLTYPE_IMM (-1U); break;\n+\t    case 'k': used_bits |= ENCODE_CLTYPE_LW_IMM (-1U); break;\n+\t    case 'l': used_bits |= ENCODE_CLTYPE_LD_IMM (-1U); break;\n+\t    case 'p': used_bits |= ENCODE_CBTYPE_IMM (-1U); break;\n+\t    case 'a': used_bits |= ENCODE_CJTYPE_IMM (-1U); break;\n+\t    case 'F': /* Compressed funct for .insn directive.  */\n+\t      switch (*++oparg)\n+\t\t{\n+\t\t  case '6': USE_BITS (OP_MASK_CFUNCT6, OP_SH_CFUNCT6); break;\n+\t\t  case '4': USE_BITS (OP_MASK_CFUNCT4, OP_SH_CFUNCT4); break;\n+\t\t  case '3': USE_BITS (OP_MASK_CFUNCT3, OP_SH_CFUNCT3); break;\n+\t\t  case '2': USE_BITS (OP_MASK_CFUNCT2, OP_SH_CFUNCT2); break;\n+\t\t  default:\n+\t\t    goto unknown_validate_operand;\n+\t\t}\n+\t      break;\n \t    default:\n-\t      as_bad (_(\"internal: bad RISC-V opcode \"\n-\t\t\t\"(unknown operand type `F%c'): %s %s\"),\n-\t\t      c, opc->name, opc->args);\n-\t     return false;\n-\t  }\n-\tbreak;\n-      default:\n-\tas_bad (_(\"internal: bad RISC-V opcode \"\n-\t\t  \"(unknown operand type `%c'): %s %s\"),\n-\t\tc, opc->name, opc->args);\n-\treturn false;\n-      }\n-#undef USE_BITS\n+\t      goto unknown_validate_operand;\n+\t    }\n+\t  break;\n+\tcase ',': break;\n+\tcase '(': break;\n+\tcase ')': break;\n+\tcase '<': USE_BITS (OP_MASK_SHAMTW, OP_SH_SHAMTW); break;\n+\tcase '>': USE_BITS (OP_MASK_SHAMT, OP_SH_SHAMT); break;\n+\tcase 'A': break; /* Macro operand, must be symbol.  */\n+\tcase 'B': break; /* Macro operand, must be symbol or constant.  */\n+\tcase 'I': break; /* Macro operand, must be constant.  */\n+\tcase 'D': /* RD, floating point.  */\n+\tcase 'd': USE_BITS (OP_MASK_RD, OP_SH_RD); break;\n+\tcase 'Z': /* RS1, CSR number.  */\n+\tcase 'S': /* RS1, floating point.  */\n+\tcase 's': USE_BITS (OP_MASK_RS1, OP_SH_RS1); break;\n+\tcase 'U': /* RS1 and RS2 are the same, floating point.  */\n+\t  USE_BITS (OP_MASK_RS1, OP_SH_RS1);\n+\t  /* Fall through.  */\n+\tcase 'T': /* RS2, floating point.  */\n+\tcase 't': USE_BITS (OP_MASK_RS2, OP_SH_RS2); break;\n+\tcase 'R': /* RS3, floating point.  */\n+\tcase 'r': USE_BITS (OP_MASK_RS3, OP_SH_RS3); break;\n+\tcase 'm': USE_BITS (OP_MASK_RM, OP_SH_RM); break;\n+\tcase 'E': USE_BITS (OP_MASK_CSR, OP_SH_CSR); break;\n+\tcase 'P': USE_BITS (OP_MASK_PRED, OP_SH_PRED); break;\n+\tcase 'Q': USE_BITS (OP_MASK_SUCC, OP_SH_SUCC); break;\n+\tcase 'o': /* ITYPE immediate, load displacement.  */\n+\tcase 'j': used_bits |= ENCODE_ITYPE_IMM (-1U); break;\n+\tcase 'a': used_bits |= ENCODE_JTYPE_IMM (-1U); break;\n+\tcase 'p': used_bits |= ENCODE_BTYPE_IMM (-1U); break;\n+\tcase 'q': used_bits |= ENCODE_STYPE_IMM (-1U); break;\n+\tcase 'u': used_bits |= ENCODE_UTYPE_IMM (-1U); break;\n+\tcase 'z': break; /* Zero immediate.  */\n+\tcase '[': break; /* Unused operand.  */\n+\tcase ']': break; /* Unused operand.  */\n+\tcase '0': break; /* AMO displacement, must to zero.  */\n+\tcase '1': break; /* Relaxation operand.  */\n+\tcase 'F': /* Funct for .insn directive.  */\n+\t  switch (*++oparg)\n+\t    {\n+\t      case '7': USE_BITS (OP_MASK_FUNCT7, OP_SH_FUNCT7); break;\n+\t      case '3': USE_BITS (OP_MASK_FUNCT3, OP_SH_FUNCT3); break;\n+\t      case '2': USE_BITS (OP_MASK_FUNCT2, OP_SH_FUNCT2); break;\n+\t      default:\n+\t\tgoto unknown_validate_operand;\n+\t    }\n+\t  break;\n+\tcase 'O': /* Opcode for .insn directive.  */\n+\t  switch (*++oparg)\n+\t    {\n+\t      case '4': USE_BITS (OP_MASK_OP, OP_SH_OP); break;\n+\t      case '2': USE_BITS (OP_MASK_OP2, OP_SH_OP2); break;\n+\t      default:\n+\t\tgoto unknown_validate_operand;\n+\t    }\n+\t  break;\n+\tdefault:\n+\tunknown_validate_operand:\n+\t  as_bad (_(\"internal: bad RISC-V opcode \"\n+\t\t    \"(unknown operand type `%s'): %s %s\"),\n+\t\t  opargStart, opc->name, opc->args);\n+\t  return false;\n+\t}\n+    }\n+\n   if (used_bits != required_bits)\n     {\n       as_bad (_(\"internal: bad RISC-V opcode \"\n@@ -1212,6 +1222,8 @@ validate_riscv_insn (const struct riscv_opcode *opc, int length)\n   return true;\n }\n \n+#undef USE_BITS\n+\n struct percent_op_match\n {\n   const char *str;\n@@ -1394,6 +1406,7 @@ macro_build (expressionS *ep, const char *name, const char *fmt, ...)\n   struct riscv_cl_insn insn;\n   bfd_reloc_code_real_type r;\n   va_list args;\n+  const char *fmtStart;\n \n   va_start (args, fmt);\n \n@@ -1408,18 +1421,17 @@ macro_build (expressionS *ep, const char *name, const char *fmt, ...)\n   gas_assert (strcmp (name, mo->name) == 0);\n \n   create_insn (&insn, mo);\n-  for (;;)\n+  for (;; ++fmt)\n     {\n-      switch (*fmt++)\n+      fmtStart = fmt;\n+      switch (*fmt)\n \t{\n \tcase 'd':\n \t  INSERT_OPERAND (RD, insn, va_arg (args, int));\n \t  continue;\n-\n \tcase 's':\n \t  INSERT_OPERAND (RS1, insn, va_arg (args, int));\n \t  continue;\n-\n \tcase 't':\n \t  INSERT_OPERAND (RS2, insn, va_arg (args, int));\n \t  continue;\n@@ -1436,7 +1448,7 @@ macro_build (expressionS *ep, const char *name, const char *fmt, ...)\n \tcase ',':\n \t  continue;\n \tdefault:\n-\t  as_fatal (_(\"internal: invalid macro\"));\n+\t  as_fatal (_(\"internal: invalid macro argument `%s'\"), fmtStart);\n \t}\n       break;\n     }\n@@ -1934,7 +1946,7 @@ my_getOpcodeExpression (expressionS *ep, bfd_reloc_code_real_type *reloc,\n }\n \n /* Detect and handle implicitly zero load-store offsets.  For example,\n-   \"lw t0, (t1)\" is shorthand for \"lw t0, 0(t1)\".  Return TRUE iff such\n+   \"lw t0, (t1)\" is shorthand for \"lw t0, 0(t1)\".  Return true if such\n    an implicit offset was detected.  */\n \n static bool\n@@ -2001,7 +2013,7 @@ riscv_csr_read_only_check (insn_t insn)\n   return true;\n }\n \n-/* Return True if it is a privileged instruction.  Otherwise, return FALSE.\n+/* Return true if it is a privileged instruction.  Otherwise, return false.\n \n    uret is actually a N-ext instruction.  So it is better to regard it as\n    an user instruction rather than the priv instruction.\n@@ -2034,13 +2046,13 @@ static const char *\n riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t  bfd_reloc_code_real_type *imm_reloc, htab_t hash)\n {\n-  char *s;\n-  const char *args;\n-  char c = 0;\n+  /* The operand string defined in the riscv_opcodes.  */\n+  const char *oparg, *opargStart;\n+  /* The parsed operands from assembly.  */\n+  char *asarg, *asargStart;\n+  char save_c = 0;\n   struct riscv_opcode *insn;\n-  char *argsStart;\n   unsigned int regno;\n-  char save_c = 0;\n   int argnum;\n   const struct percent_op_match *p;\n   const char *error = \"unrecognized opcode\";\n@@ -2049,17 +2061,17 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \n   /* Parse the name of the instruction.  Terminate the string if whitespace\n      is found so that str_hash_find only sees the name part of the string.  */\n-  for (s = str; *s != '\\0'; ++s)\n-    if (ISSPACE (*s))\n+  for (asarg = str; *asarg!= '\\0'; ++asarg)\n+    if (ISSPACE (*asarg))\n       {\n-\tsave_c = *s;\n-\t*s++ = '\\0';\n+\tsave_c = *asarg;\n+\t*asarg++ = '\\0';\n \tbreak;\n       }\n \n   insn = (struct riscv_opcode *) str_hash_find (hash, str);\n \n-  argsStart = s;\n+  asargStart = asarg;\n   for ( ; insn && insn->name && strcmp (insn->name, str) == 0; insn++)\n     {\n       if ((insn->xlen_requirement != 0) && (xlen != insn->xlen_requirement))\n@@ -2075,10 +2087,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n       *imm_reloc = BFD_RELOC_UNUSED;\n       p = percent_op_itype;\n \n-      for (args = insn->args;; ++args)\n+      for (oparg = insn->args;; ++oparg)\n \t{\n-\t  s += strspn (s, \" \\t\");\n-\t  switch (*args)\n+\t  opargStart = oparg;\n+\t  asarg += strspn (asarg, \" \\t\");\n+\t  switch (*oparg)\n \t    {\n \t    case '\\0': /* End of args.  */\n \t      if (insn->pinfo != INSN_MACRO)\n@@ -2105,75 +2118,75 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t      /* Restore the character in advance, since we want to\n \t\t\t report the detailed warning message here.  */\n \t\t      if (save_c)\n-\t\t\t*(argsStart - 1) = save_c;\n+\t\t\t*(asargStart - 1) = save_c;\n \t\t      as_warn (_(\"read-only CSR is written `%s'\"), str);\n \t\t      insn_with_csr = false;\n \t\t    }\n \t\t}\n-\t      if (*s != '\\0')\n+\t      if (*asarg != '\\0')\n \t\tbreak;\n \t      /* Successful assembly.  */\n \t      error = NULL;\n \t      insn_with_csr = false;\n \t      goto out;\n \n \t    case 'C': /* RVC */\n-\t      switch (*++args)\n+\t      switch (*++oparg)\n \t\t{\n \t\tcase 's': /* RS1 x8-x15.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_GPR, &regno)\n \t\t      || !(regno >= 8 && regno <= 15))\n \t\t    break;\n \t\t  INSERT_OPERAND (CRS1S, *ip, regno % 8);\n \t\t  continue;\n \t\tcase 'w': /* RS1 x8-x15, constrained to equal RD x8-x15.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_GPR, &regno)\n \t\t      || EXTRACT_OPERAND (CRS1S, ip->insn_opcode) + 8 != regno)\n \t\t    break;\n \t\t  continue;\n \t\tcase 't': /* RS2 x8-x15.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_GPR, &regno)\n \t\t      || !(regno >= 8 && regno <= 15))\n \t\t    break;\n \t\t  INSERT_OPERAND (CRS2S, *ip, regno % 8);\n \t\t  continue;\n \t\tcase 'x': /* RS2 x8-x15, constrained to equal RD x8-x15.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_GPR, &regno)\n \t\t      || EXTRACT_OPERAND (CRS2S, ip->insn_opcode) + 8 != regno)\n \t\t    break;\n \t\t  continue;\n \t\tcase 'U': /* RS1, constrained to equal RD.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_GPR, &regno)\n \t\t      || EXTRACT_OPERAND (RD, ip->insn_opcode) != regno)\n \t\t    break;\n \t\t  continue;\n \t\tcase 'V': /* RS2 */\n-\t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno))\n+\t\t  if (!reg_lookup (&asarg, RCLASS_GPR, &regno))\n \t\t    break;\n \t\t  INSERT_OPERAND (CRS2, *ip, regno);\n \t\t  continue;\n \t\tcase 'c': /* RS1, constrained to equal sp.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_GPR, &regno)\n \t\t      || regno != X_SP)\n \t\t    break;\n \t\t  continue;\n \t\tcase 'z': /* RS2, constrained to equal x0.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_GPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_GPR, &regno)\n \t\t      || regno != 0)\n \t\t    break;\n \t\t  continue;\n \t\tcase '>': /* Shift amount, 0 - (XLEN-1).  */\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || (unsigned long) imm_expr->X_add_number >= xlen)\n \t\t    break;\n \t\t  ip->insn_opcode |= ENCODE_CITYPE_IMM (imm_expr->X_add_number);\n \t\trvc_imm_done:\n-\t\t  s = expr_end;\n+\t\t  asarg = expr_end;\n \t\t  imm_expr->X_op = O_absent;\n \t\t  continue;\n \t\tcase '5':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number < 0\n \t\t      || imm_expr->X_add_number >= 32\n@@ -2182,7 +2195,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t  ip->insn_opcode |= ENCODE_CLTYPE_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase '6':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number < 0\n \t\t      || imm_expr->X_add_number >= 64\n@@ -2191,7 +2204,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t  ip->insn_opcode |= ENCODE_CSSTYPE_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase '8':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number < 0\n \t\t      || imm_expr->X_add_number >= 256\n@@ -2200,53 +2213,53 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t  ip->insn_opcode |= ENCODE_CIWTYPE_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'j':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number == 0\n \t\t      || !VALID_CITYPE_IMM ((valueT) imm_expr->X_add_number))\n \t\t    break;\n \t\t  ip->insn_opcode |= ENCODE_CITYPE_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'k':\n-\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, s))\n+\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, asarg))\n \t\t    continue;\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || !VALID_CLTYPE_LW_IMM ((valueT) imm_expr->X_add_number))\n \t\t    break;\n \t\t  ip->insn_opcode |= ENCODE_CLTYPE_LW_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'l':\n-\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, s))\n+\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, asarg))\n \t\t    continue;\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || !VALID_CLTYPE_LD_IMM ((valueT) imm_expr->X_add_number))\n \t\t    break;\n \t\t  ip->insn_opcode |= ENCODE_CLTYPE_LD_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'm':\n-\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, s))\n+\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, asarg))\n \t\t    continue;\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || !VALID_CITYPE_LWSP_IMM ((valueT) imm_expr->X_add_number))\n \t\t    break;\n \t\t  ip->insn_opcode |=\n \t\t    ENCODE_CITYPE_LWSP_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'n':\n-\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, s))\n+\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, asarg))\n \t\t    continue;\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || !VALID_CITYPE_LDSP_IMM ((valueT) imm_expr->X_add_number))\n \t\t    break;\n \t\t  ip->insn_opcode |=\n \t\t    ENCODE_CITYPE_LDSP_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'o':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      /* C.addiw, c.li, and c.andi allow zero immediate.\n \t\t\t C.addi allows zero immediate as hint.  Otherwise this\n@@ -2256,7 +2269,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t  ip->insn_opcode |= ENCODE_CITYPE_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'K':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number == 0\n \t\t      || !VALID_CIWTYPE_ADDI4SPN_IMM ((valueT) imm_expr->X_add_number))\n@@ -2265,27 +2278,27 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t    ENCODE_CIWTYPE_ADDI4SPN_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'L':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || !VALID_CITYPE_ADDI16SP_IMM ((valueT) imm_expr->X_add_number))\n \t\t    break;\n \t\t  ip->insn_opcode |=\n \t\t    ENCODE_CITYPE_ADDI16SP_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'M':\n-\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, s))\n+\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, asarg))\n \t\t    continue;\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || !VALID_CSSTYPE_SWSP_IMM ((valueT) imm_expr->X_add_number))\n \t\t    break;\n \t\t  ip->insn_opcode |=\n \t\t    ENCODE_CSSTYPE_SWSP_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'N':\n-\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, s))\n+\t\t  if (riscv_handle_implicit_zero_offset (imm_expr, asarg))\n \t\t    continue;\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || !VALID_CSSTYPE_SDSP_IMM ((valueT) imm_expr->X_add_number))\n \t\t    break;\n@@ -2294,7 +2307,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t  goto rvc_imm_done;\n \t\tcase 'u':\n \t\t  p = percent_op_utype;\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p))\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p))\n \t\t    break;\n \t\trvc_lui:\n \t\t  if (imm_expr->X_op != O_constant\n@@ -2307,7 +2320,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t  ip->insn_opcode |= ENCODE_CITYPE_IMM (imm_expr->X_add_number);\n \t\t  goto rvc_imm_done;\n \t\tcase 'v':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || (imm_expr->X_add_number & (RISCV_IMM_REACH - 1))\n \t\t      || ((int32_t)imm_expr->X_add_number\n \t\t\t  != imm_expr->X_add_number))\n@@ -2320,27 +2333,27 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\tcase 'a':\n \t\t  goto jump;\n \t\tcase 'S': /* Floating-point RS1 x8-x15.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_FPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_FPR, &regno)\n \t\t      || !(regno >= 8 && regno <= 15))\n \t\t    break;\n \t\t  INSERT_OPERAND (CRS1S, *ip, regno % 8);\n \t\t  continue;\n \t\tcase 'D': /* Floating-point RS2 x8-x15.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_FPR, &regno)\n+\t\t  if (!reg_lookup (&asarg, RCLASS_FPR, &regno)\n \t\t      || !(regno >= 8 && regno <= 15))\n \t\t    break;\n \t\t  INSERT_OPERAND (CRS2S, *ip, regno % 8);\n \t\t  continue;\n \t\tcase 'T': /* Floating-point RS2.  */\n-\t\t  if (!reg_lookup (&s, RCLASS_FPR, &regno))\n+\t\t  if (!reg_lookup (&asarg, RCLASS_FPR, &regno))\n \t\t    break;\n \t\t  INSERT_OPERAND (CRS2, *ip, regno);\n \t\t  continue;\n \t\tcase 'F':\n-\t\t  switch (*++args)\n+\t\t  switch (*++oparg)\n \t\t    {\n \t\t      case '6':\n-\t\t        if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t        if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t\t    || imm_expr->X_op != O_constant\n \t\t\t    || imm_expr->X_add_number < 0\n \t\t\t    || imm_expr->X_add_number >= 64)\n@@ -2351,11 +2364,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t\t  }\n \t\t\tINSERT_OPERAND (CFUNCT6, *ip, imm_expr->X_add_number);\n \t\t\timm_expr->X_op = O_absent;\n-\t\t\ts = expr_end;\n+\t\t\tasarg = expr_end;\n \t\t\tcontinue;\n \n \t\t      case '4':\n-\t\t        if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t        if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t\t    || imm_expr->X_op != O_constant\n \t\t\t    || imm_expr->X_add_number < 0\n \t\t\t    || imm_expr->X_add_number >= 16)\n@@ -2366,11 +2379,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t\t  }\n \t\t\tINSERT_OPERAND (CFUNCT4, *ip, imm_expr->X_add_number);\n \t\t\timm_expr->X_op = O_absent;\n-\t\t\ts = expr_end;\n+\t\t\tasarg = expr_end;\n \t\t\tcontinue;\n \n \t\t      case '3':\n-\t\t\tif (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t\tif (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t\t    || imm_expr->X_op != O_constant\n \t\t\t    || imm_expr->X_add_number < 0\n \t\t\t    || imm_expr->X_add_number >= 8)\n@@ -2381,11 +2394,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t\t  }\n \t\t\tINSERT_OPERAND (CFUNCT3, *ip, imm_expr->X_add_number);\n \t\t\timm_expr->X_op = O_absent;\n-\t\t\ts = expr_end;\n+\t\t\tasarg = expr_end;\n \t\t\tcontinue;\n \n \t\t      case '2':\n-\t\t\tif (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t\tif (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t\t    || imm_expr->X_op != O_constant\n \t\t\t    || imm_expr->X_add_number < 0\n \t\t\t    || imm_expr->X_add_number >= 4)\n@@ -2396,89 +2409,88 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t\t  }\n \t\t\tINSERT_OPERAND (CFUNCT2, *ip, imm_expr->X_add_number);\n \t\t\timm_expr->X_op = O_absent;\n-\t\t\ts = expr_end;\n+\t\t\tasarg = expr_end;\n \t\t\tcontinue;\n \n \t\t      default:\n-\t\t\tas_bad (_(\"internal: unknown compressed funct \"\n-\t\t\t\t  \"field specifier `CF%c'\"), *args);\n+\t\t\tgoto unknown_riscv_ip_operand;\n \t\t    }\n \t\t  break;\n \n \t\tdefault:\n-\t\t  as_bad (_(\"internal: unknown compressed field \"\n-\t\t\t    \"specifier `C%c'\"), *args);\n+\t\t  goto unknown_riscv_ip_operand;\n \t\t}\n \t      break;\n \n \t    case ',':\n \t      ++argnum;\n-\t      if (*s++ == *args)\n+\t      if (*asarg++ == *oparg)\n \t\tcontinue;\n-\t      s--;\n+\t      asarg--;\n \t      break;\n \n \t    case '(':\n \t    case ')':\n \t    case '[':\n \t    case ']':\n-\t      if (*s++ == *args)\n+\t      if (*asarg++ == *oparg)\n \t\tcontinue;\n \t      break;\n \n \t    case '<': /* Shift amount, 0 - 31.  */\n-\t      my_getExpression (imm_expr, s);\n+\t      my_getExpression (imm_expr, asarg);\n \t      check_absolute_expr (ip, imm_expr, false);\n \t      if ((unsigned long) imm_expr->X_add_number > 31)\n \t\tas_bad (_(\"improper shift amount (%lu)\"),\n \t\t\t(unsigned long) imm_expr->X_add_number);\n \t      INSERT_OPERAND (SHAMTW, *ip, imm_expr->X_add_number);\n \t      imm_expr->X_op = O_absent;\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case '>': /* Shift amount, 0 - (XLEN-1).  */\n-\t      my_getExpression (imm_expr, s);\n+\t      my_getExpression (imm_expr, asarg);\n \t      check_absolute_expr (ip, imm_expr, false);\n \t      if ((unsigned long) imm_expr->X_add_number >= xlen)\n \t\tas_bad (_(\"improper shift amount (%lu)\"),\n \t\t\t(unsigned long) imm_expr->X_add_number);\n \t      INSERT_OPERAND (SHAMT, *ip, imm_expr->X_add_number);\n \t      imm_expr->X_op = O_absent;\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case 'Z': /* CSRRxI immediate.  */\n-\t      my_getExpression (imm_expr, s);\n+\t      my_getExpression (imm_expr, asarg);\n \t      check_absolute_expr (ip, imm_expr, false);\n \t      if ((unsigned long) imm_expr->X_add_number > 31)\n \t\tas_bad (_(\"improper CSRxI immediate (%lu)\"),\n \t\t\t(unsigned long) imm_expr->X_add_number);\n \t      INSERT_OPERAND (RS1, *ip, imm_expr->X_add_number);\n \t      imm_expr->X_op = O_absent;\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case 'E': /* Control register.  */\n \t      insn_with_csr = true;\n \t      explicit_priv_attr = true;\n-\t      if (reg_lookup (&s, RCLASS_CSR, &regno))\n+\t      if (reg_lookup (&asarg, RCLASS_CSR, &regno))\n \t\tINSERT_OPERAND (CSR, *ip, regno);\n \t      else\n \t\t{\n-\t\t  my_getExpression (imm_expr, s);\n+\t\t  my_getExpression (imm_expr, asarg);\n \t\t  check_absolute_expr (ip, imm_expr, true);\n \t\t  if ((unsigned long) imm_expr->X_add_number > 0xfff)\n \t\t    as_bad (_(\"improper CSR address (%lu)\"),\n \t\t\t    (unsigned long) imm_expr->X_add_number);\n \t\t  INSERT_OPERAND (CSR, *ip, imm_expr->X_add_number);\n \t\t  imm_expr->X_op = O_absent;\n-\t\t  s = expr_end;\n+\t\t  asarg = expr_end;\n \t\t}\n \t      continue;\n \n \t    case 'm': /* Rounding mode.  */\n-\t      if (arg_lookup (&s, riscv_rm, ARRAY_SIZE (riscv_rm), &regno))\n+\t      if (arg_lookup (&asarg, riscv_rm,\n+\t\t\t      ARRAY_SIZE (riscv_rm), &regno))\n \t\t{\n \t\t  INSERT_OPERAND (RM, *ip, regno);\n \t\t  continue;\n@@ -2487,10 +2499,10 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \n \t    case 'P':\n \t    case 'Q': /* Fence predecessor/successor.  */\n-\t      if (arg_lookup (&s, riscv_pred_succ, ARRAY_SIZE (riscv_pred_succ),\n-\t\t\t      &regno))\n+\t      if (arg_lookup (&asarg, riscv_pred_succ,\n+\t\t\t      ARRAY_SIZE (riscv_pred_succ), &regno))\n \t\t{\n-\t\t  if (*args == 'P')\n+\t\t  if (*oparg == 'P')\n \t\t    INSERT_OPERAND (PRED, *ip, regno);\n \t\t  else\n \t\t    INSERT_OPERAND (SUCC, *ip, regno);\n@@ -2502,11 +2514,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t    case 's': /* Source register.  */\n \t    case 't': /* Target register.  */\n \t    case 'r': /* RS3 */\n-\t      if (reg_lookup (&s, RCLASS_GPR, &regno))\n+\t      if (reg_lookup (&asarg, RCLASS_GPR, &regno))\n \t\t{\n-\t\t  c = *args;\n-\t\t  if (*s == ' ')\n-\t\t    ++s;\n+\t\t  char c = *oparg;\n+\t\t  if (*asarg == ' ')\n+\t\t    ++asarg;\n \n \t\t  /* Now that we have assembled one operand, we use the args\n \t\t     string to figure out where it goes in the instruction.  */\n@@ -2534,11 +2546,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t    case 'T': /* Floating point RS2.  */\n \t    case 'U': /* Floating point RS1 and RS2.  */\n \t    case 'R': /* Floating point RS3.  */\n-\t      if (reg_lookup (&s, RCLASS_FPR, &regno))\n+\t      if (reg_lookup (&asarg, RCLASS_FPR, &regno))\n \t\t{\n-\t\t  c = *args;\n-\t\t  if (*s == ' ')\n-\t\t    ++s;\n+\t\t  char c = *oparg;\n+\t\t  if (*asarg == ' ')\n+\t\t    ++asarg;\n \t\t  switch (c)\n \t\t    {\n \t\t    case 'D':\n@@ -2562,33 +2574,33 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t      break;\n \n \t    case 'I':\n-\t      my_getExpression (imm_expr, s);\n+\t      my_getExpression (imm_expr, asarg);\n \t      if (imm_expr->X_op != O_big\n \t\t  && imm_expr->X_op != O_constant)\n \t\tbreak;\n \t      normalize_constant_expr (imm_expr);\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case 'A':\n-\t      my_getExpression (imm_expr, s);\n+\t      my_getExpression (imm_expr, asarg);\n \t      normalize_constant_expr (imm_expr);\n \t      /* The 'A' format specifier must be a symbol.  */\n \t      if (imm_expr->X_op != O_symbol)\n \t        break;\n \t      *imm_reloc = BFD_RELOC_32;\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case 'B':\n-\t      my_getExpression (imm_expr, s);\n+\t      my_getExpression (imm_expr, asarg);\n \t      normalize_constant_expr (imm_expr);\n \t      /* The 'B' format specifier must be a symbol or a constant.  */\n \t      if (imm_expr->X_op != O_symbol && imm_expr->X_op != O_constant)\n \t        break;\n \t      if (imm_expr->X_op == O_symbol)\n \t        *imm_reloc = BFD_RELOC_32;\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case 'j': /* Sign-extended immediate.  */\n@@ -2612,35 +2624,35 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t    case '0': /* AMO displacement, which must be zero.  */\n \t      p = percent_op_null;\n \t    load_store:\n-\t      if (riscv_handle_implicit_zero_offset (imm_expr, s))\n+\t      if (riscv_handle_implicit_zero_offset (imm_expr, asarg))\n \t\tcontinue;\n \t    alu_op:\n \t      /* If this value won't fit into a 16 bit offset, then go\n \t\t find a macro that will generate the 32 bit offset\n \t\t code pattern.  */\n-\t      if (!my_getSmallExpression (imm_expr, imm_reloc, s, p))\n+\t      if (!my_getSmallExpression (imm_expr, imm_reloc, asarg, p))\n \t\t{\n \t\t  normalize_constant_expr (imm_expr);\n \t\t  if (imm_expr->X_op != O_constant\n-\t\t      || (*args == '0' && imm_expr->X_add_number != 0)\n-\t\t      || (*args == '1')\n+\t\t      || (*oparg == '0' && imm_expr->X_add_number != 0)\n+\t\t      || (*oparg == '1')\n \t\t      || imm_expr->X_add_number >= (signed)RISCV_IMM_REACH/2\n \t\t      || imm_expr->X_add_number < -(signed)RISCV_IMM_REACH/2)\n \t\t    break;\n \t\t}\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case 'p': /* PC-relative offset.  */\n \t    branch:\n \t      *imm_reloc = BFD_RELOC_12_PCREL;\n-\t      my_getExpression (imm_expr, s);\n-\t      s = expr_end;\n+\t      my_getExpression (imm_expr, asarg);\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case 'u': /* Upper 20 bits.  */\n \t      p = percent_op_utype;\n-\t      if (!my_getSmallExpression (imm_expr, imm_reloc, s, p))\n+\t      if (!my_getSmallExpression (imm_expr, imm_reloc, asarg, p))\n \t\t{\n \t\t  if (imm_expr->X_op != O_constant)\n \t\t    break;\n@@ -2652,33 +2664,33 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t  *imm_reloc = BFD_RELOC_RISCV_HI20;\n \t\t  imm_expr->X_add_number <<= RISCV_IMM_BITS;\n \t\t}\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      continue;\n \n \t    case 'a': /* 20-bit PC-relative offset.  */\n \t    jump:\n-\t      my_getExpression (imm_expr, s);\n-\t      s = expr_end;\n+\t      my_getExpression (imm_expr, asarg);\n+\t      asarg = expr_end;\n \t      *imm_reloc = BFD_RELOC_RISCV_JMP;\n \t      continue;\n \n \t    case 'c':\n-\t      my_getExpression (imm_expr, s);\n-\t      s = expr_end;\n-\t      if (strcmp (s, \"@plt\") == 0)\n+\t      my_getExpression (imm_expr, asarg);\n+\t      asarg = expr_end;\n+\t      if (strcmp (asarg, \"@plt\") == 0)\n \t\t{\n \t\t  *imm_reloc = BFD_RELOC_RISCV_CALL_PLT;\n-\t\t  s += 4;\n+\t\t  asarg += 4;\n \t\t}\n \t      else\n \t\t*imm_reloc = BFD_RELOC_RISCV_CALL;\n \t      continue;\n \n \t    case 'O':\n-\t      switch (*++args)\n+\t      switch (*++oparg)\n \t\t{\n \t\tcase '4':\n-\t\t  if (my_getOpcodeExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getOpcodeExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number < 0\n \t\t      || imm_expr->X_add_number >= 128\n@@ -2691,11 +2703,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t    }\n \t\t  INSERT_OPERAND (OP, *ip, imm_expr->X_add_number);\n \t\t  imm_expr->X_op = O_absent;\n-\t\t  s = expr_end;\n+\t\t  asarg = expr_end;\n \t\t  continue;\n \n \t\tcase '2':\n-\t\t  if (my_getOpcodeExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getOpcodeExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number < 0\n \t\t      || imm_expr->X_add_number >= 3)\n@@ -2706,20 +2718,19 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t    }\n \t\t  INSERT_OPERAND (OP2, *ip, imm_expr->X_add_number);\n \t\t  imm_expr->X_op = O_absent;\n-\t\t  s = expr_end;\n+\t\t  asarg = expr_end;\n \t\t  continue;\n \n \t\tdefault:\n-\t\t  as_bad (_(\"internal: unknown opcode field \"\n-\t\t\t    \"specifier `O%c'\"), *args);\n+\t\t  goto unknown_riscv_ip_operand;\n \t\t}\n \t      break;\n \n \t    case 'F':\n-\t      switch (*++args)\n+\t      switch (*++oparg)\n \t\t{\n \t\tcase '7':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number < 0\n \t\t      || imm_expr->X_add_number >= 128)\n@@ -2730,11 +2741,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t    }\n \t\t  INSERT_OPERAND (FUNCT7, *ip, imm_expr->X_add_number);\n \t\t  imm_expr->X_op = O_absent;\n-\t\t  s = expr_end;\n+\t\t  asarg = expr_end;\n \t\t  continue;\n \n \t\tcase '3':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number < 0\n \t\t      || imm_expr->X_add_number >= 8)\n@@ -2745,11 +2756,11 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t    }\n \t\t  INSERT_OPERAND (FUNCT3, *ip, imm_expr->X_add_number);\n \t\t  imm_expr->X_op = O_absent;\n-\t\t  s = expr_end;\n+\t\t  asarg = expr_end;\n \t\t  continue;\n \n \t\tcase '2':\n-\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t\t  if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t      || imm_expr->X_op != O_constant\n \t\t      || imm_expr->X_add_number < 0\n \t\t      || imm_expr->X_add_number >= 4)\n@@ -2760,38 +2771,39 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \t\t    }\n \t\t  INSERT_OPERAND (FUNCT2, *ip, imm_expr->X_add_number);\n \t\t  imm_expr->X_op = O_absent;\n-\t\t  s = expr_end;\n+\t\t  asarg = expr_end;\n \t\t  continue;\n \n \t\tdefault:\n-\t\t  as_bad (_(\"internal: unknown funct field \"\n-\t\t\t    \"specifier `F%c'\\n\"), *args);\n+\t\t  goto unknown_riscv_ip_operand;\n \t\t}\n \t      break;\n \n \t    case 'z':\n-\t      if (my_getSmallExpression (imm_expr, imm_reloc, s, p)\n+\t      if (my_getSmallExpression (imm_expr, imm_reloc, asarg, p)\n \t\t  || imm_expr->X_op != O_constant\n \t\t  || imm_expr->X_add_number != 0)\n \t\tbreak;\n-\t      s = expr_end;\n+\t      asarg = expr_end;\n \t      imm_expr->X_op = O_absent;\n \t      continue;\n \n \t    default:\n-\t      as_fatal (_(\"internal: unknown argument type `%c'\"), *args);\n+\t    unknown_riscv_ip_operand:\n+\t      as_fatal (_(\"internal: unknown argument type `%s'\"),\n+\t\t\topargStart);\n \t    }\n \t  break;\n \t}\n-      s = argsStart;\n+      asarg = asargStart;\n       error = _(\"illegal operands\");\n       insn_with_csr = false;\n     }\n \n  out:\n   /* Restore the character we might have clobbered above.  */\n   if (save_c)\n-    *(argsStart - 1) = save_c;\n+    *(asargStart  - 1) = save_c;\n \n   return error;\n }\n@@ -3762,16 +3774,20 @@ md_show_usage (FILE *stream)\n {\n   fprintf (stream, _(\"\\\n RISC-V options:\\n\\\n-  -fpic                       generate position-independent code\\n\\\n+  -fpic or -fPIC              generate position-independent code\\n\\\n   -fno-pic                    don't generate position-independent code (default)\\n\\\n   -march=ISA                  set the RISC-V architecture\\n\\\n   -misa-spec=ISAspec          set the RISC-V ISA spec (2.2, 20190608, 20191213)\\n\\\n-  -mpriv-spec=PRIVspec        set the RISC-V privilege spec (1.9, 1.9.1, 1.10, 1.11)\\n\\\n+  -mpriv-spec=PRIVspec        set the RISC-V privilege spec (1.9.1, 1.10, 1.11)\\n\\\n   -mabi=ABI                   set the RISC-V ABI\\n\\\n   -mrelax                     enable relax (default)\\n\\\n   -mno-relax                  disable relax\\n\\\n   -march-attr                 generate RISC-V arch attribute\\n\\\n   -mno-arch-attr              don't generate RISC-V arch attribute\\n\\\n+  -mcsr-check                 enable the csr ISA and privilege spec version checks\\n\\\n+  -mno-csr-check              disable the csr ISA and privilege spec version checks (default)\\n\\\n+  -mbig-endian                assemble for big-endian\\n\\\n+  -mlittle-endian             assemble for little-endian\\n\\\n \"));\n }\n "
    },
    {
      "sha": "1a094404fc564bf6902c9a0747d49f480d54e5b3",
      "filename": "opcodes/riscv-dis.c",
      "status": "modified",
      "additions": 10,
      "deletions": 8,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7/opcodes/riscv-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7/opcodes/riscv-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/riscv-dis.c?ref=437e2ff1ad8a1d5f20ebd27af2f04e1a1bcb48a7",
      "patch": "@@ -177,22 +177,24 @@ maybe_print_address (struct riscv_private_data *pd, int base_reg, int offset,\n /* Print insn arguments for 32/64-bit code.  */\n \n static void\n-print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n+print_insn_args (const char *oparg, insn_t l, bfd_vma pc, disassemble_info *info)\n {\n   struct riscv_private_data *pd = info->private_data;\n   int rs1 = (l >> OP_SH_RS1) & OP_MASK_RS1;\n   int rd = (l >> OP_SH_RD) & OP_MASK_RD;\n   fprintf_ftype print = info->fprintf_func;\n+  const char *opargStart;\n \n-  if (*d != '\\0')\n+  if (*oparg != '\\0')\n     print (info->stream, \"\\t\");\n \n-  for (; *d != '\\0'; d++)\n+  for (; *oparg != '\\0'; oparg++)\n     {\n-      switch (*d)\n+      opargStart = oparg;\n+      switch (*oparg)\n \t{\n \tcase 'C': /* RVC */\n-\t  switch (*++d)\n+\t  switch (*++oparg)\n \t    {\n \t    case 's': /* RS1 x8-x15.  */\n \t    case 'w': /* RS1 x8-x15.  */\n@@ -281,12 +283,12 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n \tcase ')':\n \tcase '[':\n \tcase ']':\n-\t  print (info->stream, \"%c\", *d);\n+\t  print (info->stream, \"%c\", *oparg);\n \t  break;\n \n \tcase '0':\n \t  /* Only print constant 0 if it is the last argument.  */\n-\t  if (!d[1])\n+\t  if (!oparg[1])\n \t    print (info->stream, \"0\");\n \t  break;\n \n@@ -432,7 +434,7 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n \tdefault:\n \t  /* xgettext:c-format */\n \t  print (info->stream, _(\"# internal error, undefined modifier (%c)\"),\n-\t\t *d);\n+\t\t *opargStart);\n \t  return;\n \t}\n     }"
    }
  ]
}