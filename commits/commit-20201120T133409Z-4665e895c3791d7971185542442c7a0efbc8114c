{
  "sha": "4665e895c3791d7971185542442c7a0efbc8114c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDY2NWU4OTVjMzc5MWQ3OTcxMTg1NTQyNDQyYzdhMGVmYmM4MTE0Yw==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-20T13:34:04Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-20T13:34:09Z"
    },
    "message": "libctf: adjust dumper for symtypetab changes\n\nNow that we have a new format for the function info section, it's much\neasier to dump it: we can use the same code we use for the object type\nsection, and that's got simpler too because we can use ctf_symbol_next.\n\nAlso dump the new stuff in the header: the new flags bits and the index\nsection lengths.\n\nlibctf/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-dump.c (ctf_dump_header): Dump the new flags bits and the index\n\tsection lengths.\n\t(ctf_dump_objts): Report indexed sections.  Also dump functions.  Use\n\tctf_symbol_next, not manual looping.\n\t(ctf_dump_funcs): Delete.\n\t(ctf_dump): Use ctf_dump_objts, not ctf_dump_funcs.",
    "tree": {
      "sha": "e66e1b85a2ffe31ca7ca66b5d6b2420fc3cfb999",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e66e1b85a2ffe31ca7ca66b5d6b2420fc3cfb999"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4665e895c3791d7971185542442c7a0efbc8114c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4665e895c3791d7971185542442c7a0efbc8114c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4665e895c3791d7971185542442c7a0efbc8114c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4665e895c3791d7971185542442c7a0efbc8114c/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1136c379718cb9f6a82e71029f86cd8cf70fa6be"
    }
  ],
  "stats": {
    "total": 219,
    "additions": 88,
    "deletions": 131
  },
  "files": [
    {
      "sha": "e81db2c34c098a3351863f2ded10ebe425cd74f1",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4665e895c3791d7971185542442c7a0efbc8114c/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4665e895c3791d7971185542442c7a0efbc8114c/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=4665e895c3791d7971185542442c7a0efbc8114c",
      "patch": "@@ -1,3 +1,12 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-dump.c (ctf_dump_header): Dump the new flags bits and the index\n+\tsection lengths.\n+\t(ctf_dump_objts): Report indexed sections.  Also dump functions.  Use\n+\tctf_symbol_next, not manual looping.\n+\t(ctf_dump_funcs): Delete.\n+\t(ctf_dump): Use ctf_dump_objts, not ctf_dump_funcs.\n+\n 2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.h (CTF_INDEX_PAD_THRESHOLD): New."
    },
    {
      "sha": "ccf4b3cb2b887acb192b0960b2dc46a79a1484bc",
      "filename": "libctf/ctf-dump.c",
      "status": "modified",
      "additions": 79,
      "deletions": 131,
      "changes": 210,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4665e895c3791d7971185542442c7a0efbc8114c/libctf/ctf-dump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4665e895c3791d7971185542442c7a0efbc8114c/libctf/ctf-dump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dump.c?ref=4665e895c3791d7971185542442c7a0efbc8114c",
      "patch": "@@ -224,6 +224,7 @@ static int\n ctf_dump_header (ctf_dict_t *fp, ctf_dump_state_t *state)\n {\n   char *str;\n+  char *flagstr = NULL;\n   const ctf_header_t *hp = fp->ctf_header;\n   const char *vertab[] =\n     {\n@@ -259,10 +260,29 @@ ctf_dump_header (ctf_dict_t *fp, ctf_dump_state_t *state)\n \n   if (fp->ctf_openflags > 0)\n     {\n-      if (fp->ctf_openflags)\n-\tif (asprintf (&str, \"Flags: 0x%x (%s)\", fp->ctf_openflags,\n-\t\t      fp->ctf_openflags & CTF_F_COMPRESS ? \"CTF_F_COMPRESS\"\n-\t\t\t\t\t\t\t : \"\") < 0)\n+      if (asprintf (&flagstr, \"%s%s%s%s%s%s%s\",\n+\t\t    fp->ctf_openflags & CTF_F_COMPRESS\n+\t\t    ? \"CTF_F_COMPRESS\": \"\",\n+\t\t    (fp->ctf_openflags & CTF_F_COMPRESS)\n+\t\t    && (fp->ctf_openflags & ~CTF_F_COMPRESS)\n+\t\t    ? \", \" : \"\",\n+\t\t    fp->ctf_openflags & CTF_F_NEWFUNCINFO\n+\t\t    ? \"CTF_F_NEWFUNCINFO\" : \"\",\n+\t\t    (fp->ctf_openflags & (CTF_F_COMPRESS | CTF_F_NEWFUNCINFO))\n+\t\t    && (fp->ctf_openflags & ~(CTF_F_COMPRESS | CTF_F_NEWFUNCINFO))\n+\t\t    ? \", \" : \"\",\n+\t\t    fp->ctf_openflags & CTF_F_IDXSORTED\n+\t\t    ? \"CTF_F_IDXSORTED\" : \"\",\n+\t\t    fp->ctf_openflags & (CTF_F_COMPRESS | CTF_F_NEWFUNCINFO\n+\t\t\t\t\t | CTF_F_IDXSORTED)\n+\t\t    && (fp->ctf_openflags & ~(CTF_F_COMPRESS | CTF_F_NEWFUNCINFO\n+\t\t\t\t\t      | CTF_F_IDXSORTED))\n+\t\t    ? \", \" : \"\",\n+\t\t    fp->ctf_openflags & CTF_F_DYNSTR\n+\t\t    ? \"CTF_F_DYNSTR\" : \"\") < 0)\n+\tgoto err;\n+\n+      if (asprintf (&str, \"Flags: 0x%x (%s)\", fp->ctf_openflags, flagstr) < 0)\n \tgoto err;\n       ctf_dump_append (state, str);\n     }\n@@ -287,7 +307,15 @@ ctf_dump_header (ctf_dict_t *fp, ctf_dump_state_t *state)\n     goto err;\n \n   if (ctf_dump_header_sectfield (fp, state, \"Function info section\",\n-\t\t\t\t hp->cth_funcoff, hp->cth_varoff) < 0)\n+\t\t\t\t hp->cth_funcoff, hp->cth_objtidxoff) < 0)\n+    goto err;\n+\n+  if (ctf_dump_header_sectfield (fp, state, \"Object index section\",\n+\t\t\t\t hp->cth_objtidxoff, hp->cth_funcidxoff) < 0)\n+    goto err;\n+\n+  if (ctf_dump_header_sectfield (fp, state, \"Function index section\",\n+\t\t\t\t hp->cth_funcidxoff, hp->cth_varoff) < 0)\n     goto err;\n \n   if (ctf_dump_header_sectfield (fp, state, \"Variable section\",\n@@ -304,6 +332,7 @@ ctf_dump_header (ctf_dict_t *fp, ctf_dump_state_t *state)\n \n   return 0;\n  err:\n+  free (flagstr);\n   return (ctf_set_errno (fp, errno));\n }\n \n@@ -334,149 +363,68 @@ ctf_dump_label (const char *name, const ctf_lblinfo_t *info,\n   return 0;\n }\n \n-/* Dump all the object entries into the cds_items.  (There is no iterator for\n-   this section, so we just do it in a loop, and this function handles all of\n-   them, rather than only one.  */\n+/* Dump all the object or function entries into the cds_items.  */\n \n static int\n-ctf_dump_objts (ctf_dict_t *fp, ctf_dump_state_t *state)\n+ctf_dump_objts (ctf_dict_t *fp, ctf_dump_state_t *state, int functions)\n {\n-  size_t i;\n-\n-  for (i = 0; i < fp->ctf_nsyms; i++)\n+  const char *name;\n+  ctf_id_t id;\n+  ctf_next_t *i = NULL;\n+  char *str = NULL;\n+\n+  if ((functions && fp->ctf_funcidx_names)\n+      || (!functions && fp->ctf_objtidx_names))\n+    str = str_append (str, _(\"Section is indexed.\\n\"));\n+  else if (fp->ctf_symtab.cts_data == NULL)\n+    str = str_append (str, _(\"No symbol table.\\n\"));\n+\n+  while ((id = ctf_symbol_next (fp, &i, &name, functions)) != CTF_ERR)\n     {\n-      char *str;\n-      char *typestr;\n-      const char *sym_name;\n-      ctf_id_t type;\n-\n-      if ((type = ctf_lookup_by_symbol (state->cds_fp, i)) == CTF_ERR)\n-\tswitch (ctf_errno (state->cds_fp))\n-\t  {\n-\t    /* Most errors are just an indication that this symbol is not a data\n-\t       symbol, but this one indicates that we were called wrong, on a\n-\t       CTF file with no associated symbol table.  */\n-\t  case ECTF_NOSYMTAB:\n-\t    return -1;\n-\t  case ECTF_NOTDATA:\n-\t  case ECTF_NOTYPEDAT:\n-\t    continue;\n-\t  }\n-\n-      /* Variable name.  */\n-      sym_name = ctf_lookup_symbol_name (fp, i);\n-      if (sym_name[0] == '\\0')\n-\t{\n-\t  if (asprintf (&str, \"%lx -> \", (unsigned long) i) < 0)\n-\t    return (ctf_set_errno (fp, errno));\n-\t}\n-      else\n-\t{\n-\t  if (asprintf (&str, \"%s (%lx) -> \", sym_name, (unsigned long) i) < 0)\n-\t    return (ctf_set_errno (fp, errno));\n-\t}\n+      char *typestr = NULL;\n+      int err = 0;\n \n-      /* Variable type.  */\n-      if ((typestr = ctf_dump_format_type (state->cds_fp, type,\n-\t\t\t\t\t   CTF_ADD_ROOT)) == NULL)\n+      /* Emit the name, if we know it.  */\n+      if (name)\n \t{\n-\t  free (str);\n-\t  return 0;\t\t\t/* Swallow the error.  */\n+\t  if (asprintf (&str, \"%s -> \", name) < 0)\n+\t    goto oom;\n \t}\n+      else\n+\tstr = xstrdup (\"\");\n \n-      str = str_append (str, typestr);\n-      free (typestr);\n-\n-      ctf_dump_append (state, str);\n-    }\n-  return 0;\n-}\n-\n-/* Dump all the function entries into the cds_items.  (As above, there is no\n-   iterator for this section.)  */\n-\n-static int\n-ctf_dump_funcs (ctf_dict_t *fp, ctf_dump_state_t *state)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < fp->ctf_nsyms; i++)\n-    {\n-      char *str;\n-      char *bit = NULL;\n-      const char *sym_name;\n-      ctf_funcinfo_t fi;\n-      ctf_id_t type;\n-\n-      if ((type = ctf_func_info (state->cds_fp, i, &fi)) == CTF_ERR)\n-\tswitch (ctf_errno (state->cds_fp))\n-\t  {\n-\t    /* Most errors are just an indication that this symbol is not a data\n-\t       symbol, but this one indicates that we were called wrong, on a\n-\t       CTF file with no associated symbol table.  */\n-\t  case ECTF_NOSYMTAB:\n-\t    return -1;\n-\t  case ECTF_NOTDATA:\n-\t  case ECTF_NOTFUNC:\n-\t  case ECTF_NOFUNCDAT:\n-\t    continue;\n-\t  }\n-\n-      /* Return type and all args.  */\n-      if ((bit = ctf_type_aname (state->cds_fp, type)) == NULL)\n+      if ((typestr = ctf_type_aname (fp, id)) == NULL)\n \t{\n-\t  ctf_err_warn (fp, 1, ctf_errno (state->cds_fp),\n-\t\t\t_(\"cannot look up return type dumping function type \"\n-\t\t\t  \"for symbol 0x%li\"), (unsigned long) i);\n-\t  free (bit);\n-\t  return -1;\t\t\t/* errno is set for us.  */\n-\t}\n-\n-      /* Replace in the returned string, dropping in the function name.  */\n+\t  if (id == 0 || ctf_errno (fp) == ECTF_NONREPRESENTABLE)\n+\t    {\n+\t      if (asprintf (&typestr, \" (%s)\", _(\"type not represented in CTF\")) < 0)\n+\t\tgoto oom;\n \n-      sym_name = ctf_lookup_symbol_name (fp, i);\n-      if (sym_name[0] != '\\0')\n-\t{\n-\t  char *retstar;\n-\t  char *new_bit;\n-\t  char *walk;\n+\t      goto out;\n+\t    }\n \n-\t  new_bit = malloc (strlen (bit) + 1 + strlen (sym_name));\n-\t  if (!new_bit)\n+\t  if (asprintf (&typestr, ctf_errmsg (ctf_errno (fp))) < 0)\n \t    goto oom;\n \n-\t  /* See ctf_type_aname.  */\n-\t  retstar = strstr (bit, \"(*) (\");\n-\t  if (!ctf_assert (fp, retstar))\n-\t    goto assert_err;\n-\t  retstar += 2;\t\t\t/* After the '*' */\n-\n-\t  /* C is not good at search-and-replace.  */\n-\t  walk = new_bit;\n-\t  memcpy (walk, bit, retstar - bit);\n-\t  walk += (retstar - bit);\n-\t  strcpy (walk, sym_name);\n-\t  walk += strlen (sym_name);\n-\t  strcpy (walk, retstar);\n-\n-\t  free (bit);\n-\t  bit = new_bit;\n+\t  err = -1;\n+\t  goto out;\n \t}\n \n-      if (asprintf (&str, \"Symbol 0x%lx: %s\", (unsigned long) i, bit) < 0)\n-\tgoto oom;\n-      free (bit);\n-\n+      str = str_append (str, typestr);\n+      str = str_append (str, \"\\n\");\n       ctf_dump_append (state, str);\n       continue;\n \n     oom:\n-      free (bit);\n-      return (ctf_set_errno (fp, errno));\n-\n-    assert_err:\n-      free (bit);\n-      return -1;\t\t/* errno is set for us.  */\n+      ctf_set_errno (fp, ENOMEM);\n+      ctf_next_destroy (i);\n+      return -1;\n+    out:\n+      str = str_append (str, typestr);\n+      free (typestr);\n+      ctf_dump_append (state, str);\n+      ctf_next_destroy (i);\n+      return err;\t\t\t\t/* errno is set for us.  */\n     }\n   return 0;\n }\n@@ -697,11 +645,11 @@ ctf_dump (ctf_dict_t *fp, ctf_dump_state_t **statep, ctf_sect_names_t sect,\n \t    }\n \t  break;\n \tcase CTF_SECT_OBJT:\n-\t  if (ctf_dump_objts (fp, state) < 0)\n+\t  if (ctf_dump_objts (fp, state, 0) < 0)\n \t    goto end;\t\t\t/* errno is set for us.  */\n \t  break;\n \tcase CTF_SECT_FUNC:\n-\t  if (ctf_dump_funcs (fp, state) < 0)\n+\t  if (ctf_dump_objts (fp, state, 1) < 0)\n \t    goto end;\t\t\t/* errno is set for us.  */\n \t  break;\n \tcase CTF_SECT_VAR:"
    }
  ]
}