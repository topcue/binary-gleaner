{
  "sha": "7b961964f86618773218c067bfff066b2bff8328",
  "node_id": "C_kwDOANOeidoAKDdiOTYxOTY0Zjg2NjE4NzczMjE4YzA2N2JmZmYwNjZiMmJmZjgzMjg",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-01T14:40:02Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-09T02:00:39Z"
    },
    "message": "gdbserver: hide fork child threads from GDB\n\nThis patch aims at fixing a bug where an inferior is unexpectedly\ncreated when a fork happens at the same time as another event, and that\nother event is reported to GDB first (and the fork event stays pending\nin GDBserver).  This happens for example when we step a thread and\nanother thread forks at the same time.  The bug looks like (if I\nreproduce the included test by hand):\n\n    (gdb) show detach-on-fork\n    Whether gdb will detach the child of a fork is on.\n    (gdb) show follow-fork-mode\n    Debugger response to a program call of fork or vfork is \"parent\".\n    (gdb) si\n    [New inferior 2]\n    Reading /home/simark/build/binutils-gdb/gdb/testsuite/outputs/gdb.threads/step-while-fork-in-other-thread/step-while-fork-in-other-thread from remote target...\n    Reading /home/simark/build/binutils-gdb/gdb/testsuite/outputs/gdb.threads/step-while-fork-in-other-thread/step-while-fork-in-other-thread from remote target...\n    Reading symbols from target:/home/simark/build/binutils-gdb/gdb/testsuite/outputs/gdb.threads/step-while-fork-in-other-thread/step-while-fork-in-other-thread...\n    [New Thread 965190.965190]\n    [Switching to Thread 965190.965190]\n    Remote 'g' packet reply is too long (expected 560 bytes, got 816 bytes): ... <long series of bytes>\n\nThe sequence of events leading to the problem is:\n\n - We are using the all-stop user-visible mode as well as the\n   synchronous / all-stop variant of the remote protocol\n - We have two threads, thread A that we single-step and thread B that\n   calls fork at the same time\n - GDBserver's linux_process_target::wait pulls the \"single step\n   complete SIGTRAP\" and the \"fork\" events from the kernel.  It\n   arbitrarily choses one event to report, it happens to be the\n   single-step SIGTRAP.  The fork stays pending in the thread_info.\n - GDBserver send that SIGTRAP as a stop reply to GDB\n - While in stop_all_threads, GDB calls update_thread_list, which ends\n   up querying the remote thread list using qXfer:threads:read.\n - In the reply, GDBserver includes the fork child created as a result\n   of thread B's fork.\n - GDB-side, the remote target sees the new PID, calls\n   remote_notice_new_inferior, which ends up unexpectedly creating a new\n   inferior, and things go downhill from there.\n\nThe problem here is that as long as GDB did not process the fork event,\nit should pretend the fork child does not exist.  Ultimately, this event\nwill be reported, we'll go through follow_fork, and that process will be\ndetached.\n\nThe remote target (GDB-side), has some code to remove from the reported\nthread list the threads that are the result of forks not processed by\nGDB yet.  But that only works for fork events that have made their way\nto the remote target (GDB-side), but haven't been consumed by the core\nyet, so are still lingering as pending stop replies in the remote target\n(see remove_new_fork_children in remote.c).  But in our case, the fork\nevent hasn't made its way to the GDB-side remote target.  We need to\nimplement the same kind of logic GDBserver-side: if there exists a\nthread / inferior that is the result of a fork event GDBserver hasn't\nreported yet, it should exclude that thread / inferior from the reported\nthread list.\n\nThis was actually discussed a while ago, but not implemented AFAIK:\n\n    https://pi.simark.ca/gdb-patches/1ad9f5a8-d00e-9a26-b0c9-3f4066af5142@redhat.com/#t\n    https://sourceware.org/pipermail/gdb-patches/2016-June/133906.html\n\nImplementation details-wise, the fix for this is all in GDBserver.  The\nLinux layer of GDBserver already tracks unreported fork parent / child\nrelationships using the lwp_info::fork_relative, in order to avoid\nwildcard actions resuming fork childs unknown to GDB.  This information\nneeds to be made available to the handle_qxfer_threads_worker function,\nso it can filter the reported threads.  Add a new thread_pending_parent\ntarget function that allows the Linux target to return the parent of an\neventual fork child.\n\nTesting-wise, the test replicates pretty-much the sequence of events\nshown above.  The setup of the test makes it such that the main thread\nis about to fork.  We stepi the other thread, so that the step completes\nvery quickly, in a single event.  Meanwhile, the main thread is resumed,\nso very likely has time to call fork.  This means that the bug may not\nreproduce every time (if the main thread does not have time to call\nfork), but it will reproduce more often than not.  The test fails\nwithout the fix applied on the native-gdbserver and\nnative-extended-gdbserver boards.\n\nAt some point I suspected that which thread called fork and which thread\ndid the step influenced the order in which the events were reported, and\ntherefore the reproducibility of the bug.  So I made the test try  both\ncombinations: main thread forks while other thread steps, and vice\nversa.  I'm not sure this is still necessary, but I left it there\nanyway.  It doesn't hurt to test a few more combinations.\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=28288\nChange-Id: I2158d5732fc7d7ca06b0eb01f88cf27bf527b990",
    "tree": {
      "sha": "c94e87d2ceb8e9f3372de02f4431a1d97b94a689",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c94e87d2ceb8e9f3372de02f4431a1d97b94a689"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7b961964f86618773218c067bfff066b2bff8328",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7b961964f86618773218c067bfff066b2bff8328",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7b961964f86618773218c067bfff066b2bff8328",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7b961964f86618773218c067bfff066b2bff8328/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9aecb5778dee567c8581185a4b9badeb8d565997",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9aecb5778dee567c8581185a4b9badeb8d565997",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9aecb5778dee567c8581185a4b9badeb8d565997"
    }
  ],
  "stats": {
    "total": 223,
    "additions": 223,
    "deletions": 0
  },
  "files": [
    {
      "sha": "a39ca75a49aca19469b0285da3b916b57950c5f9",
      "filename": "gdb/testsuite/gdb.threads/pending-fork-event.c",
      "status": "added",
      "additions": 82,
      "deletions": 0,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b961964f86618773218c067bfff066b2bff8328/gdb/testsuite/gdb.threads/pending-fork-event.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b961964f86618773218c067bfff066b2bff8328/gdb/testsuite/gdb.threads/pending-fork-event.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/pending-fork-event.c?ref=7b961964f86618773218c067bfff066b2bff8328",
      "patch": "@@ -0,0 +1,82 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <pthread.h>\n+#include <unistd.h>\n+#include <assert.h>\n+\n+static volatile int release_forking_thread = 0;\n+static int x;\n+static pthread_barrier_t barrier;\n+\n+static void\n+break_here (void)\n+{\n+  x++;\n+}\n+\n+static void\n+do_fork (void)\n+{\n+  pthread_barrier_wait (&barrier);\n+\n+  while (!release_forking_thread);\n+\n+  if (FORK_FUNCTION () == 0)\n+    _exit (0);\n+\n+}\n+\n+static void *\n+thread_func (void *p)\n+{\n+#if defined(MAIN_THREAD_FORKS)\n+  break_here ();\n+#elif defined(OTHER_THREAD_FORKS)\n+  do_fork ();\n+#else\n+# error \"MAIN_THREAD_FORKS or OTHER_THREAD_FORKS must be defined\"\n+#endif\n+}\n+\n+\n+int\n+main (void)\n+{\n+  pthread_t thread;\n+  int ret;\n+\n+  pthread_barrier_init (&barrier, NULL, 2);\n+\n+  alarm (30);\n+  ret = pthread_create (&thread, NULL, thread_func, NULL);\n+  assert (ret == 0);\n+\n+  pthread_barrier_wait (&barrier);\n+\n+#if defined(MAIN_THREAD_FORKS)\n+  do_fork ();\n+#elif defined(OTHER_THREAD_FORKS)\n+  break_here ();\n+#else\n+# error \"MAIN_THREAD_FORKS or OTHER_THREAD_FORKS must be defined\"\n+#endif\n+\n+  pthread_join (thread, NULL);\n+\n+  return 0;\n+}"
    },
    {
      "sha": "51af07f56bdd20e130d0cd193eb09978b563c36c",
      "filename": "gdb/testsuite/gdb.threads/pending-fork-event.exp",
      "status": "added",
      "additions": 79,
      "deletions": 0,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b961964f86618773218c067bfff066b2bff8328/gdb/testsuite/gdb.threads/pending-fork-event.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b961964f86618773218c067bfff066b2bff8328/gdb/testsuite/gdb.threads/pending-fork-event.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/pending-fork-event.exp?ref=7b961964f86618773218c067bfff066b2bff8328",
      "patch": "@@ -0,0 +1,79 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test that we handle well, in all-stop, a fork happening in a thread B while\n+# doing a step-like command in a thread A.\n+#\n+# A buggy GDB / GDBserver combo would notice the thread of the child process\n+# of the (still unprocessed) fork event, and erroneously create a new inferior\n+# for it.  Once fixed, the child process' thread is hidden by whoever holds the\n+# pending fork event.\n+\n+standard_testfile\n+\n+proc do_test { target-non-stop who_forks fork_function } {\n+\n+    set opts [list debug \"additional_flags=-DFORK_FUNCTION=$fork_function\"]\n+\n+    # WHO_FORKS says which of the main or other thread calls (v)fork.  The\n+    # thread that does not call (v)fork is the one who tries to step.\n+    if { $who_forks == \"main\" } {\n+\tlappend opts \"additional_flags=-DMAIN_THREAD_FORKS\"\n+\tset this_binfile ${::binfile}-main-${fork_function}\n+    } elseif { $who_forks == \"other\" } {\n+\tlappend opts \"additional_flags=-DOTHER_THREAD_FORKS\"\n+\tset this_binfile ${::binfile}-other-${fork_function}\n+    } else {\n+\terror \"invalid who_forks value: $who_forks\"\n+    }\n+\n+    if { [gdb_compile_pthreads \"$::srcdir/$::subdir/$::srcfile\" $this_binfile executable $opts] != \"\" } {\n+\treturn\n+    }\n+\n+    save_vars { ::GDBFLAGS } {\n+\tappend ::GDBFLAGS \" -ex \\\"maintenance set target-non-stop ${target-non-stop}\\\"\"\n+\tclean_restart $this_binfile\n+    }\n+\n+    if {![runto_main]} {\n+\tfail \"could not run to main\"\n+\treturn\n+    }\n+\n+    # Run until breakpoint in the second thread.\n+    gdb_test \"break break_here\" \"Breakpoint $::decimal.*\"\n+    gdb_continue_to_breakpoint \"thread started\"\n+\n+    # Delete the breakpoint so the thread doesn't do a step-over.\n+    delete_breakpoints\n+\n+    # Let the forking thread make progress during the step.\n+    gdb_test \"p release_forking_thread = 1\" \" = 1\"\n+\n+    # stepi the non-forking thread.\n+    gdb_test \"stepi\"\n+\n+    # Make sure there's still a single inferior.\n+    gdb_test \"info inferior\" {\\* 1 [^\\r\\n]+}\n+}\n+\n+foreach_with_prefix target-non-stop { auto on off } {\n+    foreach_with_prefix who_forks { main other } {\n+\tforeach_with_prefix fork_function { fork vfork } {\n+\t    do_test ${target-non-stop} $who_forks $fork_function\n+\t}\n+    }\n+}"
    },
    {
      "sha": "34991df449bfb859b1d753fee334ce684d7b4ede",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b961964f86618773218c067bfff066b2bff8328/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b961964f86618773218c067bfff066b2bff8328/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=7b961964f86618773218c067bfff066b2bff8328",
      "patch": "@@ -7119,6 +7119,17 @@ linux_process_target::thread_handle (ptid_t ptid, gdb_byte **handle,\n }\n #endif\n \n+thread_info *\n+linux_process_target::thread_pending_parent (thread_info *thread)\n+{\n+  lwp_info *parent = get_thread_lwp (thread)->pending_parent ();\n+\n+  if (parent == nullptr)\n+    return nullptr;\n+\n+  return get_lwp_thread (parent);\n+}\n+\n /* Default implementation of linux_target_ops method \"set_pc\" for\n    32-bit pc register which is literally named \"pc\".  */\n "
    },
    {
      "sha": "819f915ea9a38e06fe4aaaaf052e9b7ba5926053",
      "filename": "gdbserver/linux-low.h",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b961964f86618773218c067bfff066b2bff8328/gdbserver/linux-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b961964f86618773218c067bfff066b2bff8328/gdbserver/linux-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.h?ref=7b961964f86618773218c067bfff066b2bff8328",
      "patch": "@@ -311,6 +311,8 @@ class linux_process_target : public process_stratum_target\n \t\t      int *handle_len) override;\n #endif\n \n+  thread_info *thread_pending_parent (thread_info *thread) override;\n+\n   bool supports_catch_syscall () override;\n \n   /* Return the information to access registers.  This has public\n@@ -721,6 +723,33 @@ struct pending_signal\n \n struct lwp_info\n {\n+  /* If this LWP is a fork child that wasn't reported to GDB yet, return\n+     its parent, else nullptr.  */\n+  lwp_info *pending_parent () const\n+  {\n+    if (this->fork_relative == nullptr)\n+      return nullptr;\n+\n+    gdb_assert (this->fork_relative->fork_relative == this);\n+\n+    /* In a fork parent/child relationship, the parent has a status pending and\n+       the child does not, and a thread can only be in one such relationship\n+       at most.  So we can recognize who is the parent based on which one has\n+       a pending status.  */\n+    gdb_assert (!!this->status_pending_p\n+\t\t!= !!this->fork_relative->status_pending_p);\n+\n+    if (!this->fork_relative->status_pending_p)\n+      return nullptr;\n+\n+    const target_waitstatus &ws\n+      = this->fork_relative->waitstatus;\n+    gdb_assert (ws.kind () == TARGET_WAITKIND_FORKED\n+\t\t|| ws.kind () == TARGET_WAITKIND_VFORKED);\n+\n+    return this->fork_relative;\n+  }\n+\n   /* Backlink to the parent object.  */\n   struct thread_info *thread = nullptr;\n "
    },
    {
      "sha": "8dde6fb0729512e24d741a67900f7cdbf744829d",
      "filename": "gdbserver/server.cc",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b961964f86618773218c067bfff066b2bff8328/gdbserver/server.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b961964f86618773218c067bfff066b2bff8328/gdbserver/server.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.cc?ref=7b961964f86618773218c067bfff066b2bff8328",
      "patch": "@@ -1656,6 +1656,12 @@ handle_qxfer_threads_worker (thread_info *thread, struct buffer *buffer)\n   gdb_byte *handle;\n   bool handle_status = target_thread_handle (ptid, &handle, &handle_len);\n \n+  /* If this is a fork or vfork child (has a fork parent), GDB does not yet\n+     know about this process, and must not know about it until it gets the\n+     corresponding (v)fork event.  Exclude this thread from the list.  */\n+  if (target_thread_pending_parent (thread) != nullptr)\n+    return;\n+\n   write_ptid (ptid_s, ptid);\n \n   buffer_xml_printf (buffer, \"<thread id=\\\"%s\\\"\", ptid_s);"
    },
    {
      "sha": "136b5104de8583661904adf5c321c4303c231c08",
      "filename": "gdbserver/target.cc",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b961964f86618773218c067bfff066b2bff8328/gdbserver/target.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b961964f86618773218c067bfff066b2bff8328/gdbserver/target.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/target.cc?ref=7b961964f86618773218c067bfff066b2bff8328",
      "patch": "@@ -835,6 +835,12 @@ process_stratum_target::thread_handle (ptid_t ptid, gdb_byte **handle,\n   return false;\n }\n \n+thread_info *\n+process_stratum_target::thread_pending_parent (thread_info *thread)\n+{\n+  return nullptr;\n+}\n+\n bool\n process_stratum_target::supports_software_single_step ()\n {"
    },
    {
      "sha": "1b0a1201d755672a9b0dd0512a23b6717d8b442f",
      "filename": "gdbserver/target.h",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b961964f86618773218c067bfff066b2bff8328/gdbserver/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b961964f86618773218c067bfff066b2bff8328/gdbserver/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/target.h?ref=7b961964f86618773218c067bfff066b2bff8328",
      "patch": "@@ -488,6 +488,10 @@ class process_stratum_target\n   virtual bool thread_handle (ptid_t ptid, gdb_byte **handle,\n \t\t\t      int *handle_len);\n \n+  /* If THREAD is a fork child that was not reported to GDB, return its parent\n+     else nullptr.  */\n+  virtual thread_info *thread_pending_parent (thread_info *thread);\n+\n   /* Returns true if the target can software single step.  */\n   virtual bool supports_software_single_step ();\n \n@@ -698,6 +702,12 @@ void done_accessing_memory (void);\n #define target_thread_handle(ptid, handle, handle_len) \\\n   the_target->thread_handle (ptid, handle, handle_len)\n \n+static inline thread_info *\n+target_thread_pending_parent (thread_info *thread)\n+{\n+  return the_target->thread_pending_parent (thread);\n+}\n+\n int read_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len);\n \n int set_desired_thread ();"
    }
  ]
}