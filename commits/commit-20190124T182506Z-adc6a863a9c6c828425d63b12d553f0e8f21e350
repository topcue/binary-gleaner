{
  "sha": "adc6a863a9c6c828425d63b12d553f0e8f21e350",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWRjNmE4NjNhOWM2YzgyODQyNWQ2M2IxMmQ1NTNmMGU4ZjIxZTM1MA==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-01-24T18:25:06Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-01-24T18:25:06Z"
    },
    "message": "target_pass_signals/target_program_signals: Use gdb::array_view\n\nThis replaces the pointer and length parameters of target_pass_signals\nand target_program_signals with a gdb::array_view parameter, and fixes\nthe fallout.\n\nIn infrun.c, the signal_stop, signal_print, signal_program,\nsignal_catch, signal_pass globals are currently pointers to\nheap-allocated memory.  I see no point in that, so I converted them to\narrays.  This allows simplifying the calls to\ntarget_pass_signals/target_program_signals, since we can pass the\narray directly, which can implicitly convert to gdb::array_view.\n\ngdb/ChangeLog:\n2019-01-24  Pedro Alves  <palves@redhat.com>\n\n\t* infrun.c (signal_stop, signal_print, signal_program)\n\t(signal_catch, signal_pass): Now arrays instead of pointers.\n\t(update_signals_program_target, do_target_resume)\n\t(signal_catch_update, handle_command, _initialize_infrun): Adjust.\n\t* linux-nat.c (linux_nat_target::pass_signals)\n\t(linux_nat_target::create_inferior, linux_nat_target::attach):\n\tAdjust.\n\t* linux-nat.h (linux_nat_target::pass_signals): Adjust.\n\t* nto-procfs.c (nto_procfs_target::pass_signals): Adjust.\n\t* procfs.c (procfs_target::pass_signals): Adjust.\n\t* record-full.c (record_full_target::resume): Adjust.\n\t* remote.c (remote_target::pass_signals)\n\t(remote_target::program_signals): Adjust.\n\t* target-debug.h (target_debug_print_signals): Now takes a\n\tgdb::array_view as parameter.  Adjust.\n\t* target.h (target_ops) <pass_signals, program_signals>: Replace\n\tpointer and length parameters with gdb::array_view.\n\t(target_pass_signals, target_program_signals): Likewise.\n\t* target-delegates.c: Regenerate.",
    "tree": {
      "sha": "707b67c07bca0de636702016728f8eb8dd8f49a5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/707b67c07bca0de636702016728f8eb8dd8f49a5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/adc6a863a9c6c828425d63b12d553f0e8f21e350",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/adc6a863a9c6c828425d63b12d553f0e8f21e350",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/adc6a863a9c6c828425d63b12d553f0e8f21e350",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/adc6a863a9c6c828425d63b12d553f0e8f21e350/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3046d67a0e29686ec18abd719660969c97973063",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3046d67a0e29686ec18abd719660969c97973063",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3046d67a0e29686ec18abd719660969c97973063"
    }
  ],
  "stats": {
    "total": 198,
    "additions": 100,
    "deletions": 98
  },
  "files": [
    {
      "sha": "1a3a2ed8c32ba272dc9f81608251f2a0a389b5b8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -1,3 +1,25 @@\n+2019-01-24  Pedro Alves  <palves@redhat.com>\n+\n+\t* infrun.c (signal_stop, signal_print, signal_program)\n+\t(signal_catch, signal_pass): Now arrays instead of pointers.\n+\t(update_signals_program_target, do_target_resume)\n+\t(signal_catch_update, handle_command, _initialize_infrun): Adjust.\n+\t* linux-nat.c (linux_nat_target::pass_signals)\n+\t(linux_nat_target::create_inferior, linux_nat_target::attach):\n+\tAdjust.\n+\t* linux-nat.h (linux_nat_target::pass_signals): Adjust.\n+\t* nto-procfs.c (nto_procfs_target::pass_signals): Adjust.\n+\t* procfs.c (procfs_target::pass_signals): Adjust.\n+\t* record-full.c (record_full_target::resume): Adjust.\n+\t* remote.c (remote_target::pass_signals)\n+\t(remote_target::program_signals): Adjust.\n+\t* target-debug.h (target_debug_print_signals): Now takes a\n+\tgdb::array_view as parameter.  Adjust.\n+\t* target.h (target_ops) <pass_signals, program_signals>: Replace\n+\tpointer and length parameters with gdb::array_view.\n+\t(target_pass_signals, target_program_signals): Likewise.\n+\t* target-delegates.c: Regenerate.\n+\n 2019-01-24  Pedro Alves  <palves@redhat.com>\n \n \t* common/forward-scope-exit.h"
    },
    {
      "sha": "f696558a46489bf253170a9ae9428c321ae2a587",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 15,
      "deletions": 27,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -306,20 +306,19 @@ update_observer_mode (void)\n \n /* Tables of how to react to signals; the user sets them.  */\n \n-static unsigned char *signal_stop;\n-static unsigned char *signal_print;\n-static unsigned char *signal_program;\n+static unsigned char signal_stop[GDB_SIGNAL_LAST];\n+static unsigned char signal_print[GDB_SIGNAL_LAST];\n+static unsigned char signal_program[GDB_SIGNAL_LAST];\n \n /* Table of signals that are registered with \"catch signal\".  A\n    non-zero entry indicates that the signal is caught by some \"catch\n-   signal\" command.  This has size GDB_SIGNAL_LAST, to accommodate all\n-   signals.  */\n-static unsigned char *signal_catch;\n+   signal\" command.  */\n+static unsigned char signal_catch[GDB_SIGNAL_LAST];\n \n /* Table of signals that the target may silently handle.\n    This is automatically determined from the flags above,\n    and simply cached here.  */\n-static unsigned char *signal_pass;\n+static unsigned char signal_pass[GDB_SIGNAL_LAST];\n \n #define SET_SIGS(nsigs,sigs,flags) \\\n   do { \\\n@@ -343,7 +342,7 @@ static unsigned char *signal_pass;\n void\n update_signals_program_target (void)\n {\n-  target_program_signals ((int) GDB_SIGNAL_LAST, signal_program);\n+  target_program_signals (signal_program);\n }\n \n /* Value to pass to target_resume() to cause all threads to resume.  */\n@@ -2219,9 +2218,9 @@ do_target_resume (ptid_t resume_ptid, int step, enum gdb_signal sig)\n        valid.  */\n   if (step_over_info_valid_p ()\n       || displaced_step_in_progress (tp->inf))\n-    target_pass_signals (0, NULL);\n+    target_pass_signals ({});\n   else\n-    target_pass_signals ((int) GDB_SIGNAL_LAST, signal_pass);\n+    target_pass_signals (signal_pass);\n \n   target_resume (resume_ptid, step, sig);\n \n@@ -8251,7 +8250,7 @@ signal_catch_update (const unsigned int *info)\n   for (i = 0; i < GDB_SIGNAL_LAST; ++i)\n     signal_catch[i] = info[i] > 0;\n   signal_cache_update (-1);\n-  target_pass_signals ((int) GDB_SIGNAL_LAST, signal_pass);\n+  target_pass_signals (signal_pass);\n }\n \n static void\n@@ -8287,8 +8286,6 @@ handle_command (const char *args, int from_tty)\n   int sigfirst, siglast;\n   enum gdb_signal oursig;\n   int allsigs;\n-  int nsigs;\n-  unsigned char *sigs;\n \n   if (args == NULL)\n     {\n@@ -8297,9 +8294,8 @@ handle_command (const char *args, int from_tty)\n \n   /* Allocate and zero an array of flags for which signals to handle.  */\n \n-  nsigs = (int) GDB_SIGNAL_LAST;\n-  sigs = (unsigned char *) alloca (nsigs);\n-  memset (sigs, 0, nsigs);\n+  const size_t nsigs = GDB_SIGNAL_LAST;\n+  unsigned char sigs[nsigs] {};\n \n   /* Break the command line up into args.  */\n \n@@ -8436,8 +8432,8 @@ Are you sure you want to change it? \"),\n     if (sigs[signum])\n       {\n \tsignal_cache_update (-1);\n-\ttarget_pass_signals ((int) GDB_SIGNAL_LAST, signal_pass);\n-\ttarget_program_signals ((int) GDB_SIGNAL_LAST, signal_program);\n+\ttarget_pass_signals (signal_pass);\n+\ttarget_program_signals (signal_program);\n \n \tif (from_tty)\n \t  {\n@@ -8963,8 +8959,6 @@ infrun_async_inferior_event_handler (gdb_client_data data)\n void\n _initialize_infrun (void)\n {\n-  int i;\n-  int numsigs;\n   struct cmd_list_element *c;\n \n   /* Register extra event sources in the event loop.  */\n@@ -9046,13 +9040,7 @@ leave it stopped or free to run as needed.\"),\n \t\t\t   &setlist,\n \t\t\t   &showlist);\n \n-  numsigs = (int) GDB_SIGNAL_LAST;\n-  signal_stop = XNEWVEC (unsigned char, numsigs);\n-  signal_print = XNEWVEC (unsigned char, numsigs);\n-  signal_program = XNEWVEC (unsigned char, numsigs);\n-  signal_catch = XNEWVEC (unsigned char, numsigs);\n-  signal_pass = XNEWVEC (unsigned char, numsigs);\n-  for (i = 0; i < numsigs; i++)\n+  for (size_t i = 0; i < GDB_SIGNAL_LAST; i++)\n     {\n       signal_stop[i] = 1;\n       signal_print[i] = 1;"
    },
    {
      "sha": "c285e914d53f6a81322a6b6b5d0ee02564b6734c",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -789,7 +789,8 @@ static sigset_t pass_mask;\n \n /* Update signals to pass to the inferior.  */\n void\n-linux_nat_target::pass_signals (int numsigs, const unsigned char *pass_signals)\n+linux_nat_target::pass_signals\n+  (gdb::array_view<const unsigned char> pass_signals)\n {\n   int signo;\n \n@@ -798,7 +799,7 @@ linux_nat_target::pass_signals (int numsigs, const unsigned char *pass_signals)\n   for (signo = 1; signo < NSIG; signo++)\n     {\n       int target_signo = gdb_signal_from_host (signo);\n-      if (target_signo < numsigs && pass_signals[target_signo])\n+      if (target_signo < pass_signals.size () && pass_signals[target_signo])\n         sigaddset (&pass_mask, signo);\n     }\n }\n@@ -1096,7 +1097,7 @@ linux_nat_target::create_inferior (const char *exec_file,\n      we have to mask the async mode.  */\n \n   /* Make sure we report all signals during startup.  */\n-  pass_signals (0, NULL);\n+  pass_signals ({});\n \n   inf_ptrace_target::create_inferior (exec_file, allargs, env, from_tty);\n }\n@@ -1186,7 +1187,7 @@ linux_nat_target::attach (const char *args, int from_tty)\n   ptid_t ptid;\n \n   /* Make sure we report all signals during attach.  */\n-  pass_signals (0, NULL);\n+  pass_signals ({});\n \n   TRY\n     {"
    },
    {
      "sha": "16f8a584bdedcb3c9d011daafcbf92db5307f8da",
      "filename": "gdb/linux-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/linux-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/linux-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.h?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -45,7 +45,7 @@ class linux_nat_target : public inf_ptrace_target\n \n   ptid_t wait (ptid_t, struct target_waitstatus *, int) override;\n \n-  void pass_signals (int, const unsigned char *) override;\n+  void pass_signals (gdb::array_view<const unsigned char>) override;\n \n   enum target_xfer_status xfer_partial (enum target_object object,\n \t\t\t\t\tconst char *annex,"
    },
    {
      "sha": "40959d7715dd82089658d6b184b023166cb9ec11",
      "filename": "gdb/nto-procfs.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/nto-procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/nto-procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nto-procfs.c?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -109,7 +109,7 @@ struct nto_procfs_target : public inf_child_target\n \n   void mourn_inferior () override;\n \n-  void pass_signals (int, const unsigned char *) override;\n+  void pass_signals (gdb::array_view<const unsigned char>) override;\n \n   bool thread_alive (ptid_t ptid) override;\n \n@@ -1442,8 +1442,8 @@ nto_procfs_target::store_registers (struct regcache *regcache, int regno)\n /* Set list of signals to be handled in the target.  */\n \n void\n-nto_procfs_target::pass_signals (int numsigs,\n-\t\t\t\t const unsigned char *pass_signals)\n+nto_procfs_target::pass_signals\n+  (gdb::array_view<const unsigned char> pass_signals)\n {\n   int signo;\n \n@@ -1452,7 +1452,7 @@ nto_procfs_target::pass_signals (int numsigs,\n   for (signo = 1; signo < NSIG; signo++)\n     {\n       int target_signo = gdb_signal_from_host (signo);\n-      if (target_signo < numsigs && pass_signals[target_signo])\n+      if (target_signo < pass_signals.size () && pass_signals[target_signo])\n         sigdelset (&run.trace, signo);\n     }\n }"
    },
    {
      "sha": "3c1dcba062d78640ed8a2f712d7dbf85e8650b57",
      "filename": "gdb/procfs.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/procfs.c?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -119,7 +119,7 @@ class procfs_target final : public inf_child_target\n \t\t\t\t\tULONGEST offset, ULONGEST len,\n \t\t\t\t\tULONGEST *xfered_len) override;\n \n-  void pass_signals (int, const unsigned char *) override;\n+  void pass_signals (gdb::array_view<const unsigned char>) override;\n \n   void files_info () override;\n \n@@ -2772,7 +2772,7 @@ procfs_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n /* Set up to trace signals in the child process.  */\n \n void\n-procfs_target::pass_signals (int numsigs, const unsigned char *pass_signals)\n+procfs_target::pass_signals (gdb::array_view<const unsigned char> pass_signals)\n {\n   sigset_t signals;\n   procinfo *pi = find_procinfo_or_die (inferior_ptid.pid (), 0);\n@@ -2783,7 +2783,7 @@ procfs_target::pass_signals (int numsigs, const unsigned char *pass_signals)\n   for (signo = 0; signo < NSIG; signo++)\n     {\n       int target_signo = gdb_signal_from_host (signo);\n-      if (target_signo < numsigs && pass_signals[target_signo])\n+      if (target_signo < pass_signals.size () && pass_signals[target_signo])\n \tprdelset (&signals, signo);\n     }\n "
    },
    {
      "sha": "ea0eddb536dc7632c6b6263f604e01e9c8d1e7d9",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -1098,7 +1098,7 @@ record_full_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n         }\n \n       /* Make sure the target beneath reports all signals.  */\n-      target_pass_signals (0, NULL);\n+      target_pass_signals ({});\n \n       this->beneath ()->resume (ptid, step, signal);\n     }"
    },
    {
      "sha": "ad5362114587d29e46d6cc0f86729cd76a8e084d",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -472,12 +472,12 @@ class remote_target : public process_stratum_target\n \n   void mourn_inferior () override;\n \n-  void pass_signals (int, const unsigned char *) override;\n+  void pass_signals (gdb::array_view<const unsigned char>) override;\n \n   int set_syscall_catchpoint (int, bool, int,\n \t\t\t      gdb::array_view<const int>) override;\n \n-  void program_signals (int, const unsigned char *) override;\n+  void program_signals (gdb::array_view<const unsigned char>) override;\n \n   bool thread_alive (ptid_t ptid) override;\n \n@@ -2560,24 +2560,24 @@ record_currthread (struct remote_state *rs, ptid_t currthread)\n    it can simply pass through to the inferior without reporting.  */\n \n void\n-remote_target::pass_signals (int numsigs, const unsigned char *pass_signals)\n+remote_target::pass_signals (gdb::array_view<const unsigned char> pass_signals)\n {\n   if (packet_support (PACKET_QPassSignals) != PACKET_DISABLE)\n     {\n       char *pass_packet, *p;\n-      int count = 0, i;\n+      int count = 0;\n       struct remote_state *rs = get_remote_state ();\n \n-      gdb_assert (numsigs < 256);\n-      for (i = 0; i < numsigs; i++)\n+      gdb_assert (pass_signals.size () < 256);\n+      for (size_t i = 0; i < pass_signals.size (); i++)\n \t{\n \t  if (pass_signals[i])\n \t    count++;\n \t}\n       pass_packet = (char *) xmalloc (count * 3 + strlen (\"QPassSignals:\") + 1);\n       strcpy (pass_packet, \"QPassSignals:\");\n       p = pass_packet + strlen (pass_packet);\n-      for (i = 0; i < numsigs; i++)\n+      for (size_t i = 0; i < pass_signals.size (); i++)\n \t{\n \t  if (pass_signals[i])\n \t    {\n@@ -2686,24 +2686,24 @@ remote_target::set_syscall_catchpoint (int pid, bool needed, int any_count,\n    signals it should pass through to the inferior when detaching.  */\n \n void\n-remote_target::program_signals (int numsigs, const unsigned char *signals)\n+remote_target::program_signals (gdb::array_view<const unsigned char> signals)\n {\n   if (packet_support (PACKET_QProgramSignals) != PACKET_DISABLE)\n     {\n       char *packet, *p;\n-      int count = 0, i;\n+      int count = 0;\n       struct remote_state *rs = get_remote_state ();\n \n-      gdb_assert (numsigs < 256);\n-      for (i = 0; i < numsigs; i++)\n+      gdb_assert (signals.size () < 256);\n+      for (size_t i = 0; i < signals.size (); i++)\n \t{\n \t  if (signals[i])\n \t    count++;\n \t}\n       packet = (char *) xmalloc (count * 3 + strlen (\"QProgramSignals:\") + 1);\n       strcpy (packet, \"QProgramSignals:\");\n       p = packet + strlen (packet);\n-      for (i = 0; i < numsigs; i++)\n+      for (size_t i = 0; i < signals.size (); i++)\n \t{\n \t  if (signal_pass_state (i))\n \t    {\n@@ -4796,7 +4796,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n       gdb_assert (wait_status == NULL);\n \n       /* Report all signals during attach/startup.  */\n-      pass_signals (0, NULL);\n+      pass_signals ({});\n \n       /* If there are already stopped threads, mark them stopped and\n \t report their stops before giving the prompt to the user.  */"
    },
    {
      "sha": "d9f7d46dd92e74cd2dcd290a94f03e94b395f33f",
      "filename": "gdb/target-debug.h",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/target-debug.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/target-debug.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-debug.h?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -209,20 +209,16 @@ target_debug_print_options (int options)\n }\n \n static void\n-target_debug_print_signals (const unsigned char *sigs)\n+target_debug_print_signals (gdb::array_view<const unsigned char> sigs)\n {\n   fputs_unfiltered (\"{\", gdb_stdlog);\n-  if (sigs != NULL)\n-    {\n-      int i;\n-\n-      for (i = 0; i < GDB_SIGNAL_LAST; i++)\n-\tif (sigs[i])\n-\t  {\n-\t    fprintf_unfiltered (gdb_stdlog, \" %s\",\n-\t\t\t\tgdb_signal_to_name ((enum gdb_signal) i));\n-\t  }\n-    }\n+\n+  for (size_t i = 0; i < sigs.size (); i++)\n+    if (sigs[i] != 0)\n+      {\n+\tfprintf_unfiltered (gdb_stdlog, \" %s\",\n+\t\t\t    gdb_signal_to_name ((enum gdb_signal) i));\n+      }\n   fputs_unfiltered (\" }\", gdb_stdlog);\n }\n "
    },
    {
      "sha": "a25851e9cf7b8402bf9e18f3864f39186a86c7a9",
      "filename": "gdb/target-delegates.c",
      "status": "modified",
      "additions": 16,
      "deletions": 20,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/target-delegates.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/target-delegates.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-delegates.c?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -62,8 +62,8 @@ struct dummy_target : public target_ops\n   void follow_exec (struct inferior *arg0, char *arg1) override;\n   int set_syscall_catchpoint (int arg0, bool arg1, int arg2, gdb::array_view<const int> arg3) override;\n   void mourn_inferior () override;\n-  void pass_signals (int arg0, const unsigned char * arg1) override;\n-  void program_signals (int arg0, const unsigned char * arg1) override;\n+  void pass_signals (gdb::array_view<const unsigned char> arg0) override;\n+  void program_signals (gdb::array_view<const unsigned char> arg0) override;\n   bool thread_alive (ptid_t arg0) override;\n   void update_thread_list () override;\n   const char *pid_to_str (ptid_t arg0) override;\n@@ -229,8 +229,8 @@ struct debug_target : public target_ops\n   void follow_exec (struct inferior *arg0, char *arg1) override;\n   int set_syscall_catchpoint (int arg0, bool arg1, int arg2, gdb::array_view<const int> arg3) override;\n   void mourn_inferior () override;\n-  void pass_signals (int arg0, const unsigned char * arg1) override;\n-  void program_signals (int arg0, const unsigned char * arg1) override;\n+  void pass_signals (gdb::array_view<const unsigned char> arg0) override;\n+  void program_signals (gdb::array_view<const unsigned char> arg0) override;\n   bool thread_alive (ptid_t arg0) override;\n   void update_thread_list () override;\n   const char *pid_to_str (ptid_t arg0) override;\n@@ -1659,48 +1659,44 @@ debug_target::mourn_inferior ()\n }\n \n void\n-target_ops::pass_signals (int arg0, const unsigned char * arg1)\n+target_ops::pass_signals (gdb::array_view<const unsigned char> arg0)\n {\n-  this->beneath ()->pass_signals (arg0, arg1);\n+  this->beneath ()->pass_signals (arg0);\n }\n \n void\n-dummy_target::pass_signals (int arg0, const unsigned char * arg1)\n+dummy_target::pass_signals (gdb::array_view<const unsigned char> arg0)\n {\n }\n \n void\n-debug_target::pass_signals (int arg0, const unsigned char * arg1)\n+debug_target::pass_signals (gdb::array_view<const unsigned char> arg0)\n {\n   fprintf_unfiltered (gdb_stdlog, \"-> %s->pass_signals (...)\\n\", this->beneath ()->shortname ());\n-  this->beneath ()->pass_signals (arg0, arg1);\n+  this->beneath ()->pass_signals (arg0);\n   fprintf_unfiltered (gdb_stdlog, \"<- %s->pass_signals (\", this->beneath ()->shortname ());\n-  target_debug_print_int (arg0);\n-  fputs_unfiltered (\", \", gdb_stdlog);\n-  target_debug_print_signals (arg1);\n+  target_debug_print_signals (arg0);\n   fputs_unfiltered (\")\\n\", gdb_stdlog);\n }\n \n void\n-target_ops::program_signals (int arg0, const unsigned char * arg1)\n+target_ops::program_signals (gdb::array_view<const unsigned char> arg0)\n {\n-  this->beneath ()->program_signals (arg0, arg1);\n+  this->beneath ()->program_signals (arg0);\n }\n \n void\n-dummy_target::program_signals (int arg0, const unsigned char * arg1)\n+dummy_target::program_signals (gdb::array_view<const unsigned char> arg0)\n {\n }\n \n void\n-debug_target::program_signals (int arg0, const unsigned char * arg1)\n+debug_target::program_signals (gdb::array_view<const unsigned char> arg0)\n {\n   fprintf_unfiltered (gdb_stdlog, \"-> %s->program_signals (...)\\n\", this->beneath ()->shortname ());\n-  this->beneath ()->program_signals (arg0, arg1);\n+  this->beneath ()->program_signals (arg0);\n   fprintf_unfiltered (gdb_stdlog, \"<- %s->program_signals (\", this->beneath ()->shortname ());\n-  target_debug_print_int (arg0);\n-  fputs_unfiltered (\", \", gdb_stdlog);\n-  target_debug_print_signals (arg1);\n+  target_debug_print_signals (arg0);\n   fputs_unfiltered (\")\\n\", gdb_stdlog);\n }\n "
    },
    {
      "sha": "6f597a8a1d8cf6cd792473440c17b5be9dcb468d",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -2111,15 +2111,15 @@ make_scoped_defer_target_commit_resume ()\n }\n \n void\n-target_pass_signals (int numsigs, const unsigned char *pass_signals)\n+target_pass_signals (gdb::array_view<const unsigned char> pass_signals)\n {\n-  current_top_target ()->pass_signals (numsigs, pass_signals);\n+  current_top_target ()->pass_signals (pass_signals);\n }\n \n void\n-target_program_signals (int numsigs, const unsigned char *program_signals)\n+target_program_signals (gdb::array_view<const unsigned char> program_signals)\n {\n-  current_top_target ()->program_signals (numsigs, program_signals);\n+  current_top_target ()->program_signals (program_signals);\n }\n \n static int"
    },
    {
      "sha": "d9b947af2b0f7f3228000aaf2d26e19c44f7ed53",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/adc6a863a9c6c828425d63b12d553f0e8f21e350/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=adc6a863a9c6c828425d63b12d553f0e8f21e350",
      "patch": "@@ -637,14 +637,12 @@ struct target_ops\n \n     /* Documentation of this routine is provided with the corresponding\n        target_* macro.  */\n-    virtual void pass_signals (int,\n-\t\t\t       const unsigned char * TARGET_DEBUG_PRINTER (target_debug_print_signals))\n+    virtual void pass_signals (gdb::array_view<const unsigned char> TARGET_DEBUG_PRINTER (target_debug_print_signals))\n       TARGET_DEFAULT_IGNORE ();\n \n     /* Documentation of this routine is provided with the\n        corresponding target_* function.  */\n-    virtual void program_signals (int,\n-\t\t\t\t  const unsigned char * TARGET_DEBUG_PRINTER (target_debug_print_signals))\n+    virtual void program_signals (gdb::array_view<const unsigned char> TARGET_DEBUG_PRINTER (target_debug_print_signals))\n       TARGET_DEFAULT_IGNORE ();\n \n     virtual bool thread_alive (ptid_t ptid)\n@@ -1682,7 +1680,7 @@ extern int target_can_run ();\n \n /* Set list of signals to be handled in the target.\n \n-   PASS_SIGNALS is an array of size NSIG, indexed by target signal number\n+   PASS_SIGNALS is an array indexed by target signal number\n    (enum gdb_signal).  For every signal whose entry in this array is\n    non-zero, the target is allowed -but not required- to skip reporting\n    arrival of the signal to the GDB core by returning from target_wait,\n@@ -1692,12 +1690,13 @@ extern int target_can_run ();\n    about to receive a signal, it needs to be reported in any case, even\n    if mentioned in a previous target_pass_signals call.   */\n \n-extern void target_pass_signals (int nsig, const unsigned char *pass_signals);\n+extern void target_pass_signals\n+  (gdb::array_view<const unsigned char> pass_signals);\n \n /* Set list of signals the target may pass to the inferior.  This\n    directly maps to the \"handle SIGNAL pass/nopass\" setting.\n \n-   PROGRAM_SIGNALS is an array of size NSIG, indexed by target signal\n+   PROGRAM_SIGNALS is an array indexed by target signal\n    number (enum gdb_signal).  For every signal whose entry in this\n    array is non-zero, the target is allowed to pass the signal to the\n    inferior.  Signals not present in the array shall be silently\n@@ -1708,8 +1707,8 @@ extern void target_pass_signals (int nsig, const unsigned char *pass_signals);\n    example, when detaching (as threads may have been suspended with\n    pending signals not reported to GDB).  */\n \n-extern void target_program_signals (int nsig,\n-\t\t\t\t    const unsigned char *program_signals);\n+extern void target_program_signals\n+  (gdb::array_view<const unsigned char> program_signals);\n \n /* Check to see if a thread is still alive.  */\n "
    }
  ]
}