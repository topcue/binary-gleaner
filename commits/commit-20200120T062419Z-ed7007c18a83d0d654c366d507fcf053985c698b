{
  "sha": "ed7007c18a83d0d654c366d507fcf053985c698b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWQ3MDA3YzE4YTgzZDBkNjU0YzM2NmQ1MDdmY2YwNTM5ODVjNjk4Yg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-20T06:04:20Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-20T06:24:19Z"
    },
    "message": "PowerPC64 ppc_elf_hash_entry, defined_sym_val, is_tls_get_addr\n\n\t* elf64-ppc.c (ppc_elf_hash_entry): New function, use throughout file.\n\t(defined_sym_val, is_tls_get_addr): Likewise.",
    "tree": {
      "sha": "e7ddd1e12b479a7b4ef8da9321770717da9f997c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e7ddd1e12b479a7b4ef8da9321770717da9f997c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ed7007c18a83d0d654c366d507fcf053985c698b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ed7007c18a83d0d654c366d507fcf053985c698b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ed7007c18a83d0d654c366d507fcf053985c698b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ed7007c18a83d0d654c366d507fcf053985c698b/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4d6cbb644265d565eb743ffa2bd04092c2b05518",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d6cbb644265d565eb743ffa2bd04092c2b05518",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4d6cbb644265d565eb743ffa2bd04092c2b05518"
    }
  ],
  "stats": {
    "total": 190,
    "additions": 96,
    "deletions": 94
  },
  "files": [
    {
      "sha": "88db1f6a58acf03fd208283408ecec68fab54bf4",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ed7007c18a83d0d654c366d507fcf053985c698b/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ed7007c18a83d0d654c366d507fcf053985c698b/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=ed7007c18a83d0d654c366d507fcf053985c698b",
      "patch": "@@ -1,3 +1,8 @@\n+2020-01-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf64-ppc.c (ppc_elf_hash_entry): New function, use throughout file.\n+\t(defined_sym_val, is_tls_get_addr): Likewise.\n+\n 2020-01-18  Nick Clifton  <nickc@redhat.com>\n \n \t* version.m4 (BFD_VERSION): Set to 2.34.50."
    },
    {
      "sha": "0e906cb481e0f5d602f6a159d495af35388338c6",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 91,
      "deletions": 94,
      "changes": 185,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ed7007c18a83d0d654c366d507fcf053985c698b/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ed7007c18a83d0d654c366d507fcf053985c698b/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=ed7007c18a83d0d654c366d507fcf053985c698b",
      "patch": "@@ -3112,6 +3112,12 @@ struct ppc_link_hash_entry\n #define NON_GOT        256\t/* local symbol plt, not stored.  */\n };\n \n+static inline struct ppc_link_hash_entry *\n+ppc_elf_hash_entry (struct elf_link_hash_entry *ent)\n+{\n+  return (struct ppc_link_hash_entry *) ent;\n+}\n+\n /* ppc64 ELF linker hash table.  */\n \n struct ppc_link_hash_table\n@@ -3811,7 +3817,7 @@ elf_follow_link (struct elf_link_hash_entry *h)\n static inline struct ppc_link_hash_entry *\n ppc_follow_link (struct ppc_link_hash_entry *h)\n {\n-  return (struct ppc_link_hash_entry *) follow_link (&h->elf.root);\n+  return ppc_elf_hash_entry (elf_follow_link (&h->elf));\n }\n \n /* Merge PLT info on FROM with that on TO.  */\n@@ -3858,8 +3864,8 @@ ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,\n {\n   struct ppc_link_hash_entry *edir, *eind;\n \n-  edir = (struct ppc_link_hash_entry *) dir;\n-  eind = (struct ppc_link_hash_entry *) ind;\n+  edir = ppc_elf_hash_entry (dir);\n+  eind = ppc_elf_hash_entry (ind);\n \n   edir->is_func |= eind->is_func;\n   edir->is_func_descriptor |= eind->is_func_descriptor;\n@@ -3975,8 +3981,8 @@ lookup_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)\n     {\n       const char *fd_name = fh->elf.root.root.string + 1;\n \n-      fdh = (struct ppc_link_hash_entry *)\n-\telf_link_hash_lookup (&htab->elf, fd_name, FALSE, FALSE, FALSE);\n+      fdh = ppc_elf_hash_entry (elf_link_hash_lookup (&htab->elf, fd_name,\n+\t\t\t\t\t\t      FALSE, FALSE, FALSE));\n       if (fdh == NULL)\n \treturn fdh;\n \n@@ -4104,9 +4110,9 @@ ppc64_elf_merge_symbol (struct elf_link_hash_entry *h,\n \t\t\tbfd *oldbfd ATTRIBUTE_UNUSED,\n \t\t\tconst asection *oldsec ATTRIBUTE_UNUSED)\n {\n-  ((struct ppc_link_hash_entry *) h)->fake = 0;\n+  ppc_elf_hash_entry (h)->fake = 0;\n   if ((STO_PPC64_LOCAL_MASK & isym->st_other) != 0)\n-    ((struct ppc_link_hash_entry *) h)->non_zero_localentry = 1;\n+    ppc_elf_hash_entry (h)->non_zero_localentry = 1;\n   return TRUE;\n }\n \n@@ -4128,7 +4134,7 @@ ppc64_elf_archive_symbol_lookup (bfd *abfd,\n   if (h != NULL\n       /* Don't return this sym if it is a fake function descriptor\n \t created by add_symbol_adjust.  */\n-      && !((struct ppc_link_hash_entry *) h)->fake)\n+      && !ppc_elf_hash_entry (h)->fake)\n     return h;\n \n   if (name[0] == '.')\n@@ -4644,7 +4650,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t  /* These special tls relocs tie a call to __tls_get_addr with\n \t     its parameter symbol.  */\n \t  if (h != NULL)\n-\t    ((struct ppc_link_hash_entry *) h)->tls_mask |= TLS_TLS | TLS_MARK;\n+\t    ppc_elf_hash_entry (h)->tls_mask |= TLS_TLS | TLS_MARK;\n \t  else\n \t    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx,\n \t\t\t\t\trel->r_addend,\n@@ -4719,7 +4725,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      struct ppc_link_hash_entry *eh;\n \t      struct got_entry *ent;\n \n-\t      eh = (struct ppc_link_hash_entry *) h;\n+\t      eh = ppc_elf_hash_entry (h);\n \t      for (ent = eh->elf.got.glist; ent != NULL; ent = ent->next)\n \t\tif (ent->addend == rel->r_addend\n \t\t    && ent->owner == abfd\n@@ -4772,8 +4778,8 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      h->needs_plt = 1;\n \t      if (h->root.root.string[0] == '.'\n \t\t  && h->root.root.string[1] != '\\0')\n-\t\t((struct ppc_link_hash_entry *) h)->is_func = 1;\n-\t      ((struct ppc_link_hash_entry *) h)->tls_mask |= PLT_KEEP;\n+\t\tppc_elf_hash_entry (h)->is_func = 1;\n+\t      ppc_elf_hash_entry (h)->tls_mask |= PLT_KEEP;\n \t      plt_list = &h->plt.plist;\n \t    }\n \t  if (plt_list == NULL)\n@@ -4927,7 +4933,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      h->needs_plt = 1;\n \t      if (h->root.root.string[0] == '.'\n \t\t  && h->root.root.string[1] != '\\0')\n-\t\t((struct ppc_link_hash_entry *) h)->is_func = 1;\n+\t\tppc_elf_hash_entry (h)->is_func = 1;\n \n \t      if (h == tga || h == dottga)\n \t\t{\n@@ -4985,11 +4991,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \tdotlstoc:\n \t  sec->has_tls_reloc = 1;\n \t  if (h != NULL)\n-\t    {\n-\t      struct ppc_link_hash_entry *eh;\n-\t      eh = (struct ppc_link_hash_entry *) h;\n-\t      eh->tls_mask |= tls_type & 0xff;\n-\t    }\n+\t    ppc_elf_hash_entry (h)->tls_mask |= tls_type & 0xff;\n \t  else\n \t    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx,\n \t\t\t\t\trel->r_addend, tls_type))\n@@ -5047,7 +5049,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      && ELF64_R_TYPE ((rel + 1)->r_info) == R_PPC64_TOC)\n \t    {\n \t      if (h != NULL)\n-\t\t((struct ppc_link_hash_entry *) h)->is_func = 1;\n+\t\tppc_elf_hash_entry (h)->is_func = 1;\n \t    }\n \t  /* Fall through.  */\n \n@@ -5151,7 +5153,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  struct elf_dyn_relocs *p;\n \t\t  struct elf_dyn_relocs **head;\n \n-\t\t  head = &((struct ppc_link_hash_entry *) h)->dyn_relocs;\n+\t\t  head = &ppc_elf_hash_entry (h)->dyn_relocs;\n \t\t  p = *head;\n \t\t  if (p == NULL || p->sec != sec)\n \t\t    {\n@@ -5532,7 +5534,7 @@ is_elfv2_localentry0 (struct elf_link_hash_entry *h)\n \t  && h->type == STT_FUNC\n \t  && h->root.type == bfd_link_hash_defined\n \t  && (STO_PPC64_LOCAL_MASK & h->other) == 0\n-\t  && !((struct ppc_link_hash_entry *) h)->non_zero_localentry\n+\t  && !ppc_elf_hash_entry (h)->non_zero_localentry\n \t  && is_ppc64_elf (h->root.u.def.section->owner)\n \t  && abiversion (h->root.u.def.section->owner) >= 2);\n }\n@@ -5581,6 +5583,27 @@ defined_func_desc (struct ppc_link_hash_entry *fh)\n   return NULL;\n }\n \n+/* Given H is a symbol that satisfies is_static_defined, return the\n+   value in the output file.  */\n+\n+static bfd_vma\n+defined_sym_val (struct elf_link_hash_entry *h)\n+{\n+  return (h->root.u.def.section->output_section->vma\n+\t  + h->root.u.def.section->output_offset\n+\t  + h->root.u.def.value);\n+}\n+\n+/* Return true if H matches __tls_get_addr or one of its variants.  */\n+\n+static bfd_boolean\n+is_tls_get_addr (struct elf_link_hash_entry *h,\n+\t\t struct ppc_link_hash_table *htab)\n+{\n+  return (h == &htab->tls_get_addr_fd->elf\n+\t  || h == &htab->tls_get_addr->elf);\n+}\n+\n static bfd_boolean func_desc_adjust (struct elf_link_hash_entry *, void *);\n \n /* Garbage collect sections, after first dealing with dot-symbols.  */\n@@ -5614,8 +5637,8 @@ ppc64_elf_gc_keep (struct bfd_link_info *info)\n       struct ppc_link_hash_entry *eh, *fh;\n       asection *sec;\n \n-      eh = (struct ppc_link_hash_entry *)\n-\telf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, TRUE);\n+      eh = ppc_elf_hash_entry (elf_link_hash_lookup (&htab->elf, sym->name,\n+\t\t\t\t\t\t     FALSE, FALSE, TRUE));\n       if (eh == NULL)\n \tcontinue;\n       if (eh->elf.root.type != bfd_link_hash_defined\n@@ -5647,7 +5670,7 @@ static bfd_boolean\n ppc64_elf_gc_mark_dynamic_ref (struct elf_link_hash_entry *h, void *inf)\n {\n   struct bfd_link_info *info = (struct bfd_link_info *) inf;\n-  struct ppc_link_hash_entry *eh = (struct ppc_link_hash_entry *) h;\n+  struct ppc_link_hash_entry *eh = ppc_elf_hash_entry (h);\n   struct ppc_link_hash_entry *fdh;\n   struct bfd_elf_dynamic_list *d = info->dynamic_list;\n \n@@ -5731,7 +5754,7 @@ ppc64_elf_gc_mark_hook (asection *sec,\n \t    {\n \t    case bfd_link_hash_defined:\n \t    case bfd_link_hash_defweak:\n-\t      eh = (struct ppc_link_hash_entry *) h;\n+\t      eh = ppc_elf_hash_entry (h);\n \t      fdh = defined_func_desc (eh);\n \t      if (fdh != NULL)\n \t\t{\n@@ -5827,8 +5850,8 @@ sfpr_define (struct bfd_link_info *info,\n \n       sym[len + 0] = i / 10 + '0';\n       sym[len + 1] = i % 10 + '0';\n-      h = (struct ppc_link_hash_entry *)\n-\telf_link_hash_lookup (&htab->elf, sym, writing, TRUE, TRUE);\n+      h = ppc_elf_hash_entry (elf_link_hash_lookup (&htab->elf, sym,\n+\t\t\t\t\t\t    writing, TRUE, TRUE));\n       if (stub_sec != NULL)\n \t{\n \t  if (h != NULL\n@@ -6068,7 +6091,7 @@ func_desc_adjust (struct elf_link_hash_entry *h, void *inf)\n   struct ppc_link_hash_entry *fdh;\n   bfd_boolean force_local;\n \n-  fh = (struct ppc_link_hash_entry *) h;\n+  fh = ppc_elf_hash_entry (h);\n   if (fh->elf.root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n@@ -6251,10 +6274,9 @@ ppc64_elf_func_desc_adjust (bfd *obfd ATTRIBUTE_UNUSED,\n static asection *\n readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n-  struct ppc_link_hash_entry *eh;\n+  struct ppc_link_hash_entry *eh = ppc_elf_hash_entry (h);\n   struct elf_dyn_relocs *p;\n \n-  eh = (struct ppc_link_hash_entry *) h;\n   for (p = eh->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n@@ -6272,14 +6294,12 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n static bfd_boolean\n alias_readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n-  struct ppc_link_hash_entry *eh;\n-\n-  eh = (struct ppc_link_hash_entry *) h;\n+  struct ppc_link_hash_entry *eh = ppc_elf_hash_entry (h);\n   do\n     {\n       if (readonly_dynrelocs (&eh->elf))\n \treturn TRUE;\n-      eh = (struct ppc_link_hash_entry *) eh->elf.u.alias;\n+      eh = ppc_elf_hash_entry (eh->elf.u.alias);\n     }\n   while (eh != NULL && &eh->elf != h);\n \n@@ -6341,7 +6361,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       || h->type == STT_GNU_IFUNC\n       || h->needs_plt)\n     {\n-      bfd_boolean local = (((struct ppc_link_hash_entry *) h)->save_res\n+      bfd_boolean local = (ppc_elf_hash_entry (h)->save_res\n \t\t\t   || SYMBOL_CALLS_LOCAL (info, h)\n \t\t\t   || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h));\n       /* Discard dyn_relocs when non-pic if we've decided that a\n@@ -6356,7 +6376,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       if (!bfd_link_pic (info)\n \t  && h->type != STT_GNU_IFUNC\n \t  && local)\n-\t((struct ppc_link_hash_entry *) h)->dyn_relocs = NULL;\n+\tppc_elf_hash_entry (h)->dyn_relocs = NULL;\n \n       /* Clear procedure linkage table information for any symbol that\n \t won't need a .plt entry.  */\n@@ -6368,7 +6388,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t  || (h->type != STT_GNU_IFUNC\n \t      && local\n \t      && (htab->can_convert_all_inline_plt\n-\t\t  || (((struct ppc_link_hash_entry *) h)->tls_mask\n+\t\t  || (ppc_elf_hash_entry (h)->tls_mask\n \t\t      & (TLS_TLS | PLT_KEEP)) != PLT_KEEP)))\n \t{\n \t  h->plt.plist = NULL;\n@@ -6397,7 +6417,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t      else if (!bfd_link_pic (info))\n \t\t/* We are going to be defining the function symbol on the\n \t\t   plt stub, so no dyn_relocs needed when non-pic.  */\n-\t\t((struct ppc_link_hash_entry *) h)->dyn_relocs = NULL;\n+\t\tppc_elf_hash_entry (h)->dyn_relocs = NULL;\n \t    }\n \n \t  /* ELFv2 function symbols can't have copy relocs.  */\n@@ -6427,7 +6447,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       h->root.u.def.value = def->root.u.def.value;\n       if (def->root.u.def.section == htab->elf.sdynbss\n \t  || def->root.u.def.section == htab->elf.sdynrelro)\n-\t((struct ppc_link_hash_entry *) h)->dyn_relocs = NULL;\n+\tppc_elf_hash_entry (h)->dyn_relocs = NULL;\n       return TRUE;\n     }\n \n@@ -6470,7 +6490,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t use dot-symbols and set the function symbol size to the text\n \t size of the function rather than the size of the descriptor.\n \t That's wrong for copying a descriptor.  */\n-      if (((struct ppc_link_hash_entry *) h)->oh == NULL\n+      if (ppc_elf_hash_entry (h)->oh == NULL\n \t  || !(h->size == 24 || h->size == 16))\n \treturn TRUE;\n \n@@ -6517,7 +6537,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n     }\n \n   /* We no longer want dyn_relocs.  */\n-  ((struct ppc_link_hash_entry *) h)->dyn_relocs = NULL;\n+  ppc_elf_hash_entry (h)->dyn_relocs = NULL;\n   return _bfd_elf_adjust_dynamic_copy (info, h, s);\n }\n \n@@ -6534,7 +6554,7 @@ ppc64_elf_hide_symbol (struct bfd_link_info *info,\n   if (ppc_hash_table (info) == NULL)\n     return;\n \n-  eh = (struct ppc_link_hash_entry *) h;\n+  eh = ppc_elf_hash_entry (h);\n   if (eh->is_func_descriptor)\n     {\n       struct ppc_link_hash_entry *fh = eh->oh;\n@@ -6557,8 +6577,8 @@ ppc64_elf_hide_symbol (struct bfd_link_info *info,\n \t  p = eh->elf.root.root.string - 1;\n \t  save = *p;\n \t  *(char *) p = '.';\n-\t  fh = (struct ppc_link_hash_entry *)\n-\t    elf_link_hash_lookup (htab, p, FALSE, FALSE, FALSE);\n+\t  fh = ppc_elf_hash_entry (elf_link_hash_lookup (htab, p, FALSE,\n+\t\t\t\t\t\t\t FALSE, FALSE));\n \t  *(char *) p = save;\n \n \t  /* Unfortunately, if it so happens that the string we were\n@@ -6571,8 +6591,8 @@ ppc64_elf_hide_symbol (struct bfd_link_info *info,\n \t      while (q >= eh->elf.root.root.string && *q == *p)\n \t\t--q, --p;\n \t      if (q < eh->elf.root.root.string && *p == '.')\n-\t\tfh = (struct ppc_link_hash_entry *)\n-\t\t  elf_link_hash_lookup (htab, p, FALSE, FALSE, FALSE);\n+\t\tfh = ppc_elf_hash_entry (elf_link_hash_lookup (htab, p, FALSE,\n+\t\t\t\t\t\t\t       FALSE, FALSE));\n \t    }\n \t  if (fh != NULL)\n \t    {\n@@ -6620,12 +6640,7 @@ get_sym_h (struct elf_link_hash_entry **hp,\n \t}\n \n       if (tls_maskp != NULL)\n-\t{\n-\t  struct ppc_link_hash_entry *eh;\n-\n-\t  eh = (struct ppc_link_hash_entry *) h;\n-\t  *tls_maskp = &eh->tls_mask;\n-\t}\n+\t*tls_maskp = &ppc_elf_hash_entry (h)->tls_mask;\n     }\n   else\n     {\n@@ -6796,7 +6811,7 @@ adjust_opd_syms (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)\n       && h->root.type != bfd_link_hash_defweak)\n     return TRUE;\n \n-  eh = (struct ppc_link_hash_entry *) h;\n+  eh = ppc_elf_hash_entry (h);\n   if (eh->adjust_done)\n     return TRUE;\n \n@@ -6944,7 +6959,7 @@ dec_dynrel_count (bfd_vma r_info,\n     {\n       struct elf_dyn_relocs *p;\n       struct elf_dyn_relocs **pp;\n-      pp = &((struct ppc_link_hash_entry *) h)->dyn_relocs;\n+      pp = &ppc_elf_hash_entry (h)->dyn_relocs;\n \n       /* elf_gc_sweep may have already removed all dyn relocs associated\n \t with local syms for a given section.  Also, symbol flags are\n@@ -7261,7 +7276,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)\n \t      if (h != NULL\n \t\t  && h->root.root.string[0] == '.')\n \t\t{\n-\t\t  fdh = ((struct ppc_link_hash_entry *) h)->oh;\n+\t\t  fdh = ppc_elf_hash_entry (h)->oh;\n \t\t  if (fdh != NULL)\n \t\t    {\n \t\t      fdh = ppc_follow_link (fdh);\n@@ -7668,8 +7683,7 @@ ppc64_elf_tls_setup (struct bfd_link_info *info)\n \t\t      if (!bfd_elf_link_record_dynamic_symbol (info, opt_fd))\n \t\t\treturn NULL;\n \t\t    }\n-\t\t  htab->tls_get_addr_fd\n-\t\t    = (struct ppc_link_hash_entry *) opt_fd;\n+\t\t  htab->tls_get_addr_fd = ppc_elf_hash_entry (opt_fd);\n \t\t  tga = &htab->tls_get_addr->elf;\n \t\t  if (opt != NULL && tga != NULL)\n \t\t    {\n@@ -7679,7 +7693,7 @@ ppc64_elf_tls_setup (struct bfd_link_info *info)\n \t\t      opt->mark = 1;\n \t\t      _bfd_elf_link_hash_hide_symbol (info, opt,\n \t\t\t\t\t\t      tga->forced_local);\n-\t\t      htab->tls_get_addr = (struct ppc_link_hash_entry *) opt;\n+\t\t      htab->tls_get_addr = ppc_elf_hash_entry (opt);\n \t\t    }\n \t\t  htab->tls_get_addr_fd->oh = htab->tls_get_addr;\n \t\t  htab->tls_get_addr_fd->is_func_descriptor = 1;\n@@ -7858,8 +7872,7 @@ ppc64_elf_tls_optimize (struct bfd_link_info *info)\n \t\t  if (pass == 0\n \t\t      && sec->nomark_tls_get_addr\n \t\t      && h != NULL\n-\t\t      && (h == &htab->tls_get_addr->elf\n-\t\t\t  || h == &htab->tls_get_addr_fd->elf)\n+\t\t      && is_tls_get_addr (h, htab)\n \t\t      && !found_tls_get_addr_arg\n \t\t      && is_branch_reloc (r_type))\n \t\t    {\n@@ -8234,7 +8247,7 @@ adjust_toc_syms (struct elf_link_hash_entry *h, void *inf)\n       && h->root.type != bfd_link_hash_defweak)\n     return TRUE;\n \n-  eh = (struct ppc_link_hash_entry *) h;\n+  eh = ppc_elf_hash_entry (h);\n   if (eh->adjust_done)\n     return TRUE;\n \n@@ -9286,7 +9299,7 @@ allocate_got (struct elf_link_hash_entry *h,\n \t      struct got_entry *gent)\n {\n   struct ppc_link_hash_table *htab = ppc_hash_table (info);\n-  struct ppc_link_hash_entry *eh = (struct ppc_link_hash_entry *) h;\n+  struct ppc_link_hash_entry *eh = ppc_elf_hash_entry (h);\n   int entsize = (gent->tls_type & eh->tls_mask & (TLS_GD | TLS_LD)\n \t\t ? 16 : 8);\n   int rentsize = (gent->tls_type & eh->tls_mask & TLS_GD\n@@ -9374,7 +9387,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   if (htab == NULL)\n     return FALSE;\n \n-  eh = (struct ppc_link_hash_entry *) h;\n+  eh = ppc_elf_hash_entry (h);\n   /* Run through the TLS GD got entries first if we're changing them\n      to TPREL.  */\n   if ((eh->tls_mask & (TLS_TLS | TLS_GDIE)) == (TLS_TLS | TLS_GDIE))\n@@ -9535,7 +9548,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t  && h->def_regular\n \t  && !htab->elf.dynamic_sections_created\n \t  && !htab->can_convert_all_inline_plt\n-\t  && (((struct ppc_link_hash_entry *) h)->tls_mask\n+\t  && (ppc_elf_hash_entry (h)->tls_mask\n \t      & (TLS_TLS | PLT_KEEP)) == PLT_KEEP))\n     {\n       struct plt_entry *pent;\n@@ -10652,8 +10665,7 @@ plt_stub_size (struct ppc_link_hash_table *htab,\n \tsize += 4;\n     }\n   if (stub_entry->h != NULL\n-      && (stub_entry->h == htab->tls_get_addr_fd\n-\t  || stub_entry->h == htab->tls_get_addr)\n+      && is_tls_get_addr (&stub_entry->h->elf, htab)\n       && htab->params->tls_get_addr_opt)\n     {\n       size += 7 * 4;\n@@ -10714,8 +10726,7 @@ build_plt_stub (struct ppc_link_hash_table *htab,\n   if (!ALWAYS_USE_FAKE_DEP\n       && plt_load_toc\n       && plt_thread_safe\n-      && !((stub_entry->h == htab->tls_get_addr_fd\n-\t    || stub_entry->h == htab->tls_get_addr)\n+      && !(is_tls_get_addr (&stub_entry->h->elf, htab)\n \t   && htab->params->tls_get_addr_opt))\n     {\n       bfd_vma pltoff = stub_entry->plt_ent->plt.offset & ~1;\n@@ -11011,9 +11022,7 @@ use_global_in_relocs (struct ppc_link_hash_table *htab,\n     h = ppc_follow_link (h->oh);\n   BFD_ASSERT (h->elf.root.type == bfd_link_hash_defined\n \t      || h->elf.root.type == bfd_link_hash_defweak);\n-  symval = (h->elf.root.u.def.value\n-\t    + h->elf.root.u.def.section->output_offset\n-\t    + h->elf.root.u.def.section->output_section->vma);\n+  symval = defined_sym_val (&h->elf);\n   while (num_rel-- != 0)\n     {\n       r->r_info = ELF64_R_INFO (symndx, ELF64_R_TYPE (r->r_info));\n@@ -11525,8 +11534,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  r[0].r_addend = targ;\n \t}\n       if (stub_entry->h != NULL\n-\t  && (stub_entry->h == htab->tls_get_addr_fd\n-\t      || stub_entry->h == htab->tls_get_addr)\n+\t  && is_tls_get_addr (&stub_entry->h->elf, htab)\n \t  && htab->params->tls_get_addr_opt)\n \tp = build_tls_get_addr_stub (htab, stub_entry, loc, off, r);\n       else\n@@ -11911,8 +11919,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       size = plt_stub_size (htab, stub_entry, off);\n \n       if (stub_entry->h != NULL\n-\t  && (stub_entry->h == htab->tls_get_addr_fd\n-\t      || stub_entry->h == htab->tls_get_addr)\n+\t  && is_tls_get_addr (&stub_entry->h->elf, htab)\n \t  && htab->params->tls_get_addr_opt\n \t  && stub_entry->stub_type == ppc_stub_plt_call_r2save)\n \t{\n@@ -12360,7 +12367,7 @@ toc_adjusting_stub_needed (struct bfd_link_info *info, asection *isec)\n \n \t  /* Calls to dynamic lib functions go through a plt call stub\n \t     that uses r2.  */\n-\t  eh = (struct ppc_link_hash_entry *) h;\n+\t  eh = ppc_elf_hash_entry (h);\n \t  if (eh != NULL\n \t      && (eh->elf.plt.plist != NULL\n \t\t  || (eh->oh != NULL\n@@ -12933,7 +12940,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,\n \t\t\t\t  r_indx, input_bfd))\n \t\t    goto error_ret_free_internal;\n-\t\t  hash = (struct ppc_link_hash_entry *) h;\n+\t\t  hash = ppc_elf_hash_entry (h);\n \n \t\t  ok_dest = FALSE;\n \t\t  fdh = NULL;\n@@ -13069,8 +13076,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t  if (stub_type != ppc_stub_plt_call\n \t\t      && stub_type != ppc_stub_plt_call_notoc\n \t\t      && hash != NULL\n-\t\t      && (hash == htab->tls_get_addr\n-\t\t\t  || hash == htab->tls_get_addr_fd)\n+\t\t      && is_tls_get_addr (&hash->elf, htab)\n \t\t      && section->has_tls_reloc\n \t\t      && irela != internal_relocs)\n \t\t    {\n@@ -13451,9 +13457,7 @@ ppc64_elf_set_toc (struct bfd_link_info *info, bfd *obfd)\n \t  && (!is_elf_hash_table (htab)\n \t      || h->def_regular))\n \t{\n-\t  TOCstart = (h->root.u.def.value - TOC_BASE_OFF\n-\t\t      + h->root.u.def.section->output_offset\n-\t\t      + h->root.u.def.section->output_section->vma);\n+\t  TOCstart = defined_sym_val (h) - TOC_BASE_OFF;\n \t  _bfd_set_gp_value (obfd, TOCstart);\n \t  return TOCstart;\n \t}\n@@ -13592,10 +13596,7 @@ build_global_entry_stubs_and_plt (struct elf_link_hash_entry *h, void *inf)\n \t\telse\n \t\t  relplt = NULL;\n \t      }\n-\t    rela.r_addend = (h->root.u.def.value\n-\t\t\t     + h->root.u.def.section->output_offset\n-\t\t\t     + h->root.u.def.section->output_section->vma\n-\t\t\t     + ent->addend);\n+\t    rela.r_addend = defined_sym_val (h) + ent->addend;\n \n \t    if (relplt == NULL)\n \t      {\n@@ -14436,7 +14437,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t  }\n \t    }\n \t}\n-      h = (struct ppc_link_hash_entry *) h_elf;\n+      h = ppc_elf_hash_entry (h_elf);\n \n       if (sec != NULL && discarded_section (sec))\n \t{\n@@ -15214,8 +15215,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t\t       || nop == CROR_313131)\n \t\t\t{\n \t\t\t  if (h != NULL\n-\t\t\t      && (h == htab->tls_get_addr_fd\n-\t\t\t\t  || h == htab->tls_get_addr)\n+\t\t\t      && is_tls_get_addr (&h->elf, htab)\n \t\t\t      && htab->params->tls_get_addr_opt)\n \t\t\t    {\n \t\t\t      /* Special stub used, leave nop alone.  */\n@@ -15380,8 +15380,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t   || stub_entry->stub_type == ppc_stub_plt_call_r2save\n \t\t   || stub_entry->stub_type == ppc_stub_plt_call_both)\n \t\t  && !(h != NULL\n-\t\t       && (h == htab->tls_get_addr_fd\n-\t\t\t   || h == htab->tls_get_addr)\n+\t\t       && is_tls_get_addr (&h->elf, htab)\n \t\t       && htab->params->tls_get_addr_opt)\n \t\t  && rel + 1 < relend\n \t\t  && rel[1].r_offset == rel->r_offset + 4\n@@ -16874,9 +16873,7 @@ ppc64_elf_finish_dynamic_symbol (bfd *output_bfd,\n       if (h->dynindx == -1)\n \tabort ();\n \n-      rela.r_offset = (h->root.u.def.value\n-\t\t       + h->root.u.def.section->output_section->vma\n-\t\t       + h->root.u.def.section->output_offset);\n+      rela.r_offset = defined_sym_val (h);\n       rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_COPY);\n       rela.r_addend = 0;\n       if (h->root.u.def.section == htab->elf.sdynrelro)"
    }
  ]
}