{
  "sha": "5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTQ5NmYzYzYzNWRjZTNlMTIzNDhkNmU4MWMzZjc0ODE1ZmRmZTdiNQ==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-03-11T10:17:14Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-03-11T10:17:14Z"
    },
    "message": "Add support for generating DWARF-5 format directory and file name tables from the assembler.\n\n\tPR 25611\n\tPR 25614\n\t* dwarf.h (DWARF2_Internal_LineInfo): Add li_address_size and\n\tli_segment_size fields.\n\t* dwarf.c (read_debug_line_header): Record the address size and\n\tsegment selector size values (if present) in the lineinfo\n\tstructure.\n\t(display_formatted_table): Warn if the format count is empty but\n\tthe table itself is not empty.\n\tDisplay the format count and entry count at the start of the table\n\tdump.\n\t(display_debug_lines_raw): Display the address size and segement\n\tselector size fields, if present.\n\t* testsuite/binutils-all/dw5.W: Update expected output.\n\ngas\t* dwarf2dbg.c (DWARF2_FILE_TIME_NAME): Default to -1.\n\t(DWARF2_FILE_SIZE_NAME): Default to -1.\n\t(DWARF2_LINE_VERSION): Default to the current dwarf level or 3,\n\twhichever is higher.\n\t(DWARF2_LINE_MAX_OPS_PER_INSN): Provide a default value of 1.\n\t(NUM_MD5_BYTES): Define.\n\t(struct file entry): Add md5 field.\n\t(get_filenum): Delete and replace with...\n\t(get_basename): New function.\n\t(get_directory_table_entry): New function.\n\t(allocate_filenum): New function.\n\t(allocate_filename_to_slot): New function.\n\t(dwarf2_where): Use new functions.\n\t(dwarf2_directive_filename): Add support for extended .file\n\tpseudo-op.\n\t(dwarf2_directive_loc): Allow the use of file number zero with\n\tDWARF 5 or higher.\n\t(out_file_list): Rename to...\n\t(out_dir_and_file_list): Add DWARF 5 support.\n\t(out_debug_line): Emit extra values into the section header for\n\tDWARF 5.\n\t(out_debug_str): Allow for file 0 to be used with DWARF 5.\n\t* doc/as.texi (.file): Update the description of this pseudo-op.\n\t* testsuite/gas/elf-dwarf-5-file0.s: Add more lines.\n\t* testsuite/gas/elf-dwarf-5-file0.d: Update expected dump output.\n\t* testsuite/gas/lns/lns-diag-1.l: Update expected error message.\n\t* NEWS: Mention the new feature.",
    "tree": {
      "sha": "656a7d7904a075b22d0bf20de5ec02c81f9a9964",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/656a7d7904a075b22d0bf20de5ec02c81f9a9964"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b76f3a42371cb0d83a1128a434852447da76b5e9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b76f3a42371cb0d83a1128a434852447da76b5e9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b76f3a42371cb0d83a1128a434852447da76b5e9"
    }
  ],
  "stats": {
    "total": 868,
    "additions": 672,
    "deletions": 196
  },
  "files": [
    {
      "sha": "9f54fa1f1c383c01abd164b3ea17eb3b45d8faa3",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -1,3 +1,20 @@\n+2020-03-11  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR 25611\n+\tPR 25614\n+\t* dwarf.h (DWARF2_Internal_LineInfo): Add li_address_size and\n+\tli_segment_size fields.\n+\t* dwarf.c (read_debug_line_header): Record the address size and\n+\tsegment selector size values (if present) in the lineinfo\n+\tstructure.\n+\t(display_formatted_table): Warn if the format count is empty but\n+\tthe table itself is not empty.\n+\tDisplay the format count and entry count at the start of the table\n+\tdump.\n+\t(display_debug_lines_raw): Display the address size and segement\n+\tselector size fields, if present.\n+\t* testsuite/binutils-all/dw5.W: Update expected output.\n+\n 2020-03-11  Alan Modra  <amodra@gmail.com>\n \n \tPR 25651"
    },
    {
      "sha": "c75059bd93a8513ff5b22f6500d134a375859eda",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 28,
      "deletions": 31,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -3622,7 +3622,6 @@ read_debug_line_header (struct dwarf_section * section,\n {\n   unsigned char *hdrptr;\n   unsigned int initial_length_size;\n-  unsigned char address_size, segment_selector_size;\n \n   /* Extract information from the Line Number Program Header.\n      (section 6.2.4 in the Dwarf3 doc).  */\n@@ -3679,15 +3678,15 @@ read_debug_line_header (struct dwarf_section * section,\n \n   if (linfo->li_version >= 5)\n     {\n-      SAFE_BYTE_GET_AND_INC (address_size, hdrptr, 1, end);\n+      SAFE_BYTE_GET_AND_INC (linfo->li_address_size, hdrptr, 1, end);\n \n-      SAFE_BYTE_GET_AND_INC (segment_selector_size, hdrptr, 1, end);\n-      if (segment_selector_size != 0)\n+      SAFE_BYTE_GET_AND_INC (linfo->li_segment_size, hdrptr, 1, end);\n+      if (linfo->li_segment_size != 0)\n \t{\n \t  warn (_(\"The %s section contains \"\n \t\t  \"unsupported segment selector size: %d.\\n\"),\n-\t\tsection->name, segment_selector_size);\n-\t  return 0;\n+\t\tsection->name, linfo->li_segment_size);\n+\t  return NULL;\n \t}\n     }\n \n@@ -3737,7 +3736,8 @@ display_formatted_table (unsigned char *                   data,\n   unsigned char *format_start, format_count, *format, formati;\n   dwarf_vma data_count, datai;\n   unsigned int namepass, last_entry = 0;\n-\n+  const char * table_name = is_dir ? N_(\"Directory Table\") : N_(\"File Name Table\");\n+  \n   SAFE_BYTE_GET_AND_INC (format_count, data, 1, end);\n   format_start = data;\n   for (formati = 0; formati < format_count; formati++)\n@@ -3746,39 +3746,33 @@ display_formatted_table (unsigned char *                   data,\n       SKIP_ULEB (data, end);\n       if (data == end)\n \t{\n-\t  if (is_dir)\n-\t    warn (_(\"Corrupt directory format table entry\\n\"));\n-\t  else\n-\t    warn (_(\"Corrupt file name format table entry\\n\"));\n+\t  warn (_(\"%s: Corrupt format description entry\\n\"), table_name);\n \t  return data;\n \t}\n     }\n \n   READ_ULEB (data_count, data, end);\n   if (data == end)\n     {\n-      if (is_dir)\n-\twarn (_(\"Corrupt directory list\\n\"));\n-      else\n-\twarn (_(\"Corrupt file name list\\n\"));\n+      warn (_(\"%s: Corrupt entry count\\n\"), table_name);\n       return data;\n     }\n \n   if (data_count == 0)\n     {\n-      if (is_dir)\n-\tprintf (_(\"\\n The Directory Table is empty.\\n\"));\n-      else\n-\tprintf (_(\"\\n The File Name Table is empty.\\n\"));\n+      printf (_(\"\\n The %s is empty.\\n\"), table_name);\n       return data;\n     }\n+  else if (format_count == 0)\n+    {\n+      warn (_(\"%s: format count is zero, but the table is not empty\\n\"),\n+\t    table_name);\n+      return end;\n+    }\n \n-  if (is_dir)\n-    printf (_(\"\\n The Directory Table (offset 0x%lx):\\n\"),\n-\t    (long) (data - start));\n-  else\n-    printf (_(\"\\n The File Name Table (offset 0x%lx):\\n\"),\n-\t    (long) (data - start));\n+  printf (_(\"\\n The %s (offset 0x%lx, lines %s, columns %u):\\n\"),\n+\t  table_name, (long) (data - start), dwarf_vmatoa (\"u\", data_count),\n+\t  format_count);\n \n   printf (_(\"  Entry\"));\n   /* Delay displaying name as the last entry for better screen layout.  */ \n@@ -3806,7 +3800,7 @@ display_formatted_table (unsigned char *                   data,\n \t\tprintf (_(\"\\tSize\"));\n \t\tbreak;\n \t      case DW_LNCT_MD5:\n-\t\tprintf (_(\"\\tMD5\"));\n+\t\tprintf (_(\"\\tMD5\\t\\t\\t\"));\n \t\tbreak;\n \t      default:\n \t\tprintf (_(\"\\t(Unknown format content type %s)\"),\n@@ -3840,12 +3834,10 @@ display_formatted_table (unsigned char *                   data,\n \t\t\t\t\t\t  section, NULL, '\\t', -1);\n \t    }\n \t}\n-      if (data == end)\n+\n+      if (data == end && (datai < data_count - 1))\n \t{\n-\t  if (is_dir)\n-\t    warn (_(\"Corrupt directory entries list\\n\"));\n-\t  else\n-\t    warn (_(\"Corrupt file name entries list\\n\"));\n+\t  warn (_(\"\\n%s: Corrupt entries list\\n\"), table_name);\n \t  return data;\n \t}\n       putchar ('\\n');\n@@ -3909,6 +3901,11 @@ display_debug_lines_raw (struct dwarf_section *  section,\n \t  printf (_(\"  Offset:                      0x%lx\\n\"), (long)(data - start));\n \t  printf (_(\"  Length:                      %ld\\n\"), (long) linfo.li_length);\n \t  printf (_(\"  DWARF Version:               %d\\n\"), linfo.li_version);\n+\t  if (linfo.li_version >= 5)\n+\t    {\n+\t      printf (_(\"  Address size (bytes):        %d\\n\"), linfo.li_address_size);\n+\t      printf (_(\"  Segment selector (bytes):    %d\\n\"), linfo.li_segment_size);\n+\t    }\n \t  printf (_(\"  Prologue Length:             %d\\n\"), (int) linfo.li_prologue_length);\n \t  printf (_(\"  Minimum Instruction Length:  %d\\n\"), linfo.li_min_insn_length);\n \t  if (linfo.li_version >= 4)"
    },
    {
      "sha": "2249750f87a67f3c5d5f943af39b61ffd6c69ce1",
      "filename": "binutils/dwarf.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/binutils/dwarf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/binutils/dwarf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.h?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -29,6 +29,8 @@ typedef struct\n {\n   dwarf_vma\t li_length;\n   unsigned short li_version;\n+  unsigned char  li_address_size;\n+  unsigned char  li_segment_size;\n   dwarf_vma      li_prologue_length;\n   unsigned char  li_min_insn_length;\n   unsigned char  li_max_ops_per_insn;"
    },
    {
      "sha": "2eccb03c5a60a0f637ff1ce6b528bce65df450d6",
      "filename": "binutils/testsuite/binutils-all/dw5.W",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/binutils/testsuite/binutils-all/dw5.W",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/binutils/testsuite/binutils-all/dw5.W",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/testsuite/binutils-all/dw5.W?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -291,6 +291,8 @@ Raw dump of debug contents of section .debug_line:\n   Offset:                      0x0\n   Length:                      144\n   DWARF Version:               5\n+  Address size \\(bytes\\):        8\n+  Segment selector \\(bytes\\):    0\n   Prologue Length:             60\n   Minimum Instruction Length:  1\n   Maximum Ops per Instruction: 1\n@@ -313,13 +315,13 @@ Raw dump of debug contents of section .debug_line:\n   Opcode 11 has 0 args\n   Opcode 12 has 1 arg\n \n- The Directory Table \\(offset 0x22\\):\n+ The Directory Table \\(offset 0x22, lines 3, columns 1\\):\n   Entry\tName\n   0\t\\(indirect line string, offset: 0x0\\): \n   1\t\\(indirect line string, offset: 0x1\\): \n   2\t\\(indirect line string, offset: 0x22\\): /usr/include\n \n- The File Name Table \\(offset 0x34\\):\n+ The File Name Table \\(offset 0x34, lines 4, columns 2\\):\n   Entry\tDir\tName\n   0\t0\t\\(indirect line string, offset: 0x14\\): main.c\n   1\t1\t\\(indirect line string, offset: 0x1b\\): main.c"
    },
    {
      "sha": "b4b1a3411170262534ee0eee303f97ead6d4782a",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -1,3 +1,35 @@\n+2020-03-11  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR 25611\n+\tPR 25614\n+\t* dwarf2dbg.c (DWARF2_FILE_TIME_NAME): Default to -1.\n+\t(DWARF2_FILE_SIZE_NAME): Default to -1.\n+\t(DWARF2_LINE_VERSION): Default to the current dwarf level or 3,\n+\twhichever is higher.\n+\t(DWARF2_LINE_MAX_OPS_PER_INSN): Provide a default value of 1.\n+\t(NUM_MD5_BYTES): Define.\n+\t(struct file entry): Add md5 field.\n+\t(get_filenum): Delete and replace with...\n+\t(get_basename): New function.\n+\t(get_directory_table_entry): New function.\n+\t(allocate_filenum): New function.\n+\t(allocate_filename_to_slot): New function.\n+\t(dwarf2_where): Use new functions.\n+\t(dwarf2_directive_filename): Add support for extended .file\n+\tpseudo-op.\n+\t(dwarf2_directive_loc): Allow the use of file number zero with\n+\tDWARF 5 or higher.\n+\t(out_file_list): Rename to...\n+\t(out_dir_and_file_list): Add DWARF 5 support.\n+\t(out_debug_line): Emit extra values into the section header for\n+\tDWARF 5.\n+\t(out_debug_str): Allow for file 0 to be used with DWARF 5.\n+\t* doc/as.texi (.file): Update the description of this pseudo-op.\n+\t* testsuite/gas/elf-dwarf-5-file0.s: Add more lines.\n+\t* testsuite/gas/elf-dwarf-5-file0.d: Update expected dump output.\n+\t* testsuite/gas/lns/lns-diag-1.l: Update expected error message.\n+\t* NEWS: Mention the new feature.\n+\n 2020-03-10  Alan Modra  <amodra@gmail.com>\n \n \t* config/tc-csky.c (get_operand_value): Rewrite 1 << 31 expressions"
    },
    {
      "sha": "5623db64357aa0ba53fa4df9dad12fc592e35102",
      "filename": "gas/NEWS",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/NEWS?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -1,5 +1,9 @@\n -*- text -*-\n \n+* Add --gdwarf-5 option to the assembler to generate DWARF 5 debug output\n+  (if such output is being generated).  Added the ability to generate\n+  version 5 .debug_line sections.\n+\n Changes in 2.34:\n \n * Add -malign-branch-boundary=NUM, -malign-branch=TYPE[+TYPE...],"
    },
    {
      "sha": "0a6727ef848aaf357d2a7822b437a4c393baa562",
      "filename": "gas/doc/as.texi",
      "status": "modified",
      "additions": 17,
      "deletions": 1,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/doc/as.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/doc/as.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/doc/as.texi?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -5366,13 +5366,29 @@ to the @code{.debug_line} file name table.  The syntax is:\n \n The @var{fileno} operand should be a unique positive integer to use as the\n index of the entry in the table.  The @var{filename} operand is a C string\n-literal.\n+literal enclosed in double quotes.  The @var{filename} can include directory\n+elements.  If it does, then the directory will be added to the directory table\n+and the basename will be added to the file table.\n \n The detail of filename indices is exposed to the user because the filename\n table is shared with the @code{.debug_info} section of the DWARF2 debugging\n information, and thus the user must know the exact indices that table\n entries will have.\n \n+If DWARF-5 support has been enabled via the @option{-gdwarf-5} option then\n+an extended version of the @code{file} is also allowed:\n+\n+@smallexample\n+.file @var{fileno} [@var{dirname}] @var{filename} [md5 @var{value}]\n+@end smallexample\n+\n+With this version a separate directory name is allowed, although if this is\n+used then @var{filename} should not contain any directory components.  In\n+addtion an md5 hash value of the contents of @var{filename} can be provided.\n+This will be stored in the the file table as well, and can be used by tools\n+reading the debug information to verify that the contents of the source file\n+match the contents of the compiled file.\n+\n @node Fill\n @section @code{.fill @var{repeat} , @var{size} , @var{value}}\n "
    },
    {
      "sha": "d9d517a2998dd07164a749b1c39256de760bec5c",
      "filename": "gas/dwarf2dbg.c",
      "status": "modified",
      "additions": 535,
      "deletions": 148,
      "changes": 683,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/dwarf2dbg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/dwarf2dbg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/dwarf2dbg.c?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -30,6 +30,7 @@\n \n #include \"as.h\"\n #include \"safe-ctype.h\"\n+#include \"bignum.h\"\n \n #ifdef HAVE_LIMITS_H\n #include <limits.h>\n@@ -81,11 +82,11 @@\n #endif\n \n #ifndef DWARF2_FILE_TIME_NAME\n-#define DWARF2_FILE_TIME_NAME(FILENAME,DIRNAME) 0\n+#define DWARF2_FILE_TIME_NAME(FILENAME,DIRNAME) -1\n #endif\n \n #ifndef DWARF2_FILE_SIZE_NAME\n-#define DWARF2_FILE_SIZE_NAME(FILENAME,DIRNAME) 0\n+#define DWARF2_FILE_SIZE_NAME(FILENAME,DIRNAME) -1\n #endif\n \n #ifndef DWARF2_VERSION\n@@ -99,7 +100,7 @@\n \n /* This implementation outputs version 3 .debug_line information.  */\n #ifndef DWARF2_LINE_VERSION\n-#define DWARF2_LINE_VERSION 3\n+#define DWARF2_LINE_VERSION (dwarf_level > 3 ? dwarf_level : 3)\n #endif\n \n #include \"subsegs.h\"\n@@ -147,6 +148,10 @@\n /* Flag that indicates the initial value of the is_stmt_start flag.  */\n #define\tDWARF2_LINE_DEFAULT_IS_STMT\t1\n \n+#ifndef DWARF2_LINE_MAX_OPS_PER_INSN\n+#define DWARF2_LINE_MAX_OPS_PER_INSN\t1\n+#endif\n+\n /* Given a special op, return the line skip amount.  */\n #define SPECIAL_LINE(op) \\\n \t(((op) - DWARF2_LINE_OPCODE_BASE)%DWARF2_LINE_RANGE + DWARF2_LINE_BASE)\n@@ -196,10 +201,13 @@ struct line_seg\n static struct line_seg *all_segs;\n static struct line_seg **last_seg_ptr;\n \n+#define NUM_MD5_BYTES       16\n+\n struct file_entry\n {\n-  const char *filename;\n-  unsigned int dir;\n+  const char *   filename;\n+  unsigned int   dir;\n+  unsigned char  md5[NUM_MD5_BYTES];\n };\n \n /* Table of files used by .debug_line.  */\n@@ -208,9 +216,9 @@ static unsigned int files_in_use;\n static unsigned int files_allocated;\n \n /* Table of directories used by .debug_line.  */\n-static char **dirs;\n-static unsigned int dirs_in_use;\n-static unsigned int dirs_allocated;\n+static char **       dirs = NULL;\n+static unsigned int  dirs_in_use = 0;\n+static unsigned int  dirs_allocated = 0;\n \n /* TRUE when we've seen a .loc directive recently.  Used to avoid\n    doing work when there's nothing to do.  */\n@@ -239,8 +247,6 @@ static symbolS *view_assert_failed;\n /* The size of an address on the target.  */\n static unsigned int sizeof_address;\n \f\n-static unsigned int get_filenum (const char *, unsigned int);\n-\n #ifndef TC_DWARF2_EMIT_OFFSET\n #define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset\n \n@@ -280,6 +286,7 @@ get_line_subseg (segT seg, subsegT subseg, bfd_boolean create_p)\n       last_seg_ptr = &s->next;\n       seg_info (seg)->dwarf2_line_seg = s;\n     }\n+\n   gas_assert (seg == s->seg);\n \n   for (pss = &s->head; (lss = *pss) != NULL ; pss = &lss->next)\n@@ -516,7 +523,9 @@ dwarf2_gen_line_info (addressT ofs, struct dwarf2_line_info *loc)\n   symbolS *sym;\n \n   /* Early out for as-yet incomplete location information.  */\n-  if (loc->filenum == 0 || loc->line == 0)\n+  if (loc->line == 0)\n+    return;\n+  if (loc->filenum == 0 && DWARF2_LINE_VERSION < 5)\n     return;\n \n   /* Don't emit sequences of line symbols for the same line when the\n@@ -544,6 +553,323 @@ dwarf2_gen_line_info (addressT ofs, struct dwarf2_line_info *loc)\n   dwarf2_gen_line_info_1 (sym, loc);\n }\n \n+static const char *\n+get_basename (const char * pathname)\n+{\n+  const char * file;\n+\n+  file = lbasename (pathname);\n+  /* Don't make empty string from / or A: from A:/ .  */\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+  if (file <= pathname + 3)\n+    file = pathname;\n+#else\n+  if (file == pathname + 1)\n+    file = pathname;\n+#endif\n+  return file;\n+}\n+\n+static unsigned int\n+get_directory_table_entry (const char *  dirname,\n+\t\t\t   size_t        dirlen,\n+\t\t\t   bfd_boolean   can_use_zero)\n+{\n+  unsigned int d;\n+\n+  if (dirlen == 0)\n+    return 0;\n+\n+#ifndef DWARF2_DIR_SHOULD_END_WITH_SEPARATOR\n+  if (IS_DIR_SEPARATOR (dirname[dirlen - 1]))\n+    {\n+      -- dirlen;\n+      if (dirlen == 0)\n+\treturn 0;\n+    }\n+#endif\n+\n+  for (d = 0; d < dirs_in_use; ++d)\n+    {\n+      if (dirs[d] != NULL\n+\t  && filename_ncmp (dirname, dirs[d], dirlen) == 0\n+\t  && dirs[d][dirlen] == '\\0')\n+\treturn d;\n+    }\n+\n+  if (can_use_zero)\n+    {\n+      if (dirs == NULL || dirs[0] == NULL)\n+\td = 0;\n+    }\n+  else if (d == 0)\n+    d = 1;\n+\n+  if (d >= dirs_allocated)\n+    {\n+      unsigned int old = dirs_allocated;\n+\n+      dirs_allocated = d + 32;\n+      dirs = XRESIZEVEC (char *, dirs, dirs_allocated);\n+      memset (dirs + old, 0, (dirs_allocated - old) * sizeof (char *));\n+    }\n+\n+  dirs[d] = xmemdup0 (dirname, dirlen);\n+  if (dirs_in_use <= d)\n+    dirs_in_use = d + 1;\n+\n+  return d;  \n+}\n+\n+/* Get a .debug_line file number for PATHNAME.  If there is a\n+   directory component to PATHNAME, then this will be stored\n+   in the directory table, if it is not already present.\n+   Returns the slot number allocated to that filename or -1\n+   if there was a problem.  */\n+\n+static signed int\n+allocate_filenum (const char * pathname)\n+{\n+  static signed int last_used = -1, last_used_dir_len = 0;\n+  const char *file;\n+  size_t dir_len;\n+  unsigned int i, dir;\n+\n+  /* Short circuit the common case of adding the same pathname\n+     as last time.  */\n+  if (last_used != -1)\n+    {\n+      const char * dirname = NULL;\n+\n+      if (dirs != NULL)\n+\tdirname = dirs[files[last_used].dir];\n+\n+      if (dirname == NULL)\n+\t{\n+\t  if (filename_cmp (pathname, files[last_used].filename) == 0)\n+\t    return last_used;\n+\t}\n+      else\n+\t{\n+\t  if (filename_ncmp (pathname, dirname, last_used_dir_len) == 0\n+\t      && IS_DIR_SEPARATOR (pathname [last_used_dir_len])\n+\t      && filename_cmp (pathname + last_used_dir_len + 1,\n+\t\t\t       files[last_used].filename) == 0)\n+\t    return last_used;\n+\t}\n+    }\n+\n+  file = get_basename (pathname);\n+  dir_len = file - pathname;\n+\n+  dir = get_directory_table_entry (pathname, dir_len, FALSE);\n+\n+  /* Do not use slot-0.  That is specificailly reserved for use by\n+     the '.file 0 \"name\"' directive.  */\n+  for (i = 1; i < files_in_use; ++i)\n+    if (files[i].dir == dir\n+\t&& files[i].filename\n+\t&& filename_cmp (file, files[i].filename) == 0)\n+      {\n+\tlast_used = i;\n+\tlast_used_dir_len = dir_len;\n+\treturn i;\n+      }\n+\n+  if (i >= files_allocated)\n+    {\n+      unsigned int old = files_allocated;\n+\n+      files_allocated = i + 32;\n+      /* Catch wraparound.  */\n+      if (files_allocated <= old)\n+\t{\n+\t  as_bad (_(\"file number %lu is too big\"), (unsigned long) i);\n+\t  return -1;\n+\t}\n+\n+      files = XRESIZEVEC (struct file_entry, files, files_allocated);\n+      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));\n+    }\n+\n+  files[i].filename = file;\n+  files[i].dir = dir;\n+  memset (files[i].md5, 0, NUM_MD5_BYTES);\n+\n+  if (files_in_use < i + 1)\n+    files_in_use = i + 1;  \n+  last_used = i;\n+  last_used_dir_len = dir_len;\n+\n+  return i;\n+}\n+\n+/* Allocate slot NUM in the .debug_line file table to FILENAME.\n+   If DIRNAME is not NULL or there is a directory component to FILENAME\n+   then this will be stored in the directory table, if not already present.\n+   if WITH_MD5 is TRUE then there is a md5 value in generic_bignum.\n+   Returns TRUE if allocation succeeded, FALSE otherwise.  */\n+\n+static bfd_boolean\n+allocate_filename_to_slot (const char *  dirname,\n+\t\t\t   const char *  filename,\n+\t\t\t   unsigned int  num,\n+\t\t\t   bfd_boolean   with_md5)\n+{\n+  const char *file;\n+  size_t dirlen;\n+  unsigned int i, d;\n+\n+  /* Short circuit the common case of adding the same pathname\n+     as last time.  */\n+  if (num < files_allocated && files[num].filename != NULL)\n+    {\n+      const char * dir = NULL;\n+\n+      if (dirs)\n+\tdir = dirs[files[num].dir];\n+\n+      if (with_md5\n+\t  && memcmp (generic_bignum, files[num].md5, NUM_MD5_BYTES) != 0)\n+\tgoto fail;\n+\n+      if (dirname != NULL)\n+\t{\n+\t  if (dir != NULL && filename_cmp (dir, dirname) != 0)\n+\t    goto fail;\n+      \n+\t  if (filename_cmp (filename, files[num].filename) != 0)\n+\t    goto fail;\n+\n+\t  /* If the filenames match, but the directory table entry was\n+\t     empty, then fill it with the provided directory name.  */\n+\t  if (dir == NULL)\n+\t    dirs[files[num].dir] = xmemdup0 (dirname, strlen (dirname));\n+\t    \n+\t  return TRUE;\n+\t}\n+      else if (dir != NULL) \n+\t{\n+\t  dirlen = strlen (dir);\n+\t  if (filename_ncmp (filename, dir, dirlen) == 0\n+\t      && IS_DIR_SEPARATOR (filename [dirlen])\n+\t      && filename_cmp (filename + dirlen + 1, files[num].filename) == 0)\n+\t    return TRUE;\n+\t}\n+      else /* dir == NULL  */\n+\t{\n+\t  file = get_basename (filename);\n+\t  if (filename_cmp (file, files[num].filename) == 0)\n+\t    {\n+\t      if (file > filename)\n+\t\t/* The filenames match, but the directory table entry is empty.\n+\t\t   Fill it with the provided directory name.  */\n+\t\tdirs[files[num].dir] = xmemdup0 (filename, file - filename);\n+\t      return TRUE;\n+\t    }\n+\t}\n+\n+    fail:\n+      as_bad (_(\"file table slot %u is already occupied by a different file (%s%s%s vs %s%s%s)\"),\n+\t      num,\n+\t      dir == NULL ? \"\" : dir,\n+\t      dir == NULL ? \"\" : \"/\",\n+\t      files[num].filename,\n+\t      dirname == NULL ? \"\" : dirname,\n+\t      dirname == NULL ? \"\" : \"/\",\n+\t      filename);\n+      return FALSE;\n+    }\n+\n+  if (dirname == NULL)\n+    {\n+      dirname = filename;\n+      file = get_basename (filename);\n+      dirlen = file - filename;\n+    }\n+  else\n+    {\n+      dirlen = strlen (dirname);\n+      file = filename;\n+    }\n+  \n+  d = get_directory_table_entry (dirname, dirlen, num == 0);\n+  i = num;\n+\n+  if (i >= files_allocated)\n+    {\n+      unsigned int old = files_allocated;\n+\n+      files_allocated = i + 32;\n+      /* Catch wraparound.  */\n+      if (files_allocated <= old)\n+\t{\n+\t  as_bad (_(\"file number %lu is too big\"), (unsigned long) i);\n+\t  return FALSE;\n+\t}\n+\n+      files = XRESIZEVEC (struct file_entry, files, files_allocated);\n+      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));\n+    }\n+\n+  files[i].filename = file;\n+  files[i].dir = d;\n+  if (with_md5)\n+    {\n+      if (target_big_endian)\n+\t{\n+\t  /* md5's are stored in litte endian format.  */\n+\t  unsigned int     bits_remaining = NUM_MD5_BYTES * BITS_PER_CHAR;\n+\t  unsigned int     byte = NUM_MD5_BYTES;\n+\t  unsigned int     bignum_index = 0;\n+\n+\t  while (bits_remaining)\n+\t    {\n+\t      unsigned int bignum_bits_remaining = LITTLENUM_NUMBER_OF_BITS;\n+\t      valueT       bignum_value = generic_bignum [bignum_index];\n+\t      bignum_index ++;\n+\n+\t      while (bignum_bits_remaining)\n+\t\t{\n+\t\t  files[i].md5[--byte] = bignum_value & 0xff;\n+\t\t  bignum_value >>= 8;\n+\t\t  bignum_bits_remaining -= 8;\n+\t\t  bits_remaining -= 8;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  unsigned int     bits_remaining = NUM_MD5_BYTES * BITS_PER_CHAR;\n+\t  unsigned int     byte = 0;\n+\t  unsigned int     bignum_index = 0;\n+\n+\t  while (bits_remaining)\n+\t    {\n+\t      unsigned int bignum_bits_remaining = LITTLENUM_NUMBER_OF_BITS;\n+\t      valueT       bignum_value = generic_bignum [bignum_index];\n+\n+\t      bignum_index ++;\n+\n+\t      while (bignum_bits_remaining)\n+\t\t{\n+\t\t  files[i].md5[byte++] = bignum_value & 0xff;\n+\t\t  bignum_value >>= 8;\n+\t\t  bignum_bits_remaining -= 8;\n+\t\t  bits_remaining -= 8;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    memset (files[i].md5, 0, NUM_MD5_BYTES);\n+\n+  if (files_in_use < i + 1)\n+    files_in_use = i + 1;\n+\n+  return TRUE;\n+}\n+\n /* Returns the current source information.  If .file directives have\n    been encountered, the info for the corresponding source file is\n    returned.  Otherwise, the info for the assembly source file is\n@@ -558,7 +884,8 @@ dwarf2_where (struct dwarf2_line_info *line)\n \n       memset (line, 0, sizeof (*line));\n       filename = as_where (&line->line);\n-      line->filenum = get_filenum (filename, 0);\n+      line->filenum = allocate_filenum (filename);\n+      /* FIXME: We should check the return value from allocate_filenum.  */\n       line->column = 0;\n       line->flags = DWARF2_FLAG_IS_STMT;\n       line->isa = current.isa;\n@@ -670,108 +997,6 @@ dwarf2_emit_label (symbolS *label)\n   dwarf2_consume_line_info ();\n }\n \n-/* Get a .debug_line file number for FILENAME.  If NUM is nonzero,\n-   allocate it on that file table slot, otherwise return the first\n-   empty one.  */\n-\n-static unsigned int\n-get_filenum (const char *filename, unsigned int num)\n-{\n-  static unsigned int last_used, last_used_dir_len;\n-  const char *file;\n-  size_t dir_len;\n-  unsigned int i, dir;\n-\n-  if (num == 0 && last_used)\n-    {\n-      if (! files[last_used].dir\n-\t  && filename_cmp (filename, files[last_used].filename) == 0)\n-\treturn last_used;\n-      if (files[last_used].dir\n-\t  && filename_ncmp (filename, dirs[files[last_used].dir],\n-\t\t\t    last_used_dir_len) == 0\n-\t  && IS_DIR_SEPARATOR (filename [last_used_dir_len])\n-\t  && filename_cmp (filename + last_used_dir_len + 1,\n-\t\t\t   files[last_used].filename) == 0)\n-\treturn last_used;\n-    }\n-\n-  file = lbasename (filename);\n-  /* Don't make empty string from / or A: from A:/ .  */\n-#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-  if (file <= filename + 3)\n-    file = filename;\n-#else\n-  if (file == filename + 1)\n-    file = filename;\n-#endif\n-  dir_len = file - filename;\n-\n-  dir = 0;\n-  if (dir_len)\n-    {\n-#ifndef DWARF2_DIR_SHOULD_END_WITH_SEPARATOR\n-      --dir_len;\n-#endif\n-      for (dir = 1; dir < dirs_in_use; ++dir)\n-\tif (filename_ncmp (filename, dirs[dir], dir_len) == 0\n-\t    && dirs[dir][dir_len] == '\\0')\n-\t  break;\n-\n-      if (dir >= dirs_in_use)\n-\t{\n-\t  if (dir >= dirs_allocated)\n-\t    {\n-\t      dirs_allocated = dir + 32;\n-\t      dirs = XRESIZEVEC (char *, dirs, dirs_allocated);\n-\t    }\n-\n-\t  dirs[dir] = xmemdup0 (filename, dir_len);\n-\t  dirs_in_use = dir + 1;\n-\t}\n-    }\n-\n-  if (num == 0)\n-    {\n-      for (i = 1; i < files_in_use; ++i)\n-\tif (files[i].dir == dir\n-\t    && files[i].filename\n-\t    && filename_cmp (file, files[i].filename) == 0)\n-\t  {\n-\t    last_used = i;\n-\t    last_used_dir_len = dir_len;\n-\t    return i;\n-\t  }\n-    }\n-  else\n-    i = num;\n-\n-  if (i >= files_allocated)\n-    {\n-      unsigned int old = files_allocated;\n-\n-      files_allocated = i + 32;\n-      /* Catch wraparound.  */\n-      if (files_allocated <= old)\n-\t{\n-\t  as_bad (_(\"file number %lu is too big\"), (unsigned long) i);\n-\t  return 0;\n-\t}\n-\n-      files = XRESIZEVEC (struct file_entry, files, files_allocated);\n-      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));\n-    }\n-\n-  files[i].filename = file;\n-  files[i].dir = dir;\n-  if (files_in_use < i + 1)\n-    files_in_use = i + 1;\n-  last_used = i;\n-  last_used_dir_len = dir_len;\n-\n-  return i;\n-}\n-\n /* Handle two forms of .file directive:\n    - Pass .file \"source.c\" to s_app_file\n    - Handle .file 1 \"source.c\" by adding an entry to the DWARF-2 file table\n@@ -781,8 +1006,10 @@ get_filenum (const char *filename, unsigned int num)\n char *\n dwarf2_directive_filename (void)\n {\n+  bfd_boolean with_md5 = TRUE;\n   valueT num;\n   char *filename;\n+  const char * dirname = NULL;\n   int filename_len;\n \n   /* Continue to accept a bare string and pass it off.  */\n@@ -795,24 +1022,48 @@ dwarf2_directive_filename (void)\n \n   num = get_absolute_expression ();\n \n-  if ((offsetT) num < 1 && dwarf_level < 5)\n+  if ((offsetT) num < 1 && DWARF2_LINE_VERSION < 5)\n     {\n       as_bad (_(\"file number less than one\"));\n       ignore_rest_of_line ();\n       return NULL;\n     }\n \n-  if (num == 0)\n-    {\n-      demand_empty_rest_of_line ();\n-      return NULL;\n-    }\n+  /* FIXME: Should we allow \".file <N>\\n\" as an expression meaning\n+     \"switch back to the already allocated file <N> as the current\n+     file\" ?  */\n \n   filename = demand_copy_C_string (&filename_len);\n   if (filename == NULL)\n     /* demand_copy_C_string will have already generated an error message.  */\n     return NULL;\n \n+  /* For DWARF-5 support we also accept:\n+     .file <NUM> [\"<dir>\"] \"<file>\" [md5 <NUM>]  */\n+  if (DWARF2_LINE_VERSION > 4)\n+    {\n+      SKIP_WHITESPACE ();\n+      if (*input_line_pointer == '\"')\n+\t{\n+\t  dirname = filename;\n+\t  filename = demand_copy_C_string (&filename_len);\n+\t  SKIP_WHITESPACE ();\n+\t}\n+\n+      if (strncmp (input_line_pointer, \"md5\", 3) == 0)\n+\t{\n+\t  input_line_pointer += 3;\n+\t  SKIP_WHITESPACE ();\n+\n+\t  expressionS exp;\n+\t  expression_and_evaluate (& exp);\n+\t  if (exp.X_op != O_big)\n+\t    as_bad (_(\"md5 value too small or not a constant\"));\n+\t  else\n+\t    with_md5 = TRUE;\n+\t}\n+    }\n+\n   demand_empty_rest_of_line ();\n \n   /* A .file directive implies compiler generated debug information is\n@@ -825,13 +1076,10 @@ dwarf2_directive_filename (void)\n       as_bad (_(\"file number %lu is too big\"), (unsigned long) num);\n       return NULL;\n     }\n-  if (num < files_in_use && files[num].filename != 0)\n-    {\n-      as_bad (_(\"file number %u already allocated\"), (unsigned int) num);\n-      return NULL;\n-    }\n \n-  (void) get_filenum (filename, (unsigned int) num);\n+  if (! allocate_filename_to_slot (dirname, filename, (unsigned int) num,\n+\t\t\t\t   with_md5))\n+    return NULL;\n \n   return filename;\n }\n@@ -861,10 +1109,14 @@ dwarf2_directive_loc (int dummy ATTRIBUTE_UNUSED)\n \n   if (filenum < 1)\n     {\n-      as_bad (_(\"file number less than one\"));\n-      return;\n+      if (filenum != 0 || DWARF2_LINE_VERSION < 5)\n+\t{\n+\t  as_bad (_(\"file number less than one\"));\n+\t  return;\n+\t}\n     }\n-  if (filenum >= (int) files_in_use || files[filenum].filename == 0)\n+\n+  if (filenum >= (int) files_in_use || files[filenum].filename == NULL)\n     {\n       as_bad (_(\"unassigned file number %ld\"), (long) filenum);\n       return;\n@@ -1710,34 +1962,130 @@ process_entries (segT seg, struct line_entry *e)\n /* Emit the directory and file tables for .debug_line.  */\n \n static void\n-out_file_list (void)\n+out_dir_and_file_list (void)\n {\n   size_t size;\n   const char *dir;\n   char *cp;\n   unsigned int i;\n+  bfd_boolean emit_md5 = FALSE;\n+  bfd_boolean emit_timestamps = TRUE;\n+  bfd_boolean emit_filesize = TRUE;\n \n+  /* Output the Directory Table.  */\n+\n+  if (DWARF2_LINE_VERSION >= 5)\n+    {\n+      out_byte (1);\n+      out_uleb128 (DW_LNCT_path);\n+      /* FIXME: it would be better to store these strings in\n+\t the .debug_line_str section and reference them here.  */\n+      out_uleb128 (DW_FORM_string);\n+      out_uleb128 (dirs_in_use);\n+    }\n+      \n   /* Emit directory list.  */\n+  if (DWARF2_LINE_VERSION >= 5)\n+    {\n+      if (dirs[0] == NULL)\n+\tdir = remap_debug_filename (\".\");\n+      else\n+\tdir = remap_debug_filename (dirs[0]);\n+\t\n+      size = strlen (dir) + 1;\n+      cp = frag_more (size);\n+      memcpy (cp, dir, size);\n+    }\n   for (i = 1; i < dirs_in_use; ++i)\n     {\n       dir = remap_debug_filename (dirs[i]);\n       size = strlen (dir) + 1;\n       cp = frag_more (size);\n       memcpy (cp, dir, size);\n     }\n-  /* Terminate it.  */\n-  out_byte ('\\0');\n \n-  for (i = 1; i < files_in_use; ++i)\n+  if (DWARF2_LINE_VERSION < 5)\n+    /* Terminate it.  */\n+    out_byte ('\\0');\n+\n+  /* Output the File Name Table.  */\n+\n+  if (DWARF2_LINE_VERSION >= 5)\n+    {\n+      unsigned int columns = 4;\n+\n+      if (((unsigned long) DWARF2_FILE_TIME_NAME (\"\", \"\")) == -1UL)\n+\t{\n+\t  emit_timestamps = FALSE;\n+\t  -- columns;\n+\t}\n+\n+      if (DWARF2_FILE_SIZE_NAME (\"\", \"\") == -1)\n+\t{\n+\t  emit_filesize = FALSE;\n+\t  -- columns;\n+\t}\n+\n+      for (i = 0; i < files_in_use; ++i)\n+\tif (files[i].md5[0] != 0)\n+\t  break;\n+      if (i < files_in_use)\n+\t{\n+\t  emit_md5 = TRUE;\n+\t  ++ columns;\n+\t}\n+      \n+      /* The number of format entries to follow.  */\n+      out_byte (columns);\n+\n+      /* The format of the file name.  */\n+      out_uleb128 (DW_LNCT_path);\n+      /* FIXME: it would be better to store these strings in\n+\t the .debug_line_str section and reference them here.  */\n+      out_uleb128 (DW_FORM_string);\n+\n+      /* The format of the directory index.  */\n+      out_uleb128 (DW_LNCT_directory_index);\n+      out_uleb128 (DW_FORM_udata);\n+\n+      if (emit_timestamps)\n+\t{\n+\t  /* The format of the timestamp.  */\n+\t  out_uleb128 (DW_LNCT_timestamp);\n+\t  out_uleb128 (DW_FORM_udata);\n+\t}\n+\n+      if (emit_filesize)\n+\t{\n+\t  /* The format of the file size.  */\n+\t  out_uleb128 (DW_LNCT_size);\n+\t  out_uleb128 (DW_FORM_udata);\n+\t}\n+\n+      if (emit_md5)\n+\t{\n+\t  /* The format of the MD5 sum.  */\n+\t  out_uleb128 (DW_LNCT_MD5);\n+\t  out_uleb128 (DW_FORM_data16);\n+\t}\n+\n+      /* The number of entries in the table.  */\n+      out_uleb128 (files_in_use);\n+   }\n+      \n+  for (i = DWARF2_LINE_VERSION > 4 ? 0 : 1; i < files_in_use; ++i)\n     {\n       const char *fullfilename;\n \n       if (files[i].filename == NULL)\n \t{\n-\t  as_bad (_(\"unassigned file number %ld\"), (long) i);\n \t  /* Prevent a crash later, particularly for file 1.  */\n \t  files[i].filename = \"\";\n-\t  continue;\n+\t  if (DWARF2_LINE_VERSION < 5 || i != 0)\n+\t    {\n+\t      as_bad (_(\"unassigned file number %ld\"), (long) i);\n+\t      continue;\n+\t    }\n \t}\n \n       fullfilename = DWARF2_FILE_NAME (files[i].filename,\n@@ -1746,17 +2094,45 @@ out_file_list (void)\n       cp = frag_more (size);\n       memcpy (cp, fullfilename, size);\n \n-      out_uleb128 (files[i].dir);\t/* directory number */\n+      /* Directory number.  */\n+      out_uleb128 (files[i].dir);\n+\n       /* Output the last modification timestamp.  */\n-      out_uleb128 (DWARF2_FILE_TIME_NAME (files[i].filename,\n-\t\t\t\t\t  files[i].dir ? dirs [files [i].dir] : \"\"));\n+      if (emit_timestamps)\n+\t{\n+\t  offsetT timestamp;\n+\n+\t  timestamp = DWARF2_FILE_TIME_NAME (files[i].filename,\n+\t\t\t\t\t     files[i].dir ? dirs [files [i].dir] : \"\");\n+\t  if (timestamp == -1)\n+\t    timestamp = 0;\n+\t  out_uleb128 (timestamp);\n+\t}\n+\n       /* Output the filesize.  */\n-      out_uleb128 (DWARF2_FILE_SIZE_NAME (files[i].filename,\n-\t\t\t\t\t  files[i].dir ? dirs [files [i].dir] : \"\"));\n+      if (emit_filesize)\n+\t{\n+\t  offsetT filesize;\n+\t  filesize = DWARF2_FILE_SIZE_NAME (files[i].filename,\n+\t\t\t\t\t    files[i].dir ? dirs [files [i].dir] : \"\");\n+\t  if (filesize == -1)\n+\t    filesize = 0;\n+\t  out_uleb128 (filesize);\n+\t}\n+\n+      /* Output the md5 sum.  */\n+      if (emit_md5)\n+\t{\n+\t  int b;\n+\n+\t  for (b = 0; b < NUM_MD5_BYTES; b++)\n+\t    out_byte (files[i].md5[b]);\n+\t}\n     }\n \n-  /* Terminate filename list.  */\n-  out_byte (0);\n+  if (DWARF2_LINE_VERSION < 5)\n+    /* Terminate filename list.  */\n+    out_byte (0);\n }\n \n /* Switch to SEC and output a header length field.  Return the size of\n@@ -1833,6 +2209,11 @@ out_debug_line (segT line_seg)\n   /* Version.  */\n   out_two (DWARF2_LINE_VERSION);\n \n+  if (DWARF2_LINE_VERSION >= 5)\n+    {\n+      out_byte (sizeof_address);\n+      out_byte (0); /* Segment Selector size.  */\n+    }\n   /* Length of the prologue following this length.  */\n   prologue_start = symbol_temp_make ();\n   prologue_end = symbol_temp_make ();\n@@ -1845,6 +2226,8 @@ out_debug_line (segT line_seg)\n \n   /* Parameters of the state machine.  */\n   out_byte (DWARF2_LINE_MIN_INSN_LENGTH);\n+  if (DWARF2_LINE_VERSION >= 4)\n+    out_byte (DWARF2_LINE_MAX_OPS_PER_INSN);\n   out_byte (DWARF2_LINE_DEFAULT_IS_STMT);\n   out_byte (DWARF2_LINE_BASE);\n   out_byte (DWARF2_LINE_RANGE);\n@@ -1863,8 +2246,11 @@ out_debug_line (segT line_seg)\n   out_byte (0);\t\t\t/* DW_LNS_set_prologue_end */\n   out_byte (0);\t\t\t/* DW_LNS_set_epilogue_begin */\n   out_byte (1);\t\t\t/* DW_LNS_set_isa */\n+  /* We have emitted 12 opcode lengths, so make that this\n+     matches up to the opcode base value we have been using.  */\n+  gas_assert (DWARF2_LINE_OPCODE_BASE == 13);\n \n-  out_file_list ();\n+  out_dir_and_file_list ();\n \n   symbol_set_value_now (prologue_end);\n \n@@ -2134,19 +2520,20 @@ out_debug_str (segT str_seg, symbolS **name_sym, symbolS **comp_dir_sym,\n   const char *dirname;\n   char *p;\n   int len;\n+  int first_file = DWARF2_LINE_VERSION > 4 ? 0 : 1;\n \n   subseg_set (str_seg, 0);\n \n   /* DW_AT_name.  We don't have the actual file name that was present\n-     on the command line, so assume files[1] is the main input file.\n+     on the command line, so assume files[first_file] is the main input file.\n      We're not supposed to get called unless at least one line number\n      entry was emitted, so this should always be defined.  */\n   *name_sym = symbol_temp_new_now_octets ();\n   if (files_in_use == 0)\n     abort ();\n-  if (files[1].dir)\n+  if (files[first_file].dir)\n     {\n-      dirname = remap_debug_filename (dirs[files[1].dir]);\n+      dirname = remap_debug_filename (dirs[files[first_file].dir]);\n       len = strlen (dirname);\n #ifdef TE_VMS\n       /* Already has trailing slash.  */\n@@ -2158,9 +2545,9 @@ out_debug_str (segT str_seg, symbolS **name_sym, symbolS **comp_dir_sym,\n       INSERT_DIR_SEPARATOR (p, len);\n #endif\n     }\n-  len = strlen (files[1].filename) + 1;\n+  len = strlen (files[first_file].filename) + 1;\n   p = frag_more (len);\n-  memcpy (p, files[1].filename, len);\n+  memcpy (p, files[first_file].filename, len);\n \n   /* DW_AT_comp_dir */\n   *comp_dir_sym = symbol_temp_new_now_octets ();"
    },
    {
      "sha": "3dffa63965bb2071404758d8b6ccf88f0d5fc5d8",
      "filename": "gas/testsuite/gas/elf/dwarf-5-file0.d",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/testsuite/gas/elf/dwarf-5-file0.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/testsuite/gas/elf/dwarf-5-file0.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/elf/dwarf-5-file0.d?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -2,5 +2,18 @@\n #name: DWARF5 .line 0\n #readelf: -wl\n \n+#...\n+ The Directory Table \\(offset 0x.*, lines 3, columns 1\\):\n+  Entry\tName\n+  0\tmaster directory\n+  1\tsecondary directory\n+  2\t/tmp\n+\n+ The File Name Table \\(offset 0x.*, lines 3, columns 3\\):\n+  Entry\tDir\tMD5\t\t\t\tName\n+  0\t0 0x00000000000000000000000000000000\tmaster source file\n+  1\t1 0x00000000000000000000000000000000\tsecondary source file\n+  2\t2 0x95828e8bc4f7404dbf7526fb7bd0f192\tfoo.c\n #pass\n \n+"
    },
    {
      "sha": "2792ba8c441730e15910b8ea87078537973a2a48",
      "filename": "gas/testsuite/gas/elf/dwarf-5-file0.s",
      "status": "modified",
      "additions": 19,
      "deletions": 13,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/testsuite/gas/elf/dwarf-5-file0.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/testsuite/gas/elf/dwarf-5-file0.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/elf/dwarf-5-file0.s?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -1,17 +1,23 @@\n-\t.text\n+\t.section\t.debug_info,\"\",%progbits\n+\t.4byte\t0x8a\n+\t.2byte  0x2\n+\t.4byte\t.Ldebug_abbrev0\n+\t.byte\t0x4\n+\t.uleb128 0x1\n \n- .file 0\n- .line 1\n-\t.long 3\n+\t.file 0 \"master directory/master source file\"\n+\t.line 1\n+\t.text\n+\t.word 0\n \n- .file 1 \"asdf\"\n- .line 2\n-\t.long 5\n+\t.file 1 \"secondary directory/secondary source file\"\n+\t.line 2\n+\t.word 2\n \n- .file 0\n- .line 4\n-\t.long 3\n+\t.file \"master source file\"\n+\t.line 4\n+\t.word 4\n \n- .file 2 \"def\"\n- .line 5\n-\t.long 3\n+\t.file 2 \"/tmp\" \"foo.c\" md5 0x95828e8bc4f7404dbf7526fb7bd0f192\n+\t.line 5\n+\t.word 6"
    },
    {
      "sha": "1256e85cfcbd3c56f6a1dff82339c0d165ef60e2",
      "filename": "gas/testsuite/gas/lns/lns-diag-1.l",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/testsuite/gas/lns/lns-diag-1.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5496f3c635dce3e12348d6e81c3f74815fdfe7b5/gas/testsuite/gas/lns/lns-diag-1.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/lns/lns-diag-1.l?ref=5496f3c635dce3e12348d6e81c3f74815fdfe7b5",
      "patch": "@@ -1,7 +1,7 @@\n .*: Assembler messages:\n .*:2: Error: file number less than one\n .*:3: Error: missing string\n-.*:4: Error: file number 1 already allocated\n+.*:4: Error: file table slot 1 is already occupied.*\n .*:8: Error: unassigned file number 3\n .*:9: Error: junk at end of line, first unrecognized character is `1'\n .*:12: Error: junk at end of line, first unrecognized character is `0'"
    }
  ]
}