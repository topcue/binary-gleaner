{
  "sha": "af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWYyZGRmNjlhYjg1YWRkMzE1NWNmNTVmNjVlNmU5ZjNjOWJjYjI5YQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-12T08:18:13Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-12T11:40:33Z"
    },
    "message": "SAFE_BYTE_GET64\n\nFunctions dealing with lack of a 64-bit integer type can disappear now\nthat we require C99.  Printing using dwarf_vmatoa is better too.\n\nbinutils/\n\t* dwarf.c (dwarf_vmatoa64, SAFE_BYTE_GET64, add64): Delete.\n\t(skip_attr_bytes): Replace use of SAFE_BYTE_GET64 with\n\tSAFE_BYTE_GET_AND_INC.\n\t(read_and_display_attr_value): Likewise.  Print using dwarf_vmatoa.\n\t(process_debug_info, process_cu_tu_index): Likewise.\n\t* elfcomm.c (byte_put, byte_put_little_endian, byte_put_big_endian),\n\t(byte_get, byte_get_little_endian, byte_get_big_endian),\n\t(byte_get_signed): Make size param unsigned.  Remove code dealing\n\twith 4-byte elf_vma.\n\t(byte_get_64): Delete.\n\t* elfcomm.h  (byte_put, byte_put_little_endian, byte_put_big_endian),\n\t(byte_get, byte_get_little_endian, byte_get_big_endian),\n\t(byte_get_signed): Update prototypes.\n\t(byte_get_64): Delete.\ngas/\n\t* testsuite/gas/elf/dwarf-5-file0.d: Update.\n\t* testsuite/gas/i386/dwarf5-line-1.d: Update.",
    "tree": {
      "sha": "da4e33811d28a4f7cda938183b3d349780b10c8b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/da4e33811d28a4f7cda938183b3d349780b10c8b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0d872fca0293041a5cb7c54a4a04855323563d8e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0d872fca0293041a5cb7c54a4a04855323563d8e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0d872fca0293041a5cb7c54a4a04855323563d8e"
    }
  ],
  "stats": {
    "total": 370,
    "additions": 93,
    "deletions": 277
  },
  "files": [
    {
      "sha": "1d97d6bfe79a892b136a21a4d12644fae95cd659",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "patch": "@@ -1,3 +1,20 @@\n+2021-05-12  Alan Modra  <amodra@gmail.com>\n+\n+\t* dwarf.c (dwarf_vmatoa64, SAFE_BYTE_GET64, add64): Delete.\n+\t(skip_attr_bytes): Replace use of SAFE_BYTE_GET64 with\n+\tSAFE_BYTE_GET_AND_INC.\n+\t(read_and_display_attr_value): Likewise.  Print using dwarf_vmatoa.\n+\t(process_debug_info, process_cu_tu_index): Likewise.\n+\t* elfcomm.c (byte_put, byte_put_little_endian, byte_put_big_endian),\n+\t(byte_get, byte_get_little_endian, byte_get_big_endian),\n+\t(byte_get_signed): Make size param unsigned.  Remove code dealing\n+\twith 4-byte elf_vma.\n+\t(byte_get_64): Delete.\n+\t* elfcomm.h  (byte_put, byte_put_little_endian, byte_put_big_endian),\n+\t(byte_get, byte_get_little_endian, byte_get_big_endian),\n+\t(byte_get_signed): Update prototypes.\n+\t(byte_get_64): Delete.\n+\n 2021-05-12  Alan Modra  <amodra@gmail.com>\n \n \tPR 27836"
    },
    {
      "sha": "08f8ccdee43fa5e6e8ced8cd7bd6bd6891c393b2",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 43,
      "deletions": 157,
      "changes": 200,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "patch": "@@ -307,27 +307,6 @@ print_dwarf_view (dwarf_vma value, unsigned num_bytes, int force)\n     printf (\"%*s\", len + 1, \"\");\n }\n \n-/* Format a 64-bit value, given as two 32-bit values, in hex.\n-   For reentrancy, this uses a buffer provided by the caller.  */\n-\n-static const char *\n-dwarf_vmatoa64 (dwarf_vma hvalue, dwarf_vma lvalue, char *buf,\n-\t\tunsigned int buf_len)\n-{\n-  int len = 0;\n-\n-  if (hvalue == 0)\n-    snprintf (buf, buf_len, \"%\" DWARF_VMA_FMT \"x\", lvalue);\n-  else\n-    {\n-      len = snprintf (buf, buf_len, \"%\" DWARF_VMA_FMT \"x\", hvalue);\n-      snprintf (buf + len, buf_len - len,\n-\t\t\"%08\" DWARF_VMA_FMT \"x\", lvalue);\n-    }\n-\n-  return buf;\n-}\n-\n /* Read in a LEB128 encoded value starting at address DATA.\n    If SIGN is true, return a signed LEB128 value.\n    If LENGTH_RETURN is not NULL, return in it the number of bytes read.\n@@ -457,20 +436,6 @@ read_leb128 (unsigned char *data,\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-#define SAFE_BYTE_GET64(PTR, HIGH, LOW, END)\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if ((PTR) <= (END) - 8)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  byte_get_64 ((PTR), (HIGH), (LOW));\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  * (LOW) = * (HIGH) = 0;\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n typedef struct State_Machine_Registers\n {\n   dwarf_vma address;\n@@ -1834,34 +1799,6 @@ find_cu_tu_set_v2 (dwarf_vma cu_offset, int do_types)\n   return NULL;\n }\n \n-/* Add INC to HIGH_BITS:LOW_BITS.  */\n-static void\n-add64 (dwarf_vma * high_bits, dwarf_vma * low_bits, dwarf_vma inc)\n-{\n-  dwarf_vma tmp = * low_bits;\n-\n-  tmp += inc;\n-\n-  /* FIXME: There is probably a better way of handling this:\n-\n-     We need to cope with dwarf_vma being a 32-bit or 64-bit\n-     type.  Plus regardless of its size LOW_BITS is meant to\n-     only hold 32-bits, so if there is overflow or wrap around\n-     we must propagate into HIGH_BITS.  */\n-  if (tmp < * low_bits)\n-    {\n-      ++ * high_bits;\n-    }\n-  else if (sizeof (tmp) > 8\n-\t   && (tmp >> 31) > 1)\n-    {\n-      ++ * high_bits;\n-      tmp &= 0xFFFFFFFF;\n-    }\n-\n-  * low_bits = tmp;\n-}\n-\n static const char *\n fetch_alt_indirect_string (dwarf_vma offset)\n {\n@@ -2079,20 +2016,8 @@ skip_attr_bytes (unsigned long          form,\n       break;\n \n     case DW_FORM_ref8:\n-      {\n-\tdwarf_vma high_bits;\n-\n-\tSAFE_BYTE_GET64 (data, &high_bits, &uvalue, end);\n-\tdata += 8;\n-\tif (sizeof (uvalue) > 4)\n-\t  uvalue += high_bits << 32;\n-\telse if (high_bits != 0)\n-\t  {\n-\t    /* FIXME: What to do ?  */\n-\t    return NULL;\n-\t  }\n-\tbreak;\n-      }\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 8, end);\n+      break;\n \n     case DW_FORM_data8:\n     case DW_FORM_ref_sig8:\n@@ -2476,9 +2401,10 @@ read_and_display_attr_value (unsigned long           attribute,\n \t\t\t     int                     level)\n {\n   dwarf_signed_vma svalue;\n-  dwarf_vma        uvalue = 0;\n-  unsigned char *  block_start = NULL;\n-  unsigned char *  orig_data = data;\n+  dwarf_vma uvalue = 0;\n+  dwarf_vma uvalue_hi = 0;\n+  unsigned char *block_start = NULL;\n+  unsigned char *orig_data = data;\n \n   if (data > end || (data == end && form != DW_FORM_flag_present))\n     {\n@@ -2556,6 +2482,24 @@ read_and_display_attr_value (unsigned long           attribute,\n       SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);\n       break;\n \n+    case DW_FORM_ref_sup8:\n+    case DW_FORM_ref8:\n+    case DW_FORM_data8:\n+    case DW_FORM_ref_sig8:\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 8, end);\n+      break;\n+\n+    case DW_FORM_data16:\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 8, end);\n+      SAFE_BYTE_GET_AND_INC (uvalue_hi, data, 8, end);\n+      if (byte_get != byte_get_little_endian)\n+\t{\n+\t  dwarf_vma utmp = uvalue;\n+\t  uvalue = uvalue_hi;\n+\t  uvalue_hi = utmp;\n+\t}\n+      break;\n+\n     case DW_FORM_sdata:\n       READ_SLEB (svalue, data, end);\n       uvalue = svalue;\n@@ -2639,54 +2583,18 @@ read_and_display_attr_value (unsigned long           attribute,\n     case DW_FORM_data8:\n       if (!do_loc)\n \t{\n-\t  dwarf_vma high_bits;\n-\t  dwarf_vma utmp;\n-\t  char buf[64];\n-\n-\t  SAFE_BYTE_GET64 (data, &high_bits, &uvalue, end);\n-\t  utmp = uvalue;\n+\t  dwarf_vma utmp = uvalue;\n \t  if (form == DW_FORM_ref8)\n-\t    add64 (& high_bits, & utmp, cu_offset);\n-\t  printf (\"%c0x%s\", delimiter,\n-\t\t  dwarf_vmatoa64 (high_bits, utmp, buf, sizeof (buf)));\n+\t    utmp += cu_offset;\n+\t  printf (\"%c0x%s\", delimiter, dwarf_vmatoa (\"x\", utmp));\n \t}\n-\n-      if ((do_loc || do_debug_loc || do_debug_ranges)\n-\t  && num_debug_info_entries == 0)\n-\t{\n-\t  if (sizeof (uvalue) == 8)\n-\t    SAFE_BYTE_GET (uvalue, data, 8, end);\n-\t  else\n-\t    error (_(\"DW_FORM_data8 is unsupported when sizeof (dwarf_vma) != 8\\n\"));\n-\t}\n-\n-      data += 8;\n       break;\n \n     case DW_FORM_data16:\n       if (!do_loc)\n-\t{\n-\t  dwarf_vma left_high_bits, left_low_bits;\n-\t  dwarf_vma right_high_bits, right_low_bits;\n-\n-\t  SAFE_BYTE_GET64 (data, &left_high_bits, &left_low_bits, end);\n-\t  SAFE_BYTE_GET64 (data + 8, &right_high_bits, &right_low_bits, end);\n-\t  if (byte_get == byte_get_little_endian)\n-\t    {\n-\t      /* Swap them.  */\n-\t      left_high_bits ^= right_high_bits;\n-\t      right_high_bits ^= left_high_bits;\n-\t      left_high_bits ^= right_high_bits;\n-\t      left_low_bits ^= right_low_bits;\n-\t      right_low_bits ^= left_low_bits;\n-\t      left_low_bits ^= right_low_bits;\n-\t    }\n-\t  printf (\" 0x%08\" DWARF_VMA_FMT \"x%08\" DWARF_VMA_FMT \"x\"\n-\t\t  \"%08\" DWARF_VMA_FMT \"x%08\" DWARF_VMA_FMT \"x\",\n-\t\t  left_high_bits, left_low_bits, right_high_bits,\n-\t\t  right_low_bits);\n-\t}\n-      data += 16;\n+\tprintf (\" 0x%s%s\",\n+\t\tuvalue_hi == 0 ? \"\" : dwarf_vmatoa (\"x\", uvalue_hi),\n+\t\tdwarf_vmatoa_1 (\"x\", uvalue, uvalue_hi == 0 ? 0 : 8));\n       break;\n \n     case DW_FORM_string:\n@@ -2801,20 +2709,8 @@ read_and_display_attr_value (unsigned long           attribute,\n \n     case DW_FORM_ref_sig8:\n       if (!do_loc)\n-\t{\n-\t  dwarf_vma high_bits;\n-\t  char buf[64];\n-\n-\t  SAFE_BYTE_GET64 (data, &high_bits, &uvalue, end);\n-\t  if (do_wide)\n-\t    /* We have already displayed the form name.  */\n-\t    printf (\"%c: 0x%s\", delimiter,\n-\t\t    dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));\n-\t  else\n-\t    printf (\"%csignature: 0x%s\", delimiter,\n-\t\t    dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));\n-\t}\n-      data += 8;\n+\tprintf (\"%c%s: 0x%s\", delimiter, do_wide ? \"\" : \"signature\",\n+\t\tdwarf_vmatoa (\"x\", uvalue));\n       break;\n \n     case DW_FORM_GNU_addr_index:\n@@ -3740,8 +3636,7 @@ process_debug_info (struct dwarf_section * section,\n       unsigned long sec_off;\n       unsigned int offset_size;\n       unsigned int initial_length_size;\n-      dwarf_vma signature_high = 0;\n-      dwarf_vma signature_low = 0;\n+      dwarf_vma signature = 0;\n       dwarf_vma type_offset = 0;\n       struct cu_tu_set *this_set;\n       dwarf_vma abbrev_base;\n@@ -3819,8 +3714,7 @@ process_debug_info (struct dwarf_section * section,\n \n       if (do_types)\n \t{\n-\t  SAFE_BYTE_GET64 (hdrptr, &signature_high, &signature_low, end);\n-\t  hdrptr += 8;\n+\t  SAFE_BYTE_GET_AND_INC (signature, hdrptr, 8, end);\n \t  SAFE_BYTE_GET_AND_INC (type_offset, hdrptr, offset_size, end);\n \t}\n \n@@ -3875,11 +3769,8 @@ process_debug_info (struct dwarf_section * section,\n \t  printf (_(\"   Pointer Size:  %d\\n\"), compunit.cu_pointer_size);\n \t  if (do_types)\n \t    {\n-\t      char buf[64];\n-\n \t      printf (_(\"   Signature:     0x%s\\n\"),\n-\t\t      dwarf_vmatoa64 (signature_high, signature_low,\n-\t\t\t\t      buf, sizeof (buf)));\n+\t\t      dwarf_vmatoa (\"x\", signature));\n \t      printf (_(\"   Type Offset:   0x%s\\n\"),\n \t\t      dwarf_vmatoa (\"x\", type_offset));\n \t    }\n@@ -10426,9 +10317,7 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n   unsigned int nslots;\n   unsigned int i;\n   unsigned int j;\n-  dwarf_vma signature_high;\n-  dwarf_vma signature_low;\n-  char buf[64];\n+  dwarf_vma signature;\n \n   /* PR 17512: file: 002-168123-0.004.  */\n   if (phdr == NULL)\n@@ -10487,8 +10376,8 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \t  unsigned char *shndx_list;\n \t  unsigned int shndx;\n \n-\t  SAFE_BYTE_GET64 (phash, &signature_high, &signature_low, limit);\n-\t  if (signature_high != 0 || signature_low != 0)\n+\t  SAFE_BYTE_GET (signature, phash, 8, limit);\n+\t  if (signature != 0)\n \t    {\n \t      SAFE_BYTE_GET (j, pindex, 4, limit);\n \t      shndx_list = ppool + j * 4;\n@@ -10501,8 +10390,7 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \n \t      if (do_display)\n \t\tprintf (_(\"  [%3d] Signature:  0x%s  Sections: \"),\n-\t\t\ti, dwarf_vmatoa64 (signature_high, signature_low,\n-\t\t\t\t\t   buf, sizeof (buf)));\n+\t\t\ti, dwarf_vmatoa (\"x\", signature));\n \t      for (;;)\n \t\t{\n \t\t  if (shndx_list >= limit)\n@@ -10594,7 +10482,7 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \n       for (i = 0; i < nslots; i++)\n \t{\n-\t  SAFE_BYTE_GET64 (ph, &signature_high, &signature_low, limit);\n+\t  SAFE_BYTE_GET (signature, ph, 8, limit);\n \n \t  SAFE_BYTE_GET (row, pi, 4, limit);\n \t  if (row != 0)\n@@ -10632,8 +10520,7 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \n \t      if (do_display)\n \t\tprintf (_(\"  [%3d] 0x%s\"),\n-\t\t\ti, dwarf_vmatoa64 (signature_high, signature_low,\n-\t\t\t\t\t   buf, sizeof (buf)));\n+\t\t\ti, dwarf_vmatoa (\"x\", signature));\n \t      for (j = 0; j < ncols; j++)\n \t\t{\n \t\t  SAFE_BYTE_GET (val, prow + j * 4, 4, limit);\n@@ -10680,7 +10567,7 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \n       for (i = 0; i < nslots; i++)\n \t{\n-\t  SAFE_BYTE_GET64 (ph, &signature_high, &signature_low, limit);\n+\t  SAFE_BYTE_GET (signature, ph, 8, limit);\n \n \t  SAFE_BYTE_GET (row, pi, 4, limit);\n \t  if (row != 0)\n@@ -10689,8 +10576,7 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \n \t      if (do_display)\n \t\tprintf (_(\"  [%3d] 0x%s\"),\n-\t\t\ti, dwarf_vmatoa64 (signature_high, signature_low,\n-\t\t\t\t\t   buf, sizeof (buf)));\n+\t\t\ti, dwarf_vmatoa (\"x\", signature));\n \n \t      for (j = 0; j < ncols; j++)\n \t\t{"
    },
    {
      "sha": "d4e446c4b052db9ff483e252b3a6475d38044e00",
      "filename": "binutils/elfcomm.c",
      "status": "modified",
      "additions": 17,
      "deletions": 108,
      "changes": 125,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/binutils/elfcomm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/binutils/elfcomm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/elfcomm.c?ref=af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "patch": "@@ -63,12 +63,12 @@ warn (const char *message, ...)\n   va_end (args);\n }\n \n-void (*byte_put) (unsigned char *, elf_vma, int);\n+void (*byte_put) (unsigned char *, elf_vma, unsigned int);\n \n void\n-byte_put_little_endian (unsigned char * field, elf_vma value, int size)\n+byte_put_little_endian (unsigned char * field, elf_vma value, unsigned int size)\n {\n-  if (size <= 0 || size > 8)\n+  if (size > sizeof (elf_vma))\n     {\n       error (_(\"Unhandled data length: %d\\n\"), size);\n       abort ();\n@@ -81,9 +81,9 @@ byte_put_little_endian (unsigned char * field, elf_vma value, int size)\n }\n \n void\n-byte_put_big_endian (unsigned char * field, elf_vma value, int size)\n+byte_put_big_endian (unsigned char * field, elf_vma value, unsigned int size)\n {\n-  if (size <= 0 || size > 8)\n+  if (size > sizeof (elf_vma))\n     {\n       error (_(\"Unhandled data length: %d\\n\"), size);\n       abort ();\n@@ -95,10 +95,10 @@ byte_put_big_endian (unsigned char * field, elf_vma value, int size)\n     }\n }\n \n-elf_vma (*byte_get) (const unsigned char *, int);\n+elf_vma (*byte_get) (const unsigned char *, unsigned int);\n \n elf_vma\n-byte_get_little_endian (const unsigned char *field, int size)\n+byte_get_little_endian (const unsigned char *field, unsigned int size)\n {\n   switch (size)\n     {\n@@ -121,61 +121,37 @@ byte_get_little_endian (const unsigned char *field, int size)\n \t|    (((unsigned long) (field[3])) << 24);\n \n     case 5:\n-      if (sizeof (elf_vma) == 8)\n+      if (sizeof (elf_vma) >= 8)\n \treturn  ((elf_vma) (field[0]))\n \t  |    (((elf_vma) (field[1])) << 8)\n \t  |    (((elf_vma) (field[2])) << 16)\n \t  |    (((elf_vma) (field[3])) << 24)\n \t  |    (((elf_vma) (field[4])) << 32);\n-      else if (sizeof (elf_vma) == 4)\n-\t/* We want to extract data from an 8 byte wide field and\n-\t   place it into a 4 byte wide field.  Since this is a little\n-\t   endian source we can just use the 4 byte extraction code.  */\n-\treturn  ((unsigned long) (field[0]))\n-\t  |    (((unsigned long) (field[1])) << 8)\n-\t  |    (((unsigned long) (field[2])) << 16)\n-\t  |    (((unsigned long) (field[3])) << 24);\n       /* Fall through.  */\n \n     case 6:\n-      if (sizeof (elf_vma) == 8)\n+      if (sizeof (elf_vma) >= 8)\n \treturn  ((elf_vma) (field[0]))\n \t  |    (((elf_vma) (field[1])) << 8)\n \t  |    (((elf_vma) (field[2])) << 16)\n \t  |    (((elf_vma) (field[3])) << 24)\n \t  |    (((elf_vma) (field[4])) << 32)\n \t  |    (((elf_vma) (field[5])) << 40);\n-      else if (sizeof (elf_vma) == 4)\n-\t/* We want to extract data from an 8 byte wide field and\n-\t   place it into a 4 byte wide field.  Since this is a little\n-\t   endian source we can just use the 4 byte extraction code.  */\n-\treturn  ((unsigned long) (field[0]))\n-\t  |    (((unsigned long) (field[1])) << 8)\n-\t  |    (((unsigned long) (field[2])) << 16)\n-\t  |    (((unsigned long) (field[3])) << 24);\n       /* Fall through.  */\n \n     case 7:\n-      if (sizeof (elf_vma) == 8)\n+      if (sizeof (elf_vma) >= 8)\n \treturn  ((elf_vma) (field[0]))\n \t  |    (((elf_vma) (field[1])) << 8)\n \t  |    (((elf_vma) (field[2])) << 16)\n \t  |    (((elf_vma) (field[3])) << 24)\n \t  |    (((elf_vma) (field[4])) << 32)\n \t  |    (((elf_vma) (field[5])) << 40)\n \t  |    (((elf_vma) (field[6])) << 48);\n-      else if (sizeof (elf_vma) == 4)\n-\t/* We want to extract data from an 8 byte wide field and\n-\t   place it into a 4 byte wide field.  Since this is a little\n-\t   endian source we can just use the 4 byte extraction code.  */\n-\treturn  ((unsigned long) (field[0]))\n-\t  |    (((unsigned long) (field[1])) << 8)\n-\t  |    (((unsigned long) (field[2])) << 16)\n-\t  |    (((unsigned long) (field[3])) << 24);\n       /* Fall through.  */\n \n     case 8:\n-      if (sizeof (elf_vma) == 8)\n+      if (sizeof (elf_vma) >= 8)\n \treturn  ((elf_vma) (field[0]))\n \t  |    (((elf_vma) (field[1])) << 8)\n \t  |    (((elf_vma) (field[2])) << 16)\n@@ -184,14 +160,6 @@ byte_get_little_endian (const unsigned char *field, int size)\n \t  |    (((elf_vma) (field[5])) << 40)\n \t  |    (((elf_vma) (field[6])) << 48)\n \t  |    (((elf_vma) (field[7])) << 56);\n-      else if (sizeof (elf_vma) == 4)\n-\t/* We want to extract data from an 8 byte wide field and\n-\t   place it into a 4 byte wide field.  Since this is a little\n-\t   endian source we can just use the 4 byte extraction code.  */\n-\treturn  ((unsigned long) (field[0]))\n-\t  |    (((unsigned long) (field[1])) << 8)\n-\t  |    (((unsigned long) (field[2])) << 16)\n-\t  |    (((unsigned long) (field[3])) << 24);\n       /* Fall through.  */\n \n     default:\n@@ -201,7 +169,7 @@ byte_get_little_endian (const unsigned char *field, int size)\n }\n \n elf_vma\n-byte_get_big_endian (const unsigned char *field, int size)\n+byte_get_big_endian (const unsigned char *field, unsigned int size)\n {\n   switch (size)\n     {\n@@ -223,67 +191,37 @@ byte_get_big_endian (const unsigned char *field, int size)\n \t|   (((unsigned long) (field[0])) << 24);\n \n     case 5:\n-      if (sizeof (elf_vma) == 8)\n+      if (sizeof (elf_vma) >= 8)\n \treturn ((elf_vma) (field[4]))\n \t  |   (((elf_vma) (field[3])) << 8)\n \t  |   (((elf_vma) (field[2])) << 16)\n \t  |   (((elf_vma) (field[1])) << 24)\n \t  |   (((elf_vma) (field[0])) << 32);\n-      else if (sizeof (elf_vma) == 4)\n-\t{\n-\t  /* Although we are extracting data from an 8 byte wide field,\n-\t     we are returning only 4 bytes of data.  */\n-\t  field += 1;\n-\t  return ((unsigned long) (field[3]))\n-\t    |   (((unsigned long) (field[2])) << 8)\n-\t    |   (((unsigned long) (field[1])) << 16)\n-\t    |   (((unsigned long) (field[0])) << 24);\n-\t}\n       /* Fall through.  */\n \n     case 6:\n-      if (sizeof (elf_vma) == 8)\n+      if (sizeof (elf_vma) >= 8)\n \treturn ((elf_vma) (field[5]))\n \t  |   (((elf_vma) (field[4])) << 8)\n \t  |   (((elf_vma) (field[3])) << 16)\n \t  |   (((elf_vma) (field[2])) << 24)\n \t  |   (((elf_vma) (field[1])) << 32)\n \t  |   (((elf_vma) (field[0])) << 40);\n-      else if (sizeof (elf_vma) == 4)\n-\t{\n-\t  /* Although we are extracting data from an 8 byte wide field,\n-\t     we are returning only 4 bytes of data.  */\n-\t  field += 2;\n-\t  return ((unsigned long) (field[3]))\n-\t    |   (((unsigned long) (field[2])) << 8)\n-\t    |   (((unsigned long) (field[1])) << 16)\n-\t    |   (((unsigned long) (field[0])) << 24);\n-\t}\n       /* Fall through.  */\n \n     case 7:\n-      if (sizeof (elf_vma) == 8)\n+      if (sizeof (elf_vma) >= 8)\n \treturn ((elf_vma) (field[6]))\n \t  |   (((elf_vma) (field[5])) << 8)\n \t  |   (((elf_vma) (field[4])) << 16)\n \t  |   (((elf_vma) (field[3])) << 24)\n \t  |   (((elf_vma) (field[2])) << 32)\n \t  |   (((elf_vma) (field[1])) << 40)\n \t  |   (((elf_vma) (field[0])) << 48);\n-      else if (sizeof (elf_vma) == 4)\n-\t{\n-\t  /* Although we are extracting data from an 8 byte wide field,\n-\t     we are returning only 4 bytes of data.  */\n-\t  field += 3;\n-\t  return ((unsigned long) (field[3]))\n-\t    |   (((unsigned long) (field[2])) << 8)\n-\t    |   (((unsigned long) (field[1])) << 16)\n-\t    |   (((unsigned long) (field[0])) << 24);\n-\t}\n       /* Fall through.  */\n \n     case 8:\n-      if (sizeof (elf_vma) == 8)\n+      if (sizeof (elf_vma) >= 8)\n \treturn ((elf_vma) (field[7]))\n \t  |   (((elf_vma) (field[6])) << 8)\n \t  |   (((elf_vma) (field[5])) << 16)\n@@ -292,16 +230,6 @@ byte_get_big_endian (const unsigned char *field, int size)\n \t  |   (((elf_vma) (field[2])) << 40)\n \t  |   (((elf_vma) (field[1])) << 48)\n \t  |   (((elf_vma) (field[0])) << 56);\n-      else if (sizeof (elf_vma) == 4)\n-\t{\n-\t  /* Although we are extracting data from an 8 byte wide field,\n-\t     we are returning only 4 bytes of data.  */\n-\t  field += 4;\n-\t  return ((unsigned long) (field[3]))\n-\t    |   (((unsigned long) (field[2])) << 8)\n-\t    |   (((unsigned long) (field[1])) << 16)\n-\t    |   (((unsigned long) (field[0])) << 24);\n-\t}\n       /* Fall through.  */\n \n     default:\n@@ -311,7 +239,7 @@ byte_get_big_endian (const unsigned char *field, int size)\n }\n \n elf_vma\n-byte_get_signed (const unsigned char *field, int size)\n+byte_get_signed (const unsigned char *field, unsigned int size)\n {\n   elf_vma x = byte_get (field, size);\n \n@@ -339,25 +267,6 @@ byte_get_signed (const unsigned char *field, int size)\n     }\n }\n \n-/* Return the high-order 32-bits and the low-order 32-bits\n-   of an 8-byte value separately.  */\n-\n-void\n-byte_get_64 (const unsigned char *field, elf_vma *high, elf_vma *low)\n-{\n-  if (byte_get == byte_get_big_endian)\n-    {\n-      *high = byte_get_big_endian (field, 4);\n-      *low = byte_get_big_endian (field + 4, 4);\n-    }\n-  else\n-    {\n-      *high = byte_get_little_endian (field + 4, 4);\n-      *low = byte_get_little_endian (field, 4);\n-    }\n-  return;\n-}\n-\n /* Return the path name for a proxy entry in a thin archive, adjusted\n    relative to the path name of the thin archive itself if necessary.\n    Always returns a pointer to malloc'ed memory.  */"
    },
    {
      "sha": "22abb147783e71515980320811466f65b4204736",
      "filename": "binutils/elfcomm.h",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/binutils/elfcomm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/binutils/elfcomm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/elfcomm.h?ref=af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "patch": "@@ -31,15 +31,14 @@ extern void warn (const char *, ...) ATTRIBUTE_PRINTF_1;\n \n typedef unsigned HOST_WIDEST_INT elf_vma;\n \n-extern void (*byte_put) (unsigned char *, elf_vma, int);\n-extern void byte_put_little_endian (unsigned char *, elf_vma, int);\n-extern void byte_put_big_endian (unsigned char *, elf_vma, int);\n-\n-extern elf_vma (*byte_get) (const unsigned char *, int);\n-extern elf_vma byte_get_signed (const unsigned char *, int);\n-extern elf_vma byte_get_little_endian (const unsigned char *, int);\n-extern elf_vma byte_get_big_endian (const unsigned char *, int);\n-extern void byte_get_64 (const unsigned char *, elf_vma *, elf_vma *);\n+extern void (*byte_put) (unsigned char *, elf_vma, unsigned int);\n+extern void byte_put_little_endian (unsigned char *, elf_vma, unsigned int);\n+extern void byte_put_big_endian (unsigned char *, elf_vma, unsigned int);\n+\n+extern elf_vma (*byte_get) (const unsigned char *, unsigned int);\n+extern elf_vma byte_get_signed (const unsigned char *, unsigned int);\n+extern elf_vma byte_get_little_endian (const unsigned char *, unsigned int);\n+extern elf_vma byte_get_big_endian (const unsigned char *, unsigned int);\n \n #define BYTE_PUT(field, val)\tbyte_put (field, val, sizeof (field))\n #define BYTE_GET(field)\t\tbyte_get (field, sizeof (field))"
    },
    {
      "sha": "329c28880b87fd7132241e7afacb72335187b1c4",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "patch": "@@ -1,3 +1,8 @@\n+2021-05-12  Alan Modra  <amodra@gmail.com>\n+\n+\t* testsuite/gas/elf/dwarf-5-file0.d: Update.\n+\t* testsuite/gas/i386/dwarf5-line-1.d: Update.\n+\n 2021-05-11  Sergey Belyashov  <sergey.belyashov@gmail.com>\n \n \tPR 27823"
    },
    {
      "sha": "973dc5b9ff371da3fb396cf9d6888d803c7f8f93",
      "filename": "gas/testsuite/gas/elf/dwarf-5-file0.d",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/gas/testsuite/gas/elf/dwarf-5-file0.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/gas/testsuite/gas/elf/dwarf-5-file0.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/elf/dwarf-5-file0.d?ref=af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "patch": "@@ -11,8 +11,8 @@\n \n  The File Name Table \\(offset 0x.*, lines 3, columns 3\\):\n   Entry\tDir\tMD5\t\t\t\tName\n-  0\t0 0x00000000000000000000000000000000\t\\(indirect line string, offset: 0x.*\\): master source file\n-  1\t1 0x00000000000000000000000000000000\t\\(indirect line string, offset: 0x.*\\): secondary source file\n+  0\t0 0x0\t\\(indirect line string, offset: 0x.*\\): master source file\n+  1\t1 0x0\t\\(indirect line string, offset: 0x.*\\): secondary source file\n   2\t2 0x95828e8bc4f7404dbf7526fb7bd0f192\t\\(indirect line string, offset: 0x.*\\): foo.c\n #pass\n "
    },
    {
      "sha": "cc90b61fcfddf671898e39a62094aa157bac5d1e",
      "filename": "gas/testsuite/gas/i386/dwarf5-line-1.d",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/gas/testsuite/gas/i386/dwarf5-line-1.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a/gas/testsuite/gas/i386/dwarf5-line-1.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/i386/dwarf5-line-1.d?ref=af2ddf69ab85add3155cf55f65e6e9f3c9bcb29a",
      "patch": "@@ -39,7 +39,7 @@ Raw dump of debug contents of section \\.z?debug_line:\n  The File Name Table \\(offset 0x.*, lines 2, columns 3\\):\n   Entry\tDir\tMD5\t\t\t\tName\n   0\t0 0xbbd69fc03ce253b2dbaab2522dd519ae\t\\(indirect line string, offset: 0x.*\\): core.c\n-  1\t0 0x00000000000000000000000000000000\t\\(indirect line string, offset: 0x.*\\): types.h\n+  1\t0 0x0\t\\(indirect line string, offset: 0x.*\\): types.h\n \n  Line Number Statements:\n   \\[0x.*\\]  Extended opcode 2: set Address to 0x0"
    }
  ]
}