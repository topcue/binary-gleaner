{
  "sha": "9d0faba9f52b898f0be539bc4d6fbd084772259d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWQwZmFiYTlmNTJiODk4ZjBiZTUzOWJjNGQ2ZmJkMDg0NzcyMjU5ZA==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-06-12T23:06:53Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-06-12T23:18:12Z"
    },
    "message": "Introduce generic command options framework\n\nThis commit adds a generic command options framework, that makes it\neasy enough to add '-'-style options to commands in a uniform way,\ninstead of each command implementing option parsing in its own way.\n\nOptions are defined in arrays of option_def objects (for option\ndefinition), and the same options definitions are used for supporting\nTAB completion, and also for generating the relevant help fragment of\nthe \"help\" command.  See the gdb::options::build_help function, which\nreturns a string with the result of replacing %OPTIONS% in a template\nstring with an auto-generated \"help\" string fragment for all the\npassed-in options.\n\nSince most options in GDB are in the form of \"-OPT\", with a single\ndash, this is the format that the framework supports.\n\nI like to think of gdb's \"-OPT\" as the equivalent to getopt's long\noptions format (\"--OPT\"), and gdb's \"/\" as the equivalent to getopt's\nshort options format.  getopt's short options format allows mixing\nseveral one-character options, like \"ls -als\", kind of similar to\ngdb's \"x /FMT\" and \"disassemble /MOD\", etc.  While with gdb's \"-\"\noptions, the option is expected to have a full name, and to be\nabbreviatable.  E.g., \"watch -location\", \"break -function main\", etc.\n\nThis patch only deals with \"-\" options.  The above comment serves more\nto disclose why I don't think we should support mixing several\nunrelated options in a single \"-\" option invocation, like \"thread\napply -qcs\" instead of \"thread apply -q -c -s\".\n\nThe following patches will add uses of the infrastructure to several\nkey commands.  Most notably, \"print\", \"compile print\", \"backtrace\",\n\"frame apply\" and \"thread apply\".  I tried to add options to several\ncommands in order to make sure the framework didn't leave that many\nopen holes open.\n\nOptions use the same type as set commands -- enum var_types.  So\nboolean options are var_boolean, enum options are var_enum, etc.  The\nidea is to share code between settings commands and command options.\nThe \"print\" options will be based on the \"set print\" commands, and\ntheir names will be the same.  Actually, their definitions will be the\nsame too.  There is a function to create \"set/show\" commands from an\narray for option definitions:\n\n /* Install set/show commands for options defined in OPTIONS.  DATA is\n    a pointer to the structure that holds the data associated with the\n    OPTIONS array.  */\n extern void add_setshow_cmds_for_options (command_class cmd_class, void *data,\n\t\t\t\t\t   gdb::array_view<const option_def> options,\n\t\t\t\t\t   struct cmd_list_element **set_list,\n\t\t\t\t\t   struct cmd_list_element **show_list);\n\nThat will be used by several following patches.\n\nOther features:\n\n - You can use the \"--\" delimiter to explicitly indicate end of\n   options.  Several existing commands use this token sequence for\n   this effect already, so this just standardizes it.\n\n - You can shorten option names, as long as unambiguous.  Currently,\n   some commands allow this (e.g., break -function), while others do\n   not (thread apply all -ascending).  As GDB allows abbreviating\n   command names and other things, it feels more GDB-ish to allow\n   abbreviating option names too, to me.\n\n - For boolean options, 0/1 stands for off/on, just like with boolean\n   \"set\" commands.\n\n - For boolean options, \"true\" is implied, just like with boolean \"set\n   commands.\n\nThese are the option types supported, with a few examples:\n\n - boolean options (var_boolean).  The option's argument is optional.\n\n   (gdb) print -pretty on -- *obj\n   (gdb) print -pretty off -- *obj\n   (gdb) print -p -- *obj\n   (gdb) print -p 0 -- *obj\n\n - flag options (like var_boolean, but no option argument (on/off))\n\n   (gdb) thread apply all -s COMMAND\n\n - enum options  (var_enum)\n\n   (gdb) bt -entry-values compact\n   (gdb) bt -e c\n\n - uinteger options (var_uinteger)\n\n   (gdb) print -elements 100 -- *obj\n   (gdb) print -e 100 -- *obj\n   (gdb) print -elements unlimited -- *obj\n   (gdb) print -e u -- *obj\n\n - zuinteger-unlimited options (var_zuinteger_unlimited)\n\n   (gdb) print -max-depth 100 -- obj\n   (gdb) print -max-depth -1 -- obj\n   (gdb) print -max-depth unlimited -- obj\n\nOther var_types could be supported, of course.  These were just the\ntypes that I needed for the commands that I ported over, in the\nfollowing patches.\n\nIt was interesting (and unfortunate) to find that we need at least 3\ndifferent modes to cover the existing commands:\n\n- Commands that require ending options with \"--\" if you specify any\n  option: \"print\" and \"compile print\".\n\n- Commands that do not want to require \"--\", and want to error out if\n  you specify an unknown option (i.e., an unknown argument that starts\n  with '-'): \"compile code\" / \"compile file\".\n\n- Commands that do not want to require \"--\", and want to process\n  unknown options themselves: \"bt\", because of \"bt -COUNT\",\n  \"thread/frame apply\", because \"-\" is a valid command.\n\nThe different behavior is encoded in the process_options_mode enum,\npassed to process_options/complete_options.\n\nFor testing, this patch adds one representative maintenance command\nfor each of the process_options_mode values, that are used by the\ntestsuite to exercise the options framework:\n\n (gdb) maint test-options require-delimiter\n (gdb) maint test-options unknown-is-error\n (gdb) maint test-options unknown-is-operand\n\nand adds another command to help with TAB-completion testing:\n\n (gdb) maint show test-options-completion-result\n\nSee their description at the top of the maint-test-options.c file.\n\nDocs/NEWS are in a patch later in the series.\n\ngdb/ChangeLog:\n2019-06-13  Pedro Alves  <palves@redhat.com>\n\n\t* Makefile.in (SUBDIR_CLI_SRCS): Add cli/cli-option.c.\n\t(COMMON_SFILES): Add maint-test-settings.c.\n\t* cli/cli-decode.c (boolean_enums): New global, factored out from\n\t...\n\t(add_setshow_boolean_cmd): ... here.\n\t* cli/cli-decode.h (boolean_enums): Declare.\n\t* cli/cli-option.c: New file.\n\t* cli/cli-option.h: New file.\n\t* cli/cli-setshow.c (parse_cli_boolean_value(const char **)): New,\n\tfactored out from ...\n\t(parse_cli_boolean_value(const char *)): ... this.\n\t(is_unlimited_literal): Change parameter type to pointer to\n\tpointer.  Adjust and advance ARG pointer.\n\t(parse_cli_var_uinteger, parse_cli_var_zuinteger_unlimited)\n\t(parse_cli_var_enum): New, factored out from ...\n\t(do_set_command): ... this.  Adjust.\n\t* cli/cli-setshow.h (parse_cli_boolean_value)\n\t(parse_cli_var_uinteger, parse_cli_var_zuinteger_unlimited)\n\t(parse_cli_var_enum): Declare.\n\t* cli/cli-utils.c: Include \"cli/cli-option.h\".\n\t(get_ulongest): New.\n\t* cli/cli-utils.h (get_ulongest): Declare.\n\t(check_for_argument): New overloads.\n\t* maint-test-options.c: New file.\n\ngdb/testsuite/ChangeLog:\n2019-06-13  Pedro Alves  <palves@redhat.com>\n\n\t* gdb.base/options.c: New file.\n\t* gdb.base/options.exp: New file.",
    "tree": {
      "sha": "d52104cded53080ec9527ff3ecab1c3e5e34cc46",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d52104cded53080ec9527ff3ecab1c3e5e34cc46"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9d0faba9f52b898f0be539bc4d6fbd084772259d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d0faba9f52b898f0be539bc4d6fbd084772259d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9d0faba9f52b898f0be539bc4d6fbd084772259d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d0faba9f52b898f0be539bc4d6fbd084772259d/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2c722807a752ce468b04fcf6d29857f377beeaf5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c722807a752ce468b04fcf6d29857f377beeaf5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2c722807a752ce468b04fcf6d29857f377beeaf5"
    }
  ],
  "stats": {
    "total": 2526,
    "additions": 2408,
    "deletions": 118
  },
  "files": [
    {
      "sha": "8c9eed454420fd427a38a4804bec388962bc97f6",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -1,3 +1,30 @@\n+2019-06-13  Pedro Alves  <palves@redhat.com>\n+\n+\t* Makefile.in (SUBDIR_CLI_SRCS): Add cli/cli-option.c.\n+\t(COMMON_SFILES): Add maint-test-settings.c.\n+\t* cli/cli-decode.c (boolean_enums): New global, factored out from\n+\t...\n+\t(add_setshow_boolean_cmd): ... here.\n+\t* cli/cli-decode.h (boolean_enums): Declare.\n+\t* cli/cli-option.c: New file.\n+\t* cli/cli-option.h: New file.\n+\t* cli/cli-setshow.c (parse_cli_boolean_value(const char **)): New,\n+\tfactored out from ...\n+\t(parse_cli_boolean_value(const char *)): ... this.\n+\t(is_unlimited_literal): Change parameter type to pointer to\n+\tpointer.  Adjust and advance ARG pointer.\n+\t(parse_cli_var_uinteger, parse_cli_var_zuinteger_unlimited)\n+\t(parse_cli_var_enum): New, factored out from ...\n+\t(do_set_command): ... this.  Adjust.\n+\t* cli/cli-setshow.h (parse_cli_boolean_value)\n+\t(parse_cli_var_uinteger, parse_cli_var_zuinteger_unlimited)\n+\t(parse_cli_var_enum): Declare.\n+\t* cli/cli-utils.c: Include \"cli/cli-option.h\".\n+\t(get_ulongest): New.\n+\t* cli/cli-utils.h (get_ulongest): Declare.\n+\t(check_for_argument): New overloads.\n+\t* maint-test-options.c: New file.\n+\n 2019-06-13  Pedro Alves  <palves@redhat.com>\n \n \t* cli/cli-utils.c (number_or_range_parser::get_number): Do not"
    },
    {
      "sha": "03a5159193a4d7155ae9aca037cb56d23e3e61d9",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -241,6 +241,7 @@ SUBDIR_CLI_SRCS = \\\n \tcli/cli-dump.c \\\n \tcli/cli-interp.c \\\n \tcli/cli-logging.c \\\n+\tcli/cli-option.c \\\n \tcli/cli-script.c \\\n \tcli/cli-setshow.c \\\n \tcli/cli-style.c \\\n@@ -1063,6 +1064,7 @@ COMMON_SFILES = \\\n \tmacrotab.c \\\n \tmain.c \\\n \tmaint.c \\\n+\tmaint-test-options.c \\\n \tmaint-test-settings.c \\\n \tmdebugread.c \\\n \tmem-break.c \\"
    },
    {
      "sha": "d739a0d648ac4b1b3650257e7f61dd8c8e4f3555",
      "filename": "gdb/cli/cli-decode.c",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-decode.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-decode.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.c?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -551,6 +551,7 @@ add_setshow_enum_cmd (const char *name,\n   set_cmd_context (show, context);\n }\n \n+/* See cli-decode.h.  */\n const char * const auto_boolean_enums[] = { \"on\", \"off\", \"auto\", NULL };\n \n /* Add an auto-boolean command named NAME to both the set and show\n@@ -578,6 +579,9 @@ add_setshow_auto_boolean_cmd (const char *name,\n   c->enums = auto_boolean_enums;\n }\n \n+/* See cli-decode.h.  */\n+const char * const boolean_enums[] = { \"on\", \"off\", NULL };\n+\n /* Add element named NAME to both the set and show command LISTs (the\n    list for set/show or some sublist thereof).  CLASS is as in\n    add_cmd.  VAR is address of the variable which will contain the\n@@ -591,7 +595,6 @@ add_setshow_boolean_cmd (const char *name, enum command_class theclass, int *var\n \t\t\t struct cmd_list_element **set_list,\n \t\t\t struct cmd_list_element **show_list)\n {\n-  static const char *boolean_enums[] = { \"on\", \"off\", NULL };\n   struct cmd_list_element *c;\n \n   add_setshow_cmd_full (name, theclass, var_boolean, var,"
    },
    {
      "sha": "05280d9d22024c152e0d9f1d66fd3cd795fab46b",
      "filename": "gdb/cli/cli-decode.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-decode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-decode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.h?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -261,6 +261,10 @@ extern void not_just_help_class_command (const char *arg, int from_tty);\n \n extern void print_doc_line (struct ui_file *, const char *);\n \n+/* The enums of boolean commands.  */\n+extern const char * const boolean_enums[];\n+\n+/* The enums of auto-boolean commands.  */\n extern const char * const auto_boolean_enums[];\n \n /* Verify whether a given cmd_list_element is a user-defined command."
    },
    {
      "sha": "9a53ec0592d9a3729adb5b49a9c563e0de9559f5",
      "filename": "gdb/cli/cli-option.c",
      "status": "added",
      "additions": 724,
      "deletions": 0,
      "changes": 724,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-option.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-option.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-option.c?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -0,0 +1,724 @@\n+/* CLI options framework, for GDB.\n+\n+   Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"cli/cli-option.h\"\n+#include \"cli/cli-decode.h\"\n+#include \"cli/cli-utils.h\"\n+#include \"cli/cli-setshow.h\"\n+#include \"command.h\"\n+#include <vector>\n+\n+namespace gdb {\n+namespace option {\n+\n+/* An option's value.  Which field is active depends on the option's\n+   type.  */\n+union option_value\n+{\n+  /* For var_boolean options.  */\n+  bool boolean;\n+\n+  /* For var_uinteger options.  */\n+  unsigned int uinteger;\n+\n+  /* For var_zuinteger_unlimited options.  */\n+  int integer;\n+\n+  /* For var_enum options.  */\n+  const char *enumeration;\n+};\n+\n+/* Holds an options definition and its value.  */\n+struct option_def_and_value\n+{\n+  /* The option definition.  */\n+  const option_def &option;\n+\n+  /* A context.  */\n+  void *ctx;\n+\n+  /* The option's value, if any.  */\n+  gdb::optional<option_value> value;\n+};\n+\n+/* Info passed around when handling completion.  */\n+struct parse_option_completion_info\n+{\n+  /* The completion word.  */\n+  const char *word;\n+\n+  /* The tracker.  */\n+  completion_tracker &tracker;\n+};\n+\n+/* If ARGS starts with \"-\", look for a \"--\" delimiter.  If one is\n+   found, then interpret everything up until the \"--\" as command line\n+   options.  Otherwise, interpret unknown input as the beginning of\n+   the command's operands.  */\n+\n+static const char *\n+find_end_options_delimiter (const char *args)\n+{\n+  if (args[0] == '-')\n+    {\n+      const char *p = args;\n+\n+      p = skip_spaces (p);\n+      while (*p)\n+\t{\n+\t  if (check_for_argument (&p, \"--\"))\n+\t    return p;\n+\t  else\n+\t    p = skip_to_space (p);\n+\t  p = skip_spaces (p);\n+\t}\n+    }\n+\n+  return nullptr;\n+}\n+\n+/* Complete TEXT/WORD on all options in OPTIONS_GROUP.  */\n+\n+static void\n+complete_on_options (gdb::array_view<const option_def_group> options_group,\n+\t\t     completion_tracker &tracker,\n+\t\t     const char *text, const char *word)\n+{\n+  size_t textlen = strlen (text);\n+  for (const auto &grp : options_group)\n+    for (const auto &opt : grp.options)\n+      if (strncmp (opt.name, text, textlen) == 0)\n+\t{\n+\t  tracker.add_completion\n+\t    (make_completion_match_str (opt.name, text, word));\n+\t}\n+}\n+\n+/* See cli-option.h.  */\n+\n+void\n+complete_on_all_options (completion_tracker &tracker,\n+\t\t\t gdb::array_view<const option_def_group> options_group)\n+{\n+  static const char opt[] = \"-\";\n+  complete_on_options (options_group, tracker, opt + 1, opt);\n+}\n+\n+/* Parse ARGS, guided by OPTIONS_GROUP.  HAVE_DELIMITER is true if the\n+   whole ARGS line included the \"--\" options-terminator delimiter.  */\n+\n+static gdb::optional<option_def_and_value>\n+parse_option (gdb::array_view<const option_def_group> options_group,\n+\t      process_options_mode mode,\n+\t      bool have_delimiter,\n+\t      const char **args,\n+\t      parse_option_completion_info *completion = nullptr)\n+{\n+  if (*args == nullptr)\n+    return {};\n+  else if (**args != '-')\n+    {\n+      if (have_delimiter)\n+\terror (_(\"Unrecognized option at: %s\"), *args);\n+      return {};\n+    }\n+  else if (check_for_argument (args, \"--\"))\n+    return {};\n+\n+  /* Skip the initial '-'.  */\n+  const char *arg = *args + 1;\n+\n+  const char *after = skip_to_space (arg);\n+  size_t len = after - arg;\n+  const option_def *match = nullptr;\n+  void *match_ctx = nullptr;\n+\n+  for (const auto &grp : options_group)\n+    {\n+      for (const auto &o : grp.options)\n+\t{\n+\t  if (strncmp (o.name, arg, len) == 0)\n+\t    {\n+\t      if (match != nullptr)\n+\t\t{\n+\t\t  if (completion != nullptr && arg[len] == '\\0')\n+\t\t    {\n+\t\t      complete_on_options (options_group,\n+\t\t\t\t\t   completion->tracker,\n+\t\t\t\t\t   arg, completion->word);\n+\t\t      return {};\n+\t\t    }\n+\n+\t\t  error (_(\"Ambiguous option at: -%s\"), arg);\n+\t\t}\n+\n+\t      match = &o;\n+\t      match_ctx = grp.ctx;\n+\n+\t      if ((isspace (arg[len]) || arg[len] == '\\0')\n+\t\t  && strlen (o.name) == len)\n+\t\tbreak; /* Exact match.  */\n+\t    }\n+\t}\n+    }\n+\n+  if (match == nullptr)\n+    {\n+      if (have_delimiter || mode != PROCESS_OPTIONS_UNKNOWN_IS_OPERAND)\n+\terror (_(\"Unrecognized option at: %s\"), *args);\n+\n+      return {};\n+    }\n+\n+  if (completion != nullptr && arg[len] == '\\0')\n+    {\n+      complete_on_options (options_group, completion->tracker,\n+\t\t\t   arg, completion->word);\n+      return {};\n+    }\n+\n+  *args += 1 + len;\n+  *args = skip_spaces (*args);\n+  if (completion != nullptr)\n+    completion->word = *args;\n+\n+  switch (match->type)\n+    {\n+    case var_boolean:\n+      {\n+\tif (!match->have_argument)\n+\t  {\n+\t    option_value val;\n+\t    val.boolean = true;\n+\t    return option_def_and_value {*match, match_ctx, val};\n+\t  }\n+\n+\tconst char *val_str = *args;\n+\tint res;\n+\n+\tif (**args == '\\0' && completion != nullptr)\n+\t  {\n+\t    /* Complete on both \"on/off\" and more options.  */\n+\n+\t    if (mode == PROCESS_OPTIONS_REQUIRE_DELIMITER)\n+\t      {\n+\t\tcomplete_on_enum (completion->tracker,\n+\t\t\t\t  boolean_enums, val_str, val_str);\n+\t\tcomplete_on_all_options (completion->tracker, options_group);\n+\t      }\n+\t    return option_def_and_value {*match, match_ctx};\n+\t  }\n+\telse if (**args == '-')\n+\t  {\n+\t    /* Treat:\n+\t\t \"cmd -boolean-option -another-opt...\"\n+\t       as:\n+\t\t \"cmd -boolean-option on -another-opt...\"\n+\t     */\n+\t    res = 1;\n+\t  }\n+\telse if (**args == '\\0')\n+\t  {\n+\t    /* Treat:\n+\t\t (1) \"cmd -boolean-option \"\n+\t       as:\n+\t\t (1) \"cmd -boolean-option on\"\n+\t     */\n+\t    res = 1;\n+\t  }\n+\telse\n+\t  {\n+\t    res = parse_cli_boolean_value (args);\n+\t    if (res < 0)\n+\t      {\n+\t\tconst char *end = skip_to_space (*args);\n+\t\tif (completion != nullptr)\n+\t\t  {\n+\t\t    if (*end == '\\0')\n+\t\t      {\n+\t\t\tcomplete_on_enum (completion->tracker,\n+\t\t\t\t\t  boolean_enums, val_str, val_str);\n+\t\t\treturn option_def_and_value {*match, match_ctx};\n+\t\t      }\n+\t\t  }\n+\n+\t\tif (have_delimiter)\n+\t\t  error (_(\"Value given for `-%s' is not a boolean: %.*s\"),\n+\t\t\t match->name, (int) (end - val_str), val_str);\n+\t\t/* The user didn't separate options from operands\n+\t\t   using \"--\", so treat this unrecognized value as the\n+\t\t   start of the operands.  This makes \"frame apply all\n+\t\t   -past-main CMD\" work.  */\n+\t\treturn option_def_and_value {*match, match_ctx};\n+\t      }\n+\t    else if (completion != nullptr && **args == '\\0')\n+\t      {\n+\t\t/* While \"cmd -boolean [TAB]\" only offers \"on\" and\n+\t\t   \"off\", the boolean option actually accepts \"1\",\n+\t\t   \"yes\", etc. as boolean values.  We complete on all\n+\t\t   of those instead of BOOLEAN_ENUMS here to make\n+\t\t   these work:\n+\n+\t\t    \"p -object 1[TAB]\" -> \"p -object 1 \"\n+\t\t    \"p -object ye[TAB]\" -> \"p -object yes \"\n+\n+\t\t   Etc.  Note that it's important that the space is\n+\t\t   auto-appended.  Otherwise, if we only completed on\n+\t\t   on/off here, then it might look to the user like\n+\t\t   \"1\" isn't valid, like:\n+\t\t   \"p -object 1[TAB]\" -> \"p -object 1\" (i.e., nothing happens).\n+\t\t*/\n+\t\tstatic const char *const all_boolean_enums[] = {\n+\t\t  \"on\", \"off\",\n+\t\t  \"yes\", \"no\",\n+\t\t  \"enable\", \"disable\",\n+\t\t  \"0\", \"1\",\n+\t\t  nullptr,\n+\t\t};\n+\t\tcomplete_on_enum (completion->tracker, all_boolean_enums,\n+\t\t\t\t  val_str, val_str);\n+\t\treturn {};\n+\t      }\n+\t  }\n+\n+\toption_value val;\n+\tval.boolean = res;\n+\treturn option_def_and_value {*match, match_ctx, val};\n+      }\n+    case var_uinteger:\n+    case var_zuinteger_unlimited:\n+      {\n+\tif (completion != nullptr)\n+\t  {\n+\t    if (**args == '\\0')\n+\t      {\n+\t\t/* Convenience to let the user know what the option\n+\t\t   can accept.  Note there's no common prefix between\n+\t\t   the strings on purpose, so that readline doesn't do\n+\t\t   a partial match.  */\n+\t\tcompletion->tracker.add_completion\n+\t\t  (make_unique_xstrdup (\"NUMBER\"));\n+\t\tcompletion->tracker.add_completion\n+\t\t  (make_unique_xstrdup (\"unlimited\"));\n+\t\treturn {};\n+\t      }\n+\t    else if (startswith (\"unlimited\", *args))\n+\t      {\n+\t\tcompletion->tracker.add_completion\n+\t\t  (make_unique_xstrdup (\"unlimited\"));\n+\t\treturn {};\n+\t      }\n+\t  }\n+\n+\tif (match->type == var_zuinteger_unlimited)\n+\t  {\n+\t    option_value val;\n+\t    val.integer = parse_cli_var_zuinteger_unlimited (args, false);\n+\t    return option_def_and_value {*match, match_ctx, val};\n+\t  }\n+\telse\n+\t  {\n+\t    option_value val;\n+\t    val.uinteger = parse_cli_var_uinteger (match->type, args, false);\n+\t    return option_def_and_value {*match, match_ctx, val};\n+\t  }\n+      }\n+    case var_enum:\n+      {\n+\tif (completion != nullptr)\n+\t  {\n+\t    const char *after_arg = skip_to_space (*args);\n+\t    if (*after_arg == '\\0')\n+\t      {\n+\t\tcomplete_on_enum (completion->tracker,\n+\t\t\t\t  match->enums, *args, *args);\n+\t\t*args = after_arg;\n+\n+\t\toption_value val;\n+\t\tval.enumeration = nullptr;\n+\t\treturn option_def_and_value {*match, match_ctx, val};\n+\t      }\n+\t  }\n+\n+\tif (check_for_argument (args, \"--\"))\n+\t  {\n+\t    /* Treat e.g., \"backtrace -entry-values --\" as if there\n+\t       was no argument after \"-entry-values\".  This makes\n+\t       parse_cli_var_enum throw an error with a suggestion of\n+\t       what are the valid options.  */\n+\t    args = nullptr;\n+\t  }\n+\n+\toption_value val;\n+\tval.enumeration = parse_cli_var_enum (args, match->enums);\n+\treturn option_def_and_value {*match, match_ctx, val};\n+      }\n+\n+    default:\n+      /* Not yet.  */\n+      gdb_assert_not_reached (_(\"option type not supported\"));\n+    }\n+\n+  return {};\n+}\n+\n+/* See cli-option.h.  */\n+\n+bool\n+complete_options (completion_tracker &tracker,\n+\t\t  const char **args,\n+\t\t  process_options_mode mode,\n+\t\t  gdb::array_view<const option_def_group> options_group)\n+{\n+  const char *text = *args;\n+\n+  tracker.set_use_custom_word_point (true);\n+\n+  const char *delimiter = find_end_options_delimiter (text);\n+  bool have_delimiter = delimiter != nullptr;\n+\n+  if (text[0] == '-' && (!have_delimiter || *delimiter == '\\0'))\n+    {\n+      parse_option_completion_info completion_info {nullptr, tracker};\n+\n+      while (1)\n+\t{\n+\t  *args = skip_spaces (*args);\n+\t  completion_info.word = *args;\n+\n+\t  if (strcmp (*args, \"-\") == 0)\n+\t    {\n+\t      complete_on_options (options_group, tracker, *args + 1,\n+\t\t\t\t   completion_info.word);\n+\t    }\n+\t  else if (strcmp (*args, \"--\") == 0)\n+\t    {\n+\t      tracker.add_completion (make_unique_xstrdup (*args));\n+\t    }\n+\t  else if (**args == '-')\n+\t    {\n+\t      gdb::optional<option_def_and_value> ov\n+\t\t= parse_option (options_group, mode, have_delimiter,\n+\t\t\t\targs, &completion_info);\n+\t      if (!ov && !tracker.have_completions ())\n+\t\t{\n+\t\t  tracker.advance_custom_word_point_by (*args - text);\n+\t\t  return mode == PROCESS_OPTIONS_REQUIRE_DELIMITER;\n+\t\t}\n+\n+\t      if (ov\n+\t\t  && ov->option.type == var_boolean\n+\t\t  && !ov->value.has_value ())\n+\t\t{\n+\t\t  /* Looked like a boolean option, but we failed to\n+\t\t     parse the value.  If this command requires a\n+\t\t     delimiter, this value can't be the start of the\n+\t\t     operands, so return true.  Otherwise, if the\n+\t\t     command doesn't require a delimiter return false\n+\t\t     so that the caller tries to complete on the\n+\t\t     operand.  */\n+\t\t  tracker.advance_custom_word_point_by (*args - text);\n+\t\t  return mode == PROCESS_OPTIONS_REQUIRE_DELIMITER;\n+\t\t}\n+\n+\t      /* If we parsed an option with an argument, and reached\n+\t\t the end of the input string with no trailing space,\n+\t\t return true, so that our callers don't try to\n+\t\t complete anything by themselves.  E.g., this makes it\n+\t\t so that with:\n+\n+\t\t  (gdb) frame apply all -limit 10[TAB]\n+\n+\t\t we don't try to complete on command names.  */\n+\t      if (ov\n+\t\t  && !tracker.have_completions ()\n+\t\t  && **args == '\\0'\n+\t\t  && *args > text && !isspace ((*args)[-1]))\n+\t\t{\n+\t\t  tracker.advance_custom_word_point_by\n+\t\t    (*args - text);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      tracker.advance_custom_word_point_by\n+\t\t(completion_info.word - text);\n+\n+\t      /* If the command requires a delimiter, but we haven't\n+\t\t seen one, then return true, so that the caller\n+\t\t doesn't try to complete on whatever follows options,\n+\t\t which for these commands should only be done if\n+\t\t there's a delimiter.  */\n+\t      if (mode == PROCESS_OPTIONS_REQUIRE_DELIMITER\n+\t\t  && !have_delimiter)\n+\t\t{\n+\t\t  /* If we reached the end of the input string, then\n+\t\t     offer all options, since that's all the user can\n+\t\t     type (plus \"--\").  */\n+\t\t  if (completion_info.word[0] == '\\0')\n+\t\t    complete_on_all_options (tracker, options_group);\n+\t\t  return true;\n+\t\t}\n+\t      else\n+\t\treturn false;\n+\t    }\n+\n+\t  if (tracker.have_completions ())\n+\t    {\n+\t      tracker.advance_custom_word_point_by\n+\t\t(completion_info.word - text);\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  else if (delimiter != nullptr)\n+    {\n+      tracker.advance_custom_word_point_by (delimiter - text);\n+      *args = delimiter;\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+/* See cli-option.h.  */\n+\n+bool\n+process_options (const char **args,\n+\t\t process_options_mode mode,\n+\t\t gdb::array_view<const option_def_group> options_group)\n+{\n+  if (*args == nullptr)\n+    return false;\n+\n+  /* If ARGS starts with \"-\", look for a \"--\" sequence.  If one is\n+     found, then interpret everything up until the \"--\" as\n+     'gdb::option'-style command line options.  Otherwise, interpret\n+     ARGS as possibly the command's operands.  */\n+  bool have_delimiter = find_end_options_delimiter (*args) != nullptr;\n+\n+  if (mode == PROCESS_OPTIONS_REQUIRE_DELIMITER && !have_delimiter)\n+    return false;\n+\n+  bool processed_any = false;\n+\n+  while (1)\n+    {\n+      *args = skip_spaces (*args);\n+\n+      auto ov = parse_option (options_group, mode, have_delimiter, args);\n+      if (!ov)\n+\t{\n+\t  if (processed_any)\n+\t    return true;\n+\t  return false;\n+\t}\n+\n+      processed_any = true;\n+\n+      switch (ov->option.type)\n+\t{\n+\tcase var_boolean:\n+\t  {\n+\t    bool value = ov->value.has_value () ? ov->value->boolean : true;\n+\t    *ov->option.var_address.boolean (ov->option, ov->ctx) = value;\n+\t  }\n+\t  break;\n+\tcase var_uinteger:\n+\t  *ov->option.var_address.uinteger (ov->option, ov->ctx)\n+\t    = ov->value->uinteger;\n+\t  break;\n+\tcase var_zuinteger_unlimited:\n+\t  *ov->option.var_address.integer (ov->option, ov->ctx)\n+\t    = ov->value->integer;\n+\t  break;\n+\tcase var_enum:\n+\t  *ov->option.var_address.enumeration (ov->option, ov->ctx)\n+\t    = ov->value->enumeration;\n+\t  break;\n+\tdefault:\n+\t  gdb_assert_not_reached (\"unhandled option type\");\n+\t}\n+    }\n+}\n+\n+/* Helper for build_help.  Return a fragment of a help string showing\n+   OPT's possible values.  Returns NULL if OPT doesn't take an\n+   argument.  */\n+\n+static const char *\n+get_val_type_str (const option_def &opt, std::string &buffer)\n+{\n+  if (!opt.have_argument)\n+    return nullptr;\n+\n+  switch (opt.type)\n+    {\n+    case var_boolean:\n+      return \"[on|off]\";\n+    case var_uinteger:\n+    case var_zuinteger_unlimited:\n+      return \"NUMBER|unlimited\";\n+    case var_enum:\n+      {\n+\tbuffer = \"\";\n+\tfor (size_t i = 0; opt.enums[i] != nullptr; i++)\n+\t  {\n+\t    if (i != 0)\n+\t      buffer += \"|\";\n+\t    buffer += opt.enums[i];\n+\t  }\n+\treturn buffer.c_str ();\n+      }\n+    default:\n+      return nullptr;\n+    }\n+}\n+\n+/* Helper for build_help.  Appends an indented version of DOC into\n+   HELP.  */\n+\n+static void\n+append_indented_doc (const char *doc, std::string &help)\n+{\n+  const char *p = doc;\n+  const char *n = strchr (p, '\\n');\n+\n+  while (n != nullptr)\n+    {\n+      help += \"    \";\n+      help.append (p, n - p + 1);\n+      p = n + 1;\n+      n = strchr (p, '\\n');\n+    }\n+  help += \"    \";\n+  help += p;\n+  help += '\\n';\n+}\n+\n+/* Fill HELP with an auto-generated \"help\" string fragment for\n+   OPTIONS.  */\n+\n+static void\n+build_help_option (gdb::array_view<const option_def> options,\n+\t\t   std::string &help)\n+{\n+  std::string buffer;\n+\n+  for (const auto &o : options)\n+    {\n+      if (o.set_doc == nullptr)\n+\tcontinue;\n+\n+      help += \"  -\";\n+      help += o.name;\n+\n+      const char *val_type_str = get_val_type_str (o, buffer);\n+      if (val_type_str != nullptr)\n+\t{\n+\t  help += ' ';\n+\t  help += val_type_str;\n+\t}\n+      help += \"\\n\";\n+      append_indented_doc (o.set_doc, help);\n+      if (o.help_doc != nullptr)\n+\tappend_indented_doc (o.help_doc, help);\n+      help += '\\n';\n+    }\n+}\n+\n+/* See cli-option.h.  */\n+\n+std::string\n+build_help (const char *help_tmpl,\n+\t    gdb::array_view<const option_def_group> options_group)\n+{\n+  std::string help_str;\n+\n+  const char *p = strstr (help_tmpl, \"%OPTIONS%\");\n+  help_str.assign (help_tmpl, p);\n+\n+  for (const auto &grp : options_group)\n+    for (const auto &opt : grp.options)\n+      build_help_option (opt, help_str);\n+\n+  p += strlen (\"%OPTIONS%\");\n+  help_str.append (p);\n+\n+  return help_str;\n+}\n+\n+/* See cli-option.h.  */\n+\n+void\n+add_setshow_cmds_for_options (command_class cmd_class,\n+\t\t\t      void *data,\n+\t\t\t      gdb::array_view<const option_def> options,\n+\t\t\t      struct cmd_list_element **set_list,\n+\t\t\t      struct cmd_list_element **show_list)\n+{\n+  for (const auto &option : options)\n+    {\n+      if (option.type == var_boolean)\n+\t{\n+\t  add_setshow_boolean_cmd (option.name, cmd_class,\n+\t\t\t\t   option.var_address.boolean (option, data),\n+\t\t\t\t   option.set_doc, option.show_doc,\n+\t\t\t\t   option.help_doc,\n+\t\t\t\t   nullptr, option.show_cmd_cb,\n+\t\t\t\t   set_list, show_list);\n+\t}\n+      else if (option.type == var_uinteger)\n+\t{\n+\t  add_setshow_uinteger_cmd (option.name, cmd_class,\n+\t\t\t\t    option.var_address.uinteger (option, data),\n+\t\t\t\t    option.set_doc, option.show_doc,\n+\t\t\t\t    option.help_doc,\n+\t\t\t\t    nullptr, option.show_cmd_cb,\n+\t\t\t\t    set_list, show_list);\n+\t}\n+      else if (option.type == var_zuinteger_unlimited)\n+\t{\n+\t  add_setshow_zuinteger_unlimited_cmd\n+\t    (option.name, cmd_class,\n+\t     option.var_address.integer (option, data),\n+\t     option.set_doc, option.show_doc,\n+\t     option.help_doc,\n+\t     nullptr, option.show_cmd_cb,\n+\t     set_list, show_list);\n+\t}\n+      else if (option.type == var_enum)\n+\t{\n+\t  add_setshow_enum_cmd (option.name, cmd_class,\n+\t\t\t\toption.enums,\n+\t\t\t\toption.var_address.enumeration (option, data),\n+\t\t\t\toption.set_doc, option.show_doc,\n+\t\t\t\toption.help_doc,\n+\t\t\t\tnullptr, option.show_cmd_cb,\n+\t\t\t\tset_list, show_list);\n+\t}\n+      else\n+\tgdb_assert_not_reached (_(\"option type not handled\"));\n+    }\n+}\n+\n+} /* namespace option */\n+} /* namespace gdb */"
    },
    {
      "sha": "1bfbfce1ce512991f85f6afaa13274a99fa57df5",
      "filename": "gdb/cli/cli-option.h",
      "status": "added",
      "additions": 335,
      "deletions": 0,
      "changes": 335,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-option.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-option.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-option.h?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -0,0 +1,335 @@\n+/* CLI options framework, for GDB.\n+\n+   Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef CLI_OPTION_H\n+#define CLI_OPTION_H 1\n+\n+#include \"common/gdb_optional.h\"\n+#include \"common/array-view.h\"\n+#include \"completer.h\"\n+#include <string>\n+#include \"command.h\"\n+\n+namespace gdb {\n+namespace option {\n+\n+/* A type-erased option definition.  The actual type of the option is\n+   stored in the TYPE field.  Client code cannot define objects of\n+   this type directly (the ctor is protected).  Instead, one of the\n+   wrapper types below that extends this (boolean_option_def,\n+   flag_option_def, uinteger_option_def, etc.) should be defined.  */\n+struct option_def\n+{\n+  /* The ctor is protected because you're supposed to construct using\n+     one of bool_option_def, etc. below.  */\n+protected:\n+  typedef void *(erased_get_var_address_ftype) ();\n+\n+  /* Construct an option.  NAME_ is the option's name.  VAR_TYPE_\n+     defines the option's type.  ERASED_GET_VAR_ADDRESS_ is a pointer\n+     to a function that returns the option's control variable.\n+     SHOW_CMD_CB_ is a pointer to callback for the \"show\" command that\n+     is installed for this option.  SET_DOC_, SHOW_DOC_, HELP_DOC_ are\n+     used to create the option's \"set/show\" commands.  */\n+  constexpr option_def (const char *name_,\n+\t\t\tvar_types var_type_,\n+\t\t\terased_get_var_address_ftype *erased_get_var_address_,\n+\t\t\tshow_value_ftype *show_cmd_cb_,\n+\t\t\tconst char *set_doc_,\n+\t\t\tconst char *show_doc_,\n+\t\t\tconst char *help_doc_)\n+    : name (name_), type (var_type_),\n+      erased_get_var_address (erased_get_var_address_),\n+      var_address {},\n+      show_cmd_cb (show_cmd_cb_),\n+      set_doc (set_doc_), show_doc (show_doc_), help_doc (help_doc_)\n+  {}\n+\n+public:\n+  /* The option's name.  */\n+  const char *name;\n+\n+  /* The option's type.  */\n+  var_types type;\n+\n+  /* A function that gets the controlling variable's address, type\n+     erased.  */\n+  erased_get_var_address_ftype *erased_get_var_address;\n+\n+  /* Get the controlling variable's address.  Each type of variable\n+     uses a different union member.  We do this instead of having a\n+     single hook that return a \"void *\", for better type safety.  This\n+     way, actual instances of concrete option_def types\n+     (boolean_option_def, etc.) fail to compile if you pass in a\n+     function with incorrect return type.  CTX here is the aggregate\n+     object that groups the option variables from which the callback\n+     returns the address of some member.  */\n+  union\n+    {\n+      int *(*boolean) (const option_def &, void *ctx);\n+      unsigned int *(*uinteger) (const option_def &, void *ctx);\n+      int *(*integer) (const option_def &, void *ctx);\n+      const char **(*enumeration) (const option_def &, void *ctx);\n+    }\n+  var_address;\n+\n+  /* Pointer to null terminated list of enumerated values (like argv).\n+     Only used by var_enum options.  */\n+  const char *const *enums = nullptr;\n+\n+  /* True if the option takes an argument.  */\n+  bool have_argument = true;\n+\n+  /* The \"show\" callback to use in the associated \"show\" command.\n+     E.g., \"show print elements\".  */\n+  show_value_ftype *show_cmd_cb;\n+\n+  /* The set/show/help strings.  These are shown in both the help of\n+     commands that use the option group this option belongs to (e.g.,\n+     \"help print\"), and in the associated commands (e.g., \"set/show\n+     print elements\", \"help set print elements\").  */\n+  const char *set_doc;\n+  const char *show_doc;\n+  const char *help_doc;\n+\n+  /* Convenience method that returns THIS as an option_def.  Useful\n+     when you're putting an option_def subclass in an option_def\n+     array_view.  */\n+  const option_def &def () const\n+  {\n+    return *this;\n+  }\n+};\n+\n+namespace detail\n+{\n+\n+/* Get the address of the option's value, cast to the right type.\n+   RetType is the restored type of the variable, and Context is the\n+   restored type of the context pointer.  */\n+template<typename RetType, typename Context>\n+static inline RetType *\n+get_var_address (const option_def &option, void *ctx)\n+{\n+  using unerased_ftype = RetType *(Context *);\n+  unerased_ftype *fun = (unerased_ftype *) option.erased_get_var_address;\n+  return fun ((Context *) ctx);\n+}\n+\n+/* Convenience identity helper that just returns SELF.  */\n+\n+template<typename T>\n+static T *\n+return_self (T *self)\n+{\n+  return self;\n+}\n+\n+} /* namespace detail */\n+\n+/* Follows the definitions of the option types that client code should\n+   define.  Note that objects of these types are placed in option_def\n+   arrays, by design, so they must not have data fields of their\n+   own.  */\n+\n+/* A var_boolean command line option.  */\n+\n+template<typename Context>\n+struct boolean_option_def : option_def\n+{\n+  boolean_option_def (const char *long_option_,\n+\t\t      int *(*get_var_address_cb_) (Context *),\n+\t\t      show_value_ftype *show_cmd_cb_,\n+\t\t      const char *set_doc_,\n+\t\t      const char *show_doc_ = nullptr,\n+\t\t      const char *help_doc_ = nullptr)\n+    : option_def (long_option_, var_boolean,\n+\t\t  (erased_get_var_address_ftype *) get_var_address_cb_,\n+\t\t  show_cmd_cb_,\n+\t\t  set_doc_, show_doc_, help_doc_)\n+  {\n+    var_address.boolean = detail::get_var_address<int, Context>;\n+  }\n+};\n+\n+/* A flag command line option.  This is a var_boolean option under the\n+   hood, but unlike boolean options, flag options don't take an on/off\n+   argument.  */\n+\n+template<typename Context = int>\n+struct flag_option_def : boolean_option_def<Context>\n+{\n+  flag_option_def (const char *long_option_,\n+\t\t     int *(*var_address_cb_) (Context *),\n+\t\t     const char *set_doc_,\n+\t\t     const char *help_doc_ = nullptr)\n+    : boolean_option_def<Context> (long_option_,\n+\t\t\t\t   var_address_cb_,\n+\t\t\t\t   NULL,\n+\t\t\t\t   set_doc_, NULL, help_doc_)\n+  {\n+    this->have_argument = false;\n+  }\n+\n+  flag_option_def (const char *long_option_,\n+\t\t     const char *set_doc_,\n+\t\t     const char *help_doc_ = nullptr)\n+    : boolean_option_def<Context> (long_option_,\n+\t\t\t\t   gdb::option::detail::return_self,\n+\t\t\t\t   NULL,\n+\t\t\t\t   set_doc_, nullptr, help_doc_)\n+  {\n+    this->have_argument = false;\n+  }\n+};\n+\n+/* A var_uinteger command line option.  */\n+\n+template<typename Context>\n+struct uinteger_option_def : option_def\n+{\n+  uinteger_option_def (const char *long_option_,\n+\t\t       unsigned int *(*get_var_address_cb_) (Context *),\n+\t\t       show_value_ftype *show_cmd_cb_,\n+\t\t       const char *set_doc_,\n+\t\t       const char *show_doc_ = nullptr,\n+\t\t       const char *help_doc_ = nullptr)\n+    : option_def (long_option_, var_uinteger,\n+\t\t  (erased_get_var_address_ftype *) get_var_address_cb_,\n+\t\t  show_cmd_cb_,\n+\t\t  set_doc_, show_doc_, help_doc_)\n+  {\n+    var_address.uinteger = detail::get_var_address<unsigned int, Context>;\n+  }\n+};\n+\n+/* A var_zuinteger_unlimited command line option.  */\n+\n+template<typename Context>\n+struct zuinteger_unlimited_option_def : option_def\n+{\n+  zuinteger_unlimited_option_def (const char *long_option_,\n+\t\t\t\t  int *(*get_var_address_cb_) (Context *),\n+\t\t\t\t  show_value_ftype *show_cmd_cb_,\n+\t\t\t\t  const char *set_doc_,\n+\t\t\t\t  const char *show_doc_ = nullptr,\n+\t\t\t\t  const char *help_doc_ = nullptr)\n+    : option_def (long_option_, var_zuinteger_unlimited,\n+\t\t  (erased_get_var_address_ftype *) get_var_address_cb_,\n+\t\t  show_cmd_cb_,\n+\t\t  set_doc_, show_doc_, help_doc_)\n+  {\n+    var_address.integer = detail::get_var_address<int, Context>;\n+  }\n+};\n+\n+/* An var_enum command line option.  */\n+\n+template<typename Context>\n+struct enum_option_def : option_def\n+{\n+  enum_option_def (const char *long_option_,\n+\t\t   const char *const *enumlist,\n+\t\t   const char **(*get_var_address_cb_) (Context *),\n+\t\t   show_value_ftype *show_cmd_cb_,\n+\t\t   const char *set_doc_,\n+\t\t   const char *show_doc_ = nullptr,\n+\t\t   const char *help_doc_ = nullptr)\n+    : option_def (long_option_, var_enum,\n+\t\t  (erased_get_var_address_ftype *) get_var_address_cb_,\n+\t\t  show_cmd_cb_,\n+\t\t  set_doc_, show_doc_, help_doc_)\n+  {\n+    var_address.enumeration = detail::get_var_address<const char *, Context>;\n+    this->enums = enumlist;\n+  }\n+};\n+\n+/* A group of options that all share the same context pointer to pass\n+   to the options' get-current-value callbacks.  */\n+struct option_def_group\n+{\n+  /* The list of options.  */\n+  gdb::array_view<const option_def> options;\n+\n+  /* The context pointer to pass to the options' get-current-value\n+     callbacks.  */\n+  void *ctx;\n+};\n+\n+/* Modes of operation for process_options.  */\n+enum process_options_mode\n+{\n+  /* In this mode, options are only processed if we find a \"--\"\n+     delimiter.  Throws an error if unknown options are found.  */\n+  PROCESS_OPTIONS_REQUIRE_DELIMITER,\n+\n+  /* In this mode, a \"--\" delimiter is not required.  Throws an error\n+     if unknown options are found, regardless of whether a delimiter\n+     is present.  */\n+  PROCESS_OPTIONS_UNKNOWN_IS_ERROR,\n+\n+  /* In this mode, a \"--\" delimiter is not required.  If an unknown\n+     option is found, assume it is the command's argument/operand.  */\n+  PROCESS_OPTIONS_UNKNOWN_IS_OPERAND,\n+};\n+\n+/* Process ARGS, using OPTIONS_GROUP as valid options.  Returns true\n+   if the string has been fully parsed and there are no operands to\n+   handle by the caller.  Return false if options were parsed, and\n+   *ARGS now points at the first operand.  */\n+extern bool process_options\n+  (const char **args,\n+   process_options_mode mode,\n+   gdb::array_view<const option_def_group> options_group);\n+\n+/* Complete ARGS on options listed by OPTIONS_GROUP.  Returns true if\n+   the string has been fully parsed and there are no operands to\n+   handle by the caller.  Return false if options were parsed, and\n+   *ARGS now points at the first operand.  */\n+extern bool complete_options\n+  (completion_tracker &tracker,\n+   const char **args,\n+   process_options_mode mode,\n+   gdb::array_view<const option_def_group> options_group);\n+\n+/* Complete on all options listed by OPTIONS_GROUP.  */\n+extern void\n+  complete_on_all_options (completion_tracker &tracker,\n+\t\t\t   gdb::array_view<const option_def_group> options_group);\n+\n+/* Return a string with the result of replacing %OPTIONS% in HELP_TMLP\n+   with an auto-generated \"help\" string fragment for all the options\n+   in OPTIONS_GROUP.  */\n+extern std::string build_help\n+  (const char *help_tmpl,\n+   gdb::array_view<const option_def_group> options_group);\n+\n+/* Install set/show commands for options defined in OPTIONS.  DATA is\n+   a pointer to the structure that holds the data associated with the\n+   OPTIONS array.  */\n+extern void add_setshow_cmds_for_options (command_class cmd_class, void *data,\n+\t\t\t\t\t  gdb::array_view<const option_def> options,\n+\t\t\t\t\t  struct cmd_list_element **set_list,\n+\t\t\t\t\t  struct cmd_list_element **show_list);\n+\n+} /* namespace option */\n+} /* namespace gdb */\n+\n+#endif /* CLI_OPTION_H */"
    },
    {
      "sha": "14ea723c6a98820f346db6fd721ae99cf9ee6ac2",
      "filename": "gdb/cli/cli-setshow.c",
      "status": "modified",
      "additions": 163,
      "deletions": 117,
      "changes": 280,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-setshow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-setshow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-setshow.c?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -78,33 +78,48 @@ parse_auto_binary_operation (const char *arg)\n /* See cli-setshow.h.  */\n \n int\n-parse_cli_boolean_value (const char *arg)\n+parse_cli_boolean_value (const char **arg)\n {\n-  int length;\n-\n-  if (!arg || !*arg)\n-    return 1;\n+  const char *p = skip_to_space (*arg);\n+  size_t length = p - *arg;\n \n-  length = strlen (arg);\n+  /* Note that \"o\" is ambiguous.  */\n \n-  while (arg[length - 1] == ' ' || arg[length - 1] == '\\t')\n-    length--;\n+  if ((length == 2 && strncmp (*arg, \"on\", length) == 0)\n+      || strncmp (*arg, \"1\", length) == 0\n+      || strncmp (*arg, \"yes\", length) == 0\n+      || strncmp (*arg, \"enable\", length) == 0)\n+    {\n+      *arg = skip_spaces (*arg + length);\n+      return 1;\n+    }\n+  else if ((length >= 2 && strncmp (*arg, \"off\", length) == 0)\n+\t   || strncmp (*arg, \"0\", length) == 0\n+\t   || strncmp (*arg, \"no\", length) == 0\n+\t   || strncmp (*arg, \"disable\", length) == 0)\n+    {\n+      *arg = skip_spaces (*arg + length);\n+      return 0;\n+    }\n+  else\n+    return -1;\n+}\n \n-  /* Note that \"o\" is ambiguous.  */\n+/* See cli-setshow.h.  */\n \n-  if ((length == 2 && strncmp (arg, \"on\", length) == 0)\n-      || strncmp (arg, \"1\", length) == 0\n-      || strncmp (arg, \"yes\", length) == 0\n-      || strncmp (arg, \"enable\", length) == 0)\n+int\n+parse_cli_boolean_value (const char *arg)\n+{\n+  if (!arg || !*arg)\n     return 1;\n-  else if ((length >= 2 && strncmp (arg, \"off\", length) == 0)\n-\t   || strncmp (arg, \"0\", length) == 0\n-\t   || strncmp (arg, \"no\", length) == 0\n-\t   || strncmp (arg, \"disable\", length) == 0)\n-    return 0;\n-  else\n+\n+  int b = parse_cli_boolean_value (&arg);\n+  if (b >= 0 && *arg != '\\0')\n     return -1;\n+\n+  return b;\n }\n+\n \f\n void\n deprecated_show_value_hack (struct ui_file *ignore_file,\n@@ -134,21 +149,136 @@ deprecated_show_value_hack (struct ui_file *ignore_file,\n \n /* Returns true if ARG is \"unlimited\".  */\n \n-static int\n-is_unlimited_literal (const char *arg)\n+static bool\n+is_unlimited_literal (const char **arg)\n {\n-  arg = skip_spaces (arg);\n+  *arg = skip_spaces (*arg);\n \n-  const char *p = skip_to_space (arg);\n+  const char *p = skip_to_space (*arg);\n \n-  size_t len = p - arg;\n+  size_t len = p - *arg;\n \n-  if (len > 0 && strncmp (\"unlimited\", arg, len) == 0)\n-    return true;\n+  if (len > 0 && strncmp (\"unlimited\", *arg, len) == 0)\n+    {\n+      *arg += len;\n+      return true;\n+    }\n \n   return false;\n }\n \n+/* See cli-setshow.h.  */\n+\n+unsigned int\n+parse_cli_var_uinteger (var_types var_type, const char **arg,\n+\t\t\tbool expression)\n+{\n+  LONGEST val;\n+\n+  if (*arg == nullptr)\n+    {\n+      if (var_type == var_uinteger)\n+\terror_no_arg (_(\"integer to set it to, or \\\"unlimited\\\".\"));\n+      else\n+\terror_no_arg (_(\"integer to set it to.\"));\n+    }\n+\n+  if (var_type == var_uinteger && is_unlimited_literal (arg))\n+    val = 0;\n+  else if (expression)\n+    val = parse_and_eval_long (*arg);\n+  else\n+    val = get_ulongest (arg);\n+\n+  if (var_type == var_uinteger && val == 0)\n+    val = UINT_MAX;\n+  else if (val < 0\n+\t   /* For var_uinteger, don't let the user set the value\n+\t      to UINT_MAX directly, as that exposes an\n+\t      implementation detail to the user interface.  */\n+\t   || (var_type == var_uinteger && val >= UINT_MAX)\n+\t   || (var_type == var_zuinteger && val > UINT_MAX))\n+    error (_(\"integer %s out of range\"), plongest (val));\n+\n+  return val;\n+}\n+\n+/* See cli-setshow.h.  */\n+\n+int\n+parse_cli_var_zuinteger_unlimited (const char **arg, bool expression)\n+{\n+  LONGEST val;\n+\n+  if (*arg == nullptr)\n+    error_no_arg (_(\"integer to set it to, or \\\"unlimited\\\".\"));\n+\n+  if (is_unlimited_literal (arg))\n+    val = -1;\n+  else if (expression)\n+    val = parse_and_eval_long (*arg);\n+  else\n+    val = get_ulongest (arg);\n+\n+  if (val > INT_MAX)\n+    error (_(\"integer %s out of range\"), plongest (val));\n+  else if (val < -1)\n+    error (_(\"only -1 is allowed to set as unlimited\"));\n+\n+  return val;\n+}\n+\n+/* See cli-setshow.h.  */\n+\n+const char *\n+parse_cli_var_enum (const char **args, const char *const *enums)\n+{\n+  /* If no argument was supplied, print an informative error\n+     message.  */\n+  if (args == NULL || *args == NULL || **args == '\\0')\n+    {\n+      std::string msg;\n+\n+      for (size_t i = 0; enums[i]; i++)\n+\t{\n+\t  if (i != 0)\n+\t    msg += \", \";\n+\t  msg += enums[i];\n+\t}\n+      error (_(\"Requires an argument. Valid arguments are %s.\"),\n+\t     msg.c_str ());\n+    }\n+\n+  const char *p = skip_to_space (*args);\n+  size_t len = p - *args;\n+\n+  int nmatches = 0;\n+  const char *match = NULL;\n+  for (size_t i = 0; enums[i]; i++)\n+    if (strncmp (*args, enums[i], len) == 0)\n+      {\n+\tif (enums[i][len] == '\\0')\n+\t  {\n+\t    match = enums[i];\n+\t    nmatches = 1;\n+\t    break; /* Exact match.  */\n+\t  }\n+\telse\n+\t  {\n+\t    match = enums[i];\n+\t    nmatches++;\n+\t  }\n+      }\n+\n+  if (nmatches == 0)\n+    error (_(\"Undefined item: \\\"%.*s\\\".\"), (int) len, *args);\n+\n+  if (nmatches > 1)\n+    error (_(\"Ambiguous item \\\"%.*s\\\".\"), (int) len, *args);\n+\n+  *args += len;\n+  return match;\n+}\n \n /* Do a \"set\" command.  ARG is NULL if no argument, or the\n    text of the argument, and FROM_TTY is nonzero if this command is\n@@ -295,30 +425,7 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n     case var_uinteger:\n     case var_zuinteger:\n       {\n-\tLONGEST val;\n-\n-\tif (arg == NULL)\n-\t  {\n-\t    if (c->var_type == var_uinteger)\n-\t      error_no_arg (_(\"integer to set it to, or \\\"unlimited\\\".\"));\n-\t    else\n-\t      error_no_arg (_(\"integer to set it to.\"));\n-\t  }\n-\n-\tif (c->var_type == var_uinteger && is_unlimited_literal (arg))\n-\t  val = 0;\n-\telse\n-\t  val = parse_and_eval_long (arg);\n-\n-\tif (c->var_type == var_uinteger && val == 0)\n-\t  val = UINT_MAX;\n-\telse if (val < 0\n-\t\t /* For var_uinteger, don't let the user set the value\n-\t\t    to UINT_MAX directly, as that exposes an\n-\t\t    implementation detail to the user interface.  */\n-\t\t || (c->var_type == var_uinteger && val >= UINT_MAX)\n-\t\t || (c->var_type == var_zuinteger && val > UINT_MAX))\n-\t  error (_(\"integer %s out of range\"), plongest (val));\n+\tunsigned int val = parse_cli_var_uinteger (c->var_type, &arg, true);\n \n \tif (*(unsigned int *) c->var != val)\n \t  {\n@@ -341,7 +448,7 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \t      error_no_arg (_(\"integer to set it to.\"));\n \t  }\n \n-\tif (c->var_type == var_integer && is_unlimited_literal (arg))\n+\tif (c->var_type == var_integer && is_unlimited_literal (&arg))\n \t  val = 0;\n \telse\n \t  val = parse_and_eval_long (arg);\n@@ -366,59 +473,11 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n       }\n     case var_enum:\n       {\n-\tint i;\n-\tint len;\n-\tint nmatches;\n-\tconst char *match = NULL;\n-\tconst char *p;\n-\n-\t/* If no argument was supplied, print an informative error\n-\t   message.  */\n-\tif (arg == NULL)\n-\t  {\n-\t    std::string msg;\n-\n-\t    for (i = 0; c->enums[i]; i++)\n-\t      {\n-\t\tif (i != 0)\n-\t\t  msg += \", \";\n-\t\tmsg += c->enums[i];\n-\t      }\n-\t    error (_(\"Requires an argument. Valid arguments are %s.\"), \n-\t\t   msg.c_str ());\n-\t  }\n-\n-\tp = strchr (arg, ' ');\n+\tconst char *end_arg = arg;\n+\tconst char *match = parse_cli_var_enum (&end_arg, c->enums);\n \n-\tif (p)\n-\t  len = p - arg;\n-\telse\n-\t  len = strlen (arg);\n-\n-\tnmatches = 0;\n-\tfor (i = 0; c->enums[i]; i++)\n-\t  if (strncmp (arg, c->enums[i], len) == 0)\n-\t    {\n-\t      if (c->enums[i][len] == '\\0')\n-\t\t{\n-\t\t  match = c->enums[i];\n-\t\t  nmatches = 1;\n-\t\t  break; /* Exact match.  */\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  match = c->enums[i];\n-\t\t  nmatches++;\n-\t\t}\n-\t    }\n-\n-\tif (nmatches <= 0)\n-\t  error (_(\"Undefined item: \\\"%s\\\".\"), arg);\n-\n-\tif (nmatches > 1)\n-\t  error (_(\"Ambiguous item \\\"%s\\\".\"), arg);\n-\n-\tconst char *after = skip_spaces (arg + len);\n+\tint len = end_arg - arg;\n+\tconst char *after = skip_spaces (end_arg);\n \tif (*after != '\\0')\n \t  error (_(\"Junk after item \\\"%.*s\\\": %s\"), len, arg, after);\n \n@@ -432,20 +491,7 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n       break;\n     case var_zuinteger_unlimited:\n       {\n-\tLONGEST val;\n-\n-\tif (arg == NULL)\n-\t  error_no_arg (_(\"integer to set it to, or \\\"unlimited\\\".\"));\n-\n-\tif (is_unlimited_literal (arg))\n-\t  val = -1;\n-\telse\n-\t  val = parse_and_eval_long (arg);\n-\n-\tif (val > INT_MAX)\n-\t  error (_(\"integer %s out of range\"), plongest (val));\n-\telse if (val < -1)\n-\t  error (_(\"only -1 is allowed to set as unlimited\"));\n+\tint val = parse_cli_var_zuinteger_unlimited (&arg, true);\n \n \tif (*(int *) c->var != val)\n \t  {"
    },
    {
      "sha": "c00a0989145613f6434ec275cafffc22436db50c",
      "filename": "gdb/cli/cli-setshow.h",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-setshow.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-setshow.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-setshow.h?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -23,6 +23,33 @@ struct cmd_list_element;\n    Returns 1 for true, 0 for false, and -1 if invalid.  */\n extern int parse_cli_boolean_value (const char *arg);\n \n+/* Same as above, but work with a pointer to pointer.  ARG is advanced\n+   past a successfully parsed value.  */\n+extern int parse_cli_boolean_value (const char **arg);\n+\n+/* Parse ARG, an option to a var_uinteger or var_zuinteger variable.\n+   Either returns the parsed value on success or throws an error.  If\n+   EXPRESSION is true, *ARG is parsed as an expression; otherwise, it\n+   is parsed with get_ulongest.  It's not possible to parse the\n+   integer as an expression when there may be valid input after the\n+   integer, such as when parsing command options.  E.g., \"print\n+   -elements NUMBER -obj --\".  In such case, parsing as an expression\n+   would parse \"-obj --\" as part of the expression as well.  */\n+extern unsigned int parse_cli_var_uinteger (var_types var_type,\n+\t\t\t\t\t    const char **arg,\n+\t\t\t\t\t    bool expression);\n+\n+/* Like parse_cli_var_uinteger, for var_zuinteger_unlimited.  */\n+extern int parse_cli_var_zuinteger_unlimited (const char **arg,\n+\t\t\t\t\t      bool expression);\n+\n+/* Parse ARG, an option to a var_enum variable.  ENUM is a\n+   null-terminated array of possible values. Either returns the parsed\n+   value on success or throws an error.  ARG is advanced past the\n+   parsed value.  */\n+const char *parse_cli_var_enum (const char **args,\n+\t\t\t\tconst char *const *enums);\n+\n extern void do_set_command (const char *arg, int from_tty,\n \t\t\t    struct cmd_list_element *c);\n extern void do_show_command (const char *arg, int from_tty,"
    },
    {
      "sha": "306b69e3d8ff1df916252c844682204b02c1d259",
      "filename": "gdb/cli/cli-utils.c",
      "status": "modified",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-utils.c?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -27,6 +27,57 @@ static std::string extract_arg_maybe_quoted (const char **arg);\n \n /* See documentation in cli-utils.h.  */\n \n+ULONGEST\n+get_ulongest (const char **pp, int trailer)\n+{\n+  LONGEST retval = 0;\t/* default */\n+  const char *p = *pp;\n+\n+  if (*p == '$')\n+    {\n+      value *val = value_from_history_ref (p, &p);\n+\n+      if (val != NULL)\t/* Value history reference */\n+\t{\n+\t  if (TYPE_CODE (value_type (val)) == TYPE_CODE_INT)\n+\t    retval = value_as_long (val);\n+\t  else\n+\t    error (_(\"History value must have integer type.\"));\n+\t}\n+      else\t/* Convenience variable */\n+\t{\n+\t  /* Internal variable.  Make a copy of the name, so we can\n+\t     null-terminate it to pass to lookup_internalvar().  */\n+\t  const char *start = ++p;\n+\t  while (isalnum (*p) || *p == '_')\n+\t    p++;\n+\t  std::string varname (start, p - start);\n+\t  if (!get_internalvar_integer (lookup_internalvar (varname.c_str ()),\n+\t\t\t\t       &retval))\n+\t    error (_(\"Convenience variable $%s does not have integer value.\"),\n+\t\t   varname.c_str ());\n+\t}\n+    }\n+  else\n+    {\n+      retval = strtoulst (p, pp, 0);\n+      if (p == *pp)\n+\t{\n+\t  /* There is no number here.  (e.g. \"cond a == b\").  */\n+\t  error (_(\"Expected integer at: %s\"), p);\n+\t}\n+      p = *pp;\n+    }\n+\n+  if (!(isspace (*p) || *p == '\\0' || *p == trailer))\n+    error (_(\"Trailing junk at: %s\"), p);\n+  p = skip_spaces (p);\n+  *pp = p;\n+  return retval;\n+}\n+\n+/* See documentation in cli-utils.h.  */\n+\n int\n get_number_trailer (const char **pp, int trailer)\n {"
    },
    {
      "sha": "41c23561d6f2d24662df3ef2f24886a620c320c1",
      "filename": "gdb/cli/cli-utils.h",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/cli/cli-utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-utils.h?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -39,6 +39,10 @@ extern int get_number (const char **);\n \n extern int get_number (char **);\n \n+/* Like get_number_trailer, but works with ULONGEST, and throws on\n+   error instead of returning 0.  */\n+extern ULONGEST get_ulongest (const char **pp, int trailer = '\\0');\n+\n /* Extract from ARGS the arguments [-q] [-t TYPEREGEXP] [--] NAMEREGEXP.\n \n    The caller is responsible to initialize *QUIET to false, *REGEXP\n@@ -193,6 +197,14 @@ extern std::string extract_arg (const char **arg);\n    argument.  */\n extern int check_for_argument (const char **str, const char *arg, int arg_len);\n \n+/* Same as above, but ARG's length is computed.  */\n+\n+static inline int\n+check_for_argument (const char **str, const char *arg)\n+{\n+  return check_for_argument (str, arg, strlen (arg));\n+}\n+\n /* Same, for non-const STR.  */\n \n static inline int\n@@ -202,6 +214,12 @@ check_for_argument (char **str, const char *arg, int arg_len)\n \t\t\t     arg, arg_len);\n }\n \n+static inline int\n+check_for_argument (char **str, const char *arg)\n+{\n+  return check_for_argument (str, arg, strlen (arg));\n+}\n+\n /* A helper function that looks for a set of flags at the start of a\n    string.  The possible flags are given as a null terminated string.\n    A flag in STR must either be at the end of the string,"
    },
    {
      "sha": "599155cbfe674a7ce95f25f90a2496830332cea3",
      "filename": "gdb/maint-test-options.c",
      "status": "added",
      "additions": 461,
      "deletions": 0,
      "changes": 461,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/maint-test-options.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/maint-test-options.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/maint-test-options.c?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -0,0 +1,461 @@\n+/* Maintenance commands for testing the options framework.\n+\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"gdbcmd.h\"\n+#include \"cli/cli-option.h\"\n+\n+/* This file defines three \"maintenance test-options\" subcommands to\n+   exercise TAB-completion and option processing:\n+\n+    (gdb) maint test-options require-delimiter\n+    (gdb) maint test-options unknown-is-error\n+    (gdb) maint test-options unknown-is-operand\n+\n+   And a fourth one to help with TAB-completion testing.\n+\n+    (gdb) maint show test-options-completion-result\n+\n+   Each of the test-options subcommands exercise\n+   gdb::option::process_options with a different enum\n+   process_options_mode value.  Examples for commands they model:\n+\n+   - \"print\" and \"compile print\", are like \"require-delimiter\",\n+      because they accept random expressions as argument.\n+\n+   - \"backtrace\" and \"frame/thread apply\" are like\n+     \"unknown-is-operand\", because \"-\" is a valid command.\n+\n+   - \"compile file\" and \"compile code\" are like \"unknown-is-error\".\n+\n+   These commands allow exercising all aspects of option processing\n+   without having to pick some existing command.  That should be more\n+   stable going forward than relying on an existing user command,\n+   since if we picked say \"print\", that command or its options could\n+   change in future, and then we'd be left with having to pick some\n+   other command or option to exercise some non-command-specific\n+   option processing detail.  Also, actual user commands have side\n+   effects that we're not interested in when we're focusing on unit\n+   testing the options machinery.  BTW, a maintenance command is used\n+   as a sort of unit test driver instead of actual \"maint selftest\"\n+   unit tests, since we need to go all the way via gdb including\n+   readline, for proper testing of TAB completion.\n+\n+   These maintenance commands support options of all the different\n+   available kinds of commands (boolean, enum, flag, uinteger):\n+\n+    (gdb) maint test-options require-delimiter -[TAB]\n+    -bool      -enum      -flag      -uinteger   -xx1       -xx2\n+\n+    (gdb) maint test-options require-delimiter -bool o[TAB]\n+    off  on\n+    (gdb) maint test-options require-delimiter -enum [TAB]\n+    xxx  yyy  zzz\n+    (gdb) maint test-options require-delimiter -uinteger [TAB]\n+    NUMBER     unlimited\n+\n+   '-xx1' and '-xx2' are flag options too.  They exist in order to\n+   test ambiguous option names, like '-xx'.\n+\n+  Invoking the commands makes them print out the options parsed:\n+\n+   (gdb) maint test-options unknown-is-error -flag -enum yyy cmdarg\n+   -flag 1 -xx1 0 -xx2 0 -bool 0 -enum yyy -uint 0 -zuint-unl 0 -- cmdarg\n+\n+   (gdb) maint test-options require-delimiter -flag -enum yyy cmdarg\n+   -flag 0 -xx1 0 -xx2 0 -bool 0 -enum xxx -uint 0  -zuint-unl 0 -- -flag -enum yyy cmdarg\n+   (gdb) maint test-options require-delimiter -flag -enum yyy cmdarg --\n+   Unrecognized option at: cmdarg --\n+   (gdb) maint test-options require-delimiter -flag -enum yyy -- cmdarg\n+   -flag 1 -xx1 0 -xx2 0 -bool 0 -enum yyy -uint 0 -zuint-unl 0 -- cmdarg\n+\n+  The \"maint show test-options-completion-result\" command exists in\n+  order to do something similar for completion:\n+\n+   (gdb) maint test-options unknown-is-error -flag -b 0 -enum yyy OPERAND[TAB]\n+   (gdb) maint show test-options-completion-result\n+   0 OPERAND\n+\n+   (gdb) maint test-options unknown-is-error -flag -b 0 -enum yyy[TAB]\n+   (gdb) maint show test-options-completion-result\n+   1\n+\n+   (gdb) maint test-options require-dash -unknown[TAB]\n+   (gdb) maint show test-options-completion-result\n+   1\n+\n+  Here, \"1\" means the completion function processed the whole input\n+  line, and that the command shouldn't do anything with the arguments,\n+  since there are no operands.  While \"0\" indicates that there are\n+  operands after options.  The text after \"0\" is the operands.\n+\n+  This level of detail is particularly important because getting the\n+  completion function's entry point to return back to the caller the\n+  right pointer into the operand is quite tricky in several\n+  scenarios.  */\n+\n+/* Enum values for the \"maintenance test-options\" commands.  */\n+const char test_options_enum_values_xxx[] = \"xxx\";\n+const char test_options_enum_values_yyy[] = \"yyy\";\n+const char test_options_enum_values_zzz[] = \"zzz\";\n+static const char *const test_options_enum_values_choices[] =\n+{\n+  test_options_enum_values_xxx,\n+  test_options_enum_values_yyy,\n+  test_options_enum_values_zzz,\n+  NULL\n+};\n+\n+/* Option data for the \"maintenance test-options\" commands.  */\n+\n+struct test_options_opts\n+{\n+  int flag_opt = 0;\n+  int xx1_opt = 0;\n+  int xx2_opt = 0;\n+  int boolean_opt = 0;\n+  const char *enum_opt = test_options_enum_values_xxx;\n+  unsigned int uint_opt = 0;\n+  int zuint_unl_opt = 0;\n+};\n+\n+/* Option definitions for the \"maintenance test-options\" commands.  */\n+\n+static const gdb::option::option_def test_options_option_defs[] = {\n+\n+  /* A flag option.  */\n+  gdb::option::flag_option_def<test_options_opts> {\n+    \"flag\",\n+    [] (test_options_opts *opts) { return &opts->flag_opt; },\n+    N_(\"A flag option.\"),\n+  },\n+\n+  /* A couple flags with similar names, for \"ambiguous option names\"\n+     testing.  */\n+  gdb::option::flag_option_def<test_options_opts> {\n+    \"xx1\",\n+    [] (test_options_opts *opts) { return &opts->xx1_opt; },\n+    N_(\"A flag option.\"),\n+  },\n+  gdb::option::flag_option_def<test_options_opts> {\n+    \"xx2\",\n+    [] (test_options_opts *opts) { return &opts->xx2_opt; },\n+    N_(\"A flag option.\"),\n+  },\n+\n+  /* A boolean option.  */\n+  gdb::option::boolean_option_def<test_options_opts> {\n+    \"bool\",\n+    [] (test_options_opts *opts) { return &opts->boolean_opt; },\n+    nullptr, /* show_cmd_cb */\n+    N_(\"A boolean option.\"),\n+  },\n+\n+  /* An enum option.  */\n+  gdb::option::enum_option_def<test_options_opts> {\n+    \"enum\",\n+    test_options_enum_values_choices,\n+    [] (test_options_opts *opts) { return &opts->enum_opt; },\n+    nullptr, /* show_cmd_cb */\n+    N_(\"An enum option.\"),\n+  },\n+\n+  /* A uinteger option.  */\n+  gdb::option::uinteger_option_def<test_options_opts> {\n+    \"uinteger\",\n+    [] (test_options_opts *opts) { return &opts->uint_opt; },\n+    nullptr, /* show_cmd_cb */\n+    N_(\"A uinteger option.\"),\n+    nullptr, /* show_doc */\n+    N_(\"A help doc that spawns\\nmultiple lines.\"),\n+  },\n+\n+  /* A zuinteger_unlimited option.  */\n+  gdb::option::zuinteger_unlimited_option_def<test_options_opts> {\n+    \"zuinteger-unlimited\",\n+    [] (test_options_opts *opts) { return &opts->zuint_unl_opt; },\n+    nullptr, /* show_cmd_cb */\n+    N_(\"A zuinteger-unlimited option.\"),\n+    nullptr, /* show_doc */\n+    nullptr, /* help_doc */\n+  },\n+};\n+\n+/* Create an option_def_group for the test_options_opts options, with\n+   OPTS as context.  */\n+\n+static inline gdb::option::option_def_group\n+make_test_options_options_def_group (test_options_opts *opts)\n+{\n+  return {{test_options_option_defs}, opts};\n+}\n+\n+/* Implementation of the \"maintenance test-options\n+   require-delimiter/unknown-is-error/unknown-is-operand\" commands.\n+   Each of the commands maps to a different enum process_options_mode\n+   enumerator.  The test strategy is simply processing the options in\n+   a number of scenarios, and printing back the parsed result.  */\n+\n+static void\n+maintenance_test_options_command_mode (const char *args,\n+\t\t\t\t       gdb::option::process_options_mode mode)\n+{\n+  test_options_opts opts;\n+\n+  gdb::option::process_options (&args, mode,\n+\t\t\t\tmake_test_options_options_def_group (&opts));\n+\n+  if (args == nullptr)\n+    args = \"\";\n+  else\n+    args = skip_spaces (args);\n+\n+  printf_unfiltered (_(\"-flag %d -xx1 %d -xx2 %d -bool %d \"\n+\t\t       \"-enum %s -uint %s -zuint-unl %s -- %s\\n\"),\n+\t\t     opts.flag_opt,\n+\t\t     opts.xx1_opt,\n+\t\t     opts.xx2_opt,\n+\t\t     opts.boolean_opt,\n+\t\t     opts.enum_opt,\n+\t\t     (opts.uint_opt == UINT_MAX\n+\t\t      ? \"unlimited\"\n+\t\t      : pulongest (opts.uint_opt)),\n+\t\t     (opts.zuint_unl_opt == -1\n+\t\t      ? \"unlimited\"\n+\t\t      : plongest (opts.zuint_unl_opt)),\n+\t\t     args);\n+}\n+\n+/* Variables used by the \"maintenance show\n+   test-options-completion-result\" command.  These variables are\n+   stored by the completer of the \"maint test-options\"\n+   subcommands.  */\n+\n+/* The result of gdb::option::complete_options.  */\n+static int maintenance_test_options_command_completion_result;\n+/* The text at the word point after gdb::option::complete_options\n+   returns.  */\n+static std::string maintenance_test_options_command_completion_text;\n+\n+/* The \"maintenance show test-options-completion-result\" command.  */\n+\n+static void\n+maintenance_show_test_options_completion_result\n+  (struct ui_file *file, int from_tty,\n+   struct cmd_list_element *c, const char *value)\n+{\n+  if (maintenance_test_options_command_completion_result)\n+    fprintf_filtered (file, \"1\\n\");\n+  else\n+    fprintf_filtered\n+      (file, _(\"0 %s\\n\"),\n+       maintenance_test_options_command_completion_text.c_str ());\n+}\n+\n+/* Implementation of completer for the \"maintenance test-options\n+   require-delimiter/unknown-is-error/unknown-is-operand\" commands.\n+   Each of the commands maps to a different enum process_options_mode\n+   enumerator.  */\n+\n+static void\n+maintenance_test_options_completer_mode (completion_tracker &tracker,\n+\t\t\t\t\t const char *text,\n+\t\t\t\t\t gdb::option::process_options_mode mode)\n+{\n+  try\n+    {\n+      maintenance_test_options_command_completion_result\n+\t= gdb::option::complete_options\n+\t   (tracker, &text, mode,\n+\t    make_test_options_options_def_group (nullptr));\n+      maintenance_test_options_command_completion_text = text;\n+    }\n+  catch (const gdb_exception_error &ex)\n+    {\n+      maintenance_test_options_command_completion_result = 1;\n+      throw;\n+    }\n+}\n+\n+/* Implementation of the \"maintenance test-options require-delimiter\"\n+   command.  */\n+\n+static void\n+maintenance_test_options_require_delimiter_command (const char *args,\n+\t\t\t\t\t\t    int from_tty)\n+{\n+  maintenance_test_options_command_mode\n+    (args, gdb::option::PROCESS_OPTIONS_REQUIRE_DELIMITER);\n+}\n+\n+/* Implementation of the \"maintenance test-options\n+   unknown-is-error\" command.  */\n+\n+static void\n+maintenance_test_options_unknown_is_error_command (const char *args,\n+\t\t\t\t\t\t   int from_tty)\n+{\n+  maintenance_test_options_command_mode\n+    (args, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_ERROR);\n+}\n+\n+/* Implementation of the \"maintenance test-options\n+   unknown-is-operand\" command.  */\n+\n+static void\n+maintenance_test_options_unknown_is_operand_command (const char *args,\n+\t\t\t\t\t\t     int from_tty)\n+{\n+  maintenance_test_options_command_mode\n+    (args, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_OPERAND);\n+}\n+\n+/* Completer for the \"maintenance test-options require-delimiter\"\n+   command.  */\n+\n+static void\n+maintenance_test_options_require_delimiter_command_completer\n+  (cmd_list_element *ignore, completion_tracker &tracker,\n+   const char *text, const char *word)\n+{\n+  maintenance_test_options_completer_mode\n+    (tracker, text, gdb::option::PROCESS_OPTIONS_REQUIRE_DELIMITER);\n+}\n+\n+/* Completer for the \"maintenance test-options unknown-is-error\"\n+   command.  */\n+\n+static void\n+maintenance_test_options_unknown_is_error_command_completer\n+  (cmd_list_element *ignore, completion_tracker &tracker,\n+   const char *text, const char *word)\n+{\n+  maintenance_test_options_completer_mode\n+    (tracker, text, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_ERROR);\n+}\n+\n+/* Completer for the \"maintenance test-options unknown-is-operand\"\n+   command.  */\n+\n+static void\n+maintenance_test_options_unknown_is_operand_command_completer\n+  (cmd_list_element *ignore, completion_tracker &tracker,\n+   const char *text, const char *word)\n+{\n+  maintenance_test_options_completer_mode\n+    (tracker, text, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_OPERAND);\n+}\n+\n+/* Command list for maint test-options.  */\n+struct cmd_list_element *maintenance_test_options_list;\n+\n+/* The \"maintenance test-options\" prefix command.  */\n+\n+static void\n+maintenance_test_options_command (const char *arg, int from_tty)\n+{\n+  printf_unfiltered\n+    (_(\"\\\"maintenance test-options\\\" must be followed \"\n+       \"by the name of a subcommand.\\n\"));\n+  help_list (maintenance_test_options_list, \"maintenance test-options \",\n+\t     all_commands, gdb_stdout);\n+}\n+\n+\f\n+void\n+_initialize_maint_test_options ()\n+{\n+  cmd_list_element *cmd;\n+\n+  add_prefix_cmd (\"test-options\", no_class, maintenance_test_options_command,\n+\t\t  _(\"\\\n+Generic command for testing the options infrastructure.\"),\n+\t\t  &maintenance_test_options_list,\n+\t\t  \"maintenance test-options \", 0,\n+\t\t  &maintenancelist);\n+\n+  const auto def_group = make_test_options_options_def_group (nullptr);\n+\n+  static const std::string help_require_delim_str\n+    = gdb::option::build_help (_(\"\\\n+Command used for testing options processing.\\n\\\n+Usage: maint test-options require-delimiter [[OPTION]... --] [OPERAND]...\\n\\\n+\\n\\\n+Options:\\n\\\n+\\n\\\n+%OPTIONS%\\n\\\n+If you specify any command option, you must use a double dash (\\\"--\\\")\\n\\\n+to mark the end of option processing.\"),\n+\t\t\t       def_group);\n+\n+  static const std::string help_unknown_is_error_str\n+    = gdb::option::build_help (_(\"\\\n+Command used for testing options processing.\\n\\\n+Usage: maint test-options unknown-is-error [OPTION]... [OPERAND]...\\n\\\n+\\n\\\n+Options:\\n\\\n+\\n\\\n+%OPTIONS%\"),\n+\t\t\t       def_group);\n+\n+  static const std::string help_unknown_is_operand_str\n+    = gdb::option::build_help (_(\"\\\n+Command used for testing options processing.\\n\\\n+Usage: maint test-options unknown-is-operand [OPTION]... [OPERAND]...\\n\\\n+\\n\\\n+Options:\\n\\\n+\\n\\\n+%OPTIONS%\"),\n+\t\t\t       def_group);\n+\n+  cmd = add_cmd (\"require-delimiter\", class_maintenance,\n+\t\t maintenance_test_options_require_delimiter_command,\n+\t\t help_require_delim_str.c_str (),\n+\t\t &maintenance_test_options_list);\n+  set_cmd_completer_handle_brkchars\n+    (cmd, maintenance_test_options_require_delimiter_command_completer);\n+\n+  cmd = add_cmd (\"unknown-is-error\", class_maintenance,\n+\t\t maintenance_test_options_unknown_is_error_command,\n+\t\t help_unknown_is_error_str.c_str (),\n+\t\t &maintenance_test_options_list);\n+  set_cmd_completer_handle_brkchars\n+    (cmd, maintenance_test_options_unknown_is_error_command_completer);\n+\n+  cmd = add_cmd (\"unknown-is-operand\", class_maintenance,\n+\t\t maintenance_test_options_unknown_is_operand_command,\n+\t\t help_unknown_is_operand_str.c_str (),\n+\t\t &maintenance_test_options_list);\n+  set_cmd_completer_handle_brkchars\n+    (cmd, maintenance_test_options_unknown_is_operand_command_completer);\n+\n+  add_setshow_zinteger_cmd (\"test-options-completion-result\", class_maintenance,\n+\t\t\t    &maintenance_test_options_command_completion_result,\n+\t\t\t    _(\"\\\n+Set maintenance test-options completion result.\"), _(\"\\\n+Show maintenance test-options completion result.\"), _(\"\\\n+Show the results of completing\\n\\\n+\\\"maint test-options require-delimiter\\\",\\n\\\n+\\\"maint test-options unknown-is-error\\\", or\\n\\\n+\\\"maint test-options unknown-is-operand\\\".\"),\n+\t\t\t    NULL,\n+\t\t\t    maintenance_show_test_options_completion_result,\n+\t\t\t    &maintenance_set_cmdlist,\n+\t\t\t    &maintenance_show_cmdlist);\n+}"
    },
    {
      "sha": "6e5dacbf0ee0756876fd1d56e1f9c16536380f2a",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -1,3 +1,8 @@\n+2019-06-13  Pedro Alves  <palves@redhat.com>\n+\n+\t* gdb.base/options.c: New file.\n+\t* gdb.base/options.exp: New file.\n+\n 2019-06-13  Pedro Alves  <palves@redhat.com>\n \n \t* gdb.base/settings.exp (test-boolean, test-auto-boolean): Check"
    },
    {
      "sha": "fd19922b54e95d62d285c801371228a23e43b34a",
      "filename": "gdb/testsuite/gdb.base/options.c",
      "status": "added",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/testsuite/gdb.base/options.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/testsuite/gdb.base/options.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/options.c?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -0,0 +1,33 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+int xxx1= 123;\n+\n+struct S\n+{\n+  int a;\n+  int b;\n+  int c;\n+};\n+\n+struct S g_s = {1, 2, 3};\n+\n+int\n+main ()\n+{\n+  return 0;\n+}"
    },
    {
      "sha": "1891176dc1dbca9a5ba7706c0a33eb6e24927114",
      "filename": "gdb/testsuite/gdb.base/options.exp",
      "status": "added",
      "additions": 554,
      "deletions": 0,
      "changes": 554,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/testsuite/gdb.base/options.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d0faba9f52b898f0be539bc4d6fbd084772259d/gdb/testsuite/gdb.base/options.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/options.exp?ref=9d0faba9f52b898f0be539bc4d6fbd084772259d",
      "patch": "@@ -0,0 +1,554 @@\n+# This testcase is part of GDB, the GNU debugger.\n+\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test the gdb::option framework.\n+\n+# The test uses the \"maintenance test-options\" subcommands to exercise\n+# TAB-completion and option processing.\n+\n+load_lib completion-support.exp\n+\n+clean_restart\n+\n+if { ![readline_is_used] } {\n+    untested \"no tab completion support without readline\"\n+    return -1\n+}\n+\n+# Check the completion result, as returned by the \"maintenance show\n+# test-options-completion-result\" command.  TEST is used as test name.\n+proc check_completion_result {expected test} {\n+    gdb_test \"maintenance show test-options-completion-result\" \\\n+\t\"$expected\" \\\n+\t\"$test: res=$expected\"\n+}\n+\n+# Like test_gdb_complete_unique, but the expected output is expected\n+# to be the input line.  I.e., the line is already complete.  We're\n+# just checking whether GDB recognizes the option and auto-appends a\n+# space.\n+proc test_completer_recognizes {res input_line} {\n+    set expected_re [string_to_regexp $input_line]\n+    test_gdb_complete_unique $input_line $expected_re\n+    check_completion_result $res $input_line\n+}\n+\n+# Wrapper around test_gdb_complete_multiple that also checks the\n+# completion result is RES.\n+proc res_test_gdb_complete_multiple {res cmd_prefix completion_word args} {\n+    test_gdb_complete_multiple $cmd_prefix $completion_word {*}$args\n+    check_completion_result $res \"$cmd_prefix$completion_word\"\n+}\n+\n+# Wrapper around test_gdb_complete_none that also checks the\n+# completion result is RES.\n+proc res_test_gdb_complete_none { res input_line } {\n+    test_gdb_complete_none $input_line\n+    check_completion_result $res \"$input_line\"\n+}\n+\n+# Wrapper around test_gdb_complete_unique that also checks the\n+# completion result is RES.\n+proc res_test_gdb_complete_unique { res input_line args} {\n+    test_gdb_complete_unique $input_line {*}$args\n+    check_completion_result $res \"$input_line\"\n+}\n+\n+# Make a full command name from VARIANT.  VARIANT is either\n+# \"require-delimiter\", \"unknown-is-error\" or \"unknown-is-operand\".\n+proc make_cmd {variant} {\n+    return \"maint test-options $variant\"\n+}\n+\n+# Return a string for the expected result of running \"maint\n+# test-options xxx\", with no flag/option set.  OPERAND is the expected\n+# operand.\n+proc expect_none {operand} {\n+    return \"-flag 0 -xx1 0 -xx2 0 -bool 0 -enum xxx -uint 0 -zuint-unl 0 -- $operand\"\n+}\n+\n+# Return a string for the expected result of running \"maint\n+# test-options xxx\", with -flag set.  OPERAND is the expected operand.\n+proc expect_flag {operand} {\n+    return \"-flag 1 -xx1 0 -xx2 0 -bool 0 -enum xxx -uint 0 -zuint-unl 0 -- $operand\"\n+}\n+\n+# Return a string for the expected result of running \"maint\n+# test-options xxx\", with -bool set.  OPERAND is the expected operand.\n+proc expect_bool {operand} {\n+    return \"-flag 0 -xx1 0 -xx2 0 -bool 1 -enum xxx -uint 0 -zuint-unl 0 -- $operand\"\n+}\n+\n+# Return a string for the expected result of running \"maint\n+# test-options xxx\", with one of the integer options set to $VAL.\n+# OPTION determines which option to expect set.  OPERAND is the\n+# expected operand.\n+proc expect_integer {option val operand} {\n+    if {$option == \"uinteger\"} {\n+\treturn \"-flag 0 -xx1 0 -xx2 0 -bool 0 -enum xxx -uint $val -zuint-unl 0 -- $operand\"\n+    } elseif {$option == \"zuinteger-unlimited\"} {\n+\treturn \"-flag 0 -xx1 0 -xx2 0 -bool 0 -enum xxx -uint 0 -zuint-unl $val -- $operand\"\n+    } else {\n+\terror \"unsupported option: $option\"\n+    }\n+}\n+\n+set all_options {\n+    \"-bool\"\n+    \"-enum\"\n+    \"-flag\"\n+    \"-uinteger\"\n+    \"-xx1\"\n+    \"-xx2\"\n+    \"-zuinteger-unlimited\"\n+}\n+\n+# Miscellaneous tests.\n+proc_with_prefix test-misc {variant} {\n+    global all_options\n+\n+    set cmd [make_cmd $variant]\n+\n+    # Call test command with no arguments at all.\n+    gdb_test \"$cmd\" [expect_none \"\"]\n+\n+    # Now with a single dash.\n+    if {$variant == \"require-delimiter\"} {\n+\tgdb_test \"$cmd -\" [expect_none \"-\"]\n+    } else {\n+\tgdb_test \"$cmd -\" \"Ambiguous option at: -\"\n+    }\n+\n+    # Completing at \"-\" should list all options.\n+    res_test_gdb_complete_multiple \"1\" \"$cmd \" \"-\" \"\" $all_options\n+\n+    # Now with a double dash.\n+    gdb_test \"$cmd --\" [expect_none \"\"]\n+\n+    # \"--\" is recognized by options completer, gdb auto-appends a\n+    # space.\n+    test_completer_recognizes 1 \"$cmd --\"\n+\n+    # Now with a double dash, plus a dash as operand.\n+    gdb_test \"$cmd -- -\" [expect_none \"-\"]\n+    res_test_gdb_complete_none \"0 -\" \"$cmd -- -\"\n+\n+    # Completing an unambiguous option just appends an empty space.\n+    test_completer_recognizes 1 \"$cmd -flag\"\n+\n+    # Try running an ambiguous option.\n+    if {$variant == \"require-delimiter\"} {\n+\tgdb_test \"$cmd -xx\" [expect_none \"-xx\"]\n+    } else {\n+\tgdb_test \"$cmd -xx\" \"Ambiguous option at: -xx\"\n+    }\n+\n+    # Check that options are not case insensitive.\n+    gdb_test \"$cmd -flag --\" [expect_flag \"\"]\n+\n+    # Check how the different modes behave on unknown option, with a\n+    # delimiter.\n+    gdb_test \"$cmd -FLAG --\" \\\n+\t\"Unrecognized option at: -FLAG --\"\n+\n+    # Check how the different modes behave on unknown option, without\n+    # a delimiter.\n+    if {$variant == \"unknown-is-error\"} {\n+\tgdb_test \"$cmd -FLAG\" \\\n+\t    \"Unrecognized option at: -FLAG\"\n+    } else {\n+\tgdb_test \"$cmd -FLAG\" [expect_none \"-FLAG\"]\n+    }\n+\n+    # Test parsing stops at a negative integer.\n+    gdb_test \"$cmd -1 --\" \\\n+\t\"Unrecognized option at: -1 --\"\n+    gdb_test \"$cmd -2 --\" \\\n+\t\"Unrecognized option at: -2 --\"\n+}\n+\n+# Flag option tests.\n+proc_with_prefix test-flag {variant} {\n+    global all_options\n+\n+    set cmd [make_cmd $variant]\n+\n+    # Completing a flag just appends a space.\n+    test_completer_recognizes 1 \"$cmd -flag\"\n+\n+    # Add a dash, and all options should be shown.\n+    test_gdb_complete_multiple \"$cmd  -flag \" \"-\" \"\" $all_options\n+\n+    # Basic smoke tests of accepted / not accepted values.\n+\n+    # Check all the different variants a bool option may be specified.\n+    if {$variant == \"require-delimiter\"} {\n+\tgdb_test \"$cmd -flag 999\" [expect_none \"-flag 999\"]\n+    } else {\n+\tgdb_test \"$cmd -flag 999\" [expect_flag \"999\"]\n+    }\n+    gdb_test \"$cmd -flag -- 999\" [expect_flag \"999\"]\n+\n+    # If the \"--\" separator is present, then GDB errors out if the\n+    # flag option is passed some value -- check that too.\n+    gdb_test \"$cmd -flag xxx 999 --\" \"Unrecognized option at: xxx 999 --\"\n+    gdb_test \"$cmd -flag o 999 --\" \"Unrecognized option at: o 999 --\"\n+    gdb_test \"$cmd -flag 1 999 --\" \"Unrecognized option at: 1 999 --\"\n+\n+    # Extract twice the same flag, separated by one space.\n+    gdb_test \"$cmd -flag -flag -- non flags args\" \\\n+\t[expect_flag \"non flags args\"]\n+\n+    # Extract twice the same flag, separated by one space.\n+    gdb_test \"$cmd -xx1     -xx2 -xx1  -xx2 -xx1    -- non flags args\" \\\n+\t\"-flag 0 -xx1 1 -xx2 1 -bool 0 -enum xxx -uint 0 -zuint-unl 0 -- non flags args\"\n+\n+    # Extract 2 known flags in front of unknown flags.\n+    gdb_test \"$cmd -xx1 -xx2 -a -b -c -xx1 --\" \\\n+\t\"Unrecognized option at: -a -b -c -xx1 --\"\n+\n+    # Check that combined flags are not recognised.\n+    gdb_test \"$cmd -xx1 -xx1xx2 -xx1 --\" \\\n+\t\"Unrecognized option at: -xx1xx2 -xx1 --\"\n+\n+    # Make sure the completer don't confuse a flag option with a\n+    # boolean option.  Specifically, \"o\" should not complete to\n+    # \"on/off\".\n+\n+    if {$variant == \"require-delimiter\"} {\n+\tres_test_gdb_complete_none \"1\" \"$cmd -flag o\"\n+\n+\tgdb_test \"$cmd -flag o\" [expect_none \"-flag o\"]\n+    } else {\n+\tres_test_gdb_complete_none \"0 o\" \"$cmd -flag o\"\n+\n+\tgdb_test \"$cmd -flag o\" [expect_flag \"o\"]\n+    }\n+}\n+\n+# Boolean option tests.\n+proc_with_prefix test-boolean {variant} {\n+    global all_options\n+\n+    set cmd [make_cmd $variant]\n+\n+    # Boolean option's values are optional -- \"on\" is implied.  Check\n+    # that:\n+    #\n+    # - For require-delimiter commands, completing after a boolean\n+    #   option lists all other options, plus \"on/off\".  This is\n+    #   because operands won't be processed until we see a \"--\"\n+    #   delimiter.\n+    #\n+    # - For !require-delimiter commands, completing after a boolean\n+    #   option completes as an operand, since that will tend to be\n+    #   more common than typing \"on/off\".\n+    #   E.g., \"frame apply all -past-main COMMAND\".\n+\n+    if {$variant == \"require-delimiter\"} {\n+\tres_test_gdb_complete_multiple 1 \"$cmd -bool \" \"\" \"\" {\n+\t    \"-bool\"\n+\t    \"-enum\"\n+\t    \"-flag\"\n+\t    \"-uinteger\"\n+\t    \"-xx1\"\n+\t    \"-xx2\"\n+\t    \"-zuinteger-unlimited\"\n+\t    \"off\"\n+\t    \"on\"\n+\t}\n+    } else {\n+\tres_test_gdb_complete_none \"0 \" \"$cmd -bool \"\n+    }\n+\n+    # Add another dash, and \"on/off\" are no longer offered:\n+    res_test_gdb_complete_multiple 1 \"$cmd -bool \" \"-\" \"\"  $all_options\n+\n+    # Basic smoke tests of accepted / not accepted values.\n+\n+    # The command accepts all of \"1/0/enable/disable/yes/no\" too, even\n+    # though like the \"set\" command, we don't offer those as\n+    # completion candidates if you complete right after the boolean\n+    # command's name, like:\n+    #\n+    #  (gdb) maint test-options require-delimiter -bool [TAB]\n+    #  off        on\n+    #\n+    # However, the completer does recognize them if you start typing\n+    # the boolean value.\n+    foreach value {\"0\" \"1\"} {\n+\ttest_completer_recognizes 1 \"$cmd -bool $value\"\n+    }\n+    foreach value {\"of\" \"off\"} {\n+\tres_test_gdb_complete_unique 1 \\\n+\t    \"$cmd -bool $value\" \\\n+\t    \"$cmd -bool off\"\n+    }\n+    foreach value {\"y\" \"ye\" \"yes\"} {\n+\tres_test_gdb_complete_unique 1 \\\n+\t    \"$cmd -bool $value\" \\\n+\t    \"$cmd -bool yes\"\n+    }\n+    foreach value {\"n\" \"no\"} {\n+\tres_test_gdb_complete_unique 1 \\\n+\t    \"$cmd -bool $value\" \\\n+\t    \"$cmd -bool no\"\n+    }\n+    foreach value {\n+\t\"e\"\n+\t\"en\"\n+\t\"ena\"\n+\t\"enab\"\n+\t\"enabl\"\n+\t\"enable\"\n+    } {\n+\tres_test_gdb_complete_unique 1 \\\n+\t    \"$cmd -bool $value\" \\\n+\t    \"$cmd -bool enable\"\n+    }\n+    foreach value {\n+\t\"d\"\n+\t\"di\"\n+\t\"dis\"\n+\t\"disa\"\n+\t\"disab\"\n+\t\"disabl\"\n+\t\"disable\"\n+    } {\n+\tres_test_gdb_complete_unique 1 \\\n+\t    \"$cmd -bool $value\" \\\n+\t    \"$cmd -bool disable\"\n+    }\n+\n+    if {$variant == \"require-delimiter\"} {\n+\tres_test_gdb_complete_none \"1\" \"$cmd -bool xxx\"\n+    } else {\n+\tres_test_gdb_complete_none \"0 xxx\" \"$cmd -bool xxx\"\n+    }\n+\n+    # The command accepts abbreviations of \"enable/disable/yes/no\",\n+    # even though we don't offer those for completion.\n+    foreach value {\n+\t\"1\"\n+\t\"y\" \"ye\" \"yes\"\n+\t\"e\"\n+\t\"en\"\n+\t\"ena\"\n+\t\"enab\"\n+\t\"enabl\"\n+\t\"enable\"} {\n+\tgdb_test \"$cmd -bool $value --\" [expect_bool \"\"]\n+    }\n+    foreach value {\n+\t\"0\"\n+\t\"of\" \"off\"\n+\t\"n\" \"no\"\n+\t\"d\"\n+\t\"di\"\n+\t\"dis\"\n+\t\"disa\"\n+\t\"disab\"\n+\t\"disabl\"\n+\t\"disable\"} {\n+\tgdb_test \"$cmd -bool $value --\" [expect_none \"\"]\n+    }\n+\n+    if {$variant == \"require-delimiter\"} {\n+\tgdb_test \"$cmd -bool 999\" [expect_none \"-bool 999\"]\n+    } else {\n+\tgdb_test \"$cmd -bool 999\" [expect_bool \"999\"]\n+    }\n+    gdb_test \"$cmd -bool -- 999\" [expect_bool \"999\"]\n+\n+    # Since \"on\" is implied after a boolean option, for\n+    # !require-delimiter commands, anything that is not\n+    # yes/no/1/0/on/off/enable/disable should be considered as the raw\n+    # input after the last option.  Also check \"o\", which might look\n+    # like \"on\" or \"off\", but it's treated the same.\n+\n+    foreach arg {\"xxx\" \"o\"} {\n+\tif {$variant == \"require-delimiter\"} {\n+\t    gdb_test \"$cmd -bool $arg\" [expect_none \"-bool $arg\"]\n+\t} else {\n+\t    gdb_test \"$cmd -bool $arg\" [expect_bool \"$arg\"]\n+\t}\n+    }\n+    # Also try -1.  \"unknown-is-error\" commands error out saying that\n+    # that's not a valid option.\n+    if {$variant == \"require-delimiter\"} {\n+\tgdb_test \"$cmd -bool -1\" \\\n+\t     [expect_none \"-bool -1\"]\n+    } elseif {$variant == \"unknown-is-error\"} {\n+\tgdb_test \"$cmd -bool -1\" \\\n+\t    \"Unrecognized option at: -1\"\n+    } else {\n+\tgdb_test \"$cmd -bool -1\" [expect_bool \"-1\"]\n+    }\n+\n+    # OTOH, if the \"--\" separator is present, then GDB errors out if\n+    # the boolean option is passed an invalid value -- check that too.\n+    gdb_test \"$cmd -bool -1 999 --\" \\\n+\t\"Unrecognized option at: -1 999 --\"\n+    gdb_test \"$cmd -bool xxx 999 --\" \\\n+\t\"Value given for `-bool' is not a boolean: xxx\"\n+    gdb_test \"$cmd -bool o 999 --\" \\\n+\t\"Value given for `-bool' is not a boolean: o\"\n+\n+    # Completing after a boolean option + \"o\" does list \"on/off\",\n+    # though.\n+    if {$variant == \"require-delimiter\"} {\n+\tres_test_gdb_complete_multiple 1 \"$cmd -bool \" \"o\" \"\" {\n+\t    \"off\"\n+\t    \"on\"\n+\t}\n+    } else {\n+\tres_test_gdb_complete_multiple \"0 o\" \"$cmd -bool \" \"o\" \"\" {\n+\t    \"off\"\n+\t    \"on\"\n+\t}\n+    }\n+}\n+\n+# Uinteger option tests.  OPTION is which integer option we're\n+# testing.  Can be \"uinteger\" or \"zuinteger-unlimited\".\n+proc_with_prefix test-uinteger {variant option} {\n+    global all_options\n+\n+    set cmd \"[make_cmd $variant] -$option\"\n+\n+    # Test completing a uinteger option:\n+    res_test_gdb_complete_multiple 1 \"$cmd \" \"\" \"\" {\n+\t\"NUMBER\"\n+\t\"unlimited\"\n+    }\n+\n+    # NUMBER above is just a placeholder, make sure we don't complete\n+    # it as a valid option.\n+    res_test_gdb_complete_none 1 \"$cmd NU\"\n+\n+    # \"unlimited\" is valid though.\n+    res_test_gdb_complete_unique 1 \\\n+\t\"$cmd u\" \\\n+\t\"$cmd unlimited\"\n+\n+    # Basic smoke test of accepted / not accepted values.\n+    gdb_test \"$cmd 1 -- 999\" [expect_integer $option \"1\" \"999\"]\n+    gdb_test \"$cmd unlimited -- 999\" \\\n+\t[expect_integer $option \"unlimited\" \"999\"]\n+    if {$option == \"zuinteger-unlimited\"} {\n+\tgdb_test \"$cmd -1 --\" [expect_integer $option \"unlimited\" \"\"]\n+\tgdb_test \"$cmd 0 --\" [expect_integer $option \"0\" \"\"]\n+    } else {\n+\tgdb_test \"$cmd -1 --\" \"integer -1 out of range\"\n+\tgdb_test \"$cmd 0 --\" [expect_integer $option \"unlimited\" \"\"]\n+    }\n+    gdb_test \"$cmd xxx --\" \\\n+\t\"Expected integer at: xxx --\"\n+    gdb_test \"$cmd unlimitedx --\" \\\n+\t\"Expected integer at: unlimitedx --\"\n+\n+    # Don't offer completions until we're past the\n+    # -uinteger/-zuinteger-unlimited argument.\n+    res_test_gdb_complete_none 1 \"$cmd 1\"\n+\n+    # A number of invalid values.\n+    foreach value {\"x\" \"x \" \"1a\" \"1a \" \"1-\" \"1- \" \"unlimitedx\"} {\n+\tres_test_gdb_complete_none 1 \"$cmd $value\"\n+    }\n+\n+    # Try \"-1\".\n+    if {$option == \"uinteger\"} {\n+\t# -1 is invalid uinteger.\n+\tforeach value {\"-1\" \"-1 \"} {\n+\t    res_test_gdb_complete_none 1 \"$cmd $value\"\n+\t}\n+    } else {\n+\t# -1 is valid for zuinteger-unlimited.\n+\tres_test_gdb_complete_none 1 \"$cmd -1\"\n+\tif {$variant == \"require-delimiter\"} {\n+\t    res_test_gdb_complete_multiple 1 \"$cmd -1 \" \"\" \"-\" $all_options\n+\t} else {\n+\t    res_test_gdb_complete_none \"0 \" \"$cmd -1 \"\n+\t}\n+    }\n+\n+    # Check that after a fully parsed option:\n+    #\n+    #  - for require-delimiter commands, completion offers all\n+    #    options.\n+    #\n+    #  - for !require-delimiter commands, completion offers nothing\n+    #    and returns false.\n+    if {$variant == \"require-delimiter\"} {\n+\tres_test_gdb_complete_multiple 1 \"$cmd 1 \" \"\" \"-\" $all_options\n+    } else {\n+\tres_test_gdb_complete_none \"0 \" \"$cmd 1 \"\n+    }\n+\n+    # Test completing non-option arguments after \"-uinteger 1 \".\n+    foreach operand {\"x\" \"x \" \"1a\" \"1a \" \"1-\" \"1- \"} {\n+\tif {$variant == \"require-delimiter\"} {\n+\t    res_test_gdb_complete_none 1 \"$cmd 1 $operand\"\n+\t} else {\n+\t    res_test_gdb_complete_none \"0 $operand\" \"$cmd 1 $operand\"\n+\t}\n+    }\n+    # These look like options, but they aren't.\n+    foreach operand {\"-1\" \"-1 \"} {\n+\tif {$variant == \"unknown-is-operand\"} {\n+\t    res_test_gdb_complete_none \"0 $operand\" \"$cmd 1 $operand\"\n+\t} else {\n+\t    res_test_gdb_complete_none 1 \"$cmd 1 $operand\"\n+\t}\n+    }\n+}\n+\n+# Enum option tests.\n+proc_with_prefix test-enum {variant} {\n+    set cmd [make_cmd $variant]\n+\n+    res_test_gdb_complete_multiple 1 \"$cmd -enum \" \"\" \"\" {\n+\t\"xxx\"\n+\t\"yyy\"\n+\t\"zzz\"\n+    }\n+\n+    # Check that \"-\" where a value is expected does not show the\n+    # command's options.  I.e., an enum's value is not optional.\n+    # Check both completion and running the command.\n+    res_test_gdb_complete_none 1 \"$cmd -enum -\"\n+    gdb_test \"$cmd -enum --\"\\\n+\t\"Requires an argument. Valid arguments are xxx, yyy, zzz\\\\.\"\n+\n+    # Try passing an undefined item to an enum option.\n+    gdb_test \"$cmd -enum www --\" \"Undefined item: \\\"www\\\".\"\n+}\n+\n+# Run the options framework tests first.\n+foreach_with_prefix cmd {\n+    \"require-delimiter\"\n+    \"unknown-is-error\"\n+    \"unknown-is-operand\"\n+} {\n+    test-misc $cmd\n+    test-flag $cmd\n+    test-boolean $cmd\n+    foreach subcmd {\"uinteger\" \"zuinteger-unlimited\" } {\n+\ttest-uinteger $cmd $subcmd\n+    }\n+    test-enum $cmd\n+}"
    }
  ]
}