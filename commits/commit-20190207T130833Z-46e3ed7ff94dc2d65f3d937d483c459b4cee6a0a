{
  "sha": "46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDZlM2VkN2ZmOTRkYzJkNjVmM2Q5MzdkNDgzYzQ1OWI0Y2VlNmEwYQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-02T21:35:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-02-07T13:08:33Z"
    },
    "message": "C++-ify struct thread_fsm\n\nThis C++-ifies struct thread_fsm, replacing the \"ops\" structure with\nvirtual methods, and changing all the implementations to derive from\nthread_fsm.\n\ngdb/ChangeLog\n2019-02-07  Tom Tromey  <tom@tromey.com>\n\n\t* thread.c (thread_cancel_execution_command): Update.\n\t* thread-fsm.h (struct thread_fsm): Add constructor, destructor,\n\tmethods.\n\t(struct thread_fsm_ops): Remove.\n\t(thread_fsm_ctor, thread_fsm_delete, thread_fsm_clean_up)\n\t(thread_fsm_should_stop, thread_fsm_return_value)\n\t(thread_fsm_set_finished, thread_fsm_finished_p)\n\t(thread_fsm_async_reply_reason, thread_fsm_should_notify_stop):\n\tDon't declare.\n\t* mi/mi-interp.c (mi_on_normal_stop_1): Update.\n\t* infrun.c (clear_proceed_status_thread)\n\t(clean_up_just_stopped_threads_fsms, fetch_inferior_event)\n\t(print_stop_event): Update.\n\t* infcmd.c (struct step_command_fsm): Inherit from thread_fsm.\n\tAdd constructor.\n\t(step_command_fsm_ops): Remove.\n\t(new_step_command_fsm): Remove.\n\t(step_1): Update.\n\t(step_command_fsm::should_stop): Rename from\n\tstep_command_fsm_should_stop.\n\t(step_command_fsm::clean_up): Rename from\n\tstep_command_fsm_clean_up.\n\t(step_command_fsm::do_async_reply_reason): Rename from\n\tstep_command_fsm_async_reply_reason.\n\t(struct until_next_fsm): Inherit from thread_fsm.  Add\n\tconstructor.\n\t(until_next_fsm_ops): Remove.\n\t(new_until_next_fsm): Remove.\n\t(until_next_fsm::should_stop): Rename from\n\tuntil_next_fsm_should_stop.\n\t(until_next_fsm::clean_up): Rename from until_next_fsm_clean_up.\n\t(until_next_fsm::do_async_reply_reason): Rename from\n\tuntil_next_fsm_async_reply_reason.\n\t(struct finish_command_fsm): Inherit from thread_fsm.  Add\n\tconstructor.  Change type of breakpoint.\n\t(finish_command_fsm_ops): Remove.\n\t(new_finish_command_fsm): Remove.\n\t(finish_command_fsm::should_stop): Rename from\n\tfinish_command_fsm_should_stop.\n\t(finish_command_fsm::clean_up): Rename from\n\tfinish_command_fsm_clean_up.\n\t(finish_command_fsm::return_value): Rename from\n\tfinish_command_fsm_return_value.\n\t(finish_command_fsm::do_async_reply_reason): Rename from\n\tfinish_command_fsm_async_reply_reason.\n\t(finish_command): Update.\n\t* infcall.c (struct call_thread_fsm): Inherit from thread_fsm.\n\tAdd constructor.\n\t(call_thread_fsm_ops): Remove.\n\t(call_thread_fsm::call_thread_fsm): Rename from\n\tnew_call_thread_fsm.\n\t(call_thread_fsm::should_stop): Rename from\n\tcall_thread_fsm_should_stop.\n\t(call_thread_fsm::should_notify_stop): Rename from\n\tcall_thread_fsm_should_notify_stop.\n\t(run_inferior_call, call_function_by_hand_dummy): Update.\n\t* cli/cli-interp.c (should_print_stop_to_console): Update.\n\t* breakpoint.c (struct until_break_fsm): Inherit from thread_fsm.\n\tAdd constructor.  Change type of location_breakpoint,\n\tcaller_breakpoint.\n\t(until_break_fsm_ops): Remove.\n\t(new_until_break_fsm): Remove.\n\t(until_break_fsm::should_stop): Rename from\n\tuntil_break_fsm_should_stop.\n\t(until_break_fsm::clean_up): Rename from\n\tuntil_break_fsm_clean_up.\n\t(until_break_fsm::do_async_reply_reason): Rename from\n\tuntil_break_fsm_async_reply_reason.\n\t(until_break_command): Update.\n\t* thread-fsm.c: Remove.\n\t* Makefile.in (COMMON_SFILES): Remove thread-fsm.c.",
    "tree": {
      "sha": "8bec2b571050d8809efbd5b4c863ee6862e4fee4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8bec2b571050d8809efbd5b4c863ee6862e4fee4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1a5c25988eabb35e0e40ea484b1eea029d9b7f53",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1a5c25988eabb35e0e40ea484b1eea029d9b7f53",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1a5c25988eabb35e0e40ea484b1eea029d9b7f53"
    }
  ],
  "stats": {
    "total": 775,
    "additions": 289,
    "deletions": 486
  },
  "files": [
    {
      "sha": "a714d50f50abb268dfa2a58accb82dc5c1bc9271",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 74,
      "deletions": 0,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -1,3 +1,77 @@\n+2019-02-07  Tom Tromey  <tom@tromey.com>\n+\n+\t* thread.c (thread_cancel_execution_command): Update.\n+\t* thread-fsm.h (struct thread_fsm): Add constructor, destructor,\n+\tmethods.\n+\t(struct thread_fsm_ops): Remove.\n+\t(thread_fsm_ctor, thread_fsm_delete, thread_fsm_clean_up)\n+\t(thread_fsm_should_stop, thread_fsm_return_value)\n+\t(thread_fsm_set_finished, thread_fsm_finished_p)\n+\t(thread_fsm_async_reply_reason, thread_fsm_should_notify_stop):\n+\tDon't declare.\n+\t* mi/mi-interp.c (mi_on_normal_stop_1): Update.\n+\t* infrun.c (clear_proceed_status_thread)\n+\t(clean_up_just_stopped_threads_fsms, fetch_inferior_event)\n+\t(print_stop_event): Update.\n+\t* infcmd.c (struct step_command_fsm): Inherit from thread_fsm.\n+\tAdd constructor.\n+\t(step_command_fsm_ops): Remove.\n+\t(new_step_command_fsm): Remove.\n+\t(step_1): Update.\n+\t(step_command_fsm::should_stop): Rename from\n+\tstep_command_fsm_should_stop.\n+\t(step_command_fsm::clean_up): Rename from\n+\tstep_command_fsm_clean_up.\n+\t(step_command_fsm::do_async_reply_reason): Rename from\n+\tstep_command_fsm_async_reply_reason.\n+\t(struct until_next_fsm): Inherit from thread_fsm.  Add\n+\tconstructor.\n+\t(until_next_fsm_ops): Remove.\n+\t(new_until_next_fsm): Remove.\n+\t(until_next_fsm::should_stop): Rename from\n+\tuntil_next_fsm_should_stop.\n+\t(until_next_fsm::clean_up): Rename from until_next_fsm_clean_up.\n+\t(until_next_fsm::do_async_reply_reason): Rename from\n+\tuntil_next_fsm_async_reply_reason.\n+\t(struct finish_command_fsm): Inherit from thread_fsm.  Add\n+\tconstructor.  Change type of breakpoint.\n+\t(finish_command_fsm_ops): Remove.\n+\t(new_finish_command_fsm): Remove.\n+\t(finish_command_fsm::should_stop): Rename from\n+\tfinish_command_fsm_should_stop.\n+\t(finish_command_fsm::clean_up): Rename from\n+\tfinish_command_fsm_clean_up.\n+\t(finish_command_fsm::return_value): Rename from\n+\tfinish_command_fsm_return_value.\n+\t(finish_command_fsm::do_async_reply_reason): Rename from\n+\tfinish_command_fsm_async_reply_reason.\n+\t(finish_command): Update.\n+\t* infcall.c (struct call_thread_fsm): Inherit from thread_fsm.\n+\tAdd constructor.\n+\t(call_thread_fsm_ops): Remove.\n+\t(call_thread_fsm::call_thread_fsm): Rename from\n+\tnew_call_thread_fsm.\n+\t(call_thread_fsm::should_stop): Rename from\n+\tcall_thread_fsm_should_stop.\n+\t(call_thread_fsm::should_notify_stop): Rename from\n+\tcall_thread_fsm_should_notify_stop.\n+\t(run_inferior_call, call_function_by_hand_dummy): Update.\n+\t* cli/cli-interp.c (should_print_stop_to_console): Update.\n+\t* breakpoint.c (struct until_break_fsm): Inherit from thread_fsm.\n+\tAdd constructor.  Change type of location_breakpoint,\n+\tcaller_breakpoint.\n+\t(until_break_fsm_ops): Remove.\n+\t(new_until_break_fsm): Remove.\n+\t(until_break_fsm::should_stop): Rename from\n+\tuntil_break_fsm_should_stop.\n+\t(until_break_fsm::clean_up): Rename from\n+\tuntil_break_fsm_clean_up.\n+\t(until_break_fsm::do_async_reply_reason): Rename from\n+\tuntil_break_fsm_async_reply_reason.\n+\t(until_break_command): Update.\n+\t* thread-fsm.c: Remove.\n+\t* Makefile.in (COMMON_SFILES): Remove thread-fsm.c.\n+\n 2019-02-07  Tom Tromey  <tom@tromey.com>\n \n \t* yy-remap.h: Add include guard."
    },
    {
      "sha": "cb5b7402308c85befee581ac98bb9184470a9eff",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -1122,7 +1122,6 @@ COMMON_SFILES = \\\n \ttest-target.c \\\n \tthread.c \\\n \tthread-iter.c \\\n-\tthread-fsm.c \\\n \ttid-parse.c \\\n \ttop.c \\\n \ttracefile.c \\"
    },
    {
      "sha": "bd05707d48f826ddb5cae92a5a4beacc06617166",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 33,
      "deletions": 75,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -10950,106 +10950,66 @@ awatch_command (const char *arg, int from_tty)\n    in infcmd.c.  Here because it uses the mechanisms of\n    breakpoints.  */\n \n-struct until_break_fsm\n+struct until_break_fsm : public thread_fsm\n {\n-  /* The base class.  */\n-  struct thread_fsm thread_fsm;\n-\n-  /* The thread that as current when the command was executed.  */\n+  /* The thread that was current when the command was executed.  */\n   int thread;\n \n   /* The breakpoint set at the destination location.  */\n-  struct breakpoint *location_breakpoint;\n+  breakpoint_up location_breakpoint;\n \n   /* Breakpoint set at the return address in the caller frame.  May be\n      NULL.  */\n-  struct breakpoint *caller_breakpoint;\n-};\n-\n-static void until_break_fsm_clean_up (struct thread_fsm *self,\n-\t\t\t\t      struct thread_info *thread);\n-static int until_break_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t\t\tstruct thread_info *thread);\n-static enum async_reply_reason\n-  until_break_fsm_async_reply_reason (struct thread_fsm *self);\n+  breakpoint_up caller_breakpoint;\n \n-/* until_break_fsm's vtable.  */\n+  until_break_fsm (struct interp *cmd_interp, int thread,\n+\t\t   breakpoint_up &&location_breakpoint,\n+\t\t   breakpoint_up &&caller_breakpoint)\n+    : thread_fsm (cmd_interp),\n+      thread (thread),\n+      location_breakpoint (std::move (location_breakpoint)),\n+      caller_breakpoint (std::move (caller_breakpoint))\n+  {\n+  }\n \n-static struct thread_fsm_ops until_break_fsm_ops =\n-{\n-  NULL, /* dtor */\n-  until_break_fsm_clean_up,\n-  until_break_fsm_should_stop,\n-  NULL, /* return_value */\n-  until_break_fsm_async_reply_reason,\n+  void clean_up (struct thread_info *thread) override;\n+  bool should_stop (struct thread_info *thread) override;\n+  enum async_reply_reason do_async_reply_reason () override;\n };\n \n-/* Allocate a new until_break_command_fsm.  */\n-\n-static struct until_break_fsm *\n-new_until_break_fsm (struct interp *cmd_interp, int thread,\n-\t\t     breakpoint_up &&location_breakpoint,\n-\t\t     breakpoint_up &&caller_breakpoint)\n-{\n-  struct until_break_fsm *sm;\n-\n-  sm = XCNEW (struct until_break_fsm);\n-  thread_fsm_ctor (&sm->thread_fsm, &until_break_fsm_ops, cmd_interp);\n-\n-  sm->thread = thread;\n-  sm->location_breakpoint = location_breakpoint.release ();\n-  sm->caller_breakpoint = caller_breakpoint.release ();\n-\n-  return sm;\n-}\n-\n /* Implementation of the 'should_stop' FSM method for the\n    until(location)/advance commands.  */\n \n-static int\n-until_break_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t     struct thread_info *tp)\n+bool\n+until_break_fsm::should_stop (struct thread_info *tp)\n {\n-  struct until_break_fsm *sm = (struct until_break_fsm *) self;\n-\n   if (bpstat_find_breakpoint (tp->control.stop_bpstat,\n-\t\t\t      sm->location_breakpoint) != NULL\n-      || (sm->caller_breakpoint != NULL\n+\t\t\t      location_breakpoint.get ()) != NULL\n+      || (caller_breakpoint != NULL\n \t  && bpstat_find_breakpoint (tp->control.stop_bpstat,\n-\t\t\t\t     sm->caller_breakpoint) != NULL))\n-    thread_fsm_set_finished (self);\n+\t\t\t\t     caller_breakpoint.get ()) != NULL))\n+    set_finished ();\n \n-  return 1;\n+  return true;\n }\n \n /* Implementation of the 'clean_up' FSM method for the\n    until(location)/advance commands.  */\n \n-static void\n-until_break_fsm_clean_up (struct thread_fsm *self,\n-\t\t\t  struct thread_info *thread)\n+void\n+until_break_fsm::clean_up (struct thread_info *)\n {\n-  struct until_break_fsm *sm = (struct until_break_fsm *) self;\n-\n   /* Clean up our temporary breakpoints.  */\n-  if (sm->location_breakpoint != NULL)\n-    {\n-      delete_breakpoint (sm->location_breakpoint);\n-      sm->location_breakpoint = NULL;\n-    }\n-  if (sm->caller_breakpoint != NULL)\n-    {\n-      delete_breakpoint (sm->caller_breakpoint);\n-      sm->caller_breakpoint = NULL;\n-    }\n-  delete_longjmp_breakpoint (sm->thread);\n+  location_breakpoint.reset ();\n+  caller_breakpoint.reset ();\n+  delete_longjmp_breakpoint (thread);\n }\n \n /* Implementation of the 'async_reply_reason' FSM method for the\n    until(location)/advance commands.  */\n \n-static enum async_reply_reason\n-until_break_fsm_async_reply_reason (struct thread_fsm *self)\n+enum async_reply_reason\n+until_break_fsm::do_async_reply_reason ()\n {\n   return EXEC_ASYNC_LOCATION_REACHED;\n }\n@@ -11063,7 +11023,6 @@ until_break_command (const char *arg, int from_tty, int anywhere)\n   struct frame_id caller_frame_id;\n   int thread;\n   struct thread_info *tp;\n-  struct until_break_fsm *sm;\n \n   clear_proceed_status (0);\n \n@@ -11142,10 +11101,9 @@ until_break_command (const char *arg, int from_tty, int anywhere)\n     location_breakpoint = set_momentary_breakpoint (frame_gdbarch, sal,\n \t\t\t\t\t\t    stack_frame_id, bp_until);\n \n-  sm = new_until_break_fsm (command_interp (), tp->global_num,\n-\t\t\t    std::move (location_breakpoint),\n-\t\t\t    std::move (caller_breakpoint));\n-  tp->thread_fsm = &sm->thread_fsm;\n+  tp->thread_fsm = new until_break_fsm (command_interp (), tp->global_num,\n+\t\t\t\t\tstd::move (location_breakpoint),\n+\t\t\t\t\tstd::move (caller_breakpoint));\n \n   if (lj_deleter)\n     lj_deleter->release ();"
    },
    {
      "sha": "088f4f1f89c0f870b9de5c7629002b01907691a0",
      "filename": "gdb/cli/cli-interp.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/cli/cli-interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/cli/cli-interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-interp.c?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -113,7 +113,7 @@ should_print_stop_to_console (struct interp *console_interp,\n        == BPSTAT_WHAT_STOP_NOISY)\n       || tp->thread_fsm == NULL\n       || tp->thread_fsm->command_interp == console_interp\n-      || !thread_fsm_finished_p (tp->thread_fsm))\n+      || !tp->thread_fsm->finished_p ())\n     return 1;\n   return 0;\n }"
    },
    {
      "sha": "e58ba849031df4edc14fdee3e5638b9f5a1d87fc",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 41,
      "deletions": 60,
      "changes": 101,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -470,106 +470,87 @@ get_call_return_value (struct call_return_meta_info *ri)\n /* Data for the FSM that manages an infcall.  It's main job is to\n    record the called function's return value.  */\n \n-struct call_thread_fsm\n+struct call_thread_fsm : public thread_fsm\n {\n-  /* The base class.  */\n-  struct thread_fsm thread_fsm;\n-\n   /* All the info necessary to be able to extract the return\n      value.  */\n   struct call_return_meta_info return_meta_info;\n \n   /* The called function's return value.  This is extracted from the\n      target before the dummy frame is popped.  */\n-  struct value *return_value;\n+  struct value *return_value = nullptr;\n \n   /* The top level that started the infcall (and is synchronously\n      waiting for it to end).  */\n   struct ui *waiting_ui;\n-};\n \n-static int call_thread_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t\t\tstruct thread_info *thread);\n-static int call_thread_fsm_should_notify_stop (struct thread_fsm *self);\n+  call_thread_fsm (struct ui *waiting_ui, struct interp *cmd_interp,\n+\t\t   struct gdbarch *gdbarch, struct value *function,\n+\t\t   struct type *value_type,\n+\t\t   int struct_return_p, CORE_ADDR struct_addr);\n \n-/* call_thread_fsm's vtable.  */\n+  bool should_stop (struct thread_info *thread) override;\n \n-static struct thread_fsm_ops call_thread_fsm_ops =\n-{\n-  NULL, /*dtor */\n-  NULL, /* clean_up */\n-  call_thread_fsm_should_stop,\n-  NULL, /* return_value */\n-  NULL, /* async_reply_reason*/\n-  call_thread_fsm_should_notify_stop,\n+  bool should_notify_stop () override;\n };\n \n /* Allocate a new call_thread_fsm object.  */\n \n-static struct call_thread_fsm *\n-new_call_thread_fsm (struct ui *waiting_ui, struct interp *cmd_interp,\n-\t\t     struct gdbarch *gdbarch, struct value *function,\n-\t\t     struct type *value_type,\n-\t\t     int struct_return_p, CORE_ADDR struct_addr)\n+call_thread_fsm::call_thread_fsm (struct ui *waiting_ui,\n+\t\t\t\t  struct interp *cmd_interp,\n+\t\t\t\t  struct gdbarch *gdbarch,\n+\t\t\t\t  struct value *function,\n+\t\t\t\t  struct type *value_type,\n+\t\t\t\t  int struct_return_p, CORE_ADDR struct_addr)\n+  : thread_fsm (cmd_interp),\n+    waiting_ui (waiting_ui)\n {\n-  struct call_thread_fsm *sm;\n-\n-  sm = XCNEW (struct call_thread_fsm);\n-  thread_fsm_ctor (&sm->thread_fsm, &call_thread_fsm_ops, cmd_interp);\n-\n-  sm->return_meta_info.gdbarch = gdbarch;\n-  sm->return_meta_info.function = function;\n-  sm->return_meta_info.value_type = value_type;\n-  sm->return_meta_info.struct_return_p = struct_return_p;\n-  sm->return_meta_info.struct_addr = struct_addr;\n-\n-  sm->waiting_ui = waiting_ui;\n-\n-  return sm;\n+  return_meta_info.gdbarch = gdbarch;\n+  return_meta_info.function = function;\n+  return_meta_info.value_type = value_type;\n+  return_meta_info.struct_return_p = struct_return_p;\n+  return_meta_info.struct_addr = struct_addr;\n }\n \n /* Implementation of should_stop method for infcalls.  */\n \n-static int\n-call_thread_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t     struct thread_info *thread)\n+bool\n+call_thread_fsm::should_stop (struct thread_info *thread)\n {\n-  struct call_thread_fsm *f = (struct call_thread_fsm *) self;\n-\n   if (stop_stack_dummy == STOP_STACK_DUMMY)\n     {\n       /* Done.  */\n-      thread_fsm_set_finished (self);\n+      set_finished ();\n \n       /* Stash the return value before the dummy frame is popped and\n \t registers are restored to what they were before the\n \t call..  */\n-      f->return_value = get_call_return_value (&f->return_meta_info);\n+      return_value = get_call_return_value (&return_meta_info);\n \n       /* Break out of wait_sync_command_done.  */\n-      scoped_restore save_ui = make_scoped_restore (&current_ui, f->waiting_ui);\n+      scoped_restore save_ui = make_scoped_restore (&current_ui, waiting_ui);\n       target_terminal::ours ();\n-      f->waiting_ui->prompt_state = PROMPT_NEEDED;\n+      waiting_ui->prompt_state = PROMPT_NEEDED;\n     }\n \n-  return 1;\n+  return true;\n }\n \n /* Implementation of should_notify_stop method for infcalls.  */\n \n-static int\n-call_thread_fsm_should_notify_stop (struct thread_fsm *self)\n+bool\n+call_thread_fsm::should_notify_stop ()\n {\n-  if (thread_fsm_finished_p (self))\n+  if (finished_p ())\n     {\n       /* Infcall succeeded.  Be silent and proceed with evaluating the\n \t expression.  */\n-      return 0;\n+      return false;\n     }\n \n   /* Something wrong happened.  E.g., an unexpected breakpoint\n      triggered, or a signal was intercepted.  Notify the stop.  */\n-  return 1;\n+  return true;\n }\n \n /* Subroutine of call_function_by_hand to simplify it.\n@@ -606,7 +587,7 @@ run_inferior_call (struct call_thread_fsm *sm,\n   /* Associate the FSM with the thread after clear_proceed_status\n      (otherwise it'd clear this FSM), and before anything throws, so\n      we don't leak it (and any resources it manages).  */\n-  call_thread->thread_fsm = &sm->thread_fsm;\n+  call_thread->thread_fsm = sm;\n \n   disable_watchpoints_before_interactive_call_start ();\n \n@@ -1139,7 +1120,7 @@ call_function_by_hand_dummy (struct value *function,\n        not report the stop to the user, and captures the return value\n        before the dummy frame is popped.  run_inferior_call registers\n        it with the thread ASAP.  */\n-    sm = new_call_thread_fsm (current_ui, command_interp (),\n+    sm = new call_thread_fsm (current_ui, command_interp (),\n \t\t\t      gdbarch, function,\n \t\t\t      values_type,\n \t\t\t      return_method != return_method_normal,\n@@ -1152,9 +1133,9 @@ call_function_by_hand_dummy (struct value *function,\n     if (call_thread->state != THREAD_EXITED)\n       {\n \t/* The FSM should still be the same.  */\n-\tgdb_assert (call_thread->thread_fsm == &sm->thread_fsm);\n+\tgdb_assert (call_thread->thread_fsm == sm);\n \n-\tif (thread_fsm_finished_p (call_thread->thread_fsm))\n+\tif (call_thread->thread_fsm->finished_p ())\n \t  {\n \t    struct value *retval;\n \n@@ -1170,8 +1151,8 @@ call_function_by_hand_dummy (struct value *function,\n \n \t    /* Clean up / destroy the call FSM, and restore the\n \t       original one.  */\n-\t    thread_fsm_clean_up (call_thread->thread_fsm, call_thread.get ());\n-\t    thread_fsm_delete (call_thread->thread_fsm);\n+\t    call_thread->thread_fsm->clean_up (call_thread.get ());\n+\t    delete call_thread->thread_fsm;\n \t    call_thread->thread_fsm = saved_sm;\n \n \t    maybe_remove_breakpoints ();\n@@ -1182,8 +1163,8 @@ call_function_by_hand_dummy (struct value *function,\n \n \t/* Didn't complete.  Clean up / destroy the call FSM, and restore the\n \t   previous state machine, and handle the error.  */\n-\tthread_fsm_clean_up (call_thread->thread_fsm, call_thread.get ());\n-\tthread_fsm_delete (call_thread->thread_fsm);\n+\tcall_thread->thread_fsm->clean_up (call_thread.get ());\n+\tdelete call_thread->thread_fsm;\n \tcall_thread->thread_fsm = saved_sm;\n       }\n   }"
    },
    {
      "sha": "c5977c48a90fd6bb2c0d7dd31037548a70d19e12",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 76,
      "deletions": 170,
      "changes": 246,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -950,11 +950,8 @@ nexti_command (const char *count_string, int from_tty)\n /* Data for the FSM that manages the step/next/stepi/nexti\n    commands.  */\n \n-struct step_command_fsm\n+struct step_command_fsm : public thread_fsm\n {\n-  /* The base class.  */\n-  struct thread_fsm thread_fsm;\n-\n   /* How many steps left in a \"step N\"-like command.  */\n   int count;\n \n@@ -963,39 +960,17 @@ struct step_command_fsm\n \n   /* If true, this is a stepi/nexti, otherwise a step/step.  */\n   int single_inst;\n-};\n \n-static void step_command_fsm_clean_up (struct thread_fsm *self,\n-\t\t\t\t       struct thread_info *thread);\n-static int step_command_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t\t\t struct thread_info *thread);\n-static enum async_reply_reason\n-  step_command_fsm_async_reply_reason (struct thread_fsm *self);\n-\n-/* step_command_fsm's vtable.  */\n+  explicit step_command_fsm (struct interp *cmd_interp)\n+    : thread_fsm (cmd_interp)\n+  {\n+  }\n \n-static struct thread_fsm_ops step_command_fsm_ops =\n-{\n-  NULL,\n-  step_command_fsm_clean_up,\n-  step_command_fsm_should_stop,\n-  NULL,\t/* return_value */\n-  step_command_fsm_async_reply_reason,\n+  void clean_up (struct thread_info *thread) override;\n+  bool should_stop (struct thread_info *thread) override;\n+  enum async_reply_reason do_async_reply_reason () override;\n };\n \n-/* Allocate a new step_command_fsm.  */\n-\n-static struct step_command_fsm *\n-new_step_command_fsm (struct interp *cmd_interp)\n-{\n-  struct step_command_fsm *sm;\n-\n-  sm = XCNEW (struct step_command_fsm);\n-  thread_fsm_ctor (&sm->thread_fsm, &step_command_fsm_ops, cmd_interp);\n-\n-  return sm;\n-}\n-\n /* Prepare for a step/next/etc. command.  Any target resource\n    allocated here is undone in the FSM's clean_up method.  */\n \n@@ -1043,8 +1018,8 @@ step_1 (int skip_subroutines, int single_inst, const char *count_string)\n   /* Setup the execution command state machine to handle all the COUNT\n      steps.  */\n   thr = inferior_thread ();\n-  step_sm = new_step_command_fsm (command_interp ());\n-  thr->thread_fsm = &step_sm->thread_fsm;\n+  step_sm = new step_command_fsm (command_interp ());\n+  thr->thread_fsm = step_sm;\n \n   step_command_fsm_prepare (step_sm, skip_subroutines,\n \t\t\t    single_inst, count, thr);\n@@ -1061,7 +1036,7 @@ step_1 (int skip_subroutines, int single_inst, const char *count_string)\n \n       /* Stepped into an inline frame.  Pretend that we've\n \t stopped.  */\n-      thread_fsm_clean_up (thr->thread_fsm, thr);\n+      thr->thread_fsm->clean_up (thr);\n       proceeded = normal_stop ();\n       if (!proceeded)\n \tinferior_event_handler (INF_EXEC_COMPLETE, NULL);\n@@ -1075,40 +1050,36 @@ step_1 (int skip_subroutines, int single_inst, const char *count_string)\n    return control to the user.  If count is > 1, returns false, as we\n    will need to keep going.  */\n \n-static int\n-step_command_fsm_should_stop (struct thread_fsm *self, struct thread_info *tp)\n+bool\n+step_command_fsm::should_stop (struct thread_info *tp)\n {\n-  struct step_command_fsm *sm = (struct step_command_fsm *) self;\n-\n   if (tp->control.stop_step)\n     {\n       /* There are more steps to make, and we did stop due to\n \t ending a stepping range.  Do another step.  */\n-      if (--sm->count > 0)\n-\treturn prepare_one_step (sm);\n+      if (--count > 0)\n+\treturn prepare_one_step (this);\n \n-      thread_fsm_set_finished (self);\n+      set_finished ();\n     }\n \n-  return 1;\n+  return true;\n }\n \n /* Implementation of the 'clean_up' FSM method for stepping commands.  */\n \n-static void\n-step_command_fsm_clean_up (struct thread_fsm *self, struct thread_info *thread)\n+void\n+step_command_fsm::clean_up (struct thread_info *thread)\n {\n-  struct step_command_fsm *sm = (struct step_command_fsm *) self;\n-\n-  if (!sm->single_inst || sm->skip_subroutines)\n+  if (!single_inst || skip_subroutines)\n     delete_longjmp_breakpoint (thread->global_num);\n }\n \n /* Implementation of the 'async_reply_reason' FSM method for stepping\n    commands.  */\n \n-static enum async_reply_reason\n-step_command_fsm_async_reply_reason (struct thread_fsm *self)\n+enum async_reply_reason\n+step_command_fsm::do_async_reply_reason ()\n {\n   return EXEC_ASYNC_END_STEPPING_RANGE;\n }\n@@ -1198,7 +1169,7 @@ prepare_one_step (struct step_command_fsm *sm)\n     }\n \n   /* Done.  */\n-  thread_fsm_set_finished (&sm->thread_fsm);\n+  sm->set_finished ();\n   return 1;\n }\n \n@@ -1420,75 +1391,48 @@ queue_signal_command (const char *signum_exp, int from_tty)\n /* Data for the FSM that manages the until (with no argument)\n    command.  */\n \n-struct until_next_fsm\n+struct until_next_fsm : public thread_fsm\n {\n-  /* The base class.  */\n-  struct thread_fsm thread_fsm;\n-\n   /* The thread that as current when the command was executed.  */\n   int thread;\n-};\n-\n-static int until_next_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t\t       struct thread_info *thread);\n-static void until_next_fsm_clean_up (struct thread_fsm *self,\n-\t\t\t\t     struct thread_info *thread);\n-static enum async_reply_reason\n-  until_next_fsm_async_reply_reason (struct thread_fsm *self);\n \n-/* until_next_fsm's vtable.  */\n+  until_next_fsm (struct interp *cmd_interp, int thread)\n+    : thread_fsm (cmd_interp),\n+      thread (thread)\n+  {\n+  }\n \n-static struct thread_fsm_ops until_next_fsm_ops =\n-{\n-  NULL, /* dtor */\n-  until_next_fsm_clean_up,\n-  until_next_fsm_should_stop,\n-  NULL, /* return_value */\n-  until_next_fsm_async_reply_reason,\n+  bool should_stop (struct thread_info *thread) override;\n+  void clean_up (struct thread_info *thread) override;\n+  enum async_reply_reason do_async_reply_reason () override;\n };\n \n-/* Allocate a new until_next_fsm.  */\n-\n-static struct until_next_fsm *\n-new_until_next_fsm (struct interp *cmd_interp, int thread)\n-{\n-  struct until_next_fsm *sm;\n-\n-  sm = XCNEW (struct until_next_fsm);\n-  thread_fsm_ctor (&sm->thread_fsm, &until_next_fsm_ops, cmd_interp);\n-\n-  sm->thread = thread;\n-\n-  return sm;\n-}\n-\n /* Implementation of the 'should_stop' FSM method for the until (with\n    no arg) command.  */\n \n-static int\n-until_next_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t    struct thread_info *tp)\n+bool\n+until_next_fsm::should_stop (struct thread_info *tp)\n {\n   if (tp->control.stop_step)\n-    thread_fsm_set_finished (self);\n+    set_finished ();\n \n-  return 1;\n+  return true;\n }\n \n /* Implementation of the 'clean_up' FSM method for the until (with no\n    arg) command.  */\n \n-static void\n-until_next_fsm_clean_up (struct thread_fsm *self, struct thread_info *thread)\n+void\n+until_next_fsm::clean_up (struct thread_info *thread)\n {\n   delete_longjmp_breakpoint (thread->global_num);\n }\n \n /* Implementation of the 'async_reply_reason' FSM method for the until\n    (with no arg) command.  */\n \n-static enum async_reply_reason\n-until_next_fsm_async_reply_reason (struct thread_fsm *self)\n+enum async_reply_reason\n+until_next_fsm::do_async_reply_reason ()\n {\n   return EXEC_ASYNC_END_STEPPING_RANGE;\n }\n@@ -1550,8 +1494,8 @@ until_next_command (int from_tty)\n   set_longjmp_breakpoint (tp, get_frame_id (frame));\n   delete_longjmp_breakpoint_cleanup lj_deleter (thread);\n \n-  sm = new_until_next_fsm (command_interp (), tp->global_num);\n-  tp->thread_fsm = &sm->thread_fsm;\n+  sm = new until_next_fsm (command_interp (), tp->global_num);\n+  tp->thread_fsm = sm;\n   lj_deleter.release ();\n \n   proceed ((CORE_ADDR) -1, GDB_SIGNAL_DEFAULT);\n@@ -1718,77 +1662,48 @@ print_return_value (struct ui_out *uiout, struct return_value_info *rv)\n \n /* Data for the FSM that manages the finish command.  */\n \n-struct finish_command_fsm\n+struct finish_command_fsm : public thread_fsm\n {\n-  /* The base class.  */\n-  struct thread_fsm thread_fsm;\n-\n   /* The momentary breakpoint set at the function's return address in\n      the caller.  */\n-  struct breakpoint *breakpoint;\n+  breakpoint_up breakpoint;\n \n   /* The function that we're stepping out of.  */\n-  struct symbol *function;\n+  struct symbol *function = nullptr;\n \n   /* If the FSM finishes successfully, this stores the function's\n      return value.  */\n-  struct return_value_info return_value;\n-};\n+  struct return_value_info return_value_info {};\n \n-static int finish_command_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t\t\t   struct thread_info *thread);\n-static void finish_command_fsm_clean_up (struct thread_fsm *self,\n-\t\t\t\t\t struct thread_info *thread);\n-static struct return_value_info *\n-  finish_command_fsm_return_value (struct thread_fsm *self);\n-static enum async_reply_reason\n-  finish_command_fsm_async_reply_reason (struct thread_fsm *self);\n-\n-/* finish_command_fsm's vtable.  */\n-\n-static struct thread_fsm_ops finish_command_fsm_ops =\n-{\n-  NULL, /* dtor */\n-  finish_command_fsm_clean_up,\n-  finish_command_fsm_should_stop,\n-  finish_command_fsm_return_value,\n-  finish_command_fsm_async_reply_reason,\n-  NULL, /* should_notify_stop */\n-};\n-\n-/* Allocate a new finish_command_fsm.  */\n-\n-static struct finish_command_fsm *\n-new_finish_command_fsm (struct interp *cmd_interp)\n-{\n-  struct finish_command_fsm *sm;\n-\n-  sm = XCNEW (struct finish_command_fsm);\n-  thread_fsm_ctor (&sm->thread_fsm, &finish_command_fsm_ops, cmd_interp);\n+  explicit finish_command_fsm (struct interp *cmd_interp)\n+    : thread_fsm (cmd_interp)\n+  {\n+  }\n \n-  return sm;\n-}\n+  bool should_stop (struct thread_info *thread) override;\n+  void clean_up (struct thread_info *thread) override;\n+  struct return_value_info *return_value () override;\n+  enum async_reply_reason do_async_reply_reason () override;\n+};\n \n /* Implementation of the 'should_stop' FSM method for the finish\n    commands.  Detects whether the thread stepped out of the function\n    successfully, and if so, captures the function's return value and\n    marks the FSM finished.  */\n \n-static int\n-finish_command_fsm_should_stop (struct thread_fsm *self,\n-\t\t\t\tstruct thread_info *tp)\n+bool\n+finish_command_fsm::should_stop (struct thread_info *tp)\n {\n-  struct finish_command_fsm *f = (struct finish_command_fsm *) self;\n-  struct return_value_info *rv = &f->return_value;\n+  struct return_value_info *rv = &return_value_info;\n \n-  if (f->function != NULL\n+  if (function != NULL\n       && bpstat_find_breakpoint (tp->control.stop_bpstat,\n-\t\t\t\t f->breakpoint) != NULL)\n+\t\t\t\t breakpoint.get ()) != NULL)\n     {\n       /* We're done.  */\n-      thread_fsm_set_finished (self);\n+      set_finished ();\n \n-      rv->type = TYPE_TARGET_TYPE (SYMBOL_TYPE (f->function));\n+      rv->type = TYPE_TARGET_TYPE (SYMBOL_TYPE (function));\n       if (rv->type == NULL)\n \tinternal_error (__FILE__, __LINE__,\n \t\t\t_(\"finish_command: function has no target type\"));\n@@ -1797,7 +1712,7 @@ finish_command_fsm_should_stop (struct thread_fsm *self,\n \t{\n \t  struct value *func;\n \n-\t  func = read_var_value (f->function, NULL, get_current_frame ());\n+\t  func = read_var_value (function, NULL, get_current_frame ());\n \t  rv->value = get_return_value (func, rv->type);\n \t  if (rv->value != NULL)\n \t    rv->value_history_index = record_latest_value (rv->value);\n@@ -1807,45 +1722,36 @@ finish_command_fsm_should_stop (struct thread_fsm *self,\n     {\n       /* Finishing from an inline frame, or reverse finishing.  In\n \t either case, there's no way to retrieve the return value.  */\n-      thread_fsm_set_finished (self);\n+      set_finished ();\n     }\n \n-  return 1;\n+  return true;\n }\n \n /* Implementation of the 'clean_up' FSM method for the finish\n    commands.  */\n \n-static void\n-finish_command_fsm_clean_up (struct thread_fsm *self,\n-\t\t\t     struct thread_info *thread)\n+void\n+finish_command_fsm::clean_up (struct thread_info *thread)\n {\n-  struct finish_command_fsm *f = (struct finish_command_fsm *) self;\n-\n-  if (f->breakpoint != NULL)\n-    {\n-      delete_breakpoint (f->breakpoint);\n-      f->breakpoint = NULL;\n-    }\n+  breakpoint.reset ();\n   delete_longjmp_breakpoint (thread->global_num);\n }\n \n /* Implementation of the 'return_value' FSM method for the finish\n    commands.  */\n \n-static struct return_value_info *\n-finish_command_fsm_return_value (struct thread_fsm *self)\n+struct return_value_info *\n+finish_command_fsm::return_value ()\n {\n-  struct finish_command_fsm *f = (struct finish_command_fsm *) self;\n-\n-  return &f->return_value;\n+  return &return_value_info;\n }\n \n /* Implementation of the 'async_reply_reason' FSM method for the\n    finish commands.  */\n \n-static enum async_reply_reason\n-finish_command_fsm_async_reply_reason (struct thread_fsm *self)\n+enum async_reply_reason\n+finish_command_fsm::do_async_reply_reason ()\n {\n   if (execution_direction == EXEC_REVERSE)\n     return EXEC_ASYNC_END_STEPPING_RANGE;\n@@ -1920,7 +1826,7 @@ finish_forward (struct finish_command_fsm *sm, struct frame_info *frame)\n \n   sm->breakpoint = set_momentary_breakpoint (gdbarch, sal,\n \t\t\t\t\t     get_stack_frame_id (frame),\n-\t\t\t\t\t     bp_finish).release ();\n+\t\t\t\t\t     bp_finish);\n \n   /* set_momentary_breakpoint invalidates FRAME.  */\n   frame = NULL;\n@@ -1990,9 +1896,9 @@ finish_command (const char *arg, int from_tty)\n \n   tp = inferior_thread ();\n \n-  sm = new_finish_command_fsm (command_interp ());\n+  sm = new finish_command_fsm (command_interp ());\n \n-  tp->thread_fsm = &sm->thread_fsm;\n+  tp->thread_fsm = sm;\n \n   /* Finishing from an inline frame is completely different.  We don't\n      try to show the \"return value\" - no way to locate it.  */"
    },
    {
      "sha": "b32635fc422da0a22c2e50a3f3d30074ccd61c42",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -2710,7 +2710,7 @@ clear_proceed_status_thread (struct thread_info *tp)\n   if (!signal_pass_state (tp->suspend.stop_signal))\n     tp->suspend.stop_signal = GDB_SIGNAL_0;\n \n-  thread_fsm_delete (tp->thread_fsm);\n+  delete tp->thread_fsm;\n   tp->thread_fsm = NULL;\n \n   tp->control.trap_expected = 0;\n@@ -3610,8 +3610,7 @@ clean_up_just_stopped_threads_fsms (struct execution_control_state *ecs)\n {\n   if (ecs->event_thread != NULL\n       && ecs->event_thread->thread_fsm != NULL)\n-    thread_fsm_clean_up (ecs->event_thread->thread_fsm,\n-\t\t\t ecs->event_thread);\n+    ecs->event_thread->thread_fsm->clean_up (ecs->event_thread);\n \n   if (!non_stop)\n     {\n@@ -3623,7 +3622,7 @@ clean_up_just_stopped_threads_fsms (struct execution_control_state *ecs)\n \t    continue;\n \n \t  switch_to_thread (thr);\n-\t  thread_fsm_clean_up (thr->thread_fsm, thr);\n+\t  thr->thread_fsm->clean_up (thr);\n \t}\n \n       if (ecs->event_thread != NULL)\n@@ -3766,7 +3765,7 @@ fetch_inferior_event (void *client_data)\n \t    struct thread_fsm *thread_fsm = thr->thread_fsm;\n \n \t    if (thread_fsm != NULL)\n-\t      should_stop = thread_fsm_should_stop (thread_fsm, thr);\n+\t      should_stop = thread_fsm->should_stop (thr);\n \t  }\n \n \tif (!should_stop)\n@@ -3775,16 +3774,13 @@ fetch_inferior_event (void *client_data)\n \t  }\n \telse\n \t  {\n-\t    int should_notify_stop = 1;\n+\t    bool should_notify_stop = true;\n \t    int proceeded = 0;\n \n \t    clean_up_just_stopped_threads_fsms (ecs);\n \n \t    if (thr != NULL && thr->thread_fsm != NULL)\n-\t      {\n-\t\tshould_notify_stop\n-\t\t  = thread_fsm_should_notify_stop (thr->thread_fsm);\n-\t      }\n+\t      should_notify_stop = thr->thread_fsm->should_notify_stop ();\n \n \t    if (should_notify_stop)\n \t      {\n@@ -7886,11 +7882,11 @@ print_stop_event (struct ui_out *uiout)\n \n   tp = inferior_thread ();\n   if (tp->thread_fsm != NULL\n-      && thread_fsm_finished_p (tp->thread_fsm))\n+      && tp->thread_fsm->finished_p ())\n     {\n       struct return_value_info *rv;\n \n-      rv = thread_fsm_return_value (tp->thread_fsm);\n+      rv = tp->thread_fsm->return_value ();\n       if (rv != NULL)\n \tprint_return_value (uiout, rv);\n     }"
    },
    {
      "sha": "3e9f36897a862ae55fd05f89c7eb18e2d0e85853",
      "filename": "gdb/mi/mi-interp.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/mi/mi-interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/mi/mi-interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-interp.c?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -632,11 +632,11 @@ mi_on_normal_stop_1 (struct bpstats *bs, int print_frame)\n       tp = inferior_thread ();\n \n       if (tp->thread_fsm != NULL\n-\t  && thread_fsm_finished_p (tp->thread_fsm))\n+\t  && tp->thread_fsm->finished_p ())\n \t{\n \t  enum async_reply_reason reason;\n \n-\t  reason = thread_fsm_async_reply_reason (tp->thread_fsm);\n+\t  reason = tp->thread_fsm->async_reply_reason ();\n \t  mi_uiout->field_string (\"reason\", async_reason_lookup (reason));\n \t}\n       print_stop_event (mi_uiout);"
    },
    {
      "sha": "1f0eed71a08ed874cf7e42c648563f6ee95be0b2",
      "filename": "gdb/thread-fsm.c",
      "status": "removed",
      "additions": 0,
      "deletions": 109,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1a5c25988eabb35e0e40ea484b1eea029d9b7f53/gdb/thread-fsm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1a5c25988eabb35e0e40ea484b1eea029d9b7f53/gdb/thread-fsm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread-fsm.c?ref=1a5c25988eabb35e0e40ea484b1eea029d9b7f53",
      "patch": "@@ -1,109 +0,0 @@\n-/* Thread command's finish-state machine, for GDB, the GNU debugger.\n-   Copyright (C) 2015-2019 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"defs.h\"\n-#include \"thread-fsm.h\"\n-\n-/* See thread-fsm.h.  */\n-\n-void\n-thread_fsm_ctor (struct thread_fsm *self, struct thread_fsm_ops *ops,\n-\t\t struct interp *cmd_interp)\n-{\n-  self->command_interp = cmd_interp;\n-  self->finished = 0;\n-  self->ops = ops;\n-}\n-\n-/* See thread-fsm.h.  */\n-\n-void\n-thread_fsm_delete (struct thread_fsm *self)\n-{\n-  if (self != NULL)\n-    {\n-      if (self->ops->dtor != NULL)\n-\tself->ops->dtor (self);\n-      xfree (self);\n-    }\n-}\n-\n-/* See thread-fsm.h.  */\n-\n-void\n-thread_fsm_clean_up (struct thread_fsm *self, struct thread_info *thread)\n-{\n-  if (self->ops->clean_up != NULL)\n-    self->ops->clean_up (self, thread);\n-}\n-\n-/* See thread-fsm.h.  */\n-\n-int\n-thread_fsm_should_stop (struct thread_fsm *self, struct thread_info *thread)\n-{\n-  return self->ops->should_stop (self, thread);\n-}\n-\n-/* See thread-fsm.h.  */\n-\n-struct return_value_info *\n-thread_fsm_return_value (struct thread_fsm *self)\n-{\n-  if (self->ops->return_value != NULL)\n-    return self->ops->return_value (self);\n-  return NULL;\n-}\n-\n-/* See thread-fsm.h.  */\n-\n-void\n-thread_fsm_set_finished (struct thread_fsm *self)\n-{\n-  self->finished = 1;\n-}\n-\n-/* See thread-fsm.h.  */\n-\n-int\n-thread_fsm_finished_p (struct thread_fsm *self)\n-{\n-  return self->finished;\n-}\n-\n-/* See thread-fsm.h.  */\n-\n-enum async_reply_reason\n-thread_fsm_async_reply_reason (struct thread_fsm *self)\n-{\n-  /* If we didn't finish, then the stop reason must come from\n-     elsewhere.  E.g., a breakpoint hit or a signal intercepted.  */\n-  gdb_assert (thread_fsm_finished_p (self));\n-\n-  return self->ops->async_reply_reason (self);\n-}\n-\n-/* See thread-fsm.h.  */\n-\n-int\n-thread_fsm_should_notify_stop (struct thread_fsm *self)\n-{\n-  if (self->ops->should_notify_stop != NULL)\n-    return self->ops->should_notify_stop (self);\n-  return 1;\n-}"
    },
    {
      "sha": "57837bfdfb1380d3d517964054ab78b16ca7a877",
      "filename": "gdb/thread-fsm.h",
      "status": "modified",
      "additions": 52,
      "deletions": 54,
      "changes": 106,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/thread-fsm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/thread-fsm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread-fsm.h?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -30,34 +30,24 @@ struct thread_fsm_ops;\n \n struct thread_fsm\n {\n-  /* Pointer of the virtual table of methods.  */\n-  struct thread_fsm_ops *ops;\n+  explicit thread_fsm (struct interp *cmd_interp)\n+    : command_interp (cmd_interp)\n+  {\n+  }\n \n-  /* Whether the FSM is done successfully.  */\n-  int finished;\n-\n-  /* The interpreter that issued the execution command that caused\n-     this thread to resume.  If the top level interpreter is MI/async,\n-     and the execution command was a CLI command (next/step/etc.),\n-     we'll want to print stop event output to the MI console channel\n-     (the stepped-to line, etc.), as if the user entered the execution\n-     command on a real GDB console.  */\n-  struct interp *command_interp;\n-};\n-\n-/* The virtual table of a thread_fsm.  */\n-\n-struct thread_fsm_ops\n-{\n   /* The destructor.  This should simply free heap allocated data\n      structures.  Cleaning up target resources (like, e.g.,\n      breakpoints) should be done in the clean_up method.  */\n-  void (*dtor) (struct thread_fsm *self);\n+  virtual ~thread_fsm () = default;\n+\n+  DISABLE_COPY_AND_ASSIGN (thread_fsm);\n \n   /* Called to clean up target resources after the FSM.  E.g., if the\n      FSM created internal breakpoints, this is where they should be\n      deleted.  */\n-  void (*clean_up) (struct thread_fsm *self, struct thread_info *thread);\n+  virtual void clean_up (struct thread_info *thread)\n+  {\n+  }\n \n   /* Called after handle_inferior_event decides the target is done\n      (that is, after stop_waiting).  The FSM is given a chance to\n@@ -66,50 +56,58 @@ struct thread_fsm_ops\n      should be re-resumed.  This is a good place to cache target data\n      too.  For example, the \"finish\" command saves the just-finished\n      function's return value here.  */\n-  int (*should_stop) (struct thread_fsm *self, struct thread_info *thread);\n+  virtual bool should_stop (struct thread_info *thread) = 0;\n \n   /* If this FSM saved a function's return value, you can use this\n      method to retrieve it.  Otherwise, this returns NULL.  */\n-  struct return_value_info *(*return_value) (struct thread_fsm *self);\n-\n-  /* The async_reply_reason that is broadcast to MI clients if this\n-     FSM finishes successfully.  */\n-  enum async_reply_reason (*async_reply_reason) (struct thread_fsm *self);\n+  virtual struct return_value_info *return_value ()\n+  {\n+    return nullptr;\n+  }\n+\n+  enum async_reply_reason async_reply_reason ()\n+  {\n+    /* If we didn't finish, then the stop reason must come from\n+       elsewhere.  E.g., a breakpoint hit or a signal intercepted.  */\n+    gdb_assert (finished_p ());\n+    return do_async_reply_reason ();\n+  }\n \n   /* Whether the stop should be notified to the user/frontend.  */\n-  int (*should_notify_stop) (struct thread_fsm *self);\n-};\n-/* Initialize FSM.  */\n-extern void thread_fsm_ctor (struct thread_fsm *self,\n-\t\t\t     struct thread_fsm_ops *ops,\n-\t\t\t     struct interp *cmd_interp);\n-\n-/* Calls the FSM's dtor method, and then frees FSM.  */\n-extern void thread_fsm_delete (struct thread_fsm *fsm);\n-\n-/* Calls the FSM's clean_up method.  */\n-extern void thread_fsm_clean_up (struct thread_fsm *fsm,\n-\t\t\t\t struct thread_info *thread);\n+  virtual bool should_notify_stop ()\n+  {\n+    return true;\n+  }\n \n-/* Calls the FSM's should_stop method.  */\n-extern int thread_fsm_should_stop (struct thread_fsm *fsm,\n-\t\t\t\t   struct thread_info *thread);\n+  void set_finished ()\n+  {\n+    finished = true;\n+  }\n \n-/* Calls the FSM's return_value method.  */\n-extern struct return_value_info *\n-  thread_fsm_return_value (struct thread_fsm *fsm);\n+  bool finished_p () const\n+  {\n+    return finished;\n+  }\n \n-/* Marks the FSM as completed successfully.  */\n-extern void thread_fsm_set_finished (struct thread_fsm *fsm);\n+  /* The interpreter that issued the execution command that caused\n+     this thread to resume.  If the top level interpreter is MI/async,\n+     and the execution command was a CLI command (next/step/etc.),\n+     we'll want to print stop event output to the MI console channel\n+     (the stepped-to line, etc.), as if the user entered the execution\n+     command on a real GDB console.  */\n+  struct interp *command_interp = nullptr;\n \n-/* Returns true if the FSM completed successfully.  */\n-extern int thread_fsm_finished_p (struct thread_fsm *fsm);\n+protected:\n \n-/* Calls the FSM's reply_reason method.  */\n-extern enum async_reply_reason\n-  thread_fsm_async_reply_reason (struct thread_fsm *fsm);\n+  /* Whether the FSM is done successfully.  */\n+  bool finished = false;\n \n-/* Calls the FSM's should_notify_stop method.  */\n-extern int thread_fsm_should_notify_stop (struct thread_fsm *self);\n+  /* The async_reply_reason that is broadcast to MI clients if this\n+     FSM finishes successfully.  */\n+  virtual enum async_reply_reason do_async_reply_reason ()\n+  {\n+    gdb_assert_not_reached (_(\"should not call async_reply_reason here\"));\n+  }\n+};\n \n #endif /* THREAD_FSM_H */"
    },
    {
      "sha": "6c232529646d7a287e14a76f03bc68bae4c5e2e3",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=46e3ed7ff94dc2d65f3d937d483c459b4cee6a0a",
      "patch": "@@ -170,8 +170,8 @@ thread_cancel_execution_command (struct thread_info *thr)\n {\n   if (thr->thread_fsm != NULL)\n     {\n-      thread_fsm_clean_up (thr->thread_fsm, thr);\n-      thread_fsm_delete (thr->thread_fsm);\n+      thr->thread_fsm->clean_up (thr);\n+      delete thr->thread_fsm;\n       thr->thread_fsm = NULL;\n     }\n }"
    }
  ]
}