{
  "sha": "cd6c91b4f8c429d49a103c3ad45ee741e41bd835",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2Q2YzkxYjRmOGM0MjlkNDlhMTAzYzNhZDQ1ZWU3NDFlNDFiZDgzNQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:56Z"
    },
    "message": "Change some attribute functions to be methods\n\nThis changes most of the attribute-related functions to be methods.\n(attr_form_is_block changed in a subsequent patch.)\n\ngdb/ChangeLog\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2read.c (dwarf2_find_base_address, )\n\t(read_call_site_scope, rust_containing_type)\n\t(dwarf2_get_pc_bounds, dwarf2_record_block_ranges)\n\t(handle_data_member_location, dwarf2_add_member_fn)\n\t(get_alignment, read_structure_type, process_structure_scope)\n\t(mark_common_block_symbol_computed, read_common_block)\n\t(read_tag_string_type, attr_to_dynamic_prop, read_subrange_type)\n\t(partial_die_info::read, read_attribute_value, new_symbol)\n\t(lookup_die_type, dwarf2_get_ref_die_offset)\n\t(dwarf2_get_attr_constant_value, follow_die_ref_or_sig)\n\t(dwarf2_fetch_die_loc_sect_off, get_DW_AT_signature_type)\n\t(dwarf2_symbol_mark_computed): Update.\n\t* dwarf2/attribute.h (struct attribute) <value_as_address,\n\tform_is_section_offset, form_is_constant, form_is_ref>: Declare\n\tmethods.\n\t(value_as_address, attr_form_is_section_offset)\n\t(attr_form_is_constant, attr_form_is_ref): Don't declare.\n\t* dwarf2/attribute.c (attribute::value_as_address)\n\t(attribute::form_is_section_offset, attribute::form_is_constant)\n\t(attribute::form_is_ref): Now methods.\n\nChange-Id: I320dad13002c59b848dc86c39d5d7111c8a15bdc",
    "tree": {
      "sha": "778005fe8ec6c91d7808b5b717868b535187e764",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/778005fe8ec6c91d7808b5b717868b535187e764"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cd6c91b4f8c429d49a103c3ad45ee741e41bd835",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cd6c91b4f8c429d49a103c3ad45ee741e41bd835",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cd6c91b4f8c429d49a103c3ad45ee741e41bd835",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "162dce5526debd7fbc3a4516c37ee6178bab6e5b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/162dce5526debd7fbc3a4516c37ee6178bab6e5b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/162dce5526debd7fbc3a4516c37ee6178bab6e5b"
    }
  ],
  "stats": {
    "total": 229,
    "additions": 126,
    "deletions": 103
  },
  "files": [
    {
      "sha": "331fad469059953c254a9678c679fea544074f4a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=cd6c91b4f8c429d49a103c3ad45ee741e41bd835",
      "patch": "@@ -1,3 +1,26 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2read.c (dwarf2_find_base_address, )\n+\t(read_call_site_scope, rust_containing_type)\n+\t(dwarf2_get_pc_bounds, dwarf2_record_block_ranges)\n+\t(handle_data_member_location, dwarf2_add_member_fn)\n+\t(get_alignment, read_structure_type, process_structure_scope)\n+\t(mark_common_block_symbol_computed, read_common_block)\n+\t(read_tag_string_type, attr_to_dynamic_prop, read_subrange_type)\n+\t(partial_die_info::read, read_attribute_value, new_symbol)\n+\t(lookup_die_type, dwarf2_get_ref_die_offset)\n+\t(dwarf2_get_attr_constant_value, follow_die_ref_or_sig)\n+\t(dwarf2_fetch_die_loc_sect_off, get_DW_AT_signature_type)\n+\t(dwarf2_symbol_mark_computed): Update.\n+\t* dwarf2/attribute.h (struct attribute) <value_as_address,\n+\tform_is_section_offset, form_is_constant, form_is_ref>: Declare\n+\tmethods.\n+\t(value_as_address, attr_form_is_section_offset)\n+\t(attr_form_is_constant, attr_form_is_ref): Don't declare.\n+\t* dwarf2/attribute.c (attribute::value_as_address)\n+\t(attribute::form_is_section_offset, attribute::form_is_constant)\n+\t(attribute::form_is_ref): Now methods.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2read.c (struct attribute, DW_STRING)"
    },
    {
      "sha": "6e51fff53624982004700c1a4469bcb5f6978984",
      "filename": "gdb/dwarf2/attribute.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/gdb/dwarf2/attribute.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/gdb/dwarf2/attribute.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.c?ref=cd6c91b4f8c429d49a103c3ad45ee741e41bd835",
      "patch": "@@ -30,12 +30,12 @@\n /* See attribute.h.  */\n \n CORE_ADDR\n-attr_value_as_address (struct attribute *attr)\n+attribute::value_as_address () const\n {\n   CORE_ADDR addr;\n \n-  if (attr->form != DW_FORM_addr && attr->form != DW_FORM_addrx\n-      && attr->form != DW_FORM_GNU_addr_index)\n+  if (form != DW_FORM_addr && form != DW_FORM_addrx\n+      && form != DW_FORM_GNU_addr_index)\n     {\n       /* Aside from a few clearly defined exceptions, attributes that\n \t contain an address must always be in DW_FORM_addr form.\n@@ -49,10 +49,10 @@ attr_value_as_address (struct attribute *attr)\n \t as well as update callers to pass in at least the CU's DWARF\n \t version.  This is more overhead than what we're willing to\n \t expand for a pretty rare case.  */\n-      addr = DW_UNSND (attr);\n+      addr = DW_UNSND (this);\n     }\n   else\n-    addr = DW_ADDR (attr);\n+    addr = DW_ADDR (this);\n \n   return addr;\n }\n@@ -72,20 +72,20 @@ attr_form_is_block (const struct attribute *attr)\n \n /* See attribute.h.  */\n \n-int\n-attr_form_is_section_offset (const struct attribute *attr)\n+bool\n+attribute::form_is_section_offset () const\n {\n-  return (attr->form == DW_FORM_data4\n-          || attr->form == DW_FORM_data8\n-\t  || attr->form == DW_FORM_sec_offset);\n+  return (form == DW_FORM_data4\n+          || form == DW_FORM_data8\n+\t  || form == DW_FORM_sec_offset);\n }\n \n /* See attribute.h.  */\n \n-int\n-attr_form_is_constant (const struct attribute *attr)\n+bool\n+attribute::form_is_constant () const\n {\n-  switch (attr->form)\n+  switch (form)\n     {\n     case DW_FORM_sdata:\n     case DW_FORM_udata:\n@@ -94,19 +94,19 @@ attr_form_is_constant (const struct attribute *attr)\n     case DW_FORM_data4:\n     case DW_FORM_data8:\n     case DW_FORM_implicit_const:\n-      return 1;\n+      return true;\n     default:\n-      return 0;\n+      return false;\n     }\n }\n \n /* DW_ADDR is always stored already as sect_offset; despite for the forms\n    besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */\n \n-int\n-attr_form_is_ref (const struct attribute *attr)\n+bool\n+attribute::form_is_ref () const\n {\n-  switch (attr->form)\n+  switch (form)\n     {\n     case DW_FORM_ref_addr:\n     case DW_FORM_ref1:\n@@ -115,8 +115,8 @@ attr_form_is_ref (const struct attribute *attr)\n     case DW_FORM_ref8:\n     case DW_FORM_ref_udata:\n     case DW_FORM_GNU_ref_alt:\n-      return 1;\n+      return true;\n     default:\n-      return 0;\n+      return false;\n     }\n }"
    },
    {
      "sha": "2e663f1560cf1ef7a350c409bdd8394ee4c27849",
      "filename": "gdb/dwarf2/attribute.h",
      "status": "modified",
      "additions": 39,
      "deletions": 39,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/gdb/dwarf2/attribute.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/gdb/dwarf2/attribute.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.h?ref=cd6c91b4f8c429d49a103c3ad45ee741e41bd835",
      "patch": "@@ -41,6 +41,45 @@ struct dwarf_block\n /* Attributes have a name and a value.  */\n struct attribute\n {\n+  /* Read the given attribute value as an address, taking the\n+     attribute's form into account.  */\n+  CORE_ADDR value_as_address () const;\n+\n+  /* Return non-zero if ATTR's value is a section offset --- classes\n+     lineptr, loclistptr, macptr or rangelistptr --- or zero, otherwise.\n+     You may use DW_UNSND (attr) to retrieve such offsets.\n+\n+     Section 7.5.4, \"Attribute Encodings\", explains that no attribute\n+     may have a value that belongs to more than one of these classes; it\n+     would be ambiguous if we did, because we use the same forms for all\n+     of them.  */\n+\n+  bool form_is_section_offset () const;\n+\n+  /* Return non-zero if ATTR's value falls in the 'constant' class, or\n+     zero otherwise.  When this function returns true, you can apply\n+     dwarf2_get_attr_constant_value to it.\n+\n+     However, note that for some attributes you must check\n+     attr_form_is_section_offset before using this test.  DW_FORM_data4\n+     and DW_FORM_data8 are members of both the constant class, and of\n+     the classes that contain offsets into other debug sections\n+     (lineptr, loclistptr, macptr or rangelistptr).  The DWARF spec says\n+     that, if an attribute's can be either a constant or one of the\n+     section offset classes, DW_FORM_data4 and DW_FORM_data8 should be\n+     taken as section offsets, not constants.\n+\n+     DW_FORM_data16 is not considered as dwarf2_get_attr_constant_value\n+     cannot handle that.  */\n+\n+  bool form_is_constant () const;\n+\n+  /* DW_ADDR is always stored already as sect_offset; despite for the forms\n+     besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */\n+\n+  bool form_is_ref () const;\n+\n+\n   ENUM_BITFIELD(dwarf_attribute) name : 16;\n   ENUM_BITFIELD(dwarf_form) form : 15;\n \n@@ -71,48 +110,9 @@ struct attribute\n #define DW_ADDR(attr)\t   ((attr)->u.addr)\n #define DW_SIGNATURE(attr) ((attr)->u.signature)\n \n-/* Read the given attribute value as an address, taking the attribute's\n-   form into account.  */\n-\n-extern CORE_ADDR attr_value_as_address (struct attribute *attr);\n-\n /* Check if the attribute's form is a DW_FORM_block*\n    if so return true else false.  */\n \n extern int attr_form_is_block (const struct attribute *attr);\n \n-/* Return non-zero if ATTR's value is a section offset --- classes\n-   lineptr, loclistptr, macptr or rangelistptr --- or zero, otherwise.\n-   You may use DW_UNSND (attr) to retrieve such offsets.\n-\n-   Section 7.5.4, \"Attribute Encodings\", explains that no attribute\n-   may have a value that belongs to more than one of these classes; it\n-   would be ambiguous if we did, because we use the same forms for all\n-   of them.  */\n-\n-extern int attr_form_is_section_offset (const struct attribute *attr);\n-\n-/* Return non-zero if ATTR's value falls in the 'constant' class, or\n-   zero otherwise.  When this function returns true, you can apply\n-   dwarf2_get_attr_constant_value to it.\n-\n-   However, note that for some attributes you must check\n-   attr_form_is_section_offset before using this test.  DW_FORM_data4\n-   and DW_FORM_data8 are members of both the constant class, and of\n-   the classes that contain offsets into other debug sections\n-   (lineptr, loclistptr, macptr or rangelistptr).  The DWARF spec says\n-   that, if an attribute's can be either a constant or one of the\n-   section offset classes, DW_FORM_data4 and DW_FORM_data8 should be\n-   taken as section offsets, not constants.\n-\n-   DW_FORM_data16 is not considered as dwarf2_get_attr_constant_value\n-   cannot handle that.  */\n-\n-extern int attr_form_is_constant (const struct attribute *attr);\n-\n-/* DW_ADDR is always stored already as sect_offset; despite for the forms\n-   besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */\n-\n-extern int attr_form_is_ref (const struct attribute *attr);\n-\n #endif /* GDB_DWARF2_ATTRIBUTE_H */"
    },
    {
      "sha": "0df5eef27c234b6c922d5861a401dbe47888a911",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 44,
      "deletions": 44,
      "changes": 88,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd6c91b4f8c429d49a103c3ad45ee741e41bd835/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=cd6c91b4f8c429d49a103c3ad45ee741e41bd835",
      "patch": "@@ -6112,15 +6112,15 @@ dwarf2_find_base_address (struct die_info *die, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_entry_pc, cu);\n   if (attr != nullptr)\n     {\n-      cu->base_address = attr_value_as_address (attr);\n+      cu->base_address = attr->value_as_address ();\n       cu->base_known = 1;\n     }\n   else\n     {\n       attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n       if (attr != nullptr)\n \t{\n-\t  cu->base_address = attr_value_as_address (attr);\n+\t  cu->base_address = attr->value_as_address ();\n \t  cu->base_known = 1;\n \t}\n     }\n@@ -13587,7 +13587,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t sect_offset_str (die->sect_off), objfile_name (objfile));\n       return;\n     }\n-  pc = attr_value_as_address (attr) + baseaddr;\n+  pc = attr->value_as_address () + baseaddr;\n   pc = gdbarch_adjust_dwarf2_addr (gdbarch, pc);\n \n   if (cu->call_site_htab == NULL)\n@@ -13706,7 +13706,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \n       SET_FIELD_DWARF_BLOCK (call_site->target, dlbaton);\n     }\n-  else if (attr_form_is_ref (attr))\n+  else if (attr->form_is_ref ())\n     {\n       struct dwarf2_cu *target_cu = cu;\n       struct die_info *target_die;\n@@ -13781,7 +13781,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t     for DW_AT_call_parameter.  */\n \t  origin = dwarf2_attr (child_die, DW_AT_abstract_origin, cu);\n \t}\n-      if (loc == NULL && origin != NULL && attr_form_is_ref (origin))\n+      if (loc == NULL && origin != NULL && origin->form_is_ref ())\n \t{\n \t  parameter->kind = CALL_SITE_PARAMETER_PARAM_OFFSET;\n \n@@ -13883,7 +13883,7 @@ rust_containing_type (struct die_info *die, struct dwarf2_cu *cu)\n   struct die_info *type_die = NULL;\n   struct dwarf2_cu *type_cu = cu;\n \n-  if (attr_form_is_ref (attr))\n+  if (attr->form_is_ref ())\n     type_die = follow_die_ref (die, attr, &type_cu);\n   if (type_die == NULL)\n     return NULL;\n@@ -14294,9 +14294,9 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n       attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n       if (attr != nullptr)\n         {\n-\t  low = attr_value_as_address (attr);\n-\t  high = attr_value_as_address (attr_high);\n-\t  if (cu->header.version >= 4 && attr_form_is_constant (attr_high))\n+\t  low = attr->value_as_address ();\n+\t  high = attr_high->value_as_address ();\n+\t  if (cu->header.version >= 4 && attr_high->form_is_constant ())\n \t    high += low;\n \t}\n       else\n@@ -14467,10 +14467,10 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n       attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n       if (attr != nullptr)\n         {\n-          CORE_ADDR low = attr_value_as_address (attr);\n-\t  CORE_ADDR high = attr_value_as_address (attr_high);\n+          CORE_ADDR low = attr->value_as_address ();\n+\t  CORE_ADDR high = attr_high->value_as_address ();\n \n-\t  if (cu->header.version >= 4 && attr_form_is_constant (attr_high))\n+\t  if (cu->header.version >= 4 && attr_high->form_is_constant ())\n \t    high += low;\n \n \t  low = gdbarch_adjust_dwarf2_addr (gdbarch, low + baseaddr);\n@@ -14623,9 +14623,9 @@ handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,\n \t This is because DW_AT_data_member_location is new in DWARF 4,\n \t so if we see it, we can assume that a constant form is really\n \t a constant and not a section offset.  */\n-      if (attr_form_is_constant (attr))\n+      if (attr->form_is_constant ())\n \t*offset = dwarf2_get_attr_constant_value (attr, 0);\n-      else if (attr_form_is_section_offset (attr))\n+      else if (attr->form_is_section_offset ())\n \tdwarf2_complex_location_expr_complaint ();\n       else if (attr_form_is_block (attr))\n \t*offset = decode_locdesc (DW_BLOCK (attr), cu);\n@@ -15246,7 +15246,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n \t\t}\n \t    }\n \t}\n-      else if (attr_form_is_section_offset (attr))\n+      else if (attr->form_is_section_offset ())\n         {\n \t  dwarf2_complex_location_expr_complaint ();\n         }\n@@ -15373,7 +15373,7 @@ get_alignment (struct dwarf2_cu *cu, struct die_info *die)\n   if (attr == nullptr)\n     return 0;\n \n-  if (!attr_form_is_constant (attr))\n+  if (!attr->form_is_constant ())\n     {\n       complaint (_(\"DW_AT_alignment must have constant form\"\n \t\t   \" - DIE at %s [in module %s]\"),\n@@ -15575,7 +15575,7 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n   if (attr != nullptr)\n     {\n-      if (attr_form_is_constant (attr))\n+      if (attr->form_is_constant ())\n         TYPE_LENGTH (type) = DW_UNSND (attr);\n       else\n \t{\n@@ -15740,7 +15740,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t     In this case arrange not to check the offset.  */\n \t  is_variant_part = false;\n \t}\n-      else if (attr_form_is_ref (discr))\n+      else if (discr->form_is_ref ())\n \t{\n \t  struct dwarf2_cu *target_cu = cu;\n \t  struct die_info *target_die = follow_die_ref (die, discr, &target_cu);\n@@ -16418,15 +16418,15 @@ mark_common_block_symbol_computed (struct symbol *sym,\n   gdb_assert (common_loc && member_loc);\n   gdb_assert (attr_form_is_block (common_loc));\n   gdb_assert (attr_form_is_block (member_loc)\n-\t      || attr_form_is_constant (member_loc));\n+\t      || member_loc->form_is_constant ());\n \n   baton = XOBNEW (&objfile->objfile_obstack, struct dwarf2_locexpr_baton);\n   baton->per_cu = cu->per_cu;\n   gdb_assert (baton->per_cu);\n \n   baton->size = 5 /* DW_OP_call4 */ + 1 /* DW_OP_plus */;\n \n-  if (attr_form_is_constant (member_loc))\n+  if (member_loc->form_is_constant ())\n     {\n       offset = dwarf2_get_attr_constant_value (member_loc, 0);\n       baton->size += 1 /* DW_OP_addr */ + cu->header.addr_size;\n@@ -16442,7 +16442,7 @@ mark_common_block_symbol_computed (struct symbol *sym,\n   store_unsigned_integer (ptr, 4, byte_order, cu_off);\n   ptr += 4;\n \n-  if (attr_form_is_constant (member_loc))\n+  if (member_loc->form_is_constant ())\n     {\n       *ptr++ = DW_OP_addr;\n       store_unsigned_integer (ptr, cu->header.addr_size, byte_order, offset);\n@@ -16482,7 +16482,7 @@ read_common_block (struct die_info *die, struct dwarf2_cu *cu)\n         {\n \t  /* Ok.  */\n         }\n-      else if (attr_form_is_section_offset (attr))\n+      else if (attr->form_is_section_offset ())\n         {\n \t  dwarf2_complex_location_expr_complaint ();\n \t  attr = NULL;\n@@ -16543,9 +16543,9 @@ read_common_block (struct die_info *die, struct dwarf2_cu *cu)\n \t\t\t       sect_offset_str (child_die->sect_off),\n \t\t\t     objfile_name (objfile));\n \n-\t\t  if (attr_form_is_section_offset (member_loc))\n+\t\t  if (member_loc->form_is_section_offset ())\n \t\t    dwarf2_complex_location_expr_complaint ();\n-\t\t  else if (attr_form_is_constant (member_loc)\n+\t\t  else if (member_loc->form_is_constant ()\n \t\t\t   || attr_form_is_block (member_loc))\n \t\t    {\n \t\t      if (attr != nullptr)\n@@ -17006,7 +17006,7 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n     }\n \n   attr = dwarf2_attr (die, DW_AT_string_length, cu);\n-  if (attr != nullptr && !attr_form_is_constant (attr))\n+  if (attr != nullptr && !attr->form_is_constant ())\n     {\n       /* The string length describes the location at which the length of\n \t the string can be found.  The size of the length field can be\n@@ -17016,7 +17016,7 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n \t= dwarf2_attr (die, DW_AT_string_length_byte_size, cu);\n       if (len == nullptr)\n \tlen = dwarf2_attr (die, DW_AT_byte_size, cu);\n-      if (len != nullptr && attr_form_is_constant (len))\n+      if (len != nullptr && len->form_is_constant ())\n \t{\n \t  /* Pass 0 as the default as we know this attribute is constant\n \t     and the default value will not be returned.  */\n@@ -17550,7 +17550,7 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n       prop->kind = PROP_LOCEXPR;\n       gdb_assert (prop->data.baton != NULL);\n     }\n-  else if (attr_form_is_ref (attr))\n+  else if (attr->form_is_ref ())\n     {\n       struct dwarf2_cu *target_cu = cu;\n       struct die_info *target_die;\n@@ -17567,7 +17567,7 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n       switch (target_attr->name)\n \t{\n \t  case DW_AT_location:\n-\t    if (attr_form_is_section_offset (target_attr))\n+\t    if (target_attr->form_is_section_offset ())\n \t      {\n \t\tbaton = XOBNEW (obstack, struct dwarf2_property_baton);\n \t\tbaton->property_type = die_type (target_die, target_cu);\n@@ -17614,7 +17614,7 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t    }\n \t}\n     }\n-  else if (attr_form_is_constant (attr))\n+  else if (attr->form_is_constant ())\n     {\n       prop->data.const_val = dwarf2_get_attr_constant_value (attr, 0);\n       prop->kind = PROP_CONST;\n@@ -17798,7 +17798,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   LONGEST bias = 0;\n   struct attribute *bias_attr = dwarf2_attr (die, DW_AT_GNU_bias, cu);\n-  if (bias_attr != nullptr && attr_form_is_constant (bias_attr))\n+  if (bias_attr != nullptr && bias_attr->form_is_constant ())\n     bias = dwarf2_get_attr_constant_value (bias_attr, 0);\n \n   /* Normally, the DWARF producers are expected to use a signed\n@@ -18476,12 +18476,12 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t  break;\n \tcase DW_AT_low_pc:\n \t  has_low_pc_attr = 1;\n-\t  lowpc = attr_value_as_address (&attr);\n+\t  lowpc = attr.value_as_address ();\n \t  break;\n \tcase DW_AT_high_pc:\n \t  has_high_pc_attr = 1;\n-\t  highpc = attr_value_as_address (&attr);\n-\t  if (cu->header.version >= 4 && attr_form_is_constant (&attr))\n+\t  highpc = attr.value_as_address ();\n+\t  if (cu->header.version >= 4 && attr.form_is_constant ())\n \t\thigh_pc_relative = 1;\n \t  break;\n \tcase DW_AT_location:\n@@ -18490,7 +18490,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n             {\n \t       d.locdesc = DW_BLOCK (&attr);\n             }\n-          else if (attr_form_is_section_offset (&attr))\n+          else if (attr.form_is_section_offset ())\n             {\n \t      dwarf2_complex_location_expr_complaint ();\n             }\n@@ -19162,7 +19162,7 @@ read_attribute_value (const struct die_reader_specs *reader,\n     }\n \n   /* Super hack.  */\n-  if (cu->per_cu->is_dwz && attr_form_is_ref (attr))\n+  if (cu->per_cu->is_dwz && attr->form_is_ref ())\n     attr->form = DW_FORM_GNU_ref_alt;\n \n   /* We have seen instances where the compiler tried to emit a byte\n@@ -21278,7 +21278,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t    {\n \t      CORE_ADDR addr;\n \n-\t      addr = attr_value_as_address (attr);\n+\t      addr = attr->value_as_address ();\n \t      addr = gdbarch_adjust_dwarf2_addr (gdbarch, addr + baseaddr);\n \t      SET_SYMBOL_VALUE_ADDRESS (sym, addr);\n \t    }\n@@ -21896,7 +21896,7 @@ lookup_die_type (struct die_info *die, const struct attribute *attr,\n \t\t\t\t\t\t dwarf2_per_objfile);\n       this_type = get_die_type_at_offset (sect_off, per_cu);\n     }\n-  else if (attr_form_is_ref (attr))\n+  else if (attr->form_is_ref ())\n     {\n       sect_offset sect_off = dwarf2_get_ref_die_offset (attr);\n \n@@ -21924,7 +21924,7 @@ lookup_die_type (struct die_info *die, const struct attribute *attr,\n       struct die_info *type_die = NULL;\n       struct dwarf2_cu *type_cu = cu;\n \n-      if (attr_form_is_ref (attr))\n+      if (attr->form_is_ref ())\n \ttype_die = follow_die_ref (die, attr, &type_cu);\n       if (type_die == NULL)\n \treturn build_error_marker_type (cu, die);\n@@ -22828,7 +22828,7 @@ store_in_ref_table (struct die_info *die, struct dwarf2_cu *cu)\n static sect_offset\n dwarf2_get_ref_die_offset (const struct attribute *attr)\n {\n-  if (attr_form_is_ref (attr))\n+  if (attr->form_is_ref ())\n     return (sect_offset) DW_UNSND (attr);\n \n   complaint (_(\"unsupported die ref attribute form: '%s'\"),\n@@ -22852,7 +22852,7 @@ dwarf2_get_attr_constant_value (const struct attribute *attr, int default_value)\n     return DW_UNSND (attr);\n   else\n     {\n-      /* For DW_FORM_data16 see attr_form_is_constant.  */\n+      /* For DW_FORM_data16 see attribute::form_is_constant.  */\n       complaint (_(\"Attribute value is not a constant (%s)\"),\n                  dwarf_form_name (attr->form));\n       return default_value;\n@@ -22869,7 +22869,7 @@ follow_die_ref_or_sig (struct die_info *src_die, const struct attribute *attr,\n {\n   struct die_info *die;\n \n-  if (attr_form_is_ref (attr))\n+  if (attr->form_is_ref ())\n     die = follow_die_ref (src_die, attr, ref_cu);\n   else if (attr->form == DW_FORM_ref_sig8)\n     die = follow_die_sig (src_die, attr, ref_cu);\n@@ -23043,7 +23043,7 @@ dwarf2_fetch_die_loc_sect_off (sect_offset sect_off,\n       retval.data = NULL;\n       retval.size = 0;\n     }\n-  else if (attr_form_is_section_offset (attr))\n+  else if (attr->form_is_section_offset ())\n     {\n       struct dwarf2_loclist_baton loclist_baton;\n       CORE_ADDR pc = (*get_frame_pc) (baton);\n@@ -23431,7 +23431,7 @@ get_DW_AT_signature_type (struct die_info *die, const struct attribute *attr,\n \t\t\t  struct dwarf2_cu *cu) /* ARI: editCase function */\n {\n   /* Yes, DW_AT_signature can use a non-ref_sig8 reference.  */\n-  if (attr_form_is_ref (attr))\n+  if (attr->form_is_ref ())\n     {\n       struct dwarf2_cu *type_cu = cu;\n       struct die_info *type_die = follow_die_ref (die, attr, &type_cu);\n@@ -24785,7 +24785,7 @@ dwarf2_symbol_mark_computed (const struct attribute *attr, struct symbol *sym,\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_section_info *section = cu_debug_loc_section (cu);\n \n-  if (attr_form_is_section_offset (attr)\n+  if (attr->form_is_section_offset ()\n       /* .debug_loc{,.dwo} may not exist at all, or the offset may be outside\n \t the section.  If so, fall through to the complaint in the\n \t other branch.  */"
    }
  ]
}