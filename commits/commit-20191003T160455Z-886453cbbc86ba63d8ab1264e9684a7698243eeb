{
  "sha": "886453cbbc86ba63d8ab1264e9684a7698243eeb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODg2NDUzY2JiYzg2YmE2M2Q4YWIxMjY0ZTk2ODRhNzY5ODI0M2VlYg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-07-13T20:31:26Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-10-03T16:04:55Z"
    },
    "message": "libctf: map from old to corresponding newly-added types in ctf_add_type\n\nThis lets you call ctf_type_mapping (dest_fp, src_fp, src_type_id)\nand get told what type ID the corresponding type has in the target\nctf_file_t.  This works even if it was added by a recursive call, and\nbecause it is stored in the target ctf_file_t it works even if we\nhad to add one type to multiple ctf_file_t's as part of conflicting\ntype handling.\n\nWe empty out this mapping after every archive is linked: because it maps\ninput to output fps, and we only visit each input fp once, its contents\nare rendered entirely useless every time the source fp changes.\n\nv3: add several missing mapping additions.  Add ctf_dynhash_empty, and\n    empty after every input archive.\nv5: fix tabdamage.\n\nlibctf/\n\t* ctf-impl.h (ctf_file_t): New field ctf_link_type_mapping.\n\t(struct ctf_link_type_mapping_key): New.\n\t(ctf_hash_type_mapping_key): Likewise.\n\t(ctf_hash_eq_type_mapping_key): Likewise.\n\t(ctf_add_type_mapping): Likewise.\n\t(ctf_type_mapping): Likewise.\n\t(ctf_dynhash_empty): Likewise.\n\t* ctf-open.c (ctf_file_close): Update accordingly.\n\t* ctf-create.c (ctf_update): Likewise.\n\t(ctf_add_type): Populate the mapping.\n\t* ctf-hash.c (ctf_hash_type_mapping_key): Hash a type mapping key.\n\t(ctf_hash_eq_type_mapping_key): Check the key for equality.\n\t(ctf_dynhash_insert): Fix comment typo.\n\t(ctf_dynhash_empty): New.\n\t* ctf-link.c (ctf_add_type_mapping): New.\n\t(ctf_type_mapping): Likewise.\n\t(empty_link_type_mapping): New.\n\t(ctf_link_one_input_archive): Call it.",
    "tree": {
      "sha": "77880fc8d6e8c2342b6c45f8de49a4058433c89c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/77880fc8d6e8c2342b6c45f8de49a4058433c89c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/886453cbbc86ba63d8ab1264e9684a7698243eeb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/886453cbbc86ba63d8ab1264e9684a7698243eeb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/886453cbbc86ba63d8ab1264e9684a7698243eeb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/886453cbbc86ba63d8ab1264e9684a7698243eeb/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8"
    }
  ],
  "stats": {
    "total": 206,
    "additions": 202,
    "deletions": 4
  },
  "files": [
    {
      "sha": "7dc32b89ce3560e54fc73b1ec8d97f2f4a1d6afa",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=886453cbbc86ba63d8ab1264e9684a7698243eeb",
      "patch": "@@ -1,3 +1,24 @@\n+2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_file_t): New field ctf_link_type_mapping.\n+\t(struct ctf_link_type_mapping_key): New.\n+\t(ctf_hash_type_mapping_key): Likewise.\n+\t(ctf_hash_eq_type_mapping_key): Likewise.\n+\t(ctf_add_type_mapping): Likewise.\n+\t(ctf_type_mapping): Likewise.\n+\t(ctf_dynhash_empty): Likewise.\n+\t* ctf-open.c (ctf_file_close): Update accordingly.\n+\t* ctf-create.c (ctf_update): Likewise.\n+\t(ctf_add_type): Populate the mapping.\n+\t* ctf-hash.c (ctf_hash_type_mapping_key): Hash a type mapping key.\n+\t(ctf_hash_eq_type_mapping_key): Check the key for equality.\n+\t(ctf_dynhash_insert): Fix comment typo.\n+\t(ctf_dynhash_empty): New.\n+\t* ctf-link.c (ctf_add_type_mapping): New.\n+\t(ctf_type_mapping): Likewise.\n+\t(empty_link_type_mapping): New.\n+\t(ctf_link_one_input_archive): Call it.\n+\n 2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-link.c: New file, linking of the string and type sections."
    },
    {
      "sha": "90e45f340b16b30e105c612e0f3205bb1bab0084",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 17,
      "deletions": 3,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=886453cbbc86ba63d8ab1264e9684a7698243eeb",
      "patch": "@@ -473,6 +473,7 @@ ctf_update (ctf_file_t *fp)\n   nfp->ctf_link_inputs = fp->ctf_link_inputs;\n   nfp->ctf_link_outputs = fp->ctf_link_outputs;\n   nfp->ctf_syn_ext_strtab = fp->ctf_syn_ext_strtab;\n+  nfp->ctf_link_type_mapping = fp->ctf_link_type_mapping;\n \n   nfp->ctf_snapshot_lu = fp->ctf_snapshots;\n \n@@ -485,6 +486,7 @@ ctf_update (ctf_file_t *fp)\n   fp->ctf_link_inputs = NULL;\n   fp->ctf_link_outputs = NULL;\n   fp->ctf_syn_ext_strtab = NULL;\n+  fp->ctf_link_type_mapping = NULL;\n \n   fp->ctf_dvhash = NULL;\n   memset (&fp->ctf_dvdefs, 0, sizeof (ctf_list_t));\n@@ -1557,6 +1559,7 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n   ctf_funcinfo_t ctc;\n \n   ctf_hash_t *hp;\n+  ctf_id_t orig_src_type = src_type;\n \n   if (!(dst_fp->ctf_flags & LCTF_RDWR))\n     return (ctf_set_errno (dst_fp, ECTF_RDONLY));\n@@ -1640,7 +1643,10 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \t      if (memcmp (&src_en, &dst_en, sizeof (ctf_encoding_t)) == 0)\n \t\t{\n \t\t  if (kind != CTF_K_SLICE)\n-\t\t    return dst_type;\n+\t\t    {\n+\t\t      ctf_add_type_mapping (src_fp, src_type, dst_fp, dst_type);\n+\t\t      return dst_type;\n+\t\t    }\n \t\t}\n \t      else\n \t\t  {\n@@ -1679,7 +1685,10 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \t      int match;\t/* Do the encodings match?  */\n \n \t      if (kind != CTF_K_INTEGER && kind != CTF_K_FLOAT && kind != CTF_K_SLICE)\n-\t\treturn dtd->dtd_type;\n+\t\t{\n+\t\t  ctf_add_type_mapping (src_fp, src_type, dst_fp, dtd->dtd_type);\n+\t\t  return dtd->dtd_type;\n+\t\t}\n \n \t      sroot = (flag & CTF_ADD_ROOT);\n \t      droot = (LCTF_INFO_ISROOT (dst_fp,\n@@ -1698,7 +1707,10 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \t      if (match && sroot == droot)\n \t\t{\n \t\t  if (kind != CTF_K_SLICE)\n-\t\t    return dtd->dtd_type;\n+\t\t    {\n+\t\t      ctf_add_type_mapping (src_fp, src_type, dst_fp, dtd->dtd_type);\n+\t\t      return dtd->dtd_type;\n+\t\t    }\n \t\t}\n \t      else if (!match && sroot && droot)\n \t\t{\n@@ -1939,6 +1951,8 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n       return (ctf_set_errno (dst_fp, ECTF_CORRUPT));\n     }\n \n+  if (dst_type != CTF_ERR)\n+    ctf_add_type_mapping (src_fp, orig_src_type, dst_fp, dst_type);\n   return dst_type;\n }\n "
    },
    {
      "sha": "c6233eb67677ec35a29439ca70398ee130396b20",
      "filename": "libctf/ctf-hash.c",
      "status": "modified",
      "additions": 29,
      "deletions": 1,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=886453cbbc86ba63d8ab1264e9684a7698243eeb",
      "patch": "@@ -82,6 +82,28 @@ ctf_hash_eq_string (const void *a, const void *b)\n   return !strcmp((const char *) hep_a->key, (const char *) hep_b->key);\n }\n \n+/* Hash a type_mapping_key.  */\n+unsigned int\n+ctf_hash_type_mapping_key (const void *ptr)\n+{\n+  ctf_helem_t *hep = (ctf_helem_t *) ptr;\n+  ctf_link_type_mapping_key_t *k = (ctf_link_type_mapping_key_t *) hep->key;\n+\n+  return htab_hash_pointer (k->cltm_fp) + 59 * htab_hash_pointer ((void *) k->cltm_idx);\n+}\n+\n+int\n+ctf_hash_eq_type_mapping_key (const void *a, const void *b)\n+{\n+  ctf_helem_t *hep_a = (ctf_helem_t *) a;\n+  ctf_helem_t *hep_b = (ctf_helem_t *) b;\n+  ctf_link_type_mapping_key_t *key_a = (ctf_link_type_mapping_key_t *) hep_a->key;\n+  ctf_link_type_mapping_key_t *key_b = (ctf_link_type_mapping_key_t *) hep_b->key;\n+\n+  return (key_a->cltm_fp == key_b->cltm_fp)\n+    && (key_a->cltm_idx == key_b->cltm_idx);\n+}\n+\n /* The dynhash, used for hashes whose size is not known at creation time. */\n \n /* Free a single ctf_helem.  */\n@@ -164,7 +186,7 @@ ctf_dynhash_insert (ctf_dynhash_t *hp, void *key, void *value)\n     return errno;\n \n   /* We need to keep the key_free and value_free around in each item because the\n-     del function has no visiblity into the hash as a whole, only into the\n+     del function has no visibility into the hash as a whole, only into the\n      individual items.  */\n \n   slot->key_free = hp->key_free;\n@@ -180,6 +202,12 @@ ctf_dynhash_remove (ctf_dynhash_t *hp, const void *key)\n   htab_remove_elt (hp->htab, &hep);\n }\n \n+void\n+ctf_dynhash_empty (ctf_dynhash_t *hp)\n+{\n+  htab_empty (hp->htab);\n+}\n+\n void *\n ctf_dynhash_lookup (ctf_dynhash_t *hp, const void *key)\n {"
    },
    {
      "sha": "c5225549298d7d48d0b36b152c8246490fd33c09",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=886453cbbc86ba63d8ab1264e9684a7698243eeb",
      "patch": "@@ -204,6 +204,17 @@ typedef struct ctf_str_atom_ref\n   uint32_t *caf_ref;\t\t/* A single ref to this string.  */\n } ctf_str_atom_ref_t;\n \n+/* The structure used as the key in a ctf_link_type_mapping, which lets the\n+   linker machinery determine which type IDs on the input side of a link map to\n+   which types on the output side.  (The value is a ctf_id_t: another\n+   index, not a type.)  */\n+\n+typedef struct ctf_link_type_mapping_key\n+{\n+  ctf_file_t *cltm_fp;\n+  ctf_id_t cltm_idx;\n+} ctf_link_type_mapping_key_t;\n+\n /* The ctf_file is the structure used to represent a CTF container to library\n    clients, who see it only as an opaque pointer.  Modifications can therefore\n    be made freely to this structure without regard to client versioning.  The\n@@ -269,6 +280,7 @@ struct ctf_file\n   ctf_archive_t *ctf_archive;\t  /* Archive this ctf_file_t came from.  */\n   ctf_dynhash_t *ctf_link_inputs; /* Inputs to this link.  */\n   ctf_dynhash_t *ctf_link_outputs; /* Additional outputs from this link.  */\n+  ctf_dynhash_t *ctf_link_type_mapping; /* Map input types to output types.  */\n   char *ctf_tmp_typeslice;\t  /* Storage for slicing up type names.  */\n   size_t ctf_tmp_typeslicelen;\t  /* Size of the typeslice.  */\n   void *ctf_specific;\t\t  /* Data for ctf_get/setspecific().  */\n@@ -328,10 +340,12 @@ extern const ctf_type_t *ctf_lookup_by_id (ctf_file_t **, ctf_id_t);\n typedef unsigned int (*ctf_hash_fun) (const void *ptr);\n extern unsigned int ctf_hash_integer (const void *ptr);\n extern unsigned int ctf_hash_string (const void *ptr);\n+extern unsigned int ctf_hash_type_mapping_key (const void *ptr);\n \n typedef int (*ctf_hash_eq_fun) (const void *, const void *);\n extern int ctf_hash_eq_integer (const void *, const void *);\n extern int ctf_hash_eq_string (const void *, const void *);\n+extern int ctf_hash_eq_type_mapping_key (const void *, const void *);\n \n typedef void (*ctf_hash_free_fun) (void *);\n \n@@ -349,6 +363,7 @@ extern ctf_dynhash_t *ctf_dynhash_create (ctf_hash_fun, ctf_hash_eq_fun,\n \t\t\t\t\t  ctf_hash_free_fun, ctf_hash_free_fun);\n extern int ctf_dynhash_insert (ctf_dynhash_t *, void *, void *);\n extern void ctf_dynhash_remove (ctf_dynhash_t *, const void *);\n+extern void ctf_dynhash_empty (ctf_dynhash_t *);\n extern void *ctf_dynhash_lookup (ctf_dynhash_t *, const void *);\n extern void ctf_dynhash_destroy (ctf_dynhash_t *);\n extern void ctf_dynhash_iter (ctf_dynhash_t *, ctf_hash_iter_f, void *);\n@@ -371,6 +386,11 @@ extern int ctf_dvd_insert (ctf_file_t *, ctf_dvdef_t *);\n extern void ctf_dvd_delete (ctf_file_t *, ctf_dvdef_t *);\n extern ctf_dvdef_t *ctf_dvd_lookup (const ctf_file_t *, const char *);\n \n+extern void ctf_add_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type,\n+\t\t\t\t  ctf_file_t *dst_fp, ctf_id_t dst_type);\n+extern ctf_id_t ctf_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type,\n+\t\t\t\t  ctf_file_t **dst_fp);\n+\n extern void ctf_decl_init (ctf_decl_t *);\n extern void ctf_decl_fini (ctf_decl_t *);\n extern void ctf_decl_push (ctf_decl_t *, ctf_file_t *, ctf_id_t);"
    },
    {
      "sha": "e10edf2eb413ccaa3f2621a5cc1dcb81d88f60ee",
      "filename": "libctf/ctf-link.c",
      "status": "modified",
      "additions": 114,
      "deletions": 0,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=886453cbbc86ba63d8ab1264e9684a7698243eeb",
      "patch": "@@ -20,6 +20,104 @@\n #include <ctf-impl.h>\n #include <string.h>\n \n+/* Type tracking machinery.  */\n+\n+/* Record the correspondence between a source and ctf_add_type()-added\n+   destination type: both types are translated into parent type IDs if need be,\n+   so they relate to the actual container they are in.  Outside controlled\n+   circumstances (like linking) it is probably not useful to do more than\n+   compare these pointers, since there is nothing stopping the user closing the\n+   source container whenever they want to.\n+\n+   Our OOM handling here is just to not do anything, because this is called deep\n+   enough in the call stack that doing anything useful is painfully difficult:\n+   the worst consequence if we do OOM is a bit of type duplication anyway.  */\n+\n+void\n+ctf_add_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type,\n+\t\t      ctf_file_t *dst_fp, ctf_id_t dst_type)\n+{\n+  if (LCTF_TYPE_ISPARENT (src_fp, src_type) && src_fp->ctf_parent)\n+    src_fp = src_fp->ctf_parent;\n+\n+  src_type = LCTF_TYPE_TO_INDEX(src_fp, src_type);\n+\n+  if (LCTF_TYPE_ISPARENT (dst_fp, dst_type) && dst_fp->ctf_parent)\n+    dst_fp = dst_fp->ctf_parent;\n+\n+  dst_type = LCTF_TYPE_TO_INDEX(dst_fp, dst_type);\n+\n+  /* This dynhash is a bit tricky: it has a multivalued (structural) key, so we\n+     need to use the sized-hash machinery to generate key hashing and equality\n+     functions.  */\n+\n+  if (dst_fp->ctf_link_type_mapping == NULL)\n+    {\n+      ctf_hash_fun f = ctf_hash_type_mapping_key;\n+      ctf_hash_eq_fun e = ctf_hash_eq_type_mapping_key;\n+\n+      if ((dst_fp->ctf_link_type_mapping = ctf_dynhash_create (f, e, free,\n+\t\t\t\t\t\t\t       NULL)) == NULL)\n+\treturn;\n+    }\n+\n+  ctf_link_type_mapping_key_t *key;\n+  key = calloc (1, sizeof (struct ctf_link_type_mapping_key));\n+  if (!key)\n+    return;\n+\n+  key->cltm_fp = src_fp;\n+  key->cltm_idx = src_type;\n+\n+  ctf_dynhash_insert (dst_fp->ctf_link_type_mapping, key,\n+\t\t      (void *) (uintptr_t) dst_type);\n+}\n+\n+/* Look up a type mapping: return 0 if none.  The DST_FP is modified to point to\n+   the parent if need be.  The ID returned is from the dst_fp's perspective.  */\n+ctf_id_t\n+ctf_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type, ctf_file_t **dst_fp)\n+{\n+  ctf_link_type_mapping_key_t key;\n+  ctf_file_t *target_fp = *dst_fp;\n+  ctf_id_t dst_type = 0;\n+\n+  if (LCTF_TYPE_ISPARENT (src_fp, src_type) && src_fp->ctf_parent)\n+    src_fp = src_fp->ctf_parent;\n+\n+  src_type = LCTF_TYPE_TO_INDEX(src_fp, src_type);\n+  key.cltm_fp = src_fp;\n+  key.cltm_idx = src_type;\n+\n+  if (target_fp->ctf_link_type_mapping)\n+    dst_type = (uintptr_t) ctf_dynhash_lookup (target_fp->ctf_link_type_mapping,\n+\t\t\t\t\t       &key);\n+\n+  if (dst_type != 0)\n+    {\n+      dst_type = LCTF_INDEX_TO_TYPE (target_fp, dst_type,\n+\t\t\t\t     target_fp->ctf_parent != NULL);\n+      *dst_fp = target_fp;\n+      return dst_type;\n+    }\n+\n+  if (target_fp->ctf_parent)\n+    target_fp = target_fp->ctf_parent;\n+  else\n+    return 0;\n+\n+  if (target_fp->ctf_link_type_mapping)\n+    dst_type = (uintptr_t) ctf_dynhash_lookup (target_fp->ctf_link_type_mapping,\n+\t\t\t\t\t       &key);\n+\n+  if (dst_type)\n+    dst_type = LCTF_INDEX_TO_TYPE (target_fp, dst_type,\n+\t\t\t\t   target_fp->ctf_parent != NULL);\n+\n+  *dst_fp = target_fp;\n+  return dst_type;\n+}\n+\n /* Linker machinery.\n \n    CTF linking consists of adding CTF archives full of content to be merged into\n@@ -229,6 +327,17 @@ ctf_link_one_input_archive_member (ctf_file_t *in_fp, const char *name, void *ar\n   return 0;\n }\n \n+/* Dump the unnecessary link type mapping after one input file is processed.  */\n+static void\n+empty_link_type_mapping (void *key _libctf_unused_, void *value,\n+\t\t\t void *arg _libctf_unused_)\n+{\n+  ctf_file_t *fp = (ctf_file_t *) value;\n+\n+  if (fp->ctf_link_type_mapping)\n+    ctf_dynhash_empty (fp->ctf_link_type_mapping);\n+}\n+\n /* Link one input file's types into the output file.  */\n static void\n ctf_link_one_input_archive (void *key, void *value, void *arg_)\n@@ -267,6 +376,11 @@ ctf_link_one_input_archive (void *key, void *value, void *arg_)\n       ctf_set_errno (arg->out_fp, 0);\n     }\n   ctf_file_close (arg->main_input_fp);\n+\n+  /* Discard the now-unnecessary mapping table data.  */\n+  if (arg->out_fp->ctf_link_type_mapping)\n+    ctf_dynhash_empty (arg->out_fp->ctf_link_type_mapping);\n+  ctf_dynhash_iter (arg->out_fp->ctf_link_outputs, empty_link_type_mapping, NULL);\n }\n \n /* Merge types and variable sections in all files added to the link"
    },
    {
      "sha": "600fe8fcae371424722ed6fe4ea51031c0b06cc7",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/886453cbbc86ba63d8ab1264e9684a7698243eeb/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=886453cbbc86ba63d8ab1264e9684a7698243eeb",
      "patch": "@@ -1627,6 +1627,7 @@ ctf_file_close (ctf_file_t *fp)\n   ctf_dynhash_destroy (fp->ctf_syn_ext_strtab);\n   ctf_dynhash_destroy (fp->ctf_link_inputs);\n   ctf_dynhash_destroy (fp->ctf_link_outputs);\n+  ctf_dynhash_destroy (fp->ctf_link_type_mapping);\n \n   ctf_free (fp->ctf_sxlate);\n   ctf_free (fp->ctf_txlate);"
    }
  ]
}