{
  "sha": "575673752cade1772f4a6ba2e38306e5ac9a91f6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTc1NjczNzUyY2FkZTE3NzJmNGE2YmEyZTM4MzA2ZTVhYzlhOTFmNg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-11-04T15:49:16Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-11-04T15:49:17Z"
    },
    "message": "Synthesize array descriptors with -fgnat-encodings=minimal\n\nWhen -fgnat-encodings=minimal, the compiler will avoid the special\nGNAT-specific \"encodings\" format, and instead emit ordinary DWARF as\nmuch as possible.\n\nWhen emitting DWARF for thick pointers to arrays, the compiler emits\nsomething like:\n\n   <1><11db>: Abbrev Number: 7 (DW_TAG_array_type)\n      <11dc>   DW_AT_name        : (indirect string, offset: 0x1bb8): string\n      <11e0>   DW_AT_data_location: 2 byte block: 97 6\n\t  (DW_OP_push_object_address; DW_OP_deref)\n      <11e3>   DW_AT_type        : <0x1173>\n      <11e7>   DW_AT_sibling     : <0x1201>\n   <2><11eb>: Abbrev Number: 8 (DW_TAG_subrange_type)\n      <11ec>   DW_AT_type        : <0x1206>\n      <11f0>   DW_AT_lower_bound : 6 byte block: 97 23 8 6 94 4\n\t  (DW_OP_push_object_address; DW_OP_plus_uconst: 8; DW_OP_deref;\n\t   DW_OP_deref_size: 4)\n      <11f7>   DW_AT_upper_bound : 8 byte block: 97 23 8 6 23 4 94 4\n\t  (DW_OP_push_object_address; DW_OP_plus_uconst: 8; DW_OP_deref;\n\t   DW_OP_plus_uconst: 4; DW_OP_deref_size: 4)\n\nIf you read between the lines, the \"array\" is actually a structure\nwith two elements.  One element is a pointer to the array data, and\nthe other structure describes the bounds of the array.  However, the\ncompiler doesn't emit this explicitly, but instead hides it behind\nthese location expressions.\n\ngdb can print such objects, but currently there is no way to construct\none.  So, this patch adds some code to the DWARF reader to recognize\nthis construct, and then synthesize an array descriptor.  This\ndescriptor is then handled by the existing Ada code.\n\nInternally, we've modified GCC to emit the structure type explicitly\n(we will of course be sending this upstream).  In this case, the array\nstill has the DW_AT_data_location, though.  This patch also modifies\ngdb to ignore the data location in this case -- this is preferred\nbecause the location only serves to confuse the Ada code that already\nknows where to find the data.  In the future I hope to move some of\nthis handling to the gdb core, so that Ada-specific hacks are not\nneeded; however I have not yet done this.\n\nBecause parallel types are not emitted with -fgnat-encodings=minimal,\nsome changes to the Ada code were also required.\n\nThe change ina ada-valprint.c was needed to avoid infinite recursion\nwhen trying to print a constrained packed array.  And, there didn't\nseem to be any need for a recursive call here -- the value could\nsimply be returned instead.\n\nFinally, gdb.ada/frame_arg_lang.exp no longer works in C mode, because\nwe drop back to the structure approach now.  As mentioned earlier,\nfuture work should probably fix this again; meanwhile, this doesn't\nseem to be a big problem, because it is what is currently done (users\nas a rule don't use -fgnat-encodings=minimal -- which is what I am\nultimately trying to fix).\n\nNote that a couple of tests have an added KFAIL.  Some\n-fgnat-encodings=minimal changes have landed in GNAT, and you need\nsomething very recent to pass all the tests.  I'm using git gcc to\naccomplish this.\n\ngdb/ChangeLog\n2020-11-04  Tom Tromey  <tromey@adacore.com>\n\n\t* dwarf2/read.c (recognize_bound_expression)\n\t(quirk_ada_thick_pointer): New functions.\n\t(read_array_type): Call quirk_ada_thick_pointer.\n\t(set_die_type): Add \"skip_data_location\" parameter.\n\t(quirk_ada_thick_pointer): New function.\n\t(process_structure_scope): Call quirk_ada_thick_pointer.\n\t* ada-lang.c (ada_is_unconstrained_packed_array_type)\n\t(decode_packed_array_bitsize): Handle thick pointers without\n\tparallel types.\n\t(ada_is_gnat_encoded_packed_array_type): Rename from\n\tada_is_packed_array_type.\n\t(ada_is_constrained_packed_array_type): Update.\n\t* ada-valprint.c (ada_val_print_gnat_array): Remove.\n\t(ada_value_print_1): Use ada_get_decoded_value.\n\ngdb/testsuite/ChangeLog\n2020-11-04  Tom Tromey  <tromey@adacore.com>\n\n\t* gdb.ada/O2_float_param.exp: Test different -fgnat-encodings\n\tvalues.\n\t* gdb.ada/access_to_unbounded_array.exp: Test different\n\t-fgnat-encodings values.\n\t* gdb.ada/big_packed_array.exp: Test different -fgnat-encodings\n\tvalues.\n\t* gdb.ada/arr_enum_idx_w_gap.exp: Test different -fgnat-encodings\n\tvalues.\n\t* gdb.ada/array_ptr_renaming.exp: Test different -fgnat-encodings\n\tvalues.\n\t* gdb.ada/array_of_variable_length.exp: Test different\n\t-fgnat-encodings values.\n\t* gdb.ada/arrayparam.exp: Test different -fgnat-encodings values.\n\t* gdb.ada/arrayptr.exp: Test different -fgnat-encodings values.\n\t* gdb.ada/frame_arg_lang.exp: Revert -fgnat-encodings=minimal\n\tchange.\n\t* gdb.ada/mi_string_access.exp: Test different -fgnat-encodings\n\tvalues.\n\t* gdb.ada/mod_from_name.exp: Test different -fgnat-encodings values.\n\t* gdb.ada/out_of_line_in_inlined.exp: Test different\n\t-fgnat-encodings values.\n\t* gdb.ada/packed_array.exp: Test different -fgnat-encodings\n\tvalues.\n\t* gdb.ada/pckd_arr_ren.exp: Test different -fgnat-encodings\n\tvalues.\n\t* gdb.ada/unc_arr_ptr_in_var_rec.exp: Test different\n\t-fgnat-encodings values.\n\t* gdb.ada/variant_record_packed_array.exp: Test different\n\t-fgnat-encodings values.",
    "tree": {
      "sha": "d84eec349be4566a38181d48fdf9fcca42c29af0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d84eec349be4566a38181d48fdf9fcca42c29af0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/575673752cade1772f4a6ba2e38306e5ac9a91f6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/575673752cade1772f4a6ba2e38306e5ac9a91f6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/575673752cade1772f4a6ba2e38306e5ac9a91f6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/575673752cade1772f4a6ba2e38306e5ac9a91f6/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a7400e443cb4c20aea2c1c4641cb56a913ff7235",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a7400e443cb4c20aea2c1c4641cb56a913ff7235",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a7400e443cb4c20aea2c1c4641cb56a913ff7235"
    }
  ],
  "stats": {
    "total": 1106,
    "additions": 778,
    "deletions": 328
  },
  "files": [
    {
      "sha": "031792d50b5dfdd81b6fe248626d765d161564f1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -1,3 +1,20 @@\n+2020-11-04  Tom Tromey  <tromey@adacore.com>\n+\n+\t* dwarf2/read.c (recognize_bound_expression)\n+\t(quirk_ada_thick_pointer): New functions.\n+\t(read_array_type): Call quirk_ada_thick_pointer.\n+\t(set_die_type): Add \"skip_data_location\" parameter.\n+\t(quirk_ada_thick_pointer): New function.\n+\t(process_structure_scope): Call quirk_ada_thick_pointer.\n+\t* ada-lang.c (ada_is_unconstrained_packed_array_type)\n+\t(decode_packed_array_bitsize): Handle thick pointers without\n+\tparallel types.\n+\t(ada_is_gnat_encoded_packed_array_type): Rename from\n+\tada_is_packed_array_type.\n+\t(ada_is_constrained_packed_array_type): Update.\n+\t* ada-valprint.c (ada_val_print_gnat_array): Remove.\n+\t(ada_value_print_1): Use ada_get_decoded_value.\n+\n 2020-11-04  Tom Tromey  <tromey@adacore.com>\n \n \t* ada-lang.c (recursively_update_array_bitsize): New function."
    },
    {
      "sha": "f6043b50aff88897fddcabdc9119008f36de22b8",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 31,
      "deletions": 7,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -170,8 +170,6 @@ static long decode_packed_array_bitsize (struct type *);\n \n static struct value *decode_constrained_packed_array (struct value *);\n \n-static int ada_is_packed_array_type  (struct type *);\n-\n static int ada_is_unconstrained_packed_array_type (struct type *);\n \n static struct value *value_subscript_packed (struct value *, int,\n@@ -1965,7 +1963,7 @@ ada_coerce_to_simple_array_type (struct type *type)\n /* Non-zero iff TYPE represents a standard GNAT packed-array type.  */\n \n static int\n-ada_is_packed_array_type  (struct type *type)\n+ada_is_gnat_encoded_packed_array_type  (struct type *type)\n {\n   if (type == NULL)\n     return 0;\n@@ -1982,7 +1980,7 @@ ada_is_packed_array_type  (struct type *type)\n int\n ada_is_constrained_packed_array_type (struct type *type)\n {\n-  return ada_is_packed_array_type (type)\n+  return ada_is_gnat_encoded_packed_array_type (type)\n     && !ada_is_array_descriptor_type (type);\n }\n \n@@ -1992,8 +1990,26 @@ ada_is_constrained_packed_array_type (struct type *type)\n static int\n ada_is_unconstrained_packed_array_type (struct type *type)\n {\n-  return ada_is_packed_array_type (type)\n-    && ada_is_array_descriptor_type (type);\n+  if (!ada_is_array_descriptor_type (type))\n+    return 0;\n+\n+  if (ada_is_gnat_encoded_packed_array_type (type))\n+    return 1;\n+\n+  /* If we saw GNAT encodings, then the above code is sufficient.\n+     However, with minimal encodings, we will just have a thick\n+     pointer instead.  */\n+  if (is_thick_pntr (type))\n+    {\n+      type = desc_base_type (type);\n+      /* The structure's first field is a pointer to an array, so this\n+\t fetches the array type.  */\n+      type = TYPE_TARGET_TYPE (type->field (0).type ());\n+      /* Now we can see if the array elements are packed.  */\n+      return TYPE_FIELD_BITSIZE (type, 0) > 0;\n+    }\n+\n+  return 0;\n }\n \n /* Given that TYPE encodes a packed array type (constrained or unconstrained),\n@@ -2020,7 +2036,15 @@ decode_packed_array_bitsize (struct type *type)\n     return 0;\n \n   tail = strstr (raw_name, \"___XP\");\n-  gdb_assert (tail != NULL);\n+  if (tail == nullptr)\n+    {\n+      gdb_assert (is_thick_pntr (type));\n+      /* The structure's first field is a pointer to an array, so this\n+\t fetches the array type.  */\n+      type = TYPE_TARGET_TYPE (type->field (0).type ());\n+      /* Now we can see if the array elements are packed.  */\n+      return TYPE_FIELD_BITSIZE (type, 0);\n+    }\n \n   if (sscanf (tail + sizeof (\"___XP\") - 1, \"%ld\", &bits) != 1)\n     {"
    },
    {
      "sha": "d7704f07163b1586f850c55dfb67d60f1a89e835",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 13,
      "deletions": 33,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -711,36 +711,6 @@ ada_val_print_string (struct type *type, const gdb_byte *valaddr,\n \t    eltlen, options);\n }\n \n-/* Implement Ada val_print-ing for GNAT arrays (Eg. fat pointers,\n-   thin pointers, etc).  */\n-\n-static void\n-ada_val_print_gnat_array (struct value *val,\n-\t\t\t  struct ui_file *stream, int recurse,\n-\t\t\t  const struct value_print_options *options)\n-{\n-  scoped_value_mark free_values;\n-\n-  struct type *type = ada_check_typedef (value_type (val));\n-\n-  /* If this is a reference, coerce it now.  This helps taking care\n-     of the case where ADDRESS is meaningless because original_value\n-     was not an lval.  */\n-  val = coerce_ref (val);\n-  if (type->code () == TYPE_CODE_TYPEDEF)  /* array access type.  */\n-    val = ada_coerce_to_simple_array_ptr (val);\n-  else\n-    val = ada_coerce_to_simple_array (val);\n-  if (val == NULL)\n-    {\n-      gdb_assert (type->code () == TYPE_CODE_TYPEDEF);\n-      fprintf_filtered (stream, \"0x0\");\n-    }\n-  else\n-    common_val_print (val, stream, recurse, options,\n-\t\t      language_def (language_ada));\n-}\n-\n /* Implement Ada value_print'ing for the case where TYPE is a\n    TYPE_CODE_PTR.  */\n \n@@ -1028,11 +998,21 @@ ada_value_print_1 (struct value *val, struct ui_file *stream, int recurse,\n       || (ada_is_constrained_packed_array_type (type)\n \t  && type->code () != TYPE_CODE_PTR))\n     {\n-      ada_val_print_gnat_array (val, stream, recurse, options);\n-      return;\n+      /* If this is a reference, coerce it now.  This helps taking\n+\t care of the case where ADDRESS is meaningless because\n+\t original_value was not an lval.  */\n+      val = coerce_ref (val);\n+      val = ada_get_decoded_value (val);\n+      if (val == nullptr)\n+\t{\n+\t  gdb_assert (type->code () == TYPE_CODE_TYPEDEF);\n+\t  fprintf_filtered (stream, \"0x0\");\n+\t  return;\n+\t}\n     }\n+  else\n+    val = ada_to_fixed_value (val);\n \n-  val = ada_to_fixed_value (val);\n   type = value_type (val);\n   struct type *saved_type = type;\n "
    },
    {
      "sha": "364a16d05816c9d541854a05e6ac6bde5e08d47c",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 322,
      "deletions": 6,
      "changes": 328,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -1373,6 +1373,9 @@ static void dwarf2_const_value_attr (const struct attribute *attr,\n \t\t\t\t     const gdb_byte **bytes,\n \t\t\t\t     struct dwarf2_locexpr_baton **baton);\n \n+static struct type *read_subrange_index_type (struct die_info *die,\n+\t\t\t\t\t      struct dwarf2_cu *cu);\n+\n static struct type *die_type (struct die_info *, struct dwarf2_cu *);\n \n static int need_gnat_info (struct dwarf2_cu *);\n@@ -1598,7 +1601,7 @@ static void prepare_one_comp_unit (struct dwarf2_cu *cu,\n \t\t\t\t   enum language pretend_language);\n \n static struct type *set_die_type (struct die_info *, struct type *,\n-\t\t\t\t  struct dwarf2_cu *);\n+\t\t\t\t  struct dwarf2_cu *, bool = false);\n \n static void create_all_comp_units (dwarf2_per_objfile *per_objfile);\n \n@@ -15833,6 +15836,48 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n   smash_to_methodptr_type (type, new_type);\n }\n \n+/* While some versions of GCC will generate complicated DWARF for an\n+   array (see quirk_ada_thick_pointer), more recent versions were\n+   modified to emit an explicit thick pointer structure.  However, in\n+   this case, the array still has DWARF expressions for its ranges,\n+   and these must be ignored.  */\n+\n+static void\n+quirk_ada_thick_pointer_struct (struct die_info *die, struct dwarf2_cu *cu,\n+\t\t\t\tstruct type *type)\n+{\n+  gdb_assert (cu->language == language_ada);\n+\n+  /* Check for a structure with two children.  */\n+  if (type->code () != TYPE_CODE_STRUCT || type->num_fields () != 2)\n+    return;\n+\n+  /* Check for P_ARRAY and P_BOUNDS members.  */\n+  if (TYPE_FIELD_NAME (type, 0) == NULL\n+      || strcmp (TYPE_FIELD_NAME (type, 0), \"P_ARRAY\") != 0\n+      || TYPE_FIELD_NAME (type, 1) == NULL\n+      || strcmp (TYPE_FIELD_NAME (type, 1), \"P_BOUNDS\") != 0)\n+    return;\n+\n+  /* Make sure we're looking at a pointer to an array.  */\n+  if (type->field (0).type ()->code () != TYPE_CODE_PTR)\n+    return;\n+  struct type *ary_type = TYPE_TARGET_TYPE (type->field (0).type ());\n+\n+  while (ary_type->code () == TYPE_CODE_ARRAY)\n+    {\n+      /* The Ada code already knows how to handle these types, so all\n+\t that we need to do is turn the bounds into static bounds.  */\n+      struct type *index_type = ary_type->index_type ();\n+\n+      index_type->bounds ()->low.set_const_val (1);\n+      index_type->bounds ()->high.set_const_val (0);\n+\n+      /* Handle multi-dimensional arrays.  */\n+      ary_type = TYPE_TARGET_TYPE (ary_type);\n+    }\n+}\n+\n /* If the DIE has a DW_AT_alignment attribute, return its value, doing\n    appropriate error checking and issuing complaints if there is a\n    problem.  */\n@@ -16408,6 +16453,8 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n   quirk_gcc_member_function_pointer (type, objfile);\n   if (cu->language == language_rust && die->tag == DW_TAG_union_type)\n     cu->rust_unions.push_back (type);\n+  else if (cu->language == language_ada)\n+    quirk_ada_thick_pointer_struct (die, cu, type);\n \n   /* NOTE: carlton/2004-03-16: GCC 3.4 (or at least one of its\n      snapshots) has been known to create a die giving a declaration\n@@ -16704,6 +16751,263 @@ process_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)\n   new_symbol (die, this_type, cu);\n }\n \n+/* Helper function for quirk_ada_thick_pointer that examines a bounds\n+   expression for an index type and finds the corresponding field\n+   offset in the hidden \"P_BOUNDS\" structure.  Returns true on success\n+   and updates *FIELD, false if it fails to recognize an\n+   expression.  */\n+\n+static bool\n+recognize_bound_expression (struct die_info *die, enum dwarf_attribute name,\n+\t\t\t    int *bounds_offset, struct field *field,\n+\t\t\t    struct dwarf2_cu *cu)\n+{\n+  struct attribute *attr = dwarf2_attr (die, name, cu);\n+  if (attr == nullptr || !attr->form_is_block ())\n+    return false;\n+\n+  const struct dwarf_block *block = attr->as_block ();\n+  const gdb_byte *start = block->data;\n+  const gdb_byte *end = block->data + block->size;\n+\n+  /* The expression to recognize generally looks like:\n+\n+     (DW_OP_push_object_address; DW_OP_plus_uconst: 8; DW_OP_deref;\n+     DW_OP_plus_uconst: 4; DW_OP_deref_size: 4)\n+\n+     However, the second \"plus_uconst\" may be missing:\n+\n+     (DW_OP_push_object_address; DW_OP_plus_uconst: 8; DW_OP_deref;\n+     DW_OP_deref_size: 4)\n+\n+     This happens when the field is at the start of the structure.\n+\n+     Also, the final deref may not be sized:\n+\n+     (DW_OP_push_object_address; DW_OP_plus_uconst: 4; DW_OP_deref;\n+     DW_OP_deref)\n+\n+     This happens when the size of the index type happens to be the\n+     same as the architecture's word size.  This can occur with or\n+     without the second plus_uconst.  */\n+\n+  if (end - start < 2)\n+    return false;\n+  if (*start++ != DW_OP_push_object_address)\n+    return false;\n+  if (*start++ != DW_OP_plus_uconst)\n+    return false;\n+\n+  uint64_t this_bound_off;\n+  start = gdb_read_uleb128 (start, end, &this_bound_off);\n+  if (start == nullptr || (int) this_bound_off != this_bound_off)\n+    return false;\n+  /* Update *BOUNDS_OFFSET if needed, or alternatively verify that it\n+     is consistent among all bounds.  */\n+  if (*bounds_offset == -1)\n+    *bounds_offset = this_bound_off;\n+  else if (*bounds_offset != this_bound_off)\n+    return false;\n+\n+  if (start == end || *start++ != DW_OP_deref)\n+    return false;\n+\n+  int offset = 0;\n+  if (start ==end)\n+    return false;\n+  else if (*start == DW_OP_deref_size || *start == DW_OP_deref)\n+    {\n+      /* This means an offset of 0.  */\n+    }\n+  else if (*start++ != DW_OP_plus_uconst)\n+    return false;\n+  else\n+    {\n+      /* The size is the parameter to DW_OP_plus_uconst.  */\n+      uint64_t val;\n+      start = gdb_read_uleb128 (start, end, &val);\n+      if (start == nullptr)\n+\treturn false;\n+      if ((int) val != val)\n+\treturn false;\n+      offset = val;\n+    }\n+\n+  if (start == end)\n+    return false;\n+\n+  uint64_t size;\n+  if (*start == DW_OP_deref_size)\n+    {\n+      start = gdb_read_uleb128 (start + 1, end, &size);\n+      if (start == nullptr)\n+\treturn false;\n+    }\n+  else if (*start == DW_OP_deref)\n+    {\n+      size = cu->header.addr_size;\n+      ++start;\n+    }\n+  else\n+    return false;\n+\n+  SET_FIELD_BITPOS (*field, 8 * offset);\n+  if (size != TYPE_LENGTH (field->type ()))\n+    FIELD_BITSIZE (*field) = 8 * size;\n+\n+  return true;\n+}\n+\n+/* With -fgnat-encodings=minimal, gcc will emit some unusual DWARF for\n+   some kinds of Ada arrays:\n+\n+   <1><11db>: Abbrev Number: 7 (DW_TAG_array_type)\n+      <11dc>   DW_AT_name        : (indirect string, offset: 0x1bb8): string\n+      <11e0>   DW_AT_data_location: 2 byte block: 97 6\n+\t  (DW_OP_push_object_address; DW_OP_deref)\n+      <11e3>   DW_AT_type        : <0x1173>\n+      <11e7>   DW_AT_sibling     : <0x1201>\n+   <2><11eb>: Abbrev Number: 8 (DW_TAG_subrange_type)\n+      <11ec>   DW_AT_type        : <0x1206>\n+      <11f0>   DW_AT_lower_bound : 6 byte block: 97 23 8 6 94 4\n+\t  (DW_OP_push_object_address; DW_OP_plus_uconst: 8; DW_OP_deref;\n+\t   DW_OP_deref_size: 4)\n+      <11f7>   DW_AT_upper_bound : 8 byte block: 97 23 8 6 23 4 94 4\n+\t  (DW_OP_push_object_address; DW_OP_plus_uconst: 8; DW_OP_deref;\n+\t   DW_OP_plus_uconst: 4; DW_OP_deref_size: 4)\n+\n+   This actually represents a \"thick pointer\", which is a structure\n+   with two elements: one that is a pointer to the array data, and one\n+   that is a pointer to another structure; this second structure holds\n+   the array bounds.\n+\n+   This returns a new type on success, or nullptr if this didn't\n+   recognize the type.  */\n+\n+static struct type *\n+quirk_ada_thick_pointer (struct die_info *die, struct dwarf2_cu *cu,\n+\t\t\t struct type *type)\n+{\n+  struct attribute *attr = dwarf2_attr (die, DW_AT_data_location, cu);\n+  /* So far we've only seen this with block form.  */\n+  if (attr == nullptr || !attr->form_is_block ())\n+    return nullptr;\n+\n+  /* Note that this will fail if the structure layout is changed by\n+     the compiler.  However, we have no good way to recognize some\n+     other layout, because we don't know what expression the compiler\n+     might choose to emit should this happen.  */\n+  struct dwarf_block *blk = attr->as_block ();\n+  if (blk->size != 2\n+      || blk->data[0] != DW_OP_push_object_address\n+      || blk->data[1] != DW_OP_deref)\n+    return nullptr;\n+\n+  int bounds_offset = -1;\n+  int max_align = -1;\n+  std::vector<struct field> range_fields;\n+  for (struct die_info *child_die = die->child;\n+       child_die;\n+       child_die = child_die->sibling)\n+    {\n+      if (child_die->tag == DW_TAG_subrange_type)\n+\t{\n+\t  struct type *underlying = read_subrange_index_type (child_die, cu);\n+\n+\t  int this_align = type_align (underlying);\n+\t  if (this_align > max_align)\n+\t    max_align = this_align;\n+\n+\t  range_fields.emplace_back ();\n+\t  range_fields.emplace_back ();\n+\n+\t  struct field &lower = range_fields[range_fields.size () - 2];\n+\t  struct field &upper = range_fields[range_fields.size () - 1];\n+\n+\t  lower.set_type (underlying);\n+\t  FIELD_ARTIFICIAL (lower) = 1;\n+\n+\t  upper.set_type (underlying);\n+\t  FIELD_ARTIFICIAL (upper) = 1;\n+\n+\t  if (!recognize_bound_expression (child_die, DW_AT_lower_bound,\n+\t\t\t\t\t   &bounds_offset, &lower, cu)\n+\t      || !recognize_bound_expression (child_die, DW_AT_upper_bound,\n+\t\t\t\t\t      &bounds_offset, &upper, cu))\n+\t    return nullptr;\n+\t}\n+    }\n+\n+  /* This shouldn't really happen, but double-check that we found\n+     where the bounds are stored.  */\n+  if (bounds_offset == -1)\n+    return nullptr;\n+\n+  struct objfile *objfile = cu->per_objfile->objfile;\n+  for (int i = 0; i < range_fields.size (); i += 2)\n+    {\n+      char name[20];\n+\n+      /* Set the name of each field in the bounds.  */\n+      xsnprintf (name, sizeof (name), \"LB%d\", i / 2);\n+      FIELD_NAME (range_fields[i]) = objfile->intern (name);\n+      xsnprintf (name, sizeof (name), \"UB%d\", i / 2);\n+      FIELD_NAME (range_fields[i + 1]) = objfile->intern (name);\n+    }\n+\n+  struct type *bounds = alloc_type (objfile);\n+  bounds->set_code (TYPE_CODE_STRUCT);\n+\n+  bounds->set_num_fields (range_fields.size ());\n+  bounds->set_fields\n+    ((struct field *) TYPE_ALLOC (bounds, (bounds->num_fields ()\n+\t\t\t\t\t   * sizeof (struct field))));\n+  memcpy (bounds->fields (), range_fields.data (),\n+\t  bounds->num_fields () * sizeof (struct field));\n+\n+  int last_fieldno = range_fields.size () - 1;\n+  int bounds_size = (TYPE_FIELD_BITPOS (bounds, last_fieldno) / 8\n+\t\t     + TYPE_LENGTH (bounds->field (last_fieldno).type ()));\n+  TYPE_LENGTH (bounds) = align_up (bounds_size, max_align);\n+\n+  /* Rewrite the existing array type in place.  Specifically, we\n+     remove any dynamic properties we might have read, and we replace\n+     the index types.  */\n+  struct type *iter = type;\n+  for (int i = 0; i < range_fields.size (); i += 2)\n+    {\n+      gdb_assert (iter->code () == TYPE_CODE_ARRAY);\n+      iter->main_type->dyn_prop_list = nullptr;\n+      iter->set_index_type\n+\t(create_static_range_type (NULL, bounds->field (i).type (), 1, 0));\n+      iter = TYPE_TARGET_TYPE (iter);\n+    }\n+\n+  struct type *result = alloc_type (objfile);\n+  result->set_code (TYPE_CODE_STRUCT);\n+\n+  result->set_num_fields (2);\n+  result->set_fields\n+    ((struct field *) TYPE_ZALLOC (result, (result->num_fields ()\n+\t\t\t\t\t    * sizeof (struct field))));\n+\n+  /* The names are chosen to coincide with what the compiler does with\n+     -fgnat-encodings=all, which the Ada code in gdb already\n+     understands.  */\n+  TYPE_FIELD_NAME (result, 0) = \"P_ARRAY\";\n+  result->field (0).set_type (lookup_pointer_type (type));\n+\n+  TYPE_FIELD_NAME (result, 1) = \"P_BOUNDS\";\n+  result->field (1).set_type (lookup_pointer_type (bounds));\n+  SET_FIELD_BITPOS (result->field (1), 8 * bounds_offset);\n+\n+  result->set_name (type->name ());\n+  TYPE_LENGTH (result) = (TYPE_LENGTH (result->field (0).type ())\n+\t\t\t  + TYPE_LENGTH (result->field (1).type ()));\n+\n+  return result;\n+}\n+\n /* Extract all information from a DW_TAG_array_type DIE and put it in\n    the DIE's type field.  For now, this only handles one dimensional\n    arrays.  */\n@@ -16833,8 +17137,16 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   maybe_set_alignment (cu, die, type);\n \n+  struct type *replacement_type = nullptr;\n+  if (cu->language == language_ada)\n+    {\n+      replacement_type = quirk_ada_thick_pointer (die, cu, type);\n+      if (replacement_type != nullptr)\n+\ttype = replacement_type;\n+    }\n+\n   /* Install the type in the die.  */\n-  set_die_type (die, type, cu);\n+  set_die_type (die, type, cu, replacement_type != nullptr);\n \n   /* set_die_type should be already done.  */\n   set_descriptive_type (type, die, cu);\n@@ -24431,7 +24743,8 @@ per_cu_offset_and_type_eq (const void *item_lhs, const void *item_rhs)\n      * Make the type as complete as possible before fetching more types.  */\n \n static struct type *\n-set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n+set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n+\t      bool skip_data_location)\n {\n   dwarf2_per_objfile *per_objfile = cu->per_objfile;\n   struct dwarf2_per_cu_offset_and_type **slot, ofs;\n@@ -24474,9 +24787,12 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n     }\n \n   /* Read DW_AT_data_location and set in type.  */\n-  attr = dwarf2_attr (die, DW_AT_data_location, cu);\n-  if (attr_to_dynamic_prop (attr, die, cu, &prop, cu->addr_type ()))\n-    type->add_dyn_prop (DYN_PROP_DATA_LOCATION, prop);\n+  if (!skip_data_location)\n+    {\n+      attr = dwarf2_attr (die, DW_AT_data_location, cu);\n+      if (attr_to_dynamic_prop (attr, die, cu, &prop, cu->addr_type ()))\n+\ttype->add_dyn_prop (DYN_PROP_DATA_LOCATION, prop);\n+    }\n \n   if (per_objfile->die_type_hash == NULL)\n     per_objfile->die_type_hash"
    },
    {
      "sha": "5190920812f0804ef6a13277a69ee6663af7d45d",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -1,3 +1,35 @@\n+2020-11-04  Tom Tromey  <tromey@adacore.com>\n+\n+\t* gdb.ada/O2_float_param.exp: Test different -fgnat-encodings\n+\tvalues.\n+\t* gdb.ada/access_to_unbounded_array.exp: Test different\n+\t-fgnat-encodings values.\n+\t* gdb.ada/big_packed_array.exp: Test different -fgnat-encodings\n+\tvalues.\n+\t* gdb.ada/arr_enum_idx_w_gap.exp: Test different -fgnat-encodings\n+\tvalues.\n+\t* gdb.ada/array_ptr_renaming.exp: Test different -fgnat-encodings\n+\tvalues.\n+\t* gdb.ada/array_of_variable_length.exp: Test different\n+\t-fgnat-encodings values.\n+\t* gdb.ada/arrayparam.exp: Test different -fgnat-encodings values.\n+\t* gdb.ada/arrayptr.exp: Test different -fgnat-encodings values.\n+\t* gdb.ada/frame_arg_lang.exp: Revert -fgnat-encodings=minimal\n+\tchange.\n+\t* gdb.ada/mi_string_access.exp: Test different -fgnat-encodings\n+\tvalues.\n+\t* gdb.ada/mod_from_name.exp: Test different -fgnat-encodings values.\n+\t* gdb.ada/out_of_line_in_inlined.exp: Test different\n+\t-fgnat-encodings values.\n+\t* gdb.ada/packed_array.exp: Test different -fgnat-encodings\n+\tvalues.\n+\t* gdb.ada/pckd_arr_ren.exp: Test different -fgnat-encodings\n+\tvalues.\n+\t* gdb.ada/unc_arr_ptr_in_var_rec.exp: Test different\n+\t-fgnat-encodings values.\n+\t* gdb.ada/variant_record_packed_array.exp: Test different\n+\t-fgnat-encodings values.\n+\n 2020-11-04  Tom Tromey  <tromey@adacore.com>\n \n \t* gdb.ada/enum_idx_packed.exp: Add tests."
    },
    {
      "sha": "debc21c407d587b39106811c0ae5652077ecad9b",
      "filename": "gdb/testsuite/gdb.ada/O2_float_param.exp",
      "status": "modified",
      "additions": 13,
      "deletions": 7,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/O2_float_param.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/O2_float_param.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/O2_float_param.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,13 +19,19 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable {debug optimize=-O2}] != \"\"} {\n-    return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug \\\n+\t\t   optimize=-O2 \\\n+\t\t   additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-runto \"increment\"\n+    runto \"increment\"\n \n-gdb_test \"frame\" \\\n-         \"#0\\\\s+callee\\\\.increment \\\\(val(=val@entry)?=99\\\\.0, msg=\\\\.\\\\.\\\\.\\\\).*\"\n+    gdb_test \"frame\" \\\n+\t\"#0\\\\s+callee\\\\.increment \\\\(val(=val@entry)?=99\\\\.0, msg=\\\\.\\\\.\\\\.\\\\).*\"\n+}"
    },
    {
      "sha": "f3fea4abbebd83b7b2110baa49a2561233d60a0d",
      "filename": "gdb/testsuite/gdb.ada/access_to_unbounded_array.exp",
      "status": "modified",
      "additions": 12,
      "deletions": 8,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/access_to_unbounded_array.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/access_to_unbounded_array.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/access_to_unbounded_array.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,14 +19,18 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug]] != \"\" } {\n-  return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-set bp_location [gdb_get_line_number \"BREAK\" ${testdir}/foo.adb]\n-runto \"foo.adb:$bp_location\"\n+    set bp_location [gdb_get_line_number \"BREAK\" ${testdir}/foo.adb]\n+    runto \"foo.adb:$bp_location\"\n \n-gdb_test \"print Aos(1)\" \" = \\\\(foo.string_access\\\\) $hex\"\n-gdb_test \"print Aos(2)\" \" = \\\\(foo.string_access\\\\) $hex\"\n+    gdb_test \"print Aos(1)\" \" = \\\\(foo.string_access\\\\) $hex\"\n+    gdb_test \"print Aos(2)\" \" = \\\\(foo.string_access\\\\) $hex\"\n+}"
    },
    {
      "sha": "b3a4c0d3d77699c3c9ebeb0ab69b5675d2a61a83",
      "filename": "gdb/testsuite/gdb.ada/arr_enum_idx_w_gap.exp",
      "status": "modified",
      "additions": 15,
      "deletions": 11,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/arr_enum_idx_w_gap.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/arr_enum_idx_w_gap.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/arr_enum_idx_w_gap.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,17 +19,21 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo_q418_043\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug ]] != \"\" } {\n-  return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n \n-clean_restart ${testfile}\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-set bp_location [gdb_get_line_number \"BREAK\" ${testdir}/foo_q418_043.adb]\n-if ![runto \"foo_q418_043.adb:$bp_location\" ] then {\n-  perror \"Couldn't run ${testfile}\"\n-  return\n-}\n+    clean_restart ${testfile}\n \n-gdb_test \"print A\" \\\n-         \" = \\\\(42, 42\\\\)\"\n+    set bp_location [gdb_get_line_number \"BREAK\" ${testdir}/foo_q418_043.adb]\n+    if ![runto \"foo_q418_043.adb:$bp_location\" ] then {\n+\tperror \"Couldn't run ${testfile}\"\n+\treturn\n+    }\n+\n+    gdb_test \"print A\" \\\n+\t\" = \\\\(42, 42\\\\)\"\n+}"
    },
    {
      "sha": "af9cb6f9d0d57bc9c611cc368bf7bec7c7698963",
      "filename": "gdb/testsuite/gdb.ada/array_of_variable_length.exp",
      "status": "modified",
      "additions": 28,
      "deletions": 24,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/array_of_variable_length.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/array_of_variable_length.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/array_of_variable_length.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,28 +19,32 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug]] != \"\" } {\n-  return -1\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n+\n+    clean_restart ${testfile}\n+\n+    set bp_location [gdb_get_line_number \"BREAK\" ${testdir}/foo.adb]\n+    runto \"foo.adb:$bp_location\"\n+\n+    # Pck.A is an array that embeds elements with variable size so compilers will\n+    # emit DWARF attributes such as DW_AT_byte_stride to tell GDB how to fetch\n+    # individual elements.  Array stride is also a way to describe packed arrays:\n+    # make sure we do not consider Pck.A as a packed array.\n+    gdb_test \"ptype pck.a\" \"array \\\\(1 \\\\.\\\\. 2\\\\) of pck\\\\.r_type\"\n+\n+    # Make sure this also works with a type from a fully evaluated value.  During\n+    # evaluation, dynamic types can be \"resolved\" so GDB internals could \"forget\"\n+    # that elements have variable size.  Fortunately, type resolution of array\n+    # elements happens only when processing individual elements (i.e. the resolved\n+    # array type is still associated to the dynamic element type), so the following\n+    # is supposed to work.\n+    gdb_test \"print pck.a\" \\\n+\t\"= \\\\(\\\\(l => 0, s => \\\"\\\"\\\\), \\\\(l => 2, s => \\\"ab\\\"\\\\)\\\\)\"\n+    gdb_test \"ptype $\"\\\n+\t\"array \\\\(1 \\\\.\\\\. 2\\\\) of pck\\\\.r_type\"\n }\n-\n-clean_restart ${testfile}\n-\n-set bp_location [gdb_get_line_number \"BREAK\" ${testdir}/foo.adb]\n-runto \"foo.adb:$bp_location\"\n-\n-# Pck.A is an array that embeds elements with variable size so compilers will\n-# emit DWARF attributes such as DW_AT_byte_stride to tell GDB how to fetch\n-# individual elements.  Array stride is also a way to describe packed arrays:\n-# make sure we do not consider Pck.A as a packed array.\n-gdb_test \"ptype pck.a\" \"array \\\\(1 \\\\.\\\\. 2\\\\) of pck\\\\.r_type\"\n-\n-# Make sure this also works with a type from a fully evaluated value.  During\n-# evaluation, dynamic types can be \"resolved\" so GDB internals could \"forget\"\n-# that elements have variable size.  Fortunately, type resolution of array\n-# elements happens only when processing individual elements (i.e. the resolved\n-# array type is still associated to the dynamic element type), so the following\n-# is supposed to work.\n-gdb_test \"print pck.a\" \\\n-         \"= \\\\(\\\\(l => 0, s => \\\"\\\"\\\\), \\\\(l => 2, s => \\\"ab\\\"\\\\)\\\\)\"\n-gdb_test \"ptype $\"\\\n-         \"array \\\\(1 \\\\.\\\\. 2\\\\) of pck\\\\.r_type\""
    },
    {
      "sha": "81c1a390d2332dbe7b79a399afec41f88a9a0d52",
      "filename": "gdb/testsuite/gdb.ada/array_ptr_renaming.exp",
      "status": "modified",
      "additions": 20,
      "deletions": 16,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/array_ptr_renaming.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/array_ptr_renaming.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/array_ptr_renaming.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,23 +19,27 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug]] != \"\" } {\n-  return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-set bp_location [gdb_get_line_number \"BREAK\" ${testdir}/foo.adb]\n-runto \"foo.adb:$bp_location\"\n+    set bp_location [gdb_get_line_number \"BREAK\" ${testdir}/foo.adb]\n+    runto \"foo.adb:$bp_location\"\n \n-gdb_test \"print nt\"    \" = \\\\(10, 20\\\\)\"\n-gdb_test \"print nt(1)\" \" = 10\"\n+    gdb_test \"print nt\"    \" = \\\\(10, 20\\\\)\"\n+    gdb_test \"print nt(1)\" \" = 10\"\n \n-# Accesses to arrays and unconstrained arrays have the same runtime\n-# representation with GNAT (fat pointers).  In this case, GDB \"forgets\" that\n-# it's dealing with an access and prints directly the array contents.  This\n-# should be fixed some day.\n-setup_kfail \"gdb/25883\" *-*-*\n-gdb_test \"print ntp\"     \" = \\\\(access pack\\\\.table_type\\\\) $hex.*\"\n-gdb_test \"print ntp.all\" \" = \\\\(3 => 30, 40\\\\)\"\n-gdb_test \"print ntp(3)\"  \" = 30\"\n+    # Accesses to arrays and unconstrained arrays have the same runtime\n+    # representation with GNAT (fat pointers).  In this case, GDB \"forgets\" that\n+    # it's dealing with an access and prints directly the array contents.  This\n+    # should be fixed some day.\n+    setup_kfail \"gdb/25883\" *-*-*\n+    gdb_test \"print ntp\"     \" = \\\\(access pack\\\\.table_type\\\\) $hex.*\"\n+    gdb_test \"print ntp.all\" \" = \\\\(3 => 30, 40\\\\)\"\n+    gdb_test \"print ntp(3)\"  \" = 30\"\n+}"
    },
    {
      "sha": "326c9d4aae8e4816ba4a18ce2104020e07679a31",
      "filename": "gdb/testsuite/gdb.ada/arrayparam.exp",
      "status": "modified",
      "additions": 28,
      "deletions": 22,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/arrayparam.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/arrayparam.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/arrayparam.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,34 +19,40 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug]] != \"\" } {\n-  return -1\n-}\n+# Note we don't test the \"none\" (no -fgnat-encodings option) scenario\n+# here, because \"all\" and \"minimal\" cover the cases, and this way we\n+# don't have to update the test when gnat changes its default.\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n \n-clean_restart ${testfile}\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-set bp_location [gdb_get_line_number \"STOP\" ${testdir}/foo.adb]\n-runto \"foo.adb:$bp_location\"\n+    clean_restart ${testfile}\n \n-# Verify that a call to a function that takes an array as a parameter\n-# works without problem.\n+    set bp_location [gdb_get_line_number \"STOP\" ${testdir}/foo.adb]\n+    runto \"foo.adb:$bp_location\"\n \n-gdb_test \"print call_me(\\\"bonjour\\\")\" \\\n-         \"= void\"\n+    # Verify that a call to a function that takes an array as a parameter\n+    # works without problem.\n \n-# Verify that the array was passed properly by checking the global\n-# variables that Call_Me sets as side-effects.  Use the package name to avoid\n-# name clash with debug info of system libraries.\n+    gdb_test \"print call_me(\\\"bonjour\\\")\" \\\n+\t\"= void\"\n \n-gdb_test \"print pck.first\" \\\n-         \"= 98 'b'\" \\\n-         \"print first after function call\"\n+    # Verify that the array was passed properly by checking the global\n+    # variables that Call_Me sets as side-effects.  Use the package name to avoid\n+    # name clash with debug info of system libraries.\n \n-gdb_test \"print pck.last\" \\\n-         \"= 114 'r'\" \\\n-         \"print last after function call\"\n+    gdb_test \"print pck.first\" \\\n+\t\"= 98 'b'\" \\\n+\t\"print first after function call\"\n \n-gdb_test \"print pck.length\" \\\n-         \"= 7\" \\\n-         \"print length after function call\"\n+    gdb_test \"print pck.last\" \\\n+\t\"= 114 'r'\" \\\n+\t\"print last after function call\"\n \n+    gdb_test \"print pck.length\" \\\n+\t\"= 7\" \\\n+\t\"print length after function call\"\n+}"
    },
    {
      "sha": "fa84a7a2ff164ccf33c1569cef0db0946b5ada83",
      "filename": "gdb/testsuite/gdb.ada/arrayptr.exp",
      "status": "modified",
      "additions": 25,
      "deletions": 21,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/arrayptr.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/arrayptr.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/arrayptr.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,36 +19,40 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug ]] != \"\" } {\n-  return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-set bp_location [gdb_get_line_number \"STOP\" ${testdir}/foo.adb]\n-if ![runto \"foo.adb:$bp_location\" ] then {\n-  perror \"Couldn't run ${testfile}\"\n-  return\n-} \n+    set bp_location [gdb_get_line_number \"STOP\" ${testdir}/foo.adb]\n+    if ![runto \"foo.adb:$bp_location\" ] then {\n+\tperror \"Couldn't run ${testfile}\"\n+\treturn\n+    }\n \n-gdb_test \"print string_p\" \\\n-         \"= \\\\(foo\\\\.string_access\\\\) 0x\\[0-9a-zA-Z\\]+\"\n+    gdb_test \"print string_p\" \\\n+\t\"= \\\\(foo\\\\.string_access\\\\) 0x\\[0-9a-zA-Z\\]+\"\n \n-gdb_test \"print string_p(3..4)\" \"= \\\"ll\\\"\"\n+    gdb_test \"print string_p(3..4)\" \"= \\\"ll\\\"\"\n \n-gdb_test \"print null_string\" \"= \\\\(foo\\\\.string_access\\\\) 0x0\"\n+    gdb_test \"print null_string\" \"= \\\\(foo\\\\.string_access\\\\) 0x0\"\n \n-gdb_test \"print arr_ptr\" \"= \\\\(access foo\\\\.little_array\\\\) 0x\\[0-9a-zA-Z\\]+\"\n+    gdb_test \"print arr_ptr\" \"= \\\\(access foo\\\\.little_array\\\\) 0x\\[0-9a-zA-Z\\]+\"\n \n-gdb_test \"print arr_ptr(2)\" \"= 22\"\n+    gdb_test \"print arr_ptr(2)\" \"= 22\"\n \n-gdb_test \"print arr_ptr(3..4)\" \"= \\\\(3 => 23, 24\\\\)\"\n+    gdb_test \"print arr_ptr(3..4)\" \"= \\\\(3 => 23, 24\\\\)\"\n \n-gdb_test \"ptype string_access\" \"= access array \\\\(<>\\\\) of character\"\n+    gdb_test \"ptype string_access\" \"= access array \\\\(<>\\\\) of character\"\n \n-gdb_test \"print pa_ptr.all\" \\\n-         \" = \\\\(10, 20, 30, 40, 50, 60, 62, 63, -23, 42\\\\)\"\n+    gdb_test \"print pa_ptr.all\" \\\n+\t\" = \\\\(10, 20, 30, 40, 50, 60, 62, 63, -23, 42\\\\)\"\n \n-gdb_test \"print pa_ptr(3)\" \" = 30\"\n+    gdb_test \"print pa_ptr(3)\" \" = 30\"\n \n-gdb_test \"print pa_ptr.all(3)\" \" = 30\"\n+    gdb_test \"print pa_ptr.all(3)\" \" = 30\"\n+}"
    },
    {
      "sha": "e24466b9cbeefc6c30dcf5b05b60880bff3e73e7",
      "filename": "gdb/testsuite/gdb.ada/big_packed_array.exp",
      "status": "modified",
      "additions": 14,
      "deletions": 10,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/big_packed_array.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/big_packed_array.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/big_packed_array.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,17 +19,21 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo_ra24_010\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable {debug}] != \"\"} {\n-    return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-set bp_location [gdb_get_line_number \"STOP\" ${testdir}/foo_ra24_010.adb]\n-runto \"foo_ra24_010.adb:$bp_location\"\n+    set bp_location [gdb_get_line_number \"STOP\" ${testdir}/foo_ra24_010.adb]\n+    runto \"foo_ra24_010.adb:$bp_location\"\n \n-gdb_test \"print good\" \\\n-         \"= \\\\(false <repeats 196 times>\\\\)\" \\\n+    gdb_test \"print good\" \\\n+\t\"= \\\\(false <repeats 196 times>\\\\)\" \\\n \n-gdb_test \"print bad\" \\\n-         \"= \\\\(false <repeats 196 times>\\\\)\" \\\n+    gdb_test \"print bad\" \\\n+\t\"= \\\\(false <repeats 196 times>\\\\)\"\n+}"
    },
    {
      "sha": "9668f0e7d9eecad1f64d2277daeb95c6caf34e00",
      "filename": "gdb/testsuite/gdb.ada/frame_arg_lang.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 7,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/frame_arg_lang.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/frame_arg_lang.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/frame_arg_lang.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -69,14 +69,8 @@ foreach_with_prefix scenario {all minimal} {\n \t\"The current source language is \\\"c\\\".\" \\\n \t\"show language when set to 'c'\"\n \n-    # With -fgnat-encodings=minimal, this works properly in C as well.\n-    if {$scenario == \"minimal\"} {\n-\tset expected \"\\\"test\\\"\"\n-    } else {\n-\tset expected \"{P_ARRAY = $hex, P_BOUNDS = $hex}\"\n-    }\n     gdb_test \"bt\" \\\n-\t\"#1  $hex in pck\\\\.call_me \\\\(s=$expected\\\\).*\" \\\n+\t\"#1  $hex in pck\\\\.call_me \\\\(s={P_ARRAY = $hex, P_BOUNDS = $hex}\\\\).*\" \\\n \t\"backtrace with language forced to 'c'\"\n \n     gdb_test_no_output \"set language auto\" \\"
    },
    {
      "sha": "691320b9c1cedf7348353158a9afae09f44124e0",
      "filename": "gdb/testsuite/gdb.ada/mi_string_access.exp",
      "status": "modified",
      "additions": 32,
      "deletions": 28,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/mi_string_access.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/mi_string_access.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/mi_string_access.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,41 +19,45 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile bar\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug]] != \"\" } {\n-  return -1\n-}\n-\n load_lib mi-support.exp\n set MIFLAGS \"-i=mi\"\n \n-mi_clean_restart $binfile\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n \n-if {[mi_runto_main] < 0} {\n-   fail \"cannot run to main, testcase aborted\"\n-   return 0\n-}\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-set bp_location [gdb_get_line_number \"STOP\" ${testdir}/bar.adb]\n-mi_continue_to_line \\\n-    \"bar.adb:$bp_location\" \\\n-    \"stop at start of main Ada procedure\"\n+    mi_clean_restart $binfile\n \n-mi_gdb_test \"-var-create var1 * Aos\" \\\n-    \"\\\\^done,name=\\\"var1\\\",numchild=\\\"2\\\",.*\" \\\n-    \"Create var1 varobj\"\n+    if {[mi_runto_main] < 0} {\n+\tfail \"cannot run to main, testcase aborted\"\n+\treturn 0\n+    }\n \n-mi_gdb_test \"-var-list-children 1 var1\" \\\n-    \"\\\\^done,numchild=\\\"2\\\",children=\\\\\\[child={name=\\\"var1.1\\\",exp=\\\"1\\\",numchild=\\\"1\\\",value=\\\"$hex\\\",type=\\\"bar.string_access\\\",thread-id=\\\"$decimal\\\"},child={name=\\\"var1.2\\\",exp=\\\"2\\\",numchild=\\\"1\\\",value=\\\"$hex\\\",type=\\\"bar.string_access\\\",thread-id=\\\"$decimal\\\"}\\\\\\],has_more=\\\"0\\\"\" \\\n-    \"list var1's children\"\n+    set bp_location [gdb_get_line_number \"STOP\" ${testdir}/bar.adb]\n+    mi_continue_to_line \\\n+\t\"bar.adb:$bp_location\" \\\n+\t\"stop at start of main Ada procedure\"\n \n-mi_gdb_test \"-var-evaluate-expression var1\" \\\n-    \"\\\\^done,value=\\\"\\\\\\[2\\\\\\]\\\"\" \\\n-    \"Print var1\"\n+    mi_gdb_test \"-var-create var1 * Aos\" \\\n+\t\"\\\\^done,name=\\\"var1\\\",numchild=\\\"2\\\",.*\" \\\n+\t\"Create var1 varobj\"\n \n-mi_gdb_test \"-var-evaluate-expression var1.1\" \\\n-    \"\\\\^done,value=\\\"$hex\\\"\" \\\n-    \"Print var1 first child\"\n+    mi_gdb_test \"-var-list-children 1 var1\" \\\n+\t\"\\\\^done,numchild=\\\"2\\\",children=\\\\\\[child={name=\\\"var1.1\\\",exp=\\\"1\\\",numchild=\\\"1\\\",value=\\\"$hex\\\",type=\\\"bar.string_access\\\",thread-id=\\\"$decimal\\\"},child={name=\\\"var1.2\\\",exp=\\\"2\\\",numchild=\\\"1\\\",value=\\\"$hex\\\",type=\\\"bar.string_access\\\",thread-id=\\\"$decimal\\\"}\\\\\\],has_more=\\\"0\\\"\" \\\n+\t\"list var1's children\"\n \n-mi_gdb_test \"-var-evaluate-expression var1.2\" \\\n-    \"\\\\^done,value=\\\"$hex\\\"\" \\\n-    \"Print var1 second child\"\n+    mi_gdb_test \"-var-evaluate-expression var1\" \\\n+\t\"\\\\^done,value=\\\"\\\\\\[2\\\\\\]\\\"\" \\\n+\t\"Print var1\"\n+\n+    mi_gdb_test \"-var-evaluate-expression var1.1\" \\\n+\t\"\\\\^done,value=\\\"$hex\\\"\" \\\n+\t\"Print var1 first child\"\n+\n+    mi_gdb_test \"-var-evaluate-expression var1.2\" \\\n+\t\"\\\\^done,value=\\\"$hex\\\"\" \\\n+\t\"Print var1 second child\"\n+}"
    },
    {
      "sha": "fec383bb4906070c9bc3668ee7a1f536e26eda72",
      "filename": "gdb/testsuite/gdb.ada/mod_from_name.exp",
      "status": "modified",
      "additions": 19,
      "deletions": 11,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/mod_from_name.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/mod_from_name.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/mod_from_name.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,17 +19,25 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug ]] != \"\" } {\n-  return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-set bp_location [gdb_get_line_number \"START\" ${testdir}/foo.adb]\n-if ![runto \"foo.adb:$bp_location\" ] then {\n-  perror \"Couldn't run ${testfile}\"\n-  return\n-} \n+    set bp_location [gdb_get_line_number \"START\" ${testdir}/foo.adb]\n+    if ![runto \"foo.adb:$bp_location\" ] then {\n+\tperror \"Couldn't run ${testfile}\"\n+\treturn\n+    } \n \n-gdb_test \"print xp\" \\\n-         \"= \\\\(y => \\\\(-1, -2, -3, -4, -5, -6, -7, -8, -9, -10\\\\)\\\\)\"\n+    # GNAT >= 11.0 has the needed fix here.\n+    if {$scenario == \"minimal\" && ![test_compiler_info {gcc-1[1-9]-*}]} {\n+\tsetup_kfail \"minimal encodings\" *-*-*\n+    }\n+    gdb_test \"print xp\" \\\n+\t\"= \\\\(y => \\\\(-1, -2, -3, -4, -5, -6, -7, -8, -9, -10\\\\)\\\\)\"\n+}"
    },
    {
      "sha": "7ffb7cb77971468b48a63107c1db4b4272c4087d",
      "filename": "gdb/testsuite/gdb.ada/out_of_line_in_inlined.exp",
      "status": "modified",
      "additions": 20,
      "deletions": 14,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/out_of_line_in_inlined.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/out_of_line_in_inlined.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/out_of_line_in_inlined.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,21 +19,27 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo_o224_021\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable {debug optimize=-O2}] != \"\"} {\n-    return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug \\\n+\t\t   optimize=-O2 \\\n+\t\t   additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-gdb_test \"break foo_o224_021.child1.child2\" \\\n-         \"Breakpoint \\[0-9\\]+ at.*: file .*foo_o224_021.adb, line \\[0-9\\]+.\"\n+    gdb_test \"break foo_o224_021.child1.child2\" \\\n+\t\"Breakpoint \\[0-9\\]+ at.*: file .*foo_o224_021.adb, line \\[0-9\\]+.\"\n \n-gdb_run_cmd\n-gdb_test \"\" \\\n-         \"Breakpoint $decimal, foo_o224_021\\\\.child1\\\\.child2 \\\\(s=\\\\.\\\\.\\\\.\\\\).*\"\n+    gdb_run_cmd\n+    gdb_test \"\" \\\n+\t\"Breakpoint $decimal, foo_o224_021\\\\.child1\\\\.child2 \\\\(s=\\\\.\\\\.\\\\.\\\\).*\"\n \n-set opt_addr_in \"($hex in)?\"\n-gdb_test \"bt\" \\\n-    [multi_line \"#0 +$opt_addr_in +foo_o224_021\\\\.child1\\\\.child2 \\\\(s=\\\\.\\\\.\\\\.\\\\).*\" \\\n-                \"#1 +$opt_addr_in +foo_o224_021\\\\.child1 \\\\(\\\\).*\" \\\n-                \"#2 +$opt_addr_in +foo_o224_021 \\\\(\\\\).*\" ]\n+    set opt_addr_in \"($hex in)?\"\n+    gdb_test \"bt\" \\\n+\t[multi_line \"#0 +$opt_addr_in +foo_o224_021\\\\.child1\\\\.child2 \\\\(s=\\\\.\\\\.\\\\.\\\\).*\" \\\n+\t     \"#1 +$opt_addr_in +foo_o224_021\\\\.child1 \\\\(\\\\).*\" \\\n+\t     \"#2 +$opt_addr_in +foo_o224_021 \\\\(\\\\).*\" ]\n+}"
    },
    {
      "sha": "96613183f6990e04a83740ded3dfdbd2a203fa50",
      "filename": "gdb/testsuite/gdb.ada/packed_array.exp",
      "status": "modified",
      "additions": 29,
      "deletions": 26,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/packed_array.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/packed_array.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/packed_array.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,39 +19,42 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile pa\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable {debug}] != \"\"} {\n-    return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n \n-clean_restart ${testfile}\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-set bp_location [gdb_get_line_number \"STOP\" ${testdir}/pa.adb]\n-runto \"pa.adb:$bp_location\"\n+    clean_restart ${testfile}\n \n-gdb_test \"print var\" \\\n-         \"= \\\\(4 => true, false, true, false, true\\\\)\"\n+    set bp_location [gdb_get_line_number \"STOP\" ${testdir}/pa.adb]\n+    runto \"pa.adb:$bp_location\"\n \n-# Try printing the value and the type definition of a reference\n-# to variable \"Var\".\n+    gdb_test \"print var\" \\\n+\t\"= \\\\(4 => true, false, true, false, true\\\\)\"\n \n-gdb_test \"ptype &var\" \\\n-         \"type = access array \\\\(4 \\\\.\\\\. 8\\\\) of boolean <packed: 1-bit elements>\"\n+    # Try printing the value and the type definition of a reference\n+    # to variable \"Var\".\n \n-gdb_test \"print &var\" \\\n-         \"= \\\\(access pa.packed_array\\\\) 0x.*\"\n+    gdb_test \"ptype &var\" \\\n+\t\"type = access array \\\\(4 \\\\.\\\\. 8\\\\) of boolean <packed: 1-bit elements>\"\n \n-# Print the value of U_Var, an unconstrainted packed array.\n+    gdb_test \"print &var\" \\\n+\t\"= \\\\(access pa.packed_array\\\\) 0x.*\"\n \n-set test \"print u_var\"\n-gdb_test_multiple \"$test\" \"$test\" {\n-    -re \"= \\\\(true, false, false, true, true, false\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n-        pass $test\n-    }\n-    -re \"= \\\\(warning: unable to get bounds of array.*\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n-        # The compiler forgot to emit the packed array's ___XA type,\n-        # preventing us from determining the what the array bounds\n-        # are.  Observed with (FSF GNU Ada 4.5.3 20110124).\n-        xfail $test\n+    # Print the value of U_Var, an unconstrainted packed array.\n+\n+    set test \"print u_var\"\n+    gdb_test_multiple \"$test\" \"$test\" {\n+\t-re \"= \\\\(true, false, false, true, true, false\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n+\t    pass $test\n+\t}\n+\t-re \"= \\\\(warning: unable to get bounds of array.*\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n+\t    # The compiler forgot to emit the packed array's ___XA type,\n+\t    # preventing us from determining the what the array bounds\n+\t    # are.  Observed with (FSF GNU Ada 4.5.3 20110124).\n+\t    xfail $test\n+\t}\n     }\n }\n-"
    },
    {
      "sha": "13e599b6a5889fed34341ca1f69f9a0e1701e59d",
      "filename": "gdb/testsuite/gdb.ada/pckd_arr_ren.exp",
      "status": "modified",
      "additions": 17,
      "deletions": 9,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/pckd_arr_ren.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/pckd_arr_ren.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/pckd_arr_ren.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,15 +19,23 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable {debug}] != \"\"} {\n-    return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-set bp_location [gdb_get_line_number \"STOP\" ${testdir}/foo.adb]\n-runto \"foo.adb:$bp_location\"\n+    set bp_location [gdb_get_line_number \"STOP\" ${testdir}/foo.adb]\n+    runto \"foo.adb:$bp_location\"\n \n-gdb_test \"print A2\" \\\n-         \"= (<ref>\\\\s*)?\\\\(false, false\\\\)\" \\\n-         \"print var\"\n+    # GNAT >= 11.0 has the needed fix here.\n+    if {$scenario == \"minimal\" && ![test_compiler_info {gcc-1[1-9]-*}]} {\n+\tsetup_kfail \"minimal encodings\" *-*-*\n+    }\n+    gdb_test \"print A2\" \\\n+\t\"= (<ref>\\\\s*)?\\\\(false, false\\\\)\" \\\n+\t\"print var\"\n+}"
    },
    {
      "sha": "a7fd4655d48adbd97612c1cf73a1086b3d9d6ee9",
      "filename": "gdb/testsuite/gdb.ada/unc_arr_ptr_in_var_rec.exp",
      "status": "modified",
      "additions": 48,
      "deletions": 44,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/unc_arr_ptr_in_var_rec.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/unc_arr_ptr_in_var_rec.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/unc_arr_ptr_in_var_rec.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,68 +19,72 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug]] != \"\" } {\n-  return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-set bp_location [gdb_get_line_number \"STOP1\" ${testdir}/foo.adb]\n-runto \"foo.adb:$bp_location\"\n+    set bp_location [gdb_get_line_number \"STOP1\" ${testdir}/foo.adb]\n+    runto \"foo.adb:$bp_location\"\n \n-# Print My_Object and My_Object.Ptr when Ptr is null...\n+    # Print My_Object and My_Object.Ptr when Ptr is null...\n \n-gdb_test \"print my_object\" \\\n-         \"= \\\\(n => 3, ptr => 0x0, data => \\\\(3, 5, 8\\\\)\\\\)\" \\\n-         \"print My_Object with null Ptr\"\n+    gdb_test \"print my_object\" \\\n+\t\"= \\\\(n => 3, ptr => 0x0, data => \\\\(3, 5, 8\\\\)\\\\)\" \\\n+\t\"print My_Object with null Ptr\"\n \n-gdb_test \"print my_object.ptr\" \\\n-         \"= \\\\(foo.table_access\\\\) 0x0\" \\\n-         \"print My_Object.Ptr when null\"\n+    gdb_test \"print my_object.ptr\" \\\n+\t\"= \\\\(foo.table_access\\\\) 0x0\" \\\n+\t\"print My_Object.Ptr when null\"\n \n-# Same for My_P_Object...\n+    # Same for My_P_Object...\n \n-gdb_test \"print my_p_object\" \\\n-         \"= \\\\(n => 3, ptr => 0x0, data => \\\\(3, 5, 8\\\\)\\\\)\" \\\n-         \"print My_P_Object with null Ptr\"\n+    gdb_test \"print my_p_object\" \\\n+\t\"= \\\\(n => 3, ptr => 0x0, data => \\\\(3, 5, 8\\\\)\\\\)\" \\\n+\t\"print My_P_Object with null Ptr\"\n \n-gdb_test \"print my_p_object.ptr\" \\\n-         \"\\\\(foo.p_table_access\\\\) 0x0\" \\\n-         \"print My_P_Object.Ptr when null\"\n+    gdb_test \"print my_p_object.ptr\" \\\n+\t\"\\\\(foo.p_table_access\\\\) 0x0\" \\\n+\t\"print My_P_Object.Ptr when null\"\n \n-# Continue until the Ptr component of both objects get allocated.\n+    # Continue until the Ptr component of both objects get allocated.\n \n-set bp_location [gdb_get_line_number \"STOP2\" ${testdir}/foo.adb]\n+    set bp_location [gdb_get_line_number \"STOP2\" ${testdir}/foo.adb]\n \n-gdb_breakpoint \"foo.adb:$bp_location\"\n+    gdb_breakpoint \"foo.adb:$bp_location\"\n \n-gdb_test \"continue\" \\\n-         \"Breakpoint $decimal, foo \\\\(\\\\) at .*foo.adb:$decimal.*\" \\\n-         \"continue to STOP2\"\n+    gdb_test \"continue\" \\\n+\t\"Breakpoint $decimal, foo \\\\(\\\\) at .*foo.adb:$decimal.*\" \\\n+\t\"continue to STOP2\"\n \n-# Inspect My_Object again...\n+    # Inspect My_Object again...\n \n-gdb_test \"print my_object\" \\\n-         \"= \\\\(n => 3, ptr => $hex, data => \\\\(3, 5, 8\\\\)\\\\)\" \\\n-         \"print my_object after setting Ptr\"\n+    gdb_test \"print my_object\" \\\n+\t\"= \\\\(n => 3, ptr => $hex, data => \\\\(3, 5, 8\\\\)\\\\)\" \\\n+\t\"print my_object after setting Ptr\"\n \n-gdb_test \"print my_object.ptr\" \\\n-         \"\\\\(foo.table_access\\\\) $hex\" \\\n-         \"print my_object.ptr when no longer null\"\n+    gdb_test \"print my_object.ptr\" \\\n+\t\"\\\\(foo.table_access\\\\) $hex\" \\\n+\t\"print my_object.ptr when no longer null\"\n \n-gdb_test \"print my_object.ptr.all\" \\\n-         \"= \\\\(13, 21, 34\\\\)\"\n+    gdb_test \"print my_object.ptr.all\" \\\n+\t\"= \\\\(13, 21, 34\\\\)\"\n \n-# Same with My_P_Object...\n+    # Same with My_P_Object...\n \n-gdb_test \"print my_p_object\" \\\n-         \"= \\\\(n => 3, ptr => $hex, data => \\\\(3, 5, 8\\\\)\\\\)\" \\\n-         \"print my_p_object after setting Ptr\"\n+    gdb_test \"print my_p_object\" \\\n+\t\"= \\\\(n => 3, ptr => $hex, data => \\\\(3, 5, 8\\\\)\\\\)\" \\\n+\t\"print my_p_object after setting Ptr\"\n \n-gdb_test \"print my_p_object.ptr\" \\\n-         \"= \\\\(foo.p_table_access\\\\) $hex\" \\\n-         \"print My_P_Object.Ptr when no longer null\"\n+    gdb_test \"print my_p_object.ptr\" \\\n+\t\"= \\\\(foo.p_table_access\\\\) $hex\" \\\n+\t\"print My_P_Object.Ptr when no longer null\"\n \n-gdb_test \"print my_p_object.ptr.all\" \\\n-         \"\\\\(13, 21, 34\\\\)\"\n+    gdb_test \"print my_p_object.ptr.all\" \\\n+\t\"\\\\(13, 21, 34\\\\)\"\n \n+}"
    },
    {
      "sha": "7f10d3dfc06293c639d9ba0d0ea7da8b32608022",
      "filename": "gdb/testsuite/gdb.ada/variant_record_packed_array.exp",
      "status": "modified",
      "additions": 42,
      "deletions": 24,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/variant_record_packed_array.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/575673752cade1772f4a6ba2e38306e5ac9a91f6/gdb/testsuite/gdb.ada/variant_record_packed_array.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/variant_record_packed_array.exp?ref=575673752cade1772f4a6ba2e38306e5ac9a91f6",
      "patch": "@@ -19,35 +19,53 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile foo\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug ]] != \"\" } {\n-  return -1\n-}\n+foreach_with_prefix scenario {all minimal} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$scenario]\n \n-clean_restart ${testfile}\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\"} {\n+\treturn -1\n+    }\n \n-set bp_location [gdb_get_line_number \"START\" ${testdir}/foo.adb]\n-runto \"foo.adb:$bp_location\"\n+    clean_restart ${testfile}\n \n-set test \"print my_buffer\"\n-gdb_test_multiple \"$test\" $test {\n-    -re \"= \\\\(size => 8, buffer => \\\\(1, 2, 3, 4, 5, 6, 7, 0\\\\), length => 8\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n-        pass $test\n-    }\n-    -re \"= \\\\(size => 8, length => 8, buffer => \\\\(1, 2, 3, 4, 5, 6, 7, 0\\\\)\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n-        pass $test\n+    set bp_location [gdb_get_line_number \"START\" ${testdir}/foo.adb]\n+    runto \"foo.adb:$bp_location\"\n+\n+    set test \"print my_buffer\"\n+    gdb_test_multiple \"$test\" $test {\n+\t-re \"= \\\\(size => 8, buffer => \\\\(1, 2, 3, 4, 5, 6, 7, 0\\\\), length => 8\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n+\t    pass $test\n+\t}\n+\t-re \"= \\\\(size => 8, length => 8, buffer => \\\\(1, 2, 3, 4, 5, 6, 7, 0\\\\)\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n+\t    pass $test\n+\t}\n+\t-re \" = \\\\(size => 8, length => 8, buffer => warning: could not find bounds information on packed array.*$gdb_prompt $\" {\n+\t    # GNAT >= 11.0 has the needed fix here.\n+\t    if {$scenario == \"minimal\" && ![test_compiler_info {gcc-1[1-9]-*}]} {\n+\t\tsetup_kfail \"minimal encodings\" *-*-*\n+\t    }\n+\t    fail $test\n+\t}\n     }\n-}\n \n-gdb_test \"print my_buffer'Address\" \\\n-    \"= \\\\(system\\\\.address\\\\) $hex\" \\\n-    \"print address\"\n+    gdb_test \"print my_buffer'Address\" \\\n+\t\"= \\\\(system\\\\.address\\\\) $hex\" \\\n+\t\"print address\"\n \n-set test \"print {foo.octal_buffer}($)\"\n-gdb_test_multiple \"$test\" $test {\n-    -re \"= \\\\(size => 8, buffer => \\\\(1, 2, 3, 4, 5, 6, 7, 0\\\\), length => 8\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n-        pass $test\n-    }\n-    -re \"= \\\\(size => 8, length => 8, buffer => \\\\(1, 2, 3, 4, 5, 6, 7, 0\\\\)\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n-        pass $test\n+    set test \"print {foo.octal_buffer}($)\"\n+    gdb_test_multiple \"$test\" $test {\n+\t-re \"= \\\\(size => 8, buffer => \\\\(1, 2, 3, 4, 5, 6, 7, 0\\\\), length => 8\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n+\t    pass $test\n+\t}\n+\t-re \"= \\\\(size => 8, length => 8, buffer => \\\\(1, 2, 3, 4, 5, 6, 7, 0\\\\)\\\\)\\[\\r\\n\\]+$gdb_prompt $\" {\n+\t    pass $test\n+\t}\n+\t-re \" = \\\\(size => 8, length => 8, buffer => warning: could not find bounds information on packed array.*$gdb_prompt $\" {\n+\t    # GNAT >= 11.0 has the needed fix here.\n+\t    if {$scenario == \"minimal\" && ![test_compiler_info {gcc-1[1-9]-*}]} {\n+\t\tsetup_kfail \"minimal encodings\" *-*-*\n+\t    }\n+\t    fail $test\n+\t}\n     }\n }"
    }
  ]
}