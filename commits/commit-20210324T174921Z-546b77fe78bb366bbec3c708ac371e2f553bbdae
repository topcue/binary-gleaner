{
  "sha": "546b77fe78bb366bbec3c708ac371e2f553bbdae",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTQ2Yjc3ZmU3OGJiMzY2YmJlYzNjNzA4YWMzNzFlMmY1NTNiYmRhZQ==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-06-15T18:34:06Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-03-24T17:49:21Z"
    },
    "message": "GDBserver remote packet support for memory tagging\n\nThis patch adds the generic remote bits to gdbserver so it can check for memory\ntagging support and handle fetch tags and store tags requests.\n\ngdbserver/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* remote-utils.cc (decode_m_packet_params): Renamed from ...\n\t(decode_m_packet): ... this, which now calls decode_m_packet_params.\n\tMake char * param/return const char *.\n\t(decode_M_packet): Use decode_m_packet_params and make char * param\n\tconst char *.\n\t* remote-utils.h (decode_m_packet_params): New prototype.\n\t(decode_m_packet): Constify char pointers.\n\t(decode_M_packet): Likewise.\n\t* server.cc (create_fetch_memtags_reply)\n\t(parse_store_memtags_request): New\n\tfunctions.\n\t(handle_general_set): Handle the QMemTags packet.\n\t(parse_fetch_memtags_request): New function.\n\t(handle_query): Handle the qMemTags packet and advertise memory\n\ttagging support.\n\t(captured_main): Initialize memory tagging flag.\n\t* server.h (struct client_state): Initialize memory tagging flag.\n\t* target.cc (process_stratum_target::supports_memory_tagging)\n\t(process_stratum_target::fetch_memtags)\n\t(process_stratum_target::store_memtags): New methods.\n\t* target.h: Include gdbsupport/byte-vector.h.\n\t(class process_stratum_target) <supports_memory_tagging>\n\t<fetch_memtags, store_memtags>: New class virtual methods.\n\t(target_supports_memory_tagging): Define.",
    "tree": {
      "sha": "83e9a4964c5abe2fce9a3f17de88e257b1533886",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/83e9a4964c5abe2fce9a3f17de88e257b1533886"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/546b77fe78bb366bbec3c708ac371e2f553bbdae",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/546b77fe78bb366bbec3c708ac371e2f553bbdae",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/546b77fe78bb366bbec3c708ac371e2f553bbdae",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/546b77fe78bb366bbec3c708ac371e2f553bbdae/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "754487e200deb9fad3399556e838bb68eedbab18",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/754487e200deb9fad3399556e838bb68eedbab18",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/754487e200deb9fad3399556e838bb68eedbab18"
    }
  ],
  "stats": {
    "total": 265,
    "additions": 240,
    "deletions": 25
  },
  "files": [
    {
      "sha": "f055566d91ab5cd203d99c0125b458bbb3c14625",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=546b77fe78bb366bbec3c708ac371e2f553bbdae",
      "patch": "@@ -1,3 +1,30 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* remote-utils.cc (decode_m_packet_params): Renamed from ...\n+\t(decode_m_packet): ... this, which now calls decode_m_packet_params.\n+\tMake char * param/return const char *.\n+\t(decode_M_packet): Use decode_m_packet_params and make char * param\n+\tconst char *.\n+\t* remote-utils.h (decode_m_packet_params): New prototype.\n+\t(decode_m_packet): Constify char pointers.\n+\t(decode_M_packet): Likewise.\n+\t* server.cc (create_fetch_memtags_reply)\n+\t(parse_store_memtags_request): New\n+\tfunctions.\n+\t(handle_general_set): Handle the QMemTags packet.\n+\t(parse_fetch_memtags_request): New function.\n+\t(handle_query): Handle the qMemTags packet and advertise memory\n+\ttagging support.\n+\t(captured_main): Initialize memory tagging flag.\n+\t* server.h (struct client_state): Initialize memory tagging flag.\n+\t* target.cc (process_stratum_target::supports_memory_tagging)\n+\t(process_stratum_target::fetch_memtags)\n+\t(process_stratum_target::store_memtags): New methods.\n+\t* target.h: Include gdbsupport/byte-vector.h.\n+\t(class process_stratum_target) <supports_memory_tagging>\n+\t<fetch_memtags, store_memtags>: New class virtual methods.\n+\t(target_supports_memory_tagging): Define.\n+\n 2021-03-22  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* inferiors.h (struct process_info) <all_dlls, dlls_changed>: New"
    },
    {
      "sha": "198a75a44760c8e3c0f112253e1fc866aa9c722a",
      "filename": "gdbserver/remote-utils.cc",
      "status": "modified",
      "additions": 19,
      "deletions": 23,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/remote-utils.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/remote-utils.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.cc?ref=546b77fe78bb366bbec3c708ac371e2f553bbdae",
      "patch": "@@ -1308,10 +1308,13 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n     }\n }\n \n-void\n-decode_m_packet (char *from, CORE_ADDR *mem_addr_ptr, unsigned int *len_ptr)\n+/* See remote-utils.h.  */\n+\n+const char *\n+decode_m_packet_params (const char *from, CORE_ADDR *mem_addr_ptr,\n+\t\t\tunsigned int *len_ptr, const char end_marker)\n {\n-  int i = 0, j = 0;\n+  int i = 0;\n   char ch;\n   *mem_addr_ptr = *len_ptr = 0;\n \n@@ -1321,39 +1324,32 @@ decode_m_packet (char *from, CORE_ADDR *mem_addr_ptr, unsigned int *len_ptr)\n       *mem_addr_ptr |= fromhex (ch) & 0x0f;\n     }\n \n-  for (j = 0; j < 4; j++)\n+  while ((ch = from[i++]) != end_marker)\n     {\n-      if ((ch = from[i++]) == 0)\n-\tbreak;\n       *len_ptr = *len_ptr << 4;\n       *len_ptr |= fromhex (ch) & 0x0f;\n     }\n+\n+  return from + i;\n }\n \n void\n-decode_M_packet (char *from, CORE_ADDR *mem_addr_ptr, unsigned int *len_ptr,\n-\t\t unsigned char **to_p)\n+decode_m_packet (const char *from, CORE_ADDR *mem_addr_ptr,\n+\t\t unsigned int *len_ptr)\n {\n-  int i = 0;\n-  char ch;\n-  *mem_addr_ptr = *len_ptr = 0;\n-\n-  while ((ch = from[i++]) != ',')\n-    {\n-      *mem_addr_ptr = *mem_addr_ptr << 4;\n-      *mem_addr_ptr |= fromhex (ch) & 0x0f;\n-    }\n+  decode_m_packet_params (from, mem_addr_ptr, len_ptr, '\\0');\n+}\n \n-  while ((ch = from[i++]) != ':')\n-    {\n-      *len_ptr = *len_ptr << 4;\n-      *len_ptr |= fromhex (ch) & 0x0f;\n-    }\n+void\n+decode_M_packet (const char *from, CORE_ADDR *mem_addr_ptr,\n+\t\t unsigned int *len_ptr, unsigned char **to_p)\n+{\n+  from = decode_m_packet_params (from, mem_addr_ptr, len_ptr, ':');\n \n   if (*to_p == NULL)\n     *to_p = (unsigned char *) xmalloc (*len_ptr);\n \n-  hex2bin (&from[i++], *to_p, *len_ptr);\n+  hex2bin (from, *to_p, *len_ptr);\n }\n \n int"
    },
    {
      "sha": "25074bcc2b95da13ac712b435b87634aaaa8fade",
      "filename": "gdbserver/remote-utils.h",
      "status": "modified",
      "additions": 10,
      "deletions": 2,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/remote-utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/remote-utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.h?ref=546b77fe78bb366bbec3c708ac371e2f553bbdae",
      "patch": "@@ -45,9 +45,17 @@ void prepare_resume_reply (char *buf, ptid_t ptid,\n \n const char *decode_address_to_semicolon (CORE_ADDR *addrp, const char *start);\n void decode_address (CORE_ADDR *addrp, const char *start, int len);\n-void decode_m_packet (char *from, CORE_ADDR * mem_addr_ptr,\n+\n+/* Given an input string FROM, decode MEM_ADDR_PTR, a memory address in hex\n+   form,  and LEN_PTR, a length argument in hex form, from the pattern\n+   \"<MEM_ADDR_PTR>,<LEN_PTR><END_MARKER>\", with END_MARKER being an end marker\n+   character.  */\n+const char *decode_m_packet_params (const char *from, CORE_ADDR *mem_addr_ptr,\n+\t\t\t\t    unsigned int *len_ptr,\n+\t\t\t\t    const char end_marker);\n+void decode_m_packet (const char *from, CORE_ADDR * mem_addr_ptr,\n \t\t      unsigned int *len_ptr);\n-void decode_M_packet (char *from, CORE_ADDR * mem_addr_ptr,\n+void decode_M_packet (const char *from, CORE_ADDR * mem_addr_ptr,\n \t\t      unsigned int *len_ptr, unsigned char **to_p);\n int decode_X_packet (char *from, int packet_len, CORE_ADDR * mem_addr_ptr,\n \t\t     unsigned int *len_ptr, unsigned char **to_p);"
    },
    {
      "sha": "5887133390a2150b8ea6dcee4ff214b61d6b4897",
      "filename": "gdbserver/server.cc",
      "status": "modified",
      "additions": 140,
      "deletions": 0,
      "changes": 140,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/server.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/server.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.cc?ref=546b77fe78bb366bbec3c708ac371e2f553bbdae",
      "patch": "@@ -556,6 +556,64 @@ handle_btrace_conf_general_set (char *own_buf)\n   return 1;\n }\n \n+/* Create the qMemTags packet reply given TAGS.\n+\n+   Returns true if parsing succeeded and false otherwise.  */\n+\n+static bool\n+create_fetch_memtags_reply (char *reply, const gdb::byte_vector &tags)\n+{\n+  /* It is an error to pass a zero-sized tag vector.  */\n+  gdb_assert (tags.size () != 0);\n+\n+  std::string packet (\"m\");\n+\n+  /* Write the tag data.  */\n+  packet += bin2hex (tags.data (), tags.size ());\n+\n+  /* Check if the reply is too big for the packet to handle.  */\n+  if (PBUFSIZ < packet.size ())\n+    return false;\n+\n+  strcpy (reply, packet.c_str ());\n+  return true;\n+}\n+\n+/* Parse the QMemTags request into ADDR, LEN and TAGS.\n+\n+   Returns true if parsing succeeded and false otherwise.  */\n+\n+static bool\n+parse_store_memtags_request (char *request, CORE_ADDR *addr, size_t *len,\n+\t\t\t     gdb::byte_vector &tags, int *type)\n+{\n+  gdb_assert (startswith (request, \"QMemTags:\"));\n+\n+  const char *p = request + strlen (\"QMemTags:\");\n+\n+  /* Read address and length.  */\n+  unsigned int length = 0;\n+  p = decode_m_packet_params (p, addr, &length, ':');\n+  *len = length;\n+\n+  /* Read the tag type.  */\n+  ULONGEST tag_type = 0;\n+  p = unpack_varlen_hex (p, &tag_type);\n+  *type = (int) tag_type;\n+\n+  /* Make sure there is a colon after the type.  */\n+  if (*p != ':')\n+    return false;\n+\n+  /* Skip the colon.  */\n+  p++;\n+\n+  /* Read the tag data.  */\n+  tags = hex2bin (p);\n+\n+  return true;\n+}\n+\n /* Handle all of the extended 'Q' packets.  */\n \n static void\n@@ -912,6 +970,32 @@ handle_general_set (char *own_buf)\n       return;\n     }\n \n+\n+  /* Handle store memory tags packets.  */\n+  if (startswith (own_buf, \"QMemTags:\")\n+      && target_supports_memory_tagging ())\n+    {\n+      gdb::byte_vector tags;\n+      CORE_ADDR addr = 0;\n+      size_t len = 0;\n+      int type = 0;\n+\n+      require_running_or_return (own_buf);\n+\n+      int ret = parse_store_memtags_request (own_buf, &addr, &len, tags,\n+\t\t\t\t\t     &type);\n+\n+      if (ret == 0)\n+\tret = the_target->store_memtags (addr, len, tags, type);\n+\n+      if (ret)\n+\twrite_enn (own_buf);\n+      else\n+\twrite_ok (own_buf);\n+\n+      return;\n+    }\n+\n   /* Otherwise we didn't know what packet it was.  Say we didn't\n      understand it.  */\n   own_buf[0] = 0;\n@@ -2076,6 +2160,27 @@ crc32 (CORE_ADDR base, int len, unsigned int crc)\n   return (unsigned long long) crc;\n }\n \n+/* Parse the qMemTags packet request into ADDR and LEN.  */\n+\n+static void\n+parse_fetch_memtags_request (char *request, CORE_ADDR *addr, size_t *len,\n+\t\t\t     int *type)\n+{\n+  gdb_assert (startswith (request, \"qMemTags:\"));\n+\n+  const char *p = request + strlen (\"qMemTags:\");\n+\n+  /* Read address and length.  */\n+  unsigned int length = 0;\n+  p = decode_m_packet_params (p, addr, &length, ':');\n+  *len = length;\n+\n+  /* Read the tag type.  */\n+  ULONGEST tag_type = 0;\n+  p = unpack_varlen_hex (p, &tag_type);\n+  *type = (int) tag_type;\n+}\n+\n /* Add supported btrace packets to BUF.  */\n \n static void\n@@ -2294,6 +2399,12 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)\n \t\t     events.  */\n \t\t  report_no_resumed = true;\n \t\t}\n+\t      else if (feature == \"memory-tagging+\")\n+\t\t{\n+\t\t  /* GDB supports memory tagging features.  */\n+\t\t  if (target_supports_memory_tagging ())\n+\t\t    cs.memory_tagging_feature = true;\n+\t\t}\n \t      else\n \t\t{\n \t\t  /* Move the unknown features all together.  */\n@@ -2411,6 +2522,9 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)\n \n       strcat (own_buf, \";no-resumed+\");\n \n+      if (target_supports_memory_tagging ())\n+\tstrcat (own_buf, \";memory-tagging+\");\n+\n       /* Reinitialize components as needed for the new connection.  */\n       hostio_handle_new_gdb_connection ();\n       target_handle_new_gdb_connection ();\n@@ -2603,6 +2717,31 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)\n   if (target_supports_tracepoints () && handle_tracepoint_query (own_buf))\n     return;\n \n+  /* Handle fetch memory tags packets.  */\n+  if (startswith (own_buf, \"qMemTags:\")\n+      && target_supports_memory_tagging ())\n+    {\n+      gdb::byte_vector tags;\n+      CORE_ADDR addr = 0;\n+      size_t len = 0;\n+      int type = 0;\n+\n+      require_running_or_return (own_buf);\n+\n+      parse_fetch_memtags_request (own_buf, &addr, &len, &type);\n+\n+      int ret = the_target->fetch_memtags (addr, len, tags, type);\n+\n+      if (ret)\n+\tret = create_fetch_memtags_reply (own_buf, tags);\n+\n+      if (ret)\n+\twrite_enn (own_buf);\n+\n+      *new_packet_len_p = strlen (own_buf);\n+      return;\n+    }\n+\n   /* Otherwise we didn't know what packet it was.  Say we didn't\n      understand it.  */\n   own_buf[0] = 0;\n@@ -3822,6 +3961,7 @@ captured_main (int argc, char *argv[])\n       cs.swbreak_feature = 0;\n       cs.hwbreak_feature = 0;\n       cs.vCont_supported = 0;\n+      cs.memory_tagging_feature = false;\n \n       remote_open (port);\n "
    },
    {
      "sha": "3e280732a89600ff8f53d656d30257eb48a13e2d",
      "filename": "gdbserver/server.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/server.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/server.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.h?ref=546b77fe78bb366bbec3c708ac371e2f553bbdae",
      "patch": "@@ -190,6 +190,9 @@ struct client_state\n \n   int current_traceframe = -1;\n \n+  /* If true, memory tagging features are supported.  */\n+  bool memory_tagging_feature = false;\n+\n };\n \n client_state &get_client_state ();"
    },
    {
      "sha": "1f2159714b3df80cd6965765eb07c2ed713bb0ba",
      "filename": "gdbserver/target.cc",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/target.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/target.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/target.cc?ref=546b77fe78bb366bbec3c708ac371e2f553bbdae",
      "patch": "@@ -464,6 +464,26 @@ process_stratum_target::supports_read_offsets ()\n   return false;\n }\n \n+bool\n+process_stratum_target::supports_memory_tagging ()\n+{\n+  return false;\n+}\n+\n+bool\n+process_stratum_target::fetch_memtags (CORE_ADDR address, size_t len,\n+\t\t\t\t       gdb::byte_vector &tags, int type)\n+{\n+  gdb_assert_not_reached (\"target op fetch_memtags not supported\");\n+}\n+\n+bool\n+process_stratum_target::store_memtags (CORE_ADDR address, size_t len,\n+\t\t\t\t       const gdb::byte_vector &tags, int type)\n+{\n+  gdb_assert_not_reached (\"target op store_memtags not supported\");\n+}\n+\n int\n process_stratum_target::read_offsets (CORE_ADDR *text, CORE_ADDR *data)\n {"
    },
    {
      "sha": "2831a6ce7c028b92ff91d2787625a1e494a7ef6b",
      "filename": "gdbserver/target.h",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/546b77fe78bb366bbec3c708ac371e2f553bbdae/gdbserver/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/target.h?ref=546b77fe78bb366bbec3c708ac371e2f553bbdae",
      "patch": "@@ -30,6 +30,7 @@\n #include \"gdbsupport/array-view.h\"\n #include \"gdbsupport/btrace-common.h\"\n #include <vector>\n+#include \"gdbsupport/byte-vector.h\"\n \n struct emit_ops;\n struct buffer;\n@@ -499,6 +500,23 @@ class process_stratum_target\n \n   /* Return tdesc index for IPA.  */\n   virtual int get_ipa_tdesc_idx ();\n+\n+  /* Returns true if the target supports memory tagging facilities.  */\n+  virtual bool supports_memory_tagging ();\n+\n+  /* Return the allocated memory tags of type TYPE associated with\n+     [ADDRESS, ADDRESS + LEN) in TAGS.\n+\n+     Returns true if successful and false otherwise.  */\n+  virtual bool fetch_memtags (CORE_ADDR address, size_t len,\n+\t\t\t      gdb::byte_vector &tags, int type);\n+\n+  /* Write the allocation tags of type TYPE contained in TAGS to the\n+     memory range [ADDRESS, ADDRESS + LEN).\n+\n+     Returns true if successful and false otherwise.  */\n+  virtual bool store_memtags (CORE_ADDR address, size_t len,\n+\t\t\t      const gdb::byte_vector &tags, int type);\n };\n \n extern process_stratum_target *the_target;\n@@ -525,6 +543,9 @@ int kill_inferior (process_info *proc);\n #define target_supports_exec_events() \\\n   the_target->supports_exec_events ()\n \n+#define target_supports_memory_tagging() \\\n+  the_target->supports_memory_tagging ()\n+\n #define target_handle_new_gdb_connection()\t\t \\\n   the_target->handle_new_gdb_connection ()\n "
    }
  ]
}