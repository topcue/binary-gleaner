{
  "sha": "5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTUzN2Y5YjlhM2M0NmMzODk4ZTI3NGE1MmY2YmIwZWI4ZDI5M2JiOA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-07-13T19:40:52Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-10-03T16:04:55Z"
    },
    "message": "libctf: write CTF files to memory, and CTF archives to fds\n\nBefore now, we've been able to write CTF files to gzFile descriptors or\nfds, and CTF archives to named files only.\n\nMake this a bit less irregular by allowing CTF archives to be written\nto fds with the new function ctf_arc_write_fd: also allow CTF\nfiles to be written to a new memory buffer via ctf_write_mem.\n\n(It would be nice to complete things by adding a new function to write\nCTF archives to memory, but this is too difficult to do given the short\ntime the linker is expected to be writing them out: we will transition\nto a better format in format v4, though we will always support reading\nCTF archives that are stored in .ctf sections.)\n\ninclude/\n\t* ctf-api.h (ctf_arc_write_fd): New.\n\t(ctf_write_mem): Likewise.\n\t(ctf_gzwrite): Spacing fix.\n\nlibctf/\n\t* ctf-archive.c (ctf_arc_write): Split off, and reimplement in terms\n\tof...\n\t(ctf_arc_write_fd): ... this new function.\n\t* ctf-create.c (ctf_write_mem): New.",
    "tree": {
      "sha": "3d1ac035f2c596d2fe567637f99f7380faab4ca6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3d1ac035f2c596d2fe567637f99f7380faab4ca6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d851ecd373a3764581372b10be5b74c9ee98ae08",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d851ecd373a3764581372b10be5b74c9ee98ae08",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d851ecd373a3764581372b10be5b74c9ee98ae08"
    }
  ],
  "stats": {
    "total": 168,
    "additions": 132,
    "deletions": 36
  },
  "files": [
    {
      "sha": "ddc5667341fbf19588c6667dbb116ea11f26e033",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
      "patch": "@@ -1,3 +1,9 @@\n+2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_arc_write_fd): New.\n+\t(ctf_write_mem): Likewise.\n+\t(ctf_gzwrite): Spacing fix.\n+\n 2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf.h (CTF_SET_STID): New."
    },
    {
      "sha": "2bee08bc1fd0e8ab3998a63983e4903146e3ccf1",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
      "patch": "@@ -258,6 +258,8 @@ extern void ctf_file_close (ctf_file_t *);\n \n extern int ctf_arc_write (const char *, ctf_file_t **, size_t,\n \t\t\t  const char **, size_t);\n+extern int ctf_arc_write_fd (int, ctf_file_t **, size_t, const char **,\n+\t\t\t     size_t);\n \n extern const char *ctf_cuname (ctf_file_t *);\n extern void ctf_cuname_set (ctf_file_t *, const char *);\n@@ -379,8 +381,9 @@ extern ctf_snapshot_id_t ctf_snapshot (ctf_file_t *);\n extern int ctf_rollback (ctf_file_t *, ctf_snapshot_id_t);\n extern int ctf_discard (ctf_file_t *);\n extern int ctf_write (ctf_file_t *, int);\n-extern int ctf_gzwrite (ctf_file_t * fp, gzFile fd);\n+extern int ctf_gzwrite (ctf_file_t *fp, gzFile fd);\n extern int ctf_compress_write (ctf_file_t * fp, int fd);\n+extern unsigned char *ctf_write_mem (ctf_file_t *, size_t *, size_t threshold);\n \n extern void ctf_setdebug (int debug);\n extern int ctf_getdebug (void);"
    },
    {
      "sha": "04939431173bb5aea69d7b26275969643b125a23",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
      "patch": "@@ -1,3 +1,10 @@\n+2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-archive.c (ctf_arc_write): Split off, and reimplement in terms\n+\tof...\n+\t(ctf_arc_write_fd): ... this new function.\n+\t* ctf-create.c (ctf_write_mem): New.\n+\n 2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.h (ctf_str_atom_t) <csa_offset>: New field."
    },
    {
      "sha": "8de11d6d583e8a892623b8d125d31b30d563429a",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 64,
      "deletions": 35,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
      "patch": "@@ -47,17 +47,17 @@ static int arc_mmap_unmap (void *header, size_t headersz, const char **errmsg);\n /* bsearch() internal state.  */\n static __thread char *search_nametbl;\n \n-/* Write out a CTF archive.  The entries in CTF_FILES are referenced by name:\n-   the names are passed in the names array, which must have CTF_FILES entries.\n+/* Write out a CTF archive to the start of the file referenced by the passed-in\n+   fd.  The entries in CTF_FILES are referenced by name: the names are passed in\n+   the names array, which must have CTF_FILES entries.\n \n    Returns 0 on success, or an errno, or an ECTF_* value.  */\n int\n-ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n-\t       const char **names, size_t threshold)\n+ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n+\t\t  const char **names, size_t threshold)\n {\n   const char *errmsg;\n   struct ctf_archive *archdr;\n-  int fd;\n   size_t i;\n   char dummy = 0;\n   size_t headersz;\n@@ -68,15 +68,9 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n   off_t nameoffs;\n   struct ctf_archive_modent *modent;\n \n-  ctf_dprintf (\"Writing archive %s with %lu files\\n\", file,\n+  ctf_dprintf (\"Writing CTF archive with %lu files\\n\",\n \t       (unsigned long) ctf_file_cnt);\n \n-  if ((fd = open (file, O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, 0666)) < 0)\n-    {\n-      errmsg = \"ctf_arc_write(): cannot create %s: %s\\n\";\n-      goto err;\n-    }\n-\n   /* Figure out the size of the mmap()ed header, including the\n      ctf_archive_modent array.  We assume that all of this needs no\n      padding: a likely assumption, given that it's all made up of\n@@ -91,20 +85,20 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n   ctf_startoffs = headersz;\n   if (lseek (fd, ctf_startoffs - 1, SEEK_SET) < 0)\n     {\n-      errmsg = \"ctf_arc_write(): cannot extend file while writing %s: %s\\n\";\n-      goto err_close;\n+      errmsg = \"ctf_arc_write(): cannot extend file while writing: %s\\n\";\n+      goto err;\n     }\n \n   if (write (fd, &dummy, 1) < 0)\n     {\n-      errmsg = \"ctf_arc_write(): cannot extend file while writing %s: %s\\n\";\n-      goto err_close;\n+      errmsg = \"ctf_arc_write(): cannot extend file while writing: %s\\n\";\n+      goto err;\n     }\n \n   if ((archdr = arc_mmap_header (fd, headersz)) == NULL)\n     {\n-      errmsg = \"ctf_arc_write(): Cannot mmap() %s: %s\\n\";\n-      goto err_close;\n+      errmsg = \"ctf_arc_write(): Cannot mmap(): %s\\n\";\n+      goto err;\n     }\n \n   /* Fill in everything we can, which is everything other than the name\n@@ -137,7 +131,7 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n   nametbl = malloc (namesz);\n   if (nametbl == NULL)\n     {\n-      errmsg = \"Error writing named CTF to %s: %s\\n\";\n+      errmsg = \"Error writing named CTF to archive: %s\\n\";\n       goto err_unmap;\n     }\n \n@@ -154,12 +148,12 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n       if ((off < 0) && (off > -ECTF_BASE))\n \t{\n \t  errmsg = \"ctf_arc_write(): Cannot determine file \"\n-\t    \"position while writing %s: %s\";\n+\t    \"position while writing to archive: %s\";\n \t  goto err_free;\n \t}\n       if (off < 0)\n \t{\n-\t  errmsg = \"ctf_arc_write(): Cannot write CTF file to %s: %s\\n\";\n+\t  errmsg = \"ctf_arc_write(): Cannot write CTF file to archive: %s\\n\";\n \t  errno = off * -1;\n \t  goto err_free;\n \t}\n@@ -181,7 +175,7 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n   if ((nameoffs = lseek (fd, 0, SEEK_CUR)) < 0)\n     {\n       errmsg = \"ctf_arc_write(): Cannot get current file position \"\n-\t\"in %s: %s\\n\";\n+\t\"in archive: %s\\n\";\n       goto err_free;\n     }\n   archdr->ctfa_names = htole64 (nameoffs);\n@@ -191,7 +185,7 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n       ssize_t len;\n       if ((len = write (fd, np, namesz)) < 0)\n \t{\n-\t  errmsg = \"ctf_arc_write(): Cannot write name table in %s: %s\\n\";\n+\t  errmsg = \"ctf_arc_write(): Cannot write name table to archive: %s\\n\";\n \t  goto err_free;\n \t}\n       namesz -= len;\n@@ -202,29 +196,64 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n   if (arc_mmap_writeout (fd, archdr, headersz, &errmsg) < 0)\n     goto err_unmap;\n   if (arc_mmap_unmap (archdr, headersz, &errmsg) < 0)\n-    goto err_unlink;\n-  if (close (fd) < 0)\n-    {\n-      errmsg = \"ctf_arc_write(): Cannot close after writing to %s: %s\\n\";\n-      goto err_unlink;\n-    }\n-\n+    goto err;\n   return 0;\n \n err_free:\n   free (nametbl);\n err_unmap:\n   arc_mmap_unmap (archdr, headersz, NULL);\n-err_close:\n-  close (fd);\n-err_unlink:\n-  unlink (file);\n err:\n-  ctf_dprintf (errmsg, file, errno < ECTF_BASE ? strerror (errno) :\n+  ctf_dprintf (errmsg, errno < ECTF_BASE ? strerror (errno) :\n \t       ctf_errmsg (errno));\n   return errno;\n }\n \n+/* Write out a CTF archive.  The entries in CTF_FILES are referenced by name:\n+   the names are passed in the names array, which must have CTF_FILES entries.\n+\n+   If the filename is NULL, create a temporary file and return a pointer to it.\n+\n+   Returns 0 on success, or an errno, or an ECTF_* value.  */\n+int\n+ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n+\t       const char **names, size_t threshold)\n+{\n+  int err;\n+  int fd;\n+\n+  if ((fd = open (file, O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, 0666)) < 0)\n+    {\n+      ctf_dprintf (\"ctf_arc_write(): cannot create %s: %s\\n\", file,\n+\t\t   strerror (errno));\n+      return errno;\n+    }\n+\n+  err = ctf_arc_write_fd (fd, ctf_files, ctf_file_cnt, names, threshold);\n+  if (err)\n+    goto err;\n+\n+  if ((err = close (fd)) < 0)\n+    {\n+      ctf_dprintf (\"ctf_arc_write(): Cannot close after writing to archive: \"\n+\t\t   \"%s\\n\", strerror (errno));\n+      goto err_close;\n+    }\n+\n+ err:\n+  close (fd);\n+  if (err < 0)\n+    unlink (file);\n+\n+  return err;\n+\n+ err_close:\n+  if (err < 0)\n+    unlink (file);\n+\n+  return err;\n+}\n+\n /* Write one CTF file out.  Return the file position of the written file (or\n    rather, of the file-size uint64_t that precedes it): negative return is a\n    negative errno or ctf_errno value.  On error, the file position may no longer"
    },
    {
      "sha": "09cd8d57a52daceb1de91ef5ea8ed69239428132",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=5537f9b9a3c46c3898e274a52f6bb0eb8d293bb8",
      "patch": "@@ -2029,6 +2029,57 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n   return err;\n }\n \n+/* Optionally compress the specified CTF data stream and return it as a new\n+   dynamically-allocated string.  */\n+unsigned char *\n+ctf_write_mem (ctf_file_t *fp, size_t *size, size_t threshold)\n+{\n+  unsigned char *buf;\n+  unsigned char *bp;\n+  ctf_header_t *hp;\n+  ssize_t header_len = sizeof (ctf_header_t);\n+  ssize_t compress_len;\n+  size_t max_compress_len = compressBound (fp->ctf_size);\n+  int rc;\n+\n+  if (fp->ctf_size < threshold)\n+    max_compress_len = fp->ctf_size;\n+  if ((buf = malloc (max_compress_len\n+\t\t     + sizeof (struct ctf_header))) == NULL)\n+    {\n+      ctf_set_errno (fp, ENOMEM);\n+      return NULL;\n+    }\n+\n+  hp = (ctf_header_t *) buf;\n+  memcpy (hp, fp->ctf_header, header_len);\n+  bp = buf + sizeof (struct ctf_header);\n+  *size = sizeof (struct ctf_header);\n+\n+  compress_len = max_compress_len;\n+\n+  if (fp->ctf_size < threshold)\n+    {\n+      hp->cth_flags &= ~CTF_F_COMPRESS;\n+      memcpy (bp, fp->ctf_buf, fp->ctf_size);\n+      *size += fp->ctf_size;\n+    }\n+  else\n+    {\n+      hp->cth_flags |= CTF_F_COMPRESS;\n+      if ((rc = compress (bp, (uLongf *) &compress_len,\n+\t\t\t  fp->ctf_buf, fp->ctf_size)) != Z_OK)\n+\t{\n+\t  ctf_dprintf (\"zlib deflate err: %s\\n\", zError (rc));\n+\t  ctf_set_errno (fp, ECTF_COMPRESS);\n+\t  ctf_free (buf);\n+\t  return NULL;\n+\t}\n+      *size += compress_len;\n+    }\n+  return buf;\n+}\n+\n /* Write the uncompressed CTF data stream to the specified file descriptor.  */\n int\n ctf_write (ctf_file_t *fp, int fd)"
    }
  ]
}