{
  "sha": "72d383bb08c3d09f77921e2b3f52569116bbf41e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzJkMzgzYmIwOGMzZDA5Zjc3OTIxZTJiM2Y1MjU2OTExNmJiZjQxZQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-02-03T19:36:54Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-02-03T19:37:27Z"
    },
    "message": "gdb: infrun: move stop_soon variable to inner scoped in handle_inferior_event\n\nMoving it to an inner scope makes it clearer where it's used (only while\nhandling the TARGET_WAITKIND_LOADED event).\n\ngdb/ChangeLog:\n\n\t* infrun.c (handle_inferior_event): Move stop_soon variable to\n\tinner scope.\n\nChange-Id: Ic57685a21714cfbb38f1487ee96cea1d12b44652",
    "tree": {
      "sha": "7c8e2be4fb433c88fcf3056863cab09e91744a4d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7c8e2be4fb433c88fcf3056863cab09e91744a4d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/72d383bb08c3d09f77921e2b3f52569116bbf41e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72d383bb08c3d09f77921e2b3f52569116bbf41e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/72d383bb08c3d09f77921e2b3f52569116bbf41e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72d383bb08c3d09f77921e2b3f52569116bbf41e/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "61ecbbae8eb1d161316380ca0175912f414725ce",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/61ecbbae8eb1d161316380ca0175912f414725ce",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/61ecbbae8eb1d161316380ca0175912f414725ce"
    }
  ],
  "stats": {
    "total": 137,
    "additions": 71,
    "deletions": 66
  },
  "files": [
    {
      "sha": "4ac326be1639ea5e3f5c63781cd585bbb501a40e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72d383bb08c3d09f77921e2b3f52569116bbf41e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72d383bb08c3d09f77921e2b3f52569116bbf41e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=72d383bb08c3d09f77921e2b3f52569116bbf41e",
      "patch": "@@ -1,3 +1,8 @@\n+2021-02-03  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* infrun.c (handle_inferior_event): Move stop_soon variable to\n+\tinner scope.\n+\n 2021-02-03  Pedro Alves  <pedro@palves.net>\n \n \t* infcmd.c (detach_command): Hold strong reference to target, and"
    },
    {
      "sha": "6ec269adaa8c5b127197ff85615f26ea15de9d15",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 66,
      "deletions": 66,
      "changes": 132,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72d383bb08c3d09f77921e2b3f52569116bbf41e/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72d383bb08c3d09f77921e2b3f52569116bbf41e/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=72d383bb08c3d09f77921e2b3f52569116bbf41e",
      "patch": "@@ -5023,8 +5023,6 @@ handle_inferior_event (struct execution_control_state *ecs)\n      end.  */\n   scoped_value_mark free_values;\n \n-  enum stop_kind stop_soon;\n-\n   infrun_debug_printf (\"%s\", target_waitstatus_to_string (&ecs->ws).c_str ());\n \n   if (ecs->ws.kind == TARGET_WAITKIND_IGNORE)\n@@ -5118,80 +5116,82 @@ handle_inferior_event (struct execution_control_state *ecs)\n   switch (ecs->ws.kind)\n     {\n     case TARGET_WAITKIND_LOADED:\n-      context_switch (ecs);\n-      /* Ignore gracefully during startup of the inferior, as it might\n-\t be the shell which has just loaded some objects, otherwise\n-\t add the symbols for the newly loaded objects.  Also ignore at\n-\t the beginning of an attach or remote session; we will query\n-\t the full list of libraries once the connection is\n-\t established.  */\n-\n-      stop_soon = get_inferior_stop_soon (ecs);\n-      if (stop_soon == NO_STOP_QUIETLY)\n-\t{\n-\t  struct regcache *regcache;\n-\n-\t  regcache = get_thread_regcache (ecs->event_thread);\n+      {\n+\tcontext_switch (ecs);\n+\t/* Ignore gracefully during startup of the inferior, as it might\n+\t   be the shell which has just loaded some objects, otherwise\n+\t   add the symbols for the newly loaded objects.  Also ignore at\n+\t   the beginning of an attach or remote session; we will query\n+\t   the full list of libraries once the connection is\n+\t   established.  */\n+\n+\tstop_kind stop_soon = get_inferior_stop_soon (ecs);\n+\tif (stop_soon == NO_STOP_QUIETLY)\n+\t  {\n+\t    struct regcache *regcache;\n \n-\t  handle_solib_event ();\n+\t    regcache = get_thread_regcache (ecs->event_thread);\n \n-\t  ecs->event_thread->control.stop_bpstat\n-\t    = bpstat_stop_status (regcache->aspace (),\n-\t\t\t\t  ecs->event_thread->suspend.stop_pc,\n-\t\t\t\t  ecs->event_thread, &ecs->ws);\n+\t    handle_solib_event ();\n \n-\t  if (handle_stop_requested (ecs))\n-\t    return;\n+\t    ecs->event_thread->control.stop_bpstat\n+\t      = bpstat_stop_status (regcache->aspace (),\n+\t\t\t\t    ecs->event_thread->suspend.stop_pc,\n+\t\t\t\t    ecs->event_thread, &ecs->ws);\n \n-\t  if (bpstat_causes_stop (ecs->event_thread->control.stop_bpstat))\n-\t    {\n-\t      /* A catchpoint triggered.  */\n-\t      process_event_stop_test (ecs);\n+\t    if (handle_stop_requested (ecs))\n \t      return;\n-\t    }\n \n-\t  /* If requested, stop when the dynamic linker notifies\n-\t     gdb of events.  This allows the user to get control\n-\t     and place breakpoints in initializer routines for\n-\t     dynamically loaded objects (among other things).  */\n-\t  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n-\t  if (stop_on_solib_events)\n-\t    {\n-\t      /* Make sure we print \"Stopped due to solib-event\" in\n-\t\t normal_stop.  */\n-\t      stop_print_frame = true;\n+\t    if (bpstat_causes_stop (ecs->event_thread->control.stop_bpstat))\n+\t      {\n+\t\t/* A catchpoint triggered.  */\n+\t\tprocess_event_stop_test (ecs);\n+\t\treturn;\n+\t      }\n \n-\t      stop_waiting (ecs);\n-\t      return;\n-\t    }\n-\t}\n+\t    /* If requested, stop when the dynamic linker notifies\n+\t       gdb of events.  This allows the user to get control\n+\t       and place breakpoints in initializer routines for\n+\t       dynamically loaded objects (among other things).  */\n+\t    ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+\t    if (stop_on_solib_events)\n+\t      {\n+\t\t/* Make sure we print \"Stopped due to solib-event\" in\n+\t\t   normal_stop.  */\n+\t\tstop_print_frame = true;\n \n-      /* If we are skipping through a shell, or through shared library\n-\t loading that we aren't interested in, resume the program.  If\n-\t we're running the program normally, also resume.  */\n-      if (stop_soon == STOP_QUIETLY || stop_soon == NO_STOP_QUIETLY)\n-\t{\n-\t  /* Loading of shared libraries might have changed breakpoint\n-\t     addresses.  Make sure new breakpoints are inserted.  */\n-\t  if (stop_soon == NO_STOP_QUIETLY)\n-\t    insert_breakpoints ();\n-\t  resume (GDB_SIGNAL_0);\n-\t  prepare_to_wait (ecs);\n-\t  return;\n-\t}\n+\t\tstop_waiting (ecs);\n+\t\treturn;\n+\t      }\n+\t  }\n \n-      /* But stop if we're attaching or setting up a remote\n-\t connection.  */\n-      if (stop_soon == STOP_QUIETLY_NO_SIGSTOP\n-\t  || stop_soon == STOP_QUIETLY_REMOTE)\n-\t{\n-\t  infrun_debug_printf (\"quietly stopped\");\n-\t  stop_waiting (ecs);\n-\t  return;\n-\t}\n+\t/* If we are skipping through a shell, or through shared library\n+\t   loading that we aren't interested in, resume the program.  If\n+\t   we're running the program normally, also resume.  */\n+\tif (stop_soon == STOP_QUIETLY || stop_soon == NO_STOP_QUIETLY)\n+\t  {\n+\t    /* Loading of shared libraries might have changed breakpoint\n+\t       addresses.  Make sure new breakpoints are inserted.  */\n+\t    if (stop_soon == NO_STOP_QUIETLY)\n+\t      insert_breakpoints ();\n+\t    resume (GDB_SIGNAL_0);\n+\t    prepare_to_wait (ecs);\n+\t    return;\n+\t  }\n \n-      internal_error (__FILE__, __LINE__,\n-\t\t      _(\"unhandled stop_soon: %d\"), (int) stop_soon);\n+\t/* But stop if we're attaching or setting up a remote\n+\t   connection.  */\n+\tif (stop_soon == STOP_QUIETLY_NO_SIGSTOP\n+\t    || stop_soon == STOP_QUIETLY_REMOTE)\n+\t  {\n+\t    infrun_debug_printf (\"quietly stopped\");\n+\t    stop_waiting (ecs);\n+\t    return;\n+\t  }\n+\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"unhandled stop_soon: %d\"), (int) stop_soon);\n+      }\n \n     case TARGET_WAITKIND_SPURIOUS:\n       if (handle_stop_requested (ecs))"
    }
  ]
}