{
  "sha": "b70e516e89d95d06252cb04ded3397ec0a0a3212",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjcwZTUxNmU4OWQ5NWQwNjI1MmNiMDRkZWQzMzk3ZWMwYTBhMzIxMg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-20T14:11:09Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-20T14:11:09Z"
    },
    "message": "gdb: handle the `ptid.is_pid ()` case in registers_changed_ptid\n\nAs reported by Tom here [1], commit 888bdb2b7445 (\"gdb: change regcache\nlist to be a map\") overlooked an important case, causing a regression.\nWhen registers_changed_ptid is called with a pid-like ptid, it used to\nclear all the regcaches for that pid.  That commit accidentally removed\nthat behavior.  We need to handle the `ptid.is_pid ()` case in\nregisters_changed_ptid.\n\nThe most trivial way of fixing it would be to iterate on all ptids of a\ntarget and delete the entries where the ptid match the pid.  But the\npoint of that commit was to avoid having to iterate on ptids to\ninvalidate regcaches, so that would feel like a step backwards.\n\nThe only logical solution I see is to add yet another map level, so that\nwe now have:\n\n  target -> (pid -> (ptid -> regcaches))\n\nThis patch implements that and adds a test for the case of calling\nregisters_changed_ptid with a pid-like ptid.\n\n[1] https://sourceware.org/pipermail/gdb-patches/2020-August/171222.html\n\ngdb/ChangeLog:\n\n\t* regcache.c (pid_ptid_regcache_map): New type.\n\t(target_ptid_regcache_map): Remove.\n\t(target_pid_ptid_regcache_map): New type.\n\t(regcaches): Change type to target_pid_ptid_regcache_map.\n\t(get_thread_arch_aspace_regcache): Update.\n\t(regcache_thread_ptid_changed): Update, handle pid-like ptid\n\tcase.\n\t(regcaches_size): Update.\n\t(regcache_count): Update.\n\t(registers_changed_ptid_target_pid_test): New.\n\t(_initialize_regcache): Register new test.\n\nChange-Id: I4c46e26d8225c177dbac9488b549eff4c68fa0d8",
    "tree": {
      "sha": "50e2b293b918bb21db07528bef0165e8ab7a6125",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/50e2b293b918bb21db07528bef0165e8ab7a6125"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b70e516e89d95d06252cb04ded3397ec0a0a3212",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b70e516e89d95d06252cb04ded3397ec0a0a3212",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b70e516e89d95d06252cb04ded3397ec0a0a3212",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b70e516e89d95d06252cb04ded3397ec0a0a3212/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cdd9148a19e9c0acb99ef0908671f60ea9ad69bc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cdd9148a19e9c0acb99ef0908671f60ea9ad69bc"
    }
  ],
  "stats": {
    "total": 144,
    "additions": 119,
    "deletions": 25
  },
  "files": [
    {
      "sha": "70a8f643fb1155180a7b1447938f82526abf7287",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b70e516e89d95d06252cb04ded3397ec0a0a3212/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b70e516e89d95d06252cb04ded3397ec0a0a3212/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b70e516e89d95d06252cb04ded3397ec0a0a3212",
      "patch": "@@ -1,3 +1,17 @@\n+2020-08-20  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* regcache.c (pid_ptid_regcache_map): New type.\n+\t(target_ptid_regcache_map): Remove.\n+\t(target_pid_ptid_regcache_map): New type.\n+\t(regcaches): Change type to target_pid_ptid_regcache_map.\n+\t(get_thread_arch_aspace_regcache): Update.\n+\t(regcache_thread_ptid_changed): Update, handle pid-like ptid\n+\tcase.\n+\t(regcaches_size): Update.\n+\t(regcache_count): Update.\n+\t(registers_changed_ptid_target_pid_test): New.\n+\t(_initialize_regcache): Register new test.\n+\n 2020-08-20  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* regcache.c (regcache_count): New."
    },
    {
      "sha": "91d3202b94baa87573c1b903bd6759dd83f99981",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 105,
      "deletions": 25,
      "changes": 130,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b70e516e89d95d06252cb04ded3397ec0a0a3212/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b70e516e89d95d06252cb04ded3397ec0a0a3212/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=b70e516e89d95d06252cb04ded3397ec0a0a3212",
      "patch": "@@ -319,19 +319,22 @@ reg_buffer::assert_regnum (int regnum) const\n using ptid_regcache_map\n   = std::unordered_multimap<ptid_t, regcache_up, hash_ptid>;\n \n-/* Type to map a target to a ptid_regcache_map, holding the regcaches for the\n-   threads defined by that target.  */\n+/* Type holding regcaches for a given pid.  */\n \n-using target_ptid_regcache_map\n-  = std::unordered_map<process_stratum_target *, ptid_regcache_map>;\n+using pid_ptid_regcache_map = std::unordered_map<int, ptid_regcache_map>;\n+\n+/* Type holding regcaches for a given target.  */\n+\n+using target_pid_ptid_regcache_map\n+  = std::unordered_map<process_stratum_target *, pid_ptid_regcache_map>;\n \n /* Global structure containing the existing regcaches.  */\n \n /* NOTE: this is a write-through cache.  There is no \"dirty\" bit for\n    recording if the register values have been changed (eg. by the\n    user).  Therefore all registers must be written back to the\n    target when appropriate.  */\n-static target_ptid_regcache_map regcaches;\n+static target_pid_ptid_regcache_map regcaches;\n \n struct regcache *\n get_thread_arch_aspace_regcache (process_stratum_target *target,\n@@ -340,8 +343,11 @@ get_thread_arch_aspace_regcache (process_stratum_target *target,\n {\n   gdb_assert (target != nullptr);\n \n-  /* Find the ptid -> regcache map for this target.  */\n-  auto &ptid_regc_map = regcaches[target];\n+  /* Find the map for this target.  */\n+  pid_ptid_regcache_map &pid_ptid_regc_map = regcaches[target];\n+\n+  /* Find the map for this pid.  */\n+  ptid_regcache_map &ptid_regc_map = pid_ptid_regc_map[ptid.pid ()];\n \n   /* Check first if a regcache for this arch already exists.  */\n   auto range = ptid_regc_map.equal_range (ptid);\n@@ -436,12 +442,19 @@ static void\n regcache_thread_ptid_changed (process_stratum_target *target,\n \t\t\t      ptid_t old_ptid, ptid_t new_ptid)\n {\n-  auto ptid_regc_map_it = regcaches.find (target);\n+  /* Look up map for target.  */\n+  auto pid_ptid_regc_map_it = regcaches.find (target);\n+  if (pid_ptid_regc_map_it == regcaches.end ())\n+    return;\n \n-  if (ptid_regc_map_it == regcaches.end ())\n+ /* Look up map for pid.  */\n+  pid_ptid_regcache_map &pid_ptid_regc_map = pid_ptid_regc_map_it->second;\n+  auto ptid_regc_map_it = pid_ptid_regc_map.find (old_ptid.pid ());\n+  if (ptid_regc_map_it == pid_ptid_regc_map.end ())\n     return;\n \n-  auto &ptid_regc_map = ptid_regc_map_it->second;\n+  /* Update all regcaches belonging to old_ptid.  */\n+  ptid_regcache_map &ptid_regc_map = ptid_regc_map_it->second;\n   auto range = ptid_regc_map.equal_range (old_ptid);\n   for (auto it = range.first; it != range.second;)\n     {\n@@ -478,15 +491,43 @@ registers_changed_ptid (process_stratum_target *target, ptid_t ptid)\n       /* Delete all the regcaches of all targets.  */\n       regcaches.clear ();\n     }\n+  else if (ptid.is_pid ())\n+    {\n+      /* Non-NULL target and pid ptid, delete all regcaches belonging\n+\t to this (TARGET, PID).  */\n+\n+      /* Look up map for target.  */\n+      auto pid_ptid_regc_map_it = regcaches.find (target);\n+      if (pid_ptid_regc_map_it != regcaches.end ())\n+\t{\n+\t  pid_ptid_regcache_map &pid_ptid_regc_map\n+\t    = pid_ptid_regc_map_it->second;\n+\n+\t  pid_ptid_regc_map.erase (ptid.pid ());\n+\t}\n+    }\n   else if (ptid != minus_one_ptid)\n     {\n       /* Non-NULL target and non-minus_one_ptid, delete all regcaches belonging\n-\tto this (TARGET, PTID).  */\n-      auto ptid_regc_map_it = regcaches.find (target);\n-      if (ptid_regc_map_it != regcaches.end ())\n+\t to this (TARGET, PTID).  */\n+\n+      /* Look up map for target.  */\n+      auto pid_ptid_regc_map_it = regcaches.find (target);\n+      if (pid_ptid_regc_map_it != regcaches.end ())\n \t{\n-\t  auto &ptid_regc_map = ptid_regc_map_it->second;\n-\t  ptid_regc_map.erase (ptid);\n+\t  pid_ptid_regcache_map &pid_ptid_regc_map\n+\t    = pid_ptid_regc_map_it->second;\n+\n+\t  /* Look up map for pid.  */\n+\t  auto ptid_regc_map_it\n+\t    = pid_ptid_regc_map.find (ptid.pid ());\n+\t  if (ptid_regc_map_it != pid_ptid_regc_map.end ())\n+\t    {\n+\t      ptid_regcache_map &ptid_regc_map\n+\t\t= ptid_regc_map_it->second;\n+\n+\t      ptid_regc_map.erase (ptid);\n+\t    }\n \t}\n     }\n   else\n@@ -1479,10 +1520,23 @@ static size_t\n regcaches_size ()\n {\n   size_t size = 0;\n-  for (auto it = regcaches.begin (); it != regcaches.end (); ++it)\n+\n+  for (auto pid_ptid_regc_map_it = regcaches.cbegin ();\n+       pid_ptid_regc_map_it != regcaches.cend ();\n+       ++pid_ptid_regc_map_it)\n     {\n-      auto &ptid_regc_map = it->second;\n-      size += ptid_regc_map.size ();\n+      const pid_ptid_regcache_map &pid_ptid_regc_map\n+\t= pid_ptid_regc_map_it->second;\n+\n+      for (auto ptid_regc_map_it = pid_ptid_regc_map.cbegin ();\n+\t   ptid_regc_map_it != pid_ptid_regc_map.cend ();\n+\t   ++ptid_regc_map_it)\n+\t{\n+\t  const ptid_regcache_map &ptid_regc_map\n+\t    = ptid_regc_map_it->second;\n+\n+\t  size += ptid_regc_map.size ();\n+\t}\n     }\n \n   return size;\n@@ -1493,13 +1547,21 @@ regcaches_size ()\n static int\n regcache_count (process_stratum_target *target, ptid_t ptid)\n {\n-  auto ptid_regc_map_it = regcaches.find (target);\n-  if (ptid_regc_map_it != regcaches.end ())\n+  /* Look up map for target.  */\n+  auto pid_ptid_regc_map_it = regcaches.find (target);\n+  if (pid_ptid_regc_map_it != regcaches.end ())\n     {\n-      auto &ptid_regc_map = ptid_regc_map_it->second;\n-      auto range = ptid_regc_map.equal_range (ptid);\n+      pid_ptid_regcache_map &pid_ptid_regc_map = pid_ptid_regc_map_it->second;\n \n-      return std::distance (range.first, range.second);\n+      /* Look map for pid.  */\n+      auto ptid_regc_map_it = pid_ptid_regc_map.find (ptid.pid ());\n+      if (ptid_regc_map_it != pid_ptid_regc_map.end ())\n+\t{\n+\t  ptid_regcache_map &ptid_regc_map = ptid_regc_map_it->second;\n+\t  auto range = ptid_regc_map.equal_range (ptid);\n+\n+\t  return std::distance (range.first, range.second);\n+\t}\n     }\n \n   return 0;\n@@ -1622,6 +1684,22 @@ registers_changed_ptid_target_test ()\n   SELF_CHECK (regcache_count (&data->test_target2, ptid_t (2, 2)) == 1);\n }\n \n+/* Test marking regcaches of a specific (target, pid) as changed.  */\n+\n+static void\n+registers_changed_ptid_target_pid_test ()\n+{\n+  regcache_test_data_up data = populate_regcaches_for_test ();\n+\n+  registers_changed_ptid (&data->test_target1, ptid_t (2));\n+  SELF_CHECK (regcaches_size () == 9);\n+\n+  /* Regcaches from target1 should not exist, while regcaches from target2\n+     should exist.  */\n+  SELF_CHECK (regcache_count (&data->test_target1, ptid_t (2, 2)) == 0);\n+  SELF_CHECK (regcache_count (&data->test_target2, ptid_t (2, 2)) == 1);\n+}\n+\n /* Test marking regcaches of a specific (target, ptid) as changed.  */\n \n static void\n@@ -2012,10 +2090,12 @@ _initialize_regcache ()\n   \t\t\t    selftests::get_thread_arch_aspace_regcache_test);\n   selftests::register_test (\"registers_changed_ptid_all\",\n \t\t\t    selftests::registers_changed_ptid_all_test);\n+  selftests::register_test (\"registers_changed_ptid_target\",\n+  \t\t\t    selftests::registers_changed_ptid_target_test);\n+  selftests::register_test (\"registers_changed_ptid_target_pid\",\n+  \t\t\t    selftests::registers_changed_ptid_target_pid_test);\n   selftests::register_test (\"registers_changed_ptid_target_ptid\",\n \t\t\t    selftests::registers_changed_ptid_target_ptid_test);\n-  selftests::register_test (\"registers_changed_ptid_target\",\n-\t\t\t    selftests::registers_changed_ptid_target_test);\n \n   selftests::register_test_foreach_arch (\"regcache::cooked_read_test\",\n \t\t\t\t\t selftests::cooked_read_test);"
    }
  ]
}