{
  "sha": "de8e4cb3af98396ecad849588c9c05a45a9e823c",
  "node_id": "C_kwDOANOeidoAKGRlOGU0Y2IzYWY5ODM5NmVjYWQ4NDk1ODhjOWMwNWE0NWE5ZTgyM2M",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-12T23:13:23Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-18T17:34:05Z"
    },
    "message": "Move \"catch exec\" to a new file\n\nThe \"catch exec\" code is reasonably self-contained, and so this patch\nmoves it out of breakpoint.c (the second largest source file in gdb)\nand into a new file, break-catch-exec.c.",
    "tree": {
      "sha": "1212f1c140f166fb3b13586ee70855276f766967",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1212f1c140f166fb3b13586ee70855276f766967"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/de8e4cb3af98396ecad849588c9c05a45a9e823c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/de8e4cb3af98396ecad849588c9c05a45a9e823c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/de8e4cb3af98396ecad849588c9c05a45a9e823c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/de8e4cb3af98396ecad849588c9c05a45a9e823c/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34"
    }
  ],
  "stats": {
    "total": 428,
    "additions": 237,
    "deletions": 191
  },
  "files": [
    {
      "sha": "3efd2227698cd230874170005bfe6124aeaea73a",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/de8e4cb3af98396ecad849588c9c05a45a9e823c/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/de8e4cb3af98396ecad849588c9c05a45a9e823c/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=de8e4cb3af98396ecad849588c9c05a45a9e823c",
      "patch": "@@ -999,6 +999,7 @@ COMMON_SFILES = \\\n \tbfd-target.c \\\n \tblock.c \\\n \tblockframe.c \\\n+\tbreak-catch-exec.c \\\n \tbreak-catch-fork.c \\\n \tbreak-catch-sig.c \\\n \tbreak-catch-syscall.c \\"
    },
    {
      "sha": "c0cf2aeb3b5b529ec5dc9b2bdc58f905a01fac6b",
      "filename": "gdb/break-catch-exec.c",
      "status": "added",
      "additions": 236,
      "deletions": 0,
      "changes": 236,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/de8e4cb3af98396ecad849588c9c05a45a9e823c/gdb/break-catch-exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/de8e4cb3af98396ecad849588c9c05a45a9e823c/gdb/break-catch-exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-exec.c?ref=de8e4cb3af98396ecad849588c9c05a45a9e823c",
      "patch": "@@ -0,0 +1,236 @@\n+/* Everything about exec catchpoints, for GDB.\n+\n+   Copyright (C) 1986-2022 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+\n+#include \"annotate.h\"\n+#include \"arch-utils.h\"\n+#include \"breakpoint.h\"\n+#include \"cli/cli-decode.h\"\n+#include \"inferior.h\"\n+#include \"mi/mi-common.h\"\n+#include \"target.h\"\n+#include \"valprint.h\"\n+\n+/* Exec catchpoints.  */\n+\n+/* An instance of this type is used to represent an exec catchpoint.\n+   A breakpoint is really of this type iff its ops pointer points to\n+   CATCH_EXEC_BREAKPOINT_OPS.  */\n+\n+struct exec_catchpoint : public breakpoint\n+{\n+  /* Filename of a program whose exec triggered this catchpoint.\n+     This field is only valid immediately after this catchpoint has\n+     triggered.  */\n+  gdb::unique_xmalloc_ptr<char> exec_pathname;\n+};\n+\n+static int\n+insert_catch_exec (struct bp_location *bl)\n+{\n+  return target_insert_exec_catchpoint (inferior_ptid.pid ());\n+}\n+\n+static int\n+remove_catch_exec (struct bp_location *bl, enum remove_bp_reason reason)\n+{\n+  return target_remove_exec_catchpoint (inferior_ptid.pid ());\n+}\n+\n+static int\n+breakpoint_hit_catch_exec (const struct bp_location *bl,\n+\t\t\t   const address_space *aspace, CORE_ADDR bp_addr,\n+\t\t\t   const target_waitstatus &ws)\n+{\n+  struct exec_catchpoint *c = (struct exec_catchpoint *) bl->owner;\n+\n+  if (ws.kind () != TARGET_WAITKIND_EXECD)\n+    return 0;\n+\n+  c->exec_pathname = make_unique_xstrdup (ws.execd_pathname ());\n+  return 1;\n+}\n+\n+static enum print_stop_action\n+print_it_catch_exec (bpstat *bs)\n+{\n+  struct ui_out *uiout = current_uiout;\n+  struct breakpoint *b = bs->breakpoint_at;\n+  struct exec_catchpoint *c = (struct exec_catchpoint *) b;\n+\n+  annotate_catchpoint (b->number);\n+  maybe_print_thread_hit_breakpoint (uiout);\n+  if (b->disposition == disp_del)\n+    uiout->text (\"Temporary catchpoint \");\n+  else\n+    uiout->text (\"Catchpoint \");\n+  if (uiout->is_mi_like_p ())\n+    {\n+      uiout->field_string (\"reason\", async_reason_lookup (EXEC_ASYNC_EXEC));\n+      uiout->field_string (\"disp\", bpdisp_text (b->disposition));\n+    }\n+  uiout->field_signed (\"bkptno\", b->number);\n+  uiout->text (\" (exec'd \");\n+  uiout->field_string (\"new-exec\", c->exec_pathname.get ());\n+  uiout->text (\"), \");\n+\n+  return PRINT_SRC_AND_LOC;\n+}\n+\n+static void\n+print_one_catch_exec (struct breakpoint *b, struct bp_location **last_loc)\n+{\n+  struct exec_catchpoint *c = (struct exec_catchpoint *) b;\n+  struct value_print_options opts;\n+  struct ui_out *uiout = current_uiout;\n+\n+  get_user_print_options (&opts);\n+\n+  /* Field 4, the address, is omitted (which makes the columns\n+     not line up too nicely with the headers, but the effect\n+     is relatively readable).  */\n+  if (opts.addressprint)\n+    uiout->field_skip (\"addr\");\n+  annotate_field (5);\n+  uiout->text (\"exec\");\n+  if (c->exec_pathname != NULL)\n+    {\n+      uiout->text (\", program \\\"\");\n+      uiout->field_string (\"what\", c->exec_pathname.get ());\n+      uiout->text (\"\\\" \");\n+    }\n+\n+  if (uiout->is_mi_like_p ())\n+    uiout->field_string (\"catch-type\", \"exec\");\n+}\n+\n+static void\n+print_mention_catch_exec (struct breakpoint *b)\n+{\n+  printf_filtered (_(\"Catchpoint %d (exec)\"), b->number);\n+}\n+\n+/* Implement the \"print_recreate\" breakpoint_ops method for exec\n+   catchpoints.  */\n+\n+static void\n+print_recreate_catch_exec (struct breakpoint *b, struct ui_file *fp)\n+{\n+  fprintf_unfiltered (fp, \"catch exec\");\n+  print_recreate_thread (b, fp);\n+}\n+\n+static struct breakpoint_ops catch_exec_breakpoint_ops;\n+\n+/* This function attempts to parse an optional \"if <cond>\" clause\n+   from the arg string.  If one is not found, it returns NULL.\n+\n+   Else, it returns a pointer to the condition string.  (It does not\n+   attempt to evaluate the string against a particular block.)  And,\n+   it updates arg to point to the first character following the parsed\n+   if clause in the arg string.  */\n+\n+const char *\n+ep_parse_optional_if_clause (const char **arg)\n+{\n+  const char *cond_string;\n+\n+  if (((*arg)[0] != 'i') || ((*arg)[1] != 'f') || !isspace ((*arg)[2]))\n+    return NULL;\n+\n+  /* Skip the \"if\" keyword.  */\n+  (*arg) += 2;\n+\n+  /* Skip any extra leading whitespace, and record the start of the\n+     condition string.  */\n+  *arg = skip_spaces (*arg);\n+  cond_string = *arg;\n+\n+  /* Assume that the condition occupies the remainder of the arg\n+     string.  */\n+  (*arg) += strlen (cond_string);\n+\n+  return cond_string;\n+}\n+\n+/* Commands to deal with catching events, such as signals, exceptions,\n+   process start/exit, etc.  */\n+\n+static void\n+catch_exec_command_1 (const char *arg, int from_tty,\n+\t\t      struct cmd_list_element *command)\n+{\n+  struct gdbarch *gdbarch = get_current_arch ();\n+  const char *cond_string = NULL;\n+  bool temp = command->context () == CATCH_TEMPORARY;\n+\n+  if (!arg)\n+    arg = \"\";\n+  arg = skip_spaces (arg);\n+\n+  /* The allowed syntax is:\n+     catch exec\n+     catch exec if <cond>\n+\n+     First, check if there's an if clause.  */\n+  cond_string = ep_parse_optional_if_clause (&arg);\n+\n+  if ((*arg != '\\0') && !isspace (*arg))\n+    error (_(\"Junk at end of arguments.\"));\n+\n+  std::unique_ptr<exec_catchpoint> c (new exec_catchpoint ());\n+  init_catchpoint (c.get (), gdbarch, temp, cond_string,\n+\t\t   &catch_exec_breakpoint_ops);\n+  c->exec_pathname.reset ();\n+\n+  install_breakpoint (0, std::move (c), 1);\n+}\n+\n+static void\n+initialize_ops ()\n+{\n+  struct breakpoint_ops *ops;\n+\n+  initialize_breakpoint_ops ();\n+\n+  /* Exec catchpoints.  */\n+  ops = &catch_exec_breakpoint_ops;\n+  *ops = base_breakpoint_ops;\n+  ops->insert_location = insert_catch_exec;\n+  ops->remove_location = remove_catch_exec;\n+  ops->breakpoint_hit = breakpoint_hit_catch_exec;\n+  ops->print_it = print_it_catch_exec;\n+  ops->print_one = print_one_catch_exec;\n+  ops->print_mention = print_mention_catch_exec;\n+  ops->print_recreate = print_recreate_catch_exec;\n+}\n+\n+void _initialize_break_catch_exec ();\n+void\n+_initialize_break_catch_exec ()\n+{\n+  initialize_ops ();\n+\n+  add_catch_command (\"exec\", _(\"Catch calls to exec.\"),\n+\t\t     catch_exec_command_1,\n+\t\t     NULL,\n+\t\t     CATCH_PERMANENT,\n+\t\t     CATCH_TEMPORARY);\n+}"
    },
    {
      "sha": "1812bfe42f9291386200f41c8caafcb46a17b736",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 191,
      "changes": 191,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/de8e4cb3af98396ecad849588c9c05a45a9e823c/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/de8e4cb3af98396ecad849588c9c05a45a9e823c/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=de8e4cb3af98396ecad849588c9c05a45a9e823c",
      "patch": "@@ -7986,117 +7986,6 @@ install_breakpoint (int internal, std::unique_ptr<breakpoint> &&arg, int update_\n     update_global_location_list (UGLL_MAY_INSERT);\n }\n \n-/* Exec catchpoints.  */\n-\n-/* An instance of this type is used to represent an exec catchpoint.\n-   A breakpoint is really of this type iff its ops pointer points to\n-   CATCH_EXEC_BREAKPOINT_OPS.  */\n-\n-struct exec_catchpoint : public breakpoint\n-{\n-  /* Filename of a program whose exec triggered this catchpoint.\n-     This field is only valid immediately after this catchpoint has\n-     triggered.  */\n-  gdb::unique_xmalloc_ptr<char> exec_pathname;\n-};\n-\n-static int\n-insert_catch_exec (struct bp_location *bl)\n-{\n-  return target_insert_exec_catchpoint (inferior_ptid.pid ());\n-}\n-\n-static int\n-remove_catch_exec (struct bp_location *bl, enum remove_bp_reason reason)\n-{\n-  return target_remove_exec_catchpoint (inferior_ptid.pid ());\n-}\n-\n-static int\n-breakpoint_hit_catch_exec (const struct bp_location *bl,\n-\t\t\t   const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t   const target_waitstatus &ws)\n-{\n-  struct exec_catchpoint *c = (struct exec_catchpoint *) bl->owner;\n-\n-  if (ws.kind () != TARGET_WAITKIND_EXECD)\n-    return 0;\n-\n-  c->exec_pathname = make_unique_xstrdup (ws.execd_pathname ());\n-  return 1;\n-}\n-\n-static enum print_stop_action\n-print_it_catch_exec (bpstat *bs)\n-{\n-  struct ui_out *uiout = current_uiout;\n-  struct breakpoint *b = bs->breakpoint_at;\n-  struct exec_catchpoint *c = (struct exec_catchpoint *) b;\n-\n-  annotate_catchpoint (b->number);\n-  maybe_print_thread_hit_breakpoint (uiout);\n-  if (b->disposition == disp_del)\n-    uiout->text (\"Temporary catchpoint \");\n-  else\n-    uiout->text (\"Catchpoint \");\n-  if (uiout->is_mi_like_p ())\n-    {\n-      uiout->field_string (\"reason\", async_reason_lookup (EXEC_ASYNC_EXEC));\n-      uiout->field_string (\"disp\", bpdisp_text (b->disposition));\n-    }\n-  uiout->field_signed (\"bkptno\", b->number);\n-  uiout->text (\" (exec'd \");\n-  uiout->field_string (\"new-exec\", c->exec_pathname.get ());\n-  uiout->text (\"), \");\n-\n-  return PRINT_SRC_AND_LOC;\n-}\n-\n-static void\n-print_one_catch_exec (struct breakpoint *b, struct bp_location **last_loc)\n-{\n-  struct exec_catchpoint *c = (struct exec_catchpoint *) b;\n-  struct value_print_options opts;\n-  struct ui_out *uiout = current_uiout;\n-\n-  get_user_print_options (&opts);\n-\n-  /* Field 4, the address, is omitted (which makes the columns\n-     not line up too nicely with the headers, but the effect\n-     is relatively readable).  */\n-  if (opts.addressprint)\n-    uiout->field_skip (\"addr\");\n-  annotate_field (5);\n-  uiout->text (\"exec\");\n-  if (c->exec_pathname != NULL)\n-    {\n-      uiout->text (\", program \\\"\");\n-      uiout->field_string (\"what\", c->exec_pathname.get ());\n-      uiout->text (\"\\\" \");\n-    }\n-\n-  if (uiout->is_mi_like_p ())\n-    uiout->field_string (\"catch-type\", \"exec\");\n-}\n-\n-static void\n-print_mention_catch_exec (struct breakpoint *b)\n-{\n-  printf_filtered (_(\"Catchpoint %d (exec)\"), b->number);\n-}\n-\n-/* Implement the \"print_recreate\" breakpoint_ops method for exec\n-   catchpoints.  */\n-\n-static void\n-print_recreate_catch_exec (struct breakpoint *b, struct ui_file *fp)\n-{\n-  fprintf_unfiltered (fp, \"catch exec\");\n-  print_recreate_thread (b, fp);\n-}\n-\n-static struct breakpoint_ops catch_exec_breakpoint_ops;\n-\n static int\n hw_breakpoint_used_count (void)\n {\n@@ -10958,70 +10847,6 @@ until_break_command (const char *arg, int from_tty, int anywhere)\n   proceed (-1, GDB_SIGNAL_DEFAULT);\n }\n \n-/* This function attempts to parse an optional \"if <cond>\" clause\n-   from the arg string.  If one is not found, it returns NULL.\n-\n-   Else, it returns a pointer to the condition string.  (It does not\n-   attempt to evaluate the string against a particular block.)  And,\n-   it updates arg to point to the first character following the parsed\n-   if clause in the arg string.  */\n-\n-const char *\n-ep_parse_optional_if_clause (const char **arg)\n-{\n-  const char *cond_string;\n-\n-  if (((*arg)[0] != 'i') || ((*arg)[1] != 'f') || !isspace ((*arg)[2]))\n-    return NULL;\n-\n-  /* Skip the \"if\" keyword.  */\n-  (*arg) += 2;\n-\n-  /* Skip any extra leading whitespace, and record the start of the\n-     condition string.  */\n-  *arg = skip_spaces (*arg);\n-  cond_string = *arg;\n-\n-  /* Assume that the condition occupies the remainder of the arg\n-     string.  */\n-  (*arg) += strlen (cond_string);\n-\n-  return cond_string;\n-}\n-\n-/* Commands to deal with catching events, such as signals, exceptions,\n-   process start/exit, etc.  */\n-\n-static void\n-catch_exec_command_1 (const char *arg, int from_tty,\n-\t\t      struct cmd_list_element *command)\n-{\n-  struct gdbarch *gdbarch = get_current_arch ();\n-  const char *cond_string = NULL;\n-  bool temp = command->context () == CATCH_TEMPORARY;\n-\n-  if (!arg)\n-    arg = \"\";\n-  arg = skip_spaces (arg);\n-\n-  /* The allowed syntax is:\n-     catch exec\n-     catch exec if <cond>\n-\n-     First, check if there's an if clause.  */\n-  cond_string = ep_parse_optional_if_clause (&arg);\n-\n-  if ((*arg != '\\0') && !isspace (*arg))\n-    error (_(\"Junk at end of arguments.\"));\n-\n-  std::unique_ptr<exec_catchpoint> c (new exec_catchpoint ());\n-  init_catchpoint (c.get (), gdbarch, temp, cond_string,\n-\t\t   &catch_exec_breakpoint_ops);\n-  c->exec_pathname.reset ();\n-\n-  install_breakpoint (0, std::move (c), 1);\n-}\n-\n void\n init_ada_exception_breakpoint (struct breakpoint *b,\n \t\t\t       struct gdbarch *gdbarch,\n@@ -15042,17 +14867,6 @@ initialize_breakpoint_ops (void)\n   ops->create_breakpoints_sal = strace_marker_create_breakpoints_sal;\n   ops->decode_location = strace_marker_decode_location;\n \n-  /* Exec catchpoints.  */\n-  ops = &catch_exec_breakpoint_ops;\n-  *ops = base_breakpoint_ops;\n-  ops->insert_location = insert_catch_exec;\n-  ops->remove_location = remove_catch_exec;\n-  ops->breakpoint_hit = breakpoint_hit_catch_exec;\n-  ops->print_it = print_it_catch_exec;\n-  ops->print_one = print_one_catch_exec;\n-  ops->print_mention = print_mention_catch_exec;\n-  ops->print_recreate = print_recreate_catch_exec;\n-\n   /* Solib-related catchpoints.  */\n   ops = &catch_solib_breakpoint_ops;\n   *ops = base_breakpoint_ops;\n@@ -15357,11 +15171,6 @@ Set temporary catchpoints to catch events.\"),\n \t\t\t&tcatch_cmdlist,\n \t\t\t0/*allow-unknown*/, &cmdlist);\n \n-  add_catch_command (\"exec\", _(\"Catch calls to exec.\"),\n-\t\t     catch_exec_command_1,\n-\t\t     NULL,\n-\t\t     CATCH_PERMANENT,\n-\t\t     CATCH_TEMPORARY);\n   add_catch_command (\"load\", _(\"Catch loads of shared libraries.\\n\\\n Usage: catch load [REGEX]\\n\\\n If REGEX is given, only stop for libraries matching the regular expression.\"),"
    }
  ]
}