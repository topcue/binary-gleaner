{
  "sha": "3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2RhYjllMTVkM2FiMWNkZTU1NWRmYmY0YTk1OGViMTdlZWMyZWNiMw==",
  "commit": {
    "author": {
      "name": "Sergey Belyashov",
      "email": "Sergey.Belyashov@gmail.com",
      "date": "2020-09-25T11:40:42Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-07-17T14:17:30Z"
    },
    "message": "Add basic Z80 CPU support\n\nSupported ISAs:\n- Z80 (all undocumented instructions)\n- Z180\n- eZ80 (Z80 mode only)\n\nDatasheets:\nZ80: https://www.zilog.com/manage_directlink.php?filepath=docs/z80/um0080&extn=.pdf\nZ180: https://www.zilog.com/manage_directlink.php?filepath=docs/z180/ps0140&extn=.pdf\neZ80: http://www.zilog.com/force_download.php?filepath=YUhSMGNEb3ZMM2QzZHk1NmFXeHZaeTVqYjIwdlpHOWpjeTlWVFRBd056Y3VjR1Jt\n\nTo debug Z80 programs using GDB you must configure and embed\nz80-stub.c to your program (SDCC compiler is required). Or\nyou may use some simulator with GDB support.\n\ngdb/ChangeLog:\n\n\t* Makefile.in (ALL_TARGET_OBS): Add z80-tdep.c.\n\t* NEWS: Mention z80 support.\n\t* configure.tgt: Handle z80*.\n\t* features/Makefile (XMLTOC): Add z80.xml.\n\t* features/z80-cpu.xml: New.\n\t* features/z80.c: Generate.\n\t* features/z80.xml: New.\n\t* z80-tdep.c: New file.\n\t* z80-tdep.h: New file.\n\ngdb/stubs/ChangeLog:\n\n\t* z80-stub.c: New file.\n\nChange-Id: Id0b7a6e210c3f93c6853c5e3031b7bcee47d0db9",
    "tree": {
      "sha": "42ae6677a07afc152fccddb3c32a083248cd49fa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/42ae6677a07afc152fccddb3c32a083248cd49fa"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/comments",
  "author": {
    "login": "b-s-a",
    "id": 2833802,
    "node_id": "MDQ6VXNlcjI4MzM4MDI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2833802?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/b-s-a",
    "html_url": "https://github.com/b-s-a",
    "followers_url": "https://api.github.com/users/b-s-a/followers",
    "following_url": "https://api.github.com/users/b-s-a/following{/other_user}",
    "gists_url": "https://api.github.com/users/b-s-a/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/b-s-a/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/b-s-a/subscriptions",
    "organizations_url": "https://api.github.com/users/b-s-a/orgs",
    "repos_url": "https://api.github.com/users/b-s-a/repos",
    "events_url": "https://api.github.com/users/b-s-a/events{/privacy}",
    "received_events_url": "https://api.github.com/users/b-s-a/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "12be796ca8a107f91b23e393fc228960ea52c6cc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/12be796ca8a107f91b23e393fc228960ea52c6cc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/12be796ca8a107f91b23e393fc228960ea52c6cc"
    }
  ],
  "stats": {
    "total": 2968,
    "additions": 2966,
    "deletions": 2
  },
  "files": [
    {
      "sha": "73a1bf83c858e97dee11063511ffd962e5fb174e",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -853,7 +853,8 @@ ALL_TARGET_OBS = \\\n \txstormy16-tdep.o \\\n \txtensa-config.o \\\n \txtensa-linux-tdep.o \\\n-\txtensa-tdep.o\n+\txtensa-tdep.o \\\n+\tz80-tdep.o\n \n # The following native-target dependent variables are defined on\n # configure.nat."
    },
    {
      "sha": "062249aea98e6a142a248340c7805ea3a1505f82",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -429,6 +429,7 @@ alias [-a] [--] ALIAS = COMMAND [DEFAULT-ARGS...]\n \n GNU/Linux/RISC-V (gdbserver)\triscv*-*-linux*\n BPF\t\t\t\tbpf-unknown-none\n+Z80\t\t\t\tz80-unknown-*\n \n * Python API\n "
    },
    {
      "sha": "97a5a57c37886c2261bb20ae16b9dc2dfc3f26e4",
      "filename": "gdb/configure.tgt",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/configure.tgt",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/configure.tgt",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.tgt?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -761,6 +761,10 @@ xtensa*-*-*linux*)\n \t# Target: GNU/Linux Xtensa\n \tgdb_target_obs=\"xtensa-linux-tdep.o symfile-mem.o linux-tdep.o\"\n \t;;\n+z80*)\n+\t# Target: Z80\n+\tgdb_target_obs=\"z80-tdep.o\"\n+\t;;\n \n esac\n "
    },
    {
      "sha": "ded8c3bb9da4d234032892e58708aab44f118c52",
      "filename": "gdb/features/Makefile",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/features/Makefile",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/features/Makefile",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/Makefile?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -170,7 +170,8 @@ XMLTOC = \\\n \ts390x-tevx-linux64.xml \\\n \ts390x-vx-linux64.xml \\\n \ts390-gs-linux64.xml \\\n-\ts390x-gs-linux64.xml\n+\ts390x-gs-linux64.xml \\\n+\tz80.xml\n \n TDESC_CFILES = $(patsubst %.xml,%.c,$(XMLTOC))\n GDB = false"
    },
    {
      "sha": "98498b1bcc1380dd41de1116b3a3f1c359110c3e",
      "filename": "gdb/features/z80-cpu.xml",
      "status": "added",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/features/z80-cpu.xml",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/features/z80-cpu.xml",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/z80-cpu.xml?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\"?>\n+<!-- Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+     Copying and distribution of this file, with or without modification,\n+     are permitted in any medium without royalty provided the copyright\n+     notice and this notice are preserved.  -->\n+\n+<!DOCTYPE feature SYSTEM \"gdb-target.dtd\">\n+<feature name=\"org.gnu.gdb.z80.cpu\">\n+  <flags id=\"af_flags\" size=\"2\">\n+    <field name=\"C\" start=\"0\" end=\"0\"/>\n+    <field name=\"N\" start=\"1\" end=\"1\"/>\n+    <field name=\"P/V\" start=\"2\" end=\"2\"/>\n+    <field name=\"F3\" start=\"3\" end=\"3\"/>\n+    <field name=\"H\" start=\"4\" end=\"4\"/>\n+    <field name=\"F5\" start=\"5\" end=\"5\"/>\n+    <field name=\"Z\" start=\"6\" end=\"6\"/>\n+    <field name=\"S\" start=\"7\" end=\"7\"/>\n+  </flags>\n+  <reg name=\"af\" bitsize=\"16\" type=\"af_flags\"/>\n+  <reg name=\"bc\" bitsize=\"16\" type=\"uint16\"/>\n+  <reg name=\"de\" bitsize=\"16\" type=\"data_ptr\"/>\n+  <reg name=\"hl\" bitsize=\"16\" type=\"data_ptr\"/>\n+  <reg name=\"sp\" bitsize=\"16\" type=\"data_ptr\" />\n+  <reg name=\"pc\" bitsize=\"32\" type=\"code_ptr\" />\n+  <reg name=\"ix\" bitsize=\"16\" type=\"data_ptr\"/>\n+  <reg name=\"iy\" bitsize=\"16\" type=\"data_ptr\"/>\n+  <reg name=\"af'\" bitsize=\"16\" type=\"af_flags\"/>\n+  <reg name=\"bc'\" bitsize=\"16\" type=\"uint16\"/>\n+  <reg name=\"de'\" bitsize=\"16\" type=\"data_ptr\"/>\n+  <reg name=\"hl'\" bitsize=\"16\" type=\"data_ptr\"/>\n+  <reg name=\"ir\" bitsize=\"16\" type=\"uint16\"/>\n+</feature>"
    },
    {
      "sha": "944b563aca4700bb4e0b2de2c65b5fc1e7d24473",
      "filename": "gdb/features/z80.c",
      "status": "added",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/features/z80.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/features/z80.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/z80.c?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -0,0 +1,44 @@\n+/* THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi:set ro:\n+  Original: z80.xml */\n+\n+#include \"defs.h\"\n+#include \"osabi.h\"\n+#include \"target-descriptions.h\"\n+\n+struct target_desc *tdesc_z80;\n+static void\n+initialize_tdesc_z80 (void)\n+{\n+  target_desc_up result = allocate_target_description ();\n+  set_tdesc_architecture (result.get (), bfd_scan_arch (\"z80\"));\n+\n+  struct tdesc_feature *feature;\n+\n+  feature = tdesc_create_feature (result.get (), \"org.gnu.gdb.z80.cpu\");\n+  tdesc_type_with_fields *type_with_fields;\n+  type_with_fields = tdesc_create_flags (feature, \"af_flags\", 2);\n+  tdesc_add_flag (type_with_fields, 0, \"C\");\n+  tdesc_add_flag (type_with_fields, 1, \"N\");\n+  tdesc_add_flag (type_with_fields, 2, \"P/V\");\n+  tdesc_add_flag (type_with_fields, 3, \"F3\");\n+  tdesc_add_flag (type_with_fields, 4, \"H\");\n+  tdesc_add_flag (type_with_fields, 5, \"F5\");\n+  tdesc_add_flag (type_with_fields, 6, \"Z\");\n+  tdesc_add_flag (type_with_fields, 7, \"S\");\n+\n+  tdesc_create_reg (feature, \"af\", 0, 1, NULL, 16, \"af_flags\");\n+  tdesc_create_reg (feature, \"bc\", 1, 1, NULL, 16, \"uint16\");\n+  tdesc_create_reg (feature, \"de\", 2, 1, NULL, 16, \"data_ptr\");\n+  tdesc_create_reg (feature, \"hl\", 3, 1, NULL, 16, \"data_ptr\");\n+  tdesc_create_reg (feature, \"sp\", 4, 1, NULL, 16, \"data_ptr\");\n+  tdesc_create_reg (feature, \"pc\", 5, 1, NULL, 32, \"code_ptr\");\n+  tdesc_create_reg (feature, \"ix\", 6, 1, NULL, 16, \"data_ptr\");\n+  tdesc_create_reg (feature, \"iy\", 7, 1, NULL, 16, \"data_ptr\");\n+  tdesc_create_reg (feature, \"af'\", 8, 1, NULL, 16, \"af_flags\");\n+  tdesc_create_reg (feature, \"bc'\", 9, 1, NULL, 16, \"uint16\");\n+  tdesc_create_reg (feature, \"de'\", 10, 1, NULL, 16, \"data_ptr\");\n+  tdesc_create_reg (feature, \"hl'\", 11, 1, NULL, 16, \"data_ptr\");\n+  tdesc_create_reg (feature, \"ir\", 12, 1, NULL, 16, \"uint16\");\n+\n+  tdesc_z80 = result.release ();\n+}"
    },
    {
      "sha": "238687a127e24e9db1b183cd98c7e535196cf9c1",
      "filename": "gdb/features/z80.xml",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/features/z80.xml",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/features/z80.xml",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/z80.xml?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\"?>\n+<!-- Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+     Copying and distribution of this file, with or without modification,\n+     are permitted in any medium without royalty provided the copyright\n+     notice and this notice are preserved.  -->\n+\n+<!DOCTYPE target SYSTEM \"gdb-target.dtd\">\n+<target>\n+  <architecture>z80</architecture>\n+  <xi:include href=\"z80-cpu.xml\"/>\n+</target>"
    },
    {
      "sha": "0ec128fbe6a67c1c6d59df62ee61c767ad96b2a2",
      "filename": "gdb/stubs/z80-stub.c",
      "status": "added",
      "additions": 1355,
      "deletions": 0,
      "changes": 1355,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/stubs/z80-stub.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/stubs/z80-stub.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stubs/z80-stub.c?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -0,0 +1,1355 @@\n+/* Debug stub for Z80.\n+\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* Usage:\n+  1. Copy this file to project directory\n+  2. Configure it commenting/uncommenting macros below or define DBG_CONFIGURED\n+     and all required macros and then include this file to one of your C-source\n+     files.\n+  3. Implement getDebugChar() and putDebugChar(), functions must not return\n+     until data received or sent.\n+  4. Implement all optional functions used to toggle breakpoints/watchpoints,\n+     if supported. Do not write fuctions to toggle software breakpoints if\n+     you unsure (GDB will do itself).\n+  5. Implement serial port initialization routine called at program start.\n+  6. Add necessary debugger entry points to your program, for example:\n+\t.org 0x08\t;RST 8 handler\n+\tjp _debug_swbreak\n+\t...\n+\t.org\t0x66\t;NMI handler\n+\tjp\t_debug_nmi\n+\t...\n+\tmain_loop:\n+\thalt\n+\tcall\tisDbgInterrupt\n+\tjr\tz,101$\n+\tld\thl, 2\t;EX_SIGINT\n+\tpush\thl\n+\tcall\t_debug_exception\n+\t101$:\n+\t...\n+  7. Compile file using SDCC (supported ports are: z80, z180, z80n, gbz80 and\n+     ez80_z80), do not use --peep-asm option. For example:\n+\t$ sdcc -mz80 --opt-code-size --max-allocs-per-node 50000 z80-stub.c\n+*/\n+/******************************************************************************\\\n+\t\t\t     Configuration\n+\\******************************************************************************/\n+#ifndef DBG_CONFIGURED\n+/* Uncomment this line, if stub size is critical for you */\n+//#define DBG_MIN_SIZE\n+\n+/* Comment this line out if software breakpoints are unsupported.\n+   If you have special function to toggle software breakpoints, then provide\n+   here name of these function. Expected prototype:\n+       int toggle_swbreak(int set, void *addr);\n+   function must return 0 on success. */\n+//#define DBG_SWBREAK toggle_swbreak\n+#define DBG_SWBREAK\n+\n+/* Define if one of standard RST handlers is used as software\n+   breakpoint entry point */\n+//#define DBG_SWBREAK_RST 0x08\n+\n+/* if platform supports hardware breakpoints then define following macro\n+   by name of function. Fuction must have next prototype:\n+     int toggle_hwbreak(int set, void *addr);\n+   function must return 0 on success. */\n+//#define DBG_HWBREAK toggle_hwbreak\n+\n+/* if platform supports hardware watchpoints then define all or some of\n+   following macros by names of functions. Fuctions prototypes:\n+     int toggle_watch(int set, void *addr, size_t size);  // memory write watch\n+     int toggle_rwatch(int set, void *addr, size_t size); // memory read watch\n+     int toggle_awatch(int set, void *addr, size_t size); // memory access watch\n+   function must return 0 on success. */\n+//#define DBG_WWATCH toggle_watch\n+//#define DBG_RWATCH toggle_rwatch\n+//#define DBG_AWATCH toggle_awatch\n+\n+/* Size of hardware breakpoint. Required to correct PC. */\n+#define DBG_HWBREAK_SIZE 0\n+\n+/* Define following macro if you need custom memory read/write routine.\n+   Function should return non-zero on success, and zero on failure\n+   (for example, write to ROM area).\n+   Useful with overlays (bank switching).\n+   Do not forget to define:\n+   _ovly_table - overlay table\n+   _novlys - number of items in _ovly_table\n+   or\n+   _ovly_region_table - overlay regions table\n+   _novly_regions - number of items in _ovly_region_table\n+\n+   _ovly_debug_prepare - function is called before overlay mapping\n+   _ovly_debug_event - function is called after overlay mapping\n+ */\n+//#define DBG_MEMCPY memcpy\n+\n+/* define dedicated stack size if required */\n+//#define DBG_STACK_SIZE 256\n+\n+/* max GDB packet size\n+   should be much less that DBG_STACK_SIZE because it will be allocated on stack\n+*/\n+#define DBG_PACKET_SIZE 150\n+\n+/* Uncomment if required to use trampoline when resuming operation.\n+   Useful with dedicated stack when stack pointer do not point to the stack or\n+   stack is not writable */\n+//#define DBG_USE_TRAMPOLINE\n+\n+/* Uncomment following macro to enable debug printing to debugger console */\n+//#define DBG_PRINT\n+\n+#define DBG_NMI_EX EX_HWBREAK\n+#define DBG_INT_EX EX_SIGINT\n+\n+/* Define following macro to statement, which will be exectuted after entering to\n+   stub_main function. Statement should include semicolon. */\n+//#define DBG_ENTER debug_enter();\n+\n+/* Define following macro to instruction(s), which will be execute before return\n+   control to the program. It is useful when gdb-stub is placed in one of overlays.\n+   This procedure must not change any register. On top of stack before invocation\n+   will be return address of the program. */\n+//#define DBG_RESUME jp _restore_bank\n+\n+/* Define following macro to the string containing memory map definition XML.\n+   GDB will use it to select proper breakpoint type (HW or SW). */\n+/*#define DBG_MEMORY_MAP \"\\\n+<memory-map>\\\n+\t<memory type=\\\"rom\\\" start=\\\"0x0000\\\" length=\\\"0x4000\\\"/>\\\n+<!--\t<memory type=\\\"flash\\\" start=\\\"0x4000\\\" length=\\\"0x4000\\\">\\\n+\t\t<property name=\\\"blocksize\\\">128</property>\\\n+\t</memory> -->\\\n+\t<memory type=\\\"ram\\\" start=\\\"0x8000\\\" length=\\\"0x8000\\\"/>\\\n+</memory-map>\\\n+\"\n+*/\n+#endif /* DBG_CONFIGURED */\n+/******************************************************************************\\\n+\t\t\t     Public Interface\n+\\******************************************************************************/\n+\n+/* Enter to debug mode from software or hardware breakpoint.\n+   Assume address of next instruction after breakpoint call is on top of stack.\n+   Do JP _debug_swbreak or JP _debug_hwbreak from RST handler, for example.\n+ */\n+void debug_swbreak (void);\n+void debug_hwbreak (void);\n+\n+/* Jump to this function from NMI handler. Just replace RETN instruction by\n+   JP _debug_nmi\n+   Use if NMI detects request to enter to debug mode.\n+ */\n+void debug_nmi (void);\n+\n+/* Jump to this function from INT handler. Just replace EI+RETI instructions by\n+   JP _debug_int\n+   Use if INT detects request to enter to debug mode.\n+ */\n+void debug_int (void);\n+\n+#define EX_SWBREAK\t0\t/* sw breakpoint */\n+#define EX_HWBREAK\t-1\t/* hw breakpoint */\n+#define EX_WWATCH\t-2\t/* memory write watch */\n+#define EX_RWATCH\t-3\t/* memory read watch */\n+#define EX_AWATCH\t-4\t/* memory access watch */\n+#define EX_SIGINT\t2\n+#define EX_SIGTRAP\t5\n+#define EX_SIGABRT\t6\n+#define EX_SIGBUS\t10\n+#define EX_SIGSEGV\t11\n+/* or any standard *nix signal value */\n+\n+/* Enter to debug mode (after receiving BREAK from GDB, for example)\n+ * Assume:\n+ *   program PC in (SP+0)\n+ *   caught signal in (SP+2)\n+ *   program SP is SP+4\n+ */\n+void debug_exception (int ex);\n+\n+/* Prints to debugger console. */\n+void debug_print(const char *str);\n+/******************************************************************************\\\n+\t\t\t      Required functions\n+\\******************************************************************************/\n+\n+extern int getDebugChar (void);\n+extern void putDebugChar (int ch);\n+\n+#ifdef DBG_SWBREAK\n+#define DO_EXPAND(VAL)  VAL ## 123456\n+#define EXPAND(VAL)     DO_EXPAND(VAL)\n+\n+#if EXPAND(DBG_SWBREAK) != 123456\n+#define DBG_SWBREAK_PROC DBG_SWBREAK\n+extern int DBG_SWBREAK(int set, void *addr);\n+#endif\n+\n+#undef EXPAND\n+#undef DO_EXPAND\n+#endif /* DBG_SWBREAK */\n+\n+#ifdef DBG_HWBREAK\n+extern int DBG_HWBREAK(int set, void *addr);\n+#endif\n+\n+#ifdef DBG_MEMCPY\n+extern void* DBG_MEMCPY (void *dest, const void *src, unsigned n);\n+#endif\n+\n+#ifdef DBG_WWATCH\n+extern int DBG_WWATCH(int set, void *addr, unsigned size);\n+#endif\n+\n+#ifdef DBG_RWATCH\n+extern int DBG_RWATCH(int set, void *addr, unsigned size);\n+#endif\n+\n+#ifdef DBG_AWATCH\n+extern int DBG_AWATCH(int set, void *addr, unsigned size);\n+#endif\n+\n+/******************************************************************************\\\n+\t\t\t       IMPLEMENTATION\n+\\******************************************************************************/\n+\n+#include <string.h>\n+\n+#ifndef NULL\n+# define NULL (void*)0\n+#endif\n+\n+typedef unsigned char byte;\n+typedef unsigned short word;\n+\n+/* CPU state */\n+#ifdef __SDCC_ez80_adl\n+# define REG_SIZE 3\n+#else\n+# define REG_SIZE 2\n+#endif /* __SDCC_ez80_adl */\n+\n+#define R_AF    (0*REG_SIZE)\n+#define R_BC    (1*REG_SIZE)\n+#define R_DE    (2*REG_SIZE)\n+#define R_HL    (3*REG_SIZE)\n+#define R_SP    (4*REG_SIZE)\n+#define R_PC    (5*REG_SIZE)\n+\n+#ifndef __SDCC_gbz80\n+#define R_IX    (6*REG_SIZE)\n+#define R_IY    (7*REG_SIZE)\n+#define R_AF_   (8*REG_SIZE)\n+#define R_BC_   (9*REG_SIZE)\n+#define R_DE_   (10*REG_SIZE)\n+#define R_HL_   (11*REG_SIZE)\n+#define R_IR    (12*REG_SIZE)\n+\n+#ifdef __SDCC_ez80_adl\n+#define R_SPS   (13*REG_SIZE)\n+#define NUMREGBYTES (14*REG_SIZE)\n+#else\n+#define NUMREGBYTES (13*REG_SIZE)\n+#endif /* __SDCC_ez80_adl */\n+#else\n+#define NUMREGBYTES (6*REG_SIZE)\n+#define FASTCALL\n+#endif /*__SDCC_gbz80 */\n+static byte state[NUMREGBYTES];\n+\n+#if DBG_PACKET_SIZE < (NUMREGBYTES*2+5)\n+#error \"Too small DBG_PACKET_SIZE\"\n+#endif\n+\n+#ifndef FASTCALL\n+#define FASTCALL __z88dk_fastcall\n+#endif\n+\n+/* dedicated stack */\n+#ifdef DBG_STACK_SIZE\n+\n+#define LOAD_SP\tld\tsp, #_stack + DBG_STACK_SIZE\n+\n+static char stack[DBG_STACK_SIZE];\n+\n+#else\n+\n+#undef DBG_USE_TRAMPOLINE\n+#define LOAD_SP\n+\n+#endif\n+\n+#ifndef DBG_ENTER\n+#define DBG_ENTER\n+#endif\n+\n+#ifndef DBG_RESUME\n+#define DBG_RESUME ret\n+#endif\n+\n+static signed char sigval;\n+\n+static void stub_main (int sigval, int pc_adj);\n+static char high_hex (byte v) FASTCALL;\n+static char low_hex (byte v) FASTCALL;\n+static char put_packet_info (const char *buffer) FASTCALL;\n+static void save_cpu_state (void);\n+static void rest_cpu_state (void);\n+\n+/******************************************************************************/\n+#ifdef DBG_SWBREAK\n+#ifdef DBG_SWBREAK_RST\n+#define DBG_SWBREAK_SIZE 1\n+#else\n+#define DBG_SWBREAK_SIZE 3\n+#endif\n+void\n+debug_swbreak (void) __naked\n+{\n+  __asm\n+\tld\t(#_state + R_SP), sp\n+\tLOAD_SP\n+\tcall\t_save_cpu_state\n+\tld\thl, #-DBG_SWBREAK_SIZE\n+\tpush\thl\n+\tld\thl, #EX_SWBREAK\n+\tpush\thl\n+\tcall\t_stub_main\n+\t.globl\t_break_handler\n+#ifdef DBG_SWBREAK_RST\n+_break_handler = DBG_SWBREAK_RST\n+#else\n+_break_handler = _debug_swbreak\n+#endif\n+  __endasm;\n+}\n+#endif /* DBG_SWBREAK */\n+/******************************************************************************/\n+#ifdef DBG_HWBREAK\n+#ifndef DBG_HWBREAK_SIZE\n+#define DBG_HWBREAK_SIZE 0\n+#endif /* DBG_HWBREAK_SIZE */\n+void\n+debug_hwbreak (void) __naked\n+{\n+  __asm\n+\tld\t(#_state + R_SP), sp\n+\tLOAD_SP\n+\tcall\t_save_cpu_state\n+\tld\thl, #-DBG_HWBREAK_SIZE\n+\tpush\thl\n+\tld\thl, #EX_HWBREAK\n+\tpush\thl\n+\tcall\t_stub_main\n+  __endasm;\n+}\n+#endif /* DBG_HWBREAK_SET */\n+/******************************************************************************/\n+void\n+debug_exception (int ex) __naked\n+{\n+  __asm\n+\tld\t(#_state + R_SP), sp\n+\tLOAD_SP\n+\tcall\t_save_cpu_state\n+\tld\thl, #0\n+\tpush\thl\n+#ifdef __SDCC_gbz80\n+\tld\thl, #_state + R_SP\n+\tld\ta, (hl+)\n+\tld\th, (hl)\n+\tld\tl, a\n+#else\n+\tld\thl, (#_state + R_SP)\n+#endif\n+\tinc\thl\n+\tinc\thl\n+\tld\te, (hl)\n+\tinc\thl\n+\tld\td, (hl)\n+\tpush\tde\n+\tcall\t_stub_main\n+  __endasm;\n+  (void)ex;\n+}\n+/******************************************************************************/\n+#ifndef __SDCC_gbz80\n+void\n+debug_nmi(void) __naked\n+{\n+  __asm\n+\tld\t(#_state + R_SP), sp\n+\tLOAD_SP\n+\tcall\t_save_cpu_state\n+\tld\thl, #0\t;pc_adj\n+\tpush\thl\n+\tld\thl, #DBG_NMI_EX\n+\tpush\thl\n+\tld\thl, #_stub_main\n+\tpush\thl\n+\tpush\thl\n+\tretn\n+  __endasm;\n+}\n+#endif\n+/******************************************************************************/\n+void\n+debug_int(void) __naked\n+{\n+  __asm\n+\tld\t(#_state + R_SP), sp\n+\tLOAD_SP\n+\tcall\t_save_cpu_state\n+\tld\thl, #0\t;pc_adj\n+\tpush\thl\n+\tld\thl, #DBG_INT_EX\n+\tpush\thl\n+\tld\thl, #_stub_main\n+\tpush\thl\n+\tpush\thl\n+\tei\n+\treti\n+  __endasm;\n+}\n+/******************************************************************************/\n+#ifdef DBG_PRINT\n+void\n+debug_print(const char *str)\n+{\n+  putDebugChar ('$');\n+  putDebugChar ('O');\n+  char csum = 'O';\n+  for (; *str != '\\0'; )\n+    {\n+      char c = high_hex (*str);\n+      csum += c;\n+      putDebugChar (c);\n+      c = low_hex (*str++);\n+      csum += c;\n+      putDebugChar (c);\n+    }\n+  putDebugChar ('#');\n+  putDebugChar (high_hex (csum));\n+  putDebugChar (low_hex (csum));\n+}\n+#endif /* DBG_PRINT */\n+/******************************************************************************/\n+static void store_pc_sp (int pc_adj) FASTCALL;\n+#define get_reg_value(mem) (*(void* const*)(mem))\n+#define set_reg_value(mem,val) do { (*(void**)(mem) = (val)); } while (0)\n+static char* byte2hex(char *buf, byte val);\n+static int hex2int (const char **buf) FASTCALL;\n+static char* int2hex (char *buf, int v);\n+static void get_packet (char *buffer);\n+static void put_packet (const char *buffer);\n+static char process (char *buffer) FASTCALL;\n+static void rest_cpu_state (void);\n+\n+static void\n+stub_main (int ex, int pc_adj)\n+{\n+  char buffer[DBG_PACKET_SIZE+1];\n+  sigval = (signed char)ex;\n+  store_pc_sp (pc_adj);\n+\n+  DBG_ENTER\n+\n+  /* after starting gdb_stub must always return stop reason */\n+  *buffer = '?';\n+  for (; process (buffer);)\n+    {\n+      put_packet (buffer);\n+      get_packet (buffer);\n+    }\n+  put_packet (buffer);\n+  rest_cpu_state ();\n+}\n+\n+static void\n+get_packet (char *buffer)\n+{\n+  byte csum;\n+  char ch;\n+  char *p;\n+  byte esc;\n+#if DBG_PACKET_SIZE <= 256\n+  byte count; /* it is OK to use up to 256 here */\n+#else\n+  unsigned count;\n+#endif\n+  for (;; putDebugChar ('-'))\n+    {\n+      /* wait for packet start character */\n+      while (getDebugChar () != '$');\n+retry:\n+      csum = 0;\n+      esc = 0;\n+      p = buffer;\n+      count = DBG_PACKET_SIZE;\n+      do\n+\t{\n+\t  ch = getDebugChar ();\n+\t  switch (ch)\n+\t    {\n+\t    case '$':\n+\t      goto retry;\n+\t    case '#':\n+\t      goto finish;\n+\t    case '}':\n+\t      esc = 0x20;\n+\t      break;\n+\t    default:\n+\t      *p++ = ch ^ esc;\n+\t      esc = 0;\n+\t      --count;\n+\t    }\n+\t  csum += ch;\n+\t}\n+      while (count != 0);\n+finish:\n+      *p = '\\0';\n+      if (ch != '#') /* packet is too large */\n+\tcontinue;\n+      ch = getDebugChar ();\n+      if (ch != high_hex (csum))\n+\tcontinue;\n+      ch = getDebugChar ();\n+      if (ch != low_hex (csum))\n+\tcontinue;\n+      break;\n+    }\n+  putDebugChar ('+');\n+}\n+\n+static void\n+put_packet (const char *buffer)\n+{\n+  /*  $<packet info>#<checksum>. */\n+  for (;;)\n+    {\n+      putDebugChar ('$');\n+      char checksum = put_packet_info (buffer);\n+      putDebugChar ('#');\n+      putDebugChar (high_hex(checksum));\n+      putDebugChar (low_hex(checksum));\n+      for (;;)\n+\t{\n+\t  char c = getDebugChar ();\n+\t  switch (c)\n+\t    {\n+\t    case '+': return;\n+\t    case '-': break;\n+\t    default:\n+\t      putDebugChar (c);\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+static char\n+put_packet_info (const char *src) FASTCALL\n+{\n+  char ch;\n+  char checksum = 0;\n+  for (;;)\n+    {\n+      ch = *src++;\n+      if (ch == '\\0')\n+\tbreak;\n+      if (ch == '}' || ch == '*' || ch == '#' || ch == '$')\n+\t{\n+\t  /* escape special characters */\n+\t  putDebugChar ('}');\n+\t  checksum += '}';\n+\t  ch ^= 0x20;\n+\t}\n+      putDebugChar (ch);\n+      checksum += ch;\n+    }\n+  return checksum;\n+}\n+\n+static void\n+store_pc_sp (int pc_adj) FASTCALL\n+{\n+  byte *sp = get_reg_value (&state[R_SP]);\n+  byte *pc = get_reg_value (sp);\n+  pc += pc_adj;\n+  set_reg_value (&state[R_PC], pc);\n+  set_reg_value (&state[R_SP], sp + REG_SIZE);\n+}\n+\n+static char *mem2hex (char *buf, const byte *mem, unsigned bytes);\n+static char *hex2mem (byte *mem, const char *buf, unsigned bytes);\n+\n+/* Command processors. Takes pointer to buffer (begins from command symbol),\n+   modifies buffer, returns: -1 - empty response (ignore), 0 - success,\n+   positive: error code. */\n+\n+#ifdef DBG_MIN_SIZE\n+static signed char\n+process_question (char *p) FASTCALL\n+{\n+  signed char sig;\n+  *p++ = 'S';\n+  sig = sigval;\n+  if (sig <= 0)\n+    sig = EX_SIGTRAP;\n+  p = byte2hex (p, (byte)sig);\n+  *p = '\\0';\n+  return 0;\n+}\n+#else /* DBG_MIN_SIZE */\n+static char *format_reg_value (char *p, unsigned reg_num, const byte *value);\n+\n+static signed char\n+process_question (char *p) FASTCALL\n+{\n+  signed char sig;\n+  *p++ = 'T';\n+  sig = sigval;\n+  if (sig <= 0)\n+    sig = EX_SIGTRAP;\n+  p = byte2hex (p, (byte)sig);\n+  p = format_reg_value(p, R_AF/REG_SIZE, &state[R_AF]);\n+  p = format_reg_value(p, R_SP/REG_SIZE, &state[R_SP]);\n+  p = format_reg_value(p, R_PC/REG_SIZE, &state[R_PC]);\n+#if defined(DBG_SWBREAK_PROC) || defined(DBG_HWBREAK) || defined(DBG_WWATCH) || defined(DBG_RWATCH) || defined(DBG_AWATCH)\n+  const char *reason;\n+  unsigned addr = 0;\n+  switch (sigval)\n+    {\n+#ifdef DBG_SWBREAK_PROC\n+    case EX_SWBREAK:\n+      reason = \"swbreak\";\n+      break;\n+#endif\n+#ifdef DBG_HWBREAK\n+    case EX_HWBREAK:\n+      reason = \"hwbreak\";\n+      break;\n+#endif\n+#ifdef DBG_WWATCH\n+    case EX_WWATCH:\n+      reason = \"watch\";\n+      addr = 1;\n+      break;\n+#endif\n+#ifdef DBG_RWATCH\n+    case EX_RWATCH:\n+      reason = \"rwatch\";\n+      addr = 1;\n+      break;\n+#endif\n+#ifdef DBG_AWATCH\n+    case EX_AWATCH:\n+      reason = \"awatch\";\n+      addr = 1;\n+      break;\n+#endif\n+    default:\n+      goto finish;\n+    }\n+  while ((*p++ = *reason++))\n+    ;\n+  --p;\n+  *p++ = ':';\n+  if (addr != 0)\n+    p = int2hex(p, addr);\n+  *p++ = ';';\n+finish:\n+#endif /* DBG_HWBREAK, DBG_WWATCH, DBG_RWATCH, DBG_AWATCH */\n+  *p++ = '\\0';\n+  return 0;\n+}\n+#endif /* DBG_MINSIZE */\n+\n+#define STRING2(x) #x\n+#define STRING1(x) STRING2(x)\n+#define STRING(x) STRING1(x)\n+#ifdef DBG_MEMORY_MAP\n+static void read_memory_map (char *buffer, unsigned offset, unsigned length);\n+#endif\n+\n+static signed char\n+process_q (char *buffer) FASTCALL\n+{\n+  char *p;\n+  if (memcmp (buffer + 1, \"Supported\", 9) == 0)\n+    {\n+      memcpy (buffer, \"PacketSize=\", 11);\n+      p = int2hex (&buffer[11], DBG_PACKET_SIZE);\n+#ifndef DBG_MIN_SIZE\n+#ifdef DBG_SWBREAK_PROC\n+      memcpy (p, \";swbreak+\", 9);\n+      p += 9;\n+#endif\n+#ifdef DBG_HWBREAK\n+      memcpy (p, \";hwbreak+\", 9);\n+      p += 9;\n+#endif\n+#endif /* DBG_MIN_SIZE */\n+\n+#ifdef DBG_MEMORY_MAP\n+      memcpy (p, \";qXfer:memory-map:read+\", 23);\n+      p += 23;\n+#endif\n+      *p = '\\0';\n+      return 0;\n+    }\n+#ifdef DBG_MEMORY_MAP\n+  if (memcmp (buffer + 1, \"Xfer:memory-map:read:\", 21) == 0)\n+    {\n+      p = strchr (buffer + 1 + 21, ':');\n+      if (p == NULL)\n+\treturn 1;\n+      ++p;\n+      unsigned offset = hex2int (&p);\n+      if (*p++ != ',')\n+\treturn 2;\n+      unsigned length = hex2int (&p);\n+      if (length == 0)\n+\treturn 3;\n+      if (length > DBG_PACKET_SIZE)\n+\treturn 4;\n+      read_memory_map (buffer, offset, length);\n+      return 0;\n+    }\n+#endif\n+#ifndef DBG_MIN_SIZE\n+  if (memcmp (&buffer[1], \"Attached\", 9) == 0)\n+    {\n+      /* Just report that GDB attached to existing process\n+\t if it is not applicable for you, then send patches */\n+      memcpy(buffer, \"1\", 2);\n+      return 0;\n+    }\n+#endif /* DBG_MIN_SIZE */\n+  *buffer = '\\0';\n+  return -1;\n+}\n+\n+static signed char\n+process_g (char *buffer) FASTCALL\n+{\n+  mem2hex (buffer, state, NUMREGBYTES);\n+  return 0;\n+}\n+\n+static signed char\n+process_G (char *buffer) FASTCALL\n+{\n+  hex2mem (state, &buffer[1], NUMREGBYTES);\n+  /* OK response */\n+  *buffer = '\\0';\n+  return 0;\n+}\n+\n+static signed char\n+process_m (char *buffer) FASTCALL\n+{/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */\n+  char *p = &buffer[1];\n+  byte *addr = (void*)hex2int(&p);\n+  if (*p++ != ',')\n+    return 1;\n+  unsigned len = (unsigned)hex2int(&p);\n+  if (len == 0)\n+    return 2;\n+  if (len > DBG_PACKET_SIZE/2)\n+    return 3;\n+  p = buffer;\n+#ifdef DBG_MEMCPY\n+  do\n+    {\n+      byte tmp[16];\n+      unsigned tlen = sizeof(tmp);\n+      if (tlen > len)\n+\ttlen = len;\n+      if (!DBG_MEMCPY(tmp, addr, tlen))\n+\treturn 4;\n+      p = mem2hex (p, tmp, tlen);\n+      addr += tlen;\n+      len -= tlen;\n+    }\n+  while (len);\n+#else\n+  p = mem2hex (p, addr, len);\n+#endif\n+  return 0;\n+}\n+\n+static signed char\n+process_M (char *buffer) FASTCALL\n+{/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */\n+  char *p = &buffer[1];\n+  byte *addr = (void*)hex2int(&p);\n+  if (*p != ',')\n+    return 1;\n+  ++p;\n+  unsigned len = (unsigned)hex2int(&p);\n+  if (*p++ != ':')\n+    return 2;\n+  if (len == 0)\n+    goto end;\n+  if (len*2 + (p - buffer) > DBG_PACKET_SIZE)\n+    return 3;\n+#ifdef DBG_MEMCPY\n+  do\n+    {\n+      byte tmp[16];\n+      unsigned tlen = sizeof(tmp);\n+      if (tlen > len)\n+\ttlen = len;\n+      p = hex2mem (tmp, p, tlen);\n+      if (!DBG_MEMCPY(addr, tmp, tlen))\n+\treturn 4;\n+      addr += tlen;\n+\tlen -= tlen;\n+    }\n+  while (len);\n+#else\n+  hex2mem (addr, p, len);\n+#endif\n+end:\n+  /* OK response */\n+  *buffer = '\\0';\n+  return 0;\n+}\n+\n+#ifndef DBG_MIN_SIZE\n+static signed char\n+process_X (char *buffer) FASTCALL\n+{/* XAA..AA,LLLL: Write LLLL binary bytes at address AA.AA return OK */\n+  char *p = &buffer[1];\n+  byte *addr = (void*)hex2int(&p);\n+  if (*p != ',')\n+    return 1;\n+  ++p;\n+  unsigned len = (unsigned)hex2int(&p);\n+  if (*p++ != ':')\n+    return 2;\n+  if (len == 0)\n+    goto end;\n+  if (len + (p - buffer) > DBG_PACKET_SIZE)\n+    return 3;\n+#ifdef DBG_MEMCPY\n+  if (!DBG_MEMCPY(addr, p, len))\n+    return 4;\n+#else\n+  memcpy (addr, p, len);\n+#endif\n+end:\n+  /* OK response */\n+  *buffer = '\\0';\n+  return 0;\n+}\n+#else /* DBG_MIN_SIZE */\n+static signed char\n+process_X (char *buffer) FASTCALL\n+{\n+  (void)buffer;\n+  return -1;\n+}\n+#endif /* DBG_MIN_SIZE */\n+\n+static signed char\n+process_c (char *buffer) FASTCALL\n+{/* 'cAAAA' - Continue at address AAAA(optional) */\n+  const char *p = &buffer[1];\n+  if (*p != '\\0')\n+    {\n+      void *addr = (void*)hex2int(&p);\n+      set_reg_value (&state[R_PC], addr);\n+    }\n+  rest_cpu_state ();\n+  return 0;\n+}\n+\n+static signed char\n+process_D (char *buffer) FASTCALL\n+{/* 'D' - detach the program: continue execution */\n+  *buffer = '\\0';\n+  return -2;\n+}\n+\n+static signed char\n+process_k (char *buffer) FASTCALL\n+{/* 'k' - Kill the program */\n+  set_reg_value (&state[R_PC], 0);\n+  rest_cpu_state ();\n+  (void)buffer;\n+  return 0;\n+}\n+\n+static signed char\n+process_v (char *buffer) FASTCALL\n+{\n+#ifndef DBG_MIN_SIZE\n+  if (memcmp (&buffer[1], \"Cont\", 4) == 0)\n+    {\n+      if (buffer[5] == '?')\n+\t{\n+\t  /* result response will be \"vCont;c;C\"; C action must be\n+\t     supported too, because GDB reguires at lease both of them */\n+\t  memcpy (&buffer[5], \";c;C\", 5);\n+\t  return 0;\n+\t}\n+      buffer[0] = '\\0';\n+      if (buffer[5] == ';' && (buffer[6] == 'c' || buffer[6] == 'C'))\n+\treturn -2; /* resume execution */\n+      return 1;\n+  }\n+#endif /* DBG_MIN_SIZE */\n+  return -1;\n+}\n+\n+static signed char\n+process_zZ (char *buffer) FASTCALL\n+{ /* insert/remove breakpoint */\n+#if defined(DBG_SWBREAK_PROC) || defined(DBG_HWBREAK) || \\\n+    defined(DBG_WWATCH) || defined(DBG_RWATCH) || defined(DBG_AWATCH)\n+  const byte set = (*buffer == 'Z');\n+  const char *p = &buffer[3];\n+  void *addr = (void*)hex2int(&p);\n+  if (*p != ',')\n+    return 1;\n+  p++;\n+  int kind = hex2int(&p);\n+  *buffer = '\\0';\n+  switch (buffer[1])\n+    {\n+#ifdef DBG_SWBREAK_PROC\n+    case '0': /* sw break */\n+      return DBG_SWBREAK_PROC(set, addr);\n+#endif\n+#ifdef DBG_HWBREAK\n+    case '1': /* hw break */\n+      return DBG_HWBREAK(set, addr);\n+#endif\n+#ifdef DBG_WWATCH\n+    case '2': /* write watch */\n+      return DBG_WWATCH(set, addr, kind);\n+#endif\n+#ifdef DBG_RWATCH\n+    case '3': /* read watch */\n+      return DBG_RWATCH(set, addr, kind);\n+#endif\n+#ifdef DBG_AWATCH\n+    case '4': /* access watch */\n+      return DBG_AWATCH(set, addr, kind);\n+#endif\n+    default:; /* not supported */\n+    }\n+#endif\n+  (void)buffer;\n+  return -1;\n+}\n+\n+static signed char\n+do_process (char *buffer) FASTCALL\n+{\n+  switch (*buffer)\n+    {\n+    case '?': return process_question (buffer);\n+    case 'G': return process_G (buffer);\n+    case 'k': return process_k (buffer);\n+    case 'M': return process_M (buffer);\n+    case 'X': return process_X (buffer);\n+    case 'Z': return process_zZ (buffer);\n+    case 'c': return process_c (buffer);\n+    case 'D': return process_D (buffer);\n+    case 'g': return process_g (buffer);\n+    case 'm': return process_m (buffer);\n+    case 'q': return process_q (buffer);\n+    case 'v': return process_v (buffer);\n+    case 'z': return process_zZ (buffer);\n+    default:  return -1; /* empty response */\n+    }\n+}\n+\n+static char\n+process (char *buffer) FASTCALL\n+{\n+  signed char err = do_process (buffer);\n+  char *p = buffer;\n+  char ret = 1;\n+  if (err == -2)\n+    {\n+      ret = 0;\n+      err = 0;\n+    }\n+  if (err > 0)\n+    {\n+      *p++ = 'E';\n+      p = byte2hex (p, err);\n+      *p = '\\0';\n+    }\n+  else if (err < 0)\n+    {\n+      *p = '\\0';\n+    }\n+  else if (*p == '\\0')\n+    memcpy(p, \"OK\", 3);\n+  return ret;\n+}\n+\n+static char *\n+byte2hex (char *p, byte v)\n+{\n+  *p++ = high_hex (v);\n+  *p++ = low_hex (v);\n+  return p;\n+}\n+\n+static signed char\n+hex2val (unsigned char hex) FASTCALL\n+{\n+  if (hex <= '9')\n+    return hex - '0';\n+  hex &= 0xdf; /* make uppercase */\n+  hex -= 'A' - 10;\n+  return (hex >= 10 && hex < 16) ? hex : -1;\n+}\n+\n+static int\n+hex2byte (const char *p) FASTCALL\n+{\n+  signed char h = hex2val (p[0]);\n+  signed char l = hex2val (p[1]);\n+  if (h < 0 || l < 0)\n+    return -1;\n+  return (byte)((byte)h << 4) | (byte)l;\n+}\n+\n+static int\n+hex2int (const char **buf) FASTCALL\n+{\n+  word r = 0;\n+  for (;; (*buf)++)\n+    {\n+      signed char a = hex2val(**buf);\n+      if (a < 0)\n+\tbreak;\n+      r <<= 4;\n+      r += (byte)a;\n+    }\n+  return (int)r;\n+}\n+\n+static char *\n+int2hex (char *buf, int v)\n+{\n+  buf = byte2hex(buf, (word)v >> 8);\n+  return byte2hex(buf, (byte)v);\n+}\n+\n+static char\n+high_hex (byte v) FASTCALL\n+{\n+  return low_hex(v >> 4);\n+}\n+\n+static char\n+low_hex (byte v) FASTCALL\n+{\n+/*\n+  __asm\n+\tld\ta, l\n+\tand\ta, #0x0f\n+\tadd\ta, #0x90\n+\tdaa\n+\tadc\ta, #0x40\n+\tdaa\n+\tld\tl, a\n+  __endasm;\n+  (void)v;\n+*/\n+  v &= 0x0f;\n+  v += '0';\n+  if (v < '9'+1)\n+    return v;\n+  return v + 'a' - '0' - 10;\n+}\n+\n+/* convert the memory, pointed to by mem into hex, placing result in buf */\n+/* return a pointer to the last char put in buf (null) */\n+static char *\n+mem2hex (char *buf, const byte *mem, unsigned bytes)\n+{\n+  char *d = buf;\n+  if (bytes != 0)\n+    {\n+      do\n+\t{\n+\t  d = byte2hex (d, *mem++);\n+\t}\n+      while (--bytes);\n+    }\n+  *d = 0;\n+  return d;\n+}\n+\n+/* convert the hex array pointed to by buf into binary, to be placed in mem\n+   return a pointer to the character after the last byte written */\n+\n+static const char *\n+hex2mem (byte *mem, const char *buf, unsigned bytes)\n+{\n+  if (bytes != 0)\n+    {\n+      do\n+\t{\n+\t  *mem++ = hex2byte (buf);\n+\t  buf += 2;\n+\t}\n+      while (--bytes);\n+    }\n+  return buf;\n+}\n+\n+#ifdef DBG_MEMORY_MAP\n+static void\n+read_memory_map (char *buffer, unsigned offset, unsigned length)\n+{\n+  const char *map = DBG_MEMORY_MAP;\n+  const unsigned map_sz = strlen(map);\n+  if (offset >= map_sz)\n+    {\n+      buffer[0] = 'l';\n+      buffer[1] = '\\0';\n+      return;\n+    }\n+  if (offset + length > map_sz)\n+    length = map_sz - offset;\n+  buffer[0] = 'm';\n+  memcpy (&buffer[1], &map[offset], length);\n+  buffer[1+length] = '\\0';\n+}\n+#endif\n+\n+/* write string like \" nn:0123\" and return pointer after it */\n+#ifndef DBG_MIN_SIZE\n+static char *\n+format_reg_value (char *p, unsigned reg_num, const byte *value)\n+{\n+  char *d = p;\n+  unsigned char i;\n+  d = byte2hex(d, reg_num);\n+  *d++ = ':';\n+  value += REG_SIZE;\n+  i = REG_SIZE;\n+  do\n+    {\n+      d = byte2hex(d, *--value);\n+    }\n+  while (--i != 0);\n+  *d++ = ';';\n+  return d;\n+}\n+#endif /* DBG_MIN_SIZE */\n+\n+#ifdef __SDCC_gbz80\n+/* saves all state.except PC and SP */\n+static void\n+save_cpu_state() __naked\n+{\n+  __asm\n+\tpush\taf\n+\tld\ta, l\n+\tld\t(#_state + R_HL + 0), a\n+\tld\ta, h\n+\tld\t(#_state + R_HL + 1), a\n+\tld\thl, #_state + R_HL - 1\n+\tld\t(hl), d\n+\tdec\thl\n+\tld\t(hl), e\n+\tdec\thl\n+\tld\t(hl), b\n+\tdec\thl\n+\tld\t(hl), c\n+\tdec\thl\n+\tpop\tbc\n+\tld\t(hl), b\n+\tdec\thl\n+\tld\t(hl), c\n+\tret\n+  __endasm;\n+}\n+\n+/* restore CPU state and continue execution */\n+static void\n+rest_cpu_state() __naked\n+{\n+  __asm\n+;restore SP\n+\tld\ta, (#_state + R_SP + 0)\n+\tld\tl,a\n+\tld\ta, (#_state + R_SP + 1)\n+\tld\th,a\n+\tld\tsp, hl\n+;push PC value as return address\n+\tld\ta, (#_state + R_PC + 0)\n+\tld\tl, a\n+\tld\ta, (#_state + R_PC + 1)\n+\tld\th, a\n+\tpush\thl\n+;restore registers\n+\tld\thl, #_state + R_AF\n+\tld\tc, (hl)\n+\tinc\thl\n+\tld\tb, (hl)\n+\tinc\thl\n+\tpush\tbc\n+\tld\tc, (hl)\n+\tinc\thl\n+\tld\tb, (hl)\n+\tinc\thl\n+\tld\te, (hl)\n+\tinc\thl\n+\tld\td, (hl)\n+\tinc\thl\n+\tld\ta, (hl)\n+\tinc\thl\n+\tld\th, (hl)\n+\tld\tl, a\n+\tpop\taf\n+\tret\n+  __endasm;\n+}\n+#else\n+/* saves all state.except PC and SP */\n+static void\n+save_cpu_state() __naked\n+{\n+  __asm\n+\tld\t(#_state + R_HL), hl\n+\tld\t(#_state + R_DE), de\n+\tld\t(#_state + R_BC), bc\n+\tpush\taf\n+\tpop\thl\n+\tld\t(#_state + R_AF), hl\n+\tld\ta, r\t;R is increased by 7 or by 8 if called via RST\n+\tld\tl, a\n+\tsub\ta, #7\n+\txor\ta, l\n+\tand\ta, #0x7f\n+\txor\ta, l\n+#ifdef __SDCC_ez80_adl\n+\tld\thl, i\n+\tex\tde, hl\n+\tld\thl, #_state + R_IR\n+\tld\t(hl), a\n+\tinc\thl\n+\tld\t(hl), e\n+\tinc\thl\n+\tld\t(hl), d\n+\tld\ta, MB\n+\tld\t(#_state + R_AF+2), a\n+#else\n+\tld\tl, a\n+\tld\ta, i\n+\tld\th, a\n+\tld\t(#_state + R_IR), hl\n+#endif /* __SDCC_ez80_adl */\n+\tld\t(#_state + R_IX), ix\n+\tld\t(#_state + R_IY), iy\n+\tex\taf, af'\t;'\n+\texx\n+\tld\t(#_state + R_HL_), hl\n+\tld\t(#_state + R_DE_), de\n+\tld\t(#_state + R_BC_), bc\n+\tpush\taf\n+\tpop\thl\n+\tld\t(#_state + R_AF_), hl\n+\tret\n+  __endasm;\n+}\n+\n+/* restore CPU state and continue execution */\n+static void\n+rest_cpu_state() __naked\n+{\n+  __asm\n+#ifdef DBG_USE_TRAMPOLINE\n+\tld\tsp, _stack + DBG_STACK_SIZE\n+\tld\thl, (#_state + R_PC)\n+\tpush\thl\t/* resume address */\n+#ifdef __SDCC_ez80_adl\n+\tld\thl, 0xc30000 ; use 0xc34000 for jp.s\n+#else\n+\tld\thl, 0xc300\n+#endif\n+\tpush\thl\t/* JP opcode */\n+#endif /* DBG_USE_TRAMPOLINE */\n+\tld\thl, (#_state + R_AF_)\n+\tpush\thl\n+\tpop\taf\n+\tld\tbc, (#_state + R_BC_)\n+\tld\tde, (#_state + R_DE_)\n+\tld\thl, (#_state + R_HL_)\n+\texx\n+\tex\taf, af'\t;'\n+\tld\tiy, (#_state + R_IY)\n+\tld\tix, (#_state + R_IX)\n+#ifdef __SDCC_ez80_adl\n+\tld\ta, (#_state + R_AF + 2)\n+\tld\tMB, a\n+\tld\thl, (#_state + R_IR + 1) ;I register\n+\tld\ti, hl\n+\tld\ta, (#_state + R_IR + 0) ; R register\n+\tld\tl, a\n+#else\n+\tld\thl, (#_state + R_IR)\n+\tld\ta, h\n+\tld\ti, a\n+\tld\ta, l\n+#endif /* __SDCC_ez80_adl */\n+\tsub\ta, #10\t;number of M1 cycles after ld r,a\n+\txor\ta, l\n+\tand\ta, #0x7f\n+\txor\ta, l\n+\tld\tr, a\n+\tld\tde, (#_state + R_DE)\n+\tld\tbc, (#_state + R_BC)\n+\tld\thl, (#_state + R_AF)\n+\tpush\thl\n+\tpop\taf\n+\tld\tsp, (#_state + R_SP)\n+#ifndef DBG_USE_TRAMPOLINE\n+\tld\thl, (#_state + R_PC)\n+\tpush\thl\n+\tld\thl, (#_state + R_HL)\n+\tDBG_RESUME\n+#else\n+\tld\thl, (#_state + R_HL)\n+#ifdef __SDCC_ez80_adl\n+\tjp\t#_stack + DBG_STACK_SIZE - 4\n+#else\n+\tjp\t#_stack + DBG_STACK_SIZE - 3\n+#endif\n+#endif /* DBG_USE_TRAMPOLINE */\n+  __endasm;\n+}\n+#endif /* __SDCC_gbz80 */"
    },
    {
      "sha": "7b9a7e23501bc8c1351fe30af1252e20b1877df3",
      "filename": "gdb/z80-tdep.c",
      "status": "added",
      "additions": 1461,
      "deletions": 0,
      "changes": 1461,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/z80-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/z80-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/z80-tdep.c?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -0,0 +1,1461 @@\n+/* Target-dependent code for the Z80.\n+\n+   Copyright (C) 1986-2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"arch-utils.h\"\n+#include \"dis-asm.h\"\n+#include \"frame.h\"\n+#include \"frame-unwind.h\"\n+#include \"frame-base.h\"\n+#include \"trad-frame.h\"\n+#include \"gdbcmd.h\"\n+#include \"gdbcore.h\"\n+#include \"gdbtypes.h\"\n+#include \"inferior.h\"\n+#include \"objfiles.h\"\n+#include \"symfile.h\"\n+\n+#include \"z80-tdep.h\"\n+#include \"features/z80.c\"\n+\n+/* You need to define __gdb_break_handler symbol pointing to the breakpoint\n+   handler.  The value of the symbol will be used to determine the instruction\n+   for software breakpoint.  If __gdb_break_handler points to one of standard\n+   RST addresses (0x00, 0x08, 0x10,... 0x38) then RST __gdb_break_handler\n+   instruction will be used, else CALL __gdb_break_handler\n+\n+;breakpoint handler\n+\t.globl\t__gdb_break_handler\n+\t.org\t8\n+__gdb_break_handler:\n+\tjp\t_debug_swbreak\n+\n+*/\n+\n+/* Meaning of terms \"previous\" and \"next\":\n+     previous frame - frame of callee, which is called by current function\n+     current frame - frame of current function which has called callee\n+     next frame - frame of caller, which has called current function\n+*/\n+\n+struct gdbarch_tdep\n+{\n+  /* Number of bytes used for address:\n+      2 bytes for all Z80 family\n+      3 bytes for eZ80 CPUs operating in ADL mode */\n+  int addr_length;\n+\n+  /* Type for void.  */\n+  struct type *void_type;\n+  /* Type for a function returning void.  */\n+  struct type *func_void_type;\n+  /* Type for a pointer to a function.  Used for the type of PC.  */\n+  struct type *pc_type;\n+};\n+\n+/* At any time stack frame contains following parts:\n+   [<current PC>]\n+   [<temporaries, y bytes>]\n+   [<local variables, x bytes>\n+   <next frame FP>]\n+   [<saved state (critical or interrupt functions), 2 or 10 bytes>]\n+   In simplest case <next PC> is pointer to the call instruction\n+   (or call __call_hl). There are more difficult cases: interrupt handler or\n+   push/ret and jp; but they are untrackable.\n+*/\n+\n+struct z80_unwind_cache\n+{\n+  /* The previous frame's inner most stack address (SP after call executed),\n+     it is current frame's frame_id.  */\n+  CORE_ADDR prev_sp;\n+\n+  /* Size of the frame, prev_sp + size = next_frame.prev_sp */\n+  ULONGEST size;\n+\n+  /* size of saved state (including frame pointer and return address),\n+     assume: prev_sp + size = IX + state_size */\n+  ULONGEST state_size;\n+\n+  struct\n+  {\n+    int called:1;\t/* there is return address on stack */\n+    int load_args:1;\t/* prologues loads args using POPs */\n+    int fp_sdcc:1;\t/* prologue saves and adjusts frame pointer IX */\n+    int interrupt:1;\t/* __interrupt handler */\n+    int critical:1;\t/* __critical function */\n+  } prologue_type;\n+\n+  /* Table indicating the location of each and every register.  */\n+  struct trad_frame_saved_reg *saved_regs;\n+};\n+\n+enum instruction_type\n+{\n+  insn_default,\n+  insn_z80,\n+  insn_adl,\n+  insn_z80_ed,\n+  insn_adl_ed,\n+  insn_z80_ddfd,\n+  insn_adl_ddfd,\n+  insn_djnz_d,\n+  insn_jr_d,\n+  insn_jr_cc_d,\n+  insn_jp_nn,\n+  insn_jp_rr,\n+  insn_jp_cc_nn,\n+  insn_call_nn,\n+  insn_call_cc_nn,\n+  insn_rst_n,\n+  insn_ret,\n+  insn_ret_cc,\n+  insn_push_rr,\n+  insn_pop_rr,\n+  insn_dec_sp,\n+  insn_inc_sp,\n+  insn_ld_sp_nn,\n+  insn_ld_sp_6nn9, /* ld sp, (nn) */\n+  insn_ld_sp_rr,\n+  insn_force_nop /* invalid opcode prefix */\n+};\n+\n+struct insn_info\n+{\n+  gdb_byte code;\n+  gdb_byte mask;\n+  gdb_byte size; /* without prefix(es) */\n+  enum instruction_type type;\n+};\n+\n+/* Constants */\n+\n+static const struct insn_info *\n+z80_get_insn_info (struct gdbarch *gdbarch, const gdb_byte *buf, int *size);\n+\n+static const char *z80_reg_names[] =\n+{\n+  /* 24 bit on eZ80, else 16 bit */\n+  \"af\", \"bc\", \"de\", \"hl\",\n+  \"sp\", \"pc\", \"ix\", \"iy\",\n+  \"af'\", \"bc'\", \"de'\", \"hl'\",\n+  \"ir\",\n+  /* eZ80 only */\n+  \"sps\"\n+};\n+\n+/* Return the name of register REGNUM.  */\n+static const char *\n+z80_register_name (struct gdbarch *gdbarch, int regnum)\n+{\n+  if (regnum >= 0 && regnum < ARRAY_SIZE (z80_reg_names))\n+    return z80_reg_names[regnum];\n+\n+  return NULL;\n+}\n+\n+/* Return the type of a register specified by the architecture.  Only\n+   the register cache should call this function directly; others should\n+   use \"register_type\".  */\n+static struct type *\n+z80_register_type (struct gdbarch *gdbarch, int reg_nr)\n+{\n+  return builtin_type (gdbarch)->builtin_data_ptr;\n+}\n+\n+/* The next 2 functions check BUF for instruction.  If it is pop/push rr, then\n+   it returns register number OR'ed with 0x100 */\n+static int\n+z80_is_pop_rr (const gdb_byte buf[], int *size)\n+{\n+  switch (buf[0])\n+    {\n+    case 0xc1:\n+      *size = 1;\n+      return Z80_BC_REGNUM | 0x100;\n+    case 0xd1:\n+      *size = 1;\n+      return Z80_DE_REGNUM | 0x100;\n+    case 0xe1:\n+      *size = 1;\n+      return Z80_HL_REGNUM | 0x100;\n+    case 0xf1:\n+      *size = 1;\n+      return Z80_AF_REGNUM | 0x100;\n+    case 0xdd:\n+      *size = 2;\n+      return (buf[1] == 0xe1) ? (Z80_IX_REGNUM | 0x100) : 0;\n+    case 0xfd:\n+      *size = 2;\n+      return (buf[1] == 0xe1) ? (Z80_IY_REGNUM | 0x100) : 0;\n+    }\n+  *size = 0;\n+  return 0;\n+}\n+\n+static int\n+z80_is_push_rr (const gdb_byte buf[], int *size)\n+{\n+  switch (buf[0])\n+    {\n+    case 0xc5:\n+      *size = 1;\n+      return Z80_BC_REGNUM | 0x100;\n+    case 0xd5:\n+      *size = 1;\n+      return Z80_DE_REGNUM | 0x100;\n+    case 0xe5:\n+      *size = 1;\n+      return Z80_HL_REGNUM | 0x100;\n+    case 0xf5:\n+      *size = 1;\n+      return Z80_AF_REGNUM | 0x100;\n+    case 0xdd:\n+      *size = 2;\n+      return (buf[1] == 0xe5) ? (Z80_IX_REGNUM | 0x100) : 0;\n+    case 0xfd:\n+      *size = 2;\n+      return (buf[1] == 0xe5) ? (Z80_IY_REGNUM | 0x100) : 0;\n+    }\n+  *size = 0;\n+  return 0;\n+}\n+\n+/* Function: z80_scan_prologue\n+\n+   This function decodes a function prologue to determine:\n+     1) the size of the stack frame\n+     2) which registers are saved on it\n+     3) the offsets of saved regs\n+   This information is stored in the z80_unwind_cache structure.\n+   Small SDCC functions may just load args using POP instructions in prologue:\n+\tpop\taf\n+\tpop\tde\n+\tpop\thl\n+\tpop\tbc\n+\tpush\tbc\n+\tpush\thl\n+\tpush\tde\n+\tpush\taf\n+   SDCC function prologue may have up to 3 sections (all are optional):\n+     1) save state\n+       a) __critical functions:\n+\tld\ta,i\n+\tdi\n+\tpush\taf\n+       b) __interrupt (both int and nmi) functions:\n+\tpush\taf\n+\tpush\tbc\n+\tpush\tde\n+\tpush\thl\n+\tpush\tiy\n+     2) save and adjust frame pointer\n+       a) call to special function (size optimization)\n+\tcall\t___sdcc_enter_ix\n+       b) inline (speed optimization)\n+\tpush\tix\n+\tld\tix, #0\n+\tadd\tix, sp\n+       c) without FP, but saving it (IX is optimized out)\n+\tpush\tix\n+     3) allocate local variables\n+       a) via series of PUSH AF and optional DEC SP (size optimization)\n+\tpush\taf\n+\t...\n+\tpush\taf\n+\tdec\tsp\t;optional, if allocated odd numbers of bytes\n+       b) via SP decrements\n+\tdec\tsp\n+\t...\n+\tdec\tsp\n+       c) via addition (for large frames: 5+ for speed and 9+ for size opt.)\n+\tld\thl, #xxxx\t;size of stack frame\n+\tadd\thl, sp\n+\tld\tsp, hl\n+       d) same, but using register IY (arrays or for __z88dk_fastcall functions)\n+\tld\tiy, #xxxx\t;size of stack frame\n+\tadd\tiy, sp\n+\tld\tsp, iy\n+       e) same as c, but for eZ80\n+\tlea\thl, ix - #nn\n+\tld\tsp, hl\n+       f) same as d, but for eZ80\n+\tlea\tiy, ix - #nn\n+\tld\tsp, iy\n+*/\n+\n+static int\n+z80_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n+\t\t   struct z80_unwind_cache *info)\n+{\n+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+  int addr_len = gdbarch_tdep (gdbarch)->addr_length;\n+  gdb_byte prologue[32]; /* max prologue is 24 bytes: __interrupt with local array */\n+  int pos = 0;\n+  int len;\n+  int reg;\n+  CORE_ADDR value;\n+\n+  len = pc_end - pc_beg;\n+  if (len > (int)sizeof (prologue))\n+    len = sizeof (prologue);\n+\n+  read_memory (pc_beg, prologue, len);\n+\n+  /* stage0: check for series of POPs and then PUSHs */\n+  if ((reg = z80_is_pop_rr(prologue, &pos)))\n+    {\n+      int i;\n+      int size = pos;\n+      gdb_byte regs[8]; /* Z80 have only 6 register pairs */\n+      regs[0] = reg & 0xff;\n+      for (i = 1; i < 8 && (regs[i] = z80_is_pop_rr (&prologue[pos], &size));\n+\t   ++i, pos += size);\n+      /* now we expect series of PUSHs in reverse order */\n+      for (--i; i >= 0 && regs[i] == z80_is_push_rr (&prologue[pos], &size);\n+\t   --i, pos += size);\n+      if (i == -1 && pos > 0)\n+\tinfo->prologue_type.load_args = 1;\n+      else\n+\tpos = 0;\n+    }\n+  /* stage1: check for __interrupt handlers and __critical functions */\n+  else if (!memcmp (&prologue[pos], \"\\355\\127\\363\\365\", 4))\n+    { /* ld a, i; di; push af */\n+      info->prologue_type.critical = 1;\n+      pos += 4;\n+      info->state_size += addr_len;\n+    }\n+  else if (!memcmp (&prologue[pos], \"\\365\\305\\325\\345\\375\\345\", 6))\n+    { /* push af; push bc; push de; push hl; push iy */\n+      info->prologue_type.interrupt = 1;\n+      pos += 6;\n+      info->state_size += addr_len * 5;\n+    }\n+\n+  /* stage2: check for FP saving scheme */\n+  if (prologue[pos] == 0xcd) /* call nn */\n+    {\n+      struct bound_minimal_symbol msymbol;\n+      msymbol = lookup_minimal_symbol (\"__sdcc_enter_ix\", NULL, NULL);\n+      if (msymbol.minsym)\n+\t{\n+\t  value = BMSYMBOL_VALUE_ADDRESS (msymbol);\n+\t  if (value == extract_unsigned_integer (&prologue[pos+1], addr_len, byte_order))\n+\t    {\n+\t      pos += 1 + addr_len;\n+\t      info->prologue_type.fp_sdcc = 1;\n+\t    }\n+\t}\n+    }\n+  else if (!memcmp (&prologue[pos], \"\\335\\345\\335\\041\\000\\000\", 4+addr_len) &&\n+\t   !memcmp (&prologue[pos+4+addr_len], \"\\335\\071\\335\\371\", 4))\n+    { /* push ix; ld ix, #0; add ix, sp; ld sp, ix */\n+      pos += 4 + addr_len + 4;\n+      info->prologue_type.fp_sdcc = 1;\n+    }\n+  else if (!memcmp (&prologue[pos], \"\\335\\345\", 2))\n+    { /* push ix */\n+      pos += 2;\n+      info->prologue_type.fp_sdcc = 1;\n+    }\n+\n+  /* stage3: check for local variables allocation */\n+  switch (prologue[pos])\n+    {\n+      case 0xf5: /* push af */\n+\tinfo->size = 0;\n+\twhile (prologue[pos] == 0xf5)\n+\t  {\n+\t    info->size += addr_len;\n+\t    pos++;\n+\t  }\n+\tif (prologue[pos] == 0x3b) /* dec sp */\n+\t  {\n+\t    info->size++;\n+\t    pos++;\n+\t  }\n+\tbreak;\n+      case 0x3b: /* dec sp */\n+\tinfo->size = 0;\n+\twhile (prologue[pos] == 0x3b)\n+\t  {\n+\t    info->size++;\n+\t    pos++;\n+\t  }\n+\tbreak;\n+      case 0x21: /*ld hl, -nn */\n+\tif (prologue[pos+addr_len] == 0x39 && prologue[pos+addr_len] >= 0x80 &&\n+\t    prologue[pos+addr_len+1] == 0xf9)\n+\t  { /* add hl, sp; ld sp, hl */\n+\t    info->size = -extract_signed_integer(&prologue[pos+1], addr_len, byte_order);\n+\t    pos += 1 + addr_len + 2;\n+\t  }\n+\tbreak;\n+      case 0xfd: /* ld iy, -nn */\n+\tif (prologue[pos+1] == 0x21 && prologue[pos+1+addr_len] >= 0x80 &&\n+\t    !memcmp (&prologue[pos+2+addr_len], \"\\375\\071\\375\\371\", 4))\n+\t  {\n+\t    info->size = -extract_signed_integer(&prologue[pos+2], addr_len, byte_order);\n+\t    pos += 2 + addr_len + 4;\n+\t  }\n+\tbreak;\n+      case 0xed: /* check for lea xx, ix - n */\n+\tswitch (prologue[pos+1])\n+\t  {\n+\t  case 0x22: /* lea hl, ix - n */\n+\t    if (prologue[pos+2] >= 0x80 && prologue[pos+3] == 0xf9)\n+\t      { /* ld sp, hl */\n+\t\tinfo->size = -extract_signed_integer(&prologue[pos+2], 1, byte_order);\n+\t\tpos += 4;\n+\t      }\n+\t    break;\n+\t  case 0x55: /* lea iy, ix - n */\n+\t    if (prologue[pos+2] >= 0x80 && prologue[pos+3] == 0xfd &&\n+\t\tprologue[pos+4] == 0xf9)\n+\t      { /* ld sp, iy */\n+\t\tinfo->size = -extract_signed_integer(&prologue[pos+2], 1, byte_order);\n+\t\tpos += 5;\n+\t      }\n+\t    break;\n+\t  }\n+\t  break;\n+    }\n+  len = 0;\n+\n+  if (info->prologue_type.interrupt)\n+    {\n+      info->saved_regs[Z80_AF_REGNUM].set_addr (len++);\n+      info->saved_regs[Z80_BC_REGNUM].set_addr (len++);\n+      info->saved_regs[Z80_DE_REGNUM].set_addr (len++);\n+      info->saved_regs[Z80_HL_REGNUM].set_addr (len++);\n+      info->saved_regs[Z80_IY_REGNUM].set_addr (len++);\n+    }\n+\n+  if (info->prologue_type.critical)\n+    len++; /* just skip IFF2 saved state */\n+\n+  if (info->prologue_type.fp_sdcc)\n+    info->saved_regs[Z80_IX_REGNUM].set_addr (len++);\n+\n+  info->state_size += len * addr_len;\n+\n+  return pc_beg + pos;\n+}\n+\n+static CORE_ADDR\n+z80_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n+{\n+  CORE_ADDR func_addr, func_end;\n+  CORE_ADDR prologue_end;\n+\n+  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))\n+    return pc;\n+\n+  prologue_end = skip_prologue_using_sal (gdbarch, func_addr);\n+  if (prologue_end != 0)\n+    return std::max (pc, prologue_end);\n+\n+  {\n+    struct z80_unwind_cache info = {0};\n+    struct trad_frame_saved_reg saved_regs[Z80_NUM_REGS];\n+\n+    info.saved_regs = saved_regs;\n+\n+    /* Need to run the prologue scanner to figure out if the function has a\n+       prologue.  */\n+\n+    prologue_end = z80_scan_prologue (gdbarch, func_addr, func_end, &info);\n+\n+    if (info.prologue_type.fp_sdcc || info.prologue_type.interrupt ||\n+\tinfo.prologue_type.critical)\n+      return std::max (pc, prologue_end);\n+  }\n+\n+  if (prologue_end != 0)\n+    {\n+      struct symtab_and_line prologue_sal = find_pc_line (func_addr, 0);\n+      struct compunit_symtab *compunit = SYMTAB_COMPUNIT (prologue_sal.symtab);\n+      const char *debug_format = COMPUNIT_DEBUGFORMAT (compunit);\n+\n+      if (debug_format != NULL &&\n+\t  !strncasecmp (\"dwarf\", debug_format, strlen(\"dwarf\")))\n+\treturn std::max (pc, prologue_end);\n+    }\n+\n+  return pc;\n+}\n+\n+/* Return the return-value convention that will be used by FUNCTION\n+   to return a value of type VALTYPE.  FUNCTION may be NULL in which\n+   case the return convention is computed based only on VALTYPE.\n+\n+   If READBUF is not NULL, extract the return value and save it in this buffer.\n+\n+   If WRITEBUF is not NULL, it contains a return value which will be\n+   stored into the appropriate register.  This can be used when we want\n+   to force the value returned by a function (see the \"return\" command\n+   for instance).  */\n+static enum return_value_convention\n+z80_return_value (struct gdbarch *gdbarch, struct value *function,\n+\t\t  struct type *valtype, struct regcache *regcache,\n+\t\t  gdb_byte *readbuf, const gdb_byte *writebuf)\n+{\n+  /* Byte are returned in L, word in HL, dword in DEHL.  */\n+  int len = TYPE_LENGTH (valtype);\n+\n+  if ((valtype->code () == TYPE_CODE_STRUCT\n+       || valtype->code () == TYPE_CODE_UNION\n+       || valtype->code () == TYPE_CODE_ARRAY)\n+      && len > 4)\n+    return RETURN_VALUE_STRUCT_CONVENTION;\n+\n+  if (writebuf != NULL)\n+    {\n+      if (len > 2)\n+\t{\n+\t  regcache->cooked_write_part (Z80_DE_REGNUM, 0, len - 2, writebuf+2);\n+\t  len = 2;\n+\t}\n+      regcache->cooked_write_part (Z80_HL_REGNUM, 0, len, writebuf);\n+    }\n+\n+  if (readbuf != NULL)\n+    {\n+      if (len > 2)\n+\t{\n+\t  regcache->cooked_read_part (Z80_DE_REGNUM, 0, len - 2, readbuf+2);\n+\t  len = 2;\n+\t}\n+      regcache->cooked_read_part (Z80_HL_REGNUM, 0, len, readbuf);\n+    }\n+\n+  return RETURN_VALUE_REGISTER_CONVENTION;\n+}\n+\n+/* function unwinds current stack frame and returns next one */\n+static struct z80_unwind_cache *\n+z80_frame_unwind_cache (struct frame_info *this_frame,\n+\t\t\tvoid **this_prologue_cache)\n+{\n+  CORE_ADDR start_pc, current_pc;\n+  ULONGEST this_base;\n+  int i;\n+  gdb_byte buf[sizeof(void*)];\n+  struct z80_unwind_cache *info;\n+  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n+  int addr_len = gdbarch_tdep (gdbarch)->addr_length;\n+\n+  if (*this_prologue_cache)\n+    return (struct z80_unwind_cache *) *this_prologue_cache;\n+\n+  info = FRAME_OBSTACK_ZALLOC (struct z80_unwind_cache);\n+  memset (info, 0, sizeof (*info));\n+  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);\n+  *this_prologue_cache = info;\n+\n+  start_pc = get_frame_func (this_frame);\n+  current_pc = get_frame_pc (this_frame);\n+  if ((start_pc > 0) && (start_pc <= current_pc))\n+    z80_scan_prologue (get_frame_arch (this_frame),\n+\t\t       start_pc, current_pc, info);\n+\n+  if (info->prologue_type.fp_sdcc)\n+    {\n+      /*  With SDCC standard prologue, IX points to the end of current frame\n+\t  (where previous frame pointer and state are saved).  */\n+      this_base = get_frame_register_unsigned (this_frame, Z80_IX_REGNUM);\n+      info->prev_sp = this_base + info->size;\n+    }\n+  else\n+    {\n+      CORE_ADDR addr;\n+      CORE_ADDR sp;\n+      CORE_ADDR sp_mask = (1 << gdbarch_ptr_bit(gdbarch)) - 1;\n+      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+      /* Assume that the FP is this frame's SP but with that pushed\n+\t stack space added back.  */\n+      this_base = get_frame_register_unsigned (this_frame, Z80_SP_REGNUM);\n+      sp = this_base + info->size;\n+      for (;; ++sp)\n+\t{\n+\t  sp &= sp_mask;\n+\t  if (sp < this_base)\n+\t    { /* overflow, looks like end of stack */\n+\t      sp = this_base + info->size;\n+\t      break;\n+\t    }\n+\t  /* find return address */\n+\t  read_memory (sp, buf, addr_len);\n+\t  addr = extract_unsigned_integer(buf, addr_len, byte_order);\n+\t  read_memory (addr-addr_len-1, buf, addr_len+1);\n+\t  if (buf[0] == 0xcd || (buf[0] & 0307) == 0304) /* Is it CALL */\n+\t    { /* CALL nn or CALL cc,nn */\n+\t      static const char *names[] =\n+\t\t{\n+\t\t  \"__sdcc_call_ix\", \"__sdcc_call_iy\", \"__sdcc_call_hl\"\n+\t\t};\n+\t      addr = extract_unsigned_integer(buf+1, addr_len, byte_order);\n+\t      if (addr == start_pc)\n+\t\tbreak; /* found */\n+\t      for (i = sizeof(names)/sizeof(*names)-1; i >= 0; --i)\n+\t\t{\n+\t\t  struct bound_minimal_symbol msymbol;\n+\t\t  msymbol = lookup_minimal_symbol (names[i], NULL, NULL);\n+\t\t  if (!msymbol.minsym)\n+\t\t    continue;\n+\t\t  if (addr == BMSYMBOL_VALUE_ADDRESS (msymbol))\n+\t\t    break;\n+\t\t}\n+\t      if (i >= 0)\n+\t\tbreak;\n+\t      continue;\n+\t    }\n+\t  else\n+\t    continue; /* it is not call_nn, call_cc_nn */\n+\t}\n+      info->prev_sp = sp;\n+    }\n+\n+  /* Adjust all the saved registers so that they contain addresses and not\n+     offsets.  */\n+  for (i = 0; i < gdbarch_num_regs (gdbarch) - 1; i++)\n+    if (info->saved_regs[i].addr () > 0)\n+      info->saved_regs[i].set_addr\n+\t(info->prev_sp - info->saved_regs[i].addr () * addr_len);\n+\n+  /* Except for the startup code, the return PC is always saved on\n+     the stack and is at the base of the frame.  */\n+  info->saved_regs[Z80_PC_REGNUM].set_addr (info->prev_sp);\n+\n+  /* The previous frame's SP needed to be computed.  Save the computed\n+     value.  */\n+  info->saved_regs[Z80_SP_REGNUM].set_value (info->prev_sp + addr_len);\n+  return info;\n+}\n+\n+/* Given a GDB frame, determine the address of the calling function's\n+   frame.  This will be used to create a new GDB frame struct.  */\n+static void\n+z80_frame_this_id (struct frame_info *this_frame, void **this_cache,\n+\t\t   struct frame_id *this_id)\n+{\n+  struct frame_id id;\n+  struct z80_unwind_cache *info;\n+  CORE_ADDR base;\n+  CORE_ADDR func;\n+\n+  /* The FUNC is easy.  */\n+  func = get_frame_func (this_frame);\n+\n+  info = z80_frame_unwind_cache (this_frame, this_cache);\n+  /* Hopefully the prologue analysis either correctly determined the\n+     frame's base (which is the SP from the previous frame), or set\n+     that base to \"NULL\".  */\n+  base = info->prev_sp;\n+  if (base == 0)\n+    return;\n+\n+  id = frame_id_build (base, func);\n+  *this_id = id;\n+}\n+\n+static struct value *\n+z80_frame_prev_register (struct frame_info *this_frame,\n+\t\t\t void **this_prologue_cache, int regnum)\n+{\n+  struct z80_unwind_cache *info\n+    = z80_frame_unwind_cache (this_frame, this_prologue_cache);\n+\n+  if (regnum == Z80_PC_REGNUM)\n+    {\n+      if (info->saved_regs[Z80_PC_REGNUM].is_addr ())\n+\t{\n+\t  /* Reading the return PC from the PC register is slightly\n+\t     abnormal.  */\n+\t  ULONGEST pc;\n+\t  gdb_byte buf[3];\n+\t  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n+\t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\t  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+\n+\t  read_memory (info->saved_regs[Z80_PC_REGNUM].addr (),\n+\t\t       buf, tdep->addr_length);\n+\t  pc = extract_unsigned_integer (buf, tdep->addr_length, byte_order);\n+\t  return frame_unwind_got_constant (this_frame, regnum, pc);\n+\t}\n+\n+      return frame_unwind_got_optimized (this_frame, regnum);\n+    }\n+\n+  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);\n+}\n+\n+/* Return the breakpoint kind for this target based on *PCPTR.  */\n+static int\n+z80_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)\n+{\n+  static int addr = -1;\n+  if (addr == -1)\n+    {\n+      struct bound_minimal_symbol bh;\n+      bh = lookup_minimal_symbol (\"_break_handler\", NULL, NULL);\n+      if (bh.minsym)\n+\taddr = BMSYMBOL_VALUE_ADDRESS (bh);\n+      else\n+\t{\n+\t  warning(_(\"Unable to determine inferior's software breakpoint type: \"\n+\t\t    \"couldn't find `_break_handler' function in inferior. Will \"\n+\t\t    \"be used default software breakpoint instruction RST 0x08.\"));\n+\t  addr = 0x0008;\n+\t}\n+    }\n+  return addr;\n+}\n+\n+/* Return the software breakpoint from KIND. KIND is just address of breakpoint\n+   handler.  If address is on of standard RSTs, then RST n instruction is used\n+   as breakpoint.\n+   SIZE is set to the software breakpoint's length in memory.  */\n+static const gdb_byte *\n+z80_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)\n+{\n+  static gdb_byte break_insn[8];\n+\n+  if ((kind & 070) == kind)\n+    {\n+      break_insn[0] = kind | 0307;\n+      *size = 1;\n+    }\n+  else /* kind is non-RST address, use CALL instead, but it is dungerous */\n+    {\n+      gdb_byte *p = break_insn;\n+      *p++ = 0xcd;\n+      *p++ = (kind >> 0) & 0xff;\n+      *p++ = (kind >> 8) & 0xff;\n+      if (gdbarch_tdep (gdbarch)->addr_length > 2)\n+\t*p++ = (kind >> 16) & 0xff;\n+      *size = p - break_insn;\n+    }\n+  return break_insn;\n+}\n+\n+/* Return a vector of addresses on which the software single step\n+   breakpoints should be inserted.  NULL means software single step is\n+   not used.\n+   Only one breakpoint address will be returned: conditional branches\n+   will be always evaluated. */\n+static std::vector<CORE_ADDR>\n+z80_software_single_step (struct regcache *regcache)\n+{\n+  static const int flag_mask[] = {1 << 6, 1 << 0, 1 << 2, 1 << 7};\n+  gdb_byte buf[8];\n+  ULONGEST t;\n+  ULONGEST addr;\n+  int opcode;\n+  int size;\n+  const struct insn_info *info;\n+  std::vector<CORE_ADDR> ret (1);\n+  struct gdbarch *gdbarch = target_gdbarch ();\n+\n+  regcache->cooked_read (Z80_PC_REGNUM, &addr);\n+  read_memory (addr, buf, sizeof(buf));\n+  info = z80_get_insn_info (gdbarch, buf, &size);\n+  ret[0] = addr + size;\n+  if (info == NULL) /* possible in case of double prefix */\n+    { /* forced NOP, TODO: replace by NOP */\n+      return ret;\n+    }\n+  opcode = buf[size - info->size]; /* take opcode instead of prefix */\n+  /* stage 1: check for conditions */\n+  switch (info->type)\n+    {\n+    case insn_djnz_d:\n+      regcache->cooked_read (Z80_BC_REGNUM, &t);\n+      if ((t & 0xff00) != 0x100)\n+\treturn ret;\n+      break;\n+    case insn_jr_cc_d:\n+      opcode &= 030; /* JR NZ,d has cc equal to 040, but others 000 */\n+      /* fall through */\n+    case insn_jp_cc_nn:\n+    case insn_call_cc_nn:\n+    case insn_ret_cc:\n+      regcache->cooked_read (Z80_AF_REGNUM, &t);\n+      /* lower bit of condition inverts match, so invert flags if set */\n+      if ((opcode & 010) != 0)\n+\tt = ~t;\n+      /* two higher bits of condition field defines flag, so use them only\n+\t to check condition of \"not execute\" */\n+      if (t & flag_mask[(opcode >> 4) & 3])\n+\treturn ret;\n+      break;\n+    }\n+  /* stage 2: compute address */\n+  /* TODO: implement eZ80 MADL support */\n+  switch (info->type)\n+    {\n+    default:\n+      return ret;\n+    case insn_djnz_d:\n+    case insn_jr_d:\n+    case insn_jr_cc_d:\n+      addr += size;\n+      addr += (signed char)buf[size-1];\n+      break;\n+    case insn_jp_rr:\n+      if (size == 1)\n+\topcode = Z80_HL_REGNUM;\n+      else\n+\topcode = (buf[size-2] & 0x20) ? Z80_IY_REGNUM : Z80_IX_REGNUM;\n+      regcache->cooked_read (opcode, &addr);\n+      break;\n+    case insn_jp_nn:\n+    case insn_jp_cc_nn:\n+    case insn_call_nn:\n+    case insn_call_cc_nn:\n+      addr = buf[size-1] * 0x100 + buf[size-2];\n+      if (info->size > 3) /* long instruction mode */\n+\taddr = addr * 0x100 + buf[size-3];\n+      break;\n+    case insn_rst_n:\n+      addr = opcode & 070;\n+      break;\n+    case insn_ret:\n+    case insn_ret_cc:\n+      regcache->cooked_read (Z80_SP_REGNUM, &addr);\n+      read_memory (addr, buf, 3);\n+      addr = buf[1] * 0x100 + buf[0];\n+      if (gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_ez80_adl)\n+\taddr = addr * 0x100 + buf[2];\n+      break;\n+    }\n+  ret[0] = addr;\n+  return ret;\n+}\n+\n+/* Cached, dynamically allocated copies of the target data structures: */\n+static unsigned (*cache_ovly_region_table)[3] = 0;\n+static unsigned cache_novly_regions;\n+static CORE_ADDR cache_ovly_region_table_base = 0;\n+enum ovly_index\n+  {\n+    VMA, OSIZE, MAPPED_TO_LMA\n+  };\n+\n+static void\n+z80_free_overlay_region_table (void)\n+{\n+  if (cache_ovly_region_table)\n+    xfree (cache_ovly_region_table);\n+  cache_novly_regions = 0;\n+  cache_ovly_region_table = NULL;\n+  cache_ovly_region_table_base = 0;\n+}\n+\n+/* Read an array of ints of size SIZE from the target into a local buffer.\n+   Convert to host order.  LEN is number of ints.  */\n+\n+static void\n+read_target_long_array (CORE_ADDR memaddr, unsigned int *myaddr,\n+\t\t\tint len, int size, enum bfd_endian byte_order)\n+{\n+  /* alloca is safe here, because regions array is very small. */\n+  gdb_byte *buf = (gdb_byte *) alloca (len * size);\n+  int i;\n+\n+  read_memory (memaddr, buf, len * size);\n+  for (i = 0; i < len; i++)\n+    myaddr[i] = extract_unsigned_integer (size * i + buf, size, byte_order);\n+}\n+\n+static int\n+z80_read_overlay_region_table ()\n+{\n+  struct bound_minimal_symbol novly_regions_msym;\n+  struct bound_minimal_symbol ovly_region_table_msym;\n+  struct gdbarch *gdbarch;\n+  int word_size;\n+  enum bfd_endian byte_order;\n+\n+  z80_free_overlay_region_table ();\n+  novly_regions_msym = lookup_minimal_symbol (\"_novly_regions\", NULL, NULL);\n+  if (! novly_regions_msym.minsym)\n+    {\n+      error (_(\"Error reading inferior's overlay table: \"\n+\t       \"couldn't find `_novly_regions'\\n\"\n+\t       \"variable in inferior.  Use `overlay manual' mode.\"));\n+      return 0;\n+    }\n+\n+  ovly_region_table_msym = lookup_bound_minimal_symbol (\"_ovly_region_table\");\n+  if (! ovly_region_table_msym.minsym)\n+    {\n+      error (_(\"Error reading inferior's overlay table: couldn't find \"\n+\t       \"`_ovly_region_table'\\n\"\n+\t       \"array in inferior.  Use `overlay manual' mode.\"));\n+      return 0;\n+    }\n+\n+  const enum overlay_debugging_state save_ovly_dbg = overlay_debugging;\n+  /* prevent infinite recurse */\n+  overlay_debugging = ovly_off;\n+\n+  gdbarch = ovly_region_table_msym.objfile->arch ();\n+  word_size = gdbarch_long_bit (gdbarch) / TARGET_CHAR_BIT;\n+  byte_order = gdbarch_byte_order (gdbarch);\n+\n+  cache_novly_regions = read_memory_integer (\n+\t\t\t\tBMSYMBOL_VALUE_ADDRESS (novly_regions_msym),\n+\t\t\t\t4, byte_order);\n+  cache_ovly_region_table\n+    = (unsigned int (*)[3]) xmalloc (cache_novly_regions *\n+\t\t\t\t\tsizeof (*cache_ovly_region_table));\n+  cache_ovly_region_table_base\n+    = BMSYMBOL_VALUE_ADDRESS (ovly_region_table_msym);\n+  read_target_long_array (cache_ovly_region_table_base,\n+\t\t\t  (unsigned int *) cache_ovly_region_table,\n+\t\t\t  cache_novly_regions * 3, word_size, byte_order);\n+\n+  overlay_debugging = save_ovly_dbg;\n+  return 1;                     /* SUCCESS */\n+}\n+\n+static int\n+z80_overlay_update_1 (struct obj_section *osect)\n+{\n+  int i;\n+  asection *bsect = osect->the_bfd_section;\n+  unsigned lma;\n+  unsigned vma = bfd_section_vma (bsect);\n+\n+  /* find region corresponding to the section VMA */\n+  for (i = 0; i < cache_novly_regions; i++)\n+    if (cache_ovly_region_table[i][VMA] == vma)\n+\tbreak;\n+  if (i == cache_novly_regions)\n+    return 0; /* no such region */\n+\n+  lma = cache_ovly_region_table[i][MAPPED_TO_LMA];\n+  i = 0;\n+\n+  /* we have interest for sections with same VMA */\n+  for (objfile *objfile : current_program_space->objfiles ())\n+    ALL_OBJFILE_OSECTIONS (objfile, osect)\n+      if (section_is_overlay (osect))\n+\t{\n+\t  osect->ovly_mapped = (lma == bfd_section_lma (osect->the_bfd_section));\n+\t  i |= osect->ovly_mapped; /* true, if at least one section is mapped */\n+\t}\n+  return i;\n+}\n+\n+/* Refresh overlay mapped state for section OSECT.  */\n+static void\n+z80_overlay_update (struct obj_section *osect)\n+{\n+  /* Always need to read the entire table anew.  */\n+  if (!z80_read_overlay_region_table ())\n+    return;\n+\n+  /* Were we given an osect to look up?  NULL means do all of them.  */\n+  if (osect != nullptr && z80_overlay_update_1 (osect))\n+    return;\n+\n+  /* Update all sections, even if only one was requested.  */\n+  for (objfile *objfile : current_program_space->objfiles ())\n+    ALL_OBJFILE_OSECTIONS (objfile, osect)\n+      {\n+\tif (!section_is_overlay (osect))\n+\t  continue;\n+\n+\tasection *bsect = osect->the_bfd_section;\n+\tbfd_vma lma = bfd_section_lma (bsect);\n+\tbfd_vma vma = bfd_section_vma (bsect);\n+\n+\tfor (int i = 0; i < cache_novly_regions; ++i)\n+\t  if (cache_ovly_region_table[i][VMA] == vma)\n+\t    osect->ovly_mapped =\n+\t      (cache_ovly_region_table[i][MAPPED_TO_LMA] == lma);\n+      }\n+}\n+\n+/* Return non-zero if the instruction at ADDR is a call; zero otherwise.  */\n+static int\n+z80_insn_is_call (struct gdbarch *gdbarch, CORE_ADDR addr)\n+{\n+  gdb_byte buf[8];\n+  int size;\n+  const struct insn_info *info;\n+  read_memory (addr, buf, sizeof(buf));\n+  info = z80_get_insn_info (gdbarch, buf, &size);\n+  if (info)\n+    switch (info->type)\n+      {\n+      case insn_call_nn:\n+      case insn_call_cc_nn:\n+      case insn_rst_n:\n+\treturn 1;\n+      }\n+  return 0;\n+}\n+\n+/* Return non-zero if the instruction at ADDR is a return; zero otherwise. */\n+static int\n+z80_insn_is_ret (struct gdbarch *gdbarch, CORE_ADDR addr)\n+{\n+  gdb_byte buf[8];\n+  int size;\n+  const struct insn_info *info;\n+  read_memory (addr, buf, sizeof(buf));\n+  info = z80_get_insn_info (gdbarch, buf, &size);\n+  if (info)\n+    switch (info->type)\n+      {\n+      case insn_ret:\n+      case insn_ret_cc:\n+\treturn 1;\n+      }\n+  return 0;\n+}\n+\n+/* Return non-zero if the instruction at ADDR is a jump; zero otherwise.  */\n+static int\n+z80_insn_is_jump (struct gdbarch *gdbarch, CORE_ADDR addr)\n+{\n+  gdb_byte buf[8];\n+  int size;\n+  const struct insn_info *info;\n+  read_memory (addr, buf, sizeof(buf));\n+  info = z80_get_insn_info (gdbarch, buf, &size);\n+  if (info)\n+    switch (info->type)\n+      {\n+      case insn_jp_nn:\n+      case insn_jp_cc_nn:\n+      case insn_jp_rr:\n+      case insn_jr_d:\n+      case insn_jr_cc_d:\n+      case insn_djnz_d:\n+\treturn 1;\n+      }\n+  return 0;\n+}\n+\n+static const struct frame_unwind\n+z80_frame_unwind =\n+{\n+  \"z80\",\n+  NORMAL_FRAME,\n+  default_frame_unwind_stop_reason,\n+  z80_frame_this_id,\n+  z80_frame_prev_register,\n+  NULL, /*unwind_data*/\n+  default_frame_sniffer\n+  /*dealloc_cache*/\n+  /*prev_arch*/\n+};\n+\n+/* Initialize the gdbarch struct for the Z80 arch */\n+static struct gdbarch *\n+z80_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n+{\n+  struct gdbarch *gdbarch;\n+  struct gdbarch_tdep *tdep;\n+  struct gdbarch_list *best_arch;\n+  tdesc_arch_data_up tdesc_data;\n+  unsigned long mach = info.bfd_arch_info->mach;\n+  const struct target_desc *tdesc = info.target_desc;\n+\n+  if (!tdesc_has_registers (tdesc))\n+    /* Pick a default target description.  */\n+    tdesc = tdesc_z80;\n+\n+  /* Check any target description for validity.  */\n+  if (tdesc_has_registers (tdesc))\n+    {\n+      const struct tdesc_feature *feature;\n+      int valid_p;\n+\n+      feature = tdesc_find_feature (tdesc, \"org.gnu.gdb.z80.cpu\");\n+      if (feature == NULL)\n+\treturn NULL;\n+\n+      tdesc_data = tdesc_data_alloc ();\n+\n+      valid_p = 1;\n+\n+      for (unsigned i = 0; i < Z80_NUM_REGS; i++)\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n+\t\t\t\t\t    z80_reg_names[i]);\n+\n+      if (!valid_p)\n+\treturn NULL;\n+    }\n+\n+  /* If there is already a candidate, use it.  */\n+  for (best_arch = gdbarch_list_lookup_by_info (arches, &info);\n+       best_arch != NULL;\n+       best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))\n+    {\n+      if (mach == gdbarch_bfd_arch_info (best_arch->gdbarch)->mach)\n+\treturn best_arch->gdbarch;\n+    }\n+\n+  /* None found, create a new architecture from the information provided.  */\n+  tdep = XCNEW (struct gdbarch_tdep);\n+  gdbarch = gdbarch_alloc (&info, tdep);\n+\n+  if (mach == bfd_mach_ez80_adl)\n+    {\n+      tdep->addr_length = 3;\n+      set_gdbarch_max_insn_length (gdbarch, 6);\n+    }\n+  else\n+    {\n+      tdep->addr_length = 2;\n+      set_gdbarch_max_insn_length (gdbarch, 4);\n+    }\n+\n+  /* Create a type for PC.  We can't use builtin types here, as they may not\n+     be defined.  */\n+  tdep->void_type = arch_type (gdbarch, TYPE_CODE_VOID, TARGET_CHAR_BIT,\n+\t\t\t       \"void\");\n+  tdep->func_void_type = make_function_type (tdep->void_type, NULL);\n+  tdep->pc_type = arch_pointer_type (gdbarch,\n+\t\t\t\t     tdep->addr_length * TARGET_CHAR_BIT,\n+\t\t\t\t     NULL, tdep->func_void_type);\n+\n+  set_gdbarch_short_bit (gdbarch, TARGET_CHAR_BIT);\n+  set_gdbarch_int_bit (gdbarch, 2 * TARGET_CHAR_BIT);\n+  set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);\n+  set_gdbarch_ptr_bit (gdbarch, tdep->addr_length * TARGET_CHAR_BIT);\n+  set_gdbarch_addr_bit (gdbarch, tdep->addr_length * TARGET_CHAR_BIT);\n+\n+  set_gdbarch_num_regs (gdbarch, (mach == bfd_mach_ez80_adl) ? EZ80_NUM_REGS\n+\t\t\t\t\t\t\t     : Z80_NUM_REGS);\n+  set_gdbarch_sp_regnum (gdbarch, Z80_SP_REGNUM);\n+  set_gdbarch_pc_regnum (gdbarch, Z80_PC_REGNUM);\n+\n+  set_gdbarch_register_name (gdbarch, z80_register_name);\n+  set_gdbarch_register_type (gdbarch, z80_register_type);\n+\n+  /* TODO: get FP type from binary (extra flags required) */\n+  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);\n+  set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);\n+  set_gdbarch_long_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);\n+  set_gdbarch_float_format (gdbarch, floatformats_ieee_single);\n+  set_gdbarch_double_format (gdbarch, floatformats_ieee_single);\n+  set_gdbarch_long_double_format (gdbarch, floatformats_ieee_single);\n+\n+  set_gdbarch_return_value (gdbarch, z80_return_value);\n+\n+  set_gdbarch_skip_prologue (gdbarch, z80_skip_prologue);\n+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan); // falling stack\n+\n+  set_gdbarch_software_single_step (gdbarch, z80_software_single_step);\n+  set_gdbarch_breakpoint_kind_from_pc (gdbarch, z80_breakpoint_kind_from_pc);\n+  set_gdbarch_sw_breakpoint_from_kind (gdbarch, z80_sw_breakpoint_from_kind);\n+  set_gdbarch_insn_is_call (gdbarch, z80_insn_is_call);\n+  set_gdbarch_insn_is_jump (gdbarch, z80_insn_is_jump);\n+  set_gdbarch_insn_is_ret (gdbarch, z80_insn_is_ret);\n+\n+  set_gdbarch_overlay_update (gdbarch, z80_overlay_update);\n+\n+  frame_unwind_append_unwinder (gdbarch, &z80_frame_unwind);\n+  if (tdesc_data)\n+    tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n+\n+  return gdbarch;\n+}\n+\n+/* Table to disassemble machine codes without prefix.  */\n+static const struct insn_info\n+ez80_main_insn_table[] =\n+{ /* table with double prefix check */\n+  { 0100, 0377, 0, insn_force_nop}, //double prefix\n+  { 0111, 0377, 0, insn_force_nop}, //double prefix\n+  { 0122, 0377, 0, insn_force_nop}, //double prefix\n+  { 0133, 0377, 0, insn_force_nop}, //double prefix\n+  /* initial table for eZ80_z80 */\n+  { 0100, 0377, 1, insn_z80      }, //eZ80 mode prefix\n+  { 0111, 0377, 1, insn_z80      }, //eZ80 mode prefix\n+  { 0122, 0377, 1, insn_adl      }, //eZ80 mode prefix\n+  { 0133, 0377, 1, insn_adl      }, //eZ80 mode prefix\n+  /* here common Z80/Z180/eZ80 opcodes */\n+  { 0000, 0367, 1, insn_default  }, //\"nop\", \"ex af,af'\"\n+  { 0061, 0377, 3, insn_ld_sp_nn }, //\"ld sp,nn\"\n+  { 0001, 0317, 3, insn_default  }, //\"ld rr,nn\"\n+  { 0002, 0347, 1, insn_default  }, //\"ld (rr),a\", \"ld a,(rr)\"\n+  { 0042, 0347, 3, insn_default  }, //\"ld (nn),hl/a\", \"ld hl/a,(nn)\"\n+  { 0063, 0377, 1, insn_inc_sp   }, //\"inc sp\"\n+  { 0073, 0377, 1, insn_dec_sp   }, //\"dec sp\"\n+  { 0003, 0303, 1, insn_default  }, //\"inc rr\", \"dec rr\", ...\n+  { 0004, 0307, 1, insn_default  }, //\"inc/dec r/(hl)\"\n+  { 0006, 0307, 2, insn_default  }, //\"ld r,n\", \"ld (hl),n\"\n+  { 0020, 0377, 2, insn_djnz_d   }, //\"djnz dis\"\n+  { 0030, 0377, 2, insn_jr_d     }, //\"jr dis\"\n+  { 0040, 0347, 2, insn_jr_cc_d  }, //\"jr cc,dis\"\n+  { 0100, 0300, 1, insn_default  }, //\"ld r,r\", \"halt\"\n+  { 0200, 0300, 1, insn_default  }, //\"alu_op a,r\"\n+  { 0300, 0307, 1, insn_ret_cc   }, //\"ret cc\"\n+  { 0301, 0317, 1, insn_pop_rr   }, //\"pop rr\"\n+  { 0302, 0307, 3, insn_jp_cc_nn }, //\"jp cc,nn\"\n+  { 0303, 0377, 3, insn_jp_nn    }, //\"jp nn\"\n+  { 0304, 0307, 3, insn_call_cc_nn}, //\"call cc,nn\"\n+  { 0305, 0317, 1, insn_push_rr  }, //\"push rr\"\n+  { 0306, 0307, 2, insn_default  }, //\"alu_op a,n\"\n+  { 0307, 0307, 1, insn_rst_n    }, //\"rst n\"\n+  { 0311, 0377, 1, insn_ret      }, //\"ret\"\n+  { 0313, 0377, 2, insn_default  }, //CB prefix\n+  { 0315, 0377, 3, insn_call_nn  }, //\"call nn\"\n+  { 0323, 0367, 2, insn_default  }, //\"out (n),a\", \"in a,(n)\"\n+  { 0335, 0337, 1, insn_z80_ddfd }, //DD/FD prefix\n+  { 0351, 0377, 1, insn_jp_rr    }, //\"jp (hl)\"\n+  { 0355, 0377, 1, insn_z80_ed   }, //ED prefix\n+  { 0371, 0377, 1, insn_ld_sp_rr }, //\"ld sp,hl\"\n+  { 0000, 0000, 1, insn_default  }  //others\n+} ;\n+\n+static const struct insn_info\n+ez80_adl_main_insn_table[] =\n+{ /* table with double prefix check */\n+  { 0100, 0377, 0, insn_force_nop}, //double prefix\n+  { 0111, 0377, 0, insn_force_nop}, //double prefix\n+  { 0122, 0377, 0, insn_force_nop}, //double prefix\n+  { 0133, 0377, 0, insn_force_nop}, //double prefix\n+  /* initial table for eZ80_adl */\n+  { 0000, 0367, 1, insn_default  }, //\"nop\", \"ex af,af'\"\n+  { 0061, 0377, 4, insn_ld_sp_nn }, //\"ld sp,Mmn\"\n+  { 0001, 0317, 4, insn_default  }, //\"ld rr,Mmn\"\n+  { 0002, 0347, 1, insn_default  }, //\"ld (rr),a\", \"ld a,(rr)\"\n+  { 0042, 0347, 4, insn_default  }, //\"ld (Mmn),hl/a\", \"ld hl/a,(Mmn)\"\n+  { 0063, 0377, 1, insn_inc_sp   }, //\"inc sp\"\n+  { 0073, 0377, 1, insn_dec_sp   }, //\"dec sp\"\n+  { 0003, 0303, 1, insn_default  }, //\"inc rr\", \"dec rr\", ...\n+  { 0004, 0307, 1, insn_default  }, //\"inc/dec r/(hl)\"\n+  { 0006, 0307, 2, insn_default  }, //\"ld r,n\", \"ld (hl),n\"\n+  { 0020, 0377, 2, insn_djnz_d   }, //\"djnz dis\"\n+  { 0030, 0377, 2, insn_jr_d     }, //\"jr dis\"\n+  { 0040, 0347, 2, insn_jr_cc_d  }, //\"jr cc,dis\"\n+  { 0100, 0377, 1, insn_z80      }, //eZ80 mode prefix (short instruction)\n+  { 0111, 0377, 1, insn_z80      }, //eZ80 mode prefix (short instruction)\n+  { 0122, 0377, 1, insn_adl      }, //eZ80 mode prefix (long instruction)\n+  { 0133, 0377, 1, insn_adl      }, //eZ80 mode prefix (long instruction)\n+  { 0100, 0300, 1, insn_default  }, //\"ld r,r\", \"halt\"\n+  { 0200, 0300, 1, insn_default  }, //\"alu_op a,r\"\n+  { 0300, 0307, 1, insn_ret_cc   }, //\"ret cc\"\n+  { 0301, 0317, 1, insn_pop_rr   }, //\"pop rr\"\n+  { 0302, 0307, 4, insn_jp_cc_nn }, //\"jp cc,nn\"\n+  { 0303, 0377, 4, insn_jp_nn    }, //\"jp nn\"\n+  { 0304, 0307, 4, insn_call_cc_nn}, //\"call cc,Mmn\"\n+  { 0305, 0317, 1, insn_push_rr  }, //\"push rr\"\n+  { 0306, 0307, 2, insn_default  }, //\"alu_op a,n\"\n+  { 0307, 0307, 1, insn_rst_n    }, //\"rst n\"\n+  { 0311, 0377, 1, insn_ret      }, //\"ret\"\n+  { 0313, 0377, 2, insn_default  }, //CB prefix\n+  { 0315, 0377, 4, insn_call_nn  }, //\"call Mmn\"\n+  { 0323, 0367, 2, insn_default  }, //\"out (n),a\", \"in a,(n)\"\n+  { 0335, 0337, 1, insn_adl_ddfd }, //DD/FD prefix\n+  { 0351, 0377, 1, insn_jp_rr    }, //\"jp (hl)\"\n+  { 0355, 0377, 1, insn_adl_ed   }, //ED prefix\n+  { 0371, 0377, 1, insn_ld_sp_rr }, //\"ld sp,hl\"\n+  { 0000, 0000, 1, insn_default  }  //others\n+};\n+\n+/* ED prefix opcodes table.\n+   Note the instruction length does include the ED prefix (+ 1 byte)\n+*/\n+static const struct insn_info\n+ez80_ed_insn_table[] =\n+{\n+  /* eZ80 only instructions */\n+  { 0002, 0366, 2, insn_default    }, //\"lea rr,ii+d\"\n+  { 0124, 0376, 2, insn_default    }, //\"lea ix,iy+d\", \"lea iy,ix+d\"\n+  { 0145, 0377, 2, insn_default    }, //\"pea ix+d\"\n+  { 0146, 0377, 2, insn_default    }, //\"pea iy+d\"\n+  { 0164, 0377, 2, insn_default    }, //\"tstio n\"\n+  /* Z180/eZ80 only instructions */\n+  { 0060, 0376, 1, insn_default    }, //not an instruction\n+  { 0000, 0306, 2, insn_default    }, //\"in0 r,(n)\", \"out0 (n),r\"\n+  { 0144, 0377, 2, insn_default    }, //\"tst a, n\"\n+  /* common instructions */\n+  { 0173, 0377, 3, insn_ld_sp_6nn9 }, //\"ld sp,(nn)\"\n+  { 0103, 0307, 3, insn_default    }, //\"ld (nn),rr\", \"ld rr,(nn)\"\n+  { 0105, 0317, 1, insn_ret        }, //\"retn\", \"reti\"\n+  { 0000, 0000, 1, insn_default    }\n+};\n+\n+static const struct insn_info\n+ez80_adl_ed_insn_table[] =\n+{\n+  { 0002, 0366, 2, insn_default }, //\"lea rr,ii+d\"\n+  { 0124, 0376, 2, insn_default }, //\"lea ix,iy+d\", \"lea iy,ix+d\"\n+  { 0145, 0377, 2, insn_default }, //\"pea ix+d\"\n+  { 0146, 0377, 2, insn_default }, //\"pea iy+d\"\n+  { 0164, 0377, 2, insn_default }, //\"tstio n\"\n+  { 0060, 0376, 1, insn_default }, //not an instruction\n+  { 0000, 0306, 2, insn_default }, //\"in0 r,(n)\", \"out0 (n),r\"\n+  { 0144, 0377, 2, insn_default }, //\"tst a, n\"\n+  { 0173, 0377, 4, insn_ld_sp_6nn9 }, //\"ld sp,(nn)\"\n+  { 0103, 0307, 4, insn_default }, //\"ld (nn),rr\", \"ld rr,(nn)\"\n+  { 0105, 0317, 1, insn_ret     }, //\"retn\", \"reti\"\n+  { 0000, 0000, 1, insn_default }\n+};\n+\n+/* table for FD and DD prefixed instructions */\n+static const struct insn_info\n+ez80_ddfd_insn_table[] =\n+{\n+  /* ez80 only instructions */\n+  { 0007, 0307, 2, insn_default }, //\"ld rr,(ii+d)\"\n+  { 0061, 0377, 2, insn_default }, //\"ld ii,(ii+d)\"\n+  /* common instructions */\n+  { 0011, 0367, 2, insn_default }, //\"add ii,rr\"\n+  { 0041, 0377, 3, insn_default }, //\"ld ii,nn\"\n+  { 0042, 0367, 3, insn_default }, //\"ld (nn),ii\", \"ld ii,(nn)\"\n+  { 0043, 0367, 1, insn_default }, //\"inc ii\", \"dec ii\"\n+  { 0044, 0366, 1, insn_default }, //\"inc/dec iih/iil\"\n+  { 0046, 0367, 2, insn_default }, //\"ld iih,n\", \"ld iil,n\"\n+  { 0064, 0376, 2, insn_default }, //\"inc (ii+d)\", \"dec (ii+d)\"\n+  { 0066, 0377, 2, insn_default }, //\"ld (ii+d),n\"\n+  { 0166, 0377, 0, insn_default }, //not an instruction\n+  { 0160, 0370, 2, insn_default }, //\"ld (ii+d),r\"\n+  { 0104, 0306, 1, insn_default }, //\"ld r,iih\", \"ld r,iil\"\n+  { 0106, 0307, 2, insn_default }, //\"ld r,(ii+d)\"\n+  { 0140, 0360, 1, insn_default }, //\"ld iih,r\", \"ld iil,r\"\n+  { 0204, 0306, 1, insn_default }, //\"alu_op a,iih\", \"alu_op a,iil\"\n+  { 0206, 0307, 2, insn_default }, //\"alu_op a,(ii+d)\"\n+  { 0313, 0377, 3, insn_default }, //DD/FD CB dd oo instructions\n+  { 0335, 0337, 0, insn_force_nop}, //double DD/FD prefix, exec DD/FD as NOP\n+  { 0341, 0373, 1, insn_default }, //\"pop ii\", \"push ii\"\n+  { 0343, 0377, 1, insn_default }, //\"ex (sp),ii\"\n+  { 0351, 0377, 1, insn_jp_rr   }, //\"jp (ii)\"\n+  { 0371, 0377, 1, insn_ld_sp_rr}, //\"ld sp,ii\"\n+  { 0000, 0000, 0, insn_default }  //not an instruction, exec DD/FD as NOP\n+};\n+\n+static const struct insn_info\n+ez80_adl_ddfd_insn_table[] =\n+{\n+  { 0007, 0307, 2, insn_default }, //\"ld rr,(ii+d)\"\n+  { 0061, 0377, 2, insn_default }, //\"ld ii,(ii+d)\"\n+  { 0011, 0367, 1, insn_default }, //\"add ii,rr\"\n+  { 0041, 0377, 4, insn_default }, //\"ld ii,nn\"\n+  { 0042, 0367, 4, insn_default }, //\"ld (nn),ii\", \"ld ii,(nn)\"\n+  { 0043, 0367, 1, insn_default }, //\"inc ii\", \"dec ii\"\n+  { 0044, 0366, 1, insn_default }, //\"inc/dec iih/iil\"\n+  { 0046, 0367, 2, insn_default }, //\"ld iih,n\", \"ld iil,n\"\n+  { 0064, 0376, 2, insn_default }, //\"inc (ii+d)\", \"dec (ii+d)\"\n+  { 0066, 0377, 3, insn_default }, //\"ld (ii+d),n\"\n+  { 0166, 0377, 0, insn_default }, //not an instruction\n+  { 0160, 0370, 2, insn_default }, //\"ld (ii+d),r\"\n+  { 0104, 0306, 1, insn_default }, //\"ld r,iih\", \"ld r,iil\"\n+  { 0106, 0307, 2, insn_default }, //\"ld r,(ii+d)\"\n+  { 0140, 0360, 1, insn_default }, //\"ld iih,r\", \"ld iil,r\"\n+  { 0204, 0306, 1, insn_default }, //\"alu_op a,iih\", \"alu_op a,iil\"\n+  { 0206, 0307, 2, insn_default }, //\"alu_op a,(ii+d)\"\n+  { 0313, 0377, 3, insn_default }, //DD/FD CB dd oo instructions\n+  { 0335, 0337, 0, insn_force_nop}, //double DD/FD prefix, exec DD/FD as NOP\n+  { 0341, 0373, 1, insn_default }, //\"pop ii\", \"push ii\"\n+  { 0343, 0377, 1, insn_default }, //\"ex (sp),ii\"\n+  { 0351, 0377, 1, insn_jp_rr   }, //\"jp (ii)\"\n+  { 0371, 0377, 1, insn_ld_sp_rr}, //\"ld sp,ii\"\n+  { 0000, 0000, 0, insn_default }  //not an instruction, exec DD/FD as NOP\n+};\n+\n+/* Return pointer to instruction information structure corresponded to opcode\n+   in buf.  */\n+static const struct insn_info *\n+z80_get_insn_info (struct gdbarch *gdbarch, const gdb_byte *buf, int *size)\n+{\n+  int code;\n+  const struct insn_info *info;\n+  unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;\n+  *size = 0;\n+  switch (mach)\n+    {\n+    case bfd_mach_ez80_z80:\n+      info = &ez80_main_insn_table[4]; /* skip force_nops */\n+      break;\n+    case bfd_mach_ez80_adl:\n+      info = &ez80_adl_main_insn_table[4]; /* skip force_nops */\n+      break;\n+    default:\n+      info = &ez80_main_insn_table[8]; /* skip eZ80 prefices and force_nops */\n+      break;\n+    }\n+  do\n+    {\n+      for (; ((code = buf[*size]) & info->mask) != info->code; ++info)\n+\t;\n+      *size += info->size;\n+      /* process instruction type */\n+      switch (info->type)\n+\t{\n+\tcase insn_z80:\n+\t  if (mach == bfd_mach_ez80_z80 || mach == bfd_mach_ez80_adl)\n+\t    info = &ez80_main_insn_table[0];\n+\t  else\n+\t    info = &ez80_main_insn_table[8];\n+\t  break;\n+\tcase insn_adl:\n+\t  info = &ez80_adl_main_insn_table[0];\n+\t  break;\n+\t/*  These two (for GameBoy Z80 & Z80 Next CPUs) haven't been tested.\n+\n+\tcase bfd_mach_gbz80:\n+\t  info = &gbz80_main_insn_table[0];\n+\t  break;\n+\tcase bfd_mach_z80n:\n+\t  info = &z80n_main_insn_table[0];\n+\t  break;\n+\t*/\n+\tcase insn_z80_ddfd:\n+\t  if (mach == bfd_mach_ez80_z80 || mach == bfd_mach_ez80_adl)\n+\t    info = &ez80_ddfd_insn_table[0];\n+\t  else\n+\t    info = &ez80_ddfd_insn_table[2];\n+\t  break;\n+\tcase insn_adl_ddfd:\n+\t  info = &ez80_adl_ddfd_insn_table[0];\n+\t  break;\n+\tcase insn_z80_ed:\n+\t  info = &ez80_ed_insn_table[0];\n+\t  break;\n+\tcase insn_adl_ed:\n+\t  info = &ez80_adl_ed_insn_table[0];\n+\t  break;\n+\tcase insn_force_nop:\n+\t  return NULL;\n+\tdefault:\n+\t  return info;\n+\t}\n+    }\n+  while (1);\n+}\n+\n+extern initialize_file_ftype _initialize_z80_tdep;\n+\n+void\n+_initialize_z80_tdep ()\n+{\n+  register_gdbarch_init (bfd_arch_z80, z80_gdbarch_init);\n+  initialize_tdesc_z80 ();\n+}"
    },
    {
      "sha": "4d73aeb17fadbc6691446b7d45fea09f6dcc3df4",
      "filename": "gdb/z80-tdep.h",
      "status": "added",
      "additions": 52,
      "deletions": 0,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/z80-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3/gdb/z80-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/z80-tdep.h?ref=3dab9e15d3ab1cde555dfbf4a958eb17eec2ecb3",
      "patch": "@@ -0,0 +1,52 @@\n+/* Target-dependent code for the Z80.\n+\n+   Copyright (C) 2002-2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef Z80_TDEP_H\n+#define Z80_TDEP_H\n+\n+/* Register pair constants\n+   Order optimized for gdb-stub implementation\n+   Most of register pairs are 16 bit length on Z80 and\n+   24 bit on eZ80 in ADL or MADL modes */\n+enum z80_regnum\n+{\n+  Z80_AF_REGNUM,\n+  Z80_BC_REGNUM,\n+  Z80_DE_REGNUM,\n+  Z80_HL_REGNUM,\n+  Z80_SP_REGNUM,\t/* SPL on eZ80 CPU */\n+  Z80_PC_REGNUM,\n+  Z80_IX_REGNUM,\n+  Z80_IY_REGNUM,\n+  Z80_AFA_REGNUM,\n+  Z80_BCA_REGNUM,\n+  Z80_DEA_REGNUM,\n+  Z80_HLA_REGNUM,\n+  Z80_IR_REGNUM,\n+/* eZ80 only registers */\n+  Z80_SPS_REGNUM\t/* SPS register of eZ80 CPU */\n+};\n+\n+#define Z80_NUM_REGS\t13\n+#define Z80_REG_BYTES\t(Z80_NUM_REGS*2)\n+\n+#define EZ80_NUM_REGS\t(Z80_NUM_REGS + 1)\n+#define EZ80_REG_BYTES\t(EZ80_NUM_REGS*3)\n+\n+#endif /* z80-tdep.h */"
    }
  ]
}