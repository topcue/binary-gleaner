{
  "sha": "344e9841d989cb96316d8d487e004212d4d3090a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzQ0ZTk4NDFkOTg5Y2I5NjMxNmQ4ZDQ4N2UwMDQyMTJkNGQzMDkwYQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-22T17:23:53Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-22T17:23:53Z"
    },
    "message": "gdb: remove TYPE_OBJFILE macro\n\nChange all users to use the type::objfile method instead.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (TYPE_OBJFILE): Remove, change all users to use the\n\ttype::objfile method instead.\n\nChange-Id: I6b3f580913fb1fb0cf986b176dba8db68e1fabf9",
    "tree": {
      "sha": "d8a7b89648a9463e2acbb0037740bf55149bc5a2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d8a7b89648a9463e2acbb0037740bf55149bc5a2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/344e9841d989cb96316d8d487e004212d4d3090a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/344e9841d989cb96316d8d487e004212d4d3090a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/344e9841d989cb96316d8d487e004212d4d3090a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/344e9841d989cb96316d8d487e004212d4d3090a/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "30625020198359db7462a197380c242d91c07f14",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30625020198359db7462a197380c242d91c07f14",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/30625020198359db7462a197380c242d91c07f14"
    }
  ],
  "stats": {
    "total": 70,
    "additions": 35,
    "deletions": 35
  },
  "files": [
    {
      "sha": "df54d9af985edbde766e99f62f96f26bc5c0272d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -1,3 +1,8 @@\n+2021-01-22  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* gdbtypes.h (TYPE_OBJFILE): Remove, change all users to use the\n+\ttype::objfile method instead.\n+\n 2021-01-22  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* gdbtypes.h (TYPE_OBJFILE_OWNED): Remove, update all users to"
    },
    {
      "sha": "e2befe1d82e7e9ff25001d254700df58707c06ae",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -13253,8 +13253,8 @@ ada_operator_check (struct expression *exp, int pos,\n \n   /* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */\n \n-  if (type && TYPE_OBJFILE (type)\n-      && (*objfile_func) (TYPE_OBJFILE (type), data))\n+  if (type != nullptr && type->objfile () != nullptr\n+      && objfile_func (type->objfile (), data))\n     return 1;\n \n   return 0;"
    },
    {
      "sha": "115f078787bc811c5bfcda29dd08b31f0c8171ec",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -293,7 +293,7 @@ alloc_type_instance (struct type *oldtype)\n   if (!oldtype->is_objfile_owned ())\n     type = GDBARCH_OBSTACK_ZALLOC (get_type_arch (oldtype), struct type);\n   else\n-    type = OBSTACK_ZALLOC (&TYPE_OBJFILE (oldtype)->objfile_obstack,\n+    type = OBSTACK_ZALLOC (&oldtype->objfile ()->objfile_obstack,\n \t\t\t   struct type);\n \n   TYPE_MAIN_TYPE (type) = TYPE_MAIN_TYPE (oldtype);\n@@ -648,7 +648,7 @@ make_qualified_type (struct type *type, type_instance_flags new_flags,\n \t as TYPE.  Otherwise, we can't link it into TYPE's cv chain:\n \t if one objfile is freed and the other kept, we'd have\n \t dangling pointers.  */\n-      gdb_assert (TYPE_OBJFILE (type) == TYPE_OBJFILE (storage));\n+      gdb_assert (type->objfile () == storage->objfile ());\n \n       ntype = storage;\n       TYPE_MAIN_TYPE (ntype) = TYPE_MAIN_TYPE (type);\n@@ -738,7 +738,7 @@ make_cv_type (int cnst, int voltl,\n \t can't have inter-objfile pointers.  The only thing to do is\n \t to leave stub types as stub types, and look them up afresh by\n \t name each time you encounter them.  */\n-      gdb_assert (TYPE_OBJFILE (*typeptr) == TYPE_OBJFILE (type));\n+      gdb_assert ((*typeptr)->objfile () == type->objfile ());\n     }\n   \n   ntype = make_qualified_type (type, new_flags, \n@@ -804,7 +804,7 @@ replace_type (struct type *ntype, struct type *type)\n      the assignment of one type's main type structure to the other\n      will produce a type with references to objects (names; field\n      lists; etc.) allocated on an objfile other than its own.  */\n-  gdb_assert (TYPE_OBJFILE (ntype) == TYPE_OBJFILE (type));\n+  gdb_assert (ntype->objfile () == type->objfile ());\n \n   *TYPE_MAIN_TYPE (ntype) = *TYPE_MAIN_TYPE (type);\n \n@@ -1681,7 +1681,7 @@ type_name_or_error (struct type *type)\n     return name;\n \n   name = saved_type->name ();\n-  objfile = TYPE_OBJFILE (saved_type);\n+  objfile = saved_type->objfile ();\n   error (_(\"Invalid anonymous type %s [in module %s], GCC PR debug/47510 bug?\"),\n \t name ? name : \"<anonymous>\",\n \t objfile ? objfile_name (objfile) : \"<arch>\");\n@@ -2027,7 +2027,7 @@ get_vptr_fieldno (struct type *type, struct type **basetypep)\n \t    {\n \t      /* If the type comes from a different objfile we can't cache\n \t\t it, it may have a different lifetime.  PR 2384 */\n-\t      if (TYPE_OBJFILE (type) == TYPE_OBJFILE (basetype))\n+\t      if (type->objfile () == basetype->objfile ())\n \t\t{\n \t\t  set_type_vptr_fieldno (type, fieldno);\n \t\t  set_type_vptr_basetype (type, basetype);\n@@ -2800,7 +2800,7 @@ type::add_dyn_prop (dynamic_prop_node_kind prop_kind, dynamic_prop prop)\n \n   gdb_assert (this->is_objfile_owned ());\n \n-  temp = XOBNEW (&TYPE_OBJFILE (this)->objfile_obstack,\n+  temp = XOBNEW (&this->objfile ()->objfile_obstack,\n \t\t struct dynamic_prop_list);\n   temp->prop_kind = prop_kind;\n   temp->prop = prop;\n@@ -2969,7 +2969,7 @@ check_typedef (struct type *type)\n \t     TYPE's objfile is pointless, too, since you'll have to\n \t     move over any other types NEWTYPE refers to, which could\n \t     be an unbounded amount of stuff.  */\n-\t  if (TYPE_OBJFILE (newtype) == TYPE_OBJFILE (type))\n+\t  if (newtype->objfile () == type->objfile ())\n \t    type = make_qualified_type (newtype, type->instance_flags (), type);\n \t  else\n \t    type = newtype;\n@@ -2995,7 +2995,7 @@ check_typedef (struct type *type)\n \t  /* Same as above for opaque types, we can replace the stub\n \t     with the complete type only if they are in the same\n \t     objfile.  */\n-\t  if (TYPE_OBJFILE (SYMBOL_TYPE (sym)) == TYPE_OBJFILE (type))\n+\t  if (SYMBOL_TYPE (sym)->objfile () == type->objfile ())\n \t    type = make_qualified_type (SYMBOL_TYPE (sym),\n \t\t\t\t\ttype->instance_flags (), type);\n \t  else\n@@ -5497,7 +5497,7 @@ copy_type_recursive (struct objfile *objfile,\n \n   /* This type shouldn't be pointing to any types in other objfiles;\n      if it did, the type might disappear unexpectedly.  */\n-  gdb_assert (TYPE_OBJFILE (type) == objfile);\n+  gdb_assert (type->objfile () == objfile);\n \n   struct type_pair pair (type, nullptr);\n \n@@ -5667,7 +5667,7 @@ copy_type (const struct type *type)\n \t  sizeof (struct main_type));\n   if (type->main_type->dyn_prop_list != NULL)\n     new_type->main_type->dyn_prop_list\n-      = copy_dynamic_prop_list (&TYPE_OBJFILE (type) -> objfile_obstack,\n+      = copy_dynamic_prop_list (&type->objfile ()->objfile_obstack,\n \t\t\t\ttype->main_type->dyn_prop_list);\n \n   return new_type;\n@@ -5963,9 +5963,9 @@ allocate_fixed_point_type_info (struct type *type)\n   if (type->is_objfile_owned ())\n     {\n       fixed_point_type_storage *storage\n-\t= fixed_point_objfile_key.get (TYPE_OBJFILE (type));\n+\t= fixed_point_objfile_key.get (type->objfile ());\n       if (storage == nullptr)\n-\tstorage = fixed_point_objfile_key.emplace (TYPE_OBJFILE (type));\n+\tstorage = fixed_point_objfile_key.emplace (type->objfile ());\n       info = up.get ();\n       storage->push_back (std::move (up));\n     }"
    },
    {
      "sha": "30e8ac54260430daccb9f41af75f493a45e8be53",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -220,12 +220,6 @@ DEF_ENUM_FLAGS_TYPE (enum type_instance_flag_value, type_instance_flags);\n \n #define TYPE_NOTTEXT(t)\t(((t)->instance_flags ()) & TYPE_INSTANCE_FLAG_NOTTEXT)\n \n-/* * Type owner.  If TYPE_OBJFILE_OWNED is true, the type is owned by\n-   the objfile retrieved as TYPE_OBJFILE.  Otherwise, the type is\n-   owned by an architecture; TYPE_OBJFILE is NULL in this case.  */\n-\n-#define TYPE_OBJFILE(t) ((t)->objfile ())\n-\n /* * True if this type was declared using the \"class\" keyword.  This is\n    only valid for C++ structure and enum types.  If false, a structure\n    was declared as a \"struct\"; if true it was declared \"class\".  For"
    },
    {
      "sha": "936639c8a473e3066876bdf7b01783ce03761e3d",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -151,7 +151,7 @@ tyscm_eq_type_smob (const void *ap, const void *bp)\n static htab_t\n tyscm_type_map (struct type *type)\n {\n-  struct objfile *objfile = TYPE_OBJFILE (type);\n+  struct objfile *objfile = type->objfile ();\n   htab_t htab;\n \n   if (objfile == NULL)\n@@ -351,7 +351,7 @@ tyscm_copy_type_recursive (void **slot, void *info)\n {\n   type_smob *t_smob = (type_smob *) *slot;\n   htab_t copied_types = (htab_t) info;\n-  struct objfile *objfile = TYPE_OBJFILE (t_smob->type);\n+  struct objfile *objfile = t_smob->type->objfile ();\n   htab_t htab;\n   eqable_gdb_smob **new_slot;\n   type_smob t_smob_for_lookup;"
    },
    {
      "sha": "7fd520493ac491e98e6af762cc3e6c8bdea17ba7",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -1320,7 +1320,7 @@ operator_check_standard (struct expression *exp, int pos,\n \tfor (arg = 0; arg < nargs; arg++)\n \t  {\n \t    struct type *inst_type = elts[pos + 3 + arg].type;\n-\t    struct objfile *inst_objfile = TYPE_OBJFILE (inst_type);\n+\t    struct objfile *inst_objfile = inst_type->objfile ();\n \n \t    if (inst_objfile && (*objfile_func) (inst_objfile, data))\n \t      return 1;\n@@ -1351,9 +1351,10 @@ operator_check_standard (struct expression *exp, int pos,\n \n   /* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */\n \n-  if (type && TYPE_OBJFILE (type)\n-      && (*objfile_func) (TYPE_OBJFILE (type), data))\n+  if (type != nullptr && type->objfile () != nullptr\n+      && objfile_func (type->objfile (), data))\n     return 1;\n+\n   if (objfile && (*objfile_func) (objfile, data))\n     return 1;\n "
    },
    {
      "sha": "878304f716ca821abab5f45619d166ec55e646a1",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -418,7 +418,7 @@ static PyObject *\n typy_get_objfile (PyObject *self, void *closure)\n {\n   struct type *type = ((type_object *) self)->type;\n-  struct objfile *objfile = TYPE_OBJFILE (type);\n+  struct objfile *objfile = type->objfile ();\n \n   if (objfile == nullptr)\n     Py_RETURN_NONE;\n@@ -1098,9 +1098,9 @@ set_type (type_object *obj, struct type *type)\n {\n   obj->type = type;\n   obj->prev = NULL;\n-  if (type && TYPE_OBJFILE (type))\n+  if (type != nullptr && type->objfile () != nullptr)\n     {\n-      struct objfile *objfile = TYPE_OBJFILE (type);\n+      struct objfile *objfile = type->objfile ();\n \n       obj->next = ((type_object *)\n \t\t   objfile_data (objfile, typy_objfile_data_key));\n@@ -1119,10 +1119,10 @@ typy_dealloc (PyObject *obj)\n \n   if (type->prev)\n     type->prev->next = type->next;\n-  else if (type->type && TYPE_OBJFILE (type->type))\n+  else if (type->type != nullptr && type->type->objfile () != nullptr)\n     {\n       /* Must reset head of list.  */\n-      struct objfile *objfile = TYPE_OBJFILE (type->type);\n+      struct objfile *objfile = type->type->objfile ();\n \n       if (objfile)\n \tset_objfile_data (objfile, typy_objfile_data_key, type->next);"
    },
    {
      "sha": "fc572ce96efb219f765c09a0f598c92616dc638e",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -1825,7 +1825,7 @@ rust_operator_check (struct expression *exp, int pos,\n     case OP_AGGREGATE:\n       {\n \tstruct type *type = exp->elts[pos + 1].type;\n-\tstruct objfile *objfile = TYPE_OBJFILE (type);\n+\tstruct objfile *objfile = type->objfile ();\n \n \tif (objfile != NULL && (*objfile_func) (objfile, data))\n \t  return 1;"
    },
    {
      "sha": "6f4ee5453117912dbbef190e326e3cdc2b7b191e",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/344e9841d989cb96316d8d487e004212d4d3090a/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/344e9841d989cb96316d8d487e004212d4d3090a/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=344e9841d989cb96316d8d487e004212d4d3090a",
      "patch": "@@ -2514,10 +2514,10 @@ void\n preserve_one_value (struct value *value, struct objfile *objfile,\n \t\t    htab_t copied_types)\n {\n-  if (TYPE_OBJFILE (value->type) == objfile)\n+  if (value->type->objfile () == objfile)\n     value->type = copy_type_recursive (objfile, value->type, copied_types);\n \n-  if (TYPE_OBJFILE (value->enclosing_type) == objfile)\n+  if (value->enclosing_type->objfile () == objfile)\n     value->enclosing_type = copy_type_recursive (objfile,\n \t\t\t\t\t\t value->enclosing_type,\n \t\t\t\t\t\t copied_types);\n@@ -2532,7 +2532,7 @@ preserve_one_internalvar (struct internalvar *var, struct objfile *objfile,\n   switch (var->kind)\n     {\n     case INTERNALVAR_INTEGER:\n-      if (var->u.integer.type && TYPE_OBJFILE (var->u.integer.type) == objfile)\n+      if (var->u.integer.type && var->u.integer.type->objfile () == objfile)\n \tvar->u.integer.type\n \t  = copy_type_recursive (objfile, var->u.integer.type, copied_types);\n       break;"
    }
  ]
}