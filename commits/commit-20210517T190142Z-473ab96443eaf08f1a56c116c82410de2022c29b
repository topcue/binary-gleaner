{
  "sha": "473ab96443eaf08f1a56c116c82410de2022c29b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDczYWI5NjQ0M2VhZjA4ZjFhNTZjMTE2YzgyNDEwZGUyMDIyYzI5Yg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-05-17T18:55:18Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-05-17T19:01:42Z"
    },
    "message": "Change how dwarf2_per_cu_data is deleted\n\nAddress sanitizer pointed out that the patch to use 'delete' for\ndwarf2_per_cu_data introduced a bug -- now it is possible to delete a\nsignatured_type using a pointer to its base class.\n\nThis patch fixes the problem by introducing a deleter and a unique_ptr\nspecialization.  A virtual destructor would be more ordinary here, but\nit seemed wasteful to add a vtable just for this purpose.  If virtual\nmethods are ever needed here, we can revisit this.\n\n2021-05-17  Tom Tromey  <tromey@adacore.com>\n\n\t* dwarf2/read.h (struct dwarf2_per_cu_data_deleter: New.\n\t(dwarf2_per_cu_data_up): New typedef.\n\t(struct dwarf2_per_bfd) <allocate_per_cu>: Change return type.\n\t<all_comp_units>: Use dwarf2_per_cu_data_up.\n\t* dwarf2/read.c (dwarf2_per_cu_data::operator()): New function.\n\t(dwarf2_per_bfd::allocate_per_cu): Return dwarf2_per_cu_data_up.\n\t(create_cu_from_index_list): Likewise.\n\t(create_signatured_type_table_from_index)\n\t(create_cus_from_debug_names_list, add_type_unit)\n\t(read_comp_units_from_section): Update.\n\t(dwarf2_find_containing_comp_unit): Change type of all_comp_units.\n\t(run_test): Update.",
    "tree": {
      "sha": "99609fd2b1cd5f3103f2a4303537d87aecd1cf1a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/99609fd2b1cd5f3103f2a4303537d87aecd1cf1a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/473ab96443eaf08f1a56c116c82410de2022c29b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/473ab96443eaf08f1a56c116c82410de2022c29b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/473ab96443eaf08f1a56c116c82410de2022c29b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/473ab96443eaf08f1a56c116c82410de2022c29b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "16e0020bfc845d87f2f3584414c4efa2454f8d05",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/16e0020bfc845d87f2f3584414c4efa2454f8d05",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/16e0020bfc845d87f2f3584414c4efa2454f8d05"
    }
  ],
  "stats": {
    "total": 81,
    "additions": 61,
    "deletions": 20
  },
  "files": [
    {
      "sha": "b2743646511ae88264eb674dd3ec32c007b92f81",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/473ab96443eaf08f1a56c116c82410de2022c29b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/473ab96443eaf08f1a56c116c82410de2022c29b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=473ab96443eaf08f1a56c116c82410de2022c29b",
      "patch": "@@ -1,3 +1,18 @@\n+2021-05-17  Tom Tromey  <tromey@adacore.com>\n+\n+\t* dwarf2/read.h (struct dwarf2_per_cu_data_deleter: New.\n+\t(dwarf2_per_cu_data_up): New typedef.\n+\t(struct dwarf2_per_bfd) <allocate_per_cu>: Change return type.\n+\t<all_comp_units>: Use dwarf2_per_cu_data_up.\n+\t* dwarf2/read.c (dwarf2_per_cu_data::operator()): New function.\n+\t(dwarf2_per_bfd::allocate_per_cu): Return dwarf2_per_cu_data_up.\n+\t(create_cu_from_index_list): Likewise.\n+\t(create_signatured_type_table_from_index)\n+\t(create_cus_from_debug_names_list, add_type_unit)\n+\t(read_comp_units_from_section): Update.\n+\t(dwarf2_find_containing_comp_unit): Change type of all_comp_units.\n+\t(run_test): Update.\n+\n 2021-05-17  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (tu_abbrev_offset::operator<): New method."
    },
    {
      "sha": "b3b8f1b830dbe27acb4748180e2ff72124ddec82",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 30,
      "deletions": 18,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/473ab96443eaf08f1a56c116c82410de2022c29b/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/473ab96443eaf08f1a56c116c82410de2022c29b/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=473ab96443eaf08f1a56c116c82410de2022c29b",
      "patch": "@@ -1760,6 +1760,17 @@ dwarf2_queue_item::~dwarf2_queue_item ()\n     }\n }\n \n+/* See dwarf2/read.h.  */\n+\n+void\n+dwarf2_per_cu_data_deleter::operator() (dwarf2_per_cu_data *data)\n+{\n+  if (data->is_debug_types)\n+    delete static_cast<signatured_type *> (data);\n+  else\n+    delete data;\n+}\n+\n /* The return type of find_file_and_directory.  Note, the enclosed\n    string pointers are only valid while this object is valid.  */\n \n@@ -2522,10 +2533,10 @@ dw2_instantiate_symtab (dwarf2_per_cu_data *per_cu,\n \n /* See read.h.  */\n \n-std::unique_ptr<dwarf2_per_cu_data>\n+dwarf2_per_cu_data_up\n dwarf2_per_bfd::allocate_per_cu ()\n {\n-  std::unique_ptr<dwarf2_per_cu_data> result (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data_up result (new dwarf2_per_cu_data);\n   result->per_bfd = this;\n   result->index = m_num_psymtabs++;\n   return result;\n@@ -2546,13 +2557,13 @@ dwarf2_per_bfd::allocate_signatured_type ()\n /* Return a new dwarf2_per_cu_data allocated on the per-bfd\n    obstack, and constructed with the specified field values.  */\n \n-static std::unique_ptr<dwarf2_per_cu_data>\n+static dwarf2_per_cu_data_up\n create_cu_from_index_list (dwarf2_per_bfd *per_bfd,\n \t\t\t   struct dwarf2_section_info *section,\n \t\t\t   int is_dwz,\n \t\t\t   sect_offset sect_off, ULONGEST length)\n {\n-  std::unique_ptr<dwarf2_per_cu_data> the_cu = per_bfd->allocate_per_cu ();\n+  dwarf2_per_cu_data_up the_cu = per_bfd->allocate_per_cu ();\n   the_cu->sect_off = sect_off;\n   the_cu->length = length;\n   the_cu->section = section;\n@@ -2580,7 +2591,7 @@ create_cus_from_index_list (dwarf2_per_bfd *per_bfd,\n       ULONGEST length = extract_unsigned_integer (cu_list + 8, 8, BFD_ENDIAN_LITTLE);\n       cu_list += 2 * 8;\n \n-      std::unique_ptr<dwarf2_per_cu_data> per_cu\n+      dwarf2_per_cu_data_up per_cu\n \t= create_cu_from_index_list (per_bfd, section, is_dwz, sect_off,\n \t\t\t\t     length);\n       per_bfd->all_comp_units.push_back (std::move (per_cu));\n@@ -2647,7 +2658,7 @@ create_signatured_type_table_from_index\n       slot = htab_find_slot (sig_types_hash.get (), sig_type.get (), INSERT);\n       *slot = sig_type.get ();\n \n-      per_bfd->all_comp_units.push_back (std::move (sig_type));\n+      per_bfd->all_comp_units.emplace_back (sig_type.release ());\n     }\n \n   per_bfd->signatured_types = std::move (sig_types_hash);\n@@ -2699,7 +2710,7 @@ create_signatured_type_table_from_debug_names\n       slot = htab_find_slot (sig_types_hash.get (), sig_type.get (), INSERT);\n       *slot = sig_type.get ();\n \n-      per_objfile->per_bfd->all_comp_units.push_back (std::move (sig_type));\n+      per_objfile->per_bfd->all_comp_units.emplace_back (sig_type.release ());\n     }\n \n   per_objfile->per_bfd->signatured_types = std::move (sig_types_hash);\n@@ -4930,7 +4941,7 @@ create_cus_from_debug_names_list (dwarf2_per_bfd *per_bfd,\n \t     of the next CU as end of this CU.  We create the CUs here with\n \t     length 0, and in cutu_reader::cutu_reader we'll fill in the\n \t     actual length.  */\n-\t  std::unique_ptr<dwarf2_per_cu_data> per_cu\n+\t  dwarf2_per_cu_data_up per_cu\n \t    = create_cu_from_index_list (per_bfd, &section, is_dwz,\n \t\t\t\t\t sect_off, 0);\n \t  per_bfd->all_comp_units.push_back (std::move (per_cu));\n@@ -4955,7 +4966,7 @@ create_cus_from_debug_names_list (dwarf2_per_bfd *per_bfd,\n       if (i >= 1)\n \t{\n \t  const ULONGEST length = sect_off_next - sect_off_prev;\n-\t  std::unique_ptr<dwarf2_per_cu_data> per_cu\n+\t  dwarf2_per_cu_data_up per_cu\n \t    = create_cu_from_index_list (per_bfd, &section, is_dwz,\n \t\t\t\t\t sect_off_prev, length);\n \t  per_bfd->all_comp_units.push_back (std::move (per_cu));\n@@ -6132,7 +6143,8 @@ add_type_unit (dwarf2_per_objfile *per_objfile, ULONGEST sig, void **slot)\n \n   per_objfile->resize_symtabs ();\n \n-  per_objfile->per_bfd->all_comp_units.push_back (std::move (sig_type_holder));\n+  per_objfile->per_bfd->all_comp_units.emplace_back\n+    (sig_type_holder.release ());\n   sig_type->signature = sig;\n   sig_type->is_debug_types = 1;\n   if (per_objfile->per_bfd->using_index)\n@@ -7707,7 +7719,7 @@ read_comp_units_from_section (dwarf2_per_objfile *per_objfile,\n \n   while (info_ptr < section->buffer + section->size)\n     {\n-      std::unique_ptr<dwarf2_per_cu_data> this_cu;\n+      dwarf2_per_cu_data_up this_cu;\n \n       sect_offset sect_off = (sect_offset) (info_ptr - section->buffer);\n \n@@ -7728,7 +7740,7 @@ read_comp_units_from_section (dwarf2_per_objfile *per_objfile,\n \t  signatured_type *sig_ptr = sig_type.get ();\n \t  sig_type->signature = cu_header.signature;\n \t  sig_type->type_offset_in_tu = cu_header.type_cu_offset_in_tu;\n-\t  this_cu = std::move (sig_type);\n+\t  this_cu.reset (sig_type.release ());\n \n \t  void **slot = htab_find_slot (types_htab.get (), sig_ptr, INSERT);\n \t  gdb_assert (slot != nullptr);\n@@ -24577,7 +24589,7 @@ static int\n dwarf2_find_containing_comp_unit\n   (sect_offset sect_off,\n    unsigned int offset_in_dwz,\n-   const std::vector<std::unique_ptr<dwarf2_per_cu_data>> &all_comp_units)\n+   const std::vector<dwarf2_per_cu_data_up> &all_comp_units)\n {\n   int low, high;\n \n@@ -24643,13 +24655,13 @@ namespace find_containing_comp_unit {\n static void\n run_test ()\n {\n-  std::unique_ptr<dwarf2_per_cu_data> one (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data_up one (new dwarf2_per_cu_data);\n   dwarf2_per_cu_data *one_ptr = one.get ();\n-  std::unique_ptr<dwarf2_per_cu_data> two (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data_up two (new dwarf2_per_cu_data);\n   dwarf2_per_cu_data *two_ptr = two.get ();\n-  std::unique_ptr<dwarf2_per_cu_data> three (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data_up three (new dwarf2_per_cu_data);\n   dwarf2_per_cu_data *three_ptr = three.get ();\n-  std::unique_ptr<dwarf2_per_cu_data> four (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data_up four (new dwarf2_per_cu_data);\n   dwarf2_per_cu_data *four_ptr = four.get ();\n \n   one->length = 5;\n@@ -24662,7 +24674,7 @@ run_test ()\n   four->length = 7;\n   four->is_dwz = 1;\n \n-  std::vector<std::unique_ptr<dwarf2_per_cu_data>> units;\n+  std::vector<dwarf2_per_cu_data_up> units;\n   units.push_back (std::move (one));\n   units.push_back (std::move (two));\n   units.push_back (std::move (three));"
    },
    {
      "sha": "756d1934ca0c2fced81d88b91090a7614159f90f",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 16,
      "deletions": 2,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/473ab96443eaf08f1a56c116c82410de2022c29b/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/473ab96443eaf08f1a56c116c82410de2022c29b/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=473ab96443eaf08f1a56c116c82410de2022c29b",
      "patch": "@@ -74,6 +74,20 @@ struct dwarf2_queue_item\n   enum language pretend_language;\n };\n \n+/* A deleter for dwarf2_per_cu_data that knows to downcast to\n+   signatured_type as appropriate.  This approach lets us avoid a\n+   virtual destructor, which saves a bit of space.  */\n+\n+struct dwarf2_per_cu_data_deleter\n+{\n+  void operator() (dwarf2_per_cu_data *data);\n+};\n+\n+/* A specialization of unique_ptr for dwarf2_per_cu_data and\n+   subclasses.  */\n+typedef std::unique_ptr<dwarf2_per_cu_data, dwarf2_per_cu_data_deleter>\n+    dwarf2_per_cu_data_up;\n+\n /* Some DWARF data can be shared across objfiles who share the same BFD,\n    this data is stored in this object.\n \n@@ -103,7 +117,7 @@ struct dwarf2_per_bfd\n   /* A convenience function to allocate a dwarf2_per_cu_data.  The\n      returned object has its \"index\" field set properly.  The object\n      is allocated on the dwarf2_per_bfd obstack.  */\n-  std::unique_ptr<dwarf2_per_cu_data> allocate_per_cu ();\n+  dwarf2_per_cu_data_up allocate_per_cu ();\n \n   /* A convenience function to allocate a signatured_type.  The\n      returned object has its \"index\" field set properly.  The object\n@@ -154,7 +168,7 @@ struct dwarf2_per_bfd\n \n   /* Table of all the compilation units.  This is used to locate\n      the target compilation unit of a particular reference.  */\n-  std::vector<std::unique_ptr<dwarf2_per_cu_data>> all_comp_units;\n+  std::vector<dwarf2_per_cu_data_up> all_comp_units;\n \n   /* Table of struct type_unit_group objects.\n      The hash key is the DW_AT_stmt_list value.  */"
    }
  ]
}