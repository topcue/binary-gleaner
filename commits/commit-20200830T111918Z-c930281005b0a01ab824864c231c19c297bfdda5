{
  "sha": "c930281005b0a01ab824864c231c19c297bfdda5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzkzMDI4MTAwNWIwYTAxYWI4MjQ4NjRjMjMxYzE5YzI5N2JmZGRhNQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-30T10:07:57Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-30T11:19:18Z"
    },
    "message": "PR26437, PR26438 UBSAN: tc-cr16.c left shifts and overflows\n\nAlways use unsigned constants in expressions generating masks.  The\nfollowing trys mightily to avoid UB (but hits it anyway with bits=32\nand 0x7fffffff << 1), and worse, for 32-bit int, 64-bit long, bits=32\ndoesn't generate 0xffffffff.\n    max = ((((1 << (bits - 1)) - 1) << 1) | 1);\nresults in -1, or max = 0xffffffffffffffff.\n\nThis patch fixes that problem, a possible shift exponent of -1U,\nremoves some dead code, and makes general tidies.\n\n\tPR26437\n\tPR26438\n\t* config/tc-cr16.c: Include limits.h, formatting.\n\t(CR16_PRINT): Wrap params in parentheses.  Remove parens from uses\n\tthroughout file.\n\t(getconstant): Handle zero nbits.\n\t(print_operand): Simplify handling of index regs.\n\t(check_range): Use int32_t variables.  Correct range checks.",
    "tree": {
      "sha": "100a7c5da77337a593a8dc18387219ecddf7a179",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/100a7c5da77337a593a8dc18387219ecddf7a179"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c930281005b0a01ab824864c231c19c297bfdda5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c930281005b0a01ab824864c231c19c297bfdda5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c930281005b0a01ab824864c231c19c297bfdda5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c930281005b0a01ab824864c231c19c297bfdda5/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "34d8e6d0c5f3c51d0e7858572791d8269b9d0f1c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/34d8e6d0c5f3c51d0e7858572791d8269b9d0f1c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/34d8e6d0c5f3c51d0e7858572791d8269b9d0f1c"
    }
  ],
  "stats": {
    "total": 1600,
    "additions": 799,
    "deletions": 801
  },
  "files": [
    {
      "sha": "c1504c7667917bfbc7d2bee56011d232bb019d46",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c930281005b0a01ab824864c231c19c297bfdda5/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c930281005b0a01ab824864c231c19c297bfdda5/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=c930281005b0a01ab824864c231c19c297bfdda5",
      "patch": "@@ -1,3 +1,15 @@\n+2020-08-30  Alan Modra  <amodra@gmail.com>\n+\n+\tPR26437\n+\tPR26438\n+\t* config/tc-cr16.c: Include limits.h, formatting.\n+\t(CR16_PRINT): Wrap params in parentheses.  Remove parens from uses\n+\tthroughout file.\n+\t(getconstant): Handle zero nbits.\n+\t(print_operand): Use unsigned variables.  Simplify handling of\n+\tindex regs.\n+\t(check_range): Use int32_t variables.  Correct range checks.\n+\n 2020-08-29  Alan Modra  <amodra@gmail.com>\n \n \tPR 26481"
    },
    {
      "sha": "71b23058bb7fd8701c5caa2e2c213c5193c53491",
      "filename": "gas/config/tc-cr16.c",
      "status": "modified",
      "additions": 787,
      "deletions": 801,
      "changes": 1588,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c930281005b0a01ab824864c231c19c297bfdda5/gas/config/tc-cr16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c930281005b0a01ab824864c231c19c297bfdda5/gas/config/tc-cr16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-cr16.c?ref=c930281005b0a01ab824864c231c19c297bfdda5",
      "patch": "@@ -26,6 +26,12 @@\n #include \"opcode/cr16.h\"\n #include \"elf/cr16.h\"\n \n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n+#ifndef CHAR_BIT\n+#define CHAR_BIT 8\n+#endif\n \n /* Word is considered here as a 16-bit unsigned short int.  */\n #define WORD_SHIFT  16\n@@ -41,7 +47,7 @@\n \n /* Assign a number NUM, shifted by SHIFT bytes, into a location\n    pointed by index BYTE of array 'output_opcode'.  */\n-#define CR16_PRINT(BYTE, NUM, SHIFT)   output_opcode[BYTE] |= (NUM << SHIFT)\n+#define CR16_PRINT(BYTE, NUM, SHIFT)   output_opcode[BYTE] |= (NUM) << (SHIFT)\n \n /* Operand errors.  */\n typedef enum\n@@ -119,7 +125,7 @@ l_cons (int nbytes)\n   expressionS exp;\n \n #ifdef md_flush_pending_output\n-    md_flush_pending_output ();\n+  md_flush_pending_output ();\n #endif\n \n   if (is_it_end_of_statement ())\n@@ -146,97 +152,98 @@ l_cons (int nbytes)\n       expression (&exp);\n \n       if (*input_line_pointer == ':')\n-        {\n-          /* Bitfields.  */\n-          long value = 0;\n-\n-          for (;;)\n-            {\n-              unsigned long width;\n-\n-              if (*input_line_pointer != ':')\n-                {\n-                  input_line_pointer = hold;\n-                  break;\n-                }\n-              if (exp.X_op == O_absent)\n-                {\n-                  as_warn (_(\"using a bit field width of zero\"));\n-                  exp.X_add_number = 0;\n-                  exp.X_op = O_constant;\n-                }\n-\n-              if (exp.X_op != O_constant)\n-                {\n-                  *input_line_pointer = '\\0';\n-                  as_bad (_(\"field width \\\"%s\\\" too complex for a bitfield\"), hold);\n-                  *input_line_pointer = ':';\n-                  demand_empty_rest_of_line ();\n-                  return;\n-                }\n-\n-              if ((width = exp.X_add_number) >\n-                  (unsigned int)(BITS_PER_CHAR * nbytes))\n-                {\n+\t{\n+\t  /* Bitfields.  */\n+\t  long value = 0;\n+\n+\t  for (;;)\n+\t    {\n+\t      unsigned long width;\n+\n+\t      if (*input_line_pointer != ':')\n+\t\t{\n+\t\t  input_line_pointer = hold;\n+\t\t  break;\n+\t\t}\n+\t      if (exp.X_op == O_absent)\n+\t\t{\n+\t\t  as_warn (_(\"using a bit field width of zero\"));\n+\t\t  exp.X_add_number = 0;\n+\t\t  exp.X_op = O_constant;\n+\t\t}\n+\n+\t      if (exp.X_op != O_constant)\n+\t\t{\n+\t\t  *input_line_pointer = '\\0';\n+\t\t  as_bad (_(\"field width \\\"%s\\\" too complex for a bitfield\"),\n+\t\t\t  hold);\n+\t\t  *input_line_pointer = ':';\n+\t\t  demand_empty_rest_of_line ();\n+\t\t  return;\n+\t\t}\n+\n+\t      if ((width = exp.X_add_number) >\n+\t\t  (unsigned int)(BITS_PER_CHAR * nbytes))\n+\t\t{\n \t\t  as_warn (ngettext (\"field width %lu too big to fit in %d\"\n \t\t\t\t     \" byte: truncated to %d bits\",\n \t\t\t\t     \"field width %lu too big to fit in %d\"\n \t\t\t\t     \" bytes: truncated to %d bits\",\n \t\t\t\t     nbytes),\n \t\t\t   width, nbytes, (BITS_PER_CHAR * nbytes));\n-                  width = BITS_PER_CHAR * nbytes;\n-                }                   /* Too big.  */\n-\n-\n-              if (width > bits_available)\n-                {\n-                  /* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */\n-                  input_line_pointer = hold;\n-                  exp.X_add_number = value;\n-                  break;\n-                }\n-\n-              /* Skip ':'.  */\n-              hold = ++input_line_pointer;\n-\n-              expression (&exp);\n-              if (exp.X_op != O_constant)\n-                {\n-                  char cache = *input_line_pointer;\n-\n-                  *input_line_pointer = '\\0';\n-                  as_bad (_(\"field value \\\"%s\\\" too complex for a bitfield\"), hold);\n-                  *input_line_pointer = cache;\n-                  demand_empty_rest_of_line ();\n-                  return;\n-                }\n-\n-              value |= ((~(-(1 << width)) & exp.X_add_number)\n-                        << ((BITS_PER_CHAR * nbytes) - bits_available));\n-\n-              if ((bits_available -= width) == 0\n-                  || is_it_end_of_statement ()\n-                  || *input_line_pointer != ',')\n-                break;\n-\n-              hold = ++input_line_pointer;\n-              expression (&exp);\n-            }\n-\n-          exp.X_add_number = value;\n-          exp.X_op = O_constant;\n-          exp.X_unsigned = 1;\n-        }\n+\t\t  width = BITS_PER_CHAR * nbytes;\n+\t\t}\n+\n+\t      if (width > bits_available)\n+\t\t{\n+\t\t  /* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */\n+\t\t  input_line_pointer = hold;\n+\t\t  exp.X_add_number = value;\n+\t\t  break;\n+\t\t}\n+\n+\t      /* Skip ':'.  */\n+\t      hold = ++input_line_pointer;\n+\n+\t      expression (&exp);\n+\t      if (exp.X_op != O_constant)\n+\t\t{\n+\t\t  char cache = *input_line_pointer;\n+\n+\t\t  *input_line_pointer = '\\0';\n+\t\t  as_bad (_(\"field value \\\"%s\\\" too complex for a bitfield\"),\n+\t\t\t  hold);\n+\t\t  *input_line_pointer = cache;\n+\t\t  demand_empty_rest_of_line ();\n+\t\t  return;\n+\t\t}\n+\n+\t      value |= ((~(-(1 << width)) & exp.X_add_number)\n+\t\t\t<< ((BITS_PER_CHAR * nbytes) - bits_available));\n+\n+\t      if ((bits_available -= width) == 0\n+\t\t  || is_it_end_of_statement ()\n+\t\t  || *input_line_pointer != ',')\n+\t\tbreak;\n+\n+\t      hold = ++input_line_pointer;\n+\t      expression (&exp);\n+\t    }\n+\n+\t  exp.X_add_number = value;\n+\t  exp.X_op = O_constant;\n+\t  exp.X_unsigned = 1;\n+\t}\n \n       if ((*(input_line_pointer) == '@') && (*(input_line_pointer +1) == 'c'))\n-        code_label = 1;\n+\tcode_label = 1;\n       emit_expr (&exp, (unsigned int) nbytes);\n       ++c;\n       if ((*(input_line_pointer) == '@') && (*(input_line_pointer +1) == 'c'))\n-        {\n-          input_line_pointer +=3;\n-          break;\n-        }\n+\t{\n+\t  input_line_pointer +=3;\n+\t  break;\n+\t}\n     }\n   while ((*input_line_pointer++ == ','));\n \n@@ -383,8 +390,8 @@ get_index_register_pair (char *reg_name)\n   if (rreg != NULL)\n     {\n       if ((rreg->value.reg_val != 1) || (rreg->value.reg_val != 7)\n-          || (rreg->value.reg_val != 9) || (rreg->value.reg_val > 10))\n-        return rreg->value.reg_val;\n+\t  || (rreg->value.reg_val != 9) || (rreg->value.reg_val > 10))\n+\treturn rreg->value.reg_val;\n \n       as_bad (_(\"Unknown register pair - index relative mode: `%d'\"), rreg->value.reg_val);\n     }\n@@ -470,16 +477,15 @@ reset_vars (char *op)\n    to know about all such entries so that it can adjust them if\n    necessary.  */\n \n-#define SWITCH_TABLE(fix)                                  \\\n-  (   (fix)->fx_addsy != NULL                              \\\n-   && (fix)->fx_subsy != NULL                              \\\n-   && S_GET_SEGMENT ((fix)->fx_addsy) ==                   \\\n-      S_GET_SEGMENT ((fix)->fx_subsy)                      \\\n-   && S_GET_SEGMENT (fix->fx_addsy) != undefined_section   \\\n-   && (   (fix)->fx_r_type == BFD_RELOC_CR16_NUM8          \\\n-       || (fix)->fx_r_type == BFD_RELOC_CR16_NUM16         \\\n-       || (fix)->fx_r_type == BFD_RELOC_CR16_NUM32         \\\n-       || (fix)->fx_r_type == BFD_RELOC_CR16_NUM32a))\n+#define SWITCH_TABLE(fix)\t\t\t\t\t\t\\\n+  ((fix)->fx_addsy != NULL\t\t\t\t\t\t\\\n+   && (fix)->fx_subsy != NULL\t\t\t\t\t\t\\\n+   && ((fix)->fx_r_type == BFD_RELOC_CR16_NUM8\t\t\t\t\\\n+       || (fix)->fx_r_type == BFD_RELOC_CR16_NUM16\t\t\t\\\n+       || (fix)->fx_r_type == BFD_RELOC_CR16_NUM32\t\t\t\\\n+       || (fix)->fx_r_type == BFD_RELOC_CR16_NUM32a)\t\t\t\\\n+   && S_GET_SEGMENT ((fix)->fx_addsy) != undefined_section\t\t\\\n+   && S_GET_SEGMENT ((fix)->fx_addsy) == S_GET_SEGMENT ((fix)->fx_subsy))\n \n /* See whether we need to force a relocation into the output file.\n    This is used to force out switch and PC relative relocations when\n@@ -507,12 +513,12 @@ cr16_cons_fix_new (fragS *frag, int offset, int len, expressionS *exp,\n     case 2: rtype = BFD_RELOC_CR16_NUM16; break;\n     case 4:\n       if (code_label)\n-        {\n-          rtype = BFD_RELOC_CR16_NUM32a;\n-          code_label = 0;\n-        }\n+\t{\n+\t  rtype = BFD_RELOC_CR16_NUM32a;\n+\t  code_label = 0;\n+\t}\n       else\n-        rtype = BFD_RELOC_CR16_NUM32;\n+\trtype = BFD_RELOC_CR16_NUM32;\n       break;\n     }\n \n@@ -528,10 +534,10 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS * fixP)\n \n   /* If symbols are local and resolved, then no relocation needed.  */\n   if ( ((fixP->fx_addsy)\n-        && (S_GET_SEGMENT (fixP->fx_addsy) == absolute_section))\n+\t&& (S_GET_SEGMENT (fixP->fx_addsy) == absolute_section))\n        || ((fixP->fx_subsy)\n \t   && (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)))\n-     return NULL;\n+    return NULL;\n \n   reloc = XNEW (arelent);\n   reloc->sym_ptr_ptr  = XNEW (asymbol *);\n@@ -542,56 +548,56 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS * fixP)\n   if (fixP->fx_subsy != NULL)\n     {\n       if (SWITCH_TABLE (fixP))\n-        {\n-          /* Keep the current difference in the addend.  */\n-          reloc->addend = (S_GET_VALUE (fixP->fx_addsy)\n-                           - S_GET_VALUE (fixP->fx_subsy) + fixP->fx_offset);\n-\n-          switch (fixP->fx_r_type)\n-            {\n-            case BFD_RELOC_CR16_NUM8:\n-              fixP->fx_r_type = BFD_RELOC_CR16_SWITCH8;\n-              break;\n-            case BFD_RELOC_CR16_NUM16:\n-              fixP->fx_r_type = BFD_RELOC_CR16_SWITCH16;\n-              break;\n-            case BFD_RELOC_CR16_NUM32:\n-              fixP->fx_r_type = BFD_RELOC_CR16_SWITCH32;\n-              break;\n-            case BFD_RELOC_CR16_NUM32a:\n-              fixP->fx_r_type = BFD_RELOC_CR16_NUM32a;\n-              break;\n-            default:\n-              abort ();\n-              break;\n-            }\n-        }\n-      else\n-        {\n-          /* We only resolve difference expressions in the same section.  */\n-          as_bad_where (fixP->fx_file, fixP->fx_line,\n-                        _(\"can't resolve `%s' {%s section} - `%s' {%s section}\"),\n-                        fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : \"0\",\n-                        segment_name (fixP->fx_addsy\n-                                      ? S_GET_SEGMENT (fixP->fx_addsy)\n-                                      : absolute_section),\n-                        S_GET_NAME (fixP->fx_subsy),\n-                        segment_name (S_GET_SEGMENT (fixP->fx_addsy)));\n-        }\n-    }\n-#ifdef OBJ_ELF\n-      if ((fixP->fx_r_type == BFD_RELOC_CR16_GOT_REGREL20)\n-           && GOT_symbol\n-\t   && fixP->fx_addsy == GOT_symbol)\n \t{\n-\t    reloc->addend = fixP->fx_offset = reloc->address;\n+\t  /* Keep the current difference in the addend.  */\n+\t  reloc->addend = (S_GET_VALUE (fixP->fx_addsy)\n+\t\t\t   - S_GET_VALUE (fixP->fx_subsy) + fixP->fx_offset);\n+\n+\t  switch (fixP->fx_r_type)\n+\t    {\n+\t    case BFD_RELOC_CR16_NUM8:\n+\t      fixP->fx_r_type = BFD_RELOC_CR16_SWITCH8;\n+\t      break;\n+\t    case BFD_RELOC_CR16_NUM16:\n+\t      fixP->fx_r_type = BFD_RELOC_CR16_SWITCH16;\n+\t      break;\n+\t    case BFD_RELOC_CR16_NUM32:\n+\t      fixP->fx_r_type = BFD_RELOC_CR16_SWITCH32;\n+\t      break;\n+\t    case BFD_RELOC_CR16_NUM32a:\n+\t      fixP->fx_r_type = BFD_RELOC_CR16_NUM32a;\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t      break;\n+\t    }\n \t}\n-      else if ((fixP->fx_r_type == BFD_RELOC_CR16_GOTC_REGREL20)\n-           && GOT_symbol\n-\t   && fixP->fx_addsy == GOT_symbol)\n+      else\n \t{\n-\t    reloc->addend = fixP->fx_offset = reloc->address;\n+\t  /* We only resolve difference expressions in the same section.  */\n+\t  as_bad_where (fixP->fx_file, fixP->fx_line,\n+\t\t\t_(\"can't resolve `%s' {%s section} - `%s' {%s section}\"),\n+\t\t\tfixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : \"0\",\n+\t\t\tsegment_name (fixP->fx_addsy\n+\t\t\t\t      ? S_GET_SEGMENT (fixP->fx_addsy)\n+\t\t\t\t      : absolute_section),\n+\t\t\tS_GET_NAME (fixP->fx_subsy),\n+\t\t\tsegment_name (S_GET_SEGMENT (fixP->fx_addsy)));\n \t}\n+    }\n+#ifdef OBJ_ELF\n+  if ((fixP->fx_r_type == BFD_RELOC_CR16_GOT_REGREL20)\n+      && GOT_symbol\n+      && fixP->fx_addsy == GOT_symbol)\n+    {\n+      reloc->addend = fixP->fx_offset = reloc->address;\n+    }\n+  else if ((fixP->fx_r_type == BFD_RELOC_CR16_GOTC_REGREL20)\n+\t   && GOT_symbol\n+\t   && fixP->fx_addsy == GOT_symbol)\n+    {\n+      reloc->addend = fixP->fx_offset = reloc->address;\n+    }\n #endif\n \n   gas_assert ((int) fixP->fx_r_type > 0);\n@@ -600,9 +606,9 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS * fixP)\n   if (reloc->howto == NULL)\n     {\n       as_bad_where (fixP->fx_file, fixP->fx_line,\n-                    _(\"internal error: reloc %d (`%s') not supported by object file format\"),\n-                    fixP->fx_r_type,\n-                    bfd_get_reloc_code_name (fixP->fx_r_type));\n+\t\t    _(\"internal error: reloc %d (`%s') not supported by object file format\"),\n+\t\t    fixP->fx_r_type,\n+\t\t    bfd_get_reloc_code_name (fixP->fx_r_type));\n       return NULL;\n     }\n   gas_assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);\n@@ -623,12 +629,12 @@ md_estimate_size_before_relax (fragS *fragp, asection *seg)\n   for (subtype = 0; subtype < ARRAY_SIZE (rlx_state); subtype += 2)\n     {\n       if (fragp->fr_subtype == rlx_state[subtype]\n-          && (!S_IS_DEFINED (fragp->fr_symbol)\n-              || seg != S_GET_SEGMENT (fragp->fr_symbol)))\n-        {\n-          fragp->fr_subtype = rlx_state[subtype + 1];\n-          break;\n-        }\n+\t  && (!S_IS_DEFINED (fragp->fr_symbol)\n+\t      || seg != S_GET_SEGMENT (fragp->fr_symbol)))\n+\t{\n+\t  fragp->fr_subtype = rlx_state[subtype + 1];\n+\t  break;\n+\t}\n     }\n \n   if (fragp->fr_subtype >= ARRAY_SIZE (md_relax_table))\n@@ -654,32 +660,32 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, fragS *fragP)\n       break;\n     case 1:\n       /* If the subtype is not changed due to :m operand qualifier,\n-         then no need to update the opcode value.  */\n+\t then no need to update the opcode value.  */\n       if ((int)opcode[1] != 0x18)\n-        {\n-          opcode[0] = (opcode[0] & 0xf0);\n-          opcode[1] = 0x18;\n-        }\n+\t{\n+\t  opcode[0] = (opcode[0] & 0xf0);\n+\t  opcode[1] = 0x18;\n+\t}\n       reloc = BFD_RELOC_CR16_DISP16;\n       break;\n     case 2:\n       /* If the subtype is not changed due to :l operand qualifier,\n-         then no need to update the opcode value.  */\n+\t then no need to update the opcode value.  */\n       if ((int)opcode[1] != 0)\n-        {\n-          opcode[2] = opcode[0];\n-          opcode[0] = opcode[1];\n-          opcode[1] = 0x0;\n-        }\n+\t{\n+\t  opcode[2] = opcode[0];\n+\t  opcode[0] = opcode[1];\n+\t  opcode[1] = 0x0;\n+\t}\n       reloc = BFD_RELOC_CR16_DISP24;\n       break;\n     default:\n       abort();\n     }\n \n   fix_new (fragP, fragP->fr_fix,\n-           bfd_get_reloc_size (bfd_reloc_type_lookup (stdoutput, reloc)),\n-           fragP->fr_symbol, fragP->fr_offset, 1, reloc);\n+\t   bfd_get_reloc_size (bfd_reloc_type_lookup (stdoutput, reloc)),\n+\t   fragP->fr_symbol, fragP->fr_offset, 1, reloc);\n   fragP->fr_var = 0;\n   fragP->fr_fix += md_relax_table[fragP->fr_subtype].rlx_length;\n }\n@@ -828,15 +834,15 @@ md_begin (void)\n \tas_fatal (_(\"duplicate %s\"), mnemonic);\n \n       /* Insert unique names into hash table.  The CR16 instruction set\n-         has many identical opcode names that have different opcodes based\n-         on the operands.  This hash table then provides a quick index to\n-         the first opcode with a particular name in the opcode table.  */\n+\t has many identical opcode names that have different opcodes based\n+\t on the operands.  This hash table then provides a quick index to\n+\t the first opcode with a particular name in the opcode table.  */\n       do\n-        {\n-          ++i;\n-        }\n+\t{\n+\t  ++i;\n+\t}\n       while (cr16_instruction[i].mnemonic != NULL\n-             && streq (cr16_instruction[i].mnemonic, mnemonic));\n+\t     && streq (cr16_instruction[i].mnemonic, mnemonic));\n     }\n \n   /* Initialize reg_hash hash table.  */\n@@ -878,7 +884,7 @@ process_label_constant (char *str, ins * cr16_ins)\n     case O_absent:\n       /* Missing or bad expr becomes absolute 0.  */\n       as_bad (_(\"missing or invalid displacement expression `%s' taken as 0\"),\n-              str);\n+\t      str);\n       cr16_ins->exp.X_op = O_constant;\n       cr16_ins->exp.X_add_number = 0;\n       cr16_ins->exp.X_add_symbol = NULL;\n@@ -900,182 +906,182 @@ process_label_constant (char *str, ins * cr16_ins)\n       relocatable = 1;\n \n       if (strneq (input_line_pointer, \"@c\", 2))\n-        symbol_with_at = 1;\n+\tsymbol_with_at = 1;\n \n       if (strneq (input_line_pointer, \"@l\", 2)\n-          || strneq (input_line_pointer, \":l\", 2))\n-        symbol_with_l = 1;\n+\t  || strneq (input_line_pointer, \":l\", 2))\n+\tsymbol_with_l = 1;\n \n       if (strneq (input_line_pointer, \"@m\", 2)\n-          || strneq (input_line_pointer, \":m\", 2))\n-        symbol_with_m = 1;\n+\t  || strneq (input_line_pointer, \":m\", 2))\n+\tsymbol_with_m = 1;\n \n       if (strneq (input_line_pointer, \"@s\", 2)\n-          || strneq (input_line_pointer, \":s\", 2))\n-        symbol_with_s = 1;\n+\t  || strneq (input_line_pointer, \":s\", 2))\n+\tsymbol_with_s = 1;\n \n       if (strneq (input_line_pointer, \"@cGOT\", 5)\n-          || strneq (input_line_pointer, \"@cgot\", 5))\n+\t  || strneq (input_line_pointer, \"@cgot\", 5))\n \t{\n \t  if (GOT_symbol == NULL)\n-           GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);\n+\t    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);\n \n-          symbol_with_at_gotc = 1;\n+\t  symbol_with_at_gotc = 1;\n \t}\n       else if (strneq (input_line_pointer, \"@GOT\", 4)\n-          || strneq (input_line_pointer, \"@got\", 4))\n+\t       || strneq (input_line_pointer, \"@got\", 4))\n \t{\n-          if ((strneq (input_line_pointer, \"+\", 1))\n-\t       || (strneq (input_line_pointer, \"-\", 1)))\n-           as_warn (_(\"GOT bad expression with %s.\"), input_line_pointer);\n+\t  if ((strneq (input_line_pointer, \"+\", 1))\n+\t      || (strneq (input_line_pointer, \"-\", 1)))\n+\t    as_warn (_(\"GOT bad expression with %s.\"), input_line_pointer);\n \n \t  if (GOT_symbol == NULL)\n-           GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);\n+\t    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);\n \n-          symbol_with_at_got = 1;\n+\t  symbol_with_at_got = 1;\n \t}\n \n       switch (cur_arg->type)\n-        {\n-        case arg_cr:\n-          if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n-            {\n+\t{\n+\tcase arg_cr:\n+\t  if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n+\t    {\n \t      if (symbol_with_at_got)\n-\t          cr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n \t      else if (symbol_with_at_gotc)\n-\t          cr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n \t      else if (cur_arg->size == 20)\n-                cr16_ins->rtype = BFD_RELOC_CR16_REGREL20;\n-              else\n-                cr16_ins->rtype = BFD_RELOC_CR16_REGREL20a;\n-            }\n-          break;\n-\n-        case arg_crp:\n-          if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n-\t   {\n-\t    if (symbol_with_at_got)\n-\t      cr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n-\t    else if (symbol_with_at_gotc)\n-\t      cr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n-\t   } else {\n-            switch (instruction->size)\n-              {\n-              case 1:\n-                switch (cur_arg->size)\n-                  {\n-                  case 0:\n-                    cr16_ins->rtype = BFD_RELOC_CR16_REGREL0;\n-                    break;\n-                  case 4:\n-                    if (IS_INSN_MNEMONIC (\"loadb\") || IS_INSN_MNEMONIC (\"storb\"))\n-                      cr16_ins->rtype = BFD_RELOC_CR16_REGREL4;\n-                    else\n-                      cr16_ins->rtype = BFD_RELOC_CR16_REGREL4a;\n-                    break;\n-                  default: break;\n-                  }\n-                break;\n-              case 2:\n-                cr16_ins->rtype = BFD_RELOC_CR16_REGREL16;\n-                break;\n-              case 3:\n-                if (cur_arg->size == 20)\n-                  cr16_ins->rtype = BFD_RELOC_CR16_REGREL20;\n-                else\n-                  cr16_ins->rtype = BFD_RELOC_CR16_REGREL20a;\n-                break;\n-              default:\n-                break;\n-              }\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_REGREL20;\n+\t      else\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_REGREL20a;\n \t    }\n-          break;\n+\t  break;\n+\n+\tcase arg_crp:\n+\t  if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n+\t    {\n+\t      if (symbol_with_at_got)\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n+\t      else if (symbol_with_at_gotc)\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n+\t    } else {\n+\t    switch (instruction->size)\n+\t      {\n+\t      case 1:\n+\t\tswitch (cur_arg->size)\n+\t\t  {\n+\t\t  case 0:\n+\t\t    cr16_ins->rtype = BFD_RELOC_CR16_REGREL0;\n+\t\t    break;\n+\t\t  case 4:\n+\t\t    if (IS_INSN_MNEMONIC (\"loadb\") || IS_INSN_MNEMONIC (\"storb\"))\n+\t\t      cr16_ins->rtype = BFD_RELOC_CR16_REGREL4;\n+\t\t    else\n+\t\t      cr16_ins->rtype = BFD_RELOC_CR16_REGREL4a;\n+\t\t    break;\n+\t\t  default: break;\n+\t\t  }\n+\t\tbreak;\n+\t      case 2:\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_REGREL16;\n+\t\tbreak;\n+\t      case 3:\n+\t\tif (cur_arg->size == 20)\n+\t\t  cr16_ins->rtype = BFD_RELOC_CR16_REGREL20;\n+\t\telse\n+\t\t  cr16_ins->rtype = BFD_RELOC_CR16_REGREL20a;\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  break;\n \n-        case arg_idxr:\n-          if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n+\tcase arg_idxr:\n+\t  if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n \t    {\n \t      if (symbol_with_at_got)\n-\t        cr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n \t      else if (symbol_with_at_gotc)\n-\t        cr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n \t      else\n-                cr16_ins->rtype = BFD_RELOC_CR16_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_REGREL20;\n \t    }\n-          break;\n+\t  break;\n+\n+\tcase arg_idxrp:\n+\t  if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n+\t    {\n+\t      if (symbol_with_at_got)\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n+\t      else if (symbol_with_at_gotc)\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n+\t      else {\n+\t\tswitch (instruction->size)\n+\t\t  {\n+\t\t  case 1: cr16_ins->rtype = BFD_RELOC_CR16_REGREL0; break;\n+\t\t  case 2: cr16_ins->rtype = BFD_RELOC_CR16_REGREL14; break;\n+\t\t  case 3: cr16_ins->rtype = BFD_RELOC_CR16_REGREL20; break;\n+\t\t  default: break;\n+\t\t  }\n+\t      }\n+\t    }\n+\t  break;\n \n-        case arg_idxrp:\n-          if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n+\tcase arg_c:\n+\t  if (IS_INSN_MNEMONIC (\"bal\"))\n+\t    cr16_ins->rtype = BFD_RELOC_CR16_DISP24;\n+\t  else if (IS_INSN_TYPE (BRANCH_INS))\n \t    {\n-\t    if (symbol_with_at_got)\n-\t      cr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n-\t    else if (symbol_with_at_gotc)\n-\t      cr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n-\t    else {\n-            switch (instruction->size)\n-              {\n-              case 1: cr16_ins->rtype = BFD_RELOC_CR16_REGREL0; break;\n-              case 2: cr16_ins->rtype = BFD_RELOC_CR16_REGREL14; break;\n-              case 3: cr16_ins->rtype = BFD_RELOC_CR16_REGREL20; break;\n-              default: break;\n-              }\n+\t      if (symbol_with_l)\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_DISP24;\n+\t      else if (symbol_with_m)\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_DISP16;\n+\t      else\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_DISP8;\n \t    }\n-\t   }\n-          break;\n-\n-        case arg_c:\n-          if (IS_INSN_MNEMONIC (\"bal\"))\n-            cr16_ins->rtype = BFD_RELOC_CR16_DISP24;\n-          else if (IS_INSN_TYPE (BRANCH_INS))\n-            {\n-              if (symbol_with_l)\n-                cr16_ins->rtype = BFD_RELOC_CR16_DISP24;\n-              else if (symbol_with_m)\n-                cr16_ins->rtype = BFD_RELOC_CR16_DISP16;\n-              else\n-                cr16_ins->rtype = BFD_RELOC_CR16_DISP8;\n-            }\n-          else if (IS_INSN_TYPE (STOR_IMM_INS) || IS_INSN_TYPE (LD_STOR_INS)\n-                   || IS_INSN_TYPE (CSTBIT_INS))\n-            {\n+\t  else if (IS_INSN_TYPE (STOR_IMM_INS) || IS_INSN_TYPE (LD_STOR_INS)\n+\t\t   || IS_INSN_TYPE (CSTBIT_INS))\n+\t    {\n \t      if (symbol_with_s)\n-                as_bad (_(\"operand %d: illegal use expression: `%s`\"), cur_arg_num + 1, str);\n+\t\tas_bad (_(\"operand %d: illegal use expression: `%s`\"), cur_arg_num + 1, str);\n \t      if (symbol_with_at_got)\n-\t        cr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n \t      else if (symbol_with_at_gotc)\n-\t        cr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n \t      else if (symbol_with_m)\n-                cr16_ins->rtype = BFD_RELOC_CR16_ABS20;\n-              else /* Default to (symbol_with_l) */\n-                cr16_ins->rtype = BFD_RELOC_CR16_ABS24;\n-            }\n-          else if (IS_INSN_TYPE (BRANCH_NEQ_INS))\n-            cr16_ins->rtype = BFD_RELOC_CR16_DISP4;\n-          break;\n-\n-        case arg_ic:\n-          if (IS_INSN_TYPE (ARITH_INS))\n-            {\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_ABS20;\n+\t      else /* Default to (symbol_with_l) */\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_ABS24;\n+\t    }\n+\t  else if (IS_INSN_TYPE (BRANCH_NEQ_INS))\n+\t    cr16_ins->rtype = BFD_RELOC_CR16_DISP4;\n+\t  break;\n+\n+\tcase arg_ic:\n+\t  if (IS_INSN_TYPE (ARITH_INS))\n+\t    {\n \t      if (symbol_with_at_got)\n-\t        cr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOT_REGREL20;\n \t      else if (symbol_with_at_gotc)\n-\t        cr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_GOTC_REGREL20;\n \t      else if (symbol_with_s)\n-                cr16_ins->rtype = BFD_RELOC_CR16_IMM4;\n-              else if (symbol_with_m)\n-                cr16_ins->rtype = BFD_RELOC_CR16_IMM20;\n-              else if (symbol_with_at)\n-                cr16_ins->rtype = BFD_RELOC_CR16_IMM32a;\n-              else /* Default to (symbol_with_l) */\n-                cr16_ins->rtype = BFD_RELOC_CR16_IMM32;\n-            }\n-          else if (IS_INSN_TYPE (ARITH_BYTE_INS))\n-            {\n-              cr16_ins->rtype = BFD_RELOC_CR16_IMM16;\n-            }\n-          break;\n-        default:\n-          break;\n-        }\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_IMM4;\n+\t      else if (symbol_with_m)\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_IMM20;\n+\t      else if (symbol_with_at)\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_IMM32a;\n+\t      else /* Default to (symbol_with_l) */\n+\t\tcr16_ins->rtype = BFD_RELOC_CR16_IMM32;\n+\t    }\n+\t  else if (IS_INSN_TYPE (ARITH_BYTE_INS))\n+\t    {\n+\t      cr16_ins->rtype = BFD_RELOC_CR16_IMM16;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n       break;\n \n     default:\n@@ -1109,18 +1115,18 @@ getreg_image (reg r)\n \n   reg_name = rreg->name;\n \n-/* Issue a error message when register is illegal.  */\n-#define IMAGE_ERR \\\n-  as_bad (_(\"Illegal register (`%s') in Instruction: `%s'\"), \\\n+  /* Issue a error message when register is illegal.  */\n+#define IMAGE_ERR\t\t\t\t\t\t\\\n+  as_bad (_(\"Illegal register (`%s') in Instruction: `%s'\"),\t\\\n \t  reg_name, ins_parse);\n \n   switch (rreg->type)\n     {\n     case CR16_R_REGTYPE:\n       if (! is_procreg)\n-        return rreg->image;\n+\treturn rreg->image;\n       else\n-        IMAGE_ERR;\n+\tIMAGE_ERR;\n       break;\n \n     case CR16_P_REGTYPE:\n@@ -1165,15 +1171,15 @@ set_operand (char *operand, ins * cr16_ins)\n       process_label_constant (operandS, cr16_ins);\n \n       if (cur_arg->type != arg_ic)\n-        cur_arg->type = arg_c;\n+\tcur_arg->type = arg_c;\n       break;\n \n     case arg_icr:   /* Case $0x18(r1).  */\n       operandS++;\n     case arg_cr:    /* Case 0x18(r1).   */\n       /* Set displacement constant.  */\n       while (*operandE != '(')\n-        operandE++;\n+\toperandE++;\n       *operandE = '\\0';\n       process_label_constant (operandS, cr16_ins);\n       operandS = operandE;\n@@ -1182,86 +1188,86 @@ set_operand (char *operand, ins * cr16_ins)\n       operandS++;\n       /* Set register base.  */\n       while (*operandE != ')')\n-        operandE++;\n+\toperandE++;\n       *operandE = '\\0';\n       if ((cur_arg->r = get_register (operandS)) == nullregister)\n-         as_bad (_(\"Illegal register `%s' in Instruction `%s'\"),\n-              operandS, ins_parse);\n+\tas_bad (_(\"Illegal register `%s' in Instruction `%s'\"),\n+\t\toperandS, ins_parse);\n \n       /* set the arg->rp, if reg is \"r12\" or \"r13\" or \"14\" or \"15\" */\n       if ((cur_arg->type != arg_rbase)\n-          && ((getreg_image (cur_arg->r) == 12)\n-              || (getreg_image (cur_arg->r) == 13)\n-              || (getreg_image (cur_arg->r) == 14)\n-              || (getreg_image (cur_arg->r) == 15)))\n-         {\n-           cur_arg->type = arg_crp;\n-           cur_arg->rp = cur_arg->r;\n-         }\n+\t  && ((getreg_image (cur_arg->r) == 12)\n+\t      || (getreg_image (cur_arg->r) == 13)\n+\t      || (getreg_image (cur_arg->r) == 14)\n+\t      || (getreg_image (cur_arg->r) == 15)))\n+\t{\n+\t  cur_arg->type = arg_crp;\n+\t  cur_arg->rp = cur_arg->r;\n+\t}\n       break;\n \n     case arg_crp:    /* Case 0x18(r1,r0).   */\n       /* Set displacement constant.  */\n       while (*operandE != '(')\n-        operandE++;\n+\toperandE++;\n       *operandE = '\\0';\n       process_label_constant (operandS, cr16_ins);\n       operandS = operandE;\n       operandS++;\n       /* Set register pair base.  */\n       while (*operandE != ')')\n-        operandE++;\n+\toperandE++;\n       *operandE = '\\0';\n       if ((cur_arg->rp = get_register_pair (operandS)) == nullregister)\n-         as_bad (_(\"Illegal register pair `%s' in Instruction `%s'\"),\n-              operandS, ins_parse);\n+\tas_bad (_(\"Illegal register pair `%s' in Instruction `%s'\"),\n+\t\toperandS, ins_parse);\n       break;\n \n     case arg_idxr:\n       /* Set register pair base.  */\n       if ((strchr (operandS,'(') != NULL))\n-        {\n-         while ((*operandE != '(') && (! ISSPACE (*operandE)))\n-           operandE++;\n-         if ((cur_arg->rp = get_index_register_pair (operandE)) == nullregister)\n-              as_bad (_(\"Illegal register pair `%s' in Instruction `%s'\"),\n-                            operandS, ins_parse);\n-         *operandE++ = '\\0';\n-         cur_arg->type = arg_idxrp;\n-        }\n+\t{\n+\t  while ((*operandE != '(') && (! ISSPACE (*operandE)))\n+\t    operandE++;\n+\t  if ((cur_arg->rp = get_index_register_pair (operandE)) == nullregister)\n+\t    as_bad (_(\"Illegal register pair `%s' in Instruction `%s'\"),\n+\t\t    operandS, ins_parse);\n+\t  *operandE++ = '\\0';\n+\t  cur_arg->type = arg_idxrp;\n+\t}\n       else\n-        cur_arg->rp = -1;\n+\tcur_arg->rp = -1;\n \n-       operandE = operandS;\n+      operandE = operandS;\n       /* Set displacement constant.  */\n       while (*operandE != ']')\n-        operandE++;\n+\toperandE++;\n       process_label_constant (++operandE, cr16_ins);\n       *operandE++ = '\\0';\n       operandE = operandS;\n \n       /* Set index register .  */\n       operandS = strchr (operandE,'[');\n       if (operandS != NULL)\n-        { /* Eliminate '[', detach from rest of operand.  */\n-          *operandS++ = '\\0';\n-\n-          operandE = strchr (operandS, ']');\n-\n-          if (operandE == NULL)\n-            as_bad (_(\"unmatched '['\"));\n-          else\n-            { /* Eliminate ']' and make sure it was the last thing\n-                 in the string.  */\n-              *operandE = '\\0';\n-              if (*(operandE + 1) != '\\0')\n-                as_bad (_(\"garbage after index spec ignored\"));\n-            }\n-        }\n+\t{ /* Eliminate '[', detach from rest of operand.  */\n+\t  *operandS++ = '\\0';\n+\n+\t  operandE = strchr (operandS, ']');\n+\n+\t  if (operandE == NULL)\n+\t    as_bad (_(\"unmatched '['\"));\n+\t  else\n+\t    { /* Eliminate ']' and make sure it was the last thing\n+\t\t in the string.  */\n+\t      *operandE = '\\0';\n+\t      if (*(operandE + 1) != '\\0')\n+\t\tas_bad (_(\"garbage after index spec ignored\"));\n+\t    }\n+\t}\n \n       if ((cur_arg->i_r = get_index_register (operandS)) == nullregister)\n-        as_bad (_(\"Illegal register `%s' in Instruction `%s'\"),\n-                operandS, ins_parse);\n+\tas_bad (_(\"Illegal register `%s' in Instruction `%s'\"),\n+\t\toperandS, ins_parse);\n       *operandE = '\\0';\n       *operandS = '\\0';\n       break;\n@@ -1338,9 +1344,9 @@ parse_operand (char *operand, ins * cr16_ins)\n     {\n     case '$':\n       if (strchr (operand, '(') != NULL)\n-        cur_arg->type = arg_icr;\n+\tcur_arg->type = arg_icr;\n       else\n-        cur_arg->type = arg_ic;\n+\tcur_arg->type = arg_ic;\n       goto set_params;\n       break;\n \n@@ -1361,15 +1367,15 @@ parse_operand (char *operand, ins * cr16_ins)\n   if (strchr (operand, '(') != NULL)\n     {\n       if (strchr (operand, ',') != NULL\n-          && (strchr (operand, ',') > strchr (operand, '(')))\n-        cur_arg->type = arg_crp;\n+\t  && (strchr (operand, ',') > strchr (operand, '(')))\n+\tcur_arg->type = arg_crp;\n       else\n-        cur_arg->type = arg_cr;\n+\tcur_arg->type = arg_cr;\n     }\n   else\n     cur_arg->type = arg_c;\n \n-/* Parse an operand according to its type.  */\n+  /* Parse an operand according to its type.  */\n  set_params:\n   cur_arg->constant = 0;\n   set_operand (operand, cr16_ins);\n@@ -1395,40 +1401,40 @@ parse_operands (ins * cr16_ins, char *operands)\n   while (*operandT != '\\0')\n     {\n       if (*operandT == ',' && bracket_flag != 1 && sq_bracket_flag != 1)\n-        {\n-          *operandT++ = '\\0';\n-          operand[op_num++] = strdup (operandH);\n-          operandH = operandT;\n-          continue;\n-        }\n+\t{\n+\t  *operandT++ = '\\0';\n+\t  operand[op_num++] = strdup (operandH);\n+\t  operandH = operandT;\n+\t  continue;\n+\t}\n \n       if (*operandT == ' ')\n-        as_bad (_(\"Illegal operands (whitespace): `%s'\"), ins_parse);\n+\tas_bad (_(\"Illegal operands (whitespace): `%s'\"), ins_parse);\n \n       if (*operandT == '(')\n-        bracket_flag = 1;\n+\tbracket_flag = 1;\n       else if (*operandT == '[')\n-        sq_bracket_flag = 1;\n+\tsq_bracket_flag = 1;\n \n       if (*operandT == ')')\n-        {\n-          if (bracket_flag)\n-            bracket_flag = 0;\n-          else\n-            as_fatal (_(\"Missing matching brackets : `%s'\"), ins_parse);\n-        }\n+\t{\n+\t  if (bracket_flag)\n+\t    bracket_flag = 0;\n+\t  else\n+\t    as_fatal (_(\"Missing matching brackets : `%s'\"), ins_parse);\n+\t}\n       else if (*operandT == ']')\n-        {\n-          if (sq_bracket_flag)\n-            sq_bracket_flag = 0;\n-          else\n-            as_fatal (_(\"Missing matching brackets : `%s'\"), ins_parse);\n-        }\n+\t{\n+\t  if (sq_bracket_flag)\n+\t    sq_bracket_flag = 0;\n+\t  else\n+\t    as_fatal (_(\"Missing matching brackets : `%s'\"), ins_parse);\n+\t}\n \n       if (bracket_flag == 1 && *operandT == ')')\n-        bracket_flag = 0;\n+\tbracket_flag = 0;\n       else if (sq_bracket_flag == 1 && *operandT == ']')\n-        sq_bracket_flag = 0;\n+\tsq_bracket_flag = 0;\n \n       operandT++;\n     }\n@@ -1529,7 +1535,7 @@ static int\n is_bcc_insn (char * op)\n {\n   if (!(streq (op, \"bal\") || streq (op, \"beq0b\") || streq (op, \"bnq0b\")\n-        || streq (op, \"beq0w\") || streq (op, \"bnq0w\")))\n+\t|| streq (op, \"beq0w\") || streq (op, \"bnq0w\")))\n     if ((op[0] == 'b') && (get_b_cc (op) != NULL))\n       return 1;\n   return 0;\n@@ -1580,10 +1586,10 @@ getregp_image (reg r)\n \n   reg_name = rreg->name;\n \n-/* Issue a error message when register  pair is illegal.  */\n-#define RPAIR_IMAGE_ERR \\\n-  as_bad (_(\"Illegal register pair (`%s') in Instruction: `%s'\"), \\\n-            reg_name, ins_parse);                                 \\\n+  /* Issue a error message when register  pair is illegal.  */\n+#define RPAIR_IMAGE_ERR\t\t\t\t\t\t\t\\\n+  as_bad (_(\"Illegal register pair (`%s') in Instruction: `%s'\"),\t\\\n+\t  reg_name, ins_parse);\t\t\t\t\t\t\\\n   break;\n \n   switch (rreg->type)\n@@ -1619,26 +1625,26 @@ getidxregp_image (reg r)\n \n   reg_name = rreg->name;\n \n-/* Issue a error message when register  pair is illegal.  */\n-#define IDX_RPAIR_IMAGE_ERR \\\n+  /* Issue a error message when register  pair is illegal.  */\n+#define IDX_RPAIR_IMAGE_ERR\t\t\t\t\t\t\\\n   as_bad (_(\"Illegal index register pair (`%s') in Instruction: `%s'\"), \\\n-            reg_name, ins_parse);                                       \\\n+\t  reg_name, ins_parse);\t\t\t\t\t\t\\\n \n   if (rreg->type == CR16_RP_REGTYPE)\n     {\n       switch (rreg->image)\n-        {\n-        case 0:  return 0; break;\n-        case 2:  return 1; break;\n-        case 4:  return 2; break;\n-        case 6:  return 3; break;\n-        case 8:  return 4; break;\n-        case 10: return 5; break;\n-        case 3:  return 6; break;\n-        case 5:  return 7; break;\n-        default:\n-          break;\n-        }\n+\t{\n+\tcase 0:  return 0; break;\n+\tcase 2:  return 1; break;\n+\tcase 4:  return 2; break;\n+\tcase 6:  return 3; break;\n+\tcase 8:  return 4; break;\n+\tcase 10: return 5; break;\n+\tcase 3:  return 6; break;\n+\tcase 5:  return 7; break;\n+\tdefault:\n+\t  break;\n+\t}\n     }\n \n   IDX_RPAIR_IMAGE_ERR;\n@@ -1666,10 +1672,10 @@ getprocreg_image (int r)\n \n   reg_name = rreg->name;\n \n-/* Issue a error message when register  pair is illegal.  */\n-#define PROCREG_IMAGE_ERR \\\n-  as_bad (_(\"Illegal processor register (`%s') in Instruction: `%s'\"), \\\n-            reg_name, ins_parse);                                      \\\n+  /* Issue a error message when register  pair is illegal.  */\n+#define PROCREG_IMAGE_ERR\t\t\t\t\t\t\\\n+  as_bad (_(\"Illegal processor register (`%s') in Instruction: `%s'\"),\t\\\n+\t  reg_name, ins_parse);\t\t\t\t\t\t\\\n   break;\n \n   switch (rreg->type)\n@@ -1698,19 +1704,19 @@ getprocregp_image (int r)\n     {\n       r = r - MAX_REG;\n       switch (r)\n-        {\n-        case 4: pregptab_disp = 1;  break;\n-        case 6: pregptab_disp = 2;  break;\n-        case 8:\n-        case 9:\n-        case 10:\n-          pregptab_disp = 3;  break;\n-        case 12:\n-          pregptab_disp = 4;  break;\n-        case 14:\n-          pregptab_disp = 5;  break;\n-        default: break;\n-        }\n+\t{\n+\tcase 4: pregptab_disp = 1;  break;\n+\tcase 6: pregptab_disp = 2;  break;\n+\tcase 8:\n+\tcase 9:\n+\tcase 10:\n+\t  pregptab_disp = 3;  break;\n+\tcase 12:\n+\t  pregptab_disp = 4;  break;\n+\tcase 14:\n+\t  pregptab_disp = 5;  break;\n+\tdefault: break;\n+\t}\n       rreg = &cr16_pregptab[r - pregptab_disp];\n     }\n   /* Register not found.  */\n@@ -1722,10 +1728,10 @@ getprocregp_image (int r)\n \n   reg_name = rreg->name;\n \n-/* Issue a error message when register  pair is illegal.  */\n-#define PROCREGP_IMAGE_ERR \\\n-  as_bad (_(\"Illegal 32 bit - processor register (`%s') in Instruction: `%s'\"),\\\n-            reg_name, ins_parse);                                              \\\n+  /* Issue a error message when register  pair is illegal.  */\n+#define PROCREGP_IMAGE_ERR\t\t\t\t\t\t\\\n+  as_bad (_(\"Illegal 32 bit - processor register (`%s') in Instruction: `%s'\"), \\\n+\t  reg_name, ins_parse);\t\t\t\t\t\t\\\n   break;\n \n   switch (rreg->type)\n@@ -1744,9 +1750,9 @@ getprocregp_image (int r)\n static long\n getconstant (long x, int nbits)\n {\n-  /* The following expression avoids overflow if\n-     'nbits' is the number of bits in 'bfd_vma'.  */\n-  return (x & ((((1 << (nbits - 1)) - 1) << 1) | 1));\n+  if ((unsigned) nbits >= sizeof (x) * CHAR_BIT)\n+    return x;\n+  return x & ((1UL << nbits) - 1);\n }\n \n /* Print a constant value to 'output_opcode':\n@@ -1758,27 +1764,26 @@ static void\n print_constant (int nbits, int shift, argument *arg)\n {\n   unsigned long mask = 0;\n-\n-  long constant = getconstant (arg->constant, nbits);\n+  unsigned long constant = getconstant (arg->constant, nbits);\n \n   switch (nbits)\n     {\n     case 32:\n     case 28:\n       /* mask the upper part of the constant, that is, the bits\n-         going to the lowest byte of output_opcode[0].\n-         The upper part of output_opcode[1] is always filled,\n-         therefore it is always masked with 0xFFFF.  */\n+\t going to the lowest byte of output_opcode[0].\n+\t The upper part of output_opcode[1] is always filled,\n+\t therefore it is always masked with 0xFFFF.  */\n       mask = (1 << (nbits - 16)) - 1;\n       /* Divide the constant between two consecutive words :\n-         0        1         2         3\n-         +---------+---------+---------+---------+\n-         |         | X X X X | x X x X |         |\n-         +---------+---------+---------+---------+\n-         output_opcode[0]    output_opcode[1]     */\n+\t 0        1         2         3\n+\t +---------+---------+---------+---------+\n+\t |         | X X X X | x X x X |         |\n+\t +---------+---------+---------+---------+\n+\t output_opcode[0]    output_opcode[1]     */\n \n       CR16_PRINT (0, (constant >> WORD_SHIFT) & mask, 0);\n-      CR16_PRINT (1, (constant & 0xFFFF), WORD_SHIFT);\n+      CR16_PRINT (1, constant & 0xFFFF, WORD_SHIFT);\n       break;\n \n     case 21:\n@@ -1789,74 +1794,77 @@ print_constant (int nbits, int shift, argument *arg)\n     case 22:\n     case 20:\n       /* mask the upper part of the constant, that is, the bits\n-         going to the lowest byte of output_opcode[0].\n-         The upper part of output_opcode[1] is always filled,\n-         therefore it is always masked with 0xFFFF.  */\n+\t going to the lowest byte of output_opcode[0].\n+\t The upper part of output_opcode[1] is always filled,\n+\t therefore it is always masked with 0xFFFF.  */\n       mask = (1 << (nbits - 16)) - 1;\n       /* Divide the constant between two consecutive words :\n-         0        1         2          3\n-         +---------+---------+---------+---------+\n-         |         | X X X X | - X - X |         |\n-         +---------+---------+---------+---------+\n-         output_opcode[0]    output_opcode[1]     */\n-\n-      if ((instruction->size > 2) && (shift == WORD_SHIFT))\n-        {\n-          if (arg->type == arg_idxrp)\n-            {\n-              CR16_PRINT (0, ((constant >> WORD_SHIFT) & mask) << 8, 0);\n-              CR16_PRINT (1, (constant & 0xFFFF), WORD_SHIFT);\n-            }\n-          else\n-            {\n-              CR16_PRINT (0, (((((constant >> WORD_SHIFT) & mask) << 8) & 0x0f00) | ((((constant >> WORD_SHIFT) & mask) >> 4) & 0xf)),0);\n-              CR16_PRINT (1, (constant & 0xFFFF), WORD_SHIFT);\n-            }\n-        }\n+\t 0        1         2          3\n+\t +---------+---------+---------+---------+\n+\t |         | X X X X | - X - X |         |\n+\t +---------+---------+---------+---------+\n+\t output_opcode[0]    output_opcode[1]     */\n+\n+      if (instruction->size > 2 && shift == WORD_SHIFT)\n+\t{\n+\t  if (arg->type == arg_idxrp)\n+\t    {\n+\t      CR16_PRINT (0, ((constant >> WORD_SHIFT) & mask) << 8, 0);\n+\t      CR16_PRINT (1, constant & 0xFFFF, WORD_SHIFT);\n+\t    }\n+\t  else\n+\t    {\n+\t      CR16_PRINT (0,\n+\t\t\t  ((((constant >> WORD_SHIFT) & mask & 0xf) << 8)\n+\t\t\t   | (((constant >> WORD_SHIFT) & mask & 0xf0) >> 4)),\n+\t\t\t  0);\n+\t      CR16_PRINT (1, constant & 0xFFFF, WORD_SHIFT);\n+\t    }\n+\t}\n       else\n-        CR16_PRINT (0, constant, shift);\n+\tCR16_PRINT (0, constant, shift);\n       break;\n \n     case 14:\n       if (arg->type == arg_idxrp)\n-        {\n-          if (instruction->size == 2)\n-            {\n-              CR16_PRINT (0, ((constant)      & 0xf), shift);        /* 0-3 bits.  */\n-              CR16_PRINT (0, ((constant >> 4) & 0x3), (shift + 20)); /* 4-5 bits.  */\n-              CR16_PRINT (0, ((constant >> 6) & 0x3), (shift + 14)); /* 6-7 bits.  */\n-              CR16_PRINT (0, ((constant >> 8) & 0x3f), (shift + 8)); /* 8-13 bits.  */\n-            }\n-          else\n-            CR16_PRINT (0, constant, shift);\n-        }\n+\t{\n+\t  if (instruction->size == 2)\n+\t    {\n+\t      CR16_PRINT (0, (constant)      & 0xf, shift);      /* 0-3 bits.  */\n+\t      CR16_PRINT (0, (constant >> 4) & 0x3, shift + 20); /* 4-5 bits.  */\n+\t      CR16_PRINT (0, (constant >> 6) & 0x3, shift + 14); /* 6-7 bits.  */\n+\t      CR16_PRINT (0, (constant >> 8) & 0x3f, shift + 8); /* 8-13 bits.  */\n+\t    }\n+\t  else\n+\t    CR16_PRINT (0, constant, shift);\n+\t}\n       break;\n \n     case 16:\n     case 12:\n       /* When instruction size is 3 and 'shift' is 16, a 16-bit constant is\n-         always filling the upper part of output_opcode[1]. If we mistakenly\n-         write it to output_opcode[0], the constant prefix (that is, 'match')\n-         will be overridden.\n-         0        1         2         3\n-         +---------+---------+---------+---------+\n-         | 'match' |         | X X X X |         |\n-         +---------+---------+---------+---------+\n-         output_opcode[0]    output_opcode[1]     */\n-\n-      if ((instruction->size > 2) && (shift == WORD_SHIFT))\n-        CR16_PRINT (1, constant, WORD_SHIFT);\n+\t always filling the upper part of output_opcode[1]. If we mistakenly\n+\t write it to output_opcode[0], the constant prefix (that is, 'match')\n+\t will be overridden.\n+\t 0        1         2         3\n+\t +---------+---------+---------+---------+\n+\t | 'match' |         | X X X X |         |\n+\t +---------+---------+---------+---------+\n+\t output_opcode[0]    output_opcode[1]     */\n+\n+      if (instruction->size > 2 && shift == WORD_SHIFT)\n+\tCR16_PRINT (1, constant, WORD_SHIFT);\n       else\n-        CR16_PRINT (0, constant, shift);\n+\tCR16_PRINT (0, constant, shift);\n       break;\n \n     case 8:\n-      CR16_PRINT (0, ((constant / 2) & 0xf), shift);\n-      CR16_PRINT (0, ((constant / 2) >> 4), (shift + 8));\n+      CR16_PRINT (0, (constant / 2) & 0xf, shift);\n+      CR16_PRINT (0, (constant / 2) >> 4, shift + 8);\n       break;\n \n     default:\n-      CR16_PRINT (0, constant,  shift);\n+      CR16_PRINT (0, constant, shift);\n       break;\n     }\n }\n@@ -1894,41 +1902,27 @@ print_operand (int nbits, int shift, argument *arg)\n \n     case arg_idxrp:\n       /*    16      12      8    6      0\n-            +-----------------------------+\n-            | r_index | disp  | rp_base   |\n-            +-----------------------------+          */\n+\t    +-----------------------------+\n+\t    | r_index | disp  | rp_base   |\n+\t    +-----------------------------+          */\n \n       if (instruction->size == 3)\n-        {\n-          CR16_PRINT (0, getidxregp_image (arg->rp), 0);\n-          if (getreg_image (arg->i_r) == 12)\n-            CR16_PRINT (0, 0, 3);\n-          else\n-            CR16_PRINT (0, 1, 3);\n-        }\n+\t{\n+\t  CR16_PRINT (0, getidxregp_image (arg->rp), 0);\n+\t  CR16_PRINT (0, getreg_image (arg->i_r) & 1, 3);\n+\t}\n       else\n-        {\n-          CR16_PRINT (0, getidxregp_image (arg->rp), 16);\n-          if (getreg_image (arg->i_r) == 12)\n-            CR16_PRINT (0, 0, 19);\n-          else\n-            CR16_PRINT (0, 1, 19);\n-        }\n+\t{\n+\t  CR16_PRINT (0, getidxregp_image (arg->rp), 16);\n+\t  CR16_PRINT (0, getreg_image (arg->i_r) & 1, 19);\n+\t}\n       print_constant (nbits, shift, arg);\n       break;\n \n     case arg_idxr:\n-      if (getreg_image (arg->i_r) == 12)\n-        if (IS_INSN_MNEMONIC (\"cbitb\") || IS_INSN_MNEMONIC (\"sbitb\")\n-            || IS_INSN_MNEMONIC (\"tbitb\"))\n-          CR16_PRINT (0, 0, 23);\n-        else CR16_PRINT (0, 0, 24);\n-      else\n-        if (IS_INSN_MNEMONIC (\"cbitb\") || IS_INSN_MNEMONIC (\"sbitb\")\n-            || IS_INSN_MNEMONIC (\"tbitb\"))\n-          CR16_PRINT (0, 1, 23);\n-        else CR16_PRINT (0, 1, 24);\n-\n+      CR16_PRINT (0, getreg_image (arg->i_r) & 1,\n+\t\t  (IS_INSN_TYPE (CSTBIT_INS)\n+\t\t   && instruction->mnemonic[4] == 'b') ? 23 : 24);\n       print_constant (nbits, shift, arg);\n       break;\n \n@@ -1942,24 +1936,20 @@ print_operand (int nbits, int shift, argument *arg)\n       break;\n \n     case arg_cr:\n-      print_constant (nbits, shift , arg);\n+      print_constant (nbits, shift, arg);\n       /* Add the register argument to the output_opcode.  */\n-      CR16_PRINT (0, getreg_image (arg->r), (shift+16));\n+      CR16_PRINT (0, getreg_image (arg->r), shift - 16);\n       break;\n \n     case arg_crp:\n-      print_constant (nbits, shift , arg);\n-      if (instruction->size > 1)\n-        CR16_PRINT (0, getregp_image (arg->rp), (shift + 16));\n-      else if (IS_INSN_TYPE (LD_STOR_INS) || (IS_INSN_TYPE (CSTBIT_INS)))\n-        {\n-          if (instruction->size == 2)\n-            CR16_PRINT (0, getregp_image (arg->rp), (shift - 8));\n-          else if (instruction->size == 1)\n-            CR16_PRINT (0, getregp_image (arg->rp), 16);\n-        }\n+      print_constant (nbits, shift, arg);\n+      if ((IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS))\n+\t  && instruction->size == 1)\n+\tCR16_PRINT (0, getregp_image (arg->rp), 16);\n+      else if (instruction->size > 1)\n+\tCR16_PRINT (0, getregp_image (arg->rp), (shift + 16) & 31);\n       else\n-        CR16_PRINT (0, getregp_image (arg->rp), shift);\n+\tCR16_PRINT (0, getregp_image (arg->rp), shift);\n       break;\n \n     default:\n@@ -1987,93 +1977,88 @@ get_number_of_operands (void)\n static op_err\n check_range (long *num, int bits, int unsigned flags, int update)\n {\n-  long min, max;\n+  int32_t min, max;\n   op_err retval = OP_LEGAL;\n-  long value = *num;\n-\n-  if (bits == 0 && value > 0) return OP_OUT_OF_RANGE;\n-\n-  /* For hosts with longs bigger than 32-bits make sure that the top\n-     bits of a 32-bit negative value read in by the parser are set,\n-     so that the correct comparisons are made.  */\n-  if (value & 0x80000000)\n-    value |= (-1UL << 31);\n-\n+  int32_t value = *num;\n \n   /* Verify operand value is even.  */\n   if (flags & OP_EVEN)\n     {\n       if (value % 2)\n-        return OP_NOT_EVEN;\n+\treturn OP_NOT_EVEN;\n     }\n \n   if (flags & OP_DEC)\n     {\n       value -= 1;\n       if (update)\n-        *num = value;\n+\t*num = value;\n     }\n \n   if (flags & OP_SHIFT)\n     {\n       value >>= 1;\n       if (update)\n-        *num = value;\n+\t*num = value;\n     }\n   else if (flags & OP_SHIFT_DEC)\n     {\n       value = (value >> 1) - 1;\n       if (update)\n-        *num = value;\n+\t*num = value;\n     }\n \n   if (flags & OP_ABS20)\n     {\n       if (value > 0xEFFFF)\n-        return OP_OUT_OF_RANGE;\n+\treturn OP_OUT_OF_RANGE;\n     }\n \n   if (flags & OP_ESC)\n     {\n       if (value == 0xB || value == 0x9)\n-        return OP_OUT_OF_RANGE;\n+\treturn OP_OUT_OF_RANGE;\n       else if (value == -1)\n-        {\n-          if (update)\n-            *num = 9;\n-          return retval;\n-        }\n+\t{\n+\t  if (update)\n+\t    *num = 9;\n+\t  return retval;\n+\t}\n     }\n \n   if (flags & OP_ESC1)\n     {\n       if (value > 13)\n-        return OP_OUT_OF_RANGE;\n-    }\n-\n-   if (flags & OP_SIGNED)\n-     {\n-       max = (1 << (bits - 1)) - 1;\n-       min = - (1 << (bits - 1));\n-       if ((value > max) || (value < min))\n-         retval = OP_OUT_OF_RANGE;\n-     }\n-   else if (flags & OP_UNSIGNED)\n-     {\n-       max = ((((1 << (bits - 1)) - 1) << 1) | 1);\n-       min = 0;\n-       if (((unsigned long) value > (unsigned long) max)\n-            || ((unsigned long) value < (unsigned long) min))\n-         retval = OP_OUT_OF_RANGE;\n-     }\n-   else if (flags & OP_NEG)\n-     {\n-       max = - 1;\n-       min = - ((1 << (bits - 1)) - 1);\n-       if ((value > max) || (value < min))\n-         retval = OP_OUT_OF_RANGE;\n-     }\n-   return retval;\n+\treturn OP_OUT_OF_RANGE;\n+    }\n+\n+  if (bits == 0)\n+    {\n+      if (value != 0)\n+\tretval = OP_OUT_OF_RANGE;\n+      return retval;\n+    }\n+\n+  if (flags & OP_SIGNED)\n+    {\n+      max = (1U << (bits - 1)) - 1;\n+      min = - (1U << (bits - 1));\n+      if (value > max || value < min)\n+\tretval = OP_OUT_OF_RANGE;\n+    }\n+  else if (flags & OP_UNSIGNED)\n+    {\n+      max = (1U << (bits - 1) << 1) - 1;\n+      if ((uint32_t) value > (uint32_t) max)\n+\tretval = OP_OUT_OF_RANGE;\n+    }\n+  else if (flags & OP_NEG)\n+    {\n+      min = - ((1U << (bits - 1)) - 1);\n+      if (value < min)\n+\tretval = OP_OUT_OF_RANGE;\n+    }\n+  return retval;\n }\n \n /* Bunch of error checking.\n@@ -2089,8 +2074,9 @@ warn_if_needed (ins *insn)\n     {\n       /* Enough to verify that one of the arguments is a simple reg.  */\n       if ((insn->arg[0].type == arg_r) || (insn->arg[1].type == arg_r))\n-        if (insn->arg[0].r == insn->arg[1].r)\n-          as_bad (_(\"Same src/dest register is used (`r%d'), result is undefined\"), insn->arg[0].r);\n+\tif (insn->arg[0].r == insn->arg[1].r)\n+\t  as_bad (_(\"Same src/dest register is used (`r%d'), \"\n+\t\t    \"result is undefined\"), insn->arg[0].r);\n     }\n \n   if (IS_INSN_MNEMONIC (\"pop\")\n@@ -2100,60 +2086,60 @@ warn_if_needed (ins *insn)\n       unsigned int count = insn->arg[0].constant, reg_val;\n \n       /* Check if count operand caused to save/retrieve the RA twice\n-         to generate warning message.  */\n-     if (insn->nargs > 2)\n-       {\n-         reg_val = getreg_image (insn->arg[1].r);\n-\n-         if (   ((reg_val == 9) &&  (count > 7))\n-             || ((reg_val == 10) && (count > 6))\n-             || ((reg_val == 11) && (count > 5))\n-             || ((reg_val == 12) && (count > 4))\n-             || ((reg_val == 13) && (count > 2))\n-             || ((reg_val == 14) && (count > 0)))\n-           as_warn (_(\"RA register is saved twice.\"));\n-\n-         /* Check if the third operand is \"RA\" or \"ra\" */\n-         if (!(((insn->arg[2].r) == ra) || ((insn->arg[2].r) == RA)))\n-           as_bad (_(\"`%s' Illegal use of registers.\"), ins_parse);\n-       }\n+\t to generate warning message.  */\n+      if (insn->nargs > 2)\n+\t{\n+\t  reg_val = getreg_image (insn->arg[1].r);\n+\n+\t  if (   ((reg_val == 9) &&  (count > 7))\n+\t\t || ((reg_val == 10) && (count > 6))\n+\t\t || ((reg_val == 11) && (count > 5))\n+\t\t || ((reg_val == 12) && (count > 4))\n+\t\t || ((reg_val == 13) && (count > 2))\n+\t\t || ((reg_val == 14) && (count > 0)))\n+\t    as_warn (_(\"RA register is saved twice.\"));\n+\n+\t  /* Check if the third operand is \"RA\" or \"ra\" */\n+\t  if (!(((insn->arg[2].r) == ra) || ((insn->arg[2].r) == RA)))\n+\t    as_bad (_(\"`%s' Illegal use of registers.\"), ins_parse);\n+\t}\n \n       if (insn->nargs > 1)\n-       {\n-         reg_val = getreg_image (insn->arg[1].r);\n-\n-         /* If register is a register pair ie r12/r13/r14 in operand1, then\n-            the count constant should be validated.  */\n-         if (((reg_val == 11) && (count > 7))\n-             || ((reg_val == 12) && (count > 6))\n-             || ((reg_val == 13) && (count > 4))\n-             || ((reg_val == 14) && (count > 2))\n-             || ((reg_val == 15) && (count > 0)))\n-           as_bad (_(\"`%s' Illegal count-register combination.\"), ins_parse);\n-       }\n-     else\n-       {\n-         /* Check if the operand is \"RA\" or \"ra\" */\n-         if (!(((insn->arg[0].r) == ra) || ((insn->arg[0].r) == RA)))\n-           as_bad (_(\"`%s' Illegal use of register.\"), ins_parse);\n-       }\n+\t{\n+\t  reg_val = getreg_image (insn->arg[1].r);\n+\n+\t  /* If register is a register pair ie r12/r13/r14 in operand1, then\n+\t     the count constant should be validated.  */\n+\t  if (((reg_val == 11) && (count > 7))\n+\t      || ((reg_val == 12) && (count > 6))\n+\t      || ((reg_val == 13) && (count > 4))\n+\t      || ((reg_val == 14) && (count > 2))\n+\t      || ((reg_val == 15) && (count > 0)))\n+\t    as_bad (_(\"`%s' Illegal count-register combination.\"), ins_parse);\n+\t}\n+      else\n+\t{\n+\t  /* Check if the operand is \"RA\" or \"ra\" */\n+\t  if (!(((insn->arg[0].r) == ra) || ((insn->arg[0].r) == RA)))\n+\t    as_bad (_(\"`%s' Illegal use of register.\"), ins_parse);\n+\t}\n     }\n \n   /* Some instruction assume the stack pointer as rptr operand.\n      Issue an error when the register to be loaded is also SP.  */\n   if (instruction->flags & NO_SP)\n     {\n       if (getreg_image (insn->arg[1].r) == getreg_image (sp))\n-        as_bad (_(\"`%s' has undefined result\"), ins_parse);\n+\tas_bad (_(\"`%s' has undefined result\"), ins_parse);\n     }\n \n   /* If the rptr register is specified as one of the registers to be loaded,\n      the final contents of rptr are undefined. Thus, we issue an error.  */\n   if (instruction->flags & NO_RPTR)\n     {\n       if ((1 << getreg_image (insn->arg[0].r)) & insn->arg[1].constant)\n-        as_bad (_(\"Same src/dest register is used (`r%d'),result is undefined\"),\n-                  getreg_image (insn->arg[0].r));\n+\tas_bad (_(\"Same src/dest register is used (`r%d'),result is undefined\"),\n+\t\tgetreg_image (insn->arg[0].r));\n     }\n }\n \n@@ -2169,12 +2155,12 @@ adjust_if_needed (ins *insn ATTRIBUTE_UNUSED)\n   if ((IS_INSN_TYPE (CSTBIT_INS)) || (IS_INSN_TYPE (LD_STOR_INS)))\n     {\n       if ((instruction->operands[0].op_type == abs24)\n-           && ((insn->arg[0].constant) > 0xF00000))\n-        {\n-          insn->arg[0].constant &= 0xFFFFF;\n-          instruction--;\n-          ret_value = 1;\n-        }\n+\t  && ((insn->arg[0].constant) > 0xF00000))\n+\t{\n+\t  insn->arg[0].constant &= 0xFFFFF;\n+\t  instruction--;\n+\t  ret_value = 1;\n+\t}\n     }\n \n   return ret_value;\n@@ -2216,9 +2202,9 @@ assemble_insn (const char *mnemonic, ins *insn)\n   /* Operand error (used for issuing various constant error messages).  */\n   op_err op_error, const_err = OP_LEGAL;\n \n-/* Retrieve data (based on FUNC) for each operand of a given instruction.  */\n-#define GET_CURRENT_DATA(FUNC, ARRAY)                           \\\n-  for (i = 0; i < insn->nargs; i++)                             \\\n+  /* Retrieve data (based on FUNC) for each operand of a given instruction.  */\n+#define GET_CURRENT_DATA(FUNC, ARRAY)\t\t\t\\\n+  for (i = 0; i < insn->nargs; i++)\t\t\t\\\n     ARRAY[i] = FUNC (instruction->operands[i].op_type)\n \n #define GET_CURRENT_TYPE    GET_CURRENT_DATA (get_optype, cur_type)\n@@ -2241,17 +2227,17 @@ assemble_insn (const char *mnemonic, ins *insn)\n   ins_type = CR16_INS_TYPE (instruction->flags);\n \n   while (/* Check that match is still not found.  */\n-         match != 1\n-         /* Check we didn't get to end of table.  */\n-         && instruction->mnemonic != NULL\n-         /* Check that the actual mnemonic is still available.  */\n-         && IS_INSN_MNEMONIC (mnemonic)\n-         /* Check that the instruction type wasn't changed.  */\n-         && IS_INSN_TYPE (ins_type))\n+\t match != 1\n+\t /* Check we didn't get to end of table.  */\n+\t && instruction->mnemonic != NULL\n+\t /* Check that the actual mnemonic is still available.  */\n+\t && IS_INSN_MNEMONIC (mnemonic)\n+\t /* Check that the instruction type wasn't changed.  */\n+\t && IS_INSN_TYPE (ins_type))\n     {\n       /* Check whether number of arguments is legal.  */\n       if (get_number_of_operands () != insn->nargs)\n-        goto next_insn;\n+\tgoto next_insn;\n       found_same_number_of_operands = 1;\n \n       /* Initialize arrays with data of each operand in current template.  */\n@@ -2261,53 +2247,53 @@ assemble_insn (const char *mnemonic, ins *insn)\n \n       /* Check for type compatibility.  */\n       for (i = 0; i < insn->nargs; i++)\n-        {\n-          if (cur_type[i] != insn->arg[i].type)\n-            {\n-              if (invalid_optype == -1)\n-                invalid_optype = i + 1;\n-              goto next_insn;\n-            }\n-        }\n+\t{\n+\t  if (cur_type[i] != insn->arg[i].type)\n+\t    {\n+\t      if (invalid_optype == -1)\n+\t\tinvalid_optype = i + 1;\n+\t      goto next_insn;\n+\t    }\n+\t}\n       found_same_argument_types = 1;\n \n       for (i = 0; i < insn->nargs; i++)\n-        {\n-          /* If 'bal' instruction size is '2' and reg operand is not 'ra'\n-             then goto next instruction.  */\n-          if (IS_INSN_MNEMONIC (\"bal\") && (i == 0)\n-              && (instruction->size == 2) && (insn->arg[i].rp != 14))\n-            goto next_insn;\n-\n-          /* If 'storb' instruction with 'sp' reg and 16-bit disp of\n-           * reg-pair, leads to undefined trap, so this should use\n-           * 20-bit disp of reg-pair.  */\n-          if (IS_INSN_MNEMONIC (\"storb\") && (instruction->size == 2)\n-              && (insn->arg[i].r == 15) && (insn->arg[i + 1].type == arg_crp))\n-            goto next_insn;\n-\n-          /* Only check range - don't update the constant's value, since the\n-             current instruction may not be the last we try to match.\n-             The constant's value will be updated later, right before printing\n-             it to the object file.  */\n-          if ((insn->arg[i].X_op == O_constant)\n-              && (op_error = check_range (&insn->arg[i].constant, cur_size[i],\n-                                          cur_flags[i], 0)))\n-            {\n-              if (invalid_const == -1)\n-                {\n-                  invalid_const = i + 1;\n-                  const_err = op_error;\n-                }\n-              goto next_insn;\n-            }\n-          /* For symbols, we make sure the relocation size (which was already\n-             determined) is sufficient.  */\n-          else if ((insn->arg[i].X_op == O_symbol)\n-                   && ((bfd_reloc_type_lookup (stdoutput, insn->rtype))->bitsize\n-                       > cur_size[i]))\n-                  goto next_insn;\n-        }\n+\t{\n+\t  /* If 'bal' instruction size is '2' and reg operand is not 'ra'\n+\t     then goto next instruction.  */\n+\t  if (IS_INSN_MNEMONIC (\"bal\") && (i == 0)\n+\t      && (instruction->size == 2) && (insn->arg[i].rp != 14))\n+\t    goto next_insn;\n+\n+\t  /* If 'storb' instruction with 'sp' reg and 16-bit disp of\n+\t   * reg-pair, leads to undefined trap, so this should use\n+\t   * 20-bit disp of reg-pair.  */\n+\t  if (IS_INSN_MNEMONIC (\"storb\") && (instruction->size == 2)\n+\t      && (insn->arg[i].r == 15) && (insn->arg[i + 1].type == arg_crp))\n+\t    goto next_insn;\n+\n+\t  /* Only check range - don't update the constant's value, since the\n+\t     current instruction may not be the last we try to match.\n+\t     The constant's value will be updated later, right before printing\n+\t     it to the object file.  */\n+\t  if ((insn->arg[i].X_op == O_constant)\n+\t      && (op_error = check_range (&insn->arg[i].constant, cur_size[i],\n+\t\t\t\t\t  cur_flags[i], 0)))\n+\t    {\n+\t      if (invalid_const == -1)\n+\t\t{\n+\t\t  invalid_const = i + 1;\n+\t\t  const_err = op_error;\n+\t\t}\n+\t      goto next_insn;\n+\t    }\n+\t  /* For symbols, we make sure the relocation size (which was already\n+\t     determined) is sufficient.  */\n+\t  else if ((insn->arg[i].X_op == O_symbol)\n+\t\t   && ((bfd_reloc_type_lookup (stdoutput, insn->rtype))->bitsize\n+\t\t       > cur_size[i]))\n+\t    goto next_insn;\n+\t}\n       found_const_within_range = 1;\n \n       /* If we got till here -> Full match is found.  */\n@@ -2323,70 +2309,70 @@ assemble_insn (const char *mnemonic, ins *insn)\n     {\n       /* We haven't found a match - instruction can't be assembled.  */\n       if (!found_same_number_of_operands)\n-        as_bad (_(\"Incorrect number of operands\"));\n+\tas_bad (_(\"Incorrect number of operands\"));\n       else if (!found_same_argument_types)\n-        as_bad (_(\"Illegal type of operand (arg %d)\"), invalid_optype);\n+\tas_bad (_(\"Illegal type of operand (arg %d)\"), invalid_optype);\n       else if (!found_const_within_range)\n-        {\n-          switch (const_err)\n-            {\n-            case OP_OUT_OF_RANGE:\n-              as_bad (_(\"Operand out of range (arg %d)\"), invalid_const);\n-              break;\n-            case OP_NOT_EVEN:\n-              as_bad (_(\"Operand has odd displacement (arg %d)\"), invalid_const);\n-              break;\n-            default:\n-              as_bad (_(\"Illegal operand (arg %d)\"), invalid_const);\n-              break;\n-            }\n-        }\n-\n-       return 0;\n+\t{\n+\t  switch (const_err)\n+\t    {\n+\t    case OP_OUT_OF_RANGE:\n+\t      as_bad (_(\"Operand out of range (arg %d)\"), invalid_const);\n+\t      break;\n+\t    case OP_NOT_EVEN:\n+\t      as_bad (_(\"Operand has odd displacement (arg %d)\"), invalid_const);\n+\t      break;\n+\t    default:\n+\t      as_bad (_(\"Illegal operand (arg %d)\"), invalid_const);\n+\t      break;\n+\t    }\n+\t}\n+\n+      return 0;\n     }\n   else\n     /* Full match - print the encoding to output file.  */\n     {\n       /* Make further checking (such that couldn't be made earlier).\n-         Warn the user if necessary.  */\n+\t Warn the user if necessary.  */\n       warn_if_needed (insn);\n \n       /* Check whether we need to adjust the instruction pointer.  */\n       if (adjust_if_needed (insn))\n-        /* If instruction pointer was adjusted, we need to update\n-           the size of the current template operands.  */\n-        GET_CURRENT_SIZE;\n+\t/* If instruction pointer was adjusted, we need to update\n+\t   the size of the current template operands.  */\n+\tGET_CURRENT_SIZE;\n \n       for (i = 0; i < insn->nargs; i++)\n-        {\n-          int j = instruction->flags & REVERSE_MATCH ?\n-                  i == 0 ? 1 :\n-                  i == 1 ? 0 : i :\n-                  i;\n-\n-          /* This time, update constant value before printing it.  */\n-            if ((insn->arg[j].X_op == O_constant)\n-               && (check_range (&insn->arg[j].constant, cur_size[j],\n-                                cur_flags[j], 1) != OP_LEGAL))\n-              as_fatal (_(\"Illegal operand (arg %d)\"), j+1);\n-        }\n+\t{\n+\t  int j = instruction->flags & REVERSE_MATCH ?\n+\t    i == 0 ? 1 :\n+\t    i == 1 ? 0 : i :\n+\t    i;\n+\n+\t  /* This time, update constant value before printing it.  */\n+\t  if ((insn->arg[j].X_op == O_constant)\n+\t      && (check_range (&insn->arg[j].constant, cur_size[j],\n+\t\t\t       cur_flags[j], 1) != OP_LEGAL))\n+\t    as_fatal (_(\"Illegal operand (arg %d)\"), j+1);\n+\t}\n \n       /* First, copy the instruction's opcode.  */\n       output_opcode[0] = BIN (instruction->match, instruction->match_bits);\n \n       for (i = 0; i < insn->nargs; i++)\n-        {\n-         /* For BAL (ra),disp17 instruction only. And also set the\n-            DISP24a relocation type.  */\n-         if (IS_INSN_MNEMONIC (\"bal\") && (instruction->size == 2) && i == 0)\n-           {\n-             insn->rtype = BFD_RELOC_CR16_DISP24a;\n-             continue;\n-           }\n-          cur_arg_num = i;\n-          print_operand (cur_size[i], instruction->operands[i].shift,\n-                         &insn->arg[i]);\n-        }\n+\t{\n+\t  /* For BAL (ra),disp17 instruction only. And also set the\n+\t     DISP24a relocation type.  */\n+\t  if (IS_INSN_MNEMONIC (\"bal\") && (instruction->size == 2) && i == 0)\n+\t    {\n+\t      insn->rtype = BFD_RELOC_CR16_DISP24a;\n+\t      continue;\n+\t    }\n+\t  cur_arg_num = i;\n+\t  print_operand (cur_size[i], instruction->operands[i].shift,\n+\t\t\t &insn->arg[i]);\n+\t}\n     }\n \n   return 1;\n@@ -2410,62 +2396,62 @@ print_insn (ins *insn)\n       words[j++] = output_opcode[i] & 0xFFFF;\n     }\n \n-    /* Handle relocation.  */\n-    if ((instruction->flags & RELAXABLE) && relocatable)\n-      {\n-        int relax_subtype;\n-        /* Write the maximal instruction size supported.  */\n-        insn_size = INSN_MAX_SIZE;\n-\n-        if (IS_INSN_TYPE (BRANCH_INS))\n-          {\n-            switch (insn->rtype)\n-              {\n-              case BFD_RELOC_CR16_DISP24:\n-                relax_subtype = 2;\n-                break;\n-              case BFD_RELOC_CR16_DISP16:\n-                relax_subtype = 1;\n-                break;\n-              default:\n-                relax_subtype = 0;\n-                break;\n-              }\n-          }\n-        else\n-          abort ();\n-\n-        this_frag = frag_var (rs_machine_dependent, insn_size *2,\n-                              4, relax_subtype,\n-                              insn->exp.X_add_symbol,\n-                              0,\n-                              0);\n-      }\n-    else\n-      {\n-        insn_size = instruction->size;\n-        this_frag = frag_more (insn_size * 2);\n-\n-        if ((relocatable) && (insn->rtype != BFD_RELOC_NONE))\n-          {\n-             reloc_howto_type *reloc_howto;\n-             int size;\n-\n-             reloc_howto = bfd_reloc_type_lookup (stdoutput, insn->rtype);\n-\n-             if (!reloc_howto)\n-               abort ();\n-\n-             size = bfd_get_reloc_size (reloc_howto);\n-\n-             if (size < 1 || size > 4)\n-               abort ();\n-\n-             fix_new_exp (frag_now, this_frag - frag_now->fr_literal,\n-                          size, &insn->exp, reloc_howto->pc_relative,\n-                          insn->rtype);\n-          }\n-      }\n+  /* Handle relocation.  */\n+  if ((instruction->flags & RELAXABLE) && relocatable)\n+    {\n+      int relax_subtype;\n+      /* Write the maximal instruction size supported.  */\n+      insn_size = INSN_MAX_SIZE;\n+\n+      if (IS_INSN_TYPE (BRANCH_INS))\n+\t{\n+\t  switch (insn->rtype)\n+\t    {\n+\t    case BFD_RELOC_CR16_DISP24:\n+\t      relax_subtype = 2;\n+\t      break;\n+\t    case BFD_RELOC_CR16_DISP16:\n+\t      relax_subtype = 1;\n+\t      break;\n+\t    default:\n+\t      relax_subtype = 0;\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\tabort ();\n+\n+      this_frag = frag_var (rs_machine_dependent, insn_size *2,\n+\t\t\t    4, relax_subtype,\n+\t\t\t    insn->exp.X_add_symbol,\n+\t\t\t    0,\n+\t\t\t    0);\n+    }\n+  else\n+    {\n+      insn_size = instruction->size;\n+      this_frag = frag_more (insn_size * 2);\n+\n+      if ((relocatable) && (insn->rtype != BFD_RELOC_NONE))\n+\t{\n+\t  reloc_howto_type *reloc_howto;\n+\t  int size;\n+\n+\t  reloc_howto = bfd_reloc_type_lookup (stdoutput, insn->rtype);\n+\n+\t  if (!reloc_howto)\n+\t    abort ();\n+\n+\t  size = bfd_get_reloc_size (reloc_howto);\n+\n+\t  if (size < 1 || size > 4)\n+\t    abort ();\n+\n+\t  fix_new_exp (frag_now, this_frag - frag_now->fr_literal,\n+\t\t       size, &insn->exp, reloc_howto->pc_relative,\n+\t\t       insn->rtype);\n+\t}\n+    }\n \n   /* Verify a 2-byte code alignment.  */\n   addr_mod = frag_now_fix () & 1;\n@@ -2544,7 +2530,7 @@ md_assemble (char *op)\n      extra white spaces.  */\n   if (streq (\"cinv\", op))\n     {\n-     /* Validate the cinv options.  */\n+      /* Validate the cinv options.  */\n       unsigned int op_len, param_len;\n       check_cinv_options (param);\n       op_len = strlen (op);\n@@ -2561,18 +2547,18 @@ md_assemble (char *op)\n       strcpy (param1, param);\n       /* Find the instruction.  */\n       instruction = (const inst *) str_hash_find (cr16_inst_hash, op);\n-       parse_operands (&cr16_ins, param1);\n+      parse_operands (&cr16_ins, param1);\n       if (((&cr16_ins)->arg[0].type == arg_ic)\n-          && ((&cr16_ins)->arg[0].constant >= 0))\n-        {\n-           if (streq (\"lshb\", op))\n-             cr16_assemble (\"ashub\", param);\n-           else if (streq (\"lshd\", op))\n-             cr16_assemble (\"ashud\", param);\n-           else\n-             cr16_assemble (\"ashuw\", param);\n-\t   return;\n-        }\n+\t  && ((&cr16_ins)->arg[0].constant >= 0))\n+\t{\n+\t  if (streq (\"lshb\", op))\n+\t    cr16_assemble (\"ashub\", param);\n+\t  else if (streq (\"lshd\", op))\n+\t    cr16_assemble (\"ashud\", param);\n+\t  else\n+\t    cr16_assemble (\"ashuw\", param);\n+\t  return;\n+\t}\n     }\n \n   cr16_assemble (op, param);"
    }
  ]
}