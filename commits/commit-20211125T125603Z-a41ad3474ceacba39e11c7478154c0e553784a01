{
  "sha": "a41ad3474ceacba39e11c7478154c0e553784a01",
  "node_id": "C_kwDOANOeidoAKGE0MWFkMzQ3NGNlYWNiYTM5ZTExYzc0NzgxNTRjMGU1NTM3ODRhMDE",
  "commit": {
    "author": {
      "name": "Bruno Larsen",
      "email": "blarsen@redhat.com",
      "date": "2021-10-29T20:56:28Z"
    },
    "committer": {
      "name": "Bruno Larsen",
      "email": "blarsen@redhat.com",
      "date": "2021-11-25T12:56:03Z"
    },
    "message": "PR gdb/28480: Improve ambiguous member detection\n\nBasic ambiguity detection assumes that when 2 fields with the same name\nhave the same byte offset, it must be an unambiguous request. This is not\nalways correct. Consider the following code:\n\nclass empty { };\n\nclass A {\npublic:\n  [[no_unique_address]] empty e;\n};\n\nclass B {\npublic:\n  int e;\n};\n\nclass C: public A, public B { };\n\nif we tried to use c.e in code, the compiler would warn of an ambiguity,\nhowever, since A::e does not demand an unique address, it gets the same\naddress (and thus byte offset) of the members, making A::e and B::e have the\nsame address. however, \"print c.e\" would fail to report the ambiguity,\nand would instead print it as an empty class (first path found).\n\nThe new code solves this by checking for other found_fields that have\ndifferent m_struct_path.back() (final class that the member was found\nin), despite having the same byte offset.\n\nThe testcase gdb.cp/ambiguous.exp was also changed to test for this\nbehavior.",
    "tree": {
      "sha": "db9de693ebbb1b1596b4df4a12d3f229f4d250b9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/db9de693ebbb1b1596b4df4a12d3f229f4d250b9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a41ad3474ceacba39e11c7478154c0e553784a01",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a41ad3474ceacba39e11c7478154c0e553784a01",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a41ad3474ceacba39e11c7478154c0e553784a01",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a41ad3474ceacba39e11c7478154c0e553784a01/comments",
  "author": {
    "login": "billionai",
    "id": 31167038,
    "node_id": "MDQ6VXNlcjMxMTY3MDM4",
    "avatar_url": "https://avatars.githubusercontent.com/u/31167038?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/billionai",
    "html_url": "https://github.com/billionai",
    "followers_url": "https://api.github.com/users/billionai/followers",
    "following_url": "https://api.github.com/users/billionai/following{/other_user}",
    "gists_url": "https://api.github.com/users/billionai/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/billionai/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/billionai/subscriptions",
    "organizations_url": "https://api.github.com/users/billionai/orgs",
    "repos_url": "https://api.github.com/users/billionai/repos",
    "events_url": "https://api.github.com/users/billionai/events{/privacy}",
    "received_events_url": "https://api.github.com/users/billionai/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "billionai",
    "id": 31167038,
    "node_id": "MDQ6VXNlcjMxMTY3MDM4",
    "avatar_url": "https://avatars.githubusercontent.com/u/31167038?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/billionai",
    "html_url": "https://github.com/billionai",
    "followers_url": "https://api.github.com/users/billionai/followers",
    "following_url": "https://api.github.com/users/billionai/following{/other_user}",
    "gists_url": "https://api.github.com/users/billionai/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/billionai/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/billionai/subscriptions",
    "organizations_url": "https://api.github.com/users/billionai/orgs",
    "repos_url": "https://api.github.com/users/billionai/repos",
    "events_url": "https://api.github.com/users/billionai/events{/privacy}",
    "received_events_url": "https://api.github.com/users/billionai/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "423e91d347cf6050ac17c7098cad6cbc15e5e50f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/423e91d347cf6050ac17c7098cad6cbc15e5e50f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/423e91d347cf6050ac17c7098cad6cbc15e5e50f"
    }
  ],
  "stats": {
    "total": 57,
    "additions": 57,
    "deletions": 0
  },
  "files": [
    {
      "sha": "af2198dcfbc0206d37563e75c1b00286017ad5f3",
      "filename": "gdb/testsuite/gdb.cp/ambiguous.cc",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a41ad3474ceacba39e11c7478154c0e553784a01/gdb/testsuite/gdb.cp/ambiguous.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a41ad3474ceacba39e11c7478154c0e553784a01/gdb/testsuite/gdb.cp/ambiguous.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/ambiguous.cc?ref=a41ad3474ceacba39e11c7478154c0e553784a01",
      "patch": "@@ -1,3 +1,4 @@\n+class empty { };\n \n class A1 {\n public:\n@@ -17,6 +18,17 @@ class A3 {\n   int y;\n };\n \n+#if !defined (__GNUC__) || __GNUC__ > 7\n+# define NO_UNIQUE_ADDRESS [[no_unique_address]]\n+#else\n+# define NO_UNIQUE_ADDRESS\n+#endif\n+\n+class A4 {\n+public:\n+    NO_UNIQUE_ADDRESS empty x;\n+};\n+\n class X : public A1, public A2 {\n public:\n   int z;\n@@ -77,6 +89,10 @@ class JVA1V : public KV, public LV, public virtual A1 {\n   int jva1v;\n };\n \n+class JE : public A1, public A4 {\n+public:\n+};\n+\n int main()\n {\n   A1 a1;\n@@ -92,6 +108,7 @@ int main()\n   JVA1 jva1;\n   JVA2 jva2;\n   JVA1V jva1v;\n+  JE je;\n   \n   int i;\n \n@@ -173,5 +190,7 @@ int main()\n   jva1v.i = 4;\n   jva1v.jva1v = 5;\n \n+  je.A1::x = 1;\n+\n   return 0; /* set breakpoint here */\n }"
    },
    {
      "sha": "1e63dc0c5dc699e3456c3344577a579c1b680cd5",
      "filename": "gdb/testsuite/gdb.cp/ambiguous.exp",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a41ad3474ceacba39e11c7478154c0e553784a01/gdb/testsuite/gdb.cp/ambiguous.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a41ad3474ceacba39e11c7478154c0e553784a01/gdb/testsuite/gdb.cp/ambiguous.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/ambiguous.exp?ref=a41ad3474ceacba39e11c7478154c0e553784a01",
      "patch": "@@ -264,3 +264,13 @@ gdb_test \"print (A1)(KV)jva1\" \" = \\{x = 3, y = 4\\}\"\n # JVA1V is derived from A1; A1 is a virtual base indirectly\n # and also directly; must not report ambiguity when a JVA1V is cast to an A1.\n gdb_test \"print (A1)jva1v\" \" = {x = 1, y = 2}\"\n+\n+# C++20 introduced a way to have ambiguous fields with the same byte offset.\n+# This class explicitly tests for that.\n+# if this is tested with a compiler that can't handle [[no_unique_address]]\n+# the code should still correctly identify the ambiguity because of\n+# different byte offsets.\n+test_ambiguous \"je.x\" \"x\" \"JE\" {\n+    \"'int A1::x' (JE -> A1)\"\n+    \"'empty A4::x' (JE -> A4)\"\n+}"
    },
    {
      "sha": "c552e828a947baa562e910c376aa568fc578b035",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a41ad3474ceacba39e11c7478154c0e553784a01/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a41ad3474ceacba39e11c7478154c0e553784a01/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=a41ad3474ceacba39e11c7478154c0e553784a01",
      "patch": "@@ -1962,6 +1962,34 @@ struct_field_searcher::update_result (struct value *v, LONGEST boffset)\n \t     space.  */\n \t  if (m_fields.empty () || m_last_boffset != boffset)\n \t    m_fields.push_back ({m_struct_path, v});\n+\t  else\n+\t    {\n+\t    /*Fields can occupy the same space and have the same name (be\n+\t      ambiguous).  This can happen when fields in two different base\n+\t      classes are marked [[no_unique_address]] and have the same name.\n+\t      The C++ standard says that such fields can only occupy the same\n+\t      space if they are of different type, but we don't rely on that in\n+\t      the following code. */\n+\t      bool ambiguous = false, insert = true;\n+\t      for (const found_field &field: m_fields)\n+\t\t{\n+\t\t  if(field.path.back () != m_struct_path.back ())\n+\t\t    {\n+\t\t    /* Same boffset points to members of different classes.\n+\t\t       We have found an ambiguity and should record it.  */\n+\t\t      ambiguous = true;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t    /* We don't need to insert this value again, because a\n+\t\t       non-ambiguous path already leads to it.  */\n+\t\t      insert = false;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (ambiguous && insert)\n+\t\tm_fields.push_back ({m_struct_path, v});\n+\t    }\n \t}\n     }\n }"
    }
  ]
}