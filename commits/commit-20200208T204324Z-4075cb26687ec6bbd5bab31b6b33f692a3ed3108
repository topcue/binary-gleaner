{
  "sha": "4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDA3NWNiMjY2ODdlYzZiYmQ1YmFiMzFiNmIzM2Y2OTJhM2VkMzEwOA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:43:24Z"
    },
    "message": "Unify read_initial_length implementations\n\nThere are two implementations of read_initial_length in gdb.  This\nmerges them and moves the resulting function to leb.c.\n\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.c (read_initial_length): Move to leb.c.\n\t* dwarf2/leb.h (read_initial_length): Declare.\n\t* dwarf2/leb.c (read_initial_length): Move from read.c.  Add\n\thandle_nonstd parameter.\n\t* dwarf2/frame.c (read_initial_length): Remove.\n\t(decode_frame_entry_1): Update.\n\nChange-Id: I34d37bad0f8a584bfa781432cba25e05e1bd5750",
    "tree": {
      "sha": "5c02edc5438cc17f80cd73c0bff7c626e2567307",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5c02edc5438cc17f80cd73c0bff7c626e2567307"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "09ba997f323198495bcf6884dd402fa5b9cc8978",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/09ba997f323198495bcf6884dd402fa5b9cc8978",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/09ba997f323198495bcf6884dd402fa5b9cc8978"
    }
  ],
  "stats": {
    "total": 161,
    "additions": 78,
    "deletions": 83
  },
  "files": [
    {
      "sha": "b8d744e134cac9a69a237534f4dc9a3a54bee715",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
      "patch": "@@ -1,3 +1,12 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.c (read_initial_length): Move to leb.c.\n+\t* dwarf2/leb.h (read_initial_length): Declare.\n+\t* dwarf2/leb.c (read_initial_length): Move from read.c.  Add\n+\thandle_nonstd parameter.\n+\t* dwarf2/frame.c (read_initial_length): Remove.\n+\t(decode_frame_entry_1): Update.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/loc.c (dwarf2_find_location_expression)"
    },
    {
      "sha": "db8e5cd25f342b3ecb2b2a017327daee3d5cac74",
      "filename": "gdb/dwarf2/frame.c",
      "status": "modified",
      "additions": 1,
      "deletions": 19,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/dwarf2/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/dwarf2/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame.c?ref=4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
      "patch": "@@ -1475,24 +1475,6 @@ const struct objfile_key<dwarf2_fde_table,\n \t\t\t gdb::noop_deleter<dwarf2_fde_table>>\n   dwarf2_frame_objfile_data;\n \n-\n-static ULONGEST\n-read_initial_length (bfd *abfd, const gdb_byte *buf,\n-\t\t     unsigned int *bytes_read_ptr)\n-{\n-  ULONGEST result;\n-\n-  result = bfd_get_32 (abfd, buf);\n-  if (result == 0xffffffff)\n-    {\n-      result = bfd_get_64 (abfd, buf + 4);\n-      *bytes_read_ptr = 12;\n-    }\n-  else\n-    *bytes_read_ptr = 4;\n-\n-  return result;\n-}\n \f\n \n /* Pointer encoding helper functions.  */\n@@ -1744,7 +1726,7 @@ decode_frame_entry_1 (struct comp_unit *unit, const gdb_byte *start,\n   uint64_t uleb128;\n \n   buf = start;\n-  length = read_initial_length (unit->abfd, buf, &bytes_read);\n+  length = read_initial_length (unit->abfd, buf, &bytes_read, false);\n   buf += bytes_read;\n   end = buf + (size_t) length;\n "
    },
    {
      "sha": "ef7314ed2b37952417c3dcc843f3f260abc2b4ad",
      "filename": "gdb/dwarf2/leb.c",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/dwarf2/leb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/dwarf2/leb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/leb.c?ref=4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
      "patch": "@@ -83,3 +83,30 @@ read_signed_leb128 (bfd *abfd, const gdb_byte *buf,\n   *bytes_read_ptr = num_read;\n   return result;\n }\n+\n+/* See leb.h.  */\n+\n+LONGEST\n+read_initial_length (bfd *abfd, const gdb_byte *buf, unsigned int *bytes_read,\n+\t\t     bool handle_nonstd)\n+{\n+  LONGEST length = bfd_get_32 (abfd, buf);\n+\n+  if (length == 0xffffffff)\n+    {\n+      length = bfd_get_64 (abfd, buf + 4);\n+      *bytes_read = 12;\n+    }\n+  else if (handle_nonstd && length == 0)\n+    {\n+      /* Handle the (non-standard) 64-bit DWARF2 format used by IRIX.  */\n+      length = bfd_get_64 (abfd, buf);\n+      *bytes_read = 8;\n+    }\n+  else\n+    {\n+      *bytes_read = 4;\n+    }\n+\n+  return length;\n+}"
    },
    {
      "sha": "29fdffebfecd7be9d7daabe0ad0030efdc8f8304",
      "filename": "gdb/dwarf2/leb.h",
      "status": "modified",
      "additions": 41,
      "deletions": 0,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/dwarf2/leb.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/dwarf2/leb.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/leb.h?ref=4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
      "patch": "@@ -89,4 +89,45 @@ extern LONGEST read_signed_leb128 (bfd *, const gdb_byte *, unsigned int *);\n \n extern ULONGEST read_unsigned_leb128 (bfd *, const gdb_byte *, unsigned int *);\n \n+/* Read the initial length from a section.  The (draft) DWARF 3\n+   specification allows the initial length to take up either 4 bytes\n+   or 12 bytes.  If the first 4 bytes are 0xffffffff, then the next 8\n+   bytes describe the length and all offsets will be 8 bytes in length\n+   instead of 4.\n+\n+   An older, non-standard 64-bit format is also handled by this\n+   function.  The older format in question stores the initial length\n+   as an 8-byte quantity without an escape value.  Lengths greater\n+   than 2^32 aren't very common which means that the initial 4 bytes\n+   is almost always zero.  Since a length value of zero doesn't make\n+   sense for the 32-bit format, this initial zero can be considered to\n+   be an escape value which indicates the presence of the older 64-bit\n+   format.  As written, the code can't detect (old format) lengths\n+   greater than 4GB.  If it becomes necessary to handle lengths\n+   somewhat larger than 4GB, we could allow other small values (such\n+   as the non-sensical values of 1, 2, and 3) to also be used as\n+   escape values indicating the presence of the old format.\n+\n+   The value returned via bytes_read should be used to increment the\n+   relevant pointer after calling read_initial_length().\n+\n+   [ Note:  read_initial_length() and read_offset() are based on the\n+     document entitled \"DWARF Debugging Information Format\", revision\n+     3, draft 8, dated November 19, 2001.  This document was obtained\n+     from:\n+\n+\thttp://reality.sgiweb.org/davea/dwarf3-draft8-011125.pdf\n+\n+     This document is only a draft and is subject to change.  (So beware.)\n+\n+     Details regarding the older, non-standard 64-bit format were\n+     determined empirically by examining 64-bit ELF files produced by\n+     the SGI toolchain on an IRIX 6.5 machine.\n+\n+     - Kevin, July 16, 2002\n+   ] */\n+extern LONGEST read_initial_length (bfd *abfd, const gdb_byte *buf,\n+\t\t\t\t    unsigned int *bytes_read,\n+\t\t\t\t    bool handle_nonstd = true);\n+\n #endif /* GDB_DWARF2_LEB_H */"
    },
    {
      "sha": "4ff2a4ca326d0d86076450517ed225c940ad3e43",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 0,
      "deletions": 64,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4075cb26687ec6bbd5bab31b6b33f692a3ed3108/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=4075cb26687ec6bbd5bab31b6b33f692a3ed3108",
      "patch": "@@ -1277,8 +1277,6 @@ static CORE_ADDR read_addr_index (struct dwarf2_cu *cu, unsigned int addr_index)\n static CORE_ADDR read_address (bfd *, const gdb_byte *ptr, struct dwarf2_cu *,\n \t\t\t       unsigned int *);\n \n-static LONGEST read_initial_length (bfd *, const gdb_byte *, unsigned int *);\n-\n static LONGEST read_checked_initial_length_and_offset\n   (bfd *, const gdb_byte *, const struct comp_unit_head *,\n    unsigned int *, unsigned int *);\n@@ -19016,68 +19014,6 @@ read_address (bfd *abfd, const gdb_byte *buf, struct dwarf2_cu *cu,\n   return retval;\n }\n \n-/* Read the initial length from a section.  The (draft) DWARF 3\n-   specification allows the initial length to take up either 4 bytes\n-   or 12 bytes.  If the first 4 bytes are 0xffffffff, then the next 8\n-   bytes describe the length and all offsets will be 8 bytes in length\n-   instead of 4.\n-\n-   An older, non-standard 64-bit format is also handled by this\n-   function.  The older format in question stores the initial length\n-   as an 8-byte quantity without an escape value.  Lengths greater\n-   than 2^32 aren't very common which means that the initial 4 bytes\n-   is almost always zero.  Since a length value of zero doesn't make\n-   sense for the 32-bit format, this initial zero can be considered to\n-   be an escape value which indicates the presence of the older 64-bit\n-   format.  As written, the code can't detect (old format) lengths\n-   greater than 4GB.  If it becomes necessary to handle lengths\n-   somewhat larger than 4GB, we could allow other small values (such\n-   as the non-sensical values of 1, 2, and 3) to also be used as\n-   escape values indicating the presence of the old format.\n-\n-   The value returned via bytes_read should be used to increment the\n-   relevant pointer after calling read_initial_length().\n-\n-   [ Note:  read_initial_length() and read_offset() are based on the\n-     document entitled \"DWARF Debugging Information Format\", revision\n-     3, draft 8, dated November 19, 2001.  This document was obtained\n-     from:\n-\n-\thttp://reality.sgiweb.org/davea/dwarf3-draft8-011125.pdf\n-\n-     This document is only a draft and is subject to change.  (So beware.)\n-\n-     Details regarding the older, non-standard 64-bit format were\n-     determined empirically by examining 64-bit ELF files produced by\n-     the SGI toolchain on an IRIX 6.5 machine.\n-\n-     - Kevin, July 16, 2002\n-   ] */\n-\n-static LONGEST\n-read_initial_length (bfd *abfd, const gdb_byte *buf, unsigned int *bytes_read)\n-{\n-  LONGEST length = bfd_get_32 (abfd, buf);\n-\n-  if (length == 0xffffffff)\n-    {\n-      length = bfd_get_64 (abfd, buf + 4);\n-      *bytes_read = 12;\n-    }\n-  else if (length == 0)\n-    {\n-      /* Handle the (non-standard) 64-bit DWARF2 format used by IRIX.  */\n-      length = bfd_get_64 (abfd, buf);\n-      *bytes_read = 8;\n-    }\n-  else\n-    {\n-      *bytes_read = 4;\n-    }\n-\n-  return length;\n-}\n-\n /* Cover function for read_initial_length.\n    Returns the length of the object at BUF, and stores the size of the\n    initial length in *BYTES_READ and stores the size that offsets will be in"
    }
  ]
}