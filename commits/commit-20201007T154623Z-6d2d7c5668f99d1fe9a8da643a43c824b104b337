{
  "sha": "6d2d7c5668f99d1fe9a8da643a43c824b104b337",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmQyZDdjNTY2OGY5OWQxZmU5YThkYTY0M2E0M2M4MjRiMTA0YjMzNw==",
  "commit": {
    "author": {
      "name": "Anton Kolesov",
      "email": "Anton.Kolesov@synopsys.com",
      "date": "2016-07-06T17:30:29Z"
    },
    "committer": {
      "name": "Shahab Vahedi",
      "email": "shahab@synopsys.com",
      "date": "2020-10-07T15:46:23Z"
    },
    "message": "gdbserver: Add GNU/Linux support for ARC\n\nThis gdbserver implementation supports ARC ABI v3 and v4 (older ARC ABI\nversions are not supported by other modern GNU tools or Linux itself).\nGdbserver supports inspection of ARC HS registers R30, R58 and R59 - feature\nthat has been added to Linux 4.12.  Whether gdbserver build will actually\nsupport this feature depends on the version of Linux headers used to build\nthe server.\n\nv2 [1]:\n- Use \"this->read_memory ()\" instead of \"the_target->read_memory ()\".\n- Remove the unnecessary \"arch-arc.o:\" target from the \"Makefile.in\".\n- Got rid of \"ntohs()\" function and added lots of comments about\n  endianness.\n- Clarify why \"pc\" value is read from and saved to different fields\n  in user regs struct.\n- In function \"is_reg_name_available_p()\", use a range-based iterator\n  to loop over the registers.\n- Removed mentioning of issue number that was not related to sourceware.\n- A few typo's fixed.\n\n[1] Remarks\nhttps://sourceware.org/pipermail/gdb-patches/2020-September/171911.html\nhttps://sourceware.org/pipermail/gdb-patches/2020-September/171919.html\n\ngdbserver/ChangeLog:\n\n\t* configure.srv: Support ARC architecture.\n\t* Makefile.in: Add linux-arc-low.cc and arch/arc.o.\n\t* linux-arc-low.cc: New file.",
    "tree": {
      "sha": "c4679196ec31a8674c6ca02ae217daca086c1b0e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c4679196ec31a8674c6ca02ae217daca086c1b0e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6d2d7c5668f99d1fe9a8da643a43c824b104b337",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d2d7c5668f99d1fe9a8da643a43c824b104b337",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6d2d7c5668f99d1fe9a8da643a43c824b104b337",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d2d7c5668f99d1fe9a8da643a43c824b104b337/comments",
  "author": {
    "login": "anthony-kolesov",
    "id": 602123,
    "node_id": "MDQ6VXNlcjYwMjEyMw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/602123?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/anthony-kolesov",
    "html_url": "https://github.com/anthony-kolesov",
    "followers_url": "https://api.github.com/users/anthony-kolesov/followers",
    "following_url": "https://api.github.com/users/anthony-kolesov/following{/other_user}",
    "gists_url": "https://api.github.com/users/anthony-kolesov/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/anthony-kolesov/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/anthony-kolesov/subscriptions",
    "organizations_url": "https://api.github.com/users/anthony-kolesov/orgs",
    "repos_url": "https://api.github.com/users/anthony-kolesov/repos",
    "events_url": "https://api.github.com/users/anthony-kolesov/events{/privacy}",
    "received_events_url": "https://api.github.com/users/anthony-kolesov/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": null,
  "parents": [
    {
      "sha": "e4bd363f994cf12017cb17dddeb2bc35698ee349",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e4bd363f994cf12017cb17dddeb2bc35698ee349",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e4bd363f994cf12017cb17dddeb2bc35698ee349"
    }
  ],
  "stats": {
    "total": 437,
    "additions": 437,
    "deletions": 0
  },
  "files": [
    {
      "sha": "ec9d6b040ab81261564aac243b804d0caeea02a5",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d2d7c5668f99d1fe9a8da643a43c824b104b337/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d2d7c5668f99d1fe9a8da643a43c824b104b337/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=6d2d7c5668f99d1fe9a8da643a43c824b104b337",
      "patch": "@@ -1,3 +1,9 @@\n+2020-10-06  Shahab Vahedi  <shahab@synopsys.com>\n+\n+\t* configure.srv: Support ARC architecture.\n+\t* Makefile.in: Add linux-arc-low.cc and arch/arc.o.\n+\t* linux-arc-low.cc: New file.\n+\n 2020-10-07  Kamil Rytarowski  <n54@gmx.com>\n \n \t* netbsd-low.cc (get_dynamic, get_r_debug, read_one_ptr)"
    },
    {
      "sha": "d77a1d0ab2c4228f3704cd0e419c3e20754b1481",
      "filename": "gdbserver/Makefile.in",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d2d7c5668f99d1fe9a8da643a43c824b104b337/gdbserver/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d2d7c5668f99d1fe9a8da643a43c824b104b337/gdbserver/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/Makefile.in?ref=6d2d7c5668f99d1fe9a8da643a43c824b104b337",
      "patch": "@@ -179,6 +179,7 @@ SFILES = \\\n \t$(srcdir)/i387-fp.cc \\\n \t$(srcdir)/inferiors.cc \\\n \t$(srcdir)/linux-aarch64-low.cc \\\n+\t$(srcdir)/linux-arc-low.cc \\\n \t$(srcdir)/linux-arm-low.cc \\\n \t$(srcdir)/linux-ia64-low.cc \\\n \t$(srcdir)/linux-low.cc \\\n@@ -210,6 +211,7 @@ SFILES = \\\n \t$(srcdir)/win32-low.cc \\\n \t$(srcdir)/x86-low.cc \\\n \t$(srcdir)/../gdb/alloc.c \\\n+\t$(srcdir)/../gdb/arch/arc.c \\\n \t$(srcdir)/../gdb/arch/arm.c \\\n \t$(srcdir)/../gdb/arch/arm-get-next-pcs.c \\\n \t$(srcdir)/../gdb/arch/arm-linux.c \\"
    },
    {
      "sha": "833ad27c4c4d17e0346060a53cdbf935f892aa87",
      "filename": "gdbserver/configure.srv",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d2d7c5668f99d1fe9a8da643a43c824b104b337/gdbserver/configure.srv",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d2d7c5668f99d1fe9a8da643a43c824b104b337/gdbserver/configure.srv",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure.srv?ref=6d2d7c5668f99d1fe9a8da643a43c824b104b337",
      "patch": "@@ -67,6 +67,17 @@ case \"${gdbserver_host}\" in\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} nat/netbsd-nat.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/aarch64-insn.o arch/aarch64.o\"\n \t\t\t;;\n+  arc*-*-linux*)\n+\t\t\tsrv_regobj=\"\"\n+\t\t\tsrv_tgtobj=\"linux-arc-low.o arch/arc.o $srv_linux_obj\"\n+\t\t\tsrv_xmlfiles=\"arc/v1-core.xml\"\n+\t\t\tsrv_xmlfiles=\"${srv_xmlfiles} arc/v1-aux.xml\"\n+\t\t\tsrv_xmlfiles=\"${srv_xmlfiles} arc/v2-core.xml\"\n+\t\t\tsrv_xmlfiles=\"${srv_xmlfiles} arc/v2-aux.xml\"\n+\t\t\tsrv_linux_regsets=yes\n+\t\t\tsrv_linux_usrregs=yes\n+\t\t\tsrv_linux_thread_db=yes\n+\t\t\t;;\n   arm*-*-linux*)\tsrv_tgtobj=\"$srv_linux_obj linux-arm-low.o\"\n \t\t\tsrv_tgtobj=\"$srv_tgtobj linux-arm-tdesc.o\"\n \t\t\tsrv_tgtobj=\"$srv_tgtobj linux-aarch32-low.o\""
    },
    {
      "sha": "1f370ef796437cc2f2b8f62395118f54dc2eccb4",
      "filename": "gdbserver/linux-arc-low.cc",
      "status": "added",
      "additions": 418,
      "deletions": 0,
      "changes": 418,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d2d7c5668f99d1fe9a8da643a43c824b104b337/gdbserver/linux-arc-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d2d7c5668f99d1fe9a8da643a43c824b104b337/gdbserver/linux-arc-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-arc-low.cc?ref=6d2d7c5668f99d1fe9a8da643a43c824b104b337",
      "patch": "@@ -0,0 +1,418 @@\n+/* Target dependent code for the remote server for GNU/Linux ARC.\n+\n+   Copyright 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"server.h\"\n+#include \"regdef.h\"\n+#include \"linux-low.h\"\n+#include \"tdesc.h\"\n+#include \"arch/arc.h\"\n+\n+#include <linux/elf.h>\n+#include <arpa/inet.h>\n+\n+/* Linux starting with 4.12 supports NT_ARC_V2 note type, which adds R30,\n+   R58 and R59 registers.  */\n+#ifdef NT_ARC_V2\n+#define ARC_HAS_V2_REGSET\n+#endif\n+\n+/* The encoding of the instruction \"TRAP_S 1\" (endianness agnostic).  */\n+#define TRAP_S_1_OPCODE\t0x783e\n+#define TRAP_S_1_SIZE\t2\n+\n+/* Using a mere \"uint16_t arc_linux_traps_s = TRAP_S_1_OPCODE\" would\n+   work as well, because the endianness will end up correctly when\n+   the code is compiled for the same endianness as the target (see\n+   the notes for \"low_breakpoint_at\" in this file).  However, this\n+   illustrates how the __BIG_ENDIAN__ macro can be used to make\n+   easy-to-understand codes.  */\n+#if defined(__BIG_ENDIAN__)\n+/* 0x78, 0x3e.  */\n+static gdb_byte arc_linux_trap_s[TRAP_S_1_SIZE]\n+\t= {TRAP_S_1_OPCODE >> 8, TRAP_S_1_OPCODE & 0xFF};\n+#else\n+/* 0x3e, 0x78.  */\n+static gdb_byte arc_linux_trap_s[TRAP_S_1_SIZE]\n+\t= {TRAP_S_1_OPCODE && 0xFF, TRAP_S_1_OPCODE >> 8};\n+#endif\n+\n+/* Linux target op definitions for the ARC architecture.\n+   Note for future: in case of adding the protected method low_get_next_pcs(),\n+   the public method supports_software_single_step() should be added to return\n+   \"true\".  */\n+\n+class arc_target : public linux_process_target\n+{\n+public:\n+\n+  const regs_info *get_regs_info () override;\n+\n+  const gdb_byte *sw_breakpoint_from_kind (int kind, int *size) override;\n+\n+protected:\n+\n+  void low_arch_setup () override;\n+\n+  bool low_cannot_fetch_register (int regno) override;\n+\n+  bool low_cannot_store_register (int regno) override;\n+\n+  bool low_supports_breakpoints () override;\n+\n+  CORE_ADDR low_get_pc (regcache *regcache) override;\n+\n+  void low_set_pc (regcache *regcache, CORE_ADDR newpc) override;\n+\n+  bool low_breakpoint_at (CORE_ADDR where) override;\n+};\n+\n+/* The singleton target ops object.  */\n+\n+static arc_target the_arc_target;\n+\n+bool\n+arc_target::low_supports_breakpoints ()\n+{\n+  return true;\n+}\n+\n+CORE_ADDR\n+arc_target::low_get_pc (regcache *regcache)\n+{\n+  return linux_get_pc_32bit (regcache);\n+}\n+\n+void\n+arc_target::low_set_pc (regcache *regcache, CORE_ADDR pc)\n+{\n+  linux_set_pc_32bit (regcache, pc);\n+}\n+\n+static const struct target_desc *\n+arc_linux_read_description (void)\n+{\n+#ifdef __ARC700__\n+  arc_arch_features features (4, ARC_ISA_ARCV1);\n+#else\n+  arc_arch_features features (4, ARC_ISA_ARCV2);\n+#endif\n+  struct target_desc *tdesc = arc_create_target_description (features);\n+\n+  static const char *expedite_regs[] = { \"sp\", \"status32\", nullptr };\n+  init_target_desc (tdesc, expedite_regs);\n+\n+  return tdesc;\n+}\n+\n+void\n+arc_target::low_arch_setup ()\n+{\n+  current_process ()->tdesc = arc_linux_read_description ();\n+}\n+\n+bool\n+arc_target::low_cannot_fetch_register (int regno)\n+{\n+  return (regno >= current_process ()->tdesc->reg_defs.size ());\n+}\n+\n+bool\n+arc_target::low_cannot_store_register (int regno)\n+{\n+  return (regno >= current_process ()->tdesc->reg_defs.size ());\n+}\n+\n+/* This works for both endianness.  Below you see an illustration of how\n+   the \"trap_s 1\" instruction encoded for both endianness in the memory\n+   will end up as the TRAP_S_1_OPCODE constant:\n+\n+   BE: 0x78 0x3e --> at INSN addr: 0x78 0x3e --> INSN = 0x783e\n+   LE: 0x3e 0x78 --> at INSN addr: 0x3e 0x78 --> INSN = 0x783e\n+\n+   One can employ \"memcmp()\" for comparing the arrays too.  */\n+\n+bool\n+arc_target::low_breakpoint_at (CORE_ADDR where)\n+{\n+  uint16_t insn;\n+\n+  /* \"the_target\" global variable is the current object at hand.  */\n+  this->read_memory (where, (gdb_byte *) &insn, TRAP_S_1_SIZE);\n+  return (insn == TRAP_S_1_OPCODE);\n+}\n+\n+/* PTRACE_GETREGSET/NT_PRSTATUS and PTRACE_SETREGSET/NT_PRSTATUS work with\n+   regsets in a struct, \"user_regs_struct\", defined in the\n+   linux/arch/arc/include/uapi/asm/ptrace.h header.  This code supports\n+   ARC Linux ABI v3 and v4.  */\n+\n+/* Populate a ptrace NT_PRSTATUS regset from a regcache.\n+\n+   This appears to be a unique approach to populating the buffer, but\n+   being name, rather than offset based, it is robust to future API\n+   changes, as there is no need to create a regmap of registers in the\n+   user_regs_struct.  */\n+\n+static void\n+arc_fill_gregset (struct regcache *regcache, void *buf)\n+{\n+  struct user_regs_struct *regbuf = (struct user_regs_struct *) buf;\n+\n+  /* Core registers.  */\n+  collect_register_by_name (regcache, \"r0\", &(regbuf->scratch.r0));\n+  collect_register_by_name (regcache, \"r1\", &(regbuf->scratch.r1));\n+  collect_register_by_name (regcache, \"r2\", &(regbuf->scratch.r2));\n+  collect_register_by_name (regcache, \"r3\", &(regbuf->scratch.r3));\n+  collect_register_by_name (regcache, \"r4\", &(regbuf->scratch.r4));\n+  collect_register_by_name (regcache, \"r5\", &(regbuf->scratch.r5));\n+  collect_register_by_name (regcache, \"r6\", &(regbuf->scratch.r6));\n+  collect_register_by_name (regcache, \"r7\", &(regbuf->scratch.r7));\n+  collect_register_by_name (regcache, \"r8\", &(regbuf->scratch.r8));\n+  collect_register_by_name (regcache, \"r9\", &(regbuf->scratch.r9));\n+  collect_register_by_name (regcache, \"r10\", &(regbuf->scratch.r10));\n+  collect_register_by_name (regcache, \"r11\", &(regbuf->scratch.r11));\n+  collect_register_by_name (regcache, \"r12\", &(regbuf->scratch.r12));\n+  collect_register_by_name (regcache, \"r13\", &(regbuf->callee.r13));\n+  collect_register_by_name (regcache, \"r14\", &(regbuf->callee.r14));\n+  collect_register_by_name (regcache, \"r15\", &(regbuf->callee.r15));\n+  collect_register_by_name (regcache, \"r16\", &(regbuf->callee.r16));\n+  collect_register_by_name (regcache, \"r17\", &(regbuf->callee.r17));\n+  collect_register_by_name (regcache, \"r18\", &(regbuf->callee.r18));\n+  collect_register_by_name (regcache, \"r19\", &(regbuf->callee.r19));\n+  collect_register_by_name (regcache, \"r20\", &(regbuf->callee.r20));\n+  collect_register_by_name (regcache, \"r21\", &(regbuf->callee.r21));\n+  collect_register_by_name (regcache, \"r22\", &(regbuf->callee.r22));\n+  collect_register_by_name (regcache, \"r23\", &(regbuf->callee.r23));\n+  collect_register_by_name (regcache, \"r24\", &(regbuf->callee.r24));\n+  collect_register_by_name (regcache, \"r25\", &(regbuf->callee.r25));\n+  collect_register_by_name (regcache, \"gp\", &(regbuf->scratch.gp));\n+  collect_register_by_name (regcache, \"fp\", &(regbuf->scratch.fp));\n+  collect_register_by_name (regcache, \"sp\", &(regbuf->scratch.sp));\n+  collect_register_by_name (regcache, \"blink\", &(regbuf->scratch.blink));\n+\n+  /* Loop registers.  */\n+  collect_register_by_name (regcache, \"lp_count\", &(regbuf->scratch.lp_count));\n+  collect_register_by_name (regcache, \"lp_start\", &(regbuf->scratch.lp_start));\n+  collect_register_by_name (regcache, \"lp_end\", &(regbuf->scratch.lp_end));\n+\n+  /* The current \"pc\" value must be written to \"eret\" (exception return\n+     address) register, because that is the address that the kernel code\n+     will jump back to after a breakpoint exception has been raised.\n+     The \"pc_stop\" value is ignored by the genregs_set() in\n+     linux/arch/arc/kernel/ptrace.c.  */\n+  collect_register_by_name (regcache, \"pc\", &(regbuf->scratch.ret));\n+\n+  /* Currently ARC Linux ptrace doesn't allow writes to status32 because\n+     some of its bits are kernel mode-only and shoudn't be writable from\n+     user-space.  Writing status32 from debugger could be useful, though,\n+     so ability to write non-priviliged bits will be added to kernel\n+     sooner or later.  */\n+\n+  /* BTA.  */\n+  collect_register_by_name (regcache, \"bta\", &(regbuf->scratch.bta));\n+}\n+\n+/* Populate a regcache from a ptrace NT_PRSTATUS regset.  */\n+\n+static void\n+arc_store_gregset (struct regcache *regcache, const void *buf)\n+{\n+  const struct user_regs_struct *regbuf = (const struct user_regs_struct *) buf;\n+\n+  /* Core registers.  */\n+  supply_register_by_name (regcache, \"r0\", &(regbuf->scratch.r0));\n+  supply_register_by_name (regcache, \"r1\", &(regbuf->scratch.r1));\n+  supply_register_by_name (regcache, \"r2\", &(regbuf->scratch.r2));\n+  supply_register_by_name (regcache, \"r3\", &(regbuf->scratch.r3));\n+  supply_register_by_name (regcache, \"r4\", &(regbuf->scratch.r4));\n+  supply_register_by_name (regcache, \"r5\", &(regbuf->scratch.r5));\n+  supply_register_by_name (regcache, \"r6\", &(regbuf->scratch.r6));\n+  supply_register_by_name (regcache, \"r7\", &(regbuf->scratch.r7));\n+  supply_register_by_name (regcache, \"r8\", &(regbuf->scratch.r8));\n+  supply_register_by_name (regcache, \"r9\", &(regbuf->scratch.r9));\n+  supply_register_by_name (regcache, \"r10\", &(regbuf->scratch.r10));\n+  supply_register_by_name (regcache, \"r11\", &(regbuf->scratch.r11));\n+  supply_register_by_name (regcache, \"r12\", &(regbuf->scratch.r12));\n+  supply_register_by_name (regcache, \"r13\", &(regbuf->callee.r13));\n+  supply_register_by_name (regcache, \"r14\", &(regbuf->callee.r14));\n+  supply_register_by_name (regcache, \"r15\", &(regbuf->callee.r15));\n+  supply_register_by_name (regcache, \"r16\", &(regbuf->callee.r16));\n+  supply_register_by_name (regcache, \"r17\", &(regbuf->callee.r17));\n+  supply_register_by_name (regcache, \"r18\", &(regbuf->callee.r18));\n+  supply_register_by_name (regcache, \"r19\", &(regbuf->callee.r19));\n+  supply_register_by_name (regcache, \"r20\", &(regbuf->callee.r20));\n+  supply_register_by_name (regcache, \"r21\", &(regbuf->callee.r21));\n+  supply_register_by_name (regcache, \"r22\", &(regbuf->callee.r22));\n+  supply_register_by_name (regcache, \"r23\", &(regbuf->callee.r23));\n+  supply_register_by_name (regcache, \"r24\", &(regbuf->callee.r24));\n+  supply_register_by_name (regcache, \"r25\", &(regbuf->callee.r25));\n+  supply_register_by_name (regcache, \"gp\", &(regbuf->scratch.gp));\n+  supply_register_by_name (regcache, \"fp\", &(regbuf->scratch.fp));\n+  supply_register_by_name (regcache, \"sp\", &(regbuf->scratch.sp));\n+  supply_register_by_name (regcache, \"blink\", &(regbuf->scratch.blink));\n+\n+  /* Loop registers.  */\n+  supply_register_by_name (regcache, \"lp_count\", &(regbuf->scratch.lp_count));\n+  supply_register_by_name (regcache, \"lp_start\", &(regbuf->scratch.lp_start));\n+  supply_register_by_name (regcache, \"lp_end\", &(regbuf->scratch.lp_end));\n+\n+  /* The genregs_get() in linux/arch/arc/kernel/ptrace.c populates the\n+     pseudo register \"stop_pc\" with the \"efa\" (exception fault address)\n+     register.  This was deemed necessary, because the breakpoint\n+     instruction, \"trap_s 1\", is a committing one; i.e. the \"eret\"\n+     (exception return address) register will be pointing to the next\n+     instruction, while \"efa\" points to the address that raised the\n+     breakpoint.  */\n+  supply_register_by_name (regcache, \"pc\", &(regbuf->stop_pc));\n+  unsigned long pcl = regbuf->stop_pc & ~3L;\n+  supply_register_by_name (regcache, \"pcl\", &pcl);\n+\n+  /* Other auxilliary registers.  */\n+  supply_register_by_name (regcache, \"status32\", &(regbuf->scratch.status32));\n+\n+  /* BTA.  */\n+  supply_register_by_name (regcache, \"bta\", &(regbuf->scratch.bta));\n+}\n+\n+#ifdef ARC_HAS_V2_REGSET\n+\n+/* Look through a regcache's TDESC for a register named NAME.\n+   If found, return true; false, otherwise.  */\n+\n+static bool\n+is_reg_name_available_p (const struct target_desc *tdesc,\n+\t\t\t const char *name)\n+{\n+  for (const gdb::reg &reg : tdesc->reg_defs)\n+    if (strcmp (name, reg.name) == 0)\n+      return true;\n+  return false;\n+}\n+\n+/* Copy registers from regcache to user_regs_arcv2.  */\n+\n+static void\n+arc_fill_v2_regset (struct regcache *regcache, void *buf)\n+{\n+  struct user_regs_arcv2 *regbuf = (struct user_regs_arcv2 *) buf;\n+\n+  if (is_reg_name_available_p (regcache->tdesc, \"r30\"))\n+    collect_register_by_name (regcache, \"r30\", &(regbuf->r30));\n+\n+  if (is_reg_name_available_p (regcache->tdesc, \"r58\"))\n+    collect_register_by_name (regcache, \"r58\", &(regbuf->r58));\n+\n+  if (is_reg_name_available_p (regcache->tdesc, \"r59\"))\n+    collect_register_by_name (regcache, \"r59\", &(regbuf->r59));\n+}\n+\n+/* Copy registers from user_regs_arcv2 to regcache.  */\n+\n+static void\n+arc_store_v2_regset (struct regcache *regcache, const void *buf)\n+{\n+  struct user_regs_arcv2 *regbuf = (struct user_regs_arcv2 *) buf;\n+\n+  if (is_reg_name_available_p (regcache->tdesc, \"r30\"))\n+    supply_register_by_name (regcache, \"r30\", &(regbuf->r30));\n+\n+  if (is_reg_name_available_p (regcache->tdesc, \"r58\"))\n+    supply_register_by_name (regcache, \"r58\", &(regbuf->r58));\n+\n+  if (is_reg_name_available_p (regcache->tdesc, \"r59\"))\n+    supply_register_by_name (regcache, \"r59\", &(regbuf->r59));\n+}\n+\n+#endif\n+\n+/* Fetch the thread-local storage pointer for libthread_db.  Note that\n+   this function is not called from GDB, but is called from libthread_db.\n+\n+   This is the same function as for other architectures, for example in\n+   linux-arm-low.c.  */\n+\n+ps_err_e\n+ps_get_thread_area (struct ps_prochandle *ph, lwpid_t lwpid,\n+\t\t    int idx, void **base)\n+{\n+  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid, nullptr, base) != 0)\n+    return PS_ERR;\n+\n+  /* IDX is the bias from the thread pointer to the beginning of the\n+     thread descriptor.  It has to be subtracted due to implementation\n+     quirks in libthread_db.  */\n+  *base = (void *) ((char *) *base - idx);\n+\n+  return PS_OK;\n+}\n+\n+static struct regset_info arc_regsets[] =\n+{\n+  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_PRSTATUS,\n+    sizeof (struct user_regs_struct), GENERAL_REGS,\n+    arc_fill_gregset, arc_store_gregset\n+  },\n+#ifdef ARC_HAS_V2_REGSET\n+  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_ARC_V2,\n+    sizeof (struct user_regs_arcv2), GENERAL_REGS,\n+    arc_fill_v2_regset, arc_store_v2_regset\n+  },\n+#endif\n+  NULL_REGSET\n+};\n+\n+static struct regsets_info arc_regsets_info =\n+{\n+  arc_regsets,\t/* regsets */\n+  0,\t\t/* num_regsets */\n+  nullptr,\t/* disabled regsets */\n+};\n+\n+static struct regs_info arc_regs_info =\n+{\n+  nullptr,\t/* regset_bitmap */\n+  nullptr,\t/* usrregs */\n+  &arc_regsets_info\n+};\n+\n+const regs_info *\n+arc_target::get_regs_info ()\n+{\n+  return &arc_regs_info;\n+}\n+\n+/* One of the methods necessary for Z0 packet support.  */\n+\n+const gdb_byte *\n+arc_target::sw_breakpoint_from_kind (int kind, int *size)\n+{\n+  gdb_assert (kind == TRAP_S_1_SIZE);\n+  *size = kind;\n+  return arc_linux_trap_s;\n+}\n+\n+/* The linux target ops object.  */\n+\n+linux_process_target *the_linux_target = &the_arc_target;\n+\n+void\n+initialize_low_arch (void)\n+{\n+  initialize_regsets_info (&arc_regsets_info);\n+}"
    }
  ]
}