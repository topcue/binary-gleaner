{
  "sha": "9402cc593f4aa54677203efa9a92c4f28d3033eb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTQwMmNjNTkzZjRhYTU0Njc3MjAzZWZhOWE5MmM0ZjI4ZDMwMzNlYg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-24T10:30:17Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:07:55Z"
    },
    "message": "libctf: mmappable archives\n\nIf you need to store a large number of CTF containers somewhere, this\nprovides a dedicated facility for doing so: an mmappable archive format\nlike a very simple tar or ar without all the system-dependent format\nhorrors or need for heavy file copying, with built-in compression of\nfiles above a particular size threshold.\n\nlibctf automatically mmap()s uncompressed elements of these archives, or\nuncompresses them, as needed.  (If the platform does not support mmap(),\ncopying into dynamically-allocated buffers is used.)\n\nArchive iteration operations are partitioned into raw and non-raw\nforms. Raw operations pass thhe raw archive contents to the callback:\nnon-raw forms open each member with ctf_bufopen() and pass the resulting\nctf_file_t to the iterator instead.  This lets you manipulate the raw\ndata in the archive, or the contents interpreted as a CTF file, as\nneeded.\n\nIt is not yet known whether we will store CTF archives in a linked ELF\nobject in one of these (akin to debugdata) or whether they'll get one\nsection per TU plus one parent container for types shared between them.\n(In the case of ELF objects with very large numbers of TUs, an archive\nof all of them would seem preferable, so we might just use an archive,\nand add lzma support so you can assume that .gnu_debugdata and .ctf are\ncompressed using the same algorithm if both are present.)\n\nTo make usage easier, the ctf_archive_t is not the on-disk\nrepresentation but an abstraction over both ctf_file_t's and archives of\nmany ctf_file_t's: users see both CTF archives and raw CTF files as\nctf_archive_t's upon opening, the only difference being that a raw CTF\nfile has only a single \"archive member\", named \".ctf\" (the default if a\nnull pointer is passed in as the name).  The next commit will make use\nof this facility, in addition to providing the public interface to\nactually open archives.  (In the future, it should be possible to have\nall CTF sections in an ELF file appear as an \"archive\" in the same\nfashion.)\n\nThis machinery is also used to allow library-internal creators of\nctf_archive_t's (such as the next commit) to stash away an ELF string\nand symbol table, so that all opens of members in a given archive will\nuse them.  This lets CTF archives exploit the ELF string and symbol\ntable just like raw CTF files can.\n\n(All this leads to somewhat confusing type naming.  The ctf_archive_t is\na typedef for the opaque internal type, struct ctf_archive_internal: the\nnon-internal \"struct ctf_archive\" is the on-disk structure meant for\nother libraries manipulating CTF files.  It is probably clearest to use\nthe struct name for struct ctf_archive_internal inside the program, and\nthe typedef names outside.)\n\nlibctf/\n\t* ctf-archive.c: New.\n\t* ctf-impl.h (ctf_archive_internal): New type.\n\t(ctf_arc_open_internal): New declaration.\n\t(ctf_arc_bufopen): Likewise.\n\t(ctf_arc_close_internal): Likewise.\ninclude/\n\t* ctf.h (CTFA_MAGIC): New.\n\t(struct ctf_archive): New.\n\t(struct ctf_archive_modent): Likewise.\n\t* ctf-api.h (ctf_archive_member_f): New.\n\t(ctf_archive_raw_member_f): Likewise.\n\t(ctf_arc_write): Likewise.\n\t(ctf_arc_close): Likewise.\n\t(ctf_arc_open_by_name): Likewise.\n\t(ctf_archive_iter): Likewise.\n\t(ctf_archive_raw_iter): Likewise.\n\t(ctf_get_arc): Likewise.",
    "tree": {
      "sha": "836715049596d51ddee9d5bf8da82a54c1b4eb06",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/836715049596d51ddee9d5bf8da82a54c1b4eb06"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9402cc593f4aa54677203efa9a92c4f28d3033eb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9402cc593f4aa54677203efa9a92c4f28d3033eb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9402cc593f4aa54677203efa9a92c4f28d3033eb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9402cc593f4aa54677203efa9a92c4f28d3033eb/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "72f3392127e1892cb203a98092b4ae32485365fe",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72f3392127e1892cb203a98092b4ae32485365fe",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/72f3392127e1892cb203a98092b4ae32485365fe"
    }
  ],
  "stats": {
    "total": 877,
    "additions": 877,
    "deletions": 0
  },
  "files": [
    {
      "sha": "fb7bd884aa4cddb318df61167cb74cd3414f3481",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9402cc593f4aa54677203efa9a92c4f28d3033eb/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9402cc593f4aa54677203efa9a92c4f28d3033eb/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "patch": "@@ -1,3 +1,17 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf.h (CTFA_MAGIC): New.\n+\t(struct ctf_archive): New.\n+\t(struct ctf_archive_modent): Likewise.\n+\t* ctf-api.h (ctf_archive_member_f): New.\n+\t(ctf_archive_raw_member_f): Likewise.\n+\t(ctf_arc_write): Likewise.\n+\t(ctf_arc_close): Likewise.\n+\t(ctf_arc_open_by_name): Likewise.\n+\t(ctf_archive_iter): Likewise.\n+\t(ctf_archive_raw_iter): Likewise.\n+\t(ctf_get_arc): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_file_close): New declaration."
    },
    {
      "sha": "4cac635e57e7c7f7ea220d19de6f52572e275094",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9402cc593f4aa54677203efa9a92c4f28d3033eb/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9402cc593f4aa54677203efa9a92c4f28d3033eb/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "patch": "@@ -198,13 +198,35 @@ enum\n #define\tCTF_ADD_NONROOT\t0\t/* Type only visible in nested scope.  */\n #define\tCTF_ADD_ROOT\t1\t/* Type visible at top-level scope.  */\n \n+/* These typedefs are used to define the signature for callback functions\n+   that can be used with the iteration and visit functions below.  */\n+\n+typedef int ctf_archive_member_f (ctf_file_t *fp, const char *name, void *arg);\n+typedef int ctf_archive_raw_member_f (const char *name, const void *content,\n+\t\t\t\t      size_t len, void *arg);\n+\n extern ctf_sect_t ctf_getdatasect (const ctf_file_t *);\n+extern ctf_archive_t *ctf_get_arc (const ctf_file_t *);\n+extern void ctf_arc_close (ctf_archive_t *);\n+extern ctf_file_t *ctf_arc_open_by_name (const ctf_archive_t *,\n+\t\t\t\t\t const char *, int *);\n+extern ctf_file_t *ctf_arc_open_by_name_sections (const ctf_archive_t *,\n+\t\t\t\t\t\t  const ctf_sect_t *,\n+\t\t\t\t\t\t  const ctf_sect_t *,\n+\t\t\t\t\t\t  const char *, int *);\n+\n+/* The next functions return or close real CTF files, or write out CTF archives,\n+   not opaque containers around either.  */\n+\n extern ctf_file_t *ctf_simple_open (const char *, size_t, const char *, size_t,\n \t\t\t\t   size_t, const char *, size_t, int *);\n extern ctf_file_t *ctf_bufopen (const ctf_sect_t *, const ctf_sect_t *,\n \t\t\t\tconst ctf_sect_t *, int *);\n extern void ctf_file_close (ctf_file_t *);\n \n+extern int ctf_arc_write (const char *, ctf_file_t **, size_t,\n+\t\t\t  const char **, size_t);\n+\n extern ctf_file_t *ctf_parent_file (ctf_file_t *);\n extern const char *ctf_parent_name (ctf_file_t *);\n extern void ctf_parent_name_set (ctf_file_t *, const char *);\n@@ -218,6 +240,14 @@ extern void *ctf_getspecific (ctf_file_t *);\n \n extern int ctf_errno (ctf_file_t *);\n extern const char *ctf_errmsg (int);\n+extern int ctf_archive_iter (const ctf_archive_t *, ctf_archive_member_f *,\n+\t\t\t     void *);\n+/* This function alone does not currently operate on CTF files masquerading\n+   as archives, and returns -EINVAL: the raw data is no longer available.  It is\n+   expected to be used only by archiving tools, in any case, which have no need\n+   to deal with non-archives at all.  */\n+extern int ctf_archive_raw_iter (const ctf_archive_t *,\n+\t\t\t\t ctf_archive_raw_member_f *, void *);\n extern ctf_id_t ctf_add_array (ctf_file_t *, uint32_t,\n \t\t\t       const ctf_arinfo_t *);\n extern ctf_id_t ctf_add_const (ctf_file_t *, uint32_t, ctf_id_t);"
    },
    {
      "sha": "2c3384fe84afab601b5ad8f250a5da3a75b0bcc1",
      "filename": "include/ctf.h",
      "status": "modified",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9402cc593f4aa54677203efa9a92c4f28d3033eb/include/ctf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9402cc593f4aa54677203efa9a92c4f28d3033eb/include/ctf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf.h?ref=9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "patch": "@@ -510,6 +510,53 @@ typedef struct ctf_enum\n   int cte_value;\t\t/* Value associated with this name.  */\n } ctf_enum_t;\n \n+/* The ctf_archive is a collection of ctf_file_t's stored together. The format\n+   is suitable for mmap()ing: this control structure merely describes the\n+   mmap()ed archive (and overlaps the first few bytes of it), hence the\n+   greater care taken with integral types.  All CTF files in an archive\n+   must have the same data model.  (This is not validated.)\n+\n+   All integers in this structure are stored in little-endian byte order.\n+\n+   The code relies on the fact that everything in this header is a uint64_t\n+   and thus the header needs no padding (in particular, that no padding is\n+   needed between ctfa_ctfs and the unnamed ctfa_archive_modent array\n+   that follows it).\n+\n+   This is *not* the same as the data structure returned by the ctf_arc_*()\n+   functions:  this is the low-level on-disk representation.  */\n+\n+#define CTFA_MAGIC 0x8b47f2a4d7623eeb\t/* Random.  */\n+struct ctf_archive\n+{\n+  /* Magic number.  (In loaded files, overwritten with the file size\n+     so ctf_arc_close() knows how much to munmap()).  */\n+  uint64_t ctfa_magic;\n+\n+  /* CTF data model.  */\n+  uint64_t ctfa_model;\n+\n+  /* Number of CTF files in the archive.  */\n+  uint64_t ctfa_nfiles;\n+\n+  /* Offset of the name table.  */\n+  uint64_t ctfa_names;\n+\n+  /* Offset of the CTF table.  Each element starts with a size (a uint64_t\n+     in network byte order) then a ctf_file_t of that size.  */\n+  uint64_t ctfa_ctfs;\n+};\n+\n+/* An array of ctfa_nnamed of this structure lies at\n+   ctf_archive[ctf_archive->ctfa_modents] and gives the ctfa_ctfs or\n+   ctfa_names-relative offsets of each name or ctf_file_t.  */\n+\n+typedef struct ctf_archive_modent\n+{\n+  uint64_t name_offset;\n+  uint64_t ctf_offset;\n+} ctf_archive_modent_t;\n+\n #ifdef\t__cplusplus\n }\n #endif"
    },
    {
      "sha": "aa3fb3b8224e9370390149f930361932990197a7",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9402cc593f4aa54677203efa9a92c4f28d3033eb/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9402cc593f4aa54677203efa9a92c4f28d3033eb/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "patch": "@@ -1,3 +1,11 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-archive.c: New.\n+\t* ctf-impl.h (ctf_archive_internal): New type.\n+\t(ctf_arc_open_internal): New declaration.\n+\t(ctf_arc_bufopen): Likewise.\n+\t(ctf_arc_close_internal): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-open.c: New file."
    },
    {
      "sha": "ab658fd351c483269fa76441c2d5ce716c2f585b",
      "filename": "libctf/ctf-archive.c",
      "status": "added",
      "additions": 756,
      "deletions": 0,
      "changes": 756,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9402cc593f4aa54677203efa9a92c4f28d3033eb/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9402cc593f4aa54677203efa9a92c4f28d3033eb/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "patch": "@@ -0,0 +1,756 @@\n+/* CTF archive files.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <elf.h>\n+#include <endian.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+#ifdef HAVE_MMAP\n+#include <sys/mman.h>\n+#endif\n+\n+static off_t arc_write_one_ctf (ctf_file_t * f, int fd, size_t threshold);\n+static ctf_file_t *ctf_arc_open_by_offset (const struct ctf_archive *arc,\n+\t\t\t\t\t   const ctf_sect_t *symsect,\n+\t\t\t\t\t   const ctf_sect_t *strsect,\n+\t\t\t\t\t   size_t offset, int *errp);\n+static int sort_modent_by_name (const void *one, const void *two, void *n);\n+static void *arc_mmap_header (int fd, size_t headersz);\n+static void *arc_mmap_file (int fd, size_t size);\n+static int arc_mmap_writeout (int fd, void *header, size_t headersz,\n+\t\t\t      const char **errmsg);\n+static int arc_mmap_unmap (void *header, size_t headersz, const char **errmsg);\n+\n+/* bsearch() internal state.  */\n+static __thread char *search_nametbl;\n+\n+/* Write out a CTF archive.  The entries in CTF_FILES are referenced by name:\n+   the names are passed in the names array, which must have CTF_FILES entries.\n+\n+   Returns 0 on success, or an errno, or an ECTF_* value.  */\n+int\n+ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n+\t       const char **names, size_t threshold)\n+{\n+  const char *errmsg;\n+  struct ctf_archive *archdr;\n+  int fd;\n+  size_t i;\n+  char dummy = 0;\n+  size_t headersz;\n+  ssize_t namesz;\n+  size_t ctf_startoffs;\t\t/* Start of the section we are working over.  */\n+  char *nametbl = NULL;\t\t/* The name table.  */\n+  char *np;\n+  off_t nameoffs;\n+  struct ctf_archive_modent *modent;\n+\n+  ctf_dprintf (\"Writing archive %s with %zi files\\n\", file, ctf_file_cnt);\n+\n+  if ((fd = open (file, O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, 0666)) < 0)\n+    {\n+      errmsg = \"ctf_arc_write(): cannot create %s: %s\\n\";\n+      goto err;\n+    }\n+\n+  /* Figure out the size of the mmap()ed header, including the\n+     ctf_archive_modent array.  We assume that all of this needs no\n+     padding: a likely assumption, given that it's all made up of\n+     uint64_t's.  */\n+  headersz = sizeof (struct ctf_archive)\n+    + (ctf_file_cnt * sizeof (uint64_t) * 2);\n+  ctf_dprintf (\"headersz is %zi\\n\", headersz);\n+\n+  /* From now on we work in two pieces: an mmap()ed region from zero up to the\n+     headersz, and a region updated via write() starting after that, containing\n+     all the tables.  Platforms that do not support mmap() just use write().  */\n+  ctf_startoffs = headersz;\n+  if (lseek (fd, ctf_startoffs - 1, SEEK_SET) < 0)\n+    {\n+      errmsg = \"ctf_arc_write(): cannot extend file while writing %s: %s\\n\";\n+      goto err_close;\n+    }\n+\n+  if (write (fd, &dummy, 1) < 0)\n+    {\n+      errmsg = \"ctf_arc_write(): cannot extend file while writing %s: %s\\n\";\n+      goto err_close;\n+    }\n+\n+  if ((archdr = arc_mmap_header (fd, headersz)) == NULL)\n+    {\n+      errmsg = \"ctf_arc_write(): Cannot mmap() %s: %s\\n\";\n+      goto err_close;\n+    }\n+\n+  /* Fill in everything we can, which is everything other than the name\n+     table offset.  */\n+  archdr->ctfa_magic = htole64 (CTFA_MAGIC);\n+  archdr->ctfa_nfiles = htole64 (ctf_file_cnt);\n+  archdr->ctfa_ctfs = htole64 (ctf_startoffs);\n+\n+  /* We could validate that all CTF files have the same data model, but\n+     since any reasonable construction process will be building things of\n+     only one bitness anyway, this is pretty pointless, so just use the\n+     model of the first CTF file for all of them.  (It *is* valid to\n+     create an empty archive: the value of ctfa_model is irrelevant in\n+     this case, but we must be sure not to dereference uninitialized\n+     memory.)  */\n+\n+  if (ctf_file_cnt > 0)\n+    archdr->ctfa_model = htole64 (ctf_getmodel (ctf_files[0]));\n+\n+  /* Now write out the CTFs: ctf_archive_modent array via the mapping,\n+     ctfs via write().  The names themselves have not been written yet: we\n+     track them in a local strtab until the time is right, and sort the\n+     modents array after construction.\n+\n+    The name table is not sorted.  */\n+\n+  for (i = 0, namesz = 0; i < le64toh (archdr->ctfa_nfiles); i++)\n+    namesz += strlen (names[i]) + 1;\n+\n+  nametbl = malloc (namesz);\n+  if (nametbl == NULL)\n+    {\n+      errmsg = \"Error writing named CTF to %s: %s\\n\";\n+      goto err_unmap;\n+    }\n+\n+  for (i = 0, namesz = 0,\n+       modent = (ctf_archive_modent_t *) ((char *) archdr\n+\t\t\t\t\t  + sizeof (struct ctf_archive));\n+       i < le64toh (archdr->ctfa_nfiles); i++)\n+    {\n+      off_t off;\n+\n+      strcpy (&nametbl[namesz], names[i]);\n+\n+      off = arc_write_one_ctf (ctf_files[i], fd, threshold);\n+      ctf_dprintf (\"Written %s, offset now %zi\\n\", names[i], off);\n+      if ((off < 0) && (off > -ECTF_BASE))\n+\t{\n+\t  errmsg = \"ctf_arc_write(): Cannot determine file \"\n+\t    \"position while writing %s: %s\";\n+\t  goto err_free;\n+\t}\n+      if (off < 0)\n+\t{\n+\t  errmsg = \"ctf_arc_write(): Cannot write CTF file to %s: %s\\n\";\n+\t  errno = off * -1;\n+\t  goto err_free;\n+\t}\n+\n+      modent->name_offset = htole64 (namesz);\n+      modent->ctf_offset = htole64 (off - ctf_startoffs);\n+      namesz += strlen (names[i]) + 1;\n+      modent++;\n+    }\n+\n+  qsort_r ((ctf_archive_modent_t *) ((char *) archdr\n+\t\t\t\t     + sizeof (struct ctf_archive)),\n+\t   le64toh (archdr->ctfa_nfiles),\n+\t   sizeof (struct ctf_archive_modent), sort_modent_by_name, nametbl);\n+\n+   /* Now the name table.  */\n+\n+  if ((nameoffs = lseek (fd, 0, SEEK_CUR)) < 0)\n+    {\n+      errmsg = \"ctf_arc_write(): Cannot get current file position \"\n+\t\"in %s: %s\\n\";\n+      goto err_free;\n+    }\n+  archdr->ctfa_names = htole64 (nameoffs);\n+  np = nametbl;\n+  while (namesz > 0)\n+    {\n+      ssize_t len;\n+      if ((len = write (fd, np, namesz)) < 0)\n+\t{\n+\t  errmsg = \"ctf_arc_write(): Cannot write name table in %s: %s\\n\";\n+\t  goto err_free;\n+\t}\n+      namesz -= len;\n+      np += len;\n+    }\n+  free (nametbl);\n+\n+  if (arc_mmap_writeout (fd, archdr, headersz, &errmsg) < 0)\n+    goto err_unmap;\n+  if (arc_mmap_unmap (archdr, headersz, &errmsg) < 0)\n+    goto err_unlink;\n+  if (close (fd) < 0)\n+    {\n+      errmsg = \"ctf_arc_write(): Cannot close after writing to %s: %s\\n\";\n+      goto err_unlink;\n+    }\n+\n+  return 0;\n+\n+err_free:\n+  free (nametbl);\n+err_unmap:\n+  arc_mmap_unmap (archdr, headersz, NULL);\n+err_close:\n+  close (fd);\n+err_unlink:\n+  unlink (file);\n+err:\n+  ctf_dprintf (errmsg, file, errno < ECTF_BASE ? strerror (errno) :\n+\t       ctf_errmsg (errno));\n+  return errno;\n+}\n+\n+/* Write one CTF file out.  Return the file position of the written file (or\n+   rather, of the file-size uint64_t that precedes it): negative return is a\n+   negative errno or ctf_errno value.  On error, the file position may no longer\n+   be at the end of the file.  */\n+static off_t\n+arc_write_one_ctf (ctf_file_t * f, int fd, size_t threshold)\n+{\n+  off_t off, end_off;\n+  uint64_t ctfsz = 0;\n+  char *ctfszp;\n+  size_t ctfsz_len;\n+  int (*writefn) (ctf_file_t * fp, int fd);\n+\n+  if ((off = lseek (fd, 0, SEEK_CUR)) < 0)\n+    return errno * -1;\n+\n+  if (f->ctf_size > threshold)\n+    writefn = ctf_compress_write;\n+  else\n+    writefn = ctf_write;\n+\n+  /* This zero-write turns into the size in a moment. */\n+  ctfsz_len = sizeof (ctfsz);\n+  ctfszp = (char *) &ctfsz;\n+  while (ctfsz_len > 0)\n+    {\n+      ssize_t writelen = write (fd, ctfszp, ctfsz_len);\n+      if (writelen < 0)\n+\treturn errno * -1;\n+      ctfsz_len -= writelen;\n+      ctfszp += writelen;\n+    }\n+\n+  if (writefn (f, fd) != 0)\n+    return f->ctf_errno * -1;\n+\n+  if ((end_off = lseek (fd, 0, SEEK_CUR)) < 0)\n+    return errno * -1;\n+  ctfsz = htole64 (end_off - off);\n+\n+  if ((lseek (fd, off, SEEK_SET)) < 0)\n+    return errno * -1;\n+\n+  /* ... here.  */\n+  ctfsz_len = sizeof (ctfsz);\n+  ctfszp = (char *) &ctfsz;\n+  while (ctfsz_len > 0)\n+    {\n+      ssize_t writelen = write (fd, ctfszp, ctfsz_len);\n+      if (writelen < 0)\n+\treturn errno * -1;\n+      ctfsz_len -= writelen;\n+      ctfszp += writelen;\n+    }\n+\n+  end_off = LCTF_ALIGN_OFFS (end_off, 8);\n+  if ((lseek (fd, end_off, SEEK_SET)) < 0)\n+    return errno * -1;\n+\n+  return off;\n+}\n+\n+/* qsort() function to sort the array of struct ctf_archive_modents into\n+   ascending name order.  */\n+static int\n+sort_modent_by_name (const void *one, const void *two, void *n)\n+{\n+  const struct ctf_archive_modent *a = one;\n+  const struct ctf_archive_modent *b = two;\n+  char *nametbl = n;\n+\n+  return strcmp (&nametbl[le64toh (a->name_offset)],\n+\t\t &nametbl[le64toh (b->name_offset)]);\n+}\n+\n+/* bsearch() function to search for a given name in the sorted array of struct\n+   ctf_archive_modents.  */\n+static int\n+search_modent_by_name (const void *key, const void *ent)\n+{\n+  const char *k = key;\n+  const struct ctf_archive_modent *v = ent;\n+\n+  return strcmp (k, &search_nametbl[le64toh (v->name_offset)]);\n+}\n+\n+/* A trivial wrapper: open a CTF archive, from data in a buffer (which the\n+   caller must preserve until ctf_arc_close() time).  Returns the archive, or\n+   NULL and an error in *err (if not NULL).  */\n+struct ctf_archive *\n+ctf_arc_bufopen (const void *buf, size_t size _libctf_unused_, int *errp)\n+{\n+  struct ctf_archive *arc = (struct ctf_archive *) buf;\n+\n+  if (le64toh (arc->ctfa_magic) != CTFA_MAGIC)\n+    {\n+      if (errp)\n+\t*errp = ECTF_FMT;\n+      return NULL;\n+    }\n+  return arc;\n+}\n+\n+/* Open a CTF archive.  Returns the archive, or NULL and an error in *err (if\n+   not NULL).  */\n+struct ctf_archive *\n+ctf_arc_open_internal (const char *filename, int *errp)\n+{\n+  const char *errmsg;\n+  int fd;\n+  struct stat s;\n+  struct ctf_archive *arc;\t\t/* (Actually the whole file.)  */\n+\n+  libctf_init_debug();\n+  if ((fd = open (filename, O_RDONLY)) < 0)\n+    {\n+      errmsg = \"ctf_arc_open(): cannot open %s: %s\\n\";\n+      goto err;\n+    }\n+  if (fstat (fd, &s) < 0)\n+    {\n+      errmsg = \"ctf_arc_open(): cannot stat %s: %s\\n\";\n+      goto err_close;\n+    }\n+\n+  if ((arc = arc_mmap_file (fd, s.st_size)) == NULL)\n+    {\n+      errmsg = \"ctf_arc_open(): Cannot read in %s: %s\\n\";\n+      goto err_close;\n+    }\n+\n+  if (le64toh (arc->ctfa_magic) != CTFA_MAGIC)\n+    {\n+      errmsg = \"ctf_arc_open(): Invalid magic number\";\n+      errno = ECTF_FMT;\n+      goto err_unmap;\n+    }\n+\n+  /* This horrible hack lets us know how much to unmap when the file is\n+     closed.  (We no longer need the magic number, and the mapping\n+     is private.)  */\n+  arc->ctfa_magic = s.st_size;\n+  close (fd);\n+  return arc;\n+\n+err_unmap:\n+  arc_mmap_unmap (arc, s.st_size, NULL);\n+err_close:\n+  close (fd);\n+err:\n+  if (errp)\n+    *errp = errno;\n+  ctf_dprintf (errmsg, filename, errno < ECTF_BASE ? strerror (errno) :\n+\t       ctf_errmsg (errno));\n+  return NULL;\n+}\n+\n+/* Close an archive.  */\n+void\n+ctf_arc_close_internal (struct ctf_archive *arc)\n+{\n+  if (arc == NULL)\n+    return;\n+\n+  /* See the comment in ctf_arc_open().  */\n+  arc_mmap_unmap (arc, arc->ctfa_magic, NULL);\n+}\n+\n+/* Public entry point: close an archive, or CTF file.  */\n+void\n+ctf_arc_close (ctf_archive_t *arc)\n+{\n+  if (arc == NULL)\n+    return;\n+\n+  if (arc->ctfi_is_archive)\n+    ctf_arc_close_internal (arc->ctfi_archive);\n+  else\n+    ctf_file_close (arc->ctfi_file);\n+  free ((void *) arc->ctfi_symsect.cts_data);\n+  free ((void *) arc->ctfi_strsect.cts_data);\n+  free (arc->ctfi_data);\n+  free (arc);\n+}\n+\n+/* Return the ctf_file_t with the given name, or NULL if none, setting 'err' if\n+   non-NULL.  A name of NULL means to open the default file.  */\n+static ctf_file_t *\n+ctf_arc_open_by_name_internal (const struct ctf_archive *arc,\n+\t\t\t       const ctf_sect_t *symsect,\n+\t\t\t       const ctf_sect_t *strsect,\n+\t\t\t       const char *name, int *errp)\n+{\n+  struct ctf_archive_modent *modent;\n+\n+  if (name == NULL)\n+    name = _CTF_SECTION;\t\t /* The default name.  */\n+\n+  ctf_dprintf (\"ctf_arc_open_by_name(%s): opening\\n\", name);\n+\n+  modent = (ctf_archive_modent_t *) ((char *) arc\n+\t\t\t\t     + sizeof (struct ctf_archive));\n+\n+  search_nametbl = (char *) arc + le64toh (arc->ctfa_names);\n+  modent = bsearch (name, modent, le64toh (arc->ctfa_nfiles),\n+\t\t    sizeof (struct ctf_archive_modent),\n+\t\t    search_modent_by_name);\n+\n+  /* This is actually a common case and normal operation: no error\n+     debug output.  */\n+  if (modent == NULL)\n+    {\n+      if (errp)\n+\t*errp = ECTF_ARNNAME;\n+      return NULL;\n+    }\n+\n+  return ctf_arc_open_by_offset (arc, symsect, strsect,\n+\t\t\t\t le64toh (modent->ctf_offset), errp);\n+}\n+\n+/* Return the ctf_file_t with the given name, or NULL if none, setting 'err' if\n+   non-NULL.  A name of NULL means to open the default file.\n+\n+   Use the specified string and symbol table sections.\n+\n+   Public entry point.  */\n+ctf_file_t *\n+ctf_arc_open_by_name_sections (const ctf_archive_t *arc,\n+\t\t\t       const ctf_sect_t *symsect,\n+\t\t\t       const ctf_sect_t *strsect,\n+\t\t\t       const char *name,\n+\t\t\t       int *errp)\n+{\n+  if (arc->ctfi_is_archive)\n+    {\n+      ctf_file_t *ret;\n+      ret = ctf_arc_open_by_name_internal (arc->ctfi_archive, symsect, strsect,\n+\t\t\t\t\t   name, errp);\n+      if (ret)\n+\tret->ctf_archive = (ctf_archive_t *) arc;\n+      return ret;\n+    }\n+\n+  if ((name != NULL) && (strcmp (name, _CTF_SECTION) != 0))\n+    {\n+      if (errp)\n+\t*errp = ECTF_ARNNAME;\n+      return NULL;\n+    }\n+  arc->ctfi_file->ctf_archive = (ctf_archive_t *) arc;\n+\n+  /* Bump the refcount so that the user can ctf_file_close() it.  */\n+  arc->ctfi_file->ctf_refcnt++;\n+  return arc->ctfi_file;\n+}\n+\n+/* Return the ctf_file_t with the given name, or NULL if none, setting 'err' if\n+   non-NULL.  A name of NULL means to open the default file.\n+\n+   Public entry point.  */\n+ctf_file_t *\n+ctf_arc_open_by_name (const ctf_archive_t *arc, const char *name, int *errp)\n+{\n+  const ctf_sect_t *symsect = &arc->ctfi_symsect;\n+  const ctf_sect_t *strsect = &arc->ctfi_strsect;\n+\n+  if (symsect->cts_name == NULL)\n+    symsect = NULL;\n+  if (strsect->cts_name == NULL)\n+    strsect = NULL;\n+\n+  return ctf_arc_open_by_name_sections (arc, symsect, strsect, name, errp);\n+}\n+\n+/* Return the ctf_file_t at the given ctfa_ctfs-relative offset, or NULL if\n+   none, setting 'err' if non-NULL.  */\n+static ctf_file_t *\n+ctf_arc_open_by_offset (const struct ctf_archive *arc,\n+\t\t\tconst ctf_sect_t *symsect,\n+\t\t\tconst ctf_sect_t *strsect, size_t offset,\n+\t\t\tint *errp)\n+{\n+  ctf_sect_t ctfsect;\n+  ctf_file_t *fp;\n+\n+  ctf_dprintf (\"ctf_arc_open_by_offset(%zi): opening\\n\", offset);\n+\n+  bzero (&ctfsect, sizeof (ctf_sect_t));\n+\n+  offset += le64toh (arc->ctfa_ctfs);\n+\n+  ctfsect.cts_name = _CTF_SECTION;\n+  ctfsect.cts_type = SHT_PROGBITS;\n+  ctfsect.cts_flags = SHF_ALLOC;\n+  ctfsect.cts_size = le64toh (*((uint64_t *) ((char *) arc + offset)));\n+  ctfsect.cts_entsize = 1;\n+  ctfsect.cts_offset = 0;\n+  ctfsect.cts_data = (void *) ((char *) arc + offset + sizeof (uint64_t));\n+  fp = ctf_bufopen (&ctfsect, symsect, strsect, errp);\n+  if (fp)\n+    ctf_setmodel (fp, le64toh (arc->ctfa_model));\n+  return fp;\n+}\n+\n+/* Raw iteration over all CTF files in an archive.  We pass the raw data for all\n+   CTF files in turn to the specified callback function.  */\n+static int\n+ctf_archive_raw_iter_internal (const struct ctf_archive *arc,\n+\t\t\t       ctf_archive_raw_member_f *func, void *data)\n+{\n+  int rc;\n+  size_t i;\n+  struct ctf_archive_modent *modent;\n+  const char *nametbl;\n+\n+  modent = (ctf_archive_modent_t *) ((char *) arc\n+\t\t\t\t     + sizeof (struct ctf_archive));\n+  nametbl = (((const char *) arc) + le64toh (arc->ctfa_names));\n+\n+  for (i = 0; i < le64toh (arc->ctfa_nfiles); i++)\n+    {\n+      const char *name;\n+      char *fp;\n+\n+      name = &nametbl[le64toh (modent[i].name_offset)];\n+      fp = ((char *) arc + le64toh (arc->ctfa_ctfs)\n+\t    + le64toh (modent[i].ctf_offset));\n+\n+      if ((rc = func (name, (void *) (fp + sizeof (uint64_t)),\n+\t\t      le64toh (*((uint64_t *) fp)), data)) != 0)\n+\treturn rc;\n+    }\n+  return 0;\n+}\n+\n+/* Raw iteration over all CTF files in an archive: public entry point.\n+\n+   Returns -EINVAL if not supported for this sort of archive.  */\n+int\n+ctf_archive_raw_iter (const ctf_archive_t *arc,\n+\t\t      ctf_archive_raw_member_f * func, void *data)\n+{\n+  if (arc->ctfi_is_archive)\n+    return ctf_archive_raw_iter_internal (arc->ctfi_archive, func, data);\n+\n+  return -EINVAL;\t\t\t /* Not supported. */\n+}\n+\n+/* Iterate over all CTF files in an archive.  We pass all CTF files in turn to\n+   the specified callback function.  */\n+static int\n+ctf_archive_iter_internal (const ctf_archive_t *wrapper,\n+\t\t\t   const struct ctf_archive *arc,\n+\t\t\t   const ctf_sect_t *symsect,\n+\t\t\t   const ctf_sect_t *strsect,\n+\t\t\t   ctf_archive_member_f *func, void *data)\n+{\n+  int rc;\n+  size_t i;\n+  ctf_file_t *f;\n+  struct ctf_archive_modent *modent;\n+  const char *nametbl;\n+\n+  modent = (ctf_archive_modent_t *) ((char *) arc\n+\t\t\t\t     + sizeof (struct ctf_archive));\n+  nametbl = (((const char *) arc) + le64toh (arc->ctfa_names));\n+\n+  for (i = 0; i < le64toh (arc->ctfa_nfiles); i++)\n+    {\n+      const char *name;\n+\n+      name = &nametbl[le64toh (modent[i].name_offset)];\n+      if ((f = ctf_arc_open_by_name_internal (arc, symsect, strsect,\n+\t\t\t\t\t      name, &rc)) == NULL)\n+\treturn rc;\n+\n+      f->ctf_archive = (ctf_archive_t *) wrapper;\n+      if ((rc = func (f, name, data)) != 0)\n+\t{\n+\t  ctf_file_close (f);\n+\t  return rc;\n+\t}\n+\n+      ctf_file_close (f);\n+    }\n+  return 0;\n+}\n+\n+/* Iterate over all CTF files in an archive: public entry point.  We pass all\n+   CTF files in turn to the specified callback function.  */\n+int\n+ctf_archive_iter (const ctf_archive_t *arc, ctf_archive_member_f *func,\n+\t\t  void *data)\n+{\n+  const ctf_sect_t *symsect = &arc->ctfi_symsect;\n+  const ctf_sect_t *strsect = &arc->ctfi_strsect;\n+\n+  if (symsect->cts_name == NULL)\n+    symsect = NULL;\n+  if (strsect->cts_name == NULL)\n+    strsect = NULL;\n+\n+  if (arc->ctfi_is_archive)\n+    return ctf_archive_iter_internal (arc, arc->ctfi_archive, symsect, strsect,\n+\t\t\t\t      func, data);\n+\n+  return func (arc->ctfi_file, _CTF_SECTION, data);\n+}\n+\n+#ifdef HAVE_MMAP\n+/* Map the header in.  Only used on new, empty files.  */\n+static void *arc_mmap_header (int fd, size_t headersz)\n+{\n+  void *hdr;\n+  if ((hdr = mmap (NULL, headersz, PROT_READ | PROT_WRITE, MAP_SHARED, fd,\n+\t\t   0)) == MAP_FAILED)\n+    return NULL;\n+  return hdr;\n+}\n+\n+/* mmap() the whole file, for reading only.  (Map it writably, but privately: we\n+   need to modify the region, but don't need anyone else to see the\n+   modifications.)  */\n+static void *arc_mmap_file (int fd, size_t size)\n+{\n+  void *arc;\n+  if ((arc = mmap (NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE,\n+\t\t   fd, 0)) == MAP_FAILED)\n+    return NULL;\n+  return arc;\n+}\n+\n+/* Persist the header to disk.  */\n+static int arc_mmap_writeout (int fd _libctf_unused_, void *header,\n+\t\t\t      size_t headersz, const char **errmsg)\n+{\n+    if (msync (header, headersz, MS_ASYNC) < 0)\n+    {\n+      if (errmsg)\n+\t*errmsg = \"arc_mmap_writeout(): Cannot sync after writing to %s: %s\\n\";\n+      return -1;\n+    }\n+    return 0;\n+}\n+\n+/* Unmap the region.  */\n+static int arc_mmap_unmap (void *header, size_t headersz, const char **errmsg)\n+{\n+  if (munmap (header, headersz) < 0)\n+    {\n+      if (errmsg)\n+\t*errmsg = \"arc_mmap_munmap(): Cannot unmap after writing to %s: %s\\n\";\n+      return -1;\n+    }\n+    return 0;\n+}\n+#else\n+/* Map the header in.  Only used on new, empty files.  */\n+static void *arc_mmap_header (int fd, size_t headersz)\n+{\n+  void *hdr;\n+  if ((hdr = malloc (headersz)) == NULL)\n+    return NULL;\n+  return hdr;\n+}\n+\n+/* Pull in the whole file, for reading only.  We assume the current file\n+   position is at the start of the file.  */\n+static void *arc_mmap_file (int fd, size_t size)\n+{\n+  char *data;\n+\n+  if ((data = malloc (size)) == NULL)\n+    return NULL;\n+\n+  if (ctf_pread (fd, data, size, 0) < 0)\n+    {\n+      free (data);\n+      return NULL;\n+    }\n+  return data;\n+}\n+\n+/* Persist the header to disk.  */\n+static int arc_mmap_writeout (int fd, void *header, size_t headersz,\n+\t\t\t      const char **errmsg)\n+{\n+  ssize_t len;\n+  size_t acc = 0;\n+  char *data = (char *) header;\n+  ssize_t count = headersz;\n+\n+  if ((lseek (fd, 0, SEEK_SET)) < 0)\n+    {\n+      if (errmsg)\n+\t*errmsg = \"arc_mmap_writeout(): Cannot seek while writing header to \"\n+\t  \"%s: %s\\n\";\n+      return -1;\n+    }\n+\n+  while (headersz > 0)\n+    {\n+      if ((len = write (fd, data, count)) < 0)\n+\t{\n+\t  if (errmsg)\n+\t    *errmsg = \"arc_mmap_writeout(): Cannot write header to %s: %s\\n\";\n+\t  return len;\n+\t}\n+      if (len == EINTR)\n+\tcontinue;\n+\n+      acc += len;\n+      if (len == 0)\t\t\t\t/* EOF.  */\n+\tbreak;\n+\n+      count -= len;\n+      data += len;\n+    }\n+  return 0;\n+}\n+\n+/* Unmap the region.  */\n+static int arc_mmap_unmap (void *header, size_t headersz _libctf_unused_,\n+\t\t\t   const char **errmsg _libctf_unused_)\n+{\n+  free (header);\n+  return 0;\n+}\n+#endif"
    },
    {
      "sha": "898be8ce3a419be005c8991d3df72695ce5e3399",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9402cc593f4aa54677203efa9a92c4f28d3033eb/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9402cc593f4aa54677203efa9a92c4f28d3033eb/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "patch": "@@ -230,6 +230,18 @@ struct ctf_file\n   void *ctf_specific;\t\t  /* Data for ctf_get/setspecific().  */\n };\n \n+/* An abstraction over both a ctf_file_t and a ctf_archive_t.  */\n+\n+struct ctf_archive_internal\n+{\n+  int ctfi_is_archive;\n+  ctf_file_t *ctfi_file;\n+  struct ctf_archive *ctfi_archive;\n+  ctf_sect_t ctfi_symsect;\n+  ctf_sect_t ctfi_strsect;\n+  void *ctfi_data;\n+};\n+\n /* Return x rounded up to an alignment boundary.\n    eg, P2ROUNDUP(0x1234, 0x100) == 0x1300 (0x13*align)\n    eg, P2ROUNDUP(0x5600, 0x100) == 0x5600 (0x56*align)  */\n@@ -310,6 +322,9 @@ extern ctf_dvdef_t *ctf_dvd_lookup (const ctf_file_t *, const char *);\n extern const char *ctf_strraw (ctf_file_t *, uint32_t);\n extern const char *ctf_strptr (ctf_file_t *, uint32_t);\n \n+extern struct ctf_archive *ctf_arc_open_internal (const char *, int *);\n+extern struct ctf_archive *ctf_arc_bufopen (const void *, size_t, int *);\n+extern void ctf_arc_close_internal (struct ctf_archive *);\n extern void *ctf_set_open_errno (int *, int);\n extern long ctf_set_errno (ctf_file_t *, int);\n "
    },
    {
      "sha": "8c6294a89becaf22519bad13e92bcdcf2c40125d",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9402cc593f4aa54677203efa9a92c4f28d3033eb/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9402cc593f4aa54677203efa9a92c4f28d3033eb/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "patch": "@@ -1572,6 +1572,13 @@ ctf_file_close (ctf_file_t *fp)\n   ctf_free (fp);\n }\n \n+/* Get the CTF archive from which this ctf_file_t is derived.  */\n+ctf_archive_t *\n+ctf_get_arc (const ctf_file_t *fp)\n+{\n+  return fp->ctf_archive;\n+}\n+\n /* Return the ctfsect out of the core ctf_impl.  Useful for freeing the\n    ctfsect's data * after ctf_file_close(), which is why we return the actual\n    structure, not a pointer to it, since that is likely to become a pointer to"
    }
  ]
}