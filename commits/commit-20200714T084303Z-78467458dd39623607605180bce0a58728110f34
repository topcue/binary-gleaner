{
  "sha": "78467458dd39623607605180bce0a58728110f34",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Nzg0Njc0NThkZDM5NjIzNjA3NjA1MTgwYmNlMGE1ODcyODExMGYzNA==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2020-07-14T08:43:03Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2020-07-14T08:43:03Z"
    },
    "message": "x86: drop Rm and the 'L' macro\n\nRm (and hence OP_R()) can be dropped by making 'Z' force modrm.mod to 3\n(for OP_E()) instead of ignoring it. While at it move 'Z' handling to\nits designated place (after 'Y'; 'W' handling will be moved by a later\nchange).\n\nMoves to/from TRn are illegal in 64-bit mode and thus get converted to\nhonor this at the same time (also getting them in line with moves\nto/from CRn/DRn ModRM.mod handling wise). This then also frees up the L\nmacro.",
    "tree": {
      "sha": "344c2e4087e853a47f0009585e7bd0bca7c2cac1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/344c2e4087e853a47f0009585e7bd0bca7c2cac1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/78467458dd39623607605180bce0a58728110f34",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78467458dd39623607605180bce0a58728110f34",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/78467458dd39623607605180bce0a58728110f34",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78467458dd39623607605180bce0a58728110f34/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "464d2b65680352965d877d9f4ac5430bd05934df",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/464d2b65680352965d877d9f4ac5430bd05934df",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/464d2b65680352965d877d9f4ac5430bd05934df"
    }
  ],
  "stats": {
    "total": 141,
    "additions": 67,
    "deletions": 74
  },
  "files": [
    {
      "sha": "4cc50874ff5edecf5ef57a3242579f84aaba9b3a",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78467458dd39623607605180bce0a58728110f34/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78467458dd39623607605180bce0a58728110f34/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=78467458dd39623607605180bce0a58728110f34",
      "patch": "@@ -1,3 +1,16 @@\n+2020-07-14  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* i386-dis.c (OP_R, Rm): Delete.\n+\t(MOD_0F24, MOD_0F26): Rename to ...\n+\t(X86_64_0F24, X86_64_0F26): ... respectively.\n+\t(dis386): Update 'L' and 'Z' comments.\n+\t(dis386_twobyte): Replace Rm by Em. Change opcode 0F24 and 0F26\n+\ttable references.\n+\t(mod_table): Move opcode 0F24 and 0F26 entries ...\n+\t(x86_64_table): ... here.\n+\t(putop): Drop handling of 'L'. Set modrm.mod to 3 for 'Z'. Move\n+\t'Z' case block.\n+\n 2020-07-14  Jan Beulich  <jbeulich@suse.com>\n \n \t* i386-dis.c (Rd, Rdq, MaskR): Delete."
    },
    {
      "sha": "9c45da2c4a10e5435fa9831be7f209513c780886",
      "filename": "opcodes/i386-dis.c",
      "status": "modified",
      "additions": 54,
      "deletions": 74,
      "changes": 128,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78467458dd39623607605180bce0a58728110f34/opcodes/i386-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78467458dd39623607605180bce0a58728110f34/opcodes/i386-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-dis.c?ref=78467458dd39623607605180bce0a58728110f34",
      "patch": "@@ -77,7 +77,6 @@ static void OP_DSreg (int, int);\n static void OP_C (int, int);\n static void OP_D (int, int);\n static void OP_T (int, int);\n-static void OP_R (int, int);\n static void OP_MMX (int, int);\n static void OP_XMM (int, int);\n static void OP_EM (int, int);\n@@ -274,7 +273,6 @@ fetch_data (struct disassemble_info *info, bfd_byte *addr)\n #define Gm { OP_G, m_mode }\n #define Gva { OP_G, va_mode }\n #define Gw { OP_G, w_mode }\n-#define Rm { OP_R, m_mode }\n #define Ib { OP_I, b_mode }\n #define sIb { OP_sI, b_mode }\t/* sign extened byte */\n #define sIbT { OP_sI, b_T_mode } /* sign extened byte like 'T' */\n@@ -752,8 +750,6 @@ enum\n   MOD_0F1B_PREFIX_1,\n   MOD_0F1C_PREFIX_0,\n   MOD_0F1E_PREFIX_1,\n-  MOD_0F24,\n-  MOD_0F26,\n   MOD_0F2B_PREFIX_0,\n   MOD_0F2B_PREFIX_1,\n   MOD_0F2B_PREFIX_2,\n@@ -1167,6 +1163,8 @@ enum\n   X86_64_0F01_REG_1,\n   X86_64_0F01_REG_2,\n   X86_64_0F01_REG_3,\n+  X86_64_0F24,\n+  X86_64_0F26,\n   X86_64_VEX_0F3849,\n   X86_64_VEX_0F384B,\n   X86_64_VEX_0F385C,\n@@ -1736,7 +1734,7 @@ struct dis386 {\n    'I' unused.\n    'J' unused.\n    'K' => print 'd' or 'q' if rex prefix is present.\n-   'L' => print 'l' if suffix_always is true\n+   'L' unused.\n    'M' => print 'r' if intel_mnemonic is false.\n    'N' => print 'n' if instruction has no wait \"prefix\"\n    'O' => print 'd' or 'o' (or 'q' in Intel mode)\n@@ -1755,7 +1753,7 @@ struct dis386 {\n    'W' => print 'b', 'w' or 'l' ('d' in Intel mode)\n    'X' => print 's', 'd' depending on data16 prefix (for XMM)\n    'Y' unused.\n-   'Z' => print 'q' in 64bit mode and behave as 'L' otherwise\n+   'Z' => print 'q' in 64bit mode and 'l' otherwise, if suffix_always is true.\n    '!' => change condition from true to false or from false to true.\n    '%' => add 1 upper case letter to the macro.\n    '^' => print 'w', 'l', or 'q' (Intel64 ISA only) depending on operand size\n@@ -2119,13 +2117,13 @@ static const struct dis386 dis386_twobyte[] = {\n   { PREFIX_TABLE (PREFIX_0F1E) },\n   { \"nopQ\",\t\t{ Ev }, 0 },\n   /* 20 */\n-  { \"movZ\",\t\t{ Rm, Cm }, 0 },\n-  { \"movZ\",\t\t{ Rm, Dm }, 0 },\n-  { \"movZ\",\t\t{ Cm, Rm }, 0 },\n-  { \"movZ\",\t\t{ Dm, Rm }, 0 },\n-  { MOD_TABLE (MOD_0F24) },\n+  { \"movZ\",\t\t{ Em, Cm }, 0 },\n+  { \"movZ\",\t\t{ Em, Dm }, 0 },\n+  { \"movZ\",\t\t{ Cm, Em }, 0 },\n+  { \"movZ\",\t\t{ Dm, Em }, 0 },\n+  { X86_64_TABLE (X86_64_0F24) },\n   { Bad_Opcode },\n-  { MOD_TABLE (MOD_0F26) },\n+  { X86_64_TABLE (X86_64_0F26) },\n   { Bad_Opcode },\n   /* 28 */\n   { \"movapX\",\t\t{ XM, EXx }, PREFIX_OPCODE },\n@@ -4157,6 +4155,16 @@ static const struct dis386 x86_64_table[][2] = {\n     { \"lidt\", { M }, 0 },\n   },\n \n+  {\n+    /* X86_64_0F24 */\n+    { \"movZ\",\t\t{ Em, Td }, 0 },\n+  },\n+\n+  {\n+    /* X86_64_0F26 */\n+    { \"movZ\",\t\t{ Td, Em }, 0 },\n+  },\n+\n   /* X86_64_VEX_0F3849 */\n   {\n     { Bad_Opcode },\n@@ -7991,16 +7999,6 @@ static const struct dis386 mod_table[][2] = {\n     { \"nopQ\",\t\t{ Ev }, 0 },\n     { REG_TABLE (REG_0F1E_P_1_MOD_3) },\n   },\n-  {\n-    /* MOD_0F24 */\n-    { Bad_Opcode },\n-    { \"movL\",\t\t{ Rm, Td }, 0 },\n-  },\n-  {\n-    /* MOD_0F26 */\n-    { Bad_Opcode },\n-    { \"movL\",\t\t{ Td, Rm }, 0 },\n-  },\n   {\n     /* MOD_0F2B_PREFIX_0 */\n     {\"movntps\",\t\t{ Mx, XM }, PREFIX_OPCODE },\n@@ -10616,50 +10614,8 @@ putop (const char *in_template, int sizeflag)\n \t  else\n \t    *obufp++ = 'd';\n \t  break;\n-\tcase 'Z':\n-\t  if (l != 0)\n-\t    {\n-\t      if (l != 1 || last[0] != 'X')\n-\t\tabort ();\n-\t      if (!need_vex || !vex.evex)\n-\t\tabort ();\n-\t      if (intel_syntax\n-\t\t  || ((modrm.mod == 3 || vex.b) && !(sizeflag & SUFFIX_ALWAYS)))\n-\t\tbreak;\n-\t      switch (vex.length)\n-\t\t{\n-\t\tcase 128:\n-\t\t  *obufp++ = 'x';\n-\t\t  break;\n-\t\tcase 256:\n-\t\t  *obufp++ = 'y';\n-\t\t  break;\n-\t\tcase 512:\n-\t\t  *obufp++ = 'z';\n-\t\t  break;\n-\t\tdefault:\n-\t\t  abort ();\n-\t\t}\n-\t      break;\n-\t    }\n-\t  if (intel_syntax)\n-\t    break;\n-\t  if (address_mode == mode_64bit && (sizeflag & SUFFIX_ALWAYS))\n-\t    {\n-\t      *obufp++ = 'q';\n-\t      break;\n-\t    }\n-\t  /* Fall through.  */\n-\t  goto case_L;\n \tcase 'L':\n-\t  if (l != 0)\n-\t    abort ();\n-\tcase_L:\n-\t  if (intel_syntax)\n-\t    break;\n-\t  if (sizeflag & SUFFIX_ALWAYS)\n-\t    *obufp++ = 'l';\n-\t  break;\n+\t  abort ();\n \tcase 'M':\n \t  if (intel_mnemonic != cond)\n \t    *obufp++ = 'r';\n@@ -10924,6 +10880,39 @@ putop (const char *in_template, int sizeflag)\n \t  else\n \t    abort ();\n \t  break;\n+\tcase 'Z':\n+\t  if (l == 0)\n+\t    {\n+\t      /* These insns ignore ModR/M.mod: Force it to 3 for OP_E().  */\n+\t      modrm.mod = 3;\n+\t      if (!intel_syntax && (sizeflag & SUFFIX_ALWAYS))\n+\t\t*obufp++ = address_mode == mode_64bit ? 'q' : 'l';\n+\t    }\n+\t  else if (l == 1 && last[0] == 'X')\n+\t    {\n+\t      if (!need_vex || !vex.evex)\n+\t\tabort ();\n+\t      if (intel_syntax\n+\t\t  || ((modrm.mod == 3 || vex.b) && !(sizeflag & SUFFIX_ALWAYS)))\n+\t\tbreak;\n+\t      switch (vex.length)\n+\t\t{\n+\t\tcase 128:\n+\t\t  *obufp++ = 'x';\n+\t\t  break;\n+\t\tcase 256:\n+\t\t  *obufp++ = 'y';\n+\t\t  break;\n+\t\tcase 512:\n+\t\t  *obufp++ = 'z';\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t\t}\n+\t    }\n+\t  else\n+\t    abort ();\n+\t  break;\n \tcase 'W':\n \t  if (l == 0)\n \t    {\n@@ -12811,15 +12800,6 @@ OP_T (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)\n   oappend_maybe_intel (scratchbuf);\n }\n \n-static void\n-OP_R (int bytemode, int sizeflag)\n-{\n-  /* Skip mod/rm byte.  */\n-  MODRM_CHECK;\n-  codep++;\n-  OP_E_register (bytemode, sizeflag);\n-}\n-\n static void\n OP_MMX (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)\n {"
    }
  ]
}