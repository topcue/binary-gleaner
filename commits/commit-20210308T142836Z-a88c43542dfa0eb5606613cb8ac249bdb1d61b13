{
  "sha": "a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTg4YzQzNTQyZGZhMGViNTYwNjYxM2NiOGFjMjQ5YmRiMWQ2MWIxMw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:36Z"
    },
    "message": "Implement Ada assignment\n\nAssignment is the most complicated Ada expression, because\nimplementing aggregate assignment involves several specialized\nopcodes.\n\nThis patch does this implementation by introducing new abstract\nclasses that are used to represent the various parts of aggregate\nassignment.  This makes the code somewhat cleaner, and, by avoiding\nthe over-use of 'operation' subclasses, avoids the need for dissection\nusing dynamic_cast (though a few are still needed here).\n\nI believe this patch fixes a latent bug in the handling of\naggregate_assign_from_choices.  That code does:\n\n      if (op == OP_DISCRETE_RANGE)\n\t{\n\t  choice_pos += 1;\n\t  lower = value_as_long (ada_evaluate_subexp (NULL, exp, pos,\n\t\t\t\t\t\t      EVAL_NORMAL));\n\t  upper = value_as_long (ada_evaluate_subexp (NULL, exp, pos,\n\t\t\t\t\t\t      EVAL_NORMAL));\n\t}\n\nHowever, I think 'choice_pos' should be used in the calls, rather than\n'pos'.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* expprint.c (dump_for_expression): New overload.\n\t* expop.h (check_objfile, dump_for_expression): Declare new\n\toverloads.\n\t* ada-lang.c (check_objfile): New overload.\n\t(assign_component, ada_aggregate_component::uses_objfile)\n\t(ada_aggregate_component::dump, ada_aggregate_component::assign)\n\t(ada_aggregate_component::assign_aggregate)\n\t(ada_positional_component::uses_objfile)\n\t(ada_positional_component::dump, ada_positional_component::assign)\n\t(ada_discrete_range_association::uses_objfile)\n\t(ada_discrete_range_association::dump)\n\t(ada_discrete_range_association::assign)\n\t(ada_name_association::uses_objfile, ada_name_association::dump)\n\t(ada_name_association::assign)\n\t(ada_choices_component::uses_objfile, ada_choices_component::dump)\n\t(ada_choices_component::assign)\n\t(ada_others_component::uses_objfile, ada_others_component::dump)\n\t(ada_others_component::assign, ada_assign_operation::evaluate):\n\tNew methods.\n\t* ada-exp.h (ada_string_operation) <get_name>: New method.\n\t(class ada_assign_operation): New.\n\t(class ada_component): New.\n\t(ada_component_up): New typedef.\n\t(class ada_aggregate_operation, class ada_aggregate_component)\n\t(class ada_positional_component, class ada_others_component)\n\t(class ada_association): New.\n\t(ada_association_up): New typedef.\n\t(class ada_choices_component)\n\t(class ada_discrete_range_association)\n\t(class ada_name_association): New.",
    "tree": {
      "sha": "3952527b944f4c96bf06b909e2e2dff3bcfb1ac9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3952527b944f4c96bf06b909e2e2dff3bcfb1ac9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d8a4ed8ad1b5d93b78efbd635d41f706902e2379"
    }
  ],
  "stats": {
    "total": 667,
    "additions": 667,
    "deletions": 0
  },
  "files": [
    {
      "sha": "93fdabdf1deabc3d98e032859791e7f7b0126f9b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
      "patch": "@@ -1,3 +1,36 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* expprint.c (dump_for_expression): New overload.\n+\t* expop.h (check_objfile, dump_for_expression): Declare new\n+\toverloads.\n+\t* ada-lang.c (check_objfile): New overload.\n+\t(assign_component, ada_aggregate_component::uses_objfile)\n+\t(ada_aggregate_component::dump, ada_aggregate_component::assign)\n+\t(ada_aggregate_component::assign_aggregate)\n+\t(ada_positional_component::uses_objfile)\n+\t(ada_positional_component::dump, ada_positional_component::assign)\n+\t(ada_discrete_range_association::uses_objfile)\n+\t(ada_discrete_range_association::dump)\n+\t(ada_discrete_range_association::assign)\n+\t(ada_name_association::uses_objfile, ada_name_association::dump)\n+\t(ada_name_association::assign)\n+\t(ada_choices_component::uses_objfile, ada_choices_component::dump)\n+\t(ada_choices_component::assign)\n+\t(ada_others_component::uses_objfile, ada_others_component::dump)\n+\t(ada_others_component::assign, ada_assign_operation::evaluate):\n+\tNew methods.\n+\t* ada-exp.h (ada_string_operation) <get_name>: New method.\n+\t(class ada_assign_operation): New.\n+\t(class ada_component): New.\n+\t(ada_component_up): New typedef.\n+\t(class ada_aggregate_operation, class ada_aggregate_component)\n+\t(class ada_positional_component, class ada_others_component)\n+\t(class ada_association): New.\n+\t(ada_association_up): New typedef.\n+\t(class ada_choices_component)\n+\t(class ada_discrete_range_association)\n+\t(class ada_name_association): New.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ada-lang.c (ada_var_value_operation::resolve)"
    },
    {
      "sha": "ab910e87fffc1cc4dd4e881addde6e69cec408ea",
      "filename": "gdb/ada-exp.h",
      "status": "modified",
      "additions": 279,
      "deletions": 0,
      "changes": 279,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/ada-exp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/ada-exp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.h?ref=a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
      "patch": "@@ -122,6 +122,12 @@ class ada_string_operation\n \n   using string_operation::string_operation;\n \n+  /* Return the underlying string.  */\n+  const char *get_name () const\n+  {\n+    return std::get<0> (m_storage).c_str ();\n+  }\n+\n   value *evaluate (struct type *expect_type,\n \t\t   struct expression *exp,\n \t\t   enum noside noside) override;\n@@ -447,6 +453,279 @@ class ada_funcall_operation\n   { return OP_FUNCALL; }\n };\n \n+/* An Ada assignment operation.  */\n+class ada_assign_operation\n+  : public assign_operation\n+{\n+public:\n+\n+  using assign_operation::assign_operation;\n+\n+  value *evaluate (struct type *expect_type,\n+\t\t   struct expression *exp,\n+\t\t   enum noside noside) override;\n+\n+  enum exp_opcode opcode () const override\n+  { return BINOP_ASSIGN; }\n+};\n+\n+/* This abstract class represents a single component in an Ada\n+   aggregate assignment.  */\n+class ada_component\n+{\n+public:\n+\n+  /* Assign to LHS, which is part of CONTAINER.  EXP is the expression\n+     being evaluated.  INDICES, LOW, and HIGH indicate which\n+     sub-components have already been assigned; INDICES should be\n+     updated by this call.  */\n+  virtual void assign (struct value *container,\n+\t\t       struct value *lhs, struct expression *exp,\n+\t\t       std::vector<LONGEST> &indices,\n+\t\t       LONGEST low, LONGEST high) = 0;\n+\n+  /* Same as operation::uses_objfile.  */\n+  virtual bool uses_objfile (struct objfile *objfile) = 0;\n+\n+  /* Same as operation::dump.  */\n+  virtual void dump (ui_file *stream, int depth) = 0;\n+\n+  virtual ~ada_component () = default;\n+\n+protected:\n+\n+  ada_component () = default;\n+  DISABLE_COPY_AND_ASSIGN (ada_component);\n+};\n+\n+/* Unique pointer specialization for Ada assignment components.  */\n+typedef std::unique_ptr<ada_component> ada_component_up;\n+\n+/* An operation that holds a single component.  */\n+class ada_aggregate_operation\n+  : public tuple_holding_operation<ada_component_up>\n+{\n+public:\n+\n+  using tuple_holding_operation::tuple_holding_operation;\n+\n+  /* Assuming that LHS represents an lvalue having a record or array\n+     type, evaluate an assignment of this aggregate's value to LHS.\n+     CONTAINER is an lvalue containing LHS (possibly LHS itself).\n+     Does not modify the inferior's memory, nor does it modify the\n+     contents of LHS (unless == CONTAINER).  */\n+\n+  void assign_aggregate (struct value *container,\n+\t\t\t struct value *lhs,\n+\t\t\t struct expression *exp);\n+\n+  value *evaluate (struct type *expect_type,\n+\t\t   struct expression *exp,\n+\t\t   enum noside noside) override\n+  {\n+    error (_(\"Aggregates only allowed on the right of an assignment\"));\n+  }\n+\n+  enum exp_opcode opcode () const override\n+  { return OP_AGGREGATE; }\n+};\n+\n+/* A component holding a vector of other components to assign.  */\n+class ada_aggregate_component : public ada_component\n+{\n+public:\n+\n+  explicit ada_aggregate_component (std::vector<ada_component_up> &&components)\n+    : m_components (std::move (components))\n+  {\n+  }\n+\n+  void assign (struct value *container,\n+\t       struct value *lhs, struct expression *exp,\n+\t       std::vector<LONGEST> &indices,\n+\t       LONGEST low, LONGEST high) override;\n+\n+  bool uses_objfile (struct objfile *objfile) override;\n+\n+  void dump (ui_file *stream, int depth) override;\n+\n+private:\n+\n+  std::vector<ada_component_up> m_components;\n+};\n+\n+/* A component that assigns according to a provided index (which is\n+   relative to the \"low\" value).  */\n+class ada_positional_component : public ada_component\n+{\n+public:\n+\n+  ada_positional_component (int index, operation_up &&op)\n+    : m_index (index),\n+      m_op (std::move (op))\n+  {\n+  }\n+\n+  void assign (struct value *container,\n+\t       struct value *lhs, struct expression *exp,\n+\t       std::vector<LONGEST> &indices,\n+\t       LONGEST low, LONGEST high) override;\n+\n+  bool uses_objfile (struct objfile *objfile) override;\n+\n+  void dump (ui_file *stream, int depth) override;\n+\n+private:\n+\n+  int m_index;\n+  operation_up m_op;\n+};\n+\n+/* A component which handles an \"others\" clause.  */\n+class ada_others_component : public ada_component\n+{\n+public:\n+\n+  explicit ada_others_component (operation_up &&op)\n+    : m_op (std::move (op))\n+  {\n+  }\n+\n+  void assign (struct value *container,\n+\t       struct value *lhs, struct expression *exp,\n+\t       std::vector<LONGEST> &indices,\n+\t       LONGEST low, LONGEST high) override;\n+\n+  bool uses_objfile (struct objfile *objfile) override;\n+\n+  void dump (ui_file *stream, int depth) override;\n+\n+private:\n+\n+  operation_up m_op;\n+};\n+\n+/* An interface that represents an association that is used in\n+   aggregate assignment.  */\n+class ada_association\n+{\n+public:\n+\n+  /* Like ada_component::assign, but takes an operation as a\n+     parameter.  The operation is evaluated and then assigned into LHS\n+     according to the rules of the concrete implementation.  */\n+  virtual void assign (struct value *container,\n+\t\t       struct value *lhs,\n+\t\t       struct expression *exp,\n+\t\t       std::vector<LONGEST> &indices,\n+\t\t       LONGEST low, LONGEST high,\n+\t\t       operation_up &op) = 0;\n+\n+  /* Same as operation::uses_objfile.  */\n+  virtual bool uses_objfile (struct objfile *objfile) = 0;\n+\n+  /* Same as operation::dump.  */\n+  virtual void dump (ui_file *stream, int depth) = 0;\n+\n+  virtual ~ada_association () = default;\n+\n+protected:\n+\n+  ada_association () = default;\n+  DISABLE_COPY_AND_ASSIGN (ada_association);\n+};\n+\n+/* Unique pointer specialization for Ada assignment associations.  */\n+typedef std::unique_ptr<ada_association> ada_association_up;\n+\n+/* A component that holds a vector of associations and an operation.\n+   The operation is re-evaluated for each choice.  */\n+class ada_choices_component : public ada_component\n+{\n+public:\n+\n+  explicit ada_choices_component (operation_up &&op)\n+    : m_op (std::move (op))\n+  {\n+  }\n+\n+  /* Set the vector of associations.  This is done separately from the\n+     constructor because it was simpler for the implementation of the\n+     parser.  */\n+  void set_associations (std::vector<ada_association_up> &&assoc)\n+  {\n+    m_assocs = std::move (assoc);\n+  }\n+\n+  void assign (struct value *container,\n+\t       struct value *lhs, struct expression *exp,\n+\t       std::vector<LONGEST> &indices,\n+\t       LONGEST low, LONGEST high) override;\n+\n+  bool uses_objfile (struct objfile *objfile) override;\n+\n+  void dump (ui_file *stream, int depth) override;\n+\n+private:\n+\n+  std::vector<ada_association_up> m_assocs;\n+  operation_up m_op;\n+};\n+\n+/* An association that uses a discrete range.  */\n+class ada_discrete_range_association : public ada_association\n+{\n+public:\n+\n+  ada_discrete_range_association (operation_up &&low, operation_up &&high)\n+    : m_low (std::move (low)),\n+      m_high (std::move (high))\n+  {\n+  }\n+\n+  void assign (struct value *container,\n+\t       struct value *lhs, struct expression *exp,\n+\t       std::vector<LONGEST> &indices,\n+\t       LONGEST low, LONGEST high,\n+\t       operation_up &op) override;\n+\n+  bool uses_objfile (struct objfile *objfile) override;\n+\n+  void dump (ui_file *stream, int depth) override;\n+\n+private:\n+\n+  operation_up m_low;\n+  operation_up m_high;\n+};\n+\n+/* An association that uses a name.  The name may be an expression\n+   that evaluates to an integer (for arrays), or an Ada string or\n+   variable value operation.  */\n+class ada_name_association : public ada_association\n+{\n+public:\n+\n+  explicit ada_name_association (operation_up val)\n+    : m_val (std::move (val))\n+  {\n+  }\n+\n+  void assign (struct value *container,\n+\t       struct value *lhs, struct expression *exp,\n+\t       std::vector<LONGEST> &indices,\n+\t       LONGEST low, LONGEST high,\n+\t       operation_up &op) override;\n+\n+  bool uses_objfile (struct objfile *objfile) override;\n+\n+  void dump (ui_file *stream, int depth) override;\n+\n+private:\n+\n+  operation_up m_val;\n+};\n+\n } /* namespace expr */\n \n #endif /* ADA_EXP_H */"
    },
    {
      "sha": "a62cfb95f0e91651f7437d69f70c9c3cd05c7277",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 340,
      "deletions": 0,
      "changes": 340,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
      "patch": "@@ -9634,6 +9634,346 @@ aggregate_assign_others (struct value *container,\n   ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);\n }\n \n+namespace expr\n+{\n+\n+bool\n+check_objfile (const std::unique_ptr<ada_component> &comp,\n+\t       struct objfile *objfile)\n+{\n+  return comp->uses_objfile (objfile);\n+}\n+\n+/* Assign the result of evaluating ARG starting at *POS to the INDEXth\n+   component of LHS (a simple array or a record).  Does not modify the\n+   inferior's memory, nor does it modify LHS (unless LHS ==\n+   CONTAINER).  */\n+\n+static void\n+assign_component (struct value *container, struct value *lhs, LONGEST index,\n+\t\t  struct expression *exp, operation_up &arg)\n+{\n+  scoped_value_mark mark;\n+\n+  struct value *elt;\n+  struct type *lhs_type = check_typedef (value_type (lhs));\n+\n+  if (lhs_type->code () == TYPE_CODE_ARRAY)\n+    {\n+      struct type *index_type = builtin_type (exp->gdbarch)->builtin_int;\n+      struct value *index_val = value_from_longest (index_type, index);\n+\n+      elt = unwrap_value (ada_value_subscript (lhs, 1, &index_val));\n+    }\n+  else\n+    {\n+      elt = ada_index_struct_field (index, lhs, 0, value_type (lhs));\n+      elt = ada_to_fixed_value (elt);\n+    }\n+\n+  ada_aggregate_operation *ag_op\n+    = dynamic_cast<ada_aggregate_operation *> (arg.get ());\n+  if (ag_op != nullptr)\n+    ag_op->assign_aggregate (container, elt, exp);\n+  else\n+    value_assign_to_component (container, elt,\n+\t\t\t       arg->evaluate (nullptr, exp,\n+\t\t\t\t\t      EVAL_NORMAL));\n+}\n+\n+bool\n+ada_aggregate_component::uses_objfile (struct objfile *objfile)\n+{\n+  for (const auto &item : m_components)\n+    if (item->uses_objfile (objfile))\n+      return true;\n+  return false;\n+}\n+\n+void\n+ada_aggregate_component::dump (ui_file *stream, int depth)\n+{\n+  fprintf_filtered (stream, _(\"%*sAggregate\\n\"), depth, \"\");\n+  for (const auto &item : m_components)\n+    item->dump (stream, depth + 1);\n+}\n+\n+void\n+ada_aggregate_component::assign (struct value *container,\n+\t\t\t\t struct value *lhs, struct expression *exp,\n+\t\t\t\t std::vector<LONGEST> &indices,\n+\t\t\t\t LONGEST low, LONGEST high)\n+{\n+  for (auto &item : m_components)\n+    item->assign (container, lhs, exp, indices, low, high);\n+}\n+\n+void\n+ada_aggregate_operation::assign_aggregate (struct value *container,\n+\t\t\t\t\t   struct value *lhs,\n+\t\t\t\t\t   struct expression *exp)\n+{\n+  struct type *lhs_type;\n+  LONGEST low_index, high_index;\n+\n+  container = ada_coerce_ref (container);\n+  if (ada_is_direct_array_type (value_type (container)))\n+    container = ada_coerce_to_simple_array (container);\n+  lhs = ada_coerce_ref (lhs);\n+  if (!deprecated_value_modifiable (lhs))\n+    error (_(\"Left operand of assignment is not a modifiable lvalue.\"));\n+\n+  lhs_type = check_typedef (value_type (lhs));\n+  if (ada_is_direct_array_type (lhs_type))\n+    {\n+      lhs = ada_coerce_to_simple_array (lhs);\n+      lhs_type = check_typedef (value_type (lhs));\n+      low_index = lhs_type->bounds ()->low.const_val ();\n+      high_index = lhs_type->bounds ()->high.const_val ();\n+    }\n+  else if (lhs_type->code () == TYPE_CODE_STRUCT)\n+    {\n+      low_index = 0;\n+      high_index = num_visible_fields (lhs_type) - 1;\n+    }\n+  else\n+    error (_(\"Left-hand side must be array or record.\"));\n+\n+  std::vector<LONGEST> indices (4);\n+  indices[0] = indices[1] = low_index - 1;\n+  indices[2] = indices[3] = high_index + 1;\n+\n+  std::get<0> (m_storage)->assign (container, lhs, exp, indices,\n+\t\t\t\t   low_index, high_index);\n+}\n+\n+bool\n+ada_positional_component::uses_objfile (struct objfile *objfile)\n+{\n+  return m_op->uses_objfile (objfile);\n+}\n+\n+void\n+ada_positional_component::dump (ui_file *stream, int depth)\n+{\n+  fprintf_filtered (stream, _(\"%*sPositional, index = %d\\n\"),\n+\t\t    depth, \"\", m_index);\n+  m_op->dump (stream, depth + 1);\n+}\n+\n+/* Assign into the component of LHS indexed by the OP_POSITIONAL\n+   construct, given that the positions are relative to lower bound\n+   LOW, where HIGH is the upper bound.  Record the position in\n+   INDICES.  CONTAINER is as for assign_aggregate.  */\n+void\n+ada_positional_component::assign (struct value *container,\n+\t\t\t\t  struct value *lhs, struct expression *exp,\n+\t\t\t\t  std::vector<LONGEST> &indices,\n+\t\t\t\t  LONGEST low, LONGEST high)\n+{\n+  LONGEST ind = m_index + low;\n+\n+  if (ind - 1 == high)\n+    warning (_(\"Extra components in aggregate ignored.\"));\n+  if (ind <= high)\n+    {\n+      add_component_interval (ind, ind, indices);\n+      assign_component (container, lhs, ind, exp, m_op);\n+    }\n+}\n+\n+bool\n+ada_discrete_range_association::uses_objfile (struct objfile *objfile)\n+{\n+  return m_low->uses_objfile (objfile) || m_high->uses_objfile (objfile);\n+}\n+\n+void\n+ada_discrete_range_association::dump (ui_file *stream, int depth)\n+{\n+  fprintf_filtered (stream, _(\"%*sDiscrete range:\\n\"), depth, \"\");\n+  m_low->dump (stream, depth + 1);\n+  m_high->dump (stream, depth + 1);\n+}\n+\n+void\n+ada_discrete_range_association::assign (struct value *container,\n+\t\t\t\t\tstruct value *lhs,\n+\t\t\t\t\tstruct expression *exp,\n+\t\t\t\t\tstd::vector<LONGEST> &indices,\n+\t\t\t\t\tLONGEST low, LONGEST high,\n+\t\t\t\t\toperation_up &op)\n+{\n+  LONGEST lower = value_as_long (m_low->evaluate (nullptr, exp, EVAL_NORMAL));\n+  LONGEST upper = value_as_long (m_high->evaluate (nullptr, exp, EVAL_NORMAL));\n+\n+  if (lower <= upper && (lower < low || upper > high))\n+    error (_(\"Index in component association out of bounds.\"));\n+\n+  add_component_interval (lower, upper, indices);\n+  while (lower <= upper)\n+    {\n+      assign_component (container, lhs, lower, exp, op);\n+      lower += 1;\n+    }\n+}\n+\n+bool\n+ada_name_association::uses_objfile (struct objfile *objfile)\n+{\n+  return m_val->uses_objfile (objfile);\n+}\n+\n+void\n+ada_name_association::dump (ui_file *stream, int depth)\n+{\n+  fprintf_filtered (stream, _(\"%*sName:\\n\"), depth, \"\");\n+  m_val->dump (stream, depth + 1);\n+}\n+\n+void\n+ada_name_association::assign (struct value *container,\n+\t\t\t      struct value *lhs,\n+\t\t\t      struct expression *exp,\n+\t\t\t      std::vector<LONGEST> &indices,\n+\t\t\t      LONGEST low, LONGEST high,\n+\t\t\t      operation_up &op)\n+{\n+  int index;\n+\n+  if (ada_is_direct_array_type (value_type (lhs)))\n+    index = longest_to_int (value_as_long (m_val->evaluate (nullptr, exp,\n+\t\t\t\t\t\t\t    EVAL_NORMAL)));\n+  else\n+    {\n+      ada_string_operation *strop\n+\t= dynamic_cast<ada_string_operation *> (m_val.get ());\n+\n+      const char *name;\n+      if (strop != nullptr)\n+\tname = strop->get_name ();\n+      else\n+\t{\n+\t  ada_var_value_operation *vvo\n+\t    = dynamic_cast<ada_var_value_operation *> (m_val.get ());\n+\t  if (vvo != nullptr)\n+\t    error (_(\"Invalid record component association.\"));\n+\t  name = vvo->get_symbol ()->natural_name ();\n+\t}\n+\n+      index = 0;\n+      if (! find_struct_field (name, value_type (lhs), 0,\n+\t\t\t       NULL, NULL, NULL, NULL, &index))\n+\terror (_(\"Unknown component name: %s.\"), name);\n+    }\n+\n+  add_component_interval (index, index, indices);\n+  assign_component (container, lhs, index, exp, op);\n+}\n+\n+bool\n+ada_choices_component::uses_objfile (struct objfile *objfile)\n+{\n+  if (m_op->uses_objfile (objfile))\n+    return true;\n+  for (const auto &item : m_assocs)\n+    if (item->uses_objfile (objfile))\n+      return true;\n+  return false;\n+}\n+\n+void\n+ada_choices_component::dump (ui_file *stream, int depth)\n+{\n+  fprintf_filtered (stream, _(\"%*sChoices:\\n\"), depth, \"\");\n+  m_op->dump (stream, depth + 1);\n+  for (const auto &item : m_assocs)\n+    item->dump (stream, depth + 1);\n+}\n+\n+/* Assign into the components of LHS indexed by the OP_CHOICES\n+   construct at *POS, updating *POS past the construct, given that\n+   the allowable indices are LOW..HIGH.  Record the indices assigned\n+   to in INDICES.  CONTAINER is as for assign_aggregate.  */\n+void\n+ada_choices_component::assign (struct value *container,\n+\t\t\t       struct value *lhs, struct expression *exp,\n+\t\t\t       std::vector<LONGEST> &indices,\n+\t\t\t       LONGEST low, LONGEST high)\n+{\n+  for (auto &item : m_assocs)\n+    item->assign (container, lhs, exp, indices, low, high, m_op);\n+}\n+\n+bool\n+ada_others_component::uses_objfile (struct objfile *objfile)\n+{\n+  return m_op->uses_objfile (objfile);\n+}\n+\n+void\n+ada_others_component::dump (ui_file *stream, int depth)\n+{\n+  fprintf_filtered (stream, _(\"%*sOthers:\\n\"), depth, \"\");\n+  m_op->dump (stream, depth + 1);\n+}\n+\n+/* Assign the value of the expression in the OP_OTHERS construct in\n+   EXP at *POS into the components of LHS indexed from LOW .. HIGH that\n+   have not been previously assigned.  The index intervals already assigned\n+   are in INDICES.  CONTAINER is as for assign_aggregate.  */\n+void\n+ada_others_component::assign (struct value *container,\n+\t\t\t      struct value *lhs, struct expression *exp,\n+\t\t\t      std::vector<LONGEST> &indices,\n+\t\t\t      LONGEST low, LONGEST high)\n+{\n+  int num_indices = indices.size ();\n+  for (int i = 0; i < num_indices - 2; i += 2)\n+    {\n+      for (LONGEST ind = indices[i + 1] + 1; ind < indices[i + 2]; ind += 1)\n+\tassign_component (container, lhs, ind, exp, m_op);\n+    }\n+}\n+\n+struct value *\n+ada_assign_operation::evaluate (struct type *expect_type,\n+\t\t\t\tstruct expression *exp,\n+\t\t\t\tenum noside noside)\n+{\n+  value *arg1 = std::get<0> (m_storage)->evaluate (nullptr, exp, noside);\n+\n+  ada_aggregate_operation *ag_op\n+    = dynamic_cast<ada_aggregate_operation *> (std::get<1> (m_storage).get ());\n+  if (ag_op != nullptr)\n+    {\n+      if (noside != EVAL_NORMAL)\n+\treturn arg1;\n+\n+      ag_op->assign_aggregate (arg1, arg1, exp);\n+      return ada_value_assign (arg1, arg1);\n+    }\n+  /* Force the evaluation of the rhs ARG2 to the type of the lhs ARG1,\n+     except if the lhs of our assignment is a convenience variable.\n+     In the case of assigning to a convenience variable, the lhs\n+     should be exactly the result of the evaluation of the rhs.  */\n+  struct type *type = value_type (arg1);\n+  if (VALUE_LVAL (arg1) == lval_internalvar)\n+    type = NULL;\n+  value *arg2 = std::get<1> (m_storage)->evaluate (type, exp, noside);\n+  if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)\n+    return arg1;\n+  if (VALUE_LVAL (arg1) == lval_internalvar)\n+    {\n+      /* Nothing.  */\n+    }\n+  else\n+    arg2 = coerce_for_assign (value_type (arg1), arg2);\n+  return ada_value_assign (arg1, arg2);\n+}\n+\n+} /* namespace expr */\n+\n /* Add the interval [LOW .. HIGH] to the sorted set of intervals\n    [ INDICES[0] .. INDICES[1] ],...  The resulting intervals do not\n    overlap.  */"
    },
    {
      "sha": "9a9c6bc2b199e0cf0ac2ee3ad6dd758e34c3b69b",
      "filename": "gdb/expop.h",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/expop.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/expop.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expop.h?ref=a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
      "patch": "@@ -207,6 +207,8 @@ extern struct value *eval_binop_assign_modify (struct type *expect_type,\n namespace expr\n {\n \n+class ada_component;\n+\n /* The check_objfile overloads are used to check whether a particular\n    component of some operation references an objfile.  The passed-in\n    objfile will never be a debug objfile.  */\n@@ -306,6 +308,9 @@ check_objfile (const std::pair<S, T> &item, struct objfile *objfile)\n \t  || check_objfile (item.second, objfile));\n }\n \n+extern bool check_objfile (const std::unique_ptr<ada_component> &comp,\n+\t\t\t   struct objfile *objfile);\n+\n static inline void\n dump_for_expression (struct ui_file *stream, int depth,\n \t\t     const operation_up &op)\n@@ -337,6 +342,8 @@ extern void dump_for_expression (struct ui_file *stream, int depth,\n \t\t\t\t enum range_flag flags);\n extern void dump_for_expression (struct ui_file *stream, int depth,\n \t\t\t\t objfile *objf);\n+extern void dump_for_expression (struct ui_file *stream, int depth,\n+\t\t\t\t const std::unique_ptr<ada_component> &comp);\n \n template<typename T>\n void"
    },
    {
      "sha": "92a3ab87ef02d831ce5537324053e65b599b359d",
      "filename": "gdb/expprint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/expprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a88c43542dfa0eb5606613cb8ac249bdb1d61b13/gdb/expprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expprint.c?ref=a88c43542dfa0eb5606613cb8ac249bdb1d61b13",
      "patch": "@@ -32,6 +32,7 @@\n #include \"cli/cli-style.h\"\n #include \"c-lang.h\"\n #include \"expop.h\"\n+#include \"ada-exp.h\"\n \n #include <ctype.h>\n \n@@ -1283,6 +1284,13 @@ dump_for_expression (struct ui_file *stream, int depth,\n   fprintf_filtered (stream, \"\\n\");\n }\n \n+void\n+dump_for_expression (struct ui_file *stream, int depth,\n+\t\t     const std::unique_ptr<ada_component> &comp)\n+{\n+  comp->dump (stream, depth);\n+}\n+\n void\n float_const_operation::dump (struct ui_file *stream, int depth) const\n {"
    }
  ]
}