{
  "sha": "aef6d006581cab8a858e7abd36c57e73ea6e97a2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWVmNmQwMDY1ODFjYWI4YTg1OGU3YWJkMzZjNTdlNzNlYTZlOTdhMg==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T13:05:38Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T15:37:24Z"
    },
    "message": "[PATCH 42/57][Arm][OBJDUMP] Add support for MVE instructions: vldr[bhw] and vstr[bhw]\n\nopcodes/ChangeLog:\n2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t    Michael Collison <michael.collison@arm.com>\n\n\t* arm-dis.c (enum mve_instructions): Add new instructions.\n\t(enum mve_undefined): Add new reasons.\n\t(insns): Add new instructions.\n\t(is_mve_encoding_conflict):\n\t(print_mve_vld_str_addr): New print function.\n\t(is_mve_undefined): Handle new instructions.\n\t(is_mve_unpredictable): Likewise.\n\t(print_mve_undefined): Likewise.\n\t(print_mve_size): Likewise.\n\t(print_insn_coprocessor_1): Handle MVE VLDR, VSTR instructions.\n\t(print_insn_mve):  Handle new operands.",
    "tree": {
      "sha": "b6924835bc2e675ee030a6a5d2235d0075e1b4fa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b6924835bc2e675ee030a6a5d2235d0075e1b4fa"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/aef6d006581cab8a858e7abd36c57e73ea6e97a2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aef6d006581cab8a858e7abd36c57e73ea6e97a2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/aef6d006581cab8a858e7abd36c57e73ea6e97a2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aef6d006581cab8a858e7abd36c57e73ea6e97a2/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "04d54ace12e77deb8b1d26541de0f2cbc11880f5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/04d54ace12e77deb8b1d26541de0f2cbc11880f5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/04d54ace12e77deb8b1d26541de0f2cbc11880f5"
    }
  ],
  "stats": {
    "total": 278,
    "additions": 278,
    "deletions": 0
  },
  "files": [
    {
      "sha": "3fd0227205cde57b5585187b044953a9d7eae681",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aef6d006581cab8a858e7abd36c57e73ea6e97a2/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aef6d006581cab8a858e7abd36c57e73ea6e97a2/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=aef6d006581cab8a858e7abd36c57e73ea6e97a2",
      "patch": "@@ -1,3 +1,18 @@\n+2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Michael Collison <michael.collison@arm.com>\n+\n+\t* arm-dis.c (enum mve_instructions): Add new instructions.\n+\t(enum mve_undefined): Add new reasons.\n+\t(insns): Add new instructions.\n+\t(is_mve_encoding_conflict):\n+\t(print_mve_vld_str_addr): New print function.\n+\t(is_mve_undefined): Handle new instructions.\n+\t(is_mve_unpredictable): Likewise.\n+\t(print_mve_undefined): Likewise.\n+\t(print_mve_size): Likewise.\n+\t(print_insn_coprocessor_1): Handle MVE VLDR, VSTR instructions.\n+\t(print_insn_mve):  Handle new operands.\n+\n 2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Michael Collison <michael.collison@arm.com>\n "
    },
    {
      "sha": "6d167ae0860910f59ff4ab20b4761af413d1d65b",
      "filename": "opcodes/arm-dis.c",
      "status": "modified",
      "additions": 263,
      "deletions": 0,
      "changes": 263,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aef6d006581cab8a858e7abd36c57e73ea6e97a2/opcodes/arm-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aef6d006581cab8a858e7abd36c57e73ea6e97a2/opcodes/arm-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arm-dis.c?ref=aef6d006581cab8a858e7abd36c57e73ea6e97a2",
      "patch": "@@ -102,6 +102,16 @@ enum mve_instructions\n   MVE_VLD4,\n   MVE_VST2,\n   MVE_VST4,\n+  MVE_VLDRB_T1,\n+  MVE_VLDRH_T2,\n+  MVE_VLDRB_T5,\n+  MVE_VLDRH_T6,\n+  MVE_VLDRW_T7,\n+  MVE_VSTRB_T1,\n+  MVE_VSTRH_T2,\n+  MVE_VSTRB_T5,\n+  MVE_VSTRH_T6,\n+  MVE_VSTRW_T7,\n   MVE_NONE\n };\n \n@@ -126,6 +136,8 @@ enum mve_unpredictable\n enum mve_undefined\n {\n   UNDEF_SIZE_3,\t\t\t/* undefined because size == 3.  */\n+  UNDEF_SIZE_3,\t\t\t/* undefined because size == 3.  */\n+  UNDEF_SIZE_LE_1,\t\t/* undefined because size <= 1.  */\n   UNDEF_NONE\t\t\t/* no undefined behavior.  */\n };\n \n@@ -1829,6 +1841,8 @@ static const struct opcode32 neon_opcodes[] =\n    %%\t\t\t%\n \n    %c\t\t\tprint condition code\n+   %d\t\t\tprint addr mode of MVE vldr[bhw] and vstr[bhw]\n+   %u\t\t\tprint 'U' (unsigned) or 'S' for various mve instructions\n    %i\t\t\tprint MVE predicate(s) for vpt and vpst\n    %n\t\t\tprint vector comparison code for predicated instruction\n    %v\t\t\tprint vector predicate for instruction in predicated\n@@ -2023,6 +2037,36 @@ static const struct mopcode32 mve_opcodes[] =\n    0xfc901e01, 0xff901e1f,\n    \"vld4%5-6d.%7-8s\\t%B, [%16-19r]%w\"},\n \n+  /* Vector VLDRB.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VLDRB_T1,\n+   0xec100e00, 0xee581e00,\n+   \"vldrb%v.%u%7-8s\\t%13-15Q, %d\"},\n+\n+  /* Vector VLDRH.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VLDRH_T2,\n+   0xec180e00, 0xee581e00,\n+   \"vldrh%v.%u%7-8s\\t%13-15Q, %d\"},\n+\n+  /* Vector VLDRB unsigned, variant T5.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VLDRB_T5,\n+   0xec101e00, 0xfe101f80,\n+   \"vldrb%v.u8\\t%13-15,22Q, %d\"},\n+\n+  /* Vector VLDRH unsigned, variant T6.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VLDRH_T6,\n+   0xec101e80, 0xfe101f80,\n+   \"vldrh%v.u16\\t%13-15,22Q, %d\"},\n+\n+  /* Vector VLDRW unsigned, variant T7.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VLDRW_T7,\n+   0xec101f00, 0xfe101f80,\n+   \"vldrw%v.u32\\t%13-15,22Q, %d\"},\n+\n   /* Vector VST2 no writeback.  */\n   {ARM_FEATURE_COPROC (FPU_MVE),\n    MVE_VST2,\n@@ -2047,6 +2091,36 @@ static const struct mopcode32 mve_opcodes[] =\n    0xfca01e01, 0xffb01e1f,\n    \"vst4%5-6d.%7-8s\\t%B, [%16-19r]!\"},\n \n+  /* Vector VSTRB.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VSTRB_T1,\n+   0xec000e00, 0xfe581e00,\n+   \"vstrb%v.%7-8s\\t%13-15Q, %d\"},\n+\n+  /* Vector VSTRH.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VSTRH_T2,\n+   0xec080e00, 0xfe581e00,\n+   \"vstrh%v.%7-8s\\t%13-15Q, %d\"},\n+\n+  /* Vector VSTRB variant T5.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VSTRB_T5,\n+   0xec001e00, 0xfe101f80,\n+   \"vstrb%v.8\\t%13-15,22Q, %d\"},\n+\n+  /* Vector VSTRH variant T6.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VSTRH_T6,\n+   0xec001e80, 0xfe101f80,\n+   \"vstrh%v.16\\t%13-15,22Q, %d\"},\n+\n+  /* Vector VSTRW variant T7.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VSTRW_T7,\n+   0xec001f00, 0xfe101f80,\n+   \"vstrw%v.32\\t%13-15,22Q, %d\"},\n+\n   {ARM_FEATURE_CORE_LOW (0),\n    MVE_NONE,\n    0x00000000, 0x00000000, 0}\n@@ -4074,12 +4148,109 @@ is_mve_encoding_conflict (unsigned long given,\n       else\n \treturn FALSE;\n \n+    case MVE_VSTRB_T1:\n+    case MVE_VSTRH_T2:\n+      if ((arm_decode_field (given, 24, 24) == 0)\n+\t  && (arm_decode_field (given, 21, 21) == 0))\n+\t{\n+\t    return TRUE;\n+\t}\n+      else if ((arm_decode_field (given, 7, 8) == 3))\n+\treturn TRUE;\n+      else\n+\treturn FALSE;\n+\n+    case MVE_VSTRB_T5:\n+    case MVE_VSTRH_T6:\n+    case MVE_VSTRW_T7:\n+      if ((arm_decode_field (given, 24, 24) == 0)\n+\t  && (arm_decode_field (given, 21, 21) == 0))\n+\t{\n+\t    return TRUE;\n+\t}\n+      else\n+\treturn FALSE;\n+\n     default:\n       return FALSE;\n \n     }\n }\n \n+static void\n+print_mve_vld_str_addr (struct disassemble_info *info,\n+\t\t\tunsigned long given,\n+\t\t\tenum mve_instructions matched_insn)\n+{\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+\n+  unsigned long p, w, gpr, imm, add, mod_imm;\n+\n+  imm = arm_decode_field (given, 0, 6);\n+  mod_imm = imm;\n+\n+  switch (matched_insn)\n+    {\n+    case MVE_VLDRB_T1:\n+    case MVE_VSTRB_T1:\n+      gpr = arm_decode_field (given, 16, 18);\n+      break;\n+\n+    case MVE_VLDRH_T2:\n+    case MVE_VSTRH_T2:\n+      gpr = arm_decode_field (given, 16, 18);\n+      mod_imm = imm << 1;\n+      break;\n+\n+    case MVE_VLDRH_T6:\n+    case MVE_VSTRH_T6:\n+      gpr = arm_decode_field (given, 16, 19);\n+      mod_imm = imm << 1;\n+      break;\n+\n+    case MVE_VLDRW_T7:\n+    case MVE_VSTRW_T7:\n+      gpr = arm_decode_field (given, 16, 19);\n+      mod_imm = imm << 2;\n+      break;\n+\n+    case MVE_VLDRB_T5:\n+    case MVE_VSTRB_T5:\n+      gpr = arm_decode_field (given, 16, 19);\n+      break;\n+\n+    default:\n+      return;\n+    }\n+\n+  p = arm_decode_field (given, 24, 24);\n+  w = arm_decode_field (given, 21, 21);\n+\n+  add = arm_decode_field (given, 23, 23);\n+\n+  char * add_sub;\n+\n+  /* Don't print anything for '+' as it is implied.  */\n+  if (add == 1)\n+    add_sub = \"\";\n+  else\n+    add_sub = \"-\";\n+\n+  if (p == 1)\n+    {\n+      /* Offset mode.  */\n+      if (w == 0)\n+\tfunc (stream, \"[%s, #%s%lu]\", arm_regnames[gpr], add_sub, mod_imm);\n+      /* Pre-indexed mode.  */\n+      else\n+\tfunc (stream, \"[%s, #%s%lu]!\", arm_regnames[gpr], add_sub, mod_imm);\n+    }\n+  else if ((p == 0) && (w == 1))\n+    /* Post-index mode.  */\n+    func (stream, \"[%s], #%s%lu\", arm_regnames[gpr], add_sub, mod_imm);\n+}\n+\n /* Return FALSE if GIVEN is not an undefined encoding for MATCHED_INSN.\n    Otherwise, return TRUE and set UNDEFINED_CODE to give a reason as to why\n    this encoding is undefined.  */\n@@ -4112,6 +4283,42 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n       else\n \treturn FALSE;\n \n+    case MVE_VLDRB_T1:\n+      if (arm_decode_field (given, 7, 8) == 3)\n+\t{\n+\t  *undefined_code = UNDEF_SIZE_3;\n+\t  return TRUE;\n+\t}\n+      else\n+\treturn FALSE;\n+\n+    case MVE_VLDRH_T2:\n+      if (arm_decode_field (given, 7, 8) <= 1)\n+\t{\n+\t  *undefined_code = UNDEF_SIZE_LE_1;\n+\t  return TRUE;\n+\t}\n+      else\n+\treturn FALSE;\n+\n+    case MVE_VSTRB_T1:\n+      if ((arm_decode_field (given, 7, 8) == 0))\n+\t{\n+\t  *undefined_code = UNDEF_SIZE_0;\n+\t  return TRUE;\n+\t}\n+      else\n+\treturn FALSE;\n+\n+    case MVE_VSTRH_T2:\n+      if ((arm_decode_field (given, 7, 8) <= 1))\n+\t{\n+\t  *undefined_code = UNDEF_SIZE_LE_1;\n+\t  return TRUE;\n+\t}\n+      else\n+\treturn FALSE;\n+\n     default:\n       return FALSE;\n     }\n@@ -4243,6 +4450,29 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \t  return FALSE;\n       }\n \n+    case MVE_VLDRB_T5:\n+    case MVE_VLDRH_T6:\n+    case MVE_VLDRW_T7:\n+    case MVE_VSTRB_T5:\n+    case MVE_VSTRH_T6:\n+    case MVE_VSTRW_T7:\n+      {\n+\tunsigned long rn = arm_decode_field (given, 16, 19);\n+\n+\tif ((rn == 0xd) && (arm_decode_field (given, 21, 21) == 1))\n+\t  {\n+\t    *unpredictable_code = UNPRED_R13_AND_WB;\n+\t    return TRUE;\n+\t  }\n+\telse if (rn == 0xf)\n+\t  {\n+\t    *unpredictable_code = UNPRED_R15;\n+\t    return TRUE;\n+\t  }\n+\telse\n+\t  return FALSE;\n+      }\n+\n     default:\n       return FALSE;\n     }\n@@ -4259,10 +4489,18 @@ print_mve_undefined (struct disassemble_info *info,\n \n   switch (undefined_code)\n     {\n+    case UNDEF_SIZE_0:\n+      func (stream, \"size equals zero\");\n+      break;\n+\n     case UNDEF_SIZE_3:\n       func (stream, \"size equals three\");\n       break;\n \n+    case UNDEF_SIZE_LE_1:\n+      func (stream, \"size <= 1\");\n+      break;\n+\n     case UNDEF_NONE:\n       break;\n     }\n@@ -4385,6 +4623,8 @@ print_mve_size (struct disassemble_info *info,\n     case MVE_VHSUB_T2:\n     case MVE_VLD2:\n     case MVE_VLD4:\n+    case MVE_VLDRB_T1:\n+    case MVE_VLDRH_T2:\n     case MVE_VPT_VEC_T1:\n     case MVE_VPT_VEC_T2:\n     case MVE_VPT_VEC_T3:\n@@ -4394,6 +4634,8 @@ print_mve_size (struct disassemble_info *info,\n     case MVE_VRHADD:\n     case MVE_VST2:\n     case MVE_VST4:\n+    case MVE_VSTRB_T1:\n+    case MVE_VSTRH_T2:\n       if (size <= 3)\n \tfunc (stream, \"%s\", mve_vec_sizename[size]);\n       else\n@@ -4646,6 +4888,15 @@ print_insn_coprocessor (bfd_vma pc,\n \t      && (cp_num == 8 || cp_num == 14 || cp_num == 15))\n \t    continue;\n \t}\n+      else if ((insn->value == 0xec100f80      /* vldr (system register) */\n+\t\t|| insn->value == 0xec000f80)  /* vstr (system register) */\n+\t       && arm_decode_field (given, 24, 24) == 0\n+\t       && arm_decode_field (given, 21, 21) == 0)\n+\t/* If the P and W bits are both 0 then these encodings match the MVE\n+\t   VLDR and VSTR instructions, these are in a different table, so we\n+\t   don't let it match here.  */\n+\tcontinue;\n+\n \n       for (c = insn->assembler; *c; c++)\n \t{\n@@ -5871,6 +6122,10 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t\t\tfunc (stream, \"%s\", arm_conditional[IFTHEN_COND]);\n \t\t      break;\n \n+\t\t    case 'd':\n+\t\t      print_mve_vld_str_addr (info, given, insn->mve_op);\n+\t\t      break;\n+\n \t\t    case 'i':\n \t\t      {\n \t\t\tlong mve_mask = mve_extract_pred_mask (given);\n@@ -5882,6 +6137,14 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t\t      print_vec_condition (info, given, insn->mve_op);\n \t\t      break;\n \n+\t\t    case 'u':\n+\t\t      {\n+\t\t\tif (arm_decode_field (given, 28, 28) == 0)\n+\t\t\t  func (stream, \"s\");\n+\t\t\telse\n+\t\t\t  func (stream, \"u\");\n+\t\t      }\n+\n \t\t    case 'v':\n \t\t      print_instruction_predicate (info);\n \t\t      break;"
    }
  ]
}