{
  "sha": "c29705b71a8ec966478c0dc4712194a95291c6de",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzI5NzA1YjcxYThlYzk2NjQ3OGMwZGM0NzEyMTk0YTk1MjkxYzZkZQ==",
  "commit": {
    "author": {
      "name": "Philippe Waroquiers",
      "email": "philippe.waroquiers@skynet.be",
      "date": "2019-03-24T14:14:55Z"
    },
    "committer": {
      "name": "Philippe Waroquiers",
      "email": "philippe.waroquiers@skynet.be",
      "date": "2019-04-01T18:51:59Z"
    },
    "message": "Fix internal error and improve 'set debug infrun 1'/target wait kind trace\n\nThe test  gdb.threads/watchthreads-reorder.exp verifies that the\n'set debug infrun 1' debug output does not crash GDB.\n\nUnder high load, the test can still cause a GDB internal error (see details\nbelow).\n\nThis patch fixes this crash, and improves/factorises some wait kind traces.\n\nTested on debian/amd64 + run one test with 'set debug infrun 1'.\n\nChanges compared to the first version:\n  * Handles the suggestions of Kevin to trace the relevant elements\n    of the wait status (this is done by calling target_waitstatus_to_string).\n  * Some other changes to factorise wait status tracing.\n\nNote that using target_waitstatus_to_string instead of the 'locally printed'\nstatus kind strings means that debug trace that was using strings such as:\n   \"EXITED\" or \"TARGET_WAITKIND_EXITED\"\nwill now use what is printed by target_waitstatus_to_string e.g.\n   \"exited\".\n\ngdb/ChangeLog\n2019-04-01  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n\n\t* infrun.c (stop_all_threads): If debug_infrun, always\n\ttrace the wait status after wait_one, using\n\ttarget_waitstatus_to_string and target_pid_to_str.\n\t(handle_inferior_event): Replace various trace of\n\twait status kind by a single trace.\n\t* gdb/gnu-nat.c (gnu_nat_target::wait): Replace local\n\twait status kind image by target_waitstatus_to_string.\n\t* target/waitstatus.c (target_waitstatus_to_string): Fix\n\tobsolete comment.\n\n  (top-gdb) bt\n  #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51\n  #1  0x00007f3d54a0642a in __GI_abort () at abort.c:89\n  #2  0x0000555c24c60e66 in dump_core () at ../../fixleaks/gdb/utils.c:201\n  #3  0x0000555c24c63d49 in internal_vproblem(internal_problem *, const char *, int, const char *, typedef __va_list_tag __va_list_tag *) (problem=problem@entry=0x555c25338d40 <internal_error_problem>, file=<optimized out>, line=287,\n      fmt=<optimized out>, ap=<optimized out>) at ../../fixleaks/gdb/utils.c:411\n  #4  0x0000555c24c63eab in internal_verror (file=<optimized out>, line=<optimized out>, fmt=<optimized out>,\n      ap=<optimized out>) at ../../fixleaks/gdb/utils.c:436\n  #5  0x0000555c249e8c22 in internal_error (file=file@entry=0x555c24e0f2ad \"../../fixleaks/gdb/inferior.c\",\n      line=line@entry=287, fmt=<optimized out>) at ../../fixleaks/gdb/common/errors.c:55\n  #6  0x0000555c247d3f5c in find_inferior_pid (pid=<optimized out>) at ../../fixleaks/gdb/inferior.c:287\n  #7  0x0000555c24ad2248 in find_inferior_pid (pid=<optimized out>) at ../../fixleaks/gdb/inferior.c:302\n  #8  find_inferior_ptid (ptid=...) at ../../fixleaks/gdb/inferior.c:301\n  #9  0x0000555c24c35f25 in find_thread_ptid (ptid=...) at ../../fixleaks/gdb/thread.c:522\n  #10 0x0000555c24b0ab4d in thread_db_target::pid_to_str[abi:cxx11](ptid_t) (\n      this=0x555c2532e3e0 <the_thread_db_target>, ptid=...) at ../../fixleaks/gdb/linux-thread-db.c:1637\n  #11 0x0000555c24c2f420 in target_pid_to_str[abi:cxx11](ptid_t) (ptid=...) at ../../fixleaks/gdb/target.c:2083\n  #12 0x0000555c24ad9cab in stop_all_threads () at ../../fixleaks/gdb/infrun.c:4373\n  #13 0x0000555c24ada00f in stop_waiting (ecs=<optimized out>) at ../../fixleaks/gdb/infrun.c:7464\n  #14 0x0000555c24adc401 in process_event_stop_test (ecs=ecs@entry=0x7ffc9402d9d0) at ../../fixleaks/gdb/infrun.c:6181\n  ...\n  (top-gdb) fr 12\n  #12 0x0000555c24ad9cab in stop_all_threads () at ../../fixleaks/gdb/infrun.c:4373\n  (top-gdb) p event_ptid\n  $5 = {m_pid = 25419, m_lwp = 25427, m_tid = 0}\n  (top-gdb) p ptid\n  $6 = {m_pid = 0, m_lwp = 0, m_tid = 0}\n  (top-gdb) p ws\n  $7 = {kind = TARGET_WAITKIND_THREAD_EXITED, value = {integer = 0, sig = GDB_SIGNAL_0, related_pid = {m_pid = 0,\n        m_lwp = 0, m_tid = 0}, execd_pathname = 0x0, syscall_number = 0}}\n  (top-gdb)\n\nThe gdb.log corresponding to the above crash is:\n  (gdb) PASS: gdb.threads/watchthreads-reorder.exp: reorder1: set debug infrun 1\n  continue\n  Continuing.\n  infrun: clear_proceed_status_thread (Thread 0x7ffff7fcfb40 (LWP 25419))\n  infrun: clear_proceed_status_thread (Thread 0x7ffff7310700 (LWP 25427))\n  infrun: clear_proceed_status_thread (Thread 0x7ffff6b0f700 (LWP 25428))\n  infrun: proceed (addr=0xffffffffffffffff, signal=GDB_SIGNAL_DEFAULT)\n  infrun: proceed: resuming Thread 0x7ffff7fcfb40 (LWP 25419)\n  infrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [Thread 0x7ffff7fcfb40 (LWP 25419)] at 0x7ffff7344317\n  infrun: infrun_async(1)\n  infrun: prepare_to_wait\n  infrun: proceed: resuming Thread 0x7ffff7310700 (LWP 25427)\n  infrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [Thread 0x7ffff7310700 (LWP 25427)] at 0x5555555553d7\n  infrun: prepare_to_wait\n  infrun: proceed: resuming Thread 0x7ffff6b0f700 (LWP 25428)\n  infrun: resume (step=0, signal=GDB_SIGNAL_0), trap_expected=0, current thread [Thread 0x7ffff6b0f700 (LWP 25428)] at 0x5555555554c8\n  infrun: prepare_to_wait\n  infrun: target_wait (-1.0.0, status) =\n  infrun:   -1.0.0 [process -1],\n  infrun:   status->kind = ignore\n  infrun: TARGET_WAITKIND_IGNORE\n  infrun: prepare_to_wait\n  Joining the threads.\n  [Thread 0x7ffff6b0f700 (LWP 25428) exited]\n  infrun: target_wait (-1.0.0, status) =\n  infrun:   -1.0.0 [process -1],\n  infrun:   status->kind = ignore\n  infrun: TARGET_WAITKIND_IGNORE\n  infrun: prepare_to_wait\n  infrun: target_wait (-1.0.0, status) =\n  infrun:   25419.25419.0 [Thread 0x7ffff7fcfb40 (LWP 25419)],\n  infrun:   status->kind = stopped, signal = GDB_SIGNAL_TRAP\n  infrun: TARGET_WAITKIND_STOPPED\n  infrun: stop_pc = 0x555555555e50\n  infrun: context switch\n  infrun: Switching context from Thread 0x7ffff6b0f700 (LWP 25428) to Thread 0x7ffff7fcfb40 (LWP 25419)\n  infrun: BPSTAT_WHAT_STOP_NOISY\n  infrun: stop_waiting\n  infrun: stop_all_threads\n  infrun: stop_all_threads, pass=0, iterations=0\n  infrun:   Thread 0x7ffff7fcfb40 (LWP 25419) not executing\n  infrun:   Thread 0x7ffff7310700 (LWP 25427) executing, need stop\n  [Thread 0x7ffff7310700 (LWP 25427) exited]\n  infrun: target_wait (-1.0.0, status) =\n  infrun:   25419.25427.0 [LWP 25427],\n  infrun:   status->kind = thread exited, status = 0\n  infrun: infrun_async(0)\n  ../../fixleaks/gdb/inferior.c:287: internal-error: inferior* find_inferior_pid(int): Assertion `pid != 0' failed.\n  A problem internal to GDB has been detected,\n  further debugging may prove unreliable.\n  Quit this debugging session? (y or n) FAIL: gdb.threads/watchthreads-reorder.exp: reorder1: continue to breakpoint: break-at-exit (GDB internal error)\n  Resyncing due to internal error.\n  n\n  infrun: infrun_async(1)\n\n  This is a bug, please report it.  For instructions, see:\n  <http://www.gnu.org/software/gdb/bugs/>.\n\n  infrun: infrun_async(0)\n  ../../fixleaks/gdb/inferior.c:287: internal-error: inferior* find_inferior_pid(int): Assertion `pid != 0' failed.\n  A problem internal to GDB has been detected,\n  further debugging may prove unreliable.\n  Create a core file of GDB? (y or n) y",
    "tree": {
      "sha": "b9dcea1eac88e04a4d32e7610183028db57a342c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b9dcea1eac88e04a4d32e7610183028db57a342c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c29705b71a8ec966478c0dc4712194a95291c6de",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c29705b71a8ec966478c0dc4712194a95291c6de",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c29705b71a8ec966478c0dc4712194a95291c6de",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c29705b71a8ec966478c0dc4712194a95291c6de/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "05caa1d236440cd8967f8804be8dbcf27fb490b6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/05caa1d236440cd8967f8804be8dbcf27fb490b6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/05caa1d236440cd8967f8804be8dbcf27fb490b6"
    }
  ],
  "stats": {
    "total": 103,
    "additions": 31,
    "deletions": 72
  },
  "files": [
    {
      "sha": "ce9c573a8ef73632ee3ce2d858bbf94eed41dfb2",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c29705b71a8ec966478c0dc4712194a95291c6de/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c29705b71a8ec966478c0dc4712194a95291c6de/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c29705b71a8ec966478c0dc4712194a95291c6de",
      "patch": "@@ -1,3 +1,15 @@\n+2019-04-01  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n+\n+\t* infrun.c (stop_all_threads): If debug_infrun, always\n+\ttrace the wait status after wait_one, using\n+\ttarget_waitstatus_to_string and target_pid_to_str.\n+\t(handle_inferior_event): Replace various trace of\n+\twait status kind by a single trace.\n+\t* gdb/gnu-nat.c (gnu_nat_target::wait): Replace local\n+\twait status kind image by target_waitstatus_to_string.\n+\t* target/waitstatus.c (target_waitstatus_to_string): Fix\n+\tobsolete comment.\n+\n 2019-04-01  Tom Tromey  <tromey@adacore.com>\n \n \tPR symtab/23331:"
    },
    {
      "sha": "654a652717008d1fd210d652f17516d7313b9b2f",
      "filename": "gdb/gnu-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 8,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c29705b71a8ec966478c0dc4712194a95291c6de/gdb/gnu-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c29705b71a8ec966478c0dc4712194a95291c6de/gdb/gnu-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.c?ref=c29705b71a8ec966478c0dc4712194a95291c6de",
      "patch": "@@ -1647,15 +1647,9 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n       inf_update_suspends (inf);\n     }\n \n-  inf_debug (inf, \"returning ptid = %s, status = %s (%d)\",\n+  inf_debug (inf, \"returning ptid = %s, %s\",\n \t     target_pid_to_str (ptid).c_str (),\n-\t     status->kind == TARGET_WAITKIND_EXITED ? \"EXITED\"\n-\t     : status->kind == TARGET_WAITKIND_STOPPED ? \"STOPPED\"\n-\t     : status->kind == TARGET_WAITKIND_SIGNALLED ? \"SIGNALLED\"\n-\t     : status->kind == TARGET_WAITKIND_LOADED ? \"LOADED\"\n-\t     : status->kind == TARGET_WAITKIND_SPURIOUS ? \"SPURIOUS\"\n-\t     : \"?\",\n-\t     status->value.integer);\n+\t     target_waitstatus_to_string (&status).c_str ());\n \n   return ptid;\n }"
    },
    {
      "sha": "282674116973a7bd0d18a493f2149f2284b82124",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 16,
      "deletions": 62,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c29705b71a8ec966478c0dc4712194a95291c6de/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c29705b71a8ec966478c0dc4712194a95291c6de/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=c29705b71a8ec966478c0dc4712194a95291c6de",
      "patch": "@@ -4358,24 +4358,21 @@ stop_all_threads (void)\n \t    pass = -1;\n \n \t  event_ptid = wait_one (&ws);\n-\n-\t  if (ws.kind == TARGET_WAITKIND_NO_RESUMED)\n+\t  if (debug_infrun)\n \t    {\n-\t      /* All resumed threads exited.  */\n+\t      fprintf_unfiltered (gdb_stdlog,\n+\t\t\t\t  \"infrun: stop_all_threads %s %s\\n\",\n+\t\t\t\t  target_waitstatus_to_string (&ws).c_str (),\n+\t\t\t\t  target_pid_to_str (event_ptid).c_str ());\n \t    }\n-\t  else if (ws.kind == TARGET_WAITKIND_THREAD_EXITED\n-\t\t   || ws.kind == TARGET_WAITKIND_EXITED\n-\t\t   || ws.kind == TARGET_WAITKIND_SIGNALLED)\n-\t    {\n-\t      if (debug_infrun)\n-\t\t{\n-\t\t  ptid_t ptid = ptid_t (ws.value.integer);\n \n-\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t      \"infrun: %s exited while \"\n-\t\t\t\t      \"stopping threads\\n\",\n-\t\t\t\t      target_pid_to_str (ptid).c_str ());\n-\t\t}\n+\t  if (ws.kind == TARGET_WAITKIND_NO_RESUMED\n+\t      || ws.kind == TARGET_WAITKIND_THREAD_EXITED\n+\t      || ws.kind == TARGET_WAITKIND_EXITED\n+\t      || ws.kind == TARGET_WAITKIND_SIGNALLED)\n+\t    {\n+\t      /* All resumed threads exited\n+\t\t or one thread/process exited/signalled.  */\n \t    }\n \t  else\n \t    {\n@@ -4604,6 +4601,10 @@ handle_inferior_event (struct execution_control_state *ecs)\n \n   enum stop_kind stop_soon;\n \n+  if (debug_infrun)\n+    fprintf_unfiltered (gdb_stdlog, \"infrun: handle_inferior_event %s\\n\",\n+\t\t\ttarget_waitstatus_to_string (&ecs->ws).c_str ());\n+\n   if (ecs->ws.kind == TARGET_WAITKIND_IGNORE)\n     {\n       /* We had an event in the inferior, but we are not interested in\n@@ -4615,16 +4616,12 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t not stopped, and we are ignoring the event.  Another possible\n \t circumstance is any event which the lower level knows will be\n \t reported multiple times without an intervening resume.  */\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_IGNORE\\n\");\n       prepare_to_wait (ecs);\n       return;\n     }\n \n   if (ecs->ws.kind == TARGET_WAITKIND_THREAD_EXITED)\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_THREAD_EXITED\\n\");\n       prepare_to_wait (ecs);\n       return;\n     }\n@@ -4643,9 +4640,6 @@ handle_inferior_event (struct execution_control_state *ecs)\n     {\n       /* No unwaited-for children left.  IOW, all resumed children\n \t have exited.  */\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_NO_RESUMED\\n\");\n-\n       stop_print_frame = 0;\n       stop_waiting (ecs);\n       return;\n@@ -4738,8 +4732,6 @@ handle_inferior_event (struct execution_control_state *ecs)\n   switch (ecs->ws.kind)\n     {\n     case TARGET_WAITKIND_LOADED:\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_LOADED\\n\");\n       context_switch (ecs);\n       /* Ignore gracefully during startup of the inferior, as it might\n          be the shell which has just loaded some objects, otherwise\n@@ -4817,8 +4809,6 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t\t      _(\"unhandled stop_soon: %d\"), (int) stop_soon);\n \n     case TARGET_WAITKIND_SPURIOUS:\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_SPURIOUS\\n\");\n       if (handle_stop_requested (ecs))\n \treturn;\n       context_switch (ecs);\n@@ -4827,8 +4817,6 @@ handle_inferior_event (struct execution_control_state *ecs)\n       return;\n \n     case TARGET_WAITKIND_THREAD_CREATED:\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_THREAD_CREATED\\n\");\n       if (handle_stop_requested (ecs))\n \treturn;\n       context_switch (ecs);\n@@ -4838,16 +4826,6 @@ handle_inferior_event (struct execution_control_state *ecs)\n \n     case TARGET_WAITKIND_EXITED:\n     case TARGET_WAITKIND_SIGNALLED:\n-      if (debug_infrun)\n-\t{\n-\t  if (ecs->ws.kind == TARGET_WAITKIND_EXITED)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: TARGET_WAITKIND_EXITED\\n\");\n-\t  else\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: TARGET_WAITKIND_SIGNALLED\\n\");\n-\t}\n-\n       inferior_ptid = ecs->ptid;\n       set_current_inferior (find_inferior_ptid (ecs->ptid));\n       set_current_program_space (current_inferior ()->pspace);\n@@ -4912,14 +4890,6 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n          the above cases end in a continue or goto.  */\n     case TARGET_WAITKIND_FORKED:\n     case TARGET_WAITKIND_VFORKED:\n-      if (debug_infrun)\n-\t{\n-\t  if (ecs->ws.kind == TARGET_WAITKIND_FORKED)\n-\t    fprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_FORKED\\n\");\n-\t  else\n-\t    fprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_VFORKED\\n\");\n-\t}\n-\n       /* Check whether the inferior is displaced stepping.  */\n       {\n \tstruct regcache *regcache = get_thread_regcache (ecs->event_thread);\n@@ -5080,10 +5050,6 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n       /* Done with the shared memory region.  Re-insert breakpoints in\n \t the parent, and keep going.  */\n \n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: TARGET_WAITKIND_VFORK_DONE\\n\");\n-\n       context_switch (ecs);\n \n       current_inferior ()->waiting_for_vfork_done = 0;\n@@ -5098,8 +5064,6 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n       return;\n \n     case TARGET_WAITKIND_EXECD:\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_EXECD\\n\");\n \n       /* Note we can't read registers yet (the stop_pc), because we\n \t don't yet know the inferior's post-exec architecture.\n@@ -5148,9 +5112,6 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n       /* Be careful not to try to gather much state about a thread\n          that's in a syscall.  It's frequently a losing proposition.  */\n     case TARGET_WAITKIND_SYSCALL_ENTRY:\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: TARGET_WAITKIND_SYSCALL_ENTRY\\n\");\n       /* Getting the current syscall number.  */\n       if (handle_syscall_event (ecs) == 0)\n \tprocess_event_stop_test (ecs);\n@@ -5162,22 +5123,15 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n          syscall.  Stepping one instruction seems to get it back\n          into user code.)  */\n     case TARGET_WAITKIND_SYSCALL_RETURN:\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: TARGET_WAITKIND_SYSCALL_RETURN\\n\");\n       if (handle_syscall_event (ecs) == 0)\n \tprocess_event_stop_test (ecs);\n       return;\n \n     case TARGET_WAITKIND_STOPPED:\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_STOPPED\\n\");\n       handle_signal_stop (ecs);\n       return;\n \n     case TARGET_WAITKIND_NO_HISTORY:\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog, \"infrun: TARGET_WAITKIND_NO_HISTORY\\n\");\n       /* Reverse execution: target ran out of history info.  */\n \n       /* Switch to the stopped thread.  */"
    },
    {
      "sha": "f86ce223739f5b01477622097c16341c7faf6d6a",
      "filename": "gdb/target/waitstatus.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c29705b71a8ec966478c0dc4712194a95291c6de/gdb/target/waitstatus.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c29705b71a8ec966478c0dc4712194a95291c6de/gdb/target/waitstatus.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target/waitstatus.c?ref=c29705b71a8ec966478c0dc4712194a95291c6de",
      "patch": "@@ -20,8 +20,7 @@\n #include \"common/common-defs.h\"\n #include \"waitstatus.h\"\n \n-/* Return a pretty printed form of target_waitstatus.\n-   Space for the result is malloc'd, caller must free.  */\n+/* Return a pretty printed form of target_waitstatus.  */\n \n std::string\n target_waitstatus_to_string (const struct target_waitstatus *ws)"
    }
  ]
}