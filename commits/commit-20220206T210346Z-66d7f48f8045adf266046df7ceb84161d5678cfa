{
  "sha": "66d7f48f8045adf266046df7ceb84161d5678cfa",
  "node_id": "C_kwDOANOeidoAKDY2ZDdmNDhmODA0NWFkZjI2NjA0NmRmN2NlYjg0MTYxZDU2NzhjZmE",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-11-22T03:26:24Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2022-02-06T21:03:46Z"
    },
    "message": "gdb: remove SYMBOL_CLASS macro, add getter\n\nChange-Id: I83211d5a47efc0564386e5b5ea4a29c00b1fd46a",
    "tree": {
      "sha": "473af71237afd358293f506901cdb13372d8dd72",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/473af71237afd358293f506901cdb13372d8dd72"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/66d7f48f8045adf266046df7ceb84161d5678cfa",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/66d7f48f8045adf266046df7ceb84161d5678cfa",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/66d7f48f8045adf266046df7ceb84161d5678cfa",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/66d7f48f8045adf266046df7ceb84161d5678cfa/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d1eebf9a6f02786eb0d5f6b961b8d692d23e77b1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d1eebf9a6f02786eb0d5f6b961b8d692d23e77b1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d1eebf9a6f02786eb0d5f6b961b8d692d23e77b1"
    }
  ],
  "stats": {
    "total": 291,
    "additions": 147,
    "deletions": 144
  },
  "files": [
    {
      "sha": "c9fce7d40b0e4e09e3a53bb2832ad29ceea3d166",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1157,7 +1157,7 @@ write_object_renaming (struct parser_state *par_state,\n   ada_lookup_encoded_symbol (name, orig_left_context, VAR_DOMAIN, &sym_info);\n   if (sym_info.symbol == NULL)\n     error (_(\"Could not find renamed variable: %s\"), ada_decode (name).c_str ());\n-  else if (SYMBOL_CLASS (sym_info.symbol) == LOC_TYPEDEF)\n+  else if (sym_info.symbol->aclass () == LOC_TYPEDEF)\n     /* We have a renaming of an old-style renaming symbol.  Don't\n        trust the block information.  */\n     sym_info.block = orig_left_context;\n@@ -1226,7 +1226,7 @@ write_object_renaming (struct parser_state *par_state,\n \t\t\t\t       VAR_DOMAIN, &index_sym_info);\n \t    if (index_sym_info.symbol == NULL)\n \t      error (_(\"Could not find %s\"), index_name);\n-\t    else if (SYMBOL_CLASS (index_sym_info.symbol) == LOC_TYPEDEF)\n+\t    else if (index_sym_info.symbol->aclass () == LOC_TYPEDEF)\n \t      /* Index is an old-style renaming symbol.  */\n \t      index_sym_info.block = orig_left_context;\n \t    write_var_from_sym (par_state, index_sym_info);\n@@ -1296,14 +1296,14 @@ block_lookup (const struct block *context, const char *raw_name)\n     = ada_lookup_symbol_list (name, context, VAR_DOMAIN);\n \n   if (context == NULL\n-      && (syms.empty () || SYMBOL_CLASS (syms[0].symbol) != LOC_BLOCK))\n+      && (syms.empty () || syms[0].symbol->aclass () != LOC_BLOCK))\n     symtab = lookup_symtab (name);\n   else\n     symtab = NULL;\n \n   if (symtab != NULL)\n     result = BLOCKVECTOR_BLOCK (symtab->blockvector (), STATIC_BLOCK);\n-  else if (syms.empty () || SYMBOL_CLASS (syms[0].symbol) != LOC_BLOCK)\n+  else if (syms.empty () || syms[0].symbol->aclass () != LOC_BLOCK)\n     {\n       if (context == NULL)\n \terror (_(\"No file or function \\\"%s\\\".\"), raw_name);\n@@ -1329,7 +1329,7 @@ select_possible_type_sym (const std::vector<struct block_symbol> &syms)\n \t  \n   preferred_index = -1; preferred_type = NULL;\n   for (i = 0; i < syms.size (); i += 1)\n-    switch (SYMBOL_CLASS (syms[i].symbol))\n+    switch (syms[i].symbol->aclass ())\n       {\n       case LOC_TYPEDEF:\n \tif (ada_prefer_type (SYMBOL_TYPE (syms[i].symbol), preferred_type))\n@@ -1373,7 +1373,7 @@ find_primitive_type (struct parser_state *par_state, const char *name)\n       strcpy (expanded_name, \"standard__\");\n       strcat (expanded_name, name);\n       sym = ada_lookup_symbol (expanded_name, NULL, VAR_DOMAIN).symbol;\n-      if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n+      if (sym != NULL && sym->aclass () == LOC_TYPEDEF)\n \ttype = SYMBOL_TYPE (sym);\n     }\n \n@@ -1690,7 +1690,7 @@ write_name_assoc (struct parser_state *par_state, struct stoken name)\n \t\t\t\t  par_state->expression_context_block,\n \t\t\t\t  VAR_DOMAIN);\n \n-      if (syms.size () != 1 || SYMBOL_CLASS (syms[0].symbol) == LOC_TYPEDEF)\n+      if (syms.size () != 1 || syms[0].symbol->aclass () == LOC_TYPEDEF)\n \tpstate->push_new<ada_string_operation> (copy_name (name));\n       else\n \twrite_var_from_sym (par_state, syms[0]);"
    },
    {
      "sha": "c689548aab6cf794e6366aaf8dd51177a13a0d91",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 28,
      "deletions": 28,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -3325,7 +3325,7 @@ See set/show multiple-symbol.\"));\n       if (syms[i].symbol == NULL)\n \tcontinue;\n \n-      if (SYMBOL_CLASS (syms[i].symbol) == LOC_BLOCK)\n+      if (syms[i].symbol->aclass () == LOC_BLOCK)\n \t{\n \t  struct symtab_and_line sal =\n \t    find_function_start_sal (syms[i].symbol, 1);\n@@ -3347,7 +3347,7 @@ See set/show multiple-symbol.\"));\n       else\n \t{\n \t  int is_enumeral =\n-\t    (SYMBOL_CLASS (syms[i].symbol) == LOC_CONST\n+\t    (syms[i].symbol->aclass () == LOC_CONST\n \t     && SYMBOL_TYPE (syms[i].symbol) != NULL\n \t     && SYMBOL_TYPE (syms[i].symbol)->code () == TYPE_CODE_ENUM);\n \t  struct symtab *symtab = NULL;\n@@ -3491,7 +3491,7 @@ ada_resolve_variable (struct symbol *sym, const struct block *block,\n \t\t   candidates.end (),\n \t\t   [] (block_symbol &bsym)\n \t\t   {\n-\t\t     switch (SYMBOL_CLASS (bsym.symbol))\n+\t\t     switch (bsym.symbol->aclass ())\n \t\t       {\n \t\t       case LOC_REGISTER:\n \t\t       case LOC_ARG:\n@@ -3514,7 +3514,7 @@ ada_resolve_variable (struct symbol *sym, const struct block *block,\n \t  candidates.end (),\n \t  [] (block_symbol &bsym)\n \t  {\n-\t    return SYMBOL_CLASS (bsym.symbol) == LOC_TYPEDEF;\n+\t    return bsym.symbol->aclass () == LOC_TYPEDEF;\n \t  }),\n \t candidates.end ());\n     }\n@@ -3628,7 +3628,7 @@ ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)\n   int i;\n   struct type *func_type = SYMBOL_TYPE (func);\n \n-  if (SYMBOL_CLASS (func) == LOC_CONST\n+  if (func->aclass () == LOC_CONST\n       && func_type->code () == TYPE_CODE_ENUM)\n     return (n_actuals == 0);\n   else if (func_type == NULL || func_type->code () != TYPE_CODE_FUNC)\n@@ -3934,7 +3934,7 @@ ada_parse_renaming (struct symbol *sym,\n \n   if (sym == NULL)\n     return ADA_NOT_RENAMING;\n-  switch (SYMBOL_CLASS (sym)) \n+  switch (sym->aclass ()) \n     {\n     default:\n       return ADA_NOT_RENAMING;\n@@ -4443,7 +4443,7 @@ is_nonfunction (const std::vector<struct block_symbol> &syms)\n   for (const block_symbol &sym : syms)\n     if (SYMBOL_TYPE (sym.symbol)->code () != TYPE_CODE_FUNC\n \t&& (SYMBOL_TYPE (sym.symbol)->code () != TYPE_CODE_ENUM\n-\t    || SYMBOL_CLASS (sym.symbol) != LOC_CONST))\n+\t    || sym.symbol->aclass () != LOC_CONST))\n       return 1;\n \n   return 0;\n@@ -4478,10 +4478,10 @@ lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)\n   if (sym0 == sym1)\n     return 1;\n   if (SYMBOL_DOMAIN (sym0) != SYMBOL_DOMAIN (sym1)\n-      || SYMBOL_CLASS (sym0) != SYMBOL_CLASS (sym1))\n+      || sym0->aclass () != sym1->aclass ())\n     return 0;\n \n-  switch (SYMBOL_CLASS (sym0))\n+  switch (sym0->aclass ())\n     {\n     case LOC_UNDEF:\n       return 1;\n@@ -4743,7 +4743,7 @@ remove_extra_symbols (std::vector<struct block_symbol> *syms)\n \t should be identical.  */\n \n       else if ((*syms)[i].symbol->linkage_name () != NULL\n-\t  && SYMBOL_CLASS ((*syms)[i].symbol) == LOC_STATIC\n+\t  && (*syms)[i].symbol->aclass () == LOC_STATIC\n \t  && is_nondebugging_type (SYMBOL_TYPE ((*syms)[i].symbol)))\n \t{\n \t  for (j = 0; j < syms->size (); j += 1)\n@@ -4752,8 +4752,8 @@ remove_extra_symbols (std::vector<struct block_symbol> *syms)\n \t\t  && (*syms)[j].symbol->linkage_name () != NULL\n \t\t  && strcmp ((*syms)[i].symbol->linkage_name (),\n \t\t\t     (*syms)[j].symbol->linkage_name ()) == 0\n-\t\t  && SYMBOL_CLASS ((*syms)[i].symbol)\n-\t\t       == SYMBOL_CLASS ((*syms)[j].symbol)\n+\t\t  && ((*syms)[i].symbol->aclass ()\n+\t\t      == (*syms)[j].symbol->aclass ())\n \t\t  && SYMBOL_VALUE_ADDRESS ((*syms)[i].symbol)\n \t\t  == SYMBOL_VALUE_ADDRESS ((*syms)[j].symbol))\n \t\tremove_p = 1;\n@@ -4845,7 +4845,7 @@ is_package_name (const char *name)\n static int\n old_renaming_is_invisible (const struct symbol *sym, const char *function_name)\n {\n-  if (SYMBOL_CLASS (sym) != LOC_TYPEDEF)\n+  if (sym->aclass () != LOC_TYPEDEF)\n     return 0;\n \n   std::string scope = xget_renaming_scope (SYMBOL_TYPE (sym));\n@@ -4924,7 +4924,7 @@ remove_irrelevant_renamings (std::vector<struct block_symbol> *syms,\n       const char *name;\n       const char *suffix;\n \n-      if (sym == NULL || SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n+      if (sym == NULL || sym->aclass () == LOC_TYPEDEF)\n \tcontinue;\n       name = sym->linkage_name ();\n       suffix = strstr (name, \"___XR\");\n@@ -5051,7 +5051,7 @@ match_data::operator() (struct block_symbol *bsym)\n     }\n   else \n     {\n-      if (SYMBOL_CLASS (sym) == LOC_UNRESOLVED)\n+      if (sym->aclass () == LOC_UNRESOLVED)\n \treturn true;\n       else if (SYMBOL_IS_ARGUMENT (sym))\n \targ_sym = sym;\n@@ -5742,7 +5742,7 @@ ada_add_block_symbols (std::vector<struct block_symbol> &result,\n     {\n       if (symbol_matches_domain (sym->language (), SYMBOL_DOMAIN (sym), domain))\n \t{\n-\t  if (SYMBOL_CLASS (sym) != LOC_UNRESOLVED)\n+\t  if (sym->aclass () != LOC_UNRESOLVED)\n \t    {\n \t      if (SYMBOL_IS_ARGUMENT (sym))\n \t\targ_sym = sym;\n@@ -5796,7 +5796,7 @@ ada_add_block_symbols (std::vector<struct block_symbol> &result,\n \t    if (cmp == 0\n \t\t&& is_name_suffix (sym->linkage_name () + name_len + 5))\n \t      {\n-\t\tif (SYMBOL_CLASS (sym) != LOC_UNRESOLVED)\n+\t\tif (sym->aclass () != LOC_UNRESOLVED)\n \t\t  {\n \t\t    if (SYMBOL_IS_ARGUMENT (sym))\n \t\t      arg_sym = sym;\n@@ -7214,7 +7214,7 @@ ada_find_any_type_symbol (const char *name)\n   struct symbol *sym;\n \n   sym = standard_lookup (name, get_selected_block (NULL), VAR_DOMAIN);\n-  if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n+  if (sym != NULL && sym->aclass () == LOC_TYPEDEF)\n     return sym;\n \n   sym = standard_lookup (name, NULL, STRUCT_DOMAIN);\n@@ -11253,10 +11253,10 @@ ada_has_this_exception_support (const struct exception_support_info *einfo)\n \n   /* Make sure that the symbol we found corresponds to a function.  */\n \n-  if (SYMBOL_CLASS (sym) != LOC_BLOCK)\n+  if (sym->aclass () != LOC_BLOCK)\n     {\n       error (_(\"Symbol \\\"%s\\\" is not a function (class = %d)\"),\n-\t     sym->linkage_name (), SYMBOL_CLASS (sym));\n+\t     sym->linkage_name (), sym->aclass ());\n       return 0;\n     }\n \n@@ -11276,10 +11276,10 @@ ada_has_this_exception_support (const struct exception_support_info *einfo)\n \n   /* Make sure that the symbol we found corresponds to a function.  */\n \n-  if (SYMBOL_CLASS (sym) != LOC_BLOCK)\n+  if (sym->aclass () != LOC_BLOCK)\n     {\n       error (_(\"Symbol \\\"%s\\\" is not a function (class = %d)\"),\n-\t     sym->linkage_name (), SYMBOL_CLASS (sym));\n+\t     sym->linkage_name (), sym->aclass ());\n       return 0;\n     }\n \n@@ -12246,7 +12246,7 @@ ada_exception_sal (enum ada_exception_catchpoint_kind ex,\n   if (sym == NULL)\n     error (_(\"Catchpoint symbol not found: %s\"), sym_name);\n \n-  if (SYMBOL_CLASS (sym) != LOC_BLOCK)\n+  if (sym->aclass () != LOC_BLOCK)\n     error (_(\"Unable to insert catchpoint. %s is not a function.\"), sym_name);\n \n   /* Set ADDR_STRING.  */\n@@ -12420,10 +12420,10 @@ ada_is_exception_sym (struct symbol *sym)\n {\n   const char *type_name = SYMBOL_TYPE (sym)->name ();\n \n-  return (SYMBOL_CLASS (sym) != LOC_TYPEDEF\n-\t  && SYMBOL_CLASS (sym) != LOC_BLOCK\n-\t  && SYMBOL_CLASS (sym) != LOC_CONST\n-\t  && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n+  return (sym->aclass () != LOC_TYPEDEF\n+\t  && sym->aclass () != LOC_BLOCK\n+\t  && sym->aclass () != LOC_CONST\n+\t  && sym->aclass () != LOC_UNRESOLVED\n \t  && type_name != NULL && strcmp (type_name, \"exception\") == 0);\n }\n \n@@ -12545,7 +12545,7 @@ ada_add_exceptions_from_frame (compiled_regex *preg,\n \n       ALL_BLOCK_SYMBOLS (block, iter, sym)\n \t{\n-\t  switch (SYMBOL_CLASS (sym))\n+\t  switch (sym->aclass ())\n \t    {\n \t    case LOC_TYPEDEF:\n \t    case LOC_BLOCK:"
    },
    {
      "sha": "7ba44c4c8c09972370da15f37c4146c1306329d8",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -520,7 +520,7 @@ gen_var_ref (struct agent_expr *ax, struct axs_value *value, struct symbol *var)\n     }\n \n   /* I'm imitating the code in read_var_value.  */\n-  switch (SYMBOL_CLASS (var))\n+  switch (var->aclass ())\n     {\n     case LOC_CONST:\t\t/* A constant, like an enum value.  */\n       ax_const_l (ax, (LONGEST) SYMBOL_VALUE (var));"
    },
    {
      "sha": "38773afe6a663eb315af1ce9afabb7612e007a82",
      "filename": "gdb/block.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/block.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/block.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/block.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -665,7 +665,7 @@ bool\n best_symbol (struct symbol *a, const domain_enum domain)\n {\n   return (SYMBOL_DOMAIN (a) == domain\n-\t  && SYMBOL_CLASS (a) != LOC_UNRESOLVED);\n+\t  && a->aclass () != LOC_UNRESOLVED);\n }\n \n /* See block.h.  */\n@@ -685,11 +685,10 @@ better_symbol (struct symbol *a, struct symbol *b, const domain_enum domain)\n       && SYMBOL_DOMAIN (a) != domain)\n     return b;\n \n-  if (SYMBOL_CLASS (a) != LOC_UNRESOLVED\n-      && SYMBOL_CLASS (b) == LOC_UNRESOLVED)\n+  if (a->aclass () != LOC_UNRESOLVED && b->aclass () == LOC_UNRESOLVED)\n     return a;\n-  if (SYMBOL_CLASS (b) != LOC_UNRESOLVED\n-      && SYMBOL_CLASS (a) == LOC_UNRESOLVED)\n+\n+  if (b->aclass () != LOC_UNRESOLVED && a->aclass () == LOC_UNRESOLVED)\n     return b;\n \n   return a;"
    },
    {
      "sha": "73347243f55096fe164012454e070d0db8ead480",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1093,7 +1093,7 @@ block\t:\tblock COLONCOLON name\n \t\t\t    = lookup_symbol (copy.c_str (), $1,\n \t\t\t\t\t     VAR_DOMAIN, NULL).symbol;\n \n-\t\t\t  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)\n+\t\t\t  if (!tem || tem->aclass () != LOC_BLOCK)\n \t\t\t    error (_(\"No function \\\"%s\\\" in specified context.\"),\n \t\t\t\t   copy.c_str ());\n \t\t\t  $$ = SYMBOL_BLOCK_VALUE (tem); }\n@@ -3067,7 +3067,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t\t\tpar_state->language ()->name_of_this ()\n \t\t\t? &is_a_field_of_this : NULL);\n \n-  if (bsym.symbol && SYMBOL_CLASS (bsym.symbol) == LOC_BLOCK)\n+  if (bsym.symbol && bsym.symbol->aclass () == LOC_BLOCK)\n     {\n       yylval.ssym.sym = bsym;\n       yylval.ssym.is_a_field_of_this = is_a_field_of_this.type != NULL;\n@@ -3116,7 +3116,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t}\n     }\n \n-  if (bsym.symbol && SYMBOL_CLASS (bsym.symbol) == LOC_TYPEDEF)\n+  if (bsym.symbol && bsym.symbol->aclass () == LOC_TYPEDEF)\n     {\n       yylval.tsym.type = SYMBOL_TYPE (bsym.symbol);\n       return TYPENAME;\n@@ -3211,7 +3211,7 @@ classify_inner_name (struct parser_state *par_state,\n       return ERROR;\n     }\n \n-  switch (SYMBOL_CLASS (yylval.ssym.sym.symbol))\n+  switch (yylval.ssym.sym.symbol->aclass ())\n     {\n     case LOC_BLOCK:\n     case LOC_LABEL:"
    },
    {
      "sha": "14d671e2989772b5c3033bd6b1c0e90992cb435a",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -883,7 +883,7 @@ c_type_print_template_args (const struct type_print_options *flags,\n     {\n       struct symbol *sym = TYPE_TEMPLATE_ARGUMENT (type, i);\n \n-      if (SYMBOL_CLASS (sym) != LOC_TYPEDEF)\n+      if (sym->aclass () != LOC_TYPEDEF)\n \tcontinue;\n \n       if (first)"
    },
    {
      "sha": "9fef280197603e6f77a68f7a6089710d8a2969f8",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1490,7 +1490,7 @@ patch_opaque_types (struct symtab *s)\n \t Remove syms from the chain when their types are stored,\n \t but search the whole chain, as there may be several syms\n \t from different files with the same name.  */\n-      if (SYMBOL_CLASS (real_sym) == LOC_TYPEDEF\n+      if (real_sym->aclass () == LOC_TYPEDEF\n \t  && SYMBOL_DOMAIN (real_sym) == VAR_DOMAIN\n \t  && SYMBOL_TYPE (real_sym)->code () == TYPE_CODE_PTR\n \t  && TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (real_sym))) != 0)"
    },
    {
      "sha": "8602480d01ab60ea7db40ae5a3ae5e6b1c194115",
      "filename": "gdb/compile/compile-c-symbols.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/compile/compile-c-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/compile/compile-c-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-symbols.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -62,7 +62,7 @@ convert_one_symbol (compile_c_instance *context,\n \n   context->error_symbol_once (sym.symbol);\n \n-  if (SYMBOL_CLASS (sym.symbol) == LOC_LABEL)\n+  if (sym.symbol->aclass () == LOC_LABEL)\n     sym_type = 0;\n   else\n     sym_type = context->convert_type (SYMBOL_TYPE (sym.symbol));\n@@ -80,7 +80,7 @@ convert_one_symbol (compile_c_instance *context,\n       CORE_ADDR addr = 0;\n       gdb::unique_xmalloc_ptr<char> symbol_name;\n \n-      switch (SYMBOL_CLASS (sym.symbol))\n+      switch (sym.symbol->aclass ())\n \t{\n \tcase LOC_TYPEDEF:\n \t  kind = GCC_C_SYMBOL_TYPEDEF;\n@@ -398,7 +398,7 @@ gcc_symbol_address (void *datum, struct gcc_c_context *gcc_context,\n \n       /* We only need global functions here.  */\n       sym = lookup_symbol (identifier, NULL, VAR_DOMAIN, NULL).symbol;\n-      if (sym != NULL && SYMBOL_CLASS (sym) == LOC_BLOCK)\n+      if (sym != NULL && sym->aclass () == LOC_BLOCK)\n \t{\n \t  if (compile_debug)\n \t    fprintf_unfiltered (gdb_stdlog,\n@@ -577,7 +577,7 @@ generate_c_for_for_one_variable (compile_instance *compiler,\n \t}\n       else\n \t{\n-\t  switch (SYMBOL_CLASS (sym))\n+\t  switch (sym->aclass ())\n \t    {\n \t    case LOC_REGISTER:\n \t    case LOC_ARG:"
    },
    {
      "sha": "de7afcaebcf6234b41a2dc1dbd12e0a520211c4a",
      "filename": "gdb/compile/compile-cplus-symbols.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/compile/compile-cplus-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/compile/compile-cplus-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-symbols.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -53,7 +53,7 @@ convert_one_symbol (compile_cplus_instance *instance,\n \n   instance->error_symbol_once (sym.symbol);\n \n-  if (SYMBOL_CLASS (sym.symbol) == LOC_LABEL)\n+  if (sym.symbol->aclass () == LOC_LABEL)\n     sym_type = 0;\n   else\n     sym_type = instance->convert_type (SYMBOL_TYPE (sym.symbol));\n@@ -70,7 +70,7 @@ convert_one_symbol (compile_cplus_instance *instance,\n       std::string name;\n       gdb::unique_xmalloc_ptr<char> symbol_name;\n \n-      switch (SYMBOL_CLASS (sym.symbol))\n+      switch (sym.symbol->aclass ())\n \t{\n \tcase LOC_TYPEDEF:\n \t  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_TYPEDEF)\n@@ -435,7 +435,7 @@ gcc_cplus_symbol_address (void *datum, struct gcc_cp_context *gcc_context,\n       struct symbol *sym\n \t= lookup_symbol (identifier, nullptr, VAR_DOMAIN, nullptr).symbol;\n \n-      if (sym != nullptr && SYMBOL_CLASS (sym) == LOC_BLOCK)\n+      if (sym != nullptr && sym->aclass () == LOC_BLOCK)\n \t{\n \t  if (compile_debug)\n \t    fprintf_unfiltered (gdb_stdlog,"
    },
    {
      "sha": "f146183f37751281961b0d828b9287d91ecd5754",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1501,7 +1501,7 @@ cp_lookup_rtti_type (const char *name, const struct block *block)\n       return NULL;\n     }\n \n-  if (SYMBOL_CLASS (rtti_sym) != LOC_TYPEDEF)\n+  if (rtti_sym->aclass () != LOC_TYPEDEF)\n     {\n       warning (_(\"RTTI symbol for class '%s' is not a type\"), name);\n       return NULL;"
    },
    {
      "sha": "601659d080d38c7802ddbcb76e4b334b9a702737",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -448,7 +448,7 @@ PrimaryExpression:\n \t\t  sym = lookup_symbol (copy.c_str (),\n \t\t\t\t       pstate->expression_context_block,\n \t\t\t\t       VAR_DOMAIN, &is_a_field_of_this);\n-\t\t  if (sym.symbol && SYMBOL_CLASS (sym.symbol) != LOC_TYPEDEF)\n+\t\t  if (sym.symbol && sym.symbol->aclass () != LOC_TYPEDEF)\n \t\t    {\n \t\t      if (symbol_read_needs_frame (sym.symbol))\n \t\t\tpstate->block_tracker->update (sym);\n@@ -1341,7 +1341,7 @@ classify_name (struct parser_state *par_state, const struct block *block)\n   std::string copy = copy_name (yylval.sval);\n \n   sym = lookup_symbol (copy.c_str (), block, VAR_DOMAIN, &is_a_field_of_this);\n-  if (sym.symbol && SYMBOL_CLASS (sym.symbol) == LOC_TYPEDEF)\n+  if (sym.symbol && sym.symbol->aclass () == LOC_TYPEDEF)\n     {\n       yylval.tsym.type = SYMBOL_TYPE (sym.symbol);\n       return TYPENAME;\n@@ -1388,7 +1388,7 @@ classify_inner_name (struct parser_state *par_state,\n   if (yylval.ssym.sym.symbol == NULL)\n     return ERROR;\n \n-  if (SYMBOL_CLASS (yylval.ssym.sym.symbol) == LOC_TYPEDEF)\n+  if (yylval.ssym.sym.symbol->aclass () == LOC_TYPEDEF)\n     {\n       yylval.tsym.type = SYMBOL_TYPE (yylval.ssym.sym.symbol);\n       return TYPENAME;"
    },
    {
      "sha": "d07c9d26abd08ce234c087e84d87a1738328de06",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -8879,7 +8879,7 @@ fixup_go_packaging (struct dwarf2_cu *cu)\n \t  struct symbol *sym = list->symbol[i];\n \n \t  if (sym->language () == language_go\n-\t      && SYMBOL_CLASS (sym) == LOC_BLOCK)\n+\t      && sym->aclass () == LOC_BLOCK)\n \t    {\n \t      gdb::unique_xmalloc_ptr<char> this_package_name\n \t\t(go_symbol_package_name (sym));\n@@ -21844,7 +21844,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t  && die->parent->tag == DW_TAG_common_block)\n \t\tattr2 = NULL;\n \n-\t      if (SYMBOL_CLASS (sym) == LOC_STATIC\n+\t      if (sym->aclass () == LOC_STATIC\n \t\t  && SYMBOL_VALUE_ADDRESS (sym) == 0\n \t\t  && !per_objfile->per_bfd->has_section_at_zero)\n \t\t{\n@@ -21855,7 +21855,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t}\n \t      else if (attr2 != nullptr && attr2->as_boolean ())\n \t\t{\n-\t\t  if (SYMBOL_CLASS (sym) == LOC_STATIC\n+\t\t  if (sym->aclass () == LOC_STATIC\n \t\t      && (objfile->flags & OBJF_MAINLINE) == 0\n \t\t      && per_objfile->per_bfd->can_copy)\n \t\t    {\n@@ -21918,7 +21918,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t      else if (!die_is_declaration (die, cu))\n \t\t{\n \t\t  /* Use the default LOC_OPTIMIZED_OUT class.  */\n-\t\t  gdb_assert (SYMBOL_CLASS (sym) == LOC_OPTIMIZED_OUT);\n+\t\t  gdb_assert (sym->aclass () == LOC_OPTIMIZED_OUT);\n \t\t  if (!suppress_add)\n \t\t    list_to_add = cu->list_in_scope;\n \t\t}"
    },
    {
      "sha": "91ff41cfe25aa97b0305cb2410fd7b32f68b427a",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -2588,7 +2588,7 @@ var_value_operation::evaluate_for_address (struct expression *exp,\n   if (noside == EVAL_AVOID_SIDE_EFFECTS)\n     {\n       struct type *type = lookup_pointer_type (SYMBOL_TYPE (var));\n-      enum address_class sym_class = SYMBOL_CLASS (var);\n+      enum address_class sym_class = var->aclass ();\n \n       if (sym_class == LOC_CONST\n \t  || sym_class == LOC_CONST_BYTES"
    },
    {
      "sha": "58863b8f3ab9b2e6baf5a0ed18e9fec10e574b17",
      "filename": "gdb/expop.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/expop.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/expop.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expop.h?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -482,7 +482,7 @@ check_constant (ULONGEST cst)\n static inline bool\n check_constant (struct symbol *sym)\n {\n-  enum address_class sc = SYMBOL_CLASS (sym);\n+  enum address_class sc = sym->aclass ();\n   return (sc == LOC_BLOCK\n \t  || sc == LOC_CONST\n \t  || sc == LOC_CONST_BYTES"
    },
    {
      "sha": "13f8c10897fcaa7d824e02c0a1527eac051c68f6",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1487,7 +1487,7 @@ yylex (void)\n       {\n \tresult = lookup_symbol (tmp.c_str (), pstate->expression_context_block,\n \t\t\t\tdomain, NULL);\n-\tif (result.symbol && SYMBOL_CLASS (result.symbol) == LOC_TYPEDEF)\n+\tif (result.symbol && result.symbol->aclass () == LOC_TYPEDEF)\n \t  {\n \t    yylval.tsym.type = SYMBOL_TYPE (result.symbol);\n \t    return TYPENAME;"
    },
    {
      "sha": "592593715c943b68ca6652b672dc82901af07611",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -600,7 +600,7 @@ info_common_command_for_block (const struct block *block, const char *comname,\n \tconst struct common_block *common = SYMBOL_VALUE_COMMON_BLOCK (sym);\n \tsize_t index;\n \n-\tgdb_assert (SYMBOL_CLASS (sym) == LOC_COMMON_BLOCK);\n+\tgdb_assert (sym->aclass () == LOC_COMMON_BLOCK);\n \n \tif (comname && (!sym->linkage_name ()\n \t\t\t|| strcmp (comname, sym->linkage_name ()) != 0))"
    },
    {
      "sha": "fdfad599f32e410ec838005f73dd558103db307f",
      "filename": "gdb/findvar.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/findvar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/findvar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/findvar.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -358,7 +358,7 @@ symbol_read_needs (struct symbol *sym)\n   if (SYMBOL_COMPUTED_OPS (sym) != NULL)\n     return SYMBOL_COMPUTED_OPS (sym)->get_symbol_read_needs (sym);\n \n-  switch (SYMBOL_CLASS (sym))\n+  switch (sym->aclass ())\n     {\n       /* All cases listed explicitly so that gcc -Wall will detect it if\n \t we failed to consider one.  */\n@@ -616,7 +616,7 @@ language_defn::read_var_value (struct symbol *var,\n   if (SYMBOL_COMPUTED_OPS (var) != NULL)\n     return SYMBOL_COMPUTED_OPS (var)->read_variable (var, frame);\n \n-  switch (SYMBOL_CLASS (var))\n+  switch (var->aclass ())\n     {\n     case LOC_CONST:\n       if (is_dynamic_type (type))\n@@ -718,7 +718,7 @@ language_defn::read_var_value (struct symbol *var,\n \t\t      ->register_number (var, get_frame_arch (frame));\n \tstruct value *regval;\n \n-\tif (SYMBOL_CLASS (var) == LOC_REGPARM_ADDR)\n+\tif (var->aclass () == LOC_REGPARM_ADDR)\n \t  {\n \t    regval = value_from_register (lookup_pointer_type (type),\n \t\t\t\t\t  regno,"
    },
    {
      "sha": "2e7f6540f94f88cd15338077b4216beb107e7266",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1690,7 +1690,7 @@ lookup_typename (const struct language_defn *language,\n \n   sym = lookup_symbol_in_language (name, block, VAR_DOMAIN,\n \t\t\t\t   language->la_language, NULL).symbol;\n-  if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n+  if (sym != NULL && sym->aclass () == LOC_TYPEDEF)\n     return SYMBOL_TYPE (sym);\n \n   if (noerr)"
    },
    {
      "sha": "5436072d66e3f9ae4534525edfaf421f8f743c5a",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1338,7 +1338,7 @@ package_name_p (const char *name, const struct block *block)\n   sym = lookup_symbol (name, block, STRUCT_DOMAIN, &is_a_field_of_this).symbol;\n \n   if (sym\n-      && SYMBOL_CLASS (sym) == LOC_TYPEDEF\n+      && sym->aclass () == LOC_TYPEDEF\n       && SYMBOL_TYPE (sym)->code () == TYPE_CODE_MODULE)\n     return 1;\n "
    },
    {
      "sha": "9816a90a8dd82bd0e43180fad45938b177a50076",
      "filename": "gdb/guile/scm-symbol.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/guile/scm-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/guile/scm-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-symbol.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -412,7 +412,7 @@ gdbscm_symbol_addr_class (SCM self)\n     = syscm_get_valid_symbol_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   const struct symbol *symbol = s_smob->symbol;\n \n-  return scm_from_int (SYMBOL_CLASS (symbol));\n+  return scm_from_int (symbol->aclass ());\n }\n \n /* (symbol-argument? <gdb:symbol>) -> boolean */\n@@ -437,7 +437,7 @@ gdbscm_symbol_constant_p (SCM self)\n   const struct symbol *symbol = s_smob->symbol;\n   enum address_class theclass;\n \n-  theclass = SYMBOL_CLASS (symbol);\n+  theclass = symbol->aclass ();\n \n   return scm_from_bool (theclass == LOC_CONST || theclass == LOC_CONST_BYTES);\n }\n@@ -452,7 +452,7 @@ gdbscm_symbol_function_p (SCM self)\n   const struct symbol *symbol = s_smob->symbol;\n   enum address_class theclass;\n \n-  theclass = SYMBOL_CLASS (symbol);\n+  theclass = symbol->aclass ();\n \n   return scm_from_bool (theclass == LOC_BLOCK);\n }\n@@ -467,7 +467,7 @@ gdbscm_symbol_variable_p (SCM self)\n   const struct symbol *symbol = s_smob->symbol;\n   enum address_class theclass;\n \n-  theclass = SYMBOL_CLASS (symbol);\n+  theclass = symbol->aclass ();\n \n   return scm_from_bool (!SYMBOL_IS_ARGUMENT (symbol)\n \t\t\t&& (theclass == LOC_LOCAL || theclass == LOC_REGISTER\n@@ -534,7 +534,7 @@ gdbscm_symbol_value (SCM self, SCM rest)\n   if (!gdbscm_is_false (frame_scm))\n     f_smob = frscm_get_frame_smob_arg_unsafe (frame_scm, frame_pos, FUNC_NAME);\n \n-  if (SYMBOL_CLASS (symbol) == LOC_TYPEDEF)\n+  if (symbol->aclass () == LOC_TYPEDEF)\n     {\n       gdbscm_out_of_range_error (FUNC_NAME, SCM_ARG1, self,\n \t\t\t\t _(\"cannot get the value of a typedef\"));"
    },
    {
      "sha": "b02040f68d3bb9aab96e52daa51205981e5cb037",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -976,7 +976,7 @@ prepare_one_step (thread_info *tp, struct step_command_fsm *sm)\n \t  if (inline_skipped_frames (tp) > 0)\n \t    {\n \t      symbol *sym = inline_skipped_symbol (tp);\n-\t      if (SYMBOL_CLASS (sym) == LOC_BLOCK)\n+\t      if (sym->aclass () == LOC_BLOCK)\n \t\t{\n \t\t  const block *block = SYMBOL_BLOCK_VALUE (sym);\n \t\t  if (BLOCK_END (block) < tp->control.step_range_end)"
    },
    {
      "sha": "0a930e148edc08d085824a2bc6e81a10b1a91a9a",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -204,7 +204,7 @@ collect_info::add_symbol (block_symbol *bsym)\n {\n   /* In list mode, add all matching symbols, regardless of class.\n      This allows the user to type \"list a_global_variable\".  */\n-  if (SYMBOL_CLASS (bsym->symbol) == LOC_BLOCK || this->state->list_mode)\n+  if (bsym->symbol->aclass () == LOC_BLOCK || this->state->list_mode)\n     this->result.symbols->push_back (*bsym);\n \n   /* Continue iterating.  */\n@@ -2298,7 +2298,7 @@ convert_linespec_to_sals (struct linespec_state *state, linespec *ls)\n \n \t      if (state->funfirstline\n \t\t   && !ls->minimal_symbols.empty ()\n-\t\t   && SYMBOL_CLASS (sym.symbol) == LOC_BLOCK)\n+\t\t   && sym.symbol->aclass () == LOC_BLOCK)\n \t\t{\n \t\t  const CORE_ADDR addr\n \t\t    = BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (sym.symbol));\n@@ -3491,7 +3491,7 @@ decode_compound_collector::operator () (block_symbol *bsym)\n   struct type *t;\n   struct symbol *sym = bsym->symbol;\n \n-  if (SYMBOL_CLASS (sym) != LOC_TYPEDEF)\n+  if (sym->aclass () != LOC_TYPEDEF)\n     return true; /* Continue iterating.  */\n \n   t = SYMBOL_TYPE (sym);\n@@ -4439,14 +4439,14 @@ static int\n symbol_to_sal (struct symtab_and_line *result,\n \t       int funfirstline, struct symbol *sym)\n {\n-  if (SYMBOL_CLASS (sym) == LOC_BLOCK)\n+  if (sym->aclass () == LOC_BLOCK)\n     {\n       *result = find_function_start_sal (sym, funfirstline);\n       return 1;\n     }\n   else\n     {\n-      if (SYMBOL_CLASS (sym) == LOC_LABEL && SYMBOL_VALUE_ADDRESS (sym) != 0)\n+      if (sym->aclass () == LOC_LABEL && SYMBOL_VALUE_ADDRESS (sym) != 0)\n \t{\n \t  *result = {};\n \t  result->symtab = symbol_symtab (sym);"
    },
    {
      "sha": "02e3cf1b4e7bd3486a5565dec5321d5b83cdccb5",
      "filename": "gdb/m2-exp.y",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/m2-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/m2-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-exp.y?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -507,7 +507,7 @@ fblock\t:\tblock COLONCOLON BLOCKNAME\n \t\t\t{ struct symbol *tem\n \t\t\t    = lookup_symbol (copy_name ($3).c_str (), $1,\n \t\t\t\t\t     VAR_DOMAIN, 0).symbol;\n-\t\t\t  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)\n+\t\t\t  if (!tem || tem->aclass () != LOC_BLOCK)\n \t\t\t    error (_(\"No function \\\"%s\\\" in specified context.\"),\n \t\t\t\t   copy_name ($3).c_str ());\n \t\t\t  $$ = tem;\n@@ -932,15 +932,15 @@ yylex (void)\n       return BLOCKNAME;\n     sym = lookup_symbol (tmp.c_str (), pstate->expression_context_block,\n \t\t\t VAR_DOMAIN, 0).symbol;\n-    if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)\n+    if (sym && sym->aclass () == LOC_BLOCK)\n       return BLOCKNAME;\n     if (lookup_typename (pstate->language (),\n \t\t\t tmp.c_str (), pstate->expression_context_block, 1))\n       return TYPENAME;\n \n     if(sym)\n     {\n-      switch(SYMBOL_CLASS (sym))\n+      switch(sym->aclass ())\n        {\n        case LOC_STATIC:\n        case LOC_REGISTER:"
    },
    {
      "sha": "131b033777cdef8e03dc45edf6c6cf57ab73a65c",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -4468,7 +4468,7 @@ mylookup_symbol (const char *name, const struct block *block,\n     {\n       if (sym->linkage_name ()[0] == inc\n \t  && SYMBOL_DOMAIN (sym) == domain\n-\t  && SYMBOL_CLASS (sym) == theclass\n+\t  && sym->aclass () == theclass\n \t  && strcmp (sym->linkage_name (), name) == 0)\n \treturn sym;\n     }"
    },
    {
      "sha": "0c2172f0c63974a681de3057b3f5f365151f1596",
      "filename": "gdb/mi/mi-cmd-stack.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/mi/mi-cmd-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/mi/mi-cmd-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-stack.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -599,7 +599,7 @@ list_args_or_locals (const frame_print_options &fp_opts,\n \t{\n \t  int print_me = 0;\n \n-\t  switch (SYMBOL_CLASS (sym))\n+\t  switch (sym->aclass ())\n \t    {\n \t    default:\n \t    case LOC_UNDEF:\t/* catches errors        */"
    },
    {
      "sha": "5cd72ae245115b3a57c6e39ec73af4091d456bc1",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -483,7 +483,7 @@ msymbol_is_micromips (struct minimal_symbol *msym)\n static void\n mips_make_symbol_special (struct symbol *sym, struct objfile *objfile)\n {\n-  if (SYMBOL_CLASS (sym) == LOC_BLOCK)\n+  if (sym->aclass () == LOC_BLOCK)\n     {\n       /* We are in symbol reading so it is OK to cast away constness.  */\n       struct block *block = (struct block *) SYMBOL_BLOCK_VALUE (sym);"
    },
    {
      "sha": "35b275ad3012a43d4413c6c074ef72f57bf02c0c",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -616,8 +616,8 @@ relocate_one_symbol (struct symbol *sym, struct objfile *objfile,\n      any symbols in STRUCT_DOMAIN or UNDEF_DOMAIN.\n      But I'm leaving out that test, on the theory that\n      they can't possibly pass the tests below.  */\n-  if ((SYMBOL_CLASS (sym) == LOC_LABEL\n-       || SYMBOL_CLASS (sym) == LOC_STATIC)\n+  if ((sym->aclass () == LOC_LABEL\n+       || sym->aclass () == LOC_STATIC)\n       && sym->section_index () >= 0)\n     {\n       SET_SYMBOL_VALUE_ADDRESS (sym,"
    },
    {
      "sha": "c7fa0dc882dcfef9c0e3764edf449d2cbd7421eb",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -635,7 +635,7 @@ block\t:\tblock COLONCOLON name\n \t\t\t    = lookup_symbol (copy.c_str (), $1,\n \t\t\t\t\t     VAR_DOMAIN, NULL).symbol;\n \n-\t\t\t  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)\n+\t\t\t  if (!tem || tem->aclass () != LOC_BLOCK)\n \t\t\t    error (_(\"No function \\\"%s\\\" in specified context.\"),\n \t\t\t\t   copy.c_str ());\n \t\t\t  $$ = SYMBOL_BLOCK_VALUE (tem); }\n@@ -1544,7 +1544,7 @@ yylex (void)\n     /* Call lookup_symtab, not lookup_partial_symtab, in case there are\n        no psymtabs (coff, xcoff, or some future change to blow away the\n        psymtabs once once symbols are read).  */\n-    if ((sym && SYMBOL_CLASS (sym) == LOC_BLOCK)\n+    if ((sym && sym->aclass () == LOC_BLOCK)\n \t|| lookup_symtab (tmp.c_str ()))\n       {\n \tyylval.ssym.sym.symbol = sym;\n@@ -1553,7 +1553,7 @@ yylex (void)\n \tfree (uptokstart);\n \treturn BLOCKNAME;\n       }\n-    if (sym && SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n+    if (sym && sym->aclass () == LOC_TYPEDEF)\n \t{\n #if 1\n \t  /* Despite the following flaw, we need to keep this code enabled.\n@@ -1622,7 +1622,7 @@ yylex (void)\n \t\t\t\t\t VAR_DOMAIN, NULL).symbol;\n \t\t      if (cur_sym)\n \t\t\t{\n-\t\t\t  if (SYMBOL_CLASS (cur_sym) == LOC_TYPEDEF)\n+\t\t\t  if (cur_sym->aclass () == LOC_TYPEDEF)\n \t\t\t    {\n \t\t\t      best_sym = cur_sym;\n \t\t\t      pstate->lexptr = p;"
    },
    {
      "sha": "0b0a1d63a81e3f8daefce49d6b19c13de4b2f20d",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1700,7 +1700,7 @@ info_address_command (const char *exp, int from_tty)\n       return;\n     }\n \n-  switch (SYMBOL_CLASS (sym))\n+  switch (sym->aclass ())\n     {\n     case LOC_CONST:\n     case LOC_CONST_BYTES:"
    },
    {
      "sha": "70fec4aad5dae0a50aca143f057884fc6e65ea62",
      "filename": "gdb/python/py-framefilter.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/python/py-framefilter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/python/py-framefilter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-framefilter.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -169,7 +169,7 @@ mi_should_print (struct symbol *sym, enum mi_print_types type)\n {\n   int print_me = 0;\n \n-  switch (SYMBOL_CLASS (sym))\n+  switch (sym->aclass ())\n     {\n     default:\n     case LOC_UNDEF:\t/* catches errors        */"
    },
    {
      "sha": "fe62809c19b276c787ce3cb281b4759b2bcc23ea",
      "filename": "gdb/python/py-symbol.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/python/py-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/python/py-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-symbol.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -131,7 +131,7 @@ sympy_get_addr_class (PyObject *self, void *closure)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  return gdb_py_object_from_longest (SYMBOL_CLASS (symbol)).release ();\n+  return gdb_py_object_from_longest (symbol->aclass ()).release ();\n }\n \n static PyObject *\n@@ -152,7 +152,7 @@ sympy_is_constant (PyObject *self, void *closure)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  theclass = SYMBOL_CLASS (symbol);\n+  theclass = symbol->aclass ();\n \n   return PyBool_FromLong (theclass == LOC_CONST || theclass == LOC_CONST_BYTES);\n }\n@@ -165,7 +165,7 @@ sympy_is_function (PyObject *self, void *closure)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  theclass = SYMBOL_CLASS (symbol);\n+  theclass = symbol->aclass ();\n \n   return PyBool_FromLong (theclass == LOC_BLOCK);\n }\n@@ -178,7 +178,7 @@ sympy_is_variable (PyObject *self, void *closure)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  theclass = SYMBOL_CLASS (symbol);\n+  theclass = symbol->aclass ();\n \n   return PyBool_FromLong (!SYMBOL_IS_ARGUMENT (symbol)\n \t\t\t  && (theclass == LOC_LOCAL || theclass == LOC_REGISTER\n@@ -260,7 +260,7 @@ sympy_value (PyObject *self, PyObject *args)\n     }\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n-  if (SYMBOL_CLASS (symbol) == LOC_TYPEDEF)\n+  if (symbol->aclass () == LOC_TYPEDEF)\n     {\n       PyErr_SetString (PyExc_TypeError, \"cannot get the value of a typedef\");\n       return NULL;"
    },
    {
      "sha": "6ab551a852009d958b9e639a93fe50cc930d73cb",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -997,9 +997,9 @@ typy_template_argument (PyObject *self, PyObject *args)\n     }\n \n   sym = TYPE_TEMPLATE_ARGUMENT (type, argno);\n-  if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n+  if (sym->aclass () == LOC_TYPEDEF)\n     return type_to_type_object (SYMBOL_TYPE (sym));\n-  else if (SYMBOL_CLASS (sym) == LOC_OPTIMIZED_OUT)\n+  else if (sym->aclass () == LOC_OPTIMIZED_OUT)\n     {\n       PyErr_Format (PyExc_RuntimeError,\n \t\t    _(\"Template argument is optimized out\"));"
    },
    {
      "sha": "75f8a3cf6ad61dea8fe7bdc53ef1354fa10f080c",
      "filename": "gdb/rust-parse.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/rust-parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/rust-parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-parse.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1210,14 +1210,14 @@ rust_parser::name_to_operation (const std::string &name)\n   struct block_symbol sym = lookup_symbol (name.c_str (),\n \t\t\t\t\t   pstate->expression_context_block,\n \t\t\t\t\t   VAR_DOMAIN);\n-  if (sym.symbol != nullptr && SYMBOL_CLASS (sym.symbol) != LOC_TYPEDEF)\n+  if (sym.symbol != nullptr && sym.symbol->aclass () != LOC_TYPEDEF)\n     return make_operation<var_value_operation> (sym);\n \n   struct type *type = nullptr;\n \n   if (sym.symbol != nullptr)\n     {\n-      gdb_assert (SYMBOL_CLASS (sym.symbol) == LOC_TYPEDEF);\n+      gdb_assert (sym.symbol->aclass () == LOC_TYPEDEF);\n       type = SYMBOL_TYPE (sym.symbol);\n     }\n   if (type == nullptr)"
    },
    {
      "sha": "249a88318e0f02a9b03566d4fd8e898a319bc956",
      "filename": "gdb/source.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/source.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/source.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -323,7 +323,7 @@ select_source_symtab (struct symtab *s)\n   /* Make the default place to list be the function `main'\n      if one exists.  */\n   block_symbol bsym = lookup_symbol (main_name (), 0, VAR_DOMAIN, 0);\n-  if (bsym.symbol != nullptr && SYMBOL_CLASS (bsym.symbol) == LOC_BLOCK)\n+  if (bsym.symbol != nullptr && bsym.symbol->aclass () == LOC_BLOCK)\n     {\n       symtab_and_line sal = find_function_start_sal (bsym.symbol, true);\n       if (sal.symtab == NULL)"
    },
    {
      "sha": "467f622a3677a2976f42947d54ac447c6e315f79",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1155,8 +1155,8 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t      struct symbol *prev_sym;\n \n \t      prev_sym = local_symbols->symbol[local_symbols->nsyms - 1];\n-\t      if ((SYMBOL_CLASS (prev_sym) == LOC_REF_ARG\n-\t\t   || SYMBOL_CLASS (prev_sym) == LOC_ARG)\n+\t      if ((prev_sym->aclass () == LOC_REF_ARG\n+\t\t   || prev_sym->aclass () == LOC_ARG)\n \t\t  && strcmp (prev_sym->linkage_name (),\n \t\t\t     sym->linkage_name ()) == 0)\n \t\t{\n@@ -1398,11 +1398,11 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     {\n       /* We have to convert LOC_REGISTER to LOC_REGPARM_ADDR (for\n \t variables passed in a register).  */\n-      if (SYMBOL_CLASS (sym) == LOC_REGISTER)\n+      if (sym->aclass () == LOC_REGISTER)\n \tsym->set_aclass_index (LOC_REGPARM_ADDR);\n       /* Likewise for converting LOC_ARG to LOC_REF_ARG (for the 7th\n \t and subsequent arguments on SPARC, for example).  */\n-      else if (SYMBOL_CLASS (sym) == LOC_ARG)\n+      else if (sym->aclass () == LOC_ARG)\n \tsym->set_aclass_index (LOC_REF_ARG);\n     }\n \n@@ -1628,7 +1628,7 @@ read_type (const char **pp, struct objfile *objfile)\n \t    {\n \t      struct symbol *sym = ppt->symbol[i];\n \n-\t      if (SYMBOL_CLASS (sym) == LOC_TYPEDEF\n+\t      if (sym->aclass () == LOC_TYPEDEF\n \t\t  && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN\n \t\t  && (SYMBOL_TYPE (sym)->code () == code)\n \t\t  && strcmp (sym->linkage_name (), type_name) == 0)\n@@ -4466,7 +4466,7 @@ cleanup_undefined_types_1 (void)\n \t\t      {\n \t\t\tstruct symbol *sym = ppt->symbol[i];\n \n-\t\t\tif (SYMBOL_CLASS (sym) == LOC_TYPEDEF\n+\t\t\tif (sym->aclass () == LOC_TYPEDEF\n \t\t\t    && SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN\n \t\t\t    && (SYMBOL_TYPE (sym)->code () == (*type)->code ())\n \t\t\t    && ((*type)->instance_flags ()\n@@ -4576,7 +4576,7 @@ scan_file_globals (struct objfile *objfile)\n \t\t     the same symbol if there are multiple references.  */\n \t\t  if (sym)\n \t\t    {\n-\t\t      if (SYMBOL_CLASS (sym) == LOC_BLOCK)\n+\t\t      if (sym->aclass () == LOC_BLOCK)\n \t\t\t{\n \t\t\t  fix_common_block (sym,\n \t\t\t\t\t    MSYMBOL_VALUE_ADDRESS (resolve_objfile,\n@@ -4627,7 +4627,7 @@ scan_file_globals (struct objfile *objfile)\n \t  SET_SYMBOL_VALUE_ADDRESS (prev, 0);\n \n \t  /* Complain about unresolved common block symbols.  */\n-\t  if (SYMBOL_CLASS (prev) == LOC_STATIC)\n+\t  if (prev->aclass () == LOC_STATIC)\n \t    prev->set_aclass_index (LOC_UNRESOLVED);\n \t  else\n \t    complaint (_(\"%s: common block `%s' from \""
    },
    {
      "sha": "1df3f6b8de3b32301a25385a9c48e44a8c15d813",
      "filename": "gdb/stack.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stack.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -773,7 +773,7 @@ print_frame_args (const frame_print_options &fp_opts,\n \t      break;\n \t    }\n \n-\t  switch (SYMBOL_CLASS (sym))\n+\t  switch (sym->aclass ())\n \t    {\n \t    case LOC_ARG:\n \t    case LOC_REF_ARG:\n@@ -828,7 +828,7 @@ print_frame_args (const frame_print_options &fp_opts,\n \t      nsym = lookup_symbol_search_name (sym->search_name (),\n \t\t\t\t\t\tb, VAR_DOMAIN).symbol;\n \t      gdb_assert (nsym != NULL);\n-\t      if (SYMBOL_CLASS (nsym) == LOC_REGISTER\n+\t      if (nsym->aclass () == LOC_REGISTER\n \t\t  && !SYMBOL_IS_ARGUMENT (nsym))\n \t\t{\n \t\t  /* There is a LOC_ARG/LOC_REGISTER pair.  This means\n@@ -2248,7 +2248,7 @@ iterate_over_block_locals (const struct block *b,\n \n   ALL_BLOCK_SYMBOLS (b, iter, sym)\n     {\n-      switch (SYMBOL_CLASS (sym))\n+      switch (sym->aclass ())\n \t{\n \tcase LOC_CONST:\n \tcase LOC_LOCAL:"
    },
    {
      "sha": "5c96bf9886d26b149acdfa3ec64835a4b3a3c4e3",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -543,7 +543,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n     }\n   else\n     {\n-      if (SYMBOL_CLASS (symbol) == LOC_TYPEDEF)\n+      if (symbol->aclass () == LOC_TYPEDEF)\n \tfprintf_filtered (outfile, \"typedef \");\n       if (SYMBOL_TYPE (symbol))\n \t{\n@@ -558,7 +558,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n       else\n \tfprintf_filtered (outfile, \"%s \", symbol->print_name ());\n \n-      switch (SYMBOL_CLASS (symbol))\n+      switch (symbol->aclass ())\n \t{\n \tcase LOC_CONST:\n \t  fprintf_filtered (outfile, \"const %s (%s)\",\n@@ -654,7 +654,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \n \tdefault:\n \t  fprintf_filtered (outfile, \"botched symbol class %x\",\n-\t\t\t    SYMBOL_CLASS (symbol));\n+\t\t\t    symbol->aclass ());\n \t  break;\n \t}\n     }"
    },
    {
      "sha": "9357b5b11ed17ccfecf4f6883ab38fa190836c04",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1805,7 +1805,7 @@ fixup_symbol_section (struct symbol *sym, struct objfile *objfile)\n   /* We should have an objfile by now.  */\n   gdb_assert (objfile);\n \n-  switch (SYMBOL_CLASS (sym))\n+  switch (sym->aclass ())\n     {\n     case LOC_STATIC:\n     case LOC_LABEL:\n@@ -3086,7 +3086,7 @@ find_symbol_at_address (CORE_ADDR address)\n \n \t  ALL_BLOCK_SYMBOLS (b, iter, sym)\n \t    {\n-\t      if (SYMBOL_CLASS (sym) == LOC_STATIC\n+\t      if (sym->aclass () == LOC_STATIC\n \t\t  && SYMBOL_VALUE_ADDRESS (sym) == addr)\n \t\treturn sym;\n \t    }\n@@ -4119,7 +4119,7 @@ find_function_alias_target (bound_minimal_symbol msymbol)\n \n   symbol *sym = find_pc_function (func_addr);\n   if (sym != NULL\n-      && SYMBOL_CLASS (sym) == LOC_BLOCK\n+      && sym->aclass () == LOC_BLOCK\n       && BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (sym)) == func_addr)\n     return sym;\n \n@@ -4828,25 +4828,25 @@ global_symbol_searcher::add_matching_symbols\n \t\t       || preg->exec (sym->natural_name (), 0,\n \t\t\t\t      NULL, 0) == 0)\n \t\t      && ((kind == VARIABLES_DOMAIN\n-\t\t\t   && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n-\t\t\t   && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n-\t\t\t   && SYMBOL_CLASS (sym) != LOC_BLOCK\n+\t\t\t   && sym->aclass () != LOC_TYPEDEF\n+\t\t\t   && sym->aclass () != LOC_UNRESOLVED\n+\t\t\t   && sym->aclass () != LOC_BLOCK\n \t\t\t   /* LOC_CONST can be used for more than\n \t\t\t      just enums, e.g., c++ static const\n \t\t\t      members.  We only want to skip enums\n \t\t\t      here.  */\n-\t\t\t   && !(SYMBOL_CLASS (sym) == LOC_CONST\n+\t\t\t   && !(sym->aclass () == LOC_CONST\n \t\t\t\t&& (SYMBOL_TYPE (sym)->code ()\n \t\t\t\t    == TYPE_CODE_ENUM))\n \t\t\t   && (!treg.has_value ()\n \t\t\t       || treg_matches_sym_type_name (*treg, sym)))\n \t\t\t  || (kind == FUNCTIONS_DOMAIN\n-\t\t\t      && SYMBOL_CLASS (sym) == LOC_BLOCK\n+\t\t\t      && sym->aclass () == LOC_BLOCK\n \t\t\t      && (!treg.has_value ()\n \t\t\t\t  || treg_matches_sym_type_name (*treg,\n \t\t\t\t\t\t\t\t sym)))\n \t\t\t  || (kind == TYPES_DOMAIN\n-\t\t\t      && SYMBOL_CLASS (sym) == LOC_TYPEDEF\n+\t\t\t      && sym->aclass () == LOC_TYPEDEF\n \t\t\t      && SYMBOL_DOMAIN (sym) != MODULE_DOMAIN)\n \t\t\t  || (kind == MODULES_DOMAIN\n \t\t\t      && SYMBOL_DOMAIN (sym) == MODULE_DOMAIN\n@@ -5056,7 +5056,7 @@ symbol_to_info_string (struct symbol *sym, int block,\n       string_file tmp_stream;\n \n       type_print (SYMBOL_TYPE (sym),\n-\t\t  (SYMBOL_CLASS (sym) == LOC_TYPEDEF\n+\t\t  (sym->aclass () == LOC_TYPEDEF\n \t\t   ? \"\" : sym->print_name ()),\n \t\t  &tmp_stream, 0);\n \n@@ -5526,7 +5526,7 @@ completion_list_add_symbol (completion_tracker &tracker,\n      tracker.  */\n   if (sym->language () == language_cplus\n       && SYMBOL_DOMAIN (sym) == VAR_DOMAIN\n-      && SYMBOL_CLASS (sym) == LOC_BLOCK)\n+      && sym->aclass () == LOC_BLOCK)\n     {\n       /* The call to canonicalize returns the empty string if the input\n \t string is already in canonical form, thanks to this we don't\n@@ -5671,7 +5671,7 @@ completion_list_add_fields (completion_tracker &tracker,\n \t\t\t    const lookup_name_info &lookup_name,\n \t\t\t    const char *text, const char *word)\n {\n-  if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)\n+  if (sym->aclass () == LOC_TYPEDEF)\n     {\n       struct type *t = SYMBOL_TYPE (sym);\n       enum type_code c = t->code ();\n@@ -5723,7 +5723,7 @@ symbol_is_function_or_method (minimal_symbol *msymbol)\n bound_minimal_symbol\n find_gnu_ifunc (const symbol *sym)\n {\n-  if (SYMBOL_CLASS (sym) != LOC_BLOCK)\n+  if (sym->aclass () != LOC_BLOCK)\n     return {};\n \n   lookup_name_info lookup_name (sym->search_name (),\n@@ -6572,7 +6572,7 @@ CORE_ADDR\n get_symbol_address (const struct symbol *sym)\n {\n   gdb_assert (sym->maybe_copied);\n-  gdb_assert (SYMBOL_CLASS (sym) == LOC_STATIC);\n+  gdb_assert (sym->aclass () == LOC_STATIC);\n \n   const char *linkage_name = sym->linkage_name ();\n "
    },
    {
      "sha": "a00b48f868e9956cb518d30c187f0509015973e5",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -1153,6 +1153,11 @@ struct symbol : public general_symbol_info, public allocate_on_obstack\n     return symbol_impls[this->aclass_index ()];\n   }\n \n+  address_class aclass () const\n+  {\n+    return this->impl ().aclass;\n+  }\n+\n   /* Data type of value */\n \n   struct type *type = nullptr;\n@@ -1256,7 +1261,6 @@ struct block_symbol\n    \"private\".  */\n \n #define SYMBOL_DOMAIN(symbol)\t(symbol)->domain\n-#define SYMBOL_CLASS(symbol)\t\t((symbol)->impl ().aclass)\n #define SYMBOL_OBJFILE_OWNED(symbol)\t((symbol)->is_objfile_owned)\n #define SYMBOL_IS_ARGUMENT(symbol)\t(symbol)->is_argument\n #define SYMBOL_INLINED(symbol)\t\t(symbol)->is_inlined"
    },
    {
      "sha": "807f5a312ae9f75aadac28b15863aa4ea4fdaf2e",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -696,14 +696,14 @@ validate_actionline (const char *line, struct breakpoint *b)\n \t\t       (exp->op.get ()));\n \t\t  sym = vvop->get_symbol ();\n \n-\t\t  if (SYMBOL_CLASS (sym) == LOC_CONST)\n+\t\t  if (sym->aclass () == LOC_CONST)\n \t\t    {\n \t\t      error (_(\"constant `%s' (value %s) \"\n \t\t\t       \"will not be collected.\"),\n \t\t\t     sym->print_name (),\n \t\t\t     plongest (SYMBOL_VALUE (sym)));\n \t\t    }\n-\t\t  else if (SYMBOL_CLASS (sym) == LOC_OPTIMIZED_OUT)\n+\t\t  else if (sym->aclass () == LOC_OPTIMIZED_OUT)\n \t\t    {\n \t\t      error (_(\"`%s' is optimized away \"\n \t\t\t       \"and cannot be collected.\"),\n@@ -928,11 +928,11 @@ collection_list::collect_symbol (struct symbol *sym,\n   int treat_as_expr = 0;\n \n   len = TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym)));\n-  switch (SYMBOL_CLASS (sym))\n+  switch (sym->aclass ())\n     {\n     default:\n       printf_filtered (\"%s: don't know symbol class %d\\n\",\n-\t\t       sym->print_name (), SYMBOL_CLASS (sym));\n+\t\t       sym->print_name (), sym->aclass ());\n       break;\n     case LOC_CONST:\n       printf_filtered (\"constant %s (value %s) will not be collected.\\n\",\n@@ -2550,12 +2550,12 @@ info_scope_command (const char *args_in, int from_tty)\n \t\t\t\t\t\t\t  gdb_stdout);\n \t  else\n \t    {\n-\t      switch (SYMBOL_CLASS (sym))\n+\t      switch (sym->aclass ())\n \t\t{\n \t\tdefault:\n \t\tcase LOC_UNDEF:\t/* Messed up symbol?  */\n \t\t  printf_filtered (\"a bogus symbol, class %d.\\n\",\n-\t\t\t\t   SYMBOL_CLASS (sym));\n+\t\t\t\t   sym->aclass ());\n \t\t  count--;\t\t/* Don't count this one.  */\n \t\t  continue;\n \t\tcase LOC_CONST:"
    },
    {
      "sha": "1de223ac5a108f701a74eca5d09686272a59023a",
      "filename": "gdb/typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/typeprint.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -255,7 +255,7 @@ typedef_hash_table::add_template_parameters (struct type *t)\n       void **slot;\n \n       /* We only want type-valued template parameters in the hash.  */\n-      if (SYMBOL_CLASS (TYPE_TEMPLATE_ARGUMENT (t, i)) != LOC_TYPEDEF)\n+      if (TYPE_TEMPLATE_ARGUMENT (t, i)->aclass () != LOC_TYPEDEF)\n \tcontinue;\n \n       tf = XOBNEW (&m_storage, struct decl_field);"
    },
    {
      "sha": "9767b2c30e695e9368b8605f97d0a3bdc99a8e92",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66d7f48f8045adf266046df7ceb84161d5678cfa/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=66d7f48f8045adf266046df7ceb84161d5678cfa",
      "patch": "@@ -120,7 +120,7 @@ find_function_in_inferior (const char *name, struct objfile **objf_p)\n   sym = lookup_symbol (name, 0, VAR_DOMAIN, 0);\n   if (sym.symbol != NULL)\n     {\n-      if (SYMBOL_CLASS (sym.symbol) != LOC_BLOCK)\n+      if (sym.symbol->aclass () != LOC_BLOCK)\n \t{\n \t  error (_(\"\\\"%s\\\" exists in this program but is not a function.\"),\n \t\t name);\n@@ -3779,7 +3779,7 @@ value_maybe_namespace_elt (const struct type *curtype,\n   if (sym.symbol == NULL)\n     return NULL;\n   else if ((noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t   && (SYMBOL_CLASS (sym.symbol) == LOC_TYPEDEF))\n+\t   && (sym.symbol->aclass () == LOC_TYPEDEF))\n     result = allocate_value (SYMBOL_TYPE (sym.symbol));\n   else\n     result = value_of_variable (sym.symbol, sym.block);"
    }
  ]
}