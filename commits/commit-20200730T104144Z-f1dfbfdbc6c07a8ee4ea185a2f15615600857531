{
  "sha": "f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjFkZmJmZGJjNmMwN2E4ZWU0ZWExODVhMmYxNTYxNTYwMDg1NzUzMQ==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-07-30T10:41:30Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-07-30T10:41:44Z"
    },
    "message": "elf: Add sym_cache to elf_link_hash_table\n\nSince many ELF backends have sym_cache to their link hash tables, add\nsym_cache to elf_link_hash_table.  Also use sdynbss and srelbss in\nelf_link_hash_table.\n\n\t* elf-bfd.h (sym_cache): Moved before elf_link_hash_table.\n\t(elf_link_hash_table): Add sym_cache.\n\t* elf32-arm.c (elf32_arm_link_hash_table): Remove sym_cache.\n\t(elf32_arm_check_relocs): Updated.\n\t(elf32_arm_size_dynamic_sections): Likewise.\n\t* elf32-bfin.c (bfin_link_hash_table): Removed.\n\t(bfin_link_hash_newfunc): Updated.\n\t(bfin_hash_table): Removed.\n\t* elf32-csky.c (csky_elf_link_hash_table): Remove sym_cache.\n\t(csky_elf_check_relocs): Updated.\n\t* elf32-hppa.c (elf32_hppa_link_hash_table): Remove sym_cache.\n\t(elf32_hppa_check_relocs): Updated.\n\t* elf32-i386.c (elf_i386_tls_transition): Updated.\n\t(elf_i386_convert_load_reloc): Likewise.\n\t(elf_i386_check_relocs): Likewise.\n\t* elf32-m32r.c (elf_m32r_link_hash_table): Removed.\n\t(m32r_elf_hash_table): Updated.\n\t(m32r_elf_link_hash_table_create): Likewise.\n\t(m32r_elf_create_dynamic_sections): Likewise.\n\t(m32r_elf_adjust_dynamic_symbol): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(m32r_elf_size_dynamic_sections): Likewise.\n\t(m32r_elf_relocate_section): Likewise.\n\t(m32r_elf_finish_dynamic_symbol): Likewise.\n\t(m32r_elf_check_relocs): Likewise.\n\t* elf32-m68hc1x.h (m68hc11_elf_link_hash_table): Remove\n\tsym_cache.\n\t* elf32-m68k.c (elf_m68k_link_hash_table): Likewise.\n\t(elf_m68k_check_relocs): Updated.\n\t* elf32-metag.c (elf_metag_link_hash_table): Remove sym_cache.\n\t(elf_metag_check_relocs): Updated.\n\t* elf32-microblaze.c (elf32_mb_link_hash_table): Remove sym_sec.\n\t(microblaze_elf_check_relocs): Updated.\n\t* elf32-nds32.c (nds32_elf_link_hash_table_create): Likewise.\n\t(nds32_elf_create_dynamic_sections): Likewise.\n\t(nds32_elf_adjust_dynamic_symbol): Likewise.\n\t(nds32_elf_check_relocs): Likewise.\n\t* elf32-nds32.h (elf_nds32_link_hash_table): Remove sdynbss,\n\tsrelbss and aym_cache.\n\t* elf32-nios2.c (elf32_nios2_link_hash_table): Remove sym_cache.\n\t(nios2_elf32_check_relocs): Updated.\n\t* elf32-or1k.c (elf_or1k_link_hash_table): Remove sym_sec.\n\t(or1k_elf_check_relocs): Updated.\n\t* elf32-ppc.c (ppc_elf_check_relocs): Remove sym_cache.\n\t(ppc_elf_check_relocs): Updated.\n\t* elf32-s390.c (elf_s390_link_hash_table): Remove sym_cache.\n\t(elf_s390_check_relocs): Updated.\n\t(elf_s390_finish_dynamic_sections): Likewise.\n\t* elf32-sh.c (elf_sh_link_hash_table): Remove sdynbss, srelbss\n\tand aym_cache.\n\t(sh_elf_create_dynamic_sections): Updated.\n\t(sh_elf_adjust_dynamic_symbol): Likewise.\n\t(sh_elf_size_dynamic_sections): Likewise.\n\t(sh_elf_check_relocs): Likewise.\n\t* elf32-tic6x.c (elf32_tic6x_link_hash_table): Remove sym_cache.\n\t(elf32_tic6x_check_relocs): Updated.\n\t* elf32-tilepro.c (tilepro_elf_link_hash_table): Removed.\n\t(tilepro_elf_hash_table): Updated.\n\t(tilepro_elf_link_hash_table_create): Likewise.\n\t(tilepro_elf_check_relocs): Likewise.\n\t(tilepro_elf_adjust_dynamic_symbol): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(tilepro_elf_size_dynamic_sections): Likewise.\n\t(tilepro_elf_relocate_section): Likewise.\n\t(tilepro_elf_finish_dynamic_symbol): Likewise.\n\t(tilepro_finish_dyn): Likewise.\n\t(tilepro_elf_finish_dynamic_sections): Likewise.\n\t* elf64-ppc.c (ppc_link_hash_table): Remove sym_cache.\n\t(ppc64_elf_before_check_relocs): Updated.\n\t(ppc64_elf_check_relocs): Likewise.\n\t* elf64-s390.c (elf_s390_link_hash_table): Remove sym_cache.\n\t(elf_s390_check_relocs): Updated.\n\t(elf_s390_relocate_section): Likewise.\n\t(elf_s390_finish_dynamic_sections): Likewise.\n\t* elf64-x86-64.c (elf_x86_64_tls_transition): Likewise.\n\t(elf_x86_64_check_relocs): Likewise.\n\t* elfnn-aarch64.c (elf_aarch64_link_hash_table): Remove\n\tsym_cache.\n\t(elfNN_aarch64_check_relocs): Updated.\n\t* elfnn-riscv.c (riscv_elf_link_hash_table): Remove sym_cache.\n\t(riscv_elf_check_relocs): Updated.\n\t* elfxx-mips.c (mips_elf_link_hash_table): Remove sym_cache.\n\t(mips_elf_resolve_got_page_ref): Updated.\n\t* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.\n\t* elfxx-sparc.h (_bfd_sparc_elf_link_hash_table): Remove\n\tsym_cache.\n\t* elfxx-tilegx.c (tilegx_elf_link_hash_table): Likewise.\n\t(tilegx_elf_check_relocs): Updated.\n\t* elfxx-x86.h (elf_x86_link_hash_table): Remove sym_cache.",
    "tree": {
      "sha": "bf9191cd8e6d39ac0a0aaf6d2ff945660feec1d0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bf9191cd8e6d39ac0a0aaf6d2ff945660feec1d0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6cc64caabac2f835149d0931d5ab689ccca1ca08",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6cc64caabac2f835149d0931d5ab689ccca1ca08",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6cc64caabac2f835149d0931d5ab689ccca1ca08"
    }
  ],
  "stats": {
    "total": 666,
    "additions": 326,
    "deletions": 340
  },
  "files": [
    {
      "sha": "e9d135ebb65c4ca0ed3f86819cacaa1e269941b2",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 92,
      "deletions": 0,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -1,3 +1,95 @@\n+2020-07-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* elf-bfd.h (sym_cache): Moved before elf_link_hash_table.\n+\t(elf_link_hash_table): Add sym_cache.\n+\t* elf32-arm.c (elf32_arm_link_hash_table): Remove sym_cache.\n+\t(elf32_arm_check_relocs): Updated.\n+\t(elf32_arm_size_dynamic_sections): Likewise.\n+\t* elf32-bfin.c (bfin_link_hash_table): Removed.\n+\t(bfin_link_hash_newfunc): Updated.\n+\t(bfin_hash_table): Removed.\n+\t* elf32-csky.c (csky_elf_link_hash_table): Remove sym_cache.\n+\t(csky_elf_check_relocs): Updated.\n+\t* elf32-hppa.c (elf32_hppa_link_hash_table): Remove sym_cache.\n+\t(elf32_hppa_check_relocs): Updated.\n+\t* elf32-i386.c (elf_i386_tls_transition): Updated.\n+\t(elf_i386_convert_load_reloc): Likewise.\n+\t(elf_i386_check_relocs): Likewise.\n+\t* elf32-m32r.c (elf_m32r_link_hash_table): Removed.\n+\t(m32r_elf_hash_table): Updated.\n+\t(m32r_elf_link_hash_table_create): Likewise.\n+\t(m32r_elf_create_dynamic_sections): Likewise.\n+\t(m32r_elf_adjust_dynamic_symbol): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(m32r_elf_size_dynamic_sections): Likewise.\n+\t(m32r_elf_relocate_section): Likewise.\n+\t(m32r_elf_finish_dynamic_symbol): Likewise.\n+\t(m32r_elf_check_relocs): Likewise.\n+\t* elf32-m68hc1x.h (m68hc11_elf_link_hash_table): Remove\n+\tsym_cache.\n+\t* elf32-m68k.c (elf_m68k_link_hash_table): Likewise.\n+\t(elf_m68k_check_relocs): Updated.\n+\t* elf32-metag.c (elf_metag_link_hash_table): Remove sym_cache.\n+\t(elf_metag_check_relocs): Updated.\n+\t* elf32-microblaze.c (elf32_mb_link_hash_table): Remove sym_sec.\n+\t(microblaze_elf_check_relocs): Updated.\n+\t* elf32-nds32.c (nds32_elf_link_hash_table_create): Likewise.\n+\t(nds32_elf_create_dynamic_sections): Likewise.\n+\t(nds32_elf_adjust_dynamic_symbol): Likewise.\n+\t(nds32_elf_check_relocs): Likewise.\n+\t* elf32-nds32.h (elf_nds32_link_hash_table): Remove sdynbss,\n+\tsrelbss and aym_cache.\n+\t* elf32-nios2.c (elf32_nios2_link_hash_table): Remove sym_cache.\n+\t(nios2_elf32_check_relocs): Updated.\n+\t* elf32-or1k.c (elf_or1k_link_hash_table): Remove sym_sec.\n+\t(or1k_elf_check_relocs): Updated.\n+\t* elf32-ppc.c (ppc_elf_check_relocs): Remove sym_cache.\n+\t(ppc_elf_check_relocs): Updated.\n+\t* elf32-s390.c (elf_s390_link_hash_table): Remove sym_cache.\n+\t(elf_s390_check_relocs): Updated.\n+\t(elf_s390_finish_dynamic_sections): Likewise.\n+\t* elf32-sh.c (elf_sh_link_hash_table): Remove sdynbss, srelbss\n+\tand aym_cache.\n+\t(sh_elf_create_dynamic_sections): Updated.\n+\t(sh_elf_adjust_dynamic_symbol): Likewise.\n+\t(sh_elf_size_dynamic_sections): Likewise.\n+\t(sh_elf_check_relocs): Likewise.\n+\t* elf32-tic6x.c (elf32_tic6x_link_hash_table): Remove sym_cache.\n+\t(elf32_tic6x_check_relocs): Updated.\n+\t* elf32-tilepro.c (tilepro_elf_link_hash_table): Removed.\n+\t(tilepro_elf_hash_table): Updated.\n+\t(tilepro_elf_link_hash_table_create): Likewise.\n+\t(tilepro_elf_check_relocs): Likewise.\n+\t(tilepro_elf_adjust_dynamic_symbol): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(tilepro_elf_size_dynamic_sections): Likewise.\n+\t(tilepro_elf_relocate_section): Likewise.\n+\t(tilepro_elf_finish_dynamic_symbol): Likewise.\n+\t(tilepro_finish_dyn): Likewise.\n+\t(tilepro_elf_finish_dynamic_sections): Likewise.\n+\t* elf64-ppc.c (ppc_link_hash_table): Remove sym_cache.\n+\t(ppc64_elf_before_check_relocs): Updated.\n+\t(ppc64_elf_check_relocs): Likewise.\n+\t* elf64-s390.c (elf_s390_link_hash_table): Remove sym_cache.\n+\t(elf_s390_check_relocs): Updated.\n+\t(elf_s390_relocate_section): Likewise.\n+\t(elf_s390_finish_dynamic_sections): Likewise.\n+\t* elf64-x86-64.c (elf_x86_64_tls_transition): Likewise.\n+\t(elf_x86_64_check_relocs): Likewise.\n+\t* elfnn-aarch64.c (elf_aarch64_link_hash_table): Remove\n+\tsym_cache.\n+\t(elfNN_aarch64_check_relocs): Updated.\n+\t* elfnn-riscv.c (riscv_elf_link_hash_table): Remove sym_cache.\n+\t(riscv_elf_check_relocs): Updated.\n+\t* elfxx-mips.c (mips_elf_link_hash_table): Remove sym_cache.\n+\t(mips_elf_resolve_got_page_ref): Updated.\n+\t* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.\n+\t* elfxx-sparc.h (_bfd_sparc_elf_link_hash_table): Remove\n+\tsym_cache.\n+\t* elfxx-tilegx.c (tilegx_elf_link_hash_table): Likewise.\n+\t(tilegx_elf_check_relocs): Updated.\n+\t* elfxx-x86.h (elf_x86_link_hash_table): Remove sym_cache.\n+\n 2020-07-29  Maciej W. Rozycki  <macro@linux-mips.org>\n \n \t* elflink.c (bfd_elf_final_link): Give local symbols a name if"
    },
    {
      "sha": "cd352d2a8e07f1b3a97965a75ed865d9a6bab007",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -549,6 +549,16 @@ enum elf_target_os\n   is_nacl\t/* Native Client.  */\n };\n \n+/* Used by bfd_sym_from_r_symndx to cache a small number of local\n+   symbols.  */\n+#define LOCAL_SYM_CACHE_SIZE 32\n+struct sym_cache\n+{\n+  bfd *abfd;\n+  unsigned long indx[LOCAL_SYM_CACHE_SIZE];\n+  Elf_Internal_Sym sym[LOCAL_SYM_CACHE_SIZE];\n+};\n+\n /* ELF linker hash table.  */\n \n struct elf_link_hash_table\n@@ -676,6 +686,9 @@ struct elf_link_hash_table\n   /* A linked list of dynamic BFD's loaded in the link.  */\n   struct elf_link_loaded_list *dyn_loaded;\n \n+  /* Small local sym cache.  */\n+  struct sym_cache sym_cache;\n+\n   /* Short-cuts to get to dynamic linker sections.  */\n   asection *sgot;\n   asection *sgotplt;\n@@ -717,16 +730,6 @@ struct elf_link_hash_table\n /* Returns TRUE if the hash table is a struct elf_link_hash_table.  */\n #define is_elf_hash_table(htab)\t\t\t\t\t\t\\\n   (((struct bfd_link_hash_table *) (htab))->type == bfd_link_elf_hash_table)\n-\n-/* Used by bfd_sym_from_r_symndx to cache a small number of local\n-   symbols.  */\n-#define LOCAL_SYM_CACHE_SIZE 32\n-struct sym_cache\n-{\n-  bfd *abfd;\n-  unsigned long indx[LOCAL_SYM_CACHE_SIZE];\n-  Elf_Internal_Sym sym[LOCAL_SYM_CACHE_SIZE];\n-};\n \f\n /* Constant information held for an ELF backend.  */\n "
    },
    {
      "sha": "283a6140304b8d61c231de9c0b1b69554f51e0a3",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -3390,9 +3390,6 @@ struct elf32_arm_link_hash_table\n     bfd_vma offset;\n   } tls_ldm_got;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* For convenience in allocate_dynrelocs.  */\n   bfd * obfd;\n \n@@ -15316,7 +15313,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t  if (r_symndx < symtab_hdr->sh_info)\n \t    {\n \t      /* A local symbol.  */\n-\t      isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t      isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,\n \t\t\t\t\t    abfd, r_symndx);\n \t      if (isym == NULL)\n \t\treturn FALSE;\n@@ -16871,7 +16868,8 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t\t  s->size += 4;\n \t\t}\n \n-\t      isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, symndx);\n+\t      isym = bfd_sym_from_r_symndx (&htab->root.sym_cache, ibfd,\n+\t\t\t\t\t    symndx);\n \t      if (isym == NULL)\n \t\treturn FALSE;\n "
    },
    {
      "sha": "f6ecc380d8e7da434e1a33d8a2faee027babb0ab",
      "filename": "bfd/elf32-bfin.c",
      "status": "modified",
      "additions": 4,
      "deletions": 21,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-bfin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-bfin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-bfin.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -4791,16 +4791,6 @@ struct bfin_link_hash_entry\n   struct bfin_pcrel_relocs_copied *pcrel_relocs_copied;\n };\n \n-/* bfin ELF linker hash table.  */\n-\n-struct bfin_link_hash_table\n-{\n-  struct elf_link_hash_table root;\n-\n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-};\n-\n #define bfin_hash_entry(ent) ((struct bfin_link_hash_entry *) (ent))\n \n static struct bfd_hash_entry *\n@@ -4829,25 +4819,22 @@ bfin_link_hash_newfunc (struct bfd_hash_entry *entry,\n static struct bfd_link_hash_table *\n bfin_link_hash_table_create (bfd * abfd)\n {\n-  struct bfin_link_hash_table *ret;\n-  size_t amt = sizeof (struct bfin_link_hash_table);\n+  struct elf_link_hash_table *ret;\n+  size_t amt = sizeof (struct elf_link_hash_table);\n \n   ret = bfd_zmalloc (amt);\n   if (ret == NULL)\n     return NULL;\n \n-  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,\n-\t\t\t\t      bfin_link_hash_newfunc,\n+  if (!_bfd_elf_link_hash_table_init (ret, abfd, bfin_link_hash_newfunc,\n \t\t\t\t      sizeof (struct elf_link_hash_entry),\n \t\t\t\t      BFIN_ELF_DATA))\n     {\n       free (ret);\n       return NULL;\n     }\n \n-  ret->sym_cache.abfd = NULL;\n-\n-  return &ret->root.root;\n+  return &ret->root;\n }\n \n /* The size in bytes of an entry in the procedure linkage table.  */\n@@ -5418,10 +5405,6 @@ struct bfd_elf_special_section const elf32_bfin_special_sections[] =\n \n #define bfd_elf32_bfd_is_local_label_name \\\n \t\t\t\t\tbfin_is_local_label_name\n-#define bfin_hash_table(p) \\\n-  ((struct bfin_link_hash_table *) (p)->hash)\n-\n-\n \n #define elf_backend_create_dynamic_sections \\\n \t\t\t\t\t_bfd_elf_create_dynamic_sections"
    },
    {
      "sha": "2998aad2055bd7db85f230b455ebeec9ee93e7f1",
      "filename": "bfd/elf32-csky.c",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-csky.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -1208,9 +1208,6 @@ struct csky_elf_link_hash_table\n {\n   struct elf_link_hash_table elf;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* Data for R_CKCORE_TLS_LDM32 relocations.  */\n   union\n   {\n@@ -2477,7 +2474,7 @@ csky_elf_check_relocs (bfd * abfd,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\tabfd, r_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;\n@@ -2584,7 +2581,7 @@ csky_elf_check_relocs (bfd * abfd,\n \t\t  asection *s;\n \t\t  Elf_Internal_Sym *loc_isym;\n \n-\t\t  loc_isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  loc_isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\t    abfd, r_symndx);\n \t\t  if (loc_isym == NULL)\n \t\t    return FALSE;"
    },
    {
      "sha": "56284eaf0071889a14bc0730de9fc6db76b80e90",
      "filename": "bfd/elf32-hppa.c",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-hppa.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -286,9 +286,6 @@ struct elf32_hppa_link_hash_table\n   /* Set if we need a .plt stub to support lazy dynamic linking.  */\n   unsigned int need_plt_stub:1;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* Data for LDM relocations.  */\n   union\n   {\n@@ -1465,7 +1462,7 @@ elf32_hppa_check_relocs (bfd *abfd,\n \t\t  void *vpp;\n \t\t  Elf_Internal_Sym *isym;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->etab.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;\n@@ -4038,7 +4035,7 @@ elf32_hppa_relocate_section (bfd *output_bfd,\n \t\telse\n \t\t  {\n \t\t    Elf_Internal_Sym *isym\n-\t\t      = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t      = bfd_sym_from_r_symndx (&htab->etab.sym_cache,\n \t\t\t\t\t       input_bfd, r_symndx);\n \t\t    if (isym == NULL)\n \t\t      return FALSE;"
    },
    {
      "sha": "7ae881be0ad9470900f506306fcedb9a92c57566",
      "filename": "bfd/elf32-i386.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-i386.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -1158,7 +1158,7 @@ elf_i386_tls_transition (struct bfd_link_info *info, bfd *abfd,\n \t    {\n \t      Elf_Internal_Sym *isym;\n \n-\t      isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t    abfd, r_symndx);\n \t      name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);\n \t    }\n@@ -1251,7 +1251,7 @@ elf_i386_convert_load_reloc (bfd *abfd, Elf_Internal_Shdr *symtab_hdr,\n   else\n     {\n       local_ref = TRUE;\n-      isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd,\n+      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, abfd,\n \t\t\t\t    r_symndx);\n       abs_symbol = isym->st_shndx == SHN_ABS;\n     }\n@@ -1529,7 +1529,7 @@ elf_i386_check_relocs (bfd *abfd,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\tabfd, r_symndx);\n \t  if (isym == NULL)\n \t    goto error_return;\n@@ -1859,7 +1859,7 @@ elf_i386_check_relocs (bfd *abfd,\n \t\t  void **vpp;\n \t\t  asection *s;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    goto error_return;"
    },
    {
      "sha": "2eae00b8e28f0ef85d5242ece1cb61b1728a1ca5",
      "filename": "bfd/elf32-m32r.c",
      "status": "modified",
      "additions": 57,
      "deletions": 71,
      "changes": 128,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32r.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -1498,20 +1498,6 @@ struct elf_m32r_pcrel_relocs_copied\n   bfd_size_type count;\n };\n \n-/* m32r ELF linker hash table.  */\n-\n-struct elf_m32r_link_hash_table\n-{\n-  struct elf_link_hash_table root;\n-\n-  /* Short-cuts to get to dynamic linker sections.  */\n-  asection *sdynbss;\n-  asection *srelbss;\n-\n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-};\n-\n /* Traverse an m32r ELF linker hash table.  */\n \n #define m32r_elf_link_hash_traverse(table, func, info)\t\t\t\\\n@@ -1524,21 +1510,21 @@ struct elf_m32r_link_hash_table\n \n #define m32r_elf_hash_table(p) \\\n   (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \\\n-  == M32R_ELF_DATA ? ((struct elf_m32r_link_hash_table *) ((p)->hash)) : NULL)\n+  == M32R_ELF_DATA ? ((struct elf_link_hash_table *) ((p)->hash)) : NULL)\n \n /* Create an m32r ELF linker hash table.  */\n \n static struct bfd_link_hash_table *\n m32r_elf_link_hash_table_create (bfd *abfd)\n {\n-  struct elf_m32r_link_hash_table *ret;\n-  size_t amt = sizeof (struct elf_m32r_link_hash_table);\n+  struct elf_link_hash_table *ret;\n+  size_t amt = sizeof (struct elf_link_hash_table);\n \n   ret = bfd_zmalloc (amt);\n   if (ret == NULL)\n     return NULL;\n \n-  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,\n+  if (!_bfd_elf_link_hash_table_init (ret, abfd,\n \t\t\t\t      _bfd_elf_link_hash_newfunc,\n \t\t\t\t      sizeof (struct elf_link_hash_entry),\n \t\t\t\t      M32R_ELF_DATA))\n@@ -1547,15 +1533,15 @@ m32r_elf_link_hash_table_create (bfd *abfd)\n       return NULL;\n     }\n \n-  return &ret->root.root;\n+  return &ret->root;\n }\n \n /* Create dynamic sections when linking against a dynamic object.  */\n \n static bfd_boolean\n m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n {\n-  struct elf_m32r_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   flagword flags, pltflags;\n   asection *s;\n   const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n@@ -1578,7 +1564,7 @@ m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n     pltflags |= SEC_READONLY;\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n-  htab->root.splt = s;\n+  htab->splt = s;\n   if (s == NULL\n       || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n@@ -1598,7 +1584,7 @@ m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       h = (struct elf_link_hash_entry *) bh;\n       h->def_regular = 1;\n       h->type = STT_OBJECT;\n-      htab->root.hplt = h;\n+      htab->hplt = h;\n \n       if (bfd_link_pic (info)\n \t  && ! bfd_elf_link_record_dynamic_symbol (info, h))\n@@ -1609,12 +1595,12 @@ m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  bed->default_use_rela_p\n \t\t\t\t\t  ? \".rela.plt\" : \".rel.plt\",\n \t\t\t\t\t  flags | SEC_READONLY);\n-  htab->root.srelplt = s;\n+  htab->srelplt = s;\n   if (s == NULL\n       || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n-  if (htab->root.sgot == NULL\n+  if (htab->sgot == NULL\n       && !_bfd_elf_create_got_section (abfd, info))\n     return FALSE;\n \n@@ -1669,7 +1655,7 @@ static bfd_boolean\n m32r_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t\t\t\tstruct elf_link_hash_entry *h)\n {\n-  struct elf_m32r_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   bfd *dynobj;\n   asection *s;\n \n@@ -1796,7 +1782,7 @@ static bfd_boolean\n allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n {\n   struct bfd_link_info *info;\n-  struct elf_m32r_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -1807,7 +1793,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   if (htab == NULL)\n     return FALSE;\n \n-  if (htab->root.dynamic_sections_created\n+  if (htab->dynamic_sections_created\n       && h->plt.refcount > 0)\n     {\n       /* Make sure this symbol is output as a dynamic symbol.\n@@ -1821,7 +1807,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n       if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h))\n \t{\n-\t  asection *s = htab->root.splt;\n+\t  asection *s = htab->splt;\n \n \t  /* If this is the first .plt entry, make room for the special\n \t     first entry.  */\n@@ -1847,10 +1833,10 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n \t  /* We also need to make an entry in the .got.plt section, which\n \t     will be placed in the .got section by the linker script.  */\n-\t  htab->root.sgotplt->size += 4;\n+\t  htab->sgotplt->size += 4;\n \n \t  /* We also need to make an entry in the .rel.plt section.  */\n-\t  htab->root.srelplt->size += sizeof (Elf32_External_Rela);\n+\t  htab->srelplt->size += sizeof (Elf32_External_Rela);\n \t}\n       else\n \t{\n@@ -1878,13 +1864,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t    return FALSE;\n \t}\n \n-      s = htab->root.sgot;\n+      s = htab->sgot;\n \n       h->got.offset = s->size;\n       s->size += 4;\n-      dyn = htab->root.dynamic_sections_created;\n+      dyn = htab->dynamic_sections_created;\n       if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h))\n-\thtab->root.srelgot->size += sizeof (Elf32_External_Rela);\n+\thtab->srelgot->size += sizeof (Elf32_External_Rela);\n     }\n   else\n     h->got.offset = (bfd_vma) -1;\n@@ -1944,7 +1930,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n       if (!h->non_got_ref\n \t  && ((h->def_dynamic\n \t       && !h->def_regular)\n-\t      || (htab->root.dynamic_sections_created\n+\t      || (htab->dynamic_sections_created\n \t\t  && (h->root.type == bfd_link_hash_undefweak\n \t\t      || h->root.type == bfd_link_hash_undefined))))\n \t{\n@@ -1984,7 +1970,7 @@ static bfd_boolean\n m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t\t\tstruct bfd_link_info *info)\n {\n-  struct elf_m32r_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   bfd *dynobj;\n   asection *s;\n   bfd_boolean relocs;\n@@ -1998,10 +1984,10 @@ m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n   if (htab == NULL)\n     return FALSE;\n \n-  dynobj = htab->root.dynobj;\n+  dynobj = htab->dynobj;\n   BFD_ASSERT (dynobj != NULL);\n \n-  if (htab->root.dynamic_sections_created)\n+  if (htab->dynamic_sections_created)\n     {\n       /* Set the contents of the .interp section to the interpreter.  */\n       if (bfd_link_executable (info) && !info->nointerp)\n@@ -2060,8 +2046,8 @@ m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n       symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;\n       locsymcount = symtab_hdr->sh_info;\n       end_local_got = local_got + locsymcount;\n-      s = htab->root.sgot;\n-      srel = htab->root.srelgot;\n+      s = htab->sgot;\n+      srel = htab->srelgot;\n       for (; local_got < end_local_got; ++local_got)\n \t{\n \t  if (*local_got > 0)\n@@ -2078,7 +2064,7 @@ m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n   /* Allocate global sym .plt and .got entries, and space for global\n      sym dynamic relocs.  */\n-  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);\n+  elf_link_hash_traverse (htab, allocate_dynrelocs, info);\n \n   /* We now have determined the sizes of the various dynamic sections.\n      Allocate memory for them.  */\n@@ -2088,17 +2074,17 @@ m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n       if ((s->flags & SEC_LINKER_CREATED) == 0)\n \tcontinue;\n \n-      if (s == htab->root.splt\n-\t  || s == htab->root.sgot\n-\t  || s == htab->root.sgotplt\n+      if (s == htab->splt\n+\t  || s == htab->sgot\n+\t  || s == htab->sgotplt\n \t  || s == htab->sdynbss)\n \t{\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n       else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n-\t  if (s->size != 0 && s != htab->root.srelplt)\n+\t  if (s->size != 0 && s != htab->srelplt)\n \t    relocs = TRUE;\n \n \t  /* We use the reloc_count field as a counter if we need\n@@ -2188,7 +2174,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n   Elf_Internal_Rela *rel, *relend;\n   /* Assume success.  */\n   bfd_boolean ret = TRUE;\n-  struct elf_m32r_link_hash_table *htab = m32r_elf_hash_table (info);\n+  struct elf_link_hash_table *htab = m32r_elf_hash_table (info);\n   bfd_vma *local_got_offsets;\n   asection *sgot, *splt, *sreloc;\n   bfd_vma high_address = bfd_get_section_limit (input_bfd, input_section);\n@@ -2198,8 +2184,8 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n   local_got_offsets = elf_local_got_offsets (input_bfd);\n \n-  sgot = htab->root.sgot;\n-  splt = htab->root.splt;\n+  sgot = htab->sgot;\n+  splt = htab->splt;\n   sreloc = NULL;\n \n   rel = relocs;\n@@ -2295,7 +2281,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t      bfd_boolean dyn;\n \t      sec = h->root.u.def.section;\n \n-\t      dyn = htab->root.dynamic_sections_created;\n+\t      dyn = htab->dynamic_sections_created;\n \t      sec = h->root.u.def.section;\n \t      if (r_type == R_M32R_GOTPC24\n \t\t  || (r_type == R_M32R_GOTPC_HI_ULO\n@@ -2516,7 +2502,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t  off = h->got.offset;\n \t\t  BFD_ASSERT (off != (bfd_vma) -1);\n \n-\t\t  dyn = htab->root.dynamic_sections_created;\n+\t\t  dyn = htab->dynamic_sections_created;\n \t\t  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,\n \t\t\t\t\t\t\t bfd_link_pic (info),\n \t\t\t\t\t\t\t h)\n@@ -2576,7 +2562,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n \t\t\t  /* We need to generate a R_M32R_RELATIVE reloc\n \t\t\t     for the dynamic linker.  */\n-\t\t\t  srelgot = htab->root.srelgot;\n+\t\t\t  srelgot = htab->srelgot;\n \t\t\t  BFD_ASSERT (srelgot != NULL);\n \n \t\t\t  outrel.r_offset = (sgot->output_section->vma\n@@ -2892,7 +2878,7 @@ m32r_elf_finish_dynamic_symbol (bfd *output_bfd,\n \t\t\t\tstruct elf_link_hash_entry *h,\n \t\t\t\tElf_Internal_Sym *sym)\n {\n-  struct elf_m32r_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   bfd_byte *loc;\n \n #ifdef DEBUG_PIC\n@@ -2918,9 +2904,9 @@ m32r_elf_finish_dynamic_symbol (bfd *output_bfd,\n \n       BFD_ASSERT (h->dynindx != -1);\n \n-      splt = htab->root.splt;\n-      sgot = htab->root.sgotplt;\n-      srela = htab->root.srelplt;\n+      splt = htab->splt;\n+      sgot = htab->sgotplt;\n+      srela = htab->srelplt;\n       BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);\n \n       /* Get the index in the procedure linkage table which\n@@ -3014,8 +3000,8 @@ m32r_elf_finish_dynamic_symbol (bfd *output_bfd,\n       /* This symbol has an entry in the global offset table.  Set it\n \t up.  */\n \n-      sgot = htab->root.sgot;\n-      srela = htab->root.srelgot;\n+      sgot = htab->sgot;\n+      srela = htab->srelgot;\n       BFD_ASSERT (sgot != NULL && srela != NULL);\n \n       rela.r_offset = (sgot->output_section->vma\n@@ -3063,7 +3049,7 @@ m32r_elf_finish_dynamic_symbol (bfd *output_bfd,\n \t\t  && (h->root.type == bfd_link_hash_defined\n \t\t      || h->root.type == bfd_link_hash_defweak));\n \n-      s = bfd_get_linker_section (htab->root.dynobj, \".rela.bss\");\n+      s = bfd_get_linker_section (htab->dynobj, \".rela.bss\");\n       BFD_ASSERT (s != NULL);\n \n       rela.r_offset = (h->root.u.def.value\n@@ -3078,7 +3064,7 @@ m32r_elf_finish_dynamic_symbol (bfd *output_bfd,\n     }\n \n   /* Mark some specially defined symbols as absolute.  */\n-  if (h == htab->root.hdynamic || h == htab->root.hgot)\n+  if (h == htab->hdynamic || h == htab->hgot)\n     sym->st_shndx = SHN_ABS;\n \n   return TRUE;\n@@ -3091,7 +3077,7 @@ static bfd_boolean\n m32r_elf_finish_dynamic_sections (bfd *output_bfd,\n \t\t\t\t  struct bfd_link_info *info)\n {\n-  struct elf_m32r_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   bfd *dynobj;\n   asection *sdyn;\n   asection *sgot;\n@@ -3104,12 +3090,12 @@ m32r_elf_finish_dynamic_sections (bfd *output_bfd,\n   if (htab == NULL)\n     return FALSE;\n \n-  dynobj = htab->root.dynobj;\n+  dynobj = htab->dynobj;\n \n-  sgot = htab->root.sgotplt;\n+  sgot = htab->sgotplt;\n   sdyn = bfd_get_linker_section (dynobj, \".dynamic\");\n \n-  if (htab->root.dynamic_sections_created)\n+  if (htab->dynamic_sections_created)\n     {\n       asection *splt;\n       Elf32_External_Dyn *dyncon, *dynconend;\n@@ -3132,25 +3118,25 @@ m32r_elf_finish_dynamic_sections (bfd *output_bfd,\n \t      break;\n \n \t    case DT_PLTGOT:\n-\t      s = htab->root.sgotplt;\n+\t      s = htab->sgotplt;\n \t      goto get_vma;\n \t    case DT_JMPREL:\n-\t      s = htab->root.srelplt;\n+\t      s = htab->srelplt;\n \t    get_vma:\n \t      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;\n \t      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);\n \t      break;\n \n \t    case DT_PLTRELSZ:\n-\t      s = htab->root.srelplt;\n+\t      s = htab->srelplt;\n \t      dyn.d_un.d_val = s->size;\n \t      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);\n \t      break;\n \t    }\n \t}\n \n       /* Fill in the first entry in the procedure linkage table.  */\n-      splt = htab->root.splt;\n+      splt = htab->splt;\n       if (splt && splt->size > 0)\n \t{\n \t  if (bfd_link_pic (info))\n@@ -3369,7 +3355,7 @@ m32r_elf_check_relocs (bfd *abfd,\n   struct elf_link_hash_entry **sym_hashes;\n   const Elf_Internal_Rela *rel;\n   const Elf_Internal_Rela *rel_end;\n-  struct elf_m32r_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   bfd *dynobj;\n   asection *sreloc;\n \n@@ -3384,7 +3370,7 @@ m32r_elf_check_relocs (bfd *abfd,\n   if (htab == NULL)\n     return FALSE;\n \n-  dynobj = htab->root.dynobj;\n+  dynobj = htab->dynobj;\n \n   rel_end = relocs + sec->reloc_count;\n   for (rel = relocs; rel < rel_end; rel++)\n@@ -3406,7 +3392,7 @@ m32r_elf_check_relocs (bfd *abfd,\n \t}\n \n       /* Some relocs require a global offset table.  */\n-      if (htab->root.sgot == NULL)\n+      if (htab->sgot == NULL)\n \t{\n \t  switch (r_type)\n \t    {\n@@ -3423,7 +3409,7 @@ m32r_elf_check_relocs (bfd *abfd,\n \t    case R_M32R_GOTPC_LO:\n \t    case R_M32R_GOT24:\n \t      if (dynobj == NULL)\n-\t\thtab->root.dynobj = dynobj = abfd;\n+\t\thtab->dynobj = dynobj = abfd;\n \t      if (!_bfd_elf_create_got_section (dynobj, info))\n \t\treturn FALSE;\n \t      break;\n@@ -3540,7 +3526,7 @@ m32r_elf_check_relocs (bfd *abfd,\n \t      struct elf_dyn_relocs **head;\n \n \t      if (dynobj == NULL)\n-\t\thtab->root.dynobj = dynobj = abfd;\n+\t\thtab->dynobj = dynobj = abfd;\n \n \t      /* When creating a shared object, we must copy these\n \t\t relocs into the output file.  We create a reloc"
    },
    {
      "sha": "720c270a59585b4bee80a46a5fd5753b609dcb72",
      "filename": "bfd/elf32-m68hc1x.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-m68hc1x.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-m68hc1x.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68hc1x.h?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -120,9 +120,6 @@ struct m68hc11_elf_link_hash_table\n   int top_index;\n   asection **input_list;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   bfd_boolean (* size_one_stub)  (struct bfd_hash_entry*, void*);\n   bfd_boolean (* build_one_stub) (struct bfd_hash_entry*, void*);\n };"
    },
    {
      "sha": "120816f918b3927f4fb66a49096f3a0b6c9f4dca",
      "filename": "bfd/elf32-m68k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-m68k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-m68k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68k.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -889,9 +889,6 @@ struct elf_m68k_link_hash_table\n {\n   struct elf_link_hash_table root;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* The PLT format used by this link, or NULL if the format has not\n      yet been chosen.  */\n   const struct elf_m68k_plt_info *plt_info;\n@@ -2836,7 +2833,7 @@ elf_m68k_check_relocs (bfd *abfd,\n \t\t      void *vpp;\n \t\t      Elf_Internal_Sym *isym;\n \n-\t\t      isym = bfd_sym_from_r_symndx (&elf_m68k_hash_table (info)->sym_cache,\n+\t\t      isym = bfd_sym_from_r_symndx (&elf_m68k_hash_table (info)->root.sym_cache,\n \t\t\t\t\t\t    abfd, r_symndx);\n \t\t      if (isym == NULL)\n \t\t\treturn FALSE;"
    },
    {
      "sha": "f1122fd71e582ade51de38ae971d53d187378a4d",
      "filename": "bfd/elf32-metag.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-metag.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -823,9 +823,6 @@ struct elf_metag_link_hash_table\n   asection **input_list;\n   Elf_Internal_Sym **all_local_syms;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* Data for LDM relocations.  */\n   union\n   {\n@@ -2098,7 +2095,7 @@ elf_metag_check_relocs (bfd *abfd,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  isym = bfd_sym_from_r_symndx (&htab->etab.sym_cache,\n \t\t\t\t\tabfd, r_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;"
    },
    {
      "sha": "09a1e56becd9cd79ac32fc620df702926db2d69f",
      "filename": "bfd/elf32-microblaze.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-microblaze.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -744,9 +744,6 @@ struct elf32_mb_link_hash_table\n {\n   struct elf_link_hash_table elf;\n \n-  /* Small local sym to section mapping cache.  */\n-  struct sym_cache sym_sec;\n-\n   /* TLS Local Dynamic GOT Entry */\n   union {\n     bfd_signed_vma refcount;\n@@ -2523,7 +2520,7 @@ microblaze_elf_check_relocs (bfd * abfd,\n \t\t    Elf_Internal_Sym *isym;\n \t\t    void *vpp;\n \n-\t\t    isym = bfd_sym_from_r_symndx (&htab->sym_sec,\n+\t\t    isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\t  abfd, r_symndx);\n \t\t    if (isym == NULL)\n \t\t      return FALSE;"
    },
    {
      "sha": "1f9f9ba964c0e14c98e88dc52fe0e802a7ad3471",
      "filename": "bfd/elf32-nds32.c",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -3696,8 +3696,6 @@ nds32_elf_link_hash_table_create (bfd *abfd)\n       return NULL;\n     }\n \n-  ret->sdynbss = NULL;\n-  ret->srelbss = NULL;\n   ret->sym_ld_script = NULL;\n \n   return &ret->root.root;\n@@ -3833,7 +3831,7 @@ nds32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t initialize them at run time.  The linker script puts the .dynbss\n \t section into the .bss section of the final image.  */\n       s = bfd_make_section (abfd, \".dynbss\");\n-      htab->sdynbss = s;\n+      htab->root.sdynbss = s;\n       if (s == NULL\n \t  || !bfd_set_section_flags (s, SEC_ALLOC | SEC_LINKER_CREATED))\n \treturn FALSE;\n@@ -3852,7 +3850,7 @@ nds32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t{\n \t  s = bfd_make_section (abfd, (bed->default_use_rela_p\n \t\t\t\t       ? \".rela.bss\" : \".rel.bss\"));\n-\t  htab->srelbss = s;\n+\t  htab->root.srelbss = s;\n \t  if (s == NULL\n \t      || !bfd_set_section_flags (s, flags | SEC_READONLY)\n \t      || !bfd_set_section_alignment (s, ptralign))\n@@ -3988,7 +3986,7 @@ nds32_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n      same memory location for the variable.  */\n \n   htab = nds32_elf_hash_table (info);\n-  s = htab->sdynbss;\n+  s = htab->root.sdynbss;\n   BFD_ASSERT (s != NULL);\n \n   /* We must generate a R_NDS32_COPY reloc to tell the dynamic linker\n@@ -3999,7 +3997,7 @@ nds32_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n     {\n       asection *srel;\n \n-      srel = htab->srelbss;\n+      srel = htab->root.srelbss;\n       BFD_ASSERT (srel != NULL);\n       srel->size += sizeof (Elf32_External_Rela);\n       h->needs_copy = 1;\n@@ -7277,7 +7275,8 @@ nds32_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  void *vpp;\n \n \t\t  Elf_Internal_Sym *isym;\n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,\n+\t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;\n "
    },
    {
      "sha": "83547b2cffcc3569c6f2a57e2716b4b111d47e58",
      "filename": "bfd/elf32-nds32.h",
      "status": "modified",
      "additions": 0,
      "deletions": 7,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-nds32.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-nds32.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.h?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -122,13 +122,6 @@ struct elf_nds32_link_hash_table\n {\n   struct elf_link_hash_table root;\n \n-  /* Short-cuts to get to dynamic linker sections.  */\n-  asection *sdynbss;\n-  asection *srelbss;\n-\n-  /* Small local sym to section mapping cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* Target dependent options.  */\n   int relax_fp_as_gp;\t\t/* --mrelax-omit-fp.  */\n   int eliminate_gc_relocs;\t/* --meliminate-gc-relocs.  */"
    },
    {
      "sha": "84e52285d3fb574f645c3b807d7bae2c9f612da8",
      "filename": "bfd/elf32-nios2.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-nios2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-nios2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nios2.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -1808,9 +1808,6 @@ struct elf32_nios2_link_hash_table\n       bfd_vma offset;\n     } tls_ldm_got;\n \n-    /* Small local sym cache.  */\n-    struct sym_cache sym_cache;\n-\n     bfd_vma res_n_size;\n   };\n \n@@ -4902,7 +4899,7 @@ nios2_elf32_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  void *vpp;\n \t\t  Elf_Internal_Sym *isym;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;"
    },
    {
      "sha": "ef78187dced0d7706cacd915c893130999046d9e",
      "filename": "bfd/elf32-or1k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-or1k.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -916,9 +916,6 @@ struct elf_or1k_link_hash_table\n {\n   struct elf_link_hash_table root;\n \n-  /* Small local sym to section mapping cache.  */\n-  struct sym_cache sym_sec;\n-\n   bfd_boolean saw_plta;\n };\n \n@@ -2151,7 +2148,7 @@ or1k_elf_check_relocs (bfd *abfd,\n \t\t    Elf_Internal_Sym *isym;\n \t\t    void *vpp;\n \n-\t\t    isym = bfd_sym_from_r_symndx (&htab->sym_sec,\n+\t\t    isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,\n \t\t\t\t\t\t  abfd, r_symndx);\n \t\t    if (isym == NULL)\n \t\t      return FALSE;"
    },
    {
      "sha": "93b50bc334abac66d1b94544c8f863ab5aaf21af",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -2212,9 +2212,6 @@ struct ppc_elf_link_hash_table\n   int plt_slot_size;\n   /* The size of the first PLT entry.  */\n   int plt_initial_entry_size;\n-\n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n };\n \n /* Rename some of the generic section flags to better document how they\n@@ -2952,7 +2949,7 @@ ppc_elf_check_relocs (bfd *abfd,\n       ifunc = NULL;\n       if (h == NULL && htab->elf.target_os != is_vxworks)\n \t{\n-\t  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\t\t  abfd, r_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;\n@@ -3335,7 +3332,7 @@ ppc_elf_check_relocs (bfd *abfd,\n \t      asection *s;\n \t      Elf_Internal_Sym *isym;\n \n-\t      isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t    abfd, r_symndx);\n \t      if (isym == NULL)\n \t\treturn FALSE;\n@@ -3495,7 +3492,7 @@ ppc_elf_check_relocs (bfd *abfd,\n \t\t  void *vpp;\n \t\t  Elf_Internal_Sym *isym;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;"
    },
    {
      "sha": "530a10d3be657d36697fd87302d776cbbff8e33f",
      "filename": "bfd/elf32-s390.c",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-s390.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -746,9 +746,6 @@ struct elf_s390_link_hash_table\n     bfd_signed_vma refcount;\n     bfd_vma offset;\n   } tls_ldm_got;\n-\n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n };\n \n /* Get the s390 ELF linker hash table from a link_info structure.  */\n@@ -930,7 +927,7 @@ elf_s390_check_relocs (bfd *abfd,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\tabfd, r_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;\n@@ -1281,7 +1278,7 @@ elf_s390_check_relocs (bfd *abfd,\n \t\t  asection *s;\n \t\t  void *vpp;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;\n@@ -3722,7 +3719,7 @@ elf_s390_finish_dynamic_sections (bfd *output_bfd,\n \t    if (local_plt[i].plt.offset != (bfd_vma) -1)\n \t      {\n \t\tasection *sec = local_plt[i].sec;\n-\t\tisym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, i);\n+\t\tisym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, ibfd, i);\n \t\tif (isym == NULL)\n \t\t  return FALSE;\n "
    },
    {
      "sha": "481bed4c4f915cc5bdcfb096fc50e709ca702b4f",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 6,
      "deletions": 11,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -2160,18 +2160,13 @@ struct elf_sh_link_hash_table\n   struct elf_link_hash_table root;\n \n   /* Short-cuts to get to dynamic linker sections.  */\n-  asection *sdynbss;\n-  asection *srelbss;\n   asection *sfuncdesc;\n   asection *srelfuncdesc;\n   asection *srofixup;\n \n   /* The (unloaded but important) VxWorks .rela.plt.unloaded section.  */\n   asection *srelplt2;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* A counter or offset to track a TLS got entry.  */\n   union\n     {\n@@ -2439,7 +2434,7 @@ sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t section into the .bss section of the final image.  */\n       s = bfd_make_section_anyway_with_flags (abfd, \".dynbss\",\n \t\t\t\t\t      SEC_ALLOC | SEC_LINKER_CREATED);\n-      htab->sdynbss = s;\n+      htab->root.sdynbss = s;\n       if (s == NULL)\n \treturn FALSE;\n \n@@ -2460,7 +2455,7 @@ sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t  (bed->default_use_rela_p\n \t\t\t\t\t\t   ? \".rela.bss\" : \".rel.bss\"),\n \t\t\t\t\t\t  flags | SEC_READONLY);\n-\t  htab->srelbss = s;\n+\t  htab->root.srelbss = s;\n \t  if (s == NULL\n \t      || !bfd_set_section_alignment (s, ptralign))\n \t    return FALSE;\n@@ -2580,7 +2575,7 @@ sh_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n      both the dynamic object and the regular object will refer to the\n      same memory location for the variable.  */\n \n-  s = htab->sdynbss;\n+  s = htab->root.sdynbss;\n   BFD_ASSERT (s != NULL);\n \n   /* We must generate a R_SH_COPY reloc to tell the dynamic linker to\n@@ -2591,7 +2586,7 @@ sh_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n     {\n       asection *srel;\n \n-      srel = htab->srelbss;\n+      srel = htab->root.srelbss;\n       BFD_ASSERT (srel != NULL);\n       srel->size += sizeof (Elf32_External_Rela);\n       h->needs_copy = 1;\n@@ -3151,7 +3146,7 @@ sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  || s == htab->root.sgotplt\n \t  || s == htab->sfuncdesc\n \t  || s == htab->srofixup\n-\t  || s == htab->sdynbss)\n+\t  || s == htab->root.sdynbss)\n \t{\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n@@ -5679,7 +5674,7 @@ sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,\n \t\t  void *vpp;\n \t\t  Elf_Internal_Sym *isym;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;"
    },
    {
      "sha": "9984c05203341cae4a92c6d8f5008aeeb8e8be28",
      "filename": "bfd/elf32-tic6x.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tic6x.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -46,9 +46,6 @@ struct elf32_tic6x_link_hash_table\n   /* C6X specific command line arguments.  */\n   struct elf32_tic6x_params params;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* The output BFD, for convenience.  */\n   bfd *obfd;\n \n@@ -2729,7 +2726,7 @@ elf32_tic6x_check_relocs (bfd *abfd, struct bfd_link_info *info,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\tabfd, r_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;"
    },
    {
      "sha": "e062dc03866470c54a0b4b269bd9f3ac42dcf807",
      "filename": "bfd/elf32-tilepro.c",
      "status": "modified",
      "additions": 105,
      "deletions": 113,
      "changes": 218,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf32-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tilepro.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -727,19 +727,11 @@ tilepro_elf_mkobject (bfd *abfd)\n #include \"elf/common.h\"\n #include \"elf/internal.h\"\n \n-struct tilepro_elf_link_hash_table\n-{\n-  struct elf_link_hash_table elf;\n-\n-  /* Small local sym to section mapping cache.  */\n-  struct sym_cache sym_cache;\n-};\n-\n /* Get the Tilepro ELF linker hash table from a link_info structure.  */\n #define tilepro_elf_hash_table(p) \\\n   (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \\\n   == TILEPRO_ELF_DATA \\\n-  ? ((struct tilepro_elf_link_hash_table *) ((p)->hash)) : NULL)\n+  ? ((struct elf_link_hash_table *) ((p)->hash)) : NULL)\n \n static reloc_howto_type *\n tilepro_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,\n@@ -1184,22 +1176,22 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n static struct bfd_link_hash_table *\n tilepro_elf_link_hash_table_create (bfd *abfd)\n {\n-  struct tilepro_elf_link_hash_table *ret;\n-  size_t amt = sizeof (struct tilepro_elf_link_hash_table);\n+  struct elf_link_hash_table *ret;\n+  size_t amt = sizeof (struct elf_link_hash_table);\n \n-  ret = (struct tilepro_elf_link_hash_table *) bfd_zmalloc (amt);\n+  ret = (struct elf_link_hash_table *) bfd_zmalloc (amt);\n   if (ret == NULL)\n     return NULL;\n \n-  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,\n+  if (!_bfd_elf_link_hash_table_init (ret, abfd, link_hash_newfunc,\n \t\t\t\t      sizeof (struct tilepro_elf_link_hash_entry),\n \t\t\t\t      TILEPRO_ELF_DATA))\n     {\n       free (ret);\n       return NULL;\n     }\n \n-  return &ret->elf.root;\n+  return &ret->root;\n }\n \n /* Create the .got section.  */\n@@ -1402,7 +1394,7 @@ static bfd_boolean\n tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t\t  asection *sec, const Elf_Internal_Rela *relocs)\n {\n-  struct tilepro_elf_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   Elf_Internal_Shdr *symtab_hdr;\n   struct elf_link_hash_entry **sym_hashes;\n   const Elf_Internal_Rela *rel;\n@@ -1423,8 +1415,8 @@ tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \n   BFD_ASSERT (is_tilepro_elf (abfd) || num_relocs == 0);\n \n-  if (htab->elf.dynobj == NULL)\n-    htab->elf.dynobj = abfd;\n+  if (htab->dynobj == NULL)\n+    htab->dynobj = abfd;\n \n   rel_end = relocs + num_relocs;\n   for (rel = relocs; rel < rel_end; rel++)\n@@ -1569,9 +1561,9 @@ tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      }\n \t  }\n \n-\t  if (htab->elf.sgot == NULL)\n+\t  if (htab->sgot == NULL)\n \t    {\n-\t      if (!tilepro_elf_create_got_section (htab->elf.dynobj, info))\n+\t      if (!tilepro_elf_create_got_section (htab->dynobj, info))\n \t\treturn FALSE;\n \t    }\n \t  break;\n@@ -1716,7 +1708,7 @@ tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      if (sreloc == NULL)\n \t\t{\n \t\t  sreloc = _bfd_elf_make_dynamic_reloc_section\n-\t\t    (sec, htab->elf.dynobj, 2, abfd, /*rela?*/ TRUE);\n+\t\t    (sec, htab->dynobj, 2, abfd, /*rela?*/ TRUE);\n \n \t\t  if (sreloc == NULL)\n \t\t    return FALSE;\n@@ -1754,7 +1746,7 @@ tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t{\n \t\t  size_t amt = sizeof *p;\n \t\t  p = ((struct elf_dyn_relocs *)\n-\t\t       bfd_alloc (htab->elf.dynobj, amt));\n+\t\t       bfd_alloc (htab->dynobj, amt));\n \t\t  if (p == NULL)\n \t\t    return FALSE;\n \t\t  p->next = *head;\n@@ -1850,14 +1842,14 @@ static bfd_boolean\n tilepro_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t\t\t\t   struct elf_link_hash_entry *h)\n {\n-  struct tilepro_elf_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   asection *s, *srel;\n \n   htab = tilepro_elf_hash_table (info);\n   BFD_ASSERT (htab != NULL);\n \n   /* Make sure we know what is going on here.  */\n-  BFD_ASSERT (htab->elf.dynobj != NULL\n+  BFD_ASSERT (htab->dynobj != NULL\n \t      && (h->needs_plt\n \t\t  || h->is_weakalias\n \t\t  || (h->def_dynamic\n@@ -1947,13 +1939,13 @@ tilepro_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n      .rel.bss section we are going to use.  */\n   if ((h->root.u.def.section->flags & SEC_READONLY) != 0)\n     {\n-      s = htab->elf.sdynrelro;\n-      srel = htab->elf.sreldynrelro;\n+      s = htab->sdynrelro;\n+      srel = htab->sreldynrelro;\n     }\n   else\n     {\n-      s = htab->elf.sdynbss;\n-      srel = htab->elf.srelbss;\n+      s = htab->sdynbss;\n+      srel = htab->srelbss;\n     }\n   if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)\n     {\n@@ -1971,7 +1963,7 @@ static bfd_boolean\n allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n {\n   struct bfd_link_info *info;\n-  struct tilepro_elf_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -1981,7 +1973,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   htab = tilepro_elf_hash_table (info);\n   BFD_ASSERT (htab != NULL);\n \n-  if (htab->elf.dynamic_sections_created\n+  if (htab->dynamic_sections_created\n       && h->plt.refcount > 0)\n     {\n       /* Make sure this symbol is output as a dynamic symbol.\n@@ -1995,7 +1987,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n       if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h))\n \t{\n-\t  asection *s = htab->elf.splt;\n+\t  asection *s = htab->splt;\n \n \t  /* Allocate room for the header.  */\n \t  if (s->size == 0)\n@@ -2021,10 +2013,10 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t  s->size += PLT_ENTRY_SIZE;\n \n \t  /* We also need to make an entry in the .got.plt section.  */\n-\t  htab->elf.sgotplt->size += GOT_ENTRY_SIZE;\n+\t  htab->sgotplt->size += GOT_ENTRY_SIZE;\n \n \t  /* We also need to make an entry in the .rela.plt section.  */\n-\t  htab->elf.srelplt->size += TILEPRO_ELF_RELA_BYTES;\n+\t  htab->srelplt->size += TILEPRO_ELF_RELA_BYTES;\n \t}\n       else\n \t{\n@@ -2060,22 +2052,22 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    return FALSE;\n \t}\n \n-      s = htab->elf.sgot;\n+      s = htab->sgot;\n       h->got.offset = s->size;\n       s->size += TILEPRO_BYTES_PER_WORD;\n       /* R_TILEPRO_IMM16_Xn_TLS_GD entries need 2 consecutive GOT slots. */\n       if (tls_type == GOT_TLS_GD)\n \ts->size += TILEPRO_BYTES_PER_WORD;\n-      dyn = htab->elf.dynamic_sections_created;\n+      dyn = htab->dynamic_sections_created;\n       /* R_TILEPRO_IMM16_Xn_TLS_IE_xxx needs one dynamic relocation,\n \t R_TILEPRO_IMM16_Xn_TLS_GD_xxx needs two if local symbol and two if\n \t global.  */\n       if (tls_type == GOT_TLS_GD || tls_type == GOT_TLS_IE)\n-\thtab->elf.srelgot->size += 2 * TILEPRO_ELF_RELA_BYTES;\n+\thtab->srelgot->size += 2 * TILEPRO_ELF_RELA_BYTES;\n       else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,\n \t\t\t\t\t\tbfd_link_pic (info),\n \t\t\t\t\t\th))\n-\thtab->elf.srelgot->size += TILEPRO_ELF_RELA_BYTES;\n+\thtab->srelgot->size += TILEPRO_ELF_RELA_BYTES;\n     }\n   else\n     h->got.offset = (bfd_vma) -1;\n@@ -2134,7 +2126,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n       if (!h->non_got_ref\n \t  && ((h->def_dynamic\n \t       && !h->def_regular)\n-\t      || (htab->elf.dynamic_sections_created\n+\t      || (htab->dynamic_sections_created\n \t\t  && (h->root.type == bfd_link_hash_undefweak\n \t\t      || h->root.type == bfd_link_hash_undefined))))\n \t{\n@@ -2195,14 +2187,14 @@ tilepro_elf_size_dynamic_sections (bfd *output_bfd,\n {\n   (void)output_bfd;\n \n-  struct tilepro_elf_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   bfd *dynobj;\n   asection *s;\n   bfd *ibfd;\n \n   htab = tilepro_elf_hash_table (info);\n   BFD_ASSERT (htab != NULL);\n-  dynobj = htab->elf.dynobj;\n+  dynobj = htab->dynobj;\n   BFD_ASSERT (dynobj != NULL);\n \n   if (elf_hash_table (info)->dynamic_sections_created)\n@@ -2268,8 +2260,8 @@ tilepro_elf_size_dynamic_sections (bfd *output_bfd,\n       locsymcount = symtab_hdr->sh_info;\n       end_local_got = local_got + locsymcount;\n       local_tls_type = _bfd_tilepro_elf_local_got_tls_type (ibfd);\n-      s = htab->elf.sgot;\n-      srel = htab->elf.srelgot;\n+      s = htab->sgot;\n+      srel = htab->srelgot;\n       for (; local_got < end_local_got; ++local_got, ++local_tls_type)\n \t{\n \t  if (*local_got > 0)\n@@ -2290,19 +2282,19 @@ tilepro_elf_size_dynamic_sections (bfd *output_bfd,\n \n   /* Allocate global sym .plt and .got entries, and space for global\n      sym dynamic relocs.  */\n-  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);\n+  elf_link_hash_traverse (htab, allocate_dynrelocs, info);\n \n   if (elf_hash_table (info)->dynamic_sections_created)\n     {\n       /* If the .got section is more than 0x8000 bytes, we add\n \t 0x8000 to the value of _GLOBAL_OFFSET_TABLE_, so that 16\n \t bit relocations have a greater chance of working. */\n-      if (htab->elf.sgot->size >= 0x8000\n+      if (htab->sgot->size >= 0x8000\n \t  && elf_hash_table (info)->hgot->root.u.def.value == 0)\n \telf_hash_table (info)->hgot->root.u.def.value = 0x8000;\n     }\n \n-  if (htab->elf.sgotplt)\n+  if (htab->sgotplt)\n     {\n       struct elf_link_hash_entry *got;\n       got = elf_link_hash_lookup (elf_hash_table (info),\n@@ -2313,14 +2305,14 @@ tilepro_elf_size_dynamic_sections (bfd *output_bfd,\n \t entries and there is no refeence to _GLOBAL_OFFSET_TABLE_.  */\n       if ((got == NULL\n \t   || !got->ref_regular_nonweak)\n-\t  && (htab->elf.sgotplt->size\n+\t  && (htab->sgotplt->size\n \t      == GOTPLT_HEADER_SIZE)\n-\t  && (htab->elf.splt == NULL\n-\t      || htab->elf.splt->size == 0)\n-\t  && (htab->elf.sgot == NULL\n-\t      || (htab->elf.sgot->size\n+\t  && (htab->splt == NULL\n+\t      || htab->splt->size == 0)\n+\t  && (htab->sgot == NULL\n+\t      || (htab->sgot->size\n \t\t  == get_elf_backend_data (output_bfd)->got_header_size)))\n-\thtab->elf.sgotplt->size = 0;\n+\thtab->sgotplt->size = 0;\n     }\n \n   /* The check_relocs and adjust_dynamic_symbol entry points have\n@@ -2331,11 +2323,11 @@ tilepro_elf_size_dynamic_sections (bfd *output_bfd,\n       if ((s->flags & SEC_LINKER_CREATED) == 0)\n \tcontinue;\n \n-      if (s == htab->elf.splt\n-\t  || s == htab->elf.sgot\n-\t  || s == htab->elf.sgotplt\n-\t  || s == htab->elf.sdynbss\n-\t  || s == htab->elf.sdynrelro)\n+      if (s == htab->splt\n+\t  || s == htab->sgot\n+\t  || s == htab->sgotplt\n+\t  || s == htab->sdynbss\n+\t  || s == htab->sdynrelro)\n \t{\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n@@ -2527,7 +2519,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t\t      Elf_Internal_Sym *local_syms,\n \t\t\t      asection **local_sections)\n {\n-  struct tilepro_elf_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n   Elf_Internal_Shdr *symtab_hdr;\n   struct elf_link_hash_entry **sym_hashes;\n   bfd_vma *local_got_offsets;\n@@ -2758,7 +2750,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \tcase R_TILEPRO_IMM16_X1_GOT_HA:\n \t  /* Relocation is to the entry for this symbol in the global\n \t     offset table.  */\n-\t  if (htab->elf.sgot == NULL)\n+\t  if (htab->sgot == NULL)\n \t    abort ();\n \n \t  if (h != NULL)\n@@ -2792,7 +2784,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t  else\n \t\t    {\n \t\t      bfd_put_32 (output_bfd, relocation,\n-\t\t\t\t\t  htab->elf.sgot->contents + off);\n+\t\t\t\t\t  htab->sgot->contents + off);\n \t\t      h->got.offset |= 1;\n \t\t    }\n \t\t}\n@@ -2820,11 +2812,11 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \n \t\t      /* We need to generate a R_TILEPRO_RELATIVE reloc\n \t\t\t for the dynamic linker.  */\n-\t\t      s = htab->elf.srelgot;\n+\t\t      s = htab->srelgot;\n \t\t      BFD_ASSERT (s != NULL);\n \n-\t\t      outrel.r_offset = (htab->elf.sgot->output_section->vma\n-\t\t\t\t\t + htab->elf.sgot->output_offset\n+\t\t      outrel.r_offset = (htab->sgot->output_section->vma\n+\t\t\t\t\t + htab->sgot->output_offset\n \t\t\t\t\t + off);\n \t\t      outrel.r_info = ELF32_R_INFO (0, R_TILEPRO_RELATIVE);\n \t\t      outrel.r_addend = relocation;\n@@ -2833,7 +2825,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t    }\n \n \t\t  bfd_put_32 (output_bfd, relocation,\n-\t\t\t\t      htab->elf.sgot->contents + off);\n+\t\t\t\t      htab->sgot->contents + off);\n \t\t  local_got_offsets[r_symndx] |= 1;\n \t\t}\n \t    }\n@@ -2845,16 +2837,16 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t     procedure linkage table.  */\n \t  BFD_ASSERT (h != NULL);\n \n-\t  if (h->plt.offset == (bfd_vma) -1 || htab->elf.splt == NULL)\n+\t  if (h->plt.offset == (bfd_vma) -1 || htab->splt == NULL)\n \t    {\n \t      /* We didn't make a PLT entry for this symbol.  This\n \t\t happens when statically linking PIC code, or when\n \t\t using -Bsymbolic.  */\n \t      break;\n \t    }\n \n-\t  relocation = (htab->elf.splt->output_section->vma\n-\t\t\t+ htab->elf.splt->output_offset\n+\t  relocation = (htab->splt->output_section->vma\n+\t\t\t+ htab->splt->output_offset\n \t\t\t+ h->plt.offset);\n \t  unresolved_reloc = FALSE;\n \t  break;\n@@ -2993,7 +2985,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t      outrel.r_addend = relocation + rel->r_addend;\n \n \t\t      if (is_plt)\n-\t\t\tsec = htab->elf.splt;\n+\t\t\tsec = htab->splt;\n \n \t\t      if (bfd_is_abs_section (sec))\n \t\t\tindx = 0;\n@@ -3016,7 +3008,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \n \t\t\t  if (indx == 0)\n \t\t\t    {\n-\t\t\t      osec = htab->elf.text_index_section;\n+\t\t\t      osec = htab->text_index_section;\n \t\t\t      indx = elf_section_data (osec)->dynindx;\n \t\t\t    }\n \n@@ -3142,7 +3134,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t      local_got_offsets[r_symndx] |= 1;\n \t    }\n \n-\t  if (htab->elf.sgot == NULL)\n+\t  if (htab->sgot == NULL)\n \t    abort ();\n \n \t  if ((off & 1) != 0)\n@@ -3153,13 +3145,13 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t      int indx = 0;\n \t      bfd_boolean need_relocs = FALSE;\n \n-\t      if (htab->elf.srelgot == NULL)\n+\t      if (htab->srelgot == NULL)\n \t\tabort ();\n \n \t      if (h != NULL)\n \t      {\n \t\tbfd_boolean dyn;\n-\t\tdyn = htab->elf.dynamic_sections_created;\n+\t\tdyn = htab->dynamic_sections_created;\n \n \t\tif (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,\n \t\t\t\t\t\t     bfd_link_pic (info),\n@@ -3190,18 +3182,18 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t  case R_TILEPRO_IMM16_X0_TLS_IE_HA:\n \t\t  case R_TILEPRO_IMM16_X1_TLS_IE_HA:\n \t\t    if (need_relocs) {\n-\t\t      bfd_put_32 (output_bfd, 0, htab->elf.sgot->contents + off);\n-\t\t      outrel.r_offset = (htab->elf.sgot->output_section->vma\n-\t\t\t\t       + htab->elf.sgot->output_offset + off);\n+\t\t      bfd_put_32 (output_bfd, 0, htab->sgot->contents + off);\n+\t\t      outrel.r_offset = (htab->sgot->output_section->vma\n+\t\t\t\t       + htab->sgot->output_offset + off);\n \t\t      outrel.r_addend = 0;\n \t\t      if (indx == 0)\n \t\t\toutrel.r_addend = relocation - dtpoff_base (info);\n \t\t      outrel.r_info = ELF32_R_INFO (indx, R_TILEPRO_TLS_TPOFF32);\n-\t\t      tilepro_elf_append_rela_32 (output_bfd, htab->elf.srelgot,\n+\t\t      tilepro_elf_append_rela_32 (output_bfd, htab->srelgot,\n \t\t\t\t\t\t  &outrel);\n \t\t    } else {\n \t\t      bfd_put_32 (output_bfd, tpoff (info, relocation),\n-\t\t\t\t  htab->elf.sgot->contents + off);\n+\t\t\t\t  htab->sgot->contents + off);\n \t\t    }\n \t\t    break;\n \n@@ -3214,31 +3206,31 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t  case R_TILEPRO_IMM16_X0_TLS_GD_HA:\n \t\t  case R_TILEPRO_IMM16_X1_TLS_GD_HA:\n \t\t    if (need_relocs) {\n-\t\t      outrel.r_offset = (htab->elf.sgot->output_section->vma\n-\t\t\t\t       + htab->elf.sgot->output_offset + off);\n+\t\t      outrel.r_offset = (htab->sgot->output_section->vma\n+\t\t\t\t       + htab->sgot->output_offset + off);\n \t\t      outrel.r_addend = 0;\n \t\t      outrel.r_info = ELF32_R_INFO (indx, R_TILEPRO_TLS_DTPMOD32);\n-\t\t      bfd_put_32 (output_bfd, 0, htab->elf.sgot->contents + off);\n-\t\t      tilepro_elf_append_rela_32 (output_bfd, htab->elf.srelgot,\n+\t\t      bfd_put_32 (output_bfd, 0, htab->sgot->contents + off);\n+\t\t      tilepro_elf_append_rela_32 (output_bfd, htab->srelgot,\n \t\t\t\t\t\t  &outrel);\n \t\t      if (indx == 0)\n \t\t\t{\n \t\t\t  BFD_ASSERT (! unresolved_reloc);\n \t\t\t  bfd_put_32 (output_bfd,\n \t\t\t\t      relocation - dtpoff_base (info),\n-\t\t\t\t      (htab->elf.sgot->contents + off +\n+\t\t\t\t      (htab->sgot->contents + off +\n \t\t\t\t       TILEPRO_BYTES_PER_WORD));\n \t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  bfd_put_32 (output_bfd, 0,\n-\t\t\t\t      (htab->elf.sgot->contents + off +\n+\t\t\t\t      (htab->sgot->contents + off +\n \t\t\t\t       TILEPRO_BYTES_PER_WORD));\n \t\t\t  outrel.r_info = ELF32_R_INFO (indx,\n \t\t\t\t\t\t\tR_TILEPRO_TLS_DTPOFF32);\n \t\t\t  outrel.r_offset += TILEPRO_BYTES_PER_WORD;\n \t\t\t  tilepro_elf_append_rela_32 (output_bfd,\n-\t\t\t\t\t\t      htab->elf.srelgot, &outrel);\n+\t\t\t\t\t\t      htab->srelgot, &outrel);\n \t\t\t}\n \t\t    }\n \n@@ -3249,9 +3241,9 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t\t symbol binding locally.  Mark it as belonging\n \t\t\t to module 1, the executable.  */\n \t\t      bfd_put_32 (output_bfd, 1,\n-\t\t\t\t  htab->elf.sgot->contents + off );\n+\t\t\t\t  htab->sgot->contents + off );\n \t\t      bfd_put_32 (output_bfd, relocation - dtpoff_base (info),\n-\t\t\t\t  htab->elf.sgot->contents + off +\n+\t\t\t\t  htab->sgot->contents + off +\n \t\t\t\t  TILEPRO_BYTES_PER_WORD);\n \t\t   }\n \t\t   break;\n@@ -3411,7 +3403,7 @@ tilepro_elf_finish_dynamic_symbol (bfd *output_bfd,\n \t\t\t\t   struct elf_link_hash_entry *h,\n \t\t\t\t   Elf_Internal_Sym *sym)\n {\n-  struct tilepro_elf_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n \n   htab = tilepro_elf_hash_table (info);\n   BFD_ASSERT (htab != NULL);\n@@ -3431,9 +3423,9 @@ tilepro_elf_finish_dynamic_symbol (bfd *output_bfd,\n \n       BFD_ASSERT (h->dynindx != -1);\n \n-      splt = htab->elf.splt;\n-      srela = htab->elf.srelplt;\n-      sgotplt = htab->elf.sgotplt;\n+      splt = htab->splt;\n+      srela = htab->srelplt;\n+      sgotplt = htab->sgotplt;\n \n       if (splt == NULL || srela == NULL)\n        abort ();\n@@ -3481,8 +3473,8 @@ tilepro_elf_finish_dynamic_symbol (bfd *output_bfd,\n \n       /* This symbol has an entry in the GOT.  Set it up.  */\n \n-      sgot = htab->elf.sgot;\n-      srela = htab->elf.srelgot;\n+      sgot = htab->sgot;\n+      srela = htab->srelgot;\n       BFD_ASSERT (sgot != NULL && srela != NULL);\n \n       rela.r_offset = (sgot->output_section->vma\n@@ -3528,16 +3520,16 @@ tilepro_elf_finish_dynamic_symbol (bfd *output_bfd,\n \t\t       + h->root.u.def.section->output_offset);\n       rela.r_info = ELF32_R_INFO (h->dynindx, R_TILEPRO_COPY);\n       rela.r_addend = 0;\n-      if (h->root.u.def.section == htab->elf.sdynrelro)\n-\ts = htab->elf.sreldynrelro;\n+      if (h->root.u.def.section == htab->sdynrelro)\n+\ts = htab->sreldynrelro;\n       else\n-\ts = htab->elf.srelbss;\n+\ts = htab->srelbss;\n       tilepro_elf_append_rela_32 (output_bfd, s, &rela);\n     }\n \n   /* Mark some specially defined symbols as absolute. */\n-  if (h == htab->elf.hdynamic\n-      || (h == htab->elf.hgot || h == htab->elf.hplt))\n+  if (h == htab->hdynamic\n+      || (h == htab->hgot || h == htab->hplt))\n     sym->st_shndx = SHN_ABS;\n \n   return TRUE;\n@@ -3551,7 +3543,7 @@ tilepro_finish_dyn (bfd *output_bfd, struct bfd_link_info *info,\n \t\t    asection *splt ATTRIBUTE_UNUSED)\n {\n   Elf32_External_Dyn *dyncon, *dynconend;\n-  struct tilepro_elf_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n \n   htab = tilepro_elf_hash_table (info);\n   BFD_ASSERT (htab != NULL);\n@@ -3567,15 +3559,15 @@ tilepro_finish_dyn (bfd *output_bfd, struct bfd_link_info *info,\n       switch (dyn.d_tag)\n \t{\n \tcase DT_PLTGOT:\n-\t  s = htab->elf.sgotplt;\n+\t  s = htab->sgotplt;\n \t  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;\n \t  break;\n \tcase DT_JMPREL:\n-\t  s = htab->elf.srelplt;\n+\t  s = htab->srelplt;\n \t  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;\n \t  break;\n \tcase DT_PLTRELSZ:\n-\t  s = htab->elf.srelplt;\n+\t  s = htab->srelplt;\n \t  dyn.d_un.d_val = s->size;\n \t  break;\n \tdefault:\n@@ -3593,11 +3585,11 @@ tilepro_elf_finish_dynamic_sections (bfd *output_bfd,\n {\n   bfd *dynobj;\n   asection *sdyn;\n-  struct tilepro_elf_link_hash_table *htab;\n+  struct elf_link_hash_table *htab;\n \n   htab = tilepro_elf_hash_table (info);\n   BFD_ASSERT (htab != NULL);\n-  dynobj = htab->elf.dynobj;\n+  dynobj = htab->dynobj;\n \n   sdyn = bfd_get_linker_section (dynobj, \".dynamic\");\n \n@@ -3606,7 +3598,7 @@ tilepro_elf_finish_dynamic_sections (bfd *output_bfd,\n       asection *splt;\n       bfd_boolean ret;\n \n-      splt = htab->elf.splt;\n+      splt = htab->splt;\n       BFD_ASSERT (splt != NULL && sdyn != NULL);\n \n       ret = tilepro_finish_dyn (output_bfd, info, dynobj, sdyn, splt);\n@@ -3627,42 +3619,42 @@ tilepro_elf_finish_dynamic_sections (bfd *output_bfd,\n \t  = PLT_ENTRY_SIZE;\n     }\n \n-  if (htab->elf.sgotplt)\n+  if (htab->sgotplt)\n     {\n-      if (bfd_is_abs_section (htab->elf.sgotplt->output_section))\n+      if (bfd_is_abs_section (htab->sgotplt->output_section))\n \t{\n \t  _bfd_error_handler\n-\t    (_(\"discarded output section: `%pA'\"), htab->elf.sgotplt);\n+\t    (_(\"discarded output section: `%pA'\"), htab->sgotplt);\n \t  return FALSE;\n \t}\n \n-      if (htab->elf.sgotplt->size > 0)\n+      if (htab->sgotplt->size > 0)\n \t{\n \t  /* Write the first two entries in .got.plt, needed for the dynamic\n \t     linker.  */\n \t  bfd_put_32 (output_bfd, (bfd_vma) -1,\n-\t\t      htab->elf.sgotplt->contents);\n+\t\t      htab->sgotplt->contents);\n \t  bfd_put_32 (output_bfd, (bfd_vma) 0,\n-\t\t      htab->elf.sgotplt->contents + GOT_ENTRY_SIZE);\n+\t\t      htab->sgotplt->contents + GOT_ENTRY_SIZE);\n \t}\n \n-      elf_section_data (htab->elf.sgotplt->output_section)->this_hdr.sh_entsize\n+      elf_section_data (htab->sgotplt->output_section)->this_hdr.sh_entsize\n \t= GOT_ENTRY_SIZE;\n     }\n \n-  if (htab->elf.sgot)\n+  if (htab->sgot)\n     {\n-      if (htab->elf.sgot->size > 0)\n+      if (htab->sgot->size > 0)\n \t{\n \t  /* Set the first entry in the global offset table to the address of\n \t     the dynamic section.  */\n \t  bfd_vma val = (sdyn ?\n \t\t\t sdyn->output_section->vma + sdyn->output_offset :\n \t\t\t 0);\n-\t  bfd_put_32 (output_bfd, val, htab->elf.sgot->contents);\n+\t  bfd_put_32 (output_bfd, val, htab->sgot->contents);\n \t}\n \n-      elf_section_data (htab->elf.sgot->output_section)->this_hdr.sh_entsize\n+      elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize\n \t= GOT_ENTRY_SIZE;\n     }\n "
    },
    {
      "sha": "4a75c25190e0f8c7ab01b1a183e4b83527d3b1ab",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -3250,9 +3250,6 @@ struct ppc_link_hash_table\n \n   /* Incremented every time we size stubs.  */\n   unsigned int stub_iteration;\n-\n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n };\n \n /* Rename some of the generic section flags to better document how they\n@@ -4383,7 +4380,8 @@ ppc64_elf_before_check_relocs (bfd *ibfd, struct bfd_link_info *info)\n \t      Elf_Internal_Sym *isym;\n \t      asection *s;\n \n-\t      isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, r_symndx);\n+\t      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, ibfd,\n+\t\t\t\t\t    r_symndx);\n \t      if (isym == NULL)\n \t\t{\n \t\t  if (elf_section_data (opd)->relocs != relocs)\n@@ -4684,7 +4682,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t}\n       else\n \t{\n-\t  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\t\t  abfd, r_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;\n@@ -4955,7 +4953,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      {\n \t\tElf_Internal_Sym *isym;\n \n-\t\tisym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\tisym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t      abfd, r_symndx);\n \t\tif (isym == NULL)\n \t\t  return FALSE;\n@@ -5231,7 +5229,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  void *vpp;\n \t\t  Elf_Internal_Sym *isym;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;"
    },
    {
      "sha": "c8c691e4b18be833330ccd4a0af9a75ec1612fe0",
      "filename": "bfd/elf64-s390.c",
      "status": "modified",
      "additions": 4,
      "deletions": 7,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf64-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf64-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-s390.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -663,9 +663,6 @@ struct elf_s390_link_hash_table\n     bfd_vma offset;\n   } tls_ldm_got;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* Options passed from the linker.  */\n   struct s390_elf_params *params;\n };\n@@ -852,7 +849,7 @@ elf_s390_check_relocs (bfd *abfd,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\tabfd, r_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;\n@@ -1216,7 +1213,7 @@ elf_s390_check_relocs (bfd *abfd,\n \t\t  asection *s;\n \t\t  void *vpp;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;\n@@ -2258,7 +2255,7 @@ elf_s390_relocate_section (bfd *output_bfd,\n \t\t\t\t  & 0xff00f000) == 0xe300c000\n \t\t\t      && bfd_get_8 (input_bfd,\n \t\t\t\t\t    contents + rel->r_offset + 3) == 0x04))\n-\t\t      && (isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t      && (isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\t\tinput_bfd, r_symndx))\n \t\t      && isym->st_shndx != SHN_ABS\n \t\t      && h != htab->elf.hdynamic\n@@ -3572,7 +3569,7 @@ elf_s390_finish_dynamic_sections (bfd *output_bfd,\n \t    if (local_plt[i].plt.offset != (bfd_vma) -1)\n \t      {\n \t\tasection *sec = local_plt[i].sec;\n-\t\tisym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, i);\n+\t\tisym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, ibfd, i);\n \t\tif (isym == NULL)\n \t\t  return FALSE;\n "
    },
    {
      "sha": "f97a6a05e87777792ad4ab8256f574d3546e23ff",
      "filename": "bfd/elf64-x86-64.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf64-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elf64-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-x86-64.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -1371,7 +1371,7 @@ elf_x86_64_tls_transition (struct bfd_link_info *info, bfd *abfd,\n \t    {\n \t      Elf_Internal_Sym *isym;\n \n-\t      isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t    abfd, r_symndx);\n \t      name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);\n \t    }\n@@ -1559,7 +1559,7 @@ elf_x86_64_convert_load_reloc (bfd *abfd,\n   if (h == NULL)\n     {\n       Elf_Internal_Sym *isym\n-\t= bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);\n+\t= bfd_sym_from_r_symndx (&htab->elf.sym_cache, abfd, r_symndx);\n \n       /* Skip relocation against undefined symbols.  */\n       if (isym->st_shndx == SHN_UNDEF)\n@@ -1907,7 +1907,7 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\tabfd, r_symndx);\n \t  if (isym == NULL)\n \t    goto error_return;\n@@ -2308,7 +2308,7 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  asection *s;\n \t\t  void **vpp;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    goto error_return;"
    },
    {
      "sha": "2c88f288c3ac3b4f857fb4c8e07dde68b23e042b",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -2643,9 +2643,6 @@ struct elf_aarch64_link_hash_table\n   /* The bytes of the subsequent PLT entry.  */\n   const bfd_byte *plt_entry;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* For convenience in allocate_dynrelocs.  */\n   bfd *obfd;\n \n@@ -7610,7 +7607,7 @@ elfNN_aarch64_check_relocs (bfd *abfd, struct bfd_link_info *info,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t  isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,\n \t\t\t\t\tabfd, r_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;\n@@ -7837,7 +7834,7 @@ elfNN_aarch64_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\tasection *s;\n \t\tvoid **vpp;\n \n-\t\tisym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\tisym = bfd_sym_from_r_symndx (&htab->root.sym_cache,\n \t\t\t\t\t      abfd, r_symndx);\n \t\tif (isym == NULL)\n \t\t  return FALSE;"
    },
    {
      "sha": "fb78c241770cf8a1944624835f800a9df6bf32c5",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -113,9 +113,6 @@ struct riscv_elf_link_hash_table\n   /* Short-cuts to get to dynamic linker sections.  */\n   asection *sdyntdata;\n \n-  /* Small local sym to section mapping cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* The max alignment of output sections.  */\n   bfd_vma max_alignment;\n };\n@@ -681,7 +678,7 @@ riscv_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  void *vpp;\n \t\t  Elf_Internal_Sym *isym;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;"
    },
    {
      "sha": "7cfce13cdb48ea3875c0e0b7bbbe54fc7e31ea9b",
      "filename": "bfd/elfxx-mips.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-mips.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -527,9 +527,6 @@ struct mips_elf_link_hash_table\n      returns null.  */\n   asection *(*add_stub_section) (const char *, asection *, asection *);\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* Is the PLT header compressed?  */\n   unsigned int plt_header_is_comp : 1;\n };\n@@ -4401,7 +4398,7 @@ mips_elf_resolve_got_page_ref (void **refp, void *data)\n       Elf_Internal_Sym *isym;\n \n       /* Read in the symbol.  */\n-      isym = bfd_sym_from_r_symndx (&htab->sym_cache, ref->u.abfd,\n+      isym = bfd_sym_from_r_symndx (&htab->root.sym_cache, ref->u.abfd,\n \t\t\t\t    ref->symndx);\n       if (isym == NULL)\n \t{"
    },
    {
      "sha": "273789e5f7dd9e975a784a53fe8eb1d98240bbf5",
      "filename": "bfd/elfxx-sparc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -1391,7 +1391,8 @@ _bfd_sparc_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n       if (r_symndx < symtab_hdr->sh_info)\n \t{\n \t  /* A local symbol.  */\n-\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);\n+\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, abfd,\n+\t\t\t\t\tr_symndx);\n \t  if (isym == NULL)\n \t    return FALSE;\n "
    },
    {
      "sha": "f09b0732591cb71720d7eac4b917342ad0615ca6",
      "filename": "bfd/elfxx-sparc.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-sparc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-sparc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.h?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -55,9 +55,6 @@ struct _bfd_sparc_elf_link_hash_table\n     bfd_vma offset;\n   } tls_ldm_got;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* Used by local STT_GNU_IFUNC symbols.  */\n   htab_t loc_hash_table;\n   void *loc_hash_memory;"
    },
    {
      "sha": "2631a0d35081197b3fe7eaa41a8d117a081f3baf",
      "filename": "bfd/elfxx-tilegx.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-tilegx.c?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -835,9 +835,6 @@ struct tilegx_elf_link_hash_table\n   /* Whether LE transition has been disabled for some of the\n      sections.  */\n   bfd_boolean disable_le_transition;\n-\n-  /* Small local sym to section mapping cache.  */\n-  struct sym_cache sym_cache;\n };\n \n \n@@ -1979,7 +1976,7 @@ tilegx_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  void *vpp;\n \t\t  Elf_Internal_Sym *isym;\n \n-\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n+\t\t  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,\n \t\t\t\t\t\tabfd, r_symndx);\n \t\t  if (isym == NULL)\n \t\t    return FALSE;"
    },
    {
      "sha": "75e0ae3eecb7be3da199b4581261e55bd71ad193",
      "filename": "bfd/elfxx-x86.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-x86.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f1dfbfdbc6c07a8ee4ea185a2f15615600857531/bfd/elfxx-x86.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.h?ref=f1dfbfdbc6c07a8ee4ea185a2f15615600857531",
      "patch": "@@ -468,9 +468,6 @@ struct elf_x86_link_hash_table\n   /* The amount of space used by the jump slots in the GOT.  */\n   bfd_vma sgotplt_jump_table_size;\n \n-  /* Small local sym cache.  */\n-  struct sym_cache sym_cache;\n-\n   /* _TLS_MODULE_BASE_ symbol.  */\n   struct bfd_link_hash_entry *tls_module_base;\n "
    }
  ]
}