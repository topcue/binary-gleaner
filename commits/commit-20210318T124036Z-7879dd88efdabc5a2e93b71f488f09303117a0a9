{
  "sha": "7879dd88efdabc5a2e93b71f488f09303117a0a9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Nzg3OWRkODhlZmRhYmM1YTJlOTNiNzFmNDg4ZjA5MzAzMTE3YTBhOQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:37:52Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:40:36Z"
    },
    "message": "libctf: eliminate dtd_u, part 1: int/float/slice\n\nThis series eliminates a lot of special-case code to handle dynamic\ntypes (types added to writable dicts and not yet serialized).\n\nHistorically, when such types have variable-length data in their final\nCTF representations, libctf has always worked by adding such types to a\nspecial union (ctf_dtdef_t.dtd_u) in the dynamic type definition\nstructure, then picking the members out of this structure at\nserialization time and packing them into their final form.\n\nThis has the advantage that the ctf_add_* code doesn't need to know\nanything about the final CTF representation, but the significant\ndisadvantage that all code that looks up types in any way needs two code\npaths, one for dynamic types, one for all others.  Historically libctf\n\"handled\" this by not supporting most type lookups on dynamic types at\nall until ctf_update was called to do a complete reserialization of the\nentire dict (it didn't emit an error, it just emitted wrong results).\nSince commit 676c3ecbad6e9c4, which eliminated ctf_update in favour of\nthe internal-only ctf_serialize function, all the type-lookup paths\ngrew an extra branch to handle dynamic types.\n\nWe can eliminate this branch again by dropping the dtd_u stuff and\nsimply writing out the vlen in (close to) its final form at ctf_add_*\ntime: type lookup for types using this approach is then identical for\ntypes in writable dicts and types that are in read-only ones, and\nserialization is also simplified (we just need to write out the vlen\nwe already created).\n\nThe only complexity lies in type kinds for which multiple\nvlen representations are valid depending on properties of the type,\ne.g. structures.  But we can start simple, adjusting ints, floats,\nand slices to work this way, and leaving everything else as is.\n\nlibctf/ChangeLog\n2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h (ctf_dtdef_t) <dtd_u.dtu_enc>: Remove.\n\t<dtd_u.dtu_slice>: Likewise.\n\t<dtd_vlen>: New.\n\t* ctf-create.c (ctf_add_generic): Perhaps allocate it.  All\n\tcallers adjusted.\n\t(ctf_dtd_delete): Free it.\n\t(ctf_add_slice): Use the dtd_vlen, not dtu_enc.\n\t(ctf_add_encoded): Likewise.  Assert that this must be an int or\n\tfloat.\n\t* ctf-serialize.c (ctf_emit_type_sect): Just copy the dtd_vlen.\n\t* ctf-dedup.c (ctf_dedup_rhash_type): Use the dtd_vlen, not\n\tdtu_slice.\n\t* ctf-types.c (ctf_type_reference): Likewise.\n\t(ctf_type_encoding): Remove most dynamic-type-specific code: just\n\tget the vlen from the right place.  Report failure to look up the\n\tunderlying type's encoding.",
    "tree": {
      "sha": "a120f390349fe8cd5e8cdbe74e3f54fc625b737b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a120f390349fe8cd5e8cdbe74e3f54fc625b737b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7879dd88efdabc5a2e93b71f488f09303117a0a9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7879dd88efdabc5a2e93b71f488f09303117a0a9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7879dd88efdabc5a2e93b71f488f09303117a0a9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7879dd88efdabc5a2e93b71f488f09303117a0a9/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "eefe721eadf78a5f68c38ea9ca0272c7be06e0c0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/eefe721eadf78a5f68c38ea9ca0272c7be06e0c0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/eefe721eadf78a5f68c38ea9ca0272c7be06e0c0"
    }
  ],
  "stats": {
    "total": 170,
    "additions": 92,
    "deletions": 78
  },
  "files": [
    {
      "sha": "bf138399a393d6cc118fde3d424b95cc20b2a8e7",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=7879dd88efdabc5a2e93b71f488f09303117a0a9",
      "patch": "@@ -1,3 +1,22 @@\n+2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_dtdef_t) <dtd_u.dtu_enc>: Remove.\n+\t<dtd_u.dtu_slice>: Likewise.\n+\t<dtd_vlen>: New.\n+\t* ctf-create.c (ctf_add_generic): Perhaps allocate it.  All\n+\tcallers adjusted.\n+\t(ctf_dtd_delete): Free it.\n+\t(ctf_add_slice): Use the dtd_vlen, not dtu_enc.\n+\t(ctf_add_encoded): Likewise.  Assert that this must be an int or\n+\tfloat.\n+\t* ctf-serialize.c (ctf_emit_type_sect): Just copy the dtd_vlen.\n+\t* ctf-dedup.c (ctf_dedup_rhash_type): Use the dtd_vlen, not\n+\tdtu_slice.\n+\t* ctf-types.c (ctf_type_reference): Likewise.\n+\t(ctf_type_encoding): Remove most dynamic-type-specific code: just\n+\tget the vlen from the right place.  Report failure to look up the\n+\tunderlying type's encoding.\n+\n 2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-archive.c (ctf_archive_next): GNU style fix for do {} while."
    },
    {
      "sha": "90db7121af6bfd4545a7bce9fc656f7144fa1d6a",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 57,
      "deletions": 27,
      "changes": 84,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=7879dd88efdabc5a2e93b71f488f09303117a0a9",
      "patch": "@@ -226,6 +226,7 @@ ctf_dtd_delete (ctf_dict_t *fp, ctf_dtdef_t *dtd)\n   const char *name;\n \n   ctf_dynhash_remove (fp->ctf_dthash, (void *) (uintptr_t) dtd->dtd_type);\n+  free (dtd->dtd_vlen);\n \n   switch (kind)\n     {\n@@ -406,7 +407,7 @@ ctf_rollback (ctf_dict_t *fp, ctf_snapshot_id_t id)\n \n static ctf_id_t\n ctf_add_generic (ctf_dict_t *fp, uint32_t flag, const char *name, int kind,\n-\t\t ctf_dtdef_t **rp)\n+\t\t size_t vlen, ctf_dtdef_t **rp)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type;\n@@ -425,33 +426,42 @@ ctf_add_generic (ctf_dict_t *fp, uint32_t flag, const char *name, int kind,\n \n   /* Make sure ptrtab always grows to be big enough for all types.  */\n   if (ctf_grow_ptrtab (fp) < 0)\n-      return CTF_ERR;\t\t/* errno is set for us. */\n+      return CTF_ERR;\t\t\t\t/* errno is set for us. */\n \n-  if ((dtd = malloc (sizeof (ctf_dtdef_t))) == NULL)\n+  if ((dtd = calloc (1, sizeof (ctf_dtdef_t))) == NULL)\n     return (ctf_set_errno (fp, EAGAIN));\n \n+  if (vlen > 0)\n+    {\n+      if ((dtd->dtd_vlen = calloc (1, vlen)) == NULL)\n+\tgoto oom;\n+    }\n+  else\n+    dtd->dtd_vlen = NULL;\n+\n   type = ++fp->ctf_typemax;\n   type = LCTF_INDEX_TO_TYPE (fp, type, (fp->ctf_flags & LCTF_CHILD));\n \n-  memset (dtd, 0, sizeof (ctf_dtdef_t));\n   dtd->dtd_data.ctt_name = ctf_str_add_ref (fp, name, &dtd->dtd_data.ctt_name);\n   dtd->dtd_type = type;\n \n   if (dtd->dtd_data.ctt_name == 0 && name != NULL && name[0] != '\\0')\n-    {\n-      free (dtd);\n-      return (ctf_set_errno (fp, EAGAIN));\n-    }\n+    goto oom;\n \n   if (ctf_dtd_insert (fp, dtd, flag, kind) < 0)\n-    {\n-      free (dtd);\n-      return CTF_ERR;\t\t\t/* errno is set for us.  */\n-    }\n+    goto err;\t\t\t\t\t/* errno is set for us.  */\n+\n   fp->ctf_flags |= LCTF_DIRTY;\n \n   *rp = dtd;\n   return type;\n+\n+ oom:\n+  ctf_set_errno (fp, EAGAIN);\n+ err:\n+  free (dtd->dtd_vlen);\n+  free (dtd);\n+  return CTF_ERR;\n }\n \n /* When encoding integer sizes, we want to convert a byte count in the range\n@@ -477,20 +487,34 @@ ctf_add_encoded (ctf_dict_t *fp, uint32_t flag,\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type;\n+  uint32_t encoding;\n \n   if (ep == NULL)\n     return (ctf_set_errno (fp, EINVAL));\n \n   if (name == NULL || name[0] == '\\0')\n     return (ctf_set_errno (fp, ECTF_NONAME));\n \n-  if ((type = ctf_add_generic (fp, flag, name, kind, &dtd)) == CTF_ERR)\n+  if (!ctf_assert (fp, kind == CTF_K_INTEGER || kind == CTF_K_FLOAT))\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  if ((type = ctf_add_generic (fp, flag, name, kind, sizeof (uint32_t),\n+\t\t\t       &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, flag, 0);\n   dtd->dtd_data.ctt_size = clp2 (P2ROUNDUP (ep->cte_bits, CHAR_BIT)\n \t\t\t\t / CHAR_BIT);\n-  dtd->dtd_u.dtu_enc = *ep;\n+  switch (kind)\n+    {\n+    case CTF_K_INTEGER:\n+      encoding = CTF_INT_DATA (ep->cte_format, ep->cte_offset, ep->cte_bits);\n+      break;\n+    case CTF_K_FLOAT:\n+      encoding = CTF_FP_DATA (ep->cte_format, ep->cte_offset, ep->cte_bits);\n+      break;\n+    }\n+  memcpy (dtd->dtd_vlen, &encoding, sizeof (encoding));\n \n   return type;\n }\n@@ -509,7 +533,7 @@ ctf_add_reftype (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n   if (ref != 0 && ctf_lookup_by_id (&tmp, ref) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n-  if ((type = ctf_add_generic (fp, flag, NULL, kind, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, NULL, kind, 0, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, flag, 0);\n@@ -539,6 +563,7 @@ ctf_add_slice (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref,\n \t       const ctf_encoding_t *ep)\n {\n   ctf_dtdef_t *dtd;\n+  ctf_slice_t slice;\n   ctf_id_t resolved_ref = ref;\n   ctf_id_t type;\n   int kind;\n@@ -569,15 +594,19 @@ ctf_add_slice (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref,\n       && (ref != 0))\n     return (ctf_set_errno (fp, ECTF_NOTINTFP));\n \n-  if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_SLICE, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_SLICE,\n+\t\t\t       sizeof (ctf_slice_t), &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n+  memset (&slice, 0, sizeof (ctf_slice_t));\n+\n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_SLICE, flag, 0);\n   dtd->dtd_data.ctt_size = clp2 (P2ROUNDUP (ep->cte_bits, CHAR_BIT)\n \t\t\t\t / CHAR_BIT);\n-  dtd->dtd_u.dtu_slice.cts_type = (uint32_t) ref;\n-  dtd->dtd_u.dtu_slice.cts_bits = ep->cte_bits;\n-  dtd->dtd_u.dtu_slice.cts_offset = ep->cte_offset;\n+  slice.cts_type = (uint32_t) ref;\n+  slice.cts_bits = ep->cte_bits;\n+  slice.cts_offset = ep->cte_offset;\n+  memcpy (dtd->dtd_vlen, &slice, sizeof (ctf_slice_t));\n \n   return type;\n }\n@@ -628,7 +657,8 @@ ctf_add_array (ctf_dict_t *fp, uint32_t flag, const ctf_arinfo_t *arp)\n       return (ctf_set_errno (fp, ECTF_INCOMPLETE));\n     }\n \n-  if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_ARRAY, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_ARRAY,\n+\t\t\t       0, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_ARRAY, flag, 0);\n@@ -700,7 +730,7 @@ ctf_add_function (ctf_dict_t *fp, uint32_t flag,\n     }\n \n   if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_FUNCTION,\n-\t\t\t       &dtd)) == CTF_ERR)\n+\t\t\t       0, &dtd)) == CTF_ERR)\n     {\n       free (vdat);\n       return CTF_ERR;\t\t   /* errno is set for us.  */\n@@ -730,7 +760,7 @@ ctf_add_struct_sized (ctf_dict_t *fp, uint32_t flag, const char *name,\n   if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n     dtd = ctf_dtd_lookup (fp, type);\n   else if ((type = ctf_add_generic (fp, flag, name, CTF_K_STRUCT,\n-\t\t\t\t    &dtd)) == CTF_ERR)\n+\t\t\t\t    0, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_STRUCT, flag, 0);\n@@ -767,7 +797,7 @@ ctf_add_union_sized (ctf_dict_t *fp, uint32_t flag, const char *name,\n   if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n     dtd = ctf_dtd_lookup (fp, type);\n   else if ((type = ctf_add_generic (fp, flag, name, CTF_K_UNION,\n-\t\t\t\t    &dtd)) == CTF_ERR)\n+\t\t\t\t    0, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_UNION, flag, 0);\n@@ -803,7 +833,7 @@ ctf_add_enum (ctf_dict_t *fp, uint32_t flag, const char *name)\n   if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n     dtd = ctf_dtd_lookup (fp, type);\n   else if ((type = ctf_add_generic (fp, flag, name, CTF_K_ENUM,\n-\t\t\t\t    &dtd)) == CTF_ERR)\n+\t\t\t\t    0, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_ENUM, flag, 0);\n@@ -861,7 +891,7 @@ ctf_add_forward (ctf_dict_t *fp, uint32_t flag, const char *name,\n   if (type)\n     return type;\n \n-  if ((type = ctf_add_generic (fp, flag, name, kind, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, name, kind, 0, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_FORWARD, flag, 0);\n@@ -887,7 +917,7 @@ ctf_add_typedef (ctf_dict_t *fp, uint32_t flag, const char *name,\n   if (ref != 0 && ctf_lookup_by_id (&tmp, ref) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n-  if ((type = ctf_add_generic (fp, flag, name, CTF_K_TYPEDEF,\n+  if ((type = ctf_add_generic (fp, flag, name, CTF_K_TYPEDEF, 0,\n \t\t\t       &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n@@ -1783,7 +1813,7 @@ ctf_add_type_internal (ctf_dict_t *dst_fp, ctf_dict_t *src_fp, ctf_id_t src_type\n \t   manually so as to avoid repeated lookups in ctf_add_member\n \t   and to ensure the exact same member offsets as in src_type.  */\n \n-\tdst_type = ctf_add_generic (dst_fp, flag, name, kind, &dtd);\n+\tdst_type = ctf_add_generic (dst_fp, flag, name, kind, 0, &dtd);\n \tif (dst_type == CTF_ERR)\n \t  return CTF_ERR;\t\t\t/* errno is set for us.  */\n "
    },
    {
      "sha": "b8a7d49b9dbca9e93c529f9b72a0dd281d4ba7d8",
      "filename": "libctf/ctf-dedup.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-dedup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-dedup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dedup.c?ref=7879dd88efdabc5a2e93b71f488f09303117a0a9",
      "patch": "@@ -752,7 +752,7 @@ ctf_dedup_rhash_type (ctf_dict_t *fp, ctf_dict_t *input, ctf_dict_t **inputs,\n \tciter = hval;\n \n \tif ((dtd = ctf_dynamic_type (input, type)) != NULL)\n-\t  slice = &dtd->dtd_u.dtu_slice;\n+\t  slice = (ctf_slice_t *) dtd->dtd_vlen;\n \telse\n \t  slice = (ctf_slice_t *) ((uintptr_t) tp + increment);\n "
    },
    {
      "sha": "742b4b37affd0eea4db52ba131c709a738adf318",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=7879dd88efdabc5a2e93b71f488f09303117a0a9",
      "patch": "@@ -192,13 +192,12 @@ typedef struct ctf_dtdef\n   ctf_list_t dtd_list;\t\t/* List forward/back pointers.  */\n   ctf_id_t dtd_type;\t\t/* Type identifier for this definition.  */\n   ctf_type_t dtd_data;\t\t/* Type node, including name.  */\n+  unsigned char *dtd_vlen;\t/* Variable-length data for this type.  */\n   union\n   {\n     ctf_list_t dtu_members;\t/* struct, union, or enum */\n     ctf_arinfo_t dtu_arr;\t/* array */\n-    ctf_encoding_t dtu_enc;\t/* integer or float */\n     uint32_t *dtu_argv;\t\t/* function */\n-    ctf_slice_t dtu_slice;\t/* slice */\n   } dtd_u;\n } ctf_dtdef_t;\n "
    },
    {
      "sha": "f07cb61c42aa2bc7a7164eebfe0d8437ad69cd23",
      "filename": "libctf/ctf-serialize.c",
      "status": "modified",
      "additions": 3,
      "deletions": 16,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-serialize.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-serialize.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-serialize.c?ref=7879dd88efdabc5a2e93b71f488f09303117a0a9",
      "patch": "@@ -858,7 +858,6 @@ ctf_emit_type_sect (ctf_dict_t *fp, unsigned char **tptr)\n       uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n \n       ctf_array_t cta;\n-      uint32_t encoding;\n       size_t len;\n       ctf_stype_t *copied;\n       const char *name;\n@@ -879,24 +878,12 @@ ctf_emit_type_sect (ctf_dict_t *fp, unsigned char **tptr)\n \t{\n \tcase CTF_K_INTEGER:\n \tcase CTF_K_FLOAT:\n-\t  if (kind == CTF_K_INTEGER)\n-\t    {\n-\t      encoding = CTF_INT_DATA (dtd->dtd_u.dtu_enc.cte_format,\n-\t\t\t\t       dtd->dtd_u.dtu_enc.cte_offset,\n-\t\t\t\t       dtd->dtd_u.dtu_enc.cte_bits);\n-\t    }\n-\t  else\n-\t    {\n-\t      encoding = CTF_FP_DATA (dtd->dtd_u.dtu_enc.cte_format,\n-\t\t\t\t      dtd->dtd_u.dtu_enc.cte_offset,\n-\t\t\t\t      dtd->dtd_u.dtu_enc.cte_bits);\n-\t    }\n-\t  memcpy (t, &encoding, sizeof (encoding));\n-\t  t += sizeof (encoding);\n+\t  memcpy (t, dtd->dtd_vlen, sizeof (uint32_t));\n+\t  t += sizeof (uint32_t);\n \t  break;\n \n \tcase CTF_K_SLICE:\n-\t  memcpy (t, &dtd->dtd_u.dtu_slice, sizeof (struct ctf_slice));\n+\t  memcpy (t, dtd->dtd_vlen, sizeof (struct ctf_slice));\n \t  t += sizeof (struct ctf_slice);\n \t  break;\n "
    },
    {
      "sha": "ae2438177131aa6787cf7e355c2f3c63bb854377",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 11,
      "deletions": 32,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7879dd88efdabc5a2e93b71f488f09303117a0a9/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=7879dd88efdabc5a2e93b71f488f09303117a0a9",
      "patch": "@@ -1168,7 +1168,7 @@ ctf_type_reference (ctf_dict_t *fp, ctf_id_t type)\n \t    sp = (const ctf_slice_t *) ((uintptr_t) tp + increment);\n \t  }\n \telse\n-\t  sp = &dtd->dtd_u.dtu_slice;\n+\t  sp = (const ctf_slice_t *) dtd->dtd_vlen;\n \n \treturn sp->cts_type;\n       }\n@@ -1218,52 +1218,30 @@ ctf_type_encoding (ctf_dict_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n   ctf_dtdef_t *dtd;\n   const ctf_type_t *tp;\n   ssize_t increment;\n+  const unsigned char *vlen;\n   uint32_t data;\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n     return -1;\t\t\t/* errno is set for us.  */\n \n   if ((dtd = ctf_dynamic_type (ofp, type)) != NULL)\n+    vlen = dtd->dtd_vlen;\n+  else\n     {\n-      switch (LCTF_INFO_KIND (fp, tp->ctt_info))\n-\t{\n-\tcase CTF_K_INTEGER:\n-\tcase CTF_K_FLOAT:\n-\t  *ep = dtd->dtd_u.dtu_enc;\n-\t  break;\n-\tcase CTF_K_SLICE:\n-\t  {\n-\t    const ctf_slice_t *slice;\n-\t    ctf_encoding_t underlying_en;\n-\t    ctf_id_t underlying;\n-\n-\t    slice = &dtd->dtd_u.dtu_slice;\n-\t    underlying = ctf_type_resolve (fp, slice->cts_type);\n-\t    data = ctf_type_encoding (fp, underlying, &underlying_en);\n-\n-\t    ep->cte_format = underlying_en.cte_format;\n-\t    ep->cte_offset = slice->cts_offset;\n-\t    ep->cte_bits = slice->cts_bits;\n-\t    break;\n-\t  }\n-\tdefault:\n-\t  return (ctf_set_errno (ofp, ECTF_NOTINTFP));\n-\t}\n-      return 0;\n+      ctf_get_ctt_size (fp, tp, NULL, &increment);\n+      vlen = (const unsigned char *) ((uintptr_t) tp + increment);\n     }\n \n-  (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n-\n   switch (LCTF_INFO_KIND (fp, tp->ctt_info))\n     {\n     case CTF_K_INTEGER:\n-      data = *(const uint32_t *) ((uintptr_t) tp + increment);\n+      data = *(const uint32_t *) vlen;\n       ep->cte_format = CTF_INT_ENCODING (data);\n       ep->cte_offset = CTF_INT_OFFSET (data);\n       ep->cte_bits = CTF_INT_BITS (data);\n       break;\n     case CTF_K_FLOAT:\n-      data = *(const uint32_t *) ((uintptr_t) tp + increment);\n+      data = *(const uint32_t *) vlen;\n       ep->cte_format = CTF_FP_ENCODING (data);\n       ep->cte_offset = CTF_FP_OFFSET (data);\n       ep->cte_bits = CTF_FP_BITS (data);\n@@ -1274,9 +1252,10 @@ ctf_type_encoding (ctf_dict_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n \tctf_encoding_t underlying_en;\n \tctf_id_t underlying;\n \n-\tslice = (ctf_slice_t *) ((uintptr_t) tp + increment);\n+\tslice = (ctf_slice_t *) vlen;\n \tunderlying = ctf_type_resolve (fp, slice->cts_type);\n-\tdata = ctf_type_encoding (fp, underlying, &underlying_en);\n+\tif (ctf_type_encoding (fp, underlying, &underlying_en) < 0)\n+\t  return -1;\t\t\t\t/* errno is set for us.  */\n \n \tep->cte_format = underlying_en.cte_format;\n \tep->cte_offset = slice->cts_offset;"
    }
  ]
}