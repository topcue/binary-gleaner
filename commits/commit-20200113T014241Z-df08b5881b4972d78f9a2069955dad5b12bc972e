{
  "sha": "df08b5881b4972d78f9a2069955dad5b12bc972e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGYwOGI1ODgxYjQ5NzJkNzhmOWEyMDY5OTU1ZGFkNWIxMmJjOTcyZQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-13T00:48:36Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-13T01:42:41Z"
    },
    "message": "score formatting\n\n\t* score-dis.c: Formatting.\n\t* score7-dis.c: Formatting.",
    "tree": {
      "sha": "9c7ad5739d4c44153f2e576616a9537978c0ca3c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9c7ad5739d4c44153f2e576616a9537978c0ca3c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/df08b5881b4972d78f9a2069955dad5b12bc972e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/df08b5881b4972d78f9a2069955dad5b12bc972e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/df08b5881b4972d78f9a2069955dad5b12bc972e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/df08b5881b4972d78f9a2069955dad5b12bc972e/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b2c759ce68102931140ce34c2ac00619ba363622",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b2c759ce68102931140ce34c2ac00619ba363622",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b2c759ce68102931140ce34c2ac00619ba363622"
    }
  ],
  "stats": {
    "total": 1620,
    "additions": 808,
    "deletions": 812
  },
  "files": [
    {
      "sha": "e034a611e1de9498ce36860a11091df9d9441abc",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/df08b5881b4972d78f9a2069955dad5b12bc972e/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/df08b5881b4972d78f9a2069955dad5b12bc972e/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=df08b5881b4972d78f9a2069955dad5b12bc972e",
      "patch": "@@ -1,3 +1,8 @@\n+2020-01-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* score-dis.c: Formatting.\n+\t* score7-dis.c: Formatting.\n+\n 2020-01-13  Alan Modra  <amodra@gmail.com>\n \n \t* score-dis.c (print_insn_score48): Use unsigned variables for"
    },
    {
      "sha": "e0ef21ee0b19b2d6a507b809a15d0f56437dc3ae",
      "filename": "opcodes/score-dis.c",
      "status": "modified",
      "additions": 524,
      "deletions": 519,
      "changes": 1043,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/df08b5881b4972d78f9a2069955dad5b12bc972e/opcodes/score-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/df08b5881b4972d78f9a2069955dad5b12bc972e/opcodes/score-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/score-dis.c?ref=df08b5881b4972d78f9a2069955dad5b12bc972e",
      "patch": "@@ -41,8 +41,8 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little);\n struct score_opcode\n {\n   bfd_vma value;\n-  bfd_vma mask;           /* Recognise instruction if (op & mask) == value.  */\n-  char *assembler;        /* Disassembly string.  */\n+  bfd_vma mask;\t\t/* Recognise instruction if (op & mask) == value.  */\n+  char *assembler;\t/* Disassembly string.  */\n };\n \n /* Note: There is a partial ordering in this table - it must be searched from\n@@ -521,139 +521,140 @@ print_insn_score48 (struct disassemble_info *info, bfd_vma given)\n   for (insn = score_opcodes; insn->assembler; insn++)\n     {\n       /* Using insn->mask &0xff00000000 to distinguish 48/32 bit.  */\n-      if (((insn->mask & 0xff0000000000LL)!=0) && (given & insn->mask) == insn->value)\n-        {\n-           info->bytes_per_chunk = 2;\n-           info->bytes_per_line =6;\n-\n-          char *c;\n-\n-          for (c = insn->assembler; *c; c++)\n-            {\n-              if (*c == '%')\n-                {\n-                  switch (*++c)\n-                    {\n-                    case '0':\n-                    case '1':\n-                    case '2':\n-                    case '3':\n-                    case '4':\n-                    case '5':\n-                    case '6':\n-                    case '7':\n-                    case '8':\n-                    case '9':\n-                      {\n-                        int bitstart = *c++ - '0';\n-                        int bitend = 0;\n-\n-                        while (*c >= '0' && *c <= '9')\n-                          bitstart = (bitstart * 10) + *c++ - '0';\n-\n-                        switch (*c)\n-                          {\n-                          case '-':\n-                            c++;\n-                            while (*c >= '0' && *c <= '9')\n-                              bitend = (bitend * 10) + *c++ - '0';\n-\n-                            if (!bitend)\n-                              abort ();\n-\n-                            switch (*c)\n-                              {\n-                              case 'r':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%s\", score_regnames[reg]);\n-                                }\n-                                break;\n-                              case 'd':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%ld\", reg);\n-                                }\n-                                break;\n-                              case 'i':\n-                                {\n-                                  long reg;\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-                                  reg = ((reg ^ (1u << (bitend - bitstart)))\n+      if ((insn->mask & 0xff0000000000LL) != 0\n+\t  && (given & insn->mask) == insn->value)\n+\t{\n+\t  info->bytes_per_chunk = 2;\n+\t  info->bytes_per_line =6;\n+\n+\t  char *c;\n+\n+\t  for (c = insn->assembler; *c; c++)\n+\t    {\n+\t      if (*c == '%')\n+\t\t{\n+\t\t  switch (*++c)\n+\t\t    {\n+\t\t    case '0':\n+\t\t    case '1':\n+\t\t    case '2':\n+\t\t    case '3':\n+\t\t    case '4':\n+\t\t    case '5':\n+\t\t    case '6':\n+\t\t    case '7':\n+\t\t    case '8':\n+\t\t    case '9':\n+\t\t      {\n+\t\t\tint bitstart = *c++ - '0';\n+\t\t\tint bitend = 0;\n+\n+\t\t\twhile (*c >= '0' && *c <= '9')\n+\t\t\t  bitstart = (bitstart * 10) + *c++ - '0';\n+\n+\t\t\tswitch (*c)\n+\t\t\t  {\n+\t\t\t  case '-':\n+\t\t\t    c++;\n+\t\t\t    while (*c >= '0' && *c <= '9')\n+\t\t\t      bitend = (bitend * 10) + *c++ - '0';\n+\n+\t\t\t    if (!bitend)\n+\t\t\t      abort ();\n+\n+\t\t\t    switch (*c)\n+\t\t\t      {\n+\t\t\t      case 'r':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%s\", score_regnames[reg]);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'd':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%ld\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'i':\n+\t\t\t\t{\n+\t\t\t\t  long reg;\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\t\t\t\t  reg = ((reg ^ (1u << (bitend - bitstart)))\n \t\t\t\t\t - (1u << (bitend - bitstart)));\n-                                  /* Fix bug: s3_testsuite 64-bit.\n-                                     Remove high 32 bits.  */\n-                                  reg = (int) reg;\n-\n-                                  if (((given & insn->mask) == 0x0c00000a)      /* ldc1  */\n-                                      || ((given & insn->mask) == 0x0c000012)   /* ldc2  */\n-                                      || ((given & insn->mask) == 0x0c00001c)   /* ldc3  */\n-                                      || ((given & insn->mask) == 0x0c00000b)   /* stc1  */\n-                                      || ((given & insn->mask) == 0x0c000013)   /* stc2  */\n-                                      || ((given & insn->mask) == 0x0c00001b))  /* stc3  */\n-                                    reg *= 4;\n-\n-                                  func (stream, \"%ld\", reg);\n-                                }\n-                                break;\n-                              case 'x':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%lx\", reg);\n-                                }\n-                                break;\n-                                case 'w':\n-                                {\n-                                    unsigned long reg;\n-                                    reg = given >> bitstart;\n-                                    reg &= (2u << (bitend - bitstart)) - 1;\n-                                    reg <<= 2;\n-                                    func (stream, \"%lx\", reg);\n-                                }\n-                                break;\n-\n-                              default:\n-                                abort ();\n-                              }\n-                            break;\n-\n-                          case '`':\n-                            c++;\n-                            if ((given & (1u << bitstart)) == 0)\n-                              func (stream, \"%c\", *c);\n-                            break;\n-                          case '\\'':\n-                            c++;\n-                            if ((given & (1u << bitstart)) != 0)\n-                              func (stream, \"%c\", *c);\n-                            break;\n-                          default:\n-                            abort ();\n-                          }\n-                        break;\n-                      }\n-                    default:\n+\t\t\t\t  /* Fix bug: s3_testsuite 64-bit.\n+\t\t\t\t     Remove high 32 bits.  */\n+\t\t\t\t  reg = (int) reg;\n+\n+\t\t\t\t  if (((given & insn->mask) == 0x0c00000a)      /* ldc1  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c000012)   /* ldc2  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00001c)   /* ldc3  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00000b)   /* stc1  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c000013)   /* stc2  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00001b))  /* stc3  */\n+\t\t\t\t    reg *= 4;\n+\n+\t\t\t\t  func (stream, \"%ld\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'x':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%lx\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'w':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\t\t\t\t  reg <<= 2;\n+\t\t\t\t  func (stream, \"%lx\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\t      default:\n+\t\t\t\tabort ();\n+\t\t\t      }\n+\t\t\t    break;\n+\n+\t\t\t  case '`':\n+\t\t\t    c++;\n+\t\t\t    if ((given & (1u << bitstart)) == 0)\n+\t\t\t      func (stream, \"%c\", *c);\n+\t\t\t    break;\n+\t\t\t  case '\\'':\n+\t\t\t    c++;\n+\t\t\t    if ((given & (1u << bitstart)) != 0)\n+\t\t\t      func (stream, \"%c\", *c);\n+\t\t\t    break;\n+\t\t\t  default:\n+\t\t\t    abort ();\n+\t\t\t  }\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    default:\n \t\t      abort ();\n-                    }\n-                }\n-              else\n-                func (stream, \"%c\", *c);\n-            }\n-          return 6;\n-        }\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tfunc (stream, \"%c\", *c);\n+\t    }\n+\t  return 6;\n+\t}\n     }\n \n #if (SCORE_SIMULATOR_ACTIVE)\n@@ -671,196 +672,207 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)\n {\n   struct score_opcode *insn;\n   void *stream = info->stream;\n-  int  rb_equal_zero=1;\n+  int rb_equal_zero = 1;\n   fprintf_ftype func = info->fprintf_func;\n \n   for (insn = score_opcodes; insn->assembler; insn++)\n     {\n-      if (((insn->mask & 0xff0000000000LL)==0)&&(insn->mask & 0xffff0000) && (given & insn->mask) == insn->value)\n-        {\n-          /* check for bcmpeq / bcmpeqz / bcmpne / bcmpnez */\n-            /* given &0x7c00 is for to test if rb is zero  ,\n-                 rb_equal_zero =1 : index to bcmpeqz\n-                 rb_equal_zero =0 , index to bcmpeq\n-                this checking rule only for branch compare ( insn->mask ==0x3e00007e*/\n-            if (((given & 0x7c00) !=0)&&(rb_equal_zero ==1)&&(insn->mask == 0x3e00007e)\n-                && (insn->value == 0x0000004c || insn->value == 0x0000004e))\n-            {\n-                rb_equal_zero =0;\n-               continue;\n-             }\n-\n-          char *c;\n-\n-          for (c = insn->assembler; *c; c++)\n-            {\n-              if (*c == '%')\n-                {\n-                  switch (*++c)\n-                    {\n-                    case 'j':\n-                      {\n-                        int target;\n-\n-                        if (info->flags & INSN_HAS_RELOC)\n-                          pc = 0;\n-                        target = (pc & 0xfe000000) | (given & 0x01fffffe);\n-                        (*info->print_address_func) (target, info);\n-                      }\n-                      break;\n-                    case 'b':\n-                      {\n-                        /* Sign-extend a 20-bit number.  */\n-#define SEXT20(x)       ((((x) & 0xfffff) ^ (~ 0x7ffff)) + 0x80000)\n-                        int disp = ((given & 0x01ff8000) >> 5) | (given & 0x3fe);\n-                        int target = (pc + SEXT20 (disp));\n-\n-                        (*info->print_address_func) (target, info);\n-                      }\n-                      break;\n-                    case 'z':\n-                      {\n-#define SEXT10(x)           ((((x) & 0x3ff) ^ (~ 0x1ff)) + 0x200)\n-                           if  ((given & 0x7c00 ) == 0)\n-                           {\n-                               /* Sign-extend a 20-bit number.  */\n-                               /* disp : [24 -20]  , [9-7 ] , [0] */\n-                                  int disp = (given&1)<<1 |((given>>7)&7)<<2 |((given>>20)&0x1f)<<5;\n-                                  int target = (pc + SEXT10 (disp));\n-                                  (*info->print_address_func) (target, info);\n-                           }\n-                           else\n-                           {\n-                               unsigned long reg;\n-                               int bitstart = 10;\n-                               int bitend = 14;\n-                               reg = given >> bitstart;\n-                               reg &= (2u << (bitend - bitstart)) - 1;\n-                               /* Sign-extend a 20-bit number.  */\n-                               int disp = (given&1)<<1 |((given>>7)&7)<<2 |((given>>20)&0x1f)<<5;\n-                               int target = (pc + SEXT10 (disp));\n-                               func (stream, \"%s ,\", score_regnames[reg] );\n-                                  (*info->print_address_func) (target, info);\n-\n-                               }\n-\n-                      }\n-                      break;\n-                    case 'm':\n-                      {\n-                        /* disp : [24 -20]  , [9-7 ] , [0] */\n-                        int disp = (given&1)<<2 |((given>>7)&7)<<3 |((given>>20)&0x1f)<<6;\n-                        (*info->print_address_func) (disp, info);\n-                      }\n-                      break;\n-                    case '0':\n-                    case '1':\n-                    case '2':\n-                    case '3':\n-                    case '4':\n-                    case '5':\n-                    case '6':\n-                    case '7':\n-                    case '8':\n-                    case '9':\n-                      {\n-                        int bitstart = *c++ - '0';\n-                        int bitend = 0;\n-\n-                        while (*c >= '0' && *c <= '9')\n-                          bitstart = (bitstart * 10) + *c++ - '0';\n-\n-                        switch (*c)\n-                          {\n-                          case '-':\n-                            c++;\n-                            while (*c >= '0' && *c <= '9')\n-                              bitend = (bitend * 10) + *c++ - '0';\n-\n-                            if (!bitend)\n-                              abort ();\n-\n-                            switch (*c)\n-                              {\n-                              case 'r':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%s\", score_regnames[reg]);\n-                                }\n-                                break;\n-                              case 'd':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%ld\", reg);\n-                                }\n-                                break;\n-                              case 'i':\n-                                {\n-                                  long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-                                  reg = ((reg ^ (1u << (bitend - bitstart)))\n+      if ((insn->mask & 0xff0000000000LL) == 0\n+\t  && (insn->mask & 0xffff0000) != 0\n+\t  && (given & insn->mask) == insn->value)\n+\t{\n+\t  /* check for bcmpeq / bcmpeqz / bcmpne / bcmpnez\n+\t     given & 0x7c00 is to test if rb is zero,\n+\t     rb_equal_zero = 1 : index to bcmpeqz\n+\t     rb_equal_zero = 0 , index to bcmpeq\n+\t     only for branch compare (insn->mask == 0x3e00007e).  */\n+\t  if ((given & 0x7c00) != 0\n+\t      && rb_equal_zero\n+\t      && insn->mask == 0x3e00007e\n+\t      && (insn->value == 0x0000004c || insn->value == 0x0000004e))\n+\t    {\n+\t      rb_equal_zero =0;\n+\t      continue;\n+\t    }\n+\n+\t  char *c;\n+\n+\t  for (c = insn->assembler; *c; c++)\n+\t    {\n+\t      if (*c == '%')\n+\t\t{\n+\t\t  switch (*++c)\n+\t\t    {\n+\t\t    case 'j':\n+\t\t      {\n+\t\t\tint target;\n+\n+\t\t\tif (info->flags & INSN_HAS_RELOC)\n+\t\t\t  pc = 0;\n+\t\t\ttarget = (pc & 0xfe000000) | (given & 0x01fffffe);\n+\t\t\t(*info->print_address_func) (target, info);\n+\t\t      }\n+\t\t      break;\n+\t\t    case 'b':\n+\t\t      {\n+\t\t\t/* Sign-extend a 20-bit number.  */\n+#define SEXT20(x) ((((x) & 0xfffff) ^ (~ 0x7ffff)) + 0x80000)\n+\t\t\tint disp = (((given & 0x01ff8000) >> 5)\n+\t\t\t\t    | (given & 0x3fe));\n+\t\t\tint target = (pc + SEXT20 (disp));\n+\n+\t\t\t(*info->print_address_func) (target, info);\n+\t\t      }\n+\t\t      break;\n+\t\t    case 'z':\n+\t\t      {\n+#define SEXT10(x) ((((x) & 0x3ff) ^ (~ 0x1ff)) + 0x200)\n+\t\t\tif  ((given & 0x7c00 ) == 0)\n+\t\t\t  {\n+\t\t\t    /* Sign-extend a 20-bit number.  */\n+\t\t\t    /* disp : [24 -20]  , [9-7 ] , [0] */\n+\t\t\t    int disp = ((given & 1) << 1\n+\t\t\t\t\t| ((given >> 7) & 7) << 2\n+\t\t\t\t\t| ((given >> 20) & 0x1f) <<5);\n+\t\t\t    int target = (pc + SEXT10 (disp));\n+\t\t\t    (*info->print_address_func) (target, info);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    unsigned long reg;\n+\t\t\t    int bitstart = 10;\n+\t\t\t    int bitend = 14;\n+\t\t\t    reg = given >> bitstart;\n+\t\t\t    reg &= (2u << (bitend - bitstart)) - 1;\n+\t\t\t    /* Sign-extend a 20-bit number.  */\n+\t\t\t    int disp = ((given & 1) << 1\n+\t\t\t\t\t| ((given >> 7) & 7) << 2\n+\t\t\t\t\t| ((given >> 20) & 0x1f) <<5);\n+\t\t\t    int target = (pc + SEXT10 (disp));\n+\t\t\t    func (stream, \"%s ,\", score_regnames[reg] );\n+\t\t\t    (*info->print_address_func) (target, info);\n+\n+\t\t\t  }\n+\n+\t\t      }\n+\t\t      break;\n+\t\t    case 'm':\n+\t\t      {\n+\t\t\t/* disp : [24 -20]  , [9-7 ] , [0] */\n+\t\t\tint disp = ((given & 1) << 2\n+\t\t\t\t    | ((given >> 7) & 7) << 3\n+\t\t\t\t    | ((given >> 20) & 0x1f) << 6);\n+\t\t\t(*info->print_address_func) (disp, info);\n+\t\t      }\n+\t\t      break;\n+\t\t    case '0':\n+\t\t    case '1':\n+\t\t    case '2':\n+\t\t    case '3':\n+\t\t    case '4':\n+\t\t    case '5':\n+\t\t    case '6':\n+\t\t    case '7':\n+\t\t    case '8':\n+\t\t    case '9':\n+\t\t      {\n+\t\t\tint bitstart = *c++ - '0';\n+\t\t\tint bitend = 0;\n+\n+\t\t\twhile (*c >= '0' && *c <= '9')\n+\t\t\t  bitstart = (bitstart * 10) + *c++ - '0';\n+\n+\t\t\tswitch (*c)\n+\t\t\t  {\n+\t\t\t  case '-':\n+\t\t\t    c++;\n+\t\t\t    while (*c >= '0' && *c <= '9')\n+\t\t\t      bitend = (bitend * 10) + *c++ - '0';\n+\n+\t\t\t    if (!bitend)\n+\t\t\t      abort ();\n+\n+\t\t\t    switch (*c)\n+\t\t\t      {\n+\t\t\t      case 'r':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%s\", score_regnames[reg]);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'd':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%ld\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'i':\n+\t\t\t\t{\n+\t\t\t\t  long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\t\t\t\t  reg = ((reg ^ (1u << (bitend - bitstart)))\n \t\t\t\t\t - (1u << (bitend - bitstart)));\n \n-                                  if (((given & insn->mask) == 0x0c00000a)      /* ldc1  */\n-                                      || ((given & insn->mask) == 0x0c000012)   /* ldc2  */\n-                                      || ((given & insn->mask) == 0x0c00001c)   /* ldc3  */\n-                                      || ((given & insn->mask) == 0x0c00000b)   /* stc1  */\n-                                      || ((given & insn->mask) == 0x0c000013)   /* stc2  */\n-                                      || ((given & insn->mask) == 0x0c00001b))  /* stc3  */\n-                                    reg *= 4;\n-\n-                                  func (stream, \"%ld\", reg);\n-                                }\n-                                break;\n-                              case 'x':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%lx\", reg);\n-                                }\n-                                break;\n-                              default:\n-                                abort ();\n-                              }\n-                            break;\n-\n-                          case '`':\n-                            c++;\n-                            if ((given & (1u << bitstart)) == 0)\n-                              func (stream, \"%c\", *c);\n-                            break;\n-                          case '\\'':\n-                            c++;\n-                            if ((given & (1u << bitstart)) != 0)\n-                              func (stream, \"%c\", *c);\n-                            break;\n-                          default:\n-                            abort ();\n-                          }\n-                        break;\n-                      }\n-                    default:\n+\t\t\t\t  if (((given & insn->mask) == 0x0c00000a)      /* ldc1  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c000012)   /* ldc2  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00001c)   /* ldc3  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00000b)   /* stc1  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c000013)   /* stc2  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00001b))  /* stc3  */\n+\t\t\t\t    reg *= 4;\n+\n+\t\t\t\t  func (stream, \"%ld\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'x':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%lx\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      default:\n+\t\t\t\tabort ();\n+\t\t\t      }\n+\t\t\t    break;\n+\n+\t\t\t  case '`':\n+\t\t\t    c++;\n+\t\t\t    if ((given & (1u << bitstart)) == 0)\n+\t\t\t      func (stream, \"%c\", *c);\n+\t\t\t    break;\n+\t\t\t  case '\\'':\n+\t\t\t    c++;\n+\t\t\t    if ((given & (1u << bitstart)) != 0)\n+\t\t\t      func (stream, \"%c\", *c);\n+\t\t\t    break;\n+\t\t\t  default:\n+\t\t\t    abort ();\n+\t\t\t  }\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    default:\n \t\t      abort ();\n-                    }\n-                }\n-              else\n-                func (stream, \"%c\", *c);\n-            }\n-          return 4;\n-        }\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tfunc (stream, \"%c\", *c);\n+\t    }\n+\t  return 4;\n+\t}\n     }\n \n #if (SCORE_SIMULATOR_ACTIVE)\n@@ -883,144 +895,146 @@ print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)\n   given &= 0xffff;\n   for (insn = score_opcodes; insn->assembler; insn++)\n     {\n-      if (((insn->mask & 0xff0000000000LL)==0) &&!(insn->mask & 0xffff0000) && (given & insn->mask) == insn->value)\n-        {\n-          char *c = insn->assembler;\n-\n-          info->bytes_per_chunk = 2;\n-          info->bytes_per_line = 4;\n-          given &= 0xffff;\n-\n-          for (; *c; c++)\n-            {\n-              if (*c == '%')\n-                {\n-                  switch (*++c)\n-                    {\n-\n-                    case 'j':\n-                      {\n-                        int target;\n-\n-                        if (info->flags & INSN_HAS_RELOC)\n-                          pc = 0;\n-\n-                        target = (pc & 0xfffff000) | (given & 0x00000ffe);\n-                        (*info->print_address_func) (target, info);\n-                      }\n-                      break;\n-                    case 'b':\n-                      {\n-                        /* Sign-extend a 9-bit number.  */\n-#define SEXT10(x)       ((((x) & 0x3ff) ^ (~ 0x1ff)) + 0x200)\n-                        int disp = (given & 0x1ff) << 1;\n-                        int target = (pc + SEXT10 (disp));\n-\n-                        (*info->print_address_func) (target, info);\n-                      }\n-                      break;\n-\n-                    case '0':\n-                    case '1':\n-                    case '2':\n-                    case '3':\n-                    case '4':\n-                    case '5':\n-                    case '6':\n-                    case '7':\n-                    case '8':\n-                    case '9':\n-                      {\n-                        int bitstart = *c++ - '0';\n-                        int bitend = 0;\n-\n-                        while (*c >= '0' && *c <= '9')\n-                          bitstart = (bitstart * 10) + *c++ - '0';\n-\n-                        switch (*c)\n-                          {\n-                          case '-':\n-                            {\n-                              long reg;\n-\n-                              c++;\n-                              while (*c >= '0' && *c <= '9')\n-                                bitend = (bitend * 10) + *c++ - '0';\n-                              if (!bitend)\n-                                abort ();\n-                              reg = given >> bitstart;\n-                              reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                              switch (*c)\n-                                {\n-                                case 'R':\n-                                  func (stream, \"%s\", score_regnames[reg + 16]);\n-                                  break;\n-                                case 'r':\n-                                  func (stream, \"%s\", score_regnames[reg]);\n-                                  break;\n-                                case 'd':\n+      if ((insn->mask & 0xff0000000000LL) == 0\n+\t  && !(insn->mask & 0xffff0000)\n+\t  && (given & insn->mask) == insn->value)\n+\t{\n+\t  char *c = insn->assembler;\n+\n+\t  info->bytes_per_chunk = 2;\n+\t  info->bytes_per_line = 4;\n+\t  given &= 0xffff;\n+\n+\t  for (; *c; c++)\n+\t    {\n+\t      if (*c == '%')\n+\t\t{\n+\t\t  switch (*++c)\n+\t\t    {\n+\t\t    case 'j':\n+\t\t      {\n+\t\t\tint target;\n+\n+\t\t\tif (info->flags & INSN_HAS_RELOC)\n+\t\t\t  pc = 0;\n+\n+\t\t\ttarget = (pc & 0xfffff000) | (given & 0x00000ffe);\n+\t\t\t(*info->print_address_func) (target, info);\n+\t\t      }\n+\t\t      break;\n+\n+\t\t    case 'b':\n+\t\t      {\n+\t\t\t/* Sign-extend a 9-bit number.  */\n+#define SEXT10(x) ((((x) & 0x3ff) ^ (~ 0x1ff)) + 0x200)\n+\t\t\tint disp = (given & 0x1ff) << 1;\n+\t\t\tint target = (pc + SEXT10 (disp));\n+\n+\t\t\t(*info->print_address_func) (target, info);\n+\t\t      }\n+\t\t      break;\n+\n+\t\t    case '0':\n+\t\t    case '1':\n+\t\t    case '2':\n+\t\t    case '3':\n+\t\t    case '4':\n+\t\t    case '5':\n+\t\t    case '6':\n+\t\t    case '7':\n+\t\t    case '8':\n+\t\t    case '9':\n+\t\t      {\n+\t\t\tint bitstart = *c++ - '0';\n+\t\t\tint bitend = 0;\n+\n+\t\t\twhile (*c >= '0' && *c <= '9')\n+\t\t\t  bitstart = (bitstart * 10) + *c++ - '0';\n+\n+\t\t\tswitch (*c)\n+\t\t\t  {\n+\t\t\t  case '-':\n+\t\t\t    {\n+\t\t\t      long reg;\n+\n+\t\t\t      c++;\n+\t\t\t      while (*c >= '0' && *c <= '9')\n+\t\t\t\tbitend = (bitend * 10) + *c++ - '0';\n+\t\t\t      if (!bitend)\n+\t\t\t\tabort ();\n+\t\t\t      reg = given >> bitstart;\n+\t\t\t      reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t      switch (*c)\n+\t\t\t\t{\n+\t\t\t\tcase 'R':\n+\t\t\t\t  func (stream, \"%s\", score_regnames[reg + 16]);\n+\t\t\t\t  break;\n+\t\t\t\tcase 'r':\n+\t\t\t\t  func (stream, \"%s\", score_regnames[reg]);\n+\t\t\t\t  break;\n+\t\t\t\tcase 'd':\n \t\t\t\t  /* Check rpush rd, 0 and rpop! rd, 0.\n \t\t\t\t     If 0, then print 32.  */\n \t\t\t\t  if (((given & 0x00007c00) == 0x00006c00\n \t\t\t\t       || (given & 0x00007c00) == 0x00006800)\n \t\t\t\t      && reg == 0)\n \t\t\t\t    reg = 32;\n \n-                                  if (*(c + 1) == '\\0')\n-                                    func (stream, \"%ld\", reg);\n-                                  else\n-                                    {\n-                                      c++;\n-                                      if (*c == '1')\n-                                        func (stream, \"%ld\", reg << 1);\n-                                      else if (*c == '2')\n-                                        func (stream, \"%ld\", reg << 2);\n-                                    }\n-                                  break;\n-\n-                                case 'x':\n-                                  if (*(c + 1) == '\\0')\n-                                    func (stream, \"%lx\", reg);\n-                                  else\n-                                    {\n-                                      c++;\n-                                      if (*c == '1')\n-                                        func (stream, \"%lx\", reg << 1);\n-                                      else if (*c == '2')\n-                                        func (stream, \"%lx\", reg << 2);\n-                                    }\n-                                  break;\n-                                case 'i':\n-                                  reg = (reg ^ (1u << bitend)) - (1u << bitend);\n-                                  func (stream, \"%ld\", reg);\n-                                  break;\n-                                default:\n-                                  abort ();\n-                                }\n-                            }\n-                            break;\n-\n-                          case '\\'':\n-                            c++;\n-                            if ((given & (1u << bitstart)) != 0)\n-                              func (stream, \"%c\", *c);\n-                            break;\n-                          default:\n-                            abort ();\n-                          }\n-                      }\n-                      break;\n-                    default:\n-                      abort ();\n-                    }\n-                }\n-              else\n-                func (stream, \"%c\", *c);\n-            }\n-\n-          return 2;\n-        }\n+\t\t\t\t  if (*(c + 1) == '\\0')\n+\t\t\t\t    func (stream, \"%ld\", reg);\n+\t\t\t\t  else\n+\t\t\t\t    {\n+\t\t\t\t      c++;\n+\t\t\t\t      if (*c == '1')\n+\t\t\t\t\tfunc (stream, \"%ld\", reg << 1);\n+\t\t\t\t      else if (*c == '2')\n+\t\t\t\t\tfunc (stream, \"%ld\", reg << 2);\n+\t\t\t\t    }\n+\t\t\t\t  break;\n+\n+\t\t\t\tcase 'x':\n+\t\t\t\t  if (*(c + 1) == '\\0')\n+\t\t\t\t    func (stream, \"%lx\", reg);\n+\t\t\t\t  else\n+\t\t\t\t    {\n+\t\t\t\t      c++;\n+\t\t\t\t      if (*c == '1')\n+\t\t\t\t\tfunc (stream, \"%lx\", reg << 1);\n+\t\t\t\t      else if (*c == '2')\n+\t\t\t\t\tfunc (stream, \"%lx\", reg << 2);\n+\t\t\t\t    }\n+\t\t\t\t  break;\n+\t\t\t\tcase 'i':\n+\t\t\t\t  reg = (reg ^ (1u << bitend)) - (1u << bitend);\n+\t\t\t\t  func (stream, \"%ld\", reg);\n+\t\t\t\t  break;\n+\t\t\t\tdefault:\n+\t\t\t\t  abort ();\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t    break;\n+\n+\t\t\t  case '\\'':\n+\t\t\t    c++;\n+\t\t\t    if ((given & (1u << bitstart)) != 0)\n+\t\t\t      func (stream, \"%c\", *c);\n+\t\t\t    break;\n+\t\t\t  default:\n+\t\t\t    abort ();\n+\t\t\t  }\n+\t\t      }\n+\t\t      break;\n+\t\t    default:\n+\t\t      abort ();\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tfunc (stream, \"%c\", *c);\n+\t    }\n+\n+\t  return 2;\n+\t}\n     }\n #if (SCORE_SIMULATOR_ACTIVE)\n   func (stream, _(\"<illegal instruction>\"));\n@@ -1037,128 +1051,119 @@ static int\n s3_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n {\n   unsigned char b[6];\n-  bfd_vma  given,given_h , given_l, given_16, given_32, given_48;\n+  bfd_vma given, given_h, given_l, given_16, given_32, given_48;\n   bfd_vma ridparity;\n   int status;\n   void *stream = info->stream;\n   fprintf_ftype func = info->fprintf_func;\n \n   info->display_endian = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;\n   info->bytes_per_chunk = 2;\n-  status = info->read_memory_func (pc, (bfd_byte *) & b[0], 4, info);\n+  status = info->read_memory_func (pc, (bfd_byte *) &b[0], 4, info);\n   if (status != 0)\n     {\n       info->bytes_per_chunk = 2;\n       status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);\n       b[3] = b[2] = 0;\n       if (status != 0)\n-        {\n-          info->memory_error_func (status, pc, info);\n-          return -1;\n-        }\n+\t{\n+\t  info->memory_error_func (status, pc, info);\n+\t  return -1;\n+\t}\n     }\n   if (little)\n-    {\n-      given = b[0] | (b[1] << 8);\n-    }\n+    given = b[0] | (b[1] << 8);\n   else\n-    {\n-      given = (b[0] << 8) | b[1];\n-    }\n+    given = (b[0] << 8) | b[1];\n \n   /* Set given_16.  */\n   given_16 = given;\n \n   /* Judge if now is insn_16_p.  */\n   if ((given & 0x8000)==0)\n-    return  print_insn_score16 (pc, info, given);\n-\n+    return print_insn_score16 (pc, info, given);\n   else\n     {\n       if (little)\n-        {\n-          given = ((bfd_vma)b[2]) | ((bfd_vma)b[3] << 8) | ((bfd_vma)b[0] << 16) | ((bfd_vma)b[1] << 24);\n-        }\n+\tgiven = ((bfd_vma) b[2] | (bfd_vma) b[3] << 8\n+\t\t | (bfd_vma) b[0] << 16 | (bfd_vma) b[1] << 24);\n       else\n-        {\n-          given = ((bfd_vma)b[0] << 24) | ((bfd_vma)b[1] << 16) | ((bfd_vma)b[2] << 8) | ((bfd_vma)b[3]);\n-        }\n+\tgiven = ((bfd_vma) b[0] << 24 | (bfd_vma) b[1] << 16\n+\t\t | (bfd_vma) b[2] << 8 | (bfd_vma) b[3]);\n \n       /* Set given_32.  */\n       given_32 = given;\n \n       /* Judge if now is insn_32.  */\n-      if ((given &0x80008000)==0x80000000)\n-        {\n-          /* Get rid of parity.  */\n-          ridparity = (given & 0x7FFF);\n-          ridparity |= (given & 0x7FFF0000) >> 1;\n-          given = ridparity;\n-          return  print_insn_score32 (pc, info, given);\n-        }\n+      if ((given & 0x80008000) == 0x80000000)\n+\t{\n+\t  /* Get rid of parity.  */\n+\t  ridparity = (given & 0x7FFF);\n+\t  ridparity |= (given & 0x7FFF0000) >> 1;\n+\t  given = ridparity;\n+\t  return print_insn_score32 (pc, info, given);\n+\t}\n     }\n \n   /* The insn is 48 bit.  */\n-  status = info->read_memory_func (pc, (bfd_byte *) & b[0], 6, info);\n+  status = info->read_memory_func (pc, (bfd_byte *) &b[0], 6, info);\n   if (status != 0)\n     {\n       info->memory_error_func (status, pc, info);\n       return -1;\n     }\n \n   if (little)\n-    {\n-      given = ((bfd_vma)b[4]) | ((bfd_vma)b[5] << 8) | ((bfd_vma)b[2] << 16) | ((bfd_vma)b[3] << 24)\n-              | ((bfd_vma)b[0] << 32) | ((bfd_vma)b[1] << 40);\n-    }\n+    given = ((bfd_vma) b[4] | (bfd_vma) b[5] << 8\n+\t     | (bfd_vma) b[2] << 16 | (bfd_vma) b[3] << 24\n+\t     | (bfd_vma) b[0] << 32 | (bfd_vma) b[1] << 40);\n   else\n     {\n-      given_l = ((bfd_vma)b[5]) | ((bfd_vma)b[4] << 8) | ((bfd_vma)b[3] << 16) | ((bfd_vma)b[2] << 24) ;\n-      given_h = ((bfd_vma)b[1] )|((bfd_vma)b[0] <<8);\n-      given = ((bfd_vma)given_h<<32) | (bfd_vma)given_l ;\n+      given_l = ((bfd_vma) b[5] | (bfd_vma) b[4] << 8\n+\t\t | (bfd_vma) b[3] << 16 | (bfd_vma) b[2] << 24);\n+      given_h = (bfd_vma) b[1] | (bfd_vma) b[0] << 8;\n+      given = (bfd_vma) given_h << 32 | (bfd_vma) given_l ;\n+    }\n+\n+  /* Set given_48.  */\n+  given_48 = given;\n \n+  if ((given & 0x800080008000LL) == 0x800080000000LL)\n+    {\n+      /* Get rid of parity.  */\n+      ridparity = (given & 0x7FFF);\n+      ridparity |= (given & 0x7FFF0000) >> 1;\n+      ridparity |= (given & 0x7FFF00000000LL) >> 2;\n+      given = ridparity;\n+      status = print_insn_score48  (info, given);\n+      return status;\n     }\n \n-    /* Set given_48.  */\n-    given_48 = given;\n-\n-    if ((given & 0x800080008000LL) == 0x800080000000LL)\n-      {\n-        /* Get rid of parity.  */\n-        ridparity = (given & 0x7FFF);\n-        ridparity |= (given & 0x7FFF0000) >> 1;\n-        ridparity |= (given & 0x7FFF00000000LL) >> 2;\n-        given = ridparity;\n-        status = print_insn_score48  (info, given);\n-        return status;\n-      }\n-\n-    /* Check 0x800080008000, 0x80008000, 0x8000.  */\n-    if ((given_48 & 0x800080008000LL) != 0x800080000000LL)\n-      {\n+  /* Check 0x800080008000, 0x80008000, 0x8000.  */\n+  if ((given_48 & 0x800080008000LL) != 0x800080000000LL)\n+    {\n #if (SCORE_SIMULATOR_ACTIVE)\n-        func (stream, _(\"<illegal instruction>\"));\n-        return 6;\n+      func (stream, _(\"<illegal instruction>\"));\n+      return 6;\n #endif\n-      }\n-    if (((given_32 & 0xffff00000000LL) == 0) && ((given_32 & 0x80008000) != 0x80000000))\n-      {\n+    }\n+  if ((given_32 & 0xffff00000000LL) == 0\n+      && ((given_32 & 0x80008000) != 0x80000000))\n+    {\n #if (SCORE_SIMULATOR_ACTIVE)\n-        func (stream, _(\"<illegal instruction>\"));\n-        return 4;\n+      func (stream, _(\"<illegal instruction>\"));\n+      return 4;\n #endif\n-      }\n-    if (((given_16 & 0xffffffff0000LL) == 0) && ((given_16 & 0x8000) != 0))\n-      {\n+    }\n+  if (((given_16 & 0xffffffff0000LL) == 0) && ((given_16 & 0x8000) != 0))\n+    {\n #if (SCORE_SIMULATOR_ACTIVE)\n-        func (stream, _(\"<illegal instruction>\"));\n-        return 2;\n+      func (stream, _(\"<illegal instruction>\"));\n+      return 2;\n #endif\n-      }\n-    else\n-      {\n-        return 0;\n-      }\n+    }\n+  else\n+    return 0;\n }\n \n static unsigned long\n@@ -1190,14 +1195,14 @@ print_insn_little_score (bfd_vma pc, struct disassemble_info *info)\n #else /* not BFD64 */\n int\n print_insn_big_score (bfd_vma pc ATTRIBUTE_UNUSED,\n-\t\t      struct disassemble_info * info ATTRIBUTE_UNUSED)\n+\t\t      struct disassemble_info *info ATTRIBUTE_UNUSED)\n {\n   abort ();\n }\n \n int\n print_insn_little_score (bfd_vma pc ATTRIBUTE_UNUSED,\n-\t\t\t struct disassemble_info * info ATTRIBUTE_UNUSED)\n+\t\t\t struct disassemble_info *info ATTRIBUTE_UNUSED)\n {\n   abort ();\n }"
    },
    {
      "sha": "6d20e7f50ce139811ba5643541de3af924cfab06",
      "filename": "opcodes/score7-dis.c",
      "status": "modified",
      "additions": 279,
      "deletions": 293,
      "changes": 572,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/df08b5881b4972d78f9a2069955dad5b12bc972e/opcodes/score7-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/df08b5881b4972d78f9a2069955dad5b12bc972e/opcodes/score7-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/score7-dis.c?ref=df08b5881b4972d78f9a2069955dad5b12bc972e",
      "patch": "@@ -48,8 +48,8 @@\n struct score_opcode\n {\n   unsigned long value;\n-  unsigned long mask;            /* Recognise instruction if (op & mask) == value.  */\n-  char *assembler;        /* Disassembly string.  */\n+  unsigned long mask;\t/* Recognise instruction if (op & mask) == value.  */\n+  char *assembler;\t/* Disassembly string.  */\n };\n \n /* Note: There is a partial ordering in this table - it must be searched from\n@@ -553,142 +553,142 @@ print_insn_score32 (bfd_vma pc, struct disassemble_info *info, long given)\n   for (insn = score_opcodes; insn->assembler; insn++)\n     {\n       if ((insn->mask & 0xffff0000) && (given & insn->mask) == insn->value)\n-        {\n-          char *c;\n-\n-          for (c = insn->assembler; *c; c++)\n-            {\n-              if (*c == '%')\n-                {\n-                  switch (*++c)\n-                    {\n-                    case 'j':\n-                      {\n-                        int target;\n-\n-                        if (info->flags & INSN_HAS_RELOC)\n-                          pc = 0;\n-                        target = (pc & 0xfe000000) | (given & 0x01fffffe);\n-                        (*info->print_address_func) (target, info);\n-                      }\n-                      break;\n-                    case 'b':\n-                      {\n-                        /* Sign-extend a 20-bit number.  */\n-#define SEXT20(x)       ((((x) & 0xfffff) ^ (~ 0x7ffff)) + 0x80000)\n-                        int disp = ((given & 0x01ff8000) >> 5) | (given & 0x3fe);\n-                        int target = (pc + SEXT20 (disp));\n-\n-                        (*info->print_address_func) (target, info);\n-                      }\n-                      break;\n-                    case '0':\n-                    case '1':\n-                    case '2':\n-                    case '3':\n-                    case '4':\n-                    case '5':\n-                    case '6':\n-                    case '7':\n-                    case '8':\n-                    case '9':\n-                      {\n-                        int bitstart = *c++ - '0';\n-                        int bitend = 0;\n-\n-                        while (*c >= '0' && *c <= '9')\n-                          bitstart = (bitstart * 10) + *c++ - '0';\n-\n-                        switch (*c)\n-                          {\n-                          case '-':\n-                            c++;\n-                            while (*c >= '0' && *c <= '9')\n-                              bitend = (bitend * 10) + *c++ - '0';\n-\n-                            if (!bitend)\n-                              abort ();\n-\n-                            switch (*c)\n-                              {\n-                              case 'r':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%s\", score_regnames[reg]);\n-                                }\n-                                break;\n-                              case 'd':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%ld\", reg);\n-                                }\n-                                break;\n-                              case 'i':\n-                                {\n-                                  long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-                                  reg = ((reg ^ (1 << (bitend - bitstart)))\n+\t{\n+\t  char *c;\n+\n+\t  for (c = insn->assembler; *c; c++)\n+\t    {\n+\t      if (*c == '%')\n+\t\t{\n+\t\t  switch (*++c)\n+\t\t    {\n+\t\t    case 'j':\n+\t\t      {\n+\t\t\tint target;\n+\n+\t\t\tif (info->flags & INSN_HAS_RELOC)\n+\t\t\t  pc = 0;\n+\t\t\ttarget = (pc & 0xfe000000) | (given & 0x01fffffe);\n+\t\t\t(*info->print_address_func) (target, info);\n+\t\t      }\n+\t\t      break;\n+\t\t    case 'b':\n+\t\t      {\n+\t\t\t/* Sign-extend a 20-bit number.  */\n+#define SEXT20(x) ((((x) & 0xfffff) ^ (~ 0x7ffff)) + 0x80000)\n+\t\t\tint disp = (given & 0x01ff8000) >> 5 | (given & 0x3fe);\n+\t\t\tint target = (pc + SEXT20 (disp));\n+\n+\t\t\t(*info->print_address_func) (target, info);\n+\t\t      }\n+\t\t      break;\n+\t\t    case '0':\n+\t\t    case '1':\n+\t\t    case '2':\n+\t\t    case '3':\n+\t\t    case '4':\n+\t\t    case '5':\n+\t\t    case '6':\n+\t\t    case '7':\n+\t\t    case '8':\n+\t\t    case '9':\n+\t\t      {\n+\t\t\tint bitstart = *c++ - '0';\n+\t\t\tint bitend = 0;\n+\n+\t\t\twhile (*c >= '0' && *c <= '9')\n+\t\t\t  bitstart = (bitstart * 10) + *c++ - '0';\n+\n+\t\t\tswitch (*c)\n+\t\t\t  {\n+\t\t\t  case '-':\n+\t\t\t    c++;\n+\t\t\t    while (*c >= '0' && *c <= '9')\n+\t\t\t      bitend = (bitend * 10) + *c++ - '0';\n+\n+\t\t\t    if (!bitend)\n+\t\t\t      abort ();\n+\n+\t\t\t    switch (*c)\n+\t\t\t      {\n+\t\t\t      case 'r':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%s\", score_regnames[reg]);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'd':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%ld\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'i':\n+\t\t\t\t{\n+\t\t\t\t  long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\t\t\t\t  reg = ((reg ^ (1 << (bitend - bitstart)))\n \t\t\t\t\t - (1 << (bitend - bitstart)));\n \n-                                  if (((given & insn->mask) == 0x0c00000a)      /* ldc1  */\n-                                      || ((given & insn->mask) == 0x0c000012)   /* ldc2  */\n-                                      || ((given & insn->mask) == 0x0c00001c)   /* ldc3  */\n-                                      || ((given & insn->mask) == 0x0c00000b)   /* stc1  */\n-                                      || ((given & insn->mask) == 0x0c000013)   /* stc2  */\n-                                      || ((given & insn->mask) == 0x0c00001b))  /* stc3  */\n-                                    reg *= 4;\n-\n-                                  func (stream, \"%ld\", reg);\n-                                }\n-                                break;\n-                              case 'x':\n-                                {\n-                                  unsigned long reg;\n-\n-                                  reg = given >> bitstart;\n-                                  reg &= (2u << (bitend - bitstart)) - 1;\n-\n-                                  func (stream, \"%lx\", reg);\n-                                }\n-                                break;\n-                              default:\n-                                abort ();\n-                              }\n-                            break;\n-                          case '`':\n-                            c++;\n-                            if ((given & (1u << bitstart)) == 0)\n-                              func (stream, \"%c\", *c);\n-                            break;\n-                          case '\\'':\n-                            c++;\n-                            if ((given & (1u << bitstart)) != 0)\n-                              func (stream, \"%c\", *c);\n-                            break;\n-                          default:\n-                            abort ();\n-                          }\n-                        break;\n-                      }\n-                    default:\n+\t\t\t\t  if (((given & insn->mask) == 0x0c00000a)      /* ldc1  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c000012)   /* ldc2  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00001c)   /* ldc3  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00000b)   /* stc1  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c000013)   /* stc2  */\n+\t\t\t\t      || ((given & insn->mask) == 0x0c00001b))  /* stc3  */\n+\t\t\t\t    reg *= 4;\n+\n+\t\t\t\t  func (stream, \"%ld\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      case 'x':\n+\t\t\t\t{\n+\t\t\t\t  unsigned long reg;\n+\n+\t\t\t\t  reg = given >> bitstart;\n+\t\t\t\t  reg &= (2u << (bitend - bitstart)) - 1;\n+\n+\t\t\t\t  func (stream, \"%lx\", reg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t      default:\n+\t\t\t\tabort ();\n+\t\t\t      }\n+\t\t\t    break;\n+\t\t\t  case '`':\n+\t\t\t    c++;\n+\t\t\t    if ((given & (1u << bitstart)) == 0)\n+\t\t\t      func (stream, \"%c\", *c);\n+\t\t\t    break;\n+\t\t\t  case '\\'':\n+\t\t\t    c++;\n+\t\t\t    if ((given & (1u << bitstart)) != 0)\n+\t\t\t      func (stream, \"%c\", *c);\n+\t\t\t    break;\n+\t\t\t  default:\n+\t\t\t    abort ();\n+\t\t\t  }\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    default:\n \t\t      abort ();\n-                    }\n-                }\n-              else\n-                func (stream, \"%c\", *c);\n-            }\n-          return 4;\n-        }\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tfunc (stream, \"%c\", *c);\n+\t    }\n+\t  return 4;\n+\t}\n     }\n \n #if (SCORE_SIMULATOR_ACTIVE)\n@@ -724,135 +724,135 @@ print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)\n   for (insn = score_opcodes; insn->assembler; insn++)\n     {\n       if (!(insn->mask & 0xffff0000) && (given & insn->mask) == insn->value)\n-        {\n-          char *c = insn->assembler;\n-\n-          info->bytes_per_chunk = 2;\n-          info->bytes_per_line = 4;\n-          given &= 0xffff;\n-\n-          for (; *c; c++)\n-            {\n-              if (*c == '%')\n-                {\n-                  switch (*++c)\n-                    {\n-\n-                    case 'j':\n-                      {\n-                        int target;\n-\n-                        if (info->flags & INSN_HAS_RELOC)\n-                          pc = 0;\n-\n-                        target = (pc & 0xfffff000) | (given & 0x00000ffe);\n-                        (*info->print_address_func) (target, info);\n-                      }\n-                      break;\n-                    case 'b':\n-                      {\n-                        /* Sign-extend a 9-bit number.  */\n-#define SEXT9(x)           ((((x) & 0x1ff) ^ (~ 0xff)) + 0x100)\n-                        int disp = (given & 0xff) << 1;\n-                        int target = (pc + SEXT9 (disp));\n-\n-                        (*info->print_address_func) (target, info);\n-                      }\n-                      break;\n-\n-                    case '0':\n-                    case '1':\n-                    case '2':\n-                    case '3':\n-                    case '4':\n-                    case '5':\n-                    case '6':\n-                    case '7':\n-                    case '8':\n-                    case '9':\n-                      {\n-                        int bitstart = *c++ - '0';\n-                        int bitend = 0;\n-\n-                        while (*c >= '0' && *c <= '9')\n-                          bitstart = (bitstart * 10) + *c++ - '0';\n-\n-                        switch (*c)\n-                          {\n-                          case '-':\n-                            {\n-                              long reg;\n-\n-                              c++;\n-                              while (*c >= '0' && *c <= '9')\n-                                bitend = (bitend * 10) + *c++ - '0';\n-                              if (!bitend)\n-                                abort ();\n-                              reg = given >> bitstart;\n-                              reg &= (2u << (bitend - bitstart)) - 1;\n-                              switch (*c)\n-                                {\n-                                case 'R':\n-                                  func (stream, \"%s\", score_regnames[reg + 16]);\n-                                  break;\n-                                case 'r':\n-                                  func (stream, \"%s\", score_regnames[reg]);\n-                                  break;\n-                                case 'd':\n-                                  if (*(c + 1) == '\\0')\n-                                    func (stream, \"%ld\", reg);\n-                                  else\n-                                    {\n-                                      c++;\n-                                      if (*c == '1')\n-                                        func (stream, \"%ld\", reg << 1);\n-                                      else if (*c == '2')\n-                                        func (stream, \"%ld\", reg << 2);\n-                                    }\n-                                  break;\n-\n-                                case 'x':\n-                                  if (*(c + 1) == '\\0')\n-                                    func (stream, \"%lx\", reg);\n-                                  else\n-                                    {\n-                                      c++;\n-                                      if (*c == '1')\n-                                        func (stream, \"%lx\", reg << 1);\n-                                      else if (*c == '2')\n-                                        func (stream, \"%lx\", reg << 2);\n-                                    }\n-                                  break;\n-                                case 'i':\n-                                  reg = ((reg ^ (1 << bitend)) - (1 << bitend));\n-                                  func (stream, \"%ld\", reg);\n-                                  break;\n-                                default:\n-                                  abort ();\n-                                }\n-                            }\n-                            break;\n-\n-                          case '\\'':\n-                            c++;\n-                            if ((given & (1u << bitstart)) != 0)\n-                              func (stream, \"%c\", *c);\n-                            break;\n-                          default:\n-                            abort ();\n-                          }\n-                      }\n-                      break;\n-                    default:\n-                      abort ();\n-                    }\n-                }\n-              else\n-                func (stream, \"%c\", *c);\n-            }\n-\n-          return 2;\n-        }\n+\t{\n+\t  char *c = insn->assembler;\n+\n+\t  info->bytes_per_chunk = 2;\n+\t  info->bytes_per_line = 4;\n+\t  given &= 0xffff;\n+\n+\t  for (; *c; c++)\n+\t    {\n+\t      if (*c == '%')\n+\t\t{\n+\t\t  switch (*++c)\n+\t\t    {\n+\n+\t\t    case 'j':\n+\t\t      {\n+\t\t\tint target;\n+\n+\t\t\tif (info->flags & INSN_HAS_RELOC)\n+\t\t\t  pc = 0;\n+\n+\t\t\ttarget = (pc & 0xfffff000) | (given & 0x00000ffe);\n+\t\t\t(*info->print_address_func) (target, info);\n+\t\t      }\n+\t\t      break;\n+\t\t    case 'b':\n+\t\t      {\n+\t\t\t/* Sign-extend a 9-bit number.  */\n+#define SEXT9(x) ((((x) & 0x1ff) ^ (~ 0xff)) + 0x100)\n+\t\t\tint disp = (given & 0xff) << 1;\n+\t\t\tint target = (pc + SEXT9 (disp));\n+\n+\t\t\t(*info->print_address_func) (target, info);\n+\t\t      }\n+\t\t      break;\n+\n+\t\t    case '0':\n+\t\t    case '1':\n+\t\t    case '2':\n+\t\t    case '3':\n+\t\t    case '4':\n+\t\t    case '5':\n+\t\t    case '6':\n+\t\t    case '7':\n+\t\t    case '8':\n+\t\t    case '9':\n+\t\t      {\n+\t\t\tint bitstart = *c++ - '0';\n+\t\t\tint bitend = 0;\n+\n+\t\t\twhile (*c >= '0' && *c <= '9')\n+\t\t\t  bitstart = (bitstart * 10) + *c++ - '0';\n+\n+\t\t\tswitch (*c)\n+\t\t\t  {\n+\t\t\t  case '-':\n+\t\t\t    {\n+\t\t\t      long reg;\n+\n+\t\t\t      c++;\n+\t\t\t      while (*c >= '0' && *c <= '9')\n+\t\t\t\tbitend = (bitend * 10) + *c++ - '0';\n+\t\t\t      if (!bitend)\n+\t\t\t\tabort ();\n+\t\t\t      reg = given >> bitstart;\n+\t\t\t      reg &= (2u << (bitend - bitstart)) - 1;\n+\t\t\t      switch (*c)\n+\t\t\t\t{\n+\t\t\t\tcase 'R':\n+\t\t\t\t  func (stream, \"%s\", score_regnames[reg + 16]);\n+\t\t\t\t  break;\n+\t\t\t\tcase 'r':\n+\t\t\t\t  func (stream, \"%s\", score_regnames[reg]);\n+\t\t\t\t  break;\n+\t\t\t\tcase 'd':\n+\t\t\t\t  if (*(c + 1) == '\\0')\n+\t\t\t\t    func (stream, \"%ld\", reg);\n+\t\t\t\t  else\n+\t\t\t\t    {\n+\t\t\t\t      c++;\n+\t\t\t\t      if (*c == '1')\n+\t\t\t\t\tfunc (stream, \"%ld\", reg << 1);\n+\t\t\t\t      else if (*c == '2')\n+\t\t\t\t\tfunc (stream, \"%ld\", reg << 2);\n+\t\t\t\t    }\n+\t\t\t\t  break;\n+\n+\t\t\t\tcase 'x':\n+\t\t\t\t  if (*(c + 1) == '\\0')\n+\t\t\t\t    func (stream, \"%lx\", reg);\n+\t\t\t\t  else\n+\t\t\t\t    {\n+\t\t\t\t      c++;\n+\t\t\t\t      if (*c == '1')\n+\t\t\t\t\tfunc (stream, \"%lx\", reg << 1);\n+\t\t\t\t      else if (*c == '2')\n+\t\t\t\t\tfunc (stream, \"%lx\", reg << 2);\n+\t\t\t\t    }\n+\t\t\t\t  break;\n+\t\t\t\tcase 'i':\n+\t\t\t\t  reg = ((reg ^ (1 << bitend)) - (1 << bitend));\n+\t\t\t\t  func (stream, \"%ld\", reg);\n+\t\t\t\t  break;\n+\t\t\t\tdefault:\n+\t\t\t\t  abort ();\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t    break;\n+\n+\t\t\t  case '\\'':\n+\t\t\t    c++;\n+\t\t\t    if ((given & (1u << bitstart)) != 0)\n+\t\t\t      func (stream, \"%c\", *c);\n+\t\t\t    break;\n+\t\t\t  default:\n+\t\t\t    abort ();\n+\t\t\t  }\n+\t\t      }\n+\t\t      break;\n+\t\t    default:\n+\t\t      abort ();\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tfunc (stream, \"%c\", *c);\n+\t    }\n+\n+\t  return 2;\n+\t}\n     }\n #if (SCORE_SIMULATOR_ACTIVE)\n   func (stream, _(\"<illegal instruction>\"));\n@@ -862,7 +862,6 @@ print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)\n   abort ();\n }\n \n-/*****************************************************************************/\n /* s3_s7: exported functions.  */\n \n /* NOTE: There are no checks in these routines that\n@@ -889,14 +888,14 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n   else\n     {\n       info->bytes_per_chunk = 4;\n-      status = info->read_memory_func (pc, (bfd_byte *) & b[0], 4, info);\n+      status = info->read_memory_func (pc, (bfd_byte *) &b[0], 4, info);\n       if (status != 0)\n-        {\n-          info->bytes_per_chunk = 2;\n-          status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);\n-          b[3] = b[2] = 0;\n-          insn_16_p = TRUE;\n-        }\n+\t{\n+\t  info->bytes_per_chunk = 2;\n+\t  status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);\n+\t  b[3] = b[2] = 0;\n+\t  insn_16_p = TRUE;\n+\t}\n     }\n \n   if (status != 0)\n@@ -906,39 +905,27 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n     }\n \n   if (little)\n-    {\n-      given = (b[0]) | (b[1] << 8) | (b[2] << 16) | ((unsigned) b[3] << 24);\n-    }\n+    given = b[0] | b[1] << 8 | b[2] << 16 | (unsigned) b[3] << 24;\n   else\n-    {\n-      given = ((unsigned) b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]);\n-    }\n+    given = (unsigned) b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3];\n \n   if ((given & 0x80008000) == 0x80008000)\n     {\n       insn_pce_p = FALSE;\n       insn_16_p = FALSE;\n     }\n   else if ((given & 0x8000) == 0x8000)\n-    {\n-      insn_pce_p = TRUE;\n-    }\n+    insn_pce_p = TRUE;\n   else\n-    {\n-      insn_16_p = TRUE;\n-    }\n+    insn_16_p = TRUE;\n \n   /* 16 bit instruction.  */\n   if (insn_16_p)\n     {\n       if (little)\n-        {\n-          given = b[0] | (b[1] << 8);\n-        }\n+\tgiven = b[0] | (b[1] << 8);\n       else\n-        {\n-          given = (b[0] << 8) | b[1];\n-        }\n+\tgiven = (b[0] << 8) | b[1];\n \n       status = print_insn_score16 (pc, info, given);\n     }\n@@ -953,7 +940,8 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n       status = print_insn_score16 (pc, info, given);\n       print_insn_parallel_sym (info);\n       status += print_insn_score16 (pc, info, other);\n-      /* disassemble_bytes() will output 4 byte per chunk for pce instructio.  */\n+      /* disassemble_bytes() will output 4 byte per chunk for pce\n+\t instruction.  */\n       info->bytes_per_chunk = 4;\n     }\n   /* 32 bit instruction.  */\n@@ -968,5 +956,3 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n \n   return status;\n }\n-\n-/*****************************************************************************/"
    }
  ]
}