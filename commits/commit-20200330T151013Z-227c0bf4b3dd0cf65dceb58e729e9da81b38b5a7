{
  "sha": "227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjI3YzBiZjRiM2RkMGNmNjVkY2ViNThlNzI5ZTlkYTgxYjM4YjVhNw==",
  "commit": {
    "author": {
      "name": "Pedro Franco de Carvalho",
      "email": "pedromfc@linux.ibm.com",
      "date": "2020-03-30T15:04:25Z"
    },
    "committer": {
      "name": "Pedro Franco de Carvalho",
      "email": "pedromfc@linux.ibm.com",
      "date": "2020-03-30T15:10:13Z"
    },
    "message": "[PowerPC] Fix debug register issues in ppc-linux-nat\n\nThis patch fixes some issues with debug register handling for the powerpc\nlinux native target.\n\nCurrently, the target methods for installing and removing hardware\nbreakpoints and watchpoints in ppc-linux-nat.c affect all threads known to\nlinux-nat, including threads of different processes.\n\nThis patch changes ppc-linux-nat.c so that only the process of\ninferior_ptid is affected by these target methods, as GDB expects.\n\nThis is done in the same way as various other architectures.  The\ninstall/remove target methods only register a hardware breakpoint or\nwatchpoint, and then send a stop signal to the threads.  The debug\nregisters are only changed with ptrace right before each thread is next\nresumed, using low_prepare_to_resume.\n\nThere are two interfaces to modify debug registers for linux running on\npowerpc, with different sets of ptrace requests:\n\n- PPC_PTRACE_GETHWDBGINFO, PPC_PTRACE_SETHWDEBUG, and\n  PPC_PTRACE_DELHWDEBUG.\n\n   Or\n\n- PTRACE_SET_DEBUGREG and PTRACE_GET_DEBUGREG\n\nThe first set (HWDEBUG) is the more flexible one and allows setting\nwatchpoints with a variable watched region length and, for certain\nembedded processors, multiple types of debug registers (e.g. hardware\nbreakpoints and hardware-assisted conditions for watchpoints).\nCurrently, server processors only provide one watchpoint.  The second one\n(DEBUGREG) only allows setting one debug register, a watchpoint, so we\nonly use it if the first one is not available.\n\nThe HWDEBUG interface handles debug registers with slot numbers.  Once a\nhardware watchpoint or breakpoint is installed (with\nPPC_PTRACE_SETHWDEBUG), ptrace returns a slot number.  This slot number\ncan then be used to remove the watchpoint or breakpoint from the inferior\n(with PPC_PTRACE_DELHWDEBUG).  The first interface also provides a\nbitmask of available debug register features, which can be obtained with\nPPC_PTRACE_GETHWDBGINFO.\n\nWhen GDB first tries to use debug registers, we try the first interface\nwith a ptrace call, and if it isn't available, we fall back to the second\none, if available.  We use EIO as an indicator that an interface is not\navailable in the kernel.  For simplicity, with any other error we\nimmediately assume no interface is available.  Unfortunately this means\nthat if a process is killed by a signal right before we try to detect the\ninterface, we might get an ESRCH, which would prevent debug registers to\nbe used in the GDB session.  However, it isn't clear that we can safely\nraise an exception and try again in the future in all the contexts where\nwe try to detect the interface.\n\nIf the HWDEBUG interface works but provides no feature bits, the target\nfalls back to the DEBUGREG interface.  When the kernel is configured\nwithout CONFIG_HW_BREAKPOINTS (selected by CONFIG_PERF_EVENTS), there is\na bug that causes watchpoints installed with the HWDEBUG interface not to\ntrigger.  When this is the case, the feature bits will be zero, which is\nused as the indicator to fall back to the DEBUGREG interface.  This isn't\nideal, but has always been the behavior of GDB before this patch, so I\ndecided not to change it.\n\nA flag indicates for each thread if its debug registers need to be\nupdated the next time it is resumed.  The flag is set whenever the upper\nlayers request or remove a hardware watchpoint or breakpoint, or when a\nnew thread is detected.  Because some kernel configurations disable\nwatchpoints after they are hit, we also use the last stop reason of the\nLWP to determine whether we should update the debug registers.  It isn't\nclear that this is also true of BookE hardware breakpoints, but we also\ncheck their stop reason to be on the safe side, since it doesn't hurt.\n\nA map from process numbers to hardware watchpoint or breakpoint objects\nkeeps track of what has been requested by the upper layers of GDB, since\nfor GDB installing a hardware watchpoint or breakpoint means doing so for\nthe whole process.\n\nWhen using the HWDEBUG interface we also have to keep track of which\nslots were last installed in each thread with a map from threads to the\nslots, so that they can be removed when needed.  When resuming a thread,\nwe remove all the slots using this map, then we install all the hardware\nwatchpoints and breakpoints from the per-process map of requests, and\nthen update the per-thread map accordingly.\n\nThis per-thread state is also used for copying the debug register state\nafter a fork or a clone is detected.  The kernel might do this depending\non the configuration.  Recent kernels running on server processors that\nwere configured with CONFIG_PERF_EVENTS (and therefore\nCONFIG_HW_BREAKPOINTS) don't copy debug registers across forks and\nclones.  Recent kernels without CONFIG_HW_BREAKPOINTS copy this state.  I\nbelieve that on embedded processors (e.g. a ppc440) the debug register\nstate is copied, but I haven't been able to test this.  To handle both\ncases, the per-thread state is always copied when forks and clones are\ndetected, and when we resume the thread and delete the debug register\nslots before updating them, we ignore ENOENT errors.\n\nWe don't need to handle this when using the DEBUGREG interface since it\nonly allows one hardware watchpoint and doesn't return slot numbers, we\njust set or clear this watchpoint when needed.\n\nSince we signal running threads to stop after a request is processed, so\nthat we can update their debug registers when they are next resumed,\nthere will be a time between signalling the threads and their stop during\nwhich the debug registers haven't been updated, even if the target\nmethods completed.\n\nThe tests in gdb.threads/watchpoint-fork.exp no longer fail with this\npatch.\n\ngdb/ChangeLog:\n2020-03-30  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n\n\t* ppc-linux-nat.c: Include <algorithm>, <unordered_map>, and\n\t<list>.  Remove inclusion of observable.h.\n\t(PPC_DEBUG_CURRENT_VERSION): Move up define.\n\t(struct arch_lwp_info): New struct.\n\t(class ppc_linux_dreg_interface): New class.\n\t(struct ppc_linux_process_info): New struct.\n\t(struct ppc_linux_nat_target) <low_delete_thread, low_new_fork>\n\t<low_new_clone, low_forget_process, low_prepare_to_resume>\n\t<copy_thread_dreg_state, mark_thread_stale>\n\t<mark_debug_registers_changed, register_hw_breakpoint>\n\t<clear_hw_breakpoint, register_wp, clear_wp>\n\t<can_use_watchpoint_cond_accel, calculate_dvc, check_condition>\n\t<num_memory_accesses, get_trigger_type>\n\t<create_watchpoint_request, hwdebug_point_cmp>\n\t<init_arch_lwp_info, get_arch_lwp_info>\n\t<low_stopped_by_watchpoint, low_stopped_data_address>: Declare as\n\tmethods.\n\t<struct ptid_hash>: New inner struct.\n\t<m_dreg_interface, m_process_info, m_installed_hw_bps>: Declare\n\tmembers.\n\t(saved_dabr_value, hwdebug_info, max_slots_number)\n\t(struct hw_break_tuple, struct thread_points, ppc_threads)\n\t(have_ptrace_hwdebug_interface)\n\t(hwdebug_find_thread_points_by_tid)\n\t(hwdebug_insert_point, hwdebug_remove_point): Remove.\n\t(ppc_linux_nat_target::can_use_hw_breakpoint): Use\n\tm_dreg_interface, remove call to PTRACE_SET_DEBUGREG.\n\t(ppc_linux_nat_target::region_ok_for_hw_watchpoint): Add comment,\n\tuse m_dreg_interface.\n\t(hwdebug_point_cmp): Change to...\n\t(ppc_linux_nat_target::hwdebug_point_cmp): ...this method.  Use\n\treference arguments instead of pointers.\n\t(ppc_linux_nat_target::ranged_break_num_registers): Use\n\tm_dreg_interface.\n\t(ppc_linux_nat_target::insert_hw_breakpoint): Add comment, use\n\tm_dreg_interface.  Call register_hw_breakpoint.\n\t(ppc_linux_nat_target::remove_hw_breakpoint): Add comment, use\n\tm_dreg_interface.  Call clear_hw_breakpoint.\n\t(get_trigger_type): Change to...\n\t(ppc_linux_nat_target::get_trigger_type): ...this method.  Add\n\tcomment.\n\t(ppc_linux_nat_target::insert_mask_watchpoint): Update comment,\n\tuse m_dreg_interface.  Call register_hw_breakpoint.\n\t(ppc_linux_nat_target::remove_mask_watchpoint): Update comment,\n\tuse m_dreg_interface.  Call clear_hw_breakpoint.\n\t(can_use_watchpoint_cond_accel): Change to...\n\t(ppc_linux_nat_target::can_use_watchpoint_cond_accel): ...this\n\tmethod.  Update comment, use m_dreg_interface and\n\tm_process_info.\n\t(calculate_dvc): Change to...\n\t(ppc_linux_nat_target::calculate_dvc): ...this method.  Use\n\tm_dreg_interface.\n\t(num_memory_accesses): Change to...\n\t(ppc_linux_nat_target::num_memory_accesses): ...this method.\n\t(check_condition): Change to...\n\t(ppc_linux_nat_target::check_condition): ...this method.\n\t(ppc_linux_nat_target::can_accel_watchpoint_condition): Update\n\tcomment, use m_dreg_interface.\n\t(create_watchpoint_request): Change to...\n\t(ppc_linux_nat_target::create_watchpoint_request): ...this\n\tmethod.  Use m_dreg_interface.\n\t(ppc_linux_nat_target::insert_watchpoint): Add comment, use\n\tm_dreg_interface.  Call register_hw_breakpoint or register_wp.\n\t(ppc_linux_nat_target::remove_watchpoint): Add comment, use\n\tm_dreg_interface.  Call clear_hw_breakpoint or clear_wp.\n\t(ppc_linux_nat_target::low_forget_process)\n\t(ppc_linux_nat_target::low_new_fork)\n\t(ppc_linux_nat_target::low_new_clone)\n\t(ppc_linux_nat_target::low_delete_thread)\n\t(ppc_linux_nat_target::low_prepare_to_resume): New methods.\n\t(ppc_linux_nat_target::low_new_thread): Remove previous logic,\n\tonly call mark_thread_stale.\n\t(ppc_linux_thread_exit): Remove.\n\t(ppc_linux_nat_target::stopped_data_address): Change to...\n\t(ppc_linux_nat_target::low_stopped_data_address): This. Add\n\tcomment, use m_dreg_interface and m_thread_hw_breakpoints.\n\t(ppc_linux_nat_target::stopped_by_watchpoint): Change to...\n\t(ppc_linux_nat_target::stopped_by_watchpoint): This.  Add\n\tcomment.  Call low_stopped_data_address.\n\t(ppc_linux_nat_target::watchpoint_addr_within_range): Use\n\tm_dreg_interface.\n\t(ppc_linux_nat_target::masked_watch_num_registers): Use\n\tm_dreg_interface.\n\t(ppc_linux_nat_target::copy_thread_dreg_state)\n\t(ppc_linux_nat_target::mark_thread_stale)\n\t(ppc_linux_nat_target::mark_debug_registers_changed)\n\t(ppc_linux_nat_target::register_hw_breakpoint)\n\t(ppc_linux_nat_target::clear_hw_breakpoint)\n\t(ppc_linux_nat_target::register_wp)\n\t(ppc_linux_nat_target::clear_wp)\n\t(ppc_linux_nat_target::init_arch_lwp_info)\n\t(ppc_linux_nat_target::get_arch_lwp_info): New methods.\n\t(_initialize_ppc_linux_nat): Remove observer callback.",
    "tree": {
      "sha": "28f966c4b4b08d2b544d5f2722b04f2b4b6bc2f6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/28f966c4b4b08d2b544d5f2722b04f2b4b6bc2f6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "4db10d8f4911298d06d2bb25927946f66f0f33e3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4db10d8f4911298d06d2bb25927946f66f0f33e3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4db10d8f4911298d06d2bb25927946f66f0f33e3"
    }
  ],
  "stats": {
    "total": 1416,
    "additions": 1020,
    "deletions": 396
  },
  "files": [
    {
      "sha": "203d89c3fb62d24efe141e7eba490eca84fe8ab6",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 96,
      "deletions": 0,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7",
      "patch": "@@ -1,3 +1,99 @@\n+2020-03-30  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n+\n+\t* ppc-linux-nat.c: Include <algorithm>, <unordered_map>, and\n+\t<list>.  Remove inclusion of observable.h.\n+\t(PPC_DEBUG_CURRENT_VERSION): Move up define.\n+\t(struct arch_lwp_info): New struct.\n+\t(class ppc_linux_dreg_interface): New class.\n+\t(struct ppc_linux_process_info): New struct.\n+\t(struct ppc_linux_nat_target) <low_delete_thread, low_new_fork>\n+\t<low_new_clone, low_forget_process, low_prepare_to_resume>\n+\t<copy_thread_dreg_state, mark_thread_stale>\n+\t<mark_debug_registers_changed, register_hw_breakpoint>\n+\t<clear_hw_breakpoint, register_wp, clear_wp>\n+\t<can_use_watchpoint_cond_accel, calculate_dvc, check_condition>\n+\t<num_memory_accesses, get_trigger_type>\n+\t<create_watchpoint_request, hwdebug_point_cmp>\n+\t<init_arch_lwp_info, get_arch_lwp_info>\n+\t<low_stopped_by_watchpoint, low_stopped_data_address>: Declare as\n+\tmethods.\n+\t<struct ptid_hash>: New inner struct.\n+\t<m_dreg_interface, m_process_info, m_installed_hw_bps>: Declare\n+\tmembers.\n+\t(saved_dabr_value, hwdebug_info, max_slots_number)\n+\t(struct hw_break_tuple, struct thread_points, ppc_threads)\n+\t(have_ptrace_hwdebug_interface)\n+\t(hwdebug_find_thread_points_by_tid)\n+\t(hwdebug_insert_point, hwdebug_remove_point): Remove.\n+\t(ppc_linux_nat_target::can_use_hw_breakpoint): Use\n+\tm_dreg_interface, remove call to PTRACE_SET_DEBUGREG.\n+\t(ppc_linux_nat_target::region_ok_for_hw_watchpoint): Add comment,\n+\tuse m_dreg_interface.\n+\t(hwdebug_point_cmp): Change to...\n+\t(ppc_linux_nat_target::hwdebug_point_cmp): ...this method.  Use\n+\treference arguments instead of pointers.\n+\t(ppc_linux_nat_target::ranged_break_num_registers): Use\n+\tm_dreg_interface.\n+\t(ppc_linux_nat_target::insert_hw_breakpoint): Add comment, use\n+\tm_dreg_interface.  Call register_hw_breakpoint.\n+\t(ppc_linux_nat_target::remove_hw_breakpoint): Add comment, use\n+\tm_dreg_interface.  Call clear_hw_breakpoint.\n+\t(get_trigger_type): Change to...\n+\t(ppc_linux_nat_target::get_trigger_type): ...this method.  Add\n+\tcomment.\n+\t(ppc_linux_nat_target::insert_mask_watchpoint): Update comment,\n+\tuse m_dreg_interface.  Call register_hw_breakpoint.\n+\t(ppc_linux_nat_target::remove_mask_watchpoint): Update comment,\n+\tuse m_dreg_interface.  Call clear_hw_breakpoint.\n+\t(can_use_watchpoint_cond_accel): Change to...\n+\t(ppc_linux_nat_target::can_use_watchpoint_cond_accel): ...this\n+\tmethod.  Update comment, use m_dreg_interface and\n+\tm_process_info.\n+\t(calculate_dvc): Change to...\n+\t(ppc_linux_nat_target::calculate_dvc): ...this method.  Use\n+\tm_dreg_interface.\n+\t(num_memory_accesses): Change to...\n+\t(ppc_linux_nat_target::num_memory_accesses): ...this method.\n+\t(check_condition): Change to...\n+\t(ppc_linux_nat_target::check_condition): ...this method.\n+\t(ppc_linux_nat_target::can_accel_watchpoint_condition): Update\n+\tcomment, use m_dreg_interface.\n+\t(create_watchpoint_request): Change to...\n+\t(ppc_linux_nat_target::create_watchpoint_request): ...this\n+\tmethod.  Use m_dreg_interface.\n+\t(ppc_linux_nat_target::insert_watchpoint): Add comment, use\n+\tm_dreg_interface.  Call register_hw_breakpoint or register_wp.\n+\t(ppc_linux_nat_target::remove_watchpoint): Add comment, use\n+\tm_dreg_interface.  Call clear_hw_breakpoint or clear_wp.\n+\t(ppc_linux_nat_target::low_forget_process)\n+\t(ppc_linux_nat_target::low_new_fork)\n+\t(ppc_linux_nat_target::low_new_clone)\n+\t(ppc_linux_nat_target::low_delete_thread)\n+\t(ppc_linux_nat_target::low_prepare_to_resume): New methods.\n+\t(ppc_linux_nat_target::low_new_thread): Remove previous logic,\n+\tonly call mark_thread_stale.\n+\t(ppc_linux_thread_exit): Remove.\n+\t(ppc_linux_nat_target::stopped_data_address): Change to...\n+\t(ppc_linux_nat_target::low_stopped_data_address): This. Add\n+\tcomment, use m_dreg_interface and m_thread_hw_breakpoints.\n+\t(ppc_linux_nat_target::stopped_by_watchpoint): Change to...\n+\t(ppc_linux_nat_target::stopped_by_watchpoint): This.  Add\n+\tcomment.  Call low_stopped_data_address.\n+\t(ppc_linux_nat_target::watchpoint_addr_within_range): Use\n+\tm_dreg_interface.\n+\t(ppc_linux_nat_target::masked_watch_num_registers): Use\n+\tm_dreg_interface.\n+\t(ppc_linux_nat_target::copy_thread_dreg_state)\n+\t(ppc_linux_nat_target::mark_thread_stale)\n+\t(ppc_linux_nat_target::mark_debug_registers_changed)\n+\t(ppc_linux_nat_target::register_hw_breakpoint)\n+\t(ppc_linux_nat_target::clear_hw_breakpoint)\n+\t(ppc_linux_nat_target::register_wp)\n+\t(ppc_linux_nat_target::clear_wp)\n+\t(ppc_linux_nat_target::init_arch_lwp_info)\n+\t(ppc_linux_nat_target::get_arch_lwp_info): New methods.\n+\t(_initialize_ppc_linux_nat): Remove observer callback.\n+\n 2020-03-30  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n \n \t* ppc-linux-nat.c (ppc_linux_nat_target::store_registers)"
    },
    {
      "sha": "6be8f022a7b0ec00f631a614ed15f55406bc7e06",
      "filename": "gdb/ppc-linux-nat.c",
      "status": "modified",
      "additions": 924,
      "deletions": 396,
      "changes": 1320,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7/gdb/ppc-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7/gdb/ppc-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-nat.c?ref=227c0bf4b3dd0cf65dceb58e729e9da81b38b5a7",
      "patch": "@@ -18,7 +18,6 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n-#include \"observable.h\"\n #include \"frame.h\"\n #include \"inferior.h\"\n #include \"gdbthread.h\"\n@@ -38,6 +37,9 @@\n #include \"nat/gdb_ptrace.h\"\n #include \"nat/linux-ptrace.h\"\n #include \"inf-ptrace.h\"\n+#include <algorithm>\n+#include <unordered_map>\n+#include <list>\n \n /* Prototypes for supply_gregset etc.  */\n #include \"gregset.h\"\n@@ -136,6 +138,10 @@ struct ppc_hw_breakpoint\n #define PPC_DEBUG_FEATURE_DATA_BP_DAWR\t0x10\n #endif /* PPC_DEBUG_FEATURE_DATA_BP_DAWR */\n \n+/* The version of the PowerPC HWDEBUG kernel interface that we will use, if\n+   available.  */\n+#define PPC_DEBUG_CURRENT_VERSION 1\n+\n /* Similarly for the general-purpose (gp0 -- gp31)\n    and floating-point registers (fp0 -- fp31).  */\n #ifndef PTRACE_GETREGS\n@@ -270,6 +276,214 @@ int have_ptrace_getsetregs = 1;\n    them and gotten an error.  */\n int have_ptrace_getsetfpregs = 1;\n \n+/* Private arch info associated with each thread lwp_info object, used\n+   for debug register handling.  */\n+\n+struct arch_lwp_info\n+{\n+  /* When true, indicates that the debug registers installed in the\n+     thread no longer correspond to the watchpoints and breakpoints\n+     requested by GDB.  */\n+  bool debug_regs_stale;\n+\n+  /* We need a back-reference to the PTID of the thread so that we can\n+     cleanup the debug register state of the thread in\n+     low_delete_thread.  */\n+  ptid_t lwp_ptid;\n+};\n+\n+/* Class used to detect which set of ptrace requests that\n+   ppc_linux_nat_target will use to install and remove hardware\n+   breakpoints and watchpoints.\n+\n+   The interface is only detected once, testing the ptrace calls.  The\n+   result can indicate that no interface is available.\n+\n+   The Linux kernel provides two different sets of ptrace requests to\n+   handle hardware watchpoints and breakpoints for Power:\n+\n+   - PPC_PTRACE_GETHWDBGINFO, PPC_PTRACE_SETHWDEBUG, and\n+     PPC_PTRACE_DELHWDEBUG.\n+\n+   Or\n+\n+   - PTRACE_SET_DEBUGREG and PTRACE_GET_DEBUGREG\n+\n+   The first set is the more flexible one and allows setting watchpoints\n+   with a variable watched region length and, for BookE processors,\n+   multiple types of debug registers (e.g. hardware breakpoints and\n+   hardware-assisted conditions for watchpoints).  The second one only\n+   allows setting one debug register, a watchpoint, so we only use it if\n+   the first one is not available.  */\n+\n+class ppc_linux_dreg_interface\n+{\n+public:\n+\n+  ppc_linux_dreg_interface ()\n+    : m_interface (), m_hwdebug_info ()\n+  {\n+  };\n+\n+  DISABLE_COPY_AND_ASSIGN (ppc_linux_dreg_interface);\n+\n+  /* One and only one of these three functions returns true, indicating\n+     whether the corresponding interface is the one we detected.  The\n+     interface must already have been detected as a precontidion.  */\n+\n+  bool hwdebug_p ()\n+  {\n+    gdb_assert (detected_p ());\n+    return *m_interface == HWDEBUG;\n+  }\n+\n+  bool debugreg_p ()\n+  {\n+    gdb_assert (detected_p ());\n+    return *m_interface == DEBUGREG;\n+  }\n+\n+  bool unavailable_p ()\n+  {\n+    gdb_assert (detected_p ());\n+    return *m_interface == UNAVAILABLE;\n+  }\n+\n+  /* Returns the debug register capabilities of the target.  Should only\n+     be called if the interface is HWDEBUG.  */\n+  const struct ppc_debug_info &hwdebug_info ()\n+  {\n+    gdb_assert (hwdebug_p ());\n+\n+    return m_hwdebug_info;\n+  }\n+\n+  /* Returns true if the interface has already been detected.  This is\n+     useful for cases when we know there is no work to be done if the\n+     interface hasn't been detected yet.  */\n+  bool detected_p ()\n+  {\n+    return m_interface.has_value ();\n+  }\n+\n+  /* Detect the available interface, if any, if it hasn't been detected\n+     before, using PTID for the necessary ptrace calls.  */\n+\n+  void detect (const ptid_t &ptid)\n+  {\n+    if (m_interface.has_value ())\n+      return;\n+\n+    gdb_assert (ptid.lwp_p ());\n+\n+    bool no_features = false;\n+\n+    if (ptrace (PPC_PTRACE_GETHWDBGINFO, ptid.lwp (), 0, &m_hwdebug_info)\n+\t!= -1)\n+      {\n+\t/* If there are no advertised features, we don't use the\n+\t   HWDEBUG interface and try the DEBUGREG interface instead.\n+\t   It shouldn't be necessary to do this, however, when the\n+\t   kernel is configured without CONFIG_HW_BREAKPOINTS (selected\n+\t   by CONFIG_PERF_EVENTS), there is a bug that causes\n+\t   watchpoints installed with the HWDEBUG interface not to\n+\t   trigger.  When this is the case, features will be zero,\n+\t   which we use as an indicator to fall back to the DEBUGREG\n+\t   interface.  */\n+\tif (m_hwdebug_info.features != 0)\n+\t  {\n+\t    m_interface.emplace (HWDEBUG);\n+\t    return;\n+\t  }\n+\telse\n+\t  no_features = true;\n+      }\n+\n+    /* EIO indicates that the request is invalid, so we try DEBUGREG\n+       next.  Technically, it can also indicate other failures, but we\n+       can't differentiate those.\n+\n+       Other errors could happen for various reasons.  We could get an\n+       ESRCH if the traced thread was killed by a signal.  Trying to\n+       detect the interface with another thread in the future would be\n+       complicated, as callers would have to handle an \"unknown\n+       interface\" case.  It's also unclear if raising an exception\n+       here would be safe.\n+\n+       Other errors, such as ENODEV, could be more permanent and cause\n+       a failure for any thread.\n+\n+       For simplicity, with all errors other than EIO, we set the\n+       interface to UNAVAILABLE and don't try DEBUGREG.  If DEBUGREG\n+       fails too, we'll also set the interface to UNAVAILABLE.  It's\n+       unlikely that trying the DEBUGREG interface with this same thread\n+       would work, for errors other than EIO.  This means that these\n+       errors will cause hardware watchpoints and breakpoints to become\n+       unavailable throughout a GDB session.  */\n+\n+    if (no_features || errno == EIO)\n+      {\n+\tunsigned long wp;\n+\n+\tif (ptrace (PTRACE_GET_DEBUGREG, ptid.lwp (), 0, &wp) != -1)\n+\t  {\n+\t    m_interface.emplace (DEBUGREG);\n+\t    return;\n+\t  }\n+      }\n+\n+    if (errno != EIO)\n+      warning (_(\"Error when detecting the debug register interface. \"\n+\t\t \"Debug registers will be unavailable.\"));\n+\n+    m_interface.emplace (UNAVAILABLE);\n+    return;\n+  }\n+\n+private:\n+\n+  /* HWDEBUG represents the set of calls PPC_PTRACE_GETHWDBGINFO,\n+     PPC_PTRACE_SETHWDEBUG and PPC_PTRACE_DELHWDEBUG.\n+\n+     DEBUGREG represents the set of calls PTRACE_SET_DEBUGREG and\n+     PTRACE_GET_DEBUGREG.\n+\n+     UNAVAILABLE can indicate that the kernel doesn't support any of the\n+     two sets of requests or that there was an error when we tried to\n+     detect wich interface is available.  */\n+\n+  enum debug_reg_interface\n+    {\n+     UNAVAILABLE,\n+     HWDEBUG,\n+     DEBUGREG\n+    };\n+\n+  /* The interface option.  Initialized if has_value () returns true.  */\n+  gdb::optional<enum debug_reg_interface> m_interface;\n+\n+  /* The info returned by the kernel with PPC_PTRACE_GETHWDBGINFO.  Only\n+     valid if we determined that the interface is HWDEBUG.  */\n+  struct ppc_debug_info m_hwdebug_info;\n+};\n+\n+/* Per-process information.  This includes the hardware watchpoints and\n+   breakpoints that GDB requested to this target.  */\n+\n+struct ppc_linux_process_info\n+{\n+  /* The list of hardware watchpoints and breakpoints that GDB requested\n+     for this process.\n+\n+     Only used when the interface is HWDEBUG.  */\n+  std::list<struct ppc_hw_breakpoint> requested_hw_bps;\n+\n+  /* The watchpoint value that GDB requested for this process.\n+\n+     Only used when the interface is DEBUGREG.  */\n+  gdb::optional<long> requested_wp_val;\n+};\n+\n struct ppc_linux_nat_target final : public linux_nat_target\n {\n   /* Add our register access methods.  */\n@@ -299,10 +513,6 @@ struct ppc_linux_nat_target final : public linux_nat_target\n   int remove_mask_watchpoint (CORE_ADDR, CORE_ADDR, enum target_hw_bp_type)\n     override;\n \n-  bool stopped_by_watchpoint () override;\n-\n-  bool stopped_data_address (CORE_ADDR *) override;\n-\n   bool watchpoint_addr_within_range (CORE_ADDR, CORE_ADDR, int) override;\n \n   bool can_accel_watchpoint_condition (CORE_ADDR, int, int, struct expression *)\n@@ -319,7 +529,95 @@ struct ppc_linux_nat_target final : public linux_nat_target\n     override;\n \n   /* Override linux_nat_target low methods.  */\n+  bool low_stopped_by_watchpoint () override;\n+\n+  bool low_stopped_data_address (CORE_ADDR *) override;\n+\n   void low_new_thread (struct lwp_info *lp) override;\n+\n+  void low_delete_thread (arch_lwp_info *) override;\n+\n+  void low_new_fork (struct lwp_info *, pid_t) override;\n+\n+  void low_new_clone (struct lwp_info *, pid_t) override;\n+\n+  void low_forget_process (pid_t pid) override;\n+\n+  void low_prepare_to_resume (struct lwp_info *) override;\n+\n+private:\n+\n+  void copy_thread_dreg_state (const ptid_t &parent_ptid,\n+\t\t\t       const ptid_t &child_ptid);\n+\n+  void mark_thread_stale (struct lwp_info *lp);\n+\n+  void mark_debug_registers_changed (pid_t pid);\n+\n+  void register_hw_breakpoint (pid_t pid,\n+\t\t\t       const struct ppc_hw_breakpoint &bp);\n+\n+  void clear_hw_breakpoint (pid_t pid,\n+\t\t\t    const struct ppc_hw_breakpoint &a);\n+\n+  void register_wp (pid_t pid, long wp_value);\n+\n+  void clear_wp (pid_t pid);\n+\n+  bool can_use_watchpoint_cond_accel (void);\n+\n+  void calculate_dvc (CORE_ADDR addr, int len,\n+\t\t      CORE_ADDR data_value,\n+\t\t      uint32_t *condition_mode,\n+\t\t      uint64_t *condition_value);\n+\n+  int check_condition (CORE_ADDR watch_addr,\n+\t\t       struct expression *cond,\n+\t\t       CORE_ADDR *data_value, int *len);\n+\n+  int num_memory_accesses (const std::vector<value_ref_ptr> &chain);\n+\n+  int get_trigger_type (enum target_hw_bp_type type);\n+\n+  void create_watchpoint_request (struct ppc_hw_breakpoint *p,\n+\t\t\t\t  CORE_ADDR addr,\n+\t\t\t\t  int len,\n+\t\t\t\t  enum target_hw_bp_type type,\n+\t\t\t\t  struct expression *cond,\n+\t\t\t\t  int insert);\n+\n+  bool hwdebug_point_cmp (const struct ppc_hw_breakpoint &a,\n+\t\t\t  const struct ppc_hw_breakpoint &b);\n+\n+  void init_arch_lwp_info (struct lwp_info *lp);\n+\n+  arch_lwp_info *get_arch_lwp_info (struct lwp_info *lp);\n+\n+  /* The ptrace interface we'll use to install hardware watchpoints and\n+     breakpoints (debug registers).  */\n+  ppc_linux_dreg_interface m_dreg_interface;\n+\n+  /* A map from pids to structs containing info specific to each\n+     process.  */\n+  std::unordered_map<pid_t, ppc_linux_process_info> m_process_info;\n+\n+  /* Callable object to hash ptids by their lwp number.  */\n+  struct ptid_hash\n+  {\n+    std::size_t operator() (const ptid_t &ptid) const\n+    {\n+      return std::hash<long>{} (ptid.lwp ());\n+    }\n+  };\n+\n+  /* A map from ptid_t objects to a list of pairs of slots and hardware\n+     breakpoint objects.  This keeps track of which hardware breakpoints\n+     and watchpoints were last installed in each slot of each thread.\n+\n+     Only used when the interface is HWDEBUG.  */\n+  std::unordered_map <ptid_t,\n+\t\t      std::list<std::pair<long, ppc_hw_breakpoint>>,\n+\t\t      ptid_hash> m_installed_hw_bps;\n };\n \n static ppc_linux_nat_target the_ppc_linux_nat_target;\n@@ -1719,155 +2017,101 @@ ppc_linux_nat_target::read_description ()\n   return ppc_linux_match_description (features);\n }\n \n-/* The cached DABR value, to install in new threads.\n-   This variable is used when the PowerPC HWDEBUG ptrace\n-   interface is not available.  */\n-static long saved_dabr_value;\n-\n-/* Global structure that will store information about the available\n-   features provided by the PowerPC HWDEBUG ptrace interface.  */\n-static struct ppc_debug_info hwdebug_info;\n-\n-/* Global variable that holds the maximum number of slots that the\n-   kernel will use.  This is only used when PowerPC HWDEBUG ptrace interface\n-   is available.  */\n-static size_t max_slots_number = 0;\n-\n-struct hw_break_tuple\n-{\n-  long slot;\n-  struct ppc_hw_breakpoint *hw_break;\n-};\n-\n-/* This is an internal vector created to store information about *points\n-   inserted for each thread.  This is used when PowerPC HWDEBUG ptrace\n-   interface is available.  */\n-struct thread_points\n-  {\n-    /* The TID to which this *point relates.  */\n-    int tid;\n-    /* Information about the *point, such as its address, type, etc.\n-\n-       Each element inside this vector corresponds to a hardware\n-       breakpoint or watchpoint in the thread represented by TID.  The maximum\n-       size of these vector is MAX_SLOTS_NUMBER.  If the hw_break element of\n-       the tuple is NULL, then the position in the vector is free.  */\n-    struct hw_break_tuple *hw_breaks;\n-  };\n-\n-static std::vector<thread_points *> ppc_threads;\n-\n-/* The version of the PowerPC HWDEBUG kernel interface that we will use, if\n-   available.  */\n-#define PPC_DEBUG_CURRENT_VERSION 1\n-\n-/* Returns non-zero if we support the PowerPC HWDEBUG ptrace interface.  */\n-static int\n-have_ptrace_hwdebug_interface (void)\n-{\n-  static int have_ptrace_hwdebug_interface = -1;\n-\n-  if (have_ptrace_hwdebug_interface == -1)\n-    {\n-      int tid;\n-\n-      tid = inferior_ptid.lwp ();\n-      if (tid == 0)\n-\ttid = inferior_ptid.pid ();\n-\n-      /* Check for kernel support for PowerPC HWDEBUG ptrace interface.  */\n-      if (ptrace (PPC_PTRACE_GETHWDBGINFO, tid, 0, &hwdebug_info) >= 0)\n-\t{\n-\t  /* Check whether PowerPC HWDEBUG ptrace interface is functional and\n-\t     provides any supported feature.  */\n-\t  if (hwdebug_info.features != 0)\n-\t    {\n-\t      have_ptrace_hwdebug_interface = 1;\n-\t      max_slots_number = hwdebug_info.num_instruction_bps\n-\t        + hwdebug_info.num_data_bps\n-\t        + hwdebug_info.num_condition_regs;\n-\t      return have_ptrace_hwdebug_interface;\n-\t    }\n-\t}\n-      /* Old school interface and no PowerPC HWDEBUG ptrace support.  */\n-      have_ptrace_hwdebug_interface = 0;\n-      memset (&hwdebug_info, 0, sizeof (struct ppc_debug_info));\n-    }\n-\n-  return have_ptrace_hwdebug_interface;\n-}\n+/* Routines for installing hardware watchpoints and breakpoints.  When\n+   GDB requests a hardware watchpoint or breakpoint to be installed, we\n+   register the request for the pid of inferior_ptid in a map with one\n+   entry per process.  We then issue a stop request to all the threads of\n+   this process, and mark a per-thread flag indicating that their debug\n+   registers should be updated.  Right before they are next resumed, we\n+   remove all previously installed debug registers and install all the\n+   ones GDB requested.  We then update a map with one entry per thread\n+   that keeps track of what debug registers were last installed in each\n+   thread.\n+\n+   We use this second map to remove installed registers before installing\n+   the ones requested by GDB, and to copy the debug register state after\n+   a thread clones or forks, since depending on the kernel configuration,\n+   debug registers can be inherited.  */\n+\n+/* Check if we support and have enough resources to install a hardware\n+   watchpoint or breakpoint.  See the description in target.h.  */\n \n int\n-ppc_linux_nat_target::can_use_hw_breakpoint (enum bptype type, int cnt, int ot)\n+ppc_linux_nat_target::can_use_hw_breakpoint (enum bptype type, int cnt,\n+\t\t\t\t\t     int ot)\n {\n   int total_hw_wp, total_hw_bp;\n \n-  if (have_ptrace_hwdebug_interface ())\n+  m_dreg_interface.detect (inferior_ptid);\n+\n+  if (m_dreg_interface.unavailable_p ())\n+    return 0;\n+\n+  if (m_dreg_interface.hwdebug_p ())\n     {\n       /* When PowerPC HWDEBUG ptrace interface is available, the number of\n \t available hardware watchpoints and breakpoints is stored at the\n \t hwdebug_info struct.  */\n-      total_hw_bp = hwdebug_info.num_instruction_bps;\n-      total_hw_wp = hwdebug_info.num_data_bps;\n+      total_hw_bp = m_dreg_interface.hwdebug_info ().num_instruction_bps;\n+      total_hw_wp = m_dreg_interface.hwdebug_info ().num_data_bps;\n     }\n   else\n     {\n-      /* When we do not have PowerPC HWDEBUG ptrace interface, we should\n-\t consider having 1 hardware watchpoint and no hardware breakpoints.  */\n+      gdb_assert (m_dreg_interface.debugreg_p ());\n+\n+      /* With the DEBUGREG ptrace interface, we should consider having 1\n+\t hardware watchpoint and no hardware breakpoints.  */\n       total_hw_bp = 0;\n       total_hw_wp = 1;\n     }\n \n   if (type == bp_hardware_watchpoint || type == bp_read_watchpoint\n       || type == bp_access_watchpoint || type == bp_watchpoint)\n     {\n-      if (cnt + ot > total_hw_wp)\n+      if (total_hw_wp == 0)\n+\treturn 0;\n+      else if (cnt + ot > total_hw_wp)\n \treturn -1;\n+      else\n+\treturn 1;\n     }\n   else if (type == bp_hardware_breakpoint)\n     {\n       if (total_hw_bp == 0)\n-\t{\n-\t  /* No hardware breakpoint support. */\n-\t  return 0;\n-\t}\n-      if (cnt > total_hw_bp)\n-\treturn -1;\n-    }\n-\n-  if (!have_ptrace_hwdebug_interface ())\n-    {\n-      int tid;\n-      ptid_t ptid = inferior_ptid;\n-\n-      /* We need to know whether ptrace supports PTRACE_SET_DEBUGREG\n-\t and whether the target has DABR.  If either answer is no, the\n-\t ptrace call will return -1.  Fail in that case.  */\n-      tid = ptid.lwp ();\n-      if (tid == 0)\n-\ttid = ptid.pid ();\n-\n-      if (ptrace (PTRACE_SET_DEBUGREG, tid, 0, 0) == -1)\n \treturn 0;\n+      else if (cnt > total_hw_bp)\n+\treturn -1;\n+      else\n+\treturn 1;\n     }\n \n-  return 1;\n+  return 0;\n }\n \n+/* Returns 1 if we can watch LEN bytes at address ADDR, 0 otherwise.  */\n+\n int\n ppc_linux_nat_target::region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)\n {\n   /* Handle sub-8-byte quantities.  */\n   if (len <= 0)\n     return 0;\n \n+  m_dreg_interface.detect (inferior_ptid);\n+\n+  if (m_dreg_interface.unavailable_p ())\n+    return 0;\n+\n   /* The PowerPC HWDEBUG ptrace interface tells if there are alignment\n      restrictions for watchpoints in the processors.  In that case, we use that\n      information to determine the hardcoded watchable region for\n      watchpoints.  */\n-  if (have_ptrace_hwdebug_interface ())\n+  if (m_dreg_interface.hwdebug_p ())\n     {\n       int region_size;\n+      const struct ppc_debug_info &hwdebug_info = (m_dreg_interface\n+\t\t\t\t\t\t   .hwdebug_info ());\n+\n       /* Embedded DAC-based processors, like the PowerPC 440 have ranged\n \t watchpoints and can watch any access within an arbitrary memory\n \t region. This is useful to watch arrays and structs, for instance.  It\n@@ -1894,144 +2138,61 @@ ppc_linux_nat_target::region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)\n      ptrace interface, DAC-based processors (i.e., embedded processors) will\n      use addresses aligned to 4-bytes due to the way the read/write flags are\n      passed in the old ptrace interface.  */\n-  else if (((linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n-\t   && (addr + len) > (addr & ~3) + 4)\n-\t   || (addr + len) > (addr & ~7) + 8)\n-    return 0;\n-\n-  return 1;\n-}\n-\n-/* This function compares two ppc_hw_breakpoint structs field-by-field.  */\n-static int\n-hwdebug_point_cmp (struct ppc_hw_breakpoint *a, struct ppc_hw_breakpoint *b)\n-{\n-  return (a->trigger_type == b->trigger_type\n-\t  && a->addr_mode == b->addr_mode\n-\t  && a->condition_mode == b->condition_mode\n-\t  && a->addr == b->addr\n-\t  && a->addr2 == b->addr2\n-\t  && a->condition_value == b->condition_value);\n-}\n-\n-/* This function can be used to retrieve a thread_points by the TID of the\n-   related process/thread.  If nothing has been found, and ALLOC_NEW is 0,\n-   it returns NULL.  If ALLOC_NEW is non-zero, a new thread_points for the\n-   provided TID will be created and returned.  */\n-static struct thread_points *\n-hwdebug_find_thread_points_by_tid (int tid, int alloc_new)\n-{\n-  for (thread_points *t : ppc_threads)\n-    {\n-      if (t->tid == tid)\n-\treturn t;\n-    }\n-\n-  struct thread_points *t = NULL;\n-\n-  /* Do we need to allocate a new point_item\n-     if the wanted one does not exist?  */\n-  if (alloc_new)\n+  else\n     {\n-      t = XNEW (struct thread_points);\n-      t->hw_breaks = XCNEWVEC (struct hw_break_tuple, max_slots_number);\n-      t->tid = tid;\n-      ppc_threads.push_back (t);\n-    }\n-\n-  return t;\n-}\n-\n-/* This function is a generic wrapper that is responsible for inserting a\n-   *point (i.e., calling `ptrace' in order to issue the request to the\n-   kernel) and registering it internally in GDB.  */\n-static void\n-hwdebug_insert_point (struct ppc_hw_breakpoint *b, int tid)\n-{\n-  int i;\n-  long slot;\n-  gdb::unique_xmalloc_ptr<ppc_hw_breakpoint> p (XDUP (ppc_hw_breakpoint, b));\n-  struct hw_break_tuple *hw_breaks;\n-  struct thread_points *t;\n+      gdb_assert (m_dreg_interface.debugreg_p ());\n \n-  errno = 0;\n-  slot = ptrace (PPC_PTRACE_SETHWDEBUG, tid, 0, p.get ());\n-  if (slot < 0)\n-    perror_with_name (_(\"Unexpected error setting breakpoint or watchpoint\"));\n-\n-  /* Everything went fine, so we have to register this *point.  */\n-  t = hwdebug_find_thread_points_by_tid (tid, 1);\n-  gdb_assert (t != NULL);\n-  hw_breaks = t->hw_breaks;\n-\n-  /* Find a free element in the hw_breaks vector.  */\n-  for (i = 0; i < max_slots_number; i++)\n-    {\n-      if (hw_breaks[i].hw_break == NULL)\n-\t{\n-\t  hw_breaks[i].slot = slot;\n-\t  hw_breaks[i].hw_break = p.release ();\n-\t  break;\n-\t}\n+      if (((linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n+\t   && (addr + len) > (addr & ~3) + 4)\n+\t  || (addr + len) > (addr & ~7) + 8)\n+\treturn 0;\n     }\n \n-  gdb_assert (i != max_slots_number);\n+  return 1;\n }\n \n-/* This function is a generic wrapper that is responsible for removing a\n-   *point (i.e., calling `ptrace' in order to issue the request to the\n-   kernel), and unregistering it internally at GDB.  */\n-static void\n-hwdebug_remove_point (struct ppc_hw_breakpoint *b, int tid)\n-{\n-  int i;\n-  struct hw_break_tuple *hw_breaks;\n-  struct thread_points *t;\n-\n-  t = hwdebug_find_thread_points_by_tid (tid, 0);\n-  gdb_assert (t != NULL);\n-  hw_breaks = t->hw_breaks;\n+/* This function compares two ppc_hw_breakpoint structs\n+   field-by-field.  */\n \n-  for (i = 0; i < max_slots_number; i++)\n-    if (hw_breaks[i].hw_break && hwdebug_point_cmp (hw_breaks[i].hw_break, b))\n-      break;\n-\n-  gdb_assert (i != max_slots_number);\n-\n-  /* We have to ignore ENOENT errors because the kernel implements hardware\n-     breakpoints/watchpoints as \"one-shot\", that is, they are automatically\n-     deleted when hit.  */\n-  errno = 0;\n-  if (ptrace (PPC_PTRACE_DELHWDEBUG, tid, 0, hw_breaks[i].slot) < 0)\n-    if (errno != ENOENT)\n-      perror_with_name (_(\"Unexpected error deleting \"\n-\t\t\t  \"breakpoint or watchpoint\"));\n-\n-  xfree (hw_breaks[i].hw_break);\n-  hw_breaks[i].hw_break = NULL;\n+bool\n+ppc_linux_nat_target::hwdebug_point_cmp (const struct ppc_hw_breakpoint &a,\n+\t\t\t\t\t const struct ppc_hw_breakpoint &b)\n+{\n+  return (a.trigger_type == b.trigger_type\n+\t  && a.addr_mode == b.addr_mode\n+\t  && a.condition_mode == b.condition_mode\n+\t  && a.addr == b.addr\n+\t  && a.addr2 == b.addr2\n+\t  && a.condition_value == b.condition_value);\n }\n \n /* Return the number of registers needed for a ranged breakpoint.  */\n \n int\n ppc_linux_nat_target::ranged_break_num_registers ()\n {\n-  return ((have_ptrace_hwdebug_interface ()\n-\t   && hwdebug_info.features & PPC_DEBUG_FEATURE_INSN_BP_RANGE)?\n+  m_dreg_interface.detect (inferior_ptid);\n+\n+  return ((m_dreg_interface.hwdebug_p ()\n+\t   && (m_dreg_interface.hwdebug_info ().features\n+\t       & PPC_DEBUG_FEATURE_INSN_BP_RANGE))?\n \t  2 : -1);\n }\n \n-/* Insert the hardware breakpoint described by BP_TGT.  Returns 0 for\n-   success, 1 if hardware breakpoints are not supported or -1 for failure.  */\n+/* Register the hardware breakpoint described by BP_TGT, to be inserted\n+   when the threads of inferior_ptid are resumed.  Returns 0 for success,\n+   or -1 if the HWDEBUG interface that we need for hardware breakpoints\n+   is not available.  */\n \n int\n ppc_linux_nat_target::insert_hw_breakpoint (struct gdbarch *gdbarch,\n \t\t\t\t\t    struct bp_target_info *bp_tgt)\n {\n-  struct lwp_info *lp;\n   struct ppc_hw_breakpoint p;\n \n-  if (!have_ptrace_hwdebug_interface ())\n+  m_dreg_interface.detect (inferior_ptid);\n+\n+  if (!m_dreg_interface.hwdebug_p ())\n     return -1;\n \n   p.version = PPC_DEBUG_CURRENT_VERSION;\n@@ -2054,20 +2215,25 @@ ppc_linux_nat_target::insert_hw_breakpoint (struct gdbarch *gdbarch,\n       p.addr2 = 0;\n     }\n \n-  ALL_LWPS (lp)\n-    hwdebug_insert_point (&p, lp->ptid.lwp ());\n+  register_hw_breakpoint (inferior_ptid.pid (), p);\n \n   return 0;\n }\n \n+/* Clear a registration for the hardware breakpoint given by type BP_TGT.\n+   It will be removed from the threads of inferior_ptid when they are\n+   next resumed.  Returns 0 for success, or -1 if the HWDEBUG interface\n+   that we need for hardware breakpoints is not available.  */\n+\n int\n ppc_linux_nat_target::remove_hw_breakpoint (struct gdbarch *gdbarch,\n \t\t\t\t\t    struct bp_target_info *bp_tgt)\n {\n-  struct lwp_info *lp;\n   struct ppc_hw_breakpoint p;\n \n-  if (!have_ptrace_hwdebug_interface ())\n+  m_dreg_interface.detect (inferior_ptid);\n+\n+  if (!m_dreg_interface.hwdebug_p ())\n     return -1;\n \n   p.version = PPC_DEBUG_CURRENT_VERSION;\n@@ -2090,14 +2256,16 @@ ppc_linux_nat_target::remove_hw_breakpoint (struct gdbarch *gdbarch,\n       p.addr2 = 0;\n     }\n \n-  ALL_LWPS (lp)\n-    hwdebug_remove_point (&p, lp->ptid.lwp ());\n+  clear_hw_breakpoint (inferior_ptid.pid (), p);\n \n   return 0;\n }\n \n-static int\n-get_trigger_type (enum target_hw_bp_type type)\n+/* Return the trigger value to set in a ppc_hw_breakpoint object for a\n+   given hardware watchpoint TYPE.  We assume type is not hw_execute.  */\n+\n+int\n+ppc_linux_nat_target::get_trigger_type (enum target_hw_bp_type type)\n {\n   int t;\n \n@@ -2111,19 +2279,18 @@ get_trigger_type (enum target_hw_bp_type type)\n   return t;\n }\n \n-/* Insert a new masked watchpoint at ADDR using the mask MASK.\n-   RW may be hw_read for a read watchpoint, hw_write for a write watchpoint\n-   or hw_access for an access watchpoint.  Returns 0 on success and throws\n-   an error on failure.  */\n+/* Register a new masked watchpoint at ADDR using the mask MASK, to be\n+   inserted when the threads of inferior_ptid are resumed.  RW may be\n+   hw_read for a read watchpoint, hw_write for a write watchpoint or\n+   hw_access for an access watchpoint.  */\n \n int\n ppc_linux_nat_target::insert_mask_watchpoint (CORE_ADDR addr,  CORE_ADDR mask,\n \t\t\t\t\t      target_hw_bp_type rw)\n {\n-  struct lwp_info *lp;\n   struct ppc_hw_breakpoint p;\n \n-  gdb_assert (have_ptrace_hwdebug_interface ());\n+  gdb_assert (m_dreg_interface.hwdebug_p ());\n \n   p.version = PPC_DEBUG_CURRENT_VERSION;\n   p.trigger_type = get_trigger_type (rw);\n@@ -2133,25 +2300,23 @@ ppc_linux_nat_target::insert_mask_watchpoint (CORE_ADDR addr,  CORE_ADDR mask,\n   p.addr2 = mask;\n   p.condition_value = 0;\n \n-  ALL_LWPS (lp)\n-    hwdebug_insert_point (&p, lp->ptid.lwp ());\n+  register_hw_breakpoint (inferior_ptid.pid (), p);\n \n   return 0;\n }\n \n-/* Remove a masked watchpoint at ADDR with the mask MASK.\n-   RW may be hw_read for a read watchpoint, hw_write for a write watchpoint\n-   or hw_access for an access watchpoint.  Returns 0 on success and throws\n-   an error on failure.  */\n+/* Clear a registration for a masked watchpoint at ADDR with the mask\n+   MASK.  It will be removed from the threads of inferior_ptid when they\n+   are next resumed.  RW may be hw_read for a read watchpoint, hw_write\n+   for a write watchpoint or hw_access for an access watchpoint.  */\n \n int\n ppc_linux_nat_target::remove_mask_watchpoint (CORE_ADDR addr, CORE_ADDR mask,\n \t\t\t\t\t      target_hw_bp_type rw)\n {\n-  struct lwp_info *lp;\n   struct ppc_hw_breakpoint p;\n \n-  gdb_assert (have_ptrace_hwdebug_interface ());\n+  gdb_assert (m_dreg_interface.hwdebug_p ());\n \n   p.version = PPC_DEBUG_CURRENT_VERSION;\n   p.trigger_type = get_trigger_type (rw);\n@@ -2161,39 +2326,42 @@ ppc_linux_nat_target::remove_mask_watchpoint (CORE_ADDR addr, CORE_ADDR mask,\n   p.addr2 = mask;\n   p.condition_value = 0;\n \n-  ALL_LWPS (lp)\n-    hwdebug_remove_point (&p, lp->ptid.lwp ());\n+  clear_hw_breakpoint (inferior_ptid.pid (), p);\n \n   return 0;\n }\n \n-/* Check whether we have at least one free DVC register.  */\n-static int\n-can_use_watchpoint_cond_accel (void)\n+/* Check whether we have at least one free DVC register for the threads\n+   of the pid of inferior_ptid.  */\n+\n+bool\n+ppc_linux_nat_target::can_use_watchpoint_cond_accel (void)\n {\n-  struct thread_points *p;\n-  int tid = inferior_ptid.lwp ();\n-  int cnt = hwdebug_info.num_condition_regs, i;\n+  m_dreg_interface.detect (inferior_ptid);\n \n-  if (!have_ptrace_hwdebug_interface () || cnt == 0)\n-    return 0;\n+  if (!m_dreg_interface.hwdebug_p ())\n+    return false;\n \n-  p = hwdebug_find_thread_points_by_tid (tid, 0);\n+  int cnt = m_dreg_interface.hwdebug_info ().num_condition_regs;\n \n-  if (p)\n-    {\n-      for (i = 0; i < max_slots_number; i++)\n-\tif (p->hw_breaks[i].hw_break != NULL\n-\t    && (p->hw_breaks[i].hw_break->condition_mode\n-\t\t!= PPC_BREAKPOINT_CONDITION_NONE))\n-\t  cnt--;\n+  if (cnt == 0)\n+    return false;\n \n-      /* There are no available slots now.  */\n-      if (cnt <= 0)\n-\treturn 0;\n-    }\n+  auto process_it = m_process_info.find (inferior_ptid.pid ());\n \n-  return 1;\n+  /* No breakpoints or watchpoints have been requested for this process,\n+     we have at least one free DVC register.  */\n+  if (process_it == m_process_info.end ())\n+    return true;\n+\n+  for (const ppc_hw_breakpoint &bp : process_it->second.requested_hw_bps)\n+    if (bp.condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n+      cnt--;\n+\n+  if (cnt <= 0)\n+    return false;\n+\n+  return true;\n }\n \n /* Calculate the enable bits and the contents of the Data Value Compare\n@@ -2204,10 +2372,16 @@ can_use_watchpoint_cond_accel (void)\n    On exit, CONDITION_MODE will hold the enable bits for the DVC, and\n    CONDITION_VALUE will hold the value which should be put in the\n    DVC register.  */\n-static void\n-calculate_dvc (CORE_ADDR addr, int len, CORE_ADDR data_value,\n-\t       uint32_t *condition_mode, uint64_t *condition_value)\n+\n+void\n+ppc_linux_nat_target::calculate_dvc (CORE_ADDR addr, int len,\n+\t\t\t\t     CORE_ADDR data_value,\n+\t\t\t\t     uint32_t *condition_mode,\n+\t\t\t\t     uint64_t *condition_value)\n {\n+  const struct ppc_debug_info &hwdebug_info = (m_dreg_interface.\n+\t\t\t\t\t       hwdebug_info ());\n+\n   int i, num_byte_enable, align_offset, num_bytes_off_dvc,\n       rightmost_enabled_byte;\n   CORE_ADDR addr_end_data, addr_end_dvc;\n@@ -2246,8 +2420,10 @@ calculate_dvc (CORE_ADDR addr, int len, CORE_ADDR data_value,\n    Returns -1 if there's any register access involved, or if there are\n    other kinds of values which are not acceptable in a condition\n    expression (e.g., lval_computed or lval_internalvar).  */\n-static int\n-num_memory_accesses (const std::vector<value_ref_ptr> &chain)\n+\n+int\n+ppc_linux_nat_target::num_memory_accesses (const std::vector<value_ref_ptr>\n+\t\t\t\t\t   &chain)\n {\n   int found_memory_cnt = 0;\n \n@@ -2295,9 +2471,11 @@ num_memory_accesses (const std::vector<value_ref_ptr> &chain)\n    If the function returns 1, DATA_VALUE will contain the constant against\n    which the watch value should be compared and LEN will contain the size\n    of the constant.  */\n-static int\n-check_condition (CORE_ADDR watch_addr, struct expression *cond,\n-\t\t CORE_ADDR *data_value, int *len)\n+\n+int\n+ppc_linux_nat_target::check_condition (CORE_ADDR watch_addr,\n+\t\t\t\t       struct expression *cond,\n+\t\t\t\t       CORE_ADDR *data_value, int *len)\n {\n   int pc = 1, num_accesses_left, num_accesses_right;\n   struct value *left_val, *right_val;\n@@ -2344,18 +2522,21 @@ check_condition (CORE_ADDR watch_addr, struct expression *cond,\n   return 1;\n }\n \n-/* Return non-zero if the target is capable of using hardware to evaluate\n-   the condition expression, thus only triggering the watchpoint when it is\n+/* Return true if the target is capable of using hardware to evaluate the\n+   condition expression, thus only triggering the watchpoint when it is\n    true.  */\n+\n bool\n-ppc_linux_nat_target::can_accel_watchpoint_condition (CORE_ADDR addr, int len,\n-\t\t\t\t\t\t      int rw,\n+ppc_linux_nat_target::can_accel_watchpoint_condition (CORE_ADDR addr,\n+\t\t\t\t\t\t      int len, int rw,\n \t\t\t\t\t\t      struct expression *cond)\n {\n   CORE_ADDR data_value;\n \n-  return (have_ptrace_hwdebug_interface ()\n-\t  && hwdebug_info.num_condition_regs > 0\n+  m_dreg_interface.detect (inferior_ptid);\n+\n+  return (m_dreg_interface.hwdebug_p ()\n+\t  && (m_dreg_interface.hwdebug_info ().num_condition_regs > 0)\n \t  && check_condition (addr, cond, &data_value, &len));\n }\n \n@@ -2364,11 +2545,16 @@ ppc_linux_nat_target::can_accel_watchpoint_condition (CORE_ADDR addr, int len,\n    evaluated by hardware.  INSERT tells if we are creating a request for\n    inserting or removing the watchpoint.  */\n \n-static void\n-create_watchpoint_request (struct ppc_hw_breakpoint *p, CORE_ADDR addr,\n-\t\t\t   int len, enum target_hw_bp_type type,\n-\t\t\t   struct expression *cond, int insert)\n+void\n+ppc_linux_nat_target::create_watchpoint_request (struct ppc_hw_breakpoint *p,\n+\t\t\t\t\t\t CORE_ADDR addr, int len,\n+\t\t\t\t\t\t enum target_hw_bp_type type,\n+\t\t\t\t\t\t struct expression *cond,\n+\t\t\t\t\t\t int insert)\n {\n+  const struct ppc_debug_info &hwdebug_info = (m_dreg_interface\n+\t\t\t\t\t       .hwdebug_info ());\n+\n   if (len == 1\n       || !(hwdebug_info.features & PPC_DEBUG_FEATURE_DATA_BP_RANGE))\n     {\n@@ -2410,28 +2596,33 @@ create_watchpoint_request (struct ppc_hw_breakpoint *p, CORE_ADDR addr,\n   p->addr = (uint64_t) addr;\n }\n \n+/* Register a watchpoint, to be inserted when the threads of the group of\n+   inferior_ptid are next resumed.  Returns 0 on success, and -1 if there\n+   is no ptrace interface available to install the watchpoint.  */\n+\n int\n ppc_linux_nat_target::insert_watchpoint (CORE_ADDR addr, int len,\n \t\t\t\t\t enum target_hw_bp_type type,\n \t\t\t\t\t struct expression *cond)\n {\n-  struct lwp_info *lp;\n-  int ret = -1;\n+  m_dreg_interface.detect (inferior_ptid);\n+\n+  if (m_dreg_interface.unavailable_p ())\n+    return -1;\n \n-  if (have_ptrace_hwdebug_interface ())\n+  if (m_dreg_interface.hwdebug_p ())\n     {\n       struct ppc_hw_breakpoint p;\n \n       create_watchpoint_request (&p, addr, len, type, cond, 1);\n \n-      ALL_LWPS (lp)\n-\thwdebug_insert_point (&p, lp->ptid.lwp ());\n-\n-      ret = 0;\n+      register_hw_breakpoint (inferior_ptid.pid (), p);\n     }\n   else\n     {\n-      long dabr_value;\n+      gdb_assert (m_dreg_interface.debugreg_p ());\n+\n+      long wp_value;\n       long read_mode, write_mode;\n \n       if (linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n@@ -2449,144 +2640,300 @@ ppc_linux_nat_target::insert_watchpoint (CORE_ADDR addr, int len,\n \t  write_mode = 6;\n \t}\n \n-      dabr_value = addr & ~(read_mode | write_mode);\n+      wp_value = addr & ~(read_mode | write_mode);\n       switch (type)\n \t{\n \t  case hw_read:\n \t    /* Set read and translate bits.  */\n-\t    dabr_value |= read_mode;\n+\t    wp_value |= read_mode;\n \t    break;\n \t  case hw_write:\n \t    /* Set write and translate bits.  */\n-\t    dabr_value |= write_mode;\n+\t    wp_value |= write_mode;\n \t    break;\n \t  case hw_access:\n \t    /* Set read, write and translate bits.  */\n-\t    dabr_value |= read_mode | write_mode;\n+\t    wp_value |= read_mode | write_mode;\n \t    break;\n \t}\n \n-      saved_dabr_value = dabr_value;\n-\n-      ALL_LWPS (lp)\n-\tif (ptrace (PTRACE_SET_DEBUGREG, lp->ptid.lwp (), 0,\n-\t\t    saved_dabr_value) < 0)\n-\t  return -1;\n-\n-      ret = 0;\n+      register_wp (inferior_ptid.pid (), wp_value);\n     }\n \n-  return ret;\n+  return 0;\n }\n \n+/* Clear a registration for a hardware watchpoint.  It will be removed\n+   from the threads of the group of inferior_ptid when they are next\n+   resumed.  */\n+\n int\n ppc_linux_nat_target::remove_watchpoint (CORE_ADDR addr, int len,\n \t\t\t\t\t enum target_hw_bp_type type,\n \t\t\t\t\t struct expression *cond)\n {\n-  struct lwp_info *lp;\n-  int ret = -1;\n+  gdb_assert (!m_dreg_interface.unavailable_p ());\n \n-  if (have_ptrace_hwdebug_interface ())\n+  if (m_dreg_interface.hwdebug_p ())\n     {\n       struct ppc_hw_breakpoint p;\n \n       create_watchpoint_request (&p, addr, len, type, cond, 0);\n \n-      ALL_LWPS (lp)\n-\thwdebug_remove_point (&p, lp->ptid.lwp ());\n-\n-      ret = 0;\n+      clear_hw_breakpoint (inferior_ptid.pid (), p);\n     }\n   else\n     {\n-      saved_dabr_value = 0;\n-      ALL_LWPS (lp)\n-\tif (ptrace (PTRACE_SET_DEBUGREG, lp->ptid.lwp (), 0,\n-\t\t    saved_dabr_value) < 0)\n-\t  return -1;\n+      gdb_assert (m_dreg_interface.debugreg_p ());\n \n-      ret = 0;\n+      clear_wp (inferior_ptid.pid ());\n     }\n \n-  return ret;\n+  return 0;\n }\n \n+/* Clean up the per-process info associated with PID.  When using the\n+   HWDEBUG interface, we also erase the per-thread state of installed\n+   debug registers for all the threads that belong to the group of PID.\n+\n+   Usually the thread state is cleaned up by low_delete_thread.  We also\n+   do it here because low_new_thread is not called for the initial LWP,\n+   so low_delete_thread won't be able to clean up this state.  */\n+\n void\n-ppc_linux_nat_target::low_new_thread (struct lwp_info *lp)\n+ppc_linux_nat_target::low_forget_process (pid_t pid)\n {\n-  int tid = lp->ptid.lwp ();\n+  if ((!m_dreg_interface.detected_p ())\n+      || (m_dreg_interface.unavailable_p ()))\n+    return;\n \n-  if (have_ptrace_hwdebug_interface ())\n+  ptid_t pid_ptid (pid, 0, 0);\n+\n+  m_process_info.erase (pid);\n+\n+  if (m_dreg_interface.hwdebug_p ())\n     {\n-      int i;\n-      struct thread_points *p;\n-      struct hw_break_tuple *hw_breaks;\n+      for (auto it = m_installed_hw_bps.begin ();\n+\t   it != m_installed_hw_bps.end ();)\n+\t{\n+\t  if (it->first.matches (pid_ptid))\n+\t    it = m_installed_hw_bps.erase (it);\n+\t  else\n+\t    it++;\n+\t}\n+    }\n+}\n \n-      if (ppc_threads.empty ())\n-\treturn;\n+/* Copy the per-process state associated with the pid of PARENT to the\n+   sate of CHILD_PID.  GDB expects that a forked process will have the\n+   same hardware breakpoints and watchpoints as the parent.\n \n-      /* Get a list of breakpoints from any thread.  */\n-      p = ppc_threads.back ();\n-      hw_breaks = p->hw_breaks;\n+   If we're using the HWDEBUG interface, also copy the thread debug\n+   register state for the ptid of PARENT to the state for CHILD_PID.\n \n-      /* Copy that thread's breakpoints and watchpoints to the new thread.  */\n-      for (i = 0; i < max_slots_number; i++)\n-\tif (hw_breaks[i].hw_break)\n-\t  {\n-\t    /* Older kernels did not make new threads inherit their parent\n-\t       thread's debug state, so we always clear the slot and replicate\n-\t       the debug state ourselves, ensuring compatibility with all\n-\t       kernels.  */\n+   Like for clone events, we assume the kernel will copy the debug\n+   registers from the parent thread to the child. The\n+   low_prepare_to_resume function is made to work even if it doesn't.\n \n-\t    /* The ppc debug resource accounting is done through \"slots\".\n-\t       Ask the kernel the deallocate this specific *point's slot.  */\n-\t    ptrace (PPC_PTRACE_DELHWDEBUG, tid, 0, hw_breaks[i].slot);\n+   We copy the thread state here and not in low_new_thread since we don't\n+   have the pid of the parent in low_new_thread.  Even if we did,\n+   low_new_thread might not be called immediately after the fork event is\n+   detected.  For instance, with the checkpointing system (see\n+   linux-fork.c), the thread won't be added until GDB decides to switch\n+   to a new checkpointed process.  At that point, the debug register\n+   state of the parent thread is unlikely to correspond to the state it\n+   had at the point when it forked.  */\n \n-\t    hwdebug_insert_point (hw_breaks[i].hw_break, tid);\n-\t  }\n+void\n+ppc_linux_nat_target::low_new_fork (struct lwp_info *parent,\n+\t\t\t\t    pid_t child_pid)\n+{\n+  if ((!m_dreg_interface.detected_p ())\n+      || (m_dreg_interface.unavailable_p ()))\n+    return;\n+\n+  auto process_it = m_process_info.find (parent->ptid.pid ());\n+\n+  if (process_it != m_process_info.end ())\n+    m_process_info[child_pid] = m_process_info[parent->ptid.pid ()];\n+\n+  if (m_dreg_interface.hwdebug_p ())\n+    {\n+      ptid_t child_ptid (child_pid, child_pid, 0);\n+\n+      copy_thread_dreg_state (parent->ptid, child_ptid);\n     }\n-  else\n-    ptrace (PTRACE_SET_DEBUGREG, tid, 0, saved_dabr_value);\n }\n \n-static void\n-ppc_linux_thread_exit (struct thread_info *tp, int silent)\n+/* Copy the thread debug register state from the PARENT thread to the the\n+   state for CHILD_LWP, if we're using the HWDEBUG interface.  We assume\n+   the kernel copies the debug registers from one thread to another after\n+   a clone event.  The low_prepare_to_resume function is made to work\n+   even if it doesn't.  */\n+\n+void\n+ppc_linux_nat_target::low_new_clone (struct lwp_info *parent,\n+\t\t\t\t     pid_t child_lwp)\n {\n-  int i;\n-  int tid = tp->ptid.lwp ();\n-  struct hw_break_tuple *hw_breaks;\n-  struct thread_points *t = NULL;\n+  if ((!m_dreg_interface.detected_p ())\n+      || (m_dreg_interface.unavailable_p ()))\n+    return;\n+\n+  if (m_dreg_interface.hwdebug_p ())\n+    {\n+      ptid_t child_ptid (parent->ptid.pid (), child_lwp, 0);\n+\n+      copy_thread_dreg_state (parent->ptid, child_ptid);\n+    }\n+}\n+\n+/* Initialize the arch-specific thread state for LP so that it contains\n+   the ptid for lp, so that we can use it in low_delete_thread.  Mark the\n+   new thread LP as stale so that we update its debug registers before\n+   resuming it.  This is not called for the initial thread.  */\n+\n+void\n+ppc_linux_nat_target::low_new_thread (struct lwp_info *lp)\n+{\n+  init_arch_lwp_info (lp);\n+\n+  mark_thread_stale (lp);\n+}\n+\n+/* Delete the per-thread debug register stale flag.  */\n+\n+void\n+ppc_linux_nat_target::low_delete_thread (struct arch_lwp_info\n+\t\t\t\t\t *lp_arch_info)\n+{\n+  if (lp_arch_info != NULL)\n+    {\n+      if (m_dreg_interface.detected_p ()\n+\t  && m_dreg_interface.hwdebug_p ())\n+\tm_installed_hw_bps.erase (lp_arch_info->lwp_ptid);\n+\n+      xfree (lp_arch_info);\n+    }\n+}\n+\n+/* Install or delete debug registers in thread LP so that it matches what\n+   GDB requested before it is resumed.  */\n+\n+void\n+ppc_linux_nat_target::low_prepare_to_resume (struct lwp_info *lp)\n+{\n+  if ((!m_dreg_interface.detected_p ())\n+      || (m_dreg_interface.unavailable_p ()))\n+    return;\n+\n+  /* We have to re-install or clear the debug registers if we set the\n+     stale flag.\n+\n+     In addition, some kernels configurations can disable a hardware\n+     watchpoint after it is hit.  Usually, GDB will remove and re-install\n+     a hardware watchpoint when the thread stops if \"breakpoint\n+     always-inserted\" is off, or to single-step a watchpoint.  But so\n+     that we don't rely on this behavior, if we stop due to a hardware\n+     breakpoint or watchpoint, we also refresh our debug registers.  */\n+\n+  arch_lwp_info *lp_arch_info = get_arch_lwp_info (lp);\n \n-  if (!have_ptrace_hwdebug_interface ())\n+  bool stale_dregs = (lp->stop_reason == TARGET_STOPPED_BY_WATCHPOINT\n+\t\t      || lp->stop_reason == TARGET_STOPPED_BY_HW_BREAKPOINT\n+\t\t      || lp_arch_info->debug_regs_stale);\n+\n+  if (!stale_dregs)\n     return;\n \n-  for (i = 0; i < ppc_threads.size (); i++)\n+  gdb_assert (lp->ptid.lwp_p ());\n+\n+  auto process_it = m_process_info.find (lp->ptid.pid ());\n+\n+  if (m_dreg_interface.hwdebug_p ())\n     {\n-      if (ppc_threads[i]->tid == tid)\n+      /* First, delete any hardware watchpoint or breakpoint installed in\n+\t the inferior and update the thread state.  */\n+      auto installed_it = m_installed_hw_bps.find (lp->ptid);\n+\n+      if (installed_it != m_installed_hw_bps.end ())\n \t{\n-\t  t = ppc_threads[i];\n-\t  break;\n+\t  auto &bp_list = installed_it->second;\n+\n+\t  for (auto bp_it = bp_list.begin (); bp_it != bp_list.end ();)\n+\t    {\n+\t      /* We ignore ENOENT to account for various possible kernel\n+\t\t behaviors, e.g. the kernel might or might not copy debug\n+\t\t registers across forks and clones, and we always copy\n+\t\t the debug register state when fork and clone events are\n+\t\t detected.  */\n+\t      if (ptrace (PPC_PTRACE_DELHWDEBUG, lp->ptid.lwp (), 0,\n+\t\t\t  bp_it->first) == -1)\n+\t\tif (errno != ENOENT)\n+\t\t  perror_with_name (_(\"Error deleting hardware \"\n+\t\t\t\t      \"breakpoint or watchpoint\"));\n+\n+\t      /* We erase the entries one at a time after successfuly\n+\t\t removing the corresponding slot form the thread so that\n+\t\t if we throw an exception above in a future iteration the\n+\t\t map remains consistent.  */\n+\t      bp_it = bp_list.erase (bp_it);\n+\t    }\n+\n+\t  gdb_assert (bp_list.empty ());\n+\t}\n+\n+      /* Now we install all the requested hardware breakpoints and\n+\t watchpoints and update the thread state.  */\n+\n+      if (process_it != m_process_info.end ())\n+\t{\n+\t  auto &bp_list = m_installed_hw_bps[lp->ptid];\n+\n+\t  for (ppc_hw_breakpoint bp\n+\t\t : process_it->second.requested_hw_bps)\n+\t    {\n+\t      long slot = ptrace (PPC_PTRACE_SETHWDEBUG, lp->ptid.lwp (),\n+\t\t\t\t  0, &bp);\n+\n+\t      if (slot < 0)\n+\t\tperror_with_name (_(\"Error setting hardware \"\n+\t\t\t\t    \"breakpoint or watchpoint\"));\n+\n+\t      /* Keep track of which slots we installed in this\n+\t\t thread.  */\n+\t      bp_list.emplace (bp_list.begin (), slot, bp);\n+\t    }\n \t}\n     }\n+  else\n+    {\n+      gdb_assert (m_dreg_interface.debugreg_p ());\n \n-  if (t == NULL)\n-    return;\n+      /* Passing 0 to PTRACE_SET_DEBUGREG will clear the\n+\t watchpoint.  */\n+      long wp = 0;\n \n-  unordered_remove (ppc_threads, i);\n+      /* GDB requested a watchpoint to be installed.  */\n+      if (process_it != m_process_info.end ()\n+\t  && process_it->second.requested_wp_val.has_value ())\n+\twp = *(process_it->second.requested_wp_val);\n \n-  hw_breaks = t->hw_breaks;\n+      long ret = ptrace (PTRACE_SET_DEBUGREG, lp->ptid.lwp (),\n+\t\t\t 0, wp);\n \n-  for (i = 0; i < max_slots_number; i++)\n-    if (hw_breaks[i].hw_break)\n-      xfree (hw_breaks[i].hw_break);\n+      if (ret == -1)\n+\tperror_with_name (_(\"Error setting hardware watchpoint\"));\n+    }\n \n-  xfree (t->hw_breaks);\n-  xfree (t);\n+  lp_arch_info->debug_regs_stale = false;\n }\n \n+/* Return true if INFERIOR_PTID is known to have been stopped by a\n+   hardware watchpoint, false otherwise.  If true is returned, write the\n+   address that the kernel reported as causing the SIGTRAP in ADDR_P.  */\n+\n bool\n-ppc_linux_nat_target::stopped_data_address (CORE_ADDR *addr_p)\n+ppc_linux_nat_target::low_stopped_data_address (CORE_ADDR *addr_p)\n {\n   siginfo_t siginfo;\n \n@@ -2597,48 +2944,57 @@ ppc_linux_nat_target::stopped_data_address (CORE_ADDR *addr_p)\n       || (siginfo.si_code & 0xffff) != 0x0004 /* TRAP_HWBKPT */)\n     return false;\n \n-  if (have_ptrace_hwdebug_interface ())\n+  gdb_assert (!m_dreg_interface.unavailable_p ());\n+\n+  /* Check if this signal corresponds to a hardware breakpoint.  We only\n+     need to check this if we're using the HWDEBUG interface, since the\n+     DEBUGREG interface only allows setting one hardware watchpoint.  */\n+  if (m_dreg_interface.hwdebug_p ())\n     {\n-      int i;\n-      struct thread_points *t;\n-      struct hw_break_tuple *hw_breaks;\n-      /* The index (or slot) of the *point is passed in the si_errno field.  */\n+      /* The index (or slot) of the *point is passed in the si_errno\n+\t field.  Currently, this is only the case if the kernel was\n+\t configured with CONFIG_PPC_ADV_DEBUG_REGS.  If not, we assume\n+\t the kernel will set si_errno to a value that doesn't correspond\n+\t to any real slot.  */\n       int slot = siginfo.si_errno;\n \n-      t = hwdebug_find_thread_points_by_tid (inferior_ptid.lwp (), 0);\n+      auto installed_it = m_installed_hw_bps.find (inferior_ptid);\n \n-      /* Find out if this *point is a hardware breakpoint.\n-\t If so, we should return 0.  */\n-      if (t)\n-\t{\n-\t  hw_breaks = t->hw_breaks;\n-\t  for (i = 0; i < max_slots_number; i++)\n-\t   if (hw_breaks[i].hw_break && hw_breaks[i].slot == slot\n-\t       && hw_breaks[i].hw_break->trigger_type\n-\t\t    == PPC_BREAKPOINT_TRIGGER_EXECUTE)\n-\t     return false;\n-\t}\n+      /* We must have installed slots for the thread if it got a\n+\t TRAP_HWBKPT signal.  */\n+      gdb_assert (installed_it != m_installed_hw_bps.end ());\n+\n+      for (const auto & slot_bp_pair : installed_it->second)\n+\tif (slot_bp_pair.first == slot\n+\t    && (slot_bp_pair.second.trigger_type\n+\t\t== PPC_BREAKPOINT_TRIGGER_EXECUTE))\n+\t  return false;\n     }\n \n   *addr_p = (CORE_ADDR) (uintptr_t) siginfo.si_addr;\n   return true;\n }\n \n+/* Return true if INFERIOR_PTID is known to have been stopped by a\n+   hardware watchpoint, false otherwise.  */\n+\n bool\n-ppc_linux_nat_target::stopped_by_watchpoint ()\n+ppc_linux_nat_target::low_stopped_by_watchpoint ()\n {\n   CORE_ADDR addr;\n-  return stopped_data_address (&addr);\n+  return low_stopped_data_address (&addr);\n }\n \n bool\n ppc_linux_nat_target::watchpoint_addr_within_range (CORE_ADDR addr,\n \t\t\t\t\t\t    CORE_ADDR start,\n \t\t\t\t\t\t    int length)\n {\n+  gdb_assert (!m_dreg_interface.unavailable_p ());\n+\n   int mask;\n \n-  if (have_ptrace_hwdebug_interface ()\n+  if (m_dreg_interface.hwdebug_p ()\n       && linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n     return start <= addr && start + length >= addr;\n   else if (linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n@@ -2655,10 +3011,14 @@ ppc_linux_nat_target::watchpoint_addr_within_range (CORE_ADDR addr,\n /* Return the number of registers needed for a masked hardware watchpoint.  */\n \n int\n-ppc_linux_nat_target::masked_watch_num_registers (CORE_ADDR addr, CORE_ADDR mask)\n+ppc_linux_nat_target::masked_watch_num_registers (CORE_ADDR addr,\n+\t\t\t\t\t\t  CORE_ADDR mask)\n {\n-  if (!have_ptrace_hwdebug_interface ()\n-\t   || (hwdebug_info.features & PPC_DEBUG_FEATURE_DATA_BP_MASK) == 0)\n+  m_dreg_interface.detect (inferior_ptid);\n+\n+  if (!m_dreg_interface.hwdebug_p ()\n+      || (m_dreg_interface.hwdebug_info ().features\n+\t  & PPC_DEBUG_FEATURE_DATA_BP_MASK) == 0)\n     return -1;\n   else if ((mask & 0xC0000000) != 0xC0000000)\n     {\n@@ -2671,14 +3031,182 @@ ppc_linux_nat_target::masked_watch_num_registers (CORE_ADDR addr, CORE_ADDR mask\n     return 2;\n }\n \n+/* Copy the per-thread debug register state, if any, from thread\n+   PARENT_PTID to thread CHILD_PTID, if the debug register being used is\n+   HWDEBUG.  */\n+\n+void\n+ppc_linux_nat_target::copy_thread_dreg_state (const ptid_t &parent_ptid,\n+\t\t\t\t\t      const ptid_t &child_ptid)\n+{\n+  gdb_assert (m_dreg_interface.hwdebug_p ());\n+\n+  auto installed_it = m_installed_hw_bps.find (parent_ptid);\n+\n+  if (installed_it != m_installed_hw_bps.end ())\n+    m_installed_hw_bps[child_ptid] = m_installed_hw_bps[parent_ptid];\n+}\n+\n+/* Mark the debug register stale flag for the new thread, if we have\n+   already detected which debug register interface we use.  */\n+\n+void\n+ppc_linux_nat_target::mark_thread_stale (struct lwp_info *lp)\n+{\n+  if ((!m_dreg_interface.detected_p ())\n+      || (m_dreg_interface.unavailable_p ()))\n+    return;\n+\n+  arch_lwp_info *lp_arch_info = get_arch_lwp_info (lp);\n+\n+  lp_arch_info->debug_regs_stale = true;\n+}\n+\n+/* Mark all the threads of the group of PID as stale with respect to\n+   debug registers and issue a stop request to each such thread that\n+   isn't already stopped.  */\n+\n+void\n+ppc_linux_nat_target::mark_debug_registers_changed (pid_t pid)\n+{\n+  /* We do this in two passes to make sure all threads are marked even if\n+     we get an exception when stopping one of them.  */\n+\n+  iterate_over_lwps (ptid_t (pid),\n+\t\t     [this] (struct lwp_info *lp) -> int {\n+\t\t       this->mark_thread_stale (lp);\n+\t\t       return 0;\n+\t\t     });\n+\n+  iterate_over_lwps (ptid_t (pid),\n+\t\t     [] (struct lwp_info *lp) -> int {\n+\t\t       if (!lwp_is_stopped (lp))\n+\t\t\t linux_stop_lwp (lp);\n+\t\t       return 0;\n+\t\t     });\n+}\n+\n+/* Register a hardware breakpoint or watchpoint BP for the pid PID, then\n+   mark the stale flag for all threads of the group of PID, and issue a\n+   stop request for them.  The breakpoint or watchpoint will be installed\n+   the next time each thread is resumed.  Should only be used if the\n+   debug register interface is HWDEBUG.  */\n+\n+void\n+ppc_linux_nat_target::register_hw_breakpoint (pid_t pid,\n+\t\t\t\t\t      const struct\n+\t\t\t\t\t      ppc_hw_breakpoint &bp)\n+{\n+  gdb_assert (m_dreg_interface.hwdebug_p ());\n+\n+  m_process_info[pid].requested_hw_bps.push_back (bp);\n+\n+  mark_debug_registers_changed (pid);\n+}\n+\n+/* Clear a registration for a hardware breakpoint or watchpoint BP for\n+   the pid PID, then mark the stale flag for all threads of the group of\n+   PID, and issue a stop request for them.  The breakpoint or watchpoint\n+   will be removed the next time each thread is resumed.  Should only be\n+   used if the debug register interface is HWDEBUG.  */\n+\n+void\n+ppc_linux_nat_target::clear_hw_breakpoint (pid_t pid,\n+\t\t\t\t\t   const struct ppc_hw_breakpoint &bp)\n+{\n+  gdb_assert (m_dreg_interface.hwdebug_p ());\n+\n+  auto process_it = m_process_info.find (pid);\n+\n+  gdb_assert (process_it != m_process_info.end ());\n+\n+  auto bp_it = std::find_if (process_it->second.requested_hw_bps.begin (),\n+\t\t\t     process_it->second.requested_hw_bps.end (),\n+\t\t\t     [&bp, this]\n+\t\t\t     (const struct ppc_hw_breakpoint &curr)\n+\t\t\t     { return hwdebug_point_cmp (bp, curr); }\n+\t\t\t     );\n+\n+  /* If GDB is removing a watchpoint, it must have been inserted.  */\n+  gdb_assert (bp_it != process_it->second.requested_hw_bps.end ());\n+\n+  process_it->second.requested_hw_bps.erase (bp_it);\n+\n+  mark_debug_registers_changed (pid);\n+}\n+\n+/* Register the hardware watchpoint value WP_VALUE for the pid PID,\n+   then mark the stale flag for all threads of the group of PID, and\n+   issue a stop request for them.  The breakpoint or watchpoint will be\n+   installed the next time each thread is resumed.  Should only be used\n+   if the debug register interface is DEBUGREG.  */\n+\n+void\n+ppc_linux_nat_target::register_wp (pid_t pid, long wp_value)\n+{\n+  gdb_assert (m_dreg_interface.debugreg_p ());\n+\n+  /* Our other functions should have told GDB that we only have one\n+     hardware watchpoint with this interface.  */\n+  gdb_assert (!m_process_info[pid].requested_wp_val.has_value ());\n+\n+  m_process_info[pid].requested_wp_val.emplace (wp_value);\n+\n+  mark_debug_registers_changed (pid);\n+}\n+\n+/* Clear the hardware watchpoint registration for the pid PID, then mark\n+   the stale flag for all threads of the group of PID, and issue a stop\n+   request for them.  The breakpoint or watchpoint will be installed the\n+   next time each thread is resumed.  Should only be used if the debug\n+   register interface is DEBUGREG.  */\n+\n+void\n+ppc_linux_nat_target::clear_wp (pid_t pid)\n+{\n+  gdb_assert (m_dreg_interface.debugreg_p ());\n+\n+  auto process_it = m_process_info.find (pid);\n+\n+  gdb_assert (process_it != m_process_info.end ());\n+  gdb_assert (process_it->second.requested_wp_val.has_value ());\n+\n+  process_it->second.requested_wp_val.reset ();\n+\n+  mark_debug_registers_changed (pid);\n+}\n+\n+/* Initialize the arch-specific thread state for LWP, if it not already\n+   created.  */\n+\n+void\n+ppc_linux_nat_target::init_arch_lwp_info (struct lwp_info *lp)\n+{\n+  if (lwp_arch_private_info (lp) == NULL)\n+    {\n+      lwp_set_arch_private_info (lp, XCNEW (struct arch_lwp_info));\n+      lwp_arch_private_info (lp)->debug_regs_stale = false;\n+      lwp_arch_private_info (lp)->lwp_ptid = lp->ptid;\n+    }\n+}\n+\n+/* Get the arch-specific thread state for LWP, creating it if\n+   necessary.  */\n+\n+arch_lwp_info *\n+ppc_linux_nat_target::get_arch_lwp_info (struct lwp_info *lp)\n+{\n+  init_arch_lwp_info (lp);\n+\n+  return lwp_arch_private_info (lp);\n+}\n+\n void _initialize_ppc_linux_nat ();\n void\n _initialize_ppc_linux_nat ()\n {\n   linux_target = &the_ppc_linux_nat_target;\n \n-  gdb::observers::thread_exit.attach (ppc_linux_thread_exit);\n-\n   /* Register the target.  */\n   add_inf_child_target (linux_target);\n }"
    }
  ]
}