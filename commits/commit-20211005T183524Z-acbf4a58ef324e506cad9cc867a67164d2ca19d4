{
  "sha": "acbf4a58ef324e506cad9cc867a67164d2ca19d4",
  "node_id": "C_kwDOANOeidoAKGFjYmY0YTU4ZWYzMjRlNTA2Y2FkOWNjODY3YTY3MTY0ZDJjYTE5ZDQ",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-09-13T18:53:05Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-10-05T18:35:24Z"
    },
    "message": "Remove 'varsize-limit'\n\nThis makes the Ada-specific \"varsize-limit\" a synonym for\n\"max-value-size\", and removes the Ada-specific checks of the limit.\n\nI am not certain of the history here, but it seems to me that this\ncode is fully obsolete now.  And, removing this makes it possible to\nindex large Ada arrays without triggering an error.  A new test case\nis included to demonstrate this.",
    "tree": {
      "sha": "01ef3482d2859a81ca7a94e09c7ff190838fcde9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/01ef3482d2859a81ca7a94e09c7ff190838fcde9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/acbf4a58ef324e506cad9cc867a67164d2ca19d4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/acbf4a58ef324e506cad9cc867a67164d2ca19d4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/acbf4a58ef324e506cad9cc867a67164d2ca19d4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/acbf4a58ef324e506cad9cc867a67164d2ca19d4/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3e44c3049fc23f5ba894b346b7defdfba66b076e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3e44c3049fc23f5ba894b346b7defdfba66b076e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3e44c3049fc23f5ba894b346b7defdfba66b076e"
    }
  ],
  "stats": {
    "total": 96,
    "additions": 33,
    "deletions": 63
  },
  "files": [
    {
      "sha": "7ca1f842cb1e1ffaf91467a0a92160a1306175be",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=acbf4a58ef324e506cad9cc867a67164d2ca19d4",
      "patch": "@@ -19,6 +19,11 @@ show source open\n   to open and read source code files, which can be useful if the files\n   are located over a slow network connection.\n \n+set varsize-limit\n+show varsize-limit\n+  These are now deprecated aliases for \"set max-value-size\" and\n+  \"show max-value-size\".\n+\n maint set internal-error backtrace on|off\n maint show internal-error backtrace\n maint set internal-warning backtrace on|off"
    },
    {
      "sha": "6a19ad9d01c6f58abda2fe696deee7b22945a89c",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 52,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=acbf4a58ef324e506cad9cc867a67164d2ca19d4",
      "patch": "@@ -247,9 +247,6 @@ struct ada_symbol_cache\n   struct cache_entry *root[HASH_SIZE] {};\n };\n \n-/* Maximum-sized dynamic type.  */\n-static unsigned int varsize_limit;\n-\n static const char ada_completer_word_break_characters[] =\n #ifdef VMS\n   \" \\t\\n!@#%^&*()+=|~`}{[]\\\";:?/,-\";\n@@ -524,10 +521,6 @@ coerce_unspec_val_to_type (struct value *val, struct type *type)\n     {\n       struct value *result;\n \n-      /* Make sure that the object size is not unreasonable before\n-\t trying to allocate some memory for it.  */\n-      ada_ensure_varsize_limit (type);\n-\n       if (value_optimized_out (val))\n \tresult = allocate_optimized_out_value (type);\n       else if (value_lazy (val)\n@@ -589,17 +582,6 @@ lim_warning (const char *format, ...)\n   va_end (args);\n }\n \n-/* Issue an error if the size of an object of type T is unreasonable,\n-   i.e. if it would be a bad idea to allocate a value of this type in\n-   GDB.  */\n-\n-void\n-ada_ensure_varsize_limit (const struct type *type)\n-{\n-  if (TYPE_LENGTH (type) > varsize_limit)\n-    error (_(\"object size is larger than varsize-limit\"));\n-}\n-\n /* Maximum value of a SIZE-byte signed integer type.  */\n static LONGEST\n max_of_size (int size)\n@@ -1898,7 +1880,6 @@ ada_coerce_to_simple_array (struct value *arr)\n \n       if (arrVal == NULL)\n \terror (_(\"Bounds unavailable for null array pointer.\"));\n-      ada_ensure_varsize_limit (TYPE_TARGET_TYPE (value_type (arrVal)));\n       return value_ind (arrVal);\n     }\n   else if (ada_is_constrained_packed_array_type (value_type (arr)))\n@@ -7539,12 +7520,6 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \n \t  if (dval0 == NULL)\n \t    {\n-\t      /* rtype's length is computed based on the run-time\n-\t\t value of discriminants.  If the discriminants are not\n-\t\t initialized, the type size may be completely bogus and\n-\t\t GDB may fail to allocate a value for it.  So check the\n-\t\t size first before creating the value.  */\n-\t      ada_ensure_varsize_limit (rtype);\n \t      /* Using plain value_from_contents_and_address here\n \t\t causes problems because we will end up trying to\n \t\t resolve a type that is currently being\n@@ -7585,14 +7560,6 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t  field_type = ada_get_base_type (field_type);\n \t  field_type = ada_to_fixed_type (field_type, field_valaddr,\n \t\t\t\t\t  field_address, dval, 0);\n-\t  /* If the field size is already larger than the maximum\n-\t     object size, then the record itself will necessarily\n-\t     be larger than the maximum object size.  We need to make\n-\t     this check now, because the size might be so ridiculously\n-\t     large (due to an uninitialized variable in the inferior)\n-\t     that it would cause an overflow when adding it to the\n-\t     record size.  */\n-\t  ada_ensure_varsize_limit (field_type);\n \n \t  rtype->field (f).set_type (field_type);\n \t  rtype->field (f).set_name (type->field (f).name ());\n@@ -7713,8 +7680,6 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n     }\n \n   value_free_to_mark (mark);\n-  if (TYPE_LENGTH (rtype) > varsize_limit)\n-    error (_(\"record type with dynamic size is larger than varsize-limit\"));\n   return rtype;\n }\n \n@@ -8161,8 +8126,6 @@ to_fixed_array_type (struct type *type0, struct value *dval,\n \t\t\t\t      result, range_type);\n \t  elt_type0 = TYPE_TARGET_TYPE (elt_type0);\n \t}\n-      if (!ignore_too_big && TYPE_LENGTH (result) > varsize_limit)\n-\terror (_(\"array type with dynamic size is larger than varsize-limit\"));\n     }\n \n   /* We want to preserve the type name.  This can be useful when\n@@ -10584,7 +10547,6 @@ ada_unop_ind_operation::evaluate (struct type *expect_type,\n \t\t(ada_aligned_type\n \t\t (ada_check_typedef (TYPE_TARGET_TYPE (type))));\n \t    }\n-\t  ada_ensure_varsize_limit (type);\n \t  return value_zero (type, lval_memory);\n \t}\n       else if (type->code () == TYPE_CODE_INT)\n@@ -10619,11 +10581,6 @@ ada_unop_ind_operation::evaluate (struct type *expect_type,\n \t\t\t      (CORE_ADDR) value_as_address (arg1));\n     }\n \n-  struct type *target_type = (to_static_fixed_type\n-\t\t\t      (ada_aligned_type\n-\t\t\t       (ada_check_typedef (TYPE_TARGET_TYPE (type)))));\n-  ada_ensure_varsize_limit (target_type);\n-\n   if (ada_is_array_descriptor_type (type))\n     /* GDB allows dereferencing GNAT array descriptors.  */\n     return ada_coerce_to_simple_array (arg1);\n@@ -13593,15 +13550,6 @@ exception should cause a stop.\"),\n \t\t     CATCH_PERMANENT,\n \t\t     CATCH_TEMPORARY);\n \n-  varsize_limit = 65536;\n-  add_setshow_uinteger_cmd (\"varsize-limit\", class_support,\n-\t\t\t    &varsize_limit, _(\"\\\n-Set the maximum number of bytes allowed in a variable-size object.\"), _(\"\\\n-Show the maximum number of bytes allowed in a variable-size object.\"), _(\"\\\n-Attempts to access an object whose size is not a compile-time constant\\n\\\n-and exceeds this limit will cause an error.\"),\n-\t\t\t    NULL, NULL, &setlist, &showlist);\n-\n   add_info (\"exceptions\", info_exceptions_command,\n \t    _(\"\\\n List all Ada exception names.\\n\\"
    },
    {
      "sha": "0f52ba70649ad7ccbfd894ccf837ce7ef3b077a8",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=acbf4a58ef324e506cad9cc867a67164d2ca19d4",
      "patch": "@@ -149,8 +149,6 @@ struct ada_task_info\n   int base_cpu;\n };\n \n-extern void ada_ensure_varsize_limit (const struct type *type);\n-\n extern int ada_get_field_index (const struct type *type,\n \t\t\t\tconst char *field_name,\n \t\t\t\tint maybe_missing);"
    },
    {
      "sha": "e725cd3276ef3495e8fee55ca0763f1d9fb6e73f",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=acbf4a58ef324e506cad9cc867a67164d2ca19d4",
      "patch": "@@ -970,12 +970,6 @@ ada_val_print_ref (struct type *type, const gdb_byte *valaddr,\n   if (ada_is_tagged_type (value_type (deref_val), 1))\n     deref_val = ada_tag_value_at_base_address (deref_val);\n \n-  /* Make sure that the object does not have an unreasonable size\n-     before trying to print it.  This can happen for instance with\n-     references to dynamic objects whose contents is uninitialized\n-     (Eg: an array whose bounds are not set yet).  */\n-  ada_ensure_varsize_limit (value_type (deref_val));\n-\n   if (value_lazy (deref_val))\n     value_fetch_lazy (deref_val);\n "
    },
    {
      "sha": "7cba87ce41b99407b3fe4b453125abe903bc265d",
      "filename": "gdb/testsuite/gdb.ada/varsize_limit.exp",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/testsuite/gdb.ada/varsize_limit.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/testsuite/gdb.ada/varsize_limit.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/varsize_limit.exp?ref=acbf4a58ef324e506cad9cc867a67164d2ca19d4",
      "patch": "@@ -31,10 +31,13 @@ if ![runto \"vsizelim.adb:$bp_location\" ] then {\n   return\n }\n \n-gdb_test_no_output \"set varsize-limit 16\"\n+gdb_test \"set varsize-limit 16\" \\\n+    \"Warning: command 'set varsize-limit' is deprecated.\\r\\nUse 'set max-value-size'.\"\n \n gdb_test \"print small\" \" = \\\"1234567890\\\"\"\n \n-gdb_test \"print larger\" \"object size is larger than varsize-limit.*\"\n+gdb_test \"print larger\" \"more than max-value-size.*\"\n \n-gdb_test \"print name.all\" \"object size is larger than varsize-limit.*\"\n+gdb_test \"print name.all\" \"more than max-value-size.*\"\n+\n+gdb_test \"print ba.data(5)\" \" = 5\" \"print array element\""
    },
    {
      "sha": "8bf367cda0f8f833b1fa7bd2ebe2d325b4728832",
      "filename": "gdb/testsuite/gdb.ada/varsize_limit/vsizelim.adb",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/testsuite/gdb.ada/varsize_limit/vsizelim.adb",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/testsuite/gdb.ada/varsize_limit/vsizelim.adb",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/varsize_limit/vsizelim.adb?ref=acbf4a58ef324e506cad9cc867a67164d2ca19d4",
      "patch": "@@ -30,8 +30,20 @@ procedure VsizeLim is\n    Name_Str : String_Ptr := new String'(Larger);\n    Name : Big_String_Ptr := To_Ptr (Name_Str.all'Address);\n \n+   type Table is array (Positive range <>) of Integer;\n+   type Object (N : Integer) is record\n+       Data : Table (1 .. N);\n+   end record;\n+\n+   BA : Object := (N => 1_000_000, Data => (others => 0));\n+\n begin\n+   for I in 1 .. 10 loop\n+      BA.Data(I) := I;\n+   end loop;\n+\n    Do_Nothing (Small'Address); -- STOP\n    Do_Nothing (Larger'Address);\n    Do_Nothing (Name'Address);\n+   Do_Nothing (BA'Address);\n end VsizeLim;"
    },
    {
      "sha": "bb2adae0a51b1e68c7ea903df7228ffe09f2d079",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/acbf4a58ef324e506cad9cc867a67164d2ca19d4/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=acbf4a58ef324e506cad9cc867a67164d2ca19d4",
      "patch": "@@ -4326,6 +4326,16 @@ prevents future values, larger than this size, from being allocated.\"),\n \t\t\t    set_max_value_size,\n \t\t\t    show_max_value_size,\n \t\t\t    &setlist, &showlist);\n+  set_show_commands vsize_limit\n+    = add_setshow_zuinteger_unlimited_cmd (\"varsize-limit\", class_support,\n+\t\t\t\t\t   &max_value_size, _(\"\\\n+Set the maximum number of bytes allowed in a variable-size object.\"), _(\"\\\n+Show the maximum number of bytes allowed in a variable-size object.\"), _(\"\\\n+Attempts to access an object whose size is not a compile-time constant\\n\\\n+and exceeds this limit will cause an error.\"),\n+\t\t\t\t\t   NULL, NULL, &setlist, &showlist);\n+  deprecate_cmd (vsize_limit.set, \"set max-value-size\");\n+\n #if GDB_SELF_TEST\n   selftests::register_test (\"ranges_contain\", selftests::test_ranges_contain);\n   selftests::register_test (\"insert_into_bit_range_vector\","
    }
  ]
}