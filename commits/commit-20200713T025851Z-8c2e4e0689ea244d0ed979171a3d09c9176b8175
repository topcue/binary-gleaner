{
  "sha": "8c2e4e0689ea244d0ed979171a3d09c9176b8175",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGMyZTRlMDY4OWVhMjQ0ZDBlZDk3OTE3MWEzZDA5YzkxNzZiODE3NQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-07-13T02:58:51Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-07-13T02:58:51Z"
    },
    "message": "gdb: add accessors to struct dynamic_prop\n\nAdd setters, to ensure that the kind and value of the property are\nalways kept in sync (a caller can't forget one or the other).  Add\ngetters, such that we can assert that when a caller accesses a data bit\nof the property, the property is indeed of the corresponding kind.\n\nNote that because of the way `struct dynamic_prop` is allocated\ncurrently, we can't make the `m_kind` and `m_data` fields private.  That\nwould make the type non-default-constructible, and we would have to call\nthe constructor when allocating them.  However, I still prefixed them\nwith `m_` to indicate that they should not be accessed from outside the\nclass (and also to be able to use the name `kind` for the method).\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (struct dynamic_prop) <kind, set_undefined,\n\tconst_val, set_const_val, baton, set_locexpr, set_loclist,\n\tset_addr_offset, variant_parts, set_variant_parts,\n\toriginal_type, set_original_type>: New methods.\n\t<kind>: Rename to...\n\t<m_kind>: ... this.  Update all users to use the new methods\n\tinstead.\n\t<data>: Rename to...\n\t<m_data>: ... this.  Update all users to use the new methods\n\tinstead.\n\nChange-Id: Ib72a8eb440dfeb1a5421d0933334230d7f2478f9",
    "tree": {
      "sha": "8e1f4e0993f7f25a0946d64088015a88f883c8fd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8e1f4e0993f7f25a0946d64088015a88f883c8fd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8c2e4e0689ea244d0ed979171a3d09c9176b8175",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c2e4e0689ea244d0ed979171a3d09c9176b8175",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8c2e4e0689ea244d0ed979171a3d09c9176b8175",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c2e4e0689ea244d0ed979171a3d09c9176b8175/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7c6f271296319576fa00587928e5ff52ced9c1bb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7c6f271296319576fa00587928e5ff52ced9c1bb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7c6f271296319576fa00587928e5ff52ced9c1bb"
    }
  ],
  "stats": {
    "total": 318,
    "additions": 183,
    "deletions": 135
  },
  "files": [
    {
      "sha": "2b6905d276c9b69a1a2c77c311f7953281fc2c89",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -1,3 +1,16 @@\n+2020-07-12  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* gdbtypes.h (struct dynamic_prop) <kind, set_undefined,\n+\tconst_val, set_const_val, baton, set_locexpr, set_loclist,\n+\tset_addr_offset, variant_parts, set_variant_parts,\n+\toriginal_type, set_original_type>: New methods.\n+\t<kind>: Rename to...\n+\t<m_kind>: ... this.  Update all users to use the new methods\n+\tinstead.\n+\t<data>: Rename to...\n+\t<m_data>: ... this.  Update all users to use the new methods\n+\tinstead.\n+\n 2020-07-12  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.c (get_discrete_bounds): Return failure if"
    },
    {
      "sha": "062b9d8a21f7b60187c41d63dfb9df88480465b5",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -779,13 +779,13 @@ print_record_field_types (struct type *type, struct type *outer_type,\n   struct dynamic_prop *prop = type->dyn_prop (DYN_PROP_VARIANT_PARTS);\n   if (prop != nullptr)\n     {\n-      if (prop->kind == PROP_TYPE)\n+      if (prop->kind () == PROP_TYPE)\n \t{\n-\t  type = prop->data.original_type;\n+\t  type = prop->original_type ();\n \t  prop = type->dyn_prop (DYN_PROP_VARIANT_PARTS);\n \t}\n-      gdb_assert (prop->kind == PROP_VARIANT_PARTS);\n-      print_record_field_types_dynamic (*prop->data.variant_parts,\n+      gdb_assert (prop->kind () == PROP_VARIANT_PARTS);\n+      print_record_field_types_dynamic (*prop->variant_parts (),\n \t\t\t\t\t0, type->num_fields (),\n \t\t\t\t\ttype, stream, show, level, flags);\n       return type->num_fields ();"
    },
    {
      "sha": "5b6d731479a1739f91b30525c65b7fd12c65eb4a",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -774,7 +774,7 @@ read_array_type (struct ctf_context *ccp, ctf_id_t tid)\n   type = create_array_type (NULL, element_type, range_type);\n   if (ar.ctr_nelems <= 1)\t/* Check if undefined upper bound.  */\n     {\n-      TYPE_HIGH_BOUND_KIND (range_type) = PROP_UNDEFINED;\n+      range_type->bounds ()->high.set_undefined ();\n       TYPE_LENGTH (type) = 0;\n       TYPE_TARGET_STUB (type) = 1;\n     }"
    },
    {
      "sha": "866417eb1b103e9a10dfcb0ad4a8f6c57c8f55c6",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -2589,12 +2589,12 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n   if (frame == NULL && has_stack_frames ())\n     frame = get_selected_frame (NULL);\n \n-  switch (prop->kind)\n+  switch (prop->kind ())\n     {\n     case PROP_LOCEXPR:\n       {\n \tconst struct dwarf2_property_baton *baton\n-\t  = (const struct dwarf2_property_baton *) prop->data.baton;\n+\t  = (const struct dwarf2_property_baton *) prop->baton ();\n \tgdb_assert (baton->property_type != NULL);\n \n \tif (dwarf2_locexpr_baton_eval (&baton->locexpr, frame, addr_stack,\n@@ -2636,7 +2636,7 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n     case PROP_LOCLIST:\n       {\n \tstruct dwarf2_property_baton *baton\n-\t  = (struct dwarf2_property_baton *) prop->data.baton;\n+\t  = (struct dwarf2_property_baton *) prop->baton ();\n \tCORE_ADDR pc;\n \tconst gdb_byte *data;\n \tstruct value *val;\n@@ -2662,13 +2662,13 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n       break;\n \n     case PROP_CONST:\n-      *value = prop->data.const_val;\n+      *value = prop->const_val ();\n       return true;\n \n     case PROP_ADDR_OFFSET:\n       {\n \tstruct dwarf2_property_baton *baton\n-\t  = (struct dwarf2_property_baton *) prop->data.baton;\n+\t  = (struct dwarf2_property_baton *) prop->baton ();\n \tconst struct property_addr_info *pinfo;\n \tstruct value *val;\n \n@@ -2708,13 +2708,13 @@ dwarf2_compile_property_to_c (string_file *stream,\n \t\t\t      struct symbol *sym)\n {\n   struct dwarf2_property_baton *baton\n-    = (struct dwarf2_property_baton *) prop->data.baton;\n+    = (struct dwarf2_property_baton *) prop->baton ();\n   const gdb_byte *data;\n   size_t size;\n   dwarf2_per_cu_data *per_cu;\n   dwarf2_per_objfile *per_objfile;\n \n-  if (prop->kind == PROP_LOCEXPR)\n+  if (prop->kind () == PROP_LOCEXPR)\n     {\n       data = baton->locexpr.data;\n       size = baton->locexpr.size;\n@@ -2723,7 +2723,7 @@ dwarf2_compile_property_to_c (string_file *stream,\n     }\n   else\n     {\n-      gdb_assert (prop->kind == PROP_LOCLIST);\n+      gdb_assert (prop->kind () == PROP_LOCLIST);\n \n       data = dwarf2_find_location_expression (&baton->loclist, &size, pc);\n       per_cu = baton->loclist.per_cu;"
    },
    {
      "sha": "558fad74f804180a9969a1415ffa23957a8dcac6",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 29,
      "deletions": 40,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -9464,8 +9464,7 @@ alloc_rust_variant (struct obstack *obstack, struct type *type,\n     = new (storage) gdb::array_view<variant_part> (part, 1);\n \n   struct dynamic_prop prop;\n-  prop.kind = PROP_VARIANT_PARTS;\n-  prop.data.variant_parts = prop_value;\n+  prop.set_variant_parts (prop_value);\n \n   type->add_dyn_prop (DYN_PROP_VARIANT_PARTS, prop);\n }\n@@ -14959,10 +14958,9 @@ add_variant_property (struct field_info *fip, struct type *type,\n \t\t\t    fip->variant_parts);\n \n   struct dynamic_prop prop;\n-  prop.kind = PROP_VARIANT_PARTS;\n-  prop.data.variant_parts\n-    = ((gdb::array_view<variant_part> *)\n-       obstack_copy (&objfile->objfile_obstack, &parts, sizeof (parts)));\n+  prop.set_variant_parts ((gdb::array_view<variant_part> *)\n+\t\t\t  obstack_copy (&objfile->objfile_obstack, &parts,\n+\t\t\t\t\tsizeof (parts)));\n \n   type->add_dyn_prop (DYN_PROP_VARIANT_PARTS, prop);\n }\n@@ -17138,8 +17136,7 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n     {\n       struct dynamic_prop low_bound;\n \n-      low_bound.kind = PROP_CONST;\n-      low_bound.data.const_val = 1;\n+      low_bound.set_const_val (1);\n       range_type = create_range_type (NULL, index_type, &low_bound, &prop, 0);\n     }\n   char_type = language_string_char_type (cu->language_defn, gdbarch);\n@@ -17646,9 +17643,9 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t  baton->locexpr.is_reference = false;\n \t  break;\n \t}\n-      prop->data.baton = baton;\n-      prop->kind = PROP_LOCEXPR;\n-      gdb_assert (prop->data.baton != NULL);\n+\n+      prop->set_locexpr (baton);\n+      gdb_assert (prop->baton () != NULL);\n     }\n   else if (attr->form_is_ref ())\n     {\n@@ -17672,9 +17669,8 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t\tbaton = XOBNEW (obstack, struct dwarf2_property_baton);\n \t\tbaton->property_type = die_type (target_die, target_cu);\n \t\tfill_in_loclist_baton (cu, &baton->loclist, target_attr);\n-\t\tprop->data.baton = baton;\n-\t\tprop->kind = PROP_LOCLIST;\n-\t\tgdb_assert (prop->data.baton != NULL);\n+\t\tprop->set_loclist (baton);\n+\t\tgdb_assert (prop->baton () != NULL);\n \t      }\n \t    else if (target_attr->form_is_block ())\n \t      {\n@@ -17685,9 +17681,8 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t\tbaton->locexpr.size = DW_BLOCK (target_attr)->size;\n \t\tbaton->locexpr.data = DW_BLOCK (target_attr)->data;\n \t\tbaton->locexpr.is_reference = true;\n-\t\tprop->data.baton = baton;\n-\t\tprop->kind = PROP_LOCEXPR;\n-\t\tgdb_assert (prop->data.baton != NULL);\n+\t\tprop->set_locexpr (baton);\n+\t\tgdb_assert (prop->baton () != NULL);\n \t      }\n \t    else\n \t      {\n@@ -17709,17 +17704,13 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t\t\t\t\t\t      target_cu);\n \t      baton->offset_info.offset = offset;\n \t      baton->offset_info.type = die_type (target_die, target_cu);\n-\t      prop->data.baton = baton;\n-\t      prop->kind = PROP_ADDR_OFFSET;\n+\t      prop->set_addr_offset (baton);\n \t      break;\n \t    }\n \t}\n     }\n   else if (attr->form_is_constant ())\n-    {\n-      prop->data.const_val = attr->constant_value (0);\n-      prop->kind = PROP_CONST;\n-    }\n+    prop->set_const_val (attr->constant_value (0));\n   else\n     {\n       dwarf2_invalid_attrib_class_complaint (dwarf_form_name (attr->form),\n@@ -17819,37 +17810,35 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n   if (range_type)\n     return range_type;\n \n-  low.kind = PROP_CONST;\n-  high.kind = PROP_CONST;\n-  high.data.const_val = 0;\n+  high.set_const_val (0);\n \n   /* Set LOW_DEFAULT_IS_VALID if current language and DWARF version allow\n      omitting DW_AT_lower_bound.  */\n   switch (cu->language)\n     {\n     case language_c:\n     case language_cplus:\n-      low.data.const_val = 0;\n+      low.set_const_val (0);\n       low_default_is_valid = 1;\n       break;\n     case language_fortran:\n-      low.data.const_val = 1;\n+      low.set_const_val (1);\n       low_default_is_valid = 1;\n       break;\n     case language_d:\n     case language_objc:\n     case language_rust:\n-      low.data.const_val = 0;\n+      low.set_const_val (0);\n       low_default_is_valid = (cu->header.version >= 4);\n       break;\n     case language_ada:\n     case language_m2:\n     case language_pascal:\n-      low.data.const_val = 1;\n+      low.set_const_val (1);\n       low_default_is_valid = (cu->header.version >= 4);\n       break;\n     default:\n-      low.data.const_val = 0;\n+      low.set_const_val (0);\n       low_default_is_valid = 0;\n       break;\n     }\n@@ -17871,8 +17860,8 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n       if (attr_to_dynamic_prop (attr, die, cu, &high, base_type))\n \t{\n \t  /* If bounds are constant do the final calculation here.  */\n-\t  if (low.kind == PROP_CONST && high.kind == PROP_CONST)\n-\t    high.data.const_val = low.data.const_val + high.data.const_val - 1;\n+\t  if (low.kind () == PROP_CONST && high.kind () == PROP_CONST)\n+\t    high.set_const_val (low.const_val () + high.const_val () - 1);\n \t  else\n \t    high_bound_is_count = 1;\n \t}\n@@ -17905,12 +17894,12 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n      the base type is signed.  */\n   negative_mask =\n     -((ULONGEST) 1 << (TYPE_LENGTH (base_type) * TARGET_CHAR_BIT - 1));\n-  if (low.kind == PROP_CONST\n-      && !TYPE_UNSIGNED (base_type) && (low.data.const_val & negative_mask))\n-    low.data.const_val |= negative_mask;\n-  if (high.kind == PROP_CONST\n-      && !TYPE_UNSIGNED (base_type) && (high.data.const_val & negative_mask))\n-    high.data.const_val |= negative_mask;\n+  if (low.kind () == PROP_CONST\n+      && !TYPE_UNSIGNED (base_type) && (low.const_val () & negative_mask))\n+    low.set_const_val (low.const_val () | negative_mask);\n+  if (high.kind () == PROP_CONST\n+      && !TYPE_UNSIGNED (base_type) && (high.const_val () & negative_mask))\n+    high.set_const_val (high.const_val () | negative_mask);\n \n   /* Check for bit and byte strides.  */\n   struct dynamic_prop byte_stride_prop;\n@@ -17962,7 +17951,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   /* Ada expects an empty array on no boundary attributes.  */\n   if (attr == NULL && cu->language != language_ada)\n-    TYPE_HIGH_BOUND_KIND (range_type) = PROP_UNDEFINED;\n+    range_type->bounds ()->high.set_undefined ();\n \n   name = dwarf2_name (die, cu);\n   if (name)"
    },
    {
      "sha": "709574545928ef16f904cd908ae6246aa66d13c1",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 34,
      "deletions": 62,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -874,23 +874,23 @@ allocate_stub_method (struct type *type)\n bool\n operator== (const dynamic_prop &l, const dynamic_prop &r)\n {\n-  if (l.kind != r.kind)\n+  if (l.kind () != r.kind ())\n     return false;\n \n-  switch (l.kind)\n+  switch (l.kind ())\n     {\n     case PROP_UNDEFINED:\n       return true;\n     case PROP_CONST:\n-      return l.data.const_val == r.data.const_val;\n+      return l.const_val () == r.const_val ();\n     case PROP_ADDR_OFFSET:\n     case PROP_LOCEXPR:\n     case PROP_LOCLIST:\n-      return l.data.baton == r.data.baton;\n+      return l.baton () == r.baton ();\n     case PROP_VARIANT_PARTS:\n-      return l.data.variant_parts == r.data.variant_parts;\n+      return l.variant_parts () == r.variant_parts ();\n     case PROP_TYPE:\n-      return l.data.original_type == r.data.original_type;\n+      return l.original_type () == r.original_type ();\n     }\n \n   gdb_assert_not_reached (\"unhandled dynamic_prop kind\");\n@@ -940,21 +940,18 @@ create_range_type (struct type *result_type, struct type *index_type,\n   bounds->low = *low_bound;\n   bounds->high = *high_bound;\n   bounds->bias = bias;\n-\n-  /* Initialize the stride to be a constant, the value will already be zero\n-     thanks to the use of TYPE_ZALLOC above.  */\n-  bounds->stride.kind = PROP_CONST;\n+  bounds->stride.set_const_val (0);\n \n   result_type->set_bounds (bounds);\n \n-  if (low_bound->kind == PROP_CONST && low_bound->data.const_val >= 0)\n+  if (low_bound->kind () == PROP_CONST && low_bound->const_val () >= 0)\n     TYPE_UNSIGNED (result_type) = 1;\n \n   /* Ada allows the declaration of range types whose upper bound is\n      less than the lower bound, so checking the lower bound is not\n      enough.  Make sure we do not mark a range type whose upper bound\n      is negative as unsigned.  */\n-  if (high_bound->kind == PROP_CONST && high_bound->data.const_val < 0)\n+  if (high_bound->kind () == PROP_CONST && high_bound->const_val () < 0)\n     TYPE_UNSIGNED (result_type) = 0;\n \n   TYPE_ENDIANITY_NOT_DEFAULT (result_type)\n@@ -1002,11 +999,8 @@ create_static_range_type (struct type *result_type, struct type *index_type,\n {\n   struct dynamic_prop low, high;\n \n-  low.kind = PROP_CONST;\n-  low.data.const_val = low_bound;\n-\n-  high.kind = PROP_CONST;\n-  high.data.const_val = high_bound;\n+  low.set_const_val (low_bound);\n+  high.set_const_val (high_bound);\n \n   result_type = create_range_type (result_type, index_type, &low, &high, 0);\n \n@@ -1021,9 +1015,9 @@ has_static_range (const struct range_bounds *bounds)\n {\n   /* If the range doesn't have a defined stride then its stride field will\n      be initialized to the constant 0.  */\n-  return (bounds->low.kind == PROP_CONST\n-\t  && bounds->high.kind == PROP_CONST\n-\t  && bounds->stride.kind == PROP_CONST);\n+  return (bounds->low.kind () == PROP_CONST\n+\t  && bounds->high.kind () == PROP_CONST\n+\t  && bounds->stride.kind () == PROP_CONST);\n }\n \n \n@@ -1273,13 +1267,13 @@ create_array_type_with_stride (struct type *result_type,\n \t\t\t       unsigned int bit_stride)\n {\n   if (byte_stride_prop != NULL\n-      && byte_stride_prop->kind == PROP_CONST)\n+      && byte_stride_prop->kind () == PROP_CONST)\n     {\n       /* The byte stride is actually not dynamic.  Pretend we were\n \t called with bit_stride set instead of byte_stride_prop.\n \t This will give us the same result type, while avoiding\n \t the need to handle this as a special case.  */\n-      bit_stride = byte_stride_prop->data.const_val * 8;\n+      bit_stride = byte_stride_prop->const_val () * 8;\n       byte_stride_prop = NULL;\n     }\n \n@@ -1967,7 +1961,7 @@ array_type_has_dynamic_stride (struct type *type)\n {\n   struct dynamic_prop *prop = type->dyn_prop (DYN_PROP_BYTE_STRIDE);\n \n-  return (prop != NULL && prop->kind != PROP_CONST);\n+  return (prop != NULL && prop->kind () != PROP_CONST);\n }\n \n /* Worker for is_dynamic_type.  */\n@@ -1999,7 +1993,7 @@ is_dynamic_type_internal (struct type *type, int top_level)\n     return 1;\n \n   struct dynamic_prop *prop = type->dyn_prop (DYN_PROP_VARIANT_PARTS);\n-  if (prop != nullptr && prop->kind != PROP_TYPE)\n+  if (prop != nullptr && prop->kind () != PROP_TYPE)\n     return 1;\n \n   if (TYPE_HAS_DYNAMIC_LENGTH (type))\n@@ -2097,38 +2091,27 @@ resolve_dynamic_range (struct type *dyn_range_type,\n \n   const struct dynamic_prop *prop = &dyn_range_type->bounds ()->low;\n   if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n-    {\n-      low_bound.kind = PROP_CONST;\n-      low_bound.data.const_val = value;\n-    }\n+    low_bound.set_const_val (value);\n   else\n-    {\n-      low_bound.kind = PROP_UNDEFINED;\n-      low_bound.data.const_val = 0;\n-    }\n+    low_bound.set_undefined ();\n \n   prop = &dyn_range_type->bounds ()->high;\n   if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n     {\n-      high_bound.kind = PROP_CONST;\n-      high_bound.data.const_val = value;\n+      high_bound.set_const_val (value);\n \n       if (dyn_range_type->bounds ()->flag_upper_bound_is_count)\n-\thigh_bound.data.const_val\n-\t  = low_bound.data.const_val + high_bound.data.const_val - 1;\n+\thigh_bound.set_const_val\n+\t  (low_bound.const_val () + high_bound.const_val () - 1);\n     }\n   else\n-    {\n-      high_bound.kind = PROP_UNDEFINED;\n-      high_bound.data.const_val = 0;\n-    }\n+    high_bound.set_undefined ();\n \n   bool byte_stride_p = dyn_range_type->bounds ()->flag_is_byte_stride;\n   prop = &dyn_range_type->bounds ()->stride;\n   if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n     {\n-      stride.kind = PROP_CONST;\n-      stride.data.const_val = value;\n+      stride.set_const_val (value);\n \n       /* If we have a bit stride that is not an exact number of bytes then\n \t I really don't think this is going to work with current GDB, the\n@@ -2142,8 +2125,7 @@ resolve_dynamic_range (struct type *dyn_range_type,\n     }\n   else\n     {\n-      stride.kind = PROP_UNDEFINED;\n-      stride.data.const_val = 0;\n+      stride.set_undefined ();\n       byte_stride_p = true;\n     }\n \n@@ -2188,16 +2170,11 @@ resolve_dynamic_array_or_string (struct type *type,\n      will update the length of the array accordingly.  */\n   prop = TYPE_ALLOCATED_PROP (type);\n   if (prop != NULL && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n-    {\n-      TYPE_DYN_PROP_ADDR (prop) = value;\n-      TYPE_DYN_PROP_KIND (prop) = PROP_CONST;\n-    }\n+    prop->set_const_val (value);\n+\n   prop = TYPE_ASSOCIATED_PROP (type);\n   if (prop != NULL && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n-    {\n-      TYPE_DYN_PROP_ADDR (prop) = value;\n-      TYPE_DYN_PROP_KIND (prop) = PROP_CONST;\n-    }\n+    prop->set_const_val (value);\n \n   ary_dim = check_typedef (TYPE_TARGET_TYPE (elt_type));\n \n@@ -2447,14 +2424,13 @@ resolve_dynamic_struct (struct type *type,\n   resolved_type = copy_type (type);\n \n   dynamic_prop *variant_prop = resolved_type->dyn_prop (DYN_PROP_VARIANT_PARTS);\n-  if (variant_prop != nullptr && variant_prop->kind == PROP_VARIANT_PARTS)\n+  if (variant_prop != nullptr && variant_prop->kind () == PROP_VARIANT_PARTS)\n     {\n       compute_variant_fields (type, resolved_type, addr_stack,\n-\t\t\t      *variant_prop->data.variant_parts);\n+\t\t\t      *variant_prop->variant_parts ());\n       /* We want to leave the property attached, so that the Rust code\n \t can tell whether the type was originally an enum.  */\n-      variant_prop->kind = PROP_TYPE;\n-      variant_prop->data.original_type = type;\n+      variant_prop->set_original_type (type);\n     }\n   else\n     {\n@@ -2483,8 +2459,7 @@ resolve_dynamic_struct (struct type *type,\n \t  baton.locexpr = *TYPE_FIELD_DWARF_BLOCK (resolved_type, i);\n \n \t  struct dynamic_prop prop;\n-\t  prop.kind = PROP_LOCEXPR;\n-\t  prop.data.baton = &baton;\n+\t  prop.set_locexpr (&baton);\n \n \t  CORE_ADDR addr;\n \t  if (dwarf2_evaluate_property (&prop, nullptr, addr_stack, &addr,\n@@ -2642,10 +2617,7 @@ resolve_dynamic_type_internal (struct type *type,\n   prop = TYPE_DATA_LOCATION (resolved_type);\n   if (prop != NULL\n       && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n-    {\n-      TYPE_DYN_PROP_ADDR (prop) = value;\n-      TYPE_DYN_PROP_KIND (prop) = PROP_CONST;\n-    }\n+    prop->set_const_val (value);\n \n   return resolved_type;\n }"
    },
    {
      "sha": "5d9ed3972ff1c56fc6ec70fc931a430aa12b13fb",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 87,
      "deletions": 11,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -511,11 +511,87 @@ union dynamic_prop_data\n \n struct dynamic_prop\n {\n+  dynamic_prop_kind kind () const\n+  {\n+    return m_kind;\n+  }\n+\n+  void set_undefined ()\n+  {\n+    m_kind = PROP_UNDEFINED;\n+  }\n+\n+  LONGEST const_val () const\n+  {\n+    gdb_assert (m_kind == PROP_CONST);\n+\n+    return m_data.const_val;\n+  }\n+\n+  void set_const_val (LONGEST const_val)\n+  {\n+    m_kind = PROP_CONST;\n+    m_data.const_val = const_val;\n+  }\n+\n+  void *baton () const\n+  {\n+    gdb_assert (m_kind == PROP_LOCEXPR\n+\t\t|| m_kind == PROP_LOCLIST\n+\t\t|| m_kind == PROP_ADDR_OFFSET);\n+\n+    return m_data.baton;\n+  }\n+\n+  void set_locexpr (void *baton)\n+  {\n+    m_kind = PROP_LOCEXPR;\n+    m_data.baton = baton;\n+  }\n+\n+  void set_loclist (void *baton)\n+  {\n+    m_kind = PROP_LOCLIST;\n+    m_data.baton = baton;\n+  }\n+\n+  void set_addr_offset (void *baton)\n+  {\n+    m_kind = PROP_ADDR_OFFSET;\n+    m_data.baton = baton;\n+  }\n+\n+  const gdb::array_view<variant_part> *variant_parts () const\n+  {\n+    gdb_assert (m_kind == PROP_VARIANT_PARTS);\n+\n+    return m_data.variant_parts;\n+  }\n+\n+  void set_variant_parts (gdb::array_view<variant_part> *variant_parts)\n+  {\n+    m_kind = PROP_VARIANT_PARTS;\n+    m_data.variant_parts = variant_parts;\n+  }\n+\n+  struct type *original_type () const\n+  {\n+    gdb_assert (m_kind == PROP_TYPE);\n+\n+    return m_data.original_type;\n+  }\n+\n+  void set_original_type (struct type *original_type)\n+  {\n+    m_kind = PROP_TYPE;\n+    m_data.original_type = original_type;\n+  }\n+\n   /* Determine which field of the union dynamic_prop.data is used.  */\n-  enum dynamic_prop_kind kind;\n+  enum dynamic_prop_kind m_kind;\n \n   /* Storage for dynamic or static value.  */\n-  union dynamic_prop_data data;\n+  union dynamic_prop_data m_data;\n };\n \n /* Compare two dynamic_prop objects for equality.  dynamic_prop\n@@ -1519,19 +1595,19 @@ extern unsigned type_align (struct type *);\n extern bool set_type_align (struct type *, ULONGEST);\n \n #define TYPE_LOW_BOUND(range_type) \\\n-  ((range_type)->bounds ()->low.data.const_val)\n+  ((range_type)->bounds ()->low.const_val ())\n #define TYPE_HIGH_BOUND(range_type) \\\n-  ((range_type)->bounds ()->high.data.const_val)\n+  ((range_type)->bounds ()->high.const_val ())\n #define TYPE_LOW_BOUND_UNDEFINED(range_type) \\\n   (TYPE_LOW_BOUND_KIND(range_type) == PROP_UNDEFINED)\n #define TYPE_HIGH_BOUND_UNDEFINED(range_type) \\\n   (TYPE_HIGH_BOUND_KIND(range_type) == PROP_UNDEFINED)\n #define TYPE_HIGH_BOUND_KIND(range_type) \\\n-  ((range_type)->bounds ()->high.kind)\n+  ((range_type)->bounds ()->high.kind ())\n #define TYPE_LOW_BOUND_KIND(range_type) \\\n-  ((range_type)->bounds ()->low.kind)\n+  ((range_type)->bounds ()->low.kind ())\n #define TYPE_BIT_STRIDE(range_type) \\\n-  ((range_type)->bounds ()->stride.data.const_val \\\n+  ((range_type)->bounds ()->stride.const_val () \\\n    * ((range_type)->bounds ()->flag_is_byte_stride ? 8 : 1))\n \n /* Property accessors for the type data location.  */\n@@ -1540,9 +1616,9 @@ extern bool set_type_align (struct type *, ULONGEST);\n #define TYPE_DATA_LOCATION_BATON(thistype) \\\n   TYPE_DATA_LOCATION (thistype)->data.baton\n #define TYPE_DATA_LOCATION_ADDR(thistype) \\\n-  TYPE_DATA_LOCATION (thistype)->data.const_val\n+  (TYPE_DATA_LOCATION (thistype)->const_val ())\n #define TYPE_DATA_LOCATION_KIND(thistype) \\\n-  TYPE_DATA_LOCATION (thistype)->kind\n+  (TYPE_DATA_LOCATION (thistype)->kind ())\n #define TYPE_DYNAMIC_LENGTH(thistype) \\\n   ((thistype)->dyn_prop (DYN_PROP_BYTE_SIZE))\n \n@@ -1556,9 +1632,9 @@ extern bool set_type_align (struct type *, ULONGEST);\n #define TYPE_DYN_PROP_BATON(dynprop) \\\n   dynprop->data.baton\n #define TYPE_DYN_PROP_ADDR(dynprop) \\\n-  dynprop->data.const_val\n+  (dynprop->const_val ())\n #define TYPE_DYN_PROP_KIND(dynprop) \\\n-  dynprop->kind\n+  (dynprop->kind ())\n \n \n /* Accessors for struct range_bounds data attached to an array type's"
    },
    {
      "sha": "beff8b1ebde6c3a4fdd0f6f019152b5fe67e6d56",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -471,8 +471,7 @@ gnuv3_baseclass_offset (struct type *type, int index,\n       baton.locexpr = *TYPE_FIELD_DWARF_BLOCK (type, index);\n \n       struct dynamic_prop prop;\n-      prop.kind = PROP_LOCEXPR;\n-      prop.data.baton = &baton;\n+      prop.set_locexpr (&baton);\n \n       struct property_addr_info addr_stack;\n       addr_stack.type = type;"
    },
    {
      "sha": "d38372041d752e4c188c15de168c10ce6b8162f0",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -1736,9 +1736,9 @@ parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,\n       tp->set_num_fields (0);\n       tp->set_bounds (((struct range_bounds *)\n \t\t\tTYPE_ZALLOC (tp, sizeof (struct range_bounds))));\n-      TYPE_LOW_BOUND (tp) = AUX_GET_DNLOW (bigend, ax);\n+      tp->bounds ()->low.set_const_val (AUX_GET_DNLOW (bigend, ax));\n       ax++;\n-      TYPE_HIGH_BOUND (tp) = AUX_GET_DNHIGH (bigend, ax);\n+      tp->bounds ()->high.set_const_val (AUX_GET_DNHIGH (bigend, ax));\n       ax++;\n     }\n "
    },
    {
      "sha": "c98f3c5bf735bcf2a2567a3f0013bb0902c36368",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -350,7 +350,7 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n \t      maximum value.  */\n \t      bound_info = 0;\n \t      high_bound = TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1;\n-\t      TYPE_HIGH_BOUND (range) = high_bound;\n+\t      range->bounds ()->high.set_const_val (high_bound);\n \t    }\n \tmaybe_bad_bstring:\n \t  if (bound_info < 0)"
    },
    {
      "sha": "31126a24b153fa67cae3018a4ecc6332993f0cbe",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -653,8 +653,8 @@ rust_print_struct_def (struct type *type, const char *varstring,\n \t{\n \t  fputs_filtered (\"enum \", stream);\n \t  dynamic_prop *prop = type->dyn_prop (DYN_PROP_VARIANT_PARTS);\n-\t  if (prop != nullptr && prop->kind == PROP_TYPE)\n-\t    type = prop->data.original_type;\n+\t  if (prop != nullptr && prop->kind () == PROP_TYPE)\n+\t    type = prop->original_type ();\n \t}\n       else if (type->code () == TYPE_CODE_STRUCT)\n \tfputs_filtered (\"struct \", stream);"
    },
    {
      "sha": "fae3216ba65c2c78ac4c7689322435b958962685",
      "filename": "gdb/type-stack.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/type-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c2e4e0689ea244d0ed979171a3d09c9176b8175/gdb/type-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/type-stack.c?ref=8c2e4e0689ea244d0ed979171a3d09c9176b8175",
      "patch": "@@ -172,8 +172,7 @@ type_stack::follow_types (struct type *follow_type)\n \t  lookup_array_range_type (follow_type,\n \t\t\t\t   0, array_size >= 0 ? array_size - 1 : 0);\n \tif (array_size < 0)\n-\t  TYPE_HIGH_BOUND_KIND (follow_type->index_type ())\n-\t    = PROP_UNDEFINED;\n+\t  follow_type->index_type ()->bounds ()->high.set_undefined ();\n \tbreak;\n       case tp_function:\n \t/* FIXME-type-allocation: need a way to free this type when we are"
    }
  ]
}