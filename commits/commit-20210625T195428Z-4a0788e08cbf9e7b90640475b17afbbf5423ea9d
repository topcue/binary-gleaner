{
  "sha": "4a0788e08cbf9e7b90640475b17afbbf5423ea9d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGEwNzg4ZTA4Y2JmOWU3YjkwNjQwNDc1YjE3YWZiYmY1NDIzZWE5ZA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-04-01T13:51:24Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-06-25T19:54:28Z"
    },
    "message": "gdb: make struct output_source_filename_data more C++ like\n\nIn a future commit I'm going to be making some changes to the 'info\nsources' command.  While looking at the code I noticed that things\ncould be improved by making struct output_source_filename_data more\nC++ like (private member variables, and more member functions).\nThat's what this commit does.\n\nThe 'info sources' filename filtering is split out into a separate\nclass in this commit.  In a future commit this new filter\nclass (info_sources_filter) will move into the header file and be used\nfrom the MI code.\n\nThere should be no user visible changes after this commit.\n\ngdb/ChangeLog:\n\n\t* symtab.c (struct info_sources_filter): New.\n\t(info_sources_filter::info_sources_filter): New function.\n\t(info_sources_filter::matches): New function.\n\t(info_sources_filter::print): New function.\n\t(struct filename_partial_match_opts): Moved to later in the file\n\tand update the comment.\n\t(struct output_source_filename_data)\n\t<output_source_filename_data>: New constructor.  <regexp>: Delete,\n\tthis is now in info_sources_filter.  <c_regexp>: Delete, this is\n\tnow in info_sources_filter.  <reset_output>: New member function.\n\t<filename_seen_cache>: Rename to m_filename_seen_cache, change\n\tfrom being a pointer, to being an actual object.  <first>: Rename\n\tto m_first.  <print_header>: New member function. <partial_match>:\n\tDelete.\n\t(output_source_filename_data::output): Update now\n\tm_filename_seen_cache is no longer a pointer, and for other member\n\tvariable name changes. Add a header comment.\n\t(print_info_sources_header): Renamed to...\n\t(output_source_filename_data::print_header): ...this.  Update now\n\tit's a member function and to take account of member variable\n\trenaming.\n\t(info_sources_command): Add a header comment, delete stack local\n\tfilename_seen_cache, initialization of output_source_filename_data\n\tis now done by the constructor.  Call print_header member function\n\tinstead of print_info_sources_header, call reset_output member\n\tfunction instead of manually performing the reset.",
    "tree": {
      "sha": "cea651a3d1016f7362006833fc517eb7bc115f96",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cea651a3d1016f7362006833fc517eb7bc115f96"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4a0788e08cbf9e7b90640475b17afbbf5423ea9d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a0788e08cbf9e7b90640475b17afbbf5423ea9d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4a0788e08cbf9e7b90640475b17afbbf5423ea9d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a0788e08cbf9e7b90640475b17afbbf5423ea9d/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fc4d5ebf8f8fa30ae3f5c26270df0163ad72000c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fc4d5ebf8f8fa30ae3f5c26270df0163ad72000c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fc4d5ebf8f8fa30ae3f5c26270df0163ad72000c"
    }
  ],
  "stats": {
    "total": 353,
    "additions": 247,
    "deletions": 106
  },
  "files": [
    {
      "sha": "f4805f8efeeaf73eec1391b4722df183fc3712c4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a0788e08cbf9e7b90640475b17afbbf5423ea9d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a0788e08cbf9e7b90640475b17afbbf5423ea9d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4a0788e08cbf9e7b90640475b17afbbf5423ea9d",
      "patch": "@@ -1,3 +1,32 @@\n+2021-06-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* symtab.c (struct info_sources_filter): New.\n+\t(info_sources_filter::info_sources_filter): New function.\n+\t(info_sources_filter::matches): New function.\n+\t(info_sources_filter::print): New function.\n+\t(struct filename_partial_match_opts): Moved to later in the file\n+\tand update the comment.\n+\t(struct output_source_filename_data)\n+\t<output_source_filename_data>: New constructor.  <regexp>: Delete,\n+\tthis is now in info_sources_filter.  <c_regexp>: Delete, this is\n+\tnow in info_sources_filter.  <reset_output>: New member function.\n+\t<filename_seen_cache>: Rename to m_filename_seen_cache, change\n+\tfrom being a pointer, to being an actual object.  <first>: Rename\n+\tto m_first.  <print_header>: New member function. <partial_match>:\n+\tDelete.\n+\t(output_source_filename_data::output): Update now\n+\tm_filename_seen_cache is no longer a pointer, and for other member\n+\tvariable name changes. Add a header comment.\n+\t(print_info_sources_header): Renamed to...\n+\t(output_source_filename_data::print_header): ...this.  Update now\n+\tit's a member function and to take account of member variable\n+\trenaming.\n+\t(info_sources_command): Add a header comment, delete stack local\n+\tfilename_seen_cache, initialization of output_source_filename_data\n+\tis now done by the constructor.  Call print_header member function\n+\tinstead of print_info_sources_header, call reset_output member\n+\tfunction instead of manually performing the reset.\n+\n 2021-06-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* dwarf2/read.c (struct dwarf2_base_index_functions)"
    },
    {
      "sha": "2ff79e0cddfc544f8abc83db2c1152942c57b559",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 218,
      "deletions": 106,
      "changes": 324,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a0788e08cbf9e7b90640475b17afbbf5423ea9d/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a0788e08cbf9e7b90640475b17afbbf5423ea9d/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=4a0788e08cbf9e7b90640475b17afbbf5423ea9d",
      "patch": "@@ -4200,46 +4200,190 @@ operator_chars (const char *p, const char **end)\n }\n \f\n \n-/* What part to match in a file name.  */\n-\n-struct filename_partial_match_opts\n+/* Class used to encapsulate the filename filtering for the \"info sources\"\n+   command.  */\n+struct info_sources_filter\n {\n-  /* Only match the directory name part.   */\n-  bool dirname = false;\n+  /* If filename filtering is being used (see M_C_REGEXP) then which part\n+     of the filename is being filtered against?  */\n+  enum class match_on\n+  {\n+    /* Match against the full filename.  */\n+    FULLNAME,\n \n-  /* Only match the basename part.  */\n-  bool basename = false;\n+    /* Match only against the directory part of the full filename.  */\n+    DIRNAME,\n+\n+    /* Match only against the basename part of the full filename.  */\n+    BASENAME\n+  };\n+\n+  /* Create a filter of MATCH_TYPE using regular expression REGEXP.  If\n+     REGEXP is nullptr then all files will match the filter and MATCH_TYPE\n+     is ignored.\n+\n+     The string pointed too by REGEXP must remain live and unchanged for\n+     this lifetime of this object as the object only retains a copy of the\n+     pointer.  */\n+  info_sources_filter (match_on match_type, const char *regexp);\n+\n+  DISABLE_COPY_AND_ASSIGN (info_sources_filter);\n+\n+  /* Does FULLNAME match the filter defined by this object, return true if\n+     it does, otherwise, return false.  If there is no filtering defined\n+     then this function will always return true.  */\n+  bool matches (const char *fullname) const;\n+\n+  /* Print a single line describing this filter, used as part of the \"info\n+     sources\" command output.  If there is no filter in place then nothing\n+     is printed.  */\n+  void print () const;\n+\n+private:\n+\n+  /* The type of filtering in place.  */\n+  match_on m_match_type;\n+\n+  /* Points to the original regexp used to create this filter.  */\n+  const char *m_regexp;\n+\n+  /* A compiled version of M_REGEXP.  This object is only given a value if\n+     M_REGEXP is not nullptr and is not the empty string.  */\n+  gdb::optional<compiled_regex> m_c_regexp;\n };\n \n-/* Data structure to maintain printing state for output_source_filename.  */\n+/* See class declaration.  */\n \n-struct output_source_filename_data\n+info_sources_filter::info_sources_filter (match_on match_type,\n+                                          const char *regexp)\n+  : m_match_type (match_type),\n+    m_regexp (regexp)\n {\n-  /* Output only filenames matching REGEXP.  */\n-  std::string regexp;\n-  gdb::optional<compiled_regex> c_regexp;\n-  /* Possibly only match a part of the filename.  */\n-  filename_partial_match_opts partial_match;\n+  /* Setup the compiled regular expression M_C_REGEXP based on M_REGEXP.  */\n+  if (m_regexp != nullptr && *m_regexp != '\\0')\n+    {\n+      gdb_assert (m_regexp != nullptr);\n \n+      int cflags = REG_NOSUB;\n+#ifdef HAVE_CASE_INSENSITIVE_FILE_SYSTEM\n+      cflags |= REG_ICASE;\n+#endif\n+      m_c_regexp.emplace (m_regexp, cflags, _(\"Invalid regexp\"));\n+    }\n+}\n \n-  /* Cache of what we've seen so far.  */\n-  struct filename_seen_cache *filename_seen_cache;\n+/* See class declaration.  */\n \n-  /* Flag of whether we're printing the first one.  */\n-  int first;\n+bool\n+info_sources_filter::matches (const char *fullname) const\n+{\n+  /* Does it match regexp?  */\n+  if (m_c_regexp.has_value ())\n+    {\n+      const char *to_match;\n+      std::string dirname;\n+\n+      switch (m_match_type)\n+        {\n+        case match_on::DIRNAME:\n+          dirname = ldirname (fullname);\n+          to_match = dirname.c_str ();\n+          break;\n+        case match_on::BASENAME:\n+          to_match = lbasename (fullname);\n+          break;\n+        case match_on::FULLNAME:\n+          to_match = fullname;\n+          break;\n+        }\n+\n+      if (m_c_regexp->exec (to_match, 0, NULL, 0) != 0)\n+        return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* See class declaration.  */\n+\n+void\n+info_sources_filter::print () const\n+{\n+  if (m_c_regexp.has_value ())\n+    {\n+      gdb_assert (m_regexp != nullptr);\n+\n+      switch (m_match_type)\n+\t{\n+\tcase match_on::DIRNAME:\n+\t  printf_filtered (_(\"(dirname matching regular expression \\\"%s\\\")\"),\n+\t\t\t   m_regexp);\n+\t  break;\n+\tcase match_on::BASENAME:\n+\t  printf_filtered (_(\"(basename matching regular expression \\\"%s\\\")\"),\n+\t\t\t   m_regexp);\n+\t  break;\n+\tcase match_on::FULLNAME:\n+\t  printf_filtered (_(\"(filename matching regular expression \\\"%s\\\")\"),\n+\t\t\t   m_regexp);\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Data structure to maintain the state used for printing the results of\n+   the 'info sources' command.  */\n+\n+struct output_source_filename_data\n+{\n+  /* Create an object for displaying the results of the 'info sources'\n+     command.  FILTER must remain valid and unchanged for the lifetime of\n+     this object as this object retains a reference to FILTER.  */\n+  output_source_filename_data (const info_sources_filter &filter)\n+    : m_filter (filter)\n+  { /* Nothing.  */ }\n+\n+  DISABLE_COPY_AND_ASSIGN (output_source_filename_data);\n+\n+  /* Reset enough state of this object so we can match against a new set of\n+     files.  The existing regular expression is retained though.  */\n+  void reset_output ()\n+  {\n+    m_first = true;\n+    m_filename_seen_cache.clear ();\n+  }\n \n-  /* Worker for sources_info.  Force line breaks at ,'s.\n-     NAME is the name to print.  */\n+  /* Worker for sources_info.  Force line breaks at ,'s.  NAME is the name\n+     to print.  */\n   void output (const char *name);\n \n+  /* Prints the header messages for the source files that will be printed\n+     with the matching info present in the current object state.\n+     SYMBOL_MSG is a message that describes what will or has been done with\n+     the symbols of the matching source files.  */\n+  void print_header (const char *symbol_msg);\n+\n   /* An overload suitable for use as a callback to\n      quick_symbol_functions::map_symbol_filenames.  */\n   void operator() (const char *filename, const char *fullname)\n   {\n     output (fullname != nullptr ? fullname : filename);\n   }\n+\n+private:\n+\n+  /* Flag of whether we're printing the first one.  */\n+  bool m_first = true;\n+\n+  /* Cache of what we've seen so far.  */\n+  filename_seen_cache m_filename_seen_cache;\n+\n+  /* How source filename should be filtered.  */\n+  const info_sources_filter &m_filter;\n };\n \n+/* See comment in class declaration above.  */\n+\n void\n output_source_filename_data::output (const char *name)\n {\n@@ -4252,42 +4396,45 @@ output_source_filename_data::output (const char *name)\n      situation.  I'm not sure whether this can also happen for\n      symtabs; it doesn't hurt to check.  */\n \n-  /* Was NAME already seen?  */\n-  if (filename_seen_cache->seen (name))\n-    {\n-      /* Yes; don't print it again.  */\n-      return;\n-    }\n-\n-  /* Does it match regexp?  */\n-  if (c_regexp.has_value ())\n-    {\n-      const char *to_match;\n-      std::string dirname;\n-\n-      if (partial_match.dirname)\n-\t{\n-\t  dirname = ldirname (name);\n-\t  to_match = dirname.c_str ();\n-\t}\n-      else if (partial_match.basename)\n-\tto_match = lbasename (name);\n-      else\n-\tto_match = name;\n+  /* Was NAME already seen?  If so, then don't print it again.  */\n+  if (m_filename_seen_cache.seen (name))\n+    return;\n \n-      if (c_regexp->exec (to_match, 0, NULL, 0) != 0)\n-\treturn;\n-    }\n+  /* If the filter rejects this file then don't print it.  */\n+  if (!m_filter.matches (name))\n+    return;\n \n   /* Print it and reset *FIRST.  */\n-  if (! first)\n+  if (!m_first)\n     printf_filtered (\", \");\n-  first = 0;\n+  m_first = false;\n \n   wrap_here (\"\");\n   fputs_styled (name, file_name_style.style (), gdb_stdout);\n }\n \n+/* See comment is class declaration above.  */\n+\n+void\n+output_source_filename_data::print_header (const char *symbol_msg)\n+{\n+  puts_filtered (symbol_msg);\n+  m_filter.print ();\n+  puts_filtered (\"\\n\");\n+}\n+\n+/* For the 'info sources' command, what part of the file names should we be\n+   matching the user supplied regular expression against?  */\n+\n+struct filename_partial_match_opts\n+{\n+  /* Only match the directory name part.   */\n+  bool dirname = false;\n+\n+  /* Only match the basename part.  */\n+  bool basename = false;\n+};\n+\n using isrc_flag_option_def\n   = gdb::option::flag_option_def<filename_partial_match_opts>;\n \n@@ -4316,31 +4463,6 @@ make_info_sources_options_def_group (filename_partial_match_opts *isrc_opts)\n   return {{info_sources_option_defs}, isrc_opts};\n }\n \n-/* Prints the header message for the source files that will be printed\n-   with the matching info present in DATA.  SYMBOL_MSG is a message\n-   that tells what will or has been done with the symbols of the\n-   matching source files.  */\n-\n-static void\n-print_info_sources_header (const char *symbol_msg,\n-\t\t\t   const struct output_source_filename_data *data)\n-{\n-  puts_filtered (symbol_msg);\n-  if (!data->regexp.empty ())\n-    {\n-      if (data->partial_match.dirname)\n-\tprintf_filtered (_(\"(dirname matching regular expression \\\"%s\\\")\"),\n-\t\t\t data->regexp.c_str ());\n-      else if (data->partial_match.basename)\n-\tprintf_filtered (_(\"(basename matching regular expression \\\"%s\\\")\"),\n-\t\t\t data->regexp.c_str ());\n-      else\n-\tprintf_filtered (_(\"(filename matching regular expression \\\"%s\\\")\"),\n-\t\t\t data->regexp.c_str ());\n-    }\n-  puts_filtered (\"\\n\");\n-}\n-\n /* Completer for \"info sources\".  */\n \n static void\n@@ -4354,49 +4476,41 @@ info_sources_command_completer (cmd_list_element *ignore,\n     return;\n }\n \n+/* Implement the 'info sources' command.  */\n+\n static void\n info_sources_command (const char *args, int from_tty)\n {\n-  struct output_source_filename_data data;\n-\n   if (!have_full_symbols () && !have_partial_symbols ())\n-    {\n-      error (_(\"No symbol table is loaded.  Use the \\\"file\\\" command.\"));\n-    }\n-\n-  filename_seen_cache filenames_seen;\n-\n-  auto group = make_info_sources_options_def_group (&data.partial_match);\n+    error (_(\"No symbol table is loaded.  Use the \\\"file\\\" command.\"));\n \n+  filename_partial_match_opts match_opts;\n+  auto group = make_info_sources_options_def_group (&match_opts);\n   gdb::option::process_options\n     (&args, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_ERROR, group);\n \n-  if (args != NULL && *args != '\\000')\n-    data.regexp = args;\n+  if (match_opts.dirname && match_opts.basename)\n+    error (_(\"You cannot give both -basename and -dirname to 'info sources'.\"));\n \n-  data.filename_seen_cache = &filenames_seen;\n-  data.first = 1;\n+  const char *regex = nullptr;\n+  if (args != nullptr && *args != '\\000')\n+    regex = args;\n \n-  if (data.partial_match.dirname && data.partial_match.basename)\n-    error (_(\"You cannot give both -basename and -dirname to 'info sources'.\"));\n-  if ((data.partial_match.dirname || data.partial_match.basename)\n-      && data.regexp.empty ())\n-     error (_(\"Missing REGEXP for 'info sources'.\"));\n+  if ((match_opts.dirname || match_opts.basename) && regex == nullptr)\n+    error (_(\"Missing REGEXP for 'info sources'.\"));\n \n-  if (data.regexp.empty ())\n-    data.c_regexp.reset ();\n+  info_sources_filter::match_on match_type;\n+  if (match_opts.dirname)\n+    match_type = info_sources_filter::match_on::DIRNAME;\n+  else if (match_opts.basename)\n+    match_type = info_sources_filter::match_on::BASENAME;\n   else\n-    {\n-      int cflags = REG_NOSUB;\n-#ifdef HAVE_CASE_INSENSITIVE_FILE_SYSTEM\n-      cflags |= REG_ICASE;\n-#endif\n-      data.c_regexp.emplace (data.regexp.c_str (), cflags,\n-\t\t\t     _(\"Invalid regexp\"));\n-    }\n+    match_type = info_sources_filter::match_on::FULLNAME;\n+\n+  info_sources_filter filter (match_type, regex);\n+  output_source_filename_data data (filter);\n \n-  print_info_sources_header\n-    (_(\"Source files for which symbols have been read in:\\n\"), &data);\n+  data.print_header (_(\"Source files for which symbols have been read in:\\n\"));\n \n   for (objfile *objfile : current_program_space->objfiles ())\n     {\n@@ -4412,11 +4526,9 @@ info_sources_command (const char *args, int from_tty)\n     }\n   printf_filtered (\"\\n\\n\");\n \n-  print_info_sources_header\n-    (_(\"Source files for which symbols will be read in on demand:\\n\"), &data);\n+  data.print_header (_(\"Source files for which symbols will be read in on demand:\\n\"));\n \n-  filenames_seen.clear ();\n-  data.first = 1;\n+  data.reset_output ();\n   map_symbol_filenames (data, true /*need_fullname*/);\n   printf_filtered (\"\\n\");\n }"
    }
  ]
}