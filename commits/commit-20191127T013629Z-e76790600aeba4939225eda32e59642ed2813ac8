{
  "sha": "e76790600aeba4939225eda32e59642ed2813ac8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTc2NzkwNjAwYWViYTQ5MzkyMjVlZGEzMmU1OTY0MmVkMjgxM2FjOA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-11-26T12:02:51Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-11-27T01:36:29Z"
    },
    "message": "PR23652, Use symbols from debug bfd for _bfd_elf_find_function\n\nSometimes DWARF info for a function is incomplete, and the function\ncan be retrieved by examining symbols.  However, when separate debug\nfiles are used it may be that the original file is completely\nstripped of symbols.  This patch teaches BFD to look at symbols from\nthe debug file in that case.\n\nThe patch also removes arm_elf_find_function, instead implementing\nelf_backend_maybe_function_sym.  arm_elf_find_function was written\nbefore the generic _bfd_elf_find_function called maybe_function_sym.\naarch64 copied arm, so that file gets the same treatment.  There is\nsome chance this will speed up arm and aarch64 lookup of function/line.\n\n\tPR 23652\n\t* dwarf2.c (_bfd_dwarf2_stash_syms): New function.\n\t(_bfd_dwarf2_find_nearest_line): Use it here, passing syms to\n\t_bfd_elf_find_function.  Call _bfd_elf_find_function in cases\n\twhere _bfd_elf_find_nearest_line would do so.\n\t* elf.c (_bfd_elf_find_nearest_line): Omit _bfd_elf_find_function\n\tfor dwarf2.\n\t* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Similarly.  Tidy.\n\t* elf32-arm.c (elf32_arm_maybe_function_sym): New function.\n\t(elf_backend_maybe_function_sym): Define.\n\t(arm_elf_find_function, elf32_arm_find_nearest_line): Delete.\n\t(bfd_elf32_find_nearest_line): Don't define.\n\t* elfnn-aarch64.c (elfNN_aarch64_maybe_function_sym): New function.\n\t(elf_backend_maybe_function_sym): Define.\n\t(aarch64_elf_find_function, elfNN_aarch64_find_nearest_line): Delete.\n\t(bfd_elfNN_find_nearest_line): Don't define.",
    "tree": {
      "sha": "e94950e51c433cfe5c73ab0dd3224f40451f0c8d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e94950e51c433cfe5c73ab0dd3224f40451f0c8d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e76790600aeba4939225eda32e59642ed2813ac8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e76790600aeba4939225eda32e59642ed2813ac8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e76790600aeba4939225eda32e59642ed2813ac8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e76790600aeba4939225eda32e59642ed2813ac8/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "96e2dbda089775359b130e16a337c169d67abc6b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/96e2dbda089775359b130e16a337c169d67abc6b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/96e2dbda089775359b130e16a337c169d67abc6b"
    }
  ],
  "stats": {
    "total": 400,
    "additions": 147,
    "deletions": 253
  },
  "files": [
    {
      "sha": "4a0852e577d314ab19d762c625d52e2916c0dbc8",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e76790600aeba4939225eda32e59642ed2813ac8/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e76790600aeba4939225eda32e59642ed2813ac8/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=e76790600aeba4939225eda32e59642ed2813ac8",
      "patch": "@@ -1,3 +1,22 @@\n+2019-11-27  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 23652\n+\t* dwarf2.c (_bfd_dwarf2_stash_syms): New function.\n+\t(_bfd_dwarf2_find_nearest_line): Use it here, passing syms to\n+\t_bfd_elf_find_function.  Call _bfd_elf_find_function in cases\n+\twhere _bfd_elf_find_nearest_line would do so.\n+\t* elf.c (_bfd_elf_find_nearest_line): Omit _bfd_elf_find_function\n+\tfor dwarf2.\n+\t* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Similarly.  Tidy.\n+\t* elf32-arm.c (elf32_arm_maybe_function_sym): New function.\n+\t(elf_backend_maybe_function_sym): Define.\n+\t(arm_elf_find_function, elf32_arm_find_nearest_line): Delete.\n+\t(bfd_elf32_find_nearest_line): Don't define.\n+\t* elfnn-aarch64.c (elfNN_aarch64_maybe_function_sym): New function.\n+\t(elf_backend_maybe_function_sym): Define.\n+\t(aarch64_elf_find_function, elfNN_aarch64_find_nearest_line): Delete.\n+\t(bfd_elfNN_find_nearest_line): Don't define.\n+\n 2019-11-27  Alan Modra  <amodra@gmail.com>\n \n \t* elf32-sh.c (sh_reloc): Use a bfd_vma insn."
    },
    {
      "sha": "e42483a535ab334dca2bbf50e35f191536b26953",
      "filename": "bfd/dwarf2.c",
      "status": "modified",
      "additions": 51,
      "deletions": 7,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e76790600aeba4939225eda32e59642ed2813ac8/bfd/dwarf2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e76790600aeba4939225eda32e59642ed2813ac8/bfd/dwarf2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf2.c?ref=e76790600aeba4939225eda32e59642ed2813ac8",
      "patch": "@@ -3894,6 +3894,40 @@ set_debug_vma (bfd *orig_bfd, bfd *debug_bfd)\n     }\n }\n \n+/* If the dwarf2 info was found in a separate debug file, return the\n+   debug file section corresponding to the section in the original file\n+   and the debug file symbols.  */\n+\n+static void\n+_bfd_dwarf2_stash_syms (struct dwarf2_debug *stash, bfd *abfd,\n+\t\t\tasection **sec, asymbol ***syms)\n+{\n+  if (stash->bfd_ptr != abfd)\n+    {\n+      asection *s, *d;\n+\n+      if (*sec == NULL)\n+\t{\n+\t  *syms = stash->syms;\n+\t  return;\n+\t}\n+\n+      for (s = abfd->sections, d = stash->bfd_ptr->sections;\n+\t   s != NULL && d != NULL;\n+\t   s = s->next, d = d->next)\n+\t{\n+\t  if ((d->flags & SEC_DEBUGGING) != 0)\n+\t    break;\n+\t  if (s == *sec\n+\t      && strcmp (s->name, d->name) == 0)\n+\t    {\n+\t      *sec = d;\n+\t      *syms = stash->syms;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Unset vmas for adjusted sections in STASH.  */\n \n static void\n@@ -4888,16 +4922,26 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,\n     }\n \n  done:\n-  if (function)\n+  if (functionname_ptr && function && function->is_linkage)\n+    *functionname_ptr = function->name;\n+  else if (functionname_ptr\n+\t   && ((found && !*functionname_ptr)\n+\t       || (function && !function->is_linkage)))\n     {\n-      if (!function->is_linkage)\n+      asymbol *fun;\n+      asymbol **syms = symbols;\n+      asection *sec = section;\n+\n+      if (symbols == NULL || *symbols == NULL)\n+\t_bfd_dwarf2_stash_syms (stash, abfd, &sec, &syms);\n+      fun = _bfd_elf_find_function (abfd, syms, sec, offset,\n+\t\t\t\t    *filename_ptr ? NULL : filename_ptr,\n+\t\t\t\t    functionname_ptr);\n+\n+      if (function && !function->is_linkage)\n \t{\n-\t  asymbol *fun;\n \t  bfd_vma sec_vma;\n \n-\t  fun = _bfd_elf_find_function (abfd, symbols, section, offset,\n-\t\t\t\t\t*filename_ptr ? NULL : filename_ptr,\n-\t\t\t\t\tfunctionname_ptr);\n \t  sec_vma = section->vma;\n \t  if (section->output_section != NULL)\n \t    sec_vma = section->output_section->vma + section->output_offset;\n@@ -4908,8 +4952,8 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,\n \t     to stop a repeated search of symbols.  */\n \t  function->is_linkage = TRUE;\n \t}\n-      *functionname_ptr = function->name;\n     }\n+\n   if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)\n     unset_sections (stash);\n "
    },
    {
      "sha": "1aa2603ee8ce010377c7db66dd81118cc1dda28c",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e76790600aeba4939225eda32e59642ed2813ac8/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e76790600aeba4939225eda32e59642ed2813ac8/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=e76790600aeba4939225eda32e59642ed2813ac8",
      "patch": "@@ -9030,10 +9030,11 @@ _bfd_elf_find_nearest_line (bfd *abfd,\n \t\t\t\t     filename_ptr, functionname_ptr,\n \t\t\t\t     line_ptr, discriminator_ptr,\n \t\t\t\t     dwarf_debug_sections,\n-\t\t\t\t     &elf_tdata (abfd)->dwarf2_find_line_info)\n-      || _bfd_dwarf1_find_nearest_line (abfd, symbols, section, offset,\n-\t\t\t\t\tfilename_ptr, functionname_ptr,\n-\t\t\t\t\tline_ptr))\n+\t\t\t\t     &elf_tdata (abfd)->dwarf2_find_line_info))\n+    return TRUE;\n+\n+  if (_bfd_dwarf1_find_nearest_line (abfd, symbols, section, offset,\n+\t\t\t\t     filename_ptr, functionname_ptr, line_ptr))\n     {\n       if (!*functionname_ptr)\n \t_bfd_elf_find_function (abfd, symbols, section, offset,"
    },
    {
      "sha": "37b5b64dc601fc258bae6e5596137eea587f94c1",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 30,
      "deletions": 111,
      "changes": 141,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e76790600aeba4939225eda32e59642ed2813ac8/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e76790600aeba4939225eda32e59642ed2813ac8/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=e76790600aeba4939225eda32e59642ed2813ac8",
      "patch": "@@ -16040,125 +16040,44 @@ elf32_arm_is_target_special_symbol (bfd * abfd ATTRIBUTE_UNUSED, asymbol * sym)\n \t\t\t\t\t BFD_ARM_SPECIAL_SYM_TYPE_ANY);\n }\n \n-/* This is a version of _bfd_elf_find_function() from dwarf2.c except that\n-   ARM mapping symbols are ignored when looking for function names\n-   and STT_ARM_TFUNC is considered to a function type.  */\n+/* If the ELF symbol SYM might be a function in SEC, return the\n+   function size and set *CODE_OFF to the function's entry point,\n+   otherwise return zero.  */\n \n-static bfd_boolean\n-arm_elf_find_function (bfd *\t     abfd,\n-\t\t       asymbol **    symbols,\n-\t\t       asection *    section,\n-\t\t       bfd_vma\t     offset,\n-\t\t       const char ** filename_ptr,\n-\t\t       const char ** functionname_ptr)\n-{\n-  const char * filename = NULL;\n-  asymbol * func = NULL;\n-  bfd_vma low_func = 0;\n-  asymbol ** p;\n-\n-  if (symbols == NULL)\n-    return FALSE;\n-\n-  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)\n-    return FALSE;\n-\n-  for (p = symbols; *p != NULL; p++)\n-    {\n-      elf_symbol_type *q;\n+static bfd_size_type\n+elf32_arm_maybe_function_sym (const asymbol *sym, asection *sec,\n+\t\t\t      bfd_vma *code_off)\n+{\n+  bfd_size_type size;\n \n-      q = (elf_symbol_type *) *p;\n+  if ((sym->flags & (BSF_SECTION_SYM | BSF_FILE | BSF_OBJECT\n+\t\t     | BSF_THREAD_LOCAL | BSF_RELC | BSF_SRELC)) != 0\n+      || sym->section != sec)\n+    return 0;\n \n-      switch (ELF_ST_TYPE (q->internal_elf_sym.st_info))\n-\t{\n-\tdefault:\n-\t  break;\n-\tcase STT_FILE:\n-\t  filename = bfd_asymbol_name (&q->symbol);\n-\t  break;\n+  if (!(sym->flags & BSF_SYNTHETIC))\n+    switch (ELF_ST_TYPE (((elf_symbol_type *) sym)->internal_elf_sym.st_info))\n+      {\n \tcase STT_FUNC:\n \tcase STT_ARM_TFUNC:\n \tcase STT_NOTYPE:\n-\t  /* Skip mapping symbols.  */\n-\t  if ((q->symbol.flags & BSF_LOCAL)\n-\t      && bfd_is_arm_special_symbol_name (q->symbol.name,\n-\t\t    BFD_ARM_SPECIAL_SYM_TYPE_ANY))\n-\t    continue;\n-\t  /* Fall through.  */\n-\t  if (bfd_asymbol_section (&q->symbol) == section\n-\t      && q->symbol.value >= low_func\n-\t      && q->symbol.value <= offset)\n-\t    {\n-\t      func = (asymbol *) q;\n-\t      low_func = q->symbol.value;\n-\t    }\n \t  break;\n-\t}\n-    }\n-\n-  if (func == NULL)\n-    return FALSE;\n-\n-  if (filename_ptr)\n-    *filename_ptr = filename;\n-  if (functionname_ptr)\n-    *functionname_ptr = bfd_asymbol_name (func);\n-\n-  return TRUE;\n-}\n-\n-\n-/* Find the nearest line to a particular section and offset, for error\n-   reporting.   This code is a duplicate of the code in elf.c, except\n-   that it uses arm_elf_find_function.  */\n-\n-static bfd_boolean\n-elf32_arm_find_nearest_line (bfd *\t    abfd,\n-\t\t\t     asymbol **\t    symbols,\n-\t\t\t     asection *\t    section,\n-\t\t\t     bfd_vma\t    offset,\n-\t\t\t     const char **  filename_ptr,\n-\t\t\t     const char **  functionname_ptr,\n-\t\t\t     unsigned int * line_ptr,\n-\t\t\t     unsigned int * discriminator_ptr)\n-{\n-  bfd_boolean found = FALSE;\n-\n-  if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,\n-\t\t\t\t     filename_ptr, functionname_ptr,\n-\t\t\t\t     line_ptr, discriminator_ptr,\n-\t\t\t\t     dwarf_debug_sections,\n-\t\t\t\t     & elf_tdata (abfd)->dwarf2_find_line_info))\n-    {\n-      if (!*functionname_ptr)\n-\tarm_elf_find_function (abfd, symbols, section, offset,\n-\t\t\t       *filename_ptr ? NULL : filename_ptr,\n-\t\t\t       functionname_ptr);\n-\n-      return TRUE;\n-    }\n-\n-  /* Skip _bfd_dwarf1_find_nearest_line since no known ARM toolchain\n-     uses DWARF1.  */\n-\n-  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,\n-\t\t\t\t\t     & found, filename_ptr,\n-\t\t\t\t\t     functionname_ptr, line_ptr,\n-\t\t\t\t\t     & elf_tdata (abfd)->line_info))\n-    return FALSE;\n-\n-  if (found && (*functionname_ptr || *line_ptr))\n-    return TRUE;\n-\n-  if (symbols == NULL)\n-    return FALSE;\n+\tdefault:\n+\t  return 0;\n+      }\n \n-  if (! arm_elf_find_function (abfd, symbols, section, offset,\n-\t\t\t       filename_ptr, functionname_ptr))\n-    return FALSE;\n+  if ((sym->flags & BSF_LOCAL)\n+      && bfd_is_arm_special_symbol_name (sym->name,\n+\t\t\t\t\t BFD_ARM_SPECIAL_SYM_TYPE_ANY))\n+    return 0;\n \n-  *line_ptr = 0;\n-  return TRUE;\n+  *code_off = sym->value;\n+  size = 0;\n+  if (!(sym->flags & BSF_SYNTHETIC))\n+    size = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;\n+  if (size == 0)\n+    size = 1;\n+  return size;\n }\n \n static bfd_boolean\n@@ -20488,14 +20407,14 @@ elf32_arm_backend_symbol_processing (bfd *abfd, asymbol *sym)\n #define bfd_elf32_bfd_link_hash_table_create\telf32_arm_link_hash_table_create\n #define bfd_elf32_bfd_reloc_type_lookup\t\telf32_arm_reloc_type_lookup\n #define bfd_elf32_bfd_reloc_name_lookup\t\telf32_arm_reloc_name_lookup\n-#define bfd_elf32_find_nearest_line\t\telf32_arm_find_nearest_line\n #define bfd_elf32_find_inliner_info\t\telf32_arm_find_inliner_info\n #define bfd_elf32_new_section_hook\t\telf32_arm_new_section_hook\n #define bfd_elf32_bfd_is_target_special_symbol\telf32_arm_is_target_special_symbol\n #define bfd_elf32_bfd_final_link\t\telf32_arm_final_link\n #define bfd_elf32_get_synthetic_symtab\telf32_arm_get_synthetic_symtab\n \n #define elf_backend_get_symbol_type\t\telf32_arm_get_symbol_type\n+#define elf_backend_maybe_function_sym\t\telf32_arm_maybe_function_sym\n #define elf_backend_gc_mark_hook\t\telf32_arm_gc_mark_hook\n #define elf_backend_gc_mark_extra_sections\telf32_arm_gc_mark_extra_sections\n #define elf_backend_check_relocs\t\telf32_arm_check_relocs"
    },
    {
      "sha": "51d7526a720bdb30d81db254d7348fb04ecff63f",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 32,
      "deletions": 111,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e76790600aeba4939225eda32e59642ed2813ac8/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e76790600aeba4939225eda32e59642ed2813ac8/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=e76790600aeba4939225eda32e59642ed2813ac8",
      "patch": "@@ -7999,122 +7999,43 @@ elfNN_aarch64_is_target_special_symbol (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t\t     BFD_AARCH64_SPECIAL_SYM_TYPE_ANY);\n }\n \n-/* This is a version of _bfd_elf_find_function() from dwarf2.c except that\n-   AArch64 mapping symbols are ignored when looking for function names.  */\n+/* If the ELF symbol SYM might be a function in SEC, return the\n+   function size and set *CODE_OFF to the function's entry point,\n+   otherwise return zero.  */\n \n-static bfd_boolean\n-aarch64_elf_find_function (bfd *          abfd,\n-\t\t\t   asymbol **     symbols,\n-\t\t\t   asection *     section,\n-\t\t\t   bfd_vma        offset,\n-\t\t\t   const char **  filename_ptr,\n-\t\t\t   const char **  functionname_ptr)\n-{\n-  const char *filename = NULL;\n-  asymbol *func = NULL;\n-  bfd_vma low_func = 0;\n-  asymbol **p;\n-\n-  if (symbols == NULL)\n-    return FALSE;\n-\n-  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)\n-    return FALSE;\n-\n-  for (p = symbols; *p != NULL; p++)\n-    {\n-      elf_symbol_type *q;\n+static bfd_size_type\n+elfNN_aarch64_maybe_function_sym (const asymbol *sym, asection *sec,\n+\t\t\t\t  bfd_vma *code_off)\n+{\n+  bfd_size_type size;\n \n-      q = (elf_symbol_type *) * p;\n+  if ((sym->flags & (BSF_SECTION_SYM | BSF_FILE | BSF_OBJECT\n+\t\t     | BSF_THREAD_LOCAL | BSF_RELC | BSF_SRELC)) != 0\n+      || sym->section != sec)\n+    return 0;\n \n-      switch (ELF_ST_TYPE (q->internal_elf_sym.st_info))\n-\t{\n-\tdefault:\n-\t  break;\n-\tcase STT_FILE:\n-\t  filename = bfd_asymbol_name (&q->symbol);\n-\t  break;\n+  if (!(sym->flags & BSF_SYNTHETIC))\n+    switch (ELF_ST_TYPE (((elf_symbol_type *) sym)->internal_elf_sym.st_info))\n+      {\n \tcase STT_FUNC:\n \tcase STT_NOTYPE:\n-\t  /* Skip mapping symbols.  */\n-\t  if ((q->symbol.flags & BSF_LOCAL)\n-\t      && (bfd_is_aarch64_special_symbol_name\n-\t\t  (q->symbol.name, BFD_AARCH64_SPECIAL_SYM_TYPE_ANY)))\n-\t    continue;\n-\t  /* Fall through.  */\n-\t  if (bfd_asymbol_section (&q->symbol) == section\n-\t      && q->symbol.value >= low_func && q->symbol.value <= offset)\n-\t    {\n-\t      func = (asymbol *) q;\n-\t      low_func = q->symbol.value;\n-\t    }\n \t  break;\n-\t}\n-    }\n-\n-  if (func == NULL)\n-    return FALSE;\n-\n-  if (filename_ptr)\n-    *filename_ptr = filename;\n-  if (functionname_ptr)\n-    *functionname_ptr = bfd_asymbol_name (func);\n-\n-  return TRUE;\n-}\n-\n-\n-/* Find the nearest line to a particular section and offset, for error\n-   reporting.   This code is a duplicate of the code in elf.c, except\n-   that it uses aarch64_elf_find_function.  */\n-\n-static bfd_boolean\n-elfNN_aarch64_find_nearest_line (bfd *abfd,\n-\t\t\t\t asymbol **symbols,\n-\t\t\t\t asection *section,\n-\t\t\t\t bfd_vma offset,\n-\t\t\t\t const char **filename_ptr,\n-\t\t\t\t const char **functionname_ptr,\n-\t\t\t\t unsigned int *line_ptr,\n-\t\t\t\t unsigned int *discriminator_ptr)\n-{\n-  bfd_boolean found = FALSE;\n-\n-  if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,\n-\t\t\t\t     filename_ptr, functionname_ptr,\n-\t\t\t\t     line_ptr, discriminator_ptr,\n-\t\t\t\t     dwarf_debug_sections,\n-\t\t\t\t     &elf_tdata (abfd)->dwarf2_find_line_info))\n-    {\n-      if (!*functionname_ptr)\n-\taarch64_elf_find_function (abfd, symbols, section, offset,\n-\t\t\t\t   *filename_ptr ? NULL : filename_ptr,\n-\t\t\t\t   functionname_ptr);\n-\n-      return TRUE;\n-    }\n-\n-  /* Skip _bfd_dwarf1_find_nearest_line since no known AArch64\n-     toolchain uses DWARF1.  */\n-\n-  if (!_bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,\n-\t\t\t\t\t    &found, filename_ptr,\n-\t\t\t\t\t    functionname_ptr, line_ptr,\n-\t\t\t\t\t    &elf_tdata (abfd)->line_info))\n-    return FALSE;\n-\n-  if (found && (*functionname_ptr || *line_ptr))\n-    return TRUE;\n-\n-  if (symbols == NULL)\n-    return FALSE;\n+\tdefault:\n+\t  return 0;\n+      }\n \n-  if (!aarch64_elf_find_function (abfd, symbols, section, offset,\n-\t\t\t\t  filename_ptr, functionname_ptr))\n-    return FALSE;\n+  if ((sym->flags & BSF_LOCAL)\n+      && bfd_is_aarch64_special_symbol_name (sym->name,\n+\t\t\t\t\t     BFD_AARCH64_SPECIAL_SYM_TYPE_ANY))\n+    return 0;\n \n-  *line_ptr = 0;\n-  return TRUE;\n+  *code_off = sym->value;\n+  size = 0;\n+  if (!(sym->flags & BSF_SYNTHETIC))\n+    size = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;\n+  if (size == 0)\n+    size = 1;\n+  return size;\n }\n \n static bfd_boolean\n@@ -10123,9 +10044,6 @@ const struct elf_size_info elfNN_aarch64_size_info =\n #define bfd_elfNN_find_inliner_info\t\t\\\n   elfNN_aarch64_find_inliner_info\n \n-#define bfd_elfNN_find_nearest_line\t\t\\\n-  elfNN_aarch64_find_nearest_line\n-\n #define bfd_elfNN_get_synthetic_symtab\t\t\\\n   elfNN_aarch64_get_synthetic_symtab\n \n@@ -10170,6 +10088,9 @@ const struct elf_size_info elfNN_aarch64_size_info =\n #define elf_backend_output_arch_local_syms\t\\\n   elfNN_aarch64_output_arch_local_syms\n \n+#define elf_backend_maybe_function_sym\t\t\\\n+  elfNN_aarch64_maybe_function_sym\n+\n #define elf_backend_plt_sym_val\t\t\t\\\n   elfNN_aarch64_plt_sym_val\n "
    },
    {
      "sha": "e9af7abd4b5d0be75b8e312866c00041d9da69e7",
      "filename": "bfd/elfxx-mips.c",
      "status": "modified",
      "additions": 10,
      "deletions": 20,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e76790600aeba4939225eda32e59642ed2813ac8/bfd/elfxx-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e76790600aeba4939225eda32e59642ed2813ac8/bfd/elfxx-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-mips.c?ref=e76790600aeba4939225eda32e59642ed2813ac8",
      "patch": "@@ -13078,27 +13078,17 @@ _bfd_mips_elf_find_nearest_line (bfd *abfd, asymbol **symbols,\n \t\t\t\t     filename_ptr, functionname_ptr,\n \t\t\t\t     line_ptr, discriminator_ptr,\n \t\t\t\t     dwarf_debug_sections,\n-\t\t\t\t     &elf_tdata (abfd)->dwarf2_find_line_info)\n-      || _bfd_dwarf1_find_nearest_line (abfd, symbols, section, offset,\n-\t\t\t\t\tfilename_ptr, functionname_ptr,\n-\t\t\t\t\tline_ptr))\n-    {\n-      /* PR 22789: If the function name or filename was not found through\n-\t the debug information, then try an ordinary lookup instead.  */\n-      if ((functionname_ptr != NULL && *functionname_ptr == NULL)\n-\t  || (filename_ptr != NULL && *filename_ptr == NULL))\n-\t{\n-\t  /* Do not override already discovered names.  */\n-\t  if (functionname_ptr != NULL && *functionname_ptr != NULL)\n-\t    functionname_ptr = NULL;\n-\n-\t  if (filename_ptr != NULL && *filename_ptr != NULL)\n-\t    filename_ptr = NULL;\n-\n-\t  _bfd_elf_find_function (abfd, symbols, section, offset,\n-\t\t\t\t  filename_ptr, functionname_ptr);\n-\t}\n+\t\t\t\t     &elf_tdata (abfd)->dwarf2_find_line_info))\n+    return TRUE;\n \n+  if (_bfd_dwarf1_find_nearest_line (abfd, symbols, section, offset,\n+\t\t\t\t     filename_ptr, functionname_ptr,\n+\t\t\t\t     line_ptr))\n+    {\n+      if (!*functionname_ptr)\n+\t_bfd_elf_find_function (abfd, symbols, section, offset,\n+\t\t\t\t*filename_ptr ? NULL : filename_ptr,\n+\t\t\t\tfunctionname_ptr);\n       return TRUE;\n     }\n "
    }
  ]
}