{
  "sha": "b650a28273a1cdc4bea825f6e7ccf52c9647ff9c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjY1MGEyODI3M2ExY2RjNGJlYTgyNWY2ZTdjY2Y1MmM5NjQ3ZmY5Yw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-09-16T21:26:30Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-09-16T21:26:45Z"
    },
    "message": "gdb: use bool in the solib catchpoint area\n\nUse bool instead of int in struct solib_catchpoint and in init_catchpoint &\nrelated functions.\n\ngdb/ChangeLog:\n\n\t* breakpoint.h (init_catchpoint): Change int parameter to bool.\n\t(add_solib_catchpoint): Likewise.\n\t* breakpoint.c (struct solib_catchpoint) <is_load>: Change type\n\tto bool.\n\t(add_solib_catchpoint): Change int parameter/variable to bool.\n\t(catch_load_or_unload): Likewise.\n\t(init_catchpoint): Likewise.\n\t(create_fork_vfork_event_catchpoint): Likewise.\n\t(catch_fork_command_1): Likewise.\n\t(catch_exec_command_1): Likewise.\n\nChange-Id: I1faf4506e9109f3ccdd7229ba766dc7d77aa7aa0",
    "tree": {
      "sha": "27fc510a13b00a4e29457d968a1426ae4d5e4589",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/27fc510a13b00a4e29457d968a1426ae4d5e4589"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4d0bcfcf62dd55d7b3e2983af7075e108b3eb37c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d0bcfcf62dd55d7b3e2983af7075e108b3eb37c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4d0bcfcf62dd55d7b3e2983af7075e108b3eb37c"
    }
  ],
  "stats": {
    "total": 76,
    "additions": 43,
    "deletions": 33
  },
  "files": [
    {
      "sha": "84ee292750ec43830d4599c20cb14a78a2b5fb9f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b650a28273a1cdc4bea825f6e7ccf52c9647ff9c",
      "patch": "@@ -1,3 +1,16 @@\n+2020-09-16  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* breakpoint.h (init_catchpoint): Change int parameter to bool.\n+\t(add_solib_catchpoint): Likewise.\n+\t* breakpoint.c (struct solib_catchpoint) <is_load>: Change type\n+\tto bool.\n+\t(add_solib_catchpoint): Change int parameter/variable to bool.\n+\t(catch_load_or_unload): Likewise.\n+\t(init_catchpoint): Likewise.\n+\t(create_fork_vfork_event_catchpoint): Likewise.\n+\t(catch_fork_command_1): Likewise.\n+\t(catch_exec_command_1): Likewise.\n+\n 2020-09-16  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdb-gdb.py.in (class StructTypePrettyPrinter) <to_string>:"
    },
    {
      "sha": "1876af955b49a7c455ff30b912466599d0462ac8",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 16,
      "deletions": 29,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=b650a28273a1cdc4bea825f6e7ccf52c9647ff9c",
      "patch": "@@ -7867,7 +7867,7 @@ struct solib_catchpoint : public breakpoint\n   ~solib_catchpoint () override;\n \n   /* True for \"catch load\", false for \"catch unload\".  */\n-  unsigned char is_load;\n+  bool is_load;\n \n   /* Regular expression to match, if any.  COMPILED is only valid when\n      REGEX is non-NULL.  */\n@@ -8039,15 +8039,10 @@ print_recreate_catch_solib (struct breakpoint *b, struct ui_file *fp)\n \n static struct breakpoint_ops catch_solib_breakpoint_ops;\n \n-/* Shared helper function (MI and CLI) for creating and installing\n-   a shared object event catchpoint.  If IS_LOAD is non-zero then\n-   the events to be caught are load events, otherwise they are\n-   unload events.  If IS_TEMP is non-zero the catchpoint is a\n-   temporary one.  If ENABLED is non-zero the catchpoint is\n-   created in an enabled state.  */\n+/* See breakpoint.h.  */\n \n void\n-add_solib_catchpoint (const char *arg, int is_load, int is_temp, int enabled)\n+add_solib_catchpoint (const char *arg, bool is_load, bool is_temp, bool enabled)\n {\n   struct gdbarch *gdbarch = get_current_arch ();\n \n@@ -8080,12 +8075,10 @@ static void\n catch_load_or_unload (const char *arg, int from_tty, int is_load,\n \t\t      struct cmd_list_element *command)\n {\n-  int tempflag;\n   const int enabled = 1;\n+  bool temp = get_cmd_context (command) == CATCH_TEMPORARY;\n \n-  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;\n-\n-  add_solib_catchpoint (arg, is_load, tempflag, enabled);\n+  add_solib_catchpoint (arg, is_load, temp, enabled);\n }\n \n static void\n@@ -8102,14 +8095,11 @@ catch_unload_command_1 (const char *arg, int from_tty,\n   catch_load_or_unload (arg, from_tty, 0, command);\n }\n \n-/* Initialize a new breakpoint of the bp_catchpoint kind.  If TEMPFLAG\n-   is non-zero, then make the breakpoint temporary.  If COND_STRING is\n-   not NULL, then store it in the breakpoint.  OPS, if not NULL, is\n-   the breakpoint_ops structure associated to the catchpoint.  */\n+/* See breakpoint.h.  */\n \n void\n init_catchpoint (struct breakpoint *b,\n-\t\t struct gdbarch *gdbarch, int tempflag,\n+\t\t struct gdbarch *gdbarch, bool temp,\n \t\t const char *cond_string,\n \t\t const struct breakpoint_ops *ops)\n {\n@@ -8119,7 +8109,7 @@ init_catchpoint (struct breakpoint *b,\n   init_raw_breakpoint (b, gdbarch, sal, bp_catchpoint, ops);\n \n   b->cond_string = (cond_string == NULL) ? NULL : xstrdup (cond_string);\n-  b->disposition = tempflag ? disp_del : disp_donttouch;\n+  b->disposition = temp ? disp_del : disp_donttouch;\n }\n \n void\n@@ -8139,12 +8129,12 @@ install_breakpoint (int internal, std::unique_ptr<breakpoint> &&arg, int update_\n \n static void\n create_fork_vfork_event_catchpoint (struct gdbarch *gdbarch,\n-\t\t\t\t    int tempflag, const char *cond_string,\n+\t\t\t\t    bool temp, const char *cond_string,\n                                     const struct breakpoint_ops *ops)\n {\n   std::unique_ptr<fork_catchpoint> c (new fork_catchpoint ());\n \n-  init_catchpoint (c.get (), gdbarch, tempflag, cond_string, ops);\n+  init_catchpoint (c.get (), gdbarch, temp, cond_string, ops);\n \n   c->forked_inferior_pid = null_ptid;\n \n@@ -11148,11 +11138,10 @@ catch_fork_command_1 (const char *arg, int from_tty,\n   struct gdbarch *gdbarch = get_current_arch ();\n   const char *cond_string = NULL;\n   catch_fork_kind fork_kind;\n-  int tempflag;\n \n   fork_kind = (catch_fork_kind) (uintptr_t) get_cmd_context (command);\n-  tempflag = (fork_kind == catch_fork_temporary\n-\t      || fork_kind == catch_vfork_temporary);\n+  bool temp = (fork_kind == catch_fork_temporary\n+\t       || fork_kind == catch_vfork_temporary);\n \n   if (!arg)\n     arg = \"\";\n@@ -11174,12 +11163,12 @@ catch_fork_command_1 (const char *arg, int from_tty,\n     {\n     case catch_fork_temporary:\n     case catch_fork_permanent:\n-      create_fork_vfork_event_catchpoint (gdbarch, tempflag, cond_string,\n+      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string,\n                                           &catch_fork_breakpoint_ops);\n       break;\n     case catch_vfork_temporary:\n     case catch_vfork_permanent:\n-      create_fork_vfork_event_catchpoint (gdbarch, tempflag, cond_string,\n+      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string,\n                                           &catch_vfork_breakpoint_ops);\n       break;\n     default:\n@@ -11193,10 +11182,8 @@ catch_exec_command_1 (const char *arg, int from_tty,\n \t\t      struct cmd_list_element *command)\n {\n   struct gdbarch *gdbarch = get_current_arch ();\n-  int tempflag;\n   const char *cond_string = NULL;\n-\n-  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;\n+  bool temp = get_cmd_context (command) == CATCH_TEMPORARY;\n \n   if (!arg)\n     arg = \"\";\n@@ -11213,7 +11200,7 @@ catch_exec_command_1 (const char *arg, int from_tty,\n     error (_(\"Junk at end of arguments.\"));\n \n   std::unique_ptr<exec_catchpoint> c (new exec_catchpoint ());\n-  init_catchpoint (c.get (), gdbarch, tempflag, cond_string,\n+  init_catchpoint (c.get (), gdbarch, temp, cond_string,\n \t\t   &catch_exec_breakpoint_ops);\n   c->exec_pathname = NULL;\n "
    },
    {
      "sha": "b9a605e6119da03cb71b7542ebe57a9603b65e04",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 14,
      "deletions": 4,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b650a28273a1cdc4bea825f6e7ccf52c9647ff9c/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=b650a28273a1cdc4bea825f6e7ccf52c9647ff9c",
      "patch": "@@ -1333,8 +1333,13 @@ extern void\n \t\t\t\t int enabled,\n \t\t\t\t int from_tty);\n \n+/* Initialize a new breakpoint of the bp_catchpoint kind.  If TEMP\n+   is true, then make the breakpoint temporary.  If COND_STRING is\n+   not NULL, then store it in the breakpoint.  OPS, if not NULL, is\n+   the breakpoint_ops structure associated to the catchpoint.  */\n+\n extern void init_catchpoint (struct breakpoint *b,\n-\t\t\t     struct gdbarch *gdbarch, int tempflag,\n+\t\t\t     struct gdbarch *gdbarch, bool temp,\n \t\t\t     const char *cond_string,\n \t\t\t     const struct breakpoint_ops *ops);\n \n@@ -1561,9 +1566,14 @@ extern void disable_breakpoints_in_shlibs (void);\n extern bool is_catchpoint (struct breakpoint *b);\n \n /* Shared helper function (MI and CLI) for creating and installing\n-   a shared object event catchpoint.  */\n-extern void add_solib_catchpoint (const char *arg, int is_load, int is_temp,\n-                                  int enabled);\n+   a shared object event catchpoint.  If IS_LOAD is true then\n+   the events to be caught are load events, otherwise they are\n+   unload events.  If IS_TEMP is true the catchpoint is a\n+   temporary one.  If ENABLED is true the catchpoint is\n+   created in an enabled state.  */\n+\n+extern void add_solib_catchpoint (const char *arg, bool is_load, bool is_temp,\n+\t\t\t\t  bool enabled);\n \n /* Create and insert a new software single step breakpoint for the\n    current thread.  May be called multiple times; each time will add a"
    }
  ]
}