{
  "sha": "ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWE5MzNmMTdjM2M2YjlmYTFkYWY4ZDAzYmFhMzRmN2JlYzg1NWQ2Yw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-02T07:09:32Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-04T08:50:33Z"
    },
    "message": "Release bfd_alloc memory in bfd_check_format_matches\n\nIt's a little tricky.  We can release any memory back when we have a\nmatch failure, but after a match success which we might want to\npreserve for later use the high water mark must change to that of the\nmatched bfd.\n\n\t* format.c (bfd_check_format_matches): Add preserve_match.\n\tSave initial bfd state in \"preserve\", matched bfd state in\n\t\"preserve_match\".  Save just the first match.  Release\n\tbfd_alloc memory.  Restore and finish preserved state as\n\tappropriate on all function exit paths.",
    "tree": {
      "sha": "eb3d7a89cd4756fe63701bdf134ead32a6e3cf08",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/eb3d7a89cd4756fe63701bdf134ead32a6e3cf08"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f24bdec48621f419fdc9dcd58f46891f062b7bc0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f24bdec48621f419fdc9dcd58f46891f062b7bc0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f24bdec48621f419fdc9dcd58f46891f062b7bc0"
    }
  ],
  "stats": {
    "total": 58,
    "additions": 45,
    "deletions": 13
  },
  "files": [
    {
      "sha": "148de794bc44e4803d15fb8451b87d5c692d2cbf",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c",
      "patch": "@@ -1,3 +1,11 @@\n+2020-01-04  Alan Modra  <amodra@gmail.com>\n+\n+\t* format.c (bfd_check_format_matches): Add preserve_match.\n+\tSave initial bfd state in \"preserve\", matched bfd state in\n+\t\"preserve_match\".  Save just the first match.  Release\n+\tbfd_alloc memory.  Restore and finish preserved state as\n+\tappropriate on all function exit paths.\n+\n 2020-01-04  Alan Modra  <amodra@gmail.com>\n \n \t* mmo.c (mmo_mkobject): Allocate tdata with bfd_zalloc."
    },
    {
      "sha": "e53955eb45878dda7a1303bd421084490ba4ca2e",
      "filename": "bfd/format.c",
      "status": "modified",
      "additions": 37,
      "deletions": 13,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c/bfd/format.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c/bfd/format.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/format.c?ref=ea933f17c3c6b9fa1daf8d03baa34f7bec855d6c",
      "patch": "@@ -219,7 +219,7 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n   int match_count, best_count, best_match;\n   int ar_match_index;\n   unsigned int initial_section_id = _bfd_section_id;\n-  struct bfd_preserve preserve;\n+  struct bfd_preserve preserve, preserve_match;\n \n   if (matching != NULL)\n     *matching = NULL;\n@@ -247,7 +247,10 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n   /* Presume the answer is yes.  */\n   abfd->format = format;\n   save_targ = abfd->xvec;\n-  preserve.marker = NULL;\n+\n+  preserve_match.marker = NULL;\n+  if (!bfd_preserve_save (abfd, &preserve))\n+    goto err_ret;\n \n   /* If the target type was explicitly specified, just check that target.  */\n   if (!abfd->target_defaulted)\n@@ -289,6 +292,7 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n   for (target = bfd_target_vector; *target != NULL; target++)\n     {\n       const bfd_target *temp;\n+      void **high_water;\n \n       /* The binary target matches anything, so don't return it when\n \t searching.  Don't match the plugin target if we have another\n@@ -306,6 +310,14 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n \t have sections attached, which will confuse the next\n \t _bfd_check_format call.  */\n       bfd_reinit (abfd, initial_section_id);\n+      /* Free bfd_alloc memory too.  If we have matched and preserved\n+\t a target then the high water mark is that much higher.  */\n+      if (preserve_match.marker)\n+\thigh_water = &preserve_match.marker;\n+      else\n+\thigh_water = &preserve.marker;\n+      bfd_release (abfd, *high_water);\n+      *high_water = bfd_alloc (abfd, 1);\n \n       /* Change BFD's target temporarily.  */\n       abfd->xvec = *target;\n@@ -332,10 +344,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n \t    match_priority = (*target)->match_priority;\n #endif\n \n-\t  match_targ = temp;\n-\t  if (preserve.marker != NULL)\n-\t    bfd_preserve_finish (abfd, &preserve);\n-\n \t  if (abfd->format != bfd_archive\n \t      || (bfd_has_map (abfd)\n \t\t  && bfd_get_error () != bfd_error_wrong_object_format))\n@@ -374,8 +382,12 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n \t      ar_match_index++;\n \t    }\n \n-\t  if (!bfd_preserve_save (abfd, &preserve))\n-\t    goto err_ret;\n+\t  if (preserve_match.marker == NULL)\n+\t    {\n+\t      match_targ = temp;\n+\t      if (!bfd_preserve_save (abfd, &preserve_match))\n+\t\tgoto err_ret;\n+\t    }\n \t}\n       else if (bfd_get_error () != bfd_error_wrong_format)\n \tgoto err_ret;\n@@ -448,18 +460,23 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n      really shouldn't iterate on live bfd's.  Note that saving the\n      whole bfd and restoring it would be even worse; the first thing\n      you notice is that the cached bfd file position gets out of sync.  */\n-  if (preserve.marker != NULL)\n-    bfd_preserve_restore (abfd, &preserve);\n+  if (preserve_match.marker != NULL)\n+    bfd_preserve_restore (abfd, &preserve_match);\n \n   if (match_count == 1)\n     {\n       abfd->xvec = right_targ;\n       /* If we come out of the loop knowing that the last target that\n \t matched is the one we want, then ABFD should still be in a usable\n-\t state (except possibly for XVEC).  */\n+\t state (except possibly for XVEC).  This is not just an\n+\t optimisation.  In the case of plugins a match against the\n+\t plugin target can result in the bfd being changed such that\n+\t it no longer matches the plugin target, nor will it match\n+\t RIGHT_TARG again.  */\n       if (match_targ != right_targ)\n \t{\n \t  bfd_reinit (abfd, initial_section_id);\n+\t  bfd_release (abfd, preserve.marker);\n \t  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)\n \t    goto err_ret;\n \t  match_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n@@ -477,6 +494,9 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n \n       if (matching_vector)\n \tfree (matching_vector);\n+      if (preserve_match.marker != NULL)\n+\tbfd_preserve_finish (abfd, &preserve_match);\n+      bfd_preserve_finish (abfd, &preserve);\n \n       /* File position has moved, BTW.  */\n       return TRUE;\n@@ -491,8 +511,9 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n       abfd->format = bfd_unknown;\n       if (matching_vector)\n \tfree (matching_vector);\n-      if (preserve.marker != NULL)\n-\tbfd_preserve_restore (abfd, &preserve);\n+      if (preserve_match.marker != NULL)\n+\tbfd_preserve_finish (abfd, &preserve_match);\n+      bfd_preserve_restore (abfd, &preserve);\n       return FALSE;\n     }\n \n@@ -515,6 +536,9 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n     }\n   else if (matching_vector)\n     free (matching_vector);\n+  if (preserve_match.marker != NULL)\n+    bfd_preserve_finish (abfd, &preserve_match);\n+  bfd_preserve_restore (abfd, &preserve);\n   return FALSE;\n }\n "
    }
  ]
}