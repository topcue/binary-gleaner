{
  "sha": "0579205aec4369375dccb8566ba37eefee2be912",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDU3OTIwNWFlYzQzNjkzNzVkY2NiODU2NmJhMzdlZWZlZTJiZTkxMg==",
  "commit": {
    "author": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2020-09-17T09:28:20Z"
    },
    "committer": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2021-08-05T15:40:56Z"
    },
    "message": "Simplify dwarf_expr_context class interface\n\nIdea of this patch is to get a clean and simple public interface for\nthe dwarf_expr_context class, looking like:\n\n- constructor,\n- destructor,\n- push_address method and\n- evaluate method.\n\nWhere constructor should only ever require a target architecture\ninformation. This information is held in per object file\n(dwarf2_per_objfile) structure, so it makes sense to keep that\nstructure as a constructor argument. It also makes sense to get the\naddress size from that structure, but unfortunately that interface\ndoesn't exist at the moment, so the dwarf_expr_context class user\nneeds to provide that information.\n\nThe push_address method is used to push a CORE_ADDR as a value on\ntop of the DWARF stack before the evaluation. This method can be\nlater changed to push any struct value object on the stack.\n\nThe evaluate method is the method that evaluates a DWARF expression\nand provides the evaluation result, in a form of a single struct\nvalue object that describes a location. To do this, the method requires\na context of the evaluation, as well as expected result type\ninformation. If the type information is not provided, the DWARF generic\ntype will be used instead.\n\nTo avoid storing the gdbarch information in the evaluator object, that\ninformation is now always acquired from the per_objfile object.\n\nAll data members are now private and only visible to the evaluator\nclass, so a m_ prefix was added to all of their names to reflect that.\nTo make this distinction clear, they are also accessed through objects\nthis pointer, wherever that was not the case before.\n\ngdb/ChangeLog:\n\n\t* dwarf2/expr.c (dwarf_expr_context::dwarf_expr_context): Add\n\taddress size argument.\n\t(dwarf_expr_context::read_mem): Change to use property_addr_info\n\tstructure.\n\t(dwarf_expr_context::evaluate): New function.\n\t(dwarf_expr_context::execute_stack_op): Change to use\n\tproperty_addr_info structure.\n\t* dwarf2/expr.h (struct dwarf_expr_context): New evaluate\n\tdeclaration. Change eval and fetch_result method to private.\n        (dwarf_expr_context::gdbarch): Remove member.\n        (dwarf_expr_context::stack): Make private and add m_ prefix.\n        (dwarf_expr_context::addr_size): Make private and add\n        m_ prefix.\n        (dwarf_expr_context::recursion_depth): Make private and add\n        m_ prefix.\n        (dwarf_expr_context::max_recursion_depth): Make private and\n        add m_ prefix.\n        (dwarf_expr_context::len): Make private and add m_ prefix.\n        (dwarf_expr_context::data): Make private and add m_ prefix.\n        (dwarf_expr_context::initialized): Make private and add\n        m_ prefix.\n        (dwarf_expr_context::pieces): Make private and add m_ prefix.\n        (dwarf_expr_context::per_objfile): Make private and add\n        m_ prefix.\n        (dwarf_expr_context::frame): Make private and add m_ prefix.\n        (dwarf_expr_context::per_cu): Make private and add m_ prefix.\n        (dwarf_expr_context::addr_info): Make private and add\n        m_ prefix.\n\t* dwarf2/frame.c (execute_stack_op): Change to call evaluate\n\tmethod.\n\t* dwarf2/loc.c (dwarf2_evaluate_loc_desc_full): Change to call\n\tevaluate method.\n\t(dwarf2_locexpr_baton_eval): Change to call evaluate method.",
    "tree": {
      "sha": "e6e469171794eeb12f093ba53b4733bdbfb8dbca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e6e469171794eeb12f093ba53b4733bdbfb8dbca"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0579205aec4369375dccb8566ba37eefee2be912",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0579205aec4369375dccb8566ba37eefee2be912",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0579205aec4369375dccb8566ba37eefee2be912",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0579205aec4369375dccb8566ba37eefee2be912/comments",
  "author": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51"
    }
  ],
  "stats": {
    "total": 469,
    "additions": 237,
    "deletions": 232
  },
  "files": [
    {
      "sha": "1e67ffaf2489ebaaf754b6d49033ac6777295694",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 185,
      "deletions": 163,
      "changes": 348,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0579205aec4369375dccb8566ba37eefee2be912/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0579205aec4369375dccb8566ba37eefee2be912/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=0579205aec4369375dccb8566ba37eefee2be912",
      "patch": "@@ -668,34 +668,35 @@ sect_variable_value (sect_offset sect_off,\n struct type *\n dwarf_expr_context::address_type () const\n {\n-  struct dwarf_gdbarch_types *types\n-    = (struct dwarf_gdbarch_types *) gdbarch_data (this->gdbarch,\n-\t\t\t\t\t\t   dwarf_arch_cookie);\n+  gdbarch *arch = this->m_per_objfile->objfile->arch ();\n+  dwarf_gdbarch_types *types\n+    = (dwarf_gdbarch_types *) gdbarch_data (arch, dwarf_arch_cookie);\n   int ndx;\n \n-  if (this->addr_size == 2)\n+  if (this->m_addr_size == 2)\n     ndx = 0;\n-  else if (this->addr_size == 4)\n+  else if (this->m_addr_size == 4)\n     ndx = 1;\n-  else if (this->addr_size == 8)\n+  else if (this->m_addr_size == 8)\n     ndx = 2;\n   else\n     error (_(\"Unsupported address size in DWARF expressions: %d bits\"),\n-\t   8 * this->addr_size);\n+\t   8 * this->m_addr_size);\n \n   if (types->dw_types[ndx] == NULL)\n     types->dw_types[ndx]\n-      = arch_integer_type (this->gdbarch,\n-\t\t\t   8 * this->addr_size,\n+      = arch_integer_type (arch, 8 * this->m_addr_size,\n \t\t\t   0, \"<signed DWARF address type>\");\n \n   return types->dw_types[ndx];\n }\n \n /* Create a new context for the expression evaluator.  */\n \n-dwarf_expr_context::dwarf_expr_context (dwarf2_per_objfile *per_objfile)\n-: per_objfile (per_objfile)\n+dwarf_expr_context::dwarf_expr_context (dwarf2_per_objfile *per_objfile,\n+\t\t\t\t\tint addr_size)\n+: m_addr_size (addr_size),\n+  m_per_objfile (per_objfile)\n {\n }\n \n@@ -704,7 +705,7 @@ dwarf_expr_context::dwarf_expr_context (dwarf2_per_objfile *per_objfile)\n void\n dwarf_expr_context::push (struct value *value, bool in_stack_memory)\n {\n-  stack.emplace_back (value, in_stack_memory);\n+  this->m_stack.emplace_back (value, in_stack_memory);\n }\n \n /* Push VALUE onto the stack.  */\n@@ -720,22 +721,22 @@ dwarf_expr_context::push_address (CORE_ADDR value, bool in_stack_memory)\n void\n dwarf_expr_context::pop ()\n {\n-  if (stack.empty ())\n+  if (this->m_stack.empty ())\n     error (_(\"dwarf expression stack underflow\"));\n \n-  stack.pop_back ();\n+  this->m_stack.pop_back ();\n }\n \n /* Retrieve the N'th item on the stack.  */\n \n struct value *\n dwarf_expr_context::fetch (int n)\n {\n-  if (stack.size () <= n)\n+  if (this->m_stack.size () <= n)\n      error (_(\"Asked for position %d of stack, \"\n \t      \"stack only has %zu elements on it.\"),\n-\t    n, stack.size ());\n-  return stack[stack.size () - (1 + n)].value;\n+\t    n, this->m_stack.size ());\n+  return this->m_stack[this->m_stack.size () - (1 + n)].value;\n }\n \n /* See expr.h.  */\n@@ -744,9 +745,9 @@ void\n dwarf_expr_context::get_frame_base (const gdb_byte **start,\n \t\t\t\t    size_t * length)\n {\n-  ensure_have_frame (this->frame, \"DW_OP_fbreg\");\n+  ensure_have_frame (this->m_frame, \"DW_OP_fbreg\");\n \n-  const block *bl = get_frame_block (this->frame, NULL);\n+  const block *bl = get_frame_block (this->m_frame, NULL);\n \n   if (bl == NULL)\n     error (_(\"frame address is not available.\"));\n@@ -762,7 +763,7 @@ dwarf_expr_context::get_frame_base (const gdb_byte **start,\n   gdb_assert (framefunc != NULL);\n \n   func_get_frame_base_dwarf_block (framefunc,\n-\t\t\t\t   get_frame_address_in_block (this->frame),\n+\t\t\t\t   get_frame_address_in_block (this->m_frame),\n \t\t\t\t   start, length);\n }\n \n@@ -771,11 +772,11 @@ dwarf_expr_context::get_frame_base (const gdb_byte **start,\n struct type *\n dwarf_expr_context::get_base_type (cu_offset die_cu_off)\n {\n-  if (per_cu == nullptr)\n-    return builtin_type (this->gdbarch)->builtin_int;\n+  if (this->m_per_cu == nullptr)\n+    return builtin_type (this->m_per_objfile->objfile->arch ())->builtin_int;\n \n-  struct type *result = dwarf2_get_die_type (die_cu_off, this->per_cu,\n-\t\t\t\t\t     this->per_objfile);\n+  struct type *result = dwarf2_get_die_type (die_cu_off, this->m_per_cu,\n+\t\t\t\t\t     this->m_per_objfile);\n \n   if (result == nullptr)\n     error (_(\"Could not find type for operation\"));\n@@ -788,9 +789,9 @@ dwarf_expr_context::get_base_type (cu_offset die_cu_off)\n void\n dwarf_expr_context::dwarf_call (cu_offset die_cu_off)\n {\n-  ensure_have_per_cu (this->per_cu, \"DW_OP_call\");\n+  ensure_have_per_cu (this->m_per_cu, \"DW_OP_call\");\n \n-  frame_info *frame = this->frame;\n+  frame_info *frame = this->m_frame;\n \n   auto get_pc_from_frame = [frame] ()\n     {\n@@ -799,11 +800,11 @@ dwarf_expr_context::dwarf_call (cu_offset die_cu_off)\n     };\n \n   dwarf2_locexpr_baton block\n-    = dwarf2_fetch_die_loc_cu_off (die_cu_off, this->per_cu, this->per_objfile,\n-\t\t\t\t   get_pc_from_frame);\n+    = dwarf2_fetch_die_loc_cu_off (die_cu_off, this->m_per_cu,\n+\t\t\t\t   this->m_per_objfile, get_pc_from_frame);\n \n   /* DW_OP_call_ref is currently not supported.  */\n-  gdb_assert (block.per_cu == this->per_cu);\n+  gdb_assert (block.per_cu == this->m_per_cu);\n \n   this->eval (block.data, block.size);\n }\n@@ -818,13 +819,16 @@ dwarf_expr_context::read_mem (gdb_byte *buf, CORE_ADDR addr,\n     return;\n \n   /* Prefer the passed-in memory, if it exists.  */\n-  CORE_ADDR offset = addr - this->obj_address;\n-\n-  if (offset < this->data_view.size ()\n-      && offset + length <= this->data_view.size ())\n+  if (this->m_addr_info != nullptr)\n     {\n-      memcpy (buf, this->data_view.data (), length);\n-      return;\n+      CORE_ADDR offset = addr - this->m_addr_info->addr;\n+\n+      if (offset < this->m_addr_info->valaddr.size ()\n+\t  && offset + length <= this->m_addr_info->valaddr.size ())\n+\t{\n+\t  memcpy (buf, this->m_addr_info->valaddr.data (), length);\n+\t  return;\n+\t}\n     }\n \n   read_memory (addr, buf, length);\n@@ -837,14 +841,14 @@ dwarf_expr_context::push_dwarf_reg_entry_value (call_site_parameter_kind kind,\n \t\t\t\t\t\tcall_site_parameter_u kind_u,\n \t\t\t\t\t\tint deref_size)\n {\n-  ensure_have_per_cu (this->per_cu, \"DW_OP_entry_value\");\n-  ensure_have_frame (this->frame, \"DW_OP_entry_value\");\n+  ensure_have_per_cu (this->m_per_cu, \"DW_OP_entry_value\");\n+  ensure_have_frame (this->m_frame, \"DW_OP_entry_value\");\n \n   dwarf2_per_cu_data *caller_per_cu;\n   dwarf2_per_objfile *caller_per_objfile;\n-  frame_info *caller_frame = get_prev_frame (this->frame);\n+  frame_info *caller_frame = get_prev_frame (this->m_frame);\n   call_site_parameter *parameter\n-    = dwarf_expr_reg_to_entry_parameter (this->frame, kind, kind_u,\n+    = dwarf_expr_reg_to_entry_parameter (this->m_frame, kind, kind_u,\n \t\t\t\t\t &caller_per_cu,\n \t\t\t\t\t &caller_per_objfile);\n   const gdb_byte *data_src\n@@ -863,19 +867,17 @@ dwarf_expr_context::push_dwarf_reg_entry_value (call_site_parameter_kind kind,\n \n      It is possible for the caller to be from a different objfile from the\n      callee if the call is made through a function pointer.  */\n-  scoped_restore save_frame = make_scoped_restore (&this->frame,\n+  scoped_restore save_frame = make_scoped_restore (&this->m_frame,\n \t\t\t\t\t\t   caller_frame);\n-  scoped_restore save_per_cu = make_scoped_restore (&this->per_cu,\n+  scoped_restore save_per_cu = make_scoped_restore (&this->m_per_cu,\n \t\t\t\t\t\t    caller_per_cu);\n-  scoped_restore save_obj_addr = make_scoped_restore (&this->obj_address,\n-\t\t\t\t\t\t      (CORE_ADDR) 0);\n-  scoped_restore save_per_objfile = make_scoped_restore (&this->per_objfile,\n+  scoped_restore save_addr_info = make_scoped_restore (&this->m_addr_info,\n+\t\t\t\t\t\t       nullptr);\n+  scoped_restore save_per_objfile = make_scoped_restore (&this->m_per_objfile,\n \t\t\t\t\t\t\t caller_per_objfile);\n \n-  scoped_restore save_arch = make_scoped_restore (&this->gdbarch);\n-  this->gdbarch = this->per_objfile->objfile->arch ();\n-  scoped_restore save_addr_size = make_scoped_restore (&this->addr_size);\n-  this->addr_size = this->per_cu->addr_size ();\n+  scoped_restore save_addr_size = make_scoped_restore (&this->m_addr_size);\n+  this->m_addr_size = this->m_per_cu->addr_size ();\n \n   this->eval (data_src, size);\n }\n@@ -887,49 +889,49 @@ dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n \t\t\t\t  LONGEST subobj_offset)\n {\n   value *retval = nullptr;\n+  gdbarch *arch = this->m_per_objfile->objfile->arch ();\n \n   if (type == nullptr)\n     type = address_type ();\n \n   if (subobj_type == nullptr)\n     subobj_type = type;\n \n-  if (this->pieces.size () > 0)\n+  if (this->m_pieces.size () > 0)\n     {\n       ULONGEST bit_size = 0;\n \n-      for (dwarf_expr_piece &piece : this->pieces)\n+      for (dwarf_expr_piece &piece : this->m_pieces)\n \tbit_size += piece.size;\n       /* Complain if the expression is larger than the size of the\n \t outer type.  */\n       if (bit_size > 8 * TYPE_LENGTH (type))\n \tinvalid_synthetic_pointer ();\n \n       piece_closure *c\n-\t= allocate_piece_closure (this->per_cu, this->per_objfile,\n-\t\t\t\t  std::move (this->pieces), this->frame);\n+\t= allocate_piece_closure (this->m_per_cu, this->m_per_objfile,\n+\t\t\t\t  std::move (this->m_pieces), this->m_frame);\n       retval = allocate_computed_value (subobj_type,\n \t\t\t\t\t&pieced_value_funcs, c);\n       set_value_offset (retval, subobj_offset);\n     }\n   else\n     {\n-      switch (this->location)\n+      switch (this->m_location)\n \t{\n \tcase DWARF_VALUE_REGISTER:\n \t  {\n \t    int dwarf_regnum\n \t      = longest_to_int (value_as_long (this->fetch (0)));\n-\t    int gdb_regnum = dwarf_reg_to_regnum_or_error (this->gdbarch,\n-\t\t\t\t\t\t\t   dwarf_regnum);\n+\t    int gdb_regnum = dwarf_reg_to_regnum_or_error (arch, dwarf_regnum);\n \n \t    if (subobj_offset != 0)\n \t      error (_(\"cannot use offset on synthetic pointer to register\"));\n \n-\t    gdb_assert (this->frame != NULL);\n+\t    gdb_assert (this->m_frame != NULL);\n \n \t    retval = value_from_register (subobj_type, gdb_regnum,\n-\t\t\t\t\t  this->frame);\n+\t\t\t\t\t  this->m_frame);\n \t    if (value_optimized_out (retval))\n \t      {\n \t\t/* This means the register has undefined value / was\n@@ -964,10 +966,10 @@ dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n \t      {\n \t\tcase TYPE_CODE_FUNC:\n \t\tcase TYPE_CODE_METHOD:\n-\t\t  ptr_type = builtin_type (this->gdbarch)->builtin_func_ptr;\n+\t\t  ptr_type = builtin_type (arch)->builtin_func_ptr;\n \t\t  break;\n \t\tdefault:\n-\t\t  ptr_type = builtin_type (this->gdbarch)->builtin_data_ptr;\n+\t\t  ptr_type = builtin_type (arch)->builtin_data_ptr;\n \t\t  break;\n \t      }\n \t    address = value_as_address (value_from_pointer (ptr_type, address));\n@@ -992,7 +994,7 @@ dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n \t    retval = allocate_value (subobj_type);\n \n \t    /* The given offset is relative to the actual object.  */\n-\t    if (gdbarch_byte_order (this->gdbarch) == BFD_ENDIAN_BIG)\n+\t    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG)\n \t      subobj_offset += n - max;\n \n \t    memcpy (value_contents_raw (retval),\n@@ -1004,12 +1006,12 @@ dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n \t  {\n \t    size_t n = TYPE_LENGTH (subobj_type);\n \n-\t    if (subobj_offset + n > this->len)\n+\t    if (subobj_offset + n > this->m_len)\n \t      invalid_synthetic_pointer ();\n \n \t    retval = allocate_value (subobj_type);\n \t    bfd_byte *contents = value_contents_raw (retval);\n-\t    memcpy (contents, this->data + subobj_offset, n);\n+\t    memcpy (contents, this->m_data + subobj_offset, n);\n \t  }\n \t  break;\n \n@@ -1027,11 +1029,28 @@ dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n \t}\n     }\n \n-  set_value_initialized (retval, this->initialized);\n+  set_value_initialized (retval, this->m_initialized);\n \n   return retval;\n }\n \n+/* See expr.h.  */\n+\n+value *\n+dwarf_expr_context::evaluate (const gdb_byte *addr, size_t len,\n+\t\t\t      dwarf2_per_cu_data *per_cu, frame_info *frame,\n+\t\t\t      const struct property_addr_info *addr_info,\n+\t\t\t      struct type *type, struct type *subobj_type,\n+\t\t\t      LONGEST subobj_offset)\n+{\n+  this->m_per_cu = per_cu;\n+  this->m_frame = frame;\n+  this->m_addr_info = addr_info;\n+\n+  eval (addr, len);\n+  return fetch_result (type, subobj_type, subobj_offset);\n+}\n+\n /* Require that TYPE be an integral type; throw an exception if not.  */\n \n static void\n@@ -1092,8 +1111,9 @@ get_signed_type (struct gdbarch *gdbarch, struct type *type)\n CORE_ADDR\n dwarf_expr_context::fetch_address (int n)\n {\n-  struct value *result_val = fetch (n);\n-  enum bfd_endian byte_order = gdbarch_byte_order (this->gdbarch);\n+  gdbarch *arch = this->m_per_objfile->objfile->arch ();\n+  value *result_val = fetch (n);\n+  bfd_endian byte_order = gdbarch_byte_order (arch);\n   ULONGEST result;\n \n   dwarf_require_integral (value_type (result_val));\n@@ -1107,14 +1127,14 @@ dwarf_expr_context::fetch_address (int n)\n      extract_unsigned_integer() will not produce a correct\n      result.  Make sure we invoke gdbarch_integer_to_address()\n      for those architectures which require it.  */\n-  if (gdbarch_integer_to_address_p (this->gdbarch))\n+  if (gdbarch_integer_to_address_p (arch))\n     {\n-      gdb_byte *buf = (gdb_byte *) alloca (this->addr_size);\n-      struct type *int_type = get_unsigned_type (this->gdbarch,\n-\t\t\t\t\t\t value_type (result_val));\n+      gdb_byte *buf = (gdb_byte *) alloca (this->m_addr_size);\n+      type *int_type = get_unsigned_type (arch,\n+\t\t\t\t\t  value_type (result_val));\n \n-      store_unsigned_integer (buf, this->addr_size, byte_order, result);\n-      return gdbarch_integer_to_address (this->gdbarch, int_type, buf);\n+      store_unsigned_integer (buf, this->m_addr_size, byte_order, result);\n+      return gdbarch_integer_to_address (arch, int_type, buf);\n     }\n \n   return (CORE_ADDR) result;\n@@ -1125,36 +1145,36 @@ dwarf_expr_context::fetch_address (int n)\n bool\n dwarf_expr_context::fetch_in_stack_memory (int n)\n {\n-  if (stack.size () <= n)\n+  if (this->m_stack.size () <= n)\n      error (_(\"Asked for position %d of stack, \"\n \t      \"stack only has %zu elements on it.\"),\n-\t    n, stack.size ());\n-  return stack[stack.size () - (1 + n)].in_stack_memory;\n+\t    n, this->m_stack.size ());\n+  return this->m_stack[this->m_stack.size () - (1 + n)].in_stack_memory;\n }\n \n /* Return true if the expression stack is empty.  */\n \n bool\n dwarf_expr_context::stack_empty_p () const\n {\n-  return stack.empty ();\n+  return m_stack.empty ();\n }\n \n /* Add a new piece to the dwarf_expr_context's piece list.  */\n void\n dwarf_expr_context::add_piece (ULONGEST size, ULONGEST offset)\n {\n-  this->pieces.emplace_back ();\n-  dwarf_expr_piece &p = this->pieces.back ();\n+  this->m_pieces.emplace_back ();\n+  dwarf_expr_piece &p = this->m_pieces.back ();\n \n-  p.location = this->location;\n+  p.location = this->m_location;\n   p.size = size;\n   p.offset = offset;\n \n   if (p.location == DWARF_VALUE_LITERAL)\n     {\n-      p.v.literal.data = this->data;\n-      p.v.literal.length = this->len;\n+      p.v.literal.data = this->m_data;\n+      p.v.literal.length = this->m_len;\n     }\n   else if (stack_empty_p ())\n     {\n@@ -1163,7 +1183,7 @@ dwarf_expr_context::add_piece (ULONGEST size, ULONGEST offset)\n \t a somewhat strange approach, but this lets us avoid setting\n \t the location to DWARF_VALUE_MEMORY in all the individual\n \t cases in the evaluator.  */\n-      this->location = DWARF_VALUE_OPTIMIZED_OUT;\n+      this->m_location = DWARF_VALUE_OPTIMIZED_OUT;\n     }\n   else if (p.location == DWARF_VALUE_MEMORY)\n     {\n@@ -1172,7 +1192,7 @@ dwarf_expr_context::add_piece (ULONGEST size, ULONGEST offset)\n     }\n   else if (p.location == DWARF_VALUE_IMPLICIT_POINTER)\n     {\n-      p.v.ptr.die_sect_off = (sect_offset) this->len;\n+      p.v.ptr.die_sect_off = (sect_offset) this->m_len;\n       p.v.ptr.offset = value_as_long (fetch (0));\n     }\n   else if (p.location == DWARF_VALUE_REGISTER)\n@@ -1188,13 +1208,13 @@ dwarf_expr_context::add_piece (ULONGEST size, ULONGEST offset)\n void\n dwarf_expr_context::eval (const gdb_byte *addr, size_t len)\n {\n-  int old_recursion_depth = this->recursion_depth;\n+  int old_recursion_depth = this->m_recursion_depth;\n \n   execute_stack_op (addr, addr + len);\n \n   /* RECURSION_DEPTH becomes invalid if an exception was thrown here.  */\n \n-  gdb_assert (this->recursion_depth == old_recursion_depth);\n+  gdb_assert (this->m_recursion_depth == old_recursion_depth);\n }\n \n /* Helper to read a uleb128 value or throw an error.  */\n@@ -1438,27 +1458,28 @@ void\n dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t\t\t\t      const gdb_byte *op_end)\n {\n-  enum bfd_endian byte_order = gdbarch_byte_order (this->gdbarch);\n+  gdbarch *arch = this->m_per_objfile->objfile->arch ();\n+  bfd_endian byte_order = gdbarch_byte_order (arch);\n   /* Old-style \"untyped\" DWARF values need special treatment in a\n      couple of places, specifically DW_OP_mod and DW_OP_shr.  We need\n      a special type for these values so we can distinguish them from\n      values that have an explicit type, because explicitly-typed\n      values do not need special treatment.  This special type must be\n      different (in the `==' sense) from any base type coming from the\n      CU.  */\n-  struct type *address_type = this->address_type ();\n+  type *address_type = this->address_type ();\n \n-  this->location = DWARF_VALUE_MEMORY;\n-  this->initialized = 1;  /* Default is initialized.  */\n+  this->m_location = DWARF_VALUE_MEMORY;\n+  this->m_initialized = 1;  /* Default is initialized.  */\n \n-  if (this->recursion_depth > this->max_recursion_depth)\n+  if (this->m_recursion_depth > this->m_max_recursion_depth)\n     error (_(\"DWARF-2 expression error: Loop detected (%d).\"),\n-\t   this->recursion_depth);\n-  this->recursion_depth++;\n+\t   this->m_recursion_depth);\n+  this->m_recursion_depth++;\n \n   while (op_ptr < op_end)\n     {\n-      enum dwarf_location_atom op = (enum dwarf_location_atom) *op_ptr++;\n+      dwarf_location_atom op = (dwarf_location_atom) *op_ptr++;\n       ULONGEST result;\n       /* Assume the value is not in stack memory.\n \t Code that knows otherwise sets this to true.\n@@ -1469,7 +1490,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n       bool in_stack_memory = false;\n       uint64_t uoffset, reg;\n       int64_t offset;\n-      struct value *result_val = NULL;\n+      value *result_val = NULL;\n \n       /* The DWARF expression might have a bug causing an infinite\n \t loop.  In that case, quitting is the only way out.  */\n@@ -1515,32 +1536,32 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \tcase DW_OP_addr:\n \t  result = extract_unsigned_integer (op_ptr,\n-\t\t\t\t\t     this->addr_size, byte_order);\n-\t  op_ptr += this->addr_size;\n+\t\t\t\t\t     this->m_addr_size, byte_order);\n+\t  op_ptr += this->m_addr_size;\n \t  /* Some versions of GCC emit DW_OP_addr before\n \t     DW_OP_GNU_push_tls_address.  In this case the value is an\n \t     index, not an address.  We don't support things like\n \t     branching between the address and the TLS op.  */\n \t  if (op_ptr >= op_end || *op_ptr != DW_OP_GNU_push_tls_address)\n-\t    result += this->per_objfile->objfile->text_section_offset ();\n+\t    result += this->m_per_objfile->objfile->text_section_offset ();\n \t  result_val = value_from_ulongest (address_type, result);\n \t  break;\n \n \tcase DW_OP_addrx:\n \tcase DW_OP_GNU_addr_index:\n-\t  ensure_have_per_cu (this->per_cu, \"DW_OP_addrx\");\n+\t  ensure_have_per_cu (this->m_per_cu, \"DW_OP_addrx\");\n \n \t  op_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);\n-\t  result = dwarf2_read_addr_index (this->per_cu, this->per_objfile,\n+\t  result = dwarf2_read_addr_index (this->m_per_cu, this->m_per_objfile,\n \t\t\t\t\t   uoffset);\n-\t  result += this->per_objfile->objfile->text_section_offset ();\n+\t  result += this->m_per_objfile->objfile->text_section_offset ();\n \t  result_val = value_from_ulongest (address_type, result);\n \t  break;\n \tcase DW_OP_GNU_const_index:\n-\t  ensure_have_per_cu (this->per_cu, \"DW_OP_GNU_const_index\");\n+\t  ensure_have_per_cu (this->m_per_cu, \"DW_OP_GNU_const_index\");\n \n \t  op_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);\n-\t  result = dwarf2_read_addr_index (this->per_cu, this->per_objfile,\n+\t  result = dwarf2_read_addr_index (this->m_per_cu, this->m_per_objfile,\n \t\t\t\t\t   uoffset);\n \t  result_val = value_from_ulongest (address_type, result);\n \t  break;\n@@ -1634,7 +1655,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \t  result = op - DW_OP_reg0;\n \t  result_val = value_from_ulongest (address_type, result);\n-\t  this->location = DWARF_VALUE_REGISTER;\n+\t  this->m_location = DWARF_VALUE_REGISTER;\n \t  break;\n \n \tcase DW_OP_regx:\n@@ -1643,7 +1664,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \t  result = reg;\n \t  result_val = value_from_ulongest (address_type, result);\n-\t  this->location = DWARF_VALUE_REGISTER;\n+\t  this->m_location = DWARF_VALUE_REGISTER;\n \t  break;\n \n \tcase DW_OP_implicit_value:\n@@ -1653,30 +1674,30 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &len);\n \t    if (op_ptr + len > op_end)\n \t      error (_(\"DW_OP_implicit_value: too few bytes available.\"));\n-\t    this->len = len;\n-\t    this->data = op_ptr;\n-\t    this->location = DWARF_VALUE_LITERAL;\n+\t    this->m_len = len;\n+\t    this->m_data = op_ptr;\n+\t    this->m_location = DWARF_VALUE_LITERAL;\n \t    op_ptr += len;\n \t    dwarf_expr_require_composition (op_ptr, op_end,\n \t\t\t\t\t    \"DW_OP_implicit_value\");\n \t  }\n \t  goto no_push;\n \n \tcase DW_OP_stack_value:\n-\t  this->location = DWARF_VALUE_STACK;\n+\t  this->m_location = DWARF_VALUE_STACK;\n \t  dwarf_expr_require_composition (op_ptr, op_end, \"DW_OP_stack_value\");\n \t  goto no_push;\n \n \tcase DW_OP_implicit_pointer:\n \tcase DW_OP_GNU_implicit_pointer:\n \t  {\n \t    int64_t len;\n-\t    ensure_have_per_cu (this->per_cu, \"DW_OP_implicit_pointer\");\n+\t    ensure_have_per_cu (this->m_per_cu, \"DW_OP_implicit_pointer\");\n \n-\t    int ref_addr_size = this->per_cu->ref_addr_size ();\n+\t    int ref_addr_size = this->m_per_cu->ref_addr_size ();\n \n \t    /* The referred-to DIE of sect_offset kind.  */\n-\t    this->len = extract_unsigned_integer (op_ptr, ref_addr_size,\n+\t    this->m_len = extract_unsigned_integer (op_ptr, ref_addr_size,\n \t\t\t\t\t\t  byte_order);\n \t    op_ptr += ref_addr_size;\n \n@@ -1685,7 +1706,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    result = (ULONGEST) len;\n \t    result_val = value_from_ulongest (address_type, result);\n \n-\t    this->location = DWARF_VALUE_IMPLICIT_POINTER;\n+\t    this->m_location = DWARF_VALUE_IMPLICIT_POINTER;\n \t    dwarf_expr_require_composition (op_ptr, op_end,\n \t\t\t\t\t    \"DW_OP_implicit_pointer\");\n \t  }\n@@ -1725,9 +1746,9 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \tcase DW_OP_breg31:\n \t  {\n \t    op_ptr = safe_read_sleb128 (op_ptr, op_end, &offset);\n-\t    ensure_have_frame (this->frame, \"DW_OP_breg\");\n+\t    ensure_have_frame (this->m_frame, \"DW_OP_breg\");\n \n-\t    result = read_addr_from_reg (this->frame, op - DW_OP_breg0);\n+\t    result = read_addr_from_reg (this->m_frame, op - DW_OP_breg0);\n \t    result += offset;\n \t    result_val = value_from_ulongest (address_type, result);\n \t  }\n@@ -1736,9 +1757,9 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t  {\n \t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &reg);\n \t    op_ptr = safe_read_sleb128 (op_ptr, op_end, &offset);\n-\t    ensure_have_frame (this->frame, \"DW_OP_bregx\");\n+\t    ensure_have_frame (this->m_frame, \"DW_OP_bregx\");\n \n-\t    result = read_addr_from_reg (this->frame, reg);\n+\t    result = read_addr_from_reg (this->m_frame, reg);\n \t    result += offset;\n \t    result_val = value_from_ulongest (address_type, result);\n \t  }\n@@ -1754,19 +1775,19 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t       backup the current stack locally and install a new empty stack,\n \t       then reset it afterwards, effectively erasing whatever the\n \t       recursive call put there.  */\n-\t    std::vector<dwarf_stack_value> saved_stack = std::move (stack);\n-\t    stack.clear ();\n+\t    std::vector<dwarf_stack_value> saved_stack = std::move (this->m_stack);\n+\t    this->m_stack.clear ();\n \n \t    /* FIXME: cagney/2003-03-26: This code should be using\n \t       get_frame_base_address(), and then implement a dwarf2\n \t       specific this_base method.  */\n \t    this->get_frame_base (&datastart, &datalen);\n \t    eval (datastart, datalen);\n-\t    if (this->location == DWARF_VALUE_MEMORY)\n+\t    if (this->m_location == DWARF_VALUE_MEMORY)\n \t      result = fetch_address (0);\n-\t    else if (this->location == DWARF_VALUE_REGISTER)\n+\t    else if (this->m_location == DWARF_VALUE_REGISTER)\n \t      result\n-\t\t= read_addr_from_reg (this->frame, value_as_long (fetch (0)));\n+\t\t= read_addr_from_reg (this->m_frame, value_as_long (fetch (0)));\n \t    else\n \t      error (_(\"Not implemented: computing frame \"\n \t\t       \"base using explicit value operator\"));\n@@ -1775,9 +1796,9 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    in_stack_memory = true;\n \n \t    /* Restore the content of the original stack.  */\n-\t    stack = std::move (saved_stack);\n+\t    this->m_stack = std::move (saved_stack);\n \n-\t    this->location = DWARF_VALUE_MEMORY;\n+\t    this->m_location = DWARF_VALUE_MEMORY;\n \t  }\n \t  break;\n \n@@ -1798,13 +1819,13 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t  \n \tcase DW_OP_swap:\n \t  {\n-\t    if (stack.size () < 2)\n+\t    if (this->m_stack.size () < 2)\n \t       error (_(\"Not enough elements for \"\n \t\t\t\"DW_OP_swap.  Need 2, have %zu.\"),\n-\t\t      stack.size ());\n+\t\t      this->m_stack.size ());\n \n-\t    dwarf_stack_value &t1 = stack[stack.size () - 1];\n-\t    dwarf_stack_value &t2 = stack[stack.size () - 2];\n+\t    dwarf_stack_value &t1 = this->m_stack[this->m_stack.size () - 1];\n+\t    dwarf_stack_value &t2 = this->m_stack[this->m_stack.size () - 2];\n \t    std::swap (t1, t2);\n \t    goto no_push;\n \t  }\n@@ -1816,15 +1837,17 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \tcase DW_OP_rot:\n \t  {\n-\t    if (stack.size () < 3)\n+\t    if (this->m_stack.size () < 3)\n \t       error (_(\"Not enough elements for \"\n \t\t\t\"DW_OP_rot.  Need 3, have %zu.\"),\n-\t\t      stack.size ());\n-\n-\t    dwarf_stack_value temp = stack[stack.size () - 1];\n-\t    stack[stack.size () - 1] = stack[stack.size () - 2];\n-\t    stack[stack.size () - 2] = stack[stack.size () - 3];\n-\t    stack[stack.size () - 3] = temp;\n+\t\t      this->m_stack.size ());\n+\n+\t    dwarf_stack_value temp = this->m_stack[this->m_stack.size () - 1];\n+\t    this->m_stack[this->m_stack.size () - 1]\n+\t      = this->m_stack[this->m_stack.size () - 2];\n+\t    this->m_stack[this->m_stack.size () - 2]\n+\t       = this->m_stack[this->m_stack.size () - 3];\n+\t    this->m_stack[this->m_stack.size () - 3] = temp;\n \t    goto no_push;\n \t  }\n \n@@ -1833,7 +1856,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \tcase DW_OP_deref_type:\n \tcase DW_OP_GNU_deref_type:\n \t  {\n-\t    int addr_size = (op == DW_OP_deref ? this->addr_size : *op_ptr++);\n+\t    int addr_size = (op == DW_OP_deref ? this->m_addr_size : *op_ptr++);\n \t    gdb_byte *buf = (gdb_byte *) alloca (addr_size);\n \t    CORE_ADDR addr = fetch_address (0);\n \t    struct type *type;\n@@ -1954,8 +1977,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t\t     math.  */\n \t\t  if (orig_type == address_type)\n \t\t    {\n-\t\t      struct type *utype\n-\t\t\t= get_unsigned_type (this->gdbarch, orig_type);\n+\t\t      struct type *utype = get_unsigned_type (arch, orig_type);\n \n \t\t      cast_back = 1;\n \t\t      first = value_cast (utype, first);\n@@ -1990,7 +2012,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t\tif (!value_type (first)->is_unsigned ())\n \t\t  {\n \t\t    struct type *utype\n-\t\t      = get_unsigned_type (this->gdbarch, value_type (first));\n+\t\t      = get_unsigned_type (arch, value_type (first));\n \n \t\t    first = value_cast (utype, first);\n \t\t  }\n@@ -2007,7 +2029,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t\tif (value_type (first)->is_unsigned ())\n \t\t  {\n \t\t    struct type *stype\n-\t\t      = get_signed_type (this->gdbarch, value_type (first));\n+\t\t      = get_signed_type (arch, value_type (first));\n \n \t\t    first = value_cast (stype, first);\n \t\t  }\n@@ -2058,9 +2080,9 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t  break;\n \n \tcase DW_OP_call_frame_cfa:\n-\t  ensure_have_frame (this->frame, \"DW_OP_call_frame_cfa\");\n+\t  ensure_have_frame (this->m_frame, \"DW_OP_call_frame_cfa\");\n \n-\t  result = dwarf2_frame_cfa (this->frame);\n+\t  result = dwarf2_frame_cfa (this->m_frame);\n \t  result_val = value_from_ulongest (address_type, result);\n \t  in_stack_memory = true;\n \t  break;\n@@ -2077,7 +2099,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t  returned.  */\n \t  result = value_as_long (fetch (0));\n \t  pop ();\n-\t  result = target_translate_tls_address (this->per_objfile->objfile,\n+\t  result = target_translate_tls_address (this->m_per_objfile->objfile,\n \t\t\t\t\t\t result);\n \t  result_val = value_from_ulongest (address_type, result);\n \t  break;\n@@ -2115,10 +2137,10 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \t    /* Pop off the address/regnum, and reset the location\n \t       type.  */\n-\t    if (this->location != DWARF_VALUE_LITERAL\n-\t\t&& this->location != DWARF_VALUE_OPTIMIZED_OUT)\n+\t    if (this->m_location != DWARF_VALUE_LITERAL\n+\t\t&& this->m_location != DWARF_VALUE_OPTIMIZED_OUT)\n \t      pop ();\n-\t    this->location = DWARF_VALUE_MEMORY;\n+\t    this->m_location = DWARF_VALUE_MEMORY;\n \t  }\n \t  goto no_push;\n \n@@ -2133,10 +2155,10 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \t    /* Pop off the address/regnum, and reset the location\n \t       type.  */\n-\t    if (this->location != DWARF_VALUE_LITERAL\n-\t\t&& this->location != DWARF_VALUE_OPTIMIZED_OUT)\n+\t    if (this->m_location != DWARF_VALUE_LITERAL\n+\t\t&& this->m_location != DWARF_VALUE_OPTIMIZED_OUT)\n \t      pop ();\n-\t    this->location = DWARF_VALUE_MEMORY;\n+\t    this->m_location = DWARF_VALUE_MEMORY;\n \t  }\n \t  goto no_push;\n \n@@ -2145,7 +2167,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    error (_(\"DWARF-2 expression error: DW_OP_GNU_uninit must always \"\n \t\t   \"be the very last op.\"));\n \n-\t  this->initialized = 0;\n+\t  this->m_initialized = 0;\n \t  goto no_push;\n \n \tcase DW_OP_call2:\n@@ -2168,16 +2190,16 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \tcase DW_OP_GNU_variable_value:\n \t  {\n-\t    ensure_have_per_cu (this->per_cu, \"DW_OP_GNU_variable_value\");\n-\t    int ref_addr_size = this->per_cu->ref_addr_size ();\n+\t    ensure_have_per_cu (this->m_per_cu, \"DW_OP_GNU_variable_value\");\n+\t    int ref_addr_size = this->m_per_cu->ref_addr_size ();\n \n \t    sect_offset sect_off\n \t      = (sect_offset) extract_unsigned_integer (op_ptr,\n \t\t\t\t\t\t\tref_addr_size,\n \t\t\t\t\t\t\tbyte_order);\n \t    op_ptr += ref_addr_size;\n-\t    result_val = sect_variable_value (sect_off, this->per_cu,\n-\t\t\t\t\t      this->per_objfile);\n+\t    result_val = sect_variable_value (sect_off, this->m_per_cu,\n+\t\t\t\t\t      this->m_per_objfile);\n \t    result_val = value_cast (address_type, result_val);\n \t  }\n \t  break;\n@@ -2209,7 +2231,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    if (kind_u.dwarf_reg != -1)\n \t      {\n \t\tif (deref_size == -1)\n-\t\t  deref_size = this->addr_size;\n+\t\t  deref_size = this->m_addr_size;\n \t\top_ptr += len;\n \t\tthis->push_dwarf_reg_entry_value (CALL_SITE_PARAMETER_DWARF_REG,\n \t\t\t\t\t\t  kind_u, deref_size);\n@@ -2264,13 +2286,13 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);\n \t    cu_offset type_die_cu_off = (cu_offset) uoffset;\n \n-\t    ensure_have_frame (this->frame, \"DW_OP_regval_type\");\n+\t    ensure_have_frame (this->m_frame, \"DW_OP_regval_type\");\n \n \t    struct type *type = get_base_type (type_die_cu_off);\n \t    int regnum\n-\t      = dwarf_reg_to_regnum_or_error (get_frame_arch (this->frame),\n+\t      = dwarf_reg_to_regnum_or_error (get_frame_arch (this->m_frame),\n \t\t\t\t\t      reg);\n-\t    result_val = value_from_register (type, regnum, this->frame);\n+\t    result_val = value_from_register (type, regnum, this->m_frame);\n \t  }\n \t  break;\n \n@@ -2310,11 +2332,11 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \tcase DW_OP_push_object_address:\n \t  /* Return the address of the object we are currently observing.  */\n-\t  if (this->data_view.data () == nullptr\n-\t      && this->obj_address == 0)\n+\t  if (this->m_addr_info == nullptr)\n \t    error (_(\"Location address is not set.\"));\n \n-\t  result_val = value_from_ulongest (address_type, this->obj_address);\n+\t  result_val\n+\t    = value_from_ulongest (address_type, this->m_addr_info->addr);\n \t  break;\n \n \tdefault:\n@@ -2331,11 +2353,11 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n   /* To simplify our main caller, if the result is an implicit\n      pointer, then make a pieced value.  This is ok because we can't\n      have implicit pointers in contexts where pieces are invalid.  */\n-  if (this->location == DWARF_VALUE_IMPLICIT_POINTER)\n-    add_piece (8 * this->addr_size, 0);\n+  if (this->m_location == DWARF_VALUE_IMPLICIT_POINTER)\n+    add_piece (8 * this->m_addr_size, 0);\n \n-  this->recursion_depth--;\n-  gdb_assert (this->recursion_depth >= 0);\n+  this->m_recursion_depth--;\n+  gdb_assert (this->m_recursion_depth >= 0);\n }\n \n void _initialize_dwarf2expr ();"
    },
    {
      "sha": "a10fbac07445f26b897759971e2de80637a0d593",
      "filename": "gdb/dwarf2/expr.h",
      "status": "modified",
      "additions": 34,
      "deletions": 29,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0579205aec4369375dccb8566ba37eefee2be912/gdb/dwarf2/expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0579205aec4369375dccb8566ba37eefee2be912/gdb/dwarf2/expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.h?ref=0579205aec4369375dccb8566ba37eefee2be912",
      "patch": "@@ -119,45 +119,48 @@ struct dwarf_stack_value\n    its current state and its callbacks.  */\n struct dwarf_expr_context\n {\n-  dwarf_expr_context (dwarf2_per_objfile *per_objfile);\n+  dwarf_expr_context (dwarf2_per_objfile *per_objfile,\n+\t\t      int addr_size);\n   virtual ~dwarf_expr_context () = default;\n \n   void push_address (CORE_ADDR value, bool in_stack_memory);\n-  void eval (const gdb_byte *addr, size_t len);\n \n-  /* Fetch the result of the expression evaluation in a form of\n-     a struct value, where TYPE, SUBOBJ_TYPE and SUBOBJ_OFFSET\n-     describe the source level representation of that result.  */\n-  value *fetch_result (struct type *type = nullptr,\n-\t\t       struct type *subobj_type = nullptr,\n-\t\t       LONGEST subobj_offset = 0);\n+  /* Evaluate the expression at ADDR (LEN bytes long) in a given PER_CU\n+     and FRAME context.  TYPE, SUBOBJ_TYPE and SUBOBJ_OFFSET describe\n+     the expected struct value representation of the evaluation\n+     result.  The ADDR_INFO property can be specified to override the\n+     range of memory addresses with the passed in buffer.  */\n+  value *evaluate (const gdb_byte *addr, size_t len,\n+\t\t   dwarf2_per_cu_data *per_cu, frame_info *frame,\n+\t\t   const struct property_addr_info *addr_info = nullptr,\n+\t\t   struct type *type = nullptr,\n+\t\t   struct type *subobj_type = nullptr,\n+\t\t   LONGEST subobj_offset = 0);\n \n+private:\n   /* The stack of values.  */\n-  std::vector<dwarf_stack_value> stack;\n-\n-  /* Target architecture to use for address operations.  */\n-  struct gdbarch *gdbarch = nullptr;\n+  std::vector<dwarf_stack_value> m_stack;\n \n   /* Target address size in bytes.  */\n-  int addr_size = 0;\n+  int m_addr_size = 0;\n \n   /* The current depth of dwarf expression recursion, via DW_OP_call*,\n      DW_OP_fbreg, DW_OP_push_object_address, etc., and the maximum\n      depth we'll tolerate before raising an error.  */\n-  int recursion_depth = 0, max_recursion_depth = 0x100;\n+  int m_recursion_depth = 0, m_max_recursion_depth = 0x100;\n \n   /* Location of the value.  */\n-  dwarf_value_location location = DWARF_VALUE_MEMORY;\n+  dwarf_value_location m_location = DWARF_VALUE_MEMORY;\n \n   /* For DWARF_VALUE_LITERAL, the current literal value's length and\n      data.  For DWARF_VALUE_IMPLICIT_POINTER, LEN is the offset of the\n      target DIE of sect_offset kind.  */\n-  ULONGEST len = 0;\n-  const gdb_byte *data = nullptr;\n+  ULONGEST m_len = 0;\n+  const gdb_byte *m_data = nullptr;\n \n   /* Initialization status of variable: Non-zero if variable has been\n      initialized; zero otherwise.  */\n-  int initialized = 0;\n+  int m_initialized = 0;\n \n   /* A vector of pieces.\n \n@@ -181,25 +184,21 @@ struct dwarf_expr_context\n      no DW_OP_piece operations have no value to place in a piece's\n      'size' field; the size comes from the surrounding data.  So the\n      two cases need to be handled separately.)  */\n-  std::vector<dwarf_expr_piece> pieces;\n+  std::vector<dwarf_expr_piece> m_pieces;\n \n   /* We evaluate the expression in the context of this objfile.  */\n-  dwarf2_per_objfile *per_objfile;\n+  dwarf2_per_objfile *m_per_objfile;\n \n   /* Frame information used for the evaluation.  */\n-  frame_info *frame = nullptr;\n+  frame_info *m_frame = nullptr;\n \n   /* Compilation unit used for the evaluation.  */\n-  dwarf2_per_cu_data *per_cu = nullptr;\n-\n-  /* Object address used for the evaluation.  */\n-  CORE_ADDR obj_address = 0;\n+  dwarf2_per_cu_data *m_per_cu = nullptr;\n \n-  /* The data that was passed in.  */\n-  gdb::array_view<const gdb_byte> data_view;\n-\n-private:\n+  /* Property address info used for the evaluation.  */\n+  const struct property_addr_info *m_addr_info = nullptr;\n \n+  void eval (const gdb_byte *addr, size_t len);\n   struct type *address_type () const;\n   void push (struct value *value, bool in_stack_memory);\n   bool stack_empty_p () const;\n@@ -210,6 +209,12 @@ struct dwarf_expr_context\n   CORE_ADDR fetch_address (int n);\n   bool fetch_in_stack_memory (int n);\n \n+  /* Fetch the result of the expression evaluation in a form of\n+     a struct value, where TYPE, SUBOBJ_TYPE and SUBOBJ_OFFSET\n+     describe the source level representation of that result.  */\n+  value *fetch_result (struct type *type, struct type *subobj_type,\n+\t\t       LONGEST subobj_offset);\n+\n   /* Return the location expression for the frame base attribute, in\n      START and LENGTH.  The result must be live until the current\n      expression evaluation is complete.  */"
    },
    {
      "sha": "ae26a8868d193babef048bb975361c041b665cfd",
      "filename": "gdb/dwarf2/frame.c",
      "status": "modified",
      "additions": 4,
      "deletions": 13,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0579205aec4369375dccb8566ba37eefee2be912/gdb/dwarf2/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0579205aec4369375dccb8566ba37eefee2be912/gdb/dwarf2/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame.c?ref=0579205aec4369375dccb8566ba37eefee2be912",
      "patch": "@@ -229,25 +229,16 @@ execute_stack_op (const gdb_byte *exp, ULONGEST len, int addr_size,\n \t\t  struct frame_info *this_frame, CORE_ADDR initial,\n \t\t  int initial_in_stack_memory, dwarf2_per_objfile *per_objfile)\n {\n-  dwarf_expr_context ctx (per_objfile);\n+  dwarf_expr_context ctx (per_objfile, addr_size);\n   scoped_value_mark free_values;\n \n-  ctx.frame = this_frame;\n-  ctx.gdbarch = get_frame_arch (this_frame);\n-  ctx.addr_size = addr_size;\n-\n   ctx.push_address (initial, initial_in_stack_memory);\n-  ctx.eval (exp, len);\n-\n-  CORE_ADDR result;\n-  struct value *result_val = ctx.fetch_result ();\n+  value *result_val = ctx.evaluate (exp, len, nullptr, this_frame);\n \n   if (VALUE_LVAL (result_val) == lval_memory)\n-    result = value_address (result_val);\n+    return value_address (result_val);\n   else\n-    result = value_as_address (result_val);\n-\n-  return result;\n+    return value_as_address (result_val);\n }\n \f\n "
    },
    {
      "sha": "d29fdcf6330b4d5b7b6e7188f73f090d7c22ade5",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 14,
      "deletions": 27,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0579205aec4369375dccb8566ba37eefee2be912/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0579205aec4369375dccb8566ba37eefee2be912/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=0579205aec4369375dccb8566ba37eefee2be912",
      "patch": "@@ -1461,8 +1461,6 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n \t\t\t       struct type *subobj_type,\n \t\t\t       LONGEST subobj_byte_offset)\n {\n-  struct value *retval;\n-\n   if (subobj_type == NULL)\n     {\n       subobj_type = type;\n@@ -1474,21 +1472,15 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n   if (size == 0)\n     return allocate_optimized_out_value (subobj_type);\n \n-  dwarf_expr_context ctx (per_objfile);\n-  ctx.frame = frame;\n-  ctx.per_cu = per_cu;\n-  ctx.obj_address = 0;\n+  dwarf_expr_context ctx (per_objfile, per_cu->addr_size ());\n \n+  value *retval;\n   scoped_value_mark free_values;\n \n-  ctx.gdbarch = per_objfile->objfile->arch ();\n-  ctx.addr_size = per_cu->addr_size ();\n-\n   try\n     {\n-      ctx.eval (data, size);\n-      retval = ctx.fetch_result (type, subobj_type,\n-\t\t\t\t subobj_byte_offset);\n+      retval = ctx.evaluate (data, size, per_cu, frame, nullptr, type,\n+\t\t\t     subobj_type, subobj_byte_offset);\n     }\n   catch (const gdb_exception_error &ex)\n     {\n@@ -1558,29 +1550,24 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n     return 0;\n \n   dwarf2_per_objfile *per_objfile = dlbaton->per_objfile;\n-  dwarf_expr_context ctx (per_objfile);\n+  dwarf2_per_cu_data *per_cu = dlbaton->per_cu;\n+  dwarf_expr_context ctx (per_objfile, per_cu->addr_size ());\n \n-  struct value *result;\n+  value *result;\n   scoped_value_mark free_values;\n \n-  ctx.frame = frame;\n-  ctx.per_cu = dlbaton->per_cu;\n-  if (addr_stack != nullptr)\n+  if (push_initial_value)\n     {\n-      ctx.obj_address = addr_stack->addr;\n-      ctx.data_view = addr_stack->valaddr;\n+      if (addr_stack != nullptr)\n+\tctx.push_address (addr_stack->addr, false);\n+      else\n+\tctx.push_address (0, false);\n     }\n \n-  ctx.gdbarch = per_objfile->objfile->arch ();\n-  ctx.addr_size = dlbaton->per_cu->addr_size ();\n-\n-  if (push_initial_value)\n-    ctx.push_address (ctx.obj_address, false);\n-\n   try\n     {\n-      ctx.eval (dlbaton->data, dlbaton->size);\n-      result = ctx.fetch_result ();\n+      result = ctx.evaluate (dlbaton->data, dlbaton->size,\n+\t\t\t     per_cu, frame, addr_stack);\n     }\n   catch (const gdb_exception_error &ex)\n     {"
    }
  ]
}