{
  "sha": "c499eb6896cd803d26da8c719bfac9c03e596c08",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzQ5OWViNjg5NmNkODAzZDI2ZGE4YzcxOWJmYWM5YzAzZTU5NmMwOA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-24T10:22:03Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:08:26Z"
    },
    "message": "libctf: type copying\n\nctf_add_type() allows you to copy types, and all the types they depend\non, from one container to another (writable) container. This lets a\nprogram maintaining multiple distinct containers (not in a parent-child\nrelationship) introduce types that depend on types in one container in\nanother writable one, by copying the necessary types.\n\nlibctf/\n\t* ctf-create.c (enumcmp): New.\n\t(enumadd): Likewise.\n\t(membcmp): Likewise.\n\t(membadd): Likewise.\n\t(ctf_add_type): Likewise.",
    "tree": {
      "sha": "f36ab930a9817d7e78c17ec720983b1bb64f5374",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f36ab930a9817d7e78c17ec720983b1bb64f5374"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c499eb6896cd803d26da8c719bfac9c03e596c08",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c499eb6896cd803d26da8c719bfac9c03e596c08",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c499eb6896cd803d26da8c719bfac9c03e596c08",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c499eb6896cd803d26da8c719bfac9c03e596c08/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b437bfe0f4cf06559ca4c508a2869383196ddc6b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b437bfe0f4cf06559ca4c508a2869383196ddc6b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b437bfe0f4cf06559ca4c508a2869383196ddc6b"
    }
  ],
  "stats": {
    "total": 493,
    "additions": 493,
    "deletions": 0
  },
  "files": [
    {
      "sha": "c0c98d2f43f13828ea27ae4f898e22f91f929935",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c499eb6896cd803d26da8c719bfac9c03e596c08/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c499eb6896cd803d26da8c719bfac9c03e596c08/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=c499eb6896cd803d26da8c719bfac9c03e596c08",
      "patch": "@@ -1,3 +1,11 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-create.c (enumcmp): New.\n+\t(enumadd): Likewise.\n+\t(membcmp): Likewise.\n+\t(membadd): Likewise.\n+\t(ctf_add_type): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-lookup.c (isqualifier): New."
    },
    {
      "sha": "5409ca4bb4d3eddb56b963e4861c64684d496f84",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 485,
      "deletions": 0,
      "changes": 485,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c499eb6896cd803d26da8c719bfac9c03e596c08/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c499eb6896cd803d26da8c719bfac9c03e596c08/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=c499eb6896cd803d26da8c719bfac9c03e596c08",
      "patch": "@@ -1446,6 +1446,491 @@ ctf_add_variable (ctf_file_t *fp, const char *name, ctf_id_t ref)\n   return 0;\n }\n \n+static int\n+enumcmp (const char *name, int value, void *arg)\n+{\n+  ctf_bundle_t *ctb = arg;\n+  int bvalue;\n+\n+  if (ctf_enum_value (ctb->ctb_file, ctb->ctb_type, name, &bvalue) == CTF_ERR)\n+    {\n+      ctf_dprintf (\"Conflict due to member %s iteration error.\\n\", name);\n+      return 1;\n+    }\n+  if (value != bvalue)\n+    {\n+      ctf_dprintf (\"Conflict due to value change: %i versus %i\\n\",\n+\t\t   value, bvalue);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+static int\n+enumadd (const char *name, int value, void *arg)\n+{\n+  ctf_bundle_t *ctb = arg;\n+\n+  return (ctf_add_enumerator (ctb->ctb_file, ctb->ctb_type,\n+\t\t\t      name, value) == CTF_ERR);\n+}\n+\n+static int\n+membcmp (const char *name, ctf_id_t type _libctf_unused_, unsigned long offset,\n+\t void *arg)\n+{\n+  ctf_bundle_t *ctb = arg;\n+  ctf_membinfo_t ctm;\n+\n+  if (ctf_member_info (ctb->ctb_file, ctb->ctb_type, name, &ctm) == CTF_ERR)\n+    {\n+      ctf_dprintf (\"Conflict due to member %s iteration error.\\n\", name);\n+      return 1;\n+    }\n+  if (ctm.ctm_offset != offset)\n+    {\n+      ctf_dprintf (\"Conflict due to member %s offset change: \"\n+\t\t   \"%lx versus %lx\\n\", name, ctm.ctm_offset, offset);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+static int\n+membadd (const char *name, ctf_id_t type, unsigned long offset, void *arg)\n+{\n+  ctf_bundle_t *ctb = arg;\n+  ctf_dmdef_t *dmd;\n+  char *s = NULL;\n+\n+  if ((dmd = ctf_alloc (sizeof (ctf_dmdef_t))) == NULL)\n+    return (ctf_set_errno (ctb->ctb_file, EAGAIN));\n+\n+  if (name != NULL && (s = ctf_strdup (name)) == NULL)\n+    {\n+      ctf_free (dmd);\n+      return (ctf_set_errno (ctb->ctb_file, EAGAIN));\n+    }\n+\n+  /* For now, dmd_type is copied as the src_fp's type; it is reset to an\n+    equivalent dst_fp type by a final loop in ctf_add_type(), below.  */\n+  dmd->dmd_name = s;\n+  dmd->dmd_type = type;\n+  dmd->dmd_offset = offset;\n+  dmd->dmd_value = -1;\n+\n+  ctf_list_append (&ctb->ctb_dtd->dtd_u.dtu_members, dmd);\n+\n+  if (s != NULL)\n+    ctb->ctb_file->ctf_dtvstrlen += strlen (s) + 1;\n+\n+  ctb->ctb_file->ctf_flags |= LCTF_DIRTY;\n+  return 0;\n+}\n+\n+/* The ctf_add_type routine is used to copy a type from a source CTF container\n+   to a dynamic destination container.  This routine operates recursively by\n+   following the source type's links and embedded member types.  If the\n+   destination container already contains a named type which has the same\n+   attributes, then we succeed and return this type but no changes occur.  */\n+ctf_id_t\n+ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n+{\n+  ctf_id_t dst_type = CTF_ERR;\n+  uint32_t dst_kind = CTF_K_UNKNOWN;\n+  ctf_id_t tmp;\n+\n+  const char *name;\n+  uint32_t kind, flag, vlen;\n+\n+  const ctf_type_t *src_tp, *dst_tp;\n+  ctf_bundle_t src, dst;\n+  ctf_encoding_t src_en, dst_en;\n+  ctf_arinfo_t src_ar, dst_ar;\n+\n+  ctf_dtdef_t *dtd;\n+  ctf_funcinfo_t ctc;\n+  ssize_t size;\n+\n+  ctf_hash_t *hp;\n+\n+  if (!(dst_fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (dst_fp, ECTF_RDONLY));\n+\n+  if ((src_tp = ctf_lookup_by_id (&src_fp, src_type)) == NULL)\n+    return (ctf_set_errno (dst_fp, ctf_errno (src_fp)));\n+\n+  name = ctf_strptr (src_fp, src_tp->ctt_name);\n+  kind = LCTF_INFO_KIND (src_fp, src_tp->ctt_info);\n+  flag = LCTF_INFO_ISROOT (src_fp, src_tp->ctt_info);\n+  vlen = LCTF_INFO_VLEN (src_fp, src_tp->ctt_info);\n+\n+  switch (kind)\n+    {\n+    case CTF_K_STRUCT:\n+      hp = dst_fp->ctf_structs;\n+      break;\n+    case CTF_K_UNION:\n+      hp = dst_fp->ctf_unions;\n+      break;\n+    case CTF_K_ENUM:\n+      hp = dst_fp->ctf_enums;\n+      break;\n+    default:\n+      hp = dst_fp->ctf_names;\n+      break;\n+    }\n+\n+  /* If the source type has a name and is a root type (visible at the\n+     top-level scope), lookup the name in the destination container and\n+     verify that it is of the same kind before we do anything else.  */\n+\n+  if ((flag & CTF_ADD_ROOT) && name[0] != '\\0'\n+      && (tmp = ctf_hash_lookup_type (hp, dst_fp, name)) != 0)\n+    {\n+      dst_type = tmp;\n+      dst_kind = ctf_type_kind_unsliced (dst_fp, dst_type);\n+    }\n+\n+  /* If an identically named dst_type exists, fail with ECTF_CONFLICT\n+     unless dst_type is a forward declaration and src_type is a struct,\n+     union, or enum (i.e. the definition of the previous forward decl).  */\n+\n+  if (dst_type != CTF_ERR && dst_kind != kind\n+      && (dst_kind != CTF_K_FORWARD\n+\t  || (kind != CTF_K_ENUM && kind != CTF_K_STRUCT\n+\t      && kind != CTF_K_UNION)))\n+    {\n+      ctf_dprintf (\"Conflict for type %s: kinds differ, new: %i; \"\n+\t\t   \"old (ID %lx): %i\\n\", name, kind, dst_type, dst_kind);\n+      return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n+    }\n+\n+  /* We take special action for an integer, float, or slice since it is\n+     described not only by its name but also its encoding.  For integers,\n+     bit-fields exploit this degeneracy.  */\n+\n+  if (kind == CTF_K_INTEGER || kind == CTF_K_FLOAT || kind == CTF_K_SLICE)\n+    {\n+      if (ctf_type_encoding (src_fp, src_type, &src_en) != 0)\n+\treturn (ctf_set_errno (dst_fp, ctf_errno (src_fp)));\n+\n+      if (dst_type != CTF_ERR)\n+\t{\n+\t  ctf_file_t *fp = dst_fp;\n+\n+\t  if ((dst_tp = ctf_lookup_by_id (&fp, dst_type)) == NULL)\n+\t    return CTF_ERR;\n+\n+\t  if (LCTF_INFO_ISROOT (fp, dst_tp->ctt_info) & CTF_ADD_ROOT)\n+\t    {\n+\t      /* The type that we found in the hash is also root-visible.  If\n+\t\t the two types match then use the existing one; otherwise,\n+\t\t declare a conflict.  Note: slices are not certain to match\n+\t\t even if there is no conflict: we must check the contained type\n+\t\t too.  */\n+\n+\t      if (ctf_type_encoding (dst_fp, dst_type, &dst_en) != 0)\n+\t\treturn CTF_ERR;\t\t\t/* errno set for us.  */\n+\n+\t      if (memcmp (&src_en, &dst_en, sizeof (ctf_encoding_t)) == 0)\n+\t\t{\n+\t\t  if (kind != CTF_K_SLICE)\n+\t\t    return dst_type;\n+\t\t}\n+\t      else\n+\t\t  {\n+\t\t    return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n+\t\t  }\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We found a non-root-visible type in the hash.  We reset\n+\t         dst_type to ensure that we continue to look for a possible\n+\t         conflict in the pending list.  */\n+\n+\t      dst_type = CTF_ERR;\n+\t    }\n+\t}\n+    }\n+\n+  /* If the non-empty name was not found in the appropriate hash, search\n+     the list of pending dynamic definitions that are not yet committed.\n+     If a matching name and kind are found, assume this is the type that\n+     we are looking for.  This is necessary to permit ctf_add_type() to\n+     operate recursively on entities such as a struct that contains a\n+     pointer member that refers to the same struct type.  */\n+\n+  if (dst_type == CTF_ERR && name[0] != '\\0')\n+    {\n+      for (dtd = ctf_list_prev (&dst_fp->ctf_dtdefs); dtd != NULL\n+\t     && LCTF_TYPE_TO_INDEX (src_fp, dtd->dtd_type) > dst_fp->ctf_dtoldid;\n+\t   dtd = ctf_list_prev (dtd))\n+\t{\n+\t  if (LCTF_INFO_KIND (src_fp, dtd->dtd_data.ctt_info) == kind\n+\t      && dtd->dtd_name != NULL && strcmp (dtd->dtd_name, name) == 0)\n+\t    {\n+\t      int sroot;\t/* Is the src root-visible?  */\n+\t      int droot;\t/* Is the dst root-visible?  */\n+\t      int match;\t/* Do the encodings match?  */\n+\n+\t      if (kind != CTF_K_INTEGER && kind != CTF_K_FLOAT && kind != CTF_K_SLICE)\n+\t\treturn dtd->dtd_type;\n+\n+\t      sroot = (flag & CTF_ADD_ROOT);\n+\t      droot = (LCTF_INFO_ISROOT (dst_fp,\n+\t\t\t\t\t dtd->dtd_data.\n+\t\t\t\t\t ctt_info) & CTF_ADD_ROOT);\n+\n+\t      match = (memcmp (&src_en, &dtd->dtd_u.dtu_enc,\n+\t\t\t       sizeof (ctf_encoding_t)) == 0);\n+\n+\t      /* If the types share the same encoding then return the id of the\n+\t\t first unless one type is root-visible and the other is not; in\n+\t\t that case the new type must get a new id if a match is never\n+\t\t found.  Note: slices are not certain to match even if there is\n+\t\t no conflict: we must check the contained type too. */\n+\n+\t      if (match && sroot == droot)\n+\t\t{\n+\t\t  if (kind != CTF_K_SLICE)\n+\t\t    return dtd->dtd_type;\n+\t\t}\n+\t      else if (!match && sroot && droot)\n+\t\t{\n+\t\t  return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  src.ctb_file = src_fp;\n+  src.ctb_type = src_type;\n+  src.ctb_dtd = NULL;\n+\n+  dst.ctb_file = dst_fp;\n+  dst.ctb_type = dst_type;\n+  dst.ctb_dtd = NULL;\n+\n+  /* Now perform kind-specific processing.  If dst_type is CTF_ERR, then\n+     we add a new type with the same properties as src_type to dst_fp.\n+     If dst_type is not CTF_ERR, then we verify that dst_type has the\n+     same attributes as src_type.  We recurse for embedded references.  */\n+  switch (kind)\n+    {\n+    case CTF_K_INTEGER:\n+      /*  If we found a match we will have either returned it or declared a\n+\t  conflict.  */\n+      dst_type = ctf_add_integer (dst_fp, flag, name, &src_en);\n+      break;\n+\n+    case CTF_K_FLOAT:\n+      /* If we found a match we will have either returned it or declared a\n+       conflict.  */\n+      dst_type = ctf_add_float (dst_fp, flag, name, &src_en);\n+      break;\n+\n+    case CTF_K_SLICE:\n+      /* We have checked for conflicting encodings: now try to add the\n+\t contained type.  */\n+      src_type = ctf_type_reference (src_fp, src_type);\n+      dst_type = ctf_add_type (dst_fp, src_fp, src_type);\n+\n+      if (src_type == CTF_ERR)\n+\treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n+\n+      dst_type = ctf_add_slice (dst_fp, flag, src_type, &src_en);\n+      break;\n+\n+    case CTF_K_POINTER:\n+    case CTF_K_VOLATILE:\n+    case CTF_K_CONST:\n+    case CTF_K_RESTRICT:\n+      src_type = ctf_type_reference (src_fp, src_type);\n+      src_type = ctf_add_type (dst_fp, src_fp, src_type);\n+\n+      if (src_type == CTF_ERR)\n+\treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n+\n+      dst_type = ctf_add_reftype (dst_fp, flag, src_type, kind);\n+      break;\n+\n+    case CTF_K_ARRAY:\n+      if (ctf_array_info (src_fp, src_type, &src_ar) == CTF_ERR)\n+\treturn (ctf_set_errno (dst_fp, ctf_errno (src_fp)));\n+\n+      src_ar.ctr_contents =\n+\tctf_add_type (dst_fp, src_fp, src_ar.ctr_contents);\n+      src_ar.ctr_index = ctf_add_type (dst_fp, src_fp, src_ar.ctr_index);\n+      src_ar.ctr_nelems = src_ar.ctr_nelems;\n+\n+      if (src_ar.ctr_contents == CTF_ERR || src_ar.ctr_index == CTF_ERR)\n+\treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n+\n+      if (dst_type != CTF_ERR)\n+\t{\n+\t  if (ctf_array_info (dst_fp, dst_type, &dst_ar) != 0)\n+\t    return CTF_ERR;\t\t\t/* errno is set for us.  */\n+\n+\t  if (memcmp (&src_ar, &dst_ar, sizeof (ctf_arinfo_t)))\n+\t    {\n+\t      ctf_dprintf (\"Conflict for type %s against ID %lx: \"\n+\t\t\t   \"array info differs, old %lx/%lx/%x; \"\n+\t\t\t   \"new: %lx/%lx/%x\\n\", name, dst_type,\n+\t\t\t   src_ar.ctr_contents, src_ar.ctr_index,\n+\t\t\t   src_ar.ctr_nelems, dst_ar.ctr_contents,\n+\t\t\t   dst_ar.ctr_index, dst_ar.ctr_nelems);\n+\t      return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n+\t    }\n+\t}\n+      else\n+\tdst_type = ctf_add_array (dst_fp, flag, &src_ar);\n+      break;\n+\n+    case CTF_K_FUNCTION:\n+      ctc.ctc_return = ctf_add_type (dst_fp, src_fp, src_tp->ctt_type);\n+      ctc.ctc_argc = 0;\n+      ctc.ctc_flags = 0;\n+\n+      if (ctc.ctc_return == CTF_ERR)\n+\treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n+\n+      dst_type = ctf_add_function (dst_fp, flag, &ctc, NULL);\n+      break;\n+\n+    case CTF_K_STRUCT:\n+    case CTF_K_UNION:\n+      {\n+\tctf_dmdef_t *dmd;\n+\tint errs = 0;\n+\n+\t/* Technically to match a struct or union we need to check both\n+\t   ways (src members vs. dst, dst members vs. src) but we make\n+\t   this more optimal by only checking src vs. dst and comparing\n+\t   the total size of the structure (which we must do anyway)\n+\t   which covers the possibility of dst members not in src.\n+\t   This optimization can be defeated for unions, but is so\n+\t   pathological as to render it irrelevant for our purposes.  */\n+\n+\tif (dst_type != CTF_ERR && dst_kind != CTF_K_FORWARD)\n+\t  {\n+\t    if (ctf_type_size (src_fp, src_type) !=\n+\t\tctf_type_size (dst_fp, dst_type))\n+\t      {\n+\t\tctf_dprintf (\"Conflict for type %s against ID %lx: \"\n+\t\t\t     \"union size differs, old %li, new %li\\n\",\n+\t\t\t     name, dst_type, ctf_type_size (src_fp, src_type),\n+\t\t\t     ctf_type_size (dst_fp, dst_type));\n+\t\treturn (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n+\t      }\n+\n+\t    if (ctf_member_iter (src_fp, src_type, membcmp, &dst))\n+\t      {\n+\t\tctf_dprintf (\"Conflict for type %s against ID %lx: \"\n+\t\t\t     \"members differ, see above\\n\", name, dst_type);\n+\t\treturn (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n+\t      }\n+\n+\t    break;\n+\t  }\n+\n+\t/* Unlike the other cases, copying structs and unions is done\n+\t   manually so as to avoid repeated lookups in ctf_add_member\n+\t   and to ensure the exact same member offsets as in src_type.  */\n+\n+\tdst_type = ctf_add_generic (dst_fp, flag, name, &dtd);\n+\tif (dst_type == CTF_ERR)\n+\t  return CTF_ERR;\t\t\t/* errno is set for us.  */\n+\n+\tdst.ctb_type = dst_type;\n+\tdst.ctb_dtd = dtd;\n+\n+\tif (ctf_member_iter (src_fp, src_type, membadd, &dst) != 0)\n+\t  errs++;\t       /* Increment errs and fail at bottom of case.  */\n+\n+\tif ((size = ctf_type_size (src_fp, src_type)) > CTF_MAX_SIZE)\n+\t  {\n+\t    dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n+\t    dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n+\t    dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n+\t  }\n+\telse\n+\t  dtd->dtd_data.ctt_size = (uint32_t) size;\n+\n+\tdtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, flag, vlen);\n+\n+\t/* Make a final pass through the members changing each dmd_type (a\n+\t   src_fp type) to an equivalent type in dst_fp.  We pass through all\n+\t   members, leaving any that fail set to CTF_ERR.  */\n+\tfor (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t     dmd != NULL; dmd = ctf_list_next (dmd))\n+\t  {\n+\t    if ((dmd->dmd_type = ctf_add_type (dst_fp, src_fp,\n+\t\t\t\t\t       dmd->dmd_type)) == CTF_ERR)\n+\t      errs++;\n+\t  }\n+\n+\tif (errs)\n+\t  return CTF_ERR;\t\t\t/* errno is set for us.  */\n+\tbreak;\n+      }\n+\n+    case CTF_K_ENUM:\n+      if (dst_type != CTF_ERR && dst_kind != CTF_K_FORWARD)\n+\t{\n+\t  if (ctf_enum_iter (src_fp, src_type, enumcmp, &dst)\n+\t      || ctf_enum_iter (dst_fp, dst_type, enumcmp, &src))\n+\t    {\n+\t      ctf_dprintf (\"Conflict for enum %s against ID %lx: \"\n+\t\t\t   \"members differ, see above\\n\", name, dst_type);\n+\t      return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  dst_type = ctf_add_enum (dst_fp, flag, name);\n+\t  if ((dst.ctb_type = dst_type) == CTF_ERR\n+\t      || ctf_enum_iter (src_fp, src_type, enumadd, &dst))\n+\t    return CTF_ERR;\t\t\t/* errno is set for us */\n+\t}\n+      break;\n+\n+    case CTF_K_FORWARD:\n+      if (dst_type == CTF_ERR)\n+\t{\n+\t  dst_type = ctf_add_forward (dst_fp, flag,\n+\t\t\t\t      name, CTF_K_STRUCT); /* Assume STRUCT. */\n+\t}\n+      break;\n+\n+    case CTF_K_TYPEDEF:\n+      src_type = ctf_type_reference (src_fp, src_type);\n+      src_type = ctf_add_type (dst_fp, src_fp, src_type);\n+\n+      if (src_type == CTF_ERR)\n+\treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n+\n+      /* If dst_type is not CTF_ERR at this point, we should check if\n+\t ctf_type_reference(dst_fp, dst_type) != src_type and if so fail with\n+\t ECTF_CONFLICT.  However, this causes problems with bitness typedefs\n+\t that vary based on things like if 32-bit then pid_t is int otherwise\n+\t long.  We therefore omit this check and assume that if the identically\n+\t named typedef already exists in dst_fp, it is correct or\n+\t equivalent.  */\n+\n+      if (dst_type == CTF_ERR)\n+\t{\n+\t  dst_type = ctf_add_typedef (dst_fp, flag, name, src_type);\n+\t}\n+      break;\n+\n+    default:\n+      return (ctf_set_errno (dst_fp, ECTF_CORRUPT));\n+    }\n+\n+  return dst_type;\n+}\n+\n /* Write the compressed CTF data stream to the specified gzFile descriptor.\n    This is useful for saving the results of dynamic CTF containers.  */\n int"
    }
  ]
}