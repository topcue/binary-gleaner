{
  "sha": "9b1f59fc95da32963f3ba22f8587ea0c12899e05",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWIxZjU5ZmM5NWRhMzI5NjNmM2JhMjJmODU4N2VhMGMxMjg5OWUwNQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-08-10T01:47:02Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-08-12T19:20:26Z"
    },
    "message": "gdb: make gdbarch_printable_names return a vector\n\nI noticed that gdbarch_selftest::operator() leaked the value returned by\ngdbarch_printable_names.  Make gdbarch_printable_names return an\nstd::vector and update callers.  That makes it easier for everyone\ninvolved, less manual memory management.\n\nChange-Id: Ia8fc028bdb91f787410cca34f10bf3c5a6da1498",
    "tree": {
      "sha": "27ece8ea76f043dec5c489e0055047c068144df7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/27ece8ea76f043dec5c489e0055047c068144df7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9b1f59fc95da32963f3ba22f8587ea0c12899e05",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9b1f59fc95da32963f3ba22f8587ea0c12899e05",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9b1f59fc95da32963f3ba22f8587ea0c12899e05",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9b1f59fc95da32963f3ba22f8587ea0c12899e05/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "65f82b1972cca3476b3ef6abf1d9923d34f5d4f5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/65f82b1972cca3476b3ef6abf1d9923d34f5d4f5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/65f82b1972cca3476b3ef6abf1d9923d34f5d4f5"
    }
  ],
  "stats": {
    "total": 127,
    "additions": 54,
    "deletions": 73
  },
  "files": [
    {
      "sha": "862f26b6cf7833ffd4ac13230c878a717232b55c",
      "filename": "gdb/arch-utils.c",
      "status": "modified",
      "additions": 14,
      "deletions": 11,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/arch-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/arch-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.c?ref=9b1f59fc95da32963f3ba22f8587ea0c12899e05",
      "patch": "@@ -669,26 +669,32 @@ static const bfd_target *default_bfd_vec;\n \n static enum bfd_endian default_byte_order = BFD_ENDIAN_UNKNOWN;\n \n+/* Printable names of architectures.  Used as the enum list of the\n+   \"set arch\" command.  */\n+static std::vector<const char *> arches;\n+\n void\n initialize_current_architecture (void)\n {\n-  const char **arches = gdbarch_printable_names ();\n+  arches = gdbarch_printable_names ();\n   \n   /* Find a default architecture.  */\n   if (default_bfd_arch == NULL)\n     {\n       /* Choose the architecture by taking the first one\n \t alphabetically.  */\n       const char *chosen = arches[0];\n-      const char **arch;\n-      for (arch = arches; *arch != NULL; arch++)\n+\n+      for (const char *arch : arches)\n \t{\n-\t  if (strcmp (*arch, chosen) < 0)\n-\t    chosen = *arch;\n+\t  if (strcmp (arch, chosen) < 0)\n+\t    chosen = arch;\n \t}\n+\n       if (chosen == NULL)\n \tinternal_error (__FILE__, __LINE__,\n \t\t\t_(\"initialize_current_architecture: No arch\"));\n+\n       default_bfd_arch = bfd_scan_arch (chosen);\n       if (default_bfd_arch == NULL)\n \tinternal_error (__FILE__, __LINE__,\n@@ -743,14 +749,11 @@ initialize_current_architecture (void)\n      list of architectures.  */\n   {\n     /* Append ``auto''.  */\n-    int nr;\n-    for (nr = 0; arches[nr] != NULL; nr++);\n-    arches = XRESIZEVEC (const char *, arches, nr + 2);\n-    arches[nr + 0] = \"auto\";\n-    arches[nr + 1] = NULL;\n+    arches.push_back (\"auto\");\n+    arches.push_back (nullptr);\n     set_show_commands architecture_cmds\n       = add_setshow_enum_cmd (\"architecture\", class_support,\n-\t\t\t      arches, &set_architecture_string,\n+\t\t\t      arches.data (), &set_architecture_string,\n \t\t\t      _(\"Set architecture of target.\"),\n \t\t\t      _(\"Show architecture of target.\"), NULL,\n \t\t\t      set_architecture, show_architecture,"
    },
    {
      "sha": "f89dcc5775429bbb0d130fdd72eb84fb7f1a35e9",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 10,
      "deletions": 20,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=9b1f59fc95da32963f3ba22f8587ea0c12899e05",
      "patch": "@@ -5549,40 +5549,30 @@ struct gdbarch_registration\n \n static struct gdbarch_registration *gdbarch_registry = NULL;\n \n-static void\n-append_name (const char ***buf, int *nr, const char *name)\n-{\n-  *buf = XRESIZEVEC (const char *, *buf, *nr + 1);\n-  (*buf)[*nr] = name;\n-  *nr += 1;\n-}\n-\n-const char **\n-gdbarch_printable_names (void)\n+std::vector<const char *>\n+gdbarch_printable_names ()\n {\n   /* Accumulate a list of names based on the registed list of\n      architectures.  */\n-  int nr_arches = 0;\n-  const char **arches = NULL;\n-  struct gdbarch_registration *rego;\n+  std::vector<const char *> arches;\n \n-  for (rego = gdbarch_registry;\n-       rego != NULL;\n+  for (gdbarch_registration *rego = gdbarch_registry;\n+       rego != nullptr;\n        rego = rego->next)\n     {\n-      const struct bfd_arch_info *ap;\n-      ap = bfd_lookup_arch (rego->bfd_architecture, 0);\n-      if (ap == NULL)\n+      const struct bfd_arch_info *ap\n+\t= bfd_lookup_arch (rego->bfd_architecture, 0);\n+      if (ap == nullptr)\n \tinternal_error (__FILE__, __LINE__,\n \t\t\t_(\"gdbarch_architecture_names: multi-arch unknown\"));\n       do\n \t{\n-\t  append_name (&arches, &nr_arches, ap->printable_name);\n+\t  arches.push_back (ap->printable_name);\n \t  ap = ap->next;\n \t}\n       while (ap != NULL);\n     }\n-  append_name (&arches, &nr_arches, NULL);\n+\n   return arches;\n }\n "
    },
    {
      "sha": "979159ba2f59510d98385037a4ac24913708f2fe",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=9b1f59fc95da32963f3ba22f8587ea0c12899e05",
      "patch": "@@ -1824,12 +1824,11 @@ extern void gdbarch_register (enum bfd_architecture architecture,\n \t\t\t      gdbarch_dump_tdep_ftype *);\n \n \n-/* Return a freshly allocated, NULL terminated, array of the valid\n-   architecture names.  Since architectures are registered during the\n-   _initialize phase this function only returns useful information\n-   once initialization has been completed.  */\n+/* Return a vector of the valid architecture names.  Since architectures are\n+   registered during the _initialize phase this function only returns useful\n+   information once initialization has been completed.  */\n \n-extern const char **gdbarch_printable_names (void);\n+extern std::vector<const char *> gdbarch_printable_names ();\n \n \n /* Helper function.  Search the list of ARCHES for a GDBARCH that"
    },
    {
      "sha": "39a99d0d5f34862b16bc628ab19303b78613f3dd",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 14,
      "deletions": 25,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=9b1f59fc95da32963f3ba22f8587ea0c12899e05",
      "patch": "@@ -1576,12 +1576,11 @@ extern void gdbarch_register (enum bfd_architecture architecture,\n \t\t\t      gdbarch_dump_tdep_ftype *);\n \n \n-/* Return a freshly allocated, NULL terminated, array of the valid\n-   architecture names.  Since architectures are registered during the\n-   _initialize phase this function only returns useful information\n-   once initialization has been completed.  */\n+/* Return a vector of the valid architecture names.  Since architectures are\n+   registered during the _initialize phase this function only returns useful\n+   information once initialization has been completed.  */\n \n-extern const char **gdbarch_printable_names (void);\n+extern std::vector<const char *> gdbarch_printable_names ();\n \n \n /* Helper function.  Search the list of ARCHES for a GDBARCH that\n@@ -2330,40 +2329,30 @@ struct gdbarch_registration\n \n static struct gdbarch_registration *gdbarch_registry = NULL;\n \n-static void\n-append_name (const char ***buf, int *nr, const char *name)\n-{\n-  *buf = XRESIZEVEC (const char *, *buf, *nr + 1);\n-  (*buf)[*nr] = name;\n-  *nr += 1;\n-}\n-\n-const char **\n-gdbarch_printable_names (void)\n+std::vector<const char *>\n+gdbarch_printable_names ()\n {\n   /* Accumulate a list of names based on the registed list of\n      architectures.  */\n-  int nr_arches = 0;\n-  const char **arches = NULL;\n-  struct gdbarch_registration *rego;\n+  std::vector<const char *> arches;\n \n-  for (rego = gdbarch_registry;\n-       rego != NULL;\n+  for (gdbarch_registration *rego = gdbarch_registry;\n+       rego != nullptr;\n        rego = rego->next)\n     {\n-      const struct bfd_arch_info *ap;\n-      ap = bfd_lookup_arch (rego->bfd_architecture, 0);\n-      if (ap == NULL)\n+      const struct bfd_arch_info *ap\n+\t= bfd_lookup_arch (rego->bfd_architecture, 0);\n+      if (ap == nullptr)\n \tinternal_error (__FILE__, __LINE__,\n \t\t\t_(\"gdbarch_architecture_names: multi-arch unknown\"));\n       do\n \t{\n-\t  append_name (&arches, &nr_arches, ap->printable_name);\n+\t  arches.push_back (ap->printable_name);\n \t  ap = ap->next;\n \t}\n       while (ap != NULL);\n     }\n-  append_name (&arches, &nr_arches, NULL);\n+\n   return arches;\n }\n "
    },
    {
      "sha": "052daed9196ee03612c50b6c46bf9bc52fa91a2c",
      "filename": "gdb/selftest-arch.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/selftest-arch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b1f59fc95da32963f3ba22f8587ea0c12899e05/gdb/selftest-arch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/selftest-arch.c?ref=9b1f59fc95da32963f3ba22f8587ea0c12899e05",
      "patch": "@@ -36,23 +36,23 @@ struct gdbarch_selftest : public selftest\n \n   void operator() () const override\n   {\n-    const char **arches = gdbarch_printable_names ();\n+    std::vector<const char *> arches = gdbarch_printable_names ();\n     bool pass = true;\n \n-    for (int i = 0; arches[i] != NULL; i++)\n+    for (const char *arch : arches)\n       {\n-\tif (strcmp (\"fr300\", arches[i]) == 0)\n+\tif (strcmp (\"fr300\", arch) == 0)\n \t  {\n \t    /* PR 20946 */\n \t    continue;\n \t  }\n-\telse if (strcmp (\"powerpc:EC603e\", arches[i]) == 0\n-\t\t || strcmp (\"powerpc:e500mc\", arches[i]) == 0\n-\t\t || strcmp (\"powerpc:e500mc64\", arches[i]) == 0\n-\t\t || strcmp (\"powerpc:titan\", arches[i]) == 0\n-\t\t || strcmp (\"powerpc:vle\", arches[i]) == 0\n-\t\t || strcmp (\"powerpc:e5500\", arches[i]) == 0\n-\t\t || strcmp (\"powerpc:e6500\", arches[i]) == 0)\n+\telse if (strcmp (\"powerpc:EC603e\", arch) == 0\n+\t\t || strcmp (\"powerpc:e500mc\", arch) == 0\n+\t\t || strcmp (\"powerpc:e500mc64\", arch) == 0\n+\t\t || strcmp (\"powerpc:titan\", arch) == 0\n+\t\t || strcmp (\"powerpc:vle\", arch) == 0\n+\t\t || strcmp (\"powerpc:e5500\", arch) == 0\n+\t\t || strcmp (\"powerpc:e6500\", arch) == 0)\n \t  {\n \t    /* PR 19797 */\n \t    continue;\n@@ -64,7 +64,7 @@ struct gdbarch_selftest : public selftest\n \t  {\n \t    struct gdbarch_info info;\n \n-\t    info.bfd_arch_info = bfd_scan_arch (arches[i]);\n+\t    info.bfd_arch_info = bfd_scan_arch (arch);\n \n \t    struct gdbarch *gdbarch = gdbarch_find_by_info (info);\n \t    SELF_CHECK (gdbarch != NULL);\n@@ -75,7 +75,7 @@ struct gdbarch_selftest : public selftest\n \t  {\n \t    pass = false;\n \t    exception_fprintf (gdb_stderr, ex,\n-\t\t\t       _(\"Self test failed: arch %s: \"), arches[i]);\n+\t\t\t       _(\"Self test failed: arch %s: \"), arch);\n \t  }\n \n \treset ();"
    }
  ]
}