{
  "sha": "5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWRiYzhiMzcyZjNhMTVmYTRkY2U2NWQ0NjBhM2NjZTdlZDA4MWY2Yw==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-03T14:00:55Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-03T14:01:13Z"
    },
    "message": "ELF: Consolidate readonly_dynrelocs\n\nAll readonly_dynrelocs implementations are the same.  Consolidate them\nto a single _bfd_elf_readonly_dynrelocs.\n\n\tPR ld/26067\n\t* elf-bfd.h (_bfd_elf_readonly_dynrelocs): New.\n\t* elf32-arm.c (readonly_dynrelocs): Removed.\n\t(maybe_set_textrel): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t* elf32-csky.c (readonly_dynrelocs): Removed.\n\t(maybe_set_textrel): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t*  elf32-hppa.c(readonly_dynrelocs): Removed.\n\t(alias_readonly_dynrelocs): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elf32-lm32.c (readonly_dynrelocs): Removed.\n\t(lm32_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elf32-m32r.c (readonly_dynrelocs): Removed.\n\t(m32r_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elf32-metag.c (readonly_dynrelocs): Removed.\n\t(elf_metag_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elf32-microblaze.c (readonly_dynrelocs): Removed.\n\t(microblaze_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t* elf32-nds32.c (readonly_dynrelocs): Removed.\n\t(nds32_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elf32-or1k.c (readonly_dynrelocs): Removed.\n\t(or1k_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t* elf32-ppc.c (readonly_dynrelocs): Removed.\n\t(alias_readonly_dynrelocs): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t(ppc_elf_adjust_dynamic_symbol): Likewise.\n\t(maybe_set_textrel): Likewise.\n\t* elf32-s390.c (readonly_dynrelocs): Removed.\n\t(elf_s390_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elf32-sh.c (readonly_dynrelocs): Removed.\n\t(sh_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elf32-tic6x.c (readonly_dynrelocs): Removed.\n\t(maybe_set_textrel): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t* elf32-tilepro.c (readonly_dynrelocs): Removed.\n\t(tilepro_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elf64-ppc.c (readonly_dynrelocs): Removed.\n\t(alias_readonly_dynrelocs): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t(ppc64_elf_adjust_dynamic_symbol): Likewise.\n\t(maybe_set_textrel): Likewise.\n\t* elf64-s390.c (readonly_dynrelocs): Removed.\n\t(elf_s390_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elflink.c (_bfd_elf_readonly_dynrelocs): New.\n\t* elfnn-aarch64.c (readonly_dynrelocs): Removed.\n\t(maybe_set_textrel): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t* elfnn-riscv.c (readonly_dynrelocs): Removed.\n\t(riscv_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elfxx-sparc.c (readonly_dynrelocs): Removed.\n\t(_bfd_sparc_elf_adjust_dynamic_symbol): Replace\n\treadonly_dynrelocs with _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elfxx-tilegx.c (readonly_dynrelocs): Removed.\n\t(tilegx_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n\twith _bfd_elf_readonly_dynrelocs.\n\t(maybe_set_textrel): Likewise.\n\t* elfxx-x86.c (readonly_dynrelocs): Removed.\n\t(maybe_set_textrel): Replace readonly_dynrelocs with\n\t_bfd_elf_readonly_dynrelocs.\n\t(_bfd_x86_elf_adjust_dynamic_symbol): Likewise.",
    "tree": {
      "sha": "75f6817369506f58513bb9db53f61fece6cd2461",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/75f6817369506f58513bb9db53f61fece6cd2461"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1949ad044a6979e176b0d0ebd5cfebbf162dd4f5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1949ad044a6979e176b0d0ebd5cfebbf162dd4f5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1949ad044a6979e176b0d0ebd5cfebbf162dd4f5"
    }
  ],
  "stats": {
    "total": 543,
    "additions": 145,
    "deletions": 398
  },
  "files": [
    {
      "sha": "64f01ef5ef6a5adba03f7f168c5aae0efd236956",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 86,
      "deletions": 0,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1,3 +1,89 @@\n+2020-06-03  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR ld/26067\n+\t* elf-bfd.h (_bfd_elf_readonly_dynrelocs): New.\n+\t* elf32-arm.c (readonly_dynrelocs): Removed.\n+\t(maybe_set_textrel): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t* elf32-csky.c (readonly_dynrelocs): Removed.\n+\t(maybe_set_textrel): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t*  elf32-hppa.c(readonly_dynrelocs): Removed.\n+\t(alias_readonly_dynrelocs): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf32-lm32.c (readonly_dynrelocs): Removed.\n+\t(lm32_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf32-m32r.c (readonly_dynrelocs): Removed.\n+\t(m32r_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf32-metag.c (readonly_dynrelocs): Removed.\n+\t(elf_metag_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf32-microblaze.c (readonly_dynrelocs): Removed.\n+\t(microblaze_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t* elf32-nds32.c (readonly_dynrelocs): Removed.\n+\t(nds32_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf32-or1k.c (readonly_dynrelocs): Removed.\n+\t(or1k_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t* elf32-ppc.c (readonly_dynrelocs): Removed.\n+\t(alias_readonly_dynrelocs): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t(ppc_elf_adjust_dynamic_symbol): Likewise.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf32-s390.c (readonly_dynrelocs): Removed.\n+\t(elf_s390_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf32-sh.c (readonly_dynrelocs): Removed.\n+\t(sh_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf32-tic6x.c (readonly_dynrelocs): Removed.\n+\t(maybe_set_textrel): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t* elf32-tilepro.c (readonly_dynrelocs): Removed.\n+\t(tilepro_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf64-ppc.c (readonly_dynrelocs): Removed.\n+\t(alias_readonly_dynrelocs): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t(ppc64_elf_adjust_dynamic_symbol): Likewise.\n+\t(maybe_set_textrel): Likewise.\n+\t* elf64-s390.c (readonly_dynrelocs): Removed.\n+\t(elf_s390_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elflink.c (_bfd_elf_readonly_dynrelocs): New.\n+\t* elfnn-aarch64.c (readonly_dynrelocs): Removed.\n+\t(maybe_set_textrel): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t* elfnn-riscv.c (readonly_dynrelocs): Removed.\n+\t(riscv_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elfxx-sparc.c (readonly_dynrelocs): Removed.\n+\t(_bfd_sparc_elf_adjust_dynamic_symbol): Replace\n+\treadonly_dynrelocs with _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elfxx-tilegx.c (readonly_dynrelocs): Removed.\n+\t(tilegx_elf_adjust_dynamic_symbol): Replace readonly_dynrelocs\n+\twith _bfd_elf_readonly_dynrelocs.\n+\t(maybe_set_textrel): Likewise.\n+\t* elfxx-x86.c (readonly_dynrelocs): Removed.\n+\t(maybe_set_textrel): Replace readonly_dynrelocs with\n+\t_bfd_elf_readonly_dynrelocs.\n+\t(_bfd_x86_elf_adjust_dynamic_symbol): Likewise.\n+\n 2020-06-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* elfxx-x86.h (GENERATE_DYNAMIC_RELOCATION_P): Silence"
    },
    {
      "sha": "6b8b5660fb77c8d19fd9c128b2b0ea45cd5aeb61",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -2874,6 +2874,8 @@ extern bfd_boolean _bfd_elf_write_secondary_reloc_section\n extern unsigned int _bfd_elf_symbol_section_index\n   (bfd *, elf_symbol_type *);\n \n+extern asection *_bfd_elf_readonly_dynrelocs\n+  (struct elf_link_hash_entry *);\n \n /* Large common section.  */\n extern asection _bfd_elf_large_com_section;"
    },
    {
      "sha": "69d3ba16eebb1d7f413452267e128c10ab399cea",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 1,
      "deletions": 18,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -16089,23 +16089,6 @@ elf32_arm_find_inliner_info (bfd *\t    abfd,\n   return found;\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -16730,7 +16713,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "52708702a6507cf66f6cd485d49295a0adf6849f",
      "filename": "bfd/elf32-csky.c",
      "status": "modified",
      "additions": 1,
      "deletions": 16,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-csky.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1893,21 +1893,6 @@ csky_allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n   return TRUE;\n }\n \n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Set DF_TEXTREL if we find any dynamic relocs that apply to\n    read-only sections.  */\n \n@@ -1919,7 +1904,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "15100431c8eb26459bf5da2aae7abf4bfa6637b7",
      "filename": "bfd/elf32-hppa.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-hppa.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1654,23 +1654,6 @@ elf32_hppa_hide_symbol (struct bfd_link_info *info,\n     }\n }\n \n-/* Find any dynamic relocs that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *eh)\n-{\n-  struct elf_dyn_relocs *hdh_p;\n-\n-  for (hdh_p = eh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)\n-    {\n-      asection *sec = hdh_p->sec->output_section;\n-\n-      if (sec != NULL && (sec->flags & SEC_READONLY) != 0)\n-\treturn hdh_p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Return true if we have dynamic relocs against H or any of its weak\n    aliases, that apply to read-only sections.  Cannot be used after\n    size_dynamic_sections.  */\n@@ -1681,7 +1664,7 @@ alias_readonly_dynrelocs (struct elf_link_hash_entry *eh)\n   struct elf32_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);\n   do\n     {\n-      if (readonly_dynrelocs (&hh->eh))\n+      if (_bfd_elf_readonly_dynrelocs (&hh->eh))\n \treturn TRUE;\n       hh = hppa_elf_hash_entry (hh->eh.u.alias);\n     } while (hh != NULL && &hh->eh != eh);\n@@ -2106,7 +2089,7 @@ maybe_set_textrel (struct elf_link_hash_entry *eh, void *inf)\n   if (eh->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (eh);\n+  sec = _bfd_elf_readonly_dynrelocs (eh);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) inf;"
    },
    {
      "sha": "9e958617f80fd89f0195f948b953094acc0b6700",
      "filename": "bfd/elf32-lm32.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-lm32.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1599,23 +1599,6 @@ lm32_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -1702,7 +1685,7 @@ lm32_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (0 && !readonly_dynrelocs (h))\n+  if (0 && !_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -1942,7 +1925,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "f719a532d466cf810e3c5203c0382950195bc1f7",
      "filename": "bfd/elf32-m32r.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32r.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1700,23 +1700,6 @@ m32r_elf_copy_indirect_symbol (struct bfd_link_info *info,\n }\n \n \f\n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -1807,7 +1790,7 @@ m32r_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (0 && !readonly_dynrelocs (h))\n+  if (0 && !_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -2047,7 +2030,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "b2cb918d4c856ef2350e14c4df31bf4878f81e14",
      "filename": "bfd/elf32-metag.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-metag.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -2435,23 +2435,6 @@ elf_metag_copy_indirect_symbol (struct bfd_link_info *info,\n   _bfd_elf_link_hash_copy_indirect (info, eh_dir, eh_ind);\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -2527,7 +2510,7 @@ elf_metag_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (!readonly_dynrelocs (eh))\n+  if (!_bfd_elf_readonly_dynrelocs (eh))\n     {\n       eh->non_got_ref = 0;\n       return TRUE;\n@@ -2778,7 +2761,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "92c5e7c30314552a26f6e054738f26082c911873",
      "filename": "bfd/elf32-microblaze.c",
      "status": "modified",
      "additions": 1,
      "deletions": 18,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-microblaze.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -2614,23 +2614,6 @@ microblaze_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   _bfd_elf_link_hash_copy_indirect (info, dir, ind);\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n static bfd_boolean\n microblaze_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t\t\t\t      struct elf_link_hash_entry *h)\n@@ -2709,7 +2692,7 @@ microblaze_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (!readonly_dynrelocs (h))\n+  if (!_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;"
    },
    {
      "sha": "ad5225fcd7cd2395163c1cba0858c698c10acae0",
      "filename": "bfd/elf32-nds32.c",
      "status": "modified",
      "additions": 2,
      "deletions": 20,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -3920,24 +3920,6 @@ nds32_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   _bfd_elf_link_hash_copy_indirect (info, dir, ind);\n }\n \f\n-\n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -4023,7 +4005,7 @@ nds32_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (!readonly_dynrelocs (h))\n+  if (!_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -4315,7 +4297,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "01556266c109bf2f32f1d5630c49b962edb57c5b",
      "filename": "bfd/elf32-or1k.c",
      "status": "modified",
      "additions": 2,
      "deletions": 21,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-or1k.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -2547,25 +2547,6 @@ or1k_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *sec_relocs;\n-\n-  for (sec_relocs = h->dyn_relocs;\n-       sec_relocs != NULL;\n-       sec_relocs = sec_relocs->next)\n-    {\n-      asection *s = sec_relocs->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn sec_relocs->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -2652,7 +2633,7 @@ or1k_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (!readonly_dynrelocs (h))\n+  if (!_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -2949,7 +2930,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "588b79781d80acc85be4f9105781ecdf3625bbb5",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 3,
      "deletions": 20,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -4694,23 +4694,6 @@ ppc_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED,\n   return TRUE;\n }\n \f\n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Return true if we have dynamic relocs against H or any of its weak\n    aliases, that apply to read-only sections.  Cannot be used after\n    size_dynamic_sections.  */\n@@ -4721,7 +4704,7 @@ alias_readonly_dynrelocs (struct elf_link_hash_entry *h)\n   struct ppc_elf_link_hash_entry *eh = ppc_elf_hash_entry (h);\n   do\n     {\n-      if (readonly_dynrelocs (&eh->elf))\n+      if (_bfd_elf_readonly_dynrelocs (&eh->elf))\n \treturn TRUE;\n       eh = ppc_elf_hash_entry (eh->elf.u.alias);\n     } while (eh != NULL && &eh->elf != h);\n@@ -4826,7 +4809,7 @@ ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t\t   && !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h)))\n \t      && !htab->is_vxworks\n \t      && !ppc_elf_hash_entry (h)->has_sda_refs\n-\t      && !readonly_dynrelocs (h))\n+\t      && !_bfd_elf_readonly_dynrelocs (h))\n \t    {\n \t      h->pointer_equality_needed = 0;\n \t      /* If we haven't seen a branch reloc and the symbol\n@@ -5451,7 +5434,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "c0db4f9bc8efb7966dee0fa256af829fb0c79663",
      "filename": "bfd/elf32-s390.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-s390.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1417,23 +1417,6 @@ elf_s390_adjust_gotplt (struct elf_s390_link_hash_entry *h)\n   h->gotplt_refcount = -1;\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -1558,7 +1541,7 @@ elf_s390_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (ELIMINATE_COPY_RELOCS && !readonly_dynrelocs (h))\n+  if (ELIMINATE_COPY_RELOCS && !_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -1836,7 +1819,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "29cdb3b5696d8d2a810363cb90a154d55b728709",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -2476,23 +2476,6 @@ sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   return TRUE;\n }\n \f\n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -2581,7 +2564,7 @@ sh_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (0 && !readonly_dynrelocs (h))\n+  if (0 && !_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -2954,7 +2937,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "f673fe191a68b162fa511f28935a90993101431b",
      "filename": "bfd/elf32-tic6x.c",
      "status": "modified",
      "additions": 1,
      "deletions": 18,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tic6x.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1963,23 +1963,6 @@ elf32_tic6x_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,\n   return TRUE;\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -3198,7 +3181,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "cb6cda811776f3b201d4985aa3296cade73f8bfe",
      "filename": "bfd/elf32-tilepro.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf32-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tilepro.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1871,23 +1871,6 @@ tilepro_elf_gc_mark_hook (asection *sec,\n   return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -1973,7 +1956,7 @@ tilepro_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (!readonly_dynrelocs (h))\n+  if (!_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -2227,7 +2210,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "49fda96be7a3f8222478995169bd1c8addc68419",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 4,
      "deletions": 21,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -6356,23 +6356,6 @@ ppc64_elf_func_desc_adjust (bfd *obfd ATTRIBUTE_UNUSED,\n   return TRUE;\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Return true if we have dynamic relocs against H or any of its weak\n    aliases, that apply to read-only sections.  Cannot be used after\n    size_dynamic_sections.  */\n@@ -6383,7 +6366,7 @@ alias_readonly_dynrelocs (struct elf_link_hash_entry *h)\n   struct ppc_link_hash_entry *eh = ppc_elf_hash_entry (h);\n   do\n     {\n-      if (readonly_dynrelocs (&eh->elf))\n+      if (_bfd_elf_readonly_dynrelocs (&eh->elf))\n \treturn TRUE;\n       eh = ppc_elf_hash_entry (eh->elf.u.alias);\n     }\n@@ -6492,7 +6475,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t     extra work in ld.so when resolving these symbols.  */\n \t  if (global_entry_stub (h))\n \t    {\n-\t      if (!readonly_dynrelocs (h))\n+\t      if (!_bfd_elf_readonly_dynrelocs (h))\n \t\t{\n \t\t  h->pointer_equality_needed = 0;\n \t\t  /* If we haven't seen a branch reloc and the symbol\n@@ -6510,7 +6493,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t  return TRUE;\n \t}\n       else if (!h->needs_plt\n-\t       && !readonly_dynrelocs (h))\n+\t       && !_bfd_elf_readonly_dynrelocs (h))\n \t{\n \t  /* If we haven't seen a branch reloc and the symbol isn't an\n \t     ifunc then we don't need a plt entry.  */\n@@ -9890,7 +9873,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) inf;"
    },
    {
      "sha": "07ec4709bbfb8becef63bf102bd705ea951b0719",
      "filename": "bfd/elf64-s390.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf64-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elf64-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-s390.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1352,23 +1352,6 @@ elf_s390_adjust_gotplt (struct elf_s390_link_hash_entry *h)\n   h->gotplt_refcount = -1;\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -1492,7 +1475,7 @@ elf_s390_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (ELIMINATE_COPY_RELOCS && !readonly_dynrelocs (h))\n+  if (ELIMINATE_COPY_RELOCS && !_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -1772,7 +1755,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "0d659c20257a663e38511d8126157509cbcd4413",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -14793,3 +14793,20 @@ bfd_elf_define_start_stop (struct bfd_link_info *info,\n     }\n   return NULL;\n }\n+\n+/* Find dynamic relocs for H that apply to read-only sections.  */\n+\n+asection *\n+_bfd_elf_readonly_dynrelocs (struct elf_link_hash_entry *h)\n+{\n+  struct elf_dyn_relocs *p;\n+\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n+    {\n+      asection *s = p->sec->output_section;\n+\n+      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n+\treturn p->sec;\n+    }\n+  return NULL;\n+}"
    },
    {
      "sha": "f521786c8c3183fde85260fba1ccafba28e68a27",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 1,
      "deletions": 18,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -7381,23 +7381,6 @@ elfNN_aarch64_print_private_bfd_data (bfd *abfd, void *ptr)\n   return TRUE;\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Return true if we need copy relocation against EH.  */\n \n static bfd_boolean\n@@ -8915,7 +8898,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "1b530d83dffd76e42aee66ac6d4ef5bd584dcbce",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -782,23 +782,6 @@ riscv_elf_gc_mark_hook (asection *sec,\n   return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -887,7 +870,7 @@ riscv_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (!readonly_dynrelocs (h))\n+  if (!_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -1147,7 +1130,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "633ac59bcc1d13ceb5c3e8c5822432a2be6a6b82",
      "filename": "bfd/elfxx-sparc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfxx-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfxx-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -1919,23 +1919,6 @@ _bfd_sparc_elf_fixup_symbol (struct bfd_link_info *info,\n   return TRUE;\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -2032,7 +2015,7 @@ _bfd_sparc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (!readonly_dynrelocs (h))\n+  if (!_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -2418,7 +2401,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "75b4621276705e049f97c3c5b7484bd8e6282bbc",
      "filename": "bfd/elfxx-tilegx.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfxx-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfxx-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-tilegx.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -2114,23 +2114,6 @@ tilegx_elf_gc_mark_hook (asection *sec,\n   return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Adjust a symbol defined by a dynamic object and referenced by a\n    regular object.  The current definition is in some section of the\n    dynamic object, but we're not including those sections.  We have to\n@@ -2219,7 +2202,7 @@ tilegx_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* If we don't find any dynamic relocs in read-only sections, then\n      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */\n-  if (!readonly_dynrelocs (h))\n+  if (!_bfd_elf_readonly_dynrelocs (h))\n     {\n       h->non_got_ref = 0;\n       return TRUE;\n@@ -2473,7 +2456,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) info_p;"
    },
    {
      "sha": "c89559914e77ae18196704097a45b60cbae6abca",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=5dbc8b372f3a15fa4dce65d460a3cce7ed081f6c",
      "patch": "@@ -532,23 +532,6 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Find dynamic relocs for H that apply to read-only sections.  */\n-\n-static asection *\n-readonly_dynrelocs (struct elf_link_hash_entry *h)\n-{\n-  struct elf_dyn_relocs *p;\n-\n-  for (p = h->dyn_relocs; p != NULL; p = p->next)\n-    {\n-      asection *s = p->sec->output_section;\n-\n-      if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n-    }\n-  return NULL;\n-}\n-\n /* Set DF_TEXTREL if we find any dynamic relocs that apply to\n    read-only sections.  */\n \n@@ -564,7 +547,7 @@ maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)\n   if (h->forced_local && h->type == STT_GNU_IFUNC)\n     return TRUE;\n \n-  sec = readonly_dynrelocs (h);\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n   if (sec != NULL)\n     {\n       struct bfd_link_info *info = (struct bfd_link_info *) inf;\n@@ -2078,7 +2061,7 @@ _bfd_x86_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       /* If we don't find any dynamic relocs in read-only sections,\n \t then we'll be keeping the dynamic relocs and avoiding the copy\n \t reloc.  */\n-      if (!readonly_dynrelocs (h))\n+      if (!_bfd_elf_readonly_dynrelocs (h))\n \t{\n \t  h->non_got_ref = 0;\n \t  return TRUE;"
    }
  ]
}