{
  "sha": "4c55e9702527b73ff301e5c06f2055a606348de1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGM1NWU5NzAyNTI3YjczZmYzMDFlNWMwNmYyMDU1YTYwNjM0OGRlMQ==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-07-30T17:23:38Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-07-30T17:23:38Z"
    },
    "message": "gdb/breakpoint: set the condition exp after parsing the condition successfully\n\nIn 'set_breakpoint_condition', GDB resets the condition expressions\nbefore parsing the condition input by the user.  This leads to the\nproblem of losing the condition expressions if the new condition\ndoes not parse successfully and is thus rejected.\n\nFor instance:\n\n  $ gdb ./test\n  Reading symbols from ./test...\n  (gdb) start\n  Temporary breakpoint 1 at 0x114e: file test.c, line 4.\n  Starting program: test\n\n  Temporary breakpoint 1, main () at test.c:4\n  4         int a = 10;\n  (gdb) break 5\n  Breakpoint 2 at 0x555555555155: file test.c, line 5.\n\nNow define a condition that would evaluate to false.  Next, attempt\nto overwrite that with an invalid condition:\n\n  (gdb) cond 2 a == 999\n  (gdb) cond 2 gibberish\n  No symbol \"gibberish\" in current context.\n  (gdb) info breakpoints\n  Num     Type           Disp Enb Address            What\n  2       breakpoint     keep y   0x0000555555555155 in main at test.c:5\n          stop only if a == 999\n\nIt appears as if the bad condition is successfully rejected.  But if we\nresume the program, we see that we hit the breakpoint although the condition\nwould evaluate to false.\n\n  (gdb) continue\n  Continuing.\n\n  Breakpoint 2, main () at test.c:5\n  5         a = a + 1; /* break-here */\n\nFix the problem by not resetting the condition expressions before\nparsing the condition input.\n\nSuppose the fix is applied.  A similar problem could occur if the\ncondition is valid, but has \"junk\" at the end.  In this case, parsing\nsucceeds, but an error is raised immediately after.  It is too late,\nthough; the condition expression is already updated.\n\nFor instance:\n\n  $ gdb ./test\n  Reading symbols from ./test...\n  (gdb) start\n  Temporary breakpoint 1 at 0x114e: file test.c, line 4.\n  Starting program: test\n\n  Temporary breakpoint 1, main () at test.c:4\n  4         int a = 10;\n  (gdb) break 5\n  Breakpoint 2 at 0x555555555155: file test.c, line 5.\n  (gdb) cond 2 a == 999\n  (gdb) cond 2 a == 10 if\n  Junk at end of expression\n  (gdb) info breakpoints\n  Num     Type           Disp Enb Address            What\n  2       breakpoint     keep y   0x0000555555555155 in main at test.c:5\n          stop only if a == 999\n  (gdb) c\n  Continuing.\n\n  Breakpoint 2, main () at test.c:5\n  5         a = a + 1; /* break-here */\n  (gdb)\n\nWe should not have hit the breakpoint because the condition would\nevaluate to false.\n\nFix this problem by updating the condition expression of the breakpoint\nafter parsing the input successfully and checking that there is no\nremaining junk.\n\ngdb/ChangeLog:\n2020-07-30  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* breakpoint.c (set_breakpoint_condition): Update the condition\n\texpressions after checking that the input condition string parses\n\tsuccessfully and does not contain junk at the end.\n\ngdb/testsuite/ChangeLog:\n2020-07-30  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* gdb.base/condbreak-bad.exp: Extend the test with scenarios\n\tthat attempt to overwrite an existing condition with a condition\n\tthat fails parsing and also with a condition that parses fine\n\tbut contains junk at the end.",
    "tree": {
      "sha": "e15c5b625d647060d1a9e7c2187eb30fa0ab1674",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e15c5b625d647060d1a9e7c2187eb30fa0ab1674"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4c55e9702527b73ff301e5c06f2055a606348de1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4c55e9702527b73ff301e5c06f2055a606348de1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4c55e9702527b73ff301e5c06f2055a606348de1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4c55e9702527b73ff301e5c06f2055a606348de1/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1e6205909c46fc810daa27f696773c6d30a4de85",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1e6205909c46fc810daa27f696773c6d30a4de85",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1e6205909c46fc810daa27f696773c6d30a4de85"
    }
  ],
  "stats": {
    "total": 160,
    "additions": 139,
    "deletions": 21
  },
  "files": [
    {
      "sha": "cfc5b6db5f29b0cfbc017026e4df54c4ecec44d7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c55e9702527b73ff301e5c06f2055a606348de1/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c55e9702527b73ff301e5c06f2055a606348de1/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4c55e9702527b73ff301e5c06f2055a606348de1",
      "patch": "@@ -1,3 +1,9 @@\n+2020-07-30  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* breakpoint.c (set_breakpoint_condition): Update the condition\n+\texpressions after checking that the input condition string parses\n+\tsuccessfully and does not contain junk at the end.\n+\n 2020-07-30  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* breakpoint.c (set_breakpoint_condition): Update the"
    },
    {
      "sha": "7e020c5f666a6ddbb2c886dafa3d6ed018dc5b84",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 38,
      "deletions": 21,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c55e9702527b73ff301e5c06f2055a606348de1/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c55e9702527b73ff301e5c06f2055a606348de1/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=4c55e9702527b73ff301e5c06f2055a606348de1",
      "patch": "@@ -834,30 +834,30 @@ void\n set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \t\t\t  int from_tty)\n {\n-  if (is_watchpoint (b))\n-    {\n-      struct watchpoint *w = (struct watchpoint *) b;\n-\n-      w->cond_exp.reset ();\n-    }\n-  else\n+  if (*exp == 0)\n     {\n-      struct bp_location *loc;\n+      xfree (b->cond_string);\n+      b->cond_string = nullptr;\n \n-      for (loc = b->loc; loc; loc = loc->next)\n+      if (is_watchpoint (b))\n \t{\n-\t  loc->cond.reset ();\n+\t  struct watchpoint *w = (struct watchpoint *) b;\n \n-\t  /* No need to free the condition agent expression\n-\t     bytecode (if we have one).  We will handle this\n-\t     when we go through update_global_location_list.  */\n+\t  w->cond_exp.reset ();\n \t}\n-    }\n+      else\n+\t{\n+\t  struct bp_location *loc;\n \n-  if (*exp == 0)\n-    {\n-      xfree (b->cond_string);\n-      b->cond_string = nullptr;\n+\t  for (loc = b->loc; loc; loc = loc->next)\n+\t    {\n+\t      loc->cond.reset ();\n+\n+\t      /* No need to free the condition agent expression\n+\t\t bytecode (if we have one).  We will handle this\n+\t\t when we go through update_global_location_list.  */\n+\t    }\n+\t}\n \n       if (from_tty)\n \tprintf_filtered (_(\"Breakpoint %d now unconditional.\\n\"), b->number);\n@@ -872,23 +872,40 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \n \t  innermost_block_tracker tracker;\n \t  arg = exp;\n-\t  w->cond_exp = parse_exp_1 (&arg, 0, 0, 0, &tracker);\n+\t  expression_up new_exp = parse_exp_1 (&arg, 0, 0, 0, &tracker);\n \t  if (*arg)\n \t    error (_(\"Junk at end of expression\"));\n+\t  w->cond_exp = std::move (new_exp);\n \t  w->cond_exp_valid_block = tracker.block ();\n \t}\n       else\n \t{\n \t  struct bp_location *loc;\n \n+\t  /* Parse and set condition expressions.  We make two passes.\n+\t     In the first, we parse the condition string to see if it\n+\t     is valid in all locations.  If so, the condition would be\n+\t     accepted.  So we go ahead and set the locations'\n+\t     conditions.  In case a failing case is found, we throw\n+\t     the error and the condition string will be rejected.\n+\t     This two-pass approach is taken to avoid setting the\n+\t     state of locations in case of a reject.  */\n+\t  for (loc = b->loc; loc; loc = loc->next)\n+\t    {\n+\t      arg = exp;\n+\t      parse_exp_1 (&arg, loc->address,\n+\t\t\t   block_for_pc (loc->address), 0);\n+\t      if (*arg != 0)\n+\t\terror (_(\"Junk at end of expression\"));\n+\t    }\n+\n+\t  /* If we reach here, the condition is valid at all locations.  */\n \t  for (loc = b->loc; loc; loc = loc->next)\n \t    {\n \t      arg = exp;\n \t      loc->cond =\n \t\tparse_exp_1 (&arg, loc->address,\n \t\t\t     block_for_pc (loc->address), 0);\n-\t      if (*arg)\n-\t\terror (_(\"Junk at end of expression\"));\n \t    }\n \t}\n "
    },
    {
      "sha": "2a194d16fb6ccc40733b84905634ec2066af0a50",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c55e9702527b73ff301e5c06f2055a606348de1/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c55e9702527b73ff301e5c06f2055a606348de1/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=4c55e9702527b73ff301e5c06f2055a606348de1",
      "patch": "@@ -1,3 +1,10 @@\n+2020-07-30  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* gdb.base/condbreak-bad.exp: Extend the test with scenarios\n+\tthat attempt to overwrite an existing condition with a condition\n+\tthat fails parsing and also with a condition that parses fine\n+\tbut contains junk at the end.\n+\n 2020-07-30  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* gdb.base/condbreak-bad.c: New test."
    },
    {
      "sha": "84d32a0f15d5ada8a91284ad9febe4fde25dfdc0",
      "filename": "gdb/testsuite/gdb.base/condbreak-bad.exp",
      "status": "modified",
      "additions": 88,
      "deletions": 0,
      "changes": 88,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c55e9702527b73ff301e5c06f2055a606348de1/gdb/testsuite/gdb.base/condbreak-bad.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c55e9702527b73ff301e5c06f2055a606348de1/gdb/testsuite/gdb.base/condbreak-bad.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/condbreak-bad.exp?ref=4c55e9702527b73ff301e5c06f2055a606348de1",
      "patch": "@@ -38,3 +38,91 @@ gdb_test \"info break\" \\\n \t \"${decimal}${fill}breakpoint${fill}keep y${fill}:${bp_location}\"] \\\n     \"breakpoint is unconditional\"\n \n+# Now define a valid condition.  Attempt to override that with a 'bad'\n+# condition again.  The condition should be preserved.\n+with_test_prefix \"with run\" {\n+    gdb_test_no_output \"cond $bpnum a == 10\"\n+\n+    gdb_test \"cond $bpnum gibberish\" \\\n+\t\"No symbol \\\"gibberish\\\" in current context.\" \\\n+\t\"attempt a bad condition\"\n+\n+    gdb_test \"info break\" \\\n+\t[multi_line \\\n+\t     \"Num${fill}What\" \\\n+\t     \"${decimal}${fill}breakpoint${fill}keep y${fill}:${bp_location}\" \\\n+\t     \"${fill}stop only if a == 10${fill}\"] \\\n+\t\"breakpoint condition is preserved\"\n+\n+    # Run the code.  We should hit the breakpoint, because the\n+    # condition evaluates to true.\n+\n+    gdb_run_cmd\n+    gdb_test \"\" \".*reakpoint .*, main .*${srcfile}.*\" \"run to the bp\"\n+}\n+\n+# Restart.  Repeat the test above after the program has started.\n+# This is needed to check a scenario where the breakpoints are no\n+# longer re-inserted due to solib events.  Note that runto_main\n+# deletes the breakpoints.\n+with_test_prefix \"with continue 1\" {\n+    if {![runto_main]} {\n+\tfail \"could not run to main\"\n+\treturn -1\n+    }\n+\n+    gdb_breakpoint \"$bp_location\"\n+    set bpnum [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum\"]\n+\n+    gdb_test_no_output \"cond $bpnum a == 10\"\n+\n+    gdb_test \"cond $bpnum gibberish\" \\\n+\t\"No symbol \\\"gibberish\\\" in current context.\" \\\n+\t\"attempt a bad condition\"\n+\n+    # Resume.  We should hit the breakpoint, because the\n+    # condition evaluates to true.\n+    gdb_continue_to_breakpoint \"${srcfile}:${bp_location}\"\n+}\n+\n+# Repeat with a condition that evaluates to false.\n+with_test_prefix \"with continue 2\" {\n+    if {![runto_main]} {\n+\tfail \"could not run to main\"\n+\treturn -1\n+    }\n+\n+    gdb_breakpoint \"$bp_location\"\n+    set bpnum [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum\"]\n+\n+    gdb_test_no_output \"cond $bpnum a == 999\"\n+    \n+    gdb_test \"cond $bpnum gibberish\" \\\n+\t\"No symbol \\\"gibberish\\\" in current context.\" \\\n+\t\"attempt a bad condition\"\n+\n+    # Resume.  We should *not* hit the breakpoint, because the\n+    # condition evaluates to false.\n+    gdb_continue_to_end\n+}\n+\n+# Repeat with a condition that contains junk at the end.\n+with_test_prefix \"with junk\" {\n+    if {![runto_main]} {\n+\tfail \"could not run to main\"\n+\treturn -1\n+    }\n+\n+    gdb_breakpoint \"$bp_location\"\n+    set bpnum [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum\"]\n+\n+    gdb_test_no_output \"cond $bpnum a == 999\"\n+\n+    gdb_test \"cond $bpnum a == 10 if\" \\\n+\t\"Junk at end of expression\" \\\n+\t\"attempt a bad condition\"\n+\n+    # Resume.  We should *not* hit the breakpoint, because the\n+    # condition evaluates to false.\n+    gdb_continue_to_end\n+}"
    }
  ]
}