{
  "sha": "ef0bd2046f58fac69577892c2d3b44b20d027476",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWYwYmQyMDQ2ZjU4ZmFjNjk1Nzc4OTJjMmQzYjQ0YjIwZDAyNzQ3Ng==",
  "commit": {
    "author": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2019-03-12T20:39:02Z"
    },
    "committer": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2019-03-12T20:45:48Z"
    },
    "message": "Add a more general version of lookup_struct_elt_type.\n\nlookup_struct_elt is a new function which returns a tuple of\ninformation about a component of a structure or union.  The returned\ntuple contains a pointer to the struct field object for the component\nas well as a bit offset of that field within the structure.  If the\nfield names a field in an anonymous substructure, the offset is the\n\"global\" offset relative to the original structure type.  If noerr is\nset, then the returned tuple will set the field pointer to NULL to\nindicate a missing component rather than throwing an error.\n\nlookup_struct_elt_type is now reimplemented in terms of this new\nfunction.  It simply returns the type of the returned field.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.c (lookup_struct_elt): New function.\n\t(lookup_struct_elt_type): Reimplement via lookup_struct_elt.\n\t* gdbtypes.h (struct struct_elt): New type.\n\t(lookup_struct_elt): New prototype.",
    "tree": {
      "sha": "8332b9f3c74edc4dd4f903494cc95c2d9a1f2138",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8332b9f3c74edc4dd4f903494cc95c2d9a1f2138"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ef0bd2046f58fac69577892c2d3b44b20d027476",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ef0bd2046f58fac69577892c2d3b44b20d027476",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ef0bd2046f58fac69577892c2d3b44b20d027476",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ef0bd2046f58fac69577892c2d3b44b20d027476/comments",
  "author": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "36c53a0262f84ad11d738471789dadfa9c4eb320",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/36c53a0262f84ad11d738471789dadfa9c4eb320",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/36c53a0262f84ad11d738471789dadfa9c4eb320"
    }
  ],
  "stats": {
    "total": 100,
    "additions": 72,
    "deletions": 28
  },
  "files": [
    {
      "sha": "2adc64ee33eb6b9ebbc4b629af016904fb00d50a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef0bd2046f58fac69577892c2d3b44b20d027476/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef0bd2046f58fac69577892c2d3b44b20d027476/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=ef0bd2046f58fac69577892c2d3b44b20d027476",
      "patch": "@@ -1,3 +1,10 @@\n+2019-03-12  John Baldwin  <jhb@FreeBSD.org>\n+\n+\t* gdbtypes.c (lookup_struct_elt): New function.\n+\t(lookup_struct_elt_type): Reimplement via lookup_struct_elt.\n+\t* gdbtypes.h (struct struct_elt): New type.\n+\t(lookup_struct_elt): New prototype.\n+\n 2019-03-12  John Baldwin  <jhb@FreeBSD.org>\n \n \t* gdbtypes.c (lookup_struct_elt_type): Update comment and"
    },
    {
      "sha": "db470dafacc919bf260a9a7bc469ebcf35578154",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 27,
      "deletions": 28,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef0bd2046f58fac69577892c2d3b44b20d027476/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef0bd2046f58fac69577892c2d3b44b20d027476/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=ef0bd2046f58fac69577892c2d3b44b20d027476",
      "patch": "@@ -1644,19 +1644,10 @@ lookup_template_type (char *name, struct type *type,\n   return (SYMBOL_TYPE (sym));\n }\n \n-/* Given a type TYPE, lookup the type of the component named NAME.\n-\n-   TYPE can be either a struct or union, or a pointer or reference to\n-   a struct or union.  If it is a pointer or reference, its target\n-   type is automatically used.  Thus '.' and '->' are interchangable,\n-   as specified for the definitions of the expression element types\n-   STRUCTOP_STRUCT and STRUCTOP_PTR.\n-\n-   If NOERR is nonzero, return NULL if there is no component named\n-   NAME.  */\n+/* See gdbtypes.h.  */\n \n-struct type *\n-lookup_struct_elt_type (struct type *type, const char *name, int noerr)\n+struct_elt\n+lookup_struct_elt (struct type *type, const char *name, int noerr)\n {\n   int i;\n \n@@ -1683,39 +1674,47 @@ lookup_struct_elt_type (struct type *type, const char *name, int noerr)\n \n       if (t_field_name && (strcmp_iw (t_field_name, name) == 0))\n \t{\n-\t  return TYPE_FIELD_TYPE (type, i);\n+\t  return {&TYPE_FIELD (type, i), TYPE_FIELD_BITPOS (type, i)};\n \t}\n      else if (!t_field_name || *t_field_name == '\\0')\n \t{\n-\t  struct type *subtype \n-\t    = lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name, 1);\n-\n-\t  if (subtype != NULL)\n-\t    return subtype;\n+\t  struct_elt elt\n+\t    = lookup_struct_elt (TYPE_FIELD_TYPE (type, i), name, 1);\n+\t  if (elt.field != NULL)\n+\t    {\n+\t      elt.offset += TYPE_FIELD_BITPOS (type, i);\n+\t      return elt;\n+\t    }\n \t}\n     }\n \n   /* OK, it's not in this class.  Recursively check the baseclasses.  */\n   for (i = TYPE_N_BASECLASSES (type) - 1; i >= 0; i--)\n     {\n-      struct type *t;\n-\n-      t = lookup_struct_elt_type (TYPE_BASECLASS (type, i), name, 1);\n-      if (t != NULL)\n-\t{\n-\t  return t;\n-\t}\n+      struct_elt elt = lookup_struct_elt (TYPE_BASECLASS (type, i), name, 1);\n+      if (elt.field != NULL)\n+\treturn elt;\n     }\n \n   if (noerr)\n-    {\n-      return NULL;\n-    }\n+    return {nullptr, 0};\n \n   std::string type_name = type_to_string (type);\n   error (_(\"Type %s has no component named %s.\"), type_name.c_str (), name);\n }\n \n+/* See gdbtypes.h.  */\n+\n+struct type *\n+lookup_struct_elt_type (struct type *type, const char *name, int noerr)\n+{\n+  struct_elt elt = lookup_struct_elt (type, name, noerr);\n+  if (elt.field != NULL)\n+    return FIELD_TYPE (*elt.field);\n+  else\n+    return NULL;\n+}\n+\n /* Store in *MAX the largest number representable by unsigned integer type\n    TYPE.  */\n "
    },
    {
      "sha": "66051cf02c7290890fd43bf21fb778682db90ad7",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef0bd2046f58fac69577892c2d3b44b20d027476/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef0bd2046f58fac69577892c2d3b44b20d027476/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=ef0bd2046f58fac69577892c2d3b44b20d027476",
      "patch": "@@ -1873,6 +1873,44 @@ extern struct type *allocate_stub_method (struct type *);\n \n extern const char *type_name_or_error (struct type *type);\n \n+struct struct_elt\n+{\n+  /* The field of the element, or NULL if no element was found.  */\n+  struct field *field;\n+\n+  /* The bit offset of the element in the parent structure.  */\n+  LONGEST offset;\n+};\n+\n+/* Given a type TYPE, lookup the field and offset of the component named\n+   NAME.\n+\n+   TYPE can be either a struct or union, or a pointer or reference to\n+   a struct or union.  If it is a pointer or reference, its target\n+   type is automatically used.  Thus '.' and '->' are interchangable,\n+   as specified for the definitions of the expression element types\n+   STRUCTOP_STRUCT and STRUCTOP_PTR.\n+\n+   If NOERR is nonzero, the returned structure will have field set to\n+   NULL if there is no component named NAME.\n+\n+   If the component NAME is a field in an anonymous substructure of\n+   TYPE, the returned offset is a \"global\" offset relative to TYPE\n+   rather than an offset within the substructure.  */\n+\n+extern struct_elt lookup_struct_elt (struct type *, const char *, int);\n+\n+/* Given a type TYPE, lookup the type of the component named NAME.\n+\n+   TYPE can be either a struct or union, or a pointer or reference to\n+   a struct or union.  If it is a pointer or reference, its target\n+   type is automatically used.  Thus '.' and '->' are interchangable,\n+   as specified for the definitions of the expression element types\n+   STRUCTOP_STRUCT and STRUCTOP_PTR.\n+\n+   If NOERR is nonzero, return NULL if there is no component named\n+   NAME.  */\n+\n extern struct type *lookup_struct_elt_type (struct type *, const char *, int);\n \n extern struct type *make_pointer_type (struct type *, struct type **);"
    }
  ]
}