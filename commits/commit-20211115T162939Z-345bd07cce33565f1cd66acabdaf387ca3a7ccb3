{
  "sha": "345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
  "node_id": "C_kwDOANOeidoAKDM0NWJkMDdjY2UzMzU2NWYxY2Q2NmFjYWJkYWYzODdjYTNhN2NjYjM",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-11-15T16:29:39Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-11-15T16:29:39Z"
    },
    "message": "gdb: fix gdbarch_tdep ODR violation\n\nI would like to be able to use non-trivial types in gdbarch_tdep types.\nThis is not possible at the moment (in theory), because of the one\ndefinition rule.\n\nTo allow it, rename all gdbarch_tdep types to <arch>_gdbarch_tdep, and\nmake them inherit from a gdbarch_tdep base class.  The inheritance is\nnecessary to be able to pass pointers to all these <arch>_gdbarch_tdep\nobjects to gdbarch_alloc, which takes a pointer to gdbarch_tdep.\n\nThese objects are never deleted through a base class pointer, so I\ndidn't include a virtual destructor.  In the future, if gdbarch objects\ndeletable, I could imagine that the gdbarch_tdep objects could become\nowned by the gdbarch objects, and then it would become useful to have a\nvirtual destructor (so that the gdbarch object can delete the owned\ngdbarch_tdep object).  But that's not necessary right now.\n\nIt turns out that RISC-V already has a gdbarch_tdep that is\nnon-default-constructible, so that provides a good motivation for this\nchange.\n\nMost changes are fairly straightforward, mostly needing to add some\ncasts all over the place.  There is however the xtensa architecture,\ndoing its own little weird thing to define its gdbarch_tdep.  I did my\nbest to adapt it, but I can't test those changes.\n\nChange-Id: Ic001903f91ddd106bd6ca09a79dabe8df2d69f3b",
    "tree": {
      "sha": "bfa86d2102817e06235193c865d2580e802d0a1a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bfa86d2102817e06235193c865d2580e802d0a1a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "eae06bb301512a21277dd48a4bff025c4dceda9e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/eae06bb301512a21277dd48a4bff025c4dceda9e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/eae06bb301512a21277dd48a4bff025c4dceda9e"
    }
  ],
  "stats": {
    "total": 2839,
    "additions": 1514,
    "deletions": 1325
  },
  "files": [
    {
      "sha": "7342e7b9002ca7ed6047399e6596d60c2ea3a370",
      "filename": "gdb/aarch64-fbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-fbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -153,7 +153,7 @@ aarch64_fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,\n static void\n aarch64_fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Generic FreeBSD support.  */\n   fbsd_init_abi (info, gdbarch);"
    },
    {
      "sha": "7a9cf0c87e9c0bff96d5408569a70a8696e3fb9f",
      "filename": "gdb/aarch64-linux-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -286,7 +286,7 @@ aarch64_linux_sigframe_init (const struct tramp_frame *self,\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   CORE_ADDR sp = get_frame_register_unsigned (this_frame, AARCH64_SP_REGNUM);\n   CORE_ADDR sigcontext_addr = (sp + AARCH64_RT_SIGFRAME_UCONTEXT_OFFSET\n \t\t\t       + AARCH64_UCONTEXT_SIGCONTEXT_OFFSET );\n@@ -640,7 +640,8 @@ aarch64_linux_collect_sve_regset (const struct regset *regset,\n   gdb_byte *header = (gdb_byte *) buf;\n   struct gdbarch *gdbarch = regcache->arch ();\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  uint64_t vq = gdbarch_tdep (gdbarch)->vq;\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  uint64_t vq = tdep->vq;\n \n   gdb_assert (buf != NULL);\n   gdb_assert (size > SVE_HEADER_SIZE);\n@@ -675,7 +676,7 @@ aarch64_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t\t    void *cb_data,\n \t\t\t\t\t    const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", AARCH64_LINUX_SIZEOF_GREGSET, AARCH64_LINUX_SIZEOF_GREGSET,\n       &aarch64_linux_gregset, NULL, cb_data);\n@@ -1719,7 +1720,7 @@ aarch64_linux_report_signal_info (struct gdbarch *gdbarch,\n \t\t\t\t  struct ui_out *uiout,\n \t\t\t\t  enum gdb_signal siggnal)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->has_mte () || siggnal != GDB_SIGNAL_SEGV)\n     return;\n@@ -1788,7 +1789,7 @@ aarch64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \t\t\t\t\t\t\t\t    NULL };\n   static const char *const stap_register_indirection_suffixes[] = { \"]\",\n \t\t\t\t\t\t\t\t    NULL };\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->lowest_pc = 0x8000;\n "
    },
    {
      "sha": "9805967a20545b7f686b9a7b6e6c34c3da3d1df5",
      "filename": "gdb/aarch64-newlib-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-newlib-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-newlib-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-newlib-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -29,7 +29,7 @@\n static void\n aarch64_newlib_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Jump buffer - support for longjmp.\n      Offset of original PC in jump buffer (in registers).  */"
    },
    {
      "sha": "392110afd2b0a23c2c3ae8394cd8959591b62589",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 34,
      "deletions": 26,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -248,7 +248,7 @@ class instruction_reader : public abstract_instruction_reader\n    THIS_FRAME.  */\n \n static CORE_ADDR\n-aarch64_frame_unmask_lr (struct gdbarch_tdep *tdep,\n+aarch64_frame_unmask_lr (aarch64_gdbarch_tdep *tdep,\n \t\t\t struct frame_info *this_frame, CORE_ADDR addr)\n {\n   if (tdep->has_pauth ()\n@@ -500,7 +500,8 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n \t}\n       else if (inst.opcode->iclass == ic_system)\n \t{\n-\t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\t  aarch64_gdbarch_tdep *tdep\n+\t    = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \t  int ra_state_val = 0;\n \n \t  if (insn == 0xd503233f /* paciasp.  */\n@@ -635,7 +636,7 @@ aarch64_analyze_prologue_test (void)\n   struct aarch64_prologue_cache cache;\n   cache.saved_regs = trad_frame_alloc_saved_regs (gdbarch);\n \n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Test the simple prologue in which frame pointer is used.  */\n   {\n@@ -1037,7 +1038,9 @@ aarch64_prologue_frame_unwind_stop_reason (struct frame_info *this_frame,\n     return UNWIND_UNAVAILABLE;\n \n   /* Halt the backtrace at \"_start\".  */\n-  if (cache->prev_pc <= gdbarch_tdep (get_frame_arch (this_frame))->lowest_pc)\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (arch);\n+  if (cache->prev_pc <= tdep->lowest_pc)\n     return UNWIND_OUTERMOST;\n \n   /* We've hit a wall, stop.  */\n@@ -1079,7 +1082,8 @@ aarch64_prologue_prev_register (struct frame_info *this_frame,\n     {\n       CORE_ADDR lr;\n       struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      aarch64_gdbarch_tdep *tdep\n+\t= (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n       lr = frame_unwind_register_unsigned (this_frame, AARCH64_LR_REGNUM);\n \n@@ -1247,7 +1251,8 @@ static struct value *\n aarch64_dwarf2_prev_register (struct frame_info *this_frame,\n \t\t\t      void **this_cache, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (arch);\n   CORE_ADDR lr;\n \n   switch (regnum)\n@@ -1273,7 +1278,7 @@ aarch64_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,\n \t\t\t       struct dwarf2_frame_state_reg *reg,\n \t\t\t       struct frame_info *this_frame)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   switch (regnum)\n     {\n@@ -1313,7 +1318,7 @@ static bool\n aarch64_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdb_byte op,\n \t\t\t\t     struct dwarf2_frame_state *fs)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct dwarf2_frame_state_reg *ra_state;\n \n   if (op == DW_CFA_AARCH64_negate_ra_state)\n@@ -1952,7 +1957,7 @@ aarch64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)\n static struct type *\n aarch64_vnq_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->vnq_type == NULL)\n     {\n@@ -1979,7 +1984,7 @@ aarch64_vnq_type (struct gdbarch *gdbarch)\n static struct type *\n aarch64_vnd_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->vnd_type == NULL)\n     {\n@@ -2009,7 +2014,7 @@ aarch64_vnd_type (struct gdbarch *gdbarch)\n static struct type *\n aarch64_vns_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->vns_type == NULL)\n     {\n@@ -2039,7 +2044,7 @@ aarch64_vns_type (struct gdbarch *gdbarch)\n static struct type *\n aarch64_vnh_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->vnh_type == NULL)\n     {\n@@ -2072,7 +2077,7 @@ aarch64_vnh_type (struct gdbarch *gdbarch)\n static struct type *\n aarch64_vnb_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->vnb_type == NULL)\n     {\n@@ -2099,7 +2104,7 @@ aarch64_vnb_type (struct gdbarch *gdbarch)\n static struct type *\n aarch64_vnv_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->vnv_type == NULL)\n     {\n@@ -2170,7 +2175,7 @@ aarch64_vnv_type (struct gdbarch *gdbarch)\n static int\n aarch64_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (reg >= AARCH64_DWARF_X0 && reg <= AARCH64_DWARF_X0 + 30)\n     return AARCH64_X0_REGNUM + reg - AARCH64_DWARF_X0;\n@@ -2457,7 +2462,7 @@ aarch64_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n   CORE_ADDR jb_addr;\n   gdb_byte buf[X_REGISTER_SIZE];\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   jb_addr = get_frame_register_unsigned (frame, AARCH64_X0_REGNUM);\n@@ -2488,7 +2493,7 @@ aarch64_gen_return_address (struct gdbarch *gdbarch,\n static const char *\n aarch64_pseudo_register_name (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   static const char *const q_name[] =\n     {\n@@ -2602,7 +2607,7 @@ aarch64_pseudo_register_name (struct gdbarch *gdbarch, int regnum)\n static struct type *\n aarch64_pseudo_register_type (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   int p_regnum = regnum - gdbarch_num_regs (gdbarch);\n \n@@ -2639,7 +2644,7 @@ static int\n aarch64_pseudo_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n \t\t\t\t    struct reggroup *group)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   int p_regnum = regnum - gdbarch_num_regs (gdbarch);\n \n@@ -2693,7 +2698,7 @@ static struct value *\n aarch64_pseudo_read_value (struct gdbarch *gdbarch, readable_regcache *regcache,\n \t\t\t   int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct value *result_value = allocate_value (register_type (gdbarch, regnum));\n \n   VALUE_LVAL (result_value) = lval_register;\n@@ -2763,7 +2768,7 @@ static void\n aarch64_pseudo_write (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t      int regnum, const gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   regnum -= gdbarch_num_regs (gdbarch);\n \n   if (regnum >= AARCH64_Q0_REGNUM && regnum < AARCH64_Q0_REGNUM + 32)\n@@ -3328,7 +3333,7 @@ aarch64_add_reggroups (struct gdbarch *gdbarch)\n static int\n aarch64_cannot_store_register (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->has_pauth ())\n     return 0;\n@@ -3375,7 +3380,8 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        best_arch != nullptr;\n        best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))\n     {\n-      struct gdbarch_tdep *tdep = gdbarch_tdep (best_arch->gdbarch);\n+      aarch64_gdbarch_tdep *tdep\n+\t= (aarch64_gdbarch_tdep *) gdbarch_tdep (best_arch->gdbarch);\n       if (tdep && tdep->vq == vq)\n \treturn best_arch->gdbarch;\n     }\n@@ -3483,7 +3489,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* AArch64 code is always little-endian.  */\n   info.byte_order_for_code = BFD_ENDIAN_LITTLE;\n \n-  struct gdbarch_tdep *tdep = XCNEW (struct gdbarch_tdep);\n+  aarch64_gdbarch_tdep *tdep = new aarch64_gdbarch_tdep;\n   struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* This should be low enough for everything.  */\n@@ -3605,7 +3611,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n static void\n aarch64_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  aarch64_gdbarch_tdep *tdep = (aarch64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep == NULL)\n     return;\n@@ -3825,7 +3831,9 @@ aarch64_record_data_proc_imm (insn_decode_record *aarch64_insn_r)\n static unsigned int\n aarch64_record_branch_except_sys (insn_decode_record *aarch64_insn_r)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (aarch64_insn_r->gdbarch);\n+\n+  aarch64_gdbarch_tdep *tdep\n+    = (aarch64_gdbarch_tdep *) gdbarch_tdep (aarch64_insn_r->gdbarch);\n   uint8_t insn_bits24_27, insn_bits28_31, insn_bits22_23;\n   uint32_t record_buf[4];\n "
    },
    {
      "sha": "efb0fa2d5b2c889d1523d250f2e23d3bbca78666",
      "filename": "gdb/aarch64-tdep.h",
      "status": "modified",
      "additions": 17,
      "deletions": 15,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/aarch64-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -25,6 +25,7 @@\n #include \"arch/aarch64.h\"\n #include \"displaced-stepping.h\"\n #include \"infrun.h\"\n+#include \"gdbarch.h\"\n \n /* Forward declarations.  */\n struct gdbarch;\n@@ -60,40 +61,41 @@ struct regset;\n #define AARCH64_DISPLACED_MODIFIED_INSNS 1\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct aarch64_gdbarch_tdep : gdbarch_tdep\n {\n   /* Lowest address at which instructions will appear.  */\n-  CORE_ADDR lowest_pc;\n+  CORE_ADDR lowest_pc = 0;\n \n   /* Offset to PC value in jump buffer.  If this is negative, longjmp\n      support will be disabled.  */\n-  int jb_pc;\n+  int jb_pc = 0;\n \n   /* And the size of each entry in the buf.  */\n-  size_t jb_elt_size;\n+  size_t jb_elt_size = 0;\n \n   /* Types for AdvSISD registers.  */\n-  struct type *vnq_type;\n-  struct type *vnd_type;\n-  struct type *vns_type;\n-  struct type *vnh_type;\n-  struct type *vnb_type;\n-  struct type *vnv_type;\n+  struct type *vnq_type = nullptr;\n+  struct type *vnd_type = nullptr;\n+  struct type *vns_type = nullptr;\n+  struct type *vnh_type = nullptr;\n+  struct type *vnb_type = nullptr;\n+  struct type *vnv_type = nullptr;\n \n   /* syscall record.  */\n-  int (*aarch64_syscall_record) (struct regcache *regcache, unsigned long svc_number);\n+  int (*aarch64_syscall_record) (struct regcache *regcache,\n+\t\t\t\t unsigned long svc_number) = nullptr;\n \n   /* The VQ value for SVE targets, or zero if SVE is not supported.  */\n-  uint64_t vq;\n+  uint64_t vq = 0;\n \n   /* Returns true if the target supports SVE.  */\n   bool has_sve () const\n   {\n     return vq != 0;\n   }\n \n-  int pauth_reg_base;\n-  int pauth_ra_state_regnum;\n+  int pauth_reg_base = 0;\n+  int pauth_ra_state_regnum = 0;\n \n   /* Returns true if the target supports pauth.  */\n   bool has_pauth () const\n@@ -102,7 +104,7 @@ struct gdbarch_tdep\n   }\n \n   /* First MTE register.  This is -1 if no MTE registers are available.  */\n-  int mte_reg_base;\n+  int mte_reg_base = 0;\n \n   /* Returns true if the target supports MTE.  */\n   bool has_mte () const"
    },
    {
      "sha": "b821a6bd93ac582d777dc7b5c809aab6ed57dec7",
      "filename": "gdb/alpha-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -354,8 +354,6 @@ alpha_linux_gdb_signal_to_target (struct gdbarch *gdbarch,\n static void\n alpha_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep;\n-\n   linux_init_abi (info, gdbarch, 0);\n \n   /* Hook into the DWARF CFI frame unwinder.  */\n@@ -364,7 +362,7 @@ alpha_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   /* Hook into the MDEBUG frame unwinder.  */\n   alpha_mdebug_init_abi (info, gdbarch);\n \n-  tdep = gdbarch_tdep (gdbarch);\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   tdep->dynamic_sigtramp_offset = alpha_linux_sigtramp_offset;\n   tdep->sigcontext_addr = alpha_linux_sigcontext_addr;\n   tdep->pc_in_sigtramp = alpha_linux_pc_in_sigtramp;"
    },
    {
      "sha": "b19f76bef06efa351af390fff5480ecdd44de1be",
      "filename": "gdb/alpha-netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-netbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -250,7 +250,7 @@ static void\n alphanbsd_init_abi (struct gdbarch_info info,\n \t\t    struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Hook into the DWARF CFI frame unwinder.  */\n   alpha_dwarf2_init_abi (info, gdbarch);"
    },
    {
      "sha": "7ca5ca17c6ea7c99804a90677a8ad51ca2d4acb1",
      "filename": "gdb/alpha-obsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-obsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -97,7 +97,7 @@ alphaobsd_sigcontext_addr (struct frame_info *this_frame)\n static void\n alphaobsd_init_abi(struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Hook into the DWARF CFI frame unwinder.  */\n   alpha_dwarf2_init_abi (info, gdbarch);"
    },
    {
      "sha": "760a18a178aa12fd05543a006c560a58b68729ac",
      "filename": "gdb/alpha-tdep.c",
      "status": "modified",
      "additions": 14,
      "deletions": 12,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -615,11 +615,12 @@ alpha_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t    gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n   enum type_code code = type->code ();\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if ((code == TYPE_CODE_STRUCT\n        || code == TYPE_CODE_UNION\n        || code == TYPE_CODE_ARRAY)\n-      && gdbarch_tdep (gdbarch)->return_in_memory (type))\n+      && tdep->return_in_memory (type))\n     {\n       if (readbuf)\n \t{\n@@ -850,7 +851,7 @@ static int\n alpha_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n {\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   CORE_ADDR jb_addr;\n   gdb_byte raw_buffer[ALPHA_REGISTER_SIZE];\n@@ -882,15 +883,15 @@ alpha_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n \t\t\t\t   void **this_prologue_cache)\n {\n   struct alpha_sigtramp_unwind_cache *info;\n-  struct gdbarch_tdep *tdep;\n \n   if (*this_prologue_cache)\n     return (struct alpha_sigtramp_unwind_cache *) *this_prologue_cache;\n \n   info = FRAME_OBSTACK_ZALLOC (struct alpha_sigtramp_unwind_cache);\n   *this_prologue_cache = info;\n \n-  tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (arch);\n   info->sigcontext_addr = tdep->sigcontext_addr (this_frame);\n \n   return info;\n@@ -903,7 +904,7 @@ static CORE_ADDR\n alpha_sigtramp_register_address (struct gdbarch *gdbarch,\n \t\t\t\t CORE_ADDR sigcontext_addr, int regnum)\n { \n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (regnum >= 0 && regnum < 32)\n     return sigcontext_addr + tdep->sc_regs_offset + regnum * 8;\n@@ -924,7 +925,7 @@ alpha_sigtramp_frame_this_id (struct frame_info *this_frame,\n \t\t\t      struct frame_id *this_id)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct alpha_sigtramp_unwind_cache *info\n     = alpha_sigtramp_frame_unwind_cache (this_frame, this_prologue_cache);\n   CORE_ADDR stack_addr, code_addr;\n@@ -999,14 +1000,16 @@ alpha_sigtramp_frame_sniffer (const struct frame_unwind *self,\n \n   /* We shouldn't even bother to try if the OSABI didn't register a\n      sigcontext_addr handler or pc_in_sigtramp handler.  */\n-  if (gdbarch_tdep (gdbarch)->sigcontext_addr == NULL)\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  if (tdep->sigcontext_addr == NULL)\n     return 0;\n-  if (gdbarch_tdep (gdbarch)->pc_in_sigtramp == NULL)\n+\n+  if (tdep->pc_in_sigtramp == NULL)\n     return 0;\n \n   /* Otherwise we should be in a signal frame.  */\n   find_pc_partial_function (pc, &name, NULL, NULL);\n-  if (gdbarch_tdep (gdbarch)->pc_in_sigtramp (gdbarch, pc, name))\n+  if (tdep->pc_in_sigtramp (gdbarch, pc, name))\n     return 1;\n \n   return 0;\n@@ -1038,7 +1041,7 @@ static int heuristic_fence_post = 0;\n static CORE_ADDR\n alpha_heuristic_proc_start (struct gdbarch *gdbarch, CORE_ADDR pc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  alpha_gdbarch_tdep *tdep = (alpha_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   CORE_ADDR last_non_nop = pc;\n   CORE_ADDR fence = pc - heuristic_fence_post;\n   CORE_ADDR orig_pc = pc;\n@@ -1724,15 +1727,14 @@ alpha_software_single_step (struct regcache *regcache)\n static struct gdbarch *\n alpha_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n \n   /* Find a candidate among extant architectures.  */\n   arches = gdbarch_list_lookup_by_info (arches, &info);\n   if (arches != NULL)\n     return arches->gdbarch;\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  alpha_gdbarch_tdep *tdep = new alpha_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Lowest text address.  This is used by heuristic_proc_start()"
    },
    {
      "sha": "c1674fea8cb6ad105075c1971237e714e6f2dddc",
      "filename": "gdb/alpha-tdep.h",
      "status": "modified",
      "additions": 13,
      "deletions": 11,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/alpha-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -19,6 +19,8 @@\n #ifndef ALPHA_TDEP_H\n #define ALPHA_TDEP_H\n \n+#include \"gdbarch.h\"\n+\n struct regcache;\n \n /* Say how long (ordinary) registers are.  This is a piece of bogosity\n@@ -68,38 +70,38 @@ struct regcache;\n #define ALPHA_NUM_ARG_REGS   6\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct alpha_gdbarch_tdep : gdbarch_tdep\n {\n-  CORE_ADDR vm_min_address;\t/* Used by alpha_heuristic_proc_start.  */\n+  CORE_ADDR vm_min_address = 0;\t/* Used by alpha_heuristic_proc_start.  */\n \n   /* If PC is inside a dynamically-generated signal trampoline function\n      (i.e. one copied onto the user stack at run-time), return how many\n      bytes PC is beyond the start of that function.  Otherwise, return -1.  */\n-  LONGEST (*dynamic_sigtramp_offset) (struct gdbarch *, CORE_ADDR);\n+  LONGEST (*dynamic_sigtramp_offset) (struct gdbarch *, CORE_ADDR) = nullptr;\n \n   /* Translate a signal handler stack base address into the address of\n      the sigcontext structure for that signal handler.  */\n-  CORE_ADDR (*sigcontext_addr) (struct frame_info *);\n+  CORE_ADDR (*sigcontext_addr) (struct frame_info *) = nullptr;\n \n   /* Does the PC fall in a signal trampoline.  */\n   /* NOTE: cagney/2004-04-30: Do not copy/clone this code.  Instead\n      look at tramp-frame.h and other simpler per-architecture\n      sigtramp unwinders.  */\n   int (*pc_in_sigtramp) (struct gdbarch *gdbarch, CORE_ADDR pc,\n-\t\t\t const char *name);\n+\t\t\t const char *name) = nullptr;\n \n   /* If TYPE will be returned in memory, return true.  */\n-  int (*return_in_memory) (struct type *type);\n+  int (*return_in_memory) (struct type *type) = nullptr;\n \n   /* Offset of registers in `struct sigcontext'.  */\n-  int sc_pc_offset;\n-  int sc_regs_offset;\n-  int sc_fpregs_offset;\n+  int sc_pc_offset = 0;\n+  int sc_regs_offset = 0;\n+  int sc_fpregs_offset = 0;\n \n-  int jb_pc;\t\t\t/* Offset to PC value in jump buffer.\n+  int jb_pc = 0;\t\t\t/* Offset to PC value in jump buffer.\n \t\t\t\t   If htis is negative, longjmp support\n \t\t\t\t   will be disabled.  */\n-  size_t jb_elt_size;\t\t/* And the size of each entry in the buf.  */\n+  size_t jb_elt_size = 0;\t\t/* And the size of each entry in the buf.  */\n };\n \n extern unsigned int alpha_read_insn (struct gdbarch *gdbarch, CORE_ADDR pc);"
    },
    {
      "sha": "5cf3ff266a4686a5ae5899a78facb7280ac6521c",
      "filename": "gdb/amd64-darwin-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-darwin-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -97,7 +97,7 @@ amd64_darwin_sigcontext_addr (struct frame_info *this_frame)\n static void\n x86_darwin_init_abi_64 (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   amd64_init_abi (info, gdbarch,\n \t\t  amd64_target_description (X86_XSTATE_SSE_MASK, true));"
    },
    {
      "sha": "5069342ca737b0709bfb9df8c339c38a47956cb7",
      "filename": "gdb/amd64-fbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-fbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -195,7 +195,7 @@ amd64fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t\tvoid *cb_data,\n \t\t\t\t\tconst struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", tdep->sizeof_gregset, tdep->sizeof_gregset, &i386_gregset, NULL,\n       cb_data);\n@@ -229,7 +229,7 @@ amd64fbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n static void\n amd64fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Generic FreeBSD support. */\n   fbsd_init_abi (info, gdbarch);"
    },
    {
      "sha": "817a197ceaaef81e1a8b74e213350b2097213533",
      "filename": "gdb/amd64-linux-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -1650,7 +1650,7 @@ amd64_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t\t  void *cb_data,\n \t\t\t\t\t  const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", 27 * 8, 27 * 8, &i386_gregset, NULL, cb_data);\n   cb (\".reg2\", 512, 512, &amd64_fpregset, NULL, cb_data);\n@@ -1787,7 +1787,7 @@ static void\n amd64_linux_init_abi_common(struct gdbarch_info info, struct gdbarch *gdbarch,\n \t\t\t    int num_disp_step_buffers)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, num_disp_step_buffers);\n \n@@ -1840,7 +1840,7 @@ amd64_linux_init_abi_common(struct gdbarch_info info, struct gdbarch *gdbarch,\n static void\n amd64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct tdesc_arch_data *tdesc_data = info.tdesc_data;\n   const struct tdesc_feature *feature;\n   int valid_p;\n@@ -2054,7 +2054,7 @@ amd64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n static void\n amd64_x32_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct tdesc_arch_data *tdesc_data = info.tdesc_data;\n   const struct tdesc_feature *feature;\n   int valid_p;"
    },
    {
      "sha": "be8ee3725f64fb5ca05778e852ab276fb085fbe8",
      "filename": "gdb/amd64-netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-netbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -97,7 +97,7 @@ int amd64nbsd_r_reg_offset[] =\n static void\n amd64nbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Initialize general-purpose register set details first.  */\n   tdep->gregset_reg_offset = amd64nbsd_r_reg_offset;"
    },
    {
      "sha": "0da1dbf4e4be07bdbda05755a91eaad90173d86f",
      "filename": "gdb/amd64-obsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-obsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -420,7 +420,7 @@ static const struct frame_unwind amd64obsd_trapframe_unwind =\n static void\n amd64obsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   amd64_init_abi (info, gdbarch,\n \t\t  amd64_target_description (X86_XSTATE_SSE_MASK, true));"
    },
    {
      "sha": "4cb243bda40afa91498a562a7b2aa9a103b89802",
      "filename": "gdb/amd64-sol2-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-sol2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-sol2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-sol2-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -80,7 +80,7 @@ amd64_sol2_mcontext_addr (struct frame_info *this_frame)\n static void\n amd64_sol2_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->gregset_reg_offset = amd64_sol2_gregset_reg_offset;\n   tdep->gregset_num_regs = ARRAY_SIZE (amd64_sol2_gregset_reg_offset);"
    },
    {
      "sha": "7c67359678b8684855ce1fc4f1c19cf5362e07db",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 19,
      "deletions": 17,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -247,7 +247,7 @@ static const int amd64_dwarf_regmap_len =\n static int\n amd64_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ymm0_regnum = tdep->ymm0_regnum;\n   int regnum = -1;\n \n@@ -331,7 +331,7 @@ static const char * const amd64_dword_names[] =\n static const char *\n amd64_pseudo_register_name (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (i386_byte_regnum_p (gdbarch, regnum))\n     return amd64_byte_names[regnum - tdep->al_regnum];\n   else if (i386_zmm_regnum_p (gdbarch, regnum))\n@@ -353,7 +353,7 @@ amd64_pseudo_register_read_value (struct gdbarch *gdbarch,\n \t\t\t\t  readable_regcache *regcache,\n \t\t\t\t  int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   value *result_value = allocate_value (register_type (gdbarch, regnum));\n   VALUE_LVAL (result_value) = lval_register;\n@@ -413,7 +413,7 @@ amd64_pseudo_register_write (struct gdbarch *gdbarch,\n \t\t\t     struct regcache *regcache,\n \t\t\t     int regnum, const gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (i386_byte_regnum_p (gdbarch, regnum))\n     {\n@@ -465,7 +465,7 @@ static int\n amd64_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n \t\t\t\t  struct agent_expr *ax, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (i386_byte_regnum_p (gdbarch, regnum))\n     {\n@@ -2739,7 +2739,7 @@ static struct amd64_frame_cache *\n amd64_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct amd64_frame_cache *cache;\n   CORE_ADDR addr;\n@@ -2821,7 +2821,8 @@ amd64_sigtramp_frame_sniffer (const struct frame_unwind *self,\n \t\t\t      struct frame_info *this_frame,\n \t\t\t      void **this_cache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   /* We shouldn't even bother if we don't have a sigcontext_addr\n      handler.  */\n@@ -3021,7 +3022,7 @@ amd64_supply_fpregset (const struct regset *regset, struct regcache *regcache,\n \t\t       int regnum, const void *fpregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   gdb_assert (len >= tdep->sizeof_fpregset);\n   amd64_supply_fxsave (regcache, regnum, fpregs);\n@@ -3038,7 +3039,7 @@ amd64_collect_fpregset (const struct regset *regset,\n \t\t\tint regnum, void *fpregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   gdb_assert (len >= tdep->sizeof_fpregset);\n   amd64_collect_fxsave (regcache, regnum, fpregs);\n@@ -3062,7 +3063,8 @@ amd64_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n   gdb_byte buf[8];\n   CORE_ADDR jb_addr;\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  int jb_pc_offset = gdbarch_tdep (gdbarch)->jb_pc_offset;\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int jb_pc_offset = tdep->jb_pc_offset;\n   int len = TYPE_LENGTH (builtin_type (gdbarch)->builtin_func_ptr);\n \n   /* If JB_PC_OFFSET is -1, we have no way to find out where the\n@@ -3105,7 +3107,7 @@ void\n amd64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch,\n \t\tconst target_desc *default_tdesc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const struct target_desc *tdesc = info.target_desc;\n   static const char *const stap_integer_prefixes[] = { \"$\", NULL };\n   static const char *const stap_register_prefixes[] = { \"%\", NULL };\n@@ -3284,7 +3286,7 @@ amd64_none_init_abi (gdbarch_info info, gdbarch *arch)\n static struct type *\n amd64_x32_pseudo_register_type (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   switch (regnum - tdep->eax_regnum)\n     {\n@@ -3302,7 +3304,7 @@ void\n amd64_x32_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch,\n \t\t    const target_desc *default_tdesc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   amd64_init_abi (info, gdbarch, default_tdesc);\n \n@@ -3372,7 +3374,7 @@ amd64_supply_fxsave (struct regcache *regcache, int regnum,\n \t\t     const void *fxsave)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   i387_supply_fxsave (regcache, regnum, fxsave);\n \n@@ -3395,7 +3397,7 @@ amd64_supply_xsave (struct regcache *regcache, int regnum,\n \t\t    const void *xsave)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   i387_supply_xsave (regcache, regnum, xsave);\n \n@@ -3430,7 +3432,7 @@ amd64_collect_fxsave (const struct regcache *regcache, int regnum,\n \t\t      void *fxsave)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_byte *regs = (gdb_byte *) fxsave;\n \n   i387_collect_fxsave (regcache, regnum, fxsave);\n@@ -3451,7 +3453,7 @@ amd64_collect_xsave (const struct regcache *regcache, int regnum,\n \t\t     void *xsave, int gcore)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_byte *regs = (gdb_byte *) xsave;\n \n   i387_collect_xsave (regcache, regnum, xsave, gcore);"
    },
    {
      "sha": "fb3fe488ce1f88b765dbb1146ea8ed5b826f2ad1",
      "filename": "gdb/amd64-windows-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/amd64-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-windows-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -1277,7 +1277,7 @@ amd64_windows_auto_wide_charset (void)\n static void\n amd64_windows_init_abi_common (gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* The dwarf2 unwinder (appended very early by i386_gdbarch_init) is\n      preferred over the SEH one.  The reasons are:"
    },
    {
      "sha": "de95d5acff95cd7ebce50e88be09c5d11eedb1f7",
      "filename": "gdb/arc-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -410,7 +410,7 @@ static std::vector<CORE_ADDR>\n arc_linux_software_single_step (struct regcache *regcache)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arc_gdbarch_tdep *tdep = (arc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct disassemble_info di = arc_disassemble_info (gdbarch);\n \n   /* Read current instruction.  */\n@@ -692,7 +692,7 @@ arc_linux_core_read_description (struct gdbarch *gdbarch,\n static void\n arc_linux_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arc_gdbarch_tdep *tdep = (arc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   arc_linux_debug_printf (\"GNU/Linux OS/ABI initialization.\");\n "
    },
    {
      "sha": "475ba2a5614dfe9f20e8181317c6f628ece853c0",
      "filename": "gdb/arc-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -1002,7 +1002,7 @@ arc_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n   arc_debug_printf (\"called\");\n \n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arc_gdbarch_tdep *tdep = (arc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int pc_offset = tdep->jb_pc * ARC_REGISTER_SIZE;\n   gdb_byte buf[ARC_REGISTER_SIZE];\n   CORE_ADDR jb_addr = get_frame_register_unsigned (frame, ARC_FIRST_ARG_REGNUM);\n@@ -1832,7 +1832,8 @@ arc_make_sigtramp_frame_cache (struct frame_info *this_frame)\n {\n   arc_debug_printf (\"called\");\n \n-  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  arc_gdbarch_tdep *tdep = (arc_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   /* Allocate new frame cache instance and space for saved register info.  */\n   struct arc_frame_cache *cache = FRAME_OBSTACK_ZALLOC (struct arc_frame_cache);\n@@ -1906,11 +1907,10 @@ arc_sigtramp_frame_sniffer (const struct frame_unwind *self,\n \t\t\t    struct frame_info *this_frame,\n \t\t\t    void **this_cache)\n {\n-  struct gdbarch_tdep *tdep;\n-\n   arc_debug_printf (\"called\");\n \n-  tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  arc_gdbarch_tdep *tdep = (arc_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   /* If we have a sigcontext_addr handler, then just return 1 (same as the\n      \"default_frame_sniffer ()\").  */\n@@ -2295,11 +2295,11 @@ arc_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* Allocate the ARC-private target-dependent information structure, and the\n      GDB target-independent information structure.  */\n-  gdb::unique_xmalloc_ptr<struct gdbarch_tdep> tdep\n-    (XCNEW (struct gdbarch_tdep));\n+  std::unique_ptr<arc_gdbarch_tdep> tdep_holder (new arc_gdbarch_tdep);\n+  arc_gdbarch_tdep *tdep = tdep_holder.get ();\n   tdep->jb_pc = -1; /* No longjmp support by default.  */\n   tdep->has_hw_loops = arc_check_for_hw_loops (tdesc, tdesc_data.get ());\n-  struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep.release ());\n+  struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep_holder.release ());\n \n   /* Data types.  */\n   set_gdbarch_short_bit (gdbarch, 16);\n@@ -2384,7 +2384,7 @@ arc_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n      It can override functions set earlier.  */\n   gdbarch_init_osabi (info, gdbarch);\n \n-  if (gdbarch_tdep (gdbarch)->jb_pc >= 0)\n+  if (tdep->jb_pc >= 0)\n     set_gdbarch_get_longjmp_target (gdbarch, arc_get_longjmp_target);\n \n   /* Disassembler options.  Enforce CPU if it was specified in XML target\n@@ -2454,7 +2454,7 @@ arc_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n static void\n arc_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arc_gdbarch_tdep *tdep = (arc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   fprintf_unfiltered (file, \"arc_dump_tdep: jb_pc = %i\\n\", tdep->jb_pc);\n "
    },
    {
      "sha": "d8495ed3154f08254ca00546a30a2207b7103e0e",
      "filename": "gdb/arc-tdep.h",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arc-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arc-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -121,27 +121,27 @@ extern bool arc_debug;\n \n /* Target-dependent information.  */\n \n-struct gdbarch_tdep\n+struct arc_gdbarch_tdep : gdbarch_tdep\n {\n   /* Offset to PC value in jump buffer.  If this is negative, longjmp\n      support will be disabled.  */\n-  int jb_pc;\n+  int jb_pc = 0;\n \n   /* Whether target has hardware (aka zero-delay) loops.  */\n-  bool has_hw_loops;\n+  bool has_hw_loops = false;\n \n   /* Detect sigtramp.  */\n-  bool (*is_sigtramp) (struct frame_info *);\n+  bool (*is_sigtramp) (struct frame_info *) = nullptr;\n \n   /* Get address of sigcontext for sigtramp.  */\n-  CORE_ADDR (*sigcontext_addr) (struct frame_info *);\n+  CORE_ADDR (*sigcontext_addr) (struct frame_info *) = nullptr;\n \n   /* Offset of registers in `struct sigcontext'.  */\n-  const int *sc_reg_offset;\n+  const int *sc_reg_offset = nullptr;\n \n   /* Number of registers in sc_reg_offsets.  Most likely a ARC_LAST_REGNUM,\n      but in theory it could be less, so it is kept separate.  */\n-  int sc_num_regs;\n+  int sc_num_regs = 0;\n };\n \n /* Utility functions used by other ARC-specific modules.  */"
    },
    {
      "sha": "a1482c49a43bcd094473982b9f635a7ae5667cd8",
      "filename": "gdb/arm-fbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-fbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -158,7 +158,7 @@ arm_fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t       void *cb_data,\n \t\t\t\t       const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", ARM_FBSD_SIZEOF_GREGSET, ARM_FBSD_SIZEOF_GREGSET,\n       &arm_fbsd_gregset, NULL, cb_data);\n@@ -211,7 +211,7 @@ arm_fbsd_core_read_description (struct gdbarch *gdbarch,\n static void\n arm_fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Generic FreeBSD support.  */\n   fbsd_init_abi (info, gdbarch);"
    },
    {
      "sha": "025ecf0c625fffc1367de0f9c2ffae36b4c43767",
      "filename": "gdb/arm-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -712,7 +712,7 @@ arm_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t\tvoid *cb_data,\n \t\t\t\t\tconst struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", ARM_LINUX_SIZEOF_GREGSET, ARM_LINUX_SIZEOF_GREGSET,\n       &arm_linux_gregset, NULL, cb_data);\n@@ -1714,7 +1714,7 @@ arm_linux_init_abi (struct gdbarch_info info,\n \t\t\t\t\t\t\t\t    NULL };\n   static const char *const stap_register_indirection_suffixes[] = { \"]\",\n \t\t\t\t\t\t\t\t    NULL };\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 1);\n "
    },
    {
      "sha": "bf4e46ff617fd27e2b97aa9e157b9f67f261009e",
      "filename": "gdb/arm-netbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-netbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -111,7 +111,7 @@ static void\n arm_netbsd_init_abi_common (struct gdbarch_info info,\n \t\t\t    struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->lowest_pc = 0x8000;\n   switch (info.byte_order)\n@@ -148,7 +148,7 @@ static void\n arm_netbsd_elf_init_abi (struct gdbarch_info info,\n \t\t\t struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   arm_netbsd_init_abi_common (info, gdbarch);\n "
    },
    {
      "sha": "a308c794aae505dfd584a7701bb6011aa67ad613",
      "filename": "gdb/arm-none-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-none-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-none-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-none-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -177,7 +177,7 @@ arm_none_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t       void *cb_data,\n \t\t\t\t       const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", ARM_NONE_SIZEOF_GREGSET, ARM_NONE_SIZEOF_GREGSET,\n       &arm_none_gregset, nullptr, cb_data);"
    },
    {
      "sha": "4fa88538e3466ac1224e00a5c657b6a1aa04d569",
      "filename": "gdb/arm-obsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-obsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -76,7 +76,7 @@ static void\n armobsd_init_abi (struct gdbarch_info info,\n \t\t  struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->fp_model == ARM_FLOAT_AUTO)\n     tdep->fp_model = ARM_FLOAT_SOFT_VFP;"
    },
    {
      "sha": "7495434484e5798898242160764ceb1f17513221",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 72,
      "deletions": 51,
      "changes": 123,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -332,7 +332,9 @@ bool arm_apcs_32 = true;\n int\n arm_psr_thumb_bit (struct gdbarch *gdbarch)\n {\n-  if (gdbarch_tdep (gdbarch)->is_m)\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+  if (tdep->is_m)\n     return XPSR_T;\n   else\n     return CPSR_T;\n@@ -438,6 +440,7 @@ arm_pc_is_thumb (struct gdbarch *gdbarch, CORE_ADDR memaddr)\n   struct bound_minimal_symbol sym;\n   char type;\n   arm_displaced_step_copy_insn_closure *dsc = nullptr;\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (gdbarch_displaced_step_copy_insn_closure_by_addr_p (gdbarch))\n     dsc = ((arm_displaced_step_copy_insn_closure * )\n@@ -465,7 +468,7 @@ arm_pc_is_thumb (struct gdbarch *gdbarch, CORE_ADDR memaddr)\n     return 1;\n \n   /* ARM v6-M and v7-M are always in Thumb mode.  */\n-  if (gdbarch_tdep (gdbarch)->is_m)\n+  if (tdep->is_m)\n     return 1;\n \n   /* If there are mapping symbols, consult them.  */\n@@ -568,10 +571,11 @@ arm_m_addr_is_magic (CORE_ADDR addr)\n static CORE_ADDR\n arm_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR val)\n {\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n   /* On M-profile devices, do not strip the low bit from EXC_RETURN\n      (the magic exception return address).  */\n-  if (gdbarch_tdep (gdbarch)->is_m\n-      && arm_m_addr_is_magic (val))\n+  if (tdep->is_m && arm_m_addr_is_magic (val))\n     return val;\n \n   if (arm_apcs_32)\n@@ -1557,6 +1561,7 @@ arm_analyze_prologue (struct gdbarch *gdbarch,\n   CORE_ADDR offset, current_pc;\n   pv_t regs[ARM_FPS_REGNUM];\n   CORE_ADDR unrecognized_pc = 0;\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Search the prologue looking for instructions that set up the\n      frame pointer, adjust the stack pointer, and save registers.\n@@ -1661,7 +1666,7 @@ arm_analyze_prologue (struct gdbarch *gdbarch,\n \t}\n       else if ((insn & 0xffff7fff) == 0xed6d0103\t/* stfe f?,\n \t\t\t\t\t\t\t   [sp, -#c]! */\n-\t       && gdbarch_tdep (gdbarch)->have_fpa_registers)\n+\t       && tdep->have_fpa_registers)\n \t{\n \t  if (stack.store_would_trash (regs[ARM_SP_REGNUM]))\n \t    break;\n@@ -1672,7 +1677,7 @@ arm_analyze_prologue (struct gdbarch *gdbarch,\n \t}\n       else if ((insn & 0xffbf0fff) == 0xec2d0200\t/* sfmfd f0, 4,\n \t\t\t\t\t\t\t   [sp!] */\n-\t       && gdbarch_tdep (gdbarch)->have_fpa_registers)\n+\t       && tdep->have_fpa_registers)\n \t{\n \t  int n_saved_fp_regs;\n \t  unsigned int fp_start_reg, fp_bound_reg;\n@@ -1800,6 +1805,7 @@ arm_scan_prologue (struct frame_info *this_frame,\n   CORE_ADDR prologue_start, prologue_end;\n   CORE_ADDR prev_pc = get_frame_pc (this_frame);\n   CORE_ADDR block_addr = get_frame_address_in_block (this_frame);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Assume there is no frame until proven otherwise.  */\n   cache->framereg = ARM_SP_REGNUM;\n@@ -1865,7 +1871,7 @@ arm_scan_prologue (struct frame_info *this_frame,\n       ULONGEST return_value;\n \n       /* AAPCS does not use a frame register, so we can abort here.  */\n-      if (gdbarch_tdep (gdbarch)->arm_abi == ARM_ABI_AAPCS)\n+      if (tdep->arm_abi == ARM_ABI_AAPCS)\n \treturn;\n \n       frame_loc = get_frame_register_unsigned (this_frame, ARM_FP_REGNUM);\n@@ -1930,7 +1936,9 @@ arm_prologue_unwind_stop_reason (struct frame_info *this_frame,\n \n   /* This is meant to halt the backtrace at \"_start\".  */\n   pc = get_frame_pc (this_frame);\n-  if (pc <= gdbarch_tdep (get_frame_arch (this_frame))->lowest_pc)\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (arch);\n+  if (pc <= tdep->lowest_pc)\n     return UNWIND_OUTERMOST;\n \n   /* If we've hit a wall, stop.  */\n@@ -3739,15 +3747,18 @@ arm_vfp_call_candidate (struct type *t, enum arm_vfp_cprc_base_type *base_type,\n static int\n arm_vfp_abi_for_function (struct gdbarch *gdbarch, struct type *func_type)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n   /* Variadic functions always use the base ABI.  Assume that functions\n      without debug info are not variadic.  */\n   if (func_type && check_typedef (func_type)->has_varargs ())\n     return 0;\n+\n   /* The VFP ABI is only supported as a variant of AAPCS.  */\n   if (tdep->arm_abi != ARM_ABI_AAPCS)\n     return 0;\n-  return gdbarch_tdep (gdbarch)->fp_model == ARM_FLOAT_VFP;\n+\n+  return tdep->fp_model == ARM_FLOAT_VFP;\n }\n \n /* We currently only support passing parameters in integer registers, which\n@@ -3770,6 +3781,7 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   int use_vfp_abi;\n   struct type *ftype;\n   unsigned vfp_regs_free = (1 << 16) - 1;\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Determine the type of this function and whether the VFP ABI\n      applies.  */\n@@ -3827,7 +3839,7 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       align = (align + ARM_INT_REGISTER_SIZE - 1)\n \t\t& ~(ARM_INT_REGISTER_SIZE - 1);\n       /* Different ABIs have different maximum alignments.  */\n-      if (gdbarch_tdep (gdbarch)->arm_abi == ARM_ABI_APCS)\n+      if (tdep->arm_abi == ARM_ABI_APCS)\n \t{\n \t  /* The APCS ABI only requires word alignment.  */\n \t  align = ARM_INT_REGISTER_SIZE;\n@@ -4041,7 +4053,7 @@ arm_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,\n static struct type *\n arm_ext_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->arm_ext_type)\n     tdep->arm_ext_type\n@@ -4054,7 +4066,7 @@ arm_ext_type (struct gdbarch *gdbarch)\n static struct type *\n arm_neon_double_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->neon_double_type == NULL)\n     {\n@@ -4093,7 +4105,7 @@ arm_neon_double_type (struct gdbarch *gdbarch)\n static struct type *\n arm_neon_quad_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->neon_quad_type == NULL)\n     {\n@@ -4131,7 +4143,7 @@ arm_neon_quad_type (struct gdbarch *gdbarch)\n static bool\n is_q_pseudo (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Q pseudo registers are available for both NEON (Q0~Q15) and\n      MVE (Q0~Q7) features.  */\n@@ -4152,7 +4164,7 @@ is_q_pseudo (struct gdbarch *gdbarch, int regnum)\n static bool\n is_s_pseudo (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->have_s_pseudos\n       && regnum >= tdep->s_pseudo_base\n@@ -4171,7 +4183,7 @@ is_s_pseudo (struct gdbarch *gdbarch, int regnum)\n static bool\n is_mve_pseudo (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->have_mve\n       && regnum >= tdep->mve_pseudo_base\n@@ -4187,7 +4199,7 @@ is_mve_pseudo (struct gdbarch *gdbarch, int regnum)\n static struct type *\n arm_register_type (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (is_s_pseudo (gdbarch, regnum))\n     return builtin_type (gdbarch)->builtin_float;\n@@ -4369,9 +4381,10 @@ arm_adjust_breakpoint_address (struct gdbarch *gdbarch, CORE_ADDR bpaddr)\n   int buf_len;\n   enum bfd_endian order = gdbarch_byte_order_for_code (gdbarch);\n   int i, any, last_it, last_it_count;\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* If we are using BKPT breakpoints, none of this is necessary.  */\n-  if (gdbarch_tdep (gdbarch)->thumb2_breakpoint == NULL)\n+  if (tdep->thumb2_breakpoint == NULL)\n     return bpaddr;\n \n   /* ARM mode does not have this problem.  */\n@@ -7676,7 +7689,7 @@ arm_displaced_init_closure (struct gdbarch *gdbarch, CORE_ADDR from,\n \t\t\t    CORE_ADDR to,\n \t\t\t    arm_displaced_step_copy_insn_closure *dsc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   unsigned int i, len, offset;\n   enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);\n   int size = dsc->is_thumb? 2 : 4;\n@@ -7839,7 +7852,7 @@ static const gdb_byte arm_default_thumb_be_breakpoint[] = THUMB_BE_BREAKPOINT;\n static int\n arm_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);\n \n   if (arm_pc_is_thumb (gdbarch, *pcptr))\n@@ -7874,7 +7887,7 @@ arm_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)\n static const gdb_byte *\n arm_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   switch (kind)\n     {\n@@ -7946,10 +7959,11 @@ arm_extract_return_value (struct type *type, struct regcache *regs,\n {\n   struct gdbarch *gdbarch = regs->arch ();\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (TYPE_CODE_FLT == type->code ())\n     {\n-      switch (gdbarch_tdep (gdbarch)->fp_model)\n+      switch (tdep->fp_model)\n \t{\n \tcase ARM_FLOAT_FPA:\n \t  {\n@@ -8055,7 +8069,8 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n       return (TYPE_LENGTH (type) > 16);\n     }\n \n-  if (gdbarch_tdep (gdbarch)->arm_abi != ARM_ABI_APCS)\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  if (tdep->arm_abi != ARM_ABI_APCS)\n     {\n       /* The AAPCS says all aggregates not larger than a word are returned\n \t in a register.  */\n@@ -8158,8 +8173,9 @@ arm_store_return_value (struct type *type, struct regcache *regs,\n   if (type->code () == TYPE_CODE_FLT)\n     {\n       gdb_byte buf[ARM_FP_REGISTER_SIZE];\n+      arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n-      switch (gdbarch_tdep (gdbarch)->fp_model)\n+      switch (tdep->fp_model)\n \t{\n \tcase ARM_FLOAT_FPA:\n \n@@ -8246,7 +8262,7 @@ arm_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t  struct type *valtype, struct regcache *regcache,\n \t\t  gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct type *func_type = function ? value_type (function) : NULL;\n   enum arm_vfp_cprc_base_type vfp_base_type;\n   int vfp_base_count;\n@@ -8314,7 +8330,7 @@ static int\n arm_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n {\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   CORE_ADDR jb_addr;\n   gdb_byte buf[ARM_INT_REGISTER_SIZE];\n@@ -8503,7 +8519,8 @@ static void\n show_fp_model (struct ui_file *file, int from_tty,\n \t       struct cmd_list_element *c, const char *value)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch ());\n+  arm_gdbarch_tdep *tdep\n+    = (arm_gdbarch_tdep *) gdbarch_tdep (target_gdbarch ());\n \n   if (arm_fp_model == ARM_FLOAT_AUTO\n       && gdbarch_bfd_arch_info (target_gdbarch ())->arch == bfd_arch_arm)\n@@ -8540,7 +8557,8 @@ static void\n arm_show_abi (struct ui_file *file, int from_tty,\n \t     struct cmd_list_element *c, const char *value)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch ());\n+  arm_gdbarch_tdep *tdep\n+    = (arm_gdbarch_tdep *) gdbarch_tdep (target_gdbarch ());\n \n   if (arm_abi_global == ARM_ABI_AUTO\n       && gdbarch_bfd_arch_info (target_gdbarch ())->arch == bfd_arch_arm)\n@@ -8611,7 +8629,7 @@ show_disassembly_style_sfunc (struct ui_file *file, int from_tty,\n static const char *\n arm_register_name (struct gdbarch *gdbarch, int i)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (is_s_pseudo (gdbarch, i))\n     {\n@@ -8778,7 +8796,7 @@ static enum register_status\n arm_mve_pseudo_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \t\t     int regnum, gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* P0 is the first 16 bits of VPR.  */\n   return regcache->raw_read_part (tdep->mve_vpr_regnum, 0, 2, buf);\n@@ -8792,11 +8810,10 @@ arm_pseudo_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n   char name_buf[4];\n   gdb_byte reg_buf[8];\n   int offset, double_regnum;\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   gdb_assert (regnum >= num_regs);\n \n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-\n   if (is_q_pseudo (gdbarch, regnum))\n     {\n       /* Quad-precision register.  */\n@@ -8865,7 +8882,7 @@ static void\n arm_mve_pseudo_write (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t      int regnum, const gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* P0 is the first 16 bits of VPR.  */\n   regcache->raw_write_part (tdep->mve_vpr_regnum, 0, 2, buf);\n@@ -8879,11 +8896,10 @@ arm_pseudo_write (struct gdbarch *gdbarch, struct regcache *regcache,\n   char name_buf[4];\n   gdb_byte reg_buf[8];\n   int offset, double_regnum;\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   gdb_assert (regnum >= num_regs);\n \n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-\n   if (is_q_pseudo (gdbarch, regnum))\n     {\n       /* Quad-precision register.  */\n@@ -8968,7 +8984,9 @@ arm_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n static void\n arm_register_g_packet_guesses (struct gdbarch *gdbarch)\n {\n-  if (gdbarch_tdep (gdbarch)->is_m)\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+  if (tdep->is_m)\n     {\n       const target_desc *tdesc;\n \n@@ -9005,8 +9023,9 @@ arm_register_g_packet_guesses (struct gdbarch *gdbarch)\n static int\n arm_code_of_frame_writable (struct gdbarch *gdbarch, struct frame_info *frame)\n {\n-  if (gdbarch_tdep (gdbarch)->is_m\n-      && get_frame_type (frame) == SIGTRAMP_FRAME)\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+  if (tdep->is_m && get_frame_type (frame) == SIGTRAMP_FRAME)\n     {\n       /* M-profile exception frames return to some magic PCs, where\n \t isn't writable at all.  */\n@@ -9037,7 +9056,6 @@ arm_gnu_triplet_regexp (struct gdbarch *gdbarch)\n static struct gdbarch *\n arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n   struct gdbarch_list *best_arch;\n   enum arm_abi_kind arm_abi = arm_abi_global;\n@@ -9406,12 +9424,13 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        best_arch != NULL;\n        best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))\n     {\n-      if (arm_abi != ARM_ABI_AUTO\n-\t  && arm_abi != gdbarch_tdep (best_arch->gdbarch)->arm_abi)\n+      arm_gdbarch_tdep *tdep\n+\t= (arm_gdbarch_tdep *) gdbarch_tdep (best_arch->gdbarch);\n+\n+      if (arm_abi != ARM_ABI_AUTO && arm_abi != tdep->arm_abi)\n \tcontinue;\n \n-      if (fp_model != ARM_FLOAT_AUTO\n-\t  && fp_model != gdbarch_tdep (best_arch->gdbarch)->fp_model)\n+      if (fp_model != ARM_FLOAT_AUTO && fp_model != tdep->fp_model)\n \tcontinue;\n \n       /* There are various other properties in tdep that we do not\n@@ -9420,7 +9439,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t automatically disqualified.  */\n \n       /* Do check is_m, though, since it might come from the binary.  */\n-      if (is_m != gdbarch_tdep (best_arch->gdbarch)->is_m)\n+      if (is_m != tdep->is_m)\n \tcontinue;\n \n       /* Found a match.  */\n@@ -9430,7 +9449,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   if (best_arch != NULL)\n     return best_arch->gdbarch;\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  arm_gdbarch_tdep *tdep = new arm_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Record additional information about the architecture we are defining.\n@@ -9546,7 +9565,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* This \"info float\" is FPA-specific.  Use the generic version if we\n      do not have FPA.  */\n-  if (gdbarch_tdep (gdbarch)->have_fpa_registers)\n+  if (tdep->have_fpa_registers)\n     set_gdbarch_print_float_info (gdbarch, arm_print_float_info);\n \n   /* Internal <-> external register number maps.  */\n@@ -9692,7 +9711,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n static void\n arm_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep == NULL)\n     return;\n@@ -11868,7 +11887,8 @@ static int\n arm_record_coproc_data_proc (insn_decode_record *arm_insn_r)\n {\n   uint32_t op, op1_ebit, coproc, bits_24_25;\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arm_insn_r->gdbarch);\n+  arm_gdbarch_tdep *tdep\n+    = (arm_gdbarch_tdep *) gdbarch_tdep (arm_insn_r->gdbarch);\n   struct regcache *reg_cache = arm_insn_r->regcache;\n \n   arm_insn_r->opcode = bits (arm_insn_r->arm_insn, 24, 27);\n@@ -12352,9 +12372,10 @@ thumb_record_misc (insn_decode_record *thumb_insn_r)\n /* Handling opcode 110 insns.  */\n \n static int\n-thumb_record_ldm_stm_swi (insn_decode_record *thumb_insn_r)                \n+thumb_record_ldm_stm_swi (insn_decode_record *thumb_insn_r)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (thumb_insn_r->gdbarch);\n+  arm_gdbarch_tdep *tdep\n+    = (arm_gdbarch_tdep *) gdbarch_tdep  (thumb_insn_r->gdbarch);\n   struct regcache *reg_cache = thumb_insn_r->regcache;\n \n   uint32_t ret = 0; /* function return value: -1:record failure ;  0:success  */"
    },
    {
      "sha": "9012b9da1004293e1bf3afdc91068deacf2e8742",
      "filename": "gdb/arm-tdep.h",
      "status": "modified",
      "additions": 33,
      "deletions": 32,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -87,69 +87,70 @@ enum struct_return\n };\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct arm_gdbarch_tdep : gdbarch_tdep\n {\n   /* The ABI for this architecture.  It should never be set to\n      ARM_ABI_AUTO.  */\n-  enum arm_abi_kind arm_abi;\n+  enum arm_abi_kind arm_abi {};\n \n-  enum arm_float_model fp_model; /* Floating point calling conventions.  */\n+  enum arm_float_model fp_model {}; /* Floating point calling conventions.  */\n \n-  bool have_fpa_registers;\t/* Does the target report the FPA registers?  */\n-  bool have_wmmx_registers;\t/* Does the target report the WMMX registers?  */\n+  bool have_fpa_registers = false;\t/* Does the target report the FPA registers?  */\n+  bool have_wmmx_registers = false;\t/* Does the target report the WMMX registers?  */\n   /* The number of VFP registers reported by the target.  It is zero\n      if VFP registers are not supported.  */\n-  int vfp_register_count;\n-  bool have_s_pseudos;\t\t/* Are we synthesizing the single precision\n+  int vfp_register_count = 0;\n+  bool have_s_pseudos = false;\t/* Are we synthesizing the single precision\n \t\t\t\t   VFP registers?  */\n-  int s_pseudo_base;\t\t/* Register number for the first S pseudo\n+  int s_pseudo_base = 0;\t/* Register number for the first S pseudo\n \t\t\t\t   register.  */\n-  int s_pseudo_count;\t\t/* Number of S pseudo registers.  */\n-  bool have_q_pseudos;\t\t/* Are we synthesizing the quad precision\n+  int s_pseudo_count = 0;\t/* Number of S pseudo registers.  */\n+  bool have_q_pseudos = false;\t/* Are we synthesizing the quad precision\n \t\t\t\t   Q (NEON or MVE) registers?  Requires\n \t\t\t\t   have_s_pseudos.  */\n-  int q_pseudo_base;\t\t/* Register number for the first quad\n+  int q_pseudo_base = 0;\t/* Register number for the first quad\n \t\t\t\t   precision pseudo register.  */\n-  int q_pseudo_count;\t\t/* Number of quad precision pseudo\n+  int q_pseudo_count = 0;\t/* Number of quad precision pseudo\n \t\t\t\t   registers.  */\n-  bool have_neon;\t\t/* Do we have a NEON unit?  */\n+  bool have_neon = false;\t/* Do we have a NEON unit?  */\n \n-  bool have_mve;\t\t/* Do we have a MVE extension?  */\n-  int mve_vpr_regnum;\t\t/* MVE VPR register number.  */\n-  int mve_pseudo_base;\t\t/* Number of the first MVE pseudo register.  */\n-  int mve_pseudo_count;\t\t/* Total number of MVE pseudo registers.  */\n+  bool have_mve = false;\t/* Do we have a MVE extension?  */\n+  int mve_vpr_regnum = 0;\t/* MVE VPR register number.  */\n+  int mve_pseudo_base = 0;\t/* Number of the first MVE pseudo register.  */\n+  int mve_pseudo_count = 0;\t/* Total number of MVE pseudo registers.  */\n \n-  bool is_m;\t\t\t/* Does the target follow the \"M\" profile.  */\n-  CORE_ADDR lowest_pc;\t\t/* Lowest address at which instructions \n+  bool is_m = false;\t\t/* Does the target follow the \"M\" profile.  */\n+  CORE_ADDR lowest_pc = 0;\t/* Lowest address at which instructions\n \t\t\t\t   will appear.  */\n \n-  const gdb_byte *arm_breakpoint;\t/* Breakpoint pattern for an ARM insn.  */\n-  int arm_breakpoint_size;\t/* And its size.  */\n-  const gdb_byte *thumb_breakpoint;\t/* Breakpoint pattern for a Thumb insn.  */\n-  int thumb_breakpoint_size;\t/* And its size.  */\n+  const gdb_byte *arm_breakpoint = nullptr;\t/* Breakpoint pattern for an ARM insn.  */\n+  int arm_breakpoint_size = 0;\t/* And its size.  */\n+  const gdb_byte *thumb_breakpoint = nullptr;\t/* Breakpoint pattern for a Thumb insn.  */\n+  int thumb_breakpoint_size = 0;\t/* And its size.  */\n \n   /* If the Thumb breakpoint is an undefined instruction (which is\n      affected by IT blocks) rather than a BKPT instruction (which is\n      not), then we need a 32-bit Thumb breakpoint to preserve the\n      instruction count in IT blocks.  */\n-  const gdb_byte *thumb2_breakpoint;\n-  int thumb2_breakpoint_size;\n+  const gdb_byte *thumb2_breakpoint = nullptr;\n+  int thumb2_breakpoint_size = 0;\n \n-  int jb_pc;\t\t\t/* Offset to PC value in jump buffer.\n+  int jb_pc = 0;\t\t\t/* Offset to PC value in jump buffer.\n \t\t\t\t   If this is negative, longjmp support\n \t\t\t\t   will be disabled.  */\n-  size_t jb_elt_size;\t\t/* And the size of each entry in the buf.  */\n+  size_t jb_elt_size = 0;\t\t/* And the size of each entry in the buf.  */\n \n   /* Convention for returning structures.  */\n-  enum struct_return struct_return;\n+  enum struct_return struct_return {};\n \n   /* ISA-specific data types.  */\n-  struct type *arm_ext_type;\n-  struct type *neon_double_type;\n-  struct type *neon_quad_type;\n+  struct type *arm_ext_type = nullptr;\n+  struct type *neon_double_type = nullptr;\n+  struct type *neon_quad_type = nullptr;\n \n    /* syscall record.  */\n-  int (*arm_syscall_record) (struct regcache *regcache, unsigned long svc_number);\n+  int (*arm_syscall_record) (struct regcache *regcache,\n+\t\t\t     unsigned long svc_number) = nullptr;\n };\n \n /* Structures used for displaced stepping.  */"
    },
    {
      "sha": "46cf83503d9051fda1500577e5be00a904d859ac",
      "filename": "gdb/arm-wince-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-wince-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/arm-wince-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-wince-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -115,7 +115,7 @@ arm_wince_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n static void\n arm_wince_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  arm_gdbarch_tdep *tdep = (arm_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   windows_init_abi (info, gdbarch);\n "
    },
    {
      "sha": "0db19865f312bb7e787e94532779a68b5aeb12a7",
      "filename": "gdb/avr-tdep.c",
      "status": "modified",
      "additions": 21,
      "deletions": 15,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/avr-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/avr-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/avr-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -188,18 +188,18 @@ struct avr_unwind_cache\n   trad_frame_saved_reg *saved_regs;\n };\n \n-struct gdbarch_tdep\n+struct avr_gdbarch_tdep : gdbarch_tdep\n {\n   /* Number of bytes stored to the stack by call instructions.\n      2 bytes for avr1-5 and avrxmega1-5, 3 bytes for avr6 and avrxmega6-7.  */\n-  int call_length;\n+  int call_length = 0;\n \n   /* Type for void.  */\n-  struct type *void_type;\n+  struct type *void_type = nullptr;\n   /* Type for a function returning void.  */\n-  struct type *func_void_type;\n+  struct type *func_void_type = nullptr;\n   /* Type for a pointer to a function.  Used for the type of PC.  */\n-  struct type *pc_type;\n+  struct type *pc_type = nullptr;\n };\n \n /* Lookup the name of a register given it's number.  */\n@@ -230,10 +230,14 @@ avr_register_type (struct gdbarch *gdbarch, int reg_nr)\n {\n   if (reg_nr == AVR_PC_REGNUM)\n     return builtin_type (gdbarch)->builtin_uint32;\n+\n+  avr_gdbarch_tdep *tdep = (avr_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (reg_nr == AVR_PSEUDO_PC_REGNUM)\n-    return gdbarch_tdep (gdbarch)->pc_type;\n+    return tdep->pc_type;\n+\n   if (reg_nr == AVR_SP_REGNUM)\n     return builtin_type (gdbarch)->builtin_data_ptr;\n+\n   return builtin_type (gdbarch)->builtin_uint8;\n }\n \n@@ -745,13 +749,13 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n   gdb_assert (vpc < AVR_MAX_PROLOGUE_SIZE);\n \n   /* Handle static small stack allocation using rcall or push.  */\n-\n+  avr_gdbarch_tdep *tdep = (avr_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   while (scan_stage == 1 && vpc < len)\n     {\n       insn = extract_unsigned_integer (&prologue[vpc], 2, byte_order);\n       if (insn == 0xd000)\t/* rcall .+0 */\n \t{\n-\t  info->size += gdbarch_tdep (gdbarch)->call_length;\n+\t  info->size += tdep->call_length;\n \t  vpc += 2;\n \t}\n       else if (insn == 0x920f || insn == 0x921f)  /* push r0 or push r1 */\n@@ -984,7 +988,6 @@ avr_frame_unwind_cache (struct frame_info *this_frame,\n   ULONGEST this_base;\n   struct avr_unwind_cache *info;\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int i;\n \n   if (*this_prologue_cache)\n@@ -1049,7 +1052,7 @@ avr_frame_unwind_cache (struct frame_info *this_frame,\n \n   /* The previous frame's SP needed to be computed.  Save the computed\n      value.  */\n-  tdep = gdbarch_tdep (gdbarch);\n+  avr_gdbarch_tdep *tdep = (avr_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   info->saved_regs[AVR_SP_REGNUM].set_value (info->prev_sp\n \t\t\t\t\t     - 1 + tdep->call_length);\n \n@@ -1131,7 +1134,7 @@ avr_frame_prev_register (struct frame_info *this_frame,\n \t  int i;\n \t  gdb_byte buf[3];\n \t  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-\t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\t  avr_gdbarch_tdep *tdep = (avr_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n \t  read_memory (info->saved_regs[AVR_PC_REGNUM].addr (),\n \t\t       buf, tdep->call_length);\n@@ -1273,7 +1276,8 @@ avr_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n {\n   int i;\n   gdb_byte buf[3];\n-  int call_length = gdbarch_tdep (gdbarch)->call_length;\n+  avr_gdbarch_tdep *tdep = (avr_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int call_length = tdep->call_length;\n   CORE_ADDR return_pc = avr_convert_iaddr_to_raw (bp_addr);\n   int regnum = AVR_ARGN_REGNUM;\n   struct stack_item *si = NULL;\n@@ -1424,7 +1428,6 @@ static struct gdbarch *\n avr_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch_list *best_arch;\n   int call_length;\n \n@@ -1456,12 +1459,15 @@ avr_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        best_arch != NULL;\n        best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))\n     {\n-      if (gdbarch_tdep (best_arch->gdbarch)->call_length == call_length)\n+      avr_gdbarch_tdep *tdep\n+\t= (avr_gdbarch_tdep *) gdbarch_tdep (best_arch->gdbarch);\n+\n+      if (tdep->call_length == call_length)\n \treturn best_arch->gdbarch;\n     }\n \n   /* None found, create a new architecture from the information provided.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  avr_gdbarch_tdep *tdep = new avr_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   \n   tdep->call_length = call_length;"
    },
    {
      "sha": "355f9f4446580f0fe78a8d94720efc621238fe8d",
      "filename": "gdb/bfin-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/bfin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/bfin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bfin-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -766,7 +766,8 @@ bfin_frame_align (struct gdbarch *gdbarch, CORE_ADDR address)\n enum bfin_abi\n bfin_abi (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->bfin_abi;\n+  bfin_gdbarch_tdep *tdep = (bfin_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->bfin_abi;\n }\n \n /* Initialize the current architecture based on INFO.  If possible,\n@@ -779,7 +780,6 @@ bfin_abi (struct gdbarch *gdbarch)\n static struct gdbarch *\n bfin_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n   enum bfin_abi abi;\n \n@@ -791,12 +791,16 @@ bfin_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      if (gdbarch_tdep (arches->gdbarch)->bfin_abi != abi)\n+      bfin_gdbarch_tdep *tdep\n+\t= (bfin_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n+      if (tdep->bfin_abi != abi)\n \tcontinue;\n+\n       return arches->gdbarch;\n     }\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  bfin_gdbarch_tdep *tdep = new bfin_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   tdep->bfin_abi = abi;"
    },
    {
      "sha": "70a18547e6ba25d6b9b6cd397203495cd86b2b23",
      "filename": "gdb/bfin-tdep.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/bfin-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/bfin-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bfin-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -94,10 +94,10 @@ enum bfin_abi\n };\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct bfin_gdbarch_tdep : gdbarch_tdep\n {\n   /* Which ABI is in use?  */\n-  enum bfin_abi bfin_abi;\n+  enum bfin_abi bfin_abi {};\n };\n \n /* Return the Blackfin ABI associated with GDBARCH.  */"
    },
    {
      "sha": "b2cd913d9e1b631efb13b89d7198af3169d40e77",
      "filename": "gdb/bpf-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/bpf-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/bpf-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bpf-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -57,7 +57,7 @@ enum bpf_regnum\n #define BPF_NUM_REGS\t(BPF_PC_REGNUM + 1)\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct bpf_gdbarch_tdep : gdbarch_tdep\n {\n };\n \n@@ -321,7 +321,7 @@ bpf_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     return arches->gdbarch;\n \n   /* Allocate space for the new architecture.  */\n-  struct gdbarch_tdep *tdep = XCNEW (struct gdbarch_tdep);\n+  bpf_gdbarch_tdep *tdep = new bpf_gdbarch_tdep;\n   struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Information about registers, etc.  */"
    },
    {
      "sha": "e7dbded1f5e9b3d14b2e93f034aaf2ff2317bf3c",
      "filename": "gdb/cris-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/cris-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/cris-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -33,7 +33,7 @@\n static void\n cris_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 0);\n "
    },
    {
      "sha": "691cad82c9d749f9c6b8f40db2b6f8ebf7b9ad4f",
      "filename": "gdb/cris-tdep.c",
      "status": "modified",
      "additions": 15,
      "deletions": 16,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/cris-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/cris-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -313,7 +313,7 @@ cris_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n \t\t\t\t  void **this_cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct cris_unwind_cache *info;\n   CORE_ADDR addr;\n@@ -450,7 +450,7 @@ static int\n crisv32_single_step_through_delay (struct gdbarch *gdbarch,\n \t\t\t\t   struct frame_info *this_frame)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   ULONGEST erp;\n   int ret = 0;\n \n@@ -695,7 +695,7 @@ cris_frame_unwind_cache (struct frame_info *this_frame,\n \t\t\t void **this_prologue_cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct cris_unwind_cache *info;\n \n   if ((*this_prologue_cache))\n@@ -1333,7 +1333,7 @@ crisv32_scan_prologue (CORE_ADDR pc, struct frame_info *this_frame,\n static CORE_ADDR\n cris_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   CORE_ADDR func_addr, func_end;\n   struct symtab_and_line sal;\n   CORE_ADDR pc_after_prologue;\n@@ -1368,7 +1368,7 @@ cris_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)\n static const gdb_byte *\n cris_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   static unsigned char break8_insn[] = {0x38, 0xe9};\n   static unsigned char break15_insn[] = {0x3f, 0xe9};\n \n@@ -1387,7 +1387,7 @@ static int\n cris_spec_reg_applicable (struct gdbarch *gdbarch,\n \t\t\t  struct cris_spec_reg spec_reg)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   unsigned int version = tdep->cris_version;\n   \n   switch (spec_reg.applicable_version)\n@@ -3766,7 +3766,7 @@ cris_supply_gregset (const struct regset *regset, struct regcache *regcache,\n \t\t     int regnum, const void *gregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int i;\n   const cris_elf_greg_t *regp = static_cast<const cris_elf_greg_t *>(gregs);\n \n@@ -3860,7 +3860,7 @@ Makes GDB use the NRP register instead of the ERP register in certain cases.\"),\n static void\n cris_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  cris_gdbarch_tdep *tdep = (cris_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (tdep != NULL)\n     {\n       fprintf_unfiltered (file, \"cris_dump_tdep: tdep->cris_version = %i\\n\",\n@@ -3914,7 +3914,6 @@ static struct gdbarch *\n cris_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   unsigned int cris_version;\n \n   if (usr_cmd_cris_version_valid)\n@@ -3940,17 +3939,17 @@ cris_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      if ((gdbarch_tdep (arches->gdbarch)->cris_version \n-\t   == usr_cmd_cris_version)\n-\t  && (gdbarch_tdep (arches->gdbarch)->cris_mode \n-\t   == usr_cmd_cris_mode)\n-\t  && (gdbarch_tdep (arches->gdbarch)->cris_dwarf2_cfi \n-\t      == usr_cmd_cris_dwarf2_cfi))\n+      cris_gdbarch_tdep *tdep\n+\t= (cris_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n+      if (tdep->cris_version == usr_cmd_cris_version\n+\t  && tdep->cris_mode == usr_cmd_cris_mode\n+\t  && tdep->cris_dwarf2_cfi == usr_cmd_cris_dwarf2_cfi)\n \treturn arches->gdbarch;\n     }\n \n   /* No matching architecture was found.  Create a new one.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  cris_gdbarch_tdep *tdep = new cris_gdbarch_tdep;\n   info.byte_order = BFD_ENDIAN_LITTLE;\n   gdbarch = gdbarch_alloc (&info, tdep);\n "
    },
    {
      "sha": "9b622942839f53f6f22149bbf5725a8ea95ccf43",
      "filename": "gdb/cris-tdep.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/cris-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/cris-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -24,11 +24,11 @@\n #define CRIS_TDEP_H\n \n /* CRIS architecture specific information.  */\n-struct gdbarch_tdep\n+struct cris_gdbarch_tdep : gdbarch_tdep\n {\n-  unsigned int cris_version;\n-  const char *cris_mode;\n-  int cris_dwarf2_cfi;\n+  unsigned int cris_version = 0;\n+  const char *cris_mode = nullptr;\n+  int cris_dwarf2_cfi = 0;\n };\n \n #endif /* CRIS_TDEP_H */"
    },
    {
      "sha": "0b073fb6f629a325bc520304c9e6384c56881701",
      "filename": "gdb/csky-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/csky-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/csky-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/csky-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -2164,7 +2164,6 @@ static struct gdbarch *\n csky_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n \n   /* Find a candidate among the list of pre-declared architectures.  */\n   arches = gdbarch_list_lookup_by_info (arches, &info);\n@@ -2173,7 +2172,7 @@ csky_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* None found, create a new architecture from the information\n      provided.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  csky_gdbarch_tdep *tdep = new csky_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Target data types.  */"
    },
    {
      "sha": "d690e8f519177ded7d4aa45cc41d6efb7ecc83f7",
      "filename": "gdb/csky-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/csky-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/csky-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/csky-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -29,7 +29,7 @@ enum lr_type_t\n };\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct csky_gdbarch_tdep : gdbarch_tdep\n {\n   /* This is Unused.  */\n };"
    },
    {
      "sha": "c74ea68fe847483edb211b347f98b12cb5fb0fe4",
      "filename": "gdb/frv-tdep.c",
      "status": "modified",
      "additions": 19,
      "deletions": 18,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/frv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/frv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frv-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -67,32 +67,33 @@ struct frv_unwind_cache\t\t/* was struct frame_extra_info */\n    of structures, each of which gives all the necessary info for one\n    register.  Don't stick parallel arrays in here --- that's so\n    Fortran.  */\n-struct gdbarch_tdep\n+struct frv_gdbarch_tdep : gdbarch_tdep\n {\n   /* Which ABI is in use?  */\n-  enum frv_abi frv_abi;\n+  enum frv_abi frv_abi {};\n \n   /* How many general-purpose registers does this variant have?  */\n-  int num_gprs;\n+  int num_gprs = 0;\n \n   /* How many floating-point registers does this variant have?  */\n-  int num_fprs;\n+  int num_fprs = 0;\n \n   /* How many hardware watchpoints can it support?  */\n-  int num_hw_watchpoints;\n+  int num_hw_watchpoints = 0;\n \n   /* How many hardware breakpoints can it support?  */\n-  int num_hw_breakpoints;\n+  int num_hw_breakpoints = 0;\n \n   /* Register names.  */\n-  const char **register_names;\n+  const char **register_names = nullptr;\n };\n \n /* Return the FR-V ABI associated with GDBARCH.  */\n enum frv_abi\n frv_abi (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->frv_abi;\n+  frv_gdbarch_tdep *tdep = (frv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->frv_abi;\n }\n \n /* Fetch the interpreter and executable loadmap addresses (for shared\n@@ -128,13 +129,12 @@ frv_fdpic_loadmap_addresses (struct gdbarch *gdbarch, CORE_ADDR *interp_addr,\n \n /* Allocate a new variant structure, and set up default values for all\n    the fields.  */\n-static struct gdbarch_tdep *\n+static frv_gdbarch_tdep *\n new_variant (void)\n {\n-  struct gdbarch_tdep *var;\n   int r;\n \n-  var = XCNEW (struct gdbarch_tdep);\n+  frv_gdbarch_tdep *var = new frv_gdbarch_tdep;\n \n   var->frv_abi = FRV_ABI_EABI;\n   var->num_gprs = 64;\n@@ -219,7 +219,7 @@ new_variant (void)\n /* Indicate that the variant VAR has NUM_GPRS general-purpose\n    registers, and fill in the names array appropriately.  */\n static void\n-set_variant_num_gprs (struct gdbarch_tdep *var, int num_gprs)\n+set_variant_num_gprs (frv_gdbarch_tdep *var, int num_gprs)\n {\n   int r;\n \n@@ -238,7 +238,7 @@ set_variant_num_gprs (struct gdbarch_tdep *var, int num_gprs)\n /* Indicate that the variant VAR has NUM_FPRS floating-point\n    registers, and fill in the names array appropriately.  */\n static void\n-set_variant_num_fprs (struct gdbarch_tdep *var, int num_fprs)\n+set_variant_num_fprs (frv_gdbarch_tdep *var, int num_fprs)\n {\n   int r;\n \n@@ -254,7 +254,7 @@ set_variant_num_fprs (struct gdbarch_tdep *var, int num_fprs)\n }\n \n static void\n-set_variant_abi_fdpic (struct gdbarch_tdep *var)\n+set_variant_abi_fdpic (frv_gdbarch_tdep *var)\n {\n   var->frv_abi = FRV_ABI_FDPIC;\n   var->register_names[fdpic_loadmap_exec_regnum] = xstrdup (\"loadmap_exec\");\n@@ -263,7 +263,7 @@ set_variant_abi_fdpic (struct gdbarch_tdep *var)\n }\n \n static void\n-set_variant_scratch_registers (struct gdbarch_tdep *var)\n+set_variant_scratch_registers (frv_gdbarch_tdep *var)\n {\n   var->register_names[scr0_regnum] = xstrdup (\"scr0\");\n   var->register_names[scr1_regnum] = xstrdup (\"scr1\");\n@@ -276,10 +276,12 @@ frv_register_name (struct gdbarch *gdbarch, int reg)\n {\n   if (reg < 0)\n     return \"?toosmall?\";\n+\n   if (reg >= frv_num_regs + frv_num_pseudo_regs)\n     return \"?toolarge?\";\n \n-  return gdbarch_tdep (gdbarch)->register_names[reg];\n+  frv_gdbarch_tdep *tdep = (frv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->register_names[reg];\n }\n \n \n@@ -1439,7 +1441,6 @@ static struct gdbarch *\n frv_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *var;\n   int elf_flags = 0;\n \n   /* Check to see if we've already built an appropriate architecture\n@@ -1449,7 +1450,7 @@ frv_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     return arches->gdbarch;\n \n   /* Select the right tdep structure for this variant.  */\n-  var = new_variant ();\n+  frv_gdbarch_tdep *var = new_variant ();\n   switch (info.bfd_arch_info->mach)\n     {\n     case bfd_mach_frv:"
    },
    {
      "sha": "eec800cf68d9bc4449ede4aa98a2487879abbbe6",
      "filename": "gdb/ft32-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ft32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ft32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ft32-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -109,7 +109,10 @@ static struct type *\n ft32_register_type (struct gdbarch *gdbarch, int reg_nr)\n {\n   if (reg_nr == FT32_PC_REGNUM)\n-    return gdbarch_tdep (gdbarch)->pc_type;\n+    {\n+      ft32_gdbarch_tdep *tdep = (ft32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+      return tdep->pc_type;\n+    }\n   else if (reg_nr == FT32_SP_REGNUM || reg_nr == FT32_FP_REGNUM)\n     return builtin_type (gdbarch)->builtin_data_ptr;\n   else\n@@ -559,7 +562,6 @@ static struct gdbarch *\n ft32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   struct type *void_type;\n   struct type *func_void_type;\n \n@@ -569,7 +571,7 @@ ft32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     return arches->gdbarch;\n \n   /* Allocate space for the new architecture.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  ft32_gdbarch_tdep *tdep = new ft32_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Create a type for PC.  We can't use builtin types here, as they may not"
    },
    {
      "sha": "c32f646a4a0f891e0dd92e8be456f2d1b1728bf9",
      "filename": "gdb/ft32-tdep.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ft32-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ft32-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ft32-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,10 +20,10 @@\n #ifndef FT32_TDEP_H\n #define FT32_TDEP_H\n \n-struct gdbarch_tdep\n+struct ft32_gdbarch_tdep : gdbarch_tdep\n {\n   /* Type for a pointer to a function.  Used for the type of PC.  */\n-  struct type *pc_type;\n+  struct type *pc_type = nullptr;\n };\n \n #endif /* FT32_TDEP_H */"
    },
    {
      "sha": "f73d5624633187124f8b999868da1ac866dc467f",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -62,6 +62,8 @@ struct inferior;\n \n #include \"regcache.h\"\n \n+struct gdbarch_tdep {};\n+\n /* The architecture associated with the inferior through the\n    connection to the target.\n "
    },
    {
      "sha": "829f24192ae0aee2792c76fc82518a42ae3e7a5a",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -1333,6 +1333,8 @@ struct inferior;\n \n #include \"regcache.h\"\n \n+struct gdbarch_tdep {};\n+\n /* The architecture associated with the inferior through the\n    connection to the target.\n "
    },
    {
      "sha": "f4567b48f8263d9d926cdf7a14f98bb6ace68437",
      "filename": "gdb/hppa-bsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/hppa-bsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/hppa-bsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-bsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -118,7 +118,7 @@ hppabsd_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,\n void\n hppabsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* OpenBSD and NetBSD have a 64-bit 'long double'.  */\n   set_gdbarch_long_double_bit (gdbarch, 64);"
    },
    {
      "sha": "1dd6993ab09bc0ead35c520982c3b9321d4106c2",
      "filename": "gdb/hppa-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/hppa-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/hppa-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -476,7 +476,7 @@ hppa_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t\t void *cb_data,\n \t\t\t\t\t const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", 80 * tdep->bytes_per_address, 80 * tdep->bytes_per_address,\n       &hppa_linux_regset, NULL, cb_data);\n@@ -486,7 +486,7 @@ hppa_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n static void\n hppa_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 0);\n "
    },
    {
      "sha": "d64f9f7d937a71573eaa1acfc91ea94eb7fd9f7c",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 12,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -259,6 +259,7 @@ internalize_unwinds (struct objfile *objfile, struct unwind_table_entry *table,\n   if (size > 0)\n     {\n       struct gdbarch *gdbarch = objfile->arch ();\n+      hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n       unsigned long tmp;\n       unsigned i;\n       char *buf = (char *) alloca (size);\n@@ -270,7 +271,7 @@ internalize_unwinds (struct objfile *objfile, struct unwind_table_entry *table,\n \t Note that when loading a shared library (text_offset != 0) the\n \t unwinds are already relative to the text_offset that will be\n \t passed in.  */\n-      if (gdbarch_tdep (gdbarch)->is_elf && text_offset == 0)\n+      if (tdep->is_elf && text_offset == 0)\n \t{\n \t  low_text_segment_address = -1;\n \n@@ -280,9 +281,9 @@ internalize_unwinds (struct objfile *objfile, struct unwind_table_entry *table,\n \n \t  text_offset = low_text_segment_address;\n \t}\n-      else if (gdbarch_tdep (gdbarch)->solib_get_text_base)\n+      else if (tdep->solib_get_text_base)\n \t{\n-\t  text_offset = gdbarch_tdep (gdbarch)->solib_get_text_base (objfile);\n+\t  text_offset = tdep->solib_get_text_base (objfile);\n \t}\n \n       bfd_get_section_contents (objfile->obfd, section, buf, 0, size);\n@@ -730,7 +731,7 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   /* Global pointer (r19) of the function we are trying to call.  */\n   CORE_ADDR gp;\n \n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   for (write_pass = 0; write_pass < 2; write_pass++)\n     {\n@@ -967,7 +968,7 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\tfunction_call_return_method return_method,\n \t\t\tCORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int i, offset = 0;\n   CORE_ADDR gp;\n@@ -2253,9 +2254,7 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n   }\n \n   {\n-    struct gdbarch_tdep *tdep;\n-\n-    tdep = gdbarch_tdep (gdbarch);\n+    hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n     if (tdep->unwind_adjust_stub)\n       tdep->unwind_adjust_stub (this_frame, cache->base, cache->saved_regs);\n@@ -2485,7 +2484,7 @@ hppa_stub_unwind_sniffer (const struct frame_unwind *self,\n {\n   CORE_ADDR pc = get_frame_address_in_block (this_frame);\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (pc == 0\n       || (tdep->in_solib_call_trampoline != NULL\n@@ -3029,7 +3028,6 @@ hppa_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)\n static struct gdbarch *\n hppa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n \n   /* find a candidate among the list of pre-declared architectures.  */\n@@ -3038,7 +3036,7 @@ hppa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     return (arches->gdbarch);\n \n   /* If none found, then allocate and initialize one.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  hppa_gdbarch_tdep *tdep = new hppa_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Determine from the bfd_arch_info structure if we are dealing with\n@@ -3162,7 +3160,7 @@ hppa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n static void\n hppa_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  hppa_gdbarch_tdep *tdep = (hppa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   fprintf_unfiltered (file, \"bytes_per_address = %d\\n\", \n \t\t      tdep->bytes_per_address);"
    },
    {
      "sha": "72988813b2c3b38789946c87fd5a777ba7163f66",
      "filename": "gdb/hppa-tdep.h",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/hppa-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/hppa-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,6 +20,8 @@\n #ifndef HPPA_TDEP_H\n #define HPPA_TDEP_H\n \n+#include \"gdbarch.h\"\n+\n struct trad_frame_saved_reg;\n struct objfile;\n struct so_list;\n@@ -82,39 +84,40 @@ enum hppa_regnum\n #define HPPA_INSN_SIZE 4\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct hppa_gdbarch_tdep : gdbarch_tdep\n {\n   /* The number of bytes in an address.  For now, this field is designed\n      to allow us to differentiate hppa32 from hppa64 targets.  */\n-  int bytes_per_address;\n+  int bytes_per_address = 0;\n \n   /* Is this an ELF target? This can be 64-bit HP-UX, or a 32/64-bit GNU/Linux\n      system.  */\n-  int is_elf;\n+  int is_elf = 0;\n \n   /* Given a function address, try to find the global pointer for the \n      corresponding shared object.  */\n-  CORE_ADDR (*find_global_pointer) (struct gdbarch *, struct value *);\n+  CORE_ADDR (*find_global_pointer) (struct gdbarch *, struct value *) = nullptr;\n \n   /* For shared libraries, each call goes through a small piece of\n      trampoline code in the \".plt\" section.  IN_SOLIB_CALL_TRAMPOLINE\n      evaluates to nonzero if we are currently stopped in one of these.  */\n-  int (*in_solib_call_trampoline) (struct gdbarch *gdbarch, CORE_ADDR pc);\n+  int (*in_solib_call_trampoline) (struct gdbarch *gdbarch,\n+\t\t\t\t   CORE_ADDR pc) = nullptr;\n \n   /* For targets that support multiple spaces, we may have additional stubs\n      in the return path.  These stubs are internal to the ABI, and users are\n      not interested in them.  If we detect that we are returning to a stub,\n      adjust the pc to the real caller.  This improves the behavior of commands\n      that traverse frames such as \"up\" and \"finish\".  */\n   void (*unwind_adjust_stub) (struct frame_info *this_frame, CORE_ADDR base,\n-\t\t\t      trad_frame_saved_reg *saved_regs);\n+\t\t\t      trad_frame_saved_reg *saved_regs) = nullptr;\n \n   /* These are solib-dependent methods.  They are really HPUX only, but\n      we don't have a HPUX-specific tdep vector at the moment.  */\n-  CORE_ADDR (*solib_thread_start_addr) (struct so_list *so);\n-  CORE_ADDR (*solib_get_got_by_pc) (CORE_ADDR addr);\n-  CORE_ADDR (*solib_get_solib_by_pc) (CORE_ADDR addr);\n-  CORE_ADDR (*solib_get_text_base) (struct objfile *objfile);\n+  CORE_ADDR (*solib_thread_start_addr) (struct so_list *so) = nullptr;\n+  CORE_ADDR (*solib_get_got_by_pc) (CORE_ADDR addr) = nullptr;\n+  CORE_ADDR (*solib_get_solib_by_pc) (CORE_ADDR addr) = nullptr;\n+  CORE_ADDR (*solib_get_text_base) (struct objfile *objfile) = nullptr;\n };\n \n /*"
    },
    {
      "sha": "7bddc7a32bc6f9dd2c06adf6e7497e5c966590db",
      "filename": "gdb/i386-bsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-bsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-bsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-bsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -74,7 +74,7 @@ int i386bsd_sc_reg_offset[] =\n void\n i386bsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->jb_pc_offset = 0;\n "
    },
    {
      "sha": "900a0a6bf9613adc5eb28f34e4f3e1c7d0dba715",
      "filename": "gdb/i386-darwin-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-darwin-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -156,7 +156,7 @@ i386_darwin_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t     function_call_return_method return_method,\n \t\t\t     CORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   gdb_byte buf[4];\n   int i;\n@@ -248,7 +248,7 @@ i386_darwin_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n static void\n i386_darwin_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* We support the SSE registers.  */\n   tdep->num_xmm_regs = I386_NUM_XREGS - 1;"
    },
    {
      "sha": "01db76f57ab5e40aa3106a9225c238ffa0f4266f",
      "filename": "gdb/i386-fbsd-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-fbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -308,7 +308,7 @@ i386fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t       void *cb_data,\n \t\t\t\t       const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", tdep->sizeof_gregset, tdep->sizeof_gregset, &i386_gregset, NULL,\n       cb_data);\n@@ -327,7 +327,7 @@ static CORE_ADDR\n i386fbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n \t\t\t\t   CORE_ADDR lm_addr, CORE_ADDR offset)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct regcache *regcache;\n \n   if (tdep->fsbase_regnum == -1)\n@@ -349,7 +349,7 @@ i386fbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n static void\n i386fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Obviously FreeBSD is BSD-based.  */\n   i386bsd_init_abi (info, gdbarch);\n@@ -418,7 +418,7 @@ int i386fbsd4_sc_reg_offset[] =\n static void\n i386fbsd4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Generic FreeBSD support. */\n   fbsd_init_abi (info, gdbarch);"
    },
    {
      "sha": "1f5e5f75012748d9b7230eb82dc3c0aded5e5628",
      "filename": "gdb/i386-gnu-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-gnu-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-gnu-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-gnu-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -173,7 +173,7 @@ static int i386gnu_gregset_reg_offset[] =\n static void\n i386gnu_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* GNU uses ELF.  */\n   i386_elf_init_abi (info, gdbarch);"
    },
    {
      "sha": "31aef4238187fc77145cfc38c0159e823d3cefd9",
      "filename": "gdb/i386-go32-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-go32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-go32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-go32-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -26,7 +26,7 @@\n static void\n i386_go32_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* DJGPP doesn't have any special frames for signal handlers.  */\n   tdep->sigtramp_p = NULL;"
    },
    {
      "sha": "898b73f632c464895c90d5e09e65d5a2eb6889b3",
      "filename": "gdb/i386-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -762,7 +762,7 @@ i386_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t\t void *cb_data,\n \t\t\t\t\t const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", 68, 68, &i386_gregset, NULL, cb_data);\n \n@@ -824,7 +824,7 @@ i386_linux_displaced_step_copy_insn (struct gdbarch *gdbarch,\n static void\n i386_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const struct target_desc *tdesc = info.target_desc;\n   struct tdesc_arch_data *tdesc_data = info.tdesc_data;\n   const struct tdesc_feature *feature;"
    },
    {
      "sha": "9915921ad5468eb3f1a865379d97c6e154d81e6d",
      "filename": "gdb/i386-netbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-netbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -372,7 +372,7 @@ i386nbsd_sigtramp_cache_init (const struct tramp_frame *self,\n static void \n i386nbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Obviously NetBSD is BSD-based.  */\n   i386bsd_init_abi (info, gdbarch);\n@@ -407,7 +407,7 @@ i386nbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n static void\n i386nbsdelf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* It's still NetBSD.  */\n   i386nbsd_init_abi (info, gdbarch);"
    },
    {
      "sha": "4d443e667ff2d7ebea177ace4bd654365fc5da12",
      "filename": "gdb/i386-nto-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-nto-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-nto-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-nto-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -77,7 +77,7 @@ static void\n i386nto_supply_gregset (struct regcache *regcache, char *gpregs)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   gdb_assert (tdep->gregset_reg_offset == i386nto_gregset_reg_offset);\n   i386_gregset.supply_regset (&i386_gregset, regcache, -1,\n@@ -126,7 +126,7 @@ static int\n i386nto_register_area (struct gdbarch *gdbarch,\n \t\t       int regno, int regset, unsigned *off)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   *off = 0;\n   if (regset == NTO_REG_GENERAL)\n@@ -315,7 +315,7 @@ init_i386nto_ops (void)\n static void\n i386nto_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   static struct target_so_ops nto_svr4_so_ops;\n \n   /* Deal with our strange signals.  */"
    },
    {
      "sha": "ad0a7c8e9deb90239fb0d158633fe37abb3f7d14",
      "filename": "gdb/i386-obsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-obsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -407,7 +407,7 @@ static const struct frame_unwind i386obsd_trapframe_unwind = {\n static void \n i386obsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Obviously OpenBSD is BSD-based.  */\n   i386bsd_init_abi (info, gdbarch);"
    },
    {
      "sha": "e06ef36ef99f2f5335dab59c7a0e5147b14061d1",
      "filename": "gdb/i386-sol2-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-sol2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-sol2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-sol2-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -65,7 +65,7 @@ i386_sol2_mcontext_addr (struct frame_info *this_frame)\n static void\n i386_sol2_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Solaris is SVR4-based.  */\n   i386_svr4_init_abi (info, gdbarch);"
    },
    {
      "sha": "ce18cf3e9be3274073a94e58656b5f2a7dcb280d",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 57,
      "deletions": 54,
      "changes": 111,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -167,7 +167,7 @@ const int num_lower_zmm_regs = 16;\n static int\n i386_mmx_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int mm0_regnum = tdep->mm0_regnum;\n \n   if (mm0_regnum < 0)\n@@ -182,7 +182,7 @@ i386_mmx_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_byte_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   regnum -= tdep->al_regnum;\n   return regnum >= 0 && regnum < tdep->num_byte_regs;\n@@ -193,7 +193,7 @@ i386_byte_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_word_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   regnum -= tdep->ax_regnum;\n   return regnum >= 0 && regnum < tdep->num_word_regs;\n@@ -204,7 +204,7 @@ i386_word_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_dword_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int eax_regnum = tdep->eax_regnum;\n \n   if (eax_regnum < 0)\n@@ -219,7 +219,7 @@ i386_dword_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_zmmh_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int zmm0h_regnum = tdep->zmm0h_regnum;\n \n   if (zmm0h_regnum < 0)\n@@ -232,7 +232,7 @@ i386_zmmh_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_zmm_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int zmm0_regnum = tdep->zmm0_regnum;\n \n   if (zmm0_regnum < 0)\n@@ -245,7 +245,7 @@ i386_zmm_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_k_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int k0_regnum = tdep->k0_regnum;\n \n   if (k0_regnum < 0)\n@@ -258,7 +258,7 @@ i386_k_regnum_p (struct gdbarch *gdbarch, int regnum)\n static int\n i386_ymmh_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ymm0h_regnum = tdep->ymm0h_regnum;\n \n   if (ymm0h_regnum < 0)\n@@ -273,7 +273,7 @@ i386_ymmh_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_ymm_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ymm0_regnum = tdep->ymm0_regnum;\n \n   if (ymm0_regnum < 0)\n@@ -286,7 +286,7 @@ i386_ymm_regnum_p (struct gdbarch *gdbarch, int regnum)\n static int\n i386_ymmh_avx512_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ymm16h_regnum = tdep->ymm16h_regnum;\n \n   if (ymm16h_regnum < 0)\n@@ -299,7 +299,7 @@ i386_ymmh_avx512_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_ymm_avx512_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ymm16_regnum = tdep->ymm16_regnum;\n \n   if (ymm16_regnum < 0)\n@@ -314,7 +314,7 @@ i386_ymm_avx512_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_bnd_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int bnd0_regnum = tdep->bnd0_regnum;\n \n   if (bnd0_regnum < 0)\n@@ -329,7 +329,7 @@ i386_bnd_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_xmm_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int num_xmm_regs = I387_NUM_XMM_REGS (tdep);\n \n   if (num_xmm_regs == 0)\n@@ -344,7 +344,7 @@ i386_xmm_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_xmm_avx512_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int num_xmm_avx512_regs = I387_NUM_XMM_AVX512_REGS (tdep);\n \n   if (num_xmm_avx512_regs == 0)\n@@ -357,7 +357,7 @@ i386_xmm_avx512_regnum_p (struct gdbarch *gdbarch, int regnum)\n static int\n i386_mxcsr_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (I387_NUM_XMM_REGS (tdep) == 0)\n     return 0;\n@@ -370,7 +370,7 @@ i386_mxcsr_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_fp_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (I387_ST0_REGNUM (tdep) < 0)\n     return 0;\n@@ -382,7 +382,7 @@ i386_fp_regnum_p (struct gdbarch *gdbarch, int regnum)\n int\n i386_fpc_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (I387_ST0_REGNUM (tdep) < 0)\n     return 0;\n@@ -396,7 +396,7 @@ i386_fpc_regnum_p (struct gdbarch *gdbarch, int regnum)\n static int\n i386_bndr_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n    if (I387_BND0R_REGNUM (tdep) < 0)\n      return 0;\n@@ -410,7 +410,7 @@ i386_bndr_regnum_p (struct gdbarch *gdbarch, int regnum)\n static int\n i386_mpx_ctrl_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n    if (I387_BNDCFGU_REGNUM (tdep) < 0)\n      return 0;\n@@ -424,7 +424,7 @@ i386_mpx_ctrl_regnum_p (struct gdbarch *gdbarch, int regnum)\n bool\n i386_pkru_regnum_p (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int pkru_regnum = tdep->pkru_regnum;\n \n   if (pkru_regnum < 0)\n@@ -460,7 +460,7 @@ i386_register_name (struct gdbarch *gdbarch, int regnum)\n const char *\n i386_pseudo_register_name (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (i386_bnd_regnum_p (gdbarch, regnum))\n     return i386_bnd_names[regnum - tdep->bnd0_regnum];\n   if (i386_mmx_regnum_p (gdbarch, regnum))\n@@ -483,7 +483,7 @@ i386_pseudo_register_name (struct gdbarch *gdbarch, int regnum)\n static int\n i386_dbx_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* This implements what GCC calls the \"default\" register map\n      (dbx_register_map[]).  */\n@@ -530,7 +530,7 @@ i386_dbx_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n static int\n i386_svr4_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* This implements the GCC register map that tries to be compatible\n      with the SVR4 C compiler for DWARF (svr4_dbx_register_map[]).  */\n@@ -2432,7 +2432,7 @@ static struct i386_frame_cache *\n i386_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct i386_frame_cache *cache;\n   CORE_ADDR addr;\n@@ -2521,7 +2521,8 @@ i386_sigtramp_frame_sniffer (const struct frame_unwind *self,\n \t\t\t     struct frame_info *this_frame,\n \t\t\t     void **this_prologue_cache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   /* We shouldn't even bother if we don't have a sigcontext_addr\n      handler.  */\n@@ -2608,7 +2609,8 @@ i386_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n   CORE_ADDR sp, jb_addr;\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  int jb_pc_offset = gdbarch_tdep (gdbarch)->jb_pc_offset;\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int jb_pc_offset = tdep->jb_pc_offset;\n \n   /* If JB_PC_OFFSET is -1, we have no way to find out where the\n      longjmp will land.  */\n@@ -2815,7 +2817,7 @@ static void\n i386_extract_return_value (struct gdbarch *gdbarch, struct type *type,\n \t\t\t   struct regcache *regcache, gdb_byte *valbuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int len = TYPE_LENGTH (type);\n   gdb_byte buf[I386_MAX_REGISTER_SIZE];\n \n@@ -2873,7 +2875,7 @@ static void\n i386_store_return_value (struct gdbarch *gdbarch, struct type *type,\n \t\t\t struct regcache *regcache, const gdb_byte *valbuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int len = TYPE_LENGTH (type);\n \n   if (type->code () == TYPE_CODE_FLT)\n@@ -2952,7 +2954,7 @@ static const char *struct_convention = default_struct_convention;\n static int\n i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum type_code code = type->code ();\n   int len = TYPE_LENGTH (type);\n \n@@ -3054,7 +3056,7 @@ i386_return_value (struct gdbarch *gdbarch, struct value *function,\n struct type *\n i387_ext_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->i387_ext_type)\n     {\n@@ -3072,7 +3074,7 @@ i387_ext_type (struct gdbarch *gdbarch)\n static struct type *\n i386_bnd_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n \n   if (!tdep->i386_bnd_type)\n@@ -3108,7 +3110,7 @@ i386_bnd_type (struct gdbarch *gdbarch)\n static struct type *\n i386_zmm_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->i386_zmm_type)\n     {\n@@ -3167,7 +3169,7 @@ i386_zmm_type (struct gdbarch *gdbarch)\n static struct type *\n i386_ymm_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->i386_ymm_type)\n     {\n@@ -3224,7 +3226,7 @@ i386_ymm_type (struct gdbarch *gdbarch)\n static struct type *\n i386_mmx_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->i386_mmx_type)\n     {\n@@ -3300,7 +3302,8 @@ i386_pseudo_register_type (struct gdbarch *gdbarch, int regnum)\n static int\n i386_mmx_regnum_to_fp_regnum (readable_regcache *regcache, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (regcache->arch ());\n+  gdbarch *arch = regcache->arch ();\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (arch);\n   int mmxreg, fpreg;\n   ULONGEST fstat;\n   int tos;\n@@ -3341,7 +3344,7 @@ i386_pseudo_register_read_into_value (struct gdbarch *gdbarch,\n     }\n   else\n     {\n-      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n       if (i386_bnd_regnum_p (gdbarch, regnum))\n \t{\n \t  regnum -= tdep->bnd0_regnum;\n@@ -3531,7 +3534,7 @@ i386_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n     }\n   else\n     {\n-      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n       if (i386_bnd_regnum_p (gdbarch, regnum))\n \t{\n@@ -3639,7 +3642,7 @@ int\n i386_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n \t\t\t\t struct agent_expr *ax, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (i386_mmx_regnum_p (gdbarch, regnum))\n     {\n@@ -3856,7 +3859,7 @@ i386_supply_gregset (const struct regset *regset, struct regcache *regcache,\n \t\t     int regnum, const void *gregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const gdb_byte *regs = (const gdb_byte *) gregs;\n   int i;\n \n@@ -3881,7 +3884,7 @@ i386_collect_gregset (const struct regset *regset,\n \t\t      int regnum, void *gregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_byte *regs = (gdb_byte *) gregs;\n   int i;\n \n@@ -3904,7 +3907,7 @@ i386_supply_fpregset (const struct regset *regset, struct regcache *regcache,\n \t\t      int regnum, const void *fpregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (len == I387_SIZEOF_FXSAVE)\n     {\n@@ -3927,7 +3930,7 @@ i386_collect_fpregset (const struct regset *regset,\n \t\t       int regnum, void *fpregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (len == I387_SIZEOF_FXSAVE)\n     {\n@@ -3959,7 +3962,7 @@ i386_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t   void *cb_data,\n \t\t\t\t   const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", tdep->sizeof_gregset, tdep->sizeof_gregset, &i386_gregset, NULL,\n       cb_data);\n@@ -4464,7 +4467,7 @@ i386_elf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n void\n i386_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* System V Release 4 uses ELF.  */\n   i386_elf_init_abi (info, gdbarch);\n@@ -4513,7 +4516,7 @@ int\n i386_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n \t\t\t  struct reggroup *group)\n {\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  const i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int fp_regnum_p, mmx_regnum_p, xmm_regnum_p, mxcsr_regnum_p,\n       ymm_regnum_p, ymmh_regnum_p, ymm_avx512_regnum_p, ymmh_avx512_regnum_p,\n       bndr_regnum_p, bnd_regnum_p, zmm_regnum_p, zmmh_regnum_p,\n@@ -4958,7 +4961,7 @@ static int i386_record_floats (struct gdbarch *gdbarch,\n \t\t\t       struct i386_record_s *ir,\n \t\t\t       uint32_t iregnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int i;\n \n   /* Oza: Because of floating point insn push/pop of fpu stack is going to\n@@ -5029,7 +5032,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n   ULONGEST addr;\n   gdb_byte buf[I386_MAX_REGISTER_SIZE];\n   struct i386_record_s ir;\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   uint8_t rex_w = -1;\n   uint8_t rex_r = 0;\n \n@@ -8191,7 +8194,7 @@ i386_floatformat_for_type (struct gdbarch *gdbarch,\n }\n \n static int\n-i386_validate_tdesc_p (struct gdbarch_tdep *tdep,\n+i386_validate_tdesc_p (i386_gdbarch_tdep *tdep,\n \t\t       struct tdesc_arch_data *tdesc_data)\n {\n   const struct target_desc *tdesc = tdep->tdesc;\n@@ -8393,7 +8396,6 @@ i386_type_align (struct gdbarch *gdbarch, struct type *type)\n static struct gdbarch *\n i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n   const struct target_desc *tdesc;\n   int mm0_regnum;\n@@ -8407,7 +8409,7 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     return arches->gdbarch;\n \n   /* Allocate space for the new architecture.  Assume i386 for now.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  i386_gdbarch_tdep *tdep = new i386_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* General-purpose registers.  */\n@@ -8651,7 +8653,7 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   if (!i386_validate_tdesc_p (tdep, tdesc_data.get ()))\n     {\n-      xfree (tdep);\n+      delete tdep;\n       gdbarch_free (gdbarch);\n       return NULL;\n     }\n@@ -8784,12 +8786,12 @@ static unsigned long\n i386_mpx_bd_base (void)\n {\n   struct regcache *rcache;\n-  struct gdbarch_tdep *tdep;\n   ULONGEST ret;\n   enum register_status regstatus;\n \n   rcache = get_current_regcache ();\n-  tdep = gdbarch_tdep (rcache->arch ());\n+  gdbarch *arch = rcache->arch ();\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   regstatus = regcache_raw_read_unsigned (rcache, tdep->bndcfgu_regnum, &ret);\n \n@@ -8802,7 +8804,8 @@ i386_mpx_bd_base (void)\n int\n i386_mpx_enabled (void)\n {\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (get_current_arch ());\n+  gdbarch *arch = get_current_arch ();\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (arch);\n   const struct target_desc *tdesc = tdep->tdesc;\n \n   return (tdesc_find_feature (tdesc, \"org.gnu.gdb.i386.mpx\") != NULL);"
    },
    {
      "sha": "8f1819b58deceb7f563cd5c3f75d9f504d755a6f",
      "filename": "gdb/i386-tdep.h",
      "status": "modified",
      "additions": 68,
      "deletions": 68,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -57,206 +57,206 @@ enum struct_return\n };\n \n /* i386 architecture specific information.  */\n-struct gdbarch_tdep\n+struct i386_gdbarch_tdep : gdbarch_tdep\n {\n   /* General-purpose registers.  */\n-  int *gregset_reg_offset;\n-  int gregset_num_regs;\n-  size_t sizeof_gregset;\n+  int *gregset_reg_offset = 0;\n+  int gregset_num_regs = 0;\n+  size_t sizeof_gregset = 0;\n \n   /* Floating-point registers.  */\n-  size_t sizeof_fpregset;\n+  size_t sizeof_fpregset = 0;\n \n   /* Register number for %st(0).  The register numbers for the other\n      registers follow from this one.  Set this to -1 to indicate the\n      absence of an FPU.  */\n-  int st0_regnum;\n+  int st0_regnum = 0;\n \n   /* Number of MMX registers.  */\n-  int num_mmx_regs;\n+  int num_mmx_regs = 0;\n \n   /* Register number for %mm0.  Set this to -1 to indicate the absence\n      of MMX support.  */\n-  int mm0_regnum;\n+  int mm0_regnum = 0;\n \n   /* Number of pseudo YMM registers.  */\n-  int num_ymm_regs;\n+  int num_ymm_regs = 0;\n \n   /* Register number for %ymm0.  Set this to -1 to indicate the absence\n      of pseudo YMM register support.  */\n-  int ymm0_regnum;\n+  int ymm0_regnum = 0;\n \n   /* Number of AVX512 OpMask registers (K-registers)  */\n-  int num_k_regs;\n+  int num_k_regs = 0;\n \n   /* Register number for %k0.  Set this to -1 to indicate the absence\n      of AVX512 OpMask register support.  */\n-  int k0_regnum;\n+  int k0_regnum = 0;\n \n   /* Number of pseudo ZMM registers ($zmm0-$zmm31).  */\n-  int num_zmm_regs;\n+  int num_zmm_regs = 0;\n \n   /* Register number for %zmm0.  Set this to -1 to indicate the absence\n      of pseudo ZMM register support.  */\n-  int zmm0_regnum;\n+  int zmm0_regnum = 0;\n \n   /* Number of byte registers.  */\n-  int num_byte_regs;\n+  int num_byte_regs = 0;\n \n   /* Register pseudo number for %al.  */\n-  int al_regnum;\n+  int al_regnum = 0;\n \n   /* Number of pseudo word registers.  */\n-  int num_word_regs;\n+  int num_word_regs = 0;\n \n   /* Register number for %ax.  */\n-  int ax_regnum;\n+  int ax_regnum = 0;\n \n   /* Number of pseudo dword registers.  */\n-  int num_dword_regs;\n+  int num_dword_regs = 0;\n \n   /* Register number for %eax.  Set this to -1 to indicate the absence\n      of pseudo dword register support.  */\n-  int eax_regnum;\n+  int eax_regnum = 0;\n \n   /* Number of core registers.  */\n-  int num_core_regs;\n+  int num_core_regs = 0;\n \n   /* Number of SSE registers.  */\n-  int num_xmm_regs;\n+  int num_xmm_regs = 0;\n \n   /* Number of SSE registers added in AVX512.  */\n-  int num_xmm_avx512_regs;\n+  int num_xmm_avx512_regs = 0;\n \n   /* Register number of XMM16, the first XMM register added in AVX512.  */\n-  int xmm16_regnum;\n+  int xmm16_regnum = 0;\n \n   /* Number of YMM registers added in AVX512.  */\n-  int num_ymm_avx512_regs;\n+  int num_ymm_avx512_regs = 0;\n \n   /* Register number of YMM16, the first YMM register added in AVX512.  */\n-  int ymm16_regnum;\n+  int ymm16_regnum = 0;\n \n   /* Bits of the extended control register 0 (the XFEATURE_ENABLED_MASK\n      register), excluding the x87 bit, which are supported by this GDB.  */\n \n-  uint64_t xcr0;\n+  uint64_t xcr0 = 0;\n \n   /* Offset of XCR0 in XSAVE extended state.  */\n-  int xsave_xcr0_offset;\n+  int xsave_xcr0_offset = 0;\n \n   /* Register names.  */\n-  const char * const *register_names;\n+  const char * const *register_names = nullptr;\n \n   /* Register number for %ymm0h.  Set this to -1 to indicate the absence\n      of upper YMM register support.  */\n-  int ymm0h_regnum;\n+  int ymm0h_regnum = 0;\n \n   /* Upper YMM register names.  Only used for tdesc_numbered_register.  */\n-  const char * const *ymmh_register_names;\n+  const char * const *ymmh_register_names = nullptr;\n \n   /* Register number for %ymm16h.  Set this to -1 to indicate the absence\n   of support for YMM16-31.  */\n-  int ymm16h_regnum;\n+  int ymm16h_regnum = 0;\n \n   /* YMM16-31 register names.  Only used for tdesc_numbered_register.  */\n-  const char * const *ymm16h_register_names;\n+  const char * const *ymm16h_register_names = nullptr;\n \n   /* Register number for %bnd0r.  Set this to -1 to indicate the absence\n      bound registers.  */\n-  int bnd0r_regnum;\n+  int bnd0r_regnum = 0;\n \n   /* Register number for pseudo register %bnd0.  Set this to -1 to indicate the absence\n      bound registers.  */\n-  int bnd0_regnum;\n+  int bnd0_regnum = 0;\n \n   /* Register number for %bndcfgu. Set this to -1 to indicate the absence\n      bound control registers.  */\n-  int bndcfgu_regnum;\n+  int bndcfgu_regnum = 0;\n \n   /* MPX register names.  Only used for tdesc_numbered_register.  */\n-  const char * const *mpx_register_names;\n+  const char * const *mpx_register_names = nullptr;\n \n   /* Register number for %zmm0h.  Set this to -1 to indicate the absence\n      of ZMM_HI256 register support.  */\n-  int zmm0h_regnum;\n+  int zmm0h_regnum = 0;\n \n   /* OpMask register names.  */\n-  const char * const *k_register_names;\n+  const char * const *k_register_names = nullptr;\n \n   /* ZMM register names.  Only used for tdesc_numbered_register.  */\n-  const char * const *zmmh_register_names;\n+  const char * const *zmmh_register_names = nullptr;\n \n   /* XMM16-31 register names.  Only used for tdesc_numbered_register.  */\n-  const char * const *xmm_avx512_register_names;\n+  const char * const *xmm_avx512_register_names = nullptr;\n \n   /* YMM16-31 register names.  Only used for tdesc_numbered_register.  */\n-  const char * const *ymm_avx512_register_names;\n+  const char * const *ymm_avx512_register_names = nullptr;\n \n   /* Number of PKEYS registers.  */\n-  int num_pkeys_regs;\n+  int num_pkeys_regs = 0;\n \n   /* Register number for PKRU register.  */\n-  int pkru_regnum;\n+  int pkru_regnum = 0;\n \n   /* PKEYS register names.  */\n-  const char * const *pkeys_register_names;\n+  const char * const *pkeys_register_names = nullptr;\n \n   /* Register number for %fsbase.  Set this to -1 to indicate the\n      absence of segment base registers.  */\n-  int fsbase_regnum;\n+  int fsbase_regnum = 0;\n \n   /* Target description.  */\n-  const struct target_desc *tdesc;\n+  const struct target_desc *tdesc = nullptr;\n \n   /* Register group function.  */\n-  gdbarch_register_reggroup_p_ftype *register_reggroup_p;\n+  gdbarch_register_reggroup_p_ftype *register_reggroup_p = nullptr;\n \n   /* Offset of saved PC in jmp_buf.  */\n-  int jb_pc_offset;\n+  int jb_pc_offset = 0;\n \n   /* Convention for returning structures.  */\n-  enum struct_return struct_return;\n+  enum struct_return struct_return {};\n \n   /* Address range where sigtramp lives.  */\n-  CORE_ADDR sigtramp_start;\n-  CORE_ADDR sigtramp_end;\n+  CORE_ADDR sigtramp_start = 0;\n+  CORE_ADDR sigtramp_end = 0;\n \n   /* Detect sigtramp.  */\n-  int (*sigtramp_p) (struct frame_info *);\n+  int (*sigtramp_p) (struct frame_info *) = nullptr;\n \n   /* Get address of sigcontext for sigtramp.  */\n-  CORE_ADDR (*sigcontext_addr) (struct frame_info *);\n+  CORE_ADDR (*sigcontext_addr) (struct frame_info *) = nullptr;\n \n   /* Offset of registers in `struct sigcontext'.  */\n-  int *sc_reg_offset;\n-  int sc_num_regs;\n+  int *sc_reg_offset = 0;\n+  int sc_num_regs = 0;\n \n   /* Offset of saved PC and SP in `struct sigcontext'.  Usage of these\n      is deprecated, please use `sc_reg_offset' instead.  */\n-  int sc_pc_offset;\n-  int sc_sp_offset;\n+  int sc_pc_offset = 0;\n+  int sc_sp_offset = 0;\n \n   /* ISA-specific data types.  */\n-  struct type *i386_mmx_type;\n-  struct type *i386_ymm_type;\n-  struct type *i386_zmm_type;\n-  struct type *i387_ext_type;\n-  struct type *i386_bnd_type;\n+  struct type *i386_mmx_type = nullptr;\n+  struct type *i386_ymm_type = nullptr;\n+  struct type *i386_zmm_type = nullptr;\n+  struct type *i387_ext_type = nullptr;\n+  struct type *i386_bnd_type = nullptr;\n \n   /* Process record/replay target.  */\n   /* The map for registers because the AMD64's registers order\n      in GDB is not same as I386 instructions.  */\n-  const int *record_regmap;\n+  const int *record_regmap = nullptr;\n   /* Parse intx80 args.  */\n-  int (*i386_intx80_record) (struct regcache *regcache);\n+  int (*i386_intx80_record) (struct regcache *regcache) = nullptr;\n   /* Parse sysenter args.  */\n-  int (*i386_sysenter_record) (struct regcache *regcache);\n+  int (*i386_sysenter_record) (struct regcache *regcache) = nullptr;\n   /* Parse syscall args.  */\n-  int (*i386_syscall_record) (struct regcache *regcache);\n+  int (*i386_syscall_record) (struct regcache *regcache) = nullptr;\n \n   /* Regsets. */\n-  const struct regset *fpregset;\n+  const struct regset *fpregset = nullptr;\n };\n \n /* Floating-point registers.  */"
    },
    {
      "sha": "5ab1474c1641e3027e5120554be9f8cdede9118e",
      "filename": "gdb/i386-windows-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i386-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-windows-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -136,7 +136,7 @@ i386_windows_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n static void\n i386_windows_init_abi_common (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   set_gdbarch_skip_trampoline_code (gdbarch, i386_windows_skip_trampoline_code);\n "
    },
    {
      "sha": "e5c78145bd74b187e3f5184d7085543c6f26c86c",
      "filename": "gdb/i387-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i387-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/i387-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i387-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -204,7 +204,7 @@ void\n i387_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,\n \t\t       struct frame_info *frame, const char *args)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   ULONGEST fctrl;\n   int fctrl_p;\n   ULONGEST fstat;\n@@ -440,7 +440,7 @@ void\n i387_supply_fsave (struct regcache *regcache, int regnum, const void *fsave)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   const gdb_byte *regs = (const gdb_byte *) fsave;\n   int i;\n@@ -494,7 +494,8 @@ i387_supply_fsave (struct regcache *regcache, int regnum, const void *fsave)\n void\n i387_collect_fsave (const struct regcache *regcache, int regnum, void *fsave)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (regcache->arch ());\n+  gdbarch *arch = regcache->arch ();\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (arch);\n   gdb_byte *regs = (gdb_byte *) fsave;\n   int i;\n \n@@ -587,7 +588,8 @@ static int i387_tag (const gdb_byte *raw);\n void\n i387_supply_fxsave (struct regcache *regcache, int regnum, const void *fxsave)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (regcache->arch ());\n+  gdbarch *arch = regcache->arch ();\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (arch);\n   const gdb_byte *regs = (const gdb_byte *) fxsave;\n   int i;\n \n@@ -670,7 +672,8 @@ i387_supply_fxsave (struct regcache *regcache, int regnum, const void *fxsave)\n void\n i387_collect_fxsave (const struct regcache *regcache, int regnum, void *fxsave)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (regcache->arch ());\n+  gdbarch *arch = regcache->arch ();\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (arch);\n   gdb_byte *regs = (gdb_byte *) fxsave;\n   int i;\n \n@@ -903,7 +906,7 @@ i387_xsave_get_clear_bv (struct gdbarch *gdbarch, const void *xsave)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   const gdb_byte *regs = (const gdb_byte *) xsave;\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Get `xstat_bv'.  The supported bits in `xstat_bv' are 8 bytes.  */\n   ULONGEST xstate_bv = extract_unsigned_integer (XSAVE_XSTATE_BV_ADDR (regs),\n@@ -923,7 +926,7 @@ i387_supply_xsave (struct regcache *regcache, int regnum,\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const gdb_byte *regs = (const gdb_byte *) xsave;\n   int i;\n   /* In 64-bit mode the split between \"low\" and \"high\" ZMM registers is at\n@@ -1346,7 +1349,7 @@ i387_collect_xsave (const struct regcache *regcache, int regnum,\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_byte *p, *regs = (gdb_byte *) xsave;\n   gdb_byte raw[I386_MAX_REGISTER_SIZE];\n   ULONGEST initial_xstate_bv, clear_bv, xstate_bv = 0;\n@@ -1931,7 +1934,7 @@ i387_tag (const gdb_byte *raw)\n void\n i387_return_value (struct gdbarch *gdbarch, struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   ULONGEST fstat;\n \n   /* Set the top of the floating-point register stack to 7.  The\n@@ -1954,7 +1957,7 @@ i387_return_value (struct gdbarch *gdbarch, struct regcache *regcache)\n void\n i387_reset_bnd_regs (struct gdbarch *gdbarch, struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  i386_gdbarch_tdep *tdep = (i386_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (I387_BND0R_REGNUM (tdep) > 0)\n     {"
    },
    {
      "sha": "cf062f1754acdb7638977614d50f6b378302bfe3",
      "filename": "gdb/ia64-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ia64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ia64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -216,7 +216,7 @@ ia64_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n static void\n ia64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ia64_gdbarch_tdep *tdep = (ia64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   static const char *const stap_register_prefixes[] = { \"r\", NULL };\n   static const char *const stap_register_indirection_prefixes[] = { \"[\",\n \t\t\t\t\t\t\t\t    NULL };"
    },
    {
      "sha": "08c5d6a72efaceb430fe0d0a543f5eca6f90d695",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -310,7 +310,7 @@ static const struct floatformat *floatformats_ia64_ext[2] =\n static struct type *\n ia64_ext_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ia64_gdbarch_tdep *tdep = (ia64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->ia64_ext_type)\n     tdep->ia64_ext_type\n@@ -2177,7 +2177,7 @@ ia64_sigtramp_frame_init_saved_regs (struct frame_info *this_frame,\n \t\t\t\t     struct ia64_frame_cache *cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ia64_gdbarch_tdep *tdep = (ia64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->sigcontext_register_address)\n     {\n@@ -2335,7 +2335,8 @@ ia64_sigtramp_frame_sniffer (const struct frame_unwind *self,\n \t\t\t     struct frame_info *this_frame,\n \t\t\t     void **this_cache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  ia64_gdbarch_tdep *tdep = (ia64_gdbarch_tdep *) gdbarch_tdep (arch);\n   if (tdep->pc_in_sigtramp)\n     {\n       CORE_ADDR pc = get_frame_pc (this_frame);\n@@ -3482,7 +3483,7 @@ ia64_find_global_pointer_from_dynamic_section (struct gdbarch *gdbarch,\n static CORE_ADDR\n ia64_find_global_pointer (struct gdbarch *gdbarch, CORE_ADDR faddr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ia64_gdbarch_tdep *tdep = (ia64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   CORE_ADDR addr = 0;\n \n   if (tdep->find_global_pointer_from_solib)\n@@ -3677,7 +3678,7 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t      function_call_return_method return_method,\n \t\t      CORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ia64_gdbarch_tdep *tdep = (ia64_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int argno;\n   struct value *arg;\n@@ -3917,14 +3918,13 @@ static struct gdbarch *\n ia64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n \n   /* If there is already a candidate, use it.  */\n   arches = gdbarch_list_lookup_by_info (arches, &info);\n   if (arches != NULL)\n     return arches->gdbarch;\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  ia64_gdbarch_tdep *tdep = new ia64_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   tdep->size_of_register_frame = ia64_size_of_register_frame;"
    },
    {
      "sha": "82319d508942cd81e0a7f21e04368e31ce225769",
      "filename": "gdb/ia64-tdep.h",
      "status": "modified",
      "additions": 14,
      "deletions": 9,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ia64-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ia64-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,6 +20,8 @@\n #ifndef IA64_TDEP_H\n #define IA64_TDEP_H\n \n+#include \"gdbarch.h\"\n+\n #ifdef HAVE_LIBUNWIND_IA64_H\n #include \"libunwind-ia64.h\"\n #include \"ia64-libunwind-tdep.h\"\n@@ -214,41 +216,44 @@ struct ia64_infcall_ops\n \n      Should do nothing if this operation is not permitted by the OS.  */\n   void (*allocate_new_rse_frame) (struct regcache *regcache, ULONGEST bsp,\n-\t\t\t\t  int sof);\n+\t\t\t\t  int sof) = nullptr;\n \n   /* Store the argument stored in BUF into the appropriate location\n      given the BSP and the SLOTNUM.  */\n   void (*store_argument_in_slot) (struct regcache *regcache, CORE_ADDR bsp,\n-\t\t\t\t  int slotnum, gdb_byte *buf);\n+\t\t\t\t  int slotnum, gdb_byte *buf) = nullptr;\n \n   /* For targets where we cannot call the function directly, store\n      the address of the function we want to call at the location\n      expected by the calling sequence.  */\n-  void (*set_function_addr) (struct regcache *regcache, CORE_ADDR func_addr);\n+  void (*set_function_addr) (struct regcache *regcache, CORE_ADDR func_addr)\n+    = nullptr;\n };\n \n-struct gdbarch_tdep\n+struct ia64_gdbarch_tdep : gdbarch_tdep\n {\n-  CORE_ADDR (*sigcontext_register_address) (struct gdbarch *, CORE_ADDR, int);\n-  int (*pc_in_sigtramp) (CORE_ADDR);\n+  CORE_ADDR (*sigcontext_register_address) (struct gdbarch *, CORE_ADDR, int)\n+    = nullptr;\n+  int (*pc_in_sigtramp) (CORE_ADDR) = nullptr;\n \n   /* Return the total size of THIS_FRAME's register frame.\n      CFM is THIS_FRAME's cfm register value.\n \n      Normally, the size of the register frame is always obtained by\n      extracting the lowest 7 bits (\"cfm & 0x7f\").  */\n-  int (*size_of_register_frame) (struct frame_info *this_frame, ULONGEST cfm);\n+  int (*size_of_register_frame) (struct frame_info *this_frame, ULONGEST cfm)\n+    = nullptr;\n \n   /* Determine the function address FADDR belongs to a shared library.\n      If it does, then return the associated global pointer.  If no shared\n      library was found to contain that function, then return zero.\n \n      This pointer may be NULL.  */\n   CORE_ADDR (*find_global_pointer_from_solib) (struct gdbarch *gdbarch,\n-\t\t\t\t\t       CORE_ADDR faddr);\n+\t\t\t\t\t       CORE_ADDR faddr) = nullptr;\n \n   /* ISA-specific data types.  */\n-  struct type *ia64_ext_type;\n+  struct type *ia64_ext_type = nullptr;\n \n   struct ia64_infcall_ops infcall_ops;\n };"
    },
    {
      "sha": "3f91c050b4702952d437e0f5f3ccdad15ab8ed32",
      "filename": "gdb/lm32-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/lm32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/lm32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/lm32-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -42,7 +42,7 @@\n #define LM32_REG2(insn)         ((insn >> 11) & 0x1f)\n #define LM32_IMM16(insn)        ((((long)insn & 0xffff) << 16) >> 16)\n \n-struct gdbarch_tdep\n+struct lm32_gdbarch_tdep : gdbarch_tdep\n {\n   /* gdbarch target dependent data here.  Currently unused for LM32.  */\n };\n@@ -491,15 +491,14 @@ static struct gdbarch *\n lm32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n \n   /* If there is already a candidate, use it.  */\n   arches = gdbarch_list_lookup_by_info (arches, &info);\n   if (arches != NULL)\n     return arches->gdbarch;\n \n   /* None found, create a new architecture from the information provided.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  lm32_gdbarch_tdep *tdep = new lm32_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Type sizes.  */"
    },
    {
      "sha": "200d51a16b1b4b481ca2e4ed5fbcf3f6a6a08b94",
      "filename": "gdb/m32c-tdep.c",
      "status": "modified",
      "additions": 67,
      "deletions": 46,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m32c-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m32c-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32c-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -95,42 +95,44 @@ struct m32c_reg\n #define M32C_MAX_DWARF_REGNUM (40)\n \n \n-struct gdbarch_tdep\n+struct m32c_gdbarch_tdep : gdbarch_tdep\n {\n   /* All the registers for this variant, indexed by GDB register\n      number, and the number of registers present.  */\n-  struct m32c_reg regs[M32C_MAX_NUM_REGS];\n+  struct m32c_reg regs[M32C_MAX_NUM_REGS] {};\n \n   /* The number of valid registers.  */\n-  int num_regs;\n+  int num_regs = 0;\n \n   /* Interesting registers.  These are pointers into REGS.  */\n-  struct m32c_reg *pc, *flg;\n-  struct m32c_reg *r0, *r1, *r2, *r3, *a0, *a1;\n-  struct m32c_reg *r2r0, *r3r2r1r0, *r3r1r2r0;\n-  struct m32c_reg *sb, *fb, *sp;\n+  struct m32c_reg *pc = nullptr, *flg = nullptr;\n+  struct m32c_reg *r0 = nullptr, *r1 = nullptr, *r2 = nullptr, *r3 = nullptr,\n+    *a0 = nullptr, *a1 = nullptr;\n+  struct m32c_reg *r2r0 = nullptr, *r3r2r1r0 = nullptr, *r3r1r2r0 = nullptr;\n+  struct m32c_reg *sb = nullptr, *fb = nullptr, *sp = nullptr;\n \n   /* A table indexed by DWARF register numbers, pointing into\n      REGS.  */\n-  struct m32c_reg *dwarf_regs[M32C_MAX_DWARF_REGNUM + 1];\n+  struct m32c_reg *dwarf_regs[M32C_MAX_DWARF_REGNUM + 1] {};\n \n   /* Types for this architecture.  We can't use the builtin_type_foo\n      types, because they're not initialized when building a gdbarch\n      structure.  */\n-  struct type *voyd, *ptr_voyd, *func_voyd;\n-  struct type *uint8, *uint16;\n-  struct type *int8, *int16, *int32, *int64;\n+  struct type *voyd = nullptr, *ptr_voyd = nullptr, *func_voyd = nullptr;\n+  struct type *uint8 = nullptr, *uint16 = nullptr;\n+  struct type *int8 = nullptr, *int16 = nullptr, *int32 = nullptr,\n+    *int64 = nullptr;\n \n   /* The types for data address and code address registers.  */\n-  struct type *data_addr_reg_type, *code_addr_reg_type;\n+  struct type *data_addr_reg_type = nullptr, *code_addr_reg_type = nullptr;\n \n   /* The number of bytes a return address pushed by a 'jsr' instruction\n      occupies on the stack.  */\n-  int ret_addr_bytes;\n+  int ret_addr_bytes = 0;\n \n   /* The number of bytes an address register occupies on the stack\n      when saved by an 'enter' or 'pushm' instruction.  */\n-  int push_addr_bytes;\n+  int push_addr_bytes = 0;\n };\n \n \f\n@@ -139,7 +141,7 @@ struct gdbarch_tdep\n static void\n make_types (struct gdbarch *arch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   unsigned long mach = gdbarch_bfd_arch_info (arch)->mach;\n   int data_addr_reg_bits, code_addr_reg_bits;\n   char type_name[50];\n@@ -212,28 +214,31 @@ make_types (struct gdbarch *arch)\n static const char *\n m32c_register_name (struct gdbarch *gdbarch, int num)\n {\n-  return gdbarch_tdep (gdbarch)->regs[num].name;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->regs[num].name;\n }\n \n \n static struct type *\n m32c_register_type (struct gdbarch *arch, int reg_nr)\n {\n-  return gdbarch_tdep (arch)->regs[reg_nr].type;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n+  return tdep->regs[reg_nr].type;\n }\n \n \n static int\n m32c_register_sim_regno (struct gdbarch *gdbarch, int reg_nr)\n {\n-  return gdbarch_tdep (gdbarch)->regs[reg_nr].sim_num;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->regs[reg_nr].sim_num;\n }\n \n \n static int\n m32c_debug_info_reg_to_regnum (struct gdbarch *gdbarch, int reg_nr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (0 <= reg_nr && reg_nr <= M32C_MAX_DWARF_REGNUM\n       && tdep->dwarf_regs[reg_nr])\n     return tdep->dwarf_regs[reg_nr]->num;\n@@ -248,7 +253,7 @@ static int\n m32c_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n \t\t\t  struct reggroup *group)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct m32c_reg *reg = &tdep->regs[regnum];\n \n   /* The anonymous raw registers aren't in any groups.  */\n@@ -323,7 +328,8 @@ m32c_raw_write (struct m32c_reg *reg, struct regcache *cache,\n static int\n m32c_read_flg (readable_regcache *cache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (cache->arch ());\n+  gdbarch *arch = cache->arch ();\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   ULONGEST flg;\n \n   cache->raw_read (tdep->flg->num, &flg);\n@@ -522,7 +528,8 @@ m32c_cat_write (struct m32c_reg *reg, struct regcache *cache,\n static enum register_status\n m32c_r3r2r1r0_read (struct m32c_reg *reg, readable_regcache *cache, gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (reg->arch);\n+  gdbarch *arch = reg->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   int len = TYPE_LENGTH (tdep->r0->type);\n   enum register_status status;\n \n@@ -558,7 +565,8 @@ static enum register_status\n m32c_r3r2r1r0_write (struct m32c_reg *reg, struct regcache *cache,\n \t\t     const gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (reg->arch);\n+  gdbarch *arch = reg->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   int len = TYPE_LENGTH (tdep->r0->type);\n \n   if (gdbarch_byte_order (reg->arch) == BFD_ENDIAN_BIG)\n@@ -586,7 +594,7 @@ m32c_pseudo_register_read (struct gdbarch *arch,\n \t\t\t   int cookednum,\n \t\t\t   gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   struct m32c_reg *reg;\n \n   gdb_assert (0 <= cookednum && cookednum < tdep->num_regs);\n@@ -604,7 +612,7 @@ m32c_pseudo_register_write (struct gdbarch *arch,\n \t\t\t    int cookednum,\n \t\t\t    const gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   struct m32c_reg *reg;\n \n   gdb_assert (0 <= cookednum && cookednum < tdep->num_regs);\n@@ -629,7 +637,7 @@ add_reg (struct gdbarch *arch,\n \t struct m32c_reg *ry,\n \t int n)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   struct m32c_reg *r = &tdep->regs[tdep->num_regs];\n \n   gdb_assert (tdep->num_regs < M32C_MAX_NUM_REGS);\n@@ -668,7 +676,9 @@ set_dwarf_regnum (struct m32c_reg *reg, int num)\n     reg->dwarf_num = num;\n \n   /* Update the DWARF->reg mapping.  */\n-  gdbarch_tdep (reg->arch)->dwarf_regs[num] = reg;\n+  gdbarch *arch = reg->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n+  tdep->dwarf_regs[num] = reg;\n }\n \n \n@@ -789,7 +799,7 @@ mark_save_restore (struct m32c_reg *reg)\n static void\n make_regs (struct gdbarch *arch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   int mach = gdbarch_bfd_arch_info (arch)->mach;\n   int num_raw_regs;\n   int num_cooked_regs;\n@@ -1336,16 +1346,17 @@ m32c_decode_sd23 (struct m32c_pv_state *st, int code, int size, int ind)\n static int\n m32c_pv_enter (struct m32c_pv_state *state, int size)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (state->arch);\n-\n   /* If simulating this store would require us to forget\n      everything we know about the stack frame in the name of\n      accuracy, it would be better to just quit now.  */\n   if (state->stack->store_would_trash (state->sp))\n     return 1;\n \n+  gdbarch *arch = state->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   if (m32c_pv_push (state, state->fb, tdep->push_addr_bytes))\n     return 1;\n+\n   state->fb = state->sp;\n   state->sp = pv_add_constant (state->sp, -size);\n \n@@ -1371,7 +1382,8 @@ m32c_pv_pushm_one (struct m32c_pv_state *state, pv_t reg,\n static int\n m32c_pv_pushm (struct m32c_pv_state *state, int src)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (state->arch);\n+  gdbarch *arch = state->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   /* The bits in SRC indicating which registers to save are:\n      r0 r1 r2 r3 a0 a1 sb fb */\n@@ -1391,7 +1403,9 @@ m32c_pv_pushm (struct m32c_pv_state *state, int src)\n static int\n m32c_is_1st_arg_reg (struct m32c_pv_state *state, pv_t value)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (state->arch);\n+  gdbarch *arch = state->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n+\n   return (value.kind == pvk_register\n \t  && (gdbarch_bfd_arch_info (state->arch)->mach == bfd_mach_m16c\n \t      ? (value.reg == tdep->r1->num)\n@@ -1404,7 +1418,9 @@ m32c_is_1st_arg_reg (struct m32c_pv_state *state, pv_t value)\n static int\n m32c_is_arg_reg (struct m32c_pv_state *state, pv_t value)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (state->arch);\n+  gdbarch *arch = state->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n+\n   return (value.kind == pvk_register\n \t  && (gdbarch_bfd_arch_info (state->arch)->mach == bfd_mach_m16c\n \t      ? (value.reg == tdep->r1->num || value.reg == tdep->r2->num)\n@@ -1427,7 +1443,8 @@ m32c_is_arg_spill (struct m32c_pv_state *st,\n \t\t   struct srcdest loc, \n \t\t   pv_t value)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (st->arch);\n+  gdbarch *arch = st->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   return (m32c_is_arg_reg (st, value)\n \t  && loc.kind == srcdest_mem\n@@ -1450,7 +1467,8 @@ m32c_is_struct_return (struct m32c_pv_state *st,\n \t\t       struct srcdest loc, \n \t\t       pv_t value)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (st->arch);\n+  gdbarch *arch = st->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   return (m32c_is_1st_arg_reg (st, value)\n \t  && !st->stack->find_reg (st->arch, value.reg, 0)\n@@ -1467,7 +1485,9 @@ m32c_is_struct_return (struct m32c_pv_state *st,\n static int\n m32c_pushm_is_reg_save (struct m32c_pv_state *st, int src)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (st->arch);\n+  gdbarch *arch = st->arch;\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n+\n   /* The bits in SRC indicating which registers to save are:\n      r0 r1 r2 r3 a0 a1 sb fb */\n   return\n@@ -1494,7 +1514,7 @@ check_for_saved (void *prologue_untyped, pv_t addr, CORE_ADDR size, pv_t value)\n {\n   struct m32c_prologue *prologue = (struct m32c_prologue *) prologue_untyped;\n   struct gdbarch *arch = prologue->arch;\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   /* Is this the unchanged value of some register being saved on the\n      stack?  */\n@@ -1534,7 +1554,7 @@ m32c_analyze_prologue (struct gdbarch *arch,\n \t\t       CORE_ADDR start, CORE_ADDR limit,\n \t\t       struct m32c_prologue *prologue)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   unsigned long mach = gdbarch_bfd_arch_info (arch)->mach;\n   CORE_ADDR after_last_frame_related_insn;\n   struct m32c_pv_state st;\n@@ -1864,7 +1884,8 @@ m32c_frame_base (struct frame_info *this_frame,\n {\n   struct m32c_prologue *p\n     = m32c_analyze_frame_prologue (this_frame, this_prologue_cache);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   /* In functions that use alloca, the distance between the stack\n      pointer and the frame base varies dynamically, so we can't use\n@@ -1914,7 +1935,8 @@ static struct value *\n m32c_prev_register (struct frame_info *this_frame,\n \t\t    void **this_prologue_cache, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n+  gdbarch *arch = get_frame_arch (this_frame);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (arch);\n   struct m32c_prologue *p\n     = m32c_analyze_frame_prologue (this_frame, this_prologue_cache);\n   CORE_ADDR frame_base = m32c_frame_base (this_frame, this_prologue_cache);\n@@ -1997,7 +2019,7 @@ m32c_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t      function_call_return_method return_method,\n \t\t      CORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;\n   CORE_ADDR cfa;\n@@ -2160,7 +2182,7 @@ m32c_return_value (struct gdbarch *gdbarch,\n \t\t   gdb_byte *readbuf,\n \t\t   const gdb_byte *writebuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   enum return_value_convention conv;\n   ULONGEST valtype_len = TYPE_LENGTH (valtype);\n@@ -2291,7 +2313,7 @@ static CORE_ADDR\n m32c_skip_trampoline_code (struct frame_info *frame, CORE_ADDR stop_pc)\n {\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   /* It would be nicer to simply look up the addresses of known\n@@ -2537,7 +2559,7 @@ m32c_virtual_frame_pointer (struct gdbarch *gdbarch, CORE_ADDR pc,\n   struct m32c_prologue p;\n \n   struct regcache *regcache = get_current_regcache ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m32c_gdbarch_tdep *tdep = (m32c_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   \n   if (!find_pc_partial_function (pc, &name, &func_addr, &func_end))\n     internal_error (__FILE__, __LINE__,\n@@ -2572,7 +2594,6 @@ static struct gdbarch *\n m32c_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   unsigned long mach = info.bfd_arch_info->mach;\n \n   /* Find a candidate among the list of architectures we've created\n@@ -2582,7 +2603,7 @@ m32c_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     return arches->gdbarch;\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  m32c_gdbarch_tdep *tdep = new m32c_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Essential types.  */"
    },
    {
      "sha": "a9906ff39a62425f462d8a45bd8d6a19aa8cebd9",
      "filename": "gdb/m32r-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m32r-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m32r-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -865,15 +865,14 @@ static struct gdbarch *\n m32r_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n \n   /* If there is already a candidate, use it.  */\n   arches = gdbarch_list_lookup_by_info (arches, &info);\n   if (arches != NULL)\n     return arches->gdbarch;\n \n   /* Allocate space for the new architecture.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  m32r_gdbarch_tdep *tdep = new m32r_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   set_gdbarch_wchar_bit (gdbarch, 16);"
    },
    {
      "sha": "22c333cff7d74439ed78fbd680973e0a3f9243d6",
      "filename": "gdb/m32r-tdep.h",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m32r-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m32r-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,7 +20,9 @@\n #ifndef M32R_TDEP_H\n #define M32R_TDEP_H\n \n-struct gdbarch_tdep\n+#include \"gdbarch.h\"\n+\n+struct m32r_gdbarch_tdep : gdbarch_tdep\n {\n   /* gdbarch target dependent data here.  Currently unused for M32R.  */\n };"
    },
    {
      "sha": "6d41fe85f9561cd414843950cda49b2a558a899f",
      "filename": "gdb/m68hc11-tdep.c",
      "status": "modified",
      "additions": 41,
      "deletions": 19,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68hc11-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68hc11-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68hc11-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -123,27 +123,38 @@ enum insn_return_kind {\n #define M68HC12_HARD_PC_REGNUM  (SOFT_D32_REGNUM+1)\n \n struct insn_sequence;\n-struct gdbarch_tdep\n+struct m68gc11_gdbarch_tdep : gdbarch_tdep\n   {\n     /* Stack pointer correction value.  For 68hc11, the stack pointer points\n        to the next push location.  An offset of 1 must be applied to obtain\n        the address where the last value is saved.  For 68hc12, the stack\n        pointer points to the last value pushed.  No offset is necessary.  */\n-    int stack_correction;\n+    int stack_correction = 0;\n \n     /* Description of instructions in the prologue.  */\n-    struct insn_sequence *prologue;\n+    struct insn_sequence *prologue = nullptr;\n \n     /* True if the page memory bank register is available\n        and must be used.  */\n-    int use_page_register;\n+    int use_page_register = 0;\n \n     /* ELF flags for ABI.  */\n-    int elf_flags;\n+    int elf_flags = 0;\n   };\n \n-#define STACK_CORRECTION(gdbarch) (gdbarch_tdep (gdbarch)->stack_correction)\n-#define USE_PAGE_REGISTER(gdbarch) (gdbarch_tdep (gdbarch)->use_page_register)\n+static int\n+stack_correction (gdbarch *arch)\n+{\n+  m68gc11_gdbarch_tdep *tdep = (m68gc11_gdbarch_tdep *) gdbarch_tdep (arch);\n+  return tdep->stack_correction;\n+}\n+\n+static int\n+use_page_register (gdbarch *arch)\n+{\n+  m68gc11_gdbarch_tdep *tdep = (m68gc11_gdbarch_tdep *) gdbarch_tdep (arch);\n+  return tdep->stack_correction;\n+}\n \n struct m68hc11_unwind_cache\n {\n@@ -371,13 +382,15 @@ m68hc11_pseudo_register_write (struct gdbarch *gdbarch,\n static const char *\n m68hc11_register_name (struct gdbarch *gdbarch, int reg_nr)\n {\n-  if (reg_nr == M68HC12_HARD_PC_REGNUM && USE_PAGE_REGISTER (gdbarch))\n+  if (reg_nr == M68HC12_HARD_PC_REGNUM && use_page_register (gdbarch))\n     return \"pc\";\n-  if (reg_nr == HARD_PC_REGNUM && USE_PAGE_REGISTER (gdbarch))\n+\n+  if (reg_nr == HARD_PC_REGNUM && use_page_register (gdbarch))\n     return \"ppc\";\n   \n   if (reg_nr < 0)\n     return NULL;\n+\n   if (reg_nr >= M68HC11_ALL_REGS)\n     return NULL;\n \n@@ -387,6 +400,7 @@ m68hc11_register_name (struct gdbarch *gdbarch, int reg_nr)\n      does not exist.  */\n   if (reg_nr > M68HC11_LAST_HARD_REG && soft_regs[reg_nr].name == 0)\n     return NULL;\n+\n   return m68hc11_register_names[reg_nr];\n }\n \n@@ -627,7 +641,8 @@ m68hc11_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n       return pc;\n     }\n \n-  seq_table = gdbarch_tdep (gdbarch)->prologue;\n+  m68gc11_gdbarch_tdep *tdep = (m68gc11_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  seq_table = tdep->prologue;\n   \n   /* The 68hc11 stack is as follows:\n \n@@ -807,15 +822,15 @@ m68hc11_frame_unwind_cache (struct frame_info *this_frame,\n       info->saved_regs[HARD_PC_REGNUM].set_addr (info->sp_offset);\n       this_base = get_frame_register_unsigned (this_frame, HARD_SP_REGNUM);\n       prev_sp = this_base + info->sp_offset + 2;\n-      this_base += STACK_CORRECTION (gdbarch);\n+      this_base += stack_correction (gdbarch);\n     }\n   else\n     {\n       /* The FP points at the last saved register.  Adjust the FP back\n \t to before the first saved register giving the SP.  */\n       prev_sp = this_base + info->size + 2;\n \n-      this_base += STACK_CORRECTION (gdbarch);\n+      this_base += stack_correction (gdbarch);\n       if (soft_regs[SOFT_FP_REGNUM].name)\n \tinfo->saved_regs[SOFT_FP_REGNUM].set_addr (info->size - 2);\n    }\n@@ -898,7 +913,7 @@ m68hc11_frame_prev_register (struct frame_info *this_frame,\n   /* Take into account the 68HC12 specific call (PC + page).  */\n   if (regnum == HARD_PC_REGNUM\n       && info->return_kind == RETURN_RTC\n-      && USE_PAGE_REGISTER (get_frame_arch (this_frame)))\n+      && use_page_register (get_frame_arch (this_frame)))\n     {\n       CORE_ADDR pc = value_as_long (value);\n       if (pc >= 0x08000 && pc < 0x0c000)\n@@ -1003,7 +1018,10 @@ m68hc11_print_register (struct gdbarch *gdbarch, struct ui_file *file,\n     }\n   else\n     {\n-      if (regno == HARD_PC_REGNUM && gdbarch_tdep (gdbarch)->use_page_register)\n+      m68gc11_gdbarch_tdep *tdep\n+\t= (m68gc11_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+      if (regno == HARD_PC_REGNUM && tdep->use_page_register)\n \t{\n \t  ULONGEST page;\n \n@@ -1106,7 +1124,9 @@ m68hc11_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,\n       fprintf_filtered (file, \" Y=\");\n       m68hc11_print_register (gdbarch, file, frame, HARD_Y_REGNUM);\n   \n-      if (gdbarch_tdep (gdbarch)->use_page_register)\n+      m68gc11_gdbarch_tdep *tdep = (m68gc11_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+      if (tdep->use_page_register)\n \t{\n \t  fprintf_filtered (file, \"\\nPage=\");\n \t  m68hc11_print_register (gdbarch, file, frame, HARD_PAGE_REGNUM);\n@@ -1194,7 +1214,7 @@ m68hc11_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   write_memory (sp, buf, 2);\n \n   /* Finally, update the stack pointer...  */\n-  sp -= STACK_CORRECTION (gdbarch);\n+  sp -= stack_correction (gdbarch);\n   regcache_cooked_write_unsigned (regcache, HARD_SP_REGNUM, sp);\n \n   /* ...and fake a frame pointer.  */\n@@ -1386,7 +1406,6 @@ m68hc11_gdbarch_init (struct gdbarch_info info,\n \t\t      struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int elf_flags;\n \n   soft_reg_initialized = 0;\n@@ -1403,14 +1422,17 @@ m68hc11_gdbarch_init (struct gdbarch_info info,\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      if (gdbarch_tdep (arches->gdbarch)->elf_flags != elf_flags)\n+      m68gc11_gdbarch_tdep *tdep\n+\t= (m68gc11_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n+      if (tdep->elf_flags != elf_flags)\n \tcontinue;\n \n       return arches->gdbarch;\n     }\n \n   /* Need a new architecture.  Fill in a target specific vector.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  m68gc11_gdbarch_tdep *tdep = new m68gc11_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   tdep->elf_flags = elf_flags;\n "
    },
    {
      "sha": "27fbb845551fa31e13a501be34f3586140d83dae",
      "filename": "gdb/m68k-bsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68k-bsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68k-bsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-bsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -133,7 +133,7 @@ m68kbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,\n static void\n m68kbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->jb_pc = 5;\n   tdep->jb_elt_size = 4;"
    },
    {
      "sha": "6704d8319f332c7c4822691534ceddc7ace01f44",
      "filename": "gdb/m68k-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68k-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68k-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -384,7 +384,7 @@ m68k_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n static void\n m68k_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 0);\n "
    },
    {
      "sha": "4ae27e6b7749ca55d41a0443e08854134fae6939",
      "filename": "gdb/m68k-tdep.c",
      "status": "modified",
      "additions": 33,
      "deletions": 24,
      "changes": 57,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -70,7 +70,7 @@ typedef BP_MANIPULATION (m68k_break_insn) m68k_breakpoint;\n static struct type *\n m68k_ps_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->m68k_ps_type)\n     {\n@@ -99,7 +99,7 @@ m68k_ps_type (struct gdbarch *gdbarch)\n static struct type *\n m68881_ext_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->m68881_ext_type)\n     tdep->m68881_ext_type\n@@ -120,7 +120,7 @@ m68881_ext_type (struct gdbarch *gdbarch)\n static struct type *\n m68k_register_type (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->fpregs_present)\n     {\n@@ -171,12 +171,14 @@ static const char * const m68k_register_names[] = {\n static const char *\n m68k_register_name (struct gdbarch *gdbarch, int regnum)\n {\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n   if (regnum < 0 || regnum >= ARRAY_SIZE (m68k_register_names))\n     internal_error (__FILE__, __LINE__,\n \t\t    _(\"m68k_register_name: illegal register number %d\"),\n \t\t    regnum);\n   else if (regnum >= M68K_FP0_REGNUM && regnum <= M68K_FPI_REGNUM\n-\t   && gdbarch_tdep (gdbarch)->fpregs_present == 0)\n+\t   && tdep->fpregs_present == 0)\n     return \"\";\n   else\n     return m68k_register_names[regnum];\n@@ -189,7 +191,9 @@ static int\n m68k_convert_register_p (struct gdbarch *gdbarch,\n \t\t\t int regnum, struct type *type)\n {\n-  if (!gdbarch_tdep (gdbarch)->fpregs_present)\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+  if (!tdep->fpregs_present)\n     return 0;\n   return (regnum >= M68K_FP0_REGNUM && regnum <= M68K_FP0_REGNUM + 7\n \t  /* We only support floating-point values.  */\n@@ -296,7 +300,7 @@ m68k_extract_return_value (struct type *type, struct regcache *regcache,\n   if (type->code () == TYPE_CODE_PTR && len == 4)\n     {\n       struct gdbarch *gdbarch = regcache->arch ();\n-      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n       regcache->raw_read (tdep->pointer_result_regnum, valbuf);\n     }\n   else if (len <= 4)\n@@ -321,7 +325,7 @@ m68k_svr4_extract_return_value (struct type *type, struct regcache *regcache,\n {\n   gdb_byte buf[M68K_MAX_REGISTER_SIZE];\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->float_return && type->code () == TYPE_CODE_FLT)\n     {\n@@ -344,7 +348,7 @@ m68k_store_return_value (struct type *type, struct regcache *regcache,\n   if (type->code () == TYPE_CODE_PTR && len == 4)\n     {\n       struct gdbarch *gdbarch = regcache->arch ();\n-      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n       regcache->raw_write (tdep->pointer_result_regnum, valbuf);\n       /* gdb historically also set D0 in the SVR4 case.  */\n       if (tdep->pointer_result_regnum != M68K_D0_REGNUM)\n@@ -367,7 +371,7 @@ m68k_svr4_store_return_value (struct type *type, struct regcache *regcache,\n \t\t\t      const gdb_byte *valbuf)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->float_return && type->code () == TYPE_CODE_FLT)\n     {\n@@ -387,7 +391,7 @@ m68k_svr4_store_return_value (struct type *type, struct regcache *regcache,\n static int\n m68k_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum type_code code = type->code ();\n   int len = TYPE_LENGTH (type);\n \n@@ -465,6 +469,7 @@ m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\tgdb_byte *readbuf, const gdb_byte *writebuf)\n {\n   enum type_code code = type->code ();\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Aggregates with a single member are always returned like their\n      sole element.  */\n@@ -480,7 +485,7 @@ m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,\n \t|| code == TYPE_CODE_COMPLEX || code == TYPE_CODE_ARRAY)\n        && !m68k_reg_struct_return_p (gdbarch, type))\n       /* GCC may return a `long double' in memory too.  */\n-      || (!gdbarch_tdep (gdbarch)->float_return\n+      || (!tdep->float_return\n \t  && code == TYPE_CODE_FLT\n \t  && TYPE_LENGTH (type) == 12))\n     {\n@@ -500,7 +505,6 @@ m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,\n \n       if (readbuf)\n \t{\n-\t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \t  ULONGEST addr;\n \n \t  regcache_raw_read_unsigned (regcache, tdep->pointer_result_regnum,\n@@ -537,7 +541,7 @@ m68k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t      function_call_return_method return_method,\n \t\t      CORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   gdb_byte buf[4];\n   int i;\n@@ -592,13 +596,15 @@ m68k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n static int\n m68k_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int num)\n {\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n   if (num < 8)\n     /* d0..7 */\n     return (num - 0) + M68K_D0_REGNUM;\n   else if (num < 16)\n     /* a0..7 */\n     return (num - 8) + M68K_A0_REGNUM;\n-  else if (num < 24 && gdbarch_tdep (gdbarch)->fpregs_present)\n+  else if (num < 24 && tdep->fpregs_present)\n     /* fp0..7 */\n     return (num - 16) + M68K_FP0_REGNUM;\n   else if (num == 25)\n@@ -760,6 +766,7 @@ m68k_analyze_register_saves (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t\t\t     struct m68k_frame_cache *cache)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (cache->locals >= 0)\n     {\n@@ -772,7 +779,7 @@ m68k_analyze_register_saves (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t{\n \t  op = read_memory_unsigned_integer (pc, 2, byte_order);\n \t  if (op == P_FMOVEMX_SP\n-\t      && gdbarch_tdep (gdbarch)->fpregs_present)\n+\t      && tdep->fpregs_present)\n \t    {\n \t      /* fmovem.x REGS,-(%sp) */\n \t      op = read_memory_unsigned_integer (pc + 2, 2, byte_order);\n@@ -1051,7 +1058,7 @@ m68k_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n   gdb_byte *buf;\n   CORE_ADDR sp, jb_addr;\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   if (tdep->jb_pc < 0)\n@@ -1097,7 +1104,7 @@ m68k_return_in_first_hidden_param_p (struct gdbarch *gdbarch,\n void\n m68k_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* SVR4 uses a different calling convention.  */\n   set_gdbarch_return_value (gdbarch, m68k_svr4_return_value);\n@@ -1115,7 +1122,7 @@ m68k_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n static void\n m68k_embedded_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   m68k_svr4_init_abi (info, gdbarch);\n   tdep->pointer_result_regnum = M68K_D0_REGNUM;\n@@ -1130,7 +1137,6 @@ m68k_embedded_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n static struct gdbarch *\n m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep = NULL;\n   struct gdbarch *gdbarch;\n   struct gdbarch_list *best_arch;\n   tdesc_arch_data_up tdesc_data;\n@@ -1230,13 +1236,16 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        best_arch != NULL;\n        best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))\n     {\n-      if (flavour != gdbarch_tdep (best_arch->gdbarch)->flavour)\n+      m68k_gdbarch_tdep *tdep\n+\t= (m68k_gdbarch_tdep *) gdbarch_tdep (best_arch->gdbarch);\n+\n+      if (flavour != tdep->flavour)\n \tcontinue;\n \n-      if (has_fp != gdbarch_tdep (best_arch->gdbarch)->fpregs_present)\n+      if (has_fp != tdep->fpregs_present)\n \tcontinue;\n \n-      if (float_return != gdbarch_tdep (best_arch->gdbarch)->float_return)\n+      if (float_return != tdep->float_return)\n \tcontinue;\n \n       break;\n@@ -1245,7 +1254,7 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   if (best_arch != NULL)\n     return best_arch->gdbarch;\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  m68k_gdbarch_tdep *tdep = new m68k_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   tdep->fpregs_present = has_fp;\n   tdep->float_return = float_return;\n@@ -1330,7 +1339,7 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n static void\n m68k_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  m68k_gdbarch_tdep *tdep = (m68k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep == NULL)\n     return;"
    },
    {
      "sha": "c88e7f26da5a70baf02e047cb067ee7c7833667b",
      "filename": "gdb/m68k-tdep.h",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68k-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/m68k-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -67,38 +67,38 @@ enum m68k_flavour\n \n /* Target-dependent structure in gdbarch.  */\n \n-struct gdbarch_tdep\n+struct m68k_gdbarch_tdep : gdbarch_tdep\n {\n   /* Offset to PC value in the jump buffer.  If this is negative,\n      longjmp support will be disabled.  */\n-  int jb_pc;\n+  int jb_pc = 0;\n   /* The size of each entry in the jump buffer.  */\n-  size_t jb_elt_size;\n+  size_t jb_elt_size = 0;\n \n   /* Register in which the address to store a structure value is\n      passed to a function.  */\n-  int struct_value_regnum;\n+  int struct_value_regnum = 0;\n \n   /* Register in which a pointer value is returned.  In the SVR4 ABI,\n      this is %a0, but in GCC's \"embedded\" ABI, this is %d0.  */\n-  int pointer_result_regnum;\n+  int pointer_result_regnum = 0;\n \n   /* Convention for returning structures.  */\n-  enum struct_return struct_return;\n+  enum struct_return struct_return {};\n \n   /* Convention for returning floats.  zero in int regs, non-zero in float.  */\n-  int float_return;\n+  int float_return = 0;\n \n   /* The particular flavour of m68k.  */\n-  enum m68k_flavour flavour;\n+  enum m68k_flavour flavour {};\n \n   /* Flag set if the floating point registers are present, or assumed\n      to be present.  */\n-  int fpregs_present;\n+  int fpregs_present = 0;\n \n    /* ISA-specific data types.  */\n-  struct type *m68k_ps_type;\n-  struct type *m68881_ext_type;\n+  struct type *m68k_ps_type = nullptr;\n+  struct type *m68881_ext_type = nullptr;\n };\n \n /* Initialize a SVR4 architecture variant.  */"
    },
    {
      "sha": "6d1f04a2ab2c76ea36756878b821eb2fab21235c",
      "filename": "gdb/mep-tdep.c",
      "status": "modified",
      "additions": 19,
      "deletions": 9,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mep-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mep-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mep-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -116,15 +116,15 @@\n      options are present on the current processor.  */\n \n \n-struct gdbarch_tdep\n+struct mep_gdbarch_tdep : gdbarch_tdep\n {\n   /* A CGEN cpu descriptor for this BFD architecture and machine.\n \n      Note: this is *not* customized for any particular me_module; the\n      MeP libopcodes machinery actually puts off module-specific\n      customization until the last minute.  So this contains\n      information about all supported me_modules.  */\n-  CGEN_CPU_DESC cpu_desc;\n+  CGEN_CPU_DESC cpu_desc = nullptr;\n \n   /* The me_module index from the ELF file we used to select this\n      architecture, or CONFIG_NONE if there was none.\n@@ -140,7 +140,7 @@ struct gdbarch_tdep\n      create a separate instance of the gdbarch structure for each\n      me_module value mep_gdbarch_init sees, and store the me_module\n      value from the ELF file here.  */\n-  CONFIG_ATTR me_module;\n+  CONFIG_ATTR me_module {};\n };\n \n \n@@ -259,7 +259,9 @@ me_module_register_set (CONFIG_ATTR me_module,\n        mask contains any of the me_module's coprocessor ISAs,\n        specifically excluding the generic coprocessor register sets.  */\n \n-  CGEN_CPU_DESC desc = gdbarch_tdep (target_gdbarch ())->cpu_desc;\n+  mep_gdbarch_tdep *tdep\n+    = (mep_gdbarch_tdep *) gdbarch_tdep (target_gdbarch ());\n+  CGEN_CPU_DESC desc = tdep->cpu_desc;\n   const CGEN_HW_ENTRY *hw;\n \n   if (me_module == CONFIG_NONE)\n@@ -852,7 +854,11 @@ current_me_module (void)\n       return (CONFIG_ATTR) regval;\n     }\n   else\n-    return gdbarch_tdep (target_gdbarch ())->me_module;\n+    {\n+      mep_gdbarch_tdep *tdep\n+\t= (mep_gdbarch_tdep *) gdbarch_tdep (target_gdbarch ());\n+      return tdep->me_module;\n+    }\n }\n \n \n@@ -2326,7 +2332,6 @@ static struct gdbarch *\n mep_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n \n   /* Which me_module are we building a gdbarch object for?  */\n   CONFIG_ATTR me_module;\n@@ -2384,10 +2389,15 @@ mep_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   for (arches = gdbarch_list_lookup_by_info (arches, &info); \n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n-    if (gdbarch_tdep (arches->gdbarch)->me_module == me_module)\n-      return arches->gdbarch;\n+    {\n+      mep_gdbarch_tdep *tdep\n+\t= (mep_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n+      if (tdep->me_module == me_module)\n+\treturn arches->gdbarch;\n+    }\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  mep_gdbarch_tdep *tdep = new mep_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* Get a CGEN CPU descriptor for this architecture.  */"
    },
    {
      "sha": "5309da58cc29168547fe871e16bfadd5bf97fbe6",
      "filename": "gdb/microblaze-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/microblaze-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/microblaze-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/microblaze-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -650,7 +650,6 @@ microblaze_register_g_packet_guesses (struct gdbarch *gdbarch)\n static struct gdbarch *\n microblaze_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n   tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n@@ -697,7 +696,7 @@ microblaze_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     }\n \n   /* Allocate space for the new architecture.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  microblaze_gdbarch_tdep *tdep = new microblaze_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   set_gdbarch_long_double_bit (gdbarch, 128);"
    },
    {
      "sha": "3143e92ac74d5ddef1bbe24aad100aad5959e457",
      "filename": "gdb/microblaze-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/microblaze-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/microblaze-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/microblaze-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -22,7 +22,7 @@\n \n \n /* Microblaze architecture-specific information.  */\n-struct gdbarch_tdep\n+struct microblaze_gdbarch_tdep : gdbarch_tdep\n {\n };\n "
    },
    {
      "sha": "9eac3d763ba2318ee59cc90bef8257c21c19bba0",
      "filename": "gdb/mips-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mips-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mips-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -1317,7 +1317,7 @@ mips_linux_get_syscall_number (struct gdbarch *gdbarch,\n \t\t\t       thread_info *thread)\n {\n   struct regcache *regcache = get_thread_regcache (thread);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int regsize = register_size (gdbarch, MIPS_V0_REGNUM);\n   /* The content of a register */\n@@ -1527,7 +1527,7 @@ static void\n mips_linux_init_abi (struct gdbarch_info info,\n \t\t     struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum mips_abi abi = mips_abi (gdbarch);\n   struct tdesc_arch_data *tdesc_data = info.tdesc_data;\n "
    },
    {
      "sha": "603c5d2664b39ebafa8a8cdafae2c2ca8411b110",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 102,
      "deletions": 62,
      "changes": 164,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -227,7 +227,8 @@ static const char mips_disassembler_options_n64[] = \"gpr-names=64\";\n const struct mips_regnum *\n mips_regnum (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->regnum;\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->regnum;\n }\n \n static int\n@@ -248,29 +249,47 @@ mips_float_register_p (struct gdbarch *gdbarch, int regnum)\n \t  && rawnum < mips_regnum (gdbarch)->fp0 + 32);\n }\n \n-#define MIPS_EABI(gdbarch) (gdbarch_tdep (gdbarch)->mips_abi \\\n-\t\t     == MIPS_ABI_EABI32 \\\n-\t\t   || gdbarch_tdep (gdbarch)->mips_abi == MIPS_ABI_EABI64)\n+static bool\n+mips_eabi (gdbarch *arch)\n+{\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (arch);\n+  return (tdep->mips_abi == MIPS_ABI_EABI32 \\\n+\t  || tdep->mips_abi == MIPS_ABI_EABI64);\n+}\n \n-#define MIPS_LAST_FP_ARG_REGNUM(gdbarch) \\\n-  (gdbarch_tdep (gdbarch)->mips_last_fp_arg_regnum)\n+static int\n+mips_last_fp_arg_regnum (gdbarch *arch)\n+{\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (arch);\n+  return tdep->mips_last_fp_arg_regnum;\n+}\n \n-#define MIPS_LAST_ARG_REGNUM(gdbarch) \\\n-  (gdbarch_tdep (gdbarch)->mips_last_arg_regnum)\n+static int\n+mips_last_arg_regnum (gdbarch *arch)\n+{\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (arch);\n+  return tdep->mips_last_arg_regnum;\n+}\n \n-#define MIPS_FPU_TYPE(gdbarch) (gdbarch_tdep (gdbarch)->mips_fpu_type)\n+static enum mips_fpu_type\n+mips_get_fpu_type (gdbarch *arch)\n+{\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (arch);\n+  return tdep->mips_fpu_type;\n+}\n \n /* Return the MIPS ABI associated with GDBARCH.  */\n enum mips_abi\n mips_abi (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->mips_abi;\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->mips_abi;\n }\n \n int\n mips_isa_regsize (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* If we know how big the registers are, use that size.  */\n   if (tdep->register_size_valid_p)\n@@ -316,15 +335,17 @@ mips_abi_regsize (struct gdbarch *gdbarch)\n static int\n is_mips16_isa (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->mips_isa == ISA_MIPS16;\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->mips_isa == ISA_MIPS16;\n }\n \n /* Return one iff compressed code is the microMIPS instruction set.  */\n \n static int\n is_micromips_isa (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->mips_isa == ISA_MICROMIPS;\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->mips_isa == ISA_MICROMIPS;\n }\n \n /* Return one iff ADDR denotes compressed code.  */\n@@ -615,7 +636,7 @@ static const char * const mips_linux_reg_names[NUM_MIPS_PROCESSOR_REGS] = {\n static const char *\n mips_register_name (struct gdbarch *gdbarch, int regno)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   /* GPR names for all ABIs other than n32/n64.  */\n   static const char *mips_gpr_names[] = {\n     \"zero\", \"at\", \"v0\", \"v1\", \"a0\", \"a1\", \"a2\", \"a3\",\n@@ -756,7 +777,9 @@ mips_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n   else if (register_size (gdbarch, rawnum) >\n \t   register_size (gdbarch, cookednum))\n     {\n-      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)\n+      mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+      if (tdep->mips64_transfers_32bit_regs_p)\n \treturn regcache->raw_read_part (rawnum, 0, 4, buf);\n       else\n \t{\n@@ -787,7 +810,9 @@ mips_pseudo_register_write (struct gdbarch *gdbarch,\n   else if (register_size (gdbarch, rawnum) >\n \t   register_size (gdbarch, cookednum))\n     {\n-      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)\n+      mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+      if (tdep->mips64_transfers_32bit_regs_p)\n \tregcache->raw_write_part (rawnum, 0, 4, buf);\n       else\n \t{\n@@ -829,7 +854,10 @@ mips_ax_pseudo_register_push_stack (struct gdbarch *gdbarch,\n \n       if (register_size (gdbarch, rawnum) > register_size (gdbarch, reg))\n \t{\n-\t  if (!gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p\n+\t  mips_gdbarch_tdep *tdep\n+\t    = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+\t  if (!tdep->mips64_transfers_32bit_regs_p\n \t      || gdbarch_byte_order (gdbarch) != BFD_ENDIAN_BIG)\n \t    {\n \t      ax_const_l (ax, 32);\n@@ -1031,6 +1059,7 @@ mips_register_type (struct gdbarch *gdbarch, int regnum)\n   else\n     {\n       int rawnum = regnum - gdbarch_num_regs (gdbarch);\n+      mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n       /* The cooked or ABI registers.  These are sized according to\n \t the ABI (with a few complications).  */\n@@ -1043,7 +1072,7 @@ mips_register_type (struct gdbarch *gdbarch, int regnum)\n \t/* The pseudo/cooked view of the embedded registers is always\n \t   32-bit.  The raw view is handled below.  */\n \treturn builtin_type (gdbarch)->builtin_int32;\n-      else if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)\n+      else if (tdep->mips64_transfers_32bit_regs_p)\n \t/* The target, while possibly using a 64-bit register buffer,\n \t   is only transfering 32-bits of each integer register.\n \t   Reflect this in the cooked/pseudo (ABI) register value.  */\n@@ -1132,7 +1161,7 @@ mips_pseudo_register_type (struct gdbarch *gdbarch, int regnum)\n static enum auto_boolean mask_address_var = AUTO_BOOLEAN_AUTO;\n \n static int\n-mips_mask_address_p (struct gdbarch_tdep *tdep)\n+mips_mask_address_p (mips_gdbarch_tdep *tdep)\n {\n   switch (mask_address_var)\n     {\n@@ -1154,7 +1183,8 @@ static void\n show_mask_address (struct ui_file *file, int from_tty,\n \t\t   struct cmd_list_element *c, const char *value)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch ());\n+  mips_gdbarch_tdep *tdep\n+    = (mips_gdbarch_tdep *) gdbarch_tdep (target_gdbarch ());\n \n   deprecated_show_value_hack (file, from_tty, c, value);\n   switch (mask_address_var)\n@@ -1698,9 +1728,9 @@ mips32_next_pc (struct regcache *regcache, CORE_ADDR pc)\n \t      break;\n \t    case 12:            /* SYSCALL */\n \t      {\n-\t\tstruct gdbarch_tdep *tdep;\n+\t\tmips_gdbarch_tdep *tdep\n+\t\t  = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n-\t\ttdep = gdbarch_tdep (gdbarch);\n \t\tif (tdep->syscall_next_pc != NULL)\n \t\t  pc = tdep->syscall_next_pc (get_current_frame ());\n \t\telse\n@@ -1909,9 +1939,9 @@ micromips_next_pc (struct regcache *regcache, CORE_ADDR pc)\n \t\t  break;\n \t\tcase 0x22d: /* SYSCALL:  000000 1000101101 111100 */\n \t\t  {\n-\t\t    struct gdbarch_tdep *tdep;\n+\t\t    mips_gdbarch_tdep *tdep\n+\t\t      = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n-\t\t    tdep = gdbarch_tdep (gdbarch);\n \t\t    if (tdep->syscall_next_pc != NULL)\n \t\t      pc = tdep->syscall_next_pc (get_current_frame ());\n \t\t  }\n@@ -3870,7 +3900,7 @@ mips_stub_frame_base_sniffer (struct frame_info *this_frame)\n static CORE_ADDR\n mips_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (mips_mask_address_p (tdep) && (((ULONGEST) addr) >> 32 == 0xffffffffUL))\n     /* This hack is a work-around for existing boards using PMON, the\n@@ -4405,13 +4435,13 @@ fp_register_arg_p (struct gdbarch *gdbarch, enum type_code typecode,\n \t\t   struct type *arg_type)\n {\n   return ((typecode == TYPE_CODE_FLT\n-\t   || (MIPS_EABI (gdbarch)\n+\t   || (mips_eabi (gdbarch)\n \t       && (typecode == TYPE_CODE_STRUCT\n \t\t   || typecode == TYPE_CODE_UNION)\n \t       && arg_type->num_fields () == 1\n \t       && check_typedef (arg_type->field (0).type ())->code ()\n \t       == TYPE_CODE_FLT))\n-\t  && MIPS_FPU_TYPE(gdbarch) != MIPS_FPU_NONE);\n+\t  && mips_get_fpu_type (gdbarch) != MIPS_FPU_NONE);\n }\n \n /* On o32, argument passing in GPRs depends on the alignment of the type being\n@@ -4611,7 +4641,7 @@ mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t point value into an FP register instead of pushing it onto the\n \t stack.  */\n       if (fp_register_arg_p (gdbarch, typecode, arg_type)\n-\t  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM (gdbarch))\n+\t  && float_argreg <= mips_last_fp_arg_regnum (gdbarch))\n \t{\n \t  /* EABI32 will pass doubles in consecutive registers, even on\n \t     64-bit cores.  At one time, we used to check the size of\n@@ -4678,7 +4708,7 @@ mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\t    partial_len);\n \n \t      /* Write this portion of the argument to the stack.  */\n-\t      if (argreg > MIPS_LAST_ARG_REGNUM (gdbarch)\n+\t      if (argreg > mips_last_arg_regnum (gdbarch)\n \t\t  || odd_sized_struct\n \t\t  || fp_register_arg_p (gdbarch, typecode, arg_type))\n \t\t{\n@@ -4729,7 +4759,7 @@ mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t arguments will not.  */\n \t      /* Write this portion of the argument to a general\n \t\t purpose register.  */\n-\t      if (argreg <= MIPS_LAST_ARG_REGNUM (gdbarch)\n+\t      if (argreg <= mips_last_arg_regnum (gdbarch)\n \t\t  && !fp_register_arg_p (gdbarch, typecode, arg_type))\n \t\t{\n \t\t  LONGEST regval =\n@@ -4773,7 +4803,7 @@ mips_eabi_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\tstruct type *type, struct regcache *regcache,\n \t\t\tgdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int fp_return_type = 0;\n   int offset, regnum, xfer;\n \n@@ -4845,7 +4875,7 @@ mips_n32n64_fp_arg_chunk_p (struct gdbarch *gdbarch, struct type *arg_type,\n   if (arg_type->code () != TYPE_CODE_STRUCT)\n     return 0;\n \n-  if (MIPS_FPU_TYPE (gdbarch) != MIPS_FPU_DOUBLE)\n+  if (mips_get_fpu_type (gdbarch) != MIPS_FPU_DOUBLE)\n     return 0;\n \n   if (TYPE_LENGTH (arg_type) < offset + MIPS64_REGSIZE)\n@@ -4973,7 +5003,7 @@ mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t}\n \n       if (fp_register_arg_p (gdbarch, typecode, arg_type)\n-\t  && argreg <= MIPS_LAST_ARG_REGNUM (gdbarch))\n+\t  && argreg <= mips_last_arg_regnum (gdbarch))\n \t{\n \t  /* This is a floating point value that fits entirely\n \t     in a single register or a pair of registers.  */\n@@ -5033,10 +5063,10 @@ mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\t    partial_len);\n \n \t      if (fp_register_arg_p (gdbarch, typecode, arg_type))\n-\t\tgdb_assert (argreg > MIPS_LAST_ARG_REGNUM (gdbarch));\n+\t\tgdb_assert (argreg > mips_last_arg_regnum (gdbarch));\n \n \t      /* Write this portion of the argument to the stack.  */\n-\t      if (argreg > MIPS_LAST_ARG_REGNUM (gdbarch))\n+\t      if (argreg > mips_last_arg_regnum (gdbarch))\n \t\t{\n \t\t  /* Should shorter than int integer values be\n \t\t     promoted to int before being stored?  */\n@@ -5079,7 +5109,7 @@ mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t structs may go thru BOTH paths.  */\n \t      /* Write this portion of the argument to a general\n \t\t purpose register.  */\n-\t      if (argreg <= MIPS_LAST_ARG_REGNUM (gdbarch))\n+\t      if (argreg <= mips_last_arg_regnum (gdbarch))\n \t\t{\n \t\t  LONGEST regval;\n \n@@ -5164,7 +5194,7 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\t  struct type *type, struct regcache *regcache,\n \t\t\t  gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* From MIPSpro N32 ABI Handbook, Document Number: 007-2816-004\n \n@@ -5451,7 +5481,7 @@ mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t registers are normally skipped.  */\n \n       if (fp_register_arg_p (gdbarch, typecode, arg_type)\n-\t  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM (gdbarch))\n+\t  && float_argreg <= mips_last_fp_arg_regnum (gdbarch))\n \t{\n \t  if (register_size (gdbarch, float_argreg) < 8 && len == 8)\n \t    {\n@@ -5541,7 +5571,7 @@ mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\t    partial_len);\n \n \t      /* Write this portion of the argument to the stack.  */\n-\t      if (argreg > MIPS_LAST_ARG_REGNUM (gdbarch)\n+\t      if (argreg > mips_last_arg_regnum (gdbarch)\n \t\t  || odd_sized_struct)\n \t\t{\n \t\t  /* Should shorter than int integer values be\n@@ -5577,7 +5607,7 @@ mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t structs may go thru BOTH paths.  */\n \t      /* Write this portion of the argument to a general\n \t\t purpose register.  */\n-\t      if (argreg <= MIPS_LAST_ARG_REGNUM (gdbarch))\n+\t      if (argreg <= mips_last_arg_regnum (gdbarch))\n \t\t{\n \t\t  LONGEST regval = extract_signed_integer (val, partial_len,\n \t\t\t\t\t\t\t   byte_order);\n@@ -5625,7 +5655,7 @@ mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n \t\t  /* Prevent subsequent floating point arguments from\n \t\t     being passed in floating point registers.  */\n-\t\t  float_argreg = MIPS_LAST_FP_ARG_REGNUM (gdbarch) + 1;\n+\t\t  float_argreg = mips_last_fp_arg_regnum (gdbarch) + 1;\n \t\t}\n \n \t      len -= partial_len;\n@@ -5659,7 +5689,7 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n {\n   CORE_ADDR func_addr = function ? find_function_addr (function, NULL) : 0;\n   int mips16 = mips_pc_is_mips16 (gdbarch, func_addr);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum mips_fval_reg fval_reg;\n \n   fval_reg = readbuf ? mips16 ? mips_fval_gpr : mips_fval_fpr : mips_fval_both;\n@@ -5960,7 +5990,7 @@ mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t functions because those registers are normally skipped.  */\n \n       if (fp_register_arg_p (gdbarch, typecode, arg_type)\n-\t  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM (gdbarch))\n+\t  && float_argreg <= mips_last_fp_arg_regnum (gdbarch))\n \t{\n \t  LONGEST regval = extract_unsigned_integer (val, len, byte_order);\n \t  if (mips_debug)\n@@ -5995,7 +6025,7 @@ mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\t    partial_len);\n \n \t      /* Write this portion of the argument to the stack.  */\n-\t      if (argreg > MIPS_LAST_ARG_REGNUM (gdbarch)\n+\t      if (argreg > mips_last_arg_regnum (gdbarch)\n \t\t  || odd_sized_struct)\n \t\t{\n \t\t  /* Should shorter than int integer values be\n@@ -6039,7 +6069,7 @@ mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t structs may go thru BOTH paths.  */\n \t      /* Write this portion of the argument to a general\n \t\t purpose register.  */\n-\t      if (argreg <= MIPS_LAST_ARG_REGNUM (gdbarch))\n+\t      if (argreg <= mips_last_arg_regnum (gdbarch))\n \t\t{\n \t\t  LONGEST regval = extract_signed_integer (val, partial_len,\n \t\t\t\t\t\t\t   byte_order);\n@@ -6071,7 +6101,7 @@ mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n \t\t  /* Prevent subsequent floating point arguments from\n \t\t     being passed in floating point registers.  */\n-\t\t  float_argreg = MIPS_LAST_FP_ARG_REGNUM (gdbarch) + 1;\n+\t\t  float_argreg = mips_last_fp_arg_regnum (gdbarch) + 1;\n \t\t}\n \n \t      len -= partial_len;\n@@ -6403,7 +6433,7 @@ mips_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,\n \t\t      struct frame_info *frame, const char *args)\n {\n   int fcsr = mips_regnum (gdbarch)->fp_control_status;\n-  enum mips_fpu_type type = MIPS_FPU_TYPE (gdbarch);\n+  enum mips_fpu_type type = mips_get_fpu_type (gdbarch);\n   ULONGEST fcs = 0;\n   int i;\n \n@@ -6891,7 +6921,7 @@ show_mipsfpu_command (const char *args, int from_tty)\n       return;\n     }\n \n-  switch (MIPS_FPU_TYPE (target_gdbarch ()))\n+  switch (mips_get_fpu_type (target_gdbarch ()))\n     {\n     case MIPS_FPU_SINGLE:\n       fpu = \"single-precision\";\n@@ -8038,7 +8068,6 @@ static struct gdbarch *\n mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int elf_flags;\n   enum mips_abi mips_abi, found_abi, wanted_abi;\n   int i, num_regs;\n@@ -8055,7 +8084,11 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   if (info.abfd && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)\n     elf_flags = elf_elfheader (info.abfd)->e_flags;\n   else if (arches != NULL)\n-    elf_flags = gdbarch_tdep (arches->gdbarch)->elf_flags;\n+    {\n+      mips_gdbarch_tdep *tdep\n+\t= (mips_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+      elf_flags = tdep->elf_flags;\n+    }\n   else\n     elf_flags = 0;\n   if (gdbarch_debug)\n@@ -8092,7 +8125,11 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* If we have no useful BFD information, use the ABI from the last\n      MIPS architecture (if there is one).  */\n   if (found_abi == MIPS_ABI_UNKNOWN && info.abfd == NULL && arches != NULL)\n-    found_abi = gdbarch_tdep (arches->gdbarch)->found_abi;\n+    {\n+      mips_gdbarch_tdep *tdep\n+\t= (mips_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+      found_abi = tdep->found_abi;\n+    }\n \n   /* Try the architecture for any hint of the correct ABI.  */\n   if (found_abi == MIPS_ABI_UNKNOWN\n@@ -8223,7 +8260,7 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \tbreak;\n       }\n   else if (arches != NULL)\n-    fpu_type = MIPS_FPU_TYPE (arches->gdbarch);\n+    fpu_type = mips_get_fpu_type (arches->gdbarch);\n   else\n     fpu_type = MIPS_FPU_DOUBLE;\n   if (gdbarch_debug)\n@@ -8406,28 +8443,31 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n+      mips_gdbarch_tdep *tdep\n+        = (mips_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n       /* MIPS needs to be pedantic about which ABI and the compressed\n \t ISA variation the object is using.  */\n-      if (gdbarch_tdep (arches->gdbarch)->elf_flags != elf_flags)\n+      if (tdep->elf_flags != elf_flags)\n \tcontinue;\n-      if (gdbarch_tdep (arches->gdbarch)->mips_abi != mips_abi)\n+      if (tdep->mips_abi != mips_abi)\n \tcontinue;\n-      if (gdbarch_tdep (arches->gdbarch)->mips_isa != mips_isa)\n+      if (tdep->mips_isa != mips_isa)\n \tcontinue;\n       /* Need to be pedantic about which register virtual size is\n \t used.  */\n-      if (gdbarch_tdep (arches->gdbarch)->mips64_transfers_32bit_regs_p\n+      if (tdep->mips64_transfers_32bit_regs_p\n \t  != mips64_transfers_32bit_regs_p)\n \tcontinue;\n       /* Be pedantic about which FPU is selected.  */\n-      if (MIPS_FPU_TYPE (arches->gdbarch) != fpu_type)\n+      if (mips_get_fpu_type (arches->gdbarch) != fpu_type)\n \tcontinue;\n \n       return arches->gdbarch;\n     }\n \n   /* Need a new architecture.  Fill in a target specific vector.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  mips_gdbarch_tdep *tdep = new mips_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   tdep->elf_flags = elf_flags;\n   tdep->mips64_transfers_32bit_regs_p = mips64_transfers_32bit_regs_p;\n@@ -8862,7 +8902,7 @@ mips_fpu_type_str (enum mips_fpu_type fpu_type)\n static void\n mips_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mips_gdbarch_tdep *tdep = (mips_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (tdep != NULL)\n     {\n       int ef_mips_arch;\n@@ -8911,11 +8951,11 @@ mips_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n \t\t      MIPS_DEFAULT_FPU_TYPE,\n \t\t      mips_fpu_type_str (MIPS_DEFAULT_FPU_TYPE));\n   fprintf_unfiltered (file, \"mips_dump_tdep: MIPS_EABI = %d\\n\",\n-\t\t      MIPS_EABI (gdbarch));\n+\t\t      mips_eabi (gdbarch));\n   fprintf_unfiltered (file,\n \t\t      \"mips_dump_tdep: MIPS_FPU_TYPE = %d (%s)\\n\",\n-\t\t      MIPS_FPU_TYPE (gdbarch),\n-\t\t      mips_fpu_type_str (MIPS_FPU_TYPE (gdbarch)));\n+\t\t      mips_get_fpu_type (gdbarch),\n+\t\t      mips_fpu_type_str (mips_get_fpu_type (gdbarch)));\n }\n \n void _initialize_mips_tdep ();"
    },
    {
      "sha": "b899cfd9bdb1249c7a4c82a59d4e683b8ace99a7",
      "filename": "gdb/mips-tdep.h",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mips-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mips-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -83,39 +83,39 @@ enum mips_fpu_type\n };\n \n /* MIPS specific per-architecture information.  */\n-struct gdbarch_tdep\n+struct mips_gdbarch_tdep : gdbarch_tdep\n {\n   /* from the elf header */\n-  int elf_flags;\n+  int elf_flags = 0;\n \n   /* mips options */\n-  enum mips_abi mips_abi;\n-  enum mips_abi found_abi;\n-  enum mips_isa mips_isa;\n-  enum mips_fpu_type mips_fpu_type;\n-  int mips_last_arg_regnum;\n-  int mips_last_fp_arg_regnum;\n-  int default_mask_address_p;\n+  enum mips_abi mips_abi {};\n+  enum mips_abi found_abi {};\n+  enum mips_isa mips_isa {};\n+  enum mips_fpu_type mips_fpu_type {};\n+  int mips_last_arg_regnum = 0;\n+  int mips_last_fp_arg_regnum = 0;\n+  int default_mask_address_p = 0;\n   /* Is the target using 64-bit raw integer registers but only\n      storing a left-aligned 32-bit value in each?  */\n-  int mips64_transfers_32bit_regs_p;\n+  int mips64_transfers_32bit_regs_p = 0;\n   /* Indexes for various registers.  IRIX and embedded have\n      different values.  This contains the \"public\" fields.  Don't\n      add any that do not need to be public.  */\n-  const struct mips_regnum *regnum;\n+  const struct mips_regnum *regnum = nullptr;\n   /* Register names table for the current register set.  */\n-  const char * const *mips_processor_reg_names;\n+  const char * const *mips_processor_reg_names = nullptr;\n \n   /* The size of register data available from the target, if known.\n      This doesn't quite obsolete the manual\n      mips64_transfers_32bit_regs_p, since that is documented to force\n      left alignment even for big endian (very strange).  */\n-  int register_size_valid_p;\n-  int register_size;\n+  int register_size_valid_p = 0;\n+  int register_size = 0;\n \n   /* Return the expected next PC if FRAME is stopped at a syscall\n      instruction.  */\n-  CORE_ADDR (*syscall_next_pc) (struct frame_info *frame);\n+  CORE_ADDR (*syscall_next_pc) (struct frame_info *frame) = nullptr;\n };\n \n /* Register numbers of various important registers.  */"
    },
    {
      "sha": "5804efeb62709669d6ab284802e84aa6de15b1b9",
      "filename": "gdb/mn10300-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mn10300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mn10300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -372,7 +372,7 @@ mn10300_analyze_prologue (struct gdbarch *gdbarch,\n   int rn;\n   pv_t regs[MN10300_MAX_NUM_REGS];\n   CORE_ADDR after_last_frame_setup_insn = start_pc;\n-  int am33_mode = AM33_MODE (gdbarch);\n+  int am33_mode = get_am33_mode (gdbarch);\n \n   memset (result, 0, sizeof (*result));\n   result->gdbarch = gdbarch;\n@@ -1337,14 +1337,13 @@ mn10300_gdbarch_init (struct gdbarch_info info,\n \t\t      struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int num_regs;\n \n   arches = gdbarch_list_lookup_by_info (arches, &info);\n   if (arches != NULL)\n     return arches->gdbarch;\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  mn10300_gdbarch_tdep *tdep = new mn10300_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   switch (info.bfd_arch_info->mach)\n@@ -1413,7 +1412,7 @@ mn10300_gdbarch_init (struct gdbarch_info info,\n static void\n mn10300_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  mn10300_gdbarch_tdep *tdep = (mn10300_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   fprintf_unfiltered (file, \"mn10300_dump_tdep: am33_mode = %d\\n\",\n \t\t      tdep->am33_mode);\n }"
    },
    {
      "sha": "220e4d6739b098a09d94f1274c80e462b76992c4",
      "filename": "gdb/mn10300-tdep.h",
      "status": "modified",
      "additions": 9,
      "deletions": 2,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mn10300-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/mn10300-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,6 +20,8 @@\n #ifndef MN10300_TDEP_H\n #define MN10300_TDEP_H\n \n+#include \"gdbarch.h\"\n+\n enum {\n   E_D0_REGNUM = 0,\n   E_D1_REGNUM = 1,\n@@ -74,11 +76,16 @@ enum frame_kind {\n };\n \n /* mn10300 private data.  */\n-struct gdbarch_tdep\n+struct mn10300_gdbarch_tdep : gdbarch_tdep\n {\n   int am33_mode;\n };\n \n-#define AM33_MODE(gdbarch) (gdbarch_tdep (gdbarch)->am33_mode)\n+static inline int\n+get_am33_mode (gdbarch *arch)\n+{\n+  mn10300_gdbarch_tdep *tdep = (mn10300_gdbarch_tdep *) gdbarch_tdep (arch);\n+  return tdep->am33_mode;\n+}\n \n #endif /* MN10300_TDEP_H */"
    },
    {
      "sha": "459bfb8ee5a80d55d4fc7d1483032a459422e54a",
      "filename": "gdb/moxie-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/moxie-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/moxie-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/moxie-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -1052,15 +1052,14 @@ static struct gdbarch *\n moxie_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n \n   /* If there is already a candidate, use it.  */\n   arches = gdbarch_list_lookup_by_info (arches, &info);\n   if (arches != NULL)\n     return arches->gdbarch;\n \n   /* Allocate space for the new architecture.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  moxie_gdbarch_tdep *tdep = new moxie_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   set_gdbarch_wchar_bit (gdbarch, 32);"
    },
    {
      "sha": "4e6bcd1c1c95c86c74289f65e7cadb505a0b7663",
      "filename": "gdb/moxie-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/moxie-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/moxie-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/moxie-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,7 +20,7 @@\n #ifndef MOXIE_TDEP_H\n #define MOXIE_TDEP_H\n \n-struct gdbarch_tdep\n+struct moxie_gdbarch_tdep : gdbarch_tdep\n {\n   /* gdbarch target dependent data here.  Currently unused for MOXIE.  */\n };"
    },
    {
      "sha": "f3c44b71ba57374c5f1b99edecc2ec4d5312c258",
      "filename": "gdb/msp430-tdep.c",
      "status": "modified",
      "additions": 18,
      "deletions": 14,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/msp430-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/msp430-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/msp430-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -104,19 +104,19 @@ enum\n \n /* Architecture specific data.  */\n \n-struct gdbarch_tdep\n+struct msp430_gdbarch_tdep : gdbarch_tdep\n {\n   /* The ELF header flags specify the multilib used.  */\n-  int elf_flags;\n+  int elf_flags = 0;\n \n   /* One of MSP_ISA_MSP430 or MSP_ISA_MSP430X.  */\n-  int isa;\n+  int isa = 0;\n \n   /* One of MSP_SMALL_CODE_MODEL or MSP_LARGE_CODE_MODEL.  If, at\n      some point, we support different data models too, we'll probably\n      structure things so that we can combine values using logical\n      \"or\".  */\n-  int code_model;\n+  int code_model = 0;\n };\n \n /* This structure holds the results of a prologue analysis.  */\n@@ -340,7 +340,8 @@ msp430_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc,\n   int rn;\n   pv_t reg[MSP430_NUM_TOTAL_REGS];\n   CORE_ADDR after_last_frame_setup_insn = start_pc;\n-  int code_model = gdbarch_tdep (gdbarch)->code_model;\n+  msp430_gdbarch_tdep *tdep = (msp430_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int code_model = tdep->code_model;\n   int sz;\n \n   memset (result, 0, sizeof (*result));\n@@ -568,7 +569,8 @@ msp430_return_value (struct gdbarch *gdbarch,\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   LONGEST valtype_len = TYPE_LENGTH (valtype);\n-  int code_model = gdbarch_tdep (gdbarch)->code_model;\n+  msp430_gdbarch_tdep *tdep = (msp430_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int code_model = tdep->code_model;\n \n   if (TYPE_LENGTH (valtype) > 8\n       || valtype->code () == TYPE_CODE_STRUCT\n@@ -648,7 +650,8 @@ msp430_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   int write_pass;\n   int sp_off = 0;\n   CORE_ADDR cfa;\n-  int code_model = gdbarch_tdep (gdbarch)->code_model;\n+  msp430_gdbarch_tdep *tdep = (msp430_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int code_model = tdep->code_model;\n \n   struct type *func_type = value_type (function);\n \n@@ -766,8 +769,7 @@ msp430_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n   /* Push the return address.  */\n   {\n-    int sz = (gdbarch_tdep (gdbarch)->code_model == MSP_SMALL_CODE_MODEL)\n-      ? 2 : 4;\n+    int sz = tdep->code_model == MSP_SMALL_CODE_MODEL ? 2 : 4;\n     sp = sp - sz;\n     write_memory_unsigned_integer (sp, sz, byte_order, bp_addr);\n   }\n@@ -811,7 +813,8 @@ msp430_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)\n \n   stub_name = bms.minsym->linkage_name ();\n \n-  if (gdbarch_tdep (gdbarch)->code_model == MSP_SMALL_CODE_MODEL\n+  msp430_gdbarch_tdep *tdep = (msp430_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  if (tdep->code_model == MSP_SMALL_CODE_MODEL\n       && msp430_in_return_stub (gdbarch, pc, stub_name))\n     {\n       CORE_ADDR sp = get_frame_register_unsigned (frame, MSP430_SP_REGNUM);\n@@ -830,7 +833,6 @@ static struct gdbarch *\n msp430_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int elf_flags, isa, code_model;\n \n   /* Extract the elf_flags if available.  */\n@@ -873,7 +875,8 @@ msp430_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  struct gdbarch *ca = get_current_arch ();\n \t  if (ca && gdbarch_bfd_arch_info (ca)->arch == bfd_arch_msp430)\n \t    {\n-\t      struct gdbarch_tdep *ca_tdep = gdbarch_tdep (ca);\n+\t      msp430_gdbarch_tdep *ca_tdep\n+\t\t= (msp430_gdbarch_tdep *) gdbarch_tdep (ca);\n \n \t      elf_flags = ca_tdep->elf_flags;\n \t      isa = ca_tdep->isa;\n@@ -899,7 +902,8 @@ msp430_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      struct gdbarch_tdep *candidate_tdep = gdbarch_tdep (arches->gdbarch);\n+      msp430_gdbarch_tdep *candidate_tdep\n+\t= (msp430_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n \n       if (candidate_tdep->elf_flags != elf_flags\n \t  || candidate_tdep->isa != isa\n@@ -911,7 +915,7 @@ msp430_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* None found, create a new architecture from the information\n      provided.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  msp430_gdbarch_tdep *tdep = new msp430_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   tdep->elf_flags = elf_flags;\n   tdep->isa = isa;"
    },
    {
      "sha": "0360323d28cc2546d09eca2c07a10cba6156d02d",
      "filename": "gdb/nds32-tdep.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nds32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nds32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nds32-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -289,7 +289,7 @@ typedef BP_MANIPULATION (nds32_break_insn) nds32_breakpoint;\n static int\n nds32_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int num)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const int FSR = 38;\n   const int FDR = FSR + 32;\n \n@@ -440,7 +440,7 @@ nds32_pseudo_register_read (struct gdbarch *gdbarch,\n \t\t\t    readable_regcache *regcache, int regnum,\n \t\t\t    gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_byte reg_buf[8];\n   int offset, fdr_regnum;\n   enum register_status status;\n@@ -479,7 +479,7 @@ nds32_pseudo_register_write (struct gdbarch *gdbarch,\n \t\t\t     struct regcache *regcache, int regnum,\n \t\t\t     const gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_byte reg_buf[8];\n   int offset, fdr_regnum;\n \n@@ -616,7 +616,7 @@ static CORE_ADDR\n nds32_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t\t\tCORE_ADDR limit_pc, struct nds32_frame_cache *cache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int abi_use_fpr = nds32_abi_use_fpr (tdep->elf_abi);\n   /* Current scanning status.  */\n   int in_prologue_bb = 0;\n@@ -1177,7 +1177,7 @@ static int\n nds32_analyze_epilogue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t\t\tstruct nds32_frame_cache *cache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int abi_use_fpr = nds32_abi_use_fpr (tdep->elf_abi);\n   CORE_ADDR limit_pc;\n   uint32_t insn, insn_len;\n@@ -1228,7 +1228,7 @@ nds32_analyze_epilogue (struct gdbarch *gdbarch, CORE_ADDR pc,\n static int\n nds32_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int abi_use_fpr = nds32_abi_use_fpr (tdep->elf_abi);\n   int insn_type = INSN_NORMAL;\n   int ret_found = 0;\n@@ -1432,7 +1432,7 @@ nds32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   int i;\n   ULONGEST regval;\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct type *func_type = value_type (function);\n   int abi_use_fpr = nds32_abi_use_fpr (tdep->elf_abi);\n   int abi_split = nds32_abi_split (tdep->elf_abi);\n@@ -1660,7 +1660,7 @@ nds32_extract_return_value (struct gdbarch *gdbarch, struct type *type,\n \t\t\t    struct regcache *regcache, gdb_byte *valbuf)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int abi_use_fpr = nds32_abi_use_fpr (tdep->elf_abi);\n   int calling_use_fpr;\n   int len;\n@@ -1750,7 +1750,7 @@ nds32_store_return_value (struct gdbarch *gdbarch, struct type *type,\n \t\t\t  struct regcache *regcache, const gdb_byte *valbuf)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nds32_gdbarch_tdep *tdep = (nds32_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int abi_use_fpr = nds32_abi_use_fpr (tdep->elf_abi);\n   int calling_use_fpr;\n   int len;\n@@ -1955,7 +1955,6 @@ static struct gdbarch *\n nds32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch_list *best_arch;\n   tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n@@ -1973,7 +1972,8 @@ nds32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        best_arch != NULL;\n        best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))\n     {\n-      struct gdbarch_tdep *idep = gdbarch_tdep (best_arch->gdbarch);\n+      nds32_gdbarch_tdep *idep\n+\t= (nds32_gdbarch_tdep *) gdbarch_tdep (best_arch->gdbarch);\n \n       if (idep->elf_abi != elf_abi)\n \tcontinue;\n@@ -1995,7 +1995,7 @@ nds32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     return NULL;\n \n   /* Allocate space for the new architecture.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  nds32_gdbarch_tdep *tdep = new nds32_gdbarch_tdep;\n   tdep->fpu_freg = fpu_freg;\n   tdep->use_pseudo_fsrs = use_pseudo_fsrs;\n   tdep->fs0_regnum = -1;"
    },
    {
      "sha": "e06512323f9a632776ddfcf513a28d56988b0ee4",
      "filename": "gdb/nds32-tdep.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nds32-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nds32-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nds32-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -40,15 +40,15 @@ enum nds32_regnum\n   NDS32_FD0_REGNUM = NDS32_NUM_REGS,\n };\n \n-struct gdbarch_tdep\n+struct nds32_gdbarch_tdep : gdbarch_tdep\n {\n   /* The guessed FPU configuration.  */\n-  int fpu_freg;\n+  int fpu_freg = 0;\n   /* FSRs are defined as pseudo registers.  */\n-  int use_pseudo_fsrs;\n+  int use_pseudo_fsrs = 0;\n   /* Cached regnum of the first FSR (FS0).  */\n-  int fs0_regnum;\n+  int fs0_regnum = 0;\n   /* ELF ABI info.  */\n-  int elf_abi;\n+  int elf_abi = 0;\n };\n #endif /* NDS32_TDEP_H */"
    },
    {
      "sha": "2e360ba264e87b22d888908e922d9738e791381b",
      "filename": "gdb/nios2-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nios2-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nios2-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -217,7 +217,7 @@ nios2_linux_is_kernel_helper (CORE_ADDR pc)\n static void\n nios2_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nios2_gdbarch_tdep *tdep = (nios2_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 0);\n "
    },
    {
      "sha": "706b579ef174c80176aa72ba5926ca67821a114d",
      "filename": "gdb/nios2-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nios2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nios2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -2098,7 +2098,7 @@ static CORE_ADDR\n nios2_get_next_pc (struct regcache *regcache, CORE_ADDR pc)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nios2_gdbarch_tdep *tdep = (nios2_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   unsigned long mach = gdbarch_bfd_arch_info (gdbarch)->mach;\n   unsigned int insn;\n   const struct nios2_opcode *op = nios2_fetch_insn (gdbarch, pc, &insn);\n@@ -2221,7 +2221,7 @@ static int\n nios2_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n {\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  nios2_gdbarch_tdep *tdep = (nios2_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   CORE_ADDR jb_addr = get_frame_register_unsigned (frame, NIOS2_R4_REGNUM);\n   gdb_byte buf[4];\n@@ -2275,7 +2275,6 @@ static struct gdbarch *\n nios2_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int i;\n   tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n@@ -2313,7 +2312,7 @@ nios2_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* None found, create a new architecture from the information\n      provided.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  nios2_gdbarch_tdep *tdep = new nios2_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   /* longjmp support not enabled by default.  */"
    },
    {
      "sha": "96f186536e6905525872f3c1f68d8c903fb56df9",
      "filename": "gdb/nios2-tdep.h",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nios2-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/nios2-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,6 +20,8 @@\n #ifndef NIOS2_TDEP_H\n #define NIOS2_TDEP_H\n \n+#include \"gdbarch.h\"\n+\n /* Nios II ISA specific encodings and macros.  */\n #include \"opcode/nios2.h\"\n \n@@ -67,19 +69,19 @@\n #define NIOS2_CDX_OPCODE_SIZE 2\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct nios2_gdbarch_tdep : gdbarch_tdep\n {\n   /* Assumes FRAME is stopped at a syscall (trap) instruction; returns\n      the expected next PC.  */\n   CORE_ADDR (*syscall_next_pc) (struct frame_info *frame,\n-\t\t\t\tconst struct nios2_opcode *op);\n+\t\t\t\tconst struct nios2_opcode *op) = nullptr;\n \n   /* Returns true if PC points to a kernel helper function.  */\n-  bool (*is_kernel_helper) (CORE_ADDR pc);\n+  bool (*is_kernel_helper) (CORE_ADDR pc) = nullptr;\n \n   /* Offset to PC value in jump buffer.\n      If this is negative, longjmp support will be disabled.  */\n-  int jb_pc;\n+  int jb_pc = 0;\n };\n \n extern struct target_desc *tdesc_nios2_linux;"
    },
    {
      "sha": "346ee97c49b689b9aca46427109c5c964a73ccd5",
      "filename": "gdb/or1k-tdep.c",
      "status": "modified",
      "additions": 12,
      "deletions": 11,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/or1k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/or1k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/or1k-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -62,11 +62,11 @@ show_or1k_debug (struct ui_file *file, int from_tty,\n \n /* The target-dependent structure for gdbarch.  */\n \n-struct gdbarch_tdep\n+struct or1k_gdbarch_tdep : gdbarch_tdep\n {\n-  int bytes_per_word;\n-  int bytes_per_address;\n-  CGEN_CPU_DESC gdb_cgen_cpu_desc;\n+  int bytes_per_word = 0;\n+  int bytes_per_address = 0;\n+  CGEN_CPU_DESC gdb_cgen_cpu_desc = nullptr;\n };\n \n /* Support functions for the architecture definition.  */\n@@ -247,7 +247,8 @@ or1k_return_value (struct gdbarch *gdbarch, struct value *functype,\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   enum type_code rv_type = valtype->code ();\n   unsigned int rv_size = TYPE_LENGTH (valtype);\n-  int bpw = (gdbarch_tdep (gdbarch))->bytes_per_word;\n+  or1k_gdbarch_tdep *tdep = (or1k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int bpw = tdep->bytes_per_word;\n \n   /* Deal with struct/union as addresses.  If an array won't fit in a\n      single register it is returned as address.  Anything larger than 2\n@@ -351,7 +352,7 @@ or1k_delay_slot_p (struct gdbarch *gdbarch, CORE_ADDR pc)\n {\n   const CGEN_INSN *insn;\n   CGEN_FIELDS tmp_fields;\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  or1k_gdbarch_tdep *tdep = (or1k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   insn = cgen_lookup_insn (tdep->gdb_cgen_cpu_desc,\n \t\t\t   NULL,\n@@ -633,8 +634,9 @@ or1k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   int heap_offset = 0;\n   CORE_ADDR heap_sp = sp - 128;\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  int bpa = (gdbarch_tdep (gdbarch))->bytes_per_address;\n-  int bpw = (gdbarch_tdep (gdbarch))->bytes_per_word;\n+  or1k_gdbarch_tdep *tdep = (or1k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int bpa = tdep->bytes_per_address;\n+  int bpw = tdep->bytes_per_word;\n   struct type *func_type = value_type (function);\n \n   /* Return address */\n@@ -1140,7 +1142,6 @@ static struct gdbarch *\n or1k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   const struct bfd_arch_info *binfo;\n   tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n@@ -1155,7 +1156,7 @@ or1k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n      actually know which target we are talking to, but put in some defaults\n      for now.  */\n   binfo = info.bfd_arch_info;\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  or1k_gdbarch_tdep *tdep = new or1k_gdbarch_tdep;\n   tdep->bytes_per_word = binfo->bits_per_word / binfo->bits_per_byte;\n   tdep->bytes_per_address = binfo->bits_per_address / binfo->bits_per_byte;\n   gdbarch = gdbarch_alloc (&info, tdep);\n@@ -1283,7 +1284,7 @@ or1k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n static void\n or1k_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  or1k_gdbarch_tdep *tdep = (or1k_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (NULL == tdep)\n     return; /* Nothing to report */"
    },
    {
      "sha": "87d2a694e904f748ce50757a75ab6ee1e844a0c2",
      "filename": "gdb/ppc-fbsd-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-fbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -126,7 +126,7 @@ ppcfbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t      void *cb_data,\n \t\t\t\t      const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->wordsize == 4)\n     cb (\".reg\", 148, 148, &ppc32_fbsd_gregset, NULL, cb_data);\n@@ -200,7 +200,7 @@ static struct trad_frame_cache *\n ppcfbsd_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct trad_frame_cache *cache;\n   CORE_ADDR addr, base, func;\n   gdb_byte buf[PPC_INSN_SIZE];\n@@ -287,7 +287,7 @@ static CORE_ADDR\n ppcfbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n \t\t\t\t  CORE_ADDR lm_addr, CORE_ADDR offset)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct regcache *regcache;\n   int tp_offset, tp_regnum;\n \n@@ -319,7 +319,7 @@ ppcfbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n static void\n ppcfbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Generic FreeBSD support. */\n   fbsd_init_abi (info, gdbarch);"
    },
    {
      "sha": "6df2411397caedc5c6f06b3e58a341480c560315",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -332,7 +332,7 @@ ppc_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)\n {\n   unsigned int insnbuf[POWERPC32_PLT_CHECK_LEN];\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   CORE_ADDR target = 0;\n   int scan_limit, i;\n@@ -898,7 +898,7 @@ ppc_linux_vsxregset (void)\n const struct regset *\n ppc_linux_cgprregset (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->wordsize == 4)\n     {\n@@ -938,7 +938,7 @@ ppc_linux_collect_core_cpgrregset (const struct regset *regset,\n \t\t\t\t   int regnum, void *buf, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   const struct regset *cgprregset = ppc_linux_cgprregset (gdbarch);\n \n@@ -985,7 +985,7 @@ ppc_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t\tvoid *cb_data,\n \t\t\t\t\tconst struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int have_altivec = tdep->ppc_vr0_regnum != -1;\n   int have_vsx = tdep->ppc_vsr0_upper_regnum != -1;\n   int have_ppr = tdep->ppc_ppr_regnum != -1;\n@@ -1170,7 +1170,7 @@ ppc_linux_sigtramp_cache (struct frame_info *this_frame,\n   CORE_ADDR fpregs;\n   int i;\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   base = get_frame_register_unsigned (this_frame,\n@@ -1341,7 +1341,7 @@ ppc_linux_get_syscall_number (struct gdbarch *gdbarch,\n \t\t\t      thread_info *thread)\n {\n   struct regcache *regcache = get_thread_regcache (thread);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   /* Make sure we're in a 32- or 64-bit machine */\n@@ -1417,7 +1417,7 @@ static int\n ppc_linux_syscall_record (struct regcache *regcache)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   ULONGEST scnum;\n   enum gdb_syscall syscall_gdb;\n   int ret;\n@@ -1506,7 +1506,7 @@ ppc_linux_record_signal (struct gdbarch *gdbarch, struct regcache *regcache,\n   const int SIGNAL_FRAMESIZE = 128;\n   const int sizeof_rt_sigframe = 1440 * 2 + 8 * 2 + 4 * 6 + 8 + 8 + 128 + 512;\n   ULONGEST sp;\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int i;\n \n   for (i = 3; i <= 12; i++)\n@@ -2018,7 +2018,7 @@ static void\n ppc_linux_init_abi (struct gdbarch_info info,\n \t\t    struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct tdesc_arch_data *tdesc_data = info.tdesc_data;\n   static const char *const stap_integer_prefixes[] = { \"i\", NULL };\n   static const char *const stap_register_indirection_prefixes[] = { \"(\","
    },
    {
      "sha": "97912eb55088f440fab830c0ef59d21958180a4b",
      "filename": "gdb/ppc-netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-netbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -102,7 +102,7 @@ ppcnbsd_sigtramp_cache_init (const struct tramp_frame *self,\n \t\t\t     CORE_ADDR func)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   CORE_ADDR addr, base;\n   int i;\n "
    },
    {
      "sha": "6a83c08b04f1ebdd3a44ee644f9aba70724b0d0c",
      "filename": "gdb/ppc-obsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-obsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -161,7 +161,7 @@ static struct trad_frame_cache *\n ppcobsd_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct trad_frame_cache *cache;\n   CORE_ADDR addr, base, func;"
    },
    {
      "sha": "0d15e427561e46cd2a0a6d3ed26d865e7d77e5b5",
      "filename": "gdb/ppc-sysv-tdep.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-sysv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-sysv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-sysv-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -65,7 +65,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t      function_call_return_method return_method,\n \t\t\t      CORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int opencl_abi = ppc_sysv_use_opencl_abi (value_type (function));\n   ULONGEST saved_sp;\n@@ -597,7 +597,7 @@ get_decimal_float_return_value (struct gdbarch *gdbarch, struct type *valtype,\n \t\t\t\tstruct regcache *regcache, gdb_byte *readbuf,\n \t\t\t\tconst gdb_byte *writebuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   gdb_assert (valtype->code () == TYPE_CODE_DECFLOAT);\n \n@@ -675,7 +675,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n \t\t\t  gdb_byte *readbuf, const gdb_byte *writebuf,\n \t\t\t  int broken_gcc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int opencl_abi = func_type? ppc_sysv_use_opencl_abi (func_type) : 0;\n \n@@ -1250,7 +1250,7 @@ ppc64_sysv_abi_push_val (struct gdbarch *gdbarch,\n \t\t\t const bfd_byte *val, int len, int align,\n \t\t\t struct ppc64_sysv_argpos *argpos)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int offset = 0;\n \n   /* Enforce alignment of stack location, if requested.  */\n@@ -1300,7 +1300,7 @@ static void\n ppc64_sysv_abi_push_integer (struct gdbarch *gdbarch, ULONGEST val,\n \t\t\t     struct ppc64_sysv_argpos *argpos)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   gdb_byte buf[PPC_MAX_REGISTER_SIZE];\n \n@@ -1318,7 +1318,7 @@ ppc64_sysv_abi_push_freg (struct gdbarch *gdbarch,\n \t\t\t  struct type *type, const bfd_byte *val,\n \t\t\t  struct ppc64_sysv_argpos *argpos)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (tdep->soft_float)\n     return;\n \n@@ -1403,7 +1403,7 @@ static void\n ppc64_sysv_abi_push_vreg (struct gdbarch *gdbarch, const bfd_byte *val,\n \t\t\t  struct ppc64_sysv_argpos *argpos)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (argpos->regcache && argpos->vreg <= 13)\n     argpos->regcache->cooked_write (tdep->ppc_vr0_regnum + argpos->vreg, val);\n@@ -1419,7 +1419,7 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n \t\t\t   struct type *type, const bfd_byte *val,\n \t\t\t   struct ppc64_sysv_argpos *argpos)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (type->code () == TYPE_CODE_FLT\n       || type->code () == TYPE_CODE_DECFLOAT)\n@@ -1545,7 +1545,7 @@ ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch,\n \t\t\t\tCORE_ADDR struct_addr)\n {\n   CORE_ADDR func_addr = find_function_addr (function, NULL);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int opencl_abi = ppc_sysv_use_opencl_abi (value_type (function));\n   ULONGEST back_chain;\n@@ -1739,7 +1739,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n \t\t\t\t  struct regcache *regcache, gdb_byte *readbuf,\n \t\t\t\t  const gdb_byte *writebuf, int index)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Integers live in GPRs starting at r3.  */\n   if ((valtype->code () == TYPE_CODE_INT\n@@ -1905,7 +1905,7 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\t     struct type *valtype, struct regcache *regcache,\n \t\t\t     gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct type *func_type = function ? value_type (function) : NULL;\n   int opencl_abi = func_type? ppc_sysv_use_opencl_abi (func_type) : 0;\n   struct type *eltype;"
    },
    {
      "sha": "6b305c460b112b2a2ede4802c15042454753866c",
      "filename": "gdb/ppc-tdep.h",
      "status": "modified",
      "additions": 52,
      "deletions": 52,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -205,106 +205,106 @@ enum powerpc_long_double_abi\n   POWERPC_LONG_DOUBLE_LAST\n };\n \n-struct gdbarch_tdep\n+struct ppc_gdbarch_tdep : gdbarch_tdep\n   {\n-    int wordsize;\t\t/* Size in bytes of fixed-point word.  */\n-    int soft_float;\t\t/* Avoid FP registers for arguments?  */\n+    int wordsize = 0;\t\t/* Size in bytes of fixed-point word.  */\n+    int soft_float = 0;\t\t/* Avoid FP registers for arguments?  */\n \n-    enum powerpc_elf_abi elf_abi;\t/* ELF ABI version.  */\n+    enum powerpc_elf_abi elf_abi {};\t/* ELF ABI version.  */\n \n     /* Format to use for the \"long double\" data type.  */\n-    enum powerpc_long_double_abi long_double_abi;\n+    enum powerpc_long_double_abi long_double_abi {};\n \n     /* How to pass vector arguments.  Never set to AUTO or LAST.  */\n-    enum powerpc_vector_abi vector_abi;\n+    enum powerpc_vector_abi vector_abi {};\n \n-    int ppc_gp0_regnum;\t\t/* GPR register 0 */\n-    int ppc_toc_regnum;\t\t/* TOC register */\n-    int ppc_ps_regnum;\t        /* Processor (or machine) status (%msr) */\n-    int ppc_cr_regnum;\t\t/* Condition register */\n-    int ppc_lr_regnum;\t\t/* Link register */\n-    int ppc_ctr_regnum;\t\t/* Count register */\n-    int ppc_xer_regnum;\t\t/* Integer exception register */\n+    int ppc_gp0_regnum = 0;\t\t/* GPR register 0 */\n+    int ppc_toc_regnum = 0;\t\t/* TOC register */\n+    int ppc_ps_regnum = 0;\t\t/* Processor (or machine) status (%msr) */\n+    int ppc_cr_regnum = 0;\t\t/* Condition register */\n+    int ppc_lr_regnum = 0;\t\t/* Link register */\n+    int ppc_ctr_regnum = 0;\t\t/* Count register */\n+    int ppc_xer_regnum = 0;\t\t/* Integer exception register */\n \n     /* Not all PPC and RS6000 variants will have the registers\n        represented below.  A -1 is used to indicate that the register\n        is not present in this variant.  */\n \n     /* Floating-point registers.  */\n-    int ppc_fp0_regnum;         /* Floating-point register 0.  */\n-    int ppc_fpscr_regnum;\t/* fp status and condition register.  */\n+    int ppc_fp0_regnum = 0;\t/* Floating-point register 0.  */\n+    int ppc_fpscr_regnum = 0;\t/* fp status and condition register.  */\n \n     /* Multiplier-Quotient Register (older POWER architectures only).  */\n-    int ppc_mq_regnum;\n+    int ppc_mq_regnum = 0;\n \n     /* POWER7 VSX registers.  */\n-    int ppc_vsr0_regnum;\t/* First VSX register.  */\n-    int ppc_vsr0_upper_regnum;  /* First right most dword vsx register.  */\n-    int ppc_efpr0_regnum;\t/* First Extended FP register.  */\n+    int ppc_vsr0_regnum = 0;\t\t/* First VSX register.  */\n+    int ppc_vsr0_upper_regnum = 0; \t/* First right most dword vsx register.  */\n+    int ppc_efpr0_regnum = 0;\t\t/* First Extended FP register.  */\n \n     /* Altivec registers.  */\n-    int ppc_vr0_regnum;\t\t/* First AltiVec register.  */\n-    int ppc_vrsave_regnum;\t/* Last AltiVec register.  */\n+    int ppc_vr0_regnum = 0;\t/* First AltiVec register.  */\n+    int ppc_vrsave_regnum = 0;\t/* Last AltiVec register.  */\n \n     /* Altivec pseudo-register vX aliases for the raw vrX\n        registers.  */\n-    int ppc_v0_alias_regnum;\n+    int ppc_v0_alias_regnum = 0;\n \n     /* SPE registers.  */\n-    int ppc_ev0_upper_regnum;   /* First GPR upper half register.  */\n-    int ppc_ev0_regnum;         /* First ev register.  */\n-    int ppc_acc_regnum;         /* SPE 'acc' register.  */\n-    int ppc_spefscr_regnum;     /* SPE 'spefscr' register.  */\n+    int ppc_ev0_upper_regnum = 0;   /* First GPR upper half register.  */\n+    int ppc_ev0_regnum = 0;         /* First ev register.  */\n+    int ppc_acc_regnum = 0;         /* SPE 'acc' register.  */\n+    int ppc_spefscr_regnum = 0;     /* SPE 'spefscr' register.  */\n \n     /* Program Priority Register.  */\n-    int ppc_ppr_regnum;\n+    int ppc_ppr_regnum = 0;\n \n     /* Data Stream Control Register.  */\n-    int ppc_dscr_regnum;\n+    int ppc_dscr_regnum = 0;\n \n     /* Target Address Register.  */\n-    int ppc_tar_regnum;\n+    int ppc_tar_regnum = 0;\n \n     /* Decimal 128 registers.  */\n-    int ppc_dl0_regnum;\t\t/* First Decimal128 argument register pair.  */\n+    int ppc_dl0_regnum = 0;\t/* First Decimal128 argument register pair.  */\n \n-    int have_ebb;\n+    int have_ebb = 0;\n \n     /* PMU registers.  */\n-    int ppc_mmcr0_regnum;\n-    int ppc_mmcr2_regnum;\n-    int ppc_siar_regnum;\n-    int ppc_sdar_regnum;\n-    int ppc_sier_regnum;\n+    int ppc_mmcr0_regnum = 0;\n+    int ppc_mmcr2_regnum = 0;\n+    int ppc_siar_regnum = 0;\n+    int ppc_sdar_regnum = 0;\n+    int ppc_sier_regnum = 0;\n \n     /* Hardware Transactional Memory registers.  */\n-    int have_htm_spr;\n-    int have_htm_core;\n-    int have_htm_fpu;\n-    int have_htm_altivec;\n-    int have_htm_vsx;\n-    int ppc_cppr_regnum;\n-    int ppc_cdscr_regnum;\n-    int ppc_ctar_regnum;\n+    int have_htm_spr = 0;\n+    int have_htm_core = 0;\n+    int have_htm_fpu = 0;\n+    int have_htm_altivec = 0;\n+    int have_htm_vsx = 0;\n+    int ppc_cppr_regnum = 0;\n+    int ppc_cdscr_regnum = 0;\n+    int ppc_ctar_regnum = 0;\n \n     /* HTM pseudo registers.  */\n-    int ppc_cdl0_regnum;\n-    int ppc_cvsr0_regnum;\n-    int ppc_cefpr0_regnum;\n+    int ppc_cdl0_regnum = 0;\n+    int ppc_cvsr0_regnum = 0;\n+    int ppc_cefpr0_regnum = 0;\n \n     /* Offset to ABI specific location where link register is saved.  */\n-    int lr_frame_offset;\t\n+    int lr_frame_offset = 0;\n \n     /* An array of integers, such that sim_regno[I] is the simulator\n        register number for GDB register number I, or -1 if the\n        simulator does not implement that register.  */\n-    int *sim_regno;\n+    int *sim_regno = nullptr;\n \n     /* ISA-specific types.  */\n-    struct type *ppc_builtin_type_vec64;\n-    struct type *ppc_builtin_type_vec128;\n+    struct type *ppc_builtin_type_vec64 = nullptr;\n+    struct type *ppc_builtin_type_vec128 = nullptr;\n \n-    int (*ppc_syscall_record) (struct regcache *regcache);\n+    int (*ppc_syscall_record) (struct regcache *regcache) = nullptr;\n };\n \n "
    },
    {
      "sha": "aab893df3a5bd51a4b7350ebc980780ac3027e5a",
      "filename": "gdb/ppc64-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/ppc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc64-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -89,7 +89,7 @@ ppc64_plt_entry_point (struct frame_info *frame, CORE_ADDR plt_off)\n {\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   CORE_ADDR tocp;\n \n   if (execution_direction == EXEC_REVERSE)"
    },
    {
      "sha": "f6489ab02389238ec472f1c0bdc5cdf5803f7697",
      "filename": "gdb/riscv-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/riscv-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/riscv-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -179,7 +179,7 @@ riscv_linux_syscall_next_pc (struct frame_info *frame)\n static void\n riscv_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 0);\n "
    },
    {
      "sha": "a6a64d3cb84d61e760805dd3c2264a0340ab5708",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 22,
      "deletions": 15,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -730,39 +730,44 @@ show_riscv_debug_variable (struct ui_file *file, int from_tty,\n int\n riscv_isa_xlen (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->isa_features.xlen;\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->isa_features.xlen;\n }\n \n /* See riscv-tdep.h.  */\n \n int\n riscv_abi_xlen (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->abi_features.xlen;\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->abi_features.xlen;\n }\n \n /* See riscv-tdep.h.  */\n \n int\n riscv_isa_flen (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->isa_features.flen;\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->isa_features.flen;\n }\n \n /* See riscv-tdep.h.  */\n \n int\n riscv_abi_flen (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->abi_features.flen;\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->abi_features.flen;\n }\n \n /* See riscv-tdep.h.  */\n \n bool\n riscv_abi_embedded (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->abi_features.embedded;\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->abi_features.embedded;\n }\n \n /* Return true if the target for GDBARCH has floating point hardware.  */\n@@ -778,7 +783,8 @@ riscv_has_fp_regs (struct gdbarch *gdbarch)\n static bool\n riscv_has_fp_abi (struct gdbarch *gdbarch)\n {\n-  return gdbarch_tdep (gdbarch)->abi_features.flen > 0;\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  return tdep->abi_features.flen > 0;\n }\n \n /* Return true if REGNO is a floating pointer register.  */\n@@ -901,7 +907,7 @@ riscv_register_name (struct gdbarch *gdbarch, int regnum)\n      will show up in 'info register all'.  Unless, we identify the\n      duplicate copies of these registers (in riscv_tdesc_unknown_reg) and\n      then hide the registers here by giving them no name.  */\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (tdep->duplicate_fflags_regnum == regnum)\n     return NULL;\n   if (tdep->duplicate_frm_regnum == regnum)\n@@ -929,7 +935,7 @@ riscv_register_name (struct gdbarch *gdbarch, int regnum)\n static struct type *\n riscv_fpreg_d_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->riscv_fpreg_d_type == nullptr)\n     {\n@@ -1251,7 +1257,7 @@ riscv_is_regnum_a_named_csr (int regnum)\n static bool\n riscv_is_unknown_csr (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   return (regnum >= tdep->unknown_csrs_first_regnum\n \t  && regnum < (tdep->unknown_csrs_first_regnum\n \t\t       + tdep->unknown_csrs_count));\n@@ -3560,7 +3566,7 @@ riscv_tdesc_unknown_reg (struct gdbarch *gdbarch, tdesc_feature *feature,\n      record their register numbers here.  */\n   if (strcmp (tdesc_feature_name (feature), riscv_freg_feature.name ()) == 0)\n     {\n-      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n       int *regnum_ptr = nullptr;\n \n       if (strcmp (reg_name, \"fflags\") == 0)\n@@ -3591,7 +3597,7 @@ riscv_tdesc_unknown_reg (struct gdbarch *gdbarch, tdesc_feature *feature,\n      about register groups in riscv_register_reggroup_p.  */\n   if (strcmp (tdesc_feature_name (feature), riscv_csr_feature.name ()) == 0)\n     {\n-      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      riscv_gdbarch_tdep *tdep = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n       if (tdep->unknown_csrs_first_regnum == -1)\n \ttdep->unknown_csrs_first_regnum = possible_regnum;\n       gdb_assert (tdep->unknown_csrs_first_regnum\n@@ -3628,7 +3634,6 @@ riscv_gdbarch_init (struct gdbarch_info info,\n \t\t    struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   struct riscv_gdbarch_features features;\n   const struct target_desc *tdesc = info.target_desc;\n \n@@ -3693,7 +3698,8 @@ riscv_gdbarch_init (struct gdbarch_info info,\n       /* Check that the feature set of the ARCHES matches the feature set\n \t we are looking for.  If it doesn't then we can't reuse this\n \t gdbarch.  */\n-      struct gdbarch_tdep *other_tdep = gdbarch_tdep (arches->gdbarch);\n+      riscv_gdbarch_tdep *other_tdep\n+\t= (riscv_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n \n       if (other_tdep->isa_features != features\n \t  || other_tdep->abi_features != abi_features)\n@@ -3706,7 +3712,7 @@ riscv_gdbarch_init (struct gdbarch_info info,\n     return arches->gdbarch;\n \n   /* None found, so create a new architecture from the information provided.  */\n-  tdep = new (struct gdbarch_tdep);\n+  riscv_gdbarch_tdep *tdep = new riscv_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   tdep->isa_features = features;\n   tdep->abi_features = abi_features;\n@@ -3812,7 +3818,8 @@ static CORE_ADDR\n riscv_next_pc (struct regcache *regcache, CORE_ADDR pc)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  const riscv_gdbarch_tdep *tdep\n+    = (riscv_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct riscv_insn insn;\n   CORE_ADDR next_pc;\n "
    },
    {
      "sha": "2af6ec332f76ba2edff14d69ac3ef2ba2e950831",
      "filename": "gdb/riscv-tdep.h",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/riscv-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/riscv-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -22,6 +22,7 @@\n #define RISCV_TDEP_H\n \n #include \"arch/riscv.h\"\n+#include \"gdbarch.h\"\n \n /* RiscV register numbers.  */\n enum\n@@ -75,7 +76,7 @@ enum\n };\n \n /* RISC-V specific per-architecture information.  */\n-struct gdbarch_tdep\n+struct riscv_gdbarch_tdep : gdbarch_tdep\n {\n   /* Features about the target hardware that impact how the gdbarch is\n      configured.  Two gdbarch instances are compatible only if this field\n@@ -105,7 +106,7 @@ struct gdbarch_tdep\n \n   /* Return the expected next PC assuming FRAME is stopped at a syscall\n      instruction.  */\n-  CORE_ADDR (*syscall_next_pc) (struct frame_info *frame);\n+  CORE_ADDR (*syscall_next_pc) (struct frame_info *frame) = nullptr;\n };\n \n "
    },
    {
      "sha": "616dafb1721be6097f435bf556b3b9dba647f7f4",
      "filename": "gdb/rl78-tdep.c",
      "status": "modified",
      "additions": 22,
      "deletions": 19,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rl78-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rl78-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rl78-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -209,21 +209,21 @@ enum\n \n /* Architecture specific data.  */\n \n-struct gdbarch_tdep\n+struct rl78_gdbarch_tdep : gdbarch_tdep\n {\n   /* The ELF header flags specify the multilib used.  */\n-  int elf_flags;\n-\n-  struct type *rl78_void,\n-\t      *rl78_uint8,\n-\t      *rl78_int8,\n-\t      *rl78_uint16,\n-\t      *rl78_int16,\n-\t      *rl78_uint32,\n-\t      *rl78_int32,\n-\t      *rl78_data_pointer,\n-\t      *rl78_code_pointer,\n-\t      *rl78_psw_type;\n+  int elf_flags = 0;\n+\n+  struct type *rl78_void = nullptr,\n+\t      *rl78_uint8 = nullptr,\n+\t      *rl78_int8 = nullptr,\n+\t      *rl78_uint16 = nullptr,\n+\t      *rl78_int16 = nullptr,\n+\t      *rl78_uint32 = nullptr,\n+\t      *rl78_int32 = nullptr,\n+\t      *rl78_data_pointer = nullptr,\n+\t      *rl78_code_pointer = nullptr,\n+\t      *rl78_psw_type = nullptr;\n };\n \n /* This structure holds the results of a prologue analysis.  */\n@@ -266,7 +266,7 @@ struct rl78_prologue\n static struct type *\n rl78_psw_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  rl78_gdbarch_tdep *tdep = (rl78_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->rl78_psw_type == NULL)\n     {\n@@ -290,7 +290,7 @@ rl78_psw_type (struct gdbarch *gdbarch)\n static struct type *\n rl78_register_type (struct gdbarch *gdbarch, int reg_nr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  rl78_gdbarch_tdep *tdep = (rl78_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (reg_nr == RL78_PC_REGNUM)\n     return tdep->rl78_code_pointer;\n@@ -1247,7 +1247,8 @@ rl78_return_value (struct gdbarch *gdbarch,\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   ULONGEST valtype_len = TYPE_LENGTH (valtype);\n-  int is_g10 = gdbarch_tdep (gdbarch)->elf_flags & E_FLAG_RL78_G10;\n+  rl78_gdbarch_tdep *tdep = (rl78_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int is_g10 = tdep->elf_flags & E_FLAG_RL78_G10;\n \n   if (valtype_len > 8)\n     return RETURN_VALUE_STRUCT_CONVENTION;\n@@ -1375,7 +1376,6 @@ static struct gdbarch *\n rl78_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int elf_flags;\n \n   /* Extract the elf_flags if available.  */\n@@ -1392,15 +1392,18 @@ rl78_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      if (gdbarch_tdep (arches->gdbarch)->elf_flags != elf_flags)\n+      rl78_gdbarch_tdep *tdep\n+\t= (rl78_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n+      if (tdep->elf_flags != elf_flags)\n \tcontinue;\n \n       return arches->gdbarch;\n     }\n \n   /* None found, create a new architecture from the information\n      provided.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  rl78_gdbarch_tdep * tdep = new rl78_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   tdep->elf_flags = elf_flags;\n "
    },
    {
      "sha": "11cae6ad4bceb2dbd953e1b99ae2cc71b04beba6",
      "filename": "gdb/rs6000-aix-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 9,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rs6000-aix-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rs6000-aix-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-aix-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -73,7 +73,7 @@ aix_sighandle_frame_cache (struct frame_info *this_frame,\n   LONGEST backchain;\n   CORE_ADDR base, base_orig, func;\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct trad_frame_cache *this_trad_cache;\n \n@@ -259,7 +259,8 @@ rs6000_aix_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t\t void *cb_data,\n \t\t\t\t\t const struct regcache *regcache)\n {\n-  if (gdbarch_tdep (gdbarch)->wordsize == 4)\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  if (tdep->wordsize == 4)\n     cb (\".reg\", 592, 592, &rs6000_aix32_regset, NULL, cb_data);\n   else\n     cb (\".reg\", 576, 576, &rs6000_aix64_regset, NULL, cb_data);\n@@ -289,15 +290,15 @@ rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\tfunction_call_return_method return_method,\n \t\t\tCORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int ii;\n   int len = 0;\n   int argno;\t\t\t/* current argument number */\n   int argbytes;\t\t\t/* current argument byte */\n   gdb_byte tmp_buffer[50];\n   int f_argno = 0;\t\t/* current floating point argno */\n-  int wordsize = gdbarch_tdep (gdbarch)->wordsize;\n+  int wordsize = tdep->wordsize;\n   CORE_ADDR func_addr = find_function_addr (function, NULL);\n \n   struct value *arg = 0;\n@@ -519,7 +520,7 @@ rs6000_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t     struct type *valtype, struct regcache *regcache,\n \t\t     gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   /* The calling convention this function implements assumes the\n@@ -657,7 +658,7 @@ rs6000_convert_from_func_ptr_addr (struct gdbarch *gdbarch,\n \t\t\t\t   CORE_ADDR addr,\n \t\t\t\t   struct target_ops *targ)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct obj_section *s;\n \n@@ -701,7 +702,7 @@ branch_dest (struct regcache *regcache, int opcode, int instr,\n \t     CORE_ADDR pc, CORE_ADDR safety)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   CORE_ADDR dest;\n   int immediate;\n@@ -969,7 +970,7 @@ static struct ld_info\n rs6000_aix_extract_ld_info (struct gdbarch *gdbarch,\n \t\t\t    const gdb_byte *ldi_buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct type *ptr_type = builtin_type (gdbarch)->builtin_data_ptr;\n   const struct ld_info_desc desc\n@@ -1128,7 +1129,7 @@ rs6000_aix_core_xfer_shared_libraries_aix (struct gdbarch *gdbarch,\n static void\n rs6000_aix_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* RS6000/AIX does not support PT_STEP.  Has to be simulated.  */\n   set_gdbarch_software_single_step (gdbarch, rs6000_software_single_step);"
    },
    {
      "sha": "bdc1aaa18d7ac90efde3975f9e580e3407080ced",
      "filename": "gdb/rs6000-lynx178-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rs6000-lynx178-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rs6000-lynx178-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-lynx178-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -36,15 +36,15 @@ rs6000_lynx178_push_dummy_call (struct gdbarch *gdbarch,\n \t\t\t\tfunction_call_return_method return_method,\n \t\t\t\tCORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int ii;\n   int len = 0;\n   int argno;\t\t\t/* current argument number */\n   int argbytes;\t\t\t/* current argument byte */\n   gdb_byte tmp_buffer[50];\n   int f_argno = 0;\t\t/* current floating point argno */\n-  int wordsize = gdbarch_tdep (gdbarch)->wordsize;\n+  int wordsize = tdep->wordsize;\n \n   struct value *arg = 0;\n   struct type *type;\n@@ -265,7 +265,7 @@ rs6000_lynx178_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\t     struct type *valtype, struct regcache *regcache,\n \t\t\t     gdb_byte *readbuf, const gdb_byte *writebuf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   /* The calling convention this function implements assumes the"
    },
    {
      "sha": "0d6189431868297acee6a64d2bf823aa842edf30",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 60,
      "deletions": 61,
      "changes": 121,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -209,7 +209,7 @@ struct rs6000_framedata\n int\n vsx_register_p (struct gdbarch *gdbarch, int regno)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (tdep->ppc_vsr0_regnum < 0)\n     return 0;\n   else\n@@ -221,7 +221,7 @@ vsx_register_p (struct gdbarch *gdbarch, int regno)\n int\n altivec_register_p (struct gdbarch *gdbarch, int regno)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (tdep->ppc_vr0_regnum < 0 || tdep->ppc_vrsave_regnum < 0)\n     return 0;\n   else\n@@ -233,7 +233,7 @@ altivec_register_p (struct gdbarch *gdbarch, int regno)\n int\n spe_register_p (struct gdbarch *gdbarch, int regno)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   \n   /* Is it a reference to EV0 -- EV31, and do we have those?  */\n   if (IS_SPE_PSEUDOREG (tdep, regno))\n@@ -265,7 +265,7 @@ spe_register_p (struct gdbarch *gdbarch, int regno)\n int\n ppc_floating_point_unit_p (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   return (tdep->ppc_fp0_regnum >= 0\n \t  && tdep->ppc_fpscr_regnum >= 0);\n@@ -276,7 +276,7 @@ ppc_floating_point_unit_p (struct gdbarch *gdbarch)\n int\n ppc_altivec_support_p (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   return (tdep->ppc_vr0_regnum >= 0\n \t  && tdep->ppc_vrsave_regnum >= 0);\n@@ -305,7 +305,7 @@ set_sim_regno (int *table, int gdb_regno, int sim_regno)\n static void\n init_sim_regno_table (struct gdbarch *arch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (arch);\n   int total_regs = gdbarch_num_regs (arch);\n   int *sim_regno = GDBARCH_OBSTACK_CALLOC (arch, total_regs, int);\n   int i;\n@@ -399,7 +399,7 @@ init_sim_regno_table (struct gdbarch *arch)\n static int\n rs6000_register_sim_regno (struct gdbarch *gdbarch, int reg)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int sim_regno;\n \n   if (tdep->sim_regno == NULL)\n@@ -470,7 +470,7 @@ ppc_collect_reg (const struct regcache *regcache, int regnum,\n     \n static int\n ppc_greg_offset (struct gdbarch *gdbarch,\n-\t\t struct gdbarch_tdep *tdep,\n+\t\t ppc_gdbarch_tdep *tdep,\n \t\t const struct ppc_reg_offsets *offsets,\n \t\t int regnum,\n \t\t int *regsize)\n@@ -507,7 +507,7 @@ ppc_greg_offset (struct gdbarch *gdbarch,\n }\n \n static int\n-ppc_fpreg_offset (struct gdbarch_tdep *tdep,\n+ppc_fpreg_offset (ppc_gdbarch_tdep *tdep,\n \t\t  const struct ppc_reg_offsets *offsets,\n \t\t  int regnum)\n {\n@@ -530,7 +530,7 @@ ppc_supply_gregset (const struct regset *regset, struct regcache *regcache,\n \t\t    int regnum, const void *gregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const struct ppc_reg_offsets *offsets\n     = (const struct ppc_reg_offsets *) regset->regmap;\n   size_t offset;\n@@ -580,14 +580,13 @@ ppc_supply_fpregset (const struct regset *regset, struct regcache *regcache,\n \t\t     int regnum, const void *fpregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep;\n   const struct ppc_reg_offsets *offsets;\n   size_t offset;\n \n   if (!ppc_floating_point_unit_p (gdbarch))\n     return;\n \n-  tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   offsets = (const struct ppc_reg_offsets *) regset->regmap;\n   if (regnum == -1)\n     {\n@@ -620,7 +619,7 @@ ppc_collect_gregset (const struct regset *regset,\n \t\t     int regnum, void *gregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const struct ppc_reg_offsets *offsets\n     = (const struct ppc_reg_offsets *) regset->regmap;\n   size_t offset;\n@@ -671,14 +670,13 @@ ppc_collect_fpregset (const struct regset *regset,\n \t\t      int regnum, void *fpregs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep;\n   const struct ppc_reg_offsets *offsets;\n   size_t offset;\n \n   if (!ppc_floating_point_unit_p (gdbarch))\n     return;\n \n-  tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   offsets = (const struct ppc_reg_offsets *) regset->regmap;\n   if (regnum == -1)\n     {\n@@ -756,7 +754,7 @@ static int\n rs6000_in_function_epilogue_frame_p (struct frame_info *curfrm,\n \t\t\t\t     struct gdbarch *gdbarch, CORE_ADDR pc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   bfd_byte insn_buf[PPC_INSN_SIZE];\n   CORE_ADDR scan_pc, func_start, func_end, epilogue_start, epilogue_end;\n@@ -1052,8 +1050,9 @@ ppc_displaced_step_fixup (struct gdbarch *gdbarch,\n       if (insn & 0x1)\n \t{\n \t  /* Link register needs to be set to the next instruction's PC.  */\n+\t  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \t  regcache_cooked_write_unsigned (regs,\n-\t\t\t\t\t  gdbarch_tdep (gdbarch)->ppc_lr_regnum,\n+\t\t\t\t\t  tdep->ppc_lr_regnum,\n \t\t\t\t\t  from + PPC_INSN_SIZE);\n \t  displaced_debug_printf (\"(ppc) adjusted LR to %s\",\n \t\t\t\t  paddress (gdbarch, from + PPC_INSN_SIZE));\n@@ -1599,7 +1598,7 @@ skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc, CORE_ADDR lim_pc,\n   int num_skip_non_prologue_insns = 0;\n   int r0_contains_arg = 0;\n   const struct bfd_arch_info *arch_info = gdbarch_bfd_arch_info (gdbarch);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   memset (fdata, 0, sizeof (struct rs6000_framedata));\n@@ -2319,7 +2318,7 @@ static CORE_ADDR\n rs6000_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)\n {\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   unsigned int ii, op;\n   int rel;\n@@ -2377,7 +2376,7 @@ rs6000_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)\n static struct type *\n rs6000_builtin_type_vec64 (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->ppc_builtin_type_vec64)\n     {\n@@ -2422,7 +2421,7 @@ rs6000_builtin_type_vec64 (struct gdbarch *gdbarch)\n static struct type *\n rs6000_builtin_type_vec128 (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->ppc_builtin_type_vec128)\n     {\n@@ -2476,7 +2475,7 @@ rs6000_builtin_type_vec128 (struct gdbarch *gdbarch)\n static const char *\n rs6000_register_name (struct gdbarch *gdbarch, int regno)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* The upper half \"registers\" have names in the XML description,\n      but we present only the low GPRs and the full 64-bit registers\n@@ -2614,7 +2613,7 @@ rs6000_register_name (struct gdbarch *gdbarch, int regno)\n static struct type *\n rs6000_pseudo_register_type (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* These are the e500 pseudo-registers.  */\n   if (IS_SPE_PSEUDOREG (tdep, regnum))\n@@ -2653,7 +2652,7 @@ static int\n rs6000_pseudo_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n \t\t\t\t   struct reggroup *group)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (IS_V_ALIAS_PSEUDOREG (tdep, regnum))\n     return 0;\n@@ -2668,7 +2667,7 @@ static int\n rs6000_convert_register_p (struct gdbarch *gdbarch, int regnum,\n \t\t\t   struct type *type)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   return (tdep->ppc_fp0_regnum >= 0\n \t  && regnum >= tdep->ppc_fp0_regnum\n@@ -2753,7 +2752,7 @@ e500_move_ev_register (move_ev_register_func move,\n \t\t       struct regcache *regcache, int ev_reg, void *buffer)\n {\n   struct gdbarch *arch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch); \n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (arch);\n   int reg_index;\n   gdb_byte *byte_buffer = (gdb_byte *) buffer;\n   enum register_status status;\n@@ -2794,7 +2793,7 @@ e500_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \t\t\t   int ev_reg, gdb_byte *buffer)\n {\n   struct gdbarch *arch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index;\n   enum register_status status;\n \n@@ -2835,7 +2834,7 @@ static enum register_status\n dfp_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \t\t\t   int reg_nr, gdb_byte *buffer)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, fp0;\n   enum register_status status;\n \n@@ -2875,7 +2874,7 @@ static void\n dfp_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t    int reg_nr, const gdb_byte *buffer)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, fp0;\n \n   if (IS_DFP_PSEUDOREG (tdep, reg_nr))\n@@ -2912,7 +2911,7 @@ v_alias_pseudo_register_read (struct gdbarch *gdbarch,\n \t\t\t      readable_regcache *regcache, int reg_nr,\n \t\t\t      gdb_byte *buffer)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_assert (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr));\n \n   return regcache->raw_read (tdep->ppc_vr0_regnum\n@@ -2927,7 +2926,7 @@ v_alias_pseudo_register_write (struct gdbarch *gdbarch,\n \t\t\t       struct regcache *regcache,\n \t\t\t       int reg_nr, const gdb_byte *buffer)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_assert (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr));\n \n   regcache->raw_write (tdep->ppc_vr0_regnum\n@@ -2939,7 +2938,7 @@ static enum register_status\n vsx_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \t\t\t   int reg_nr, gdb_byte *buffer)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, vr0, fp0, vsr0_upper;\n   enum register_status status;\n \n@@ -2987,7 +2986,7 @@ static void\n vsx_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t    int reg_nr, const gdb_byte *buffer)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, vr0, fp0, vsr0_upper;\n \n   if (IS_VSX_PSEUDOREG (tdep, reg_nr))\n@@ -3029,7 +3028,7 @@ static enum register_status\n efp_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \t\t\t   int reg_nr, gdb_byte *buffer)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, vr0;\n \n   if (IS_EFP_PSEUDOREG (tdep, reg_nr))\n@@ -3058,7 +3057,7 @@ static void\n efp_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t    int reg_nr, const gdb_byte *buffer)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, vr0;\n   int offset = gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG ? 0 : 8;\n \n@@ -3094,7 +3093,7 @@ rs6000_pseudo_register_read (struct gdbarch *gdbarch,\n \t\t\t     int reg_nr, gdb_byte *buffer)\n {\n   struct gdbarch *regcache_arch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); \n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   gdb_assert (regcache_arch == gdbarch);\n \n@@ -3125,7 +3124,7 @@ rs6000_pseudo_register_write (struct gdbarch *gdbarch,\n \t\t\t      int reg_nr, const gdb_byte *buffer)\n {\n   struct gdbarch *regcache_arch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); \n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   gdb_assert (regcache_arch == gdbarch);\n \n@@ -3156,7 +3155,7 @@ static void\n dfp_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n \t\t\t\tstruct agent_expr *ax, int reg_nr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, fp0;\n \n   if (IS_DFP_PSEUDOREG (tdep, reg_nr))\n@@ -3183,7 +3182,7 @@ static void\n v_alias_pseudo_register_collect (struct gdbarch *gdbarch,\n \t\t\t\t struct agent_expr *ax, int reg_nr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   gdb_assert (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr));\n \n   ax_reg_mask (ax, tdep->ppc_vr0_regnum\n@@ -3197,7 +3196,7 @@ static void\n vsx_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n \t\t\t\tstruct agent_expr *ax, int reg_nr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, vr0, fp0, vsr0_upper;\n \n   if (IS_VSX_PSEUDOREG (tdep, reg_nr))\n@@ -3235,7 +3234,7 @@ static void\n efp_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n \t\t\t\tstruct agent_expr *ax, int reg_nr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int reg_index, vr0;\n \n   if (IS_EFP_PSEUDOREG (tdep, reg_nr))\n@@ -3258,7 +3257,7 @@ static int\n rs6000_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n \t\t\t\t   struct agent_expr *ax, int reg_nr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (IS_SPE_PSEUDOREG (tdep, reg_nr))\n     {\n       int reg_index = reg_nr - tdep->ppc_ev0_regnum;\n@@ -3298,7 +3297,7 @@ rs6000_gen_return_address (struct gdbarch *gdbarch,\n \t\t\t   struct agent_expr *ax, struct axs_value *value,\n \t\t\t   CORE_ADDR scope)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   value->type = register_type (gdbarch, tdep->ppc_lr_regnum);\n   value->kind = axs_lvalue_register;\n   value->u.reg = tdep->ppc_lr_regnum;\n@@ -3309,7 +3308,7 @@ rs6000_gen_return_address (struct gdbarch *gdbarch,\n static int\n rs6000_stab_reg_to_regnum (struct gdbarch *gdbarch, int num)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (0 <= num && num <= 31)\n     return tdep->ppc_gp0_regnum + num;\n@@ -3351,7 +3350,7 @@ rs6000_stab_reg_to_regnum (struct gdbarch *gdbarch, int num)\n static int\n rs6000_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int num)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (0 <= num && num <= 31)\n     return tdep->ppc_gp0_regnum + num;\n@@ -3570,7 +3569,7 @@ rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)\n {\n   struct rs6000_frame_cache *cache;\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct rs6000_framedata fdata;\n   int wordsize = tdep->wordsize;\n@@ -3806,7 +3805,7 @@ rs6000_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)\n {\n   struct rs6000_frame_cache *cache;\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (*this_cache)\n     return (struct rs6000_frame_cache *) *this_cache;\n@@ -3927,7 +3926,7 @@ ppc_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,\n \t\t\t    struct dwarf2_frame_state_reg *reg,\n \t\t\t    struct frame_info *this_frame)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* PPC32 and PPC64 ABI's are the same regarding volatile and\n      non-volatile registers.  We will use the same code for both.  */\n@@ -4139,7 +4138,7 @@ bfd_uses_spe_extensions (bfd *abfd)\n    Otherwise, it's just a VR register.  Record them accordingly.  */\n \n static int\n-ppc_record_vsr (struct regcache *regcache, struct gdbarch_tdep *tdep, int vsr)\n+ppc_record_vsr (struct regcache *regcache, ppc_gdbarch_tdep *tdep, int vsr)\n {\n   if (vsr < 0 || vsr >= 64)\n     return -1;\n@@ -4168,7 +4167,7 @@ static int\n ppc_process_record_op4 (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\tCORE_ADDR addr, uint32_t insn)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ext = PPC_FIELD (insn, 21, 11);\n   int vra = PPC_FIELD (insn, 11, 5);\n \n@@ -4541,7 +4540,7 @@ static int\n ppc_process_record_op19 (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t   CORE_ADDR addr, uint32_t insn)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ext = PPC_EXTOP (insn);\n \n   switch (ext & 0x01f)\n@@ -4593,7 +4592,7 @@ static int\n ppc_process_record_op31 (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t   CORE_ADDR addr, uint32_t insn)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ext = PPC_EXTOP (insn);\n   int tmp, nr, nb, i;\n   CORE_ADDR at_dcsz, ea = 0;\n@@ -5190,7 +5189,7 @@ static int\n ppc_process_record_op59 (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t   CORE_ADDR addr, uint32_t insn)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ext = PPC_EXTOP (insn);\n \n   switch (ext & 0x1f)\n@@ -5284,7 +5283,7 @@ static int\n ppc_process_record_op60 (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t   CORE_ADDR addr, uint32_t insn)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ext = PPC_EXTOP (insn);\n \n   switch (ext >> 2)\n@@ -5646,7 +5645,7 @@ static int\n ppc_process_record_op61 (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t   CORE_ADDR addr, uint32_t insn)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   ULONGEST ea = 0;\n   int size;\n \n@@ -5705,7 +5704,7 @@ static int\n ppc_process_record_op63 (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t   CORE_ADDR addr, uint32_t insn)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ext = PPC_EXTOP (insn);\n   int tmp;\n \n@@ -5964,7 +5963,7 @@ int\n ppc_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t      CORE_ADDR addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   uint32_t insn;\n   int op6, tmp, i;\n@@ -6267,7 +6266,6 @@ static struct gdbarch *\n rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int wordsize, from_xcoff_exec, from_elf_exec;\n   enum bfd_architecture arch;\n   unsigned long mach;\n@@ -6953,7 +6951,8 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       /* Word size in the various PowerPC bfd_arch_info structs isn't\n \t meaningful, because 64-bit CPUs can run in 32-bit mode.  So, perform\n \t separate word size check.  */\n-      tdep = gdbarch_tdep (arches->gdbarch);\n+      ppc_gdbarch_tdep *tdep\n+\t= (ppc_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n       if (tdep && tdep->elf_abi != elf_abi)\n \tcontinue;\n       if (tdep && tdep->soft_float != soft_float)\n@@ -6974,7 +6973,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        - \"set arch\"\t\ttrust blindly\n        - GDB startup\t\tuseless but harmless */\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  ppc_gdbarch_tdep *tdep = new ppc_gdbarch_tdep;\n   tdep->wordsize = wordsize;\n   tdep->elf_abi = elf_abi;\n   tdep->soft_float = soft_float;\n@@ -7253,7 +7252,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n static void\n rs6000_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  ppc_gdbarch_tdep *tdep = (ppc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep == NULL)\n     return;"
    },
    {
      "sha": "73e708b6462d9a817a090aa98c0f97228dcf7484",
      "filename": "gdb/rx-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/rx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rx-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -68,16 +68,16 @@ enum rx_frame_type {\n };\n \n /* Architecture specific data.  */\n-struct gdbarch_tdep\n+struct rx_gdbarch_tdep : gdbarch_tdep\n {\n   /* The ELF header flags specify the multilib used.  */\n-  int elf_flags;\n+  int elf_flags = 0;\n \n   /* Type of PSW and BPSW.  */\n-  struct type *rx_psw_type;\n+  struct type *rx_psw_type = nullptr;\n \n   /* Type of FPSW.  */\n-  struct type *rx_fpsw_type;\n+  struct type *rx_fpsw_type = nullptr;\n };\n \n /* This structure holds the results of a prologue analysis.  */\n@@ -944,7 +944,6 @@ static struct gdbarch *\n rx_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int elf_flags;\n   tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n@@ -963,7 +962,10 @@ rx_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      if (gdbarch_tdep (arches->gdbarch)->elf_flags != elf_flags)\n+      rx_gdbarch_tdep *tdep\n+\t= (rx_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n+      if (tdep->elf_flags != elf_flags)\n \tcontinue;\n \n       return arches->gdbarch;\n@@ -994,7 +996,7 @@ rx_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   gdb_assert(tdesc_data != NULL);\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  rx_gdbarch_tdep *tdep = new rx_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   tdep->elf_flags = elf_flags;\n "
    },
    {
      "sha": "ca4fe0a3c7178b2082c9acbd13a53797e293e2e4",
      "filename": "gdb/s12z-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/s12z-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/s12z-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s12z-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -482,7 +482,7 @@ constexpr gdb_byte s12z_break_insn[] = {0x00};\n \n typedef BP_MANIPULATION (s12z_break_insn) s12z_breakpoint;\n \n-struct gdbarch_tdep\n+struct s12z_gdbarch_tdep : gdbarch_tdep\n {\n };\n \n@@ -640,7 +640,7 @@ show_bdccsr_command (const char *args, int from_tty)\n static struct gdbarch *\n s12z_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep = XNEW (struct gdbarch_tdep);\n+  s12z_gdbarch_tdep *tdep = new s12z_gdbarch_tdep;\n   struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep);\n \n   add_cmd (\"bdccsr\", class_support, show_bdccsr_command,"
    },
    {
      "sha": "3fa0b65f0b6d57d11e051fd2544742c6141d6e0e",
      "filename": "gdb/s390-linux-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/s390-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/s390-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -79,7 +79,7 @@ static void\n s390_write_pc (struct regcache *regcache, CORE_ADDR pc)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   regcache_cooked_write_unsigned (regcache, tdep->pc_regnum, pc);\n \n@@ -269,7 +269,7 @@ s390_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t   void *cb_data,\n \t\t\t\t   const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const int gregset_size = (tdep->abi == ABI_LINUX_S390 ?\n \t\t\t    s390_sizeof_gregset : s390x_sizeof_gregset);\n \n@@ -390,7 +390,7 @@ s390_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n \t\t\t\t  void **this_prologue_cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int word_size = gdbarch_ptr_bit (gdbarch) / 8;\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct s390_sigtramp_unwind_cache *info;\n@@ -561,7 +561,7 @@ s390_linux_get_syscall_number (struct gdbarch *gdbarch,\n \t\t\t       thread_info *thread)\n {\n   struct regcache *regs = get_thread_regcache (thread);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   ULONGEST pc;\n   ULONGEST svc_number = -1;\n@@ -594,7 +594,7 @@ static int\n s390_all_but_pc_registers_record (struct regcache *regcache)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int i;\n \n   for (i = 0; i < 16; i++)\n@@ -802,7 +802,7 @@ static int\n s390_linux_syscall_record (struct regcache *regcache, LONGEST syscall_native)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int ret;\n   enum gdb_syscall syscall_gdb;\n \n@@ -852,7 +852,7 @@ static int\n s390_linux_record_signal (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t  enum gdb_signal signal)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   /* There are two kinds of signal frames on s390. rt_sigframe is always\n      the larger one, so don't even bother with sigframe.  */\n   const int sizeof_rt_sigframe = (tdep->abi == ABI_LINUX_ZSERIES ?\n@@ -1116,7 +1116,7 @@ s390_init_linux_record_tdep (struct linux_record_tdep *record_tdep,\n static void\n s390_linux_init_abi_any (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->s390_syscall_record = s390_linux_syscall_record;\n \n@@ -1151,7 +1151,7 @@ s390_linux_init_abi_any (struct gdbarch_info info, struct gdbarch *gdbarch)\n static void\n s390_linux_init_abi_31 (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->abi = ABI_LINUX_S390;\n \n@@ -1167,7 +1167,7 @@ s390_linux_init_abi_31 (struct gdbarch_info info, struct gdbarch *gdbarch)\n static void\n s390_linux_init_abi_64 (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->abi = ABI_LINUX_ZSERIES;\n "
    },
    {
      "sha": "abbb094b11e9b4f49b1e360686d71684340c20a1",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 40,
      "deletions": 34,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -1045,7 +1045,7 @@ s390_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n static int\n s390_register_call_saved (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   switch (tdep->abi)\n     {\n@@ -1076,7 +1076,7 @@ s390_guess_tracepoint_registers (struct gdbarch *gdbarch,\n \t\t\t\t struct regcache *regcache,\n \t\t\t\t CORE_ADDR addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int sz = register_size (gdbarch, S390_PSWA_REGNUM);\n   gdb_byte *reg = (gdb_byte *) alloca (sz);\n   ULONGEST pswm, pswa;\n@@ -1172,7 +1172,7 @@ enum { s390_dwarf_reg_r0l = ARRAY_SIZE (s390_dwarf_regmap) - 16 };\n static int\n s390_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int gdb_reg = -1;\n \n   /* In a 32-on-64 debug scenario, debug info refers to the full\n@@ -1205,7 +1205,7 @@ s390_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n    These pseudo-registers are composed of two adjacent gprs.  */\n \n static int\n-regnum_is_gpr_full (struct gdbarch_tdep *tdep, int regnum)\n+regnum_is_gpr_full (s390_gdbarch_tdep *tdep, int regnum)\n {\n   return (tdep->gpr_full_regnum != -1\n \t  && regnum >= tdep->gpr_full_regnum\n@@ -1216,7 +1216,7 @@ regnum_is_gpr_full (struct gdbarch_tdep *tdep, int regnum)\n    These pseudo-registers are composed of f0-f15 and v0l-v15l.  */\n \n static int\n-regnum_is_vxr_full (struct gdbarch_tdep *tdep, int regnum)\n+regnum_is_vxr_full (s390_gdbarch_tdep *tdep, int regnum)\n {\n   return (tdep->v0_full_regnum != -1\n \t  && regnum >= tdep->v0_full_regnum\n@@ -1231,7 +1231,7 @@ static struct value *\n s390_value_from_register (struct gdbarch *gdbarch, struct type *type,\n \t\t\t  int regnum, struct frame_id frame_id)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct value *value = default_value_from_register (gdbarch, type,\n \t\t\t\t\t\t     regnum, frame_id);\n   check_typedef (type);\n@@ -1250,7 +1250,7 @@ s390_value_from_register (struct gdbarch *gdbarch, struct type *type,\n static const char *\n s390_pseudo_register_name (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (regnum == tdep->pc_regnum)\n     return \"pc\";\n@@ -1284,7 +1284,7 @@ s390_pseudo_register_name (struct gdbarch *gdbarch, int regnum)\n static struct type *\n s390_pseudo_register_type (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (regnum == tdep->pc_regnum)\n     return builtin_type (gdbarch)->builtin_func_ptr;\n@@ -1308,7 +1308,7 @@ static enum register_status\n s390_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \t\t\t   int regnum, gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int regsize = register_size (gdbarch, regnum);\n   ULONGEST val;\n@@ -1383,7 +1383,7 @@ static void\n s390_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t    int regnum, const gdb_byte *buf)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int regsize = register_size (gdbarch, regnum);\n   ULONGEST val, psw;\n@@ -1442,7 +1442,7 @@ static int\n s390_pseudo_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n \t\t\t\t struct reggroup *group)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* We usually save/restore the whole PSW, which includes PC and CC.\n      However, some older gdbservers may not support saving/restoring\n@@ -1470,7 +1470,7 @@ static int\n s390_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n \t\t\t\t struct agent_expr *ax, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (regnum == tdep->pc_regnum)\n     {\n       ax_reg_mask (ax, S390_PSWA_REGNUM);\n@@ -1504,7 +1504,7 @@ static int\n s390_ax_pseudo_register_push_stack (struct gdbarch *gdbarch,\n \t\t\t\t    struct agent_expr *ax, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (regnum == tdep->pc_regnum)\n     {\n       ax_reg (ax, S390_PSWA_REGNUM);\n@@ -1746,7 +1746,7 @@ struct s390_arg_state\n \n static void\n s390_handle_arg (struct s390_arg_state *as, struct value *arg,\n-\t\t struct gdbarch_tdep *tdep, int word_size,\n+\t\t s390_gdbarch_tdep *tdep, int word_size,\n \t\t enum bfd_endian byte_order, int is_unnamed)\n {\n   struct type *type = check_typedef (value_type (arg));\n@@ -1905,7 +1905,7 @@ s390_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t      function_call_return_method return_method,\n \t\t      CORE_ADDR struct_addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int word_size = gdbarch_ptr_bit (gdbarch) / 8;\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int i;\n@@ -2083,11 +2083,14 @@ s390_return_value (struct gdbarch *gdbarch, struct value *function,\n       rvc = RETURN_VALUE_STRUCT_CONVENTION;\n       break;\n     case TYPE_CODE_ARRAY:\n-      rvc = (gdbarch_tdep (gdbarch)->vector_abi == S390_VECTOR_ABI_128\n-\t     && TYPE_LENGTH (type) <= 16 && type->is_vector ())\n-\t? RETURN_VALUE_REGISTER_CONVENTION\n-\t: RETURN_VALUE_STRUCT_CONVENTION;\n-      break;\n+      {\n+\ts390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\trvc = (tdep->vector_abi == S390_VECTOR_ABI_128\n+\t       && TYPE_LENGTH (type) <= 16 && type->is_vector ())\n+\t  ? RETURN_VALUE_REGISTER_CONVENTION\n+\t  : RETURN_VALUE_STRUCT_CONVENTION;\n+\tbreak;\n+      }\n     default:\n       rvc = TYPE_LENGTH (type) <= 8\n \t? RETURN_VALUE_REGISTER_CONVENTION\n@@ -2165,7 +2168,7 @@ s390_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR pc)\n static CORE_ADDR\n s390_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   ULONGEST pc;\n   pc = frame_unwind_register_unsigned (next_frame, tdep->pc_regnum);\n   return gdbarch_addr_bits_remove (gdbarch, pc);\n@@ -2187,7 +2190,7 @@ static struct value *\n s390_unwind_pseudo_register (struct frame_info *this_frame, int regnum)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   struct type *type = register_type (gdbarch, regnum);\n \n   /* Unwind PC via PSW address.  */\n@@ -2772,7 +2775,7 @@ static CORE_ADDR\n s390_record_address_mask (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t  CORE_ADDR val)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   ULONGEST pswm, pswa;\n   int am;\n   if (tdep->abi == ABI_LINUX_S390)\n@@ -2839,7 +2842,7 @@ s390_record_calc_disp_vsce (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t\t    uint8_t vx, uint8_t el, uint8_t es, uint16_t bd,\n \t\t\t    int8_t dh, CORE_ADDR *res)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   ULONGEST x;\n   gdb_byte buf[16];\n@@ -2882,7 +2885,7 @@ static int s390_popcnt (unsigned int x) {\n static int\n s390_record_gpr_g (struct gdbarch *gdbarch, struct regcache *regcache, int i)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (record_full_arch_list_add_reg (regcache, S390_R0_REGNUM + i))\n     return -1;\n   if (tdep->abi == ABI_LINUX_S390)\n@@ -2896,7 +2899,7 @@ s390_record_gpr_g (struct gdbarch *gdbarch, struct regcache *regcache, int i)\n static int\n s390_record_gpr_h (struct gdbarch *gdbarch, struct regcache *regcache, int i)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   if (tdep->abi == ABI_LINUX_S390)\n     {\n       if (record_full_arch_list_add_reg (regcache, S390_R0_UPPER_REGNUM + i))\n@@ -2936,7 +2939,7 @@ static int\n s390_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t     CORE_ADDR addr)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  s390_gdbarch_tdep *tdep = (s390_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   uint16_t insn[3] = {0};\n   /* Instruction as bytes.  */\n   uint8_t ibyte[6];\n@@ -6831,7 +6834,7 @@ while (0)\n    tdesc.  */\n \n static bool\n-s390_tdesc_valid (struct gdbarch_tdep *tdep,\n+s390_tdesc_valid (s390_gdbarch_tdep *tdep,\n \t\t  struct tdesc_arch_data *tdesc_data)\n {\n   static const char *const psw[] = {\n@@ -6983,10 +6986,10 @@ s390_tdesc_valid (struct gdbarch_tdep *tdep,\n /* Allocate and initialize new gdbarch_tdep.  Caller is responsible to free\n    memory after use.  */\n \n-static struct gdbarch_tdep *\n+static s390_gdbarch_tdep *\n s390_gdbarch_tdep_alloc ()\n {\n-  struct gdbarch_tdep *tdep = XCNEW (struct gdbarch_tdep);\n+  s390_gdbarch_tdep *tdep = new s390_gdbarch_tdep;\n \n   tdep->tdesc = NULL;\n \n@@ -7023,7 +7026,7 @@ s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   static const char *const stap_register_indirection_suffixes[] = { \")\",\n \t\t\t\t\t\t\t\t    NULL };\n \n-  struct gdbarch_tdep *tdep = s390_gdbarch_tdep_alloc ();\n+  s390_gdbarch_tdep *tdep = s390_gdbarch_tdep_alloc ();\n   struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep);\n   tdesc_arch_data_up tdesc_data = tdesc_data_alloc ();\n   info.tdesc_data = tdesc_data.get ();\n@@ -7153,7 +7156,7 @@ s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* Check any target description for validity.  */\n   if (!s390_tdesc_valid (tdep, tdesc_data.get ()))\n     {\n-      xfree (tdep);\n+      delete tdep;\n       gdbarch_free (gdbarch);\n       return NULL;\n     }\n@@ -7174,16 +7177,19 @@ s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      struct gdbarch_tdep *tmp = gdbarch_tdep (arches->gdbarch);\n+      s390_gdbarch_tdep *tmp\n+\t= (s390_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n       if (!tmp)\n \tcontinue;\n+\n       /* A program can 'choose' not to use the vector registers when they\n \t are present.  Leading to the same tdesc but different tdep and\n \t thereby a different gdbarch.  */\n       if (tmp->vector_abi != tdep->vector_abi)\n \tcontinue;\n \n-      xfree (tdep);\n+      delete tdep;\n       gdbarch_free (gdbarch);\n       return arches->gdbarch;\n     }"
    },
    {
      "sha": "191977ecf50383e185beb9c594fa81c216f12d12",
      "filename": "gdb/s390-tdep.h",
      "status": "modified",
      "additions": 17,
      "deletions": 16,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/s390-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/s390-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -37,32 +37,33 @@ enum s390_vector_abi_kind\n \n /* The tdep structure.  */\n \n-struct gdbarch_tdep\n+struct s390_gdbarch_tdep : gdbarch_tdep\n {\n   /* Target description.  */\n-  const struct target_desc *tdesc;\n+  const struct target_desc *tdesc = nullptr;\n \n   /* ABI version.  */\n-  enum s390_abi_kind abi;\n+  enum s390_abi_kind abi {};\n \n   /* Vector ABI.  */\n-  enum s390_vector_abi_kind vector_abi;\n+  enum s390_vector_abi_kind vector_abi {};\n \n   /* Pseudo register numbers.  */\n-  int gpr_full_regnum;\n-  int pc_regnum;\n-  int cc_regnum;\n-  int v0_full_regnum;\n-\n-  bool have_upper;\n-  bool have_linux_v1;\n-  bool have_linux_v2;\n-  bool have_tdb;\n-  bool have_vx;\n-  bool have_gs;\n+  int gpr_full_regnum = 0;\n+  int pc_regnum = 0;\n+  int cc_regnum = 0;\n+  int v0_full_regnum = 0;\n+\n+  bool have_upper = 0;\n+  bool have_linux_v1 = 0;\n+  bool have_linux_v2 = 0;\n+  bool have_tdb = 0;\n+  bool have_vx = 0;\n+  bool have_gs = 0;\n \n   /* Hook to record OS specific systemcall.  */\n-  int (*s390_syscall_record) (struct regcache *regcache, LONGEST svc_number);\n+  int (*s390_syscall_record) (struct regcache *regcache, LONGEST svc_number)\n+    = nullptr;\n };\n \n /* Decoding S/390 instructions.  */"
    },
    {
      "sha": "9d4bebb11aa9e893798c83e29e75a661c09e5674",
      "filename": "gdb/sh-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sh-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sh-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -195,7 +195,7 @@ sh_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n \t\t\t\t\t     svr4_fetch_objfile_link_map);\n \n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sh_gdbarch_tdep *tdep = (sh_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Remember regset characteristics.  The sizes should match\n      elf_gregset_t and elf_fpregset_t from Linux.  */"
    },
    {
      "sha": "ddb2c7e1ea8f0be8ba710b80b815e31dedca237b",
      "filename": "gdb/sh-netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sh-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sh-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-netbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -63,7 +63,7 @@ static void\n shnbsd_init_abi (struct gdbarch_info info,\n \t\t  struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sh_gdbarch_tdep *tdep = (sh_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   nbsd_init_abi (info, gdbarch);\n \n   tdep->core_gregmap = (struct sh_corefile_regmap *)regmap;"
    },
    {
      "sha": "4346e78c5e979c6e781149d6b04728e4c2e9bd7f",
      "filename": "gdb/sh-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sh-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sh-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -1554,7 +1554,7 @@ sh_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n static struct type *\n sh_littlebyte_bigword_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sh_gdbarch_tdep *tdep = (sh_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->sh_littlebyte_bigword_type == NULL)\n     tdep->sh_littlebyte_bigword_type\n@@ -2146,7 +2146,7 @@ sh_corefile_supply_regset (const struct regset *regset,\n \t\t\t   int regnum, const void *regs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sh_gdbarch_tdep *tdep = (sh_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const struct sh_corefile_regmap *regmap = (regset == &sh_corefile_gregset\n \t\t\t\t\t     ? tdep->core_gregmap\n \t\t\t\t\t     : tdep->core_fpregmap);\n@@ -2172,7 +2172,7 @@ sh_corefile_collect_regset (const struct regset *regset,\n \t\t\t    int regnum, void *regs, size_t len)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sh_gdbarch_tdep *tdep = (sh_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   const struct sh_corefile_regmap *regmap = (regset == &sh_corefile_gregset\n \t\t\t\t\t     ? tdep->core_gregmap\n \t\t\t\t\t     : tdep->core_fpregmap);\n@@ -2210,7 +2210,7 @@ sh_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t void *cb_data,\n \t\t\t\t const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sh_gdbarch_tdep *tdep = (sh_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->core_gregmap != NULL)\n     cb (\".reg\", tdep->sizeof_gregset, tdep->sizeof_gregset,\n@@ -2237,7 +2237,6 @@ static struct gdbarch *\n sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n \n   /* If there is already a candidate, use it.  */\n   arches = gdbarch_list_lookup_by_info (arches, &info);\n@@ -2246,7 +2245,7 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* None found, create a new architecture from the information\n      provided.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  sh_gdbarch_tdep *tdep = new sh_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);"
    },
    {
      "sha": "fce3f715f671c91126a88a28f88a786f8a6ade3f",
      "filename": "gdb/sh-tdep.h",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sh-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sh-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -19,6 +19,8 @@\n #ifndef SH_TDEP_H\n #define SH_TDEP_H\n \n+#include \"gdbarch.h\"\n+\n /* Contributed by Steve Chamberlain sac@cygnus.com.  */\n \n /* Registers for all SH variants.  Used also by sh3-rom.c.  */\n@@ -89,20 +91,20 @@ struct sh_corefile_regmap\n   unsigned int offset;\n };\n \n-struct gdbarch_tdep\n+struct sh_gdbarch_tdep : gdbarch_tdep\n {\n   /* Non-NULL when debugging from a core file.  Provides the offset\n      where each general-purpose register is stored inside the associated\n      core file section.  */\n-  struct sh_corefile_regmap *core_gregmap;\n-  int sizeof_gregset;\n+  struct sh_corefile_regmap *core_gregmap = nullptr;\n+  int sizeof_gregset = 0;\n   /* Non-NULL when debugging from a core file and when FP registers are\n      available.  Provides the offset where each FP register is stored\n      inside the associated core file section.  */\n-  struct sh_corefile_regmap *core_fpregmap;\n-  int sizeof_fpregset;\n+  struct sh_corefile_regmap *core_fpregmap = nullptr;\n+  int sizeof_fpregset = 0;\n   /* ISA-specific data types.  */\n-  struct type *sh_littlebyte_bigword_type;\n+  struct type *sh_littlebyte_bigword_type = nullptr;\n };\n \n extern const struct regset sh_corefile_gregset;"
    },
    {
      "sha": "9c46919e72bb48371c0d9617d892c98ba032e9a4",
      "filename": "gdb/sparc-linux-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -253,7 +253,8 @@ sparc32_linux_collect_core_fpregset (const struct regset *regset,\n static void\n sparc_linux_write_pc (struct regcache *regcache, CORE_ADDR pc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (regcache->arch ());\n+  gdbarch *arch = regcache->arch ();\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (arch);\n   ULONGEST psr;\n \n   regcache_cooked_write_unsigned (regcache, tdep->pc_regnum, pc);\n@@ -420,7 +421,7 @@ static const struct regset sparc32_linux_fpregset =\n static void\n sparc32_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 0);\n "
    },
    {
      "sha": "e600447ab99d93fe29934894a28602c57df8bfb8",
      "filename": "gdb/sparc-netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-netbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -295,7 +295,7 @@ static const struct regset sparc32nbsd_fpregset =\n void\n sparc32nbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   nbsd_init_abi (info, gdbarch);\n "
    },
    {
      "sha": "94e8a121a4cfad870168c44805bb9b34093c5a4c",
      "filename": "gdb/sparc-sol2-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-sol2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-sol2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-sol2-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -196,7 +196,7 @@ static const struct frame_unwind sparc32_sol2_sigtramp_frame_unwind =\n static void\n sparc32_sol2_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->gregset = &sparc32_sol2_gregset;\n   tdep->sizeof_gregset = 152;"
    },
    {
      "sha": "31916b60ddb7a5b6f88aae0f05a9a7cfb6f8a8fd",
      "filename": "gdb/sparc-tdep.c",
      "status": "modified",
      "additions": 11,
      "deletions": 10,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -429,7 +429,7 @@ sparc32_register_name (struct gdbarch *gdbarch, int regnum)\n static struct type *\n sparc_psr_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->sparc_psr_type)\n     {\n@@ -451,7 +451,7 @@ sparc_psr_type (struct gdbarch *gdbarch)\n static struct type *\n sparc_fsr_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->sparc_fsr_type)\n     {\n@@ -992,7 +992,7 @@ CORE_ADDR\n sparc_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t\t\tCORE_ADDR current_pc, struct sparc_frame_cache *cache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   unsigned long insn;\n   int offset = 0;\n   int dest = -1;\n@@ -1684,8 +1684,9 @@ sparc_analyze_control_transfer (struct regcache *regcache,\n       struct frame_info *frame = get_current_frame ();\n \n       /* Trap instruction (TRAP).  */\n-      return gdbarch_tdep (regcache->arch ())->step_trap (frame,\n-\t\t\t\t\t\t\t\t     insn);\n+      gdbarch *arch = regcache->arch ();\n+      sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (arch);\n+      return tdep->step_trap (frame, insn);\n     }\n \n   /* FIXME: Handle DONE and RETRY instructions.  */\n@@ -1735,7 +1736,7 @@ static std::vector<CORE_ADDR>\n sparc_software_single_step (struct regcache *regcache)\n {\n   struct gdbarch *arch = regcache->arch ();\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (arch);\n   CORE_ADDR npc, nnpc;\n \n   CORE_ADDR pc, orig_npc;\n@@ -1764,7 +1765,8 @@ sparc_software_single_step (struct regcache *regcache)\n static void\n sparc_write_pc (struct regcache *regcache, CORE_ADDR pc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (regcache->arch ());\n+  gdbarch *arch = regcache->arch ();\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (arch);\n \n   regcache_cooked_write_unsigned (regcache, tdep->pc_regnum, pc);\n   regcache_cooked_write_unsigned (regcache, tdep->npc_regnum, pc + 4);\n@@ -1779,7 +1781,7 @@ sparc_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \t\t\t\t    void *cb_data,\n \t\t\t\t    const struct regcache *regcache)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   cb (\".reg\", tdep->sizeof_gregset, tdep->sizeof_gregset, tdep->gregset, NULL,\n       cb_data);\n@@ -1814,7 +1816,6 @@ validate_tdesc_registers (const struct target_desc *tdesc,\n static struct gdbarch *\n sparc32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep;\n   const struct target_desc *tdesc = info.target_desc;\n   struct gdbarch *gdbarch;\n   int valid_p = 1;\n@@ -1825,7 +1826,7 @@ sparc32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     return arches->gdbarch;\n \n   /* Allocate space for the new architecture.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  sparc_gdbarch_tdep *tdep = new sparc_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   tdep->pc_regnum = SPARC32_PC_REGNUM;"
    },
    {
      "sha": "ceedb2cb595ada2f6a0996066c9042c1dba3ba6e",
      "filename": "gdb/sparc-tdep.h",
      "status": "modified",
      "additions": 23,
      "deletions": 20,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,6 +20,8 @@\n #ifndef SPARC_TDEP_H\n #define SPARC_TDEP_H 1\n \n+#include \"gdbarch.h\"\n+\n #define SPARC_CORE_REGISTERS                      \\\n   \"g0\", \"g1\", \"g2\", \"g3\", \"g4\", \"g5\", \"g6\", \"g7\", \\\n   \"o0\", \"o1\", \"o2\", \"o3\", \"o4\", \"o5\", \"sp\", \"o7\", \\\n@@ -55,43 +57,44 @@ struct sparc_fpregmap\n \n /* SPARC architecture-specific information.  */\n \n-struct gdbarch_tdep\n+struct sparc_gdbarch_tdep : gdbarch_tdep\n {\n   /* Register numbers for the PN and nPC registers.  The definitions\n      for (64-bit) UltraSPARC differ from the (32-bit) SPARC\n      definitions.  */\n-  int pc_regnum;\n-  int npc_regnum;\n+  int pc_regnum = 0;\n+  int npc_regnum = 0;\n \n   /* Register names specific for architecture (sparc32 vs. sparc64) */\n-  const char * const *fpu_register_names;\n-  size_t fpu_registers_num;\n-  const char * const *cp0_register_names;\n-  size_t cp0_registers_num;\n+  const char * const *fpu_register_names = nullptr;\n+  size_t fpu_registers_num = 0;\n+  const char * const *cp0_register_names = nullptr;\n+  size_t cp0_registers_num = 0;\n \n   /* Register sets.  */\n-  const struct regset *gregset;\n-  size_t sizeof_gregset;\n-  const struct regset *fpregset;\n-  size_t sizeof_fpregset;\n+  const struct regset *gregset = nullptr;\n+  size_t sizeof_gregset = 0;\n+  const struct regset *fpregset = nullptr;\n+  size_t sizeof_fpregset = 0;\n \n   /* Offset of saved PC in jmp_buf.  */\n-  int jb_pc_offset;\n+  int jb_pc_offset = 0;\n \n   /* Size of an Procedure Linkage Table (PLT) entry, 0 if we shouldn't\n      treat the PLT special when doing prologue analysis.  */\n-  size_t plt_entry_size;\n+  size_t plt_entry_size = 0;\n \n   /* Alternative location for trap return.  Used for single-stepping.  */\n-  CORE_ADDR (*step_trap) (struct frame_info *frame, unsigned long insn);\n+  CORE_ADDR (*step_trap) (struct frame_info *frame, unsigned long insn)\n+    = nullptr;\n \n   /* ISA-specific data types.  */\n-  struct type *sparc_psr_type;\n-  struct type *sparc_fsr_type;\n-  struct type *sparc64_ccr_type;\n-  struct type *sparc64_pstate_type;\n-  struct type *sparc64_fsr_type;\n-  struct type *sparc64_fprs_type;\n+  struct type *sparc_psr_type = nullptr;\n+  struct type *sparc_fsr_type = nullptr;\n+  struct type *sparc64_ccr_type = nullptr;\n+  struct type *sparc64_pstate_type = nullptr;\n+  struct type *sparc64_fsr_type = nullptr;\n+  struct type *sparc64_fprs_type = nullptr;\n };\n \n /* Register numbers of various important registers.  */"
    },
    {
      "sha": "d52162a55a92f459c0b57e8bd9e4c27158205c5f",
      "filename": "gdb/sparc64-fbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-fbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -222,7 +222,7 @@ static const struct regset sparc64fbsd_fpregset =\n static void\n sparc64fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Generic FreeBSD support. */\n   fbsd_init_abi (info, gdbarch);"
    },
    {
      "sha": "5b9cc9046563f2e8a37064d6f92da50c58bc232c",
      "filename": "gdb/sparc64-linux-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -261,7 +261,8 @@ sparc64_linux_collect_core_fpregset (const struct regset *regset,\n static void\n sparc64_linux_write_pc (struct regcache *regcache, CORE_ADDR pc)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (regcache->arch ());\n+  gdbarch *arch = regcache->arch ();\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (arch);\n   ULONGEST state;\n \n   regcache_cooked_write_unsigned (regcache, tdep->pc_regnum, pc);\n@@ -363,7 +364,7 @@ static const struct regset sparc64_linux_fpregset =\n static void\n sparc64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 0);\n "
    },
    {
      "sha": "81e37631d15beec229c985953d89190e942e5189",
      "filename": "gdb/sparc64-netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-netbsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -248,7 +248,7 @@ static const struct regset sparc64nbsd_fpregset =\n static void\n sparc64nbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   nbsd_init_abi (info, gdbarch);\n "
    },
    {
      "sha": "0931b23b92c046c8717d784310a707c883558445",
      "filename": "gdb/sparc64-obsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-obsd-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -423,7 +423,7 @@ static const struct regset sparc64obsd_fpregset =\n static void\n sparc64obsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->gregset = &sparc64obsd_gregset;\n   tdep->sizeof_gregset = 288;"
    },
    {
      "sha": "6c1fe192cb6592077fc593bda1382f8bb14f478e",
      "filename": "gdb/sparc64-sol2-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-sol2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-sol2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-sol2-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -199,7 +199,7 @@ static const struct frame_unwind sparc64_sol2_sigtramp_frame_unwind =\n static void\n sparc64_sol2_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->gregset = &sparc64_sol2_gregset;\n   tdep->sizeof_gregset = 304;"
    },
    {
      "sha": "cb698304d62bdd687e1a7ccc93595edcced6af94",
      "filename": "gdb/sparc64-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/sparc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -648,7 +648,7 @@ sparc64_structure_or_union_p (const struct type *type)\n static struct type *\n sparc64_pstate_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->sparc64_pstate_type)\n     {\n@@ -675,7 +675,7 @@ sparc64_pstate_type (struct gdbarch *gdbarch)\n static struct type *\n sparc64_ccr_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->sparc64_ccr_type == NULL)\n     {\n@@ -700,7 +700,7 @@ sparc64_ccr_type (struct gdbarch *gdbarch)\n static struct type *\n sparc64_fsr_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->sparc64_fsr_type)\n     {\n@@ -733,7 +733,7 @@ sparc64_fsr_type (struct gdbarch *gdbarch)\n static struct type *\n sparc64_fprs_type (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (!tdep->sparc64_fprs_type)\n     {\n@@ -1806,7 +1806,7 @@ sparc64_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr)\n void\n sparc64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  sparc_gdbarch_tdep *tdep = (sparc_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   tdep->pc_regnum = SPARC64_PC_REGNUM;\n   tdep->npc_regnum = SPARC64_NPC_REGNUM;"
    },
    {
      "sha": "ff5fec81375b5c936b16fb747a26c9ff1aeeaa56",
      "filename": "gdb/tic6x-linux-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/tic6x-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/tic6x-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tic6x-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -45,7 +45,7 @@ static const gdb_byte tic6x_bkpt_bnop_le[] = { 0x22, 0xa1, 0x00, 0x00 };\n static unsigned int\n tic6x_register_sigcontext_offset (unsigned int regnum, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  tic6x_gdbarch_tdep *tdep = (tic6x_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (regnum == TIC6X_A4_REGNUM || regnum == TIC6X_A4_REGNUM + 2\n       || regnum == TIC6X_A4_REGNUM + 4)\n@@ -92,7 +92,7 @@ tic6x_linux_rt_sigreturn_init (const struct tramp_frame *self,\n \t\t    + TIC6X_SIGINFO_SIZE\n \t\t    + 4 + 4 /* uc_flags and *uc_link in struct ucontext.  */\n \t\t    + TIC6X_STACK_T_SIZE);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  tic6x_gdbarch_tdep *tdep = (tic6x_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   unsigned int reg_offset;\n   unsigned int i;\n \n@@ -165,7 +165,7 @@ extern struct target_so_ops dsbt_so_ops;\n static void\n tic6x_uclinux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  tic6x_gdbarch_tdep *tdep = (tic6x_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   linux_init_abi (info, gdbarch, 0);\n "
    },
    {
      "sha": "7b1d83bd637397d6c20f76fcd4cdadb9e577e68b",
      "filename": "gdb/tic6x-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/tic6x-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/tic6x-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tic6x-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -325,7 +325,7 @@ tic6x_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)\n static const gdb_byte *\n tic6x_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  tic6x_gdbarch_tdep *tdep = (tic6x_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   *size = kind;\n \n@@ -598,7 +598,8 @@ tic6x_get_next_pc (struct regcache *regcache, CORE_ADDR pc)\n \n       if (inst == TIC6X_INST_SWE)\n \t{\n-\t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\t  tic6x_gdbarch_tdep *tdep\n+\t    = (tic6x_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n \t  if (tdep->syscall_next_pc != NULL)\n \t    return tdep->syscall_next_pc (get_current_frame ());\n@@ -1141,7 +1142,6 @@ static struct gdbarch *\n tic6x_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n   int has_gp = 0;\n@@ -1216,7 +1216,8 @@ tic6x_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      tdep = gdbarch_tdep (arches->gdbarch);\n+      tic6x_gdbarch_tdep *tdep\n+\t= (tic6x_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n \n       if (has_gp != tdep->has_gp)\n \tcontinue;\n@@ -1225,7 +1226,7 @@ tic6x_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \treturn arches->gdbarch;\n     }\n \n-  tdep = XCNEW (struct gdbarch_tdep);\n+  tic6x_gdbarch_tdep *tdep = new tic6x_gdbarch_tdep;\n \n   tdep->has_gp = has_gp;\n   gdbarch = gdbarch_alloc (&info, tdep);"
    },
    {
      "sha": "bb79a0dd95d2c0927818d96e03b8be919d5db015",
      "filename": "gdb/tic6x-tdep.h",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/tic6x-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/tic6x-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tic6x-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -20,6 +20,8 @@\n #ifndef TIC6X_TDEP_H\n #define TIC6X_TDEP_H\n \n+#include \"gdbarch.h\"\n+\n enum\n {\n   TIC6X_A4_REGNUM = 4,\n@@ -44,15 +46,15 @@ extern const gdb_byte tic6x_bkpt_illegal_opcode_be[];\n extern const gdb_byte tic6x_bkpt_illegal_opcode_le[];\n \n /* Target-dependent structure in gdbarch.  */\n-struct gdbarch_tdep\n+struct tic6x_gdbarch_tdep : gdbarch_tdep\n {\n   /* Return the expected next PC if FRAME is stopped at a syscall\n      instruction.  */\n-  CORE_ADDR (*syscall_next_pc) (struct frame_info *frame);\n+  CORE_ADDR (*syscall_next_pc) (struct frame_info *frame) = nullptr;\n \n-  const gdb_byte *breakpoint; /* Breakpoint instruction.  */\n+  const gdb_byte *breakpoint = nullptr; /* Breakpoint instruction.  */\n \n-  int has_gp; /* Has general purpose registers A16 - A31 and B16 - B31.  */\n+  int has_gp = 0; /* Has general purpose registers A16 - A31 and B16 - B31.  */\n };\n \n #endif /* TIC6X_TDEP_H */"
    },
    {
      "sha": "70f6d42a95b1651763e6e54f80d3557abd8e9b34",
      "filename": "gdb/v850-tdep.c",
      "status": "modified",
      "additions": 17,
      "deletions": 13,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/v850-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/v850-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/v850-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -264,15 +264,15 @@ enum v850_abi\n \n /* Architecture specific data.  */\n \n-struct gdbarch_tdep\n+struct v850_gdbarch_tdep : gdbarch_tdep\n {\n   /* Fields from the ELF header.  */\n-  int e_flags;\n-  int e_machine;\n+  int e_flags = 0;\n+  int e_machine = 0;\n \n   /* Which ABI are we using?  */\n-  enum v850_abi abi;\n-  int eight_byte_align;\n+  enum v850_abi abi {};\n+  int eight_byte_align = 0;\n };\n \n struct v850_frame_cache\n@@ -510,8 +510,9 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n {\n   int i;\n   struct type *fld_type, *tgt_type;\n+  v850_gdbarch_tdep *tdep = (v850_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n-  if (gdbarch_tdep (gdbarch)->abi == V850_ABI_RH850)\n+  if (tdep->abi == V850_ABI_RH850)\n     {\n       if (v850_type_is_scalar (type) && TYPE_LENGTH(type) <= 8)\n \treturn 0;\n@@ -1021,8 +1022,9 @@ v850_push_dummy_call (struct gdbarch *gdbarch,\n   int argnum;\n   int arg_space = 0;\n   int stack_offset;\n+  v850_gdbarch_tdep *tdep = (v850_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n-  if (gdbarch_tdep (gdbarch)->abi == V850_ABI_RH850)\n+  if (tdep->abi == V850_ABI_RH850)\n     stack_offset = 0;\n   else\n     {\n@@ -1054,7 +1056,7 @@ v850_push_dummy_call (struct gdbarch *gdbarch,\n       gdb_byte valbuf[v850_reg_size];\n \n       if (!v850_type_is_scalar (value_type (*args))\n-\t && gdbarch_tdep (gdbarch)->abi == V850_ABI_GCC\n+\t  && tdep->abi == V850_ABI_GCC\n \t  && TYPE_LENGTH (value_type (*args)) > E_MAX_RETTYPE_SIZE_IN_REGS)\n \t{\n \t  store_unsigned_integer (valbuf, 4, byte_order,\n@@ -1068,7 +1070,7 @@ v850_push_dummy_call (struct gdbarch *gdbarch,\n \t  val = (gdb_byte *) value_contents (*args).data ();\n \t}\n \n-      if (gdbarch_tdep (gdbarch)->eight_byte_align\n+      if (tdep->eight_byte_align\n \t  && v850_eight_byte_align_p (value_type (*args)))\n \t{\n \t  if (argreg <= E_ARGLAST_REGNUM && (argreg & 1))\n@@ -1348,7 +1350,6 @@ static struct gdbarch *\n v850_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   int e_flags, e_machine;\n \n   /* Extract the elf_flags if available.  */\n@@ -1371,13 +1372,16 @@ v850_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n        arches != NULL;\n        arches = gdbarch_list_lookup_by_info (arches->next, &info))\n     {\n-      if (gdbarch_tdep (arches->gdbarch)->e_flags != e_flags\n-\t  || gdbarch_tdep (arches->gdbarch)->e_machine != e_machine)\n+      v850_gdbarch_tdep *tdep\n+\t= (v850_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n+      if (tdep->e_flags != e_flags || tdep->e_machine != e_machine)\n \tcontinue;\n \n       return arches->gdbarch;\n     }\n-  tdep = XCNEW (struct gdbarch_tdep);\n+\n+  v850_gdbarch_tdep *tdep = new v850_gdbarch_tdep;\n   tdep->e_flags = e_flags;\n   tdep->e_machine = e_machine;\n "
    },
    {
      "sha": "57a9ff0b98dde17b2ea23771de6eb6cab0158473",
      "filename": "gdb/xtensa-config.c",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/xtensa-config.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/xtensa-config.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xtensa-config.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -62,7 +62,7 @@ const xtensa_mask_t xtensa_mask15 = { 1, xtensa_submask15 };\n \n \n /* Register map.  */\n-xtensa_register_t rmap[] = \n+static xtensa_register_t rmap[] =\n {\n   /*    idx ofs bi sz al targno  flags cp typ group name  */\n   XTREG(  0,  0,32, 4, 4,0x0020,0x0006,-2, 9,0x0100,pc,          0,0,0,0,0,0)\n@@ -213,9 +213,4 @@ xtensa_register_t rmap[] =\n   XTREG_END\n };\n \n-\n-\n-#ifdef XTENSA_CONFIG_INSTANTIATE\n-XTENSA_CONFIG_INSTANTIATE(rmap,0)\n-#endif\n-\n+xtensa_gdbarch_tdep xtensa_tdep (rmap);"
    },
    {
      "sha": "b24ebc5f17c427f309cb7b68ca0e7f97518f8498",
      "filename": "gdb/xtensa-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/xtensa-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/xtensa-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xtensa-linux-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -99,7 +99,7 @@ xtensa_linux_gdb_signal_to_target (struct gdbarch *gdbarch,\n static void\n xtensa_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (tdep->num_nopriv_regs < tdep->num_regs)\n     {"
    },
    {
      "sha": "f09d2335559b0a0a30fbbae25b1287d6c0e93a25",
      "filename": "gdb/xtensa-tdep.c",
      "status": "modified",
      "additions": 139,
      "deletions": 115,
      "changes": 254,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/xtensa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/xtensa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xtensa-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -86,13 +86,13 @@ static unsigned int xtensa_debug_level = 0;\n #define TX_PS\t\t\t0x20\n \n /* ABI-independent macros.  */\n-#define ARG_NOF(gdbarch) \\\n-  (gdbarch_tdep (gdbarch)->call_abi \\\n+#define ARG_NOF(tdep) \\\n+  (tdep->call_abi \\\n    == CallAbiCall0Only ? C0_NARGS : (ARGS_NUM_REGS))\n-#define ARG_1ST(gdbarch) \\\n-  (gdbarch_tdep (gdbarch)->call_abi  == CallAbiCall0Only \\\n-   ? (gdbarch_tdep (gdbarch)->a0_base + C0_ARGS) \\\n-   : (gdbarch_tdep (gdbarch)->a0_base + 6))\n+#define ARG_1ST(tdep) \\\n+  (tdep->call_abi  == CallAbiCall0Only \\\n+   ? (tdep->a0_base + C0_ARGS) \\\n+   : (tdep->a0_base + 6))\n \n /* XTENSA_IS_ENTRY tests whether the first byte of an instruction\n    indicates that the instruction is an ENTRY instruction.  */\n@@ -116,8 +116,10 @@ static unsigned int xtensa_debug_level = 0;\n static int\n windowing_enabled (struct gdbarch *gdbarch, unsigned int ps)\n {\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n   /* If we know CALL0 ABI is set explicitly,  say it is Call0.  */\n-  if (gdbarch_tdep (gdbarch)->call_abi == CallAbiCall0Only)\n+  if (tdep->call_abi == CallAbiCall0Only)\n     return 0;\n \n   return ((ps & PS_EXC) == 0 && (ps & PS_WOE) != 0);\n@@ -128,7 +130,7 @@ windowing_enabled (struct gdbarch *gdbarch, unsigned int ps)\n static int\n arreg_number (struct gdbarch *gdbarch, int a_regnum, ULONGEST wb)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int arreg;\n \n   arreg = a_regnum - tdep->a0_base;\n@@ -143,7 +145,7 @@ arreg_number (struct gdbarch *gdbarch, int a_regnum, ULONGEST wb)\n static int\n areg_number (struct gdbarch *gdbarch, int ar_regnum, unsigned int wb)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int areg;\n \n   areg = ar_regnum - tdep->ar_base;\n@@ -224,10 +226,10 @@ static int\n xtensa_find_register_by_name (struct gdbarch *gdbarch, const char *name)\n {\n   int i;\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   for (i = 0; i < gdbarch_num_cooked_regs (gdbarch); i++)\n-\n-    if (strcasecmp (gdbarch_tdep (gdbarch)->regmap[i].name, name) == 0)\n+    if (strcasecmp (tdep->regmap[i].name, name) == 0)\n       return i;\n \n   return -1;\n@@ -237,9 +239,11 @@ xtensa_find_register_by_name (struct gdbarch *gdbarch, const char *name)\n static const char *\n xtensa_register_name (struct gdbarch *gdbarch, int regnum)\n {\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n   /* Return the name stored in the register map.  */\n   if (regnum >= 0 && regnum < gdbarch_num_cooked_regs (gdbarch))\n-    return gdbarch_tdep (gdbarch)->regmap[regnum].name;\n+    return tdep->regmap[regnum].name;\n \n   internal_error (__FILE__, __LINE__, _(\"invalid register %d\"), regnum);\n   return 0;\n@@ -250,7 +254,7 @@ xtensa_register_name (struct gdbarch *gdbarch, int regnum)\n static struct type *\n xtensa_register_type (struct gdbarch *gdbarch, int regnum)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Return signed integer for ARx and Ax registers.  */\n   if ((regnum >= tdep->ar_base\n@@ -335,12 +339,13 @@ static int\n xtensa_reg_to_regnum (struct gdbarch *gdbarch, int regnum)\n {\n   int i;\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (regnum >= 0 && regnum < 16)\n-    return gdbarch_tdep (gdbarch)->a0_base + regnum;\n+    return tdep->a0_base + regnum;\n \n   for (i = 0; i < gdbarch_num_cooked_regs (gdbarch); i++)\n-    if (regnum == gdbarch_tdep (gdbarch)->regmap[i].target_number)\n+    if (regnum == tdep->regmap[i].target_number)\n       return i;\n \n   return -1;\n@@ -537,16 +542,17 @@ xtensa_pseudo_register_read (struct gdbarch *gdbarch,\n {\n   DEBUGTRACE (\"xtensa_pseudo_register_read (... regnum = %d (%s) ...)\\n\",\n \t      regnum, xtensa_register_name (gdbarch, regnum));\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Read aliases a0..a15, if this is a Windowed ABI.  */\n-  if (gdbarch_tdep (gdbarch)->isa_use_windowed_registers\n-      && (regnum >= gdbarch_tdep (gdbarch)->a0_base)\n-      && (regnum <= gdbarch_tdep (gdbarch)->a0_base + 15))\n+  if (tdep->isa_use_windowed_registers\n+      && (regnum >= tdep->a0_base)\n+      && (regnum <= tdep->a0_base + 15))\n     {\n       ULONGEST value;\n       enum register_status status;\n \n-      status = regcache->raw_read (gdbarch_tdep (gdbarch)->wb_regnum,\n+      status = regcache->raw_read (tdep->wb_regnum,\n \t\t\t\t   &value);\n       if (status != REG_VALID)\n \treturn status;\n@@ -560,8 +566,8 @@ xtensa_pseudo_register_read (struct gdbarch *gdbarch,\n   /* We have to find out how to deal with priveleged registers.\n      Let's treat them as pseudo-registers, but we cannot read/write them.  */\n      \n-  else if (gdbarch_tdep (gdbarch)->call_abi == CallAbiCall0Only\n-\t   || regnum < gdbarch_tdep (gdbarch)->a0_base)\n+  else if (tdep->call_abi == CallAbiCall0Only\n+\t   || regnum < tdep->a0_base)\n     {\n       buffer[0] = (gdb_byte)0;\n       buffer[1] = (gdb_byte)0;\n@@ -572,9 +578,9 @@ xtensa_pseudo_register_read (struct gdbarch *gdbarch,\n   /* Pseudo registers.  */\n   else if (regnum >= 0 && regnum < gdbarch_num_cooked_regs (gdbarch))\n     {\n-      xtensa_register_t *reg = &gdbarch_tdep (gdbarch)->regmap[regnum];\n+      xtensa_register_t *reg = &tdep->regmap[regnum];\n       xtensa_register_type_t type = reg->type;\n-      int flags = gdbarch_tdep (gdbarch)->target_flags;\n+      int flags = tdep->target_flags;\n \n       /* We cannot read Unknown or Unmapped registers.  */\n       if (type == xtRegisterTypeUnmapped || type == xtRegisterTypeUnknown)\n@@ -628,15 +634,16 @@ xtensa_pseudo_register_write (struct gdbarch *gdbarch,\n {\n   DEBUGTRACE (\"xtensa_pseudo_register_write (... regnum = %d (%s) ...)\\n\",\n \t      regnum, xtensa_register_name (gdbarch, regnum));\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Renumber register, if aliases a0..a15 on Windowed ABI.  */\n-  if (gdbarch_tdep (gdbarch)->isa_use_windowed_registers\n-      && (regnum >= gdbarch_tdep (gdbarch)->a0_base)\n-      && (regnum <= gdbarch_tdep (gdbarch)->a0_base + 15))\n+  if (tdep->isa_use_windowed_registers\n+      && (regnum >= tdep->a0_base)\n+      && (regnum <= tdep->a0_base + 15))\n     {\n       ULONGEST value;\n       regcache_raw_read_unsigned (regcache,\n-\t\t\t\t  gdbarch_tdep (gdbarch)->wb_regnum, &value);\n+\t\t\t\t  tdep->wb_regnum, &value);\n       regnum = arreg_number (gdbarch, regnum, value);\n     }\n \n@@ -648,16 +655,16 @@ xtensa_pseudo_register_write (struct gdbarch *gdbarch,\n   /* We have to find out how to deal with priveleged registers.\n      Let's treat them as pseudo-registers, but we cannot read/write them.  */\n \n-  else if (regnum < gdbarch_tdep (gdbarch)->a0_base)\n+  else if (regnum < tdep->a0_base)\n     {\n       return;\n     }\n   /* Pseudo registers.  */\n   else if (regnum >= 0 && regnum < gdbarch_num_cooked_regs (gdbarch))\n     {\n-      xtensa_register_t *reg = &gdbarch_tdep (gdbarch)->regmap[regnum];\n+      xtensa_register_t *reg = &tdep->regmap[regnum];\n       xtensa_register_type_t type = reg->type;\n-      int flags = gdbarch_tdep (gdbarch)->target_flags;\n+      int flags = tdep->target_flags;\n \n       /* On most targets, we cannot write registers\n \t of type \"Unknown\" or \"Unmapped\".  */\n@@ -770,7 +777,8 @@ xtensa_register_reggroup_p (struct gdbarch *gdbarch,\n \t\t\t    int regnum,\n \t\t\t    struct reggroup *group)\n {\n-  xtensa_register_t* reg = &gdbarch_tdep (gdbarch)->regmap[regnum];\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  xtensa_register_t* reg = &tdep->regmap[regnum];\n   xtensa_register_type_t type = reg->type;\n   xtensa_register_group_t rg = reg->group;\n   int cp_number;\n@@ -823,6 +831,7 @@ xtensa_supply_gregset (const struct regset *regset,\n {\n   const xtensa_elf_gregset_t *regs = (const xtensa_elf_gregset_t *) gregs;\n   struct gdbarch *gdbarch = rc->arch ();\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int i;\n \n   DEBUGTRACE (\"xtensa_supply_gregset (..., regnum==%d, ...)\\n\", regnum);\n@@ -831,33 +840,33 @@ xtensa_supply_gregset (const struct regset *regset,\n     rc->raw_supply (gdbarch_pc_regnum (gdbarch), (char *) &regs->pc);\n   if (regnum == gdbarch_ps_regnum (gdbarch) || regnum == -1)\n     rc->raw_supply (gdbarch_ps_regnum (gdbarch), (char *) &regs->ps);\n-  if (regnum == gdbarch_tdep (gdbarch)->wb_regnum || regnum == -1)\n-    rc->raw_supply (gdbarch_tdep (gdbarch)->wb_regnum,\n+  if (regnum == tdep->wb_regnum || regnum == -1)\n+    rc->raw_supply (tdep->wb_regnum,\n \t\t    (char *) &regs->windowbase);\n-  if (regnum == gdbarch_tdep (gdbarch)->ws_regnum || regnum == -1)\n-    rc->raw_supply (gdbarch_tdep (gdbarch)->ws_regnum,\n+  if (regnum == tdep->ws_regnum || regnum == -1)\n+    rc->raw_supply (tdep->ws_regnum,\n \t\t    (char *) &regs->windowstart);\n-  if (regnum == gdbarch_tdep (gdbarch)->lbeg_regnum || regnum == -1)\n-    rc->raw_supply (gdbarch_tdep (gdbarch)->lbeg_regnum,\n+  if (regnum == tdep->lbeg_regnum || regnum == -1)\n+    rc->raw_supply (tdep->lbeg_regnum,\n \t\t    (char *) &regs->lbeg);\n-  if (regnum == gdbarch_tdep (gdbarch)->lend_regnum || regnum == -1)\n-    rc->raw_supply (gdbarch_tdep (gdbarch)->lend_regnum,\n+  if (regnum == tdep->lend_regnum || regnum == -1)\n+    rc->raw_supply (tdep->lend_regnum,\n \t\t    (char *) &regs->lend);\n-  if (regnum == gdbarch_tdep (gdbarch)->lcount_regnum || regnum == -1)\n-    rc->raw_supply (gdbarch_tdep (gdbarch)->lcount_regnum,\n+  if (regnum == tdep->lcount_regnum || regnum == -1)\n+    rc->raw_supply (tdep->lcount_regnum,\n \t\t    (char *) &regs->lcount);\n-  if (regnum == gdbarch_tdep (gdbarch)->sar_regnum || regnum == -1)\n-    rc->raw_supply (gdbarch_tdep (gdbarch)->sar_regnum,\n+  if (regnum == tdep->sar_regnum || regnum == -1)\n+    rc->raw_supply (tdep->sar_regnum,\n \t\t    (char *) &regs->sar);\n-  if (regnum >=gdbarch_tdep (gdbarch)->ar_base\n-      && regnum < gdbarch_tdep (gdbarch)->ar_base\n-\t\t    + gdbarch_tdep (gdbarch)->num_aregs)\n+  if (regnum >=tdep->ar_base\n+      && regnum < tdep->ar_base\n+\t\t    + tdep->num_aregs)\n     rc->raw_supply\n-      (regnum, (char *) &regs->ar[regnum - gdbarch_tdep (gdbarch)->ar_base]);\n+      (regnum, (char *) &regs->ar[regnum - tdep->ar_base]);\n   else if (regnum == -1)\n     {\n-      for (i = 0; i < gdbarch_tdep (gdbarch)->num_aregs; ++i)\n-\trc->raw_supply (gdbarch_tdep (gdbarch)->ar_base + i,\n+      for (i = 0; i < tdep->num_aregs; ++i)\n+\trc->raw_supply (tdep->ar_base + i,\n \t\t\t(char *) &regs->ar[i]);\n     }\n }\n@@ -1051,12 +1060,13 @@ static struct frame_id\n xtensa_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)\n {\n   CORE_ADDR pc, fp;\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* THIS-FRAME is a dummy frame.  Return a frame ID of that frame.  */\n \n   pc = get_frame_pc (this_frame);\n   fp = get_frame_register_unsigned\n-\t (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);\n+\t (this_frame, tdep->a0_base + 1);\n \n   /* Make dummy frame ID unique by adding a constant.  */\n   return frame_id_build (fp + SP_ALIGNMENT, pc);\n@@ -1105,7 +1115,8 @@ xtensa_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR current_pc)\n {\n #define RETURN_FP goto done\n \n-  unsigned int fp_regnum = gdbarch_tdep (gdbarch)->a0_base + 1;\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  unsigned int fp_regnum = tdep->a0_base + 1;\n   CORE_ADDR start_addr;\n   xtensa_isa isa;\n   xtensa_insnbuf ins, slot;\n@@ -1182,7 +1193,7 @@ xtensa_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR current_pc)\n \t\t    RETURN_FP;\n \n \t\t  fp_regnum\n-\t\t    = gdbarch_tdep (gdbarch)->a0_base + register_operand;\n+\t\t    = tdep->a0_base + register_operand;\n \t\t  RETURN_FP;\n \t\t}\n \t    }\n@@ -1254,26 +1265,27 @@ xtensa_frame_cache (struct frame_info *this_frame, void **this_cache)\n   if (windowed)\n     {\n       LONGEST op1;\n+      xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n       /* Get WINDOWBASE, WINDOWSTART, and PS registers.  */\n       wb = get_frame_register_unsigned (this_frame, \n-\t\t\t\t\tgdbarch_tdep (gdbarch)->wb_regnum);\n+\t\t\t\t\ttdep->wb_regnum);\n       ws = get_frame_register_unsigned (this_frame,\n-\t\t\t\t\tgdbarch_tdep (gdbarch)->ws_regnum);\n+\t\t\t\t\ttdep->ws_regnum);\n \n       if (safe_read_memory_integer (pc, 1, byte_order, &op1)\n \t  && XTENSA_IS_ENTRY (gdbarch, op1))\n \t{\n \t  int callinc = CALLINC (ps);\n \t  ra = get_frame_register_unsigned\n-\t    (this_frame, gdbarch_tdep (gdbarch)->a0_base + callinc * 4);\n+\t    (this_frame, tdep->a0_base + callinc * 4);\n \t  \n \t  /* ENTRY hasn't been executed yet, therefore callsize is still 0.  */\n \t  cache->wd.callsize = 0;\n \t  cache->wd.wb = wb;\n \t  cache->wd.ws = ws;\n \t  cache->prev_sp = get_frame_register_unsigned\n-\t\t\t     (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);\n+\t\t\t     (this_frame, tdep->a0_base + 1);\n \n \t  /* This only can be the outermost frame since we are\n \t     just about to execute ENTRY.  SP hasn't been set yet.\n@@ -1292,10 +1304,10 @@ xtensa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t{\n \t  fp_regnum = xtensa_scan_prologue (gdbarch, pc);\n \t  ra = get_frame_register_unsigned (this_frame,\n-\t\t\t\t\t    gdbarch_tdep (gdbarch)->a0_base);\n+\t\t\t\t\t    tdep->a0_base);\n \t  cache->wd.callsize = WINSIZE (ra);\n \t  cache->wd.wb = (wb - cache->wd.callsize / 4)\n-\t\t\t  & (gdbarch_tdep (gdbarch)->num_aregs / 4 - 1);\n+\t\t\t  & (tdep->num_aregs / 4 - 1);\n \t  cache->wd.ws = ws & ~(1 << wb);\n \n \t  cache->pc = get_frame_func (this_frame);\n@@ -1310,7 +1322,7 @@ xtensa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n \t  /* Set A0...A3.  */\n \t  sp = get_frame_register_unsigned\n-\t    (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1) - 16;\n+\t    (this_frame, tdep->a0_base + 1) - 16;\n \t  \n \t  for (i = 0; i < 4; i++, sp += 4)\n \t    {\n@@ -1342,14 +1354,14 @@ xtensa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t      /* Register window overflow already happened.\n \t\t We can read caller's SP from the proper spill location.  */\n \t      sp = get_frame_register_unsigned\n-\t\t(this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);\n+\t\t(this_frame, tdep->a0_base + 1);\n \t      cache->prev_sp = read_memory_integer (sp - 12, 4, byte_order);\n \t    }\n \t  else\n \t    {\n \t      /* Read caller's frame SP directly from the previous window.  */\n \t      int regnum = arreg_number\n-\t\t\t     (gdbarch, gdbarch_tdep (gdbarch)->a0_base + 1,\n+\t\t\t     (gdbarch, tdep->a0_base + 1,\n \t\t\t      cache->wd.wb);\n \n \t      cache->prev_sp = xtensa_read_register (regnum);\n@@ -1415,20 +1427,21 @@ xtensa_frame_prev_register (struct frame_info *this_frame,\n   struct xtensa_frame_cache *cache;\n   ULONGEST saved_reg = 0;\n   int done = 1;\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   if (*this_cache == NULL)\n     *this_cache = xtensa_frame_cache (this_frame, this_cache);\n   cache = (struct xtensa_frame_cache *) *this_cache;\n \n   if (regnum ==gdbarch_pc_regnum (gdbarch))\n     saved_reg = cache->ra;\n-  else if (regnum == gdbarch_tdep (gdbarch)->a0_base + 1)\n+  else if (regnum == tdep->a0_base + 1)\n     saved_reg = cache->prev_sp;\n   else if (!cache->call0)\n     {\n-      if (regnum == gdbarch_tdep (gdbarch)->ws_regnum)\n+      if (regnum == tdep->ws_regnum)\n \tsaved_reg = cache->wd.ws;\n-      else if (regnum == gdbarch_tdep (gdbarch)->wb_regnum)\n+      else if (regnum == tdep->wb_regnum)\n \tsaved_reg = cache->wd.wb;\n       else if (regnum == gdbarch_ps_regnum (gdbarch))\n \tsaved_reg = cache->ps;\n@@ -1445,14 +1458,14 @@ xtensa_frame_prev_register (struct frame_info *this_frame,\n     {\n       /* Convert A-register numbers to AR-register numbers,\n \t if we deal with A-register.  */\n-      if (regnum >= gdbarch_tdep (gdbarch)->a0_base\n-\t  && regnum <= gdbarch_tdep (gdbarch)->a0_base + 15)\n+      if (regnum >= tdep->a0_base\n+\t  && regnum <= tdep->a0_base + 15)\n \tregnum = arreg_number (gdbarch, regnum, cache->wd.wb);\n \n       /* Check, if we deal with AR-register saved on stack.  */\n-      if (regnum >= gdbarch_tdep (gdbarch)->ar_base\n-\t  && regnum <= (gdbarch_tdep (gdbarch)->ar_base\n-\t\t\t + gdbarch_tdep (gdbarch)->num_aregs))\n+      if (regnum >= tdep->ar_base\n+\t  && regnum <= (tdep->ar_base\n+\t\t\t + tdep->num_aregs))\n \t{\n \t  int areg = areg_number (gdbarch, regnum, cache->wd.wb);\n \n@@ -1465,10 +1478,10 @@ xtensa_frame_prev_register (struct frame_info *this_frame,\n     }\n   else /* Call0 ABI.  */\n     {\n-      int reg = (regnum >= gdbarch_tdep (gdbarch)->ar_base\n-\t\t&& regnum <= (gdbarch_tdep (gdbarch)->ar_base\n+      int reg = (regnum >= tdep->ar_base\n+\t\t&& regnum <= (tdep->ar_base\n \t\t\t       + C0_NREGS))\n-\t\t  ? regnum - gdbarch_tdep (gdbarch)->ar_base : regnum;\n+\t\t  ? regnum - tdep->ar_base : regnum;\n \n       if (reg < C0_NREGS)\n \t{\n@@ -1543,7 +1556,8 @@ xtensa_extract_return_value (struct type *type,\n \n   gdb_assert(len > 0);\n \n-  if (gdbarch_tdep (gdbarch)->call_abi != CallAbiCall0Only)\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  if (tdep->call_abi != CallAbiCall0Only)\n     {\n       /* First, we have to find the caller window in the register file.  */\n       regcache_raw_read_unsigned (regcache, gdbarch_pc_regnum (gdbarch), &pc);\n@@ -1558,14 +1572,14 @@ xtensa_extract_return_value (struct type *type,\n       /* Get the register offset of the return\n \t register (A2) in the caller window.  */\n       regcache_raw_read_unsigned\n-\t(regcache, gdbarch_tdep (gdbarch)->wb_regnum, &wb);\n+\t(regcache, tdep->wb_regnum, &wb);\n       areg = arreg_number (gdbarch,\n-\t\t\t  gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);\n+\t\t\t  tdep->a0_base + 2 + callsize, wb);\n     }\n   else\n     {\n       /* No windowing hardware - Call0 ABI.  */\n-      areg = gdbarch_tdep (gdbarch)->a0_base + C0_ARGS;\n+      areg = tdep->a0_base + C0_ARGS;\n     }\n \n   DEBUGINFO (\"[xtensa_extract_return_value] areg %d len %d\\n\", areg, len);\n@@ -1598,10 +1612,11 @@ xtensa_store_return_value (struct type *type,\n \n   DEBUGTRACE (\"xtensa_store_return_value (...)\\n\");\n \n-  if (gdbarch_tdep (gdbarch)->call_abi != CallAbiCall0Only)\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  if (tdep->call_abi != CallAbiCall0Only)\n     {\n       regcache_raw_read_unsigned \n-\t(regcache, gdbarch_tdep (gdbarch)->wb_regnum, &wb);\n+\t(regcache, tdep->wb_regnum, &wb);\n       regcache_raw_read_unsigned (regcache, gdbarch_pc_regnum (gdbarch), &pc);\n       callsize = extract_call_winsize (gdbarch, pc);\n \n@@ -1610,14 +1625,14 @@ xtensa_store_return_value (struct type *type,\n \t\t\t_(\"unimplemented for this length: %s\"),\n \t\t\tpulongest (TYPE_LENGTH (type)));\n       areg = arreg_number (gdbarch,\n-\t\t\t   gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);\n+\t\t\t   tdep->a0_base + 2 + callsize, wb);\n \n       DEBUGTRACE (\"[xtensa_store_return_value] callsize %d wb %d\\n\",\n \t      callsize, (int) wb);\n     }\n   else\n     {\n-      areg = gdbarch_tdep (gdbarch)->a0_base + C0_ARGS;\n+      areg = tdep->a0_base + C0_ARGS;\n     }\n \n   if (len < 4 && gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)\n@@ -1681,6 +1696,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n \t\t\tCORE_ADDR struct_addr)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   int size, onstack_size;\n   gdb_byte *buf = (gdb_byte *) alloca (16);\n   CORE_ADDR ra, ps;\n@@ -1793,7 +1809,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n       size = (size + info->align - 1) & ~(info->align - 1);\n       onstack_size = (onstack_size + info->align - 1) & ~(info->align - 1);\n \n-      if (size + info->length > REGISTER_SIZE * ARG_NOF (gdbarch))\n+      if (size + info->length > REGISTER_SIZE * ARG_NOF (tdep))\n \t{\n \t  info->onstack = 1;\n \t  info->u.offset = onstack_size;\n@@ -1802,7 +1818,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n       else\n \t{\n \t  info->onstack = 0;\n-\t  info->u.regno = ARG_1ST (gdbarch) + size / REGISTER_SIZE;\n+\t  info->u.regno = ARG_1ST (tdep) + size / REGISTER_SIZE;\n \t}\n       size += info->length;\n     }\n@@ -1811,7 +1827,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n   sp = align_down (sp - onstack_size, SP_ALIGNMENT);\n \n   /* Simulate MOVSP, if Windowed ABI.  */\n-  if ((gdbarch_tdep (gdbarch)->call_abi != CallAbiCall0Only)\n+  if ((tdep->call_abi != CallAbiCall0Only)\n       && (sp != osp))\n     {\n       read_memory (osp - 16, buf, 16);\n@@ -1823,7 +1839,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n   if (return_method == return_method_struct)\n     {\n       store_unsigned_integer (buf, REGISTER_SIZE, byte_order, struct_addr);\n-      regcache->cooked_write (ARG_1ST (gdbarch), buf);\n+      regcache->cooked_write (ARG_1ST (tdep), buf);\n     }\n \n   for (int i = 0; i < nargs; i++)\n@@ -1887,15 +1903,15 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n      The return address for the current function (in A0) is\n      saved in the dummy frame, so we can safely overwrite A0 here.  */\n \n-  if (gdbarch_tdep (gdbarch)->call_abi != CallAbiCall0Only)\n+  if (tdep->call_abi != CallAbiCall0Only)\n     {\n       ULONGEST val;\n \n       ra = (bp_addr & 0x3fffffff) | 0x40000000;\n       regcache_raw_read_unsigned (regcache, gdbarch_ps_regnum (gdbarch), &val);\n       ps = (unsigned long) val & ~0x00030000;\n       regcache_cooked_write_unsigned\n-\t(regcache, gdbarch_tdep (gdbarch)->a0_base + 4, ra);\n+\t(regcache, tdep->a0_base + 4, ra);\n       regcache_cooked_write_unsigned (regcache,\n \t\t\t\t      gdbarch_ps_regnum (gdbarch),\n \t\t\t\t      ps | 0x00010000);\n@@ -1905,21 +1921,21 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n \t to modify WINDOWSTART register to make it look like there\n \t is only one register window corresponding to WINDOWEBASE.  */\n \n-      regcache->raw_read (gdbarch_tdep (gdbarch)->wb_regnum, buf);\n+      regcache->raw_read (tdep->wb_regnum, buf);\n       regcache_cooked_write_unsigned\n-\t(regcache, gdbarch_tdep (gdbarch)->ws_regnum,\n+\t(regcache, tdep->ws_regnum,\n \t 1 << extract_unsigned_integer (buf, 4, byte_order));\n     }\n   else\n     {\n       /* Simulate CALL0: write RA into A0 register.  */\n       regcache_cooked_write_unsigned\n-\t(regcache, gdbarch_tdep (gdbarch)->a0_base, bp_addr);\n+\t(regcache, tdep->a0_base, bp_addr);\n     }\n \n   /* Set new stack pointer and return it.  */\n   regcache_cooked_write_unsigned (regcache,\n-\t\t\t\t  gdbarch_tdep (gdbarch)->a0_base + 1, sp);\n+\t\t\t\t  tdep->a0_base + 1, sp);\n   /* Make dummy frame ID unique by adding a constant.  */\n   return sp + SP_ALIGNMENT;\n }\n@@ -1929,7 +1945,9 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n static int\n xtensa_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)\n {\n-  if (gdbarch_tdep (gdbarch)->isa_use_density_instructions)\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+\n+  if (tdep->isa_use_density_instructions)\n     return 2;\n   else\n     return 4;\n@@ -2174,6 +2192,7 @@ call0_track_op (struct gdbarch *gdbarch, xtensa_c0reg_t dst[], xtensa_c0reg_t sr\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   unsigned litbase, litaddr, litval;\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   switch (opclass)\n     {\n@@ -2264,9 +2283,9 @@ call0_track_op (struct gdbarch *gdbarch, xtensa_c0reg_t dst[], xtensa_c0reg_t sr\n       /* 2 operands: dst, literal offset.  */\n       gdb_assert (nods == 2);\n       /* litbase = xtensa_get_litbase (pc);  can be also used.  */\n-      litbase = (gdbarch_tdep (gdbarch)->litbase_regnum == -1)\n+      litbase = (tdep->litbase_regnum == -1)\n \t? 0 : xtensa_read_register\n-\t\t(gdbarch_tdep (gdbarch)->litbase_regnum);\n+\t\t(tdep->litbase_regnum);\n       litaddr = litbase & 1\n \t\t  ? (litbase & ~1) + (signed)odv[1]\n \t\t  : (pc + 3  + (signed)odv[1]) & ~3;\n@@ -2548,9 +2567,10 @@ call0_frame_cache (struct frame_info *this_frame,\n   CORE_ADDR body_pc=UINT_MAX;\t/* PC, where prologue analysis stopped.  */\n   CORE_ADDR sp, fp, ra;\n   int fp_regnum = C0_SP, c0_hasfp = 0, c0_frmsz = 0, prev_sp = 0, to_stk;\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n  \n   sp = get_frame_register_unsigned\n-    (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);\n+    (this_frame, tdep->a0_base + 1);\n   fp = sp; /* Assume FP == SP until proven otherwise.  */\n \n   /* Find the beginning of the prologue of the function containing the PC\n@@ -2584,12 +2604,12 @@ call0_frame_cache (struct frame_info *this_frame,\n \t was derived from SP.  Otherwise, it would be C0_FP.  */\n       fp_regnum = c0_hasfp ? C0_FP : C0_SP;\n       c0_frmsz = - cache->c0.c0_rt[fp_regnum].fr_ofs;\n-      fp_regnum += gdbarch_tdep (gdbarch)->a0_base;\n+      fp_regnum += tdep->a0_base;\n     }\n   else  /* No data from the prologue analysis.  */\n     {\n       c0_hasfp = 0;\n-      fp_regnum = gdbarch_tdep (gdbarch)->a0_base + C0_SP;\n+      fp_regnum = tdep->a0_base + C0_SP;\n       c0_frmsz = 0;\n       start_pc = pc;\n    }\n@@ -2613,7 +2633,7 @@ call0_frame_cache (struct frame_info *this_frame,\n       if (cache->c0.c0_sp_ofs == C0_NOSTK)\n \t/* Saved unaligned value of SP is kept in a register.  */\n \tunaligned_sp = get_frame_register_unsigned\n-\t  (this_frame, gdbarch_tdep (gdbarch)->a0_base + cache->c0.c0_old_sp);\n+\t  (this_frame, tdep->a0_base + cache->c0.c0_old_sp);\n       else\n \t/* Get the value from stack.  */\n \tunaligned_sp = (CORE_ADDR)\n@@ -2673,7 +2693,7 @@ call0_frame_cache (struct frame_info *this_frame,\n \t{\n \t  ra = get_frame_register_unsigned\n \t    (this_frame,\n-\t     gdbarch_tdep (gdbarch)->a0_base + cache->c0.c0_rt[i].fr_reg);\n+\t     tdep->a0_base + cache->c0.c0_rt[i].fr_reg);\n \t}\n       else ra = 0;\n     }\n@@ -2700,8 +2720,9 @@ static int a11_was_saved;\n static void\n execute_l32e (struct gdbarch *gdbarch, int at, int as, int offset, CORE_ADDR wb)\n {\n-  int atreg = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base + at, wb);\n-  int asreg = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base + as, wb);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int atreg = arreg_number (gdbarch, tdep->a0_base + at, wb);\n+  int asreg = arreg_number (gdbarch, tdep->a0_base + as, wb);\n   CORE_ADDR addr = xtensa_read_register (asreg) + offset;\n   unsigned int spilled_value\n     = read_memory_unsigned_integer (addr, 4, gdbarch_byte_order (gdbarch));\n@@ -2729,8 +2750,9 @@ execute_l32e (struct gdbarch *gdbarch, int at, int as, int offset, CORE_ADDR wb)\n static void\n execute_s32e (struct gdbarch *gdbarch, int at, int as, int offset, CORE_ADDR wb)\n {\n-  int atreg = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base + at, wb);\n-  int asreg = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base + as, wb);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int atreg = arreg_number (gdbarch, tdep->a0_base + at, wb);\n+  int asreg = arreg_number (gdbarch, tdep->a0_base + as, wb);\n   CORE_ADDR addr = xtensa_read_register (asreg) + offset;\n   ULONGEST spilled_value = xtensa_read_register (atreg);\n \n@@ -2762,6 +2784,7 @@ execute_code (struct gdbarch *gdbarch, CORE_ADDR current_pc, CORE_ADDR wb)\n   xtensa_opcode opc;\n   int insn_num = 0;\n   void (*func) (struct gdbarch *, int, int, int, CORE_ADDR);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   uint32_t at, as, offset;\n \n@@ -2827,7 +2850,7 @@ execute_code (struct gdbarch *gdbarch, CORE_ADDR current_pc, CORE_ADDR wb)\n \t      if (a0_was_saved)\n \t\t{\n \t\t  int arreg = arreg_number (gdbarch,\n-\t\t\t\t\t    gdbarch_tdep (gdbarch)->a0_base,\n+\t\t\t\t\t    tdep->a0_base,\n \t\t\t\t\t    wb);\n \t\t  xtensa_write_register (arreg, a0_saved);\n \t\t}\n@@ -2840,15 +2863,15 @@ execute_code (struct gdbarch *gdbarch, CORE_ADDR current_pc, CORE_ADDR wb)\n \t\t  if (a11_was_saved)\n \t\t    {\n \t\t      int arreg = arreg_number (gdbarch,\n-\t\t\t\t\t\tgdbarch_tdep (gdbarch)->a0_base + 11,\n+\t\t\t\t\t\ttdep->a0_base + 11,\n \t\t\t\t\t\twb);\n \t\t      xtensa_write_register (arreg, a11_saved);\n \t\t    }\n \t\t}\n \t      else if (a7_was_saved)\n \t\t{\n \t\t  int arreg = arreg_number (gdbarch,\n-\t\t\t\t\t    gdbarch_tdep (gdbarch)->a0_base + 7,\n+\t\t\t\t\t    tdep->a0_base + 7,\n \t\t\t\t\t    wb);\n \t\t  xtensa_write_register (arreg, a7_saved);\n \t\t}\n@@ -2892,12 +2915,13 @@ xtensa_window_interrupt_frame_cache (struct frame_info *this_frame,\n   CORE_ADDR ps, wb, ws, ra;\n   int epc1_regnum, i, regnum;\n   xtensa_exception_handler_t eh_type;\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \n   /* Read PS, WB, and WS from the hardware. Note that PS register\n      must be present, if Windowed ABI is supported.  */\n   ps = xtensa_read_register (gdbarch_ps_regnum (gdbarch));\n-  wb = xtensa_read_register (gdbarch_tdep (gdbarch)->wb_regnum);\n-  ws = xtensa_read_register (gdbarch_tdep (gdbarch)->ws_regnum);\n+  wb = xtensa_read_register (tdep->wb_regnum);\n+  ws = xtensa_read_register (tdep->ws_regnum);\n \n   /* Execute all the remaining instructions from Window Interrupt Handler\n      by simulating them on the remote protocol level.  On return, set the\n@@ -2920,15 +2944,15 @@ Unable to decode Xtensa Window Interrupt Handler's code.\"));\n     cache->wd.ws = ws | (1 << wb);\n \n   cache->wd.wb = (ps & 0xf00) >> 8; /* Set WB to OWB.  */\n-  regnum = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base,\n+  regnum = arreg_number (gdbarch, tdep->a0_base,\n \t\t\t cache->wd.wb);\n   ra = xtensa_read_register (regnum);\n   cache->wd.callsize = WINSIZE (ra);\n   cache->prev_sp = xtensa_read_register (regnum + 1);\n   /* Set regnum to a frame pointer of the frame being cached.  */\n   regnum = xtensa_scan_prologue (gdbarch, pc);\n   regnum = arreg_number (gdbarch,\n-\t\t\t gdbarch_tdep (gdbarch)->a0_base + regnum,\n+\t\t\t tdep->a0_base + regnum,\n \t\t\t cache->wd.wb);\n   cache->base = get_frame_register_unsigned (this_frame, regnum);\n \n@@ -3005,7 +3029,8 @@ xtensa_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)\n \n       CORE_ADDR end_func;\n \n-      if ((gdbarch_tdep (gdbarch)->call_abi == CallAbiCall0Only)\n+      xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+      if ((tdep->call_abi == CallAbiCall0Only)\n \t  && call0_ret (start_pc, prologue_sal.end))\n \treturn start_pc;\n \n@@ -3026,7 +3051,7 @@ xtensa_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)\n static void\n xtensa_verify_config (struct gdbarch *gdbarch)\n {\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  xtensa_gdbarch_tdep *tdep = (xtensa_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n   string_file log;\n \n   /* Verify that we got a reasonable number of AREGS.  */\n@@ -3064,7 +3089,7 @@ xtensa_verify_config (struct gdbarch *gdbarch)\n /* Derive specific register numbers from the array of registers.  */\n \n static void\n-xtensa_derive_tdep (struct gdbarch_tdep *tdep)\n+xtensa_derive_tdep (xtensa_gdbarch_tdep *tdep)\n {\n   xtensa_register_t* rmap;\n   int n, max_size = 4;\n@@ -3139,12 +3164,11 @@ xtensa_derive_tdep (struct gdbarch_tdep *tdep)\n \n /* Module \"constructor\" function.  */\n \n-extern struct gdbarch_tdep xtensa_tdep;\n+extern xtensa_gdbarch_tdep xtensa_tdep;\n \n static struct gdbarch *\n xtensa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n \n   DEBUGTRACE (\"gdbarch_init()\\n\");\n@@ -3155,7 +3179,7 @@ xtensa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* We have to set the byte order before we call gdbarch_alloc.  */\n   info.byte_order = XCHAL_HAVE_BE ? BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;\n \n-  tdep = &xtensa_tdep;\n+  xtensa_gdbarch_tdep *tdep = &xtensa_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n   xtensa_derive_tdep (tdep);\n "
    },
    {
      "sha": "64e4da69dc58f2865ab209c3f3c53d48e92cf927",
      "filename": "gdb/xtensa-tdep.h",
      "status": "modified",
      "additions": 68,
      "deletions": 112,
      "changes": 180,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/xtensa-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/xtensa-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xtensa-tdep.h?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -21,6 +21,8 @@\n #define XTENSA_TDEP_H\n \n #include \"arch/xtensa.h\"\n+#include \"gdbarch.h\"\n+#include \"xtensa-config.h\"\n \n /* XTENSA_TDEP_VERSION can/should be changed along with XTENSA_CONFIG_VERSION\n    whenever the \"tdep\" structure changes in an incompatible way.  */\n@@ -155,137 +157,91 @@ struct ctype_cache\n   struct type *virtual_type;\n };\n \n+#ifndef XCHAL_NUM_CONTEXTS\n+# define XCHAL_NUM_CONTEXTS\t0\n+#endif\n+\n+#ifndef XCHAL_HAVE_EXCEPTIONS\n+# define XCHAL_HAVE_EXCEPTIONS\t1\n+#endif\n+\n /*  Xtensa-specific target dependencies.  */\n \n-struct gdbarch_tdep\n+struct xtensa_gdbarch_tdep : gdbarch_tdep\n {\n-  unsigned int target_flags;\n+  xtensa_gdbarch_tdep (xtensa_register_t *regmap)\n+    : regmap (regmap)\n+  {}\n+\n+  unsigned int target_flags = 0;\n \n   /* Spill location for TIE register files under ocd.  */\n \n-  unsigned int spill_location;\n-  unsigned int spill_size;\n+  unsigned int spill_location = (unsigned int) -1;\n+  unsigned int spill_size = 0;\n \n-  char *unused;\t\t\t\t/* Placeholder for compatibility.  */\n-  call_abi_t call_abi;\t\t\t/* Calling convention.  */\n+  char *unused = nullptr;\t\t/* Placeholder for compatibility.  */\n+\n+  /* Calling convention.  */\n+  call_abi_t call_abi = (XSHAL_ABI == XTHAL_ABI_CALL0\n+\t\t\t ? CallAbiCall0Only : CallAbiDefault);\n \n   /* CPU configuration.  */\n \n-  unsigned int debug_interrupt_level;\n+  unsigned int debug_interrupt_level = XCHAL_DEBUGLEVEL;\n \n-  unsigned int icache_line_bytes;\n-  unsigned int dcache_line_bytes;\n-  unsigned int dcache_writeback;\n+  unsigned int icache_line_bytes = XCHAL_ICACHE_LINESIZE;\n+  unsigned int dcache_line_bytes = XCHAL_DCACHE_LINESIZE;\n+  unsigned int dcache_writeback = XCHAL_DCACHE_IS_WRITEBACK;\n \n-  unsigned int isa_use_windowed_registers;\n-  unsigned int isa_use_density_instructions;\n-  unsigned int isa_use_exceptions;\n-  unsigned int isa_use_ext_l32r;\n-  unsigned int isa_max_insn_size;\t/* Maximum instruction length.  */\n-  unsigned int debug_num_ibreaks;\t/* Number of IBREAKs.  */\n-  unsigned int debug_num_dbreaks;\n+  unsigned int isa_use_windowed_registers = XSHAL_ABI != XTHAL_ABI_CALL0;\n+  unsigned int isa_use_density_instructions = XCHAL_HAVE_DENSITY;\n+  unsigned int isa_use_exceptions = XCHAL_HAVE_EXCEPTIONS;\n+  unsigned int isa_use_ext_l32r = XSHAL_USE_ABSOLUTE_LITERALS;\n+  unsigned int isa_max_insn_size = XCHAL_MAX_INSTRUCTION_SIZE;\t/* Maximum instruction length.  */\n+  unsigned int debug_num_ibreaks = XCHAL_NUM_IBREAK;\t/* Number of IBREAKs.  */\n+  unsigned int debug_num_dbreaks = XCHAL_NUM_DBREAK;\n \n   /* Register map.  */\n \n-  xtensa_register_t* regmap;\n-\n-  unsigned int num_regs;\t/* Number of registers in register map.  */\n-  unsigned int num_nopriv_regs;\t/* Number of non-privileged registers.  */\n-  unsigned int num_pseudo_regs;\t/* Number of pseudo registers.  */\n-  unsigned int num_aregs;\t/* Size of register file.  */\n-  unsigned int num_contexts;\n-\n-  int ar_base;\t\t\t/* Register number for AR0.  */\n-  int a0_base;\t\t\t/* Register number for A0 (pseudo).  */\n-  int wb_regnum;\t\t/* Register number for WB.  */\n-  int ws_regnum;\t\t/* Register number for WS.  */\n-  int pc_regnum;\t\t/* Register number for PC.  */\n-  int ps_regnum;\t\t/* Register number for PS.  */\n-  int lbeg_regnum;\t\t/* Register numbers for count regs.  */\n-  int lend_regnum;\n-  int lcount_regnum;\n-  int sar_regnum;\t\t/* Register number of SAR.  */\n-  int litbase_regnum;\t\t/* Register number of LITBASE.  */\n-  int threadptr_regnum;\t\t/* Register number of THREADPTR.  */\n-\n-  int interrupt_regnum;\t\t/* Register number for interrupt.  */\n-  int interrupt2_regnum;\t/* Register number for interrupt2.  */\n-  int cpenable_regnum;\t\t/* Register number for cpenable.  */\n-  int debugcause_regnum;\t/* Register number for debugcause.  */\n-  int exccause_regnum;\t\t/* Register number for exccause.  */\n-  int excvaddr_regnum;\t\t/* Register number for excvaddr.  */\n-\n-  int max_register_raw_size;\n-  int max_register_virtual_size;\n-  unsigned long *fp_layout;\t/* Layout of custom/TIE regs in 'FP' area.  */\n-  unsigned int fp_layout_bytes;\t/* Size of layout information (in bytes).  */\n-  unsigned long *gregmap;\n+  xtensa_register_t *regmap;\n+\n+  unsigned int num_regs = 0;\t\t/* Number of registers in register map.  */\n+  unsigned int num_nopriv_regs = 0;\t/* Number of non-privileged registers.  */\n+  unsigned int num_pseudo_regs = 0;\t/* Number of pseudo registers.  */\n+  unsigned int num_aregs = XCHAL_NUM_AREGS;\t\t/* Size of register file.  */\n+  unsigned int num_contexts = XCHAL_NUM_CONTEXTS;\n+\n+  int ar_base = -1;\t\t/* Register number for AR0.  */\n+  int a0_base = -1;\t\t/* Register number for A0 (pseudo).  */\n+  int wb_regnum = -1;\t\t/* Register number for WB.  */\n+  int ws_regnum = -1;\t\t/* Register number for WS.  */\n+  int pc_regnum = -1;\t\t/* Register number for PC.  */\n+  int ps_regnum = -1;\t\t/* Register number for PS.  */\n+  int lbeg_regnum = -1;\t\t/* Register numbers for count regs.  */\n+  int lend_regnum = -1;\n+  int lcount_regnum = -1;\n+  int sar_regnum = -1;\t\t/* Register number of SAR.  */\n+  int litbase_regnum = -1;\t/* Register number of LITBASE.  */\n+  int threadptr_regnum = -1;\t/* Register number of THREADPTR.  */\n+\n+  int interrupt_regnum = -1;\t/* Register number for interrupt.  */\n+  int interrupt2_regnum = -1;\t/* Register number for interrupt2.  */\n+  int cpenable_regnum = -1;\t/* Register number for cpenable.  */\n+  int debugcause_regnum = -1;\t/* Register number for debugcause.  */\n+  int exccause_regnum = -1;\t/* Register number for exccause.  */\n+  int excvaddr_regnum = -1;\t/* Register number for excvaddr.  */\n+\n+  int max_register_raw_size = 0;\n+  int max_register_virtual_size = 0;\n+  unsigned long *fp_layout = nullptr;\t/* Layout of custom/TIE regs in 'FP' area.  */\n+  unsigned int fp_layout_bytes = 0;\t/* Size of layout information (in bytes).  */\n+  unsigned long *gregmap = nullptr;\n \n   /* Cached register types.  */\n-  struct ctype_cache *type_entries;\n+  struct ctype_cache *type_entries = nullptr;\n };\n \n-/* Macro to instantiate a gdbarch_tdep structure.  */\n-\n-#define XTENSA_GDBARCH_TDEP_INSTANTIATE(rmap,spillsz)\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    0,\t\t\t\t/* target_flags */\t\t\t\\\n-    (unsigned) -1,\t\t/* spill_location */\t\\\n-    (spillsz),\t\t\t/* spill_size */\t\t\t\\\n-    0,\t\t\t\t/* unused */\t\t\t\t\\\n-    (XSHAL_ABI == XTHAL_ABI_CALL0\t\t\t\t\t\\\n-     ? CallAbiCall0Only\t\t\t\t\t\t\t\\\n-     : CallAbiDefault),\t\t/* call_abi */\t\t\t\t\\\n-    XCHAL_DEBUGLEVEL,\t\t/* debug_interrupt_level */\t\t\\\n-    XCHAL_ICACHE_LINESIZE,\t/* icache_line_bytes */\t\t\t\\\n-    XCHAL_DCACHE_LINESIZE,\t/* dcache_line_bytes */\t\t\t\\\n-    XCHAL_DCACHE_IS_WRITEBACK,  /* dcache_writeback */\t\t\t\\\n-    (XSHAL_ABI != XTHAL_ABI_CALL0),   /* isa_use_windowed_registers */\t\\\n-    XCHAL_HAVE_DENSITY,\t\t /* isa_use_density_instructions */\t\\\n-    XCHAL_HAVE_EXCEPTIONS,\t /* isa_use_exceptions */\t\t\\\n-    XSHAL_USE_ABSOLUTE_LITERALS, /* isa_use_ext_l32r */\t\t\t\\\n-    XCHAL_MAX_INSTRUCTION_SIZE,  /* isa_max_insn_size */\t\t\\\n-    XCHAL_NUM_IBREAK,\t\t /* debug_num_ibreaks */\t\t\\\n-    XCHAL_NUM_DBREAK,\t\t /* debug_num_dbreaks */\t\t\\\n-    rmap,\t\t\t /* regmap */\t\t\t\t\\\n-    0,\t\t\t\t /* num_regs */\t\t\t\t\\\n-    0,\t\t\t\t /* num_nopriv_regs */\t\t\t\\\n-    0,\t\t\t\t /* num_pseudo_regs */\t\t\t\\\n-    XCHAL_NUM_AREGS,\t\t /* num_aregs */\t\t\t\\\n-    XCHAL_NUM_CONTEXTS,\t\t /* num_contexts */\t\t\t\\\n-    -1,\t\t\t\t /* ar_base */\t\t\t\t\\\n-    -1,\t\t\t\t /* a0_base */\t\t\t\t\\\n-    -1,\t\t\t\t /* wb_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* ws_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* pc_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* ps_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* lbeg_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* lend_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* lcount_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* sar_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* litbase_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* interrupt_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* interrupt2_regnum */\t\t\\\n-    -1,\t\t\t\t /* cpenable_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* debugcause_regnum */\t\t\\\n-    -1,\t\t\t\t /* exccause_regnum */\t\t\t\\\n-    -1,\t\t\t\t /* excvaddr_regnum */\t\t\t\\\n-    0,\t\t\t\t /* max_register_raw_size */\t\t\\\n-    0,\t\t\t\t /* max_register_virtual_size */\t\\\n-    0,\t\t\t\t /* fp_layout */\t\t\t\\\n-    0,\t\t\t\t /* fp_layout_bytes */\t\t\t\\\n-    0,\t\t\t\t /* gregmap */\t\t\t\t\\\n-  }\n-#define XTENSA_CONFIG_INSTANTIATE(rmap,spill_size)\t\\\n-\tstruct gdbarch_tdep xtensa_tdep = \\\n-\t  XTENSA_GDBARCH_TDEP_INSTANTIATE(rmap,spill_size);\n-\n-#ifndef XCHAL_NUM_CONTEXTS\n-#define XCHAL_NUM_CONTEXTS\t0\n-#endif\n-#ifndef XCHAL_HAVE_EXCEPTIONS\n-#define XCHAL_HAVE_EXCEPTIONS\t1\n-#endif\n #define WB_SHIFT\t  2\n \n /* We assign fixed numbers to the registers of the \"current\" window "
    },
    {
      "sha": "9d453cd32b9598972ee29671cd0e1eed5cb03b27",
      "filename": "gdb/z80-tdep.c",
      "status": "modified",
      "additions": 15,
      "deletions": 11,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/z80-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/345bd07cce33565f1cd66acabdaf387ca3a7ccb3/gdb/z80-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/z80-tdep.c?ref=345bd07cce33565f1cd66acabdaf387ca3a7ccb3",
      "patch": "@@ -54,19 +54,21 @@\n      next frame - frame of caller, which has called current function\n */\n \n-struct gdbarch_tdep\n+struct z80_gdbarch_tdep : gdbarch_tdep\n {\n   /* Number of bytes used for address:\n       2 bytes for all Z80 family\n       3 bytes for eZ80 CPUs operating in ADL mode */\n-  int addr_length;\n+  int addr_length = 0;\n \n   /* Type for void.  */\n-  struct type *void_type;\n+  struct type *void_type = nullptr;\n+\n   /* Type for a function returning void.  */\n-  struct type *func_void_type;\n+  struct type *func_void_type = nullptr;\n+\n   /* Type for a pointer to a function.  Used for the type of PC.  */\n-  struct type *pc_type;\n+  struct type *pc_type = nullptr;\n };\n \n /* At any time stack frame contains following parts:\n@@ -305,7 +307,8 @@ z80_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n \t\t   struct z80_unwind_cache *info)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  int addr_len = gdbarch_tdep (gdbarch)->addr_length;\n+  z80_gdbarch_tdep *tdep = (z80_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int addr_len = tdep->addr_length;\n   gdb_byte prologue[32]; /* max prologue is 24 bytes: __interrupt with local array */\n   int pos = 0;\n   int len;\n@@ -560,7 +563,8 @@ z80_frame_unwind_cache (struct frame_info *this_frame,\n   gdb_byte buf[sizeof(void*)];\n   struct z80_unwind_cache *info;\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  int addr_len = gdbarch_tdep (gdbarch)->addr_length;\n+  z80_gdbarch_tdep *tdep = (z80_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  int addr_len = tdep->addr_length;\n \n   if (*this_prologue_cache)\n     return (struct z80_unwind_cache *) *this_prologue_cache;\n@@ -692,7 +696,7 @@ z80_frame_prev_register (struct frame_info *this_frame,\n \t  ULONGEST pc;\n \t  gdb_byte buf[3];\n \t  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-\t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\t  z80_gdbarch_tdep *tdep = (z80_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n \t  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n \t  read_memory (info->saved_regs[Z80_PC_REGNUM].addr (),\n@@ -745,11 +749,12 @@ z80_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)\n     }\n   else /* kind is non-RST address, use CALL instead, but it is dungerous */\n     {\n+      z80_gdbarch_tdep *tdep = (z80_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n       gdb_byte *p = break_insn;\n       *p++ = 0xcd;\n       *p++ = (kind >> 0) & 0xff;\n       *p++ = (kind >> 8) & 0xff;\n-      if (gdbarch_tdep (gdbarch)->addr_length > 2)\n+      if (tdep->addr_length > 2)\n \t*p++ = (kind >> 16) & 0xff;\n       *size = p - break_insn;\n     }\n@@ -1077,7 +1082,6 @@ static struct gdbarch *\n z80_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n   struct gdbarch_list *best_arch;\n   tdesc_arch_data_up tdesc_data;\n   unsigned long mach = info.bfd_arch_info->mach;\n@@ -1119,7 +1123,7 @@ z80_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     }\n \n   /* None found, create a new architecture from the information provided.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n+  z80_gdbarch_tdep *tdep = new z80_gdbarch_tdep;\n   gdbarch = gdbarch_alloc (&info, tdep);\n \n   if (mach == bfd_mach_ez80_adl)"
    }
  ]
}