{
  "sha": "a975c88e6549c508ec86658e6816d7b8f16af13c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTk3NWM4OGU2NTQ5YzUwOGVjODY2NThlNjgxNmQ3YjhmMTZhZjEzYw==",
  "commit": {
    "author": {
      "name": "Stephen Casner",
      "email": "casner@acm.org",
      "date": "2020-06-05T01:12:32Z"
    },
    "committer": {
      "name": "Stephen Casner",
      "email": "casner@acm.org",
      "date": "2020-06-05T01:12:32Z"
    },
    "message": "Extend pdp11-aout symbol table format and code for .stab symbols.\n\n* bfd/pdp11.c (pdp11_external_nlist): Repurposed e_unused to e_desc.\n(N_STAB, is_stab): Needed new function is_stab to disambiguate\nnormal vs. .stab symbol table type values, replacing N_STAB mask.\n(translate_from_native_sym_flags): Determine correct section for\ndifferent .stab types.\n(translate_to_native_sym_flags): Leave .stab types intact.\n(translate_symbol_table): Error if symbol indicates overlay;\nstore desc field from .stab symbols.\n(write_syms): Output desc field with symbol.\n(aout_link_check_ar_symbols): Skip .stab symbols.\n(aout_link_add_symbols): Correctly distinguish .stab symbols.\n(aout_link_write_other_symbol): Write 0 for desk and ovly fields.\n(aout_link_write_symbols): Write 0 for desk and ovly fields;\ncorrectly distinguish .stab symbols and select calculate their\nsection and value; and copy desc and ovly fields from input symbol\nto output symbol.",
    "tree": {
      "sha": "a51af3ae7a7c53dde712f009cc8da7c967ca59bc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a51af3ae7a7c53dde712f009cc8da7c967ca59bc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a975c88e6549c508ec86658e6816d7b8f16af13c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a975c88e6549c508ec86658e6816d7b8f16af13c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a975c88e6549c508ec86658e6816d7b8f16af13c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a975c88e6549c508ec86658e6816d7b8f16af13c/comments",
  "author": {
    "login": "slcasner",
    "id": 5100408,
    "node_id": "MDQ6VXNlcjUxMDA0MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5100408?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/slcasner",
    "html_url": "https://github.com/slcasner",
    "followers_url": "https://api.github.com/users/slcasner/followers",
    "following_url": "https://api.github.com/users/slcasner/following{/other_user}",
    "gists_url": "https://api.github.com/users/slcasner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/slcasner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/slcasner/subscriptions",
    "organizations_url": "https://api.github.com/users/slcasner/orgs",
    "repos_url": "https://api.github.com/users/slcasner/repos",
    "events_url": "https://api.github.com/users/slcasner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/slcasner/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "slcasner",
    "id": 5100408,
    "node_id": "MDQ6VXNlcjUxMDA0MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5100408?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/slcasner",
    "html_url": "https://github.com/slcasner",
    "followers_url": "https://api.github.com/users/slcasner/followers",
    "following_url": "https://api.github.com/users/slcasner/following{/other_user}",
    "gists_url": "https://api.github.com/users/slcasner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/slcasner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/slcasner/subscriptions",
    "organizations_url": "https://api.github.com/users/slcasner/orgs",
    "repos_url": "https://api.github.com/users/slcasner/repos",
    "events_url": "https://api.github.com/users/slcasner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/slcasner/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "470e738f6d505ef612c480650a9a7be06c376c46",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/470e738f6d505ef612c480650a9a7be06c376c46",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/470e738f6d505ef612c480650a9a7be06c376c46"
    }
  ],
  "stats": {
    "total": 177,
    "additions": 146,
    "deletions": 31
  },
  "files": [
    {
      "sha": "e99de6dbed89b44fa0da36796c7b47610f2f273d",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a975c88e6549c508ec86658e6816d7b8f16af13c/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a975c88e6549c508ec86658e6816d7b8f16af13c/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=a975c88e6549c508ec86658e6816d7b8f16af13c",
      "patch": "@@ -1,3 +1,25 @@\n+2020-06-04  Stephen Casner  <casner@acm.org>\n+\n+\tExtend pdp11-aout symbol table format to accommodate .stab\n+\tsymbols and implement correct handling of them.\n+\n+\t* pdp11.c (pdp11_external_nlist): Repurposed e_unused to e_desc.\n+\t(N_STAB, is_stab): Needed new function is_stab to disambiguate\n+\tnormal vs. .stab symbol table type values, replacing N_STAB mask.\n+\t(translate_from_native_sym_flags): Determine correct section for\n+\tdifferent .stab types.\n+\t(translate_to_native_sym_flags): Leave .stab types intact.\n+\t(translate_symbol_table): Error if symbol indicates overlay;\n+\tstore desc field from .stab symbols.\n+\t(write_syms): Output desc field with symbol.\n+\t(aout_link_check_ar_symbols): Skip .stab symbols.\n+\t(aout_link_add_symbols): Correctly distinguish .stab symbols.\n+\t(aout_link_write_other_symbol): Write 0 for desk and ovly fields.\n+\t(aout_link_write_symbols): Write 0 for desk and ovly fields;\n+\tcorrectly distinguish .stab symbols and select calculate their\n+\tsection and value; and copy desc and ovly fields from input symbol\n+\tto output symbol.\n+\n 2020-06-04  Stephen Casner  <casner@acm.org>\n \n \t* aoutx.h (translate_symbol_table): Comment had external and"
    },
    {
      "sha": "2eca67c4a7ccca221068abfa37a33e367dac0519",
      "filename": "bfd/pdp11.c",
      "status": "modified",
      "additions": 124,
      "deletions": 31,
      "changes": 155,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a975c88e6549c508ec86658e6816d7b8f16af13c/bfd/pdp11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a975c88e6549c508ec86658e6816d7b8f16af13c/bfd/pdp11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pdp11.c?ref=a975c88e6549c508ec86658e6816d7b8f16af13c",
      "patch": "@@ -22,7 +22,9 @@\n /* BFD backend for PDP-11, running 2.11BSD in particular.\n \n    This file was hacked up by looking hard at the existing vaxnetbsd\n-   back end and the header files in 2.11BSD.\n+   back end and the header files in 2.11BSD.  The symbol table format\n+   of 2.11BSD has been extended to accommodate .stab symbols.  See\n+   struct pdp11_external_nlist below for details.\n \n    TODO\n    * support for V7 file formats\n@@ -101,10 +103,23 @@ struct pdp11_external_exec\n \n #define A_FLAG_RELOC_STRIPPED\t0x0001\n \n+/* The following struct defines the format of an entry in the object file\n+   symbol table.  In the original 2.11BSD struct the index into the string\n+   table is stored as a long, but the PDP11 C convention for storing a long in\n+   memory placed the most significant word first even though the bytes within a\n+   word are stored least significant first.  So here the string table index is\n+   considered to be just 16 bits and the first two bytes of the struct were\n+   previously named e_unused.  To extend the symbol table format to accommodate\n+   .stab symbols, the e_unused bytes are renamed e_desc to store the desc field\n+   of the .stab symbol.  The GDP Project's STABS document says that the \"other\"\n+   field is almost always unused and can be set to zero; the only nonzero cases\n+   identified were for stabs in their own sections, which does not apply for\n+   pdp11 a.out format, and for a special case of GNU Modula2 which is not\n+   supported for the PDP11.  */\n #define external_nlist pdp11_external_nlist\n struct pdp11_external_nlist\n {\n-  bfd_byte e_unused[2];\t\t/* Unused.  */\n+  bfd_byte e_desc[2];\t\t/* The desc field for .stab symbols, else 0.  */\n   bfd_byte e_strx[2];\t\t/* Index into string table of name.  */\n   bfd_byte e_type[1];\t\t/* Type of symbol.  */\n   bfd_byte e_ovly[1];\t\t/* Overlay number.  */\n@@ -151,6 +166,13 @@ static bfd_boolean MY(write_object_contents) (bfd *);\n #include \"aout/stab_gnu.h\"\n #include \"aout/ar.h\"\n \n+/* The symbol type numbers for the 16-bit a.out format from 2.11BSD differ from\n+   those defined in aout64.h so we must redefine them here.  N_EXT changes from\n+   0x01 to 0x20 which creates a conflict with some .stab values, in particular\n+   between undefined externals (N_UNDF+N_EXT) vs. global variables (N_GYSM) and\n+   between external bss symbols (N_BSS+N_EXT) vs. function names (N_FUN).  We\n+   disambiguate those conflicts with a hack in is_stab() to look for the ':' in\n+   the global variable or function name string.  */\n #undef N_TYPE\n #undef N_UNDF\n #undef N_ABS\n@@ -170,7 +192,12 @@ static bfd_boolean MY(write_object_contents) (bfd *);\n #define N_REG\t\t0x14\t/* Register symbol.  */\n #define N_FN\t\t0x1f\t/* File name.  */\n #define N_EXT\t\t0x20\t/* External flag.  */\n-#define N_STAB\t \t0xc0\t/* Not relevant; modified aout64.h's 0xe0 to avoid N_EXT.  */\n+/* Type numbers from .stab entries that could conflict:\n+\tN_GSYM\t\t0x20\t   Global variable [conflict with external undef]\n+\tN_FNAME\t\t0x22\t   Function name (for BSD Fortran) [ignored]\n+\tN_FUN\t\t0x24\t   Function name [conflict with external BSS]\n+\tN_NOMAP\t\t0x34\t   No DST map for sym. [ext. reg. doesn't exist]\n+*/\n \n #define RELOC_SIZE 2\n \n@@ -300,6 +327,19 @@ NAME (aout, reloc_name_lookup) (bfd *abfd ATTRIBUTE_UNUSED,\n   return NULL;\n }\n \n+/* Disambiguate conflicts between normal symbol types and .stab symbol types\n+   (undefined externals N_UNDF+N_EXT vs. global variables N_GYSM and external\n+   bss symbols N_BSS+N_EXT vs. function names N_FUN) with a hack to look for\n+   the ':' in the global variable or function name string.  */\n+\n+static int\n+is_stab (int type, const char *name)\n+{\n+  if (type == N_GSYM || type == N_FUN)\n+    return (index(name, ':') != NULL);\n+  return (type > N_FUN);\n+}\n+\n static int\n pdp11_aout_write_headers (bfd *abfd, struct internal_exec *execp)\n {\n@@ -1325,28 +1365,33 @@ translate_from_native_sym_flags (bfd *abfd,\n {\n   flagword visible;\n \n-  if (cache_ptr->type == N_FN)\n+  if (is_stab (cache_ptr->type, cache_ptr->symbol.name))\n     {\n       asection *sec;\n \n       /* This is a debugging symbol.  */\n       cache_ptr->symbol.flags = BSF_DEBUGGING;\n \n       /* Work out the symbol section.  */\n-      switch (cache_ptr->type & N_TYPE)\n+      switch (cache_ptr->type)\n \t{\n-\tcase N_TEXT:\n+\tcase N_SO:\n+\tcase N_SOL:\n+\tcase N_FUN:\n+\tcase N_ENTRY:\n+\tcase N_SLINE:\n \tcase N_FN:\n \t  sec = obj_textsec (abfd);\n \t  break;\n-\tcase N_DATA:\n+\tcase N_STSYM:\n+\tcase N_DSLINE:\n \t  sec = obj_datasec (abfd);\n \t  break;\n-\tcase N_BSS:\n+\tcase N_LCSYM:\n+\tcase N_BSLINE:\n \t  sec = obj_bsssec (abfd);\n \t  break;\n \tdefault:\n-\tcase N_ABS:\n \t  sec = bfd_abs_section_ptr;\n \t  break;\n \t}\n@@ -1418,10 +1463,12 @@ translate_to_native_sym_flags (bfd *abfd,\n   bfd_vma value = cache_ptr->value;\n   asection *sec;\n   bfd_vma off;\n+  const char *name = cache_ptr->name != NULL ? cache_ptr->name : \"*unknown*\";\n \n   /* Mask out any existing type bits in case copying from one section\n      to another.  */\n-  sym_pointer->e_type[0] &= ~N_TYPE;\n+  if (!is_stab (sym_pointer->e_type[0], name))\n+    sym_pointer->e_type[0] &= ~N_TYPE;\n \n   sec = bfd_asymbol_section (cache_ptr);\n   off = 0;\n@@ -1433,7 +1480,7 @@ translate_to_native_sym_flags (bfd *abfd,\n       _bfd_error_handler\n \t/* xgettext:c-format */\n \t(_(\"%pB: can not represent section for symbol `%s' in a.out object file format\"),\n-\t abfd, cache_ptr->name != NULL ? cache_ptr->name : \"*unknown*\");\n+\t abfd, name);\n       bfd_set_error (bfd_error_nonrepresentable_section);\n       return FALSE;\n     }\n@@ -1511,6 +1558,7 @@ NAME (aout, translate_symbol_table) (bfd *abfd,\n   for (; ext < ext_end; ext++, in++)\n     {\n       bfd_vma x;\n+      int ovly;\n \n       x = GET_WORD (abfd, ext->e_strx);\n       in->symbol.the_bfd = abfd;\n@@ -1533,9 +1581,19 @@ NAME (aout, translate_symbol_table) (bfd *abfd,\n \t  return FALSE;\n \t}\n \n+      ovly = H_GET_8 (abfd, ext->e_ovly);\n+      if (ovly != 0)\n+\t{\n+\t  _bfd_error_handler\n+\t    (_(\"%pB: symbol indicates overlay (not supported)\"), abfd);\n+\t  bfd_set_error (bfd_error_bad_value);\n+\t  return FALSE;\n+\t}\n+\n       in->symbol.value = GET_WORD (abfd,  ext->e_value);\n-      /* TODO: is 0 a safe value here?  */\n-      in->desc = 0;\n+      /* e_desc is zero for normal symbols but for .stab symbols it\n+\t carries the desc field in our extended 2.11BSD format. */\n+      in->desc = H_GET_16 (abfd, ext->e_desc);\n       in->other = 0;\n       in->type = H_GET_8 (abfd,  ext->e_type);\n       in->symbol.udata.p = NULL;\n@@ -1686,23 +1744,27 @@ NAME (aout, write_syms) (bfd *abfd)\n       bfd_size_type indx;\n       struct external_nlist nsp;\n \n-      PUT_WORD (abfd, 0, nsp.e_unused);\n-\n       indx = add_to_stringtab (abfd, strtab, g->name, FALSE);\n       if (indx == (bfd_size_type) -1)\n \tgoto error_return;\n       PUT_WORD (abfd, indx, nsp.e_strx);\n \n       if (bfd_asymbol_flavour(g) == abfd->xvec->flavour)\n-\tH_PUT_8 (abfd, aout_symbol(g)->type,  nsp.e_type);\n+\t{\n+\t  H_PUT_16 (abfd, aout_symbol (g)->desc,  nsp.e_desc);\n+\t  H_PUT_8 (abfd, 0, nsp.e_ovly);\n+\t  H_PUT_8 (abfd, aout_symbol (g)->type,  nsp.e_type);\n+\t}\n       else\n-\tH_PUT_8 (abfd, 0, nsp.e_type);\n+\t{\n+\t  H_PUT_16 (abfd, 0, nsp.e_desc);\n+\t  H_PUT_8 (abfd, 0, nsp.e_ovly);\n+\t  H_PUT_8 (abfd, 0, nsp.e_type);\n+\t}\n \n       if (! translate_to_native_sym_flags (abfd, g, &nsp))\n \tgoto error_return;\n \n-      H_PUT_8 (abfd, 0, nsp.e_ovly);\n-\n       if (bfd_bwrite ((void *)&nsp, (bfd_size_type) EXTERNAL_NLIST_SIZE, abfd)\n \t  != EXTERNAL_NLIST_SIZE)\n \tgoto error_return;\n@@ -2643,17 +2705,17 @@ aout_link_check_ar_symbols (bfd *abfd,\n   for (; p < pend; p++)\n     {\n       int type = H_GET_8 (abfd, p->e_type);\n-      const char *name;\n+      const char *name = strings + GET_WORD (abfd, p->e_strx);\n       struct bfd_link_hash_entry *h;\n \n       /* Ignore symbols that are not externally visible.  This is an\n \t optimization only, as we check the type more thoroughly\n \t below.  */\n       if ((type & N_EXT) == 0\n+\t  || is_stab(type, name)\n \t  || type == N_FN)\n \tcontinue;\n \n-      name = strings + GET_WORD (abfd, p->e_strx);\n       h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);\n \n       /* We are only interested in symbols that are currently\n@@ -2863,6 +2925,10 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \n       type = H_GET_8 (abfd, p->e_type);\n \n+      /* Ignore debugging symbols.  */\n+      if (is_stab(type, name))\n+\tcontinue;\n+\n       /* PR 19629: Corrupt binaries can contain illegal string offsets.  */\n       if (GET_WORD (abfd, p->e_strx) >= obj_aout_external_string_size (abfd))\n \treturn FALSE;\n@@ -2873,8 +2939,8 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n       switch (type)\n \t{\n \tdefault:\n-\t  /* Anything else should be a debugging symbol.  */\n-\t  BFD_ASSERT ((type & N_STAB) != 0);\n+\t  /* Shouldn't be any types not covered.  */\n+\t  BFD_ASSERT (0);\n \t  continue;\n \n \tcase N_UNDF:\n@@ -3077,12 +3143,14 @@ aout_link_write_other_symbol (struct bfd_hash_entry *bh, void *data)\n     }\n \n   H_PUT_8 (output_bfd, type, outsym.e_type);\n+  H_PUT_8 (output_bfd, 0, outsym.e_ovly);\n   indx = add_to_stringtab (output_bfd, flaginfo->strtab, h->root.root.string,\n \t\t\t   FALSE);\n   if (indx == (bfd_size_type) -1)\n     /* FIXME: No way to handle errors.  */\n     abort ();\n \n+  PUT_WORD (output_bfd, 0, outsym.e_desc);\n   PUT_WORD (output_bfd, indx, outsym.e_strx);\n   PUT_WORD (output_bfd, val, outsym.e_value);\n \n@@ -4097,6 +4165,8 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n       && discard != discard_all)\n     {\n       H_PUT_8 (output_bfd, N_TEXT, outsym->e_type);\n+      H_PUT_8 (output_bfd, 0, outsym->e_ovly);\n+      H_PUT_16 (output_bfd, 0, outsym->e_desc);\n       strtab_index = add_to_stringtab (output_bfd, flaginfo->strtab,\n \t\t\t\t       bfd_get_filename (input_bfd), FALSE);\n       if (strtab_index == (bfd_size_type) -1)\n@@ -4210,7 +4280,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t    case strip_none:\n \t      break;\n \t    case strip_debugger:\n-\t      if ((type & N_STAB) != 0)\n+\t      if (is_stab (type, name))\n \t\tskip = TRUE;\n \t      break;\n \t    case strip_some:\n@@ -4230,7 +4300,33 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t    }\n \n \t  /* Get the value of the symbol.  */\n-\t  if ((type & N_TYPE) == N_TEXT\n+\t  if (is_stab (type, name))\n+\t    {\n+\t      switch (type)\n+\t\t{\n+\t\tdefault:\n+\t\t  symsec = bfd_abs_section_ptr;\n+\t\t  break;\n+\t\tcase N_SO:\n+\t\tcase N_SOL:\n+\t\tcase N_FUN:\n+\t\tcase N_ENTRY:\n+\t\tcase N_SLINE:\n+\t\tcase N_FN:\n+\t\t  symsec = obj_textsec (input_bfd);\n+\t\t  break;\n+\t\tcase N_STSYM:\n+\t\tcase N_DSLINE:\n+\t\t  symsec = obj_datasec (input_bfd);\n+\t\t  break;\n+\t\tcase N_LCSYM:\n+\t\tcase N_BSLINE:\n+\t\t  symsec = obj_bsssec (input_bfd);\n+\t\t  break;\n+\t\t}\n+\t      val = GET_WORD (input_bfd, sym->e_value);\n+\t    }\n+\t  else if ((type & N_TYPE) == N_TEXT\n \t      || type == N_WEAKT)\n \t    symsec = obj_textsec (input_bfd);\n \t  else if ((type & N_TYPE) == N_DATA\n@@ -4258,11 +4354,6 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t      val = GET_WORD (input_bfd, sym->e_value);\n \t      symsec = NULL;\n \t    }\n-\t  else if ((type & N_STAB) != 0)\n-\t    {\n-\t      val = GET_WORD (input_bfd, sym->e_value);\n-\t      symsec = NULL;\n-\t    }\n \t  else\n \t    {\n \t      /* If we get here with an indirect symbol, it means that\n@@ -4376,7 +4467,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\tcase discard_sec_merge:\n \t\t  break;\n \t\tcase discard_l:\n-\t\t  if ((type & N_STAB) == 0\n+\t\t  if (!is_stab (type, name)\n \t\t      && bfd_is_local_label_name (input_bfd, name))\n \t\t    skip = TRUE;\n \t\t  break;\n@@ -4500,6 +4591,8 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n       /* Copy this symbol into the list of symbols we are going to\n \t write out.  */\n       H_PUT_8 (output_bfd, type, outsym->e_type);\n+      H_PUT_8 (output_bfd, H_GET_8 (input_bfd, sym->e_ovly), outsym->e_ovly);\n+      H_PUT_16 (output_bfd, H_GET_16 (input_bfd, sym->e_desc), outsym->e_desc);\n       copy = FALSE;\n       if (! flaginfo->info->keep_memory)\n \t{"
    }
  ]
}