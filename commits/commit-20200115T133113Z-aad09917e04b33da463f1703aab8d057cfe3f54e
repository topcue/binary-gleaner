{
  "sha": "aad09917e04b33da463f1703aab8d057cfe3f54e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWFkMDk5MTdlMDRiMzNkYTQ2M2YxNzAzYWFiOGQwNTdjZmUzZjU0ZQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-15T05:37:16Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-15T13:31:13Z"
    },
    "message": "tic4x disassembly static variables\n\ntic4x uses a number of static variables for tables that are generated\ndepending on the current machine (tic4x vs. tic3x).  However, it is\npossible to change the machine from one invocation of print_insn_tic4x\nto the next.  This patch throws away the old state if that happens,\nand uses a relatively small known size array of register names rather\nthan a malloc'd table.\n\n\t* tic4x-dis.c (tic4x_version): Make unsigned long.\n\t(optab, optab_special, registernames): New file scope vars.\n\t(tic4x_print_register): Set up registernames rather than\n\tmalloc'd registertable.\n\t(tic4x_disassemble): Delete optable and optable_special.  Use\n\toptab and optab_special instead.  Throw away old optab,\n\toptab_special and registernames when info->mach changes.",
    "tree": {
      "sha": "dcf1d4382c6f91f58bb66771a768baa7489763ce",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/dcf1d4382c6f91f58bb66771a768baa7489763ce"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/aad09917e04b33da463f1703aab8d057cfe3f54e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aad09917e04b33da463f1703aab8d057cfe3f54e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/aad09917e04b33da463f1703aab8d057cfe3f54e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aad09917e04b33da463f1703aab8d057cfe3f54e/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "131cb553d6d10412b20cf49bb0e3a5e736a90a36",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/131cb553d6d10412b20cf49bb0e3a5e736a90a36",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/131cb553d6d10412b20cf49bb0e3a5e736a90a36"
    }
  ],
  "stats": {
    "total": 85,
    "additions": 54,
    "deletions": 31
  },
  "files": [
    {
      "sha": "e7e963397adb1a8324a9120cc42dabc61b12c826",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aad09917e04b33da463f1703aab8d057cfe3f54e/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aad09917e04b33da463f1703aab8d057cfe3f54e/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=aad09917e04b33da463f1703aab8d057cfe3f54e",
      "patch": "@@ -1,3 +1,13 @@\n+2020-01-15  Alan Modra  <amodra@gmail.com>\n+\n+\t* tic4x-dis.c (tic4x_version): Make unsigned long.\n+\t(optab, optab_special, registernames): New file scope vars.\n+\t(tic4x_print_register): Set up registernames rather than\n+\tmalloc'd registertable.\n+\t(tic4x_disassemble): Delete optable and optable_special.  Use\n+\toptab and optab_special instead.  Throw away old optab,\n+\toptab_special and registernames when info->mach changes.\n+\n 2020-01-14  Sergey Belyashov  <sergey.belyashov@gmail.com>\n \n \tPR 25377"
    },
    {
      "sha": "33d75c878b8cf5fd75e22899b480259becf8d36d",
      "filename": "opcodes/tic4x-dis.c",
      "status": "modified",
      "additions": 44,
      "deletions": 31,
      "changes": 75,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aad09917e04b33da463f1703aab8d057cfe3f54e/opcodes/tic4x-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aad09917e04b33da463f1703aab8d057cfe3f54e/opcodes/tic4x-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/tic4x-dis.c?ref=aad09917e04b33da463f1703aab8d057cfe3f54e",
      "patch": "@@ -51,8 +51,11 @@ typedef enum\n }\n indirect_t;\n \n-static int tic4x_version = 0;\n+static unsigned long tic4x_version = 0;\n static int tic4x_dp = 0;\n+static tic4x_inst_t **optab = NULL;\n+static tic4x_inst_t **optab_special = NULL;\n+static const char *registernames[REG_TABLE_SIZE];\n \n static int\n tic4x_pc_offset (unsigned int op)\n@@ -130,28 +133,24 @@ tic4x_print_str (struct disassemble_info *info, const char *str)\n static int\n tic4x_print_register (struct disassemble_info *info, unsigned long regno)\n {\n-  static tic4x_register_t ** registertable = NULL;\n   unsigned int i;\n \n-  if (registertable == NULL)\n+  if (registernames[REG_R0] == NULL)\n     {\n-      registertable = xmalloc (sizeof (tic4x_register_t *) * REG_TABLE_SIZE);\n       for (i = 0; i < tic3x_num_registers; i++)\n-\tregistertable[tic3x_registers[i].regno]\n-\t  = (tic4x_register_t *) (tic3x_registers + i);\n+\tregisternames[tic3x_registers[i].regno] = tic3x_registers[i].name;\n       if (IS_CPU_TIC4X (tic4x_version))\n \t{\n \t  /* Add C4x additional registers, overwriting\n \t     any C3x registers if necessary.  */\n \t  for (i = 0; i < tic4x_num_registers; i++)\n-\t    registertable[tic4x_registers[i].regno]\n-\t      = (tic4x_register_t *)(tic4x_registers + i);\n+\t    registernames[tic4x_registers[i].regno] = tic4x_registers[i].name;\n \t}\n     }\n   if (regno > (IS_CPU_TIC4X (tic4x_version) ? TIC4X_REG_MAX : TIC3X_REG_MAX))\n     return 0;\n   if (info != NULL)\n-    (*info->fprintf_func) (info->stream, \"%s\", registertable[regno]->name);\n+    (*info->fprintf_func) (info->stream, \"%s\", registernames[regno]);\n   return 1;\n }\n \n@@ -687,61 +686,75 @@ tic4x_disassemble (unsigned long pc,\n \t\t   unsigned long instruction,\n \t\t   struct disassemble_info *info)\n {\n-  static tic4x_inst_t **optable = NULL;\n-  static tic4x_inst_t **optable_special = NULL;\n   tic4x_inst_t *p;\n   int i;\n   unsigned long tic4x_oplevel;\n \n-  tic4x_version = info->mach;\n+  if (tic4x_version != info->mach)\n+    {\n+      tic4x_version = info->mach;\n+      /* Don't stash anything from a previous call using a different\n+\t machine.  */\n+      if (optab)\n+\t{\n+\t  free (optab);\n+\t  optab = NULL;\n+\t}\n+      if (optab_special)\n+\t{\n+\t  free (optab_special);\n+\t  optab_special = NULL;\n+\t}\n+      registernames[REG_R0] = NULL;\n+    }\n \n   tic4x_oplevel  = (IS_CPU_TIC4X (tic4x_version)) ? OP_C4X : 0;\n   tic4x_oplevel |= OP_C3X | OP_LPWR | OP_IDLE2 | OP_ENH;\n \n-  if (optable == NULL)\n+  if (optab == NULL)\n     {\n-      optable = xcalloc (sizeof (tic4x_inst_t *), (1 << TIC4X_HASH_SIZE));\n+      optab = xcalloc (sizeof (tic4x_inst_t *), (1 << TIC4X_HASH_SIZE));\n \n-      optable_special = xcalloc (sizeof (tic4x_inst_t *), TIC4X_SPESOP_SIZE);\n+      optab_special = xcalloc (sizeof (tic4x_inst_t *), TIC4X_SPESOP_SIZE);\n \n       /* Install opcodes in reverse order so that preferred\n \t forms overwrite synonyms.  */\n       for (i = tic4x_num_insts - 1; i >= 0; i--)\n-        tic4x_hash_opcode (optable, optable_special, &tic4x_insts[i],\n+\ttic4x_hash_opcode (optab, optab_special, &tic4x_insts[i],\n \t\t\t   tic4x_oplevel);\n \n       /* We now need to remove the insn that are special from the\n-         \"normal\" optable, to make the disasm search this extra list\n-         for them.  */\n+\t \"normal\" optable, to make the disasm search this extra list\n+\t for them.  */\n       for (i = 0; i < TIC4X_SPESOP_SIZE; i++)\n-        if (optable_special[i] != NULL)\n-          optable[optable_special[i]->opcode >> (32 - TIC4X_HASH_SIZE)] = NULL;\n+\tif (optab_special[i] != NULL)\n+\t  optab[optab_special[i]->opcode >> (32 - TIC4X_HASH_SIZE)] = NULL;\n     }\n \n   /* See if we can pick up any loading of the DP register...  */\n   if ((instruction >> 16) == 0x5070 || (instruction >> 16) == 0x1f70)\n     tic4x_dp = EXTRU (instruction, 15, 0);\n \n-  p = optable[instruction >> (32 - TIC4X_HASH_SIZE)];\n+  p = optab[instruction >> (32 - TIC4X_HASH_SIZE)];\n   if (p != NULL)\n     {\n       if (((instruction & p->opmask) == p->opcode)\n-           && tic4x_print_op (NULL, instruction, p, pc))\n-        tic4x_print_op (info, instruction, p, pc);\n+\t  && tic4x_print_op (NULL, instruction, p, pc))\n+\ttic4x_print_op (info, instruction, p, pc);\n       else\n-        (*info->fprintf_func) (info->stream, \"%08lx\", instruction);\n+\t(*info->fprintf_func) (info->stream, \"%08lx\", instruction);\n     }\n   else\n     {\n       for (i = 0; i<TIC4X_SPESOP_SIZE; i++)\n-        if (optable_special[i] != NULL\n-            && optable_special[i]->opcode == instruction)\n-          {\n-            (*info->fprintf_func)(info->stream, \"%s\", optable_special[i]->name);\n-            break;\n-          }\n+\tif (optab_special[i] != NULL\n+\t    && optab_special[i]->opcode == instruction)\n+\t  {\n+\t    (*info->fprintf_func)(info->stream, \"%s\", optab_special[i]->name);\n+\t    break;\n+\t  }\n       if (i == TIC4X_SPESOP_SIZE)\n-        (*info->fprintf_func) (info->stream, \"%08lx\", instruction);\n+\t(*info->fprintf_func) (info->stream, \"%08lx\", instruction);\n     }\n \n   /* Return size of insn in words.  */"
    }
  ]
}