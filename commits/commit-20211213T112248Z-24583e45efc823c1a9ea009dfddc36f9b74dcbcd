{
  "sha": "24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
  "node_id": "C_kwDOANOeidoAKDI0NTgzZTQ1ZWZjODIzYzFhOWVhMDA5ZGZkZGMzNmY5Yjc0ZGNiY2Q",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2021-12-13T11:22:48Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2021-12-13T11:22:48Z"
    },
    "message": "gdbserver: replace direct assignments to current_thread\n\nReplace the direct assignments to current_thread with\nswitch_to_thread.  Use scoped_restore_current_thread when appropriate.\nThere is one instance remaining in linux-low.cc's wait_for_sigstop.\nThis will be handled in a separate patch.\n\nRegression-tested on X86-64 Linux using the native-gdbserver and\nnative-extended-gdbserver board files.",
    "tree": {
      "sha": "ac00cde441192c880eee0f36a7e4346e0ba53c58",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ac00cde441192c880eee0f36a7e4346e0ba53c58"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f24791b72e764ada576901c0e866bf7768773a16",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f24791b72e764ada576901c0e866bf7768773a16",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f24791b72e764ada576901c0e866bf7768773a16"
    }
  ],
  "stats": {
    "total": 213,
    "additions": 77,
    "deletions": 136
  },
  "files": [
    {
      "sha": "b6cf10096afc8e59dc0651f0bbb6ed08257264a5",
      "filename": "gdbserver/inferiors.cc",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/inferiors.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/inferiors.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/inferiors.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -41,7 +41,7 @@ add_thread (ptid_t thread_id, void *target_data)\n   all_threads.push_back (new_thread);\n \n   if (current_thread == NULL)\n-    current_thread = new_thread;\n+    switch_to_thread (new_thread);\n \n   return new_thread;\n }\n@@ -99,7 +99,7 @@ remove_thread (struct thread_info *thread)\n   discard_queued_stop_replies (ptid_of (thread));\n   all_threads.remove (thread);\n   if (current_thread == thread)\n-    current_thread = NULL;\n+    switch_to_thread (nullptr);\n   free_one_thread (thread);\n }\n \n@@ -129,7 +129,7 @@ clear_inferiors (void)\n \n   clear_dlls ();\n \n-  current_thread = NULL;\n+  switch_to_thread (nullptr);\n }\n \n struct process_info *\n@@ -215,7 +215,7 @@ void\n switch_to_thread (process_stratum_target *ops, ptid_t ptid)\n {\n   gdb_assert (ptid != minus_one_ptid);\n-  current_thread = find_thread_ptid (ptid);\n+  switch_to_thread (find_thread_ptid (ptid));\n }\n \n /* See gdbthread.h.  */\n@@ -233,7 +233,7 @@ switch_to_process (process_info *proc)\n {\n   int pid = pid_of (proc);\n \n-  current_thread = find_any_thread_of_pid (pid);\n+  switch_to_thread (find_any_thread_of_pid (pid));\n }\n \n /* See gdbsupport/common-inferior.h.  */"
    },
    {
      "sha": "373bacbb74d84b934e7da948202c6189b809f344",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 39,
      "deletions": 74,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -430,14 +430,10 @@ linux_process_target::low_new_fork (process_info *parent, process_info *child)\n void\n linux_process_target::arch_setup_thread (thread_info *thread)\n {\n-  struct thread_info *saved_thread;\n-\n-  saved_thread = current_thread;\n-  current_thread = thread;\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (thread);\n \n   low_arch_setup ();\n-\n-  current_thread = saved_thread;\n }\n \n int\n@@ -672,7 +668,7 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n \n       /* Delete the execing process and all its threads.  */\n       mourn (proc);\n-      current_thread = NULL;\n+      switch_to_thread (nullptr);\n \n       /* Create a new process/lwp/thread.  */\n       proc = add_linux_process (event_pid, 0);\n@@ -712,42 +708,37 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n CORE_ADDR\n linux_process_target::get_pc (lwp_info *lwp)\n {\n-  struct thread_info *saved_thread;\n   struct regcache *regcache;\n   CORE_ADDR pc;\n \n   if (!low_supports_breakpoints ())\n     return 0;\n \n-  saved_thread = current_thread;\n-  current_thread = get_lwp_thread (lwp);\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (get_lwp_thread (lwp));\n \n   regcache = get_thread_regcache (current_thread, 1);\n   pc = low_get_pc (regcache);\n \n   if (debug_threads)\n     debug_printf (\"pc is 0x%lx\\n\", (long) pc);\n \n-  current_thread = saved_thread;\n   return pc;\n }\n \n void\n linux_process_target::get_syscall_trapinfo (lwp_info *lwp, int *sysno)\n {\n-  struct thread_info *saved_thread;\n   struct regcache *regcache;\n \n-  saved_thread = current_thread;\n-  current_thread = get_lwp_thread (lwp);\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (get_lwp_thread (lwp));\n \n   regcache = get_thread_regcache (current_thread, 1);\n   low_get_syscall_trapinfo (regcache, sysno);\n \n   if (debug_threads)\n     debug_printf (\"get_syscall_trapinfo sysno %d\\n\", *sysno);\n-\n-  current_thread = saved_thread;\n }\n \n void\n@@ -762,7 +753,6 @@ linux_process_target::save_stop_reason (lwp_info *lwp)\n {\n   CORE_ADDR pc;\n   CORE_ADDR sw_breakpoint_pc;\n-  struct thread_info *saved_thread;\n #if USE_SIGTRAP_SIGINFO\n   siginfo_t siginfo;\n #endif\n@@ -774,8 +764,8 @@ linux_process_target::save_stop_reason (lwp_info *lwp)\n   sw_breakpoint_pc = pc - low_decr_pc_after_break ();\n \n   /* breakpoint_at reads from the current thread.  */\n-  saved_thread = current_thread;\n-  current_thread = get_lwp_thread (lwp);\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (get_lwp_thread (lwp));\n \n #if USE_SIGTRAP_SIGINFO\n   if (ptrace (PTRACE_GETSIGINFO, lwpid_of (current_thread),\n@@ -888,7 +878,6 @@ linux_process_target::save_stop_reason (lwp_info *lwp)\n     }\n \n   lwp->stop_pc = pc;\n-  current_thread = saved_thread;\n   return true;\n }\n \n@@ -1644,16 +1633,15 @@ linux_process_target::thread_still_has_status_pending (thread_info *thread)\n       && (lp->stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT\n \t  || lp->stop_reason == TARGET_STOPPED_BY_HW_BREAKPOINT))\n     {\n-      struct thread_info *saved_thread;\n       CORE_ADDR pc;\n       int discard = 0;\n \n       gdb_assert (lp->last_status != 0);\n \n       pc = get_pc (lp);\n \n-      saved_thread = current_thread;\n-      current_thread = thread;\n+      scoped_restore_current_thread restore_thread;\n+      switch_to_thread (thread);\n \n       if (pc != lp->stop_pc)\n \t{\n@@ -1682,8 +1670,6 @@ linux_process_target::thread_still_has_status_pending (thread_info *thread)\n \t}\n #endif\n \n-      current_thread = saved_thread;\n-\n       if (discard)\n \t{\n \t  if (debug_threads)\n@@ -1971,10 +1957,8 @@ linux_process_target::low_get_thread_area (int lwpid, CORE_ADDR *addrp)\n bool\n linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n {\n-  struct thread_info *saved_thread;\n-\n-  saved_thread = current_thread;\n-  current_thread = get_lwp_thread (lwp);\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (get_lwp_thread (lwp));\n \n   if ((wstat == NULL\n        || (WIFSTOPPED (*wstat) && WSTOPSIG (*wstat) != SIGTRAP))\n@@ -2015,7 +1999,6 @@ linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n \t\tdebug_printf (\"Checking whether LWP %ld needs to move out of \"\n \t\t\t      \"the jump pad...it does\\n\",\n \t\t\t      lwpid_of (current_thread));\n-\t      current_thread = saved_thread;\n \n \t      return true;\n \t    }\n@@ -2088,7 +2071,6 @@ linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n \t\t  \"jump pad...no\\n\",\n \t\t  lwpid_of (current_thread));\n \n-  current_thread = saved_thread;\n   return false;\n }\n \n@@ -2179,17 +2161,15 @@ dequeue_one_deferred_signal (struct lwp_info *lwp, int *wstat)\n bool\n linux_process_target::check_stopped_by_watchpoint (lwp_info *child)\n {\n-  struct thread_info *saved_thread = current_thread;\n-  current_thread = get_lwp_thread (child);\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (get_lwp_thread (child));\n \n   if (low_stopped_by_watchpoint ())\n     {\n       child->stop_reason = TARGET_STOPPED_BY_WATCHPOINT;\n       child->stopped_data_address = low_stopped_data_address ();\n     }\n \n-  current_thread = saved_thread;\n-\n   return child->stop_reason == TARGET_STOPPED_BY_WATCHPOINT;\n }\n \n@@ -2269,7 +2249,7 @@ linux_process_target::filter_event (int lwpid, int wstat)\n       child_ptid = ptid_t (lwpid, lwpid);\n       child = add_lwp (child_ptid);\n       child->stopped = 1;\n-      current_thread = child->thread;\n+      switch_to_thread (child->thread);\n     }\n \n   /* If we didn't find a process, one of two things presumably happened:\n@@ -2548,7 +2528,7 @@ linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n       *wstatp = event_child->status_pending;\n       event_child->status_pending_p = 0;\n       event_child->status_pending = 0;\n-      current_thread = event_thread;\n+      switch_to_thread (event_thread);\n       return lwpid_of (event_thread);\n     }\n \n@@ -2676,7 +2656,7 @@ linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n \n   gdb_sigmask (SIG_SETMASK, &prev_mask, NULL);\n \n-  current_thread = event_thread;\n+  switch_to_thread (event_thread);\n \n   return lwpid_of (event_thread);\n }\n@@ -2807,7 +2787,7 @@ linux_process_target::stabilize_threads ()\n       return;\n     }\n \n-  thread_info *saved_thread = current_thread;\n+  scoped_restore_current_thread restore_thread;\n \n   stabilizing_threads = 1;\n \n@@ -2849,8 +2829,6 @@ linux_process_target::stabilize_threads ()\n \n   stabilizing_threads = 0;\n \n-  current_thread = saved_thread;\n-\n   if (debug_threads)\n     {\n       thread_stuck = find_thread ([this] (thread_info *thread)\n@@ -3560,7 +3538,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t  select_event_lwp (&event_child);\n \n \t  /* current_thread and event_child must stay in sync.  */\n-\t  current_thread = get_lwp_thread (event_child);\n+\t  switch_to_thread (get_lwp_thread (event_child));\n \n \t  event_child->status_pending_p = 0;\n \t  w = event_child->status_pending;\n@@ -3897,7 +3875,6 @@ linux_process_target::stuck_in_jump_pad (thread_info *thread)\n void\n linux_process_target::move_out_of_jump_pad (thread_info *thread)\n {\n-  struct thread_info *saved_thread;\n   struct lwp_info *lwp = get_thread_lwp (thread);\n   int *wstat;\n \n@@ -3910,8 +3887,8 @@ linux_process_target::move_out_of_jump_pad (thread_info *thread)\n   gdb_assert (lwp->stopped);\n \n   /* For gdb_breakpoint_here.  */\n-  saved_thread = current_thread;\n-  current_thread = thread;\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (thread);\n \n   wstat = lwp->status_pending_p ? &lwp->status_pending : NULL;\n \n@@ -3940,8 +3917,6 @@ linux_process_target::move_out_of_jump_pad (thread_info *thread)\n     }\n   else\n     lwp_suspended_inc (lwp);\n-\n-  current_thread = saved_thread;\n }\n \n static bool\n@@ -4017,9 +3992,9 @@ linux_process_target::install_software_single_step_breakpoints (lwp_info *lwp)\n   struct thread_info *thread = get_lwp_thread (lwp);\n   struct regcache *regcache = get_thread_regcache (thread, 1);\n \n-  scoped_restore save_current_thread = make_scoped_restore (&current_thread);\n+  scoped_restore_current_thread restore_thread;\n \n-  current_thread = thread;\n+  switch_to_thread (thread);\n   std::vector<CORE_ADDR> next_pcs = low_get_next_pcs (regcache);\n \n   for (CORE_ADDR pc : next_pcs)\n@@ -4067,7 +4042,6 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n \t\t\t\t\t    int signal, siginfo_t *info)\n {\n   struct thread_info *thread = get_lwp_thread (lwp);\n-  struct thread_info *saved_thread;\n   int ptrace_request;\n   struct process_info *proc = get_thread_process (thread);\n \n@@ -4123,8 +4097,8 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n       return;\n     }\n \n-  saved_thread = current_thread;\n-  current_thread = thread;\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (thread);\n \n   /* This bit needs some thinking about.  If we get a signal that\n      we must report while a single-step reinsert is still pending,\n@@ -4248,7 +4222,6 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n \t     of coercing an 8 byte integer to a 4 byte pointer.  */\n \t  (PTRACE_TYPE_ARG4) (uintptr_t) signal);\n \n-  current_thread = saved_thread;\n   if (errno)\n     perror_with_name (\"resuming thread\");\n \n@@ -4445,7 +4418,6 @@ bool\n linux_process_target::thread_needs_step_over (thread_info *thread)\n {\n   struct lwp_info *lwp = get_thread_lwp (thread);\n-  struct thread_info *saved_thread;\n   CORE_ADDR pc;\n   struct process_info *proc = get_thread_process (thread);\n \n@@ -4526,8 +4498,8 @@ linux_process_target::thread_needs_step_over (thread_info *thread)\n       return false;\n     }\n \n-  saved_thread = current_thread;\n-  current_thread = thread;\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (thread);\n \n   /* We can only step over breakpoints we know about.  */\n   if (breakpoint_here (pc) || fast_tracepoint_jump_here (pc))\n@@ -4544,7 +4516,6 @@ linux_process_target::thread_needs_step_over (thread_info *thread)\n \t\t\t  \" GDB breakpoint at 0x%s; skipping step over\\n\",\n \t\t\t  lwpid_of (thread), paddress (pc));\n \n-\t  current_thread = saved_thread;\n \t  return false;\n \t}\n       else\n@@ -4556,14 +4527,10 @@ linux_process_target::thread_needs_step_over (thread_info *thread)\n \n \t  /* We've found an lwp that needs stepping over --- return 1 so\n \t     that find_thread stops looking.  */\n-\t  current_thread = saved_thread;\n-\n \t  return true;\n \t}\n     }\n \n-  current_thread = saved_thread;\n-\n   if (debug_threads)\n     debug_printf (\"Need step over [LWP %ld]? No, no breakpoint found\"\n \t\t  \" at 0x%s\\n\",\n@@ -4576,9 +4543,7 @@ void\n linux_process_target::start_step_over (lwp_info *lwp)\n {\n   struct thread_info *thread = get_lwp_thread (lwp);\n-  struct thread_info *saved_thread;\n   CORE_ADDR pc;\n-  int step;\n \n   if (debug_threads)\n     debug_printf (\"Starting step-over on LWP %ld.  Stopping all threads\\n\",\n@@ -4602,16 +4567,17 @@ linux_process_target::start_step_over (lwp_info *lwp)\n      shouldn't care about.  */\n   pc = get_pc (lwp);\n \n-  saved_thread = current_thread;\n-  current_thread = thread;\n-\n-  lwp->bp_reinsert = pc;\n-  uninsert_breakpoints_at (pc);\n-  uninsert_fast_tracepoint_jumps_at (pc);\n+  bool step = false;\n+  {\n+    scoped_restore_current_thread restore_thread;\n+    switch_to_thread (thread);\n \n-  step = single_step (lwp);\n+    lwp->bp_reinsert = pc;\n+    uninsert_breakpoints_at (pc);\n+    uninsert_fast_tracepoint_jumps_at (pc);\n \n-  current_thread = saved_thread;\n+    step = single_step (lwp);\n+  }\n \n   resume_one_lwp (lwp, step, 0, NULL);\n \n@@ -4624,12 +4590,12 @@ linux_process_target::finish_step_over (lwp_info *lwp)\n {\n   if (lwp->bp_reinsert != 0)\n     {\n-      struct thread_info *saved_thread = current_thread;\n+      scoped_restore_current_thread restore_thread;\n \n       if (debug_threads)\n \tdebug_printf (\"Finished step over.\\n\");\n \n-      current_thread = get_lwp_thread (lwp);\n+      switch_to_thread (get_lwp_thread (lwp));\n \n       /* Reinsert any breakpoint at LWP->BP_REINSERT.  Note that there\n \t may be no breakpoint to reinsert there by now.  */\n@@ -4650,7 +4616,6 @@ linux_process_target::finish_step_over (lwp_info *lwp)\n \t}\n \n       step_over_bkpt = null_ptid;\n-      current_thread = saved_thread;\n       return true;\n     }\n   else"
    },
    {
      "sha": "4955bd35d108af77c57eb400b31180b476376c53",
      "filename": "gdbserver/linux-x86-low.cc",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/linux-x86-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/linux-x86-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-x86-low.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -991,7 +991,7 @@ x86_linux_read_description (void)\n void\n x86_target::update_xmltarget ()\n {\n-  struct thread_info *saved_thread = current_thread;\n+  scoped_restore_current_thread restore_thread;\n \n   /* Before changing the register cache's internal layout, flush the\n      contents of the current valid caches back to the threads, and\n@@ -1002,12 +1002,10 @@ x86_target::update_xmltarget ()\n     int pid = proc->pid;\n \n     /* Look up any thread of this process.  */\n-    current_thread = find_any_thread_of_pid (pid);\n+    switch_to_thread (find_any_thread_of_pid (pid));\n \n     low_arch_setup ();\n   });\n-\n-  current_thread = saved_thread;\n }\n \n /* Process qSupported query, \"xmlRegisters=\".  Update the buffer size for"
    },
    {
      "sha": "406594c63be83aeebce65ed16f6aeee66634270d",
      "filename": "gdbserver/mem-break.cc",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/mem-break.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/mem-break.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/mem-break.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -1501,13 +1501,12 @@ delete_single_step_breakpoints (struct thread_info *thread)\n       if (bp->type == single_step_breakpoint\n \t  && ((struct single_step_breakpoint *) bp)->ptid == ptid_of (thread))\n \t{\n-\t  struct thread_info *saved_thread = current_thread;\n+\t  scoped_restore_current_thread restore_thread;\n \n-\t  current_thread = thread;\n+\t  switch_to_thread (thread);\n \t  *bp_link = bp->next;\n \t  release_breakpoint (proc, bp);\n \t  bp = *bp_link;\n-\t  current_thread = saved_thread;\n \t}\n       else\n \t{\n@@ -1603,11 +1602,10 @@ uninsert_single_step_breakpoints (struct thread_info *thread)\n \t   reinsert breakpoint.  */\n \tif (bp->raw->refcount == 1)\n \t  {\n-\t    struct thread_info *saved_thread = current_thread;\n+\t    scoped_restore_current_thread restore_thread;\n \n-\t    current_thread = thread;\n+\t    switch_to_thread (thread);\n \t    uninsert_raw_breakpoint (bp->raw);\n-\t    current_thread = saved_thread;\n \t  }\n       }\n     }\n@@ -1709,11 +1707,10 @@ reinsert_single_step_breakpoints (struct thread_info *thread)\n \n \t  if (bp->raw->refcount == 1)\n \t    {\n-\t      struct thread_info *saved_thread = current_thread;\n+\t      scoped_restore_current_thread restore_thread;\n \n-\t      current_thread = thread;\n+\t      switch_to_thread (thread);\n \t      reinsert_raw_breakpoint (bp->raw);\n-\t      current_thread = saved_thread;\n \t    }\n \t}\n     }"
    },
    {
      "sha": "3c9dadd836974a836414c8001923396c03865dab",
      "filename": "gdbserver/netbsd-low.cc",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/netbsd-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/netbsd-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/netbsd-low.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -310,7 +310,7 @@ netbsd_wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n     }\n \n   if (find_thread_ptid (ptid_t (pid)))\n-    current_thread = find_thread_ptid (wptid);\n+    switch_to_thread (find_thread_ptid (wptid));\n \n   if (code == TRAP_LWP && pst.pe_report_event == PTRACE_LWP_CREATE)\n     {"
    },
    {
      "sha": "8f3f77f69b3f9b46530e9742d247a84d77a46582",
      "filename": "gdbserver/proc-service.cc",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/proc-service.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/proc-service.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/proc-service.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -105,20 +105,17 @@ ps_lgetregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, prgregset_t gregset)\n {\n #ifdef HAVE_REGSETS\n   struct lwp_info *lwp;\n-  struct thread_info *reg_thread, *saved_thread;\n   struct regcache *regcache;\n \n   lwp = find_lwp_pid (ptid_t (lwpid));\n   if (lwp == NULL)\n     return PS_ERR;\n \n-  reg_thread = get_lwp_thread (lwp);\n-  saved_thread = current_thread;\n-  current_thread = reg_thread;\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (get_lwp_thread (lwp));\n   regcache = get_thread_regcache (current_thread, 1);\n   gregset_info ()->fill_function (regcache, gregset);\n \n-  current_thread = saved_thread;\n   return PS_OK;\n #else\n   return PS_ERR;"
    },
    {
      "sha": "304be0d5dd3641c8802f4d0a85dc97335017ee42",
      "filename": "gdbserver/regcache.cc",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/regcache.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/regcache.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/regcache.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -49,14 +49,13 @@ get_thread_regcache (struct thread_info *thread, int fetch)\n \n   if (fetch && regcache->registers_valid == 0)\n     {\n-      struct thread_info *saved_thread = current_thread;\n+      scoped_restore_current_thread restore_thread;\n \n-      current_thread = thread;\n+      switch_to_thread (thread);\n       /* Invalidate all registers, to prevent stale left-overs.  */\n       memset (regcache->register_status, REG_UNAVAILABLE,\n \t      regcache->tdesc->reg_defs.size ());\n       fetch_inferior_registers (regcache, -1);\n-      current_thread = saved_thread;\n       regcache->registers_valid = 1;\n     }\n \n@@ -83,11 +82,10 @@ regcache_invalidate_thread (struct thread_info *thread)\n \n   if (regcache->registers_valid)\n     {\n-      struct thread_info *saved_thread = current_thread;\n+      scoped_restore_current_thread restore_thread;\n \n-      current_thread = thread;\n+      switch_to_thread (thread);\n       store_inferior_registers (regcache, -1);\n-      current_thread = saved_thread;\n     }\n \n   regcache->registers_valid = 0;"
    },
    {
      "sha": "ae1a85fa2b5c201f64777e033cbcbb33492c570c",
      "filename": "gdbserver/remote-utils.cc",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/remote-utils.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/remote-utils.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -1099,7 +1099,6 @@ prepare_resume_reply (char *buf, ptid_t ptid, const target_waitstatus &status)\n     case TARGET_WAITKIND_SYSCALL_ENTRY:\n     case TARGET_WAITKIND_SYSCALL_RETURN:\n       {\n-\tstruct thread_info *saved_thread;\n \tconst char **regp;\n \tstruct regcache *regcache;\n \n@@ -1182,7 +1181,7 @@ prepare_resume_reply (char *buf, ptid_t ptid, const target_waitstatus &status)\n \n \tbuf += strlen (buf);\n \n-\tsaved_thread = current_thread;\n+\tscoped_restore_current_thread restore_thread;\n \n \tswitch_to_thread (the_target, ptid);\n \n@@ -1273,8 +1272,6 @@ prepare_resume_reply (char *buf, ptid_t ptid, const target_waitstatus &status)\n \t    buf += strlen (buf);\n \t    current_process ()->dlls_changed = false;\n \t  }\n-\n-\tcurrent_thread = saved_thread;\n       }\n       break;\n     case TARGET_WAITKIND_EXITED:"
    },
    {
      "sha": "54ca95e62ffc602d90b52ff2627cdc04086c97a0",
      "filename": "gdbserver/server.cc",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/server.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/server.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -1294,7 +1294,7 @@ handle_detach (char *own_buf)\n \t  cs.last_status.set_exited (0);\n \t  cs.last_ptid = ptid_t (pid);\n \n-\t  current_thread = NULL;\n+\t  switch_to_thread (nullptr);\n \t}\n       else\n \t{\n@@ -1722,8 +1722,7 @@ handle_qxfer_threads_proper (struct buffer *buffer)\n {\n   client_state &cs = get_client_state ();\n \n-  scoped_restore save_current_thread\n-    = make_scoped_restore (&current_thread);\n+  scoped_restore_current_thread restore_thread;\n   scoped_restore save_current_general_thread\n     = make_scoped_restore (&cs.general_thread);\n \n@@ -2258,7 +2257,7 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)\n \n   if (strcmp (\"qSymbol::\", own_buf) == 0)\n     {\n-      struct thread_info *save_thread = current_thread;\n+      scoped_restore_current_thread restore_thread;\n \n       /* For qSymbol, GDB only changes the current thread if the\n \t previous current thread was of a different process.  So if\n@@ -2267,15 +2266,15 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)\n \t exec in a non-leader thread.  */\n       if (current_thread == NULL)\n \t{\n-\t  current_thread\n+\t  thread_info *any_thread\n \t    = find_any_thread_of_pid (cs.general_thread.pid ());\n+\t  switch_to_thread (any_thread);\n \n \t  /* Just in case, if we didn't find a thread, then bail out\n \t     instead of crashing.  */\n \t  if (current_thread == NULL)\n \t    {\n \t      write_enn (own_buf);\n-\t      current_thread = save_thread;\n \t      return;\n \t    }\n \t}\n@@ -2298,8 +2297,6 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)\n       if (current_thread != NULL)\n \tthe_target->look_up_symbols ();\n \n-      current_thread = save_thread;\n-\n       strcpy (own_buf, \"OK\");\n       return;\n     }"
    },
    {
      "sha": "bfafb7cd99eb437dfe0abe4ccffcca8a77f7330e",
      "filename": "gdbserver/target.cc",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/target.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/target.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/target.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -35,7 +35,7 @@ set_desired_thread ()\n   client_state &cs = get_client_state ();\n   thread_info *found = find_thread_ptid (cs.general_thread);\n \n-  current_thread = found;\n+  switch_to_thread (found);\n   return (current_thread != NULL);\n }\n \n@@ -101,7 +101,7 @@ prepare_to_access_memory (void)\n       return 1;\n     }\n \n-  current_thread = thread;\n+  switch_to_thread (thread);\n   cs.general_thread = ptid_of (thread);\n \n   return 0;"
    },
    {
      "sha": "01e83571224125ed554c01013aa93b35f7d13843",
      "filename": "gdbserver/thread-db.cc",
      "status": "modified",
      "additions": 5,
      "deletions": 9,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/thread-db.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/thread-db.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/thread-db.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -388,7 +388,6 @@ thread_db_get_tls_address (struct thread_info *thread, CORE_ADDR offset,\n   psaddr_t addr;\n   td_err_e err;\n   struct lwp_info *lwp;\n-  struct thread_info *saved_thread;\n   struct process_info *proc;\n   struct thread_db *thread_db;\n \n@@ -411,8 +410,8 @@ thread_db_get_tls_address (struct thread_info *thread, CORE_ADDR offset,\n   if (!lwp->thread_known)\n     return TD_NOTHR;\n \n-  saved_thread = current_thread;\n-  current_thread = thread;\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (thread);\n \n   if (load_module != 0)\n     {\n@@ -435,7 +434,6 @@ thread_db_get_tls_address (struct thread_info *thread, CORE_ADDR offset,\n       addr = (char *) addr + offset;\n     }\n \n-  current_thread = saved_thread;\n   if (err == TD_OK)\n     {\n       *address = (CORE_ADDR) (uintptr_t) addr;\n@@ -788,7 +786,7 @@ disable_thread_event_reporting (struct process_info *proc)\n \n       if (td_ta_clear_event_p != NULL)\n \t{\n-\t  struct thread_info *saved_thread = current_thread;\n+\t  scoped_restore_current_thread restore_thread;\n \t  td_thr_events_t events;\n \n \t  switch_to_process (proc);\n@@ -797,8 +795,6 @@ disable_thread_event_reporting (struct process_info *proc)\n \t     in any events anymore.  */\n \t  td_event_fillset (&events);\n \t  (*td_ta_clear_event_p) (thread_db->thread_agent, &events);\n-\n-\t  current_thread = saved_thread;\n \t}\n     }\n }\n@@ -894,8 +890,8 @@ thread_db_notice_clone (struct thread_info *parent_thr, ptid_t child_ptid)\n   /* find_one_thread calls into libthread_db which accesses memory via\n      the current thread.  Temporarily switch to a thread we know is\n      stopped.  */\n-  scoped_restore restore_current_thread\n-    = make_scoped_restore (&current_thread, parent_thr);\n+  scoped_restore_current_thread restore_thread;\n+  switch_to_thread (parent_thr);\n \n   if (!find_one_thread (child_ptid))\n     warning (\"Cannot find thread after clone.\");"
    },
    {
      "sha": "f176ab24393ac9b56c9d0c58c3a97001f1748752",
      "filename": "gdbserver/tracepoint.cc",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/tracepoint.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/tracepoint.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/tracepoint.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -3975,18 +3975,14 @@ gdb_agent_about_to_close (int pid)\n \n   if (!maybe_write_ipa_not_loaded (buf))\n     {\n-      struct thread_info *saved_thread;\n-\n-      saved_thread = current_thread;\n+      scoped_restore_current_thread restore_thread;\n \n       /* Find any thread which belongs to process PID.  */\n-      current_thread = find_any_thread_of_pid (pid);\n+      switch_to_thread (find_any_thread_of_pid (pid));\n \n       strcpy (buf, \"close\");\n \n       run_inferior_command (buf, strlen (buf) + 1);\n-\n-      current_thread = saved_thread;\n     }\n }\n "
    },
    {
      "sha": "6f6fcefafbc421078e2ffda3399720dcd35f3fd9",
      "filename": "gdbserver/win32-low.cc",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/win32-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24583e45efc823c1a9ea009dfddc36f9b74dcbcd/gdbserver/win32-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/win32-low.cc?ref=24583e45efc823c1a9ea009dfddc36f9b74dcbcd",
      "patch": "@@ -1102,7 +1102,7 @@ get_child_debug_event (DWORD *continue_status,\n \t*ourstatus = stop->status;\n \tcurrent_event = stop->event;\n \tptid = debug_event_ptid (&current_event);\n-\tcurrent_thread = find_thread_ptid (ptid);\n+\tswitch_to_thread (find_thread_ptid (ptid));\n \treturn 1;\n       }\n \n@@ -1152,7 +1152,7 @@ get_child_debug_event (DWORD *continue_status,\n       child_delete_thread (current_event.dwProcessId,\n \t\t\t   current_event.dwThreadId);\n \n-      current_thread = get_first_thread ();\n+      switch_to_thread (get_first_thread ());\n       return 1;\n \n     case CREATE_PROCESS_DEBUG_EVENT:\n@@ -1264,7 +1264,7 @@ get_child_debug_event (DWORD *continue_status,\n       ourstatus->set_spurious ();\n     }\n   else\n-    current_thread = find_thread_ptid (ptid);\n+    switch_to_thread (find_thread_ptid (ptid));\n \n   return 1;\n }"
    }
  ]
}