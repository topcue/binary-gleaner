{
  "sha": "5776fca307b8af3d852525b77e9b917a9aa97370",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTc3NmZjYTMwN2I4YWYzZDg1MjUyNWI3N2U5YjkxN2E5YWE5NzM3MA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-03-25T03:30:56Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-05T01:55:11Z"
    },
    "message": "Move lexptr and prev_lexptr to parser_state\n\nThis removes the lexptr and prev_lexptr globals, in favor of members\nof parser_state.  prev_lexptr could be isolated to each parser, but\nsince every parser uses it, that did not seem necessary.\n\ngdb/ChangeLog\n2019-04-04  Tom Tromey  <tom@tromey.com>\n\n\t* rust-exp.y (struct rust_parser) <lex_hex, lex_escape,\n\tlex_operator, push_back>: New methods.\n\tUpdate all rules.\n\t(rust_parser::lex_hex, lex_escape): Rename and update.\n\t(rust_parser::lex_string, rust_parser::lex_identifier): Update.\n\t(rust_parser::lex_operator): Rename and update.\n\t(rust_parser::lex_number, rustyylex, rustyyerror)\n\t(rust_lex_test_init, rust_lex_test_sequence)\n\t(rust_lex_test_push_back, rust_lex_tests): Update.\n\t* parser-defs.h (struct parser_state) <parser_state>: Add \"input\"\n\tparameter.\n\t<lexptr, prev_lexptr>: New members.\n\t(lexptr, prev_lexptr): Don't declare.\n\t* parse.c (lexptr, prev_lexptr): Remove globals.\n\t(parse_exp_in_context): Update.\n\t* p-exp.y (yylex, yyerror): Update.\n\t* m2-exp.y (parse_number, yylex, yyerror): Update.\n\t* go-exp.y (lex_one_token, yyerror): Update.\n\t* f-exp.y (match_string_literal, yylex, yyerror): Update.\n\t* d-exp.y (lex_one_token, yyerror): Update.\n\t* c-exp.y (scan_macro_expansion, finished_macro_expansion)\n\t(lex_one_token, yyerror): Update.\n\t* ada-lex.l (YY_INPUT): Update.\n\t(rewind_to_char): Update.\n\t* ada-exp.y (yyerror): Update.",
    "tree": {
      "sha": "ac923aa97349376a076996f5f8db12b44e728cb5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ac923aa97349376a076996f5f8db12b44e728cb5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5776fca307b8af3d852525b77e9b917a9aa97370",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5776fca307b8af3d852525b77e9b917a9aa97370",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5776fca307b8af3d852525b77e9b917a9aa97370",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5776fca307b8af3d852525b77e9b917a9aa97370/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8621b685bfdcb8773b8177fb2b89e45499902868",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8621b685bfdcb8773b8177fb2b89e45499902868",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8621b685bfdcb8773b8177fb2b89e45499902868"
    }
  ],
  "stats": {
    "total": 587,
    "additions": 312,
    "deletions": 275
  },
  "files": [
    {
      "sha": "629e555f16798e069519c4b50331e1c835cc6f47",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -1,3 +1,31 @@\n+2019-04-04  Tom Tromey  <tom@tromey.com>\n+\n+\t* rust-exp.y (struct rust_parser) <lex_hex, lex_escape,\n+\tlex_operator, push_back>: New methods.\n+\tUpdate all rules.\n+\t(rust_parser::lex_hex, lex_escape): Rename and update.\n+\t(rust_parser::lex_string, rust_parser::lex_identifier): Update.\n+\t(rust_parser::lex_operator): Rename and update.\n+\t(rust_parser::lex_number, rustyylex, rustyyerror)\n+\t(rust_lex_test_init, rust_lex_test_sequence)\n+\t(rust_lex_test_push_back, rust_lex_tests): Update.\n+\t* parser-defs.h (struct parser_state) <parser_state>: Add \"input\"\n+\tparameter.\n+\t<lexptr, prev_lexptr>: New members.\n+\t(lexptr, prev_lexptr): Don't declare.\n+\t* parse.c (lexptr, prev_lexptr): Remove globals.\n+\t(parse_exp_in_context): Update.\n+\t* p-exp.y (yylex, yyerror): Update.\n+\t* m2-exp.y (parse_number, yylex, yyerror): Update.\n+\t* go-exp.y (lex_one_token, yyerror): Update.\n+\t* f-exp.y (match_string_literal, yylex, yyerror): Update.\n+\t* d-exp.y (lex_one_token, yyerror): Update.\n+\t* c-exp.y (scan_macro_expansion, finished_macro_expansion)\n+\t(lex_one_token, yyerror): Update.\n+\t* ada-lex.l (YY_INPUT): Update.\n+\t(rewind_to_char): Update.\n+\t* ada-exp.y (yyerror): Update.\n+\n 2019-04-04  Tom Tromey  <tom@tromey.com>\n \n \t* rust-exp.y (rustyylex, rust_lex_tests): Update."
    },
    {
      "sha": "f50500c2e7fa98ae1594fe8ecfcd78d42e4a07db",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -745,7 +745,7 @@ ada_parse (struct parser_state *par_state)\n static void\n yyerror (const char *msg)\n {\n-  error (_(\"Error in expression, near `%s'.\"), lexptr);\n+  error (_(\"Error in expression, near `%s'.\"), pstate->lexptr);\n }\n \n /* Emit expression to access an instance of SYM, in block BLOCK (if"
    },
    {
      "sha": "f7fac27410edf683594e528252a91dbe603dd73c",
      "filename": "gdb/ada-lex.l",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/ada-lex.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/ada-lex.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lex.l?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -73,13 +73,13 @@ static void rewind_to_char (int);\n \n #undef YY_INPUT\n #define YY_INPUT(BUF, RESULT, MAX_SIZE) \\\n-    if ( *lexptr == '\\000' ) \\\n+    if ( *pstate->lexptr == '\\000' ) \\\n       (RESULT) = YY_NULL; \\\n     else \\\n       { \\\n-        *(BUF) = *lexptr; \\\n+        *(BUF) = *pstate->lexptr; \\\n         (RESULT) = 1; \\\n-\tlexptr += 1; \\\n+\tpstate->lexptr += 1; \\\n       }\n \n static int find_dot_all (const char *);\n@@ -628,9 +628,9 @@ processAttribute (const char *str)\n static void\n rewind_to_char (int ch)\n {\n-  lexptr -= yyleng;\n-  while (toupper (*lexptr) != toupper (ch))\n-    lexptr -= 1;\n+  pstate->lexptr -= yyleng;\n+  while (toupper (*pstate->lexptr) != toupper (ch))\n+    pstate->lexptr -= 1;\n   yyrestart (NULL);\n }\n "
    },
    {
      "sha": "c85bb3133e854cdd2a73e90f669b3dc0738a0f5d",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -2483,8 +2483,8 @@ scan_macro_expansion (char *expansion)\n \n   /* Save the old lexptr value, so we can return to it when we're done\n      parsing the expanded text.  */\n-  cpstate->macro_original_text = lexptr;\n-  lexptr = copy;\n+  cpstate->macro_original_text = pstate->lexptr;\n+  pstate->lexptr = copy;\n }\n \n static int\n@@ -2500,7 +2500,7 @@ finished_macro_expansion (void)\n   gdb_assert (cpstate->macro_original_text);\n \n   /* Pop back to the original text.  */\n-  lexptr = cpstate->macro_original_text;\n+  pstate->lexptr = cpstate->macro_original_text;\n   cpstate->macro_original_text = 0;\n }\n \n@@ -2550,17 +2550,17 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n   /* Check if this is a macro invocation that we need to expand.  */\n   if (! scanning_macro_expansion ())\n     {\n-      char *expanded = macro_expand_next (&lexptr,\n+      char *expanded = macro_expand_next (&pstate->lexptr,\n                                           standard_macro_lookup,\n                                           expression_macro_scope);\n \n       if (expanded)\n         scan_macro_expansion (expanded);\n     }\n \n-  prev_lexptr = lexptr;\n+  pstate->prev_lexptr = pstate->lexptr;\n \n-  tokstart = lexptr;\n+  tokstart = pstate->lexptr;\n   /* See if it is a special token of length 3.  */\n   for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)\n     if (strncmp (tokstart, tokentab3[i].oper, 3) == 0)\n@@ -2569,7 +2569,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t    && par_state->language ()->la_language != language_cplus)\n \t  break;\n \n-\tlexptr += 3;\n+\tpstate->lexptr += 3;\n \tyylval.opcode = tokentab3[i].opcode;\n \treturn tokentab3[i].token;\n       }\n@@ -2582,7 +2582,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t    && par_state->language ()->la_language != language_cplus)\n \t  break;\n \n-\tlexptr += 2;\n+\tpstate->lexptr += 2;\n \tyylval.opcode = tokentab2[i].opcode;\n \tif (tokentab2[i].token == ARROW)\n \t  last_was_structop = 1;\n@@ -2616,13 +2616,13 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n     case ' ':\n     case '\\t':\n     case '\\n':\n-      lexptr++;\n+      pstate->lexptr++;\n       goto retry;\n \n     case '[':\n     case '(':\n       paren_depth++;\n-      lexptr++;\n+      pstate->lexptr++;\n       if (par_state->language ()->la_language == language_objc\n \t  && c == '[')\n \treturn OBJC_LBRAC;\n@@ -2633,20 +2633,20 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n       if (paren_depth == 0)\n \treturn 0;\n       paren_depth--;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case ',':\n       if (pstate->comma_terminates\n           && paren_depth == 0\n           && ! scanning_macro_expansion ())\n \treturn 0;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case '.':\n       /* Might be a floating point number.  */\n-      if (lexptr[1] < '0' || lexptr[1] > '9')\n+      if (pstate->lexptr[1] < '0' || pstate->lexptr[1] > '9')\n \t{\n \t  last_was_structop = true;\n \t  goto symbol;\t\t/* Nope, must be a symbol. */\n@@ -2713,7 +2713,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t    err_copy[p - tokstart] = 0;\n \t    error (_(\"Invalid number \\\"%s\\\".\"), err_copy);\n \t  }\n-\tlexptr = p;\n+\tpstate->lexptr = p;\n \treturn toktype;\n       }\n \n@@ -2728,7 +2728,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t    if (strncmp (p, \"selector\", len) == 0\n \t\t&& (p[len] == '\\0' || ISSPACE (p[len])))\n \t      {\n-\t\tlexptr = p + len;\n+\t\tpstate->lexptr = p + len;\n \t\treturn SELECTOR;\n \t      }\n \t    else if (*p == '\"')\n@@ -2741,7 +2741,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \tif (strncmp (p, \"entry\", len) == 0 && !c_ident_is_alnum (p[len])\n \t    && p[len] != '_')\n \t  {\n-\t    lexptr = &p[len];\n+\t    pstate->lexptr = &p[len];\n \t    return ENTRY;\n \t  }\n       }\n@@ -2764,7 +2764,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n     case '{':\n     case '}':\n     symbol:\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case 'L':\n@@ -2779,16 +2779,16 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n     parse_string:\n       {\n \tint host_len;\n-\tint result = parse_string_or_char (tokstart, &lexptr, &yylval.tsval,\n-\t\t\t\t\t   &host_len);\n+\tint result = parse_string_or_char (tokstart, &pstate->lexptr,\n+\t\t\t\t\t   &yylval.tsval, &host_len);\n \tif (result == CHAR)\n \t  {\n \t    if (host_len == 0)\n \t      error (_(\"Empty character constant.\"));\n \t    else if (host_len > 2 && c == '\\'')\n \t      {\n \t\t++tokstart;\n-\t\tnamelen = lexptr - tokstart - 1;\n+\t\tnamelen = pstate->lexptr - tokstart - 1;\n \t\t*is_quoted_name = true;\n \n \t\tgoto tryname;\n@@ -2860,7 +2860,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \treturn 0;\n     }\n \n-  lexptr += namelen;\n+  pstate->lexptr += namelen;\n \n   tryname:\n \n@@ -2902,7 +2902,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n   if (*tokstart == '$')\n     return DOLLAR_VARIABLE;\n \n-  if (parse_completion && *lexptr == '\\0')\n+  if (parse_completion && *pstate->lexptr == '\\0')\n     saw_name_at_eof = 1;\n \n   yylval.ssym.stoken = yylval.sval;\n@@ -3388,8 +3388,8 @@ c_print_token (FILE *file, int type, YYSTYPE value)\n static void\n yyerror (const char *msg)\n {\n-  if (prev_lexptr)\n-    lexptr = prev_lexptr;\n+  if (pstate->prev_lexptr)\n+    pstate->lexptr = pstate->prev_lexptr;\n \n-  error (_(\"A %s in expression, near `%s'.\"), msg, lexptr);\n+  error (_(\"A %s in expression, near `%s'.\"), msg, pstate->lexptr);\n }"
    },
    {
      "sha": "9addf6c04108f1b77d5ffd771c2bc6b4f6e2ffd6",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -1039,14 +1039,14 @@ lex_one_token (struct parser_state *par_state)\n \n  retry:\n \n-  prev_lexptr = lexptr;\n+  pstate->prev_lexptr = pstate->lexptr;\n \n-  tokstart = lexptr;\n+  tokstart = pstate->lexptr;\n   /* See if it is a special token of length 3.  */\n   for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)\n     if (strncmp (tokstart, tokentab3[i].oper, 3) == 0)\n       {\n-\tlexptr += 3;\n+\tpstate->lexptr += 3;\n \tyylval.opcode = tokentab3[i].opcode;\n \treturn tokentab3[i].token;\n       }\n@@ -1055,7 +1055,7 @@ lex_one_token (struct parser_state *par_state)\n   for (i = 0; i < sizeof tokentab2 / sizeof tokentab2[0]; i++)\n     if (strncmp (tokstart, tokentab2[i].oper, 2) == 0)\n       {\n-\tlexptr += 2;\n+\tpstate->lexptr += 2;\n \tyylval.opcode = tokentab2[i].opcode;\n \treturn tokentab2[i].token;\n       }\n@@ -1080,32 +1080,32 @@ lex_one_token (struct parser_state *par_state)\n     case ' ':\n     case '\\t':\n     case '\\n':\n-      lexptr++;\n+      pstate->lexptr++;\n       goto retry;\n \n     case '[':\n     case '(':\n       paren_depth++;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case ']':\n     case ')':\n       if (paren_depth == 0)\n \treturn 0;\n       paren_depth--;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case ',':\n       if (pstate->comma_terminates && paren_depth == 0)\n \treturn 0;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case '.':\n       /* Might be a floating point number.  */\n-      if (lexptr[1] < '0' || lexptr[1] > '9')\n+      if (pstate->lexptr[1] < '0' || pstate->lexptr[1] > '9')\n \t{\n \t  if (parse_completion)\n \t    last_was_structop = 1;\n@@ -1170,7 +1170,7 @@ lex_one_token (struct parser_state *par_state)\n \t    err_copy[p - tokstart] = 0;\n \t    error (_(\"Invalid number \\\"%s\\\".\"), err_copy);\n \t  }\n-\tlexptr = p;\n+\tpstate->lexptr = p;\n \treturn toktype;\n       }\n \n@@ -1184,7 +1184,7 @@ lex_one_token (struct parser_state *par_state)\n \tif (strncmp (p, \"entry\", len) == 0 && !isalnum (p[len])\n \t    && p[len] != '_')\n \t  {\n-\t    lexptr = &p[len];\n+\t    pstate->lexptr = &p[len];\n \t    return ENTRY;\n \t  }\n       }\n@@ -1207,24 +1207,24 @@ lex_one_token (struct parser_state *par_state)\n     case '{':\n     case '}':\n     symbol:\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case '\\'':\n     case '\"':\n     case '`':\n       {\n \tint host_len;\n-\tint result = parse_string_or_char (tokstart, &lexptr, &yylval.tsval,\n-\t\t\t\t\t   &host_len);\n+\tint result = parse_string_or_char (tokstart, &pstate->lexptr,\n+\t\t\t\t\t   &yylval.tsval, &host_len);\n \tif (result == CHARACTER_LITERAL)\n \t  {\n \t    if (host_len == 0)\n \t      error (_(\"Empty character constant.\"));\n \t    else if (host_len > 2 && c == '\\'')\n \t      {\n \t\t++tokstart;\n-\t\tnamelen = lexptr - tokstart - 1;\n+\t\tnamelen = pstate->lexptr - tokstart - 1;\n \t\tgoto tryname;\n \t      }\n \t    else if (host_len > 1)\n@@ -1269,7 +1269,7 @@ lex_one_token (struct parser_state *par_state)\n         return 0;\n     }\n \n-  lexptr += namelen;\n+  pstate->lexptr += namelen;\n \n  tryname:\n \n@@ -1308,7 +1308,7 @@ lex_one_token (struct parser_state *par_state)\n \treturn NAME_OR_INT;\n     }\n \n-  if (parse_completion && *lexptr == '\\0')\n+  if (parse_completion && *pstate->lexptr == '\\0')\n     saw_name_at_eof = 1;\n \n   return IDENTIFIER;\n@@ -1634,9 +1634,9 @@ d_parse (struct parser_state *par_state)\n static void\n yyerror (const char *msg)\n {\n-  if (prev_lexptr)\n-    lexptr = prev_lexptr;\n+  if (pstate->prev_lexptr)\n+    pstate->lexptr = pstate->prev_lexptr;\n \n-  error (_(\"A %s in expression, near `%s'.\"), msg, lexptr);\n+  error (_(\"A %s in expression, near `%s'.\"), msg, pstate->lexptr);\n }\n "
    },
    {
      "sha": "fce90b48ef52105777a7365622df4e6fa0b2f0df",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -1005,14 +1005,14 @@ growbuf_by_size (int count)\n static int\n match_string_literal (void)\n {\n-  const char *tokptr = lexptr;\n+  const char *tokptr = pstate->lexptr;\n \n   for (tempbufindex = 0, tokptr++; *tokptr != '\\0'; tokptr++)\n     {\n       CHECKBUF (1);\n-      if (*tokptr == *lexptr)\n+      if (*tokptr == *pstate->lexptr)\n \t{\n-\t  if (*(tokptr + 1) == *lexptr)\n+\t  if (*(tokptr + 1) == *pstate->lexptr)\n \t    tokptr++;\n \t  else\n \t    break;\n@@ -1027,7 +1027,7 @@ match_string_literal (void)\n       tempbuf[tempbufindex] = '\\0';\n       yylval.sval.ptr = tempbuf;\n       yylval.sval.length = tempbufindex;\n-      lexptr = ++tokptr;\n+      pstate->lexptr = ++tokptr;\n       return STRING_LITERAL;\n     }\n }\n@@ -1044,21 +1044,21 @@ yylex (void)\n   \n  retry:\n  \n-  prev_lexptr = lexptr;\n+  pstate->prev_lexptr = pstate->lexptr;\n  \n-  tokstart = lexptr;\n+  tokstart = pstate->lexptr;\n \n   /* First of all, let us make sure we are not dealing with the\n      special tokens .true. and .false. which evaluate to 1 and 0.  */\n \n-  if (*lexptr == '.')\n+  if (*pstate->lexptr == '.')\n     {\n       for (int i = 0; i < ARRAY_SIZE (boolean_values); i++)\n \t{\n \t  if (strncasecmp (tokstart, boolean_values[i].name,\n \t\t\t   strlen (boolean_values[i].name)) == 0)\n \t    {\n-\t      lexptr += strlen (boolean_values[i].name);\n+\t      pstate->lexptr += strlen (boolean_values[i].name);\n \t      yylval.lval = boolean_values[i].value;\n \t      return BOOLEAN_LITERAL;\n \t    }\n@@ -1071,7 +1071,7 @@ yylex (void)\n \t\t     strlen (dot_ops[i].oper)) == 0)\n       {\n \tgdb_assert (!dot_ops[i].case_sensitive);\n-\tlexptr += strlen (dot_ops[i].oper);\n+\tpstate->lexptr += strlen (dot_ops[i].oper);\n \tyylval.opcode = dot_ops[i].opcode;\n \treturn dot_ops[i].token;\n       }\n@@ -1080,7 +1080,7 @@ yylex (void)\n \n   if (strncmp (tokstart, \"**\", 2) == 0)\n     {\n-      lexptr += 2;\n+      pstate->lexptr += 2;\n       yylval.opcode = BINOP_EXP;\n       return STARSTAR;\n     }\n@@ -1093,7 +1093,7 @@ yylex (void)\n     case ' ':\n     case '\\t':\n     case '\\n':\n-      lexptr++;\n+      pstate->lexptr++;\n       goto retry;\n       \n     case '\\'':\n@@ -1104,25 +1104,25 @@ yylex (void)\n       \n     case '(':\n       paren_depth++;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n       \n     case ')':\n       if (paren_depth == 0)\n \treturn 0;\n       paren_depth--;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n       \n     case ',':\n       if (pstate->comma_terminates && paren_depth == 0)\n \treturn 0;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n       \n     case '.':\n       /* Might be a floating point number.  */\n-      if (lexptr[1] < '0' || lexptr[1] > '9')\n+      if (pstate->lexptr[1] < '0' || pstate->lexptr[1] > '9')\n \tgoto symbol;\t\t/* Nope, must be a symbol.  */\n       /* FALL THRU.  */\n       \n@@ -1186,7 +1186,7 @@ yylex (void)\n \t    err_copy[p - tokstart] = 0;\n \t    error (_(\"Invalid number \\\"%s\\\".\"), err_copy);\n \t  }\n-\tlexptr = p;\n+\tpstate->lexptr = p;\n \treturn toktype;\n       }\n       \n@@ -1211,7 +1211,7 @@ yylex (void)\n     case '{':\n     case '}':\n     symbol:\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n     }\n   \n@@ -1232,7 +1232,7 @@ yylex (void)\n   if (namelen == 2 && tokstart[0] == 'i' && tokstart[1] == 'f')\n     return 0;\n   \n-  lexptr += namelen;\n+  pstate->lexptr += namelen;\n   \n   /* Catch specific keywords.  */\n \n@@ -1339,8 +1339,8 @@ f_parse (struct parser_state *par_state)\n static void\n yyerror (const char *msg)\n {\n-  if (prev_lexptr)\n-    lexptr = prev_lexptr;\n+  if (pstate->prev_lexptr)\n+    pstate->lexptr = pstate->prev_lexptr;\n \n-  error (_(\"A %s in expression, near `%s'.\"), msg, lexptr);\n+  error (_(\"A %s in expression, near `%s'.\"), msg, pstate->lexptr);\n }"
    },
    {
      "sha": "6754d5217e5e9f995b3d9a200c0b855ad49e1215",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -1020,14 +1020,14 @@ lex_one_token (struct parser_state *par_state)\n \n  retry:\n \n-  prev_lexptr = lexptr;\n+  par_state->prev_lexptr = par_state->lexptr;\n \n-  tokstart = lexptr;\n+  tokstart = par_state->lexptr;\n   /* See if it is a special token of length 3.  */\n   for (i = 0; i < sizeof (tokentab3) / sizeof (tokentab3[0]); i++)\n     if (strncmp (tokstart, tokentab3[i].oper, 3) == 0)\n       {\n-\tlexptr += 3;\n+\tpar_state->lexptr += 3;\n \tyylval.opcode = tokentab3[i].opcode;\n \treturn tokentab3[i].token;\n       }\n@@ -1036,7 +1036,7 @@ lex_one_token (struct parser_state *par_state)\n   for (i = 0; i < sizeof (tokentab2) / sizeof (tokentab2[0]); i++)\n     if (strncmp (tokstart, tokentab2[i].oper, 2) == 0)\n       {\n-\tlexptr += 2;\n+\tpar_state->lexptr += 2;\n \tyylval.opcode = tokentab2[i].opcode;\n \t/* NOTE: -> doesn't exist in Go, so we don't need to watch for\n \t   setting last_was_structop here.  */\n@@ -1059,33 +1059,33 @@ lex_one_token (struct parser_state *par_state)\n     case ' ':\n     case '\\t':\n     case '\\n':\n-      lexptr++;\n+      par_state->lexptr++;\n       goto retry;\n \n     case '[':\n     case '(':\n       paren_depth++;\n-      lexptr++;\n+      par_state->lexptr++;\n       return c;\n \n     case ']':\n     case ')':\n       if (paren_depth == 0)\n \treturn 0;\n       paren_depth--;\n-      lexptr++;\n+      par_state->lexptr++;\n       return c;\n \n     case ',':\n       if (pstate->comma_terminates\n           && paren_depth == 0)\n \treturn 0;\n-      lexptr++;\n+      par_state->lexptr++;\n       return c;\n \n     case '.':\n       /* Might be a floating point number.  */\n-      if (lexptr[1] < '0' || lexptr[1] > '9')\n+      if (par_state->lexptr[1] < '0' || par_state->lexptr[1] > '9')\n \t{\n \t  if (parse_completion)\n \t    last_was_structop = 1;\n@@ -1148,7 +1148,7 @@ lex_one_token (struct parser_state *par_state)\n \t    err_copy[p - tokstart] = 0;\n \t    error (_(\"Invalid number \\\"%s\\\".\"), err_copy);\n \t  }\n-\tlexptr = p;\n+\tpar_state->lexptr = p;\n \treturn toktype;\n       }\n \n@@ -1162,7 +1162,7 @@ lex_one_token (struct parser_state *par_state)\n \tif (strncmp (p, \"entry\", len) == 0 && !isalnum (p[len])\n \t    && p[len] != '_')\n \t  {\n-\t    lexptr = &p[len];\n+\t    par_state->lexptr = &p[len];\n \t    return ENTRY;\n \t  }\n       }\n@@ -1185,24 +1185,24 @@ lex_one_token (struct parser_state *par_state)\n     case '{':\n     case '}':\n     symbol:\n-      lexptr++;\n+      par_state->lexptr++;\n       return c;\n \n     case '\\'':\n     case '\"':\n     case '`':\n       {\n \tint host_len;\n-\tint result = parse_string_or_char (tokstart, &lexptr, &yylval.tsval,\n-\t\t\t\t\t   &host_len);\n+\tint result = parse_string_or_char (tokstart, &par_state->lexptr,\n+\t\t\t\t\t   &yylval.tsval, &host_len);\n \tif (result == CHAR)\n \t  {\n \t    if (host_len == 0)\n \t      error (_(\"Empty character constant.\"));\n \t    else if (host_len > 2 && c == '\\'')\n \t      {\n \t\t++tokstart;\n-\t\tnamelen = lexptr - tokstart - 1;\n+\t\tnamelen = par_state->lexptr - tokstart - 1;\n \t\tgoto tryname;\n \t      }\n \t    else if (host_len > 1)\n@@ -1255,7 +1255,7 @@ lex_one_token (struct parser_state *par_state)\n \treturn 0;\n     }\n \n-  lexptr += namelen;\n+  par_state->lexptr += namelen;\n \n   tryname:\n \n@@ -1276,7 +1276,7 @@ lex_one_token (struct parser_state *par_state)\n   if (*tokstart == '$')\n     return DOLLAR_VARIABLE;\n \n-  if (parse_completion && *lexptr == '\\0')\n+  if (parse_completion && *par_state->lexptr == '\\0')\n     saw_name_at_eof = 1;\n   return NAME;\n }\n@@ -1581,8 +1581,8 @@ go_parse (struct parser_state *par_state)\n static void\n yyerror (const char *msg)\n {\n-  if (prev_lexptr)\n-    lexptr = prev_lexptr;\n+  if (pstate->prev_lexptr)\n+    pstate->lexptr = pstate->prev_lexptr;\n \n-  error (_(\"A %s in expression, near `%s'.\"), msg, lexptr);\n+  error (_(\"A %s in expression, near `%s'.\"), msg, pstate->lexptr);\n }"
    },
    {
      "sha": "6ba8eaf8554c82ac85f04bac67d7170a83ccaea8",
      "filename": "gdb/m2-exp.y",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/m2-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/m2-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-exp.y?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -618,7 +618,7 @@ type\n static int\n parse_number (int olen)\n {\n-  const char *p = lexptr;\n+  const char *p = pstate->lexptr;\n   LONGEST n = 0;\n   LONGEST prevn = 0;\n   int c,i,ischar=0;\n@@ -649,7 +649,7 @@ parse_number (int olen)\n \t\t\t  yylval.val))\n \t  return ERROR;\n \n-\tlexptr += len;\n+\tpstate->lexptr += len;\n \treturn FLOAT;\n       }\n     if (p[c] == '.' && base != 10)\n@@ -689,9 +689,9 @@ parse_number (int olen)\n \t prevn=n;\n     }\n \n-  lexptr = p;\n+  pstate->lexptr = p;\n   if(*p == 'B' || *p == 'C' || *p == 'H')\n-     lexptr++;\t\t\t/* Advance past B,C or H */\n+     pstate->lexptr++;\t\t\t/* Advance past B,C or H */\n \n   if (ischar)\n   {\n@@ -782,16 +782,16 @@ yylex (void)\n \n  retry:\n \n-  prev_lexptr = lexptr;\n+  pstate->prev_lexptr = pstate->lexptr;\n \n-  tokstart = lexptr;\n+  tokstart = pstate->lexptr;\n \n \n   /* See if it is a special token of length 2 */\n   for( i = 0 ; i < (int) (sizeof tokentab2 / sizeof tokentab2[0]) ; i++)\n      if (strncmp (tokentab2[i].name, tokstart, 2) == 0)\n      {\n-\tlexptr += 2;\n+\tpstate->lexptr += 2;\n \treturn tokentab2[i].token;\n      }\n \n@@ -803,34 +803,34 @@ yylex (void)\n     case ' ':\n     case '\\t':\n     case '\\n':\n-      lexptr++;\n+      pstate->lexptr++;\n       goto retry;\n \n     case '(':\n       paren_depth++;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case ')':\n       if (paren_depth == 0)\n \treturn 0;\n       paren_depth--;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case ',':\n       if (pstate->comma_terminates && paren_depth == 0)\n \treturn 0;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case '.':\n       /* Might be a floating point number.  */\n-      if (lexptr[1] >= '0' && lexptr[1] <= '9')\n+      if (pstate->lexptr[1] >= '0' && pstate->lexptr[1] <= '9')\n \tbreak;\t\t\t/* Falls into number code.  */\n       else\n       {\n-\t lexptr++;\n+\t pstate->lexptr++;\n \t return DOT;\n       }\n \n@@ -851,7 +851,7 @@ yylex (void)\n     case '@':\n     case '~':\n     case '&':\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case '\\'' :\n@@ -872,7 +872,7 @@ yylex (void)\n \t error (_(\"Unterminated string or character constant.\"));\n       yylval.sval.ptr = tokstart + 1;\n       yylval.sval.length = namelen - 1;\n-      lexptr += namelen + 1;\n+      pstate->lexptr += namelen + 1;\n \n       if(namelen == 2)  \t/* Single character */\n       {\n@@ -918,7 +918,7 @@ yylex (void)\n \t    err_copy[p - tokstart] = 0;\n \t    error (_(\"Invalid number \\\"%s\\\".\"), err_copy);\n \t  }\n-\tlexptr = p;\n+\tpstate->lexptr = p;\n \treturn toktype;\n     }\n \n@@ -942,7 +942,7 @@ yylex (void)\n       return 0;\n     }\n \n-  lexptr += namelen;\n+  pstate->lexptr += namelen;\n \n   /*  Lookup special keywords */\n   for(i = 0 ; i < (int) (sizeof(keytab) / sizeof(keytab[0])) ; i++)\n@@ -1050,8 +1050,8 @@ m2_parse (struct parser_state *par_state)\n static void\n yyerror (const char *msg)\n {\n-  if (prev_lexptr)\n-    lexptr = prev_lexptr;\n+  if (pstate->prev_lexptr)\n+    pstate->lexptr = pstate->prev_lexptr;\n \n-  error (_(\"A %s in expression, near `%s'.\"), msg, lexptr);\n+  error (_(\"A %s in expression, near `%s'.\"), msg, pstate->lexptr);\n }"
    },
    {
      "sha": "4487899ead9719f9830e78ee44a924ea4da648e4",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -1128,10 +1128,10 @@ yylex (void)\n \n  retry:\n \n-  prev_lexptr = lexptr;\n+  pstate->prev_lexptr = pstate->lexptr;\n \n-  tokstart = lexptr;\n-  explen = strlen (lexptr);\n+  tokstart = pstate->lexptr;\n+  explen = strlen (pstate->lexptr);\n \n   /* See if it is a special token of length 3.  */\n   if (explen > 2)\n@@ -1141,7 +1141,7 @@ yylex (void)\n               || (!isalpha (tokstart[3])\n \t\t  && !isdigit (tokstart[3]) && tokstart[3] != '_')))\n         {\n-          lexptr += 3;\n+          pstate->lexptr += 3;\n           yylval.opcode = tokentab3[i].opcode;\n           return tokentab3[i].token;\n         }\n@@ -1154,7 +1154,7 @@ yylex (void)\n               || (!isalpha (tokstart[2])\n \t\t  && !isdigit (tokstart[2]) && tokstart[2] != '_')))\n         {\n-          lexptr += 2;\n+          pstate->lexptr += 2;\n           yylval.opcode = tokentab2[i].opcode;\n           return tokentab2[i].token;\n         }\n@@ -1170,31 +1170,31 @@ yylex (void)\n     case ' ':\n     case '\\t':\n     case '\\n':\n-      lexptr++;\n+      pstate->lexptr++;\n       goto retry;\n \n     case '\\'':\n       /* We either have a character constant ('0' or '\\177' for example)\n \t or we have a quoted symbol reference ('foo(int,int)' in object pascal\n \t for example).  */\n-      lexptr++;\n-      c = *lexptr++;\n+      pstate->lexptr++;\n+      c = *pstate->lexptr++;\n       if (c == '\\\\')\n-\tc = parse_escape (pstate->gdbarch (), &lexptr);\n+\tc = parse_escape (pstate->gdbarch (), &pstate->lexptr);\n       else if (c == '\\'')\n \terror (_(\"Empty character constant.\"));\n \n       yylval.typed_val_int.val = c;\n       yylval.typed_val_int.type = parse_type (pstate)->builtin_char;\n \n-      c = *lexptr++;\n+      c = *pstate->lexptr++;\n       if (c != '\\'')\n \t{\n \t  namelen = skip_quoted (tokstart) - tokstart;\n \t  if (namelen > 2)\n \t    {\n-\t      lexptr = tokstart + namelen;\n-\t      if (lexptr[-1] != '\\'')\n+\t      pstate->lexptr = tokstart + namelen;\n+\t      if (pstate->lexptr[-1] != '\\'')\n \t\terror (_(\"Unmatched single quote.\"));\n \t      namelen -= 2;\n               tokstart++;\n@@ -1207,25 +1207,25 @@ yylex (void)\n \n     case '(':\n       paren_depth++;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case ')':\n       if (paren_depth == 0)\n \treturn 0;\n       paren_depth--;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case ',':\n       if (pstate->comma_terminates && paren_depth == 0)\n \treturn 0;\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case '.':\n       /* Might be a floating point number.  */\n-      if (lexptr[1] < '0' || lexptr[1] > '9')\n+      if (pstate->lexptr[1] < '0' || pstate->lexptr[1] > '9')\n \t{\n \t  goto symbol;\t\t/* Nope, must be a symbol.  */\n \t}\n@@ -1293,7 +1293,7 @@ yylex (void)\n \t    err_copy[p - tokstart] = 0;\n \t    error (_(\"Invalid number \\\"%s\\\".\"), err_copy);\n \t  }\n-\tlexptr = p;\n+\tpstate->lexptr = p;\n \treturn toktype;\n       }\n \n@@ -1317,7 +1317,7 @@ yylex (void)\n     case '{':\n     case '}':\n     symbol:\n-      lexptr++;\n+      pstate->lexptr++;\n       return c;\n \n     case '\"':\n@@ -1369,7 +1369,7 @@ yylex (void)\n       tempbuf[tempbufindex] = '\\0';\t/* See note above.  */\n       yylval.sval.ptr = tempbuf;\n       yylval.sval.length = tempbufindex;\n-      lexptr = tokptr;\n+      pstate->lexptr = tokptr;\n       return (STRING);\n     }\n \n@@ -1420,7 +1420,7 @@ yylex (void)\n       return 0;\n     }\n \n-  lexptr += namelen;\n+  pstate->lexptr += namelen;\n \n   tryname:\n \n@@ -1616,7 +1616,7 @@ yylex (void)\n \t     us whether a type is nested), we just ignore the\n \t     containing type.  */\n \n-\t  p = lexptr;\n+\t  p = pstate->lexptr;\n \t  best_sym = sym;\n \t  while (1)\n \t    {\n@@ -1661,7 +1661,7 @@ yylex (void)\n \t\t\t  if (SYMBOL_CLASS (cur_sym) == LOC_TYPEDEF)\n \t\t\t    {\n \t\t\t      best_sym = cur_sym;\n-\t\t\t      lexptr = p;\n+\t\t\t      pstate->lexptr = p;\n \t\t\t    }\n \t\t\t  else\n \t\t\t    break;\n@@ -1734,8 +1734,8 @@ pascal_parse (struct parser_state *par_state)\n static void\n yyerror (const char *msg)\n {\n-  if (prev_lexptr)\n-    lexptr = prev_lexptr;\n+  if (pstate->prev_lexptr)\n+    pstate->lexptr = pstate->prev_lexptr;\n \n-  error (_(\"A %s in expression, near `%s'.\"), msg, lexptr);\n+  error (_(\"A %s in expression, near `%s'.\"), msg, pstate->lexptr);\n }"
    },
    {
      "sha": "5692e23386be87317354f55070cd492e535285e7",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 3,
      "deletions": 8,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -69,8 +69,6 @@ const struct exp_descriptor exp_descriptor_standard =\n innermost_block_tracker innermost_block;\n int arglist_len;\n static struct type_stack type_stack;\n-const char *lexptr;\n-const char *prev_lexptr;\n \n /* True if parsing an expression to attempt completion.  */\n int parse_completion;\n@@ -1112,16 +1110,13 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n   const struct language_defn *lang = NULL;\n   int subexp;\n \n-  lexptr = *stringptr;\n-  prev_lexptr = NULL;\n-\n   type_stack.elements.clear ();\n   expout_last_struct = -1;\n   expout_tag_completion_type = TYPE_CODE_UNDEF;\n   expout_completion_name.reset ();\n   innermost_block.reset (tracker_types);\n \n-  if (lexptr == 0 || *lexptr == 0)\n+  if (*stringptr == 0 || **stringptr == 0)\n     error_no_arg (_(\"expression to compute\"));\n \n   std::vector<int> funcalls;\n@@ -1184,7 +1179,7 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n      to the value matching SELECTED_FRAME as set by get_current_arch.  */\n \n   parser_state ps (lang, get_current_arch (), expression_context_block,\n-\t\t   expression_context_pc, comma);\n+\t\t   expression_context_pc, comma, *stringptr);\n \n   scoped_restore_current_language lang_saver;\n   set_language (lang->la_language);\n@@ -1223,7 +1218,7 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n   if (expressiondebug)\n     dump_prefix_expression (result.get (), gdb_stdlog);\n \n-  *stringptr = lexptr;\n+  *stringptr = ps.lexptr;\n   return result;\n }\n "
    },
    {
      "sha": "66828e0f772fb081d6c961280c24e02cb10a3b2d",
      "filename": "gdb/parser-defs.h",
      "status": "modified",
      "additions": 13,
      "deletions": 11,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/parser-defs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/parser-defs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parser-defs.h?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -89,11 +89,13 @@ struct parser_state : public expr_builder\n \t\tstruct gdbarch *gdbarch,\n \t\tconst struct block *context_block,\n \t\tCORE_ADDR context_pc,\n-\t\tint comma)\n+\t\tint comma,\n+\t\tconst char *input)\n     : expr_builder (lang, gdbarch),\n       expression_context_block (context_block),\n       expression_context_pc (context_pc),\n-      comma_terminates (comma)\n+      comma_terminates (comma),\n+      lexptr (input)\n   {\n   }\n \n@@ -114,6 +116,15 @@ struct parser_state : public expr_builder\n   /* Nonzero means stop parsing on first comma (if not within parentheses).  */\n \n   int comma_terminates;\n+\n+  /* During parsing of a C expression, the pointer to the next character\n+     is in this variable.  */\n+\n+  const char *lexptr;\n+\n+  /* After a token has been recognized, this variable points to it.\n+     Currently used only for error reporting.  */\n+  const char *prev_lexptr = nullptr;\n };\n \n /* When parsing expressions we track the innermost block that was\n@@ -352,15 +363,6 @@ extern void null_post_parser (expression_up *, int);\n \n extern bool parse_float (const char *p, int len,\n \t\t\t const struct type *type, gdb_byte *data);\n-\n-/* During parsing of a C expression, the pointer to the next character\n-   is in this variable.  */\n-\n-extern const char *lexptr;\n-\n-/* After a token has been recognized, this variable points to it.\n-   Currently used only for error reporting.  */\n-extern const char *prev_lexptr;\n \f\n /* These codes indicate operator precedences for expression printing,\n    least tightly binding first.  */"
    },
    {
      "sha": "782117e93e2b243021f6ac45b3ee284832799174",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 130,
      "deletions": 118,
      "changes": 248,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5776fca307b8af3d852525b77e9b917a9aa97370/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=5776fca307b8af3d852525b77e9b917a9aa97370",
      "patch": "@@ -117,7 +117,6 @@ struct rust_parser;\n static int rustyylex (YYSTYPE *, rust_parser *);\n static void rustyyerror (rust_parser *parser, const char *msg);\n \n-static void rust_push_back (char c);\n static struct stoken make_stoken (const char *);\n static struct block_symbol rust_lookup_symbol (const char *name,\n \t\t\t\t\t       const struct block *block,\n@@ -237,6 +236,10 @@ struct rust_parser\n   int lex_number (YYSTYPE *lvalp);\n   int lex_string (YYSTYPE *lvalp);\n   int lex_identifier (YYSTYPE *lvalp);\n+  uint32_t lex_hex (int min, int max);\n+  uint32_t lex_escape (int is_byte);\n+  int lex_operator (YYSTYPE *lvalp);\n+  void push_back (char c);\n \n   struct type *rust_lookup_type (const char *name, const struct block *block);\n   std::vector<struct type *> convert_params_to_types (rust_op_vector *params);\n@@ -855,7 +858,7 @@ identifier_path_for_expr:\n |\tidentifier_path_for_expr COLONCOLON '<' type_list RSH\n \t\t{\n \t\t  $$ = parser->ast_path ($1->left.sval, $4);\n-\t\t  rust_push_back ('>');\n+\t\t  parser->push_back ('>');\n \t\t}\n ;\n \n@@ -898,7 +901,7 @@ identifier_path_for_type:\n |\tjust_identifiers_for_type '<' type_list RSH\n \t\t{\n \t\t  $$ = parser->ast_path ($1->left.sval, $3);\n-\t\t  rust_push_back ('>');\n+\t\t  parser->push_back ('>');\n \t\t}\n ;\n \n@@ -1111,27 +1114,27 @@ update_innermost_block (struct block_symbol sym)\n /* Lex a hex number with at least MIN digits and at most MAX\n    digits.  */\n \n-static uint32_t\n-lex_hex (int min, int max)\n+uint32_t\n+rust_parser::lex_hex (int min, int max)\n {\n   uint32_t result = 0;\n   int len = 0;\n   /* We only want to stop at MAX if we're lexing a byte escape.  */\n   int check_max = min == max;\n \n   while ((check_max ? len <= max : 1)\n-\t && ((lexptr[0] >= 'a' && lexptr[0] <= 'f')\n-\t     || (lexptr[0] >= 'A' && lexptr[0] <= 'F')\n-\t     || (lexptr[0] >= '0' && lexptr[0] <= '9')))\n+\t && ((pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'f')\n+\t     || (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'F')\n+\t     || (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9')))\n     {\n       result *= 16;\n-      if (lexptr[0] >= 'a' && lexptr[0] <= 'f')\n-\tresult = result + 10 + lexptr[0] - 'a';\n-      else if (lexptr[0] >= 'A' && lexptr[0] <= 'F')\n-\tresult = result + 10 + lexptr[0] - 'A';\n+      if (pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'f')\n+\tresult = result + 10 + pstate->lexptr[0] - 'a';\n+      else if (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'F')\n+\tresult = result + 10 + pstate->lexptr[0] - 'A';\n       else\n-\tresult = result + lexptr[0] - '0';\n-      ++lexptr;\n+\tresult = result + pstate->lexptr[0] - '0';\n+      ++pstate->lexptr;\n       ++len;\n     }\n \n@@ -1149,65 +1152,65 @@ lex_hex (int min, int max)\n /* Lex an escape.  IS_BYTE is true if we're lexing a byte escape;\n    otherwise we're lexing a character escape.  */\n \n-static uint32_t\n-lex_escape (int is_byte)\n+uint32_t\n+rust_parser::lex_escape (int is_byte)\n {\n   uint32_t result;\n \n-  gdb_assert (lexptr[0] == '\\\\');\n-  ++lexptr;\n-  switch (lexptr[0])\n+  gdb_assert (pstate->lexptr[0] == '\\\\');\n+  ++pstate->lexptr;\n+  switch (pstate->lexptr[0])\n     {\n     case 'x':\n-      ++lexptr;\n+      ++pstate->lexptr;\n       result = lex_hex (2, 2);\n       break;\n \n     case 'u':\n       if (is_byte)\n \terror (_(\"Unicode escape in byte literal\"));\n-      ++lexptr;\n-      if (lexptr[0] != '{')\n+      ++pstate->lexptr;\n+      if (pstate->lexptr[0] != '{')\n \terror (_(\"Missing '{' in Unicode escape\"));\n-      ++lexptr;\n+      ++pstate->lexptr;\n       result = lex_hex (1, 6);\n       /* Could do range checks here.  */\n-      if (lexptr[0] != '}')\n+      if (pstate->lexptr[0] != '}')\n \terror (_(\"Missing '}' in Unicode escape\"));\n-      ++lexptr;\n+      ++pstate->lexptr;\n       break;\n \n     case 'n':\n       result = '\\n';\n-      ++lexptr;\n+      ++pstate->lexptr;\n       break;\n     case 'r':\n       result = '\\r';\n-      ++lexptr;\n+      ++pstate->lexptr;\n       break;\n     case 't':\n       result = '\\t';\n-      ++lexptr;\n+      ++pstate->lexptr;\n       break;\n     case '\\\\':\n       result = '\\\\';\n-      ++lexptr;\n+      ++pstate->lexptr;\n       break;\n     case '0':\n       result = '\\0';\n-      ++lexptr;\n+      ++pstate->lexptr;\n       break;\n     case '\\'':\n       result = '\\'';\n-      ++lexptr;\n+      ++pstate->lexptr;\n       break;\n     case '\"':\n       result = '\"';\n-      ++lexptr;\n+      ++pstate->lexptr;\n       break;\n \n     default:\n-      error (_(\"Invalid escape \\\\%c in literal\"), lexptr[0]);\n+      error (_(\"Invalid escape \\\\%c in literal\"), pstate->lexptr[0]);\n     }\n \n   return result;\n@@ -1221,25 +1224,25 @@ rust_parser::lex_character (YYSTYPE *lvalp)\n   int is_byte = 0;\n   uint32_t value;\n \n-  if (lexptr[0] == 'b')\n+  if (pstate->lexptr[0] == 'b')\n     {\n       is_byte = 1;\n-      ++lexptr;\n+      ++pstate->lexptr;\n     }\n-  gdb_assert (lexptr[0] == '\\'');\n-  ++lexptr;\n+  gdb_assert (pstate->lexptr[0] == '\\'');\n+  ++pstate->lexptr;\n   /* This should handle UTF-8 here.  */\n-  if (lexptr[0] == '\\\\')\n+  if (pstate->lexptr[0] == '\\\\')\n     value = lex_escape (is_byte);\n   else\n     {\n-      value = lexptr[0] & 0xff;\n-      ++lexptr;\n+      value = pstate->lexptr[0] & 0xff;\n+      ++pstate->lexptr;\n     }\n \n-  if (lexptr[0] != '\\'')\n+  if (pstate->lexptr[0] != '\\'')\n     error (_(\"Unterminated character literal\"));\n-  ++lexptr;\n+  ++pstate->lexptr;\n \n   lvalp->typed_val_int.val = value;\n   lvalp->typed_val_int.type = get_type (is_byte ? \"u8\" : \"char\");\n@@ -1285,45 +1288,46 @@ ends_raw_string (const char *str, int n)\n int\n rust_parser::lex_string (YYSTYPE *lvalp)\n {\n-  int is_byte = lexptr[0] == 'b';\n+  int is_byte = pstate->lexptr[0] == 'b';\n   int raw_length;\n \n   if (is_byte)\n-    ++lexptr;\n-  raw_length = starts_raw_string (lexptr);\n-  lexptr += raw_length;\n-  gdb_assert (lexptr[0] == '\"');\n-  ++lexptr;\n+    ++pstate->lexptr;\n+  raw_length = starts_raw_string (pstate->lexptr);\n+  pstate->lexptr += raw_length;\n+  gdb_assert (pstate->lexptr[0] == '\"');\n+  ++pstate->lexptr;\n \n   while (1)\n     {\n       uint32_t value;\n \n       if (raw_length > 0)\n \t{\n-\t  if (lexptr[0] == '\"' && ends_raw_string (lexptr, raw_length - 1))\n+\t  if (pstate->lexptr[0] == '\"' && ends_raw_string (pstate->lexptr,\n+\t\t\t\t\t\t\t   raw_length - 1))\n \t    {\n \t      /* Exit with lexptr pointing after the final \"#\".  */\n-\t      lexptr += raw_length;\n+\t      pstate->lexptr += raw_length;\n \t      break;\n \t    }\n-\t  else if (lexptr[0] == '\\0')\n+\t  else if (pstate->lexptr[0] == '\\0')\n \t    error (_(\"Unexpected EOF in string\"));\n \n-\t  value = lexptr[0] & 0xff;\n+\t  value = pstate->lexptr[0] & 0xff;\n \t  if (is_byte && value > 127)\n \t    error (_(\"Non-ASCII value in raw byte string\"));\n \t  obstack_1grow (&obstack, value);\n \n-\t  ++lexptr;\n+\t  ++pstate->lexptr;\n \t}\n-      else if (lexptr[0] == '\"')\n+      else if (pstate->lexptr[0] == '\"')\n \t{\n \t  /* Make sure to skip the quote.  */\n-\t  ++lexptr;\n+\t  ++pstate->lexptr;\n \t  break;\n \t}\n-      else if (lexptr[0] == '\\\\')\n+      else if (pstate->lexptr[0] == '\\\\')\n \t{\n \t  value = lex_escape (is_byte);\n \n@@ -1334,15 +1338,15 @@ rust_parser::lex_string (YYSTYPE *lvalp)\n \t\t\t\t       sizeof (value), sizeof (value),\n \t\t\t\t       &obstack, translit_none);\n \t}\n-      else if (lexptr[0] == '\\0')\n+      else if (pstate->lexptr[0] == '\\0')\n \terror (_(\"Unexpected EOF in string\"));\n       else\n \t{\n-\t  value = lexptr[0] & 0xff;\n+\t  value = pstate->lexptr[0] & 0xff;\n \t  if (is_byte && value > 127)\n \t    error (_(\"Non-ASCII value in byte string\"));\n \t  obstack_1grow (&obstack, value);\n-\t  ++lexptr;\n+\t  ++pstate->lexptr;\n \t}\n     }\n \n@@ -1382,27 +1386,27 @@ rust_identifier_start_p (char c)\n int\n rust_parser::lex_identifier (YYSTYPE *lvalp)\n {\n-  const char *start = lexptr;\n+  const char *start = pstate->lexptr;\n   unsigned int length;\n   const struct token_info *token;\n   int i;\n-  int is_gdb_var = lexptr[0] == '$';\n+  int is_gdb_var = pstate->lexptr[0] == '$';\n \n-  gdb_assert (rust_identifier_start_p (lexptr[0]));\n+  gdb_assert (rust_identifier_start_p (pstate->lexptr[0]));\n \n-  ++lexptr;\n+  ++pstate->lexptr;\n \n   /* For the time being this doesn't handle Unicode rules.  Non-ASCII\n      identifiers are gated anyway.  */\n-  while ((lexptr[0] >= 'a' && lexptr[0] <= 'z')\n-\t || (lexptr[0] >= 'A' && lexptr[0] <= 'Z')\n-\t || lexptr[0] == '_'\n-\t || (is_gdb_var && lexptr[0] == '$')\n-\t || (lexptr[0] >= '0' && lexptr[0] <= '9'))\n-    ++lexptr;\n+  while ((pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'z')\n+\t || (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'Z')\n+\t || pstate->lexptr[0] == '_'\n+\t || (is_gdb_var && pstate->lexptr[0] == '$')\n+\t || (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9'))\n+    ++pstate->lexptr;\n \n \n-  length = lexptr - start;\n+  length = pstate->lexptr - start;\n   token = NULL;\n   for (i = 0; i < ARRAY_SIZE (identifier_tokens); ++i)\n     {\n@@ -1419,28 +1423,28 @@ rust_parser::lex_identifier (YYSTYPE *lvalp)\n       if (token->value == 0)\n \t{\n \t  /* Leave the terminating token alone.  */\n-\t  lexptr = start;\n+\t  pstate->lexptr = start;\n \t  return 0;\n \t}\n     }\n   else if (token == NULL\n \t   && (strncmp (start, \"thread\", length) == 0\n \t       || strncmp (start, \"task\", length) == 0)\n-\t   && space_then_number (lexptr))\n+\t   && space_then_number (pstate->lexptr))\n     {\n       /* \"task\" or \"thread\" followed by a number terminates the\n \t parse, per gdb rules.  */\n-      lexptr = start;\n+      pstate->lexptr = start;\n       return 0;\n     }\n \n-  if (token == NULL || (parse_completion && lexptr[0] == '\\0'))\n+  if (token == NULL || (parse_completion && pstate->lexptr[0] == '\\0'))\n     lvalp->sval = make_stoken (copy_name (start, length));\n \n-  if (parse_completion && lexptr[0] == '\\0')\n+  if (parse_completion && pstate->lexptr[0] == '\\0')\n     {\n       /* Prevent rustyylex from returning two COMPLETE tokens.  */\n-      prev_lexptr = lexptr;\n+      pstate->prev_lexptr = pstate->lexptr;\n       return COMPLETE;\n     }\n \n@@ -1453,18 +1457,18 @@ rust_parser::lex_identifier (YYSTYPE *lvalp)\n \n /* Lex an operator.  */\n \n-static int\n-lex_operator (YYSTYPE *lvalp)\n+int\n+rust_parser::lex_operator (YYSTYPE *lvalp)\n {\n   const struct token_info *token = NULL;\n   int i;\n \n   for (i = 0; i < ARRAY_SIZE (operator_tokens); ++i)\n     {\n-      if (strncmp (operator_tokens[i].name, lexptr,\n+      if (strncmp (operator_tokens[i].name, pstate->lexptr,\n \t\t   strlen (operator_tokens[i].name)) == 0)\n \t{\n-\t  lexptr += strlen (operator_tokens[i].name);\n+\t  pstate->lexptr += strlen (operator_tokens[i].name);\n \t  token = &operator_tokens[i];\n \t  break;\n \t}\n@@ -1476,7 +1480,7 @@ lex_operator (YYSTYPE *lvalp)\n       return token->value;\n     }\n \n-  return *lexptr++;\n+  return *pstate->lexptr++;\n }\n \n /* Lex a number.  */\n@@ -1495,7 +1499,8 @@ rust_parser::lex_number (YYSTYPE *lvalp)\n   int type_index = -1;\n   int i;\n \n-  match = regexec (&number_regex, lexptr, ARRAY_SIZE (subexps), subexps, 0);\n+  match = regexec (&number_regex, pstate->lexptr, ARRAY_SIZE (subexps),\n+\t\t   subexps, 0);\n   /* Failure means the regexp is broken.  */\n   gdb_assert (match == 0);\n \n@@ -1539,9 +1544,9 @@ rust_parser::lex_number (YYSTYPE *lvalp)\n      a request for a trait method call, not a syntax error involving\n      the floating point number \"23.\".  */\n   gdb_assert (subexps[0].rm_eo > 0);\n-  if (lexptr[subexps[0].rm_eo - 1] == '.')\n+  if (pstate->lexptr[subexps[0].rm_eo - 1] == '.')\n     {\n-      const char *next = skip_spaces (&lexptr[subexps[0].rm_eo]);\n+      const char *next = skip_spaces (&pstate->lexptr[subexps[0].rm_eo]);\n \n       if (rust_identifier_start_p (*next) || *next == '.')\n \t{\n@@ -1559,7 +1564,8 @@ rust_parser::lex_number (YYSTYPE *lvalp)\n   if (type_name == NULL)\n     {\n       gdb_assert (type_index != -1);\n-      type_name_holder = std::string (lexptr + subexps[type_index].rm_so,\n+      type_name_holder = std::string ((pstate->lexptr\n+\t\t\t\t       + subexps[type_index].rm_so),\n \t\t\t\t      (subexps[type_index].rm_eo\n \t\t\t\t       - subexps[type_index].rm_so));\n       type_name = type_name_holder.c_str ();\n@@ -1570,16 +1576,16 @@ rust_parser::lex_number (YYSTYPE *lvalp)\n \n   /* Copy the text of the number and remove the \"_\"s.  */\n   std::string number;\n-  for (i = 0; i < end_index && lexptr[i]; ++i)\n+  for (i = 0; i < end_index && pstate->lexptr[i]; ++i)\n     {\n-      if (lexptr[i] == '_')\n+      if (pstate->lexptr[i] == '_')\n \tcould_be_decimal = 0;\n       else\n-\tnumber.push_back (lexptr[i]);\n+\tnumber.push_back (pstate->lexptr[i]);\n     }\n \n   /* Advance past the match.  */\n-  lexptr += subexps[0].rm_eo;\n+  pstate->lexptr += subexps[0].rm_eo;\n \n   /* Parse the number.  */\n   if (is_integer)\n@@ -1627,18 +1633,22 @@ rust_parser::lex_number (YYSTYPE *lvalp)\n static int\n rustyylex (YYSTYPE *lvalp, rust_parser *parser)\n {\n+  struct parser_state *pstate = parser->pstate;\n+\n   /* Skip all leading whitespace.  */\n-  while (lexptr[0] == ' ' || lexptr[0] == '\\t' || lexptr[0] == '\\r'\n-\t || lexptr[0] == '\\n')\n-    ++lexptr;\n+  while (pstate->lexptr[0] == ' '\n+\t || pstate->lexptr[0] == '\\t'\n+\t || pstate->lexptr[0] == '\\r'\n+\t || pstate->lexptr[0] == '\\n')\n+    ++pstate->lexptr;\n \n   /* If we hit EOF and we're completing, then return COMPLETE -- maybe\n      we're completing an empty string at the end of a field_expr.\n      But, we don't want to return two COMPLETE tokens in a row.  */\n-  if (lexptr[0] == '\\0' && lexptr == prev_lexptr)\n+  if (pstate->lexptr[0] == '\\0' && pstate->lexptr == pstate->prev_lexptr)\n     return 0;\n-  prev_lexptr = lexptr;\n-  if (lexptr[0] == '\\0')\n+  pstate->prev_lexptr = pstate->lexptr;\n+  if (pstate->lexptr[0] == '\\0')\n     {\n       if (parse_completion)\n \t{\n@@ -1648,49 +1658,49 @@ rustyylex (YYSTYPE *lvalp, rust_parser *parser)\n       return 0;\n     }\n \n-  if (lexptr[0] >= '0' && lexptr[0] <= '9')\n+  if (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9')\n     return parser->lex_number (lvalp);\n-  else if (lexptr[0] == 'b' && lexptr[1] == '\\'')\n+  else if (pstate->lexptr[0] == 'b' && pstate->lexptr[1] == '\\'')\n     return parser->lex_character (lvalp);\n-  else if (lexptr[0] == 'b' && lexptr[1] == '\"')\n+  else if (pstate->lexptr[0] == 'b' && pstate->lexptr[1] == '\"')\n     return parser->lex_string (lvalp);\n-  else if (lexptr[0] == 'b' && starts_raw_string (lexptr + 1))\n+  else if (pstate->lexptr[0] == 'b' && starts_raw_string (pstate->lexptr + 1))\n     return parser->lex_string (lvalp);\n-  else if (starts_raw_string (lexptr))\n+  else if (starts_raw_string (pstate->lexptr))\n     return parser->lex_string (lvalp);\n-  else if (rust_identifier_start_p (lexptr[0]))\n+  else if (rust_identifier_start_p (pstate->lexptr[0]))\n     return parser->lex_identifier (lvalp);\n-  else if (lexptr[0] == '\"')\n+  else if (pstate->lexptr[0] == '\"')\n     return parser->lex_string (lvalp);\n-  else if (lexptr[0] == '\\'')\n+  else if (pstate->lexptr[0] == '\\'')\n     return parser->lex_character (lvalp);\n-  else if (lexptr[0] == '}' || lexptr[0] == ']')\n+  else if (pstate->lexptr[0] == '}' || pstate->lexptr[0] == ']')\n     {\n       /* Falls through to lex_operator.  */\n       --parser->paren_depth;\n     }\n-  else if (lexptr[0] == '(' || lexptr[0] == '{')\n+  else if (pstate->lexptr[0] == '(' || pstate->lexptr[0] == '{')\n     {\n       /* Falls through to lex_operator.  */\n       ++parser->paren_depth;\n     }\n-  else if (lexptr[0] == ',' && parser->pstate->comma_terminates\n+  else if (pstate->lexptr[0] == ',' && pstate->comma_terminates\n \t   && parser->paren_depth == 0)\n     return 0;\n \n-  return lex_operator (lvalp);\n+  return parser->lex_operator (lvalp);\n }\n \n /* Push back a single character to be re-lexed.  */\n \n-static void\n-rust_push_back (char c)\n+void\n+rust_parser::push_back (char c)\n {\n   /* Can't be called before any lexing.  */\n-  gdb_assert (prev_lexptr != NULL);\n+  gdb_assert (pstate->prev_lexptr != NULL);\n \n-  --lexptr;\n-  gdb_assert (*lexptr == c);\n+  --pstate->lexptr;\n+  gdb_assert (*pstate->lexptr == c);\n }\n \n \f\n@@ -2545,7 +2555,9 @@ rust_parse (struct parser_state *state)\n static void\n rustyyerror (rust_parser *parser, const char *msg)\n {\n-  const char *where = prev_lexptr ? prev_lexptr : lexptr;\n+  const char *where = (parser->pstate->prev_lexptr\n+\t\t       ? parser->pstate->prev_lexptr\n+\t\t       : parser->pstate->lexptr);\n   error (_(\"%s in expression, near `%s'.\"), msg, where);\n }\n \n@@ -2558,8 +2570,8 @@ rustyyerror (rust_parser *parser, const char *msg)\n static void\n rust_lex_test_init (rust_parser *parser, const char *input)\n {\n-  prev_lexptr = NULL;\n-  lexptr = input;\n+  parser->pstate->prev_lexptr = NULL;\n+  parser->pstate->lexptr = input;\n   parser->paren_depth = 0;\n }\n \n@@ -2635,7 +2647,7 @@ rust_lex_test_sequence (rust_parser *parser, const char *input, int len,\n {\n   int i;\n \n-  lexptr = input;\n+  parser->pstate->lexptr = input;\n   parser->paren_depth = 0;\n \n   for (i = 0; i < len; ++i)\n@@ -2696,7 +2708,7 @@ rust_lex_test_push_back (rust_parser *parser)\n   SELF_CHECK (token == COMPOUND_ASSIGN);\n   SELF_CHECK (lval.opcode == BINOP_RSH);\n \n-  rust_push_back ('=');\n+  parser->push_back ('=');\n \n   token = rustyylex (&lval, parser);\n   SELF_CHECK (token == '=');\n@@ -2714,7 +2726,7 @@ rust_lex_tests (void)\n \n   // Set up dummy \"parser\", so that rust_type works.\n   struct parser_state ps (&rust_language_defn, target_gdbarch (),\n-\t\t\t  nullptr, 0, 0);\n+\t\t\t  nullptr, 0, 0, nullptr);\n   rust_parser parser (&ps);\n \n   rust_lex_test_one (&parser, \"\", 0);"
    }
  ]
}