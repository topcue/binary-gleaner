{
  "sha": "0958441403b92163dff851f0a78241c7fcb4e8eb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDk1ODQ0MTQwM2I5MjE2M2RmZjg1MWYwYTc4MjQxYzdmY2I0ZThlYg==",
  "commit": {
    "author": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2020-11-15T08:12:52Z"
    },
    "committer": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2020-11-15T08:12:52Z"
    },
    "message": "Add support for printing value of DWARF-based fixed-point type objects\n\nThis commit introduces a new kind of type, meant to describe\nfixed-point types, using a new code added specifically for\nthis purpose (TYPE_CODE_FIXED_POINT).\n\nIt then adds handling of fixed-point base types in the DWARF reader.\n\nAnd finally, as a first step, this commit adds support for printing\nthe value of fixed-point type objects.\n\nNote that this commit has a known issue: Trying to print the value\nof a fixed-point object with a format letter (e.g. \"print /x NAME\")\ncauses the wrong value to be printed because the scaling factor\nis not applied. Since the fix for this issue is isolated, and\nthis is not a regression, the fix will be made in a pach of its own.\nThis is meant to simplify review and archeology.\n\nAlso, other functionalities related to fixed-point type handling\n(ptype, arithmetics, etc), will be added piecemeal as well, for\nthe same reasons (faciliate reviews and archeology). Related to this,\nthe testcase gdb.ada/fixed_cmp.exp is adjusted to compile the test\nprogram with -fgnat-encodings=all, so as to force the use of GNAT\nencodings, rather than rely on the compiler's default to use them.\nThe intent is to enhance this testcase to also test the pure DWARF\napproach using -fgnat-encodings=minimal as soon as the corresponding\nsuport gets added in. Thus, the modification to the testcase is made\nin a way that it prepares this testcase to be tested in both modes.\n\ngdb/ChangeLog:\n\n        * ada-valprint.c (ada_value_print_1): Add fixed-point type handling.\n        * dwarf2/read.c (get_dwarf2_rational_constant)\n        (get_dwarf2_unsigned_rational_constant, finish_fixed_point_type)\n        (has_zero_over_zero_small_attribute): New functions.\n        read_base_type, set_die_type): Add fixed-point type handling.\n        * gdb-gdb.py.in: Add fixed-point type handling.\n        * gdbtypes.c: #include \"gmp-utils.h\".\n        (create_range_type, set_type_code): Add fixed-point type handling.\n        (init_fixed_point_type): New function.\n        (is_integral_type, is_scalar_type): Add fixed-point type handling.\n        (print_fixed_point_type_info): New function.\n        (recursive_dump_type, copy_type_recursive): Add fixed-point type\n        handling.\n        (fixed_point_type_storage): New typedef.\n        (fixed_point_objfile_key): New static global.\n        (allocate_fixed_point_type_info, is_fixed_point_type): New functions.\n        (fixed_point_type_base_type, fixed_point_scaling_factor): New\n        functions.\n        * gdbtypes.h: #include \"gmp-utils.h\".\n        (enum type_code) <TYPE_SPECIFIC_FIXED_POINT>: New enum.\n        (union type_specific) <fixed_point_info>: New field.\n        (struct fixed_point_type_info): New struct.\n        (INIT_FIXED_POINT_SPECIFIC, TYPE_FIXED_POINT_INFO): New macros.\n        (init_fixed_point_type, is_fixed_point_type)\n        (fixed_point_type_base_type, fixed_point_scaling_factor)\n        (allocate_fixed_point_type_info): Add declarations.\n        * valprint.c (generic_val_print_fixed_point): New function.\n        (generic_value_print): Add fixed-point type handling.\n        * value.c (value_as_address, unpack_long): Add fixed-point type\n        handling.\n\ngdb/testsuite/ChangeLog:\n\n        * gdb.ada/fixed_cmp.exp: Force compilation to use -fgnat-encodings=all.\n        * gdb.ada/fixed_points.exp: Add fixed-point variables printing tests.\n        * gdb.ada/fixed_points/pck.ads, gdb.ada/fixed_points/pck.adb:\n        New files.\n        * gdb.ada/fixed_points/fixed_points.adb: Add use of package Pck.\n\n        * gdb.dwarf2/dw2-fixed-point.c, gdb.dwarf2/dw2-fixed-point.exp:\n        New files.",
    "tree": {
      "sha": "d5e81a519e48f52e665f16ddc8a15cc378e45a7f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d5e81a519e48f52e665f16ddc8a15cc378e45a7f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0958441403b92163dff851f0a78241c7fcb4e8eb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0958441403b92163dff851f0a78241c7fcb4e8eb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0958441403b92163dff851f0a78241c7fcb4e8eb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0958441403b92163dff851f0a78241c7fcb4e8eb/comments",
  "author": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e55c6530dbf96bfbe2e4a232c0feb19c0a4a2294",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e55c6530dbf96bfbe2e4a232c0feb19c0a4a2294",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e55c6530dbf96bfbe2e4a232c0feb19c0a4a2294"
    }
  ],
  "stats": {
    "total": 778,
    "additions": 760,
    "deletions": 18
  },
  "files": [
    {
      "sha": "16905ac636d0c36bd34c96244fa719bbe5ce7d80",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -1,3 +1,36 @@\n+2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n+\n+\t* ada-valprint.c (ada_value_print_1): Add fixed-point type handling.\n+\t* dwarf2/read.c (get_dwarf2_rational_constant)\n+\t(get_dwarf2_unsigned_rational_constant, finish_fixed_point_type)\n+\t(has_zero_over_zero_small_attribute): New functions.\n+\tread_base_type, set_die_type): Add fixed-point type handling.\n+\t* gdb-gdb.py.in: Add fixed-point type handling.\n+\t* gdbtypes.c: #include \"gmp-utils.h\".\n+\t(create_range_type, set_type_code): Add fixed-point type handling.\n+\t(init_fixed_point_type): New function.\n+\t(is_integral_type, is_scalar_type): Add fixed-point type handling.\n+\t(print_fixed_point_type_info): New function.\n+\t(recursive_dump_type, copy_type_recursive): Add fixed-point type\n+\thandling.\n+\t(fixed_point_type_storage): New typedef.\n+\t(fixed_point_objfile_key): New static global.\n+\t(allocate_fixed_point_type_info, is_fixed_point_type): New functions.\n+\t(fixed_point_type_base_type, fixed_point_scaling_factor): New\n+\tfunctions.\n+\t* gdbtypes.h: #include \"gmp-utils.h\".\n+\t(enum type_code) <TYPE_SPECIFIC_FIXED_POINT>: New enum.\n+\t(union type_specific) <fixed_point_info>: New field.\n+\t(struct fixed_point_type_info): New struct.\n+\t(INIT_FIXED_POINT_SPECIFIC, TYPE_FIXED_POINT_INFO): New macros.\n+\t(init_fixed_point_type, is_fixed_point_type)\n+\t(fixed_point_type_base_type, fixed_point_scaling_factor)\n+\t(allocate_fixed_point_type_info): Add declarations.\n+\t* valprint.c (generic_val_print_fixed_point): New function.\n+\t(generic_value_print): Add fixed-point type handling.\n+\t* value.c (value_as_address, unpack_long): Add fixed-point type\n+\thandling.\n+\n 2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n \n \t* utils.h (uinteger_pow): Add declaration."
    },
    {
      "sha": "482069a3fb2124168e8c7f436805f254a8be4157",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -1027,6 +1027,9 @@ ada_value_print_1 (struct value *val, struct ui_file *stream, int recurse,\n       deprecated_set_value_type (val, type);\n     }\n \n+  if (is_fixed_point_type (type))\n+    type = fixed_point_type_base_type (type);\n+\n   switch (type->code ())\n     {\n     default:"
    },
    {
      "sha": "3c598262913fa7044e5b42cec096791d9a0fc672",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 211,
      "deletions": 0,
      "changes": 211,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -18092,6 +18092,157 @@ read_typedef (struct die_info *die, struct dwarf2_cu *cu)\n   return this_type;\n }\n \n+/* Assuming DIE is a rational DW_TAG_constant, read the DIE's\n+   numerator and denominator into NUMERATOR and DENOMINATOR (resp).\n+\n+   If the numerator and/or numerator attribute is missing,\n+   a complaint is filed, and NUMERATOR and DENOMINATOR are left\n+   untouched.  */\n+\n+static void\n+get_dwarf2_rational_constant (struct die_info *die, struct dwarf2_cu *cu,\n+\t\t\t      LONGEST *numerator, LONGEST *denominator)\n+{\n+  struct attribute *num_attr, *denom_attr;\n+\n+  num_attr = dwarf2_attr (die, DW_AT_GNU_numerator, cu);\n+  if (num_attr == nullptr)\n+    complaint (_(\"DW_AT_GNU_numerator missing in %s DIE at %s\"),\n+\t       dwarf_tag_name (die->tag), sect_offset_str (die->sect_off));\n+\n+  denom_attr = dwarf2_attr (die, DW_AT_GNU_denominator, cu);\n+  if (denom_attr == nullptr)\n+    complaint (_(\"DW_AT_GNU_denominator missing in %s DIE at %s\"),\n+\t       dwarf_tag_name (die->tag), sect_offset_str (die->sect_off));\n+\n+  if (num_attr == nullptr || denom_attr == nullptr)\n+    return;\n+\n+  *numerator = num_attr->constant_value (1);\n+  *denominator = denom_attr->constant_value (1);\n+}\n+\n+/* Same as get_dwarf2_rational_constant, but extracting an unsigned\n+   rational constant, rather than a signed one.\n+\n+   If the rational constant has a negative value, a complaint\n+   is filed, and NUMERATOR and DENOMINATOR are left untouched.  */\n+\n+static void\n+get_dwarf2_unsigned_rational_constant (struct die_info *die,\n+\t\t\t\t       struct dwarf2_cu *cu,\n+\t\t\t\t       ULONGEST *numerator,\n+\t\t\t\t       ULONGEST *denominator)\n+{\n+  LONGEST num = 1, denom = 1;\n+\n+  get_dwarf2_rational_constant (die, cu, &num, &denom);\n+  if (num < 0 && denom < 0)\n+    {\n+      num = -num;\n+      denom = -denom;\n+    }\n+  else if (num < 0)\n+    {\n+      complaint (_(\"unexpected negative value for DW_AT_GNU_numerator\"\n+\t\t   \" in DIE at %s\"),\n+\t\t sect_offset_str (die->sect_off));\n+      return;\n+    }\n+  else if (denom < 0)\n+    {\n+      complaint (_(\"unexpected negative value for DW_AT_GNU_denominator\"\n+\t\t   \" in DIE at %s\"),\n+\t\t sect_offset_str (die->sect_off));\n+      return;\n+    }\n+\n+  *numerator = num;\n+  *denominator = denom;\n+}\n+\n+/* Assuming DIE corresponds to a fixed point type, finish the creation\n+   of the corresponding TYPE by setting its TYPE_FIXED_POINT_INFO.\n+   CU is the DIE's CU.  */\n+\n+static void\n+finish_fixed_point_type (struct type *type, struct die_info *die,\n+\t\t\t struct dwarf2_cu *cu)\n+{\n+  struct attribute *attr;\n+  /* Numerator and denominator of our fixed-point type's scaling factor.\n+     The default is a scaling factor of 1, which we use as a fallback\n+     when we are not able to decode it (problem with the debugging info,\n+     unsupported forms, bug in GDB, etc...).  Using that as the default\n+     allows us to at least print the unscaled value, which might still\n+     be useful to a user.  */\n+  ULONGEST scale_num = 1;\n+  ULONGEST scale_denom = 1;\n+\n+  gdb_assert (type->code () == TYPE_CODE_FIXED_POINT\n+\t      && TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_FIXED_POINT);\n+\n+  attr = dwarf2_attr (die, DW_AT_binary_scale, cu);\n+  if (!attr)\n+    attr = dwarf2_attr (die, DW_AT_decimal_scale, cu);\n+  if (!attr)\n+    attr = dwarf2_attr (die, DW_AT_small, cu);\n+\n+  if (attr == nullptr)\n+    {\n+      /* Scaling factor not found.  Assume a scaling factor of 1,\n+\t and hope for the best.  At least the user will be able to see\n+\t the encoded value.  */\n+      complaint (_(\"no scale found for fixed-point type (DIE at %s)\"),\n+\t\t sect_offset_str (die->sect_off));\n+    }\n+  else if (attr->name == DW_AT_binary_scale)\n+    {\n+      LONGEST scale_exp = attr->constant_value (0);\n+      ULONGEST *num_or_denom = scale_exp > 0 ? &scale_num : &scale_denom;\n+\n+      *num_or_denom = 1 << abs (scale_exp);\n+    }\n+  else if (attr->name == DW_AT_decimal_scale)\n+    {\n+      LONGEST scale_exp = attr->constant_value (0);\n+      ULONGEST *num_or_denom = scale_exp > 0 ? &scale_num : &scale_denom;\n+\n+      *num_or_denom = uinteger_pow (10, abs (scale_exp));\n+    }\n+  else if (attr->name == DW_AT_small)\n+    {\n+      struct die_info *scale_die;\n+      struct dwarf2_cu *scale_cu = cu;\n+\n+      scale_die = follow_die_ref (die, attr, &scale_cu);\n+      if (scale_die->tag == DW_TAG_constant)\n+\tget_dwarf2_unsigned_rational_constant (scale_die, scale_cu,\n+\t\t\t\t\t       &scale_num, &scale_denom);\n+      else\n+\tcomplaint (_(\"%s DIE not supported as target of DW_AT_small attribute\"\n+\t\t     \" (DIE at %s)\"),\n+\t\t   dwarf_tag_name (die->tag), sect_offset_str (die->sect_off));\n+    }\n+  else\n+    {\n+      complaint (_(\"unsupported scale attribute %s for fixed-point type\"\n+\t\t   \" (DIE at %s)\"),\n+\t\t dwarf_attr_name (attr->name),\n+\t\t sect_offset_str (die->sect_off));\n+    }\n+\n+  gdb_mpq &scaling_factor = TYPE_FIXED_POINT_INFO (type)->scaling_factor;\n+\n+  gdb_mpz tmp_z (scale_num);\n+  mpz_set (mpq_numref (scaling_factor.val), tmp_z.val);\n+\n+  tmp_z = scale_denom;\n+  mpz_set (mpq_denref (scaling_factor.val), tmp_z.val);\n+\n+  mpq_canonicalize (scaling_factor.val);\n+}\n+\n /* Allocate a floating-point type of size BITS and name NAME.  Pass NAME_HINT\n    (which may be different from NAME) to the architecture back-end to allow\n    it to guess the correct format if necessary.  */\n@@ -18133,6 +18284,32 @@ dwarf2_init_integer_type (struct dwarf2_cu *cu, struct objfile *objfile,\n   return type;\n }\n \n+/* Return true if DIE has a DW_AT_small attribute whose value is\n+   a constant rational, where both the numerator and denominator\n+   are equal to zero.\n+\n+   CU is the DIE's Compilation Unit.  */\n+\n+static bool\n+has_zero_over_zero_small_attribute (struct die_info *die,\n+\t\t\t\t    struct dwarf2_cu *cu)\n+{\n+  struct attribute *attr = dwarf2_attr (die, DW_AT_small, cu);\n+  if (attr == nullptr)\n+    return false;\n+\n+  struct dwarf2_cu *scale_cu = cu;\n+  struct die_info *scale_die\n+    = follow_die_ref (die, attr, &scale_cu);\n+\n+  if (scale_die->tag != DW_TAG_constant)\n+    return false;\n+\n+  LONGEST num = 1, denom = 1;\n+  get_dwarf2_rational_constant (scale_die, cu, &num, &denom);\n+  return (num == 0 && denom == 0);\n+}\n+\n /* Initialise and return a floating point type of size BITS suitable for\n    use as a component of a complex number.  The NAME_HINT is passed through\n    when initialising the floating point type and is the name of the complex\n@@ -18243,6 +18420,31 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n \t}\n     }\n \n+  if ((encoding == DW_ATE_signed_fixed || encoding == DW_ATE_unsigned_fixed)\n+      && cu->language == language_ada\n+      && has_zero_over_zero_small_attribute (die, cu))\n+    {\n+      /* brobecker/2018-02-24: This is a fixed point type for which\n+\t the scaling factor is represented as fraction whose value\n+\t does not make sense (zero divided by zero), so we should\n+\t normally never see these.  However, there is a small category\n+\t of fixed point types for which GNAT is unable to provide\n+\t the scaling factor via the standard DWARF mechanisms, and\n+\t for which the info is provided via the GNAT encodings instead.\n+\t This is likely what this DIE is about.\n+\n+\t Ideally, GNAT should be declaring this type the same way\n+\t it declares other fixed point types when using the legacy\n+\t GNAT encoding, which is to use a simple signed or unsigned\n+\t base type.  A report to the GNAT team has been created to\n+\t look into it.  In the meantime, pretend this type is a simple\n+\t signed or unsigned integral, rather than a fixed point type,\n+\t to avoid any confusion later on as to how to process this type.  */\n+      encoding = (encoding == DW_ATE_signed_fixed\n+\t\t  ? DW_ATE_signed\n+\t\t  : DW_ATE_unsigned);\n+    }\n+\n   switch (encoding)\n     {\n       case DW_ATE_address:\n@@ -18319,6 +18521,14 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n \t  return set_die_type (die, type, cu);\n \t}\n \tbreak;\n+      case DW_ATE_signed_fixed:\n+\ttype = init_fixed_point_type (objfile, bits, 0, name);\n+\tfinish_fixed_point_type (type, die, cu);\n+\tbreak;\n+      case DW_ATE_unsigned_fixed:\n+\ttype = init_fixed_point_type (objfile, bits, 1, name);\n+\tfinish_fixed_point_type (type, die, cu);\n+\tbreak;\n \n       default:\n \tcomplaint (_(\"unsupported DW_AT_encoding: '%s'\"),\n@@ -24751,6 +24961,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n       && type->code () != TYPE_CODE_METHODPTR\n       && type->code () != TYPE_CODE_MEMBERPTR\n       && type->code () != TYPE_CODE_METHOD\n+      && type->code () != TYPE_CODE_FIXED_POINT\n       && !HAVE_GNAT_AUX_INFO (type))\n     INIT_GNAT_SPECIFIC (type);\n "
    },
    {
      "sha": "ff68bd71a682296a1bc4d5018c9b627c7f8bd0ae",
      "filename": "gdb/gdb-gdb.py.in",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/gdb-gdb.py.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/gdb-gdb.py.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdb-gdb.py.in?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -229,6 +229,11 @@ class StructMainTypePrettyPrinter:\n             # tail_call_list is not printed.\n         elif type_specific_kind == \"TYPE_SPECIFIC_SELF_TYPE\":\n             img = \"self_type = %s\" % type_specific['self_type']\n+        elif type_specific_kind == \"TYPE_SPECIFIC_FIXED_POINT\":\n+            # The scaling factor is an opaque structure, so we cannot\n+            # decode its value from Python (not without insider knowledge).\n+            img = ('scaling_factor: <opaque> (call __gmpz_dump with '\n+                   ' _mp_num and _mp_den fields if needed)')\n         else:\n             img = (\"type_specific = ??? (unknown type_secific_kind: %s)\"\n                    % type_specific_kind)"
    },
    {
      "sha": "2f92887b3cfcd81c554ac0fa10f9de7c1cc95ce0",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 132,
      "deletions": 1,
      "changes": 133,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -40,6 +40,7 @@\n #include \"gdbcore.h\"\n #include \"floatformat.h\"\n #include <algorithm>\n+#include \"gmp-utils.h\"\n \n /* Initialize BADNESS constants.  */\n \n@@ -950,14 +951,16 @@ create_range_type (struct type *result_type, struct type *index_type,\n \n   result_type->set_bounds (bounds);\n \n+  if (index_type->code () == TYPE_CODE_FIXED_POINT)\n+    result_type->set_is_unsigned (index_type->is_unsigned ());\n   /* Note that the signed-ness of a range type can't simply be copied\n      from the underlying type.  Consider a case where the underlying\n      type is 'int', but the range type can hold 0..65535, and where\n      the range is further specified to fit into 16 bits.  In this\n      case, if we copy the underlying type's sign, then reading some\n      range values will cause an unwanted sign extension.  So, we have\n      some heuristics here instead.  */\n-  if (low_bound->kind () == PROP_CONST && low_bound->const_val () >= 0)\n+  else if (low_bound->kind () == PROP_CONST && low_bound->const_val () >= 0)\n     result_type->set_is_unsigned (true);\n   /* Ada allows the declaration of range types whose upper bound is\n      less than the lower bound, so checking the lower bound is not\n@@ -3136,6 +3139,9 @@ set_type_code (struct type *type, enum type_code code)\n \tbreak;\n       case TYPE_CODE_FUNC:\n \tINIT_FUNC_SPECIFIC (type);\n+        break;\n+      case TYPE_CODE_FIXED_POINT:\n+\tINIT_FIXED_POINT_SPECIFIC (type);\n \tbreak;\n     }\n }\n@@ -3352,6 +3358,24 @@ init_pointer_type (struct objfile *objfile,\n   return t;\n }\n \n+/* Allocate a TYPE_CODE_FIXED_POINT type structure associated with OBJFILE.\n+   BIT is the pointer type size in bits.\n+   UNSIGNED_P should be nonzero if the type is unsigned.\n+   NAME is the type name.  */\n+\n+struct type *\n+init_fixed_point_type (struct objfile *objfile,\n+\t\t       int bit, int unsigned_p, const char *name)\n+{\n+  struct type *t;\n+\n+  t = init_type (objfile, TYPE_CODE_FIXED_POINT, bit, name);\n+  if (unsigned_p)\n+    t->set_is_unsigned (true);\n+\n+  return t;\n+}\n+\n /* See gdbtypes.h.  */\n \n unsigned\n@@ -3498,6 +3522,7 @@ is_integral_type (struct type *t)\n   t = check_typedef (t);\n   return\n     ((t != NULL)\n+     && !is_fixed_point_type (t)\n      && ((t->code () == TYPE_CODE_INT)\n \t || (t->code () == TYPE_CODE_ENUM)\n \t || (t->code () == TYPE_CODE_FLAGS)\n@@ -3523,6 +3548,9 @@ is_scalar_type (struct type *type)\n {\n   type = check_typedef (type);\n \n+  if (is_fixed_point_type (type))\n+    return 0; /* Implemented as a scalar, but more like a floating point.  */\n+\n   switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n@@ -4887,6 +4915,16 @@ print_gnat_stuff (struct type *type, int spaces)\n     }\n }\n \n+/* Print the contents of the TYPE's type_specific union, assuming that\n+   its type-specific kind is TYPE_SPECIFIC_FIXED_POINT.  */\n+\n+static void\n+print_fixed_point_type_info (struct type *type, int spaces)\n+{\n+  printfi_filtered (spaces + 2, \"scaling factor: %s\\n\",\n+\t\t    fixed_point_scaling_factor (type).str ().get ());\n+}\n+\n static struct obstack dont_print_type_obstack;\n \n /* Print the dynamic_prop PROP.  */\n@@ -5025,6 +5063,9 @@ recursive_dump_type (struct type *type, int spaces)\n     case TYPE_CODE_NAMESPACE:\n       printf_filtered (\"(TYPE_CODE_NAMESPACE)\");\n       break;\n+    case TYPE_CODE_FIXED_POINT:\n+      printf_filtered (\"(TYPE_CODE_FIXED_POINT)\");\n+      break;\n     default:\n       printf_filtered (\"(UNKNOWN TYPE CODE)\");\n       break;\n@@ -5217,6 +5258,12 @@ recursive_dump_type (struct type *type, int spaces)\n \tputs_filtered (\"\\n\");\n \tbreak;\n \n+      case TYPE_SPECIFIC_FIXED_POINT:\n+\tprintfi_filtered (spaces, \"fixed_point_info \");\n+\tprint_fixed_point_type_info (type, spaces);\n+\tputs_filtered (\"\\n\");\n+\tbreak;\n+\n     case TYPE_SPECIFIC_INT:\n       if (type->bit_size_differs_p ())\n \t{\n@@ -5449,6 +5496,11 @@ copy_type_recursive (struct objfile *objfile,\n \t\t\t  copy_type_recursive (objfile, TYPE_SELF_TYPE (type),\n \t\t\t\t\t       copied_types));\n       break;\n+    case TYPE_SPECIFIC_FIXED_POINT:\n+      INIT_FIXED_POINT_SPECIFIC (new_type);\n+      TYPE_FIXED_POINT_INFO (new_type)->scaling_factor\n+\t= TYPE_FIXED_POINT_INFO (type)->scaling_factor;\n+      break;\n     case TYPE_SPECIFIC_INT:\n       TYPE_SPECIFIC_FIELD (new_type) = TYPE_SPECIFIC_INT;\n       TYPE_MAIN_TYPE (new_type)->type_specific.int_stuff\n@@ -5752,6 +5804,85 @@ append_composite_type_field (struct type *t, const char *name,\n   append_composite_type_field_aligned (t, name, field, 0);\n }\n \n+\f\n+\n+/* We manage the lifetimes of fixed_point_type_info objects by\n+   attaching them to the objfile.  Currently, these objects are\n+   modified during construction, and GMP does not provide a way to\n+   hash the contents of an mpq_t; so it's a bit of a pain to hash-cons\n+   them.  If we did do this, they could be moved to the per-BFD and\n+   shared across objfiles.  */\n+typedef std::vector<std::unique_ptr<fixed_point_type_info>>\n+    fixed_point_type_storage;\n+\n+/* Key used for managing the storage of fixed-point type info.  */\n+static const struct objfile_key<fixed_point_type_storage>\n+    fixed_point_objfile_key;\n+\n+/* See gdbtypes.h.  */\n+\n+fixed_point_type_info *\n+allocate_fixed_point_type_info (struct type *type)\n+{\n+  std::unique_ptr<fixed_point_type_info> up (new fixed_point_type_info);\n+  fixed_point_type_info *result;\n+\n+  if (TYPE_OBJFILE_OWNED (type))\n+    {\n+      fixed_point_type_storage *storage\n+\t= fixed_point_objfile_key.get (TYPE_OBJFILE (type));\n+      if (storage == nullptr)\n+\tstorage = fixed_point_objfile_key.emplace (TYPE_OBJFILE (type));\n+      result = up.get ();\n+      storage->push_back (std::move (up));\n+    }\n+  else\n+    {\n+      /* We just leak the memory, because that's what we do generally\n+\t for non-objfile-attached types.  */\n+      result = up.release ();\n+    }\n+\n+  return result;\n+}\n+\n+/* See gdbtypes.h.  */\n+\n+bool\n+is_fixed_point_type (struct type *type)\n+{\n+  while (check_typedef (type)->code () == TYPE_CODE_RANGE)\n+    type = TYPE_TARGET_TYPE (check_typedef (type));\n+  type = check_typedef (type);\n+\n+  return type->code () == TYPE_CODE_FIXED_POINT;\n+}\n+\n+/* See gdbtypes.h.  */\n+\n+struct type *\n+fixed_point_type_base_type (struct type *type)\n+{\n+  while (check_typedef (type)->code () == TYPE_CODE_RANGE)\n+    type = TYPE_TARGET_TYPE (check_typedef (type));\n+  type = check_typedef (type);\n+\n+  gdb_assert (type->code () == TYPE_CODE_FIXED_POINT);\n+  return type;\n+}\n+\n+/* See gdbtypes.h.  */\n+\n+const gdb_mpq &\n+fixed_point_scaling_factor (struct type *type)\n+{\n+  type = fixed_point_type_base_type (type);\n+\n+  return TYPE_FIXED_POINT_INFO (type)->scaling_factor;\n+}\n+\n+\f\n+\n static struct gdbarch_data *gdbtypes_data;\n \n const struct builtin_type *"
    },
    {
      "sha": "5f9ac27b515103b8d5d4a4db30f0015212a54eb8",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 51,
      "deletions": 2,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -52,6 +52,7 @@\n #include \"gdbsupport/print-utils.h\"\n #include \"dwarf2.h\"\n #include \"gdb_obstack.h\"\n+#include \"gmp-utils.h\"\n \n /* Forward declarations for prototypes.  */\n struct field;\n@@ -189,7 +190,10 @@ enum type_code\n     TYPE_CODE_INTERNAL_FUNCTION,\n \n     /* * Methods implemented in extension languages.  */\n-    TYPE_CODE_XMETHOD\n+    TYPE_CODE_XMETHOD,\n+\n+    /* * Fixed Point type.  */\n+    TYPE_CODE_FIXED_POINT,\n   };\n \n /* * Some bits for the type's instance_flags word.  See the macros\n@@ -600,7 +604,8 @@ enum type_specific_kind\n   /* Note: This is used by TYPE_CODE_FUNC and TYPE_CODE_METHOD.  */\n   TYPE_SPECIFIC_FUNC,\n   TYPE_SPECIFIC_SELF_TYPE,\n-  TYPE_SPECIFIC_INT\n+  TYPE_SPECIFIC_INT,\n+  TYPE_SPECIFIC_FIXED_POINT,\n };\n \n union type_owner\n@@ -766,6 +771,10 @@ union type_specific\n \n   struct type *self_type;\n \n+  /* * For TYPE_CODE_FIXED_POINT types, the info necessary to decode\n+     values of that type.  */\n+  struct fixed_point_type_info *fixed_point_info;\n+\n   /* * An integer-like scalar type may be stored in just part of its\n      enclosing storage bytes.  This structure describes this\n      situation.  */\n@@ -1678,6 +1687,14 @@ struct call_site\n     struct call_site_parameter parameter[1];\n   };\n \n+/* The type-specific info for TYPE_CODE_FIXED_POINT types.  */\n+\n+struct fixed_point_type_info\n+{\n+  /* The fixed point type's scaling factor.  */\n+  gdb_mpq scaling_factor;\n+};\n+\n /* * The default value of TYPE_CPLUS_SPECIFIC(T) points to this shared\n    static structure.  */\n \n@@ -1725,6 +1742,13 @@ extern void allocate_gnat_aux_type (struct type *);\n      TYPE_ZALLOC (type,\t\t\t\t\t\t\t       \\\n \t\t  sizeof (*TYPE_MAIN_TYPE (type)->type_specific.func_stuff)))\n \n+/* \"struct fixed_point_type_info\" has a field that has a destructor.\n+   See allocate_fixed_point_type_info to understand how this is\n+   handled.  */\n+#define INIT_FIXED_POINT_SPECIFIC(type) \\\n+  (TYPE_SPECIFIC_FIELD (type) = TYPE_SPECIFIC_FIXED_POINT, \\\n+   TYPE_FIXED_POINT_INFO (type) = allocate_fixed_point_type_info (type))\n+\n #define TYPE_MAIN_TYPE(thistype) (thistype)->main_type\n #define TYPE_TARGET_TYPE(thistype) TYPE_MAIN_TYPE(thistype)->target_type\n #define TYPE_POINTER_TYPE(thistype) (thistype)->pointer_type\n@@ -1821,6 +1845,9 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n   (TYPE_CPLUS_SPECIFIC(thistype)->virtual_field_bits == NULL ? 0 \\\n     : B_TST(TYPE_CPLUS_SPECIFIC(thistype)->virtual_field_bits, (index)))\n \n+#define TYPE_FIXED_POINT_INFO(thistype) \\\n+  (TYPE_MAIN_TYPE(thistype)->type_specific.fixed_point_info)\n+\n #define FIELD_NAME(thisfld) ((thisfld).name)\n #define FIELD_LOC_KIND(thisfld) ((thisfld).loc_kind)\n #define FIELD_BITPOS_LVAL(thisfld) ((thisfld).loc.bitpos)\n@@ -2192,6 +2219,8 @@ extern struct type *init_decfloat_type (struct objfile *, int, const char *);\n extern struct type *init_complex_type (const char *, struct type *);\n extern struct type *init_pointer_type (struct objfile *, int, const char *,\n \t\t\t\t       struct type *);\n+extern struct type *init_fixed_point_type (struct objfile *, int, int,\n+\t\t\t\t\t   const char *);\n \n /* Helper functions to construct architecture-owned types.  */\n extern struct type *arch_type (struct gdbarch *, enum type_code, int,\n@@ -2529,6 +2558,26 @@ extern int type_not_allocated (const struct type *type);\n \n extern int type_not_associated (const struct type *type);\n \n+/* Return True if TYPE is a TYPE_CODE_FIXED_POINT or if TYPE is\n+   a range type whose base type is a TYPE_CODE_FIXED_POINT.  */\n+extern bool is_fixed_point_type (struct type *type);\n+\n+/* Assuming that TYPE is a fixed point type, return its base type.\n+\n+   In other words, this returns the type after having peeled all\n+   intermediate type layers (such as TYPE_CODE_RANGE, for instance).\n+   The TYPE_CODE of the type returned is guaranteed to be\n+   a TYPE_CODE_FIXED_POINT.  */\n+extern struct type *fixed_point_type_base_type (struct type *type);\n+\n+/* Given TYPE, which is a fixed point type, return its scaling factor.  */\n+extern const gdb_mpq &fixed_point_scaling_factor (struct type *type);\n+\n+/* Allocate a fixed-point type info for TYPE.  This should only be\n+   called by INIT_FIXED_POINT_SPECIFIC.  */\n+extern fixed_point_type_info *allocate_fixed_point_type_info\n+  (struct type *type);\n+\n /* * When the type includes explicit byte ordering, return that.\n    Otherwise, the byte ordering from gdbarch_byte_order for \n    get_type_arch is returned.  */"
    },
    {
      "sha": "0f629bd76b9cebfb9f910ea67c003664b6a08df7",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -1,3 +1,14 @@\n+2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n+\n+\t* gdb.ada/fixed_cmp.exp: Force compilation to use -fgnat-encodings=all.\n+\t* gdb.ada/fixed_points.exp: Add fixed-point variables printing tests.\n+\t* gdb.ada/fixed_points/pck.ads, gdb.ada/fixed_points/pck.adb:\n+\tNew files.\n+\t* gdb.ada/fixed_points/fixed_points.adb: Add use of package Pck.\n+\n+\t* gdb.dwarf2/dw2-fixed-point.c, gdb.dwarf2/dw2-fixed-point.exp:\n+\tNew files.\n+\n 2020-11-14  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \tPR cli/26879"
    },
    {
      "sha": "cfdbb1cfd1eb05b4f21c208875bc5c94499bdb19",
      "filename": "gdb/testsuite/gdb.ada/fixed_cmp.exp",
      "status": "modified",
      "additions": 19,
      "deletions": 15,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_cmp.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_cmp.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_cmp.exp?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -19,25 +19,29 @@ if { [skip_ada_tests] } { return -1 }\n \n standard_ada_testfile fixed\n \n-if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable [list debug ]] != \"\" } {\n-  return -1\n-}\n+foreach_with_prefix gnat_encodings {all} {\n+    set flags [list debug additional_flags=-fgnat-encodings=$gnat_encodings]\n+\n+    if {[gdb_compile_ada \"${srcfile}\" \"${binfile}\" executable $flags] != \"\" } {\n+      return -1\n+    }\n \n-clean_restart ${testfile}\n+    clean_restart ${testfile}\n \n-set bp_location [gdb_get_line_number \"STOP\" ${testdir}/fixed.adb]\n-runto \"fixed.adb:$bp_location\"\n+    set bp_location [gdb_get_line_number \"STOP\" ${testdir}/fixed.adb]\n+    runto \"fixed.adb:$bp_location\"\n \n-gdb_test \"print My_Var > 10.0\" \\\n-         \"= true\"\n+    gdb_test \"print My_Var > 10.0\" \\\n+             \"= true\"\n \n-gdb_test \"print My_Var > 20.0\" \\\n-         \"= false\"\n+    gdb_test \"print My_Var > 20.0\" \\\n+             \"= false\"\n \n-# Do the same, but with integer values.\n+    # Do the same, but with integer values.\n \n-gdb_test \"print My_Var > 10\" \\\n-         \"= true\"\n+    gdb_test \"print My_Var > 10\" \\\n+             \"= true\"\n \n-gdb_test \"print My_Var > 20\" \\\n-         \"= false\"\n+    gdb_test \"print My_Var > 20\" \\\n+             \"= false\"\n+}"
    },
    {
      "sha": "655ee955d3ef51f0cc3a799ba6fba58fc44c1b8e",
      "filename": "gdb/testsuite/gdb.ada/fixed_points.exp",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_points.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_points.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_points.exp?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -49,3 +49,14 @@ gdb_test \"print Overprecise_Object\" \\\n \n gdb_test \"ptype Overprecise_Object\" \\\n          \"= delta 0.135791\"\n+\n+# FP*_Var...\n+\n+gdb_test \"print fp1_var\" \\\n+         \" = 0.25\"\n+\n+gdb_test \"print fp2_var\" \\\n+         \" = -0.01\"\n+\n+gdb_test \"print fp3_var\" \\\n+         \" = 0.1\""
    },
    {
      "sha": "f0a34ba5dff5b771946793f6b350212c5cf6e27e",
      "filename": "gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -14,6 +14,7 @@\n --  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n \n with System;\n+with Pck; use Pck;\n \n procedure Fixed_Points is\n \n@@ -59,4 +60,7 @@ begin\n    Subtype_Object := 1.0/16.0;\n    New_Type_Object := 1.0/16.0;\n    Overprecise_Object := Overprecise_Fixed_Point'Small * 2;\n+   Do_Nothing (FP1_Var'Address);\n+   Do_Nothing (FP2_Var'Address);\n+   Do_Nothing (FP3_Var'Address);\n end Fixed_Points;"
    },
    {
      "sha": "16f03849f5dd6ea484b7d64c015e69fd2c473c89",
      "filename": "gdb/testsuite/gdb.ada/fixed_points/pck.adb",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_points/pck.adb",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_points/pck.adb",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_points/pck.adb?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -0,0 +1,22 @@\n+--  Copyright 2016-2020 Free Software Foundation, Inc.\n+--\n+--  This program is free software; you can redistribute it and/or modify\n+--  it under the terms of the GNU General Public License as published by\n+--  the Free Software Foundation; either version 3 of the License, or\n+--  (at your option) any later version.\n+--\n+--  This program is distributed in the hope that it will be useful,\n+--  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+--  GNU General Public License for more details.\n+--\n+--  You should have received a copy of the GNU General Public License\n+--  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+package body Pck is\n+   procedure Do_Nothing (A : System.Address) is\n+   begin\n+      null;\n+   end Do_Nothing;\n+end pck;\n+"
    },
    {
      "sha": "4d900dccf60bf31786be4c9874a001085f952ab7",
      "filename": "gdb/testsuite/gdb.ada/fixed_points/pck.ads",
      "status": "added",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_points/pck.ads",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.ada/fixed_points/pck.ads",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_points/pck.ads?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -0,0 +1,30 @@\n+--  Copyright 2016-2020 Free Software Foundation, Inc.\n+--\n+--  This program is free software; you can redistribute it and/or modify\n+--  it under the terms of the GNU General Public License as published by\n+--  the Free Software Foundation; either version 3 of the License, or\n+--  (at your option) any later version.\n+--\n+--  This program is distributed in the hope that it will be useful,\n+--  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+--  GNU General Public License for more details.\n+--\n+--  You should have received a copy of the GNU General Public License\n+--  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+with System;\n+\n+package Pck is\n+   type FP1_Type is delta 0.1 range -1.0 .. +1.0;\n+   FP1_Var : FP1_Type := 0.25;\n+\n+   type FP2_Type is delta 0.01 digits 14;\n+   FP2_Var : FP2_Type := -0.01;\n+\n+   type FP3_Type is delta 0.1 range 0.0 .. 1.0 with Small => 0.1/3.0;\n+   FP3_Var : FP3_Type := 0.1;\n+\n+   procedure Do_Nothing (A : System.Address);\n+end pck;\n+"
    },
    {
      "sha": "d9c811c08837af73e35a97a6ca441c4325101fa8",
      "filename": "gdb/testsuite/gdb.dwarf2/dw2-fixed-point.c",
      "status": "added",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.c?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -0,0 +1,49 @@\n+/* Copyright 2016-2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <stdint.h>\n+\n+/* Simulate an Ada variable declared inside package Pck as follow:\n+      type FP1_Type is delta 0.1 range -1.0 .. +1.0;\n+      FP1_Var : FP1_Type := 0.25;  */\n+int8_t pck__fp1_var = 4;\n+\n+/* Simulate an Ada variable declared inside package Pck as follow:\n+      type FP2_Type is delta 0.01 digits 14;\n+      FP2_Var : FP2_Type := -0.01;  */\n+int32_t pck__fp2_var = -1;\n+\n+/* Simulate an Ada variable declared inside package Pck as follow:\n+      type FP3_Type is delta 0.1 range 0.0 .. 1.0 with Small => 0.1/3.0;\n+      FP3_Var : FP3_Type := 0.1;  */\n+int8_t pck__fp3_var = 3;\n+\n+/* Simulate an Ada variable declared inside package Pck as follow:\n+      type FP1_Type is delta 0.1 range -1.0 .. +1.0;\n+      FP1_Var : FP1_Type := 1.0;  */\n+int8_t pck__fp1_range_var = 16;\n+\n+int\n+main (void)\n+{\n+  pck__fp1_var++;\n+  pck__fp2_var++;\n+  pck__fp3_var++;\n+  pck__fp1_range_var++;\n+\n+  return 0;\n+}"
    },
    {
      "sha": "bf88ffe4f73ef2f47d81d298eeaac5185fa8012b",
      "filename": "gdb/testsuite/gdb.dwarf2/dw2-fixed-point.exp",
      "status": "added",
      "additions": 132,
      "deletions": 0,
      "changes": 132,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.exp?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -0,0 +1,132 @@\n+# Copyright 2016-2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+load_lib dwarf.exp\n+\n+# This test can only be run on targets which support DWARF-2 and use gas.\n+if {![dwarf2_support]} {\n+    return 0\n+}\n+\n+standard_testfile dw2-fixed-point.c dw2-fixed-point-dw.S\n+\n+# Make some DWARF for the test.\n+set asm_file [standard_output_file $srcfile2]\n+Dwarf::assemble $asm_file {\n+    cu {} {\n+ \tDW_TAG_compile_unit {\n+                {DW_AT_language @DW_LANG_Ada95}\n+                {DW_AT_name     pck.ads}\n+                {DW_AT_comp_dir /tmp}\n+        } {\n+            declare_labels fp1_base_type fp2_base_type fp3_small \\\n+                fp3_base_type fp1_range_type\n+\n+            fp1_base_type: DW_TAG_base_type {\n+                {DW_AT_byte_size     1 DW_FORM_sdata}\n+                {DW_AT_encoding      @DW_ATE_signed_fixed}\n+                {DW_AT_name          pck__fp1_type}\n+                {DW_AT_binary_scale  -4 DW_FORM_sdata}\n+            }\n+\n+            DW_TAG_variable {\n+                {DW_AT_name pck__fp1_var}\n+                {DW_AT_type :$fp1_base_type}\n+                {DW_AT_location {\n+                    DW_OP_addr [gdb_target_symbol pck__fp1_var]\n+                } SPECIAL_expr}\n+                {external 1 flag}\n+            }\n+\n+            fp2_base_type: DW_TAG_base_type {\n+                {DW_AT_byte_size     1 DW_FORM_sdata}\n+                {DW_AT_encoding      @DW_ATE_signed_fixed}\n+                {DW_AT_name          pck__fp2_type}\n+                {DW_AT_decimal_scale -2 DW_FORM_sdata}\n+            }\n+\n+            DW_TAG_variable {\n+                {DW_AT_name pck__fp2_var}\n+                {DW_AT_type :$fp2_base_type}\n+                {DW_AT_location {\n+                    DW_OP_addr [gdb_target_symbol pck__fp2_var]\n+                } SPECIAL_expr}\n+                {external 1 flag}\n+            }\n+\n+            fp3_small: DW_TAG_constant {\n+                {DW_AT_GNU_numerator   1 DW_FORM_data1}\n+                {DW_AT_GNU_denominator 30 DW_FORM_sdata}\n+            }\n+\n+            fp3_base_type: DW_TAG_base_type {\n+                {DW_AT_byte_size     1 DW_FORM_sdata}\n+                {DW_AT_encoding      @DW_ATE_signed_fixed}\n+                {DW_AT_name          pck__fp3_type}\n+                {DW_AT_small         :$fp3_small}\n+            }\n+\n+            DW_TAG_variable {\n+                {DW_AT_name pck__fp3_var}\n+                {DW_AT_type :$fp3_base_type}\n+                {DW_AT_location {\n+                    DW_OP_addr [gdb_target_symbol pck__fp3_var]\n+                } SPECIAL_expr}\n+                {external 1 flag}\n+            }\n+\n+            fp1_range_type: DW_TAG_subrange_type {\n+                 {DW_AT_lower_bound 0xf0 DW_FORM_data1}\n+                 {DW_AT_upper_bound 0x10 DW_FORM_data1}\n+                 {DW_AT_name foo__fp1_range_type}\n+                 {DW_AT_type :$fp1_base_type}\n+             }\n+\n+             DW_TAG_variable {\n+                 {DW_AT_name pck__fp1_range_var}\n+                 {DW_AT_type :$fp1_range_type}\n+                 {DW_AT_location {\n+                     DW_OP_addr [gdb_target_symbol pck__fp1_range_var]\n+                 } SPECIAL_expr}\n+                 {external 1 flag}\n+             }\n+\t}\n+    }\n+}\n+\n+if { [prepare_for_testing ${testfile}.exp ${testfile} \\\n+\t  [list $srcfile $asm_file] {nodebug}] } {\n+    return -1\n+}\n+\n+if ![runto_main] {\n+    return -1\n+}\n+\n+# Do the testing in Ada mode, since this is the language for which\n+# this feature has been implemented, and where we know the language\n+# has the concept of fixed-point types.\n+gdb_test_no_output \"set lang ada\"\n+\n+gdb_test \"print pck.fp1_var\" \\\n+         \" = 0.25\"\n+\n+gdb_test \"print pck.fp2_var\" \\\n+         \" = -0.01\"\n+\n+gdb_test \"print pck.fp3_var\" \\\n+         \" = 0.1\"\n+\n+gdb_test \"print pck.fp1_range_var\" \\\n+         \" = 1\""
    },
    {
      "sha": "38ae0bdf0e25defab21ece9bbce7c07ac651a300",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -794,6 +794,31 @@ generic_val_print_float (struct type *type, struct ui_file *stream,\n   print_floating (valaddr, type, stream);\n }\n \n+/* generic_val_print helper for TYPE_CODE_FIXED_POINT.  */\n+\n+static void\n+generic_val_print_fixed_point (struct value *val, struct ui_file *stream,\n+\t\t\t       const struct value_print_options *options)\n+{\n+  if (options->format)\n+    value_print_scalar_formatted (val, options, 0, stream);\n+  else\n+    {\n+      struct type *type = value_type (val);\n+\n+      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      gdb_mpf f;\n+\n+      f.read_fixed_point (valaddr, TYPE_LENGTH (type),\n+\t\t\t  type_byte_order (type), type->is_unsigned (),\n+\t\t\t  fixed_point_scaling_factor (type));\n+\n+      const char *fmt = TYPE_LENGTH (type) < 4 ? \"%.11Fg\" : \"%.17Fg\";\n+      gdb::unique_xmalloc_ptr<char> str = gmp_string_asprintf (fmt, f.val);\n+      fprintf_filtered (stream, \"%s\", str.get ());\n+    }\n+}\n+\n /* generic_value_print helper for TYPE_CODE_COMPLEX.  */\n \n static void\n@@ -844,6 +869,10 @@ generic_value_print (struct value *val, struct ui_file *stream, int recurse,\n   struct type *type = value_type (val);\n \n   type = check_typedef (type);\n+\n+  if (is_fixed_point_type (type))\n+    type = fixed_point_type_base_type (type);\n+\n   switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n@@ -909,6 +938,10 @@ generic_value_print (struct value *val, struct ui_file *stream, int recurse,\n \tgeneric_val_print_float (type, stream, val, options);\n       break;\n \n+    case TYPE_CODE_FIXED_POINT:\n+      generic_val_print_fixed_point (val, stream, options);\n+      break;\n+\n     case TYPE_CODE_VOID:\n       fputs_filtered (decorations->void_name, stream);\n       break;"
    },
    {
      "sha": "a0546afe9ea114b25863c8af26994f59825f7c28",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0958441403b92163dff851f0a78241c7fcb4e8eb/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=0958441403b92163dff851f0a78241c7fcb4e8eb",
      "patch": "@@ -2758,6 +2758,9 @@ value_as_address (struct value *val)\n LONGEST\n unpack_long (struct type *type, const gdb_byte *valaddr)\n {\n+  if (is_fixed_point_type (type))\n+    type = fixed_point_type_base_type (type);\n+\n   enum bfd_endian byte_order = type_byte_order (type);\n   enum type_code code = type->code ();\n   int len = TYPE_LENGTH (type);\n@@ -2806,6 +2809,17 @@ unpack_long (struct type *type, const gdb_byte *valaddr)\n     case TYPE_CODE_DECFLOAT:\n       return target_float_to_longest (valaddr, type);\n \n+    case TYPE_CODE_FIXED_POINT:\n+      {\n+\tgdb_mpq vq;\n+\tvq.read_fixed_point (valaddr, len, byte_order, nosign,\n+\t\t\t     fixed_point_scaling_factor (type));\n+\n+\tgdb_mpz vz;\n+\tmpz_tdiv_q (vz.val, mpq_numref (vq.val), mpq_denref (vq.val));\n+\treturn vz.as_integer<LONGEST> ();\n+      }\n+\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_REF:\n     case TYPE_CODE_RVALUE_REF:"
    }
  ]
}