{
  "sha": "64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
  "node_id": "C_kwDOANOeidoAKDY0YTk3NjA2MDFkM2Q4NzYxZmNmMGFhZTEyMWU2OWNhMGNhZTFhOWM",
  "commit": {
    "author": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2022-02-25T00:42:22Z"
    },
    "committer": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2022-02-25T00:42:22Z"
    },
    "message": "Support template lookups in strncmp_iw_with_mode\n\nThis patch adds support for wild template parameter list matches, similar\nto how ABI tags or function overloads are now handled.\n\nWith this patch, users will be able to \"gloss over\" the details of matching\ntemplate parameter lists.  This is accomplished by adding (yet more) logic\nto strncmp_iw_with_mode to skip parameter lists if none is explicitly given\nby the user.\n\nHere's a simple example using gdb.linespec/cpls-ops.exp:\n\nBefore\n------\n(gdb) ptype test_op_call\ntype = struct test_op_call {\n  public:\n    void operator()(void);\n    void operator()(int);\n    void operator()(long);\n    void operator()<int>(int *);\n}\n(gdb) b test_op_call::operator()\nBreakpoint 1 at 0x400583: test_op_call::operator(). (3 locations)\n(gdb) i b\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   <MULTIPLE>\n1.1                         y     0x400583 in test_op_call::operator()(int)\n                                                   at cpls-ops.cc:43\n1.2                         y     0x40058e in test_op_call::operator()()\n                                                   at cpls-ops.cc:47\n1.3                         y     0x40059e in test_op_call::operator()(long)\n                                                   at cpls-ops.cc:51\n\nThe breakpoint at test_op_call::operator()<int> was never set.\n\nAfter\n-----\n(gdb) b test_op_call::operator()\nBreakpoint 1 at 0x400583: test_op_call::operator(). (4 locations)\n(gdb) i b\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   <MULTIPLE>\n1.1                         y     0x400583 in test_op_call::operator()(int)\n                                                   at cpls-ops.cc:43\n1.2                         y     0x40058e in test_op_call::operator()()\n                                                   at cpls-ops.cc:47\n1.3                         y     0x40059e in test_op_call::operator()(long)\n                                                   at cpls-ops.cc:51\n1.4                         y     0x4008d0 in test_op_call::operator()<int>(int*)\n                                                   at cpls-ops.cc:57\n\nSimilar to how scope lookups work, passing \"-qualified\" to the break command\nwill cause a literal lookup of the symbol.  In the example immediately above,\nthis will cause GDB to only find the three non-template functions.",
    "tree": {
      "sha": "568bdb8fd5255e7824d6912582baf7f7d93e5292",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/568bdb8fd5255e7824d6912582baf7f7d93e5292"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "b05752c223b79f3b42fb2a506377fc12adaf8aeb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b05752c223b79f3b42fb2a506377fc12adaf8aeb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b05752c223b79f3b42fb2a506377fc12adaf8aeb"
    }
  ],
  "stats": {
    "total": 840,
    "additions": 800,
    "deletions": 40
  },
  "files": [
    {
      "sha": "41ea84e6063c8b123b76949bd04468296d13e1af",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -3,6 +3,20 @@\n \n *** Changes since GDB 11\n \n+* Improved C++ template support\n+\n+  GDB now treats functions/types involving C++ templates like it does function\n+  overloads.  Users may omit parameter lists to set breakpoints on families of\n+  template functions, including types/functions composed of multiple template types:\n+\n+  (gdb) break template_func(template_1, int)\n+\n+  The above will set breakpoints at every function `template_func' where\n+  the first function parameter is any template type named `template_1' and\n+  the second function parameter is `int'.\n+\n+  TAB completion also gains similar improvements.\n+\n * The FreeBSD native target now supports async mode.\n \n * Configure changes"
    },
    {
      "sha": "af5c30384b02d7d7fe3c7ec1ecf6734df302bd7f",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -1692,6 +1692,12 @@ cp_search_name_hash (const char *search_name)\n \t  && string[5] != ':')\n \tbreak;\n \n+      /* Ignore template parameter lists.  */\n+      if (string[0] == '<'\n+\t  && string[1] != '(' && string[1] != '<' && string[1] != '='\n+\t  && string[1] != ' ' && string[1] != '\\0')\n+\tbreak;\n+\n       hash = SYMBOL_HASH_NEXT (hash, *string);\n     }\n   return hash;\n@@ -1745,7 +1751,7 @@ cp_symbol_name_matches_1 (const char *symbol_search_name,\n   while (true)\n     {\n       if (strncmp_iw_with_mode (sname, lookup_name, lookup_name_len,\n-\t\t\t\tmode, language_cplus, match_for_lcd) == 0)\n+\t\t\t\tmode, language_cplus, match_for_lcd, true) == 0)\n \t{\n \t  if (comp_match_res != NULL)\n \t    {"
    },
    {
      "sha": "504eb663c14b484f93b2f8e992c5d2a4f5a98e30",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -16888,6 +16888,21 @@ also use the @value{GDBN} command-line word completion facilities to list the\n available choices, or to finish the type list for you.\n @xref{Completion,, Command Completion}, for details on how to do this.\n \n+@item @r{Breakpoints in template functions}\n+\n+Similar to how overloaded symbols are handled, @value{GDBN} will ignore\n+template parameter lists when it encounters a symbol which includes a\n+C@t{++} template.  This permits setting breakpoints on families of template functions\n+or functions whose parameters include template types.\n+\n+The @kbd{-qualified} flag may be used to override this behavior, causing\n+@value{GDBN} to search for a specific function or type.\n+\n+The @value{GDBN} command-line word completion facility also understands\n+template parameters and may be used to list available choices or finish\n+template parameter lists for you. @xref{Completion,, Command Completion}, for\n+details on how to do this.\n+\n @item @r{Breakpoints in functions with ABI tags}\n \n The GNU C@t{++} compiler introduced the notion of ABI ``tags'', which"
    },
    {
      "sha": "1b9a2d48819610000e4c8adace2c1155f3aea938",
      "filename": "gdb/testsuite/gdb.cp/templates.cc",
      "status": "modified",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.cp/templates.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.cp/templates.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/templates.cc?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -742,6 +742,34 @@ template<class C> int FunctionArg<C>::method(Empty<void (FunctionArg<C>)> &arg)\n Empty<void(FunctionArg<int>)> empty;\n FunctionArg<int> arg;\n \n+template <typename T1>\n+struct Foozle\n+{\n+  int x;\n+  T1 t;\n+  template <typename T2>\n+  T2 fogey (T2 plop);\n+};\n+\n+template <typename T1>\n+template <typename T2>\n+T2 Foozle<T1>::fogey (T2 plop)\n+{\n+  return plop;\n+}\n+\n+template <typename T>\n+int operator< (T &lhs, T &rhs)\n+{\n+  return 0;\n+}\n+\n+template <typename T>\n+int operator<< (T &obj, T &val)\n+{\n+  return 1;\n+};\n+\n int main()\n {\n     int i;\n@@ -815,5 +843,24 @@ int main()\n \n   arg.method(empty);\n \n+  Empty<int> e;\n+  Foozle<int> fzi;\n+  x = fzi.fogey (0);\n+  c = fzi.fogey<char> ('a');\n+  e = fzi.fogey<Empty<int>> (e);\n+  Foozle<char> fzc;\n+  c = fzc.fogey ('b');\n+  x = fzc.fogey<int> (0);\n+  e = fzc.fogey<Empty<int>> (e);\n+  Foozle<Empty<int>> fze;\n+  e = fze.fogey (e);\n+  c = fze.fogey<char> ('c');\n+  x = fze.fogey<int> (0);\n+\n+  z = e < e;\n+  z += e << e;\n+  z += fzi < fzi;\n+  z += fzi << fzi;\n+\n   return 0;\t/* Final breakpoint.  */\n }"
    },
    {
      "sha": "a798054d19cee09b5b580b6c38acf377a6681f67",
      "filename": "gdb/testsuite/gdb.cp/templates.exp",
      "status": "modified",
      "additions": 67,
      "deletions": 0,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.cp/templates.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.cp/templates.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/templates.exp?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -614,3 +614,70 @@ gdb_test \"print Garply<Garply<char> >::garply\" \\\n # Now should work fine\n gdb_test \"break Garply<Garply<char> >::garply\" \\\n     \"Breakpoint \\[0-9\\]* at $hex: file .*templates.cc, line.*\"\n+\n+#\n+# Template wild-matching tests\n+#\n+\n+# Turn off \"ask\" when multiple symbols are seen.\n+gdb_test_no_output \"set multiple-symbols all\"\n+\n+# Test setting breakpoints in a method of all class template instantiations,\n+# including overloads.\n+gdb_test \"break Foo::foo\"  \"Breakpoint.*at.* \\\\(3 locations\\\\)\"\n+foreach t [list \"int\" \"char\" \"volatile char *\"] {\n+    gdb_breakpoint \"Foo<$t>::foo (int, $t)\"\n+    gdb_breakpoint \"Foo::foo (int, $t)\"\n+}\n+\n+gdb_test \"break Bar::bar\" \"Breakpoint.*at.* \\\\(2 locations\\\\)\"\n+gdb_test \"break Bar::bar (int, int)\" \"Breakpoint.*at.* \\\\(2 locations\\\\)\"\n+foreach val [list 1 33] {\n+    gdb_breakpoint \"Bar<int, $val>::bar (int, int)\"\n+}\n+\n+# Test setting breakpoints in a member function template of a class template,\n+# including overloads.\n+gdb_test \"break Foozle::fogey\" \"Breakpoint.*at.* \\\\(9 locations\\\\)\" \\\n+    \"break at template method fogey\"\n+foreach t [list \"int\" \"char\" \"Empty<int>\"] {\n+    gdb_test \"break Foozle::fogey ($t)\" \"Breakpoint.*at.* \\\\(3 locations\\\\)\"\n+    gdb_test \"break Foozle::fogey<$t>\" \"Breakpoint.*at.* \\\\(3 locations\\\\)\"\n+    foreach u [list \"int\" \"char\" \"Empty<int>\"] {\n+\tgdb_breakpoint \"Foozle<$t>::fogey<$u>\" message\n+\tgdb_breakpoint \"Foozle<$t>::fogey<$u> ($u)\" message\n+    }\n+}\n+\n+# Test templated operators < and <<.  Restrict results to only the test\n+# source file.\n+# operator<:\n+#   1. operator< (const T2&, const T2&)\n+#   2. operator< (const T2&, char)\n+#   3. operator< <Empty<int>>\n+#   4. operator< <Foozle<in>>\n+#\n+# operator<<:\n+#   1. operator<< <Empty<int>>\n+#   2. operator<< <Foozle<int>>\n+gdb_test \"break -source $srcfile -func operator<\" \\\n+    \"Breakpoint.*at.* \\\\(4 locations\\\\)\"\n+gdb_test \"break -source $srcfile -func operator<<\" \\\n+    \"Breakpoint.*at.* \\\\(2 locations\\\\)\"\n+foreach t [list \"Empty\" \"Foozle\"] {\n+    set tt \"$t<int>\"\n+    gdb_breakpoint \"operator< <$tt>\" message\n+    gdb_breakpoint \"operator<< <$tt>\" message\n+\n+    # Try a specific instance, both with and without whitespace\n+    # after the template-template parameter.\n+    gdb_breakpoint \"operator< <$tt> ($tt&, $tt&)\" message\n+    gdb_breakpoint \"operator< <$tt > ($tt&, $tt&)\" message\n+    gdb_breakpoint \"operator<< <$tt> ($tt&, $tt&)\" message\n+    gdb_breakpoint \"operator<< <$tt > ($tt&, $tt&)\" message\n+}\n+\n+# Test that \"-qualified\" finds no matching locations.\n+gdb_test_no_output \"set breakpoint pending off\"\n+gdb_test \"break -qualified Foozle::fogey\" \\\n+    \"Function \\\"Foozle::fogey\\\" not defined.\""
    },
    {
      "sha": "0383469828c77f6f737f9cdfa48cb860c7440c24",
      "filename": "gdb/testsuite/gdb.linespec/cpcompletion.exp",
      "status": "modified",
      "additions": 432,
      "deletions": 5,
      "changes": 437,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.linespec/cpcompletion.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.linespec/cpcompletion.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.linespec/cpcompletion.exp?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -16,6 +16,7 @@\n # This file is part of the gdb testsuite.\n \n load_lib completion-support.exp\n+load_lib data-structures.exp\n \n standard_testfile cpls.cc cpls2.cc cpls-hyphen.cc\n \n@@ -32,6 +33,217 @@ if { ![readline_is_used] } {\n     return -1\n }\n \n+#\n+# Some convenience procedures for testing template parameter list\n+# completion.\n+#\n+\n+# For the variable named ARGLISTVAR, which should be the name of an\n+# argument list in the calling frame, \"consume\" the top-most token.\n+# [See comments for makefoo for description of arglist format.]\n+\n+proc consume {arglistvar} {\n+  upvar $arglistvar arglist\n+\n+  # ARGLIST is a string -- simply strip off the first character.\n+  set arglist [string range $arglist 1 end]\n+}\n+\n+# Create a function template named NAME, using the given stack ID to grab\n+# NUM template parameters.  The result is pushed back onto the\n+# stack.  NUM may be \"all,\" in which case we use the entire stack\n+# to create the function template, including function arguments.\n+# The resulting template function's arguments are taken from the test\n+# source code for the function \"foo\" and is not generalized.\n+\n+proc maket {sid name {num 1}} {\n+\n+  # Set up a temporary stack of parameters.  This will reverse\n+  # the order in SID so that when they are popped again below,\n+  # we get them in the correct order.  This also takes into account\n+  # how many levels of the result stack we want to consider.\n+\n+  set paramstack [::Stack::new]\n+  if {[string equal $num \"all\"]} {\n+    while {![stack empty $sid]} {\n+      stack push $paramstack [stack pop $sid]\n+    }\n+  } else {\n+    for {set i 0} {$i < $num} {incr i} {\n+      stack push $paramstack [stack pop $sid]\n+    }\n+  }\n+\n+  # Construct the function template and push it back to the\n+  # top of the stack given by SID.\n+  set result \"\"\n+  set first true\n+  while {![stack empty $paramstack]} {\n+    set top [stack pop $paramstack]\n+    if {$first} {\n+      set first false\n+    } else {\n+      append result \", \"\n+    }\n+    append result $top\n+  }\n+\n+  # Save argument list.\n+  set args $result\n+\n+  # GDB outputs \"> >\" instead of \">>\".\n+  if {[string index $top end] == \">\"} {\n+      append result \" \"\n+  }\n+  set result \"$name<$result>\"\n+  if {[string equal $num \"all\"]} {\n+    append result \"($args)\"\n+  }\n+  stack push $sid $result\n+  stack delete $paramstack\n+}\n+\n+# Given the stack SID and the name of a variable of the desired template\n+# parameters, construct the actual template parameter and push it to the\n+# top of the stack.\n+\n+proc makearg {sid arglistvar} {\n+    upvar $arglistvar arglist\n+\n+  set c [string index $arglist 0]\n+  consume arglist\n+  switch $c {\n+    A -\n+    B {\n+      makearg $sid arglist\n+      makearg $sid arglist\n+      maket $sid $c 2\n+    }\n+\n+    a -\n+    b -\n+    c -\n+    d {\n+      makearg $sid arglist\n+      maket $sid $c\n+    }\n+\n+    i {\n+      stack push $sid \"int\"\n+    }\n+\n+    n {\n+      # These are not templates.\n+      set c [string index $arglist 0]\n+      stack push $sid \"n::n$c\"\n+      consume arglist\n+    }\n+\n+    N {\n+      set c [string index $arglist 0]\n+      makearg $sid arglist\n+      set top [stack pop $sid]\n+      stack push $sid \"n::N$top\"\n+    }\n+\n+    default { error \"unhandled arglist identifier: '$c'\" }\n+  }\n+}\n+\n+# Given ARGLIST, construct a class template for the type and return\n+# it as a string.\n+\n+proc maketype {arglist} {\n+    set s [Stack::new]\n+    makearg $s arglist\n+    set result [stack pop $s]\n+    stack delete $s\n+    return $result\n+}\n+\n+# Returns a function template declaration for the function \"foo\" in the\n+# corresponding test source code.  ARGLIST specifies the exact instantiation\n+# that is desired.\n+#\n+# Generically, this procedure returns a string of the form,\n+# \"foo<parameter-list> (arg-list)\", where ARGLIST describes the parameter(s).\n+#\n+# Valid specifiers for ARGLIST (must be kept in sync with source code):\n+#\n+# i: Creates an \"int\" type.\n+# a, b, c, d: Creates the struct template of the same name, taking a single\n+#    template parameter.\n+# A, B: Creates the struct template of the same name, taking two template\n+#    parameters.\n+# na, nb: Creates the non-template structs n::na and n::nb, respectively.\n+# NA, NB: Creates the struct templates n::NA and n::NB, respectively, which\n+#    take two template parameters.\n+#\n+# Examples:\n+# makefoo i\n+# --> foo<int> (int)\n+# makefoo ii\n+# --> foo<int, int> (int, int)\n+# makefoo Aiabi\n+# --> foo<A<int, a<b<int> > > > (A<int, a<b<int> > >)\n+# makefoo NANAiaiNBbiabi\n+# --> foo<n::NA<n::NA<int, a<int> >, n::NB<b<int>, a<b<int> > > > >\n+#          (n::NA<n::NA<int, a<int> >, n::NB<b<int>, a<b<int> > > >)\n+\n+proc makefoo {arglist} {\n+    set s [::Stack::new]\n+    while {[string length $arglist] > 0} {\n+\tmakearg $s arglist\n+    }\n+\n+  maket $s \"foo\" all\n+  set result [stack pop $s]\n+  stack delete $s\n+  return $result\n+}\n+\n+# Test wrapper for a single \"makefoo\" unit test.\n+\n+proc test_makefoo_1 {arglist expected} {\n+  set exp \"foo<$expected\"\n+  if {[string index $exp end] == \">\"} {\n+    append exp \" \"\n+  }\n+  append exp \">\"\n+  append exp \"($expected)\"\n+\n+  set calc [makefoo $arglist]\n+  send_log \"makefoo $arglist = $calc\\n\"\n+  send_log \"expecting: $exp\\n\"\n+  if {[string equal $exp $calc]} {\n+    pass \"makefoo unit test: $arglist\"\n+  } else {\n+      fail \"makefoo unit test: $arglist\"\n+  }\n+}\n+\n+# Test whether the procedure \"makefoo\" is functioning as expected.\n+\n+proc test_makefoo {} {\n+  test_makefoo_1 \"i\" \"int\"\n+  test_makefoo_1 \"ai\" \"a<int>\"\n+  test_makefoo_1 \"aai\" \"a<a<int> >\"\n+  test_makefoo_1 \"ii\" \"int, int\"\n+  test_makefoo_1 \"aaibi\" \"a<a<int> >, b<int>\"\n+    test_makefoo_1 \\\n+      \"ababiibababai\" \"a<b<a<b<int> > > >, int, b<a<b<a<b<a<int> > > > > >\"\n+  test_makefoo_1 \"Aii\" \"A<int, int>\"\n+  test_makefoo_1 \"ABaibibi\" \"A<B<a<int>, b<int> >, b<int> >\"\n+  test_makefoo_1 \"na\" \"n::na\"\n+  test_makefoo_1 \"nana\" \"n::na, n::na\"\n+  test_makefoo_1 \"NAii\" \"n::NA<int, int>\"\n+  test_makefoo_1 \"NANAiiNAii\" \"n::NA<n::NA<int, int>, n::NA<int, int> >\"\n+}\n+\n+#\n+# Tests start here.\n+#\n+\n # Disable the completion limit for the whole testcase.\n gdb_test_no_output \"set max-completions unlimited\"\n \n@@ -385,12 +597,11 @@ proc_with_prefix template-ret-type {} {\n \t    test_complete_prefix_range $complete_line $start\n \t}\n \n-\t# Setting a breakpoint without the template params doesn't work.\n-\tcheck_setting_bp_fails \"$cmd_prefix template2_fn\"\n-\t# However, setting a breakpoint with template params and without\n-\t# the method params does work, just like with non-template\n-\t# functions.  It also works with or without return type.\n+\t# Setting a breakpoint with or without template params and without\n+\t# the method params works, just like with non-template functions.\n+\t#  It also works with or without return type.\n \tforeach linespec [list \\\n+\t\t\t      \"template2_fn\" \\\n \t\t\t      \"${method_name}\" \\\n \t\t\t      \"${method_name}${param_list}\" \\\n \t\t\t      \"${struct_type}::${method_name}\" \\\n@@ -404,6 +615,218 @@ proc_with_prefix template-ret-type {} {\n     }\n }\n \n+# Test completion of function template foo.\n+\n+proc_with_prefix template-function-foo {} {\n+\n+    foreach cmd_prefix {\"b\" \"b -function\"} {\n+\t# \"foo\" is ambiguous, this will set many different breakpoints.\n+\tset completion_list \\\n+\t    [list \\\n+\t\t [makefoo Aabiaai] \\\n+\t\t [makefoo Aabiabi] \\\n+\t\t [makefoo Aabicdi] \\\n+\t\t [makefoo AabicdiAabiaai] \\\n+\t\t [makefoo AabicdiAabiabi] \\\n+\t\t [makefoo AabicdiBabicdi] \\\n+\t\t [makefoo Babicdi] \\\n+\t\t [makefoo aai] \\\n+\t\t [makefoo aaiabi] \\\n+\t\t [makefoo aaicci] \\\n+\t\t [makefoo aaicdi] \\\n+\t\t [makefoo abi] \\\n+\t\t [makefoo anabnb] \\\n+\t\t [makefoo cci] \\\n+\t\t [makefoo cdi] \\\n+\t\t [makefoo NAnanbNBnanb] \\\n+\t\t [makefoo nanb]]\n+\ttest_gdb_complete_multiple \"$cmd_prefix \" \"foo\" \"<\" $completion_list\n+\tcheck_bp_locations_match_list \"$cmd_prefix foo\" $completion_list\n+\n+\t# \"foo<\" should give the same result, but it should not set any\n+\t# breakpoints.\n+\ttest_gdb_complete_multiple \"$cmd_prefix \" \"foo<\" \"\" $completion_list\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<\"\n+\n+\t# \"foo<A\" should only give completions in COMPLETION_LIST that\n+\t# start with \"A\" but should set no breakpoints.\n+\tset completion_list \\\n+\t    [list \\\n+\t\t [makefoo Aabiaai] \\\n+\t\t [makefoo Aabiabi] \\\n+\t\t [makefoo Aabicdi] \\\n+\t\t [makefoo AabicdiAabiaai] \\\n+\t\t [makefoo AabicdiAabiabi] \\\n+\t\t [makefoo AabicdiBabicdi]]\n+\ttest_gdb_complete_multiple \"$cmd_prefix \" \"foo<A\" \"<a<b<int> >, \" \\\n+\t    $completion_list\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<A\"\n+\n+\t# \"foo<A>\" should give any function with one parameter of any type\n+\t# of A.  While the parameter list in the template should be ignored,\n+\t# the function's argument list should not be ignored.\n+\tset completion_list \\\n+\t    [list \\\n+\t\t [makefoo Aabiaai] \\\n+\t\t [makefoo Aabiabi] \\\n+\t\t [makefoo Aabicdi]]\n+\ttest_gdb_complete_multiple \"$cmd_prefix \" \"foo<A>\" \\\n+\t    \"(A<a<b<int> >, \" $completion_list\n+\tcheck_bp_locations_match_list \"$cmd_prefix foo<A>\" $completion_list\n+\n+\t# \"foo<A,\" should complete to any function with more than one\n+\t# parameter where the first parameter is any type of A.  Insufficient\n+\t# location to set breakpoints.\n+\tset completion_list \\\n+\t    [list \\\n+\t\t [makefoo AabicdiAabiaai] \\\n+\t\t [makefoo AabicdiAabiabi] \\\n+\t\t [makefoo AabicdiBabicdi]]\n+\ttest_gdb_complete_multiple \"$cmd_prefix \" \"foo<A,\" \" \" \\\n+\t    $completion_list\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<A,\"\n+\n+\t# \"foo<A<a<b<int>, a\" should give all completions starting with\n+\t# \"Aabia\" but it is insufficient to set breakpoints.\n+\tset completion_list \\\n+\t    [list \\\n+\t\t [makefoo Aabiaai] \\\n+\t\t [makefoo Aabiabi]]\n+\ttest_gdb_complete_multiple \"$cmd_prefix \" \"foo<A<a<b<int> >, a\" \\\n+\t    \"<\" $completion_list\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<A<a<b<int> >, a\"\n+\n+\t# \"foo<A<a<b<int>, a<\" should yield the same results as above.\n+\ttest_gdb_complete_multiple \"$cmd_prefix \" \"foo<A<a<b<int> >, a<\" \\\n+\t    \"\" $completion_list\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<A<a<b<int> >, a<\"\n+\n+\t# \"foo<A<a<b<int>, a<a\" is unique but insufficient to set a\n+\t# breakpoint.  This has an ignored template parameter list, so\n+\t# the completion will contain an ignored list (\"a<a>\")\n+\ttest_gdb_complete_unique \"$cmd_prefix foo<A<a<b<int> >, a<a\" \\\n+\t    \"$cmd_prefix [makefoo Aabiaai]\"\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<A<b<int> >, a<a\"\n+\n+\t# \"foo<A<a<b<int>, a<b\" is also unique.  Same parameter ignoring\n+\t# happens here, too (except \"a<b>\").\n+\ttest_gdb_complete_unique \"$cmd_prefix foo<A<a<b<int> >, a<b\" \\\n+\t    \"$cmd_prefix [makefoo Aabiabi]\"\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<A<a<b<int> >, a<b\"\n+\n+\t# \"foo<B\" is unique but insufficient to set a breakpoint.\n+\ttest_gdb_complete_unique \"$cmd_prefix foo<B\" \\\n+\t    \"$cmd_prefix [makefoo Babicdi]\"\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<B\"\n+\n+\t# \"foo<B>\" yields the same unique result and sets a breakpoint.\n+\t# Since the input skips the parameter list, so does the completion.\n+\ttest_gdb_complete_unique \"$cmd_prefix foo<B>\" \\\n+\t    \"$cmd_prefix foo<B>(B<a<b<int> >, c<d<int> > >)\"\n+\tcheck_bp_locations_match_list \"$cmd_prefix foo<B>\" \\\n+\t    [list [makefoo Babicdi]]\n+\n+\t# \"foo<B,\" should return no completions and no breakpoints.\n+\ttest_gdb_complete_none \"$cmd_prefix foo<B,\"\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<B,\"\n+\n+\t# \"foo<n::\" should yield only the functions starting with\n+\t# \"n\" and \"N\" and no breakpoints.\n+\tset completion_list \\\n+\t    [list \\\n+\t\t [makefoo NAnanbNBnanb] \\\n+\t\t [makefoo nanb]]\n+\ttest_gdb_complete_multiple \"$cmd_prefix \" \"foo<n::\" \"\" \\\n+\t    $completion_list\n+\tcheck_setting_bp_fails \"$cmd_prefix foo<n::\"\n+\n+\t# \"foo<A<a, c> >\" is unique and sets a breakpoint.\n+\t# Multiple template parameter lists are skipped, so GDB will ignore\n+\t# them in the completion.\n+\ttest_gdb_complete_unique \"$cmd_prefix foo<A<a, c> >\" \\\n+\t    \"$cmd_prefix foo<A<a, c> >(A<a<b<int> >, c<d<int> > >)\"\n+\tcheck_bp_locations_match_list \"$cmd_prefix foo<A<a, c> >\" \\\n+\t    [list [makefoo Aabicdi]]\n+    }\n+}\n+\n+# Helper for template-class-with-method to build completion lists.\n+\n+proc makem {arglist_list} {\n+    set completion_list {}\n+    foreach arglist $arglist_list {\n+\tlappend completion_list \"[maketype $arglist]::method()\"\n+    }\n+    return $completion_list\n+}\n+\n+# Returns a list of elements that look like\n+#   void TYPE::method()\n+# where TYPE is derived from each arglist in ARGLIST_LIST.\n+\n+proc test_makem_1 {arglist_list expected_list} {\n+    set result [makem $arglist_list]\n+    send_log \"makem $arglist = $result\\n\"\n+    send_log \"expecting $expected_list\\n\"\n+\n+    # Do list equality via canonical strings.\n+    if {[expr {[list {*}$expected_list] eq [list {*}$result]}]} {\n+\tpass \"makem unit test: $arglist\"\n+    } else {\n+\tfail \"makem unit test: $arglist\"\n+    }\n+}\n+\n+# Unit tests for makem.\n+\n+proc test_makem {} {\n+    test_makem_1 ai {\"a<int>::method()\"}\n+    test_makem_1 bi {\"b<int>::method()\"}\n+    test_makem_1 {ai bi} {\"a<int>::method()\" \"b<int>::method()\"}\n+    test_makem_1 {Aaiaai Bbibbi abi cdi} {\n+\t\"A<a<int>, a<a<int> > >::method()\"\n+\t\"B<b<int>, b<b<int> > >::method()\"\n+\t\"a<b<int> >::method()\"\n+\t\"c<d<int> >::method()\"\n+    }\n+}\n+\n+# Test class template containing a (non-templated) method called \"method.\"\n+\n+proc_with_prefix template-class-with-method {} {\n+\n+    foreach {type type_list} \\\n+\t[list \\\n+\t     \"\" {aai abi cci cdi Aabicdi Aabiaai Aabiabi Babicdi} \\\n+\t     \"a\" {aai abi} \\\n+\t     \"b\" {} \\\n+\t     \"c\" {cci cdi} \\\n+\t     \"A\" {Aabicdi Aabiaai Aabiabi} \\\n+\t     \"B\" {Babicdi} \\\n+\t     \"A<a, a>\" {Aabiaai Aabiabi} \\\n+\t     \"A<a<b>, c>\" {Aabicdi}\\\n+\t     \"A<a, d>\" {} \\\n+\t     \"B<a, a>\" {} \\\n+\t     \"B<a, b>\" {} \\\n+\t     \"B<a, c>\" {Babicdi}] \\\n+\t{\n+\t    foreach cmd_prefix {\"b\" \"b -function\"} {\n+\t\tset c \"$cmd_prefix \"\n+\t\tif {$type != \"\"} {\n+\t\t    append c \"${type}::\"\n+\t\t}\n+\t\tappend c \"method\"\n+\n+\t\tif {[llength $type_list] > 0} {\n+\t\t    test_gdb_complete_unique $c \"${c}()\"\n+\t\t    check_bp_locations_match_list $c [makem $type_list]\n+\t\t} else {\n+\t\t    test_gdb_complete_none $c\n+\t\t}\n+\t    }\n+\t}\n+}\n+\n # Test completion of a const-overloaded funtion (const-overload).\n # Note that \"const\" appears after the function/method parameters.\n \n@@ -947,6 +1370,10 @@ proc test_driver {} {\n     overload-3\n     template-overload\n     template-ret-type\n+    #test_makefoo\n+    template-function-foo\n+    #test_makem\n+    template-class-with-method\n     const-overload\n     const-overload-quoted\n     append-end-quote-char-when-unambiguous"
    },
    {
      "sha": "78e5a552173ca10052d3e8c4ee507a5acd8fe67f",
      "filename": "gdb/testsuite/gdb.linespec/cpls-ops.exp",
      "status": "modified",
      "additions": 23,
      "deletions": 30,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.linespec/cpls-ops.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.linespec/cpls-ops.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.linespec/cpls-ops.exp?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -248,47 +248,40 @@ proc test_operator_ambiguous {class_name opn cls} {\n \ttest_gdb_complete_multiple \\\n \t    \"$cmd_prefix \" \"$linespec_noparams\" \"\" $location_list\n \n-\t# Setting the breakpoint doesn't create a breakpoint location\n-\t# for the template, because immediately after\n-\t# \"operator()/operator[]\" we have the template parameters, not\n-\t# the parameter list.\n-\tset location_list \\\n-\t    [list \\\n-\t\t \"${class_name}::operator${opn}${cls}(int)\" \\\n-\t\t \"${class_name}::operator${opn}${cls}(long)\"]\n-\tif {$opn == \"(\"} {\n-\t    set location_list \\\n-\t\t[concat \\\n-\t\t     [list \"${class_name}::operator${opn}${cls}()\"] \\\n-\t\t     $location_list]\n-\t}\n \tcheck_bp_locations_match_list \"$cmd_prefix $linespec_noparams\" \\\n \t    $location_list\n \tcheck_bp_locations_match_list \"$cmd_prefix $linespec_noparams<int>\" \\\n \t    [list \"${class_name}::operator${opn}${cls}<int>(int*)\"]\n \n \t# Test the template version.  Test both with and without\n \t# return type.\n-\ttest_gdb_complete_unique \\\n-\t    \"$cmd_prefix ${class_name}::operator${opn}${cls}<int>(in\" \\\n-\t    \"$cmd_prefix ${class_name}::operator${opn}${cls}<int>(int*)\"\n-\tcheck_bp_locations_match_list \\\n-\t    \"$cmd_prefix ${class_name}::operator${opn}${cls}<int>(int*)\" \\\n-\t    [list \"${class_name}::operator${opn}${cls}<int>(int*)\"]\n-\ttest_gdb_complete_unique \\\n-\t    \"$cmd_prefix void ${class_name}::operator${opn}${cls}<int>(in\" \\\n-\t    \"$cmd_prefix void ${class_name}::operator${opn}${cls}<int>(int*)\"\n-\tcheck_bp_locations_match_list \\\n-\t    \"$cmd_prefix void ${class_name}::operator${opn}${cls}<int>(int*)\" \\\n-\t    [list \"${class_name}::operator${opn}${cls}<int>(int*)\"]\n+\tset f \"${class_name}::operator\"\n+\tforeach ws1 {\"\" \" \"} {\n+\t    foreach ws2 {\"\" \" \"} {\n+\t\tforeach ws3 {\"\" \" \"} {\n+\t\t    test_gdb_complete_unique \\\n+\t\t\t\"$cmd_prefix ${f}${opn}${ws1}${cls}<${ws2}int${ws3}>(in\" \\\n+\t\t\t\"$cmd_prefix ${f}${opn}${ws1}${cls}<${ws2}int${ws3}>(int*)\"\n+\t\t    check_bp_locations_match_list \\\n+\t\t\t\"$cmd_prefix ${f}${opn}${ws1}${cls}<${ws2}int${ws3}>(int*)\" \\\n+\t\t\t[list \"${f}${opn}${cls}<int>(int*)\"]\n+\t\t    test_gdb_complete_unique \\\n+\t\t\t\"$cmd_prefix void ${f}${opn}${ws1}${cls}<${ws2}int${ws3}>(in\" \\\n+\t\t\t\"$cmd_prefix void ${f}${opn}${ws1}${cls}<${ws2}int${ws3}>(int*)\"\n+\t\t    check_bp_locations_match_list \\\n+\t\t\t\"$cmd_prefix void ${f}${opn}${ws1}${cls}<${ws2}int${ws3}>(int*)\" \\\n+\t\t\t[list \"${f}${opn}${cls}<int>(int*)\"]\n+\t\t}\n+\t    }\n+\t}\n \n \t# Add extra spaces.\n \ttest_gdb_complete_unique \\\n-\t    \"$cmd_prefix ${class_name}::operator ${opn} ${cls} ( in\" \\\n-\t    \"$cmd_prefix ${class_name}::operator ${opn} ${cls} ( int)\"\n+\t    \"$cmd_prefix ${class_name}::operator ${opn} ${cls} ( lo\" \\\n+\t    \"$cmd_prefix ${class_name}::operator ${opn} ${cls} ( long)\"\n \tcheck_bp_locations_match_list \\\n-\t    \"$cmd_prefix ${class_name}::operator ${opn} ${cls} ( int )\" \\\n-\t    [list \"${class_name}::operator${opn}${cls}(int)\"]\n+\t    \"$cmd_prefix ${class_name}::operator ${opn} ${cls} ( long )\" \\\n+\t    [list \"${class_name}::operator${opn}${cls}(long)\"]\n     }\n }\n "
    },
    {
      "sha": "d96c1dd721131a3bfade8ca4f47fbb90d561956b",
      "filename": "gdb/testsuite/gdb.linespec/cpls.cc",
      "status": "modified",
      "additions": 109,
      "deletions": 1,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.linespec/cpls.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/testsuite/gdb.linespec/cpls.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.linespec/cpls.cc?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -146,7 +146,7 @@ namespace ns_overload3_test\n   }\n }\n \n-/* Code for the template-overload tests.  */\n+/* Code for the template-function_foo (template parameter completion) tests.  */\n \n template <typename T>\n struct template_struct\n@@ -163,6 +163,113 @@ T template_struct<T>::template_overload_fn (T t)\n template_struct<int> template_struct_int;\n template_struct<long> template_struct_long;\n \n+/* Code for the template-parameter-overload test.  */\n+\n+template <typename T>\n+void foo (T c) {}\n+\n+template <typename T1, typename T2>\n+void foo (T1 a, T2 b) {}\n+\n+template <typename T>\n+struct a\n+{\n+  void method () {}\n+};\n+\n+template <typename T>\n+struct b\n+{\n+  void method () {}\n+};\n+\n+template <typename T>\n+struct c\n+{\n+  void method () {}\n+};\n+\n+template <typename T>\n+struct d\n+{\n+  void method () {};\n+};\n+\n+template <typename T1, typename T2>\n+struct A\n+{\n+  void method () {}\n+};\n+\n+template <typename T1, typename T2>\n+struct B\n+{\n+  void method () {}\n+};\n+\n+namespace n\n+{\n+  struct na {};\n+  struct nb {};\n+\n+  template <typename T1, typename T2>\n+  struct NA {};\n+\n+  template <typename T1, typename T2>\n+  struct NB {};\n+};\n+\n+static void\n+template_function_foo ()\n+{\n+  a<a<int>> aa;\n+  aa.method ();\n+  a<b<int>> ab;\n+  ab.method ();\n+  c<c<int>> cc;\n+  cc.method ();\n+  c<d<int>> cd;\n+  cd.method ();\n+  foo (aa);\n+  foo (ab);\n+  foo (cc);\n+  foo (cd);\n+  foo (aa, ab);\n+  foo (aa, cc);\n+  foo (aa, cd);\n+\n+  A<a<b<int>>, c<d<int>>> Aabcd;\n+  Aabcd.method ();\n+  foo (Aabcd);\n+\n+  A<a<b<int>>, a<a<int>>> Aabaa;\n+  Aabaa.method ();\n+  foo (Aabaa);\n+\n+  A<a<b<int>>, a<b<int>>> Aabab;\n+  Aabab.method ();\n+  foo (Aabab);\n+\n+  B<a<b<int>>, c<d<int>>> Babcd;\n+  Babcd.method ();\n+  foo (Babcd);\n+\n+  foo (Aabcd, Babcd);\n+  foo (Aabcd, Aabaa);\n+  foo (Aabcd, Aabab);\n+\n+  n::na na;\n+  n::nb nb;\n+  foo (na, nb);\n+  a<n::na> ana;\n+  b<n::nb> bnb;\n+  foo (ana, bnb);\n+\n+  n::NA<n::na, n::nb> NAnanb;\n+  n::NB<n::na, n::nb> Nbnanb;\n+  foo (NAnanb, Nbnanb);\n+}\n+\n /* Code for the template2-ret-type tests.  */\n \n template <typename T>\n@@ -381,6 +488,7 @@ main ()\n   template2_struct_inst.template2_fn<int, int> ();\n   template_struct_int.template_overload_fn(0);\n   template_struct_long.template_overload_fn(0);\n+  template_function_foo ();\n \n   return 0;\n }"
    },
    {
      "sha": "a8d6c96386da31d34b86994311403ea8ab15a4a9",
      "filename": "gdb/utils.c",
      "status": "modified",
      "additions": 81,
      "deletions": 1,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/utils.c?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -2252,13 +2252,45 @@ skip_abi_tag (const char **name)\n   return false;\n }\n \n+/* If *NAME points at a template parameter list, skip it and return true.\n+   Otherwise do nothing and return false.  */\n+\n+static bool\n+skip_template_parameter_list (const char **name)\n+{\n+  const char *p = *name;\n+\n+  if (*p == '<')\n+    {\n+      const char *template_param_list_end = find_toplevel_char (p + 1, '>');\n+\n+      if (template_param_list_end == NULL)\n+\treturn false;\n+\n+      p = template_param_list_end + 1;\n+\n+      /* Skip any whitespace that might occur after the closing of the\n+\t parameter list, but only if it is the end of parameter list.  */\n+      const char *q = p;\n+      while (ISSPACE (*q))\n+\t++q;\n+      if (*q == '>')\n+\tp = q;\n+      *name = p;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* See utils.h.  */\n \n int\n strncmp_iw_with_mode (const char *string1, const char *string2,\n \t\t      size_t string2_len, strncmp_iw_mode mode,\n \t\t      enum language language,\n-\t\t      completion_match_for_lcd *match_for_lcd)\n+\t\t      completion_match_for_lcd *match_for_lcd,\n+\t\t      bool ignore_template_params)\n {\n   const char *string1_start = string1;\n   const char *end_str2 = string2 + string2_len;\n@@ -2308,6 +2340,48 @@ strncmp_iw_with_mode (const char *string1, const char *string2,\n \t    string1++;\n \t}\n \n+      /* Skip template parameters in STRING1 if STRING2 does not contain\n+\t any.  E.g.:\n+\n+\t Case 1: User is looking for all functions named \"foo\".\n+\t string1: foo <...> (...)\n+\t string2: foo\n+\n+\t Case 2: User is looking for all methods named \"foo\" in all template\n+\t class instantiations.\n+\t string1: Foo<...>::foo <...> (...)\n+\t string2: Foo::foo (...)\n+\n+\t Case 3: User is looking for a specific overload of a template\n+\t function or method.\n+\t string1: foo<...>\n+\t string2: foo(...)\n+\n+\t Case 4: User is looking for a specific overload of a specific\n+\t template instantiation.\n+\t string1: foo<A> (...)\n+\t string2: foo<B> (...)\n+\n+\t Case 5: User is looking wild parameter match.\n+\t string1: foo<A<a<b<...> > > > (...)\n+\t string2: foo<A\n+      */\n+      if (language == language_cplus && ignore_template_params\n+\t  && *string1 == '<' && *string2 != '<')\n+\t{\n+\t  /* Skip any parameter list in STRING1.  */\n+\t  const char *template_start = string1;\n+\n+\t  if (skip_template_parameter_list (&string1))\n+\t    {\n+\t      /* Don't mark the parameter list ignored if the user didn't\n+\t\t try to ignore it.  [Case #5 above]  */\n+\t      if (*string2 != '\\0'\n+\t\t  && match_for_lcd != NULL && template_start != string1)\n+\t\tmatch_for_lcd->mark_ignored_range (template_start, string1);\n+\t    }\n+\t}\n+\n       if (*string1 == '\\0' || string2 == end_str2)\n \tbreak;\n \n@@ -2416,6 +2490,12 @@ strncmp_iw_with_mode (const char *string1, const char *string2,\n \t\t    break;\n \t\t  if (*string1 == '(' || *string2 == '(')\n \t\t    break;\n+\n+\t\t  /* If STRING1 or STRING2 starts with a template\n+\t\t     parameter list, break out of operator processing.  */\n+\t\t  skip_ws (string1, string2, end_str2);\n+\t\t  if (*string1 == '<' || *string2 == '<')\n+\t\t    break;\n \t\t}\n \n \t      continue;"
    },
    {
      "sha": "d6080012aa697c4a24ea66d3b122d31e3b27c9aa",
      "filename": "gdb/utils.h",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64a9760601d3d8761fcf0aae121e69ca0cae1a9c/gdb/utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/utils.h?ref=64a9760601d3d8761fcf0aae121e69ca0cae1a9c",
      "patch": "@@ -63,11 +63,14 @@ enum class strncmp_iw_mode\n \n    MATCH_FOR_LCD is passed down so that the function can mark parts of\n    the symbol name as ignored for completion matching purposes (e.g.,\n-   to handle abi tags).  */\n+   to handle abi tags).  If IGNORE_TEMPLATE_PARAMS is true, all template\n+   parameter lists will be ignored when language is C++.  */\n+\n extern int strncmp_iw_with_mode\n   (const char *string1, const char *string2, size_t string2_len,\n    strncmp_iw_mode mode, enum language language,\n-   completion_match_for_lcd *match_for_lcd = NULL);\n+   completion_match_for_lcd *match_for_lcd = NULL,\n+   bool ignore_template_params = false);\n \n /* Do a strncmp() type operation on STRING1 and STRING2, ignoring any\n    differences in whitespace.  STRING2_LEN is STRING2's length."
    }
  ]
}