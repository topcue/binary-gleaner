{
  "sha": "b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
  "node_id": "C_kwDOANOeidoAKGIzYWE4MGI0NWM0ZjQ2MDI5ZWZlYjIwNGJiOWYyZDJjNDI3OGEwZTU",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-11-09T13:25:42Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-11-09T13:25:42Z"
    },
    "message": "Add --unicode option to control how unicode characters are handled by display tools.\n\n\t* nm.c: Add --unicode option to control how unicode characters are\n\thandled.\n\t* objdump.c: Likewise.\n\t* readelf.c: Likewise.\n\t* strings.c: Likewise.\n\t* binutils.texi: Document the new feature.\n\t* NEWS: Document the new feature.\n\t* testsuite/binutils-all/unicode.exp: New file.\n\t* testsuite/binutils-all/nm.hex.unicode\n\t* testsuite/binutils-all/strings.escape.unicode\n\t* testsuite/binutils-all/objdump.highlight.unicode\n\t* testsuite/binutils-all/readelf.invalid.unicode",
    "tree": {
      "sha": "843d2678476437a35e31a6fef3ff905781fc8d8b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/843d2678476437a35e31a6fef3ff905781fc8d8b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "024120b6ee344843b7d02e83e6fc0d5b33a3cd29",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/024120b6ee344843b7d02e83e6fc0d5b33a3cd29",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/024120b6ee344843b7d02e83e6fc0d5b33a3cd29"
    }
  ],
  "stats": {
    "total": 1512,
    "additions": 1409,
    "deletions": 103
  },
  "files": [
    {
      "sha": "6850edb9dd54dc052ac1e47f64a46d9d1cd4b79f",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
      "patch": "@@ -1,3 +1,18 @@\n+2021-11-09  Nick Clifton  <nickc@redhat.com>\n+\n+\t* nm.c: Add --unicode option to control how unicode characters are\n+\thandled.\n+\t* objdump.c: Likewise.\n+\t* readelf.c: Likewise.\n+\t* strings.c: Likewise.\n+\t* binutils.texi: Document the new feature.\n+\t* NEWS: Document the new feature.\n+\t* testsuite/binutils-all/unicode.exp: New file.\n+\t* testsuite/binutils-all/nm.hex.unicode\n+\t* testsuite/binutils-all/strings.escape.unicode\n+\t* testsuite/binutils-all/objdump.highlight.unicode\n+\t* testsuite/binutils-all/readelf.invalid.unicode\n+\n 2021-11-03  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf.c (display_debug_loc): Use section name in warnings."
    },
    {
      "sha": "f948d34f0918084bcaada6eada32fb2de9eb14ca",
      "filename": "binutils/NEWS",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/NEWS?ref=b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
      "patch": "@@ -2,6 +2,15 @@\n \n * Add support for the LoongArch instruction set.\n \n+* Tools which display symbols or strings (readelf, strings, nm, objdump)\n+  have a new command line option which controls how unicode characters are\n+  handled.  By default they are treated as normal for the tool.  Using\n+  --unicode=locale will display them according to the current locale.\n+  Using --unicode=hex will display them as hex byte values, whilst\n+  --unicode=escape will display them as escape sequences.  In addition\n+  using --unicode=highlight will display them as unicode escape sequences\n+  highlighted in red (if supported by the output device).\n+\n Changes in 2.37:\n \n * The readelf tool has a new command line option which can be used to specify"
    },
    {
      "sha": "5de0631f3f4dc567ed4d76b9737c447f5d40e7c2",
      "filename": "binutils/doc/binutils.texi",
      "status": "modified",
      "additions": 78,
      "deletions": 0,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/doc/binutils.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/doc/binutils.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/doc/binutils.texi?ref=b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
      "patch": "@@ -812,6 +812,7 @@ nm [@option{-A}|@option{-o}|@option{--print-file-name}]\n    [@option{-s}|@option{--print-armap}]\n    [@option{-t} @var{radix}|@option{--radix=}@var{radix}]\n    [@option{-u}|@option{--undefined-only}]\n+   [@option{-U} @var{method}] [@option{--unicode=}@var{method}]\n    [@option{-V}|@option{--version}]\n    [@option{-X 32_64}]\n    [@option{--defined-only}]\n@@ -1132,6 +1133,21 @@ Use @var{radix} as the radix for printing the symbol values.  It must be\n @cindex undefined symbols\n Display only undefined symbols (those external to each object file).\n \n+@item -U @var{[d|i|l|e|x|h]}\n+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}\n+Controls the display of UTF-8 encoded mulibyte characters in strings.\n+The default (@option{--unicode=default}) is to give them no special\n+treatment.  The @option{--unicode=locale} option displays the sequence\n+in the current locale, which may or may not support them.  The options\n+@option{--unicode=hex} and @option{--unicode=invalid} display them as\n+hex byte sequences enclosed by either angle brackets or curly braces.\n+\n+The @option{--unicode=escape} option displays them as escape sequences\n+(@var{\\uxxxx}) and the @option{--unicode=highlight} option displays\n+them as escape sequences highlighted in red (if supported by the\n+output device).  The colouring is intended to draw attention to the\n+presence of unicode sequences where they might not be expected.\n+\n @item -V\n @itemx --version\n Show the version number of @command{nm} and exit.\n@@ -2247,6 +2263,7 @@ objdump [@option{-a}|@option{--archive-headers}]\n         [@option{--prefix-strip=}@var{level}]\n         [@option{--insn-width=}@var{width}]\n         [@option{--visualize-jumps[=color|=extended-color|=off]}\n+        [@option{-U} @var{method}] [@option{--unicode=}@var{method}]\n         [@option{-V}|@option{--version}]\n         [@option{-H}|@option{--help}]\n         @var{objfile}@dots{}\n@@ -2921,6 +2938,21 @@ When displaying symbols include those which the target considers to be\n special in some way and which would not normally be of interest to the\n user.\n \n+@item -U @var{[d|i|l|e|x|h]}\n+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}\n+Controls the display of UTF-8 encoded mulibyte characters in strings.\n+The default (@option{--unicode=default}) is to give them no special\n+treatment.  The @option{--unicode=locale} option displays the sequence\n+in the current locale, which may or may not support them.  The options\n+@option{--unicode=hex} and @option{--unicode=invalid} display them as\n+hex byte sequences enclosed by either angle brackets or curly braces.\n+\n+The @option{--unicode=escape} option displays them as escape sequences\n+(@var{\\uxxxx}) and the @option{--unicode=highlight} option displays\n+them as escape sequences highlighted in red (if supported by the\n+output device).  The colouring is intended to draw attention to the\n+presence of unicode sequences where they might not be expected.\n+\n @item -V\n @itemx --version\n Print the version number of @command{objdump} and exit.\n@@ -3197,6 +3229,7 @@ strings [@option{-afovV}] [@option{-}@var{min-len}]\n         [@option{-n} @var{min-len}] [@option{--bytes=}@var{min-len}]\n         [@option{-t} @var{radix}] [@option{--radix=}@var{radix}]\n         [@option{-e} @var{encoding}] [@option{--encoding=}@var{encoding}]\n+        [@option{-U} @var{method}] [@option{--unicode=}@var{method}]\n         [@option{-}] [@option{--all}] [@option{--print-file-name}]\n         [@option{-T} @var{bfdname}] [@option{--target=}@var{bfdname}]\n         [@option{-w}] [@option{--include-all-whitespace}]\n@@ -3288,6 +3321,28 @@ single-8-bit-byte characters, @samp{b} = 16-bit bigendian, @samp{l} =\n littleendian.  Useful for finding wide character strings. (@samp{l}\n and @samp{b} apply to, for example, Unicode UTF-16/UCS-2 encodings).\n \n+@item -U @var{[d|i|l|e|x|h]}\n+@itemx --unicode=@var{[default|invalid|locale|escape|hex|highlight]}\n+Controls the display of UTF-8 encoded mulibyte characters in strings.\n+The default (@option{--unicode=default}) is to give them no special\n+treatment, and instead rely upon the setting of the\n+@option{--encoding} option.  The other values for this option\n+automatically enable @option{--encoding=S}.\n+\n+The @option{--unicode=invalid} option treats them as non-graphic\n+characters and hence not part of a valid string.  All the remaining\n+options treat them as valid string characters.\n+\n+The @option{--unicode=locale} option displays them in the current\n+locale, which may or may not support UTF-8 encoding.  The\n+@option{--unicode=hex} option displays them as hex byte sequences\n+enclosed between @var{<>} characters.  The @option{--unicode=escape}\n+option displays them as escape sequences (@var{\\uxxxx}) and the\n+@option{--unicode=highlight} option displays them as escape sequences\n+highlighted in red (if supported by the output device).  The colouring\n+is intended to draw attention to the presence of unicode sequences\n+where they might not be expected.\n+\n @item -T @var{bfdname}\n @itemx --target=@var{bfdname}\n @cindex object code format\n@@ -4796,6 +4851,7 @@ readelf [@option{-a}|@option{--all}]\n         [@option{--demangle@var{=style}}|@option{--no-demangle}]\n         [@option{--quiet}]\n         [@option{--recurse-limit}|@option{--no-recurse-limit}]\n+        [@option{-U} @var{method}|@option{--unicode=}@var{method}]\n         [@option{-n}|@option{--notes}]\n         [@option{-r}|@option{--relocs}]\n         [@option{-u}|@option{--unwind}]\n@@ -4962,6 +5018,28 @@ necessary in order to demangle truly complicated names.  Note however\n that if the recursion limit is disabled then stack exhaustion is\n possible and any bug reports about such an event will be rejected.\n \n+@item -U @var{[d|i|l|e|x|h]}\n+@itemx --unicode=[default|invalid|locale|escape|hex|highlight]\n+Controls the display of non-ASCII characters in identifier names.\n+The default (@option{--unicode=locale} or @option{--unicode=default}) is\n+to treat them as multibyte characters and display them in the current\n+locale.  All other versions of this option treat the bytes as UTF-8\n+encoded values and attempt to interpret them.  If they cannot be\n+interpreted or if the @option{--unicode=invalid} option is used then\n+they are displayed as a sequence of hex bytes, encloses in curly\n+parethesis characters.\n+\n+Using the @option{--unicode=escape} option will display the characters\n+as as unicode escape sequences (@var{\\uxxxx}).  Using the\n+@option{--unicode=hex} will display the characters as hex byte\n+sequences enclosed between angle brackets.\n+\n+Using the @option{--unicode=highlight} will display the characters as \n+unicode escape sequences but it will also highlighted them in red,\n+assuming that colouring is supported by the output device.  The\n+colouring is intended to draw attention to the presence of unicode\n+sequences when they might not be expected.\n+\n @item -e\n @itemx --headers\n Display all the headers in the file.  Equivalent to @option{-h -l -S}."
    },
    {
      "sha": "e7ed6f829af1b003010edc87c807f97d9706e352",
      "filename": "binutils/nm.c",
      "status": "modified",
      "additions": 227,
      "deletions": 1,
      "changes": 228,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/nm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/nm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/nm.c?ref=b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
      "patch": "@@ -38,6 +38,11 @@\n #include \"bucomm.h\"\n #include \"plugin-api.h\"\n #include \"plugin.h\"\n+#include \"safe-ctype.h\"\n+\n+#ifndef streq\n+#define streq(a,b) (strcmp ((a),(b)) == 0)\n+#endif\n \n /* When sorting by size, we use this structure to hold the size and a\n    pointer to the minisymbol.  */\n@@ -216,6 +221,18 @@ static const char *plugin_target = NULL;\n static bfd *lineno_cache_bfd;\n static bfd *lineno_cache_rel_bfd;\n \n+typedef enum unicode_display_type\n+{\n+  unicode_default = 0,\n+  unicode_locale,\n+  unicode_escape,\n+  unicode_hex,\n+  unicode_highlight,\n+  unicode_invalid\n+} unicode_display_type;\n+\n+static unicode_display_type unicode_display = unicode_default;\n+\n enum long_option_values\n {\n   OPTION_TARGET = 200,\n@@ -260,6 +277,7 @@ static struct option long_options[] =\n   {\"target\", required_argument, 0, OPTION_TARGET},\n   {\"defined-only\", no_argument, &defined_only, 1},\n   {\"undefined-only\", no_argument, &undefined_only, 1},\n+  {\"unicode\", required_argument, NULL, 'U'},\n   {\"version\", no_argument, &show_version, 1},\n   {\"with-symbol-versions\", no_argument, &with_symbol_versions, 1},\n   {\"without-symbol-versions\", no_argument, &with_symbol_versions, 0},\n@@ -313,6 +331,8 @@ usage (FILE *stream, int status)\n   -t, --radix=RADIX      Use RADIX for printing symbol values\\n\\\n       --target=BFDNAME   Specify the target object format as BFDNAME\\n\\\n   -u, --undefined-only   Display only undefined symbols\\n\\\n+  -U {d|s|i|x|e|h}       Specify how to treat UTF-8 encoded unicode characters\\n\\\n+      --unicode={default|show|invalid|hex|escape|highlight}\\n\\\n       --with-symbol-versions  Display version strings after symbol names\\n\\\n   -X 32_64               (ignored)\\n\\\n   @FILE                  Read options from FILE\\n\\\n@@ -432,6 +452,187 @@ get_coff_symbol_type (const struct internal_syment *sym)\n   return bufp;\n }\n \f\n+/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.\n+   The conversion format is controlled by the unicode_display variable.\n+   Returns the number of characters added to OUT.\n+   Returns the number of bytes consumed from IN in CONSUMED.\n+   Always consumes at least one byte and displays at least one character.  */\n+   \n+static unsigned int\n+display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)\n+{\n+  char *        orig_out = out;\n+  unsigned int  nchars = 0;\n+  unsigned int j;\n+\n+  if (unicode_display == unicode_default)\n+    goto invalid;\n+\n+  if (in[0] < 0xc0)\n+    goto invalid;\n+\n+  if ((in[1] & 0xc0) != 0x80)\n+    goto invalid;\n+\n+  if ((in[0] & 0x20) == 0)\n+    {\n+      nchars = 2;\n+      goto valid;\n+    }\n+\n+  if ((in[2] & 0xc0) != 0x80)\n+    goto invalid;\n+\n+  if ((in[0] & 0x10) == 0)\n+    {\n+      nchars = 3;\n+      goto valid;\n+    }\n+\n+  if ((in[3] & 0xc0) != 0x80)\n+    goto invalid;\n+\n+  nchars = 4;\n+\n+ valid:\n+  switch (unicode_display)\n+    {\n+    case unicode_locale:\n+      /* Copy the bytes into the output buffer as is.  */\n+      memcpy (out, in, nchars);\n+      out += nchars;\n+      break;\n+\n+    case unicode_invalid:\n+    case unicode_hex:\n+      out += sprintf (out, \"%c\", unicode_display == unicode_hex ? '<' : '{');\n+      out += sprintf (out, \"0x\");\n+      for (j = 0; j < nchars; j++)\n+\tout += sprintf (out, \"%02x\", in [j]);\n+      out += sprintf (out, \"%c\", unicode_display == unicode_hex ? '>' : '}');\n+      break;\n+      \n+    case unicode_highlight:\n+      if (isatty (1))\n+\tout += sprintf (out, \"\\x1B[31;47m\"); /* Red.  */\n+      /* Fall through.  */\n+    case unicode_escape:\n+      switch (nchars)\n+\t{\n+\tcase 2:\n+\t  out += sprintf (out, \"\\\\u%02x%02x\",\n+\t\t  ((in[0] & 0x1c) >> 2), \n+\t\t  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));\n+\t  break;\n+\n+\tcase 3:\n+\t  out += sprintf (out, \"\\\\u%02x%02x\",\n+\t\t  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),\n+\t\t  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));\n+\t  break;\n+\n+\tcase 4:\n+\t  out += sprintf (out, \"\\\\u%02x%02x%02x\",\n+\t\t  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),\n+\t\t  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),\n+\t\t  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));\n+\t  break;\n+\tdefault:\n+\t  /* URG.  */\n+\t  break;\n+\t}\n+\n+      if (unicode_display == unicode_highlight && isatty (1))\n+\tout += sprintf (out, \"\\033[0m\"); /* Default colour.  */\n+      break;\n+\n+    default:\n+      /* URG */\n+      break;\n+    }\n+\n+  * consumed = nchars;\n+  return out - orig_out;\n+\n+ invalid:\n+  /* Not a valid UTF-8 sequence.  */\n+  *out = *in;\n+  * consumed = 1;\n+  return 1;\n+}\n+\n+/* Convert any UTF-8 encoded characters in NAME into the form specified by\n+   unicode_display.  Also converts control characters.  Returns a static\n+   buffer if conversion was necessary.\n+   Code stolen from objdump.c:sanitize_string().  */\n+\n+static const char *\n+convert_utf8 (const char * in)\n+{\n+  static char *  buffer = NULL;\n+  static size_t  buffer_len = 0;\n+  const char *   original = in;\n+  char *         out;\n+\n+  /* Paranoia.  */\n+  if (in == NULL)\n+    return \"\";\n+\n+  /* See if any conversion is necessary.\n+     In the majority of cases it will not be needed.  */\n+  do\n+    {\n+      unsigned char c = *in++;\n+\n+      if (c == 0)\n+\treturn original;\n+\n+      if (ISCNTRL (c))\n+\tbreak;\n+\n+      if (unicode_display != unicode_default && c >= 0xc0)\n+\tbreak;\n+    }\n+  while (1);\n+\n+  /* Copy the input, translating as needed.  */\n+  in = original;\n+  if (buffer_len < (strlen (in) * 9))\n+    {\n+      free ((void *) buffer);\n+      buffer_len = strlen (in) * 9;\n+      buffer = xmalloc (buffer_len + 1);\n+    }\n+\n+  out = buffer;\n+  do\n+    {\n+      unsigned char c = *in++;\n+\n+      if (c == 0)\n+\tbreak;\n+\n+      if (ISCNTRL (c))\n+\t{\n+\t  *out++ = '^';\n+\t  *out++ = c + 0x40;\n+\t}\n+      else if (unicode_display != unicode_default && c >= 0xc0)\n+\t{\n+\t  unsigned int num_consumed;\n+\n+\t  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);\n+\t  in += num_consumed - 1;\n+\t}\n+      else\n+\t*out++ = c;\n+    }\n+  while (1);\n+\n+  *out = 0;\n+  return buffer;\n+}\n+\n /* Print symbol name NAME, read from ABFD, with printf format FORM,\n    demangling it if requested.  */\n \n@@ -444,20 +645,27 @@ print_symname (const char *form, struct extended_symbol_info *info,\n \n   if (name == NULL)\n     name = info->sinfo->name;\n+\n   if (!with_symbol_versions\n       && bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n     {\n       atver = strchr (name, '@');\n       if (atver)\n \t*atver = 0;\n     }\n+\n   if (do_demangle && *name)\n     {\n       alloc = bfd_demangle (abfd, name, demangle_flags);\n       if (alloc != NULL)\n \tname = alloc;\n     }\n \n+  if (unicode_display != unicode_default)\n+    {\n+      name = convert_utf8 (name);\n+    }\n+\n   if (info != NULL && info->elfinfo && with_symbol_versions)\n     {\n       const char *version_string;\n@@ -1808,7 +2016,7 @@ main (int argc, char **argv)\n     fatal (_(\"fatal error: libbfd ABI mismatch\"));\n   set_default_bfd_target ();\n \n-  while ((c = getopt_long (argc, argv, \"aABCDef:gHhjJlnopPrSst:uvVvX:\",\n+  while ((c = getopt_long (argc, argv, \"aABCDef:gHhjJlnopPrSst:uU:vVvX:\",\n \t\t\t   long_options, (int *) 0)) != EOF)\n     {\n       switch (c)\n@@ -1901,6 +2109,24 @@ main (int argc, char **argv)\n \tcase 'u':\n \t  undefined_only = 1;\n \t  break;\n+\n+\tcase 'U':\n+\t  if (streq (optarg, \"default\") || streq (optarg, \"d\"))\n+\t    unicode_display = unicode_default;\n+\t  else if (streq (optarg, \"locale\") || streq (optarg, \"l\"))\n+\t    unicode_display = unicode_locale;\n+\t  else if (streq (optarg, \"escape\") || streq (optarg, \"e\"))\n+\t    unicode_display = unicode_escape;\n+\t  else if (streq (optarg, \"invalid\") || streq (optarg, \"i\"))\n+\t    unicode_display = unicode_invalid;\n+\t  else if (streq (optarg, \"hex\") || streq (optarg, \"x\"))\n+\t    unicode_display = unicode_hex;\n+\t  else if (streq (optarg, \"highlight\") || streq (optarg, \"h\"))\n+\t    unicode_display = unicode_highlight;\n+\t  else\n+\t    fatal (_(\"invalid argument to -U/--unicode: %s\"), optarg);\n+\t  break;\n+\n \tcase 'V':\n \t  show_version = 1;\n \t  break;"
    },
    {
      "sha": "20499aaba0f44e113664fb216b11efec9982f93c",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 204,
      "deletions": 31,
      "changes": 235,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
      "patch": "@@ -204,6 +204,18 @@ static const struct objdump_private_desc * const objdump_private_vectors[] =\n \n /* The list of detected jumps inside a function.  */\n static struct jump_info *detected_jumps = NULL;\n+\n+typedef enum unicode_display_type\n+{\n+  unicode_default = 0,\n+  unicode_locale,\n+  unicode_escape,\n+  unicode_hex,\n+  unicode_highlight,\n+  unicode_invalid\n+} unicode_display_type;\n+\n+static unicode_display_type unicode_display = unicode_default;\n \f\n static void usage (FILE *, int) ATTRIBUTE_NORETURN;\n static void\n@@ -330,6 +342,9 @@ usage (FILE *stream, int status)\n       fprintf (stream, _(\"\\\n   -w, --wide                     Format output for more than 80 columns\\n\"));\n       fprintf (stream, _(\"\\\n+  -U[d|l|i|x|e|h]                Controls the display of UTF-8 unicode characters\\n\\\n+  --unicode=[default|locale|invalid|hex|escape|highlight]\\n\"));\n+      fprintf (stream, _(\"\\\n   -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\\n\"));\n       fprintf (stream, _(\"\\\n       --start-address=ADDR       Only process data whose address is >= ADDR\\n\"));\n@@ -420,17 +435,23 @@ static struct option long_options[]=\n {\n   {\"adjust-vma\", required_argument, NULL, OPTION_ADJUST_VMA},\n   {\"all-headers\", no_argument, NULL, 'x'},\n-  {\"private-headers\", no_argument, NULL, 'p'},\n-  {\"private\", required_argument, NULL, 'P'},\n   {\"architecture\", required_argument, NULL, 'm'},\n   {\"archive-headers\", no_argument, NULL, 'a'},\n+#ifdef ENABLE_LIBCTF\n+  {\"ctf\", required_argument, NULL, OPTION_CTF},\n+  {\"ctf-parent\", required_argument, NULL, OPTION_CTF_PARENT},\n+#endif\n   {\"debugging\", no_argument, NULL, 'g'},\n   {\"debugging-tags\", no_argument, NULL, 'e'},\n   {\"demangle\", optional_argument, NULL, 'C'},\n   {\"disassemble\", optional_argument, NULL, 'd'},\n   {\"disassemble-all\", no_argument, NULL, 'D'},\n-  {\"disassembler-options\", required_argument, NULL, 'M'},\n   {\"disassemble-zeroes\", no_argument, NULL, 'z'},\n+  {\"disassembler-options\", required_argument, NULL, 'M'},\n+  {\"dwarf\", optional_argument, NULL, OPTION_DWARF},\n+  {\"dwarf-check\", no_argument, 0, OPTION_DWARF_CHECK},\n+  {\"dwarf-depth\", required_argument, 0, OPTION_DWARF_DEPTH},\n+  {\"dwarf-start\", required_argument, 0, OPTION_DWARF_START},\n   {\"dynamic-reloc\", no_argument, NULL, 'R'},\n   {\"dynamic-syms\", no_argument, NULL, 'T'},\n   {\"endian\", required_argument, NULL, OPTION_ENDIAN},\n@@ -440,45 +461,40 @@ static struct option long_options[]=\n   {\"full-contents\", no_argument, NULL, 's'},\n   {\"headers\", no_argument, NULL, 'h'},\n   {\"help\", no_argument, NULL, 'H'},\n+  {\"include\", required_argument, NULL, 'I'},\n   {\"info\", no_argument, NULL, 'i'},\n+  {\"inlines\", no_argument, 0, OPTION_INLINES},\n+  {\"insn-width\", required_argument, NULL, OPTION_INSN_WIDTH},\n   {\"line-numbers\", no_argument, NULL, 'l'},\n-  {\"no-show-raw-insn\", no_argument, &show_raw_insn, -1},\n   {\"no-addresses\", no_argument, &no_addresses, 1},\n-  {\"process-links\", no_argument, &process_links, true},\n+  {\"no-recurse-limit\", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},\n+  {\"no-recursion-limit\", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},\n+  {\"no-show-raw-insn\", no_argument, &show_raw_insn, -1},\n+  {\"prefix\", required_argument, NULL, OPTION_PREFIX},\n   {\"prefix-addresses\", no_argument, &prefix_addresses, 1},\n+  {\"prefix-strip\", required_argument, NULL, OPTION_PREFIX_STRIP},\n+  {\"private\", required_argument, NULL, 'P'},\n+  {\"private-headers\", no_argument, NULL, 'p'},\n+  {\"process-links\", no_argument, &process_links, true},\n   {\"recurse-limit\", no_argument, NULL, OPTION_RECURSE_LIMIT},\n   {\"recursion-limit\", no_argument, NULL, OPTION_RECURSE_LIMIT},\n-  {\"no-recurse-limit\", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},\n-  {\"no-recursion-limit\", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},\n   {\"reloc\", no_argument, NULL, 'r'},\n   {\"section\", required_argument, NULL, 'j'},\n   {\"section-headers\", no_argument, NULL, 'h'},\n   {\"show-raw-insn\", no_argument, &show_raw_insn, 1},\n   {\"source\", no_argument, NULL, 'S'},\n   {\"source-comment\", optional_argument, NULL, OPTION_SOURCE_COMMENT},\n   {\"special-syms\", no_argument, &dump_special_syms, 1},\n-  {\"include\", required_argument, NULL, 'I'},\n-  {\"dwarf\", optional_argument, NULL, OPTION_DWARF},\n-#ifdef ENABLE_LIBCTF\n-  {\"ctf\", optional_argument, NULL, OPTION_CTF},\n-  {\"ctf-parent\", required_argument, NULL, OPTION_CTF_PARENT},\n-#endif\n   {\"stabs\", no_argument, NULL, 'G'},\n   {\"start-address\", required_argument, NULL, OPTION_START_ADDRESS},\n   {\"stop-address\", required_argument, NULL, OPTION_STOP_ADDRESS},\n   {\"syms\", no_argument, NULL, 't'},\n   {\"target\", required_argument, NULL, 'b'},\n+  {\"unicode\", required_argument, NULL, 'U'},\n   {\"version\", no_argument, NULL, 'V'},\n-  {\"wide\", no_argument, NULL, 'w'},\n-  {\"prefix\", required_argument, NULL, OPTION_PREFIX},\n-  {\"prefix-strip\", required_argument, NULL, OPTION_PREFIX_STRIP},\n-  {\"insn-width\", required_argument, NULL, OPTION_INSN_WIDTH},\n-  {\"dwarf-depth\", required_argument, 0, OPTION_DWARF_DEPTH},\n-  {\"dwarf-start\", required_argument, 0, OPTION_DWARF_START},\n-  {\"dwarf-check\", no_argument, 0, OPTION_DWARF_CHECK},\n-  {\"inlines\", no_argument, 0, OPTION_INLINES},\n   {\"visualize-jumps\", optional_argument, 0, OPTION_VISUALIZE_JUMPS},\n-  {0, no_argument, 0, 0}\n+  {\"wide\", no_argument, NULL, 'w'},\n+  {NULL, no_argument, NULL, 0}\n };\n \f\n static void\n@@ -488,9 +504,121 @@ nonfatal (const char *msg)\n   exit_status = 1;\n }\n \n+/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.\n+   The conversion format is controlled by the unicode_display variable.\n+   Returns the number of characters added to OUT.\n+   Returns the number of bytes consumed from IN in CONSUMED.\n+   Always consumes at least one byte and displays at least one character.  */\n+   \n+static unsigned int\n+display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)\n+{\n+  char *        orig_out = out;\n+  unsigned int  nchars = 0;\n+  unsigned int j;\n+\n+  if (unicode_display == unicode_default)\n+    goto invalid;\n+\n+  if (in[0] < 0xc0)\n+    goto invalid;\n+\n+  if ((in[1] & 0xc0) != 0x80)\n+    goto invalid;\n+\n+  if ((in[0] & 0x20) == 0)\n+    {\n+      nchars = 2;\n+      goto valid;\n+    }\n+\n+  if ((in[2] & 0xc0) != 0x80)\n+    goto invalid;\n+\n+  if ((in[0] & 0x10) == 0)\n+    {\n+      nchars = 3;\n+      goto valid;\n+    }\n+\n+  if ((in[3] & 0xc0) != 0x80)\n+    goto invalid;\n+\n+  nchars = 4;\n+\n+ valid:\n+  switch (unicode_display)\n+    {\n+    case unicode_locale:\n+      /* Copy the bytes into the output buffer as is.  */\n+      memcpy (out, in, nchars);\n+      out += nchars;\n+      break;\n+\n+    case unicode_invalid:\n+    case unicode_hex:\n+      out += sprintf (out, \"%c\", unicode_display == unicode_hex ? '<' : '{');\n+      out += sprintf (out, \"0x\");\n+      for (j = 0; j < nchars; j++)\n+\tout += sprintf (out, \"%02x\", in [j]);\n+      out += sprintf (out, \"%c\", unicode_display == unicode_hex ? '>' : '}');\n+      break;\n+      \n+    case unicode_highlight:\n+      if (isatty (1))\n+\tout += sprintf (out, \"\\x1B[31;47m\"); /* Red.  */\n+      /* Fall through.  */\n+    case unicode_escape:\n+      switch (nchars)\n+\t{\n+\tcase 2:\n+\t  out += sprintf (out, \"\\\\u%02x%02x\",\n+\t\t  ((in[0] & 0x1c) >> 2), \n+\t\t  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));\n+\t  break;\n+\n+\tcase 3:\n+\t  out += sprintf (out, \"\\\\u%02x%02x\",\n+\t\t  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),\n+\t\t  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));\n+\t  break;\n+\n+\tcase 4:\n+\t  out += sprintf (out, \"\\\\u%02x%02x%02x\",\n+\t\t  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),\n+\t\t  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),\n+\t\t  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));\n+\t  break;\n+\tdefault:\n+\t  /* URG.  */\n+\t  break;\n+\t}\n+\n+      if (unicode_display == unicode_highlight && isatty (1))\n+\tout += sprintf (out, \"\\033[0m\"); /* Default colour.  */\n+      break;\n+\n+    default:\n+      /* URG */\n+      break;\n+    }\n+\n+  * consumed = nchars;\n+  return out - orig_out;\n+\n+ invalid:\n+  /* Not a valid UTF-8 sequence.  */\n+  *out = *in;\n+  * consumed = 1;\n+  return 1;\n+}\n+\n /* Returns a version of IN with any control characters\n    replaced by escape sequences.  Uses a static buffer\n-   if necessary.  */\n+   if necessary.\n+\n+   If unicode display is enabled, then also handles the\n+   conversion of unicode characters.  */\n \n static const char *\n sanitize_string (const char * in)\n@@ -508,40 +636,50 @@ sanitize_string (const char * in)\n      of cases it will not be needed.  */\n   do\n     {\n-      char c = *in++;\n+      unsigned char c = *in++;\n \n       if (c == 0)\n \treturn original;\n \n       if (ISCNTRL (c))\n \tbreak;\n+\n+      if (unicode_display != unicode_default && c >= 0xc0)\n+\tbreak;\n     }\n   while (1);\n \n   /* Copy the input, translating as needed.  */\n   in = original;\n-  if (buffer_len < (strlen (in) * 2))\n+  if (buffer_len < (strlen (in) * 9))\n     {\n       free ((void *) buffer);\n-      buffer_len = strlen (in) * 2;\n+      buffer_len = strlen (in) * 9;\n       buffer = xmalloc (buffer_len + 1);\n     }\n \n   out = buffer;\n   do\n     {\n-      char c = *in++;\n+      unsigned char c = *in++;\n \n       if (c == 0)\n \tbreak;\n \n-      if (!ISCNTRL (c))\n-\t*out++ = c;\n-      else\n+      if (ISCNTRL (c))\n \t{\n \t  *out++ = '^';\n \t  *out++ = c + 0x40;\n \t}\n+      else if (unicode_display != unicode_default && c >= 0xc0)\n+\t{\n+\t  unsigned int num_consumed;\n+\n+\t  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);\n+\t  in += num_consumed - 1;\n+\t}\n+      else\n+\t*out++ = c;\n     }\n   while (1);\n \n@@ -4522,6 +4660,24 @@ dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bool dynamic)\n \t\t  free (alloc);\n \t\t}\n \t    }\n+\t  else if (unicode_display != unicode_default\n+\t\t   && name != NULL && *name != '\\0')\n+\t    {\n+\t      const char * sanitized_name;\n+\n+\t      /* If we want to sanitize the name, we do it here, and\n+\t\t temporarily clobber it while calling bfd_print_symbol.\n+\t\t FIXME: This is a gross hack.  */\n+\t      sanitized_name = sanitize_string (name);\n+\t      if (sanitized_name != name)\n+\t\t(*current)->name = sanitized_name;\n+\t      else\n+\t\tsanitized_name = NULL;\n+\t      bfd_print_symbol (cur_bfd, stdout, *current,\n+\t\t\t\tbfd_print_symbol_all);\n+\t      if (sanitized_name != NULL)\n+\t\t(*current)->name = name;\n+\t    }\n \t  else\n \t    bfd_print_symbol (cur_bfd, stdout, *current,\n \t\t\t      bfd_print_symbol_all);\n@@ -5205,7 +5361,7 @@ main (int argc, char **argv)\n   set_default_bfd_target ();\n \n   while ((c = getopt_long (argc, argv,\n-\t\t\t   \"CDE:FGHI:LM:P:RSTVW::ab:defghij:lm:prstvwxz\",\n+\t\t\t   \"CDE:FGHI:LM:P:RSTU:VW::ab:defghij:lm:prstvwxz\",\n \t\t\t   long_options, (int *) 0))\n \t != EOF)\n     {\n@@ -5489,6 +5645,23 @@ main (int argc, char **argv)\n \t  seenflag = true;\n \t  break;\n \n+\tcase 'U':\n+\t  if (streq (optarg, \"default\") || streq (optarg, \"d\"))\n+\t    unicode_display = unicode_default;\n+\t  else if (streq (optarg, \"locale\") || streq (optarg, \"l\"))\n+\t    unicode_display = unicode_locale;\n+\t  else if (streq (optarg, \"escape\") || streq (optarg, \"e\"))\n+\t    unicode_display = unicode_escape;\n+\t  else if (streq (optarg, \"invalid\") || streq (optarg, \"i\"))\n+\t    unicode_display = unicode_invalid;\n+\t  else if (streq (optarg, \"hex\") || streq (optarg, \"x\"))\n+\t    unicode_display = unicode_hex;\n+\t  else if (streq (optarg, \"highlight\") || streq (optarg, \"h\"))\n+\t    unicode_display = unicode_highlight;\n+\t  else\n+\t    fatal (_(\"invalid argument to -U/--unicode: %s\"), optarg);\n+\t  break;\n+\n \tcase 'H':\n \t  usage (stdout, 0);\n \t  /* No need to set seenflag or to break - usage() does not return.  */"
    },
    {
      "sha": "50129f4ab4f12283f75b2eceb39aaba6ea02286f",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 181,
      "deletions": 9,
      "changes": 190,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
      "patch": "@@ -329,6 +329,19 @@ typedef enum print_mode\n }\n print_mode;\n \n+typedef enum unicode_display_type\n+{\n+  unicode_default = 0,\n+  unicode_locale,\n+  unicode_escape,\n+  unicode_hex,\n+  unicode_highlight,\n+  unicode_invalid\n+} unicode_display_type;\n+\n+static unicode_display_type unicode_display = unicode_default;\n+\n+  \n /* Versioned symbol info.  */\n enum versioned_symbol_info\n {\n@@ -656,23 +669,156 @@ print_symbol (signed int width, const char * symbol)\n       if (c == 0)\n \tbreak;\n \n-      /* Do not print control characters directly as they can affect terminal\n-\t settings.  Such characters usually appear in the names generated\n-\t by the assembler for local labels.  */\n-      if (ISCNTRL (c))\n+      if (ISPRINT (c))\n+\t{\n+\t  putchar (c);\n+\t  width_remaining --;\n+\t  num_printed ++;\n+\t}\n+      else if (ISCNTRL (c))\n \t{\n+\t  /* Do not print control characters directly as they can affect terminal\n+\t     settings.  Such characters usually appear in the names generated\n+\t     by the assembler for local labels.  */\n+\n \t  if (width_remaining < 2)\n \t    break;\n \n \t  printf (\"^%c\", c + 0x40);\n \t  width_remaining -= 2;\n \t  num_printed += 2;\n \t}\n-      else if (ISPRINT (c))\n+      else if (c == 0x7f)\n \t{\n-\t  putchar (c);\n-\t  width_remaining --;\n-\t  num_printed ++;\n+\t  if (width_remaining < 5)\n+\t    break;\n+\t  printf (\"<DEL>\");\n+\t  width_remaining -= 5;\n+\t  num_printed += 5;\n+\t}\n+      else if (unicode_display != unicode_locale\n+\t       && unicode_display != unicode_default)\n+\t{\n+\t  /* Display unicode characters as something else.  */\n+\t  unsigned char bytes[4];\n+\t  bool          is_utf8;\n+\t  uint          nbytes;\n+\n+\t  bytes[0] = c;\n+\n+\t  if (bytes[0] < 0xc0)\n+\t    {\n+\t      nbytes = 1;\n+\t      is_utf8 = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      bytes[1] = *symbol++;\n+\n+\t      if ((bytes[1] & 0xc0) != 0x80)\n+\t\t{\n+\t\t  is_utf8 = false;\n+\t\t  /* Do not consume this character.  It may only\n+\t\t     be the first byte in the sequence that was\n+\t\t     corrupt.  */\n+\t\t  --symbol;\n+\t\t  nbytes = 1;\n+\t\t}\n+\t      else if ((bytes[0] & 0x20) == 0)\n+\t\t{\n+\t\t  is_utf8 = true;\n+\t\t  nbytes = 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  bytes[2] = *symbol++;\n+\n+\t\t  if ((bytes[2] & 0xc0) != 0x80)\n+\t\t    {\n+\t\t      is_utf8 = false;\n+\t\t      symbol -= 2;\n+\t\t      nbytes = 1;\n+\t\t    }\n+\t\t  else if ((bytes[0] & 0x10) == 0)\n+\t\t    {\n+\t\t      is_utf8 = true;\n+\t\t      nbytes = 3;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      bytes[3] = *symbol++;\n+\n+\t\t      nbytes = 4;\n+\n+\t\t      if ((bytes[3] & 0xc0) != 0x80)\n+\t\t\t{\n+\t\t\t  is_utf8 = false;\n+\t\t\t  symbol -= 3;\n+\t\t\t  nbytes = 1;\n+\t\t\t}\n+\t\t      else\n+\t\t\tis_utf8 = true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (unicode_display == unicode_invalid)\n+\t    is_utf8 = false;\n+\n+\t  if (unicode_display == unicode_hex || ! is_utf8)\n+\t    {\n+\t      uint i;\n+\n+\t      if (width_remaining < (nbytes * 2) + 2)\n+\t\tbreak;\n+\t  \n+\t      putchar (is_utf8 ? '<' : '{');\n+\t      printf (\"0x\");\n+\t      for (i = 0; i < nbytes; i++)\n+\t\tprintf (\"%02x\", bytes[i]);\n+\t      putchar (is_utf8 ? '>' : '}');\n+\t    }\n+\t  else\n+\t    {\n+\t      if (unicode_display == unicode_highlight && isatty (1))\n+\t\tprintf (\"\\x1B[31;47m\"); /* Red.  */\n+\t      \n+\t      switch (nbytes)\n+\t\t{\n+\t\tcase 2:\n+\t\t  if (width_remaining < 6)\n+\t\t    break;\n+\t\t  printf (\"\\\\u%02x%02x\",\n+\t\t\t  (bytes[0] & 0x1c) >> 2, \n+\t\t\t  ((bytes[0] & 0x03) << 6) | (bytes[1] & 0x3f));\n+\t\t  break;\n+\t\tcase 3:\n+\t\t  if (width_remaining < 6)\n+\t\t    break;\n+\t\t  printf (\"\\\\u%02x%02x\",\n+\t\t\t  ((bytes[0] & 0x0f) << 4) | ((bytes[1] & 0x3c) >> 2),\n+\t\t\t  ((bytes[1] & 0x03) << 6) | (bytes[2] & 0x3f));\n+\t\t  break;\n+\t\tcase 4:\n+\t\t  if (width_remaining < 8)\n+\t\t    break;\n+\t\t  printf (\"\\\\u%02x%02x%02x\",\n+\t\t\t  ((bytes[0] & 0x07) << 6) | ((bytes[1] & 0x3c) >> 2),\n+\t\t\t  ((bytes[1] & 0x03) << 6) | ((bytes[2] & 0x3c) >> 2),\n+\t\t\t  ((bytes[2] & 0x03) << 6) | (bytes[3] & 0x3f));\n+\t\t  \n+\t\t  break;\n+\t\tdefault:\n+\t\t  /* URG.  */\n+\t\t  break;\n+\t\t}\n+\n+\t      if (unicode_display == unicode_highlight && isatty (1))\n+\t\tprintf (\"\\033[0m\"); /* Default colour.  */\n+\t    }\n+\t  \n+\t  if (bytes[nbytes - 1] == 0)\n+\t    break;\n \t}\n       else\n \t{\n@@ -4731,6 +4877,7 @@ static struct option options[] =\n   {\"syms\",\t       no_argument, 0, 's'},\n   {\"silent-truncation\",no_argument, 0, 'T'},\n   {\"section-details\",  no_argument, 0, 't'},\n+  {\"unicode\",          required_argument, NULL, 'U'},\n   {\"unwind\",\t       no_argument, 0, 'u'},\n   {\"version-info\",     no_argument, 0, 'V'},\n   {\"version\",\t       no_argument, 0, 'v'},\n@@ -4806,6 +4953,12 @@ usage (FILE * stream)\n      --recurse-limit     Enable a demangling recursion limit.  (default)\\n\"));\n   fprintf (stream, _(\"\\\n      --no-recurse-limit  Disable a demangling recursion limit\\n\"));\n+  fprintf (stream, _(\"\\\n+     -U[dlexhi] --unicode=[default|locale|escape|hex|highlight|invalid]\\n\\\n+                         Display unicode characters as determined by the current locale\\n\\\n+                          (default), escape sequences, \\\"<hex sequences>\\\", highlighted\\n\\\n+                          escape sequences, or treat them as invalid and display as\\n\\\n+                          \\\"{hex sequences}\\\"\\n\"));\n   fprintf (stream, _(\"\\\n   -n --notes             Display the core notes (if present)\\n\"));\n   fprintf (stream, _(\"\\\n@@ -4990,7 +5143,7 @@ parse_args (struct dump_data *dumpdata, int argc, char ** argv)\n     usage (stderr);\n \n   while ((c = getopt_long\n-\t  (argc, argv, \"ACDHILNPR:STVWacdeghi:lnp:rstuvw::x:z\", options, NULL)) != EOF)\n+\t  (argc, argv, \"ACDHILNPR:STU:VWacdeghi:lnp:rstuvw::x:z\", options, NULL)) != EOF)\n     {\n       switch (c)\n \t{\n@@ -5192,6 +5345,25 @@ parse_args (struct dump_data *dumpdata, int argc, char ** argv)\n \t  /* Ignored for backward compatibility.  */\n \t  break;\n \n+\tcase 'U':\n+\t  if (optarg == NULL)\n+\t    error (_(\"Missing arg to -U/--unicode\")); /* Can this happen ?  */\n+\t  else if (streq (optarg, \"default\") || streq (optarg, \"d\"))\n+\t    unicode_display = unicode_default;\n+\t  else if (streq (optarg, \"locale\") || streq (optarg, \"l\"))\n+\t    unicode_display = unicode_locale;\n+\t  else if (streq (optarg, \"escape\") || streq (optarg, \"e\"))\n+\t    unicode_display = unicode_escape;\n+\t  else if (streq (optarg, \"invalid\") || streq (optarg, \"i\"))\n+\t    unicode_display = unicode_invalid;\n+\t  else if (streq (optarg, \"hex\") || streq (optarg, \"x\"))\n+\t    unicode_display = unicode_hex;\n+\t  else if (streq (optarg, \"highlight\") || streq (optarg, \"h\"))\n+\t    unicode_display = unicode_highlight;\n+\t  else\n+\t    error (_(\"invalid argument to -U/--unicode: %s\"), optarg);\n+\t  break;\n+\n \tcase OPTION_SYM_BASE:\n \t  sym_base = 0;\n \t  if (optarg != NULL)"
    },
    {
      "sha": "f50badf983e897136937478f13a45ff91b715ff3",
      "filename": "binutils/strings.c",
      "status": "modified",
      "additions": 695,
      "deletions": 62,
      "changes": 757,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/strings.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5/binutils/strings.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/strings.c?ref=b3aa80b45c4f46029efeb204bb9f2d2c4278a0e5",
      "patch": "@@ -55,6 +55,19 @@\n    -T {bfdname}\n \t\tSpecify a non-default object file format.\n \n+  --unicode={default|locale|invalid|hex|escape|highlight}\n+  -u {d|l|i|x|e|h}\n+                Determine how to handle UTF-8 unicode characters.  The default\n+\t\tis no special treatment.  All other versions of this option\n+\t\tonly apply if the encoding is valid and enabling the option\n+\t\timplies --encoding=S.\n+\t\tThe 'locale' option displays the characters according to the\n+\t\tcurrent locale.  The 'invalid' option treats them as\n+\t\tnon-string characters.  The 'hex' option displays them as hex\n+\t\tbyte sequences.  The 'escape' option displays them as escape\n+\t\tsequences and the 'highlight' option displays them as\n+\t\tcoloured escape sequences.\n+\n   --output-separator=sep_string\n   -s sep_string\tString used to separate parsed strings in output.\n \t\tDefault is newline.\n@@ -76,6 +89,22 @@\n #include \"safe-ctype.h\"\n #include \"bucomm.h\"\n \n+#ifndef streq\n+#define streq(a,b) (strcmp ((a),(b)) == 0)\n+#endif\n+\n+typedef enum unicode_display_type\n+{\n+  unicode_default = 0,\n+  unicode_locale,\n+  unicode_escape,\n+  unicode_hex,\n+  unicode_highlight,\n+  unicode_invalid\n+} unicode_display_type;\n+\n+static unicode_display_type unicode_display = unicode_default;\n+\n #define STRING_ISGRAPHIC(c) \\\n       (   (c) >= 0 \\\n        && (c) <= 255 \\\n@@ -94,7 +123,7 @@ extern int errno;\n static int address_radix;\n \n /* Minimum length of sequence of graphic chars to trigger output.  */\n-static int string_min;\n+static uint string_min;\n \n /* Whether or not we include all whitespace as a graphic char.   */\n static bool include_all_whitespace;\n@@ -121,21 +150,22 @@ static char *output_separator;\n static struct option long_options[] =\n {\n   {\"all\", no_argument, NULL, 'a'},\n+  {\"bytes\", required_argument, NULL, 'n'},\n   {\"data\", no_argument, NULL, 'd'},\n+  {\"encoding\", required_argument, NULL, 'e'},\n+  {\"help\", no_argument, NULL, 'h'},\n+  {\"include-all-whitespace\", no_argument, NULL, 'w'},\n+  {\"output-separator\", required_argument, NULL, 's'},\n   {\"print-file-name\", no_argument, NULL, 'f'},\n-  {\"bytes\", required_argument, NULL, 'n'},\n   {\"radix\", required_argument, NULL, 't'},\n-  {\"include-all-whitespace\", no_argument, NULL, 'w'},\n-  {\"encoding\", required_argument, NULL, 'e'},\n   {\"target\", required_argument, NULL, 'T'},\n-  {\"output-separator\", required_argument, NULL, 's'},\n-  {\"help\", no_argument, NULL, 'h'},\n+  {\"unicode\", required_argument, NULL, 'U'},\n   {\"version\", no_argument, NULL, 'v'},\n   {NULL, 0, NULL, 0}\n };\n \n static bool strings_file (char *);\n-static void print_strings (const char *, FILE *, file_ptr, int, int, char *);\n+static void print_strings (const char *, FILE *, file_ptr, int, char *);\n static void usage (FILE *, int) ATTRIBUTE_NORETURN;\n \f\n int main (int, char **);\n@@ -171,7 +201,7 @@ main (int argc, char **argv)\n   encoding = 's';\n   output_separator = NULL;\n \n-  while ((optc = getopt_long (argc, argv, \"adfhHn:wot:e:T:s:Vv0123456789\",\n+  while ((optc = getopt_long (argc, argv, \"adfhHn:wot:e:T:s:U:Vv0123456789\",\n \t\t\t      long_options, (int *) 0)) != EOF)\n     {\n       switch (optc)\n@@ -244,6 +274,23 @@ main (int argc, char **argv)\n \t  output_separator = optarg;\n           break;\n \n+\tcase 'U':\n+\t  if (streq (optarg, \"default\") || streq (optarg, \"d\"))\n+\t    unicode_display = unicode_default;\n+\t  else if (streq (optarg, \"locale\") || streq (optarg, \"l\"))\n+\t    unicode_display = unicode_locale;\n+\t  else if (streq (optarg, \"escape\") || streq (optarg, \"e\"))\n+\t    unicode_display = unicode_escape;\n+\t  else if (streq (optarg, \"invalid\") || streq (optarg, \"i\"))\n+\t    unicode_display = unicode_invalid;\n+\t  else if (streq (optarg, \"hex\") || streq (optarg, \"x\"))\n+\t    unicode_display = unicode_hex;\n+\t  else if (streq (optarg, \"highlight\") || streq (optarg, \"h\"))\n+\t    unicode_display = unicode_highlight;\n+\t  else\n+\t    fatal (_(\"invalid argument to -U/--unicode: %s\"), optarg);\n+\t  break;\n+\n \tcase 'V':\n \tcase 'v':\n \t  print_version (\"strings\");\n@@ -258,6 +305,9 @@ main (int argc, char **argv)\n \t}\n     }\n \n+  if (unicode_display != unicode_default)\n+    encoding = 'S';\n+\n   if (numeric_opt != 0)\n     {\n       string_min = (int) strtoul (argv[numeric_opt - 1] + 1, &s, 0);\n@@ -293,14 +343,14 @@ main (int argc, char **argv)\n     {\n       datasection_only = false;\n       SET_BINARY (fileno (stdin));\n-      print_strings (\"{standard input}\", stdin, 0, 0, 0, (char *) NULL);\n+      print_strings (\"{standard input}\", stdin, 0, 0, (char *) NULL);\n       files_given = true;\n     }\n   else\n     {\n       for (; optind < argc; ++optind)\n \t{\n-\t  if (strcmp (argv[optind], \"-\") == 0)\n+\t  if (streq (argv[optind], \"-\"))\n \t    datasection_only = false;\n \t  else\n \t    {\n@@ -342,7 +392,7 @@ strings_a_section (bfd *abfd, asection *sect, const char *filename,\n     }\n \n   *got_a_section = true;\n-  print_strings (filename, NULL, sect->filepos, 0, sectsize, (char *) mem);\n+  print_strings (filename, NULL, sect->filepos, sectsize, (char *) mem);\n   free (mem);\n }\n \n@@ -427,7 +477,7 @@ strings_file (char *file)\n \t  return false;\n \t}\n \n-      print_strings (file, stream, (file_ptr) 0, 0, 0, (char *) 0);\n+      print_strings (file, stream, (file_ptr) 0, 0, (char *) NULL);\n \n       if (fclose (stream) == EOF)\n \t{\n@@ -551,11 +601,627 @@ unget_part_char (long c, file_ptr *address, int *magiccount, char **magic)\n \t}\n     }\n }\n+\n+static void\n+print_filename_and_address (const char * filename, file_ptr address)\n+{\n+  if (print_filenames)\n+    printf (\"%s: \", filename);\n+\n+  if (! print_addresses)\n+    return;\n+\n+  switch (address_radix)\n+    {\n+    case 8:\n+      if (sizeof (address) > sizeof (long))\n+\t{\n+#ifndef __MSVCRT__\n+\t  printf (\"%7llo \", (unsigned long long) address);\n+#else\n+\t  printf (\"%7I64o \", (unsigned long long) address);\n+#endif\n+\t}\n+      else\n+\tprintf (\"%7lo \", (unsigned long) address);\n+      break;\n+\n+    case 10:\n+      if (sizeof (address) > sizeof (long))\n+\t{\n+#ifndef __MSVCRT__\n+\t  printf (\"%7llu \", (unsigned long long) address);\n+#else\n+\t  printf (\"%7I64d \", (unsigned long long) address);\n+#endif\n+\t}\n+      else\n+\tprintf (\"%7ld \", (long) address);\n+      break;\n+\n+    case 16:\n+      if (sizeof (address) > sizeof (long))\n+\t{\n+#ifndef __MSVCRT__\n+\t  printf (\"%7llx \", (unsigned long long) address);\n+#else\n+\t  printf (\"%7I64x \", (unsigned long long) address);\n+#endif\n+\t}\n+      else\n+\tprintf (\"%7lx \", (unsigned long) address);\n+      break;\n+    }\n+}\n+\n+/* Return non-zero if the bytes starting at BUFFER form a valid UTF-8 encoding.\n+   If the encoding is valid then returns the number of bytes it uses.  */\n+\n+static unsigned int\n+is_valid_utf8 (const unsigned char * buffer, unsigned long buflen)\n+{\n+  if (buffer[0] < 0xc0)\n+    return 0;\n+\n+  if (buflen < 2)\n+    return 0;\n+\n+  if ((buffer[1] & 0xc0) != 0x80)\n+    return 0;\n+\n+  if ((buffer[0] & 0x20) == 0)\n+    return 2;\n+\n+  if (buflen < 3)\n+    return 0;\n+\n+  if ((buffer[2] & 0xc0) != 0x80)\n+    return 0;\n+  \n+  if ((buffer[0] & 0x10) == 0)\n+    return 3;\n+\n+  if (buflen < 4)\n+    return 0;\n+\n+  if ((buffer[3] & 0xc0) != 0x80)\n+    return 0;\n+\n+  return 4;\n+}\n+\n+/* Display a UTF-8 encoded character in BUFFER according to the setting\n+   of unicode_display.  The character is known to be valid.\n+   Returns the number of bytes consumed.  */\n+\n+static uint\n+display_utf8_char (const unsigned char * buffer)\n+{\n+  uint j;\n+  uint utf8_len;\n+\n+  switch (buffer[0] & 0x30)\n+    {\n+    case 0x00:\n+    case 0x10:\n+      utf8_len = 2;\n+      break;\n+    case 0x20:\n+      utf8_len = 3;\n+      break;\n+    default:\n+      utf8_len = 4;\n+    }\n+      \n+  switch (unicode_display)\n+    {\n+    default:\n+      fprintf (stderr, \"ICE: unexpected unicode display type\\n\");\n+      break;\n+\n+    case unicode_escape:\n+    case unicode_highlight:\n+      if (unicode_display == unicode_highlight && isatty (1))\n+\tprintf (\"\\x1B[31;47m\"); /* Red.  */\n+\n+      switch (utf8_len)\n+\t{\n+\tcase 2:\n+\t  printf (\"\\\\u%02x%02x\",\n+\t\t  ((buffer[0] & 0x1c) >> 2), \n+\t\t  ((buffer[0] & 0x03) << 6) | (buffer[1] & 0x3f));\n+\t  break;\n+\n+\tcase 3:\n+\t  printf (\"\\\\u%02x%02x\",\n+\t\t  ((buffer[0] & 0x0f) << 4) | ((buffer[1] & 0x3c) >> 2),\n+\t\t  ((buffer[1] & 0x03) << 6) | ((buffer[2] & 0x3f)));\n+\t  break;\n+\n+\tcase 4:\n+\t  printf (\"\\\\u%02x%02x%02x\",\n+\t\t  ((buffer[0] & 0x07) << 6) | ((buffer[1] & 0x3c) >> 2),\n+\t\t  ((buffer[1] & 0x03) << 6) | ((buffer[2] & 0x3c) >> 2),\n+\t\t  ((buffer[2] & 0x03) << 6) | ((buffer[3] & 0x3f)));\n+\t  break;\n+\tdefault:\n+\t  /* URG.  */\n+\t  break;\n+\t}\n+\n+      if (unicode_display == unicode_highlight && isatty (1))\n+\tprintf (\"\\033[0m\"); /* Default colour.  */\n+      break;\n+\n+    case unicode_hex:\n+      putchar ('<');\n+      printf (\"0x\");\n+      for (j = 0; j < utf8_len; j++)\n+\tprintf (\"%02x\", buffer [j]);\n+      putchar ('>');\n+      break;\n+\n+    case unicode_locale:\n+      printf (\"%.1s\", buffer);\n+      break;\n+    }\n+\n+  return utf8_len;\n+}\n+\n+/* Display strings in BUFFER.  Treat any UTF-8 encoded characters encountered\n+   according to the setting of the unicode_display variable.  The buffer\n+   contains BUFLEN bytes.\n+\n+   Display the characters as if they started at ADDRESS and are contained in\n+   FILENAME.  */\n+\n+static void\n+print_unicode_buffer (const char *            filename,\n+\t\t      file_ptr                address,\n+\t\t      const unsigned char *   buffer,\n+\t\t      unsigned long           buflen)\n+{\n+  /* Paranoia checks...  */\n+  if (filename == NULL\n+      || buffer == NULL\n+      || unicode_display == unicode_default\n+      || encoding != 'S'\n+      || encoding_bytes != 1)\n+    {\n+      fprintf (stderr, \"ICE: bad arguments to print_unicode_buffer\\n\");\n+      return;\n+    }\n+\n+  if (buflen == 0)\n+    return;\n+\n+  /* We must only display strings that are at least string_min *characters*\n+     long.  So we scan the buffer in two stages.  First we locate the start\n+     of a potential string.  Then we walk along it until we have found\n+     string_min characters.  Then we go back to the start point and start\n+     displaying characters according to the unicode_display setting.  */\n+\n+  unsigned long start_point = 0;\n+  unsigned long i = 0;\n+  unsigned int char_len = 1;\n+  unsigned int num_found = 0;\n+\n+  for (i = 0; i < buflen; i += char_len)\n+    {\n+      int c = buffer[i];\n+\n+      char_len = 1;\n+\n+      /* Find the first potential character of a string.  */\n+      if (! STRING_ISGRAPHIC (c))\n+\t{\n+\t  num_found = 0;\n+\t  continue;\n+\t}\n+\n+      if (c > 126)\n+\t{\n+\t  if (c < 0xc0)\n+\t    {\n+\t      num_found = 0;\n+\t      continue;\n+\t    }\n+\n+\t  if ((char_len = is_valid_utf8 (buffer + i, buflen - i)) == 0)\n+\t    {\n+\t      char_len = 1;\n+\t      num_found = 0;\n+\t      continue;\n+\t    }\n+\n+\t  if (unicode_display == unicode_invalid)\n+\t    {\n+\t      /* We have found a valid UTF-8 character, but we treat it as non-graphic.  */\n+\t      num_found = 0;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (num_found == 0)\n+\t/* We have found a potential starting point for a string.  */\n+\tstart_point = i;\n+\n+      ++ num_found;\n+\n+      if (num_found >= string_min)\n+\tbreak;\n+    }\n+\n+  if (num_found < string_min)\n+    return;\n+\n+  print_filename_and_address (filename, address + start_point);\n+  \n+  /* We have found string_min characters.  Display them and any\n+     more that follow.  */\n+  for (i = start_point; i < buflen; i += char_len)\n+    {\n+      int c = buffer[i];\n+\n+      char_len = 1;\n+\n+      if (! STRING_ISGRAPHIC (c))\n+\tbreak;\n+      else if (c < 127)\n+\tputchar (c);\n+      else if (! is_valid_utf8 (buffer + i, buflen - i))\n+\tbreak;\n+      else if (unicode_display == unicode_invalid)\n+\tbreak;\n+      else\n+\tchar_len = display_utf8_char (buffer + i);\n+    }\n+\n+  if (output_separator)\n+    fputs (output_separator, stdout);\n+  else\n+    putchar ('\\n');\n+\n+  /* FIXME: Using tail recursion here is lazy programming...  */\n+  print_unicode_buffer (filename, address + i, buffer + i, buflen - i);\n+}\n+\n+static int\n+get_unicode_byte (FILE * stream, unsigned char * putback, uint * num_putback, uint * num_read)\n+{\n+  if (* num_putback > 0)\n+    {\n+      * num_putback = * num_putback - 1;\n+      return putback [* num_putback];\n+    }\n+\n+  * num_read = * num_read + 1;\n+\n+#if defined(HAVE_GETC_UNLOCKED) && HAVE_DECL_GETC_UNLOCKED\n+  return getc_unlocked (stream);\n+#else\n+  return getc (stream);\n+#endif\n+}\n+\n+/* Helper function for print_unicode_stream.  */\n+\n+static void\n+print_unicode_stream_body (const char *     filename,\n+\t\t\t   file_ptr         address,\n+\t\t\t   FILE *           stream,\n+\t\t\t   unsigned char *  putback_buf,\n+\t\t\t   uint             num_putback,\n+\t\t\t   unsigned char *  print_buf)\n+{\n+  /* It would be nice if we could just read the stream into a buffer\n+     and then process if with print_unicode_buffer.  But the input\n+     might be huge or it might time-locked (eg stdin).  So instead\n+     we go one byte at a time...  */\n+\n+  file_ptr start_point = 0;\n+  uint num_read = 0;\n+  uint num_chars = 0;\n+  uint num_print = 0;\n+  int c;\n+\n+  /* Find a series of string_min characters.  Put them into print_buf.  */\n+  do\n+    {\n+      if (num_chars >= string_min)\n+\tbreak;\n+\n+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n+      if (c == EOF)\n+\tbreak;\n+\n+      if (! STRING_ISGRAPHIC (c))\n+\t{\n+\t  num_chars = num_print = 0;\n+\t  continue;\n+\t}\n+\n+      if (num_chars == 0)\n+\tstart_point = num_read - 1;\n+\n+      if (c < 127)\n+\t{\n+\t  print_buf[num_print] = c;\n+\t  num_chars ++;\n+\t  num_print ++;\n+\t  continue;\n+\t}\n+\n+      if (c < 0xc0)\n+\t{\n+\t  num_chars = num_print = 0;\n+\t  continue;\n+\t}\n+\n+      /* We *might* have a UTF-8 sequence.  Time to start peeking.  */\n+      char utf8[4];\n+\n+      utf8[0] = c;\n+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n+      if (c == EOF)\n+\tbreak;\n+      utf8[1] = c;\n+\n+      if ((utf8[1] & 0xc0) != 0x80)\n+\t{\n+\t  /* Invalid UTF-8.  */\n+\t  putback_buf[num_putback++] = utf8[1];\n+\t  num_chars = num_print = 0;\n+\t  continue;\n+\t}\n+      else if ((utf8[0] & 0x20) == 0)\n+\t{\n+\t  /* A valid 2-byte UTF-8 encoding.  */\n+\t  if (unicode_display == unicode_invalid)\n+\t    {\n+\t      putback_buf[num_putback++] = utf8[1];\n+\t      num_chars = num_print = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      print_buf[num_print ++] = utf8[0];\n+\t      print_buf[num_print ++] = utf8[1];\n+\t      num_chars ++;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n+      if (c == EOF)\n+\tbreak;\n+      utf8[2] = c;\n+\n+      if ((utf8[2] & 0xc0) != 0x80)\n+\t{\n+\t  /* Invalid UTF-8.  */\n+\t  putback_buf[num_putback++] = utf8[2];\n+\t  putback_buf[num_putback++] = utf8[1];\n+\t  num_chars = num_print = 0;\n+\t  continue;\n+\t}\n+      else if ((utf8[0] & 0x10) == 0)\n+\t{\n+\t  /* A valid 3-byte UTF-8 encoding.  */\n+\t  if (unicode_display == unicode_invalid)\n+\t    {\n+\t      putback_buf[num_putback++] = utf8[2];\n+\t      putback_buf[num_putback++] = utf8[1];\n+\t      num_chars = num_print = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      print_buf[num_print ++] = utf8[0];\n+\t      print_buf[num_print ++] = utf8[1];\n+\t      print_buf[num_print ++] = utf8[2];\n+\t      num_chars ++;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n+      if (c == EOF)\n+\tbreak;\n+      utf8[3] = c;\n+\n+      if ((utf8[3] & 0xc0) != 0x80)\n+\t{\n+\t  /* Invalid UTF-8.  */\n+\t  putback_buf[num_putback++] = utf8[3];\n+\t  putback_buf[num_putback++] = utf8[2];\n+\t  putback_buf[num_putback++] = utf8[1];\n+\t  num_chars = num_print = 0;\n+\t}\n+      /* We have a valid 4-byte UTF-8 encoding.  */\n+      else if (unicode_display == unicode_invalid)\n+\t{\n+\t  putback_buf[num_putback++] = utf8[3];\n+\t  putback_buf[num_putback++] = utf8[1];\n+\t  putback_buf[num_putback++] = utf8[2];\n+\t  num_chars = num_print = 0;\n+\t}\n+      else\n+\t{\n+\t  print_buf[num_print ++] = utf8[0];\n+\t  print_buf[num_print ++] = utf8[1];\n+\t  print_buf[num_print ++] = utf8[2];\n+\t  print_buf[num_print ++] = utf8[3];\n+\t  num_chars ++;\n+\t}\n+    }\n+  while (1);\n+\n+  if (num_chars >= string_min)\n+    {\n+      /* We know that we have string_min valid characters in print_buf,\n+\t and there may be more to come in the stream.  Start displaying\n+\t them.  */\n+\n+      print_filename_and_address (filename, address + start_point);\n+\n+      uint i;\n+      for (i = 0; i < num_print;)\n+\t{\n+\t  if (print_buf[i] < 127)\n+\t    putchar (print_buf[i++]);\n+\t  else\n+\t    i += display_utf8_char (print_buf + i);\n+\t}\n+\n+      /* OK so now we have to start read unchecked bytes.  */\n+\n+        /* Find a series of string_min characters.  Put them into print_buf.  */\n+      do\n+\t{\n+\t  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n+\t  if (c == EOF)\n+\t    break;\n+\n+\t  if (! STRING_ISGRAPHIC (c))\n+\t    break;\n+\n+\t  if (c < 127)\n+\t    {\n+\t      putchar (c);\n+\t      continue;\n+\t    }\n+\n+\t  if (c < 0xc0)\n+\t    break;\n+\n+\t  /* We *might* have a UTF-8 sequence.  Time to start peeking.  */\n+\t  unsigned char utf8[4];\n+\n+\t  utf8[0] = c;\n+\t  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n+\t  if (c == EOF)\n+\t    break;\n+\t  utf8[1] = c;\n+\n+\t  if ((utf8[1] & 0xc0) != 0x80)\n+\t    {\n+\t      /* Invalid UTF-8.  */\n+\t      putback_buf[num_putback++] = utf8[1];\n+\t      break;\n+\t    }\n+\t  else if ((utf8[0] & 0x20) == 0)\n+\t    {\n+\t      /* Valid 2-byte UTF-8.  */\n+\t      if (unicode_display == unicode_invalid)\n+\t\t{\n+\t\t  putback_buf[num_putback++] = utf8[1];\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  (void) display_utf8_char (utf8);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n+\t  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n+\t  if (c == EOF)\n+\t    break;\n+\t  utf8[2] = c;\n+\n+\t  if ((utf8[2] & 0xc0) != 0x80)\n+\t    {\n+\t      /* Invalid UTF-8.  */\n+\t      putback_buf[num_putback++] = utf8[2];\n+\t      putback_buf[num_putback++] = utf8[1];\n+\t      break;\n+\t    }\n+\t  else if ((utf8[0] & 0x10) == 0)\n+\t    {\n+\t      /* Valid 3-byte UTF-8.  */\n+\t      if (unicode_display == unicode_invalid)\n+\t\t{\n+\t\t  putback_buf[num_putback++] = utf8[2];\n+\t\t  putback_buf[num_putback++] = utf8[1];\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  (void) display_utf8_char (utf8);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n+\t  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n+\t  if (c == EOF)\n+\t    break;\n+\t  utf8[3] = c;\n+\n+\t  if ((utf8[3] & 0xc0) != 0x80)\n+\t    {\n+\t      /* Invalid UTF-8.  */\n+\t      putback_buf[num_putback++] = utf8[3];\n+\t      putback_buf[num_putback++] = utf8[2];\n+\t      putback_buf[num_putback++] = utf8[1];\n+\t      break;\n+\t    }\n+\t  else if (unicode_display == unicode_invalid)\n+\t    {\n+\t      putback_buf[num_putback++] = utf8[3];\n+\t      putback_buf[num_putback++] = utf8[2];\n+\t      putback_buf[num_putback++] = utf8[1];\n+\t      break;\n+\t    }\n+\t  else\n+\t    /* A valid 4-byte UTF-8 encoding.  */\n+\t    (void) display_utf8_char (utf8);\n+\t}\n+      while (1);\n+\n+      if (output_separator)\n+\tfputs (output_separator, stdout);\n+      else\n+\tputchar ('\\n');\n+    }\n+\n+  if (c != EOF)\n+    /* FIXME: Using tail recursion here is lazy, but it works.  */\n+    print_unicode_stream_body (filename, address + num_read, stream, putback_buf, num_putback, print_buf);\n+}\n+\n+/* Display strings read in from STREAM.  Treat any UTF-8 encoded characters\n+   encountered according to the setting of the unicode_display variable.\n+   The stream is positioned at ADDRESS and is attached to FILENAME.  */\n+\n+static void\n+print_unicode_stream (const char * filename,\n+\t\t      file_ptr     address,\n+\t\t      FILE *       stream)\n+{\n+  /* Paranoia checks...  */\n+  if (filename == NULL\n+      || stream == NULL\n+      || unicode_display == unicode_default\n+      || encoding != 'S'\n+      || encoding_bytes != 1)\n+    {\n+      fprintf (stderr, \"ICE: bad arguments to print_unicode_stream\\n\");\n+      return;\n+    }\n+\n+  /* Allocate space for string_min 4-byte utf-8 characters.  */\n+  unsigned char * print_buf = xmalloc ((4 * string_min) + 1);\n+  /* We should never have to put back more than 4 bytes.  */\n+  unsigned char putback_buf[5];\n+  uint num_putback = 0;\n+\n+  print_unicode_stream_body (filename, address, stream, putback_buf, num_putback, print_buf);\n+  free (print_buf);\n+}\n \f\n /* Find the strings in file FILENAME, read from STREAM.\n    Assume that STREAM is positioned so that the next byte read\n    is at address ADDRESS in the file.\n-   Stop reading at address STOP_POINT in the file, if nonzero.\n \n    If STREAM is NULL, do not read from it.\n    The caller can supply a buffer of characters\n@@ -566,20 +1232,29 @@ unget_part_char (long c, file_ptr *address, int *magiccount, char **magic)\n \n static void\n print_strings (const char *filename, FILE *stream, file_ptr address,\n-\t       int stop_point, int magiccount, char *magic)\n+\t       int magiccount, char *magic)\n {\n+  if (unicode_display != unicode_default)\n+    {\n+      if (magic != NULL)\n+\tprint_unicode_buffer (filename, address,\n+\t\t\t      (const unsigned char *) magic, magiccount);\n+\n+      if (stream != NULL)\n+\tprint_unicode_stream (filename, address, stream);\n+      return;\n+    }\n+\n   char *buf = (char *) xmalloc (sizeof (char) * (string_min + 1));\n \n   while (1)\n     {\n       file_ptr start;\n-      int i;\n+      uint i;\n       long c;\n \n       /* See if the next `string_min' chars are all graphic chars.  */\n     tryline:\n-      if (stop_point && address >= stop_point)\n-\tbreak;\n       start = address;\n       for (i = 0; i < string_min; i++)\n \t{\n@@ -601,51 +1276,7 @@ print_strings (const char *filename, FILE *stream, file_ptr address,\n \n       /* We found a run of `string_min' graphic characters.  Print up\n \t to the next non-graphic character.  */\n-\n-      if (print_filenames)\n-\tprintf (\"%s: \", filename);\n-      if (print_addresses)\n-\tswitch (address_radix)\n-\t  {\n-\t  case 8:\n-\t    if (sizeof (start) > sizeof (long))\n-\t      {\n-#ifndef __MSVCRT__\n-\t\tprintf (\"%7llo \", (unsigned long long) start);\n-#else\n-\t\tprintf (\"%7I64o \", (unsigned long long) start);\n-#endif\n-\t      }\n-\t    else\n-\t      printf (\"%7lo \", (unsigned long) start);\n-\t    break;\n-\n-\t  case 10:\n-\t    if (sizeof (start) > sizeof (long))\n-\t      {\n-#ifndef __MSVCRT__\n-\t\tprintf (\"%7llu \", (unsigned long long) start);\n-#else\n-\t\tprintf (\"%7I64d \", (unsigned long long) start);\n-#endif\n-\t      }\n-\t    else\n-\t      printf (\"%7ld \", (long) start);\n-\t    break;\n-\n-\t  case 16:\n-\t    if (sizeof (start) > sizeof (long))\n-\t      {\n-#ifndef __MSVCRT__\n-\t\tprintf (\"%7llx \", (unsigned long long) start);\n-#else\n-\t\tprintf (\"%7I64x \", (unsigned long long) start);\n-#endif\n-\t      }\n-\t    else\n-\t      printf (\"%7lx \", (unsigned long) start);\n-\t    break;\n-\t  }\n+      print_filename_and_address (filename, start);\n \n       buf[i] = '\\0';\n       fputs (buf, stdout);\n@@ -697,6 +1328,8 @@ usage (FILE *stream, int status)\n   -T --target=<BFDNAME>     Specify the binary file format\\n\\\n   -e --encoding={s,S,b,l,B,L} Select character size and endianness:\\n\\\n                             s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\\n\\\n+  --unicode={default|show|invalid|hex|escape|highlight}\\n\\\n+  -u {d|s|i|x|e|h}          Specify how to treat UTF-8 encoded unicode characters\\n\\\n   -s --output-separator=<string> String used to separate strings in output.\\n\\\n   @<file>                   Read options from <file>\\n\\\n   -h --help                 Display this information\\n\\"
    }
  ]
}