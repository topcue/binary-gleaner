{
  "sha": "e8c33fa16a85801af1812bc9e6120cdf0538b401",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZThjMzNmYTE2YTg1ODAxYWYxODEyYmM5ZTYxMjBjZGYwNTM4YjQwMQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:35Z"
    },
    "message": "Introduce ada_unop_ind_operation\n\nThis adds class ada_unop_ind_operation, which implements UNOP_IND for\nAda.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (ada_unop_ind_operation::evaluate): New method.\n\t* ada-exp.h (class ada_unop_ind_operation): New.",
    "tree": {
      "sha": "925ca7ffa23714402c31e2a8de3789da2577b8d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/925ca7ffa23714402c31e2a8de3789da2577b8d6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e8c33fa16a85801af1812bc9e6120cdf0538b401",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e8c33fa16a85801af1812bc9e6120cdf0538b401",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e8c33fa16a85801af1812bc9e6120cdf0538b401",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e8c33fa16a85801af1812bc9e6120cdf0538b401/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "065ec8268d5b1eb1895da4328d3bc9a5a5d043d1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/065ec8268d5b1eb1895da4328d3bc9a5a5d043d1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/065ec8268d5b1eb1895da4328d3bc9a5a5d043d1"
    }
  ],
  "stats": {
    "total": 103,
    "additions": 103,
    "deletions": 0
  },
  "files": [
    {
      "sha": "5f6dcfbf389523f630b274305b5066575595829d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e8c33fa16a85801af1812bc9e6120cdf0538b401/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e8c33fa16a85801af1812bc9e6120cdf0538b401/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=e8c33fa16a85801af1812bc9e6120cdf0538b401",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (ada_unop_ind_operation::evaluate): New method.\n+\t* ada-exp.h (class ada_unop_ind_operation): New.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ada-lang.c (ada_binop_exp): No longer static."
    },
    {
      "sha": "c87036e2d19ad129bbe5e8353e090136e2ac236b",
      "filename": "gdb/ada-exp.h",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e8c33fa16a85801af1812bc9e6120cdf0538b401/gdb/ada-exp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e8c33fa16a85801af1812bc9e6120cdf0538b401/gdb/ada-exp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.h?ref=e8c33fa16a85801af1812bc9e6120cdf0538b401",
      "patch": "@@ -358,6 +358,19 @@ class ada_atr_val_operation\n   { return OP_ATR_VAL; }\n };\n \n+/* The indirection operator for Ada.  */\n+class ada_unop_ind_operation\n+  : public unop_ind_base_operation\n+{\n+public:\n+\n+  using unop_ind_base_operation::unop_ind_base_operation;\n+\n+  value *evaluate (struct type *expect_type,\n+\t\t   struct expression *exp,\n+\t\t   enum noside noside) override;\n+};\n+\n } /* namespace expr */\n \n #endif /* ADA_EXP_H */"
    },
    {
      "sha": "5998ae7096e6eba0844c51a6370ba67588fef4e5",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 85,
      "deletions": 0,
      "changes": 85,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e8c33fa16a85801af1812bc9e6120cdf0538b401/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e8c33fa16a85801af1812bc9e6120cdf0538b401/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=e8c33fa16a85801af1812bc9e6120cdf0538b401",
      "patch": "@@ -10703,6 +10703,91 @@ ada_atr_val_operation::evaluate (struct type *expect_type,\n   return ada_val_atr (noside, std::get<0> (m_storage), arg);\n }\n \n+value *\n+ada_unop_ind_operation::evaluate (struct type *expect_type,\n+\t\t\t\t  struct expression *exp,\n+\t\t\t\t  enum noside noside)\n+{\n+  value *arg1 = std::get<0> (m_storage)->evaluate (expect_type, exp, noside);\n+\n+  struct type *type = ada_check_typedef (value_type (arg1));\n+  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n+    {\n+      if (ada_is_array_descriptor_type (type))\n+\t/* GDB allows dereferencing GNAT array descriptors.  */\n+\t{\n+\t  struct type *arrType = ada_type_of_array (arg1, 0);\n+\n+\t  if (arrType == NULL)\n+\t    error (_(\"Attempt to dereference null array pointer.\"));\n+\t  return value_at_lazy (arrType, 0);\n+\t}\n+      else if (type->code () == TYPE_CODE_PTR\n+\t       || type->code () == TYPE_CODE_REF\n+\t       /* In C you can dereference an array to get the 1st elt.  */\n+\t       || type->code () == TYPE_CODE_ARRAY)\n+\t{\n+\t  /* As mentioned in the OP_VAR_VALUE case, tagged types can\n+\t     only be determined by inspecting the object's tag.\n+\t     This means that we need to evaluate completely the\n+\t     expression in order to get its type.  */\n+\n+\t  if ((type->code () == TYPE_CODE_REF\n+\t       || type->code () == TYPE_CODE_PTR)\n+\t      && ada_is_tagged_type (TYPE_TARGET_TYPE (type), 0))\n+\t    {\n+\t      arg1 = std::get<0> (m_storage)->evaluate (nullptr, exp,\n+\t\t\t\t\t\t\tEVAL_NORMAL);\n+\t      type = value_type (ada_value_ind (arg1));\n+\t    }\n+\t  else\n+\t    {\n+\t      type = to_static_fixed_type\n+\t\t(ada_aligned_type\n+\t\t (ada_check_typedef (TYPE_TARGET_TYPE (type))));\n+\t    }\n+\t  ada_ensure_varsize_limit (type);\n+\t  return value_zero (type, lval_memory);\n+\t}\n+      else if (type->code () == TYPE_CODE_INT)\n+\t{\n+\t  /* GDB allows dereferencing an int.  */\n+\t  if (expect_type == NULL)\n+\t    return value_zero (builtin_type (exp->gdbarch)->builtin_int,\n+\t\t\t       lval_memory);\n+\t  else\n+\t    {\n+\t      expect_type =\n+\t\tto_static_fixed_type (ada_aligned_type (expect_type));\n+\t      return value_zero (expect_type, lval_memory);\n+\t    }\n+\t}\n+      else\n+\terror (_(\"Attempt to take contents of a non-pointer value.\"));\n+    }\n+  arg1 = ada_coerce_ref (arg1);     /* FIXME: What is this for??  */\n+  type = ada_check_typedef (value_type (arg1));\n+\n+  if (type->code () == TYPE_CODE_INT)\n+    /* GDB allows dereferencing an int.  If we were given\n+       the expect_type, then use that as the target type.\n+       Otherwise, assume that the target type is an int.  */\n+    {\n+      if (expect_type != NULL)\n+\treturn ada_value_ind (value_cast (lookup_pointer_type (expect_type),\n+\t\t\t\t\t  arg1));\n+      else\n+\treturn value_at_lazy (builtin_type (exp->gdbarch)->builtin_int,\n+\t\t\t      (CORE_ADDR) value_as_address (arg1));\n+    }\n+\n+  if (ada_is_array_descriptor_type (type))\n+    /* GDB allows dereferencing GNAT array descriptors.  */\n+    return ada_coerce_to_simple_array (arg1);\n+  else\n+    return ada_value_ind (arg1);\n+}\n+\n }\n \n /* Implement the evaluate_exp routine in the exp_descriptor structure"
    }
  ]
}