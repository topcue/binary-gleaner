{
  "sha": "6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmQ0ZDkzMjg2N2ZhOGIzYzY4NWIzYTM1OGJmODFmN2Y2YzZlYTdkNg==",
  "commit": {
    "author": {
      "name": "Cl\u00e9ment Chigot",
      "email": "clement.chigot@atos.net",
      "date": "2021-03-11T10:08:18Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-12T02:34:00Z"
    },
    "message": "bfd: use default coff_write_object_contents for XCOFF64\n\nThere is no need for XCOFF64 to have is own write_object_contents.\n\n\t* coff64-rs6000.c (xcoff64_write_object_contents): Remove.\n\t* coffcode.h (coff_write_object_contents): Add bfd_mach_ppc_620\n\tsupport for o_cputype field.  Avoid creating an empty a.out header\n\tfor XCOFF64.",
    "tree": {
      "sha": "63250f6accc28da049cb258d140637730ffc5b48",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/63250f6accc28da049cb258d140637730ffc5b48"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6/comments",
  "author": {
    "login": "Helflym",
    "id": 23002587,
    "node_id": "MDQ6VXNlcjIzMDAyNTg3",
    "avatar_url": "https://avatars.githubusercontent.com/u/23002587?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Helflym",
    "html_url": "https://github.com/Helflym",
    "followers_url": "https://api.github.com/users/Helflym/followers",
    "following_url": "https://api.github.com/users/Helflym/following{/other_user}",
    "gists_url": "https://api.github.com/users/Helflym/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Helflym/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Helflym/subscriptions",
    "organizations_url": "https://api.github.com/users/Helflym/orgs",
    "repos_url": "https://api.github.com/users/Helflym/repos",
    "events_url": "https://api.github.com/users/Helflym/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Helflym/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8aa2d0236a5cf981aff44cf679515c6031a152bd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8aa2d0236a5cf981aff44cf679515c6031a152bd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8aa2d0236a5cf981aff44cf679515c6031a152bd"
    }
  ],
  "stats": {
    "total": 365,
    "additions": 14,
    "deletions": 351
  },
  "files": [
    {
      "sha": "95dcc5718efd0c9431830302d90bdfc4491bdd43",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
      "patch": "@@ -1,3 +1,10 @@\n+2021-03-12  Cl\u00e9ment Chigot  <clement.chigot@atos.net>\n+\n+\t* coff64-rs6000.c (xcoff64_write_object_contents): Remove.\n+\t* coffcode.h (coff_write_object_contents): Add bfd_mach_ppc_620\n+\tsupport for o_cputype field.  Avoid creating an empty a.out header\n+\tfor XCOFF64.\n+\n 2021-03-12  Cl\u00e9ment Chigot  <clement.chigot@atos.net>\n \n \t* coff64-rs6000.c (xcoff64_create_csect_from_smclas): Add"
    },
    {
      "sha": "a31a6fb91a98157dabc72503e6852b28f56e8bb0",
      "filename": "bfd/coff64-rs6000.c",
      "status": "modified",
      "additions": 2,
      "deletions": 350,
      "changes": 352,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6/bfd/coff64-rs6000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6/bfd/coff64-rs6000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff64-rs6000.c?ref=6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
      "patch": "@@ -147,8 +147,6 @@ static void xcoff64_swap_ldrel_in\n   (bfd *, const void *, struct internal_ldrel *);\n static void xcoff64_swap_ldrel_out\n   (bfd *, const struct internal_ldrel *, void *d);\n-static bfd_boolean xcoff64_write_object_contents\n-  (bfd *);\n static bfd_boolean xcoff64_ppc_relocate_section\n   (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,\n    struct internal_reloc *, struct internal_syment *,\n@@ -711,352 +709,6 @@ xcoff64_swap_ldrel_out (bfd *abfd, const struct internal_ldrel *src, void *d)\n   bfd_put_32 (abfd, src->l_symndx, dst->l_symndx);\n }\n \n-static bfd_boolean\n-xcoff64_write_object_contents (bfd *abfd)\n-{\n-  asection *current;\n-  bfd_boolean hasrelocs = FALSE;\n-  bfd_boolean haslinno = FALSE;\n-  file_ptr scn_base;\n-  file_ptr reloc_base;\n-  file_ptr lineno_base;\n-  file_ptr sym_base;\n-  unsigned long reloc_size = 0;\n-  unsigned long lnno_size = 0;\n-  asection *text_sec = NULL;\n-  asection *data_sec = NULL;\n-  asection *bss_sec = NULL;\n-  struct internal_filehdr internal_f;\n-  struct internal_aouthdr internal_a;\n-\n-  bfd_set_error (bfd_error_system_call);\n-\n-  if (! abfd->output_has_begun)\n-    {\n-      if (! bfd_coff_compute_section_file_positions (abfd))\n-\treturn FALSE;\n-    }\n-\n-  /* Work out the size of the reloc and linno areas.  */\n-  reloc_base = obj_relocbase (abfd);\n-\n-  for (current = abfd->sections; current != NULL; current = current->next)\n-    reloc_size += current->reloc_count * bfd_coff_relsz (abfd);\n-\n-  lineno_base = reloc_base + reloc_size;\n-\n-  /* Make a pass through the symbol table to count line number entries and\n-     put them into the correct asections.  */\n-  lnno_size = coff_count_linenumbers (abfd) * bfd_coff_linesz (abfd);\n-\n-  sym_base = lineno_base + lnno_size;\n-\n-  /* Indicate in each section->line_filepos its actual file address.  */\n-  for (current = abfd->sections; current != NULL; current =  current->next)\n-    {\n-      if (current->lineno_count)\n-\t{\n-\t  current->line_filepos = lineno_base;\n-\t  current->moving_line_filepos = lineno_base;\n-\t  lineno_base += current->lineno_count * bfd_coff_linesz (abfd);\n-\t}\n-      else\n-\t{\n-\t  current->line_filepos = 0;\n-\t}\n-\n-      if (current->reloc_count)\n-\t{\n-\t  current->rel_filepos = reloc_base;\n-\t  reloc_base += current->reloc_count * bfd_coff_relsz (abfd);\n-\t}\n-      else\n-\t{\n-\t  current->rel_filepos = 0;\n-\t}\n-    }\n-\n-  if ((abfd->flags & EXEC_P) != 0)\n-    {\n-      scn_base = bfd_coff_filhsz (abfd) + bfd_coff_aoutsz (abfd);\n-      internal_f.f_opthdr = bfd_coff_aoutsz (abfd);\n-    }\n-  else\n-    {\n-      scn_base = bfd_coff_filhsz (abfd);\n-      internal_f.f_opthdr = 0;\n-    }\n-\n-  internal_f.f_nscns = 0;\n-\n-  if (bfd_seek (abfd, scn_base, SEEK_SET) != 0)\n-    return FALSE;\n-\n-  for (current = abfd->sections; current != NULL; current = current->next)\n-    {\n-      struct internal_scnhdr section;\n-      struct external_scnhdr buff;\n-      bfd_size_type amount;\n-\n-      internal_f.f_nscns++;\n-\n-      strncpy (section.s_name, current->name, SCNNMLEN);\n-\n-      section.s_vaddr = current->vma;\n-      section.s_paddr = current->lma;\n-      section.s_size =  current->size;\n-\n-      /* If this section has no size or is unloadable then the scnptr\n-\t will be 0 too.  */\n-      if (current->size == 0\n-\t  || (current->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)\n-\t{\n-\t  section.s_scnptr = 0;\n-\t}\n-      else\n-\t{\n-\t  section.s_scnptr = current->filepos;\n-\t}\n-\n-      section.s_relptr = current->rel_filepos;\n-      section.s_lnnoptr = current->line_filepos;\n-      section.s_nreloc = current->reloc_count;\n-\n-      section.s_nlnno = current->lineno_count;\n-      if (current->reloc_count != 0)\n-\thasrelocs = TRUE;\n-      if (current->lineno_count != 0)\n-\thaslinno = TRUE;\n-\n-      section.s_flags = sec_to_styp_flags (current->name, current->flags);\n-\n-      if (!strcmp (current->name, _TEXT))\n-\t{\n-\t  text_sec = current;\n-\t}\n-      else if (!strcmp (current->name, _DATA))\n-\t{\n-\t  data_sec = current;\n-\t}\n-      else if (!strcmp (current->name, _BSS))\n-\t{\n-\t  bss_sec = current;\n-\t}\n-\n-      amount = bfd_coff_scnhsz (abfd);\n-      if (bfd_coff_swap_scnhdr_out (abfd, &section, &buff) == 0\n-\t  || bfd_bwrite (&buff, amount, abfd) != amount)\n-\treturn FALSE;\n-    }\n-\n-  internal_f.f_timdat = 0;\n-\n-  internal_f.f_flags = 0;\n-\n-  if (!hasrelocs)\n-    internal_f.f_flags |= F_RELFLG;\n-  if (!haslinno)\n-    internal_f.f_flags |= F_LNNO;\n-  if (abfd->flags & EXEC_P)\n-    internal_f.f_flags |= F_EXEC;\n-\n-  /* FIXME: this is wrong for PPC_PE!  */\n-  if (bfd_little_endian (abfd))\n-    internal_f.f_flags |= F_AR32WR;\n-  else\n-    internal_f.f_flags |= F_AR32W;\n-\n-  if ((abfd->flags & DYNAMIC) != 0)\n-    internal_f.f_flags |= F_SHROBJ;\n-  if (bfd_get_section_by_name (abfd, _LOADER) != NULL)\n-    internal_f.f_flags |= F_DYNLOAD;\n-\n-  memset (&internal_a, 0, sizeof internal_a);\n-\n-  internal_f.f_magic = bfd_xcoff_magic_number (abfd);\n-  internal_a.magic = (abfd->flags & D_PAGED\n-\t\t      ? RS6K_AOUTHDR_ZMAGIC\n-\t\t      : (abfd->flags & WP_TEXT\n-\t\t\t ? RS6K_AOUTHDR_NMAGIC\n-\t\t\t : RS6K_AOUTHDR_OMAGIC));\n-\n-  /* FIXME: Does anybody ever set this to another value?  */\n-  internal_a.vstamp = 0;\n-\n-  /* Now should write relocs, strings, syms.  */\n-  obj_sym_filepos (abfd) = sym_base;\n-\n-  internal_f.f_symptr = 0;\n-  internal_f.f_nsyms = 0;\n-\n-  /* If bfd_get_symcount (abfd) != 0, then we are not using the COFF\n-     backend linker, and obj_raw_syment_count is not valid until after\n-     coff_write_symbols is called.  */\n-  if (bfd_get_symcount (abfd) != 0)\n-    {\n-      int firstundef;\n-\n-      if (!coff_renumber_symbols (abfd, &firstundef))\n-\treturn FALSE;\n-      coff_mangle_symbols (abfd);\n-      if (! coff_write_symbols (abfd))\n-\treturn FALSE;\n-      if (! coff_write_linenumbers (abfd))\n-\treturn FALSE;\n-      if (! coff_write_relocs (abfd, firstundef))\n-\treturn FALSE;\n-\n-      internal_f.f_symptr = sym_base;\n-      internal_f.f_nsyms = bfd_get_symcount (abfd);\n-    }\n-  else if (obj_raw_syment_count (abfd) != 0)\n-    {\n-      internal_f.f_symptr = sym_base;\n-\n-      /* AIX appears to require that F_RELFLG not be set if there are\n-\t local symbols but no relocations.  */\n-      internal_f.f_flags &=~ F_RELFLG;\n-    }\n-  else\n-    {\n-      internal_f.f_flags |= F_LSYMS;\n-    }\n-\n-  if (text_sec)\n-    {\n-      internal_a.tsize = text_sec->size;\n-      internal_a.text_start = internal_a.tsize ? text_sec->vma : 0;\n-    }\n-\n-  if (data_sec)\n-    {\n-      internal_a.dsize = data_sec->size;\n-      internal_a.data_start = internal_a.dsize ? data_sec->vma : 0;\n-    }\n-\n-  if (bss_sec)\n-    {\n-      internal_a.bsize = bss_sec->size;\n-      if (internal_a.bsize && bss_sec->vma < internal_a.data_start)\n-\tinternal_a.data_start = bss_sec->vma;\n-    }\n-\n-  internal_a.entry = bfd_get_start_address (abfd);\n-  internal_f.f_nsyms = obj_raw_syment_count (abfd);\n-\n-  if (xcoff_data (abfd)->full_aouthdr)\n-    {\n-      bfd_vma toc;\n-      asection *loader_sec;\n-\n-      internal_a.vstamp = 1;\n-\n-      internal_a.o_snentry = xcoff_data (abfd)->snentry;\n-      if (internal_a.o_snentry == 0)\n-\tinternal_a.entry = (bfd_vma) -1;\n-\n-      if (text_sec != NULL)\n-\t{\n-\t  internal_a.o_sntext = text_sec->target_index;\n-\t  internal_a.o_algntext = bfd_section_alignment (text_sec);\n-\t}\n-      else\n-\t{\n-\t  internal_a.o_sntext = 0;\n-\t  internal_a.o_algntext = 0;\n-\t}\n-\n-      if (data_sec != NULL)\n-\t{\n-\t  internal_a.o_sndata = data_sec->target_index;\n-\t  internal_a.o_algndata = bfd_section_alignment (data_sec);\n-\t}\n-      else\n-\t{\n-\t  internal_a.o_sndata = 0;\n-\t  internal_a.o_algndata = 0;\n-\t}\n-\n-      loader_sec = bfd_get_section_by_name (abfd, \".loader\");\n-      if (loader_sec != NULL)\n-\tinternal_a.o_snloader = loader_sec->target_index;\n-      else\n-\tinternal_a.o_snloader = 0;\n-      if (bss_sec != NULL)\n-\tinternal_a.o_snbss = bss_sec->target_index;\n-      else\n-\tinternal_a.o_snbss = 0;\n-\n-      toc = xcoff_data (abfd)->toc;\n-      internal_a.o_toc = toc;\n-      internal_a.o_sntoc = xcoff_data (abfd)->sntoc;\n-\n-      internal_a.o_modtype = xcoff_data (abfd)->modtype;\n-      if (xcoff_data (abfd)->cputype != -1)\n-\tinternal_a.o_cputype = xcoff_data (abfd)->cputype;\n-      else\n-\t{\n-\t  switch (bfd_get_arch (abfd))\n-\t    {\n-\t    case bfd_arch_rs6000:\n-\t      internal_a.o_cputype = 4;\n-\t      break;\n-\t    case bfd_arch_powerpc:\n-\t      if (bfd_get_mach (abfd) == bfd_mach_ppc)\n-\t\tinternal_a.o_cputype = 3;\n-\t      else if (bfd_get_mach (abfd) == bfd_mach_ppc_620)\n-\t\tinternal_a.o_cputype = 2;\n-\t      else\n-\t\tinternal_a.o_cputype = 1;\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t}\n-      internal_a.o_maxstack = xcoff_data (abfd)->maxstack;\n-      internal_a.o_maxdata = xcoff_data (abfd)->maxdata;\n-    }\n-\n-  if (bfd_seek (abfd, (file_ptr) 0, 0) != 0)\n-    return FALSE;\n-\n-  {\n-    char * buff;\n-    bfd_size_type amount = bfd_coff_filhsz (abfd);\n-\n-    buff = bfd_malloc (amount);\n-    if (buff == NULL)\n-      return FALSE;\n-\n-    bfd_coff_swap_filehdr_out (abfd, &internal_f, buff);\n-    amount = bfd_bwrite (buff, amount, abfd);\n-\n-    free (buff);\n-\n-    if (amount != bfd_coff_filhsz (abfd))\n-      return FALSE;\n-  }\n-\n-  if (abfd->flags & EXEC_P)\n-    {\n-      char * buff;\n-      bfd_size_type amount = bfd_coff_aoutsz (abfd);\n-\n-      buff = bfd_malloc (amount);\n-      if (buff == NULL)\n-\treturn FALSE;\n-\n-      bfd_coff_swap_aouthdr_out (abfd, &internal_a, buff);\n-      amount = bfd_bwrite (buff, amount, abfd);\n-\n-      free (buff);\n-\n-      if (amount != bfd_coff_aoutsz (abfd))\n-\treturn FALSE;\n-    }\n-\n-  return TRUE;\n-}\n \n static bfd_boolean\n xcoff64_reloc_type_br (bfd *input_bfd,\n@@ -2702,7 +2354,7 @@ const bfd_target rs6000_xcoff64_vec =\n \n     {/* bfd_write_contents */\n       _bfd_bool_bfd_false_error,\n-      xcoff64_write_object_contents,\n+      coff_write_object_contents,\n       _bfd_xcoff_write_archive_contents,\n       _bfd_bool_bfd_false_error\n     },\n@@ -2966,7 +2618,7 @@ const bfd_target rs6000_xcoff64_aix_vec =\n \n     {/* bfd_write_contents */\n       _bfd_bool_bfd_false_error,\n-      xcoff64_write_object_contents,\n+      coff_write_object_contents,\n       _bfd_xcoff_write_archive_contents,\n       _bfd_bool_bfd_false_error\n     },"
    },
    {
      "sha": "b0ca266fa0d81911f76ef41ef9040d362e78259c",
      "filename": "bfd/coffcode.h",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6/bfd/coffcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6/bfd/coffcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffcode.h?ref=6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
      "patch": "@@ -4058,6 +4058,8 @@ coff_write_object_contents (bfd * abfd)\n \t    case bfd_arch_powerpc:\n \t      if (bfd_get_mach (abfd) == bfd_mach_ppc)\n \t\tinternal_a.o_cputype = 3;\n+\t      else if (bfd_get_mach (abfd) == bfd_mach_ppc_620)\n+\t\tinternal_a.o_cputype = 2;\n \t      else\n \t\tinternal_a.o_cputype = 1;\n \t      break;\n@@ -4127,12 +4129,13 @@ coff_write_object_contents (bfd * abfd)\n #endif\n     }\n #ifdef RS6000COFF_C\n+#ifndef XCOFF64\n   else\n     {\n       AOUTHDR buff;\n       size_t size;\n \n-      /* XCOFF seems to always write at least a small a.out header.  */\n+      /* XCOFF32 seems to always write at least a small a.out header.  */\n       coff_swap_aouthdr_out (abfd, & internal_a, & buff);\n       if (xcoff_data (abfd)->full_aouthdr)\n \tsize = bfd_coff_aoutsz (abfd);\n@@ -4141,6 +4144,7 @@ coff_write_object_contents (bfd * abfd)\n       if (bfd_bwrite (& buff, (bfd_size_type) size, abfd) != size)\n \treturn FALSE;\n     }\n+#endif\n #endif\n \n   return TRUE;"
    }
  ]
}