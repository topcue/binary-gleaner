{
  "sha": "d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDVhMjJlNzdiNTY1MjllYWRlNzg3NDE5ZWE4MGE3ZTllN2QyYWE2Zg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-11-25T19:31:02Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-12-04T16:31:18Z"
    },
    "message": "Remove gdbarch_bits_big_endian\n\nFrom what I can tell, set_gdbarch_bits_big_endian has never been used.\nThat is, all architectures since its introduction have simply used the\ndefault, which is simply check the architecture's byte-endianness.\n\nBecause this interferes with the scalar_storage_order code, this patch\nremoves this gdbarch setting entirely.  In some places,\ntype_byte_order is used rather than the plain gdbarch.\n\ngdb/ChangeLog\n2019-12-04  Tom Tromey  <tromey@adacore.com>\n\n\t* ada-lang.c (decode_constrained_packed_array)\n\t(ada_value_assign, value_assign_to_component): Update.\n\t* dwarf2loc.c (rw_pieced_value, access_memory)\n\t(dwarf2_compile_expr_to_ax): Update.\n\t* dwarf2read.c (dwarf2_add_field): Update.\n\t* eval.c (evaluate_subexp_standard): Update.\n\t* gdbarch.c, gdbarch.h: Rebuild.\n\t* gdbarch.sh (bits_big_endian): Remove.\n\t* gdbtypes.h (union field_location): Update comment.\n\t* target-descriptions.c (make_gdb_type): Update.\n\t* valarith.c (value_bit_index): Update.\n\t* value.c (struct value) <bitpos>: Update comment.\n\t(unpack_bits_as_long, modify_field): Update.\n\t* value.h (value_bitpos): Update comment.\n\nChange-Id: I379b5e0c408ec8742f7a6c6b721108e73ed1b018",
    "tree": {
      "sha": "9efbd056575604aae8ac03e072aac8e2439ea3cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9efbd056575604aae8ac03e072aac8e2439ea3cd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7ab4a236ce85f1e0950e88e267e679a066b77bed",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7ab4a236ce85f1e0950e88e267e679a066b77bed",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7ab4a236ce85f1e0950e88e267e679a066b77bed"
    }
  ],
  "stats": {
    "total": 92,
    "additions": 37,
    "deletions": 55
  },
  "files": [
    {
      "sha": "e09a5887d14c505dd2f1e2d39face297dee993a1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -1,3 +1,20 @@\n+2019-12-04  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ada-lang.c (decode_constrained_packed_array)\n+\t(ada_value_assign, value_assign_to_component): Update.\n+\t* dwarf2loc.c (rw_pieced_value, access_memory)\n+\t(dwarf2_compile_expr_to_ax): Update.\n+\t* dwarf2read.c (dwarf2_add_field): Update.\n+\t* eval.c (evaluate_subexp_standard): Update.\n+\t* gdbarch.c, gdbarch.h: Rebuild.\n+\t* gdbarch.sh (bits_big_endian): Remove.\n+\t* gdbtypes.h (union field_location): Update comment.\n+\t* target-descriptions.c (make_gdb_type): Update.\n+\t* valarith.c (value_bit_index): Update.\n+\t* value.c (struct value) <bitpos>: Update comment.\n+\t(unpack_bits_as_long, modify_field): Update.\n+\t* value.h (value_bitpos): Update comment.\n+\n 2019-12-04  Tom Tromey  <tromey@adacore.com>\n \n \t* gdbtypes.c (type_byte_order): Move earlier.  Assert for unknown"
    },
    {
      "sha": "3289a8e5c8eef918370afe44298808210f9b864e",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -2257,7 +2257,7 @@ decode_constrained_packed_array (struct value *arr)\n       return NULL;\n     }\n \n-  if (gdbarch_bits_big_endian (get_type_arch (value_type (arr)))\n+  if (type_byte_order (value_type (arr)) == BFD_ENDIAN_BIG\n       && ada_is_modular_type (value_type (arr)))\n     {\n        /* This is a (right-justified) modular type representing a packed\n@@ -2499,7 +2499,7 @@ ada_value_primitive_packed_val (struct value *obj, const gdb_byte *valaddr,\n   const gdb_byte *src;                /* First byte containing data to unpack */\n   gdb_byte *unpacked;\n   const int is_scalar = is_scalar_type (type);\n-  const int is_big_endian = gdbarch_bits_big_endian (get_type_arch (type));\n+  const int is_big_endian = type_byte_order (type) == BFD_ENDIAN_BIG;\n   gdb::byte_vector staging;\n \n   type = ada_check_typedef (type);\n@@ -2645,7 +2645,7 @@ ada_value_assign (struct value *toval, struct value *fromval)\n       if (from_size == 0)\n \tfrom_size = TYPE_LENGTH (value_type (fromval)) * TARGET_CHAR_BIT;\n \n-      const int is_big_endian = gdbarch_bits_big_endian (get_type_arch (type));\n+      const int is_big_endian = type_byte_order (type) == BFD_ENDIAN_BIG;\n       ULONGEST from_offset = 0;\n       if (is_big_endian && is_scalar_type (value_type (fromval)))\n \tfrom_offset = from_size - bits;\n@@ -2694,7 +2694,7 @@ value_assign_to_component (struct value *container, struct value *component,\n   else\n     bits = value_bitsize (component);\n \n-  if (gdbarch_bits_big_endian (get_type_arch (value_type (container))))\n+  if (type_byte_order (value_type (container)) == BFD_ENDIAN_BIG)\n     {\n       int src_offset;\n "
    },
    {
      "sha": "976d453d3ca2283fe2f75084544050dd42a94dac",
      "filename": "gdb/dwarf2loc.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/dwarf2loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/dwarf2loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2loc.c?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -1577,8 +1577,7 @@ rw_pieced_value (struct value *v, struct value *from)\n   struct piece_closure *c\n     = (struct piece_closure *) value_computed_closure (v);\n   gdb::byte_vector buffer;\n-  int bits_big_endian\n-    = gdbarch_bits_big_endian (get_type_arch (value_type (v)));\n+  bool bits_big_endian = type_byte_order (value_type (v)) == BFD_ENDIAN_BIG;\n \n   if (from != NULL)\n     {\n@@ -2817,7 +2816,7 @@ access_memory (struct gdbarch *arch, struct agent_expr *expr, ULONGEST nbits)\n   if (8 * nbytes == nbits)\n     return;\n \n-  if (gdbarch_bits_big_endian (arch))\n+  if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG)\n     {\n       /* On a bits-big-endian machine, we want the high-order\n \t NBITS.  */\n@@ -2867,7 +2866,7 @@ dwarf2_compile_expr_to_ax (struct agent_expr *expr, struct axs_value *loc,\n   enum bfd_endian byte_order = gdbarch_byte_order (arch);\n   ULONGEST bits_collected = 0;\n   unsigned int addr_size_bits = 8 * addr_size;\n-  int bits_big_endian = gdbarch_bits_big_endian (arch);\n+  bool bits_big_endian = byte_order == BFD_ENDIAN_BIG;\n \n   std::vector<int> offsets (op_end - op_ptr, -1);\n "
    },
    {
      "sha": "e009b523ccc831ca315f13a5ec4a44f8b8946242",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -15127,7 +15127,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       attr = dwarf2_attr (die, DW_AT_bit_offset, cu);\n       if (attr != nullptr)\n \t{\n-\t  if (gdbarch_bits_big_endian (gdbarch))\n+\t  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)\n \t    {\n \t      /* For big endian bits, the DW_AT_bit_offset gives the\n \t         additional bit offset from the MSB of the containing"
    },
    {
      "sha": "87874420dc8643f422b78a7adac9039c89198a9a",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -1547,7 +1547,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t\t{\n \t\t  int bit_index = (unsigned) range_low % TARGET_CHAR_BIT;\n \n-\t\t  if (gdbarch_bits_big_endian (exp->gdbarch))\n+\t\t  if (gdbarch_byte_order (exp->gdbarch) == BFD_ENDIAN_BIG)\n \t\t    bit_index = TARGET_CHAR_BIT - 1 - bit_index;\n \t\t  valaddr[(unsigned) range_low / TARGET_CHAR_BIT]\n \t\t    |= 1 << bit_index;"
    },
    {
      "sha": "59c97da9853e4ac3eb7b5d98e6341a90863c50ad",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 0,
      "deletions": 23,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -172,7 +172,6 @@ struct gdbarch\n \n      */\n \n-  int bits_big_endian;\n   int short_bit;\n   int int_bit;\n   int long_bit;\n@@ -389,7 +388,6 @@ gdbarch_alloc (const struct gdbarch_info *info,\n   gdbarch->target_desc = info->target_desc;\n \n   /* Force the explicit initialization of these.  */\n-  gdbarch->bits_big_endian = (gdbarch->byte_order == BFD_ENDIAN_BIG);\n   gdbarch->short_bit = 2*TARGET_CHAR_BIT;\n   gdbarch->int_bit = 4*TARGET_CHAR_BIT;\n   gdbarch->long_bit = 4*TARGET_CHAR_BIT;\n@@ -528,7 +526,6 @@ verify_gdbarch (struct gdbarch *gdbarch)\n   if (gdbarch->bfd_arch_info == NULL)\n     log.puts (\"\\n\\tbfd_arch_info\");\n   /* Check those that need to be defined for the given multi-arch level.  */\n-  /* Skip verify of bits_big_endian, invalid_p == 0 */\n   /* Skip verify of short_bit, invalid_p == 0 */\n   /* Skip verify of int_bit, invalid_p == 0 */\n   /* Skip verify of long_bit, invalid_p == 0 */\n@@ -816,9 +813,6 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: bfd_arch_info = %s\\n\",\n                       gdbarch_bfd_arch_info (gdbarch)->printable_name);\n-  fprintf_unfiltered (file,\n-                      \"gdbarch_dump: bits_big_endian = %s\\n\",\n-                      plongest (gdbarch->bits_big_endian));\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: breakpoint_from_pc = <%s>\\n\",\n                       host_address_to_string (gdbarch->breakpoint_from_pc));\n@@ -1564,23 +1558,6 @@ gdbarch_target_desc (struct gdbarch *gdbarch)\n   return gdbarch->target_desc;\n }\n \n-int\n-gdbarch_bits_big_endian (struct gdbarch *gdbarch)\n-{\n-  gdb_assert (gdbarch != NULL);\n-  /* Skip verify of bits_big_endian, invalid_p == 0 */\n-  if (gdbarch_debug >= 2)\n-    fprintf_unfiltered (gdb_stdlog, \"gdbarch_bits_big_endian called\\n\");\n-  return gdbarch->bits_big_endian;\n-}\n-\n-void\n-set_gdbarch_bits_big_endian (struct gdbarch *gdbarch,\n-                             int bits_big_endian)\n-{\n-  gdbarch->bits_big_endian = bits_big_endian;\n-}\n-\n int\n gdbarch_short_bit (struct gdbarch *gdbarch)\n {"
    },
    {
      "sha": "78e05ecdcb93b8ae8dc843d27618f82cb0adde59",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -146,12 +146,6 @@ extern const struct target_desc * gdbarch_target_desc (struct gdbarch *gdbarch);\n \n /* The following are initialized by the target dependent code.  */\n \n-/* The bit byte-order has to do just with numbering of bits in debugging symbols\n-   and such.  Conceptually, it's quite separate from byte/word byte order. */\n-\n-extern int gdbarch_bits_big_endian (struct gdbarch *gdbarch);\n-extern void set_gdbarch_bits_big_endian (struct gdbarch *gdbarch, int bits_big_endian);\n-\n /* Number of bits in a short or unsigned short for the target machine. */\n \n extern int gdbarch_short_bit (struct gdbarch *gdbarch);"
    },
    {
      "sha": "331eb392781eb759d38303897947e7a950b3c8dc",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -347,10 +347,6 @@ i;enum gdb_osabi;osabi;;;GDB_OSABI_UNKNOWN\n #\n i;const struct target_desc *;target_desc;;;;;;;host_address_to_string (gdbarch->target_desc)\n \n-# The bit byte-order has to do just with numbering of bits in debugging symbols\n-# and such.  Conceptually, it's quite separate from byte/word byte order.\n-v;int;bits_big_endian;;;1;(gdbarch->byte_order == BFD_ENDIAN_BIG);;0\n-\n # Number of bits in a short or unsigned short for the target machine.\n v;int;short_bit;;;8 * sizeof (short);2*TARGET_CHAR_BIT;;0\n # Number of bits in an int or unsigned int for the target machine."
    },
    {
      "sha": "e399f5f5bc373ad95867d6e3c5a3e7f6bf9b6f21",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -552,10 +552,9 @@ union type_owner\n union field_location\n {\n   /* * Position of this field, counting in bits from start of\n-     containing structure.  For gdbarch_bits_big_endian=1\n-     targets, it is the bit offset to the MSB.  For\n-     gdbarch_bits_big_endian=0 targets, it is the bit offset to\n-     the LSB.  */\n+     containing structure.  For big-endian targets, it is the bit\n+     offset to the MSB.  For little-endian targets, it is the bit\n+     offset to the LSB.  */\n \n   LONGEST bitpos;\n "
    },
    {
      "sha": "29b80ddd79905e4d7689a92f75e9d6bbbe67c89a",
      "filename": "gdb/target-descriptions.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/target-descriptions.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/target-descriptions.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-descriptions.c?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -224,7 +224,7 @@ make_gdb_type (struct gdbarch *gdbarch, struct tdesc_type *ttype)\n \t\t the total size of the structure.  */\n \t      bitsize = f.end - f.start + 1;\n \t      total_size = e->size * TARGET_CHAR_BIT;\n-\t      if (gdbarch_bits_big_endian (m_gdbarch))\n+\t      if (gdbarch_byte_order (m_gdbarch) == BFD_ENDIAN_BIG)\n \t\tSET_FIELD_BITPOS (fld[0], total_size - f.start - bitsize);\n \t      else\n \t\tSET_FIELD_BITPOS (fld[0], f.start);"
    },
    {
      "sha": "887acc86751078ad3f5944b2b6119d414edccd29",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -1723,7 +1723,7 @@ value_bit_index (struct type *type, const gdb_byte *valaddr, int index)\n   word = extract_unsigned_integer (valaddr + (rel_index / TARGET_CHAR_BIT), 1,\n \t\t\t\t   type_byte_order (type));\n   rel_index %= TARGET_CHAR_BIT;\n-  if (gdbarch_bits_big_endian (gdbarch))\n+  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)\n     rel_index = TARGET_CHAR_BIT - 1 - rel_index;\n   return (word >> rel_index) & 1;\n }"
    },
    {
      "sha": "781808016cde43778c4446b1ae4f0ff02f17b20d",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -273,8 +273,8 @@ struct value\n   LONGEST bitsize = 0;\n \n   /* Only used for bitfields; position of start of field.  For\n-     gdbarch_bits_big_endian=0 targets, it is the position of the LSB.  For\n-     gdbarch_bits_big_endian=1 targets, it is the position of the MSB.  */\n+     little-endian targets, it is the position of the LSB.  For\n+     big-endian targets, it is the position of the MSB.  */\n   LONGEST bitpos = 0;\n \n   /* The number of references to this value.  When a value is created,\n@@ -3135,7 +3135,7 @@ unpack_bits_as_long (struct type *field_type, const gdb_byte *valaddr,\n \n   /* Extract bits.  See comment above.  */\n \n-  if (gdbarch_bits_big_endian (get_type_arch (field_type)))\n+  if (byte_order == BFD_ENDIAN_BIG)\n     lsbcount = (bytes_read * 8 - bitpos % 8 - bitsize);\n   else\n     lsbcount = (bitpos % 8);\n@@ -3311,7 +3311,7 @@ modify_field (struct type *type, gdb_byte *addr,\n   oword = extract_unsigned_integer (addr, bytesize, byte_order);\n \n   /* Shifting for bit field depends on endianness of the target machine.  */\n-  if (gdbarch_bits_big_endian (get_type_arch (type)))\n+  if (byte_order == BFD_ENDIAN_BIG)\n     bitpos = bytesize * 8 - bitpos - bitsize;\n \n   oword &= ~(mask << bitpos);"
    },
    {
      "sha": "08162474211d2e72e356eb1d14a224ca196776af",
      "filename": "gdb/value.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/value.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d5a22e77b56529eade787419ea80a7e9e7d2aa6f/gdb/value.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.h?ref=d5a22e77b56529eade787419ea80a7e9e7d2aa6f",
      "patch": "@@ -146,8 +146,8 @@ extern LONGEST value_bitsize (const struct value *);\n extern void set_value_bitsize (struct value *, LONGEST bit);\n \n /* Only used for bitfields; position of start of field.  For\n-   gdbarch_bits_big_endian=0 targets, it is the position of the LSB.  For\n-   gdbarch_bits_big_endian=1 targets, it is the position of the MSB.  */\n+   little-endian targets, it is the position of the LSB.  For\n+   big-endian targets, it is the position of the MSB.  */\n \n extern LONGEST value_bitpos (const struct value *);\n extern void set_value_bitpos (struct value *, LONGEST bit);"
    }
  ]
}