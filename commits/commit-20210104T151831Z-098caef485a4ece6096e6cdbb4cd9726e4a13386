{
  "sha": "098caef485a4ece6096e6cdbb4cd9726e4a13386",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDk4Y2FlZjQ4NWE0ZWNlNjA5NmU2Y2RiYjRjZDk3MjZlNGExMzM4Ng==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-12-22T20:45:21Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-01-04T15:18:31Z"
    },
    "message": "Refactor struct trad_frame_saved_regs\n\nThe following patch drops the overloading going on with the trad_frame_saved_reg\nstruct and defines a new struct with a KIND enum and a union of different\nfields.\n\nThe new struct looks like this:\n\nstruct trad_frame_saved_reg\n {\n  setters/getters\n\n  ...\n\nprivate:\n\n  trad_frame_saved_reg_kind m_kind;\n\n  union {\n    LONGEST value;\n    int realreg;\n    LONGEST addr;\n    const gdb_byte *value_bytes;\n  } m_reg;\n};\n\nAnd the enums look like this:\n\n/* Describes the kind of encoding a stored register has.  */\nenum class trad_frame_saved_reg_kind\n{\n  /* Register value is unknown.  */\n  UNKNOWN = 0,\n  /* Register value is a constant.  */\n  VALUE,\n  /* Register value is in another register.  */\n  REALREG,\n  /* Register value is at an address.  */\n  ADDR,\n  /* Register value is a sequence of bytes.  */\n  VALUE_BYTES\n};\n\nThe patch also adds setters/getters and updates all the users of the old\nstruct.\n\nIt is worth mentioning that due to the previous overloaded nature of the\nfields, some tdep files like to store negative offsets and indexes in the ADDR\nfield, so I kept the ADDR as LONGEST instead of CORE_ADDR. Those cases may\nbe better supported by a new enum entry.\n\nI have not addressed those cases in this patch to prevent unwanted breakage,\ngiven I have no way to test some of the targets. But it would be nice to\nclean those up eventually.\n\nThe change to frame-unwind.* is to constify the parameter being passed to the\nunwinding functions, given we now accept a \"const gdb_byte *\" for value bytes.\n\nTested on aarch64-linux/Ubuntu 20.04/18.04 and by building GDB with\n--enable-targets=all.\n\ngdb/ChangeLog:\n\n2021-01-04  Luis Machado  <luis.machado@linaro.org>\n\n\tUpdate all users of trad_frame_saved_reg to use the new member\n\tfunctions.\n\n\tRemote all struct keywords from declarations of trad_frame_saved_reg\n\ttypes, except on forward declarations.\n\n\t* aarch64-tdep.c: Update.\n\t* alpha-mdebug-tdep.c: Update.\n\t* alpha-tdep.c: Update.\n\t* arc-tdep.c: Update.\n\t* arm-tdep.c: Update.\n\t* avr-tdep.c: Update.\n\t* cris-tdep.c: Update.\n\t* csky-tdep.c: Update.\n\t* frv-tdep.c: Update.\n\t* hppa-linux-tdep.c: Update.\n\t* hppa-tdep.c: Update.\n\t* hppa-tdep.h: Update.\n\t* lm32-tdep.c: Update.\n\t* m32r-linux-tdep.c: Update.\n\t* m32r-tdep.c: Update.\n\t* m68hc11-tdep.c: Update.\n\t* mips-tdep.c: Update.\n\t* moxie-tdep.c: Update.\n\t* riscv-tdep.c: Update.\n\t* rs6000-tdep.c: Update.\n\t* s390-linux-tdep.c: Update.\n\t* s390-tdep.c: Update.\n\t* score-tdep.c: Update.\n\t* sparc-netbsd-tdep.c: Update.\n\t* sparc-sol2-tdep.c: Update.\n\t* sparc64-fbsd-tdep.c: Update.\n\t* sparc64-netbsd-tdep.c: Update.\n\t* sparc64-obsd-tdep.c: Update.\n\t* sparc64-sol2-tdep.c: Update.\n\t* tilegx-tdep.c: Update.\n\t* v850-tdep.c: Update.\n\t* vax-tdep.c: Update.\n\n\t* frame-unwind.c (frame_unwind_got_bytes): Make parameter const.\n\t* frame-unwind.h (frame_unwind_got_bytes): Likewise.\n\n\t* trad-frame.c: Update.\n\tRemove TF_REG_* enum.\n\t(trad_frame_alloc_saved_regs): Add a static assertion to check for\n\ta trivially-constructible struct.\n\t(trad_frame_reset_saved_regs): Adjust to use member function.\n\t(trad_frame_value_p): Likewise.\n\t(trad_frame_addr_p): Likewise.\n\t(trad_frame_realreg_p): Likewise.\n\t(trad_frame_value_bytes_p): Likewise.\n\t(trad_frame_set_value): Likewise.\n\t(trad_frame_set_realreg): Likewise.\n\t(trad_frame_set_addr): Likewise.\n\t(trad_frame_set_unknown): Likewise.\n\t(trad_frame_set_value_bytes): Likewise.\n\t(trad_frame_get_prev_register): Likewise.\n\t* trad-frame.h: Update.\n\t(trad_frame_saved_reg_kind): New enum.\n\t(struct trad_frame_saved_reg) <addr, realreg, data>: Remove.\n\t<m_kind, m_reg>: New member fields.\n\t<set_value, set_realreg, set_addr, set_unknown, set_value_bytes>\n\t<kind, value, realreg, addr, value_bytes, is_value, is_realreg>\n\t<is_addr, is_unknown, is_value_bytes>: New member functions.",
    "tree": {
      "sha": "bc5808e3f19fbcdf402c9c5e11a52dacff679412",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bc5808e3f19fbcdf402c9c5e11a52dacff679412"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/098caef485a4ece6096e6cdbb4cd9726e4a13386",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/098caef485a4ece6096e6cdbb4cd9726e4a13386",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/098caef485a4ece6096e6cdbb4cd9726e4a13386",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/098caef485a4ece6096e6cdbb4cd9726e4a13386/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dbb078f66ecfe2d50fd3e03463b5b206a8eed243",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dbb078f66ecfe2d50fd3e03463b5b206a8eed243",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dbb078f66ecfe2d50fd3e03463b5b206a8eed243"
    }
  ],
  "stats": {
    "total": 958,
    "additions": 555,
    "deletions": 403
  },
  "files": [
    {
      "sha": "f113bff3c8693d96a03efc0b92c5c551c62869c7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 67,
      "deletions": 0,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -1,3 +1,70 @@\n+2021-01-04  Luis Machado  <luis.machado@linaro.org>\n+\n+\tUpdate all users of trad_frame_saved_reg to use the new member\n+\tfunctions.\n+\n+\tRemote all struct keywords from declarations of trad_frame_saved_reg\n+\ttypes, except on forward declarations.\n+\n+\t* aarch64-tdep.c: Update.\n+\t* alpha-mdebug-tdep.c: Update.\n+\t* alpha-tdep.c: Update.\n+\t* arc-tdep.c: Update.\n+\t* arm-tdep.c: Update.\n+\t* avr-tdep.c: Update.\n+\t* cris-tdep.c: Update.\n+\t* csky-tdep.c: Update.\n+\t* frv-tdep.c: Update.\n+\t* hppa-linux-tdep.c: Update.\n+\t* hppa-tdep.c: Update.\n+\t* hppa-tdep.h: Update.\n+\t* lm32-tdep.c: Update.\n+\t* m32r-linux-tdep.c: Update.\n+\t* m32r-tdep.c: Update.\n+\t* m68hc11-tdep.c: Update.\n+\t* mips-tdep.c: Update.\n+\t* moxie-tdep.c: Update.\n+\t* riscv-tdep.c: Update.\n+\t* rs6000-tdep.c: Update.\n+\t* s390-linux-tdep.c: Update.\n+\t* s390-tdep.c: Update.\n+\t* score-tdep.c: Update.\n+\t* sparc-netbsd-tdep.c: Update.\n+\t* sparc-sol2-tdep.c: Update.\n+\t* sparc64-fbsd-tdep.c: Update.\n+\t* sparc64-netbsd-tdep.c: Update.\n+\t* sparc64-obsd-tdep.c: Update.\n+\t* sparc64-sol2-tdep.c: Update.\n+\t* tilegx-tdep.c: Update.\n+\t* v850-tdep.c: Update.\n+\t* vax-tdep.c: Update.\n+\n+\t* frame-unwind.c (frame_unwind_got_bytes): Make parameter const.\n+\t* frame-unwind.h (frame_unwind_got_bytes): Likewise.\n+\n+\t* trad-frame.c: Update.\n+\tRemove TF_REG_* enum.\n+\t(trad_frame_alloc_saved_regs): Add a static assertion to check for\n+\ta trivially-constructible struct.\n+\t(trad_frame_reset_saved_regs): Adjust to use member function.\n+\t(trad_frame_value_p): Likewise.\n+\t(trad_frame_addr_p): Likewise.\n+\t(trad_frame_realreg_p): Likewise.\n+\t(trad_frame_value_bytes_p): Likewise.\n+\t(trad_frame_set_value): Likewise.\n+\t(trad_frame_set_realreg): Likewise.\n+\t(trad_frame_set_addr): Likewise.\n+\t(trad_frame_set_unknown): Likewise.\n+\t(trad_frame_set_value_bytes): Likewise.\n+\t(trad_frame_get_prev_register): Likewise.\n+\t* trad-frame.h: Update.\n+\t(trad_frame_saved_reg_kind): New enum.\n+\t(struct trad_frame_saved_reg) <addr, realreg, data>: Remove.\n+\t<m_kind, m_reg>: New member fields.\n+\t<set_value, set_realreg, set_addr, set_unknown, set_value_bytes>\n+\t<kind, value, realreg, addr, value_bytes, is_value, is_realreg>\n+\t<is_addr, is_unknown, is_value_bytes>: New member functions.\n+\n 2021-01-02  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* target-float.c: Fix typos."
    },
    {
      "sha": "77e6ad700fcdcd5f709aecb537584184dc06d059",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 25,
      "deletions": 22,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -201,7 +201,7 @@ struct aarch64_prologue_cache\n   int framereg;\n \n   /* Saved register offsets.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n static void\n@@ -564,7 +564,7 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n       CORE_ADDR offset;\n \n       if (stack.find_reg (gdbarch, i, &offset))\n-\tcache->saved_regs[i].addr = offset;\n+\tcache->saved_regs[i].set_addr (offset);\n     }\n \n   for (i = 0; i < AARCH64_D_REGISTER_COUNT; i++)\n@@ -574,7 +574,7 @@ aarch64_analyze_prologue (struct gdbarch *gdbarch,\n \n       if (stack.find_reg (gdbarch, i + AARCH64_X_REGISTER_COUNT,\n \t\t\t  &offset))\n-\tcache->saved_regs[i + regnum + AARCH64_D0_REGNUM].addr = offset;\n+\tcache->saved_regs[i + regnum + AARCH64_D0_REGNUM].set_addr (offset);\n     }\n \n   return start;\n@@ -654,19 +654,19 @@ aarch64_analyze_prologue_test (void)\n     for (int i = 0; i < AARCH64_X_REGISTER_COUNT; i++)\n       {\n \tif (i == AARCH64_FP_REGNUM)\n-\t  SELF_CHECK (cache.saved_regs[i].addr == -272);\n+\t  SELF_CHECK (cache.saved_regs[i].addr () == -272);\n \telse if (i == AARCH64_LR_REGNUM)\n-\t  SELF_CHECK (cache.saved_regs[i].addr == -264);\n+\t  SELF_CHECK (cache.saved_regs[i].addr () == -264);\n \telse\n-\t  SELF_CHECK (cache.saved_regs[i].addr == -1);\n+\t  SELF_CHECK (cache.saved_regs[i].is_realreg ());\n       }\n \n     for (int i = 0; i < AARCH64_D_REGISTER_COUNT; i++)\n       {\n \tint regnum = gdbarch_num_regs (gdbarch);\n \n-\tSELF_CHECK (cache.saved_regs[i + regnum + AARCH64_D0_REGNUM].addr\n-\t\t    == -1);\n+\tSELF_CHECK (cache.saved_regs[i + regnum\n+\t\t\t\t     + AARCH64_D0_REGNUM].is_realreg ());\n       }\n   }\n \n@@ -694,23 +694,24 @@ aarch64_analyze_prologue_test (void)\n     for (int i = 0; i < AARCH64_X_REGISTER_COUNT; i++)\n       {\n \tif (i == 1)\n-\t  SELF_CHECK (cache.saved_regs[i].addr == -16);\n+\t  SELF_CHECK (cache.saved_regs[i].addr () == -16);\n \telse if (i == 19)\n-\t  SELF_CHECK (cache.saved_regs[i].addr == -48);\n+\t  SELF_CHECK (cache.saved_regs[i].addr () == -48);\n \telse\n-\t  SELF_CHECK (cache.saved_regs[i].addr == -1);\n+\t  SELF_CHECK (cache.saved_regs[i].is_realreg ());\n       }\n \n     for (int i = 0; i < AARCH64_D_REGISTER_COUNT; i++)\n       {\n \tint regnum = gdbarch_num_regs (gdbarch);\n \n \tif (i == 0)\n-\t  SELF_CHECK (cache.saved_regs[i + regnum + AARCH64_D0_REGNUM].addr\n+\t  SELF_CHECK (cache.saved_regs[i + regnum\n+\t\t\t\t       + AARCH64_D0_REGNUM].addr ()\n \t\t      == -24);\n \telse\n-\t  SELF_CHECK (cache.saved_regs[i + regnum + AARCH64_D0_REGNUM].addr\n-\t\t      == -1);\n+\t  SELF_CHECK (cache.saved_regs[i + regnum\n+\t\t\t\t       + AARCH64_D0_REGNUM].is_realreg ());\n       }\n   }\n \n@@ -848,20 +849,21 @@ aarch64_analyze_prologue_test (void)\n       for (int i = 0; i < AARCH64_X_REGISTER_COUNT; i++)\n \t{\n \t  if (i == 19)\n-\t    SELF_CHECK (cache.saved_regs[i].addr == -20);\n+\t    SELF_CHECK (cache.saved_regs[i].addr () == -20);\n \t  else if (i == AARCH64_FP_REGNUM)\n-\t    SELF_CHECK (cache.saved_regs[i].addr == -48);\n+\t    SELF_CHECK (cache.saved_regs[i].addr () == -48);\n \t  else if (i == AARCH64_LR_REGNUM)\n-\t    SELF_CHECK (cache.saved_regs[i].addr == -40);\n+\t    SELF_CHECK (cache.saved_regs[i].addr () == -40);\n \t  else\n-\t    SELF_CHECK (cache.saved_regs[i].addr == -1);\n+\t    SELF_CHECK (cache.saved_regs[i].is_realreg ());\n \t}\n \n       if (tdep->has_pauth ())\n \t{\n \t  SELF_CHECK (trad_frame_value_p (cache.saved_regs,\n \t\t\t\t\t  tdep->pauth_ra_state_regnum));\n-\t  SELF_CHECK (cache.saved_regs[tdep->pauth_ra_state_regnum].addr == 1);\n+\t  SELF_CHECK (cache.saved_regs[tdep->pauth_ra_state_regnum].addr ()\n+\t\t      == 1);\n \t}\n     }\n }\n@@ -950,8 +952,8 @@ aarch64_scan_prologue (struct frame_info *this_frame,\n \n       cache->framereg = AARCH64_FP_REGNUM;\n       cache->framesize = 16;\n-      cache->saved_regs[29].addr = 0;\n-      cache->saved_regs[30].addr = 8;\n+      cache->saved_regs[29].set_addr (0);\n+      cache->saved_regs[30].set_addr (8);\n     }\n }\n \n@@ -981,7 +983,8 @@ aarch64_make_prologue_cache_1 (struct frame_info *this_frame,\n      determined by aarch64_analyze_prologue.  */\n   for (reg = 0; reg < gdbarch_num_regs (get_frame_arch (this_frame)); reg++)\n     if (trad_frame_addr_p (cache->saved_regs, reg))\n-      cache->saved_regs[reg].addr += cache->prev_sp;\n+      cache->saved_regs[reg].set_addr (cache->saved_regs[reg].addr ()\n+\t\t\t\t       + cache->prev_sp);\n \n   cache->func = get_frame_func (this_frame);\n "
    },
    {
      "sha": "8024e4a68adf44a425aff49d2cf63b92d31e1ce8",
      "filename": "gdb/alpha-mdebug-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/alpha-mdebug-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/alpha-mdebug-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-mdebug-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -180,7 +180,7 @@ struct alpha_mdebug_unwind_cache\n {\n   struct mdebug_extra_func_info *proc_desc;\n   CORE_ADDR vfp;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Extract all of the information about the frame from PROC_DESC\n@@ -231,14 +231,14 @@ alpha_mdebug_frame_unwind_cache (struct frame_info *this_frame,\n       /* Clear bit for RA so we don't save it again later.  */\n       mask &= ~(1 << returnreg);\n \n-      info->saved_regs[returnreg].addr = reg_position;\n+      info->saved_regs[returnreg].set_addr (reg_position);\n       reg_position += 8;\n     }\n \n   for (ireg = 0; ireg <= 31; ++ireg)\n     if (mask & (1 << ireg))\n       {\n-\tinfo->saved_regs[ireg].addr = reg_position;\n+\tinfo->saved_regs[ireg].set_addr (reg_position);\n \treg_position += 8;\n       }\n \n@@ -248,7 +248,7 @@ alpha_mdebug_frame_unwind_cache (struct frame_info *this_frame,\n   for (ireg = 0; ireg <= 31; ++ireg)\n     if (mask & (1 << ireg))\n       {\n-\tinfo->saved_regs[ALPHA_FP0_REGNUM + ireg].addr = reg_position;\n+\tinfo->saved_regs[ALPHA_FP0_REGNUM + ireg].set_addr (reg_position);\n \treg_position += 8;\n       }\n "
    },
    {
      "sha": "d80109f681d0d9e602b5d0ba57ca106c11fdfce7",
      "filename": "gdb/alpha-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/alpha-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/alpha-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -1118,7 +1118,7 @@ struct alpha_heuristic_unwind_cache\n { \n   CORE_ADDR vfp;\n   CORE_ADDR start_pc;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n   int return_reg;\n };\n \n@@ -1305,7 +1305,7 @@ alpha_heuristic_frame_unwind_cache (struct frame_info *this_frame,\n \t\t pointer or not.  */\n \t      /* Hack: temporarily add one, so that the offset is non-zero\n \t\t and we can tell which registers have save offsets below.  */\n-\t      info->saved_regs[reg].addr = (word & 0xffff) + 1;\n+\t      info->saved_regs[reg].set_addr ((word & 0xffff) + 1);\n \n \t      /* Starting with OSF/1-3.2C, the system libraries are shipped\n \t\t without local symbols, but they still contain procedure\n@@ -1386,7 +1386,8 @@ alpha_heuristic_frame_unwind_cache (struct frame_info *this_frame,\n      one to the offsets to make all detected offsets non-zero.  */\n   for (reg = 0; reg < ALPHA_NUM_REGS; ++reg)\n     if (trad_frame_addr_p(info->saved_regs, reg))\n-      info->saved_regs[reg].addr += val - 1;\n+      info->saved_regs[reg].set_addr (info->saved_regs[reg].addr ()\n+\t\t\t\t      + val - 1);\n \n   /* The stack pointer of the previous frame is computed by popping\n      the current stack frame.  */"
    },
    {
      "sha": "9b8457112111c9185bf18b3a86a868621b4a44fe",
      "filename": "gdb/arc-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/arc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/arc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -82,7 +82,7 @@ struct arc_frame_cache\n   /* Store addresses for registers saved in prologue.  During prologue analysis\n      GDB stores offsets relatively to \"old SP\", then after old SP is evaluated,\n      offsets are replaced with absolute addresses.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Global debug flag.  */\n@@ -1457,7 +1457,7 @@ arc_analyze_prologue (struct gdbarch *gdbarch, const CORE_ADDR entrypoint,\n \t{\n \t  CORE_ADDR offset;\n \t  if (stack.find_reg (gdbarch, i, &offset))\n-\t    cache->saved_regs[i].addr = offset;\n+\t    cache->saved_regs[i].set_addr (offset);\n \t}\n     }\n \n@@ -1677,7 +1677,7 @@ arc_print_frame_cache (struct gdbarch *gdbarch, const char *message,\n \tdebug_printf (\"arc: saved register %s at %s %s\\n\",\n \t\t      gdbarch_register_name (gdbarch, i),\n \t\t      (addresses_known) ? \"address\" : \"offset\",\n-\t\t      paddress (gdbarch, cache->saved_regs[i].addr));\n+\t\t      paddress (gdbarch, cache->saved_regs[i].addr ()));\n     }\n }\n \n@@ -1739,7 +1739,8 @@ arc_make_frame_cache (struct frame_info *this_frame)\n   for (int i = 0; i <= ARC_LAST_CORE_REGNUM; i++)\n     {\n       if (trad_frame_addr_p (cache->saved_regs, i))\n-\tcache->saved_regs[i].addr += cache->prev_sp;\n+\tcache->saved_regs[i].set_addr (cache->saved_regs[i].addr ()\n+\t\t\t\t       + cache->prev_sp);\n     }\n \n   if (arc_debug)\n@@ -1877,7 +1878,7 @@ arc_make_sigtramp_frame_cache (struct frame_info *this_frame)\n   for (int i = 0; i < tdep->sc_num_regs; i++)\n     {\n       if (tdep->sc_reg_offset[i] != ARC_OFFSET_NO_REGISTER)\n-\tcache->saved_regs[i].addr = addr + tdep->sc_reg_offset[i];\n+\tcache->saved_regs[i].set_addr (addr + tdep->sc_reg_offset[i]);\n     }\n \n   return cache;"
    },
    {
      "sha": "9e4cf07aff874d33171193f55911a76936ff0aeb",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 32,
      "deletions": 30,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -282,7 +282,7 @@ struct arm_prologue_cache\n   int framereg;\n \n   /* Saved register offsets.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n namespace {\n@@ -1153,7 +1153,7 @@ thumb_analyze_prologue (struct gdbarch *gdbarch,\n \n   for (i = 0; i < 16; i++)\n     if (stack.find_reg (gdbarch, i, &offset))\n-      cache->saved_regs[i].addr = offset;\n+      cache->saved_regs[i].set_addr (offset);\n \n   return unrecognized_pc;\n }\n@@ -1779,7 +1779,7 @@ arm_analyze_prologue (struct gdbarch *gdbarch,\n \n       for (regno = 0; regno < ARM_FPS_REGNUM; regno++)\n \tif (stack.find_reg (gdbarch, regno, &offset))\n-\t  cache->saved_regs[regno].addr = offset;\n+\t  cache->saved_regs[regno].set_addr (offset);\n     }\n \n   if (arm_debug)\n@@ -1907,7 +1907,8 @@ arm_make_prologue_cache (struct frame_info *this_frame)\n      determined by arm_scan_prologue.  */\n   for (reg = 0; reg < gdbarch_num_regs (get_frame_arch (this_frame)); reg++)\n     if (trad_frame_addr_p (cache->saved_regs, reg))\n-      cache->saved_regs[reg].addr += cache->prev_sp;\n+      cache->saved_regs[reg].set_addr (cache->saved_regs[reg].addr ()\n+\t\t\t\t       + cache->prev_sp);\n \n   return cache;\n }\n@@ -2367,12 +2368,12 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t{\n \t  if (trad_frame_realreg_p (cache->saved_regs, ARM_SP_REGNUM))\n \t    {\n-\t      int reg = cache->saved_regs[ARM_SP_REGNUM].realreg;\n+\t      int reg = cache->saved_regs[ARM_SP_REGNUM].realreg ();\n \t      vsp = get_frame_register_unsigned (this_frame, reg);\n \t    }\n \t  else\n \t    {\n-\t      CORE_ADDR addr = cache->saved_regs[ARM_SP_REGNUM].addr;\n+\t      CORE_ADDR addr = cache->saved_regs[ARM_SP_REGNUM].addr ();\n \t      vsp = get_frame_memory_unsigned (this_frame, addr, 4);\n \t    }\n \n@@ -2407,7 +2408,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  for (i = 0; i < 12; i++)\n \t    if (mask & (1 << i))\n \t      {\n-\t\tcache->saved_regs[4 + i].addr = vsp;\n+\t\tcache->saved_regs[4 + i].set_addr (vsp);\n \t\tvsp += 4;\n \t      }\n \n@@ -2436,14 +2437,14 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  /* Pop r4..r[4+count].  */\n \t  for (i = 0; i <= count; i++)\n \t    {\n-\t      cache->saved_regs[4 + i].addr = vsp;\n+\t      cache->saved_regs[4 + i].set_addr (vsp);\n \t      vsp += 4;\n \t    }\n \n \t  /* If indicated by flag, pop LR as well.  */\n \t  if (pop_lr)\n \t    {\n-\t      cache->saved_regs[ARM_LR_REGNUM].addr = vsp;\n+\t      cache->saved_regs[ARM_LR_REGNUM].set_addr (vsp);\n \t      vsp += 4;\n \t    }\n \t}\n@@ -2471,7 +2472,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  for (i = 0; i < 4; i++)\n \t    if (mask & (1 << i))\n \t      {\n-\t\tcache->saved_regs[i].addr = vsp;\n+\t\tcache->saved_regs[i].set_addr (vsp);\n \t\tvsp += 4;\n \t      }\n \t}\n@@ -2502,7 +2503,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  /* Pop VFP double-precision registers D[start]..D[start+count].  */\n \t  for (i = 0; i <= count; i++)\n \t    {\n-\t      cache->saved_regs[ARM_D0_REGNUM + start + i].addr = vsp;\n+\t      cache->saved_regs[ARM_D0_REGNUM + start + i].set_addr (vsp);\n \t      vsp += 8;\n \t    }\n \n@@ -2517,7 +2518,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  /* Pop VFP double-precision registers D[8]..D[8+count].  */\n \t  for (i = 0; i <= count; i++)\n \t    {\n-\t      cache->saved_regs[ARM_D0_REGNUM + 8 + i].addr = vsp;\n+\t      cache->saved_regs[ARM_D0_REGNUM + 8 + i].set_addr (vsp);\n \t      vsp += 8;\n \t    }\n \n@@ -2537,7 +2538,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  /* Pop iwmmx registers WR[start]..WR[start+count].  */\n \t  for (i = 0; i <= count; i++)\n \t    {\n-\t      cache->saved_regs[ARM_WR0_REGNUM + start + i].addr = vsp;\n+\t      cache->saved_regs[ARM_WR0_REGNUM + start + i].set_addr (vsp);\n \t      vsp += 8;\n \t    }\n \t}\n@@ -2554,7 +2555,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  for (i = 0; i < 4; i++)\n \t    if (mask & (1 << i))\n \t      {\n-\t\tcache->saved_regs[ARM_WCGR0_REGNUM + i].addr = vsp;\n+\t\tcache->saved_regs[ARM_WCGR0_REGNUM + i].set_addr (vsp);\n \t\tvsp += 4;\n \t      }\n \t}\n@@ -2566,7 +2567,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  /* Pop iwmmx registers WR[10]..WR[10+count].  */\n \t  for (i = 0; i <= count; i++)\n \t    {\n-\t      cache->saved_regs[ARM_WR0_REGNUM + 10 + i].addr = vsp;\n+\t      cache->saved_regs[ARM_WR0_REGNUM + 10 + i].set_addr (vsp);\n \t      vsp += 8;\n \t    }\n \t}\n@@ -2584,7 +2585,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t     D[16+start]..D[16+start+count].  */\n \t  for (i = 0; i <= count; i++)\n \t    {\n-\t      cache->saved_regs[ARM_D0_REGNUM + 16 + start + i].addr = vsp;\n+\t      cache->saved_regs[ARM_D0_REGNUM + 16 + start + i].set_addr (vsp);\n \t      vsp += 8;\n \t    }\n \t}\n@@ -2597,7 +2598,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  /* Pop VFP double-precision registers D[start]..D[start+count].  */\n \t  for (i = 0; i <= count; i++)\n \t    {\n-\t      cache->saved_regs[ARM_D0_REGNUM + start + i].addr = vsp;\n+\t      cache->saved_regs[ARM_D0_REGNUM + start + i].set_addr (vsp);\n \t      vsp += 8;\n \t    }\n \t}\n@@ -2609,7 +2610,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n \t  /* Pop VFP double-precision registers D[8]..D[8+count].  */\n \t  for (i = 0; i <= count; i++)\n \t    {\n-\t      cache->saved_regs[ARM_D0_REGNUM + 8 + i].addr = vsp;\n+\t      cache->saved_regs[ARM_D0_REGNUM + 8 + i].set_addr (vsp);\n \t      vsp += 8;\n \t    }\n \t}\n@@ -2623,7 +2624,7 @@ arm_exidx_fill_cache (struct frame_info *this_frame, gdb_byte *entry)\n   /* If we restore SP from a register, assume this was the frame register.\n      Otherwise just fall back to SP as frame register.  */\n   if (trad_frame_realreg_p (cache->saved_regs, ARM_SP_REGNUM))\n-    cache->framereg = cache->saved_regs[ARM_SP_REGNUM].realreg;\n+    cache->framereg = cache->saved_regs[ARM_SP_REGNUM].realreg ();\n   else\n     cache->framereg = ARM_SP_REGNUM;\n \n@@ -2760,7 +2761,8 @@ arm_make_epilogue_frame_cache (struct frame_info *this_frame)\n      determined by arm_scan_prologue.  */\n   for (reg = 0; reg < gdbarch_num_regs (get_frame_arch (this_frame)); reg++)\n     if (trad_frame_addr_p (cache->saved_regs, reg))\n-      cache->saved_regs[reg].addr += cache->prev_sp;\n+      cache->saved_regs[reg].set_addr (cache->saved_regs[reg].addr ()\n+\t\t\t\t       + cache->prev_sp);\n \n   return cache;\n }\n@@ -3037,14 +3039,14 @@ arm_m_exception_cache (struct frame_info *this_frame)\n      ReturnAddress, LR (R14), R12, R3, R2, R1, R0.  See details in\n      \"B1.5.6 Exception entry behavior\" in\n      \"ARMv7-M Architecture Reference Manual\".  */\n-  cache->saved_regs[0].addr = unwound_sp;\n-  cache->saved_regs[1].addr = unwound_sp + 4;\n-  cache->saved_regs[2].addr = unwound_sp + 8;\n-  cache->saved_regs[3].addr = unwound_sp + 12;\n-  cache->saved_regs[ARM_IP_REGNUM].addr = unwound_sp + 16;\n-  cache->saved_regs[ARM_LR_REGNUM].addr = unwound_sp + 20;\n-  cache->saved_regs[ARM_PC_REGNUM].addr = unwound_sp + 24;\n-  cache->saved_regs[ARM_PS_REGNUM].addr = unwound_sp + 28;\n+  cache->saved_regs[0].set_addr (unwound_sp);\n+  cache->saved_regs[1].set_addr (unwound_sp + 4);\n+  cache->saved_regs[2].set_addr (unwound_sp + 8);\n+  cache->saved_regs[3].set_addr (unwound_sp + 12);\n+  cache->saved_regs[ARM_IP_REGNUM].set_addr (unwound_sp + 16);\n+  cache->saved_regs[ARM_LR_REGNUM].set_addr (unwound_sp + 20);\n+  cache->saved_regs[ARM_PC_REGNUM].set_addr (unwound_sp + 24);\n+  cache->saved_regs[ARM_PS_REGNUM].set_addr (unwound_sp + 28);\n \n   /* Check EXC_RETURN bit FTYPE if extended stack frame (FPU regs stored)\n      type used.  */\n@@ -3066,10 +3068,10 @@ arm_m_exception_cache (struct frame_info *this_frame)\n       fpu_regs_stack_offset = unwound_sp + 0x20;\n       for (i = 0; i < 16; i++)\n \t{\n-\t  cache->saved_regs[ARM_D0_REGNUM + i].addr = fpu_regs_stack_offset;\n+\t  cache->saved_regs[ARM_D0_REGNUM + i].set_addr (fpu_regs_stack_offset);\n \t  fpu_regs_stack_offset += 4;\n \t}\n-      cache->saved_regs[ARM_FPSCR_REGNUM].addr = unwound_sp + 0x60;\n+      cache->saved_regs[ARM_FPSCR_REGNUM].set_addr (unwound_sp + 0x60);\n \n       /* Offset 0x64 is reserved.  */\n       cache->prev_sp = unwound_sp + 0x68;"
    },
    {
      "sha": "e9493f1ec6fb6e38b3f3a957c146f6cd0d74a2f6",
      "filename": "gdb/avr-tdep.c",
      "status": "modified",
      "additions": 17,
      "deletions": 16,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/avr-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/avr-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/avr-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -185,7 +185,7 @@ struct avr_unwind_cache\n   int size;\n   int prologue_type;\n   /* Table indicating the location of each and every register.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n struct gdbarch_tdep\n@@ -672,14 +672,14 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n \t{\n \t  int from;\n \n-\t  info->saved_regs[AVR_FP_REGNUM + 1].addr = num_pushes;\n+\t  info->saved_regs[AVR_FP_REGNUM + 1].set_addr (num_pushes);\n \t  if (num_pushes >= 2)\n-\t    info->saved_regs[AVR_FP_REGNUM].addr = num_pushes - 1;\n+\t    info->saved_regs[AVR_FP_REGNUM].set_addr (num_pushes - 1);\n \n \t  i = 0;\n \t  for (from = AVR_LAST_PUSHED_REGNUM + 1 - (num_pushes - 2);\n \t       from <= AVR_LAST_PUSHED_REGNUM; ++from)\n-\t    info->saved_regs [from].addr = ++i;\n+\t    info->saved_regs [from].set_addr (++i);\n \t}\n       info->size = loc_size + num_pushes;\n       info->prologue_type = AVR_PROLOGUE_CALL;\n@@ -707,19 +707,19 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n \t{\n \t  info->prologue_type = AVR_PROLOGUE_INTR;\n \t  vpc += sizeof (img);\n-\t  info->saved_regs[AVR_SREG_REGNUM].addr = 3;\n-\t  info->saved_regs[0].addr = 2;\n-\t  info->saved_regs[1].addr = 1;\n+\t  info->saved_regs[AVR_SREG_REGNUM].set_addr (3);\n+\t  info->saved_regs[0].set_addr (2);\n+\t  info->saved_regs[1].set_addr (1);\n \t  info->size += 3;\n \t}\n       else if (len >= sizeof (img) - 2\n \t       && memcmp (img + 2, prologue, sizeof (img) - 2) == 0)\n \t{\n \t  info->prologue_type = AVR_PROLOGUE_SIG;\n \t  vpc += sizeof (img) - 2;\n-\t  info->saved_regs[AVR_SREG_REGNUM].addr = 3;\n-\t  info->saved_regs[0].addr = 2;\n-\t  info->saved_regs[1].addr = 1;\n+\t  info->saved_regs[AVR_SREG_REGNUM].set_addr (3);\n+\t  info->saved_regs[0].set_addr (2);\n+\t  info->saved_regs[1].set_addr (1);\n \t  info->size += 2;\n \t}\n     }\n@@ -735,7 +735,7 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n \t  /* Bits 4-9 contain a mask for registers R0-R32.  */\n \t  int regno = (insn & 0x1f0) >> 4;\n \t  info->size++;\n-\t  info->saved_regs[regno].addr = info->size;\n+\t  info->saved_regs[regno].set_addr (info->size);\n \t  scan_stage = 1;\n \t}\n       else\n@@ -892,7 +892,7 @@ avr_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n   {\n     CORE_ADDR prologue_end = pc;\n     struct avr_unwind_cache info = {0};\n-    struct trad_frame_saved_reg saved_regs[AVR_NUM_REGS];\n+    trad_frame_saved_reg saved_regs[AVR_NUM_REGS];\n \n     info.saved_regs = saved_regs;\n     \n@@ -1037,14 +1037,15 @@ avr_frame_unwind_cache (struct frame_info *this_frame,\n   /* Adjust all the saved registers so that they contain addresses and not\n      offsets.  */\n   for (i = 0; i < gdbarch_num_regs (gdbarch) - 1; i++)\n-    if (info->saved_regs[i].addr > 0)\n-      info->saved_regs[i].addr = info->prev_sp - info->saved_regs[i].addr;\n+    if (info->saved_regs[i].addr () > 0)\n+      info->saved_regs[i].set_addr (info->prev_sp\n+\t\t\t\t    - info->saved_regs[i].addr ());\n \n   /* Except for the main and startup code, the return PC is always saved on\n      the stack and is at the base of the frame.  */\n \n   if (info->prologue_type != AVR_PROLOGUE_MAIN)\n-    info->saved_regs[AVR_PC_REGNUM].addr = info->prev_sp;\n+    info->saved_regs[AVR_PC_REGNUM].set_addr (info->prev_sp);\n \n   /* The previous frame's SP needed to be computed.  Save the computed\n      value.  */\n@@ -1132,7 +1133,7 @@ avr_frame_prev_register (struct frame_info *this_frame,\n \t  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n \t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-\t  read_memory (info->saved_regs[AVR_PC_REGNUM].addr,\n+\t  read_memory (info->saved_regs[AVR_PC_REGNUM].addr (),\n \t\t       buf, tdep->call_length);\n \n \t  /* Extract the PC read from memory as a big-endian.  */"
    },
    {
      "sha": "63ce803b0194f069e4447237216ffe5c882fa932",
      "filename": "gdb/cris-tdep.c",
      "status": "modified",
      "additions": 23,
      "deletions": 24,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/cris-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/cris-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -305,7 +305,7 @@ struct cris_unwind_cache\n   int leaf_function;\n \n   /* Table indicating the location of each and every register.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n static struct cris_unwind_cache *\n@@ -354,36 +354,36 @@ cris_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n       /* R0 to R13 are stored in reverse order at offset (2 * 4) in \n \t struct pt_regs.  */\n       for (i = 0; i <= 13; i++)\n-\tinfo->saved_regs[i].addr = addr + ((15 - i) * 4);\n+\tinfo->saved_regs[i].set_addr (addr + ((15 - i) * 4));\n \n-      info->saved_regs[MOF_REGNUM].addr = addr + (16 * 4);\n-      info->saved_regs[DCCR_REGNUM].addr = addr + (17 * 4);\n-      info->saved_regs[SRP_REGNUM].addr = addr + (18 * 4);\n+      info->saved_regs[MOF_REGNUM].set_addr (addr + (16 * 4));\n+      info->saved_regs[DCCR_REGNUM].set_addr (addr + (17 * 4));\n+      info->saved_regs[SRP_REGNUM].set_addr (addr + (18 * 4));\n       /* Note: IRP is off by 2 at this point.  There's no point in correcting\n \t it though since that will mean that the backtrace will show a PC \n \t different from what is shown when stopped.  */\n-      info->saved_regs[IRP_REGNUM].addr = addr + (19 * 4);\n+      info->saved_regs[IRP_REGNUM].set_addr (addr + (19 * 4));\n       info->saved_regs[gdbarch_pc_regnum (gdbarch)]\n \t= info->saved_regs[IRP_REGNUM];\n-      info->saved_regs[gdbarch_sp_regnum (gdbarch)].addr = addr + (24 * 4);\n+      info->saved_regs[gdbarch_sp_regnum (gdbarch)].set_addr (addr + (24 * 4));\n     }\n   else\n     {\n       /* CRISv32.  */\n       /* R0 to R13 are stored in order at offset (1 * 4) in \n \t struct pt_regs.  */\n       for (i = 0; i <= 13; i++)\n-\tinfo->saved_regs[i].addr = addr + ((i + 1) * 4);\n-\n-      info->saved_regs[ACR_REGNUM].addr = addr + (15 * 4);\n-      info->saved_regs[SRS_REGNUM].addr = addr + (16 * 4);\n-      info->saved_regs[MOF_REGNUM].addr = addr + (17 * 4);\n-      info->saved_regs[SPC_REGNUM].addr = addr + (18 * 4);\n-      info->saved_regs[CCS_REGNUM].addr = addr + (19 * 4);\n-      info->saved_regs[SRP_REGNUM].addr = addr + (20 * 4);\n-      info->saved_regs[ERP_REGNUM].addr = addr + (21 * 4);\n-      info->saved_regs[EXS_REGNUM].addr = addr + (22 * 4);\n-      info->saved_regs[EDA_REGNUM].addr = addr + (23 * 4);\n+\tinfo->saved_regs[i].set_addr (addr + ((i + 1) * 4));\n+\n+      info->saved_regs[ACR_REGNUM].set_addr (addr + (15 * 4));\n+      info->saved_regs[SRS_REGNUM].set_addr (addr + (16 * 4));\n+      info->saved_regs[MOF_REGNUM].set_addr (addr + (17 * 4));\n+      info->saved_regs[SPC_REGNUM].set_addr (addr + (18 * 4));\n+      info->saved_regs[CCS_REGNUM].set_addr (addr + (19 * 4));\n+      info->saved_regs[SRP_REGNUM].set_addr (addr + (20 * 4));\n+      info->saved_regs[ERP_REGNUM].set_addr (addr + (21 * 4));\n+      info->saved_regs[EXS_REGNUM].set_addr (addr + (22 * 4));\n+      info->saved_regs[EDA_REGNUM].set_addr (addr + (23 * 4));\n \n       /* FIXME: If ERP is in a delay slot at this point then the PC will\n \t be wrong at this point.  This problem manifests itself in the\n@@ -395,8 +395,7 @@ cris_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n       info->saved_regs[gdbarch_pc_regnum (gdbarch)]\n \t= info->saved_regs[ERP_REGNUM];\n \n-      info->saved_regs[gdbarch_sp_regnum (gdbarch)].addr\n-\t= addr + (25 * 4);\n+      info->saved_regs[gdbarch_sp_regnum (gdbarch)].set_addr (addr + (25 * 4));\n     }\n   \n   return info;\n@@ -1229,7 +1228,7 @@ cris_scan_prologue (CORE_ADDR pc, struct frame_info *this_frame,\n \t the next frame.  */\n       this_base = get_frame_register_unsigned (this_frame, CRIS_FP_REGNUM);\n       info->base = this_base;\n-      info->saved_regs[CRIS_FP_REGNUM].addr = info->base;\n+      info->saved_regs[CRIS_FP_REGNUM].set_addr (info->base);\n   \n       /* The FP points at the last saved register.  Adjust the FP back\n \t to before the first saved register giving the SP.  */\n@@ -1254,7 +1253,7 @@ cris_scan_prologue (CORE_ADDR pc, struct frame_info *this_frame,\n \n   for (regno = regsave; regno >= 0; regno--)\n     {\n-      info->saved_regs[regno].addr = info->base + info->r8_offset - val;\n+      info->saved_regs[regno].set_addr (info->base + info->r8_offset - val);\n       val -= 4;\n     }\n \n@@ -1269,12 +1268,12 @@ cris_scan_prologue (CORE_ADDR pc, struct frame_info *this_frame,\n       if (info->r8_offset == 0)\n \t{\n \t  /* R8 not pushed yet.  */\n-\t  info->saved_regs[SRP_REGNUM].addr = info->base;\n+\t  info->saved_regs[SRP_REGNUM].set_addr (info->base);\n \t}\n       else\n \t{\n \t  /* R8 pushed, but SP may or may not be moved to R8 yet.  */\n-\t  info->saved_regs[SRP_REGNUM].addr = info->base + 4;\n+\t  info->saved_regs[SRP_REGNUM].set_addr (info->base + 4);\n \t}\n     }\n "
    },
    {
      "sha": "55ebca6b04b18a33741bebdcf51d8ab782e54ad3",
      "filename": "gdb/csky-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/csky-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/csky-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/csky-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -502,7 +502,7 @@ struct csky_unwind_cache\n   int framereg;\n \n   /* Saved register offsets.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Do prologue analysis, returning the PC of the first instruction\n@@ -1459,17 +1459,17 @@ csky_analyze_prologue (struct gdbarch *gdbarch,\n \t{\n \t  if (register_offsets[rn] >= 0)\n \t    {\n-\t      this_cache->saved_regs[rn].addr\n-\t\t= this_cache->prev_sp - register_offsets[rn];\n+\t      this_cache->saved_regs[rn].set_addr (this_cache->prev_sp\n+\t\t\t\t\t\t   - register_offsets[rn]);\n \t      if (csky_debug)\n \t\t{\n \t\t  CORE_ADDR rn_value = read_memory_unsigned_integer (\n-\t\t    this_cache->saved_regs[rn].addr, 4, byte_order);\n+\t\t    this_cache->saved_regs[rn].addr (), 4, byte_order);\n \t\t  fprintf_unfiltered (gdb_stdlog, \"Saved register %s \"\n \t\t\t\t      \"stored at 0x%08lx, value=0x%08lx\\n\",\n \t\t\t\t      csky_register_names[rn],\n \t\t\t\t      (unsigned long)\n-\t\t\t\t\tthis_cache->saved_regs[rn].addr,\n+\t\t\t\t\tthis_cache->saved_regs[rn].addr (),\n \t\t\t\t      (unsigned long) rn_value);\n \t\t}\n \t    }"
    },
    {
      "sha": "b19e95d350908545dd3ca7b6129ef07903d2352f",
      "filename": "gdb/frame-unwind.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/frame-unwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/frame-unwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame-unwind.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -296,7 +296,7 @@ frame_unwind_got_constant (struct frame_info *frame, int regnum,\n }\n \n struct value *\n-frame_unwind_got_bytes (struct frame_info *frame, int regnum, gdb_byte *buf)\n+frame_unwind_got_bytes (struct frame_info *frame, int regnum, const gdb_byte *buf)\n {\n   struct gdbarch *gdbarch = frame_unwind_arch (frame);\n   struct value *reg_val;"
    },
    {
      "sha": "da0b4bcbe30fbcb26efa36c258788894441d5464",
      "filename": "gdb/frame-unwind.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/frame-unwind.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/frame-unwind.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame-unwind.h?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -226,7 +226,7 @@ struct value *frame_unwind_got_constant (struct frame_info *frame, int regnum,\n    inside BUF.  */\n \n struct value *frame_unwind_got_bytes (struct frame_info *frame, int regnum,\n-\t\t\t\t      gdb_byte *buf);\n+\t\t\t\t      const gdb_byte *buf);\n \n /* Return a value which indicates that FRAME's saved version of REGNUM\n    has a known constant (computed) value of ADDR.  Convert the"
    },
    {
      "sha": "2db7319bd8928d40da3462ee9485c5570dae3f55",
      "filename": "gdb/frv-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/frv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/frv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frv-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -49,7 +49,7 @@ struct frv_unwind_cache\t\t/* was struct frame_extra_info */\n     CORE_ADDR base;\n \n     /* Table indicating the location of each and every register.  */\n-    struct trad_frame_saved_reg *saved_regs;\n+    trad_frame_saved_reg *saved_regs;\n   };\n \n /* A structure describing a particular variant of the FRV.\n@@ -949,15 +949,16 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \n       for (i = 0; i < 64; i++)\n \tif (gr_saved[i])\n-\t  info->saved_regs[i].addr = this_base - fp_offset + gr_sp_offset[i];\n+\t  info->saved_regs[i].set_addr (this_base - fp_offset\n+\t\t\t\t\t+ gr_sp_offset[i]);\n \n       info->prev_sp = this_base - fp_offset + framesize;\n       info->base = this_base;\n \n       /* If LR was saved on the stack, record its location.  */\n       if (lr_saved_on_stack)\n-\tinfo->saved_regs[lr_regnum].addr\n-\t  = this_base - fp_offset + lr_sp_offset;\n+\tinfo->saved_regs[lr_regnum].set_addr (this_base - fp_offset\n+\t\t\t\t\t      + lr_sp_offset);\n \n       /* The call instruction moves the caller's PC in the callee's LR.\n \t Since this is an unwind, do the reverse.  Copy the location of LR"
    },
    {
      "sha": "ff07b7d2d4c3e82d993a0f4c4c0af4d6487232af",
      "filename": "gdb/hppa-linux-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/hppa-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/hppa-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-linux-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -191,7 +191,7 @@ hppa_linux_sigtramp_find_sigcontext (struct gdbarch *gdbarch, CORE_ADDR pc)\n struct hppa_linux_sigtramp_unwind_cache\n {\n   CORE_ADDR base;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n static struct hppa_linux_sigtramp_unwind_cache *\n@@ -227,13 +227,13 @@ hppa_linux_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n   scptr += 4;\n \n   /* GR[0] is the psw.  */\n-  info->saved_regs[HPPA_IPSW_REGNUM].addr = scptr;\n+  info->saved_regs[HPPA_IPSW_REGNUM].set_addr (scptr);\n   scptr += 4;\n \n   /* General registers.  */\n   for (i = 1; i < 32; i++)\n     {\n-      info->saved_regs[HPPA_R0_REGNUM + i].addr = scptr;\n+      info->saved_regs[HPPA_R0_REGNUM + i].set_addr (scptr);\n       scptr += 4;\n     }\n \n@@ -245,24 +245,24 @@ hppa_linux_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n \n   for (i = 4; i < 32; i++)\n     {\n-      info->saved_regs[HPPA_FP0_REGNUM + (i * 2)].addr = scptr;\n+      info->saved_regs[HPPA_FP0_REGNUM + (i * 2)].set_addr (scptr);\n       scptr += 4;\n-      info->saved_regs[HPPA_FP0_REGNUM + (i * 2) + 1].addr = scptr;\n+      info->saved_regs[HPPA_FP0_REGNUM + (i * 2) + 1].set_addr (scptr);\n       scptr += 4;\n     }\n \n   /* IASQ/IAOQ.  */\n-  info->saved_regs[HPPA_PCSQ_HEAD_REGNUM].addr = scptr;\n+  info->saved_regs[HPPA_PCSQ_HEAD_REGNUM].set_addr (scptr);\n   scptr += 4;\n-  info->saved_regs[HPPA_PCSQ_TAIL_REGNUM].addr = scptr;\n+  info->saved_regs[HPPA_PCSQ_TAIL_REGNUM].set_addr (scptr);\n   scptr += 4;\n \n-  info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].addr = scptr;\n+  info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].set_addr (scptr);\n   scptr += 4;\n-  info->saved_regs[HPPA_PCOQ_TAIL_REGNUM].addr = scptr;\n+  info->saved_regs[HPPA_PCOQ_TAIL_REGNUM].set_addr (scptr);\n   scptr += 4;\n \n-  info->saved_regs[HPPA_SAR_REGNUM].addr = scptr;\n+  info->saved_regs[HPPA_SAR_REGNUM].set_addr (scptr);\n \n   info->base = get_frame_register_unsigned (this_frame, HPPA_SP_REGNUM);\n "
    },
    {
      "sha": "4f7256500edb5628c8dcbbe7bf9e214364d17f10",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 21,
      "deletions": 19,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -1865,7 +1865,7 @@ hppa_find_unwind_entry_in_block (struct frame_info *this_frame)\n struct hppa_frame_cache\n {\n   CORE_ADDR base;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n static struct hppa_frame_cache *\n@@ -2007,18 +2007,18 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \tif (inst == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */\n \t  {\n \t    looking_for_rp = 0;\n-\t    cache->saved_regs[HPPA_RP_REGNUM].addr = -20;\n+\t    cache->saved_regs[HPPA_RP_REGNUM].set_addr (-20);\n \t  }\n \telse if (inst == 0x6bc23fd1) /* stw rp,-0x18(sr0,sp) */\n \t  {\n \t    looking_for_rp = 0;\n-\t    cache->saved_regs[HPPA_RP_REGNUM].addr = -24;\n+\t    cache->saved_regs[HPPA_RP_REGNUM].set_addr (-24);\n \t  }\n \telse if (inst == 0x0fc212c1 \n \t\t || inst == 0x73c23fe1) /* std rp,-0x10(sr0,sp) */\n \t  {\n \t    looking_for_rp = 0;\n-\t    cache->saved_regs[HPPA_RP_REGNUM].addr = -16;\n+\t    cache->saved_regs[HPPA_RP_REGNUM].set_addr (-16);\n \t  }\n \t\n \t/* Check to see if we saved SP into the stack.  This also\n@@ -2028,7 +2028,7 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t    || (inst & 0xffffc00c) == 0x73c10008) /* std,ma r1,N(sr0,sp) */\n \t  {\n \t    looking_for_sp = 0;\n-\t    cache->saved_regs[HPPA_FP_REGNUM].addr = 0;\n+\t    cache->saved_regs[HPPA_FP_REGNUM].set_addr (0);\n \t  }\n \telse if (inst == 0x08030241) /* copy %r3, %r1 */\n \t  {\n@@ -2044,10 +2044,10 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t    if ((inst >> 26) == 0x1b && hppa_extract_14 (inst) >= 0)\n \t      /* stwm with a positive displacement is a _post_\n \t\t _modify_.  */\n-\t      cache->saved_regs[reg].addr = 0;\n+\t      cache->saved_regs[reg].set_addr (0);\n \t    else if ((inst & 0xfc00000c) == 0x70000008)\n \t      /* A std has explicit post_modify forms.  */\n-\t      cache->saved_regs[reg].addr = 0;\n+\t      cache->saved_regs[reg].set_addr (0);\n \t    else\n \t      {\n \t\tCORE_ADDR offset;\n@@ -2062,10 +2062,10 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t\t\n \t\t/* Handle code with and without frame pointers.  */\n \t\tif (u->Save_SP)\n-\t\t  cache->saved_regs[reg].addr = offset;\n+\t\t  cache->saved_regs[reg].set_addr (offset);\n \t\telse\n-\t\t  cache->saved_regs[reg].addr\n-\t\t    = (u->Total_frame_size << 3) + offset;\n+\t\t  cache->saved_regs[reg].set_addr ((u->Total_frame_size << 3)\n+\t\t\t\t\t\t   + offset);\n \t      }\n \t  }\n \n@@ -2095,12 +2095,12 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t\t/* 1st HP CC FP register store.  After this\n \t\t   instruction we've set enough state that the GCC and\n \t\t   HPCC code are both handled in the same manner.  */\n-\t\tcache->saved_regs[reg + HPPA_FP4_REGNUM + 4].addr = 0;\n+\t\tcache->saved_regs[reg + HPPA_FP4_REGNUM + 4].set_addr (0);\n \t\tfp_loc = 8;\n \t      }\n \t    else\n \t      {\n-\t\tcache->saved_regs[reg + HPPA_FP0_REGNUM + 4].addr = fp_loc;\n+\t\tcache->saved_regs[reg + HPPA_FP0_REGNUM + 4].set_addr (fp_loc);\n \t\tfp_loc += 8;\n \t      }\n \t  }\n@@ -2251,7 +2251,8 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n     for (reg = 0; reg < gdbarch_num_regs (gdbarch); reg++)\n       {\n \tif (trad_frame_addr_p (cache->saved_regs, reg))\n-\t  cache->saved_regs[reg].addr += cache->base;\n+\t  cache->saved_regs[reg].set_addr (cache->saved_regs[reg].addr ()\n+\t\t\t\t\t   + cache->base);\n       }\n   }\n \n@@ -2357,13 +2358,13 @@ hppa_fallback_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t     stack.  */\n \t  if (insn == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */\n \t    {\n-\t      cache->saved_regs[HPPA_RP_REGNUM].addr = -20;\n+\t      cache->saved_regs[HPPA_RP_REGNUM].set_addr (-20);\n \t      found_rp = 1;\n \t    }\n \t  else if (insn == 0x0fc212c1\n \t\t   || insn == 0x73c23fe1) /* std rp,-0x10(sr0,sp) */\n \t    {\n-\t      cache->saved_regs[HPPA_RP_REGNUM].addr = -16;\n+\t      cache->saved_regs[HPPA_RP_REGNUM].set_addr (-16);\n \t      found_rp = 1;\n \t    }\n \t}\n@@ -2379,7 +2380,8 @@ hppa_fallback_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n   if (trad_frame_addr_p (cache->saved_regs, HPPA_RP_REGNUM))\n     {\n-      cache->saved_regs[HPPA_RP_REGNUM].addr += cache->base;\n+      cache->saved_regs[HPPA_RP_REGNUM].set_addr (cache->saved_regs[HPPA_RP_REGNUM].addr ()\n+\t\t\t\t\t\t  + cache->base);\n       cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = \n \tcache->saved_regs[HPPA_RP_REGNUM];\n     }\n@@ -2428,7 +2430,7 @@ static const struct frame_unwind hppa_fallback_frame_unwind =\n struct hppa_stub_unwind_cache\n {\n   CORE_ADDR base;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n static struct hppa_stub_unwind_cache *\n@@ -2447,7 +2449,7 @@ hppa_stub_frame_unwind_cache (struct frame_info *this_frame,\n   info->base = get_frame_register_unsigned (this_frame, HPPA_SP_REGNUM);\n \n   /* By default we assume that stubs do not change the rp.  */\n-  info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].realreg = HPPA_RP_REGNUM;\n+  info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].set_realreg (HPPA_RP_REGNUM);\n \n   return info;\n }\n@@ -2754,7 +2756,7 @@ hppa_find_global_pointer (struct gdbarch *gdbarch, struct value *function)\n \n struct value *\n hppa_frame_prev_register_helper (struct frame_info *this_frame,\n-\t\t\t\t struct trad_frame_saved_reg saved_regs[],\n+\t\t\t\t trad_frame_saved_reg saved_regs[],\n \t\t\t\t int regnum)\n {\n   struct gdbarch *arch = get_frame_arch (this_frame);"
    },
    {
      "sha": "d033c14a5690a017ce5f141da2e34013b0793d12",
      "filename": "gdb/hppa-tdep.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/hppa-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/hppa-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.h?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -107,7 +107,7 @@ struct gdbarch_tdep\n      adjust the pc to the real caller.  This improves the behavior of commands\n      that traverse frames such as \"up\" and \"finish\".  */\n   void (*unwind_adjust_stub) (struct frame_info *this_frame, CORE_ADDR base,\n-  \t\t\t      struct trad_frame_saved_reg *saved_regs);\n+\t\t\t      trad_frame_saved_reg *saved_regs);\n \n   /* These are solib-dependent methods.  They are really HPUX only, but\n      we don't have a HPUX-specific tdep vector at the moment.  */\n@@ -199,7 +199,7 @@ CORE_ADDR hppa_symbol_address(const char *sym);\n \n extern struct value *\n   hppa_frame_prev_register_helper (struct frame_info *this_frame,\n-\t\t\t\t   struct trad_frame_saved_reg *saved_regs,\n+\t\t\t\t   trad_frame_saved_reg *saved_regs,\n \t\t\t\t   int regnum);\n \n extern CORE_ADDR hppa_read_pc (struct regcache *regcache);"
    },
    {
      "sha": "8f1961c90395a6da54f950c38e151e1388cefb1c",
      "filename": "gdb/lm32-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/lm32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/lm32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/lm32-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -58,7 +58,7 @@ struct lm32_frame_cache\n   /* Size of frame.  */\n   int size;\n   /* Table indicating the location of each and every register.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Add the available register groups.  */\n@@ -146,8 +146,7 @@ lm32_analyze_prologue (struct gdbarch *gdbarch,\n \t  /* Any stack displaced store is likely part of the prologue.\n \t     Record that the register is being saved, and the offset \n \t     into the stack.  */\n-\t  info->saved_regs[LM32_REG1 (instruction)].addr =\n-\t    LM32_IMM16 (instruction);\n+\t  info->saved_regs[LM32_REG1 (instruction)].set_addr (LM32_IMM16 (instruction));\n \t}\n       else if ((LM32_OPCODE (instruction) == OP_ADDI)\n \t       && (LM32_REG1 (instruction) == SIM_LM32_SP_REGNUM))\n@@ -188,7 +187,7 @@ lm32_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n {\n   CORE_ADDR func_addr, limit_pc;\n   struct lm32_frame_cache frame_info;\n-  struct trad_frame_saved_reg saved_regs[SIM_LM32_NUM_REGS];\n+  trad_frame_saved_reg saved_regs[SIM_LM32_NUM_REGS];\n \n   /* See if we can determine the end of the prologue via the symbol table.\n      If so, then return either PC, or the PC after the prologue, whichever\n@@ -419,7 +418,7 @@ lm32_frame_cache (struct frame_info *this_frame, void **this_prologue_cache)\n   for (i = 0; i < gdbarch_num_regs (get_frame_arch (this_frame)) - 1; i++)\n     {\n       if (trad_frame_addr_p (info->saved_regs, i))\n-\tinfo->saved_regs[i].addr = this_base + info->saved_regs[i].addr;\n+\tinfo->saved_regs[i].set_addr (this_base + info->saved_regs[i].addr ());\n     }\n \n   /* The call instruction moves the caller's PC in the callee's RA register."
    },
    {
      "sha": "bed14edba3a4f8c09ad1dcb3233d902f1afa3b5a",
      "filename": "gdb/m32r-linux-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/m32r-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/m32r-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-linux-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -219,7 +219,7 @@ static int m32r_linux_sc_reg_offset[] = {\n struct m32r_frame_cache\n {\n   CORE_ADDR base, pc;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n static struct m32r_frame_cache *\n@@ -258,8 +258,8 @@ m32r_linux_sigtramp_frame_cache (struct frame_info *this_frame,\n   for (regnum = 0; regnum < sizeof (m32r_linux_sc_reg_offset) / 4; regnum++)\n     {\n       if (m32r_linux_sc_reg_offset[regnum] >= 0)\n-\tcache->saved_regs[regnum].addr =\n-\t  sigcontext_addr + m32r_linux_sc_reg_offset[regnum];\n+\tcache->saved_regs[regnum].set_addr (sigcontext_addr\n+\t\t\t\t\t    + m32r_linux_sc_reg_offset[regnum]);\n     }\n \n   return cache;"
    },
    {
      "sha": "9259660e43db1614c5c36992de68363b96ee49cc",
      "filename": "gdb/m32r-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/m32r-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/m32r-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -509,7 +509,7 @@ struct m32r_unwind_cache\n   LONGEST r13_offset;\n   int uses_frame;\n   /* Table indicating the location of each and every register.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Put here the code to store, into fi->saved_regs, the addresses of\n@@ -581,7 +581,7 @@ m32r_frame_unwind_cache (struct frame_info *this_frame,\n \t  /* st rn, @-sp */\n \t  int regno = ((op >> 8) & 0xf);\n \t  info->sp_offset -= 4;\n-\t  info->saved_regs[regno].addr = info->sp_offset;\n+\t  info->saved_regs[regno].set_addr (info->sp_offset);\n \t}\n       else if ((op & 0xff00) == 0x4f00)\n \t{\n@@ -633,7 +633,8 @@ m32r_frame_unwind_cache (struct frame_info *this_frame,\n      not offsets.  */\n   for (i = 0; i < gdbarch_num_regs (get_frame_arch (this_frame)) - 1; i++)\n     if (trad_frame_addr_p (info->saved_regs, i))\n-      info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);\n+      info->saved_regs[i].set_addr (info->prev_sp\n+\t\t\t\t    + info->saved_regs[i].addr ());\n \n   /* The call instruction moves the caller's PC in the callee's LR.\n      Since this is an unwind, do the reverse.  Copy the location of LR"
    },
    {
      "sha": "2a121446d6cfbf4cab8b4d19e485cc0bbd6325c9",
      "filename": "gdb/m68hc11-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/m68hc11-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/m68hc11-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68hc11-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -161,7 +161,7 @@ struct m68hc11_unwind_cache\n   enum insn_return_kind return_kind;\n \n   /* Table indicating the location of each and every register.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Table of registers for 68HC11.  This includes the hard registers\n@@ -700,7 +700,7 @@ m68hc11_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \n \t      save_addr -= 2;\n \t      if (info->saved_regs)\n-\t\tinfo->saved_regs[saved_reg].addr = save_addr;\n+\t\tinfo->saved_regs[saved_reg].set_addr (save_addr);\n \t    }\n \t  else\n \t    {\n@@ -800,11 +800,11 @@ m68hc11_frame_unwind_cache (struct frame_info *this_frame,\n   if (info->pc != 0)\n     m68hc11_scan_prologue (gdbarch, info->pc, current_pc, info);\n \n-  info->saved_regs[HARD_PC_REGNUM].addr = info->size;\n+  info->saved_regs[HARD_PC_REGNUM].set_addr (info->size);\n \n   if (info->sp_offset != (CORE_ADDR) -1)\n     {\n-      info->saved_regs[HARD_PC_REGNUM].addr = info->sp_offset;\n+      info->saved_regs[HARD_PC_REGNUM].set_addr (info->sp_offset);\n       this_base = get_frame_register_unsigned (this_frame, HARD_SP_REGNUM);\n       prev_sp = this_base + info->sp_offset + 2;\n       this_base += STACK_CORRECTION (gdbarch);\n@@ -817,23 +817,23 @@ m68hc11_frame_unwind_cache (struct frame_info *this_frame,\n \n       this_base += STACK_CORRECTION (gdbarch);\n       if (soft_regs[SOFT_FP_REGNUM].name)\n-\tinfo->saved_regs[SOFT_FP_REGNUM].addr = info->size - 2;\n+\tinfo->saved_regs[SOFT_FP_REGNUM].set_addr (info->size - 2);\n    }\n \n   if (info->return_kind == RETURN_RTC)\n     {\n       prev_sp += 1;\n-      info->saved_regs[HARD_PAGE_REGNUM].addr = info->size;\n-      info->saved_regs[HARD_PC_REGNUM].addr = info->size + 1;\n+      info->saved_regs[HARD_PAGE_REGNUM].set_addr (info->size);\n+      info->saved_regs[HARD_PC_REGNUM].set_addr (info->size + 1);\n     }\n   else if (info->return_kind == RETURN_RTI)\n     {\n       prev_sp += 7;\n-      info->saved_regs[HARD_CCR_REGNUM].addr = info->size;\n-      info->saved_regs[HARD_D_REGNUM].addr = info->size + 1;\n-      info->saved_regs[HARD_X_REGNUM].addr = info->size + 3;\n-      info->saved_regs[HARD_Y_REGNUM].addr = info->size + 5;\n-      info->saved_regs[HARD_PC_REGNUM].addr = info->size + 7;\n+      info->saved_regs[HARD_CCR_REGNUM].set_addr (info->size);\n+      info->saved_regs[HARD_D_REGNUM].set_addr (info->size + 1);\n+      info->saved_regs[HARD_X_REGNUM].set_addr (info->size + 3);\n+      info->saved_regs[HARD_Y_REGNUM].set_addr (info->size + 5);\n+      info->saved_regs[HARD_PC_REGNUM].set_addr (info->size + 7);\n     }\n \n   /* Add 1 here to adjust for the post-decrement nature of the push\n@@ -847,7 +847,7 @@ m68hc11_frame_unwind_cache (struct frame_info *this_frame,\n   for (i = 0; i < gdbarch_num_cooked_regs (gdbarch); i++)\n     if (trad_frame_addr_p (info->saved_regs, i))\n       {\n-\tinfo->saved_regs[i].addr += this_base;\n+\tinfo->saved_regs[i].set_addr (info->saved_regs[i].addr () + this_base);\n       }\n \n   /* The previous frame's SP needed to be computed.  Save the computed"
    },
    {
      "sha": "f0c343d1297623943ebac220d8bd2773938f7026",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 9,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -2425,7 +2425,7 @@ micromips_instruction_is_compact_branch (unsigned short insn)\n struct mips_frame_cache\n {\n   CORE_ADDR base;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Set a register's saved stack address in temp_saved_regs.  If an\n@@ -2444,12 +2444,12 @@ set_reg_offset (struct gdbarch *gdbarch, struct mips_frame_cache *this_cache,\n \t\tint regnum, CORE_ADDR offset)\n {\n   if (this_cache != NULL\n-      && this_cache->saved_regs[regnum].addr == -1)\n+      && this_cache->saved_regs[regnum].is_realreg ())\n     {\n-      this_cache->saved_regs[regnum + 0 * gdbarch_num_regs (gdbarch)].addr\n-\t= offset;\n-      this_cache->saved_regs[regnum + 1 * gdbarch_num_regs (gdbarch)].addr\n-\t= offset;\n+      this_cache->saved_regs[regnum + 0\n+\t\t\t     * gdbarch_num_regs (gdbarch)].set_addr (offset);\n+      this_cache->saved_regs[regnum + 1\n+\t\t\t     * gdbarch_num_regs (gdbarch)].set_addr (offset);\n     }\n }\n \n@@ -3389,9 +3389,7 @@ reset_saved_regs (struct gdbarch *gdbarch, struct mips_frame_cache *this_cache)\n     int i;\n \n     for (i = 0; i < num_regs; i++)\n-      {\n-\tthis_cache->saved_regs[i].addr = -1;\n-      }\n+      this_cache->saved_regs[i].set_addr (-1);\n   }\n }\n "
    },
    {
      "sha": "9af37d65cc59d89b12732adb8955ab9e008b0b7d",
      "filename": "gdb/moxie-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/moxie-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/moxie-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/moxie-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -267,7 +267,7 @@ struct moxie_unwind_cache\n   LONGEST r13_offset;\n   int uses_frame;\n   /* Table indicating the location of each and every register.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Read an unsigned integer from the inferior, and adjust"
    },
    {
      "sha": "c0e84e585d23168a644e64ec0d6d8f51c791f5bc",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -107,7 +107,7 @@ struct riscv_unwind_cache\n   int frame_base_offset;\n \n   /* Information about previous register values.  */\n-  struct trad_frame_saved_reg *regs;\n+  trad_frame_saved_reg *regs;\n \n   /* The id for this frame.  */\n   struct frame_id this_id;\n@@ -3146,7 +3146,8 @@ riscv_frame_cache (struct frame_info *this_frame, void **this_cache)\n   for (regno = 0; regno < numregs; ++regno)\n     {\n       if (trad_frame_addr_p (cache->regs, regno))\n-\tcache->regs[regno].addr += cache->frame_base;\n+\tcache->regs[regno].set_addr (cache->regs[regno].addr ()\n+\t\t\t\t     + cache->frame_base);\n     }\n \n   /* The previous $pc can be found wherever the $ra value can be found."
    },
    {
      "sha": "2dbc2a23a9eaa8b53a8269ea765f6649e5bc938c",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 14,
      "deletions": 13,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -3469,7 +3469,7 @@ struct rs6000_frame_cache\n {\n   CORE_ADDR base;\n   CORE_ADDR initial_sp;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n \n   /* Set BASE_P to true if this frame cache is properly initialized.\n      Otherwise set to false because some registers or memory cannot\n@@ -3580,7 +3580,7 @@ rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)\n       if (ppc_floating_point_unit_p (gdbarch))\n \tfor (i = fdata.saved_fpr; i < ppc_num_fprs; i++)\n \t  {\n-\t    cache->saved_regs[tdep->ppc_fp0_regnum + i].addr = fpr_addr;\n+\t    cache->saved_regs[tdep->ppc_fp0_regnum + i].set_addr (fpr_addr);\n \t    fpr_addr += 8;\n \t  }\n     }\n@@ -3596,7 +3596,7 @@ rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)\n       for (i = fdata.saved_gpr; i < ppc_num_gprs; i++)\n \t{\n \t  if (fdata.gpr_mask & (1U << i))\n-\t    cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = gpr_addr;\n+\t    cache->saved_regs[tdep->ppc_gp0_regnum + i].set_addr (gpr_addr);\n \t  gpr_addr += wordsize;\n \t}\n     }\n@@ -3611,7 +3611,7 @@ rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t  CORE_ADDR vr_addr = cache->base + fdata.vr_offset;\n \t  for (i = fdata.saved_vr; i < 32; i++)\n \t    {\n-\t      cache->saved_regs[tdep->ppc_vr0_regnum + i].addr = vr_addr;\n+\t      cache->saved_regs[tdep->ppc_vr0_regnum + i].set_addr (vr_addr);\n \t      vr_addr += register_size (gdbarch, tdep->ppc_vr0_regnum);\n \t    }\n \t}\n@@ -3629,8 +3629,9 @@ rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n \t  for (i = fdata.saved_ev; i < ppc_num_gprs; i++)\n \t    {\n-\t      cache->saved_regs[tdep->ppc_ev0_regnum + i].addr = ev_addr;\n-\t      cache->saved_regs[tdep->ppc_gp0_regnum + i].addr = ev_addr + off;\n+\t      cache->saved_regs[tdep->ppc_ev0_regnum + i].set_addr (ev_addr);\n+\t      cache->saved_regs[tdep->ppc_gp0_regnum + i].set_addr (ev_addr\n+\t\t\t\t\t\t\t\t    + off);\n \t      ev_addr += register_size (gdbarch, tdep->ppc_ev0_regnum);\n \t    }\n \t}\n@@ -3639,25 +3640,25 @@ rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)\n   /* If != 0, fdata.cr_offset is the offset from the frame that\n      holds the CR.  */\n   if (fdata.cr_offset != 0)\n-    cache->saved_regs[tdep->ppc_cr_regnum].addr\n-      = cache->base + fdata.cr_offset;\n+    cache->saved_regs[tdep->ppc_cr_regnum].set_addr (cache->base\n+\t\t\t\t\t\t     + fdata.cr_offset);\n \n   /* If != 0, fdata.lr_offset is the offset from the frame that\n      holds the LR.  */\n   if (fdata.lr_offset != 0)\n-    cache->saved_regs[tdep->ppc_lr_regnum].addr\n-      = cache->base + fdata.lr_offset;\n+    cache->saved_regs[tdep->ppc_lr_regnum].set_addr (cache->base\n+\t\t\t\t\t\t     + fdata.lr_offset);\n   else if (fdata.lr_register != -1)\n-    cache->saved_regs[tdep->ppc_lr_regnum].realreg = fdata.lr_register;\n+    cache->saved_regs[tdep->ppc_lr_regnum].set_realreg (fdata.lr_register);\n   /* The PC is found in the link register.  */\n   cache->saved_regs[gdbarch_pc_regnum (gdbarch)] =\n     cache->saved_regs[tdep->ppc_lr_regnum];\n \n   /* If != 0, fdata.vrsave_offset is the offset from the frame that\n      holds the VRSAVE.  */\n   if (fdata.vrsave_offset != 0)\n-    cache->saved_regs[tdep->ppc_vrsave_regnum].addr\n-      = cache->base + fdata.vrsave_offset;\n+    cache->saved_regs[tdep->ppc_vrsave_regnum].set_addr (cache->base\n+\t\t\t\t\t\t\t + fdata.vrsave_offset);\n \n   if (fdata.alloca_reg < 0)\n     /* If no alloca register used, then fi->frame is the value of the"
    },
    {
      "sha": "4a39681f43f816d5b7f5535cf430fa6c7fe6c696",
      "filename": "gdb/s390-linux-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/s390-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/s390-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-linux-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -379,7 +379,7 @@ s390_core_read_description (struct gdbarch *gdbarch,\n \n struct s390_sigtramp_unwind_cache {\n   CORE_ADDR frame_base;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Unwind THIS_FRAME and return the corresponding unwind cache for\n@@ -443,33 +443,33 @@ s390_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n \t    double fprs[16];  */\n \n   /* PSW mask and address.  */\n-  info->saved_regs[S390_PSWM_REGNUM].addr = sigreg_ptr;\n+  info->saved_regs[S390_PSWM_REGNUM].set_addr (sigreg_ptr);\n   sigreg_ptr += word_size;\n-  info->saved_regs[S390_PSWA_REGNUM].addr = sigreg_ptr;\n+  info->saved_regs[S390_PSWA_REGNUM].set_addr (sigreg_ptr);\n   sigreg_ptr += word_size;\n \n   /* Then the GPRs.  */\n   for (i = 0; i < 16; i++)\n     {\n-      info->saved_regs[S390_R0_REGNUM + i].addr = sigreg_ptr;\n+      info->saved_regs[S390_R0_REGNUM + i].set_addr (sigreg_ptr);\n       sigreg_ptr += word_size;\n     }\n \n   /* Then the ACRs.  */\n   for (i = 0; i < 16; i++)\n     {\n-      info->saved_regs[S390_A0_REGNUM + i].addr = sigreg_ptr;\n+      info->saved_regs[S390_A0_REGNUM + i].set_addr (sigreg_ptr);\n       sigreg_ptr += 4;\n     }\n \n   /* The floating-point control word.  */\n-  info->saved_regs[S390_FPC_REGNUM].addr = sigreg_ptr;\n+  info->saved_regs[S390_FPC_REGNUM].set_addr (sigreg_ptr);\n   sigreg_ptr += 8;\n \n   /* And finally the FPRs.  */\n   for (i = 0; i < 16; i++)\n     {\n-      info->saved_regs[S390_F0_REGNUM + i].addr = sigreg_ptr;\n+      info->saved_regs[S390_F0_REGNUM + i].set_addr (sigreg_ptr);\n       sigreg_ptr += 8;\n     }\n \n@@ -478,13 +478,13 @@ s390_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n   if (tdep->gpr_full_regnum != -1)\n     for (i = 0; i < 16; i++)\n       {\n-\tinfo->saved_regs[S390_R0_UPPER_REGNUM + i].addr = sigreg_ptr;\n+\tinfo->saved_regs[S390_R0_UPPER_REGNUM + i].set_addr (sigreg_ptr);\n \tsigreg_ptr += 4;\n       }\n \n   /* Restore the previous frame's SP.  */\n   prev_sp = read_memory_unsigned_integer (\n-\t\t\tinfo->saved_regs[S390_SP_REGNUM].addr,\n+\t\t\tinfo->saved_regs[S390_SP_REGNUM].addr (),\n \t\t\tword_size, byte_order);\n \n   /* Determine our frame base.  */"
    },
    {
      "sha": "dbdace848dae0c6d61a09cdd5a584b6e93080ab8",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -2299,7 +2299,7 @@ s390_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,\n \n struct value *\n s390_trad_frame_prev_register (struct frame_info *this_frame,\n-\t\t\t       struct trad_frame_saved_reg saved_regs[],\n+\t\t\t       trad_frame_saved_reg saved_regs[],\n \t\t\t       int regnum)\n {\n   if (regnum < S390_NUM_REGS)\n@@ -2316,7 +2316,7 @@ struct s390_unwind_cache {\n   CORE_ADDR frame_base;\n   CORE_ADDR local_base;\n \n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Unwind THIS_FRAME and write the information into unwind cache INFO using\n@@ -2464,12 +2464,12 @@ s390_prologue_frame_unwind_cache (struct frame_info *this_frame,\n   for (i = 0; i < 16; i++)\n     if (s390_register_call_saved (gdbarch, S390_R0_REGNUM + i)\n \t&& data.gpr_slot[i] != 0)\n-      info->saved_regs[S390_R0_REGNUM + i].addr = cfa - data.gpr_slot[i];\n+      info->saved_regs[S390_R0_REGNUM + i].set_addr (cfa - data.gpr_slot[i]);\n \n   for (i = 0; i < 16; i++)\n     if (s390_register_call_saved (gdbarch, S390_F0_REGNUM + i)\n \t&& data.fpr_slot[i] != 0)\n-      info->saved_regs[S390_F0_REGNUM + i].addr = cfa - data.fpr_slot[i];\n+      info->saved_regs[S390_F0_REGNUM + i].set_addr (cfa - data.fpr_slot[i]);\n \n   /* Function return will set PC to %r14.  */\n   info->saved_regs[S390_PSWA_REGNUM] = info->saved_regs[S390_RETADDR_REGNUM];\n@@ -2481,7 +2481,7 @@ s390_prologue_frame_unwind_cache (struct frame_info *this_frame,\n   if (size == 0\n       && !trad_frame_addr_p (info->saved_regs, S390_PSWA_REGNUM))\n     {\n-      info->saved_regs[S390_PSWA_REGNUM].realreg = S390_RETADDR_REGNUM;\n+      info->saved_regs[S390_PSWA_REGNUM].set_realreg (S390_RETADDR_REGNUM);\n     }\n \n   /* Another sanity check: unless this is a frameless function,\n@@ -2547,8 +2547,8 @@ s390_backchain_frame_unwind_cache (struct frame_info *this_frame,\n       /* We don't know which registers were saved, but it will have\n \t to be at least %r14 and %r15.  This will allow us to continue\n \t unwinding, but other prev-frame registers may be incorrect ...  */\n-      info->saved_regs[S390_SP_REGNUM].addr = backchain + 15*word_size;\n-      info->saved_regs[S390_RETADDR_REGNUM].addr = backchain + 14*word_size;\n+      info->saved_regs[S390_SP_REGNUM].set_addr (backchain + 15*word_size);\n+      info->saved_regs[S390_RETADDR_REGNUM].set_addr (backchain + 14*word_size);\n \n       /* Function return will set PC to %r14.  */\n       info->saved_regs[S390_PSWA_REGNUM]\n@@ -2648,7 +2648,7 @@ static const struct frame_unwind s390_frame_unwind = {\n struct s390_stub_unwind_cache\n {\n   CORE_ADDR frame_base;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Unwind THIS_FRAME and return the corresponding unwind cache for\n@@ -2671,7 +2671,7 @@ s390_stub_frame_unwind_cache (struct frame_info *this_frame,\n   info->saved_regs = trad_frame_alloc_saved_regs (this_frame);\n \n   /* The return address is in register %r14.  */\n-  info->saved_regs[S390_PSWA_REGNUM].realreg = S390_RETADDR_REGNUM;\n+  info->saved_regs[S390_PSWA_REGNUM].set_realreg (S390_RETADDR_REGNUM);\n \n   /* Retrieve stack pointer and determine our frame base.  */\n   reg = get_frame_register_unsigned (this_frame, S390_SP_REGNUM);"
    },
    {
      "sha": "4b9f647948c2119806acc339f908459dd0fb6ac5",
      "filename": "gdb/score-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/score-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/score-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/score-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -50,7 +50,7 @@ struct score_frame_cache\n {\n   CORE_ADDR base;\n   CORE_ADDR fp;\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n static int target_mach = bfd_mach_score7;\n@@ -1019,9 +1019,9 @@ score7_analyze_prologue (CORE_ADDR startaddr, CORE_ADDR pc,\n   /* Save RA.  */\n   if (ra_offset_p == 1)\n     {\n-      if (this_cache->saved_regs[SCORE_PC_REGNUM].addr == -1)\n-\tthis_cache->saved_regs[SCORE_PC_REGNUM].addr =\n-\t  sp + sp_offset - ra_offset;\n+      if (this_cache->saved_regs[SCORE_PC_REGNUM].is_realreg ())\n+\tthis_cache->saved_regs[SCORE_PC_REGNUM].set_addr (sp + sp_offset\n+\t\t\t\t\t\t\t  - ra_offset);\n     }\n   else\n     {\n@@ -1032,9 +1032,9 @@ score7_analyze_prologue (CORE_ADDR startaddr, CORE_ADDR pc,\n   /* Save FP.  */\n   if (fp_offset_p == 1)\n     {\n-      if (this_cache->saved_regs[SCORE_FP_REGNUM].addr == -1)\n-\tthis_cache->saved_regs[SCORE_FP_REGNUM].addr =\n-\t  sp + sp_offset - fp_offset;\n+      if (this_cache->saved_regs[SCORE_FP_REGNUM].is_realreg ())\n+\tthis_cache->saved_regs[SCORE_FP_REGNUM].set_addr (sp + sp_offset\n+\t\t\t\t\t\t\t  - fp_offset);\n     }\n \n   /* Save SP and FP.  */\n@@ -1265,9 +1265,9 @@ score3_analyze_prologue (CORE_ADDR startaddr, CORE_ADDR pc,\n   /* Save RA.  */\n   if (ra_offset_p == 1)\n     {\n-      if (this_cache->saved_regs[SCORE_PC_REGNUM].addr == -1)\n-\tthis_cache->saved_regs[SCORE_PC_REGNUM].addr =\n-\t  sp + sp_offset - ra_offset;\n+      if (this_cache->saved_regs[SCORE_PC_REGNUM].is_realreg ())\n+\tthis_cache->saved_regs[SCORE_PC_REGNUM].set_addr (sp + sp_offset\n+\t\t\t\t\t\t\t  - ra_offset);\n     }\n   else\n     {\n@@ -1278,9 +1278,9 @@ score3_analyze_prologue (CORE_ADDR startaddr, CORE_ADDR pc,\n   /* Save FP.  */\n   if (fp_offset_p == 1)\n     {\n-      if (this_cache->saved_regs[SCORE_FP_REGNUM].addr == -1)\n-\tthis_cache->saved_regs[SCORE_FP_REGNUM].addr =\n-\t  sp + sp_offset - fp_offset;\n+      if (this_cache->saved_regs[SCORE_FP_REGNUM].is_realreg ())\n+\tthis_cache->saved_regs[SCORE_FP_REGNUM].set_addr (sp + sp_offset\n+\t\t\t\t\t\t\t  - fp_offset);\n     }\n \n   /* Save SP and FP.  */"
    },
    {
      "sha": "2203039b0e8b9a61d53fbecbfaf25d1d1813f03d",
      "filename": "gdb/sparc-netbsd-tdep.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-netbsd-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -94,11 +94,11 @@ sparc32nbsd_pc_in_sigtramp (CORE_ADDR pc, const char *name)\n   return nbsd_pc_in_sigtramp (pc, name);\n }\n \n-struct trad_frame_saved_reg *\n+trad_frame_saved_reg *\n sparc32nbsd_sigcontext_saved_regs (struct frame_info *this_frame)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n   CORE_ADDR addr, sigcontext_addr;\n   int regnum, delta;\n   ULONGEST psr;\n@@ -115,34 +115,34 @@ sparc32nbsd_sigcontext_saved_regs (struct frame_info *this_frame)\n      that the part of the signal trampoline that saves the state has\n      been executed.  */\n \n-  saved_regs[SPARC_SP_REGNUM].addr = sigcontext_addr + 8;\n-  saved_regs[SPARC32_PC_REGNUM].addr = sigcontext_addr + 12;\n-  saved_regs[SPARC32_NPC_REGNUM].addr = sigcontext_addr + 16;\n-  saved_regs[SPARC32_PSR_REGNUM].addr = sigcontext_addr + 20;\n-  saved_regs[SPARC_G1_REGNUM].addr = sigcontext_addr + 24;\n-  saved_regs[SPARC_O0_REGNUM].addr = sigcontext_addr + 28;\n+  saved_regs[SPARC_SP_REGNUM].set_addr (sigcontext_addr + 8);\n+  saved_regs[SPARC32_PC_REGNUM].set_addr (sigcontext_addr + 12);\n+  saved_regs[SPARC32_NPC_REGNUM].set_addr (sigcontext_addr + 16);\n+  saved_regs[SPARC32_PSR_REGNUM].set_addr (sigcontext_addr + 20);\n+  saved_regs[SPARC_G1_REGNUM].set_addr (sigcontext_addr + 24);\n+  saved_regs[SPARC_O0_REGNUM].set_addr (sigcontext_addr + 28);\n \n   /* The remaining `global' registers and %y are saved in the `local'\n      registers.  */\n   delta = SPARC_L0_REGNUM - SPARC_G0_REGNUM;\n   for (regnum = SPARC_G2_REGNUM; regnum <= SPARC_G7_REGNUM; regnum++)\n-    saved_regs[regnum].realreg = regnum + delta;\n-  saved_regs[SPARC32_Y_REGNUM].realreg = SPARC_L1_REGNUM;\n+    saved_regs[regnum].set_realreg (regnum + delta);\n+  saved_regs[SPARC32_Y_REGNUM].set_realreg (SPARC_L1_REGNUM);\n \n   /* The remaining `out' registers can be found in the current frame's\n      `in' registers.  */\n   delta = SPARC_I0_REGNUM - SPARC_O0_REGNUM;\n   for (regnum = SPARC_O1_REGNUM; regnum <= SPARC_O5_REGNUM; regnum++)\n-    saved_regs[regnum].realreg = regnum + delta;\n-  saved_regs[SPARC_O7_REGNUM].realreg = SPARC_I7_REGNUM;\n+    saved_regs[regnum].set_realreg (regnum + delta);\n+  saved_regs[SPARC_O7_REGNUM].set_realreg (SPARC_I7_REGNUM);\n \n   /* The `local' and `in' registers have been saved in the register\n      save area.  */\n-  addr = saved_regs[SPARC_SP_REGNUM].addr;\n+  addr = saved_regs[SPARC_SP_REGNUM].addr ();\n   addr = get_frame_memory_unsigned (this_frame, addr, 4);\n   for (regnum = SPARC_L0_REGNUM;\n        regnum <= SPARC_I7_REGNUM; regnum++, addr += 4)\n-    saved_regs[regnum].addr = addr;\n+    saved_regs[regnum].set_addr (addr);\n \n   /* Handle StackGhost.  */\n   {\n@@ -152,7 +152,7 @@ sparc32nbsd_sigcontext_saved_regs (struct frame_info *this_frame)\n       {\n \tULONGEST i7;\n \n-\taddr = saved_regs[SPARC_I7_REGNUM].addr;\n+\taddr = saved_regs[SPARC_I7_REGNUM].addr ();\n \ti7 = get_frame_memory_unsigned (this_frame, addr, 4);\n \ttrad_frame_set_value (saved_regs, SPARC_I7_REGNUM, i7 ^ wcookie);\n       }\n@@ -163,17 +163,17 @@ sparc32nbsd_sigcontext_saved_regs (struct frame_info *this_frame)\n \n #define PSR_EF\t0x00001000\n \n-  addr = saved_regs[SPARC32_PSR_REGNUM].addr;\n+  addr = saved_regs[SPARC32_PSR_REGNUM].addr ();\n   psr = get_frame_memory_unsigned (this_frame, addr, 4);\n   if (psr & PSR_EF)\n     {\n       CORE_ADDR sp;\n \n       sp = get_frame_register_unsigned (this_frame, SPARC_SP_REGNUM);\n-      saved_regs[SPARC32_FSR_REGNUM].addr = sp + 96;\n+      saved_regs[SPARC32_FSR_REGNUM].set_addr (sp + 96);\n       for (regnum = SPARC_F0_REGNUM, addr = sp + 96 + 8;\n \t   regnum <= SPARC_F31_REGNUM; regnum++, addr += 4)\n-\tsaved_regs[regnum].addr = addr;\n+\tsaved_regs[regnum].set_addr (addr);\n     }\n \n   return saved_regs;"
    },
    {
      "sha": "6b6d59e76100590c01467857200d085716821fd7",
      "filename": "gdb/sparc-sol2-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc-sol2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc-sol2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-sol2-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -122,15 +122,15 @@ sparc32_sol2_sigtramp_frame_cache (struct frame_info *this_frame,\n     (cache->copied_regs_mask & 0x04) ? SPARC_I2_REGNUM : SPARC_O2_REGNUM;\n   mcontext_addr = get_frame_register_unsigned (this_frame, regnum) + 40;\n \n-  cache->saved_regs[SPARC32_PSR_REGNUM].addr = mcontext_addr + 0 * 4;\n-  cache->saved_regs[SPARC32_PC_REGNUM].addr = mcontext_addr + 1 * 4;\n-  cache->saved_regs[SPARC32_NPC_REGNUM].addr = mcontext_addr + 2 * 4;\n-  cache->saved_regs[SPARC32_Y_REGNUM].addr = mcontext_addr + 3 * 4;\n+  cache->saved_regs[SPARC32_PSR_REGNUM].set_addr (mcontext_addr + 0 * 4);\n+  cache->saved_regs[SPARC32_PC_REGNUM].set_addr (mcontext_addr + 1 * 4);\n+  cache->saved_regs[SPARC32_NPC_REGNUM].set_addr (mcontext_addr + 2 * 4);\n+  cache->saved_regs[SPARC32_Y_REGNUM].set_addr (mcontext_addr + 3 * 4);\n \n   /* Since %g0 is always zero, keep the identity encoding.  */\n   for (regnum = SPARC_G1_REGNUM, addr = mcontext_addr + 4 * 4;\n        regnum <= SPARC_O7_REGNUM; regnum++, addr += 4)\n-    cache->saved_regs[regnum].addr = addr;\n+    cache->saved_regs[regnum].set_addr (addr);\n \n   if (get_frame_memory_unsigned (this_frame, mcontext_addr + 19 * 4, 4))\n     {\n@@ -140,11 +140,11 @@ sparc32_sol2_sigtramp_frame_cache (struct frame_info *this_frame,\n     }\n   else\n     {\n-      addr = cache->saved_regs[SPARC_SP_REGNUM].addr;\n+      addr = cache->saved_regs[SPARC_SP_REGNUM].addr ();\n       addr = get_frame_memory_unsigned (this_frame, addr, 4);\n       for (regnum = SPARC_L0_REGNUM;\n \t   regnum <= SPARC_I7_REGNUM; regnum++, addr += 4)\n-\tcache->saved_regs[regnum].addr = addr;\n+\tcache->saved_regs[regnum].set_addr (addr);\n     }\n \n   return cache;"
    },
    {
      "sha": "6f906d53173bf7da60332dcee37f3fe64f877cbb",
      "filename": "gdb/sparc64-fbsd-tdep.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc64-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc64-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-fbsd-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -114,48 +114,48 @@ sparc64fbsd_sigtramp_frame_cache (struct frame_info *this_frame,\n   /* The following registers travel in the `mc_local' slots of\n      `mcontext_t'.  */\n   addr = mcontext_addr + 16 * 8;\n-  cache->saved_regs[SPARC64_FPRS_REGNUM].addr = addr + 0 * 8;\n-  cache->saved_regs[SPARC64_FSR_REGNUM].addr = addr + 1 * 8;\n+  cache->saved_regs[SPARC64_FPRS_REGNUM].set_addr (addr + 0 * 8);\n+  cache->saved_regs[SPARC64_FSR_REGNUM].set_addr (addr + 1 * 8);\n \n   /* The following registers travel in the `mc_in' slots of\n      `mcontext_t'.  */\n   addr = mcontext_addr + 24 * 8;\n-  cache->saved_regs[SPARC64_NPC_REGNUM].addr = addr + 0 * 8;\n-  cache->saved_regs[SPARC64_PC_REGNUM].addr = addr + 1 * 8;\n-  cache->saved_regs[SPARC64_STATE_REGNUM].addr = addr + 2 * 8;\n-  cache->saved_regs[SPARC64_Y_REGNUM].addr = addr + 4 * 8;\n+  cache->saved_regs[SPARC64_NPC_REGNUM].set_addr (addr + 0 * 8);\n+  cache->saved_regs[SPARC64_PC_REGNUM].set_addr (addr + 1 * 8);\n+  cache->saved_regs[SPARC64_STATE_REGNUM].set_addr (addr + 2 * 8);\n+  cache->saved_regs[SPARC64_Y_REGNUM].set_addr (addr + 4 * 8);\n \n   /* The `global' and `out' registers travel in the `mc_global' and\n      `mc_out' slots of `mcontext_t', except for %g0.  Since %g0 is\n      always zero, keep the identity encoding.  */\n   for (regnum = SPARC_G1_REGNUM, addr = mcontext_addr + 8;\n        regnum <= SPARC_O7_REGNUM; regnum++, addr += 8)\n-    cache->saved_regs[regnum].addr = addr;\n+    cache->saved_regs[regnum].set_addr (addr);\n \n   /* The `local' and `in' registers have been saved in the register\n      save area.  */\n-  addr = cache->saved_regs[SPARC_SP_REGNUM].addr;\n+  addr = cache->saved_regs[SPARC_SP_REGNUM].addr ();\n   sp = get_frame_memory_unsigned (this_frame, addr, 8);\n   for (regnum = SPARC_L0_REGNUM, addr = sp + BIAS;\n        regnum <= SPARC_I7_REGNUM; regnum++, addr += 8)\n-    cache->saved_regs[regnum].addr = addr;\n+    cache->saved_regs[regnum].set_addr (addr);\n \n   /* The floating-point registers are only saved if the FEF bit in\n      %fprs has been set.  */\n \n #define FPRS_FEF\t(1 << 2)\n \n-  addr = cache->saved_regs[SPARC64_FPRS_REGNUM].addr;\n+  addr = cache->saved_regs[SPARC64_FPRS_REGNUM].addr ();\n   fprs = get_frame_memory_unsigned (this_frame, addr, 8);\n   if (fprs & FPRS_FEF)\n     {\n       for (regnum = SPARC_F0_REGNUM, addr = mcontext_addr + 32 * 8;\n \t   regnum <= SPARC_F31_REGNUM; regnum++, addr += 4)\n-\tcache->saved_regs[regnum].addr = addr;\n+\tcache->saved_regs[regnum].set_addr (addr);\n \n       for (regnum = SPARC64_F32_REGNUM;\n \t   regnum <= SPARC64_F62_REGNUM; regnum++, addr += 8)\n-\tcache->saved_regs[regnum].addr = addr;\n+\tcache->saved_regs[regnum].set_addr (addr);\n     }\n \n   return cache;"
    },
    {
      "sha": "f08edd4d773d4acb9bbe9dc552cc22238deb451c",
      "filename": "gdb/sparc64-netbsd-tdep.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc64-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc64-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-netbsd-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -84,12 +84,12 @@ sparc64nbsd_pc_in_sigtramp (CORE_ADDR pc, const char *name)\n   return nbsd_pc_in_sigtramp (pc, name);\n }\n \n-struct trad_frame_saved_reg *\n+trad_frame_saved_reg *\n sparc64nbsd_sigcontext_saved_regs (CORE_ADDR sigcontext_addr,\n \t\t\t\t   struct frame_info *this_frame)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n   CORE_ADDR addr, sp;\n   int regnum, delta;\n \n@@ -100,34 +100,34 @@ sparc64nbsd_sigcontext_saved_regs (CORE_ADDR sigcontext_addr,\n      that the part of the signal trampoline that saves the state has\n      been executed.  */\n \n-  saved_regs[SPARC_SP_REGNUM].addr = sigcontext_addr + 8;\n-  saved_regs[SPARC64_PC_REGNUM].addr = sigcontext_addr + 16;\n-  saved_regs[SPARC64_NPC_REGNUM].addr = sigcontext_addr + 24;\n-  saved_regs[SPARC64_STATE_REGNUM].addr = sigcontext_addr + 32;\n-  saved_regs[SPARC_G1_REGNUM].addr = sigcontext_addr + 40;\n-  saved_regs[SPARC_O0_REGNUM].addr = sigcontext_addr + 48;\n+  saved_regs[SPARC_SP_REGNUM].set_addr (sigcontext_addr + 8);\n+  saved_regs[SPARC64_PC_REGNUM].set_addr (sigcontext_addr + 16);\n+  saved_regs[SPARC64_NPC_REGNUM].set_addr (sigcontext_addr + 24);\n+  saved_regs[SPARC64_STATE_REGNUM].set_addr (sigcontext_addr + 32);\n+  saved_regs[SPARC_G1_REGNUM].set_addr (sigcontext_addr + 40);\n+  saved_regs[SPARC_O0_REGNUM].set_addr (sigcontext_addr + 48);\n \n   /* The remaining `global' registers and %y are saved in the `local'\n      registers.  */\n   delta = SPARC_L0_REGNUM - SPARC_G0_REGNUM;\n   for (regnum = SPARC_G2_REGNUM; regnum <= SPARC_G7_REGNUM; regnum++)\n-    saved_regs[regnum].realreg = regnum + delta;\n-  saved_regs[SPARC64_Y_REGNUM].realreg = SPARC_L1_REGNUM;\n+    saved_regs[regnum].set_realreg (regnum + delta);\n+  saved_regs[SPARC64_Y_REGNUM].set_realreg (SPARC_L1_REGNUM);\n \n   /* The remaining `out' registers can be found in the current frame's\n      `in' registers.  */\n   delta = SPARC_I0_REGNUM - SPARC_O0_REGNUM;\n   for (regnum = SPARC_O1_REGNUM; regnum <= SPARC_O5_REGNUM; regnum++)\n-    saved_regs[regnum].realreg = regnum + delta;\n-  saved_regs[SPARC_O7_REGNUM].realreg = SPARC_I7_REGNUM;\n+    saved_regs[regnum].set_realreg (regnum + delta);\n+  saved_regs[SPARC_O7_REGNUM].set_realreg (SPARC_I7_REGNUM);\n \n   /* The `local' and `in' registers have been saved in the register\n      save area.  */\n-  addr = saved_regs[SPARC_SP_REGNUM].addr;\n+  addr = saved_regs[SPARC_SP_REGNUM].addr ();\n   sp = get_frame_memory_unsigned (this_frame, addr, 8);\n   for (regnum = SPARC_L0_REGNUM, addr = sp + BIAS;\n        regnum <= SPARC_I7_REGNUM; regnum++, addr += 8)\n-    saved_regs[regnum].addr = addr;\n+    saved_regs[regnum].set_addr (addr);\n \n   /* Handle StackGhost.  */\n   {\n@@ -137,7 +137,7 @@ sparc64nbsd_sigcontext_saved_regs (CORE_ADDR sigcontext_addr,\n       {\n \tULONGEST i7;\n \n-\taddr = saved_regs[SPARC_I7_REGNUM].addr;\n+\taddr = saved_regs[SPARC_I7_REGNUM].addr ();\n \ti7 = get_frame_memory_unsigned (this_frame, addr, 8);\n \ttrad_frame_set_value (saved_regs, SPARC_I7_REGNUM, i7 ^ wcookie);\n       }"
    },
    {
      "sha": "9e678d268ad7dde945eaa3954caae8ba07d92fed",
      "filename": "gdb/sparc64-obsd-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc64-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc64-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-obsd-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -249,13 +249,13 @@ sparc64obsd_trapframe_cache (struct frame_info *this_frame, void **this_cache)\n \n   cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);\n \n-  cache->saved_regs[SPARC64_STATE_REGNUM].addr = trapframe_addr;\n-  cache->saved_regs[SPARC64_PC_REGNUM].addr = trapframe_addr + 8;\n-  cache->saved_regs[SPARC64_NPC_REGNUM].addr = trapframe_addr + 16;\n+  cache->saved_regs[SPARC64_STATE_REGNUM].set_addr (trapframe_addr);\n+  cache->saved_regs[SPARC64_PC_REGNUM].set_addr (trapframe_addr + 8);\n+  cache->saved_regs[SPARC64_NPC_REGNUM].set_addr (trapframe_addr + 16);\n \n   for (regnum = SPARC_G0_REGNUM; regnum <= SPARC_I7_REGNUM; regnum++)\n-    cache->saved_regs[regnum].addr =\n-      trapframe_addr + 48 + (regnum - SPARC_G0_REGNUM) * 8;\n+    cache->saved_regs[regnum].set_addr (trapframe_addr + 48\n+\t\t\t\t\t+ (regnum - SPARC_G0_REGNUM) * 8);\n \n   return cache;\n }"
    },
    {
      "sha": "e664825027c8d340cfae146d5f80e09eb62e1c10",
      "filename": "gdb/sparc64-sol2-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc64-sol2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/sparc64-sol2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-sol2-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -121,17 +121,17 @@ sparc64_sol2_sigtramp_frame_cache (struct frame_info *this_frame,\n     (cache->copied_regs_mask & 0x04) ? SPARC_I2_REGNUM : SPARC_O2_REGNUM;\n   mcontext_addr = get_frame_register_unsigned (this_frame, regnum) + 64;\n \n-  cache->saved_regs[SPARC64_CCR_REGNUM].addr = mcontext_addr + 0 * 8;\n-  cache->saved_regs[SPARC64_PC_REGNUM].addr = mcontext_addr + 1 * 8;\n-  cache->saved_regs[SPARC64_NPC_REGNUM].addr = mcontext_addr + 2 * 8;\n-  cache->saved_regs[SPARC64_Y_REGNUM].addr = mcontext_addr + 3 * 8;\n-  cache->saved_regs[SPARC64_ASI_REGNUM].addr = mcontext_addr + 19 * 8; \n-  cache->saved_regs[SPARC64_FPRS_REGNUM].addr = mcontext_addr + 20 * 8;\n+  cache->saved_regs[SPARC64_CCR_REGNUM].set_addr (mcontext_addr + 0 * 8);\n+  cache->saved_regs[SPARC64_PC_REGNUM].set_addr (mcontext_addr + 1 * 8);\n+  cache->saved_regs[SPARC64_NPC_REGNUM].set_addr (mcontext_addr + 2 * 8);\n+  cache->saved_regs[SPARC64_Y_REGNUM].set_addr (mcontext_addr + 3 * 8);\n+  cache->saved_regs[SPARC64_ASI_REGNUM].set_addr (mcontext_addr + 19 * 8);\n+  cache->saved_regs[SPARC64_FPRS_REGNUM].set_addr (mcontext_addr + 20 * 8);\n \n   /* Since %g0 is always zero, keep the identity encoding.  */\n   for (regnum = SPARC_G1_REGNUM, addr = mcontext_addr + 4 * 8;\n        regnum <= SPARC_O7_REGNUM; regnum++, addr += 8)\n-    cache->saved_regs[regnum].addr = addr;\n+    cache->saved_regs[regnum].set_addr (addr);\n \n   if (get_frame_memory_unsigned (this_frame, mcontext_addr + 21 * 8, 8))\n     {\n@@ -143,11 +143,11 @@ sparc64_sol2_sigtramp_frame_cache (struct frame_info *this_frame,\n     {\n       CORE_ADDR sp;\n \n-      addr = cache->saved_regs[SPARC_SP_REGNUM].addr;\n+      addr = cache->saved_regs[SPARC_SP_REGNUM].addr ();\n       sp = get_frame_memory_unsigned (this_frame, addr, 8);\n       for (regnum = SPARC_L0_REGNUM, addr = sp + BIAS;\n \t   regnum <= SPARC_I7_REGNUM; regnum++, addr += 8)\n-\tcache->saved_regs[regnum].addr = addr;\n+\tcache->saved_regs[regnum].set_addr (addr);\n     }\n \n   return cache;"
    },
    {
      "sha": "0030fed028e8bffb1826de68f8a692c23719b7b9",
      "filename": "gdb/tilegx-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 10,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/tilegx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/tilegx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tilegx-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -50,7 +50,7 @@ struct tilegx_frame_cache\n   CORE_ADDR start_pc;\n \n   /* Table of saved registers.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Register state values used by analyze_prologue.  */\n@@ -464,8 +464,8 @@ tilegx_analyze_prologue (struct gdbarch* gdbarch,\n \t\t     saved_address.  The value of realreg is not\n \t\t     meaningful in this case but it must be >= 0.\n \t\t     See trad-frame.h.  */\n-\t\t  cache->saved_regs[saved_register].realreg = saved_register;\n-\t\t  cache->saved_regs[saved_register].addr = saved_address;\n+\t\t  cache->saved_regs[saved_register].set_realreg (saved_register);\n+\t\t  cache->saved_regs[saved_register].set_addr (saved_address);\n \t\t} \n \t      else if (cache\n \t\t       && (operands[0] == TILEGX_SP_REGNUM) \n@@ -488,12 +488,12 @@ tilegx_analyze_prologue (struct gdbarch* gdbarch,\n \t\t  /* Fix up the sign-extension.  */\n \t\t  if (opcode->mnemonic == TILEGX_OPC_ADDI)\n \t\t    op2_as_short = op2_as_char;\n-\t\t  prev_sp_value = (cache->saved_regs[hopefully_sp].addr\n+\t\t  prev_sp_value = (cache->saved_regs[hopefully_sp].addr ()\n \t\t\t\t   - op2_as_short);\n \n \t\t  new_reverse_frame[i].state = REVERSE_STATE_VALUE;\n \t\t  new_reverse_frame[i].value\n-\t\t    = cache->saved_regs[hopefully_sp].addr;\n+\t\t    = cache->saved_regs[hopefully_sp].addr ();\n \t\t  trad_frame_set_value (cache->saved_regs,\n \t\t\t\t\thopefully_sp, prev_sp_value);\n \t\t}\n@@ -717,17 +717,16 @@ tilegx_analyze_prologue (struct gdbarch* gdbarch,\n \t    {\n \t      unsigned saved_register = (unsigned) reverse_frame[i].value;\n \n-\t      cache->saved_regs[saved_register].realreg = i;\n-\t      cache->saved_regs[saved_register].addr = (LONGEST) -1;\n+\t      cache->saved_regs[saved_register].set_realreg (i);\n+\t      cache->saved_regs[saved_register].set_addr ((LONGEST) -1);\n \t    }\n \t}\n     }\n \n   if (lr_saved_on_stack_p)\n     {\n-      cache->saved_regs[TILEGX_LR_REGNUM].realreg = TILEGX_LR_REGNUM;\n-      cache->saved_regs[TILEGX_LR_REGNUM].addr =\n-\tcache->saved_regs[TILEGX_SP_REGNUM].addr;\n+      cache->saved_regs[TILEGX_LR_REGNUM].set_realreg (TILEGX_LR_REGNUM);\n+      cache->saved_regs[TILEGX_LR_REGNUM].set_addr (cache->saved_regs[TILEGX_SP_REGNUM].addr ());\n     }\n \n   return prolog_end;"
    },
    {
      "sha": "17375e83482c3286b294489d4daafb71291ed36d",
      "filename": "gdb/trad-frame.c",
      "status": "modified",
      "additions": 35,
      "deletions": 49,
      "changes": 84,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/trad-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/trad-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/trad-frame.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -30,7 +30,7 @@ struct trad_frame_cache\n {\n   struct frame_info *this_frame;\n   CORE_ADDR this_base;\n-  struct trad_frame_saved_reg *prev_regs;\n+  trad_frame_saved_reg *prev_regs;\n   struct frame_id this_id;\n };\n \n@@ -49,23 +49,22 @@ trad_frame_cache_zalloc (struct frame_info *this_frame)\n \n void\n trad_frame_reset_saved_regs (struct gdbarch *gdbarch,\n-\t\t\t     struct trad_frame_saved_reg *regs)\n+\t\t\t     trad_frame_saved_reg *regs)\n {\n   int numregs = gdbarch_num_cooked_regs (gdbarch);\n+\n   for (int regnum = 0; regnum < numregs; regnum++)\n-    {\n-      regs[regnum].realreg = regnum;\n-      regs[regnum].addr = -1;\n-      regs[regnum].data = nullptr;\n-    }\n+    regs[regnum].set_realreg (regnum);\n }\n \n-struct trad_frame_saved_reg *\n+trad_frame_saved_reg *\n trad_frame_alloc_saved_regs (struct gdbarch *gdbarch)\n {\n+  gdb_static_assert (std::is_trivially_default_constructible<trad_frame_saved_reg>::value);\n+\n   int numregs = gdbarch_num_cooked_regs (gdbarch);\n-  struct trad_frame_saved_reg *this_saved_regs\n-    = FRAME_OBSTACK_CALLOC (numregs, struct trad_frame_saved_reg);\n+  trad_frame_saved_reg *this_saved_regs\n+    = FRAME_OBSTACK_CALLOC (numregs, trad_frame_saved_reg);\n \n   trad_frame_reset_saved_regs (gdbarch, this_saved_regs);\n   return this_saved_regs;\n@@ -76,75 +75,65 @@ trad_frame_alloc_saved_regs (struct gdbarch *gdbarch)\n    non-optimized frames, the technique is reliable (just need to check\n    for all potential instruction sequences).  */\n \n-struct trad_frame_saved_reg *\n+trad_frame_saved_reg *\n trad_frame_alloc_saved_regs (struct frame_info *this_frame)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n \n   return trad_frame_alloc_saved_regs (gdbarch);\n }\n \n-enum { TF_REG_VALUE = -1, TF_REG_UNKNOWN = -2, TF_REG_VALUE_BYTES = -3 };\n-\n int\n-trad_frame_value_p (struct trad_frame_saved_reg this_saved_regs[], int regnum)\n+trad_frame_value_p (trad_frame_saved_reg this_saved_regs[], int regnum)\n {\n-  return (this_saved_regs[regnum].realreg == TF_REG_VALUE);\n+  return this_saved_regs[regnum].is_value ();\n }\n \n int\n-trad_frame_addr_p (struct trad_frame_saved_reg this_saved_regs[], int regnum)\n+trad_frame_addr_p (trad_frame_saved_reg this_saved_regs[], int regnum)\n {\n-  return (this_saved_regs[regnum].realreg >= 0\n-\t  && this_saved_regs[regnum].addr != -1);\n+  return this_saved_regs[regnum].is_addr ();\n }\n \n int\n-trad_frame_realreg_p (struct trad_frame_saved_reg this_saved_regs[],\n+trad_frame_realreg_p (trad_frame_saved_reg this_saved_regs[],\n \t\t      int regnum)\n {\n-  return (this_saved_regs[regnum].realreg >= 0\n-\t  && this_saved_regs[regnum].addr == -1);\n+  return this_saved_regs[regnum].is_realreg ();\n }\n \n /* See trad-frame.h.  */\n \n bool\n-trad_frame_value_bytes_p (struct trad_frame_saved_reg this_saved_regs[],\n+trad_frame_value_bytes_p (trad_frame_saved_reg this_saved_regs[],\n \t\t\t  int regnum)\n {\n-  return (this_saved_regs[regnum].realreg == TF_REG_VALUE_BYTES\n-\t  && this_saved_regs[regnum].data != nullptr);\n+  return this_saved_regs[regnum].is_value_bytes ();\n }\n \n void\n-trad_frame_set_value (struct trad_frame_saved_reg this_saved_regs[],\n+trad_frame_set_value (trad_frame_saved_reg this_saved_regs[],\n \t\t      int regnum, LONGEST val)\n {\n-  /* Make the REALREG invalid, indicating that the ADDR contains the\n-     register's value.  */\n-  this_saved_regs[regnum].realreg = TF_REG_VALUE;\n-  this_saved_regs[regnum].addr = val;\n+  this_saved_regs[regnum].set_value (val);\n }\n \n /* See trad-frame.h.  */\n \n void\n-trad_frame_set_realreg (struct trad_frame_saved_reg this_saved_regs[],\n+trad_frame_set_realreg (trad_frame_saved_reg this_saved_regs[],\n \t\t\tint regnum, int realreg)\n {\n-  this_saved_regs[regnum].realreg = realreg;\n-  this_saved_regs[regnum].addr = -1;\n+  this_saved_regs[regnum].set_realreg (realreg);\n }\n \n /* See trad-frame.h.  */\n \n void\n-trad_frame_set_addr (struct trad_frame_saved_reg this_saved_regs[],\n+trad_frame_set_addr (trad_frame_saved_reg this_saved_regs[],\n \t\t     int regnum, CORE_ADDR addr)\n {\n-  this_saved_regs[regnum].realreg = regnum;\n-  this_saved_regs[regnum].addr = addr;\n+  this_saved_regs[regnum].set_addr (addr);\n }\n \n void\n@@ -227,26 +216,23 @@ trad_frame_set_reg_regmap (struct trad_frame_cache *this_trad_cache,\n }\n \n void\n-trad_frame_set_unknown (struct trad_frame_saved_reg this_saved_regs[],\n+trad_frame_set_unknown (trad_frame_saved_reg this_saved_regs[],\n \t\t\tint regnum)\n {\n-  /* Make the REALREG invalid, indicating that the value is not known.  */\n-  this_saved_regs[regnum].realreg = TF_REG_UNKNOWN;\n-  this_saved_regs[regnum].addr = -1;\n+  this_saved_regs[regnum].set_unknown ();\n }\n \n /* See trad-frame.h.  */\n \n void\n-trad_frame_set_value_bytes (struct trad_frame_saved_reg this_saved_regs[],\n+trad_frame_set_value_bytes (trad_frame_saved_reg this_saved_regs[],\n \t\t\t    int regnum, const gdb_byte *bytes,\n \t\t\t    size_t size)\n {\n-  this_saved_regs[regnum].realreg = TF_REG_VALUE_BYTES;\n-\n   /* Allocate the space and copy the data bytes.  */\n-  this_saved_regs[regnum].data = FRAME_OBSTACK_CALLOC (size, gdb_byte);\n-  memcpy (this_saved_regs[regnum].data, bytes, size);\n+  gdb_byte *data = FRAME_OBSTACK_CALLOC (size, gdb_byte);\n+  memcpy (data, bytes, size);\n+  this_saved_regs[regnum].set_value_bytes (data);\n }\n \n /* See trad-frame.h.  */\n@@ -266,24 +252,24 @@ trad_frame_set_reg_value_bytes (struct trad_frame_cache *this_trad_cache,\n \n struct value *\n trad_frame_get_prev_register (struct frame_info *this_frame,\n-\t\t\t      struct trad_frame_saved_reg this_saved_regs[],\n+\t\t\t      trad_frame_saved_reg this_saved_regs[],\n \t\t\t      int regnum)\n {\n   if (trad_frame_addr_p (this_saved_regs, regnum))\n     /* The register was saved in memory.  */\n     return frame_unwind_got_memory (this_frame, regnum,\n-\t\t\t\t    this_saved_regs[regnum].addr);\n+\t\t\t\t    this_saved_regs[regnum].addr ());\n   else if (trad_frame_realreg_p (this_saved_regs, regnum))\n     return frame_unwind_got_register (this_frame, regnum,\n-\t\t\t\t      this_saved_regs[regnum].realreg);\n+\t\t\t\t      this_saved_regs[regnum].realreg ());\n   else if (trad_frame_value_p (this_saved_regs, regnum))\n     /* The register's value is available.  */\n     return frame_unwind_got_constant (this_frame, regnum,\n-\t\t\t\t      this_saved_regs[regnum].addr);\n+\t\t\t\t      this_saved_regs[regnum].value ());\n   else if (trad_frame_value_bytes_p (this_saved_regs, regnum))\n     /* The register's value is available as a sequence of bytes.  */\n     return frame_unwind_got_bytes (this_frame, regnum,\n-\t\t\t\t   this_saved_regs[regnum].data);\n+\t\t\t\t   this_saved_regs[regnum].value_bytes ());\n   else\n     return frame_unwind_got_optimized (this_frame, regnum);\n }"
    },
    {
      "sha": "cdc937cfa29db3412007d636673b298d75c9c68f",
      "filename": "gdb/trad-frame.h",
      "status": "modified",
      "additions": 131,
      "deletions": 42,
      "changes": 173,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/trad-frame.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/trad-frame.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/trad-frame.h?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -62,88 +62,177 @@ struct value *trad_frame_get_register (struct trad_frame_cache *this_trad_cache,\n \t\t\t\t       struct frame_info *this_frame,\n \t\t\t\t       int regnum);\n \n-/* A traditional saved regs table, indexed by REGNUM, encoding where\n-   the value of REGNUM for the previous frame can be found in this\n-   frame.\n-\n-   The table is initialized with an identity encoding (ADDR == -1,\n-   REALREG == REGNUM) indicating that the value of REGNUM in the\n-   previous frame can be found in register REGNUM (== REALREG) in this\n-   frame.\n-\n-   The initial encoding can then be changed:\n-\n-   Modify ADDR (REALREG >= 0, ADDR != -1) to indicate that the value\n-   of register REGNUM in the previous frame can be found in memory at\n-   ADDR in this frame (addr_p, !realreg_p, !value_p).\n-\n-   Modify REALREG (REALREG >= 0, ADDR == -1) to indicate that the\n-   value of register REGNUM in the previous frame is found in register\n-   REALREG in this frame (!addr_p, realreg_p, !value_p).\n-\n-   Call trad_frame_set_value (REALREG == -1) to indicate that the\n-   value of register REGNUM in the previous frame is found in ADDR\n-   (!addr_p, !realreg_p, value_p).\n+/* Describes the kind of encoding a stored register has.  */\n+enum class trad_frame_saved_reg_kind\n+{\n+  /* Register value is unknown.  */\n+  UNKNOWN = 0,\n+  /* Register value is a constant.  */\n+  VALUE,\n+  /* Register value is in another register.  */\n+  REALREG,\n+  /* Register value is at an address.  */\n+  ADDR,\n+  /* Register value is a sequence of bytes.  */\n+  VALUE_BYTES\n+};\n \n-   Call trad_frame_set_unknown (REALREG == -2) to indicate that the\n-   register's value is not known.  */\n+/* A struct that describes a saved register in a frame.  */\n \n struct trad_frame_saved_reg\n {\n-  LONGEST addr; /* A CORE_ADDR fits in a longest.  */\n-  int realreg;\n-  /* Register data (for values that don't fit in ADDR).  */\n-  gdb_byte *data;\n+  /* Setters */\n+\n+  /* Encode that the saved register's value is constant VAL in the\n+     trad-frame.  */\n+  void set_value (LONGEST val)\n+  {\n+    m_kind = trad_frame_saved_reg_kind::VALUE;\n+    m_reg.value = val;\n+  }\n+\n+  /* Encode that the saved register's value is stored in register REALREG.  */\n+  void set_realreg (int realreg)\n+  {\n+    m_kind = trad_frame_saved_reg_kind::REALREG;\n+    m_reg.realreg = realreg;\n+  }\n+\n+  /* Encode that the saved register's value is stored in memory at ADDR.  */\n+  void set_addr (LONGEST addr)\n+  {\n+    m_kind = trad_frame_saved_reg_kind::ADDR;\n+    m_reg.addr = addr;\n+  }\n+\n+  /* Encode that the saved register's value is unknown.  */\n+  void set_unknown ()\n+  {\n+    m_kind = trad_frame_saved_reg_kind::UNKNOWN;\n+  }\n+\n+  /* Encode that the saved register's value is stored as a sequence of bytes.\n+     This is useful when the value is larger than what primitive types\n+     can hold.  */\n+  void set_value_bytes (const gdb_byte *value_bytes)\n+  {\n+    m_kind = trad_frame_saved_reg_kind::VALUE_BYTES;\n+    m_reg.value_bytes = value_bytes;\n+  }\n+\n+  /* Getters */\n+\n+  LONGEST value () const\n+  {\n+    gdb_assert (m_kind == trad_frame_saved_reg_kind::VALUE);\n+    return m_reg.value;\n+  }\n+\n+  int realreg () const\n+  {\n+    gdb_assert (m_kind == trad_frame_saved_reg_kind::REALREG);\n+    return m_reg.realreg;\n+  }\n+\n+  LONGEST addr () const\n+  {\n+    gdb_assert (m_kind == trad_frame_saved_reg_kind::ADDR);\n+    return m_reg.addr;\n+  }\n+\n+  const gdb_byte *value_bytes () const\n+  {\n+    gdb_assert (m_kind == trad_frame_saved_reg_kind::VALUE_BYTES);\n+    return m_reg.value_bytes;\n+  }\n+\n+  /* Convenience functions, return true if the register has been\n+     encoded as specified.  Return false otherwise.  */\n+  bool is_value () const\n+  {\n+    return m_kind == trad_frame_saved_reg_kind::VALUE;\n+  }\n+\n+  bool is_realreg () const\n+  {\n+    return m_kind == trad_frame_saved_reg_kind::REALREG;\n+  }\n+\n+  bool is_addr () const\n+  {\n+    return m_kind == trad_frame_saved_reg_kind::ADDR;\n+  }\n+\n+  bool is_unknown () const\n+  {\n+    return m_kind == trad_frame_saved_reg_kind::UNKNOWN;\n+  }\n+\n+  bool is_value_bytes () const\n+  {\n+    return m_kind == trad_frame_saved_reg_kind::VALUE_BYTES;\n+  }\n+\n+private:\n+\n+  trad_frame_saved_reg_kind m_kind;\n+\n+  union {\n+    LONGEST value;\n+    int realreg;\n+    LONGEST addr;\n+    const gdb_byte *value_bytes;\n+  } m_reg;\n };\n \n /* Encode REGNUM value in the trad-frame.  */\n-void trad_frame_set_value (struct trad_frame_saved_reg this_saved_regs[],\n+void trad_frame_set_value (trad_frame_saved_reg this_saved_regs[],\n \t\t\t   int regnum, LONGEST val);\n \n /* Encode REGNUM is in REALREG in the trad-frame.  */\n-void trad_frame_set_realreg (struct trad_frame_saved_reg this_saved_regs[],\n+void trad_frame_set_realreg (trad_frame_saved_reg this_saved_regs[],\n \t\t\t     int regnum, int realreg);\n \n /* Encode REGNUM is at address ADDR in the trad-frame.  */\n-void trad_frame_set_addr (struct trad_frame_saved_reg this_trad_cache[],\n+void trad_frame_set_addr (trad_frame_saved_reg this_trad_cache[],\n \t\t\t  int regnum, CORE_ADDR addr);\n \n /* Mark REGNUM as unknown.  */\n-void trad_frame_set_unknown (struct trad_frame_saved_reg this_saved_regs[],\n+void trad_frame_set_unknown (trad_frame_saved_reg this_saved_regs[],\n \t\t\t     int regnum);\n \n /* Encode REGNUM value in the trad-frame as a sequence of bytes.  This is\n    useful when the value is larger than what primitive types can hold.  */\n-void trad_frame_set_value_bytes (struct trad_frame_saved_reg this_saved_regs[],\n+void trad_frame_set_value_bytes (trad_frame_saved_reg this_saved_regs[],\n \t\t\t\t int regnum, const gdb_byte *bytes,\n \t\t\t\t size_t size);\n \n /* Convenience functions, return non-zero if the register has been\n    encoded as specified.  */\n-int trad_frame_value_p (struct trad_frame_saved_reg this_saved_regs[],\n+int trad_frame_value_p (trad_frame_saved_reg this_saved_regs[],\n \t\t\tint regnum);\n-int trad_frame_addr_p (struct trad_frame_saved_reg this_saved_regs[],\n+int trad_frame_addr_p (trad_frame_saved_reg this_saved_regs[],\n \t\t       int regnum);\n-int trad_frame_realreg_p (struct trad_frame_saved_reg this_saved_regs[],\n+int trad_frame_realreg_p (trad_frame_saved_reg this_saved_regs[],\n \t\t\t  int regnum);\n \n /* Return TRUE if REGNUM is stored as a sequence of bytes, and FALSE\n    otherwise.  */\n-bool trad_frame_value_bytes_p (struct trad_frame_saved_reg this_saved_regs[],\n+bool trad_frame_value_bytes_p (trad_frame_saved_reg this_saved_regs[],\n \t\t\t      int regnum);\n \n-/* Reset the save regs cache, setting register values to -1.  */\n+/* Reset the saved regs cache, setting register values to -1.  */\n void trad_frame_reset_saved_regs (struct gdbarch *gdbarch,\n-\t\t\t\t  struct trad_frame_saved_reg *regs);\n+\t\t\t\t  trad_frame_saved_reg *regs);\n \n /* Return a freshly allocated (and initialized) trad_frame array.  */\n-struct trad_frame_saved_reg *trad_frame_alloc_saved_regs (struct frame_info *);\n-struct trad_frame_saved_reg *trad_frame_alloc_saved_regs (struct gdbarch *);\n+trad_frame_saved_reg *trad_frame_alloc_saved_regs (struct frame_info *);\n+trad_frame_saved_reg *trad_frame_alloc_saved_regs (struct gdbarch *);\n \n /* Given the trad_frame info, return the location of the specified\n    register.  */\n struct value *trad_frame_get_prev_register (struct frame_info *this_frame,\n-\t\t\t\t\t    struct trad_frame_saved_reg this_saved_regs[],\n+\t\t\t\t\t    trad_frame_saved_reg this_saved_regs[],\n \t\t\t\t\t    int regnum);\n \n #endif"
    },
    {
      "sha": "8bd74eaa3b0885bdcc0f67542102ca97ca86e60b",
      "filename": "gdb/v850-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/v850-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/v850-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/v850-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -286,7 +286,7 @@ struct v850_frame_cache\n   int uses_fp;\n   \n   /* Saved registers.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n /* Info gleaned from scanning a function's prologue.  */\n@@ -933,7 +933,7 @@ v850_analyze_prologue (struct gdbarch *gdbarch,\n   for (pifsr_tmp = pifsrs; pifsr_tmp != pifsr; pifsr_tmp++)\n     {\n       pifsr_tmp->offset -= pi->sp_offset - pifsr_tmp->cur_frameoffset;\n-      pi->saved_regs[pifsr_tmp->reg].addr = pifsr_tmp->offset;\n+      pi->saved_regs[pifsr_tmp->reg].set_addr (pifsr_tmp->offset);\n     }\n \n   return current_pc;\n@@ -1280,7 +1280,8 @@ v850_frame_cache (struct frame_info *this_frame, void **this_cache)\n      instead of offsets.  */\n   for (i = 0; i < gdbarch_num_regs (gdbarch); i++)\n     if (trad_frame_addr_p (cache->saved_regs, i))\n-      cache->saved_regs[i].addr += cache->base;\n+      cache->saved_regs[i].set_addr (cache->saved_regs[i].addr ()\n+\t\t\t\t     + cache->base);\n \n   /* The call instruction moves the caller's PC in the callee's LP.\n      Since this is an unwind, do the reverse.  Copy the location of LP\n@@ -1314,7 +1315,7 @@ v850_frame_this_id (struct frame_info *this_frame, void **this_cache,\n   if (cache->base == 0)\n     return;\n \n-  *this_id = frame_id_build (cache->saved_regs[E_SP_REGNUM].addr, cache->pc);\n+  *this_id = frame_id_build (cache->saved_regs[E_SP_REGNUM].addr (), cache->pc);\n }\n \n static const struct frame_unwind v850_frame_unwind = {"
    },
    {
      "sha": "2e707a64764711b59c6b3024388c51e4f86a9b84",
      "filename": "gdb/vax-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/vax-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/098caef485a4ece6096e6cdbb4cd9726e4a13386/gdb/vax-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/vax-tdep.c?ref=098caef485a4ece6096e6cdbb4cd9726e4a13386",
      "patch": "@@ -301,7 +301,7 @@ struct vax_frame_cache\n   CORE_ADDR base;\n \n   /* Table of saved registers.  */\n-  struct trad_frame_saved_reg *saved_regs;\n+  trad_frame_saved_reg *saved_regs;\n };\n \n static struct vax_frame_cache *\n@@ -329,10 +329,10 @@ vax_frame_cache (struct frame_info *this_frame, void **this_cache)\n   mask = get_frame_memory_unsigned (this_frame, cache->base + 4, 4) >> 16;\n \n   /* These are always saved.  */\n-  cache->saved_regs[VAX_PC_REGNUM].addr = cache->base + 16;\n-  cache->saved_regs[VAX_FP_REGNUM].addr = cache->base + 12;\n-  cache->saved_regs[VAX_AP_REGNUM].addr = cache->base + 8;\n-  cache->saved_regs[VAX_PS_REGNUM].addr = cache->base + 4;\n+  cache->saved_regs[VAX_PC_REGNUM].set_addr (cache->base + 16);\n+  cache->saved_regs[VAX_FP_REGNUM].set_addr (cache->base + 12);\n+  cache->saved_regs[VAX_AP_REGNUM].set_addr (cache->base + 8);\n+  cache->saved_regs[VAX_PS_REGNUM].set_addr (cache->base + 4);\n \n   /* Scan the register save mask and record the location of the saved\n      registers.  */\n@@ -341,7 +341,7 @@ vax_frame_cache (struct frame_info *this_frame, void **this_cache)\n     {\n       if (mask & (1 << regnum))\n \t{\n-\t  cache->saved_regs[regnum].addr = addr;\n+\t  cache->saved_regs[regnum].set_addr (addr);\n \t  addr += 4;\n \t}\n     }"
    }
  ]
}