{
  "sha": "fd3619828e94a24a92cddec42cbc0ab33352eeb4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmQzNjE5ODI4ZTk0YTI0YTkyY2RkZWM0MmNiYzBhYjMzMzUyZWViNA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-16T10:55:17Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-19T00:10:13Z"
    },
    "message": "bfd_section_* macros\n\nThis large patch removes the unnecessary bfd parameter from various\nbfd section macros and functions.  The bfd is hardly ever used and if\nneeded for the bfd_set_section_* or bfd_rename_section functions can\nbe found via section->owner except for the com, und, abs, and ind\nstd_section special sections.  Those sections shouldn't be modified\nanyway.\n\nThe patch also removes various bfd_get_section_<field> macros,\nreplacing their use with bfd_section_<field>, and adds\nbfd_set_section_lma.  I've also fixed a minor bug in gas where\ncompressed section renaming was done directly rather than calling\nbfd_rename_section.  This would have broken bfd_get_section_by_name\nand similar functions, but that hardly mattered at such a late stage\nin gas processing.\n\nbfd/\n\t* bfd-in.h (bfd_get_section_name, bfd_get_section_vma),\n\t(bfd_get_section_lma, bfd_get_section_alignment),\n\t(bfd_get_section_size, bfd_get_section_flags),\n\t(bfd_get_section_userdata): Delete.\n\t(bfd_section_name, bfd_section_size, bfd_section_vma),\n\t(bfd_section_lma, bfd_section_alignment): Lose bfd parameter.\n\t(bfd_section_flags, bfd_section_userdata): New.\n\t(bfd_is_com_section): Rename parameter.\n\t* section.c (bfd_set_section_userdata, bfd_set_section_vma),\n\t(bfd_set_section_alignment, bfd_set_section_flags, bfd_rename_section),\n\t(bfd_set_section_size): Delete bfd parameter, rename section parameter.\n\t(bfd_set_section_lma): New.\n\t* bfd-in2.h: Regenerate.\n\t* mach-o.c (bfd_mach_o_init_section_from_mach_o): Delete bfd param,\n\tupdate callers.\n\t* aoutx.h, * bfd.c, * coff-alpha.c, * coff-arm.c, * coff-mips.c,\n\t* coff64-rs6000.c, * coffcode.h, * coffgen.c, * cofflink.c,\n\t* compress.c, * ecoff.c, * elf-eh-frame.c, * elf-hppa.h,\n\t* elf-ifunc.c, * elf-m10200.c, * elf-m10300.c, * elf-properties.c,\n\t* elf-s390-common.c, * elf-vxworks.c, * elf.c, * elf32-arc.c,\n\t* elf32-arm.c, * elf32-avr.c, * elf32-bfin.c, * elf32-cr16.c,\n\t* elf32-cr16c.c, * elf32-cris.c, * elf32-crx.c, * elf32-csky.c,\n\t* elf32-d10v.c, * elf32-epiphany.c, * elf32-fr30.c, * elf32-frv.c,\n\t* elf32-ft32.c, * elf32-h8300.c, * elf32-hppa.c, * elf32-i386.c,\n\t* elf32-ip2k.c, * elf32-iq2000.c, * elf32-lm32.c, * elf32-m32c.c,\n\t* elf32-m32r.c, * elf32-m68hc1x.c, * elf32-m68k.c, * elf32-mcore.c,\n\t* elf32-mep.c, * elf32-metag.c, * elf32-microblaze.c,\n\t* elf32-moxie.c, * elf32-msp430.c, * elf32-mt.c, * elf32-nds32.c,\n\t* elf32-nios2.c, * elf32-or1k.c, * elf32-ppc.c, * elf32-pru.c,\n\t* elf32-rl78.c, * elf32-rx.c, * elf32-s390.c, * elf32-score.c,\n\t* elf32-score7.c, * elf32-sh.c, * elf32-spu.c, * elf32-tic6x.c,\n\t* elf32-tilepro.c, * elf32-v850.c, * elf32-vax.c, * elf32-visium.c,\n\t* elf32-xstormy16.c, * elf32-xtensa.c, * elf64-alpha.c,\n\t* elf64-bpf.c, * elf64-hppa.c, * elf64-ia64-vms.c, * elf64-mmix.c,\n\t* elf64-ppc.c, * elf64-s390.c, * elf64-sparc.c, * elf64-x86-64.c,\n\t* elflink.c, * elfnn-aarch64.c, * elfnn-ia64.c, * elfnn-riscv.c,\n\t* elfxx-aarch64.c, * elfxx-mips.c, * elfxx-sparc.c,\n\t* elfxx-tilegx.c, * elfxx-x86.c, * i386msdos.c, * linker.c,\n\t* mach-o.c, * mmo.c, * opncls.c, * pdp11.c, * pei-x86_64.c,\n\t* peicode.h, * reloc.c, * section.c, * syms.c, * vms-alpha.c,\n\t* xcofflink.c: Update throughout for bfd section macro and function\n\tchanges.\nbinutils/\n\t* addr2line.c, * bucomm.c, * coffgrok.c, * dlltool.c, * nm.c,\n\t* objcopy.c, * objdump.c, * od-elf32_avr.c, * od-macho.c,\n\t* od-xcoff.c, * prdbg.c, * rdcoff.c, * rddbg.c, * rescoff.c,\n\t* resres.c, * size.c, * srconv.c, * strings.c, * windmc.c: Update\n\tthroughout for bfd section macro and function changes.\ngas/\n\t* as.c, * as.h, * dw2gencfi.c, * dwarf2dbg.c, * ecoff.c,\n\t* read.c, * stabs.c, * subsegs.c, * subsegs.h, * write.c,\n\t* config/obj-coff-seh.c, * config/obj-coff.c, * config/obj-ecoff.c,\n\t* config/obj-elf.c, * config/obj-macho.c, * config/obj-som.c,\n\t* config/tc-aarch64.c, * config/tc-alpha.c, * config/tc-arc.c,\n\t* config/tc-arm.c, * config/tc-avr.c, * config/tc-bfin.c,\n\t* config/tc-bpf.c, * config/tc-d10v.c, * config/tc-d30v.c,\n\t* config/tc-epiphany.c, * config/tc-fr30.c, * config/tc-frv.c,\n\t* config/tc-h8300.c, * config/tc-hppa.c, * config/tc-i386.c,\n\t* config/tc-ia64.c, * config/tc-ip2k.c, * config/tc-iq2000.c,\n\t* config/tc-lm32.c, * config/tc-m32c.c, * config/tc-m32r.c,\n\t* config/tc-m68hc11.c, * config/tc-mep.c, * config/tc-microblaze.c,\n\t* config/tc-mips.c, * config/tc-mmix.c, * config/tc-mn10200.c,\n\t* config/tc-mn10300.c, * config/tc-msp430.c, * config/tc-mt.c,\n\t* config/tc-nds32.c, * config/tc-or1k.c, * config/tc-ppc.c,\n\t* config/tc-pru.c, * config/tc-rl78.c, * config/tc-rx.c,\n\t* config/tc-s12z.c, * config/tc-s390.c, * config/tc-score.c,\n\t* config/tc-score7.c, * config/tc-sh.c, * config/tc-sparc.c,\n\t* config/tc-spu.c, * config/tc-tic4x.c, * config/tc-tic54x.c,\n\t* config/tc-tic6x.c, * config/tc-tilegx.c, * config/tc-tilepro.c,\n\t* config/tc-v850.c, * config/tc-visium.c, * config/tc-wasm32.c,\n\t* config/tc-xc16x.c, * config/tc-xgate.c, * config/tc-xstormy16.c,\n\t* config/tc-xtensa.c, * config/tc-z8k.c: Update throughout for\n\tbfd section macro and function changes.\n\t* write.c (compress_debug): Use bfd_rename_section.\ngdb/\n\t* aarch64-linux-tdep.c, * arm-tdep.c, * auto-load.c,\n\t* coff-pe-read.c, * coffread.c, * corelow.c, * dbxread.c,\n\t* dicos-tdep.c, * dwarf2-frame.c, * dwarf2read.c, * elfread.c,\n\t* exec.c, * fbsd-tdep.c, * gcore.c, * gdb_bfd.c, * gdb_bfd.h,\n\t* hppa-tdep.c, * i386-cygwin-tdep.c, * i386-fbsd-tdep.c,\n\t* i386-linux-tdep.c, * jit.c, * linux-tdep.c, * machoread.c,\n\t* maint.c, * mdebugread.c, * minidebug.c, * mips-linux-tdep.c,\n\t* mips-sde-tdep.c, * mips-tdep.c, * mipsread.c, * nto-tdep.c,\n\t* objfiles.c, * objfiles.h, * osabi.c, * ppc-linux-tdep.c,\n\t* ppc64-tdep.c, * record-btrace.c, * record-full.c, * remote.c,\n\t* rs6000-aix-tdep.c, * rs6000-tdep.c, * s390-linux-tdep.c,\n\t* s390-tdep.c, * solib-aix.c, * solib-dsbt.c, * solib-frv.c,\n\t* solib-spu.c, * solib-svr4.c, * solib-target.c,\n\t* spu-linux-nat.c, * spu-tdep.c, * symfile-mem.c, * symfile.c,\n\t* symmisc.c, * symtab.c, * target.c, * windows-nat.c,\n\t* xcoffread.c, * cli/cli-dump.c, * compile/compile-object-load.c,\n\t* mi/mi-interp.c: Update throughout for bfd section macro and\n\tfunction changes.\n\t* gcore (gcore_create_callback): Use bfd_set_section_lma.\n\t* spu-tdep.c (spu_overlay_new_objfile): Likewise.\ngprof/\n\t* corefile.c, * symtab.c: Update throughout for bfd section\n\tmacro and function changes.\nld/\n\t* ldcref.c, * ldctor.c, * ldelf.c, * ldlang.c, * pe-dll.c,\n\t* emultempl/aarch64elf.em, * emultempl/aix.em,\n\t* emultempl/armcoff.em, * emultempl/armelf.em,\n\t* emultempl/cr16elf.em, * emultempl/cskyelf.em,\n\t* emultempl/m68hc1xelf.em, * emultempl/m68kelf.em,\n\t* emultempl/mipself.em, * emultempl/mmix-elfnmmo.em,\n\t* emultempl/mmo.em, * emultempl/msp430.em,\n\t* emultempl/nios2elf.em, * emultempl/pe.em, * emultempl/pep.em,\n\t* emultempl/ppc64elf.em, * emultempl/xtensaelf.em: Update\n\tthroughout for bfd section macro and function changes.\nlibctf/\n\t* ctf-open-bfd.c: Update throughout for bfd section macro changes.\nopcodes/\n\t* arc-ext.c: Update throughout for bfd section macro changes.\nsim/\n\t* common/sim-load.c, * common/sim-utils.c, * cris/sim-if.c,\n\t* erc32/func.c, * lm32/sim-if.c, * m32c/load.c, * m32c/trace.c,\n\t* m68hc11/interp.c, * ppc/hw_htab.c, * ppc/hw_init.c,\n\t* rl78/load.c, * rl78/trace.c, * rx/gdb-if.c, * rx/load.c,\n\t* rx/trace.c: Update throughout for bfd section macro changes.",
    "tree": {
      "sha": "496b4a1d9bc015f6d1177758a811afa3f6e6895e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/496b4a1d9bc015f6d1177758a811afa3f6e6895e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fd3619828e94a24a92cddec42cbc0ab33352eeb4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd3619828e94a24a92cddec42cbc0ab33352eeb4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fd3619828e94a24a92cddec42cbc0ab33352eeb4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd3619828e94a24a92cddec42cbc0ab33352eeb4/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5dfda3562a69686c43aad4fb0269cc9d5ec010d5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5dfda3562a69686c43aad4fb0269cc9d5ec010d5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5dfda3562a69686c43aad4fb0269cc9d5ec010d5"
    }
  ],
  "stats": {
    "total": 3913,
    "additions": 1917,
    "deletions": 1996
  },
  "files": [
    {
      "sha": "8fff6a67523d9920b4c2cb3d21f2fd7796ecb4da",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 45,
      "deletions": 0,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,48 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* bfd-in.h (bfd_get_section_name, bfd_get_section_vma),\n+\t(bfd_get_section_lma, bfd_get_section_alignment),\n+\t(bfd_get_section_size, bfd_get_section_flags),\n+\t(bfd_get_section_userdata): Delete.\n+\t(bfd_section_name, bfd_section_size, bfd_section_vma),\n+\t(bfd_section_lma, bfd_section_alignment): Lose bfd parameter.\n+\t(bfd_section_flags, bfd_section_userdata): New.\n+\t(bfd_is_com_section): Rename parameter.\n+\t* section.c (bfd_set_section_userdata, bfd_set_section_vma),\n+\t(bfd_set_section_alignment, bfd_set_section_flags, bfd_rename_section),\n+\t(bfd_set_section_size): Delete bfd parameter, rename section parameter.\n+\t(bfd_set_section_lma): New.\n+\t* bfd-in2.h: Regenerate.\n+\t* mach-o.c (bfd_mach_o_init_section_from_mach_o): Delete bfd param,\n+\tupdate callers.\n+\t* aoutx.h, * bfd.c, * coff-alpha.c, * coff-arm.c, * coff-mips.c,\n+\t* coff64-rs6000.c, * coffcode.h, * coffgen.c, * cofflink.c,\n+\t* compress.c, * ecoff.c, * elf-eh-frame.c, * elf-hppa.h,\n+\t* elf-ifunc.c, * elf-m10200.c, * elf-m10300.c, * elf-properties.c,\n+\t* elf-s390-common.c, * elf-vxworks.c, * elf.c, * elf32-arc.c,\n+\t* elf32-arm.c, * elf32-avr.c, * elf32-bfin.c, * elf32-cr16.c,\n+\t* elf32-cr16c.c, * elf32-cris.c, * elf32-crx.c, * elf32-csky.c,\n+\t* elf32-d10v.c, * elf32-epiphany.c, * elf32-fr30.c, * elf32-frv.c,\n+\t* elf32-ft32.c, * elf32-h8300.c, * elf32-hppa.c, * elf32-i386.c,\n+\t* elf32-ip2k.c, * elf32-iq2000.c, * elf32-lm32.c, * elf32-m32c.c,\n+\t* elf32-m32r.c, * elf32-m68hc1x.c, * elf32-m68k.c, * elf32-mcore.c,\n+\t* elf32-mep.c, * elf32-metag.c, * elf32-microblaze.c,\n+\t* elf32-moxie.c, * elf32-msp430.c, * elf32-mt.c, * elf32-nds32.c,\n+\t* elf32-nios2.c, * elf32-or1k.c, * elf32-ppc.c, * elf32-pru.c,\n+\t* elf32-rl78.c, * elf32-rx.c, * elf32-s390.c, * elf32-score.c,\n+\t* elf32-score7.c, * elf32-sh.c, * elf32-spu.c, * elf32-tic6x.c,\n+\t* elf32-tilepro.c, * elf32-v850.c, * elf32-vax.c, * elf32-visium.c,\n+\t* elf32-xstormy16.c, * elf32-xtensa.c, * elf64-alpha.c,\n+\t* elf64-bpf.c, * elf64-hppa.c, * elf64-ia64-vms.c, * elf64-mmix.c,\n+\t* elf64-ppc.c, * elf64-s390.c, * elf64-sparc.c, * elf64-x86-64.c,\n+\t* elflink.c, * elfnn-aarch64.c, * elfnn-ia64.c, * elfnn-riscv.c,\n+\t* elfxx-aarch64.c, * elfxx-mips.c, * elfxx-sparc.c,\n+\t* elfxx-tilegx.c, * elfxx-x86.c, * i386msdos.c, * linker.c,\n+\t* mach-o.c, * mmo.c, * opncls.c, * pdp11.c, * pei-x86_64.c,\n+\t* peicode.h, * reloc.c, * section.c, * syms.c, * vms-alpha.c,\n+\t* xcofflink.c: Update throughout for bfd section macro and function\n+\tchanges.\n+\n 2019-09-18  Alan Modra  <amodra@gmail.com>\n \n \t* bfd-in.h (bfd_asymbol_section): Rename from bfd_get_section."
    },
    {
      "sha": "8923ca7b3cbfb6190ef89021935b887979a71ecf",
      "filename": "bfd/aoutx.h",
      "status": "modified",
      "additions": 14,
      "deletions": 16,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/aoutx.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/aoutx.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/aoutx.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3108,18 +3108,18 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \t  break;\n \tcase N_TEXT | N_EXT:\n \t  section = obj_textsec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \tcase N_DATA | N_EXT:\n \tcase N_SETV | N_EXT:\n \t  /* Treat N_SETV symbols as N_DATA symbol; see comment in\n \t     translate_from_native_sym_flags.  */\n \t  section = obj_datasec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \tcase N_BSS | N_EXT:\n \t  section = obj_bsssec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \tcase N_INDR | N_EXT:\n \t  /* An indirect symbol.  The next symbol is the symbol\n@@ -3145,17 +3145,17 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \tcase N_SETT: case N_SETT | N_EXT:\n \t  section = obj_textsec (abfd);\n \t  flags |= BSF_CONSTRUCTOR;\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \tcase N_SETD: case N_SETD | N_EXT:\n \t  section = obj_datasec (abfd);\n \t  flags |= BSF_CONSTRUCTOR;\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \tcase N_SETB: case N_SETB | N_EXT:\n \t  section = obj_bsssec (abfd);\n \t  flags |= BSF_CONSTRUCTOR;\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \tcase N_WARNING:\n \t  /* A warning symbol.  The next symbol is the one to warn\n@@ -3181,17 +3181,17 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \t  break;\n \tcase N_WEAKT:\n \t  section = obj_textsec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  flags = BSF_WEAK;\n \t  break;\n \tcase N_WEAKD:\n \t  section = obj_datasec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  flags = BSF_WEAK;\n \t  break;\n \tcase N_WEAKB:\n \t  section = obj_bsssec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  flags = BSF_WEAK;\n \t  break;\n \t}\n@@ -3899,8 +3899,7 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n \t      (*flaginfo->info->callbacks->reloc_overflow)\n \t\t(flaginfo->info, NULL,\n \t\t (p->type == bfd_section_reloc_link_order\n-\t\t  ? bfd_section_name (flaginfo->output_bfd,\n-\t\t\t\t      pr->u.section)\n+\t\t  ? bfd_section_name (pr->u.section)\n \t\t  : pr->u.name),\n \t\t howto->name, pr->addend, NULL, NULL, (bfd_vma) 0);\n \t      break;\n@@ -4314,7 +4313,7 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \t\t    asection *s;\n \n \t\t    s = aout_reloc_index_to_section (input_bfd, r_index);\n-\t\t    name = bfd_section_name (input_bfd, s);\n+\t\t    name = bfd_section_name (s);\n \t\t  }\n \t\t(*flaginfo->info->callbacks->reloc_overflow)\n \t\t  (flaginfo->info, (h ? &h->root : NULL), name, howto->name,\n@@ -4728,7 +4727,7 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \t\t\tasection *s;\n \n \t\t\ts = aout_reloc_index_to_section (input_bfd, r_index);\n-\t\t\tname = bfd_section_name (input_bfd, s);\n+\t\t\tname = bfd_section_name (s);\n \t\t      }\n \t\t    (*flaginfo->info->callbacks->reloc_overflow)\n \t\t      (flaginfo->info, (h ? &h->root : NULL), name,\n@@ -4868,8 +4867,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \treturn FALSE;\n       PUT_WORD (output_bfd, strtab_index, outsym->e_strx);\n       PUT_WORD (output_bfd,\n-\t\t(bfd_get_section_vma (output_bfd,\n-\t\t\t\t      obj_textsec (input_bfd)->output_section)\n+\t\t(bfd_section_vma (obj_textsec (input_bfd)->output_section)\n \t\t + obj_textsec (input_bfd)->output_offset),\n \t\toutsym->e_value);\n       ++obj_aout_external_sym_count (output_bfd);\n@@ -5077,7 +5075,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\t  BFD_ASSERT (bfd_is_abs_section (output_section)\n \t\t\t      || output_section->owner == output_bfd);\n \t\t  val = (hresolve->root.u.def.value\n-\t\t\t + bfd_get_section_vma (output_bfd, output_section)\n+\t\t\t + bfd_section_vma (output_section)\n \t\t\t + input_section->output_offset);\n \n \t\t  /* Get the correct type based on the section.  If"
    },
    {
      "sha": "e55e3e90ba7f8983515c585d6c5bb4154ed11ddd",
      "filename": "bfd/bfd-in.h",
      "status": "modified",
      "additions": 9,
      "deletions": 15,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/bfd-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/bfd-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -299,21 +299,15 @@ typedef struct bfd_section *sec_ptr;\n    ? (((bfd_vma) (this) + ((boundary) - 1)) & ~ (bfd_vma) ((boundary)-1)) \\\n    : ~ (bfd_vma) 0)\n \n-#define bfd_get_section_name(bfd, ptr) ((void) bfd, (ptr)->name)\n-#define bfd_get_section_vma(bfd, ptr) ((void) bfd, (ptr)->vma)\n-#define bfd_get_section_lma(bfd, ptr) ((void) bfd, (ptr)->lma)\n-#define bfd_get_section_alignment(bfd, ptr) ((void) bfd, \\\n-\t\t\t\t\t     (ptr)->alignment_power)\n-#define bfd_section_name(bfd, ptr) ((ptr)->name)\n-#define bfd_section_size(bfd, ptr) ((ptr)->size)\n-#define bfd_get_section_size(ptr) ((ptr)->size)\n-#define bfd_section_vma(bfd, ptr) ((ptr)->vma)\n-#define bfd_section_lma(bfd, ptr) ((ptr)->lma)\n-#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)\n-#define bfd_get_section_flags(bfd, ptr) ((void) bfd, (ptr)->flags)\n-#define bfd_get_section_userdata(bfd, ptr) ((void) bfd, (ptr)->userdata)\n-\n-#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)\n+#define bfd_section_name(sec) ((sec)->name)\n+#define bfd_section_size(sec) ((sec)->size)\n+#define bfd_section_vma(sec) ((sec)->vma)\n+#define bfd_section_lma(sec) ((sec)->lma)\n+#define bfd_section_alignment(sec) ((sec)->alignment_power)\n+#define bfd_section_flags(sec) ((sec)->flags)\n+#define bfd_section_userdata(sec) ((sec)->userdata)\n+\n+#define bfd_is_com_section(sec) (((sec)->flags & SEC_IS_COMMON) != 0)\n \n #define bfd_get_section_limit_octets(bfd, sec)\t\t\t\\\n   ((bfd)->direction != write_direction && (sec)->rawsize != 0\t\\"
    },
    {
      "sha": "425f0c6709af6ebe806c9e60b95e5e6ff75cad96",
      "filename": "bfd/bfd-in2.h",
      "status": "modified",
      "additions": 26,
      "deletions": 29,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/bfd-in2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/bfd-in2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in2.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -306,21 +306,15 @@ typedef struct bfd_section *sec_ptr;\n    ? (((bfd_vma) (this) + ((boundary) - 1)) & ~ (bfd_vma) ((boundary)-1)) \\\n    : ~ (bfd_vma) 0)\n \n-#define bfd_get_section_name(bfd, ptr) ((void) bfd, (ptr)->name)\n-#define bfd_get_section_vma(bfd, ptr) ((void) bfd, (ptr)->vma)\n-#define bfd_get_section_lma(bfd, ptr) ((void) bfd, (ptr)->lma)\n-#define bfd_get_section_alignment(bfd, ptr) ((void) bfd, \\\n-\t\t\t\t\t     (ptr)->alignment_power)\n-#define bfd_section_name(bfd, ptr) ((ptr)->name)\n-#define bfd_section_size(bfd, ptr) ((ptr)->size)\n-#define bfd_get_section_size(ptr) ((ptr)->size)\n-#define bfd_section_vma(bfd, ptr) ((ptr)->vma)\n-#define bfd_section_lma(bfd, ptr) ((ptr)->lma)\n-#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)\n-#define bfd_get_section_flags(bfd, ptr) ((void) bfd, (ptr)->flags)\n-#define bfd_get_section_userdata(bfd, ptr) ((void) bfd, (ptr)->userdata)\n-\n-#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)\n+#define bfd_section_name(sec) ((sec)->name)\n+#define bfd_section_size(sec) ((sec)->size)\n+#define bfd_section_vma(sec) ((sec)->vma)\n+#define bfd_section_lma(sec) ((sec)->lma)\n+#define bfd_section_alignment(sec) ((sec)->alignment_power)\n+#define bfd_section_flags(sec) ((sec)->flags)\n+#define bfd_section_userdata(sec) ((sec)->userdata)\n+\n+#define bfd_is_com_section(sec) (((sec)->flags & SEC_IS_COMMON) != 0)\n \n #define bfd_get_section_limit_octets(bfd, sec)\t\t\t\\\n   ((bfd)->direction != write_direction && (sec)->rawsize != 0\t\\\n@@ -1742,26 +1736,31 @@ struct relax_table {\n    would use a comma expression, eg: \"((ptr)->foo = val, TRUE)\" and some\n    compilers will complain about comma expressions that have no effect.  */\n static inline bfd_boolean\n-bfd_set_section_userdata (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr,\n-                          void * val)\n+bfd_set_section_userdata (asection *sec, void *val)\n+{\n+  sec->userdata = val;\n+  return TRUE;\n+}\n+\n+static inline bfd_boolean\n+bfd_set_section_vma (asection *sec, bfd_vma val)\n {\n-  ptr->userdata = val;\n+  sec->vma = sec->lma = val;\n+  sec->user_set_vma = TRUE;\n   return TRUE;\n }\n \n static inline bfd_boolean\n-bfd_set_section_vma (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr, bfd_vma val)\n+bfd_set_section_lma (asection *sec, bfd_vma val)\n {\n-  ptr->vma = ptr->lma = val;\n-  ptr->user_set_vma = TRUE;\n+  sec->lma = val;\n   return TRUE;\n }\n \n static inline bfd_boolean\n-bfd_set_section_alignment (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr,\n-                           unsigned int val)\n+bfd_set_section_alignment (asection *sec, unsigned int val)\n {\n-  ptr->alignment_power = val;\n+  sec->alignment_power = val;\n   return TRUE;\n }\n \n@@ -1963,11 +1962,10 @@ asection *bfd_make_section_with_flags\n \n asection *bfd_make_section (bfd *, const char *name);\n \n-bfd_boolean bfd_set_section_flags\n-   (bfd *abfd, asection *sec, flagword flags);\n+bfd_boolean bfd_set_section_flags (asection *sec, flagword flags);\n \n void bfd_rename_section\n-   (bfd *abfd, asection *sec, const char *newname);\n+   (asection *sec, const char *newname);\n \n void bfd_map_over_sections\n    (bfd *abfd,\n@@ -1979,8 +1977,7 @@ asection *bfd_sections_find_if\n     bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),\n     void *obj);\n \n-bfd_boolean bfd_set_section_size\n-   (bfd *abfd, asection *sec, bfd_size_type val);\n+bfd_boolean bfd_set_section_size (asection *sec, bfd_size_type val);\n \n bfd_boolean bfd_set_section_contents\n    (bfd *abfd, asection *section, const void *data,"
    },
    {
      "sha": "7029bf7b85bac4543a915970c04d78524ab8be9c",
      "filename": "bfd/bfd.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2342,7 +2342,7 @@ bfd_update_compression_header (bfd *abfd, bfd_byte *contents,\n \t\t  bfd_put_32 (abfd, 1 << sec->alignment_power,\n \t\t\t      &echdr->ch_addralign);\n \t\t  /* bfd_log2 (alignof (Elf32_Chdr)) */\n-\t\t  bfd_set_section_alignment (abfd, sec, 2);\n+\t\t  bfd_set_section_alignment (sec, 2);\n \t\t}\n \t      else\n \t\t{\n@@ -2354,7 +2354,7 @@ bfd_update_compression_header (bfd *abfd, bfd_byte *contents,\n \t\t  bfd_put_64 (abfd, 1 << sec->alignment_power,\n \t\t\t      &echdr->ch_addralign);\n \t\t  /* bfd_log2 (alignof (Elf64_Chdr)) */\n-\t\t  bfd_set_section_alignment (abfd, sec, 3);\n+\t\t  bfd_set_section_alignment (sec, 3);\n \t\t}\n \t    }\n \t  else\n@@ -2368,7 +2368,7 @@ bfd_update_compression_header (bfd *abfd, bfd_byte *contents,\n \t      memcpy (contents, \"ZLIB\", 4);\n \t      bfd_putb64 (sec->size, contents + 4);\n \t      /* No way to keep the original alignment, just use 1 always. */\n-\t      bfd_set_section_alignment (abfd, sec, 0);\n+\t      bfd_set_section_alignment (sec, 0);\n \t    }\n \t}\n     }\n@@ -2597,7 +2597,7 @@ bfd_convert_section_contents (bfd *ibfd, sec_ptr isec, bfd *obfd,\n       use_memmove = TRUE;\n     }\n \n-  size = bfd_get_section_size (isec) - ihdr_size + ohdr_size;\n+  size = bfd_section_size (isec) - ihdr_size + ohdr_size;\n   if (!use_memmove)\n     {\n       contents = (bfd_byte *) bfd_malloc (size);"
    },
    {
      "sha": "d36921bbfe6784523bbbd533ccfdbfa93fe9d701",
      "filename": "bfd/coff-alpha.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coff-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coff-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-alpha.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -426,7 +426,7 @@ alpha_ecoff_object_p (bfd *abfd)\n \t  size = sec->line_filepos * 8;\n \t  BFD_ASSERT (size == sec->size\n \t\t      || size + 8 == sec->size);\n-\t  if (! bfd_set_section_size (abfd, sec, size))\n+\t  if (!bfd_set_section_size (sec, size))\n \t    return NULL;\n \t}\n     }\n@@ -1237,7 +1237,7 @@ alpha_convert_external_reloc (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* Compute a new r_symndx value.  */\n       hsec = h->root.u.def.section;\n-      name = bfd_get_section_name (output_bfd, hsec->output_section);\n+      name = bfd_section_name (hsec->output_section);\n \n       r_symndx = (unsigned long) -1;\n       switch (name[1])\n@@ -1928,8 +1928,7 @@ alpha_relocate_section (bfd *output_bfd,\n \t\t    if (r_extern)\n \t\t      name = sym_hashes[r_symndx]->root.root.string;\n \t\t    else\n-\t\t      name = bfd_section_name (input_bfd,\n-\t\t\t\t\t       symndx_to_section[r_symndx]);\n+\t\t      name = bfd_section_name (symndx_to_section[r_symndx]);\n \t\t    (*info->callbacks->reloc_overflow)\n \t\t      (info, NULL, name, alpha_howto_table[r_type].name,\n \t\t       (bfd_vma) 0, input_bfd, input_section,"
    },
    {
      "sha": "cbc5257e9f3e951a5ed46aa92336426ef0aee07c",
      "filename": "bfd/coff-arm.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coff-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coff-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-arm.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1989,7 +1989,7 @@ bfd_arm_get_bfd_for_interworking (bfd *\t\t\t abfd,\n       sec = bfd_make_section_with_flags (abfd, ARM2THUMB_GLUE_SECTION_NAME,\n \t\t\t\t\t flags);\n       if (sec == NULL\n-\t  || ! bfd_set_section_alignment (abfd, sec, 2))\n+\t  || !bfd_set_section_alignment (sec, 2))\n \treturn FALSE;\n     }\n \n@@ -2003,7 +2003,7 @@ bfd_arm_get_bfd_for_interworking (bfd *\t\t\t abfd,\n \t\t\t\t\t flags);\n \n       if (sec == NULL\n-\t  || ! bfd_set_section_alignment (abfd, sec, 2))\n+\t  || !bfd_set_section_alignment (sec, 2))\n \treturn FALSE;\n     }\n "
    },
    {
      "sha": "c6fe679a6c68e56cdf02a9b1464b068c62fa8773",
      "filename": "bfd/coff-mips.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coff-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coff-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-mips.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1012,8 +1012,7 @@ mips_relocate_section (bfd *output_bfd,\n \n \t\t  /* Compute a new r_symndx value.  */\n \t\t  s = h->root.u.def.section;\n-\t\t  name = bfd_get_section_name (output_bfd,\n-\t\t\t\t\t       s->output_section);\n+\t\t  name = bfd_section_name (s->output_section);\n \n \t\t  int_rel.r_symndx = -1;\n \t\t  switch (name[1])\n@@ -1223,7 +1222,7 @@ mips_relocate_section (bfd *output_bfd,\n \t\tif (int_rel.r_extern)\n \t\t  name = NULL;\n \t\telse\n-\t\t  name = bfd_section_name (input_bfd, s);\n+\t\t  name = bfd_section_name (s);\n \t\t(*info->callbacks->reloc_overflow)\n \t\t  (info, (h ? &h->root : NULL), name, howto->name,\n \t\t   (bfd_vma) 0, input_bfd, input_section,"
    },
    {
      "sha": "091da1fd5e81e5fa5a1480221b1e12deaffe5e82",
      "filename": "bfd/coff64-rs6000.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coff64-rs6000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coff64-rs6000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff64-rs6000.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -959,7 +959,7 @@ xcoff64_write_object_contents (bfd *abfd)\n       if (text_sec != NULL)\n \t{\n \t  internal_a.o_sntext = text_sec->target_index;\n-\t  internal_a.o_algntext = bfd_get_section_alignment (abfd, text_sec);\n+\t  internal_a.o_algntext = bfd_section_alignment (text_sec);\n \t}\n       else\n \t{\n@@ -970,7 +970,7 @@ xcoff64_write_object_contents (bfd *abfd)\n       if (data_sec != NULL)\n \t{\n \t  internal_a.o_sndata = data_sec->target_index;\n-\t  internal_a.o_algndata = bfd_get_section_alignment (abfd, data_sec);\n+\t  internal_a.o_algndata = bfd_section_alignment (data_sec);\n \t}\n       else\n \t{"
    },
    {
      "sha": "948bb705b0945ff749383a1ee7ffc55bb4221f81",
      "filename": "bfd/coffcode.h",
      "status": "modified",
      "additions": 9,
      "deletions": 10,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coffcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coffcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffcode.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1696,7 +1696,7 @@ coff_set_custom_section_alignment (bfd *abfd ATTRIBUTE_UNUSED,\n \n   for (i = 0; i < table_size; ++i)\n     {\n-      const char *secname = bfd_get_section_name (abfd, section);\n+      const char *secname = bfd_section_name (section);\n \n       if (alignment_table[i].comparison_length == (unsigned int) -1\n \t  ? strcmp (alignment_table[i].name, secname) == 0\n@@ -1759,17 +1759,17 @@ coff_new_section_hook (bfd * abfd, asection * section)\n \n #ifdef RS6000COFF_C\n   if (bfd_xcoff_text_align_power (abfd) != 0\n-      && strcmp (bfd_get_section_name (abfd, section), \".text\") == 0)\n+      && strcmp (bfd_section_name (section), \".text\") == 0)\n     section->alignment_power = bfd_xcoff_text_align_power (abfd);\n   else if (bfd_xcoff_data_align_power (abfd) != 0\n-      && strcmp (bfd_get_section_name (abfd, section), \".data\") == 0)\n+      && strcmp (bfd_section_name (section), \".data\") == 0)\n     section->alignment_power = bfd_xcoff_data_align_power (abfd);\n   else\n     {\n       int i;\n \n       for (i = 0; i < XCOFF_DWSECT_NBR_NAMES; i++)\n-\tif (strcmp (bfd_get_section_name (abfd, section),\n+\tif (strcmp (bfd_section_name (section),\n \t\t    xcoff_dwsect_names[i].name) == 0)\n \t  {\n \t    section->alignment_power = 0;\n@@ -3221,7 +3221,7 @@ coff_compute_section_file_positions (bfd * abfd)\n \t incremented in coff_set_section_contents.  This is right for\n \t SVR3.2.  */\n       if (strcmp (current->name, _LIB) == 0)\n-\t(void) bfd_set_section_vma (abfd, current, 0);\n+\tbfd_set_section_vma (current, 0);\n #endif\n \n #ifdef ALIGN_SECTIONS_IN_FILE\n@@ -4011,7 +4011,7 @@ coff_write_object_contents (bfd * abfd)\n       if (text_sec != NULL)\n \t{\n \t  internal_a.o_sntext = text_sec->target_index;\n-\t  internal_a.o_algntext = bfd_get_section_alignment (abfd, text_sec);\n+\t  internal_a.o_algntext = bfd_section_alignment (text_sec);\n \t}\n       else\n \t{\n@@ -4021,7 +4021,7 @@ coff_write_object_contents (bfd * abfd)\n       if (data_sec != NULL)\n \t{\n \t  internal_a.o_sndata = data_sec->target_index;\n-\t  internal_a.o_algndata = bfd_get_section_alignment (abfd, data_sec);\n+\t  internal_a.o_algndata = bfd_section_alignment (data_sec);\n \t}\n       else\n \t{\n@@ -4390,8 +4390,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \t   PR 17521: file: 078-10659-0.004.  */\n \tcontinue;\n       else\n-\tcache_ptr->u.offset = (dst.l_addr.l_paddr\n-\t\t\t       - bfd_section_vma (abfd, asect));\n+\tcache_ptr->u.offset = dst.l_addr.l_paddr - bfd_section_vma (asect);\n       cache_ptr++;\n     }\n \n@@ -4886,7 +4885,7 @@ coff_classify_symbol (bfd *abfd,\n \t  name = _bfd_coff_internal_syment_name (abfd, syment, buf)\n \t  sec = coff_section_from_bfd_index (abfd, syment->n_scnum);\n \t  if (sec != NULL && name != NULL\n-\t      && (strcmp (bfd_get_section_name (abfd, sec), name) == 0))\n+\t      && (strcmp (bfd_section_name (sec), name) == 0))\n \t    return COFF_SYMBOL_PE_SECTION;\n \t}\n #endif"
    },
    {
      "sha": "ba7bb5eaf42573668eedb8289816e721a129d928",
      "filename": "bfd/coffgen.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coffgen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/coffgen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffgen.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -217,7 +217,7 @@ make_a_section_from_file (bfd *abfd,\n \t  break;\n \t}\n       if (new_name != NULL)\n-\tbfd_rename_section (abfd, return_section, new_name);\n+\tbfd_rename_section (return_section, new_name);\n     }\n \n   return result;\n@@ -2366,7 +2366,7 @@ coff_find_nearest_line_with_names (bfd *abfd,\n       bfd_vma maxdiff;\n \n       /* Look through the C_FILE symbols to find the best one.  */\n-      sec_vma = bfd_get_section_vma (abfd, section);\n+      sec_vma = bfd_section_vma (section);\n       *filename_ptr = (char *) p->u.syment._n._n_n._n_offset;\n       maxdiff = (bfd_vma) 0 - (bfd_vma) 1;\n       while (1)\n@@ -2658,7 +2658,7 @@ _bfd_coff_section_already_linked (bfd *abfd,\n   if ((flags & SEC_GROUP) != 0)\n     return FALSE;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n   s_comdat = bfd_coff_get_comdat_section (abfd, sec);\n \n   if (s_comdat != NULL)"
    },
    {
      "sha": "2115e9c36ab0990b83e59636a520bc957186ef3a",
      "filename": "bfd/cofflink.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/cofflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/cofflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cofflink.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2846,8 +2846,7 @@ _bfd_coff_reloc_link_order (bfd *output_bfd,\n \t  (*flaginfo->info->callbacks->reloc_overflow)\n \t    (flaginfo->info, NULL,\n \t     (link_order->type == bfd_section_reloc_link_order\n-\t      ? bfd_section_name (output_bfd,\n-\t\t\t\t  link_order->u.reloc.p->u.section)\n+\t      ? bfd_section_name (link_order->u.reloc.p->u.section)\n \t      : link_order->u.reloc.p->u.name),\n \t     howto->name, link_order->u.reloc.p->addend,\n \t     (bfd *) NULL, (asection *) NULL, (bfd_vma) 0);"
    },
    {
      "sha": "8f96d064bde1369a8956a3d3ed9d8599b86ead86",
      "filename": "bfd/compress.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/compress.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/compress.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/compress.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -155,8 +155,7 @@ bfd_compress_section_contents (bfd *abfd, sec_ptr sec,\n \t      return 0;\n \t    }\n \t  free (uncompressed_buffer);\n-\t  bfd_set_section_alignment (abfd, sec,\n-\t\t\t\t     orig_uncompressed_alignment_pow);\n+\t  bfd_set_section_alignment (sec, orig_uncompressed_alignment_pow);\n \n \t  sec->contents = buffer;\n \t  sec->compress_status = COMPRESS_SECTION_DONE;\n@@ -255,7 +254,7 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)\n \t      && filesize < sz\n \t      /* PR 24753: Linker created sections can be larger than\n \t\t the file size, eg if they are being used to hold stubs.  */\n-\t      && (bfd_get_section_flags (abfd, sec) & SEC_LINKER_CREATED) == 0\n+\t      && (bfd_section_flags (sec) & SEC_LINKER_CREATED) == 0\n \t      /* The MMO file format supports its own special compression\n \t\t technique, but it uses COMPRESS_SECTION_NONE when loading\n \t\t a section's contents.  */\n@@ -552,7 +551,7 @@ bfd_init_section_decompress_status (bfd *abfd, sec_ptr sec)\n \n   sec->compressed_size = sec->size;\n   sec->size = uncompressed_size;\n-  bfd_set_section_alignment (abfd, sec, uncompressed_alignment_power);\n+  bfd_set_section_alignment (sec, uncompressed_alignment_power);\n   sec->compress_status = DECOMPRESS_SECTION_SIZED;\n \n   return TRUE;"
    },
    {
      "sha": "30adba0e6d2bff32c2cfd602c41564107108e8aa",
      "filename": "bfd/ecoff.c",
      "status": "modified",
      "additions": 9,
      "deletions": 11,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/ecoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/ecoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ecoff.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1676,10 +1676,10 @@ ecoff_slurp_reloc_table (bfd *abfd,\n \t    abort ();\n \t  rptr->sym_ptr_ptr = sec->symbol_ptr_ptr;\n \n-\t  rptr->addend = - bfd_get_section_vma (abfd, sec);\n+\t  rptr->addend = - bfd_section_vma (sec);\n \t}\n \n-      rptr->address = intern.r_vaddr - bfd_get_section_vma (abfd, section);\n+      rptr->address = intern.r_vaddr - bfd_section_vma (section);\n \n       /* Let the backend select the howto field and do any other\n \t required processing.  */\n@@ -2431,7 +2431,7 @@ _bfd_ecoff_write_object_contents (bfd *abfd)\n       strncpy (section.s_name, current->name, sizeof section.s_name);\n \n       /* This seems to be correct for Irix 4 shared libraries.  */\n-      vma = bfd_get_section_vma (abfd, current);\n+      vma = bfd_section_vma (current);\n       if (streq (current->name, _LIB))\n \tsection.s_vaddr = 0;\n       else\n@@ -2682,8 +2682,7 @@ _bfd_ecoff_write_object_contents (bfd *abfd)\n \t      if (reloc->howto == NULL)\n \t\tcontinue;\n \n-\t      in.r_vaddr = (reloc->address\n-\t\t\t    + bfd_get_section_vma (abfd, current));\n+\t      in.r_vaddr = reloc->address + bfd_section_vma (current);\n \t      in.r_type = reloc->howto->type;\n \n \t      if ((sym->flags & BSF_SECTION_SYM) == 0)\n@@ -2719,7 +2718,7 @@ _bfd_ecoff_write_object_contents (bfd *abfd)\n \t\t    { _RCONST, RELOC_SECTION_RCONST }\n \t\t  };\n \n-\t\t  name = bfd_get_section_name (abfd, bfd_asymbol_section (sym));\n+\t\t  name = bfd_section_name (bfd_asymbol_section (sym));\n \n \t\t  for (j = 0; j < ARRAY_SIZE (section_symndx); j++)\n \t\t    if (streq (name, section_symndx[j].name))\n@@ -4010,7 +4009,7 @@ ecoff_reloc_link_order (bfd *output_bfd,\n \t  (*info->callbacks->reloc_overflow)\n \t    (info, NULL,\n \t     (link_order->type == bfd_section_reloc_link_order\n-\t      ? bfd_section_name (output_bfd, section)\n+\t      ? bfd_section_name (section)\n \t      : link_order->u.reloc.p->u.name),\n \t     rel.howto->name, addend, NULL, NULL, (bfd_vma) 0);\n \t  break;\n@@ -4025,8 +4024,7 @@ ecoff_reloc_link_order (bfd *output_bfd,\n   rel.addend = 0;\n \n   /* Move the information into an internal_reloc structure.  */\n-  in.r_vaddr = (rel.address\n-\t\t+ bfd_get_section_vma (output_bfd, output_section));\n+  in.r_vaddr = rel.address + bfd_section_vma (output_section);\n   in.r_type = rel.howto->type;\n \n   if (type == bfd_symbol_reloc_link_order)\n@@ -4076,7 +4074,7 @@ ecoff_reloc_link_order (bfd *output_bfd,\n \t{ _RCONST, RELOC_SECTION_RCONST }\n       };\n \n-      name = bfd_get_section_name (output_bfd, section);\n+      name = bfd_section_name (section);\n \n       for (i = 0; i < ARRAY_SIZE (section_symndx); i++)\n \tif (streq (name, section_symndx[i].name))\n@@ -4189,7 +4187,7 @@ ecoff_link_write_external (struct bfd_hash_entry *bh, void * data)\n \t  };\n \n \t  output_section = h->root.u.def.section->output_section;\n-\t  name = bfd_section_name (output_section->owner, output_section);\n+\t  name = bfd_section_name (output_section);\n \n \t  for (i = 0; i < ARRAY_SIZE (section_storage_classes); i++)\n \t    if (streq (name, section_storage_classes[i].name))"
    },
    {
      "sha": "c2cb77bb1103b3fdd34eb916bb1f4a43f435d745",
      "filename": "bfd/elf-eh-frame.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-eh-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-eh-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-eh-frame.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1109,7 +1109,7 @@ add_eh_frame_hdr_terminator (asection *sec,\n   if (!sec->rawsize)\n     sec->rawsize = sec->size;\n \n-  bfd_set_section_size (sec->owner, sec, sec->size + 8);\n+  bfd_set_section_size (sec, sec->size + 8);\n }\n \n /* Finish a pass over all .eh_frame_entry sections.  */\n@@ -1682,7 +1682,7 @@ _bfd_elf_eh_frame_entry_present (struct bfd_link_info *info)\n     {\n       for (o = abfd->sections; o; o = o->next)\n \t{\n-\t  const char *name = bfd_get_section_name (abfd, o);\n+\t  const char *name = bfd_section_name (o);\n \n \t  if (strcmp (name, \".eh_frame_entry\")\n \t      && !bfd_is_abs_section (o->output_section))"
    },
    {
      "sha": "2035d4c9c0b12a6dc15bbc016fee9274d0b7d662",
      "filename": "bfd/elf-hppa.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-hppa.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-hppa.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-hppa.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -881,7 +881,7 @@ elf_hppa_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec)\n {\n   const char *name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (strcmp (name, \".PARISC.unwind\") == 0)\n     {"
    },
    {
      "sha": "58948e32f112787c7afa9da42d2306541a90c56b",
      "filename": "bfd/elf-ifunc.c",
      "status": "modified",
      "additions": 4,
      "deletions": 7,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-ifunc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-ifunc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-ifunc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -62,8 +62,7 @@ _bfd_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_with_flags (abfd, rel_sec,\n \t\t\t\t       flags | SEC_READONLY);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t  bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->irelifunc = s;\n     }\n@@ -73,7 +72,7 @@ _bfd_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)\n \t for static executables.   */\n       s = bfd_make_section_with_flags (abfd, \".iplt\", pltflags);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+\t  || !bfd_set_section_alignment (s, bed->plt_alignment))\n \treturn FALSE;\n       htab->iplt = s;\n \n@@ -82,8 +81,7 @@ _bfd_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t? \".rela.iplt\" : \".rel.iplt\"),\n \t\t\t\t       flags | SEC_READONLY);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t  bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->irelplt = s;\n \n@@ -94,8 +92,7 @@ _bfd_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)\n       else\n \ts = bfd_make_section_with_flags (abfd, \".igot\", flags);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->igotplt = s;\n     }"
    },
    {
      "sha": "b234c168c8f1b5ec666f04a95f45bd1f7d9b0fb4",
      "filename": "bfd/elf-m10200.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-m10200.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-m10200.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-m10200.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -413,7 +413,7 @@ mn10200_elf_relocate_section (bfd *output_bfd,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)"
    },
    {
      "sha": "30828f117ab17b72a39133125009e5423d50b9b9",
      "filename": "bfd/elf-m10300.c",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-m10300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-m10300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-m10300.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -725,7 +725,7 @@ _bfd_mn10300_elf_create_got_section (bfd * abfd,\n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n   htab->splt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n \n   /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the\n@@ -742,15 +742,15 @@ _bfd_mn10300_elf_create_got_section (bfd * abfd,\n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   htab->sgot = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (bed->want_got_plt)\n     {\n       s = bfd_make_section_anyway_with_flags (abfd, \".got.plt\", flags);\n       htab->sgotplt = s;\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, ptralign))\n+\t  || !bfd_set_section_alignment (s, ptralign))\n \treturn FALSE;\n     }\n \n@@ -2125,7 +2125,7 @@ mn10300_elf_relocate_section (bfd *output_bfd,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)\n@@ -4821,7 +4821,7 @@ _bfd_mn10300_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  flags | SEC_READONLY);\n   htab->root.srelplt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (! _bfd_mn10300_elf_create_got_section (abfd, info))\n@@ -4858,7 +4858,7 @@ _bfd_mn10300_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t   ? \".rela.bss\" : \".rel.bss\"),\n \t\t\t\t\t\t  flags | SEC_READONLY);\n \t  if (s == NULL\n-\t      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+\t      || !bfd_set_section_alignment (s, ptralign))\n \t    return FALSE;\n \t}\n     }\n@@ -5073,7 +5073,7 @@ _bfd_mn10300_elf_size_dynamic_sections (bfd * output_bfd,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (streq (name, \".plt\"))\n \t{\n@@ -5099,8 +5099,7 @@ _bfd_mn10300_elf_size_dynamic_sections (bfd * output_bfd,\n \t\t     entry.  The entries in the .rela.plt section\n \t\t     really apply to the .got section, which we\n \t\t     created ourselves and so know is not readonly.  */\n-\t\t  outname = bfd_get_section_name (output_bfd,\n-\t\t\t\t\t\t  s->output_section);\n+\t\t  outname = bfd_section_name (s->output_section);\n \t\t  target = bfd_get_section_by_name (output_bfd, outname + 5);\n \t\t  if (target != NULL\n \t\t      && (target->flags & SEC_READONLY) != 0"
    },
    {
      "sha": "199e61728e418f3b1fdb437ef11152b3cb67930b",
      "filename": "bfd/elf-properties.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-properties.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-properties.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-properties.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -695,12 +695,12 @@ _bfd_elf_convert_gnu_properties (bfd *ibfd, asection *isec,\n   align_shift = bed->s->elfclass == ELFCLASS64 ? 3 : 2;\n \n   /* Get the output .note.gnu.property section size.  */\n-  size = bfd_get_section_size (isec->output_section);\n+  size = bfd_section_size (isec->output_section);\n \n   /* Update the output .note.gnu.property section alignment.  */\n-  bfd_set_section_alignment (obfd, isec->output_section, align_shift);\n+  bfd_set_section_alignment (isec->output_section, align_shift);\n \n-  if (size > bfd_get_section_size (isec))\n+  if (size > bfd_section_size (isec))\n     {\n       contents = (bfd_byte *) bfd_malloc (size);\n       free (*ptr);"
    },
    {
      "sha": "d7cd7e60e9e376599268daf1f1c0ff1dc53ac160",
      "filename": "bfd/elf-s390-common.c",
      "status": "modified",
      "additions": 4,
      "deletions": 7,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-s390-common.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-s390-common.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-s390-common.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -131,8 +131,7 @@ s390_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_with_flags (abfd, \".rela.ifunc\",\n \t\t\t\t       flags | SEC_READONLY);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t  bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->irelifunc = s;\n     }\n@@ -141,21 +140,19 @@ s390_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_with_flags (abfd, \".iplt\",\n \t\t\t\t   flags | SEC_CODE | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n   htab->iplt = s;\n \n   s = bfd_make_section_with_flags (abfd, \".rela.iplt\", flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t      bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->irelplt = s;\n \n   s = bfd_make_section_with_flags (abfd, \".igot.plt\", flags);\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s,\n-\t\t\t\t     bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->igotplt = s;\n "
    },
    {
      "sha": "8fe17bf628fdea9be2c49c4017758bbbca26d2f6",
      "filename": "bfd/elf-vxworks.c",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-vxworks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf-vxworks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-vxworks.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -97,7 +97,7 @@ elf_vxworks_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info,\n \t\t\t\t\t      | SEC_READONLY\n \t\t\t\t\t      | SEC_LINKER_CREATED);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (dynobj, s, bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n \n       *srelplt2_out = s;\n@@ -279,9 +279,7 @@ elf_vxworks_finish_dynamic_entry (bfd *output_bfd, Elf_Internal_Dyn *dyn)\n \n     case DT_VX_WRS_TLS_DATA_ALIGN:\n       sec = bfd_get_section_by_name (output_bfd, \".tls_data\");\n-      dyn->d_un.d_val\n-\t= (bfd_size_type)1 << bfd_get_section_alignment (output_bfd,\n-\t\t\t\t\t\t\t sec);\n+      dyn->d_un.d_val = (bfd_size_type) 1 << bfd_section_alignment (sec);\n       break;\n \n     case DT_VX_WRS_TLS_VARS_START:"
    },
    {
      "sha": "664eae5c66f6beeec4d6f64ea66b8ef20214cc31",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 9,
      "deletions": 11,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -547,7 +547,7 @@ bfd_elf_sym_name (bfd *abfd,\n   if (name == NULL)\n     name = \"(null)\";\n   else if (sym_sec && *name == '\\0')\n-    name = bfd_section_name (abfd, sym_sec);\n+    name = bfd_section_name (sym_sec);\n \n   return name;\n }\n@@ -1049,10 +1049,9 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,\n \n   newsect->filepos = hdr->sh_offset;\n \n-  if (! bfd_set_section_vma (abfd, newsect, hdr->sh_addr)\n-      || ! bfd_set_section_size (abfd, newsect, hdr->sh_size)\n-      || ! bfd_set_section_alignment (abfd, newsect,\n-\t\t\t\t      bfd_log2 (hdr->sh_addralign)))\n+  if (!bfd_set_section_vma (newsect, hdr->sh_addr)\n+      || !bfd_set_section_size (newsect, hdr->sh_size)\n+      || !bfd_set_section_alignment (newsect, bfd_log2 (hdr->sh_addralign)))\n     return FALSE;\n \n   flags = SEC_NO_FLAGS;\n@@ -1142,7 +1141,7 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,\n     if (! bed->elf_backend_section_flags (&flags, hdr))\n       return FALSE;\n \n-  if (! bfd_set_section_flags (abfd, newsect, flags))\n+  if (!bfd_set_section_flags (newsect, flags))\n     return FALSE;\n \n   /* We do not parse the PT_NOTE segments as we are interested even in the\n@@ -1286,7 +1285,7 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,\n \t      char *new_name = convert_zdebug_to_debug (abfd, name);\n \t      if (new_name == NULL)\n \t\treturn FALSE;\n-\t      bfd_rename_section (abfd, newsect, new_name);\n+\t      bfd_rename_section (newsect, new_name);\n \t    }\n \t}\n       else\n@@ -5542,7 +5541,7 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t\t{\n \t\t  unsigned int secalign;\n \n-\t\t  secalign = bfd_get_section_alignment (abfd, *secpp);\n+\t\t  secalign = bfd_section_alignment (*secpp);\n \t\t  if (secalign > align_power)\n \t\t    align_power = secalign;\n \t\t}\n@@ -5696,7 +5695,7 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \n \t  sec = *secpp;\n \t  this_hdr = &elf_section_data (sec)->this_hdr;\n-\t  align = (bfd_size_type) 1 << bfd_get_section_alignment (abfd, sec);\n+\t  align = (bfd_size_type) 1 << bfd_section_alignment (sec);\n \n \t  if ((p->p_type == PT_LOAD\n \t       || p->p_type == PT_TLS)\n@@ -6835,8 +6834,7 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n        || (segment->p_paddr\t\t\t\t\t\t\\\n \t   ? segment->p_paddr != section->lma\t\t\t\t\\\n \t   : segment->p_vaddr != section->vma)\t\t\t\t\\\n-       || (strcmp (bfd_get_section_name (ibfd, section), \".dynamic\")\t\\\n-\t   == 0))\t\t\t\t\t\t\t\\\n+       || (strcmp (bfd_section_name (section), \".dynamic\") == 0))\t\\\n    && (segment->p_type != PT_LOAD || !section->segment_mark))\n \n /* If the output section of a section in the input segment is NULL,"
    },
    {
      "sha": "91537efd8410dde9bc51b0e9071323f4c7a93026",
      "filename": "bfd/elf32-arc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -900,7 +900,7 @@ arc_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n \n       for (sec = ibfd->sections; sec != NULL; sec = sec->next)\n \t{\n-\t  if ((bfd_get_section_flags (ibfd, sec)\n+\t  if ((bfd_section_flags (sec)\n \t       & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t      == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t    only_data_sections = FALSE;"
    },
    {
      "sha": "1c4887a03408ce0c019151911a958a907f1e6b2f",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 14,
      "deletions": 13,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3817,7 +3817,8 @@ create_got_section (bfd *dynobj, struct bfd_link_info *info)\n       htab->srofixup = bfd_make_section_with_flags (dynobj, \".rofixup\",\n \t\t\t\t\t\t    (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS\n \t\t\t\t\t\t     | SEC_IN_MEMORY | SEC_LINKER_CREATED | SEC_READONLY));\n-      if (htab->srofixup == NULL || ! bfd_set_section_alignment (dynobj, htab->srofixup, 2))\n+      if (htab->srofixup == NULL\n+\t  || !bfd_set_section_alignment (htab->srofixup, 2))\n \treturn FALSE;\n     }\n \n@@ -3845,7 +3846,7 @@ create_ifunc_sections (struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (dynobj, \".iplt\",\n \t\t\t\t\t      flags | SEC_READONLY | SEC_CODE);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (dynobj, s, bed->plt_alignment))\n+\t  || !bfd_set_section_alignment (s, bed->plt_alignment))\n \treturn FALSE;\n       htab->root.iplt = s;\n     }\n@@ -3856,7 +3857,7 @@ create_ifunc_sections (struct bfd_link_info *info)\n \t\t\t\t\t      RELOC_SECTION (htab, \".iplt\"),\n \t\t\t\t\t      flags | SEC_READONLY);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (dynobj, s, bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->root.irelplt = s;\n     }\n@@ -3865,7 +3866,7 @@ create_ifunc_sections (struct bfd_link_info *info)\n     {\n       s = bfd_make_section_anyway_with_flags (dynobj, \".igot.plt\", flags);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (dynobj, s, bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->root.igotplt = s;\n     }\n@@ -7709,7 +7710,7 @@ arm_make_glue_section (bfd * abfd, const char * name)\n   sec = bfd_make_section_anyway_with_flags (abfd, name, ARM_GLUE_SECTION_FLAGS);\n \n   if (sec == NULL\n-      || !bfd_set_section_alignment (abfd, sec, 2))\n+      || !bfd_set_section_alignment (sec, 2))\n     return FALSE;\n \n   /* Set the gc mark to prevent the section from being removed by garbage\n@@ -13374,7 +13375,7 @@ elf32_arm_relocate_section (bfd *\t\t   output_bfd,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       if (r_symndx != STN_UNDEF\n@@ -13552,10 +13553,10 @@ adjust_exidx_size(asection *exidx_sec, int adjust)\n   if (!exidx_sec->rawsize)\n     exidx_sec->rawsize = exidx_sec->size;\n \n-  bfd_set_section_size (exidx_sec->owner, exidx_sec, exidx_sec->size + adjust);\n+  bfd_set_section_size (exidx_sec, exidx_sec->size + adjust);\n   out_sec = exidx_sec->output_section;\n   /* Adjust size of output section.  */\n-  bfd_set_section_size (out_sec->owner, out_sec, out_sec->size +adjust);\n+  bfd_set_section_size (out_sec, out_sec->size +adjust);\n }\n \n /* Insert an EXIDX_CANTUNWIND marker at the end of a section.  */\n@@ -15696,9 +15697,9 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t{\n \t\t  flagword flags;\n \n-\t\t  flags = bfd_get_section_flags (dynobj, sreloc);\n+\t\t  flags = bfd_section_flags (sreloc);\n \t\t  flags &= ~(SEC_LOAD | SEC_ALLOC);\n-\t\t  bfd_set_section_flags (dynobj, sreloc, flags);\n+\t\t  bfd_set_section_flags (sreloc, flags);\n \t\t}\n \t    }\n \n@@ -17158,7 +17159,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (s == htab->root.splt)\n \t{\n@@ -17951,7 +17952,7 @@ elf32_arm_fake_sections (bfd * abfd, Elf_Internal_Shdr * hdr, asection * sec)\n {\n   const char * name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (is_arm_elf_unwind_section_name (abfd, name))\n     {\n@@ -20874,7 +20875,7 @@ elf32_arm_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n \t  if (strcmp (sec->name, \".glue_7\")\n \t      && strcmp (sec->name, \".glue_7t\"))\n \t    {\n-\t      if ((bfd_get_section_flags (ibfd, sec)\n+\t      if ((bfd_section_flags (sec)\n \t\t   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t\t  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t\tonly_data_sections = FALSE;"
    },
    {
      "sha": "f04cc94ff3456e0d97dcc2e3cbbcab3e5fa0c789",
      "filename": "bfd/elf32-avr.c",
      "status": "modified",
      "additions": 11,
      "deletions": 13,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-avr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-avr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-avr.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1465,7 +1465,7 @@ elf32_avr_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{\n@@ -2354,8 +2354,7 @@ avr_property_record_compare (const void *ap, const void *bp)\n     return (a->offset - b->offset);\n \n   if (a->section != b->section)\n-    return (bfd_get_section_vma (a->section->owner, a->section)\n-\t    - bfd_get_section_vma (b->section->owner, b->section));\n+    return bfd_section_vma (a->section) - bfd_section_vma (b->section);\n \n   return (a->type - b->type);\n }\n@@ -3948,12 +3947,12 @@ internal_reloc_compare (const void *ap, const void *bp)\n /* Return true if ADDRESS is within the vma range of SECTION from ABFD.  */\n \n static bfd_boolean\n-avr_is_section_for_address (bfd *abfd, asection *section, bfd_vma address)\n+avr_is_section_for_address (asection *section, bfd_vma address)\n {\n   bfd_vma vma;\n   bfd_size_type size;\n \n-  vma = bfd_get_section_vma (abfd, section);\n+  vma = bfd_section_vma (section);\n   if (address < vma)\n     return FALSE;\n \n@@ -3985,7 +3984,7 @@ struct avr_find_section_data\n    perform any checks, and just returns.  */\n \n static void\n-avr_find_section_for_address (bfd *abfd,\n+avr_find_section_for_address (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t      asection *section, void *data)\n {\n   struct avr_find_section_data *fs_data\n@@ -3996,11 +3995,11 @@ avr_find_section_for_address (bfd *abfd,\n     return;\n \n   /* If this section isn't part of the addressable code content, skip it.  */\n-  if ((bfd_get_section_flags (abfd, section) & SEC_ALLOC) == 0\n-      && (bfd_get_section_flags (abfd, section) & SEC_CODE) == 0)\n+  if ((bfd_section_flags (section) & SEC_ALLOC) == 0\n+      && (bfd_section_flags (section) & SEC_CODE) == 0)\n     return;\n \n-  if (avr_is_section_for_address (abfd, section, fs_data->address))\n+  if (avr_is_section_for_address (section, fs_data->address))\n     fs_data->section = section;\n }\n \n@@ -4023,7 +4022,7 @@ avr_elf32_load_records_from_section (bfd *abfd, asection *sec)\n \n   fs_data.section = NULL;\n \n-  size = bfd_get_section_size (sec);\n+  size = bfd_section_size (sec);\n   contents = bfd_malloc (size);\n   bfd_get_section_contents (abfd, sec, contents, 0, size);\n   ptr = contents;\n@@ -4126,8 +4125,7 @@ avr_elf32_load_records_from_section (bfd *abfd, asection *sec)\n \t{\n \t  /* Try to find section and offset from address.  */\n \t  if (fs_data.section != NULL\n-\t      && !avr_is_section_for_address (abfd, fs_data.section,\n-\t\t\t\t\t      address))\n+\t      && !avr_is_section_for_address (fs_data.section, address))\n \t    fs_data.section = NULL;\n \n \t  if (fs_data.section == NULL)\n@@ -4145,7 +4143,7 @@ avr_elf32_load_records_from_section (bfd *abfd, asection *sec)\n \n \t  r_list->records [i].section = fs_data.section;\n \t  r_list->records [i].offset\n-\t    = address - bfd_get_section_vma (abfd, fs_data.section);\n+\t    = address - bfd_section_vma (fs_data.section);\n \t}\n \n       r_list->records [i].type = *((bfd_byte *) ptr);"
    },
    {
      "sha": "6efee04c8bb024fa9555dc616af7d74474e0dab5",
      "filename": "bfd/elf32-bfin.c",
      "status": "modified",
      "additions": 17,
      "deletions": 21,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-bfin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-bfin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-bfin.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1601,7 +1601,7 @@ bfin_relocate_section (bfd * output_bfd,\n \t      if (name == NULL)\n \t\treturn FALSE;\n \t      if (*name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (r == bfd_reloc_overflow)\n@@ -2560,7 +2560,7 @@ bfinfdpic_relocate_section (bfd * output_bfd,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{\n@@ -2778,8 +2778,7 @@ bfinfdpic_relocate_section (bfd * output_bfd,\n \t\t    bfd_vma offset;\n \n \t\t    addend += bfinfdpic_got_section (info)->output_section->vma;\n-\t\t    if ((bfd_get_section_flags (output_bfd,\n-\t\t\t\t\t\tinput_section->output_section)\n+\t\t    if ((bfd_section_flags (input_section->output_section)\n \t\t\t & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \t\t      {\n \t\t\tif (_bfinfdpic_osec_readonly_p (output_bfd,\n@@ -2807,8 +2806,7 @@ bfinfdpic_relocate_section (bfd * output_bfd,\n \t\t\t\t\t\t  picrel);\n \t\t      }\n \t\t  }\n-\t\telse if ((bfd_get_section_flags (output_bfd,\n-\t\t\t\t\t\t input_section->output_section)\n+\t\telse if ((bfd_section_flags (input_section->output_section)\n \t\t\t  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \t\t  {\n \t\t    bfd_vma offset;\n@@ -2901,8 +2899,7 @@ bfinfdpic_relocate_section (bfd * output_bfd,\n \t\tif (osec)\n \t\t  addend += osec->output_section->vma;\n \t\tif (IS_FDPIC (input_bfd)\n-\t\t    && (bfd_get_section_flags (output_bfd,\n-\t\t\t\t\t       input_section->output_section)\n+\t\t    && (bfd_section_flags (input_section->output_section)\n \t\t\t& (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \t\t  {\n \t\t    if (_bfinfdpic_osec_readonly_p (output_bfd,\n@@ -2939,8 +2936,7 @@ bfinfdpic_relocate_section (bfd * output_bfd,\n \t      }\n \t    else\n \t      {\n-\t\tif ((bfd_get_section_flags (output_bfd,\n-\t\t\t\t\t    input_section->output_section)\n+\t\tif ((bfd_section_flags (input_section->output_section)\n \t\t     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \t\t  {\n \t\t    if (_bfinfdpic_osec_readonly_p (output_bfd,\n@@ -3201,7 +3197,7 @@ _bfin_create_got_section (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   elf_hash_table (info)->sgot = s;\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (bed->want_got_sym)\n@@ -3238,7 +3234,7 @@ _bfin_create_got_section (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, \".rel.got\",\n \t\t\t\t\t      (flags | SEC_READONLY));\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n \n       bfinfdpic_gotrel_section (info) = s;\n@@ -3247,7 +3243,7 @@ _bfin_create_got_section (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, \".rofixup\",\n \t\t\t\t\t      (flags | SEC_READONLY));\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n \n       bfinfdpic_gotfixup_section (info) = s;\n@@ -3261,7 +3257,7 @@ _bfin_create_got_section (bfd *abfd, struct bfd_link_info *info)\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n   /* Blackfin-specific: remember it.  */\n   bfinfdpic_plt_section (info) = s;\n@@ -3289,7 +3285,7 @@ _bfin_create_got_section (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".rel.plt\",\n \t\t\t\t\t  flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   /* Blackfin-specific: remember it.  */\n   bfinfdpic_pltrel_section (info) = s;\n@@ -3355,7 +3351,7 @@ elf32_bfinfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t  \".rela.bss\",\n \t\t\t\t\t\t  flags | SEC_READONLY);\n \t  if (s == NULL\n-\t      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+\t      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \t    return FALSE;\n \t}\n     }\n@@ -4616,7 +4612,7 @@ bfinfdpic_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \n \tcase R_BFIN_FUNCDESC_VALUE:\n \t  picrel->relocsfdv++;\n-\t  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)\n+\t  if (bfd_section_flags (sec) & SEC_ALLOC)\n \t    picrel->relocs32--;\n \t  /* Fall through.  */\n \n@@ -4625,7 +4621,7 @@ bfinfdpic_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t    break;\n \n \t  picrel->sym++;\n-\t  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)\n+\t  if (bfd_section_flags (sec) & SEC_ALLOC)\n \t    picrel->relocs32++;\n \t  break;\n \n@@ -5064,9 +5060,9 @@ bfin_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* Apply the required alignment.  */\n   s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));\n-  if (power_of_two > bfd_get_section_alignment (dynobj, s))\n+  if (power_of_two > bfd_section_alignment (s))\n     {\n-      if (!bfd_set_section_alignment (dynobj, s, power_of_two))\n+      if (!bfd_set_section_alignment (s, power_of_two))\n \treturn FALSE;\n     }\n \n@@ -5200,7 +5196,7 @@ bfin_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       strip = FALSE;\n "
    },
    {
      "sha": "72642e532c197bc5fdb2bafed4b5db8a83636ad9",
      "filename": "bfd/elf32-cr16.c",
      "status": "modified",
      "additions": 7,
      "deletions": 8,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-cr16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-cr16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-cr16.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -610,15 +610,15 @@ _bfd_cr16_elf_create_got_section (bfd * abfd, struct bfd_link_info * info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   htab->sgot= s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (bed->want_got_plt)\n     {\n       s = bfd_make_section_anyway_with_flags (abfd, \".got.plt\", flags);\n       htab->sgotplt = s;\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, ptralign))\n+\t  || !bfd_set_section_alignment (s, ptralign))\n \treturn FALSE;\n     }\n \n@@ -1444,7 +1444,7 @@ elf32_cr16_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)\n@@ -2241,7 +2241,7 @@ _bfd_cr16_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  flags | SEC_READONLY);\n   htab->srelplt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (! _bfd_cr16_elf_create_got_section (abfd, info))\n@@ -2278,7 +2278,7 @@ _bfd_cr16_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t   ? \".rela.bss\" : \".rel.bss\"),\n \t\t\t\t\t\t  flags | SEC_READONLY);\n \t  if (s == NULL\n-\t      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+\t      || !bfd_set_section_alignment (s, ptralign))\n \t    return FALSE;\n \t}\n     }\n@@ -2463,7 +2463,7 @@ _bfd_cr16_elf_size_dynamic_sections (bfd * output_bfd,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (strcmp (name, \".plt\") == 0)\n \t{\n@@ -2489,8 +2489,7 @@ _bfd_cr16_elf_size_dynamic_sections (bfd * output_bfd,\n \t\t     entry.  The entries in the .rela.plt section\n \t\t     really apply to the .got section, which we\n \t\t     created ourselves and so know is not readonly.  */\n-\t\t  outname = bfd_get_section_name (output_bfd,\n-\t\t\t\t\t\t  s->output_section);\n+\t\t  outname = bfd_section_name (s->output_section);\n \t\t  target = bfd_get_section_by_name (output_bfd, outname + 5);\n \t\t  if (target != NULL\n \t\t      && (target->flags & SEC_READONLY) != 0"
    },
    {
      "sha": "35bacbbc6faeebc5cda9e76cdf6c40104e63fe66",
      "filename": "bfd/elf32-cr16c.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-cr16c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-cr16c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-cr16c.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -763,7 +763,7 @@ elf32_cr16c_relocate_section (bfd *output_bfd,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)\n@@ -827,9 +827,9 @@ elf32_cr16c_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t      asection *sec,\n \t\t\t\t      int *retval)\n {\n-  if (strcmp (bfd_get_section_name (abfd, sec), \".fcommon\") == 0)\n+  if (strcmp (bfd_section_name (sec), \".fcommon\") == 0)\n     *retval = SHN_CR16C_FCOMMON;\n-  else if (strcmp (bfd_get_section_name (abfd, sec), \".ncommon\") == 0)\n+  else if (strcmp (bfd_section_name (sec), \".ncommon\") == 0)\n     *retval = SHN_CR16C_NCOMMON;\n   else\n     return FALSE;"
    },
    {
      "sha": "9c07b6d7b9871403fdfff41fa55807ba77f382c0",
      "filename": "bfd/elf32-cris.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-cris.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-cris.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-cris.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1044,7 +1044,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  symname = (bfd_elf_string_from_elf_section\n \t\t     (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (symname == NULL)\n-\t    symname = bfd_section_name (input_bfd, sec);\n+\t    symname = bfd_section_name (sec);\n \t}\n       else\n \t{\n@@ -2480,7 +2480,7 @@ cris_elf_plt_sym_val (bfd_vma i ATTRIBUTE_UNUSED, const asection *plt,\n   if ((got = bfd_get_section_by_name (abfd, \".got\")) == NULL)\n     return (bfd_vma) -1;\n \n-  plt_sec_size =  bfd_section_size (plt->owner, plt);\n+  plt_sec_size =  bfd_section_size (plt);\n   plt_entry_size\n     = (bfd_get_mach (abfd) == bfd_mach_cris_v32\n        ? PLT_ENTRY_SIZE_V32 : PLT_ENTRY_SIZE);\n@@ -3580,7 +3580,7 @@ elf_cris_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (strcmp (name, \".plt\") == 0)\n \t{"
    },
    {
      "sha": "6d15b2b10bfb77b112a0c7558c5906b3a5b6a466",
      "filename": "bfd/elf32-crx.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-crx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-crx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-crx.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -905,7 +905,7 @@ elf32_crx_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)"
    },
    {
      "sha": "16897b3930e758ef7a9252180a13516ff645104d",
      "filename": "bfd/elf32-csky.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-csky.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2092,7 +2092,7 @@ csky_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  if (htab->elf.hplt != NULL)\n \t    strip_section = FALSE;\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rel\") )\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rel\") )\n \t{\n \t  if (s->size != 0 )\n \t    relocs = TRUE;\n@@ -5070,7 +5070,7 @@ csky_elf_relocate_section (bfd *                  output_bfd,\n \t\t  if (name == NULL)\n \t\t    break;\n \t\t  if (*name == '\\0')\n-\t\t    name = bfd_section_name (input_bfd, sec);\n+\t\t    name = bfd_section_name (sec);\n \t\t}\n \t      (*info->callbacks->reloc_overflow)\n \t\t(info,"
    },
    {
      "sha": "bd07ad68b2844577606d926baa280b62227dc913",
      "filename": "bfd/elf32-d10v.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-d10v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-d10v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-d10v.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -482,7 +482,7 @@ elf32_d10v_relocate_section (bfd *output_bfd,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       r = _bfd_final_link_relocate (howto, input_bfd, input_section,"
    },
    {
      "sha": "c45f0b35042877cc051ffe5984ac2887f101637a",
      "filename": "bfd/elf32-epiphany.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-epiphany.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-epiphany.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-epiphany.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -518,7 +518,7 @@ epiphany_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "0d299c64b616ea2e64a832440a00336fdd829a36",
      "filename": "bfd/elf32-fr30.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-fr30.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-fr30.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-fr30.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -549,7 +549,7 @@ fr30_elf_relocate_section (bfd *output_bfd,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "7770687f55781a9bb1d8e04121f73c1ae6551567",
      "filename": "bfd/elf32-frv.c",
      "status": "modified",
      "additions": 13,
      "deletions": 17,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-frv.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2736,7 +2736,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n \t  if (name == NULL || name[0] == 0)\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n       else\n \t{\n@@ -3566,8 +3566,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t    && (!h || FRVFDPIC_FUNCDESC_LOCAL (info, h)))\n \t\t  {\n \t\t    addend += frvfdpic_got_section (info)->output_section->vma;\n-\t\t    if ((bfd_get_section_flags (output_bfd,\n-\t\t\t\t\t\tinput_section->output_section)\n+\t\t    if ((bfd_section_flags (input_section->output_section)\n \t\t\t & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \t\t      {\n \t\t\tbfd_vma offset;\n@@ -3597,8 +3596,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t picrel);\n \t\t      }\n \t\t  }\n-\t\telse if ((bfd_get_section_flags (output_bfd,\n-\t\t\t\t\t\t input_section->output_section)\n+\t\telse if ((bfd_section_flags (input_section->output_section)\n \t\t\t  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \t\t  {\n \t\t    bfd_vma offset;\n@@ -3691,8 +3689,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\tif (osec)\n \t\t  addend += osec->output_section->vma;\n \t\tif (IS_FDPIC (input_bfd)\n-\t\t    && (bfd_get_section_flags (output_bfd,\n-\t\t\t\t\t       input_section->output_section)\n+\t\t    && (bfd_section_flags (input_section->output_section)\n \t\t\t& (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \t\t  {\n \t\t    if (_frvfdpic_osec_readonly_p (output_bfd,\n@@ -3732,8 +3729,7 @@ elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t      }\n \t    else\n \t      {\n-\t\tif ((bfd_get_section_flags (output_bfd,\n-\t\t\t\t\t    input_section->output_section)\n+\t\tif ((bfd_section_flags (input_section->output_section)\n \t\t     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \t\t  {\n \t\t    bfd_vma offset;\n@@ -4192,7 +4188,7 @@ _frv_create_got_section (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   elf_hash_table (info)->sgot = s;\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (bed->want_got_sym)\n@@ -4230,14 +4226,14 @@ _frv_create_got_section (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t      (flags | SEC_READONLY));\n       elf_hash_table (info)->srelgot = s;\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n \n       /* Machine-specific.  */\n       s = bfd_make_section_anyway_with_flags (abfd, \".rofixup\",\n \t\t\t\t\t      (flags | SEC_READONLY));\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n \n       frvfdpic_gotfixup_section (info) = s;\n@@ -4285,7 +4281,7 @@ _frv_create_got_section (bfd *abfd, struct bfd_link_info *info)\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n   /* FRV-specific: remember it.  */\n   frvfdpic_plt_section (info) = s;\n@@ -4305,7 +4301,7 @@ _frv_create_got_section (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".rel.plt\",\n \t\t\t\t\t  flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   /* FRV-specific: remember it.  */\n   frvfdpic_pltrel_section (info) = s;\n@@ -4373,7 +4369,7 @@ elf32_frvfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t   ? \".rela.bss\" : \".rel.bss\"),\n \t\t\t\t\t\t  flags | SEC_READONLY);\n \t  if (s == NULL\n-\t      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+\t      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \t    return FALSE;\n \t}\n     }\n@@ -6137,7 +6133,7 @@ elf32_frv_check_relocs (bfd *abfd,\n \n \tcase R_FRV_FUNCDESC_VALUE:\n \t  picrel->relocsfdv++;\n-\t  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)\n+\t  if (bfd_section_flags (sec) & SEC_ALLOC)\n \t    picrel->relocs32--;\n \t  /* Fall through.  */\n \n@@ -6146,7 +6142,7 @@ elf32_frv_check_relocs (bfd *abfd,\n \t    break;\n \n \t  picrel->sym = 1;\n-\t  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)\n+\t  if (bfd_section_flags (sec) & SEC_ALLOC)\n \t    picrel->relocs32++;\n \t  break;\n "
    },
    {
      "sha": "b8e69e5a2484b24312ab1bd9d4473280a2022e84",
      "filename": "bfd/elf32-ft32.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-ft32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-ft32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ft32.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -389,7 +389,7 @@ ft32_elf_relocate_section (bfd *output_bfd,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "ba7c8b2062d98280e4d35bb63982b4daf4aa00a2",
      "filename": "bfd/elf32-h8300.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-h8300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-h8300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-h8300.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -502,7 +502,7 @@ elf32_h8_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)"
    },
    {
      "sha": "f065449b15ec97f3c6486c67d59606f807ef6d37",
      "filename": "bfd/elf32-hppa.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-hppa.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2270,12 +2270,12 @@ elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t      /* Make space for the plt stub at the end of the .plt\n \t\t section.  We want this stub right at the end, up\n \t\t against the .got section.  */\n-\t      int gotalign = bfd_section_alignment (dynobj, htab->etab.sgot);\n-\t      int pltalign = bfd_section_alignment (dynobj, sec);\n+\t      int gotalign = bfd_section_alignment (htab->etab.sgot);\n+\t      int pltalign = bfd_section_alignment (sec);\n \t      bfd_size_type mask;\n \n \t      if (gotalign > pltalign)\n-\t\t(void) bfd_set_section_alignment (dynobj, sec, gotalign);\n+\t\tbfd_set_section_alignment (sec, gotalign);\n \t      mask = ((bfd_size_type) 1 << gotalign) - 1;\n \t      sec->size = (sec->size + sizeof (plt_stub) + mask) & ~mask;\n \t    }\n@@ -2284,7 +2284,7 @@ elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t       || sec == htab->etab.sdynbss\n \t       || sec == htab->etab.sdynrelro)\n \t;\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, sec), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (sec), \".rela\"))\n \t{\n \t  if (sec->size != 0)\n \t    {\n@@ -4151,7 +4151,7 @@ elf32_hppa_relocate_section (bfd *output_bfd,\n \t\t    if (sym_name == NULL)\n \t\t      return FALSE;\n \t\t    if (*sym_name == '\\0')\n-\t\t      sym_name = bfd_section_name (input_bfd, sym_sec);\n+\t\t      sym_name = bfd_section_name (sym_sec);\n \t\t    _bfd_error_handler\n \t\t      (_(\"%pB:%s has both normal and TLS relocs\"),\n \t\t       input_bfd, sym_name);\n@@ -4201,7 +4201,7 @@ elf32_hppa_relocate_section (bfd *output_bfd,\n \t  if (sym_name == NULL)\n \t    return FALSE;\n \t  if (*sym_name == '\\0')\n-\t    sym_name = bfd_section_name (input_bfd, sym_sec);\n+\t    sym_name = bfd_section_name (sym_sec);\n \t}\n \n       howto = elf_hppa_howto_table + r_type;"
    },
    {
      "sha": "9248ef5a41803b8de7b8c79869f710f7864bc3ac",
      "filename": "bfd/elf32-i386.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-i386.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1948,7 +1948,7 @@ elf_i386_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,\n {\n   const char *name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   /* This is an ugly, but unfortunately necessary hack that is\n      needed when producing EFI binaries on x86. It tells\n@@ -3429,7 +3429,7 @@ elf_i386_relocate_section (bfd *output_bfd,\n \t      if (name == NULL)\n \t\treturn FALSE;\n \t      if (*name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (r == bfd_reloc_overflow)"
    },
    {
      "sha": "6e5131ff98be74276a230c2e538bc134fba548df",
      "filename": "bfd/elf32-ip2k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-ip2k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-ip2k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ip2k.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1435,7 +1435,7 @@ ip2k_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "e95f1a56eacd332f50762d41769e60ba83771710",
      "filename": "bfd/elf32-iq2000.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-iq2000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-iq2000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-iq2000.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -625,7 +625,7 @@ iq2000_elf_relocate_section (bfd *\t\t     output_bfd ATTRIBUTE_UNUSED,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, osec) : name;\n+\t  name = name == NULL ? bfd_section_name (osec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "0601f1454b48968ebd050ef46a7cf6da582ddc70",
      "filename": "bfd/elf32-lm32.c",
      "status": "modified",
      "additions": 10,
      "deletions": 11,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-lm32.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -195,8 +195,7 @@ create_rofixup_section (bfd *dynobj, struct bfd_link_info *info)\n \t\t\t\t\t   | SEC_LINKER_CREATED\n \t\t\t\t\t   | SEC_READONLY));\n   if (lm32fdpic_fixup32_section (info) == NULL\n-      || ! bfd_set_section_alignment (dynobj,\n-\t\t\t\t      lm32fdpic_fixup32_section (info), 2))\n+      || !bfd_set_section_alignment (lm32fdpic_fixup32_section (info), 2))\n     return FALSE;\n \n   return TRUE;\n@@ -821,7 +820,7 @@ lm32_elf_relocate_section (bfd *output_bfd,\n \t  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);\n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{\n@@ -1036,7 +1035,7 @@ lm32_elf_relocate_section (bfd *output_bfd,\n \t\t  if ((!h) || (h && h->root.type != bfd_link_hash_undefweak))\n \t\t    {\n \t\t      /* Only create .rofixup entries for relocs in loadable sections.  */\n-\t\t      if ((bfd_get_section_flags (output_bfd, input_section->output_section)\n+\t\t      if ((bfd_section_flags (input_section->output_section)\n \t\t\t  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))\n \n \t\t\t{\n@@ -1090,7 +1089,7 @@ lm32_elf_relocate_section (bfd *output_bfd,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)\n@@ -2120,7 +2119,7 @@ lm32_elf_size_dynamic_sections (bfd *output_bfd,\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0 && s != htab->root.srelplt)\n \t    relocs = TRUE;\n@@ -2255,7 +2254,7 @@ lm32_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t\t  /* Don't generate entries for weak symbols.  */\n \t\t\t  if (!h || (h && h->root.type != bfd_link_hash_undefweak))\n \t\t\t    {\n-\t\t\t      if (!discarded_section (s) && !((bfd_get_section_flags (ibfd, s) & SEC_ALLOC) == 0))\n+\t\t\t      if (!discarded_section (s) && !((bfd_section_flags (s) & SEC_ALLOC) == 0))\n \t\t\t\t{\n \t\t\t\t  switch (ELF32_R_TYPE (internal_relocs->r_info))\n \t\t\t\t    {\n@@ -2277,7 +2276,7 @@ lm32_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t\t\t  if (!strcmp (current->name, h->root.root.string))\n \t\t\t\t    break;\n \t\t\t\t}\n-\t\t\t      if (!current && !discarded_section (s) && (bfd_get_section_flags (ibfd, s) & SEC_ALLOC))\n+\t\t\t      if (!current && !discarded_section (s) && (bfd_section_flags (s) & SEC_ALLOC))\n \t\t\t\t{\n \t\t\t\t  /* Will this have an entry in the GOT.  */\n \t\t\t\t  if (ELF32_R_TYPE (internal_relocs->r_info) == R_LM32_16_GOT)\n@@ -2377,7 +2376,7 @@ lm32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n   htab->root.splt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n \n   if (bed->want_plt_sym)\n@@ -2408,7 +2407,7 @@ lm32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  flags | SEC_READONLY);\n   htab->root.srelplt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (htab->root.sgot == NULL\n@@ -2447,7 +2446,7 @@ lm32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t  flags | SEC_READONLY);\n \t  htab->srelbss = s;\n \t  if (s == NULL\n-\t      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+\t      || !bfd_set_section_alignment (s, ptralign))\n \t    return FALSE;\n \t}\n     }"
    },
    {
      "sha": "e3f03cc045adf70b740dd237f6423a5061991543",
      "filename": "bfd/elf32-m32c.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-m32c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-m32c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32c.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -450,7 +450,7 @@ m32c_elf_relocate_section\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (sym->st_name == 0) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = sym->st_name == 0 ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{\n@@ -709,7 +709,7 @@ m32c_elf_check_relocs\n \t\t\t\t\t\t\t flags);\n \t      elf_hash_table (info)->splt = splt;\n \t      if (splt == NULL\n-\t\t  || ! bfd_set_section_alignment (dynobj, splt, 1))\n+\t\t  || !bfd_set_section_alignment (splt, 1))\n \t\treturn FALSE;\n \t    }\n "
    },
    {
      "sha": "edd04b91d9d771472c2cd05368bb1f5b0063ebae",
      "filename": "bfd/elf32-m32r.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32r.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1322,7 +1322,7 @@ _bfd_m32r_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t\tasection *sec,\n \t\t\t\t\tint *retval)\n {\n-  if (strcmp (bfd_get_section_name (abfd, sec), \".scommon\") == 0)\n+  if (strcmp (bfd_section_name (sec), \".scommon\") == 0)\n     {\n       *retval = SHN_M32R_SCOMMON;\n       return TRUE;\n@@ -1407,7 +1407,7 @@ m32r_elf_add_symbol_hook (bfd *abfd,\n \t\t\t\t\t\t  flags);\n \t  if (s == NULL)\n \t    return FALSE;\n-\t  if (! bfd_set_section_alignment (abfd, s, 2))\n+\t  if (!bfd_set_section_alignment (s, 2))\n \t    return FALSE;\n \t}\n \n@@ -1623,7 +1623,7 @@ m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n   htab->root.splt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n \n   if (bed->want_plt_sym)\n@@ -1654,7 +1654,7 @@ m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  flags | SEC_READONLY);\n   htab->root.srelplt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (htab->root.sgot == NULL\n@@ -1693,7 +1693,7 @@ m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t  flags | SEC_READONLY);\n \t  htab->srelbss = s;\n \t  if (s == NULL\n-\t      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+\t      || !bfd_set_section_alignment (s, ptralign))\n \t    return FALSE;\n \t}\n     }\n@@ -2234,7 +2234,7 @@ m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0 && s != htab->root.srelplt)\n \t    relocs = TRUE;\n@@ -2954,7 +2954,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\tconst char *name;\n \n \t\tBFD_ASSERT (sec != NULL);\n-\t\tname = bfd_get_section_name (sec->owner, sec);\n+\t\tname = bfd_section_name (sec);\n \n \t\tif (   strcmp (name, \".sdata\") == 0\n \t\t    || strcmp (name, \".sbss\") == 0\n@@ -3022,7 +3022,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (errmsg != NULL)"
    },
    {
      "sha": "8739ca86c13a4810f0c1d22ea4938e5c6613f47d",
      "filename": "bfd/elf32-m68hc1x.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-m68hc1x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-m68hc1x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68hc1x.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -267,7 +267,7 @@ elf32_m68hc11_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)\n \t   section != NULL;\n \t   section = section->next)\n \t{\n-\t  const char* name = bfd_get_section_name (input_bfd, section);\n+\t  const char *name = bfd_section_name (section);\n \n \t  if (!strcmp (name, \".tramp\"))\n \t    htab->tramp_section = section;\n@@ -1014,7 +1014,7 @@ elf32_m68hc11_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       if (is_far && ELF32_R_TYPE (rel->r_info) == R_M68HC11_16)"
    },
    {
      "sha": "559578d81827ea538571fddf2d94d91875a0f5b5",
      "filename": "bfd/elf32-m68k.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-m68k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-m68k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68k.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3104,7 +3104,7 @@ elf_m68k_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (strcmp (name, \".plt\") == 0)\n \t{\n@@ -3938,7 +3938,7 @@ elf_m68k_relocate_section (bfd *output_bfd,\n \t\t  name = (bfd_elf_string_from_elf_section\n \t\t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t\t  if (name == NULL || *name == '\\0')\n-\t\t    name = bfd_section_name (input_bfd, sec);\n+\t\t    name = bfd_section_name (sec);\n \t\t}\n \n \t      _bfd_error_handler\n@@ -3973,7 +3973,7 @@ elf_m68k_relocate_section (bfd *output_bfd,\n \t      if (name == NULL)\n \t\treturn FALSE;\n \t      if (*name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (r == bfd_reloc_overflow)"
    },
    {
      "sha": "3a58ff3038be35c4522e39aba5b2eccab18fa514",
      "filename": "bfd/elf32-mcore.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-mcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-mcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-mcore.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -536,7 +536,7 @@ mcore_elf_relocate_section (bfd * output_bfd,\n \t\t      break;\n \n \t\t    if (* name == '\\0')\n-\t\t      name = bfd_section_name (input_bfd, sec);\n+\t\t      name = bfd_section_name (sec);\n \t\t  }\n \n \t\t(*info->callbacks->reloc_overflow)"
    },
    {
      "sha": "f46e3bcbe36e633217592da5d7bf28a68129f554",
      "filename": "bfd/elf32-mep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-mep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-mep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-mep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -477,7 +477,7 @@ mep_elf_relocate_section\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "e3df8c56843bf83d4e65b78cd25fd93c39651b70",
      "filename": "bfd/elf32-metag.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-metag.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1519,7 +1519,7 @@ elf_metag_relocate_section (bfd *output_bfd,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{\n@@ -2934,7 +2934,7 @@ elf_metag_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0 && s != htab->etab.srelplt)\n \t    relocs = TRUE;"
    },
    {
      "sha": "c187d83ee046a26265c96cac393299190c62c952",
      "filename": "bfd/elf32-microblaze.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-microblaze.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1071,7 +1071,7 @@ microblaze_elf_relocate_section (bfd *output_bfd,\n \t\t/* Only relocate if the symbol is defined.  */\n \t\tif (sec)\n \t\t  {\n-\t\t    name = bfd_get_section_name (sec->owner, sec);\n+\t\t    name = bfd_section_name (sec);\n \n \t\t    if (strcmp (name, \".sdata2\") == 0\n \t\t\t|| strcmp (name, \".sbss2\") == 0)\n@@ -1119,7 +1119,7 @@ microblaze_elf_relocate_section (bfd *output_bfd,\n \t\t/* Only relocate if the symbol is defined.  */\n \t\tif (sec)\n \t\t  {\n-\t\t    name = bfd_get_section_name (sec->owner, sec);\n+\t\t    name = bfd_section_name (sec);\n \n \t\t    if (strcmp (name, \".sdata\") == 0\n \t\t\t|| strcmp (name, \".sbss\") == 0)\n@@ -1608,7 +1608,7 @@ microblaze_elf_relocate_section (bfd *output_bfd,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (errmsg != NULL)\n@@ -2766,7 +2766,7 @@ microblaze_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n   s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));\n   if (power_of_two > s->alignment_power)\n     {\n-      if (!bfd_set_section_alignment (s->owner, s, power_of_two))\n+      if (!bfd_set_section_alignment (s, power_of_two))\n \treturn FALSE;\n     }\n \n@@ -3115,7 +3115,7 @@ microblaze_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (strncmp (name, \".rela\", 5) == 0)\n \t{\n@@ -3501,7 +3501,7 @@ microblaze_elf_add_symbol_hook (bfd *abfd,\n \t put into .sbss.  */\n       *secp = bfd_make_section_old_way (abfd, \".sbss\");\n       if (*secp == NULL\n-\t  || ! bfd_set_section_flags (abfd, *secp, SEC_IS_COMMON))\n+\t  || !bfd_set_section_flags (*secp, SEC_IS_COMMON))\n \treturn FALSE;\n \n       *valp = sym->st_size;"
    },
    {
      "sha": "9b6048f0c0054b06bc442962b51ff1119b0004b4",
      "filename": "bfd/elf32-moxie.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-moxie.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-moxie.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-moxie.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -243,7 +243,7 @@ moxie_elf_relocate_section (bfd *output_bfd,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "4dcc8d480da870c4f263b45cbccd3803a2d4227d",
      "filename": "bfd/elf32-msp430.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-msp430.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-msp430.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-msp430.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1314,7 +1314,7 @@ elf32_msp430_relocate_section (bfd * output_bfd ATTRIBUTE_UNUSED,\n \n \t  name = bfd_elf_string_from_elf_section\n \t      (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL || * name == 0) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL || *name == 0 ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{\n@@ -1691,7 +1691,7 @@ msp430_elf_relax_delete_bytes (bfd * abfd, asection * sec, bfd_vma addr,\n \n       name = bfd_elf_string_from_elf_section\n \t(abfd, symtab_hdr->sh_link, isym->st_name);\n-      name = (name == NULL || * name == 0) ? bfd_section_name (abfd, sec) : name;\n+      name = name == NULL || *name == 0 ? bfd_section_name (sec) : name;\n \n       if (isym->st_shndx != sec_shndx)\n \tcontinue;"
    },
    {
      "sha": "d120d0548285920ac5fd06868d77aee34ffcbd88",
      "filename": "bfd/elf32-mt.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-mt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-mt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-mt.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -346,7 +346,7 @@ mt_elf_relocate_section\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "013355a490802f446e016dfe4f52f7731bf5f9b3",
      "filename": "bfd/elf32-nds32.c",
      "status": "modified",
      "additions": 21,
      "deletions": 22,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3723,11 +3723,11 @@ create_got_section (bfd *dynobj, struct bfd_link_info *info)\n   /* _bfd_elf_create_got_section will create it for us.  */\n   ehtab->srelgot = bfd_get_section_by_name (dynobj, \".rela.got\");\n   if (ehtab->srelgot == NULL\n-      || !bfd_set_section_flags (dynobj, ehtab->srelgot,\n+      || !bfd_set_section_flags (ehtab->srelgot,\n \t\t\t\t (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS\n \t\t\t\t  | SEC_IN_MEMORY | SEC_LINKER_CREATED\n \t\t\t\t  | SEC_READONLY))\n-      || !bfd_set_section_alignment (dynobj, ehtab->srelgot, 2))\n+      || !bfd_set_section_alignment (ehtab->srelgot, 2))\n     return FALSE;\n \n   return TRUE;\n@@ -3769,8 +3769,8 @@ nds32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section (abfd, \".plt\");\n   ehtab->splt = s;\n   if (s == NULL\n-      || !bfd_set_section_flags (abfd, s, pltflags)\n-      || !bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_flags (s, pltflags)\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n \n   if (bed->want_plt_sym)\n@@ -3798,29 +3798,29 @@ nds32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\tbed->default_use_rela_p ? \".rela.plt\" : \".rel.plt\");\n   ehtab->srelplt = s;\n   if (s == NULL\n-      || !bfd_set_section_flags (abfd, s, flags | SEC_READONLY)\n-      || !bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_flags (s, flags | SEC_READONLY)\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (ehtab->sgot == NULL && !create_got_section (abfd, info))\n     return FALSE;\n \n   for (sec = abfd->sections; sec; sec = sec->next)\n     {\n-      secflags = bfd_get_section_flags (abfd, sec);\n+      secflags = bfd_section_flags (sec);\n       if ((secflags & (SEC_DATA | SEC_LINKER_CREATED))\n \t  || ((secflags & SEC_HAS_CONTENTS) != SEC_HAS_CONTENTS))\n \tcontinue;\n-      secname = bfd_get_section_name (abfd, sec);\n+      secname = bfd_section_name (sec);\n       relname = (char *) bfd_malloc ((bfd_size_type) strlen (secname) + 6);\n       strcpy (relname, \".rela\");\n       strcat (relname, secname);\n       if (bfd_get_section_by_name (abfd, secname))\n \tcontinue;\n       s = bfd_make_section (abfd, relname);\n       if (s == NULL\n-\t  || !bfd_set_section_flags (abfd, s, flags | SEC_READONLY)\n-\t  || !bfd_set_section_alignment (abfd, s, ptralign))\n+\t  || !bfd_set_section_flags (s, flags | SEC_READONLY)\n+\t  || !bfd_set_section_alignment (s, ptralign))\n \treturn FALSE;\n     }\n \n@@ -3835,7 +3835,7 @@ nds32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section (abfd, \".dynbss\");\n       htab->sdynbss = s;\n       if (s == NULL\n-\t  || !bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))\n+\t  || !bfd_set_section_flags (s, SEC_ALLOC | SEC_LINKER_CREATED))\n \treturn FALSE;\n       /* The .rel[a].bss section holds copy relocs.  This section is not\n \t normally needed.  We need to create it here, though, so that the\n@@ -3854,8 +3854,8 @@ nds32_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t       ? \".rela.bss\" : \".rel.bss\"));\n \t  htab->srelbss = s;\n \t  if (s == NULL\n-\t      || !bfd_set_section_flags (abfd, s, flags | SEC_READONLY)\n-\t      || !bfd_set_section_alignment (abfd, s, ptralign))\n+\t      || !bfd_set_section_flags (s, flags | SEC_READONLY)\n+\t      || !bfd_set_section_alignment (s, ptralign))\n \t    return FALSE;\n \t}\n     }\n@@ -4065,9 +4065,9 @@ nds32_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* Apply the required alignment.  */\n   s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));\n-  if (power_of_two > bfd_get_section_alignment (dynobj, s))\n+  if (power_of_two > bfd_section_alignment (s))\n     {\n-      if (!bfd_set_section_alignment (dynobj, s, power_of_two))\n+      if (!bfd_set_section_alignment (s, power_of_two))\n \treturn FALSE;\n     }\n \n@@ -4525,7 +4525,7 @@ nds32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t{\n \t  got_size += s->size;\n \t}\n-      else if (strncmp (bfd_get_section_name (dynobj, s), \".rela\", 5) == 0)\n+      else if (strncmp (bfd_section_name (s), \".rela\", 5) == 0)\n \t{\n \t  if (s->size != 0 && s != elf_hash_table (info)->srelplt)\n \t    relocs = TRUE;\n@@ -5571,8 +5571,7 @@ nds32_elf_relocate_section (bfd *\t\t   output_bfd ATTRIBUTE_UNUSED,\n \t\t    return FALSE;\n \n \t\t  BFD_ASSERT (strncmp (name, \".rela\", 5) == 0\n-\t\t\t      && strcmp (bfd_get_section_name (input_bfd,\n-\t\t\t\t\t\t\t       input_section),\n+\t\t\t      && strcmp (bfd_section_name (input_section),\n \t\t\t\t\t name + 5) == 0);\n \n \t\t  sreloc = bfd_get_section_by_name (dynobj, name);\n@@ -6166,7 +6165,7 @@ nds32_elf_relocate_section (bfd *\t\t   output_bfd ATTRIBUTE_UNUSED,\n \t      name = bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name);\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (errmsg != NULL)\n@@ -7390,7 +7389,7 @@ nds32_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t    return FALSE;\n \n \t\t  BFD_ASSERT (strncmp (name, \".rela\", 5) == 0\n-\t\t\t      && strcmp (bfd_get_section_name (abfd, sec),\n+\t\t\t      && strcmp (bfd_section_name (sec),\n \t\t\t\t\t name + 5) == 0);\n \n \t\t  sreloc = bfd_get_section_by_name (dynobj, name);\n@@ -7404,8 +7403,8 @@ nds32_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t      if ((sec->flags & SEC_ALLOC) != 0)\n \t\t\tflags |= SEC_ALLOC | SEC_LOAD;\n \t\t      if (sreloc == NULL\n-\t\t\t  || !bfd_set_section_flags (dynobj, sreloc, flags)\n-\t\t\t  || !bfd_set_section_alignment (dynobj, sreloc, 2))\n+\t\t\t  || !bfd_set_section_flags (sreloc, flags)\n+\t\t\t  || !bfd_set_section_alignment (sreloc, 2))\n \t\t\treturn FALSE;\n \n \t\t      elf_section_type (sreloc) = SHT_RELA;"
    },
    {
      "sha": "698e4e5c2d41477a365d4ba02fc69a24659c5f80",
      "filename": "bfd/elf32-nios2.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-nios2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-nios2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nios2.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3846,7 +3846,7 @@ nios2_elf32_relocate_section (bfd *output_bfd,\n \t\t\t\t  (input_bfd, symtab_hdr->sh_link,\n \t\t\t\t   sym->st_name));\n \t\t\t  if (name == NULL || *name == '\\0')\n-\t\t\t    name = bfd_section_name (input_bfd, sec);\n+\t\t\t    name = bfd_section_name (sec);\n \t\t\t}\n \t\t      /* xgettext:c-format */\n \t\t      format = _(\"unable to reach %s (at %#\" PRIx64 \") from \"\n@@ -4484,7 +4484,7 @@ nios2_elf32_relocate_section (bfd *output_bfd,\n \t\t\t\t\t\t      symtab_hdr->sh_link,\n \t\t\t\t\t\t      sym->st_name);\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)\n@@ -4554,7 +4554,7 @@ static bfd_boolean\n nios2_elf32_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t   Elf_Internal_Shdr *hdr, asection *sec)\n {\n-  register const char *name = bfd_get_section_name (abfd, sec);\n+  const char *name = bfd_section_name (sec);\n \n   if ((sec->flags & SEC_SMALL_DATA)\n       || strcmp (name, \".sdata\") == 0\n@@ -4580,7 +4580,7 @@ create_got_section (bfd *dynobj, struct bfd_link_info *info)\n \n   /* In order for the two loads in .PLTresolve to share the same %hiadj,\n      _GLOBAL_OFFSET_TABLE_ must be aligned to a 16-byte boundary.  */\n-  if (!bfd_set_section_alignment (dynobj, htab->root.sgotplt, 4))\n+  if (!bfd_set_section_alignment (htab->root.sgotplt, 4))\n     return FALSE;\n \n   /* The Nios II ABI specifies that GOT-relative relocations are relative\n@@ -4616,7 +4616,7 @@ nios2_elf32_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)\n      same %hiadj, the start of the PLT (as well as the GOT) must be aligned\n      to a 16-byte boundary.  This is because the addresses for these loads\n      include the -(.plt+4) PIC correction.  */\n-  return bfd_set_section_alignment (dynobj, htab->root.splt, 4);\n+  return bfd_set_section_alignment (htab->root.splt, 4);\n }\n \n /* Implement elf_backend_copy_indirect_symbol:\n@@ -5429,8 +5429,8 @@ nios2_elf32_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n   /* Align dynbss.  */\n   s->size = BFD_ALIGN (s->size, (bfd_size_type)1 << align2);\n-  if (align2 > bfd_get_section_alignment (dynobj, s)\n-      && !bfd_set_section_alignment (dynobj, s, align2))\n+  if (align2 > bfd_section_alignment (s)\n+      && !bfd_set_section_alignment (s, align2))\n     return FALSE;\n \n   /* Define the symbol as being at this point in the section.  */\n@@ -5853,7 +5853,7 @@ nios2_elf32_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (CONST_STRNEQ (name, \".rela\"))\n \t{"
    },
    {
      "sha": "4cf0b7cc36ce307b50293a70d29366cb1fdc1fea",
      "filename": "bfd/elf32-or1k.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-or1k.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1303,7 +1303,7 @@ or1k_elf_relocate_section (bfd *output_bfd,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{\n@@ -2064,8 +2064,7 @@ or1k_elf_check_relocs (bfd *abfd,\n \t\t      return FALSE;\n \n \t\t    if (strncmp (name, \".rela\", 5) != 0\n-\t\t\t|| strcmp (bfd_get_section_name (abfd, sec),\n-\t\t\t\t   name + 5) != 0)\n+\t\t\t|| strcmp (bfd_section_name (sec), name + 5) != 0)\n \t\t      {\n \t\t\t_bfd_error_handler\n \t\t\t  /* xgettext:c-format */\n@@ -2996,7 +2995,7 @@ or1k_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0 && s != htab->root.srelplt)\n \t    relocs = TRUE;"
    },
    {
      "sha": "9765a33541f1f18a7713930fad9f17755cf0d267",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 23,
      "deletions": 26,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1329,14 +1329,14 @@ ppc_elf_section_from_shdr (bfd *abfd,\n     return FALSE;\n \n   newsect = hdr->bfd_section;\n-  flags = bfd_get_section_flags (abfd, newsect);\n+  flags = bfd_section_flags (newsect);\n   if (hdr->sh_flags & SHF_EXCLUDE)\n     flags |= SEC_EXCLUDE;\n \n   if (hdr->sh_type == SHT_ORDERED)\n     flags |= SEC_SORT_ENTRIES;\n \n-  bfd_set_section_flags (abfd, newsect, flags);\n+  bfd_set_section_flags (newsect, flags);\n   return TRUE;\n }\n \n@@ -1674,7 +1674,7 @@ ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)\n       /* Set the output section size, if it exists.  */\n       asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);\n \n-      if (asec && ! bfd_set_section_size (abfd, asec, 20 + num_entries * 4))\n+      if (asec && !bfd_set_section_size (asec, 20 + num_entries * 4))\n \t{\n \t  ibfd = abfd;\n \t  /* xgettext:c-format */\n@@ -2337,7 +2337,7 @@ ppc_elf_create_got (bfd *abfd, struct bfd_link_info *info)\n \t executable.  */\n       flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS\n \t\t\t| SEC_IN_MEMORY | SEC_LINKER_CREATED);\n-      if (!bfd_set_section_flags (abfd, htab->elf.sgot, flags))\n+      if (!bfd_set_section_flags (htab->elf.sgot, flags))\n \treturn FALSE;\n     }\n \n@@ -2390,7 +2390,7 @@ ppc_elf_create_glink (bfd *abfd, struct bfd_link_info *info)\n   if (p2align < htab->params->plt_stub_align)\n     p2align = htab->params->plt_stub_align;\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, p2align))\n+      || !bfd_set_section_alignment (s, p2align))\n     return FALSE;\n \n   if (!info->no_ld_generated_unwind_info)\n@@ -2400,23 +2400,23 @@ ppc_elf_create_glink (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, \".eh_frame\", flags);\n       htab->glink_eh_frame = s;\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n     }\n \n   flags = SEC_ALLOC | SEC_LINKER_CREATED;\n   s = bfd_make_section_anyway_with_flags (abfd, \".iplt\", flags);\n   htab->elf.iplt = s;\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 4))\n+      || !bfd_set_section_alignment (s, 4))\n     return FALSE;\n \n   flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS\n \t   | SEC_IN_MEMORY | SEC_LINKER_CREATED);\n   s = bfd_make_section_anyway_with_flags (abfd, \".rela.iplt\", flags);\n   htab->elf.irelplt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, 2))\n+      || ! bfd_set_section_alignment (s, 2))\n     return FALSE;\n \n   /* Local plt entries.  */\n@@ -2425,7 +2425,7 @@ ppc_elf_create_glink (bfd *abfd, struct bfd_link_info *info)\n   htab->pltlocal = bfd_make_section_anyway_with_flags (abfd, \".branch_lt\",\n \t\t\t\t\t\t       flags);\n   if (htab->pltlocal == NULL\n-      || ! bfd_set_section_alignment (abfd, htab->pltlocal, 2))\n+      || !bfd_set_section_alignment (htab->pltlocal, 2))\n     return FALSE;\n \n   if (bfd_link_pic (info))\n@@ -2435,7 +2435,7 @@ ppc_elf_create_glink (bfd *abfd, struct bfd_link_info *info)\n       htab->relpltlocal\n \t= bfd_make_section_anyway_with_flags (abfd, \".rela.branch_lt\", flags);\n       if (htab->relpltlocal == NULL\n-\t  || ! bfd_set_section_alignment (abfd, htab->relpltlocal, 2))\n+\t  || !bfd_set_section_alignment (htab->relpltlocal, 2))\n \treturn FALSE;\n     }\n \n@@ -2487,7 +2487,7 @@ ppc_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, \".rela.sbss\", flags);\n       htab->relsbss = s;\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n     }\n \n@@ -2500,7 +2500,7 @@ ppc_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   if (htab->plt_type == PLT_VXWORKS)\n     /* The VxWorks PLT is a loaded section with contents.  */\n     flags |= SEC_HAS_CONTENTS | SEC_LOAD | SEC_READONLY;\n-  return bfd_set_section_flags (abfd, s, flags);\n+  return bfd_set_section_flags (s, flags);\n }\n \n /* Copy the extra info we tack onto an elf_link_hash_entry.  */\n@@ -2739,7 +2739,7 @@ elf_allocate_pointer_linker_section (bfd *abfd,\n   linker_section_ptr->lsect = lsect;\n   *ptr_linker_section_ptr = linker_section_ptr;\n \n-  if (!bfd_set_section_alignment (lsect->section->owner, lsect->section, 2))\n+  if (!bfd_set_section_alignment (lsect->section, 2))\n     return FALSE;\n   linker_section_ptr->offset = lsect->section->size;\n   lsect->section->size += 4;\n@@ -4029,19 +4029,19 @@ ppc_elf_select_plt_layout (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* The new PLT is a loaded section.  */\n       if (htab->elf.splt != NULL\n-\t  && !bfd_set_section_flags (htab->elf.dynobj, htab->elf.splt, flags))\n+\t  && !bfd_set_section_flags (htab->elf.splt, flags))\n \treturn -1;\n \n       /* The new GOT is not executable.  */\n       if (htab->elf.sgot != NULL\n-\t  && !bfd_set_section_flags (htab->elf.dynobj, htab->elf.sgot, flags))\n+\t  && !bfd_set_section_flags (htab->elf.sgot, flags))\n \treturn -1;\n     }\n   else\n     {\n       /* Stop an unused .glink section from affecting .text alignment.  */\n       if (htab->glink != NULL\n-\t  && !bfd_set_section_alignment (htab->elf.dynobj, htab->glink, 0))\n+\t  && !bfd_set_section_alignment (htab->glink, 0))\n \treturn -1;\n     }\n   return htab->plt_type == PLT_NEW;\n@@ -5823,8 +5823,7 @@ ppc_elf_size_dynamic_sections (bfd *output_bfd,\n \t{\n \t  strip_section = (s->flags & SEC_KEEP) == 0;\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (htab->elf.dynobj, s),\n-\t\t\t     \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0)\n \t    {\n@@ -8394,10 +8393,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t      unresolved_reloc = TRUE;\n \t      break;\n \t    }\n-\t  BFD_ASSERT (strcmp (bfd_get_section_name (sec->owner, sec),\n-\t\t\t      \".got\") == 0\n-\t\t      || strcmp (bfd_get_section_name (sec->owner, sec),\n-\t\t\t\t \".cgot\") == 0);\n+\t  BFD_ASSERT (strcmp (bfd_section_name (sec), \".got\") == 0\n+\t\t      || strcmp (bfd_section_name (sec), \".cgot\") == 0);\n \n \t  addend -= sec->output_section->vma + sec->output_offset + 0x8000;\n \t  break;\n@@ -8512,7 +8509,7 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t      }\n \t    addend -= SYM_VAL (sda);\n \n-\t    name = bfd_get_section_name (output_bfd, sec->output_section);\n+\t    name = bfd_section_name (sec->output_section);\n \t    if (!(strcmp (name, \".sdata\") == 0\n \t\t  || strcmp (name, \".sbss\") == 0))\n \t      {\n@@ -8543,7 +8540,7 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t      }\n \t    addend -= SYM_VAL (sda);\n \n-\t    name = bfd_get_section_name (output_bfd, sec->output_section);\n+\t    name = bfd_section_name (sec->output_section);\n \t    if (!(strcmp (name, \".sdata2\") == 0\n \t\t  || strcmp (name, \".sbss2\") == 0))\n \t      {\n@@ -8618,7 +8615,7 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t\tbreak;\n \t      }\n \n-\t    name = bfd_get_section_name (output_bfd, sec->output_section);\n+\t    name = bfd_section_name (sec->output_section);\n \t    if (strcmp (name, \".sdata\") == 0\n \t\t|| strcmp (name, \".sbss\") == 0)\n \t      {\n@@ -8725,7 +8722,7 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t\tbreak;\n \t      }\n \n-\t    name = bfd_get_section_name (output_bfd, sec->output_section);\n+\t    name = bfd_section_name (sec->output_section);\n \t    if (strcmp (name, \".sdata\") == 0\n \t\t|| strcmp (name, \".sbss\") == 0)\n \t      sda = htab->sdata[0].sym;"
    },
    {
      "sha": "054f1650f264a5930d4338a917c846bc4ff9b28d",
      "filename": "bfd/elf32-pru.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-pru.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-pru.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-pru.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -905,7 +905,7 @@ pru_elf32_relocate_section (bfd *output_bfd,\n \t\t\t\t\t\t      symtab_hdr->sh_link,\n \t\t\t\t\t\t      sym->st_name);\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)"
    },
    {
      "sha": "ba95515f7d51fc2b71b29de9b1ef819daaa657aa",
      "filename": "bfd/elf32-rl78.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-rl78.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-rl78.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rl78.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -726,7 +726,7 @@ rl78_elf_relocate_section\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (sym->st_name == 0) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = sym->st_name == 0 ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{\n@@ -1349,7 +1349,7 @@ rl78_elf_check_relocs\n \t\t\t\t\t\t\t flags);\n \t      elf_hash_table (info)->splt = splt;\n \t      if (splt == NULL\n-\t\t  || ! bfd_set_section_alignment (dynobj, splt, 1))\n+\t\t  || !bfd_set_section_alignment (splt, 1))\n \t\treturn FALSE;\n \t    }\n "
    },
    {
      "sha": "7978244f1e5a81ac280a8cb468e33b163c460c3d",
      "filename": "bfd/elf32-rx.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-rx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-rx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rx.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -543,7 +543,7 @@ rx_elf_relocate_section\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (sym->st_name == 0) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = sym->st_name == 0 ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "7e22d9666ab2b4a11960e6c291d446b6ecbff8bf",
      "filename": "bfd/elf32-s390.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-s390.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2003,7 +2003,7 @@ elf_s390_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0)\n \t    relocs = TRUE;\n@@ -3254,7 +3254,7 @@ elf_s390_relocate_section (bfd *output_bfd,\n \t      if (name == NULL)\n \t\treturn FALSE;\n \t      if (*name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (r == bfd_reloc_overflow)"
    },
    {
      "sha": "3d499ca07190adab387900cac7b5bc95634cacf4",
      "filename": "bfd/elf32-score.c",
      "status": "modified",
      "additions": 11,
      "deletions": 12,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-score.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-score.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-score.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1257,8 +1257,8 @@ score_elf_rel_dyn_section (bfd *dynobj, bfd_boolean create_p)\n \t\t\t\t\t\t    | SEC_LINKER_CREATED\n \t\t\t\t\t\t    | SEC_READONLY));\n       if (sreloc == NULL\n-\t  || ! bfd_set_section_alignment (dynobj, sreloc,\n-\t\t\t\t\t  SCORE_ELF_LOG_FILE_ALIGN (dynobj)))\n+\t  || !bfd_set_section_alignment (sreloc,\n+\t\t\t\t\t SCORE_ELF_LOG_FILE_ALIGN (dynobj)))\n \treturn NULL;\n     }\n   return sreloc;\n@@ -1431,7 +1431,7 @@ score_elf_create_got_section (bfd *abfd,\n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   elf_hash_table (info)->sgot = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, 4))\n+      || !bfd_set_section_alignment (s, 4))\n     return FALSE;\n \n   /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the\n@@ -3070,7 +3070,7 @@ s3_bfd_score_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t\t   asection *sec,\n \t\t\t\t\t   int *retval)\n {\n-  if (strcmp (bfd_get_section_name (abfd, sec), \".scommon\") == 0)\n+  if (strcmp (bfd_section_name (sec), \".scommon\") == 0)\n     {\n       *retval = SHN_SCORE_SCOMMON;\n       return TRUE;\n@@ -3283,7 +3283,7 @@ s3_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *i\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (CONST_STRNEQ (name, \".rel\"))\n \t{\n@@ -3296,8 +3296,7 @@ s3_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *i\n \t\t the linker now does not create empty output sections.  */\n \t      if (s->output_section != NULL\n \t\t  && strcmp (name,\n-\t\t\t     bfd_get_section_name (s->output_section->owner,\n-\t\t\t\t\t\t   s->output_section)) == 0)\n+\t\t\t     bfd_section_name (s->output_section)) == 0)\n \t\ts->flags |= SEC_EXCLUDE;\n \t    }\n \t  else\n@@ -3311,7 +3310,7 @@ s3_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *i\n \t\t assert a DT_TEXTREL entry rather than testing whether\n \t\t there exists a relocation to a read only section or\n \t\t not.  */\n-\t      outname = bfd_get_section_name (output_bfd, s->output_section);\n+\t      outname = bfd_section_name (s->output_section);\n \t      target = bfd_get_section_by_name (output_bfd, outname + 4);\n \t      if ((target != NULL\n \t\t   && (target->flags & SEC_READONLY) != 0\n@@ -3424,7 +3423,7 @@ s3_bfd_score_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_get_linker_section (abfd, \".dynamic\");\n   if (s != NULL)\n     {\n-      if (!bfd_set_section_flags (abfd, s, flags))\n+      if (!bfd_set_section_flags (s, flags))\n \treturn FALSE;\n     }\n \n@@ -3441,7 +3440,7 @@ s3_bfd_score_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, SCORE_ELF_STUB_SECTION_NAME,\n \t\t\t\t\t      flags | SEC_CODE);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \n \treturn FALSE;\n     }\n@@ -3709,7 +3708,7 @@ s3_bfd_score_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,\n {\n   const char *name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (strcmp (name, \".got\") == 0\n       || strcmp (name, \".srdata\") == 0\n@@ -3732,7 +3731,7 @@ s3_bfd_score_elf_section_processing (bfd *abfd ATTRIBUTE_UNUSED, Elf_Internal_Sh\n {\n   if (hdr->bfd_section != NULL)\n     {\n-      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);\n+      const char *name = bfd_section_name (hdr->bfd_section);\n \n       if (strcmp (name, \".sdata\") == 0)\n \t{"
    },
    {
      "sha": "e625435ff574903adb227e14fd471122d420552c",
      "filename": "bfd/elf32-score7.c",
      "status": "modified",
      "additions": 11,
      "deletions": 12,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-score7.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-score7.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-score7.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1114,8 +1114,8 @@ score_elf_rel_dyn_section (bfd *dynobj, bfd_boolean create_p)\n \t\t\t\t\t\t    | SEC_LINKER_CREATED\n \t\t\t\t\t\t    | SEC_READONLY));\n       if (sreloc == NULL\n-\t  || ! bfd_set_section_alignment (dynobj, sreloc,\n-\t\t\t\t\t  SCORE_ELF_LOG_FILE_ALIGN (dynobj)))\n+\t  || !bfd_set_section_alignment (sreloc,\n+\t\t\t\t\t SCORE_ELF_LOG_FILE_ALIGN (dynobj)))\n \treturn NULL;\n     }\n   return sreloc;\n@@ -1289,7 +1289,7 @@ score_elf_create_got_section (bfd *abfd,\n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   elf_hash_table (info)->sgot = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, 4))\n+      || !bfd_set_section_alignment (s, 4))\n     return FALSE;\n \n   /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the\n@@ -2875,7 +2875,7 @@ s7_bfd_score_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t\t asection *sec,\n \t\t\t\t\t int *retval)\n {\n-  if (strcmp (bfd_get_section_name (abfd, sec), \".scommon\") == 0)\n+  if (strcmp (bfd_section_name (sec), \".scommon\") == 0)\n     {\n       *retval = SHN_SCORE_SCOMMON;\n       return TRUE;\n@@ -3091,7 +3091,7 @@ s7_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *i\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (CONST_STRNEQ (name, \".rel\"))\n \t{\n@@ -3104,8 +3104,7 @@ s7_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *i\n \t\t the linker now does not create empty output sections.  */\n \t      if (s->output_section != NULL\n \t\t  && strcmp (name,\n-\t\t\t     bfd_get_section_name (s->output_section->owner,\n-\t\t\t\t\t\t   s->output_section)) == 0)\n+\t\t\t     bfd_section_name (s->output_section)) == 0)\n \t\ts->flags |= SEC_EXCLUDE;\n \t    }\n \t  else\n@@ -3119,7 +3118,7 @@ s7_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *i\n \t\t assert a DT_TEXTREL entry rather than testing whether\n \t\t there exists a relocation to a read only section or\n \t\t not.  */\n-\t      outname = bfd_get_section_name (output_bfd, s->output_section);\n+\t      outname = bfd_section_name (s->output_section);\n \t      target = bfd_get_section_by_name (output_bfd, outname + 4);\n \t      if ((target != NULL\n \t\t   && (target->flags & SEC_READONLY) != 0\n@@ -3232,7 +3231,7 @@ s7_bfd_score_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_get_linker_section (abfd, \".dynamic\");\n   if (s != NULL)\n     {\n-      if (!bfd_set_section_flags (abfd, s, flags))\n+      if (!bfd_set_section_flags (s, flags))\n \treturn FALSE;\n     }\n \n@@ -3249,7 +3248,7 @@ s7_bfd_score_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, SCORE_ELF_STUB_SECTION_NAME,\n \t\t\t\t\t      flags | SEC_CODE);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \n \treturn FALSE;\n     }\n@@ -3520,7 +3519,7 @@ s7_bfd_score_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,\n {\n   const char *name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (strcmp (name, \".got\") == 0\n       || strcmp (name, \".srdata\") == 0\n@@ -3544,7 +3543,7 @@ s7_bfd_score_elf_section_processing (bfd *abfd ATTRIBUTE_UNUSED, Elf_Internal_Sh\n {\n   if (hdr->bfd_section != NULL)\n     {\n-      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);\n+      const char *name = bfd_section_name (hdr->bfd_section);\n \n       if (strcmp (name, \".sdata\") == 0)\n \t{"
    },
    {
      "sha": "c572f709f2a17b53d5f5d42faf8b30632d09842c",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2324,7 +2324,7 @@ create_got_section (bfd *dynobj, struct bfd_link_info *info)\n \t\t\t\t\t\t\t | SEC_IN_MEMORY\n \t\t\t\t\t\t\t | SEC_LINKER_CREATED));\n   if (htab->sfuncdesc == NULL\n-      || ! bfd_set_section_alignment (dynobj, htab->sfuncdesc, 2))\n+      || !bfd_set_section_alignment (htab->sfuncdesc, 2))\n     return FALSE;\n \n   htab->srelfuncdesc = bfd_make_section_anyway_with_flags (dynobj,\n@@ -2335,7 +2335,7 @@ create_got_section (bfd *dynobj, struct bfd_link_info *info)\n \t\t\t\t\t\t\t    | SEC_LINKER_CREATED\n \t\t\t\t\t\t\t    | SEC_READONLY));\n   if (htab->srelfuncdesc == NULL\n-      || ! bfd_set_section_alignment (dynobj, htab->srelfuncdesc, 2))\n+      || !bfd_set_section_alignment (htab->srelfuncdesc, 2))\n     return FALSE;\n \n   /* Also create .rofixup.  */\n@@ -2346,7 +2346,7 @@ create_got_section (bfd *dynobj, struct bfd_link_info *info)\n \t\t\t\t\t\t\t| SEC_LINKER_CREATED\n \t\t\t\t\t\t\t| SEC_READONLY));\n   if (htab->srofixup == NULL\n-      || ! bfd_set_section_alignment (dynobj, htab->srofixup, 2))\n+      || !bfd_set_section_alignment (htab->srofixup, 2))\n     return FALSE;\n \n   return TRUE;\n@@ -2401,7 +2401,7 @@ sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n   htab->root.splt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n \n   if (bed->want_plt_sym)\n@@ -2433,7 +2433,7 @@ sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  flags | SEC_READONLY);\n   htab->root.srelplt = s;\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+      || !bfd_set_section_alignment (s, ptralign))\n     return FALSE;\n \n   if (htab->root.sgot == NULL\n@@ -2473,7 +2473,7 @@ sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t  flags | SEC_READONLY);\n \t  htab->srelbss = s;\n \t  if (s == NULL\n-\t      || ! bfd_set_section_alignment (abfd, s, ptralign))\n+\t      || !bfd_set_section_alignment (s, ptralign))\n \t    return FALSE;\n \t}\n     }\n@@ -3211,7 +3211,7 @@ sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0 && s != htab->root.srelplt && s != htab->srelplt2)\n \t    relocs = TRUE;\n@@ -3619,7 +3619,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t  symname = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n \t  if (symname == NULL || *symname == '\\0')\n-\t    symname = bfd_section_name (input_bfd, sec);\n+\t    symname = bfd_section_name (sec);\n \n \t  relocation = (sec->output_section->vma\n \t\t\t+ sec->output_offset\n@@ -5170,7 +5170,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t    if (name == NULL)\n \t\t      return FALSE;\n \t\t    if (*name == '\\0')\n-\t\t      name = bfd_section_name (input_bfd, sec);\n+\t\t      name = bfd_section_name (sec);\n \t\t  }\n \t\t(*info->callbacks->reloc_overflow)\n \t\t  (info, (h ? &h->root : NULL), name, howto->name,"
    },
    {
      "sha": "e75d999fd51fa12bb5e3b53eb18e7f7390a01211",
      "filename": "bfd/elf32-spu.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-spu.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -585,7 +585,7 @@ spu_elf_create_sections (struct bfd_link_info *info)\n       flags = SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY;\n       s = bfd_make_section_anyway_with_flags (ibfd, SPU_PTNOTE_SPUNAME, flags);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (ibfd, s, 4))\n+\t  || !bfd_set_section_alignment (s, 4))\n \treturn FALSE;\n       /* Because we didn't set SEC_LINKER_CREATED we need to set the\n \t proper section type.  */\n@@ -595,7 +595,7 @@ spu_elf_create_sections (struct bfd_link_info *info)\n       size = 12 + ((sizeof (SPU_PLUGIN_NAME) + 3) & -4);\n       size += (name_len + 3) & -4;\n \n-      if (!bfd_set_section_size (ibfd, s, size))\n+      if (!bfd_set_section_size (s, size))\n \treturn FALSE;\n \n       data = bfd_zalloc (ibfd, size);\n@@ -622,7 +622,7 @@ spu_elf_create_sections (struct bfd_link_info *info)\n       flags = (SEC_LOAD | SEC_ALLOC | SEC_READONLY | SEC_HAS_CONTENTS\n \t       | SEC_IN_MEMORY | SEC_LINKER_CREATED);\n       s = bfd_make_section_anyway_with_flags (ibfd, \".fixup\", flags);\n-      if (s == NULL || !bfd_set_section_alignment (ibfd, s, 2))\n+      if (s == NULL || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n       htab->sfixup = s;\n     }\n@@ -1694,7 +1694,7 @@ spu_elf_size_stubs (struct bfd_link_info *info)\n       stub = bfd_make_section_anyway_with_flags (ibfd, \".stub\", flags);\n       htab->stub_sec[0] = stub;\n       if (stub == NULL\n-\t  || !bfd_set_section_alignment (ibfd, stub,\n+\t  || !bfd_set_section_alignment (stub,\n \t\t\t\t\t ovl_stub_size_log2 (htab->params)))\n \treturn 0;\n       stub->size = htab->stub_count[0] * ovl_stub_size (htab->params);\n@@ -1709,7 +1709,7 @@ spu_elf_size_stubs (struct bfd_link_info *info)\n \t  stub = bfd_make_section_anyway_with_flags (ibfd, \".stub\", flags);\n \t  htab->stub_sec[ovl] = stub;\n \t  if (stub == NULL\n-\t      || !bfd_set_section_alignment (ibfd, stub,\n+\t      || !bfd_set_section_alignment (stub,\n \t\t\t\t\t     ovl_stub_size_log2 (htab->params)))\n \t    return 0;\n \t  stub->size = htab->stub_count[ovl] * ovl_stub_size (htab->params);\n@@ -1727,7 +1727,7 @@ spu_elf_size_stubs (struct bfd_link_info *info)\n       flags = SEC_ALLOC;\n       htab->ovtab = bfd_make_section_anyway_with_flags (ibfd, \".ovtab\", flags);\n       if (htab->ovtab == NULL\n-\t  || !bfd_set_section_alignment (ibfd, htab->ovtab, 4))\n+\t  || !bfd_set_section_alignment (htab->ovtab, 4))\n \treturn 0;\n \n       htab->ovtab->size = (16 + 16 + (16 << htab->fromelem_size_log2))\n@@ -1736,7 +1736,7 @@ spu_elf_size_stubs (struct bfd_link_info *info)\n       flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;\n       htab->init = bfd_make_section_anyway_with_flags (ibfd, \".ovini\", flags);\n       if (htab->init == NULL\n-\t  || !bfd_set_section_alignment (ibfd, htab->init, 4))\n+\t  || !bfd_set_section_alignment (htab->init, 4))\n \treturn 0;\n \n       htab->init->size = 16;\n@@ -1761,15 +1761,15 @@ spu_elf_size_stubs (struct bfd_link_info *info)\n       flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;\n       htab->ovtab = bfd_make_section_anyway_with_flags (ibfd, \".ovtab\", flags);\n       if (htab->ovtab == NULL\n-\t  || !bfd_set_section_alignment (ibfd, htab->ovtab, 4))\n+\t  || !bfd_set_section_alignment (htab->ovtab, 4))\n \treturn 0;\n \n       htab->ovtab->size = htab->num_overlays * 16 + 16 + htab->num_buf * 4;\n     }\n \n   htab->toe = bfd_make_section_anyway_with_flags (ibfd, \".toe\", SEC_ALLOC);\n   if (htab->toe == NULL\n-      || !bfd_set_section_alignment (ibfd, htab->toe, 4))\n+      || !bfd_set_section_alignment (htab->toe, 4))\n     return 0;\n   htab->toe->size = 16;\n \n@@ -5049,7 +5049,7 @@ spu_elf_relocate_section (bfd *output_bfd,\n \t    (_(\"%pB(%s+%#\" PRIx64 \"): \"\n \t       \"unresolvable %s relocation against symbol `%s'\"),\n \t     input_bfd,\n-\t     bfd_get_section_name (input_bfd, input_section),\n+\t     bfd_section_name (input_section),\n \t     (uint64_t) rel->r_offset,\n \t     howto->name,\n \t     sym_name);\n@@ -5436,7 +5436,7 @@ spu_elf_modify_program_headers (bfd *abfd, struct bfd_link_info *info)\n }\n \n bfd_boolean\n-spu_elf_size_sections (bfd * output_bfd, struct bfd_link_info *info)\n+spu_elf_size_sections (bfd *obfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n {\n   struct spu_link_hash_table *htab = spu_hash_table (info);\n   if (htab->params->emit_fixups)\n@@ -5493,7 +5493,7 @@ spu_elf_size_sections (bfd * output_bfd, struct bfd_link_info *info)\n \n       /* We always have a NULL fixup as a sentinel */\n       size = (fixup_count + 1) * FIXUP_RECORD_SIZE;\n-      if (!bfd_set_section_size (output_bfd, sfixup, size))\n+      if (!bfd_set_section_size (sfixup, size))\n \treturn FALSE;\n       sfixup->contents = (bfd_byte *) bfd_zalloc (info->input_bfds, size);\n       if (sfixup->contents == NULL)"
    },
    {
      "sha": "258349cfb7537cc3f4009e206550e833e7d5331d",
      "filename": "bfd/elf32-tic6x.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tic6x.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1684,8 +1684,8 @@ elf32_tic6x_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)\n   htab->dsbt = bfd_make_section_anyway_with_flags (dynobj, \".dsbt\",\n \t\t\t\t\t\t   flags);\n   if (htab->dsbt == NULL\n-      || ! bfd_set_section_alignment (dynobj, htab->dsbt, 2)\n-      || ! bfd_set_section_alignment (dynobj, htab->elf.splt, 5))\n+      || !bfd_set_section_alignment (htab->dsbt, 2)\n+      || !bfd_set_section_alignment (htab->elf.splt, 5))\n     return FALSE;\n \n   return TRUE;\n@@ -1992,7 +1992,7 @@ elf32_tic6x_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,\n {\n   const char * name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (is_tic6x_elf_unwind_section_name (name))\n     {\n@@ -2683,7 +2683,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,\n \t      if (name == NULL)\n \t\treturn FALSE;\n \t      if (*name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch (r)\n@@ -3016,7 +3016,7 @@ elf32_tic6x_add_symbol_hook (bfd *abfd,\n       *secp = bfd_make_section_old_way (abfd, \".scommon\");\n       (*secp)->flags |= SEC_IS_COMMON;\n       *valp = sym->st_size;\n-      (void) bfd_set_section_alignment (abfd, *secp, bfd_log2 (sym->st_value));\n+      bfd_set_section_alignment (*secp, bfd_log2 (sym->st_value));\n       break;\n     }\n \n@@ -3072,7 +3072,7 @@ elf32_tic6x_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t      asection *sec,\n \t\t\t\t      int *retval)\n {\n-  if (strcmp (bfd_get_section_name (abfd, sec), \".scommon\") == 0)\n+  if (strcmp (bfd_section_name (sec), \".scommon\") == 0)\n     {\n       *retval = SHN_TIC6X_SCOMMON;\n       return TRUE;\n@@ -3385,7 +3385,7 @@ elf32_tic6x_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t  if (s == htab->elf.splt && s->size > 0)\n \t    s->size = (s->size + 31) & ~(bfd_vma)31;\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0\n \t      && s != htab->elf.srelplt)\n@@ -3992,10 +3992,10 @@ elf32_tic6x_adjust_exidx_size (asection *exidx_sec, int adjust)\n   if (!exidx_sec->rawsize)\n     exidx_sec->rawsize = exidx_sec->size;\n \n-  bfd_set_section_size (exidx_sec->owner, exidx_sec, exidx_sec->size + adjust);\n+  bfd_set_section_size (exidx_sec, exidx_sec->size + adjust);\n   out_sec = exidx_sec->output_section;\n   /* Adjust size of output section.  */\n-  bfd_set_section_size (out_sec->owner, out_sec, out_sec->size +adjust);\n+  bfd_set_section_size (out_sec, out_sec->size +adjust);\n }\n \n /* Insert an EXIDX_CANTUNWIND marker at the end of a section.  */"
    },
    {
      "sha": "249b3aaf5ba557ac1efe676b8fa1e0c251c958b6",
      "filename": "bfd/elf32-tilepro.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tilepro.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1229,13 +1229,13 @@ tilepro_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t   (bed->dynamic_sec_flags\n \t\t\t\t    | SEC_READONLY));\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->srelgot = s;\n \n   s = s_got = bfd_make_section_with_flags (abfd, \".got\", flags);\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->sgot = s;\n \n@@ -1246,8 +1246,7 @@ tilepro_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n     {\n       s = bfd_make_section_with_flags (abfd, \".got.plt\", flags);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->sgotplt = s;\n \n@@ -2754,7 +2753,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       switch (r_type)"
    },
    {
      "sha": "21df3c8b9ac21b46a41692b6f685fe45da3334cd",
      "filename": "bfd/elf32-v850.c",
      "status": "modified",
      "additions": 15,
      "deletions": 16,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-v850.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-v850.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-v850.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -177,7 +177,7 @@ v850_elf_check_relocs (bfd *abfd,\n \n \t  if (h && h->root.type == bfd_link_hash_common\n \t      && h->root.u.c.p\n-\t      && !strcmp (bfd_get_section_name (abfd, h->root.u.c.p->section), \"COMMON\"))\n+\t      && !strcmp (bfd_section_name (h->root.u.c.p->section), \"COMMON\"))\n \t    {\n \t      asection * section;\n \n@@ -2269,7 +2269,7 @@ v850_elf_relocate_section (bfd *output_bfd,\n \t      name = (bfd_elf_string_from_elf_section\n \t\t      (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t      if (name == NULL || *name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  switch ((int) r)\n@@ -2372,11 +2372,11 @@ v850_elf_make_note_section (bfd * abfd)\n   if (s == NULL)\n     return NULL;\n \n-  if (!bfd_set_section_alignment (abfd, s, 2))\n+  if (!bfd_set_section_alignment (s, 2))\n     return NULL;\n \n   /* Allocate space for all known notes.  */\n-  if (!bfd_set_section_size (abfd, s, NUM_V850_NOTES * SIZEOF_V850_NOTE))\n+  if (!bfd_set_section_size (s, NUM_V850_NOTES * SIZEOF_V850_NOTE))\n     return NULL;\n \n   data = bfd_zalloc (abfd, NUM_V850_NOTES * SIZEOF_V850_NOTE);\n@@ -2443,7 +2443,7 @@ v850_elf_copy_notes (bfd *ibfd, bfd *obfd)\n   if ((inotes = bfd_get_section_by_name (ibfd, V850_NOTE_SECNAME)) == NULL)\n     return;\n \n-  if (bfd_section_size (ibfd, inotes) == bfd_section_size (obfd, onotes))\n+  if (bfd_section_size (inotes) == bfd_section_size (onotes))\n     {\n       bfd_byte * icont;\n       bfd_byte * ocont;\n@@ -2457,7 +2457,7 @@ v850_elf_copy_notes (bfd *ibfd, bfd *obfd)\n \treturn;\n \n       /* Copy/overwrite notes from the input to the output.  */\n-      memcpy (ocont, icont, bfd_section_size (obfd, onotes));\n+      memcpy (ocont, icont, bfd_section_size (onotes));\n     }\n }\n \n@@ -2490,7 +2490,7 @@ v850_elf_merge_notes (bfd * ibfd, bfd *obfd)\n       bfd_byte * icont;\n       bfd_byte * ocont;\n \n-      BFD_ASSERT (bfd_section_size (ibfd, inotes) == bfd_section_size (obfd, onotes));\n+      BFD_ASSERT (bfd_section_size (inotes) == bfd_section_size (onotes));\n \n       if ((icont = elf_section_data (inotes)->this_hdr.contents) == NULL)\n \tBFD_ASSERT (bfd_malloc_and_get_section (ibfd, inotes, & icont));\n@@ -2672,7 +2672,7 @@ v850_elf_print_notes (bfd * abfd, FILE * file)\n   if (notes == NULL || notes->contents == NULL)\n     return;\n \n-  BFD_ASSERT (bfd_section_size (abfd, notes) == NUM_V850_NOTES * SIZEOF_V850_NOTE);\n+  BFD_ASSERT (bfd_section_size (notes) == NUM_V850_NOTES * SIZEOF_V850_NOTE);\n \n   for (id = V850_NOTE_ALIGNMENT; id <= NUM_V850_NOTES; id++)\n     print_v850_note (abfd, file, notes->contents, id);\n@@ -2946,11 +2946,11 @@ v850_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t   asection *sec,\n \t\t\t\t   int *retval)\n {\n-  if (strcmp (bfd_get_section_name (abfd, sec), \".scommon\") == 0)\n+  if (strcmp (bfd_section_name (sec), \".scommon\") == 0)\n     *retval = SHN_V850_SCOMMON;\n-  else if (strcmp (bfd_get_section_name (abfd, sec), \".tcommon\") == 0)\n+  else if (strcmp (bfd_section_name (sec), \".tcommon\") == 0)\n     *retval = SHN_V850_TCOMMON;\n-  else if (strcmp (bfd_get_section_name (abfd, sec), \".zcommon\") == 0)\n+  else if (strcmp (bfd_section_name (sec), \".zcommon\") == 0)\n     *retval = SHN_V850_ZCOMMON;\n   else\n     return FALSE;\n@@ -3162,10 +3162,9 @@ v850_elf_section_from_shdr (bfd *abfd,\n     case SHT_V850_SCOMMON:\n     case SHT_V850_TCOMMON:\n     case SHT_V850_ZCOMMON:\n-      if (! bfd_set_section_flags (abfd, hdr->bfd_section,\n-\t\t\t\t   (bfd_get_section_flags (abfd,\n-\t\t\t\t\t\t\t   hdr->bfd_section)\n-\t\t\t\t    | SEC_IS_COMMON)))\n+      if (!bfd_set_section_flags (hdr->bfd_section,\n+\t\t\t\t  (bfd_section_flags (hdr->bfd_section)\n+\t\t\t\t   | SEC_IS_COMMON)))\n \treturn FALSE;\n     }\n \n@@ -3182,7 +3181,7 @@ v850_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,\n {\n   const char * name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (strcmp (name, \".scommon\") == 0)\n     hdr->sh_type = SHT_V850_SCOMMON;"
    },
    {
      "sha": "80162d87cb26d1b42e4b658c3cc3aee99c97740b",
      "filename": "bfd/elf32-vax.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-vax.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-vax.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-vax.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1069,7 +1069,7 @@ elf_vax_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (strcmp (name, \".plt\") == 0)\n \t{\n@@ -1094,8 +1094,7 @@ elf_vax_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t\t     section, then we probably need a DT_TEXTREL\n \t\t     entry.  .rela.plt is actually associated with\n \t\t     .got.plt, which is never readonly.  */\n-\t\t  outname = bfd_get_section_name (output_bfd,\n-\t\t\t\t\t\t  s->output_section);\n+\t\t  outname = bfd_section_name (s->output_section);\n \t\t  target = bfd_get_section_by_name (output_bfd, outname + 5);\n \t\t  if (target != NULL\n \t\t      && (target->flags & SEC_READONLY) != 0\n@@ -1633,7 +1632,7 @@ elf_vax_relocate_section (bfd *output_bfd,\n \t\t    if (name == NULL)\n \t\t      return FALSE;\n \t\t    if (*name == '\\0')\n-\t\t      name = bfd_section_name (input_bfd, sec);\n+\t\t      name = bfd_section_name (sec);\n \t\t  }\n \t\tinfo->callbacks->reloc_overflow\n \t\t  (info, (h ? &h->root : NULL), name, howto->name,"
    },
    {
      "sha": "35e4b84ed1408bd53378cdd6f8b24139bea8d71c",
      "filename": "bfd/elf32-visium.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-visium.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-visium.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-visium.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -599,7 +599,7 @@ visium_elf_relocate_section (bfd *output_bfd,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "ef106b3f928a441c2d8640d300cbd2899bba2a48",
      "filename": "bfd/elf32-xstormy16.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-xstormy16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-xstormy16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-xstormy16.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -471,7 +471,7 @@ xstormy16_elf_check_relocs (bfd *abfd,\n \t\t\t\t\t\t\t flags);\n \t      elf_hash_table (info)->splt = splt;\n \t      if (splt == NULL\n-\t\t  || ! bfd_set_section_alignment (dynobj, splt, 1))\n+\t\t  || !bfd_set_section_alignment (splt, 1))\n \t\treturn FALSE;\n \t    }\n \n@@ -834,7 +834,7 @@ xstormy16_elf_relocate_section (bfd *\t\t\toutput_bfd ATTRIBUTE_UNUSED,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       switch (ELF32_R_TYPE (rel->r_info))"
    },
    {
      "sha": "306b18b4f265fad72ab81afdf1230e7c213b7f33",
      "filename": "bfd/elf32-xtensa.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-xtensa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf32-xtensa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-xtensa.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1320,21 +1320,21 @@ elf_xtensa_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)\n \n   /* Mark the \".got.plt\" section READONLY.  */\n   if (htab->elf.sgotplt == NULL\n-      || ! bfd_set_section_flags (dynobj, htab->elf.sgotplt, flags))\n+      || !bfd_set_section_flags (htab->elf.sgotplt, flags))\n     return FALSE;\n \n   /* Create \".got.loc\" (literal tables for use by dynamic linker).  */\n   htab->sgotloc = bfd_make_section_anyway_with_flags (dynobj, \".got.loc\",\n \t\t\t\t\t\t      flags);\n   if (htab->sgotloc == NULL\n-      || ! bfd_set_section_alignment (dynobj, htab->sgotloc, 2))\n+      || !bfd_set_section_alignment (htab->sgotloc, 2))\n     return FALSE;\n \n   /* Create \".xt.lit.plt\" (literal table for \".got.plt*\").  */\n   htab->spltlittbl = bfd_make_section_anyway_with_flags (dynobj, \".xt.lit.plt\",\n \t\t\t\t\t\t\t noalloc_flags);\n   if (htab->spltlittbl == NULL\n-      || ! bfd_set_section_alignment (dynobj, htab->spltlittbl, 2))\n+      || !bfd_set_section_alignment (htab->spltlittbl, 2))\n     return FALSE;\n \n   return TRUE;\n@@ -1366,14 +1366,14 @@ add_extra_plt_sections (struct bfd_link_info *info, int count)\n       sprintf (sname, \".plt.%u\", chunk);\n       s = bfd_make_section_anyway_with_flags (dynobj, sname, flags | SEC_CODE);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (dynobj, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n \n       sname = (char *) bfd_malloc (14);\n       sprintf (sname, \".got.plt.%u\", chunk);\n       s = bfd_make_section_anyway_with_flags (dynobj, sname, flags);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (dynobj, s, 2))\n+\t  || !bfd_set_section_alignment (s, 2))\n \treturn FALSE;\n     }\n \n@@ -1626,7 +1626,7 @@ elf_xtensa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (CONST_STRNEQ (name, \".rela\"))\n \t{\n@@ -2687,7 +2687,7 @@ elf_xtensa_relocate_section (bfd *output_bfd,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       if (r_symndx != STN_UNDEF\n@@ -11244,7 +11244,7 @@ xtensa_make_property_section (asection *sec, const char *base_name)\n   if (! prop_sec)\n     {\n       flagword flags = (SEC_RELOC | SEC_HAS_CONTENTS | SEC_READONLY);\n-      flags |= (bfd_get_section_flags (sec->owner, sec)\n+      flags |= (bfd_section_flags (sec)\n \t\t& (SEC_LINK_ONCE | SEC_LINK_DUPLICATES));\n \n       prop_sec = bfd_make_section_anyway_with_flags"
    },
    {
      "sha": "84ec83b74af55b9b38b96532ec068b2d7684a5d5",
      "filename": "bfd/elf64-alpha.c",
      "status": "modified",
      "additions": 12,
      "deletions": 13,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-alpha.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1168,9 +1168,8 @@ elf64_alpha_section_from_shdr (bfd *abfd,\n \n   if (hdr->sh_type == SHT_ALPHA_DEBUG)\n     {\n-      if (! bfd_set_section_flags (abfd, newsect,\n-\t\t\t\t   (bfd_get_section_flags (abfd, newsect)\n-\t\t\t\t    | SEC_DEBUGGING)))\n+      if (!bfd_set_section_flags (newsect,\n+\t\t\t\t  bfd_section_flags (newsect) | SEC_DEBUGGING))\n \treturn FALSE;\n     }\n \n@@ -1196,7 +1195,7 @@ elf64_alpha_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec)\n {\n   register const char *name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (strcmp (name, \".mdebug\") == 0)\n     {\n@@ -1270,7 +1269,7 @@ elf64_alpha_create_got_section (bfd *abfd,\n \t   | SEC_LINKER_CREATED);\n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n \n   alpha_elf_tdata (abfd)->got = s;\n@@ -1302,7 +1301,7 @@ elf64_alpha_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t   | (elf64_alpha_use_secureplt ? SEC_READONLY : 0));\n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", flags);\n   elf_hash_table (info)->splt = s;\n-  if (s == NULL || ! bfd_set_section_alignment (abfd, s, 4))\n+  if (s == NULL || ! bfd_set_section_alignment (s, 4))\n     return FALSE;\n \n   /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the\n@@ -1317,15 +1316,15 @@ elf64_alpha_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t   | SEC_LINKER_CREATED | SEC_READONLY);\n   s = bfd_make_section_anyway_with_flags (abfd, \".rela.plt\", flags);\n   elf_hash_table (info)->srelplt = s;\n-  if (s == NULL || ! bfd_set_section_alignment (abfd, s, 3))\n+  if (s == NULL || ! bfd_set_section_alignment (s, 3))\n     return FALSE;\n \n   if (elf64_alpha_use_secureplt)\n     {\n       flags = SEC_ALLOC | SEC_LINKER_CREATED;\n       s = bfd_make_section_anyway_with_flags (abfd, \".got.plt\", flags);\n       elf_hash_table (info)->sgotplt = s;\n-      if (s == NULL || ! bfd_set_section_alignment (abfd, s, 3))\n+      if (s == NULL || ! bfd_set_section_alignment (s, 3))\n \treturn FALSE;\n     }\n \n@@ -1343,7 +1342,7 @@ elf64_alpha_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".rela.got\", flags);\n   elf_hash_table (info)->srelgot = s;\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n \n   /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the\n@@ -1616,7 +1615,7 @@ elf64_alpha_output_extsym (struct alpha_elf_link_hash_entry *h, void * data)\n \t    h->esym.asym.sc = scUndefined;\n \t  else\n \t    {\n-\t      name = bfd_section_name (output_section->owner, output_section);\n+\t      name = bfd_section_name (output_section);\n \n \t      if (strcmp (name, \".text\") == 0)\n \t\th->esym.asym.sc = scText;\n@@ -2860,7 +2859,7 @@ elf64_alpha_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if (CONST_STRNEQ (name, \".rela\"))\n \t{\n@@ -4508,7 +4507,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\t    if (name == NULL)\n \t\t      name = _(\"<unknown>\");\n \t\t    else if (name[0] == 0)\n-\t\t      name = bfd_section_name (input_bfd, sec);\n+\t\t      name = bfd_section_name (sec);\n \t\t  }\n \t\t_bfd_error_handler\n \t\t  /* xgettext:c-format */\n@@ -4779,7 +4778,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t\tif (name == NULL)\n \t\t  return FALSE;\n \t\tif (*name == '\\0')\n-\t\t  name = bfd_section_name (input_bfd, sec);\n+\t\t  name = bfd_section_name (sec);\n \t      }\n \t    (*info->callbacks->reloc_overflow)\n \t      (info, (h ? &h->root.root : NULL), name, howto->name,"
    },
    {
      "sha": "67c45a1fa449ad3f546d20fe41a38d6b383f3109",
      "filename": "bfd/elf64-bpf.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-bpf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-bpf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-bpf.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -407,7 +407,7 @@ bpf_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n \t  name = bfd_elf_string_from_elf_section\n \t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n-\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t  name = name == NULL ? bfd_section_name (sec) : name;\n \t}\n       else\n \t{"
    },
    {
      "sha": "25e91d8a233c00ecde980ba8c2bbbf0ed7842004",
      "filename": "bfd/elf64-hppa.c",
      "status": "modified",
      "additions": 12,
      "deletions": 13,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-hppa.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -422,7 +422,7 @@ get_reloc_section (bfd *abfd,\n \t\t\t\t\t\t  | SEC_LINKER_CREATED\n \t\t\t\t\t\t  | SEC_READONLY));\n       if (srel == NULL\n-\t  || !bfd_set_section_alignment (dynobj, srel, 3))\n+\t  || !bfd_set_section_alignment (srel, 3))\n \treturn FALSE;\n     }\n \n@@ -1159,7 +1159,7 @@ get_opd (bfd *abfd,\n \t\t\t\t\t\t | SEC_IN_MEMORY\n \t\t\t\t\t\t | SEC_LINKER_CREATED));\n       if (!opd\n-\t  || !bfd_set_section_alignment (abfd, opd, 3))\n+\t  || !bfd_set_section_alignment (opd, 3))\n \t{\n \t  BFD_ASSERT (0);\n \t  return FALSE;\n@@ -1195,7 +1195,7 @@ get_plt (bfd *abfd,\n \t\t\t\t\t\t | SEC_IN_MEMORY\n \t\t\t\t\t\t | SEC_LINKER_CREATED));\n       if (!plt\n-\t  || !bfd_set_section_alignment (abfd, plt, 3))\n+\t  || !bfd_set_section_alignment (plt, 3))\n \t{\n \t  BFD_ASSERT (0);\n \t  return FALSE;\n@@ -1231,7 +1231,7 @@ get_dlt (bfd *abfd,\n \t\t\t\t\t\t | SEC_IN_MEMORY\n \t\t\t\t\t\t | SEC_LINKER_CREATED));\n       if (!dlt\n-\t  || !bfd_set_section_alignment (abfd, dlt, 3))\n+\t  || !bfd_set_section_alignment (dlt, 3))\n \t{\n \t  BFD_ASSERT (0);\n \t  return FALSE;\n@@ -1267,7 +1267,7 @@ get_stub (bfd *abfd,\n \t\t\t\t\t\t  | SEC_READONLY\n \t\t\t\t\t\t  | SEC_LINKER_CREATED));\n       if (!stub\n-\t  || !bfd_set_section_alignment (abfd, stub, 3))\n+\t  || !bfd_set_section_alignment (stub, 3))\n \t{\n \t  BFD_ASSERT (0);\n \t  return FALSE;\n@@ -1347,7 +1347,7 @@ elf64_hppa_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_READONLY\n \t\t\t\t\t   | SEC_LINKER_CREATED));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n   hppa_info->dlt_rel_sec = s;\n \n@@ -1358,7 +1358,7 @@ elf64_hppa_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_READONLY\n \t\t\t\t\t   | SEC_LINKER_CREATED));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n   hppa_info->plt_rel_sec = s;\n \n@@ -1369,7 +1369,7 @@ elf64_hppa_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_READONLY\n \t\t\t\t\t   | SEC_LINKER_CREATED));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n   hppa_info->other_rel_sec = s;\n \n@@ -1380,7 +1380,7 @@ elf64_hppa_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_READONLY\n \t\t\t\t\t   | SEC_LINKER_CREATED));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n   hppa_info->opd_rel_sec = s;\n \n@@ -1750,7 +1750,7 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, sec);\n+      name = bfd_section_name (sec);\n \n       if (strcmp (name, \".plt\") == 0)\n \t{\n@@ -1783,8 +1783,7 @@ elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t\t     entry.  The entries in the .rela.plt section\n \t\t     really apply to the .got section, which we\n \t\t     created ourselves and so know is not readonly.  */\n-\t\t  outname = bfd_get_section_name (output_bfd,\n-\t\t\t\t\t\t  sec->output_section);\n+\t\t  outname = bfd_section_name (sec->output_section);\n \t\t  target = bfd_get_section_by_name (output_bfd, outname + 4);\n \t\t  if (target != NULL\n \t\t      && (target->flags & SEC_READONLY) != 0\n@@ -3938,7 +3937,7 @@ elf64_hppa_relocate_section (bfd *output_bfd,\n \t\t    if (sym_name == NULL)\n \t\t      return FALSE;\n \t\t    if (*sym_name == '\\0')\n-\t\t      sym_name = bfd_section_name (input_bfd, sym_sec);\n+\t\t      sym_name = bfd_section_name (sym_sec);\n \t\t  }\n \n \t\t(*info->callbacks->reloc_overflow)"
    },
    {
      "sha": "aa2aa119f5e6e7b6c8cde7c46b8ad89d49dd5c9f",
      "filename": "bfd/elf64-ia64-vms.c",
      "status": "modified",
      "additions": 19,
      "deletions": 21,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-ia64-vms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-ia64-vms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ia64-vms.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -840,7 +840,7 @@ elf64_ia64_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr,\n {\n   const char *name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (is_unwind_section_name (abfd, name))\n     {\n@@ -1286,12 +1286,12 @@ elf64_ia64_create_dynamic_sections (bfd *abfd,\n   s = bfd_make_section_anyway_with_flags (abfd, \".dynamic\",\n \t\t\t\t\t  flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n   ia64_info->root.splt = s;\n \n@@ -1307,7 +1307,7 @@ elf64_ia64_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_IN_MEMORY\n \t\t\t\t\t   | SEC_LINKER_CREATED));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 0))\n+      || !bfd_set_section_alignment (s, 0))\n     return FALSE;\n \n   /* Create a fixup section.  */\n@@ -1317,7 +1317,7 @@ elf64_ia64_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_IN_MEMORY\n \t\t\t\t\t   | SEC_LINKER_CREATED));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n   ia64_info->fixups_sec = s;\n \n@@ -1328,7 +1328,7 @@ elf64_ia64_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_IN_MEMORY\n \t\t\t\t\t   | SEC_LINKER_CREATED));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n   s->size = sizeof (struct elf64_vms_transfer);\n   ia64_info->transfer_sec = s;\n@@ -1340,7 +1340,7 @@ elf64_ia64_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_IN_MEMORY\n \t\t\t\t\t   | SEC_READONLY));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, 3))\n+      || !bfd_set_section_alignment (s, 3))\n     return FALSE;\n   ia64_info->note_sec = s;\n \n@@ -1738,7 +1738,7 @@ get_got (bfd *abfd, struct elf64_ia64_link_hash_table *ia64_info)\n       got = bfd_make_section_anyway_with_flags (dynobj, \".got\",\n \t\t\t\t\t\tflags | SEC_SMALL_DATA);\n       if (got == NULL\n-\t  || !bfd_set_section_alignment (dynobj, got, 3))\n+\t  || !bfd_set_section_alignment (got, 3))\n \treturn NULL;\n       ia64_info->root.sgot = got;\n     }\n@@ -1774,7 +1774,7 @@ get_fptr (bfd *abfd, struct bfd_link_info *info,\n \t\t\t\t\t\t     : SEC_READONLY)\n \t\t\t\t\t\t  | SEC_LINKER_CREATED));\n       if (!fptr\n-\t  || !bfd_set_section_alignment (dynobj, fptr, 4))\n+\t  || !bfd_set_section_alignment (fptr, 4))\n \t{\n \t  BFD_ASSERT (0);\n \t  return NULL;\n@@ -1792,7 +1792,7 @@ get_fptr (bfd *abfd, struct bfd_link_info *info,\n \t\t\t\t\t\t\t  | SEC_LINKER_CREATED\n \t\t\t\t\t\t\t  | SEC_READONLY));\n \t  if (fptr_rel == NULL\n-\t      || !bfd_set_section_alignment (dynobj, fptr_rel, 3))\n+\t      || !bfd_set_section_alignment (fptr_rel, 3))\n \t    {\n \t      BFD_ASSERT (0);\n \t      return NULL;\n@@ -1827,7 +1827,7 @@ get_pltoff (bfd *abfd, struct elf64_ia64_link_hash_table *ia64_info)\n \t\t\t\t\t\t    | SEC_SMALL_DATA\n \t\t\t\t\t\t    | SEC_LINKER_CREATED));\n       if (!pltoff\n-\t  || !bfd_set_section_alignment (dynobj, pltoff, 4))\n+\t  || !bfd_set_section_alignment (pltoff, 4))\n \t{\n \t  BFD_ASSERT (0);\n \t  return NULL;\n@@ -1855,11 +1855,9 @@ get_reloc_section (bfd *abfd,\n     return NULL;\n \n   BFD_ASSERT ((CONST_STRNEQ (srel_name, \".rela\")\n-\t       && strcmp (bfd_get_section_name (abfd, sec),\n-\t\t\t  srel_name+5) == 0)\n+\t       && strcmp (bfd_section_name (sec), srel_name+5) == 0)\n \t      || (CONST_STRNEQ (srel_name, \".rel\")\n-\t\t  && strcmp (bfd_get_section_name (abfd, sec),\n-\t\t\t     srel_name+4) == 0));\n+\t\t  && strcmp (bfd_section_name (sec), srel_name+4) == 0));\n \n   dynobj = ia64_info->root.dynobj;\n   if (!dynobj)\n@@ -1875,7 +1873,7 @@ get_reloc_section (bfd *abfd,\n \t\t\t\t\t\t  | SEC_LINKER_CREATED\n \t\t\t\t\t\t  | SEC_READONLY));\n       if (srel == NULL\n-\t  || !bfd_set_section_alignment (dynobj, srel, 3))\n+\t  || !bfd_set_section_alignment (srel, 3))\n \treturn NULL;\n     }\n \n@@ -2750,7 +2748,7 @@ elf64_ia64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n \t  /* It's OK to base decisions on the section name, because none\n \t     of the dynobj section names depend upon the input files.  */\n-\t  name = bfd_get_section_name (dynobj, sec);\n+\t  name = bfd_section_name (sec);\n \n \t  if (strcmp (name, \".got.plt\") == 0)\n \t    strip = FALSE;\n@@ -4501,8 +4499,8 @@ elf64_vms_section_from_shdr (bfd *abfd,\n     {\n       asection *newsect = hdr->bfd_section;\n \n-      if (! bfd_set_section_flags\n-\t  (abfd, newsect, bfd_get_section_flags (abfd, newsect) | secflags))\n+      if (!bfd_set_section_flags (newsect,\n+\t\t\t\t  bfd_section_flags (newsect) | secflags))\n \treturn FALSE;\n     }\n \n@@ -4629,7 +4627,7 @@ elf64_vms_section_processing (bfd *abfd ATTRIBUTE_UNUSED,\n {\n   if (hdr->bfd_section != NULL)\n     {\n-      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);\n+      const char *name = bfd_section_name (hdr->bfd_section);\n \n       if (strcmp (name, \".text\") == 0)\n \thdr->sh_flags |= SHF_IA_64_VMS_SHARED;\n@@ -4670,7 +4668,7 @@ elf64_vms_final_write_processing (bfd *abfd)\n     {\n       hdr = &elf_section_data (s)->this_hdr;\n \n-      if (strcmp (bfd_get_section_name (abfd, hdr->bfd_section),\n+      if (strcmp (bfd_section_name (hdr->bfd_section),\n \t\t  \".IA_64.unwind_info\") == 0)\n \tunwind_info_sect_idx = elf_section_data (s)->this_idx;\n "
    },
    {
      "sha": "69d57a2ce96120ddbb4c5be9f197aa5ba7b1f56d",
      "filename": "bfd/elf64-mmix.c",
      "status": "modified",
      "additions": 13,
      "deletions": 17,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-mmix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-mmix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-mmix.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1414,7 +1414,7 @@ mmix_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t  symtab_hdr->sh_link,\n \t\t\t\t\t\t  sym->st_name);\n \t  if (name == NULL)\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n       else\n \t{\n@@ -1606,9 +1606,9 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,\n \treturn bfd_reloc_undefined;\n \n       /* Check that we're not relocating against a register symbol.  */\n-      if (strcmp (bfd_get_section_name (symsec->owner, symsec),\n+      if (strcmp (bfd_section_name (symsec),\n \t\t  MMIX_REG_CONTENTS_SECTION_NAME) == 0\n-\t  || strcmp (bfd_get_section_name (symsec->owner, symsec),\n+\t  || strcmp (bfd_section_name (symsec),\n \t\t     MMIX_REG_SECTION_NAME) == 0)\n \t{\n \t  /* Note: This is separated out into two messages in order\n@@ -1641,7 +1641,7 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,\n       if (symsec == NULL)\n \treturn bfd_reloc_undefined;\n \n-      if (strcmp (bfd_get_section_name (symsec->owner, symsec),\n+      if (strcmp (bfd_section_name (symsec),\n \t\t  MMIX_REG_CONTENTS_SECTION_NAME) == 0)\n \t{\n \t  if ((srel & 7) != 0 || srel < 32*8 || srel > 255*8)\n@@ -1652,7 +1652,7 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,\n \t    }\n \t  srel /= 8;\n \t}\n-      else if (strcmp (bfd_get_section_name (symsec->owner, symsec),\n+      else if (strcmp (bfd_section_name (symsec),\n \t\t       MMIX_REG_SECTION_NAME) == 0)\n \t{\n \t  if (srel < 0 || srel > 255)\n@@ -1704,9 +1704,9 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,\n \t   accidentally handling it.  */\n \tif (!bfd_is_abs_section (symsec)\n \t    && !bfd_is_und_section (symsec)\n-\t    && strcmp (bfd_get_section_name (symsec->owner, symsec),\n+\t    && strcmp (bfd_section_name (symsec),\n \t\t       MMIX_REG_CONTENTS_SECTION_NAME) != 0\n-\t    && strcmp (bfd_get_section_name (symsec->owner, symsec),\n+\t    && strcmp (bfd_section_name (symsec),\n \t\t       MMIX_REG_SECTION_NAME) != 0)\n \t{\n \t  _bfd_error_handler\n@@ -1722,10 +1722,8 @@ mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,\n \tfirst_global = 255;\n       else\n \t{\n-\t  first_global\n-\t    = bfd_get_section_vma (input_section->output_section->owner,\n-\t\t\t\t   regsec) / 8;\n-\t  if (strcmp (bfd_get_section_name (symsec->owner, symsec),\n+\t  first_global = bfd_section_vma (regsec) / 8;\n+\t  if (strcmp (bfd_section_name (symsec),\n \t\t      MMIX_REG_CONTENTS_SECTION_NAME) == 0)\n \t    {\n \t      if ((srel & 7) != 0 || srel < 32*8 || srel > 255*8)\n@@ -1876,9 +1874,7 @@ mmix_elf_check_common_relocs  (bfd *abfd,\n \t\t those flags, as that is what currently happens for usual\n \t\t GREG allocations, and that works.  */\n \t      if (allocated_gregs_section == NULL\n-\t\t  || !bfd_set_section_alignment (bpo_greg_owner,\n-\t\t\t\t\t\t allocated_gregs_section,\n-\t\t\t\t\t\t 3))\n+\t\t  || !bfd_set_section_alignment (allocated_gregs_section, 3))\n \t\treturn FALSE;\n \n \t      gregdata = (struct bpo_greg_section_info *)\n@@ -2123,7 +2119,7 @@ mmix_elf_section_from_bfd_section (bfd *       abfd ATTRIBUTE_UNUSED,\n \t\t\t\t   asection *  sec,\n \t\t\t\t   int *       retval)\n {\n-  if (strcmp (bfd_get_section_name (abfd, sec), MMIX_REG_SECTION_NAME) == 0)\n+  if (strcmp (bfd_section_name (sec), MMIX_REG_SECTION_NAME) == 0)\n     *retval = SHN_REGISTER;\n   else\n     return FALSE;\n@@ -2222,7 +2218,7 @@ mmix_elf_final_link (bfd *abfd, struct bfd_link_info *info)\n   if (reg_section != NULL)\n     {\n       /* FIXME: Pass error state gracefully.  */\n-      if (bfd_get_section_flags (abfd, reg_section) & SEC_HAS_CONTENTS)\n+      if (bfd_section_flags (reg_section) & SEC_HAS_CONTENTS)\n \t_bfd_abort (__FILE__, __LINE__, _(\"register section has contents\\n\"));\n \n       /* Really remove the section, if it hasn't already been done.  */\n@@ -2330,7 +2326,7 @@ _bfd_mmix_before_linker_allocation (bfd *abfd ATTRIBUTE_UNUSED,\n   /* Set the zeroth-order estimate for the GREGs size.  */\n   gregs_size = n_gregs * 8;\n \n-  if (!bfd_set_section_size (bpo_greg_owner, bpo_gregs_section, gregs_size))\n+  if (!bfd_set_section_size (bpo_gregs_section, gregs_size))\n     return FALSE;\n \n   /* Allocate and set up the GREG arrays.  They're filled in at relaxation"
    },
    {
      "sha": "14119dd259a984b3272099eec55137baf09018b8",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3487,7 +3487,7 @@ create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)\n       htab->sfpr = bfd_make_section_anyway_with_flags (dynobj, \".sfpr\",\n \t\t\t\t\t\t       flags);\n       if (htab->sfpr == NULL\n-\t  || !bfd_set_section_alignment (dynobj, htab->sfpr, 2))\n+\t  || !bfd_set_section_alignment (htab->sfpr, 2))\n \treturn FALSE;\n     }\n \n@@ -3498,15 +3498,15 @@ create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)\n   htab->glink = bfd_make_section_anyway_with_flags (dynobj, \".glink\",\n \t\t\t\t\t\t    flags);\n   if (htab->glink == NULL\n-      || !bfd_set_section_alignment (dynobj, htab->glink, 3))\n+      || !bfd_set_section_alignment (htab->glink, 3))\n     return FALSE;\n \n   /* The part of .glink used by global entry stubs, separate so that\n      it can be aligned appropriately without affecting htab->glink.  */\n   htab->global_entry = bfd_make_section_anyway_with_flags (dynobj, \".glink\",\n \t\t\t\t\t\t\t   flags);\n   if (htab->global_entry == NULL\n-      || !bfd_set_section_alignment (dynobj, htab->global_entry, 2))\n+      || !bfd_set_section_alignment (htab->global_entry, 2))\n     return FALSE;\n \n   if (!info->no_ld_generated_unwind_info)\n@@ -3517,22 +3517,22 @@ create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)\n \t\t\t\t\t\t\t\t \".eh_frame\",\n \t\t\t\t\t\t\t\t flags);\n       if (htab->glink_eh_frame == NULL\n-\t  || !bfd_set_section_alignment (dynobj, htab->glink_eh_frame, 2))\n+\t  || !bfd_set_section_alignment (htab->glink_eh_frame, 2))\n \treturn FALSE;\n     }\n \n   flags = SEC_ALLOC | SEC_LINKER_CREATED;\n   htab->elf.iplt = bfd_make_section_anyway_with_flags (dynobj, \".iplt\", flags);\n   if (htab->elf.iplt == NULL\n-      || !bfd_set_section_alignment (dynobj, htab->elf.iplt, 3))\n+      || !bfd_set_section_alignment (htab->elf.iplt, 3))\n     return FALSE;\n \n   flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY\n \t   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);\n   htab->elf.irelplt\n     = bfd_make_section_anyway_with_flags (dynobj, \".rela.iplt\", flags);\n   if (htab->elf.irelplt == NULL\n-      || !bfd_set_section_alignment (dynobj, htab->elf.irelplt, 3))\n+      || !bfd_set_section_alignment (htab->elf.irelplt, 3))\n     return FALSE;\n \n   /* Create branch lookup table for plt_branch stubs.  */\n@@ -3541,15 +3541,15 @@ create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)\n   htab->brlt = bfd_make_section_anyway_with_flags (dynobj, \".branch_lt\",\n \t\t\t\t\t\t   flags);\n   if (htab->brlt == NULL\n-      || !bfd_set_section_alignment (dynobj, htab->brlt, 3))\n+      || !bfd_set_section_alignment (htab->brlt, 3))\n     return FALSE;\n \n   /* Local plt entries, put in .branch_lt but a separate section for\n      convenience.  */\n   htab->pltlocal = bfd_make_section_anyway_with_flags (dynobj, \".branch_lt\",\n \t\t\t\t\t\t       flags);\n   if (htab->pltlocal == NULL\n-      || !bfd_set_section_alignment (dynobj, htab->pltlocal, 3))\n+      || !bfd_set_section_alignment (htab->pltlocal, 3))\n     return FALSE;\n \n   if (!bfd_link_pic (info))\n@@ -3560,13 +3560,13 @@ create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)\n   htab->relbrlt\n     = bfd_make_section_anyway_with_flags (dynobj, \".rela.branch_lt\", flags);\n   if (htab->relbrlt == NULL\n-      || !bfd_set_section_alignment (dynobj, htab->relbrlt, 3))\n+      || !bfd_set_section_alignment (htab->relbrlt, 3))\n     return FALSE;\n \n   htab->relpltlocal\n     = bfd_make_section_anyway_with_flags (dynobj, \".rela.branch_lt\", flags);\n   if (htab->relpltlocal == NULL\n-      || !bfd_set_section_alignment (dynobj, htab->relpltlocal, 3))\n+      || !bfd_set_section_alignment (htab->relpltlocal, 3))\n     return FALSE;\n \n   return TRUE;\n@@ -3762,13 +3762,13 @@ create_got_section (bfd *abfd, struct bfd_link_info *info)\n \n   got = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   if (!got\n-      || !bfd_set_section_alignment (abfd, got, 3))\n+      || !bfd_set_section_alignment (got, 3))\n     return FALSE;\n \n   relgot = bfd_make_section_anyway_with_flags (abfd, \".rela.got\",\n \t\t\t\t\t       flags | SEC_READONLY);\n   if (!relgot\n-      || !bfd_set_section_alignment (abfd, relgot, 3))\n+      || !bfd_set_section_alignment (relgot, 3))\n     return FALSE;\n \n   ppc64_elf_tdata (abfd)->got = got;"
    },
    {
      "sha": "4ffcde92e212371e6ad8c4d21990276ae6a21c6d",
      "filename": "bfd/elf64-s390.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-s390.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1957,7 +1957,7 @@ elf_s390_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0 && s != htab->elf.srelplt)\n \t    relocs = TRUE;\n@@ -3203,7 +3203,7 @@ elf_s390_relocate_section (bfd *output_bfd,\n \t      if (name == NULL)\n \t\treturn FALSE;\n \t      if (*name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (r == bfd_reloc_overflow)"
    },
    {
      "sha": "8bf9623bd9fca6e240db79135353c19a2391fbb8",
      "filename": "bfd/elf64-sparc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-sparc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -748,7 +748,7 @@ elf64_sparc_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,\n {\n   const char *name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (strcmp (name, \".stab\") == 0)\n     {"
    },
    {
      "sha": "16e66f95d2c7b3cd5b79d670ad09cb9e8f59a040",
      "filename": "bfd/elf64-x86-64.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elf64-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-x86-64.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3989,7 +3989,7 @@ elf_x86_64_relocate_section (bfd *output_bfd,\n \t      if (name == NULL)\n \t\treturn FALSE;\n \t      if (*name == '\\0')\n-\t\tname = bfd_section_name (input_bfd, sec);\n+\t\tname = bfd_section_name (sec);\n \t    }\n \n \t  if (r == bfd_reloc_overflow)"
    },
    {
      "sha": "2169e2b40cb05f59be350f8eeb8a983d9c4df40e",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 23,
      "deletions": 28,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -162,22 +162,21 @@ _bfd_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  (bed->dynamic_sec_flags\n \t\t\t\t\t   | SEC_READONLY));\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->srelgot = s;\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->sgot = s;\n \n   if (bed->want_got_plt)\n     {\n       s = bfd_make_section_anyway_with_flags (abfd, \".got.plt\", flags);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->sgotplt = s;\n     }\n@@ -286,25 +285,25 @@ _bfd_elf_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n   s = bfd_make_section_anyway_with_flags (abfd, \".gnu.version_d\",\n \t\t\t\t\t  flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".gnu.version\",\n \t\t\t\t\t  flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, 1))\n+      || !bfd_set_section_alignment (s, 1))\n     return FALSE;\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".gnu.version_r\",\n \t\t\t\t\t  flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".dynsym\",\n \t\t\t\t\t  flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   elf_hash_table (info)->dynsym = s;\n \n@@ -315,7 +314,7 @@ _bfd_elf_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".dynamic\", flags);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n \n   /* The special symbol _DYNAMIC is always set to the start of the\n@@ -334,7 +333,7 @@ _bfd_elf_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, \".hash\",\n \t\t\t\t\t      flags | SEC_READONLY);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;\n     }\n@@ -344,7 +343,7 @@ _bfd_elf_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, \".gnu.hash\",\n \t\t\t\t\t      flags | SEC_READONLY);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       /* For 64-bit ELF, .gnu.hash is a non-uniform entity size section:\n \t 4 32-bit words followed by variable count of 64-bit words, then\n@@ -395,7 +394,7 @@ _bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n   htab->splt = s;\n \n@@ -415,7 +414,7 @@ _bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t   ? \".rela.plt\" : \".rel.plt\"),\n \t\t\t\t\t  flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->srelplt = s;\n \n@@ -466,7 +465,7 @@ _bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t   ? \".rela.bss\" : \".rel.bss\"),\n \t\t\t\t\t\t  flags | SEC_READONLY);\n \t  if (s == NULL\n-\t      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+\t      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \t    return FALSE;\n \t  htab->srelbss = s;\n \n@@ -477,8 +476,7 @@ _bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t   ? \".rela.data.rel.ro\" : \".rel.data.rel.ro\"),\n \t\t    flags | SEC_READONLY));\n \t      if (s == NULL\n-\t\t  || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t\t  bed->s->log_file_align))\n+\t\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \t\treturn FALSE;\n \t      htab->sreldynrelro = s;\n \t    }\n@@ -3099,20 +3097,18 @@ _bfd_elf_adjust_dynamic_copy (struct bfd_link_info *info,\n      know the symbol alignment requirement, we start with the\n      maximum alignment and check low bits of the symbol address\n      for the minimum alignment.  */\n-  power_of_two = bfd_get_section_alignment (sec->owner, sec);\n+  power_of_two = bfd_section_alignment (sec);\n   mask = ((bfd_vma) 1 << power_of_two) - 1;\n   while ((h->root.u.def.value & mask) != 0)\n     {\n        mask >>= 1;\n        --power_of_two;\n     }\n \n-  if (power_of_two > bfd_get_section_alignment (dynbss->owner,\n-\t\t\t\t\t\tdynbss))\n+  if (power_of_two > bfd_section_alignment (dynbss))\n     {\n       /* Adjust the section alignment if needed.  */\n-      if (! bfd_set_section_alignment (dynbss->owner, dynbss,\n-\t\t\t\t       power_of_two))\n+      if (!bfd_set_section_alignment (dynbss, power_of_two))\n \treturn FALSE;\n     }\n \n@@ -3949,7 +3945,7 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n     {\n       const char *name;\n \n-      name = bfd_get_section_name (abfd, s);\n+      name = bfd_section_name (s);\n       if (CONST_STRNEQ (name, \".gnu.warning.\"))\n \t{\n \t  char *msg;\n@@ -11393,8 +11389,7 @@ elf_reloc_link_order (bfd *output_bfd,\n \n \tcase bfd_reloc_overflow:\n \t  if (link_order->type == bfd_section_reloc_link_order)\n-\t    sym_name = bfd_section_name (output_bfd,\n-\t\t\t\t\t link_order->u.reloc.p->u.section);\n+\t    sym_name = bfd_section_name (link_order->u.reloc.p->u.section);\n \t  else\n \t    sym_name = link_order->u.reloc.p->u.name;\n \t  (*info->callbacks->reloc_overflow) (info, NULL, sym_name,\n@@ -11837,7 +11832,7 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)\n \t    }\n \n \t  attr_size = bfd_elf_obj_attr_size (abfd);\n-\t  bfd_set_section_size (abfd, o, attr_size);\n+\t  bfd_set_section_size (o, attr_size);\n \t  /* Skip this section later on.  */\n \t  o->map_head.link_order = NULL;\n \t  if (attr_size)\n@@ -13588,7 +13583,7 @@ bfd_elf_parse_eh_frame_entries (bfd *abfd ATTRIBUTE_UNUSED,\n \n       for (sec = ibfd->sections; sec; sec = sec->next)\n \t{\n-\t  if (CONST_STRNEQ (bfd_section_name (ibfd, sec), \".eh_frame_entry\")\n+\t  if (CONST_STRNEQ (bfd_section_name (sec), \".eh_frame_entry\")\n \t      && init_reloc_cookie_rels (&cookie, info, ibfd, sec))\n \t    {\n \t      _bfd_elf_parse_eh_frame_entry (info, sec, &cookie);\n@@ -14444,7 +14439,7 @@ get_dynamic_reloc_section_name (bfd *       abfd,\n \t\t\t\tbfd_boolean is_rela)\n {\n   char *name;\n-  const char *old_name = bfd_get_section_name (NULL, sec);\n+  const char *old_name = bfd_section_name (sec);\n   const char *prefix = is_rela ? \".rela\" : \".rel\";\n \n   if (old_name == NULL)\n@@ -14527,7 +14522,7 @@ _bfd_elf_make_dynamic_reloc_section (asection *sec,\n \t\t section named \"auto\" we'll get \".relauto\" which is\n \t\t seen to be a .rela section.  */\n \t      elf_section_type (reloc_sec) = is_rela ? SHT_RELA : SHT_REL;\n-\t      if (! bfd_set_section_alignment (dynobj, reloc_sec, alignment))\n+\t      if (!bfd_set_section_alignment (reloc_sec, alignment))\n \t\treloc_sec = NULL;\n \t    }\n \t}"
    },
    {
      "sha": "6f3bd0d5650818e5429fc64775593a160ccee844",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -6790,7 +6790,7 @@ elfNN_aarch64_relocate_section (bfd *output_bfd,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       if (r_symndx != 0\n@@ -7273,7 +7273,7 @@ elfNN_aarch64_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n \n       for (sec = ibfd->sections; sec != NULL; sec = sec->next)\n \t{\n-\t  if ((bfd_get_section_flags (ibfd, sec)\n+\t  if ((bfd_section_flags (sec)\n \t       & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t      == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t    only_data_sections = FALSE;\n@@ -7519,13 +7519,13 @@ aarch64_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  (bed->dynamic_sec_flags\n \t\t\t\t\t   | SEC_READONLY));\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->srelgot = s;\n \n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->sgot = s;\n   htab->sgot->size += GOT_ENTRY_SIZE;\n@@ -7547,8 +7547,7 @@ aarch64_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n     {\n       s = bfd_make_section_anyway_with_flags (abfd, \".got.plt\", flags);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->sgotplt = s;\n     }\n@@ -9150,7 +9149,7 @@ elfNN_aarch64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* Strip this section if we don't need it; see the\n \t     comment below.  */\n \t}\n-      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), \".rela\"))\n+      else if (CONST_STRNEQ (bfd_section_name (s), \".rela\"))\n \t{\n \t  if (s->size != 0 && s != htab->root.srelplt)\n \t    relocs = TRUE;"
    },
    {
      "sha": "da10178d4feecdbbd87f437110222f9577f01811",
      "filename": "bfd/elfnn-ia64.c",
      "status": "modified",
      "additions": 13,
      "deletions": 16,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfnn-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfnn-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-ia64.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -956,7 +956,7 @@ elfNN_ia64_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr,\n {\n   const char *name;\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   if (is_unwind_section_name (abfd, name))\n     {\n@@ -1561,11 +1561,10 @@ elfNN_ia64_create_dynamic_sections (bfd *abfd,\n     return FALSE;\n \n   {\n-    flagword flags = bfd_get_section_flags (abfd, ia64_info->root.sgot);\n-    bfd_set_section_flags (abfd, ia64_info->root.sgot,\n-\t\t\t   SEC_SMALL_DATA | flags);\n+    flagword flags = bfd_section_flags (ia64_info->root.sgot);\n+    bfd_set_section_flags (ia64_info->root.sgot, SEC_SMALL_DATA | flags);\n     /* The .got section is always aligned at 8 bytes.  */\n-    if (! bfd_set_section_alignment (abfd, ia64_info->root.sgot, 3))\n+    if (!bfd_set_section_alignment (ia64_info->root.sgot, 3))\n       return FALSE;\n   }\n \n@@ -1579,7 +1578,7 @@ elfNN_ia64_create_dynamic_sections (bfd *abfd,\n \t\t\t\t\t   | SEC_LINKER_CREATED\n \t\t\t\t\t   | SEC_READONLY));\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, LOG_SECTION_ALIGN))\n+      || !bfd_set_section_alignment (s, LOG_SECTION_ALIGN))\n     return FALSE;\n   ia64_info->rel_pltoff_sec = s;\n \n@@ -1977,11 +1976,11 @@ get_got (bfd *abfd, struct bfd_link_info *info,\n       got = ia64_info->root.sgot;\n \n       /* The .got section is always aligned at 8 bytes.  */\n-      if (!bfd_set_section_alignment (abfd, got, 3))\n+      if (!bfd_set_section_alignment (got, 3))\n \treturn NULL;\n \n-      flags = bfd_get_section_flags (abfd, got);\n-      if (! bfd_set_section_flags (abfd, got, SEC_SMALL_DATA | flags))\n+      flags = bfd_section_flags (got);\n+      if (!bfd_set_section_flags (got, SEC_SMALL_DATA | flags))\n \treturn NULL;\n     }\n \n@@ -2016,7 +2015,7 @@ get_fptr (bfd *abfd, struct bfd_link_info *info,\n \t\t\t\t\t\t     ? 0 : SEC_READONLY)\n \t\t\t\t\t\t  | SEC_LINKER_CREATED));\n       if (!fptr\n-\t  || !bfd_set_section_alignment (abfd, fptr, 4))\n+\t  || !bfd_set_section_alignment (fptr, 4))\n \t{\n \t  BFD_ASSERT (0);\n \t  return NULL;\n@@ -2034,8 +2033,7 @@ get_fptr (bfd *abfd, struct bfd_link_info *info,\n \t\t\t\t\t\t\t  | SEC_LINKER_CREATED\n \t\t\t\t\t\t\t  | SEC_READONLY));\n \t  if (fptr_rel == NULL\n-\t      || !bfd_set_section_alignment (abfd, fptr_rel,\n-\t\t\t\t\t     LOG_SECTION_ALIGN))\n+\t      || !bfd_set_section_alignment (fptr_rel, LOG_SECTION_ALIGN))\n \t    {\n \t      BFD_ASSERT (0);\n \t      return NULL;\n@@ -2071,7 +2069,7 @@ get_pltoff (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t    | SEC_SMALL_DATA\n \t\t\t\t\t\t    | SEC_LINKER_CREATED));\n       if (!pltoff\n-\t  || !bfd_set_section_alignment (abfd, pltoff, 4))\n+\t  || !bfd_set_section_alignment (pltoff, 4))\n \t{\n \t  BFD_ASSERT (0);\n \t  return NULL;\n@@ -2112,8 +2110,7 @@ get_reloc_section (bfd *abfd,\n \t\t\t\t\t\t  | SEC_LINKER_CREATED\n \t\t\t\t\t\t  | SEC_READONLY));\n       if (srel == NULL\n-\t  || !bfd_set_section_alignment (dynobj, srel,\n-\t\t\t\t\t LOG_SECTION_ALIGN))\n+\t  || !bfd_set_section_alignment (srel, LOG_SECTION_ALIGN))\n \treturn NULL;\n     }\n \n@@ -3171,7 +3168,7 @@ elfNN_ia64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n \t  /* It's OK to base decisions on the section name, because none\n \t     of the dynobj section names depend upon the input files.  */\n-\t  name = bfd_get_section_name (dynobj, sec);\n+\t  name = bfd_section_name (sec);\n \n \t  if (strcmp (name, \".got.plt\") == 0)\n \t    strip = FALSE;"
    },
    {
      "sha": "ccf904af1bcc8c339f02945f8cfbac7f20ad7a88",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -310,13 +310,13 @@ riscv_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  (bed->dynamic_sec_flags\n \t\t\t\t\t   | SEC_READONLY));\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->srelgot = s;\n \n   s = s_got = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->sgot = s;\n \n@@ -327,8 +327,7 @@ riscv_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n     {\n       s = bfd_make_section_anyway_with_flags (abfd, \".got.plt\", flags);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->sgotplt = s;\n \n@@ -1840,7 +1839,7 @@ riscv_elf_relocate_section (bfd *output_bfd,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       resolved_to_zero = (h != NULL\n@@ -3160,7 +3159,7 @@ _bfd_riscv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n \n       for (sec = ibfd->sections; sec != NULL; sec = sec->next)\n \t{\n-\t  if ((bfd_get_section_flags (ibfd, sec)\n+\t  if ((bfd_section_flags (sec)\n \t       & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t      == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t    only_data_sections = FALSE;"
    },
    {
      "sha": "e7290aaab1d522d6c757a82647bbf86c138677de",
      "filename": "bfd/elfxx-aarch64.c",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-aarch64.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -758,11 +758,9 @@ _bfd_aarch64_elf_link_setup_gnu_properties (struct bfd_link_info *info,\n \t      _(\"%F%P: failed to create GNU property section\\n\"));\n \n           align = (bfd_get_mach (ebfd) & bfd_mach_aarch64_ilp32) ? 2 : 3;\n-          if (!bfd_set_section_alignment (ebfd, sec, align))\n-            {\n-              info->callbacks->einfo (_(\"%F%pA: failed to align section\\n\"),\n-                                      sec);\n-            }\n+\t  if (!bfd_set_section_alignment (sec, align))\n+\t    info->callbacks->einfo (_(\"%F%pA: failed to align section\\n\"),\n+\t\t\t\t    sec);\n \n \t  elf_section_type (sec) = SHT_NOTE;\n \t}"
    },
    {
      "sha": "496e42e7c5d50b273cdb62a586e5f58f093322b3",
      "filename": "bfd/elfxx-mips.c",
      "status": "modified",
      "additions": 37,
      "deletions": 44,
      "changes": 81,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-mips.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1726,7 +1726,7 @@ section_allows_mips16_refs_p (asection *section)\n {\n   const char *name;\n \n-  name = bfd_get_section_name (section->owner, section);\n+  name = bfd_section_name (section);\n   return (FN_STUB_P (name)\n \t  || CALL_STUB_P (name)\n \t  || CALL_FP_STUB_P (name)\n@@ -1937,7 +1937,7 @@ mips_elf_add_la25_intro (struct mips_elf_la25_stub *stub,\n \n   /* Make sure that any padding goes before the stub.  */\n   align = input_section->alignment_power;\n-  if (!bfd_set_section_alignment (s->owner, s, align))\n+  if (!bfd_set_section_alignment (s, align))\n     return FALSE;\n   if (align > 3)\n     s->size = (1 << align) - 8;\n@@ -1974,7 +1974,7 @@ mips_elf_add_la25_trampoline (struct mips_elf_la25_stub *stub,\n       asection *input_section = stub->h->root.root.u.def.section;\n       s = htab->add_stub_section (\".text\", NULL,\n \t\t\t\t  input_section->output_section);\n-      if (s == NULL || !bfd_set_section_alignment (s->owner, s, 4))\n+      if (s == NULL || !bfd_set_section_alignment (s, 4))\n \treturn FALSE;\n       htab->strampoline = s;\n     }\n@@ -2992,7 +2992,7 @@ mips_elf_output_extsym (struct mips_elf_link_hash_entry *h, void *data)\n \t    h->esym.asym.sc = scUndefined;\n \t  else\n \t    {\n-\t      name = bfd_section_name (output_section->owner, output_section);\n+\t      name = bfd_section_name (output_section);\n \n \t      if (strcmp (name, \".text\") == 0)\n \t\th->esym.asym.sc = scText;\n@@ -3265,8 +3265,8 @@ mips_elf_rel_dyn_section (struct bfd_link_info *info, bfd_boolean create_p)\n \t\t\t\t\t\t    | SEC_LINKER_CREATED\n \t\t\t\t\t\t    | SEC_READONLY));\n       if (sreloc == NULL\n-\t  || ! bfd_set_section_alignment (dynobj, sreloc,\n-\t\t\t\t\t  MIPS_ELF_LOG_FILE_ALIGN (dynobj)))\n+\t  || !bfd_set_section_alignment (sreloc,\n+\t\t\t\t\t MIPS_ELF_LOG_FILE_ALIGN (dynobj)))\n \treturn NULL;\n     }\n   return sreloc;\n@@ -5201,8 +5201,7 @@ mips_elf_create_compact_rel_section\n \n       s = bfd_make_section_anyway_with_flags (abfd, \".compact_rel\", flags);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t  MIPS_ELF_LOG_FILE_ALIGN (abfd)))\n+\t  || !bfd_set_section_alignment (s, MIPS_ELF_LOG_FILE_ALIGN (abfd)))\n \treturn FALSE;\n \n       s->size = sizeof (Elf32_External_compact_rel);\n@@ -5236,7 +5235,7 @@ mips_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n      in the function stub generation and in the linker script.  */\n   s = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, 4))\n+      || !bfd_set_section_alignment (s, 4))\n     return FALSE;\n   htab->root.sgot = s;\n \n@@ -5537,7 +5536,7 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,\n \t\t\t\t\t\tsymtab_hdr->sh_link,\n \t\t\t\t\t\tsym->st_name);\n       if (*namep == NULL || **namep == '\\0')\n-\t*namep = bfd_section_name (input_bfd, sec);\n+\t*namep = bfd_section_name (sec);\n \n       /* For relocations against a section symbol and ones against no\n \t symbol (absolute relocations) infer the ISA mode from the addend.  */\n@@ -5735,7 +5734,7 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,\n \t      sec = NULL;\n \t      for (o = input_bfd->sections; o != NULL; o = o->next)\n \t\t{\n-\t\t  if (CALL_FP_STUB_P (bfd_get_section_name (input_bfd, o)))\n+\t\t  if (CALL_FP_STUB_P (bfd_section_name (o)))\n \t\t    {\n \t\t      sec = h->call_fp_stub;\n \t\t      break;\n@@ -7385,7 +7384,7 @@ _bfd_mips_elf_section_processing (bfd *abfd, Elf_Internal_Shdr *hdr)\n \n   if (hdr->bfd_section != NULL)\n     {\n-      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);\n+      const char *name = bfd_section_name (hdr->bfd_section);\n \n       /* .sbss is not handled specially here because the GNU/Linux\n \t prelinker can convert .sbss from NOBITS to PROGBITS and\n@@ -7514,10 +7513,9 @@ _bfd_mips_elf_section_from_shdr (bfd *abfd,\n \n   if (flags)\n     {\n-      if (! bfd_set_section_flags (abfd, hdr->bfd_section,\n-\t\t\t\t   (bfd_get_section_flags (abfd,\n-\t\t\t\t\t\t\t   hdr->bfd_section)\n-\t\t\t\t    | flags)))\n+      if (!bfd_set_section_flags (hdr->bfd_section,\n+\t\t\t\t  (bfd_section_flags (hdr->bfd_section)\n+\t\t\t\t   | flags)))\n \treturn FALSE;\n     }\n \n@@ -7624,7 +7622,7 @@ _bfd_mips_elf_section_from_shdr (bfd *abfd,\n bfd_boolean\n _bfd_mips_elf_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec)\n {\n-  const char *name = bfd_get_section_name (abfd, sec);\n+  const char *name = bfd_section_name (sec);\n \n   if (strcmp (name, \".liblist\") == 0)\n     {\n@@ -7764,12 +7762,12 @@ bfd_boolean\n _bfd_mips_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t\tasection *sec, int *retval)\n {\n-  if (strcmp (bfd_get_section_name (abfd, sec), \".scommon\") == 0)\n+  if (strcmp (bfd_section_name (sec), \".scommon\") == 0)\n     {\n       *retval = SHN_MIPS_SCOMMON;\n       return TRUE;\n     }\n-  if (strcmp (bfd_get_section_name (abfd, sec), \".acommon\") == 0)\n+  if (strcmp (bfd_section_name (sec), \".acommon\") == 0)\n     {\n       *retval = SHN_MIPS_ACOMMON;\n       return TRUE;\n@@ -7996,7 +7994,7 @@ _bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_get_linker_section (abfd, \".dynamic\");\n       if (s != NULL)\n \t{\n-\t  if (! bfd_set_section_flags (abfd, s, flags))\n+\t  if (!bfd_set_section_flags (s, flags))\n \t    return FALSE;\n \t}\n     }\n@@ -8013,8 +8011,7 @@ _bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  MIPS_ELF_STUB_SECTION_NAME (abfd),\n \t\t\t\t\t  flags | SEC_CODE);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t      MIPS_ELF_LOG_FILE_ALIGN (abfd)))\n+      || !bfd_set_section_alignment (s, MIPS_ELF_LOG_FILE_ALIGN (abfd)))\n     return FALSE;\n   htab->sstubs = s;\n \n@@ -8025,8 +8022,7 @@ _bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       s = bfd_make_section_anyway_with_flags (abfd, \".rld_map\",\n \t\t\t\t\t      flags &~ (flagword) SEC_READONLY);\n       if (s == NULL\n-\t  || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t  MIPS_ELF_LOG_FILE_ALIGN (abfd)))\n+\t  || !bfd_set_section_alignment (s, MIPS_ELF_LOG_FILE_ALIGN (abfd)))\n \treturn FALSE;\n     }\n \n@@ -8069,24 +8065,24 @@ _bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n       /* Change alignments of some sections.  */\n       s = bfd_get_linker_section (abfd, \".hash\");\n       if (s != NULL)\n-\t(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n+\tbfd_set_section_alignment (s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n \n       s = bfd_get_linker_section (abfd, \".dynsym\");\n       if (s != NULL)\n-\t(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n+\tbfd_set_section_alignment (s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n \n       s = bfd_get_linker_section (abfd, \".dynstr\");\n       if (s != NULL)\n-\t(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n+\tbfd_set_section_alignment (s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n \n       /* ??? */\n       s = bfd_get_section_by_name (abfd, \".reginfo\");\n       if (s != NULL)\n-\t(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n+\tbfd_set_section_alignment (s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n \n       s = bfd_get_linker_section (abfd, \".dynamic\");\n       if (s != NULL)\n-\t(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n+\tbfd_set_section_alignment (s, MIPS_ELF_LOG_FILE_ALIGN (abfd));\n     }\n \n   if (bfd_link_executable (info))\n@@ -8378,7 +8374,7 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \n   /* Check for the mips16 stub sections.  */\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n   if (FN_STUB_P (name))\n     {\n       unsigned long r_symndx;\n@@ -9375,12 +9371,12 @@ _bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t     Encourage better cache usage by aligning.  We do this\n \t     lazily to avoid pessimizing traditional objects.  */\n \t  if (!htab->is_vxworks\n-\t      && !bfd_set_section_alignment (dynobj, htab->root.splt, 5))\n+\t      && !bfd_set_section_alignment (htab->root.splt, 5))\n \t    return FALSE;\n \n \t  /* Make sure that .got.plt is word-aligned.  We do this lazily\n \t     for the same reason as above.  */\n-\t  if (!bfd_set_section_alignment (dynobj, htab->root.sgotplt,\n+\t  if (!bfd_set_section_alignment (htab->root.sgotplt,\n \t\t\t\t\t  MIPS_ELF_LOG_FILE_ALIGN (dynobj)))\n \t    return FALSE;\n \n@@ -9588,16 +9584,15 @@ _bfd_mips_elf_always_size_sections (bfd *output_bfd,\n   sect = bfd_get_section_by_name (output_bfd, \".reginfo\");\n   if (sect != NULL)\n     {\n-      bfd_set_section_size (output_bfd, sect, sizeof (Elf32_External_RegInfo));\n+      bfd_set_section_size (sect, sizeof (Elf32_External_RegInfo));\n       sect->flags |= SEC_FIXED_SIZE | SEC_HAS_CONTENTS;\n     }\n \n   /* The .MIPS.abiflags section has a fixed size.  */\n   sect = bfd_get_section_by_name (output_bfd, \".MIPS.abiflags\");\n   if (sect != NULL)\n     {\n-      bfd_set_section_size (output_bfd, sect,\n-\t\t\t    sizeof (Elf_External_ABIFlags_v0));\n+      bfd_set_section_size (sect, sizeof (Elf_External_ABIFlags_v0));\n       sect->flags |= SEC_FIXED_SIZE | SEC_HAS_CONTENTS;\n     }\n \n@@ -10030,7 +10025,7 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,\n \n       /* It's OK to base decisions on the section name, because none\n \t of the dynobj section names depend upon the input files.  */\n-      name = bfd_get_section_name (dynobj, s);\n+      name = bfd_section_name (s);\n \n       if ((s->flags & SEC_LINKER_CREATED) == 0)\n \tcontinue;\n@@ -10048,8 +10043,7 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t assert a DT_TEXTREL entry rather than testing whether\n \t\t there exists a relocation to a read only section or\n \t\t not.  */\n-\t      outname = bfd_get_section_name (output_bfd,\n-\t\t\t\t\t      s->output_section);\n+\t      outname = bfd_section_name (s->output_section);\n \t      target = bfd_get_section_by_name (output_bfd, outname + 4);\n \t      if ((target != NULL\n \t\t   && (target->flags & SEC_READONLY) != 0\n@@ -12445,7 +12439,7 @@ _bfd_mips_final_write_processing (bfd *abfd)\n \n \tcase SHT_MIPS_GPTAB:\n \t  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);\n-\t  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);\n+\t  name = bfd_section_name ((*hdrpp)->bfd_section);\n \t  BFD_ASSERT (name != NULL\n \t\t      && CONST_STRNEQ (name, \".gptab.\"));\n \t  sec = bfd_get_section_by_name (abfd, name + sizeof \".gptab\" - 1);\n@@ -12455,7 +12449,7 @@ _bfd_mips_final_write_processing (bfd *abfd)\n \n \tcase SHT_MIPS_CONTENT:\n \t  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);\n-\t  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);\n+\t  name = bfd_section_name ((*hdrpp)->bfd_section);\n \t  BFD_ASSERT (name != NULL\n \t\t      && CONST_STRNEQ (name, \".MIPS.content\"));\n \t  sec = bfd_get_section_by_name (abfd,\n@@ -12475,7 +12469,7 @@ _bfd_mips_final_write_processing (bfd *abfd)\n \n \tcase SHT_MIPS_EVENTS:\n \t  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);\n-\t  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);\n+\t  name = bfd_section_name ((*hdrpp)->bfd_section);\n \t  BFD_ASSERT (name != NULL);\n \t  if (CONST_STRNEQ (name, \".MIPS.events\"))\n \t    sec = bfd_get_section_by_name (abfd,\n@@ -12861,8 +12855,7 @@ _bfd_mips_elf_gc_mark_extra_sections (struct bfd_link_info *info,\n \n       for (o = sub->sections; o != NULL; o = o->next)\n \tif (!o->gc_mark\n-\t    && MIPS_ELF_ABIFLAGS_SECTION_NAME_P\n-\t\t (bfd_get_section_name (sub, o)))\n+\t    && MIPS_ELF_ABIFLAGS_SECTION_NAME_P (bfd_section_name (o)))\n \t  {\n \t    if (!_bfd_elf_gc_mark (info, o, gc_mark_hook))\n \t      return FALSE;\n@@ -15024,7 +15017,7 @@ _bfd_mips_elf_final_link (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t\t\t\t   \".rtproc\",\n \t\t\t\t\t\t\t\t   flags);\n \t\t  if (rtproc_sec == NULL\n-\t\t      || ! bfd_set_section_alignment (abfd, rtproc_sec, 4))\n+\t\t      || !bfd_set_section_alignment (rtproc_sec, 4))\n \t\t    return FALSE;\n \t\t}\n "
    },
    {
      "sha": "735e83f3de5cc9866d4ed34240aec001626c5136",
      "filename": "bfd/elfxx-sparc.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1263,15 +1263,14 @@ create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)\n \n   s = bfd_make_section_with_flags (abfd, \".iplt\", pltflags);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n+      || !bfd_set_section_alignment (s, bed->plt_alignment))\n     return FALSE;\n   htab->iplt = s;\n \n   s = bfd_make_section_with_flags (abfd, \".rela.iplt\",\n \t\t\t\t   flags | SEC_READONLY);\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s,\n-\t\t\t\t      bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->irelplt = s;\n \n@@ -4164,8 +4163,7 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,\n \t\t     || r_type == R_SPARC_UA32\n \t\t     || r_type == R_SPARC_DISP32)\n \t\t    && (((input_section->flags & SEC_DEBUGGING) != 0\n-\t\t\t && strcmp (bfd_section_name (input_bfd,\n-\t\t\t\t\t\t      input_section),\n+\t\t\t && strcmp (bfd_section_name (input_section),\n \t\t\t\t    \".stab\") == 0)\n \t\t\t|| _bfd_elf_section_offset (output_bfd, info,\n \t\t\t\t\t\t    input_section,\n@@ -4194,7 +4192,7 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,\n \t\t    if (name == NULL)\n \t\t      return FALSE;\n \t\t    if (*name == '\\0')\n-\t\t      name = bfd_section_name (input_bfd, sec);\n+\t\t      name = bfd_section_name (sec);\n \t\t  }\n \t\t(*info->callbacks->reloc_overflow)\n \t\t  (info, (h ? &h->root : NULL), name, howto->name,"
    },
    {
      "sha": "41af167e1e187df686df92302b544611134f3ef9",
      "filename": "bfd/elfxx-tilegx.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-tilegx.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1438,13 +1438,13 @@ tilegx_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n \t\t\t\t\t  (bed->dynamic_sec_flags\n \t\t\t\t\t   | SEC_READONLY));\n   if (s == NULL\n-      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->srelgot = s;\n \n   s = s_got = bfd_make_section_anyway_with_flags (abfd, \".got\", flags);\n   if (s == NULL\n-      || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n+      || !bfd_set_section_alignment (s, bed->s->log_file_align))\n     return FALSE;\n   htab->sgot = s;\n \n@@ -1455,8 +1455,7 @@ tilegx_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n     {\n       s = bfd_make_section_anyway_with_flags (abfd, \".got.plt\", flags);\n       if (s == NULL\n-\t  || !bfd_set_section_alignment (abfd, s,\n-\t\t\t\t\t bed->s->log_file_align))\n+\t  || !bfd_set_section_alignment (s, bed->s->log_file_align))\n \treturn FALSE;\n       htab->sgotplt = s;\n \n@@ -3032,7 +3031,7 @@ tilegx_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \t  name = (bfd_elf_string_from_elf_section\n \t\t  (input_bfd, symtab_hdr->sh_link, sym->st_name));\n \t  if (name == NULL || *name == '\\0')\n-\t    name = bfd_section_name (input_bfd, sec);\n+\t    name = bfd_section_name (sec);\n \t}\n \n       switch (r_type)"
    },
    {
      "sha": "d8165d17528006689572634db163274fdc004033",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 13,
      "deletions": 18,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1238,7 +1238,7 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t{\n \t  /* Strip these too.  */\n \t}\n-      else if (htab->is_reloc_section (bfd_get_section_name (dynobj, s)))\n+      else if (htab->is_reloc_section (bfd_section_name (s)))\n \t{\n \t  if (s->size != 0\n \t      && s != htab->elf.srelplt\n@@ -1280,8 +1280,7 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t it is empty.  Update its section alignment now since it\n \t is non-empty.  */\n       if (s == htab->elf.iplt)\n-\tbfd_set_section_alignment (s->owner, s,\n-\t\t\t\t   htab->plt.iplt_alignment);\n+\tbfd_set_section_alignment (s, htab->plt.iplt_alignment);\n \n       /* Allocate memory for the section contents.  We use bfd_zalloc\n \t here in case unused entries are not reclaimed before the\n@@ -2625,7 +2624,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t  if (sec == NULL)\n \t    info->callbacks->einfo (_(\"%F%P: failed to create GNU property section\\n\"));\n \n-\t  if (!bfd_set_section_alignment (ebfd, sec, class_align))\n+\t  if (!bfd_set_section_alignment (sec, class_align))\n \t    {\n error_alignment:\n \t      info->callbacks->einfo (_(\"%F%pA: failed to align section\\n\"),\n@@ -2839,11 +2838,11 @@ _bfd_x86_elf_link_setup_gnu_properties\n      instead of in create_dynamic_sections so that they are always\n      properly aligned even if create_dynamic_sections isn't called.  */\n   sec = htab->elf.sgot;\n-  if (!bfd_set_section_alignment (dynobj, sec, got_align))\n+  if (!bfd_set_section_alignment (sec, got_align))\n     goto error_alignment;\n \n   sec = htab->elf.sgotplt;\n-  if (!bfd_set_section_alignment (dynobj, sec, got_align))\n+  if (!bfd_set_section_alignment (sec, got_align))\n     goto error_alignment;\n \n   /* Create the ifunc sections here so that check_relocs can be\n@@ -2881,8 +2880,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t    = bfd_log2 (htab->non_lazy_plt->plt_entry_size);\n \n \t  sec = pltsec;\n-\t  if (!bfd_set_section_alignment (sec->owner, sec,\n-\t\t\t\t\t  plt_alignment))\n+\t  if (!bfd_set_section_alignment (sec, plt_alignment))\n \t    goto error_alignment;\n \n \t  /* Create the GOT procedure linkage table.  */\n@@ -2892,8 +2890,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t  if (sec == NULL)\n \t    info->callbacks->einfo (_(\"%F%P: failed to create GOT PLT section\\n\"));\n \n-\t  if (!bfd_set_section_alignment (dynobj, sec,\n-\t\t\t\t\t  non_lazy_plt_alignment))\n+\t  if (!bfd_set_section_alignment (sec, non_lazy_plt_alignment))\n \t    goto error_alignment;\n \n \t  htab->plt_got = sec;\n@@ -2913,8 +2910,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t\t  if (sec == NULL)\n \t\t    info->callbacks->einfo (_(\"%F%P: failed to create IBT-enabled PLT section\\n\"));\n \n-\t\t  if (!bfd_set_section_alignment (dynobj, sec,\n-\t\t\t\t\t\t  plt_alignment))\n+\t\t  if (!bfd_set_section_alignment (sec, plt_alignment))\n \t\t    goto error_alignment;\n \t\t}\n \t      else if (htab->params->bndplt && ABI_64_P (dynobj))\n@@ -2928,8 +2924,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t\t  if (sec == NULL)\n \t\t    info->callbacks->einfo (_(\"%F%P: failed to create BND PLT section\\n\"));\n \n-\t\t  if (!bfd_set_section_alignment (dynobj, sec,\n-\t\t\t\t\t\t  non_lazy_plt_alignment))\n+\t\t  if (!bfd_set_section_alignment (sec, non_lazy_plt_alignment))\n \t\t    goto error_alignment;\n \t\t}\n \n@@ -2949,7 +2944,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t  if (sec == NULL)\n \t    info->callbacks->einfo (_(\"%F%P: failed to create PLT .eh_frame section\\n\"));\n \n-\t  if (!bfd_set_section_alignment (dynobj, sec, class_align))\n+\t  if (!bfd_set_section_alignment (sec, class_align))\n \t    goto error_alignment;\n \n \t  htab->plt_eh_frame = sec;\n@@ -2962,7 +2957,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t      if (sec == NULL)\n \t\tinfo->callbacks->einfo (_(\"%F%P: failed to create GOT PLT .eh_frame section\\n\"));\n \n-\t      if (!bfd_set_section_alignment (dynobj, sec, class_align))\n+\t      if (!bfd_set_section_alignment (sec, class_align))\n \t\tgoto error_alignment;\n \n \t      htab->plt_got_eh_frame = sec;\n@@ -2976,7 +2971,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t      if (sec == NULL)\n \t\tinfo->callbacks->einfo (_(\"%F%P: failed to create the second PLT .eh_frame section\\n\"));\n \n-\t      if (!bfd_set_section_alignment (dynobj, sec, class_align))\n+\t      if (!bfd_set_section_alignment (sec, class_align))\n \t\tgoto error_alignment;\n \n \t      htab->plt_second_eh_frame = sec;\n@@ -2995,7 +2990,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n \t section backwards, resulting in a warning and section lma not\n \t being set properly.  It later leads to a \"File truncated\"\n \t error.  */\n-      if (!bfd_set_section_alignment (sec->owner, sec, 0))\n+      if (!bfd_set_section_alignment (sec, 0))\n \tgoto error_alignment;\n \n       htab->plt.iplt_alignment = (normal_target"
    },
    {
      "sha": "18f332f60d302f8c4c7c240479478f191f57c905",
      "filename": "bfd/i386msdos.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/i386msdos.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/i386msdos.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/i386msdos.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -109,7 +109,7 @@ msdos_object_p (bfd *abfd)\n       return NULL;\n     }\n \n-  bfd_set_section_size (abfd, section, size);\n+  bfd_set_section_size (section, size);\n   section->alignment_power = 4;\n \n   return abfd->xvec;\n@@ -135,16 +135,16 @@ msdos_write_object_contents (bfd *abfd)\n     {\n       if (sec->size == 0)\n \tcontinue;\n-      if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)\n+      if (bfd_section_flags (sec) & SEC_ALLOC)\n \t{\n-\t  bfd_vma sec_vma = bfd_get_section_vma (abfd, sec) + sec->size;\n+\t  bfd_vma sec_vma = bfd_section_vma (sec) + sec->size;\n \t  if (sec_vma > high_vma)\n \t    high_vma = sec_vma;\n \t}\n-      if (bfd_get_section_flags (abfd, sec) & SEC_LOAD)\n+      if (bfd_section_flags (sec) & SEC_LOAD)\n \t{\n \t  file_ptr sec_end = (sizeof (hdr)\n-\t\t\t      + bfd_get_section_vma (abfd, sec)\n+\t\t\t      + bfd_section_vma (sec)\n \t\t\t      + sec->size);\n \t  if (sec_end > outfile_size)\n \t    outfile_size = sec_end;\n@@ -195,9 +195,9 @@ msdos_set_section_contents (bfd *abfd,\n   if (count == 0)\n     return TRUE;\n \n-  section->filepos = EXE_PAGE_SIZE + bfd_get_section_vma (abfd, section);\n+  section->filepos = EXE_PAGE_SIZE + bfd_section_vma (section);\n \n-  if (bfd_get_section_flags (abfd, section) & SEC_LOAD)\n+  if (bfd_section_flags (section) & SEC_LOAD)\n     {\n       if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0\n \t  || bfd_bwrite (location, count, abfd) != count)"
    },
    {
      "sha": "143b8eb950e993ae0c5f6fde07023dbb4549ef16",
      "filename": "bfd/linker.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/linker.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/linker.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/linker.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2396,7 +2396,7 @@ _bfd_generic_reloc_link_order (bfd *abfd,\n \t  (*info->callbacks->reloc_overflow)\n \t    (info, NULL,\n \t     (link_order->type == bfd_section_reloc_link_order\n-\t      ? bfd_section_name (abfd, link_order->u.reloc.p->u.section)\n+\t      ? bfd_section_name (link_order->u.reloc.p->u.section)\n \t      : link_order->u.reloc.p->u.name),\n \t     r->howto->name, link_order->u.reloc.p->addend,\n \t     NULL, NULL, 0);\n@@ -2942,7 +2942,7 @@ _bfd_generic_section_already_linked (bfd *abfd ATTRIBUTE_UNUSED,\n      into a single large link once section, which defeats the purpose\n      of having link once sections in the first place.  */\n \n-  name = bfd_get_section_name (abfd, sec);\n+  name = bfd_section_name (sec);\n \n   already_linked_list = bfd_section_already_linked_table_lookup (name);\n "
    },
    {
      "sha": "117e410d834378e11810595289eac424693279af",
      "filename": "bfd/mach-o.c",
      "status": "modified",
      "additions": 15,
      "deletions": 16,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/mach-o.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/mach-o.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -437,7 +437,7 @@ bfd_mach_o_convert_section_name_to_mach_o (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t\t   bfd_mach_o_section *section)\n {\n   const mach_o_section_name_xlat *xlat;\n-  const char *name = bfd_get_section_name (abfd, sect);\n+  const char *name = bfd_section_name (sect);\n   const char *segname;\n   const char *dot;\n   unsigned int len;\n@@ -2583,13 +2583,13 @@ bfd_mach_o_mangle_sections (bfd *abfd, bfd_mach_o_data_struct *mdata)\n   target_index = 0;\n   for (sec = abfd->sections; sec; sec = sec->next)\n     {\n-      unsigned bfd_align = bfd_get_section_alignment (abfd, sec);\n+      unsigned bfd_align = bfd_section_alignment (sec);\n       bfd_mach_o_section *msect = bfd_mach_o_get_mach_o_section (sec);\n \n       mdata->sections[target_index] = msect;\n \n-      msect->addr = bfd_get_section_vma (abfd, sec);\n-      msect->size = bfd_get_section_size (sec);\n+      msect->addr = bfd_section_vma (sec);\n+      msect->size = bfd_section_size (sec);\n \n       /* Use the largest alignment set, in case it was bumped after the\n \t section was created.  */\n@@ -2808,7 +2808,7 @@ bfd_mach_o_set_section_flags_from_bfd (bfd *abfd ATTRIBUTE_UNUSED,\n   bfd_mach_o_section *s = bfd_mach_o_get_mach_o_section (sec);\n \n   /* Create default flags.  */\n-  bfd_flags = bfd_get_section_flags (abfd, sec);\n+  bfd_flags = bfd_section_flags (sec);\n   if ((bfd_flags & SEC_CODE) == SEC_CODE)\n     s->flags = BFD_MACH_O_S_ATTR_PURE_INSTRUCTIONS\n       | BFD_MACH_O_S_ATTR_SOME_INSTRUCTIONS\n@@ -2983,7 +2983,7 @@ bfd_mach_o_build_exec_seg_command (bfd *abfd, bfd_mach_o_segment_command *seg)\n   for (s = seg->sect_head; s != NULL; s = s->next)\n     {\n       asection *sec = s->bfdsection;\n-      flagword flags = bfd_get_section_flags (abfd, sec);\n+      flagword flags = bfd_section_flags (sec);\n \n       /* Adjust segment size.  */\n       seg->vmsize = FILE_ALIGN (seg->vmsize, s->align);\n@@ -3502,7 +3502,7 @@ bfd_boolean\n bfd_mach_o_new_section_hook (bfd *abfd, asection *sec)\n {\n   bfd_mach_o_section *s;\n-  unsigned bfdalign = bfd_get_section_alignment (abfd, sec);\n+  unsigned bfdalign = bfd_section_alignment (sec);\n \n   s = bfd_mach_o_get_mach_o_section (sec);\n   if (s == NULL)\n@@ -3526,10 +3526,10 @@ bfd_mach_o_new_section_hook (bfd *abfd, asection *sec)\n \t  s->flags = xlat->macho_sectype | xlat->macho_secattr;\n \t  s->align = xlat->sectalign > bfdalign ? xlat->sectalign\n \t\t\t\t\t\t: bfdalign;\n-\t  (void) bfd_set_section_alignment (abfd, sec, s->align);\n-\t  bfd_flags = bfd_get_section_flags (abfd, sec);\n+\t  bfd_set_section_alignment (sec, s->align);\n+\t  bfd_flags = bfd_section_flags (sec);\n \t  if (bfd_flags == SEC_NO_FLAGS)\n-\t    bfd_set_section_flags (abfd, sec, xlat->bfd_flags);\n+\t    bfd_set_section_flags (sec, xlat->bfd_flags);\n \t}\n       else\n \t/* Create default flags.  */\n@@ -3540,13 +3540,12 @@ bfd_mach_o_new_section_hook (bfd *abfd, asection *sec)\n }\n \n static void\n-bfd_mach_o_init_section_from_mach_o (bfd *abfd, asection *sec,\n-\t\t\t\t     unsigned long prot)\n+bfd_mach_o_init_section_from_mach_o (asection *sec, unsigned long prot)\n {\n   flagword flags;\n   bfd_mach_o_section *section;\n \n-  flags = bfd_get_section_flags (abfd, sec);\n+  flags = bfd_section_flags (sec);\n   section = bfd_mach_o_get_mach_o_section (sec);\n \n   /* TODO: see if we should use the xlat system for doing this by\n@@ -3584,7 +3583,7 @@ bfd_mach_o_init_section_from_mach_o (bfd *abfd, asection *sec,\n   if (section->nreloc != 0)\n     flags |= SEC_RELOC;\n \n-  bfd_set_section_flags (abfd, sec, flags);\n+  bfd_set_section_flags (sec, flags);\n \n   sec->vma = section->addr;\n   sec->lma = section->addr;\n@@ -3651,7 +3650,7 @@ bfd_mach_o_read_section_32 (bfd *abfd, unsigned long prot)\n   section->reserved2 = bfd_h_get_32 (abfd, raw.reserved2);\n   section->reserved3 = 0;\n \n-  bfd_mach_o_init_section_from_mach_o (abfd, sec, prot);\n+  bfd_mach_o_init_section_from_mach_o (sec, prot);\n \n   return sec;\n }\n@@ -3694,7 +3693,7 @@ bfd_mach_o_read_section_64 (bfd *abfd, unsigned long prot)\n   section->reserved2 = bfd_h_get_32 (abfd, raw.reserved2);\n   section->reserved3 = bfd_h_get_32 (abfd, raw.reserved3);\n \n-  bfd_mach_o_init_section_from_mach_o (abfd, sec, prot);\n+  bfd_mach_o_init_section_from_mach_o (sec, prot);\n \n   return sec;\n }"
    },
    {
      "sha": "736ee4bed8194cb61e18891f00ea074416bfce1e",
      "filename": "bfd/mmo.c",
      "status": "modified",
      "additions": 36,
      "deletions": 44,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/mmo.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/mmo.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mmo.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -596,7 +596,7 @@ static bfd_boolean\n mmo_section_has_contents (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *p ATTRIBUTE_UNUSED)\n {\n   /* The point is to match what --extract-symbols does (well, negated).  */\n-  return bfd_get_section_size (sec) != 0;\n+  return bfd_section_size (sec) != 0;\n }\n \n /* Find out whether we should omit symbol consistency checks for this\n@@ -642,10 +642,10 @@ static void\n mmo_find_sec_w_addr (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *p)\n {\n   struct mmo_find_sec_info *infop = (struct mmo_find_sec_info *) p;\n-  bfd_vma vma = bfd_get_section_vma (abfd, sec);\n+  bfd_vma vma = bfd_section_vma (sec);\n \n   /* Ignore sections that aren't loaded.  */\n-  if ((bfd_get_section_flags (abfd, sec) & (SEC_LOAD | SEC_ALLOC))\n+  if ((bfd_section_flags (sec) & (SEC_LOAD | SEC_ALLOC))\n       !=  (SEC_LOAD | SEC_ALLOC))\n     return;\n \n@@ -657,10 +657,10 @@ static void\n mmo_find_sec_w_addr_grow (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *p)\n {\n   struct mmo_find_sec_info *infop = (struct mmo_find_sec_info *) p;\n-  bfd_vma vma = bfd_get_section_vma (abfd, sec);\n+  bfd_vma vma = bfd_section_vma (sec);\n \n   /* Ignore sections that aren't loaded.  */\n-  if ((bfd_get_section_flags (abfd, sec) & (SEC_LOAD | SEC_ALLOC))\n+  if ((bfd_section_flags (sec) & (SEC_LOAD | SEC_ALLOC))\n       !=  (SEC_LOAD | SEC_ALLOC))\n     return;\n \n@@ -700,12 +700,11 @@ mmo_decide_section (bfd *abfd, bfd_vma vma)\n       if (sec == NULL)\n \treturn NULL;\n \n-      if (! sec->user_set_vma && ! bfd_set_section_vma (abfd, sec, vma))\n+      if (!sec->user_set_vma && !bfd_set_section_vma (sec, vma))\n \treturn NULL;\n \n-      if (! bfd_set_section_flags (abfd, sec,\n-\t\t\t\t   bfd_get_section_flags (abfd, sec)\n-\t\t\t\t   | SEC_CODE | SEC_LOAD | SEC_ALLOC))\n+      if (!bfd_set_section_flags (sec, (bfd_section_flags (sec)\n+\t\t\t\t\t| SEC_CODE | SEC_LOAD | SEC_ALLOC)))\n \treturn NULL;\n     }\n   else if ((vma >> 56) == 0x20)\n@@ -715,12 +714,11 @@ mmo_decide_section (bfd *abfd, bfd_vma vma)\n       if (sec == NULL)\n \treturn NULL;\n \n-      if (! sec->user_set_vma && ! bfd_set_section_vma (abfd, sec, vma))\n+      if (!sec->user_set_vma && !bfd_set_section_vma (sec, vma))\n \treturn NULL;\n \n-      if (! bfd_set_section_flags (abfd, sec,\n-\t\t\t\t   bfd_get_section_flags (abfd, sec)\n-\t\t\t\t   | SEC_LOAD | SEC_ALLOC))\n+      if (!bfd_set_section_flags (sec, (bfd_section_flags (sec)\n+\t\t\t\t\t| SEC_LOAD | SEC_ALLOC)))\n \treturn NULL;\n     }\n \n@@ -733,12 +731,11 @@ mmo_decide_section (bfd *abfd, bfd_vma vma)\n   sprintf (sec_name, \".MMIX.sec.%d\", abfd->tdata.mmo_data->sec_no++);\n   sec = mmo_make_section (abfd, sec_name);\n \n-  if (! sec->user_set_vma && ! bfd_set_section_vma (abfd, sec, vma))\n+  if (!sec->user_set_vma && !bfd_set_section_vma (sec, vma))\n     return NULL;\n \n-  if (! bfd_set_section_flags (abfd, sec,\n-\t\t\t       bfd_get_section_flags (abfd, sec)\n-\t\t\t       | SEC_LOAD | SEC_ALLOC))\n+  if (!bfd_set_section_flags (sec, (bfd_section_flags (sec)\n+\t\t\t\t    | SEC_LOAD | SEC_ALLOC)))\n     return NULL;\n   return sec;\n }\n@@ -1136,14 +1133,13 @@ mmo_get_spec_section (bfd *abfd, int spec_data_number)\n \n   /* Add in the section flags we found to those bfd entered during this\n      process and set the contents.  */\n-  if (! bfd_set_section_flags (abfd, sec,\n-\t\t\t       bfd_sec_flags_from_mmo_flags (flags)\n-\t\t\t       | bfd_get_section_flags (abfd, sec)\n-\t\t\t       | (section_length != 0 ? SEC_HAS_CONTENTS : 0))\n-      || ! bfd_set_section_size (abfd, sec, sec->size + section_length)\n+  if (!bfd_set_section_flags (sec,\n+\t\t\t      (bfd_sec_flags_from_mmo_flags (flags)\n+\t\t\t       | bfd_section_flags (sec)\n+\t\t\t       | (section_length != 0 ? SEC_HAS_CONTENTS : 0)))\n+      || !bfd_set_section_size (sec, sec->size + section_length)\n       /* Set VMA only for the first occurrence.  */\n-      || (! sec->user_set_vma\n-\t  && ! bfd_set_section_vma  (abfd, sec, section_vma)))\n+      || (!sec->user_set_vma && !bfd_set_section_vma (sec, section_vma)))\n     {\n       /* If we get an error for any of the calls above, signal more than\n \t just a format error for the spec section.  */\n@@ -1561,9 +1557,8 @@ mmo_get_loc (asection *sec, bfd_vma vma, int size)\n \n \t  /* We get here for the first time (at other times too) for this\n \t     section.  Say we have contents.  */\n-\t  if (! bfd_set_section_flags (sec->owner, sec,\n-\t\t\t\t       bfd_get_section_flags (sec->owner, sec)\n-\t\t\t\t       | SEC_HAS_CONTENTS))\n+\t  if (!bfd_set_section_flags (sec, (bfd_section_flags (sec)\n+\t\t\t\t\t    | SEC_HAS_CONTENTS)))\n \t    return NULL;\n \t}\n     }\n@@ -2070,18 +2065,16 @@ mmo_scan (bfd *abfd)\n      section flags must be set then.  */\n   sec = bfd_get_section_by_name (abfd, MMO_TEXT_SECTION_NAME);\n   if (sec != NULL\n-      && (bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS)\n-      && ! bfd_set_section_flags (abfd, sec,\n-\t\t\t\t  bfd_get_section_flags (abfd, sec)\n-\t\t\t\t  | SEC_ALLOC | SEC_LOAD | SEC_CODE))\n+      && (bfd_section_flags (sec) & SEC_HAS_CONTENTS)\n+      && !bfd_set_section_flags (sec, (bfd_section_flags (sec)\n+\t\t\t\t       | SEC_ALLOC | SEC_LOAD | SEC_CODE)))\n     error = TRUE;\n \n   sec = bfd_get_section_by_name (abfd, MMO_DATA_SECTION_NAME);\n   if (sec != NULL\n-      && (bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS)\n-      && ! bfd_set_section_flags (abfd, sec,\n-\t\t\t\t  bfd_get_section_flags (abfd, sec)\n-\t\t\t\t  | SEC_ALLOC | SEC_LOAD))\n+      && (bfd_section_flags (sec) & SEC_HAS_CONTENTS)\n+      && !bfd_set_section_flags (sec, (bfd_section_flags (sec)\n+\t\t\t\t       | SEC_ALLOC | SEC_LOAD)))\n     error = TRUE;\n \n   /* Free whatever resources we took.  */\n@@ -2432,7 +2425,7 @@ bfd_sec_flags_from_mmo_flags (flagword flags)\n static bfd_boolean\n mmo_has_leading_or_trailing_zero_tetra_p (bfd *abfd, asection *sec)\n {\n-  bfd_vma secaddr = bfd_get_section_vma (abfd, sec);\n+  bfd_vma secaddr = bfd_section_vma (sec);\n \n   if (sec->size < 4)\n     return FALSE;\n@@ -2464,7 +2457,7 @@ mmo_internal_write_section (bfd *abfd, asection *sec)\n \n   if (strcmp (sec->name, MMO_TEXT_SECTION_NAME) == 0)\n     {\n-      bfd_vma secaddr = bfd_get_section_vma (abfd, sec);\n+      bfd_vma secaddr = bfd_section_vma (sec);\n \n       /* Because leading and trailing zeros are omitted in output, we need to\n \t specify the section boundaries so they're correct when the file\n@@ -2485,7 +2478,7 @@ mmo_internal_write_section (bfd *abfd, asection *sec)\n     }\n   else if (strcmp (sec->name, MMO_DATA_SECTION_NAME) == 0)\n     {\n-      bfd_vma secaddr = bfd_get_section_vma (abfd, sec);\n+      bfd_vma secaddr = bfd_section_vma (sec);\n \n       /* Same goes as for MMO_TEXT_SECTION_NAME above.  */\n       if (sec->size != 0\n@@ -2519,15 +2512,15 @@ mmo_internal_write_section (bfd *abfd, asection *sec)\n     }\n   /* Ignore sections that are just allocated or empty; we write out\n      _contents_ here.  */\n-  else if ((bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS) != 0\n+  else if ((bfd_section_flags (sec) & SEC_HAS_CONTENTS) != 0\n \t   && sec->size != 0)\n     {\n       if (!mmo_write_section_description (abfd, sec))\n \treturn FALSE;\n \n       /* Writing a LOP_LOC ends the LOP_SPEC data, and makes data actually\n \t loaded.  */\n-      if (bfd_get_section_flags (abfd, sec) & SEC_LOAD)\n+      if (bfd_section_flags (sec) & SEC_LOAD)\n \treturn (! abfd->tdata.mmo_data->have_error\n \t\t&& mmo_write_loc_chunk_list (abfd,\n \t\t\t\t\t mmo_section_data (sec)->head));\n@@ -2646,10 +2639,9 @@ EXAMPLE\n      for all alien sections; perhaps mmo.em should clear that flag.  Might\n      be related to weak references.  */\n   mmo_write_tetra (abfd,\n-\t\t   mmo_sec_flags_from_bfd_flags\n-\t\t   (bfd_get_section_flags (abfd, sec)));\n+\t\t   mmo_sec_flags_from_bfd_flags (bfd_section_flags (sec)));\n   mmo_write_octa (abfd, sec->size);\n-  mmo_write_octa (abfd, bfd_get_section_vma (abfd, sec));\n+  mmo_write_octa (abfd, bfd_section_vma (sec));\n   return TRUE;\n }\n \n@@ -3171,7 +3163,7 @@ mmo_write_section_unless_reg_contents (bfd *abfd, asection *sec, void *p)\n   /* Exclude the convenience register section.  */\n   if (strcmp (sec->name, MMIX_REG_SECTION_NAME) == 0)\n     {\n-      if (bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS)\n+      if (bfd_section_flags (sec) & SEC_HAS_CONTENTS)\n \t{\n \t  /* Make sure it hasn't got contents.  It seems impossible to\n \t     make it carry contents, so we don't have a test-case for"
    },
    {
      "sha": "b537dfd96d1f0cc2f2f2501a1c1cb6d6f53aa22b",
      "filename": "bfd/opncls.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/opncls.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/opncls.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/opncls.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1218,7 +1218,7 @@ bfd_get_debug_link_info_1 (bfd *abfd, void *crc32_out)\n   if (sect == NULL)\n     return NULL;\n \n-  size = bfd_get_section_size (sect);\n+  size = bfd_section_size (sect);\n \n   /* PR 22794: Make sure that the section has a reasonable size.  */\n   if (size < 8 || size >= bfd_get_size (abfd))\n@@ -1308,7 +1308,7 @@ bfd_get_alt_debug_link_info (bfd * abfd, bfd_size_type *buildid_len,\n   if (sect == NULL)\n     return NULL;\n \n-  size = bfd_get_section_size (sect);\n+  size = bfd_section_size (sect);\n   if (size < 8 || size >= bfd_get_size (abfd))\n     return NULL;\n \n@@ -1322,7 +1322,7 @@ bfd_get_alt_debug_link_info (bfd * abfd, bfd_size_type *buildid_len,\n   /* BuildID value is stored after the filename.  */\n   name = (char *) contents;\n   buildid_offset = strnlen (name, size) + 1;\n-  if (buildid_offset >= bfd_get_section_size (sect))\n+  if (buildid_offset >= bfd_section_size (sect))\n     return NULL;\n \n   *buildid_len = size - buildid_offset;\n@@ -1727,14 +1727,14 @@ bfd_create_gnu_debuglink_section (bfd *abfd, const char *filename)\n   debuglink_size &= ~3;\n   debuglink_size += 4;\n \n-  if (! bfd_set_section_size (abfd, sect, debuglink_size))\n+  if (!bfd_set_section_size (sect, debuglink_size))\n     /* XXX Should we delete the section from the bfd ?  */\n     return NULL;\n \n   /* PR 21193: Ensure that the section has 4-byte alignment for the CRC.\n      Note - despite the name of the function being called, we are\n      setting an alignment power, not a byte alignment value.  */\n-  bfd_set_section_alignment (abfd, sect, 2);\n+  bfd_set_section_alignment (sect, 2);\n \n   return sect;\n }\n@@ -1872,7 +1872,7 @@ get_build_id (bfd *abfd)\n       return NULL;\n     }\n \n-  size = bfd_get_section_size (sect);\n+  size = bfd_section_size (sect);\n   /* FIXME: Should we support smaller build-id notes ?  */\n   if (size < 0x24)\n     {\n@@ -1890,7 +1890,7 @@ get_build_id (bfd *abfd)\n   /* FIXME: Paranoia - allow for compressed build-id sections.\n      Maybe we should complain if this size is different from\n      the one obtained above...  */\n-  size = bfd_get_section_size (sect);\n+  size = bfd_section_size (sect);\n   if (size < sizeof (Elf_External_Note))\n     {\n       bfd_set_error (bfd_error_invalid_operation);"
    },
    {
      "sha": "a0c3ac0fa66b2062b310d91df677ae4e1cba4965",
      "filename": "bfd/pdp11.c",
      "status": "modified",
      "additions": 7,
      "deletions": 9,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/pdp11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/pdp11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pdp11.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2802,17 +2802,17 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \t  break;\n \tcase N_TEXT | N_EXT:\n \t  section = obj_textsec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \tcase N_DATA | N_EXT:\n \t  /* Treat N_SETV symbols as N_DATA symbol; see comment in\n \t     translate_from_native_sym_flags.  */\n \t  section = obj_datasec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \tcase N_BSS | N_EXT:\n \t  section = obj_bsssec (abfd);\n-\t  value -= bfd_get_section_vma (abfd, section);\n+\t  value -= bfd_section_vma (section);\n \t  break;\n \t}\n \n@@ -3151,8 +3151,7 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n \t  (*flaginfo->info->callbacks->reloc_overflow)\n \t    (flaginfo->info, NULL,\n \t     (p->type == bfd_section_reloc_link_order\n-\t      ? bfd_section_name (flaginfo->output_bfd,\n-\t\t\t\t  pr->u.section)\n+\t      ? bfd_section_name (pr->u.section)\n \t      : pr->u.name),\n \t     howto->name, pr->addend, NULL,\n \t     (asection *) NULL, (bfd_vma) 0);\n@@ -3477,7 +3476,7 @@ pdp11_aout_link_input_section (struct aout_final_link_info *flaginfo,\n \t\t    asection *s;\n \n \t\t    s = aout_reloc_type_to_section (input_bfd, r_type);\n-\t\t    name = bfd_section_name (input_bfd, s);\n+\t\t    name = bfd_section_name (s);\n \t\t  }\n \t\t(*flaginfo->info->callbacks->reloc_overflow)\n \t\t  (flaginfo->info, (h ? &h->root : NULL), name, howto->name,\n@@ -3997,8 +3996,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \treturn FALSE;\n       PUT_WORD (output_bfd, strtab_index, outsym->e_strx);\n       PUT_WORD (output_bfd,\n-\t\t(bfd_get_section_vma (output_bfd,\n-\t\t\t\t      obj_textsec (input_bfd)->output_section)\n+\t\t(bfd_section_vma (obj_textsec (input_bfd)->output_section)\n \t\t + obj_textsec (input_bfd)->output_offset),\n \t\toutsym->e_value);\n       ++obj_aout_external_sym_count (output_bfd);\n@@ -4206,7 +4204,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\t  BFD_ASSERT (bfd_is_abs_section (output_section)\n \t\t\t      || output_section->owner == output_bfd);\n \t\t  val = (hresolve->root.u.def.value\n-\t\t\t + bfd_get_section_vma (output_bfd, output_section)\n+\t\t\t + bfd_section_vma (output_section)\n \t\t\t + input_section->output_offset);\n \n \t\t  /* Get the correct type based on the section.  If"
    },
    {
      "sha": "c0b97351defb044a4498fc70908ed89dfc83526e",
      "filename": "bfd/pei-x86_64.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/pei-x86_64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/pei-x86_64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pei-x86_64.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -770,7 +770,7 @@ pex64_bfd_print_pdata_section (bfd *abfd, void *vfile, asection *pdata_section)\n \t  if (PEX64_IS_RUNTIME_FUNCTION_CHAINED (&rf))\n \t    {\n \t      bfd_vma altent = PEX64_GET_UNWINDDATA_UNIFIED_RVA (&rf);\n-\t      bfd_vma pdata_vma = bfd_get_section_vma (abfd, pdata_section);\n+\t      bfd_vma pdata_vma = bfd_section_vma (pdata_section);\n \t      struct pex64_runtime_function arf;\n \n \t      fprintf (file, \"\\t shares information with \");"
    },
    {
      "sha": "1e2b104430235b8e0b8ae62fa720e90a1a83c665",
      "filename": "bfd/peicode.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/peicode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/peicode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/peicode.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -608,16 +608,16 @@ pe_ILF_make_a_section (pe_ILF_vars * vars,\n \n   flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_KEEP | SEC_IN_MEMORY;\n \n-  bfd_set_section_flags (vars->abfd, sec, flags | extra_flags);\n+  bfd_set_section_flags (sec, flags | extra_flags);\n \n-  (void) bfd_set_section_alignment (vars->abfd, sec, 2);\n+  bfd_set_section_alignment (sec, 2);\n \n   /* Check that we will not run out of space.  */\n   BFD_ASSERT (vars->data + size < vars->bim->buffer + vars->bim->size);\n \n   /* Set the section size and contents.  The actual\n      contents are filled in by our parent.  */\n-  bfd_set_section_size (vars->abfd, sec, (bfd_size_type) size);\n+  bfd_set_section_size (sec, (bfd_size_type) size);\n   sec->contents = vars->data;\n   sec->target_index = vars->sec_index ++;\n "
    },
    {
      "sha": "0c67ecd313ab1a3281baa38878574c4aa0d20c4e",
      "filename": "bfd/reloc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/reloc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/reloc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/reloc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1526,8 +1526,7 @@ _bfd_clear_contents (reloc_howto_type *howto,\n \n   /* For a range list, use 1 instead of 0 as placeholder.  0\n      would terminate the list, hiding any later entries.  */\n-  if (strcmp (bfd_get_section_name (input_bfd, input_section),\n-\t      \".debug_ranges\") == 0\n+  if (strcmp (bfd_section_name (input_section), \".debug_ranges\") == 0\n       && (howto->dst_mask & 1) != 0)\n     x |= 1;\n "
    },
    {
      "sha": "3a9cb26023453746e30ebf9ff56f072e53a0d141",
      "filename": "bfd/section.c",
      "status": "modified",
      "additions": 28,
      "deletions": 27,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/section.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/section.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/section.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -554,26 +554,31 @@ CODE_FRAGMENT\n .   would use a comma expression, eg: \"((ptr)->foo = val, TRUE)\" and some\n .   compilers will complain about comma expressions that have no effect.  *}\n .static inline bfd_boolean\n-.bfd_set_section_userdata (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr,\n-.\t\t\t   void * val)\n+.bfd_set_section_userdata (asection *sec, void *val)\n .{\n-.  ptr->userdata = val;\n+.  sec->userdata = val;\n .  return TRUE;\n .}\n .\n .static inline bfd_boolean\n-.bfd_set_section_vma (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr, bfd_vma val)\n+.bfd_set_section_vma (asection *sec, bfd_vma val)\n .{\n-.  ptr->vma = ptr->lma = val;\n-.  ptr->user_set_vma = TRUE;\n+.  sec->vma = sec->lma = val;\n+.  sec->user_set_vma = TRUE;\n .  return TRUE;\n .}\n .\n .static inline bfd_boolean\n-.bfd_set_section_alignment (bfd * abfd ATTRIBUTE_UNUSED, asection * ptr,\n-.\t\t\t    unsigned int val)\n+.bfd_set_section_lma (asection *sec, bfd_vma val)\n .{\n-.  ptr->alignment_power = val;\n+.  sec->lma = val;\n+.  return TRUE;\n+.}\n+.\n+.static inline bfd_boolean\n+.bfd_set_section_alignment (asection *sec, unsigned int val)\n+.{\n+.  sec->alignment_power = val;\n .  return TRUE;\n .}\n .\n@@ -1289,13 +1294,12 @@ FUNCTION\n \tbfd_set_section_flags\n \n SYNOPSIS\n-\tbfd_boolean bfd_set_section_flags\n-\t  (bfd *abfd, asection *sec, flagword flags);\n+\tbfd_boolean bfd_set_section_flags (asection *sec, flagword flags);\n \n DESCRIPTION\n-\tSet the attributes of the section @var{sec} in the BFD\n-\t@var{abfd} to the value @var{flags}. Return <<TRUE>> on success,\n-\t<<FALSE>> on error. Possible error returns are:\n+\tSet the attributes of the section @var{sec} to the value @var{flags}.\n+\tReturn <<TRUE>> on success, <<FALSE>> on error.  Possible error\n+\treturns are:\n \n \to <<bfd_error_invalid_operation>> -\n \tThe section cannot have one or more of the attributes\n@@ -1305,9 +1309,7 @@ DESCRIPTION\n */\n \n bfd_boolean\n-bfd_set_section_flags (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t       sec_ptr section,\n-\t\t       flagword flags)\n+bfd_set_section_flags (asection *section, flagword flags)\n {\n   section->flags = flags;\n   return TRUE;\n@@ -1319,21 +1321,21 @@ FUNCTION\n \n SYNOPSIS\n \tvoid bfd_rename_section\n-\t  (bfd *abfd, asection *sec, const char *newname);\n+\t  (asection *sec, const char *newname);\n \n DESCRIPTION\n-\tRename section @var{sec} in @var{abfd} to @var{newname}.\n+\tRename section @var{sec} to @var{newname}.\n */\n \n void\n-bfd_rename_section (bfd *abfd, sec_ptr sec, const char *newname)\n+bfd_rename_section (asection *sec, const char *newname)\n {\n   struct section_hash_entry *sh;\n \n   sh = (struct section_hash_entry *)\n     ((char *) sec - offsetof (struct section_hash_entry, section));\n   sh->section.name = newname;\n-  bfd_hash_rename (&abfd->section_htab, newname, &sh->root);\n+  bfd_hash_rename (&sec->owner->section_htab, newname, &sh->root);\n }\n \n /*\n@@ -1417,8 +1419,7 @@ FUNCTION\n \tbfd_set_section_size\n \n SYNOPSIS\n-\tbfd_boolean bfd_set_section_size\n-\t  (bfd *abfd, asection *sec, bfd_size_type val);\n+\tbfd_boolean bfd_set_section_size (asection *sec, bfd_size_type val);\n \n DESCRIPTION\n \tSet @var{sec} to the size @var{val}. If the operation is\n@@ -1431,18 +1432,18 @@ DESCRIPTION\n */\n \n bfd_boolean\n-bfd_set_section_size (bfd *abfd, sec_ptr ptr, bfd_size_type val)\n+bfd_set_section_size (asection *sec, bfd_size_type val)\n {\n   /* Once you've started writing to any section you cannot create or change\n      the size of any others.  */\n \n-  if (abfd->output_has_begun)\n+  if (sec->owner == NULL || sec->owner->output_has_begun)\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n       return FALSE;\n     }\n \n-  ptr->size = val;\n+  sec->size = val;\n   return TRUE;\n }\n \n@@ -1486,7 +1487,7 @@ bfd_set_section_contents (bfd *abfd,\n {\n   bfd_size_type sz;\n \n-  if (!(bfd_get_section_flags (abfd, section) & SEC_HAS_CONTENTS))\n+  if (!(bfd_section_flags (section) & SEC_HAS_CONTENTS))\n     {\n       bfd_set_error (bfd_error_no_contents);\n       return FALSE;"
    },
    {
      "sha": "9a2754ebe69e674c4c958b95f2251e1dc2dcf727",
      "filename": "bfd/syms.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/syms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/syms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/syms.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1290,7 +1290,7 @@ _bfd_stab_section_find_nearest_line (bfd *abfd,\n \n   /* We are passed a section relative offset.  The offsets in the\n      stabs information are absolute.  */\n-  offset += bfd_get_section_vma (abfd, section);\n+  offset += bfd_section_vma (section);\n \n #ifdef ENABLE_CACHING\n   if (info->cached_indexentry != NULL"
    },
    {
      "sha": "4dde056e1ee67e638a3af4beda2a08897f0e557b",
      "filename": "bfd/vms-alpha.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/vms-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/vms-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-alpha.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -632,7 +632,7 @@ _bfd_vms_slurp_eisd (bfd *abfd, unsigned int offset)\n       section->size = size;\n       section->vma = vaddr;\n \n-      if (!bfd_set_section_flags (abfd, section, bfd_flags))\n+      if (!bfd_set_section_flags (section, bfd_flags))\n \treturn FALSE;\n     }\n \n@@ -687,7 +687,7 @@ _bfd_vms_slurp_eihs (bfd *abfd, unsigned int offset)\n       section->size = dstsize;\n       section->filepos = VMS_BLOCK_SIZE * (dstvbn - 1);\n \n-      if (!bfd_set_section_flags (abfd, section, bfd_flags))\n+      if (!bfd_set_section_flags (section, bfd_flags))\n \treturn FALSE;\n \n       PRIV (dst_section) = section;\n@@ -705,7 +705,7 @@ _bfd_vms_slurp_eihs (bfd *abfd, unsigned int offset)\n       section->size = dmtbytes;\n       section->filepos = VMS_BLOCK_SIZE * (dmtvbn - 1);\n \n-      if (!bfd_set_section_flags (abfd, section, bfd_flags))\n+      if (!bfd_set_section_flags (section, bfd_flags))\n \treturn FALSE;\n     }\n \n@@ -1261,7 +1261,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \t\t    new_flags |= SEC_CODE;\n \t\t    new_flags &= ~SEC_DATA;\n \t\t  }\n-\t\tif (!bfd_set_section_flags (abfd, section, new_flags))\n+\t\tif (!bfd_set_section_flags (section, new_flags))\n \t\t  return FALSE;\n \n \t\t/* Give a non-overlapping vma to non absolute sections.  */\n@@ -2441,7 +2441,7 @@ vms_slurp_debug (bfd *abfd)\n       section = bfd_make_section (abfd, \"$DST$\");\n       if (!section)\n \treturn FALSE;\n-      if (!bfd_set_section_flags (abfd, section, flags))\n+      if (!bfd_set_section_flags (section, flags))\n \treturn FALSE;\n       PRIV (dst_section) = section;\n     }\n@@ -4623,7 +4623,7 @@ build_module_list (bfd *abfd)\n \t section and build the list of modules.  This is sufficient\n \t since we can compute the start address and the end address\n \t of every module from the section contents.  */\n-      bfd_size_type size = bfd_get_section_size (dmt);\n+      bfd_size_type size = bfd_section_size (dmt);\n       unsigned char *ptr, *end;\n \n       ptr = (unsigned char *) bfd_alloc (abfd, size);\n@@ -9324,7 +9324,7 @@ vms_new_section_hook (bfd * abfd, asection *section)\n   vms_debug2 ((1, \"vms_new_section_hook (%p, [%u]%s)\\n\",\n \t       abfd, section->index, section->name));\n \n-  if (! bfd_set_section_alignment (abfd, section, 0))\n+  if (!bfd_set_section_alignment (section, 0))\n     return FALSE;\n \n   vms_debug2 ((7, \"%u: %s\\n\", section->index, section->name));\n@@ -9412,11 +9412,11 @@ vms_get_symbol_info (bfd * abfd ATTRIBUTE_UNUSED,\n   else if (bfd_is_ind_section (sec))\n     ret->type = 'I';\n   else if ((symbol->flags & BSF_FUNCTION)\n-\t   || (bfd_get_section_flags (abfd, sec) & SEC_CODE))\n+\t   || (bfd_section_flags (sec) & SEC_CODE))\n     ret->type = 'T';\n-  else if (bfd_get_section_flags (abfd, sec) & SEC_DATA)\n+  else if (bfd_section_flags (sec) & SEC_DATA)\n     ret->type = 'D';\n-  else if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)\n+  else if (bfd_section_flags (sec) & SEC_ALLOC)\n     ret->type = 'B';\n   else\n     ret->type = '?';"
    },
    {
      "sha": "52691720aeaa0bb207f8982e06319d9829bda4f0",
      "filename": "bfd/xcofflink.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/xcofflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/bfd/xcofflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/xcofflink.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2080,14 +2080,14 @@ xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n   for (o = abfd->sections; o != first_csect; o = o->next)\n     {\n       /* Debugging sections have no csects.  */\n-      if (bfd_get_section_flags (abfd, o) & SEC_DEBUGGING)\n+      if (bfd_section_flags (o) & SEC_DEBUGGING)\n \tcontinue;\n \n       /* Reset the section size and the line number count, since the\n \t data is now attached to the csects.  Don't reset the size of\n \t the .debug section, since we need to read it below in\n \t bfd_xcoff_size_dynamic_sections.  */\n-      if (strcmp (bfd_get_section_name (abfd, o), \".debug\") != 0)\n+      if (strcmp (bfd_section_name (o), \".debug\") != 0)\n \to->size = 0;\n       o->lineno_count = 0;\n \n@@ -3019,7 +3019,7 @@ xcoff_sweep (struct bfd_link_info *info)\n \t\t  || o == xcoff_hash_table (info)->loader_section\n \t\t  || o == xcoff_hash_table (info)->linkage_section\n \t\t  || o == xcoff_hash_table (info)->descriptor_section\n-\t\t  || (bfd_get_section_flags (sub, o) & SEC_DEBUGGING)\n+\t\t  || (bfd_section_flags (o) & SEC_DEBUGGING)\n \t\t  || strcmp (o->name, \".debug\") == 0)\n \t\to->flags |= SEC_MARK;\n \t      else"
    },
    {
      "sha": "9f6300f17d6c105cabfcc01505f248ce17d50be1",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,11 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* addr2line.c, * bucomm.c, * coffgrok.c, * dlltool.c, * nm.c,\n+\t* objcopy.c, * objdump.c, * od-elf32_avr.c, * od-macho.c,\n+\t* od-xcoff.c, * prdbg.c, * rdcoff.c, * rddbg.c, * rescoff.c,\n+\t* resres.c, * size.c, * srconv.c, * strings.c, * windmc.c: Update\n+\tthroughout for bfd section macro and function changes.\n+\n 2019-09-18  Alan Modra  <amodra@gmail.com>\n \n \t* nm.c: Update bfd_get_section to bfd_asymbol_section throughout."
    },
    {
      "sha": "d9cc2881f8db8e392ceed19fcfceb679c5940c26",
      "filename": "binutils/addr2line.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/addr2line.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/addr2line.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/addr2line.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -182,14 +182,14 @@ find_address_in_section (bfd *abfd, asection *section,\n   if (found)\n     return;\n \n-  if ((bfd_get_section_flags (abfd, section) & SEC_ALLOC) == 0)\n+  if ((bfd_section_flags (section) & SEC_ALLOC) == 0)\n     return;\n \n-  vma = bfd_get_section_vma (abfd, section);\n+  vma = bfd_section_vma (section);\n   if (pc < vma)\n     return;\n \n-  size = bfd_get_section_size (section);\n+  size = bfd_section_size (section);\n   if (pc >= vma + size)\n     return;\n \n@@ -208,10 +208,10 @@ find_offset_in_section (bfd *abfd, asection *section)\n   if (found)\n     return;\n \n-  if ((bfd_get_section_flags (abfd, section) & SEC_ALLOC) == 0)\n+  if ((bfd_section_flags (section) & SEC_ALLOC) == 0)\n     return;\n \n-  size = bfd_get_section_size (section);\n+  size = bfd_section_size (section);\n   if (pc >= size)\n     return;\n "
    },
    {
      "sha": "2493fd561bc71e7edc106b715aa16ff1a7ec41ba",
      "filename": "binutils/bucomm.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/bucomm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/bucomm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/bucomm.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -94,7 +94,7 @@ bfd_nonfatal_message (const char *filename,\n       if (!filename)\n \tfilename = bfd_get_archive_filename (abfd);\n       if (section)\n-\tsection_name = bfd_get_section_name (abfd, section);\n+\tsection_name = bfd_section_name (section);\n     }\n   if (section_name)\n     fprintf (stderr, \":%s[%s]\", filename, section_name);"
    },
    {
      "sha": "177c66ed7664d56981cfe7d2ee5721df1be5ca49",
      "filename": "binutils/coffgrok.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/coffgrok.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/coffgrok.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/coffgrok.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -145,7 +145,7 @@ do_sections_p1 (struct coff_ofile *head)\n       if (strcmp (section->name, \".bss\") == 0)\n \thead->sections[i].data = 1;\n       head->sections[i].address = section->lma;\n-      head->sections[i].size = bfd_get_section_size (section);\n+      head->sections[i].size = bfd_section_size (section);\n       head->sections[i].number = idx;\n       head->sections[i].nrelocs = section->reloc_count;\n       head->sections[i].relocs ="
    },
    {
      "sha": "85304d0c37fcf064ecffe28d451d3ea48e72ce3b",
      "filename": "binutils/dlltool.c",
      "status": "modified",
      "additions": 7,
      "deletions": 9,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/dlltool.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/dlltool.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dlltool.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1384,7 +1384,7 @@ scan_drectve_symbols (bfd *abfd)\n   if (s == NULL)\n     return;\n \n-  size = bfd_get_section_size (s);\n+  size = bfd_section_size (s);\n   buf  = xmalloc (size);\n \n   bfd_get_section_contents (abfd, s, buf, 0, size);\n@@ -2482,11 +2482,9 @@ make_one_lib_file (export_type *exp, int i, int delay)\n       if (si->id != i)\n \tabort ();\n       si->sec = bfd_make_section_old_way (abfd, si->name);\n-      bfd_set_section_flags (abfd,\n-\t\t\t     si->sec,\n-\t\t\t     si->flags & applicable);\n+      bfd_set_section_flags (si->sec, si->flags & applicable);\n \n-      bfd_set_section_alignment(abfd, si->sec, si->align);\n+      bfd_set_section_alignment (si->sec, si->align);\n       si->sec->output_section = si->sec;\n       si->sym = bfd_make_empty_symbol(abfd);\n       si->sym->name = si->sec->name;\n@@ -2822,7 +2820,7 @@ make_one_lib_file (export_type *exp, int i, int delay)\n \t    arelent *imglue, *ba_rel, *ea_rel, *pea_rel;\n \n \t    /* Alignment must be set to 2**2 or you get extra stuff.  */\n-\t    bfd_set_section_alignment(abfd, sec, 2);\n+\t    bfd_set_section_alignment (sec, 2);\n \n \t    si->size = 4 * 5;\n \t    si->data = xmalloc (si->size);\n@@ -2908,8 +2906,8 @@ make_one_lib_file (export_type *exp, int i, int delay)\n       {\n \tsinfo *si = secdata + i;\n \n-\tbfd_set_section_size (abfd, si->sec, si->size);\n-\tbfd_set_section_vma (abfd, si->sec, vma);\n+\tbfd_set_section_size (si->sec, si->size);\n+\tbfd_set_section_vma (si->sec, vma);\n       }\n   }\n   /* Write them out.  */\n@@ -3691,7 +3689,7 @@ identify_search_section (bfd * abfd, asection * section, void * obj)\n   if (ms_style && ((section->flags & SEC_DATA) == 0))\n     return;\n \n-  if ((datasize = bfd_section_size (abfd, section)) == 0)\n+  if ((datasize = bfd_section_size (section)) == 0)\n     return;\n \n   data = (bfd_byte *) xmalloc (datasize + 1);"
    },
    {
      "sha": "e177d444efde547f4efa0b22a05d0014ca0700fb",
      "filename": "binutils/nm.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/nm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/nm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/nm.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -791,8 +791,8 @@ sort_symbols_by_size (bfd *abfd, bfd_boolean is_dynamic, void *minisyms,\n \t      && sec == bfd_asymbol_section (next))\n \t    sz = valueof (next) - valueof (sym);\n \t  else\n-\t    sz = (bfd_get_section_vma (abfd, sec)\n-\t\t  + bfd_section_size (abfd, sec)\n+\t    sz = (bfd_section_vma (sec)\n+\t\t  + bfd_section_size (sec)\n \t\t  - valueof (sym));\n \t}\n "
    },
    {
      "sha": "6489fbe72f90c85787096bd4d39cb67ab8f58381",
      "filename": "binutils/objcopy.c",
      "status": "modified",
      "additions": 58,
      "deletions": 61,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/objcopy.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/objcopy.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objcopy.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1255,7 +1255,7 @@ group_signature (asection *group)\n static bfd_boolean\n is_dwo_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n {\n-  const char *name = bfd_get_section_name (abfd, sec);\n+  const char *name = bfd_section_name (sec);\n   int len = strlen (name);\n \n   return strncmp (name + len - 4, \".dwo\", 4) == 0;\n@@ -1310,25 +1310,25 @@ is_strip_section_1 (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n       struct section_list *p;\n       struct section_list *q;\n \n-      p = find_section_list (bfd_get_section_name (abfd, sec), FALSE,\n+      p = find_section_list (bfd_section_name (sec), FALSE,\n \t\t\t     SECTION_CONTEXT_REMOVE);\n-      q = find_section_list (bfd_get_section_name (abfd, sec), FALSE,\n+      q = find_section_list (bfd_section_name (sec), FALSE,\n \t\t\t     SECTION_CONTEXT_COPY);\n \n       if (p && q)\n \tfatal (_(\"error: section %s matches both remove and copy options\"),\n-\t       bfd_get_section_name (abfd, sec));\n+\t       bfd_section_name (sec));\n       if (p && is_update_section (abfd, sec))\n \tfatal (_(\"error: section %s matches both update and remove options\"),\n-\t       bfd_get_section_name (abfd, sec));\n+\t       bfd_section_name (sec));\n \n       if (p != NULL)\n \treturn TRUE;\n       if (sections_copied && q == NULL)\n \treturn TRUE;\n     }\n \n-  if ((bfd_get_section_flags (abfd, sec) & SEC_DEBUGGING) != 0)\n+  if ((bfd_section_flags (sec) & SEC_DEBUGGING) != 0)\n     {\n       if (strip_symbols == STRIP_DEBUG\n \t  || strip_symbols == STRIP_UNNEEDED\n@@ -1339,7 +1339,7 @@ is_strip_section_1 (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n \t  /* By default we don't want to strip .reloc section.\n \t     This section has for pe-coff special meaning.   See\n \t     pe-dll.c file in ld, and peXXigen.c in bfd for details.  */\n-\t  if (strcmp (bfd_get_section_name (abfd, sec), \".reloc\") != 0)\n+\t  if (strcmp (bfd_section_name (sec), \".reloc\") != 0)\n \t    return TRUE;\n \t}\n \n@@ -1364,7 +1364,7 @@ is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n   if (is_strip_section_1 (abfd, sec))\n     return TRUE;\n \n-  if ((bfd_get_section_flags (abfd, sec) & SEC_GROUP) != 0)\n+  if ((bfd_section_flags (sec) & SEC_GROUP) != 0)\n     {\n       asymbol *gsym;\n       const char *gname;\n@@ -1414,7 +1414,7 @@ is_nondebug_keep_contents_section (bfd *ibfd, asection *isection)\n      directory\", but that may be the .text section for objects produced by some\n      tools, which it is not sensible to keep.  */\n   if (ibfd->xvec->flavour == bfd_target_coff_flavour)\n-    return (strcmp (bfd_get_section_name (ibfd, isection), \".buildid\") == 0);\n+    return (strcmp (bfd_section_name (isection), \".buildid\") == 0);\n \n   return FALSE;\n }\n@@ -2728,7 +2728,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t}\n \t    }\n \n-\t  if (! bfd_set_section_size (obfd, padd->section, padd->size))\n+\t  if (!bfd_set_section_size (padd->section, padd->size))\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);\n \t      return FALSE;\n@@ -2737,7 +2737,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t  pset = find_section_list (padd->name, FALSE,\n \t\t\t\t    SECTION_CONTEXT_SET_VMA | SECTION_CONTEXT_ALTER_VMA);\n \t  if (pset != NULL\n-\t      && ! bfd_set_section_vma (obfd, padd->section, pset->vma_val))\n+\t      && !bfd_set_section_vma (padd->section, pset->vma_val))\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);\n \t      return FALSE;\n@@ -2749,9 +2749,8 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t    {\n \t      padd->section->lma = pset->lma_val;\n \n-\t      if (! bfd_set_section_alignment\n-\t\t  (obfd, padd->section,\n-\t\t   bfd_section_alignment (obfd, padd->section)))\n+\t      if (!bfd_set_section_alignment\n+\t\t  (padd->section, bfd_section_alignment (padd->section)))\n \t\t{\n \t\t  bfd_nonfatal_message (NULL, obfd, padd->section, NULL);\n \t\t  return FALSE;\n@@ -2776,7 +2775,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t    }\n \n \t  osec = pupdate->section->output_section;\n-\t  if (! bfd_set_section_size (obfd, osec, pupdate->size))\n+\t  if (!bfd_set_section_size (osec, pupdate->size))\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, osec, NULL);\n \t      return FALSE;\n@@ -2793,7 +2792,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t{\n \t  bfd_size_type size;\n \t  \n-\t  size = bfd_get_section_size (osec);\n+\t  size = bfd_section_size (osec);\n \t  if (size == 0)\n \t    {\n \t      bfd_nonfatal_message (NULL, ibfd, osec, _(\"warning: note section is empty\"));\n@@ -2820,7 +2819,8 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t      else\n \t\t{\n \t\t  if (osec->output_section == NULL\n-\t\t      || ! bfd_set_section_size (obfd, osec->output_section, merged_size))\n+\t\t      || !bfd_set_section_size (osec->output_section,\n+\t\t\t\t\t\tmerged_size))\n \t\t    {\n \t\t      bfd_nonfatal_message (NULL, obfd, osec, _(\"warning: failed to set merged notes size\"));\n \t\t      free (merged_notes);\n@@ -2848,14 +2848,14 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t      continue;\n \t    }\n \n-\t  if ((bfd_get_section_flags (ibfd, osec) & SEC_HAS_CONTENTS) == 0)\n+\t  if ((bfd_section_flags (osec) & SEC_HAS_CONTENTS) == 0)\n \t    {\n \t      bfd_nonfatal_message (NULL, ibfd, osec,\n \t\t\t\t    _(\"can't dump section - it has no contents\"));\n \t      continue;\n \t    }\n \n-\t  bfd_size_type size = bfd_get_section_size (osec);\n+\t  bfd_size_type size = bfd_section_size (osec);\n \t  if (size == 0)\n \t    {\n \t      bfd_nonfatal_message (NULL, ibfd, osec,\n@@ -2948,7 +2948,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t\t\t\t   + highest_section->size,\n \t\t\t\t\t   /* FIXME: We ought to be using\n \t\t\t\t\t      COFF_PAGE_SIZE here or maybe\n-\t\t\t\t\t      bfd_get_section_alignment() (if it\n+\t\t\t\t\t      bfd_section_alignment() (if it\n \t\t\t\t\t      was set) but since this is for PE\n \t\t\t\t\t      and we know the required alignment\n \t\t\t\t\t      it is easier just to hard code it.  */\n@@ -2957,7 +2957,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t/* Umm, not sure what to do in this case.  */\n \t\tdebuglink_vma = 0x1000;\n \n-\t      bfd_set_section_vma (obfd, gnu_debuglink_section, debuglink_vma);\n+\t      bfd_set_section_vma (gnu_debuglink_section, debuglink_vma);\n \t    }\n \t}\n     }\n@@ -2991,18 +2991,18 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t      bfd_size_type size;\n \t      bfd_vma gap_start, gap_stop;\n \n-\t      flags = bfd_get_section_flags (obfd, osections[i]);\n+\t      flags = bfd_section_flags (osections[i]);\n \t      if ((flags & SEC_HAS_CONTENTS) == 0\n \t\t  || (flags & SEC_LOAD) == 0)\n \t\tcontinue;\n \n-\t      size = bfd_section_size (obfd, osections[i]);\n-\t      gap_start = bfd_section_lma (obfd, osections[i]) + size;\n-\t      gap_stop = bfd_section_lma (obfd, osections[i + 1]);\n+\t      size = bfd_section_size (osections[i]);\n+\t      gap_start = bfd_section_lma (osections[i]) + size;\n+\t      gap_stop = bfd_section_lma (osections[i + 1]);\n \t      if (gap_start < gap_stop)\n \t\t{\n-\t\t  if (! bfd_set_section_size (obfd, osections[i],\n-\t\t\t\t\t      size + (gap_stop - gap_start)))\n+\t\t  if (!bfd_set_section_size (osections[i],\n+\t\t\t\t\t     size + (gap_stop - gap_start)))\n \t\t    {\n \t\t      bfd_nonfatal_message (NULL, obfd, osections[i],\n \t\t\t\t\t    _(\"Can't fill gap after section\"));\n@@ -3021,12 +3021,11 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t  bfd_vma lma;\n \t  bfd_size_type size;\n \n-\t  lma = bfd_section_lma (obfd, osections[c - 1]);\n-\t  size = bfd_section_size (obfd, osections[c - 1]);\n+\t  lma = bfd_section_lma (osections[c - 1]);\n+\t  size = bfd_section_size (osections[c - 1]);\n \t  if (lma + size < pad_to)\n \t    {\n-\t      if (! bfd_set_section_size (obfd, osections[c - 1],\n-\t\t\t\t\t  pad_to - lma))\n+\t      if (!bfd_set_section_size (osections[c - 1], pad_to - lma))\n \t\t{\n \t\t  bfd_nonfatal_message (NULL, obfd, osections[c - 1],\n \t\t\t\t\t_(\"can't add padding\"));\n@@ -3204,7 +3203,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t      file_ptr off;\n \n \t      left = gaps[i];\n-\t      off = bfd_section_size (obfd, osections[i]) - left;\n+\t      off = bfd_section_size (osections[i]) - left;\n \n \t      while (left > 0)\n \t\t{\n@@ -3779,13 +3778,13 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n     return;\n \n   /* Get the, possibly new, name of the output section.  */\n-  name = bfd_section_name (ibfd, isection);\n-  flags = bfd_get_section_flags (ibfd, isection);\n+  name = bfd_section_name (isection);\n+  flags = bfd_section_flags (isection);\n   name = find_section_rename (name, &flags);\n \n   /* Prefix sections.  */\n   if ((prefix_alloc_sections_string)\n-      && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))\n+      && (bfd_section_flags (isection) & SEC_ALLOC))\n     prefix = prefix_alloc_sections_string;\n   else if (prefix_sections_string)\n     prefix = prefix_sections_string;\n@@ -3802,7 +3801,7 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n \n   make_nobits = FALSE;\n \n-  p = find_section_list (bfd_section_name (ibfd, isection), FALSE,\n+  p = find_section_list (bfd_section_name (isection), FALSE,\n \t\t\t SECTION_CONTEXT_SET_FLAGS);\n   if (p != NULL)\n     flags = p->flags | (flags & (SEC_HAS_CONTENTS | SEC_RELOC));\n@@ -3834,20 +3833,20 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n   if (make_nobits)\n     elf_section_type (osection) = SHT_NOBITS;\n \n-  size = bfd_section_size (ibfd, isection);\n+  size = bfd_section_size (isection);\n   size = bfd_convert_section_size (ibfd, isection, obfd, size);\n   if (copy_byte >= 0)\n     size = (size + interleave - 1) / interleave * copy_width;\n   else if (extract_symbol)\n     size = 0;\n-  if (! bfd_set_section_size (obfd, osection, size))\n+  if (!bfd_set_section_size (osection, size))\n     {\n       err = _(\"failed to set size\");\n       goto loser;\n     }\n \n-  vma = bfd_section_vma (ibfd, isection);\n-  p = find_section_list (bfd_section_name (ibfd, isection), FALSE,\n+  vma = bfd_section_vma (isection);\n+  p = find_section_list (bfd_section_name (isection), FALSE,\n \t\t\t SECTION_CONTEXT_ALTER_VMA | SECTION_CONTEXT_SET_VMA);\n   if (p != NULL)\n     {\n@@ -3859,14 +3858,14 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n   else\n     vma += change_section_address;\n \n-  if (! bfd_set_section_vma (obfd, osection, vma))\n+  if (!bfd_set_section_vma (osection, vma))\n     {\n       err = _(\"failed to set vma\");\n       goto loser;\n     }\n \n   lma = isection->lma;\n-  p = find_section_list (bfd_section_name (ibfd, isection), FALSE,\n+  p = find_section_list (bfd_section_name (isection), FALSE,\n \t\t\t SECTION_CONTEXT_ALTER_LMA | SECTION_CONTEXT_SET_LMA);\n   if (p != NULL)\n     {\n@@ -3880,18 +3879,16 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n \n   osection->lma = lma;\n \n-  p = find_section_list (bfd_section_name (ibfd, isection), FALSE,\n+  p = find_section_list (bfd_section_name (isection), FALSE,\n \t\t\t SECTION_CONTEXT_SET_ALIGNMENT);\n   if (p != NULL)\n     alignment = p->alignment;\n   else\n-    alignment = bfd_section_alignment (ibfd, isection);\n+    alignment = bfd_section_alignment (isection);\n   \n   /* FIXME: This is probably not enough.  If we change the LMA we\n      may have to recompute the header for the file as well.  */\n-  if (!bfd_set_section_alignment (obfd,\n-\t\t\t\t  osection,\n-\t\t\t\t  alignment))\n+  if (!bfd_set_section_alignment (osection, alignment))\n     {\n       err = _(\"failed to set alignment\");\n       goto loser;\n@@ -3965,12 +3962,12 @@ skip_section (bfd *ibfd, sec_ptr isection, bfd_boolean skip_copy)\n   if (skip_copy && is_merged_note_section (ibfd, isection))\n     return TRUE;\n \n-  flags = bfd_get_section_flags (ibfd, isection);\n+  flags = bfd_section_flags (isection);\n   if ((flags & SEC_GROUP) != 0)\n     return TRUE;\n \n   osection = isection->output_section;\n-  size = bfd_get_section_size (isection);\n+  size = bfd_section_size (isection);\n \n   if (size == 0 || osection == 0)\n     return TRUE;\n@@ -3995,7 +3992,7 @@ handle_remove_relocations_option (const char *section_pattern)\n static bfd_boolean\n discard_relocations (bfd *ibfd ATTRIBUTE_UNUSED, asection *isection)\n {\n-  return (find_section_list (bfd_section_name (ibfd, isection), FALSE,\n+  return (find_section_list (bfd_section_name (isection), FALSE,\n \t\t\t     SECTION_CONTEXT_REMOVE_RELOCS) != NULL);\n }\n \n@@ -4140,10 +4137,10 @@ copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n      ELF classes of input and output aren't the same.  We can't use\n      the output section size since --interleave will shrink the output\n      section.   Size will be updated if the section is converted.   */\n-  size = bfd_get_section_size (isection);\n+  size = bfd_section_size (isection);\n \n-  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS\n-      && bfd_get_section_flags (obfd, osection) & SEC_HAS_CONTENTS)\n+  if (bfd_section_flags (isection) & SEC_HAS_CONTENTS\n+      && bfd_section_flags (osection) & SEC_HAS_CONTENTS)\n     {\n       bfd_byte *memhunk = NULL;\n \n@@ -4180,7 +4177,7 @@ copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n \t  else\n \t    /* User must pad the section up in order to do this.  */\n \t    fatal (_(\"cannot reverse bytes: length of section %s must be evenly divisible by %d\"),\n-\t\t   bfd_section_name (ibfd, isection), reverse_bytes);\n+\t\t   bfd_section_name (isection), reverse_bytes);\n \t}\n \n       if (copy_byte >= 0)\n@@ -4223,7 +4220,7 @@ copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n \t}\n       free (memhunk);\n     }\n-  else if ((p = find_section_list (bfd_get_section_name (ibfd, isection),\n+  else if ((p = find_section_list (bfd_section_name (isection),\n \t\t\t\t   FALSE, SECTION_CONTEXT_SET_FLAGS)) != NULL\n \t   && (p->flags & SEC_HAS_CONTENTS) != 0)\n     {\n@@ -4294,9 +4291,9 @@ compare_section_lma (const void *arg1, const void *arg2)\n     return -1;\n \n   /* Sort sections with the same LMA by size.  */\n-  if (bfd_get_section_size (*sec1) > bfd_get_section_size (*sec2))\n+  if (bfd_section_size (*sec1) > bfd_section_size (*sec2))\n     return 1;\n-  else if (bfd_get_section_size (*sec1) < bfd_get_section_size (*sec2))\n+  else if (bfd_section_size (*sec1) < bfd_section_size (*sec2))\n     return -1;\n \n   return 0;\n@@ -4378,10 +4375,10 @@ write_debugging_info (bfd *obfd, void *dhandle,\n       stabstrsec = bfd_make_section_with_flags (obfd, \".stabstr\", flags);\n       if (stabsec == NULL\n \t  || stabstrsec == NULL\n-\t  || ! bfd_set_section_size (obfd, stabsec, symsize)\n-\t  || ! bfd_set_section_size (obfd, stabstrsec, stringsize)\n-\t  || ! bfd_set_section_alignment (obfd, stabsec, 2)\n-\t  || ! bfd_set_section_alignment (obfd, stabstrsec, 0))\n+\t  || !bfd_set_section_size (stabsec, symsize)\n+\t  || !bfd_set_section_size (stabstrsec, stringsize)\n+\t  || !bfd_set_section_alignment (stabsec, 2)\n+\t  || !bfd_set_section_alignment (stabstrsec, 0))\n \t{\n \t  bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t\t_(\"can't create debugging section\"));"
    },
    {
      "sha": "96727a0f51e0ce04d35f7b7419424e0e551f30e3",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 22,
      "deletions": 21,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -545,13 +545,13 @@ dump_section_header (bfd *abfd, asection *section, void *data)\n     return;\n \n   printf (\"%3d %-*s %08lx  \", section->index, longest_section_name,\n-\t  sanitize_string (bfd_get_section_name (abfd, section)),\n-\t  (unsigned long) bfd_section_size (abfd, section) / opb);\n-  bfd_printf_vma (abfd, bfd_get_section_vma (abfd, section));\n+\t  sanitize_string (bfd_section_name (section)),\n+\t  (unsigned long) bfd_section_size (section) / opb);\n+  bfd_printf_vma (abfd, bfd_section_vma (section));\n   printf (\"  \");\n   bfd_printf_vma (abfd, section->lma);\n   printf (\"  %08lx  2**%u\", (unsigned long) section->filepos,\n-\t  bfd_get_section_alignment (abfd, section));\n+\t  bfd_section_alignment (section));\n   if (! wide_output)\n     printf (\"\\n                \");\n   printf (\"  \");\n@@ -631,7 +631,8 @@ dump_section_header (bfd *abfd, asection *section, void *data)\n    DATA which contains the string length of the longest section name.  */\n \n static void\n-find_longest_section_name (bfd *abfd, asection *section, void *data)\n+find_longest_section_name (bfd *abfd ATTRIBUTE_UNUSED,\n+\t\t\t   asection *section, void *data)\n {\n   int *longest_so_far = (int *) data;\n   const char *name;\n@@ -645,7 +646,7 @@ find_longest_section_name (bfd *abfd, asection *section, void *data)\n   if (! process_section_p (section))\n     return;\n \n-  name = bfd_get_section_name (abfd, section);\n+  name = bfd_section_name (section);\n   len = (int) strlen (name);\n   if (len > *longest_so_far)\n     *longest_so_far = len;\n@@ -1034,8 +1035,8 @@ sym_ok (bfd_boolean               want_section,\n \t debug info file, whilst the section we want is in a normal file.\n \t So the section pointers will be different, but the section names\n \t will be the same.  */\n-      if (strcmp (bfd_section_name (abfd, sorted_syms[place]->section),\n-\t\t  bfd_section_name (abfd, sec)) != 0)\n+      if (strcmp (bfd_section_name (sorted_syms[place]->section),\n+\t\t  bfd_section_name (sec)) != 0)\n \treturn FALSE;\n     }\n \n@@ -1141,9 +1142,9 @@ find_symbol_for_address (bfd_vma vma,\n      Also give the target a chance to reject symbols.  */\n   want_section = (aux->require_sec\n \t\t  || ((abfd->flags & HAS_RELOC) != 0\n-\t\t      && vma >= bfd_get_section_vma (abfd, sec)\n-\t\t      && vma < (bfd_get_section_vma (abfd, sec)\n-\t\t\t\t+ bfd_section_size (abfd, sec) / opb)));\n+\t\t      && vma >= bfd_section_vma (sec)\n+\t\t      && vma < (bfd_section_vma (sec)\n+\t\t\t\t+ bfd_section_size (sec) / opb)));\n   \n   if (! sym_ok (want_section, abfd, thisplace, sec, inf))\n     {\n@@ -1267,8 +1268,8 @@ objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,\n       bfd_vma secaddr;\n \n       (*inf->fprintf_func) (inf->stream, \" <%s\",\n-\t\t\t    sanitize_string (bfd_get_section_name (abfd, sec)));\n-      secaddr = bfd_get_section_vma (abfd, sec);\n+\t\t\t    sanitize_string (bfd_section_name (sec)));\n+      secaddr = bfd_section_vma (sec);\n       if (vma < secaddr)\n \t{\n \t  (*inf->fprintf_func) (inf->stream, \"-0x\");\n@@ -2235,7 +2236,7 @@ disassemble_bytes (struct disassemble_info * inf,\n \t\t      asection *sym_sec;\n \n \t\t      sym_sec = bfd_asymbol_section (*q->sym_ptr_ptr);\n-\t\t      sym_name = bfd_get_section_name (aux->abfd, sym_sec);\n+\t\t      sym_name = bfd_section_name (sym_sec);\n \t\t      if (sym_name == NULL || *sym_name == '\\0')\n \t\t\tsym_name = \"*unknown*\";\n \t\t      printf (\"%s\", sanitize_string (sym_name));\n@@ -2308,7 +2309,7 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n   if (! process_section_p (section))\n     return;\n \n-  datasize = bfd_get_section_size (section);\n+  datasize = bfd_section_size (section);\n   if (datasize == 0)\n     return;\n \n@@ -2538,7 +2539,7 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n       else\n \t{\n #define is_valid_next_sym(SYM) \\\n-  (strcmp (bfd_section_name (abfd, (SYM)->section), bfd_section_name (abfd, section)) == 0 \\\n+  (strcmp (bfd_section_name ((SYM)->section), bfd_section_name (section)) == 0 \\\n    && (bfd_asymbol_value (SYM) > bfd_asymbol_value (sym)) \\\n    && pinfo->symbol_is_valid (SYM, pinfo))\n \n@@ -2750,9 +2751,9 @@ load_specific_debug_section (enum dwarf_section_display_enum debug,\n   section->filename = bfd_get_filename (abfd);\n   section->reloc_info = NULL;\n   section->num_relocs = 0;\n-  section->address = bfd_get_section_vma (abfd, sec);\n+  section->address = bfd_section_vma (sec);\n   section->user_data = sec;\n-  section->size = bfd_get_section_size (sec);\n+  section->size = bfd_section_size (sec);\n   /* PR 24360: On 32-bit hosts sizeof (size_t) < sizeof (bfd_size_type). */\n   alloced = amt = section->size + 1;\n   if (alloced != amt || alloced == 0)\n@@ -2925,7 +2926,7 @@ static void\n dump_dwarf_section (bfd *abfd, asection *section,\n \t\t    void *arg ATTRIBUTE_UNUSED)\n {\n-  const char *name = bfd_get_section_name (abfd, section);\n+  const char *name = bfd_section_name (section);\n   const char *match;\n   int i;\n \n@@ -3050,7 +3051,7 @@ read_section_stabs (bfd *abfd, const char *sect_name, bfd_size_type *size_ptr,\n       return NULL;\n     }\n \n-  *size_ptr = bfd_section_size (abfd, stabsect);\n+  *size_ptr = bfd_section_size (stabsect);\n   if (entsize_ptr)\n     *entsize_ptr = stabsect->entsize;\n \n@@ -3459,7 +3460,7 @@ dump_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED)\n   if (! process_section_p (section))\n     return;\n \n-  if ((datasize = bfd_section_size (abfd, section)) == 0)\n+  if ((datasize = bfd_section_size (section)) == 0)\n     return;\n \n   /* Compute the address range to display.  */"
    },
    {
      "sha": "4a607d20ee7f981aa50256417f8bdd80debda76a",
      "filename": "binutils/od-elf32_avr.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/od-elf32_avr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/od-elf32_avr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/od-elf32_avr.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -85,7 +85,7 @@ elf32_avr_get_note_section_contents (bfd *abfd, bfd_size_type *size)\n   if ((section = bfd_get_section_by_name (abfd, \".note.gnu.avr.deviceinfo\")) == NULL)\n     return NULL;\n \n-  *size = bfd_get_section_size (section);\n+  *size = bfd_section_size (section);\n   char *contents = (char *) xmalloc (*size);\n   bfd_get_section_contents (abfd, section, contents, 0, *size);\n \n@@ -162,17 +162,17 @@ elf32_avr_get_memory_usage (bfd *abfd,\n   asection *section;\n \n   if ((section = bfd_get_section_by_name (abfd, \".data\")) != NULL)\n-    avr_datasize = bfd_section_size (abfd, section);\n+    avr_datasize = bfd_section_size (section);\n   if ((section = bfd_get_section_by_name (abfd, \".text\")) != NULL)\n-    avr_textsize = bfd_section_size (abfd, section);\n+    avr_textsize = bfd_section_size (section);\n   if ((section = bfd_get_section_by_name (abfd, \".bss\")) != NULL)\n-    avr_bsssize = bfd_section_size (abfd, section);\n+    avr_bsssize = bfd_section_size (section);\n   if ((section = bfd_get_section_by_name (abfd, \".bootloader\")) != NULL)\n-    bootloadersize = bfd_section_size (abfd, section);\n+    bootloadersize = bfd_section_size (section);\n   if ((section = bfd_get_section_by_name (abfd, \".noinit\")) != NULL)\n-    noinitsize = bfd_section_size (abfd, section);\n+    noinitsize = bfd_section_size (section);\n   if ((section = bfd_get_section_by_name (abfd, \".eeprom\")) != NULL)\n-    eepromsize = bfd_section_size (abfd, section);\n+    eepromsize = bfd_section_size (section);\n \n   *text_usage = avr_textsize + avr_datasize + bootloadersize;\n   *data_usage = avr_datasize + avr_bsssize + noinitsize;\n@@ -255,12 +255,12 @@ elf32_avr_dump_avr_prop (bfd *abfd)\n   for (i = 0; i < r_list->record_count; ++i)\n     {\n       printf (\"   %d %s @ %s + %#08lx (%#08lx)\\n\",\n-              i,\n-              avr_elf32_property_record_name (&r_list->records [i]),\n-              r_list->records [i].section->name,\n-              r_list->records [i].offset,\n-              (bfd_get_section_vma (abfd, r_list->records [i].section)\n-               + r_list->records [i].offset));\n+\t      i,\n+\t      avr_elf32_property_record_name (&r_list->records [i]),\n+\t      r_list->records [i].section->name,\n+\t      r_list->records [i].offset,\n+\t      (bfd_section_vma (r_list->records [i].section)\n+\t       + r_list->records [i].offset));\n       switch (r_list->records [i].type)\n         {\n         case RECORD_ORG:"
    },
    {
      "sha": "ada86b52360e2288cea789049d76a6cb43736d76",
      "filename": "binutils/od-macho.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/od-macho.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/od-macho.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/od-macho.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2259,7 +2259,7 @@ dump_section_content (bfd *abfd,\n \t\tasection *bfdsec = sec->bfdsection;\n \t\tunsigned char *content;\n \n-\t\tsize = bfd_get_section_size (bfdsec);\n+\t\tsize = bfd_section_size (bfdsec);\n \t\tcontent = (unsigned char *) xmalloc (size);\n \t\tbfd_get_section_contents (abfd, bfdsec, content, 0, size);\n "
    },
    {
      "sha": "e5566bc9a73c7a97b790d4c646391ec862e1e295",
      "filename": "binutils/od-xcoff.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/od-xcoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/od-xcoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/od-xcoff.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -763,7 +763,7 @@ dump_xcoff32_symbols (bfd *abfd, struct xcoff_dump *data)\n     {\n       bfd_size_type size;\n \n-      size = bfd_get_section_size (debugsec);\n+      size = bfd_section_size (debugsec);\n       debug = (char *) xmalloc (size);\n       bfd_get_section_contents (abfd, debugsec, debug, 0, size);\n     }\n@@ -1051,7 +1051,7 @@ dump_xcoff32_loader (bfd *abfd)\n       printf (_(\"no .loader section in file\\n\"));\n       return;\n     }\n-  size = bfd_get_section_size (loader);\n+  size = bfd_section_size (loader);\n   if (size < sizeof (*lhdr))\n     {\n       printf (_(\"section .loader is too short\\n\"));\n@@ -1198,7 +1198,7 @@ dump_xcoff32_except (bfd *abfd, struct xcoff_dump *data)\n       printf (_(\"no .except section in file\\n\"));\n       return;\n     }\n-  size = bfd_get_section_size (sec);\n+  size = bfd_section_size (sec);\n   excp_data = (bfd_byte *) xmalloc (size);\n   bfd_get_section_contents (abfd, sec, excp_data, 0, size);\n   exceptab = (struct external_exceptab *)excp_data;\n@@ -1241,7 +1241,7 @@ dump_xcoff32_typchk (bfd *abfd)\n       printf (_(\"no .typchk section in file\\n\"));\n       return;\n     }\n-  size = bfd_get_section_size (sec);\n+  size = bfd_section_size (sec);\n   data = (bfd_byte *) xmalloc (size);\n   bfd_get_section_contents (abfd, sec, data, 0, size);\n \n@@ -1449,9 +1449,9 @@ dump_xcoff32_traceback (bfd *abfd, struct xcoff_dump *data)\n   text_sec = bfd_get_section_by_name (abfd, \".text\");\n   if (text_sec == NULL)\n     return;\n-  text_vma = bfd_get_section_vma (abfd, text_sec);\n+  text_vma = bfd_section_vma (text_sec);\n \n-  text_size = bfd_get_section_size (text_sec);\n+  text_size = bfd_section_size (text_sec);\n   text = (char *) xmalloc (text_size);\n   bfd_get_section_contents (abfd, text_sec, text, 0, text_size);\n "
    },
    {
      "sha": "40cf54b8fe948eae493a06fba3188c9a07fed310",
      "filename": "binutils/prdbg.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/prdbg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/prdbg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/prdbg.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1930,14 +1930,14 @@ find_address_in_section (bfd *abfd, asection *section, void *data)\n   if (found)\n     return;\n \n-  if ((bfd_get_section_flags (abfd, section) & SEC_ALLOC) == 0)\n+  if ((bfd_section_flags (section) & SEC_ALLOC) == 0)\n     return;\n \n-  vma = bfd_get_section_vma (abfd, section);\n+  vma = bfd_section_vma (section);\n   if (pc < vma)\n     return;\n \n-  size = bfd_get_section_size (section);\n+  size = bfd_section_size (section);\n   if (pc >= vma + size)\n     return;\n "
    },
    {
      "sha": "006f13b3aa015d96e2c25c89145bfe6313b806f1",
      "filename": "binutils/rdcoff.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/rdcoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/rdcoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/rdcoff.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -816,7 +816,7 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \t\t  else\n \t\t    base = auxent.x_sym.x_misc.x_lnsz.x_lnno - 1;\n \n-\t\t  addr = bfd_get_section_vma (abfd, bfd_asymbol_section (sym));\n+\t\t  addr = bfd_section_vma (bfd_asymbol_section (sym));\n \n \t\t  ++linenos;\n "
    },
    {
      "sha": "eb8ffcbc0257c4cad7e87adcbbf9c0ced1cba621",
      "filename": "binutils/rddbg.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/rddbg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/rddbg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/rddbg.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -121,7 +121,7 @@ read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n \t  bfd_byte *stab;\n \t  bfd_size_type stroff, next_stroff;\n \n-\t  stabsize = bfd_section_size (abfd, sec);\n+\t  stabsize = bfd_section_size (sec);\n \t  stabs = (bfd_byte *) xmalloc (stabsize);\n \t  if (! bfd_get_section_contents (abfd, sec, stabs, 0, stabsize))\n \t    {\n@@ -133,7 +133,7 @@ read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n \t      return FALSE;\n \t    }\n \n-\t  strsize = bfd_section_size (abfd, strsec);\n+\t  strsize = bfd_section_size (strsec);\n \t  strings = (bfd_byte *) xmalloc (strsize + 1);\n \t  if (! bfd_get_section_contents (abfd, strsec, strings, 0, strsize))\n \t    {"
    },
    {
      "sha": "9a0fcda2ac6ba4364350999d433bd70a4e24a61c",
      "filename": "binutils/rescoff.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/rescoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/rescoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/rescoff.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -141,7 +141,7 @@ read_coff_rsrc (const char *filename, const char *target)\n     }\n \n   set_windres_bfd (&wrbfd, abfd, sec, WR_KIND_BFD);\n-  size = bfd_section_size (abfd, sec);\n+  size = bfd_section_size (sec);\n   /* PR 17512: file: 1b25ba5d\n      The call to get_file_size here may be expensive\n      but there is no other way to determine if the section size\n@@ -155,8 +155,8 @@ read_coff_rsrc (const char *filename, const char *target)\n   flaginfo.filename = filename;\n   flaginfo.data = data;\n   flaginfo.data_end = data + size;\n-  flaginfo.secaddr = (bfd_get_section_vma (abfd, sec)\n-\t\t   - pe_data (abfd)->pe_opthdr.ImageBase);\n+  flaginfo.secaddr = (bfd_section_vma (sec)\n+\t\t      - pe_data (abfd)->pe_opthdr.ImageBase);\n \n   /* Now just read in the top level resource directory.  Note that we\n      don't free data, since we create resource entries that point into\n@@ -547,7 +547,7 @@ write_coff_file (const char *filename, const char *target,\n \t    + cwi.dataentsize\n \t    + cwi.resources.length);\n \n-  if (! bfd_set_section_size (abfd, sec, length))\n+  if (!bfd_set_section_size (sec, length))\n     bfd_fatal (\"bfd_set_section_size\");\n \n   bfd_set_reloc (abfd, sec, cwi.relocs, cwi.reloc_count);"
    },
    {
      "sha": "161ea354fec9cea0c80d1b8f21e42c642431f9c2",
      "filename": "binutils/resres.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/resres.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/resres.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/resres.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -142,7 +142,7 @@ write_res_file (const char *fn,const rc_res_directory *resdir)\n   sec_length = write_res_directory ((windres_bfd *) NULL, 0x20UL, resdir,\n \t\t\t\t    (const rc_res_id *) NULL,\n \t\t\t\t    (const rc_res_id *) NULL, &language, 1);\n-  if (! bfd_set_section_size (abfd, sec, (sec_length + 3) & ~3))\n+  if (!bfd_set_section_size (sec, (sec_length + 3) & ~3))\n     bfd_fatal (\"bfd_set_section_size\");\n   if ((sec_length & 3) != 0)\n     set_windres_bfd_content (&wrbfd, sign, sec_length, 4-(sec_length & 3));"
    },
    {
      "sha": "b147221e916f03e6504b097a9a54ce934c47548f",
      "filename": "binutils/size.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/size.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/size.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/size.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -478,11 +478,11 @@ berkeley_or_gnu_sum (bfd *abfd ATTRIBUTE_UNUSED, sec_ptr sec,\n   flagword flags;\n   bfd_size_type size;\n \n-  flags = bfd_get_section_flags (abfd, sec);\n+  flags = bfd_section_flags (sec);\n   if ((flags & SEC_ALLOC) == 0)\n     return;\n \n-  size = bfd_get_section_size (sec);\n+  size = bfd_section_size (sec);\n   if ((flags & SEC_CODE) != 0\n       || (selected_output_format == FORMAT_BERKLEY\n \t  && (flags & SEC_READONLY) != 0))\n@@ -557,21 +557,21 @@ static void\n sysv_internal_sizer (bfd *file ATTRIBUTE_UNUSED, sec_ptr sec,\n \t\t     void *ignore ATTRIBUTE_UNUSED)\n {\n-  bfd_size_type size = bfd_section_size (file, sec);\n+  bfd_size_type size = bfd_section_size (sec);\n \n   if (   ! bfd_is_abs_section (sec)\n       && ! bfd_is_com_section (sec)\n       && ! bfd_is_und_section (sec))\n     {\n-      int namelen = strlen (bfd_section_name (file, sec));\n+      int namelen = strlen (bfd_section_name (sec));\n \n       if (namelen > svi_namelen)\n \tsvi_namelen = namelen;\n \n       svi_total += size;\n \n-      if (bfd_section_vma (file, sec) > svi_maxvma)\n-\tsvi_maxvma = bfd_section_vma (file, sec);\n+      if (bfd_section_vma (sec) > svi_maxvma)\n+\tsvi_maxvma = bfd_section_vma (sec);\n     }\n }\n \n@@ -589,17 +589,17 @@ static void\n sysv_internal_printer (bfd *file ATTRIBUTE_UNUSED, sec_ptr sec,\n \t\t       void *ignore ATTRIBUTE_UNUSED)\n {\n-  bfd_size_type size = bfd_section_size (file, sec);\n+  bfd_size_type size = bfd_section_size (sec);\n \n   if (   ! bfd_is_abs_section (sec)\n       && ! bfd_is_com_section (sec)\n       && ! bfd_is_und_section (sec))\n     {\n       svi_total += size;\n \n-      sysv_one_line (bfd_section_name (file, sec),\n+      sysv_one_line (bfd_section_name (sec),\n \t\t     size,\n-\t\t     bfd_section_vma (file, sec));\n+\t\t     bfd_section_vma (sec));\n     }\n }\n "
    },
    {
      "sha": "a421f642e0be73f99a051e1457fab7df607cb219",
      "filename": "binutils/srconv.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/srconv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/srconv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/srconv.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -419,14 +419,14 @@ wr_ob (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_section *section)\n   unsigned char stuff[200];\n \n   i = 0;\n-  while (i < bfd_get_section_size (section->bfd_section))\n+  while (i < bfd_section_size (section->bfd_section))\n     {\n       struct IT_ob ob;\n       int todo = 200;\t\t/* Copy in 200 byte lumps.  */\n \n       ob.spare = 0;\n-      if (i + todo > bfd_get_section_size (section->bfd_section))\n-\ttodo = bfd_get_section_size (section->bfd_section) - i;\n+      if (i + todo > bfd_section_size (section->bfd_section))\n+\ttodo = bfd_section_size (section->bfd_section) - i;\n \n       if (first)\n \t{"
    },
    {
      "sha": "8150c1181df3250ad2dc5de4f38cdbfad1b7fa71",
      "filename": "binutils/strings.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/strings.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/strings.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/strings.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -332,7 +332,7 @@ strings_a_section (bfd *abfd, asection *sect, const char *filename,\n   if ((sect->flags & DATA_FLAGS) != DATA_FLAGS)\n     return;\n \n-  sectsize = bfd_get_section_size (sect);\n+  sectsize = bfd_section_size (sect);\n   if (sectsize == 0)\n     return;\n "
    },
    {
      "sha": "10bd6144c698be69fe4e6d1009c3b3add7088b9c",
      "filename": "binutils/windmc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/windmc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/binutils/windmc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/windmc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -698,7 +698,7 @@ windmc_write_bin (const char *filename, mc_node_lang **nl, int elems)\n       dta_off += mi[i].res_len;\n     }\n   sec_length = (dta_off + 3) & ~3;\n-  if (! bfd_set_section_size (mc_bfd.abfd, mc_bfd.sec, sec_length))\n+  if (!bfd_set_section_size (mc_bfd.sec, sec_length))\n     bfd_fatal (\"bfd_set_section_size\");\n   /* Make sure we write the complete block.  */\n   set_windmc_bfd_content (\"\\0\", sec_length - 1, 1);"
    },
    {
      "sha": "819585d9e317d8f491a9c848b2f14358086629b9",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,31 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* as.c, * as.h, * dw2gencfi.c, * dwarf2dbg.c, * ecoff.c,\n+\t* read.c, * stabs.c, * subsegs.c, * subsegs.h, * write.c,\n+\t* config/obj-coff-seh.c, * config/obj-coff.c, * config/obj-ecoff.c,\n+\t* config/obj-elf.c, * config/obj-macho.c, * config/obj-som.c,\n+\t* config/tc-aarch64.c, * config/tc-alpha.c, * config/tc-arc.c,\n+\t* config/tc-arm.c, * config/tc-avr.c, * config/tc-bfin.c,\n+\t* config/tc-bpf.c, * config/tc-d10v.c, * config/tc-d30v.c,\n+\t* config/tc-epiphany.c, * config/tc-fr30.c, * config/tc-frv.c,\n+\t* config/tc-h8300.c, * config/tc-hppa.c, * config/tc-i386.c,\n+\t* config/tc-ia64.c, * config/tc-ip2k.c, * config/tc-iq2000.c,\n+\t* config/tc-lm32.c, * config/tc-m32c.c, * config/tc-m32r.c,\n+\t* config/tc-m68hc11.c, * config/tc-mep.c, * config/tc-microblaze.c,\n+\t* config/tc-mips.c, * config/tc-mmix.c, * config/tc-mn10200.c,\n+\t* config/tc-mn10300.c, * config/tc-msp430.c, * config/tc-mt.c,\n+\t* config/tc-nds32.c, * config/tc-or1k.c, * config/tc-ppc.c,\n+\t* config/tc-pru.c, * config/tc-rl78.c, * config/tc-rx.c,\n+\t* config/tc-s12z.c, * config/tc-s390.c, * config/tc-score.c,\n+\t* config/tc-score7.c, * config/tc-sh.c, * config/tc-sparc.c,\n+\t* config/tc-spu.c, * config/tc-tic4x.c, * config/tc-tic54x.c,\n+\t* config/tc-tic6x.c, * config/tc-tilegx.c, * config/tc-tilepro.c,\n+\t* config/tc-v850.c, * config/tc-visium.c, * config/tc-wasm32.c,\n+\t* config/tc-xc16x.c, * config/tc-xgate.c, * config/tc-xstormy16.c,\n+\t* config/tc-xtensa.c, * config/tc-z8k.c: Update throughout for\n+\tbfd section macro and function changes.\n+\t* write.c (compress_debug): Use bfd_rename_section.\n+\n 2019-09-18  Alan Modra  <amodra@gmail.com>\n \n \t* symbols.c (S_IS_LOCAL): Update bfd_get_section to"
    },
    {
      "sha": "d53db113e22ea868f69a3da29390813a0f1c52e3",
      "filename": "gas/as.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/as.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/as.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/as.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1147,13 +1147,13 @@ perform_an_assembly_pass (int argc, char ** argv)\n   /* @@ FIXME -- we're setting the RELOC flag so that sections are assumed\n      to have relocs, otherwise we don't find out in time.  */\n   applicable = bfd_applicable_section_flags (stdoutput);\n-  bfd_set_section_flags (stdoutput, text_section,\n+  bfd_set_section_flags (text_section,\n \t\t\t applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n \t\t\t\t       | SEC_CODE | SEC_READONLY));\n-  bfd_set_section_flags (stdoutput, data_section,\n+  bfd_set_section_flags (data_section,\n \t\t\t applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n \t\t\t\t       | SEC_DATA));\n-  bfd_set_section_flags (stdoutput, bss_section, applicable & SEC_ALLOC);\n+  bfd_set_section_flags (bss_section, applicable & SEC_ALLOC);\n   seg_info (bss_section)->bss = 1;\n #endif\n   subseg_new (BFD_ABS_SECTION_NAME, 0);\n@@ -1360,7 +1360,7 @@ main (int argc, char ** argv)\n       segT gnustack;\n \n       gnustack = subseg_new (\".note.GNU-stack\", 0);\n-      bfd_set_section_flags (stdoutput, gnustack,\n+      bfd_set_section_flags (gnustack,\n \t\t\t     SEC_READONLY | (flag_execstack ? SEC_CODE : 0));\n \n     }"
    },
    {
      "sha": "5b604a45342205187bef6d96a6bb1f1f35c5423d",
      "filename": "gas/as.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/as.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/as.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/as.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -226,7 +226,7 @@ COMMON subsegT now_subseg;\n /* Segment our instructions emit to.  */\n COMMON segT now_seg;\n \n-#define segment_name(SEG)\tbfd_get_section_name (stdoutput, SEG)\n+#define segment_name(SEG)\tbfd_section_name (SEG)\n \n extern segT reg_section, expr_section;\n /* Shouldn't these be eliminated someday?  */"
    },
    {
      "sha": "b24e435677b822780aac775ade997517deca867b",
      "filename": "gas/config/obj-coff-seh.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-coff-seh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-coff-seh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-coff-seh.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -48,7 +48,7 @@ get_pxdata_name (segT seg, const char *base_name)\n   const char *name,*dollar, *dot;\n   char *sname;\n \n-  name = bfd_get_section_name (stdoutput, seg);\n+  name = bfd_section_name (seg);\n \n   dollar = strchr (name, '$');\n   dot = strchr (name + 1, '.');\n@@ -95,16 +95,16 @@ make_pxdata_seg (segT cseg, char *name)\n \n   r = subseg_new (name, 0);\n   /* Check if code segment is marked as linked once.  */\n-  flags = bfd_get_section_flags (stdoutput, cseg)\n-    & (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD\n-       | SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE\n-       | SEC_LINK_DUPLICATES_SAME_CONTENTS);\n+  flags = (bfd_section_flags (cseg)\n+\t   & (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD\n+\t      | SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE\n+\t      | SEC_LINK_DUPLICATES_SAME_CONTENTS));\n \n   /* Add standard section flags.  */\n   flags |= SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA;\n \n   /* Apply possibly linked once flags to new generated segment, too.  */\n-  if (!bfd_set_section_flags (stdoutput, r, flags))\n+  if (!bfd_set_section_flags (r, flags))\n     as_bad (_(\"bfd_set_section_flags: %s\"),\n \t    bfd_errmsg (bfd_get_error ()));\n \n@@ -161,8 +161,8 @@ seh_validate_seg (const char *directive)\n   const char *cseg_name, *nseg_name;\n   if (seh_ctx_cur->code_seg == now_seg)\n     return 1;\n-  cseg_name = bfd_get_section_name (stdoutput, seh_ctx_cur->code_seg);\n-  nseg_name = bfd_get_section_name (stdoutput, now_seg);\n+  cseg_name = bfd_section_name (seh_ctx_cur->code_seg);\n+  nseg_name = bfd_section_name (now_seg);\n   as_bad (_(\"%s used in segment '%s' instead of expected '%s'\"),\n   \t  directive, nseg_name, cseg_name);\n   ignore_rest_of_line ();"
    },
    {
      "sha": "d1dd0f0131a9dcf8cc3f7a68a38c4a4ef81abb09",
      "filename": "gas/config/obj-coff.c",
      "status": "modified",
      "additions": 14,
      "deletions": 16,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-coff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-coff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-coff.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -205,13 +205,12 @@ obj_coff_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT s\n       char numbuff[20];\n \n       sec = subseg_new (\".drectve\", 0);\n-      oldflags = bfd_get_section_flags (stdoutput, sec);\n+      oldflags = bfd_section_flags (sec);\n       if (oldflags == SEC_NO_FLAGS)\n \t{\n-\t  if (!bfd_set_section_flags (stdoutput, sec,\n-\t\tTC_COFF_SECTION_DEFAULT_ATTRIBUTES))\n+\t  if (!bfd_set_section_flags (sec, TC_COFF_SECTION_DEFAULT_ATTRIBUTES))\n \t    as_warn (_(\"error setting flags for \\\"%s\\\": %s\"),\n-\t\tbfd_section_name (stdoutput, sec),\n+\t\tbfd_section_name (sec),\n \t\tbfd_errmsg (bfd_get_error ()));\n \t}\n \n@@ -554,7 +553,7 @@ obj_coff_ident (int ignore ATTRIBUTE_UNUSED)\n        that shouldn't be loaded into memory, which requires linker\n        changes...  For now, until proven otherwise, use .rdata.  */\n     sec = subseg_new (\".rdata$zzz\", 0);\n-    bfd_set_section_flags (stdoutput, sec,\n+    bfd_set_section_flags (sec,\n \t\t\t   ((SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA)\n \t\t\t    & bfd_applicable_section_flags (stdoutput)));\n   }\n@@ -774,8 +773,7 @@ obj_coff_endef (int ignore ATTRIBUTE_UNUSED)\n \n   if (S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_EFCN\n       || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_LABEL\n-      || (streq (bfd_get_section_name (stdoutput,\n-\t\t\t\t       S_GET_SEGMENT (def_symbol_in_progress)),\n+      || (streq (bfd_section_name (S_GET_SEGMENT (def_symbol_in_progress)),\n \t\t \"*DEBUG*\")\n \t  && !SF_GET_TAG (def_symbol_in_progress))\n       || S_GET_SEGMENT (def_symbol_in_progress) == absolute_section\n@@ -1480,7 +1478,7 @@ coff_adjust_section_syms (bfd *abfd ATTRIBUTE_UNUSED,\n \tfixp = fixp->fx_next;\n       }\n   }\n-  if (bfd_get_section_size (sec) == 0\n+  if (bfd_section_size (sec) == 0\n       && nrelocs == 0\n       && nlnno == 0\n       && sec != text_section\n@@ -1657,7 +1655,7 @@ obj_coff_section (int ignore ATTRIBUTE_UNUSED)\n   if (alignment >= 0)\n     sec->alignment_power = alignment;\n \n-  oldflags = bfd_get_section_flags (stdoutput, sec);\n+  oldflags = bfd_section_flags (sec);\n   if (oldflags == SEC_NO_FLAGS)\n     {\n       /* Set section flags for a new section just created by subseg_new.\n@@ -1673,9 +1671,9 @@ obj_coff_section (int ignore ATTRIBUTE_UNUSED)\n \tflags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n #endif\n \n-      if (! bfd_set_section_flags (stdoutput, sec, flags))\n+      if (!bfd_set_section_flags (sec, flags))\n \tas_warn (_(\"error setting flags for \\\"%s\\\": %s\"),\n-\t\t bfd_section_name (stdoutput, sec),\n+\t\t bfd_section_name (sec),\n \t\t bfd_errmsg (bfd_get_error ()));\n     }\n   else if (flags != SEC_NO_FLAGS)\n@@ -1713,7 +1711,7 @@ coff_frob_section (segT sec)\n      supposedly because standard COFF has no other way of encoding alignment\n      for sections.  If your COFF flavor has a different way of encoding\n      section alignment, then skip this step, as TICOFF does.  */\n-  bfd_vma size = bfd_get_section_size (sec);\n+  bfd_vma size = bfd_section_size (sec);\n #if !defined(TICOFF)\n   bfd_vma align_power = (bfd_vma) sec->alignment_power + OCTETS_PER_BYTE_POWER;\n   bfd_vma mask = ((bfd_vma) 1 << align_power) - 1;\n@@ -1724,7 +1722,7 @@ coff_frob_section (segT sec)\n       fragS *last;\n \n       new_size = (size + mask) & ~mask;\n-      bfd_set_section_size (stdoutput, sec, new_size);\n+      bfd_set_section_size (sec, new_size);\n \n       /* If the size had to be rounded up, add some padding in\n          the last non-empty frag.  */\n@@ -1751,7 +1749,7 @@ coff_frob_section (segT sec)\n       unsigned char sclass = C_STAT;\n \n #ifdef OBJ_XCOFF\n-      if (bfd_get_section_flags (stdoutput, sec) & SEC_DEBUGGING)\n+      if (bfd_section_flags (sec) & SEC_DEBUGGING)\n         sclass = C_DWARF;\n #endif\n       S_SET_STORAGE_CLASS (secsym, sclass);\n@@ -1772,9 +1770,9 @@ coff_frob_section (segT sec)\n   strsec = sec;\n   sec = subseg_get (STAB_SECTION_NAME, 0);\n   /* size is already rounded up, since other section will be listed first */\n-  size = bfd_get_section_size (strsec);\n+  size = bfd_section_size (strsec);\n \n-  n_entries = bfd_get_section_size (sec) / 12 - 1;\n+  n_entries = bfd_section_size (sec) / 12 - 1;\n \n   /* Find first non-empty frag.  It should be large enough.  */\n   fragp = seg_info (sec)->frchainP->frch_root;"
    },
    {
      "sha": "a5616f388e861ef4680b42c161d7f31b65332af5",
      "filename": "gas/config/obj-ecoff.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-ecoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-ecoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-ecoff.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -90,15 +90,15 @@ ecoff_frob_file_before_fix (void)\n \t  }\n       if (i == n_names)\n \t{\n-\t  bfd_set_section_vma (stdoutput, sec, addr);\n-\t  addr += bfd_section_size (stdoutput, sec);\n+\t  bfd_set_section_vma (sec, addr);\n+\t  addr += bfd_section_size (sec);\n \t}\n     }\n   for (i = 0; i < n_names; i++)\n     if (secs[i])\n       {\n-\tbfd_set_section_vma (stdoutput, secs[i], addr);\n-\taddr += bfd_section_size (stdoutput, secs[i]);\n+\tbfd_set_section_vma (secs[i], addr);\n+\taddr += bfd_section_size (secs[i]);\n       }\n   for (i = n_names - 1; i >= 0; i--)\n     if (secs[i])"
    },
    {
      "sha": "56293584a0aa7065b4228f2b5d1b69e5e73b09c0",
      "filename": "gas/config/obj-elf.c",
      "status": "modified",
      "additions": 12,
      "deletions": 15,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-elf.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -737,7 +737,7 @@ obj_elf_change_section (const char *name,\n       if (type == SHT_NOBITS)\n \tseg_info (sec)->bss = 1;\n \n-      bfd_set_section_flags (stdoutput, sec, flags);\n+      bfd_set_section_flags (sec, flags);\n       if (flags & SEC_MERGE)\n \tsec->entsize = entsize;\n       elf_group_name (sec) = group_name;\n@@ -1859,9 +1859,7 @@ obj_elf_version (int ignore ATTRIBUTE_UNUSED)\n \n       /* Create the .note section.  */\n       note_secp = subseg_new (\".note\", 0);\n-      bfd_set_section_flags (stdoutput,\n-\t\t\t     note_secp,\n-\t\t\t     SEC_HAS_CONTENTS | SEC_READONLY);\n+      bfd_set_section_flags (note_secp, SEC_HAS_CONTENTS | SEC_READONLY);\n       record_alignment (note_secp, 2);\n \n       /* Process the version string.  */\n@@ -2140,9 +2138,8 @@ obj_elf_ident (int ignore ATTRIBUTE_UNUSED)\n     {\n       char *p;\n       comment_section = subseg_new (\".comment\", 0);\n-      bfd_set_section_flags (stdoutput, comment_section,\n-\t\t\t     SEC_READONLY | SEC_HAS_CONTENTS\n-\t\t\t     | SEC_MERGE | SEC_STRINGS);\n+      bfd_set_section_flags (comment_section, (SEC_READONLY | SEC_HAS_CONTENTS\n+\t\t\t\t\t       | SEC_MERGE | SEC_STRINGS));\n       comment_section->entsize = 1;\n #ifdef md_elf_section_change_hook\n       md_elf_section_change_hook ();\n@@ -2170,7 +2167,7 @@ obj_elf_init_stab_section (segT seg)\n \n   /* Force the section to align to a longword boundary.  Without this,\n      UnixWare ar crashes.  */\n-  bfd_set_section_alignment (stdoutput, seg, 2);\n+  bfd_set_section_alignment (seg, 2);\n \n   /* Make space for this first symbol.  */\n   p = frag_more (12);\n@@ -2204,10 +2201,10 @@ adjust_stab_sections (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n   name = concat (sec->name, \"str\", NULL);\n   strsec = bfd_get_section_by_name (abfd, name);\n   if (strsec)\n-    strsz = bfd_section_size (abfd, strsec);\n+    strsz = bfd_section_size (strsec);\n   else\n     strsz = 0;\n-  nsyms = bfd_section_size (abfd, sec) / 12 - 1;\n+  nsyms = bfd_section_size (sec) / 12 - 1;\n \n   p = seg_info (sec)->stabu.p;\n   gas_assert (p != 0);\n@@ -2490,8 +2487,8 @@ elf_adjust_symtab (void)\n       sec_name = \".group\";\n       s = subseg_force_new (sec_name, 0);\n       if (s == NULL\n-\t  || !bfd_set_section_flags (stdoutput, s, flags)\n-\t  || !bfd_set_section_alignment (stdoutput, s, 2))\n+\t  || !bfd_set_section_flags (s, flags)\n+\t  || !bfd_set_section_alignment (s, 2))\n \t{\n \t  as_fatal (_(\"can't create group: %s\"),\n \t\t    bfd_errmsg (bfd_get_error ()));\n@@ -2598,7 +2595,7 @@ elf_frob_file_after_relocs (void)\n \n       group = elf_sec_group (head);\n       subseg_set (group, 0);\n-      bfd_set_section_size (stdoutput, group, size);\n+      bfd_set_section_size (group, size);\n       group->contents = (unsigned char *) frag_more (size);\n       frag_now->fr_fix = frag_now_fix_octets ();\n       frag_wane (frag_now);\n@@ -2656,8 +2653,8 @@ elf_frob_file_after_relocs (void)\n \t to force the ELF backend to allocate a file position, and then\n \t write out the data.  FIXME: Is this really the best way to do\n \t this?  */\n-      bfd_set_section_size\n-\t(stdoutput, sec, bfd_ecoff_debug_size (stdoutput, &debug, debug_swap));\n+      bfd_set_section_size (sec, bfd_ecoff_debug_size (stdoutput, &debug,\n+\t\t\t\t\t\t       debug_swap));\n \n       /* Pass BUF to bfd_set_section_contents because this will\n \t eventually become a call to fwrite, and ISO C prohibits"
    },
    {
      "sha": "07c7831945e24e9fbc3f4c946e8f74174c58a01c",
      "filename": "gas/config/obj-macho.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-macho.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-macho.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-macho.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -227,7 +227,7 @@ obj_mach_o_make_or_get_sect (char * segname, char * sectname,\n   /* Sub-segments don't exists as is on Mach-O.  */\n   sec = subseg_new (name, 0);\n \n-  oldflags = bfd_get_section_flags (stdoutput, sec);\n+  oldflags = bfd_section_flags (sec);\n   msect = bfd_mach_o_get_mach_o_section (sec);\n \n   if (oldflags == SEC_NO_FLAGS)\n@@ -245,9 +245,9 @@ obj_mach_o_make_or_get_sect (char * segname, char * sectname,\n \tflags |= SEC_DEBUGGING;\n \n       /* New, so just use the defaults or what's specified.  */\n-      if (! bfd_set_section_flags (stdoutput, sec, flags))\n+      if (!bfd_set_section_flags (sec, flags))\n \tas_warn (_(\"failed to set flags for \\\"%s\\\": %s\"),\n-\t\t bfd_section_name (stdoutput, sec),\n+\t\t bfd_section_name (sec),\n \t\t bfd_errmsg (bfd_get_error ()));\n \n       strncpy (msect->segname, segname, BFD_MACH_O_SEGNAME_SIZE);\n@@ -1697,7 +1697,7 @@ static void\n obj_mach_o_set_section_vma (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *v_p)\n {\n   bfd_mach_o_section *ms = bfd_mach_o_get_mach_o_section (sec);\n-  unsigned bfd_align = bfd_get_section_alignment (abfd, sec);\n+  unsigned bfd_align = bfd_section_alignment (sec);\n   obj_mach_o_set_vma_data *p = (struct obj_mach_o_set_vma_data *)v_p;\n   unsigned sectype = (ms->flags & BFD_MACH_O_SECTION_TYPE_MASK);\n   unsigned zf;\n@@ -1719,16 +1719,16 @@ obj_mach_o_set_section_vma (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *v_p\n \n   /* We know the section size now - so make a vma for the section just\n      based on order.  */\n-  ms->size = bfd_get_section_size (sec);\n+  ms->size = bfd_section_size (sec);\n \n   /* Make sure that the align agrees, and set to the largest value chosen.  */\n   ms->align = ms->align > bfd_align ? ms->align : bfd_align;\n-  bfd_set_section_alignment (abfd, sec, ms->align);\n+  bfd_set_section_alignment (sec, ms->align);\n \n   p->vma += (1 << ms->align) - 1;\n   p->vma &= ~((1 << ms->align) - 1);\n   ms->addr = p->vma;\n-  bfd_set_section_vma (abfd, sec, p->vma);\n+  bfd_set_section_vma (sec, p->vma);\n   p->vma += ms->size;\n }\n \n@@ -1752,7 +1752,7 @@ static void\n obj_mach_o_set_indirect_symbols (bfd *abfd, asection *sec,\n \t\t\t\t void *xxx ATTRIBUTE_UNUSED)\n {\n-  bfd_vma sect_size = bfd_section_size (abfd, sec);\n+  bfd_vma sect_size = bfd_section_size (sec);\n   bfd_mach_o_section *ms = bfd_mach_o_get_mach_o_section (sec);\n   unsigned lazy = 0;\n "
    },
    {
      "sha": "20213b8b327c03fcbecb6be46f02e7c3b6223819",
      "filename": "gas/config/obj-som.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-som.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/obj-som.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-som.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -224,14 +224,14 @@ obj_som_init_stab_section (segT seg)\n      of the various stabs spaces/subspaces need to be \"small\".  We\n      reserve range 72/73 which appear to work well.  */\n   obj_set_section_attributes (space, 1, 1, 72, 2);\n-  bfd_set_section_alignment (stdoutput, space, 2);\n+  bfd_set_section_alignment (space, 2);\n \n   /* Set the containing space for both stab sections to be $GDB_DEBUG$\n      (just created above).  Also set some attributes which BFD does\n      not understand.  In particular, access bits, sort keys, and load\n      quadrant.  */\n   obj_set_subsection_attributes (seg, space, 0x1f, 73, 0, 0, 0, 0);\n-  bfd_set_section_alignment (stdoutput, seg, 2);\n+  bfd_set_section_alignment (seg, 2);\n \n   /* Make some space for the first special stab entry and zero the memory.\n      It contains information about the length of this file's\n@@ -254,7 +254,7 @@ obj_som_init_stab_section (segT seg)\n      quadrant.  */\n   seg = bfd_get_section_by_name (stdoutput, \"$GDB_STRINGS$\");\n   obj_set_subsection_attributes (seg, space, 0x1f, 72, 0, 0, 0, 0);\n-  bfd_set_section_alignment (stdoutput, seg, 2);\n+  bfd_set_section_alignment (seg, 2);\n \n   subseg_set (saved_seg, saved_subseg);\n }\n@@ -273,10 +273,10 @@ adjust_stab_sections (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n \n   strsec = bfd_get_section_by_name (abfd, \"$GDB_STRINGS$\");\n   if (strsec)\n-    strsz = bfd_section_size (abfd, strsec);\n+    strsz = bfd_section_size (strsec);\n   else\n     strsz = 0;\n-  nsyms = bfd_section_size (abfd, sec) / 12 - 1;\n+  nsyms = bfd_section_size (sec) / 12 - 1;\n \n   p = seg_info (sec)->stabu.p;\n   gas_assert (p != 0);"
    },
    {
      "sha": "522efebfe42ed797e510b4694c2c51827f55728e",
      "filename": "gas/config/tc-aarch64.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-aarch64.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -7363,7 +7363,7 @@ aarch64_init_frag (fragS * fragP, int max_chars)\n \n   /* PR 21809: Do not set a mapping state for debug sections\n      - it just confuses other tools.  */\n-  if (bfd_get_section_flags (NULL, now_seg) & SEC_DEBUGGING)\n+  if (bfd_section_flags (now_seg) & SEC_DEBUGGING)\n     return;\n \n   switch (fragP->fr_type)"
    },
    {
      "sha": "70ceba02c163fbccb0fa6c03e4a4d434fbf39ec3",
      "filename": "gas/config/tc-alpha.c",
      "status": "modified",
      "additions": 9,
      "deletions": 10,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-alpha.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1205,10 +1205,9 @@ create_literal_section (const char *name,\n \n   *secp = new_sec = subseg_new (name, 0);\n   subseg_set (current_section, current_subsec);\n-  bfd_set_section_alignment (stdoutput, new_sec, 4);\n-  bfd_set_section_flags (stdoutput, new_sec,\n-\t\t\t SEC_RELOC | SEC_ALLOC | SEC_LOAD | SEC_READONLY\n-\t\t\t | SEC_DATA);\n+  bfd_set_section_alignment (new_sec, 4);\n+  bfd_set_section_flags (new_sec, (SEC_RELOC | SEC_ALLOC | SEC_LOAD\n+\t\t\t\t   | SEC_READONLY | SEC_DATA));\n \n   S_CLEAR_EXTERNAL (*symp = section_symbol (new_sec));\n }\n@@ -3985,8 +3984,8 @@ s_alpha_stab (int n)\n   if (alpha_flag_mdebug < 0)\n     {\n       segT sec = subseg_new (\".mdebug\", 0);\n-      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);\n-      bfd_set_section_alignment (stdoutput, sec, 3);\n+      bfd_set_section_flags (sec, SEC_HAS_CONTENTS | SEC_READONLY);\n+      bfd_set_section_alignment (sec, 3);\n \n       ecoff_read_begin_hook ();\n \n@@ -5301,7 +5300,7 @@ maybe_set_gp (asection *sec)\n \n   if (!sec)\n     return;\n-  vma = bfd_get_section_vma (sec->owner, sec);\n+  vma = bfd_section_vma (sec);\n   if (vma && vma < alpha_gp_value)\n     alpha_gp_value = vma;\n }\n@@ -5515,8 +5514,8 @@ md_begin (void)\n   if (ECOFF_DEBUGGING)\n     {\n       segT sec = subseg_new (\".mdebug\", (subsegT) 0);\n-      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);\n-      bfd_set_section_alignment (stdoutput, sec, 3);\n+      bfd_set_section_flags (sec, SEC_HAS_CONTENTS | SEC_READONLY);\n+      bfd_set_section_alignment (sec, 3);\n     }\n #endif\n \n@@ -5563,7 +5562,7 @@ md_assemble (char *str)\n valueT\n md_section_align (segT seg, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   valueT mask = ((valueT) 1 << align) - 1;\n \n   return (size + mask) & ~mask;"
    },
    {
      "sha": "c73906b51bb49596685cdf52a1e1c1efaf267a08",
      "filename": "gas/config/tc-arc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2706,7 +2706,7 @@ valueT\n md_section_align (segT segment,\n \t\t  valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & (-((valueT) 1 << align)));\n }\n@@ -4529,8 +4529,7 @@ arc_set_ext_seg (void)\n   if (!arcext_section)\n     {\n       arcext_section = subseg_new (\".arcextmap\", 0);\n-      bfd_set_section_flags (stdoutput, arcext_section,\n-\t\t\t     SEC_READONLY | SEC_HAS_CONTENTS);\n+      bfd_set_section_flags (arcext_section, SEC_READONLY | SEC_HAS_CONTENTS);\n     }\n   else\n     subseg_set (arcext_section, 0);"
    },
    {
      "sha": "b0f1507c360621cc269937f619b5c16f7882712a",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -22878,7 +22878,7 @@ arm_frob_label (symbolS * sym)\n      out of the jump table, and chaos would ensue.  */\n   if (label_is_thumb_function_name\n       && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')\n-      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+      && (bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     {\n       /* When the address of a Thumb function is taken the bottom\n \t bit of that address should be set.  This will allow\n@@ -26491,7 +26491,7 @@ arm_init_frag (fragS * fragP, int max_chars)\n \n   /* PR 21809: Do not set a mapping state for debug sections\n      - it just confuses other tools.  */\n-  if (bfd_get_section_flags (NULL, now_seg) & SEC_DEBUGGING)\n+  if (bfd_section_flags (now_seg) & SEC_DEBUGGING)\n     return;\n \n   frag_thumb_mode = fragP->tc_frag_data.thumb_mode ^ MODE_RECORDED;\n@@ -30019,9 +30019,8 @@ md_begin (void)\n \n \tif (sec != NULL)\n \t  {\n-\t    bfd_set_section_flags\n-\t      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);\n-\t    bfd_set_section_size (stdoutput, sec, 0);\n+\t    bfd_set_section_flags (sec, SEC_READONLY | SEC_DEBUGGING);\n+\t    bfd_set_section_size (sec, 0);\n \t    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);\n \t  }\n       }"
    },
    {
      "sha": "36262ad8c0dceea43f49bac691c7217e63c83d14",
      "filename": "gas/config/tc-avr.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-avr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-avr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-avr.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1429,7 +1429,7 @@ avr_operands (struct avr_opcodes_s *opcode, char **line)\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & (-1UL << align));\n }\n \n@@ -2229,7 +2229,7 @@ avr_create_property_section (void)\n   sec = bfd_make_section (stdoutput, section_name);\n   if (sec == NULL)\n     as_fatal (_(\"Failed to create property section `%s'\\n\"), section_name);\n-  bfd_set_section_flags (stdoutput, sec, flags);\n+  bfd_set_section_flags (sec, flags);\n   sec->output_section = sec;\n   return sec;\n }\n@@ -2404,7 +2404,7 @@ avr_create_and_fill_property_section (void)\n     return;\n \n   prop_sec = avr_create_property_section ();\n-  bfd_set_section_size (stdoutput, prop_sec, sec_size);\n+  bfd_set_section_size (prop_sec, sec_size);\n \n   subseg_set (prop_sec, 0);\n   frag_base = frag_more (sec_size);"
    },
    {
      "sha": "5f10cb7fb4c77f6de1d093bcaec9b84224329512",
      "filename": "gas/config/tc-bfin.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-bfin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-bfin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-bfin.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -789,7 +789,7 @@ md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int boundary = bfd_get_section_alignment (stdoutput, segment);\n+  int boundary = bfd_section_alignment (segment);\n   return ((size + (1 << boundary) - 1) & -(1 << boundary));\n }\n "
    },
    {
      "sha": "7c3bf2e718fcbfb0585ba9125bcf6ea65750598f",
      "filename": "gas/config/tc-bpf.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-bpf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-bpf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-bpf.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -189,7 +189,7 @@ md_begin (void)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "2eb679bb44267d6d52f3c1469861a11a428981fa",
      "filename": "gas/config/tc-d10v.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-d10v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-d10v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-d10v.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -268,7 +268,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "a54945e1f3b3dd3e3b289ffb6c877345ac1909e4",
      "filename": "gas/config/tc-d30v.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-d30v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-d30v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-d30v.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -302,7 +302,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n \n@@ -1490,7 +1490,7 @@ d30v_align (int n, char *pfill, symbolS *label)\n   if (pfill == NULL)\n     {\n       if (n > 2\n-\t  && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+\t  && (bfd_section_flags (now_seg) & SEC_CODE) != 0)\n \t{\n \t  static char const nop[4] = { 0x00, 0xf0, 0x00, 0x00 };\n "
    },
    {
      "sha": "753cb6e0bf9bf0827fa338b763142cad823c96d8",
      "filename": "gas/config/tc-epiphany.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-epiphany.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-epiphany.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-epiphany.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -152,7 +152,7 @@ md_begin (void)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "5767eeb616238c34fed718e7d1b65909f9e5f2da",
      "filename": "gas/config/tc-fr30.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-fr30.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-fr30.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-fr30.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -154,7 +154,7 @@ md_operand (expressionS * expressionP)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "d8ff553294cfbae0a0b6697cd7423b250aa3da2e",
      "filename": "gas/config/tc-frv.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-frv.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1225,7 +1225,7 @@ md_operand (expressionS *expressionP)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }\n \n@@ -1651,7 +1651,7 @@ frv_frob_file_section (bfd *abfd, asection *sec, void *ptr ATTRIBUTE_UNUSED)\n   segment_info_type *seginfo = seg_info (sec);\n   fixS *fixp;\n   CGEN_CPU_DESC cd = gas_cgen_cpu_desc;\n-  flagword flags = bfd_get_section_flags (abfd, sec);\n+  flagword flags = bfd_section_flags (sec);\n \n   /* Skip relocations in known sections (.ctors, .dtors, and .gcc_except_table)\n      since we can fix those up by hand.  */"
    },
    {
      "sha": "c79c6d42255dcb320125a9a827ab0443f69e31e4",
      "filename": "gas/config/tc-h8300.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-h8300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-h8300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-h8300.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2225,7 +2225,7 @@ md_convert_frag (bfd *headers ATTRIBUTE_UNUSED,\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & (-1U << align));\n }\n "
    },
    {
      "sha": "fb6d82bc596072d42892d6c01275b1107afc4f70",
      "filename": "gas/config/tc-hppa.c",
      "status": "modified",
      "additions": 13,
      "deletions": 15,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-hppa.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1608,7 +1608,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,\n valueT\n md_section_align (asection *segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   int align2 = (1 << align) - 1;\n \n   return (size + align2) & ~align2;\n@@ -5962,7 +5962,7 @@ pa_build_unwind_subspace (struct call_info *call_info)\n   char *name, *p;\n   symbolS *symbolP;\n \n-  if ((bfd_get_section_flags (stdoutput, now_seg)\n+  if ((bfd_section_flags (now_seg)\n        & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))\n       != (SEC_ALLOC | SEC_LOAD | SEC_READONLY))\n     return;\n@@ -6006,10 +6006,9 @@ pa_build_unwind_subspace (struct call_info *call_info)\n   if (seg == ASEC_NULL)\n     {\n       seg = subseg_new (UNWIND_SECTION_NAME, 0);\n-      bfd_set_section_flags (stdoutput, seg,\n-\t\t\t     SEC_READONLY | SEC_HAS_CONTENTS\n-\t\t\t     | SEC_LOAD | SEC_RELOC | SEC_ALLOC | SEC_DATA);\n-      bfd_set_section_alignment (stdoutput, seg, 2);\n+      bfd_set_section_flags (seg, (SEC_READONLY | SEC_HAS_CONTENTS | SEC_LOAD\n+\t\t\t\t   | SEC_RELOC | SEC_ALLOC | SEC_DATA));\n+      bfd_set_section_alignment (seg, 2);\n     }\n \n   subseg_set (seg, 0);\n@@ -7533,14 +7532,13 @@ pa_subspace (int create_new)\n \tseg_info (section)->bss = 1;\n \n       /* Now set the flags.  */\n-      bfd_set_section_flags (stdoutput, section, applicable);\n+      bfd_set_section_flags (section, applicable);\n \n       /* Record any alignment request for this section.  */\n       record_alignment (section, exact_log2 (alignment));\n \n       /* Set the starting offset for this section.  */\n-      bfd_set_section_vma (stdoutput, section,\n-\t\t\t   pa_subspace_start (space, quadrant));\n+      bfd_set_section_vma (section, pa_subspace_start (space, quadrant));\n \n       /* Now that all the flags are set, update an existing subspace,\n \t or create a new one.  */\n@@ -7614,7 +7612,7 @@ pa_spaces_begin (void)\n \t{\n \t  text_section = segment;\n \t  applicable = bfd_applicable_section_flags (stdoutput);\n-\t  bfd_set_section_flags (stdoutput, segment,\n+\t  bfd_set_section_flags (segment,\n \t\t\t\t applicable & (SEC_ALLOC | SEC_LOAD\n \t\t\t\t\t       | SEC_RELOC | SEC_CODE\n \t\t\t\t\t       | SEC_READONLY\n@@ -7624,7 +7622,7 @@ pa_spaces_begin (void)\n \t{\n \t  data_section = segment;\n \t  applicable = bfd_applicable_section_flags (stdoutput);\n-\t  bfd_set_section_flags (stdoutput, segment,\n+\t  bfd_set_section_flags (segment,\n \t\t\t\t applicable & (SEC_ALLOC | SEC_LOAD\n \t\t\t\t\t       | SEC_RELOC\n \t\t\t\t\t       | SEC_HAS_CONTENTS));\n@@ -7634,13 +7632,13 @@ pa_spaces_begin (void)\n \t{\n \t  bss_section = segment;\n \t  applicable = bfd_applicable_section_flags (stdoutput);\n-\t  bfd_set_section_flags (stdoutput, segment,\n+\t  bfd_set_section_flags (segment,\n \t\t\t\t applicable & SEC_ALLOC);\n \t}\n       else if (!strcmp (pa_def_subspaces[i].name, \"$LIT$\"))\n \t{\n \t  applicable = bfd_applicable_section_flags (stdoutput);\n-\t  bfd_set_section_flags (stdoutput, segment,\n+\t  bfd_set_section_flags (segment,\n \t\t\t\t applicable & (SEC_ALLOC | SEC_LOAD\n \t\t\t\t\t       | SEC_RELOC\n \t\t\t\t\t       | SEC_READONLY\n@@ -7649,7 +7647,7 @@ pa_spaces_begin (void)\n       else if (!strcmp (pa_def_subspaces[i].name, \"$MILLICODE$\"))\n \t{\n \t  applicable = bfd_applicable_section_flags (stdoutput);\n-\t  bfd_set_section_flags (stdoutput, segment,\n+\t  bfd_set_section_flags (segment,\n \t\t\t\t applicable & (SEC_ALLOC | SEC_LOAD\n \t\t\t\t\t       | SEC_RELOC\n \t\t\t\t\t       | SEC_READONLY\n@@ -7658,7 +7656,7 @@ pa_spaces_begin (void)\n       else if (!strcmp (pa_def_subspaces[i].name, \"$UNWIND$\"))\n \t{\n \t  applicable = bfd_applicable_section_flags (stdoutput);\n-\t  bfd_set_section_flags (stdoutput, segment,\n+\t  bfd_set_section_flags (segment,\n \t\t\t\t applicable & (SEC_ALLOC | SEC_LOAD\n \t\t\t\t\t       | SEC_RELOC\n \t\t\t\t\t       | SEC_READONLY"
    },
    {
      "sha": "fec69c1397df7bd60587f7765cd728d241d8c8c1",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -8105,7 +8105,7 @@ x86_cleanup (void)\n \n   /* Create the .note.gnu.property section.  */\n   sec = subseg_new (NOTE_GNU_PROPERTY_SECTION_NAME, 0);\n-  bfd_set_section_flags (stdoutput, sec,\n+  bfd_set_section_flags (sec,\n \t\t\t (SEC_ALLOC\n \t\t\t  | SEC_LOAD\n \t\t\t  | SEC_DATA\n@@ -8123,7 +8123,7 @@ x86_cleanup (void)\n       alignment = 2;\n     }\n \n-  bfd_set_section_alignment (stdoutput, sec, alignment);\n+  bfd_set_section_alignment (sec, alignment);\n   elf_section_type (sec) = SHT_NOTE;\n \n   /* GNU_PROPERTY_X86_ISA_1_USED: 4-byte type + 4-byte data size\n@@ -11939,7 +11939,7 @@ md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)\n \t work.  */\n       int align;\n \n-      align = bfd_get_section_alignment (stdoutput, segment);\n+      align = bfd_section_alignment (segment);\n       size = ((size + (1 << align) - 1) & (-((valueT) 1 << align)));\n     }\n #endif\n@@ -12382,8 +12382,7 @@ handle_large_common (int small ATTRIBUTE_UNUSED)\n \t  /* The .lbss section is for local .largecomm symbols.  */\n \t  lbss_section = subseg_new (\".lbss\", 0);\n \t  applicable = bfd_applicable_section_flags (stdoutput);\n-\t  bfd_set_section_flags (stdoutput, lbss_section,\n-\t\t\t\t applicable & SEC_ALLOC);\n+\t  bfd_set_section_flags (lbss_section, applicable & SEC_ALLOC);\n \t  seg_info (lbss_section)->bss = 1;\n \n \t  subseg_set (seg, subseg);"
    },
    {
      "sha": "0c618e811eeb701a88f92b459de5810540ad7bdc",
      "filename": "gas/config/tc-ia64.c",
      "status": "modified",
      "additions": 9,
      "deletions": 14,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ia64.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1152,14 +1152,14 @@ obj_elf_vms_common (int ignore ATTRIBUTE_UNUSED)\n \n   record_alignment (now_seg, log_align);\n \n-  cur_size = bfd_section_size (stdoutput, now_seg);\n+  cur_size = bfd_section_size (now_seg);\n   if ((int) size > cur_size)\n     {\n       char *pfrag\n         = frag_var (rs_fill, 1, 1, (relax_substateT)0, NULL,\n                     (valueT)size - (valueT)cur_size, NULL);\n       *pfrag = 0;\n-      bfd_section_size (stdoutput, now_seg) = size;\n+      bfd_set_section_size (now_seg, size);\n     }\n \n   /* Switch back to current segment.  */\n@@ -3606,8 +3606,7 @@ start_unwind_section (const segT text_seg, int sec_index)\n   else\n     {\n       set_section (sec_name);\n-      bfd_set_section_flags (stdoutput, now_seg,\n-\t\t\t     SEC_LOAD | SEC_ALLOC | SEC_READONLY);\n+      bfd_set_section_flags (now_seg, SEC_LOAD | SEC_ALLOC | SEC_READONLY);\n     }\n \n   elf_linked_to_section (now_seg) = text_seg;\n@@ -7250,7 +7249,7 @@ md_begin (void)\n   md.auto_align = 1;\n   md.explicit_mode = md.default_explicit_mode;\n \n-  bfd_set_section_alignment (stdoutput, text_section, 4);\n+  bfd_set_section_alignment (text_section, 4);\n \n   /* Make sure function pointers get initialized.  */\n   target_big_endian = -1;\n@@ -7778,7 +7777,7 @@ ia64_frob_label (struct symbol *sym)\n       return;\n     }\n \n-  if (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE)\n+  if (bfd_section_flags (now_seg) & SEC_CODE)\n     {\n       md.last_text_seg = now_seg;\n       fix = XOBNEW (&notes, struct label_fix);\n@@ -7818,7 +7817,7 @@ void\n ia64_flush_pending_output (void)\n {\n   if (!md.keep_pending_output\n-      && bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE)\n+      && bfd_section_flags (now_seg) & SEC_CODE)\n     {\n       /* ??? This causes many unnecessary stop bits to be emitted.\n \t Unfortunately, it isn't clear if it is safe to remove this.  */\n@@ -10989,7 +10988,7 @@ ia64_pcrel_from_section (fixS *fix, segT sec)\n {\n   unsigned long off = fix->fx_frag->fr_address + fix->fx_where;\n \n-  if (bfd_get_section_flags (stdoutput, sec) & SEC_CODE)\n+  if (bfd_section_flags (sec) & SEC_CODE)\n     off &= ~0xfUL;\n \n   return off;\n@@ -11946,9 +11945,7 @@ ia64_vms_note (void)\n   /* Create the .note section.  */\n \n   secp = subseg_new (\".note\", 0);\n-  bfd_set_section_flags (stdoutput,\n-\t\t\t secp,\n-\t\t\t SEC_HAS_CONTENTS | SEC_READONLY);\n+  bfd_set_section_flags (secp, SEC_HAS_CONTENTS | SEC_READONLY);\n \n   /* Module header note (MHD).  */\n   bname = xstrdup (lbasename (out_file_name));\n@@ -11993,9 +11990,7 @@ ia64_vms_note (void)\n   frag_align (3, 0, 0);\n \n   secp = subseg_new (\".vms_display_name_info\", 0);\n-  bfd_set_section_flags (stdoutput,\n-\t\t\t secp,\n-\t\t\t SEC_HAS_CONTENTS | SEC_READONLY);\n+  bfd_set_section_flags (secp, SEC_HAS_CONTENTS | SEC_READONLY);\n \n   /* This symbol should be passed on the command line and be variable\n      according to language.  */"
    },
    {
      "sha": "53b4d88f111aa33bc3d4460dbb02a24f6de0019b",
      "filename": "gas/config/tc-ip2k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-ip2k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-ip2k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ip2k.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -213,7 +213,7 @@ md_assemble (char * str)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "d2a0c59848306451508e75cebf57261e96cc535d",
      "filename": "gas/config/tc-iq2000.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-iq2000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-iq2000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-iq2000.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -430,7 +430,7 @@ md_assemble (char * str)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }\n \n@@ -817,7 +817,7 @@ s_iq2000_end (int x ATTRIBUTE_UNUSED)\n   else\n     p = NULL;\n \n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     maybe_text = 1;\n   else\n     maybe_text = 0;\n@@ -916,7 +916,7 @@ s_iq2000_ent (int aent)\n   if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')\n     get_number ();\n \n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     maybe_text = 1;\n   else\n     maybe_text = 0;"
    },
    {
      "sha": "75a733a6f22839c3552da86235b3d8b444107cf9",
      "filename": "gas/config/tc-lm32.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-lm32.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -277,7 +277,7 @@ md_undefined_symbol (char * name ATTRIBUTE_UNUSED)\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "3ea3e5997407ee93a1d3841b2e738dc8f3dc1c9b",
      "filename": "gas/config/tc-m32c.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-m32c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-m32c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m32c.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -392,7 +392,7 @@ md_operand (expressionS * exp)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "75ee9d93dedc130145cc7b25a55e9ae9548fc6bc",
      "filename": "gas/config/tc-m32r.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m32r.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -713,7 +713,7 @@ md_begin (void)\n \n   /* This is copied from perform_an_assembly_pass.  */\n   applicable = bfd_applicable_section_flags (stdoutput);\n-  bfd_set_section_flags (stdoutput, sbss_section, applicable & SEC_ALLOC);\n+  bfd_set_section_flags (sbss_section, applicable & SEC_ALLOC);\n \n   subseg_set (seg, subseg);\n \n@@ -1448,7 +1448,7 @@ md_operand (expressionS *expressionP)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "1c36d5d98cba01efd4ee0f38bca0d21cbf467fa5",
      "filename": "gas/config/tc-m68hc11.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-m68hc11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-m68hc11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m68hc11.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -583,7 +583,7 @@ md_atof (int type, char *litP, int *sizeP)\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "c0d48e835437fb68fcb834d6f6db24a952957cfd",
      "filename": "gas/config/tc-mep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1380,7 +1380,7 @@ md_assemble (char * str)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }\n \n@@ -1528,7 +1528,7 @@ md_estimate_size_before_relax (fragS * fragP, segT segment)\n       || S_IS_WEAK (fragP->fr_symbol)\n #ifdef MEP_IVC2_SUPPORTED\n       || (mep_cop == EF_MEP_COP_IVC2\n-\t  && bfd_get_section_flags (stdoutput, segment) & SEC_MEP_VLIW)\n+\t  && bfd_section_flags (segment) & SEC_MEP_VLIW)\n #endif /* MEP_IVC2_SUPPORTED */\n       )\n     {\n@@ -1539,7 +1539,7 @@ md_estimate_size_before_relax (fragS * fragP, segT segment)\n     }\n \n   if (MEP_VLIW && ! MEP_VLIW64\n-      && (bfd_get_section_flags (stdoutput, segment) & SEC_MEP_VLIW))\n+      && (bfd_section_flags (segment) & SEC_MEP_VLIW))\n     {\n       /* Use 32 bit branches for vliw32 so the vliw word is not split.  */\n       switch (fragP->fr_cgen.insn->base->num)\n@@ -1572,7 +1572,7 @@ md_estimate_size_before_relax (fragS * fragP, segT segment)\n \n #ifdef MEP_IVC2_SUPPORTED\n   if (mep_cop == EF_MEP_COP_IVC2\n-      && bfd_get_section_flags (stdoutput, segment) & SEC_MEP_VLIW)\n+      && bfd_section_flags (segment) & SEC_MEP_VLIW)\n     return 0;\n #endif /* MEP_IVC2_SUPPORTED */\n \n@@ -1587,7 +1587,7 @@ mep_relax_frag (segT segment, fragS *fragP, long stretch)\n   long rv = relax_frag (segment, fragP, stretch);\n #ifdef MEP_IVC2_SUPPORTED\n   if (mep_cop == EF_MEP_COP_IVC2\n-      && bfd_get_section_flags (stdoutput, segment) & SEC_MEP_VLIW)\n+      && bfd_section_flags (segment) & SEC_MEP_VLIW)\n     return 0;\n #endif\n   return rv;\n@@ -1624,7 +1624,7 @@ md_convert_frag (bfd *abfd  ATTRIBUTE_UNUSED,\n   int core_mode;\n \n #ifdef MEP_IVC2_SUPPORTED\n-  if (bfd_get_section_flags (stdoutput, seg) & SEC_MEP_VLIW\n+  if (bfd_section_flags (seg) & SEC_MEP_VLIW\n       && mep_cop == EF_MEP_COP_IVC2)\n     core_mode = 0;\n   else\n@@ -2110,7 +2110,7 @@ mep_vtext_section (void)\n     {\n       flagword applicable = bfd_applicable_section_flags (stdoutput);\n       vtext_section = subseg_new (VTEXT_SECTION_NAME, 0);\n-      bfd_set_section_flags (stdoutput, vtext_section,\n+      bfd_set_section_flags (vtext_section,\n \t\t\t     applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n \t\t\t\t\t   | SEC_CODE | SEC_READONLY\n \t\t\t\t\t   | SEC_MEP_VLIW));"
    },
    {
      "sha": "2f68d688eadf2374214e7abbd2ff4d049f098026",
      "filename": "gas/config/tc-microblaze.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-microblaze.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2011,8 +2011,7 @@ md_apply_fix (fixS *   fixP,\n     {\n       if (S_IS_WEAK (fixP->fx_addsy)\n \t  || (symbol_used_in_reloc_p (fixP->fx_addsy)\n-\t      && (((bfd_get_section_flags (stdoutput,\n-\t\t\t\t\t   S_GET_SEGMENT (fixP->fx_addsy))\n+\t      && (((bfd_section_flags (S_GET_SEGMENT (fixP->fx_addsy))\n \t\t    & SEC_LINK_ONCE) != 0)\n \t\t  || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),\n \t\t\t       \".gnu.linkonce\","
    },
    {
      "sha": "b2e49730c0eb3d5b5c041d3c62938017ecdc529e",
      "filename": "gas/config/tc-mips.c",
      "status": "modified",
      "additions": 24,
      "deletions": 27,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mips.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3859,9 +3859,9 @@ md_begin (void)\n   if (strncmp (TARGET_OS, \"elf\", 3) != 0\n       && strncmp (TARGET_OS, \"vxworks\", 7) != 0)\n     {\n-      (void) bfd_set_section_alignment (stdoutput, text_section, 4);\n-      (void) bfd_set_section_alignment (stdoutput, data_section, 4);\n-      (void) bfd_set_section_alignment (stdoutput, bss_section, 4);\n+      bfd_set_section_alignment (text_section, 4);\n+      bfd_set_section_alignment (data_section, 4);\n+      bfd_set_section_alignment (bss_section, 4);\n     }\n \n   /* Create a .reginfo section for register masks and a .mdebug\n@@ -3886,8 +3886,8 @@ md_begin (void)\n       {\n \tsec = subseg_new (\".reginfo\", (subsegT) 0);\n \n-\tbfd_set_section_flags (stdoutput, sec, flags);\n-\tbfd_set_section_alignment (stdoutput, sec, HAVE_NEWABI ? 3 : 2);\n+\tbfd_set_section_flags (sec, flags);\n+\tbfd_set_section_alignment (sec, HAVE_NEWABI ? 3 : 2);\n \n \tmips_regmask_frag = frag_more (sizeof (Elf32_External_RegInfo));\n       }\n@@ -3896,8 +3896,8 @@ md_begin (void)\n \t/* The 64-bit ABI uses a .MIPS.options section rather than\n \t   .reginfo section.  */\n \tsec = subseg_new (\".MIPS.options\", (subsegT) 0);\n-\tbfd_set_section_flags (stdoutput, sec, flags);\n-\tbfd_set_section_alignment (stdoutput, sec, 3);\n+\tbfd_set_section_flags (sec, flags);\n+\tbfd_set_section_alignment (sec, 3);\n \n \t/* Set up the option header.  */\n \t{\n@@ -3918,25 +3918,23 @@ md_begin (void)\n       }\n \n     sec = subseg_new (\".MIPS.abiflags\", (subsegT) 0);\n-    bfd_set_section_flags (stdoutput, sec,\n+    bfd_set_section_flags (sec,\n \t\t\t   SEC_READONLY | SEC_DATA | SEC_ALLOC | SEC_LOAD);\n-    bfd_set_section_alignment (stdoutput, sec, 3);\n+    bfd_set_section_alignment (sec, 3);\n     mips_flags_frag = frag_more (sizeof (Elf_External_ABIFlags_v0));\n \n     if (ECOFF_DEBUGGING)\n       {\n \tsec = subseg_new (\".mdebug\", (subsegT) 0);\n-\t(void) bfd_set_section_flags (stdoutput, sec,\n-\t\t\t\t      SEC_HAS_CONTENTS | SEC_READONLY);\n-\t(void) bfd_set_section_alignment (stdoutput, sec, 2);\n+\tbfd_set_section_flags (sec, SEC_HAS_CONTENTS | SEC_READONLY);\n+\tbfd_set_section_alignment (sec, 2);\n       }\n     else if (mips_flag_pdr)\n       {\n \tpdr_seg = subseg_new (\".pdr\", (subsegT) 0);\n-\t(void) bfd_set_section_flags (stdoutput, pdr_seg,\n-\t\t\t\t      SEC_READONLY | SEC_RELOC\n-\t\t\t\t      | SEC_DEBUGGING);\n-\t(void) bfd_set_section_alignment (stdoutput, pdr_seg, 2);\n+\tbfd_set_section_flags (pdr_seg,\n+\t\t\t       SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);\n+\tbfd_set_section_alignment (pdr_seg, 2);\n       }\n \n     subseg_set (seg, subseg);\n@@ -4468,7 +4466,7 @@ s_is_linkonce (symbolS *sym, segT from_seg)\n \n   if (symseg != from_seg && !S_IS_LOCAL (sym))\n     {\n-      if ((bfd_get_section_flags (stdoutput, symseg) & SEC_LINK_ONCE))\n+      if ((bfd_section_flags (symseg) & SEC_LINK_ONCE))\n \tlinkonce = TRUE;\n       /* The GNU toolchain uses an extension for ELF: a section\n \t beginning with the magic string .gnu.linkonce is a\n@@ -6180,7 +6178,7 @@ match_float_constant (struct mips_arg_info *arg, expressionS *imm,\n     }\n \n   new_seg = subseg_new (newname, (subsegT) 0);\n-  bfd_set_section_flags (stdoutput, new_seg,\n+  bfd_set_section_flags (new_seg,\n \t\t\t SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA);\n   frag_align (length == 4 ? 2 : 3, 0, 0);\n   if (strncmp (TARGET_OS, \"elf\", 3) != 0)\n@@ -16128,7 +16126,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n \t       && fixP->fx_done\n \t       && fixP->fx_frag->fr_address >= text_section->vma\n \t       && (fixP->fx_frag->fr_address\n-\t\t   < text_section->vma + bfd_get_section_size (text_section))\n+\t\t   < text_section->vma + bfd_section_size (text_section))\n \t       && ((insn & 0xffff0000) == 0x10000000\t /* beq $0,$0 */\n \t\t   || (insn & 0xffff0000) == 0x04010000\t /* bgez $0 */\n \t\t   || (insn & 0xffff0000) == 0x04110000)) /* bgezal $0 */\n@@ -16319,17 +16317,16 @@ s_change_sec (int sec)\n     case 'r':\n       seg = subseg_new (RDATA_SECTION_NAME,\n \t\t\t(subsegT) get_absolute_expression ());\n-      bfd_set_section_flags (stdoutput, seg, (SEC_ALLOC | SEC_LOAD\n-\t\t\t\t\t      | SEC_READONLY | SEC_RELOC\n-\t\t\t\t\t      | SEC_DATA));\n+      bfd_set_section_flags (seg, (SEC_ALLOC | SEC_LOAD | SEC_READONLY\n+\t\t\t\t   | SEC_RELOC | SEC_DATA));\n       if (strncmp (TARGET_OS, \"elf\", 3) != 0)\n \trecord_alignment (seg, 4);\n       demand_empty_rest_of_line ();\n       break;\n \n     case 's':\n       seg = subseg_new (\".sdata\", (subsegT) get_absolute_expression ());\n-      bfd_set_section_flags (stdoutput, seg,\n+      bfd_set_section_flags (seg,\n \t\t\t     SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);\n       if (strncmp (TARGET_OS, \"elf\", 3) != 0)\n \trecord_alignment (seg, 4);\n@@ -16338,7 +16335,7 @@ s_change_sec (int sec)\n \n     case 'B':\n       seg = subseg_new (\".sbss\", (subsegT) get_absolute_expression ());\n-      bfd_set_section_flags (stdoutput, seg, SEC_ALLOC);\n+      bfd_set_section_flags (seg, SEC_ALLOC);\n       if (strncmp (TARGET_OS, \"elf\", 3) != 0)\n \trecord_alignment (seg, 4);\n       demand_empty_rest_of_line ();\n@@ -17603,7 +17600,7 @@ tc_get_register (int frame)\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n \n   /* We don't need to align ELF sections to the full alignment.\n      However, Irix 5 may prefer that we align them at least to a 16\n@@ -19760,7 +19757,7 @@ s_mips_end (int x ATTRIBUTE_UNUSED)\n   else\n     p = NULL;\n \n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) == 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) == 0)\n     as_warn (_(\".end not in text section\"));\n \n   if (!cur_proc_ptr)\n@@ -19850,7 +19847,7 @@ s_mips_ent (int aent)\n       || *input_line_pointer == '-')\n     get_number ();\n \n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) == 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) == 0)\n     as_warn (_(\".ent or .aent not in text section\"));\n \n   if (!aent && cur_proc_ptr)"
    },
    {
      "sha": "1514b6d0607d41a4e57afefa20e0d05e37eb2075",
      "filename": "gas/config/tc-mmix.c",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mmix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mmix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mmix.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2130,9 +2130,8 @@ s_bspec (int unused ATTRIBUTE_UNUSED)\n       if (sec == NULL)\n \tas_fatal (_(\"can't create section %s\"), newsecname);\n \n-      if (!bfd_set_section_flags (stdoutput, sec,\n-\t\t\t\t  bfd_get_section_flags (stdoutput, sec)\n-\t\t\t\t  | SEC_READONLY))\n+      if (!bfd_set_section_flags (sec,\n+\t\t\t\t  bfd_section_flags (sec) | SEC_READONLY))\n \tas_fatal (_(\"can't set section flags for section %s\"), newsecname);\n     }\n \n@@ -2638,7 +2637,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixP)\n      than just helping the user around this limitation here; hopefully the\n      code using the local expression is around.  Putting the LOCAL\n      semantics in a relocation still seems right; a section didn't do.  */\n-  if (bfd_section_size (section->owner, section) == 0)\n+  if (bfd_section_size (section) == 0)\n     as_bad_where\n       (fixP->fx_file, fixP->fx_line,\n        fixP->fx_r_type == BFD_RELOC_MMIX_LOCAL\n@@ -2708,7 +2707,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixP)\n \t resolve the relocation here.  */\n       if (addsy != NULL\n \t  && (bfd_is_und_section (addsec)\n-\t      || strcmp (bfd_get_section_name (addsec->owner, addsec),\n+\t      || strcmp (bfd_section_name (addsec),\n \t\t\t MMIX_REG_CONTENTS_SECTION_NAME) == 0))\n \t{\n \t  code = fixP->fx_r_type;\n@@ -2735,7 +2734,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixP)\n \n     case BFD_RELOC_MMIX_BASE_PLUS_OFFSET:\n       if (addsy != NULL\n-\t  && strcmp (bfd_get_section_name (addsec->owner, addsec),\n+\t  && strcmp (bfd_section_name (addsec),\n \t\t     MMIX_REG_CONTENTS_SECTION_NAME) == 0)\n \t{\n \t  /* This changed into a register; the relocation is for the\n@@ -2838,7 +2837,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixP)\n     case BFD_RELOC_MMIX_REG:\n       if (addsy != NULL\n \t  && (bfd_is_und_section (addsec)\n-\t      || strcmp (bfd_get_section_name (addsec->owner, addsec),\n+\t      || strcmp (bfd_section_name (addsec),\n \t\t\t MMIX_REG_CONTENTS_SECTION_NAME) == 0))\n \t{\n \t  code = fixP->fx_r_type;\n@@ -3794,7 +3793,7 @@ mmix_frob_file (void)\n   if (real_reg_section != NULL)\n     {\n       /* FIXME: Pass error state gracefully.  */\n-      if (bfd_get_section_flags (stdoutput, real_reg_section) & SEC_HAS_CONTENTS)\n+      if (bfd_section_flags (real_reg_section) & SEC_HAS_CONTENTS)\n \tas_fatal (_(\"register section has contents\\n\"));\n \n       bfd_section_list_remove (stdoutput, real_reg_section);\n@@ -3924,7 +3923,7 @@ mmix_md_elf_section_change_hook (void)\n   if (doing_bspec)\n     as_bad (_(\"section change from within a BSPEC/ESPEC pair is not supported\"));\n \n-  last_alignment = bfd_get_section_alignment (now_seg->owner, now_seg);\n+  last_alignment = bfd_section_alignment (now_seg);\n   want_unaligned = 0;\n }\n "
    },
    {
      "sha": "ebc011b1a6da917edde3b6fb6bdf3da659ee5377",
      "filename": "gas/config/tc-mn10200.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mn10200.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mn10200.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mn10200.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -675,7 +675,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "1a41731379f01454b8c79f1d06b402aaca9f0596",
      "filename": "gas/config/tc-mn10300.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mn10300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mn10300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mn10300.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -900,7 +900,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n \n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n@@ -2616,7 +2616,7 @@ mn10300_handle_align (fragS *frag)\n       && now_seg != bss_section\n       /* Do not create relocs for the merging sections - such\n \t relocs will prevent the contents from being merged.  */\n-      && (bfd_get_section_flags (now_seg->owner, now_seg) & SEC_MERGE) == 0)\n+      && (bfd_section_flags (now_seg) & SEC_MERGE) == 0)\n     /* Create a new fixup to record the alignment request.  The symbol is\n        irrelevant but must be present so we use the absolute section symbol.\n        The offset from the symbol is used to record the power-of-two alignment"
    },
    {
      "sha": "56d202434999613a44bc4930ce5652035315e03b",
      "filename": "gas/config/tc-msp430.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-msp430.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-msp430.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-msp430.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -4239,7 +4239,7 @@ md_assemble (char * str)\n valueT\n md_section_align (asection * seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n \n   return ((addr + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "5b938aa2a9301524a7b9a52555c5fd1daf63bba0",
      "filename": "gas/config/tc-mt.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-mt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mt.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -333,7 +333,7 @@ md_assemble (char * str)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "36ed58a453814b5c56ce7523074fd9ec05bef38c",
      "filename": "gas/config/tc-nds32.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-nds32.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3841,7 +3841,7 @@ do_nds32_seg (int i, subsegT sub)\n       seg->s = subseg_new (seg->name, sub);\n       if (OUTPUT_FLAVOR == bfd_target_elf_flavour)\n \t{\n-\t  bfd_set_section_flags (stdoutput, seg->s, seg->flags);\n+\t  bfd_set_section_flags (seg->s, seg->flags);\n \t  if ((seg->flags & SEC_LOAD) == 0)\n \t    seg_info (seg->s)->bss = 1;\n \t}\n@@ -6609,7 +6609,7 @@ md_operand (expressionS *expressionP)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & ((valueT) -1 << align));\n }\n@@ -7569,7 +7569,7 @@ nds32_set_section_relocs (asection *sec, arelent ** relocs ATTRIBUTE_UNUSED,\n \t\t\t  unsigned int n ATTRIBUTE_UNUSED)\n {\n   bfd *abfd ATTRIBUTE_UNUSED = sec->owner;\n-  if (bfd_get_section_flags (abfd, sec) & (flagword) SEC_RELOC)\n+  if (bfd_section_flags (sec) & (flagword) SEC_RELOC)\n     nds32_insertion_sort (sec->orelocation, sec->reloc_count,\n \t\t\t  sizeof (arelent**), compar_relent);\n }"
    },
    {
      "sha": "e29d4dd77d065e680c84664491f12dfc3ea503ff",
      "filename": "gas/config/tc-or1k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-or1k.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -165,7 +165,7 @@ md_operand (expressionS * expressionP)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "156f62c6fc07e2d945d91fb817352bc4f158c0fa",
      "filename": "gas/config/tc-ppc.c",
      "status": "modified",
      "additions": 32,
      "deletions": 42,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ppc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1975,9 +1975,7 @@ ppc_cleanup (void)\n \n     /* Create the .PPC.EMB.apuinfo section.  */\n     apuinfo_secp = subseg_new (APUINFO_SECTION_NAME, 0);\n-    bfd_set_section_flags (stdoutput,\n-\t\t\t   apuinfo_secp,\n-\t\t\t   SEC_HAS_CONTENTS | SEC_READONLY);\n+    bfd_set_section_flags (apuinfo_secp, SEC_HAS_CONTENTS | SEC_READONLY);\n \n     p = frag_more (4);\n     md_number_to_chars (p, (valueT) 8, 4);\n@@ -2703,7 +2701,7 @@ ppc_frob_file_before_adjust (void)\n   toc = bfd_get_section_by_name (stdoutput, \".toc\");\n   if (toc != NULL\n       && toc_reloc_types != has_large_toc_reloc\n-      && bfd_section_size (stdoutput, toc) > 0x10000)\n+      && bfd_section_size (toc) > 0x10000)\n     as_warn (_(\"TOC section size exceeds 64k\"));\n }\n \n@@ -4681,14 +4679,14 @@ ppc_change_debug_section (unsigned int idx, subsegT subseg)\n   const struct xcoff_dwsect_name *dw = &xcoff_dwsect_names[idx];\n \n   sec = subseg_new (dw->name, subseg);\n-  oldflags = bfd_get_section_flags (stdoutput, sec);\n+  oldflags = bfd_section_flags (sec);\n   if (oldflags == SEC_NO_FLAGS)\n     {\n       /* Just created section.  */\n       gas_assert (dw_sections[idx].sect == NULL);\n \n-      bfd_set_section_flags (stdoutput, sec, SEC_DEBUGGING);\n-      bfd_set_section_alignment (stdoutput, sec, 0);\n+      bfd_set_section_flags (sec, SEC_DEBUGGING);\n+      bfd_set_section_alignment (sec, 0);\n       dw_sections[idx].sect = sec;\n     }\n \n@@ -5804,11 +5802,10 @@ ppc_pdata (int ignore ATTRIBUTE_UNUSED)\n     {\n       pdata_section = subseg_new (\".pdata\", 0);\n \n-      bfd_set_section_flags (stdoutput, pdata_section,\n-\t\t\t     (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t      | SEC_READONLY | SEC_DATA ));\n+      bfd_set_section_flags (pdata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n+\t\t\t\t\t     | SEC_READONLY | SEC_DATA));\n \n-      bfd_set_section_alignment (stdoutput, pdata_section, 2);\n+      bfd_set_section_alignment (pdata_section, 2);\n     }\n   else\n     {\n@@ -5837,11 +5834,10 @@ ppc_ydata (int ignore ATTRIBUTE_UNUSED)\n   if (ydata_section == 0)\n     {\n       ydata_section = subseg_new (\".ydata\", 0);\n-      bfd_set_section_flags (stdoutput, ydata_section,\n-\t\t\t     (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t      | SEC_READONLY | SEC_DATA ));\n+      bfd_set_section_flags (ydata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n+\t\t\t\t\t     | SEC_READONLY | SEC_DATA ));\n \n-      bfd_set_section_alignment (stdoutput, ydata_section, 3);\n+      bfd_set_section_alignment (ydata_section, 3);\n     }\n   else\n     {\n@@ -5874,11 +5870,10 @@ ppc_reldata (int ignore ATTRIBUTE_UNUSED)\n     {\n       reldata_section = subseg_new (\".reldata\", 0);\n \n-      bfd_set_section_flags (stdoutput, reldata_section,\n-\t\t\t     (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t      | SEC_DATA));\n+      bfd_set_section_flags (reldata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n+\t\t\t\t\t       | SEC_DATA));\n \n-      bfd_set_section_alignment (stdoutput, reldata_section, 2);\n+      bfd_set_section_alignment (reldata_section, 2);\n     }\n   else\n     {\n@@ -5903,11 +5898,10 @@ ppc_rdata (int ignore ATTRIBUTE_UNUSED)\n   if (rdata_section == 0)\n     {\n       rdata_section = subseg_new (\".rdata\", 0);\n-      bfd_set_section_flags (stdoutput, rdata_section,\n-\t\t\t     (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t      | SEC_READONLY | SEC_DATA ));\n+      bfd_set_section_flags (rdata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n+\t\t\t\t\t     | SEC_READONLY | SEC_DATA ));\n \n-      bfd_set_section_alignment (stdoutput, rdata_section, 2);\n+      bfd_set_section_alignment (rdata_section, 2);\n     }\n   else\n     {\n@@ -6261,13 +6255,13 @@ ppc_pe_section (int ignore ATTRIBUTE_UNUSED)\n \n   if (flags != SEC_NO_FLAGS)\n     {\n-      if (! bfd_set_section_flags (stdoutput, sec, flags))\n+      if (!bfd_set_section_flags (sec, flags))\n \tas_bad (_(\"error setting flags for \\\"%s\\\": %s\"),\n-\t\tbfd_section_name (stdoutput, sec),\n+\t\tbfd_section_name (sec),\n \t\tbfd_errmsg (bfd_get_error ()));\n     }\n \n-  bfd_set_section_alignment (stdoutput, sec, align);\n+  bfd_set_section_alignment (sec, align);\n }\n \n static void\n@@ -6298,11 +6292,10 @@ ppc_pe_tocd (int ignore ATTRIBUTE_UNUSED)\n     {\n       tocdata_section = subseg_new (\".tocd\", 0);\n       /* FIXME: section flags won't work.  */\n-      bfd_set_section_flags (stdoutput, tocdata_section,\n-\t\t\t     (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t      | SEC_READONLY | SEC_DATA));\n+      bfd_set_section_flags (tocdata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n+\t\t\t\t\t       | SEC_READONLY | SEC_DATA));\n \n-      bfd_set_section_alignment (stdoutput, tocdata_section, 2);\n+      bfd_set_section_alignment (tocdata_section, 2);\n     }\n   else\n     {\n@@ -6573,8 +6566,7 @@ ppc_frob_symbol (symbolS *sym)\n \t  /* This is a csect symbol.  x_scnlen is the size of the\n \t     csect.  */\n \t  if (symbol_get_tc (sym)->next == (symbolS *) NULL)\n-\t    a->x_csect.x_scnlen.l = (bfd_section_size (stdoutput,\n-\t\t\t\t\t\t       S_GET_SEGMENT (sym))\n+\t    a->x_csect.x_scnlen.l = (bfd_section_size (S_GET_SEGMENT (sym))\n \t\t\t\t     - S_GET_VALUE (sym));\n \t  else\n \t    {\n@@ -6622,8 +6614,7 @@ ppc_frob_symbol (symbolS *sym)\n \t      || symbol_get_tc (next)->symbol_class != XMC_TC)\n \t    {\n \t      if (ppc_after_toc_frag == (fragS *) NULL)\n-\t\ta->x_csect.x_scnlen.l = (bfd_section_size (stdoutput,\n-\t\t\t\t\t\t\t   data_section)\n+\t\ta->x_csect.x_scnlen.l = (bfd_section_size (data_section)\n \t\t\t\t\t - S_GET_VALUE (sym));\n \t      else\n \t\ta->x_csect.x_scnlen.l = (ppc_after_toc_frag->fr_address\n@@ -6787,12 +6778,12 @@ ppc_frob_section (asection *sec)\n   static bfd_vma vma = 0;\n \n   /* Dwarf sections start at 0.  */\n-  if (bfd_get_section_flags (NULL, sec) & SEC_DEBUGGING)\n+  if (bfd_section_flags (sec) & SEC_DEBUGGING)\n     return;\n \n   vma = md_section_align (sec, vma);\n-  bfd_set_section_vma (stdoutput, sec, vma);\n-  vma += bfd_section_size (stdoutput, sec);\n+  bfd_set_section_vma (sec, vma);\n+  vma += bfd_section_size (sec);\n }\n \n #endif /* OBJ_XCOFF */\n@@ -6823,7 +6814,7 @@ md_section_align (asection *seg ATTRIBUTE_UNUSED, valueT addr)\n #ifdef OBJ_ELF\n   return addr;\n #else\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n \n   return ((addr + (1 << align) - 1) & -(1 << align));\n #endif\n@@ -6886,7 +6877,7 @@ ppc_fix_adjustable (fixS *fix)\n     return 0;\n \n   /* Always adjust symbols in debugging sections.  */\n-  if (bfd_get_section_flags (stdoutput, symseg) & SEC_DEBUGGING)\n+  if (bfd_section_flags (symseg) & SEC_DEBUGGING)\n     return 1;\n \n   if (ppc_toc_csect != (symbolS *) NULL\n@@ -7927,9 +7918,8 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg)\n #else\n       /* We want to use the offset within the toc, not the actual VMA\n \t of the symbol.  */\n-      fixP->fx_addnumber =\n-\t- bfd_get_section_vma (stdoutput, S_GET_SEGMENT (fixP->fx_addsy))\n-\t- S_GET_VALUE (ppc_toc_csect);\n+      fixP->fx_addnumber = (- bfd_section_vma (S_GET_SEGMENT (fixP->fx_addsy))\n+\t\t\t    - S_GET_VALUE (ppc_toc_csect));\n       /* Set *valP to avoid errors.  */\n       *valP = value;\n #endif"
    },
    {
      "sha": "2e2058c1debb81adf60dd9ddba744caee1d4577e",
      "filename": "gas/config/tc-pru.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-pru.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-pru.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-pru.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1745,7 +1745,7 @@ md_assemble (char *op_str)\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & (-((valueT) 1 << align)));\n }\n "
    },
    {
      "sha": "9160cc027fb077118e666d344f57d3e8fa150928",
      "filename": "gas/config/tc-rl78.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-rl78.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-rl78.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-rl78.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1520,6 +1520,6 @@ md_apply_fix (struct fix * f ATTRIBUTE_UNUSED,\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "5d2e69b8b30a803851e91dcc186819e7a2a299d9",
      "filename": "gas/config/tc-rx.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-rx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-rx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-rx.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -509,7 +509,7 @@ parse_rx_section (char * name)\n       obj_elf_change_section (name, type, 0, attr, 0, NULL, FALSE, FALSE);\n     }\n \n-  bfd_set_section_alignment (stdoutput, now_seg, align);\n+  bfd_set_section_alignment (now_seg, align);\n }\n \n static void\n@@ -1290,7 +1290,7 @@ md_operand (expressionS * exp ATTRIBUTE_UNUSED)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "be4d4fb0952e40f7ad5ab82d1a77d8dc27a2c12b",
      "filename": "gas/config/tc-s12z.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-s12z.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-s12z.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-s12z.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -187,7 +187,7 @@ md_atof (int type, char *litP, int *sizeP)\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "a4dae4fb16d67501fc57977875ea2a66b9ef95ff",
      "filename": "gas/config/tc-s390.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-s390.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2084,7 +2084,7 @@ md_atof (int type, char *litp, int *sizep)\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n \n   return ((addr + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "1393a188206ad34616e930b6395f3c06c2b24875",
      "filename": "gas/config/tc-score.c",
      "status": "modified",
      "additions": 17,
      "deletions": 16,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-score.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-score.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-score.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -5300,7 +5300,7 @@ s3_pic_need_relax (symbolS *sym, asection *segtype)\n   linkonce = FALSE;\n   if (symsec != segtype && ! S_IS_LOCAL (sym))\n     {\n-      if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE) != 0)\n+      if ((bfd_section_flags (symsec) & SEC_LINK_ONCE) != 0)\n \tlinkonce = TRUE;\n \n       /* The GNU toolchain uses an extension for ELF: a section\n@@ -5546,7 +5546,7 @@ static void\n s3_score_s_section (int ignore)\n {\n   obj_elf_section (ignore);\n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     record_alignment (now_seg, 2);\n \n }\n@@ -5569,14 +5569,14 @@ s3_s_change_sec (int sec)\n     {\n     case 'r':\n       seg = subseg_new (s3_RDATA_SECTION_NAME, (subsegT) get_absolute_expression ());\n-      bfd_set_section_flags (stdoutput, seg, (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_RELOC | SEC_DATA));\n+      bfd_set_section_flags (seg, (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_RELOC | SEC_DATA));\n       if (strcmp (TARGET_OS, \"elf\") != 0)\n         record_alignment (seg, 4);\n       demand_empty_rest_of_line ();\n       break;\n     case 's':\n       seg = subseg_new (\".sdata\", (subsegT) get_absolute_expression ());\n-      bfd_set_section_flags (stdoutput, seg, SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);\n+      bfd_set_section_flags (seg, SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);\n       if (strcmp (TARGET_OS, \"elf\") != 0)\n         record_alignment (seg, 4);\n       demand_empty_rest_of_line ();\n@@ -5686,7 +5686,7 @@ s3_s_score_ent (int aent)\n     s3_get_number ();\n \n #ifdef BFD_ASSEMBLER\n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     maybe_text = 1;\n   else\n     maybe_text = 0;\n@@ -5795,7 +5795,7 @@ s3_s_score_end (int x ATTRIBUTE_UNUSED)\n     p = NULL;\n \n #ifdef BFD_ASSEMBLER\n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     maybe_text = 1;\n   else\n     maybe_text = 0;\n@@ -6128,15 +6128,16 @@ s3_s_score_lcomm (int bytes_p)\n   if (OUTPUT_FLAVOR == bfd_target_ecoff_flavour || OUTPUT_FLAVOR == bfd_target_elf_flavour)\n     {\n       /* For Score and Alpha ECOFF or ELF, small objects are put in .sbss.  */\n-      if ((unsigned)temp <= bfd_get_gp_size (stdoutput))\n-        {\n-          bss_seg = subseg_new (\".sbss\", 1);\n-          seg_info (bss_seg)->bss = 1;\n+      if ((unsigned) temp <= bfd_get_gp_size (stdoutput))\n+\t{\n+\t  bss_seg = subseg_new (\".sbss\", 1);\n+\t  seg_info (bss_seg)->bss = 1;\n #ifdef BFD_ASSEMBLER\n-          if (!bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))\n-            as_warn (_(\"error setting flags for \\\".sbss\\\": %s\"), bfd_errmsg (bfd_get_error ()));\n+\t  if (!bfd_set_section_flags (bss_seg, SEC_ALLOC))\n+\t    as_warn (_(\"error setting flags for \\\".sbss\\\": %s\"),\n+\t\t     bfd_errmsg (bfd_get_error ()));\n #endif\n-        }\n+\t}\n     }\n #endif\n \n@@ -6538,8 +6539,8 @@ s3_begin (void)\n   seg = now_seg;\n   subseg = now_subseg;\n   s3_pdr_seg = subseg_new (\".pdr\", (subsegT) 0);\n-  (void)bfd_set_section_flags (stdoutput, s3_pdr_seg, SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);\n-  (void)bfd_set_section_alignment (stdoutput, s3_pdr_seg, 2);\n+  bfd_set_section_flags (s3_pdr_seg, SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);\n+  bfd_set_section_alignment (s3_pdr_seg, 2);\n   subseg_set (seg, subseg);\n \n   if (s3_USE_GLOBAL_POINTER_OPT)\n@@ -7076,7 +7077,7 @@ s3_pcrel_from (fixS * fixP)\n static valueT\n s3_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "a615e149c9d1d72b9cd48c4f6f4f5b554cbda289",
      "filename": "gas/config/tc-score7.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-score7.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-score7.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-score7.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -5188,7 +5188,7 @@ s7_pic_need_relax (symbolS *sym, asection *segtype)\n   linkonce = FALSE;\n   if (symsec != segtype && ! S_IS_LOCAL (sym))\n     {\n-      if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE) != 0)\n+      if ((bfd_section_flags (symsec) & SEC_LINK_ONCE) != 0)\n \tlinkonce = TRUE;\n \n       /* The GNU toolchain uses an extension for ELF: a section\n@@ -5399,7 +5399,7 @@ static void\n s7_s_section (int ignore)\n {\n   obj_elf_section (ignore);\n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     record_alignment (now_seg, 2);\n \n }\n@@ -5422,14 +5422,14 @@ s7_s_change_sec (int sec)\n     {\n     case 'r':\n       seg = subseg_new (s7_RDATA_SECTION_NAME, (subsegT) get_absolute_expression ());\n-      bfd_set_section_flags (stdoutput, seg, (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_RELOC | SEC_DATA));\n+      bfd_set_section_flags (seg, (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_RELOC | SEC_DATA));\n       if (strcmp (TARGET_OS, \"elf\") != 0)\n         record_alignment (seg, 4);\n       demand_empty_rest_of_line ();\n       break;\n     case 's':\n       seg = subseg_new (\".sdata\", (subsegT) get_absolute_expression ());\n-      bfd_set_section_flags (stdoutput, seg, SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);\n+      bfd_set_section_flags (seg, SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);\n       if (strcmp (TARGET_OS, \"elf\") != 0)\n         record_alignment (seg, 4);\n       demand_empty_rest_of_line ();\n@@ -5540,7 +5540,7 @@ s7_s_score_ent (int aent)\n     s7_get_number ();\n \n #ifdef BFD_ASSEMBLER\n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     maybe_text = 1;\n   else\n     maybe_text = 0;\n@@ -5650,7 +5650,7 @@ s7_s_score_end (int x ATTRIBUTE_UNUSED)\n     p = NULL;\n \n #ifdef BFD_ASSEMBLER\n-  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)\n+  if ((bfd_section_flags (now_seg) & SEC_CODE) != 0)\n     maybe_text = 1;\n   else\n     maybe_text = 0;\n@@ -5993,7 +5993,7 @@ s7_s_score_lcomm (int bytes_p)\n           bss_seg = subseg_new (\".sbss\", 1);\n           seg_info (bss_seg)->bss = 1;\n #ifdef BFD_ASSEMBLER\n-          if (!bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))\n+          if (!bfd_set_section_flags (bss_seg, SEC_ALLOC))\n             as_warn (_(\"error setting flags for \\\".sbss\\\": %s\"), bfd_errmsg (bfd_get_error ()));\n #endif\n         }\n@@ -6152,8 +6152,8 @@ s7_begin (void)\n   seg = now_seg;\n   subseg = now_subseg;\n   s7_pdr_seg = subseg_new (\".pdr\", (subsegT) 0);\n-  (void) bfd_set_section_flags (stdoutput, s7_pdr_seg, SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);\n-  (void) bfd_set_section_alignment (stdoutput, s7_pdr_seg, 2);\n+  bfd_set_section_flags (s7_pdr_seg, SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);\n+  bfd_set_section_alignment (s7_pdr_seg, 2);\n   subseg_set (seg, subseg);\n \n   if (s7_USE_GLOBAL_POINTER_OPT)\n@@ -6628,7 +6628,7 @@ s7_pcrel_from (fixS * fixP)\n static valueT\n s7_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "c57f0661344baeee6b1efd3bbf78e663c908a072",
      "filename": "gas/config/tc-sh.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-sh.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3162,8 +3162,8 @@ md_section_align (segT seg ATTRIBUTE_UNUSED, valueT size)\n #ifdef OBJ_ELF\n   return size;\n #else /* ! OBJ_ELF */\n-  return ((size + (1 << bfd_get_section_alignment (stdoutput, seg)) - 1)\n-\t  & -(1 << bfd_get_section_alignment (stdoutput, seg)));\n+  return ((size + (1 << bfd_section_alignment (seg)) - 1)\n+\t  & -(1 << bfd_section_alignment (seg)));\n #endif /* ! OBJ_ELF */\n }\n "
    },
    {
      "sha": "4f7d675f60c74ce8eccaf7190ebcb39b76b97e9f",
      "filename": "gas/config/tc-sparc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-sparc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -4001,7 +4001,7 @@ tc_gen_reloc (asection *section, fixS *fixp)\n     }\n \n   /* Nothing is aligned in DWARF debugging sections.  */\n-  if (bfd_get_section_flags (stdoutput, section) & SEC_DEBUGGING)\n+  if (bfd_section_flags (section) & SEC_DEBUGGING)\n     switch (code)\n       {\n       case BFD_RELOC_16: code = BFD_RELOC_SPARC_UA16; break;"
    },
    {
      "sha": "bdb22e72ba79c23a7d52ae74cb47fd5f6d9ebf51",
      "filename": "gas/config/tc-spu.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-spu.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -904,7 +904,7 @@ tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)\n valueT\n md_section_align (segT seg, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   valueT mask = ((valueT) 1 << align) - 1;\n \n   return (size + mask) & ~mask;"
    },
    {
      "sha": "b5588b9c46716e3cb015f441a4e5f41d1eff808c",
      "filename": "gas/config/tc-tic4x.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tic4x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tic4x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic4x.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1001,9 +1001,9 @@ tic4x_sect (int x ATTRIBUTE_UNUSED)\n       symbol_set_frag (line_label, frag_now);\n     }\n \n-  if (bfd_get_section_flags (stdoutput, seg) == SEC_NO_FLAGS)\n+  if (bfd_section_flags (seg) == SEC_NO_FLAGS)\n     {\n-      if (!bfd_set_section_flags (stdoutput, seg, SEC_DATA))\n+      if (!bfd_set_section_flags (seg, SEC_DATA))\n \tas_warn (_(\"Error setting flags for \\\"%s\\\": %s\"), name,\n \t\t bfd_errmsg (bfd_get_error ()));\n     }\n@@ -1104,7 +1104,7 @@ tic4x_usect (int x ATTRIBUTE_UNUSED)\n       S_SET_VALUE (line_label, frag_now_fix ());\n     }\n   seg_info (seg)->bss = 1;\t/* Uninitialised data.  */\n-  if (!bfd_set_section_flags (stdoutput, seg, SEC_ALLOC))\n+  if (!bfd_set_section_flags (seg, SEC_ALLOC))\n     as_warn (_(\"Error setting flags for \\\"%s\\\": %s\"), name,\n \t     bfd_errmsg (bfd_get_error ()));\n   tic4x_seg_alloc (name, seg, size, line_label);"
    },
    {
      "sha": "72c8cf3967a24e34dcf33b59085ffcc95ff96e28",
      "filename": "gas/config/tc-tic54x.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tic54x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tic54x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic54x.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1391,7 +1391,7 @@ tic54x_usect (int x ATTRIBUTE_UNUSED)\n     blocking_flag = alignment_flag = 0;\n \n   seg = subseg_new (name, 0);\n-  flags = bfd_get_section_flags (stdoutput, seg) | SEC_ALLOC;\n+  flags = bfd_section_flags (seg) | SEC_ALLOC;\n \n   if (alignment_flag)\n     {\n@@ -1420,7 +1420,7 @@ tic54x_usect (int x ATTRIBUTE_UNUSED)\n   if (blocking_flag)\n     flags |= SEC_TIC54X_BLOCK;\n \n-  if (!bfd_set_section_flags (stdoutput, seg, flags))\n+  if (!bfd_set_section_flags (seg, flags))\n     as_warn (_(\"Error setting flags for \\\"%s\\\": %s\"), name,\n \t     bfd_errmsg (bfd_get_error ()));\n \n@@ -3977,12 +3977,12 @@ static void\n emit_insn (tic54x_insn *insn)\n {\n   int i;\n-  flagword oldflags = bfd_get_section_flags (stdoutput, now_seg);\n+  flagword oldflags = bfd_section_flags (now_seg);\n   flagword flags = oldflags | SEC_CODE;\n \n-  if (! bfd_set_section_flags (stdoutput, now_seg, flags))\n+  if (!bfd_set_section_flags (now_seg, flags))\n         as_warn (_(\"error setting flags for \\\"%s\\\": %s\"),\n-                 bfd_section_name (stdoutput, now_seg),\n+                 bfd_section_name (now_seg),\n                  bfd_errmsg (bfd_get_error ()));\n \n   for (i = 0; i < insn->words; i++)"
    },
    {
      "sha": "0433d9e409ed9724ff6675cc687309a70faa55bf",
      "filename": "gas/config/tc-tic6x.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic6x.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -781,7 +781,7 @@ md_begin (void)\n \n   /* This is copied from perform_an_assembly_pass.  */\n   applicable = bfd_applicable_section_flags (stdoutput);\n-  bfd_set_section_flags (stdoutput, sbss_section, applicable & SEC_ALLOC);\n+  bfd_set_section_flags (sbss_section, applicable & SEC_ALLOC);\n \n   subseg_set (seg, subseg);\n \n@@ -4483,7 +4483,7 @@ md_section_align (segT segment ATTRIBUTE_UNUSED,\n {\n   /* Round up section sizes to ensure that text sections consist of\n      whole fetch packets.  */\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & (-((valueT) 1 << align)));\n }\n "
    },
    {
      "sha": "788a9f3b462652616f15943428d0843e7d564926",
      "filename": "gas/config/tc-tilegx.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tilegx.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -262,7 +262,7 @@ md_begin (void)\n     as_warn (_(\"Could not set architecture and machine\"));\n \n   /* Guarantee text section is aligned.  */\n-  bfd_set_section_alignment (stdoutput, text_section,\n+  bfd_set_section_alignment (text_section,\n                              TILEGX_LOG2_BUNDLE_ALIGNMENT_IN_BYTES);\n \n   require_canonical_reg_names = 1;\n@@ -948,8 +948,8 @@ tilegx_flush_bundle (void)\n \n   /* If the section seems to have no alignment set yet, go ahead and\n      make it large enough to hold code.  */\n-  if (bfd_get_section_alignment (stdoutput, now_seg) == 0)\n-    bfd_set_section_alignment (stdoutput, now_seg,\n+  if (bfd_section_alignment (now_seg) == 0)\n+    bfd_set_section_alignment (now_seg,\n                                TILEGX_LOG2_BUNDLE_ALIGNMENT_IN_BYTES);\n \n   for (j = 0; j < current_bundle_index; j++)"
    },
    {
      "sha": "1c98a9335832c3217f30b3cbf24160e2d5daeac2",
      "filename": "gas/config/tc-tilepro.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tilepro.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -207,7 +207,7 @@ md_begin (void)\n   int i;\n \n   /* Guarantee text section is aligned.  */\n-  bfd_set_section_alignment (stdoutput, text_section,\n+  bfd_set_section_alignment (text_section,\n                              TILEPRO_LOG2_BUNDLE_ALIGNMENT_IN_BYTES);\n \n   require_canonical_reg_names = 1;\n@@ -838,8 +838,8 @@ tilepro_flush_bundle (void)\n \n   /* If the section seems to have no alignment set yet, go ahead and\n      make it large enough to hold code.  */\n-  if (bfd_get_section_alignment (stdoutput, now_seg) == 0)\n-    bfd_set_section_alignment (stdoutput, now_seg,\n+  if (bfd_section_alignment (now_seg) == 0)\n+    bfd_set_section_alignment (now_seg,\n                                TILEPRO_LOG2_BUNDLE_ALIGNMENT_IN_BYTES);\n \n   for (j = 0; j < current_bundle_index; j++)"
    },
    {
      "sha": "dfb43cbc16f3ee4ae4177eddd8fbed0fb8ccda2e",
      "filename": "gas/config/tc-v850.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-v850.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-v850.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-v850.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -229,7 +229,7 @@ do_v850_seg (int i, subsegT sub)\n   else\n     {\n       seg->s = subseg_new (seg->name, sub);\n-      bfd_set_section_flags (stdoutput, seg->s, seg->flags);\n+      bfd_set_section_flags (seg->s, seg->flags);\n       if ((seg->flags & SEC_LOAD) == 0)\n \tseg_info (seg->s)->bss = 1;\n     }\n@@ -1878,7 +1878,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n \n@@ -3740,8 +3740,8 @@ v850_md_end (void)\n   enum v850_notes id;\n \n   note_sec = subseg_new (V850_NOTE_SECNAME, 0);\n-  bfd_set_section_flags (stdoutput, note_sec, SEC_HAS_CONTENTS | SEC_READONLY | SEC_MERGE);\n-  bfd_set_section_alignment (stdoutput, note_sec, 2);\n+  bfd_set_section_flags (note_sec, SEC_HAS_CONTENTS | SEC_READONLY | SEC_MERGE);\n+  bfd_set_section_alignment (note_sec, 2);\n \n   /* Provide default values for all of the notes.  */\n   for (id = V850_NOTE_ALIGNMENT; id <= NUM_V850_NOTES; id++)"
    },
    {
      "sha": "fbf59c9e017e5c96d78ddc5d97b6a2d181ccfd4e",
      "filename": "gas/config/tc-visium.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-visium.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-visium.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-visium.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -222,7 +222,7 @@ visium_rdata (int xxx)\n valueT\n md_section_align (asection *seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n \n   return ((addr + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "3dc42f91df4829b5af66f5b21e2f9920f16e91cb",
      "filename": "gas/config/tc-wasm32.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-wasm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-wasm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-wasm32.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -177,7 +177,7 @@ md_begin (void)\n valueT\n md_section_align (asection * seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "23b9e687c864b7ee9a20369f86615781138ca80e",
      "filename": "gas/config/tc-xc16x.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-xc16x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-xc16x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xc16x.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -234,7 +234,7 @@ md_atof (int type, char *litP, int *sizeP)\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n   return ((size + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "4f92c24d0dfa3539f4964b6df12b00c50cfc1195",
      "filename": "gas/config/tc-xgate.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-xgate.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-xgate.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xgate.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -466,7 +466,7 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)\n valueT\n md_section_align (asection * seg, valueT addr)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   return ((addr + (1 << align) - 1) & -(1 << align));\n }\n "
    },
    {
      "sha": "1c708b63625f75be673aaa36a072f0db9cf3d55f",
      "filename": "gas/config/tc-xstormy16.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-xstormy16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-xstormy16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xstormy16.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -277,7 +277,7 @@ xstormy16_cgen_record_fixup_exp (fragS *              frag,\n valueT\n md_section_align (segT segment, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, segment);\n+  int align = bfd_section_alignment (segment);\n \n   return ((size + (1 << align) - 1) & -(1 << align));\n }"
    },
    {
      "sha": "c68128e2897c245647a90d64f210738e50e1394d",
      "filename": "gas/config/tc-xtensa.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-xtensa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-xtensa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xtensa.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -4115,7 +4115,7 @@ get_is_linkonce_section (bfd *abfd ATTRIBUTE_UNUSED, segT sec)\n {\n   flagword flags, link_once_flags;\n \n-  flags = bfd_get_section_flags (abfd, sec);\n+  flags = bfd_section_flags (sec);\n   link_once_flags = (flags & SEC_LINK_ONCE);\n \n   /* Flags might not be set yet.  */\n@@ -4980,7 +4980,7 @@ xtensa_mark_frags_for_org (void)\n       segment_info_type *seginfo;\n       fragS *fragP;\n       flagword flags;\n-      flags = bfd_get_section_flags (stdoutput, sec);\n+      flags = bfd_section_flags (sec);\n       if (flags & SEC_DEBUGGING)\n \tcontinue;\n       if (!(flags & SEC_ALLOC))\n@@ -5025,7 +5025,7 @@ xtensa_find_unmarked_state_frags (void)\n       segment_info_type *seginfo;\n       fragS *fragP;\n       flagword flags;\n-      flags = bfd_get_section_flags (stdoutput, sec);\n+      flags = bfd_section_flags (sec);\n       if (flags & SEC_DEBUGGING)\n \tcontinue;\n       if (!(flags & SEC_ALLOC))\n@@ -5073,7 +5073,7 @@ xtensa_find_unaligned_branch_targets (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t      asection *sec,\n \t\t\t\t      void *unused ATTRIBUTE_UNUSED)\n {\n-  flagword flags = bfd_get_section_flags (abfd, sec);\n+  flagword flags = bfd_section_flags (sec);\n   segment_info_type *seginfo = seg_info (sec);\n   fragS *frag = seginfo->frchainP->frch_root;\n \n@@ -5112,7 +5112,7 @@ xtensa_find_unaligned_loops (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t     asection *sec,\n \t\t\t     void *unused ATTRIBUTE_UNUSED)\n {\n-  flagword flags = bfd_get_section_flags (abfd, sec);\n+  flagword flags = bfd_section_flags (sec);\n   segment_info_type *seginfo = seg_info (sec);\n   fragS *frag = seginfo->frchainP->frch_root;\n   xtensa_isa isa = xtensa_default_isa;\n@@ -8941,7 +8941,7 @@ xtensa_add_config_info (void)\n   int sz;\n \n   info_sec = subseg_new (\".xtensa.info\", 0);\n-  bfd_set_section_flags (stdoutput, info_sec, SEC_HAS_CONTENTS | SEC_READONLY);\n+  bfd_set_section_flags (info_sec, SEC_HAS_CONTENTS | SEC_READONLY);\n \n   data = XNEWVEC (char, 100);\n   sprintf (data, \"USE_ABSOLUTE_LITERALS=%d\\nABI=%d\\n\",\n@@ -11682,8 +11682,8 @@ cache_literal_section (bfd_boolean use_abs_literals)\n \n       elf_group_name (seg) = group_name;\n \n-      bfd_set_section_flags (stdoutput, seg, flags);\n-      bfd_set_section_alignment (stdoutput, seg, 2);\n+      bfd_set_section_flags (seg, flags);\n+      bfd_set_section_alignment (seg, 2);\n     }\n \n   *pcached = seg;\n@@ -11814,7 +11814,7 @@ xtensa_create_property_segments (frag_predicate property_function,\n \t    num_recs++;\n \n \t  rec_size = num_recs * 8;\n-\t  bfd_set_section_size (stdoutput, sec, rec_size);\n+\t  bfd_set_section_size (sec, rec_size);\n \n \t  if (num_recs)\n \t    {\n@@ -11911,7 +11911,7 @@ xtensa_create_xproperty_segments (frag_flags_fn flag_fn,\n \t    num_recs++;\n \n \t  rec_size = num_recs * (8 + 4);\n-\t  bfd_set_section_size (stdoutput, sec, rec_size);\n+\t  bfd_set_section_size (sec, rec_size);\n \t  /* elf_section_data (sec)->this_hdr.sh_entsize = 12; */\n \n \t  if (num_recs)\n@@ -11955,7 +11955,7 @@ xtensa_create_xproperty_segments (frag_flags_fn flag_fn,\n static bfd_boolean\n exclude_section_from_property_tables (segT sec)\n {\n-  flagword flags = bfd_get_section_flags (stdoutput, sec);\n+  flagword flags = bfd_section_flags (sec);\n \n   /* Sections that don't contribute to the memory footprint are excluded.  */\n   if ((flags & SEC_DEBUGGING)"
    },
    {
      "sha": "68e1b761cd646b31aed30908b40a15d851a718e8",
      "filename": "gas/config/tc-z8k.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-z8k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/config/tc-z8k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-z8k.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1385,7 +1385,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,\n valueT\n md_section_align (segT seg, valueT size)\n {\n-  int align = bfd_get_section_alignment (stdoutput, seg);\n+  int align = bfd_section_alignment (seg);\n   valueT mask = ((valueT) 1 << align) - 1;\n \n   return (size + mask) & ~mask;"
    },
    {
      "sha": "388123fd2410f64546df069cf1cf0bb424fd3a8d",
      "filename": "gas/dw2gencfi.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/dw2gencfi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/dw2gencfi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/dw2gencfi.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -232,7 +232,7 @@ get_debugseg_name (segT seg, const char *base_name)\n   if (!seg)\n     return concat (base_name, NULL);\n \n-  name = bfd_get_section_name (stdoutput, seg);\n+  name = bfd_section_name (seg);\n \n   if (name == NULL || *name == 0)\n     return concat (base_name, NULL);\n@@ -281,7 +281,7 @@ is_now_linkonce_segment (void)\n   if (compact_eh)\n     return now_seg;\n \n-  if ((bfd_get_section_flags (stdoutput, now_seg)\n+  if ((bfd_section_flags (now_seg)\n        & (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD\n \t  | SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE\n \t  | SEC_LINK_DUPLICATES_SAME_CONTENTS)) != 0)\n@@ -306,16 +306,16 @@ make_debug_seg (segT cseg, char *name, int sflags)\n   if (!cseg)\n     flags = 0;\n   else\n-    flags = bfd_get_section_flags (stdoutput, cseg)\n-      & (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD\n-\t | SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE\n-\t | SEC_LINK_DUPLICATES_SAME_CONTENTS);\n+    flags = (bfd_section_flags (cseg)\n+\t     & (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD\n+\t\t| SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE\n+\t\t| SEC_LINK_DUPLICATES_SAME_CONTENTS));\n \n   /* Add standard section flags.  */\n   flags |= sflags;\n \n   /* Apply possibly linked once flags to new generated segment, too.  */\n-  if (!bfd_set_section_flags (stdoutput, r, flags))\n+  if (!bfd_set_section_flags (r, flags))\n     as_bad (_(\"bfd_set_section_flags: %s\"),\n \t    bfd_errmsg (bfd_get_error ()));\n \n@@ -1359,7 +1359,7 @@ get_cfi_seg (segT cseg, const char *base, flagword flags, int align)\n   else\n     {\n       cseg = subseg_new (base, 0);\n-      bfd_set_section_flags (stdoutput, cseg, flags);\n+      bfd_set_section_flags (cseg, flags);\n     }\n   record_alignment (cseg, align);\n   return cseg;"
    },
    {
      "sha": "90b47b02fc049a9655c5057439b98de82ef5b192",
      "filename": "gas/dwarf2dbg.c",
      "status": "modified",
      "additions": 9,
      "deletions": 14,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/dwarf2dbg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/dwarf2dbg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/dwarf2dbg.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -657,7 +657,7 @@ dwarf2_emit_label (symbolS *label)\n     return;\n   if (S_GET_SEGMENT (label) != now_seg)\n     return;\n-  if (!(bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE))\n+  if (!(bfd_section_flags (now_seg) & SEC_CODE))\n     return;\n   if (files_in_use == 0 && debug_type != DEBUG_DWARF2)\n     return;\n@@ -1594,7 +1594,7 @@ process_entries (segT seg, struct line_entry *e)\n \t that all of the sub-sections are merged into a proper\n \t .debug_line section before a debugger sees them.  */\n \n-      sec_name = bfd_get_section_name (stdoutput, seg);\n+      sec_name = bfd_section_name (seg);\n       if (strcmp (sec_name, \".text\") != 0)\n \t{\n \t  name = concat (\".debug_line\", sec_name, (char *) NULL);\n@@ -2238,7 +2238,7 @@ dwarf2_finish (void)\n \n   /* Create and switch to the line number section.  */\n   line_seg = subseg_new (\".debug_line\", 0);\n-  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY | SEC_DEBUGGING);\n+  bfd_set_section_flags (line_seg, SEC_READONLY | SEC_DEBUGGING);\n \n   /* For each subsection, chain the debug entries together.  */\n   for (s = all_segs; s; s = s->next)\n@@ -2284,15 +2284,11 @@ dwarf2_finish (void)\n       aranges_seg = subseg_new (\".debug_aranges\", 0);\n       str_seg = subseg_new (\".debug_str\", 0);\n \n-      bfd_set_section_flags (stdoutput, info_seg,\n-\t\t\t     SEC_READONLY | SEC_DEBUGGING);\n-      bfd_set_section_flags (stdoutput, abbrev_seg,\n-\t\t\t     SEC_READONLY | SEC_DEBUGGING);\n-      bfd_set_section_flags (stdoutput, aranges_seg,\n-\t\t\t     SEC_READONLY | SEC_DEBUGGING);\n-      bfd_set_section_flags (stdoutput, str_seg,\n-\t\t\t     (SEC_READONLY | SEC_DEBUGGING\n-\t\t\t      | SEC_MERGE | SEC_STRINGS));\n+      bfd_set_section_flags (info_seg, SEC_READONLY | SEC_DEBUGGING);\n+      bfd_set_section_flags (abbrev_seg, SEC_READONLY | SEC_DEBUGGING);\n+      bfd_set_section_flags (aranges_seg, SEC_READONLY | SEC_DEBUGGING);\n+      bfd_set_section_flags (str_seg, (SEC_READONLY | SEC_DEBUGGING\n+\t\t\t\t       | SEC_MERGE | SEC_STRINGS));\n       str_seg->entsize = 1;\n \n       record_alignment (aranges_seg, ffs (2 * sizeof_address) - 1);\n@@ -2302,8 +2298,7 @@ dwarf2_finish (void)\n       else\n \t{\n \t  ranges_seg = subseg_new (\".debug_ranges\", 0);\n-\t  bfd_set_section_flags (stdoutput, ranges_seg,\n-\t\t\t\t SEC_READONLY | SEC_DEBUGGING);\n+\t  bfd_set_section_flags (ranges_seg, SEC_READONLY | SEC_DEBUGGING);\n \t  record_alignment (ranges_seg, ffs (2 * sizeof_address) - 1);\n \t  out_debug_ranges (ranges_seg);\n \t}"
    },
    {
      "sha": "bacc89fe3af6e8611f39fea88f229c6b4e0878f7",
      "filename": "gas/ecoff.c",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/ecoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/ecoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ecoff.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3700,8 +3700,7 @@ ecoff_build_lineno (const struct ecoff_debug_swap *backend,\n       && first_proc_ptr != (proc_t *) NULL\n       && local_first_lineno != (lineno_list_t *) NULL\n       && ((S_GET_VALUE (first_proc_ptr->sym->as_sym)\n-\t   + bfd_get_section_vma (stdoutput,\n-\t\t\t\t  S_GET_SEGMENT (first_proc_ptr->sym->as_sym)))\n+\t   + bfd_section_vma (S_GET_SEGMENT (first_proc_ptr->sym->as_sym)))\n \t  != 0))\n     {\n       first.file = local_first_lineno->file;\n@@ -3981,8 +3980,7 @@ ecoff_build_symbols (const struct ecoff_debug_swap *backend,\n \t\t      else\n \t\t\tsym_ptr->ecoff_sym.asym.value =\n \t\t\t  (S_GET_VALUE (as_sym)\n-\t\t\t   + bfd_get_section_vma (stdoutput,\n-\t\t\t\t\t\t  S_GET_SEGMENT (as_sym))\n+\t\t\t   + bfd_section_vma (S_GET_SEGMENT (as_sym))\n \t\t\t   + sym_ptr->addend);\n \n \t\t      sym_ptr->ecoff_sym.weakext = S_IS_WEAK (as_sym);\n@@ -4310,8 +4308,7 @@ ecoff_build_procs (const struct ecoff_debug_swap *backend,\n \n \t\t  adr_sym = proc_ptr->sym->as_sym;\n \t\t  adr = (S_GET_VALUE (adr_sym)\n-\t\t\t + bfd_get_section_vma (stdoutput,\n-\t\t\t\t\t\tS_GET_SEGMENT (adr_sym)));\n+\t\t\t + bfd_section_vma (S_GET_SEGMENT (adr_sym)));\n \t\t  if (first)\n \t\t    {\n \t\t      /* This code used to force the adr of the very"
    },
    {
      "sha": "e53dd0232d9caecd5868aab4cb1d0cfbf76b949b",
      "filename": "gas/read.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/read.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -742,7 +742,7 @@ assemble_one (char *line)\n static bfd_boolean\n in_bss (void)\n {\n-  flagword flags = bfd_get_section_flags (stdoutput, now_seg);\n+  flagword flags = bfd_section_flags (now_seg);\n \n   return (flags & SEC_ALLOC) && !(flags & (SEC_LOAD | SEC_HAS_CONTENTS));\n }\n@@ -2419,7 +2419,7 @@ s_linkonce (int ignore ATTRIBUTE_UNUSED)\n     if ((bfd_applicable_section_flags (stdoutput) & SEC_LINK_ONCE) == 0)\n       as_warn (_(\".linkonce is not supported for this object file format\"));\n \n-    flags = bfd_get_section_flags (stdoutput, now_seg);\n+    flags = bfd_section_flags (now_seg);\n     flags |= SEC_LINK_ONCE;\n     switch (type)\n       {\n@@ -2438,7 +2438,7 @@ s_linkonce (int ignore ATTRIBUTE_UNUSED)\n \tflags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;\n \tbreak;\n       }\n-    if (!bfd_set_section_flags (stdoutput, now_seg, flags))\n+    if (!bfd_set_section_flags (now_seg, flags))\n       as_bad (_(\"bfd_set_section_flags: %s\"),\n \t      bfd_errmsg (bfd_get_error ()));\n   }\n@@ -2464,7 +2464,7 @@ bss_alloc (symbolS *symbolP, addressT size, unsigned int align)\n \t{\n \t  bss_seg = subseg_new (\".sbss\", 1);\n \t  seg_info (bss_seg)->bss = 1;\n-\t  if (!bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))\n+\t  if (!bfd_set_section_flags (bss_seg, SEC_ALLOC))\n \t    as_warn (_(\"error setting flags for \\\".sbss\\\": %s\"),\n \t\t     bfd_errmsg (bfd_get_error ()));\n \t}\n@@ -2957,9 +2957,9 @@ s_mri_sect (char *type ATTRIBUTE_UNUSED)\n \t  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_READONLY | SEC_ROM;\n \tif (flags != SEC_NO_FLAGS)\n \t  {\n-\t    if (!bfd_set_section_flags (stdoutput, seg, flags))\n+\t    if (!bfd_set_section_flags (seg, flags))\n \t      as_warn (_(\"error setting flags for \\\"%s\\\": %s\"),\n-\t\t       bfd_section_name (stdoutput, seg),\n+\t\t       bfd_section_name (seg),\n \t\t       bfd_errmsg (bfd_get_error ()));\n \t  }\n       }"
    },
    {
      "sha": "0217c422ec3a7715bb985f508abda5c5af46e92e",
      "filename": "gas/stabs.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/stabs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/stabs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/stabs.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -109,7 +109,7 @@ get_stab_string_offset (const char *string, const char *stabstr_secname,\n       p = frag_more (1);\n       *p = 0;\n       retval = seg_info (seg)->stabu.stab_string_size = 1;\n-      bfd_set_section_flags (stdoutput, seg, SEC_READONLY | SEC_DEBUGGING);\n+      bfd_set_section_flags (seg, SEC_READONLY | SEC_DEBUGGING);\n     }\n \n   if (length > 0)\n@@ -336,7 +336,7 @@ s_stab_generic (int what,\n \n       if (! seg_info (seg)->hadone)\n \t{\n-\t  bfd_set_section_flags (stdoutput, seg,\n+\t  bfd_set_section_flags (seg,\n \t\t\t\t SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);\n #ifdef INIT_STAB_SECTION\n \t  INIT_STAB_SECTION (seg);"
    },
    {
      "sha": "d438a10c696fee1511a34ed7ce96425c09744313",
      "filename": "gas/subsegs.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/subsegs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/subsegs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/subsegs.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -65,7 +65,7 @@ subseg_change (segT seg, int subseg)\n     {\n       seginfo = XCNEW (segment_info_type);\n       seginfo->bfd_section = seg;\n-      bfd_set_section_userdata (stdoutput, seg, seginfo);\n+      bfd_set_section_userdata (seg, seginfo);\n     }\n }\n \f\n@@ -146,9 +146,7 @@ subseg_get (const char *segname, int force_new)\n {\n   segT secptr;\n   segment_info_type *seginfo;\n-  const char *now_seg_name = (now_seg\n-\t\t\t      ? bfd_get_section_name (stdoutput, now_seg)\n-\t\t\t      : 0);\n+  const char *now_seg_name = now_seg ? bfd_section_name (now_seg) : 0;\n \n   if (!force_new\n       && now_seg_name\n@@ -167,7 +165,7 @@ subseg_get (const char *segname, int force_new)\n       secptr->output_section = secptr;\n       seginfo = XCNEW (segment_info_type);\n       seginfo->bfd_section = secptr;\n-      bfd_set_section_userdata (stdoutput, secptr, seginfo);\n+      bfd_set_section_userdata (secptr, seginfo);\n     }\n   return secptr;\n }\n@@ -260,7 +258,7 @@ section_symbol (segT sec)\n int\n subseg_text_p (segT sec)\n {\n-  return (bfd_get_section_flags (stdoutput, sec) & SEC_CODE) != 0;\n+  return (bfd_section_flags (sec) & SEC_CODE) != 0;\n }\n \n /* Return non zero if SEC has at least one byte of data.  It is"
    },
    {
      "sha": "2a956026fefe79179029485013d509d178401766",
      "filename": "gas/subsegs.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/subsegs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/subsegs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/subsegs.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -112,7 +112,7 @@ typedef struct segment_info_struct {\n \n \n #define seg_info(sec) \\\n-  ((segment_info_type *) bfd_get_section_userdata (stdoutput, sec))\n+  ((segment_info_type *) bfd_section_userdata (sec))\n \n extern symbolS *section_symbol (segT);\n "
    },
    {
      "sha": "9b5ae6ff32a3b43453bdf03da62bbb12adda569c",
      "filename": "gas/write.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gas/write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/write.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -359,8 +359,8 @@ record_alignment (/* Segment to which alignment pertains.  */\n   if (seg == absolute_section)\n     return;\n \n-  if (align > bfd_get_section_alignment (stdoutput, seg))\n-    bfd_set_section_alignment (stdoutput, seg, align);\n+  if (align > bfd_section_alignment (seg))\n+    bfd_set_section_alignment (seg, align);\n }\n \n int\n@@ -369,7 +369,7 @@ get_recorded_alignment (segT seg)\n   if (seg == absolute_section)\n     return 0;\n \n-  return bfd_get_section_alignment (stdoutput, seg);\n+  return bfd_section_alignment (seg);\n }\n \n /* Reset the section indices after removing the gas created sections.  */\n@@ -555,7 +555,7 @@ relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx)\n }\n \n static void\n-size_seg (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n+size_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n {\n   flagword flags;\n   fragS *fragp;\n@@ -580,16 +580,16 @@ size_seg (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n   else\n     size = 0;\n \n-  flags = bfd_get_section_flags (abfd, sec);\n-  if (size == 0 && bfd_get_section_size (sec) != 0 &&\n+  flags = bfd_section_flags (sec);\n+  if (size == 0 && bfd_section_size (sec) != 0 &&\n     (flags & SEC_HAS_CONTENTS) != 0)\n     return;\n \n   if (size > 0 && ! seginfo->bss)\n     flags |= SEC_HAS_CONTENTS;\n \n   flags &= ~SEC_RELOC;\n-  x = bfd_set_section_flags (abfd, sec, flags);\n+  x = bfd_set_section_flags (sec, flags);\n   gas_assert (x);\n \n   /* If permitted, allow the backend to pad out the section\n@@ -598,7 +598,7 @@ size_seg (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n     newsize = size;\n   else\n     newsize = md_section_align (sec, size);\n-  x = bfd_set_section_size (abfd, sec, newsize);\n+  x = bfd_set_section_size (sec, newsize);\n   gas_assert (x);\n \n   /* If the size had to be rounded up, add some padding in the last\n@@ -1215,7 +1215,8 @@ get_frag_for_reloc (fragS *last_frag,\n }\n \n static void\n-write_relocs (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n+write_relocs (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,\n+\t      void *xxx ATTRIBUTE_UNUSED)\n {\n   segment_info_type *seginfo = seg_info (sec);\n   unsigned int n;\n@@ -1345,9 +1346,9 @@ write_relocs (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n \n   if (n)\n     {\n-      flagword flags = bfd_get_section_flags (abfd, sec);\n+      flagword flags = bfd_section_flags (sec);\n       flags |= SEC_RELOC;\n-      bfd_set_section_flags (abfd, sec, flags);\n+      bfd_set_section_flags (sec, flags);\n       bfd_set_reloc (stdoutput, sec, relocs, n);\n     }\n \n@@ -1433,15 +1434,15 @@ compress_debug (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n   char *header;\n   struct z_stream_s *strm;\n   int x;\n-  flagword flags = bfd_get_section_flags (abfd, sec);\n+  flagword flags = bfd_section_flags (sec);\n   unsigned int header_size, compression_header_size;\n \n   if (seginfo == NULL\n       || sec->size < 32\n       || (flags & (SEC_ALLOC | SEC_HAS_CONTENTS)) == SEC_ALLOC)\n     return;\n \n-  section_name = bfd_get_section_name (stdoutput, sec);\n+  section_name = bfd_section_name (sec);\n   if (strncmp (section_name, \".debug_\", 7) != 0)\n     return;\n \n@@ -1565,12 +1566,12 @@ compress_debug (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)\n \n   /* Update the section size and its name.  */\n   bfd_update_compression_header (abfd, (bfd_byte *) header, sec);\n-  x = bfd_set_section_size (abfd, sec, compressed_size);\n+  x = bfd_set_section_size (sec, compressed_size);\n   gas_assert (x);\n   if (!compression_header_size)\n     {\n       compressed_name = concat (\".z\", section_name + 1, (char *) NULL);\n-      bfd_section_name (stdoutput, sec) = compressed_name;\n+      bfd_rename_section (sec, compressed_name);\n     }\n }\n \n@@ -1599,7 +1600,7 @@ write_contents (bfd *abfd ATTRIBUTE_UNUSED,\n \n   /* Write out the frags.  */\n   if (seginfo == NULL\n-      || !(bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS))\n+      || !(bfd_section_flags (sec) & SEC_HAS_CONTENTS))\n     return;\n \n   for (f = seginfo->frchainP->frch_root;\n@@ -1815,7 +1816,7 @@ subsegs_finish_section (asection *s)\n \tdo_not_pad_sections_to_alignment = 1;\n \n       alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);\n-      if ((bfd_get_section_flags (now_seg->owner, now_seg) & SEC_MERGE)\n+      if ((bfd_section_flags (now_seg) & SEC_MERGE)\n \t  && now_seg->entsize)\n \t{\n \t  unsigned int entsize = now_seg->entsize;\n@@ -1875,7 +1876,7 @@ create_obj_attrs_section (void)\n   s = subseg_new (name, 0);\n   elf_section_type (s)\n     = get_elf_backend_data (stdoutput)->obj_attrs_section_type;\n-  bfd_set_section_flags (stdoutput, s, SEC_READONLY | SEC_DATA);\n+  bfd_set_section_flags (s, SEC_READONLY | SEC_DATA);\n   frag_now_fix ();\n   p = frag_more (size);\n   bfd_elf_set_obj_attr_contents (stdoutput, (bfd_byte *)p, size);\n@@ -1959,9 +1960,8 @@ maybe_generate_build_notes (void)\n   /* Create a GNU Build Attribute section.  */\n   sec = subseg_new (GNU_BUILD_ATTRS_SECTION_NAME, FALSE);\n   elf_section_type (sec) = SHT_NOTE;\n-  bfd_set_section_flags (stdoutput, sec,\n-\t\t\t SEC_READONLY | SEC_HAS_CONTENTS | SEC_DATA);\n-  bfd_set_section_alignment (stdoutput, sec, 2);\n+  bfd_set_section_flags (sec, SEC_READONLY | SEC_HAS_CONTENTS | SEC_DATA);\n+  bfd_set_section_alignment (sec, 2);\n \n   /* Work out the size of the notes that we will create,\n      and the relocation we should use.  */\n@@ -2041,7 +2041,7 @@ maybe_generate_build_notes (void)\n \n \t/* ...and another one to install the end address.  */\n \tcreate_note_reloc (sec, sym, total_size, desc2_offset, desc_reloc,\n-\t\t\t   bfd_get_section_size (bsym->section),\n+\t\t\t   bfd_section_size (bsym->section),\n \t\t\t   note);\n \n \ttotal_size += note_size;"
    },
    {
      "sha": "7057e37e8da8e7dae9f744d0a7ffba5388a24017",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,26 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* aarch64-linux-tdep.c, * arm-tdep.c, * auto-load.c,\n+\t* coff-pe-read.c, * coffread.c, * corelow.c, * dbxread.c,\n+\t* dicos-tdep.c, * dwarf2-frame.c, * dwarf2read.c, * elfread.c,\n+\t* exec.c, * fbsd-tdep.c, * gcore.c, * gdb_bfd.c, * gdb_bfd.h,\n+\t* hppa-tdep.c, * i386-cygwin-tdep.c, * i386-fbsd-tdep.c,\n+\t* i386-linux-tdep.c, * jit.c, * linux-tdep.c, * machoread.c,\n+\t* maint.c, * mdebugread.c, * minidebug.c, * mips-linux-tdep.c,\n+\t* mips-sde-tdep.c, * mips-tdep.c, * mipsread.c, * nto-tdep.c,\n+\t* objfiles.c, * objfiles.h, * osabi.c, * ppc-linux-tdep.c,\n+\t* ppc64-tdep.c, * record-btrace.c, * record-full.c, * remote.c,\n+\t* rs6000-aix-tdep.c, * rs6000-tdep.c, * s390-linux-tdep.c,\n+\t* s390-tdep.c, * solib-aix.c, * solib-dsbt.c, * solib-frv.c,\n+\t* solib-spu.c, * solib-svr4.c, * solib-target.c,\n+\t* spu-linux-nat.c, * spu-tdep.c, * symfile-mem.c, * symfile.c,\n+\t* symmisc.c, * symtab.c, * target.c, * windows-nat.c,\n+\t* xcoffread.c, * cli/cli-dump.c, * compile/compile-object-load.c,\n+\t* mi/mi-interp.c: Update throughout for bfd section macro and\n+\tfunction changes.\n+\t* gcore (gcore_create_callback): Use bfd_set_section_lma.\n+\t* spu-tdep.c (spu_overlay_new_objfile): Likewise.\n+\n 2019-09-18  Tom Tromey  <tom@tromey.com>\n \n \t* NEWS: Add entry."
    },
    {
      "sha": "a375c3b137d657faf22bf9c041e84e3f07ba404f",
      "filename": "gdb/aarch64-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/aarch64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/aarch64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -452,7 +452,7 @@ aarch64_linux_core_read_vq (struct gdbarch *gdbarch, bfd *abfd)\n       return 0;\n     }\n \n-  size_t size = bfd_section_size (abfd, sve_section);\n+  size_t size = bfd_section_size (sve_section);\n \n   /* Check extended state size.  */\n   if (size < SVE_HEADER_SIZE)"
    },
    {
      "sha": "e17550fed7727d958e594b8a6c56eb7ee2c3812c",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2009,12 +2009,11 @@ arm_obj_section_from_vma (struct objfile *objfile, bfd_vma vma)\n   struct obj_section *osect;\n \n   ALL_OBJFILE_OSECTIONS (objfile, osect)\n-    if (bfd_get_section_flags (objfile->obfd,\n-\t\t\t       osect->the_bfd_section) & SEC_ALLOC)\n+    if (bfd_section_flags (osect->the_bfd_section) & SEC_ALLOC)\n       {\n \tbfd_vma start, size;\n-\tstart = bfd_get_section_vma (objfile->obfd, osect->the_bfd_section);\n-\tsize = bfd_get_section_size (osect->the_bfd_section);\n+\tstart = bfd_section_vma (osect->the_bfd_section);\n+\tsize = bfd_section_size (osect->the_bfd_section);\n \n \tif (start <= vma && vma < start + size)\n \t  return osect;\n@@ -2054,8 +2053,8 @@ arm_exidx_new_objfile (struct objfile *objfile)\n   gdb::byte_vector exidx_data;\n   if (exidx)\n     {\n-      exidx_vma = bfd_section_vma (objfile->obfd, exidx);\n-      exidx_data.resize (bfd_get_section_size (exidx));\n+      exidx_vma = bfd_section_vma (exidx);\n+      exidx_data.resize (bfd_section_size (exidx));\n \n       if (!bfd_get_section_contents (objfile->obfd, exidx,\n \t\t\t\t     exidx_data.data (), 0,\n@@ -2067,8 +2066,8 @@ arm_exidx_new_objfile (struct objfile *objfile)\n   gdb::byte_vector extab_data;\n   if (extab)\n     {\n-      extab_vma = bfd_section_vma (objfile->obfd, extab);\n-      extab_data.resize (bfd_get_section_size (extab));\n+      extab_vma = bfd_section_vma (extab);\n+      extab_data.resize (bfd_section_size (extab));\n \n       if (!bfd_get_section_contents (objfile->obfd, extab,\n \t\t\t\t     extab_data.data (), 0,\n@@ -2100,7 +2099,7 @@ arm_exidx_new_objfile (struct objfile *objfile)\n       sec = arm_obj_section_from_vma (objfile, idx);\n       if (sec == NULL)\n \tcontinue;\n-      idx -= bfd_get_section_vma (objfile->obfd, sec->the_bfd_section);\n+      idx -= bfd_section_vma (sec->the_bfd_section);\n \n       /* Determine address of exception table entry.  */\n       if (val == 1)"
    },
    {
      "sha": "136d53ffe137c4d7ba6f45bcbdffe44e365348c9",
      "filename": "gdb/auto-load.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/auto-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/auto-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/auto-load.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1116,7 +1116,7 @@ auto_load_section_scripts (struct objfile *objfile, const char *section_name)\n \n   scripts_sect = bfd_get_section_by_name (abfd, section_name);\n   if (scripts_sect == NULL\n-      || (bfd_get_section_flags (abfd, scripts_sect) & SEC_HAS_CONTENTS) == 0)\n+      || (bfd_section_flags (scripts_sect) & SEC_HAS_CONTENTS) == 0)\n     return;\n \n   if (!bfd_get_full_section_contents (abfd, scripts_sect, &data))\n@@ -1128,7 +1128,7 @@ auto_load_section_scripts (struct objfile *objfile, const char *section_name)\n \n       char *p = (char *) data;\n       source_section_scripts (objfile, section_name, p,\n-\t\t\t      p + bfd_get_section_size (scripts_sect));\n+\t\t\t      p + bfd_section_size (scripts_sect));\n     }\n }\n "
    },
    {
      "sha": "74e0057d4aba08ec8230051cfceea376710f7a5a",
      "filename": "gdb/cli/cli-dump.c",
      "status": "modified",
      "additions": 9,
      "deletions": 11,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/cli/cli-dump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/cli/cli-dump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-dump.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -163,12 +163,10 @@ dump_bfd_file (const char *filename, const char *mode,\n \n   gdb_bfd_ref_ptr obfd (bfd_openw_or_error (filename, target, mode));\n   osection = bfd_make_section_anyway (obfd.get (), \".newsec\");\n-  bfd_set_section_size (obfd.get (), osection, len);\n-  bfd_set_section_vma (obfd.get (), osection, vaddr);\n-  bfd_set_section_alignment (obfd.get (), osection, 0);\n-  bfd_set_section_flags (obfd.get (), osection, (SEC_HAS_CONTENTS\n-\t\t\t\t\t\t | SEC_ALLOC\n-\t\t\t\t\t\t | SEC_LOAD));\n+  bfd_set_section_size (osection, len);\n+  bfd_set_section_vma (osection, vaddr);\n+  bfd_set_section_alignment (osection, 0);\n+  bfd_set_section_flags (osection, (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD));\n   osection->entsize = 0;\n   if (!bfd_set_section_contents (obfd.get (), osection, buf, 0, len))\n     warning (_(\"writing dump file '%s' (%s)\"), filename,\n@@ -403,15 +401,15 @@ static void\n restore_section_callback (bfd *ibfd, asection *isec, void *args)\n {\n   struct callback_data *data = (struct callback_data *) args;\n-  bfd_vma sec_start  = bfd_section_vma (ibfd, isec);\n-  bfd_size_type size = bfd_section_size (ibfd, isec);\n+  bfd_vma sec_start  = bfd_section_vma (isec);\n+  bfd_size_type size = bfd_section_size (isec);\n   bfd_vma sec_end    = sec_start + size;\n   bfd_size_type sec_offset = 0;\n   bfd_size_type sec_load_count = size;\n   int ret;\n \n   /* Ignore non-loadable sections, eg. from elf files.  */\n-  if (!(bfd_get_section_flags (ibfd, isec) & SEC_LOAD))\n+  if (!(bfd_section_flags (isec) & SEC_LOAD))\n     return;\n \n   /* Does the section overlap with the desired restore range? */\n@@ -420,7 +418,7 @@ restore_section_callback (bfd *ibfd, asection *isec, void *args)\n     {\n       /* No, no useable data in this section.  */\n       printf_filtered (_(\"skipping section %s...\\n\"), \n-\t\t       bfd_section_name (ibfd, isec));\n+\t\t       bfd_section_name (isec));\n       return;\n     }\n \n@@ -441,7 +439,7 @@ restore_section_callback (bfd *ibfd, asection *isec, void *args)\n \t   bfd_errmsg (bfd_get_error ()));\n \n   printf_filtered (\"Restoring section %s (0x%lx to 0x%lx)\",\n-\t\t   bfd_section_name (ibfd, isec), \n+\t\t   bfd_section_name (isec), \n \t\t   (unsigned long) sec_start, \n \t\t   (unsigned long) sec_end);\n "
    },
    {
      "sha": "fe74d26cab3e66267b5327f1a6aee1d29b2d905b",
      "filename": "gdb/coff-pe-read.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/coff-pe-read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/coff-pe-read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coff-pe-read.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -136,7 +136,7 @@ get_section_vmas (bfd *abfd, asection *sectp, void *context)\n          bfd_get_section_vma() within memory.  Store the offset.  */\n \n       sections[sectix].vma_offset\n-\t= bfd_get_section_vma (abfd, sectp) - sections[sectix].rva_start;\n+\t= bfd_section_vma (sectp) - sections[sectix].rva_start;\n     }\n }\n \f"
    },
    {
      "sha": "c44b69069e4c0a2ce35dcb4b85a3edc1798fbb03",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -222,15 +222,15 @@ coff_locate_sections (bfd *abfd, asection *sectp, void *csip)\n   const char *name;\n \n   csi = (struct coff_symfile_info *) csip;\n-  name = bfd_get_section_name (abfd, sectp);\n+  name = bfd_section_name (sectp);\n   if (strcmp (name, \".text\") == 0)\n     {\n-      csi->textaddr = bfd_section_vma (abfd, sectp);\n-      csi->textsize += bfd_section_size (abfd, sectp);\n+      csi->textaddr = bfd_section_vma (sectp);\n+      csi->textsize += bfd_section_size (sectp);\n     }\n   else if (startswith (name, \".text\"))\n     {\n-      csi->textsize += bfd_section_size (abfd, sectp);\n+      csi->textsize += bfd_section_size (sectp);\n     }\n   else if (strcmp (name, \".stabstr\") == 0)\n     {\n@@ -307,7 +307,7 @@ cs_section_address (struct coff_symbol *cs, bfd *abfd)\n   args.resultp = &sect;\n   bfd_map_over_sections (abfd, find_targ_sec, &args);\n   if (sect != NULL)\n-    addr = bfd_get_section_vma (abfd, sect);\n+    addr = bfd_section_vma (sect);\n   return addr;\n }\n \n@@ -692,7 +692,7 @@ coff_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n          bfd_get_section_contents?  */\n       bfd_seek (abfd, abfd->where, 0);\n \n-      stabstrsize = bfd_section_size (abfd, info->stabstrsect);\n+      stabstrsize = bfd_section_size (info->stabstrsect);\n \n       coffstab_build_psymtabs (objfile,\n \t\t\t       info->textaddr, info->textsize,"
    },
    {
      "sha": "a30c55730387951588afb07a9acb38d9762daeb5",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 24,
      "deletions": 25,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -99,30 +99,30 @@ setup_sections (bfd *abfd, asection *sect, void *data_voidp)\n       if (sect->output_section == NULL)\n \tsect->output_section = sect;\n \n-      if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)\n+      if ((bfd_section_flags (sect) & SEC_ALLOC) == 0)\n \treturn;\n \n       /* Make the memory always readable.  */\n       prot = GDB_MMAP_PROT_READ;\n-      if ((bfd_get_section_flags (abfd, sect) & SEC_READONLY) == 0)\n+      if ((bfd_section_flags (sect) & SEC_READONLY) == 0)\n \tprot |= GDB_MMAP_PROT_WRITE;\n-      if ((bfd_get_section_flags (abfd, sect) & SEC_CODE) != 0)\n+      if ((bfd_section_flags (sect) & SEC_CODE) != 0)\n \tprot |= GDB_MMAP_PROT_EXEC;\n \n       if (compile_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"module \\\"%s\\\" section \\\"%s\\\" size %s prot %u\\n\",\n \t\t\t    bfd_get_filename (abfd),\n-\t\t\t    bfd_get_section_name (abfd, sect),\n+\t\t\t    bfd_section_name (sect),\n \t\t\t    paddress (target_gdbarch (),\n-\t\t\t\t      bfd_get_section_size (sect)),\n+\t\t\t\t      bfd_section_size (sect)),\n \t\t\t    prot);\n     }\n   else\n     prot = -1;\n \n   if (sect == NULL\n-      || (data->last_prot != prot && bfd_get_section_size (sect) != 0))\n+      || (data->last_prot != prot && bfd_section_size (sect) != 0))\n     {\n       CORE_ADDR addr;\n       asection *sect_iter;\n@@ -150,9 +150,8 @@ setup_sections (bfd *abfd, asection *sect, void *data_voidp)\n \n       for (sect_iter = data->last_section_first; sect_iter != sect;\n \t   sect_iter = sect_iter->next)\n-\tif ((bfd_get_section_flags (abfd, sect_iter) & SEC_ALLOC) != 0)\n-\t  bfd_set_section_vma (abfd, sect_iter,\n-\t\t\t       addr + bfd_get_section_vma (abfd, sect_iter));\n+\tif ((bfd_section_flags (sect_iter) & SEC_ALLOC) != 0)\n+\t  bfd_set_section_vma (sect_iter, addr + bfd_section_vma (sect_iter));\n \n       data->last_size = 0;\n       data->last_section_first = sect;\n@@ -163,14 +162,14 @@ setup_sections (bfd *abfd, asection *sect, void *data_voidp)\n   if (sect == NULL)\n     return;\n \n-  alignment = ((CORE_ADDR) 1) << bfd_get_section_alignment (abfd, sect);\n+  alignment = ((CORE_ADDR) 1) << bfd_section_alignment (sect);\n   data->last_max_alignment = std::max (data->last_max_alignment, alignment);\n \n   data->last_size = (data->last_size + alignment - 1) & -alignment;\n \n-  bfd_set_section_vma (abfd, sect, data->last_size);\n+  bfd_set_section_vma (sect, data->last_size);\n \n-  data->last_size += bfd_get_section_size (sect);\n+  data->last_size += bfd_section_size (sect);\n   data->last_size = (data->last_size + alignment - 1) & -alignment;\n }\n \n@@ -197,7 +196,7 @@ link_callbacks_warning (struct bfd_link_info *link_info, const char *xwarning,\n \t\t\tbfd_vma address)\n {\n   warning (_(\"Compiled module \\\"%s\\\" section \\\"%s\\\": warning: %s\"),\n-\t   bfd_get_filename (abfd), bfd_get_section_name (abfd, section),\n+\t   bfd_get_filename (abfd), bfd_section_name (section),\n \t   xwarning);\n }\n \n@@ -210,7 +209,7 @@ link_callbacks_undefined_symbol (struct bfd_link_info *link_info,\n {\n   warning (_(\"Cannot resolve relocation to \\\"%s\\\" \"\n \t     \"from compiled module \\\"%s\\\" section \\\"%s\\\".\"),\n-\t   name, bfd_get_filename (abfd), bfd_get_section_name (abfd, section));\n+\t   name, bfd_get_filename (abfd), bfd_section_name (section));\n }\n \n /* Helper for link_callbacks callbacks vector.  */\n@@ -233,7 +232,7 @@ link_callbacks_reloc_dangerous (struct bfd_link_info *link_info,\n {\n   warning (_(\"Compiled module \\\"%s\\\" section \\\"%s\\\": dangerous \"\n \t     \"relocation: %s\\n\"),\n-\t   bfd_get_filename (abfd), bfd_get_section_name (abfd, section),\n+\t   bfd_get_filename (abfd), bfd_section_name (section),\n \t   message);\n }\n \n@@ -246,7 +245,7 @@ link_callbacks_unattached_reloc (struct bfd_link_info *link_info,\n {\n   warning (_(\"Compiled module \\\"%s\\\" section \\\"%s\\\": unattached \"\n \t     \"relocation: %s\\n\"),\n-\t   bfd_get_filename (abfd), bfd_get_section_name (abfd, section),\n+\t   bfd_get_filename (abfd), bfd_section_name (section),\n \t   name);\n }\n \n@@ -324,11 +323,11 @@ copy_sections (bfd *abfd, asection *sect, void *data)\n   struct bfd_link_order link_order;\n   CORE_ADDR inferior_addr;\n \n-  if ((bfd_get_section_flags (abfd, sect) & (SEC_ALLOC | SEC_LOAD))\n+  if ((bfd_section_flags (sect) & (SEC_ALLOC | SEC_LOAD))\n       != (SEC_ALLOC | SEC_LOAD))\n     return;\n \n-  if (bfd_get_section_size (sect) == 0)\n+  if (bfd_section_size (sect) == 0)\n     return;\n \n   /* Mostly a copy of bfd_simple_get_relocated_section_contents which GDB\n@@ -349,11 +348,11 @@ copy_sections (bfd *abfd, asection *sect, void *data)\n   link_order.next = NULL;\n   link_order.type = bfd_indirect_link_order;\n   link_order.offset = 0;\n-  link_order.size = bfd_get_section_size (sect);\n+  link_order.size = bfd_section_size (sect);\n   link_order.u.indirect.section = sect;\n \n   gdb::unique_xmalloc_ptr<gdb_byte> sect_data\n-    ((bfd_byte *) xmalloc (bfd_get_section_size (sect)));\n+    ((bfd_byte *) xmalloc (bfd_section_size (sect)));\n \n   sect_data_got = bfd_get_relocated_section_contents (abfd, &link_info,\n \t\t\t\t\t\t      &link_order,\n@@ -362,19 +361,19 @@ copy_sections (bfd *abfd, asection *sect, void *data)\n \n   if (sect_data_got == NULL)\n     error (_(\"Cannot map compiled module \\\"%s\\\" section \\\"%s\\\": %s\"),\n-\t   bfd_get_filename (abfd), bfd_get_section_name (abfd, sect),\n+\t   bfd_get_filename (abfd), bfd_section_name (sect),\n \t   bfd_errmsg (bfd_get_error ()));\n   gdb_assert (sect_data_got == sect_data.get ());\n \n-  inferior_addr = bfd_get_section_vma (abfd, sect);\n+  inferior_addr = bfd_section_vma (sect);\n   if (0 != target_write_memory (inferior_addr, sect_data.get (),\n-\t\t\t\tbfd_get_section_size (sect)))\n+\t\t\t\tbfd_section_size (sect)))\n     error (_(\"Cannot write compiled module \\\"%s\\\" section \\\"%s\\\" \"\n \t     \"to inferior memory range %s-%s.\"),\n-\t   bfd_get_filename (abfd), bfd_get_section_name (abfd, sect),\n+\t   bfd_get_filename (abfd), bfd_section_name (sect),\n \t   paddress (target_gdbarch (), inferior_addr),\n \t   paddress (target_gdbarch (),\n-\t\t     inferior_addr + bfd_get_section_size (sect)));\n+\t\t     inferior_addr + bfd_section_size (sect)));\n }\n \n /* Fetch the type of COMPILE_I_EXPR_PTR_TYPE and COMPILE_I_EXPR_VAL"
    },
    {
      "sha": "b30b91b522d94f048e1e741a6d4c0bb570ed58e4",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -289,10 +289,10 @@ add_to_thread_list (bfd *abfd, asection *asect, void *reg_sect_arg)\n   bool fake_pid_p = false;\n   struct inferior *inf;\n \n-  if (!startswith (bfd_section_name (abfd, asect), \".reg/\"))\n+  if (!startswith (bfd_section_name (asect), \".reg/\"))\n     return;\n \n-  core_tid = atoi (bfd_section_name (abfd, asect) + 5);\n+  core_tid = atoi (bfd_section_name (asect) + 5);\n \n   pid = bfd_core_file_pid (core_bfd);\n   if (pid == 0)\n@@ -584,7 +584,7 @@ core_target::get_core_register_section (struct regcache *regcache,\n       return;\n     }\n \n-  size = bfd_section_size (core_bfd, section);\n+  size = bfd_section_size (section);\n   if (size < section_min_size)\n     {\n       warning (_(\"Section `%s' in core file too small.\"),\n@@ -614,8 +614,7 @@ core_target::get_core_register_section (struct regcache *regcache,\n \n   gdb_assert (m_core_vec != nullptr);\n   m_core_vec->core_read_registers (regcache, contents, size, which,\n-\t\t\t\t   ((CORE_ADDR)\n-\t\t\t\t    bfd_section_vma (core_bfd, section)));\n+\t\t\t\t   (CORE_ADDR) bfd_section_vma (section));\n }\n \n /* Data passed to gdbarch_iterate_over_regset_sections's callback.  */\n@@ -727,7 +726,7 @@ add_to_spuid_list (bfd *abfd, asection *asect, void *list_p)\n     = bfd_big_endian (abfd) ? BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;\n   int fd, pos = 0;\n \n-  sscanf (bfd_section_name (abfd, asect), \"SPU/%d/regs%n\", &fd, &pos);\n+  sscanf (bfd_section_name (asect), \"SPU/%d/regs%n\", &fd, &pos);\n   if (pos == 0)\n     return;\n \n@@ -768,7 +767,7 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \t  if (section == NULL)\n \t    return TARGET_XFER_E_IO;\n \n-\t  size = bfd_section_size (core_bfd, section);\n+\t  size = bfd_section_size (section);\n \t  if (offset >= size)\n \t    return TARGET_XFER_EOF;\n \t  size -= offset;\n@@ -803,7 +802,7 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \t  if (section == NULL)\n \t    return TARGET_XFER_E_IO;\n \n-\t  size = bfd_section_size (core_bfd, section);\n+\t  size = bfd_section_size (section);\n \t  if (offset >= size)\n \t    return TARGET_XFER_EOF;\n \t  size -= offset;\n@@ -883,7 +882,7 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \t  if (section == NULL)\n \t    return TARGET_XFER_E_IO;\n \n-\t  size = bfd_section_size (core_bfd, section);\n+\t  size = bfd_section_size (section);\n \t  if (offset >= size)\n \t    return TARGET_XFER_EOF;\n \t  size -= offset;"
    },
    {
      "sha": "564c5d3a414e15c2a4df33a7c594c0d7dfd39407",
      "filename": "gdb/dbxread.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/dbxread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/dbxread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dbxread.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -207,10 +207,10 @@ find_text_range (bfd * sym_bfd, struct objfile *objfile)\n   CORE_ADDR end = 0;\n \n   for (sec = sym_bfd->sections; sec; sec = sec->next)\n-    if (bfd_get_section_flags (sym_bfd, sec) & SEC_CODE)\n+    if (bfd_section_flags (sec) & SEC_CODE)\n       {\n-\tCORE_ADDR sec_start = bfd_section_vma (sym_bfd, sec);\n-\tCORE_ADDR sec_end = sec_start + bfd_section_size (sym_bfd, sec);\n+\tCORE_ADDR sec_start = bfd_section_vma (sec);\n+\tCORE_ADDR sec_end = sec_start + bfd_section_size (sec);\n \n \tif (found_any)\n \t  {\n@@ -607,8 +607,8 @@ dbx_symfile_init (struct objfile *objfile)\n   text_sect = bfd_get_section_by_name (sym_bfd, \".text\");\n   if (!text_sect)\n     error (_(\"Can't find .text section in symbol file\"));\n-  DBX_TEXT_ADDR (objfile) = bfd_section_vma (sym_bfd, text_sect);\n-  DBX_TEXT_SIZE (objfile) = bfd_section_size (sym_bfd, text_sect);\n+  DBX_TEXT_ADDR (objfile) = bfd_section_vma (text_sect);\n+  DBX_TEXT_SIZE (objfile) = bfd_section_size (text_sect);\n \n   DBX_SYMBOL_SIZE (objfile) = obj_symbol_entry_size (sym_bfd);\n   DBX_SYMCOUNT (objfile) = bfd_get_symcount (sym_bfd);\n@@ -781,7 +781,7 @@ fill_symbuf (bfd *sym_bfd)\n \n \t  if (bfd_seek (sym_bfd, filepos, SEEK_SET) != 0)\n \t    perror_with_name (bfd_get_filename (sym_bfd));\n-\t  symbuf_left = bfd_section_size (sym_bfd, (*symbuf_sections)[sect_idx]);\n+\t  symbuf_left = bfd_section_size ((*symbuf_sections)[sect_idx]);\n \t  symbol_table_offset = filepos - symbuf_read;\n \t  ++sect_idx;\n \t}\n@@ -2980,7 +2980,7 @@ coffstab_build_psymtabs (struct objfile *objfile,\n     = make_scoped_restore (&symbuf_sections);\n   if (stabsects.size () == 1)\n     {\n-      stabsize = bfd_section_size (sym_bfd, stabsects[0]);\n+      stabsize = bfd_section_size (stabsects[0]);\n       DBX_SYMCOUNT (objfile) = stabsize / DBX_SYMBOL_SIZE (objfile);\n       DBX_SYMTAB_OFFSET (objfile) = stabsects[0]->filepos;\n     }\n@@ -2989,15 +2989,15 @@ coffstab_build_psymtabs (struct objfile *objfile,\n       DBX_SYMCOUNT (objfile) = 0;\n       for (asection *section : stabsects)\n \t{\n-\t  stabsize = bfd_section_size (sym_bfd, section);\n+\t  stabsize = bfd_section_size (section);\n \t  DBX_SYMCOUNT (objfile) += stabsize / DBX_SYMBOL_SIZE (objfile);\n \t}\n \n       DBX_SYMTAB_OFFSET (objfile) = stabsects[0]->filepos;\n \n       sect_idx = 1;\n       symbuf_sections = &stabsects;\n-      symbuf_left = bfd_section_size (sym_bfd, stabsects[0]);\n+      symbuf_left = bfd_section_size (stabsects[0]);\n       symbuf_read = 0;\n     }\n \n@@ -3040,7 +3040,7 @@ elfstab_build_psymtabs (struct objfile *objfile, asection *stabsect,\n #define\tELF_STABS_SYMBOL_SIZE\t12\t/* XXX FIXME XXX */\n   DBX_SYMBOL_SIZE (objfile) = ELF_STABS_SYMBOL_SIZE;\n   DBX_SYMCOUNT (objfile)\n-    = bfd_section_size (objfile->obfd, stabsect) / DBX_SYMBOL_SIZE (objfile);\n+    = bfd_section_size (stabsect) / DBX_SYMBOL_SIZE (objfile);\n   DBX_STRINGTAB_SIZE (objfile) = stabstrsize;\n   DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;\n   DBX_STAB_SECTION (objfile) = stabsect;\n@@ -3067,7 +3067,7 @@ elfstab_build_psymtabs (struct objfile *objfile, asection *stabsect,\n   processing_acc_compilation = 1;\n \n   symbuf_read = 0;\n-  symbuf_left = bfd_section_size (objfile->obfd, stabsect);\n+  symbuf_left = bfd_section_size (stabsect);\n \n   scoped_restore restore_stabs_data = make_scoped_restore (&stabs_data);\n   gdb::unique_xmalloc_ptr<gdb_byte> data_holder;\n@@ -3128,13 +3128,13 @@ stabsect_build_psymtabs (struct objfile *objfile, char *stab_name,\n   text_sect = bfd_get_section_by_name (sym_bfd, text_name);\n   if (!text_sect)\n     error (_(\"Can't find %s section in symbol file\"), text_name);\n-  DBX_TEXT_ADDR (objfile) = bfd_section_vma (sym_bfd, text_sect);\n-  DBX_TEXT_SIZE (objfile) = bfd_section_size (sym_bfd, text_sect);\n+  DBX_TEXT_ADDR (objfile) = bfd_section_vma (text_sect);\n+  DBX_TEXT_SIZE (objfile) = bfd_section_size (text_sect);\n \n   DBX_SYMBOL_SIZE (objfile) = sizeof (struct external_nlist);\n-  DBX_SYMCOUNT (objfile) = bfd_section_size (sym_bfd, stabsect)\n+  DBX_SYMCOUNT (objfile) = bfd_section_size (stabsect)\n     / DBX_SYMBOL_SIZE (objfile);\n-  DBX_STRINGTAB_SIZE (objfile) = bfd_section_size (sym_bfd, stabstrsect);\n+  DBX_STRINGTAB_SIZE (objfile) = bfd_section_size (stabstrsect);\n   DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;\t/* XXX - FIXME: POKING\n \t\t\t\t\t\t\t   INSIDE BFD DATA\n \t\t\t\t\t\t\t   STRUCTURES */"
    },
    {
      "sha": "3ef9114b10579ad907b4f81bb28a24ee0ed260ac",
      "filename": "gdb/dicos-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/dicos-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/dicos-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dicos-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -70,7 +70,7 @@ dicos_load_module_p (bfd *abfd, int header_size)\n   if (!section)\n     return 0;\n \n-  if (bfd_section_size (abfd, section) != header_size)\n+  if (bfd_section_size (section) != header_size)\n     return 0;\n \n   /* Dicos LMs always have a \"Dicos_loadModuleInfo\" symbol"
    },
    {
      "sha": "34b8cbcb768aa77c3b7c6fbb974d57ad13c792c4",
      "filename": "gdb/dwarf2-frame.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/dwarf2-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/dwarf2-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2-frame.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1565,7 +1565,7 @@ read_encoded_value (struct comp_unit *unit, gdb_byte encoding,\n       base = 0;\n       break;\n     case DW_EH_PE_pcrel:\n-      base = bfd_get_section_vma (unit->abfd, unit->dwarf_frame_section);\n+      base = bfd_section_vma (unit->dwarf_frame_section);\n       base += (buf - unit->dwarf_frame_buffer);\n       break;\n     case DW_EH_PE_datarel:"
    },
    {
      "sha": "5e71ded2039abb7f9326d9dc08cb1aa40a283175",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 60,
      "deletions": 60,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2280,7 +2280,7 @@ get_section_name (const struct dwarf2_section_info *section)\n   asection *sectp = get_section_bfd_section (section);\n \n   gdb_assert (sectp != NULL);\n-  return bfd_section_name (get_section_bfd_owner (section), sectp);\n+  return bfd_section_name (sectp);\n }\n \n /* Return the name of the file SECTION is in.  */\n@@ -2315,7 +2315,7 @@ get_section_flags (const struct dwarf2_section_info *section)\n   asection *sectp = get_section_bfd_section (section);\n \n   gdb_assert (sectp != NULL);\n-  return bfd_get_section_flags (sectp->owner, sectp);\n+  return bfd_section_flags (sectp);\n }\n \n /* When loading sections, we look either for uncompressed section or for\n@@ -2340,109 +2340,109 @@ void\n dwarf2_per_objfile::locate_sections (bfd *abfd, asection *sectp,\n \t\t\t\t     const dwarf2_debug_sections &names)\n {\n-  flagword aflag = bfd_get_section_flags (abfd, sectp);\n+  flagword aflag = bfd_section_flags (sectp);\n \n   if ((aflag & SEC_HAS_CONTENTS) == 0)\n     {\n     }\n   else if (section_is_p (sectp->name, &names.info))\n     {\n       this->info.s.section = sectp;\n-      this->info.size = bfd_get_section_size (sectp);\n+      this->info.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.abbrev))\n     {\n       this->abbrev.s.section = sectp;\n-      this->abbrev.size = bfd_get_section_size (sectp);\n+      this->abbrev.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.line))\n     {\n       this->line.s.section = sectp;\n-      this->line.size = bfd_get_section_size (sectp);\n+      this->line.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.loc))\n     {\n       this->loc.s.section = sectp;\n-      this->loc.size = bfd_get_section_size (sectp);\n+      this->loc.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.loclists))\n     {\n       this->loclists.s.section = sectp;\n-      this->loclists.size = bfd_get_section_size (sectp);\n+      this->loclists.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.macinfo))\n     {\n       this->macinfo.s.section = sectp;\n-      this->macinfo.size = bfd_get_section_size (sectp);\n+      this->macinfo.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.macro))\n     {\n       this->macro.s.section = sectp;\n-      this->macro.size = bfd_get_section_size (sectp);\n+      this->macro.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.str))\n     {\n       this->str.s.section = sectp;\n-      this->str.size = bfd_get_section_size (sectp);\n+      this->str.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.line_str))\n     {\n       this->line_str.s.section = sectp;\n-      this->line_str.size = bfd_get_section_size (sectp);\n+      this->line_str.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.addr))\n     {\n       this->addr.s.section = sectp;\n-      this->addr.size = bfd_get_section_size (sectp);\n+      this->addr.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.frame))\n     {\n       this->frame.s.section = sectp;\n-      this->frame.size = bfd_get_section_size (sectp);\n+      this->frame.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.eh_frame))\n     {\n       this->eh_frame.s.section = sectp;\n-      this->eh_frame.size = bfd_get_section_size (sectp);\n+      this->eh_frame.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.ranges))\n     {\n       this->ranges.s.section = sectp;\n-      this->ranges.size = bfd_get_section_size (sectp);\n+      this->ranges.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.rnglists))\n     {\n       this->rnglists.s.section = sectp;\n-      this->rnglists.size = bfd_get_section_size (sectp);\n+      this->rnglists.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.types))\n     {\n       struct dwarf2_section_info type_section;\n \n       memset (&type_section, 0, sizeof (type_section));\n       type_section.s.section = sectp;\n-      type_section.size = bfd_get_section_size (sectp);\n+      type_section.size = bfd_section_size (sectp);\n \n       this->types.push_back (type_section);\n     }\n   else if (section_is_p (sectp->name, &names.gdb_index))\n     {\n       this->gdb_index.s.section = sectp;\n-      this->gdb_index.size = bfd_get_section_size (sectp);\n+      this->gdb_index.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.debug_names))\n     {\n       this->debug_names.s.section = sectp;\n-      this->debug_names.size = bfd_get_section_size (sectp);\n+      this->debug_names.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names.debug_aranges))\n     {\n       this->debug_aranges.s.section = sectp;\n-      this->debug_aranges.size = bfd_get_section_size (sectp);\n+      this->debug_aranges.size = bfd_section_size (sectp);\n     }\n \n-  if ((bfd_get_section_flags (abfd, sectp) & (SEC_LOAD | SEC_ALLOC))\n-      && bfd_section_vma (abfd, sectp) == 0)\n+  if ((bfd_section_flags (sectp) & (SEC_LOAD | SEC_ALLOC))\n+      && bfd_section_vma (sectp) == 0)\n     this->has_section_at_zero = true;\n }\n \n@@ -2531,7 +2531,7 @@ dwarf2_read_section (struct objfile *objfile, dwarf2_section_info *info)\n     {\n       error (_(\"Dwarf Error: Can't read DWARF data\"\n \t       \" in section %s [in module %s]\"),\n-\t     bfd_section_name (abfd, sectp), bfd_get_filename (abfd));\n+\t     bfd_section_name (sectp), bfd_get_filename (abfd));\n     }\n }\n \n@@ -2603,37 +2603,37 @@ locate_dwz_sections (bfd *abfd, asection *sectp, void *arg)\n   if (section_is_p (sectp->name, &dwarf2_elf_names.abbrev))\n     {\n       dwz_file->abbrev.s.section = sectp;\n-      dwz_file->abbrev.size = bfd_get_section_size (sectp);\n+      dwz_file->abbrev.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &dwarf2_elf_names.info))\n     {\n       dwz_file->info.s.section = sectp;\n-      dwz_file->info.size = bfd_get_section_size (sectp);\n+      dwz_file->info.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &dwarf2_elf_names.str))\n     {\n       dwz_file->str.s.section = sectp;\n-      dwz_file->str.size = bfd_get_section_size (sectp);\n+      dwz_file->str.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &dwarf2_elf_names.line))\n     {\n       dwz_file->line.s.section = sectp;\n-      dwz_file->line.size = bfd_get_section_size (sectp);\n+      dwz_file->line.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &dwarf2_elf_names.macro))\n     {\n       dwz_file->macro.s.section = sectp;\n-      dwz_file->macro.size = bfd_get_section_size (sectp);\n+      dwz_file->macro.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &dwarf2_elf_names.gdb_index))\n     {\n       dwz_file->gdb_index.s.section = sectp;\n-      dwz_file->gdb_index.size = bfd_get_section_size (sectp);\n+      dwz_file->gdb_index.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &dwarf2_elf_names.debug_names))\n     {\n       dwz_file->debug_names.s.section = sectp;\n-      dwz_file->debug_names.size = bfd_get_section_size (sectp);\n+      dwz_file->debug_names.size = bfd_section_size (sectp);\n     }\n }\n \n@@ -12311,7 +12311,7 @@ locate_v1_virtual_dwo_sections (asection *sectp,\n       if (sections->abbrev.s.section != NULL)\n \treturn 0;\n       sections->abbrev.s.section = sectp;\n-      sections->abbrev.size = bfd_get_section_size (sectp);\n+      sections->abbrev.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->info_dwo)\n \t   || section_is_p (sectp->name, &names->types_dwo))\n@@ -12320,47 +12320,47 @@ locate_v1_virtual_dwo_sections (asection *sectp,\n       if (sections->info_or_types.s.section != NULL)\n \treturn 0;\n       sections->info_or_types.s.section = sectp;\n-      sections->info_or_types.size = bfd_get_section_size (sectp);\n+      sections->info_or_types.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->line_dwo))\n     {\n       /* There can be only one.  */\n       if (sections->line.s.section != NULL)\n \treturn 0;\n       sections->line.s.section = sectp;\n-      sections->line.size = bfd_get_section_size (sectp);\n+      sections->line.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->loc_dwo))\n     {\n       /* There can be only one.  */\n       if (sections->loc.s.section != NULL)\n \treturn 0;\n       sections->loc.s.section = sectp;\n-      sections->loc.size = bfd_get_section_size (sectp);\n+      sections->loc.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->macinfo_dwo))\n     {\n       /* There can be only one.  */\n       if (sections->macinfo.s.section != NULL)\n \treturn 0;\n       sections->macinfo.s.section = sectp;\n-      sections->macinfo.size = bfd_get_section_size (sectp);\n+      sections->macinfo.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->macro_dwo))\n     {\n       /* There can be only one.  */\n       if (sections->macro.s.section != NULL)\n \treturn 0;\n       sections->macro.s.section = sectp;\n-      sections->macro.size = bfd_get_section_size (sectp);\n+      sections->macro.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->str_offsets_dwo))\n     {\n       /* There can be only one.  */\n       if (sections->str_offsets.s.section != NULL)\n \treturn 0;\n       sections->str_offsets.s.section = sectp;\n-      sections->str_offsets.size = bfd_get_section_size (sectp);\n+      sections->str_offsets.size = bfd_section_size (sectp);\n     }\n   else\n     {\n@@ -12558,11 +12558,11 @@ create_dwp_v2_section (struct dwarf2_per_objfile *dwarf2_per_objfile,\n      bounds of the real section.  This is a pretty-rare event, so just\n      flag an error (easier) instead of a warning and trying to cope.  */\n   if (sectp == NULL\n-      || offset + size > bfd_get_section_size (sectp))\n+      || offset + size > bfd_section_size (sectp))\n     {\n       error (_(\"Dwarf Error: Bad DWP V2 section info, doesn't fit\"\n \t       \" in section %s [in module %s]\"),\n-\t     sectp ? bfd_section_name (abfd, sectp) : \"<unknown>\",\n+\t     sectp ? bfd_section_name (sectp) : \"<unknown>\",\n \t     objfile_name (dwarf2_per_objfile->objfile));\n     }\n \n@@ -12933,50 +12933,50 @@ dwarf2_locate_dwo_sections (bfd *abfd, asection *sectp, void *dwo_sections_ptr)\n   if (section_is_p (sectp->name, &names->abbrev_dwo))\n     {\n       dwo_sections->abbrev.s.section = sectp;\n-      dwo_sections->abbrev.size = bfd_get_section_size (sectp);\n+      dwo_sections->abbrev.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->info_dwo))\n     {\n       dwo_sections->info.s.section = sectp;\n-      dwo_sections->info.size = bfd_get_section_size (sectp);\n+      dwo_sections->info.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->line_dwo))\n     {\n       dwo_sections->line.s.section = sectp;\n-      dwo_sections->line.size = bfd_get_section_size (sectp);\n+      dwo_sections->line.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->loc_dwo))\n     {\n       dwo_sections->loc.s.section = sectp;\n-      dwo_sections->loc.size = bfd_get_section_size (sectp);\n+      dwo_sections->loc.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->macinfo_dwo))\n     {\n       dwo_sections->macinfo.s.section = sectp;\n-      dwo_sections->macinfo.size = bfd_get_section_size (sectp);\n+      dwo_sections->macinfo.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->macro_dwo))\n     {\n       dwo_sections->macro.s.section = sectp;\n-      dwo_sections->macro.size = bfd_get_section_size (sectp);\n+      dwo_sections->macro.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->str_dwo))\n     {\n       dwo_sections->str.s.section = sectp;\n-      dwo_sections->str.size = bfd_get_section_size (sectp);\n+      dwo_sections->str.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->str_offsets_dwo))\n     {\n       dwo_sections->str_offsets.s.section = sectp;\n-      dwo_sections->str_offsets.size = bfd_get_section_size (sectp);\n+      dwo_sections->str_offsets.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->types_dwo))\n     {\n       struct dwarf2_section_info type_section;\n \n       memset (&type_section, 0, sizeof (type_section));\n       type_section.s.section = sectp;\n-      type_section.size = bfd_get_section_size (sectp);\n+      type_section.size = bfd_section_size (sectp);\n       dwo_sections->types.push_back (type_section);\n     }\n }\n@@ -13040,17 +13040,17 @@ dwarf2_locate_common_dwp_sections (bfd *abfd, asection *sectp,\n   if (section_is_p (sectp->name, &names->str_dwo))\n     {\n       dwp_file->sections.str.s.section = sectp;\n-      dwp_file->sections.str.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.str.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->cu_index))\n     {\n       dwp_file->sections.cu_index.s.section = sectp;\n-      dwp_file->sections.cu_index.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.cu_index.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->tu_index))\n     {\n       dwp_file->sections.tu_index.s.section = sectp;\n-      dwp_file->sections.tu_index.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.tu_index.size = bfd_section_size (sectp);\n     }\n }\n \n@@ -13075,42 +13075,42 @@ dwarf2_locate_v2_dwp_sections (bfd *abfd, asection *sectp, void *dwp_file_ptr)\n   if (section_is_p (sectp->name, &names->abbrev_dwo))\n     {\n       dwp_file->sections.abbrev.s.section = sectp;\n-      dwp_file->sections.abbrev.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.abbrev.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->info_dwo))\n     {\n       dwp_file->sections.info.s.section = sectp;\n-      dwp_file->sections.info.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.info.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->line_dwo))\n     {\n       dwp_file->sections.line.s.section = sectp;\n-      dwp_file->sections.line.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.line.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->loc_dwo))\n     {\n       dwp_file->sections.loc.s.section = sectp;\n-      dwp_file->sections.loc.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.loc.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->macinfo_dwo))\n     {\n       dwp_file->sections.macinfo.s.section = sectp;\n-      dwp_file->sections.macinfo.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.macinfo.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->macro_dwo))\n     {\n       dwp_file->sections.macro.s.section = sectp;\n-      dwp_file->sections.macro.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.macro.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->str_offsets_dwo))\n     {\n       dwp_file->sections.str_offsets.s.section = sectp;\n-      dwp_file->sections.str_offsets.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.str_offsets.size = bfd_section_size (sectp);\n     }\n   else if (section_is_p (sectp->name, &names->types_dwo))\n     {\n       dwp_file->sections.types.s.section = sectp;\n-      dwp_file->sections.types.size = bfd_get_section_size (sectp);\n+      dwp_file->sections.types.size = bfd_section_size (sectp);\n     }\n }\n "
    },
    {
      "sha": "901710f2833e0b811af983d2a6f85d6570c2f881",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -125,7 +125,7 @@ elf_symfile_segments (bfd *abfd)\n     {\n       int j;\n \n-      if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)\n+      if ((bfd_section_flags (sect) & SEC_ALLOC) == 0)\n \tcontinue;\n \n       Elf_Internal_Shdr *this_hdr = &elf_section_data (sect)->this_hdr;\n@@ -146,10 +146,10 @@ elf_symfile_segments (bfd *abfd)\n \t RealView) use SHT_NOBITS for uninitialized data.  Since it is\n \t uninitialized, it doesn't need a program header.  Such\n \t binaries are not relocatable.  */\n-      if (bfd_get_section_size (sect) > 0 && j == num_segments\n-\t  && (bfd_get_section_flags (abfd, sect) & SEC_LOAD) != 0)\n+      if (bfd_section_size (sect) > 0 && j == num_segments\n+\t  && (bfd_section_flags (sect) & SEC_LOAD) != 0)\n \twarning (_(\"Loadable section \\\"%s\\\" outside of ELF segments\"),\n-\t\t bfd_section_name (abfd, sect));\n+\t\t bfd_section_name (sect));\n     }\n \n   return data;\n@@ -289,12 +289,12 @@ elf_symtab_read (minimal_symbol_reader &reader,\n \t     covers the stub's address.  */\n \t  for (sect = abfd->sections; sect != NULL; sect = sect->next)\n \t    {\n-\t      if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)\n+\t      if ((bfd_section_flags (sect) & SEC_ALLOC) == 0)\n \t\tcontinue;\n \n-\t      if (symaddr >= bfd_get_section_vma (abfd, sect)\n-\t\t  && symaddr < bfd_get_section_vma (abfd, sect)\n-\t\t\t       + bfd_get_section_size (sect))\n+\t      if (symaddr >= bfd_section_vma (sect)\n+\t\t  && symaddr < bfd_section_vma (sect)\n+\t\t\t       + bfd_section_size (sect))\n \t\tbreak;\n \t    }\n \t  if (!sect)\n@@ -591,9 +591,9 @@ elf_rel_plt_read (minimal_symbol_reader &reader,\n       if (section == NULL)\n \treturn false;\n \n-      return (bfd_get_section_vma (obfd, section) <= address\n-\t      && (address < bfd_get_section_vma (obfd, section)\n-\t\t  + bfd_get_section_size (section)));\n+      return (bfd_section_vma (section) <= address\n+\t      && (address < bfd_section_vma (section)\n+\t\t  + bfd_section_size (section)));\n     };\n \n   reloc_count = relplt->size / elf_section_data (relplt)->this_hdr.sh_entsize;\n@@ -1236,7 +1236,7 @@ elf_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n \telfstab_build_psymtabs (objfile,\n \t\t\t\tei.stabsect,\n \t\t\t\tstr_sect->filepos,\n-\t\t\t\tbfd_section_size (abfd, str_sect));\n+\t\t\t\tbfd_section_size (str_sect));\n     }\n \n   if (dwarf2_has_info (objfile, NULL))"
    },
    {
      "sha": "6bdf9abb3e42fc29837c7efadb5f07ad8913f5dc",
      "filename": "gdb/exec.c",
      "status": "modified",
      "additions": 15,
      "deletions": 19,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -454,14 +454,14 @@ add_to_section_table (bfd *abfd, struct bfd_section *asect,\n      encountered on sparc-solaris 2.10 a shared library with an empty .bss\n      section to which a symbol named \"_end\" was attached.  The address\n      of this symbol still needs to be relocated.  */\n-  aflag = bfd_get_section_flags (abfd, asect);\n+  aflag = bfd_section_flags (asect);\n   if (!(aflag & SEC_ALLOC))\n     return;\n \n   (*table_pp)->owner = NULL;\n   (*table_pp)->the_bfd_section = asect;\n-  (*table_pp)->addr = bfd_section_vma (abfd, asect);\n-  (*table_pp)->endaddr = (*table_pp)->addr + bfd_section_size (abfd, asect);\n+  (*table_pp)->addr = bfd_section_vma (asect);\n+  (*table_pp)->endaddr = (*table_pp)->addr + bfd_section_size (asect);\n   (*table_pp)++;\n }\n \n@@ -571,7 +571,7 @@ add_target_sections_of_objfile (struct objfile *objfile)\n   /* Compute the number of sections to add.  */\n   ALL_OBJFILE_OSECTIONS (objfile, osect)\n     {\n-      if (bfd_get_section_size (osect->the_bfd_section) == 0)\n+      if (bfd_section_size (osect->the_bfd_section) == 0)\n \tcontinue;\n       count++;\n     }\n@@ -585,7 +585,7 @@ add_target_sections_of_objfile (struct objfile *objfile)\n \n   ALL_OBJFILE_OSECTIONS (objfile, osect)\n     {\n-      if (bfd_get_section_size (osect->the_bfd_section) == 0)\n+      if (bfd_section_size (osect->the_bfd_section) == 0)\n \tcontinue;\n \n       gdb_assert (ts < table->sections + space + count);\n@@ -665,7 +665,7 @@ exec_read_partial_read_only (gdb_byte *readbuf, ULONGEST offset,\n \t    continue;\n \n \t  vma = s->vma;\n-\t  size = bfd_get_section_size (s);\n+\t  size = bfd_section_size (s);\n \t  if (vma <= offset && offset < (vma + size))\n \t    {\n \t      ULONGEST amt;\n@@ -705,9 +705,7 @@ section_table_available_memory (CORE_ADDR memaddr, ULONGEST len,\n \n   for (target_section *p = sections; p < sections_end; p++)\n     {\n-      if ((bfd_get_section_flags (p->the_bfd_section->owner,\n-\t\t\t\t  p->the_bfd_section)\n-\t   & SEC_READONLY) == 0)\n+      if ((bfd_section_flags (p->the_bfd_section) & SEC_READONLY) == 0)\n \tcontinue;\n \n       /* Copy the meta-data, adjusted.  */\n@@ -894,17 +892,16 @@ print_section_info (struct target_section_table *t, bfd *abfd)\n       for (p = t->sections; p < t->sections_end; p++)\n \t{\n \t  struct bfd_section *psect = p->the_bfd_section;\n-\t  bfd *pbfd = psect->owner;\n \n-\t  if ((bfd_get_section_flags (pbfd, psect) & (SEC_ALLOC | SEC_LOAD))\n+\t  if ((bfd_section_flags (psect) & (SEC_ALLOC | SEC_LOAD))\n \t      != (SEC_ALLOC | SEC_LOAD))\n \t    continue;\n \n-\t  if (bfd_get_section_vma (pbfd, psect) <= abfd->start_address\n-\t      && abfd->start_address < (bfd_get_section_vma (pbfd, psect)\n-\t\t\t\t\t+ bfd_get_section_size (psect)))\n+\t  if (bfd_section_vma (psect) <= abfd->start_address\n+\t      && abfd->start_address < (bfd_section_vma (psect)\n+\t\t\t\t\t+ bfd_section_size (psect)))\n \t    {\n-\t      displacement = p->addr - bfd_get_section_vma (pbfd, psect);\n+\t      displacement = p->addr - bfd_section_vma (psect);\n \t      break;\n \t    }\n \t}\n@@ -935,7 +932,7 @@ print_section_info (struct target_section_table *t, bfd *abfd)\n       if (info_verbose)\n \tprintf_filtered (\" @ %s\",\n \t\t\t hex_string_custom (psect->filepos, 8));\n-      printf_filtered (\" is %s\", bfd_section_name (pbfd, psect));\n+      printf_filtered (\" is %s\", bfd_section_name (psect));\n       if (pbfd != abfd)\n \tprintf_filtered (\" in %s\", bfd_get_filename (pbfd));\n       printf_filtered (\"\\n\");\n@@ -975,9 +972,8 @@ set_section_command (const char *args, int from_tty)\n   table = current_target_sections;\n   for (p = table->sections; p < table->sections_end; p++)\n     {\n-      if (!strncmp (secname, bfd_section_name (p->bfd,\n-\t\t\t\t\t       p->the_bfd_section), seclen)\n-\t  && bfd_section_name (p->bfd, p->the_bfd_section)[seclen] == '\\0')\n+      if (!strncmp (secname, bfd_section_name (p->the_bfd_section), seclen)\n+\t  && bfd_section_name (p->the_bfd_section)[seclen] == '\\0')\n \t{\n \t  offset = secaddr - p->addr;\n \t  p->addr += offset;"
    },
    {
      "sha": "9422e3c1a7e1a65c76b088f42bb5986bd13a089f",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -502,10 +502,10 @@ fbsd_core_thread_name (struct gdbarch *gdbarch, struct thread_info *thr)\n       thread_section_name section_name (\".thrmisc\", thr->ptid);\n \n       section = bfd_get_section_by_name (core_bfd, section_name.c_str ());\n-      if (section != NULL && bfd_section_size (core_bfd, section) > 0)\n+      if (section != NULL && bfd_section_size (section) > 0)\n \t{\n \t  /* Truncate the name if it is longer than \"buf\".  */\n-\t  size = bfd_section_size (core_bfd, section);\n+\t  size = bfd_section_size (section);\n \t  if (size > sizeof buf - 1)\n \t    size = sizeof buf - 1;\n \t  if (bfd_get_section_contents (core_bfd, section, buf, (file_ptr) 0,\n@@ -1058,7 +1058,7 @@ fbsd_core_info_proc_files (struct gdbarch *gdbarch)\n       return;\n     }\n \n-  size_t note_size = bfd_get_section_size (section);\n+  size_t note_size = bfd_section_size (section);\n   if (note_size < 4)\n     error (_(\"malformed core note - too short for header\"));\n \n@@ -1191,7 +1191,7 @@ fbsd_core_info_proc_mappings (struct gdbarch *gdbarch)\n       return;\n     }\n \n-  note_size = bfd_get_section_size (section);\n+  note_size = bfd_section_size (section);\n   if (note_size < 4)\n     error (_(\"malformed core note - too short for header\"));\n \n@@ -1239,7 +1239,7 @@ fbsd_core_vnode_path (struct gdbarch *gdbarch, int fd)\n   if (section == NULL)\n     return nullptr;\n \n-  note_size = bfd_get_section_size (section);\n+  note_size = bfd_section_size (section);\n   if (note_size < 4)\n     error (_(\"malformed core note - too short for header\"));\n \n@@ -1344,7 +1344,7 @@ fbsd_core_info_proc_status (struct gdbarch *gdbarch)\n    * structure size, then it must be long enough to access the last\n    * field used (ki_rusage_ch.ru_majflt) which is the size of a long.\n    */\n-  note_size = bfd_get_section_size (section);\n+  note_size = bfd_section_size (section);\n   if (note_size < (4 + kp->ki_rusage_ch + kp->ru_majflt\n \t\t   + long_bit / TARGET_CHAR_BIT))\n     error (_(\"malformed core note - too short\"));"
    },
    {
      "sha": "f283ed4580d9f2266dafeafcd09b88eca8a311fd",
      "filename": "gdb/gcore.c",
      "status": "modified",
      "additions": 22,
      "deletions": 24,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/gcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/gcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -95,9 +95,9 @@ write_gcore_file_1 (bfd *obfd)\n     error (_(\"Failed to create 'note' section for corefile: %s\"),\n \t   bfd_errmsg (bfd_get_error ()));\n \n-  bfd_set_section_vma (obfd, note_sec, 0);\n-  bfd_set_section_alignment (obfd, note_sec, 0);\n-  bfd_set_section_size (obfd, note_sec, note_size);\n+  bfd_set_section_vma (note_sec, 0);\n+  bfd_set_section_alignment (note_sec, 0);\n+  bfd_set_section_size (note_sec, note_size);\n \n   /* Now create the memory/load sections.  */\n   if (gcore_memory_sections (obfd) == 0)\n@@ -332,11 +332,11 @@ derive_heap_segment (bfd *abfd, bfd_vma *bottom, bfd_vma *top)\n \n   for (sec = abfd->sections; sec; sec = sec->next)\n     {\n-      if (bfd_get_section_flags (abfd, sec) & SEC_DATA\n-\t  || strcmp (\".bss\", bfd_section_name (abfd, sec)) == 0)\n+      if (bfd_section_flags (sec) & SEC_DATA\n+\t  || strcmp (\".bss\", bfd_section_name (sec)) == 0)\n \t{\n-\t  sec_vaddr = bfd_get_section_vma (abfd, sec);\n-\t  sec_size = bfd_get_section_size (sec);\n+\t  sec_vaddr = bfd_section_vma (sec);\n+\t  sec_size = bfd_section_size (sec);\n \t  if (sec_vaddr + sec_size > top_of_data_memory)\n \t    top_of_data_memory = sec_vaddr + sec_size;\n \t}\n@@ -365,17 +365,17 @@ make_output_phdrs (bfd *obfd, asection *osec, void *ignored)\n   int p_type = 0;\n \n   /* FIXME: these constants may only be applicable for ELF.  */\n-  if (startswith (bfd_section_name (obfd, osec), \"load\"))\n+  if (startswith (bfd_section_name (osec), \"load\"))\n     p_type = PT_LOAD;\n-  else if (startswith (bfd_section_name (obfd, osec), \"note\"))\n+  else if (startswith (bfd_section_name (osec), \"note\"))\n     p_type = PT_NOTE;\n   else\n     p_type = PT_NULL;\n \n   p_flags |= PF_R;\t/* Segment is readable.  */\n-  if (!(bfd_get_section_flags (obfd, osec) & SEC_READONLY))\n+  if (!(bfd_section_flags (osec) & SEC_READONLY))\n     p_flags |= PF_W;\t/* Segment is writable.  */\n-  if (bfd_get_section_flags (obfd, osec) & SEC_CODE)\n+  if (bfd_section_flags (osec) & SEC_CODE)\n     p_flags |= PF_X;\t/* Segment is executable.  */\n \n   bfd_record_phdr (obfd, p_type, 1, p_flags, 0, 0, 0, 0, 1, &osec);\n@@ -417,8 +417,7 @@ gcore_create_callback (CORE_ADDR vaddr, unsigned long size, int read,\n \t  {\n \t    bfd *abfd = objfile->obfd;\n \t    asection *asec = objsec->the_bfd_section;\n-\t    bfd_vma align = (bfd_vma) 1 << bfd_get_section_alignment (abfd,\n-\t\t\t\t\t\t\t\t      asec);\n+\t    bfd_vma align = (bfd_vma) 1 << bfd_section_alignment (asec);\n \t    bfd_vma start = obj_section_addr (objsec) & -align;\n \t    bfd_vma end = (obj_section_endaddr (objsec) + align - 1) & -align;\n \n@@ -464,9 +463,9 @@ gcore_create_callback (CORE_ADDR vaddr, unsigned long size, int read,\n \t\t\tplongest (size), paddress (target_gdbarch (), vaddr));\n     }\n \n-  bfd_set_section_size (obfd, osec, size);\n-  bfd_set_section_vma (obfd, osec, vaddr);\n-  bfd_section_lma (obfd, osec) = 0; /* ??? bfd_set_section_lma?  */\n+  bfd_set_section_size (osec, size);\n+  bfd_set_section_vma (osec, vaddr);\n+  bfd_set_section_lma (osec, 0);\n   return 0;\n }\n \n@@ -482,17 +481,16 @@ objfile_find_memory_regions (struct target_ops *self,\n   for (objfile *objfile : current_program_space->objfiles ())\n     ALL_OBJFILE_OSECTIONS (objfile, objsec)\n       {\n-\tbfd *ibfd = objfile->obfd;\n \tasection *isec = objsec->the_bfd_section;\n-\tflagword flags = bfd_get_section_flags (ibfd, isec);\n+\tflagword flags = bfd_section_flags (isec);\n \n \t/* Separate debug info files are irrelevant for gcore.  */\n \tif (objfile->separate_debug_objfile_backlink != NULL)\n \t  continue;\n \n \tif ((flags & SEC_ALLOC) || (flags & SEC_LOAD))\n \t  {\n-\t    int size = bfd_section_size (ibfd, isec);\n+\t    int size = bfd_section_size (isec);\n \t    int ret;\n \n \t    ret = (*func) (obj_section_addr (objsec), size, \n@@ -530,15 +528,15 @@ objfile_find_memory_regions (struct target_ops *self,\n static void\n gcore_copy_callback (bfd *obfd, asection *osec, void *ignored)\n {\n-  bfd_size_type size, total_size = bfd_section_size (obfd, osec);\n+  bfd_size_type size, total_size = bfd_section_size (osec);\n   file_ptr offset = 0;\n \n   /* Read-only sections are marked; we don't have to copy their contents.  */\n-  if ((bfd_get_section_flags (obfd, osec) & SEC_LOAD) == 0)\n+  if ((bfd_section_flags (osec) & SEC_LOAD) == 0)\n     return;\n \n   /* Only interested in \"load\" sections.  */\n-  if (!startswith (bfd_section_name (obfd, osec), \"load\"))\n+  if (!startswith (bfd_section_name (osec), \"load\"))\n     return;\n \n   size = std::min (total_size, (bfd_size_type) MAX_COPY_BYTES);\n@@ -549,13 +547,13 @@ gcore_copy_callback (bfd *obfd, asection *osec, void *ignored)\n       if (size > total_size)\n \tsize = total_size;\n \n-      if (target_read_memory (bfd_section_vma (obfd, osec) + offset,\n+      if (target_read_memory (bfd_section_vma (osec) + offset,\n \t\t\t      memhunk.data (), size) != 0)\n \t{\n \t  warning (_(\"Memory read failed for corefile \"\n \t\t     \"section, %s bytes at %s.\"),\n \t\t   plongest (size),\n-\t\t   paddress (target_gdbarch (), bfd_section_vma (obfd, osec)));\n+\t\t   paddress (target_gdbarch (), bfd_section_vma (osec)));\n \t  break;\n \t}\n       if (!bfd_set_section_contents (obfd, osec, memhunk.data (),"
    },
    {
      "sha": "8a67d5e97d72fe846e6d158cb0891685883d55ab",
      "filename": "gdb/gdb_bfd.c",
      "status": "modified",
      "additions": 7,
      "deletions": 8,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/gdb_bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/gdb_bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdb_bfd.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -480,7 +480,7 @@ static void\n free_one_bfd_section (bfd *abfd, asection *sectp, void *ignore)\n {\n   struct gdb_bfd_section_data *sect\n-    = (struct gdb_bfd_section_data *) bfd_get_section_userdata (abfd, sectp);\n+    = (struct gdb_bfd_section_data *) bfd_section_userdata (sectp);\n \n   if (sect != NULL && sect->data != NULL)\n     {\n@@ -626,14 +626,13 @@ get_section_descriptor (asection *section)\n {\n   struct gdb_bfd_section_data *result;\n \n-  result = ((struct gdb_bfd_section_data *)\n-\t    bfd_get_section_userdata (section->owner, section));\n+  result = (struct gdb_bfd_section_data *) bfd_section_userdata (section);\n \n   if (result == NULL)\n     {\n       result = ((struct gdb_bfd_section_data *)\n \t\tbfd_zalloc (section->owner, sizeof (*result)));\n-      bfd_set_section_userdata (section->owner, section, result);\n+      bfd_set_section_userdata (section, result);\n     }\n \n   return result;\n@@ -671,9 +670,9 @@ gdb_bfd_map_section (asection *sectp, bfd_size_type *size)\n       /* Only try to mmap sections which are large enough: we don't want\n \t to waste space due to fragmentation.  */\n \n-      if (bfd_get_section_size (sectp) > 4 * pagesize)\n+      if (bfd_section_size (sectp) > 4 * pagesize)\n \t{\n-\t  descriptor->size = bfd_get_section_size (sectp);\n+\t  descriptor->size = bfd_section_size (sectp);\n \t  descriptor->data = bfd_mmap (abfd, 0, descriptor->size, PROT_READ,\n \t\t\t\t       MAP_PRIVATE, sectp->filepos,\n \t\t\t\t       &descriptor->map_addr,\n@@ -697,14 +696,14 @@ gdb_bfd_map_section (asection *sectp, bfd_size_type *size)\n   /* Handle compressed sections, or ordinary uncompressed sections in\n      the no-mmap case.  */\n \n-  descriptor->size = bfd_get_section_size (sectp);\n+  descriptor->size = bfd_section_size (sectp);\n   descriptor->data = NULL;\n \n   data = NULL;\n   if (!bfd_get_full_section_contents (abfd, sectp, &data))\n     {\n       warning (_(\"Can't read data for section '%s' in file '%s'\"),\n-\t       bfd_get_section_name (abfd, sectp),\n+\t       bfd_section_name (sectp),\n \t       bfd_get_filename (abfd));\n       /* Set size to 0 to prevent further attempts to read the invalid\n \t section.  */"
    },
    {
      "sha": "674880d07fff9e52e1cd873a25536e4df94b0bba",
      "filename": "gdb/gdb_bfd.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/gdb_bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/gdb_bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdb_bfd.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -106,7 +106,7 @@ void gdb_bfd_record_inclusion (bfd *includer, bfd *includee);\n \n /* Try to read or map the contents of the section SECT.  If successful, the\n    section data is returned and *SIZE is set to the size of the section data;\n-   this may not be the same as the size according to bfd_get_section_size if the\n+   this may not be the same as the size according to bfd_section_size if the\n    section was compressed.  The returned section data is associated with the BFD\n    and will be destroyed when the BFD is destroyed.  There is no other way to\n    free it; for temporary uses of section data, see bfd_malloc_and_get_section."
    },
    {
      "sha": "249d5c91bd176ac34a66a299a68cfab1942647ad",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -380,7 +380,7 @@ read_unwind_info (struct objfile *objfile)\n       if (strcmp (unwind_sec->name, \"$UNWIND_START$\") == 0\n \t  || strcmp (unwind_sec->name, \".PARISC.unwind\") == 0)\n \t{\n-\t  unwind_size = bfd_section_size (objfile->obfd, unwind_sec);\n+\t  unwind_size = bfd_section_size (unwind_sec);\n \t  unwind_entries = unwind_size / UNWIND_ENTRY_SIZE;\n \n \t  total_entries += unwind_entries;\n@@ -393,7 +393,7 @@ read_unwind_info (struct objfile *objfile)\n \n   if (stub_unwind_sec)\n     {\n-      stub_unwind_size = bfd_section_size (objfile->obfd, stub_unwind_sec);\n+      stub_unwind_size = bfd_section_size (stub_unwind_sec);\n       stub_entries = stub_unwind_size / STUB_UNWIND_ENTRY_SIZE;\n     }\n   else\n@@ -421,7 +421,7 @@ read_unwind_info (struct objfile *objfile)\n       if (strcmp (unwind_sec->name, \"$UNWIND_START$\") == 0\n \t  || strcmp (unwind_sec->name, \".PARISC.unwind\") == 0)\n \t{\n-\t  unwind_size = bfd_section_size (objfile->obfd, unwind_sec);\n+\t  unwind_size = bfd_section_size (unwind_sec);\n \t  unwind_entries = unwind_size / UNWIND_ENTRY_SIZE;\n \n \t  internalize_unwinds (objfile, &ui->table[index], unwind_sec,"
    },
    {
      "sha": "25c3cfcbb9882ea37100eccb9e74ef96e91509e5",
      "filename": "gdb/i386-cygwin-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/i386-cygwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/i386-cygwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-cygwin-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -110,14 +110,14 @@ core_process_module_section (bfd *abfd, asection *sect, void *obj)\n   if (!startswith (sect->name, \".module\"))\n     return;\n \n-  buf = (gdb_byte *) xmalloc (bfd_get_section_size (sect) + 1);\n+  buf = (gdb_byte *) xmalloc (bfd_section_size (sect) + 1);\n   if (!buf)\n     {\n       printf_unfiltered (\"memory allocation failed for %s\\n\", sect->name);\n       goto out;\n     }\n   if (!bfd_get_section_contents (abfd, sect,\n-\t\t\t\t buf, 0, bfd_get_section_size (sect)))\n+\t\t\t\t buf, 0, bfd_section_size (sect)))\n     goto out;\n \n \n@@ -130,7 +130,7 @@ core_process_module_section (bfd *abfd, asection *sect, void *obj)\n   module_name_size =\n     extract_unsigned_integer (buf + 8, 4, byte_order);\n \n-  if (12 + module_name_size > bfd_get_section_size (sect))\n+  if (12 + module_name_size > bfd_section_size (sect))\n     goto out;\n   module_name = (char *) buf + 12;\n \n@@ -240,7 +240,7 @@ i386_cygwin_osabi_sniffer (bfd *abfd)\n     {\n       asection *section = bfd_get_section_by_name (abfd, \".reg\");\n       if (section\n-\t  && bfd_section_size (abfd, section) == I386_WINDOWS_SIZEOF_GREGSET)\n+\t  && bfd_section_size (section) == I386_WINDOWS_SIZEOF_GREGSET)\n \treturn GDB_OSABI_CYGWIN;\n     }\n "
    },
    {
      "sha": "04d0a641b72cbbc5fac9e3eec10ae6841639bc3a",
      "filename": "gdb/i386-fbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/i386-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/i386-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-fbsd-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -233,7 +233,7 @@ i386fbsd_core_read_xcr0 (bfd *abfd)\n \n   if (xstate)\n     {\n-      size_t size = bfd_section_size (abfd, xstate);\n+      size_t size = bfd_section_size (xstate);\n \n       /* Check extended state size.  */\n       if (size < X86_XSTATE_AVX_SIZE)"
    },
    {
      "sha": "c41013984ee0c6f9d70afebf8d1da7ecb7c574fe",
      "filename": "gdb/i386-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/i386-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/i386-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-linux-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -646,7 +646,7 @@ i386_linux_core_read_xcr0 (bfd *abfd)\n \n   if (xstate)\n     {\n-      size_t size = bfd_section_size (abfd, xstate);\n+      size_t size = bfd_section_size (xstate);\n \n       /* Check extended state size.  */\n       if (size < X86_XSTATE_AVX_SIZE)"
    },
    {
      "sha": "af01b4d6c4fe3f1d997b6ab2867fed93e1c0b84c",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -910,12 +910,12 @@ JITed symbol file is not an object file, ignoring it.\\n\"));\n      addresses that we care about.  */\n   section_addr_info sai;\n   for (sec = nbfd->sections; sec != NULL; sec = sec->next)\n-    if ((bfd_get_section_flags (nbfd.get (), sec) & (SEC_ALLOC|SEC_LOAD)) != 0)\n+    if ((bfd_section_flags (sec) & (SEC_ALLOC|SEC_LOAD)) != 0)\n       {\n         /* We assume that these virtual addresses are absolute, and do not\n            treat them as offsets.  */\n-\tsai.emplace_back (bfd_get_section_vma (nbfd.get (), sec),\n-\t\t\t  bfd_get_section_name (nbfd.get (), sec),\n+\tsai.emplace_back (bfd_section_vma (sec),\n+\t\t\t  bfd_section_name (sec),\n \t\t\t  sec->index);\n       }\n "
    },
    {
      "sha": "63a9bd32dfd3f066640d947e1fb57e30e4fd07c9",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1046,7 +1046,7 @@ linux_core_info_proc_mappings (struct gdbarch *gdbarch, const char *args)\n \n   addr_size_bits = gdbarch_addr_bit (core_gdbarch);\n   addr_size = addr_size_bits / 8;\n-  note_size = bfd_get_section_size (section);\n+  note_size = bfd_section_size (section);\n \n   if (note_size < 2 * addr_size)\n     error (_(\"malformed core note - too short for header\"));"
    },
    {
      "sha": "1795982a3e8200659f676e2cfac1d2c063c97e89",
      "filename": "gdb/machoread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/machoread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/machoread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/machoread.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -575,7 +575,7 @@ macho_add_oso_symfile (oso_el *oso, const gdb_bfd_ref_ptr &abfd,\n                          sec->name, sym->name,\n                          paddress (arch, res));\n                     }\n-                  bfd_set_section_vma (abfd.get (), sec, res);\n+                  bfd_set_section_vma (sec, res);\n                   sections_rebased[sec->index] = 1;\n                 }\n             }\n@@ -854,8 +854,7 @@ macho_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n             {\n               if (strcmp (asect->name, dsect->name) != 0)\n                 break;\n-              bfd_set_section_size (dsym_bfd.get (), dsect,\n-                                    bfd_get_section_size (asect));\n+              bfd_set_section_size (dsect, bfd_section_size (asect));\n             }\n \n \t  /* Add the dsym file as a separate file.  */"
    },
    {
      "sha": "ec9f4abb26466936c76fc9bc0cef8a1091e616c9",
      "filename": "gdb/maint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/maint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/maint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/maint.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -335,8 +335,8 @@ print_bfd_section_info (bfd *abfd,\n \t\t\tasection *asect,\n \t\t\tvoid *datum)\n {\n-  flagword flags = bfd_get_section_flags (abfd, asect);\n-  const char *name = bfd_section_name (abfd, asect);\n+  flagword flags = bfd_section_flags (asect);\n+  const char *name = bfd_section_name (asect);\n   maint_print_section_data *print_data = (maint_print_section_data *) datum;\n   const char *arg = print_data->arg;\n \n@@ -348,8 +348,8 @@ print_bfd_section_info (bfd *abfd,\n       int addr_size = gdbarch_addr_bit (gdbarch) / 8;\n       CORE_ADDR addr, endaddr;\n \n-      addr = bfd_section_vma (abfd, asect);\n-      endaddr = addr + bfd_section_size (abfd, asect);\n+      addr = bfd_section_vma (asect);\n+      endaddr = addr + bfd_section_size (asect);\n       print_section_index (abfd, asect, print_data->index_digits);\n       maint_print_section_info (name, flags, addr, endaddr,\n \t\t\t\tasect->filepos, addr_size);\n@@ -366,8 +366,8 @@ print_objfile_section_info (bfd *abfd,\n \t\t\t    struct obj_section *asect,\n \t\t\t    maint_print_section_data *print_data)\n {\n-  flagword flags = bfd_get_section_flags (abfd, asect->the_bfd_section);\n-  const char *name = bfd_section_name (abfd, asect->the_bfd_section);\n+  flagword flags = bfd_section_flags (asect->the_bfd_section);\n+  const char *name = bfd_section_name (asect->the_bfd_section);\n   const char *string = print_data->arg;\n \n   if (string == NULL || *string == '\\0'"
    },
    {
      "sha": "0956fbdb6755467e187eac38799e21edbb7df6a0",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2338,7 +2338,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n      the text section (and fh->adr) really starts at zero.  */\n   text_sect = bfd_get_section_by_name (cur_bfd, \".text\");\n   if (text_sect != NULL\n-      && (bfd_get_section_flags (cur_bfd, text_sect) & SEC_RELOC))\n+      && (bfd_section_flags (text_sect) & SEC_RELOC))\n     relocatable = 1;\n \n   extern_tab = XOBNEWVEC (&objfile->objfile_obstack, EXTR, hdr->iextMax);"
    },
    {
      "sha": "7659e2803823b927a2928d69c660b9e6ada59708",
      "filename": "gdb/mi/mi-interp.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mi/mi-interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mi/mi-interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-interp.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1179,8 +1179,7 @@ mi_memory_changed (struct inferior *inferior, CORE_ADDR memaddr,\n       sec = find_pc_section (memaddr);\n       if (sec != NULL && sec->objfile != NULL)\n \t{\n-\t  flagword flags = bfd_get_section_flags (sec->objfile->obfd,\n-\t\t\t\t\t\t  sec->the_bfd_section);\n+\t  flagword flags = bfd_section_flags (sec->the_bfd_section);\n \n \t  if (flags & SEC_CODE)\n \t    mi_uiout->field_string (\"type\", \"code\");"
    },
    {
      "sha": "2a60741dfaff687b37f07986a69ea48876cebd5e",
      "filename": "gdb/minidebug.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/minidebug.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/minidebug.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minidebug.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -87,7 +87,7 @@ lzma_open (struct bfd *nbfd, void *open_closure)\n   struct gdb_lzma_stream *lstream;\n   size_t pos;\n \n-  size = bfd_get_section_size (section);\n+  size = bfd_section_size (section);\n   offset = section->filepos + size - LZMA_STREAM_HEADER_SIZE;\n   if (size < LZMA_STREAM_HEADER_SIZE\n       || bfd_seek (section->owner, offset, SEEK_SET) != 0"
    },
    {
      "sha": "eab284da1304b36c8c1903cfc9c120d71d416620",
      "filename": "gdb/mips-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mips-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mips-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-linux-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -562,7 +562,7 @@ mips_linux_core_read_description (struct gdbarch *gdbarch,\n   if (! section)\n     return NULL;\n \n-  switch (bfd_section_size (abfd, section))\n+  switch (bfd_section_size (section))\n     {\n     case sizeof (mips_elf_gregset_t):\n       return mips_tdesc_gp32;"
    },
    {
      "sha": "791a5991ad54384c21d7d8220feb18b2896b8d80",
      "filename": "gdb/mips-sde-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mips-sde-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mips-sde-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-sde-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -208,7 +208,7 @@ mips_sde_elf_osabi_sniff_abi_tag_sections (bfd *abfd, asection *sect,\n   enum gdb_osabi *os_ident_ptr = (enum gdb_osabi *) obj;\n   const char *name;\n \n-  name = bfd_get_section_name (abfd, sect);\n+  name = bfd_section_name (sect);\n \n   /* The presence of a section with a \".sde\" prefix is indicative\n      of an SDE binary.  */"
    },
    {
      "sha": "6870db82024a4b3f9344bb2f7bbe0f530bfb1810",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -7975,7 +7975,7 @@ static void\n mips_find_abi_section (bfd *abfd, asection *sect, void *obj)\n {\n   enum mips_abi *abip = (enum mips_abi *) obj;\n-  const char *name = bfd_get_section_name (abfd, sect);\n+  const char *name = bfd_section_name (sect);\n \n   if (*abip != MIPS_ABI_UNKNOWN)\n     return;\n@@ -8003,7 +8003,7 @@ static void\n mips_find_long_section (bfd *abfd, asection *sect, void *obj)\n {\n   int *lbp = (int *) obj;\n-  const char *name = bfd_get_section_name (abfd, sect);\n+  const char *name = bfd_section_name (sect);\n \n   if (startswith (name, \".gcc_compiled_long32\"))\n     *lbp = 32;"
    },
    {
      "sha": "b5f7f6cde4b92e79387aa67767443e005539c031",
      "filename": "gdb/mipsread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mipsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/mipsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mipsread.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -200,10 +200,10 @@ read_alphacoff_dynamic_symtab (minimal_symbol_reader &reader,\n       || si.dyninfo_sect == NULL || si.got_sect == NULL)\n     return;\n \n-  gdb::byte_vector sym_sec (bfd_get_section_size (si.sym_sect));\n-  gdb::byte_vector str_sec (bfd_get_section_size (si.str_sect));\n-  gdb::byte_vector dyninfo_sec (bfd_get_section_size (si.dyninfo_sect));\n-  gdb::byte_vector got_sec (bfd_get_section_size (si.got_sect));\n+  gdb::byte_vector sym_sec (bfd_section_size (si.sym_sect));\n+  gdb::byte_vector str_sec (bfd_section_size (si.str_sect));\n+  gdb::byte_vector dyninfo_sec (bfd_section_size (si.dyninfo_sect));\n+  gdb::byte_vector got_sec (bfd_section_size (si.got_sect));\n \n   if (!bfd_get_section_contents (abfd, si.sym_sect, sym_sec.data (),\n \t\t\t\t (file_ptr) 0, sym_sec.size ()))"
    },
    {
      "sha": "41b4e257373ddbd0cee8c752ced6ffbbfb752986",
      "filename": "gdb/nto-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/nto-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/nto-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nto-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -319,8 +319,8 @@ nto_sniff_abi_note_section (bfd *abfd, asection *sect, void *obj)\n   const char *name;\n   const unsigned sizeof_Elf_Nhdr = 12;\n \n-  sectname = bfd_get_section_name (abfd, sect);\n-  sectsize = bfd_section_size (abfd, sect);\n+  sectname = bfd_section_name (sect);\n+  sectsize = bfd_section_size (sect);\n \n   if (sectsize > 128)\n     sectsize = 128;"
    },
    {
      "sha": "90c4650bd47bec55dfdebab523dbc41f07e16869",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -271,7 +271,7 @@ add_to_objfile_sections_full (struct bfd *abfd, struct bfd_section *asect,\n     {\n       flagword aflag;\n \n-      aflag = bfd_get_section_flags (abfd, asect);\n+      aflag = bfd_section_flags (asect);\n       if (!(aflag & SEC_ALLOC))\n \treturn;\n     }\n@@ -1119,15 +1119,15 @@ static int\n insert_section_p (const struct bfd *abfd,\n \t\t  const struct bfd_section *section)\n {\n-  const bfd_vma lma = bfd_section_lma (abfd, section);\n+  const bfd_vma lma = bfd_section_lma (section);\n \n-  if (overlay_debugging && lma != 0 && lma != bfd_section_vma (abfd, section)\n+  if (overlay_debugging && lma != 0 && lma != bfd_section_vma (section)\n       && (bfd_get_file_flags (abfd) & BFD_IN_MEMORY) == 0)\n     /* This is an overlay section.  IN_MEMORY check is needed to avoid\n        discarding sections from the \"system supplied DSO\" (aka vdso)\n        on some Linux systems (e.g. Fedora 11).  */\n     return 0;\n-  if ((bfd_get_section_flags (abfd, section) & SEC_THREAD_LOCAL) != 0)\n+  if ((bfd_section_flags (section) & SEC_THREAD_LOCAL) != 0)\n     /* This is a TLS section.  */\n     return 0;\n \n@@ -1220,10 +1220,10 @@ filter_overlapping_sections (struct obj_section **map, int map_size)\n \t\t\t   \" (A) section `%s' from `%s' [%s, %s)\\n\"\n \t\t\t   \" (B) section `%s' from `%s' [%s, %s).\\n\"\n \t\t\t   \"Will ignore section B\"),\n-\t\t\t bfd_section_name (abfd1, bfds1), objfile_name (objf1),\n+\t\t\t bfd_section_name (bfds1), objfile_name (objf1),\n \t\t\t paddress (gdbarch, sect1_addr),\n \t\t\t paddress (gdbarch, sect1_endaddr),\n-\t\t\t bfd_section_name (abfd2, bfds2), objfile_name (objf2),\n+\t\t\t bfd_section_name (bfds2), objfile_name (objf2),\n \t\t\t paddress (gdbarch, sect2_addr),\n \t\t\t paddress (gdbarch, sect2_endaddr));\n \t    }"
    },
    {
      "sha": "68d36d408e1f605692c234ec8d13ff0d738ee67a",
      "filename": "gdb/objfiles.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/objfiles.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/objfiles.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.h?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -143,14 +143,14 @@ struct obj_section\n \n /* The memory address of section S (vma + offset).  */\n #define obj_section_addr(s)\t\t\t\t      \t\t\\\n-  (bfd_get_section_vma ((s)->objfile->obfd, s->the_bfd_section)\t\t\\\n+  (bfd_section_vma (s->the_bfd_section)\t\t\t\t\t\\\n    + obj_section_offset (s))\n \n /* The one-passed-the-end memory address of section S\n    (vma + size + offset).  */\n #define obj_section_endaddr(s)\t\t\t\t\t\t\\\n-  (bfd_get_section_vma ((s)->objfile->obfd, s->the_bfd_section)\t\t\\\n-   + bfd_get_section_size ((s)->the_bfd_section)\t\t\t\\\n+  (bfd_section_vma (s->the_bfd_section)\t\t\t\t\t\\\n+   + bfd_section_size ((s)->the_bfd_section)\t\t\t\t\\\n    + obj_section_offset (s))\n \n /* The \"objstats\" structure provides a place for gdb to record some"
    },
    {
      "sha": "cdf72a7664f82fe8140ffd8b5900848355b1081b",
      "filename": "gdb/osabi.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/osabi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/osabi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/osabi.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -416,7 +416,7 @@ check_note (bfd *abfd, asection *sect, char *note, unsigned int *sectsize,\n   gdb_assert (notesz <= MAX_NOTESZ);\n \n   /* Check whether SECT is big enough to comtain the complete note.  */\n-  if (notesz > bfd_section_size (abfd, sect))\n+  if (notesz > bfd_section_size (sect))\n     return 0;\n \n   /* Check the note name.  */\n@@ -445,8 +445,8 @@ generic_elf_osabi_sniff_abi_tag_sections (bfd *abfd, asection *sect, void *obj)\n   unsigned int sectsize;\n   char *note;\n \n-  name = bfd_get_section_name (abfd, sect);\n-  sectsize = bfd_section_size (abfd, sect);\n+  name = bfd_section_name (sect);\n+  sectsize = bfd_section_size (sect);\n \n   /* Limit the amount of data to read.  */\n   if (sectsize > MAX_NOTESZ)"
    },
    {
      "sha": "c6181c9dd489164dfb2a8ea9c5f85e595c4d498a",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1558,7 +1558,7 @@ ppc_linux_write_pc (struct regcache *regcache, CORE_ADDR pc)\n static int\n ppc_linux_spu_section (bfd *abfd, asection *asect, void *user_data)\n {\n-  return startswith (bfd_section_name (abfd, asect), \"SPU/\");\n+  return startswith (bfd_section_name (asect), \"SPU/\");\n }\n \n static const struct target_desc *\n@@ -1580,7 +1580,7 @@ ppc_linux_core_read_description (struct gdbarch *gdbarch,\n   if (! section)\n     return NULL;\n \n-  switch (bfd_section_size (abfd, section))\n+  switch (bfd_section_size (section))\n     {\n     case 48 * 4:\n       features.wordsize = 4;"
    },
    {
      "sha": "6a7aabf877a4ebdbd30fac2e71f7312320542abf",
      "filename": "gdb/ppc64-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/ppc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/ppc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc64-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -593,8 +593,8 @@ ppc64_convert_from_func_ptr_addr (struct gdbarch *gdbarch,\n \t\t\t\t      s->the_bfd_section,\n \t\t\t\t      &buf, addr - s->addr, 8);\n       if (res != 0)\n-\treturn extract_unsigned_integer (buf, 8, byte_order)\n-\t\t- bfd_section_vma (s->bfd, s->the_bfd_section) + s->addr;\n+\treturn (extract_unsigned_integer (buf, 8, byte_order)\n+\t\t- bfd_section_vma (s->the_bfd_section) + s->addr);\n    }\n \n   return addr;"
    },
    {
      "sha": "b55459e4ad1a9198f710f979e3fdc8b35bd7a938",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1435,8 +1435,7 @@ record_btrace_target::xfer_partial (enum target_object object,\n \t    if (section != NULL)\n \t      {\n \t\t/* Check if the section we found is readonly.  */\n-\t\tif ((bfd_get_section_flags (section->the_bfd_section->owner,\n-\t\t\t\t\t    section->the_bfd_section)\n+\t\tif ((bfd_section_flags (section->the_bfd_section)\n \t\t     & SEC_READONLY) != 0)\n \t\t  {\n \t\t    /* Truncate the request to fit into this section.  */"
    },
    {
      "sha": "0c6cb621630c27be28d153b5c98fa9217913e86c",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -2350,9 +2350,9 @@ record_full_restore (void)\n \t\t\tosec ? \"succeeded\" : \"failed\");\n   if (osec == NULL)\n     return;\n-  osec_size = bfd_section_size (core_bfd, osec);\n+  osec_size = bfd_section_size (osec);\n   if (record_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"%s\", bfd_section_name (core_bfd, osec));\n+    fprintf_unfiltered (gdb_stdlog, \"%s\", bfd_section_name (osec));\n \n   /* Check the magic code.  */\n   bfdcore_read (core_bfd, osec, &magic, sizeof (magic), &bfd_offset);\n@@ -2599,10 +2599,9 @@ record_full_base_target::save_record (const char *recfilename)\n     error (_(\"Failed to create 'precord' section for corefile %s: %s\"),\n \t   recfilename,\n            bfd_errmsg (bfd_get_error ()));\n-  bfd_set_section_size (obfd.get (), osec, save_size);\n-  bfd_set_section_vma (obfd.get (), osec, 0);\n-  bfd_set_section_alignment (obfd.get (), osec, 0);\n-  bfd_section_lma (obfd.get (), osec) = 0;\n+  bfd_set_section_size (osec, save_size);\n+  bfd_set_section_vma (osec, 0);\n+  bfd_set_section_alignment (osec, 0);\n \n   /* Save corefile state.  */\n   write_gcore_file (obfd.get ());"
    },
    {
      "sha": "980864e0707351f26d99f1d007ecda141782d238",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -8749,9 +8749,7 @@ remote_target::remote_xfer_live_readonly_partial (gdb_byte *readbuf,\n \n   secp = target_section_by_addr (this, memaddr);\n   if (secp != NULL\n-      && (bfd_get_section_flags (secp->the_bfd_section->owner,\n-\t\t\t\t secp->the_bfd_section)\n-\t  & SEC_READONLY))\n+      && (bfd_section_flags (secp->the_bfd_section) & SEC_READONLY))\n     {\n       struct target_section *p;\n       ULONGEST memend = memaddr + len;\n@@ -10656,11 +10654,11 @@ compare_sections_command (const char *args, int from_tty)\n       if (read_only && (s->flags & SEC_READONLY) == 0)\n \tcontinue;\t\t/* Skip writeable sections */\n \n-      size = bfd_get_section_size (s);\n+      size = bfd_section_size (s);\n       if (size == 0)\n \tcontinue;\t\t/* Skip zero-length section.  */\n \n-      sectname = bfd_get_section_name (exec_bfd, s);\n+      sectname = bfd_section_name (s);\n       if (args && strcmp (args, sectname) != 0)\n \tcontinue;\t\t/* Not the section selected by user.  */\n \n@@ -13059,7 +13057,6 @@ void\n remote_target::trace_set_readonly_regions ()\n {\n   asection *s;\n-  bfd *abfd = NULL;\n   bfd_size_type size;\n   bfd_vma vma;\n   int anysecs = 0;\n@@ -13083,8 +13080,8 @@ remote_target::trace_set_readonly_regions ()\n \tcontinue;\n \n       anysecs = 1;\n-      vma = bfd_get_section_vma (abfd, s);\n-      size = bfd_get_section_size (s);\n+      vma = bfd_section_vma (s);\n+      size = bfd_section_size (s);\n       sprintf_vma (tmp1, vma);\n       sprintf_vma (tmp2, vma + size);\n       sec_length = 1 + strlen (tmp1) + 1 + strlen (tmp2);"
    },
    {
      "sha": "f2ff2557368f10c45d401abccf102d15f24e2af6",
      "filename": "gdb/rs6000-aix-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/rs6000-aix-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/rs6000-aix-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-aix-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1110,7 +1110,7 @@ rs6000_aix_core_xfer_shared_libraries_aix (struct gdbarch *gdbarch,\n   if (ldinfo_sec == NULL)\n     error (_(\"cannot find .ldinfo section from core file: %s\"),\n \t   bfd_errmsg (bfd_get_error ()));\n-  ldinfo_size = bfd_get_section_size (ldinfo_sec);\n+  ldinfo_size = bfd_section_size (ldinfo_sec);\n \n   gdb::byte_vector ldinfo_buf (ldinfo_size);\n "
    },
    {
      "sha": "47a232f6c6ad8e81655f222bb8aabe284cd87a9a",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -3866,7 +3866,7 @@ bfd_uses_spe_extensions (bfd *abfd)\n   if (!sect)\n     return 0;\n \n-  size = bfd_get_section_size (sect);\n+  size = bfd_section_size (sect);\n   contents = (gdb_byte *) xmalloc (size);\n   if (!bfd_get_section_contents (abfd, sect, contents, 0, size))\n     {"
    },
    {
      "sha": "ab3889ba45a725ad7b70ad6c0a7be61888bda102",
      "filename": "gdb/s390-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/s390-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/s390-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-linux-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -346,7 +346,7 @@ s390_core_read_description (struct gdbarch *gdbarch,\n   te = (hwcap & HWCAP_S390_TE);\n   gs = (hwcap & HWCAP_S390_GS);\n \n-  switch (bfd_section_size (abfd, section))\n+  switch (bfd_section_size (section))\n     {\n     case s390_sizeof_gregset:\n       if (high_gprs)"
    },
    {
      "sha": "463c0a0bd73ff28654facf9c3849f9e034db2fd0",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -697,9 +697,7 @@ s390_load (struct s390_prologue_data *data,\n       struct target_section *secp;\n       secp = target_section_by_addr (current_top_target (), addr.k);\n       if (secp != NULL\n-\t  && (bfd_get_section_flags (secp->the_bfd_section->owner,\n-\t\t\t\t     secp->the_bfd_section)\n-\t      & SEC_READONLY))\n+\t  && (bfd_section_flags (secp->the_bfd_section) & SEC_READONLY))\n \treturn pv_constant (read_memory_integer (addr.k, size,\n \t\t\t\t\t\t data->byte_order));\n     }"
    },
    {
      "sha": "8308190d90cd0f8933ef4b899e72dd13ce629ee1",
      "filename": "gdb/solib-aix.c",
      "status": "modified",
      "additions": 14,
      "deletions": 17,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-aix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-aix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-aix.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -303,15 +303,13 @@ solib_aix_bss_data_overlap (bfd *abfd)\n      section after the .data section (the problem has only been\n      observed when using the GNU linker, and the default linker\n      script always places the .data and .bss sections in that order).  */\n-  if (bfd_section_vma (abfd, bss_sect)\n-      < bfd_section_vma (abfd, data_sect))\n+  if (bfd_section_vma (bss_sect) < bfd_section_vma (data_sect))\n     return 0;\n \n-  if (bfd_section_vma (abfd, bss_sect)\n-      < bfd_section_vma (abfd, data_sect) + bfd_get_section_size (data_sect))\n-    return ((bfd_section_vma (abfd, data_sect)\n-\t     + bfd_get_section_size (data_sect))\n-\t    - bfd_section_vma (abfd, bss_sect));\n+  if (bfd_section_vma (bss_sect)\n+      < bfd_section_vma (data_sect) + bfd_section_size (data_sect))\n+    return (bfd_section_vma (data_sect) + bfd_section_size (data_sect)\n+\t    - bfd_section_vma (bss_sect));\n \n   return 0;\n }\n@@ -324,7 +322,7 @@ solib_aix_relocate_section_addresses (struct so_list *so,\n {\n   struct bfd_section *bfd_sect = sec->the_bfd_section;\n   bfd *abfd = bfd_sect->owner;\n-  const char *section_name = bfd_section_name (abfd, bfd_sect);\n+  const char *section_name = bfd_section_name (bfd_sect);\n   lm_info_aix *info = (lm_info_aix *) so->lm_info;\n \n   if (strcmp (section_name, \".text\") == 0)\n@@ -355,17 +353,17 @@ solib_aix_relocate_section_addresses (struct so_list *so,\n       CORE_ADDR data_offset = 0;\n \n       if (data_sect != NULL)\n-\tdata_offset = info->data_addr - bfd_section_vma (abfd, data_sect);\n+\tdata_offset = info->data_addr - bfd_section_vma (data_sect);\n \n-      sec->addr = bfd_section_vma (abfd, bfd_sect) + data_offset;\n+      sec->addr = bfd_section_vma (bfd_sect) + data_offset;\n       sec->addr += solib_aix_bss_data_overlap (abfd);\n-      sec->endaddr = sec->addr + bfd_section_size (abfd, bfd_sect);\n+      sec->endaddr = sec->addr + bfd_section_size (bfd_sect);\n     }\n   else\n     {\n       /* All other sections should not be relocated.  */\n-      sec->addr = bfd_section_vma (abfd, bfd_sect);\n-      sec->endaddr = sec->addr + bfd_section_size (abfd, bfd_sect);\n+      sec->addr = bfd_section_vma (bfd_sect);\n+      sec->endaddr = sec->addr + bfd_section_size (bfd_sect);\n     }\n }\n \n@@ -414,7 +412,7 @@ solib_aix_get_section_offsets (struct objfile *objfile,\n \t= objfile->sections[objfile->sect_index_text].the_bfd_section;\n \n       offsets->offsets[objfile->sect_index_text]\n-\t= info->text_addr + sect->filepos - bfd_section_vma (abfd, sect);\n+\t= info->text_addr + sect->filepos - bfd_section_vma (sect);\n     }\n \n   /* .data */\n@@ -425,7 +423,7 @@ solib_aix_get_section_offsets (struct objfile *objfile,\n \t= objfile->sections[objfile->sect_index_data].the_bfd_section;\n \n       offsets->offsets[objfile->sect_index_data]\n-\t= info->data_addr - bfd_section_vma (abfd, sect);\n+\t= info->data_addr - bfd_section_vma (sect);\n     }\n \n   /* .bss\n@@ -661,8 +659,7 @@ data_obj_section_from_objfile (struct objfile *objfile)\n   struct obj_section *osect;\n \n   ALL_OBJFILE_OSECTIONS (objfile, osect)\n-    if (strcmp (bfd_section_name (objfile->obfd, osect->the_bfd_section),\n-\t\t\".data\") == 0)\n+    if (strcmp (bfd_section_name (osect->the_bfd_section), \".data\") == 0)\n       return osect;\n \n   return NULL;"
    },
    {
      "sha": "70d6f2e314b668c6c20c1e258cbfdaf04a28285b",
      "filename": "gdb/solib-dsbt.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-dsbt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-dsbt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-dsbt.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -438,12 +438,12 @@ scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)\n \t such fallback to the file VMA address without the possibility of\n \t having the section relocated to its actual in-memory address.  */\n \n-      dyn_addr = bfd_section_vma (abfd, sect);\n+      dyn_addr = bfd_section_vma (sect);\n     }\n \n   /* Read in .dynamic from the BFD.  We will get the actual value\n      from memory later.  */\n-  sect_size = bfd_section_size (abfd, sect);\n+  sect_size = bfd_section_size (sect);\n   buf = bufstart = (gdb_byte *) alloca (sect_size);\n   if (!bfd_get_section_contents (abfd, sect,\n \t\t\t\t buf, 0, sect_size))\n@@ -807,7 +807,7 @@ enable_break (void)\n \n       /* Read the contents of the .interp section into a local buffer;\n \t the contents specify the dynamic linker this program uses.  */\n-      interp_sect_size = bfd_section_size (exec_bfd, interp_sect);\n+      interp_sect_size = bfd_section_size (interp_sect);\n       buf = (char *) alloca (interp_sect_size);\n       bfd_get_section_contents (exec_bfd, interp_sect,\n \t\t\t\tbuf, 0, interp_sect_size);\n@@ -839,24 +839,20 @@ enable_break (void)\n       interp_sect = bfd_get_section_by_name (tmp_bfd.get (), \".text\");\n       if (interp_sect)\n \t{\n-\t  info->interp_text_sect_low\n-\t    = bfd_section_vma (tmp_bfd.get (), interp_sect);\n+\t  info->interp_text_sect_low = bfd_section_vma (interp_sect);\n \t  info->interp_text_sect_low\n \t    += displacement_from_map (ldm, info->interp_text_sect_low);\n \t  info->interp_text_sect_high\n-\t    = info->interp_text_sect_low\n-\t    + bfd_section_size (tmp_bfd.get (), interp_sect);\n+\t    = info->interp_text_sect_low + bfd_section_size (interp_sect);\n \t}\n       interp_sect = bfd_get_section_by_name (tmp_bfd.get (), \".plt\");\n       if (interp_sect)\n \t{\n-\t  info->interp_plt_sect_low =\n-\t    bfd_section_vma (tmp_bfd.get (), interp_sect);\n+\t  info->interp_plt_sect_low = bfd_section_vma (interp_sect);\n \t  info->interp_plt_sect_low\n \t    += displacement_from_map (ldm, info->interp_plt_sect_low);\n-\t  info->interp_plt_sect_high =\n-\t    info->interp_plt_sect_low + bfd_section_size (tmp_bfd.get (),\n-\t\t\t\t\t\t\t  interp_sect);\n+\t  info->interp_plt_sect_high\n+\t    = info->interp_plt_sect_low + bfd_section_size (interp_sect);\n \t}\n \n       addr = gdb_bfd_lookup_symbol (tmp_bfd.get (), cmp_name,"
    },
    {
      "sha": "08fa5768676bedabf9216ddc45194ab5ba952873",
      "filename": "gdb/solib-frv.c",
      "status": "modified",
      "additions": 5,
      "deletions": 9,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-frv.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -546,7 +546,7 @@ enable_break2 (void)\n \n       /* Read the contents of the .interp section into a local buffer;\n          the contents specify the dynamic linker this program uses.  */\n-      interp_sect_size = bfd_section_size (exec_bfd, interp_sect);\n+      interp_sect_size = bfd_section_size (interp_sect);\n       buf = (char *) alloca (interp_sect_size);\n       bfd_get_section_contents (exec_bfd, interp_sect,\n \t\t\t\tbuf, 0, interp_sect_size);\n@@ -603,24 +603,20 @@ enable_break2 (void)\n       interp_sect = bfd_get_section_by_name (tmp_bfd.get (), \".text\");\n       if (interp_sect)\n \t{\n-\t  interp_text_sect_low\n-\t    = bfd_section_vma (tmp_bfd.get (), interp_sect);\n+\t  interp_text_sect_low = bfd_section_vma (interp_sect);\n \t  interp_text_sect_low\n \t    += displacement_from_map (ldm, interp_text_sect_low);\n \t  interp_text_sect_high\n-\t    = interp_text_sect_low + bfd_section_size (tmp_bfd.get (),\n-\t\t\t\t\t\t       interp_sect);\n+\t    = interp_text_sect_low + bfd_section_size (interp_sect);\n \t}\n       interp_sect = bfd_get_section_by_name (tmp_bfd.get (), \".plt\");\n       if (interp_sect)\n \t{\n-\t  interp_plt_sect_low =\n-\t    bfd_section_vma (tmp_bfd.get (), interp_sect);\n+\t  interp_plt_sect_low = bfd_section_vma (interp_sect);\n \t  interp_plt_sect_low\n \t    += displacement_from_map (ldm, interp_plt_sect_low);\n \t  interp_plt_sect_high =\n-\t    interp_plt_sect_low + bfd_section_size (tmp_bfd.get (),\n-\t\t\t\t\t\t    interp_sect);\n+\t    interp_plt_sect_low + bfd_section_size (interp_sect);\n \t}\n \n       addr = gdb_bfd_lookup_symbol (tmp_bfd.get (), cmp_name, \"_dl_debug_addr\");"
    },
    {
      "sha": "49e470adb62dadb4c4e3849899f8819cc78c885a",
      "filename": "gdb/solib-spu.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-spu.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -364,7 +364,7 @@ spu_bfd_open (const char *pathname)\n   spu_name = bfd_get_section_by_name (abfd.get (), \".note.spu_name\");\n   if (spu_name)\n     {\n-      int sect_size = bfd_section_size (abfd.get (), spu_name);\n+      int sect_size = bfd_section_size (spu_name);\n \n       if (sect_size > 20)\n \t{"
    },
    {
      "sha": "e04fde942d15b8fb0d9827d77f1794b35a3c76d3",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 27,
      "deletions": 32,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -234,7 +234,7 @@ lm_addr_check (const struct so_list *so, bfd *abfd)\n       if (dyninfo_sect == NULL)\n \tgoto set_addr;\n \n-      dynaddr = bfd_section_vma (abfd, dyninfo_sect);\n+      dynaddr = bfd_section_vma (dyninfo_sect);\n \n       if (dynaddr + l_addr != l_dynaddr)\n \t{\n@@ -559,7 +559,7 @@ find_program_interpreter (void)\n      interp_sect = bfd_get_section_by_name (exec_bfd, \".interp\");\n      if (interp_sect != NULL)\n       {\n-\tint sect_size = bfd_section_size (exec_bfd, interp_sect);\n+\tint sect_size = bfd_section_size (interp_sect);\n \n \tgdb::byte_vector buf (sect_size);\n \tbfd_get_section_contents (exec_bfd, interp_sect, buf.data (), 0,\n@@ -618,12 +618,12 @@ scan_dyntag (const int desired_dyntag, bfd *abfd, CORE_ADDR *ptr,\n \t such fallback to the file VMA address without the possibility of\n \t having the section relocated to its actual in-memory address.  */\n \n-      dyn_addr = bfd_section_vma (abfd, sect);\n+      dyn_addr = bfd_section_vma (sect);\n     }\n \n   /* Read in .dynamic from the BFD.  We will get the actual value\n      from memory later.  */\n-  sect_size = bfd_section_size (abfd, sect);\n+  sect_size = bfd_section_size (sect);\n   buf = bufstart = (gdb_byte *) alloca (sect_size);\n   if (!bfd_get_section_contents (abfd, sect,\n \t\t\t\t buf, 0, sect_size))\n@@ -2255,20 +2255,18 @@ enable_break (struct svr4_info *info, int from_tty)\n \t  interp_sect = bfd_get_section_by_name (tmp_bfd, \".text\");\n \t  if (interp_sect)\n \t    {\n-\t      info->interp_text_sect_low =\n-\t\tbfd_section_vma (tmp_bfd, interp_sect) + load_addr;\n-\t      info->interp_text_sect_high =\n-\t\tinfo->interp_text_sect_low\n-\t\t+ bfd_section_size (tmp_bfd, interp_sect);\n+\t      info->interp_text_sect_low\n+\t\t= bfd_section_vma (interp_sect) + load_addr;\n+\t      info->interp_text_sect_high\n+\t\t= info->interp_text_sect_low + bfd_section_size (interp_sect);\n \t    }\n \t  interp_sect = bfd_get_section_by_name (tmp_bfd, \".plt\");\n \t  if (interp_sect)\n \t    {\n-\t      info->interp_plt_sect_low =\n-\t\tbfd_section_vma (tmp_bfd, interp_sect) + load_addr;\n-\t      info->interp_plt_sect_high =\n-\t\tinfo->interp_plt_sect_low\n-\t\t+ bfd_section_size (tmp_bfd, interp_sect);\n+\t      info->interp_plt_sect_low\n+\t\t= bfd_section_vma (interp_sect) + load_addr;\n+\t      info->interp_plt_sect_high\n+\t\t= info->interp_plt_sect_low + bfd_section_size (interp_sect);\n \t    }\n \n \t  svr4_create_solib_event_breakpoints (info, target_gdbarch (), sym_addr);\n@@ -2392,20 +2390,18 @@ enable_break (struct svr4_info *info, int from_tty)\n       interp_sect = bfd_get_section_by_name (tmp_bfd.get (), \".text\");\n       if (interp_sect)\n \t{\n-\t  info->interp_text_sect_low =\n-\t    bfd_section_vma (tmp_bfd.get (), interp_sect) + load_addr;\n-\t  info->interp_text_sect_high =\n-\t    info->interp_text_sect_low\n-\t    + bfd_section_size (tmp_bfd.get (), interp_sect);\n+\t  info->interp_text_sect_low\n+\t    = bfd_section_vma (interp_sect) + load_addr;\n+\t  info->interp_text_sect_high\n+\t    = info->interp_text_sect_low + bfd_section_size (interp_sect);\n \t}\n       interp_sect = bfd_get_section_by_name (tmp_bfd.get (), \".plt\");\n       if (interp_sect)\n \t{\n-\t  info->interp_plt_sect_low =\n-\t    bfd_section_vma (tmp_bfd.get (), interp_sect) + load_addr;\n-\t  info->interp_plt_sect_high =\n-\t    info->interp_plt_sect_low\n-\t    + bfd_section_size (tmp_bfd.get (), interp_sect);\n+\t  info->interp_plt_sect_low\n+\t    = bfd_section_vma (interp_sect) + load_addr;\n+\t  info->interp_plt_sect_high\n+\t    = info->interp_plt_sect_low + bfd_section_size (interp_sect);\n \t}\n \n       /* Now try to set a breakpoint in the dynamic linker.  */\n@@ -2733,7 +2729,7 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t\t      gdb_byte *buf_filesz_p = (gdb_byte *) &phdrp->p_filesz;\n \t\t      CORE_ADDR filesz;\n \n-\t\t      content2 = (bfd_get_section_flags (exec_bfd, plt2_asect)\n+\t\t      content2 = (bfd_section_flags (plt2_asect)\n \t\t\t\t  & SEC_HAS_CONTENTS) != 0;\n \n \t\t      filesz = extract_unsigned_integer (buf_filesz_p, 4,\n@@ -2742,9 +2738,9 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t\t      /* PLT2_ASECT is from on-disk file (exec_bfd) while\n \t\t\t FILESZ is from the in-memory image.  */\n \t\t      if (content2)\n-\t\t\tfilesz += bfd_get_section_size (plt2_asect);\n+\t\t\tfilesz += bfd_section_size (plt2_asect);\n \t\t      else\n-\t\t\tfilesz -= bfd_get_section_size (plt2_asect);\n+\t\t\tfilesz -= bfd_section_size (plt2_asect);\n \n \t\t      store_unsigned_integer (buf_filesz_p, 4, byte_order,\n \t\t\t\t\t      filesz);\n@@ -2867,7 +2863,7 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t\t      gdb_byte *buf_filesz_p = (gdb_byte *) &phdrp->p_filesz;\n \t\t      CORE_ADDR filesz;\n \n-\t\t      content2 = (bfd_get_section_flags (exec_bfd, plt2_asect)\n+\t\t      content2 = (bfd_section_flags (plt2_asect)\n \t\t\t\t  & SEC_HAS_CONTENTS) != 0;\n \n \t\t      filesz = extract_unsigned_integer (buf_filesz_p, 8,\n@@ -2876,9 +2872,9 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t\t      /* PLT2_ASECT is from on-disk file (exec_bfd) while\n \t\t\t FILESZ is from the in-memory image.  */\n \t\t      if (content2)\n-\t\t\tfilesz += bfd_get_section_size (plt2_asect);\n+\t\t\tfilesz += bfd_section_size (plt2_asect);\n \t\t      else\n-\t\t\tfilesz -= bfd_get_section_size (plt2_asect);\n+\t\t\tfilesz -= bfd_section_size (plt2_asect);\n \n \t\t      store_unsigned_integer (buf_filesz_p, 8, byte_order,\n \t\t\t\t\t      filesz);\n@@ -2972,8 +2968,7 @@ svr4_relocate_main_executable (void)\n \n       for (asect = exec_bfd->sections; asect != NULL; asect = asect->next)\n \texec_set_section_address (bfd_get_filename (exec_bfd), asect->index,\n-\t\t\t\t  (bfd_section_vma (exec_bfd, asect)\n-\t\t\t\t   + displacement));\n+\t\t\t\t  bfd_section_vma (asect) + displacement);\n     }\n }\n "
    },
    {
      "sha": "3fd180850c14cf0ae8fc151b94966772c4968a8d",
      "filename": "gdb/solib-target.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/solib-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-target.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -323,7 +323,7 @@ solib_target_relocate_section_addresses (struct so_list *so,\n \t  for (i = 0, sect = so->abfd->sections;\n \t       sect != NULL;\n \t       i++, sect = sect->next)\n-\t    if ((bfd_get_section_flags (so->abfd, sect) & SEC_ALLOC))\n+\t    if ((bfd_section_flags (sect) & SEC_ALLOC))\n \t      num_alloc_sections++;\n \n \t  if (num_alloc_sections != li->section_bases.size ())\n@@ -341,14 +341,14 @@ Could not relocate shared library \\\"%s\\\": wrong number of ALLOC sections\"),\n \t\t   sect != NULL;\n \t\t   i++, sect = sect->next)\n \t\t{\n-\t\t  if (!(bfd_get_section_flags (so->abfd, sect) & SEC_ALLOC))\n+\t\t  if (!(bfd_section_flags (sect) & SEC_ALLOC))\n \t\t    continue;\n-\t\t  if (bfd_section_size (so->abfd, sect) > 0)\n+\t\t  if (bfd_section_size (sect) > 0)\n \t\t    {\n \t\t      CORE_ADDR low, high;\n \n \t\t      low = li->section_bases[i];\n-\t\t      high = low + bfd_section_size (so->abfd, sect) - 1;\n+\t\t      high = low + bfd_section_size (sect) - 1;\n \n \t\t      if (low < so->addr_low)\n \t\t\tso->addr_low = low;"
    },
    {
      "sha": "635366b4f1d4ccbbe8d53f4861dd2a43d4f0c975",
      "filename": "gdb/spu-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/spu-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/spu-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/spu-linux-nat.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -363,7 +363,7 @@ spu_bfd_open (ULONGEST addr)\n   spu_name = bfd_get_section_by_name (nbfd.get (), \".note.spu_name\");\n   if (spu_name)\n     {\n-      int sect_size = bfd_section_size (nbfd.get (), spu_name);\n+      int sect_size = bfd_section_size (spu_name);\n       if (sect_size > 20)\n \t{\n \t  char *buf = (char *)alloca (sect_size - 20 + 1);"
    },
    {
      "sha": "5360efb12f7da299f9dcf4f3f71b7992f8e0feaf",
      "filename": "gdb/spu-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/spu-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/spu-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/spu-tdep.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1833,7 +1833,7 @@ spu_get_overlay_table (struct objfile *objfile)\n \tcontinue;\n \n       ALL_OBJFILE_OSECTIONS (objfile, osect)\n-\tif (vma == bfd_section_vma (objfile->obfd, osect->the_bfd_section)\n+\tif (vma == bfd_section_vma (osect->the_bfd_section)\n \t    && pos == osect->the_bfd_section->filepos)\n \t  {\n \t    int ndx = osect - objfile->sections;\n@@ -1921,9 +1921,9 @@ spu_overlay_new_objfile (struct objfile *objfile)\n       int ndx = osect - objfile->sections;\n \n       if (ovly_table[ndx].mapped_ptr == 0)\n-\tbfd_section_lma (obfd, bsect) = bfd_section_vma (obfd, bsect);\n+\tbfd_set_section_lma (bsect, bfd_section_vma (bsect));\n       else\n-\tbfd_section_lma (obfd, bsect) = SPU_OVERLAY_LMA + bsect->filepos;\n+\tbfd_set_section_lma (bsect, SPU_OVERLAY_LMA + bsect->filepos);\n     }\n }\n "
    },
    {
      "sha": "82fb17ed1654f7688fd75de0706b9ef38af3065e",
      "filename": "gdb/symfile-mem.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/symfile-mem.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/symfile-mem.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile-mem.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -111,9 +111,9 @@ symbol_file_add_from_memory (struct bfd *templ, CORE_ADDR addr,\n \n   section_addr_info sai;\n   for (sec = nbfd->sections; sec != NULL; sec = sec->next)\n-    if ((bfd_get_section_flags (nbfd, sec) & (SEC_ALLOC|SEC_LOAD)) != 0)\n-      sai.emplace_back (bfd_get_section_vma (nbfd, sec) + loadbase,\n-\t\t\tbfd_get_section_name (nbfd, sec),\n+    if ((bfd_section_flags (sec) & (SEC_ALLOC|SEC_LOAD)) != 0)\n+      sai.emplace_back (bfd_section_vma (sec) + loadbase,\n+\t\t\tbfd_section_name (sec),\n \t\t\tsec->index);\n \n   if (from_tty)"
    },
    {
      "sha": "b914b05a1754547b3376d1de2613e821f3b7cd41",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 57,
      "deletions": 62,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -200,15 +200,14 @@ find_lowest_section (bfd *abfd, asection *sect, void *obj)\n {\n   asection **lowest = (asection **) obj;\n \n-  if (0 == (bfd_get_section_flags (abfd, sect) & (SEC_ALLOC | SEC_LOAD)))\n+  if (0 == (bfd_section_flags (sect) & (SEC_ALLOC | SEC_LOAD)))\n     return;\n   if (!*lowest)\n     *lowest = sect;\t\t/* First loadable section */\n-  else if (bfd_section_vma (abfd, *lowest) > bfd_section_vma (abfd, sect))\n+  else if (bfd_section_vma (*lowest) > bfd_section_vma (sect))\n     *lowest = sect;\t\t/* A lower loadable section */\n-  else if (bfd_section_vma (abfd, *lowest) == bfd_section_vma (abfd, sect)\n-\t   && (bfd_section_size (abfd, (*lowest))\n-\t       <= bfd_section_size (abfd, sect)))\n+  else if (bfd_section_vma (*lowest) == bfd_section_vma (sect)\n+\t   && (bfd_section_size (*lowest) <= bfd_section_size (sect)))\n     *lowest = sect;\n }\n \n@@ -228,10 +227,10 @@ build_section_addr_info_from_section_table (const struct target_section *start,\n       struct bfd_section *asect = stp->the_bfd_section;\n       bfd *abfd = asect->owner;\n \n-      if (bfd_get_section_flags (abfd, asect) & (SEC_ALLOC | SEC_LOAD)\n+      if (bfd_section_flags (asect) & (SEC_ALLOC | SEC_LOAD)\n \t  && sap.size () < end - start)\n \tsap.emplace_back (stp->addr,\n-\t\t\t  bfd_section_name (abfd, asect),\n+\t\t\t  bfd_section_name (asect),\n \t\t\t  gdb_bfd_section_index (abfd, asect));\n     }\n \n@@ -247,9 +246,9 @@ build_section_addr_info_from_bfd (bfd *abfd)\n \n   section_addr_info sap;\n   for (sec = abfd->sections; sec != NULL; sec = sec->next)\n-    if (bfd_get_section_flags (abfd, sec) & (SEC_ALLOC | SEC_LOAD))\n-      sap.emplace_back (bfd_get_section_vma (abfd, sec),\n-\t\t\tbfd_get_section_name (abfd, sec),\n+    if (bfd_section_flags (sec) & (SEC_ALLOC | SEC_LOAD))\n+      sap.emplace_back (bfd_section_vma (sec),\n+\t\t\tbfd_section_name (sec),\n \t\t\tgdb_bfd_section_index (abfd, sec));\n \n   return sap;\n@@ -353,10 +352,10 @@ place_section (bfd *abfd, asection *sect, void *obj)\n   struct place_section_arg *arg = (struct place_section_arg *) obj;\n   CORE_ADDR *offsets = arg->offsets->offsets, start_addr;\n   int done;\n-  ULONGEST align = ((ULONGEST) 1) << bfd_get_section_alignment (abfd, sect);\n+  ULONGEST align = ((ULONGEST) 1) << bfd_section_alignment (sect);\n \n   /* We are only interested in allocated sections.  */\n-  if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)\n+  if ((bfd_section_flags (sect) & SEC_ALLOC) == 0)\n     return;\n \n   /* If the user specified an offset, honor it.  */\n@@ -380,7 +379,7 @@ place_section (bfd *abfd, asection *sect, void *obj)\n \t  continue;\n \n \t/* We can only conflict with allocated sections.  */\n-\tif ((bfd_get_section_flags (abfd, cur_sec) & SEC_ALLOC) == 0)\n+\tif ((bfd_section_flags (cur_sec) & SEC_ALLOC) == 0)\n \t  continue;\n \n \t/* If the section offset is 0, either the section has not been placed\n@@ -390,10 +389,10 @@ place_section (bfd *abfd, asection *sect, void *obj)\n \t  continue;\n \n \t/* If this section would overlap us, then we must move up.  */\n-\tif (start_addr + bfd_get_section_size (sect) > offsets[indx]\n-\t    && start_addr < offsets[indx] + bfd_get_section_size (cur_sec))\n+\tif (start_addr + bfd_section_size (sect) > offsets[indx]\n+\t    && start_addr < offsets[indx] + bfd_section_size (cur_sec))\n \t  {\n-\t    start_addr = offsets[indx] + bfd_get_section_size (cur_sec);\n+\t    start_addr = offsets[indx] + bfd_section_size (cur_sec);\n \t    start_addr = (start_addr + align - 1) & -align;\n \t    done = 0;\n \t    break;\n@@ -405,7 +404,7 @@ place_section (bfd *abfd, asection *sect, void *obj)\n   while (!done);\n \n   offsets[gdb_bfd_section_index (abfd, sect)] = start_addr;\n-  arg->lowest = start_addr + bfd_get_section_size (sect);\n+  arg->lowest = start_addr + bfd_section_size (sect);\n }\n \n /* Store section_addr_info as prepared (made relative and with SECTINDEX\n@@ -510,7 +509,7 @@ addr_info_make_relative (section_addr_info *addrs, bfd *abfd)\n       lower_offset = 0;\n     }\n   else\n-    lower_offset = bfd_section_vma (bfd_get_filename (abfd), lower_sect);\n+    lower_offset = bfd_section_vma (lower_sect);\n \n   /* Create ADDRS_TO_ABFD_ADDRS array to map the sections in ADDRS to sections\n      in ABFD.  Section names are not unique - there can be multiple sections of\n@@ -658,7 +657,7 @@ default_symfile_offsets (struct objfile *objfile,\n       for (cur_sec = abfd->sections; cur_sec != NULL; cur_sec = cur_sec->next)\n \t/* We do not expect this to happen; just skip this step if the\n \t   relocatable file has a section with an assigned VMA.  */\n-\tif (bfd_section_vma (abfd, cur_sec) != 0)\n+\tif (bfd_section_vma (cur_sec) != 0)\n \t  break;\n \n       if (cur_sec == NULL)\n@@ -700,10 +699,10 @@ default_symfile_offsets (struct objfile *objfile,\n \t  for (cur_sec = abfd->sections; cur_sec != NULL;\n \t       cur_sec = cur_sec->next)\n \t    {\n-\t      if ((bfd_get_section_flags (abfd, cur_sec) & SEC_ALLOC) == 0)\n+\t      if ((bfd_section_flags (cur_sec) & SEC_ALLOC) == 0)\n \t\tcontinue;\n \n-\t      bfd_set_section_vma (abfd, cur_sec, offsets[cur_sec->index]);\n+\t      bfd_set_section_vma (cur_sec, offsets[cur_sec->index]);\n \t      exec_set_section_address (bfd_get_filename (abfd),\n \t\t\t\t\tcur_sec->index,\n \t\t\t\t\toffsets[cur_sec->index]);\n@@ -740,16 +739,16 @@ default_symfile_segments (bfd *abfd)\n   /* Make sure there is at least one loadable section in the file.  */\n   for (sect = abfd->sections; sect != NULL; sect = sect->next)\n     {\n-      if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)\n+      if ((bfd_section_flags (sect) & SEC_ALLOC) == 0)\n \tcontinue;\n \n       break;\n     }\n   if (sect == NULL)\n     return NULL;\n \n-  low = bfd_get_section_vma (abfd, sect);\n-  high = low + bfd_get_section_size (sect);\n+  low = bfd_section_vma (sect);\n+  high = low + bfd_section_size (sect);\n \n   data = XCNEW (struct symfile_segment_data);\n   data->num_segments = 1;\n@@ -763,14 +762,14 @@ default_symfile_segments (bfd *abfd)\n     {\n       CORE_ADDR vma;\n \n-      if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)\n+      if ((bfd_section_flags (sect) & SEC_ALLOC) == 0)\n \tcontinue;\n \n-      vma = bfd_get_section_vma (abfd, sect);\n+      vma = bfd_section_vma (sect);\n       if (vma < low)\n \tlow = vma;\n-      if (vma + bfd_get_section_size (sect) > high)\n-\thigh = vma + bfd_get_section_size (sect);\n+      if (vma + bfd_section_size (sect) > high)\n+\thigh = vma + bfd_section_size (sect);\n \n       data->segment_info[i] = 1;\n     }\n@@ -872,9 +871,9 @@ init_entry_point_info (struct objfile *objfile)\n \t{\n \t  struct bfd_section *sect = osect->the_bfd_section;\n \n-\t  if (entry_point >= bfd_get_section_vma (objfile->obfd, sect)\n-\t      && entry_point < (bfd_get_section_vma (objfile->obfd, sect)\n-\t\t\t\t+ bfd_get_section_size (sect)))\n+\t  if (entry_point >= bfd_section_vma (sect)\n+\t      && entry_point < (bfd_section_vma (sect)\n+\t\t\t\t+ bfd_section_size (sect)))\n \t    {\n \t      ei->the_bfd_section_index\n \t\t= gdb_bfd_section_index (objfile->obfd, sect);\n@@ -1878,7 +1877,7 @@ add_section_size_callback (bfd *abfd, asection *asec, void *data)\n {\n   bfd_size_type *sum = (bfd_size_type *) data;\n \n-  *sum += bfd_get_section_size (asec);\n+  *sum += bfd_section_size (asec);\n }\n \n /* Opaque data for load_progress.  */\n@@ -2001,16 +2000,16 @@ static void\n load_section_callback (bfd *abfd, asection *asec, void *data)\n {\n   struct load_section_data *args = (struct load_section_data *) data;\n-  bfd_size_type size = bfd_get_section_size (asec);\n-  const char *sect_name = bfd_get_section_name (abfd, asec);\n+  bfd_size_type size = bfd_section_size (asec);\n+  const char *sect_name = bfd_section_name (asec);\n \n-  if ((bfd_get_section_flags (abfd, asec) & SEC_LOAD) == 0)\n+  if ((bfd_section_flags (asec) & SEC_LOAD) == 0)\n     return;\n \n   if (size == 0)\n     return;\n \n-  ULONGEST begin = bfd_section_lma (abfd, asec) + args->load_offset;\n+  ULONGEST begin = bfd_section_lma (asec) + args->load_offset;\n   ULONGEST end = begin + size;\n   gdb_byte *buffer = (gdb_byte *) xmalloc (size);\n   bfd_get_section_contents (abfd, asec, buffer, 0, size);\n@@ -2988,9 +2987,8 @@ section_is_overlay (struct obj_section *section)\n     {\n       asection *bfd_section = section->the_bfd_section;\n \n-      if (bfd_section_lma (abfd, bfd_section) != 0\n-\t  && bfd_section_lma (abfd, bfd_section)\n-\t     != bfd_section_vma (abfd, bfd_section))\n+      if (bfd_section_lma (bfd_section) != 0\n+\t  && bfd_section_lma (bfd_section) != bfd_section_vma (bfd_section))\n \treturn 1;\n     }\n \n@@ -3061,15 +3059,14 @@ pc_in_unmapped_range (CORE_ADDR pc, struct obj_section *section)\n {\n   if (section_is_overlay (section))\n     {\n-      bfd *abfd = section->objfile->obfd;\n       asection *bfd_section = section->the_bfd_section;\n \n       /* We assume the LMA is relocated by the same offset as the VMA.  */\n-      bfd_vma size = bfd_get_section_size (bfd_section);\n+      bfd_vma size = bfd_section_size (bfd_section);\n       CORE_ADDR offset = obj_section_offset (section);\n \n-      if (bfd_get_section_lma (abfd, bfd_section) + offset <= pc\n-\t  && pc < bfd_get_section_lma (abfd, bfd_section) + offset + size)\n+      if (bfd_section_lma (bfd_section) + offset <= pc\n+\t  && pc < bfd_section_lma (bfd_section) + offset + size)\n \treturn 1;\n     }\n \n@@ -3117,8 +3114,8 @@ overlay_unmapped_address (CORE_ADDR pc, struct obj_section *section)\n     {\n       asection *bfd_section = section->the_bfd_section;\n \n-      return pc + bfd_section_lma (abfd, bfd_section)\n-\t\t- bfd_section_vma (abfd, bfd_section);\n+      return (pc + bfd_section_lma (bfd_section)\n+\t      - bfd_section_vma (bfd_section));\n     }\n \n   return pc;\n@@ -3135,8 +3132,8 @@ overlay_mapped_address (CORE_ADDR pc, struct obj_section *section)\n     {\n       asection *bfd_section = section->the_bfd_section;\n \n-      return pc + bfd_section_vma (abfd, bfd_section)\n-\t\t- bfd_section_lma (abfd, bfd_section);\n+      return (pc + bfd_section_vma (bfd_section)\n+\t      - bfd_section_lma (bfd_section));\n     }\n \n   return pc;\n@@ -3241,10 +3238,10 @@ list_overlays_command (const char *args, int from_tty)\n \t      bfd_vma lma, vma;\n \t      int size;\n \n-\t      vma = bfd_section_vma (objfile->obfd, osect->the_bfd_section);\n-\t      lma = bfd_section_lma (objfile->obfd, osect->the_bfd_section);\n-\t      size = bfd_get_section_size (osect->the_bfd_section);\n-\t      name = bfd_section_name (objfile->obfd, osect->the_bfd_section);\n+\t      vma = bfd_section_vma (osect->the_bfd_section);\n+\t      lma = bfd_section_lma (osect->the_bfd_section);\n+\t      size = bfd_section_size (osect->the_bfd_section);\n+\t      name = bfd_section_name (osect->the_bfd_section);\n \n \t      printf_filtered (\"Section %s, loaded at \", name);\n \t      fputs_filtered (paddress (gdbarch, lma), gdb_stdout);\n@@ -3282,8 +3279,7 @@ map_overlay_command (const char *args, int from_tty)\n   /* First, find a section matching the user supplied argument.  */\n   for (objfile *obj_file : current_program_space->objfiles ())\n     ALL_OBJFILE_OSECTIONS (obj_file, sec)\n-      if (!strcmp (bfd_section_name (obj_file->obfd, sec->the_bfd_section),\n-\t\t   args))\n+      if (!strcmp (bfd_section_name (sec->the_bfd_section), args))\n \t{\n \t  /* Now, check to see if the section is an overlay.  */\n \t  if (!section_is_overlay (sec))\n@@ -3301,8 +3297,7 @@ map_overlay_command (const char *args, int from_tty)\n \t\t{\n \t\t  if (info_verbose)\n \t\t    printf_unfiltered (_(\"Note: section %s unmapped by overlap\\n\"),\n-\t\t\t\t       bfd_section_name (obj_file->obfd,\n-\t\t\t\t\t\t\t sec2->the_bfd_section));\n+\t\t\t\t       bfd_section_name (sec2->the_bfd_section));\n \t\t  sec2->ovly_mapped = 0; /* sec2 overlaps sec: unmap sec2.  */\n \t\t}\n \t  return;\n@@ -3330,7 +3325,7 @@ unmap_overlay_command (const char *args, int from_tty)\n   /* First, find a section matching the user supplied argument.  */\n   for (objfile *objfile : current_program_space->objfiles ())\n     ALL_OBJFILE_OSECTIONS (objfile, sec)\n-      if (!strcmp (bfd_section_name (objfile->obfd, sec->the_bfd_section), args))\n+      if (!strcmp (bfd_section_name (sec->the_bfd_section), args))\n \t{\n \t  if (!sec->ovly_mapped)\n \t    error (_(\"Section %s is not mapped\"), args);\n@@ -3539,14 +3534,14 @@ simple_overlay_update_1 (struct obj_section *osect)\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n   for (i = 0; i < cache_novlys; i++)\n-    if (cache_ovly_table[i][VMA] == bfd_section_vma (obfd, bsect)\n-\t&& cache_ovly_table[i][LMA] == bfd_section_lma (obfd, bsect))\n+    if (cache_ovly_table[i][VMA] == bfd_section_vma (bsect)\n+\t&& cache_ovly_table[i][LMA] == bfd_section_lma (bsect))\n       {\n \tread_target_long_array (cache_ovly_table_base + i * word_size,\n \t\t\t\t(unsigned int *) cache_ovly_table[i],\n \t\t\t\t4, word_size, byte_order);\n-\tif (cache_ovly_table[i][VMA] == bfd_section_vma (obfd, bsect)\n-\t    && cache_ovly_table[i][LMA] == bfd_section_lma (obfd, bsect))\n+\tif (cache_ovly_table[i][VMA] == bfd_section_vma (bsect)\n+\t    && cache_ovly_table[i][LMA] == bfd_section_lma (bsect))\n \t  {\n \t    osect->ovly_mapped = cache_ovly_table[i][MAPPED];\n \t    return 1;\n@@ -3607,8 +3602,8 @@ simple_overlay_update (struct obj_section *osect)\n \t  asection *bsect = osect->the_bfd_section;\n \n \t  for (i = 0; i < cache_novlys; i++)\n-\t    if (cache_ovly_table[i][VMA] == bfd_section_vma (obfd, bsect)\n-\t\t&& cache_ovly_table[i][LMA] == bfd_section_lma (obfd, bsect))\n+\t    if (cache_ovly_table[i][VMA] == bfd_section_vma (bsect)\n+\t\t&& cache_ovly_table[i][LMA] == bfd_section_lma (bsect))\n \t      { /* obj_section matches i'th entry in ovly_table.  */\n \t\tosect->ovly_mapped = cache_ovly_table[i][MAPPED];\n \t\tbreak;\t\t/* finished with inner for loop: break out.  */"
    },
    {
      "sha": "4699fd09206e06c4ce569a3c40d84f86635043a6",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 5,
      "deletions": 10,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -244,8 +244,7 @@ dump_msymbols (struct objfile *objfile, struct ui_file *outfile)\n \t{\n \t  if (section->the_bfd_section != NULL)\n \t    fprintf_filtered (outfile, \" section %s\",\n-\t\t\t      bfd_section_name (objfile->obfd,\n-\t\t\t\t\t\tsection->the_bfd_section));\n+\t\t\t      bfd_section_name (section->the_bfd_section));\n \t  else\n \t    fprintf_filtered (outfile, \" spurious section %ld\",\n \t\t\t      (long) (section - objfile->sections));\n@@ -525,8 +524,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \t\t      outfile);\n       if (section)\n \tfprintf_filtered (outfile, \" section %s\\n\",\n-\t\t\t  bfd_section_name (section->the_bfd_section->owner,\n-\t\t\t\t\t    section->the_bfd_section));\n+\t\t\t  bfd_section_name (section->the_bfd_section));\n       else\n \tfprintf_filtered (outfile, \"\\n\");\n       return;\n@@ -596,8 +594,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \t\t\t  outfile);\n \t  if (section)\n \t    fprintf_filtered (outfile, \" section %s\",\n-\t\t\t      bfd_section_name (section->the_bfd_section->owner,\n-\t\t\t\t\t\tsection->the_bfd_section));\n+\t\t\t      bfd_section_name (section->the_bfd_section));\n \t  break;\n \n \tcase LOC_REGISTER:\n@@ -638,8 +635,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \t\t\t  outfile);\n \t  if (section)\n \t    fprintf_filtered (outfile, \" section %s\",\n-\t\t\t      bfd_section_name (section->the_bfd_section->owner,\n-\t\t\t\t\t\tsection->the_bfd_section));\n+\t\t\t      bfd_section_name (section->the_bfd_section));\n \t  break;\n \n \tcase LOC_BLOCK:\n@@ -655,8 +651,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \t\t\t  outfile);\n \t  if (section)\n \t    fprintf_filtered (outfile, \" section %s\",\n-\t\t\t      bfd_section_name (section->the_bfd_section->owner,\n-\t\t\t\t\t\tsection->the_bfd_section));\n+\t\t\t      bfd_section_name (section->the_bfd_section));\n \t  break;\n \n \tcase LOC_COMPUTED:"
    },
    {
      "sha": "35eab08cb37c381dd6a3ee6c24d842c979f8a779",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1033,20 +1033,17 @@ matching_obj_sections (struct obj_section *obj_first,\n      have the same size, address, and name.  We can't compare section indexes,\n      which would be more reliable, because some sections may have been\n      stripped.  */\n-  if (bfd_get_section_size (first) != bfd_get_section_size (second))\n+  if (bfd_section_size (first) != bfd_section_size (second))\n     return 0;\n \n   /* In-memory addresses may start at a different offset, relativize them.  */\n-  if (bfd_get_section_vma (first->owner, first)\n-      - bfd_get_start_address (first->owner)\n-      != bfd_get_section_vma (second->owner, second)\n-\t - bfd_get_start_address (second->owner))\n+  if (bfd_section_vma (first) - bfd_get_start_address (first->owner)\n+      != bfd_section_vma (second) - bfd_get_start_address (second->owner))\n     return 0;\n \n-  if (bfd_get_section_name (first->owner, first) == NULL\n-      || bfd_get_section_name (second->owner, second) == NULL\n-      || strcmp (bfd_get_section_name (first->owner, first),\n-\t\t bfd_get_section_name (second->owner, second)) != 0)\n+  if (bfd_section_name (first) == NULL\n+      || bfd_section_name (second) == NULL\n+      || strcmp (bfd_section_name (first), bfd_section_name (second)) != 0)\n     return 0;\n \n   /* Otherwise check that they are in corresponding objfiles.  */"
    },
    {
      "sha": "78bdfeb49a4a034a7a51f1b19cd044fac5d383a7",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1042,9 +1042,7 @@ memory_xfer_partial_1 (struct target_ops *ops, enum target_object object,\n \n       secp = target_section_by_addr (ops, memaddr);\n       if (secp != NULL\n-\t  && (bfd_get_section_flags (secp->the_bfd_section->owner,\n-\t\t\t\t     secp->the_bfd_section)\n-\t      & SEC_READONLY))\n+\t  && (bfd_section_flags (secp->the_bfd_section) & SEC_READONLY))\n \t{\n \t  table = target_get_section_table (ops);\n \t  return section_table_xfer_memory_partial (readbuf, writebuf,"
    },
    {
      "sha": "26030e0a9285ca947df24f7f8f239afb4bac54f4",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -794,8 +794,7 @@ windows_make_so (const char *name, LPVOID load_addr)\n \t file header and the section alignment.  */\n       cygwin_load_start = (CORE_ADDR) (uintptr_t) ((char *)\n \t\t\t\t\t\t   load_addr + 0x1000);\n-      cygwin_load_end = cygwin_load_start + bfd_section_size (abfd.get (),\n-\t\t\t\t\t\t\t      text);\n+      cygwin_load_end = cygwin_load_start + bfd_section_size (text);\n     }\n #endif\n "
    },
    {
      "sha": "2fa27066539caad2597bda37ac5942e13430db6e",
      "filename": "gdb/xcoffread.c",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/xcoffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gdb/xcoffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xcoffread.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -267,9 +267,9 @@ find_targ_sec (bfd *abfd, asection *sect, void *obj)\n   if (sect->target_index == args->targ_index)\n     {\n       /* This is the section.  Figure out what SECT_OFF_* code it is.  */\n-      if (bfd_get_section_flags (abfd, sect) & SEC_CODE)\n+      if (bfd_section_flags (sect) & SEC_CODE)\n \t*args->resultp = SECT_OFF_TEXT (objfile);\n-      else if (bfd_get_section_flags (abfd, sect) & SEC_LOAD)\n+      else if (bfd_section_flags (sect) & SEC_LOAD)\n \t*args->resultp = SECT_OFF_DATA (objfile);\n       else\n \t*args->resultp = gdb_bfd_section_index (abfd, sect);\n@@ -2354,7 +2354,7 @@ scan_xcoff_symtab (minimal_symbol_reader &reader,\n \t\t       section.  */\n \t\t    bfd_sect = secnum_to_bfd_section (symbol.n_scnum, objfile);\n \t\t    if (bfd_sect)\n-\t\t      toc_offset -= bfd_section_vma (objfile->obfd, bfd_sect);\n+\t\t      toc_offset -= bfd_section_vma (bfd_sect);\n \t\t    break;\n \n \t\t  case XMC_TC:\n@@ -2952,7 +2952,7 @@ xcoff_initial_scan (struct objfile *objfile, symfile_add_flags symfile_flags)\n \t  secp = bfd_get_section_by_name (abfd, \".debug\");\n \t  if (secp)\n \t    {\n-\t      length = bfd_section_size (abfd, secp);\n+\t      length = bfd_section_size (secp);\n \t      if (length)\n \t\t{\n \t\t  debugsec\n@@ -3029,8 +3029,7 @@ xcoff_symfile_offsets (struct objfile *objfile,\n   if (objfile->num_sections == 0)\n     return; /* Is that even possible?  Better safe than sorry.  */\n \n-  first_section_name\n-    = bfd_section_name (objfile->obfd, objfile->sections[0].the_bfd_section);\n+  first_section_name = bfd_section_name (objfile->sections[0].the_bfd_section);\n \n   if (objfile->sect_index_text == 0\n       && strcmp (first_section_name, \".text\") != 0)\n@@ -3089,7 +3088,7 @@ xcoff_get_core_n_import_files (bfd *abfd)\n   if (sect == NULL)\n     return -1;  /* Not a core file.  */\n \n-  for (offset = 0; offset < bfd_get_section_size (sect);)\n+  for (offset = 0; offset < bfd_section_size (sect);)\n     {\n       int next;\n "
    },
    {
      "sha": "84285aa30de0c1cfa4e16d94b5731ad7722cd995",
      "filename": "gprof/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gprof/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gprof/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gprof/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,8 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* corefile.c, * symtab.c: Update throughout for bfd section\n+\tmacro and function changes.\n+\n 2019-09-18  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* Makefile.in: Re-generate."
    },
    {
      "sha": "ba6fd9c54f2d2e2087d58c7541d1a691b1898d8d",
      "filename": "gprof/corefile.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gprof/corefile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gprof/corefile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gprof/corefile.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -271,17 +271,17 @@ core_init (const char * aout_name)\n void\n core_get_text_space (bfd *cbfd)\n {\n-  core_text_space = malloc (bfd_get_section_size (core_text_sect));\n+  core_text_space = malloc (bfd_section_size (core_text_sect));\n \n   if (!core_text_space)\n     {\n       fprintf (stderr, _(\"%s: ran out room for %lu bytes of text space\\n\"),\n-\t       whoami, (unsigned long) bfd_get_section_size (core_text_sect));\n+\t       whoami, (unsigned long) bfd_section_size (core_text_sect));\n       done (1);\n     }\n \n   if (!bfd_get_section_contents (cbfd, core_text_sect, core_text_space,\n-\t\t\t\t 0, bfd_get_section_size (core_text_sect)))\n+\t\t\t\t 0, bfd_section_size (core_text_sect)))\n     {\n       bfd_perror (\"bfd_get_section_contents\");\n       free (core_text_space);\n@@ -675,7 +675,7 @@ core_create_function_syms (void)\n       sym_sec = core_syms[i]->section;\n       symtab.limit->addr = core_syms[i]->value;\n       if (sym_sec)\n-\tsymtab.limit->addr += bfd_get_section_vma (sym_sec->owner, sym_sec);\n+\tsymtab.limit->addr += bfd_section_vma (sym_sec);\n \n       if (found)\n \t{\n@@ -734,8 +734,8 @@ core_create_function_syms (void)\n \t section containing the symbol, if available.  */\n       min_vma = MIN (symtab.limit->addr, min_vma);\n       if (sym_sec)\n-\tmax_vma = MAX (bfd_get_section_vma (sym_sec->owner, sym_sec)\n-\t\t       + bfd_section_size (sym_sec->owner, sym_sec) - 1,\n+\tmax_vma = MAX (bfd_section_vma (sym_sec)\n+\t\t       + bfd_section_size (sym_sec) - 1,\n \t\t       max_vma);\n       else\n \tmax_vma = MAX (symtab.limit->addr, max_vma);\n@@ -787,7 +787,7 @@ core_create_line_syms (void)\n   ltab.len = 0;\n   prev_line_num = 0;\n \n-  vma_high = core_text_sect->vma + bfd_get_section_size (core_text_sect);\n+  vma_high = core_text_sect->vma + bfd_section_size (core_text_sect);\n   for (vma = core_text_sect->vma; vma < vma_high; vma += min_insn_size)\n     {\n       unsigned int len;"
    },
    {
      "sha": "eb63aa926a29e1267c06bb2cb46d9598330cefd2",
      "filename": "gprof/symtab.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gprof/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/gprof/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gprof/symtab.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -149,7 +149,7 @@ symtab_finalize (Sym_Table *tab)\n \n   if (tab->len > 0 && dst[-1].end_addr == 0)\n     dst[-1].end_addr\n-      = core_text_sect->vma + bfd_get_section_size (core_text_sect) - 1;\n+      = core_text_sect->vma + bfd_section_size (core_text_sect) - 1;\n \n   DBG (AOUTDEBUG | IDDEBUG,\n        printf (\"[symtab_finalize]: removed %d duplicate entries\\n\","
    },
    {
      "sha": "2abb558b9c1e11c118ababb2bf4f090881f26d68",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,16 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* ldcref.c, * ldctor.c, * ldelf.c, * ldlang.c, * pe-dll.c,\n+\t* emultempl/aarch64elf.em, * emultempl/aix.em,\n+\t* emultempl/armcoff.em, * emultempl/armelf.em,\n+\t* emultempl/cr16elf.em, * emultempl/cskyelf.em,\n+\t* emultempl/m68hc1xelf.em, * emultempl/m68kelf.em,\n+\t* emultempl/mipself.em, * emultempl/mmix-elfnmmo.em,\n+\t* emultempl/mmo.em, * emultempl/msp430.em,\n+\t* emultempl/nios2elf.em, * emultempl/pe.em, * emultempl/pep.em,\n+\t* emultempl/ppc64elf.em, * emultempl/xtensaelf.em: Update\n+\tthroughout for bfd section macro and function changes.\n+\n 2019-09-18  Alan Modra  <amodra@gmail.com>\n \n \t* ldcref.c (check_reloc_refs): Update bfd_get_section to"
    },
    {
      "sha": "bd5c888782650bed8d0e1be425b880975f09797c",
      "filename": "ld/emultempl/aarch64elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/aarch64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/aarch64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/aarch64elf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -178,7 +178,7 @@ elf${ELFSIZE}_aarch64_add_stub_section (const char *stub_sec_name,\n \n   /* Long branch stubs contain a 64-bit address, so the section requires\n      8 byte alignment.  */\n-  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, 3);\n+  bfd_set_section_alignment (stub_sec, 3);\n \n   output_section = input_section->output_section;\n   os = lang_output_section_get (output_section);"
    },
    {
      "sha": "1ce8376a52a4457ee549e1af7463c43354523df6",
      "filename": "ld/emultempl/aix.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/aix.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/aix.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/aix.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -895,7 +895,7 @@ gld${EMULATION_NAME}_before_allocation (void)\n       if (is == NULL)\n \t{\n \t  einfo (_(\"%F%P: can't find %s in output section\\n\"),\n-\t\t bfd_get_section_name (sec->owner, sec));\n+\t\t bfd_section_name (sec));\n \t}\n \n       /* Now figure out where the section should go.  */"
    },
    {
      "sha": "180e1faa27c296deff1987c8478f2beb757dcbfb",
      "filename": "ld/emultempl/armcoff.em",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/armcoff.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/armcoff.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/armcoff.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -176,8 +176,7 @@ gld${EMULATION_NAME}_finish (void)\n \t  /* Special procesing is required for a Thumb entry symbol.  The\n \t     bottom bit of its address must be set.  */\n \t  val = (h->u.def.value\n-\t\t + bfd_get_section_vma (link_info.output_bfd,\n-\t\t\t\t\th->u.def.section->output_section)\n+\t\t + bfd_section_vma (h->u.def.section->output_section)\n \t\t + h->u.def.section->output_offset);\n \n \t  val |= 1;"
    },
    {
      "sha": "0cbfcc70b320ddfa46b492778a59921e8016cb61",
      "filename": "ld/emultempl/armelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/armelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/armelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/armelf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -232,7 +232,7 @@ elf32_arm_add_stub_section (const char * stub_sec_name,\n   if (stub_sec == NULL)\n     goto err_ret;\n \n-  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, alignment_power);\n+  bfd_set_section_alignment (stub_sec, alignment_power);\n \n   os = lang_output_section_get (output_section);\n \n@@ -478,8 +478,7 @@ gld${EMULATION_NAME}_finish (void)\n       /* Special procesing is required for a Thumb entry symbol.  The\n \t bottom bit of its address must be set.  */\n       val = (h->u.def.value\n-\t     + bfd_get_section_vma (link_info.output_bfd,\n-\t\t\t\t    h->u.def.section->output_section)\n+\t     + bfd_section_vma (h->u.def.section->output_section)\n \t     + h->u.def.section->output_offset);\n \n       val |= 1;"
    },
    {
      "sha": "9cdd356e3563395d75e822bc8689ec0d4a9923d5",
      "filename": "ld/emultempl/cr16elf.em",
      "status": "modified",
      "additions": 8,
      "deletions": 10,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/cr16elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/cr16elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/cr16elf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -75,14 +75,12 @@ cr16_elf_after_open (void)\n \n \t      relsec = bfd_make_section (abfd, \".emreloc\");\n \t      if (relsec == NULL\n-\t\t  || ! bfd_set_section_flags (abfd, relsec,\n-\t\t\t\t\t      (SEC_ALLOC\n-\t\t\t\t\t       | SEC_LOAD\n-\t\t\t\t\t       | SEC_HAS_CONTENTS\n-\t\t\t\t\t       | SEC_IN_MEMORY))\n-\t\t  || ! bfd_set_section_alignment (abfd, relsec, 2)\n-\t\t  || ! bfd_set_section_size (abfd, relsec,\n-\t\t\t\t\t     datasec->reloc_count * 8))\n+\t\t  || !bfd_set_section_flags (relsec, (SEC_ALLOC\n+\t\t\t\t\t\t      | SEC_LOAD\n+\t\t\t\t\t\t      | SEC_HAS_CONTENTS\n+\t\t\t\t\t\t      | SEC_IN_MEMORY))\n+\t\t  || !bfd_set_section_alignment (relsec, 2)\n+\t\t  || !bfd_set_section_size (relsec, datasec->reloc_count * 8))\n \t\teinfo (_(\"%F%P: %pB: can not create .emreloc section: %E\\n\"));\n \t    }\n \n@@ -99,11 +97,11 @@ cr16_elf_after_open (void)\n static void\n check_sections (bfd *abfd, asection *sec, void *datasec)\n {\n-  if ((strncmp (bfd_get_section_name (abfd, sec), \".data.rel\", 9) == 0)\n+  if ((strncmp (bfd_section_name (sec), \".data.rel\", 9) == 0)\n       && sec != datasec\n       && sec->reloc_count == 0 )\n     einfo (_(\"%X%P: %pB: section %s has relocs; can not use --embedded-relocs\\n\"),\n-\t   abfd, bfd_get_section_name (abfd, sec));\n+\t   abfd, bfd_section_name (sec));\n }\n \n static void"
    },
    {
      "sha": "91848086550abff209d3a88f95a8de488d6c6bce",
      "filename": "ld/emultempl/cskyelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/cskyelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/cskyelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/cskyelf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -180,10 +180,10 @@ elf32_csky_add_stub_section (const char *stub_sec_name,\n   if (stub_sec == NULL)\n     goto err_ret;\n \n-  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, 3);\n+  bfd_set_section_alignment (stub_sec, 3);\n \n   output_section = input_section->output_section;\n-  secname = bfd_get_section_name (output_section->owner, output_section);\n+  secname = bfd_section_name (output_section);\n   os = lang_output_section_find (secname);\n \n   info.input_section = input_section;"
    },
    {
      "sha": "b63e4e92d97ff240188513f789cee6694aa7ecec",
      "filename": "ld/emultempl/m68hc1xelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/m68hc1xelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/m68hc1xelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/m68hc1xelf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -212,10 +212,8 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \n \tcase lang_input_section_enum:\n \t  if (l->input_section.section == info->input_section\n-\t      || strcmp (bfd_get_section_name (l->input_section.section->owner,\n-\t\t\t\t\t       l->input_section.section),\n-\t\t\t bfd_get_section_name (info->input_section->owner,\n-\t\t\t\t\t       info->input_section)) == 0)\n+\t      || strcmp (bfd_section_name (l->input_section.section),\n+\t\t\t bfd_section_name (info->input_section)) == 0)\n \t    {\n \t      /* We've found our section.  Insert the stub immediately\n \t\t before its associated input section.  */"
    },
    {
      "sha": "c8d9eea934b4f50818987d9f083ba484d0175f9b",
      "filename": "ld/emultempl/m68kelf.em",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/m68kelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/m68kelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/m68kelf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -102,9 +102,8 @@ m68k_elf_after_open (void)\n \t\t\t\t\t\t    | SEC_HAS_CONTENTS\n \t\t\t\t\t\t    | SEC_IN_MEMORY));\n \t      if (relsec == NULL\n-\t\t  || ! bfd_set_section_alignment (abfd, relsec, 2)\n-\t\t  || ! bfd_set_section_size (abfd, relsec,\n-\t\t\t\t\t     datasec->reloc_count * 12))\n+\t\t  || !bfd_set_section_alignment (relsec, 2)\n+\t\t  || !bfd_set_section_size (relsec, datasec->reloc_count * 12))\n \t\teinfo (_(\"%F%P: %pB: can not create .emreloc section: %E\\n\"));\n \t    }\n \n@@ -123,11 +122,11 @@ m68k_elf_after_open (void)\n static void\n check_sections (bfd *abfd, asection *sec, void *datasec)\n {\n-  if ((bfd_get_section_flags (abfd, sec) & SEC_DATA)\n+  if ((bfd_section_flags (sec) & SEC_DATA)\n       && sec != datasec\n       && sec->reloc_count != 0)\n     einfo (_(\"%X%P: %pB: section %s has relocs; can not use --embedded-relocs\\n\"),\n-\t   abfd, bfd_get_section_name (abfd, sec));\n+\t   abfd, bfd_section_name (sec));\n }\n \n #endif /* SUPPORT_EMBEDDED_RELOCS */"
    },
    {
      "sha": "48944d5309be06e52291f568ef26412f7bc5e7f8",
      "filename": "ld/emultempl/mipself.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/mipself.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/mipself.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mipself.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -168,7 +168,7 @@ mips_add_stub_section (const char *stub_sec_name, asection *input_section,\n   /* Set the flags.  */\n   flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE\n \t   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_KEEP);\n-  if (!bfd_set_section_flags (stub_bfd, stub_sec, flags))\n+  if (!bfd_set_section_flags (stub_sec, flags))\n     goto err_ret;\n \n   os = lang_output_section_get (output_section);"
    },
    {
      "sha": "7cb4087a935f200d0ad2f05ad4fd96aaa5ce2a63",
      "filename": "ld/emultempl/mmix-elfnmmo.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/mmix-elfnmmo.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/mmix-elfnmmo.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mmix-elfnmmo.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -103,14 +103,14 @@ mmix_after_allocation (void)\n     }\n \n   /* Set vma to correspond to first such register number * 8.  */\n-  bfd_set_section_vma (link_info.output_bfd, sec, (bfd_vma) regvma);\n+  bfd_set_section_vma (sec, (bfd_vma) regvma);\n \n   /* Simplify symbol output for the register section (without contents;\n      created for register symbols) by setting the output offset to 0.\n      This section is only present when there are register symbols.  */\n   sec = bfd_get_section_by_name (link_info.output_bfd, MMIX_REG_SECTION_NAME);\n   if (sec != NULL)\n-    bfd_set_section_vma (sec->owner, sec, 0);\n+    bfd_set_section_vma (sec, 0);\n \n   if (!_bfd_mmix_after_linker_allocation (link_info.output_bfd, &link_info))\n     {"
    },
    {
      "sha": "fff48942bc43349f63724d31b67bd39d51b970ee",
      "filename": "ld/emultempl/mmo.em",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/mmo.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/mmo.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mmo.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -192,10 +192,10 @@ mmo_place_orphan (asection *s,\n    paper over the bug similarly.  */\n \n static void\n-mmo_wipe_sec_reloc_flag (bfd *abfd, asection *sec, void *ptr ATTRIBUTE_UNUSED)\n+mmo_wipe_sec_reloc_flag (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,\n+\t\t\t void *ptr ATTRIBUTE_UNUSED)\n {\n-  bfd_set_section_flags (abfd, sec,\n-\t\t\t bfd_get_section_flags (abfd, sec) & ~SEC_RELOC);\n+  bfd_set_section_flags (sec, bfd_section_flags (sec) & ~SEC_RELOC);\n }\n \n /* Iterate with bfd_map_over_sections over mmo_wipe_sec_reloc_flag... */"
    },
    {
      "sha": "8f2548952898183f7ddbb715a1001c994f05370a",
      "filename": "ld/emultempl/msp430.em",
      "status": "modified",
      "additions": 11,
      "deletions": 9,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/msp430.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/msp430.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/msp430.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -382,10 +382,10 @@ change_output_section (lang_statement_union_type ** head,\n }\n \n static void\n-add_region_prefix (bfd *abfd, asection *s,\n-\t\t   ATTRIBUTE_UNUSED void *unused)\n+add_region_prefix (bfd *abfd ATTRIBUTE_UNUSED, asection *s,\n+\t\t   void *unused ATTRIBUTE_UNUSED)\n {\n-  const char *curr_name = bfd_get_section_name (abfd, s);\n+  const char *curr_name = bfd_section_name (s);\n   int region = REGION_NONE;\n \n   if (strncmp (curr_name, \".text\", 5) == 0)\n@@ -404,10 +404,10 @@ add_region_prefix (bfd *abfd, asection *s,\n     case REGION_NONE:\n       break;\n     case REGION_UPPER:\n-      bfd_rename_section (abfd, s, concat (\".upper\", curr_name, NULL));\n+      bfd_rename_section (s, concat (\".upper\", curr_name, NULL));\n       break;\n     case REGION_LOWER:\n-      bfd_rename_section (abfd, s, concat (\".lower\", curr_name, NULL));\n+      bfd_rename_section (s, concat (\".lower\", curr_name, NULL));\n       break;\n     case REGION_EITHER:\n       s->name = concat (\".either\", curr_name, NULL);\n@@ -538,7 +538,8 @@ gld${EMULATION_NAME}_handle_option (int optc)\n }\n \n static void\n-eval_upper_either_sections (bfd *abfd, asection *s, void *data)\n+eval_upper_either_sections (bfd *abfd ATTRIBUTE_UNUSED,\n+\t\t\t    asection *s, void *data)\n {\n   const char * base_sec_name;\n   const char * curr_name;\n@@ -560,7 +561,7 @@ eval_upper_either_sections (bfd *abfd, asection *s, void *data)\n     return;\n \n   base_sec_name = (const char *) data;\n-  curr_name = bfd_get_section_name (abfd, s);\n+  curr_name = bfd_section_name (s);\n \n   /* Only concerned with .either input sections in the upper output section.  */\n   either_name = concat (\".either\", base_sec_name, NULL);\n@@ -620,7 +621,8 @@ eval_upper_either_sections (bfd *abfd, asection *s, void *data)\n }\n \n static void\n-eval_lower_either_sections (bfd *abfd, asection *s, void *data)\n+eval_lower_either_sections (bfd *abfd ATTRIBUTE_UNUSED,\n+\t\t\t    asection *s, void *data)\n {\n   const char * base_sec_name;\n   const char * curr_name;\n@@ -640,7 +642,7 @@ eval_lower_either_sections (bfd *abfd, asection *s, void *data)\n     return;\n \n   base_sec_name = (const char *) data;\n-  curr_name = bfd_get_section_name (abfd, s);\n+  curr_name = bfd_section_name (s);\n \n   /* Only concerned with .either input sections in the lower or \"default\"\n      output section i.e. not in the upper output section.  */"
    },
    {
      "sha": "816da6ca72266594b48f911567b613ab2bc50c78",
      "filename": "ld/emultempl/nios2elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/nios2elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/nios2elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/nios2elf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -181,7 +181,7 @@ nios2elf_add_stub_section (const char *stub_sec_name, asection *input_section,\n     goto err_ret;\n \n   output_section = input_section->output_section;\n-  secname = bfd_get_section_name (output_section->owner, output_section);\n+  secname = bfd_section_name (output_section);\n   os = lang_output_section_find (secname);\n \n   info.input_section = input_section;"
    },
    {
      "sha": "70f771cebd782b608e1aaf83c13241820b34e9a5",
      "filename": "ld/emultempl/pe.em",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/pe.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/pe.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/pe.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1920,8 +1920,7 @@ gld_${EMULATION_NAME}_finish (void)\n \t  /* Special procesing is required for a Thumb entry symbol.  The\n \t     bottom bit of its address must be set.  */\n \t  val = (h->u.def.value\n-\t\t + bfd_get_section_vma (link_info.output_bfd,\n-\t\t\t\t\th->u.def.section->output_section)\n+\t\t + bfd_section_vma (h->u.def.section->output_section)\n \t\t + h->u.def.section->output_offset);\n \n \t  val |= 1;\n@@ -2182,7 +2181,7 @@ gld_${EMULATION_NAME}_place_orphan (asection *s,\n \n       ls = &(*pl)->input_section;\n \n-      lname = bfd_get_section_name (ls->section->owner, ls->section);\n+      lname = bfd_section_name (ls->section);\n       if (strchr (lname, '\\$') != NULL\n \t  && (dollar == NULL || strcmp (orig_secname, lname) < 0))\n \tbreak;"
    },
    {
      "sha": "6d150d211a92bb725935724c150ef5da9e5cce96",
      "filename": "ld/emultempl/pep.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/pep.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/pep.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/pep.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1979,7 +1979,7 @@ gld_${EMULATION_NAME}_place_orphan (asection *s,\n \n       ls = &(*pl)->input_section;\n \n-      lname = bfd_get_section_name (ls->section->owner, ls->section);\n+      lname = bfd_section_name (ls->section);\n       if (strchr (lname, '\\$') != NULL\n \t  && (dollar == NULL || strcmp (orig_secname, lname) < 0))\n \tbreak;"
    },
    {
      "sha": "ee71f256c657c2f4cc619362b73b0dddb734c93c",
      "filename": "ld/emultempl/ppc64elf.em",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/ppc64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/ppc64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/ppc64elf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -421,12 +421,11 @@ ppc_add_stub_section (const char *stub_sec_name, asection *input_section)\n   stub_sec = bfd_make_section_anyway_with_flags (stub_file->the_bfd,\n \t\t\t\t\t\t stub_sec_name, flags);\n   if (stub_sec == NULL\n-      || !bfd_set_section_alignment (stub_file->the_bfd, stub_sec,\n-\t\t\t\t     (params.plt_stub_align > 5\n-\t\t\t\t      ? params.plt_stub_align\n-\t\t\t\t      : params.plt_stub_align < -5\n-\t\t\t\t      ? -params.plt_stub_align\n-\t\t\t\t      : 5)))\n+      || !bfd_set_section_alignment (stub_sec, (params.plt_stub_align > 5\n+\t\t\t\t\t\t? params.plt_stub_align\n+\t\t\t\t\t\t: params.plt_stub_align < -5\n+\t\t\t\t\t\t? -params.plt_stub_align\n+\t\t\t\t\t\t: 5)))\n     goto err_ret;\n \n   output_section = input_section->output_section;"
    },
    {
      "sha": "569df615ce04091150ac18e9aea505443d25ad99",
      "filename": "ld/emultempl/xtensaelf.em",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/xtensaelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/emultempl/xtensaelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/xtensaelf.em?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -127,9 +127,9 @@ replace_insn_sec_with_prop_sec (bfd *abfd,\n   /* Create a property table section for it.  */\n   prop_sec_name = strdup (prop_sec_name);\n   prop_sec = bfd_make_section_with_flags\n-    (abfd, prop_sec_name, bfd_get_section_flags (abfd, insn_sec));\n+    (abfd, prop_sec_name, bfd_section_flags (insn_sec));\n   if (prop_sec == NULL\n-      || ! bfd_set_section_alignment (abfd, prop_sec, 2))\n+      || !bfd_set_section_alignment (prop_sec, 2))\n     {\n       *error_message = _(\"could not create new section\");\n       goto cleanup;\n@@ -247,7 +247,7 @@ replace_instruction_table_sections (bfd *abfd, asection *sec)\n   char *owned_prop_sec_name = NULL;\n   const char *sec_name;\n \n-  sec_name = bfd_get_section_name (abfd, sec);\n+  sec_name = bfd_section_name (sec);\n   if (strcmp (sec_name, INSN_SEC_BASE_NAME) == 0)\n     {\n       insn_sec_name = INSN_SEC_BASE_NAME;\n@@ -1293,10 +1293,10 @@ static bfd_boolean\n is_inconsistent_linkonce_section (asection *sec)\n {\n   bfd *abfd = sec->owner;\n-  const char *sec_name = bfd_get_section_name (abfd, sec);\n+  const char *sec_name = bfd_section_name (sec);\n   const char *name;\n \n-  if ((bfd_get_section_flags (abfd, sec) & SEC_LINK_ONCE) == 0\n+  if ((bfd_section_flags (sec) & SEC_LINK_ONCE) == 0\n       || strncmp (sec_name, \".gnu.linkonce.\", linkonce_len) != 0)\n     return FALSE;\n "
    },
    {
      "sha": "576cf7e388fb193c71eef56c33b58596cb9f9381",
      "filename": "ld/ldcref.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ldcref.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ldcref.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldcref.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -574,7 +574,7 @@ check_nocrossref (struct cref_hash_entry *h, void *ignore ATTRIBUTE_UNUSED)\n   defsec = hl->u.def.section->output_section;\n   if (defsec == NULL)\n     return TRUE;\n-  defsecname = bfd_get_section_name (defsec->owner, defsec);\n+  defsecname = bfd_section_name (defsec);\n \n   for (ncrs = nocrossref_list; ncrs != NULL; ncrs = ncrs->next)\n     for (ncr = ncrs->list; ncr != NULL; ncr = ncr->next)\n@@ -658,10 +658,10 @@ check_reloc_refs (bfd *abfd, asection *sec, void *iarg)\n   arelent **p, **pend;\n \n   outsec = sec->output_section;\n-  outsecname = bfd_get_section_name (outsec->owner, outsec);\n+  outsecname = bfd_section_name (outsec);\n \n   outdefsec = info->defsec->output_section;\n-  outdefsecname = bfd_get_section_name (outdefsec->owner, outdefsec);\n+  outdefsecname = bfd_section_name (outdefsec);\n \n   /* The section where the symbol is defined is permitted.  */\n   if (strcmp (outsecname, outdefsecname) == 0)"
    },
    {
      "sha": "a6a6aa9e1e0dfefc2d58a47de14ff9ce6ae8fb71",
      "filename": "ld/ldctor.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ldctor.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ldctor.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldctor.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -293,7 +293,7 @@ ldctor_build_sets (void)\n \t      /* See PR 20911 for a reproducer.  */\n \t      if (p->elements->section->owner == NULL)\n \t\teinfo (_(\"%X%P: special section %s does not support reloc %s for set %s\\n\"),\n-\t\t       bfd_get_section_name (link_info.output_bfd, p->elements->section),\n+\t\t       bfd_section_name (p->elements->section),\n \t\t       bfd_get_reloc_code_name (p->reloc),\n \t\t       p->h->root.string);\n \t      else"
    },
    {
      "sha": "8d4a2e58a1b6c96effc4873d147a259942dca9c1",
      "filename": "ld/ldelf.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ldelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ldelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelf.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1065,7 +1065,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n \n \t  for (s = abfd->sections; s && type < COMPACT_EH_HDR; s = s->next)\n \t    {\n-\t      const char *name = bfd_get_section_name (abfd, s);\n+\t      const char *name = bfd_section_name (s);\n \n \t      if (bfd_is_abs_section (s->output_section))\n \t\tcontinue;\n@@ -1112,7 +1112,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n \t\t\t\t\t   bed->dynamic_sec_flags\n \t\t\t\t\t   | SEC_READONLY);\n \t  if (s != NULL\n-\t      && bfd_set_section_alignment (elfbfd, s, 2))\n+\t      && bfd_set_section_alignment (s, 2))\n \t    {\n \t      htab->eh_info.hdr_sec = s;\n \t      warn_eh_frame = FALSE;\n@@ -1382,7 +1382,7 @@ ldelf_setup_build_id (bfd *ibfd)\n   flags = (SEC_ALLOC | SEC_LOAD | SEC_IN_MEMORY\n \t   | SEC_LINKER_CREATED | SEC_READONLY | SEC_DATA);\n   s = bfd_make_section_with_flags (ibfd, \".note.gnu.build-id\", flags);\n-  if (s != NULL && bfd_set_section_alignment (ibfd, s, 2))\n+  if (s != NULL && bfd_set_section_alignment (s, 2))\n     {\n       struct elf_obj_tdata *t = elf_tdata (link_info.output_bfd);\n       t->o->build_id.after_write_object_contents = &write_build_id;"
    },
    {
      "sha": "a3843623fb4beaa5cfaa32fb3af3c15baf841fa9",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 20,
      "deletions": 31,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -319,7 +319,7 @@ walk_wild_section_general (lang_wild_statement_type *ptr,\n \n \t  if (sec->spec.name != NULL)\n \t    {\n-\t      const char *sname = bfd_get_section_name (file->the_bfd, s);\n+\t      const char *sname = bfd_section_name (s);\n \n \t      skip = name_match (sec->spec.name, sname) != 0;\n \t    }\n@@ -452,10 +452,8 @@ compare_section (sort_type sort, asection *asec, asection *bsec)\n       abort ();\n \n     case by_init_priority:\n-      ainit_priority\n-\t= get_init_priority (bfd_get_section_name (asec->owner, asec));\n-      binit_priority\n-\t= get_init_priority (bfd_get_section_name (bsec->owner, bsec));\n+      ainit_priority = get_init_priority (bfd_section_name (asec));\n+      binit_priority = get_init_priority (bfd_section_name (bsec));\n       if (ainit_priority == 0 || binit_priority == 0)\n \tgoto sort_by_name;\n       ret = ainit_priority - binit_priority;\n@@ -465,28 +463,24 @@ compare_section (sort_type sort, asection *asec, asection *bsec)\n \tgoto sort_by_name;\n \n     case by_alignment_name:\n-      ret = (bfd_section_alignment (bsec->owner, bsec)\n-\t     - bfd_section_alignment (asec->owner, asec));\n+      ret = bfd_section_alignment (bsec) - bfd_section_alignment (asec);\n       if (ret)\n \tbreak;\n       /* Fall through.  */\n \n     case by_name:\n sort_by_name:\n-      ret = strcmp (bfd_get_section_name (asec->owner, asec),\n-\t\t    bfd_get_section_name (bsec->owner, bsec));\n+      ret = strcmp (bfd_section_name (asec), bfd_section_name (bsec));\n       break;\n \n     case by_name_alignment:\n-      ret = strcmp (bfd_get_section_name (asec->owner, asec),\n-\t\t    bfd_get_section_name (bsec->owner, bsec));\n+      ret = strcmp (bfd_section_name (asec), bfd_section_name (bsec));\n       if (ret)\n \tbreak;\n       /* Fall through.  */\n \n     case by_alignment:\n-      ret = (bfd_section_alignment (bsec->owner, bsec)\n-\t     - bfd_section_alignment (asec->owner, asec));\n+      ret = bfd_section_alignment (bsec) - bfd_section_alignment (asec);\n       break;\n     }\n \n@@ -610,7 +604,7 @@ walk_wild_section_specs1_wild1 (lang_wild_statement_type *ptr,\n \n   for (s = file->the_bfd->sections; s != NULL; s = s->next)\n     {\n-      const char *sname = bfd_get_section_name (file->the_bfd, s);\n+      const char *sname = bfd_section_name (s);\n       bfd_boolean skip = !match_simple_wild (wildsec0->spec.name, sname);\n \n       if (!skip)\n@@ -647,7 +641,7 @@ walk_wild_section_specs2_wild1 (lang_wild_statement_type *ptr,\n \twalk_wild_consider_section (ptr, file, s, sec0, callback, data);\n       else\n \t{\n-\t  const char *sname = bfd_get_section_name (file->the_bfd, s);\n+\t  const char *sname = bfd_section_name (s);\n \t  bfd_boolean skip = !match_simple_wild (wildsec1->spec.name, sname);\n \n \t  if (!skip)\n@@ -682,7 +676,7 @@ walk_wild_section_specs3_wild2 (lang_wild_statement_type *ptr,\n \twalk_wild_consider_section (ptr, file, s, sec0, callback, data);\n       else\n \t{\n-\t  const char *sname = bfd_get_section_name (file->the_bfd, s);\n+\t  const char *sname = bfd_section_name (s);\n \t  bfd_boolean skip = !match_simple_wild (wildsec1->spec.name, sname);\n \n \t  if (!skip)\n@@ -734,7 +728,7 @@ walk_wild_section_specs4_wild2 (lang_wild_statement_type *ptr,\n \t  walk_wild_consider_section (ptr, file, s, sec1, callback, data);\n \telse\n \t  {\n-\t    const char *sname = bfd_get_section_name (file->the_bfd, s);\n+\t    const char *sname = bfd_section_name (s);\n \t    bfd_boolean skip = !match_simple_wild (wildsec2->spec.name,\n \t\t\t\t\t\t   sname);\n \n@@ -5314,9 +5308,8 @@ lang_size_sections_1\n \t\t\t   \" section %s\\n\"), os->name);\n \n \t\tinput = os->children.head->input_section.section;\n-\t\tbfd_set_section_vma (os->bfd_section->owner,\n-\t\t\t\t     os->bfd_section,\n-\t\t\t\t     bfd_section_vma (input->owner, input));\n+\t\tbfd_set_section_vma (os->bfd_section,\n+\t\t\t\t     bfd_section_vma (input));\n \t\tif (!(os->bfd_section->flags & SEC_FIXED_SIZE))\n \t\t  os->bfd_section->size = input->size;\n \t\tbreak;\n@@ -5371,13 +5364,11 @@ lang_size_sections_1\n \t\t\tif (command_line.check_section_addresses)\n \t\t\t  einfo (_(\"%F%P: error: no memory region specified\"\n \t\t\t\t   \" for loadable section `%s'\\n\"),\n-\t\t\t\t bfd_get_section_name (link_info.output_bfd,\n-\t\t\t\t\t\t       os->bfd_section));\n+\t\t\t\t bfd_section_name (os->bfd_section));\n \t\t\telse\n \t\t\t  einfo (_(\"%P: warning: no memory region specified\"\n \t\t\t\t   \" for loadable section `%s'\\n\"),\n-\t\t\t\t bfd_get_section_name (link_info.output_bfd,\n-\t\t\t\t\t\t       os->bfd_section));\n+\t\t\t\t bfd_section_name (os->bfd_section));\n \t\t      }\n \n \t\t    newdot = os->region->current;\n@@ -5406,7 +5397,7 @@ lang_size_sections_1\n \t\t\t     os->name, (unsigned long) dotdelta);\n \t\t  }\n \n-\t\tbfd_set_section_vma (0, os->bfd_section, newdot);\n+\t\tbfd_set_section_vma (os->bfd_section, newdot);\n \n \t\tos->bfd_section->output_offset = 0;\n \t      }\n@@ -6464,8 +6455,7 @@ lang_end (void)\n       bfd_vma val;\n \n       val = (h->u.def.value\n-\t     + bfd_get_section_vma (link_info.output_bfd,\n-\t\t\t\t    h->u.def.section->output_section)\n+\t     + bfd_section_vma (h->u.def.section->output_section)\n \t     + h->u.def.section->output_offset);\n       if (!bfd_set_start_address (link_info.output_bfd, val))\n \teinfo (_(\"%F%P: %s: can't set start address\\n\"), entry_symbol.name);\n@@ -6496,10 +6486,9 @@ lang_end (void)\n \t\teinfo (_(\"%P: warning: cannot find entry symbol %s;\"\n \t\t\t \" defaulting to %V\\n\"),\n \t\t       entry_symbol.name,\n-\t\t       bfd_get_section_vma (link_info.output_bfd, ts));\n-\t      if (!(bfd_set_start_address\n-\t\t    (link_info.output_bfd,\n-\t\t     bfd_get_section_vma (link_info.output_bfd, ts))))\n+\t\t       bfd_section_vma (ts));\n+\t      if (!bfd_set_start_address (link_info.output_bfd,\n+\t\t\t\t\t  bfd_section_vma (ts)))\n \t\teinfo (_(\"%F%P: can't set start address\\n\"));\n \t    }\n \t  else"
    },
    {
      "sha": "3cfbc39e5bdc551b2021559bbaa4431634ca9f5f",
      "filename": "ld/pe-dll.c",
      "status": "modified",
      "additions": 37,
      "deletions": 39,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/pe-dll.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/ld/pe-dll.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/pe-dll.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1014,33 +1014,31 @@ build_filler_bfd (int include_edata)\n     {\n       edata_s = bfd_make_section_old_way (filler_bfd, \".edata\");\n       if (edata_s == NULL\n-\t  || !bfd_set_section_flags (filler_bfd, edata_s,\n-\t\t\t\t     (SEC_HAS_CONTENTS\n-\t\t\t\t      | SEC_ALLOC\n-\t\t\t\t      | SEC_LOAD\n-\t\t\t\t      | SEC_KEEP\n-\t\t\t\t      | SEC_IN_MEMORY)))\n+\t  || !bfd_set_section_flags (edata_s, (SEC_HAS_CONTENTS\n+\t\t\t\t\t       | SEC_ALLOC\n+\t\t\t\t\t       | SEC_LOAD\n+\t\t\t\t\t       | SEC_KEEP\n+\t\t\t\t\t       | SEC_IN_MEMORY)))\n \t{\n \t  einfo (_(\"%X%P: can not create .edata section: %E\\n\"));\n \t  return;\n \t}\n-      bfd_set_section_size (filler_bfd, edata_s, edata_sz);\n+      bfd_set_section_size (edata_s, edata_sz);\n     }\n \n   reloc_s = bfd_make_section_old_way (filler_bfd, \".reloc\");\n   if (reloc_s == NULL\n-      || !bfd_set_section_flags (filler_bfd, reloc_s,\n-\t\t\t\t (SEC_HAS_CONTENTS\n-\t\t\t\t  | SEC_ALLOC\n-\t\t\t\t  | SEC_LOAD\n-\t\t\t\t  | SEC_KEEP\n-\t\t\t\t  | SEC_IN_MEMORY)))\n+      || !bfd_set_section_flags (reloc_s, (SEC_HAS_CONTENTS\n+\t\t\t\t\t   | SEC_ALLOC\n+\t\t\t\t\t   | SEC_LOAD\n+\t\t\t\t\t   | SEC_KEEP\n+\t\t\t\t\t   | SEC_IN_MEMORY)))\n     {\n       einfo (_(\"%X%P: can not create .reloc section: %E\\n\"));\n       return;\n     }\n \n-  bfd_set_section_size (filler_bfd, reloc_s, 0);\n+  bfd_set_section_size (reloc_s, 0);\n \n   ldlang_add_file (filler_file);\n }\n@@ -1303,7 +1301,7 @@ pe_walk_relocs (struct bfd_link_info *info,\n \t{\n \t  arelent **relocs;\n \t  int relsize, nrelocs, i;\n-\t  int flags = bfd_get_section_flags (b, s);\n+\t  int flags = bfd_section_flags (s);\n \n \t  /* Skip discarded linkonce sections.  */\n \t  if (flags & SEC_LINK_ONCE\n@@ -1947,8 +1945,8 @@ quick_section (bfd *abfd, const char *name, int flags, int align)\n   asymbol *sym;\n \n   sec = bfd_make_section_old_way (abfd, name);\n-  bfd_set_section_flags (abfd, sec, flags | SEC_ALLOC | SEC_LOAD | SEC_KEEP);\n-  bfd_set_section_alignment (abfd, sec, align);\n+  bfd_set_section_flags (sec, flags | SEC_ALLOC | SEC_LOAD | SEC_KEEP);\n+  bfd_set_section_alignment (sec, align);\n   /* Remember to undo this before trying to link internally!  */\n   sec->output_section = sec;\n \n@@ -2072,7 +2070,7 @@ make_head (bfd *parent)\n      pointer to the list points to the *end* of this section, which is\n      the start of the list of sections from other objects.  */\n \n-  bfd_set_section_size (abfd, id2, 20);\n+  bfd_set_section_size (id2, 20);\n   d2 = xmalloc (20);\n   id2->contents = d2;\n   memset (d2, 0, 20);\n@@ -2084,16 +2082,16 @@ make_head (bfd *parent)\n   save_relocs (id2);\n \n   if (pe_use_nul_prefixed_import_tables)\n-    bfd_set_section_size (abfd, id5, PE_IDATA5_SIZE);\n+    bfd_set_section_size (id5, PE_IDATA5_SIZE);\n   else\n-    bfd_set_section_size (abfd, id5, 0);\n+    bfd_set_section_size (id5, 0);\n   d5 = xmalloc (PE_IDATA5_SIZE);\n   id5->contents = d5;\n   memset (d5, 0, PE_IDATA5_SIZE);\n   if (pe_use_nul_prefixed_import_tables)\n-    bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE);\n+    bfd_set_section_size (id4, PE_IDATA4_SIZE);\n   else\n-    bfd_set_section_size (abfd, id4, 0);\n+    bfd_set_section_size (id4, 0);\n   d4 = xmalloc (PE_IDATA4_SIZE);\n   id4->contents = d4;\n   memset (d4, 0, PE_IDATA4_SIZE);\n@@ -2154,20 +2152,20 @@ make_tail (bfd *parent)\n   id7 = quick_section (abfd, \".idata$7\", SEC_HAS_CONTENTS, 2);\n   quick_symbol (abfd, U (\"\"), dll_symname, \"_iname\", id7, BSF_GLOBAL, 0);\n \n-  bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE);\n+  bfd_set_section_size (id4, PE_IDATA4_SIZE);\n   d4 = xmalloc (PE_IDATA4_SIZE);\n   id4->contents = d4;\n   memset (d4, 0, PE_IDATA4_SIZE);\n \n-  bfd_set_section_size (abfd, id5, PE_IDATA5_SIZE);\n+  bfd_set_section_size (id5, PE_IDATA5_SIZE);\n   d5 = xmalloc (PE_IDATA5_SIZE);\n   id5->contents = d5;\n   memset (d5, 0, PE_IDATA5_SIZE);\n \n   len = strlen (dll_filename) + 1;\n   if (len & 1)\n     len++;\n-  bfd_set_section_size (abfd, id7, len);\n+  bfd_set_section_size (id7, len);\n   d7 = xmalloc (len);\n   id7->contents = d7;\n   strcpy ((char *) d7, dll_filename);\n@@ -2339,7 +2337,7 @@ make_one (def_file_export *exp, bfd *parent, bfd_boolean include_jmp_stub)\n \n   if (include_jmp_stub)\n     {\n-      bfd_set_section_size (abfd, tx, jmp_byte_count);\n+      bfd_set_section_size (tx, jmp_byte_count);\n       td = xmalloc (jmp_byte_count);\n       tx->contents = td;\n       memcpy (td, jmp_bytes, jmp_byte_count);\n@@ -2374,16 +2372,16 @@ make_one (def_file_export *exp, bfd *parent, bfd_boolean include_jmp_stub)\n       save_relocs (tx);\n     }\n   else\n-    bfd_set_section_size (abfd, tx, 0);\n+    bfd_set_section_size (tx, 0);\n \n-  bfd_set_section_size (abfd, id7, 4);\n+  bfd_set_section_size (id7, 4);\n   d7 = xmalloc (4);\n   id7->contents = d7;\n   memset (d7, 0, 4);\n   quick_reloc (abfd, 0, BFD_RELOC_RVA, 5);\n   save_relocs (id7);\n \n-  bfd_set_section_size (abfd, id5, PE_IDATA5_SIZE);\n+  bfd_set_section_size (id5, PE_IDATA5_SIZE);\n   d5 = xmalloc (PE_IDATA5_SIZE);\n   id5->contents = d5;\n   memset (d5, 0, PE_IDATA5_SIZE);\n@@ -2400,7 +2398,7 @@ make_one (def_file_export *exp, bfd *parent, bfd_boolean include_jmp_stub)\n       save_relocs (id5);\n     }\n \n-  bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE);\n+  bfd_set_section_size (id4, PE_IDATA4_SIZE);\n   d4 = xmalloc (PE_IDATA4_SIZE);\n   id4->contents = d4;\n   memset (d4, 0, PE_IDATA4_SIZE);\n@@ -2420,7 +2418,7 @@ make_one (def_file_export *exp, bfd *parent, bfd_boolean include_jmp_stub)\n   if (exp->flag_noname)\n     {\n       len = 0;\n-      bfd_set_section_size (abfd, id6, 0);\n+      bfd_set_section_size (id6, 0);\n     }\n   else\n     {\n@@ -2433,7 +2431,7 @@ make_one (def_file_export *exp, bfd *parent, bfd_boolean include_jmp_stub)\n \tlen = 2 + strlen (exp->name) + 1;\n       if (len & 1)\n \tlen++;\n-      bfd_set_section_size (abfd, id6, len);\n+      bfd_set_section_size (id6, len);\n       d6 = xmalloc (len);\n       id6->contents = d6;\n       memset (d6, 0, len);\n@@ -2491,7 +2489,7 @@ make_singleton_name_thunk (const char *import, bfd *parent)\n   quick_symbol (abfd, \"__nm_\", import, \"\", UNDSEC, BSF_GLOBAL, 0);\n \n   /* We need space for the real thunk and for the null terminator.  */\n-  bfd_set_section_size (abfd, id4, PE_IDATA4_SIZE * 2);\n+  bfd_set_section_size (id4, PE_IDATA4_SIZE * 2);\n   d4 = xmalloc (PE_IDATA4_SIZE * 2);\n   id4->contents = d4;\n   memset (d4, 0, PE_IDATA4_SIZE * 2);\n@@ -2568,7 +2566,7 @@ make_import_fixup_entry (const char *name,\n   quick_symbol (abfd, U (\"\"), symname, \"_iname\", UNDSEC, BSF_GLOBAL, 0);\n   quick_symbol (abfd, \"\", fixup_name, \"\", UNDSEC, BSF_GLOBAL, 0);\n \n-  bfd_set_section_size (abfd, id2, 20);\n+  bfd_set_section_size (id2, 20);\n   d2 = xmalloc (20);\n   id2->contents = d2;\n   memset (d2, 0, 20);\n@@ -2643,7 +2641,7 @@ make_runtime_pseudo_reloc (const char *name ATTRIBUTE_UNUSED,\n \n       quick_symbol (abfd, \"__imp_\", name, \"\", UNDSEC, BSF_GLOBAL, 0);\n \n-      bfd_set_section_size (abfd, rt_rel, size);\n+      bfd_set_section_size (rt_rel, size);\n       rt_rel_d = xmalloc (size);\n       rt_rel->contents = rt_rel_d;\n       memset (rt_rel_d, 0, size);\n@@ -2660,7 +2658,7 @@ make_runtime_pseudo_reloc (const char *name ATTRIBUTE_UNUSED,\n     }\n   else\n     {\n-      bfd_set_section_size (abfd, rt_rel, 8);\n+      bfd_set_section_size (rt_rel, 8);\n       rt_rel_d = xmalloc (8);\n       rt_rel->contents = rt_rel_d;\n       memset (rt_rel_d, 0, 8);\n@@ -2708,7 +2706,7 @@ pe_create_runtime_relocator_reference (bfd *parent)\n   quick_symbol (abfd, \"\", U (\"_pei386_runtime_relocator\"), \"\", UNDSEC,\n \t\tBSF_NO_FLAGS, 0);\n \n-  bfd_set_section_size (abfd, extern_rt_rel, PE_IDATA5_SIZE);\n+  bfd_set_section_size (extern_rt_rel, PE_IDATA5_SIZE);\n   extern_rt_rel_d = xcalloc (1, PE_IDATA5_SIZE);\n   extern_rt_rel->contents = extern_rt_rel_d;\n \n@@ -3571,7 +3569,7 @@ pe_dll_fill_sections (bfd *abfd, struct bfd_link_info *info)\n   generate_reloc (abfd, info);\n   if (reloc_sz > 0)\n     {\n-      bfd_set_section_size (filler_bfd, reloc_s, reloc_sz);\n+      bfd_set_section_size (reloc_s, reloc_sz);\n \n       /* Resize the sections.  */\n       lang_reset_memory_regions ();\n@@ -3603,7 +3601,7 @@ pe_exe_fill_sections (bfd *abfd, struct bfd_link_info *info)\n   generate_reloc (abfd, info);\n   if (reloc_sz > 0)\n     {\n-      bfd_set_section_size (filler_bfd, reloc_s, reloc_sz);\n+      bfd_set_section_size (reloc_s, reloc_sz);\n \n       /* Resize the sections.  */\n       lang_reset_memory_regions ();"
    },
    {
      "sha": "8a82ed0565f82f6176f6e818c74de0bc651ea678",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,7 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* ctf-open-bfd.c: Update throughout for bfd section macro changes.\n+\n 2019-09-09  Phil Blundell  <pb@pbcl.net>\n \n \tbinutils 2.33 branch created."
    },
    {
      "sha": "6a0c15531ef7cb6fea83c49a1595f433f7c88565",
      "filename": "libctf/ctf-open-bfd.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/libctf/ctf-open-bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/libctf/ctf-open-bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open-bfd.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -100,7 +100,7 @@ ctf_bfdopen (struct bfd *abfd, int *errp)\n \n   ctfsect.cts_name = _CTF_SECTION;\n   ctfsect.cts_entsize = 1;\n-  ctfsect.cts_size = bfd_section_size (abfd, ctf_asect);\n+  ctfsect.cts_size = bfd_section_size (ctf_asect);\n   ctfsect.cts_data = contents;\n \n   if ((arc = ctf_bfdopen_ctfsect (abfd, &ctfsect, errp)) != NULL)\n@@ -157,7 +157,7 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n \t    }\n \t  strsect.cts_data = contents;\n \t  strsect.cts_name = (char *) strsect.cts_data + strhdr->sh_name;\n-\t  strsect.cts_size = bfd_section_size (abfd, str_asect);\n+\t  strsect.cts_size = bfd_section_size (str_asect);\n \t  strsect.cts_entsize = strhdr->sh_size;\n \t  strsectp = &strsect;\n \n@@ -170,7 +170,7 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n \n \t  symsect.cts_name = (char *) strsect.cts_data + symhdr->sh_name;\n \t  symsect.cts_entsize = symhdr->sh_size;\n-\t  symsect.cts_size = bfd_section_size (abfd, sym_asect);\n+\t  symsect.cts_size = bfd_section_size (sym_asect);\n \t  symsect.cts_data = contents;\n \t  symsectp = &symsect;\n \t}"
    },
    {
      "sha": "0d8abcd7ff2017c7f2427a9bd3952417ac5aeeb3",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,7 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* arc-ext.c: Update throughout for bfd section macro changes.\n+\n 2019-09-18  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* Makefile.in: Re-generate."
    },
    {
      "sha": "cfb13aa0e1d3a2b8e234f5bc1d1f28984784dd11",
      "filename": "opcodes/arc-ext.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/opcodes/arc-ext.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/opcodes/arc-ext.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arc-ext.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -438,7 +438,7 @@ build_ARC_extmap (bfd *text_bfd)\n \t  sizeof (\".gnu.linkonce.arcextmap.\") - 1)\n \t|| !strcmp (sect->name,\".arcextmap\"))\n       {\n-\tbfd_size_type  count  = bfd_get_section_size (sect);\n+\tbfd_size_type  count  = bfd_section_size (sect);\n \tunsigned char* buffer = xmalloc (count);\n \n \tif (buffer)"
    },
    {
      "sha": "191e2370a98579a21b2f56d75577eaaa20a50c5a",
      "filename": "sim/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ChangeLog?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1,3 +1,11 @@\n+2019-09-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* common/sim-load.c, * common/sim-utils.c, * cris/sim-if.c,\n+\t* erc32/func.c, * lm32/sim-if.c, * m32c/load.c, * m32c/trace.c,\n+\t* m68hc11/interp.c, * ppc/hw_htab.c, * ppc/hw_init.c,\n+\t* rl78/load.c, * rl78/trace.c, * rx/gdb-if.c, * rx/load.c,\n+\t* rx/trace.c: Update throughout for bfd section macro changes.\n+\n 2019-06-13  Stafford Horne  <shorne@gmail.com>\n \n \t* or1k/cpu.c: Regenerate."
    },
    {
      "sha": "ff06497d5c6505a2962609f33b1d659b2f206ec8",
      "filename": "sim/common/sim-load.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/common/sim-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/common/sim-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/common/sim-load.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -101,7 +101,7 @@ sim_load_file (SIM_DESC sd, const char *myname, host_callback *callback,\n \t{\n \t  bfd_size_type size;\n \n-\t  size = bfd_get_section_size (s);\n+\t  size = bfd_section_size (s);\n \t  if (size > 0)\n \t    {\n \t      unsigned char *buffer;\n@@ -119,13 +119,13 @@ sim_load_file (SIM_DESC sd, const char *myname, host_callback *callback,\n \t\t  return NULL;\n \t\t}\n \t      if (lma_p)\n-\t\tlma = bfd_section_lma (result_bfd, s);\n+\t\tlma = bfd_section_lma (s);\n \t      else\n-\t\tlma = bfd_section_vma (result_bfd, s);\n+\t\tlma = bfd_section_vma (s);\n \t      if (verbose_p)\n \t\t{\n \t\t  xprintf (callback, \"Loading section %s, size 0x%lx %s \",\n-\t\t\t   bfd_get_section_name (result_bfd, s),\n+\t\t\t   bfd_section_name (s),\n \t\t\t   (unsigned long) size,\n \t\t\t   (lma_p ? \"lma\" : \"vma\"));\n \t\t  xprintf_bfd_vma (callback, lma);"
    },
    {
      "sha": "e83a2e4d0c83206b7f3a3d70fefd11c7c5191619",
      "filename": "sim/common/sim-utils.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/common/sim-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/common/sim-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/common/sim-utils.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -263,11 +263,11 @@ sim_analyze_program (SIM_DESC sd, const char *prog_name, bfd *prog_bfd)\n   STATE_START_ADDR (sd) = bfd_get_start_address (prog_bfd);\n \n   for (s = prog_bfd->sections; s; s = s->next)\n-    if (strcmp (bfd_get_section_name (prog_bfd, s), \".text\") == 0)\n+    if (strcmp (bfd_section_name (s), \".text\") == 0)\n       {\n \tSTATE_TEXT_SECTION (sd) = s;\n-\tSTATE_TEXT_START (sd) = bfd_get_section_vma (prog_bfd, s);\n-\tSTATE_TEXT_END (sd) = STATE_TEXT_START (sd) + bfd_section_size (prog_bfd, s);\n+\tSTATE_TEXT_START (sd) = bfd_section_vma (s);\n+\tSTATE_TEXT_END (sd) = STATE_TEXT_START (sd) + bfd_section_size (s);\n \tbreak;\n       }\n "
    },
    {
      "sha": "ebfb0e586b4ac045d327c267d3f03ecbc6a57492",
      "filename": "sim/cris/sim-if.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/cris/sim-if.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/cris/sim-if.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/cris/sim-if.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -315,17 +315,17 @@ cris_set_section_offset_iterator (bfd *abfd, asection *s, void *vp)\n   SIM_DESC sd = p->sd;\n   int offset = p->offset;\n \n-  if ((bfd_get_section_flags (abfd, s) & SEC_ALLOC))\n+  if ((bfd_section_flags (s) & SEC_ALLOC))\n     {\n-      bfd_vma vma = bfd_get_section_vma (abfd, s);\n+      bfd_vma vma = bfd_section_vma (s);\n       \n-      bfd_set_section_vma (abfd, s, vma + offset);\n+      bfd_set_section_vma (s, vma + offset);\n     }\n \n   /* This seems clumsy and inaccurate, but let's stick to doing it the\n      same way as sim_analyze_program for consistency.  */\n-  if (strcmp (bfd_get_section_name (abfd, s), \".text\") == 0)\n-    STATE_TEXT_START (sd) = bfd_get_section_vma (abfd, s);\n+  if (strcmp (bfd_section_name (s), \".text\") == 0)\n+    STATE_TEXT_START (sd) = bfd_section_vma (s);\n }\n \n /* Adjust the start-address, LMA and VMA of a SD.  Must be called\n@@ -360,10 +360,10 @@ get_progbounds_iterator (bfd *abfd ATTRIBUTE_UNUSED, asection *s, void *vp)\n {\n   struct progbounds *pbp = (struct progbounds *) vp;\n \n-  if ((bfd_get_section_flags (abfd, s) & SEC_ALLOC))\n+  if ((bfd_section_flags (s) & SEC_ALLOC))\n     {\n-      bfd_size_type sec_size = bfd_get_section_size (s);\n-      bfd_size_type sec_start = bfd_get_section_vma (abfd, s);\n+      bfd_size_type sec_size = bfd_section_size (s);\n+      bfd_size_type sec_start = bfd_section_vma (s);\n       bfd_size_type sec_end = sec_start + sec_size;\n \n       if (sec_end > pbp->endmem)\n@@ -372,7 +372,7 @@ get_progbounds_iterator (bfd *abfd ATTRIBUTE_UNUSED, asection *s, void *vp)\n       if (sec_start < pbp->startmem)\n \tpbp->startmem = sec_start;\n \n-      if ((bfd_get_section_flags (abfd, s) & SEC_LOAD))\n+      if ((bfd_section_flags (s) & SEC_LOAD))\n \t{\n \t  if (sec_end > pbp->end_loadmem)\n \t    pbp->end_loadmem = sec_end;"
    },
    {
      "sha": "a0c85a091394b040d4245dac4a3a86cfb706b1ab",
      "filename": "sim/erc32/func.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/erc32/func.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/erc32/func.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/erc32/func.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -1051,14 +1051,14 @@ bfd_load (const char *fname)\n     if (sis_verbose)\n \tprintf(\"loading %s:\", fname);\n     for (section = pbfd->sections; section; section = section->next) {\n-\tif (bfd_get_section_flags(pbfd, section) & SEC_ALLOC) {\n+\tif (bfd_section_flags (section) & SEC_ALLOC) {\n \t    bfd_vma         section_address;\n \t    unsigned long   section_size;\n \t    const char     *section_name;\n \n-\t    section_name = bfd_get_section_name(pbfd, section);\n+\t    section_name = bfd_section_name (section);\n \n-\t    section_address = bfd_get_section_vma(pbfd, section);\n+\t    section_address = bfd_section_vma (section);\n \t    /*\n \t     * Adjust sections from a.out files, since they don't carry their\n \t     * addresses with.\n@@ -1084,14 +1084,14 @@ bfd_load (const char *fname)\n \t\t}\n \t    }\n \n-\t    section_size = bfd_section_size(pbfd, section);\n+\t    section_size = bfd_section_size (section);\n \n \t    if (sis_verbose)\n \t\tprintf(\"\\nsection %s at 0x%08lx (0x%lx bytes)\",\n \t\t       section_name, section_address, section_size);\n \n \t    /* Text, data or lit */\n-\t    if (bfd_get_section_flags(pbfd, section) & SEC_LOAD) {\n+\t    if (bfd_section_flags (section) & SEC_LOAD) {\n \t\tfile_ptr        fptr;\n \n \t\tfptr = 0;"
    },
    {
      "sha": "71312d36442bc341295279d4302af63886b14bcb",
      "filename": "sim/lm32/sim-if.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/lm32/sim-if.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/lm32/sim-if.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/lm32/sim-if.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -50,21 +50,18 @@ find_base (bfd *prog_bfd)\n   found = 0;\n   for (s = prog_bfd->sections; s; s = s->next)\n     {\n-      if ((strcmp (bfd_get_section_name (prog_bfd, s), \".boot\") == 0)\n-\t  || (strcmp (bfd_get_section_name (prog_bfd, s), \".text\") == 0)\n-\t  || (strcmp (bfd_get_section_name (prog_bfd, s), \".data\") == 0)\n-\t  || (strcmp (bfd_get_section_name (prog_bfd, s), \".bss\") == 0))\n+      if ((strcmp (bfd_section_name (s), \".boot\") == 0)\n+\t  || (strcmp (bfd_section_name (s), \".text\") == 0)\n+\t  || (strcmp (bfd_section_name (s), \".data\") == 0)\n+\t  || (strcmp (bfd_section_name (s), \".bss\") == 0))\n \t{\n \t  if (!found)\n \t    {\n-\t      base = bfd_get_section_vma (prog_bfd, s);\n+\t      base = bfd_section_vma (s);\n \t      found = 1;\n \t    }\n \t  else\n-\t    base =\n-\t      bfd_get_section_vma (prog_bfd,\n-\t\t\t\t   s) < base ? bfd_get_section_vma (prog_bfd,\n-\t\t\t\t\t\t\t\t    s) : base;\n+\t    base = bfd_section_vma (s) < base ? bfd_section_vma (s) : base;\n \t}\n     }\n   return base & ~(0xffffUL);"
    },
    {
      "sha": "c6a3b2dcaa9a9271757f0a236cf2cb9493d78164",
      "filename": "sim/m32c/load.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/m32c/load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/m32c/load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32c/load.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -74,11 +74,11 @@ m32c_load (bfd * prog)\n          remains as a reminder.  */\n       if ((s->flags & SEC_ALLOC) && !(s->flags & SEC_READONLY))\n \t{\n-\t  if (strcmp (bfd_get_section_name (prog, s), \".stack\"))\n+\t  if (strcmp (bfd_section_name (s), \".stack\"))\n \t    {\n \t      int secend =\n-\t\tbfd_get_section_size (s) + bfd_section_lma (prog, s);\n-\t      if (heaptop < secend && bfd_section_lma (prog, s) < 0x10000)\n+\t\tbfd_section_size (s) + bfd_section_lma (s);\n+\t      if (heaptop < secend && bfd_section_lma (s) < 0x10000)\n \t\t{\n \t\t  heaptop = heapbottom = secend;\n \t\t}\n@@ -91,14 +91,14 @@ m32c_load (bfd * prog)\n \t  bfd_size_type size;\n \t  bfd_vma base;\n \n-\t  size = bfd_get_section_size (s);\n+\t  size = bfd_section_size (s);\n \t  if (size <= 0)\n \t    continue;\n \n-\t  base = bfd_section_lma (prog, s);\n+\t  base = bfd_section_lma (s);\n \t  if (verbose)\n \t    fprintf (stderr, \"[load a=%08x s=%08x %s]\\n\",\n-\t\t     (int) base, (int) size, bfd_get_section_name (prog, s));\n+\t\t     (int) base, (int) size, bfd_section_name (s));\n \t  buf = (char *) malloc (size);\n \t  bfd_get_section_contents (prog, s, buf, 0, size);\n \t  mem_put_blk (base, buf, size);"
    },
    {
      "sha": "bc75d15e3c9b59799b88314165c093bcc69e5e7c",
      "filename": "sim/m32c/trace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/m32c/trace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/m32c/trace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32c/trace.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -231,7 +231,7 @@ sim_disasm_one (void)\n \t  if (s->flags & SEC_CODE || code_section == 0)\n \t    {\n \t      code_section = s;\n-\t      code_base = bfd_section_lma (current_bfd, s);\n+\t      code_base = bfd_section_lma (s);\n \t      break;\n \t    }\n \t}"
    },
    {
      "sha": "a5131d2a977ccaf211b9b74b355dd273209e773e",
      "filename": "sim/m68hc11/interp.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/m68hc11/interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/m68hc11/interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/interp.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -344,15 +344,15 @@ sim_prepare_for_program (SIM_DESC sd, bfd* abfd)\n             {\n               bfd_size_type size;\n \n-              size = bfd_get_section_size (s);\n+\t      size = bfd_section_size (s);\n               if (size > 0)\n                 {\n                   bfd_vma lma;\n \n                   if (STATE_LOAD_AT_LMA_P (sd))\n-                    lma = bfd_section_lma (abfd, s);\n+\t\t    lma = bfd_section_lma (s);\n                   else\n-                    lma = bfd_section_vma (abfd, s);\n+\t\t    lma = bfd_section_vma (s);\n \n                   if (lma <= 0xFFFE && lma+size >= 0x10000)\n                     cpu->cpu_use_elf_start = 0;"
    },
    {
      "sha": "e7b6371e1dd4ab868ba3c9254d121498e5175f64",
      "filename": "sim/ppc/hw_htab.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/ppc/hw_htab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/ppc/hw_htab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_htab.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -391,25 +391,25 @@ htab_sum_binary(bfd *abfd,\n \t\tPTR data)\n {\n   htab_binary_sizes *sizes = (htab_binary_sizes*)data;\n-  unsigned_word size = bfd_get_section_size (sec);\n-  unsigned_word vma = bfd_get_section_vma (abfd, sec);\n-  unsigned_word ra = bfd_get_section_lma (abfd, sec);\n+  unsigned_word size = bfd_section_size (sec);\n+  unsigned_word vma = bfd_section_vma (sec);\n+  unsigned_word ra = bfd_section_lma (sec);\n \n   /* skip the section if no memory to allocate */\n-  if (! (bfd_get_section_flags(abfd, sec) & SEC_ALLOC))\n+  if (! (bfd_section_flags (sec) & SEC_ALLOC))\n     return;\n \n-  if ((bfd_get_section_flags (abfd, sec) & SEC_CODE)\n-      || (bfd_get_section_flags (abfd, sec) & SEC_READONLY)) {\n+  if ((bfd_section_flags (sec) & SEC_CODE)\n+      || (bfd_section_flags (sec) & SEC_READONLY)) {\n     if (sizes->text_bound < vma + size)\n       sizes->text_bound = ALIGN_PAGE(vma + size);\n     if (sizes->text_base > vma)\n       sizes->text_base = FLOOR_PAGE(vma);\n     if (sizes->text_ra > ra)\n       sizes->text_ra = FLOOR_PAGE(ra);\n   }\n-  else if ((bfd_get_section_flags (abfd, sec) & SEC_DATA)\n-\t   || (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)) {\n+  else if ((bfd_section_flags (sec) & SEC_DATA)\n+\t   || (bfd_section_flags (sec) & SEC_ALLOC)) {\n     if (sizes->data_bound < vma + size)\n       sizes->data_bound = ALIGN_PAGE(vma + size);\n     if (sizes->data_base > vma)\n@@ -432,41 +432,41 @@ htab_dma_binary(bfd *abfd,\n   device *me = sizes->me;\n \n   /* skip the section if no memory to allocate */\n-  if (! (bfd_get_section_flags(abfd, sec) & SEC_ALLOC))\n+  if (! (bfd_section_flags (sec) & SEC_ALLOC))\n     return;\n \n   /* check/ignore any sections of size zero */\n-  section_size = bfd_get_section_size (sec);\n+  section_size = bfd_section_size (sec);\n   if (section_size == 0)\n     return;\n \n   /* if nothing to load, ignore this one */\n-  if (! (bfd_get_section_flags(abfd, sec) & SEC_LOAD))\n+  if (! (bfd_section_flags (sec) & SEC_LOAD))\n     return;\n \n   /* find where it is to go */\n-  section_vma = bfd_get_section_vma(abfd, sec);\n+  section_vma = bfd_section_vma (sec);\n   section_ra = 0;\n-  if ((bfd_get_section_flags (abfd, sec) & SEC_CODE)\n-      || (bfd_get_section_flags (abfd, sec) & SEC_READONLY))\n+  if ((bfd_section_flags (sec) & SEC_CODE)\n+      || (bfd_section_flags (sec) & SEC_READONLY))\n     section_ra = (section_vma - sizes->text_base + sizes->text_ra);\n-  else if ((bfd_get_section_flags (abfd, sec) & SEC_DATA))\n+  else if ((bfd_section_flags (sec) & SEC_DATA))\n     section_ra = (section_vma - sizes->data_base + sizes->data_ra);\n   else \n     return; /* just ignore it */\n \n   DTRACE(htab,\n \t (\"load - name=%-7s vma=0x%.8lx size=%6ld ra=0x%.8lx flags=%3lx(%s%s%s%s%s )\\n\",\n-\t  bfd_get_section_name(abfd, sec),\n+\t  bfd_section_name (sec),\n \t  (long)section_vma,\n \t  (long)section_size,\n \t  (long)section_ra,\n-\t  (long)bfd_get_section_flags(abfd, sec),\n-\t  bfd_get_section_flags(abfd, sec) & SEC_LOAD ? \" LOAD\" : \"\",\n-\t  bfd_get_section_flags(abfd, sec) & SEC_CODE ? \" CODE\" : \"\",\n-\t  bfd_get_section_flags(abfd, sec) & SEC_DATA ? \" DATA\" : \"\",\n-\t  bfd_get_section_flags(abfd, sec) & SEC_ALLOC ? \" ALLOC\" : \"\",\n-\t  bfd_get_section_flags(abfd, sec) & SEC_READONLY ? \" READONLY\" : \"\"\n+\t  (long)bfd_section_flags (sec),\n+\t  bfd_section_flags (sec) & SEC_LOAD ? \" LOAD\" : \"\",\n+\t  bfd_section_flags (sec) & SEC_CODE ? \" CODE\" : \"\",\n+\t  bfd_section_flags (sec) & SEC_DATA ? \" DATA\" : \"\",\n+\t  bfd_section_flags (sec) & SEC_ALLOC ? \" ALLOC\" : \"\",\n+\t  bfd_section_flags (sec) & SEC_READONLY ? \" READONLY\" : \"\"\n \t  ));\n \n   /* dma in the sections data */"
    },
    {
      "sha": "779c95c5a24ce3a3112c2b67c348fef718a304c0",
      "filename": "sim/ppc/hw_init.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/ppc/hw_init.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3619828e94a24a92cddec42cbc0ab33352eeb4/sim/ppc/hw_init.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_init.c?ref=fd3619828e94a24a92cddec42cbc0ab33352eeb4",
      "patch": "@@ -324,39 +324,39 @@ update_for_binary_section(bfd *abfd,\n   device *me = (device*)obj;\n \n   /* skip the section if no memory to allocate */\n-  if (! (bfd_get_section_flags(abfd, the_section) & SEC_ALLOC))\n+  if (! (bfd_section_flags (the_section) & SEC_ALLOC))\n     return;\n \n   /* check/ignore any sections of size zero */\n-  section_size = bfd_get_section_size (the_section);\n+  section_size = bfd_section_size (the_section);\n   if (section_size == 0)\n     return;\n \n   /* find where it is to go */\n-  section_vma = bfd_get_section_vma(abfd, the_section);\n+  section_vma = bfd_section_vma (the_section);\n \n   DTRACE(binary,\n \t (\"name=%-7s, vma=0x%.8lx, size=%6ld, flags=%3lx(%s%s%s%s%s )\\n\",\n-\t  bfd_get_section_name(abfd, the_section),\n+\t  bfd_section_name (the_section),\n \t  (long)section_vma,\n \t  (long)section_size,\n-\t  (long)bfd_get_section_flags(abfd, the_section),\n-\t  bfd_get_section_flags(abfd, the_section) & SEC_LOAD ? \" LOAD\" : \"\",\n-\t  bfd_get_section_flags(abfd, the_section) & SEC_CODE ? \" CODE\" : \"\",\n-\t  bfd_get_section_flags(abfd, the_section) & SEC_DATA ? \" DATA\" : \"\",\n-\t  bfd_get_section_flags(abfd, the_section) & SEC_ALLOC ? \" ALLOC\" : \"\",\n-\t  bfd_get_section_flags(abfd, the_section) & SEC_READONLY ? \" READONLY\" : \"\"\n+\t  (long)bfd_section_flags (the_section),\n+\t  bfd_section_flags (the_section) & SEC_LOAD ? \" LOAD\" : \"\",\n+\t  bfd_section_flags (the_section) & SEC_CODE ? \" CODE\" : \"\",\n+\t  bfd_section_flags (the_section) & SEC_DATA ? \" DATA\" : \"\",\n+\t  bfd_section_flags (the_section) & SEC_ALLOC ? \" ALLOC\" : \"\",\n+\t  bfd_section_flags (the_section) & SEC_READONLY ? \" READONLY\" : \"\"\n \t  ));\n \n   /* If there is an .interp section, it means it needs a shared library interpreter.  */\n-  if (strcmp(\".interp\", bfd_get_section_name(abfd, the_section)) == 0)\n+  if (strcmp(\".interp\", bfd_section_name (the_section)) == 0)\n     error(\"Shared libraries are not yet supported.\\n\");\n \n   /* determine the devices access */\n   access = access_read;\n-  if (bfd_get_section_flags(abfd, the_section) & SEC_CODE)\n+  if (bfd_section_flags (the_section) & SEC_CODE)\n     access |= access_exec;\n-  if (!(bfd_get_section_flags(abfd, the_section) & SEC_READONLY))\n+  if (!(bfd_section_flags (the_section) & SEC_READONLY))\n     access |= access_write;\n \n   /* if claim specified, allocate region from the memory device */\n@@ -386,7 +386,7 @@ update_for_binary_section(bfd *abfd,\n \t\t\t  me);\n \n   /* if a load dma in the required data */\n-  if (bfd_get_section_flags(abfd, the_section) & SEC_LOAD) {\n+  if (bfd_section_flags (the_section) & SEC_LOAD) {\n     void *section_init = zalloc(section_size);\n     if (!bfd_get_section_contents(abfd,\n \t\t\t\t  the_section,"
    }
  ]
}