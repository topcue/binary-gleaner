{
  "sha": "9cc89dc0acc140cb27e21d2597af42d36444673b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWNjODlkYzBhY2MxNDBjYjI3ZTIxZDI1OTdhZjQyZDM2NDQ0NjczYg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-11T03:20:35Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-11T04:31:15Z"
    },
    "message": "PR25651, objcopy SIGSEGV in copy_object\n\nWith the right set of options, the second block of code dealing with\npadding can see a different section count.  So don't use the new count.\nSince I was editing those lines, I've also changed the code allocating\narrays a little.\n    array = malloc (n * sizeof (*array));\nfor an array of ints is just better than\n    array = malloc (n * sizeof (int));\nIt's easier to write correctly in the first place and more robust\nagainst code changes that might modify the array element type.\n\n\tPR 25651\n\t* objcopy.c (copy_object): Test \"gaps\" not gap_fill_set or\n\tpad_to_set on second block of code dealing with padding.\n\tReplace \"c\" with \"num_sec\" and don't recalculate number of\n\tsections on second block.  Size arrays using sizeof (element)\n\trather than sizeof (element type).",
    "tree": {
      "sha": "6fc9a4fe2c099ba2fa0714c2b7933cf827833ae6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6fc9a4fe2c099ba2fa0714c2b7933cf827833ae6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9cc89dc0acc140cb27e21d2597af42d36444673b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9cc89dc0acc140cb27e21d2597af42d36444673b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9cc89dc0acc140cb27e21d2597af42d36444673b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9cc89dc0acc140cb27e21d2597af42d36444673b/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1db6f990303ab6c45909f8e133641ef6c24a04d2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1db6f990303ab6c45909f8e133641ef6c24a04d2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1db6f990303ab6c45909f8e133641ef6c24a04d2"
    }
  ],
  "stats": {
    "total": 42,
    "additions": 25,
    "deletions": 17
  },
  "files": [
    {
      "sha": "0ca05640d82b8ce1a8e131f0f1724c0037a05496",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9cc89dc0acc140cb27e21d2597af42d36444673b/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9cc89dc0acc140cb27e21d2597af42d36444673b/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=9cc89dc0acc140cb27e21d2597af42d36444673b",
      "patch": "@@ -1,3 +1,12 @@\n+2020-03-11  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25651\n+\t* objcopy.c (copy_object): Test \"gaps\" not gap_fill_set or\n+\tpad_to_set on second block of code dealing with padding.\n+\tReplace \"c\" with \"num_sec\" and don't recalculate number of\n+\tsections on second block.  Size arrays using sizeof (element)\n+\trather than sizeof (element type).\n+\n 2020-03-10  Alan Modra  <amodra@gmail.com>\n \n \t* objdump.c (disassemble_section): Don't call qsort unless"
    },
    {
      "sha": "e6711a99fb2f0324c8f7edea21580daa061cfdaa",
      "filename": "binutils/objcopy.c",
      "status": "modified",
      "additions": 16,
      "deletions": 17,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9cc89dc0acc140cb27e21d2597af42d36444673b/binutils/objcopy.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9cc89dc0acc140cb27e21d2597af42d36444673b/binutils/objcopy.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objcopy.c?ref=9cc89dc0acc140cb27e21d2597af42d36444673b",
      "patch": "@@ -2596,7 +2596,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n   void *dhandle;\n   enum bfd_architecture iarch;\n   unsigned int imach;\n-  unsigned int c, i;\n+  unsigned int num_sec, i;\n \n   if (ibfd->xvec->byteorder != obfd->xvec->byteorder\n       && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN\n@@ -3101,8 +3101,8 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t}\n     }\n \n-  c = bfd_count_sections (obfd);\n-  if (c != 0\n+  num_sec = bfd_count_sections (obfd);\n+  if (num_sec != 0\n       && (gap_fill_set || pad_to_set))\n     {\n       asection **set;\n@@ -3113,18 +3113,18 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t increasing the section sizes as required to fill the gaps.\n \t We write out the gap contents below.  */\n \n-      osections = (asection **) xmalloc (c * sizeof (asection *));\n+      osections = xmalloc (num_sec * sizeof (*osections));\n       set = osections;\n       bfd_map_over_sections (obfd, get_sections, &set);\n \n-      qsort (osections, c, sizeof (asection *), compare_section_lma);\n+      qsort (osections, num_sec, sizeof (*osections), compare_section_lma);\n \n-      gaps = (bfd_size_type *) xmalloc (c * sizeof (bfd_size_type));\n-      memset (gaps, 0, c * sizeof (bfd_size_type));\n+      gaps = xmalloc (num_sec * sizeof (*gaps));\n+      memset (gaps, 0, num_sec * sizeof (*gaps));\n \n       if (gap_fill_set)\n \t{\n-\t  for (i = 0; i < c - 1; i++)\n+\t  for (i = 0; i < num_sec - 1; i++)\n \t    {\n \t      flagword flags;\n \t      bfd_size_type size;           /* Octets.  */\n@@ -3161,22 +3161,22 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t{\n \t  bfd_vma lma;         /* Octets.  */\n \t  bfd_size_type size;  /* Octets.  */\n-\t  unsigned int opb = bfd_octets_per_byte (obfd, osections[c - 1]);\n+\t  unsigned int opb = bfd_octets_per_byte (obfd, osections[num_sec - 1]);\n \t  bfd_vma _pad_to = pad_to * opb;\n \n-\t  lma = bfd_section_lma (osections[c - 1]) * opb;\n-\t  size = bfd_section_size (osections[c - 1]);\n+\t  lma = bfd_section_lma (osections[num_sec - 1]) * opb;\n+\t  size = bfd_section_size (osections[num_sec - 1]);\n \t  if (lma + size < _pad_to)\n \t    {\n-\t      if (!bfd_set_section_size (osections[c - 1], _pad_to - lma))\n+\t      if (!bfd_set_section_size (osections[num_sec - 1], _pad_to - lma))\n \t\t{\n-\t\t  bfd_nonfatal_message (NULL, obfd, osections[c - 1],\n+\t\t  bfd_nonfatal_message (NULL, obfd, osections[num_sec - 1],\n \t\t\t\t\t_(\"can't add padding\"));\n \t\t  status = 1;\n \t\t}\n \t      else\n \t\t{\n-\t\t  gaps[c - 1] = _pad_to - (lma + size);\n+\t\t  gaps[num_sec - 1] = _pad_to - (lma + size);\n \t\t  if (max_gap < _pad_to - (lma + size))\n \t\t    max_gap = _pad_to - (lma + size);\n \t\t}\n@@ -3376,7 +3376,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t}\n     }\n \n-  if (gap_fill_set || pad_to_set)\n+  if (gaps != NULL)\n     {\n       bfd_byte *buf;\n \n@@ -3386,8 +3386,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n       buf = (bfd_byte *) xmalloc (max_gap);\n       memset (buf, gap_fill, max_gap);\n \n-      c = bfd_count_sections (obfd);\n-      for (i = 0; i < c; i++)\n+      for (i = 0; i < num_sec; i++)\n \t{\n \t  if (gaps[i] != 0)\n \t    {"
    }
  ]
}