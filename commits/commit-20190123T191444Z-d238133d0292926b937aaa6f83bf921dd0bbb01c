{
  "sha": "d238133d0292926b937aaa6f83bf921dd0bbb01c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDIzODEzM2QwMjkyOTI2YjkzN2FhYTZmODNiZjkyMWRkMGJiYjAxYw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-23T18:58:35Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-01-23T19:14:44Z"
    },
    "message": "Remove remaining cleanup from fetch_inferior_event\n\nThis removes the remaining cleanup from fetch_inferior_event,\nreplacing it with a SCOPE_EXIT.  This required introducing a new scope\nand reindenting.\n\ngdb/ChangeLog:\n2019-01-23  Tom Tromey  <tom@tromey.com>\n\t    Pedro Alves  <palves@redhat.com>\n\n\t* infrun.c (reinstall_readline_callback_handler_cleanup): Remove\n\tparameter.\n\t(fetch_inferior_event): Use SCOPE_EXIT.",
    "tree": {
      "sha": "add216a70ed4a3b0903ca76ee3916c1a17627836",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/add216a70ed4a3b0903ca76ee3916c1a17627836"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d238133d0292926b937aaa6f83bf921dd0bbb01c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d238133d0292926b937aaa6f83bf921dd0bbb01c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d238133d0292926b937aaa6f83bf921dd0bbb01c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d238133d0292926b937aaa6f83bf921dd0bbb01c/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9885e6bb5b0f6f0147f9b3a15a4bd4516faf4a26",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9885e6bb5b0f6f0147f9b3a15a4bd4516faf4a26",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9885e6bb5b0f6f0147f9b3a15a4bd4516faf4a26"
    }
  ],
  "stats": {
    "total": 210,
    "additions": 110,
    "deletions": 100
  },
  "files": [
    {
      "sha": "33261fed14e668bf327929749d0e472cce7921b3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d238133d0292926b937aaa6f83bf921dd0bbb01c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d238133d0292926b937aaa6f83bf921dd0bbb01c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d238133d0292926b937aaa6f83bf921dd0bbb01c",
      "patch": "@@ -1,3 +1,11 @@\n+2019-01-23  Tom Tromey  <tom@tromey.com>\n+\t    Pedro Alves  <palves@redhat.com>\n+\n+\t* infrun.c (reinstall_readline_callback_handler_cleanup): Remove\n+\tparameter.\n+\t(fetch_inferior_event): Use SCOPE_EXIT.\n+\n+\n 2019-01-23  Tom Tromey  <tom@tromey.com>\n \t    Pedro Alves  <palves@redhat.com>\n "
    },
    {
      "sha": "68574679830f982665f1a07347dce9f45e076569",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 102,
      "deletions": 100,
      "changes": 202,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d238133d0292926b937aaa6f83bf921dd0bbb01c/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d238133d0292926b937aaa6f83bf921dd0bbb01c/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=d238133d0292926b937aaa6f83bf921dd0bbb01c",
      "patch": "@@ -3585,7 +3585,7 @@ wait_for_inferior (void)\n    input.  */\n \n static void\n-reinstall_readline_callback_handler_cleanup (void *arg)\n+reinstall_readline_callback_handler_cleanup ()\n {\n   struct ui *ui = current_ui;\n \n@@ -3687,7 +3687,6 @@ fetch_inferior_event (void *client_data)\n {\n   struct execution_control_state ecss;\n   struct execution_control_state *ecs = &ecss;\n-  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);\n   int cmd_done = 0;\n   ptid_t waiton_ptid = minus_one_ptid;\n \n@@ -3699,116 +3698,119 @@ fetch_inferior_event (void *client_data)\n   scoped_restore save_ui = make_scoped_restore (&current_ui, main_ui);\n \n   /* End up with readline processing input, if necessary.  */\n-  make_cleanup (reinstall_readline_callback_handler_cleanup, NULL);\n-\n-  /* We're handling a live event, so make sure we're doing live\n-     debugging.  If we're looking at traceframes while the target is\n-     running, we're going to need to get back to that mode after\n-     handling the event.  */\n-  gdb::optional<scoped_restore_current_traceframe> maybe_restore_traceframe;\n-  if (non_stop)\n-    {\n-      maybe_restore_traceframe.emplace ();\n-      set_current_traceframe (-1);\n-    }\n-\n-  gdb::optional<scoped_restore_current_thread> maybe_restore_thread;\n-\n-  if (non_stop)\n-    /* In non-stop mode, the user/frontend should not notice a thread\n-       switch due to internal events.  Make sure we reverse to the\n-       user selected thread and frame after handling the event and\n-       running any breakpoint commands.  */\n-    maybe_restore_thread.emplace ();\n-\n-  overlay_cache_invalid = 1;\n-  /* Flush target cache before starting to handle each event.  Target\n-     was running and cache could be stale.  This is just a heuristic.\n-     Running threads may modify target memory, but we don't get any\n-     event.  */\n-  target_dcache_invalidate ();\n-\n-  scoped_restore save_exec_dir\n-    = make_scoped_restore (&execution_direction, target_execution_direction ());\n-\n-  ecs->ptid = do_target_wait (waiton_ptid, &ecs->ws,\n-\t\t\t      target_can_async_p () ? TARGET_WNOHANG : 0);\n-\n-  if (debug_infrun)\n-    print_target_wait_results (waiton_ptid, ecs->ptid, &ecs->ws);\n-\n-  /* If an error happens while handling the event, propagate GDB's\n-     knowledge of the executing state to the frontend/user running\n-     state.  */\n-  ptid_t finish_ptid = !target_is_non_stop_p () ? minus_one_ptid : ecs->ptid;\n-  scoped_finish_thread_state finish_state (finish_ptid);\n-\n-  /* Get executed before make_cleanup_restore_current_thread above to apply\n-     still for the thread which has thrown the exception.  */\n-  auto defer_bpstat_clear\n-    = make_scope_exit (bpstat_clear_actions);\n-  auto defer_delete_threads\n-    = make_scope_exit (delete_just_stopped_threads_infrun_breakpoints);\n-\n-  /* Now figure out what to do with the result of the result.  */\n-  handle_inferior_event (ecs);\n+  {\n+    SCOPE_EXIT { reinstall_readline_callback_handler_cleanup (); };\n+\n+    /* We're handling a live event, so make sure we're doing live\n+       debugging.  If we're looking at traceframes while the target is\n+       running, we're going to need to get back to that mode after\n+       handling the event.  */\n+    gdb::optional<scoped_restore_current_traceframe> maybe_restore_traceframe;\n+    if (non_stop)\n+      {\n+\tmaybe_restore_traceframe.emplace ();\n+\tset_current_traceframe (-1);\n+      }\n \n-  if (!ecs->wait_some_more)\n-    {\n-      struct inferior *inf = find_inferior_ptid (ecs->ptid);\n-      int should_stop = 1;\n-      struct thread_info *thr = ecs->event_thread;\n+    gdb::optional<scoped_restore_current_thread> maybe_restore_thread;\n+\n+    if (non_stop)\n+      /* In non-stop mode, the user/frontend should not notice a thread\n+\t switch due to internal events.  Make sure we reverse to the\n+\t user selected thread and frame after handling the event and\n+\t running any breakpoint commands.  */\n+      maybe_restore_thread.emplace ();\n+\n+    overlay_cache_invalid = 1;\n+    /* Flush target cache before starting to handle each event.  Target\n+       was running and cache could be stale.  This is just a heuristic.\n+       Running threads may modify target memory, but we don't get any\n+       event.  */\n+    target_dcache_invalidate ();\n+\n+    scoped_restore save_exec_dir\n+      = make_scoped_restore (&execution_direction,\n+\t\t\t     target_execution_direction ());\n+\n+    ecs->ptid = do_target_wait (waiton_ptid, &ecs->ws,\n+\t\t\t\ttarget_can_async_p () ? TARGET_WNOHANG : 0);\n+\n+    if (debug_infrun)\n+      print_target_wait_results (waiton_ptid, ecs->ptid, &ecs->ws);\n+\n+    /* If an error happens while handling the event, propagate GDB's\n+       knowledge of the executing state to the frontend/user running\n+       state.  */\n+    ptid_t finish_ptid = !target_is_non_stop_p () ? minus_one_ptid : ecs->ptid;\n+    scoped_finish_thread_state finish_state (finish_ptid);\n+\n+    /* Get executed before make_cleanup_restore_current_thread above to apply\n+       still for the thread which has thrown the exception.  */\n+    auto defer_bpstat_clear\n+      = make_scope_exit (bpstat_clear_actions);\n+    auto defer_delete_threads\n+      = make_scope_exit (delete_just_stopped_threads_infrun_breakpoints);\n+\n+    /* Now figure out what to do with the result of the result.  */\n+    handle_inferior_event (ecs);\n+\n+    if (!ecs->wait_some_more)\n+      {\n+\tstruct inferior *inf = find_inferior_ptid (ecs->ptid);\n+\tint should_stop = 1;\n+\tstruct thread_info *thr = ecs->event_thread;\n \n-      delete_just_stopped_threads_infrun_breakpoints ();\n+\tdelete_just_stopped_threads_infrun_breakpoints ();\n \n-      if (thr != NULL)\n-\t{\n-\t  struct thread_fsm *thread_fsm = thr->thread_fsm;\n+\tif (thr != NULL)\n+\t  {\n+\t    struct thread_fsm *thread_fsm = thr->thread_fsm;\n \n-\t  if (thread_fsm != NULL)\n-\t    should_stop = thread_fsm_should_stop (thread_fsm, thr);\n-\t}\n+\t    if (thread_fsm != NULL)\n+\t      should_stop = thread_fsm_should_stop (thread_fsm, thr);\n+\t  }\n \n-      if (!should_stop)\n-\t{\n-\t  keep_going (ecs);\n-\t}\n-      else\n-\t{\n-\t  int should_notify_stop = 1;\n-\t  int proceeded = 0;\n+\tif (!should_stop)\n+\t  {\n+\t    keep_going (ecs);\n+\t  }\n+\telse\n+\t  {\n+\t    int should_notify_stop = 1;\n+\t    int proceeded = 0;\n \n-\t  clean_up_just_stopped_threads_fsms (ecs);\n+\t    clean_up_just_stopped_threads_fsms (ecs);\n \n-\t  if (thr != NULL && thr->thread_fsm != NULL)\n-\t    {\n-\t      should_notify_stop\n-\t\t= thread_fsm_should_notify_stop (thr->thread_fsm);\n-\t    }\n+\t    if (thr != NULL && thr->thread_fsm != NULL)\n+\t      {\n+\t\tshould_notify_stop\n+\t\t  = thread_fsm_should_notify_stop (thr->thread_fsm);\n+\t      }\n \n-\t  if (should_notify_stop)\n-\t    {\n-\t      /* We may not find an inferior if this was a process exit.  */\n-\t      if (inf == NULL || inf->control.stop_soon == NO_STOP_QUIETLY)\n-\t\tproceeded = normal_stop ();\n-\t    }\n+\t    if (should_notify_stop)\n+\t      {\n+\t\t/* We may not find an inferior if this was a process exit.  */\n+\t\tif (inf == NULL || inf->control.stop_soon == NO_STOP_QUIETLY)\n+\t\t  proceeded = normal_stop ();\n+\t      }\n \n-\t  if (!proceeded)\n-\t    {\n-\t      inferior_event_handler (INF_EXEC_COMPLETE, NULL);\n-\t      cmd_done = 1;\n-\t    }\n-\t}\n-    }\n+\t    if (!proceeded)\n+\t      {\n+\t\tinferior_event_handler (INF_EXEC_COMPLETE, NULL);\n+\t\tcmd_done = 1;\n+\t      }\n+\t  }\n+      }\n \n-  defer_delete_threads.release ();\n-  defer_bpstat_clear.release ();\n+    defer_delete_threads.release ();\n+    defer_bpstat_clear.release ();\n \n-  /* No error, don't finish the thread states yet.  */\n-  finish_state.release ();\n+    /* No error, don't finish the thread states yet.  */\n+    finish_state.release ();\n \n-  /* Revert thread and frame.  */\n-  do_cleanups (old_chain);\n+    /* This scope is used to ensure that readline callbacks are\n+       reinstalled here.  */\n+  }\n \n   /* If a UI was in sync execution mode, and now isn't, restore its\n      prompt (a synchronous execution command has finished, and we're"
    }
  ]
}