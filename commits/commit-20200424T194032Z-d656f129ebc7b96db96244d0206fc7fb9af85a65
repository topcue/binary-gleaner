{
  "sha": "d656f129ebc7b96db96244d0206fc7fb9af85a65",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDY1NmYxMjllYmM3Yjk2ZGI5NjI0NGQwMjA2ZmM3ZmI5YWY4NWE2NQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T19:40:31Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T19:40:32Z"
    },
    "message": "Update Ada ptype support for dynamic types\n\nThe DWARF reader was updated to handle variant parts and some other\nselected features for Ada; but the Ada \"ptype\" code was not touched.\nThis patch changes the Ada ptype code to handle the new types\nproperly.\n\nTest cases for this and for some of the other code in this series are\nin a separate patch.\n\ngdb/ChangeLog\n2020-04-24  Tom Tromey  <tromey@adacore.com>\n\n\t* ada-typeprint.c (print_choices, print_variant_part)\n\t(print_record_field_types_dynamic): New functions.\n\t(print_record_field_types): Use print_record_field_types_dynamic.",
    "tree": {
      "sha": "ca04689520072c44fa3b230d8e74e9b42129d977",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ca04689520072c44fa3b230d8e74e9b42129d977"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d656f129ebc7b96db96244d0206fc7fb9af85a65",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d656f129ebc7b96db96244d0206fc7fb9af85a65",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d656f129ebc7b96db96244d0206fc7fb9af85a65",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d656f129ebc7b96db96244d0206fc7fb9af85a65/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7d79de9a4be2d1abb0320c322967f1aad39b1f7d"
    }
  ],
  "stats": {
    "total": 135,
    "additions": 135,
    "deletions": 0
  },
  "files": [
    {
      "sha": "7cccdd0c3a181e4664e498e3ffea90eee56758ef",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d656f129ebc7b96db96244d0206fc7fb9af85a65/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d656f129ebc7b96db96244d0206fc7fb9af85a65/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d656f129ebc7b96db96244d0206fc7fb9af85a65",
      "patch": "@@ -1,3 +1,9 @@\n+2020-04-24  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ada-typeprint.c (print_choices, print_variant_part)\n+\t(print_record_field_types_dynamic): New functions.\n+\t(print_record_field_types): Use print_record_field_types_dynamic.\n+\n 2020-04-24  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf2/read.c (handle_data_member_location): New overload."
    },
    {
      "sha": "83972fe125dc24103c8df54212d8c444931232c4",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 129,
      "deletions": 0,
      "changes": 129,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d656f129ebc7b96db96244d0206fc7fb9af85a65/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d656f129ebc7b96db96244d0206fc7fb9af85a65/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=d656f129ebc7b96db96244d0206fc7fb9af85a65",
      "patch": "@@ -654,6 +654,120 @@ print_selected_record_field_types (struct type *type, struct type *outer_type,\n   return flds;\n }\n \n+static void print_record_field_types_dynamic\n+  (const gdb::array_view<variant_part> &parts,\n+   int from, int to, struct type *type, struct ui_file *stream,\n+   int show, int level, const struct type_print_options *flags);\n+\n+/* Print the choices encoded by VARIANT on STREAM.  LEVEL is the\n+   indentation level.  The type of the discriminant for VARIANT is\n+   given by DISR_TYPE.  */\n+\n+static void\n+print_choices (struct type *discr_type, const variant &variant,\n+\t       struct ui_file *stream, int level)\n+{\n+  fprintf_filtered (stream, \"\\n%*swhen \", level, \"\");\n+  if (variant.is_default ())\n+    fprintf_filtered (stream, \"others\");\n+  else\n+    {\n+      bool first = true;\n+      for (const discriminant_range &range : variant.discriminants)\n+\t{\n+\t  if (!first)\n+\t    fprintf_filtered (stream, \" | \");\n+\t  first = false;\n+\n+\t  ada_print_scalar (discr_type, range.low, stream);\n+\t  if (range.low != range.high)\n+\t    ada_print_scalar (discr_type, range.high, stream);\n+\t}\n+    }\n+\n+  fprintf_filtered (stream, \" =>\");\n+}\n+\n+/* Print a single variant part, PART, on STREAM.  TYPE is the\n+   enclosing type.  SHOW, LEVEL, and FLAGS are the usual type-printing\n+   settings.  This prints information about PART and the fields it\n+   controls.  It returns the index of the next field that should be\n+   shown -- that is, one after the last field printed by this\n+   call.  */\n+\n+static int\n+print_variant_part (const variant_part &part,\n+\t\t    struct type *type, struct ui_file *stream,\n+\t\t    int show, int level,\n+\t\t    const struct type_print_options *flags)\n+{\n+  struct type *discr_type = nullptr;\n+  const char *name;\n+  if (part.discriminant_index == -1)\n+    name = \"?\";\n+  else\n+    {\n+      name = TYPE_FIELD_NAME (type, part.discriminant_index);\n+      discr_type = TYPE_FIELD_TYPE (type, part.discriminant_index);\n+    }\n+\n+  fprintf_filtered (stream, \"\\n%*scase %s is\", level + 4, \"\", name);\n+\n+  int last_field = -1;\n+  for (const variant &variant : part.variants)\n+    {\n+      print_choices (discr_type, variant, stream, level + 8);\n+\n+      if (variant.first_field == variant.last_field)\n+\tfprintf_filtered (stream, \" null;\");\n+      else\n+\t{\n+\t  print_record_field_types_dynamic (variant.parts,\n+\t\t\t\t\t    variant.first_field,\n+\t\t\t\t\t    variant.last_field, type, stream,\n+\t\t\t\t\t    show, level + 8, flags);\n+\t  last_field = variant.last_field;\n+\t}\n+    }\n+\n+  fprintf_filtered (stream, \"\\n%*send case;\", level + 4, \"\");\n+\n+  return last_field;\n+}\n+\n+/* Print some fields of TYPE to STREAM.  SHOW, LEVEL, and FLAGS are\n+   the usual type-printing settings.  PARTS is the array of variant\n+   parts that correspond to the range of fields to be printed.  FROM\n+   and TO are the range of fields to print.  */\n+\n+static void\n+print_record_field_types_dynamic (const gdb::array_view<variant_part> &parts,\n+\t\t\t\t  int from, int to,\n+\t\t\t\t  struct type *type, struct ui_file *stream,\n+\t\t\t\t  int show, int level,\n+\t\t\t\t  const struct type_print_options *flags)\n+{\n+  int field = from;\n+\n+  for (const variant_part &part : parts)\n+    {\n+      if (part.variants.empty ())\n+\tcontinue;\n+\n+      /* Print any non-varying fields.  */\n+      int first_varying = part.variants[0].first_field;\n+      print_selected_record_field_types (type, type, field,\n+\t\t\t\t\t first_varying - 1, stream,\n+\t\t\t\t\t show, level, flags);\n+\n+      field = print_variant_part (part, type, stream, show, level, flags);\n+    }\n+\n+  /* Print any trailing fields that we were asked to print.  */\n+  print_selected_record_field_types (type, type, field, to - 1, stream, show,\n+\t\t\t\t     level, flags);\n+}\n+\n /* Print a description on STREAM of all fields of record or union type\n    TYPE, as for print_selected_record_field_types, above.  */\n \n@@ -662,6 +776,21 @@ print_record_field_types (struct type *type, struct type *outer_type,\n \t\t\t  struct ui_file *stream, int show, int level,\n \t\t\t  const struct type_print_options *flags)\n {\n+  struct dynamic_prop *prop = get_dyn_prop (DYN_PROP_VARIANT_PARTS, type);\n+  if (prop != nullptr)\n+    {\n+      if (prop->kind == PROP_TYPE)\n+\t{\n+\t  type = prop->data.original_type;\n+\t  prop = get_dyn_prop (DYN_PROP_VARIANT_PARTS, type);\n+\t}\n+      gdb_assert (prop->kind == PROP_VARIANT_PARTS);\n+      print_record_field_types_dynamic (*prop->data.variant_parts,\n+\t\t\t\t\t0, TYPE_NFIELDS (type),\n+\t\t\t\t\ttype, stream, show, level, flags);\n+      return TYPE_NFIELDS (type);\n+    }\n+\n   return print_selected_record_field_types (type, outer_type,\n \t\t\t\t\t    0, TYPE_NFIELDS (type) - 1,\n \t\t\t\t\t    stream, show, level, flags);"
    }
  ]
}