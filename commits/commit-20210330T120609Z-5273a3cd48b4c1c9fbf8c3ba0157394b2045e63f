{
  "sha": "5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTI3M2EzY2Q0OGI0YzFjOWZiZjhjM2JhMDE1NzM5NGIyMDQ1ZTYzZg==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-30T12:06:09Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-30T12:06:09Z"
    },
    "message": "x86: integrate broadcast_op into struct _i386_insn\n\nThere's no need for the extra level of indirection and the extra storage\nneeded for the pointer, pointing from one piece of static data to\nanother. Key checking of broadcast being in effect off of the type field\nof the structure instead.",
    "tree": {
      "sha": "bae326503e5ba787eb564867c80c241875ca792b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bae326503e5ba787eb564867c80c241875ca792b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6225c532b4ce85661c5148d513335c0d8bd90e4f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6225c532b4ce85661c5148d513335c0d8bd90e4f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6225c532b4ce85661c5148d513335c0d8bd90e4f"
    }
  ],
  "stats": {
    "total": 95,
    "additions": 52,
    "deletions": 43
  },
  "files": [
    {
      "sha": "a8d24bf4349e717acd96938c3010c1cdadb05e86",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f",
      "patch": "@@ -1,3 +1,17 @@\n+2021-03-30  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* config/tc-i386.c (broadcast_op): Delete.\n+\t(struct Broadcast_Operation): Move ...\n+\t(struct _i386_insn): ... here. Change field \"broadcast\".\n+\t(match_mem_size): Adjust check for broadcast.\n+\t(optimize_encoding): Likewise.\n+\t(process_suffix): Likewise.\n+\t(build_evex_prefix): Adjust broadcast processing.\n+\t(swap_2_operands): Likewise.\n+\t(check_VecOperations): Likewise.\n+\t(match_template): Likewise.\n+\t(check_VecOperands): Likewise.\n+\n 2021-03-30  Jan Beulich  <jbeulich@suse.com>\n \n \t* config/tc-i386.c (reg_k0): New."
    },
    {
      "sha": "f5cc6a1d64c0491a8297de10acf3dad32eadda79",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 38,
      "deletions": 43,
      "changes": 81,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f",
      "patch": "@@ -232,22 +232,6 @@ struct RC_Operation\n \n static struct RC_Operation rc_op;\n \n-/* The struct describes broadcasting, applied to OPERAND.  FACTOR is\n-   broadcast factor.  */\n-struct Broadcast_Operation\n-{\n-  /* Type of broadcast: {1to2}, {1to4}, {1to8}, or {1to16}.  */\n-  int type;\n-\n-  /* Index of broadcasted operand.  */\n-  unsigned int operand;\n-\n-  /* Number of bytes to broadcast.  */\n-  int bytes;\n-};\n-\n-static struct Broadcast_Operation broadcast_op;\n-\n /* VEX prefix.  */\n typedef struct\n {\n@@ -398,8 +382,21 @@ struct _i386_insn\n     /* Rounding control and SAE attributes.  */\n     struct RC_Operation *rounding;\n \n-    /* Broadcasting attributes.  */\n-    struct Broadcast_Operation *broadcast;\n+    /* Broadcasting attributes.\n+\n+       The struct describes broadcasting, applied to OPERAND.  TYPE is\n+       expresses the broadcast factor.  */\n+    struct Broadcast_Operation\n+    {\n+      /* Type of broadcast: {1to2}, {1to4}, {1to8}, or {1to16}.  */\n+      unsigned int type;\n+\n+      /* Index of broadcasted operand.  */\n+      unsigned int operand;\n+\n+      /* Number of bytes to broadcast.  */\n+      unsigned int bytes;\n+    } broadcast;\n \n     /* Compressed disp8*N attribute.  */\n     unsigned int memshift;\n@@ -2211,7 +2208,7 @@ match_mem_size (const insn_template *t, unsigned int wanted,\n {\n   return (match_operand_size (t, wanted, given)\n \t  && !((i.types[given].bitfield.unspecified\n-\t\t&& !i.broadcast\n+\t\t&& !i.broadcast.type\n \t\t&& !t->operand_types[wanted].bitfield.unspecified)\n \t       || (i.types[given].bitfield.fword\n \t\t   && !t->operand_types[wanted].bitfield.fword)\n@@ -3911,9 +3908,9 @@ build_evex_prefix (void)\n \t\t    i.tm.opcode_modifier.evex = EVEX128;\n \t\t    break;\n \t\t  }\n-\t\telse if (i.broadcast && op == i.broadcast->operand)\n+\t\telse if (i.broadcast.type && op == i.broadcast.operand)\n \t\t  {\n-\t\t    switch (i.broadcast->bytes)\n+\t\t    switch (i.broadcast.bytes)\n \t\t      {\n \t\t\tcase 64:\n \t\t\t  i.tm.opcode_modifier.evex = EVEX512;\n@@ -3955,7 +3952,7 @@ build_evex_prefix (void)\n \t}\n       i.vex.bytes[3] |= vec_length;\n       /* Encode the broadcast bit.  */\n-      if (i.broadcast)\n+      if (i.broadcast.type)\n \ti.vex.bytes[3] |= 0x10;\n     }\n   else\n@@ -4255,7 +4252,7 @@ optimize_encoding (void)\n \t   && !i.types[0].bitfield.zmmword\n \t   && !i.types[1].bitfield.zmmword\n \t   && !i.mask.reg\n-\t   && !i.broadcast\n+\t   && !i.broadcast.type\n \t   && is_evex_encoding (&i.tm)\n \t   && ((i.tm.base_opcode & ~Opcode_SIMD_IntD) == 0x6f\n \t       || (i.tm.base_opcode & ~4) == 0xdb\n@@ -5472,12 +5469,12 @@ swap_2_operands (unsigned int xchg1, unsigned int xchg2)\n       else if (i.mask.operand == xchg2)\n \ti.mask.operand = xchg1;\n     }\n-  if (i.broadcast)\n+  if (i.broadcast.type)\n     {\n-      if (i.broadcast->operand == xchg1)\n-\ti.broadcast->operand = xchg2;\n-      else if (i.broadcast->operand == xchg2)\n-\ti.broadcast->operand = xchg1;\n+      if (i.broadcast.operand == xchg1)\n+\ti.broadcast.operand = xchg2;\n+      else if (i.broadcast.operand == xchg2)\n+\ti.broadcast.operand = xchg1;\n     }\n   if (i.rounding)\n     {\n@@ -5892,13 +5889,13 @@ check_VecOperands (const insn_template *t)\n \n   /* Check if broadcast is supported by the instruction and is applied\n      to the memory operand.  */\n-  if (i.broadcast)\n+  if (i.broadcast.type)\n     {\n       i386_operand_type type, overlap;\n \n       /* Check if specified broadcast is supported in this instruction,\n \t and its broadcast bytes match the memory operand.  */\n-      op = i.broadcast->operand;\n+      op = i.broadcast.operand;\n       if (!t->opcode_modifier.broadcast\n \t  || !(i.flags[op] & Operand_Mem)\n \t  || (!i.types[op].bitfield.unspecified\n@@ -5909,10 +5906,10 @@ check_VecOperands (const insn_template *t)\n \t  return 1;\n \t}\n \n-      i.broadcast->bytes = ((1 << (t->opcode_modifier.broadcast - 1))\n-\t\t\t    * i.broadcast->type);\n+      i.broadcast.bytes = ((1 << (t->opcode_modifier.broadcast - 1))\n+\t\t\t   * i.broadcast.type);\n       operand_type_set (&type, 0);\n-      switch (i.broadcast->bytes)\n+      switch (i.broadcast.bytes)\n \t{\n \tcase 2:\n \t  type.bitfield.word = 1;\n@@ -6066,7 +6063,7 @@ check_VecOperands (const insn_template *t)\n   if (t->opcode_modifier.disp8memshift\n       && i.disp_encoding != disp_encoding_32bit)\n     {\n-      if (i.broadcast)\n+      if (i.broadcast.type)\n \ti.memshift = t->opcode_modifier.broadcast - 1;\n       else if (t->opcode_modifier.disp8memshift != DISP8_SHIFT_VL)\n \ti.memshift = t->opcode_modifier.disp8memshift;\n@@ -6394,8 +6391,8 @@ match_template (char mnem_suffix)\n       if (t->opcode_modifier.checkregsize)\n \t{\n \t  check_register = (1 << t->operands) - 1;\n-\t  if (i.broadcast)\n-\t    check_register &= ~(1 << i.broadcast->operand);\n+\t  if (i.broadcast.type)\n+\t    check_register &= ~(1 << i.broadcast.operand);\n \t}\n       else\n \tcheck_register = 0;\n@@ -6961,7 +6958,7 @@ process_suffix (void)\n       /* For [XYZ]MMWORD operands inspect operand sizes.  While generally\n \t also suitable for AT&T syntax mode, it was requested that this be\n \t restricted to just Intel syntax.  */\n-      if (intel_syntax && is_any_vex_encoding (&i.tm) && !i.broadcast)\n+      if (intel_syntax && is_any_vex_encoding (&i.tm) && !i.broadcast.type)\n \t{\n \t  unsigned int op;\n \n@@ -10391,9 +10388,9 @@ check_VecOperations (char *op_string, char *op_end)\n \t  /* Check broadcasts.  */\n \t  if (strncmp (op_string, \"1to\", 3) == 0)\n \t    {\n-\t      int bcst_type;\n+\t      unsigned int bcst_type;\n \n-\t      if (i.broadcast)\n+\t      if (i.broadcast.type)\n \t\tgoto duplicated_vec_op;\n \n \t      op_string += 3;\n@@ -10416,10 +10413,8 @@ check_VecOperations (char *op_string, char *op_end)\n \t\t}\n \t      op_string++;\n \n-\t      broadcast_op.type = bcst_type;\n-\t      broadcast_op.operand = this_operand;\n-\t      broadcast_op.bytes = 0;\n-\t      i.broadcast = &broadcast_op;\n+\t      i.broadcast.type = bcst_type;\n+\t      i.broadcast.operand = this_operand;\n \t    }\n \t  /* Check masking operation.  */\n \t  else if ((mask = parse_register (op_string, &end_op)) != NULL)"
    }
  ]
}