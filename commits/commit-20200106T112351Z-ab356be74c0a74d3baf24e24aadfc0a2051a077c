{
  "sha": "ab356be74c0a74d3baf24e24aadfc0a2051a077c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWIzNTZiZTc0YzBhNzRkM2JhZjI0ZTI0YWFkZmMwYTIwNTFhMDc3Yw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-06T07:59:14Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-06T11:23:51Z"
    },
    "message": "alpha-vms: don't exit on stack underflow/overflow\n\nBFD is not supposed to exit or abort on anything the user can do.\n\n\t* vms-alpha.c (_bfd_vms_push, _bfd_vms_pop): Return pass/fail\n\tstatus rather than exiting on stack overflow or underflow.\n\t(_bfd_vms_slurp_etir): Adjust to suit.",
    "tree": {
      "sha": "4b6b5c6a509b51149938408f471fb2bd9e3a875a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4b6b5c6a509b51149938408f471fb2bd9e3a875a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ab356be74c0a74d3baf24e24aadfc0a2051a077c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ab356be74c0a74d3baf24e24aadfc0a2051a077c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ab356be74c0a74d3baf24e24aadfc0a2051a077c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ab356be74c0a74d3baf24e24aadfc0a2051a077c/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cc6aa1a6e0a8f2b3eda496aef0b3579a8c2b5951",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cc6aa1a6e0a8f2b3eda496aef0b3579a8c2b5951",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cc6aa1a6e0a8f2b3eda496aef0b3579a8c2b5951"
    }
  ],
  "stats": {
    "total": 161,
    "additions": 108,
    "deletions": 53
  },
  "files": [
    {
      "sha": "4fc134503688bd879c8f3d9652c6c5da1ef35bd6",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ab356be74c0a74d3baf24e24aadfc0a2051a077c/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ab356be74c0a74d3baf24e24aadfc0a2051a077c/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=ab356be74c0a74d3baf24e24aadfc0a2051a077c",
      "patch": "@@ -1,3 +1,9 @@\n+2020-01-06  Alan Modra  <amodra@gmail.com>\n+\n+\t* vms-alpha.c (_bfd_vms_push, _bfd_vms_pop): Return pass/fail\n+\tstatus rather than exiting on stack overflow or underflow.\n+\t(_bfd_vms_slurp_etir): Adjust to suit.\n+\n 2020-01-06  Alan Modra  <amodra@gmail.com>\n \n \t* som.c (som_bfd_fill_in_ar_symbols): Bounds check som_dict index."
    },
    {
      "sha": "73e728538463e83b08f449a5899def6c4eb0a1b6",
      "filename": "bfd/vms-alpha.c",
      "status": "modified",
      "additions": 102,
      "deletions": 53,
      "changes": 155,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ab356be74c0a74d3baf24e24aadfc0a2051a077c/bfd/vms-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ab356be74c0a74d3baf24e24aadfc0a2051a077c/bfd/vms-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-alpha.c?ref=ab356be74c0a74d3baf24e24aadfc0a2051a077c",
      "patch": "@@ -1456,7 +1456,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \n /* Push value and section index.  */\n \n-static void\n+static bfd_boolean\n _bfd_vms_push (bfd *abfd, bfd_vma val, unsigned int reloc)\n {\n   vms_debug2 ((4, \"<push %08lx (0x%08x) at %d>\\n\",\n@@ -1469,26 +1469,28 @@ _bfd_vms_push (bfd *abfd, bfd_vma val, unsigned int reloc)\n     {\n       bfd_set_error (bfd_error_bad_value);\n       _bfd_error_handler (_(\"stack overflow (%d) in _bfd_vms_push\"), PRIV (stackptr));\n-      exit (1);\n+      return FALSE;\n     }\n+  return TRUE;\n }\n \n /* Pop value and section index.  */\n \n-static void\n+static bfd_boolean\n _bfd_vms_pop (bfd *abfd, bfd_vma *val, unsigned int *rel)\n {\n   if (PRIV (stackptr) == 0)\n     {\n       bfd_set_error (bfd_error_bad_value);\n       _bfd_error_handler (_(\"stack underflow in _bfd_vms_pop\"));\n-      exit (1);\n+      return FALSE;\n     }\n   PRIV (stackptr)--;\n   *val = PRIV (stack[PRIV (stackptr)]).value;\n   *rel = PRIV (stack[PRIV (stackptr)]).reloc;\n \n   vms_debug2 ((4, \"<pop %08lx (0x%08x)>\\n\", (unsigned long)*val, *rel));\n+  return TRUE;\n }\n \n /* Routines to fill sections contents during tir/etir read.  */\n@@ -1905,7 +1907,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t     stack 32 bit value of symbol (high bits set to 0).  */\n \tcase ETIR__C_STA_GBL:\n \t  _bfd_vms_get_value (abfd, ptr, maxptr, info, &op1, &h);\n-\t  _bfd_vms_push (abfd, op1, alpha_vms_sym_to_ctxt (h));\n+\t  if (!_bfd_vms_push (abfd, op1, alpha_vms_sym_to_ctxt (h)))\n+\t    return FALSE;\n \t  break;\n \n \t  /* Stack longword\n@@ -1915,7 +1918,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \tcase ETIR__C_STA_LW:\n \t  if (ptr + 4 > maxptr)\n \t    goto corrupt_etir;\n-\t  _bfd_vms_push (abfd, bfd_getl32 (ptr), RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, bfd_getl32 (ptr), RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \t  /* Stack quadword\n@@ -1925,7 +1929,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \tcase ETIR__C_STA_QW:\n \t  if (ptr + 8 > maxptr)\n \t    goto corrupt_etir;\n-\t  _bfd_vms_push (abfd, bfd_getl64 (ptr), RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, bfd_getl64 (ptr), RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \t  /* Stack psect base plus quadword offset\n@@ -1949,7 +1954,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t\treturn FALSE;\n \t      }\n \t    op1 = bfd_getl64 (ptr + 4);\n-\t    _bfd_vms_push (abfd, op1, psect | RELC_SEC_BASE);\n+\t    if (!_bfd_vms_push (abfd, op1, psect | RELC_SEC_BASE))\n+\t      return FALSE;\n \t  }\n \t  break;\n \n@@ -1964,7 +1970,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Store byte: pop stack, write byte\n \t     arg: -.  */\n \tcase ETIR__C_STO_B:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE)\n \t    goto bad_context;\n \t  image_write_b (abfd, (unsigned int) op1 & 0xff);\n@@ -1973,7 +1980,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Store word: pop stack, write word\n \t     arg: -.  */\n \tcase ETIR__C_STO_W:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE)\n \t    goto bad_context;\n \t  image_write_w (abfd, (unsigned int) op1 & 0xffff);\n@@ -1982,7 +1990,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Store longword: pop stack, write longword\n \t     arg: -.  */\n \tcase ETIR__C_STO_LW:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 & RELC_SEC_BASE)\n \t    {\n \t      op1 = alpha_vms_fix_sec_rel (abfd, info, rel1, op1);\n@@ -2005,7 +2014,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Store quadword: pop stack, write quadword\n \t     arg: -.  */\n \tcase ETIR__C_STO_QW:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 & RELC_SEC_BASE)\n \t    {\n \t      op1 = alpha_vms_fix_sec_rel (abfd, info, rel1, op1);\n@@ -2032,7 +2042,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t    if (ptr + 4 > maxptr)\n \t      goto corrupt_etir;\n \t    size = bfd_getl32 (ptr);\n-\t    _bfd_vms_pop (abfd, &op1, &rel1);\n+\t    if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t      return FALSE;\n \t    if (rel1 != RELC_NONE)\n \t      goto bad_context;\n \t    while (op1-- > 0)\n@@ -2095,7 +2106,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Store offset to psect: pop stack, add low 32 bits to base of psect\n \t     arg: none.  */\n \tcase ETIR__C_STO_OFF:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \n \t  if (!(rel1 & RELC_SEC_BASE))\n \t    abort ();\n@@ -2266,7 +2278,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Det relocation base: pop stack, set image location counter\n \t     arg: none.  */\n \tcase ETIR__C_CTL_SETRB:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (!(rel1 & RELC_SEC_BASE))\n \t    abort ();\n \t  image_set_ptr (abfd, op1, rel1 & RELC_MASK, info);\n@@ -2284,7 +2297,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Define location: pop index, save location counter under index\n \t     arg: none.  */\n \tcase ETIR__C_CTL_DFLOC:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE)\n \t    goto bad_context;\n \t  dst_define_location (abfd, op1);\n@@ -2293,7 +2307,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Set location: pop index, restore location counter from index\n \t     arg: none.  */\n \tcase ETIR__C_CTL_STLOC:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE)\n \t    goto bad_context;\n \t  dst_restore_location (abfd, op1);\n@@ -2302,28 +2317,34 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Stack defined location: pop index, push location counter from index\n \t     arg: none.  */\n \tcase ETIR__C_CTL_STKDL:\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, dst_retrieve_location (abfd, op1), RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, dst_retrieve_location (abfd, op1),\n+\t\t\t      RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_NOP:      /* No-op.  */\n \t  break;\n \n \tcase ETIR__C_OPR_ADD:      /* Add.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n-\t  _bfd_vms_pop (abfd, &op2, &rel2);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t      || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t    return FALSE;\n \t  if (rel1 == RELC_NONE && rel2 != RELC_NONE)\n \t    rel1 = rel2;\n \t  else if (rel1 != RELC_NONE && rel2 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, op1 + op2, rel1);\n+\t  if (!_bfd_vms_push (abfd, op1 + op2, rel1))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_SUB:      /* Subtract.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n-\t  _bfd_vms_pop (abfd, &op2, &rel2);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t      || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t    return FALSE;\n \t  if (rel1 == RELC_NONE && rel2 != RELC_NONE)\n \t    rel1 = rel2;\n \t  else if ((rel1 & RELC_SEC_BASE) && (rel2 & RELC_SEC_BASE))\n@@ -2334,69 +2355,90 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t    }\n \t  else if (rel1 != RELC_NONE && rel2 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, op2 - op1, rel1);\n+\t  if (!_bfd_vms_push (abfd, op2 - op1, rel1))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_MUL:      /* Multiply.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n-\t  _bfd_vms_pop (abfd, &op2, &rel2);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t      || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE || rel2 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, op1 * op2, RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, op1 * op2, RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_DIV:      /* Divide.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n-\t  _bfd_vms_pop (abfd, &op2, &rel2);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t      || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE || rel2 != RELC_NONE)\n \t    goto bad_context;\n \t  if (op2 == 0)\n-\t    _bfd_vms_push (abfd, 0, RELC_NONE);\n+\t    {\n+\t      if (!_bfd_vms_push (abfd, 0, RELC_NONE))\n+\t\treturn FALSE;\n+\t    }\n \t  else\n-\t    _bfd_vms_push (abfd, op2 / op1, RELC_NONE);\n+\t    {\n+\t      if (!_bfd_vms_push (abfd, op2 / op1, RELC_NONE))\n+\t\treturn FALSE;\n+\t    }\n \t  break;\n \n \tcase ETIR__C_OPR_AND:      /* Logical AND.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n-\t  _bfd_vms_pop (abfd, &op2, &rel2);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t      || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE || rel2 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, op1 & op2, RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, op1 & op2, RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_IOR:      /* Logical inclusive OR.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n-\t  _bfd_vms_pop (abfd, &op2, &rel2);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t      || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE || rel2 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, op1 | op2, RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, op1 | op2, RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_EOR:      /* Logical exclusive OR.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n-\t  _bfd_vms_pop (abfd, &op2, &rel2);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t      || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE || rel2 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, op1 ^ op2, RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, op1 ^ op2, RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_NEG:      /* Negate.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, -op1, RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, -op1, RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_COM:      /* Complement.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE)\n \t    goto bad_context;\n-\t  _bfd_vms_push (abfd, ~op1, RELC_NONE);\n+\t  if (!_bfd_vms_push (abfd, ~op1, RELC_NONE))\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_ASH:      /* Arithmetic shift.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n-\t  _bfd_vms_pop (abfd, &op2, &rel2);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t      || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t    return FALSE;\n \t  if (rel1 != RELC_NONE || rel2 != RELC_NONE)\n \t    {\n \t    bad_context:\n@@ -2408,7 +2450,8 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t    op1 >>= -(int)op2;\n \t  else\t\t\t/* Shift left.  */\n \t    op1 <<= (int)op2;\n-\t  _bfd_vms_push (abfd, op1, RELC_NONE); /* FIXME: sym.  */\n+\t  if (!_bfd_vms_push (abfd, op1, RELC_NONE)) /* FIXME: sym.  */\n+\t    return FALSE;\n \t  break;\n \n \tcase ETIR__C_OPR_INSV:      /* Insert field.   */\n@@ -2422,14 +2465,20 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  break;\n \n \tcase ETIR__C_OPR_SEL:      /* Select.  */\n-\t  _bfd_vms_pop (abfd, &op1, &rel1);\n+\t  if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t    return FALSE;\n \t  if (op1 & 0x01L)\n-\t    _bfd_vms_pop (abfd, &op1, &rel1);\n+\t    {\n+\t      if (!_bfd_vms_pop (abfd, &op1, &rel1))\n+\t\treturn FALSE;\n+\t    }\n \t  else\n \t    {\n-\t      _bfd_vms_pop (abfd, &op1, &rel1);\n-\t      _bfd_vms_pop (abfd, &op2, &rel2);\n-\t      _bfd_vms_push (abfd, op1, rel1);\n+\t      if (!_bfd_vms_pop (abfd, &op1, &rel1)\n+\t\t  || !_bfd_vms_pop (abfd, &op2, &rel2))\n+\t\treturn FALSE;\n+\t      if (!_bfd_vms_push (abfd, op1, rel1))\n+\t\treturn FALSE;\n \t    }\n \t  break;\n "
    }
  ]
}