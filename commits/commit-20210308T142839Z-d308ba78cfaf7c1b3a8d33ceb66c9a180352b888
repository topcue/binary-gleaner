{
  "sha": "d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDMwOGJhNzhjZmFmN2MxYjNhOGQzM2NlYjY2YzlhMTgwMzUyYjg4OA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:39Z"
    },
    "message": "Convert f-exp.y to use operations\n\nThis converts the Fortran parser to generate operations rather than\nexp_elements.  A couple of tests of expression debug dumping are\nupdated to follow the new output.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* f-exp.y: Create operations.\n\t(f_language::parser): Update.\n\ngdb/testsuite/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* gdb.fortran/debug-expr.exp: Update tests.",
    "tree": {
      "sha": "9276d701ff32795d68515ca1c4fec1737c2e9c41",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9276d701ff32795d68515ca1c4fec1737c2e9c41"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f1b8ceef1b055a0eb927852e9a9402d21aea96f5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f1b8ceef1b055a0eb927852e9a9402d21aea96f5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f1b8ceef1b055a0eb927852e9a9402d21aea96f5"
    }
  ],
  "stats": {
    "total": 374,
    "additions": 238,
    "deletions": 136
  },
  "files": [
    {
      "sha": "3af105597cf357a476cbb1cb0873c8da4aa2573d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* f-exp.y: Create operations.\n+\t(f_language::parser): Update.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* m2-exp.y: Create operations."
    },
    {
      "sha": "0e56669f0a34c333e194037880f2012cbbaebe57",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 225,
      "deletions": 132,
      "changes": 357,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
      "patch": "@@ -55,6 +55,7 @@\n #include <ctype.h>\n #include <algorithm>\n #include \"type-stack.h\"\n+#include \"f-exp.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n #define parse_f_type(ps) builtin_f_type (ps->gdbarch ())\n@@ -89,6 +90,7 @@ static void push_kind_type (LONGEST val, struct type *type);\n \n static struct type *convert_to_kind_type (struct type *basetype, int kind);\n \n+using namespace expr;\n %}\n \n /* Although the yacc \"value\" of an expression is not used,\n@@ -209,9 +211,7 @@ start   :\texp\n \t;\n \n type_exp:\ttype\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t\t  write_exp_elt_type (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPE); }\n+\t\t\t{ pstate->push_new<type_operation> ($1); }\n \t;\n \n exp     :       '(' exp ')'\n@@ -220,39 +220,65 @@ exp     :       '(' exp ')'\n \n /* Expressions, not including the comma operator.  */\n exp\t:\t'*' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_IND); }\n+\t\t\t{ pstate->wrap<unop_ind_operation> (); }\n \t;\n \n exp\t:\t'&' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ADDR); }\n+\t\t\t{ pstate->wrap<unop_addr_operation> (); }\n \t;\n \n exp\t:\t'-' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_NEG); }\n+\t\t\t{ pstate->wrap<unary_neg_operation> (); }\n \t;\n \n exp\t:\tBOOL_NOT exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT); }\n+\t\t\t{ pstate->wrap<unary_logical_not_operation> (); }\n \t;\n \n exp\t:\t'~' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_COMPLEMENT); }\n+\t\t\t{ pstate->wrap<unary_complement_operation> (); }\n \t;\n \n exp\t:\tSIZEOF exp       %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_SIZEOF); }\n+\t\t\t{ pstate->wrap<unop_sizeof_operation> (); }\n \t;\n \n exp\t:\tKIND '(' exp ')'       %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_FORTRAN_KIND); }\n+\t\t\t{ pstate->wrap<fortran_kind_operation> (); }\n \t;\n \n exp\t:\tUNOP_OR_BINOP_INTRINSIC '('\n \t\t\t{ pstate->start_arglist (); }\n \t\tone_or_two_args ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, $1);\n-\t\t\t  write_exp_elt_longcst (pstate, pstate->end_arglist ());\n-\t\t\t  write_exp_elt_opcode (pstate, $1); }\n+\t\t\t{\n+\t\t\t  int n = pstate->end_arglist ();\n+\t\t\t  gdb_assert (n == 1 || n == 2);\n+\t\t\t  if ($1 == FORTRAN_ASSOCIATED)\n+\t\t\t    {\n+\t\t\t      if (n == 1)\n+\t\t\t\tpstate->wrap<fortran_associated_1arg> ();\n+\t\t\t      else\n+\t\t\t\tpstate->wrap2<fortran_associated_2arg> ();\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      std::vector<operation_up> args\n+\t\t\t\t= pstate->pop_vector (n);\n+\t\t\t      gdb_assert ($1 == FORTRAN_LBOUND\n+\t\t\t\t\t  || $1 == FORTRAN_UBOUND);\n+\t\t\t      operation_up op;\n+\t\t\t      if (n == 1)\n+\t\t\t\top.reset\n+\t\t\t\t  (new fortran_bound_1arg ($1,\n+\t\t\t\t\t\t\t   std::move (args[0])));\n+\t\t\t      else\n+\t\t\t\top.reset\n+\t\t\t\t  (new fortran_bound_2arg ($1,\n+\t\t\t\t\t\t\t   std::move (args[0]),\n+\t\t\t\t\t\t\t   std::move (args[1])));\n+\t\t\t      pstate->push (std::move (op));\n+\t\t\t    }\n+\t\t\t}\n \t;\n \n one_or_two_args\n@@ -270,20 +296,53 @@ one_or_two_args\n exp\t:\texp '(' \n \t\t\t{ pstate->start_arglist (); }\n \t\targlist ')'\t\n-\t\t\t{ write_exp_elt_opcode (pstate,\n-\t\t\t\t\t\tOP_F77_UNDETERMINED_ARGLIST);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t pstate->end_arglist ());\n-\t\t\t  write_exp_elt_opcode (pstate,\n-\t\t\t\t\t      OP_F77_UNDETERMINED_ARGLIST); }\n+\t\t\t{\n+\t\t\t  std::vector<operation_up> args\n+\t\t\t    = pstate->pop_vector (pstate->end_arglist ());\n+\t\t\t  pstate->push_new<fortran_undetermined>\n+\t\t\t    (pstate->pop (), std::move (args));\n+\t\t\t}\n \t;\n \n exp\t:\tUNOP_INTRINSIC '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, $1); }\n+\t\t\t{\n+\t\t\t  switch ($1)\n+\t\t\t    {\n+\t\t\t    case UNOP_ABS:\n+\t\t\t      pstate->wrap<fortran_abs_operation> ();\n+\t\t\t      break;\n+\t\t\t    case UNOP_FORTRAN_FLOOR:\n+\t\t\t      pstate->wrap<fortran_floor_operation> ();\n+\t\t\t      break;\n+\t\t\t    case UNOP_FORTRAN_CEILING:\n+\t\t\t      pstate->wrap<fortran_ceil_operation> ();\n+\t\t\t      break;\n+\t\t\t    case UNOP_FORTRAN_ALLOCATED:\n+\t\t\t      pstate->wrap<fortran_allocated_operation> ();\n+\t\t\t      break;\n+\t\t\t    default:\n+\t\t\t      gdb_assert_not_reached (\"unhandled intrinsic\");\n+\t\t\t    }\n+\t\t\t}\n \t;\n \n exp\t:\tBINOP_INTRINSIC '(' exp ',' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, $1); }\n+\t\t\t{\n+\t\t\t  switch ($1)\n+\t\t\t    {\n+\t\t\t    case BINOP_MOD:\n+\t\t\t      pstate->wrap2<fortran_mod_operation> ();\n+\t\t\t      break;\n+\t\t\t    case BINOP_FORTRAN_MODULO:\n+\t\t\t      pstate->wrap2<fortran_modulo_operation> ();\n+\t\t\t      break;\n+\t\t\t    case BINOP_FORTRAN_CMPLX:\n+\t\t\t      pstate->wrap2<fortran_cmplx_operation> ();\n+\t\t\t      break;\n+\t\t\t    default:\n+\t\t\t      gdb_assert_not_reached (\"unhandled intrinsic\");\n+\t\t\t    }\n+\t\t\t}\n \t;\n \n arglist\t:\n@@ -308,257 +367,288 @@ arglist\t:\targlist ',' subrange   %prec ABOVE_COMMA\n /* There are four sorts of subrange types in F90.  */\n \n subrange:\texp ':' exp\t%prec ABOVE_COMMA\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_RANGE);\n-\t\t\t  write_exp_elt_longcst (pstate, RANGE_STANDARD);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_RANGE); }\n+\t\t\t{\n+\t\t\t  operation_up high = pstate->pop ();\n+\t\t\t  operation_up low = pstate->pop ();\n+\t\t\t  pstate->push_new<fortran_range_operation>\n+\t\t\t    (RANGE_STANDARD, std::move (low),\n+\t\t\t     std::move (high), operation_up ());\n+\t\t\t}\n \t;\n \n subrange:\texp ':'\t%prec ABOVE_COMMA\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_RANGE);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t RANGE_HIGH_BOUND_DEFAULT);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_RANGE); }\n+\t\t\t{\n+\t\t\t  operation_up low = pstate->pop ();\n+\t\t\t  pstate->push_new<fortran_range_operation>\n+\t\t\t    (RANGE_HIGH_BOUND_DEFAULT, std::move (low),\n+\t\t\t     operation_up (), operation_up ());\n+\t\t\t}\n \t;\n \n subrange:\t':' exp\t%prec ABOVE_COMMA\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_RANGE);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t RANGE_LOW_BOUND_DEFAULT);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_RANGE); }\n+\t\t\t{\n+\t\t\t  operation_up high = pstate->pop ();\n+\t\t\t  pstate->push_new<fortran_range_operation>\n+\t\t\t    (RANGE_LOW_BOUND_DEFAULT, operation_up (),\n+\t\t\t     std::move (high), operation_up ());\n+\t\t\t}\n \t;\n \n subrange:\t':'\t%prec ABOVE_COMMA\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_RANGE);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (RANGE_LOW_BOUND_DEFAULT\n-\t\t\t\t\t\t  | RANGE_HIGH_BOUND_DEFAULT));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_RANGE); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<fortran_range_operation>\n+\t\t\t    (RANGE_LOW_BOUND_DEFAULT\n+\t\t\t     | RANGE_HIGH_BOUND_DEFAULT,\n+\t\t\t     operation_up (), operation_up (),\n+\t\t\t     operation_up ());\n+\t\t\t}\n \t;\n \n /* And each of the four subrange types can also have a stride.  */\n subrange:\texp ':' exp ':' exp\t%prec ABOVE_COMMA\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_RANGE);\n-\t\t\t  write_exp_elt_longcst (pstate, RANGE_HAS_STRIDE);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_RANGE); }\n+\t\t\t{\n+\t\t\t  operation_up stride = pstate->pop ();\n+\t\t\t  operation_up high = pstate->pop ();\n+\t\t\t  operation_up low = pstate->pop ();\n+\t\t\t  pstate->push_new<fortran_range_operation>\n+\t\t\t    (RANGE_STANDARD | RANGE_HAS_STRIDE,\n+\t\t\t     std::move (low), std::move (high),\n+\t\t\t     std::move (stride));\n+\t\t\t}\n \t;\n \n subrange:\texp ':' ':' exp\t%prec ABOVE_COMMA\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_RANGE);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (RANGE_HIGH_BOUND_DEFAULT\n-\t\t\t\t\t\t  | RANGE_HAS_STRIDE));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_RANGE); }\n+\t\t\t{\n+\t\t\t  operation_up stride = pstate->pop ();\n+\t\t\t  operation_up low = pstate->pop ();\n+\t\t\t  pstate->push_new<fortran_range_operation>\n+\t\t\t    (RANGE_HIGH_BOUND_DEFAULT\n+\t\t\t     | RANGE_HAS_STRIDE,\n+\t\t\t     std::move (low), operation_up (),\n+\t\t\t     std::move (stride));\n+\t\t\t}\n \t;\n \n subrange:\t':' exp ':' exp\t%prec ABOVE_COMMA\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_RANGE);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (RANGE_LOW_BOUND_DEFAULT\n-\t\t\t\t\t\t  | RANGE_HAS_STRIDE));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_RANGE); }\n+\t\t\t{\n+\t\t\t  operation_up stride = pstate->pop ();\n+\t\t\t  operation_up high = pstate->pop ();\n+\t\t\t  pstate->push_new<fortran_range_operation>\n+\t\t\t    (RANGE_LOW_BOUND_DEFAULT\n+\t\t\t     | RANGE_HAS_STRIDE,\n+\t\t\t     operation_up (), std::move (high),\n+\t\t\t     std::move (stride));\n+\t\t\t}\n \t;\n \n subrange:\t':' ':' exp\t%prec ABOVE_COMMA\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_RANGE);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (RANGE_LOW_BOUND_DEFAULT\n-\t\t\t\t\t\t  | RANGE_HIGH_BOUND_DEFAULT\n-\t\t\t\t\t\t  | RANGE_HAS_STRIDE));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_RANGE); }\n+\t\t\t{\n+\t\t\t  operation_up stride = pstate->pop ();\n+\t\t\t  pstate->push_new<fortran_range_operation>\n+\t\t\t    (RANGE_LOW_BOUND_DEFAULT\n+\t\t\t     | RANGE_HIGH_BOUND_DEFAULT\n+\t\t\t     | RANGE_HAS_STRIDE,\n+\t\t\t     operation_up (), operation_up (),\n+\t\t\t     std::move (stride));\n+\t\t\t}\n \t;\n \n complexnum:     exp ',' exp \n \t\t\t{ }                          \n \t;\n \n exp\t:\t'(' complexnum ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_COMPLEX);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t      parse_f_type (pstate)\n-\t\t\t\t\t      ->builtin_complex_s16);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX); }\n+\t\t\t{\n+\t\t\t  operation_up rhs = pstate->pop ();\n+\t\t\t  operation_up lhs = pstate->pop ();\n+\t\t\t  pstate->push_new<complex_operation>\n+\t\t\t    (std::move (lhs), std::move (rhs),\n+\t\t\t     parse_f_type (pstate)->builtin_complex_s16);\n+\t\t\t}\n \t;\n \n exp\t:\t'(' type ')' exp  %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_CAST);\n-\t\t\t  write_exp_elt_type (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<unop_cast_operation>\n+\t\t\t    (pstate->pop (), $2);\n+\t\t\t}\n \t;\n \n exp     :       exp '%' name\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<structop_operation>\n+\t\t\t    (pstate->pop (), copy_name ($3));\n+\t\t\t}\n \t;\n \n exp     :       exp '%' name COMPLETE\n-\t\t\t{ pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_operation (pstate->pop (),\n+\t\t\t\t\t\t      copy_name ($3));\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp     :       exp '%' COMPLETE\n-\t\t\t{ struct stoken s;\n-\t\t\t  pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t\t  s.ptr = \"\";\n-\t\t\t  s.length = 0;\n-\t\t\t  write_exp_string (pstate, s);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_operation (pstate->pop (), \"\");\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n+\t;\n \n /* Binary operators in order of decreasing precedence.  */\n \n exp\t:\texp '@' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REPEAT); }\n+\t\t\t{ pstate->wrap2<repeat_operation> (); }\n \t;\n \n exp\t:\texp STARSTAR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_EXP); }\n+\t\t\t{ pstate->wrap2<exp_operation> (); }\n \t;\n \n exp\t:\texp '*' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_MUL); }\n+\t\t\t{ pstate->wrap2<mul_operation> (); }\n \t;\n \n exp\t:\texp '/' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_DIV); }\n+\t\t\t{ pstate->wrap2<div_operation> (); }\n \t;\n \n exp\t:\texp '+' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ADD); }\n+\t\t\t{ pstate->wrap2<add_operation> (); }\n \t;\n \n exp\t:\texp '-' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUB); }\n+\t\t\t{ pstate->wrap2<sub_operation> (); }\n \t;\n \n exp\t:\texp LSH exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LSH); }\n+\t\t\t{ pstate->wrap2<lsh_operation> (); }\n \t;\n \n exp\t:\texp RSH exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_RSH); }\n+\t\t\t{ pstate->wrap2<rsh_operation> (); }\n \t;\n \n exp\t:\texp EQUAL exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }\n+\t\t\t{ pstate->wrap2<equal_operation> (); }\n \t;\n \n exp\t:\texp NOTEQUAL exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }\n+\t\t\t{ pstate->wrap2<notequal_operation> (); }\n \t;\n \n exp\t:\texp LEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LEQ); }\n+\t\t\t{ pstate->wrap2<leq_operation> (); }\n \t;\n \n exp\t:\texp GEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GEQ); }\n+\t\t\t{ pstate->wrap2<geq_operation> (); }\n \t;\n \n exp\t:\texp LESSTHAN exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LESS); }\n+\t\t\t{ pstate->wrap2<less_operation> (); }\n \t;\n \n exp\t:\texp GREATERTHAN exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GTR); }\n+\t\t\t{ pstate->wrap2<gtr_operation> (); }\n \t;\n \n exp\t:\texp '&' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_AND); }\n+\t\t\t{ pstate->wrap2<bitwise_and_operation> (); }\n \t;\n \n exp\t:\texp '^' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n+\t\t\t{ pstate->wrap2<bitwise_xor_operation> (); }\n \t;\n \n exp\t:\texp '|' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_IOR); }\n+\t\t\t{ pstate->wrap2<bitwise_ior_operation> (); }\n \t;\n \n exp     :       exp BOOL_AND exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n+\t\t\t{ pstate->wrap2<logical_and_operation> (); }\n \t;\n \n \n exp\t:\texp BOOL_OR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n+\t\t\t{ pstate->wrap2<logical_or_operation> (); }\n \t;\n \n exp\t:\texp '=' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN); }\n+\t\t\t{ pstate->wrap2<assign_operation> (); }\n \t;\n \n exp\t:\texp ASSIGN_MODIFY exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);\n-\t\t\t  write_exp_elt_opcode (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY); }\n+\t\t\t{\n+\t\t\t  operation_up rhs = pstate->pop ();\n+\t\t\t  operation_up lhs = pstate->pop ();\n+\t\t\t  pstate->push_new<assign_modify_operation>\n+\t\t\t    ($2, std::move (lhs), std::move (rhs));\n+\t\t\t}\n \t;\n \n exp\t:\tINT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) ($1.val));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    ($1.type, $1.val);\n+\t\t\t}\n \t;\n \n exp\t:\tNAME_OR_INT\n \t\t\t{ YYSTYPE val;\n \t\t\t  parse_number (pstate, $1.stoken.ptr,\n \t\t\t\t\t$1.stoken.length, 0, &val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, val.typed_val.type);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (LONGEST)val.typed_val.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (val.typed_val.type,\n+\t\t\t     val.typed_val.val);\n+\t\t\t}\n \t;\n \n exp\t:\tFLOAT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_floatcst (pstate, $1.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT); }\n+\t\t\t{\n+\t\t\t  float_data data;\n+\t\t\t  std::copy (std::begin ($1.val), std::end ($1.val),\n+\t\t\t\t     std::begin (data));\n+\t\t\t  pstate->push_new<float_const_operation> ($1.type, data);\n+\t\t\t}\n \t;\n \n exp\t:\tvariable\n \t;\n \n exp\t:\tDOLLAR_VARIABLE\n-\t\t\t{ write_dollar_variable (pstate, $1); }\n+\t\t\t{ pstate->push_dollar ($1); }\n \t;\n \n exp\t:\tSIZEOF '(' type ')'\t%prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t      parse_f_type (pstate)\n-\t\t\t\t\t      ->builtin_integer);\n+\t\t\t{\n \t\t\t  $3 = check_typedef ($3);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (LONGEST) TYPE_LENGTH ($3));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (parse_f_type (pstate)->builtin_integer,\n+\t\t\t     TYPE_LENGTH ($3));\n+\t\t\t}\n \t;\n \n exp     :       BOOLEAN_LITERAL\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t\t}\n+\t\t\t{ pstate->push_new<bool_operation> ($1); }\n \t;\n \n exp\t:\tSTRING_LITERAL\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_STRING);\n-\t\t\t  write_exp_string (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_STRING);\n+\t\t\t  pstate->push_new<string_operation>\n+\t\t\t    (copy_name ($1));\n \t\t\t}\n \t;\n \n variable:\tname_not_typename\n \t\t\t{ struct block_symbol sym = $1.sym;\n \t\t\t  std::string name = copy_name ($1.stoken);\n-\t\t\t  write_exp_symbol_reference (pstate, name.c_str (),\n-\t\t\t\t\t\t      sym);\n+\t\t\t  pstate->push_symbol (name.c_str (), sym);\n \t\t\t}\n \t;\n \n@@ -1436,7 +1526,10 @@ f_language::parser (struct parser_state *par_state) const\n   scoped_restore restore_type_stack = make_scoped_restore (&type_stack,\n \t\t\t\t\t\t\t   &stack);\n \n-  return yyparse ();\n+  int result = yyparse ();\n+  if (!result)\n+    pstate->set_operation (pstate->pop ());\n+  return result;\n }\n \n static void"
    },
    {
      "sha": "5767fa562c640b1281c3f95a749b0c0319a905a0",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
      "patch": "@@ -1,3 +1,7 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* gdb.fortran/debug-expr.exp: Update tests.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* gdb.base/debug-expr.exp: Update expected dump output."
    },
    {
      "sha": "ca1fb9755aad7440247a44ad1c4c4e261f2a8423",
      "filename": "gdb/testsuite/gdb.fortran/debug-expr.exp",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/gdb/testsuite/gdb.fortran/debug-expr.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888/gdb/testsuite/gdb.fortran/debug-expr.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/debug-expr.exp?ref=d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
      "patch": "@@ -42,10 +42,10 @@ gdb_continue_to_breakpoint \"Break Here\"\n gdb_test_no_output \"set debug expression 1\"\n gdb_test_debug_expr \"print obj%three(1)%two(1)%one(1)%i\" \"\\\\\\$$decimal = 1\"\n gdb_test_debug_expr \"print .TRUE.\"  [multi_line \\\n-\t\t\t\t\t \"\" \\\n-\t\t\t\t\t \"\\\\s+0\\\\s+OP_BOOL\\\\s+TRUE\" \\\n+\t\t\t\t\t \"Operation: OP_BOOL\" \\\n+\t\t\t\t\t \" Constant: .*1\" \\\n \t\t\t\t\t \"\\\\\\$$decimal = \\.TRUE\\.\"]\n gdb_test_debug_expr \"print .FALSE.\"  [multi_line \\\n-\t\t\t\t\t  \"\" \\\n-\t\t\t\t\t  \"\\\\s+0\\\\s+OP_BOOL\\\\s+FALSE\" \\\n+\t\t\t\t\t \"Operation: OP_BOOL\" \\\n+\t\t\t\t\t \" Constant: .*0\" \\\n \t\t\t\t\t  \"\\\\\\$$decimal = \\.FALSE\\.\"]"
    }
  ]
}