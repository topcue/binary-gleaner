{
  "sha": "521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTIxZDRiMTk0Zjg5Y2E4ZjdkNWQzY2NlMWVjZGM0ZmM3NTU5MjA1Yw==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-11-09T10:37:51Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-11-09T10:37:51Z"
    },
    "message": "Extend the DWARF decoder to display FORM names when operating in wide mode.\n\n\tPR 26847\n\t* dwarf.c (read_and_display_attr_value): In wide mode, display the\n\tname of the form.",
    "tree": {
      "sha": "95cb3e0e48947daf17f5c153e8a210525fcf8770",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/95cb3e0e48947daf17f5c153e8a210525fcf8770"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a4e91c46306ed0bd24b45f882af0e28c5c8c3634",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a4e91c46306ed0bd24b45f882af0e28c5c8c3634",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a4e91c46306ed0bd24b45f882af0e28c5c8c3634"
    }
  ],
  "stats": {
    "total": 156,
    "additions": 109,
    "deletions": 47
  },
  "files": [
    {
      "sha": "25ba6084e869454b283fcf444fffafcf86173ed8",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c",
      "patch": "@@ -1,3 +1,9 @@\n+2020-11-09  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR 26847\n+\t* dwarf.c (read_and_display_attr_value): In wide mode, display the\n+\tname of the form.\n+\n 2020-11-09  Alan Modra  <amodra@gmail.com>\n \n \t* elfedit (usage): Avoid false positive \"may be used uninitialised\"."
    },
    {
      "sha": "58077447293d02222041802d4d87285c22554c0c",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 103,
      "deletions": 47,
      "changes": 150,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=521d4b194f89ca8f7d5d3cce1ecdc4fc7559205c",
      "patch": "@@ -702,7 +702,7 @@ fetch_indirect_string (dwarf_vma offset)\n     ret = (const unsigned char *)\n       _(\"<no NUL byte at end of .debug_str section>\");\n \n-  return ret; \n+  return ret;\n }\n \n static const unsigned char *\n@@ -795,7 +795,7 @@ fetch_indexed_string (dwarf_vma idx, struct cu_tu_set *this_set,\n     }\n \n   index_offset = idx * offset_size;\n-      \n+\n   if (this_set != NULL)\n     index_offset += this_set->section_offsets [DW_SECT_STR_OFFSETS];\n \n@@ -1859,7 +1859,7 @@ fetch_alt_indirect_string (dwarf_vma offset)\n \n       return ret;\n     }\n-  \n+\n   warn (_(\"DW_FORM_GNU_strp_alt offset (%s) too big or no string sections available\\n\"),\n \tdwarf_vmatoa (\"x\", offset));\n   return _(\"<offset is too big>\");\n@@ -2134,7 +2134,7 @@ get_type_abbrev_from_form (unsigned long                 form,\n \n   data = (unsigned char *) section->start + uvalue;\n   map = find_abbrev_map_by_offset (uvalue);\n-  \n+\n   if (map == NULL)\n     {\n       warn (_(\"Unable to find abbreviations for CU offset %#lx\\n\"), uvalue);\n@@ -2159,7 +2159,7 @@ get_type_abbrev_from_form (unsigned long                 form,\n   for (entry = map->list->first_abbrev; entry != NULL; entry = entry->next)\n     if (entry->number == abbrev_number)\n       break;\n-  \n+\n   if (abbrev_num_return != NULL)\n     * abbrev_num_return = abbrev_number;\n \n@@ -2303,7 +2303,7 @@ display_discr_list (unsigned long          form,\n       printf (\"[default]\");\n       return;\n     }\n-  \n+\n   switch (form)\n     {\n     case DW_FORM_block:\n@@ -2329,7 +2329,7 @@ display_discr_list (unsigned long          form,\n   bfd_boolean is_signed =\n     (level > 0 && level <= MAX_CU_NESTING)\n     ? level_type_signed [level - 1] : FALSE;\n-    \n+\n   printf (\"(\");\n   while (uvalue)\n     {\n@@ -2411,6 +2411,17 @@ read_and_display_attr_value (unsigned long           attribute,\n       return data;\n     }\n \n+  if (do_wide && ! do_loc)\n+    {\n+      /* PR 26847: Display the name of the form.  */\n+      const char * name = get_FORM_name (form);\n+\n+      /* For convenience we skip the DW_FORM_ prefix to the name.  */\n+      if (name[0] == 'D')\n+\tname += 8; /* strlen (\"DW_FORM_\")  */\n+      printf (\"%c(%s)\", delimiter, name);\n+    }\n+\n   switch (form)\n     {\n     default:\n@@ -2492,7 +2503,13 @@ read_and_display_attr_value (unsigned long           attribute,\n \n     case DW_FORM_GNU_ref_alt:\n       if (!do_loc)\n-\tprintf (\"%c<alt 0x%s>\", delimiter, dwarf_vmatoa (\"x\", uvalue));\n+\t{\n+\t  if (do_wide)\n+\t    /* We have already printed the form name.  */\n+\t    printf (\"%c<0x%s>\", delimiter, dwarf_vmatoa (\"x\", uvalue));\n+\t  else\n+\t    printf (\"%c<alt 0x%s>\", delimiter, dwarf_vmatoa (\"x\", uvalue));\n+\t}\n       /* FIXME: Follow the reference...  */\n       break;\n \n@@ -2620,16 +2637,32 @@ read_and_display_attr_value (unsigned long           attribute,\n \n     case DW_FORM_strp:\n       if (!do_loc)\n-\tprintf (_(\"%c(indirect string, offset: 0x%s): %s\"), delimiter,\n-\t\tdwarf_vmatoa (\"x\", uvalue),\n-\t\tfetch_indirect_string (uvalue));\n+\t{\n+\t  if (do_wide)\n+\t    /* We have already displayed the form name.  */\n+\t    printf (_(\"%c(offset: 0x%s): %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_indirect_string (uvalue));\n+\t  else\n+\t    printf (_(\"%c(indirect string, offset: 0x%s): %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_indirect_string (uvalue));\n+\t}\n       break;\n \n     case DW_FORM_line_strp:\n       if (!do_loc)\n-\tprintf (_(\"%c(indirect line string, offset: 0x%s): %s\"), delimiter,\n-\t\tdwarf_vmatoa (\"x\", uvalue),\n-\t\tfetch_indirect_line_string (uvalue));\n+\t{\n+\t  if (do_wide)\n+\t    /* We have already displayed the form name.  */\n+\t    printf (_(\"%c(offset: 0x%s): %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_indirect_line_string (uvalue));\n+\t  else\n+\t    printf (_(\"%c(indirect line string, offset: 0x%s): %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_indirect_line_string (uvalue));\n+\t}\n       break;\n \n     case DW_FORM_GNU_str_index:\n@@ -2638,18 +2671,30 @@ read_and_display_attr_value (unsigned long           attribute,\n \t  const char * suffix = strrchr (section->name, '.');\n \t  bfd_boolean  dwo = (suffix && strcmp (suffix, \".dwo\") == 0) ? TRUE : FALSE;\n \n-\t  printf (_(\"%c(indexed string: 0x%s): %s\"), delimiter,\n-\t\t  dwarf_vmatoa (\"x\", uvalue),\n-\t\t  fetch_indexed_string (uvalue, this_set, offset_size, dwo));\n+\t  if (do_wide)\n+\t    /* We have already displayed the form name.  */\n+\t    printf (_(\"%c(offset: 0x%s): %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_indexed_string (uvalue, this_set, offset_size, dwo));\n+\t  else\n+\t    printf (_(\"%c(indexed string: 0x%s): %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_indexed_string (uvalue, this_set, offset_size, dwo));\n \t}\n       break;\n \n     case DW_FORM_GNU_strp_alt:\n       if (!do_loc)\n \t{\n-\t  printf (_(\"%c(alt indirect string, offset: 0x%s) %s\"), delimiter,\n-\t\t  dwarf_vmatoa (\"x\", uvalue),\n-\t\t  fetch_alt_indirect_string (uvalue));\n+\t  if (do_wide)\n+\t    /* We have already displayed the form name.  */\n+\t    printf (_(\"%c(offset: 0x%s) %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_alt_indirect_string (uvalue));\n+\t  else\n+\t    printf (_(\"%c(alt indirect string, offset: 0x%s) %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_alt_indirect_string (uvalue));\n \t}\n       break;\n \n@@ -2664,17 +2709,30 @@ read_and_display_attr_value (unsigned long           attribute,\n \t  char buf[64];\n \n \t  SAFE_BYTE_GET64 (data, &high_bits, &uvalue, end);\n-\t  printf (\"%csignature: 0x%s\", delimiter,\n-\t\t  dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));\n+\t  if (do_wide)\n+\t    /* We have already displayed the form name.  */\n+\t    printf (\"%c: 0x%s\", delimiter,\n+\t\t    dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));\n+\t  else\n+\t    printf (\"%csignature: 0x%s\", delimiter,\n+\t\t    dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));\n \t}\n       data += 8;\n       break;\n \n     case DW_FORM_GNU_addr_index:\n       if (!do_loc)\n-\tprintf (_(\"%c(addr_index: 0x%s): %s\"), delimiter,\n-\t\tdwarf_vmatoa (\"x\", uvalue),\n-\t\tfetch_indexed_value (uvalue * pointer_size, pointer_size));\n+\t{\n+\t  if (do_wide)\n+\t    /* We have already displayed the form name.  */\n+\t    printf (_(\"%c(index: 0x%s): %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_indexed_value (uvalue * pointer_size, pointer_size));\n+\t  else\n+\t    printf (_(\"%c(addr_index: 0x%s): %s\"), delimiter,\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    fetch_indexed_value (uvalue * pointer_size, pointer_size));\n+\t}\n       break;\n \n     default:\n@@ -2819,7 +2877,7 @@ read_and_display_attr_value (unsigned long           attribute,\n \t\tbreak;\n \t      }\n \t  break;\n-\t      \n+\n \tcase DW_AT_comp_dir:\n \t  /* FIXME: Also extract a build-id in a CU/TU.  */\n \t  if (need_dwo_info)\n@@ -2846,7 +2904,7 @@ read_and_display_attr_value (unsigned long           attribute,\n \t\tbreak;\n \t      }\n \t  break;\n-\t      \n+\n \tcase DW_AT_GNU_dwo_id:\n \t  if (need_dwo_info)\n \t    switch (form)\n@@ -2861,7 +2919,7 @@ read_and_display_attr_value (unsigned long           attribute,\n \t\tbreak;\n \t      }\n \t  break;\n-\t      \n+\n \tdefault:\n \t  break;\n \t}\n@@ -2881,7 +2939,7 @@ read_and_display_attr_value (unsigned long           attribute,\n \t  abbrev_entry *  type_abbrev;\n \t  unsigned char * type_data;\n \t  unsigned long   type_cu_offset;\n-\t  \n+\n \t  type_abbrev = get_type_abbrev_from_form (form, uvalue, cu_offset,\n \t\t\t\t\t\t   section, NULL, & type_data, & type_cu_offset);\n \t  if (type_abbrev != NULL)\n@@ -2893,7 +2951,7 @@ read_and_display_attr_value (unsigned long           attribute,\n \t  level_type_signed[level] = is_signed;\n \t}\n       break;\n-      \n+\n     case DW_AT_inline:\n       printf (\"\\t\");\n       switch (uvalue)\n@@ -3145,7 +3203,7 @@ read_and_display_attr_value (unsigned long           attribute,\n       printf (\"\\t\");\n       display_discr_list (form, uvalue, data, end, level);\n       break;\n-      \n+\n     case DW_AT_frame_base:\n       have_frame_base = 1;\n       /* Fall through.  */\n@@ -3334,7 +3392,7 @@ introduce (struct dwarf_section * section, bfd_boolean raw)\n \tprintf (_(\"Contents of the %s section:\\n\\n\"), section->name);\n     }\n }\n-  \n+\n /* Process the contents of a .debug_info section.\n    If do_loc is TRUE then we are scanning for location lists and dwo tags\n    and we do not want to display anything to the user.\n@@ -3434,7 +3492,7 @@ process_debug_info (struct dwarf_section *           section,\n       load_debug_section_with_follow (str_index_dwo, file);\n       load_debug_section_with_follow (debug_addr, file);\n     }\n-  \n+\n   load_debug_section_with_follow (abbrev_sec, file);\n   if (debug_displays [abbrev_sec].section.start == NULL)\n     {\n@@ -3450,7 +3508,7 @@ process_debug_info (struct dwarf_section *           section,\n   free (cu_abbrev_map);\n   cu_abbrev_map = NULL;\n   next_free_abbrev_map_entry = 0;\n-  \n+\n   /* In order to be able to resolve DW_FORM_ref_attr forms we need\n      to load *all* of the abbrevs for all CUs in this .debug_info\n      section.  This does effectively mean that we (partially) read\n@@ -3532,7 +3590,7 @@ process_debug_info (struct dwarf_section *           section,\n \t     list);\n \t  list->start_of_next_abbrevs = next;\n \t}\n-\t\t       \n+\n       start = section_begin + cu_offset + compunit.cu_length\n \t+ initial_length_size;\n       record_abbrev_list_for_cu (cu_offset, start - section_begin, list);\n@@ -4123,7 +4181,7 @@ display_formatted_table (unsigned char *                   data,\n   dwarf_vma data_count, datai;\n   unsigned int namepass, last_entry = 0;\n   const char * table_name = is_dir ? N_(\"Directory Table\") : N_(\"File Name Table\");\n-  \n+\n   SAFE_BYTE_GET_AND_INC (format_count, data, 1, end);\n   if (do_checks && format_count > 5)\n     warn (_(\"Unexpectedly large number of columns in the %s (%u)\\n\"),\n@@ -4166,7 +4224,7 @@ display_formatted_table (unsigned char *                   data,\n \t  format_count);\n \n   printf (_(\"  Entry\"));\n-  /* Delay displaying name as the last entry for better screen layout.  */ \n+  /* Delay displaying name as the last entry for better screen layout.  */\n   for (namepass = 0; namepass < 2; namepass++)\n     {\n       format = format_start;\n@@ -4207,7 +4265,7 @@ display_formatted_table (unsigned char *                   data,\n       unsigned char *datapass = data;\n \n       printf (\"  %d\", last_entry++);\n-      /* Delay displaying name as the last entry for better screen layout.  */ \n+      /* Delay displaying name as the last entry for better screen layout.  */\n       for (namepass = 0; namepass < 2; namepass++)\n \t{\n \t  format = format_start;\n@@ -7369,7 +7427,6 @@ display_debug_ranges_list (unsigned char *start, unsigned char *finish,\n \tbreak;\n       SAFE_SIGNED_BYTE_GET_AND_INC (end, start, pointer_size, finish);\n \n-      \n       printf (\"    %8.8lx \", offset);\n \n       if (begin == 0 && end == 0)\n@@ -9705,7 +9762,7 @@ display_debug_links (struct dwarf_section *  section,\n     The .gun_debugaltlink section is formatted as:\n       (c-string)  Filename.\n       (binary)    Build-ID.  */\n-  \n+\n   filename =  section->start;\n   filelen = strnlen ((const char *) filename, section->size);\n   if (filelen == section->size)\n@@ -10399,7 +10456,7 @@ load_cu_tu_indexes (void *file)\n   if (cu_tu_indexes_read == -1)\n     {\n       cu_tu_indexes_read = TRUE;\n-  \n+\n       if (load_debug_section_with_follow (dwp_cu_index, file))\n \tif (! process_cu_tu_index (&debug_displays [dwp_cu_index].section, 0))\n \t  cu_tu_indexes_read = FALSE;\n@@ -10643,7 +10700,6 @@ parse_gnu_debuglink (struct dwarf_section * section, void * data)\n      The CRC value is stored after the filename, aligned up to 4 bytes.  */\n   name = (const char *) section->start;\n \n-  \n   crc_offset = strnlen (name, section->size) + 1;\n   crc_offset = (crc_offset + 3) & ~3;\n   if (crc_offset + 4 > section->size)\n@@ -10801,12 +10857,12 @@ load_separate_debug_info (const char *            main_filename,\n \t    xlink->name ? xlink->name : xlink->uncompressed_name);\n       return NULL;\n     }\n-    \n+\n   /* Attempt to locate the separate file.\n      This should duplicate the logic in bfd/opncls.c:find_separate_debug_file().  */\n \n   canon_dir = lrealpath (main_filename);\n-  \n+\n   for (canon_dirlen = strlen (canon_dir); canon_dirlen > 0; canon_dirlen--)\n     if (IS_DIR_SEPARATOR (canon_dir[canon_dirlen - 1]))\n       break;\n@@ -11134,7 +11190,7 @@ load_separate_debug_files (void * file, const char * filename)\n \n   do_follow_links = 0;\n   return FALSE;\n-}  \n+}\n \n void\n free_debug_memory (void)\n@@ -11146,7 +11202,7 @@ free_debug_memory (void)\n   free (cu_abbrev_map);\n   cu_abbrev_map = NULL;\n   next_free_abbrev_map_entry = 0;\n-  \n+\n   for (i = 0; i < max; i++)\n     free_debug_section ((enum dwarf_section_display_enum) i);\n \n@@ -11178,7 +11234,7 @@ free_debug_memory (void)\n       free ((void *) d);\n     }\n   first_separate_info = NULL;\n-  \n+\n   free_dwo_info ();\n }\n "
    }
  ]
}