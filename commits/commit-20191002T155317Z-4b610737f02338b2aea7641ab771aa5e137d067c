{
  "sha": "4b610737f02338b2aea7641ab771aa5e137d067c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGI2MTA3MzdmMDIzMzhiMmFlYTc2NDFhYjc3MWFhNWUxMzdkMDY3Yw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-06-25T18:50:45Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-10-02T15:53:17Z"
    },
    "message": "Handle copy relocations\n\nIn ELF, if a data symbol is defined in a shared library and used by\nthe main program, it will be subject to a \"copy relocation\".  In this\nscenario, the main program has a copy of the symbol in question, and a\nrelocation that tells ld.so to copy the data from the shared library.\nThen the symbol in the main program is used to satisfy all references.\n\nThis patch changes gdb to handle this scenario.  Data symbols coming\nfrom ELF shared libraries get a special flag that indicates that the\nsymbol's address may be subject to copy relocation.\n\nI looked briefly into handling copy relocations by looking at the\nactual relocations in the main program, but this seemed difficult to\ndo with BFD.\n\nNote that no caching is done here.  Perhaps this could be changed if\nneed be; I wanted to avoid possible problems with either objfile\nlifetimes and changes, or conflicts with the long-term (vapor-ware)\nobjfile splitting project.\n\ngdb/ChangeLog\n2019-10-02  Tom Tromey  <tromey@adacore.com>\n\n\t* symmisc.c (dump_msymbols): Don't use MSYMBOL_VALUE_ADDRESS.\n\t* ada-lang.c (lesseq_defined_than): Handle\n\tLOC_STATIC.\n\t* dwarf2read.c (dwarf2_per_objfile): Add can_copy\n\tparameter.\n\t(dwarf2_has_info): Likewise.\n\t(new_symbol): Set maybe_copied on symbol when\n\tappropriate.\n\t* dwarf2read.h (dwarf2_per_objfile): Add can_copy\n\tparameter.\n\t<can_copy>: New member.\n\t* elfread.c (record_minimal_symbol): Set maybe_copied\n\ton symbol when appropriate.\n\t(elf_symfile_read): Update call to dwarf2_has_info.\n\t* minsyms.c (lookup_minimal_symbol_linkage): New\n\tfunction.\n\t* minsyms.h (lookup_minimal_symbol_linkage): Declare.\n\t* symtab.c (get_symbol_address, get_msymbol_address):\n\tNew functions.\n\t* symtab.h (get_symbol_address, get_msymbol_address):\n\tDeclare.\n\t(SYMBOL_VALUE_ADDRESS, MSYMBOL_VALUE_ADDRESS): Handle\n\tmaybe_copied.\n\t(struct symbol, struct minimal_symbol) <maybe_copied>:\n\tNew member.",
    "tree": {
      "sha": "a29d17f55e269ad24027060bb9fb0bdf40cd3b67",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a29d17f55e269ad24027060bb9fb0bdf40cd3b67"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4b610737f02338b2aea7641ab771aa5e137d067c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4b610737f02338b2aea7641ab771aa5e137d067c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4b610737f02338b2aea7641ab771aa5e137d067c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4b610737f02338b2aea7641ab771aa5e137d067c/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1dd588507782591478882a891f64945af9e2b86c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1dd588507782591478882a891f64945af9e2b86c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1dd588507782591478882a891f64945af9e2b86c"
    }
  ],
  "stats": {
    "total": 240,
    "additions": 208,
    "deletions": 32
  },
  "files": [
    {
      "sha": "9bfb7551df2426e714c4d3533eda1b5879c1515e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -1,3 +1,31 @@\n+2019-10-02  Tom Tromey  <tromey@adacore.com>\n+\n+\t* symmisc.c (dump_msymbols): Don't use MSYMBOL_VALUE_ADDRESS.\n+\t* ada-lang.c (lesseq_defined_than): Handle\n+\tLOC_STATIC.\n+\t* dwarf2read.c (dwarf2_per_objfile): Add can_copy\n+\tparameter.\n+\t(dwarf2_has_info): Likewise.\n+\t(new_symbol): Set maybe_copied on symbol when\n+\tappropriate.\n+\t* dwarf2read.h (dwarf2_per_objfile): Add can_copy\n+\tparameter.\n+\t<can_copy>: New member.\n+\t* elfread.c (record_minimal_symbol): Set maybe_copied\n+\ton symbol when appropriate.\n+\t(elf_symfile_read): Update call to dwarf2_has_info.\n+\t* minsyms.c (lookup_minimal_symbol_linkage): New\n+\tfunction.\n+\t* minsyms.h (lookup_minimal_symbol_linkage): Declare.\n+\t* symtab.c (get_symbol_address, get_msymbol_address):\n+\tNew functions.\n+\t* symtab.h (get_symbol_address, get_msymbol_address):\n+\tDeclare.\n+\t(SYMBOL_VALUE_ADDRESS, MSYMBOL_VALUE_ADDRESS): Handle\n+\tmaybe_copied.\n+\t(struct symbol, struct minimal_symbol) <maybe_copied>:\n+\tNew member.\n+\n 2019-10-02  Tom Tromey  <tromey@adacore.com>\n \n \t* source.c (struct current_source_location): New."
    },
    {
      "sha": "f7f972a9bc961f6bb9a8c5cfda52d1e8e5e1c5e1",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -4724,6 +4724,15 @@ lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)\n     case LOC_CONST:\n       return SYMBOL_VALUE (sym0) == SYMBOL_VALUE (sym1)\n         && equiv_types (SYMBOL_TYPE (sym0), SYMBOL_TYPE (sym1));\n+\n+    case LOC_STATIC:\n+      {\n+        const char *name0 = SYMBOL_LINKAGE_NAME (sym0);\n+        const char *name1 = SYMBOL_LINKAGE_NAME (sym1);\n+        return (strcmp (name0, name1) == 0\n+                && SYMBOL_VALUE_ADDRESS (sym0) == SYMBOL_VALUE_ADDRESS (sym1));\n+      }\n+\n     default:\n       return 0;\n     }"
    },
    {
      "sha": "feac40ff95c17609f80dfceb1ca3c2b539811e1f",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 26,
      "deletions": 18,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -2138,8 +2138,10 @@ attr_value_as_address (struct attribute *attr)\n /* See declaration.  */\n \n dwarf2_per_objfile::dwarf2_per_objfile (struct objfile *objfile_,\n-\t\t\t\t\tconst dwarf2_debug_sections *names)\n-  : objfile (objfile_)\n+\t\t\t\t\tconst dwarf2_debug_sections *names,\n+\t\t\t\t\tbool can_copy_)\n+  : objfile (objfile_),\n+    can_copy (can_copy_)\n {\n   if (names == NULL)\n     names = &dwarf2_elf_names;\n@@ -2214,11 +2216,14 @@ class free_cached_comp_units\n /* Try to locate the sections we need for DWARF 2 debugging\n    information and return true if we have enough to do something.\n    NAMES points to the dwarf2 section names, or is NULL if the standard\n-   ELF names are used.  */\n+   ELF names are used.  CAN_COPY is true for formats where symbol\n+   interposition is possible and so symbol values must follow copy\n+   relocation rules.  */\n \n int\n dwarf2_has_info (struct objfile *objfile,\n-                 const struct dwarf2_debug_sections *names)\n+                 const struct dwarf2_debug_sections *names,\n+\t\t bool can_copy)\n {\n   if (objfile->flags & OBJF_READNEVER)\n     return 0;\n@@ -2228,7 +2233,8 @@ dwarf2_has_info (struct objfile *objfile,\n \n   if (dwarf2_per_objfile == NULL)\n     dwarf2_per_objfile = dwarf2_objfile_data_key.emplace (objfile, objfile,\n-\t\t\t\t\t\t\t  names);\n+\t\t\t\t\t\t\t  names,\n+\t\t\t\t\t\t\t  can_copy);\n \n   return (!dwarf2_per_objfile->info.is_virtual\n \t  && dwarf2_per_objfile->info.s.section != NULL\n@@ -21715,19 +21721,21 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t}\n \t      else if (attr2 && (DW_UNSND (attr2) != 0))\n \t\t{\n-\t\t  /* Workaround gfortran PR debug/40040 - it uses\n-\t\t     DW_AT_location for variables in -fPIC libraries which may\n-\t\t     get overriden by other libraries/executable and get\n-\t\t     a different address.  Resolve it by the minimal symbol\n-\t\t     which may come from inferior's executable using copy\n-\t\t     relocation.  Make this workaround only for gfortran as for\n-\t\t     other compilers GDB cannot guess the minimal symbol\n-\t\t     Fortran mangling kind.  */\n-\t\t  if (cu->language == language_fortran && die->parent\n-\t\t      && die->parent->tag == DW_TAG_module\n-\t\t      && cu->producer\n-\t\t      && startswith (cu->producer, \"GNU Fortran\"))\n-\t\t    SYMBOL_ACLASS_INDEX (sym) = LOC_UNRESOLVED;\n+\t\t  if (SYMBOL_CLASS (sym) == LOC_STATIC\n+\t\t      && (objfile->flags & OBJF_MAINLINE) == 0\n+\t\t      && dwarf2_per_objfile->can_copy)\n+\t\t    {\n+\t\t      /* A global static variable might be subject to\n+\t\t\t copy relocation.  We first check for a local\n+\t\t\t minsym, though, because maybe the symbol was\n+\t\t\t marked hidden, in which case this would not\n+\t\t\t apply.  */\n+\t\t      bound_minimal_symbol found\n+\t\t\t= (lookup_minimal_symbol_linkage\n+\t\t\t   (SYMBOL_LINKAGE_NAME (sym), objfile));\n+\t\t      if (found.minsym != nullptr)\n+\t\t\tsym->maybe_copied = 1;\n+\t\t    }\n \n \t\t  /* A variable with DW_AT_external is never static,\n \t\t     but it may be block-scoped.  */"
    },
    {
      "sha": "a737168b62953fc3c899d2c69cd55d85bd872015",
      "filename": "gdb/dwarf2read.h",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/dwarf2read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/dwarf2read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.h?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -106,9 +106,12 @@ struct dwarf2_per_objfile\n {\n   /* Construct a dwarf2_per_objfile for OBJFILE.  NAMES points to the\n      dwarf2 section names, or is NULL if the standard ELF names are\n-     used.  */\n+     used.  CAN_COPY is true for formats where symbol\n+     interposition is possible and so symbol values must follow copy\n+     relocation rules.  */\n   dwarf2_per_objfile (struct objfile *objfile,\n-\t\t      const dwarf2_debug_sections *names);\n+\t\t      const dwarf2_debug_sections *names,\n+\t\t      bool can_copy);\n \n   ~dwarf2_per_objfile ();\n \n@@ -208,6 +211,9 @@ struct dwarf2_per_objfile\n      original data was compressed using 'dwz -m'.  */\n   std::unique_ptr<struct dwz_file> dwz_file;\n \n+  /* Whether copy relocations are supported by this object format.  */\n+  bool can_copy;\n+\n   /* A flag indicating whether this objfile has a section loaded at a\n      VMA of 0.  */\n   bool has_section_at_zero = false;"
    },
    {
      "sha": "d2a7bcf8aa6130caa89dae074ddda85bd5f92fd1",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -203,10 +203,16 @@ record_minimal_symbol (minimal_symbol_reader &reader,\n       || ms_type == mst_text_gnu_ifunc)\n     address = gdbarch_addr_bits_remove (gdbarch, address);\n \n-  return reader.record_full (name, name_len, copy_name, address,\n-\t\t\t     ms_type,\n-\t\t\t     gdb_bfd_section_index (objfile->obfd,\n-\t\t\t\t\t\t    bfd_section));\n+  struct minimal_symbol *result\n+    = reader.record_full (name, name_len, copy_name, address,\n+\t\t\t  ms_type,\n+\t\t\t  gdb_bfd_section_index (objfile->obfd,\n+\t\t\t\t\t\t bfd_section));\n+  if ((objfile->flags & OBJF_MAINLINE) == 0\n+      && (ms_type == mst_data || ms_type == mst_bss))\n+    result->maybe_copied = 1;\n+\n+  return result;\n }\n \n /* Read the symbol table of an ELF file.\n@@ -1239,7 +1245,7 @@ elf_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n \t\t\t\tbfd_section_size (str_sect));\n     }\n \n-  if (dwarf2_has_info (objfile, NULL))\n+  if (dwarf2_has_info (objfile, NULL, true))\n     {\n       dw_index_kind index_kind;\n "
    },
    {
      "sha": "c41e5c3200121d167051cf8a2e75dd9dc1a8c1dd",
      "filename": "gdb/minsyms.c",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/minsyms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/minsyms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minsyms.c?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -519,6 +519,29 @@ iterate_over_minimal_symbols\n \n /* See minsyms.h.  */\n \n+bound_minimal_symbol\n+lookup_minimal_symbol_linkage (const char *name, struct objfile *objf)\n+{\n+  unsigned int hash = msymbol_hash (name) % MINIMAL_SYMBOL_HASH_SIZE;\n+\n+  for (objfile *objfile : objf->separate_debug_objfiles ())\n+    {\n+      for (minimal_symbol *msymbol = objfile->per_bfd->msymbol_hash[hash];\n+\t   msymbol != NULL;\n+\t   msymbol = msymbol->hash_next)\n+\t{\n+\t  if (strcmp (MSYMBOL_LINKAGE_NAME (msymbol), name) == 0\n+\t      && (MSYMBOL_TYPE (msymbol) == mst_data\n+\t\t  || MSYMBOL_TYPE (msymbol) == mst_bss))\n+\t    return {msymbol, objfile};\n+\t}\n+    }\n+\n+  return {};\n+}\n+\n+/* See minsyms.h.  */\n+\n struct bound_minimal_symbol\n lookup_minimal_symbol_text (const char *name, struct objfile *objf)\n {"
    },
    {
      "sha": "0a19f0b096231ea055d5537c6c75fa41d843d6fc",
      "filename": "gdb/minsyms.h",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/minsyms.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/minsyms.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minsyms.h?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -205,6 +205,17 @@ struct bound_minimal_symbol lookup_bound_minimal_symbol (const char *);\n struct bound_minimal_symbol lookup_minimal_symbol_text (const char *,\n \t\t\t\t\t\t\tstruct objfile *);\n \n+/* Look through the minimal symbols in OBJF (and its separate debug\n+   objfiles) for a global (not file-local) minsym whose linkage name\n+   is NAME.  This is somewhat similar to lookup_minimal_symbol_text,\n+   only data symbols (not text symbols) are considered, and a non-NULL\n+   objfile is not accepted.  Returns a bound minimal symbol that\n+   matches, or an \"empty\" bound minimal symbol otherwise.  */\n+\n+extern struct bound_minimal_symbol lookup_minimal_symbol_linkage\n+  (const char *name, struct objfile *objf)\n+  ATTRIBUTE_NONNULL (1) ATTRIBUTE_NONNULL (2);\n+\n /* Look through all the current minimal symbol tables and find the\n    first minimal symbol that matches NAME and PC.  If OBJF is non-NULL,\n    limit the search to that objfile.  Returns a pointer to the minimal"
    },
    {
      "sha": "cb5bed9d85c455d72bff9cb203ad9a90690ce2c2",
      "filename": "gdb/symfile.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/symfile.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/symfile.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.h?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -585,7 +585,8 @@ struct dwarf2_debug_sections {\n };\n \n extern int dwarf2_has_info (struct objfile *,\n-                            const struct dwarf2_debug_sections *);\n+                            const struct dwarf2_debug_sections *,\n+\t\t\t    bool = false);\n \n /* Dwarf2 sections that can be accessed by dwarf2_get_section_info.  */\n enum dwarf2_section_enum {"
    },
    {
      "sha": "c91ad5e5f455502886b6bf19b0b1395f3274b25a",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -236,9 +236,13 @@ dump_msymbols (struct objfile *objfile, struct ui_file *outfile)\n \t  break;\n \t}\n       fprintf_filtered (outfile, \"[%2d] %c \", index, ms_type);\n-      fputs_filtered (paddress (gdbarch, MSYMBOL_VALUE_ADDRESS (objfile,\n-\t\t\t\t\t\t\t\tmsymbol)),\n-\t\t      outfile);\n+\n+      /* Use the relocated address as shown in the symbol here -- do\n+\t not try to respect copy relocations.  */\n+      CORE_ADDR addr = (msymbol->value.address\n+\t\t\t+ ANOFFSET (objfile->section_offsets,\n+\t\t\t\t    msymbol->section));\n+      fputs_filtered (paddress (gdbarch, addr), outfile);\n       fprintf_filtered (outfile, \" %s\", MSYMBOL_LINKAGE_NAME (msymbol));\n       if (section)\n \t{"
    },
    {
      "sha": "8a551f1575a31579b030e6ac927bf6eb78e99346",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -6261,6 +6261,50 @@ symbol_set_symtab (struct symbol *symbol, struct symtab *symtab)\n   symbol->owner.symtab = symtab;\n }\n \n+/* See symtab.h.  */\n+\n+CORE_ADDR\n+get_symbol_address (const struct symbol *sym)\n+{\n+  gdb_assert (sym->maybe_copied);\n+  gdb_assert (SYMBOL_CLASS (sym) == LOC_STATIC);\n+\n+  const char *linkage_name = SYMBOL_LINKAGE_NAME (sym);\n+\n+  for (objfile *objfile : current_program_space->objfiles ())\n+    {\n+      bound_minimal_symbol minsym\n+\t= lookup_minimal_symbol_linkage (linkage_name, objfile);\n+      if (minsym.minsym != nullptr)\n+\treturn BMSYMBOL_VALUE_ADDRESS (minsym);\n+    }\n+  return sym->ginfo.value.address;\n+}\n+\n+/* See symtab.h.  */\n+\n+CORE_ADDR\n+get_msymbol_address (struct objfile *objf, const struct minimal_symbol *minsym)\n+{\n+  gdb_assert (minsym->maybe_copied);\n+  gdb_assert ((objf->flags & OBJF_MAINLINE) == 0);\n+\n+  const char *linkage_name = MSYMBOL_LINKAGE_NAME (minsym);\n+\n+  for (objfile *objfile : current_program_space->objfiles ())\n+    {\n+      if ((objfile->flags & OBJF_MAINLINE) != 0)\n+\t{\n+\t  bound_minimal_symbol found\n+\t    = lookup_minimal_symbol_linkage (linkage_name, objfile);\n+\t  if (found.minsym != nullptr)\n+\t    return BMSYMBOL_VALUE_ADDRESS (found);\n+\t}\n+    }\n+  return (minsym->value.address\n+\t  + ANOFFSET (objf->section_offsets, minsym->section));\n+}\n+\n \f\n \n void"
    },
    {
      "sha": "dc65409dd24cd8ae561525fd1d72a8f82b3ecdd1",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 39,
      "deletions": 3,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4b610737f02338b2aea7641ab771aa5e137d067c/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=4b610737f02338b2aea7641ab771aa5e137d067c",
      "patch": "@@ -454,6 +454,14 @@ extern const char *symbol_get_demangled_name\n \n extern CORE_ADDR symbol_overlayed_address (CORE_ADDR, struct obj_section *);\n \n+/* Return the address of SYM.  The MAYBE_COPIED flag must be set on\n+   SYM.  If SYM appears in the main program's minimal symbols, then\n+   that minsym's address is returned; otherwise, SYM's address is\n+   returned.  This should generally only be used via the\n+   SYMBOL_VALUE_ADDRESS macro.  */\n+\n+extern CORE_ADDR get_symbol_address (const struct symbol *sym);\n+\n /* Note that all the following SYMBOL_* macros are used with the\n    SYMBOL argument being either a partial symbol or\n    a full symbol.  Both types have a ginfo field.  In particular\n@@ -463,7 +471,9 @@ extern CORE_ADDR symbol_overlayed_address (CORE_ADDR, struct obj_section *);\n    field only, instead of the SYMBOL parameter.  */\n \n #define SYMBOL_VALUE(symbol)\t\t(symbol)->ginfo.value.ivalue\n-#define SYMBOL_VALUE_ADDRESS(symbol)\t((symbol)->ginfo.value.address + 0)\n+#define SYMBOL_VALUE_ADDRESS(symbol)\t\t\t      \\\n+  (((symbol)->maybe_copied) ? get_symbol_address (symbol)     \\\n+   : ((symbol)->ginfo.value.address))\n #define SET_SYMBOL_VALUE_ADDRESS(symbol, new_value)\t\\\n   ((symbol)->ginfo.value.address = (new_value))\n #define SYMBOL_VALUE_BYTES(symbol)\t(symbol)->ginfo.value.bytes\n@@ -671,6 +681,14 @@ struct minimal_symbol : public general_symbol_info\n      the object file format may not carry that piece of information.  */\n   unsigned int has_size : 1;\n \n+  /* For data symbols only, if this is set, then the symbol might be\n+     subject to copy relocation.  In this case, a minimal symbol\n+     matching the symbol's linkage name is first looked for in the\n+     main objfile.  If found, then that address is used; otherwise the\n+     address in this symbol is used.  */\n+\n+  unsigned maybe_copied : 1;\n+\n   /* Minimal symbols with the same hash key are kept on a linked\n      list.  This is the link.  */\n \n@@ -690,6 +708,15 @@ struct minimal_symbol : public general_symbol_info\n   bool text_p () const;\n };\n \n+/* Return the address of MINSYM, which comes from OBJF.  The\n+   MAYBE_COPIED flag must be set on MINSYM.  If MINSYM appears in the\n+   main program's minimal symbols, then that minsym's address is\n+   returned; otherwise, MINSYM's address is returned.  This should\n+   generally only be used via the MSYMBOL_VALUE_ADDRESS macro.  */\n+\n+extern CORE_ADDR get_msymbol_address (struct objfile *objf,\n+\t\t\t\t      const struct minimal_symbol *minsym);\n+\n #define MSYMBOL_TARGET_FLAG_1(msymbol)  (msymbol)->target_flag_1\n #define MSYMBOL_TARGET_FLAG_2(msymbol)  (msymbol)->target_flag_2\n #define MSYMBOL_SIZE(msymbol)\t\t((msymbol)->size + 0)\n@@ -708,8 +735,9 @@ struct minimal_symbol : public general_symbol_info\n /* The relocated address of the minimal symbol, using the section\n    offsets from OBJFILE.  */\n #define MSYMBOL_VALUE_ADDRESS(objfile, symbol)\t\t\t\t\\\n-  ((symbol)->value.address\t\t\t\t\t\\\n-   + ANOFFSET ((objfile)->section_offsets, ((symbol)->section)))\n+  (((symbol)->maybe_copied) ? get_msymbol_address (objfile, symbol)\t\\\n+   : ((symbol)->value.address\t\t\t\t\t\t\\\n+      + ANOFFSET ((objfile)->section_offsets, ((symbol)->section))))\n /* For a bound minsym, we can easily compute the address directly.  */\n #define BMSYMBOL_VALUE_ADDRESS(symbol) \\\n   MSYMBOL_VALUE_ADDRESS ((symbol).objfile, (symbol).minsym)\n@@ -1112,6 +1140,14 @@ struct symbol\n   /* Whether this is an inlined function (class LOC_BLOCK only).  */\n   unsigned is_inlined : 1;\n \n+  /* For LOC_STATIC only, if this is set, then the symbol might be\n+     subject to copy relocation.  In this case, a minimal symbol\n+     matching the symbol's linkage name is first looked for in the\n+     main objfile.  If found, then that address is used; otherwise the\n+     address in this symbol is used.  */\n+\n+  unsigned maybe_copied : 1;\n+\n   /* The concrete type of this symbol.  */\n \n   ENUM_BITFIELD (symbol_subclass_kind) subclass : 2;"
    }
  ]
}