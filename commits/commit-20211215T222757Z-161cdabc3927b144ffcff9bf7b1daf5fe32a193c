{
  "sha": "161cdabc3927b144ffcff9bf7b1daf5fe32a193c",
  "node_id": "C_kwDOANOeidoAKDE2MWNkYWJjMzkyN2IxNDRmZmNmZjliZjdiMWRhZjVmZTMyYTE5M2M",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-12-15T04:36:26Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-12-15T22:27:57Z"
    },
    "message": "PR28691, validate dwarf attribute form\n\nPR28691 is a fuzzing PR that triggers a non-problem of \"output changes\nper run\" with PIEs and/or different compilers.  I've closed similar\nPRs before as wontfix, but I guess there will be no end of this type\nof PR.  The trigger is an attribute that usually takes one of the\noffset/constant reference DW_FORMs being given an indexed string\nDW_FORM.  The bfd reader doesn't support indexed strings and returns\nan error string instead.  The address of the string varies with PIE\nruns and/or compiler, and we allow that address to appear in output.\nFix this by validating integer attribute forms, as we do for string\nform attributes.\n\n\tPR 28691\n\t* dwarf2.c (is_str_attr): Rename to..\n\t(is_str_form): ..this.  Change param type.  Update calls.\n\t(is_int_form): New function.\n\t(read_attribute_value): Handle DW_FORM_addrx2.\n\t(find_abstract_instance): Validate form when using attr.u.val.\n\t(scan_unit_for_symbols, parse_comp_unit): Likewise.",
    "tree": {
      "sha": "dbcaf1c769b02d45f1b1974aa6f6252d4c6c4bfd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/dbcaf1c769b02d45f1b1974aa6f6252d4c6c4bfd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/161cdabc3927b144ffcff9bf7b1daf5fe32a193c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/161cdabc3927b144ffcff9bf7b1daf5fe32a193c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/161cdabc3927b144ffcff9bf7b1daf5fe32a193c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/161cdabc3927b144ffcff9bf7b1daf5fe32a193c/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "261b07488b9dfe69090e6980f6de9d0f4f3f03ca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/261b07488b9dfe69090e6980f6de9d0f4f3f03ca",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/261b07488b9dfe69090e6980f6de9d0f4f3f03ca"
    }
  ],
  "stats": {
    "total": 184,
    "additions": 128,
    "deletions": 56
  },
  "files": [
    {
      "sha": "3e49e302179a25a267814a6a74b48110dfce03cd",
      "filename": "bfd/dwarf2.c",
      "status": "modified",
      "additions": 128,
      "deletions": 56,
      "changes": 184,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/161cdabc3927b144ffcff9bf7b1daf5fe32a193c/bfd/dwarf2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/161cdabc3927b144ffcff9bf7b1daf5fe32a193c/bfd/dwarf2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf2.c?ref=161cdabc3927b144ffcff9bf7b1daf5fe32a193c",
      "patch": "@@ -1158,18 +1158,63 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,\n \n /* Returns true if the form is one which has a string value.  */\n \n-static inline bool\n-is_str_attr (enum dwarf_form form)\n+static bool\n+is_str_form (const struct attribute *attr)\n {\n-  return (form == DW_FORM_string\n-\t  || form == DW_FORM_strp\n-\t  || form == DW_FORM_strx\n-\t  || form == DW_FORM_strx1\n-\t  || form == DW_FORM_strx2\n-\t  || form == DW_FORM_strx3\n-\t  || form == DW_FORM_strx4\n-\t  || form == DW_FORM_line_strp\n-\t  || form == DW_FORM_GNU_strp_alt);\n+  switch (attr->form)\n+    {\n+    case DW_FORM_string:\n+    case DW_FORM_strp:\n+    case DW_FORM_strx:\n+    case DW_FORM_strx1:\n+    case DW_FORM_strx2:\n+    case DW_FORM_strx3:\n+    case DW_FORM_strx4:\n+    case DW_FORM_line_strp:\n+    case DW_FORM_GNU_strp_alt:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Returns true if the form is one which has an integer value.  */\n+\n+static bool\n+is_int_form (const struct attribute *attr)\n+{\n+  switch (attr->form)\n+    {\n+    case DW_FORM_addr:\n+    case DW_FORM_data2:\n+    case DW_FORM_data4:\n+    case DW_FORM_data8:\n+    case DW_FORM_data1:\n+    case DW_FORM_flag:\n+    case DW_FORM_sdata:\n+    case DW_FORM_udata:\n+    case DW_FORM_ref_addr:\n+    case DW_FORM_ref1:\n+    case DW_FORM_ref2:\n+    case DW_FORM_ref4:\n+    case DW_FORM_ref8:\n+    case DW_FORM_ref_udata:\n+    case DW_FORM_sec_offset:\n+    case DW_FORM_flag_present:\n+    case DW_FORM_ref_sig8:\n+    case DW_FORM_addrx:\n+    case DW_FORM_implicit_const:\n+    case DW_FORM_addrx1:\n+    case DW_FORM_addrx2:\n+    case DW_FORM_addrx3:\n+    case DW_FORM_addrx4:\n+    case DW_FORM_GNU_ref_alt:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n }\n \n static const char *\n@@ -1250,6 +1295,7 @@ read_attribute_value (struct attribute *  attr,\n       attr->u.val = read_1_byte (abfd, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_data2:\n+    case DW_FORM_addrx2:\n     case DW_FORM_ref2:\n       attr->u.val = read_2_bytes (abfd, &info_ptr, info_ptr_end);\n       break;\n@@ -3037,24 +3083,25 @@ find_abstract_instance (struct comp_unit *unit,\n \t\tcase DW_AT_name:\n \t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n \t\t     over DW_AT_name.  */\n-\t\t  if (name == NULL && is_str_attr (attr.form))\n+\t\t  if (name == NULL && is_str_form (&attr))\n \t\t    {\n \t\t      name = attr.u.str;\n \t\t      if (non_mangled (unit->lang))\n \t\t\t*is_linkage = true;\n \t\t    }\n \t\t  break;\n \t\tcase DW_AT_specification:\n-\t\t  if (!find_abstract_instance (unit, &attr, recur_count + 1,\n-\t\t\t\t\t       &name, is_linkage,\n-\t\t\t\t\t       filename_ptr, linenumber_ptr))\n+\t\t  if (is_int_form (&attr)\n+\t\t      && !find_abstract_instance (unit, &attr, recur_count + 1,\n+\t\t\t\t\t\t  &name, is_linkage,\n+\t\t\t\t\t\t  filename_ptr, linenumber_ptr))\n \t\t    return false;\n \t\t  break;\n \t\tcase DW_AT_linkage_name:\n \t\tcase DW_AT_MIPS_linkage_name:\n \t\t  /* PR 16949:  Corrupt debug info can place\n \t\t     non-string forms into these attributes.  */\n-\t\t  if (is_str_attr (attr.form))\n+\t\t  if (is_str_form (&attr))\n \t\t    {\n \t\t      name = attr.u.str;\n \t\t      *is_linkage = true;\n@@ -3063,11 +3110,13 @@ find_abstract_instance (struct comp_unit *unit,\n \t\tcase DW_AT_decl_file:\n \t\t  if (!comp_unit_maybe_decode_line_info (unit))\n \t\t    return false;\n-\t\t  *filename_ptr = concat_filename (unit->line_table,\n-\t\t\t\t\t\t   attr.u.val);\n+\t\t  if (is_int_form (&attr))\n+\t\t    *filename_ptr = concat_filename (unit->line_table,\n+\t\t\t\t\t\t     attr.u.val);\n \t\t  break;\n \t\tcase DW_AT_decl_line:\n-\t\t  *linenumber_ptr = attr.u.val;\n+\t\t  if (is_int_form (&attr))\n+\t\t    *linenumber_ptr = attr.u.val;\n \t\t  break;\n \t\tdefault:\n \t\t  break;\n@@ -3452,28 +3501,31 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t      switch (attr.name)\n \t\t{\n \t\tcase DW_AT_call_file:\n-\t\t  func->caller_file = concat_filename (unit->line_table,\n-\t\t\t\t\t\t       attr.u.val);\n+\t\t  if (is_int_form (&attr))\n+\t\t    func->caller_file = concat_filename (unit->line_table,\n+\t\t\t\t\t\t\t attr.u.val);\n \t\t  break;\n \n \t\tcase DW_AT_call_line:\n-\t\t  func->caller_line = attr.u.val;\n+\t\t  if (is_int_form (&attr))\n+\t\t    func->caller_line = attr.u.val;\n \t\t  break;\n \n \t\tcase DW_AT_abstract_origin:\n \t\tcase DW_AT_specification:\n-\t\t  if (!find_abstract_instance (unit, &attr, 0,\n-\t\t\t\t\t       &func->name,\n-\t\t\t\t\t       &func->is_linkage,\n-\t\t\t\t\t       &func->file,\n-\t\t\t\t\t       &func->line))\n+\t\t  if (is_int_form (&attr)\n+\t\t      && !find_abstract_instance (unit, &attr, 0,\n+\t\t\t\t\t\t  &func->name,\n+\t\t\t\t\t\t  &func->is_linkage,\n+\t\t\t\t\t\t  &func->file,\n+\t\t\t\t\t\t  &func->line))\n \t\t    goto fail;\n \t\t  break;\n \n \t\tcase DW_AT_name:\n \t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n \t\t     over DW_AT_name.  */\n-\t\t  if (func->name == NULL && is_str_attr (attr.form))\n+\t\t  if (func->name == NULL && is_str_form (&attr))\n \t\t    {\n \t\t      func->name = attr.u.str;\n \t\t      if (non_mangled (unit->lang))\n@@ -3485,34 +3537,41 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t\tcase DW_AT_MIPS_linkage_name:\n \t\t  /* PR 16949:  Corrupt debug info can place\n \t\t     non-string forms into these attributes.  */\n-\t\t  if (is_str_attr (attr.form))\n+\t\t  if (is_str_form (&attr))\n \t\t    {\n \t\t      func->name = attr.u.str;\n \t\t      func->is_linkage = true;\n \t\t    }\n \t\t  break;\n \n \t\tcase DW_AT_low_pc:\n-\t\t  low_pc = attr.u.val;\n+\t\t  if (is_int_form (&attr))\n+\t\t    low_pc = attr.u.val;\n \t\t  break;\n \n \t\tcase DW_AT_high_pc:\n-\t\t  high_pc = attr.u.val;\n-\t\t  high_pc_relative = attr.form != DW_FORM_addr;\n+\t\t  if (is_int_form (&attr))\n+\t\t    {\n+\t\t      high_pc = attr.u.val;\n+\t\t      high_pc_relative = attr.form != DW_FORM_addr;\n+\t\t    }\n \t\t  break;\n \n \t\tcase DW_AT_ranges:\n-\t\t  if (!read_rangelist (unit, &func->arange, attr.u.val))\n+\t\t  if (is_int_form (&attr)\n+\t\t      && !read_rangelist (unit, &func->arange, attr.u.val))\n \t\t    goto fail;\n \t\t  break;\n \n \t\tcase DW_AT_decl_file:\n-\t\t  func->file = concat_filename (unit->line_table,\n-\t\t\t\t\t\tattr.u.val);\n+\t\t  if (is_int_form (&attr))\n+\t\t    func->file = concat_filename (unit->line_table,\n+\t\t\t\t\t\t  attr.u.val);\n \t\t  break;\n \n \t\tcase DW_AT_decl_line:\n-\t\t  func->line = attr.u.val;\n+\t\t  if (is_int_form (&attr))\n+\t\t    func->line = attr.u.val;\n \t\t  break;\n \n \t\tdefault:\n@@ -3524,7 +3583,7 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t      switch (attr.name)\n \t\t{\n \t\tcase DW_AT_specification:\n-\t\t  if (attr.u.val)\n+\t\t  if (is_int_form (&attr) && attr.u.val)\n \t\t    {\n \t\t      struct varinfo * spec_var;\n \n@@ -3551,21 +3610,23 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \t\t  break;\n \n \t\tcase DW_AT_name:\n-\t\t  if (is_str_attr (attr.form))\n+\t\t  if (is_str_form (&attr))\n \t\t    var->name = attr.u.str;\n \t\t  break;\n \n \t\tcase DW_AT_decl_file:\n-\t\t  var->file = concat_filename (unit->line_table,\n-\t\t\t\t\t       attr.u.val);\n+\t\t  if (is_int_form (&attr))\n+\t\t    var->file = concat_filename (unit->line_table,\n+\t\t\t\t\t\t attr.u.val);\n \t\t  break;\n \n \t\tcase DW_AT_decl_line:\n-\t\t  var->line = attr.u.val;\n+\t\t  if (is_int_form (&attr))\n+\t\t    var->line = attr.u.val;\n \t\t  break;\n \n \t\tcase DW_AT_external:\n-\t\t  if (attr.u.val != 0)\n+\t\t  if (is_int_form (&attr) && attr.u.val != 0)\n \t\t    var->stack = false;\n \t\t  break;\n \n@@ -3775,31 +3836,41 @@ parse_comp_unit (struct dwarf2_debug *stash,\n       switch (attr.name)\n \t{\n \tcase DW_AT_stmt_list:\n-\t  unit->stmtlist = 1;\n-\t  unit->line_offset = attr.u.val;\n+\t  if (is_int_form (&attr))\n+\t    {\n+\t      unit->stmtlist = 1;\n+\t      unit->line_offset = attr.u.val;\n+\t    }\n \t  break;\n \n \tcase DW_AT_name:\n-\t  if (is_str_attr (attr.form))\n+\t  if (is_str_form (&attr))\n \t    unit->name = attr.u.str;\n \t  break;\n \n \tcase DW_AT_low_pc:\n-\t  low_pc = attr.u.val;\n-\t  /* If the compilation unit DIE has a DW_AT_low_pc attribute,\n-\t     this is the base address to use when reading location\n-\t     lists or range lists.  */\n-\t  if (abbrev->tag == DW_TAG_compile_unit)\n-\t    unit->base_address = low_pc;\n+\t  if (is_int_form (&attr))\n+\t    {\n+\t      low_pc = attr.u.val;\n+\t      /* If the compilation unit DIE has a DW_AT_low_pc attribute,\n+\t\t this is the base address to use when reading location\n+\t\t lists or range lists.  */\n+\t      if (abbrev->tag == DW_TAG_compile_unit)\n+\t\tunit->base_address = low_pc;\n+\t    }\n \t  break;\n \n \tcase DW_AT_high_pc:\n-\t  high_pc = attr.u.val;\n-\t  high_pc_relative = attr.form != DW_FORM_addr;\n+\t  if (is_int_form (&attr))\n+\t    {\n+\t      high_pc = attr.u.val;\n+\t      high_pc_relative = attr.form != DW_FORM_addr;\n+\t    }\n \t  break;\n \n \tcase DW_AT_ranges:\n-\t  if (!read_rangelist (unit, &unit->arange, attr.u.val))\n+\t  if (is_int_form (&attr)\n+\t      && !read_rangelist (unit, &unit->arange, attr.u.val))\n \t    return NULL;\n \t  break;\n \n@@ -3808,7 +3879,7 @@ parse_comp_unit (struct dwarf2_debug *stash,\n \t    char *comp_dir = attr.u.str;\n \n \t    /* PR 17512: file: 1fe726be.  */\n-\t    if (! is_str_attr (attr.form))\n+\t    if (!is_str_form (&attr))\n \t      {\n \t\t_bfd_error_handler\n \t\t  (_(\"DWARF error: DW_AT_comp_dir attribute encountered with a non-string form\"));\n@@ -3829,7 +3900,8 @@ parse_comp_unit (struct dwarf2_debug *stash,\n \t  }\n \n \tcase DW_AT_language:\n-\t  unit->lang = attr.u.val;\n+\t  if (is_int_form (&attr))\n+\t    unit->lang = attr.u.val;\n \t  break;\n \n \tdefault:"
    }
  ]
}