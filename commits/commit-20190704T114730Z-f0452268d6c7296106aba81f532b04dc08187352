{
  "sha": "f0452268d6c7296106aba81f532b04dc08187352",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjA0NTIyNjhkNmM3Mjk2MTA2YWJhODFmNTMyYjA0ZGMwODE4NzM1Mg==",
  "commit": {
    "author": {
      "name": "Alan Hayward",
      "email": "alan.hayward@arm.com",
      "date": "2019-06-26T09:12:13Z"
    },
    "committer": {
      "name": "Alan Hayward",
      "email": "alan.hayward@arm.com",
      "date": "2019-07-04T11:47:30Z"
    },
    "message": "Arm: Prefix register sizes with ARM_\n\nAdd ARM_ to the front of INT_REGISTER_SIZE, FP_REGISTER_SIZE and\nARM_VFP_REGISTER_SIZE to make it obvious they are for the Arm target.\nMove the defines to arch/arm.h\n\nNo functionality changes.\n\ngdb/ChangeLog:\n\n\t* arch/arm-get-next-pcs.c (thumb_get_next_pcs_raw): Use ARM_\n\tdefines.\n\t* arch/arm-linux.c (arm_linux_sigreturn_next_pc_offset): Likewise.\n\t* arch/arm.h (INT_REGISTER_SIZE) Rename from...\n\t(ARM_INT_REGISTER_SIZE): ...to this.\n\t(ARM_FP_REGISTER_SIZE) (ARM_VFP_REGISTER_SIZE): Add define.\n\t* arm-linux-tdep.c (ARM_LINUX_JB_ELEMENT_SIZE)\n\t(ARM_LINUX_SIZEOF_GREGSET, arm_linux_supply_gregset)\n\t(arm_linux_collect_gregset, supply_nwfpe_register)\n\t(collect_nwfpe_register, arm_linux_collect_nwfpe): Use ARM_\n\tdefines.\n\t* arm-linux-tdep.h (ARM_LINUX_SIZEOF_NWFPE, NWFPE_FPSR_OFFSET)\n\t(NWFPE_FPCR_OFFSET, NWFPE_TAGS_OFFSET): Likewise\n\t* arm-nbsd-tdep.c (ARM_NBSD_JB_ELEMENT_SIZE): Likewise.\n\t* arm-tdep.c (arm_push_dummy_call, arm_extract_return_value)\n\t(arm_return_in_memory, arm_store_return_value)\n\t(arm_get_longjmp_target, arm_register_g_packet_guesses)\n\t(arm_record_ld_st_multiple): Likewise.\n\t* arm-tdep.h (FP_REGISTER_SIZE, VFP_REGISTER_SIZE): Remove.\n\t* arm-wince-tdep.c (ARM_WINCE_JB_ELEMENT_SIZE): Use ARM_ defines.",
    "tree": {
      "sha": "26fda2648b02d0f3a90f5c74760c10ec3a415b83",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/26fda2648b02d0f3a90f5c74760c10ec3a415b83"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f0452268d6c7296106aba81f532b04dc08187352",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f0452268d6c7296106aba81f532b04dc08187352",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f0452268d6c7296106aba81f532b04dc08187352",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f0452268d6c7296106aba81f532b04dc08187352/comments",
  "author": {
    "login": "a74nh",
    "id": 4146708,
    "node_id": "MDQ6VXNlcjQxNDY3MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/a74nh",
    "html_url": "https://github.com/a74nh",
    "followers_url": "https://api.github.com/users/a74nh/followers",
    "following_url": "https://api.github.com/users/a74nh/following{/other_user}",
    "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions",
    "organizations_url": "https://api.github.com/users/a74nh/orgs",
    "repos_url": "https://api.github.com/users/a74nh/repos",
    "events_url": "https://api.github.com/users/a74nh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/a74nh/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "a74nh",
    "id": 4146708,
    "node_id": "MDQ6VXNlcjQxNDY3MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/a74nh",
    "html_url": "https://github.com/a74nh",
    "followers_url": "https://api.github.com/users/a74nh/followers",
    "following_url": "https://api.github.com/users/a74nh/following{/other_user}",
    "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions",
    "organizations_url": "https://api.github.com/users/a74nh/orgs",
    "repos_url": "https://api.github.com/users/a74nh/repos",
    "events_url": "https://api.github.com/users/a74nh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/a74nh/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e935475cb6bcd8146717896e88824ae93a0897c7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e935475cb6bcd8146717896e88824ae93a0897c7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e935475cb6bcd8146717896e88824ae93a0897c7"
    }
  ],
  "stats": {
    "total": 210,
    "additions": 117,
    "deletions": 93
  },
  "files": [
    {
      "sha": "d0523fbd2bcd288607b0581e09fa6815dd0355bf",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -1,3 +1,26 @@\n+2019-07-04  Alan Hayward  <alan.hayward@arm.com>\n+\n+        * arch/arm-get-next-pcs.c (thumb_get_next_pcs_raw): Use ARM_\n+        defines.\n+        * arch/arm-linux.c (arm_linux_sigreturn_next_pc_offset): Likewise.\n+        * arch/arm.h (INT_REGISTER_SIZE) Rename from...\n+        (ARM_INT_REGISTER_SIZE): ...to this.\n+        (ARM_FP_REGISTER_SIZE) (ARM_VFP_REGISTER_SIZE): Add define.\n+        * arm-linux-tdep.c (ARM_LINUX_JB_ELEMENT_SIZE)\n+        (ARM_LINUX_SIZEOF_GREGSET, arm_linux_supply_gregset)\n+        (arm_linux_collect_gregset, supply_nwfpe_register)\n+        (collect_nwfpe_register, arm_linux_collect_nwfpe): Use ARM_\n+        defines.\n+        * arm-linux-tdep.h (ARM_LINUX_SIZEOF_NWFPE, NWFPE_FPSR_OFFSET)\n+        (NWFPE_FPCR_OFFSET, NWFPE_TAGS_OFFSET): Likewise\n+        * arm-nbsd-tdep.c (ARM_NBSD_JB_ELEMENT_SIZE): Likewise.\n+        * arm-tdep.c (arm_push_dummy_call, arm_extract_return_value)\n+        (arm_return_in_memory, arm_store_return_value)\n+        (arm_get_longjmp_target, arm_register_g_packet_guesses)\n+        (arm_record_ld_st_multiple): Likewise.\n+        * arm-tdep.h (FP_REGISTER_SIZE, VFP_REGISTER_SIZE): Remove.\n+        * arm-wince-tdep.c (ARM_WINCE_JB_ELEMENT_SIZE): Use ARM_ defines.\n+\n 2019-07-04  Alan Hayward  <alan.hayward@arm.com>\n \n \t* aarch64-linux-tdep.c (aarch64_linux_init_abi): Use"
    },
    {
      "sha": "00c7064d8b7fae201fbf3b1d49642308904bfe36",
      "filename": "gdb/arch/arm-get-next-pcs.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arch/arm-get-next-pcs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arch/arm-get-next-pcs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/arm-get-next-pcs.c?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -408,7 +408,8 @@ thumb_get_next_pcs_raw (struct arm_get_next_pcs *self)\n \n       /* Fetch the saved PC from the stack.  It's stored above\n          all of the other registers.  */\n-      unsigned long offset = bitcount (bits (inst1, 0, 7)) * INT_REGISTER_SIZE;\n+      unsigned long offset = bitcount (bits (inst1, 0, 7))\n+\t\t\t     * ARM_INT_REGISTER_SIZE;\n       sp = regcache_raw_get_unsigned (regcache, ARM_SP_REGNUM);\n       nextpc = self->ops->read_mem_uint (sp + offset, 4, byte_order);\n     }"
    },
    {
      "sha": "180228fe8978c3a40e81e243da47030491e31d3d",
      "filename": "gdb/arch/arm-linux.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arch/arm-linux.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arch/arm-linux.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/arm-linux.c?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -53,7 +53,7 @@ arm_linux_sigreturn_next_pc_offset (unsigned long sp,\n       r0_offset += ARM_UCONTEXT_SIGCONTEXT + ARM_SIGCONTEXT_R0;\n     }\n \n-  pc_offset = r0_offset + INT_REGISTER_SIZE * ARM_PC_REGNUM;\n+  pc_offset = r0_offset + ARM_INT_REGISTER_SIZE * ARM_PC_REGNUM;\n \n   return pc_offset;\n }"
    },
    {
      "sha": "0ebbf89a9c2b57d3f5362f68ba353c3d2c1562ca",
      "filename": "gdb/arch/arm.h",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arch/arm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arch/arm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/arm.h?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -93,8 +93,12 @@ enum arm_breakpoint_kinds\n \n #define XPSR_T\t\t0x01000000\n \n-/* Size of integer registers.  */\n-#define INT_REGISTER_SIZE\t\t4\n+/* Size of registers.  */\n+\n+#define ARM_INT_REGISTER_SIZE\t\t4\n+/* IEEE extended doubles are 80 bits.  DWORD aligned they use 96 bits.  */\n+#define ARM_FP_REGISTER_SIZE\t\t12\n+#define ARM_VFP_REGISTER_SIZE\t\t8\n \n /* Addresses for calling Thumb functions have the bit 0 set.\n    Here are some macros to test, set, or clear bit 0 of addresses.  */"
    },
    {
      "sha": "d846749e0b8a23e72af40226e748f746ab129379",
      "filename": "gdb/arm-linux-tdep.c",
      "status": "modified",
      "additions": 21,
      "deletions": 20,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-linux-tdep.c?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -103,7 +103,7 @@ static const gdb_byte arm_linux_thumb2_le_breakpoint[] = { 0xf0, 0xf7, 0x00, 0xa\n    SoftVFP or VFP (which implies EABI) then the PC is at offset 9 in the \n    buffer.  This is also true for the SoftFPA model.  However, for the FPA \n    model the PC is at offset 21 in the buffer.  */\n-#define ARM_LINUX_JB_ELEMENT_SIZE\tINT_REGISTER_SIZE\n+#define ARM_LINUX_JB_ELEMENT_SIZE\tARM_INT_REGISTER_SIZE\n #define ARM_LINUX_JB_PC_FPA\t\t21\n #define ARM_LINUX_JB_PC_EABI\t\t9\n \n@@ -471,7 +471,7 @@ static struct tramp_frame arm_kernel_linux_restart_syscall_tramp_frame = {\n \n /* Core file and register set support.  */\n \n-#define ARM_LINUX_SIZEOF_GREGSET (18 * INT_REGISTER_SIZE)\n+#define ARM_LINUX_SIZEOF_GREGSET (18 * ARM_INT_REGISTER_SIZE)\n \n void\n arm_linux_supply_gregset (const struct regset *regset,\n@@ -483,29 +483,30 @@ arm_linux_supply_gregset (const struct regset *regset,\n   const gdb_byte *gregs = (const gdb_byte *) gregs_buf;\n   int regno;\n   CORE_ADDR reg_pc;\n-  gdb_byte pc_buf[INT_REGISTER_SIZE];\n+  gdb_byte pc_buf[ARM_INT_REGISTER_SIZE];\n \n   for (regno = ARM_A1_REGNUM; regno < ARM_PC_REGNUM; regno++)\n     if (regnum == -1 || regnum == regno)\n-      regcache->raw_supply (regno, gregs + INT_REGISTER_SIZE * regno);\n+      regcache->raw_supply (regno, gregs + ARM_INT_REGISTER_SIZE * regno);\n \n   if (regnum == ARM_PS_REGNUM || regnum == -1)\n     {\n       if (arm_apcs_32)\n \tregcache->raw_supply (ARM_PS_REGNUM,\n-\t\t\t      gregs + INT_REGISTER_SIZE * ARM_CPSR_GREGNUM);\n+\t\t\t      gregs + ARM_INT_REGISTER_SIZE * ARM_CPSR_GREGNUM);\n       else\n \tregcache->raw_supply (ARM_PS_REGNUM,\n-\t\t\t     gregs + INT_REGISTER_SIZE * ARM_PC_REGNUM);\n+\t\t\t     gregs + ARM_INT_REGISTER_SIZE * ARM_PC_REGNUM);\n     }\n \n   if (regnum == ARM_PC_REGNUM || regnum == -1)\n     {\n-      reg_pc = extract_unsigned_integer (gregs\n-\t\t\t\t\t + INT_REGISTER_SIZE * ARM_PC_REGNUM,\n-\t\t\t\t\t INT_REGISTER_SIZE, byte_order);\n+      reg_pc = extract_unsigned_integer (\n+\t\t gregs + ARM_INT_REGISTER_SIZE * ARM_PC_REGNUM,\n+\t\t ARM_INT_REGISTER_SIZE, byte_order);\n       reg_pc = gdbarch_addr_bits_remove (gdbarch, reg_pc);\n-      store_unsigned_integer (pc_buf, INT_REGISTER_SIZE, byte_order, reg_pc);\n+      store_unsigned_integer (pc_buf, ARM_INT_REGISTER_SIZE, byte_order,\n+\t\t\t      reg_pc);\n       regcache->raw_supply (ARM_PC_REGNUM, pc_buf);\n     }\n }\n@@ -521,21 +522,21 @@ arm_linux_collect_gregset (const struct regset *regset,\n   for (regno = ARM_A1_REGNUM; regno < ARM_PC_REGNUM; regno++)\n     if (regnum == -1 || regnum == regno)\n       regcache->raw_collect (regno,\n-\t\t\t    gregs + INT_REGISTER_SIZE * regno);\n+\t\t\t    gregs + ARM_INT_REGISTER_SIZE * regno);\n \n   if (regnum == ARM_PS_REGNUM || regnum == -1)\n     {\n       if (arm_apcs_32)\n \tregcache->raw_collect (ARM_PS_REGNUM,\n-\t\t\t      gregs + INT_REGISTER_SIZE * ARM_CPSR_GREGNUM);\n+\t\t\t      gregs + ARM_INT_REGISTER_SIZE * ARM_CPSR_GREGNUM);\n       else\n \tregcache->raw_collect (ARM_PS_REGNUM,\n-\t\t\t      gregs + INT_REGISTER_SIZE * ARM_PC_REGNUM);\n+\t\t\t      gregs + ARM_INT_REGISTER_SIZE * ARM_PC_REGNUM);\n     }\n \n   if (regnum == ARM_PC_REGNUM || regnum == -1)\n     regcache->raw_collect (ARM_PC_REGNUM,\n-\t\t\t   gregs + INT_REGISTER_SIZE * ARM_PC_REGNUM);\n+\t\t\t   gregs + ARM_INT_REGISTER_SIZE * ARM_PC_REGNUM);\n }\n \n /* Support for register format used by the NWFPE FPA emulator.  */\n@@ -551,11 +552,11 @@ supply_nwfpe_register (struct regcache *regcache, int regno,\n {\n   const gdb_byte *reg_data;\n   gdb_byte reg_tag;\n-  gdb_byte buf[FP_REGISTER_SIZE];\n+  gdb_byte buf[ARM_FP_REGISTER_SIZE];\n \n-  reg_data = regs + (regno - ARM_F0_REGNUM) * FP_REGISTER_SIZE;\n+  reg_data = regs + (regno - ARM_F0_REGNUM) * ARM_FP_REGISTER_SIZE;\n   reg_tag = regs[(regno - ARM_F0_REGNUM) + NWFPE_TAGS_OFFSET];\n-  memset (buf, 0, FP_REGISTER_SIZE);\n+  memset (buf, 0, ARM_FP_REGISTER_SIZE);\n \n   switch (reg_tag)\n     {\n@@ -586,7 +587,7 @@ collect_nwfpe_register (const struct regcache *regcache, int regno,\n {\n   gdb_byte *reg_data;\n   gdb_byte reg_tag;\n-  gdb_byte buf[FP_REGISTER_SIZE];\n+  gdb_byte buf[ARM_FP_REGISTER_SIZE];\n \n   regcache->raw_collect (regno, buf);\n \n@@ -595,7 +596,7 @@ collect_nwfpe_register (const struct regcache *regcache, int regno,\n      from the native file to the target file.  But this doesn't\n      always make sense.  */\n \n-  reg_data = regs + (regno - ARM_F0_REGNUM) * FP_REGISTER_SIZE;\n+  reg_data = regs + (regno - ARM_F0_REGNUM) * ARM_FP_REGISTER_SIZE;\n   reg_tag = regs[(regno - ARM_F0_REGNUM) + NWFPE_TAGS_OFFSET];\n \n   switch (reg_tag)\n@@ -648,7 +649,7 @@ arm_linux_collect_nwfpe (const struct regset *regset,\n \n   if (regnum == ARM_FPS_REGNUM || regnum == -1)\n     regcache->raw_collect (ARM_FPS_REGNUM,\n-\t\t\t   regs + INT_REGISTER_SIZE * ARM_FPS_REGNUM);\n+\t\t\t   regs + ARM_INT_REGISTER_SIZE * ARM_FPS_REGNUM);\n }\n \n /* Support VFP register format.  */"
    },
    {
      "sha": "a17bf4e3e44cbafd51b57ad61c434f0212a67e05",
      "filename": "gdb/arm-linux-tdep.h",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-linux-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-linux-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-linux-tdep.h?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -23,9 +23,9 @@\n struct regset;\n struct regcache;\n \n-#define ARM_LINUX_SIZEOF_NWFPE (8 * FP_REGISTER_SIZE \\\n-\t\t\t\t+ 2 * INT_REGISTER_SIZE \\\n-\t\t\t\t+ 8 + INT_REGISTER_SIZE)\n+#define ARM_LINUX_SIZEOF_NWFPE (8 * ARM_FP_REGISTER_SIZE \\\n+\t\t\t\t+ 2 * ARM_INT_REGISTER_SIZE \\\n+\t\t\t\t+ 8 + ARM_INT_REGISTER_SIZE)\n \n /* Support for register format used by the NWFPE FPA emulator.  Each\n    register takes three words, where either the first one, two, or\n@@ -35,9 +35,9 @@ struct regcache;\n    final word flag which indicates whether NWFPE has been\n    initialized.  */\n \n-#define NWFPE_FPSR_OFFSET (8 * FP_REGISTER_SIZE)\n-#define NWFPE_FPCR_OFFSET (NWFPE_FPSR_OFFSET + INT_REGISTER_SIZE)\n-#define NWFPE_TAGS_OFFSET (NWFPE_FPCR_OFFSET + INT_REGISTER_SIZE)\n+#define NWFPE_FPSR_OFFSET (8 * ARM_FP_REGISTER_SIZE)\n+#define NWFPE_FPCR_OFFSET (NWFPE_FPSR_OFFSET + ARM_INT_REGISTER_SIZE)\n+#define NWFPE_TAGS_OFFSET (NWFPE_FPCR_OFFSET + ARM_INT_REGISTER_SIZE)\n #define NWFPE_INITFLAG_OFFSET (NWFPE_TAGS_OFFSET + 8)\n \n void arm_linux_supply_gregset (const struct regset *regset,"
    },
    {
      "sha": "804d02aa9aadfd24bf1e02939af63fb9cd8e0352",
      "filename": "gdb/arm-nbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-nbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-nbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-nbsd-tdep.c?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -26,7 +26,7 @@\n \n /* Description of the longjmp buffer.  */\n #define ARM_NBSD_JB_PC 24\n-#define ARM_NBSD_JB_ELEMENT_SIZE INT_REGISTER_SIZE\n+#define ARM_NBSD_JB_ELEMENT_SIZE ARM_INT_REGISTER_SIZE\n \n /* For compatibility with previous implemenations of GDB on arm/NetBSD,\n    override the default little-endian breakpoint.  */"
    },
    {
      "sha": "4f2d07350f93586727dcf3f5b838340d76b780e6",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 56,
      "deletions": 52,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -3694,18 +3694,19 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n       align = type_align (arg_type);\n       /* Round alignment up to a whole number of words.  */\n-      align = (align + INT_REGISTER_SIZE - 1) & ~(INT_REGISTER_SIZE - 1);\n+      align = (align + ARM_INT_REGISTER_SIZE - 1)\n+\t\t& ~(ARM_INT_REGISTER_SIZE - 1);\n       /* Different ABIs have different maximum alignments.  */\n       if (gdbarch_tdep (gdbarch)->arm_abi == ARM_ABI_APCS)\n \t{\n \t  /* The APCS ABI only requires word alignment.  */\n-\t  align = INT_REGISTER_SIZE;\n+\t  align = ARM_INT_REGISTER_SIZE;\n \t}\n       else\n \t{\n \t  /* The AAPCS requires at most doubleword alignment.  */\n-\t  if (align > INT_REGISTER_SIZE * 2)\n-\t    align = INT_REGISTER_SIZE * 2;\n+\t  if (align > ARM_INT_REGISTER_SIZE * 2)\n+\t    align = ARM_INT_REGISTER_SIZE * 2;\n \t}\n \n       if (use_vfp_abi\n@@ -3770,14 +3771,14 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       /* Push stack padding for dowubleword alignment.  */\n       if (nstack & (align - 1))\n \t{\n-\t  si = push_stack_item (si, val, INT_REGISTER_SIZE);\n-\t  nstack += INT_REGISTER_SIZE;\n+\t  si = push_stack_item (si, val, ARM_INT_REGISTER_SIZE);\n+\t  nstack += ARM_INT_REGISTER_SIZE;\n \t}\n       \n       /* Doubleword aligned quantities must go in even register pairs.  */\n       if (may_use_core_reg\n \t  && argreg <= ARM_LAST_ARG_REGNUM\n-\t  && align > INT_REGISTER_SIZE\n+\t  && align > ARM_INT_REGISTER_SIZE\n \t  && argreg & 1)\n \targreg++;\n \n@@ -3803,7 +3804,8 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t registers and stack.  */\n       while (len > 0)\n \t{\n-\t  int partial_len = len < INT_REGISTER_SIZE ? len : INT_REGISTER_SIZE;\n+\t  int partial_len = len < ARM_INT_REGISTER_SIZE\n+\t\t\t    ? len : ARM_INT_REGISTER_SIZE;\n \t  CORE_ADDR regval\n \t    = extract_unsigned_integer (val, partial_len, byte_order);\n \n@@ -3812,19 +3814,19 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      /* The argument is being passed in a general purpose\n \t\t register.  */\n \t      if (byte_order == BFD_ENDIAN_BIG)\n-\t\tregval <<= (INT_REGISTER_SIZE - partial_len) * 8;\n+\t\tregval <<= (ARM_INT_REGISTER_SIZE - partial_len) * 8;\n \t      if (arm_debug)\n \t\tfprintf_unfiltered (gdb_stdlog, \"arg %d in %s = 0x%s\\n\",\n \t\t\t\t    argnum,\n \t\t\t\t    gdbarch_register_name\n \t\t\t\t      (gdbarch, argreg),\n-\t\t\t\t    phex (regval, INT_REGISTER_SIZE));\n+\t\t\t\t    phex (regval, ARM_INT_REGISTER_SIZE));\n \t      regcache_cooked_write_unsigned (regcache, argreg, regval);\n \t      argreg++;\n \t    }\n \t  else\n \t    {\n-\t      gdb_byte buf[INT_REGISTER_SIZE];\n+\t      gdb_byte buf[ARM_INT_REGISTER_SIZE];\n \n \t      memset (buf, 0, sizeof (buf));\n \t      store_unsigned_integer (buf, partial_len, byte_order, regval);\n@@ -3833,8 +3835,8 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      if (arm_debug)\n \t\tfprintf_unfiltered (gdb_stdlog, \"arg %d @ sp + %d\\n\",\n \t\t\t\t    argnum, nstack);\n-\t      si = push_stack_item (si, buf, INT_REGISTER_SIZE);\n-\t      nstack += INT_REGISTER_SIZE;\n+\t      si = push_stack_item (si, buf, ARM_INT_REGISTER_SIZE);\n+\t      nstack += ARM_INT_REGISTER_SIZE;\n \t    }\n \t      \n \t  len -= partial_len;\n@@ -7840,7 +7842,7 @@ arm_extract_return_value (struct type *type, struct regcache *regs,\n \t    /* The value is in register F0 in internal format.  We need to\n \t       extract the raw value and then convert it to the desired\n \t       internal type.  */\n-\t    bfd_byte tmpbuf[FP_REGISTER_SIZE];\n+\t    bfd_byte tmpbuf[ARM_FP_REGISTER_SIZE];\n \n \t    regs->cooked_read (ARM_F0_REGNUM, tmpbuf);\n \t    target_float_convert (tmpbuf, arm_ext_type (gdbarch),\n@@ -7855,7 +7857,8 @@ arm_extract_return_value (struct type *type, struct regcache *regs,\n \tcase ARM_FLOAT_VFP:\n \t  regs->cooked_read (ARM_A1_REGNUM, valbuf);\n \t  if (TYPE_LENGTH (type) > 4)\n-\t    regs->cooked_read (ARM_A1_REGNUM + 1, valbuf + INT_REGISTER_SIZE);\n+\t    regs->cooked_read (ARM_A1_REGNUM + 1,\n+\t\t\t       valbuf + ARM_INT_REGISTER_SIZE);\n \t  break;\n \n \tdefault:\n@@ -7885,11 +7888,11 @@ arm_extract_return_value (struct type *type, struct regcache *regs,\n \t     anything special for small big-endian values.  */\n \t  regcache_cooked_read_unsigned (regs, regno++, &tmp);\n \t  store_unsigned_integer (valbuf, \n-\t\t\t\t  (len > INT_REGISTER_SIZE\n-\t\t\t\t   ? INT_REGISTER_SIZE : len),\n+\t\t\t\t  (len > ARM_INT_REGISTER_SIZE\n+\t\t\t\t   ? ARM_INT_REGISTER_SIZE : len),\n \t\t\t\t  byte_order, tmp);\n-\t  len -= INT_REGISTER_SIZE;\n-\t  valbuf += INT_REGISTER_SIZE;\n+\t  len -= ARM_INT_REGISTER_SIZE;\n+\t  valbuf += ARM_INT_REGISTER_SIZE;\n \t}\n     }\n   else\n@@ -7899,15 +7902,15 @@ arm_extract_return_value (struct type *type, struct regcache *regs,\n          registers with 32-bit load instruction(s).  */\n       int len = TYPE_LENGTH (type);\n       int regno = ARM_A1_REGNUM;\n-      bfd_byte tmpbuf[INT_REGISTER_SIZE];\n+      bfd_byte tmpbuf[ARM_INT_REGISTER_SIZE];\n \n       while (len > 0)\n \t{\n \t  regs->cooked_read (regno++, tmpbuf);\n \t  memcpy (valbuf, tmpbuf,\n-\t\t  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);\n-\t  len -= INT_REGISTER_SIZE;\n-\t  valbuf += INT_REGISTER_SIZE;\n+\t\t  len > ARM_INT_REGISTER_SIZE ? ARM_INT_REGISTER_SIZE : len);\n+\t  len -= ARM_INT_REGISTER_SIZE;\n+\t  valbuf += ARM_INT_REGISTER_SIZE;\n \t}\n     }\n }\n@@ -7942,7 +7945,7 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n     {\n       /* The AAPCS says all aggregates not larger than a word are returned\n \t in a register.  */\n-      if (TYPE_LENGTH (type) <= INT_REGISTER_SIZE)\n+      if (TYPE_LENGTH (type) <= ARM_INT_REGISTER_SIZE)\n \treturn 0;\n \n       return 1;\n@@ -7953,12 +7956,12 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n \n       /* All aggregate types that won't fit in a register must be returned\n \t in memory.  */\n-      if (TYPE_LENGTH (type) > INT_REGISTER_SIZE)\n+      if (TYPE_LENGTH (type) > ARM_INT_REGISTER_SIZE)\n \treturn 1;\n \n       /* In the ARM ABI, \"integer\" like aggregate types are returned in\n \t registers.  For an aggregate type to be integer like, its size\n-\t must be less than or equal to INT_REGISTER_SIZE and the\n+\t must be less than or equal to ARM_INT_REGISTER_SIZE and the\n \t offset of each addressable subfield must be zero.  Note that bit\n \t fields are not addressable, and all addressable subfields of\n \t unions always start at offset zero.\n@@ -7982,7 +7985,7 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n \t  int i;\n \t  /* Need to check if this struct/union is \"integer\" like.  For\n \t     this to be true, its size must be less than or equal to\n-\t     INT_REGISTER_SIZE and the offset of each addressable\n+\t     ARM_INT_REGISTER_SIZE and the offset of each addressable\n \t     subfield must be zero.  Note that bit fields are not\n \t     addressable, and unions always start at offset zero.  If any\n \t     of the subfields is a floating point type, the struct/union\n@@ -8041,7 +8044,7 @@ arm_store_return_value (struct type *type, struct regcache *regs,\n \n   if (TYPE_CODE (type) == TYPE_CODE_FLT)\n     {\n-      gdb_byte buf[FP_REGISTER_SIZE];\n+      gdb_byte buf[ARM_FP_REGISTER_SIZE];\n \n       switch (gdbarch_tdep (gdbarch)->fp_model)\n \t{\n@@ -8058,7 +8061,8 @@ arm_store_return_value (struct type *type, struct regcache *regs,\n \tcase ARM_FLOAT_VFP:\n \t  regs->cooked_write (ARM_A1_REGNUM, valbuf);\n \t  if (TYPE_LENGTH (type) > 4)\n-\t    regs->cooked_write (ARM_A1_REGNUM + 1, valbuf + INT_REGISTER_SIZE);\n+\t    regs->cooked_write (ARM_A1_REGNUM + 1,\n+\t\t\t\tvalbuf + ARM_INT_REGISTER_SIZE);\n \t  break;\n \n \tdefault:\n@@ -8079,10 +8083,10 @@ arm_store_return_value (struct type *type, struct regcache *regs,\n \t{\n \t  /* Values of one word or less are zero/sign-extended and\n \t     returned in r0.  */\n-\t  bfd_byte tmpbuf[INT_REGISTER_SIZE];\n+\t  bfd_byte tmpbuf[ARM_INT_REGISTER_SIZE];\n \t  LONGEST val = unpack_long (type, valbuf);\n \n-\t  store_signed_integer (tmpbuf, INT_REGISTER_SIZE, byte_order, val);\n+\t  store_signed_integer (tmpbuf, ARM_INT_REGISTER_SIZE, byte_order, val);\n \t  regs->cooked_write (ARM_A1_REGNUM, tmpbuf);\n \t}\n       else\n@@ -8096,8 +8100,8 @@ arm_store_return_value (struct type *type, struct regcache *regs,\n \t  while (len > 0)\n \t    {\n \t      regs->cooked_write (regno++, valbuf);\n-\t      len -= INT_REGISTER_SIZE;\n-\t      valbuf += INT_REGISTER_SIZE;\n+\t      len -= ARM_INT_REGISTER_SIZE;\n+\t      valbuf += ARM_INT_REGISTER_SIZE;\n \t    }\n \t}\n     }\n@@ -8108,15 +8112,15 @@ arm_store_return_value (struct type *type, struct regcache *regs,\n          registers with 32-bit load instruction(s).  */\n       int len = TYPE_LENGTH (type);\n       int regno = ARM_A1_REGNUM;\n-      bfd_byte tmpbuf[INT_REGISTER_SIZE];\n+      bfd_byte tmpbuf[ARM_INT_REGISTER_SIZE];\n \n       while (len > 0)\n \t{\n \t  memcpy (tmpbuf, valbuf,\n-\t\t  len > INT_REGISTER_SIZE ? INT_REGISTER_SIZE : len);\n+\t\t  len > ARM_INT_REGISTER_SIZE ? ARM_INT_REGISTER_SIZE : len);\n \t  regs->cooked_write (regno++, tmpbuf);\n-\t  len -= INT_REGISTER_SIZE;\n-\t  valbuf += INT_REGISTER_SIZE;\n+\t  len -= ARM_INT_REGISTER_SIZE;\n+\t  valbuf += ARM_INT_REGISTER_SIZE;\n \t}\n     }\n }\n@@ -8200,15 +8204,15 @@ arm_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   CORE_ADDR jb_addr;\n-  gdb_byte buf[INT_REGISTER_SIZE];\n+  gdb_byte buf[ARM_INT_REGISTER_SIZE];\n   \n   jb_addr = get_frame_register_unsigned (frame, ARM_A1_REGNUM);\n \n   if (target_read_memory (jb_addr + tdep->jb_pc * tdep->jb_elt_size, buf,\n-\t\t\t  INT_REGISTER_SIZE))\n+\t\t\t  ARM_INT_REGISTER_SIZE))\n     return 0;\n \n-  *pc = extract_unsigned_integer (buf, INT_REGISTER_SIZE, byte_order);\n+  *pc = extract_unsigned_integer (buf, ARM_INT_REGISTER_SIZE, byte_order);\n   return 1;\n }\n \n@@ -8778,24 +8782,24 @@ arm_register_g_packet_guesses (struct gdbarch *gdbarch)\n \t same as the FPA layout.  */\n       register_remote_g_packet_guess (gdbarch,\n \t\t\t\t      /* r0-r12,sp,lr,pc; f0-f7; fps,xpsr */\n-\t\t\t\t      (16 * INT_REGISTER_SIZE)\n-\t\t\t\t      + (8 * FP_REGISTER_SIZE)\n-\t\t\t\t      + (2 * INT_REGISTER_SIZE),\n+\t\t\t\t      (16 * ARM_INT_REGISTER_SIZE)\n+\t\t\t\t      + (8 * ARM_FP_REGISTER_SIZE)\n+\t\t\t\t      + (2 * ARM_INT_REGISTER_SIZE),\n \t\t\t\t      tdesc_arm_with_m_fpa_layout);\n \n       /* The regular M-profile layout.  */\n       register_remote_g_packet_guess (gdbarch,\n \t\t\t\t      /* r0-r12,sp,lr,pc; xpsr */\n-\t\t\t\t      (16 * INT_REGISTER_SIZE)\n-\t\t\t\t      + INT_REGISTER_SIZE,\n+\t\t\t\t      (16 * ARM_INT_REGISTER_SIZE)\n+\t\t\t\t      + ARM_INT_REGISTER_SIZE,\n \t\t\t\t      tdesc_arm_with_m);\n \n       /* M-profile plus M4F VFP.  */\n       register_remote_g_packet_guess (gdbarch,\n \t\t\t\t      /* r0-r12,sp,lr,pc; d0-d15; fpscr,xpsr */\n-\t\t\t\t      (16 * INT_REGISTER_SIZE)\n-\t\t\t\t      + (16 * VFP_REGISTER_SIZE)\n-\t\t\t\t      + (2 * INT_REGISTER_SIZE),\n+\t\t\t\t      (16 * ARM_INT_REGISTER_SIZE)\n+\t\t\t\t      + (16 * ARM_VFP_REGISTER_SIZE)\n+\t\t\t\t      + (2 * ARM_INT_REGISTER_SIZE),\n \t\t\t\t      tdesc_arm_with_m_vfp_d16);\n     }\n \n@@ -10976,7 +10980,7 @@ arm_record_ld_st_multiple (insn_decode_record *arm_insn_r)\n \t  /* STMDA (STMED): Decrement after.  */\n \t  case 0:\n \t  record_buf_mem[1] = (uint32_t) u_regval\n-\t\t\t      - register_count * INT_REGISTER_SIZE + 4;\n+\t\t\t      - register_count * ARM_INT_REGISTER_SIZE + 4;\n \t  break;\n \t  /* STM (STMIA, STMEA): Increment after.  */\n \t  case 1:\n@@ -10985,18 +10989,18 @@ arm_record_ld_st_multiple (insn_decode_record *arm_insn_r)\n \t  /* STMDB (STMFD): Decrement before.  */\n \t  case 2:\n \t  record_buf_mem[1] = (uint32_t) u_regval\n-\t\t\t      - register_count * INT_REGISTER_SIZE;\n+\t\t\t      - register_count * ARM_INT_REGISTER_SIZE;\n \t  break;\n \t  /* STMIB (STMFA): Increment before.  */\n \t  case 3:\n-\t  record_buf_mem[1] = (uint32_t) u_regval + INT_REGISTER_SIZE;\n+\t  record_buf_mem[1] = (uint32_t) u_regval + ARM_INT_REGISTER_SIZE;\n \t  break;\n \t  default:\n \t    gdb_assert_not_reached (\"no decoding pattern found\");\n \t  break;\n \t}\n \n-      record_buf_mem[0] = register_count * INT_REGISTER_SIZE;\n+      record_buf_mem[0] = register_count * ARM_INT_REGISTER_SIZE;\n       arm_insn_r->mem_rec_count = 1;\n \n       /* If wback is true, also save the base register, which is going to be"
    },
    {
      "sha": "807849a5ffcac0627a5c945fbd59197e3260dbcd",
      "filename": "gdb/arm-tdep.h",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.h?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -32,15 +32,6 @@ struct gdb_get_next_pcs;\n \n #include <vector>\n \n-/* Say how long FP registers are.  Used for documentation purposes and\n-   code readability in this header.  IEEE extended doubles are 80\n-   bits.  DWORD aligned they use 96 bits.  */\n-#define FP_REGISTER_SIZE\t12\n-\n-/* Say how long VFP double precision registers are.  Used for documentation\n-   purposes and code readability.  These are fixed at 64 bits.  */\n-#define VFP_REGISTER_SIZE\t8\n-\n /* Number of machine registers.  The only define actually required \n    is gdbarch_num_regs.  The other definitions are used for documentation\n    purposes and code readability.  */"
    },
    {
      "sha": "584eef9fedc7a2070920b3b4a2ebbe055236c687",
      "filename": "gdb/arm-wince-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-wince-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f0452268d6c7296106aba81f532b04dc08187352/gdb/arm-wince-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-wince-tdep.c?ref=f0452268d6c7296106aba81f532b04dc08187352",
      "patch": "@@ -32,7 +32,7 @@ static const gdb_byte arm_wince_le_breakpoint[] = { 0x10, 0x00, 0x00, 0xe6 };\n static const gdb_byte arm_wince_thumb_le_breakpoint[] = { 0xfe, 0xdf };\n \n /* Description of the longjmp buffer.  */\n-#define ARM_WINCE_JB_ELEMENT_SIZE\tINT_REGISTER_SIZE\n+#define ARM_WINCE_JB_ELEMENT_SIZE\tARM_INT_REGISTER_SIZE\n #define ARM_WINCE_JB_PC\t\t\t10\n \n static CORE_ADDR"
    }
  ]
}