{
  "sha": "9adda7af10c354a62146d917a30a2fae8df370d1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWFkZGE3YWYxMGMzNTRhNjIxNDZkOTE3YTMwYTJmYWU4ZGYzNzBkMQ==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-07-03T12:34:21Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-07-03T12:34:21Z"
    },
    "message": "Remove stale overlay testcase bits\n\nD10V support was removed years ago, but the gdb.base/d10vovly.c file\nstayed behind.  Looking a bit closer, I can't find anywhere that\nreferences gdb.base/m32rovly.c either.\n\nBoth gdb.base/m32rovly.c and gdb.base/d10vovly.c seem to be older\ncopies of gdb.base/ovlymgr.c, that are exactly the same, except for\nsome cosmetic differences, and for missing _ovly_debug_event.  Note\nthat gdb.base/ovlymgr.c has the #ifdef __M32R__ bits too.  Note also\nthat gdb.base/overlays.exp is currently only supported on m32r, and\nthat uses ovlymgr.c not gdb.base/m32rovly.c.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.base/d10vovly.c: Delete.\n\t* gdb.base/m32rovly.c: Delete.\n\t* gdb.base/ovlymgr.c: Remove all code guarded by __D10V__.",
    "tree": {
      "sha": "a1de6b29a269d60004bea926015f8db10982fd9e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a1de6b29a269d60004bea926015f8db10982fd9e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9adda7af10c354a62146d917a30a2fae8df370d1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9adda7af10c354a62146d917a30a2fae8df370d1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9adda7af10c354a62146d917a30a2fae8df370d1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9adda7af10c354a62146d917a30a2fae8df370d1/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b657622c3ecd810064f17f279b0a56648b4dc2d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b657622c3ecd810064f17f279b0a56648b4dc2d6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b657622c3ecd810064f17f279b0a56648b4dc2d6"
    }
  ],
  "stats": {
    "total": 588,
    "additions": 5,
    "deletions": 583
  },
  "files": [
    {
      "sha": "f6c7e5a62e78d156d586f9863c9a0478027f7fb8",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9adda7af10c354a62146d917a30a2fae8df370d1/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9adda7af10c354a62146d917a30a2fae8df370d1/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=9adda7af10c354a62146d917a30a2fae8df370d1",
      "patch": "@@ -1,3 +1,8 @@\n+2020-07-03  Pedro Alves  <palves@redhat.com>\n+\n+\t* gdb.base/m32rovly.c: Delete.\n+\t* gdb.base/ovlymgr.c: Remove all code guarded by __D10V__.\n+\n 2020-06-30  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n \n \t* gdb.python/py-breakpoint.exp: use gdb_test_multiline instead"
    },
    {
      "sha": "bdb90feae6bd5f23fac3397399ccb18cf2065c80",
      "filename": "gdb/testsuite/gdb.base/d10vovly.c",
      "status": "removed",
      "additions": 0,
      "deletions": 225,
      "changes": 225,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b657622c3ecd810064f17f279b0a56648b4dc2d6/gdb/testsuite/gdb.base/d10vovly.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b657622c3ecd810064f17f279b0a56648b4dc2d6/gdb/testsuite/gdb.base/d10vovly.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/d10vovly.c?ref=b657622c3ecd810064f17f279b0a56648b4dc2d6",
      "patch": "@@ -1,225 +0,0 @@\n-\n-/*\n- * Ovlymgr.c -- Runtime Overlay Manager for the GDB testsuite.\n- */\n-\n-#include \"ovlymgr.h\"\n-\n-/* Local functions and data: */\n-\n-extern unsigned long _ovly_table[][4];\n-extern unsigned long _novlys __attribute__ ((section (\".data\")));\n-enum ovly_index { VMA, SIZE, LMA, MAPPED};\n-\n-static void ovly_copy (unsigned long dst, unsigned long src, long size);\n-\n-/* Flush the data and instruction caches at address START for SIZE bytes.\n-   Support for each new port must be added here.  */\n-/* FIXME: Might be better to have a standard libgloss function that\n-   ports provide that we can then use.  Use libgloss instead of newlib\n-   since libgloss is the one intended to handle low level system issues.\n-   I would suggest something like _flush_cache to avoid the user's namespace\n-   but not be completely obscure as other things may need this facility.  */\n- \n-static void\n-FlushCache (void)\n-{\n-#ifdef __M32R__\n-  volatile char *mspr = (char *) 0xfffffff7;\n-  *mspr = 1;\n-#endif\n-}\n-\n-/* OverlayLoad:\n- * Copy the overlay into its runtime region,\n- * and mark the overlay as \"mapped\".\n- */\n-\n-bool\n-OverlayLoad (unsigned long ovlyno)\n-{\n-  unsigned long i;\n-\n-  if (ovlyno < 0 || ovlyno >= _novlys)\n-    exit (-1);\t/* fail, bad ovly number */\n-\n-  if (_ovly_table[ovlyno][MAPPED])\n-    return TRUE;\t/* this overlay already mapped -- nothing to do! */\n-\n-  for (i = 0; i < _novlys; i++)\n-    if (i == ovlyno)\n-      _ovly_table[i][MAPPED] = 1;\t/* this one now mapped */\n-    else if (_ovly_table[i][VMA] == _ovly_table[ovlyno][VMA])\n-      _ovly_table[i][MAPPED] = 0;\t/* this one now un-mapped */\n-\n-  ovly_copy (_ovly_table[ovlyno][VMA], \n-\t     _ovly_table[ovlyno][LMA], \n-\t     _ovly_table[ovlyno][SIZE]);\n-\n-  FlushCache ();\n-\n-  return TRUE;\n-}\n-\n-/* OverlayUnload:\n- * Copy the overlay back into its \"load\" region.\n- * Does NOT mark overlay as \"unmapped\", therefore may be called\n- * more than once for the same mapped overlay.\n- */\n- \n-bool\n-OverlayUnload (unsigned long ovlyno)\n-{\n-  if (ovlyno < 0 || ovlyno >= _novlys)\n-    exit (-1);  /* fail, bad ovly number */\n- \n-  if (!_ovly_table[ovlyno][MAPPED])\n-    exit (-1);  /* error, can't copy out a segment that's not \"in\" */\n- \n-  ovly_copy (_ovly_table[ovlyno][LMA], \n-\t     _ovly_table[ovlyno][VMA],\n-\t     _ovly_table[ovlyno][SIZE]);\n-\n-  return TRUE;\n-}\n-\n-#ifdef __D10V__\n-#define IMAP0       (*(short *)(0xff00))\n-#define IMAP1       (*(short *)(0xff02))\n-#define DMAP        (*(short *)(0xff04))\n-\n-static void\n-D10VTranslate (unsigned long logical,\n-\t       short *dmap,\n-\t       unsigned long **addr)\n-{\n-  unsigned long physical;\n-  unsigned long seg;\n-  unsigned long off;\n-\n-  /* to access data, we use the following mapping \n-     0x00xxxxxx: Logical data address segment        (DMAP translated memory)\n-     0x01xxxxxx: Logical instruction address segment (IMAP translated memory)\n-     0x10xxxxxx: Physical data memory segment        (On-chip data memory)\n-     0x11xxxxxx: Physical instruction memory segment (On-chip insn memory)\n-     0x12xxxxxx: Phisical unified memory segment     (Unified memory)\n-     */\n-\n-  /* Addresses must be correctly aligned */\n-  if (logical & (sizeof (**addr) - 1))\n-    exit (-1);\n-\n-  /* If the address is in one of the two logical address spaces, it is\n-     first translated into a physical address */\n-  seg = (logical >> 24);\n-  off = (logical & 0xffffffL);\n-  switch (seg) \n-      {\n-      case 0x00: /* in logical data address segment */\n-\tif (off <= 0x7fffL)\n-\t  physical = (0x10L << 24) + off;\n-\telse\n-\t  /* Logical address out side of on-chip segment, not\n-             supported */\n-\t  exit (-1);\n-\tbreak;\n-      case 0x01: /* in logical instruction address segment */\n-\t{\n-\t  short map;\n-\t  if (off <= 0x1ffffL)\n-\t    map = IMAP0;\n-\t  else if (off <= 0x3ffffL)\n-\t    map = IMAP1;\n-\t  else\n-\t    /* Logical address outside of IMAP[01] segment, not\n-\t       supported */\n-\t    exit (-1);\n-\t  if (map & 0x1000L)\n-\t    {\n-\t    /* Instruction memory */\n-\t      physical = (0x11L << 24) | off;\n-\t    }\n-\t  else\n-\t    {\n-\t    /* Unified memory */\n-\t      physical = ((map & 0x7fL) << 17) + (off & 0x1ffffL);\n-\t      if (physical > 0xffffffL)\n-\t\t/* Address outside of unified address segment */\n-\t\texit (-1);\n-\t      physical |= (0x12L << 24);\n-\t    }\n-\t  break;\n-\t}\n-      case 0x10:\n-      case 0x11:\n-      case 0x12:\n-\tphysical = logical;\n-\tbreak;\n-      default:\n-\texit (-1);\t/* error */\n-      }\n-\n-  seg = (physical >> 24);\n-  off = (physical & 0xffffffL);\n-  switch (seg) \n-    {\n-    case 0x10:\t/* dst is a 15 bit offset into the on-chip memory */\n-      *dmap = 0;\n-      *addr = (long *) (0x0000 + ((short)off & 0x7fff));\n-      break;\n-    case 0x11:\t/* dst is an 18-bit offset into the on-chip\n-\t\t   instruction memory */\n-      *dmap = 0x1000L | ((off & 0x3ffffL) >> 14);\n-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));\n-      break;\n-    case 0x12:\t/* dst is a 24-bit offset into unified memory */\n-      *dmap = off >> 14;\n-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));\n-      break;\n-    default:\n-      exit (-1);\t/* error */\n-    }\n-}\n-#endif /* __D10V__ */\n-\n-static void\n-ovly_copy (unsigned long dst, unsigned long src, long size)\n-{\n-#ifdef  __M32R__\n-  memcpy ((void *) dst, (void *) src, size);\n-  return;\n-#endif /* M32R */\n-\n-#ifdef  __D10V__\n-  unsigned long *s, *d, tmp;\n-  short dmap_src, dmap_dst;\n-  short dmap_save;\n-\n-  /* all section sizes should by multiples of 4 bytes */\n-  dmap_save = DMAP;\n-\n-  D10VTranslate (src, &dmap_src, &s);\n-  D10VTranslate (dst, &dmap_dst, &d);\n-\n-  while (size > 0)\n-    {\n-      /* NB: Transfer 4 byte (long) quantites, problems occure\n-\t when only two bytes are transfered */\n-      DMAP = dmap_src;\n-      tmp = *s;\n-      DMAP = dmap_dst;\n-      *d = tmp; \n-      d++;\n-      s++;\n-      size -= sizeof (tmp);\n-      src += sizeof (tmp);\n-      dst += sizeof (tmp);\n-      if ((src & 0x3fff) == 0)\n-\tD10VTranslate (src, &dmap_src, &s);\n-      if ((dst & 0x3fff) == 0)\n-\tD10VTranslate (dst, &dmap_dst, &d);\n-    }\n-  DMAP = dmap_save;\n-#endif /* D10V */\n-}\n-"
    },
    {
      "sha": "bdb90feae6bd5f23fac3397399ccb18cf2065c80",
      "filename": "gdb/testsuite/gdb.base/m32rovly.c",
      "status": "removed",
      "additions": 0,
      "deletions": 225,
      "changes": 225,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b657622c3ecd810064f17f279b0a56648b4dc2d6/gdb/testsuite/gdb.base/m32rovly.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b657622c3ecd810064f17f279b0a56648b4dc2d6/gdb/testsuite/gdb.base/m32rovly.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/m32rovly.c?ref=b657622c3ecd810064f17f279b0a56648b4dc2d6",
      "patch": "@@ -1,225 +0,0 @@\n-\n-/*\n- * Ovlymgr.c -- Runtime Overlay Manager for the GDB testsuite.\n- */\n-\n-#include \"ovlymgr.h\"\n-\n-/* Local functions and data: */\n-\n-extern unsigned long _ovly_table[][4];\n-extern unsigned long _novlys __attribute__ ((section (\".data\")));\n-enum ovly_index { VMA, SIZE, LMA, MAPPED};\n-\n-static void ovly_copy (unsigned long dst, unsigned long src, long size);\n-\n-/* Flush the data and instruction caches at address START for SIZE bytes.\n-   Support for each new port must be added here.  */\n-/* FIXME: Might be better to have a standard libgloss function that\n-   ports provide that we can then use.  Use libgloss instead of newlib\n-   since libgloss is the one intended to handle low level system issues.\n-   I would suggest something like _flush_cache to avoid the user's namespace\n-   but not be completely obscure as other things may need this facility.  */\n- \n-static void\n-FlushCache (void)\n-{\n-#ifdef __M32R__\n-  volatile char *mspr = (char *) 0xfffffff7;\n-  *mspr = 1;\n-#endif\n-}\n-\n-/* OverlayLoad:\n- * Copy the overlay into its runtime region,\n- * and mark the overlay as \"mapped\".\n- */\n-\n-bool\n-OverlayLoad (unsigned long ovlyno)\n-{\n-  unsigned long i;\n-\n-  if (ovlyno < 0 || ovlyno >= _novlys)\n-    exit (-1);\t/* fail, bad ovly number */\n-\n-  if (_ovly_table[ovlyno][MAPPED])\n-    return TRUE;\t/* this overlay already mapped -- nothing to do! */\n-\n-  for (i = 0; i < _novlys; i++)\n-    if (i == ovlyno)\n-      _ovly_table[i][MAPPED] = 1;\t/* this one now mapped */\n-    else if (_ovly_table[i][VMA] == _ovly_table[ovlyno][VMA])\n-      _ovly_table[i][MAPPED] = 0;\t/* this one now un-mapped */\n-\n-  ovly_copy (_ovly_table[ovlyno][VMA], \n-\t     _ovly_table[ovlyno][LMA], \n-\t     _ovly_table[ovlyno][SIZE]);\n-\n-  FlushCache ();\n-\n-  return TRUE;\n-}\n-\n-/* OverlayUnload:\n- * Copy the overlay back into its \"load\" region.\n- * Does NOT mark overlay as \"unmapped\", therefore may be called\n- * more than once for the same mapped overlay.\n- */\n- \n-bool\n-OverlayUnload (unsigned long ovlyno)\n-{\n-  if (ovlyno < 0 || ovlyno >= _novlys)\n-    exit (-1);  /* fail, bad ovly number */\n- \n-  if (!_ovly_table[ovlyno][MAPPED])\n-    exit (-1);  /* error, can't copy out a segment that's not \"in\" */\n- \n-  ovly_copy (_ovly_table[ovlyno][LMA], \n-\t     _ovly_table[ovlyno][VMA],\n-\t     _ovly_table[ovlyno][SIZE]);\n-\n-  return TRUE;\n-}\n-\n-#ifdef __D10V__\n-#define IMAP0       (*(short *)(0xff00))\n-#define IMAP1       (*(short *)(0xff02))\n-#define DMAP        (*(short *)(0xff04))\n-\n-static void\n-D10VTranslate (unsigned long logical,\n-\t       short *dmap,\n-\t       unsigned long **addr)\n-{\n-  unsigned long physical;\n-  unsigned long seg;\n-  unsigned long off;\n-\n-  /* to access data, we use the following mapping \n-     0x00xxxxxx: Logical data address segment        (DMAP translated memory)\n-     0x01xxxxxx: Logical instruction address segment (IMAP translated memory)\n-     0x10xxxxxx: Physical data memory segment        (On-chip data memory)\n-     0x11xxxxxx: Physical instruction memory segment (On-chip insn memory)\n-     0x12xxxxxx: Phisical unified memory segment     (Unified memory)\n-     */\n-\n-  /* Addresses must be correctly aligned */\n-  if (logical & (sizeof (**addr) - 1))\n-    exit (-1);\n-\n-  /* If the address is in one of the two logical address spaces, it is\n-     first translated into a physical address */\n-  seg = (logical >> 24);\n-  off = (logical & 0xffffffL);\n-  switch (seg) \n-      {\n-      case 0x00: /* in logical data address segment */\n-\tif (off <= 0x7fffL)\n-\t  physical = (0x10L << 24) + off;\n-\telse\n-\t  /* Logical address out side of on-chip segment, not\n-             supported */\n-\t  exit (-1);\n-\tbreak;\n-      case 0x01: /* in logical instruction address segment */\n-\t{\n-\t  short map;\n-\t  if (off <= 0x1ffffL)\n-\t    map = IMAP0;\n-\t  else if (off <= 0x3ffffL)\n-\t    map = IMAP1;\n-\t  else\n-\t    /* Logical address outside of IMAP[01] segment, not\n-\t       supported */\n-\t    exit (-1);\n-\t  if (map & 0x1000L)\n-\t    {\n-\t    /* Instruction memory */\n-\t      physical = (0x11L << 24) | off;\n-\t    }\n-\t  else\n-\t    {\n-\t    /* Unified memory */\n-\t      physical = ((map & 0x7fL) << 17) + (off & 0x1ffffL);\n-\t      if (physical > 0xffffffL)\n-\t\t/* Address outside of unified address segment */\n-\t\texit (-1);\n-\t      physical |= (0x12L << 24);\n-\t    }\n-\t  break;\n-\t}\n-      case 0x10:\n-      case 0x11:\n-      case 0x12:\n-\tphysical = logical;\n-\tbreak;\n-      default:\n-\texit (-1);\t/* error */\n-      }\n-\n-  seg = (physical >> 24);\n-  off = (physical & 0xffffffL);\n-  switch (seg) \n-    {\n-    case 0x10:\t/* dst is a 15 bit offset into the on-chip memory */\n-      *dmap = 0;\n-      *addr = (long *) (0x0000 + ((short)off & 0x7fff));\n-      break;\n-    case 0x11:\t/* dst is an 18-bit offset into the on-chip\n-\t\t   instruction memory */\n-      *dmap = 0x1000L | ((off & 0x3ffffL) >> 14);\n-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));\n-      break;\n-    case 0x12:\t/* dst is a 24-bit offset into unified memory */\n-      *dmap = off >> 14;\n-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));\n-      break;\n-    default:\n-      exit (-1);\t/* error */\n-    }\n-}\n-#endif /* __D10V__ */\n-\n-static void\n-ovly_copy (unsigned long dst, unsigned long src, long size)\n-{\n-#ifdef  __M32R__\n-  memcpy ((void *) dst, (void *) src, size);\n-  return;\n-#endif /* M32R */\n-\n-#ifdef  __D10V__\n-  unsigned long *s, *d, tmp;\n-  short dmap_src, dmap_dst;\n-  short dmap_save;\n-\n-  /* all section sizes should by multiples of 4 bytes */\n-  dmap_save = DMAP;\n-\n-  D10VTranslate (src, &dmap_src, &s);\n-  D10VTranslate (dst, &dmap_dst, &d);\n-\n-  while (size > 0)\n-    {\n-      /* NB: Transfer 4 byte (long) quantites, problems occure\n-\t when only two bytes are transfered */\n-      DMAP = dmap_src;\n-      tmp = *s;\n-      DMAP = dmap_dst;\n-      *d = tmp; \n-      d++;\n-      s++;\n-      size -= sizeof (tmp);\n-      src += sizeof (tmp);\n-      dst += sizeof (tmp);\n-      if ((src & 0x3fff) == 0)\n-\tD10VTranslate (src, &dmap_src, &s);\n-      if ((dst & 0x3fff) == 0)\n-\tD10VTranslate (dst, &dmap_dst, &d);\n-    }\n-  DMAP = dmap_save;\n-#endif /* D10V */\n-}\n-"
    },
    {
      "sha": "5d087ad90a211d85ba6f39c3f735f324cac0dade",
      "filename": "gdb/testsuite/gdb.base/ovlymgr.c",
      "status": "modified",
      "additions": 0,
      "deletions": 133,
      "changes": 133,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9adda7af10c354a62146d917a30a2fae8df370d1/gdb/testsuite/gdb.base/ovlymgr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9adda7af10c354a62146d917a30a2fae8df370d1/gdb/testsuite/gdb.base/ovlymgr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ovlymgr.c?ref=9adda7af10c354a62146d917a30a2fae8df370d1",
      "patch": "@@ -93,141 +93,8 @@ OverlayUnload (unsigned long ovlyno)\n   return TRUE;\n }\n \n-#ifdef __D10V__\n-#define IMAP0       (*(short *)(0xff00))\n-#define IMAP1       (*(short *)(0xff02))\n-#define DMAP        (*(short *)(0xff04))\n-\n-static void\n-D10VTranslate (unsigned long logical,\n-\t       short *dmap,\n-\t       unsigned long **addr)\n-{\n-  unsigned long physical;\n-  unsigned long seg;\n-  unsigned long off;\n-\n-  /* to access data, we use the following mapping \n-     0x00xxxxxx: Logical data address segment        (DMAP translated memory)\n-     0x01xxxxxx: Logical instruction address segment (IMAP translated memory)\n-     0x10xxxxxx: Physical data memory segment        (On-chip data memory)\n-     0x11xxxxxx: Physical instruction memory segment (On-chip insn memory)\n-     0x12xxxxxx: Phisical unified memory segment     (Unified memory)\n-     */\n-\n-  /* Addresses must be correctly aligned */\n-  if (logical & (sizeof (**addr) - 1))\n-    exit (-1);\n-\n-  /* If the address is in one of the two logical address spaces, it is\n-     first translated into a physical address */\n-  seg = (logical >> 24);\n-  off = (logical & 0xffffffL);\n-  switch (seg) \n-      {\n-      case 0x00: /* in logical data address segment */\n-\tif (off <= 0x7fffL)\n-\t  physical = (0x10L << 24) + off;\n-\telse\n-\t  /* Logical address out side of on-chip segment, not\n-             supported */\n-\t  exit (-1);\n-\tbreak;\n-      case 0x01: /* in logical instruction address segment */\n-\t{\n-\t  short map;\n-\t  if (off <= 0x1ffffL)\n-\t    map = IMAP0;\n-\t  else if (off <= 0x3ffffL)\n-\t    map = IMAP1;\n-\t  else\n-\t    /* Logical address outside of IMAP[01] segment, not\n-\t       supported */\n-\t    exit (-1);\n-\t  if (map & 0x1000L)\n-\t    {\n-\t    /* Instruction memory */\n-\t      physical = (0x11L << 24) | off;\n-\t    }\n-\t  else\n-\t    {\n-\t    /* Unified memory */\n-\t      physical = ((map & 0x7fL) << 17) + (off & 0x1ffffL);\n-\t      if (physical > 0xffffffL)\n-\t\t/* Address outside of unified address segment */\n-\t\texit (-1);\n-\t      physical |= (0x12L << 24);\n-\t    }\n-\t  break;\n-\t}\n-      case 0x10:\n-      case 0x11:\n-      case 0x12:\n-\tphysical = logical;\n-\tbreak;\n-      default:\n-\texit (-1);\t/* error */\n-      }\n-\n-  seg = (physical >> 24);\n-  off = (physical & 0xffffffL);\n-  switch (seg) \n-    {\n-    case 0x10:\t/* dst is a 15 bit offset into the on-chip memory */\n-      *dmap = 0;\n-      *addr = (long *) (0x0000 + ((short)off & 0x7fff));\n-      break;\n-    case 0x11:\t/* dst is an 18-bit offset into the on-chip\n-\t\t   instruction memory */\n-      *dmap = 0x1000L | ((off & 0x3ffffL) >> 14);\n-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));\n-      break;\n-    case 0x12:\t/* dst is a 24-bit offset into unified memory */\n-      *dmap = off >> 14;\n-      *addr = (long *) (0x8000 + ((short)off & 0x3fff));\n-      break;\n-    default:\n-      exit (-1);\t/* error */\n-    }\n-}\n-#endif /* __D10V__ */\n-\n static void\n ovly_copy (unsigned long dst, unsigned long src, long size)\n {\n-#ifdef  __D10V__\n-  unsigned long *s, *d, tmp;\n-  short dmap_src, dmap_dst;\n-  short dmap_save;\n-\n-  /* all section sizes should by multiples of 4 bytes */\n-  dmap_save = DMAP;\n-\n-  D10VTranslate (src, &dmap_src, &s);\n-  D10VTranslate (dst, &dmap_dst, &d);\n-\n-  while (size > 0)\n-    {\n-      /* NB: Transfer 4 byte (long) quantites, problems occure\n-\t when only two bytes are transfered */\n-      DMAP = dmap_src;\n-      tmp = *s;\n-      DMAP = dmap_dst;\n-      *d = tmp; \n-      d++;\n-      s++;\n-      size -= sizeof (tmp);\n-      src += sizeof (tmp);\n-      dst += sizeof (tmp);\n-      if ((src & 0x3fff) == 0)\n-\tD10VTranslate (src, &dmap_src, &s);\n-      if ((dst & 0x3fff) == 0)\n-\tD10VTranslate (dst, &dmap_dst, &d);\n-    }\n-  DMAP = dmap_save;\n-#else\n   memcpy ((void *) dst, (void *) src, size);\n-#endif /* D10V */\n-  return;\n }\n-"
    }
  ]
}