{
  "sha": "28d5518b12119eaf087c64fe25e31d2f49e53485",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjhkNTUxOGIxMjExOWVhZjA4N2M2NGZlMjVlMzFkMmY0OWU1MzQ4NQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-04T21:43:53Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-04T21:43:53Z"
    },
    "message": "gdb: rename things related to step over chains\n\nRename step_over_queue_head to global_thread_step_over_chain_head, to\nmake it more obvious when reading code that we are touching the global\nqueue.  Rename all functions that operate on it to have \"global\" in\ntheir name, to make it clear on which chain they operate on.  Also, in a\nsubsequent patch, we'll need both global and non-global versions of\nthese functions, so it will be easier to do the distinction if they are\nnamed properly.\n\nNormalize the naming to use \"chain\" everywhere instead of sometimes\n\"queue\", sometimes \"chain\".\n\nI also reworded a few comments in gdbthread.h.  They implied that the\nstep over chain is per-inferior, when in reality there is only one\nglobal chain, not one per inferior, as far as I understand.\n\ngdb/ChangeLog:\n\n\t* gdbthread.h (thread_step_over_chain_enqueue): Rename to...\n\t(global_thread_step_over_chain_enqueue): ... this.  Update all\n\tusers.\n\t(thread_step_over_chain_remove): Rename to...\n\t(global_thread_step_over_chain_remove): ... this.  Update all\n\tusers.\n\t(thread_step_over_chain_next): Rename to...\n\t(global_thread_step_over_chain_next): ... this.  Update all\n\tusers.\n\t* infrun.h (step_over_queue_head): Rename to...\n\t(global_thread_step_over_chain_head): ... this.  Update all\n\tusers.\n\t* infrun.c (step_over_queue_head): Rename to...\n\t(global_thread_step_over_chain_head): ... this.  Update all\n\tusers.\n\t* thread.c (step_over_chain_remove): Rename to...\n\t(thread_step_over_chain_remove): ... this.  Update all users.\n\t(thread_step_over_chain_next): Rename to...\n\t(global_thread_step_over_chain_next): ... this.  Update all\n\tusers.\n\t(thread_step_over_chain_enqueue): Rename to...\n\t(global_thread_step_over_chain_enqueue): ... this.  Update all\n\tusers.\n\t(thread_step_over_chain_remove): Rename to...\n\t(global_thread_step_over_chain_remove): ... this.  Update all\n\tusers.\n\nChange-Id: Iabbf57d83c01321ca199d83fadb57f5b04e4d6d9",
    "tree": {
      "sha": "729974cc7c7c46b7bd834fb3a75102f350b20e54",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/729974cc7c7c46b7bd834fb3a75102f350b20e54"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/28d5518b12119eaf087c64fe25e31d2f49e53485",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/28d5518b12119eaf087c64fe25e31d2f49e53485",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/28d5518b12119eaf087c64fe25e31d2f49e53485",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/28d5518b12119eaf087c64fe25e31d2f49e53485/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f5f01699643e923edf7d0c661e330ceff609fac5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5f01699643e923edf7d0c661e330ceff609fac5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f5f01699643e923edf7d0c661e330ceff609fac5"
    }
  ],
  "stats": {
    "total": 95,
    "additions": 62,
    "deletions": 33
  },
  "files": [
    {
      "sha": "416f666a16bb88c0247bffe674d648072ddd61e7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=28d5518b12119eaf087c64fe25e31d2f49e53485",
      "patch": "@@ -1,3 +1,32 @@\n+2020-12-04  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbthread.h (thread_step_over_chain_enqueue): Rename to...\n+\t(global_thread_step_over_chain_enqueue): ... this.  Update all\n+\tusers.\n+\t(thread_step_over_chain_remove): Rename to...\n+\t(global_thread_step_over_chain_remove): ... this.  Update all\n+\tusers.\n+\t(thread_step_over_chain_next): Rename to...\n+\t(global_thread_step_over_chain_next): ... this.  Update all\n+\tusers.\n+\t* infrun.h (step_over_queue_head): Rename to...\n+\t(global_thread_step_over_chain_head): ... this.  Update all\n+\tusers.\n+\t* infrun.c (step_over_queue_head): Rename to...\n+\t(global_thread_step_over_chain_head): ... this.  Update all\n+\tusers.\n+\t* thread.c (step_over_chain_remove): Rename to...\n+\t(thread_step_over_chain_remove): ... this.  Update all users.\n+\t(thread_step_over_chain_next): Rename to...\n+\t(global_thread_step_over_chain_next): ... this.  Update all\n+\tusers.\n+\t(thread_step_over_chain_enqueue): Rename to...\n+\t(global_thread_step_over_chain_enqueue): ... this.  Update all\n+\tusers.\n+\t(thread_step_over_chain_remove): Rename to...\n+\t(global_thread_step_over_chain_remove): ... this.  Update all\n+\tusers.\n+\n 2020-12-04  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* infrun.c (get_displaced_stepping_state): Remove, change"
    },
    {
      "sha": "1eecb989a79e69ab59e8e74af41425bf86711fb3",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=28d5518b12119eaf087c64fe25e31d2f49e53485",
      "patch": "@@ -741,20 +741,20 @@ extern value *get_last_thread_stack_temporary (struct thread_info *tp);\n extern bool value_in_thread_stack_temporaries (struct value *,\n \t\t\t\t\t       struct thread_info *thr);\n \n-/* Add TP to the end of its inferior's pending step-over chain.  */\n+/* Add TP to the end of the global pending step-over chain.  */\n \n-extern void thread_step_over_chain_enqueue (struct thread_info *tp);\n+extern void global_thread_step_over_chain_enqueue (thread_info *tp);\n \n-/* Remove TP from its inferior's pending step-over chain.  */\n+/* Remove TP from the global pending step-over chain.  */\n \n-extern void thread_step_over_chain_remove (struct thread_info *tp);\n+extern void global_thread_step_over_chain_remove (thread_info *tp);\n \n-/* Return the next thread in the step-over chain starting at TP.  NULL\n-   if TP is the last entry in the chain.  */\n+/* Return the thread following TP in the global step-over chain, or NULL if TP\n+   is the last entry in the chain.  */\n \n-extern struct thread_info *thread_step_over_chain_next (struct thread_info *tp);\n+extern thread_info *global_thread_step_over_chain_next (thread_info *tp);\n \n-/* Return true if TP is in the step-over chain.  */\n+/* Return true if TP is in any step-over chain.  */\n \n extern int thread_is_in_step_over_chain (struct thread_info *tp);\n "
    },
    {
      "sha": "b965e702538cbb2d235b574abeeb8ccd9670d642",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=28d5518b12119eaf087c64fe25e31d2f49e53485",
      "patch": "@@ -1237,14 +1237,14 @@ follow_exec (ptid_t ptid, const char *exec_file_target)\n      matically get reset there in the new process.).  */\n }\n \n-/* The queue of threads that need to do a step-over operation to get\n+/* The chain of threads that need to do a step-over operation to get\n    past e.g., a breakpoint.  What technique is used to step over the\n    breakpoint/watchpoint does not matter -- all threads end up in the\n    same queue, to maintain rough temporal order of execution, in order\n    to avoid starvation, otherwise, we could e.g., find ourselves\n    constantly stepping the same couple threads past their breakpoints\n    over and over, if the single-step finish fast enough.  */\n-struct thread_info *step_over_queue_head;\n+struct thread_info *global_thread_step_over_chain_head;\n \n /* Bit flags indicating what the thread needs to step over.  */\n \n@@ -1689,7 +1689,7 @@ displaced_step_prepare_throw (thread_info *tp)\n       displaced_debug_printf (\"deferring step of %s\",\n \t\t\t      target_pid_to_str (tp->ptid).c_str ());\n \n-      thread_step_over_chain_enqueue (tp);\n+      global_thread_step_over_chain_enqueue (tp);\n       return 0;\n     }\n   else\n@@ -1940,7 +1940,7 @@ start_step_over (void)\n   if (step_over_info_valid_p ())\n     return false;\n \n-  for (tp = step_over_queue_head; tp != NULL; tp = next)\n+  for (tp = global_thread_step_over_chain_head; tp != NULL; tp = next)\n     {\n       struct execution_control_state ecss;\n       struct execution_control_state *ecs = &ecss;\n@@ -1949,7 +1949,7 @@ start_step_over (void)\n \n       gdb_assert (!tp->stop_requested);\n \n-      next = thread_step_over_chain_next (tp);\n+      next = global_thread_step_over_chain_next (tp);\n \n       /* If this inferior already has a displaced step in process,\n \t don't start a new one.  */\n@@ -1967,9 +1967,9 @@ start_step_over (void)\n       if (must_be_in_line && displaced_step_in_progress_any_inferior ())\n \treturn false;\n \n-      thread_step_over_chain_remove (tp);\n+      global_thread_step_over_chain_remove (tp);\n \n-      if (step_over_queue_head == NULL)\n+      if (global_thread_step_over_chain_head == NULL)\n \tinfrun_debug_printf (\"step-over queue now empty\");\n \n       if (tp->control.trap_expected\n@@ -3026,7 +3026,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t  infrun_debug_printf (\"need to step-over [%s] first\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \n-\t  thread_step_over_chain_enqueue (tp);\n+\t  global_thread_step_over_chain_enqueue (tp);\n \t}\n \n       switch_to_thread (cur_thr);\n@@ -3035,7 +3035,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n   /* Enqueue the current thread last, so that we move all other\n      threads over their breakpoints first.  */\n   if (cur_thr->stepping_over_breakpoint)\n-    thread_step_over_chain_enqueue (cur_thr);\n+    global_thread_step_over_chain_enqueue (cur_thr);\n \n   /* If the thread isn't started, we'll still need to set its prev_pc,\n      so that switch_back_to_stepped_thread knows the thread hasn't\n@@ -3219,7 +3219,7 @@ infrun_thread_stop_requested (ptid_t ptid)\n \t start_step_over doesn't try to resume them\n \t automatically.  */\n       if (thread_is_in_step_over_chain (tp))\n-\tthread_step_over_chain_remove (tp);\n+\tglobal_thread_step_over_chain_remove (tp);\n \n       /* If the thread is stopped, but the user/frontend doesn't\n \t know about that yet, queue a pending event, as if the\n@@ -4823,7 +4823,7 @@ stop_all_threads (void)\n \t\t\t      target_pid_to_str (t->ptid).c_str ());\n \n \t\t\t  t->control.trap_expected = 0;\n-\t\t\t  thread_step_over_chain_enqueue (t);\n+\t\t\t  global_thread_step_over_chain_enqueue (t);\n \t\t\t}\n \t\t    }\n \t\t  else\n@@ -4846,7 +4846,7 @@ stop_all_threads (void)\n \t\t\t{\n \t\t\t  /* Add it back to the step-over queue.  */\n \t\t\t  t->control.trap_expected = 0;\n-\t\t\t  thread_step_over_chain_enqueue (t);\n+\t\t\t  global_thread_step_over_chain_enqueue (t);\n \t\t\t}\n \n \t\t      regcache = get_thread_regcache (t);\n@@ -7776,7 +7776,7 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \t  infrun_debug_printf (\"step-over already in progress: \"\n \t\t\t       \"step-over for %s deferred\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str ());\n-\t  thread_step_over_chain_enqueue (tp);\n+\t  global_thread_step_over_chain_enqueue (tp);\n \t}\n       else\n \t{"
    },
    {
      "sha": "ca0774e8e6b998e7ced73ebcef5211b014d8ab41",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=28d5518b12119eaf087c64fe25e31d2f49e53485",
      "patch": "@@ -262,9 +262,9 @@ extern void infrun_async (int enable);\n    loop.  */\n extern void mark_infrun_async_event_handler (void);\n \n-/* The global queue of threads that need to do a step-over operation\n+/* The global chain of threads that need to do a step-over operation\n    to get past e.g., a breakpoint.  */\n-extern struct thread_info *step_over_queue_head;\n+extern struct thread_info *global_thread_step_over_chain_head;\n \n /* Remove breakpoints if possible (usually that means, if everything\n    is stopped).  On failure, print a message.  */"
    },
    {
      "sha": "2bbb016d4d98dde70e7efcc3f7b00a3e5511f30c",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/28d5518b12119eaf087c64fe25e31d2f49e53485/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=28d5518b12119eaf087c64fe25e31d2f49e53485",
      "patch": "@@ -205,9 +205,9 @@ clear_thread_inferior_resources (struct thread_info *tp)\n static void\n set_thread_exited (thread_info *tp, bool silent)\n {\n-  /* Dead threads don't need to step-over.  Remove from queue.  */\n+  /* Dead threads don't need to step-over.  Remove from chain.  */\n   if (tp->step_over_next != NULL)\n-    thread_step_over_chain_remove (tp);\n+    global_thread_step_over_chain_remove (tp);\n \n   if (tp->state != THREAD_EXITED)\n     {\n@@ -365,7 +365,7 @@ step_over_chain_enqueue (struct thread_info **list_p, struct thread_info *tp)\n /* Remove TP from step-over chain LIST_P.  */\n \n static void\n-step_over_chain_remove (struct thread_info **list_p, struct thread_info *tp)\n+thread_step_over_chain_remove (struct thread_info **list_p, struct thread_info *tp)\n {\n   gdb_assert (tp->step_over_next != NULL);\n   gdb_assert (tp->step_over_prev != NULL);\n@@ -386,11 +386,11 @@ step_over_chain_remove (struct thread_info **list_p, struct thread_info *tp)\n /* See gdbthread.h.  */\n \n struct thread_info *\n-thread_step_over_chain_next (struct thread_info *tp)\n+global_thread_step_over_chain_next (struct thread_info *tp)\n {\n   struct thread_info *next = tp->step_over_next;\n \n-  return (next == step_over_queue_head ? NULL : next);\n+  return (next == global_thread_step_over_chain_head ? NULL : next);\n }\n \n /* See gdbthread.h.  */\n@@ -404,17 +404,17 @@ thread_is_in_step_over_chain (struct thread_info *tp)\n /* See gdbthread.h.  */\n \n void\n-thread_step_over_chain_enqueue (struct thread_info *tp)\n+global_thread_step_over_chain_enqueue (struct thread_info *tp)\n {\n-  step_over_chain_enqueue (&step_over_queue_head, tp);\n+  step_over_chain_enqueue (&global_thread_step_over_chain_head, tp);\n }\n \n /* See gdbthread.h.  */\n \n void\n-thread_step_over_chain_remove (struct thread_info *tp)\n+global_thread_step_over_chain_remove (struct thread_info *tp)\n {\n-  step_over_chain_remove (&step_over_queue_head, tp);\n+  thread_step_over_chain_remove (&global_thread_step_over_chain_head, tp);\n }\n \n /* Delete the thread referenced by THR.  If SILENT, don't notify\n@@ -805,7 +805,7 @@ set_running_thread (struct thread_info *tp, bool running)\n \t the step-over queue, so that we don't try to resume\n \t it until the user wants it to.  */\n       if (tp->step_over_next != NULL)\n-\tthread_step_over_chain_remove (tp);\n+\tglobal_thread_step_over_chain_remove (tp);\n     }\n \n   return started;"
    }
  ]
}