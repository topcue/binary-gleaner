{
  "sha": "a48931cc2df9f87596d93b319236c73ef0fe0f4e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTQ4OTMxY2MyZGY5Zjg3NTk2ZDkzYjMxOTIzNmM3M2VmMGZlMGY0ZQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-16T23:29:25Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-20T08:34:03Z"
    },
    "message": "bfd macro conversion to inline functions, section\n\nThis one exposed a bug in tic6x gas, found with inline function\nparameter type checking.  struct bfd_section and struct bfd_symbol\nboth have a flags field, so bfd_is_com_section (symbol) compiled OK\nwhen bfd_is_com_section was a macro but didn't special case common\nsymbols.\n\nbfd/\n\t* bfd-in.h (bfd_section_name, bfd_section_size, bfd_section_vma),\n\t(bfd_section_lma, bfd_section_alignment, bfd_section_flags),\n\t(bfd_section_userdata, bfd_is_com_section, discarded_section),\n\t(bfd_get_section_limit_octets, bfd_get_section_limit): Delete macros.\n\t* bfd.c (bfd_get_section_limit_octets, bfd_get_section_limit),\n\t(bfd_section_list_remove, bfd_section_list_append),\n\t(bfd_section_list_prepend, bfd_section_list_insert_after),\n\t(bfd_section_list_insert_before, bfd_section_removed_from_list):\n\tNew inline functions.\n\t* section.c (bfd_is_und_section, bfd_is_abs_section),\n\t(bfd_is_ind_section, bfd_is_const_section, bfd_section_list_remove),\n\t(bfd_section_list_append, bfd_section_list_prepend),\n\t(bfd_section_list_insert_after, bfd_section_list_insert_before),\n\t(bfd_section_removed_from_list): Delete macros.\n\t(bfd_section_name, bfd_section_size, bfd_section_vma),\n\t(bfd_section_lma, bfd_section_alignment, bfd_section_flags),\n\t(bfd_section_userdata, bfd_is_com_section, bfd_is_und_section),\n\t(bfd_is_abs_section, bfd_is_ind_section, bfd_is_const_section),\n\t(discarded_section): New inline functions.\n\t* bfd-in2.h: Regenerate.\ngas/\n\t* config/tc-tic6x.c (tc_gen_reloc): Correct common symbol check.\nld/\n\t* emultempl/xtensaelf.em (xtensa_get_section_deps): Comment.\n\tUse bfd_section_userdata.\n\t(xtensa_set_section_deps): Use bfd_set_section_userdata.\n\t* ldlang.c (lang_output_section_get): Use bfd_section_userdata.\n\t(sort_def_symbol): Likewise, and bfd_set_section_userdata.\n\t(init_os): Use bfd_set_section_userdata.\n\t(print_all_symbols): Use bfd_section_userdata.\n\t* ldlang.h (get_userdata): Delete.",
    "tree": {
      "sha": "8a344cb919102bf891b6b172cde5548bfdc45f6e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8a344cb919102bf891b6b172cde5548bfdc45f6e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a48931cc2df9f87596d93b319236c73ef0fe0f4e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a48931cc2df9f87596d93b319236c73ef0fe0f4e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a48931cc2df9f87596d93b319236c73ef0fe0f4e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a48931cc2df9f87596d93b319236c73ef0fe0f4e/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "af30dc128be191dc6179763203035ff62c634284",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af30dc128be191dc6179763203035ff62c634284",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/af30dc128be191dc6179763203035ff62c634284"
    }
  ],
  "stats": {
    "total": 666,
    "additions": 407,
    "deletions": 259
  },
  "files": [
    {
      "sha": "080c628feeb047f456303e57634ca362e3414ad8",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -1,3 +1,26 @@\n+2019-09-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* bfd-in.h (bfd_section_name, bfd_section_size, bfd_section_vma),\n+\t(bfd_section_lma, bfd_section_alignment, bfd_section_flags),\n+\t(bfd_section_userdata, bfd_is_com_section, discarded_section),\n+\t(bfd_get_section_limit_octets, bfd_get_section_limit): Delete macros.\n+\t* bfd.c (bfd_get_section_limit_octets, bfd_get_section_limit),\n+\t(bfd_section_list_remove, bfd_section_list_append),\n+\t(bfd_section_list_prepend, bfd_section_list_insert_after),\n+\t(bfd_section_list_insert_before, bfd_section_removed_from_list):\n+\tNew inline functions.\n+\t* section.c (bfd_is_und_section, bfd_is_abs_section),\n+\t(bfd_is_ind_section, bfd_is_const_section, bfd_section_list_remove),\n+\t(bfd_section_list_append, bfd_section_list_prepend),\n+\t(bfd_section_list_insert_after, bfd_section_list_insert_before),\n+\t(bfd_section_removed_from_list): Delete macros.\n+\t(bfd_section_name, bfd_section_size, bfd_section_vma),\n+\t(bfd_section_lma, bfd_section_alignment, bfd_section_flags),\n+\t(bfd_section_userdata, bfd_is_com_section, bfd_is_und_section),\n+\t(bfd_is_abs_section, bfd_is_ind_section, bfd_is_const_section),\n+\t(discarded_section): New inline functions.\n+\t* bfd-in2.h: Regenerate.\n+\n 2019-09-20  Alan Modra  <amodra@gmail.com>\n \n \t* bfd-in.h (bfd_asymbol_section, bfd_asymbol_value, bfd_asymbol_name),"
    },
    {
      "sha": "969a9657967c4a94f8aa8a78809787b4f54ab5b5",
      "filename": "bfd/bfd-in.h",
      "status": "modified",
      "additions": 0,
      "deletions": 25,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/bfd-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/bfd-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in.h?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -285,31 +285,6 @@ typedef struct bfd_section *sec_ptr;\n   ((((bfd_vma) (this) + (boundary) - 1) >= (bfd_vma) (this))\t\t  \\\n    ? (((bfd_vma) (this) + ((boundary) - 1)) & ~ (bfd_vma) ((boundary)-1)) \\\n    : ~ (bfd_vma) 0)\n-\n-#define bfd_section_name(sec) ((sec)->name)\n-#define bfd_section_size(sec) ((sec)->size)\n-#define bfd_section_vma(sec) ((sec)->vma)\n-#define bfd_section_lma(sec) ((sec)->lma)\n-#define bfd_section_alignment(sec) ((sec)->alignment_power)\n-#define bfd_section_flags(sec) ((sec)->flags)\n-#define bfd_section_userdata(sec) ((sec)->userdata)\n-\n-#define bfd_is_com_section(sec) (((sec)->flags & SEC_IS_COMMON) != 0)\n-\n-#define bfd_get_section_limit_octets(bfd, sec)\t\t\t\\\n-  ((bfd)->direction != write_direction && (sec)->rawsize != 0\t\\\n-   ? (sec)->rawsize : (sec)->size)\n-\n-/* Find the address one past the end of SEC.  */\n-#define bfd_get_section_limit(bfd, sec) \\\n-  (bfd_get_section_limit_octets(bfd, sec) / bfd_octets_per_byte (bfd))\n-\n-/* Return TRUE if input section SEC has been discarded.  */\n-#define discarded_section(sec)\t\t\t\t\\\n-  (!bfd_is_abs_section (sec)\t\t\t\t\t\\\n-   && bfd_is_abs_section ((sec)->output_section)\t\t\\\n-   && (sec)->sec_info_type != SEC_INFO_TYPE_MERGE\t\t\\\n-   && (sec)->sec_info_type != SEC_INFO_TYPE_JUST_SYMS)\n \f\n typedef enum bfd_print_symbol\n {"
    },
    {
      "sha": "44bce06191f8c53692493c4119fb60785b331324",
      "filename": "bfd/bfd-in2.h",
      "status": "modified",
      "additions": 177,
      "deletions": 122,
      "changes": 299,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/bfd-in2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/bfd-in2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in2.h?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -292,31 +292,6 @@ typedef struct bfd_section *sec_ptr;\n   ((((bfd_vma) (this) + (boundary) - 1) >= (bfd_vma) (this))\t\t  \\\n    ? (((bfd_vma) (this) + ((boundary) - 1)) & ~ (bfd_vma) ((boundary)-1)) \\\n    : ~ (bfd_vma) 0)\n-\n-#define bfd_section_name(sec) ((sec)->name)\n-#define bfd_section_size(sec) ((sec)->size)\n-#define bfd_section_vma(sec) ((sec)->vma)\n-#define bfd_section_lma(sec) ((sec)->lma)\n-#define bfd_section_alignment(sec) ((sec)->alignment_power)\n-#define bfd_section_flags(sec) ((sec)->flags)\n-#define bfd_section_userdata(sec) ((sec)->userdata)\n-\n-#define bfd_is_com_section(sec) (((sec)->flags & SEC_IS_COMMON) != 0)\n-\n-#define bfd_get_section_limit_octets(bfd, sec)\t\t\t\\\n-  ((bfd)->direction != write_direction && (sec)->rawsize != 0\t\\\n-   ? (sec)->rawsize : (sec)->size)\n-\n-/* Find the address one past the end of SEC.  */\n-#define bfd_get_section_limit(bfd, sec) \\\n-  (bfd_get_section_limit_octets(bfd, sec) / bfd_octets_per_byte (bfd))\n-\n-/* Return TRUE if input section SEC has been discarded.  */\n-#define discarded_section(sec)\t\t\t\t\\\n-  (!bfd_is_abs_section (sec)\t\t\t\t\t\\\n-   && bfd_is_abs_section ((sec)->output_section)\t\t\\\n-   && (sec)->sec_info_type != SEC_INFO_TYPE_MERGE\t\t\\\n-   && (sec)->sec_info_type != SEC_INFO_TYPE_JUST_SYMS)\n \f\n typedef enum bfd_print_symbol\n {\n@@ -1686,6 +1661,53 @@ struct relax_table {\n   int size;\n };\n \n+static inline const char *\n+bfd_section_name (const asection *sec)\n+{\n+  return sec->name;\n+}\n+\n+static inline bfd_size_type\n+bfd_section_size (const asection *sec)\n+{\n+  return sec->size;\n+}\n+\n+static inline bfd_vma\n+bfd_section_vma (const asection *sec)\n+{\n+  return sec->vma;\n+}\n+\n+static inline bfd_vma\n+bfd_section_lma (const asection *sec)\n+{\n+  return sec->lma;\n+}\n+\n+static inline unsigned int\n+bfd_section_alignment (const asection *sec)\n+{\n+  return sec->alignment_power;\n+}\n+\n+static inline flagword\n+bfd_section_flags (const asection *sec)\n+{\n+  return sec->flags;\n+}\n+\n+static inline void *\n+bfd_section_userdata (const asection *sec)\n+{\n+  return sec->userdata;\n+}\n+static inline bfd_boolean\n+bfd_is_com_section (const asection *sec)\n+{\n+  return (sec->flags & SEC_IS_COMMON) != 0;\n+}\n+\n /* Note: the following are provided as inline functions rather than macros\n    because not all callers use the return value.  A macro implementation\n    would use a comma expression, eg: \"((ptr)->foo = val, TRUE)\" and some\n@@ -1738,105 +1760,39 @@ extern asection _bfd_std_section[4];\n /* Pointer to the indirect section.  */\n #define bfd_ind_section_ptr (&_bfd_std_section[3])\n \n-#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)\n-#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)\n-#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)\n+static inline bfd_boolean\n+bfd_is_und_section (const asection *sec)\n+{\n+  return sec == bfd_und_section_ptr;\n+}\n \n-#define bfd_is_const_section(SEC)              \\\n- (   ((SEC) == bfd_abs_section_ptr)            \\\n-  || ((SEC) == bfd_und_section_ptr)            \\\n-  || ((SEC) == bfd_com_section_ptr)            \\\n-  || ((SEC) == bfd_ind_section_ptr))\n+static inline bfd_boolean\n+bfd_is_abs_section (const asection *sec)\n+{\n+  return sec == bfd_abs_section_ptr;\n+}\n \n-/* Macros to handle insertion and deletion of a bfd's sections.  These\n-   only handle the list pointers, ie. do not adjust section_count,\n-   target_index etc.  */\n-#define bfd_section_list_remove(ABFD, S) \\\n-  do                                                   \\\n-    {                                                  \\\n-      asection *_s = S;                                \\\n-      asection *_next = _s->next;                      \\\n-      asection *_prev = _s->prev;                      \\\n-      if (_prev)                                       \\\n-        _prev->next = _next;                           \\\n-      else                                             \\\n-        (ABFD)->sections = _next;                      \\\n-      if (_next)                                       \\\n-        _next->prev = _prev;                           \\\n-      else                                             \\\n-        (ABFD)->section_last = _prev;                  \\\n-    }                                                  \\\n-  while (0)\n-#define bfd_section_list_append(ABFD, S) \\\n-  do                                                   \\\n-    {                                                  \\\n-      asection *_s = S;                                \\\n-      bfd *_abfd = ABFD;                               \\\n-      _s->next = NULL;                                 \\\n-      if (_abfd->section_last)                         \\\n-        {                                              \\\n-          _s->prev = _abfd->section_last;              \\\n-          _abfd->section_last->next = _s;              \\\n-        }                                              \\\n-      else                                             \\\n-        {                                              \\\n-          _s->prev = NULL;                             \\\n-          _abfd->sections = _s;                        \\\n-        }                                              \\\n-      _abfd->section_last = _s;                        \\\n-    }                                                  \\\n-  while (0)\n-#define bfd_section_list_prepend(ABFD, S) \\\n-  do                                                   \\\n-    {                                                  \\\n-      asection *_s = S;                                \\\n-      bfd *_abfd = ABFD;                               \\\n-      _s->prev = NULL;                                 \\\n-      if (_abfd->sections)                             \\\n-        {                                              \\\n-          _s->next = _abfd->sections;                  \\\n-          _abfd->sections->prev = _s;                  \\\n-        }                                              \\\n-      else                                             \\\n-        {                                              \\\n-          _s->next = NULL;                             \\\n-          _abfd->section_last = _s;                    \\\n-        }                                              \\\n-      _abfd->sections = _s;                            \\\n-    }                                                  \\\n-  while (0)\n-#define bfd_section_list_insert_after(ABFD, A, S) \\\n-  do                                                   \\\n-    {                                                  \\\n-      asection *_a = A;                                \\\n-      asection *_s = S;                                \\\n-      asection *_next = _a->next;                      \\\n-      _s->next = _next;                                \\\n-      _s->prev = _a;                                   \\\n-      _a->next = _s;                                   \\\n-      if (_next)                                       \\\n-        _next->prev = _s;                              \\\n-      else                                             \\\n-        (ABFD)->section_last = _s;                     \\\n-    }                                                  \\\n-  while (0)\n-#define bfd_section_list_insert_before(ABFD, B, S) \\\n-  do                                                   \\\n-    {                                                  \\\n-      asection *_b = B;                                \\\n-      asection *_s = S;                                \\\n-      asection *_prev = _b->prev;                      \\\n-      _s->prev = _prev;                                \\\n-      _s->next = _b;                                   \\\n-      _b->prev = _s;                                   \\\n-      if (_prev)                                       \\\n-        _prev->next = _s;                              \\\n-      else                                             \\\n-        (ABFD)->sections = _s;                         \\\n-    }                                                  \\\n-  while (0)\n-#define bfd_section_removed_from_list(ABFD, S) \\\n-  ((S)->next == NULL ? (ABFD)->section_last != (S) : (S)->next->prev != (S))\n+static inline bfd_boolean\n+bfd_is_ind_section (const asection *sec)\n+{\n+  return sec == bfd_ind_section_ptr;\n+}\n+\n+static inline bfd_boolean\n+bfd_is_const_section (const asection *sec)\n+{\n+  return sec >= bfd_abs_section_ptr && sec <= bfd_ind_section_ptr;\n+}\n+\n+/* Return TRUE if input section SEC has been discarded.  */\n+static inline bfd_boolean\n+discarded_section (const asection *sec)\n+{\n+  return (!bfd_is_abs_section (sec)\n+          && bfd_is_abs_section (sec->output_section)\n+          && sec->sec_info_type != SEC_INFO_TYPE_MERGE\n+          && sec->sec_info_type != SEC_INFO_TYPE_JUST_SYMS);\n+}\n \n #define BFD_FAKE_SECTION(SEC, SYM, NAME, IDX, FLAGS)                   \\\n   /* name, id,  index, next, prev, flags, user_set_vma,            */  \\\n@@ -7398,6 +7354,105 @@ bfd_set_asymbol_name (asymbol *sy, const char *name)\n   sy->name = name;\n }\n \n+static inline bfd_size_type\n+bfd_get_section_limit_octets (const bfd *abfd, const asection *sec)\n+{\n+  if (abfd->direction != write_direction && sec->rawsize != 0)\n+    return sec->rawsize;\n+  return sec->size;\n+}\n+\n+/* Find the address one past the end of SEC.  */\n+static inline bfd_size_type\n+bfd_get_section_limit (const bfd *abfd, const asection *sec)\n+{\n+  return bfd_get_section_limit_octets (abfd, sec) / bfd_octets_per_byte (abfd);\n+}\n+\n+/* Functions to handle insertion and deletion of a bfd's sections.  These\n+   only handle the list pointers, ie. do not adjust section_count,\n+   target_index etc.  */\n+static inline void\n+bfd_section_list_remove (bfd *abfd, asection *s)\n+{\n+  asection *next = s->next;\n+  asection *prev = s->prev;\n+  if (prev)\n+    prev->next = next;\n+  else\n+    abfd->sections = next;\n+  if (next)\n+    next->prev = prev;\n+  else\n+    abfd->section_last = prev;\n+}\n+\n+static inline void\n+bfd_section_list_append (bfd *abfd, asection *s)\n+{\n+  s->next = 0;\n+  if (abfd->section_last)\n+    {\n+      s->prev = abfd->section_last;\n+      abfd->section_last->next = s;\n+    }\n+  else\n+    {\n+      s->prev = 0;\n+      abfd->sections = s;\n+    }\n+  abfd->section_last = s;\n+}\n+\n+static inline void\n+bfd_section_list_prepend (bfd *abfd, asection *s)\n+{\n+  s->prev = 0;\n+  if (abfd->sections)\n+    {\n+      s->next = abfd->sections;\n+      abfd->sections->prev = s;\n+    }\n+  else\n+    {\n+      s->next = 0;\n+      abfd->section_last = s;\n+    }\n+  abfd->sections = s;\n+}\n+\n+static inline void\n+bfd_section_list_insert_after (bfd *abfd, asection *a, asection *s)\n+{\n+  asection *next = a->next;\n+  s->next = next;\n+  s->prev = a;\n+  a->next = s;\n+  if (next)\n+    next->prev = s;\n+  else\n+    abfd->section_last = s;\n+}\n+\n+static inline void\n+bfd_section_list_insert_before (bfd *abfd, asection *b, asection *s)\n+{\n+  asection *prev = b->prev;\n+  s->prev = prev;\n+  s->next = b;\n+  b->prev = s;\n+  if (prev)\n+    prev->next = s;\n+  else\n+    abfd->sections = s;\n+}\n+\n+static inline bfd_boolean\n+bfd_section_removed_from_list (const bfd *abfd, const asection *s)\n+{\n+  return s->next ? s->next->prev != s : abfd->section_last != s;\n+}\n+\n \n typedef enum bfd_error\n {"
    },
    {
      "sha": "af2c192260d4b776995b8128ac9a195c530c1c8c",
      "filename": "bfd/bfd.c",
      "status": "modified",
      "additions": 99,
      "deletions": 0,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd.c?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -477,6 +477,105 @@ CODE_FRAGMENT\n .  sy->name = name;\n .}\n .\n+.static inline bfd_size_type\n+.bfd_get_section_limit_octets (const bfd *abfd, const asection *sec)\n+.{\n+.  if (abfd->direction != write_direction && sec->rawsize != 0)\n+.    return sec->rawsize;\n+.  return sec->size;\n+.}\n+.\n+.{* Find the address one past the end of SEC.  *}\n+.static inline bfd_size_type\n+.bfd_get_section_limit (const bfd *abfd, const asection *sec)\n+.{\n+.  return bfd_get_section_limit_octets (abfd, sec) / bfd_octets_per_byte (abfd);\n+.}\n+.\n+.{* Functions to handle insertion and deletion of a bfd's sections.  These\n+.   only handle the list pointers, ie. do not adjust section_count,\n+.   target_index etc.  *}\n+.static inline void\n+.bfd_section_list_remove (bfd *abfd, asection *s)\n+.{\n+.  asection *next = s->next;\n+.  asection *prev = s->prev;\n+.  if (prev)\n+.    prev->next = next;\n+.  else\n+.    abfd->sections = next;\n+.  if (next)\n+.    next->prev = prev;\n+.  else\n+.    abfd->section_last = prev;\n+.}\n+.\n+.static inline void\n+.bfd_section_list_append (bfd *abfd, asection *s)\n+.{\n+.  s->next = 0;\n+.  if (abfd->section_last)\n+.    {\n+.      s->prev = abfd->section_last;\n+.      abfd->section_last->next = s;\n+.    }\n+.  else\n+.    {\n+.      s->prev = 0;\n+.      abfd->sections = s;\n+.    }\n+.  abfd->section_last = s;\n+.}\n+.\n+.static inline void\n+.bfd_section_list_prepend (bfd *abfd, asection *s)\n+.{\n+.  s->prev = 0;\n+.  if (abfd->sections)\n+.    {\n+.      s->next = abfd->sections;\n+.      abfd->sections->prev = s;\n+.    }\n+.  else\n+.    {\n+.      s->next = 0;\n+.      abfd->section_last = s;\n+.    }\n+.  abfd->sections = s;\n+.}\n+.\n+.static inline void\n+.bfd_section_list_insert_after (bfd *abfd, asection *a, asection *s)\n+.{\n+.  asection *next = a->next;\n+.  s->next = next;\n+.  s->prev = a;\n+.  a->next = s;\n+.  if (next)\n+.    next->prev = s;\n+.  else\n+.    abfd->section_last = s;\n+.}\n+.\n+.static inline void\n+.bfd_section_list_insert_before (bfd *abfd, asection *b, asection *s)\n+.{\n+.  asection *prev = b->prev;\n+.  s->prev = prev;\n+.  s->next = b;\n+.  b->prev = s;\n+.  if (prev)\n+.    prev->next = s;\n+.  else\n+.    abfd->sections = s;\n+.}\n+.\n+.static inline bfd_boolean\n+.bfd_section_removed_from_list (const bfd *abfd, const asection *s)\n+.{\n+.  return s->next ? s->next->prev != s : abfd->section_last != s;\n+.}\n+.\n */\n \n #include \"sysdep.h\""
    },
    {
      "sha": "34e08aef57eb9e02559100bb324d7df410b55923",
      "filename": "bfd/section.c",
      "status": "modified",
      "additions": 80,
      "deletions": 99,
      "changes": 179,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/section.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/bfd/section.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/section.c?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -549,6 +549,53 @@ CODE_FRAGMENT\n .  int size;\n .};\n .\n+.static inline const char *\n+.bfd_section_name (const asection *sec)\n+.{\n+.  return sec->name;\n+.}\n+.\n+.static inline bfd_size_type\n+.bfd_section_size (const asection *sec)\n+.{\n+.  return sec->size;\n+.}\n+.\n+.static inline bfd_vma\n+.bfd_section_vma (const asection *sec)\n+.{\n+.  return sec->vma;\n+.}\n+.\n+.static inline bfd_vma\n+.bfd_section_lma (const asection *sec)\n+.{\n+.  return sec->lma;\n+.}\n+.\n+.static inline unsigned int\n+.bfd_section_alignment (const asection *sec)\n+.{\n+.  return sec->alignment_power;\n+.}\n+.\n+.static inline flagword\n+.bfd_section_flags (const asection *sec)\n+.{\n+.  return sec->flags;\n+.}\n+.\n+.static inline void *\n+.bfd_section_userdata (const asection *sec)\n+.{\n+.  return sec->userdata;\n+.}\n+.static inline bfd_boolean\n+.bfd_is_com_section (const asection *sec)\n+.{\n+.  return (sec->flags & SEC_IS_COMMON) != 0;\n+.}\n+.\n .{* Note: the following are provided as inline functions rather than macros\n .   because not all callers use the return value.  A macro implementation\n .   would use a comma expression, eg: \"((ptr)->foo = val, TRUE)\" and some\n@@ -601,105 +648,39 @@ CODE_FRAGMENT\n .{* Pointer to the indirect section.  *}\n .#define bfd_ind_section_ptr (&_bfd_std_section[3])\n .\n-.#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)\n-.#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)\n-.#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)\n-.\n-.#define bfd_is_const_section(SEC)\t\t\\\n-. (   ((SEC) == bfd_abs_section_ptr)\t\t\\\n-.  || ((SEC) == bfd_und_section_ptr)\t\t\\\n-.  || ((SEC) == bfd_com_section_ptr)\t\t\\\n-.  || ((SEC) == bfd_ind_section_ptr))\n-.\n-.{* Macros to handle insertion and deletion of a bfd's sections.  These\n-.   only handle the list pointers, ie. do not adjust section_count,\n-.   target_index etc.  *}\n-.#define bfd_section_list_remove(ABFD, S) \\\n-.  do\t\t\t\t\t\t\t\\\n-.    {\t\t\t\t\t\t\t\\\n-.      asection *_s = S;\t\t\t\t\\\n-.      asection *_next = _s->next;\t\t\t\\\n-.      asection *_prev = _s->prev;\t\t\t\\\n-.      if (_prev)\t\t\t\t\t\\\n-.        _prev->next = _next;\t\t\t\t\\\n-.      else\t\t\t\t\t\t\\\n-.        (ABFD)->sections = _next;\t\t\t\\\n-.      if (_next)\t\t\t\t\t\\\n-.        _next->prev = _prev;\t\t\t\t\\\n-.      else\t\t\t\t\t\t\\\n-.        (ABFD)->section_last = _prev;\t\t\t\\\n-.    }\t\t\t\t\t\t\t\\\n-.  while (0)\n-.#define bfd_section_list_append(ABFD, S) \\\n-.  do\t\t\t\t\t\t\t\\\n-.    {\t\t\t\t\t\t\t\\\n-.      asection *_s = S;\t\t\t\t\\\n-.      bfd *_abfd = ABFD;\t\t\t\t\\\n-.      _s->next = NULL;\t\t\t\t\t\\\n-.      if (_abfd->section_last)\t\t\t\t\\\n-.        {\t\t\t\t\t\t\\\n-.          _s->prev = _abfd->section_last;\t\t\\\n-.          _abfd->section_last->next = _s;\t\t\\\n-.        }\t\t\t\t\t\t\\\n-.      else\t\t\t\t\t\t\\\n-.        {\t\t\t\t\t\t\\\n-.          _s->prev = NULL;\t\t\t\t\\\n-.          _abfd->sections = _s;\t\t\t\\\n-.        }\t\t\t\t\t\t\\\n-.      _abfd->section_last = _s;\t\t\t\\\n-.    }\t\t\t\t\t\t\t\\\n-.  while (0)\n-.#define bfd_section_list_prepend(ABFD, S) \\\n-.  do\t\t\t\t\t\t\t\\\n-.    {\t\t\t\t\t\t\t\\\n-.      asection *_s = S;\t\t\t\t\\\n-.      bfd *_abfd = ABFD;\t\t\t\t\\\n-.      _s->prev = NULL;\t\t\t\t\t\\\n-.      if (_abfd->sections)\t\t\t\t\\\n-.        {\t\t\t\t\t\t\\\n-.          _s->next = _abfd->sections;\t\t\t\\\n-.          _abfd->sections->prev = _s;\t\t\t\\\n-.        }\t\t\t\t\t\t\\\n-.      else\t\t\t\t\t\t\\\n-.        {\t\t\t\t\t\t\\\n-.          _s->next = NULL;\t\t\t\t\\\n-.          _abfd->section_last = _s;\t\t\t\\\n-.        }\t\t\t\t\t\t\\\n-.      _abfd->sections = _s;\t\t\t\t\\\n-.    }\t\t\t\t\t\t\t\\\n-.  while (0)\n-.#define bfd_section_list_insert_after(ABFD, A, S) \\\n-.  do\t\t\t\t\t\t\t\\\n-.    {\t\t\t\t\t\t\t\\\n-.      asection *_a = A;\t\t\t\t\\\n-.      asection *_s = S;\t\t\t\t\\\n-.      asection *_next = _a->next;\t\t\t\\\n-.      _s->next = _next;\t\t\t\t\\\n-.      _s->prev = _a;\t\t\t\t\t\\\n-.      _a->next = _s;\t\t\t\t\t\\\n-.      if (_next)\t\t\t\t\t\\\n-.        _next->prev = _s;\t\t\t\t\\\n-.      else\t\t\t\t\t\t\\\n-.        (ABFD)->section_last = _s;\t\t\t\\\n-.    }\t\t\t\t\t\t\t\\\n-.  while (0)\n-.#define bfd_section_list_insert_before(ABFD, B, S) \\\n-.  do\t\t\t\t\t\t\t\\\n-.    {\t\t\t\t\t\t\t\\\n-.      asection *_b = B;\t\t\t\t\\\n-.      asection *_s = S;\t\t\t\t\\\n-.      asection *_prev = _b->prev;\t\t\t\\\n-.      _s->prev = _prev;\t\t\t\t\\\n-.      _s->next = _b;\t\t\t\t\t\\\n-.      _b->prev = _s;\t\t\t\t\t\\\n-.      if (_prev)\t\t\t\t\t\\\n-.        _prev->next = _s;\t\t\t\t\\\n-.      else\t\t\t\t\t\t\\\n-.        (ABFD)->sections = _s;\t\t\t\t\\\n-.    }\t\t\t\t\t\t\t\\\n-.  while (0)\n-.#define bfd_section_removed_from_list(ABFD, S) \\\n-.  ((S)->next == NULL ? (ABFD)->section_last != (S) : (S)->next->prev != (S))\n+.static inline bfd_boolean\n+.bfd_is_und_section (const asection *sec)\n+.{\n+.  return sec == bfd_und_section_ptr;\n+.}\n+.\n+.static inline bfd_boolean\n+.bfd_is_abs_section (const asection *sec)\n+.{\n+.  return sec == bfd_abs_section_ptr;\n+.}\n+.\n+.static inline bfd_boolean\n+.bfd_is_ind_section (const asection *sec)\n+.{\n+.  return sec == bfd_ind_section_ptr;\n+.}\n+.\n+.static inline bfd_boolean\n+.bfd_is_const_section (const asection *sec)\n+.{\n+.  return sec >= bfd_abs_section_ptr && sec <= bfd_ind_section_ptr;\n+.}\n+.\n+.{* Return TRUE if input section SEC has been discarded.  *}\n+.static inline bfd_boolean\n+.discarded_section (const asection *sec)\n+.{\n+.  return (!bfd_is_abs_section (sec)\n+.          && bfd_is_abs_section (sec->output_section)\n+.          && sec->sec_info_type != SEC_INFO_TYPE_MERGE\n+.          && sec->sec_info_type != SEC_INFO_TYPE_JUST_SYMS);\n+.}\n .\n .#define BFD_FAKE_SECTION(SEC, SYM, NAME, IDX, FLAGS)\t\t\t\\\n .  {* name, id,  index, next, prev, flags, user_set_vma,            *}\t\\"
    },
    {
      "sha": "482ab08c2969f694d2f10ba584f63ab0017968a7",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -1,3 +1,7 @@\n+2019-09-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/tc-tic6x.c (tc_gen_reloc): Correct common symbol check.\n+\n 2018-09-20  Jan Beulich  <jbeulich@suse.com>\n \n \tPR gas/25012"
    },
    {
      "sha": "cd12c82dce164c01d60922115f5dfc1ef13dd0dd",
      "filename": "gas/config/tc-tic6x.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/gas/config/tc-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/gas/config/tc-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic6x.c?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -4526,7 +4526,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)\n   if (reloc->howto->pcrel_offset && reloc->howto->partial_inplace)\n     {\n       reloc->addend += reloc->address;\n-      if (!bfd_is_com_section (symbol))\n+      if (!bfd_is_com_section (bfd_asymbol_section (symbol)))\n \treloc->addend -= symbol->value;\n     }\n   if (r_type == BFD_RELOC_C6000_PCR_H16"
    },
    {
      "sha": "3f62dad9cceaabb00c56965ea07410a221560bbd",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -1,3 +1,14 @@\n+2019-09-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* emultempl/xtensaelf.em (xtensa_get_section_deps): Comment.\n+\tUse bfd_section_userdata.\n+\t(xtensa_set_section_deps): Use bfd_set_section_userdata.\n+\t* ldlang.c (lang_output_section_get): Use bfd_section_userdata.\n+\t(sort_def_symbol): Likewise, and bfd_set_section_userdata.\n+\t(init_os): Use bfd_set_section_userdata.\n+\t(print_all_symbols): Use bfd_section_userdata.\n+\t* ldlang.h (get_userdata): Delete.\n+\n 2019-09-20  Alan Modra  <amodra@gmail.com>\n \n \t* ldelf.c (ldelf_after_open, ldelf_place_orphan"
    },
    {
      "sha": "0b11fdcd6988c7b0b90c3c5295e41c1b56b8794d",
      "filename": "ld/emultempl/xtensaelf.em",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/ld/emultempl/xtensaelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/ld/emultempl/xtensaelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/xtensaelf.em?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -596,8 +596,12 @@ xtensa_get_section_deps (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,\n   /* We have a separate function for this so that\n      we could in the future keep a completely independent\n      structure that maps a section to its dependence edges.\n-     For now, we place these in the sec->userdata field.  */\n-  reloc_deps_section *sec_deps = sec->userdata;\n+     For now, we place these in the sec->userdata field.\n+     This doesn't clash with ldlang.c use of userdata for output\n+     sections, and during map output for input sections, since the\n+     xtensa use is only for input sections and only extant in\n+     before_allocation.  */\n+  reloc_deps_section *sec_deps = bfd_section_userdata (sec);\n   return sec_deps;\n }\n \n@@ -606,7 +610,7 @@ xtensa_set_section_deps (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,\n \t\t\t asection *sec,\n \t\t\t reloc_deps_section *deps_section)\n {\n-  sec->userdata = deps_section;\n+  bfd_set_section_userdata (sec, deps_section);\n }\n \n "
    },
    {
      "sha": "1a49f69d90800c6f9f54dc834b0aabf83db6dae1",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -1414,7 +1414,7 @@ lang_memory_default (asection *section)\n lang_output_section_statement_type *\n lang_output_section_get (const asection *output_section)\n {\n-  return get_userdata (output_section);\n+  return bfd_section_userdata (output_section);\n }\n \n /* Find or create an output_section_statement with the given NAME.\n@@ -2316,12 +2316,11 @@ sort_def_symbol (struct bfd_link_hash_entry *hash_entry,\n       input_section_userdata_type *ud;\n       struct map_symbol_def *def;\n \n-      ud = ((input_section_userdata_type *)\n-\t    get_userdata (hash_entry->u.def.section));\n+      ud = bfd_section_userdata (hash_entry->u.def.section);\n       if (!ud)\n \t{\n \t  ud = stat_alloc (sizeof (*ud));\n-\t  get_userdata (hash_entry->u.def.section) = ud;\n+\t  bfd_set_section_userdata (hash_entry->u.def.section, ud);\n \t  ud->map_symbol_def_tail = &ud->map_symbol_def_head;\n \t  ud->map_symbol_def_count = 0;\n \t}\n@@ -2361,7 +2360,7 @@ init_os (lang_output_section_statement_type *s, flagword flags)\n \n   /* Set the userdata of the output section to the output section\n      statement to avoid lookup.  */\n-  get_userdata (s->bfd_section) = s;\n+  bfd_set_section_userdata (s->bfd_section, s);\n \n   /* If there is a base address, make sure that any sections it might\n      mention are initialized.  */\n@@ -4390,8 +4389,7 @@ hash_entry_addr_cmp (const void *a, const void *b)\n static void\n print_all_symbols (asection *sec)\n {\n-  input_section_userdata_type *ud\n-    = (input_section_userdata_type *) get_userdata (sec);\n+  input_section_userdata_type *ud = bfd_section_userdata (sec);\n   struct map_symbol_def *def;\n   struct bfd_link_hash_entry **entries;\n   unsigned int i;"
    },
    {
      "sha": "5ab62e327929b94ff762a147a1bf47dc242769d1",
      "filename": "ld/ldlang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a48931cc2df9f87596d93b319236c73ef0fe0f4e/ld/ldlang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a48931cc2df9f87596d93b319236c73ef0fe0f4e/ld/ldlang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.h?ref=a48931cc2df9f87596d93b319236c73ef0fe0f4e",
      "patch": "@@ -329,8 +329,6 @@ typedef struct input_section_userdata_struct\n   unsigned long map_symbol_def_count;\n } input_section_userdata_type;\n \n-#define get_userdata(x) ((x)->userdata)\n-\n static inline bfd_boolean\n bfd_input_just_syms (const bfd *abfd)\n {"
    }
  ]
}