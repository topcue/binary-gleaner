{
  "sha": "5014c2d22b2627eb1ac88a4763a58d431fe064a7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTAxNGMyZDIyYjI2MjdlYjFhYzg4YTQ3NjNhNThkNDMxZmUwNjRhNw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-20T06:06:46Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-21T09:09:54Z"
    },
    "message": "Redo gas local symbol support\n\ngas handles local symbols specially in order to save memory, but the\nimplementation using two separate hash tables is inefficient,\nparticularly the scheme of duplicating a struct local_symbol when it\nneeds to be converted to a full struct symbol.  Also, updating symbol\npointers with LOCAL_SYMBOL_CHECK is horrible and has led to some hard\nto find bugs.\n\nThis changes the implementation to use a single hash table and avoids\nanother copy of the symbol name in symbol_entry_t.  When converting\nlocal symbols the struct local_symbol memory is reused.  Not only\ndoes that save memory, but there is no need to twiddle symbol pointers\nwith LOCAL_SYMBOL_CHECK.\n\nAssembling gcc-10 -g -Og gold/powerpc.cc output shows the following:\n\nold:\nsymbol table hash statistics:\n\t1371192 searches\n\t1290398 collisions\n\t143585 elements\n\t262139 table size\nmini local symbol table hash statistics:\n\t2966204 searches\n\t2707489 collisions\n\t523533 elements\n\t1048573 table size\n523533 mini local symbols created, 140453 converted\n\nnew:\nsymbol table hash statistics:\n\t2828883 searches\n\t2453138 collisions\n\t526665 elements\n\t1048573 table size\n523533 mini local symbols created, 140453 converted\n\n\t* symbols.c (struct local_symbol): Add \"hash\" entry.  Reorder fields.\n\tDelete union.  Adjust code throughout file.\n\t(struct symbol): Add \"hash\", \"name\" and \"x\" entries.  Reorder fields.\n\tSplit off some to..\n\t(struct xsymbol): ..this.  New struct.  Adjust code throughout file\n\taccessing these fields.\n\t(struct symbol_entry): Delete.\n\t(union symbol_entry): New.\n\t(hash_symbol_entry): Adjust for symbol_entry_t change.\n\t(symbol_entry_find): Likewise.\n\t(eq_symbol_entry): Compare hash values too.\n\t(symbol_entry_alloc): Delete.\n\t(local_symbol_converted_p, local_symbol_mark_converted): Delete.\n\t(local_symbol_get_real_symbol, local_symbol_set_real_symbol): Delete.\n\t(local_hash): Delete.\n\t(abs_symbol_x, dot_symbol_x): New static var.\n\t(symbol_init): New function.\n\t(symbol_create): Rewrite.\n\t(LOCAL_SYMBOL_CHECK): Delete.  Replace uses throughout with simple\n\ttest of flags.local_symbol.\n\t(local_symbol_make): Adjust for struct local_symbol changes.\n\t(local_symbol_convert): Rewrite.  Adjust all callers.\n\t(symbol_table_insert): Simplify.\n\t(symbol_clone): Comment on local sym cloning.  Handle split symbol\n\tstruct.\n\t(get_real_sym): Delete.  Remove all uses.\n\t(symbol_find_exact_noref): Simplify.\n\t(resolve_local_symbol): Don't resolve non-locals.\n\t(S_SET_SEGMENT): Don't special case reg_section.\n\t(S_SET_NAME): Set both name and bsym->name.\n\t(symbol_mark_resolved, symbol_resolved_p): Simplify.\n\t(symbol_symbolS): Update comment.\n\t(symbol_begin): Don't create local_hash.  Adjust abs_symbol setup.\n\t(dot_symbol_init): Adjust dot_symbol setup.\n\t(symbol_print_statistics): Delete local_hash stats.",
    "tree": {
      "sha": "a2bc2b7bf9565f4f6826af556162a606966eb7a9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a2bc2b7bf9565f4f6826af556162a606966eb7a9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5014c2d22b2627eb1ac88a4763a58d431fe064a7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5014c2d22b2627eb1ac88a4763a58d431fe064a7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5014c2d22b2627eb1ac88a4763a58d431fe064a7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5014c2d22b2627eb1ac88a4763a58d431fe064a7/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef"
    }
  ],
  "stats": {
    "total": 774,
    "additions": 375,
    "deletions": 399
  },
  "files": [
    {
      "sha": "1155727c02eb0108945e04b286f6b7d3b37b994d",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5014c2d22b2627eb1ac88a4763a58d431fe064a7/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5014c2d22b2627eb1ac88a4763a58d431fe064a7/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=5014c2d22b2627eb1ac88a4763a58d431fe064a7",
      "patch": "@@ -1,3 +1,41 @@\n+2020-08-21  Alan Modra  <amodra@gmail.com>\n+\n+\t* symbols.c (struct local_symbol): Add \"hash\" entry.  Reorder fields.\n+\tDelete union.  Adjust code throughout file.\n+\t(struct symbol): Add \"hash\", \"name\" and \"x\" entries.  Reorder fields.\n+\tSplit off some to..\n+\t(struct xsymbol): ..this.  New struct.  Adjust code throughout file\n+\taccessing these fields.\n+\t(struct symbol_entry): Delete.\n+\t(union symbol_entry): New.\n+\t(hash_symbol_entry): Adjust for symbol_entry_t change.\n+\t(symbol_entry_find): Likewise.\n+\t(eq_symbol_entry): Compare hash values too.\n+\t(symbol_entry_alloc): Delete.\n+\t(local_symbol_converted_p, local_symbol_mark_converted): Delete.\n+\t(local_symbol_get_real_symbol, local_symbol_set_real_symbol): Delete.\n+\t(local_hash): Delete.\n+\t(abs_symbol_x, dot_symbol_x): New static var.\n+\t(symbol_init): New function.\n+\t(symbol_create): Rewrite.\n+\t(LOCAL_SYMBOL_CHECK): Delete.  Replace uses throughout with simple\n+\ttest of flags.local_symbol.\n+\t(local_symbol_make): Adjust for struct local_symbol changes.\n+\t(local_symbol_convert): Rewrite.  Adjust all callers.\n+\t(symbol_table_insert): Simplify.\n+\t(symbol_clone): Comment on local sym cloning.  Handle split symbol\n+\tstruct.\n+\t(get_real_sym): Delete.  Remove all uses.\n+\t(symbol_find_exact_noref): Simplify.\n+\t(resolve_local_symbol): Don't resolve non-locals.\n+\t(S_SET_SEGMENT): Don't special case reg_section.\n+\t(S_SET_NAME): Set both name and bsym->name.\n+\t(symbol_mark_resolved, symbol_resolved_p): Simplify.\n+\t(symbol_symbolS): Update comment.\n+\t(symbol_begin): Don't create local_hash.  Adjust abs_symbol setup.\n+\t(dot_symbol_init): Adjust dot_symbol setup.\n+\t(symbol_print_statistics): Delete local_hash stats.\n+\n 2020-08-21  Alan Modra  <amodra@gmail.com>\n \n \t* symbols.c (struct symbol_flags): Rename sy_volatile to volatil,"
    },
    {
      "sha": "e823726f54d3a786a45639713711dd431a52a8e2",
      "filename": "gas/symbols.c",
      "status": "modified",
      "additions": 337,
      "deletions": 399,
      "changes": 736,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5014c2d22b2627eb1ac88a4763a58d431fe064a7/gas/symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5014c2d22b2627eb1ac88a4763a58d431fe064a7/gas/symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/symbols.c?ref=5014c2d22b2627eb1ac88a4763a58d431fe064a7",
      "patch": "@@ -91,48 +91,61 @@ struct local_symbol\n   /* Symbol flags.  Only local_symbol and resolved are relevant.  */\n   struct symbol_flags flags;\n \n-  /* The symbol section.  This also serves as a flag.  If this is\n-     reg_section, then this symbol has been converted into a regular\n-     symbol, and sym points to it.  */\n-  segT section;\n+  /* Hash value calculated from name.  */\n+  hashval_t hash;\n \n   /* The symbol name.  */\n   const char *name;\n \n-  /* The symbol frag or the real symbol, depending upon the value in\n-     section.  */\n-  union\n-  {\n-    fragS *frag;\n-    symbolS *sym;\n-  } u;\n+  /* The symbol frag.  */\n+  fragS *frag;\n+\n+  /* The symbol section.  */\n+  asection *section;\n \n   /* The value of the symbol.  */\n   valueT value;\n };\n \n-/* The information we keep for a symbol.  Note that the symbol table\n-   holds pointers both to this and to local_symbol structures.  */\n+/* The information we keep for a symbol.  The symbol table holds\n+   pointers both to this and to local_symbol structures.  The first\n+   three fields must be identical to struct local_symbol, and the size\n+   should be the same as or smaller than struct local_symbol.\n+   Fields that don't fit go to an extension structure.  */\n \n struct symbol\n {\n   /* Symbol flags.  */\n   struct symbol_flags flags;\n \n+  /* Hash value calculated from name.  */\n+  hashval_t hash;\n+\n+  /* The symbol name.  */\n+  const char *name;\n+\n+  /* Pointer to the frag this symbol is attached to, if any.\n+     Otherwise, NULL.  */\n+  fragS *frag;\n+\n   /* BFD symbol */\n   asymbol *bsym;\n \n+  /* Extra symbol fields that won't fit.  */\n+  struct xsymbol *x;\n+};\n+\n+/* Extra fields to make up a full symbol.  */\n+\n+struct xsymbol\n+{\n   /* The value of the symbol.  */\n   expressionS value;\n \n   /* Forwards and backwards chain pointers.  */\n   struct symbol *next;\n   struct symbol *previous;\n \n-  /* Pointer to the frag this symbol is attached to, if any.\n-     Otherwise, NULL.  */\n-  struct frag *frag;\n-\n #ifdef OBJ_SYMFIELD_TYPE\n   OBJ_SYMFIELD_TYPE obj;\n #endif\n@@ -142,25 +155,22 @@ struct symbol\n #endif\n };\n \n-struct symbol_entry\n+typedef union symbol_entry\n {\n-  const char *symbol_name;\n-  hashval_t hash;\n-  void *symbol;\n-};\n-\n-typedef struct symbol_entry symbol_entry_t;\n+  struct local_symbol lsy;\n+  struct symbol sy;\n+} symbol_entry_t;\n \n /* Hash function for a symbol_entry.  */\n \n static hashval_t\n hash_symbol_entry (const void *e)\n {\n   symbol_entry_t *entry = (symbol_entry_t *) e;\n-  if (entry->hash == 0)\n-    entry->hash = htab_hash_string (entry->symbol_name);\n+  if (entry->sy.hash == 0)\n+    entry->sy.hash = htab_hash_string (entry->sy.name);\n \n-  return entry->hash;\n+  return entry->sy.hash;\n }\n \n /* Equality function for a symbol_entry.  */\n@@ -171,33 +181,19 @@ eq_symbol_entry (const void *a, const void *b)\n   const symbol_entry_t *ea = (const symbol_entry_t *) a;\n   const symbol_entry_t *eb = (const symbol_entry_t *) b;\n \n-  return strcmp (ea->symbol_name, eb->symbol_name) == 0;\n-}\n-\n-static symbol_entry_t *\n-symbol_entry_alloc (const char *symbol_name, void *symbol)\n-{\n-  symbol_entry_t *entry = XNEW (symbol_entry_t);\n-  entry->symbol_name = symbol_name;\n-  entry->hash = 0;\n-  entry->symbol = symbol;\n-  return entry;\n+  return (ea->sy.hash == eb->sy.hash\n+\t  && strcmp (ea->sy.name, eb->sy.name) == 0);\n }\n \n static void *\n-symbol_entry_find (htab_t table, const char *symbol_name)\n+symbol_entry_find (htab_t table, const char *name)\n {\n-  symbol_entry_t needle = { symbol_name, 0, NULL };\n-  symbol_entry_t *entry = htab_find (table, &needle);\n-  return entry != NULL ? entry->symbol : NULL;\n+  hashval_t hash = htab_hash_string (name);\n+  symbol_entry_t needle = { { { 0 }, hash, name, 0, 0, 0 } };\n+  return htab_find_with_hash (table, &needle, hash);\n }\n \n \n-#define local_symbol_converted_p(l) ((l)->section == reg_section)\n-#define local_symbol_mark_converted(l) ((l)->section = reg_section)\n-#define local_symbol_get_real_symbol(l) ((l)->u.sym)\n-#define local_symbol_set_real_symbol(l, s) ((l)->u.sym = (s))\n-\n /* This is non-zero if symbols are case sensitive, which is the\n    default.  */\n int symbols_case_sensitive = 1;\n@@ -206,17 +202,15 @@ int symbols_case_sensitive = 1;\n extern int new_broken_words;\n #endif\n \n-/* symbol-name => struct symbol pointer */\n static htab_t sy_hash;\n \n-/* Table of local symbols.  */\n-static htab_t local_hash;\n-\n /* Below are commented in \"symbols.h\".  */\n symbolS *symbol_rootP;\n symbolS *symbol_lastP;\n symbolS abs_symbol;\n+struct xsymbol abs_symbol_x;\n symbolS dot_symbol;\n+struct xsymbol dot_symbol_x;\n \n #ifdef DEBUG_SYMS\n #define debug_verify_symchain verify_symbol_chain\n@@ -294,37 +288,48 @@ save_symbol_name (const char *name)\n   return ret;\n }\n \n-/* Create a symbol.  NAME is copied, the caller can destroy/modify.  */\n-\n-symbolS *\n-symbol_create (const char *name, segT segment, fragS *frag, valueT valu)\n+static void\n+symbol_init (symbolS *symbolP, const char *name, asection *sec,\n+\t     fragS *frag, valueT valu)\n {\n-  const char *preserved_copy_of_name;\n-  symbolS *symbolP;\n-\n-  preserved_copy_of_name = save_symbol_name (name);\n-\n-  symbolP = (symbolS *) obstack_alloc (&notes, sizeof (symbolS));\n-\n-  /* symbol must be born in some fixed state.  This seems as good as any.  */\n-  memset (symbolP, 0, sizeof (symbolS));\n-\n+  symbolP->frag = frag;\n   symbolP->bsym = bfd_make_empty_symbol (stdoutput);\n   if (symbolP->bsym == NULL)\n     as_fatal (\"bfd_make_empty_symbol: %s\", bfd_errmsg (bfd_get_error ()));\n-  S_SET_NAME (symbolP, preserved_copy_of_name);\n+  symbolP->bsym->name = name;\n+  symbolP->bsym->section = sec;\n \n-  S_SET_SEGMENT (symbolP, segment);\n   S_SET_VALUE (symbolP, valu);\n-  symbol_clear_list_pointers (symbolP);\n \n-  symbolP->frag = frag;\n+  symbol_clear_list_pointers (symbolP);\n \n   obj_symbol_new_hook (symbolP);\n \n #ifdef tc_symbol_new_hook\n   tc_symbol_new_hook (symbolP);\n #endif\n+}\n+\n+/* Create a symbol.  NAME is copied, the caller can destroy/modify.  */\n+\n+symbolS *\n+symbol_create (const char *name, segT segment, fragS *frag, valueT valu)\n+{\n+  const char *preserved_copy_of_name;\n+  symbolS *symbolP;\n+  size_t size;\n+\n+  preserved_copy_of_name = save_symbol_name (name);\n+\n+  size = sizeof (symbolS) + sizeof (struct xsymbol);\n+  symbolP = (symbolS *) obstack_alloc (&notes, size);\n+\n+  /* symbol must be born in some fixed state.  This seems as good as any.  */\n+  memset (symbolP, 0, size);\n+  symbolP->name = preserved_copy_of_name;\n+  symbolP->x = (struct xsymbol *) (symbolP + 1);\n+\n+  symbol_init (symbolP, preserved_copy_of_name, segment, frag, valu);\n \n   return symbolP;\n }\n@@ -333,25 +338,11 @@ symbol_create (const char *name, segT segment, fragS *frag, valueT valu)\n /* Local symbol support.  If we can get away with it, we keep only a\n    small amount of information for local symbols.  */\n \n-static symbolS *local_symbol_convert (struct local_symbol *);\n-\n /* Used for statistics.  */\n \n static unsigned long local_symbol_count;\n static unsigned long local_symbol_conversion_count;\n \n-/* This macro is called with a symbol argument passed by reference.\n-   It returns whether this is a local symbol.  If necessary, it\n-   changes its argument to the real symbol.  */\n-\n-#define LOCAL_SYMBOL_CHECK(s)\t\t\t\t\t\t\\\n-  (s->flags.local_symbol\t\t\t\t\t\t\\\n-   ? (local_symbol_converted_p ((struct local_symbol *) s)\t\t\\\n-      ? (s = local_symbol_get_real_symbol ((struct local_symbol *) s),\t\\\n-\t 0)\t\t\t\t\t\t\t\t\\\n-      : 1)\t\t\t\t\t\t\t\t\\\n-   : 0)\n-\n /* Create a local symbol and insert it into the local hash table.  */\n \n struct local_symbol *\n@@ -367,51 +358,42 @@ local_symbol_make (const char *name, segT section, fragS *frag, valueT val)\n \n   ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);\n   ret->flags = flags;\n+  ret->hash = 0;\n   ret->name = name_copy;\n+  ret->frag = frag;\n   ret->section = section;\n-  ret->u.frag = frag;\n   ret->value = val;\n \n-  htab_insert (local_hash, symbol_entry_alloc (name_copy, ret));\n+  htab_insert (sy_hash, ret);\n \n   return ret;\n }\n \n-/* Convert a local symbol into a real symbol.  Note that we do not\n-   reclaim the space used by the local symbol.  */\n+/* Convert a local symbol into a real symbol.  */\n \n static symbolS *\n-local_symbol_convert (struct local_symbol *locsym)\n+local_symbol_convert (void *sym)\n {\n-  symbolS *ret;\n+  symbol_entry_t *ent = (symbol_entry_t *) sym;\n+  struct xsymbol *xtra;\n+  valueT val;\n \n-  gas_assert (locsym->flags.local_symbol);\n-  if (local_symbol_converted_p (locsym))\n-    return local_symbol_get_real_symbol (locsym);\n+  gas_assert (ent->lsy.flags.local_symbol);\n \n   ++local_symbol_conversion_count;\n \n-  ret = symbol_new (locsym->name, locsym->section,\n-\t\t    locsym->u.frag, locsym->value);\n-\n-  if (locsym->flags.resolved)\n-    ret->flags.resolved = 1;\n+  xtra = (struct xsymbol *) obstack_alloc (&notes, sizeof *xtra);\n+  val = ent->lsy.value;\n+  ent->sy.x = xtra;\n \n   /* Local symbols are always either defined or used.  */\n-  ret->flags.used = 1;\n-\n-#ifdef TC_LOCAL_SYMFIELD_CONVERT\n-  TC_LOCAL_SYMFIELD_CONVERT (locsym, ret);\n-#endif\n-\n-  symbol_table_insert (ret);\n+  ent->sy.flags.used = 1;\n+  ent->sy.flags.local_symbol = 0;\n \n-  local_symbol_mark_converted (locsym);\n-  local_symbol_set_real_symbol (locsym, ret);\n+  symbol_init (&ent->sy, ent->lsy.name, ent->lsy.section, ent->lsy.frag, val);\n+  symbol_append (&ent->sy, symbol_lastP, &symbol_rootP, &symbol_lastP);\n \n-  htab_insert (local_hash, symbol_entry_alloc (locsym->name, NULL));\n-\n-  return ret;\n+  return &ent->sy;\n }\n \f\n static void\n@@ -494,12 +476,12 @@ colon (/* Just seen \"x:\" - rattle symbols & frags.  */\n \treturn symbolP;\n #endif\n       /* Now check for undefined symbols.  */\n-      if (LOCAL_SYMBOL_CHECK (symbolP))\n+      if (symbolP->flags.local_symbol)\n \t{\n \t  struct local_symbol *locsym = (struct local_symbol *) symbolP;\n \n \t  if (locsym->section != undefined_section\n-\t      && (locsym->u.frag != frag_now\n+\t      && (locsym->frag != frag_now\n \t\t  || locsym->section != now_seg\n \t\t  || locsym->value != frag_now_fix ()))\n \t    {\n@@ -508,7 +490,7 @@ colon (/* Just seen \"x:\" - rattle symbols & frags.  */\n \t    }\n \n \t  locsym->section = now_seg;\n-\t  locsym->u.frag = frag_now;\n+\t  locsym->frag = frag_now;\n \t  locsym->value = frag_now_fix ();\n \t}\n       else if (!(S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))\n@@ -621,11 +603,11 @@ colon (/* Just seen \"x:\" - rattle symbols & frags.  */\n     {\n       /* This symbol is actually being defined within an MRI common\n \t section.  This requires special handling.  */\n-      if (LOCAL_SYMBOL_CHECK (symbolP))\n-\tsymbolP = local_symbol_convert ((struct local_symbol *) symbolP);\n-      symbolP->value.X_op = O_symbol;\n-      symbolP->value.X_add_symbol = mri_common_symbol;\n-      symbolP->value.X_add_number = S_GET_VALUE (mri_common_symbol);\n+      if (symbolP->flags.local_symbol)\n+\tsymbolP = local_symbol_convert (symbolP);\n+      symbolP->x->value.X_op = O_symbol;\n+      symbolP->x->value.X_add_symbol = mri_common_symbol;\n+      symbolP->x->value.X_add_number = S_GET_VALUE (mri_common_symbol);\n       symbolP->frag = &zero_address_frag;\n       S_SET_SEGMENT (symbolP, expr_section);\n       symbolP->flags.mri_common = 1;\n@@ -647,15 +629,8 @@ void\n symbol_table_insert (symbolS *symbolP)\n {\n   know (symbolP);\n-  know (S_GET_NAME (symbolP));\n \n-  if (LOCAL_SYMBOL_CHECK (symbolP))\n-    htab_insert (local_hash,\n-\t\t symbol_entry_alloc (S_GET_NAME (symbolP),\n-\t\t\t\t     (struct local_symbol *)symbolP));\n-  else\n-    htab_insert (sy_hash, symbol_entry_alloc (S_GET_NAME (symbolP),\n-\t\t\t\t\t      (struct local_symbol *)symbolP));\n+  htab_insert (sy_hash, symbolP);\n }\n \f\n /* If a symbol name does not exist, create it as undefined, and insert\n@@ -712,16 +687,19 @@ symbol_clone (symbolS *orgsymP, int replace)\n   /* Make sure we never clone the dot special symbol.  */\n   gas_assert (orgsymP != &dot_symbol);\n \n-  /* Running local_symbol_convert on a clone that's not the one currently\n-     in local_hash would incorrectly replace the hash entry.  Thus the\n-     symbol must be converted here.  Note that the rest of the function\n-     depends on not encountering an unconverted symbol.  */\n-  if (LOCAL_SYMBOL_CHECK (orgsymP))\n-    orgsymP = local_symbol_convert ((struct local_symbol *) orgsymP);\n+  /* When cloning a local symbol it isn't absolutely necessary to\n+     convert the original, but converting makes the code much\n+     simpler to cover this unexpected case.  As of 2020-08-21\n+     symbol_clone won't be called on a local symbol.  */\n+  if (orgsymP->flags.local_symbol)\n+    orgsymP = local_symbol_convert (orgsymP);\n   bsymorg = orgsymP->bsym;\n \n-  newsymP = (symbolS *) obstack_alloc (&notes, sizeof (*newsymP));\n+  newsymP = (symbolS *) obstack_alloc (&notes, (sizeof (symbolS)\n+\t\t\t\t\t\t+ sizeof (struct xsymbol)));\n   *newsymP = *orgsymP;\n+  newsymP->x = (struct xsymbol *) (newsymP + 1);\n+  *newsymP->x = *orgsymP->x;\n   bsymnew = bfd_make_empty_symbol (bfd_asymbol_bfd (bsymorg));\n   if (bsymnew == NULL)\n     as_fatal (\"bfd_make_empty_symbol: %s\", bfd_errmsg (bfd_get_error ()));\n@@ -744,19 +722,19 @@ symbol_clone (symbolS *orgsymP, int replace)\n     {\n       if (symbol_rootP == orgsymP)\n \tsymbol_rootP = newsymP;\n-      else if (orgsymP->previous)\n+      else if (orgsymP->x->previous)\n \t{\n-\t  orgsymP->previous->next = newsymP;\n-\t  orgsymP->previous = NULL;\n+\t  orgsymP->x->previous->x->next = newsymP;\n+\t  orgsymP->x->previous = NULL;\n \t}\n       if (symbol_lastP == orgsymP)\n \tsymbol_lastP = newsymP;\n-      else if (orgsymP->next)\n-\torgsymP->next->previous = newsymP;\n+      else if (orgsymP->x->next)\n+\torgsymP->x->next->x->previous = newsymP;\n \n       /* Symbols that won't be output can't be external.  */\n       S_CLEAR_EXTERNAL (orgsymP);\n-      orgsymP->previous = orgsymP->next = orgsymP;\n+      orgsymP->x->previous = orgsymP->x->next = orgsymP;\n       debug_verify_symchain (symbol_rootP, symbol_lastP);\n \n       symbol_table_insert (newsymP);\n@@ -765,25 +743,12 @@ symbol_clone (symbolS *orgsymP, int replace)\n     {\n       /* Symbols that won't be output can't be external.  */\n       S_CLEAR_EXTERNAL (newsymP);\n-      newsymP->previous = newsymP->next = newsymP;\n+      newsymP->x->previous = newsymP->x->next = newsymP;\n     }\n \n   return newsymP;\n }\n \n-/* If S is a local symbol that has been converted, return the\n-   converted symbol.  Otherwise return S.  */\n-\n-static inline symbolS *\n-get_real_sym (symbolS *s)\n-{\n-  if (s != NULL\n-      && s->flags.local_symbol\n-      && local_symbol_converted_p ((struct local_symbol *) s))\n-    s = local_symbol_get_real_symbol ((struct local_symbol *) s);\n-  return s;\n-}\n-\n /* Referenced symbols, if they are forward references, need to be cloned\n    (without replacing the original) so that the value of the referenced\n    symbols at the point of use is saved by the clone.  */\n@@ -792,10 +757,10 @@ get_real_sym (symbolS *s)\n symbolS *\n symbol_clone_if_forward_ref (symbolS *symbolP, int is_forward)\n {\n-  if (symbolP && !LOCAL_SYMBOL_CHECK (symbolP))\n+  if (symbolP && !symbolP->flags.local_symbol)\n     {\n-      symbolS *orig_add_symbol = get_real_sym (symbolP->value.X_add_symbol);\n-      symbolS *orig_op_symbol = get_real_sym (symbolP->value.X_op_symbol);\n+      symbolS *orig_add_symbol = symbolP->x->value.X_add_symbol;\n+      symbolS *orig_op_symbol = symbolP->x->value.X_op_symbol;\n       symbolS *add_symbol = orig_add_symbol;\n       symbolS *op_symbol = orig_op_symbol;\n \n@@ -843,8 +808,8 @@ symbol_clone_if_forward_ref (symbolS *symbolP, int is_forward)\n \t    }\n \t}\n \n-      symbolP->value.X_add_symbol = add_symbol;\n-      symbolP->value.X_op_symbol = op_symbol;\n+      symbolP->x->value.X_add_symbol = add_symbol;\n+      symbolP->x->value.X_op_symbol = op_symbol;\n     }\n \n   return symbolP;\n@@ -888,11 +853,7 @@ symbol_find_exact (const char *name)\n symbolS *\n symbol_find_exact_noref (const char *name, int noref)\n {\n-  symbolS *sym = symbol_entry_find (local_hash, name);\n-  if (sym)\n-    return sym;\n-\n-  sym = symbol_entry_find (sy_hash, name);\n+  symbolS *sym = symbol_entry_find (sy_hash, name);\n \n   /* Any references to the symbol, except for the reference in\n      .weakref, must clear this flag, such that the symbol does not\n@@ -963,35 +924,35 @@ symbol_append (symbolS *addme, symbolS *target,\n   extern int symbol_table_frozen;\n   if (symbol_table_frozen)\n     abort ();\n-  if (LOCAL_SYMBOL_CHECK (addme))\n+  if (addme->flags.local_symbol)\n     abort ();\n-  if (target != NULL && LOCAL_SYMBOL_CHECK (target))\n+  if (target != NULL && target->flags.local_symbol)\n     abort ();\n \n   if (target == NULL)\n     {\n       know (*rootPP == NULL);\n       know (*lastPP == NULL);\n-      addme->next = NULL;\n-      addme->previous = NULL;\n+      addme->x->next = NULL;\n+      addme->x->previous = NULL;\n       *rootPP = addme;\n       *lastPP = addme;\n       return;\n     }\t\t\t\t/* if the list is empty  */\n \n-  if (target->next != NULL)\n+  if (target->x->next != NULL)\n     {\n-      target->next->previous = addme;\n+      target->x->next->x->previous = addme;\n     }\n   else\n     {\n       know (*lastPP == target);\n       *lastPP = addme;\n     }\t\t\t\t/* if we have a next  */\n \n-  addme->next = target->next;\n-  target->next = addme;\n-  addme->previous = target;\n+  addme->x->next = target->x->next;\n+  target->x->next = addme;\n+  addme->x->previous = target;\n \n   debug_verify_symchain (symbol_rootP, symbol_lastP);\n }\n@@ -1001,38 +962,38 @@ symbol_append (symbolS *addme, symbolS *target,\n void\n symbol_clear_list_pointers (symbolS *symbolP)\n {\n-  if (LOCAL_SYMBOL_CHECK (symbolP))\n+  if (symbolP->flags.local_symbol)\n     abort ();\n-  symbolP->next = NULL;\n-  symbolP->previous = NULL;\n+  symbolP->x->next = NULL;\n+  symbolP->x->previous = NULL;\n }\n \n /* Remove SYMBOLP from the list.  */\n \n void\n symbol_remove (symbolS *symbolP, symbolS **rootPP, symbolS **lastPP)\n {\n-  if (LOCAL_SYMBOL_CHECK (symbolP))\n+  if (symbolP->flags.local_symbol)\n     abort ();\n \n   if (symbolP == *rootPP)\n     {\n-      *rootPP = symbolP->next;\n+      *rootPP = symbolP->x->next;\n     }\t\t\t\t/* if it was the root  */\n \n   if (symbolP == *lastPP)\n     {\n-      *lastPP = symbolP->previous;\n+      *lastPP = symbolP->x->previous;\n     }\t\t\t\t/* if it was the tail  */\n \n-  if (symbolP->next != NULL)\n+  if (symbolP->x->next != NULL)\n     {\n-      symbolP->next->previous = symbolP->previous;\n+      symbolP->x->next->x->previous = symbolP->x->previous;\n     }\t\t\t\t/* if not last  */\n \n-  if (symbolP->previous != NULL)\n+  if (symbolP->x->previous != NULL)\n     {\n-      symbolP->previous->next = symbolP->next;\n+      symbolP->x->previous->x->next = symbolP->x->next;\n     }\t\t\t\t/* if not first  */\n \n   debug_verify_symchain (*rootPP, *lastPP);\n@@ -1047,24 +1008,24 @@ symbol_insert (symbolS *addme, symbolS *target,\n   extern int symbol_table_frozen;\n   if (symbol_table_frozen)\n     abort ();\n-  if (LOCAL_SYMBOL_CHECK (addme))\n+  if (addme->flags.local_symbol)\n     abort ();\n-  if (LOCAL_SYMBOL_CHECK (target))\n+  if (target->flags.local_symbol)\n     abort ();\n \n-  if (target->previous != NULL)\n+  if (target->x->previous != NULL)\n     {\n-      target->previous->next = addme;\n+      target->x->previous->x->next = addme;\n     }\n   else\n     {\n       know (*rootPP == target);\n       *rootPP = addme;\n     }\t\t\t\t/* if not first  */\n \n-  addme->previous = target->previous;\n-  target->previous = addme;\n-  addme->next = target;\n+  addme->x->previous = target->x->previous;\n+  target->x->previous = addme;\n+  addme->x->next = target;\n \n   debug_verify_symchain (*rootPP, *lastPP);\n }\n@@ -1081,7 +1042,7 @@ verify_symbol_chain (symbolS *rootP, symbolS *lastP)\n     {\n       gas_assert (symbolP->bsym != NULL);\n       gas_assert (symbolP->flags.local_symbol == 0);\n-      gas_assert (symbolP->next->previous == symbolP);\n+      gas_assert (symbolP->x->next->x->previous == symbolP);\n     }\n \n   gas_assert (lastP == symbolP);\n@@ -1090,14 +1051,14 @@ verify_symbol_chain (symbolS *rootP, symbolS *lastP)\n int\n symbol_on_chain (symbolS *s, symbolS *rootPP, symbolS *lastPP)\n {\n-  return (!LOCAL_SYMBOL_CHECK (s)\n-\t  && ((s->next != s\n-\t       && s->next != NULL\n-\t       && s->next->previous == s)\n+  return (!s->flags.local_symbol\n+\t  && ((s->x->next != s\n+\t       && s->x->next != NULL\n+\t       && s->x->next->x->previous == s)\n \t      || s == lastPP)\n-\t  && ((s->previous != s\n-\t       && s->previous != NULL\n-\t       && s->previous->next == s)\n+\t  && ((s->x->previous != s\n+\t       && s->x->previous != NULL\n+\t       && s->x->previous->x->next == s)\n \t      || s == rootPP));\n }\n \n@@ -1106,7 +1067,7 @@ symbol_on_chain (symbolS *s, symbolS *rootPP, symbolS *lastPP)\n static int\n use_complex_relocs_for (symbolS * symp)\n {\n-  switch (symp->value.X_op)\n+  switch (symp->x->value.X_op)\n     {\n     case O_constant:\n       return 0;\n@@ -1130,20 +1091,20 @@ use_complex_relocs_for (symbolS * symp)\n     case O_gt:\n     case O_logical_and:\n     case O_logical_or:\n-      if ((S_IS_COMMON (symp->value.X_op_symbol)\n-\t   || S_IS_LOCAL (symp->value.X_op_symbol))\n-\t  && S_IS_DEFINED (symp->value.X_op_symbol)\n-\t  && S_GET_SEGMENT (symp->value.X_op_symbol) != expr_section)\n+      if ((S_IS_COMMON (symp->x->value.X_op_symbol)\n+\t   || S_IS_LOCAL (symp->x->value.X_op_symbol))\n+\t  && S_IS_DEFINED (symp->x->value.X_op_symbol)\n+\t  && S_GET_SEGMENT (symp->x->value.X_op_symbol) != expr_section)\n \t{\n \tcase O_symbol:\n \tcase O_symbol_rva:\n \tcase O_uminus:\n \tcase O_bit_not:\n \tcase O_logical_not:\n-\t  if ((S_IS_COMMON (symp->value.X_add_symbol)\n-\t       || S_IS_LOCAL (symp->value.X_add_symbol))\n-\t      && S_IS_DEFINED (symp->value.X_add_symbol)\n-\t      && S_GET_SEGMENT (symp->value.X_add_symbol) != expr_section)\n+\t  if ((S_IS_COMMON (symp->x->value.X_add_symbol)\n+\t       || S_IS_LOCAL (symp->x->value.X_add_symbol))\n+\t      && S_IS_DEFINED (symp->x->value.X_add_symbol)\n+\t      && S_GET_SEGMENT (symp->x->value.X_add_symbol) != expr_section)\n \t    return 0;\n \t}\n       break;\n@@ -1229,7 +1190,7 @@ resolve_symbol_value (symbolS *symp)\n   valueT final_val;\n   segT final_seg;\n \n-  if (LOCAL_SYMBOL_CHECK (symp))\n+  if (symp->flags.local_symbol)\n     {\n       struct local_symbol *locsym = (struct local_symbol *) symp;\n \n@@ -1240,9 +1201,9 @@ resolve_symbol_value (symbolS *symp)\n       /* Symbols whose section has SEC_ELF_OCTETS set,\n \t resolve to octets instead of target bytes. */\n       if (locsym->section->flags & SEC_OCTETS)\n-\tfinal_val += locsym->u.frag->fr_address;\n+\tfinal_val += locsym->frag->fr_address;\n       else\n-\tfinal_val += locsym->u.frag->fr_address / OCTETS_PER_BYTE;\n+\tfinal_val += locsym->frag->fr_address / OCTETS_PER_BYTE;\n \n       if (finalize_syms)\n \t{\n@@ -1256,11 +1217,11 @@ resolve_symbol_value (symbolS *symp)\n   if (symp->flags.resolved)\n     {\n       final_val = 0;\n-      while (symp->value.X_op == O_symbol)\n+      while (symp->x->value.X_op == O_symbol)\n \t{\n-\t  final_val += symp->value.X_add_number;\n-\t  symp = symp->value.X_add_symbol;\n-\t  if (LOCAL_SYMBOL_CHECK (symp))\n+\t  final_val += symp->x->value.X_add_number;\n+\t  symp = symp->x->value.X_add_symbol;\n+\t  if (symp->flags.local_symbol)\n \t    {\n \t      struct local_symbol *locsym = (struct local_symbol *) symp;\n \t      final_val += locsym->value;\n@@ -1269,8 +1230,8 @@ resolve_symbol_value (symbolS *symp)\n \t  if (!symp->flags.resolved)\n \t    return 0;\n \t}\n-      if (symp->value.X_op == O_constant)\n-\tfinal_val += symp->value.X_add_number;\n+      if (symp->x->value.X_op == O_constant)\n+\tfinal_val += symp->x->value.X_add_number;\n       else\n \tfinal_val = 0;\n       return final_val;\n@@ -1294,11 +1255,11 @@ resolve_symbol_value (symbolS *symp)\n       symbolS * relc_symbol = NULL;\n       char * relc_symbol_name = NULL;\n \n-      relc_symbol_name = symbol_relc_make_expr (& symp->value);\n+      relc_symbol_name = symbol_relc_make_expr (& symp->x->value);\n \n       /* For debugging, print out conversion input & output.  */\n #ifdef DEBUG_SYMS\n-      print_expr (& symp->value);\n+      print_expr (& symp->x->value);\n       if (relc_symbol_name)\n \tfprintf (stderr, \"-> relc symbol: %s\\n\", relc_symbol_name);\n #endif\n@@ -1324,9 +1285,9 @@ resolve_symbol_value (symbolS *symp)\n \t    relc_symbol->bsym->flags |= BSF_RELC;\n \t  /* symp->bsym->flags |= BSF_RELC; */\n \t  copy_symbol_attributes (symp, relc_symbol);\n-\t  symp->value.X_op = O_symbol;\n-\t  symp->value.X_add_symbol = relc_symbol;\n-\t  symp->value.X_add_number = 0;\n+\t  symp->x->value.X_op = O_symbol;\n+\t  symp->x->value.X_add_symbol = relc_symbol;\n+\t  symp->x->value.X_add_number = 0;\n \t  resolved = 1;\n \t}\n \n@@ -1346,10 +1307,10 @@ resolve_symbol_value (symbolS *symp)\n       symp->flags.resolving = 1;\n \n       /* Help out with CSE.  */\n-      add_symbol = symp->value.X_add_symbol;\n-      op_symbol = symp->value.X_op_symbol;\n-      final_val = symp->value.X_add_number;\n-      op = symp->value.X_op;\n+      add_symbol = symp->x->value.X_add_symbol;\n+      op_symbol = symp->x->value.X_op_symbol;\n+      final_val = symp->x->value.X_add_number;\n+      op = symp->x->value.X_op;\n \n       switch (op)\n \t{\n@@ -1381,19 +1342,19 @@ resolve_symbol_value (symbolS *symp)\n \t  left = resolve_symbol_value (add_symbol);\n \t  seg_left = S_GET_SEGMENT (add_symbol);\n \t  if (finalize_syms)\n-\t    symp->value.X_op_symbol = NULL;\n+\t    symp->x->value.X_op_symbol = NULL;\n \n \tdo_symbol:\n \t  if (S_IS_WEAKREFR (symp))\n \t    {\n \t      gas_assert (final_val == 0);\n \t      if (S_IS_WEAKREFR (add_symbol))\n \t\t{\n-\t\t  gas_assert (add_symbol->value.X_op == O_symbol\n-\t\t\t  && add_symbol->value.X_add_number == 0);\n-\t\t  add_symbol = add_symbol->value.X_add_symbol;\n+\t\t  gas_assert (add_symbol->x->value.X_op == O_symbol\n+\t\t\t      && add_symbol->x->value.X_add_number == 0);\n+\t\t  add_symbol = add_symbol->x->value.X_add_symbol;\n \t\t  gas_assert (! S_IS_WEAKREFR (add_symbol));\n-\t\t  symp->value.X_add_symbol = add_symbol;\n+\t\t  symp->x->value.X_add_symbol = add_symbol;\n \t\t}\n \t    }\n \n@@ -1408,15 +1369,14 @@ resolve_symbol_value (symbolS *symp)\n \n \t  /* Don't leave symbol loops.  */\n \t  if (finalize_syms\n-\t      && !LOCAL_SYMBOL_CHECK (add_symbol)\n+\t      && !add_symbol->flags.local_symbol\n \t      && add_symbol->flags.resolving)\n \t    break;\n \n \t  if (finalize_syms && final_val == 0)\n \t    {\n-\t      if (LOCAL_SYMBOL_CHECK (add_symbol))\n-\t\tadd_symbol = local_symbol_convert ((struct local_symbol *)\n-\t\t\t\t\t\t   add_symbol);\n+\t      if (add_symbol->flags.local_symbol)\n+\t\tadd_symbol = local_symbol_convert (add_symbol);\n \t      copy_symbol_attributes (symp, add_symbol);\n \t    }\n \n@@ -1439,11 +1399,11 @@ resolve_symbol_value (symbolS *symp)\n \t    {\n \t      if (finalize_syms)\n \t\t{\n-\t\t  symp->value.X_op = O_symbol;\n-\t\t  symp->value.X_add_symbol = add_symbol;\n-\t\t  symp->value.X_add_number = final_val;\n+\t\t  symp->x->value.X_op = O_symbol;\n+\t\t  symp->x->value.X_add_symbol = add_symbol;\n+\t\t  symp->x->value.X_add_number = final_val;\n \t\t  /* Use X_op_symbol as a flag.  */\n-\t\t  symp->value.X_op_symbol = add_symbol;\n+\t\t  symp->x->value.X_op_symbol = add_symbol;\n \t\t}\n \t      final_seg = seg_left;\n \t      final_val += symp->frag->fr_address + left;\n@@ -1599,7 +1559,7 @@ resolve_symbol_value (symbolS *symp)\n \t      right = 1;\n \t    }\n \n-\t  switch (symp->value.X_op)\n+\t  switch (symp->x->value.X_op)\n \t    {\n \t    case O_multiply:\t\tleft *= right; break;\n \t    case O_divide:\t\tleft /= right; break;\n@@ -1618,7 +1578,7 @@ resolve_symbol_value (symbolS *symp)\n \t\t      && (seg_left != undefined_section\n \t\t\t  || add_symbol == op_symbol)\n \t\t      ? ~ (offsetT) 0 : 0);\n-\t      if (symp->value.X_op == O_ne)\n+\t      if (symp->x->value.X_op == O_ne)\n \t\tleft = ~left;\n \t      break;\n \t    case O_lt:\tleft = left <  right ? ~ (offsetT) 0 : 0; break;\n@@ -1697,8 +1657,8 @@ static int\n resolve_local_symbol (void **slot, void *arg ATTRIBUTE_UNUSED)\n {\n   symbol_entry_t *entry = *((symbol_entry_t **) slot);\n-  if (entry->symbol != NULL)\n-    resolve_symbol_value ((symbolS *) entry->symbol);\n+  if (entry->sy.flags.local_symbol)\n+    resolve_symbol_value (&entry->sy);\n \n   return 1;\n }\n@@ -1708,7 +1668,7 @@ resolve_local_symbol (void **slot, void *arg ATTRIBUTE_UNUSED)\n void\n resolve_local_symbol_values (void)\n {\n-  htab_traverse (local_hash, resolve_local_symbol, NULL);\n+  htab_traverse (sy_hash, resolve_local_symbol, NULL);\n }\n \n /* Obtain the current value of a symbol without changing any\n@@ -1719,17 +1679,17 @@ snapshot_symbol (symbolS **symbolPP, valueT *valueP, segT *segP, fragS **fragPP)\n {\n   symbolS *symbolP = *symbolPP;\n \n-  if (LOCAL_SYMBOL_CHECK (symbolP))\n+  if (symbolP->flags.local_symbol)\n     {\n       struct local_symbol *locsym = (struct local_symbol *) symbolP;\n \n       *valueP = locsym->value;\n       *segP = locsym->section;\n-      *fragPP = locsym->u.frag;\n+      *fragPP = locsym->frag;\n     }\n   else\n     {\n-      expressionS exp = symbolP->value;\n+      expressionS exp = symbolP->x->value;\n \n       if (!symbolP->flags.resolved && exp.X_op != O_illegal)\n \t{\n@@ -1763,13 +1723,13 @@ snapshot_symbol (symbolS **symbolPP, valueT *valueP, segT *segP, fragS **fragPP)\n \n       /* A bogus input file can result in resolve_expression()\n \t generating a local symbol, so we have to check again.  */\n-      if (LOCAL_SYMBOL_CHECK (symbolP))\n+      if (symbolP->flags.local_symbol)\n \t{\n \t  struct local_symbol *locsym = (struct local_symbol *) symbolP;\n \n \t  *valueP = locsym->value;\n \t  *segP = locsym->section;\n-\t  *fragPP = locsym->u.frag;\n+\t  *fragPP = locsym->frag;\n \t}\n       else\n \t{\n@@ -2154,7 +2114,7 @@ decode_local_label_name (char *s)\n valueT\n S_GET_VALUE (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return resolve_symbol_value (s);\n \n   if (!s->flags.resolved)\n@@ -2164,43 +2124,43 @@ S_GET_VALUE (symbolS *s)\n \treturn val;\n     }\n   if (S_IS_WEAKREFR (s))\n-    return S_GET_VALUE (s->value.X_add_symbol);\n+    return S_GET_VALUE (s->x->value.X_add_symbol);\n \n-  if (s->value.X_op != O_constant)\n+  if (s->x->value.X_op != O_constant)\n     {\n       if (! s->flags.resolved\n-\t  || s->value.X_op != O_symbol\n+\t  || s->x->value.X_op != O_symbol\n \t  || (S_IS_DEFINED (s) && ! S_IS_COMMON (s)))\n \tas_bad (_(\"attempt to get value of unresolved symbol `%s'\"),\n \t\tS_GET_NAME (s));\n     }\n-  return (valueT) s->value.X_add_number;\n+  return (valueT) s->x->value.X_add_number;\n }\n \n /* Set the value of a symbol.  */\n \n void\n S_SET_VALUE (symbolS *s, valueT val)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     {\n       ((struct local_symbol *) s)->value = val;\n       return;\n     }\n \n-  s->value.X_op = O_constant;\n-  s->value.X_add_number = (offsetT) val;\n-  s->value.X_unsigned = 0;\n+  s->x->value.X_op = O_constant;\n+  s->x->value.X_add_number = (offsetT) val;\n+  s->x->value.X_unsigned = 0;\n   S_CLEAR_WEAKREFR (s);\n }\n \n void\n copy_symbol_attributes (symbolS *dest, symbolS *src)\n {\n-  if (LOCAL_SYMBOL_CHECK (dest))\n-    dest = local_symbol_convert ((struct local_symbol *) dest);\n-  if (LOCAL_SYMBOL_CHECK (src))\n-    src = local_symbol_convert ((struct local_symbol *) src);\n+  if (dest->flags.local_symbol)\n+    dest = local_symbol_convert (dest);\n+  if (src->flags.local_symbol)\n+    src = local_symbol_convert (src);\n \n   /* In an expression, transfer the settings of these flags.\n      The user can override later, of course.  */\n@@ -2222,7 +2182,7 @@ S_IS_FUNCTION (symbolS *s)\n {\n   flagword flags;\n \n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n \n   flags = s->bsym->flags;\n@@ -2235,7 +2195,7 @@ S_IS_EXTERNAL (symbolS *s)\n {\n   flagword flags;\n \n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n \n   flags = s->bsym->flags;\n@@ -2250,45 +2210,45 @@ S_IS_EXTERNAL (symbolS *s)\n int\n S_IS_WEAK (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   /* Conceptually, a weakrefr is weak if the referenced symbol is.  We\n      could probably handle a WEAKREFR as always weak though.  E.g., if\n      the referenced symbol has lost its weak status, there's no reason\n      to keep handling the weakrefr as if it was weak.  */\n   if (S_IS_WEAKREFR (s))\n-    return S_IS_WEAK (s->value.X_add_symbol);\n+    return S_IS_WEAK (s->x->value.X_add_symbol);\n   return (s->bsym->flags & BSF_WEAK) != 0;\n }\n \n int\n S_IS_WEAKREFR (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return s->flags.weakrefr != 0;\n }\n \n int\n S_IS_WEAKREFD (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return s->flags.weakrefd != 0;\n }\n \n int\n S_IS_COMMON (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return bfd_is_com_section (s->bsym->section);\n }\n \n int\n S_IS_DEFINED (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return ((struct local_symbol *) s)->section != undefined_section;\n   return s->bsym->section != undefined_section;\n }\n@@ -2305,7 +2265,7 @@ int\n S_FORCE_RELOC (symbolS *s, int strict)\n {\n   segT sec;\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     sec = ((struct local_symbol *) s)->section;\n   else\n     {\n@@ -2323,7 +2283,7 @@ S_FORCE_RELOC (symbolS *s, int strict)\n int\n S_IS_DEBUG (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   if (s->bsym->flags & BSF_DEBUGGING)\n     return 1;\n@@ -2336,7 +2296,7 @@ S_IS_LOCAL (symbolS *s)\n   flagword flags;\n   const char *name;\n \n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 1;\n \n   flags = s->bsym->flags;\n@@ -2380,8 +2340,8 @@ S_IS_STABD (symbolS *s)\n int\n S_CAN_BE_REDEFINED (const symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    return (((struct local_symbol *) s)->u.frag\n+  if (s->flags.local_symbol)\n+    return (((struct local_symbol *) s)->frag\n \t    == &predefined_address_frag);\n   /* Permit register names to be redefined.  */\n   return s->bsym->section == reg_section;\n@@ -2390,53 +2350,45 @@ S_CAN_BE_REDEFINED (const symbolS *s)\n int\n S_IS_VOLATILE (const symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return s->flags.volatil;\n }\n \n int\n S_IS_FORWARD_REF (const symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return s->flags.forward_ref;\n }\n \n const char *\n S_GET_NAME (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    return ((struct local_symbol *) s)->name;\n-  return s->bsym->name;\n+  return s->name;\n }\n \n segT\n S_GET_SEGMENT (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return ((struct local_symbol *) s)->section;\n   return s->bsym->section;\n }\n \n void\n S_SET_SEGMENT (symbolS *s, segT seg)\n {\n-  /* Don't reassign section symbols.  The direct reason is to prevent seg\n-     faults assigning back to const global symbols such as *ABS*, but it\n-     shouldn't happen anyway.  */\n-\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     {\n-      if (seg == reg_section)\n-\ts = local_symbol_convert ((struct local_symbol *) s);\n-      else\n-\t{\n-\t  ((struct local_symbol *) s)->section = seg;\n-\t  return;\n-\t}\n+      ((struct local_symbol *) s)->section = seg;\n+      return;\n     }\n \n+  /* Don't reassign section symbols.  The direct reason is to prevent seg\n+     faults assigning back to const global symbols such as *ABS*, but it\n+     shouldn't happen anyway.  */\n   if (s->bsym->flags & BSF_SECTION_SYM)\n     {\n       if (s->bsym->section != seg)\n@@ -2449,8 +2401,8 @@ S_SET_SEGMENT (symbolS *s, segT seg)\n void\n S_SET_EXTERNAL (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   if ((s->bsym->flags & BSF_WEAK) != 0)\n     {\n       /* Let .weak override .global.  */\n@@ -2482,7 +2434,7 @@ S_SET_EXTERNAL (symbolS *s)\n void\n S_CLEAR_EXTERNAL (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return;\n   if ((s->bsym->flags & BSF_WEAK) != 0)\n     {\n@@ -2496,8 +2448,8 @@ S_CLEAR_EXTERNAL (symbolS *s)\n void\n S_SET_WEAK (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n #ifdef obj_set_weak_hook\n   obj_set_weak_hook (s);\n #endif\n@@ -2508,8 +2460,8 @@ S_SET_WEAK (symbolS *s)\n void\n S_SET_WEAKREFR (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   s->flags.weakrefr = 1;\n   /* If the alias was already used, make sure we mark the target as\n      used as well, otherwise it might be dropped from the symbol\n@@ -2518,30 +2470,30 @@ S_SET_WEAKREFR (symbolS *s)\n      previous target in the symbol table.  Since it will be weak, it's\n      not a big deal.  */\n   if (s->flags.used)\n-    symbol_mark_used (s->value.X_add_symbol);\n+    symbol_mark_used (s->x->value.X_add_symbol);\n }\n \n void\n S_CLEAR_WEAKREFR (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return;\n   s->flags.weakrefr = 0;\n }\n \n void\n S_SET_WEAKREFD (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   s->flags.weakrefd = 1;\n   S_SET_WEAK (s);\n }\n \n void\n S_CLEAR_WEAKREFD (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return;\n   if (s->flags.weakrefd)\n     {\n@@ -2565,8 +2517,8 @@ S_CLEAR_WEAKREFD (symbolS *s)\n void\n S_SET_THREAD_LOCAL (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   if (bfd_is_com_section (s->bsym->section)\n       && (s->bsym->flags & BSF_THREAD_LOCAL) != 0)\n     return;\n@@ -2583,34 +2535,32 @@ S_SET_THREAD_LOCAL (symbolS *s)\n void\n S_SET_NAME (symbolS *s, const char *name)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    {\n-      ((struct local_symbol *) s)->name = name;\n-      return;\n-    }\n+  s->name = name;\n+  if (s->flags.local_symbol)\n+    return;\n   s->bsym->name = name;\n }\n \n void\n S_SET_VOLATILE (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   s->flags.volatil = 1;\n }\n \n void\n S_CLEAR_VOLATILE (symbolS *s)\n {\n-  if (!LOCAL_SYMBOL_CHECK (s))\n+  if (!s->flags.local_symbol)\n     s->flags.volatil = 0;\n }\n \n void\n S_SET_FORWARD_REF (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   s->flags.forward_ref = 1;\n }\n \n@@ -2619,39 +2569,39 @@ S_SET_FORWARD_REF (symbolS *s)\n symbolS *\n symbol_previous (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     abort ();\n-  return s->previous;\n+  return s->x->previous;\n }\n \n /* Return the next symbol in a chain.  */\n \n symbolS *\n symbol_next (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     abort ();\n-  return s->next;\n+  return s->x->next;\n }\n \n /* Return a pointer to the value of a symbol as an expression.  */\n \n expressionS *\n symbol_get_value_expression (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n-  return &s->value;\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n+  return &s->x->value;\n }\n \n /* Set the value of a symbol to an expression.  */\n \n void\n symbol_set_value_expression (symbolS *s, const expressionS *exp)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n-  s->value = *exp;\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n+  s->x->value = *exp;\n   S_CLEAR_WEAKREFR (s);\n }\n \n@@ -2660,8 +2610,6 @@ symbol_set_value_expression (symbolS *s, const expressionS *exp)\n int\n symbol_same_p (symbolS *s1, symbolS *s2)\n {\n-  s1 = get_real_sym (s1);\n-  s2 = get_real_sym (s2);\n   return s1 == s2;\n }\n \n@@ -2670,10 +2618,10 @@ symbol_same_p (symbolS *s1, symbolS *s2)\n offsetT *\n symbol_X_add_number (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return (offsetT *) &((struct local_symbol *) s)->value;\n \n-  return &s->value.X_add_number;\n+  return &s->x->value.X_add_number;\n }\n \n /* Set the value of SYM to the current position in the current segment.  */\n@@ -2691,9 +2639,9 @@ symbol_set_value_now (symbolS *sym)\n void\n symbol_set_frag (symbolS *s, fragS *f)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     {\n-      ((struct local_symbol *) s)->u.frag = f;\n+      ((struct local_symbol *) s)->frag = f;\n       return;\n     }\n   s->frag = f;\n@@ -2705,8 +2653,8 @@ symbol_set_frag (symbolS *s, fragS *f)\n fragS *\n symbol_get_frag (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    return ((struct local_symbol *) s)->u.frag;\n+  if (s->flags.local_symbol)\n+    return ((struct local_symbol *) s)->frag;\n   return s->frag;\n }\n \n@@ -2715,20 +2663,20 @@ symbol_get_frag (symbolS *s)\n void\n symbol_mark_used (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return;\n   s->flags.used = 1;\n   if (S_IS_WEAKREFR (s))\n-    symbol_mark_used (s->value.X_add_symbol);\n+    symbol_mark_used (s->x->value.X_add_symbol);\n }\n \n /* Clear the mark of whether a symbol has been used.  */\n \n void\n symbol_clear_used (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   s->flags.used = 0;\n }\n \n@@ -2737,7 +2685,7 @@ symbol_clear_used (symbolS *s)\n int\n symbol_used_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 1;\n   return s->flags.used;\n }\n@@ -2747,8 +2695,8 @@ symbol_used_p (symbolS *s)\n void\n symbol_mark_used_in_reloc (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   s->flags.used_in_reloc = 1;\n }\n \n@@ -2757,7 +2705,7 @@ symbol_mark_used_in_reloc (symbolS *s)\n void\n symbol_clear_used_in_reloc (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return;\n   s->flags.used_in_reloc = 0;\n }\n@@ -2767,7 +2715,7 @@ symbol_clear_used_in_reloc (symbolS *s)\n int\n symbol_used_in_reloc_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return s->flags.used_in_reloc;\n }\n@@ -2777,8 +2725,8 @@ symbol_used_in_reloc_p (symbolS *s)\n void\n symbol_mark_mri_common (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   s->flags.mri_common = 1;\n }\n \n@@ -2787,7 +2735,7 @@ symbol_mark_mri_common (symbolS *s)\n void\n symbol_clear_mri_common (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return;\n   s->flags.mri_common = 0;\n }\n@@ -2797,7 +2745,7 @@ symbol_clear_mri_common (symbolS *s)\n int\n symbol_mri_common_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return s->flags.mri_common;\n }\n@@ -2807,7 +2755,7 @@ symbol_mri_common_p (symbolS *s)\n void\n symbol_mark_written (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return;\n   s->flags.written = 1;\n }\n@@ -2817,7 +2765,7 @@ symbol_mark_written (symbolS *s)\n void\n symbol_clear_written (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return;\n   s->flags.written = 0;\n }\n@@ -2827,7 +2775,7 @@ symbol_clear_written (symbolS *s)\n int\n symbol_written_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return s->flags.written;\n }\n@@ -2837,11 +2785,6 @@ symbol_written_p (symbolS *s)\n void\n symbol_mark_resolved (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    {\n-      ((struct local_symbol *) s)->flags.resolved = 1;\n-      return;\n-    }\n   s->flags.resolved = 1;\n }\n \n@@ -2850,17 +2793,15 @@ symbol_mark_resolved (symbolS *s)\n int\n symbol_resolved_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    return ((struct local_symbol *) s)->flags.resolved;\n   return s->flags.resolved;\n }\n \n /* Return whether a symbol is a section symbol.  */\n \n int\n-symbol_section_p (symbolS *s ATTRIBUTE_UNUSED)\n+symbol_section_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   return (s->bsym->flags & BSF_SECTION_SYM) != 0;\n }\n@@ -2870,9 +2811,9 @@ symbol_section_p (symbolS *s ATTRIBUTE_UNUSED)\n int\n symbol_equated_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n-  return s->value.X_op == O_symbol;\n+  return s->x->value.X_op == O_symbol;\n }\n \n /* Return whether a symbol is equated to another symbol, and should be\n@@ -2881,16 +2822,16 @@ symbol_equated_p (symbolS *s)\n int\n symbol_equated_reloc_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n   /* X_op_symbol, normally not used for O_symbol, is set by\n      resolve_symbol_value to flag expression syms that have been\n      equated.  */\n-  return (s->value.X_op == O_symbol\n+  return (s->x->value.X_op == O_symbol\n #if defined (OBJ_COFF) && defined (TE_PE)\n \t  && ! S_IS_WEAK (s)\n #endif\n-\t  && ((s->flags.resolved && s->value.X_op_symbol != NULL)\n+\t  && ((s->flags.resolved && s->x->value.X_op_symbol != NULL)\n \t      || ! S_IS_DEFINED (s)\n \t      || S_IS_COMMON (s)));\n }\n@@ -2900,9 +2841,9 @@ symbol_equated_reloc_p (symbolS *s)\n int\n symbol_constant_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 1;\n-  return s->value.X_op == O_constant;\n+  return s->x->value.X_op == O_constant;\n }\n \n /* Return whether a symbol was cloned and thus removed from the global\n@@ -2911,19 +2852,17 @@ symbol_constant_p (symbolS *s)\n int\n symbol_shadow_p (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return 0;\n-  return s->next == s;\n+  return s->x->next == s;\n }\n \n-/* If S was created as a struct symbol, return S, otherwise if S is a\n-   converted local_symbol return the converted symbol, otherwise\n-   return NULL.  */\n+/* If S is a struct symbol return S, otherwise return NULL.  */\n \n symbolS *\n symbol_symbolS (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n+  if (s->flags.local_symbol)\n     return NULL;\n   return s;\n }\n@@ -2933,8 +2872,8 @@ symbol_symbolS (symbolS *s)\n asymbol *\n symbol_get_bfdsym (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   return s->bsym;\n }\n \n@@ -2943,8 +2882,8 @@ symbol_get_bfdsym (symbolS *s)\n void\n symbol_set_bfdsym (symbolS *s, asymbol *bsym)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n   /* Usually, it is harmless to reset a symbol to a BFD section\n      symbol. For example, obj_elf_change_section sets the BFD symbol\n      of an old symbol with the newly created section symbol. But when\n@@ -2964,19 +2903,19 @@ symbol_set_bfdsym (symbolS *s, asymbol *bsym)\n OBJ_SYMFIELD_TYPE *\n symbol_get_obj (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n-  return &s->obj;\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n+  return &s->x->obj;\n }\n \n /* Set the object format information for a symbol.  */\n \n void\n symbol_set_obj (symbolS *s, OBJ_SYMFIELD_TYPE *o)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n-  s->obj = *o;\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n+  s->x->obj = *o;\n }\n \n #endif /* OBJ_SYMFIELD_TYPE */\n@@ -2988,19 +2927,19 @@ symbol_set_obj (symbolS *s, OBJ_SYMFIELD_TYPE *o)\n TC_SYMFIELD_TYPE *\n symbol_get_tc (symbolS *s)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n-  return &s->tc;\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n+  return &s->x->tc;\n }\n \n /* Set the processor information for a symbol.  */\n \n void\n symbol_set_tc (symbolS *s, TC_SYMFIELD_TYPE *o)\n {\n-  if (LOCAL_SYMBOL_CHECK (s))\n-    s = local_symbol_convert ((struct local_symbol *) s);\n-  s->tc = *o;\n+  if (s->flags.local_symbol)\n+    s = local_symbol_convert (s);\n+  s->x->tc = *o;\n }\n \n #endif /* TC_SYMFIELD_TYPE */\n@@ -3012,14 +2951,12 @@ symbol_begin (void)\n   symbol_rootP = NULL;\t\t/* In case we have 0 symbols (!!)  */\n   sy_hash = htab_create_alloc (16, hash_symbol_entry, eq_symbol_entry,\n \t\t\t       NULL, xcalloc, free);\n-  local_hash = htab_create_alloc (16, hash_symbol_entry, eq_symbol_entry,\n-\t\t\t\t  NULL, xcalloc, free);\n \n-  memset ((char *) (&abs_symbol), '\\0', sizeof (abs_symbol));\n #if defined (EMIT_SECTION_SYMBOLS) || !defined (RELOC_REQUIRES_SYMBOL)\n   abs_symbol.bsym = bfd_abs_section_ptr->symbol;\n #endif\n-  abs_symbol.value.X_op = O_constant;\n+  abs_symbol.x = &abs_symbol_x;\n+  abs_symbol.x->value.X_op = O_constant;\n   abs_symbol.frag = &zero_address_frag;\n \n   if (LOCAL_LABELS_FB)\n@@ -3029,12 +2966,14 @@ symbol_begin (void)\n void\n dot_symbol_init (void)\n {\n+  dot_symbol.name = \".\";\n+  dot_symbol.flags.forward_ref = 1;\n   dot_symbol.bsym = bfd_make_empty_symbol (stdoutput);\n   if (dot_symbol.bsym == NULL)\n     as_fatal (\"bfd_make_empty_symbol: %s\", bfd_errmsg (bfd_get_error ()));\n   dot_symbol.bsym->name = \".\";\n-  dot_symbol.flags.forward_ref = 1;\n-  dot_symbol.value.X_op = O_constant;\n+  dot_symbol.x = &dot_symbol_x;\n+  dot_symbol.x->value.X_op = O_constant;\n }\n \f\n int indent_level;\n@@ -3053,15 +2992,15 @@ print_symbol_value_1 (FILE *file, symbolS *sym)\n   fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) sym));\n   fprintf (file, \" %s\", name);\n \n-  if (LOCAL_SYMBOL_CHECK (sym))\n+  if (sym->flags.local_symbol)\n     {\n       struct local_symbol *locsym = (struct local_symbol *) sym;\n \n-      if (locsym->u.frag != & zero_address_frag\n-\t  && locsym->u.frag != NULL)\n+      if (locsym->frag != &zero_address_frag\n+\t  && locsym->frag != NULL)\n \t{\n \t  fprintf (file, \" frag \");\n-\t  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) locsym->u.frag));\n+\t  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) locsym->frag));\n \t}\n       if (locsym->flags.resolved)\n \tfprintf (file, \" resolved\");\n@@ -3113,11 +3052,11 @@ print_symbol_value_1 (FILE *file, symbolS *sym)\n     {\n       indent_level++;\n       fprintf (file, \"\\n%*s<\", indent_level * 4, \"\");\n-      if (LOCAL_SYMBOL_CHECK (sym))\n+      if (sym->flags.local_symbol)\n \tfprintf (file, \"constant %lx\",\n \t\t (unsigned long) ((struct local_symbol *) sym)->value);\n       else\n-\tprint_expr_1 (file, &sym->value);\n+\tprint_expr_1 (file, &sym->x->value);\n       fprintf (file, \">\");\n       indent_level--;\n     }\n@@ -3269,7 +3208,6 @@ void\n symbol_print_statistics (FILE *file)\n {\n   htab_print_statistics (file, \"symbol table\", sy_hash);\n-  htab_print_statistics (file, \"mini local symbol table\", local_hash);\n   fprintf (file, \"%lu mini local symbols created, %lu converted\\n\",\n \t   local_symbol_count, local_symbol_conversion_count);\n }"
    }
  ]
}