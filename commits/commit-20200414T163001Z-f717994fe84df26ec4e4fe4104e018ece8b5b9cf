{
  "sha": "f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjcxNzk5NGZlODRkZjI2ZWM0ZTRmZTQxMDRlMDE4ZWNlOGI1YjljZg==",
  "commit": {
    "author": {
      "name": "Juan Manuel Guerrero",
      "email": "juan.guerrero@gmx.de",
      "date": "2020-04-14T16:30:01Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-04-14T16:30:01Z"
    },
    "message": "[PATCH v2 2/2] coff-go32: support extended relocations\n\nThis patch extends the relocation and line number counters for\ncoff-go32 and coff-go32-exe to 32 bits.  As I understand it works the\nsame as for PE-COFF:\n\nIf the number of relocations in an object file exceeds 65534, the\nNRELOC field is set to 65535 and the actual number of relocations is\nstored in the VADDR field of the first relocation entry.\n\nExecutable files have no relocations, and thus the NRELOC field is\nrepurposed to extend NLNNO to 32-bits.\n\nbfd\t* coff-go32.c (COFF_GO32, IMAGE_SCN_LNK_NRELOC_OVFL)\n\t(coff_SWAP_scnhdr_in, coff_SWAP_scnhdr_out): Define.\n\t(_bfd_go32_swap_scnhdr_in, _bfd_go32_swap_scnhdr_out)\n\t(_bfd_go32_mkobject): New functions.\n\t* coff-stgo32.c (IMAGE_SCN_LNK_NRELOC_OVFL)\n\t(coff_SWAP_scnhdr_in, coff_SWAP_scnhdr_out): Define.\n\t(go32exe_mkobject): Call _bfd_go32_mkobject.\n\t* coffcode.h (COFF_WITH_EXTENDED_RELOC_COUNTER): Define.\n\t(coff_set_alignment_hook): Define function for COFF_GO32_EXE\n\tand COFF_GO32.\n\t(coff_write_relocs): Enable extended reloc counter code if\n\tCOFF_WITH_EXTENDED_RELOC_COUNTER is defined.  Test for obj_go32.\n\t(coff_write_object_contents): Likewise.  Pad section headers\n\tfor COFF_GO32 and COFF_GO32EXE.  Use bfd_coff_swap_scnhdr_out\n\tinstead of coff_swap_scnhdr_out.\n\t* cofflink.c (_bfd_coff_final_link): Test also for obj_go32 to\n\tenable extended reloc counter.\n\t* coffswap.h: (coff_swap_scnhdr_in, coff_swap_scnhdr_out):\n\tDeclare with ATTRIBUTE_UNUSED.\n\t* libcoff-in.h: (struct coff_tdata): New field go32.\n\t(obj_go32): Define.\n\t* libcoff.h: Regenerate.",
    "tree": {
      "sha": "f0ce03676b17fac838ae086565b69b6be3f36b55",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f0ce03676b17fac838ae086565b69b6be3f36b55"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/comments",
  "author": {
    "login": "jmgdjgpp",
    "id": 19332534,
    "node_id": "MDQ6VXNlcjE5MzMyNTM0",
    "avatar_url": "https://avatars.githubusercontent.com/u/19332534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jmgdjgpp",
    "html_url": "https://github.com/jmgdjgpp",
    "followers_url": "https://api.github.com/users/jmgdjgpp/followers",
    "following_url": "https://api.github.com/users/jmgdjgpp/following{/other_user}",
    "gists_url": "https://api.github.com/users/jmgdjgpp/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jmgdjgpp/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jmgdjgpp/subscriptions",
    "organizations_url": "https://api.github.com/users/jmgdjgpp/orgs",
    "repos_url": "https://api.github.com/users/jmgdjgpp/repos",
    "events_url": "https://api.github.com/users/jmgdjgpp/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jmgdjgpp/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "06ca5dd49ac45e814ca167f441ac0b191b50bb37",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/06ca5dd49ac45e814ca167f441ac0b191b50bb37",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/06ca5dd49ac45e814ca167f441ac0b191b50bb37"
    }
  ],
  "stats": {
    "total": 278,
    "additions": 250,
    "deletions": 28
  },
  "files": [
    {
      "sha": "c3015012ab38cc27a7146eb1c802ac6806022f31",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
      "patch": "@@ -1,3 +1,29 @@\n+2020-04-14  Juan Manuel Guerrero  <juan.guerrero@gmx.de>\n+            Jan W. Jagersma  <jwjagersma@gmail.com>\n+\n+\t* coff-go32.c (COFF_GO32, IMAGE_SCN_LNK_NRELOC_OVFL)\n+\t(coff_SWAP_scnhdr_in, coff_SWAP_scnhdr_out): Define.\n+\t(_bfd_go32_swap_scnhdr_in, _bfd_go32_swap_scnhdr_out)\n+\t(_bfd_go32_mkobject): New functions.\n+\t* coff-stgo32.c (IMAGE_SCN_LNK_NRELOC_OVFL)\n+\t(coff_SWAP_scnhdr_in, coff_SWAP_scnhdr_out): Define.\n+\t(go32exe_mkobject): Call _bfd_go32_mkobject.\n+\t* coffcode.h (COFF_WITH_EXTENDED_RELOC_COUNTER): Define.\n+\t(coff_set_alignment_hook): Define function for COFF_GO32_EXE\n+\tand COFF_GO32.\n+\t(coff_write_relocs): Enable extended reloc counter code if\n+\tCOFF_WITH_EXTENDED_RELOC_COUNTER is defined.  Test for obj_go32.\n+\t(coff_write_object_contents): Likewise.  Pad section headers\n+\tfor COFF_GO32 and COFF_GO32EXE.  Use bfd_coff_swap_scnhdr_out\n+\tinstead of coff_swap_scnhdr_out.\n+\t* cofflink.c (_bfd_coff_final_link): Test also for obj_go32 to\n+\tenable extended reloc counter.\n+\t* coffswap.h: (coff_swap_scnhdr_in, coff_swap_scnhdr_out):\n+\tDeclare with ATTRIBUTE_UNUSED.\n+\t* libcoff-in.h: (struct coff_tdata): New field go32.\n+\t(obj_go32): Define.\n+\t* libcoff.h: Regenerate.\n+\n 2020-04-14  Fangrui Song  <maskray@google.com>\n \n \tPR gas/25768"
    },
    {
      "sha": "448769362a7db9586dbb720a38697258df384cc6",
      "filename": "bfd/coff-go32.c",
      "status": "modified",
      "additions": 134,
      "deletions": 0,
      "changes": 134,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/coff-go32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/coff-go32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-go32.c?ref=f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
      "patch": "@@ -22,6 +22,7 @@\n #define TARGET_SYM\t\ti386_coff_go32_vec\n #define TARGET_NAME\t\t\"coff-go32\"\n #define TARGET_UNDERSCORE\t'_'\n+#define COFF_GO32\n #define COFF_LONG_SECTION_NAMES\n #define COFF_SUPPORT_GNU_LINKONCE\n #define COFF_LONG_FILENAMES\n@@ -42,4 +43,137 @@\n { COFF_SECTION_NAME_PARTIAL_MATCH (\".gnu.linkonce.wi\"), \\\n   COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }\n \n+/* Section contains extended relocations. */\n+#define IMAGE_SCN_LNK_NRELOC_OVFL (0x01000000)\n+\n+#include \"sysdep.h\"\n+#include \"bfd.h\"\n+\n+/* The following functions are not static, because they are also\n+   used for coff-go32-exe (coff-stgo32.c).  */\n+bfd_boolean _bfd_go32_mkobject (bfd *);\n+void _bfd_go32_swap_scnhdr_in (bfd *, void *, void *);\n+unsigned int _bfd_go32_swap_scnhdr_out (bfd *, void *, void *);\n+\n+#define coff_mkobject _bfd_go32_mkobject\n+#define coff_SWAP_scnhdr_in _bfd_go32_swap_scnhdr_in\n+#define coff_SWAP_scnhdr_out _bfd_go32_swap_scnhdr_out\n+\n #include \"coff-i386.c\"\n+\n+bfd_boolean\n+_bfd_go32_mkobject (bfd * abfd)\n+{\n+  const bfd_size_type amt = sizeof (coff_data_type);\n+\n+  abfd->tdata.coff_obj_data = bfd_zalloc (abfd, amt);\n+  if (abfd->tdata.coff_obj_data == NULL)\n+    return FALSE;\n+\n+  coff_data (abfd)->go32 = TRUE;\n+\n+  return TRUE;\n+}\n+\n+void\n+_bfd_go32_swap_scnhdr_in (bfd * abfd, void * ext, void * in)\n+{\n+  SCNHDR *scnhdr_ext = (SCNHDR *) ext;\n+  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;\n+\n+  memcpy (scnhdr_int->s_name, scnhdr_ext->s_name, sizeof (scnhdr_int->s_name));\n+\n+  scnhdr_int->s_vaddr = GET_SCNHDR_VADDR (abfd, scnhdr_ext->s_vaddr);\n+  scnhdr_int->s_paddr = GET_SCNHDR_PADDR (abfd, scnhdr_ext->s_paddr);\n+  scnhdr_int->s_size = GET_SCNHDR_SIZE (abfd, scnhdr_ext->s_size);\n+\n+  scnhdr_int->s_scnptr = GET_SCNHDR_SCNPTR (abfd, scnhdr_ext->s_scnptr);\n+  scnhdr_int->s_relptr = GET_SCNHDR_RELPTR (abfd, scnhdr_ext->s_relptr);\n+  scnhdr_int->s_lnnoptr = GET_SCNHDR_LNNOPTR (abfd, scnhdr_ext->s_lnnoptr);\n+  scnhdr_int->s_flags = GET_SCNHDR_FLAGS (abfd, scnhdr_ext->s_flags);\n+  scnhdr_int->s_nreloc = GET_SCNHDR_NRELOC (abfd, scnhdr_ext->s_nreloc);\n+  scnhdr_int->s_nlnno = GET_SCNHDR_NLNNO (abfd, scnhdr_ext->s_nlnno);\n+\n+  /* DJGPP follows the same strategy as PE COFF.\n+     Iff the file is an executable then the higher 16 bits\n+     of the line number have been stored in the relocation\n+     counter field.  */\n+  if (abfd->flags & EXEC_P && (strcmp (scnhdr_ext->s_name, \".text\") == 0))\n+    {\n+      scnhdr_int->s_nlnno\n+\t= (GET_SCNHDR_NRELOC (abfd, scnhdr_ext->s_nreloc) << 16)\n+\t  + GET_SCNHDR_NLNNO (abfd, scnhdr_ext->s_nlnno);\n+      scnhdr_int->s_nreloc = 0;\n+    }\n+}\n+\n+unsigned int\n+_bfd_go32_swap_scnhdr_out (bfd * abfd, void * in, void * out)\n+{\n+  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;\n+  SCNHDR *scnhdr_ext = (SCNHDR *) out;\n+  unsigned int ret = bfd_coff_scnhsz (abfd);\n+\n+  memcpy (scnhdr_ext->s_name, scnhdr_int->s_name, sizeof (scnhdr_int->s_name));\n+\n+  PUT_SCNHDR_VADDR (abfd, scnhdr_int->s_vaddr, scnhdr_ext->s_vaddr);\n+  PUT_SCNHDR_PADDR (abfd, scnhdr_int->s_paddr, scnhdr_ext->s_paddr);\n+  PUT_SCNHDR_SIZE (abfd, scnhdr_int->s_size, scnhdr_ext->s_size);\n+  PUT_SCNHDR_SCNPTR (abfd, scnhdr_int->s_scnptr, scnhdr_ext->s_scnptr);\n+  PUT_SCNHDR_RELPTR (abfd, scnhdr_int->s_relptr, scnhdr_ext->s_relptr);\n+  PUT_SCNHDR_LNNOPTR (abfd, scnhdr_int->s_lnnoptr, scnhdr_ext->s_lnnoptr);\n+  PUT_SCNHDR_FLAGS (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);\n+\n+  if (abfd->flags & EXEC_P && (strcmp (scnhdr_int->s_name, \".text\") == 0))\n+    {\n+      /* DJGPP follows the same strategy as PE COFF.\n+\t By inference from looking at MS output, the 32 bit field\n+\t which is the combination of the number_of_relocs and\n+\t number_of_linenos is used for the line number count in\n+\t executables.  A 16-bit field won't do for cc1.  The MS\n+\t document says that the number of relocs is zero for\n+\t executables, but the 17-th bit has been observed to be there.\n+\t Overflow is not an issue: a 4G-line program will overflow a\n+\t bunch of other fields long before this!  */\n+      PUT_SCNHDR_NLNNO (abfd, (scnhdr_int->s_nlnno & 0xffff),\n+\t\t\tscnhdr_ext->s_nlnno);\n+      PUT_SCNHDR_NRELOC (abfd, (scnhdr_int->s_nlnno >> 16),\n+\t\t\t scnhdr_ext->s_nreloc);\n+    }\n+  else\n+    {\n+      /* DJGPP follows the same strategy as PE COFF.  */\n+      if (scnhdr_int->s_nlnno <= MAX_SCNHDR_NLNNO)\n+\tPUT_SCNHDR_NLNNO (abfd, scnhdr_int->s_nlnno, scnhdr_ext->s_nlnno);\n+      else\n+\t{\n+\t  char buf[sizeof (scnhdr_int->s_name) + 1];\n+\n+\t  memcpy (buf, scnhdr_int->s_name, sizeof (scnhdr_int->s_name));\n+\t  buf[sizeof (scnhdr_int->s_name)] = '\\0';\n+\t  _bfd_error_handler\n+\t    /* xgettext:c-format */\n+\t    (_(\"%pB: warning: %s: line number overflow: 0x%lx > 0xffff\"),\n+\t     abfd, buf, scnhdr_int->s_nlnno);\n+\t  bfd_set_error (bfd_error_file_truncated);\n+\t  PUT_SCNHDR_NLNNO (abfd, 0xffff, scnhdr_ext->s_nlnno);\n+\t  ret = 0;\n+\t}\n+\n+      /* Although we could encode 0xffff relocs here, we do not, to be\n+\t consistent with other parts of bfd.  Also it lets us warn, as\n+\t we should never see 0xffff here w/o having the overflow flag\n+\t set.  */\n+      if (scnhdr_int->s_nreloc < MAX_SCNHDR_NRELOC)\n+\tPUT_SCNHDR_NRELOC (abfd, scnhdr_int->s_nreloc, scnhdr_ext->s_nreloc);\n+      else\n+\t{\n+\t  /* DJGPP can deal with large #s of relocs, but not here.  */\n+\t  PUT_SCNHDR_NRELOC (abfd, 0xffff, scnhdr_ext->s_nreloc);\n+\t  scnhdr_int->s_flags |= IMAGE_SCN_LNK_NRELOC_OVFL;\n+\t  PUT_SCNHDR_FLAGS (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);\n+\t}\n+    }\n+\n+  return ret;\n+}"
    },
    {
      "sha": "0fea119fc494ddc97ce6044eb07a4c3b893be493",
      "filename": "bfd/coff-stgo32.c",
      "status": "modified",
      "additions": 14,
      "deletions": 16,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/coff-stgo32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/coff-stgo32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-stgo32.c?ref=f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
      "patch": "@@ -46,6 +46,9 @@\n { COFF_SECTION_NAME_PARTIAL_MATCH (\".gnu.linkonce.wi\"), \\\n   COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }\n \n+/* Section contains extended relocations. */\n+#define IMAGE_SCN_LNK_NRELOC_OVFL (0x01000000)\n+\n #include \"sysdep.h\"\n #include \"bfd.h\"\n #include \"coff/msdos.h\"\n@@ -55,10 +58,17 @@ static bfd_boolean go32exe_write_object_contents (bfd *);\n static bfd_boolean go32exe_mkobject (bfd *);\n static bfd_boolean go32exe_copy_private_bfd_data (bfd *, bfd *);\n \n+/* Defined in coff-go32.c.  */\n+bfd_boolean _bfd_go32_mkobject (bfd *);\n+void _bfd_go32_swap_scnhdr_in (bfd *, void *, void *);\n+unsigned int _bfd_go32_swap_scnhdr_out (bfd *, void *, void *);\n+\n #define COFF_CHECK_FORMAT go32exe_check_format\n #define COFF_WRITE_CONTENTS go32exe_write_object_contents\n #define coff_mkobject go32exe_mkobject\n #define coff_bfd_copy_private_bfd_data go32exe_copy_private_bfd_data\n+#define coff_SWAP_scnhdr_in _bfd_go32_swap_scnhdr_in\n+#define coff_SWAP_scnhdr_out _bfd_go32_swap_scnhdr_out\n \n #include \"coff-i386.c\"\n \n@@ -352,32 +362,20 @@ go32exe_write_object_contents (bfd *abfd)\n static bfd_boolean\n go32exe_mkobject (bfd *abfd)\n {\n-  coff_data_type *coff = NULL;\n-  const bfd_size_type amt = sizeof (coff_data_type);\n-\n   /* Don't output to an archive.  */\n   if (abfd->my_archive != NULL)\n     return FALSE;\n \n-  abfd->tdata.coff_obj_data = bfd_zalloc (abfd, amt);\n-  if (abfd->tdata.coff_obj_data == NULL)\n+  if (!_bfd_go32_mkobject (abfd))\n     return FALSE;\n-  coff = coff_data (abfd);\n-  coff->symbols = NULL;\n-  coff->conversion_table = NULL;\n-  coff->raw_syments = NULL;\n-  coff->relocbase = 0;\n-  coff->local_toc_sym_map = 0;\n \n   go32exe_create_stub (abfd);\n-  if (coff->stub == NULL)\n+  if (coff_data (abfd)->stub == NULL)\n     {\n-      bfd_release (abfd, coff);\n+      bfd_release (abfd, coff_data (abfd));\n       return FALSE;\n     }\n-  abfd->origin = coff->stub_size;\n-\n-/*  make_abs_section(abfd);*/ /* ??? */\n+  abfd->origin = coff_data (abfd)->stub_size;\n \n   return TRUE;\n }"
    },
    {
      "sha": "c6569ec9cd45ba095ed08d1cbd7f0cdb05b7abcd",
      "filename": "bfd/coffcode.h",
      "status": "modified",
      "additions": 62,
      "deletions": 8,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/coffcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/coffcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffcode.h?ref=f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
      "patch": "@@ -364,6 +364,10 @@ CODE_FRAGMENT\n #define GNU_LINKONCE_WT \".gnu.linkonce.wt.\"\n #define DOT_RELOC\t\".reloc\"\n \n+#if defined(COFF_WITH_PE) || defined(COFF_GO32_EXE) || defined(COFF_GO32)\n+# define COFF_WITH_EXTENDED_RELOC_COUNTER\n+#endif\n+\n #if defined (COFF_LONG_SECTION_NAMES)\n /* Needed to expand the inputs to BLANKOR1TOODD.  */\n #define COFFLONGSECTIONCATHELPER(x,y)    x ## y\n@@ -1964,6 +1968,39 @@ coff_set_alignment_hook (bfd *abfd, asection *section, void * scnhdr)\n }\n \n #else /* ! RS6000COFF_C */\n+#if defined (COFF_GO32_EXE) || defined (COFF_GO32)\n+\n+static void\n+coff_set_alignment_hook (bfd * abfd, asection * section, void * scnhdr)\n+{\n+  struct internal_scnhdr *hdr = (struct internal_scnhdr *) scnhdr;\n+\n+  /* Check for extended relocs.  */\n+  if (hdr->s_flags & IMAGE_SCN_LNK_NRELOC_OVFL)\n+    {\n+      struct external_reloc dst;\n+      struct internal_reloc n;\n+      const file_ptr oldpos = bfd_tell (abfd);\n+      const bfd_size_type relsz = bfd_coff_relsz (abfd);\n+\n+      if (bfd_seek (abfd, (file_ptr) hdr->s_relptr, 0) != 0)\n+\treturn;\n+      if (bfd_bread (& dst, relsz, abfd) != relsz)\n+\treturn;\n+\n+      coff_swap_reloc_in (abfd, &dst, &n);\n+      if (bfd_seek (abfd, oldpos, 0) != 0)\n+\treturn;\n+      section->reloc_count = hdr->s_nreloc = n.r_vaddr - 1;\n+      section->rel_filepos += relsz;\n+    }\n+  else if (hdr->s_nreloc == 0xffff)\n+    _bfd_error_handler\n+      (_(\"%pB: warning: claims to have 0xffff relocs, without overflow\"),\n+       abfd);\n+}\n+\n+#else /* ! COFF_GO32_EXE && ! COFF_GO32 */\n \n static void\n coff_set_alignment_hook (bfd *abfd ATTRIBUTE_UNUSED,\n@@ -1972,6 +2009,7 @@ coff_set_alignment_hook (bfd *abfd ATTRIBUTE_UNUSED,\n {\n }\n \n+#endif /* ! COFF_GO32_EXE && ! COFF_GO32 */\n #endif /* ! RS6000COFF_C */\n #endif /* ! COFF_WITH_PE */\n #endif /* ! COFF_ALIGN_IN_SECTION_HEADER */\n@@ -2521,8 +2559,8 @@ coff_write_relocs (bfd * abfd, int first_undef)\n       if (bfd_seek (abfd, s->rel_filepos, SEEK_SET) != 0)\n \treturn FALSE;\n \n-#ifdef COFF_WITH_PE\n-      if (obj_pe (abfd) && s->reloc_count >= 0xffff)\n+#ifdef COFF_WITH_EXTENDED_RELOC_COUNTER\n+      if ((obj_pe (abfd) || obj_go32 (abfd)) && s->reloc_count >= 0xffff)\n \t{\n \t  /* Encode real count here as first reloc.  */\n \t  struct internal_reloc n;\n@@ -3382,9 +3420,9 @@ coff_write_object_contents (bfd * abfd)\n   for (current = abfd->sections; current != NULL; current =\n        current->next)\n     {\n-#ifdef COFF_WITH_PE\n+#ifdef COFF_WITH_EXTENDED_RELOC_COUNTER\n       /* We store the actual reloc count in the first reloc's addr.  */\n-      if (obj_pe (abfd) && current->reloc_count >= 0xffff)\n+      if ((obj_pe (abfd) || obj_go32 (abfd)) && current->reloc_count >= 0xffff)\n \treloc_count ++;\n #endif\n       reloc_count += current->reloc_count;\n@@ -3412,9 +3450,9 @@ coff_write_object_contents (bfd * abfd)\n \t{\n \t  current->rel_filepos = reloc_base;\n \t  reloc_base += current->reloc_count * bfd_coff_relsz (abfd);\n-#ifdef COFF_WITH_PE\n+#ifdef COFF_WITH_EXTENDED_RELOC_COUNTER\n \t  /* Extra reloc to hold real count.  */\n-\t  if (obj_pe (abfd) && current->reloc_count >= 0xffff)\n+\t  if ((obj_pe (abfd) || obj_go32 (abfd)) && current->reloc_count >= 0xffff)\n \t    reloc_base += bfd_coff_relsz (abfd);\n #endif\n \t}\n@@ -3615,7 +3653,7 @@ coff_write_object_contents (bfd * abfd)\n \t  SCNHDR buff;\n \t  bfd_size_type amt = bfd_coff_scnhsz (abfd);\n \n-\t  if (coff_swap_scnhdr_out (abfd, &section, &buff) == 0\n+\t  if (bfd_coff_swap_scnhdr_out (abfd, &section, &buff) == 0\n \t      || bfd_bwrite (& buff, amt, abfd) != amt)\n \t    return FALSE;\n \t}\n@@ -3741,14 +3779,30 @@ coff_write_object_contents (bfd * abfd)\n \t  scnhdr.s_nlnno = current->target_index;\n \t  scnhdr.s_flags = STYP_OVRFLO;\n \t  amt = bfd_coff_scnhsz (abfd);\n-\t  if (coff_swap_scnhdr_out (abfd, &scnhdr, &buff) == 0\n+\t  if (bfd_coff_swap_scnhdr_out (abfd, &scnhdr, &buff) == 0\n \t      || bfd_bwrite (& buff, amt, abfd) != amt)\n \t    return FALSE;\n \t}\n     }\n #endif\n #endif\n \n+#if defined (COFF_GO32_EXE) || defined (COFF_GO32)\n+  /* Pad section headers.  */\n+  if ((abfd->flags & EXEC_P) && abfd->sections != NULL)\n+    {\n+      file_ptr cur_ptr = scn_base\n+\t\t\t + abfd->section_count * bfd_coff_scnhsz (abfd);\n+      long fill_size = (abfd->sections->filepos - cur_ptr);\n+      bfd_byte *b = bfd_zmalloc (fill_size);\n+      if (b)\n+\t{\n+\t  bfd_bwrite ((PTR)b, fill_size, abfd);\n+\t  free (b);\n+\t}\n+    }\n+#endif\n+\n   /* OK, now set up the filehdr...  */\n \n   /* Don't include the internal abs section in the section count */"
    },
    {
      "sha": "0beff8397faf0b9ad06fce890c9f16d19a64c0dc",
      "filename": "bfd/cofflink.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/cofflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/cofflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cofflink.c?ref=f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
      "patch": "@@ -689,7 +689,7 @@ _bfd_coff_final_link (bfd *abfd,\n \t  rel_filepos += o->reloc_count * relsz;\n \t  /* In PE COFF, if there are at least 0xffff relocations an\n \t     extra relocation will be written out to encode the count.  */\n-\t  if (obj_pe (abfd) && o->reloc_count >= 0xffff)\n+\t  if ((obj_pe (abfd) || obj_go32 (abfd)) && o->reloc_count >= 0xffff)\n \t    rel_filepos += relsz;\n \t}\n \n@@ -1108,7 +1108,7 @@ _bfd_coff_final_link (bfd *abfd,\n \n \t  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0)\n \t    goto error_return;\n-\t  if (obj_pe (abfd) && o->reloc_count >= 0xffff)\n+\t  if ((obj_pe (abfd) || obj_go32 (abfd)) && o->reloc_count >= 0xffff)\n \t    {\n \t      /* In PE COFF, write the count of relocs as the first\n \t\t reloc.  The header overflow bit will be set"
    },
    {
      "sha": "7c0be221075f3668fa9d227bbd67964d363528cc",
      "filename": "bfd/coffswap.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/coffswap.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/coffswap.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffswap.h?ref=f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
      "patch": "@@ -725,6 +725,7 @@ coff_swap_aouthdr_out (bfd * abfd, void * in, void * out)\n   return AOUTSZ;\n }\n \n+ATTRIBUTE_UNUSED\n static void\n coff_swap_scnhdr_in (bfd * abfd, void * ext, void * in)\n {\n@@ -751,6 +752,7 @@ coff_swap_scnhdr_in (bfd * abfd, void * ext, void * in)\n #endif\n }\n \n+ATTRIBUTE_UNUSED\n static unsigned int\n coff_swap_scnhdr_out (bfd * abfd, void * in, void * out)\n {"
    },
    {
      "sha": "3f0227c4acf8d571e412ab4068c333dbac97770b",
      "filename": "bfd/libcoff-in.h",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/libcoff-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/libcoff-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libcoff-in.h?ref=f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
      "patch": "@@ -33,8 +33,9 @@ extern \"C\" {\n \n #define coff_data(bfd)\t\t      ((bfd)->tdata.coff_obj_data)\n #define obj_pe(bfd)\t\t      (coff_data (bfd)->pe)\n+#define obj_go32(bfd)\t\t      (coff_data (bfd)->go32)\n #define obj_symbols(bfd)\t      (coff_data (bfd)->symbols)\n-#define\tobj_sym_filepos(bfd)\t      (coff_data (bfd)->sym_filepos)\n+#define obj_sym_filepos(bfd)\t      (coff_data (bfd)->sym_filepos)\n #define obj_relocbase(bfd)\t      (coff_data (bfd)->relocbase)\n #define obj_raw_syments(bfd)\t      (coff_data (bfd)->raw_syments)\n #define obj_raw_syment_count(bfd)     (coff_data (bfd)->raw_syment_count)\n@@ -114,6 +115,9 @@ typedef struct coff_tdata\n      used by ARM code.  */\n   flagword flags;\n \n+  /* Is this a GO32 coff file?  */\n+  bfd_boolean go32;\n+\n   /* A stub (extra data prepended before the COFF image) and its size.\n      Used by coff-go32-exe, it contains executable data that loads the\n      COFF object into memory.  */"
    },
    {
      "sha": "d7e0548bc504b5a6af5177c608f1cc830f148f89",
      "filename": "bfd/libcoff.h",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/libcoff.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f717994fe84df26ec4e4fe4104e018ece8b5b9cf/bfd/libcoff.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libcoff.h?ref=f717994fe84df26ec4e4fe4104e018ece8b5b9cf",
      "patch": "@@ -37,8 +37,9 @@ extern \"C\" {\n \n #define coff_data(bfd)\t\t      ((bfd)->tdata.coff_obj_data)\n #define obj_pe(bfd)\t\t      (coff_data (bfd)->pe)\n+#define obj_go32(bfd)\t\t      (coff_data (bfd)->go32)\n #define obj_symbols(bfd)\t      (coff_data (bfd)->symbols)\n-#define\tobj_sym_filepos(bfd)\t      (coff_data (bfd)->sym_filepos)\n+#define obj_sym_filepos(bfd)\t      (coff_data (bfd)->sym_filepos)\n #define obj_relocbase(bfd)\t      (coff_data (bfd)->relocbase)\n #define obj_raw_syments(bfd)\t      (coff_data (bfd)->raw_syments)\n #define obj_raw_syment_count(bfd)     (coff_data (bfd)->raw_syment_count)\n@@ -118,6 +119,9 @@ typedef struct coff_tdata\n      used by ARM code.  */\n   flagword flags;\n \n+  /* Is this a GO32 coff file?  */\n+  bfd_boolean go32;\n+\n   /* A stub (extra data prepended before the COFF image) and its size.\n      Used by coff-go32-exe, it contains executable data that loads the\n      COFF object into memory.  */"
    }
  ]
}