{
  "sha": "725cbb63263d27e87f5a4f9b73281e7710de53e4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzI1Y2JiNjMyNjNkMjdlODdmNWE0ZjliNzMyODFlNzcxMGRlNTNlNA==",
  "commit": {
    "author": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2019-04-25T20:05:51Z"
    },
    "committer": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2019-04-25T20:06:52Z"
    },
    "message": "c++/24367: Infinite recursion of typedef substitution\n\nThis bug finds another usage where we end up segfaulting while\nnormalizing user input.  inspect_type and replace_type recurse,\nattempting to substitute the \"real\" symbol name for the typedef name.\nHowever, since the both these names are the same, they keep calling\neach other until the stack overflows.\n\nA simple reproducer for it is given by\n\n  typedef struct foo foo;\n  int qux (foo *f) { return 0; }\n\n  (gdb) b qux(foo*)\n  Segmentation fault\n\ninspect_type already contains some special handling to prevent a\nsimilar situation from occurring with namespaces.  I wonder, however,\nwhether we need be so pedantic about the exact nature of the substitution.\n\nThis patch implements this rather more aggressive assumption that these\nsubstitutions should be avoided whenever the replacement symbol's name is\nexactly the same as the one we're trying to substitute.  [In the above\nexample, we're trying to substitute the tyepdef named \"foo\" with the symbol\nnamed \"foo\" (a struct).]\n\ngdb/ChangeLog:\n\n\tPR c++/24367\n\t* cp-support.c (inspect_type): Don't attempt substitutions\n\tof symbol with the same name.\n\ngdb/testsuite/ChangeLog:\n\n\tPR c++/24367\n\t* gdb.cp/meth-typedefs.cc (incomplete_struct)\n\t(another_incomplete_struct, test_incomplete): New definitions.\n\t(main): Use new definitions.\n\t* gdb.cp/meth-typedefs.exp: Add new tests for `test_incomplete'\n\tfunctions.",
    "tree": {
      "sha": "60962bd09743ddf401e082ceee91b5688d319a61",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/60962bd09743ddf401e082ceee91b5688d319a61"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/725cbb63263d27e87f5a4f9b73281e7710de53e4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/725cbb63263d27e87f5a4f9b73281e7710de53e4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/725cbb63263d27e87f5a4f9b73281e7710de53e4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/725cbb63263d27e87f5a4f9b73281e7710de53e4/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "3d1cbb78936fbf2985ffd2ebf074841599ead788",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3d1cbb78936fbf2985ffd2ebf074841599ead788",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3d1cbb78936fbf2985ffd2ebf074841599ead788"
    }
  ],
  "stats": {
    "total": 49,
    "additions": 46,
    "deletions": 3
  },
  "files": [
    {
      "sha": "e0120e7743fa8c77cb680a3f460acc1721064df4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=725cbb63263d27e87f5a4f9b73281e7710de53e4",
      "patch": "@@ -1,3 +1,9 @@\n+2019-04-25  Keith Seitz  <keiths@redhat.com>\n+\n+\tPR c++/24367\n+\t* cp-support.c (inspect_type): Don't attempt substitutions\n+\tof symbol with the same name.\n+\n 2019-04-25  Tom Tromey  <tromey@adacore.com>\n \n \tPR gdb/24475:"
    },
    {
      "sha": "4afb79a4ea9d032b23e9a49e7f5ee2bae90f10cd",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 13,
      "deletions": 3,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=725cbb63263d27e87f5a4f9b73281e7710de53e4",
      "patch": "@@ -190,10 +190,20 @@ inspect_type (struct demangle_parse_info *info,\n \t  /* Get the real type of the typedef.  */\n \t  type = check_typedef (otype);\n \n-\t  /* If the symbol is a namespace and its type name is no different\n+\t  /* If the symbol name is the same as the original type name,\n+\t     don't substitute.  That would cause infinite recursion in\n+\t     symbol lookups, as the typedef symbol is often the first\n+\t     found symbol in the symbol table.\n+\n+\t     However, this can happen in a number of situations, such as:\n+\n+\t     If the symbol is a namespace and its type name is no different\n \t     than the name we looked up, this symbol is not a namespace\n-\t     alias and does not need to be substituted.  */\n-\t  if (TYPE_CODE (otype) == TYPE_CODE_NAMESPACE\n+\t     alias and does not need to be substituted.\n+\n+\t     If the symbol is typedef and its type name is the same\n+\t     as the symbol's name, e.g., \"typedef struct foo foo;\".  */\n+\t  if (TYPE_NAME (type) != nullptr\n \t      && strcmp (TYPE_NAME (type), name) == 0)\n \t    return 0;\n "
    },
    {
      "sha": "9b0725a0335b046430b288d1d9f5fa4369f4a0cb",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=725cbb63263d27e87f5a4f9b73281e7710de53e4",
      "patch": "@@ -1,3 +1,12 @@\n+2019-04-25  Keith Seitz  <keiths@redhat.com>\n+\n+\tPR c++/24367\n+\t* gdb.cp/meth-typedefs.cc (incomplete_struct)\n+\t(another_incomplete_struct, test_incomplete): New definitions.\n+\t(main): Use new definitions.\n+\t* gdb.cp/meth-typedefs.exp: Add new tests for `test_incomplete'\n+\tfunctions.\n+\n 2019-04-25  Sergio Durigan Junior  <sergiodj@redhat.com>\n \n \tPR corefiles/11608"
    },
    {
      "sha": "f65478e8c0f250057e83c824051ef4b390f0f5c9",
      "filename": "gdb/testsuite/gdb.cp/meth-typedefs.cc",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/testsuite/gdb.cp/meth-typedefs.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/testsuite/gdb.cp/meth-typedefs.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/meth-typedefs.cc?ref=725cbb63263d27e87f5a4f9b73281e7710de53e4",
      "patch": "@@ -36,6 +36,13 @@ typedef void (*fptr2) (fptr1, my_other_type_2);\n typedef void (*fptr3) (fptr2, my_other_type);\n typedef void (*fptr4) (anon_enum a, anon_struct const& b, anon_union const*** c);\n \n+// For c++/24367 testing\n+typedef struct incomplete_struct incomplete_struct;\n+typedef struct _incomplete_struct another_incomplete_struct;\n+int test_incomplete (incomplete_struct *p) { return 0; } // test_incomplete(incomplete_struct*)\n+int test_incomplete (another_incomplete_struct *p) { return 1; } // test_incomplete(another_incomplete_struct*)\n+int test_incomplete (int *p) { return -1; } // test_incomplete(int*)\n+\n namespace A\n {\n   class foo\n@@ -147,5 +154,11 @@ main (void)\n \n   fptr4 f4;\n \n+  // Tests for c++/24367\n+  int *i = nullptr;\n+  incomplete_struct *is = nullptr;\n+  another_incomplete_struct *ais = nullptr;\n+  int result = (test_incomplete (i) + test_incomplete (is)\n+\t\t+ test_incomplete (ais));\n   return 0;\n }"
    },
    {
      "sha": "76a8fc9780826e1b23ff0aca9ca271671761db64",
      "filename": "gdb/testsuite/gdb.cp/meth-typedefs.exp",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/testsuite/gdb.cp/meth-typedefs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/725cbb63263d27e87f5a4f9b73281e7710de53e4/gdb/testsuite/gdb.cp/meth-typedefs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/meth-typedefs.exp?ref=725cbb63263d27e87f5a4f9b73281e7710de53e4",
      "patch": "@@ -137,6 +137,11 @@ foreach t $typedefs(_BAR_) {\n     add methods \"test\" \"$t&\" {_BAR_&}\n }\n \n+# Tests for c++/24367\n+foreach t {int incomplete_struct another_incomplete_struct} {\n+    add methods \"test_incomplete\" \"${t}*\" [string_to_regexp \"${t}*\"]\n+}\n+\n gdb_test_no_output \"set listsize 1\" \"\"\n \n # Finally, for each method in the list METHODS, check whether"
    }
  ]
}