{
  "sha": "b437bfe0f4cf06559ca4c508a2869383196ddc6b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjQzN2JmZTBmNGNmMDY1NTljYTRjNTA4YTI4NjkzODMxOTZkZGM2Yg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-24T10:15:33Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:08:19Z"
    },
    "message": "libctf: lookups by name and symbol\n\nThese functions allow you to look up types given a name in a simple\nsubset of C declarator syntax (no function pointers), to look up the\ntypes of variables given a name, and to look up the types of data\nobjects and the type signatures of functions given symbol table offsets.\n\n(Despite its name, one function in this commit, ctf_lookup_symbol_name(),\nis for the internal use of libctf only, and does not appear in any\npublic header files.)\n\nlibctf/\n\t* ctf-lookup.c (isqualifier): New.\n\t(ctf_lookup_by_name): Likewise.\n\t(struct ctf_lookup_var_key): Likewise.\n\t(ctf_lookup_var): Likewise.\n\t(ctf_lookup_variable): Likewise.\n\t(ctf_lookup_symbol_name): Likewise.\n\t(ctf_lookup_by_symbol): Likewise.\n\t(ctf_func_info): Likewise.\n\t(ctf_func_args): Likewise.\n\ninclude/\n\t* ctf-api.h (ctf_func_info): New.\n\t(ctf_func_args): Likewise.\n\t(ctf_lookup_by_symbol): Likewise.\n\t(ctf_lookup_by_symbol): Likewise.\n\t(ctf_lookup_variable): Likewise.",
    "tree": {
      "sha": "295fe61f500d0ad7e248c795829384fbbf382e37",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/295fe61f500d0ad7e248c795829384fbbf382e37"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b437bfe0f4cf06559ca4c508a2869383196ddc6b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b437bfe0f4cf06559ca4c508a2869383196ddc6b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b437bfe0f4cf06559ca4c508a2869383196ddc6b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b437bfe0f4cf06559ca4c508a2869383196ddc6b/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "316afdb130346e44622229793d1fb8d391059f8d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/316afdb130346e44622229793d1fb8d391059f8d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/316afdb130346e44622229793d1fb8d391059f8d"
    }
  ],
  "stats": {
    "total": 392,
    "additions": 392,
    "deletions": 0
  },
  "files": [
    {
      "sha": "4be07a55319bfce7382abe33ca36e1c76a9f9ad1",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b437bfe0f4cf06559ca4c508a2869383196ddc6b/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b437bfe0f4cf06559ca4c508a2869383196ddc6b/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=b437bfe0f4cf06559ca4c508a2869383196ddc6b",
      "patch": "@@ -1,3 +1,11 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_func_info): New.\n+\t(ctf_func_args): Likewise.\n+\t(ctf_lookup_by_symbol): Likewise.\n+\t(ctf_lookup_by_symbol): Likewise.\n+\t(ctf_lookup_variable): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_visit_f): New definition."
    },
    {
      "sha": "045d8af19054a71cfa1a25e59b231c3fc849aa09",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b437bfe0f4cf06559ca4c508a2869383196ddc6b/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b437bfe0f4cf06559ca4c508a2869383196ddc6b/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=b437bfe0f4cf06559ca4c508a2869383196ddc6b",
      "patch": "@@ -270,6 +270,13 @@ extern void *ctf_getspecific (ctf_file_t *);\n extern int ctf_errno (ctf_file_t *);\n extern const char *ctf_errmsg (int);\n \n+extern int ctf_func_info (ctf_file_t *, unsigned long, ctf_funcinfo_t *);\n+extern int ctf_func_args (ctf_file_t *, unsigned long, uint32_t, ctf_id_t *);\n+\n+extern ctf_id_t ctf_lookup_by_name (ctf_file_t *, const char *);\n+extern ctf_id_t ctf_lookup_by_symbol (ctf_file_t *, unsigned long);\n+extern ctf_id_t ctf_lookup_variable (ctf_file_t *, const char *);\n+\n extern ctf_id_t ctf_type_resolve (ctf_file_t *, ctf_id_t);\n extern char *ctf_type_aname (ctf_file_t *, ctf_id_t);\n extern ssize_t ctf_type_lname (ctf_file_t *, ctf_id_t, char *, size_t);"
    },
    {
      "sha": "93209d0b4097cae895d2b446dcc300d3d1174f75",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b437bfe0f4cf06559ca4c508a2869383196ddc6b/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b437bfe0f4cf06559ca4c508a2869383196ddc6b/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=b437bfe0f4cf06559ca4c508a2869383196ddc6b",
      "patch": "@@ -1,3 +1,15 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-lookup.c (isqualifier): New.\n+\t(ctf_lookup_by_name): Likewise.\n+\t(struct ctf_lookup_var_key): Likewise.\n+\t(ctf_lookup_var): Likewise.\n+\t(ctf_lookup_variable): Likewise.\n+\t(ctf_lookup_symbol_name): Likewise.\n+\t(ctf_lookup_by_symbol): Likewise.\n+\t(ctf_func_info): Likewise.\n+\t(ctf_func_args): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-decl.c: New file."
    },
    {
      "sha": "ff185049f91fad35da9756614c5de9122f771657",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b437bfe0f4cf06559ca4c508a2869383196ddc6b/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b437bfe0f4cf06559ca4c508a2869383196ddc6b/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=b437bfe0f4cf06559ca4c508a2869383196ddc6b",
      "patch": "@@ -368,6 +368,7 @@ extern void ctf_dprintf (const char *, ...);\n extern void libctf_init_debug (void);\n \n extern Elf64_Sym *ctf_sym_to_elf64 (const Elf32_Sym *src, Elf64_Sym *dst);\n+extern const char *ctf_lookup_symbol_name (ctf_file_t *fp, unsigned long symidx);\n \n /* Variables, all underscore-prepended. */\n "
    },
    {
      "sha": "7ea46a7295b10fc755b0fa040b7585c4180f512c",
      "filename": "libctf/ctf-lookup.c",
      "status": "modified",
      "additions": 364,
      "deletions": 0,
      "changes": 364,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b437bfe0f4cf06559ca4c508a2869383196ddc6b/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b437bfe0f4cf06559ca4c508a2869383196ddc6b/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=b437bfe0f4cf06559ca4c508a2869383196ddc6b",
      "patch": "@@ -21,6 +21,290 @@\n #include <elf.h>\n #include <string.h>\n \n+/* Compare the given input string and length against a table of known C storage\n+   qualifier keywords.  We just ignore these in ctf_lookup_by_name, below.  To\n+   do this quickly, we use a pre-computed Perfect Hash Function similar to the\n+   technique originally described in the classic paper:\n+\n+   R.J. Cichelli, \"Minimal Perfect Hash Functions Made Simple\",\n+   Communications of the ACM, Volume 23, Issue 1, January 1980, pp. 17-19.\n+\n+   For an input string S of length N, we use hash H = S[N - 1] + N - 105, which\n+   for the current set of qualifiers yields a unique H in the range [0 .. 20].\n+   The hash can be modified when the keyword set changes as necessary.  We also\n+   store the length of each keyword and check it prior to the final strcmp().\n+\n+   TODO: just use gperf.  */\n+\n+static int\n+isqualifier (const char *s, size_t len)\n+{\n+  static const struct qual\n+  {\n+    const char *q_name;\n+    size_t q_len;\n+  } qhash[] = {\n+    {\"static\", 6}, {\"\", 0}, {\"\", 0}, {\"\", 0},\n+    {\"volatile\", 8}, {\"\", 0}, {\"\", 0}, {\"\", 0}, {\"\", 0},\n+    {\"\", 0}, {\"auto\", 4}, {\"extern\", 6}, {\"\", 0}, {\"\", 0},\n+    {\"\", 0}, {\"\", 0}, {\"const\", 5}, {\"register\", 8},\n+    {\"\", 0}, {\"restrict\", 8}, {\"_Restrict\", 9}\n+  };\n+\n+  int h = s[len - 1] + (int) len - 105;\n+  const struct qual *qp = &qhash[h];\n+\n+  return (h >= 0 && (size_t) h < sizeof (qhash) / sizeof (qhash[0])\n+\t  && (size_t) len == qp->q_len &&\n+\t  strncmp (qp->q_name, s, qp->q_len) == 0);\n+}\n+\n+/* Attempt to convert the given C type name into the corresponding CTF type ID.\n+   It is not possible to do complete and proper conversion of type names\n+   without implementing a more full-fledged parser, which is necessary to\n+   handle things like types that are function pointers to functions that\n+   have arguments that are function pointers, and fun stuff like that.\n+   Instead, this function implements a very simple conversion algorithm that\n+   finds the things that we actually care about: structs, unions, enums,\n+   integers, floats, typedefs, and pointers to any of these named types.  */\n+\n+ctf_id_t\n+ctf_lookup_by_name (ctf_file_t *fp, const char *name)\n+{\n+  static const char delimiters[] = \" \\t\\n\\r\\v\\f*\";\n+\n+  const ctf_lookup_t *lp;\n+  const char *p, *q, *end;\n+  ctf_id_t type = 0;\n+  ctf_id_t ntype, ptype;\n+\n+  if (name == NULL)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  for (p = name, end = name + strlen (name); *p != '\\0'; p = q)\n+    {\n+      while (isspace (*p))\n+\tp++;\t\t\t/* Skip leading whitespace.  */\n+\n+      if (p == end)\n+\tbreak;\n+\n+      if ((q = strpbrk (p + 1, delimiters)) == NULL)\n+\tq = end;\t\t/* Compare until end.  */\n+\n+      if (*p == '*')\n+\t{\n+\t  /* Find a pointer to type by looking in fp->ctf_ptrtab.\n+\t     If we can't find a pointer to the given type, see if\n+\t     we can compute a pointer to the type resulting from\n+\t     resolving the type down to its base type and use\n+\t     that instead.  This helps with cases where the CTF\n+\t     data includes \"struct foo *\" but not \"foo_t *\" and\n+\t     the user tries to access \"foo_t *\" in the debugger.\n+\n+\t     TODO need to handle parent containers too.  */\n+\n+\t  ntype = fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, type)];\n+\t  if (ntype == 0)\n+\t    {\n+\t      ntype = ctf_type_resolve_unsliced (fp, type);\n+\t      if (ntype == CTF_ERR\n+\t\t  || (ntype =\n+\t\t      fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, ntype)]) == 0)\n+\t\t{\n+\t\t  (void) ctf_set_errno (fp, ECTF_NOTYPE);\n+\t\t  goto err;\n+\t\t}\n+\t    }\n+\n+\t  type = LCTF_INDEX_TO_TYPE (fp, ntype, (fp->ctf_flags & LCTF_CHILD));\n+\n+\t  q = p + 1;\n+\t  continue;\n+\t}\n+\n+      if (isqualifier (p, (size_t) (q - p)))\n+\tcontinue;\t\t/* Skip qualifier keyword.  */\n+\n+      for (lp = fp->ctf_lookups; lp->ctl_prefix != NULL; lp++)\n+\t{\n+\t  /* TODO: This is not MT-safe.  */\n+\t  if ((lp->ctl_prefix[0] == '\\0' ||\n+\t       strncmp (p, lp->ctl_prefix, (size_t) (q - p)) == 0) &&\n+\t      (size_t) (q - p) >= lp->ctl_len)\n+\t    {\n+\t      for (p += lp->ctl_len; isspace (*p); p++)\n+\t\tcontinue;\t/* Skip prefix and next whitespace.  */\n+\n+\t      if ((q = strchr (p, '*')) == NULL)\n+\t\tq = end;\t/* Compare until end.  */\n+\n+\t      while (isspace (q[-1]))\n+\t\tq--;\t\t/* Exclude trailing whitespace.  */\n+\n+\t      /* Expand and/or allocate storage for a slice of the name, then\n+\t\t copy it in.  */\n+\n+\t      if (fp->ctf_tmp_typeslicelen >= (size_t) (q - p) + 1)\n+\t\t{\n+\t\t  memcpy (fp->ctf_tmp_typeslice, p, (size_t) (q - p));\n+\t\t  fp->ctf_tmp_typeslice[(size_t) (q - p)] = '\\0';\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  free (fp->ctf_tmp_typeslice);\n+\t\t  fp->ctf_tmp_typeslice = strndup (p, (size_t) (q - p));\n+\t\t  if (fp->ctf_tmp_typeslice == NULL)\n+\t\t    {\n+\t\t      (void) ctf_set_errno (fp, ENOMEM);\n+\t\t      return CTF_ERR;\n+\t\t    }\n+\t\t}\n+\n+\t      if ((type = ctf_hash_lookup_type (lp->ctl_hash, fp,\n+\t\t\t\t\t\tfp->ctf_tmp_typeslice)) == 0)\n+\t\t{\n+\t\t  (void) ctf_set_errno (fp, ECTF_NOTYPE);\n+\t\t  goto err;\n+\t\t}\n+\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (lp->ctl_prefix == NULL)\n+\t{\n+\t  (void) ctf_set_errno (fp, ECTF_NOTYPE);\n+\t  goto err;\n+\t}\n+    }\n+\n+  if (*p != '\\0' || type == 0)\n+    return (ctf_set_errno (fp, ECTF_SYNTAX));\n+\n+  return type;\n+\n+err:\n+  if (fp->ctf_parent != NULL\n+      && (ptype = ctf_lookup_by_name (fp->ctf_parent, name)) != CTF_ERR)\n+    return ptype;\n+\n+  return CTF_ERR;\n+}\n+\n+typedef struct ctf_lookup_var_key\n+{\n+  ctf_file_t *clvk_fp;\n+  const char *clvk_name;\n+} ctf_lookup_var_key_t;\n+\n+/* A bsearch function for variable names.  */\n+\n+static int\n+ctf_lookup_var (const void *key_, const void *memb_)\n+{\n+  const ctf_lookup_var_key_t *key = key_;\n+  const ctf_varent_t *memb = memb_;\n+\n+  return (strcmp (key->clvk_name, ctf_strptr (key->clvk_fp, memb->ctv_name)));\n+}\n+\n+/* Given a variable name, return the type of the variable with that name.  */\n+\n+ctf_id_t\n+ctf_lookup_variable (ctf_file_t *fp, const char *name)\n+{\n+  ctf_varent_t *ent;\n+  ctf_lookup_var_key_t key = { fp, name };\n+\n+  /* This array is sorted, so we can bsearch for it.  */\n+\n+  ent = bsearch (&key, fp->ctf_vars, fp->ctf_nvars, sizeof (ctf_varent_t),\n+\t\t ctf_lookup_var);\n+\n+  if (ent == NULL)\n+    {\n+      if (fp->ctf_parent != NULL)\n+\treturn ctf_lookup_variable (fp->ctf_parent, name);\n+\n+      return (ctf_set_errno (fp, ECTF_NOTYPEDAT));\n+    }\n+\n+  return ent->ctv_type;\n+}\n+\n+/* Given a symbol table index, return the name of that symbol from the secondary\n+   string table, or the null string (never NULL).  */\n+const char *\n+ctf_lookup_symbol_name (ctf_file_t *fp, unsigned long symidx)\n+{\n+  const ctf_sect_t *sp = &fp->ctf_symtab;\n+  Elf64_Sym sym, *gsp;\n+\n+  if (sp->cts_data == NULL)\n+    {\n+      ctf_set_errno (fp, ECTF_NOSYMTAB);\n+      return _CTF_NULLSTR;\n+    }\n+\n+  if (symidx >= fp->ctf_nsyms)\n+    {\n+      ctf_set_errno (fp, EINVAL);\n+      return _CTF_NULLSTR;\n+    }\n+\n+  if (sp->cts_entsize == sizeof (Elf32_Sym))\n+    {\n+      const Elf32_Sym *symp = (Elf32_Sym *) sp->cts_data + symidx;\n+      gsp = ctf_sym_to_elf64 (symp, &sym);\n+    }\n+  else\n+      gsp = (Elf64_Sym *) sp->cts_data + symidx;\n+\n+  if (gsp->st_name < fp->ctf_str[CTF_STRTAB_1].cts_len)\n+    return (const char *) fp->ctf_str[CTF_STRTAB_1].cts_strs + gsp->st_name;\n+\n+  return _CTF_NULLSTR;\n+}\n+\n+/* Given a symbol table index, return the type of the data object described\n+   by the corresponding entry in the symbol table.  */\n+\n+ctf_id_t\n+ctf_lookup_by_symbol (ctf_file_t *fp, unsigned long symidx)\n+{\n+  const ctf_sect_t *sp = &fp->ctf_symtab;\n+  ctf_id_t type;\n+\n+  if (sp->cts_data == NULL)\n+    return (ctf_set_errno (fp, ECTF_NOSYMTAB));\n+\n+  if (symidx >= fp->ctf_nsyms)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if (sp->cts_entsize == sizeof (Elf32_Sym))\n+    {\n+      const Elf32_Sym *symp = (Elf32_Sym *) sp->cts_data + symidx;\n+      if (ELF32_ST_TYPE (symp->st_info) != STT_OBJECT)\n+\treturn (ctf_set_errno (fp, ECTF_NOTDATA));\n+    }\n+  else\n+    {\n+      const Elf64_Sym *symp = (Elf64_Sym *) sp->cts_data + symidx;\n+      if (ELF64_ST_TYPE (symp->st_info) != STT_OBJECT)\n+\treturn (ctf_set_errno (fp, ECTF_NOTDATA));\n+    }\n+\n+  if (fp->ctf_sxlate[symidx] == -1u)\n+    return (ctf_set_errno (fp, ECTF_NOTYPEDAT));\n+\n+  type = *(uint32_t *) ((uintptr_t) fp->ctf_buf + fp->ctf_sxlate[symidx]);\n+  if (type == 0)\n+    return (ctf_set_errno (fp, ECTF_NOTYPEDAT));\n+\n+  return type;\n+}\n+\n /* Return the pointer to the internal CTF type data corresponding to the\n    given type ID.  If the ID is invalid, the function returns NULL.\n    This function is not exported outside of the library.  */\n@@ -61,3 +345,83 @@ ctf_lookup_by_id (ctf_file_t **fpp, ctf_id_t type)\n   return NULL;\n }\n \n+/* Given a symbol table index, return the info for the function described\n+   by the corresponding entry in the symbol table.  */\n+\n+int\n+ctf_func_info (ctf_file_t *fp, unsigned long symidx, ctf_funcinfo_t *fip)\n+{\n+  const ctf_sect_t *sp = &fp->ctf_symtab;\n+  const uint32_t *dp;\n+  uint32_t info, kind, n;\n+\n+  if (sp->cts_data == NULL)\n+    return (ctf_set_errno (fp, ECTF_NOSYMTAB));\n+\n+  if (symidx >= fp->ctf_nsyms)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if (sp->cts_entsize == sizeof (Elf32_Sym))\n+    {\n+      const Elf32_Sym *symp = (Elf32_Sym *) sp->cts_data + symidx;\n+      if (ELF32_ST_TYPE (symp->st_info) != STT_FUNC)\n+\treturn (ctf_set_errno (fp, ECTF_NOTFUNC));\n+    }\n+  else\n+    {\n+      const Elf64_Sym *symp = (Elf64_Sym *) sp->cts_data + symidx;\n+      if (ELF64_ST_TYPE (symp->st_info) != STT_FUNC)\n+\treturn (ctf_set_errno (fp, ECTF_NOTFUNC));\n+    }\n+\n+  if (fp->ctf_sxlate[symidx] == -1u)\n+    return (ctf_set_errno (fp, ECTF_NOFUNCDAT));\n+\n+  dp = (uint32_t *) ((uintptr_t) fp->ctf_buf + fp->ctf_sxlate[symidx]);\n+\n+  info = *dp++;\n+  kind = LCTF_INFO_KIND (fp, info);\n+  n = LCTF_INFO_VLEN (fp, info);\n+\n+  if (kind == CTF_K_UNKNOWN && n == 0)\n+    return (ctf_set_errno (fp, ECTF_NOFUNCDAT));\n+\n+  if (kind != CTF_K_FUNCTION)\n+    return (ctf_set_errno (fp, ECTF_CORRUPT));\n+\n+  fip->ctc_return = *dp++;\n+  fip->ctc_argc = n;\n+  fip->ctc_flags = 0;\n+\n+  if (n != 0 && dp[n - 1] == 0)\n+    {\n+      fip->ctc_flags |= CTF_FUNC_VARARG;\n+      fip->ctc_argc--;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Given a symbol table index, return the arguments for the function described\n+   by the corresponding entry in the symbol table.  */\n+\n+int\n+ctf_func_args (ctf_file_t * fp, unsigned long symidx, uint32_t argc,\n+\t       ctf_id_t * argv)\n+{\n+  const uint32_t *dp;\n+  ctf_funcinfo_t f;\n+\n+  if (ctf_func_info (fp, symidx, &f) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  /* The argument data is two uint32_t's past the translation table\n+     offset: one for the function info, and one for the return type. */\n+\n+  dp = (uint32_t *) ((uintptr_t) fp->ctf_buf + fp->ctf_sxlate[symidx]) + 2;\n+\n+  for (argc = MIN (argc, f.ctc_argc); argc != 0; argc--)\n+    *argv++ = *dp++;\n+\n+  return 0;\n+}"
    }
  ]
}