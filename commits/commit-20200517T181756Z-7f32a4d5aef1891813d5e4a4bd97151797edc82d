{
  "sha": "7f32a4d5aef1891813d5e4a4bd97151797edc82d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2YzMmE0ZDVhZWYxODkxODEzZDVlNGE0YmQ5NzE1MTc5N2VkYzgyZA==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-05-17T18:17:56Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-05-17T18:17:56Z"
    },
    "message": "Stop considering hw and sw breakpoint locations duplicates (PR gdb/25741)\n\nIn the following conditions:\n\n  - A target with hardware breakpoints available, and\n  - A target that uses software single stepping,\n  - An instruction at ADDRESS loops back to itself,\n\nNow consider the following steps:\n\n  1. The user places a hardware breakpoint at ADDRESS (an instruction\n  that loops to itself),\n\n  2. The inferior runs and hits the breakpoint at ADDRESS,\n\n  3. The user tells GDB to 'continue'.\n\nIn #3 when the user tells GDB to continue, GDB first disables the\nhardware breakpoint at ADDRESS, and then inserts a software\nsingle-step breakpoint at ADDRESS.  The original user-created\nbreakpoint was a hardware breakpoint, while the single-step breakpoint\nwill be a software breakpoint.\n\nGDB continues and immediately hits the software single-step\nbreakpoint.\n\nGDB then deletes the software single-step breakpoint by calling\ndelete_single_step_breakpoints, which eventually calls\ndelete_breakpoint, which, once the breakpoint (and its locations) are\ndeleted, calls update_global_location_list.\n\nDuring update_global_location_list GDB spots that we have an old\nlocation (the software single step breakpoint location) that is\ninserted, but being deleted, and a location (the original hardware\nbreakpoint) at the same address which we are keeping, but which is not\ncurrently inserted, GDB then calls breakpoint_locations_match on these\ntwo locations.\n\nCurrently the locations do match, and so GDB calls swap_insertion\nwhich swaps the \"inserted\" state of the two locations.  The user\ncreated hardware breakpoint is marked as inserted, while the GDB\ninternal software single step breakpoint is now marked as not\ninserted.  After this GDB returns through the call stack and leaves\ndelete_single_step_breakpoints.\n\nAfter this GDB continues with its normal \"stopping\" process, as part\nof this stopping process GDB removes all the breakpoints from the\ntarget.  Due to the swap it is now the user-created hardware\nbreakpoint that is marked as inserted, so it is this breakpoint GDB\ntries to remove.\n\nThe problem is that GDB inserted the software single-step breakpoint\nas a software breakpoint, but is now trying to remove the hardware\nbreakpoint.  The problem is removing a software breakpoint is very\ndifferent to removing a hardware breakpoint, this could result is some\nundetected undefined behaviour, or as in the original bug report (PR\ngdb/25741), could result in the target throwing an error.\n\nWith \"set breakpoint always-inserted on\", we can easily reproduce this\nagainst GDBserver.  E.g.:\n\n  (gdb) hbreak main\n  Sending packet: $m400700,40#28...Packet received: 89e58b....\n  Sending packet: $m400736,1#fe...Packet received: 48\n  Hardware assisted breakpoint 1 at 0x400736: file threads.c, line 57.\n  Sending packet: $Z1,400736,1#48...Packet received: OK\n  Packet Z1 (hardware-breakpoint) is supported\n\n  (gdb) b main\n  Note: breakpoint 1 also set at pc 0x400736.\n  Sending packet: $m400736,1#fe...Packet received: 48\n  Breakpoint 2 at 0x400736: file threads.c, line 57.\n\n  (gdb) del\n  Delete all breakpoints? (y or n) y\n  Sending packet: $z0,400736,1#67...Packet received: E01\n  warning: Error removing breakpoint 2\n\nThis patch adds a testcase that does exactly that.\n\nTrying to enhance GDB to handle this scenario while continuing to\navoid inserting redundant software and hardware breakpoints at the\nsame address turns out futile, because, given non-stop and breakpoints\nalways-inserted, if the user:\n\n #1 - inserts a hw breakpoint, then\n #2 - inserts a sw breakpoint at the same address, and then\n #3 - removes the original hw breakpoint,\n\nGDB would have to make sure to insert the sw breakpoint before\nremoving the hw breakpoint, to avoid running threads missing the\nbreakpoint.  I.e., there's always going to be a window where a target\nneeds to be able to handle both sw and a hw breakpoints installed at\nthe same address.  You can see more detailed description of that issue\nhere:\nhttps://sourceware.org/pipermail/gdb-patches/2020-April/167738.html\n\nSo the fix here is to just stop considering software breakpoints and\nhw breakpoints duplicates, and let GDB insert sw and hw breakpoints at\nthe same address.\n\nThe central change is to make breakpoint_locations_match consider the\nlocation's type too.  There are several other changes necessary to\nactually make that that work correctly, however:\n\n- We need to handle the duplicates detection better.  Take a look at\n  the loop at the tail end of update_global_location_list.  Currently,\n  because breakpoint locations aren't sorted by type, we can end up\n  with, at the same address, a sw break, then a hw break, then a sw\n  break, etc.  The result is that that second sw break won't be\n  considered a duplicate of the first sw break.  Seems like we already\n  handle that incorrectly for range breakpoints.\n\n- The \"set breakpoint auto-hw on\" handling is moved out of\n  insert_bp_location to update_global_location_list, before the\n  duplicates determination.\n\n  Moving \"set breakpoint auto-hw off\" handling as well and downgrading\n  it to a warning+'disabling the location' was considered too, but in\n  the end discarded, because we want to error out with internal and\n  momentary breakpoints, like software single-step breakpoints.\n  Disabling such locations at update_global_location_list time would\n  make GDB lose control of the inferior.\n\n- In update_breakpoint_locations, the logic of matching old locations\n  with new locations, in the have_ambiguous_names case, is updated to\n  still consider sw vs hw locations the same.\n\n- Review all ALL_BP_LOCATIONS_AT_ADDR uses, and update those that\n  might need to be updated, and update comments for those that don't.\n  Note that that macro walks all locations at a given address, and\n  doesn't call breakpoint_locations_match.\n\nThe result against GDBserver (with \"set breakpoint\ncondition-evaluation host\" to avoid seeing confusing reinsertions) is:\n\n (gdb) hbreak main\n Sending packet: $m400736,1#fe...Packet received: 48\n Hardware assisted breakpoint 1 at 0x400736: file main.c, line 57.\n Sending packet: $Z1,400736,1#48...Packet received: OK\n\n (gdb) b main\n Note: breakpoint 1 also set at pc 0x400736.\n Sending packet: $m400736,1#fe...Packet received: 48\n Breakpoint 4 at 0x400736: file main.c, line 57.\n Sending packet: $Z0,400736,1#47...Packet received: OK\n\n (gdb) del 3\n Sending packet: $z1,400736,1#68...Packet received: OK\n\ngdb/ChangeLog:\n2020-05-17  Pedro Alves  <palves@redhat.com>\n\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n\t    Keno Fischer  <keno@juliacomputing.com>\n\n\tPR gdb/25741\n\t* breakpoint.c (build_target_condition_list): Update comments.\n\t(build_target_command_list): Update comments and skip matching\n\tlocations.\n\t(insert_bp_location): Move \"set breakpoint auto-hw on\" handling to\n\ta separate function.  Simplify \"set breakpoint auto-hw off\"\n\thandling.\n\t(insert_breakpoints): Update comment.\n\t(tracepoint_locations_match): New parameter.  For breakpoints,\n\tcompare location types too, if the caller wants to.\n\t(handle_automatic_hardware_breakpoints): New functions.\n\t(bp_location_is_less_than): Also sort by location type and\n\thardware breakpoint length.\n\t(update_global_location_list): Handle \"set breakpoint auto-hw on\"\n\there.\n\t(update_breakpoint_locations): Ask breakpoint_locations_match to\n\tignore location types.\n\ngdb/testsuite/ChangeLog:\n2020-05-17  Pedro Alves  <palves@redhat.com>\n\n\tPR gdb/25741\n\t* gdb.base/hw-sw-break-same-address.exp: New file.",
    "tree": {
      "sha": "0650778154877f991a6df878f3331c232901b562",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0650778154877f991a6df878f3331c232901b562"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7f32a4d5aef1891813d5e4a4bd97151797edc82d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7f32a4d5aef1891813d5e4a4bd97151797edc82d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7f32a4d5aef1891813d5e4a4bd97151797edc82d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7f32a4d5aef1891813d5e4a4bd97151797edc82d/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "966dc1a27c55ccb298cb8c7c41c9cc2985cc321a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/966dc1a27c55ccb298cb8c7c41c9cc2985cc321a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/966dc1a27c55ccb298cb8c7c41c9cc2985cc321a"
    }
  ],
  "stats": {
    "total": 353,
    "additions": 267,
    "deletions": 86
  },
  "files": [
    {
      "sha": "1c2ddcecb7e20a1d244397994b14214bf804090a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7f32a4d5aef1891813d5e4a4bd97151797edc82d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7f32a4d5aef1891813d5e4a4bd97151797edc82d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7f32a4d5aef1891813d5e4a4bd97151797edc82d",
      "patch": "@@ -1,3 +1,25 @@\n+2020-05-17  Pedro Alves  <palves@redhat.com>\n+\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n+\t    Keno Fischer  <keno@juliacomputing.com>\n+\n+\tPR gdb/25741\n+\t* breakpoint.c (build_target_condition_list): Update comments.\n+\t(build_target_command_list): Update comments and skip matching\n+\tlocations.\n+\t(insert_bp_location): Move \"set breakpoint auto-hw on\" handling to\n+\ta separate function.  Simplify \"set breakpoint auto-hw off\"\n+\thandling.\n+\t(insert_breakpoints): Update comment.\n+\t(tracepoint_locations_match): New parameter.  For breakpoints,\n+\tcompare location types too, if the caller wants to.\n+\t(handle_automatic_hardware_breakpoints): New functions.\n+\t(bp_location_is_less_than): Also sort by location type and\n+\thardware breakpoint length.\n+\t(update_global_location_list): Handle \"set breakpoint auto-hw on\"\n+\there.\n+\t(update_breakpoint_locations): Ask breakpoint_locations_match to\n+\tignore location types.\n+\n 2020-05-16  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (TYPE_NAME): Remove.  Change all cal sites to use"
    },
    {
      "sha": "aead882acd885b13694af3f90e5a6fe525b6c46c",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 167,
      "deletions": 86,
      "changes": 253,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7f32a4d5aef1891813d5e4a4bd97151797edc82d/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7f32a4d5aef1891813d5e4a4bd97151797edc82d/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=7f32a4d5aef1891813d5e4a4bd97151797edc82d",
      "patch": "@@ -144,6 +144,10 @@ static void describe_other_breakpoints (struct gdbarch *,\n static int watchpoint_locations_match (struct bp_location *loc1,\n \t\t\t\t       struct bp_location *loc2);\n \n+static int breakpoint_locations_match (struct bp_location *loc1,\n+\t\t\t\t       struct bp_location *loc2,\n+\t\t\t\t       bool sw_hw_bps_match = false);\n+\n static int breakpoint_location_address_match (struct bp_location *bl,\n \t\t\t\t\t      const struct address_space *aspace,\n \t\t\t\t\t      CORE_ADDR addr);\n@@ -2125,10 +2129,14 @@ build_target_condition_list (struct bp_location *bl)\n     return;\n \n   /* Do a first pass to check for locations with no assigned\n-     conditions or conditions that fail to parse to a valid agent expression\n-     bytecode.  If any of these happen, then it's no use to send conditions\n-     to the target since this location will always trigger and generate a\n-     response back to GDB.  */\n+     conditions or conditions that fail to parse to a valid agent\n+     expression bytecode.  If any of these happen, then it's no use to\n+     send conditions to the target since this location will always\n+     trigger and generate a response back to GDB.  Note we consider\n+     all locations at the same address irrespective of type, i.e.,\n+     even if the locations aren't considered duplicates (e.g.,\n+     software breakpoint and hardware breakpoint at the same\n+     address).  */\n   ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)\n     {\n       loc = (*loc2p);\n@@ -2177,8 +2185,12 @@ build_target_condition_list (struct bp_location *bl)\n \t}\n     }\n \n-  /* No NULL conditions or failed bytecode generation.  Build a condition list\n-     for this location's address.  */\n+  /* No NULL conditions or failed bytecode generation.  Build a\n+     condition list for this location's address.  If we have software\n+     and hardware locations at the same address, they aren't\n+     considered duplicates, but we still marge all the conditions\n+     anyway, as it's simpler, and doesn't really make a practical\n+     difference.  */\n   ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)\n     {\n       loc = (*loc2p);\n@@ -2296,9 +2308,9 @@ build_target_command_list (struct bp_location *bl)\n   if (dprintf_style != dprintf_style_agent)\n     return;\n \n-  /* For now, if we have any duplicate location that isn't a dprintf,\n-     don't install the target-side commands, as that would make the\n-     breakpoint not be reported to the core, and we'd lose\n+  /* For now, if we have any location at the same address that isn't a\n+     dprintf, don't install the target-side commands, as that would\n+     make the breakpoint not be reported to the core, and we'd lose\n      control.  */\n   ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)\n     {\n@@ -2360,12 +2372,19 @@ build_target_command_list (struct bp_location *bl)\n \t}\n     }\n \n-  /* No NULL commands or failed bytecode generation.  Build a command list\n-     for this location's address.  */\n+  /* No NULL commands or failed bytecode generation.  Build a command\n+     list for all duplicate locations at this location's address.\n+     Note that here we must care for whether the breakpoint location\n+     types are considered duplicates, otherwise, say, if we have a\n+     software and hardware location at the same address, the target\n+     could end up running the commands twice.  For the moment, we only\n+     support targets-side commands with dprintf, but it doesn't hurt\n+     to be pedantically correct in case that changes.  */\n   ALL_BP_LOCATIONS_AT_ADDR (loc2p, locp, bl->address)\n     {\n       loc = (*loc2p);\n-      if (loc->owner->extra_string\n+      if (breakpoint_locations_match (bl, loc)\n+\t  && loc->owner->extra_string\n \t  && is_breakpoint (loc->owner)\n \t  && loc->pspace->num == bl->pspace->num\n \t  && loc->owner->enable_state == bp_enabled\n@@ -2451,72 +2470,31 @@ insert_bp_location (struct bp_location *bl,\n       bl->needs_update = 0;\n     }\n \n+  /* If \"set breakpoint auto-hw\" is \"on\" and a software breakpoint was\n+     set at a read-only address, then a breakpoint location will have\n+     been changed to hardware breakpoint before we get here.  If it is\n+     \"off\" however, error out before actually trying to insert the\n+     breakpoint, with a nicer error message.  */\n   if (bl->loc_type == bp_loc_software_breakpoint\n-      || bl->loc_type == bp_loc_hardware_breakpoint)\n+      && !automatic_hardware_breakpoints)\n     {\n-      if (bl->owner->type != bp_hardware_breakpoint)\n-\t{\n-\t  /* If the explicitly specified breakpoint type\n-\t     is not hardware breakpoint, check the memory map to see\n-\t     if the breakpoint address is in read only memory or not.\n-\n-\t     Two important cases are:\n-\t     - location type is not hardware breakpoint, memory\n-\t     is readonly.  We change the type of the location to\n-\t     hardware breakpoint.\n-\t     - location type is hardware breakpoint, memory is\n-\t     read-write.  This means we've previously made the\n-\t     location hardware one, but then the memory map changed,\n-\t     so we undo.\n-\t     \n-\t     When breakpoints are removed, remove_breakpoints will use\n-\t     location types we've just set here, the only possible\n-\t     problem is that memory map has changed during running\n-\t     program, but it's not going to work anyway with current\n-\t     gdb.  */\n-\t  struct mem_region *mr \n-\t    = lookup_mem_region (bl->target_info.reqstd_address);\n-\t  \n-\t  if (mr)\n-\t    {\n-\t      if (automatic_hardware_breakpoints)\n-\t\t{\n-\t\t  enum bp_loc_type new_type;\n-\t\t  \n-\t\t  if (mr->attrib.mode != MEM_RW)\n-\t\t    new_type = bp_loc_hardware_breakpoint;\n-\t\t  else \n-\t\t    new_type = bp_loc_software_breakpoint;\n-\t\t  \n-\t\t  if (new_type != bl->loc_type)\n-\t\t    {\n-\t\t      static int said = 0;\n+      mem_region *mr = lookup_mem_region (bl->address);\n \n-\t\t      bl->loc_type = new_type;\n-\t\t      if (!said)\n-\t\t\t{\n-\t\t\t  fprintf_filtered (gdb_stdout,\n-\t\t\t\t\t    _(\"Note: automatically using \"\n-\t\t\t\t\t      \"hardware breakpoints for \"\n-\t\t\t\t\t      \"read-only addresses.\\n\"));\n-\t\t\t  said = 1;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      else if (bl->loc_type == bp_loc_software_breakpoint\n-\t\t       && mr->attrib.mode != MEM_RW)\n-\t\t{\n-\t\t  fprintf_unfiltered (tmp_error_stream,\n-\t\t\t\t      _(\"Cannot insert breakpoint %d.\\n\"\n-\t\t\t\t\t\"Cannot set software breakpoint \"\n-\t\t\t\t\t\"at read-only address %s\\n\"),\n-\t\t\t\t      bl->owner->number,\n-\t\t\t\t      paddress (bl->gdbarch, bl->address));\n-\t\t  return 1;\n-\t\t}\n-\t    }\n+      if (mr != nullptr && mr->attrib.mode != MEM_RW)\n+\t{\n+\t  fprintf_unfiltered (tmp_error_stream,\n+\t\t\t      _(\"Cannot insert breakpoint %d.\\n\"\n+\t\t\t\t\"Cannot set software breakpoint \"\n+\t\t\t\t\"at read-only address %s\\n\"),\n+\t\t\t      bl->owner->number,\n+\t\t\t      paddress (bl->gdbarch, bl->address));\n+\t  return 1;\n \t}\n-        \n+    }\n+\n+  if (bl->loc_type == bp_loc_software_breakpoint\n+      || bl->loc_type == bp_loc_hardware_breakpoint)\n+    {\n       /* First check to see if we have to handle an overlay.  */\n       if (overlay_debugging == ovly_off\n \t  || bl->section == NULL\n@@ -2830,7 +2808,11 @@ insert_breakpoints (void)\n \n   /* Updating watchpoints creates new locations, so update the global\n      location list.  Explicitly tell ugll to insert locations and\n-     ignore breakpoints_always_inserted_mode.  */\n+     ignore breakpoints_always_inserted_mode.  Also,\n+     update_global_location_list tries to \"upgrade\" software\n+     breakpoints to hardware breakpoints to handle \"set breakpoint\n+     auto-hw\", so we need to call it even if we don't have new\n+     locations.  */\n   update_global_location_list (UGLL_INSERT);\n }\n \n@@ -6811,11 +6793,14 @@ tracepoint_locations_match (struct bp_location *loc1,\n \n /* Assuming LOC1 and LOC2's types' have meaningful target addresses\n    (bl_address_is_meaningful), returns true if LOC1 and LOC2 represent\n-   the same location.  */\n+   the same location.  If SW_HW_BPS_MATCH is true, then software\n+   breakpoint locations and hardware breakpoint locations match,\n+   otherwise they don't.  */\n \n static int\n-breakpoint_locations_match (struct bp_location *loc1, \n-\t\t\t    struct bp_location *loc2)\n+breakpoint_locations_match (struct bp_location *loc1,\n+\t\t\t    struct bp_location *loc2,\n+\t\t\t    bool sw_hw_bps_match)\n {\n   int hw_point1, hw_point2;\n \n@@ -6833,9 +6818,12 @@ breakpoint_locations_match (struct bp_location *loc1,\n   else if (is_tracepoint (loc1->owner) || is_tracepoint (loc2->owner))\n     return tracepoint_locations_match (loc1, loc2);\n   else\n-    /* We compare bp_location.length in order to cover ranged breakpoints.  */\n+    /* We compare bp_location.length in order to cover ranged\n+       breakpoints.  Keep this in sync with\n+       bp_location_is_less_than.  */\n     return (breakpoint_address_match (loc1->pspace->aspace, loc1->address,\n \t\t\t\t     loc2->pspace->aspace, loc2->address)\n+\t    && (loc1->loc_type == loc2->loc_type || sw_hw_bps_match)\n \t    && loc1->length == loc2->length);\n }\n \n@@ -8515,6 +8503,61 @@ mention (struct breakpoint *b)\n \n static bool bp_loc_is_permanent (struct bp_location *loc);\n \n+/* Handle \"set breakpoint auto-hw on\".\n+\n+   If the explicitly specified breakpoint type is not hardware\n+   breakpoint, check the memory map to see whether the breakpoint\n+   address is in read-only memory.\n+\n+   - location type is not hardware breakpoint, memory is read-only.\n+   We change the type of the location to hardware breakpoint.\n+\n+   - location type is hardware breakpoint, memory is read-write.  This\n+   means we've previously made the location hardware one, but then the\n+   memory map changed, so we undo.\n+*/\n+\n+static void\n+handle_automatic_hardware_breakpoints (bp_location *bl)\n+{\n+  if (automatic_hardware_breakpoints\n+      && bl->owner->type != bp_hardware_breakpoint\n+      && (bl->loc_type == bp_loc_software_breakpoint\n+\t  || bl->loc_type == bp_loc_hardware_breakpoint))\n+    {\n+      /* When breakpoints are removed, remove_breakpoints will use\n+\t location types we've just set here, the only possible problem\n+\t is that memory map has changed during running program, but\n+\t it's not going to work anyway with current gdb.  */\n+      mem_region *mr = lookup_mem_region (bl->address);\n+\n+      if (mr != nullptr)\n+\t{\n+\t  enum bp_loc_type new_type;\n+\n+\t  if (mr->attrib.mode != MEM_RW)\n+\t    new_type = bp_loc_hardware_breakpoint;\n+\t  else\n+\t    new_type = bp_loc_software_breakpoint;\n+\n+\t  if (new_type != bl->loc_type)\n+\t    {\n+\t      static bool said = false;\n+\n+\t      bl->loc_type = new_type;\n+\t      if (!said)\n+\t\t{\n+\t\t  fprintf_filtered (gdb_stdout,\n+\t\t\t\t    _(\"Note: automatically using \"\n+\t\t\t\t      \"hardware breakpoints for \"\n+\t\t\t\t      \"read-only addresses.\\n\"));\n+\t\t  said = true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n static struct bp_location *\n add_location_to_breakpoint (struct breakpoint *b,\n \t\t\t    const struct symtab_and_line *sal)\n@@ -11438,6 +11481,18 @@ bp_location_is_less_than (const bp_location *a, const bp_location *b)\n   if (a->permanent != b->permanent)\n     return a->permanent > b->permanent;\n \n+  /* Sort by type in order to make duplicate determination easier.\n+     See update_global_location_list.  This is kept in sync with\n+     breakpoint_locations_match.  */\n+  if (a->loc_type < b->loc_type)\n+    return true;\n+\n+  /* Likewise, for range-breakpoints, sort by length.  */\n+  if (a->loc_type == bp_loc_hardware_breakpoint\n+      && b->loc_type == bp_loc_hardware_breakpoint\n+      && a->length < b->length)\n+    return true;\n+\n   /* Make the internal GDB representation stable across GDB runs\n      where A and B memory inside GDB can differ.  Breakpoint locations of\n      the same type at the same address can be sorted in arbitrary order.  */\n@@ -11612,6 +11667,7 @@ force_breakpoint_reinsertion (struct bp_location *bl)\n       loc->cond_bytecode.reset ();\n     }\n }\n+\n /* Called whether new breakpoints are created, or existing breakpoints\n    deleted, to update the global location list and recompute which\n    locations are duplicate of which.\n@@ -11660,6 +11716,20 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n   ALL_BREAKPOINTS (b)\n     for (loc = b->loc; loc; loc = loc->next)\n       *locp++ = loc;\n+\n+  /* See if we need to \"upgrade\" a software breakpoint to a hardware\n+     breakpoint.  Do this before deciding whether locations are\n+     duplicates.  Also do this before sorting because sorting order\n+     depends on location type.  */\n+  for (locp = bp_locations;\n+       locp < bp_locations + bp_locations_count;\n+       locp++)\n+    {\n+      loc = *locp;\n+      if (!loc->inserted && should_be_inserted (loc))\n+\thandle_automatic_hardware_breakpoints (loc);\n+    }\n+\n   std::sort (bp_locations, bp_locations + bp_locations_count,\n \t     bp_location_is_less_than);\n \n@@ -11763,6 +11833,9 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n \t\t    {\n \t\t      struct bp_location *loc2 = *loc2p;\n \n+\t\t      if (loc2 == old_loc)\n+\t\t\tcontinue;\n+\n \t\t      if (breakpoint_locations_match (loc2, old_loc))\n \t\t\t{\n \t\t\t  /* Read watchpoint locations are switched to\n@@ -11777,8 +11850,7 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n \t\t\t  /* loc2 is a duplicated location. We need to check\n \t\t\t     if it should be inserted in case it will be\n \t\t\t     unduplicated.  */\n-\t\t\t  if (loc2 != old_loc\n-\t\t\t      && unduplicated_should_be_inserted (loc2))\n+\t\t\t  if (unduplicated_should_be_inserted (loc2))\n \t\t\t    {\n \t\t\t      swap_insertion (old_loc, loc2);\n \t\t\t      keep_in_target = 1;\n@@ -13495,11 +13567,20 @@ update_breakpoint_locations (struct breakpoint *b,\n \t    if (have_ambiguous_names)\n \t      {\n \t\tfor (; l; l = l->next)\n-\t\t  if (breakpoint_locations_match (e, l))\n-\t\t    {\n-\t\t      l->enabled = 0;\n-\t\t      break;\n-\t\t    }\n+\t\t  {\n+\t\t    /* Ignore software vs hardware location type at\n+\t\t       this point, because with \"set breakpoint\n+\t\t       auto-hw\", after a re-set, locations that were\n+\t\t       hardware can end up as software, or vice versa.\n+\t\t       As mentioned above, this is an heuristic and in\n+\t\t       practice should give the correct answer often\n+\t\t       enough.  */\n+\t\t    if (breakpoint_locations_match (e, l, true))\n+\t\t      {\n+\t\t\tl->enabled = 0;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n \t      }\n \t    else\n \t      {"
    },
    {
      "sha": "2a3e72c0226f41438fcfc139d56b858a5fff9f7b",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7f32a4d5aef1891813d5e4a4bd97151797edc82d/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7f32a4d5aef1891813d5e4a4bd97151797edc82d/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=7f32a4d5aef1891813d5e4a4bd97151797edc82d",
      "patch": "@@ -1,3 +1,8 @@\n+2020-05-17  Pedro Alves  <palves@redhat.com>\n+\n+\tPR gdb/25741\n+\t* gdb.base/hw-sw-break-same-address.exp: New file.\n+\n 2020-05-16  Pedro Alves  <palves@redhat.com>\n \n \t* gdb.multi/multi-re-run.exp (test_re_run): Switch"
    },
    {
      "sha": "92896ff4db56b83abc2279188f437aeae6b6df0a",
      "filename": "gdb/testsuite/gdb.base/hw-sw-break-same-address.exp",
      "status": "added",
      "additions": 73,
      "deletions": 0,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7f32a4d5aef1891813d5e4a4bd97151797edc82d/gdb/testsuite/gdb.base/hw-sw-break-same-address.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7f32a4d5aef1891813d5e4a4bd97151797edc82d/gdb/testsuite/gdb.base/hw-sw-break-same-address.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/hw-sw-break-same-address.exp?ref=7f32a4d5aef1891813d5e4a4bd97151797edc82d",
      "patch": "@@ -0,0 +1,73 @@\n+# Copyright 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test that inserting a hardware and a software breakpoint at the same\n+# address behaves as expected.  GDB used to consider hw and sw\n+# breakpoint locations as duplicate locations, which would lead to bad\n+# behavior.  See PR gdb/25741.\n+\n+if {[skip_hw_breakpoint_tests]} {\n+    return 0\n+}\n+\n+set test hbreak\n+set srcfile ${test}.c\n+if { [prepare_for_testing \"failed to prepare\" ${test} ${srcfile}] } {\n+    return -1\n+}\n+\n+if ![runto_main] {\n+    fail \"can't run to main\"\n+    return -1\n+}\n+\n+delete_breakpoints\n+\n+gdb_test_no_output \"set breakpoint always-inserted on\"\n+gdb_test_no_output \"set breakpoint condition-evaluation host\"\n+gdb_test_no_output \"set confirm off\"\n+\n+# Test inserting a hw breakpoint first, then a sw breakpoint at the\n+# same address.\n+with_test_prefix \"hw-sw\" {\n+    gdb_test \"hbreak main\" \\\n+\t\"Hardware assisted breakpoint .* at .*\" \\\n+\t\"hbreak\"\n+\n+    gdb_test \"break main\" \\\n+\t\"Note: breakpoint .* also set at .*\\r\\nBreakpoint .* at .*\" \\\n+\t\"break\"\n+\n+    # A bad GDB debugging against GDBserver would output a warning\n+    # here:\n+    #  delete breakpoints\n+    #  warning: Error removing breakpoint 3\n+    #  (gdb) FAIL: gdb.base/hw-sw-break-same-address.exp: hw-sw: delete breakpoints\n+    gdb_test_no_output \"delete breakpoints\"\n+}\n+\n+# Now the opposite: test inserting a sw breakpoint first, then a hw\n+# breakpoint at the same address.\n+with_test_prefix \"sw-hw\" {\n+    gdb_test \"break main\" \\\n+\t\"Breakpoint .* at .*\" \\\n+\t\"break\"\n+\n+    gdb_test \"hbreak main\" \\\n+\t\"Note: breakpoint .* also set at .*\\r\\nHardware assisted breakpoint .* at .*\" \\\n+\t\"hbreak\"\n+\n+    gdb_test_no_output \"delete breakpoints\"\n+}"
    }
  ]
}