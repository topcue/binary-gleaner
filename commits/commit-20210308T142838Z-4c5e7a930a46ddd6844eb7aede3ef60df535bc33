{
  "sha": "4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGM1ZTdhOTMwYTQ2ZGRkNjg0NGViN2FlZGUzZWY2MGRmNTM1YmMzMw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:38Z"
    },
    "message": "Convert stap probes to create operations\n\nThis changes the stap probe code to create operations, rather than\nexp_elements.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* stap-probe.c (binop_maker_ftype): New typedef.\n\t(stap_maker_map): New global.\n\t(stap_make_binop): New function.\n\t(stap_parse_register_operand): Return operation_up.\n\t(stap_parse_single_operand, stap_parse_argument_conditionally)\n\t(stap_parse_argument_1): Likewise.\n\t(stap_parse_argument): Create operations.\n\t(stap_probe::parse_arguments): Update.\n\t(_initialize_stap_probe): Initialize stap_maker_map.\n\t* ppc-linux-tdep.c (ppc_stap_parse_special_token): Change return\n\ttype.\n\t* i386-tdep.h (i386_stap_parse_special_token): Change return\n\ttype.\n\t* i386-tdep.c (i386_stap_parse_special_token_triplet)\n\t(i386_stap_parse_special_token_three_arg_disp)\n\t(i386_stap_parse_special_token): Change return type.\n\t* gdbarch.sh (stap_parse_special_token): Change return type.\n\t* gdbarch.c: Rebuild.\n\t* gdbarch.h: Rebuild.\n\t* arm-linux-tdep.c (arm_stap_parse_special_token): Change return\n\ttype.\n\t* aarch64-linux-tdep.c (aarch64_stap_parse_special_token): Change\n\treturn type.",
    "tree": {
      "sha": "360c0598047c43c52d5b770a869cfa3efe847f3a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/360c0598047c43c52d5b770a869cfa3efe847f3a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "482ddd69c5f026aac98932be2fa8ac985b37d5be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/482ddd69c5f026aac98932be2fa8ac985b37d5be",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/482ddd69c5f026aac98932be2fa8ac985b37d5be"
    }
  ],
  "stats": {
    "total": 567,
    "additions": 276,
    "deletions": 291
  },
  "files": [
    {
      "sha": "5b6493c1b8e2fa7aab8a29c73426bb7e0b5c16cd",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -1,3 +1,29 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* stap-probe.c (binop_maker_ftype): New typedef.\n+\t(stap_maker_map): New global.\n+\t(stap_make_binop): New function.\n+\t(stap_parse_register_operand): Return operation_up.\n+\t(stap_parse_single_operand, stap_parse_argument_conditionally)\n+\t(stap_parse_argument_1): Likewise.\n+\t(stap_parse_argument): Create operations.\n+\t(stap_probe::parse_arguments): Update.\n+\t(_initialize_stap_probe): Initialize stap_maker_map.\n+\t* ppc-linux-tdep.c (ppc_stap_parse_special_token): Change return\n+\ttype.\n+\t* i386-tdep.h (i386_stap_parse_special_token): Change return\n+\ttype.\n+\t* i386-tdep.c (i386_stap_parse_special_token_triplet)\n+\t(i386_stap_parse_special_token_three_arg_disp)\n+\t(i386_stap_parse_special_token): Change return type.\n+\t* gdbarch.sh (stap_parse_special_token): Change return type.\n+\t* gdbarch.c: Rebuild.\n+\t* gdbarch.h: Rebuild.\n+\t* arm-linux-tdep.c (arm_stap_parse_special_token): Change return\n+\ttype.\n+\t* aarch64-linux-tdep.c (aarch64_stap_parse_special_token): Change\n+\treturn type.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* gdbarch.sh (dtrace_parse_probe_argument): Change return type."
    },
    {
      "sha": "d8476c907e80cb34af2c2e4a70a1c6e0ba80ed20",
      "filename": "gdb/aarch64-linux-tdep.c",
      "status": "modified",
      "additions": 24,
      "deletions": 34,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/aarch64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/aarch64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-tdep.c?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -31,6 +31,7 @@\n #include \"tramp-frame.h\"\n #include \"trad-frame.h\"\n #include \"target/target.h\"\n+#include \"expop.h\"\n \n #include \"regcache.h\"\n #include \"regset.h\"\n@@ -753,7 +754,7 @@ aarch64_stap_is_single_operand (struct gdbarch *gdbarch, const char *s)\n    It returns one if the special token has been parsed successfully,\n    or zero if the current token is not considered special.  */\n \n-static int\n+static expr::operation_up\n aarch64_stap_parse_special_token (struct gdbarch *gdbarch,\n \t\t\t\t  struct stap_parse_info *p)\n {\n@@ -764,11 +765,9 @@ aarch64_stap_parse_special_token (struct gdbarch *gdbarch,\n       char *endp;\n       /* Used to save the register name.  */\n       const char *start;\n-      char *regname;\n       int len;\n       int got_minus = 0;\n       long displacement;\n-      struct stoken str;\n \n       ++tmp;\n       start = tmp;\n@@ -778,17 +777,14 @@ aarch64_stap_parse_special_token (struct gdbarch *gdbarch,\n \t++tmp;\n \n       if (*tmp != ',')\n-\treturn 0;\n+\treturn {};\n \n       len = tmp - start;\n-      regname = (char *) alloca (len + 2);\n-\n-      strncpy (regname, start, len);\n-      regname[len] = '\\0';\n+      std::string regname (start, len);\n \n-      if (user_reg_map_name_to_regnum (gdbarch, regname, len) == -1)\n+      if (user_reg_map_name_to_regnum (gdbarch, regname.c_str (), len) == -1)\n \terror (_(\"Invalid register name `%s' on expression `%s'.\"),\n-\t       regname, p->saved_arg);\n+\t       regname.c_str (), p->saved_arg);\n \n       ++tmp;\n       tmp = skip_spaces (tmp);\n@@ -806,45 +802,39 @@ aarch64_stap_parse_special_token (struct gdbarch *gdbarch,\n \t++tmp;\n \n       if (!isdigit (*tmp))\n-\treturn 0;\n+\treturn {};\n \n       displacement = strtol (tmp, &endp, 10);\n       tmp = endp;\n \n       /* Skipping last `]'.  */\n       if (*tmp++ != ']')\n-\treturn 0;\n+\treturn {};\n+      p->arg = tmp;\n+\n+      using namespace expr;\n \n       /* The displacement.  */\n-      write_exp_elt_opcode (&p->pstate, OP_LONG);\n-      write_exp_elt_type (&p->pstate, builtin_type (gdbarch)->builtin_long);\n-      write_exp_elt_longcst (&p->pstate, displacement);\n-      write_exp_elt_opcode (&p->pstate, OP_LONG);\n+      struct type *long_type = builtin_type (gdbarch)->builtin_long;\n       if (got_minus)\n-\twrite_exp_elt_opcode (&p->pstate, UNOP_NEG);\n+\tdisplacement = -displacement;\n+      operation_up disp = make_operation<long_const_operation> (long_type,\n+\t\t\t\t\t\t\t\tdisplacement);\n \n       /* The register name.  */\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-      str.ptr = regname;\n-      str.length = len;\n-      write_exp_string (&p->pstate, str);\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n+      operation_up reg\n+\t= make_operation<register_operation> (std::move (regname));\n \n-      write_exp_elt_opcode (&p->pstate, BINOP_ADD);\n+      operation_up sum\n+\t= make_operation<add_operation> (std::move (reg), std::move (disp));\n \n       /* Casting to the expected type.  */\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-      write_exp_elt_type (&p->pstate, lookup_pointer_type (p->arg_type));\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-\n-      write_exp_elt_opcode (&p->pstate, UNOP_IND);\n-\n-      p->arg = tmp;\n+      struct type *arg_ptr_type = lookup_pointer_type (p->arg_type);\n+      sum = make_operation<unop_cast_operation> (std::move (sum),\n+\t\t\t\t\t\t arg_ptr_type);\n+      return make_operation<unop_ind_operation> (std::move (sum));\n     }\n-  else\n-    return 0;\n-\n-  return 1;\n+  return {};\n }\n \n /* AArch64 process record-replay constructs: syscall, signal etc.  */"
    },
    {
      "sha": "773a93384f77c6fdbc5a1d46ba569ba3c2956b9b",
      "filename": "gdb/arm-linux-tdep.c",
      "status": "modified",
      "additions": 20,
      "deletions": 25,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/arm-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/arm-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-linux-tdep.c?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -32,6 +32,7 @@\n #include \"breakpoint.h\"\n #include \"auxv.h\"\n #include \"xml-syscall.h\"\n+#include \"expop.h\"\n \n #include \"aarch32-tdep.h\"\n #include \"arch/arm.h\"\n@@ -1146,7 +1147,7 @@ arm_stap_is_single_operand (struct gdbarch *gdbarch, const char *s)\n    It returns one if the special token has been parsed successfully,\n    or zero if the current token is not considered special.  */\n \n-static int\n+static expr::operation_up\n arm_stap_parse_special_token (struct gdbarch *gdbarch,\n \t\t\t      struct stap_parse_info *p)\n {\n@@ -1161,7 +1162,6 @@ arm_stap_parse_special_token (struct gdbarch *gdbarch,\n       int len, offset;\n       int got_minus = 0;\n       long displacement;\n-      struct stoken str;\n \n       ++tmp;\n       start = tmp;\n@@ -1171,7 +1171,7 @@ arm_stap_parse_special_token (struct gdbarch *gdbarch,\n \t++tmp;\n \n       if (*tmp != ',')\n-\treturn 0;\n+\treturn {};\n \n       len = tmp - start;\n       regname = (char *) alloca (len + 2);\n@@ -1212,38 +1212,33 @@ arm_stap_parse_special_token (struct gdbarch *gdbarch,\n \n       /* Skipping last `]'.  */\n       if (*tmp++ != ']')\n-\treturn 0;\n+\treturn {};\n+      p->arg = tmp;\n+\n+      using namespace expr;\n \n       /* The displacement.  */\n-      write_exp_elt_opcode (&p->pstate, OP_LONG);\n-      write_exp_elt_type (&p->pstate, builtin_type (gdbarch)->builtin_long);\n-      write_exp_elt_longcst (&p->pstate, displacement);\n-      write_exp_elt_opcode (&p->pstate, OP_LONG);\n+      struct type *long_type = builtin_type (gdbarch)->builtin_long;\n       if (got_minus)\n-\twrite_exp_elt_opcode (&p->pstate, UNOP_NEG);\n+\tdisplacement = -displacement;\n+      operation_up disp = make_operation<long_const_operation> (long_type,\n+\t\t\t\t\t\t\t\tdisplacement);\n \n       /* The register name.  */\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-      str.ptr = regname;\n-      str.length = len;\n-      write_exp_string (&p->pstate, str);\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n+      operation_up reg\n+\t= make_operation<register_operation> (regname);\n \n-      write_exp_elt_opcode (&p->pstate, BINOP_ADD);\n+      operation_up sum\n+\t= make_operation<add_operation> (std::move (reg), std::move (disp));\n \n       /* Casting to the expected type.  */\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-      write_exp_elt_type (&p->pstate, lookup_pointer_type (p->arg_type));\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-\n-      write_exp_elt_opcode (&p->pstate, UNOP_IND);\n-\n-      p->arg = tmp;\n+      struct type *arg_ptr_type = lookup_pointer_type (p->arg_type);\n+      sum = make_operation<unop_cast_operation> (std::move (sum),\n+\t\t\t\t\t\t arg_ptr_type);\n+      return make_operation<unop_ind_operation> (std::move (sum));\n     }\n-  else\n-    return 0;\n \n-  return 1;\n+  return {};\n }\n \n /* ARM process record-replay constructs: syscall, signal etc.  */"
    },
    {
      "sha": "8fa3cbaea3d252e68484b779c4b0e9624b6996f4",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -4589,7 +4589,7 @@ gdbarch_stap_parse_special_token_p (struct gdbarch *gdbarch)\n   return gdbarch->stap_parse_special_token != NULL;\n }\n \n-int\n+expr::operation_up\n gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, struct stap_parse_info *p)\n {\n   gdb_assert (gdbarch != NULL);"
    },
    {
      "sha": "342c29c59808dbdd65dd90681ffe2502563b036c",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -1346,8 +1346,8 @@ extern void set_gdbarch_stap_is_single_operand (struct gdbarch *gdbarch, gdbarch\n \n extern bool gdbarch_stap_parse_special_token_p (struct gdbarch *gdbarch);\n \n-typedef int (gdbarch_stap_parse_special_token_ftype) (struct gdbarch *gdbarch, struct stap_parse_info *p);\n-extern int gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, struct stap_parse_info *p);\n+typedef expr::operation_up (gdbarch_stap_parse_special_token_ftype) (struct gdbarch *gdbarch, struct stap_parse_info *p);\n+extern expr::operation_up gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, struct stap_parse_info *p);\n extern void set_gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, gdbarch_stap_parse_special_token_ftype *stap_parse_special_token);\n \n /* Perform arch-dependent adjustments to a register name."
    },
    {
      "sha": "84b645e9915c91bae32b390248c73c60a8d465fb",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -994,7 +994,7 @@ M;int;stap_is_single_operand;const char *s;s\n # if the token was not recognized as a special token (in this case, returning\n # zero means that the special parser is deferring the parsing to the generic\n # parser), and should advance the buffer pointer (p->arg).\n-M;int;stap_parse_special_token;struct stap_parse_info *p;p\n+M;expr::operation_up;stap_parse_special_token;struct stap_parse_info *p;p\n \n # Perform arch-dependent adjustments to a register name.\n #"
    },
    {
      "sha": "4f8da924073a09535ba8c25be32a2072361744bc",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 79,
      "deletions": 135,
      "changes": 214,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -48,6 +48,7 @@\n #include \"i387-tdep.h\"\n #include \"gdbsupport/x86-xstate.h\"\n #include \"x86-tdep.h\"\n+#include \"expop.h\"\n \n #include \"record.h\"\n #include \"record-full.h\"\n@@ -4069,7 +4070,7 @@ i386_stap_is_single_operand (struct gdbarch *gdbarch, const char *s)\n    Return true if the operand was parsed successfully, false\n    otherwise.  */\n \n-static bool\n+static expr::operation_up\n i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n \t\t\t\t       struct stap_parse_info *p)\n {\n@@ -4081,9 +4082,7 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n       int i;\n       long displacements[3];\n       const char *start;\n-      char *regname;\n       int len;\n-      struct stoken str;\n       char *endp;\n \n       got_minus[0] = false;\n@@ -4096,15 +4095,15 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n \t}\n \n       if (!isdigit ((unsigned char) *s))\n-\treturn false;\n+\treturn {};\n \n       displacements[0] = strtol (s, &endp, 10);\n       s = endp;\n \n       if (*s != '+' && *s != '-')\n \t{\n \t  /* We are not dealing with a triplet.  */\n-\t  return false;\n+\t  return {};\n \t}\n \n       got_minus[1] = false;\n@@ -4117,15 +4116,15 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n \t}\n \n       if (!isdigit ((unsigned char) *s))\n-\treturn false;\n+\treturn {};\n \n       displacements[1] = strtol (s, &endp, 10);\n       s = endp;\n \n       if (*s != '+' && *s != '-')\n \t{\n \t  /* We are not dealing with a triplet.  */\n-\t  return false;\n+\t  return {};\n \t}\n \n       got_minus[2] = false;\n@@ -4138,13 +4137,13 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n \t}\n \n       if (!isdigit ((unsigned char) *s))\n-\treturn false;\n+\treturn {};\n \n       displacements[2] = strtol (s, &endp, 10);\n       s = endp;\n \n       if (*s != '(' || s[1] != '%')\n-\treturn false;\n+\treturn {};\n \n       s += 2;\n       start = s;\n@@ -4153,57 +4152,46 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n \t++s;\n \n       if (*s++ != ')')\n-\treturn false;\n+\treturn {};\n \n       len = s - start - 1;\n-      regname = (char *) alloca (len + 1);\n-\n-      strncpy (regname, start, len);\n-      regname[len] = '\\0';\n+      std::string regname (start, len);\n \n-      if (user_reg_map_name_to_regnum (gdbarch, regname, len) == -1)\n+      if (user_reg_map_name_to_regnum (gdbarch, regname.c_str (), len) == -1)\n \terror (_(\"Invalid register name `%s' on expression `%s'.\"),\n-\t       regname, p->saved_arg);\n+\t       regname.c_str (), p->saved_arg);\n \n+      LONGEST value = 0;\n       for (i = 0; i < 3; i++)\n \t{\n-\t  write_exp_elt_opcode (&p->pstate, OP_LONG);\n-\t  write_exp_elt_type\n-\t    (&p->pstate, builtin_type (gdbarch)->builtin_long);\n-\t  write_exp_elt_longcst (&p->pstate, displacements[i]);\n-\t  write_exp_elt_opcode (&p->pstate, OP_LONG);\n+\t  LONGEST this_val = displacements[i];\n \t  if (got_minus[i])\n-\t    write_exp_elt_opcode (&p->pstate, UNOP_NEG);\n+\t    this_val = -this_val;\n+\t  value += this_val;\n \t}\n \n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-      str.ptr = regname;\n-      str.length = len;\n-      write_exp_string (&p->pstate, str);\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-      write_exp_elt_type (&p->pstate,\n-\t\t\t  builtin_type (gdbarch)->builtin_data_ptr);\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-\n-      write_exp_elt_opcode (&p->pstate, BINOP_ADD);\n-      write_exp_elt_opcode (&p->pstate, BINOP_ADD);\n-      write_exp_elt_opcode (&p->pstate, BINOP_ADD);\n+      p->arg = s;\n \n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-      write_exp_elt_type (&p->pstate,\n-\t\t\t  lookup_pointer_type (p->arg_type));\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n+      using namespace expr;\n \n-      write_exp_elt_opcode (&p->pstate, UNOP_IND);\n+      struct type *long_type = builtin_type (gdbarch)->builtin_long;\n+      operation_up offset\n+\t= make_operation<long_const_operation> (long_type, value);\n \n-      p->arg = s;\n+      operation_up reg\n+\t= make_operation<register_operation> (std::move (regname));\n+      struct type *void_ptr = builtin_type (gdbarch)->builtin_data_ptr;\n+      reg = make_operation<unop_cast_operation> (std::move (reg), void_ptr);\n \n-      return true;\n+      operation_up sum\n+\t= make_operation<add_operation> (std::move (reg), std::move (offset));\n+      struct type *arg_ptr_type = lookup_pointer_type (p->arg_type);\n+      sum = make_operation<unop_cast_operation> (std::move (sum),\n+\t\t\t\t\t\t arg_ptr_type);\n+      return make_operation<unop_ind_operation> (std::move (sum));\n     }\n \n-  return false;\n+  return {};\n }\n \n /* Helper function for i386_stap_parse_special_token.\n@@ -4215,7 +4203,7 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n    Return true if the operand was parsed successfully, false\n    otherwise.  */\n \n-static bool\n+static expr::operation_up\n i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t\t\t\t\t      struct stap_parse_info *p)\n {\n@@ -4228,11 +4216,8 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n       bool size_minus = false;\n       long size = 0;\n       const char *start;\n-      char *base;\n       int len_base;\n-      char *index;\n       int len_index;\n-      struct stoken base_token, index_token;\n \n       if (*s == '+')\n \t++s;\n@@ -4243,7 +4228,7 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t}\n \n       if (offset_minus && !isdigit (*s))\n-\treturn false;\n+\treturn {};\n \n       if (isdigit (*s))\n \t{\n@@ -4254,7 +4239,7 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t}\n \n       if (*s != '(' || s[1] != '%')\n-\treturn false;\n+\treturn {};\n \n       s += 2;\n       start = s;\n@@ -4263,16 +4248,14 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t++s;\n \n       if (*s != ',' || s[1] != '%')\n-\treturn false;\n+\treturn {};\n \n       len_base = s - start;\n-      base = (char *) alloca (len_base + 1);\n-      strncpy (base, start, len_base);\n-      base[len_base] = '\\0';\n+      std::string base (start, len_base);\n \n-      if (user_reg_map_name_to_regnum (gdbarch, base, len_base) == -1)\n+      if (user_reg_map_name_to_regnum (gdbarch, base.c_str (), len_base) == -1)\n \terror (_(\"Invalid register name `%s' on expression `%s'.\"),\n-\t       base, p->saved_arg);\n+\t       base.c_str (), p->saved_arg);\n \n       s += 2;\n       start = s;\n@@ -4281,16 +4264,15 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t++s;\n \n       len_index = s - start;\n-      index = (char *) alloca (len_index + 1);\n-      strncpy (index, start, len_index);\n-      index[len_index] = '\\0';\n+      std::string index (start, len_index);\n \n-      if (user_reg_map_name_to_regnum (gdbarch, index, len_index) == -1)\n+      if (user_reg_map_name_to_regnum (gdbarch, index.c_str (),\n+\t\t\t\t       len_index) == -1)\n \terror (_(\"Invalid register name `%s' on expression `%s'.\"),\n-\t       index, p->saved_arg);\n+\t       index.c_str (), p->saved_arg);\n \n       if (*s != ',' && *s != ')')\n-\treturn false;\n+\treturn {};\n \n       if (*s == ',')\n \t{\n@@ -4309,85 +4291,60 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t  s = endp;\n \n \t  if (*s != ')')\n-\t    return false;\n+\t    return {};\n \t}\n \n       ++s;\n+      p->arg = s;\n \n-      if (offset)\n+      using namespace expr;\n+\n+      struct type *long_type = builtin_type (gdbarch)->builtin_long;\n+      operation_up reg = make_operation<register_operation> (std::move (base));\n+\n+      if (offset != 0)\n \t{\n-\t  write_exp_elt_opcode (&p->pstate, OP_LONG);\n-\t  write_exp_elt_type (&p->pstate,\n-\t\t\t      builtin_type (gdbarch)->builtin_long);\n-\t  write_exp_elt_longcst (&p->pstate, offset);\n-\t  write_exp_elt_opcode (&p->pstate, OP_LONG);\n \t  if (offset_minus)\n-\t    write_exp_elt_opcode (&p->pstate, UNOP_NEG);\n+\t    offset = -offset;\n+\t  operation_up value\n+\t    = make_operation<long_const_operation> (long_type, offset);\n+\t  reg = make_operation<add_operation> (std::move (reg),\n+\t\t\t\t\t       std::move (value));\n \t}\n \n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-      base_token.ptr = base;\n-      base_token.length = len_base;\n-      write_exp_string (&p->pstate, base_token);\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-\n-      if (offset)\n-\twrite_exp_elt_opcode (&p->pstate, BINOP_ADD);\n-\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-      index_token.ptr = index;\n-      index_token.length = len_index;\n-      write_exp_string (&p->pstate, index_token);\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n+      operation_up ind_reg\n+\t= make_operation<register_operation> (std::move (index));\n \n-      if (size)\n+      if (size != 0)\n \t{\n-\t  write_exp_elt_opcode (&p->pstate, OP_LONG);\n-\t  write_exp_elt_type (&p->pstate,\n-\t\t\t      builtin_type (gdbarch)->builtin_long);\n-\t  write_exp_elt_longcst (&p->pstate, size);\n-\t  write_exp_elt_opcode (&p->pstate, OP_LONG);\n \t  if (size_minus)\n-\t    write_exp_elt_opcode (&p->pstate, UNOP_NEG);\n-\t  write_exp_elt_opcode (&p->pstate, BINOP_MUL);\n+\t    size = -size;\n+\t  operation_up value\n+\t    = make_operation<long_const_operation> (long_type, size);\n+\t  ind_reg = make_operation<mul_operation> (std::move (ind_reg),\n+\t\t\t\t\t\t   std::move (value));\n \t}\n \n-      write_exp_elt_opcode (&p->pstate, BINOP_ADD);\n-\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-      write_exp_elt_type (&p->pstate,\n-\t\t\t  lookup_pointer_type (p->arg_type));\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-\n-      write_exp_elt_opcode (&p->pstate, UNOP_IND);\n-\n-      p->arg = s;\n+      operation_up sum\n+\t= make_operation<add_operation> (std::move (reg),\n+\t\t\t\t\t std::move (ind_reg));\n \n-      return true;\n+      struct type *arg_ptr_type = lookup_pointer_type (p->arg_type);\n+      sum = make_operation<unop_cast_operation> (std::move (sum),\n+\t\t\t\t\t\t arg_ptr_type);\n+      return make_operation<unop_ind_operation> (std::move (sum));\n     }\n \n-  return false;\n+  return {};\n }\n \n /* Implementation of `gdbarch_stap_parse_special_token', as defined in\n    gdbarch.h.  */\n \n-int\n+expr::operation_up\n i386_stap_parse_special_token (struct gdbarch *gdbarch,\n \t\t\t       struct stap_parse_info *p)\n {\n-  /* In order to parse special tokens, we use a state-machine that go\n-     through every known token and try to get a match.  */\n-  enum\n-    {\n-      TRIPLET,\n-      THREE_ARG_DISPLACEMENT,\n-      DONE\n-    };\n-  int current_state;\n-\n-  current_state = TRIPLET;\n-\n   /* The special tokens to be parsed here are:\n \n      - `register base + (register index * size) + offset', as represented\n@@ -4396,26 +4353,13 @@ i386_stap_parse_special_token (struct gdbarch *gdbarch,\n      - Operands of the form `-8+3+1(%rbp)', which must be interpreted as\n      `*(-8 + 3 - 1 + (void *) $eax)'.  */\n \n-  while (current_state != DONE)\n-    {\n-      switch (current_state)\n-\t{\n-\tcase TRIPLET:\n-\t  if (i386_stap_parse_special_token_triplet (gdbarch, p))\n-\t    return 1;\n-\t  break;\n+  expr::operation_up result\n+    = i386_stap_parse_special_token_triplet (gdbarch, p);\n \n-\tcase THREE_ARG_DISPLACEMENT:\n-\t  if (i386_stap_parse_special_token_three_arg_disp (gdbarch, p))\n-\t    return 1;\n-\t  break;\n-\t}\n+  if (result == nullptr)\n+    result = i386_stap_parse_special_token_three_arg_disp (gdbarch, p);\n \n-      /* Advancing to the next state.  */\n-      ++current_state;\n-    }\n-\n-  return 0;\n+  return result;\n }\n \n /* Implementation of 'gdbarch_stap_adjust_register', as defined in"
    },
    {
      "sha": "ee7655e9861ef865e0ef7dc3e0f2ef32f75894dc",
      "filename": "gdb/i386-tdep.h",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/i386-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/i386-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.h?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -22,6 +22,7 @@\n \n #include \"gdbarch.h\"\n #include \"infrun.h\"\n+#include \"expression.h\"\n \n struct frame_info;\n struct gdbarch;\n@@ -485,7 +486,7 @@ extern int i386bsd_sc_reg_offset[];\n extern int i386_stap_is_single_operand (struct gdbarch *gdbarch,\n \t\t\t\t\tconst char *s);\n \n-extern int i386_stap_parse_special_token (struct gdbarch *gdbarch,\n-\t\t\t\t\t  struct stap_parse_info *p);\n+extern expr::operation_up i386_stap_parse_special_token\n+     (struct gdbarch *gdbarch, struct stap_parse_info *p);\n \n #endif /* i386-tdep.h */"
    },
    {
      "sha": "1e94922f25a94edb76cef16e5ca1eb2b9434e9d1",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 16,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -52,6 +52,7 @@\n #include \"linux-record.h\"\n #include \"record-full.h\"\n #include \"infrun.h\"\n+#include \"expop.h\"\n \n #include \"stap-probe.h\"\n #include \"ax.h\"\n@@ -1674,7 +1675,7 @@ ppc_stap_is_single_operand (struct gdbarch *gdbarch, const char *s)\n /* Implementation of `gdbarch_stap_parse_special_token', as defined in\n    gdbarch.h.  */\n \n-static int\n+static expr::operation_up\n ppc_stap_parse_special_token (struct gdbarch *gdbarch,\n \t\t\t      struct stap_parse_info *p)\n {\n@@ -1686,7 +1687,6 @@ ppc_stap_parse_special_token (struct gdbarch *gdbarch,\n       const char *s = p->arg;\n       char *regname;\n       int len;\n-      struct stoken str;\n \n       while (isdigit (*s))\n \t++s;\n@@ -1695,7 +1695,7 @@ ppc_stap_parse_special_token (struct gdbarch *gdbarch,\n \t{\n \t  /* It is a register displacement indeed.  Returning 0 means we are\n \t     deferring the treatment of this case to the generic parser.  */\n-\t  return 0;\n+\t  return {};\n \t}\n \n       len = s - p->arg;\n@@ -1710,22 +1710,14 @@ ppc_stap_parse_special_token (struct gdbarch *gdbarch,\n \terror (_(\"Invalid register name `%s' on expression `%s'.\"),\n \t       regname, p->saved_arg);\n \n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-      str.ptr = regname;\n-      str.length = len;\n-      write_exp_string (&p->pstate, str);\n-      write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-\n       p->arg = s;\n-    }\n-  else\n-    {\n-      /* All the other tokens should be handled correctly by the generic\n-\t parser.  */\n-      return 0;\n+\n+      return expr::make_operation<expr::register_operation> (regname);\n     }\n \n-  return 1;\n+  /* All the other tokens should be handled correctly by the generic\n+     parser.  */\n+  return {};\n }\n \n /* Initialize linux_record_tdep if not initialized yet."
    },
    {
      "sha": "264d91239af13bba8904badd0f26e34ef8f092a4",
      "filename": "gdb/stap-probe.c",
      "status": "modified",
      "additions": 112,
      "deletions": 75,
      "changes": 187,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/stap-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c5e7a930a46ddd6844eb7aede3ef60df535bc33/gdb/stap-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stap-probe.c?ref=4c5e7a930a46ddd6844eb7aede3ef60df535bc33",
      "patch": "@@ -36,6 +36,8 @@\n #include \"parser-defs.h\"\n #include \"language.h\"\n #include \"elf-bfd.h\"\n+#include \"expop.h\"\n+#include <unordered_map>\n \n #include <ctype.h>\n \n@@ -262,10 +264,13 @@ enum stap_operand_prec\n   STAP_OPERAND_PREC_MUL\n };\n \n-static void stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n-\t\t\t\t   enum stap_operand_prec prec);\n+static expr::operation_up stap_parse_argument_1 (struct stap_parse_info *p,\n+\t\t\t\t\t\t expr::operation_up &&lhs,\n+\t\t\t\t\t\t enum stap_operand_prec prec)\n+  ATTRIBUTE_UNUSED_RESULT;\n \n-static void stap_parse_argument_conditionally (struct stap_parse_info *p);\n+static expr::operation_up stap_parse_argument_conditionally\n+     (struct stap_parse_info *p) ATTRIBUTE_UNUSED_RESULT;\n \n /* Returns true if *S is an operator, false otherwise.  */\n \n@@ -427,6 +432,22 @@ stap_get_opcode (const char **s)\n   return op;\n }\n \n+typedef expr::operation_up binop_maker_ftype (expr::operation_up &&,\n+\t\t\t\t\t      expr::operation_up &&);\n+/* Map from an expression opcode to a function that can create a\n+   binary operation of that type.  */\n+static std::unordered_map<exp_opcode, binop_maker_ftype *> stap_maker_map;\n+\n+/* Helper function to create a binary operation.  */\n+static expr::operation_up\n+stap_make_binop (enum exp_opcode opcode, expr::operation_up &&lhs,\n+\t\t expr::operation_up &&rhs)\n+{\n+  auto iter = stap_maker_map.find (opcode);\n+  gdb_assert (iter != stap_maker_map.end ());\n+  return iter->second (std::move (lhs), std::move (rhs));\n+}\n+\n /* Given the bitness of the argument, represented by B, return the\n    corresponding `struct type *', or throw an error if B is\n    unknown.  */\n@@ -676,19 +697,16 @@ stap_check_register_indirection_suffix (struct gdbarch *gdbarch, const char *s,\n    language (e.g., `15' is the 15th general-purpose register), but inside\n    GDB they have a prefix (the letter `r') appended.  */\n \n-static void\n+static expr::operation_up\n stap_parse_register_operand (struct stap_parse_info *p)\n {\n   /* Simple flag to indicate whether we have seen a minus signal before\n      certain number.  */\n   bool got_minus = false;\n-  /* Flags to indicate whether this register access is being displaced and/or\n+  /* Flag to indicate whether this register access is being\n      indirected.  */\n-  bool disp_p = false;\n   bool indirect_p = false;\n   struct gdbarch *gdbarch = p->gdbarch;\n-  /* Needed to generate the register name as a part of an expression.  */\n-  struct stoken str;\n   /* Variables used to extract the register name from the probe's\n      argument.  */\n   const char *start;\n@@ -699,6 +717,8 @@ stap_parse_register_operand (struct stap_parse_info *p)\n   const char *reg_suffix;\n   const char *reg_ind_suffix;\n \n+  using namespace expr;\n+\n   /* Checking for a displacement argument.  */\n   if (*p->arg == '+')\n     {\n@@ -712,23 +732,21 @@ stap_parse_register_operand (struct stap_parse_info *p)\n       ++p->arg;\n     }\n \n+  struct type *long_type = builtin_type (gdbarch)->builtin_long;\n+  operation_up disp_op;\n   if (isdigit (*p->arg))\n     {\n       /* The value of the displacement.  */\n       long displacement;\n       char *endp;\n \n-      disp_p = true;\n       displacement = strtol (p->arg, &endp, 10);\n       p->arg = endp;\n \n       /* Generating the expression for the displacement.  */\n-      write_exp_elt_opcode (&p->pstate, OP_LONG);\n-      write_exp_elt_type (&p->pstate, builtin_type (gdbarch)->builtin_long);\n-      write_exp_elt_longcst (&p->pstate, displacement);\n-      write_exp_elt_opcode (&p->pstate, OP_LONG);\n       if (got_minus)\n-\twrite_exp_elt_opcode (&p->pstate, UNOP_NEG);\n+\tdisplacement = -displacement;\n+      disp_op = make_operation<long_const_operation> (long_type, displacement);\n     }\n \n   /* Getting rid of register indirection prefix.  */\n@@ -738,7 +756,7 @@ stap_parse_register_operand (struct stap_parse_info *p)\n       p->arg += strlen (reg_ind_prefix);\n     }\n \n-  if (disp_p && !indirect_p)\n+  if (disp_op != nullptr && !indirect_p)\n     error (_(\"Invalid register displacement syntax on expression `%s'.\"),\n \t   p->saved_arg);\n \n@@ -796,27 +814,23 @@ stap_parse_register_operand (struct stap_parse_info *p)\n \t\t\t      \" (previous name was '%s')\"),\n \t\t\t    newregname.c_str (), regname.c_str ());\n \n-\t  regname = newregname;\n+\t  regname = std::move (newregname);\n \t}\n     }\n \n-  write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n-  str.ptr = regname.c_str ();\n-  str.length = regname.size ();\n-  write_exp_string (&p->pstate, str);\n-  write_exp_elt_opcode (&p->pstate, OP_REGISTER);\n+  operation_up reg = make_operation<register_operation> (std::move (regname));\n \n   if (indirect_p)\n     {\n-      if (disp_p)\n-\twrite_exp_elt_opcode (&p->pstate, BINOP_ADD);\n+      if (disp_op != nullptr)\n+\treg = make_operation<add_operation> (std::move (disp_op),\n+\t\t\t\t\t     std::move (reg));\n \n       /* Casting to the expected type.  */\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-      write_exp_elt_type (&p->pstate, lookup_pointer_type (p->arg_type));\n-      write_exp_elt_opcode (&p->pstate, UNOP_CAST);\n-\n-      write_exp_elt_opcode (&p->pstate, UNOP_IND);\n+      struct type *arg_ptr_type = lookup_pointer_type (p->arg_type);\n+      reg = make_operation<unop_cast_operation> (std::move (reg),\n+\t\t\t\t\t\t arg_ptr_type);\n+      reg = make_operation<unop_ind_operation> (std::move (reg));\n     }\n \n   /* Getting rid of the register name suffix.  */\n@@ -836,6 +850,8 @@ stap_parse_register_operand (struct stap_parse_info *p)\n \terror (_(\"Missing indirection suffix on expression `%s'.\"),\n \t       p->saved_arg);\n     }\n+\n+  return reg;\n }\n \n /* This function is responsible for parsing a single operand.\n@@ -853,23 +869,24 @@ stap_parse_register_operand (struct stap_parse_info *p)\n    unrecognized operands, allowing arch-specific parsers to be\n    created.  */\n \n-static void\n+static expr::operation_up\n stap_parse_single_operand (struct stap_parse_info *p)\n {\n   struct gdbarch *gdbarch = p->gdbarch;\n   const char *int_prefix = NULL;\n \n+  using namespace expr;\n+\n   /* We first try to parse this token as a \"special token\".  */\n-  if (gdbarch_stap_parse_special_token_p (gdbarch)\n-      && (gdbarch_stap_parse_special_token (gdbarch, p) != 0))\n+  if (gdbarch_stap_parse_special_token_p (gdbarch))\n     {\n-      /* If the return value of the above function is not zero,\n-\t it means it successfully parsed the special token.\n-\n-\t If it is NULL, we try to parse it using our method.  */\n-      return;\n+      operation_up token = gdbarch_stap_parse_special_token (gdbarch, p);\n+      if (token != nullptr)\n+\treturn token;\n     }\n \n+  struct type *long_type = builtin_type (gdbarch)->builtin_long;\n+  operation_up result;\n   if (*p->arg == '-' || *p->arg == '~' || *p->arg == '+' || *p->arg == '!')\n     {\n       char c = *p->arg;\n@@ -912,20 +929,22 @@ stap_parse_single_operand (struct stap_parse_info *p)\n \t    error (_(\"Invalid operator `%c' for register displacement \"\n \t\t     \"on expression `%s'.\"), c, p->saved_arg);\n \n-\t  stap_parse_register_operand (p);\n+\t  result = stap_parse_register_operand (p);\n \t}\n       else\n \t{\n \t  /* This is not a displacement.  We skip the operator, and\n \t     deal with it when the recursion returns.  */\n \t  ++p->arg;\n-\t  stap_parse_argument_conditionally (p);\n+\t  result = stap_parse_argument_conditionally (p);\n \t  if (c == '-')\n-\t    write_exp_elt_opcode (&p->pstate, UNOP_NEG);\n+\t    result = make_operation<unary_neg_operation> (std::move (result));\n \t  else if (c == '~')\n-\t    write_exp_elt_opcode (&p->pstate, UNOP_COMPLEMENT);\n+\t    result = (make_operation<unary_complement_operation>\n+\t\t      (std::move (result)));\n \t  else if (c == '!')\n-\t    write_exp_elt_opcode (&p->pstate, UNOP_LOGICAL_NOT);\n+\t    result = (make_operation<unary_logical_not_operation>\n+\t\t      (std::move (result)));\n \t}\n     }\n   else if (isdigit (*p->arg))\n@@ -953,11 +972,7 @@ stap_parse_single_operand (struct stap_parse_info *p)\n \t  const char *int_suffix;\n \n \t  /* We are dealing with a numeric constant.  */\n-\t  write_exp_elt_opcode (&p->pstate, OP_LONG);\n-\t  write_exp_elt_type (&p->pstate,\n-\t\t\t      builtin_type (gdbarch)->builtin_long);\n-\t  write_exp_elt_longcst (&p->pstate, number);\n-\t  write_exp_elt_opcode (&p->pstate, OP_LONG);\n+\t  result = make_operation<long_const_operation> (long_type, number);\n \n \t  p->arg = tmp;\n \n@@ -968,7 +983,7 @@ stap_parse_single_operand (struct stap_parse_info *p)\n \t\t   p->saved_arg);\n \t}\n       else if (stap_is_register_indirection_prefix (gdbarch, tmp, NULL))\n-\tstap_parse_register_operand (p);\n+\tresult = stap_parse_register_operand (p);\n       else\n \terror (_(\"Unknown numeric token on expression `%s'.\"),\n \t       p->saved_arg);\n@@ -984,10 +999,7 @@ stap_parse_single_operand (struct stap_parse_info *p)\n       number = strtol (p->arg, &endp, 10);\n       p->arg = endp;\n \n-      write_exp_elt_opcode (&p->pstate, OP_LONG);\n-      write_exp_elt_type (&p->pstate, builtin_type (gdbarch)->builtin_long);\n-      write_exp_elt_longcst (&p->pstate, number);\n-      write_exp_elt_opcode (&p->pstate, OP_LONG);\n+      result = make_operation<long_const_operation> (long_type, number);\n \n       if (stap_check_integer_suffix (gdbarch, p->arg, &int_suffix))\n \tp->arg += strlen (int_suffix);\n@@ -997,10 +1009,12 @@ stap_parse_single_operand (struct stap_parse_info *p)\n     }\n   else if (stap_is_register_prefix (gdbarch, p->arg, NULL)\n \t   || stap_is_register_indirection_prefix (gdbarch, p->arg, NULL))\n-    stap_parse_register_operand (p);\n+    result = stap_parse_register_operand (p);\n   else\n     error (_(\"Operator `%c' not recognized on expression `%s'.\"),\n \t   *p->arg, p->saved_arg);\n+\n+  return result;\n }\n \n /* This function parses an argument conditionally, based on single or\n@@ -1009,15 +1023,16 @@ stap_parse_single_operand (struct stap_parse_info *p)\n    starts with `-', `~', `+' (i.e., unary operators), a digit, or\n    something recognized by `gdbarch_stap_is_single_operand'.  */\n \n-static void\n+static expr::operation_up\n stap_parse_argument_conditionally (struct stap_parse_info *p)\n {\n   gdb_assert (gdbarch_stap_is_single_operand_p (p->gdbarch));\n \n+  expr::operation_up result;\n   if (*p->arg == '-' || *p->arg == '~' || *p->arg == '+' || *p->arg == '!'\n       || isdigit (*p->arg)\n       || gdbarch_stap_is_single_operand (p->gdbarch, p->arg))\n-    stap_parse_single_operand (p);\n+    result = stap_parse_single_operand (p);\n   else if (*p->arg == '(')\n     {\n       /* We are dealing with a parenthesized operand.  It means we\n@@ -1027,7 +1042,7 @@ stap_parse_argument_conditionally (struct stap_parse_info *p)\n       p->arg = skip_spaces (p->arg);\n       ++p->inside_paren_p;\n \n-      stap_parse_argument_1 (p, 0, STAP_OPERAND_PREC_NONE);\n+      result = stap_parse_argument_1 (p, {}, STAP_OPERAND_PREC_NONE);\n \n       p->arg = skip_spaces (p->arg);\n       if (*p->arg != ')')\n@@ -1041,13 +1056,16 @@ stap_parse_argument_conditionally (struct stap_parse_info *p)\n     }\n   else\n     error (_(\"Cannot parse expression `%s'.\"), p->saved_arg);\n+\n+  return result;\n }\n \n /* Helper function for `stap_parse_argument'.  Please, see its comments to\n    better understand what this function does.  */\n \n-static void\n-stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n+static expr::operation_up ATTRIBUTE_UNUSED_RESULT\n+stap_parse_argument_1 (struct stap_parse_info *p,\n+\t\t       expr::operation_up &&lhs_in,\n \t\t       enum stap_operand_prec prec)\n {\n   /* This is an operator-precedence parser.\n@@ -1061,13 +1079,15 @@ stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n   if (p->inside_paren_p)\n     p->arg = skip_spaces (p->arg);\n \n-  if (!has_lhs)\n+  using namespace expr;\n+  operation_up lhs = std::move (lhs_in);\n+  if (lhs == nullptr)\n     {\n       /* We were called without a left-side, either because this is the\n \t first call, or because we were called to parse a parenthesized\n \t expression.  It doesn't really matter; we have to parse the\n \t left-side in order to continue the process.  */\n-      stap_parse_argument_conditionally (p);\n+      lhs = stap_parse_argument_conditionally (p);\n     }\n \n   if (p->inside_paren_p)\n@@ -1117,12 +1137,12 @@ stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n \t processing this part of the expression before continuing.  */\n       bool paren_subexp = *p->arg == '(';\n \n-      stap_parse_argument_conditionally (p);\n+      operation_up rhs = stap_parse_argument_conditionally (p);\n       if (p->inside_paren_p)\n \tp->arg = skip_spaces (p->arg);\n       if (paren_subexp)\n \t{\n-\t  write_exp_elt_opcode (&p->pstate, opcode);\n+\t  lhs = stap_make_binop (opcode, std::move (lhs), std::move (rhs));\n \t  continue;\n \t}\n \n@@ -1146,15 +1166,18 @@ stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n \t      break;\n \t    }\n \n-\t  /* Parse the right-side of the expression, but since we already\n-\t     have a left-side at this point, set `has_lhs' to 1.  */\n-\t  stap_parse_argument_1 (p, 1, lookahead_prec);\n+\t  /* Parse the right-side of the expression, using the current\n+\t     right-hand-side as the left-hand-side of the new\n+\t     subexpression.  */\n+\t  rhs = stap_parse_argument_1 (p, std::move (rhs), lookahead_prec);\n \t  if (p->inside_paren_p)\n \t    p->arg = skip_spaces (p->arg);\n \t}\n \n-      write_exp_elt_opcode (&p->pstate, opcode);\n+      lhs = stap_make_binop (opcode, std::move (lhs), std::move (rhs));\n     }\n+\n+  return lhs;\n }\n \n /* Parse a probe's argument.\n@@ -1194,14 +1217,14 @@ stap_parse_argument (const char **arg, struct type *atype,\n   struct stap_parse_info p (*arg, atype, language_def (language_c),\n \t\t\t    gdbarch);\n \n-  stap_parse_argument_1 (&p, 0, STAP_OPERAND_PREC_NONE);\n+  using namespace expr;\n+  operation_up result = stap_parse_argument_1 (&p, {}, STAP_OPERAND_PREC_NONE);\n \n   gdb_assert (p.inside_paren_p == 0);\n \n   /* Casting the final expression to the appropriate type.  */\n-  write_exp_elt_opcode (&p.pstate, UNOP_CAST);\n-  write_exp_elt_type (&p.pstate, atype);\n-  write_exp_elt_opcode (&p.pstate, UNOP_CAST);\n+  result = make_operation<unop_cast_operation> (std::move (result), atype);\n+  p.pstate.set_operation (std::move (result));\n \n   p.arg = skip_spaces (p.arg);\n   *arg = p.arg;\n@@ -1290,12 +1313,6 @@ stap_probe::parse_arguments (struct gdbarch *gdbarch)\n \n       expression_up expr = stap_parse_argument (&cur, atype, gdbarch);\n \n-      if (stap_expression_debug)\n-\tdump_raw_expression (expr.get (), gdb_stdlog,\n-\t\t\t     \"before conversion to prefix form\");\n-\n-      prefixify_expression (expr.get ());\n-\n       if (stap_expression_debug)\n \tdump_prefix_expression (expr.get (), gdb_stdlog);\n \n@@ -1747,4 +1764,24 @@ NAME matches the probe names.\\n\\\n OBJECT matches the executable or shared library name.\"),\n \t   info_probes_cmdlist_get ());\n \n+\n+  using namespace expr;\n+  stap_maker_map[BINOP_ADD] = make_operation<add_operation>;\n+  stap_maker_map[BINOP_BITWISE_AND] = make_operation<bitwise_and_operation>;\n+  stap_maker_map[BINOP_BITWISE_IOR] = make_operation<bitwise_ior_operation>;\n+  stap_maker_map[BINOP_BITWISE_XOR] = make_operation<bitwise_xor_operation>;\n+  stap_maker_map[BINOP_DIV] = make_operation<div_operation>;\n+  stap_maker_map[BINOP_EQUAL] = make_operation<equal_operation>;\n+  stap_maker_map[BINOP_GEQ] = make_operation<geq_operation>;\n+  stap_maker_map[BINOP_GTR] = make_operation<gtr_operation>;\n+  stap_maker_map[BINOP_LEQ] = make_operation<leq_operation>;\n+  stap_maker_map[BINOP_LESS] = make_operation<less_operation>;\n+  stap_maker_map[BINOP_LOGICAL_AND] = make_operation<logical_and_operation>;\n+  stap_maker_map[BINOP_LOGICAL_OR] = make_operation<logical_or_operation>;\n+  stap_maker_map[BINOP_LSH] = make_operation<lsh_operation>;\n+  stap_maker_map[BINOP_MUL] = make_operation<mul_operation>;\n+  stap_maker_map[BINOP_NOTEQUAL] = make_operation<notequal_operation>;\n+  stap_maker_map[BINOP_REM] = make_operation<rem_operation>;\n+  stap_maker_map[BINOP_RSH] = make_operation<rsh_operation>;\n+  stap_maker_map[BINOP_SUB] = make_operation<sub_operation>;\n }"
    }
  ]
}