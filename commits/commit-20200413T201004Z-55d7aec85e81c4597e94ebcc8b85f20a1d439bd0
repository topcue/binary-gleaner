{
  "sha": "55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTVkN2FlYzg1ZTgxYzQ1OTdlOTRlYmNjOGI4NWYyMGExZDQzOWJkMA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-04-13T18:42:59Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-13T20:10:04Z"
    },
    "message": "Switch gdbserver to gdbsupport event loop\n\nThis changes gdbserver to use the gdbserver event loop, removing the\nancient fork.\n\ngdbserver/ChangeLog\n2020-04-13  Tom Tromey  <tom@tromey.com>\n\n\t* server.h (handle_serial_event, handle_target_event): Update.\n\t* server.c: Don't call initialize_event_loop.\n\t(keep_processing_events): New global.\n\t(handle_serial_event): Return void.  Set keep_processing_events.\n\t(handle_target_event): Return void.\n\t(start_event_loop): Move from event-loop.c.  Rewrite.\n\t* remote-utils.c (handle_accept_event): Return void.\n\t(reset_readchar): Use delete_timer.\n\t(process_remaining): Return void.\n\t(reschedule): Use create_timer.\n\t* event-loop.h: Remove.\n\t* event-loop.cc: Remove.\n\t* Makefile.in (OBS): Use gdbsupport/event-loop.o, not event-loop.o.",
    "tree": {
      "sha": "664fe7b861844fbe141d01768c38e2f6b033399e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/664fe7b861844fbe141d01768c38e2f6b033399e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e487f9949ab654b20da8ac01b8311ae956136e5e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e487f9949ab654b20da8ac01b8311ae956136e5e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e487f9949ab654b20da8ac01b8311ae956136e5e"
    }
  ],
  "stats": {
    "total": 688,
    "additions": 60,
    "deletions": 628
  },
  "files": [
    {
      "sha": "1d0fbb87c06e22f404ea414c94706a2640da7e45",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
      "patch": "@@ -1,3 +1,19 @@\n+2020-04-13  Tom Tromey  <tom@tromey.com>\n+\n+\t* server.h (handle_serial_event, handle_target_event): Update.\n+\t* server.c: Don't call initialize_event_loop.\n+\t(keep_processing_events): New global.\n+\t(handle_serial_event): Return void.  Set keep_processing_events.\n+\t(handle_target_event): Return void.\n+\t(start_event_loop): Move from event-loop.c.  Rewrite.\n+\t* remote-utils.c (handle_accept_event): Return void.\n+\t(reset_readchar): Use delete_timer.\n+\t(process_remaining): Return void.\n+\t(reschedule): Use create_timer.\n+\t* event-loop.h: Remove.\n+\t* event-loop.cc: Remove.\n+\t* Makefile.in (OBS): Use gdbsupport/event-loop.o, not event-loop.o.\n+\n 2020-04-13  Tom Tromey  <tom@tromey.com>\n \n \t* server.c (invoke_async_signal_handlers)"
    },
    {
      "sha": "417a530e25d5c96a8281c9af37df5f2c2a7ce36d",
      "filename": "gdbserver/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/Makefile.in?ref=55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
      "patch": "@@ -241,7 +241,6 @@ OBS = \\\n \tax.o \\\n \tdebug.o \\\n \tdll.o \\\n-\tevent-loop.o \\\n \thostio.o \\\n \tinferiors.o \\\n \tmem-break.o \\"
    },
    {
      "sha": "8827e8a32ebb826525385f642036b95f822175a4",
      "filename": "gdbserver/event-loop.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 567,
      "changes": 567,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e487f9949ab654b20da8ac01b8311ae956136e5e/gdbserver/event-loop.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e487f9949ab654b20da8ac01b8311ae956136e5e/gdbserver/event-loop.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/event-loop.cc?ref=e487f9949ab654b20da8ac01b8311ae956136e5e",
      "patch": "@@ -1,567 +0,0 @@\n-/* Event loop machinery for the remote server for GDB.\n-   Copyright (C) 1999-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n-\n-/* Based on src/gdb/event-loop.c.  */\n-\n-#include \"server.h\"\n-\n-#include <sys/types.h>\n-#include \"gdbsupport/gdb_sys_time.h\"\n-\n-#ifdef USE_WIN32API\n-#include <windows.h>\n-#include <io.h>\n-#endif\n-\n-#include <unistd.h>\n-#include <queue>\n-\n-typedef int (event_handler_func) (gdb_fildes_t);\n-\n-/* Tell create_file_handler what events we are interested in.  */\n-\n-#define GDB_READABLE\t(1<<1)\n-#define GDB_WRITABLE\t(1<<2)\n-#define GDB_EXCEPTION\t(1<<3)\n-\n-/* Events are queued by on the event_queue and serviced later\n-   on by do_one_event.  An event can be, for instance, a file\n-   descriptor becoming ready to be read.  Servicing an event simply\n-   means that the procedure PROC will be called.  We have 2 queues,\n-   one for file handlers that we listen to in the event loop, and one\n-   for the file handlers+events that are ready.  The procedure PROC\n-   associated with each event is always the same (handle_file_event).\n-   Its duty is to invoke the handler associated with the file\n-   descriptor whose state change generated the event, plus doing other\n-   cleanups and such.  */\n-\n-struct gdb_event\n-  {\n-    /* Procedure to call to service this event.  */\n-    event_handler_func *proc;\n-\n-    /* File descriptor that is ready.  */\n-    gdb_fildes_t fd;\n-  };\n-\n-/* Information about each file descriptor we register with the event\n-   loop.  */\n-\n-typedef struct file_handler\n-  {\n-    /* File descriptor.  */\n-    gdb_fildes_t fd;\n-\n-    /* Events we want to monitor.  */\n-    int mask;\n-\n-    /* Events that have been seen since the last time.  */\n-    int ready_mask;\n-\n-    /* Procedure to call when fd is ready.  */\n-    handler_func *proc;\n-\n-    /* Argument to pass to proc.  */\n-    gdb_client_data client_data;\n-\n-    /* Was an error detected on this fd?  */\n-    int error;\n-\n-    /* Next registered file descriptor.  */\n-    struct file_handler *next_file;\n-  }\n-file_handler;\n-\n-typedef gdb::unique_xmalloc_ptr<gdb_event> gdb_event_up;\n-\n-static std::queue<gdb_event_up, std::list<gdb_event_up>> event_queue;\n-\n-/* Gdb_notifier is just a list of file descriptors gdb is interested\n-   in.  These are the input file descriptor, and the target file\n-   descriptor.  Each of the elements in the gdb_notifier list is\n-   basically a description of what kind of events gdb is interested\n-   in, for each fd.  */\n-\n-static struct\n-  {\n-    /* Ptr to head of file handler list.  */\n-    file_handler *first_file_handler;\n-\n-    /* Masks to be used in the next call to select.  Bits are set in\n-       response to calls to create_file_handler.  */\n-    fd_set check_masks[3];\n-\n-    /* What file descriptors were found ready by select.  */\n-    fd_set ready_masks[3];\n-\n-    /* Number of valid bits (highest fd value + 1). (for select) */\n-    int num_fds;\n-  }\n-gdb_notifier;\n-\n-/* Callbacks are just routines that are executed before waiting for the\n-   next event.  In GDB this is struct gdb_timer.  We don't need timers\n-   so rather than copy all that complexity in gdbserver, we provide what\n-   we need, but we do so in a way that if/when the day comes that we need\n-   that complexity, it'll be easier to add - replace callbacks with timers\n-   and use a delta of zero (which is all gdb currently uses timers for anyway).\n-\n-   PROC will be executed before gdbserver goes to sleep to wait for the\n-   next event.  */\n-\n-struct callback_event\n-  {\n-    int id;\n-    callback_handler_func *proc;\n-    gdb_client_data data;\n-    struct callback_event *next;\n-  };\n-\n-/* Table of registered callbacks.  */\n-\n-static struct\n-  {\n-    struct callback_event *first;\n-    struct callback_event *last;\n-\n-    /* Id of the last callback created.  */\n-    int num_callbacks;\n-  }\n-callback_list;\n-\n-void\n-initialize_event_loop (void)\n-{\n-}\n-\n-/* Process one event.  If an event was processed, 1 is returned\n-   otherwise 0 is returned.  Scan the queue from head to tail,\n-   processing therefore the high priority events first, by invoking\n-   the associated event handler procedure.  */\n-\n-static int\n-process_event (void)\n-{\n-  /* Let's get rid of the event from the event queue.  We need to\n-     do this now because while processing the event, since the\n-     proc function could end up jumping out to the caller of this\n-     function.  In that case, we would have on the event queue an\n-     event which has been processed, but not deleted.  */\n-  if (!event_queue.empty ())\n-    {\n-      gdb_event_up event_ptr = std::move (event_queue.front ());\n-      event_queue.pop ();\n-\n-      event_handler_func *proc = event_ptr->proc;\n-      gdb_fildes_t fd = event_ptr->fd;\n-\n-      /* Now call the procedure associated with the event.  */\n-      if ((*proc) (fd))\n-\treturn -1;\n-      return 1;\n-    }\n-\n-  /* This is the case if there are no event on the event queue.  */\n-  return 0;\n-}\n-\n-/* Append PROC to the callback list.\n-   The result is the \"id\" of the callback that can be passed back to\n-   delete_callback_event.  */\n-\n-int\n-append_callback_event (callback_handler_func *proc, gdb_client_data data)\n-{\n-  struct callback_event *event_ptr = XNEW (struct callback_event);\n-\n-  event_ptr->id = callback_list.num_callbacks++;\n-  event_ptr->proc = proc;\n-  event_ptr->data = data;\n-  event_ptr->next = NULL;\n-  if (callback_list.first == NULL)\n-    callback_list.first = event_ptr;\n-  if (callback_list.last != NULL)\n-    callback_list.last->next = event_ptr;\n-  callback_list.last = event_ptr;\n-  return event_ptr->id;\n-}\n-\n-/* Delete callback ID.\n-   It is not an error callback ID doesn't exist.  */\n-\n-void\n-delete_callback_event (int id)\n-{\n-  struct callback_event **p;\n-\n-  for (p = &callback_list.first; *p != NULL; p = &(*p)->next)\n-    {\n-      struct callback_event *event_ptr = *p;\n-\n-      if (event_ptr->id == id)\n-\t{\n-\t  *p = event_ptr->next;\n-\t  if (event_ptr == callback_list.last)\n-\t    callback_list.last = NULL;\n-\t  free (event_ptr);\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* Run the next callback.\n-   The result is 1 if a callback was called and event processing\n-   should continue, -1 if the callback wants the event loop to exit,\n-   and 0 if there are no more callbacks.  */\n-\n-static int\n-process_callback (void)\n-{\n-  struct callback_event *event_ptr;\n-\n-  event_ptr = callback_list.first;\n-  if (event_ptr != NULL)\n-    {\n-      callback_handler_func *proc = event_ptr->proc;\n-      gdb_client_data data = event_ptr->data;\n-\n-      /* Remove the event before calling PROC,\n-\t more events may get added by PROC.  */\n-      callback_list.first = event_ptr->next;\n-      if (callback_list.first == NULL)\n-\tcallback_list.last = NULL;\n-      free  (event_ptr);\n-      if ((*proc) (data))\n-\treturn -1;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Add a file handler/descriptor to the list of descriptors we are\n-   interested in.  FD is the file descriptor for the file/stream to be\n-   listened to.  MASK is a combination of READABLE, WRITABLE,\n-   EXCEPTION.  PROC is the procedure that will be called when an event\n-   occurs for FD.  CLIENT_DATA is the argument to pass to PROC.  */\n-\n-static void\n-create_file_handler (gdb_fildes_t fd, int mask, handler_func *proc,\n-\t\t     gdb_client_data client_data)\n-{\n-  file_handler *file_ptr;\n-\n-  /* Do we already have a file handler for this file? (We may be\n-     changing its associated procedure).  */\n-  for (file_ptr = gdb_notifier.first_file_handler;\n-       file_ptr != NULL;\n-       file_ptr = file_ptr->next_file)\n-    if (file_ptr->fd == fd)\n-      break;\n-\n-  /* It is a new file descriptor.  Add it to the list.  Otherwise,\n-     just change the data associated with it.  */\n-  if (file_ptr == NULL)\n-    {\n-      file_ptr = XNEW (struct file_handler);\n-      file_ptr->fd = fd;\n-      file_ptr->ready_mask = 0;\n-      file_ptr->next_file = gdb_notifier.first_file_handler;\n-      gdb_notifier.first_file_handler = file_ptr;\n-\n-      if (mask & GDB_READABLE)\n-\tFD_SET (fd, &gdb_notifier.check_masks[0]);\n-      else\n-\tFD_CLR (fd, &gdb_notifier.check_masks[0]);\n-\n-      if (mask & GDB_WRITABLE)\n-\tFD_SET (fd, &gdb_notifier.check_masks[1]);\n-      else\n-\tFD_CLR (fd, &gdb_notifier.check_masks[1]);\n-\n-      if (mask & GDB_EXCEPTION)\n-\tFD_SET (fd, &gdb_notifier.check_masks[2]);\n-      else\n-\tFD_CLR (fd, &gdb_notifier.check_masks[2]);\n-\n-      if (gdb_notifier.num_fds <= fd)\n-\tgdb_notifier.num_fds = fd + 1;\n-    }\n-\n-  file_ptr->proc = proc;\n-  file_ptr->client_data = client_data;\n-  file_ptr->mask = mask;\n-}\n-\n-/* Wrapper function for create_file_handler.  */\n-\n-void\n-add_file_handler (gdb_fildes_t fd,\n-\t\t  handler_func *proc, gdb_client_data client_data)\n-{\n-  create_file_handler (fd, GDB_READABLE | GDB_EXCEPTION, proc, client_data);\n-}\n-\n-/* Remove the file descriptor FD from the list of monitored fd's:\n-   i.e. we don't care anymore about events on the FD.  */\n-\n-void\n-delete_file_handler (gdb_fildes_t fd)\n-{\n-  file_handler *file_ptr, *prev_ptr = NULL;\n-  int i;\n-\n-  /* Find the entry for the given file. */\n-\n-  for (file_ptr = gdb_notifier.first_file_handler;\n-       file_ptr != NULL;\n-       file_ptr = file_ptr->next_file)\n-    if (file_ptr->fd == fd)\n-      break;\n-\n-  if (file_ptr == NULL)\n-    return;\n-\n-  if (file_ptr->mask & GDB_READABLE)\n-    FD_CLR (fd, &gdb_notifier.check_masks[0]);\n-  if (file_ptr->mask & GDB_WRITABLE)\n-    FD_CLR (fd, &gdb_notifier.check_masks[1]);\n-  if (file_ptr->mask & GDB_EXCEPTION)\n-    FD_CLR (fd, &gdb_notifier.check_masks[2]);\n-\n-  /* Find current max fd.  */\n-\n-  if ((fd + 1) == gdb_notifier.num_fds)\n-    {\n-      gdb_notifier.num_fds--;\n-      for (i = gdb_notifier.num_fds; i; i--)\n-\t{\n-\t  if (FD_ISSET (i - 1, &gdb_notifier.check_masks[0])\n-\t      || FD_ISSET (i - 1, &gdb_notifier.check_masks[1])\n-\t      || FD_ISSET (i - 1, &gdb_notifier.check_masks[2]))\n-\t    break;\n-\t}\n-      gdb_notifier.num_fds = i;\n-    }\n-\n-  /* Deactivate the file descriptor, by clearing its mask, so that it\n-     will not fire again.  */\n-\n-  file_ptr->mask = 0;\n-\n-  /* Get rid of the file handler in the file handler list.  */\n-  if (file_ptr == gdb_notifier.first_file_handler)\n-    gdb_notifier.first_file_handler = file_ptr->next_file;\n-  else\n-    {\n-      for (prev_ptr = gdb_notifier.first_file_handler;\n-\t   prev_ptr->next_file != file_ptr;\n-\t   prev_ptr = prev_ptr->next_file)\n-\t;\n-      prev_ptr->next_file = file_ptr->next_file;\n-    }\n-  free (file_ptr);\n-}\n-\n-/* Handle the given event by calling the procedure associated to the\n-   corresponding file handler.  Called by process_event indirectly,\n-   through event_ptr->proc.  EVENT_FILE_DESC is file descriptor of the\n-   event in the front of the event queue.  */\n-\n-static int\n-handle_file_event (gdb_fildes_t event_file_desc)\n-{\n-  file_handler *file_ptr;\n-  int mask;\n-\n-  /* Search the file handler list to find one that matches the fd in\n-     the event.  */\n-  for (file_ptr = gdb_notifier.first_file_handler; file_ptr != NULL;\n-       file_ptr = file_ptr->next_file)\n-    {\n-      if (file_ptr->fd == event_file_desc)\n-\t{\n-\t  /* See if the desired events (mask) match the received\n-\t     events (ready_mask).  */\n-\n-\t  if (file_ptr->ready_mask & GDB_EXCEPTION)\n-\t    {\n-\t      warning (\"Exception condition detected on fd %s\",\n-\t\t       pfildes (file_ptr->fd));\n-\t      file_ptr->error = 1;\n-\t    }\n-\t  else\n-\t    file_ptr->error = 0;\n-\t  mask = file_ptr->ready_mask & file_ptr->mask;\n-\n-\t  /* Clear the received events for next time around.  */\n-\t  file_ptr->ready_mask = 0;\n-\n-\t  /* If there was a match, then call the handler.  */\n-\t  if (mask != 0)\n-\t    {\n-\t      if ((*file_ptr->proc) (file_ptr->error,\n-\t\t\t\t     file_ptr->client_data) < 0)\n-\t\treturn -1;\n-\t    }\n-\t  break;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Create a file event, to be enqueued in the event queue for\n-   processing.  The procedure associated to this event is always\n-   handle_file_event, which will in turn invoke the one that was\n-   associated to FD when it was registered with the event loop.  */\n-\n-static gdb_event *\n-create_file_event (gdb_fildes_t fd)\n-{\n-  gdb_event *file_event_ptr;\n-\n-  file_event_ptr = XNEW (gdb_event);\n-  file_event_ptr->proc = handle_file_event;\n-  file_event_ptr->fd = fd;\n-\n-  return file_event_ptr;\n-}\n-\n-/* Called by do_one_event to wait for new events on the monitored file\n-   descriptors.  Queue file events as they are detected by the poll.\n-   If there are no events, this function will block in the call to\n-   select.  Return -1 if there are no files descriptors to monitor,\n-   otherwise return 0.  */\n-\n-static int\n-wait_for_event (void)\n-{\n-  file_handler *file_ptr;\n-  int num_found = 0;\n-\n-  /* Make sure all output is done before getting another event.  */\n-  fflush (stdout);\n-  fflush (stderr);\n-\n-  if (gdb_notifier.num_fds == 0)\n-    return -1;\n-\n-  gdb_notifier.ready_masks[0] = gdb_notifier.check_masks[0];\n-  gdb_notifier.ready_masks[1] = gdb_notifier.check_masks[1];\n-  gdb_notifier.ready_masks[2] = gdb_notifier.check_masks[2];\n-  num_found = select (gdb_notifier.num_fds,\n-\t\t      &gdb_notifier.ready_masks[0],\n-\t\t      &gdb_notifier.ready_masks[1],\n-\t\t      &gdb_notifier.ready_masks[2],\n-\t\t      NULL);\n-\n-  /* Clear the masks after an error from select.  */\n-  if (num_found == -1)\n-    {\n-      FD_ZERO (&gdb_notifier.ready_masks[0]);\n-      FD_ZERO (&gdb_notifier.ready_masks[1]);\n-      FD_ZERO (&gdb_notifier.ready_masks[2]);\n-#ifdef EINTR\n-      /* Dont print anything if we got a signal, let gdb handle\n-\t it.  */\n-      if (errno != EINTR)\n-\tperror_with_name (\"select\");\n-#endif\n-    }\n-\n-  /* Enqueue all detected file events.  */\n-\n-  for (file_ptr = gdb_notifier.first_file_handler;\n-       file_ptr != NULL && num_found > 0;\n-       file_ptr = file_ptr->next_file)\n-    {\n-      int mask = 0;\n-\n-      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[0]))\n-\tmask |= GDB_READABLE;\n-      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[1]))\n-\tmask |= GDB_WRITABLE;\n-      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[2]))\n-\tmask |= GDB_EXCEPTION;\n-\n-      if (!mask)\n-\tcontinue;\n-      else\n-\tnum_found--;\n-\n-      /* Enqueue an event only if this is still a new event for this\n-\t fd.  */\n-\n-      if (file_ptr->ready_mask == 0)\n-\t{\n-\t  gdb_event *file_event_ptr = create_file_event (file_ptr->fd);\n-\n-\t  event_queue.emplace (file_event_ptr);\n-\t}\n-      file_ptr->ready_mask = mask;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Start up the event loop.  This is the entry point to the event\n-   loop.  */\n-\n-void\n-start_event_loop (void)\n-{\n-  /* Loop until there is nothing to do.  This is the entry point to\n-     the event loop engine.  If nothing is ready at this time, wait\n-     for something to happen (via wait_for_event), then process it.\n-     Return when there are no longer event sources to wait for.  */\n-\n-  while (1)\n-    {\n-      /* Any events already waiting in the queue?  */\n-      int res = process_event ();\n-\n-      /* Did the event handler want the event loop to stop?  */\n-      if (res == -1)\n-\treturn;\n-\n-      if (res)\n-\tcontinue;\n-\n-      /* Process any queued callbacks before we go to sleep.  */\n-      res = process_callback ();\n-\n-      /* Did the callback want the event loop to stop?  */\n-      if (res == -1)\n-\treturn;\n-\n-      if (res)\n-\tcontinue;\n-\n-      /* Wait for a new event.  If wait_for_event returns -1, we\n-\t should get out because this means that there are no event\n-\t sources left.  This will make the event loop stop, and the\n-\t application exit.  */\n-\n-      if (wait_for_event () < 0)\n-\treturn;\n-    }\n-\n-  /* We are done with the event loop.  There are no more event sources\n-     to listen to.  So we exit gdbserver.  */\n-}"
    },
    {
      "sha": "a49173e867da06023f16fe739ad4b29ae539492a",
      "filename": "gdbserver/event-loop.h",
      "status": "removed",
      "additions": 0,
      "deletions": 36,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e487f9949ab654b20da8ac01b8311ae956136e5e/gdbserver/event-loop.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e487f9949ab654b20da8ac01b8311ae956136e5e/gdbserver/event-loop.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/event-loop.h?ref=e487f9949ab654b20da8ac01b8311ae956136e5e",
      "patch": "@@ -1,36 +0,0 @@\n-/* Event loop machinery for the remote server for GDB.\n-   Copyright (C) 1993-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GDBSERVER_EVENT_LOOP_H\n-#define GDBSERVER_EVENT_LOOP_H\n-\n-typedef void *gdb_client_data;\n-typedef int (handler_func) (int, gdb_client_data);\n-typedef int (callback_handler_func) (gdb_client_data);\n-\n-extern void delete_file_handler (gdb_fildes_t fd);\n-extern void add_file_handler (gdb_fildes_t fd, handler_func *proc,\n-\t\t\t      gdb_client_data client_data);\n-extern int append_callback_event (callback_handler_func *proc,\n-\t\t\t\t   gdb_client_data client_data);\n-extern void delete_callback_event (int id);\n-\n-extern void start_event_loop (void);\n-extern void initialize_event_loop (void);\n-\n-#endif /* GDBSERVER_EVENT_LOOP_H */"
    },
    {
      "sha": "6249691954d62d1d347e66963f4a5bcd5fbf01d9",
      "filename": "gdbserver/remote-utils.cc",
      "status": "modified",
      "additions": 5,
      "deletions": 13,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/remote-utils.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/remote-utils.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.cc?ref=55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
      "patch": "@@ -144,7 +144,7 @@ enable_async_notification (int fd)\n #endif\n }\n \n-static int\n+static void\n handle_accept_event (int err, gdb_client_data client_data)\n {\n   struct sockaddr_storage sockaddr;\n@@ -213,8 +213,6 @@ handle_accept_event (int err, gdb_client_data client_data)\n      until GDB as selected all-stop/non-stop, and has queried the\n      threads' status ('?').  */\n   target_async (0);\n-\n-  return 0;\n }\n \n /* Prepare for a later connection to a remote debugger.\n@@ -930,27 +928,21 @@ reset_readchar (void)\n   readchar_bufcnt = 0;\n   if (readchar_callback != NOT_SCHEDULED)\n     {\n-      delete_callback_event (readchar_callback);\n+      delete_timer (readchar_callback);\n       readchar_callback = NOT_SCHEDULED;\n     }\n }\n \n /* Process remaining data in readchar_buf.  */\n \n-static int\n+static void\n process_remaining (void *context)\n {\n-  int res;\n-\n   /* This is a one-shot event.  */\n   readchar_callback = NOT_SCHEDULED;\n \n   if (readchar_bufcnt > 0)\n-    res = handle_serial_event (0, NULL);\n-  else\n-    res = 0;\n-\n-  return res;\n+    handle_serial_event (0, NULL);\n }\n \n /* If there is still data in the buffer, queue another event to process it,\n@@ -960,7 +952,7 @@ static void\n reschedule (void)\n {\n   if (readchar_bufcnt > 0 && readchar_callback == NOT_SCHEDULED)\n-    readchar_callback = append_callback_event (process_remaining, NULL);\n+    readchar_callback = create_timer (0, process_remaining, NULL);\n }\n \n /* Read a packet from the remote machine, with error checking,"
    },
    {
      "sha": "77175ff74cb3e1b698e8fb1922859568de71e6d1",
      "filename": "gdbserver/server.cc",
      "status": "modified",
      "additions": 36,
      "deletions": 8,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/server.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/server.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.cc?ref=55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
      "patch": "@@ -83,6 +83,10 @@ bool run_once;\n /* Whether to report TARGET_WAITKIND_NO_RESUMED events.  */\n static bool report_no_resumed;\n \n+/* The event loop checks this to decide whether to continue accepting\n+   events.  */\n+static bool keep_processing_events = true;\n+\n bool non_stop;\n \n static struct {\n@@ -3463,6 +3467,32 @@ gdbserver_show_disableable (FILE *stream)\n \t   \"  threads     \\tAll of the above\\n\");\n }\n \n+/* Start up the event loop.  This is the entry point to the event\n+   loop.  */\n+\n+static void\n+start_event_loop ()\n+{\n+  /* Loop until there is nothing to do.  This is the entry point to\n+     the event loop engine.  If nothing is ready at this time, wait\n+     for something to happen (via wait_for_event), then process it.\n+     Return when there are no longer event sources to wait for.  */\n+\n+  keep_processing_events = true;\n+  while (keep_processing_events)\n+    {\n+      /* Any events already waiting in the queue?  */\n+      int res = gdb_do_one_event ();\n+\n+      /* Was there an error?  */\n+      if (res == -1)\n+\tbreak;\n+    }\n+\n+  /* We are done with the event loop.  There are no more event sources\n+     to listen to.  So we exit gdbserver.  */\n+}\n+\n static void\n kill_inferior_callback (process_info *process)\n {\n@@ -3762,7 +3792,6 @@ captured_main (int argc, char *argv[])\n   initialize_async_io ();\n   initialize_low ();\n   have_job_control ();\n-  initialize_event_loop ();\n   if (target_supports_tracepoints ())\n     initialize_tracepoint ();\n \n@@ -4365,21 +4394,22 @@ process_serial_event (void)\n \n /* Event-loop callback for serial events.  */\n \n-int\n+void\n handle_serial_event (int err, gdb_client_data client_data)\n {\n   if (debug_threads)\n     debug_printf (\"handling possible serial event\\n\");\n \n   /* Really handle it.  */\n   if (process_serial_event () < 0)\n-    return -1;\n+    {\n+      keep_processing_events = false;\n+      return;\n+    }\n \n   /* Be sure to not change the selected thread behind GDB's back.\n      Important in the non-stop mode asynchronous protocol.  */\n   set_desired_thread ();\n-\n-  return 0;\n }\n \n /* Push a stop notification on the notification queue.  */\n@@ -4397,7 +4427,7 @@ push_stop_notification (ptid_t ptid, struct target_waitstatus *status)\n \n /* Event-loop callback for target events.  */\n \n-int\n+void\n handle_target_event (int err, gdb_client_data client_data)\n {\n   client_state &cs = get_client_state ();\n@@ -4474,8 +4504,6 @@ handle_target_event (int err, gdb_client_data client_data)\n   /* Be sure to not change the selected thread behind GDB's back.\n      Important in the non-stop mode asynchronous protocol.  */\n   set_desired_thread ();\n-\n-  return 0;\n }\n \n /* See gdbsupport/event-loop.h.  */"
    },
    {
      "sha": "039082e2eff5594238b99ad3f079dd1baacf3053",
      "filename": "gdbserver/server.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/server.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/55d7aec85e81c4597e94ebcc8b85f20a1d439bd0/gdbserver/server.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.h?ref=55d7aec85e81c4597e94ebcc8b85f20a1d439bd0",
      "patch": "@@ -88,13 +88,13 @@ typedef SOCKET gdb_fildes_t;\n typedef int gdb_fildes_t;\n #endif\n \n-#include \"event-loop.h\"\n+#include \"gdbsupport/event-loop.h\"\n \n /* Functions from server.c.  */\n extern void handle_v_requests (char *own_buf, int packet_len,\n \t\t\t       int *new_packet_len);\n-extern int handle_serial_event (int err, gdb_client_data client_data);\n-extern int handle_target_event (int err, gdb_client_data client_data);\n+extern void handle_serial_event (int err, gdb_client_data client_data);\n+extern void handle_target_event (int err, gdb_client_data client_data);\n \n /* Get rid of the currently pending stop replies that match PTID.  */\n extern void discard_queued_stop_replies (ptid_t ptid);"
    }
  ]
}