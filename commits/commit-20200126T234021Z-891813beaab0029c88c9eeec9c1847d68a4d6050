{
  "sha": "891813beaab0029c88c9eeec9c1847d68a4d6050",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODkxODEzYmVhYWIwMDI5Yzg4YzllZWVjOWMxODQ3ZDY4YTRkNjA1MA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-10-22T23:28:37Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-01-26T23:40:21Z"
    },
    "message": "Introduce partial_symtab::read_symtab method\n\nThis introduces a new partial_symtab::read_symtab method, and updates\nthe symbol readers to subclass partial_symtab and implement this\nmethod.  The old read_symtab and read_symtab_private members are\nremoved.\n\nIn practice, only DWARF and CTF are truly updated to take advantage of\nthe new setup.  The other symbol readers are less actively maintained,\nand so this patch also introduces a \"legacy_psymtab\", which\nessentially works the same way as the old partial_symtab.\n\n(Note that, without more knowledge of the interaction between these\nsymbol readers, fixing this to remove the new (small) overhead is not\ntrivial, because these readers copy the read_symtab pointer between\npartial symtabs.)\n\ngdb/ChangeLog\n2020-01-26  Tom Tromey  <tom@tromey.com>\n\n\t* xcoffread.c (this_symtab_psymtab, read_xcoff_symtab)\n\t(xcoff_psymtab_to_symtab_1, xcoff_read_symtab)\n\t(xcoff_start_psymtab, xcoff_end_psymtab, scan_xcoff_symtab): Use\n\tlegacy_symtab.\n\t* stabsread.h (dbx_end_psymtab): Use legacy_symtab.\n\t* psymtab.c (psymtab_to_symtab): Call method.\n\t(dump_psymtab): Update.\n\t* psympriv.h (struct partial_symtab): Add virtual destructor.\n\t<read_symtab>: New method.\n\t(struct legacy_symtab): New.\n\t* mdebugread.c (mdebug_read_symtab): Use legacy_psymtab.\n\t(struct pst_map) <pst>: Now a legacy_psymtab.\n\t(parse_procedure, parse_partial_symbols, psymtab_to_symtab_1)\n\t(new_psymtab): Use legacy_psymtab.\n\t* dwarf2read.h (struct dwarf2_psymtab): New.\n\t(struct dwarf2_per_cu_data) <psymtab>: Use it.\n\t* dwarf2read.c (dwarf2_create_include_psymtab)\n\t(dwarf2_build_include_psymtabs, create_type_unit_group)\n\t(create_partial_symtab, process_psymtab_comp_unit_reader)\n\t(build_type_psymtabs_reader, build_type_psymtab_dependencies)\n\t(set_partial_user): Use dwarf2_psymtab.\n\t(dwarf2_psymtab::read_symtab): Rename from dwarf2_read_symtab.\n\t(psymtab_to_symtab_1, process_full_comp_unit)\n\t(process_full_type_unit, dwarf2_ranges_read)\n\t(dwarf2_get_pc_bounds, psymtab_include_file_name)\n\t(dwarf_decode_lines): Use dwarf2_psymtab.\n\t* dwarf-index-write.c (psym_index_map): Use dwarf2_psymtab.\n\t(add_address_entry_worker, write_one_signatured_type)\n\t(recursively_count_psymbols, recursively_write_psymbols)\n\t(write_one_signatured_type, psyms_seen_size, write_gdbindex)\n\t(write_debug_names): Likewise.\n\t* dbxread.c (struct header_file_location): Take a legacy_psymtab.\n\t<pst>: Now a legacy_psymtab.\n\t(find_corresponding_bincl_psymtab): Return a legacy_psymtab.\n\t(read_dbx_symtab, start_psymtab, dbx_end_psymtab)\n\t(dbx_psymtab_to_symtab_1, read_ofile_symtab): Use legacy_psymtab.\n\t* ctfread.c (struct ctf_psymtab): New.\n\t(ctf_start_symtab, ctf_end_symtab, psymtab_to_symtab): Take a\n\tctf_psymtab.\n\t(ctf_psymtab::read_symtab): Rename from ctf_read_symtab.\n\t(create_partial_symtab): Return a ctf_psymtab.\n\t(scan_partial_symbols): Update.\n\nChange-Id: Ia57a828786867d6ad03200af8f996f48ed15285e",
    "tree": {
      "sha": "b8f7d6ed3f2dc760bab54a5f641c044ca104cc98",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b8f7d6ed3f2dc760bab54a5f641c044ca104cc98"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/891813beaab0029c88c9eeec9c1847d68a4d6050",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/891813beaab0029c88c9eeec9c1847d68a4d6050",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/891813beaab0029c88c9eeec9c1847d68a4d6050",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/891813beaab0029c88c9eeec9c1847d68a4d6050/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c3693a1d9466bc9d3abe004e66f1b56fed22ba61",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c3693a1d9466bc9d3abe004e66f1b56fed22ba61",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c3693a1d9466bc9d3abe004e66f1b56fed22ba61"
    }
  ],
  "stats": {
    "total": 451,
    "additions": 277,
    "deletions": 174
  },
  "files": [
    {
      "sha": "8fcb24ec5cd1055261135693dc0f8f8939f3bbf5",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 45,
      "deletions": 0,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -1,3 +1,48 @@\n+2020-01-26  Tom Tromey  <tom@tromey.com>\n+\n+\t* xcoffread.c (this_symtab_psymtab, read_xcoff_symtab)\n+\t(xcoff_psymtab_to_symtab_1, xcoff_read_symtab)\n+\t(xcoff_start_psymtab, xcoff_end_psymtab, scan_xcoff_symtab): Use\n+\tlegacy_symtab.\n+\t* stabsread.h (dbx_end_psymtab): Use legacy_symtab.\n+\t* psymtab.c (psymtab_to_symtab): Call method.\n+\t(dump_psymtab): Update.\n+\t* psympriv.h (struct partial_symtab): Add virtual destructor.\n+\t<read_symtab>: New method.\n+\t(struct legacy_symtab): New.\n+\t* mdebugread.c (mdebug_read_symtab): Use legacy_psymtab.\n+\t(struct pst_map) <pst>: Now a legacy_psymtab.\n+\t(parse_procedure, parse_partial_symbols, psymtab_to_symtab_1)\n+\t(new_psymtab): Use legacy_psymtab.\n+\t* dwarf2read.h (struct dwarf2_psymtab): New.\n+\t(struct dwarf2_per_cu_data) <psymtab>: Use it.\n+\t* dwarf2read.c (dwarf2_create_include_psymtab)\n+\t(dwarf2_build_include_psymtabs, create_type_unit_group)\n+\t(create_partial_symtab, process_psymtab_comp_unit_reader)\n+\t(build_type_psymtabs_reader, build_type_psymtab_dependencies)\n+\t(set_partial_user): Use dwarf2_psymtab.\n+\t(dwarf2_psymtab::read_symtab): Rename from dwarf2_read_symtab.\n+\t(psymtab_to_symtab_1, process_full_comp_unit)\n+\t(process_full_type_unit, dwarf2_ranges_read)\n+\t(dwarf2_get_pc_bounds, psymtab_include_file_name)\n+\t(dwarf_decode_lines): Use dwarf2_psymtab.\n+\t* dwarf-index-write.c (psym_index_map): Use dwarf2_psymtab.\n+\t(add_address_entry_worker, write_one_signatured_type)\n+\t(recursively_count_psymbols, recursively_write_psymbols)\n+\t(write_one_signatured_type, psyms_seen_size, write_gdbindex)\n+\t(write_debug_names): Likewise.\n+\t* dbxread.c (struct header_file_location): Take a legacy_psymtab.\n+\t<pst>: Now a legacy_psymtab.\n+\t(find_corresponding_bincl_psymtab): Return a legacy_psymtab.\n+\t(read_dbx_symtab, start_psymtab, dbx_end_psymtab)\n+\t(dbx_psymtab_to_symtab_1, read_ofile_symtab): Use legacy_psymtab.\n+\t* ctfread.c (struct ctf_psymtab): New.\n+\t(ctf_start_symtab, ctf_end_symtab, psymtab_to_symtab): Take a\n+\tctf_psymtab.\n+\t(ctf_psymtab::read_symtab): Rename from ctf_read_symtab.\n+\t(create_partial_symtab): Return a ctf_psymtab.\n+\t(scan_partial_symbols): Update.\n+\n 2020-01-26  Tom Tromey  <tom@tromey.com>\n \n \t* xcoffread.c (xcoff_start_psymtab): Use new."
    },
    {
      "sha": "120c7b4017a6730b79f2119e14c1b57fd7ced8a7",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 38,
      "deletions": 26,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -115,6 +115,19 @@ struct ctf_context\n   struct buildsym_compunit *builder;\n };\n \n+/* A partial symtab, specialized for this module.  */\n+struct ctf_psymtab : public partial_symtab\n+{\n+  ctf_psymtab (const char *filename, struct objfile *objfile, CORE_ADDR addr)\n+    : partial_symtab (filename, objfile, addr)\n+  {\n+  }\n+\n+  void read_symtab (struct objfile *) override;\n+\n+  struct ctf_context *context;\n+};\n+\n /* The routines that read and process fields/members of a C struct, union,\n    or enumeration, pass lists of data member fields in an instance of a\n    ctf_field_info structure. It is derived from dwarf2read.c.  */\n@@ -147,7 +160,7 @@ struct ctf_field_info\n \n /* Local function prototypes */\n \n-static void psymtab_to_symtab (struct partial_symtab *);\n+static void psymtab_to_symtab (ctf_psymtab *);\n \n static int ctf_add_type_cb (ctf_id_t tid, void *arg);\n \n@@ -1171,12 +1184,12 @@ get_objfile_text_range (struct objfile *of, int *tsize)\n /* Start a symtab for OBJFILE in CTF format.  */\n \n static void\n-ctf_start_symtab (struct partial_symtab *pst,\n+ctf_start_symtab (ctf_psymtab *pst,\n \t\t  struct objfile *of, CORE_ADDR text_offset)\n {\n   struct ctf_context *ccp;\n \n-  ccp = (struct ctf_context *) pst->read_symtab_private;\n+  ccp = pst->context;\n   ccp->builder = new buildsym_compunit\n \t\t       (of, of->original_name, NULL,\n \t\t       language_c, text_offset);\n@@ -1188,12 +1201,12 @@ ctf_start_symtab (struct partial_symtab *pst,\n    the .text section number.  */\n \n static struct compunit_symtab *\n-ctf_end_symtab (struct partial_symtab *pst,\n+ctf_end_symtab (ctf_psymtab *pst,\n \t\tCORE_ADDR end_addr, int section)\n {\n   struct ctf_context *ccp;\n \n-  ccp = (struct ctf_context *) pst->read_symtab_private;\n+  ccp = pst->context;\n   struct compunit_symtab *result\n     = ccp->builder->end_symtab (end_addr, section);\n   delete ccp->builder;\n@@ -1204,14 +1217,14 @@ ctf_end_symtab (struct partial_symtab *pst,\n /* Read in full symbols for PST, and anything it depends on.  */\n \n static void\n-psymtab_to_symtab (struct partial_symtab *pst)\n+psymtab_to_symtab (ctf_psymtab *pst)\n {\n   struct symbol *sym;\n   struct ctf_context *ccp;\n \n   gdb_assert (!pst->readin);\n \n-  ccp = (struct ctf_context *) pst->read_symtab_private;\n+  ccp = pst->context;\n \n   /* Iterate over entries in data types section.  */\n   if (ctf_type_iter (ccp->fp, ctf_add_type_cb, ccp) == CTF_ERR)\n@@ -1247,31 +1260,31 @@ psymtab_to_symtab (struct partial_symtab *pst)\n /* Expand partial symbol table PST into a full symbol table.\n    PST is not NULL.  */\n \n-static void\n-ctf_read_symtab (struct partial_symtab *pst, struct objfile *objfile)\n+void\n+ctf_psymtab::read_symtab (struct objfile *objfile)\n {\n-  if (pst->readin)\n-    warning (_(\"bug: psymtab for %s is already read in.\"), pst->filename);\n+  if (readin)\n+    warning (_(\"bug: psymtab for %s is already read in.\"), filename);\n   else\n     {\n       if (info_verbose)\n \t{\n-\t  printf_filtered (_(\"Reading in CTF data for %s...\"), pst->filename);\n+\t  printf_filtered (_(\"Reading in CTF data for %s...\"), filename);\n \t  gdb_flush (gdb_stdout);\n \t}\n \n       /* Start a symtab.  */\n-      CORE_ADDR text_offset;        /* Start of text segment.  */\n+      CORE_ADDR offset;        /* Start of text segment.  */\n       int tsize;\n \n-      text_offset = get_objfile_text_range (objfile, &tsize);\n-      ctf_start_symtab (pst, objfile, text_offset);\n-      psymtab_to_symtab (pst);\n+      offset = get_objfile_text_range (objfile, &tsize);\n+      ctf_start_symtab (this, objfile, offset);\n+      psymtab_to_symtab (this);\n \n-      pst->set_text_low (text_offset);\n-      pst->set_text_high (text_offset + tsize);\n-      pst->compunit_symtab = ctf_end_symtab (pst, text_offset + tsize,\n-\t\t\t\t\t     SECT_OFF_TEXT (objfile));\n+      set_text_low (offset);\n+      set_text_high (offset + tsize);\n+      compunit_symtab = ctf_end_symtab (this, offset + tsize,\n+\t\t\t\t\tSECT_OFF_TEXT (objfile));\n \n       /* Finish up the debug error message.  */\n       if (info_verbose)\n@@ -1291,21 +1304,20 @@ ctf_read_symtab (struct partial_symtab *pst, struct objfile *objfile)\n    partial_symtab remains around.  They are allocated on an obstack,\n    objfile_obstack.  */\n \n-static struct partial_symtab *\n+static ctf_psymtab *\n create_partial_symtab (const char *name,\n \t\t       ctf_file_t *cfp,\n \t\t       struct objfile *objfile)\n {\n-  struct partial_symtab *pst;\n+  ctf_psymtab *pst;\n   struct ctf_context *ccx;\n \n-  pst = new partial_symtab (name, objfile, 0);\n+  pst = new ctf_psymtab (name, objfile, 0);\n \n   ccx = XOBNEW (&objfile->objfile_obstack, struct ctf_context);\n   ccx->fp = cfp;\n   ccx->of = objfile;\n-  pst->read_symtab_private = (void *) ccx;\n-  pst->read_symtab = ctf_read_symtab;\n+  pst->context = ccx;\n \n   return pst;\n }\n@@ -1393,7 +1405,7 @@ scan_partial_symbols (ctf_file_t *cfp, struct objfile *of)\n   struct ctf_context ccx;\n   bfd *abfd = of->obfd;\n   const char *name = bfd_get_filename (abfd);\n-  struct partial_symtab *pst = create_partial_symtab (name, cfp, of);\n+  ctf_psymtab *pst = create_partial_symtab (name, cfp, of);\n \n   ccx.fp = cfp;\n   ccx.of = of;"
    },
    {
      "sha": "64387c62c17909687c73b4b36ef2259fdba6d2a9",
      "filename": "gdb/dbxread.c",
      "status": "modified",
      "additions": 37,
      "deletions": 37,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/dbxread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/dbxread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dbxread.c?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -245,7 +245,7 @@ find_text_range (bfd * sym_bfd, struct objfile *objfile)\n struct header_file_location\n {\n   header_file_location (const char *name_, int instance_,\n-\t\t\tstruct partial_symtab *pst_)\n+\t\t\tlegacy_psymtab *pst_)\n     : name (name_),\n       instance (instance_),\n       pst (pst_)\n@@ -254,7 +254,7 @@ struct header_file_location\n \n   const char *name;\t\t/* Name of header file */\n   int instance;\t\t\t/* See above */\n-  struct partial_symtab *pst;\t/* Partial symtab that has the\n+  legacy_psymtab *pst;\t/* Partial symtab that has the\n \t\t\t\t   BINCL/EINCL defs for this file.  */\n };\n \n@@ -263,16 +263,16 @@ static std::vector<struct header_file_location> *bincl_list;\n \n /* Local function prototypes.  */\n \n-static void read_ofile_symtab (struct objfile *, struct partial_symtab *);\n+static void read_ofile_symtab (struct objfile *, legacy_psymtab *);\n \n-static void dbx_read_symtab (struct partial_symtab *self,\n+static void dbx_read_symtab (legacy_psymtab *self,\n \t\t\t     struct objfile *objfile);\n \n-static void dbx_psymtab_to_symtab_1 (struct objfile *, struct partial_symtab *);\n+static void dbx_psymtab_to_symtab_1 (struct objfile *, legacy_psymtab *);\n \n static void read_dbx_symtab (minimal_symbol_reader &, struct objfile *);\n \n-static struct partial_symtab *find_corresponding_bincl_psymtab (const char *,\n+static legacy_psymtab *find_corresponding_bincl_psymtab (const char *,\n \t\t\t\t\t\t\t\tint);\n \n static const char *dbx_next_symbol_text (struct objfile *);\n@@ -297,7 +297,7 @@ static void add_old_header_file (const char *, int);\n \n static void add_this_object_header_file (int);\n \n-static struct partial_symtab *start_psymtab (struct objfile *, const char *,\n+static legacy_psymtab *start_psymtab (struct objfile *, const char *,\n \t\t\t\t\t     CORE_ADDR, int);\n \n /* Free up old header file tables.  */\n@@ -857,7 +857,7 @@ dbx_next_symbol_text (struct objfile *objfile)\n    bincl in the list.  Return the partial symtab associated\n    with that header_file_location.  */\n \n-static struct partial_symtab *\n+static legacy_psymtab *\n find_corresponding_bincl_psymtab (const char *name, int instance)\n {\n   for (const header_file_location &bincl : *bincl_list)\n@@ -866,7 +866,7 @@ find_corresponding_bincl_psymtab (const char *name, int instance)\n       return bincl.pst;\n \n   repeated_header_complaint (name, symnum);\n-  return (struct partial_symtab *) 0;\n+  return (legacy_psymtab *) 0;\n }\n \n /* Set namestring based on nlist.  If the string table index is invalid, \n@@ -968,15 +968,15 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n   int data_sect_index;\n \n   /* Current partial symtab.  */\n-  struct partial_symtab *pst;\n+  legacy_psymtab *pst;\n \n   /* List of current psymtab's include files.  */\n   const char **psymtab_include_list;\n   int includes_allocated;\n   int includes_used;\n \n   /* Index within current psymtab dependency list.  */\n-  struct partial_symtab **dependency_list;\n+  legacy_psymtab **dependency_list;\n   int dependencies_used, dependencies_allocated;\n \n   text_addr = DBX_TEXT_ADDR (objfile);\n@@ -989,7 +989,7 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n \n   stringtab_global = DBX_STRINGTAB (objfile);\n \n-  pst = (struct partial_symtab *) 0;\n+  pst = (legacy_psymtab *) 0;\n \n   includes_allocated = 30;\n   includes_used = 0;\n@@ -999,8 +999,8 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n   dependencies_allocated = 30;\n   dependencies_used = 0;\n   dependency_list =\n-    (struct partial_symtab **) alloca (dependencies_allocated *\n-\t\t\t\t       sizeof (struct partial_symtab *));\n+    (legacy_psymtab **) alloca (dependencies_allocated *\n+\t\t\t\tsizeof (legacy_psymtab *));\n \n   /* Init bincl list */\n   std::vector<struct header_file_location> bincl_storage;\n@@ -1136,7 +1136,7 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n \t\t\t\t   ? nlist.n_value : pst->raw_text_high (),\n \t\t\t\t   dependency_list, dependencies_used,\n \t\t\t\t   textlow_not_set);\n-\t\t  pst = (struct partial_symtab *) 0;\n+\t\t  pst = (legacy_psymtab *) 0;\n \t\t  includes_used = 0;\n \t\t  dependencies_used = 0;\n \t\t  has_line_numbers = 0;\n@@ -1251,7 +1251,7 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n \t\t\t\t      ? valu : pst->raw_text_high ()),\n \t\t\t\t     dependency_list, dependencies_used,\n \t\t\t\t     prev_textlow_not_set);\n-\t\t    pst = (struct partial_symtab *) 0;\n+\t\t    pst = (legacy_psymtab *) 0;\n \t\t    includes_used = 0;\n \t\t    dependencies_used = 0;\n \t\t    has_line_numbers = 0;\n@@ -1762,7 +1762,7 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n \t  /* Find the corresponding bincl and mark that psymtab on the\n \t     psymtab dependency list.  */\n \t  {\n-\t    struct partial_symtab *needed_pst =\n+\t    legacy_psymtab *needed_pst =\n \t      find_corresponding_bincl_psymtab (namestring, nlist.n_value);\n \n \t    /* If this include file was defined earlier in this file,\n@@ -1789,15 +1789,15 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n \t\tdependency_list[dependencies_used++] = needed_pst;\n \t\tif (dependencies_used >= dependencies_allocated)\n \t\t  {\n-\t\t    struct partial_symtab **orig = dependency_list;\n+\t\t    legacy_psymtab **orig = dependency_list;\n \n \t\t    dependency_list =\n-\t\t      (struct partial_symtab **)\n+\t\t      (legacy_psymtab **)\n \t\t      alloca ((dependencies_allocated *= 2)\n-\t\t\t      * sizeof (struct partial_symtab *));\n+\t\t\t      * sizeof (legacy_psymtab *));\n \t\t    memcpy (dependency_list, orig,\n \t\t\t    (dependencies_used\n-\t\t\t     * sizeof (struct partial_symtab *)));\n+\t\t\t     * sizeof (legacy_psymtab *)));\n #ifdef DEBUG_INFO\n \t\t    fprintf_unfiltered (gdb_stderr,\n \t\t\t\t\t\"Had to reallocate \"\n@@ -1823,7 +1823,7 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n \t\t\t       symnum * symbol_size,\n \t\t\t       (CORE_ADDR) 0, dependency_list,\n \t\t\t       dependencies_used, textlow_not_set);\n-\t      pst = (struct partial_symtab *) 0;\n+\t      pst = (legacy_psymtab *) 0;\n \t      includes_used = 0;\n \t      dependencies_used = 0;\n \t      has_line_numbers = 0;\n@@ -1899,17 +1899,16 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n    is the address relative to which its symbols are (incremental) or 0\n    (normal).  */\n \n-static struct partial_symtab *\n+static legacy_psymtab *\n start_psymtab (struct objfile *objfile, const char *filename, CORE_ADDR textlow,\n \t       int ldsymoff)\n {\n-  struct partial_symtab *result = new partial_symtab (filename, objfile,\n-\t\t\t\t\t\t      textlow);\n+  legacy_psymtab *result = new legacy_psymtab (filename, objfile, textlow);\n \n   result->read_symtab_private =\n     XOBNEW (&objfile->objfile_obstack, struct symloc);\n   LDSYMOFF (result) = ldsymoff;\n-  result->read_symtab = dbx_read_symtab;\n+  result->legacy_read_symtab = dbx_read_symtab;\n   SYMBOL_SIZE (result) = symbol_size;\n   SYMBOL_OFFSET (result) = symbol_table_offset;\n   STRING_OFFSET (result) = string_table_offset;\n@@ -1927,11 +1926,11 @@ start_psymtab (struct objfile *objfile, const char *filename, CORE_ADDR textlow,\n \n    FIXME:  List variables and peculiarities of same.  */\n \n-struct partial_symtab *\n-dbx_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,\n+legacy_psymtab *\n+dbx_end_psymtab (struct objfile *objfile, legacy_psymtab *pst,\n \t\t const char **include_list, int num_includes,\n \t\t int capping_symbol_offset, CORE_ADDR capping_text,\n-\t\t struct partial_symtab **dependency_list,\n+\t\t legacy_psymtab **dependency_list,\n \t\t int number_dependencies,\n \t\t int textlow_not_set)\n {\n@@ -2017,15 +2016,15 @@ dbx_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,\n       pst->dependencies\n \t= objfile->partial_symtabs->allocate_dependencies (number_dependencies);\n       memcpy (pst->dependencies, dependency_list,\n-\t      number_dependencies * sizeof (struct partial_symtab *));\n+\t      number_dependencies * sizeof (legacy_psymtab *));\n     }\n   else\n     pst->dependencies = 0;\n \n   for (i = 0; i < num_includes; i++)\n     {\n-      struct partial_symtab *subpst =\n-\tnew partial_symtab (include_list[i], objfile);\n+      legacy_psymtab *subpst =\n+\tnew legacy_psymtab (include_list[i], objfile);\n \n       subpst->read_symtab_private =\n \tXOBNEW (&objfile->objfile_obstack, struct symloc);\n@@ -2039,7 +2038,7 @@ dbx_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,\n       subpst->dependencies[0] = pst;\n       subpst->number_of_dependencies = 1;\n \n-      subpst->read_symtab = pst->read_symtab;\n+      subpst->legacy_read_symtab = pst->legacy_read_symtab;\n     }\n \n   if (num_includes == 0\n@@ -2065,7 +2064,7 @@ dbx_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,\n }\n \f\n static void\n-dbx_psymtab_to_symtab_1 (struct objfile *objfile, struct partial_symtab *pst)\n+dbx_psymtab_to_symtab_1 (struct objfile *objfile, legacy_psymtab *pst)\n {\n   int i;\n \n@@ -2092,7 +2091,8 @@ dbx_psymtab_to_symtab_1 (struct objfile *objfile, struct partial_symtab *pst)\n \t    wrap_here (\"\");\t/* Flush output.  */\n \t    gdb_flush (gdb_stdout);\n \t  }\n-\tdbx_psymtab_to_symtab_1 (objfile, pst->dependencies[i]);\n+\tdbx_psymtab_to_symtab_1 (objfile,\n+\t\t\t\t (legacy_psymtab *) pst->dependencies[i]);\n       }\n \n   if (LDSYMLEN (pst))\t\t/* Otherwise it's a dummy.  */\n@@ -2115,7 +2115,7 @@ dbx_psymtab_to_symtab_1 (struct objfile *objfile, struct partial_symtab *pst)\n    Be verbose about it if the user wants that.  SELF is not NULL.  */\n \n static void\n-dbx_read_symtab (struct partial_symtab *self, struct objfile *objfile)\n+dbx_read_symtab (legacy_psymtab *self, struct objfile *objfile)\n {\n   if (self->readin)\n     {\n@@ -2165,7 +2165,7 @@ dbx_read_symtab (struct partial_symtab *self, struct objfile *objfile)\n /* Read in a defined section of a specific object file's symbols.  */\n \n static void\n-read_ofile_symtab (struct objfile *objfile, struct partial_symtab *pst)\n+read_ofile_symtab (struct objfile *objfile, legacy_psymtab *pst)\n {\n   const char *namestring;\n   struct external_nlist *bufp;"
    },
    {
      "sha": "9aaf6af785a3474a76c6f921ee5b139c7d2117db",
      "filename": "gdb/dwarf-index-write.c",
      "status": "modified",
      "additions": 15,
      "deletions": 14,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/dwarf-index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/dwarf-index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf-index-write.c?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -399,7 +399,7 @@ write_hash_table (mapped_symtab *symtab, data_buf &output, data_buf &cpool)\n     }\n }\n \n-typedef std::unordered_map<partial_symtab *, unsigned int> psym_index_map;\n+typedef std::unordered_map<dwarf2_psymtab *, unsigned int> psym_index_map;\n \n /* Helper struct for building the address table.  */\n struct addrmap_index_data\n@@ -439,7 +439,7 @@ static int\n add_address_entry_worker (void *datap, CORE_ADDR start_addr, void *obj)\n {\n   struct addrmap_index_data *data = (struct addrmap_index_data *) datap;\n-  struct partial_symtab *pst = (struct partial_symtab *) obj;\n+  dwarf2_psymtab *pst = (dwarf2_psymtab *) obj;\n \n   if (data->previous_valid)\n     add_address_entry (data->objfile, data->addr_vec,\n@@ -582,7 +582,7 @@ write_one_signatured_type (void **slot, void *d)\n   struct signatured_type_index_data *info\n     = (struct signatured_type_index_data *) d;\n   struct signatured_type *entry = (struct signatured_type *) *slot;\n-  struct partial_symtab *psymtab = entry->per_cu.v.psymtab;\n+  dwarf2_psymtab *psymtab = entry->per_cu.v.psymtab;\n \n   write_psymbols (info->symtab,\n \t\t  info->psyms_seen,\n@@ -612,12 +612,12 @@ write_one_signatured_type (void **slot, void *d)\n    if they appeared in this psymtab.  */\n \n static void\n-recursively_count_psymbols (struct partial_symtab *psymtab,\n+recursively_count_psymbols (dwarf2_psymtab *psymtab,\n \t\t\t    size_t &psyms_seen)\n {\n   for (int i = 0; i < psymtab->number_of_dependencies; ++i)\n     if (psymtab->dependencies[i]->user != NULL)\n-      recursively_count_psymbols (psymtab->dependencies[i],\n+      recursively_count_psymbols ((dwarf2_psymtab *) psymtab->dependencies[i],\n \t\t\t\t  psyms_seen);\n \n   psyms_seen += psymtab->n_global_syms;\n@@ -629,7 +629,7 @@ recursively_count_psymbols (struct partial_symtab *psymtab,\n \n static void\n recursively_write_psymbols (struct objfile *objfile,\n-\t\t\t    struct partial_symtab *psymtab,\n+\t\t\t    dwarf2_psymtab *psymtab,\n \t\t\t    struct mapped_symtab *symtab,\n \t\t\t    std::unordered_set<partial_symbol *> &psyms_seen,\n \t\t\t    offset_type cu_index)\n@@ -638,7 +638,8 @@ recursively_write_psymbols (struct objfile *objfile,\n \n   for (i = 0; i < psymtab->number_of_dependencies; ++i)\n     if (psymtab->dependencies[i]->user != NULL)\n-      recursively_write_psymbols (objfile, psymtab->dependencies[i],\n+      recursively_write_psymbols (objfile,\n+\t\t\t\t  (dwarf2_psymtab *) psymtab->dependencies[i],\n \t\t\t\t  symtab, psyms_seen, cu_index);\n \n   write_psymbols (symtab,\n@@ -868,14 +869,14 @@ class debug_names\n      as if they appeared in this psymtab.  */\n   void recursively_write_psymbols\n     (struct objfile *objfile,\n-     struct partial_symtab *psymtab,\n+     dwarf2_psymtab *psymtab,\n      std::unordered_set<partial_symbol *> &psyms_seen,\n      int cu_index)\n   {\n     for (int i = 0; i < psymtab->number_of_dependencies; ++i)\n       if (psymtab->dependencies[i]->user != NULL)\n-\trecursively_write_psymbols (objfile, psymtab->dependencies[i],\n-\t\t\t\t    psyms_seen, cu_index);\n+\trecursively_write_psymbols\n+\t  (objfile, (dwarf2_psymtab *) psymtab->dependencies[i], psyms_seen, cu_index);\n \n     write_psymbols (psyms_seen,\n \t\t    (objfile->partial_symtabs->global_psymbols.data ()\n@@ -1234,7 +1235,7 @@ class debug_names\n   write_one_signatured_type (struct signatured_type *entry,\n \t\t\t     struct signatured_type_index_data *info)\n   {\n-    struct partial_symtab *psymtab = entry->per_cu.v.psymtab;\n+    dwarf2_psymtab *psymtab = entry->per_cu.v.psymtab;\n \n     write_psymbols (info->psyms_seen,\n \t\t    (info->objfile->partial_symtabs->global_psymbols.data ()\n@@ -1320,7 +1321,7 @@ psyms_seen_size (struct dwarf2_per_objfile *dwarf2_per_objfile)\n   size_t psyms_count = 0;\n   for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n     {\n-      struct partial_symtab *psymtab = per_cu->v.psymtab;\n+      dwarf2_psymtab *psymtab = per_cu->v.psymtab;\n \n       if (psymtab != NULL && psymtab->user == NULL)\n \trecursively_count_psymbols (psymtab, psyms_count);\n@@ -1423,7 +1424,7 @@ write_gdbindex (struct dwarf2_per_objfile *dwarf2_per_objfile, FILE *out_file,\n     {\n       struct dwarf2_per_cu_data *per_cu\n \t= dwarf2_per_objfile->all_comp_units[i];\n-      struct partial_symtab *psymtab = per_cu->v.psymtab;\n+      dwarf2_psymtab *psymtab = per_cu->v.psymtab;\n \n       /* CU of a shared file from 'dwz -m' may be unused by this main file.\n \t It may be referenced from a local scope but in such case it does not\n@@ -1508,7 +1509,7 @@ write_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   for (int i = 0; i < dwarf2_per_objfile->all_comp_units.size (); ++i)\n     {\n       const dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->all_comp_units[i];\n-      partial_symtab *psymtab = per_cu->v.psymtab;\n+      dwarf2_psymtab *psymtab = per_cu->v.psymtab;\n \n       /* CU of a shared file from 'dwz -m' may be unused by this main\n \t file.  It may be referenced from a local scope but in such"
    },
    {
      "sha": "8bde26534e300c52c8f5ccd97b7f5667b49c9ffa",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 33,
      "deletions": 40,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -1480,7 +1480,7 @@ static const char *get_section_file_name (const struct dwarf2_section_info *);\n static void dwarf2_find_base_address (struct die_info *die,\n \t\t\t\t      struct dwarf2_cu *cu);\n \n-static struct partial_symtab *create_partial_symtab\n+static dwarf2_psymtab *create_partial_symtab\n   (struct dwarf2_per_cu_data *per_cu, const char *name);\n \n static void build_type_psymtabs_reader (const struct die_reader_specs *reader,\n@@ -1513,10 +1513,7 @@ static void add_partial_subprogram (struct partial_die_info *pdi,\n \t\t\t\t    CORE_ADDR *lowpc, CORE_ADDR *highpc,\n \t\t\t\t    int need_pc, struct dwarf2_cu *cu);\n \n-static void dwarf2_read_symtab (struct partial_symtab *,\n-\t\t\t\tstruct objfile *);\n-\n-static void psymtab_to_symtab_1 (struct partial_symtab *);\n+static void psymtab_to_symtab_1 (dwarf2_psymtab *);\n \n static abbrev_table_up abbrev_table_read_table\n   (struct dwarf2_per_objfile *dwarf2_per_objfile, struct dwarf2_section_info *,\n@@ -1644,7 +1641,7 @@ static line_header_up dwarf_decode_line_header (sect_offset sect_off,\n \t\t\t\t\t\tstruct dwarf2_cu *cu);\n \n static void dwarf_decode_lines (struct line_header *, const char *,\n-\t\t\t\tstruct dwarf2_cu *, struct partial_symtab *,\n+\t\t\t\tstruct dwarf2_cu *, dwarf2_psymtab *,\n \t\t\t\tCORE_ADDR, int decode_mapping);\n \n static void dwarf2_start_subfile (struct dwarf2_cu *, const char *,\n@@ -1703,7 +1700,7 @@ static void read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu);\n static void read_variable (struct die_info *die, struct dwarf2_cu *cu);\n \n static int dwarf2_ranges_read (unsigned, CORE_ADDR *, CORE_ADDR *,\n-\t\t\t       struct dwarf2_cu *, struct partial_symtab *);\n+\t\t\t       struct dwarf2_cu *, dwarf2_psymtab *);\n \n /* How dwarf2_get_pc_bounds constructed its *LOWPC and *HIGHPC return\n    values.  Keep the items ordered with increasing constraints compliance.  */\n@@ -1726,7 +1723,7 @@ enum pc_bounds_kind\n static enum pc_bounds_kind dwarf2_get_pc_bounds (struct die_info *,\n \t\t\t\t\t\t CORE_ADDR *, CORE_ADDR *,\n \t\t\t\t\t\t struct dwarf2_cu *,\n-\t\t\t\t\t\t struct partial_symtab *);\n+\t\t\t\t\t\t dwarf2_psymtab *);\n \n static void get_scope_pc_bounds (struct die_info *,\n \t\t\t\t CORE_ADDR *, CORE_ADDR *,\n@@ -6692,10 +6689,10 @@ read_abbrev_offset (struct dwarf2_per_objfile *dwarf2_per_objfile,\n    partial symtab as being an include of PST.  */\n \n static void\n-dwarf2_create_include_psymtab (const char *name, struct partial_symtab *pst,\n+dwarf2_create_include_psymtab (const char *name, dwarf2_psymtab *pst,\n                                struct objfile *objfile)\n {\n-  struct partial_symtab *subpst = new partial_symtab (name, objfile);\n+  dwarf2_psymtab *subpst = new dwarf2_psymtab (name, objfile);\n \n   if (!IS_ABSOLUTE_PATH (subpst->filename))\n     {\n@@ -6707,12 +6704,10 @@ dwarf2_create_include_psymtab (const char *name, struct partial_symtab *pst,\n   subpst->dependencies[0] = pst;\n   subpst->number_of_dependencies = 1;\n \n-  subpst->read_symtab = pst->read_symtab;\n-\n   /* No private part is necessary for include psymtabs.  This property\n      can be used to differentiate between such include psymtabs and\n      the regular ones.  */\n-  subpst->read_symtab_private = NULL;\n+  subpst->per_cu_data = nullptr;\n }\n \n /* Read the Line Number Program data and extract the list of files\n@@ -6722,7 +6717,7 @@ dwarf2_create_include_psymtab (const char *name, struct partial_symtab *pst,\n static void\n dwarf2_build_include_psymtabs (struct dwarf2_cu *cu,\n \t\t\t       struct die_info *die,\n-\t\t\t       struct partial_symtab *pst)\n+\t\t\t       dwarf2_psymtab *pst)\n {\n   line_header_up lh;\n   struct attribute *attr;\n@@ -7934,7 +7929,7 @@ create_type_unit_group (struct dwarf2_cu *cu, sect_offset line_offset_struct)\n   else\n     {\n       unsigned int line_offset = to_underlying (line_offset_struct);\n-      struct partial_symtab *pst;\n+      dwarf2_psymtab *pst;\n       std::string name;\n \n       /* Give the symtab a useful name for debug purposes.  */\n@@ -8021,19 +8016,18 @@ get_type_unit_group (struct dwarf2_cu *cu, const struct attribute *stmt_list)\n    The caller must fill in the following details:\n    dirname, textlow, texthigh.  */\n \n-static struct partial_symtab *\n+static dwarf2_psymtab *\n create_partial_symtab (struct dwarf2_per_cu_data *per_cu, const char *name)\n {\n   struct objfile *objfile = per_cu->dwarf2_per_objfile->objfile;\n-  struct partial_symtab *pst;\n+  dwarf2_psymtab *pst;\n \n-  pst = new partial_symtab (name, objfile, 0);\n+  pst = new dwarf2_psymtab (name, objfile, 0);\n \n   pst->psymtabs_addrmap_supported = true;\n \n   /* This is the glue that links PST into GDB's symbol API.  */\n-  pst->read_symtab_private = per_cu;\n-  pst->read_symtab = dwarf2_read_symtab;\n+  pst->per_cu_data = per_cu;\n   per_cu->v.psymtab = pst;\n \n   return pst;\n@@ -8055,7 +8049,7 @@ process_psymtab_comp_unit_reader (const struct die_reader_specs *reader,\n   struct dwarf2_per_cu_data *per_cu = cu->per_cu;\n   CORE_ADDR baseaddr;\n   CORE_ADDR best_lowpc = 0, best_highpc = 0;\n-  struct partial_symtab *pst;\n+  dwarf2_psymtab *pst;\n   enum pc_bounds_kind cu_bounds_kind;\n   const char *filename;\n \n@@ -8224,7 +8218,7 @@ build_type_psymtabs_reader (const struct die_reader_specs *reader,\n   struct attribute *attr;\n   struct partial_die_info *first_die;\n   CORE_ADDR lowpc, highpc;\n-  struct partial_symtab *pst;\n+  dwarf2_psymtab *pst;\n \n   gdb_assert (per_cu->is_debug_types);\n   sig_type = (struct signatured_type *) per_cu;\n@@ -8397,7 +8391,7 @@ build_type_psymtab_dependencies (void **slot, void *info)\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct type_unit_group *tu_group = (struct type_unit_group *) *slot;\n   struct dwarf2_per_cu_data *per_cu = &tu_group->per_cu;\n-  struct partial_symtab *pst = per_cu->v.psymtab;\n+  dwarf2_psymtab *pst = per_cu->v.psymtab;\n   int len = (tu_group->tus == nullptr) ? 0 : tu_group->tus->size ();\n   int i;\n \n@@ -8514,7 +8508,7 @@ set_partial_user (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n   for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n     {\n-      struct partial_symtab *pst = per_cu->v.psymtab;\n+      dwarf2_psymtab *pst = per_cu->v.psymtab;\n \n       if (pst == NULL)\n \tcontinue;\n@@ -9494,24 +9488,23 @@ locate_pdi_sibling (const struct die_reader_specs *reader,\n /* Expand this partial symbol table into a full symbol table.  SELF is\n    not NULL.  */\n \n-static void\n-dwarf2_read_symtab (struct partial_symtab *self,\n-\t\t    struct objfile *objfile)\n+void\n+dwarf2_psymtab::read_symtab (struct objfile *objfile)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n \n-  if (self->readin)\n+  if (readin)\n     {\n       warning (_(\"bug: psymtab for %s is already read in.\"),\n-\t       self->filename);\n+\t       filename);\n     }\n   else\n     {\n       if (info_verbose)\n \t{\n \t  printf_filtered (_(\"Reading in symbols for %s...\"),\n-\t\t\t   self->filename);\n+\t\t\t   filename);\n \t  gdb_flush (gdb_stdout);\n \t}\n \n@@ -9530,7 +9523,7 @@ dwarf2_read_symtab (struct partial_symtab *self,\n \n       dwarf2_per_objfile->reading_partial_symbols = 0;\n \n-      psymtab_to_symtab_1 (self);\n+      psymtab_to_symtab_1 (this);\n \n       /* Finish up the debug error message.  */\n       if (info_verbose)\n@@ -9687,7 +9680,7 @@ process_queue (struct dwarf2_per_objfile *dwarf2_per_objfile)\n /* Read in full symbols for PST, and anything it depends on.  */\n \n static void\n-psymtab_to_symtab_1 (struct partial_symtab *pst)\n+psymtab_to_symtab_1 (dwarf2_psymtab *pst)\n {\n   struct dwarf2_per_cu_data *per_cu;\n   int i;\n@@ -9711,10 +9704,10 @@ psymtab_to_symtab_1 (struct partial_symtab *pst)\n             wrap_here (\"\");     /* Flush output.  */\n             gdb_flush (gdb_stdout);\n           }\n-        psymtab_to_symtab_1 (pst->dependencies[i]);\n+        psymtab_to_symtab_1 ((dwarf2_psymtab *) pst->dependencies[i]);\n       }\n \n-  per_cu = (struct dwarf2_per_cu_data *) pst->read_symtab_private;\n+  per_cu = pst->per_cu_data;\n \n   if (per_cu == NULL)\n     {\n@@ -10477,7 +10470,7 @@ process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,\n     per_cu->v.quick->compunit_symtab = cust;\n   else\n     {\n-      struct partial_symtab *pst = per_cu->v.psymtab;\n+      dwarf2_psymtab *pst = per_cu->v.psymtab;\n       pst->compunit_symtab = cust;\n       pst->readin = true;\n     }\n@@ -10557,7 +10550,7 @@ process_full_type_unit (struct dwarf2_per_cu_data *per_cu,\n     per_cu->v.quick->compunit_symtab = cust;\n   else\n     {\n-      struct partial_symtab *pst = per_cu->v.psymtab;\n+      dwarf2_psymtab *pst = per_cu->v.psymtab;\n       pst->compunit_symtab = cust;\n       pst->readin = true;\n     }\n@@ -14596,7 +14589,7 @@ dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu,\n static int\n dwarf2_ranges_read (unsigned offset, CORE_ADDR *low_return,\n \t\t    CORE_ADDR *high_return, struct dwarf2_cu *cu,\n-\t\t    struct partial_symtab *ranges_pst)\n+\t\t    dwarf2_psymtab *ranges_pst)\n {\n   struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n@@ -14664,7 +14657,7 @@ dwarf2_ranges_read (unsigned offset, CORE_ADDR *low_return,\n static enum pc_bounds_kind\n dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n \t\t      CORE_ADDR *highpc, struct dwarf2_cu *cu,\n-\t\t      struct partial_symtab *pst)\n+\t\t      dwarf2_psymtab *pst)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = cu->per_cu->dwarf2_per_objfile;\n@@ -20944,7 +20937,7 @@ dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n \n static const char *\n psymtab_include_file_name (const struct line_header *lh, const file_entry &fe,\n-\t\t\t   const struct partial_symtab *pst,\n+\t\t\t   const dwarf2_psymtab *pst,\n \t\t\t   const char *comp_dir,\n \t\t\t   gdb::unique_xmalloc_ptr<char> *name_holder)\n {\n@@ -21645,7 +21638,7 @@ dwarf_decode_lines_1 (struct line_header *lh, struct dwarf2_cu *cu,\n \n static void\n dwarf_decode_lines (struct line_header *lh, const char *comp_dir,\n-\t\t    struct dwarf2_cu *cu, struct partial_symtab *pst,\n+\t\t    struct dwarf2_cu *cu, dwarf2_psymtab *pst,\n \t\t    CORE_ADDR lowpc, int decode_mapping)\n {\n   struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;"
    },
    {
      "sha": "06bd908a445c302640fdb72a5937e77a27f0695f",
      "filename": "gdb/dwarf2read.h",
      "status": "modified",
      "additions": 22,
      "deletions": 2,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/dwarf2read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/dwarf2read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.h?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -25,6 +25,7 @@\n #include \"filename-seen-cache.h\"\n #include \"gdb_obstack.h\"\n #include \"gdbsupport/hash_enum.h\"\n+#include \"psympriv.h\"\n \n /* Hold 'maintenance (set|show) dwarf' commands.  */\n extern struct cmd_list_element *set_dwarf_cmdlist;\n@@ -269,9 +270,28 @@ struct dwarf2_per_objfile\n \n dwarf2_per_objfile *get_dwarf2_per_objfile (struct objfile *objfile);\n \n+/* A partial symtab specialized for DWARF.  */\n+struct dwarf2_psymtab : public partial_symtab\n+{\n+  dwarf2_psymtab (const char *filename, struct objfile *objfile)\n+    : partial_symtab (filename, objfile)\n+  {\n+  }\n+\n+  dwarf2_psymtab (const char *filename, struct objfile *objfile,\n+\t\t  CORE_ADDR addr)\n+    : partial_symtab (filename, objfile, addr)\n+  {\n+  }\n+\n+  void read_symtab (struct objfile *) override;\n+\n+  struct dwarf2_per_cu_data *per_cu_data;\n+};\n+\n /* Persistent data held for a compilation unit, even when not\n    processing it.  We put a pointer to this structure in the\n-   read_symtab_private field of the psymtab.  */\n+   psymtab.  */\n \n struct dwarf2_per_cu_data\n {\n@@ -339,7 +359,7 @@ struct dwarf2_per_cu_data\n   {\n     /* The partial symbol table associated with this compilation unit,\n        or NULL for unread partial units.  */\n-    struct partial_symtab *psymtab;\n+    dwarf2_psymtab *psymtab;\n \n     /* Data needed by the \"quick\" functions.  */\n     struct dwarf2_per_cu_quick_data *quick;"
    },
    {
      "sha": "621b314ff99404b80c4387678a09327060c3a20b",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -251,10 +251,10 @@ static struct symbol *mylookup_symbol (const char *, const struct block *,\n \n static void sort_blocks (struct symtab *);\n \n-static struct partial_symtab *new_psymtab (const char *, struct objfile *);\n+static legacy_psymtab *new_psymtab (const char *, struct objfile *);\n \n static void psymtab_to_symtab_1 (struct objfile *objfile,\n-\t\t\t\t struct partial_symtab *, const char *);\n+\t\t\t\t legacy_psymtab *, const char *);\n \n static void add_block (struct block *, struct symtab *);\n \n@@ -275,7 +275,7 @@ static const char *mdebug_next_symbol_text (struct objfile *);\n    and reorders the symtab list at the end.  SELF is not NULL.  */\n \n static void\n-mdebug_read_symtab (struct partial_symtab *self, struct objfile *objfile)\n+mdebug_read_symtab (legacy_psymtab *self, struct objfile *objfile)\n {\n   if (info_verbose)\n     {\n@@ -389,7 +389,7 @@ mdebug_build_psymtabs (minimal_symbol_reader &reader,\n \n struct pst_map\n {\n-  struct partial_symtab *pst;\t/* the psymtab proper */\n+  legacy_psymtab *pst;\t/* the psymtab proper */\n   long n_globals;\t\t/* exported globals (external symbols) */\n   long globals_offset;\t\t/* cumulative */\n };\n@@ -1910,7 +1910,7 @@ upgrade_type (int fd, struct type **tpp, int tq, union aux_ext *ax, int bigend,\n \n static void\n parse_procedure (PDR *pr, struct compunit_symtab *search_symtab,\n-\t\t struct partial_symtab *pst)\n+\t\t legacy_psymtab *pst)\n {\n   struct symbol *s, *i;\n   const struct block *b;\n@@ -2310,7 +2310,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n   EXTR *ext_in;\n   EXTR *ext_in_end;\n   SYMR sh;\n-  struct partial_symtab *pst;\n+  legacy_psymtab *pst;\n   int textlow_not_set = 1;\n \n   /* List of current psymtab's include files.  */\n@@ -2320,7 +2320,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n   EXTR *extern_tab;\n   struct pst_map *fdr_to_pst;\n   /* Index within current psymtab dependency list.  */\n-  struct partial_symtab **dependency_list;\n+  legacy_psymtab **dependency_list;\n   int dependencies_used, dependencies_allocated;\n   char *name;\n   enum language prev_language;\n@@ -2349,8 +2349,8 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n   dependencies_allocated = 30;\n   dependencies_used = 0;\n   dependency_list =\n-    (struct partial_symtab **) alloca (dependencies_allocated *\n-\t\t\t\t       sizeof (struct partial_symtab *));\n+    (legacy_psymtab **) alloca (dependencies_allocated *\n+\t\t\t\tsizeof (legacy_psymtab *));\n \n   set_last_source_file (NULL);\n \n@@ -2373,7 +2373,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n   fdr_to_pst = fdr_to_pst_holder.data ();\n   fdr_to_pst++;\n   {\n-    struct partial_symtab *new_pst = new_psymtab (\"\", objfile);\n+    legacy_psymtab *new_pst = new_psymtab (\"\", objfile);\n \n     fdr_to_pst[-1].pst = new_pst;\n     FDR_IDX (new_pst) = -1;\n@@ -2591,7 +2591,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n   /* Pass 3 over files, over local syms: fill in static symbols.  */\n   for (f_idx = 0; f_idx < hdr->ifdMax; f_idx++)\n     {\n-      struct partial_symtab *save_pst;\n+      legacy_psymtab *save_pst;\n       EXTR *ext_ptr;\n       CORE_ADDR textlow;\n \n@@ -2609,7 +2609,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n \ttextlow = fh->adr;\n       else\n \ttextlow = 0;\n-      pst = new partial_symtab (fdr_name (fh), objfile, textlow);\n+      pst = new legacy_psymtab (fdr_name (fh), objfile, textlow);\n       pst->read_symtab_private = XOBNEW (&objfile->objfile_obstack, symloc);\n       memset (pst->read_symtab_private, 0, sizeof (struct symloc));\n \n@@ -2621,7 +2621,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n       PENDING_LIST (pst) = pending_list;\n \n       /* The way to turn this into a symtab is to call...  */\n-      pst->read_symtab = mdebug_read_symtab;\n+      pst->legacy_read_symtab = mdebug_read_symtab;\n \n       /* Set up language for the pst.\n          The language from the FDR is used if it is unambigious (e.g. cfront\n@@ -2895,7 +2895,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n \t\t\t{\t\t/* Here if prev stab wasn't N_SO.  */\n \t\t\t  if (pst)\n \t\t\t    {\n-\t\t\t      pst = (struct partial_symtab *) 0;\n+\t\t\t      pst = (legacy_psymtab *) 0;\n \t\t\t      includes_used = 0;\n \t\t\t      dependencies_used = 0;\n \t\t\t    }\n@@ -3285,7 +3285,7 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n \t\t    if (pst\n \t\t\t&& gdbarch_sofun_address_maybe_missing (gdbarch))\n \t\t      {\n-\t\t\tpst = (struct partial_symtab *) 0;\n+\t\t\tpst = (legacy_psymtab *) 0;\n \t\t\tincludes_used = 0;\n \t\t\tdependencies_used = 0;\n \t\t      }\n@@ -3740,12 +3740,12 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n \n   /* Remove the dummy psymtab created for -O3 images above, if it is\n      still empty, to enable the detection of stripped executables.  */\n-  pst = objfile->partial_symtabs->psymtabs;\n-  if (pst->next == NULL\n-      && pst->number_of_dependencies == 0\n-      && pst->n_global_syms == 0\n-      && pst->n_static_syms == 0)\n-    objfile->partial_symtabs->discard_psymtab (pst);\n+  partial_symtab *pst_del = objfile->partial_symtabs->psymtabs;\n+  if (pst_del->next == NULL\n+      && pst_del->number_of_dependencies == 0\n+      && pst_del->n_global_syms == 0\n+      && pst_del->n_static_syms == 0)\n+    objfile->partial_symtabs->discard_psymtab (pst_del);\n }\n \n /* If the current psymbol has an enumerated type, we need to add\n@@ -3844,7 +3844,7 @@ mdebug_next_symbol_text (struct objfile *objfile)\n \n static void\n psymtab_to_symtab_1 (struct objfile *objfile,\n-\t\t     struct partial_symtab *pst, const char *filename)\n+\t\t     legacy_psymtab *pst, const char *filename)\n {\n   bfd_size_type external_sym_size;\n   bfd_size_type external_pdr_size;\n@@ -3882,7 +3882,7 @@ psymtab_to_symtab_1 (struct objfile *objfile,\n \t    gdb_flush (gdb_stdout);\n \t  }\n \t/* We only pass the filename for debug purposes.  */\n-\tpsymtab_to_symtab_1 (objfile, pst->dependencies[i],\n+\tpsymtab_to_symtab_1 (objfile, (legacy_psymtab *) pst->dependencies[i],\n \t\t\t     pst->dependencies[i]->filename);\n       }\n \n@@ -4655,12 +4655,12 @@ new_symtab (const char *name, int maxlines, struct objfile *objfile)\n \n /* Allocate a new partial_symtab NAME.  */\n \n-static struct partial_symtab *\n+static legacy_psymtab *\n new_psymtab (const char *name, struct objfile *objfile)\n {\n-  struct partial_symtab *psymtab;\n+  legacy_psymtab *psymtab;\n \n-  psymtab = new partial_symtab (name, objfile);\n+  psymtab = new legacy_psymtab (name, objfile);\n \n   /* Keep a backpointer to the file's symbols.  */\n \n@@ -4672,7 +4672,7 @@ new_psymtab (const char *name, struct objfile *objfile)\n   PENDING_LIST (psymtab) = pending_list;\n \n   /* The way to turn this into a symtab is to call...  */\n-  psymtab->read_symtab = mdebug_read_symtab;\n+  psymtab->legacy_read_symtab = mdebug_read_symtab;\n   return (psymtab);\n }\n "
    },
    {
      "sha": "4c189aafc4b21be03b6d498544ed1c4d50928e34",
      "filename": "gdb/psympriv.h",
      "status": "modified",
      "additions": 33,
      "deletions": 1,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/psympriv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/psympriv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psympriv.h?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -121,6 +121,14 @@ struct partial_symtab\n \t\t  CORE_ADDR addr)\n     ATTRIBUTE_NONNULL (2) ATTRIBUTE_NONNULL (3);\n \n+  virtual ~partial_symtab ()\n+  {\n+  }\n+\n+  /* Read the full symbol table corresponding to this partial symbol\n+     table.  */\n+  virtual void read_symtab (struct objfile *) = 0;\n+\n   /* Return the raw low text address of this partial_symtab.  */\n   CORE_ADDR raw_text_low () const\n   {\n@@ -278,11 +286,35 @@ struct partial_symtab\n      !readin or if we haven't looked for the symtab after it was readin.  */\n \n   struct compunit_symtab *compunit_symtab = nullptr;\n+};\n+\n+/* A partial_symtab that works in the historical db way.  This should\n+   not be used in new code, but exists to transition the somewhat\n+   unmaintained \"legacy\" debug formats.  */\n+\n+struct legacy_psymtab : public partial_symtab\n+{\n+  legacy_psymtab (const char *filename, struct objfile *objfile)\n+    : partial_symtab (filename, objfile)\n+  {\n+  }\n+\n+  legacy_psymtab (const char *filename, struct objfile *objfile,\n+\t\t  CORE_ADDR addr)\n+    : partial_symtab (filename, objfile, addr)\n+  {\n+  }\n+\n+  void read_symtab (struct objfile *objf) override\n+  {\n+    if (legacy_read_symtab)\n+      (*legacy_read_symtab) (this, objf);\n+  }\n \n   /* Pointer to function which will read in the symtab corresponding to\n      this psymtab.  */\n \n-  void (*read_symtab) (struct partial_symtab *, struct objfile *) = nullptr;\n+  void (*legacy_read_symtab) (legacy_psymtab *, struct objfile *) = nullptr;\n \n   /* Information that lets read_symtab() locate the part of the symbol table\n      that this psymtab corresponds to.  This information is private to the"
    },
    {
      "sha": "6a2f7f7202a07b2454e606f9fa6087c312f5f53f",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -758,7 +758,7 @@ psymtab_to_symtab (struct objfile *objfile, struct partial_symtab *pst)\n     {\n       scoped_restore decrementer = increment_reading_symtab ();\n \n-      (*pst->read_symtab) (pst, objfile);\n+      pst->read_symtab (objfile);\n     }\n \n   return pst->compunit_symtab;\n@@ -946,8 +946,6 @@ dump_psymtab (struct objfile *objfile, struct partial_symtab *psymtab,\n       fprintf_filtered (outfile,\n \t\t\t\"  Full symtab was read (at \");\n       gdb_print_host_address (psymtab->compunit_symtab, outfile);\n-      fprintf_filtered (outfile, \" by function at \");\n-      gdb_print_host_address (psymtab->read_symtab, outfile);\n       fprintf_filtered (outfile, \")\\n\");\n     }\n "
    },
    {
      "sha": "b3d6ef48116ecf5ec612ffdf892c7f649b915eea",
      "filename": "gdb/stabsread.h",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/stabsread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/stabsread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.h?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -20,6 +20,7 @@\n #define STABSREAD_H\n \n struct objfile;\n+struct legacy_psymtab;\n enum language;\n \n /* Definitions, prototypes, etc for stabs debugging format support\n@@ -170,11 +171,11 @@ extern void finish_global_stabs (struct objfile *objfile);\n /* Functions exported by dbxread.c.  These are not in stabsread.c because\n    they are only used by some stabs readers.  */\n \n-extern struct partial_symtab *dbx_end_psymtab\n-  (struct objfile *objfile, struct partial_symtab *pst,\n+extern legacy_psymtab *dbx_end_psymtab\n+  (struct objfile *objfile, legacy_psymtab *pst,\n    const char **include_list, int num_includes,\n    int capping_symbol_offset, CORE_ADDR capping_text,\n-   struct partial_symtab **dependency_list, int number_dependencies,\n+   legacy_psymtab **dependency_list, int number_dependencies,\n    int textlow_not_set);\n \n extern void process_one_symbol (int, int, CORE_ADDR, const char *,"
    },
    {
      "sha": "69731a47911f60ceece34c916b498c73e89a9078",
      "filename": "gdb/xcoffread.c",
      "status": "modified",
      "additions": 22,
      "deletions": 21,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/xcoffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/891813beaab0029c88c9eeec9c1847d68a4d6050/gdb/xcoffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xcoffread.c?ref=891813beaab0029c88c9eeec9c1847d68a4d6050",
      "patch": "@@ -230,7 +230,7 @@ static CORE_ADDR read_symbol_nvalue (int);\n static struct symbol *process_xcoff_symbol (struct coff_symbol *,\n \t\t\t\t\t    struct objfile *);\n \n-static void read_xcoff_symtab (struct objfile *, struct partial_symtab *);\n+static void read_xcoff_symtab (struct objfile *, legacy_psymtab *);\n \n #if 0\n static void add_stab_to_list (char *, struct pending_stabs **);\n@@ -592,7 +592,7 @@ allocate_include_entry (void)\n \n /* Global variable to pass the psymtab down to all the routines involved\n    in psymtab to symtab processing.  */\n-static struct partial_symtab *this_symtab_psymtab;\n+static legacy_psymtab *this_symtab_psymtab;\n \n /* Objfile related to this_symtab_psymtab; set at the same time.  */\n static struct objfile *this_symtab_objfile;\n@@ -990,7 +990,7 @@ xcoff_next_symbol_text (struct objfile *objfile)\n /* Read symbols for a given partial symbol table.  */\n \n static void\n-read_xcoff_symtab (struct objfile *objfile, struct partial_symtab *pst)\n+read_xcoff_symtab (struct objfile *objfile, legacy_psymtab *pst)\n {\n   bfd *abfd = objfile->obfd;\n   char *raw_auxptr;\t\t/* Pointer to first raw aux entry for sym.  */\n@@ -1817,7 +1817,7 @@ find_linenos (struct bfd *abfd, struct bfd_section *asect, void *vpinfo)\n }\n \f\n static void\n-xcoff_psymtab_to_symtab_1 (struct objfile *objfile, struct partial_symtab *pst)\n+xcoff_psymtab_to_symtab_1 (struct objfile *objfile, legacy_psymtab *pst)\n {\n   int i;\n \n@@ -1847,7 +1847,8 @@ xcoff_psymtab_to_symtab_1 (struct objfile *objfile, struct partial_symtab *pst)\n \t    wrap_here (\"\");\t/* Flush output */\n \t    gdb_flush (gdb_stdout);\n \t  }\n-\txcoff_psymtab_to_symtab_1 (objfile, pst->dependencies[i]);\n+\txcoff_psymtab_to_symtab_1 (objfile,\n+\t\t\t\t   (legacy_psymtab *) pst->dependencies[i]);\n       }\n \n   if (((struct symloc *) pst->read_symtab_private)->numsyms != 0)\n@@ -1866,7 +1867,7 @@ xcoff_psymtab_to_symtab_1 (struct objfile *objfile, struct partial_symtab *pst)\n    Be verbose about it if the user wants that.  SELF is not NULL.  */\n \n static void\n-xcoff_read_symtab (struct partial_symtab *self, struct objfile *objfile)\n+xcoff_read_symtab (legacy_psymtab *self, struct objfile *objfile)\n {\n   if (self->readin)\n     {\n@@ -2003,17 +2004,17 @@ static unsigned int first_fun_line_offset;\n    is the address relative to which its symbols are (incremental) or 0\n    (normal).  */\n \n-static struct partial_symtab *\n+static legacy_psymtab *\n xcoff_start_psymtab (struct objfile *objfile,\n \t\t     const char *filename, int first_symnum)\n {\n   /* We fill in textlow later.  */\n-  struct partial_symtab *result = new partial_symtab (filename, objfile, 0);\n+  legacy_psymtab *result = new legacy_psymtab (filename, objfile, 0);\n \n   result->read_symtab_private =\n     XOBNEW (&objfile->objfile_obstack, struct symloc);\n   ((struct symloc *) result->read_symtab_private)->first_symnum = first_symnum;\n-  result->read_symtab = xcoff_read_symtab;\n+  result->legacy_read_symtab = xcoff_read_symtab;\n \n   /* Deduce the source language from the filename for this psymtab.  */\n   psymtab_language = deduce_language_from_filename (filename);\n@@ -2029,11 +2030,11 @@ xcoff_start_psymtab (struct objfile *objfile,\n    INCLUDE_LIST, NUM_INCLUDES, DEPENDENCY_LIST, and NUMBER_DEPENDENCIES\n    are the information for includes and dependencies.  */\n \n-static struct partial_symtab *\n-xcoff_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,\n+static legacy_psymtab *\n+xcoff_end_psymtab (struct objfile *objfile, legacy_psymtab *pst,\n \t\t   const char **include_list, int num_includes,\n \t\t   int capping_symbol_number,\n-\t\t   struct partial_symtab **dependency_list,\n+\t\t   legacy_psymtab **dependency_list,\n \t\t   int number_dependencies, int textlow_not_set)\n {\n   int i;\n@@ -2054,15 +2055,15 @@ xcoff_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,\n       pst->dependencies\n \t= objfile->partial_symtabs->allocate_dependencies (number_dependencies);\n       memcpy (pst->dependencies, dependency_list,\n-\t      number_dependencies * sizeof (struct partial_symtab *));\n+\t      number_dependencies * sizeof (legacy_psymtab *));\n     }\n   else\n     pst->dependencies = 0;\n \n   for (i = 0; i < num_includes; i++)\n     {\n-      struct partial_symtab *subpst =\n-\tnew partial_symtab (include_list[i], objfile);\n+      legacy_psymtab *subpst =\n+\tnew legacy_psymtab (include_list[i], objfile);\n \n       subpst->read_symtab_private = XOBNEW (&objfile->objfile_obstack, symloc);\n       ((struct symloc *) subpst->read_symtab_private)->first_symnum = 0;\n@@ -2075,7 +2076,7 @@ xcoff_end_psymtab (struct objfile *objfile, struct partial_symtab *pst,\n       subpst->dependencies[0] = pst;\n       subpst->number_of_dependencies = 1;\n \n-      subpst->read_symtab = pst->read_symtab;\n+      subpst->legacy_read_symtab = pst->legacy_read_symtab;\n     }\n \n   if (num_includes == 0\n@@ -2169,15 +2170,15 @@ scan_xcoff_symtab (minimal_symbol_reader &reader,\n   unsigned int nsyms;\n \n   /* Current partial symtab */\n-  struct partial_symtab *pst;\n+  legacy_psymtab *pst;\n \n   /* List of current psymtab's include files.  */\n   const char **psymtab_include_list;\n   int includes_allocated;\n   int includes_used;\n \n   /* Index within current psymtab dependency list.  */\n-  struct partial_symtab **dependency_list;\n+  legacy_psymtab **dependency_list;\n   int dependencies_used, dependencies_allocated;\n \n   char *sraw_symbol;\n@@ -2191,7 +2192,7 @@ scan_xcoff_symtab (minimal_symbol_reader &reader,\n   int misc_func_recorded = 0;\t/* true if any misc. function.  */\n   int textlow_not_set = 1;\n \n-  pst = (struct partial_symtab *) 0;\n+  pst = (legacy_psymtab *) 0;\n \n   includes_allocated = 30;\n   includes_used = 0;\n@@ -2201,8 +2202,8 @@ scan_xcoff_symtab (minimal_symbol_reader &reader,\n   dependencies_allocated = 30;\n   dependencies_used = 0;\n   dependency_list =\n-    (struct partial_symtab **) alloca (dependencies_allocated *\n-\t\t\t\t       sizeof (struct partial_symtab *));\n+    (legacy_psymtab **) alloca (dependencies_allocated *\n+\t\t\t\t       sizeof (legacy_psymtab *));\n \n   set_last_source_file (NULL);\n "
    }
  ]
}