{
  "sha": "596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTk2ZGM0YWRmZmYzNDdiNGQ4ZGMxZjdlNGViNTdiOGYyZjM0MjI4MQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-05-08T20:14:05Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-05-08T20:14:06Z"
    },
    "message": "Speed up psymbol reading by removing a copy\n\nI noticed that cp_canonicalize_string and friends copy a\nunique_xmalloc_ptr to a std::string.  However, this copy isn't\ngenuinely needed anywhere, and it serves to slow down DWARF psymbol\nreading.\n\nThis patch removes the copy and updates the callers to adapt.\n\nThis speeds up the reader from 1.906 seconds (mean of 10 runs, of gdb\non a copy of itself) to 1.888 seconds (mean of 10 runs, on the same\ncopy as the first trial).\n\ngdb/ChangeLog\n2020-05-08  Tom Tromey  <tom@tromey.com>\n\n\t* symtab.h (class demangle_result_storage) <set_malloc_ptr>: New\n\toverload.\n\t<swap_string, m_string>: Remove.\n\t* symtab.c (demangle_for_lookup, completion_list_add_symbol):\n\tUpdate.\n\t* stabsread.c (define_symbol, read_type): Update.\n\t* linespec.c (find_linespec_symbols): Update.\n\t* gnu-v3-abi.c (gnuv3_get_typeid): Update.\n\t* dwarf2/read.c (dwarf2_canonicalize_name): Update.\n\t* dbxread.c (read_dbx_symtab): Update.\n\t* cp-support.h (cp_canonicalize_string_full)\n\t(cp_canonicalize_string, cp_canonicalize_string_no_typedefs):\n\tReturn unique_xmalloc_ptr.\n\t* cp-support.c (inspect_type): Update.\n\t(cp_canonicalize_string_full): Return unique_xmalloc_ptr.\n\t(cp_canonicalize_string_no_typedefs, cp_canonicalize_string):\n\tLikewise.\n\t* c-typeprint.c (print_name_maybe_canonical): Update.\n\t* break-catch-throw.c (check_status_exception_catchpoint):\n\tUpdate.",
    "tree": {
      "sha": "612ad84effaac4a52857ea209f8297f0a1859340",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/612ad84effaac4a52857ea209f8297f0a1859340"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bf4cb9bee210298c813f87aae005432d2e934449",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf4cb9bee210298c813f87aae005432d2e934449",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bf4cb9bee210298c813f87aae005432d2e934449"
    }
  ],
  "stats": {
    "total": 183,
    "additions": 104,
    "deletions": 79
  },
  "files": [
    {
      "sha": "dbfc94ca052ef898edbbea9ffd50219732f14582",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -1,3 +1,26 @@\n+2020-05-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* symtab.h (class demangle_result_storage) <set_malloc_ptr>: New\n+\toverload.\n+\t<swap_string, m_string>: Remove.\n+\t* symtab.c (demangle_for_lookup, completion_list_add_symbol):\n+\tUpdate.\n+\t* stabsread.c (define_symbol, read_type): Update.\n+\t* linespec.c (find_linespec_symbols): Update.\n+\t* gnu-v3-abi.c (gnuv3_get_typeid): Update.\n+\t* dwarf2/read.c (dwarf2_canonicalize_name): Update.\n+\t* dbxread.c (read_dbx_symtab): Update.\n+\t* cp-support.h (cp_canonicalize_string_full)\n+\t(cp_canonicalize_string, cp_canonicalize_string_no_typedefs):\n+\tReturn unique_xmalloc_ptr.\n+\t* cp-support.c (inspect_type): Update.\n+\t(cp_canonicalize_string_full): Return unique_xmalloc_ptr.\n+\t(cp_canonicalize_string_no_typedefs, cp_canonicalize_string):\n+\tLikewise.\n+\t* c-typeprint.c (print_name_maybe_canonical): Update.\n+\t* break-catch-throw.c (check_status_exception_catchpoint):\n+\tUpdate.\n+\n 2020-05-08  Tom de Vries  <tdevries@suse.de>\n \n \t* infrun.c (follow_fork): Copy current_line and current_symtab to"
    },
    {
      "sha": "59293c4e57060399b1dbeb3d70f68276434ca110",
      "filename": "gdb/break-catch-throw.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/break-catch-throw.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/break-catch-throw.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-throw.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -156,26 +156,28 @@ check_status_exception_catchpoint (struct bpstats *bs)\n   if (self->pattern == NULL)\n     return;\n \n+  const char *name = nullptr;\n+  gdb::unique_xmalloc_ptr<char> canon;\n   try\n     {\n       struct value *typeinfo_arg;\n-      std::string canon;\n \n       fetch_probe_arguments (NULL, &typeinfo_arg);\n       type_name = cplus_typename_from_type_info (typeinfo_arg);\n \n       canon = cp_canonicalize_string (type_name.c_str ());\n-      if (!canon.empty ())\n-\tstd::swap (type_name, canon);\n+      name = (canon == nullptr\n+\t      ? canon.get ()\n+\t      : type_name.c_str ());\n     }\n   catch (const gdb_exception_error &e)\n     {\n       exception_print (gdb_stderr, e);\n     }\n \n-  if (!type_name.empty ())\n+  if (name != nullptr)\n     {\n-      if (self->pattern->exec (type_name.c_str (), 0, NULL, 0) != 0)\n+      if (self->pattern->exec (name, 0, NULL, 0) != 0)\n \tbs->stop = 0;\n     }\n }"
    },
    {
      "sha": "f84691a62e7aff99838680cfa91263fe61a2b5b1",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -1739,13 +1739,14 @@ oper:\tOPERATOR NEW\n \n \t\t\t  c_print_type ($2, NULL, &buf, -1, 0,\n \t\t\t\t\t&type_print_raw_options);\n+\t\t\t  std::string name = std::move (buf.string ());\n \n \t\t\t  /* This also needs canonicalization.  */\n-\t\t\t  std::string canon\n-\t\t\t    = cp_canonicalize_string (buf.c_str ());\n-\t\t\t  if (canon.empty ())\n-\t\t\t    canon = std::move (buf.string ());\n-\t\t\t  $$ = operator_stoken ((\" \" + canon).c_str ());\n+\t\t\t  gdb::unique_xmalloc_ptr<char> canon\n+\t\t\t    = cp_canonicalize_string (name.c_str ());\n+\t\t\t  if (canon != nullptr)\n+\t\t\t    name = canon.get ();\n+\t\t\t  $$ = operator_stoken ((\" \" + name).c_str ());\n \t\t\t}\n \t;\n "
    },
    {
      "sha": "aaf9e0dfe0a1a70a5dbae4edfb96c80f168688fa",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -84,14 +84,14 @@ print_name_maybe_canonical (const char *name,\n \t\t\t    const struct type_print_options *flags,\n \t\t\t    struct ui_file *stream)\n {\n-  std::string s;\n+  gdb::unique_xmalloc_ptr<char> s;\n \n   if (!flags->raw)\n     s = cp_canonicalize_string_full (name,\n \t\t\t\t     find_typedef_for_canonicalize,\n \t\t\t\t     (void *) flags);\n \n-  fputs_filtered (!s.empty () ? s.c_str () : name, stream);\n+  fputs_filtered (s != nullptr ? s.get () : name, stream);\n }\n \n \f"
    },
    {
      "sha": "92a2e3b4904111ae55541d0444524c679bcb83f0",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 20,
      "deletions": 21,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -274,12 +274,13 @@ inspect_type (struct demangle_parse_info *info,\n \n \t\t Canonicalize the name again, and store it in the\n \t\t current node (RET_COMP).  */\n-\t      std::string canon = cp_canonicalize_string_no_typedefs (name);\n+\t      gdb::unique_xmalloc_ptr<char> canon\n+\t\t= cp_canonicalize_string_no_typedefs (name);\n \n-\t      if (!canon.empty ())\n+\t      if (canon != nullptr)\n \t\t{\n \t\t  /* Copy the canonicalization into the obstack.  */\n-\t\t  name = copy_string_to_obstack (&info->obstack, canon.c_str (), &len);\n+\t\t  name = copy_string_to_obstack (&info->obstack, canon.get (), &len);\n \t\t}\n \n \t      ret_comp->u.s_name.s = name;\n@@ -506,16 +507,15 @@ replace_typedefs (struct demangle_parse_info *info,\n \n /* Parse STRING and convert it to canonical form, resolving any\n    typedefs.  If parsing fails, or if STRING is already canonical,\n-   return the empty string.  Otherwise return the canonical form.  If\n+   return nullptr.  Otherwise return the canonical form.  If\n    FINDER is not NULL, then type components are passed to FINDER to be\n    looked up.  DATA is passed verbatim to FINDER.  */\n \n-std::string\n+gdb::unique_xmalloc_ptr<char>\n cp_canonicalize_string_full (const char *string,\n \t\t\t     canonicalization_ftype *finder,\n \t\t\t     void *data)\n {\n-  std::string ret;\n   unsigned int estimated_len;\n   std::unique_ptr<demangle_parse_info> info;\n \n@@ -531,41 +531,42 @@ cp_canonicalize_string_full (const char *string,\n \t\t\t\t\t\t\t    estimated_len);\n       gdb_assert (us);\n \n-      ret = us.get ();\n       /* Finally, compare the original string with the computed\n \t name, returning NULL if they are the same.  */\n-      if (ret == string)\n-\treturn std::string ();\n+      if (strcmp (us.get (), string) == 0)\n+\treturn nullptr;\n+\n+      return us;\n     }\n \n-  return ret;\n+  return nullptr;\n }\n \n /* Like cp_canonicalize_string_full, but always passes NULL for\n    FINDER.  */\n \n-std::string\n+gdb::unique_xmalloc_ptr<char>\n cp_canonicalize_string_no_typedefs (const char *string)\n {\n   return cp_canonicalize_string_full (string, NULL, NULL);\n }\n \n /* Parse STRING and convert it to canonical form.  If parsing fails,\n-   or if STRING is already canonical, return the empty string.\n+   or if STRING is already canonical, return nullptr.\n    Otherwise return the canonical form.  */\n \n-std::string\n+gdb::unique_xmalloc_ptr<char>\n cp_canonicalize_string (const char *string)\n {\n   std::unique_ptr<demangle_parse_info> info;\n   unsigned int estimated_len;\n \n   if (cp_already_canonical (string))\n-    return std::string ();\n+    return nullptr;\n \n   info = cp_demangled_name_to_comp (string, NULL);\n   if (info == NULL)\n-    return std::string ();\n+    return nullptr;\n \n   estimated_len = strlen (string) * 2;\n   gdb::unique_xmalloc_ptr<char> us (cp_comp_to_string (info->tree,\n@@ -575,15 +576,13 @@ cp_canonicalize_string (const char *string)\n     {\n       warning (_(\"internal error: string \\\"%s\\\" failed to be canonicalized\"),\n \t       string);\n-      return std::string ();\n+      return nullptr;\n     }\n \n-  std::string ret (us.get ());\n-\n-  if (ret == string)\n-    return std::string ();\n+  if (strcmp (us.get (), string) == 0)\n+    return nullptr;\n \n-  return ret;\n+  return us;\n }\n \n /* Convert a mangled name to a demangle_component tree.  *MEMORY is"
    },
    {
      "sha": "6ca898315bb1a8d4f9632e73680eab260167c622",
      "filename": "gdb/cp-support.h",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/cp-support.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/cp-support.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.h?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -77,15 +77,16 @@ struct demangle_parse_info\n \n /* Functions from cp-support.c.  */\n \n-extern std::string cp_canonicalize_string (const char *string);\n+extern gdb::unique_xmalloc_ptr<char> cp_canonicalize_string\n+  (const char *string);\n \n-extern std::string cp_canonicalize_string_no_typedefs (const char *string);\n+extern gdb::unique_xmalloc_ptr<char> cp_canonicalize_string_no_typedefs\n+  (const char *string);\n \n typedef const char *(canonicalization_ftype) (struct type *, void *);\n \n-extern std::string cp_canonicalize_string_full (const char *string,\n-\t\t\t\t\t\tcanonicalization_ftype *finder,\n-\t\t\t\t\t\tvoid *data);\n+extern gdb::unique_xmalloc_ptr<char> cp_canonicalize_string_full\n+  (const char *string, canonicalization_ftype *finder, void *data);\n \n extern char *cp_class_name_from_physname (const char *physname);\n "
    },
    {
      "sha": "1e1a5dc9b979e520c7859eb1b32046b6670efcff",
      "filename": "gdb/dbxread.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/dbxread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/dbxread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dbxread.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -1434,12 +1434,13 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n  \t  if (psymtab_language == language_cplus)\n  \t    {\n \t      std::string name (namestring, p - namestring);\n-\t      std::string new_name = cp_canonicalize_string (name.c_str ());\n-\t      if (!new_name.empty ())\n+\t      gdb::unique_xmalloc_ptr<char> new_name\n+\t\t= cp_canonicalize_string (name.c_str ());\n+\t      if (new_name != nullptr)\n \t\t{\n-\t\t  sym_len = new_name.length ();\n+\t\t  sym_len = strlen (new_name.get ());\n \t\t  sym_name = obstack_strdup (&objfile->objfile_obstack,\n-\t\t\t\t\t     new_name);\n+\t\t\t\t\t     new_name.get ());\n \t\t}\n \t    }\n "
    },
    {
      "sha": "60b56b8ea81be49613c47e8205987b0cf730f6a1",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -21736,13 +21736,11 @@ dwarf2_canonicalize_name (const char *name, struct dwarf2_cu *cu,\n {\n   if (name && cu->language == language_cplus)\n     {\n-      std::string canon_name = cp_canonicalize_string (name);\n+      gdb::unique_xmalloc_ptr<char> canon_name\n+\t= cp_canonicalize_string (name);\n \n-      if (!canon_name.empty ())\n-\t{\n-\t  if (canon_name != name)\n-\t    name = objfile->intern (canon_name);\n-\t}\n+      if (canon_name != nullptr)\n+\tname = objfile->intern (canon_name.get ());\n     }\n \n   return name;"
    },
    {
      "sha": "83deed5965792fa3ef5a7568007f0bbcfdf0c87b",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -1090,7 +1090,8 @@ gnuv3_get_typeid (struct value *value)\n   struct type *type;\n   struct gdbarch *gdbarch;\n   struct value *result;\n-  std::string type_name, canonical;\n+  std::string type_name;\n+  gdb::unique_xmalloc_ptr<char> canonical;\n \n   /* We have to handle values a bit trickily here, to allow this code\n      to work properly with non_lvalue values that are really just\n@@ -1118,8 +1119,9 @@ gnuv3_get_typeid (struct value *value)\n      uses.  E.g., GDB tends to use \"const char *\" as a type name, but\n      the demangler uses \"char const *\".  */\n   canonical = cp_canonicalize_string (type_name.c_str ());\n-  if (!canonical.empty ())\n-    type_name = canonical;\n+  const char *name = (canonical == nullptr\n+\t\t      ? type_name.c_str ()\n+\t\t      : canonical.get ());\n \n   typeinfo_type = gnuv3_get_typeid_type (gdbarch);\n \n@@ -1135,19 +1137,19 @@ gnuv3_get_typeid (struct value *value)\n       vtable = gnuv3_get_vtable (gdbarch, type, address);\n       if (vtable == NULL)\n \terror (_(\"cannot find typeinfo for object of type '%s'\"),\n-\t       type_name.c_str ());\n+\t       name);\n       typeinfo_value = value_field (vtable, vtable_field_type_info);\n       result = value_ind (value_cast (make_pointer_type (typeinfo_type, NULL),\n \t\t\t\t      typeinfo_value));\n     }\n   else\n     {\n-      std::string sym_name = std::string (\"typeinfo for \") + type_name;\n+      std::string sym_name = std::string (\"typeinfo for \") + name;\n       bound_minimal_symbol minsym\n \t= lookup_minimal_symbol (sym_name.c_str (), NULL, NULL);\n \n       if (minsym.minsym == NULL)\n-\terror (_(\"could not find typeinfo symbol for '%s'\"), type_name.c_str ());\n+\terror (_(\"could not find typeinfo symbol for '%s'\"), name);\n \n       result = value_at_lazy (typeinfo_type, BMSYMBOL_VALUE_ADDRESS (minsym));\n     }"
    },
    {
      "sha": "6007cd22eaf1dfe189e9b195f512d418ae944b38",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -3898,9 +3898,10 @@ find_linespec_symbols (struct linespec_state *state,\n \t\t       std::vector <block_symbol> *symbols,\n \t\t       std::vector<bound_minimal_symbol> *minsyms)\n {\n-  std::string canon = cp_canonicalize_string_no_typedefs (lookup_name);\n-  if (!canon.empty ())\n-    lookup_name = canon.c_str ();\n+  gdb::unique_xmalloc_ptr<char> canon\n+    = cp_canonicalize_string_no_typedefs (lookup_name);\n+  if (canon != nullptr)\n+    lookup_name = canon.get ();\n \n   /* It's important to not call expand_symtabs_matching unnecessarily\n      as it can really slow things down (by unnecessarily expanding"
    },
    {
      "sha": "eac47407105a7b81068b00a3c5b78da7310002c8",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -738,7 +738,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n   else\n     {\n     normal:\n-      std::string new_name;\n+      gdb::unique_xmalloc_ptr<char> new_name;\n \n       if (sym->language () == language_cplus)\n \t{\n@@ -748,8 +748,8 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  name[p - string] = '\\0';\n \t  new_name = cp_canonicalize_string (name);\n \t}\n-      if (!new_name.empty ())\n-\tsym->compute_and_set_names (new_name, true, objfile->per_bfd);\n+      if (new_name != nullptr)\n+\tsym->compute_and_set_names (new_name.get (), true, objfile->per_bfd);\n       else\n \tsym->compute_and_set_names (gdb::string_view (string, p - string), true,\n \t\t\t\t    objfile->per_bfd);\n@@ -1637,10 +1637,10 @@ read_type (const char **pp, struct objfile *objfile)\n \t      memcpy (name, *pp, p - *pp);\n \t      name[p - *pp] = '\\0';\n \n-\t      std::string new_name = cp_canonicalize_string (name);\n-\t      if (!new_name.empty ())\n+\t      gdb::unique_xmalloc_ptr<char> new_name = cp_canonicalize_string (name);\n+\t      if (new_name != nullptr)\n \t\ttype_name = obstack_strdup (&objfile->objfile_obstack,\n-\t\t\t\t\t    new_name);\n+\t\t\t\t\t    new_name.get ());\n \t    }\n \t  if (type_name == NULL)\n \t    {"
    },
    {
      "sha": "ffd9707d9e745f482e068c182b843d24b0c3df92",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -1838,9 +1838,9 @@ demangle_for_lookup (const char *name, enum language lang,\n \n       /* If we were given a non-mangled name, canonicalize it\n \t according to the language (so far only for C++).  */\n-      std::string canon = cp_canonicalize_string (name);\n-      if (!canon.empty ())\n-\treturn storage.swap_string (canon);\n+      gdb::unique_xmalloc_ptr<char> canon = cp_canonicalize_string (name);\n+      if (canon != nullptr)\n+\treturn storage.set_malloc_ptr (std::move (canon));\n     }\n   else if (lang == language_d)\n     {\n@@ -5349,10 +5349,10 @@ completion_list_add_symbol (completion_tracker &tracker,\n       /* The call to canonicalize returns the empty string if the input\n \t string is already in canonical form, thanks to this we don't\n \t remove the symbol we just added above.  */\n-      std::string str\n+      gdb::unique_xmalloc_ptr<char> str\n \t= cp_canonicalize_string_no_typedefs (sym->natural_name ());\n-      if (!str.empty ())\n-\ttracker.remove_completion (str.c_str ());\n+      if (str != nullptr)\n+\ttracker.remove_completion (str.get ());\n     }\n }\n "
    },
    {
      "sha": "764c567a90bb9dd1ca176625f9267861517b2c67",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 7,
      "deletions": 10,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "patch": "@@ -2299,20 +2299,18 @@ bool iterate_over_symbols_terminated\n /* Storage type used by demangle_for_lookup.  demangle_for_lookup\n    either returns a const char * pointer that points to either of the\n    fields of this type, or a pointer to the input NAME.  This is done\n-   this way because the underlying functions that demangle_for_lookup\n-   calls either return a std::string (e.g., cp_canonicalize_string) or\n-   a malloc'ed buffer (libiberty's demangled), and we want to avoid\n-   unnecessary reallocation/string copying.  */\n+   this way to avoid depending on the precise details of the storage\n+   for the string.  */\n class demangle_result_storage\n {\n public:\n \n-  /* Swap the std::string storage with STR, and return a pointer to\n-     the beginning of the new string.  */\n-  const char *swap_string (std::string &str)\n+  /* Swap the malloc storage to STR, and return a pointer to the\n+     beginning of the new string.  */\n+  const char *set_malloc_ptr (gdb::unique_xmalloc_ptr<char> &&str)\n   {\n-    std::swap (m_string, str);\n-    return m_string.c_str ();\n+    m_malloc = std::move (str);\n+    return m_malloc.get ();\n   }\n \n   /* Set the malloc storage to now point at PTR.  Any previous malloc\n@@ -2326,7 +2324,6 @@ class demangle_result_storage\n private:\n \n   /* The storage.  */\n-  std::string m_string;\n   gdb::unique_xmalloc_ptr<char> m_malloc;\n };\n "
    }
  ]
}