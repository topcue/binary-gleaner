{
  "sha": "72f3392127e1892cb203a98092b4ae32485365fe",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzJmMzM5MjEyN2UxODkyY2IyMDNhOTgwOTJiNGFlMzI0ODUzNjVmZQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-24T09:17:13Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:07:46Z"
    },
    "message": "libctf: opening\n\nThis fills in the other half of the opening/creation puzzle: opening of\nalready-existing CTF files.  Such files are always read-only: if you\nwant to add to a CTF file opened with one of the opening functions in\nthis file, use ctf_add_type(), in a later commit, to copy appropriate\ntypes into a newly ctf_create()d, writable container.\n\nThe lowest-level opening functions are in here: ctf_bufopen(), which\ntakes ctf_sect_t structures akin to ELF section headers, and\nctf_simple_open(), which can be used if you don't have an entire ELF\nsection header to work from.  Both will malloc() new space for the\nbuffers only if necessary, will mmap() directly from the file if\nrequested, and will mprotect() it afterwards to prevent accidental\ncorruption of the types. These functions are also used by ctf_update()\nwhen converting types in a writable container into read-only types that\ncan be looked up using the lookup functions (in later commits).\n\nThe files are always of the native endianness of the system that created\nthem: at read time, the endianness of the header magic number is used to\ndetermine whether or not the file needs byte-swapping, and the entire\nthing is aggressively byte-swapped.\n\nThe agggressive nature of this swapping avoids complicating the rest of\nthe code with endianness conversions, while the native endianness\nintroduces no byte-swapping overhead in the common case. (The\nendianness-independence code is also much newer than everything else in\nthis file, and deserves closer scrutiny.)\n\nThe accessors at the top of the file are there to transparently support\nolder versions of the CTF file format, allowing translation from older\nformats that have different sizes for the structures in ctf.h:\ncurrently, these older formats are intermingled with the newer ones in\nctf.h: they will probably migrate to a compatibility header in time, to\nease readability.  The ctf_set_base() function is split out for the same\nreason: when conversion code to a newer format is written, it would need\nto malloc() new storage for the entire ctf_file_t if a file format\nchange causes it to grow, and for that we need ctf_set_base() to be a\nseparate function.\n\nOne pair of linked data structures supported by this file has no\ncreation code in libctf yet: the data and function object sections read\nby init_symtab(). These will probably arrive soon, when the linker comes\nto need them. (init_symtab() has hardly been changed since 2009, but if\nany code in libctf has rotted over time, this will.)\n\nA few simple accessors are also present that can even be called on\nread-only containers because they don't actually modify them, since the\nrelevant things are not stored in the container but merely change its\noperation: ctf_setmodel(), which lets you specify whether a container is\nLP64 or not (used to statically determine the sizes of a few types),\nctf_import(), which is the only way to associate a parent container with\na child container, and ctf_setspecific(), which lets the caller\nassociate an arbitrary pointer with the CTF container for any use. If\nthe user doesn't call these functions correctly, libctf will misbehave:\nthis is particularly important for ctf_import(), since a container built\nagainst a given parent container will not be able to resolve types that\ndepend on types in the parent unless it is ctf_import()ed with a parent\ncontainer with the same set of types at the same IDs, or a superset.\n\nPossible future extensions (also noted in the ctf-hash.c file) include\nstoring a count of things so that we don't need to do one pass over the\nCTF file counting everything, and computing a perfect hash at CTF\ncreation time in some compact form, storing it in the CTF file, and\nusing it to hash things so we don't need to do a second pass over the\nentire CTF file to set up the hashes used to go from names to type IDs.\n(There are multiple such hashes, one for each C type namespace: types,\nenums, structs, and unions.)\n\nlibctf/\n\t* ctf-open.c: New file.\n\t* swap.h: Likewise.\ninclude/\n\t* ctf-api.h (ctf_file_close): New declaration.\n\t(ctf_getdatasect): Likewise.\n\t(ctf_parent_file): Likewise.\n\t(ctf_parent_name): Likewise.\n\t(ctf_parent_name_set): Likewise.\n\t(ctf_import): Likewise.\n\t(ctf_setmodel): Likewise.\n\t(ctf_getmodel): Likewise.\n\t(ctf_setspecific): Likewise.\n\t(ctf_getspecific): Likewise.",
    "tree": {
      "sha": "9c851214b2dd4f6f1967c7be277b536684923085",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9c851214b2dd4f6f1967c7be277b536684923085"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/72f3392127e1892cb203a98092b4ae32485365fe",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72f3392127e1892cb203a98092b4ae32485365fe",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/72f3392127e1892cb203a98092b4ae32485365fe",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72f3392127e1892cb203a98092b4ae32485365fe/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "47d546f427d0d3bf9f503b5b118ae05b49d73d28",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/47d546f427d0d3bf9f503b5b118ae05b49d73d28",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/47d546f427d0d3bf9f503b5b118ae05b49d73d28"
    }
  ],
  "stats": {
    "total": 1767,
    "additions": 1767,
    "deletions": 0
  },
  "files": [
    {
      "sha": "8b82efedf00a5b55efecdbf88598c75b78a4973e",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72f3392127e1892cb203a98092b4ae32485365fe/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72f3392127e1892cb203a98092b4ae32485365fe/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=72f3392127e1892cb203a98092b4ae32485365fe",
      "patch": "@@ -1,3 +1,16 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_file_close): New declaration.\n+\t(ctf_getdatasect): Likewise.\n+\t(ctf_parent_file): Likewise.\n+\t(ctf_parent_name): Likewise.\n+\t(ctf_parent_name_set): Likewise.\n+\t(ctf_import): Likewise.\n+\t(ctf_setmodel): Likewise.\n+\t(ctf_getmodel): Likewise.\n+\t(ctf_setspecific): Likewise.\n+\t(ctf_getspecific): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (zlib.h): New include."
    },
    {
      "sha": "d9eff0bc2841889fd00456a87c4a2529e6142d72",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72f3392127e1892cb203a98092b4ae32485365fe/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72f3392127e1892cb203a98092b4ae32485365fe/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=72f3392127e1892cb203a98092b4ae32485365fe",
      "patch": "@@ -198,10 +198,23 @@ enum\n #define\tCTF_ADD_NONROOT\t0\t/* Type only visible in nested scope.  */\n #define\tCTF_ADD_ROOT\t1\t/* Type visible at top-level scope.  */\n \n+extern ctf_sect_t ctf_getdatasect (const ctf_file_t *);\n extern ctf_file_t *ctf_simple_open (const char *, size_t, const char *, size_t,\n \t\t\t\t   size_t, const char *, size_t, int *);\n extern ctf_file_t *ctf_bufopen (const ctf_sect_t *, const ctf_sect_t *,\n \t\t\t\tconst ctf_sect_t *, int *);\n+extern void ctf_file_close (ctf_file_t *);\n+\n+extern ctf_file_t *ctf_parent_file (ctf_file_t *);\n+extern const char *ctf_parent_name (ctf_file_t *);\n+extern void ctf_parent_name_set (ctf_file_t *, const char *);\n+\n+extern int ctf_import (ctf_file_t *, ctf_file_t *);\n+extern int ctf_setmodel (ctf_file_t *, int);\n+extern int ctf_getmodel (ctf_file_t *);\n+\n+extern void ctf_setspecific (ctf_file_t *, void *);\n+extern void *ctf_getspecific (ctf_file_t *);\n \n extern int ctf_errno (ctf_file_t *);\n extern const char *ctf_errmsg (int);"
    },
    {
      "sha": "4a69c62fd1c6e8b611ddd00f0a2ad032bee4da00",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72f3392127e1892cb203a98092b4ae32485365fe/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72f3392127e1892cb203a98092b4ae32485365fe/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=72f3392127e1892cb203a98092b4ae32485365fe",
      "patch": "@@ -1,3 +1,8 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-open.c: New file.\n+\t* swap.h: Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-create.c: New file."
    },
    {
      "sha": "fcc0c9d29c082c632394b5225150aed822cd29ff",
      "filename": "libctf/ctf-open.c",
      "status": "added",
      "additions": 1676,
      "deletions": 0,
      "changes": 1676,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72f3392127e1892cb203a98092b4ae32485365fe/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72f3392127e1892cb203a98092b4ae32485365fe/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=72f3392127e1892cb203a98092b4ae32485365fe",
      "patch": "@@ -0,0 +1,1676 @@\n+/* Opening CTF files.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <stddef.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <elf.h>\n+#include <assert.h>\n+#include \"swap.h\"\n+#include <bfd.h>\n+#include <zlib.h>\n+\n+#include \"elf-bfd.h\"\n+\n+static const ctf_dmodel_t _libctf_models[] = {\n+  {\"ILP32\", CTF_MODEL_ILP32, 4, 1, 2, 4, 4},\n+  {\"LP64\", CTF_MODEL_LP64, 8, 1, 2, 4, 8},\n+  {NULL, 0, 0, 0, 0, 0, 0}\n+};\n+\n+const char _CTF_SECTION[] = \".ctf\";\n+const char _CTF_NULLSTR[] = \"\";\n+\n+/* Version-sensitive accessors.  */\n+\n+static uint32_t\n+get_kind_v1 (uint32_t info)\n+{\n+  return (CTF_V1_INFO_KIND (info));\n+}\n+\n+static uint32_t\n+get_root_v1 (uint32_t info)\n+{\n+  return (CTF_V1_INFO_ISROOT (info));\n+}\n+\n+static uint32_t\n+get_vlen_v1 (uint32_t info)\n+{\n+  return (CTF_V1_INFO_VLEN (info));\n+}\n+\n+static uint32_t\n+get_kind_v2 (uint32_t info)\n+{\n+  return (CTF_V2_INFO_KIND (info));\n+}\n+\n+static uint32_t\n+get_root_v2 (uint32_t info)\n+{\n+  return (CTF_V2_INFO_ISROOT (info));\n+}\n+\n+static uint32_t\n+get_vlen_v2 (uint32_t info)\n+{\n+  return (CTF_V2_INFO_VLEN (info));\n+}\n+\n+static inline ssize_t\n+get_ctt_size_common (const ctf_file_t *fp _libctf_unused_,\n+\t\t     const ctf_type_t *tp _libctf_unused_,\n+\t\t     ssize_t *sizep, ssize_t *incrementp, size_t lsize,\n+\t\t     size_t csize, size_t ctf_type_size,\n+\t\t     size_t ctf_stype_size, size_t ctf_lsize_sent)\n+{\n+  ssize_t size, increment;\n+\n+  if (csize == ctf_lsize_sent)\n+    {\n+      size = lsize;\n+      increment = ctf_type_size;\n+    }\n+  else\n+    {\n+      size = csize;\n+      increment = ctf_stype_size;\n+    }\n+\n+  if (sizep)\n+    *sizep = size;\n+  if (incrementp)\n+    *incrementp = increment;\n+\n+  return size;\n+}\n+\n+static ssize_t\n+get_ctt_size_v1 (const ctf_file_t *fp, const ctf_type_t *tp,\n+\t\t ssize_t *sizep, ssize_t *incrementp)\n+{\n+  ctf_type_v1_t *t1p = (ctf_type_v1_t *) tp;\n+\n+  return (get_ctt_size_common (fp, tp, sizep, incrementp,\n+\t\t\t       CTF_TYPE_LSIZE (t1p), t1p->ctt_size,\n+\t\t\t       sizeof (ctf_type_v1_t), sizeof (ctf_stype_v1_t),\n+\t\t\t       CTF_LSIZE_SENT_V1));\n+}\n+\n+/* Return the size that a v1 will be once it is converted to v2.  */\n+\n+static ssize_t\n+get_ctt_size_v2_unconverted (const ctf_file_t *fp, const ctf_type_t *tp,\n+\t\t\t     ssize_t *sizep, ssize_t *incrementp)\n+{\n+  ctf_type_v1_t *t1p = (ctf_type_v1_t *) tp;\n+\n+  return (get_ctt_size_common (fp, tp, sizep, incrementp,\n+\t\t\t       CTF_TYPE_LSIZE (t1p), t1p->ctt_size,\n+\t\t\t       sizeof (ctf_type_t), sizeof (ctf_stype_t),\n+\t\t\t       CTF_LSIZE_SENT));\n+}\n+\n+static ssize_t\n+get_ctt_size_v2 (const ctf_file_t *fp, const ctf_type_t *tp,\n+\t\t ssize_t *sizep, ssize_t *incrementp)\n+{\n+  return (get_ctt_size_common (fp, tp, sizep, incrementp,\n+\t\t\t       CTF_TYPE_LSIZE (tp), tp->ctt_size,\n+\t\t\t       sizeof (ctf_type_t), sizeof (ctf_stype_t),\n+\t\t\t       CTF_LSIZE_SENT));\n+}\n+\n+static ssize_t\n+get_vbytes_common (unsigned short kind, ssize_t size _libctf_unused_,\n+\t\t   size_t vlen)\n+{\n+  switch (kind)\n+    {\n+    case CTF_K_INTEGER:\n+    case CTF_K_FLOAT:\n+      return (sizeof (uint32_t));\n+    case CTF_K_SLICE:\n+      return (offsetof (ctf_slice_t, cts_bits) +\n+\t      sizeof (((ctf_slice_t *)0)->cts_bits));\n+    case CTF_K_ENUM:\n+      return (sizeof (ctf_enum_t) * vlen);\n+    case CTF_K_FORWARD:\n+    case CTF_K_UNKNOWN:\n+    case CTF_K_POINTER:\n+    case CTF_K_TYPEDEF:\n+    case CTF_K_VOLATILE:\n+    case CTF_K_CONST:\n+    case CTF_K_RESTRICT:\n+      return 0;\n+    default:\n+      ctf_dprintf (\"detected invalid CTF kind -- %x\\n\", kind);\n+      return ECTF_CORRUPT;\n+    }\n+}\n+\n+static ssize_t\n+get_vbytes_v1 (unsigned short kind, ssize_t size, size_t vlen)\n+{\n+  switch (kind)\n+    {\n+    case CTF_K_ARRAY:\n+      return (sizeof (ctf_array_v1_t));\n+    case CTF_K_FUNCTION:\n+      return (sizeof (unsigned short) * (vlen + (vlen & 1)));\n+    case CTF_K_STRUCT:\n+    case CTF_K_UNION:\n+      if (size < CTF_LSTRUCT_THRESH_V1)\n+\treturn (sizeof (ctf_member_v1_t) * vlen);\n+      else\n+\treturn (sizeof (ctf_lmember_v1_t) * vlen);\n+    }\n+\n+  return (get_vbytes_common (kind, size, vlen));\n+}\n+\n+static ssize_t\n+get_vbytes_v2 (unsigned short kind, ssize_t size, size_t vlen)\n+{\n+  switch (kind)\n+    {\n+    case CTF_K_ARRAY:\n+      return (sizeof (ctf_array_t));\n+    case CTF_K_FUNCTION:\n+      return (sizeof (uint32_t) * (vlen + (vlen & 1)));\n+    case CTF_K_STRUCT:\n+    case CTF_K_UNION:\n+      if (size < CTF_LSTRUCT_THRESH)\n+\treturn (sizeof (ctf_member_t) * vlen);\n+      else\n+\treturn (sizeof (ctf_lmember_t) * vlen);\n+    }\n+\n+  return (get_vbytes_common (kind, size, vlen));\n+}\n+\n+static const ctf_fileops_t ctf_fileops[] = {\n+  {NULL, NULL, NULL, NULL, NULL},\n+  /* CTF_VERSION_1 */\n+  {get_kind_v1, get_root_v1, get_vlen_v1, get_ctt_size_v1, get_vbytes_v1},\n+  /* CTF_VERSION_1_UPGRADED_3 */\n+  {get_kind_v2, get_root_v2, get_vlen_v2, get_ctt_size_v2, get_vbytes_v2},\n+  /* CTF_VERSION_2 */\n+  {get_kind_v2, get_root_v2, get_vlen_v2, get_ctt_size_v2, get_vbytes_v2},\n+  /* CTF_VERSION_3, identical to 2: only new type kinds */\n+  {get_kind_v2, get_root_v2, get_vlen_v2, get_ctt_size_v2, get_vbytes_v2},\n+};\n+\n+/* Initialize the symtab translation table by filling each entry with the\n+  offset of the CTF type or function data corresponding to each STT_FUNC or\n+  STT_OBJECT entry in the symbol table.  */\n+\n+static int\n+init_symtab (ctf_file_t *fp, const ctf_header_t *hp,\n+\t     const ctf_sect_t *sp, const ctf_sect_t *strp)\n+{\n+  const unsigned char *symp = sp->cts_data;\n+  uint32_t *xp = fp->ctf_sxlate;\n+  uint32_t *xend = xp + fp->ctf_nsyms;\n+\n+  uint32_t objtoff = hp->cth_objtoff;\n+  uint32_t funcoff = hp->cth_funcoff;\n+\n+  uint32_t info, vlen;\n+  Elf64_Sym sym, *gsp;\n+  const char *name;\n+\n+  /* The CTF data object and function type sections are ordered to match\n+     the relative order of the respective symbol types in the symtab.\n+     If no type information is available for a symbol table entry, a\n+     pad is inserted in the CTF section.  As a further optimization,\n+     anonymous or undefined symbols are omitted from the CTF data.  */\n+\n+  for (; xp < xend; xp++, symp += sp->cts_entsize)\n+    {\n+      if (sp->cts_entsize == sizeof (Elf32_Sym))\n+\tgsp = ctf_sym_to_elf64 ((Elf32_Sym *) (uintptr_t) symp, &sym);\n+      else\n+\tgsp = (Elf64_Sym *) (uintptr_t) symp;\n+\n+      if (gsp->st_name < strp->cts_size)\n+\tname = (const char *) strp->cts_data + gsp->st_name;\n+      else\n+\tname = _CTF_NULLSTR;\n+\n+      if (gsp->st_name == 0 || gsp->st_shndx == SHN_UNDEF\n+\t  || strcmp (name, \"_START_\") == 0 || strcmp (name, \"_END_\") == 0)\n+\t{\n+\t  *xp = -1u;\n+\t  continue;\n+\t}\n+\n+      switch (ELF64_ST_TYPE (gsp->st_info))\n+\t{\n+\tcase STT_OBJECT:\n+\t  if (objtoff >= hp->cth_funcoff\n+\t      || (gsp->st_shndx == SHN_EXTABS && gsp->st_value == 0))\n+\t    {\n+\t      *xp = -1u;\n+\t      break;\n+\t    }\n+\n+\t  *xp = objtoff;\n+\t  objtoff += sizeof (uint32_t);\n+\t  break;\n+\n+\tcase STT_FUNC:\n+\t  if (funcoff >= hp->cth_typeoff)\n+\t    {\n+\t      *xp = -1u;\n+\t      break;\n+\t    }\n+\n+\t  *xp = funcoff;\n+\n+\t  info = *(uint32_t *) ((uintptr_t) fp->ctf_buf + funcoff);\n+\t  vlen = LCTF_INFO_VLEN (fp, info);\n+\n+\t  /* If we encounter a zero pad at the end, just skip it.  Otherwise\n+\t     skip over the function and its return type (+2) and the argument\n+\t     list (vlen).\n+\t   */\n+\t  if (LCTF_INFO_KIND (fp, info) == CTF_K_UNKNOWN && vlen == 0)\n+\t    funcoff += sizeof (uint32_t);\t/* Skip pad.  */\n+\t  else\n+\t    funcoff += sizeof (uint32_t) * (vlen + 2);\n+\t  break;\n+\n+\tdefault:\n+\t  *xp = -1u;\n+\t  break;\n+\t}\n+    }\n+\n+  ctf_dprintf (\"loaded %lu symtab entries\\n\", fp->ctf_nsyms);\n+  return 0;\n+}\n+\n+/* Set the CTF base pointer and derive the buf pointer from it, initializing\n+   everything in the ctf_file that depends on the base or buf pointers.  */\n+\n+static void\n+ctf_set_base (ctf_file_t *fp, const ctf_header_t *hp, void *base)\n+{\n+  fp->ctf_base = base;\n+  fp->ctf_buf = fp->ctf_base + sizeof (ctf_header_t);\n+  fp->ctf_vars = (ctf_varent_t *) ((const char *) fp->ctf_buf +\n+\t\t\t\t   hp->cth_varoff);\n+  fp->ctf_nvars = (hp->cth_typeoff - hp->cth_varoff) / sizeof (ctf_varent_t);\n+\n+  fp->ctf_str[CTF_STRTAB_0].cts_strs = (const char *) fp->ctf_buf\n+    + hp->cth_stroff;\n+  fp->ctf_str[CTF_STRTAB_0].cts_len = hp->cth_strlen;\n+\n+  /* If we have a parent container name and label, store the relocated\n+     string pointers in the CTF container for easy access later. */\n+\n+  /* Note: before conversion, these will be set to values that will be\n+     immediately invalidated by the conversion process, but the conversion\n+     process will call ctf_set_base() again to fix things up.  */\n+\n+  if (hp->cth_parlabel != 0)\n+    fp->ctf_parlabel = ctf_strptr (fp, hp->cth_parlabel);\n+  if (hp->cth_parname != 0)\n+    fp->ctf_parname = ctf_strptr (fp, hp->cth_parname);\n+\n+  ctf_dprintf (\"ctf_set_base: parent name %s (label %s)\\n\",\n+\t       fp->ctf_parname ? fp->ctf_parname : \"<NULL>\",\n+\t       fp->ctf_parlabel ? fp->ctf_parlabel : \"<NULL>\");\n+}\n+\n+/* Free a ctf_base pointer: the pointer passed, or (if NULL) fp->ctf_base.  */\n+static void\n+ctf_free_base (ctf_file_t *fp, unsigned char *ctf_base, size_t ctf_size)\n+{\n+  unsigned char *base;\n+  size_t size;\n+\n+  if (ctf_base)\n+    {\n+      base = ctf_base;\n+      size = ctf_size;\n+    }\n+  else\n+    {\n+      base = (unsigned char *) fp->ctf_base;\n+      size = fp->ctf_size;\n+    }\n+\n+  if (base != fp->ctf_data.cts_data && base != NULL)\n+    ctf_data_free (base, size);\n+}\n+\n+/* Set the version of the CTF file. */\n+\n+/* When this is reset, LCTF_* changes behaviour, but there is no guarantee that\n+   the variable data list associated with each type has been upgraded: the\n+   caller must ensure this has been done in advance.  */\n+\n+static void\n+ctf_set_version (ctf_file_t * fp, ctf_header_t * cth, int ctf_version)\n+{\n+  fp->ctf_version = ctf_version;\n+  cth->cth_version = ctf_version;\n+  fp->ctf_fileops = &ctf_fileops[ctf_version];\n+}\n+\n+/* Upgrade the type table to CTF_VERSION_3 (really CTF_VERSION_1_UPGRADED_3).\n+\n+   The upgrade is not done in-place: the ctf_base is moved.  ctf_strptr() must\n+   not be called before reallocation is complete.\n+\n+   Type kinds not checked here due to nonexistence in older formats:\n+      CTF_K_SLICE.  */\n+static int\n+upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n+{\n+  const ctf_type_v1_t *tbuf;\n+  const ctf_type_v1_t *tend;\n+  unsigned char *ctf_base, *old_ctf_base = (unsigned char *) fp->ctf_base;\n+  size_t old_ctf_size = fp->ctf_size;\n+  ctf_type_t *t2buf;\n+\n+  ssize_t increase = 0, size, increment, v2increment, vbytes, v2bytes;\n+  const ctf_type_v1_t *tp;\n+  ctf_type_t *t2p;\n+  ctf_header_t *new_cth;\n+\n+  tbuf = (ctf_type_v1_t *) (fp->ctf_buf + cth->cth_typeoff);\n+  tend = (ctf_type_v1_t *) (fp->ctf_buf + cth->cth_stroff);\n+\n+  /* Much like init_types(), this is a two-pass process.\n+\n+     First, figure out the new type-section size needed.  (It is possible,\n+     in theory, for it to be less than the old size, but this is very\n+     unlikely.  It cannot be so small that cth_typeoff ends up of negative\n+     size.  We validate this with an assertion below.)\n+\n+     We must cater not only for changes in vlen and types sizes but also\n+     for changes in 'increment', which happen because v2 places some types\n+     into ctf_stype_t where v1 would be forced to use the larger non-stype.  */\n+\n+  for (tp = tbuf; tp < tend;\n+       tp = (ctf_type_v1_t *) ((uintptr_t) tp + increment + vbytes))\n+    {\n+      unsigned short kind = CTF_V1_INFO_KIND (tp->ctt_info);\n+      unsigned long vlen = CTF_V1_INFO_VLEN (tp->ctt_info);\n+\n+      size = get_ctt_size_v1 (fp, (const ctf_type_t *) tp, NULL, &increment);\n+      vbytes = get_vbytes_v1 (kind, size, vlen);\n+\n+      get_ctt_size_v2_unconverted (fp, (const ctf_type_t *) tp, NULL,\n+\t\t\t\t   &v2increment);\n+      v2bytes = get_vbytes_v2 (kind, size, vlen);\n+\n+      if ((vbytes < 0) || (size < 0))\n+\treturn ECTF_CORRUPT;\n+\n+      increase += v2increment - increment;\t/* May be negative.  */\n+      increase += v2bytes - vbytes;\n+    }\n+\n+  /* Allocate enough room for the new buffer, then copy everything but the\n+     type section into place, and reset the base accordingly.  Leave the\n+     version number unchanged, so that LCTF_INFO_* still works on the\n+     as-yet-untranslated type info.  */\n+\n+  if ((ctf_base = ctf_data_alloc (fp->ctf_size + increase)) == NULL)\n+    return ECTF_ZALLOC;\n+\n+  memcpy (ctf_base, fp->ctf_base, sizeof (ctf_header_t) + cth->cth_typeoff);\n+  memcpy (ctf_base + sizeof (ctf_header_t) + cth->cth_stroff + increase,\n+\t  fp->ctf_base + sizeof (ctf_header_t) + cth->cth_stroff,\n+\t  cth->cth_strlen);\n+\n+  memset (ctf_base + sizeof (ctf_header_t) + cth->cth_typeoff, 0,\n+\t cth->cth_stroff - cth->cth_typeoff + increase);\n+\n+  /* The cth here is an automatic variable in ctf_bufopen(), and transient\n+     (a copy maintained because at that stage the header read out of the\n+     ctf file may be read-only). We make all modifications in the\n+     canonical copy at ctf_base (by now, writable), then copy it back into\n+     cth at the end.  */\n+\n+  new_cth = (ctf_header_t *) ctf_base;\n+  new_cth->cth_stroff += increase;\n+  fp->ctf_size += increase;\n+  assert (new_cth->cth_stroff >= new_cth->cth_typeoff);\n+  ctf_set_base (fp, new_cth, ctf_base);\n+\n+  t2buf = (ctf_type_t *) (fp->ctf_buf + new_cth->cth_typeoff);\n+\n+  /* Iterate through all the types again, upgrading them.\n+\n+     Everything that hasn't changed can just be outright memcpy()ed.\n+     Things that have changed need field-by-field consideration.  */\n+\n+  for (tp = tbuf, t2p = t2buf; tp < tend;\n+       tp = (ctf_type_v1_t *) ((uintptr_t) tp + increment + vbytes),\n+       t2p = (ctf_type_t *) ((uintptr_t) t2p + v2increment + v2bytes))\n+    {\n+      unsigned short kind = CTF_V1_INFO_KIND (tp->ctt_info);\n+      int isroot = CTF_V1_INFO_ISROOT (tp->ctt_info);\n+      unsigned long vlen = CTF_V1_INFO_VLEN (tp->ctt_info);\n+      ssize_t v2size;\n+      void *vdata, *v2data;\n+\n+      size = get_ctt_size_v1 (fp, (const ctf_type_t *) tp, NULL, &increment);\n+      vbytes = get_vbytes_v1 (kind, size, vlen);\n+\n+      t2p->ctt_name = tp->ctt_name;\n+      t2p->ctt_info = CTF_TYPE_INFO (kind, isroot, vlen);\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_FUNCTION:\n+\tcase CTF_K_FORWARD:\n+\tcase CTF_K_TYPEDEF:\n+\tcase CTF_K_POINTER:\n+\tcase CTF_K_VOLATILE:\n+\tcase CTF_K_CONST:\n+\tcase CTF_K_RESTRICT:\n+\t  t2p->ctt_type = tp->ctt_type;\n+\t  break;\n+\tcase CTF_K_INTEGER:\n+\tcase CTF_K_FLOAT:\n+\tcase CTF_K_ARRAY:\n+\tcase CTF_K_STRUCT:\n+\tcase CTF_K_UNION:\n+\tcase CTF_K_ENUM:\n+\tcase CTF_K_UNKNOWN:\n+\t  if (size <= CTF_MAX_SIZE)\n+\t    t2p->ctt_size = size;\n+\t  else\n+\t    {\n+\t      t2p->ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n+\t      t2p->ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n+\t    }\n+\t  break;\n+\t}\n+\n+      v2size = get_ctt_size_v2 (fp, t2p, NULL, &v2increment);\n+      v2bytes = get_vbytes_v2 (kind, v2size, vlen);\n+\n+      /* Catch out-of-sync get_ctt_size_*().  The count goes wrong if\n+\t these are not identical (and having them different makes no\n+\t sense semantically).  */\n+\n+      assert (size == v2size);\n+\n+      /* Now the varlen info.  */\n+\n+      vdata = (void *) ((uintptr_t) tp + increment);\n+      v2data = (void *) ((uintptr_t) t2p + v2increment);\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_ARRAY:\n+\t  {\n+\t    const ctf_array_v1_t *ap = (const ctf_array_v1_t *) vdata;\n+\t    ctf_array_t *a2p = (ctf_array_t *) v2data;\n+\n+\t    a2p->cta_contents = ap->cta_contents;\n+\t    a2p->cta_index = ap->cta_index;\n+\t    a2p->cta_nelems = ap->cta_nelems;\n+\t    break;\n+\t  }\n+\tcase CTF_K_STRUCT:\n+\tcase CTF_K_UNION:\n+\t  {\n+\t    ctf_member_t tmp;\n+\t    const ctf_member_v1_t *m1 = (const ctf_member_v1_t *) vdata;\n+\t    const ctf_lmember_v1_t *lm1 = (const ctf_lmember_v1_t *) m1;\n+\t    ctf_member_t *m2 = (ctf_member_t *) v2data;\n+\t    ctf_lmember_t *lm2 = (ctf_lmember_t *) m2;\n+\t    unsigned long i;\n+\n+\t    /* We walk all four pointers forward, but only reference the two\n+\t       that are valid for the given size, to avoid quadruplicating all\n+\t       the code.  */\n+\n+\t    for (i = vlen; i != 0; i--, m1++, lm1++, m2++, lm2++)\n+\t      {\n+\t\tsize_t offset;\n+\t\tif (size < CTF_LSTRUCT_THRESH_V1)\n+\t\t  {\n+\t\t    offset = m1->ctm_offset;\n+\t\t    tmp.ctm_name = m1->ctm_name;\n+\t\t    tmp.ctm_type = m1->ctm_type;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    offset = CTF_LMEM_OFFSET (lm1);\n+\t\t    tmp.ctm_name = lm1->ctlm_name;\n+\t\t    tmp.ctm_type = lm1->ctlm_type;\n+\t\t  }\n+\t\tif (size < CTF_LSTRUCT_THRESH)\n+\t\t  {\n+\t\t    m2->ctm_name = tmp.ctm_name;\n+\t\t    m2->ctm_type = tmp.ctm_type;\n+\t\t    m2->ctm_offset = offset;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    lm2->ctlm_name = tmp.ctm_name;\n+\t\t    lm2->ctlm_type = tmp.ctm_type;\n+\t\t    lm2->ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (offset);\n+\t\t    lm2->ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (offset);\n+\t\t  }\n+\t      }\n+\t    break;\n+\t  }\n+\tcase CTF_K_FUNCTION:\n+\t  {\n+\t    unsigned long i;\n+\t    unsigned short *a1 = (unsigned short *) vdata;\n+\t    uint32_t *a2 = (uint32_t *) v2data;\n+\n+\t    for (i = vlen; i != 0; i--, a1++, a2++)\n+\t      *a2 = *a1;\n+\t  }\n+\t/* FALLTHRU */\n+\tdefault:\n+\t  /* Catch out-of-sync get_vbytes_*().  */\n+\t  assert (vbytes == v2bytes);\n+\t  memcpy (v2data, vdata, vbytes);\n+\t}\n+    }\n+\n+  /* Verify that the entire region was converted.  If not, we are either\n+     converting too much, or too little (leading to a buffer overrun either here\n+     or at read time, in init_types().) */\n+\n+  assert ((size_t) t2p - (size_t) fp->ctf_buf == new_cth->cth_stroff);\n+\n+  ctf_set_version (fp, (ctf_header_t *) ctf_base, CTF_VERSION_1_UPGRADED_3);\n+  ctf_free_base (fp, old_ctf_base, old_ctf_size);\n+  memcpy (cth, new_cth, sizeof (ctf_header_t));\n+\n+  return 0;\n+}\n+\n+/* Initialize the type ID translation table with the byte offset of each type,\n+   and initialize the hash tables of each named type.  Upgrade the type table to\n+   the latest supported representation in the process, if needed, and if this\n+   recension of libctf supports upgrading.  */\n+\n+static int\n+init_types (ctf_file_t *fp, ctf_header_t *cth)\n+{\n+  const ctf_type_t *tbuf;\n+  const ctf_type_t *tend;\n+\n+  unsigned long pop[CTF_K_MAX + 1] = { 0 };\n+  const ctf_type_t *tp;\n+  ctf_hash_t *hp;\n+  uint32_t id, dst;\n+  uint32_t *xp;\n+\n+  /* We determine whether the container is a child or a parent based on\n+     the value of cth_parname.  */\n+\n+  int child = cth->cth_parname != 0;\n+  int nlstructs = 0, nlunions = 0;\n+  int err;\n+\n+  if (_libctf_unlikely_ (fp->ctf_version == CTF_VERSION_1))\n+    {\n+      int err;\n+      if ((err = upgrade_types (fp, cth)) != 0)\n+\treturn err;\t\t\t\t/* Upgrade failed.  */\n+    }\n+\n+  tbuf = (ctf_type_t *) (fp->ctf_buf + cth->cth_typeoff);\n+  tend = (ctf_type_t *) (fp->ctf_buf + cth->cth_stroff);\n+\n+  /* We make two passes through the entire type section.  In this first\n+     pass, we count the number of each type and the total number of types.  */\n+\n+  for (tp = tbuf; tp < tend; fp->ctf_typemax++)\n+    {\n+      unsigned short kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n+      unsigned long vlen = LCTF_INFO_VLEN (fp, tp->ctt_info);\n+      ssize_t size, increment, vbytes;\n+\n+      (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n+      vbytes = LCTF_VBYTES (fp, kind, size, vlen);\n+\n+      if (vbytes < 0)\n+\treturn ECTF_CORRUPT;\n+\n+      if (kind == CTF_K_FORWARD)\n+\t{\n+\t  /* For forward declarations, ctt_type is the CTF_K_* kind for the tag,\n+\t     so bump that population count too.  If ctt_type is unknown, treat\n+\t     the tag as a struct.  */\n+\n+\t  if (tp->ctt_type == CTF_K_UNKNOWN || tp->ctt_type >= CTF_K_MAX)\n+\t    pop[CTF_K_STRUCT]++;\n+\t  else\n+\t    pop[tp->ctt_type]++;\n+\t}\n+      tp = (ctf_type_t *) ((uintptr_t) tp + increment + vbytes);\n+      pop[kind]++;\n+    }\n+\n+  if (child)\n+    {\n+      ctf_dprintf (\"CTF container %p is a child\\n\", (void *) fp);\n+      fp->ctf_flags |= LCTF_CHILD;\n+    }\n+  else\n+    ctf_dprintf (\"CTF container %p is a parent\\n\", (void *) fp);\n+\n+  /* Now that we've counted up the number of each type, we can allocate\n+     the hash tables, type translation table, and pointer table.  */\n+\n+  if ((fp->ctf_structs = ctf_hash_create (pop[CTF_K_STRUCT], ctf_hash_string,\n+\t\t\t\t\t  ctf_hash_eq_string)) == NULL)\n+    return ENOMEM;\n+\n+  if ((fp->ctf_unions = ctf_hash_create (pop[CTF_K_UNION], ctf_hash_string,\n+\t\t\t\t\t ctf_hash_eq_string)) == NULL)\n+    return ENOMEM;\n+\n+  if ((fp->ctf_enums = ctf_hash_create (pop[CTF_K_ENUM], ctf_hash_string,\n+\t\t\t\t\tctf_hash_eq_string)) == NULL)\n+    return ENOMEM;\n+\n+  if ((fp->ctf_names = ctf_hash_create (pop[CTF_K_INTEGER] +\n+\t\t\t\t\tpop[CTF_K_FLOAT] +\n+\t\t\t\t\tpop[CTF_K_FUNCTION] +\n+\t\t\t\t\tpop[CTF_K_TYPEDEF] +\n+\t\t\t\t\tpop[CTF_K_POINTER] +\n+\t\t\t\t\tpop[CTF_K_VOLATILE] +\n+\t\t\t\t\tpop[CTF_K_CONST] +\n+\t\t\t\t\tpop[CTF_K_RESTRICT],\n+\t\t\t\t\tctf_hash_string,\n+\t\t\t\t\tctf_hash_eq_string)) == NULL)\n+    return ENOMEM;\n+\n+  fp->ctf_txlate = ctf_alloc (sizeof (uint32_t) * (fp->ctf_typemax + 1));\n+  fp->ctf_ptrtab = ctf_alloc (sizeof (uint32_t) * (fp->ctf_typemax + 1));\n+\n+  if (fp->ctf_txlate == NULL || fp->ctf_ptrtab == NULL)\n+    return ENOMEM;\t\t/* Memory allocation failed.  */\n+\n+  xp = fp->ctf_txlate;\n+  *xp++ = 0;\t\t\t/* Type id 0 is used as a sentinel value.  */\n+\n+  memset (fp->ctf_txlate, 0, sizeof (uint32_t) * (fp->ctf_typemax + 1));\n+  memset (fp->ctf_ptrtab, 0, sizeof (uint32_t) * (fp->ctf_typemax + 1));\n+\n+  /* In the second pass through the types, we fill in each entry of the\n+     type and pointer tables and add names to the appropriate hashes.  */\n+\n+  for (id = 1, tp = tbuf; tp < tend; xp++, id++)\n+    {\n+      unsigned short kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n+      unsigned short flag = LCTF_INFO_ISROOT (fp, tp->ctt_info);\n+      unsigned long vlen = LCTF_INFO_VLEN (fp, tp->ctt_info);\n+      ssize_t size, increment, vbytes;\n+\n+      const char *name;\n+\n+      (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n+      name = ctf_strptr (fp, tp->ctt_name);\n+      vbytes = LCTF_VBYTES (fp, kind, size, vlen);\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_INTEGER:\n+\tcase CTF_K_FLOAT:\n+\t  /* Names are reused by bit-fields, which are differentiated by their\n+\t     encodings, and so typically we'd record only the first instance of\n+\t     a given intrinsic.  However, we replace an existing type with a\n+\t     root-visible version so that we can be sure to find it when\n+\t     checking for conflicting definitions in ctf_add_type().  */\n+\n+\t  if (((ctf_hash_lookup_type (fp->ctf_names, fp, name)) == 0)\n+\t      || (flag & CTF_ADD_ROOT))\n+\t    {\n+\t      err = ctf_hash_define_type (fp->ctf_names, fp,\n+\t\t\t\t\t  LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t\t  tp->ctt_name);\n+\t      if (err != 0 && err != ECTF_STRTAB)\n+\t\treturn err;\n+\t    }\n+\t  break;\n+\n+\t  /* These kinds have no name, so do not need interning into any\n+\t     hashtables.  */\n+\tcase CTF_K_ARRAY:\n+\tcase CTF_K_SLICE:\n+\t  break;\n+\n+\tcase CTF_K_FUNCTION:\n+\t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n+\t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t      tp->ctt_name);\n+\t  if (err != 0 && err != ECTF_STRTAB)\n+\t    return err;\n+\t  break;\n+\n+\tcase CTF_K_STRUCT:\n+\t  err = ctf_hash_define_type (fp->ctf_structs, fp,\n+\t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t      tp->ctt_name);\n+\n+\t  if (err != 0 && err != ECTF_STRTAB)\n+\t    return err;\n+\n+\t  if (size >= CTF_LSTRUCT_THRESH)\n+\t    nlstructs++;\n+\t  break;\n+\n+\tcase CTF_K_UNION:\n+\t  err = ctf_hash_define_type (fp->ctf_unions, fp,\n+\t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t      tp->ctt_name);\n+\n+\t  if (err != 0 && err != ECTF_STRTAB)\n+\t    return err;\n+\n+\t  if (size >= CTF_LSTRUCT_THRESH)\n+\t    nlunions++;\n+\t  break;\n+\n+\tcase CTF_K_ENUM:\n+\t  err = ctf_hash_define_type (fp->ctf_enums, fp,\n+\t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t      tp->ctt_name);\n+\n+\t  if (err != 0 && err != ECTF_STRTAB)\n+\t    return err;\n+\t  break;\n+\n+\tcase CTF_K_TYPEDEF:\n+\t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n+\t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t      tp->ctt_name);\n+\t  if (err != 0 && err != ECTF_STRTAB)\n+\t    return err;\n+\t  break;\n+\n+\tcase CTF_K_FORWARD:\n+\t  /* Only insert forward tags into the given hash if the type or tag\n+\t     name is not already present.  */\n+\t  switch (tp->ctt_type)\n+\t    {\n+\t    case CTF_K_STRUCT:\n+\t      hp = fp->ctf_structs;\n+\t      break;\n+\t    case CTF_K_UNION:\n+\t      hp = fp->ctf_unions;\n+\t      break;\n+\t    case CTF_K_ENUM:\n+\t      hp = fp->ctf_enums;\n+\t      break;\n+\t    default:\n+\t      hp = fp->ctf_structs;\n+\t    }\n+\n+\t  if (ctf_hash_lookup_type (hp, fp, name) == 0)\n+\t    {\n+\t      err = ctf_hash_insert_type (hp, fp,\n+\t\t\t\t\t  LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t\t  tp->ctt_name);\n+\t      if (err != 0 && err != ECTF_STRTAB)\n+\t\treturn err;\n+\t    }\n+\t  break;\n+\n+\tcase CTF_K_POINTER:\n+\t  /* If the type referenced by the pointer is in this CTF container,\n+\t     then store the index of the pointer type in\n+\t     fp->ctf_ptrtab[ index of referenced type ].  */\n+\n+\t  if (LCTF_TYPE_ISCHILD (fp, tp->ctt_type) == child\n+\t      && LCTF_TYPE_TO_INDEX (fp, tp->ctt_type) <= fp->ctf_typemax)\n+\t    fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, tp->ctt_type)] = id;\n+\t /*FALLTHRU*/\n+\n+\tcase CTF_K_VOLATILE:\n+\tcase CTF_K_CONST:\n+\tcase CTF_K_RESTRICT:\n+\t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n+\t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t      tp->ctt_name);\n+\t  if (err != 0 && err != ECTF_STRTAB)\n+\t    return err;\n+\t  break;\n+\t}\n+\n+      *xp = (uint32_t) ((uintptr_t) tp - (uintptr_t) fp->ctf_buf);\n+      tp = (ctf_type_t *) ((uintptr_t) tp + increment + vbytes);\n+    }\n+\n+  ctf_dprintf (\"%lu total types processed\\n\", fp->ctf_typemax);\n+  ctf_dprintf (\"%u enum names hashed\\n\", ctf_hash_size (fp->ctf_enums));\n+  ctf_dprintf (\"%u struct names hashed (%d long)\\n\",\n+\t       ctf_hash_size (fp->ctf_structs), nlstructs);\n+  ctf_dprintf (\"%u union names hashed (%d long)\\n\",\n+\t       ctf_hash_size (fp->ctf_unions), nlunions);\n+  ctf_dprintf (\"%u base type names hashed\\n\", ctf_hash_size (fp->ctf_names));\n+\n+  /* Make an additional pass through the pointer table to find pointers that\n+     point to anonymous typedef nodes.  If we find one, modify the pointer table\n+     so that the pointer is also known to point to the node that is referenced\n+     by the anonymous typedef node.  */\n+\n+  for (id = 1; id <= fp->ctf_typemax; id++)\n+    {\n+      if ((dst = fp->ctf_ptrtab[id]) != 0)\n+\t{\n+\t  tp = LCTF_INDEX_TO_TYPEPTR (fp, id);\n+\n+\t  if (LCTF_INFO_KIND (fp, tp->ctt_info) == CTF_K_TYPEDEF &&\n+\t      strcmp (ctf_strptr (fp, tp->ctt_name), \"\") == 0 &&\n+\t      LCTF_TYPE_ISCHILD (fp, tp->ctt_type) == child &&\n+\t      LCTF_TYPE_TO_INDEX (fp, tp->ctt_type) <= fp->ctf_typemax)\n+\t    fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, tp->ctt_type)] = dst;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Endianness-flipping routines.\n+\n+   We flip everything, mindlessly, even 1-byte entities, so that future\n+   expansions do not require changes to this code.  */\n+\n+/* < C11? define away static assertions.  */\n+\n+#if !defined (__STDC_VERSION__) || __STDC_VERSION__ < 201112L\n+#define _Static_assert(cond, err)\n+#endif\n+\n+/* Swap the endianness of something.  */\n+\n+#define swap_thing(x)\t\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _Static_assert (sizeof (x) == 1 || (sizeof (x) % 2 == 0\t\t\\\n+\t\t\t\t\t&& sizeof (x) <= 8),\t\t\\\n+\t\t    \"Invalid size, update endianness code\");\t\t\\\n+    switch (sizeof (x)) {\t\t\t\t\t\t\\\n+    case 2: x = bswap_16 (x); break;\t\t\t\t\t\\\n+    case 4: x = bswap_32 (x); break;\t\t\t\t\t\\\n+    case 8: x = bswap_64 (x); break;\t\t\t\t\t\\\n+    case 1: /* Nothing needs doing */\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  } while (0);\n+\n+/* Flip the endianness of the CTF header.  */\n+\n+static void\n+flip_header (ctf_header_t *cth)\n+{\n+  swap_thing (cth->cth_preamble.ctp_magic);\n+  swap_thing (cth->cth_preamble.ctp_version);\n+  swap_thing (cth->cth_preamble.ctp_flags);\n+  swap_thing (cth->cth_parlabel);\n+  swap_thing (cth->cth_parname);\n+  swap_thing (cth->cth_objtoff);\n+  swap_thing (cth->cth_funcoff);\n+  swap_thing (cth->cth_varoff);\n+  swap_thing (cth->cth_typeoff);\n+  swap_thing (cth->cth_stroff);\n+  swap_thing (cth->cth_strlen);\n+}\n+\n+/* Flip the endianness of the label section, an array of ctf_lblent_t.  */\n+\n+static void\n+flip_lbls (void *start, size_t len)\n+{\n+  ctf_lblent_t *lbl = start;\n+\n+  for (ssize_t i = len / sizeof (struct ctf_lblent); i > 0; lbl++, i--)\n+    {\n+      swap_thing (lbl->ctl_label);\n+      swap_thing (lbl->ctl_type);\n+    }\n+}\n+\n+/* Flip the endianness of the data-object or function sections, an array of\n+   uint32_t.  (The function section has more internal structure, but that\n+   structure is an array of uint32_t, so can be treated as one big array for\n+   byte-swapping.)  */\n+\n+static void\n+flip_objts (void *start, size_t len)\n+{\n+  uint32_t *obj = start;\n+\n+  for (ssize_t i = len / sizeof (uint32_t); i > 0; obj++, i--)\n+      swap_thing (*obj);\n+}\n+\n+/* Flip the endianness of the variable section, an array of ctf_varent_t.  */\n+\n+static void\n+flip_vars (void *start, size_t len)\n+{\n+  ctf_varent_t *var = start;\n+\n+  for (ssize_t i = len / sizeof (struct ctf_varent); i > 0; var++, i--)\n+    {\n+      swap_thing (var->ctv_name);\n+      swap_thing (var->ctv_type);\n+    }\n+}\n+\n+/* Flip the endianness of the type section, a tagged array of ctf_type or\n+   ctf_stype followed by variable data.  */\n+\n+static int\n+flip_types (void *start, size_t len)\n+{\n+  ctf_type_t *t = start;\n+\n+  while ((uintptr_t) t < ((uintptr_t) start) + len)\n+    {\n+      swap_thing (t->ctt_name);\n+      swap_thing (t->ctt_info);\n+      swap_thing (t->ctt_size);\n+\n+      uint32_t kind = CTF_V2_INFO_KIND (t->ctt_info);\n+      size_t size = t->ctt_size;\n+      uint32_t vlen = CTF_V2_INFO_VLEN (t->ctt_info);\n+      size_t vbytes = get_vbytes_v2 (kind, size, vlen);\n+\n+      if (_libctf_unlikely_ (size == CTF_LSIZE_SENT))\n+\t{\n+\t  swap_thing (t->ctt_lsizehi);\n+\t  swap_thing (t->ctt_lsizelo);\n+\t  size = CTF_TYPE_LSIZE (t);\n+\t  t = (ctf_type_t *) ((uintptr_t) t + sizeof (ctf_type_t));\n+\t}\n+      else\n+\tt = (ctf_type_t *) ((uintptr_t) t + sizeof (ctf_stype_t));\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_FORWARD:\n+\tcase CTF_K_UNKNOWN:\n+\tcase CTF_K_POINTER:\n+\tcase CTF_K_TYPEDEF:\n+\tcase CTF_K_VOLATILE:\n+\tcase CTF_K_CONST:\n+\tcase CTF_K_RESTRICT:\n+\t  /* These types have no vlen data to swap.  */\n+\t  assert (vbytes == 0);\n+\t  break;\n+\n+\tcase CTF_K_INTEGER:\n+\tcase CTF_K_FLOAT:\n+\t  {\n+\t    /* These types have a single uint32_t.  */\n+\n+\t    uint32_t *item = (uint32_t *) t;\n+\n+\t    swap_thing (*item);\n+\t    break;\n+\t  }\n+\n+\tcase CTF_K_FUNCTION:\n+\t  {\n+\t    /* This type has a bunch of uint32_ts.  */\n+\n+\t    uint32_t *item = (uint32_t *) t;\n+\n+\t    for (ssize_t i = vlen; i > 0; item++, i--)\n+\t      swap_thing (*item);\n+\t    break;\n+\t  }\n+\n+\tcase CTF_K_ARRAY:\n+\t  {\n+\t    /* This has a single ctf_array_t.  */\n+\n+\t    ctf_array_t *a = (ctf_array_t *) t;\n+\n+\t    assert (vbytes == sizeof (ctf_array_t));\n+\t    swap_thing (a->cta_contents);\n+\t    swap_thing (a->cta_index);\n+\t    swap_thing (a->cta_nelems);\n+\n+\t    break;\n+\t  }\n+\n+\tcase CTF_K_SLICE:\n+\t  {\n+\t    /* This has a single ctf_slice_t.  */\n+\n+\t    ctf_slice_t *s = (ctf_slice_t *) t;\n+\n+\t    assert (vbytes == sizeof (ctf_slice_t));\n+\t    swap_thing (s->cts_type);\n+\t    swap_thing (s->cts_offset);\n+\t    swap_thing (s->cts_bits);\n+\n+\t    break;\n+\t  }\n+\n+\tcase CTF_K_STRUCT:\n+\tcase CTF_K_UNION:\n+\t  {\n+\t    /* This has an array of ctf_member or ctf_lmember, depending on\n+\t       size.  We could consider it to be a simple array of uint32_t,\n+\t       but for safety's sake in case these structures ever acquire\n+\t       non-uint32_t members, do it member by member.  */\n+\n+\t    if (_libctf_unlikely_ (size >= CTF_LSTRUCT_THRESH))\n+\t      {\n+\t\tctf_lmember_t *lm = (ctf_lmember_t *) t;\n+\t\tfor (ssize_t i = vlen; i > 0; i--, lm++)\n+\t\t  {\n+\t\t    swap_thing (lm->ctlm_name);\n+\t\t    swap_thing (lm->ctlm_offsethi);\n+\t\t    swap_thing (lm->ctlm_type);\n+\t\t    swap_thing (lm->ctlm_offsetlo);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tctf_member_t *m = (ctf_member_t *) t;\n+\t\tfor (ssize_t i = vlen; i > 0; i--, m++)\n+\t\t  {\n+\t\t    swap_thing (m->ctm_name);\n+\t\t    swap_thing (m->ctm_offset);\n+\t\t    swap_thing (m->ctm_type);\n+\t\t  }\n+\t      }\n+\t    break;\n+\t  }\n+\n+\tcase CTF_K_ENUM:\n+\t  {\n+\t    /* This has an array of ctf_enum_t.  */\n+\n+\t    ctf_enum_t *item = (ctf_enum_t *) t;\n+\n+\t    for (ssize_t i = vlen; i > 0; item++, i--)\n+\t      {\n+\t\tswap_thing (item->cte_name);\n+\t\tswap_thing (item->cte_value);\n+\t      }\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  ctf_dprintf (\"unhandled CTF kind in endianness conversion -- %x\\n\",\n+\t\t       kind);\n+\t  return ECTF_CORRUPT;\n+\t}\n+\n+      t = (ctf_type_t *) ((uintptr_t) t + vbytes);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Flip the endianness of BASE, given the offsets in the (already endian-\n+   converted) CTH.\n+\n+   All of this stuff happens before the header is fully initialized, so the\n+   LCTF_*() macros cannot be used yet.  Since we do not try to endian-convert v1\n+   data, this is no real loss.  */\n+\n+static int\n+flip_ctf (ctf_header_t *cth, unsigned char *base)\n+{\n+  base += sizeof (ctf_header_t);\n+\n+  flip_lbls (base + cth->cth_lbloff, cth->cth_objtoff - cth->cth_lbloff);\n+  flip_objts (base + cth->cth_objtoff, cth->cth_funcoff - cth->cth_objtoff);\n+  flip_objts (base + cth->cth_funcoff, cth->cth_varoff - cth->cth_funcoff);\n+  flip_vars (base + cth->cth_varoff, cth->cth_typeoff - cth->cth_varoff);\n+  return flip_types (base + cth->cth_typeoff, cth->cth_stroff - cth->cth_typeoff);\n+}\n+\n+/* Open a CTF file, mocking up a suitable ctf_sect.  */\n+ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n+\t\t\t     const char *symsect, size_t symsect_size,\n+\t\t\t     size_t symsect_entsize,\n+\t\t\t     const char *strsect, size_t strsect_size,\n+\t\t\t     int *errp)\n+{\n+  ctf_sect_t skeleton;\n+\n+  ctf_sect_t ctf_sect, sym_sect, str_sect;\n+  ctf_sect_t *ctfsectp = NULL;\n+  ctf_sect_t *symsectp = NULL;\n+  ctf_sect_t *strsectp = NULL;\n+\n+  skeleton.cts_name = _CTF_SECTION;\n+  skeleton.cts_type = SHT_PROGBITS;\n+  skeleton.cts_flags = 0;\n+  skeleton.cts_entsize = 1;\n+  skeleton.cts_offset = 0;\n+\n+  if (ctfsect)\n+    {\n+      memcpy (&ctf_sect, &skeleton, sizeof (struct ctf_sect));\n+      ctf_sect.cts_data = ctfsect;\n+      ctf_sect.cts_size = ctfsect_size;\n+      ctfsectp = &ctf_sect;\n+    }\n+\n+  if (symsect)\n+    {\n+      memcpy (&sym_sect, &skeleton, sizeof (struct ctf_sect));\n+      sym_sect.cts_data = symsect;\n+      sym_sect.cts_size = symsect_size;\n+      sym_sect.cts_entsize = symsect_entsize;\n+      symsectp = &sym_sect;\n+    }\n+\n+  if (strsect)\n+    {\n+      memcpy (&str_sect, &skeleton, sizeof (struct ctf_sect));\n+      str_sect.cts_data = strsect;\n+      str_sect.cts_size = strsect_size;\n+      strsectp = &str_sect;\n+    }\n+\n+  return ctf_bufopen (ctfsectp, symsectp, strsectp, errp);\n+}\n+\n+/* Decode the specified CTF buffer and optional symbol table, and create a new\n+   CTF container representing the symbolic debugging information.  This code can\n+   be used directly by the debugger, or it can be used as the engine for\n+   ctf_fdopen() or ctf_open(), below.  */\n+\n+ctf_file_t *\n+ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n+\t     const ctf_sect_t *strsect, int *errp)\n+{\n+  const ctf_preamble_t *pp;\n+  ctf_header_t hp;\n+  ctf_file_t *fp;\n+  void *buf, *base;\n+  size_t size, hdrsz;\n+  int foreign_endian = 0;\n+  int err;\n+\n+  libctf_init_debug();\n+\n+  if (ctfsect == NULL || ((symsect == NULL) != (strsect == NULL)))\n+    return (ctf_set_open_errno (errp, EINVAL));\n+\n+  if (symsect != NULL && symsect->cts_entsize != sizeof (Elf32_Sym) &&\n+      symsect->cts_entsize != sizeof (Elf64_Sym))\n+    return (ctf_set_open_errno (errp, ECTF_SYMTAB));\n+\n+  if (symsect != NULL && symsect->cts_data == NULL)\n+    return (ctf_set_open_errno (errp, ECTF_SYMBAD));\n+\n+  if (strsect != NULL && strsect->cts_data == NULL)\n+    return (ctf_set_open_errno (errp, ECTF_STRBAD));\n+\n+  if (ctfsect->cts_size < sizeof (ctf_preamble_t))\n+    return (ctf_set_open_errno (errp, ECTF_NOCTFBUF));\n+\n+  pp = (const ctf_preamble_t *) ctfsect->cts_data;\n+\n+  ctf_dprintf (\"ctf_bufopen: magic=0x%x version=%u\\n\",\n+\t       pp->ctp_magic, pp->ctp_version);\n+\n+  /* Validate each part of the CTF header.\n+\n+     First, we validate the preamble (common to all versions).  At that point,\n+     we know the endianness and specific header version, and can validate the\n+     version-specific parts including section offsets and alignments.\n+\n+     We specifically do not support foreign-endian old versions.  */\n+\n+  if (_libctf_unlikely_ (pp->ctp_magic != CTF_MAGIC))\n+    {\n+      if (pp->ctp_magic == bswap_16 (CTF_MAGIC))\n+\t{\n+\t  if (pp->ctp_version != CTF_VERSION_3)\n+\t    return (ctf_set_open_errno (errp, ECTF_CTFVERS));\n+\t  foreign_endian = 1;\n+\t}\n+      else\n+\treturn (ctf_set_open_errno (errp, ECTF_NOCTFBUF));\n+    }\n+\n+  if (_libctf_unlikely_ ((pp->ctp_version < CTF_VERSION_1)\n+\t\t\t || (pp->ctp_version > CTF_VERSION_3)))\n+    return (ctf_set_open_errno (errp, ECTF_CTFVERS));\n+\n+  if ((symsect != NULL) && (pp->ctp_version < CTF_VERSION_2))\n+    {\n+      /* The symtab can contain function entries which contain embedded ctf\n+\t info.  We do not support dynamically upgrading such entries (none\n+\t should exist in any case, since dwarf2ctf does not create them).  */\n+\n+      ctf_dprintf (\"ctf_bufopen: CTF version %d symsect not \"\n+\t\t   \"supported\\n\", pp->ctp_version);\n+      return (ctf_set_open_errno (errp, ECTF_NOTSUP));\n+    }\n+\n+  if (ctfsect->cts_size < sizeof (ctf_header_t))\n+    return (ctf_set_open_errno (errp, ECTF_NOCTFBUF));\n+\n+  memcpy (&hp, ctfsect->cts_data, sizeof (hp));\n+\n+  if (foreign_endian)\n+    flip_header (&hp);\n+\n+  hdrsz = sizeof (ctf_header_t);\n+\n+  size = hp.cth_stroff + hp.cth_strlen;\n+\n+  ctf_dprintf (\"ctf_bufopen: uncompressed size=%lu\\n\", (unsigned long) size);\n+\n+  if (hp.cth_lbloff > size || hp.cth_objtoff > size\n+      || hp.cth_funcoff > size || hp.cth_typeoff > size || hp.cth_stroff > size)\n+    return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+\n+  if (hp.cth_lbloff > hp.cth_objtoff\n+      || hp.cth_objtoff > hp.cth_funcoff\n+      || hp.cth_funcoff > hp.cth_typeoff\n+      || hp.cth_funcoff > hp.cth_varoff\n+      || hp.cth_varoff > hp.cth_typeoff || hp.cth_typeoff > hp.cth_stroff)\n+    return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+\n+  if ((hp.cth_lbloff & 3) || (hp.cth_objtoff & 1)\n+      || (hp.cth_funcoff & 1) || (hp.cth_varoff & 3) || (hp.cth_typeoff & 3))\n+    return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+\n+  /* Once everything is determined to be valid, attempt to decompress the CTF\n+     data buffer if it is compressed, or copy it into new storage if it is not\n+     compressed but needs endian-flipping.  Otherwise we just put the data\n+     section's buffer pointer into ctf_buf, below.  */\n+\n+  /* Note: if this is a v1 buffer, it will be reallocated and expanded by\n+     init_types().  */\n+\n+  if (hp.cth_flags & CTF_F_COMPRESS)\n+    {\n+      size_t srclen, dstlen;\n+      const void *src;\n+      int rc = Z_OK;\n+\n+      if ((base = ctf_data_alloc (size + hdrsz)) == NULL)\n+\treturn (ctf_set_open_errno (errp, ECTF_ZALLOC));\n+\n+      memcpy (base, ctfsect->cts_data, hdrsz);\n+      ((ctf_preamble_t *) base)->ctp_flags &= ~CTF_F_COMPRESS;\n+      buf = (unsigned char *) base + hdrsz;\n+\n+      src = (unsigned char *) ctfsect->cts_data + hdrsz;\n+      srclen = ctfsect->cts_size - hdrsz;\n+      dstlen = size;\n+\n+      if ((rc = uncompress (buf, &dstlen, src, srclen)) != Z_OK)\n+\t{\n+\t  ctf_dprintf (\"zlib inflate err: %s\\n\", zError (rc));\n+\t  ctf_data_free (base, size + hdrsz);\n+\t  return (ctf_set_open_errno (errp, ECTF_DECOMPRESS));\n+\t}\n+\n+      if (dstlen != size)\n+\t{\n+\t  ctf_dprintf (\"zlib inflate short -- got %lu of %lu \"\n+\t\t       \"bytes\\n\", (unsigned long) dstlen, (unsigned long) size);\n+\t  ctf_data_free (base, size + hdrsz);\n+\t  return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+\t}\n+\n+    }\n+  else if (foreign_endian)\n+    {\n+      if ((base = ctf_data_alloc (size + hdrsz)) == NULL)\n+\treturn (ctf_set_open_errno (errp, ECTF_ZALLOC));\n+    }\n+  else\n+    {\n+      base = (void *) ctfsect->cts_data;\n+      buf = (unsigned char *) base + hdrsz;\n+    }\n+\n+  /* Once we have uncompressed and validated the CTF data buffer, we can\n+     proceed with allocating a ctf_file_t and initializing it.\n+\n+     Nothing that depends on buf or base should be set directly in this function\n+     before the init_types() call, because it may be reallocated during\n+     transparent upgrade if this recension of libctf is so configured: see\n+     ctf_set_base() and ctf_realloc_base().  */\n+\n+  if ((fp = ctf_alloc (sizeof (ctf_file_t))) == NULL)\n+    return (ctf_set_open_errno (errp, ENOMEM));\n+\n+  memset (fp, 0, sizeof (ctf_file_t));\n+  ctf_set_version (fp, &hp, hp.cth_version);\n+\n+  if (_libctf_unlikely_ (hp.cth_version < CTF_VERSION_2))\n+    fp->ctf_parmax = CTF_MAX_PTYPE_V1;\n+  else\n+    fp->ctf_parmax = CTF_MAX_PTYPE;\n+\n+  memcpy (&fp->ctf_data, ctfsect, sizeof (ctf_sect_t));\n+\n+  if (symsect != NULL)\n+    {\n+      memcpy (&fp->ctf_symtab, symsect, sizeof (ctf_sect_t));\n+      memcpy (&fp->ctf_strtab, strsect, sizeof (ctf_sect_t));\n+    }\n+\n+  if (fp->ctf_data.cts_name != NULL)\n+    fp->ctf_data.cts_name = ctf_strdup (fp->ctf_data.cts_name);\n+  if (fp->ctf_symtab.cts_name != NULL)\n+    fp->ctf_symtab.cts_name = ctf_strdup (fp->ctf_symtab.cts_name);\n+  if (fp->ctf_strtab.cts_name != NULL)\n+    fp->ctf_strtab.cts_name = ctf_strdup (fp->ctf_strtab.cts_name);\n+\n+  if (fp->ctf_data.cts_name == NULL)\n+    fp->ctf_data.cts_name = _CTF_NULLSTR;\n+  if (fp->ctf_symtab.cts_name == NULL)\n+    fp->ctf_symtab.cts_name = _CTF_NULLSTR;\n+  if (fp->ctf_strtab.cts_name == NULL)\n+    fp->ctf_strtab.cts_name = _CTF_NULLSTR;\n+\n+  if (strsect != NULL)\n+    {\n+      fp->ctf_str[CTF_STRTAB_1].cts_strs = strsect->cts_data;\n+      fp->ctf_str[CTF_STRTAB_1].cts_len = strsect->cts_size;\n+    }\n+\n+  if (foreign_endian &&\n+      (err = flip_ctf (&hp, base)) != 0)\n+    {\n+      /* We can be certain that flip_ctf() will have endian-flipped everything\n+         other than the types table when we return.  In particular the header\n+         is fine, so set it, to allow freeing to use the usual code path.  */\n+\n+      (void) ctf_set_open_errno (errp, err);\n+      ctf_set_base (fp, &hp, base);\n+      goto bad;\n+    }\n+\n+  ctf_set_base (fp, &hp, base);\n+  fp->ctf_size = size + hdrsz;\n+\n+  if ((err = init_types (fp, &hp)) != 0)\n+    {\n+      (void) ctf_set_open_errno (errp, err);\n+      goto bad;\n+    }\n+\n+  /* The ctf region may have been reallocated by init_types(), but now\n+     that is done, it will not move again, so we can protect it, as long\n+     as it didn't come from the ctfsect, which might have been allocated\n+     with malloc().  */\n+\n+  if (fp->ctf_base != (void *) ctfsect->cts_data)\n+    ctf_data_protect ((void *) fp->ctf_base, fp->ctf_size);\n+\n+  /* If we have a symbol table section, allocate and initialize\n+     the symtab translation table, pointed to by ctf_sxlate.  */\n+\n+  if (symsect != NULL)\n+    {\n+      fp->ctf_nsyms = symsect->cts_size / symsect->cts_entsize;\n+      fp->ctf_sxlate = ctf_alloc (fp->ctf_nsyms * sizeof (uint32_t));\n+\n+      if (fp->ctf_sxlate == NULL)\n+\t{\n+\t  (void) ctf_set_open_errno (errp, ENOMEM);\n+\t  goto bad;\n+\t}\n+\n+      if ((err = init_symtab (fp, &hp, symsect, strsect)) != 0)\n+\t{\n+\t  (void) ctf_set_open_errno (errp, err);\n+\t  goto bad;\n+\t}\n+    }\n+\n+  /* Initialize the ctf_lookup_by_name top-level dictionary.  We keep an\n+     array of type name prefixes and the corresponding ctf_hash to use.\n+     NOTE: This code must be kept in sync with the code in ctf_update().  */\n+  fp->ctf_lookups[0].ctl_prefix = \"struct\";\n+  fp->ctf_lookups[0].ctl_len = strlen (fp->ctf_lookups[0].ctl_prefix);\n+  fp->ctf_lookups[0].ctl_hash = fp->ctf_structs;\n+  fp->ctf_lookups[1].ctl_prefix = \"union\";\n+  fp->ctf_lookups[1].ctl_len = strlen (fp->ctf_lookups[1].ctl_prefix);\n+  fp->ctf_lookups[1].ctl_hash = fp->ctf_unions;\n+  fp->ctf_lookups[2].ctl_prefix = \"enum\";\n+  fp->ctf_lookups[2].ctl_len = strlen (fp->ctf_lookups[2].ctl_prefix);\n+  fp->ctf_lookups[2].ctl_hash = fp->ctf_enums;\n+  fp->ctf_lookups[3].ctl_prefix = _CTF_NULLSTR;\n+  fp->ctf_lookups[3].ctl_len = strlen (fp->ctf_lookups[3].ctl_prefix);\n+  fp->ctf_lookups[3].ctl_hash = fp->ctf_names;\n+  fp->ctf_lookups[4].ctl_prefix = NULL;\n+  fp->ctf_lookups[4].ctl_len = 0;\n+  fp->ctf_lookups[4].ctl_hash = NULL;\n+\n+  if (symsect != NULL)\n+    {\n+      if (symsect->cts_entsize == sizeof (Elf64_Sym))\n+\t(void) ctf_setmodel (fp, CTF_MODEL_LP64);\n+      else\n+\t(void) ctf_setmodel (fp, CTF_MODEL_ILP32);\n+    }\n+  else\n+    (void) ctf_setmodel (fp, CTF_MODEL_NATIVE);\n+\n+  fp->ctf_refcnt = 1;\n+  return fp;\n+\n+bad:\n+  ctf_file_close (fp);\n+  return NULL;\n+}\n+\n+/* Close the specified CTF container and free associated data structures.  Note\n+   that ctf_file_close() is a reference counted operation: if the specified file\n+   is the parent of other active containers, its reference count will be greater\n+   than one and it will be freed later when no active children exist.  */\n+\n+void\n+ctf_file_close (ctf_file_t *fp)\n+{\n+  ctf_dtdef_t *dtd, *ntd;\n+  ctf_dvdef_t *dvd, *nvd;\n+\n+  if (fp == NULL)\n+    return;\t\t   /* Allow ctf_file_close(NULL) to simplify caller code.  */\n+\n+  ctf_dprintf (\"ctf_file_close(%p) refcnt=%u\\n\", (void *) fp, fp->ctf_refcnt);\n+\n+  if (fp->ctf_refcnt > 1)\n+    {\n+      fp->ctf_refcnt--;\n+      return;\n+    }\n+\n+  if (fp->ctf_dynparname != NULL)\n+    ctf_free (fp->ctf_dynparname);\n+\n+  if (fp->ctf_parent != NULL)\n+    ctf_file_close (fp->ctf_parent);\n+\n+  for (dtd = ctf_list_next (&fp->ctf_dtdefs); dtd != NULL; dtd = ntd)\n+    {\n+      ntd = ctf_list_next (dtd);\n+      ctf_dtd_delete (fp, dtd);\n+    }\n+  ctf_dynhash_destroy (fp->ctf_dthash);\n+  ctf_dynhash_destroy (fp->ctf_dtbyname);\n+\n+  for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL; dvd = nvd)\n+    {\n+      nvd = ctf_list_next (dvd);\n+      ctf_dvd_delete (fp, dvd);\n+    }\n+  ctf_dynhash_destroy (fp->ctf_dvhash);\n+\n+  ctf_free (fp->ctf_tmp_typeslice);\n+\n+  if (fp->ctf_data.cts_name != _CTF_NULLSTR &&\n+      fp->ctf_data.cts_name != NULL)\n+    ctf_free ((char *) fp->ctf_data.cts_name);\n+\n+  if (fp->ctf_symtab.cts_name != _CTF_NULLSTR &&\n+      fp->ctf_symtab.cts_name != NULL)\n+    ctf_free ((char *) fp->ctf_symtab.cts_name);\n+\n+  if (fp->ctf_strtab.cts_name != _CTF_NULLSTR &&\n+      fp->ctf_strtab.cts_name != NULL)\n+    ctf_free ((char *) fp->ctf_strtab.cts_name);\n+\n+  else if (fp->ctf_data_mmapped)\n+    ctf_munmap (fp->ctf_data_mmapped, fp->ctf_data_mmapped_len);\n+\n+  ctf_free_base (fp, NULL, 0);\n+\n+  if (fp->ctf_sxlate != NULL)\n+    ctf_free (fp->ctf_sxlate);\n+\n+  if (fp->ctf_txlate != NULL)\n+    ctf_free (fp->ctf_txlate);\n+\n+  if (fp->ctf_ptrtab != NULL)\n+    ctf_free (fp->ctf_ptrtab);\n+\n+  ctf_hash_destroy (fp->ctf_structs);\n+  ctf_hash_destroy (fp->ctf_unions);\n+  ctf_hash_destroy (fp->ctf_enums);\n+  ctf_hash_destroy (fp->ctf_names);\n+\n+  ctf_free (fp);\n+}\n+\n+/* Return the ctfsect out of the core ctf_impl.  Useful for freeing the\n+   ctfsect's data * after ctf_file_close(), which is why we return the actual\n+   structure, not a pointer to it, since that is likely to become a pointer to\n+   freed data before the return value is used under the expected use case of\n+   ctf_getsect()/ ctf_file_close()/free().  */\n+extern ctf_sect_t\n+ctf_getdatasect (const ctf_file_t *fp)\n+{\n+  return fp->ctf_data;\n+}\n+\n+/* Return the CTF handle for the parent CTF container, if one exists.\n+   Otherwise return NULL to indicate this container has no imported parent.  */\n+ctf_file_t *\n+ctf_parent_file (ctf_file_t *fp)\n+{\n+  return fp->ctf_parent;\n+}\n+\n+/* Return the name of the parent CTF container, if one exists.  Otherwise\n+   return NULL to indicate this container is a root container.  */\n+const char *\n+ctf_parent_name (ctf_file_t *fp)\n+{\n+  return fp->ctf_parname;\n+}\n+\n+/* Set the parent name.  It is an error to call this routine without calling\n+   ctf_import() at some point.  */\n+void\n+ctf_parent_name_set (ctf_file_t *fp, const char *name)\n+{\n+  if (fp->ctf_dynparname != NULL)\n+    ctf_free (fp->ctf_dynparname);\n+\n+  fp->ctf_dynparname = ctf_strdup (name);\n+  fp->ctf_parname = fp->ctf_dynparname;\n+}\n+\n+/* Import the types from the specified parent container by storing a pointer\n+   to it in ctf_parent and incrementing its reference count.  Only one parent\n+   is allowed: if a parent already exists, it is replaced by the new parent.  */\n+int\n+ctf_import (ctf_file_t *fp, ctf_file_t *pfp)\n+{\n+  if (fp == NULL || fp == pfp || (pfp != NULL && pfp->ctf_refcnt == 0))\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if (pfp != NULL && pfp->ctf_dmodel != fp->ctf_dmodel)\n+    return (ctf_set_errno (fp, ECTF_DMODEL));\n+\n+  if (fp->ctf_parent != NULL)\n+    ctf_file_close (fp->ctf_parent);\n+\n+  if (pfp != NULL)\n+    {\n+      fp->ctf_flags |= LCTF_CHILD;\n+      pfp->ctf_refcnt++;\n+\n+      if (fp->ctf_parname == NULL)\n+\tctf_parent_name_set (fp, \"PARENT\");\n+    }\n+  fp->ctf_parent = pfp;\n+  return 0;\n+}\n+\n+/* Set the data model constant for the CTF container.  */\n+int\n+ctf_setmodel (ctf_file_t *fp, int model)\n+{\n+  const ctf_dmodel_t *dp;\n+\n+  for (dp = _libctf_models; dp->ctd_name != NULL; dp++)\n+    {\n+      if (dp->ctd_code == model)\n+\t{\n+\t  fp->ctf_dmodel = dp;\n+\t  return 0;\n+\t}\n+    }\n+\n+  return (ctf_set_errno (fp, EINVAL));\n+}\n+\n+/* Return the data model constant for the CTF container.  */\n+int\n+ctf_getmodel (ctf_file_t *fp)\n+{\n+  return fp->ctf_dmodel->ctd_code;\n+}\n+\n+void\n+ctf_setspecific (ctf_file_t *fp, void *data)\n+{\n+  fp->ctf_specific = data;\n+}\n+\n+void *\n+ctf_getspecific (ctf_file_t *fp)\n+{\n+  return fp->ctf_specific;\n+}"
    },
    {
      "sha": "06a93301813bcf76215b2605a13b9b8caac5ef74",
      "filename": "libctf/swap.h",
      "status": "added",
      "additions": 60,
      "deletions": 0,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72f3392127e1892cb203a98092b4ae32485365fe/libctf/swap.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72f3392127e1892cb203a98092b4ae32485365fe/libctf/swap.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/swap.h?ref=72f3392127e1892cb203a98092b4ae32485365fe",
      "patch": "@@ -0,0 +1,60 @@\n+/* Interface to byteswapping functions.\n+   Copyright (C) 2006-2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _CTF_SWAP_H\n+#define _CTF_SWAP_H\n+\n+#include \"config.h\"\n+#include <stdint.h>\n+\n+#ifdef HAVE_BYTESWAP_H\n+#include <byteswap.h>\n+#else\n+\n+/* Provide our own versions of the byteswap functions.  */\n+inline uint16_t\n+bswap_16(uint16_t v)\n+{\n+  return ((v >> 8) & 0xff) | ((v & 0xff) << 8);\n+}\n+\n+inline uint32_t\n+bswap_32(uint32_t v)\n+{\n+  return (  ((v & 0xff000000) >> 24)\n+\t  | ((v & 0x00ff0000) >>  8)\n+\t  | ((v & 0x0000ff00) <<  8)\n+\t  | ((v & 0x000000ff) << 24));\n+}\n+\n+inline uint64_t\n+bswap_64(uint64_t v)\n+{\n+  return (  ((v & 0xff00000000000000ULL) >> 56)\n+\t  | ((v & 0x00ff000000000000ULL) >> 40)\n+\t  | ((v & 0x0000ff0000000000ULL) >> 24)\n+\t  | ((v & 0x000000ff00000000ULL) >>  8)\n+\t  | ((v & 0x00000000ff000000ULL) <<  8)\n+\t  | ((v & 0x0000000000ff0000ULL) << 24)\n+\t  | ((v & 0x000000000000ff00ULL) << 40)\n+\t  | ((v & 0x00000000000000ffULL) << 56));\n+}\n+#endif /* !defined(HAVE_BYTESWAP_H) */\n+\n+#endif /* !defined(_CTF_SWAP_H) */"
    }
  ]
}