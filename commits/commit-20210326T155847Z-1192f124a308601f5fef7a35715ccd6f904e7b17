{
  "sha": "1192f124a308601f5fef7a35715ccd6f904e7b17",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTE5MmYxMjRhMzA4NjAxZjVmZWY3YTM1NzE1Y2NkNmY5MDRlN2IxNw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-01-25T04:57:29Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-03-26T15:58:47Z"
    },
    "message": "gdb: generalize commit_resume, avoid commit-resuming when threads have pending statuses\n\nThe rationale for this patch comes from the ROCm port [1], the goal\nbeing to reduce the number of back and forths between GDB and the\ntarget when doing successive operations.  I'll start with explaining\nthe rationale and then go over the implementation.  In the ROCm / GPU\nworld, the term \"wave\" is somewhat equivalent to a \"thread\" in GDB.\nSo if you read if from a GPU stand point, just s/thread/wave/.\n\nROCdbgapi, the library used by GDB [2] to communicate with the GPU\ntarget, gives the illusion that it's possible for the debugger to\ncontrol (start and stop) individual threads.  But in reality, this is\nnot how it works.  Under the hood, all threads of a queue are\ncontrolled as a group.  To stop one thread in a group of running ones,\nthe state of all threads is retrieved from the GPU, all threads are\ndestroyed, and all threads but the one we want to stop are re-created\nfrom the saved state.  The net result, from the point of view of GDB,\nis that the library stopped one thread.  The same thing goes if we\nwant to resume one thread while others are running: the state of all\nrunning threads is retrieved from the GPU, they are all destroyed, and\nthey are all re-created, including the thread we want to resume.\n\nThis leads to some inefficiencies when combined with how GDB works,\nhere are two examples:\n\n - Stopping all threads: because the target operates in non-stop mode,\n   when the user interface mode is all-stop, GDB must stop all threads\n   individually when presenting a stop.  Let's suppose we have 1000\n   threads and the user does ^C.  GDB asks the target to stop one\n   thread.  Behind the scenes, the library retrieves 1000 thread\n   states and restores the 999 others still running ones.  GDB asks\n   the target to stop another one.  The target retrieves 999 thread\n   states and restores the 998 remaining ones.  That means that to\n   stop 1000 threads, we did 1000 back and forths with the GPU.  It\n   would have been much better to just retrieve the states once and\n   stop there.\n\n - Resuming with pending events: suppose the 1000 threads hit a\n   breakpoint at the same time.  The breakpoint is conditional and\n   evaluates to true for the first thread, to false for all others.\n   GDB pulls one event (for the first thread) from the target, decides\n   that it should present a stop, so stops all threads using\n   stop_all_threads.  All these other threads have a breakpoint event\n   to report, which is saved in `thread_info::suspend::waitstatus` for\n   later.  When the user does \"continue\", GDB resumes that one thread\n   that did hit the breakpoint.  It then processes the pending events\n   one by one as if they just arrived.  It picks one, evaluates the\n   condition to false, and resumes the thread.  It picks another one,\n   evaluates the condition to false, and resumes the thread.  And so\n   on.  In between each resumption, there is a full state retrieval\n   and re-creation.  It would be much nicer if we could wait a little\n   bit before sending those threads on the GPU, until it processed all\n   those pending events.\n\nTo address this kind of performance issue, ROCdbgapi has a concept\ncalled \"forward progress required\", which is a boolean state that\nallows its user (i.e. GDB) to say \"I'm doing a bunch of operations,\nyou can hold off putting the threads on the GPU until I'm done\" (the\n\"forward progress not required\" state).  Turning forward progress back\non indicates to the library that all threads that are supposed to be\nrunning should now be really running on the GPU.\n\nIt turns out that GDB has a similar concept, though not as general,\ncommit_resume.  One difference is that commit_resume is not stateful:\nthe target can't look up \"does the core need me to schedule resumed\nthreads for execution right now\".  It is also specifically linked to\nthe resume method, it is not used in other contexts.  The target\naccumulates resumption requests through target_ops::resume calls, and\nthen commits those resumptions when target_ops::commit_resume is\ncalled.  The target has no way to check if it's ok to leave resumed\nthreads stopped in other target methods.\n\nTo bridge the gap, this patch generalizes the commit_resume concept in\nGDB to match the forward progress concept of ROCdbgapi.  The current\nname (commit_resume) can be interpreted as \"commit the previous resume\ncalls\".  I renamed the concept to \"commit_resumed\", as in \"commit the\nthreads that are resumed\".\n\nIn the new version, we have two things:\n\n - the commit_resumed_state field in process_stratum_target: indicates\n   whether GDB requires target stacks using this target to have\n   resumed threads committed to the execution target/device.  If\n   false, an execution target is allowed to leave resumed threads\n   un-committed at the end of whatever method it is executing.\n\n - the commit_resumed target method: called when commit_resumed_state\n   transitions from false to true.  While commit_resumed_state was\n   false, the target may have left some resumed threads un-committed.\n   This method being called tells it that it should commit them back\n   to the execution device.\n\nLet's take the \"Stopping all threads\" scenario from above and see how\nit would work with the ROCm target with this change.  Before stopping\nall threads, GDB would set the target's commit_resumed_state field to\nfalse.  It would then ask the target to stop the first thread.  The\ntarget would retrieve all threads' state from the GPU and mark that\none as stopped.  Since commit_resumed_state is false, it leaves all\nthe other threads (still resumed) stopped.  GDB would then proceed to\ncall target_stop for all the other threads.  Since resumed threads are\nnot committed, this doesn't do any back and forth with the GPU.\n\nTo simplify the implementation of targets, this patch makes it so that\nwhen calling certain target methods, the contract between the core and\nthe targets guarantees that commit_resumed_state is false.  This way,\nthe target doesn't need two paths, one for commit_resumed_state ==\ntrue and one for commit_resumed_state == false.  It can just assert\nthat commit_resumed_state is false and work with that assumption.\nThis also helps catch places where we forgot to disable\ncommit_resumed_state before calling the method, which represents a\nprobable optimization opportunity.  The commit adds assertions in the\ntarget method wrappers (target_resume and friends) to have some\nconfidence that this contract between the core and the targets is\nrespected.\n\nThe scoped_disable_commit_resumed type is used to disable the commit\nresumed state of all process targets on construction, and selectively\nre-enable it on destruction (see below for criteria).  Note that it\nonly sets the process_stratum_target::commit_resumed_state flag.  A\nsubsequent call to maybe_call_commit_resumed_all_targets is necessary\nto call the commit_resumed method on all target stacks with process\ntargets that got their commit_resumed_state flag turned back on.  This\nseparation is because we don't want to call the commit_resumed methods\nin scoped_disable_commit_resumed's destructor, as they may throw.\n\nOn destruction, commit-resumed is not re-enabled for a given target\nif:\n\n 1. this target has no threads resumed, or\n\n 2. this target has at least one resumed thread with a pending status\n    known to the core (saved in thread_info::suspend::waitstatus).\n\nThe first point is not technically necessary, because a proper\ncommit_resumed implementation would be a no-op if the target has no\nresumed threads.  But since we have a flag do to a quick check, it\nshouldn't hurt.\n\nThe second point is more important: together with the\nscoped_disable_commit_resumed instance added in fetch_inferior_event,\nit makes it so the \"Resuming with pending events\" described above is\nhandled efficiently.  Here's what happens in that case:\n\n 1. The user types \"continue\".\n\n 2. Upon destruction, the scoped_disable_commit_resumed in the\n    `proceed` function does not enable commit-resumed, as it sees some\n    threads have pending statuses.\n\n 3. fetch_inferior_event is called to handle another event, the\n    breakpoint hit evaluates to false, and that thread is resumed.\n    Because there are still more threads with pending statuses, the\n    destructor of scoped_disable_commit_resumed in\n    fetch_inferior_event still doesn't enable commit-resumed.\n\n 4. Rinse and repeat step 3, until the last pending status is handled\n    by fetch_inferior_event.  In that case,\n    scoped_disable_commit_resumed's destructor sees there are no more\n    threads with pending statues, so it asks the target to commit\n    resumed threads.\n\nThis allows us to avoid all unnecessary back and forths, there is a\nsingle commit_resumed call once all pending statuses are processed.\n\nThis change required remote_target::remote_stop_ns to learn how to\nhandle stopping threads that were resumed but pending vCont.  The\nsimplest example where that happens is when using the remote target in\nall-stop, but with \"maint set target-non-stop on\", to force it to\noperate in non-stop mode under the hood.  If two threads hit a\nbreakpoint at the same time, GDB will receive two stop replies.  It\nwill present the stop for one thread and save the other one in\nthread_info::suspend::waitstatus.\n\nBefore this patch, when doing \"continue\", GDB first resumes the thread\nwithout a pending status:\n\n    Sending packet: $vCont;c:p172651.172676#f3\n\nIt then consumes the pending status in the next fetch_inferior_event\ncall:\n\n    [infrun] do_target_wait_1: Using pending wait status status->kind = stopped, signal = GDB_SIGNAL_TRAP for Thread 1517137.1517137.\n    [infrun] target_wait (-1.0.0, status) =\n    [infrun]   1517137.1517137.0 [Thread 1517137.1517137],\n    [infrun]   status->kind = stopped, signal = GDB_SIGNAL_TRAP\n\nIt then realizes it needs to stop all threads to present the stop, so\nstops the thread it just resumed:\n\n    [infrun] stop_all_threads:   Thread 1517137.1517137 not executing\n    [infrun] stop_all_threads:   Thread 1517137.1517174 executing, need stop\n    remote_stop called\n    Sending packet: $vCont;t:p172651.172676#04\n\nThis is an unnecessary resume/stop.  With this patch, we don't commit\nresumed threads after proceeding, because of the pending status:\n\n    [infrun] maybe_commit_resumed_all_process_targets: not requesting commit-resumed for target extended-remote, a thread has a pending waitstatus\n\nWhen GDB handles the pending status and stop_all_threads runs, we stop a\nresumed but pending vCont thread:\n\n    remote_stop_ns: Enqueueing phony stop reply for thread pending vCont-resume (1520940, 1520976, 0)\n\nThat thread was never actually resumed on the remote stub / gdbserver,\nso we shouldn't send a packet to the remote side asking to stop the\nthread.\n\nNote that there are paths that resume the target and then do a\nsynchronous blocking wait, in sort of nested event loop, via\nwait_sync_command_done.  For example, inferior function calls, or any\nrun control command issued from a breakpoint command list.  We handle\nthat making wait_sync_command_one a \"sync\" point -- force forward\nprogress, or IOW, force-enable commit-resumed state.\n\ngdb/ChangeLog:\nyyyy-mm-dd  Simon Marchi  <simon.marchi@efficios.com>\n\t    Pedro Alves  <pedro@palves.net>\n\n\t* infcmd.c (run_command_1, attach_command, detach_command)\n\t(interrupt_target_1): Use scoped_disable_commit_resumed.\n\t* infrun.c (do_target_resume): Remove\n\ttarget_commit_resume call.\n\t(commit_resume_all_targets): Remove.\n\t(maybe_set_commit_resumed_all_targets): New.\n\t(maybe_call_commit_resumed_all_targets): New.\n\t(enable_commit_resumed): New.\n\t(scoped_disable_commit_resumed::scoped_disable_commit_resumed)\n\t(scoped_disable_commit_resumed::~scoped_disable_commit_resumed)\n\t(scoped_disable_commit_resumed::reset)\n\t(scoped_disable_commit_resumed::reset_and_commit)\n\t(scoped_enable_commit_resumed::scoped_enable_commit_resumed)\n\t(scoped_enable_commit_resumed::~scoped_enable_commit_resumed):\n\tNew.\n\t(proceed): Use scoped_disable_commit_resumed and\n\tmaybe_call_commit_resumed_all_targets.\n\t(fetch_inferior_event): Use scoped_disable_commit_resumed.\n\t* infrun.h (struct scoped_disable_commit_resumed): New.\n\t(maybe_call_commit_resumed_all_process_targets): New.\n\t(struct scoped_enable_commit_resumed): New.\n\t* mi/mi-main.c (exec_continue): Use scoped_disable_commit_resumed.\n\t* process-stratum-target.h (class process_stratum_target):\n\t<commit_resumed_state>: New.\n\t* record-full.c (record_full_wait_1): Change commit_resumed_state\n\taround calling commit_resumed.\n\t* remote.c (class remote_target) <commit_resume>: Rename to...\n\t<commit_resumed>: ... this.\n\t(struct stop_reply): Move up.\n\t(remote_target::commit_resume): Rename to...\n\t(remote_target::commit_resumed): ... this.  Check if there is any\n\tthread pending vCont resume.\n\t(remote_target::remote_stop_ns): Generate stop replies for resumed\n\tbut pending vCont threads.\n\t(remote_target::wait_ns): Add gdb_assert.\n\t* target-delegates.c: Regenerate.\n\t* target.c (target_wait, target_resume): Assert that the current\n\tprocess_stratum target isn't in commit-resumed state.\n\t(defer_target_commit_resume): Remove.\n\t(target_commit_resume): Remove.\n\t(target_commit_resumed): New.\n\t(make_scoped_defer_target_commit_resume): Remove.\n\t(target_stop): Assert that the current process_stratum target\n\tisn't in commit-resumed state.\n\t* target.h (struct target_ops) <commit_resume>: Rename to ...\n\t <commit_resumed>: ... this.\n\t(target_commit_resume): Remove.\n\t(target_commit_resumed): New.\n\t(make_scoped_defer_target_commit_resume): Remove.\n\t* top.c (wait_sync_command_done): Use\n\tscoped_enable_commit_resumed.\n\n[1] https://github.com/ROCm-Developer-Tools/ROCgdb/\n[2] https://github.com/ROCm-Developer-Tools/ROCdbgapi\n\nChange-Id: I836135531a29214b21695736deb0a81acf8cf566",
    "tree": {
      "sha": "0aec8738ccfc8f3948a521f30257dae75e342e65",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0aec8738ccfc8f3948a521f30257dae75e342e65"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1192f124a308601f5fef7a35715ccd6f904e7b17",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1192f124a308601f5fef7a35715ccd6f904e7b17",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1192f124a308601f5fef7a35715ccd6f904e7b17",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1192f124a308601f5fef7a35715ccd6f904e7b17/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e5b9b39f8872fa01efb9c7f8ce7283fb9cd5122d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e5b9b39f8872fa01efb9c7f8ce7283fb9cd5122d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e5b9b39f8872fa01efb9c7f8ce7283fb9cd5122d"
    }
  ],
  "stats": {
    "total": 673,
    "additions": 575,
    "deletions": 98
  },
  "files": [
    {
      "sha": "e3ae1c4df7533983f75a2c0274df218959fdfa35",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 55,
      "deletions": 0,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -1,3 +1,58 @@\n+2021-03-26  Simon Marchi  <simon.marchi@efficios.com>\n+\t    Pedro Alves  <pedro@palves.net>\n+\n+\t* infcmd.c (run_command_1, attach_command, detach_command)\n+\t(interrupt_target_1): Use scoped_disable_commit_resumed.\n+\t* infrun.c (do_target_resume): Remove\n+\ttarget_commit_resume call.\n+\t(commit_resume_all_targets): Remove.\n+\t(maybe_set_commit_resumed_all_targets): New.\n+\t(maybe_call_commit_resumed_all_targets): New.\n+\t(enable_commit_resumed): New.\n+\t(scoped_disable_commit_resumed::scoped_disable_commit_resumed)\n+\t(scoped_disable_commit_resumed::~scoped_disable_commit_resumed)\n+\t(scoped_disable_commit_resumed::reset)\n+\t(scoped_disable_commit_resumed::reset_and_commit)\n+\t(scoped_enable_commit_resumed::scoped_enable_commit_resumed)\n+\t(scoped_enable_commit_resumed::~scoped_enable_commit_resumed):\n+\tNew.\n+\t(proceed): Use scoped_disable_commit_resumed and\n+\tmaybe_call_commit_resumed_all_targets.\n+\t(fetch_inferior_event): Use scoped_disable_commit_resumed.\n+\t* infrun.h (struct scoped_disable_commit_resumed): New.\n+\t(maybe_call_commit_resumed_all_process_targets): New.\n+\t(struct scoped_enable_commit_resumed): New.\n+\t* mi/mi-main.c (exec_continue): Use scoped_disable_commit_resumed.\n+\t* process-stratum-target.h (class process_stratum_target):\n+\t<commit_resumed_state>: New.\n+\t* record-full.c (record_full_wait_1): Change commit_resumed_state\n+\taround calling commit_resumed.\n+\t* remote.c (class remote_target) <commit_resume>: Rename to...\n+\t<commit_resumed>: ... this.\n+\t(struct stop_reply): Move up.\n+\t(remote_target::commit_resume): Rename to...\n+\t(remote_target::commit_resumed): ... this.  Check if there is any\n+\tthread pending vCont resume.\n+\t(remote_target::remote_stop_ns): Generate stop replies for resumed\n+\tbut pending vCont threads.\n+\t(remote_target::wait_ns): Add gdb_assert.\n+\t* target-delegates.c: Regenerate.\n+\t* target.c (target_wait, target_resume): Assert that the current\n+\tprocess_stratum target isn't in commit-resumed state.\n+\t(defer_target_commit_resume): Remove.\n+\t(target_commit_resume): Remove.\n+\t(target_commit_resumed): New.\n+\t(make_scoped_defer_target_commit_resume): Remove.\n+\t(target_stop): Assert that the current process_stratum target\n+\tisn't in commit-resumed state.\n+\t* target.h (struct target_ops) <commit_resume>: Rename to ...\n+\t <commit_resumed>: ... this.\n+\t(target_commit_resume): Remove.\n+\t(target_commit_resumed): New.\n+\t(make_scoped_defer_target_commit_resume): Remove.\n+\t* top.c (wait_sync_command_done): Use\n+\tscoped_enable_commit_resumed.\n+\n 2021-03-26  Pedro Alves  <pedro@palves.net>\n \n \t* target.c (target_always_non_stop_p): Also check whether the"
    },
    {
      "sha": "9b0186dd391c4c3e89fbc9f5ba739b2e44782240",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -419,6 +419,8 @@ run_command_1 (const char *args, int from_tty, enum run_how run_how)\n \n   dont_repeat ();\n \n+  scoped_disable_commit_resumed disable_commit_resumed (\"running\");\n+\n   kill_if_already_running (from_tty);\n \n   init_wait_for_inferior ();\n@@ -538,6 +540,8 @@ run_command_1 (const char *args, int from_tty, enum run_how run_how)\n   /* Since there was no error, there's no need to finish the thread\n      states here.  */\n   finish_state.release ();\n+\n+  disable_commit_resumed.reset_and_commit ();\n }\n \n static void\n@@ -2565,6 +2569,8 @@ attach_command (const char *args, int from_tty)\n \n   dont_repeat ();\t\t/* Not for the faint of heart */\n \n+  scoped_disable_commit_resumed disable_commit_resumed (\"attaching\");\n+\n   if (gdbarch_has_global_solist (target_gdbarch ()))\n     /* Don't complain if all processes share the same symbol\n        space.  */\n@@ -2673,6 +2679,8 @@ attach_command (const char *args, int from_tty)\n     }\n   else\n     attach_post_wait (args, from_tty, mode);\n+\n+  disable_commit_resumed.reset_and_commit ();\n }\n \n /* We had just found out that the target was already attached to an\n@@ -2746,6 +2754,8 @@ detach_command (const char *args, int from_tty)\n   if (inferior_ptid == null_ptid)\n     error (_(\"The program is not being run.\"));\n \n+  scoped_disable_commit_resumed disable_commit_resumed (\"detaching\");\n+\n   query_if_trace_running (from_tty);\n \n   disconnect_tracing ();\n@@ -2779,6 +2789,8 @@ detach_command (const char *args, int from_tty)\n \n   if (!was_non_stop_p)\n     restart_after_all_stop_detach (as_process_stratum_target (target_ref.get ()));\n+\n+  disable_commit_resumed.reset_and_commit ();\n }\n \n /* Disconnect from the current target without resuming it (leaving it\n@@ -2827,6 +2839,8 @@ stop_current_target_threads_ns (ptid_t ptid)\n void\n interrupt_target_1 (bool all_threads)\n {\n+  scoped_disable_commit_resumed disable_commit_resumed (\"interrupting\");\n+\n   if (non_stop)\n     {\n       if (all_threads)\n@@ -2844,6 +2858,8 @@ interrupt_target_1 (bool all_threads)\n     }\n   else\n     target_interrupt ();\n+\n+  disable_commit_resumed.reset_and_commit ();\n }\n \n /* interrupt [-a]"
    },
    {
      "sha": "347eefbd0dd4d4a73d56fbc4038210d998824cf7",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 207,
      "deletions": 19,
      "changes": 226,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -2173,8 +2173,6 @@ do_target_resume (ptid_t resume_ptid, bool step, enum gdb_signal sig)\n \n   target_resume (resume_ptid, step, sig);\n \n-  target_commit_resume ();\n-\n   if (target_can_async_p ())\n     target_async (1);\n }\n@@ -2761,28 +2759,208 @@ schedlock_applies (struct thread_info *tp)\n \t\t\t\t\t    execution_direction)));\n }\n \n-/* Calls target_commit_resume on all targets.  */\n+/* Set process_stratum_target::COMMIT_RESUMED_STATE in all target\n+   stacks that have threads executing and don't have threads with\n+   pending events.  */\n \n static void\n-commit_resume_all_targets ()\n+maybe_set_commit_resumed_all_targets ()\n+{\n+  for (inferior *inf : all_non_exited_inferiors ())\n+    {\n+      process_stratum_target *proc_target = inf->process_target ();\n+\n+      if (proc_target->commit_resumed_state)\n+\t{\n+\t  /* We already set this in a previous iteration, via another\n+\t     inferior sharing the process_stratum target.  */\n+\t  continue;\n+\t}\n+\n+      /* If the target has no resumed threads, it would be useless to\n+\t ask it to commit the resumed threads.  */\n+      if (!proc_target->threads_executing)\n+\t{\n+\t  infrun_debug_printf (\"not requesting commit-resumed for target \"\n+\t\t\t       \"%s, no resumed threads\",\n+\t\t\t       proc_target->shortname ());\n+\t  continue;\n+\t}\n+\n+      /* As an optimization, if a thread from this target has some\n+\t status to report, handle it before requiring the target to\n+\t commit its resumed threads: handling the status might lead to\n+\t resuming more threads.  */\n+      bool has_thread_with_pending_status = false;\n+      for (thread_info *thread : all_non_exited_threads (proc_target))\n+\tif (thread->resumed && thread->suspend.waitstatus_pending_p)\n+\t  {\n+\t    has_thread_with_pending_status = true;\n+\t    break;\n+\t  }\n+\n+      if (has_thread_with_pending_status)\n+\t{\n+\t  infrun_debug_printf (\"not requesting commit-resumed for target %s, a\"\n+\t\t\t       \" thread has a pending waitstatus\",\n+\t\t\t       proc_target->shortname ());\n+\t  continue;\n+\t}\n+\n+      infrun_debug_printf (\"enabling commit-resumed for target %s\",\n+\t\t\t   proc_target->shortname ());\n+\n+      proc_target->commit_resumed_state = true;\n+    }\n+}\n+\n+/* See infrun.h.  */\n+\n+void\n+maybe_call_commit_resumed_all_targets ()\n {\n   scoped_restore_current_thread restore_thread;\n \n-  /* Map between process_target and a representative inferior.  This\n-     is to avoid committing a resume in the same target more than\n-     once.  Resumptions must be idempotent, so this is an\n-     optimization.  */\n-  std::unordered_map<process_stratum_target *, inferior *> conn_inf;\n+  for (inferior *inf : all_non_exited_inferiors ())\n+    {\n+      process_stratum_target *proc_target = inf->process_target ();\n+\n+      if (!proc_target->commit_resumed_state)\n+\tcontinue;\n+\n+      switch_to_inferior_no_thread (inf);\n+\n+      infrun_debug_printf (\"calling commit_resumed for target %s\",\n+\t\t\t   proc_target->shortname());\n+\n+      target_commit_resumed ();\n+    }\n+}\n+\n+/* To track nesting of scoped_disable_commit_resumed objects, ensuring\n+   that only the outermost one attempts to re-enable\n+   commit-resumed.  */\n+static bool enable_commit_resumed = true;\n+\n+/* See infrun.h.  */\n+\n+scoped_disable_commit_resumed::scoped_disable_commit_resumed\n+  (const char *reason)\n+  : m_reason (reason),\n+    m_prev_enable_commit_resumed (enable_commit_resumed)\n+{\n+  infrun_debug_printf (\"reason=%s\", m_reason);\n+\n+  enable_commit_resumed = false;\n \n   for (inferior *inf : all_non_exited_inferiors ())\n-    if (inf->has_execution ())\n-      conn_inf[inf->process_target ()] = inf;\n+    {\n+      process_stratum_target *proc_target = inf->process_target ();\n+\n+      if (m_prev_enable_commit_resumed)\n+\t{\n+\t  /* This is the outermost instance: force all\n+\t     COMMIT_RESUMED_STATE to false.  */\n+\t  proc_target->commit_resumed_state = false;\n+\t}\n+      else\n+\t{\n+\t  /* This is not the outermost instance, we expect\n+\t     COMMIT_RESUMED_STATE to have been cleared by the\n+\t     outermost instance.  */\n+\t  gdb_assert (!proc_target->commit_resumed_state);\n+\t}\n+    }\n+}\n \n-  for (const auto &ci : conn_inf)\n+/* See infrun.h.  */\n+\n+void\n+scoped_disable_commit_resumed::reset ()\n+{\n+  if (m_reset)\n+    return;\n+  m_reset = true;\n+\n+  infrun_debug_printf (\"reason=%s\", m_reason);\n+\n+  gdb_assert (!enable_commit_resumed);\n+\n+  enable_commit_resumed = m_prev_enable_commit_resumed;\n+\n+  if (m_prev_enable_commit_resumed)\n     {\n-      inferior *inf = ci.second;\n-      switch_to_inferior_no_thread (inf);\n-      target_commit_resume ();\n+      /* This is the outermost instance, re-enable\n+         COMMIT_RESUMED_STATE on the targets where it's possible.  */\n+      maybe_set_commit_resumed_all_targets ();\n+    }\n+  else\n+    {\n+      /* This is not the outermost instance, we expect\n+\t COMMIT_RESUMED_STATE to still be false.  */\n+      for (inferior *inf : all_non_exited_inferiors ())\n+\t{\n+\t  process_stratum_target *proc_target = inf->process_target ();\n+\t  gdb_assert (!proc_target->commit_resumed_state);\n+\t}\n+    }\n+}\n+\n+/* See infrun.h.  */\n+\n+scoped_disable_commit_resumed::~scoped_disable_commit_resumed ()\n+{\n+  reset ();\n+}\n+\n+/* See infrun.h.  */\n+\n+void\n+scoped_disable_commit_resumed::reset_and_commit ()\n+{\n+  reset ();\n+  maybe_call_commit_resumed_all_targets ();\n+}\n+\n+/* See infrun.h.  */\n+\n+scoped_enable_commit_resumed::scoped_enable_commit_resumed\n+  (const char *reason)\n+  : m_reason (reason),\n+    m_prev_enable_commit_resumed (enable_commit_resumed)\n+{\n+  infrun_debug_printf (\"reason=%s\", m_reason);\n+\n+  if (!enable_commit_resumed)\n+    {\n+      enable_commit_resumed = true;\n+\n+      /* Re-enable COMMIT_RESUMED_STATE on the targets where it's\n+\t possible.  */\n+      maybe_set_commit_resumed_all_targets ();\n+\n+      maybe_call_commit_resumed_all_targets ();\n+    }\n+}\n+\n+/* See infrun.h.  */\n+\n+scoped_enable_commit_resumed::~scoped_enable_commit_resumed ()\n+{\n+  infrun_debug_printf (\"reason=%s\", m_reason);\n+\n+  gdb_assert (enable_commit_resumed);\n+\n+  enable_commit_resumed = m_prev_enable_commit_resumed;\n+\n+  if (!enable_commit_resumed)\n+    {\n+      /* Force all COMMIT_RESUMED_STATE back to false.  */\n+      for (inferior *inf : all_non_exited_inferiors ())\n+\t{\n+\t  process_stratum_target *proc_target = inf->process_target ();\n+\t  proc_target->commit_resumed_state = false;\n+\t}\n     }\n }\n \n@@ -3006,7 +3184,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n   cur_thr->prev_pc = regcache_read_pc_protected (regcache);\n \n   {\n-    scoped_restore save_defer_tc = make_scoped_defer_target_commit_resume ();\n+    scoped_disable_commit_resumed disable_commit_resumed (\"proceeding\");\n \n     started = start_step_over ();\n \n@@ -3074,9 +3252,9 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \tif (!ecs->wait_some_more)\n \t  error (_(\"Command aborted.\"));\n       }\n-  }\n \n-  commit_resume_all_targets ();\n+    disable_commit_resumed.reset_and_commit ();\n+  }\n \n   finish_state.release ();\n \n@@ -3878,8 +4056,16 @@ fetch_inferior_event ()\n       = make_scoped_restore (&execution_direction,\n \t\t\t     target_execution_direction ());\n \n+    /* Allow targets to pause their resumed threads while we handle\n+       the event.  */\n+    scoped_disable_commit_resumed disable_commit_resumed (\"handling event\");\n+\n     if (!do_target_wait (minus_one_ptid, ecs, TARGET_WNOHANG))\n-      return;\n+      {\n+\tinfrun_debug_printf (\"do_target_wait returned no event\");\n+\tdisable_commit_resumed.reset_and_commit ();\n+\treturn;\n+      }\n \n     gdb_assert (ecs->ws.kind != TARGET_WAITKIND_IGNORE);\n \n@@ -3970,6 +4156,8 @@ fetch_inferior_event ()\n     /* No error, don't finish the thread states yet.  */\n     finish_state.release ();\n \n+    disable_commit_resumed.reset_and_commit ();\n+\n     /* This scope is used to ensure that readline callbacks are\n        reinstalled here.  */\n   }"
    },
    {
      "sha": "220ccc79e8b4c7f035df7a53254f43c7461a6305",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 98,
      "deletions": 0,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -273,4 +273,102 @@ extern void all_uis_on_sync_execution_starting (void);\n    detach.  */\n extern void restart_after_all_stop_detach (process_stratum_target *proc_target);\n \n+/* RAII object to temporarily disable the requirement for target\n+   stacks to commit their resumed threads.\n+\n+   On construction, set process_stratum_target::commit_resumed_state\n+   to false for all process_stratum targets in all target\n+   stacks.\n+\n+   On destruction (or if reset_and_commit() is called), set\n+   process_stratum_target::commit_resumed_state to true for all\n+   process_stratum targets in all target stacks, except those that:\n+\n+     - have no resumed threads\n+     - have a resumed thread with a pending status\n+\n+   target_commit_resumed is not called in the destructor, because its\n+   implementations could throw, and we don't to swallow that error in\n+   a destructor.  Instead, the caller should call the\n+   reset_and_commit_resumed() method so that an eventual exception can\n+   propagate.  \"reset\" in the method name refers to the fact that this\n+   method has the same effect as the destructor, in addition to\n+   committing resumes.\n+\n+   The creation of nested scoped_disable_commit_resumed objects is\n+   tracked, such that only the outermost instance actually does\n+   something, for cases like this:\n+\n+     void\n+     inner_func ()\n+     {\n+       scoped_disable_commit_resumed disable;\n+\n+       // do stuff\n+\n+       disable.reset_and_commit ();\n+     }\n+\n+     void\n+     outer_func ()\n+     {\n+       scoped_disable_commit_resumed disable;\n+\n+       for (... each thread ...)\n+\t inner_func ();\n+\n+       disable.reset_and_commit ();\n+     }\n+\n+   In this case, we don't want the `disable` destructor in\n+   `inner_func` to require targets to commit resumed threads, so that\n+   the `reset_and_commit()` call in `inner_func` doesn't actually\n+   resume threads.  */\n+\n+struct scoped_disable_commit_resumed\n+{\n+  explicit scoped_disable_commit_resumed (const char *reason);\n+  ~scoped_disable_commit_resumed ();\n+\n+  DISABLE_COPY_AND_ASSIGN (scoped_disable_commit_resumed);\n+\n+  /* Undoes the disabling done by the ctor, and calls\n+     maybe_call_commit_resumed_all_targets().  */\n+  void reset_and_commit ();\n+\n+private:\n+  /* Undoes the disabling done by the ctor.  */\n+  void reset ();\n+\n+  /* Whether this object has been reset.  */\n+  bool m_reset = false;\n+\n+  const char *m_reason;\n+  bool m_prev_enable_commit_resumed;\n+};\n+\n+/* Call target_commit_resumed method on all target stacks whose\n+   process_stratum target layer has COMMIT_RESUME_STATE set.  */\n+\n+extern void maybe_call_commit_resumed_all_targets ();\n+\n+/* RAII object to temporarily enable the requirement for target stacks\n+   to commit their resumed threads.  This is the inverse of\n+   scoped_disable_commit_resumed.  The constructor calls the\n+   maybe_call_commit_resumed_all_targets function itself, since it's\n+   OK to throw from a constructor.  */\n+\n+struct scoped_enable_commit_resumed\n+{\n+  explicit scoped_enable_commit_resumed (const char *reason);\n+  ~scoped_enable_commit_resumed ();\n+\n+  DISABLE_COPY_AND_ASSIGN (scoped_enable_commit_resumed);\n+\n+private:\n+  const char *m_reason;\n+  bool m_prev_enable_commit_resumed;\n+};\n+\n+\n #endif /* INFRUN_H */"
    },
    {
      "sha": "988db558be1f5ee8c767e6a906aedf3c4e77b7f1",
      "filename": "gdb/mi/mi-main.c",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/mi/mi-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/mi/mi-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.c?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -266,6 +266,8 @@ exec_continue (char **argv, int argc)\n {\n   prepare_execution_command (current_inferior ()->top_target (), mi_async_p ());\n \n+  scoped_disable_commit_resumed disable_commit_resumed (\"mi continue\");\n+\n   if (non_stop)\n     {\n       /* In non-stop mode, 'resume' always resumes a single thread.\n@@ -311,6 +313,8 @@ exec_continue (char **argv, int argc)\n \t  continue_1 (1);\n \t}\n     }\n+\n+  disable_commit_resumed.reset_and_commit ();\n }\n \n static void"
    },
    {
      "sha": "6fddbba90c72c61029c5eadbc6145aa13b205a52",
      "filename": "gdb/process-stratum-target.h",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/process-stratum-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/process-stratum-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/process-stratum-target.h?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -72,6 +72,38 @@ class process_stratum_target : public target_ops\n \n   /* The connection number.  Visible in \"info connections\".  */\n   int connection_number = 0;\n+\n+  /* Whether resumed threads must be committed to the target.\n+\n+     When true, resumed threads must be committed to the execution\n+     target.\n+\n+     When false, the target may leave resumed threads stopped when\n+     it's convenient or efficient to do so.  When the core requires\n+     resumed threads to be committed again, this is set back to true\n+     and calls the `commit_resumed` method to allow the target to do\n+     so.\n+\n+     To simplify the implementation of targets, the following methods\n+     are guaranteed to be called with COMMIT_RESUMED_STATE set to\n+     false:\n+\n+       - resume\n+       - stop\n+       - wait\n+\n+     Knowing this, the target doesn't need to implement different\n+     behaviors depending on the COMMIT_RESUMED_STATE, and can simply\n+     assume that it is false.\n+\n+     Targets can take advantage of this to batch resumption requests,\n+     for example.  In that case, the target doesn't actually resume in\n+     its `resume` implementation.  Instead, it takes note of the\n+     resumption intent in `resume` and defers the actual resumption to\n+     `commit_resumed`.  For example, the remote target uses this to\n+     coalesce multiple resumption requests in a single vCont\n+     packet.  */\n+  bool commit_resumed_state = false;\n };\n \n /* Downcast TARGET to process_stratum_target.  */"
    },
    {
      "sha": "23cbdcb58c40ab36cd4d2f77cdc60f6e8354ff1c",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -1242,11 +1242,11 @@ record_full_wait_1 (struct target_ops *ops,\n \t\t\t   break;\n   \t\t\t}\n \n+\t\t      process_stratum_target *proc_target\n+\t\t\t= current_inferior ()->process_target ();\n+\n \t\t      if (gdbarch_software_single_step_p (gdbarch))\n \t\t\t{\n-\t\t\t  process_stratum_target *proc_target\n-\t\t\t    = current_inferior ()->process_target ();\n-\n \t\t\t  /* Try to insert the software single step breakpoint.\n \t\t\t     If insert success, set step to 0.  */\n \t\t\t  set_executing (proc_target, inferior_ptid, false);\n@@ -1263,7 +1263,9 @@ record_full_wait_1 (struct target_ops *ops,\n \t\t\t\t\t    \"issuing one more step in the \"\n \t\t\t\t\t    \"target beneath\\n\");\n \t\t      ops->beneath ()->resume (ptid, step, GDB_SIGNAL_0);\n-\t\t      ops->beneath ()->commit_resume ();\n+\t\t      proc_target->commit_resumed_state = true;\n+\t\t      proc_target->commit_resumed ();\n+\t\t      proc_target->commit_resumed_state = false;\n \t\t      continue;\n \t\t    }\n \t\t}"
    },
    {
      "sha": "1036ffd5cad02aeb349dbafe4d9c5ea1b7d96b6d",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 117,
      "deletions": 32,
      "changes": 149,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -426,7 +426,7 @@ class remote_target : public process_stratum_target\n   void detach (inferior *, int) override;\n   void disconnect (const char *, int) override;\n \n-  void commit_resume () override;\n+  void commit_resumed () override;\n   void resume (ptid_t, int, enum gdb_signal) override;\n   ptid_t wait (ptid_t, struct target_waitstatus *, target_wait_flags) override;\n \n@@ -6499,6 +6499,36 @@ get_remote_inferior (inferior *inf)\n   return static_cast<remote_inferior *> (inf->priv.get ());\n }\n \n+struct stop_reply : public notif_event\n+{\n+  ~stop_reply ();\n+\n+  /* The identifier of the thread about this event  */\n+  ptid_t ptid;\n+\n+  /* The remote state this event is associated with.  When the remote\n+     connection, represented by a remote_state object, is closed,\n+     all the associated stop_reply events should be released.  */\n+  struct remote_state *rs;\n+\n+  struct target_waitstatus ws;\n+\n+  /* The architecture associated with the expedited registers.  */\n+  gdbarch *arch;\n+\n+  /* Expedited registers.  This makes remote debugging a bit more\n+     efficient for those targets that provide critical registers as\n+     part of their normal status mechanism (as another roundtrip to\n+     fetch them is avoided).  */\n+  std::vector<cached_reg_t> regcache;\n+\n+  enum target_stop_reason stop_reason;\n+\n+  CORE_ADDR watch_data_address;\n+\n+  int core;\n+};\n+\n /* Class used to track the construction of a vCont packet in the\n    outgoing packet buffer.  This is used to send multiple vCont\n    packets if we have more actions than would fit a single packet.  */\n@@ -6603,7 +6633,7 @@ vcont_builder::push_action (ptid_t ptid, bool step, gdb_signal siggnal)\n /* to_commit_resume implementation.  */\n \n void\n-remote_target::commit_resume ()\n+remote_target::commit_resumed ()\n {\n   int any_process_wildcard;\n   int may_global_wildcard_vcont;\n@@ -6678,6 +6708,8 @@ remote_target::commit_resume ()\n      disable process and global wildcard resumes appropriately.  */\n   check_pending_events_prevent_wildcard_vcont (&may_global_wildcard_vcont);\n \n+  bool any_pending_vcont_resume = false;\n+\n   for (thread_info *tp : all_non_exited_threads (this))\n     {\n       remote_thread_info *priv = get_remote_thread_info (tp);\n@@ -6694,13 +6726,21 @@ remote_target::commit_resume ()\n \t  continue;\n \t}\n \n+      if (priv->get_resume_state () == resume_state::RESUMED_PENDING_VCONT)\n+\tany_pending_vcont_resume = true;\n+\n       /* If a thread is the parent of an unfollowed fork, then we\n \t can't do a global wildcard, as that would resume the fork\n \t child.  */\n       if (is_pending_fork_parent_thread (tp))\n \tmay_global_wildcard_vcont = 0;\n     }\n \n+  /* We didn't have any resumed thread pending a vCont resume, so nothing to\n+     do.  */\n+  if (!any_pending_vcont_resume)\n+    return;\n+\n   /* Now let's build the vCont packet(s).  Actions must be appended\n      from narrower to wider scopes (thread -> process -> global).  If\n      we end up with too many actions for a single packet vcont_builder\n@@ -6721,6 +6761,13 @@ remote_target::commit_resume ()\n \n       gdb_assert (!thread_is_in_step_over_chain (tp));\n \n+      /* We should never be commit-resuming a thread that has a stop reply.\n+         Otherwise, we would end up reporting a stop event for a thread while\n+\t it is running on the remote target.  */\n+      remote_state *rs = get_remote_state ();\n+      for (const auto &stop_reply : rs->stop_reply_queue)\n+\tgdb_assert (stop_reply->ptid != tp->ptid);\n+\n       const resumed_pending_vcont_info &info\n \t= remote_thr->resumed_pending_vcont_info ();\n \n@@ -6786,6 +6833,74 @@ remote_target::remote_stop_ns (ptid_t ptid)\n   char *p = rs->buf.data ();\n   char *endp = p + get_remote_packet_size ();\n \n+  /* If any thread that needs to stop was resumed but pending a vCont\n+     resume, generate a phony stop_reply.  However, first check\n+     whether the thread wasn't resumed with a signal.  Generating a\n+     phony stop in that case would result in losing the signal.  */\n+  bool needs_commit = false;\n+  for (thread_info *tp : all_non_exited_threads (this, ptid))\n+    {\n+      remote_thread_info *remote_thr = get_remote_thread_info (tp);\n+\n+      if (remote_thr->get_resume_state ()\n+\t  == resume_state::RESUMED_PENDING_VCONT)\n+\t{\n+\t  const resumed_pending_vcont_info &info\n+\t    = remote_thr->resumed_pending_vcont_info ();\n+\t  if (info.sig != GDB_SIGNAL_0)\n+\t    {\n+\t      /* This signal must be forwarded to the inferior.  We\n+\t\t could commit-resume just this thread, but its simpler\n+\t\t to just commit-resume everything.  */\n+\t      needs_commit = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (needs_commit)\n+    commit_resumed ();\n+  else\n+    for (thread_info *tp : all_non_exited_threads (this, ptid))\n+      {\n+\tremote_thread_info *remote_thr = get_remote_thread_info (tp);\n+\n+\tif (remote_thr->get_resume_state ()\n+\t    == resume_state::RESUMED_PENDING_VCONT)\n+\t  {\n+\t    remote_debug_printf (\"Enqueueing phony stop reply for thread pending \"\n+\t\t\t\t \"vCont-resume (%d, %ld, %ld)\", tp->ptid.pid(),\n+\t\t\t\t tp->ptid.lwp (), tp->ptid.tid ());\n+\n+\t    /* Check that the thread wasn't resumed with a signal.\n+\t       Generating a phony stop would result in losing the\n+\t       signal.  */\n+\t    const resumed_pending_vcont_info &info\n+\t      = remote_thr->resumed_pending_vcont_info ();\n+\t    gdb_assert (info.sig == GDB_SIGNAL_0);\n+\n+\t    stop_reply *sr = new stop_reply ();\n+\t    sr->ptid = tp->ptid;\n+\t    sr->rs = rs;\n+\t    sr->ws.kind = TARGET_WAITKIND_STOPPED;\n+\t    sr->ws.value.sig = GDB_SIGNAL_0;\n+\t    sr->arch = tp->inf->gdbarch;\n+\t    sr->stop_reason = TARGET_STOPPED_BY_NO_REASON;\n+\t    sr->watch_data_address = 0;\n+\t    sr->core = 0;\n+\t    this->push_stop_reply (sr);\n+\n+\t    /* Pretend that this thread was actually resumed on the\n+\t       remote target, then stopped.  If we leave it in the\n+\t       RESUMED_PENDING_VCONT state and the commit_resumed\n+\t       method is called while the stop reply is still in the\n+\t       queue, we'll end up reporting a stop event to the core\n+\t       for that thread while it is running on the remote\n+\t       target... that would be bad.  */\n+\t    remote_thr->set_resumed ();\n+\t  }\n+      }\n+\n   /* FIXME: This supports_vCont_probed check is a workaround until\n      packet_support is per-connection.  */\n   if (packet_support (PACKET_vCont) == PACKET_SUPPORT_UNKNOWN\n@@ -6990,36 +7105,6 @@ remote_console_output (const char *msg)\n   gdb_stdtarg->flush ();\n }\n \n-struct stop_reply : public notif_event\n-{\n-  ~stop_reply ();\n-\n-  /* The identifier of the thread about this event  */\n-  ptid_t ptid;\n-\n-  /* The remote state this event is associated with.  When the remote\n-     connection, represented by a remote_state object, is closed,\n-     all the associated stop_reply events should be released.  */\n-  struct remote_state *rs;\n-\n-  struct target_waitstatus ws;\n-\n-  /* The architecture associated with the expedited registers.  */\n-  gdbarch *arch;\n-\n-  /* Expedited registers.  This makes remote debugging a bit more\n-     efficient for those targets that provide critical registers as\n-     part of their normal status mechanism (as another roundtrip to\n-     fetch them is avoided).  */\n-  std::vector<cached_reg_t> regcache;\n-\n-  enum target_stop_reason stop_reason;\n-\n-  CORE_ADDR watch_data_address;\n-\n-  int core;\n-};\n-\n /* Return the length of the stop reply queue.  */\n \n int"
    },
    {
      "sha": "efbb31be02d78751344741d211892a7a6925715b",
      "filename": "gdb/target-delegates.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/target-delegates.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/target-delegates.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-delegates.c?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -14,7 +14,7 @@ struct dummy_target : public target_ops\n   void detach (inferior *arg0, int arg1) override;\n   void disconnect (const char *arg0, int arg1) override;\n   void resume (ptid_t arg0, int arg1, enum gdb_signal arg2) override;\n-  void commit_resume () override;\n+  void commit_resumed () override;\n   ptid_t wait (ptid_t arg0, struct target_waitstatus *arg1, target_wait_flags arg2) override;\n   void fetch_registers (struct regcache *arg0, int arg1) override;\n   void store_registers (struct regcache *arg0, int arg1) override;\n@@ -188,7 +188,7 @@ struct debug_target : public target_ops\n   void detach (inferior *arg0, int arg1) override;\n   void disconnect (const char *arg0, int arg1) override;\n   void resume (ptid_t arg0, int arg1, enum gdb_signal arg2) override;\n-  void commit_resume () override;\n+  void commit_resumed () override;\n   ptid_t wait (ptid_t arg0, struct target_waitstatus *arg1, target_wait_flags arg2) override;\n   void fetch_registers (struct regcache *arg0, int arg1) override;\n   void store_registers (struct regcache *arg0, int arg1) override;\n@@ -447,22 +447,22 @@ debug_target::resume (ptid_t arg0, int arg1, enum gdb_signal arg2)\n }\n \n void\n-target_ops::commit_resume ()\n+target_ops::commit_resumed ()\n {\n-  this->beneath ()->commit_resume ();\n+  this->beneath ()->commit_resumed ();\n }\n \n void\n-dummy_target::commit_resume ()\n+dummy_target::commit_resumed ()\n {\n }\n \n void\n-debug_target::commit_resume ()\n+debug_target::commit_resumed ()\n {\n-  fprintf_unfiltered (gdb_stdlog, \"-> %s->commit_resume (...)\\n\", this->beneath ()->shortname ());\n-  this->beneath ()->commit_resume ();\n-  fprintf_unfiltered (gdb_stdlog, \"<- %s->commit_resume (\", this->beneath ()->shortname ());\n+  fprintf_unfiltered (gdb_stdlog, \"-> %s->commit_resumed (...)\\n\", this->beneath ()->shortname ());\n+  this->beneath ()->commit_resumed ();\n+  fprintf_unfiltered (gdb_stdlog, \"<- %s->commit_resumed (\", this->beneath ()->shortname ());\n   fputs_unfiltered (\")\\n\", gdb_stdlog);\n }\n "
    },
    {
      "sha": "0da035e1a6776b2eec4ac5ab1e937df1041c75f8",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 11,
      "deletions": 16,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -2597,6 +2597,9 @@ target_wait (ptid_t ptid, struct target_waitstatus *status,\n \t     target_wait_flags options)\n {\n   target_ops *target = current_inferior ()->top_target ();\n+  process_stratum_target *proc_target = current_inferior ()->process_target ();\n+\n+  gdb_assert (!proc_target->commit_resumed_state);\n \n   if (!target->can_async_p ())\n     gdb_assert ((options & TARGET_WNOHANG) == 0);\n@@ -2653,6 +2656,7 @@ void\n target_resume (ptid_t ptid, int step, enum gdb_signal signal)\n {\n   process_stratum_target *curr_target = current_inferior ()->process_target ();\n+  gdb_assert (!curr_target->commit_resumed_state);\n \n   target_dcache_invalidate ();\n \n@@ -2666,26 +2670,13 @@ target_resume (ptid_t ptid, int step, enum gdb_signal signal)\n   clear_inline_frame_state (curr_target, ptid);\n }\n \n-/* If true, target_commit_resume is a nop.  */\n-static int defer_target_commit_resume;\n-\n /* See target.h.  */\n \n void\n-target_commit_resume (void)\n-{\n-  if (defer_target_commit_resume)\n-    return;\n-\n-  current_inferior ()->top_target ()->commit_resume ();\n-}\n-\n-/* See target.h.  */\n-\n-scoped_restore_tmpl<int>\n-make_scoped_defer_target_commit_resume ()\n+target_commit_resumed ()\n {\n-  return make_scoped_restore (&defer_target_commit_resume, 1);\n+  gdb_assert (current_inferior ()->process_target ()->commit_resumed_state);\n+  current_inferior ()->top_target ()->commit_resumed ();\n }\n \n void\n@@ -3761,6 +3752,10 @@ target_update_thread_list (void)\n void\n target_stop (ptid_t ptid)\n {\n+  process_stratum_target *proc_target = current_inferior ()->process_target ();\n+\n+  gdb_assert (!proc_target->commit_resumed_state);\n+\n   if (!may_stop)\n     {\n       warning (_(\"May not interrupt or stop the target, ignoring attempt\"));"
    },
    {
      "sha": "0aef372a7e7b0afb104bc5f6ce8531903cd58a31",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 13,
      "deletions": 18,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -485,8 +485,15 @@ struct target_ops\n \t\t\t int TARGET_DEBUG_PRINTER (target_debug_print_step),\n \t\t\t enum gdb_signal)\n       TARGET_DEFAULT_NORETURN (noprocess ());\n-    virtual void commit_resume ()\n+\n+    /* Ensure that all resumed threads are committed to the target.\n+\n+       See the description of\n+       process_stratum_target::commit_resumed_state for more\n+       details.  */\n+    virtual void commit_resumed ()\n       TARGET_DEFAULT_IGNORE ();\n+\n     /* See target_wait's description.  Note that implementations of\n        this method must not assume that inferior_ptid on entry is\n        pointing at the thread or inferior that ends up reporting an\n@@ -1463,23 +1470,11 @@ extern void target_disconnect (const char *, int);\n    target_commit_resume below.  */\n extern void target_resume (ptid_t ptid, int step, enum gdb_signal signal);\n \n-/* Commit a series of resumption requests previously prepared with\n-   target_resume calls.\n-\n-   GDB always calls target_commit_resume after calling target_resume\n-   one or more times.  A target may thus use this method in\n-   coordination with the target_resume method to batch target-side\n-   resumption requests.  In that case, the target doesn't actually\n-   resume in its target_resume implementation.  Instead, it prepares\n-   the resumption in target_resume, and defers the actual resumption\n-   to target_commit_resume.  E.g., the remote target uses this to\n-   coalesce multiple resumption requests in a single vCont packet.  */\n-extern void target_commit_resume ();\n-\n-/* Setup to defer target_commit_resume calls, and reactivate\n-   target_commit_resume on destruction, if it was previously\n-   active.  */\n-extern scoped_restore_tmpl<int> make_scoped_defer_target_commit_resume ();\n+/* Ensure that all resumed threads are committed to the target.\n+\n+   See the description of process_stratum_target::commit_resumed_state\n+   for more details.  */\n+extern void target_commit_resumed ();\n \n /* For target_read_memory see target/target.h.  */\n "
    },
    {
      "sha": "31b751fa2622d9187e631435ebccc9d63bf3132e",
      "filename": "gdb/top.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1192f124a308601f5fef7a35715ccd6f904e7b17/gdb/top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/top.c?ref=1192f124a308601f5fef7a35715ccd6f904e7b17",
      "patch": "@@ -517,6 +517,13 @@ wait_sync_command_done (void)\n   scoped_restore save_ui = make_scoped_restore (&current_ui);\n   struct ui *ui = current_ui;\n \n+  /* We're about to wait until the target stops after having resumed\n+     it so must force-commit resumptions, in case we're being called\n+     in some context where a scoped_disable_commit_resumed object is\n+     active.  I.e., this function is a commit-resumed sync/flush\n+     point.  */\n+  scoped_enable_commit_resumed enable (\"sync wait\");\n+\n   while (gdb_do_one_event () >= 0)\n     if (ui->prompt_state != PROMPT_BLOCKED)\n       break;"
    }
  ]
}