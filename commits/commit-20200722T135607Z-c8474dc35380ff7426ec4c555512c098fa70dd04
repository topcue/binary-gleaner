{
  "sha": "c8474dc35380ff7426ec4c555512c098fa70dd04",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Yzg0NzRkYzM1MzgwZmY3NDI2ZWM0YzU1NTUxMmMwOThmYTcwZGQwNA==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-07-22T13:56:07Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-07-22T13:56:07Z"
    },
    "message": "gdb/jit: enable tracking multiple JITer objfiles\n\nGDB's JIT handler stores an objfile (and data associated with it) per\nprogram space to keep track of JIT breakpoint information.  This assumes\nthat there is at most one JITer objfile in the program space.  However,\nthere may be multiple.  If so, only the first JITer's hook breakpoints\nwould be realized and the JIT events from the other JITers would be\nmissed.\n\nThis patch removes that assumption, allowing an arbitrary number of\nobjfiles within a program space to be JITers.\n\n- The \"unique\" program_space -> JITer objfile pointer in\n  jit_program_space_data is removed.  In fact, jit_program_space_data\n  becomes empty, so it is removed entirely.\n\n- jit_breakpoint_deleted is modified, it now has to assume that any\n  objfile in a program space is a potential JITer.  It now iterates on\n  all objfiles, checking if they are indeed JITers, and if they are,\n  whether the deleted breakpoint belongs to them.\n\n- jit_breakpoint_re_set_internal also has to assume that any objfile in\n  a program space is a potential JITer.  It creates (or updates) one\n  jiter_objfile_data structure for each JITer it finds.\n\n- Same for jit_inferior_init.  It now iterates all objfiles to read the\n  initial JIT object list.\n\ngdb/ChangeLog:\n2020-07-22  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\t    Simon Marchi  <simon.marchi@polymtl.ca>\n\n\t* jit.c (struct jit_program_space_data): Remove.\n\t(jit_program_space_key): Remove.\n\t(jiter_objfile_data::~jiter_objfile_data): Remove program space\n\tstuff.\n\t(get_jit_program_space_data): Remove.\n\t(jit_breakpoint_deleted): Iterate on all of the program space's\n\tobjfiles.\n\t(jit_inferior_init): Likewise.\n\t(jit_breakpoint_re_set_internal): Likewise.  Also change return\n\ttype to void.\n\t(jit_breakpoint_re_set): Pass current_program_space to\n\tjit_breakpoint_re_set_internal.\n\ngdb/testsuite/ChangeLog:\n2020-07-22  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* gdb.base/jit-reader-simple.exp: Add a scenario for a binary that\n\tloads two JITers.",
    "tree": {
      "sha": "2b627a82ec7f28ad74e3b063669859c6d931cd71",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2b627a82ec7f28ad74e3b063669859c6d931cd71"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c8474dc35380ff7426ec4c555512c098fa70dd04",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c8474dc35380ff7426ec4c555512c098fa70dd04",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c8474dc35380ff7426ec4c555512c098fa70dd04",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c8474dc35380ff7426ec4c555512c098fa70dd04/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "77208eb7e24a2bad8771f3958d9cd2e06144c654",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/77208eb7e24a2bad8771f3958d9cd2e06144c654",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/77208eb7e24a2bad8771f3958d9cd2e06144c654"
    }
  ],
  "stats": {
    "total": 235,
    "additions": 126,
    "deletions": 109
  },
  "files": [
    {
      "sha": "83f20ac349b5cdff040c7717fe5f945f9f2f2209",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c8474dc35380ff7426ec4c555512c098fa70dd04/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c8474dc35380ff7426ec4c555512c098fa70dd04/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c8474dc35380ff7426ec4c555512c098fa70dd04",
      "patch": "@@ -1,3 +1,19 @@\n+2020-07-22  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\t    Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* jit.c (struct jit_program_space_data): Remove.\n+\t(jit_program_space_key): Remove.\n+\t(jiter_objfile_data::~jiter_objfile_data): Remove program space\n+\tstuff.\n+\t(get_jit_program_space_data): Remove.\n+\t(jit_breakpoint_deleted): Iterate on all of the program space's\n+\tobjfiles.\n+\t(jit_inferior_init): Likewise.\n+\t(jit_breakpoint_re_set_internal): Likewise.  Also change return\n+\ttype to void.\n+\t(jit_breakpoint_re_set): Pass current_program_space to\n+\tjit_breakpoint_re_set_internal.\n+\n 2020-07-22  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* jit.h (struct jiter_objfile_data) <cached_code_address,"
    },
    {
      "sha": "0e1cb200618860d3dda2a9ab18d5dc12e014f3aa",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 63,
      "deletions": 108,
      "changes": 171,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c8474dc35380ff7426ec4c555512c098fa70dd04/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c8474dc35380ff7426ec4c555512c098fa70dd04/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=c8474dc35380ff7426ec4c555512c098fa70dd04",
      "patch": "@@ -239,30 +239,10 @@ jit_reader_unload_command (const char *args, int from_tty)\n   loaded_jit_reader = NULL;\n }\n \n-/* Per-program space structure recording which objfile has the JIT\n-   symbols.  */\n-\n-struct jit_program_space_data\n-{\n-  /* The objfile.  This is NULL if no objfile holds the JIT\n-     symbols.  */\n-\n-  struct objfile *objfile = nullptr;\n-};\n-\n-static program_space_key<jit_program_space_data> jit_program_space_key;\n-\n /* Destructor for jiter_objfile_data.  */\n \n jiter_objfile_data::~jiter_objfile_data ()\n {\n-  jit_program_space_data *ps_data\n-    = jit_program_space_key.get (this->objfile->pspace);\n-\n-  gdb_assert (ps_data != nullptr);\n-  gdb_assert (ps_data->objfile == this->objfile);\n-\n-  ps_data->objfile = nullptr;\n   if (this->jit_breakpoint != nullptr)\n     delete_breakpoint (this->jit_breakpoint);\n }\n@@ -290,20 +270,6 @@ add_objfile_entry (struct objfile *objfile, CORE_ADDR entry)\n   objfile->jited_data.reset (new jited_objfile_data (entry));\n }\n \n-/* Return jit_program_space_data for current program space.  Allocate\n-   if not already present.  */\n-\n-static struct jit_program_space_data *\n-get_jit_program_space_data ()\n-{\n-  struct jit_program_space_data *ps_data;\n-\n-  ps_data = jit_program_space_key.get (current_program_space);\n-  if (ps_data == NULL)\n-    ps_data = jit_program_space_key.emplace (current_program_space);\n-  return ps_data;\n-}\n-\n /* Helper function for reading the global JIT descriptor from remote\n    memory.  Returns true if all went well, false otherwise.  */\n \n@@ -908,15 +874,12 @@ jit_breakpoint_deleted (struct breakpoint *b)\n \n   for (iter = b->loc; iter != NULL; iter = iter->next)\n     {\n-      struct jit_program_space_data *ps_data;\n-\n-      ps_data = jit_program_space_key.get (iter->pspace);\n-      if (ps_data != nullptr && ps_data->objfile != nullptr)\n+      for (objfile *objf : iter->pspace->objfiles ())\n \t{\n-\t  objfile *objf = ps_data->objfile;\n \t  jiter_objfile_data *jiter_data = objf->jiter_data.get ();\n \n-\t  if (jiter_data->jit_breakpoint == iter->owner)\n+\t  if (jiter_data != nullptr\n+\t      && jiter_data->jit_breakpoint == iter->owner)\n \t    {\n \t      jiter_data->cached_code_address = 0;\n \t      jiter_data->jit_breakpoint = nullptr;\n@@ -925,62 +888,55 @@ jit_breakpoint_deleted (struct breakpoint *b)\n     }\n }\n \n-/* (Re-)Initialize the jit breakpoint if necessary.\n-   Return true if the jit breakpoint has been successfully initialized.  */\n+/* (Re-)Initialize the jit breakpoints for JIT-producing objfiles in\n+   PSPACE.  */\n \n-static bool\n-jit_breakpoint_re_set_internal (struct gdbarch *gdbarch,\n-\t\t\t\tstruct jit_program_space_data *ps_data)\n+static void\n+jit_breakpoint_re_set_internal (struct gdbarch *gdbarch, program_space *pspace)\n {\n-  struct bound_minimal_symbol reg_symbol;\n-  struct bound_minimal_symbol desc_symbol;\n   jiter_objfile_data *objf_data;\n-  CORE_ADDR addr;\n \n-  if (ps_data->objfile == NULL)\n+  for (objfile *the_objfile : pspace->objfiles ())\n     {\n       /* Lookup the registration symbol.  If it is missing, then we\n \t assume we are not attached to a JIT.  */\n-      reg_symbol = lookup_bound_minimal_symbol (jit_break_name);\n+      bound_minimal_symbol reg_symbol\n+\t= lookup_minimal_symbol (jit_break_name, nullptr, the_objfile);\n       if (reg_symbol.minsym == NULL\n \t  || BMSYMBOL_VALUE_ADDRESS (reg_symbol) == 0)\n-\treturn false;\n+\tcontinue;\n \n-      desc_symbol = lookup_minimal_symbol (jit_descriptor_name, NULL,\n-\t\t\t\t\t   reg_symbol.objfile);\n+      bound_minimal_symbol desc_symbol\n+\t= lookup_minimal_symbol (jit_descriptor_name, NULL, the_objfile);\n       if (desc_symbol.minsym == NULL\n \t  || BMSYMBOL_VALUE_ADDRESS (desc_symbol) == 0)\n-\treturn false;\n+\tcontinue;\n \n       objf_data = get_jiter_objfile_data (reg_symbol.objfile);\n       objf_data->register_code = reg_symbol.minsym;\n       objf_data->descriptor = desc_symbol.minsym;\n \n-      ps_data->objfile = reg_symbol.objfile;\n-    }\n-  else\n-    objf_data = get_jiter_objfile_data (ps_data->objfile);\n-\n-  addr = MSYMBOL_VALUE_ADDRESS (ps_data->objfile, objf_data->register_code);\n-\n-  if (jit_debug)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"jit_breakpoint_re_set_internal, \"\n-\t\t\t\"breakpoint_addr = %s\\n\",\n-\t\t\tpaddress (gdbarch, addr));\n+      CORE_ADDR addr = MSYMBOL_VALUE_ADDRESS (the_objfile,\n+\t\t\t\t\t      objf_data->register_code);\n \n-  if (objf_data->cached_code_address == addr)\n-    return true;\n+      if (jit_debug)\n+\tfprintf_unfiltered (gdb_stdlog,\n+\t\t\t    \"jit_breakpoint_re_set_internal, \"\n+\t\t\t    \"breakpoint_addr = %s\\n\",\n+\t\t\t    paddress (gdbarch, addr));\n \n-  /* Delete the old breakpoint.  */\n-  if (objf_data->jit_breakpoint != nullptr)\n-    delete_breakpoint (objf_data->jit_breakpoint);\n+      /* Check if we need to re-create the breakpoint.  */\n+      if (objf_data->cached_code_address == addr)\n+\tcontinue;\n \n-  /* Put a breakpoint in the registration symbol.  */\n-  objf_data->cached_code_address = addr;\n-  objf_data->jit_breakpoint = create_jit_event_breakpoint (gdbarch, addr);\n+      /* Delete the old breakpoint.  */\n+      if (objf_data->jit_breakpoint != nullptr)\n+\tdelete_breakpoint (objf_data->jit_breakpoint);\n \n-  return true;\n+      /* Put a breakpoint in the registration symbol.  */\n+      objf_data->cached_code_address = addr;\n+      objf_data->jit_breakpoint = create_jit_event_breakpoint (gdbarch, addr);\n+    }\n }\n \n /* The private data passed around in the frame unwind callback\n@@ -1219,50 +1175,50 @@ jit_inferior_init (struct gdbarch *gdbarch)\n {\n   struct jit_descriptor descriptor;\n   struct jit_code_entry cur_entry;\n-  struct jit_program_space_data *ps_data;\n   CORE_ADDR cur_entry_addr;\n \n   if (jit_debug)\n     fprintf_unfiltered (gdb_stdlog, \"jit_inferior_init\\n\");\n \n   jit_prepend_unwinder (gdbarch);\n \n-  ps_data = get_jit_program_space_data ();\n-  if (!jit_breakpoint_re_set_internal (gdbarch, ps_data))\n-    return;\n+  jit_breakpoint_re_set_internal (gdbarch, current_program_space);\n \n-  /* There must be a JITer registered, otherwise we would exit early\n-     above.  */\n-  objfile *jiter = ps_data->objfile;\n+  for (objfile *jiter : current_program_space->objfiles ())\n+    {\n+      if (jiter->jiter_data == nullptr)\n+\tcontinue;\n \n-  /* Read the descriptor so we can check the version number and load\n-     any already JITed functions.  */\n-  if (!jit_read_descriptor (gdbarch, &descriptor, jiter))\n-    return;\n+      /* Read the descriptor so we can check the version number and load\n+\t any already JITed functions.  */\n+      if (!jit_read_descriptor (gdbarch, &descriptor, jiter))\n+\tcontinue;\n \n-  /* Check that the version number agrees with that we support.  */\n-  if (descriptor.version != 1)\n-    {\n-      printf_unfiltered (_(\"Unsupported JIT protocol version %ld \"\n-\t\t\t   \"in descriptor (expected 1)\\n\"),\n-\t\t\t (long) descriptor.version);\n-      return;\n-    }\n+      /* Check that the version number agrees with that we support.  */\n+      if (descriptor.version != 1)\n+\t{\n+\t  printf_unfiltered (_(\"Unsupported JIT protocol version %ld \"\n+\t\t\t       \"in descriptor (expected 1)\\n\"),\n+\t\t\t     (long) descriptor.version);\n+\t  continue;\n+\t}\n \n-  /* If we've attached to a running program, we need to check the descriptor\n-     to register any functions that were already generated.  */\n-  for (cur_entry_addr = descriptor.first_entry;\n-       cur_entry_addr != 0;\n-       cur_entry_addr = cur_entry.next_entry)\n-    {\n-      jit_read_code_entry (gdbarch, cur_entry_addr, &cur_entry);\n+      /* If we've attached to a running program, we need to check the\n+\t descriptor to register any functions that were already\n+\t generated.  */\n+      for (cur_entry_addr = descriptor.first_entry;\n+\t   cur_entry_addr != 0;\n+\t   cur_entry_addr = cur_entry.next_entry)\n+\t{\n+\t  jit_read_code_entry (gdbarch, cur_entry_addr, &cur_entry);\n \n-      /* This hook may be called many times during setup, so make sure we don't\n-\t add the same symbol file twice.  */\n-      if (jit_find_objf_with_entry_addr (cur_entry_addr) != NULL)\n-\tcontinue;\n+\t  /* This hook may be called many times during setup, so make sure\n+\t     we don't add the same symbol file twice.  */\n+\t  if (jit_find_objf_with_entry_addr (cur_entry_addr) != NULL)\n+\t    continue;\n \n-      jit_register_code (gdbarch, cur_entry_addr, &cur_entry);\n+\t  jit_register_code (gdbarch, cur_entry_addr, &cur_entry);\n+\t}\n     }\n }\n \n@@ -1288,8 +1244,7 @@ jit_inferior_created_hook (void)\n void\n jit_breakpoint_re_set (void)\n {\n-  jit_breakpoint_re_set_internal (target_gdbarch (),\n-\t\t\t\t  get_jit_program_space_data ());\n+  jit_breakpoint_re_set_internal (target_gdbarch (), current_program_space);\n }\n \n /* This function cleans up any code entries left over when the"
    },
    {
      "sha": "c83dc40d12ee237b1d791bf6da609f5ff4873064",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c8474dc35380ff7426ec4c555512c098fa70dd04/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c8474dc35380ff7426ec4c555512c098fa70dd04/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=c8474dc35380ff7426ec4c555512c098fa70dd04",
      "patch": "@@ -1,3 +1,8 @@\n+2020-07-22  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* gdb.base/jit-reader-simple.exp: Add a scenario for a binary that\n+\tloads two JITers.\n+\n 2020-07-21  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.python/py-arch-reg-groups.exp: Additional tests."
    },
    {
      "sha": "a8f33c6d7a8137ce64e7aab4a4df782a114c0975",
      "filename": "gdb/testsuite/gdb.base/jit-reader-simple.exp",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c8474dc35380ff7426ec4c555512c098fa70dd04/gdb/testsuite/gdb.base/jit-reader-simple.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c8474dc35380ff7426ec4c555512c098fa70dd04/gdb/testsuite/gdb.base/jit-reader-simple.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/jit-reader-simple.exp?ref=c8474dc35380ff7426ec4c555512c098fa70dd04",
      "patch": "@@ -34,6 +34,7 @@ standard_testfile\n set libname $testfile-jit\n set srcfile_lib $srcdir/$subdir/$libname.c\n set binfile_lib [standard_output_file $libname.so]\n+set binfile_lib2 [standard_output_file ${libname}2.so]\n \n # Build a standalone JIT binary.\n \n@@ -53,12 +54,15 @@ proc build_standalone_jit {{options \"\"}} {\n \n proc build_shared_jit {{options \"\"}} {\n     global testfile\n-    global srcfile_lib binfile_lib\n+    global srcfile_lib binfile_lib binfile_lib2\n \n     lappend options \"debug additional_flags=-fPIC\"\n     if { [gdb_compile_shlib $srcfile_lib $binfile_lib $options] != \"\" } {\n \treturn -1\n     }\n+    if { [gdb_compile_shlib $srcfile_lib $binfile_lib2 $options] != \"\" } {\n+\treturn -1\n+    }\n \n     return 0\n }\n@@ -83,6 +87,15 @@ if {[gdb_compile ${srcdir}/${subdir}/${srcfile_dl} $binfile_dl executable \\\n     return -1\n }\n \n+# Build the program that loads *two* JIT libraries.\n+set binfile_dl2 $binfile-dl2\n+set options [list debug shlib=${binfile_lib} shlib=${binfile_lib2}]\n+if {[gdb_compile ${srcdir}/${subdir}/${srcfile_dl} $binfile_dl2 executable \\\n+\t $options] == -1 } {\n+    untested \"failed to compile two-jitter binary\"\n+    return -1\n+}\n+\n # STANDALONE is true when the JIT reader is included directly in the\n # main program.  False when the JIT reader is in a separate shared\n # library.  If CHANGE_ADDR is true, force changing the JIT descriptor\n@@ -160,3 +173,31 @@ foreach standalone {1 0} {\n \t}\n     }\n }\n+\n+# Now start the program that loads two JITer libraries and expect to\n+# see JIT breakpoints defined for both.\n+\n+with_test_prefix \"two JITers\" {\n+    clean_restart $binfile_dl2\n+\n+    if {![runto_main]} {\n+\tuntested \"could not run to main\"\n+\treturn -1\n+    }\n+\n+    set num_bps 0\n+    set ws \"\\[ \\t\\]+\"\n+    gdb_test_multiple \"maint info breakpoints\" \"have two jit breakpoints\" {\n+\t-re \"jit events${ws}keep y${ws}$hex <__jit_debug_register_code> inf 1\\r\\n\" {\n+\t    incr num_bps\n+\t    exp_continue\n+\t}\n+\t-re \"$gdb_prompt $\" {\n+\t    if {$num_bps == 2} {\n+\t\tpass $gdb_test_name\n+\t    } else {\n+\t\tfail $gdb_test_name\n+\t    }\n+\t}\n+    }\n+}"
    }
  ]
}