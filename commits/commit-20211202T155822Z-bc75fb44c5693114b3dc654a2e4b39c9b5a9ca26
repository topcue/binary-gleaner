{
  "sha": "bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
  "node_id": "C_kwDOANOeidoAKGJjNzVmYjQ0YzU2OTMxMTRiM2RjNjU0YTJlNGIzOWM5YjVhOWNhMjY",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-08-30T12:24:12Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-12-02T15:58:22Z"
    },
    "message": "Implement 'task apply'\n\nThis adds a 'task apply' command, which is the Ada tasking analogue of\n'thread apply'.  Unlike 'thread apply', it doesn't offer the\n'ascending' flag; but otherwise it's essentially the same.",
    "tree": {
      "sha": "88521df79005aa37964020587b7c288f432fc1ef",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/88521df79005aa37964020587b7c288f432fc1ef"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8a18382f94515b4be7e51dbe3865d202403d21d5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8a18382f94515b4be7e51dbe3865d202403d21d5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8a18382f94515b4be7e51dbe3865d202403d21d5"
    }
  ],
  "stats": {
    "total": 295,
    "additions": 277,
    "deletions": 18
  },
  "files": [
    {
      "sha": "13b662868764b8b9e4138058e783694f31f380d5",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
      "patch": "@@ -24,6 +24,9 @@ show varsize-limit\n   These are now deprecated aliases for \"set max-value-size\" and\n   \"show max-value-size\".\n \n+task apply [all | TASK-IDS...] [FLAG]... COMMAND\n+  Like \"thread apply\", but applies COMMAND to Ada tasks.\n+\n watch [...] task ID\n   Watchpoints can now be restricted to a specific Ada task.\n "
    },
    {
      "sha": "519878ad06180990b8d12ee962ac77288b427972",
      "filename": "gdb/ada-tasks.c",
      "status": "modified",
      "additions": 201,
      "deletions": 3,
      "changes": 204,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/ada-tasks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/ada-tasks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-tasks.c?ref=bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
      "patch": "@@ -1472,6 +1472,163 @@ ada_tasks_new_objfile_observer (struct objfile *objfile)\n       ada_tasks_invalidate_inferior_data (inf);\n }\n \n+/* The qcs command line flags for the \"task apply\" commands.  Keep\n+   this in sync with the \"frame apply\" commands.  */\n+\n+using qcs_flag_option_def\n+  = gdb::option::flag_option_def<qcs_flags>;\n+\n+static const gdb::option::option_def task_qcs_flags_option_defs[] = {\n+  qcs_flag_option_def {\n+    \"q\", [] (qcs_flags *opt) { return &opt->quiet; },\n+    N_(\"Disables printing the task information.\"),\n+  },\n+\n+  qcs_flag_option_def {\n+    \"c\", [] (qcs_flags *opt) { return &opt->cont; },\n+    N_(\"Print any error raised by COMMAND and continue.\"),\n+  },\n+\n+  qcs_flag_option_def {\n+    \"s\", [] (qcs_flags *opt) { return &opt->silent; },\n+    N_(\"Silently ignore any errors or empty output produced by COMMAND.\"),\n+  },\n+};\n+\n+/* Create an option_def_group for the \"task apply all\" options, with\n+   FLAGS as context.  */\n+\n+static inline std::array<gdb::option::option_def_group, 1>\n+make_task_apply_all_options_def_group (qcs_flags *flags)\n+{\n+  return {{\n+    { {task_qcs_flags_option_defs}, flags },\n+  }};\n+}\n+\n+/* Create an option_def_group for the \"task apply\" options, with\n+   FLAGS as context.  */\n+\n+static inline gdb::option::option_def_group\n+make_task_apply_options_def_group (qcs_flags *flags)\n+{\n+  return {{task_qcs_flags_option_defs}, flags};\n+}\n+\n+/* Implementation of 'task apply all'.  */\n+\n+static void\n+task_apply_all_command (const char *cmd, int from_tty)\n+{\n+  qcs_flags flags;\n+\n+  auto group = make_task_apply_all_options_def_group (&flags);\n+  gdb::option::process_options\n+    (&cmd, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_OPERAND, group);\n+\n+  validate_flags_qcs (\"task apply all\", &flags);\n+\n+  if (cmd == nullptr || *cmd == '\\0')\n+    error (_(\"Please specify a command at the end of 'task apply all'\"));\n+\n+  update_thread_list ();\n+  ada_build_task_list ();\n+\n+  inferior *inf = current_inferior ();\n+  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);\n+\n+  /* Save a copy of the thread list and increment each thread's\n+     refcount while executing the command in the context of each\n+     thread, in case the command affects this.  */\n+  std::vector<std::pair<int, thread_info_ref>> thr_list_cpy;\n+\n+  for (int i = 1; i <= data->task_list.size (); ++i)\n+    {\n+      ada_task_info &task = data->task_list[i - 1];\n+      if (!ada_task_is_alive (&task))\n+\tcontinue;\n+\n+      thread_info *tp = find_thread_ptid (inf, task.ptid);\n+      if (tp == nullptr)\n+\twarning (_(\"Unable to compute thread ID for task %s.\\n\"\n+\t\t   \"Cannot switch to this task.\"),\n+\t\t task_to_str (i, &task).c_str ());\n+      else\n+\tthr_list_cpy.emplace_back (i, thread_info_ref::new_reference (tp));\n+    }\n+\n+  scoped_restore_current_thread restore_thread;\n+\n+  for (const auto &info : thr_list_cpy)\n+    if (switch_to_thread_if_alive (info.second.get ()))\n+      thread_try_catch_cmd (info.second.get (), info.first, cmd,\n+\t\t\t    from_tty, flags);\n+}\n+\n+/* Implementation of 'task apply'.  */\n+\n+static void\n+task_apply_command (const char *tidlist, int from_tty)\n+{\n+\n+  if (tidlist == nullptr || *tidlist == '\\0')\n+    error (_(\"Please specify a task ID list\"));\n+\n+  update_thread_list ();\n+  ada_build_task_list ();\n+\n+  inferior *inf = current_inferior ();\n+  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);\n+\n+  /* Save a copy of the thread list and increment each thread's\n+     refcount while executing the command in the context of each\n+     thread, in case the command affects this.  */\n+  std::vector<std::pair<int, thread_info_ref>> thr_list_cpy;\n+\n+  number_or_range_parser parser (tidlist);\n+  while (!parser.finished ())\n+    {\n+      int num = parser.get_number ();\n+\n+      if (num < 1 || num - 1 >= data->task_list.size ())\n+\twarning (_(\"no Ada Task with number %d\"), num);\n+      else\n+\t{\n+\t  ada_task_info &task = data->task_list[num - 1];\n+\t  if (!ada_task_is_alive (&task))\n+\t    continue;\n+\n+\t  thread_info *tp = find_thread_ptid (inf, task.ptid);\n+\t  if (tp == nullptr)\n+\t    warning (_(\"Unable to compute thread ID for task %s.\\n\"\n+\t\t       \"Cannot switch to this task.\"),\n+\t\t     task_to_str (num, &task).c_str ());\n+\t  else\n+\t    thr_list_cpy.emplace_back (num,\n+\t\t\t\t       thread_info_ref::new_reference (tp));\n+\t}\n+    }\n+\n+  qcs_flags flags;\n+  const char *cmd = parser.cur_tok ();\n+\n+  auto group = make_task_apply_options_def_group (&flags);\n+  gdb::option::process_options\n+    (&cmd, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_OPERAND, group);\n+\n+  validate_flags_qcs (\"task apply\", &flags);\n+\n+  if (*cmd == '\\0')\n+    error (_(\"Please specify a command following the task ID list\"));\n+\n+  scoped_restore_current_thread restore_thread;\n+\n+  for (const auto &info : thr_list_cpy)\n+    if (switch_to_thread_if_alive (info.second.get ()))\n+      thread_try_catch_cmd (info.second.get (), info.first, cmd,\n+\t\t\t    from_tty, flags);\n+}\n+\n void _initialize_tasks ();\n void\n _initialize_tasks ()\n@@ -1482,11 +1639,52 @@ _initialize_tasks ()\n   gdb::observers::new_objfile.attach (ada_tasks_new_objfile_observer,\n \t\t\t\t      \"ada-tasks\");\n \n+  static struct cmd_list_element *task_cmd_list;\n+  static struct cmd_list_element *task_apply_list;\n+\n+\n   /* Some new commands provided by this module.  */\n   add_info (\"tasks\", info_tasks_command,\n \t    _(\"Provide information about all known Ada tasks.\"));\n-  add_cmd (\"task\", class_run, task_command,\n-\t   _(\"Use this command to switch between Ada tasks.\\n\\\n+\n+  add_prefix_cmd (\"task\", class_run, task_command,\n+\t\t  _(\"Use this command to switch between Ada tasks.\\n\\\n Without argument, this command simply prints the current task ID.\"),\n-\t   &cmdlist);\n+\t\t  &task_cmd_list, 1, &cmdlist);\n+\n+#define TASK_APPLY_OPTION_HELP \"\\\n+Prints per-inferior task number followed by COMMAND output.\\n\\\n+\\n\\\n+By default, an error raised during the execution of COMMAND\\n\\\n+aborts \\\"task apply\\\".\\n\\\n+\\n\\\n+Options:\\n\\\n+%OPTIONS%\"\n+\n+  static const auto task_apply_opts\n+    = make_task_apply_options_def_group (nullptr);\n+\n+  static std::string task_apply_help = gdb::option::build_help (_(\"\\\n+Apply a command to a list of tasks.\\n\\\n+Usage: task apply ID... [OPTION]... COMMAND\\n\\\n+ID is a space-separated list of IDs of tasks to apply COMMAND on.\\n\"\n+TASK_APPLY_OPTION_HELP), task_apply_opts);\n+\n+  add_prefix_cmd (\"apply\", class_run,\n+\t\t  task_apply_command,\n+\t\t  task_apply_help.c_str (),\n+\t\t  &task_apply_list, 1,\n+\t\t  &task_cmd_list);\n+\n+  static const auto task_apply_all_opts\n+    = make_task_apply_all_options_def_group (nullptr);\n+\n+  static std::string task_apply_all_help = gdb::option::build_help (_(\"\\\n+Apply a command to all tasks in the current inferior.\\n\\\n+\\n\\\n+Usage: task apply all [OPTION]... COMMAND\\n\"\n+TASK_APPLY_OPTION_HELP), task_apply_all_opts);\n+\n+  add_cmd (\"all\", class_run, task_apply_all_command,\n+\t   task_apply_all_help.c_str (), &task_apply_list);\n }"
    },
    {
      "sha": "d0c5bcf18e1d6020ac3040dcfa894458a81439b4",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
      "patch": "@@ -18537,6 +18537,41 @@ from the current task to the given task.\n #4  0x804aacc in un () at un.adb:5\n @end smallexample\n \n+@item task apply [@var{task-id-list} | all] [@var{flag}]@dots{} @var{command}\n+The @code{task apply} command is the Ada tasking analogue of\n+@code{thread apply} (@pxref{Threads}).  It allows you to apply the\n+named @var{command} to one or more tasks.  Specify the tasks that you\n+want affected using a list of task IDs, or specify @code{all} to apply\n+to all tasks.\n+\n+The @var{flag} arguments control what output to produce and how to\n+handle errors raised when applying @var{command} to a task.\n+@var{flag} must start with a @code{-} directly followed by one letter\n+in @code{qcs}.  If several flags are provided, they must be given\n+individually, such as @code{-c -q}.\n+\n+By default, @value{GDBN} displays some task information before the\n+output produced by @var{command}, and an error raised during the\n+execution of a @var{command} will abort @code{task apply}.  The\n+following flags can be used to fine-tune this behavior:\n+\n+@table @code\n+@item -c\n+The flag @code{-c}, which stands for @samp{continue}, causes any\n+errors in @var{command} to be displayed, and the execution of\n+@code{task apply} then continues.\n+@item -s\n+The flag @code{-s}, which stands for @samp{silent}, causes any errors\n+or empty output produced by a @var{command} to be silently ignored.\n+That is, the execution continues, but the task information and errors\n+are not printed.\n+@item -q\n+The flag @code{-q} (@samp{quiet}) disables printing the task\n+information.\n+@end table\n+\n+Flags @code{-c} and @code{-s} cannot be used together.\n+\n @item break @var{location} task @var{taskno}\n @itemx break @var{location} task @var{taskno} if @dots{}\n @cindex breakpoints and tasks, in Ada"
    },
    {
      "sha": "e229a5f09bd4f5f0f122562ba8162fcd8b273448",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
      "patch": "@@ -975,4 +975,21 @@ extern void thread_select (const char *tidstr, class thread_info *thr);\n    target to get the name.  May return nullptr.  */\n extern const char *thread_name (thread_info *thread);\n \n+/* Switch to thread TP if it is alive.  Returns true if successfully\n+   switched, false otherwise.  */\n+\n+extern bool switch_to_thread_if_alive (thread_info *thr);\n+\n+/* Assuming that THR is the current thread, execute CMD.\n+   If ADA_TASK is not empty, it is the Ada task ID, and will\n+   be printed instead of the thread information.\n+   FLAGS.QUIET controls the printing of the thread information.\n+   FLAGS.CONT and FLAGS.SILENT control how to handle errors.  Can throw an\n+   exception if !FLAGS.SILENT and !FLAGS.CONT and CMD fails.  */\n+\n+extern void thread_try_catch_cmd (thread_info *thr,\n+\t\t\t\t  gdb::optional<int> ada_task,\n+\t\t\t\t  const char *cmd, int from_tty,\n+\t\t\t\t  const qcs_flags &flags);\n+\n #endif /* GDBTHREAD_H */"
    },
    {
      "sha": "821adef4b1ae5de59f687b059f2663d7ac98dcf6",
      "filename": "gdb/testsuite/gdb.ada/rdv_wait.exp",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/testsuite/gdb.ada/rdv_wait.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/testsuite/gdb.ada/rdv_wait.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/rdv_wait.exp?ref=bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
      "patch": "@@ -35,3 +35,8 @@ runto \"break_me\"\n gdb_test \"task 2\" \\\n          [join {\"\\\\\\[Switching to task 2 \\\"mit\\\"\\\\\\].*\" \\\n                 \".*foo\\\\.t \\\\(.*\\\\).*foo\\\\.adb:.*\"} \"\"]\n+\n+gdb_test \"task apply 1 -q frame\" \".*pck\\\\.break_me.*\"\n+\n+gdb_test \"task apply all frame\" \\\n+    \"Task ID 1:.*pck\\\\.break_me.*Task ID 2:.*\""
    },
    {
      "sha": "6c792eccb8f69e450c12035a9a49e9b4db481718",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 16,
      "deletions": 15,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=bc75fb44c5693114b3dc654a2e4b39c9b5a9ca26",
      "patch": "@@ -662,10 +662,9 @@ thread_alive (thread_info *tp)\n   return target_thread_alive (tp->ptid);\n }\n \n-/* Switch to thread TP if it is alive.  Returns true if successfully\n-   switched, false otherwise.  */\n+/* See gdbthreads.h.  */\n \n-static bool\n+bool\n switch_to_thread_if_alive (thread_info *thr)\n {\n   scoped_restore_current_thread restore_thread;\n@@ -1428,23 +1427,25 @@ tp_array_compar_descending (const thread_info_ref &a, const thread_info_ref &b)\n   return (a->per_inf_num > b->per_inf_num);\n }\n \n-/* Assuming that THR is the current thread, execute CMD.\n-   FLAGS.QUIET controls the printing of the thread information.\n-   FLAGS.CONT and FLAGS.SILENT control how to handle errors.  Can throw an\n-   exception if !FLAGS.SILENT and !FLAGS.CONT and CMD fails.  */\n+/* See gdbthread.h.  */\n \n-static void\n-thr_try_catch_cmd (thread_info *thr, const char *cmd, int from_tty,\n-\t\t   const qcs_flags &flags)\n+void\n+thread_try_catch_cmd (thread_info *thr, gdb::optional<int> ada_task,\n+\t\t      const char *cmd, int from_tty,\n+\t\t      const qcs_flags &flags)\n {\n   gdb_assert (is_current_thread (thr));\n \n   /* The thread header is computed before running the command since\n      the command can change the inferior, which is not permitted\n      by thread_target_id_str.  */\n-  std::string thr_header =\n-    string_printf (_(\"\\nThread %s (%s):\\n\"), print_thread_id (thr),\n-\t\t   thread_target_id_str (thr).c_str ());\n+  std::string thr_header;\n+  if (ada_task.has_value ())\n+    thr_header = string_printf (_(\"\\nTask ID %d:\\n\"), *ada_task);\n+  else\n+    thr_header = string_printf (_(\"\\nThread %s (%s):\\n\"),\n+\t\t\t\tprint_thread_id (thr),\n+\t\t\t\tthread_target_id_str (thr).c_str ());\n \n   try\n     {\n@@ -1576,7 +1577,7 @@ thread_apply_all_command (const char *cmd, int from_tty)\n \n       for (thread_info_ref &thr : thr_list_cpy)\n \tif (switch_to_thread_if_alive (thr.get ()))\n-\t  thr_try_catch_cmd (thr.get (), cmd, from_tty, flags);\n+\t  thread_try_catch_cmd (thr.get (), {}, cmd, from_tty, flags);\n     }\n }\n \n@@ -1738,7 +1739,7 @@ thread_apply_command (const char *tidlist, int from_tty)\n \t  continue;\n \t}\n \n-      thr_try_catch_cmd (tp, cmd, from_tty, flags);\n+      thread_try_catch_cmd (tp, {}, cmd, from_tty, flags);\n     }\n }\n "
    }
  ]
}