{
  "sha": "b026f59345a336cabf74719fce9f96cab7c7ab4d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjAyNmY1OTM0NWEzMzZjYWJmNzQ3MTlmY2U5Zjk2Y2FiN2M3YWI0ZA==",
  "commit": {
    "author": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2019-01-10T21:57:08Z"
    },
    "committer": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2019-01-10T21:57:08Z"
    },
    "message": "gdb/23712: Use new multidictionary API\n\nThis patch builds on the previous by enabling the `new' multidictionary\nAPI.  A lot of the hunks are simply textual replacements of \"dict_\"\nwith \"mdict_\" and similar transformations.\n\nA word of warning, even with the use of multidictionaries, the code\nstill does not satisfactorily fix the reported problems with gdb/23712\n(or gdb/23010). We still have additional changes to make before that\nhappens.\n\ngdb/ChangeLog:\n\n\tPR gdb/23712\n\tPR symtab/23010\n\t* dictionary.h (struct dictionary): Replace declaration with\n\tmultidictionary.\n\t(dict_create_hashed, dict_create_hashed_expandable)\n\t(dict_create_linear, dict_create_linear_expandable)\n\t(dict_free, dict_add_symbol, dict_add_pending, dict_empty)\n\t(dict_iterator_first, dict_iterator_next, dict_iter_match_first)\n\t(dict_iter_match_next, dict_size): Rename to \"mdict_\" versions\n\ttaking multidictionary argument.\n\t[ALL_DICT_SYMBOLS]: Update for multidictionary.\n\t* block.h (struct block) <dict>: Change to multidictionary\n\tand rename `multidict'.\n\t* block.c, buildsym.c, jit.c, mdebugread.c, objfiles.c,\n\tsymmisc.c: Update all dictionary references to multidictionary.",
    "tree": {
      "sha": "206e3e42bdc820ddd089ef01bcefb4b73a936460",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/206e3e42bdc820ddd089ef01bcefb4b73a936460"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b026f59345a336cabf74719fce9f96cab7c7ab4d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b026f59345a336cabf74719fce9f96cab7c7ab4d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b026f59345a336cabf74719fce9f96cab7c7ab4d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b026f59345a336cabf74719fce9f96cab7c7ab4d/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "c7748ee9ceb5a394658cd07aeb0445924599e442",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c7748ee9ceb5a394658cd07aeb0445924599e442",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c7748ee9ceb5a394658cd07aeb0445924599e442"
    }
  ],
  "stats": {
    "total": 232,
    "additions": 125,
    "deletions": 107
  },
  "files": [
    {
      "sha": "c7650ca924ccbb292742481c132bef0d2ebddfb2",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -1,3 +1,21 @@\n+2019-01-10  Keith Seitz  <keiths@redhat.com>\n+\n+\tPR gdb/23712\n+\tPR symtab/23010\n+\t* dictionary.h (struct dictionary): Replace declaration with\n+\tmultidictionary.\n+\t(dict_create_hashed, dict_create_hashed_expandable)\n+\t(dict_create_linear, dict_create_linear_expandable)\n+\t(dict_free, dict_add_symbol, dict_add_pending, dict_empty)\n+\t(dict_iterator_first, dict_iterator_next, dict_iter_match_first)\n+\t(dict_iter_match_next, dict_size): Rename to \"mdict_\" versions\n+\ttaking multidictionary argument.\n+\t[ALL_DICT_SYMBOLS]: Update for multidictionary.\n+\t* block.h (struct block) <dict>: Change to multidictionary\n+\tand rename `multidict'.\n+\t* block.c, buildsym.c, jit.c, mdebugread.c, objfiles.c,\n+\tsymmisc.c: Update all dictionary references to multidictionary.\n+\n 2019-01-10  Keith Seitz  <keiths@redhat.com>\n \n \tPR gdb/23712"
    },
    {
      "sha": "3192b33e9e9c3c71e33b9b864784cd2fae01cf45",
      "filename": "gdb/block.c",
      "status": "modified",
      "additions": 17,
      "deletions": 14,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/block.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/block.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/block.c?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -387,9 +387,9 @@ block_global_block (const struct block *block)\n    zero/NULL.  This is useful for creating \"dummy\" blocks that don't\n    correspond to actual source files.\n \n-   Warning: it sets the block's BLOCK_DICT to NULL, which isn't a\n+   Warning: it sets the block's BLOCK_MULTIDICT to NULL, which isn't a\n    valid value.  If you really don't want the block to have a\n-   dictionary, then you should subsequently set its BLOCK_DICT to\n+   dictionary, then you should subsequently set its BLOCK_MULTIDICT to\n    dict_create_linear (obstack, NULL).  */\n \n struct block *\n@@ -544,10 +544,11 @@ block_iterator_step (struct block_iterator *iterator, int first)\n \n \t  block = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust),\n \t\t\t\t     iterator->which);\n-\t  sym = dict_iterator_first (BLOCK_DICT (block), &iterator->dict_iter);\n+\t  sym = mdict_iterator_first (BLOCK_MULTIDICT (block),\n+\t\t\t\t      &iterator->mdict_iter);\n \t}\n       else\n-\tsym = dict_iterator_next (&iterator->dict_iter);\n+\tsym = mdict_iterator_next (&iterator->mdict_iter);\n \n       if (sym != NULL)\n \treturn sym;\n@@ -569,7 +570,7 @@ block_iterator_first (const struct block *block,\n   initialize_block_iterator (block, iterator);\n \n   if (iterator->which == FIRST_LOCAL_BLOCK)\n-    return dict_iterator_first (block->dict, &iterator->dict_iter);\n+    return mdict_iterator_first (block->multidict, &iterator->mdict_iter);\n \n   return block_iterator_step (iterator, 1);\n }\n@@ -580,7 +581,7 @@ struct symbol *\n block_iterator_next (struct block_iterator *iterator)\n {\n   if (iterator->which == FIRST_LOCAL_BLOCK)\n-    return dict_iterator_next (&iterator->dict_iter);\n+    return mdict_iterator_next (&iterator->mdict_iter);\n \n   return block_iterator_step (iterator, 0);\n }\n@@ -612,11 +613,11 @@ block_iter_match_step (struct block_iterator *iterator,\n \n \t  block = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust),\n \t\t\t\t     iterator->which);\n-\t  sym = dict_iter_match_first (BLOCK_DICT (block), name,\n-\t\t\t\t       &iterator->dict_iter);\n+\t  sym = mdict_iter_match_first (BLOCK_MULTIDICT (block), name,\n+\t\t\t\t\t&iterator->mdict_iter);\n \t}\n       else\n-\tsym = dict_iter_match_next (name, &iterator->dict_iter);\n+\tsym = mdict_iter_match_next (name, &iterator->mdict_iter);\n \n       if (sym != NULL)\n \treturn sym;\n@@ -639,7 +640,8 @@ block_iter_match_first (const struct block *block,\n   initialize_block_iterator (block, iterator);\n \n   if (iterator->which == FIRST_LOCAL_BLOCK)\n-    return dict_iter_match_first (block->dict, name, &iterator->dict_iter);\n+    return mdict_iter_match_first (block->multidict, name,\n+\t\t\t\t   &iterator->mdict_iter);\n \n   return block_iter_match_step (iterator, name, 1);\n }\n@@ -651,7 +653,7 @@ block_iter_match_next (const lookup_name_info &name,\n \t\t       struct block_iterator *iterator)\n {\n   if (iterator->which == FIRST_LOCAL_BLOCK)\n-    return dict_iter_match_next (name, &iterator->dict_iter);\n+    return mdict_iter_match_next (name, &iterator->mdict_iter);\n \n   return block_iter_match_step (iterator, name, 0);\n }\n@@ -731,7 +733,7 @@ block_lookup_symbol_primary (const struct block *block, const char *name,\n \t\t\t     const domain_enum domain)\n {\n   struct symbol *sym, *other;\n-  struct dict_iterator dict_iter;\n+  struct mdict_iterator mdict_iter;\n \n   lookup_name_info lookup_name (name, symbol_name_match_type::FULL);\n \n@@ -740,9 +742,10 @@ block_lookup_symbol_primary (const struct block *block, const char *name,\n \t      || BLOCK_SUPERBLOCK (BLOCK_SUPERBLOCK (block)) == NULL);\n \n   other = NULL;\n-  for (sym = dict_iter_match_first (block->dict, lookup_name, &dict_iter);\n+  for (sym\n+\t = mdict_iter_match_first (block->multidict, lookup_name, &mdict_iter);\n        sym != NULL;\n-       sym = dict_iter_match_next (lookup_name, &dict_iter))\n+       sym = mdict_iter_match_next (lookup_name, &mdict_iter))\n     {\n       if (SYMBOL_DOMAIN (sym) == domain)\n \treturn sym;"
    },
    {
      "sha": "d32114b9f5952d9e4bc0385c8528437c604a4242",
      "filename": "gdb/block.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/block.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/block.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/block.h?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -111,7 +111,7 @@ struct block\n \n   /* This is used to store the symbols in the block.  */\n \n-  struct dictionary *dict;\n+  struct multidictionary *multidict;\n \n   /* Contains information about namespace-related info relevant to this block:\n      using directives and the current namespace scope.  */\n@@ -143,7 +143,7 @@ struct global_block\n #define BLOCK_END(bl)\t\t(bl)->endaddr\n #define BLOCK_FUNCTION(bl)\t(bl)->function\n #define BLOCK_SUPERBLOCK(bl)\t(bl)->superblock\n-#define BLOCK_DICT(bl)\t\t(bl)->dict\n+#define BLOCK_MULTIDICT(bl)\t(bl)->multidict\n #define BLOCK_NAMESPACE(bl)\t(bl)->namespace_info\n \n /* Accessor for ranges field within block BL.  */\n@@ -298,9 +298,9 @@ struct block_iterator\n \n   enum block_enum which;\n \n-  /* The underlying dictionary iterator.  */\n+  /* The underlying multidictionary iterator.  */\n \n-  struct dict_iterator dict_iter;\n+  struct mdict_iterator mdict_iter;\n };\n \n /* Initialize ITERATOR to point at the first symbol in BLOCK, and"
    },
    {
      "sha": "bd0f25e061e5bd930e305a7292d7df408c0ac319",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 13,
      "deletions": 15,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -227,22 +227,20 @@ buildsym_compunit::finish_block_internal\n \n   if (symbol)\n     {\n-      BLOCK_DICT (block)\n-\t= dict_create_linear (&m_objfile->objfile_obstack,\n-\t\t\t      m_language, *listhead);\n+      BLOCK_MULTIDICT (block)\n+\t= mdict_create_linear (&m_objfile->objfile_obstack, *listhead);\n     }\n   else\n     {\n       if (expandable)\n \t{\n-\t  BLOCK_DICT (block) = dict_create_hashed_expandable (m_language);\n-\t  dict_add_pending (BLOCK_DICT (block), *listhead);\n+\t  BLOCK_MULTIDICT (block) = mdict_create_hashed_expandable (m_language);\n+\t  mdict_add_pending (BLOCK_MULTIDICT (block), *listhead);\n \t}\n       else\n \t{\n-\t  BLOCK_DICT (block) =\n-\t    dict_create_hashed (&m_objfile->objfile_obstack,\n-\t\t\t\tm_language, *listhead);\n+\t  BLOCK_MULTIDICT (block) =\n+\t    mdict_create_hashed (&m_objfile->objfile_obstack, *listhead);\n \t}\n     }\n \n@@ -254,7 +252,7 @@ buildsym_compunit::finish_block_internal\n   if (symbol)\n     {\n       struct type *ftype = SYMBOL_TYPE (symbol);\n-      struct dict_iterator iter;\n+      struct mdict_iterator miter;\n       SYMBOL_BLOCK_VALUE (symbol) = block;\n       BLOCK_FUNCTION (block) = symbol;\n \n@@ -268,7 +266,7 @@ buildsym_compunit::finish_block_internal\n \n \t  /* Here we want to directly access the dictionary, because\n \t     we haven't fully initialized the block yet.  */\n-\t  ALL_DICT_SYMBOLS (BLOCK_DICT (block), iter, sym)\n+\t  ALL_DICT_SYMBOLS (BLOCK_MULTIDICT (block), miter, sym)\n \t    {\n \t      if (SYMBOL_IS_ARGUMENT (sym))\n \t\tnparams++;\n@@ -282,7 +280,7 @@ buildsym_compunit::finish_block_internal\n \t      iparams = 0;\n \t      /* Here we want to directly access the dictionary, because\n \t\t we haven't fully initialized the block yet.  */\n-\t      ALL_DICT_SYMBOLS (BLOCK_DICT (block), iter, sym)\n+\t      ALL_DICT_SYMBOLS (BLOCK_MULTIDICT (block), miter, sym)\n \t\t{\n \t\t  if (iparams == nparams)\n \t\t    break;\n@@ -1066,7 +1064,7 @@ buildsym_compunit::end_symtab_with_blockvector (struct block *static_block,\n       {\n \tstruct block *block = BLOCKVECTOR_BLOCK (blockvector, block_i);\n \tstruct symbol *sym;\n-\tstruct dict_iterator iter;\n+\tstruct mdict_iterator miter;\n \n \t/* Inlined functions may have symbols not in the global or\n \t   static symbol lists.  */\n@@ -1077,7 +1075,7 @@ buildsym_compunit::end_symtab_with_blockvector (struct block *static_block,\n \t/* Note that we only want to fix up symbols from the local\n \t   blocks, not blocks coming from included symtabs.  That is why\n \t   we use ALL_DICT_SYMBOLS here and not ALL_BLOCK_SYMBOLS.  */\n-\tALL_DICT_SYMBOLS (BLOCK_DICT (block), iter, sym)\n+\tALL_DICT_SYMBOLS (BLOCK_MULTIDICT (block), miter, sym)\n \t  if (symbol_symtab (sym) == NULL)\n \t    symbol_set_symtab (sym, symtab);\n       }\n@@ -1211,7 +1209,7 @@ buildsym_compunit::augment_type_symtab ()\n \t to the primary symtab.  */\n       set_missing_symtab (m_file_symbols, cust);\n \n-      dict_add_pending (BLOCK_DICT (block), m_file_symbols);\n+      mdict_add_pending (BLOCK_MULTIDICT (block), m_file_symbols);\n     }\n \n   if (m_global_symbols != NULL)\n@@ -1222,7 +1220,7 @@ buildsym_compunit::augment_type_symtab ()\n \t to the primary symtab.  */\n       set_missing_symtab (m_global_symbols, cust);\n \n-      dict_add_pending (BLOCK_DICT (block),\n+      mdict_add_pending (BLOCK_MULTIDICT (block),\n \t\t\tm_global_symbols);\n     }\n }"
    },
    {
      "sha": "5705dbba2b2b80813a4d15a85e0f6eb3430c6118",
      "filename": "gdb/dictionary.h",
      "status": "modified",
      "additions": 60,
      "deletions": 59,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/dictionary.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/dictionary.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dictionary.h?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -25,10 +25,10 @@\n \n #include \"symfile.h\"\n \n-/* An opaque type for dictionaries; only dictionary.c should know\n-   about its innards.  */\n+/* An opaque type for multi-language dictionaries; only dictionary.c should\n+   know about its innards.  */\n \n-struct dictionary;\n+struct multidictionary;\n \n /* Other types needed for declarations.  */\n \n@@ -38,65 +38,64 @@ struct pending;\n struct language_defn;\n \n /* The creation functions for various implementations of\n-   dictionaries.  */\n+   multi-language dictionaries.  */\n \n-/* Create a dictionary of symbols of language LANGUAGE implemented via\n+/* Create a multi-language dictionary of symbols implemented via\n    a fixed-size hashtable.  All memory it uses is allocated on\n    OBSTACK; the environment is initialized from SYMBOL_LIST.  */\n \n-extern struct dictionary *dict_create_hashed (struct obstack *obstack,\n-\t\t\t\t\t      enum language language,\n-\t\t\t\t\t      const struct pending\n-\t\t\t\t\t      *symbol_list);\n+extern struct multidictionary *\n+  mdict_create_hashed (struct obstack *obstack,\n+\t\t       const struct pending *symbol_list);\n \n-/* Create a dictionary of symbols of language LANGUAGE, implemented\n-   via a hashtable that grows as necessary.  The dictionary is\n-   initially empty; to add symbols to it, call dict_add_symbol().\n-   Call dict_free() when you're done with it.  */\n+/* Create a multi-language dictionary of symbols, implemented\n+   via a hashtable that grows as necessary.  The initial dictionary of\n+   LANGUAGE is empty; to add symbols to it, call mdict_add_symbol().\n+   Call mdict_free() when you're done with it.  */\n \n-extern struct dictionary *\n-  dict_create_hashed_expandable (enum language language);\n+extern struct multidictionary *\n+  mdict_create_hashed_expandable (enum language language);\n \n-/* Create a dictionary of symbols of language LANGUAGE, implemented\n+/* Create a multi-language dictionary of symbols, implemented\n    via a fixed-size array.  All memory it uses is allocated on\n    OBSTACK; the environment is initialized from the SYMBOL_LIST.  The\n    symbols are ordered in the same order that they're found in\n    SYMBOL_LIST.  */\n \n-extern struct dictionary *dict_create_linear (struct obstack *obstack,\n-\t\t\t\t\t      enum language language,\n-\t\t\t\t\t      const struct pending\n-\t\t\t\t\t      *symbol_list);\n+extern struct multidictionary *\n+  mdict_create_linear (struct obstack *obstack,\n+\t\t       const struct pending *symbol_list);\n \n-/* Create a dictionary of symbols of language LANGUAGE, implemented\n-   via an array that grows as necessary.  The dictionary is initially\n-   empty; to add symbols to it, call dict_add_symbol().  Call\n-   dict_free() when you're done with it.  */\n+/* Create a multi-language dictionary of symbols, implemented\n+   via an array that grows as necessary.  The multidictionary initially\n+   contains a single empty dictionary of LANGUAGE; to add symbols to it,\n+   call mdict_add_symbol().  Call mdict_free() when you're done with it.  */\n \n-extern struct dictionary *\n-  dict_create_linear_expandable (enum language language);\n+extern struct multidictionary *\n+  mdict_create_linear_expandable (enum language language);\n \n-/* The functions providing the interface to dictionaries.  Note that\n-   the most common parts of the interface, namely symbol lookup, are\n-   only provided via iterator functions.  */\n+/* The functions providing the interface to multi-language dictionaries.\n+   Note that the most common parts of the interface, namely symbol lookup,\n+   are only provided via iterator functions.  */\n \n-/* Free the memory used by a dictionary that's not on an obstack.  (If\n+/* Free the memory used by a multidictionary that's not on an obstack.  (If\n    any.)  */\n \n-extern void dict_free (struct dictionary *dict);\n+extern void mdict_free (struct multidictionary *mdict);\n \n-/* Add a symbol to an expandable dictionary.  */\n+/* Add a symbol to an expandable multidictionary.  */\n \n-extern void dict_add_symbol (struct dictionary *dict, struct symbol *sym);\n+extern void mdict_add_symbol (struct multidictionary *mdict,\n+\t\t\t      struct symbol *sym);\n \n-/* Utility to add a list of symbols to a dictionary.  */\n+/* Utility to add a list of symbols to a multidictionary.  */\n \n-extern void dict_add_pending (struct dictionary *dict,\n-\t\t\t      const struct pending *symbol_list);\n+extern void mdict_add_pending (struct multidictionary *mdict,\n+\t\t\t       const struct pending *symbol_list);\n \n-/* Is the dictionary empty?  */\n+/* Is the multidictionary empty?  */\n \n-extern int dict_empty (struct dictionary *dict);\n+extern int mdict_empty (struct multidictionary *mdict);\n \n /* A type containing data that is used when iterating over all symbols\n    in a dictionary.  Don't ever look at its innards; this type would\n@@ -128,44 +127,46 @@ struct mdict_iterator\n   unsigned short current_idx;\n };\n \n-/* Initialize ITERATOR to point at the first symbol in DICT, and\n-   return that first symbol, or NULL if DICT is empty.  */\n+/* Initialize ITERATOR to point at the first symbol in MDICT, and\n+   return that first symbol, or NULL if MDICT is empty.  */\n \n-extern struct symbol *dict_iterator_first (const struct dictionary *dict,\n-\t\t\t\t\t   struct dict_iterator *iterator);\n+extern struct symbol *\n+  mdict_iterator_first (const struct multidictionary *mdict,\n+\t\t\tstruct mdict_iterator *miterator);\n \n-/* Advance ITERATOR, and return the next symbol, or NULL if there are\n+/* Advance MITERATOR, and return the next symbol, or NULL if there are\n    no more symbols.  Don't call this if you've previously received\n-   NULL from dict_iterator_first or dict_iterator_next on this\n+   NULL from mdict_iterator_first or mdict_iterator_next on this\n    iteration.  */\n \n-extern struct symbol *dict_iterator_next (struct dict_iterator *iterator);\n+extern struct symbol *mdict_iterator_next (struct mdict_iterator *miterator);\n \n-/* Initialize ITERATOR to point at the first symbol in DICT whose\n+/* Initialize MITERATOR to point at the first symbol in MDICT whose\n    SYMBOL_SEARCH_NAME is NAME, as tested using COMPARE (which must use\n    the same conventions as strcmp_iw and be compatible with any\n    dictionary hashing function), and return that first symbol, or NULL\n    if there are no such symbols.  */\n \n-extern struct symbol *dict_iter_match_first (const struct dictionary *dict,\n-\t\t\t\t\t     const lookup_name_info &name,\n-\t\t\t\t\t     struct dict_iterator *iterator);\n+extern struct symbol *\n+  mdict_iter_match_first (const struct multidictionary *mdict,\n+\t\t\t  const lookup_name_info &name,\n+\t\t\t  struct mdict_iterator *miterator);\n \n-/* Advance ITERATOR to point at the next symbol in DICT whose\n+/* Advance MITERATOR to point at the next symbol in MDICT whose\n    SYMBOL_SEARCH_NAME is NAME, as tested using COMPARE (see\n    dict_iter_match_first), or NULL if there are no more such symbols.\n    Don't call this if you've previously received NULL from \n-   dict_iterator_match_first or dict_iterator_match_next on this\n-   iteration.  And don't call it unless ITERATOR was created by a\n-   previous call to dict_iter_match_first with the same NAME and COMPARE.  */\n+   mdict_iterator_match_first or mdict_iterator_match_next on this\n+   iteration.  And don't call it unless MITERATOR was created by a\n+   previous call to mdict_iter_match_first with the same NAME and COMPARE.  */\n \n-extern struct symbol *dict_iter_match_next (const lookup_name_info &name,\n-\t\t\t\t\t    struct dict_iterator *iterator);\n+extern struct symbol *mdict_iter_match_next (const lookup_name_info &name,\n+\t\t\t\t\t     struct mdict_iterator *miterator);\n \n-/* Return some notion of the size of the dictionary: the number of\n+/* Return some notion of the size of the multidictionary: the number of\n    symbols if we have that, the number of hash buckets otherwise.  */\n \n-extern int dict_size (const struct dictionary *dict);\n+extern int mdict_size (const struct multidictionary *mdict);\n \n /* Macro to loop through all symbols in a dictionary DICT, in no\n    particular order.  ITER is a struct dict_iterator (NOTE: __not__ a\n@@ -175,8 +176,8 @@ extern int dict_size (const struct dictionary *dict);\n    early by a break if you desire.  */\n \n #define ALL_DICT_SYMBOLS(dict, iter, sym)\t\t\t\\\n-\tfor ((sym) = dict_iterator_first ((dict), &(iter));\t\\\n+\tfor ((sym) = mdict_iterator_first ((dict), &(iter));\t\\\n \t     (sym);\t\t\t\t\t\t\\\n-\t     (sym) = dict_iterator_next (&(iter)))\n+\t     (sym) = mdict_iterator_next (&(iter)))\n \n #endif /* DICTIONARY_H */"
    },
    {
      "sha": "35e44e34269ff4b9a77c3b7842809096aef00912",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -651,14 +651,12 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n   size_t blockvector_size;\n   CORE_ADDR begin, end;\n   struct blockvector *bv;\n-  enum language language;\n \n   actual_nblocks = FIRST_LOCAL_BLOCK + stab->nblocks;\n \n   cust = allocate_compunit_symtab (objfile, stab->file_name);\n   allocate_symtab (cust, stab->file_name);\n   add_compunit_symtab_to_objfile (cust);\n-  language = compunit_language (cust);\n \n   /* JIT compilers compile in memory.  */\n   COMPUNIT_DIRNAME (cust) = NULL;\n@@ -702,8 +700,8 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n \t\t\t\t\t   TARGET_CHAR_BIT,\n \t\t\t\t\t   \"void\");\n \n-      BLOCK_DICT (new_block) = dict_create_linear (&objfile->objfile_obstack,\n-\t\t\t\t\t\t   language, NULL);\n+      BLOCK_MULTIDICT (new_block)\n+\t= mdict_create_linear (&objfile->objfile_obstack, NULL);\n       /* The address range.  */\n       BLOCK_START (new_block) = (CORE_ADDR) gdb_block_iter->begin;\n       BLOCK_END (new_block) = (CORE_ADDR) gdb_block_iter->end;\n@@ -740,8 +738,8 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n       new_block = (i == GLOBAL_BLOCK\n \t\t   ? allocate_global_block (&objfile->objfile_obstack)\n \t\t   : allocate_block (&objfile->objfile_obstack));\n-      BLOCK_DICT (new_block) = dict_create_linear (&objfile->objfile_obstack,\n-\t\t\t\t\t\t   language, NULL);\n+      BLOCK_MULTIDICT (new_block)\n+\t= mdict_create_linear (&objfile->objfile_obstack, NULL);\n       BLOCK_SUPERBLOCK (new_block) = block_iter;\n       block_iter = new_block;\n "
    },
    {
      "sha": "4bdf9731cfe0a7f4d8f2eaf03f87354bdf66a492",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -4506,7 +4506,7 @@ static void\n add_symbol (struct symbol *s, struct symtab *symtab, struct block *b)\n {\n   symbol_set_symtab (s, symtab);\n-  dict_add_symbol (BLOCK_DICT (b), s);\n+  mdict_add_symbol (BLOCK_MULTIDICT (b), s);\n }\n \n /* Add a new block B to a symtab S.  */\n@@ -4734,7 +4734,7 @@ new_bvect (int nblocks)\n }\n \n /* Allocate and zero a new block of language LANGUAGE, and set its\n-   BLOCK_DICT.  If function is non-zero, assume the block is\n+   BLOCK_MULTIDICT.  If function is non-zero, assume the block is\n    associated to a function, and make sure that the symbols are stored\n    linearly; otherwise, store them hashed.  */\n \n@@ -4747,9 +4747,9 @@ new_block (enum block_type type, enum language language)\n   struct block *retval = XCNEW (struct block);\n \n   if (type == FUNCTION_BLOCK)\n-    BLOCK_DICT (retval) = dict_create_linear_expandable (language);\n+    BLOCK_MULTIDICT (retval) = mdict_create_linear_expandable (language);\n   else\n-    BLOCK_DICT (retval) = dict_create_hashed_expandable (language);\n+    BLOCK_MULTIDICT (retval) = mdict_create_hashed_expandable (language);\n \n   return retval;\n }"
    },
    {
      "sha": "854e87db216c25c153a708104bf27b8291603356",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -818,7 +818,7 @@ objfile_relocate1 (struct objfile *objfile,\n \t  {\n \t    struct block *b;\n \t    struct symbol *sym;\n-\t    struct dict_iterator iter;\n+\t    struct mdict_iterator miter;\n \n \t    b = BLOCKVECTOR_BLOCK (bv, i);\n \t    BLOCK_START (b) += ANOFFSET (delta, block_line_section);\n@@ -835,7 +835,7 @@ objfile_relocate1 (struct objfile *objfile,\n \n \t    /* We only want to iterate over the local symbols, not any\n \t       symbols in included symtabs.  */\n-\t    ALL_DICT_SYMBOLS (BLOCK_DICT (b), iter, sym)\n+\t    ALL_DICT_SYMBOLS (BLOCK_MULTIDICT (b), miter, sym)\n \t      {\n \t\trelocate_one_symbol (sym, objfile, delta);\n \t      }"
    },
    {
      "sha": "92c054cba3f8f12b63acdd0eae571a0b189eec05",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b026f59345a336cabf74719fce9f96cab7c7ab4d/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=b026f59345a336cabf74719fce9f96cab7c7ab4d",
      "patch": "@@ -276,7 +276,7 @@ dump_symtab_1 (struct symtab *symtab, struct ui_file *outfile)\n   struct objfile *objfile = SYMTAB_OBJFILE (symtab);\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n   int i;\n-  struct dict_iterator iter;\n+  struct mdict_iterator miter;\n   int len;\n   struct linetable *l;\n   const struct blockvector *bv;\n@@ -332,7 +332,7 @@ dump_symtab_1 (struct symtab *symtab, struct ui_file *outfile)\n \t     even if we're using a hashtable, but nothing else but this message\n \t     wants it.  */\n \t  fprintf_filtered (outfile, \", %d syms/buckets in \",\n-\t\t\t    dict_size (BLOCK_DICT (b)));\n+\t\t\t    mdict_size (BLOCK_MULTIDICT (b)));\n \t  fputs_filtered (paddress (gdbarch, BLOCK_START (b)), outfile);\n \t  fprintf_filtered (outfile, \"..\");\n \t  fputs_filtered (paddress (gdbarch, BLOCK_END (b)), outfile);\n@@ -350,7 +350,7 @@ dump_symtab_1 (struct symtab *symtab, struct ui_file *outfile)\n \t  /* Now print each symbol in this block (in no particular order, if\n \t     we're using a hashtable).  Note that we only want this\n \t     block, not any blocks from included symtabs.  */\n-\t  ALL_DICT_SYMBOLS (BLOCK_DICT (b), iter, sym)\n+\t  ALL_DICT_SYMBOLS (BLOCK_MULTIDICT (b), miter, sym)\n \t    {\n \t      TRY\n \t\t{"
    }
  ]
}