{
  "sha": "772d1f343476340874012b80c4c4863dcf98d2e2",
  "node_id": "C_kwDOANOeidoAKDc3MmQxZjM0MzQ3NjM0MDg3NDAxMmI4MGM0YzQ4NjNkY2Y5OGQyZTI",
  "commit": {
    "author": {
      "name": "Tiezhu Yang",
      "email": "yangtiezhu@loongson.cn",
      "date": "2022-02-11T12:13:21Z"
    },
    "committer": {
      "name": "Tiezhu Yang",
      "email": "yangtiezhu@loongson.cn",
      "date": "2022-02-11T12:13:21Z"
    },
    "message": "gdb: LoongArch: Add initial baremetal support\n\nThis commit adds initial baremetal support for LoongArch.\n\nSigned-off-by: Zhensong Liu <liuzhensong@loongson.cn>\nSigned-off-by: Qing zhang <zhangqing@loongson.cn>\nSigned-off-by: Youling Tang <tangyouling@loongson.cn>\nSigned-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>",
    "tree": {
      "sha": "8c7157c8287a67502e15b08a0125ab15421b897d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8c7157c8287a67502e15b08a0125ab15421b897d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/772d1f343476340874012b80c4c4863dcf98d2e2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/772d1f343476340874012b80c4c4863dcf98d2e2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/772d1f343476340874012b80c4c4863dcf98d2e2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/772d1f343476340874012b80c4c4863dcf98d2e2/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "e74d08100dd3d1c5aee6eb67235465ebed194380",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e74d08100dd3d1c5aee6eb67235465ebed194380",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e74d08100dd3d1c5aee6eb67235465ebed194380"
    }
  ],
  "stats": {
    "total": 365,
    "additions": 365,
    "deletions": 0
  },
  "files": [
    {
      "sha": "ffcff03109a70ed2870e25021902afe461012522",
      "filename": "gdb/loongarch-tdep.c",
      "status": "added",
      "additions": 316,
      "deletions": 0,
      "changes": 316,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/772d1f343476340874012b80c4c4863dcf98d2e2/gdb/loongarch-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/772d1f343476340874012b80c4c4863dcf98d2e2/gdb/loongarch-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/loongarch-tdep.c?ref=772d1f343476340874012b80c4c4863dcf98d2e2",
      "patch": "@@ -0,0 +1,316 @@\n+/* Target-dependent code for the LoongArch architecture, for GDB.\n+\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"arch-utils.h\"\n+#include \"dwarf2/frame.h\"\n+#include \"elf-bfd.h\"\n+#include \"frame-unwind.h\"\n+#include \"loongarch-tdep.h\"\n+#include \"target-descriptions.h\"\n+#include \"trad-frame.h\"\n+#include \"user-regs.h\"\n+\n+/* Implement the loongarch_skip_prologue gdbarch method.  */\n+\n+static CORE_ADDR\n+loongarch_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n+{\n+  CORE_ADDR func_addr;\n+\n+  /* See if we can determine the end of the prologue via the symbol table.\n+     If so, then return either PC, or the PC after the prologue, whichever\n+     is greater.  */\n+  if (find_pc_partial_function (pc, nullptr, &func_addr, nullptr))\n+    {\n+      CORE_ADDR post_prologue_pc\n+\t= skip_prologue_using_sal (gdbarch, func_addr);\n+      if (post_prologue_pc != 0)\n+\treturn std::max (pc, post_prologue_pc);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Adjust the address downward (direction of stack growth) so that it\n+   is correctly aligned for a new stack frame.  */\n+\n+static CORE_ADDR\n+loongarch_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)\n+{\n+  return align_down (addr, 16);\n+}\n+\n+/* Generate, or return the cached frame cache for LoongArch frame unwinder.  */\n+\n+static struct trad_frame_cache *\n+loongarch_frame_cache (struct frame_info *this_frame, void **this_cache)\n+{\n+  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n+  struct trad_frame_cache *cache;\n+  CORE_ADDR pc;\n+\n+  if (*this_cache != nullptr)\n+    return (struct trad_frame_cache *) *this_cache;\n+\n+  cache = trad_frame_cache_zalloc (this_frame);\n+  *this_cache = cache;\n+\n+  loongarch_gdbarch_tdep *tdep = (loongarch_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  trad_frame_set_reg_realreg (cache, gdbarch_pc_regnum (gdbarch), tdep->regs.ra);\n+\n+  pc = get_frame_address_in_block (this_frame);\n+  trad_frame_set_id (cache, frame_id_build_unavailable_stack (pc));\n+\n+  return cache;\n+}\n+\n+/* Implement the this_id callback for LoongArch frame unwinder.  */\n+\n+static void\n+loongarch_frame_this_id (struct frame_info *this_frame, void **prologue_cache,\n+\t\t\t struct frame_id *this_id)\n+{\n+  struct trad_frame_cache *info;\n+\n+  info = loongarch_frame_cache (this_frame, prologue_cache);\n+  trad_frame_get_id (info, this_id);\n+}\n+\n+/* Implement the prev_register callback for LoongArch frame unwinder.  */\n+\n+static struct value *\n+loongarch_frame_prev_register (struct frame_info *this_frame,\n+\t\t\t       void **prologue_cache, int regnum)\n+{\n+  struct trad_frame_cache *info;\n+\n+  info = loongarch_frame_cache (this_frame, prologue_cache);\n+  return trad_frame_get_register (info, this_frame, regnum);\n+}\n+\n+static const struct frame_unwind loongarch_frame_unwind = {\n+  \"loongarch prologue\",\n+  /*.type\t   =*/NORMAL_FRAME,\n+  /*.stop_reason   =*/default_frame_unwind_stop_reason,\n+  /*.this_id\t   =*/loongarch_frame_this_id,\n+  /*.prev_register =*/loongarch_frame_prev_register,\n+  /*.unwind_data   =*/nullptr,\n+  /*.sniffer\t   =*/default_frame_sniffer,\n+  /*.dealloc_cache =*/nullptr,\n+  /*.prev_arch\t   =*/nullptr,\n+};\n+\n+/* Implement the \"dwarf2_reg_to_regnum\" gdbarch method.  */\n+\n+static int\n+loongarch_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int num)\n+{\n+  loongarch_gdbarch_tdep *tdep = (loongarch_gdbarch_tdep *) gdbarch_tdep (gdbarch);\n+  auto regs = tdep->regs;\n+\n+  if (0 <= num && num < 32)\n+    return regs.r + num;\n+  else\n+    return -1;\n+}\n+\n+static constexpr gdb_byte loongarch_default_breakpoint[] = {0x05, 0x00, 0x2a, 0x00};\n+typedef BP_MANIPULATION (loongarch_default_breakpoint) loongarch_breakpoint;\n+\n+/* Extract a set of required target features out of ABFD.  If ABFD is nullptr\n+   then a LOONGARCH_GDBARCH_FEATURES is returned in its default state.  */\n+\n+static struct loongarch_gdbarch_features\n+loongarch_features_from_bfd (const bfd *abfd)\n+{\n+  struct loongarch_gdbarch_features features;\n+\n+  /* Now try to improve on the defaults by looking at the binary we are\n+     going to execute.  We assume the user knows what they are doing and\n+     that the target will match the binary.  Remember, this code path is\n+     only used at all if the target hasn't given us a description, so this\n+     is really a last ditched effort to do something sane before giving\n+     up.  */\n+  if (abfd != nullptr && bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n+    {\n+      unsigned char eclass = elf_elfheader (abfd)->e_ident[EI_CLASS];\n+\n+      if (eclass == ELFCLASS32)\n+\tfeatures.xlen = 4;\n+      else if (eclass == ELFCLASS64)\n+\tfeatures.xlen = 8;\n+      else\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"unknown ELF header class %d\"), eclass);\n+    }\n+\n+  return features;\n+}\n+\n+/* Find a suitable default target description.  Use the contents of INFO,\n+   specifically the bfd object being executed, to guide the selection of a\n+   suitable default target description.  */\n+\n+static const struct target_desc *\n+loongarch_find_default_target_description (const struct gdbarch_info info)\n+{\n+  /* Extract desired feature set from INFO.  */\n+  struct loongarch_gdbarch_features features\n+    = loongarch_features_from_bfd (info.abfd);\n+\n+  /* If the XLEN field is still 0 then we got nothing useful from INFO.BFD,\n+     maybe there was no bfd object.  In this case we fall back to a minimal\n+     useful target with no floating point, the x-register size is selected\n+     based on the architecture from INFO.  */\n+  if (features.xlen == 0)\n+    features.xlen = info.bfd_arch_info->bits_per_address == 32 ? 4 : 8;\n+\n+  /* Now build a target description based on the feature set.  */\n+  return loongarch_lookup_target_description (features);\n+}\n+\n+/* Initialize the current architecture based on INFO  */\n+\n+static struct gdbarch *\n+loongarch_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n+{\n+  const struct target_desc *tdesc = info.target_desc;\n+\n+  /* Ensure we always have a target description.  */\n+  if (!tdesc_has_registers (tdesc))\n+    tdesc = loongarch_find_default_target_description (info);\n+\n+  const struct tdesc_feature *feature_cpu\n+    = tdesc_find_feature (tdesc, \"org.gnu.gdb.loongarch.base\");\n+  if (feature_cpu == nullptr)\n+    return nullptr;\n+\n+  int xlen_bitsize = tdesc_register_bitsize (feature_cpu, \"pc\");\n+  struct loongarch_gdbarch_features features;\n+  features.xlen = (xlen_bitsize / 8);\n+\n+  size_t regnum = 0;\n+  tdesc_arch_data_up tdesc_data = tdesc_data_alloc ();\n+  loongarch_gdbarch_tdep *tdep = new loongarch_gdbarch_tdep;\n+  tdep->regs.r = regnum;\n+\n+  /* Validate the description provides the mandatory base registers\n+     and allocate their numbers.  */\n+  bool valid_p = true;\n+  for (int i = 0; i < 32; i++)\n+    valid_p &= tdesc_numbered_register (feature_cpu, tdesc_data.get (), regnum++,\n+\t\t\t\t\tloongarch_r_normal_name[i] + 1);\n+  valid_p &= tdesc_numbered_register (feature_cpu, tdesc_data.get (),\n+\t\t\t\t      tdep->regs.pc = regnum++, \"pc\");\n+  valid_p &= tdesc_numbered_register (feature_cpu, tdesc_data.get (),\n+\t\t\t\t      tdep->regs.badv = regnum++, \"badv\");\n+  if (!valid_p)\n+    return nullptr;\n+\n+  /* LoongArch code is always little-endian.  */\n+  info.byte_order_for_code = BFD_ENDIAN_LITTLE;\n+\n+  /* Have a look at what the supplied (if any) bfd object requires of the\n+     target, then check that this matches with what the target is\n+     providing.  */\n+  struct loongarch_gdbarch_features abi_features\n+    = loongarch_features_from_bfd (info.abfd);\n+\n+  /* If the ABI_FEATURES xlen is 0 then this indicates we got no useful abi\n+     features from the INFO object.  In this case we just treat the\n+     hardware features as defining the abi.  */\n+  if (abi_features.xlen == 0)\n+    abi_features = features;\n+\n+  /* Find a candidate among the list of pre-declared architectures.  */\n+  for (arches = gdbarch_list_lookup_by_info (arches, &info);\n+       arches != nullptr;\n+       arches = gdbarch_list_lookup_by_info (arches->next, &info))\n+    {\n+      /* Check that the feature set of the ARCHES matches the feature set\n+\t we are looking for.  If it doesn't then we can't reuse this\n+\t gdbarch.  */\n+      loongarch_gdbarch_tdep *candidate_tdep\n+\t= (loongarch_gdbarch_tdep *) gdbarch_tdep (arches->gdbarch);\n+\n+      if (candidate_tdep->abi_features != abi_features)\n+\tcontinue;\n+\n+      break;\n+    }\n+\n+  if (arches != nullptr)\n+    return arches->gdbarch;\n+\n+  /* None found, so create a new architecture from the information provided.  */\n+  struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep);\n+  tdep->abi_features = abi_features;\n+\n+  /* Target data types.  */\n+  set_gdbarch_short_bit (gdbarch, 16);\n+  set_gdbarch_int_bit (gdbarch, 32);\n+  set_gdbarch_long_bit (gdbarch, info.bfd_arch_info->bits_per_address);\n+  set_gdbarch_long_long_bit (gdbarch, 64);\n+  set_gdbarch_ptr_bit (gdbarch, info.bfd_arch_info->bits_per_address);\n+  set_gdbarch_char_signed (gdbarch, 0);\n+\n+  info.target_desc = tdesc;\n+  info.tdesc_data = tdesc_data.get ();\n+\n+  /* Information about registers.  */\n+  tdep->regs.ra = tdep->regs.r + 1;\n+  tdep->regs.sp = tdep->regs.r + 3;\n+  set_gdbarch_num_regs (gdbarch, regnum);\n+  set_gdbarch_sp_regnum (gdbarch, tdep->regs.sp);\n+  set_gdbarch_pc_regnum (gdbarch, tdep->regs.pc);\n+\n+  /* Finalise the target description registers.  */\n+  tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n+\n+  /* Advance PC across function entry code.  */\n+  set_gdbarch_skip_prologue (gdbarch, loongarch_skip_prologue);\n+\n+  /* Stack grows downward.  */\n+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);\n+\n+  /* Frame info.  */\n+  set_gdbarch_frame_align (gdbarch, loongarch_frame_align);\n+\n+  /* Breakpoint manipulation.  */\n+  set_gdbarch_breakpoint_kind_from_pc (gdbarch, loongarch_breakpoint::kind_from_pc);\n+  set_gdbarch_sw_breakpoint_from_kind (gdbarch, loongarch_breakpoint::bp_from_kind);\n+\n+  /* Frame unwinders. Use DWARF debug info if available, otherwise use our own unwinder.  */\n+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, loongarch_dwarf2_reg_to_regnum);\n+  dwarf2_append_unwinders (gdbarch);\n+  frame_unwind_append_unwinder (gdbarch, &loongarch_frame_unwind);\n+\n+  /* Hook in OS ABI-specific overrides, if they have been registered.  */\n+  gdbarch_init_osabi (info, gdbarch);\n+\n+  return gdbarch;\n+}\n+\n+void _initialize_loongarch_tdep ();\n+void\n+_initialize_loongarch_tdep ()\n+{\n+  gdbarch_register (bfd_arch_loongarch, loongarch_gdbarch_init, nullptr);\n+}"
    },
    {
      "sha": "b2fd16e25a7c23cd8876592fa47c9a751d4d4a9d",
      "filename": "gdb/loongarch-tdep.h",
      "status": "added",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/772d1f343476340874012b80c4c4863dcf98d2e2/gdb/loongarch-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/772d1f343476340874012b80c4c4863dcf98d2e2/gdb/loongarch-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/loongarch-tdep.h?ref=772d1f343476340874012b80c4c4863dcf98d2e2",
      "patch": "@@ -0,0 +1,49 @@\n+/* Target-dependent header for the LoongArch architecture, for GDB.\n+\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LOONGARCH_TDEP_H\n+#define LOONGARCH_TDEP_H\n+\n+#include \"gdbarch.h\"\n+#include \"arch/loongarch.h\"\n+#include \"regset.h\"\n+\n+#include \"elf/loongarch.h\"\n+#include \"opcode/loongarch.h\"\n+\n+/* Register set definitions.  */\n+extern const struct regset loongarch_gregset;\n+\n+/* Target-dependent structure in gdbarch.  */\n+struct loongarch_gdbarch_tdep : gdbarch_tdep\n+{\n+  /* Features about the abi that impact how the gdbarch is configured.  */\n+  struct loongarch_gdbarch_features abi_features;\n+\n+  struct\n+  {\n+    int r;\t/* General register. */\n+    int ra;\t/* Return Address.  */\n+    int sp;\t/* Stack Pointer.  */\n+    int pc;\t/* Program Counter.  */\n+    int badv;\t/* Bad vaddr for addressing exception.  */\n+  } regs;\t/* LoongArch registers  */\n+};\n+\n+#endif /* LOONGARCH_TDEP_H  */"
    }
  ]
}