{
  "sha": "7f2043399809c0ba5c4819172214371ed820e8c6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2YyMDQzMzk5ODA5YzBiYTVjNDgxOTE3MjIxNDM3MWVkODIwZThjNg==",
  "commit": {
    "author": {
      "name": "Rainer Orth",
      "email": "ro@CeBiTec.Uni-Bielefeld.DE",
      "date": "2020-05-18T15:56:00Z"
    },
    "committer": {
      "name": "Rainer Orth",
      "email": "ro@CeBiTec.Uni-Bielefeld.DE",
      "date": "2020-05-18T15:56:00Z"
    },
    "message": "Remove unused ps_lgetLDT etc. on Solaris/x86 [PR25981]\n\nAs reported in PR build/25981, a future Solaris 11.4 update will soon\nremove the short i386 register names like SS etc. from <sys/regset.h>.\nThey could leak into user code (e.g. via <signal.h> -> <sys/signal.h> ->\n<sys/ucontext.h>) and pollute the user namespace.  Affected code would\nhave a hard time avoiding the issue: LLVM is one of those.\n\nWhile the short names are required to be present by the i386 psABI, that\ndocument only demands that they exist in <ucontext.h>, which is what the\nupcoming update assures.\n\nWith this change, in a 64-bit-default configuration, procfs.c fails to\ncompile on Solaris/x86:\n\n/vol/src/gnu/gdb/hg/master/git/gdb/procfs.c: In function 'ssd* procfs_find_LDT_entry(ptid_t)':\n/vol/src/gnu/gdb/hg/master/git/gdb/procfs.c:1643:18: error: 'GS' was not declared in this scope\n 1643 |   key = (*gregs)[GS] & 0xffff;\n      |                  ^~\nmake[2]: *** [Makefile:1607: procfs.o] Error 1\n\nInitially I meant to provide a definition using the planned replacement\nmacro, but closer inspection revealed a better way.  procfs_find_LDT_entry\nand its helper proc_get_LDT_entry are only used to implement ps_lgetLDT,\none of the callback functions required by libthread_db.so.1\n(cf. <proc_service.h>).  While that function is still documented as being\nrequired even in Solaris 11.4, I found that calls to it had been removed\nlong ago in Solaris 9, so just removing the three functions above is the\neasiest fix.\n\nThe following patch does just that.  It compiled successfully on\namd64-pc-solaris2.11, however, as reported in PR gdb/25939, master is\ncompletely broken on Solaris since the multi-target patch.  The patch\napplies cleanly to the gdb-9 branch and there I could test it\nsuccessfully.\n\n\tPR build/25981\n\t* procfs.c [(__i386__ || __x86_64__) && sun] (proc_get_LDT_entry,\n\tprocfs_find_LDT_entry): Remove.\n\t* procfs.h [(__i386__ || __x86_64__) && sun] (struct ssd,\n\tprocfs_find_LDT_entry): Remove.\n\t* sol-thread.c [(__i386__ || __x86_64__) && sun] (ps_lgetLDT):\n\tRemove.",
    "tree": {
      "sha": "947f2176a831e47a1c14bbe2dc83f33f3df9c53f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/947f2176a831e47a1c14bbe2dc83f33f3df9c53f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7f2043399809c0ba5c4819172214371ed820e8c6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7f2043399809c0ba5c4819172214371ed820e8c6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7f2043399809c0ba5c4819172214371ed820e8c6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7f2043399809c0ba5c4819172214371ed820e8c6/comments",
  "author": {
    "login": "rorth",
    "id": 3930951,
    "node_id": "MDQ6VXNlcjM5MzA5NTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rorth",
    "html_url": "https://github.com/rorth",
    "followers_url": "https://api.github.com/users/rorth/followers",
    "following_url": "https://api.github.com/users/rorth/following{/other_user}",
    "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rorth/subscriptions",
    "organizations_url": "https://api.github.com/users/rorth/orgs",
    "repos_url": "https://api.github.com/users/rorth/repos",
    "events_url": "https://api.github.com/users/rorth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rorth/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "rorth",
    "id": 3930951,
    "node_id": "MDQ6VXNlcjM5MzA5NTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rorth",
    "html_url": "https://github.com/rorth",
    "followers_url": "https://api.github.com/users/rorth/followers",
    "following_url": "https://api.github.com/users/rorth/following{/other_user}",
    "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rorth/subscriptions",
    "organizations_url": "https://api.github.com/users/rorth/orgs",
    "repos_url": "https://api.github.com/users/rorth/repos",
    "events_url": "https://api.github.com/users/rorth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rorth/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ed02cdb5b78d17429f7e873acc49d94a5a0223d8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ed02cdb5b78d17429f7e873acc49d94a5a0223d8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ed02cdb5b78d17429f7e873acc49d94a5a0223d8"
    }
  ],
  "stats": {
    "total": 127,
    "additions": 10,
    "deletions": 117
  },
  "files": [
    {
      "sha": "cba0464770c419cd41317607d60bf802fe7abec6",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7f2043399809c0ba5c4819172214371ed820e8c6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7f2043399809c0ba5c4819172214371ed820e8c6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7f2043399809c0ba5c4819172214371ed820e8c6",
      "patch": "@@ -1,3 +1,13 @@\n+2020-05-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\tPR build/25981\n+\t* procfs.c [(__i386__ || __x86_64__) && sun] (proc_get_LDT_entry,\n+\tprocfs_find_LDT_entry): Remove.\n+\t* procfs.h [(__i386__ || __x86_64__) && sun] (struct ssd,\n+\tprocfs_find_LDT_entry): Remove.\n+\t* sol-thread.c [(__i386__ || __x86_64__) && sun] (ps_lgetLDT):\n+\tRemove.\n+\n 2020-05-17  Pedro Alves  <palves@redhat.com>\n \t    Andrew Burgess  <andrew.burgess@embecosm.com>\n \t    Keno Fischer  <keno@juliacomputing.com>"
    },
    {
      "sha": "f6c6b0e71c16224d3e7345ca09e011cdcf06349a",
      "filename": "gdb/procfs.c",
      "status": "modified",
      "additions": 0,
      "deletions": 79,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7f2043399809c0ba5c4819172214371ed820e8c6/gdb/procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7f2043399809c0ba5c4819172214371ed820e8c6/gdb/procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/procfs.c?ref=7f2043399809c0ba5c4819172214371ed820e8c6",
      "patch": "@@ -1569,85 +1569,6 @@ proc_set_watchpoint (procinfo *pi, CORE_ADDR addr, int len, int wflags)\n   return (write (pi->ctl_fd, &arg, sizeof (arg)) == sizeof (arg));\n }\n \n-#if (defined(__i386__) || defined(__x86_64__)) && defined (sun)\n-\n-#include <sys/sysi86.h>\n-\n-/* The KEY is actually the value of the lower 16 bits of the GS\n-   register for the LWP that we're interested in.  Returns the\n-   matching ssh struct (LDT entry).  */\n-\n-static struct ssd *\n-proc_get_LDT_entry (procinfo *pi, int key)\t/* ARI: editCase function */\n-{\n-  static struct ssd *ldt_entry = NULL;\n-  char pathname[MAX_PROC_NAME_SIZE];\n-\n-  /* Allocate space for one LDT entry.\n-     This alloc must persist, because we return a pointer to it.  */\n-  if (ldt_entry == NULL)\n-    ldt_entry = XNEW (struct ssd);\n-\n-  /* Open the file descriptor for the LDT table.  */\n-  xsnprintf (pathname, sizeof (pathname), \"/proc/%d/ldt\", pi->pid);\n-  scoped_fd fd (open_with_retry (pathname, O_RDONLY));\n-  if (fd.get () < 0)\n-    {\n-      proc_warn (pi, \"proc_get_LDT_entry (open)\", __LINE__);\n-      return NULL;\n-    }\n-\n-  /* Now 'read' thru the table, find a match and return it.  */\n-  while (read (fd.get (), ldt_entry, sizeof (struct ssd))\n-\t == sizeof (struct ssd))\n-    {\n-      if (ldt_entry->sel == 0\n-\t  && ldt_entry->bo  == 0\n-\t  && ldt_entry->acc1 == 0\n-\t  && ldt_entry->acc2 == 0)\n-\tbreak;\t/* end of table */\n-      /* If key matches, return this entry.  */\n-      if (ldt_entry->sel == key)\n-\treturn ldt_entry;\n-    }\n-  /* Loop ended, match not found.  */\n-  return NULL;\n-}\n-\n-/* Returns the pointer to the LDT entry of PTID.  */\n-\n-struct ssd *\n-procfs_find_LDT_entry (ptid_t ptid)\t/* ARI: editCase function */\n-{\n-  gdb_gregset_t *gregs;\n-  int            key;\n-  procinfo      *pi;\n-\n-  /* Find procinfo for the lwp.  */\n-  pi = find_procinfo (ptid.pid (), ptid.lwp ());\n-  if (pi == NULL)\n-    {\n-      warning (_(\"procfs_find_LDT_entry: could not find procinfo for %d:%ld.\"),\n-\t       ptid.pid (), ptid.lwp ());\n-      return NULL;\n-    }\n-  /* get its general registers.  */\n-  gregs = proc_get_gregs (pi);\n-  if (gregs == NULL)\n-    {\n-      warning (_(\"procfs_find_LDT_entry: could not read gregs for %d:%ld.\"),\n-\t       ptid.pid (), ptid.lwp ());\n-      return NULL;\n-    }\n-  /* Now extract the GS register's lower 16 bits.  */\n-  key = (*gregs)[GS] & 0xffff;\n-\n-  /* Find the matching entry and return it.  */\n-  return proc_get_LDT_entry (pi, key);\n-}\n-\n-#endif\n-\n /* =============== END, non-thread part of /proc  \"MODULE\" =============== */\n \n /* =================== Thread \"MODULE\" =================== */"
    },
    {
      "sha": "46835fdf8207074155f7c8e78fad89f376e046f8",
      "filename": "gdb/procfs.h",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7f2043399809c0ba5c4819172214371ed820e8c6/gdb/procfs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7f2043399809c0ba5c4819172214371ed820e8c6/gdb/procfs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/procfs.h?ref=7f2043399809c0ba5c4819172214371ed820e8c6",
      "patch": "@@ -25,10 +25,4 @@\n \n extern ptid_t procfs_first_available (void);\n \n-#if (defined (__i386__) || defined (__x86_64__)) && defined (sun)\n-struct ssd;\n-\n-extern struct ssd *procfs_find_LDT_entry (ptid_t);\n-#endif\n-\n #endif /* PROCFS_H */"
    },
    {
      "sha": "9addf8de3ab54142ed043d225d15336f71411a41",
      "filename": "gdb/sol-thread.c",
      "status": "modified",
      "additions": 0,
      "deletions": 32,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7f2043399809c0ba5c4819172214371ed820e8c6/gdb/sol-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7f2043399809c0ba5c4819172214371ed820e8c6/gdb/sol-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sol-thread.c?ref=7f2043399809c0ba5c4819172214371ed820e8c6",
      "patch": "@@ -969,38 +969,6 @@ ps_pdmodel (struct ps_prochandle *ph, int *data_model)\n \n   return PS_OK;\n }\n-\n-#if (defined(__i386__) || defined(__x86_64__)) && defined (sun)\n-\n-/* Reads the local descriptor table of a LWP.\n-\n-   This function is necessary on x86-solaris only.  Without it, the loading\n-   of libthread_db would fail because of ps_lgetLDT being undefined.  */\n-\n-ps_err_e\n-ps_lgetLDT (struct ps_prochandle *ph, lwpid_t lwpid, struct ssd *pldt)\t/* ARI: editCase function */\n-{\n-  /* NOTE: only used on Solaris, therefore OK to refer to procfs.c.  */\n-  struct ssd *ret;\n-\n-  /* FIXME: can't I get the process ID from the prochandle or\n-     something?  */\n-\n-  if (inferior_ptid.pid () <= 0 || lwpid <= 0)\n-    return PS_BADLID;\n-\n-  ret = procfs_find_LDT_entry (ptid_t (inferior_ptid.pid (),\n-\t\t\t       lwpid, 0));\n-  if (ret)\n-    {\n-      memcpy (pldt, ret, sizeof (struct ssd));\n-      return PS_OK;\n-    }\n-  else\n-    /* LDT not found.  */\n-    return PS_ERR;\n-}\n-#endif\n \f\n \n /* Convert PTID to printable form.  */"
    }
  ]
}