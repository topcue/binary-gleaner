{
  "sha": "e310298cf3fc02112ac0018260748828affa4061",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTMxMDI5OGNmM2ZjMDIxMTJhYzAwMTgyNjA3NDg4MjhhZmZhNDA2MQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-25T02:20:10Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-26T00:07:25Z"
    },
    "message": "PR25593, --as-needed breaks DT_NEEDED order with linker plugin\n\nThis patch delays setting up DT_NEEDED dynamic tags until all object\nfiles and libraries have been opened and their symbols processed,\nrather than adding the tags while processing symbols.  Tags are\nordered according to the position of the associated library on the\ncommand line and linker scripts.  It is still possible with\n--as-needed libs that are mentioned more than once for tags to be\nordered according to which mention was needed.  For example with\n\"--as-needed a.so b.so c.so b.so\" when b.so is not needed by a.so or\nany other prior object file but is needed by c.so, the order of tags\nwill be \"A C B\".\n\nbfd/\n\tPR 25593\n\t* elf-bfd.h (struct elf_link_hash_table): Rename \"loaded\" to\n\t\"dyn_loaded\".\n\t(bfd_elf_add_dt_needed_tag): Declare.\n\t* elf-strtab.c (_bfd_elf_strtab_restore): Handle NULL buf.\n\t* elflink.c (bfd_elf_add_dt_needed_tag): Make global and rename\n\tfrom elf_add_dt_needed_tag.  Remove soname and doit param.\n\t(elf_link_add_object_symbols): Don't use elf_add_dt_needed_tag\n\tto see whether as-needed lib is already loaded, use dyn_loaded\n\tlist instead.  When saving and restoring around as-needed lib\n\thandle possibility that dynstr has not been initialised.  Don't\n\tadd DT_NEEDED tags here.  Limit dyn_loaded list to dynamic libs.\n\tMark libs loaded via DT_NEEDED entries of other libs with\n\tDYN_NO_NEEDED if they should not be mentioned in DT_NEEDED of\n\tthe output.\n\t(elf_link_check_versioned_symbol): Remove now unneccesary\n\tDYNAMIC check when traversing dyn_loaded list.\nld/\n\tPR 25593\n\t* ldelf.c (ldelf_try_needed): Add DT_NEEDED lib to input_bfds.\n\t(ldelf_after_open): Save state of input_bfds list before loading\n\tDT_NEEDED libs.  Traverse input_bfds list adding DT_NEEDED tags.\n\tRestore input_bfds list.\n\t* testsuite/ld-cris/gotplt1.d: Adjust for changed .dynstr order.",
    "tree": {
      "sha": "fd7444bdd4f804c1cf0304e82011ea576a731077",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fd7444bdd4f804c1cf0304e82011ea576a731077"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e310298cf3fc02112ac0018260748828affa4061",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e310298cf3fc02112ac0018260748828affa4061",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e310298cf3fc02112ac0018260748828affa4061",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e310298cf3fc02112ac0018260748828affa4061/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b570b954bc5c1d6a6edb363c7bdba814bc1fd174",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b570b954bc5c1d6a6edb363c7bdba814bc1fd174",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b570b954bc5c1d6a6edb363c7bdba814bc1fd174"
    }
  ],
  "stats": {
    "total": 149,
    "additions": 103,
    "deletions": 46
  },
  "files": [
    {
      "sha": "d2791d656c96def7cb98efff51d41ee9a95eb6de",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e310298cf3fc02112ac0018260748828affa4061/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e310298cf3fc02112ac0018260748828affa4061/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=e310298cf3fc02112ac0018260748828affa4061",
      "patch": "@@ -1,3 +1,23 @@\n+2020-02-26  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25593\n+\t* elf-bfd.h (struct elf_link_hash_table): Rename \"loaded\" to\n+\t\"dyn_loaded\".\n+\t(bfd_elf_add_dt_needed_tag): Declare.\n+\t* elf-strtab.c (_bfd_elf_strtab_restore): Handle NULL buf.\n+\t* elflink.c (bfd_elf_add_dt_needed_tag): Make global and rename\n+\tfrom elf_add_dt_needed_tag.  Remove soname and doit param.\n+\t(elf_link_add_object_symbols): Don't use elf_add_dt_needed_tag\n+\tto see whether as-needed lib is already loaded, use dyn_loaded\n+\tlist instead.  When saving and restoring around as-needed lib\n+\thandle possibility that dynstr has not been initialised.  Don't\n+\tadd DT_NEEDED tags here.  Limit dyn_loaded list to dynamic libs.\n+\tMark libs loaded via DT_NEEDED entries of other libs with\n+\tDYN_NO_NEEDED if they should not be mentioned in DT_NEEDED of\n+\tthe output.\n+\t(elf_link_check_versioned_symbol): Remove now unneccesary\n+\tDYNAMIC check when traversing dyn_loaded list.\n+\n 2020-02-26  Alan Modra  <amodra@gmail.com>\n \n \t* bfdio.c (bfd_get_file_size): Ignore bogus archive element sizes."
    },
    {
      "sha": "b9307613635818edc559719feb4b0ea7095ab28e",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e310298cf3fc02112ac0018260748828affa4061/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e310298cf3fc02112ac0018260748828affa4061/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=e310298cf3fc02112ac0018260748828affa4061",
      "patch": "@@ -637,8 +637,8 @@ struct elf_link_hash_table\n   asection *tls_sec;\n   bfd_size_type tls_size;\n \n-  /* A linked list of BFD's loaded in the link.  */\n-  struct elf_link_loaded_list *loaded;\n+  /* A linked list of dynamic BFD's loaded in the link.  */\n+  struct elf_link_loaded_list *dyn_loaded;\n \n   /* Short-cuts to get to dynamic linker sections.  */\n   asection *sgot;\n@@ -2510,6 +2510,8 @@ extern bfd_boolean bfd_elf_link_add_symbols\n   (bfd *, struct bfd_link_info *);\n extern bfd_boolean _bfd_elf_add_dynamic_entry\n   (struct bfd_link_info *, bfd_vma, bfd_vma);\n+extern int bfd_elf_add_dt_needed_tag\n+  (bfd *, struct bfd_link_info *);\n extern bfd_boolean _bfd_elf_link_check_relocs\n   (bfd *, struct bfd_link_info *);\n "
    },
    {
      "sha": "c397180dccab479ff4926f9998efed9509bc45ee",
      "filename": "bfd/elf-strtab.c",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e310298cf3fc02112ac0018260748828affa4061/bfd/elf-strtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e310298cf3fc02112ac0018260748828affa4061/bfd/elf-strtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-strtab.c?ref=e310298cf3fc02112ac0018260748828affa4061",
      "patch": "@@ -245,13 +245,16 @@ _bfd_elf_strtab_save (struct elf_strtab_hash *tab)\n void\n _bfd_elf_strtab_restore (struct elf_strtab_hash *tab, void *buf)\n {\n-  size_t idx, curr_size = tab->size;\n+  size_t idx, curr_size = tab->size, save_size;\n   struct strtab_save *save = (struct strtab_save *) buf;\n \n   BFD_ASSERT (tab->sec_size == 0);\n-  BFD_ASSERT (save->size <= curr_size);\n-  tab->size = save->size;\n-  for (idx = 1; idx < save->size; ++idx)\n+  save_size = 1;\n+  if (save != NULL)\n+    save_size = save->size;\n+  BFD_ASSERT (save_size <= curr_size);\n+  tab->size = save_size;\n+  for (idx = 1; idx < save_size; ++idx)\n     tab->array[idx]->refcount = save->refcount[idx];\n \n   for (; idx < curr_size; ++idx)"
    },
    {
      "sha": "6f03c5c09fdfadd0d02de02f7632fc35aa58ecef",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 43,
      "deletions": 39,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e310298cf3fc02112ac0018260748828affa4061/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e310298cf3fc02112ac0018260748828affa4061/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=e310298cf3fc02112ac0018260748828affa4061",
      "patch": "@@ -3501,23 +3501,21 @@ _bfd_elf_add_dynamic_entry (struct bfd_link_info *info,\n   return TRUE;\n }\n \n-/* Add a DT_NEEDED entry for this dynamic object if DO_IT is true,\n-   otherwise just check whether one already exists.  Returns -1 on error,\n+/* Add a DT_NEEDED entry for this dynamic object.  Returns -1 on error,\n    1 if a DT_NEEDED tag already exists, and 0 on success.  */\n \n-static int\n-elf_add_dt_needed_tag (bfd *abfd,\n-\t\t       struct bfd_link_info *info,\n-\t\t       const char *soname,\n-\t\t       bfd_boolean do_it)\n+int\n+bfd_elf_add_dt_needed_tag (bfd *abfd, struct bfd_link_info *info)\n {\n   struct elf_link_hash_table *hash_table;\n   size_t strindex;\n+  const char *soname;\n \n   if (!_bfd_elf_link_create_dynstrtab (abfd, info))\n     return -1;\n \n   hash_table = elf_hash_table (info);\n+  soname = elf_dt_name (abfd);\n   strindex = _bfd_elf_strtab_add (hash_table->dynstr, soname, FALSE);\n   if (strindex == (size_t) -1)\n     return -1;\n@@ -3547,17 +3545,11 @@ elf_add_dt_needed_tag (bfd *abfd,\n \t  }\n     }\n \n-  if (do_it)\n-    {\n-      if (!_bfd_elf_link_create_dynamic_sections (hash_table->dynobj, info))\n-\treturn -1;\n+  if (!_bfd_elf_link_create_dynamic_sections (hash_table->dynobj, info))\n+    return -1;\n \n-      if (!_bfd_elf_add_dynamic_entry (info, DT_NEEDED, strindex))\n-\treturn -1;\n-    }\n-  else\n-    /* We were just checking for existence of the tag.  */\n-    _bfd_elf_strtab_delref (hash_table->dynstr, strindex);\n+  if (!_bfd_elf_add_dynamic_entry (info, DT_NEEDED, strindex))\n+    return -1;\n \n   return 0;\n }\n@@ -4069,7 +4061,7 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n       char *audit = NULL;\n       struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;\n       const Elf_Internal_Phdr *phdr;\n-      int ret;\n+      struct elf_link_loaded_list *loaded_lib;\n \n       /* ld --just-symbols and dynamic objects don't mix very well.\n \t ld shouldn't allow it.  */\n@@ -4258,15 +4250,22 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n \t will need to know it.  */\n       elf_dt_name (abfd) = soname;\n \n-      ret = elf_add_dt_needed_tag (abfd, info, soname, add_needed);\n-      if (ret < 0)\n-\tgoto error_return;\n-\n       /* If we have already included this dynamic object in the\n \t link, just ignore it.  There is no reason to include a\n \t particular dynamic object more than once.  */\n-      if (ret > 0)\n-\treturn TRUE;\n+      for (loaded_lib = htab->dyn_loaded;\n+\t   loaded_lib != NULL;\n+\t   loaded_lib = loaded_lib->next)\n+\t{\n+\t  if (strcmp (elf_dt_name (loaded_lib->abfd), soname) == 0)\n+\t    return TRUE;\n+\t}\n+\n+      /* Create dynamic sections for backends that require that be done\n+\t before setup_gnu_properties.  */\n+      if (add_needed\n+\t  && !_bfd_elf_link_create_dynamic_sections (abfd, info))\n+\treturn FALSE;\n \n       /* Save the DT_AUDIT entry for the linker emulation code. */\n       elf_dt_audit (abfd) = audit;\n@@ -4389,9 +4388,13 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n       old_table = htab->root.table.table;\n       old_size = htab->root.table.size;\n       old_count = htab->root.table.count;\n-      old_strtab = _bfd_elf_strtab_save (htab->dynstr);\n-      if (old_strtab == NULL)\n-\tgoto error_free_vers;\n+      old_strtab = NULL;\n+      if (htab->dynstr != NULL)\n+\t{\n+\t  old_strtab = _bfd_elf_strtab_save (htab->dynstr);\n+\t  if (old_strtab == NULL)\n+\t    goto error_free_vers;\n+\t}\n \n       for (i = 0; i < htab->root.table.size; i++)\n \t{\n@@ -5102,7 +5105,6 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n \t\t      && !on_needed_list (elf_dt_name (abfd),\n \t\t\t\t\t  htab->needed, NULL))))\n \t    {\n-\t      int ret;\n \t      const char *soname = elf_dt_name (abfd);\n \n \t      info->callbacks->minfo (\"%!\", soname, old_bfd,\n@@ -5127,12 +5129,11 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n \t      elf_dyn_lib_class (abfd) = (enum dynamic_lib_link_class)\n \t\t(elf_dyn_lib_class (abfd) & ~DYN_AS_NEEDED);\n \n+\t      /* Create dynamic sections for backends that require\n+\t\t that be done before setup_gnu_properties.  */\n+\t      if (!_bfd_elf_link_create_dynamic_sections (abfd, info))\n+\t\treturn FALSE;\n \t      add_needed = TRUE;\n-\t      ret = elf_add_dt_needed_tag (abfd, info, soname, add_needed);\n-\t      if (ret < 0)\n-\t\tgoto error_free_vers;\n-\n-\t      BFD_ASSERT (ret == 0);\n \t    }\n \t}\n     }\n@@ -5222,7 +5223,8 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n       memcpy (htab->root.table.table, old_tab, tabsize);\n       htab->root.undefs = old_undefs;\n       htab->root.undefs_tail = old_undefs_tail;\n-      _bfd_elf_strtab_restore (htab->dynstr, old_strtab);\n+      if (htab->dynstr != NULL)\n+\t_bfd_elf_strtab_restore (htab->dynstr, old_strtab);\n       free (old_strtab);\n       old_strtab = NULL;\n       for (i = 0; i < htab->root.table.size; i++)\n@@ -5550,7 +5552,7 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n \t}\n     }\n \n-  if (is_elf_hash_table (htab) && add_needed)\n+  if (dynamic && add_needed)\n     {\n       /* Add this bfd to the loaded list.  */\n       struct elf_link_loaded_list *n;\n@@ -5559,9 +5561,12 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n       if (n == NULL)\n \tgoto error_return;\n       n->abfd = abfd;\n-      n->next = htab->loaded;\n-      htab->loaded = n;\n+      n->next = htab->dyn_loaded;\n+      htab->dyn_loaded = n;\n     }\n+  if (dynamic && !add_needed\n+      && (elf_dyn_lib_class (abfd) & DYN_DT_NEEDED) != 0)\n+    elf_dyn_lib_class (abfd) |= DYN_NO_NEEDED;\n \n   return TRUE;\n \n@@ -9689,7 +9694,7 @@ elf_link_check_versioned_symbol (struct bfd_link_info *info,\n     }\n   BFD_ASSERT (abfd != NULL);\n \n-  for (loaded = elf_hash_table (info)->loaded;\n+  for (loaded = elf_hash_table (info)->dyn_loaded;\n        loaded != NULL;\n        loaded = loaded->next)\n     {\n@@ -9709,7 +9714,6 @@ elf_link_check_versioned_symbol (struct bfd_link_info *info,\n \n       /* We check each DSO for a possible hidden versioned definition.  */\n       if (input == abfd\n-\t  || (input->flags & DYNAMIC) == 0\n \t  || elf_dynversym (input) == 0)\n \tcontinue;\n "
    },
    {
      "sha": "3cb0cf8fbe3eda8de2942605b31736b7fd08a00a",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e310298cf3fc02112ac0018260748828affa4061/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e310298cf3fc02112ac0018260748828affa4061/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=e310298cf3fc02112ac0018260748828affa4061",
      "patch": "@@ -1,3 +1,12 @@\n+2020-02-26  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25593\n+\t* ldelf.c (ldelf_try_needed): Add DT_NEEDED lib to input_bfds.\n+\t(ldelf_after_open): Save state of input_bfds list before loading\n+\tDT_NEEDED libs.  Traverse input_bfds list adding DT_NEEDED tags.\n+\tRestore input_bfds list.\n+\t* testsuite/ld-cris/gotplt1.d: Adjust for changed .dynstr order.\n+\n 2020-02-24  Nick Clifton  <nickc@redhat.com>\n \n \t* po/fr.po: Update French translation."
    },
    {
      "sha": "b055929d02aa60ccdf704b74fab215fff1e929e9",
      "filename": "ld/ldelf.c",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e310298cf3fc02112ac0018260748828affa4061/ld/ldelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e310298cf3fc02112ac0018260748828affa4061/ld/ldelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelf.c?ref=e310298cf3fc02112ac0018260748828affa4061",
      "patch": "@@ -375,6 +375,9 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n \n   bfd_elf_set_dyn_lib_class (abfd, (enum dynamic_lib_link_class) link_class);\n \n+  *link_info.input_bfds_tail = abfd;\n+  link_info.input_bfds_tail = &abfd->link.next;\n+\n   /* Add this file into the symbol table.  */\n   if (! bfd_link_add_symbols (abfd, &link_info))\n     einfo (_(\"%F%P: %pB: error adding symbols: %E\\n\"), abfd);\n@@ -992,6 +995,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n   struct elf_link_hash_table *htab;\n   asection *s;\n   bfd *abfd;\n+  bfd **save_input_bfd_tail;\n \n   after_open_default ();\n \n@@ -1134,6 +1138,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n      special action by the person doing the link.  Note that the\n      needed list can actually grow while we are stepping through this\n      loop.  */\n+  save_input_bfd_tail = link_info.input_bfds_tail;\n   needed = bfd_elf_get_needed_list (link_info.output_bfd, &link_info);\n   for (l = needed; l != NULL; l = l->next)\n     {\n@@ -1290,6 +1295,20 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n \t     l->name, l->by);\n     }\n \n+  for (abfd = link_info.input_bfds; abfd; abfd = abfd->link.next)\n+    if (bfd_get_format (abfd) == bfd_object\n+\t&& ((abfd->flags) & DYNAMIC) != 0\n+\t&& bfd_get_flavour (abfd) == bfd_target_elf_flavour\n+\t&& (elf_dyn_lib_class (abfd) & (DYN_AS_NEEDED | DYN_NO_NEEDED)) == 0\n+\t&& elf_dt_name (abfd) != NULL)\n+      {\n+\tif (bfd_elf_add_dt_needed_tag (abfd, &link_info) < 0)\n+\t  einfo (_(\"%F%P: failed to add DT_NEEDED dynamic tag\\n\"));\n+      }\n+\n+  link_info.input_bfds_tail = save_input_bfd_tail;\n+  *save_input_bfd_tail = NULL;\n+\n   if (link_info.eh_frame_hdr_type == COMPACT_EH_HDR)\n     if (!bfd_elf_parse_eh_frame_entries (NULL, &link_info))\n       einfo (_(\"%F%P: failed to parse EH frame entries\\n\"));"
    },
    {
      "sha": "defba8ad6a96d3406533c845b40b9c09b7d1f9e6",
      "filename": "ld/testsuite/ld-cris/gotplt1.d",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e310298cf3fc02112ac0018260748828affa4061/ld/testsuite/ld-cris/gotplt1.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e310298cf3fc02112ac0018260748828affa4061/ld/testsuite/ld-cris/gotplt1.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-cris/gotplt1.d?ref=e310298cf3fc02112ac0018260748828affa4061",
      "patch": "@@ -34,7 +34,7 @@ Contents of section \\.text:\n  80178 6f0d1000 0000611a 6f2e5401 08000000  .*\n  80188 6f3e70df ffff0000                    .*\n Contents of section \\.dynamic:\n- 82190 01000000 01000000 04000000 e4000800  .*\n+ 82190 01000000 07000000 04000000 e4000800  .*\n  821a0 05000000 18010800 06000000 f8000800  .*\n  821b0 0a000000 1a000000 0b000000 10000000  .*\n  821c0 15000000 00000000 03000000 18220800  .*"
    }
  ]
}