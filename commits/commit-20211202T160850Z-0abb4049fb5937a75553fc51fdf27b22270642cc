{
  "sha": "0abb4049fb5937a75553fc51fdf27b22270642cc",
  "node_id": "C_kwDOANOeidoAKDBhYmI0MDQ5ZmI1OTM3YTc1NTUzZmM1MWZkZjI3YjIyMjcwNjQyY2M",
  "commit": {
    "author": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2019-03-07T07:25:33Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-12-02T16:08:50Z"
    },
    "message": "(RISCV) fix handling of fixed-point type return values\n\nThis commit adds support for TYPE_CODE_FIXED_POINT types for\n\"finish\" and \"return\" commands.\n\nConsider the following Ada code...\n\n   type FP1_Type is delta 0.1 range -1.0 .. +1.0; --  Ordinary\n   function Call_FP1 (F : FP1_Type) return FP1_Type is\n   begin\n      FP1_Arg := F;\n      return FP1_Arg;\n   end Call_FP1;\n\n... used as follow:\n\n   F1 : FP1_Type := 1.0;\n   F1 := Call_FP1 (F1);\n\n\"finish\" currently behaves as follow:\n\n    | (gdb) finish\n    | [...]\n    | Value returned is $1 = 0\n\nWe expect the returned value to be \"1\".\n\nSimilarly, \"return\" makes the function return the wrong value:\n\n    | (gdb) return 1.0\n    | Make pck.call_fp1 return now? (y or n) y\n    | [...]\n    | 9          F1 := Call_FP1 (F1);\n    | (gdb) next\n    | (gdb) print f1\n    | $1 = 0.0625\n\n(we expect it to print \"1\" instead).\n\nThis problem comes from the handling of integral return values\nwhen the return value is actually fixed point type. Our type\nhere is actually a range of a fixed point type, but the same\nprinciples should also apply to pure fixed-point types. For\nthe record, here is what the debugging info looks like:\n\n <1><238>: Abbrev Number: 2 (DW_TAG_subrange_type)\n    <239>   DW_AT_lower_bound : -16\n    <23a>   DW_AT_upper_bound : 16\n    <23b>   DW_AT_name        : pck__fp1_type\n    <23f>   DW_AT_type        : <0x248>\n\n <1><248>: Abbrev Number: 4 (DW_TAG_base_type)\n    <249>   DW_AT_byte_size   : 1\n    <24a>   DW_AT_encoding    : 13      (signed_fixed)\n    <24b>   DW_AT_binary_scale: -4\n    <24c>   DW_AT_name        : pck__Tfp1_typeB\n    <250>   DW_AT_artificial  : 1\n\n... where the scaling factor is 1/16.\n\nLooking at the \"finish\" command, what happens is that riscv_arg_location\ndetermines that our return value should be returned by parameter using\nan integral convention (via builtin type long). And then,\nriscv_return_value uses a cast to that builtin type long to\nstore the value of into a buffer with the right register size.\nThis doesn't work in our case, because the underlying value\nreturned by the function is unscaled, which means it is 16,\nand thus the cast is like doing:\n\n   arg_val = (FP1_Type) 16\n\n... In other words, it is trying to create an FP1_Type enty whose\nvalue is 16. Applying the scaling factor, that's 256, and because\nthe size of FP1_Type is 1 byte, we overflow and thus it ends up\nbeing zero.\n\nThe same happen with the \"return\" function, but the other way around.\n\nThe fix consists in handling fixed-point types separately from\nintegral types.",
    "tree": {
      "sha": "440345168153971059a87c588b56f9170732fcf2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/440345168153971059a87c588b56f9170732fcf2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0abb4049fb5937a75553fc51fdf27b22270642cc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0abb4049fb5937a75553fc51fdf27b22270642cc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0abb4049fb5937a75553fc51fdf27b22270642cc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0abb4049fb5937a75553fc51fdf27b22270642cc/comments",
  "author": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a6617193990fd9b6762d735f742f2df542b859c7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a6617193990fd9b6762d735f742f2df542b859c7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a6617193990fd9b6762d735f742f2df542b859c7"
    }
  ],
  "stats": {
    "total": 47,
    "additions": 44,
    "deletions": 3
  },
  "files": [
    {
      "sha": "b29a23ee70bb87830c29b7941b3bb4fd6ab83445",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 44,
      "deletions": 3,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0abb4049fb5937a75553fc51fdf27b22270642cc/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0abb4049fb5937a75553fc51fdf27b22270642cc/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=0abb4049fb5937a75553fc51fdf27b22270642cc",
      "patch": "@@ -2770,6 +2770,7 @@ riscv_arg_location (struct gdbarch *gdbarch,\n     case TYPE_CODE_RANGE:\n     case TYPE_CODE_ENUM:\n     case TYPE_CODE_PTR:\n+    case TYPE_CODE_FIXED_POINT:\n       if (ainfo->length <= cinfo->xlen)\n \t{\n \t  ainfo->type = builtin_type (gdbarch)->builtin_long;\n@@ -3144,8 +3145,30 @@ riscv_return_value (struct gdbarch  *gdbarch,\n \t   buffers of sufficient size.  */\n \tif (writebuf != nullptr)\n \t  {\n-\t    struct value *arg_val = value_from_contents (arg_type, writebuf);\n-\t    abi_val = value_cast (info.type, arg_val);\n+\t    struct value *arg_val;\n+\n+\t    if (is_fixed_point_type (arg_type))\n+\t      {\n+\t\t/* Convert the argument to the type used to pass\n+\t\t   the return value, but being careful to preserve\n+\t\t   the fact that the value needs to be returned\n+\t\t   unscaled.  */\n+\t\tgdb_mpz unscaled;\n+\n+\t\tunscaled.read (gdb::make_array_view (writebuf,\n+\t\t\t\t\t\t     TYPE_LENGTH (arg_type)),\n+\t\t\t       type_byte_order (arg_type),\n+\t\t\t       arg_type->is_unsigned ());\n+\t\tabi_val = allocate_value (info.type);\n+\t\tunscaled.write (value_contents_raw (abi_val),\n+\t\t\t\ttype_byte_order (info.type),\n+\t\t\t\tinfo.type->is_unsigned ());\n+\t      }\n+\t    else\n+\t      {\n+\t\targ_val = value_from_contents (arg_type, writebuf);\n+\t\tabi_val = value_cast (info.type, arg_val);\n+\t      }\n \t    writebuf = value_contents_raw (abi_val).data ();\n \t  }\n \telse\n@@ -3249,7 +3272,25 @@ riscv_return_value (struct gdbarch  *gdbarch,\n \t   comment at the head of this block for more details.  */\n \tif (readbuf != nullptr)\n \t  {\n-\t    struct value *arg_val = value_cast (arg_type, abi_val);\n+\t    struct value *arg_val;\n+\n+\t    if (is_fixed_point_type (arg_type))\n+\t      {\n+\t\t/* Convert abi_val to the actual return type, but\n+\t\t   being careful to preserve the fact that abi_val\n+\t\t   is unscaled.  */\n+\t\tgdb_mpz unscaled;\n+\n+\t\tunscaled.read (value_contents (abi_val),\n+\t\t\t       type_byte_order (info.type),\n+\t\t\t       info.type->is_unsigned ());\n+\t\targ_val = allocate_value (arg_type);\n+\t\tunscaled.write (value_contents_raw (arg_val),\n+\t\t\t\ttype_byte_order (arg_type),\n+\t\t\t\targ_type->is_unsigned ());\n+\t      }\n+\t    else\n+\t      arg_val = value_cast (arg_type, abi_val);\n \t    memcpy (old_readbuf, value_contents_raw (arg_val).data (),\n \t\t    TYPE_LENGTH (arg_type));\n \t  }"
    }
  ]
}