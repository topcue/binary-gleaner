{
  "sha": "df95181f00dacf335deb4415e3e6061548b917ba",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGY5NTE4MWYwMGRhY2YzMzVkZWI0NDE1ZTNlNjA2MTU0OGI5MTdiYQ==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-04-02T13:11:24Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-04-02T13:11:24Z"
    },
    "message": "gdbserver/linux-low: turn some more static functions into private methods\n\ngdbserver/ChangeLog:\n2020-04-02  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\tTurn some more static methods in linux-low into private methods\n\tof linux_process_target.\n\n\t* linux-low.cc (get_pc): Turn into...\n\t(linux_process_target::get_pc): ...this.\n\t(save_stop_reason): Turn into...\n\t(linux_process_target::save_stop_reason): ...this.\n\t(thread_still_has_status_pending_p): Turn into...\n\t(linux_process_target::thread_still_has_status_pending): ...this.\n\t(status_pending_p_callback): Turn into...\n\t(linux_process_target::status_pending_p_callback): ...this.\n\t(resume_stopped_resumed_lwps): Turn into...\n\t(linux_process_target::resume_stopped_resumed_lwps): ...this.\n\t(install_software_single_step_breakpoints): Turn into...\n\t(linux_process_target::install_software_single_step_breakpoints):\n\t...this.\n\t(single_step): Turn into...\n\t(linux_process_target::single_step): ...this.\n\t(linux_resume_one_lwp_throw): Turn into...\n\t(linux_process_target::resume_one_lwp_throw): ...this.\n\t(linux_resume_one_lwp): Turn into...\n\t(linux_process_target::resume_one_lwp): ...this.\n\t(resume_status_pending_p): Turn into...\n\t(linux_process_target::resume_status_pending): ...this.\n\t(need_step_over_p): Turn into...\n\t(linux_process_target::thread_needs_step_over): ...this.\n\t(linux_resume_one_thread): Turn into...\n\t(linux_process_target::resume_one_thread): ...this.\n\t(proceed_one_lwp): Turn into...\n\t(linux_process_target::proceed_one_lwp): ...this.\n\t(unsuspend_and_proceed_one_lwp): Turn into...\n\t(linux_process_target::unsuspend_and_proceed_one_lwp): ...this.\n\n\tUpdate the calls/references to the above functions below.\n\n\t(linux_process_target::handle_extended_wait)\n\t(linux_process_target::filter_event)\n\t(linux_process_target::wait_for_event_filtered)\n\t(linux_process_target::wait_1)\n\t(linux_process_target::move_out_of_jump_pad)\n\t(linux_process_target::start_step_over)\n\t(linux_process_target::resume)\n\t(linux_process_target::proceed_all_lwps)\n\t(regsets_store_inferior_registers)\n\t(linux_process_target::store_register)\n\n\t* linux-low.h (class linux_process_target)\n\t<get_pc>\n\t<save_stop_reason>\n\t<thread_still_has_status_pending>\n\t<status_pending_p_callback>\n\t<resume_stopped_resumed_lwps>\n\t<install_software_single_step_breakpoints>\n\t<single_step>\n\t<resume_one_lwp_throw>\n\t<resume_one_lwp>\n\t<resume_status_pending>\n\t<thread_needs_step_over>\n\t<resume_one_thread>\n\t<proceed_one_lwp>\n\t<unsuspend_and_proceed_one_lwp>: Declare.",
    "tree": {
      "sha": "aaff361aee36633c89558b60be7de3f785a1778a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/aaff361aee36633c89558b60be7de3f785a1778a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/df95181f00dacf335deb4415e3e6061548b917ba",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/df95181f00dacf335deb4415e3e6061548b917ba",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/df95181f00dacf335deb4415e3e6061548b917ba",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/df95181f00dacf335deb4415e3e6061548b917ba/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bd70b1f240b24d8c9b08868ca777f5a81d13c0c2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bd70b1f240b24d8c9b08868ca777f5a81d13c0c2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bd70b1f240b24d8c9b08868ca777f5a81d13c0c2"
    }
  ],
  "stats": {
    "total": 334,
    "additions": 213,
    "deletions": 121
  },
  "files": [
    {
      "sha": "d6d5eee856eff2f5a30c9a1b94aa717de463e6b5",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 64,
      "deletions": 0,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/df95181f00dacf335deb4415e3e6061548b917ba/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/df95181f00dacf335deb4415e3e6061548b917ba/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=df95181f00dacf335deb4415e3e6061548b917ba",
      "patch": "@@ -1,3 +1,67 @@\n+2020-04-02  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\tTurn some more static methods in linux-low into private methods\n+\tof linux_process_target.\n+\n+\t* linux-low.cc (get_pc): Turn into...\n+\t(linux_process_target::get_pc): ...this.\n+\t(save_stop_reason): Turn into...\n+\t(linux_process_target::save_stop_reason): ...this.\n+\t(thread_still_has_status_pending_p): Turn into...\n+\t(linux_process_target::thread_still_has_status_pending): ...this.\n+\t(status_pending_p_callback): Turn into...\n+\t(linux_process_target::status_pending_p_callback): ...this.\n+\t(resume_stopped_resumed_lwps): Turn into...\n+\t(linux_process_target::resume_stopped_resumed_lwps): ...this.\n+\t(install_software_single_step_breakpoints): Turn into...\n+\t(linux_process_target::install_software_single_step_breakpoints):\n+\t...this.\n+\t(single_step): Turn into...\n+\t(linux_process_target::single_step): ...this.\n+\t(linux_resume_one_lwp_throw): Turn into...\n+\t(linux_process_target::resume_one_lwp_throw): ...this.\n+\t(linux_resume_one_lwp): Turn into...\n+\t(linux_process_target::resume_one_lwp): ...this.\n+\t(resume_status_pending_p): Turn into...\n+\t(linux_process_target::resume_status_pending): ...this.\n+\t(need_step_over_p): Turn into...\n+\t(linux_process_target::thread_needs_step_over): ...this.\n+\t(linux_resume_one_thread): Turn into...\n+\t(linux_process_target::resume_one_thread): ...this.\n+\t(proceed_one_lwp): Turn into...\n+\t(linux_process_target::proceed_one_lwp): ...this.\n+\t(unsuspend_and_proceed_one_lwp): Turn into...\n+\t(linux_process_target::unsuspend_and_proceed_one_lwp): ...this.\n+\n+\tUpdate the calls/references to the above functions below.\n+\n+\t(linux_process_target::handle_extended_wait)\n+\t(linux_process_target::filter_event)\n+\t(linux_process_target::wait_for_event_filtered)\n+\t(linux_process_target::wait_1)\n+\t(linux_process_target::move_out_of_jump_pad)\n+\t(linux_process_target::start_step_over)\n+\t(linux_process_target::resume)\n+\t(linux_process_target::proceed_all_lwps)\n+\t(regsets_store_inferior_registers)\n+\t(linux_process_target::store_register)\n+\n+\t* linux-low.h (class linux_process_target)\n+\t<get_pc>\n+\t<save_stop_reason>\n+\t<thread_still_has_status_pending>\n+\t<status_pending_p_callback>\n+\t<resume_stopped_resumed_lwps>\n+\t<install_software_single_step_breakpoints>\n+\t<single_step>\n+\t<resume_one_lwp_throw>\n+\t<resume_one_lwp>\n+\t<resume_status_pending>\n+\t<thread_needs_step_over>\n+\t<resume_one_thread>\n+\t<proceed_one_lwp>\n+\t<unsuspend_and_proceed_one_lwp>: Declare.\n+\n 2020-04-02  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \tTurn the 'fetch_register' linux target op into a method of"
    },
    {
      "sha": "65edde8b0e80007e5acffd82afdc9ddb6a5dc364",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 71,
      "deletions": 121,
      "changes": 192,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/df95181f00dacf335deb4415e3e6061548b917ba/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/df95181f00dacf335deb4415e3e6061548b917ba/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=df95181f00dacf335deb4415e3e6061548b917ba",
      "patch": "@@ -267,8 +267,6 @@ int using_threads = 1;\n    jump pads).  */\n static int stabilizing_threads;\n \n-static void linux_resume_one_lwp (struct lwp_info *lwp,\n-\t\t\t\t  int step, int signal, siginfo_t *info);\n static void unsuspend_all_lwps (struct lwp_info *except);\n static struct lwp_info *add_lwp (ptid_t ptid);\n static void mark_lwp_dead (struct lwp_info *lwp, int wstat);\n@@ -278,7 +276,6 @@ static int kill_lwp (unsigned long lwpid, int signo);\n static void enqueue_pending_signal (struct lwp_info *lwp, int signal, siginfo_t *info);\n static int linux_low_ptrace_options (int attached);\n static int check_ptrace_stopped_lwp_gone (struct lwp_info *lp);\n-static void proceed_one_lwp (thread_info *thread, lwp_info *except);\n \n /* When the event-loop is doing a step-over, this points at the thread\n    being stepped.  */\n@@ -438,8 +435,6 @@ linux_add_process (int pid, int attached)\n   return proc;\n }\n \n-static CORE_ADDR get_pc (struct lwp_info *lwp);\n-\n void\n linux_process_target::arch_setup_thread (thread_info *thread)\n {\n@@ -616,9 +611,9 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n       new_lwp = add_lwp (ptid);\n \n       /* Either we're going to immediately resume the new thread\n-\t or leave it stopped.  linux_resume_one_lwp is a nop if it\n+\t or leave it stopped.  resume_one_lwp is a nop if it\n \t thinks the thread is currently running, so set this first\n-\t before calling linux_resume_one_lwp.  */\n+\t before calling resume_one_lwp.  */\n       new_lwp->stopped = 1;\n \n       /* If we're suspending all threads, leave this one suspended\n@@ -726,11 +721,8 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n   internal_error (__FILE__, __LINE__, _(\"unknown ptrace event %d\"), event);\n }\n \n-/* Return the PC as read from the regcache of LWP, without any\n-   adjustment.  */\n-\n-static CORE_ADDR\n-get_pc (struct lwp_info *lwp)\n+CORE_ADDR\n+linux_process_target::get_pc (lwp_info *lwp)\n {\n   struct thread_info *saved_thread;\n   struct regcache *regcache;\n@@ -783,14 +775,8 @@ get_syscall_trapinfo (struct lwp_info *lwp, int *sysno)\n \n static int check_stopped_by_watchpoint (struct lwp_info *child);\n \n-/* Called when the LWP stopped for a signal/trap.  If it stopped for a\n-   trap check what caused it (breakpoint, watchpoint, trace, etc.),\n-   and save the result in the LWP's stop_reason field.  If it stopped\n-   for a breakpoint, decrement the PC if necessary on the lwp's\n-   architecture.  Returns true if we now have the LWP's stop PC.  */\n-\n-static int\n-save_stop_reason (struct lwp_info *lwp)\n+bool\n+linux_process_target::save_stop_reason (lwp_info *lwp)\n {\n   CORE_ADDR pc;\n   CORE_ADDR sw_breakpoint_pc;\n@@ -800,7 +786,7 @@ save_stop_reason (struct lwp_info *lwp)\n #endif\n \n   if (the_low_target.get_pc == NULL)\n-    return 0;\n+    return false;\n \n   pc = get_pc (lwp);\n   sw_breakpoint_pc = pc - the_low_target.decr_pc_after_break;\n@@ -921,7 +907,7 @@ save_stop_reason (struct lwp_info *lwp)\n \n   lwp->stop_pc = pc;\n   current_thread = saved_thread;\n-  return 1;\n+  return true;\n }\n \n static struct lwp_info *\n@@ -1678,12 +1664,8 @@ linux_process_target::thread_alive (ptid_t ptid)\n     return 0;\n }\n \n-/* Return 1 if this lwp still has an interesting status pending.  If\n-   not (e.g., it had stopped for a breakpoint that is gone), return\n-   false.  */\n-\n-static int\n-thread_still_has_status_pending_p (struct thread_info *thread)\n+bool\n+linux_process_target::thread_still_has_status_pending (thread_info *thread)\n {\n   struct lwp_info *lp = get_thread_lwp (thread);\n \n@@ -1766,9 +1748,9 @@ lwp_resumed (struct lwp_info *lwp)\n   return 0;\n }\n \n-/* Return true if this lwp has an interesting status pending.  */\n-static bool\n-status_pending_p_callback (thread_info *thread, ptid_t ptid)\n+bool\n+linux_process_target::status_pending_p_callback (thread_info *thread,\n+\t\t\t\t\t\t ptid_t ptid)\n {\n   struct lwp_info *lp = get_thread_lwp (thread);\n \n@@ -1781,9 +1763,9 @@ status_pending_p_callback (thread_info *thread, ptid_t ptid)\n     return 0;\n \n   if (lp->status_pending_p\n-      && !thread_still_has_status_pending_p (thread))\n+      && !thread_still_has_status_pending (thread))\n     {\n-      linux_resume_one_lwp (lp, lp->stepping, GDB_SIGNAL_0, NULL);\n+      resume_one_lwp (lp, lp->stepping, GDB_SIGNAL_0, NULL);\n       return 0;\n     }\n \n@@ -2517,7 +2499,7 @@ linux_process_target::filter_event (int lwpid, int wstat)\n \t\t\t  child->stepping ? \"step\" : \"continue\",\n \t\t\t  target_pid_to_str (ptid_of (thread)));\n \n-\t  linux_resume_one_lwp (child, child->stepping, 0, NULL);\n+\t  resume_one_lwp (child, child->stepping, 0, NULL);\n \t  return NULL;\n \t}\n     }\n@@ -2543,11 +2525,8 @@ maybe_hw_step (struct thread_info *thread)\n     }\n }\n \n-/* Resume LWPs that are currently stopped without any pending status\n-   to report, but are resumed from the core's perspective.  */\n-\n-static void\n-resume_stopped_resumed_lwps (thread_info *thread)\n+void\n+linux_process_target::resume_stopped_resumed_lwps (thread_info *thread)\n {\n   struct lwp_info *lp = get_thread_lwp (thread);\n \n@@ -2567,7 +2546,7 @@ resume_stopped_resumed_lwps (thread_info *thread)\n \t\t      paddress (lp->stop_pc),\n \t\t      step);\n \n-      linux_resume_one_lwp (lp, step, GDB_SIGNAL_0, NULL);\n+      resume_one_lwp (lp, step, GDB_SIGNAL_0, NULL);\n     }\n }\n \n@@ -2614,7 +2593,7 @@ linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n \t\t\t\t       &requested_child->status_pending);\n \t  requested_child->status_pending_p = 0;\n \t  requested_child->status_pending = 0;\n-\t  linux_resume_one_lwp (requested_child, 0, 0, NULL);\n+\t  resume_one_lwp (requested_child, 0, 0, NULL);\n \t}\n \n       if (requested_child->suspended\n@@ -2702,7 +2681,10 @@ linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n       /* Now that we've pulled all events out of the kernel, resume\n \t LWPs that don't have an interesting event to report.  */\n       if (stopping_threads == NOT_STOPPING_THREADS)\n-\tfor_each_thread (resume_stopped_resumed_lwps);\n+\tfor_each_thread ([this] (thread_info *thread)\n+\t  {\n+\t    resume_stopped_resumed_lwps (thread);\n+\t  });\n \n       /* ... and find an LWP with a status to report to the core, if\n \t any.  */\n@@ -3272,7 +3254,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t    debug_printf (\"Signal %d for LWP %ld deferred (in jump pad)\\n\",\n \t\t\t  WSTOPSIG (w), lwpid_of (current_thread));\n \n-\t  linux_resume_one_lwp (event_child, 0, 0, NULL);\n+\t  resume_one_lwp (event_child, 0, 0, NULL);\n \n \t  if (debug_threads)\n \t    debug_exit ();\n@@ -3372,8 +3354,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t\t\tlwpid_of (current_thread));\n \t}\n \n-      linux_resume_one_lwp (event_child, event_child->stepping,\n-\t\t\t    0, NULL);\n+      resume_one_lwp (event_child, event_child->stepping, 0, NULL);\n \n       if (debug_threads)\n \tdebug_exit ();\n@@ -3429,8 +3410,8 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t}\n       else\n \t{\n-\t  linux_resume_one_lwp (event_child, event_child->stepping,\n-\t\t\t\tWSTOPSIG (w), info_p);\n+\t  resume_one_lwp (event_child, event_child->stepping,\n+\t\t\t  WSTOPSIG (w), info_p);\n \t}\n \n       if (debug_threads)\n@@ -4039,7 +4020,7 @@ linux_process_target::move_out_of_jump_pad (thread_info *thread)\n \t\t\t  WSTOPSIG (*wstat), lwpid_of (thread));\n \t}\n \n-      linux_resume_one_lwp (lwp, 0, 0, NULL);\n+      resume_one_lwp (lwp, 0, 0, NULL);\n     }\n   else\n     lwp_suspended_inc (lwp);\n@@ -4117,10 +4098,8 @@ enqueue_pending_signal (struct lwp_info *lwp, int signal, siginfo_t *info)\n   lwp->pending_signals = p_sig;\n }\n \n-/* Install breakpoints for software single stepping.  */\n-\n-static void\n-install_software_single_step_breakpoints (struct lwp_info *lwp)\n+void\n+linux_process_target::install_software_single_step_breakpoints (lwp_info *lwp)\n {\n   struct thread_info *thread = get_lwp_thread (lwp);\n   struct regcache *regcache = get_thread_regcache (thread, 1);\n@@ -4134,12 +4113,8 @@ install_software_single_step_breakpoints (struct lwp_info *lwp)\n     set_single_step_breakpoint (pc, current_ptid);\n }\n \n-/* Single step via hardware or software single step.\n-   Return 1 if hardware single stepping, 0 if software single stepping\n-   or can't single step.  */\n-\n-static int\n-single_step (struct lwp_info* lwp)\n+int\n+linux_process_target::single_step (lwp_info* lwp)\n {\n   int step = 0;\n \n@@ -4174,12 +4149,9 @@ lwp_signal_can_be_delivered (struct lwp_info *lwp)\n \t  == fast_tpoint_collect_result::not_collecting);\n }\n \n-/* Resume execution of LWP.  If STEP is nonzero, single-step it.  If\n-   SIGNAL is nonzero, give it that signal.  */\n-\n-static void\n-linux_resume_one_lwp_throw (struct lwp_info *lwp,\n-\t\t\t    int step, int signal, siginfo_t *info)\n+void\n+linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n+\t\t\t\t\t    int signal, siginfo_t *info)\n {\n   struct thread_info *thread = get_lwp_thread (lwp);\n   struct thread_info *saved_thread;\n@@ -4416,16 +4388,13 @@ check_ptrace_stopped_lwp_gone (struct lwp_info *lp)\n   return 0;\n }\n \n-/* Like linux_resume_one_lwp_throw, but no error is thrown if the LWP\n-   disappears while we try to resume it.  */\n-\n-static void\n-linux_resume_one_lwp (struct lwp_info *lwp,\n-\t\t      int step, int signal, siginfo_t *info)\n+void\n+linux_process_target::resume_one_lwp (lwp_info *lwp, int step, int signal,\n+\t\t\t\t      siginfo_t *info)\n {\n   try\n     {\n-      linux_resume_one_lwp_throw (lwp, step, signal, info);\n+      resume_one_lwp_throw (lwp, step, signal, info);\n     }\n   catch (const gdb_exception_error &ex)\n     {\n@@ -4546,11 +4515,8 @@ linux_set_resume_request (thread_info *thread, thread_resume *resume, size_t n)\n   lwp->resume = NULL;\n }\n \n-/* find_thread callback for linux_resume.  Return true if this lwp has an\n-   interesting status pending.  */\n-\n-static bool\n-resume_status_pending_p (thread_info *thread)\n+bool\n+linux_process_target::resume_status_pending (thread_info *thread)\n {\n   struct lwp_info *lwp = get_thread_lwp (thread);\n \n@@ -4559,16 +4525,11 @@ resume_status_pending_p (thread_info *thread)\n   if (lwp->resume == NULL)\n     return false;\n \n-  return thread_still_has_status_pending_p (thread);\n+  return thread_still_has_status_pending (thread);\n }\n \n-/* Return 1 if this lwp that GDB wants running is stopped at an\n-   internal breakpoint that we need to step over.  It assumes that any\n-   required STOP_PC adjustment has already been propagated to the\n-   inferior's regcache.  */\n-\n-static bool\n-need_step_over_p (thread_info *thread)\n+bool\n+linux_process_target::thread_needs_step_over (thread_info *thread)\n {\n   struct lwp_info *lwp = get_thread_lwp (thread);\n   struct thread_info *saved_thread;\n@@ -4739,7 +4700,7 @@ linux_process_target::start_step_over (lwp_info *lwp)\n \n   current_thread = saved_thread;\n \n-  linux_resume_one_lwp (lwp, step, 0, NULL);\n+  resume_one_lwp (lwp, step, 0, NULL);\n \n   /* Require next event from this LWP.  */\n   step_over_bkpt = thread->id;\n@@ -4814,21 +4775,9 @@ linux_process_target::complete_ongoing_step_over ()\n     }\n }\n \n-/* This function is called once per thread.  We check the thread's resume\n-   request, which will tell us whether to resume, step, or leave the thread\n-   stopped; and what signal, if any, it should be sent.\n-\n-   For threads which we aren't explicitly told otherwise, we preserve\n-   the stepping flag; this is used for stepping over gdbserver-placed\n-   breakpoints.\n-\n-   If pending_flags was set in any thread, we queue any needed\n-   signals, since we won't actually resume.  We already have a pending\n-   event to report, so we don't need to preserve any step requests;\n-   they should be re-issued if necessary.  */\n-\n-static void\n-linux_resume_one_thread (thread_info *thread, bool leave_all_stopped)\n+void\n+linux_process_target::resume_one_thread (thread_info *thread,\n+\t\t\t\t\t bool leave_all_stopped)\n {\n   struct lwp_info *lwp = get_thread_lwp (thread);\n   int leave_pending;\n@@ -4955,7 +4904,10 @@ linux_process_target::resume (thread_resume *resume_info, size_t n)\n      before considering to start a step-over (in all-stop).  */\n   bool any_pending = false;\n   if (!non_stop)\n-    any_pending = find_thread (resume_status_pending_p) != NULL;\n+    any_pending = find_thread ([this] (thread_info *thread)\n+\t\t    {\n+\t\t      return resume_status_pending (thread);\n+\t\t    }) != nullptr;\n \n   /* If there is a thread which would otherwise be resumed, which is\n      stopped at a breakpoint that needs stepping over, then don't\n@@ -4964,7 +4916,10 @@ linux_process_target::resume (thread_resume *resume_info, size_t n)\n      to queue any signals that would otherwise be delivered or\n      queued.  */\n   if (!any_pending && supports_breakpoints ())\n-    need_step_over = find_thread (need_step_over_p);\n+    need_step_over = find_thread ([this] (thread_info *thread)\n+\t\t       {\n+\t\t\t return thread_needs_step_over (thread);\n+\t\t       });\n \n   bool leave_all_stopped = (need_step_over != NULL || any_pending);\n \n@@ -4983,7 +4938,7 @@ linux_process_target::resume (thread_resume *resume_info, size_t n)\n      otherwise deliver.  */\n   for_each_thread ([&] (thread_info *thread)\n     {\n-      linux_resume_one_thread (thread, leave_all_stopped);\n+      resume_one_thread (thread, leave_all_stopped);\n     });\n \n   if (need_step_over)\n@@ -5001,17 +4956,8 @@ linux_process_target::resume (thread_resume *resume_info, size_t n)\n     async_file_mark ();\n }\n \n-/* This function is called once per thread.  We check the thread's\n-   last resume request, which will tell us whether to resume, step, or\n-   leave the thread stopped.  Any signal the client requested to be\n-   delivered has already been enqueued at this point.\n-\n-   If any thread that GDB wants running is stopped at an internal\n-   breakpoint that needs stepping over, we start a step-over operation\n-   on that particular thread, and leave all others stopped.  */\n-\n-static void\n-proceed_one_lwp (thread_info *thread, lwp_info *except)\n+void\n+linux_process_target::proceed_one_lwp (thread_info *thread, lwp_info *except)\n {\n   struct lwp_info *lwp = get_thread_lwp (thread);\n   int step;\n@@ -5104,11 +5050,12 @@ proceed_one_lwp (thread_info *thread, lwp_info *except)\n   else\n     step = 0;\n \n-  linux_resume_one_lwp (lwp, step, 0, NULL);\n+  resume_one_lwp (lwp, step, 0, NULL);\n }\n \n-static void\n-unsuspend_and_proceed_one_lwp (thread_info *thread, lwp_info *except)\n+void\n+linux_process_target::unsuspend_and_proceed_one_lwp (thread_info *thread,\n+\t\t\t\t\t\t     lwp_info *except)\n {\n   struct lwp_info *lwp = get_thread_lwp (thread);\n \n@@ -5132,7 +5079,10 @@ linux_process_target::proceed_all_lwps ()\n \n   if (supports_breakpoints ())\n     {\n-      need_step_over = find_thread (need_step_over_p);\n+      need_step_over = find_thread ([this] (thread_info *thread)\n+\t\t\t {\n+\t\t\t   return thread_needs_step_over (thread);\n+\t\t\t });\n \n       if (need_step_over != NULL)\n \t{\n@@ -5149,7 +5099,7 @@ linux_process_target::proceed_all_lwps ()\n   if (debug_threads)\n     debug_printf (\"Proceeding, no step-over needed\\n\");\n \n-  for_each_thread ([] (thread_info *thread)\n+  for_each_thread ([this] (thread_info *thread)\n     {\n       proceed_one_lwp (thread, NULL);\n     });\n@@ -5362,7 +5312,7 @@ regsets_store_inferior_registers (struct regsets_info *regsets_info,\n \t      /* At this point, ESRCH should mean the process is\n \t\t already gone, in which case we simply ignore attempts\n \t\t to change its registers.  See also the related\n-\t\t comment in linux_resume_one_lwp.  */\n+\t\t comment in resume_one_lwp.  */\n \t      free (buf);\n \t      return 0;\n \t    }\n@@ -5509,7 +5459,7 @@ linux_process_target::store_register (const usrregs_info *usrregs,\n \t  /* At this point, ESRCH should mean the process is\n \t     already gone, in which case we simply ignore attempts\n \t     to change its registers.  See also the related\n-\t     comment in linux_resume_one_lwp.  */\n+\t     comment in resume_one_lwp.  */\n \t  if (errno == ESRCH)\n \t    return;\n "
    },
    {
      "sha": "4f5502b46406ae0f87a768e83cc5c6f07cc2b221",
      "filename": "gdbserver/linux-low.h",
      "status": "modified",
      "additions": 78,
      "deletions": 0,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/df95181f00dacf335deb4415e3e6061548b917ba/gdbserver/linux-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/df95181f00dacf335deb4415e3e6061548b917ba/gdbserver/linux-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.h?ref=df95181f00dacf335deb4415e3e6061548b917ba",
      "patch": "@@ -580,6 +580,84 @@ class linux_process_target : public process_stratum_target\n   void usr_store_inferior_registers (const regs_info *regs_info,\n \t\t\t\t     regcache *regcache, int regno, int all);\n \n+  /* Return the PC as read from the regcache of LWP, without any\n+     adjustment.  */\n+  CORE_ADDR get_pc (lwp_info *lwp);\n+\n+  /* Called when the LWP stopped for a signal/trap.  If it stopped for a\n+     trap check what caused it (breakpoint, watchpoint, trace, etc.),\n+     and save the result in the LWP's stop_reason field.  If it stopped\n+     for a breakpoint, decrement the PC if necessary on the lwp's\n+     architecture.  Returns true if we now have the LWP's stop PC.  */\n+  bool save_stop_reason (lwp_info *lwp);\n+\n+  /* Resume execution of LWP.  If STEP is nonzero, single-step it.  If\n+     SIGNAL is nonzero, give it that signal.  */\n+  void resume_one_lwp_throw (lwp_info *lwp, int step, int signal,\n+\t\t\t     siginfo_t *info);\n+\n+  /* Like resume_one_lwp_throw, but no error is thrown if the LWP\n+     disappears while we try to resume it.  */\n+  void resume_one_lwp (lwp_info *lwp, int step, int signal, siginfo_t *info);\n+\n+  /* This function is called once per thread.  We check the thread's\n+     last resume request, which will tell us whether to resume, step, or\n+     leave the thread stopped.  Any signal the client requested to be\n+     delivered has already been enqueued at this point.\n+\n+     If any thread that GDB wants running is stopped at an internal\n+     breakpoint that needs stepping over, we start a step-over operation\n+     on that particular thread, and leave all others stopped.  */\n+  void proceed_one_lwp (thread_info *thread, lwp_info *except);\n+\n+  /* This function is called once per thread.  We check the thread's\n+     resume request, which will tell us whether to resume, step, or\n+     leave the thread stopped; and what signal, if any, it should be\n+     sent.\n+\n+     For threads which we aren't explicitly told otherwise, we preserve\n+     the stepping flag; this is used for stepping over gdbserver-placed\n+     breakpoints.\n+\n+     If pending_flags was set in any thread, we queue any needed\n+     signals, since we won't actually resume.  We already have a pending\n+     event to report, so we don't need to preserve any step requests;\n+     they should be re-issued if necessary.  */\n+  void resume_one_thread (thread_info *thread, bool leave_all_stopped);\n+\n+  /* Return true if this lwp has an interesting status pending.  */\n+  bool status_pending_p_callback (thread_info *thread, ptid_t ptid);\n+\n+  /* Resume LWPs that are currently stopped without any pending status\n+     to report, but are resumed from the core's perspective.  */\n+  void resume_stopped_resumed_lwps (thread_info *thread);\n+\n+  /* Unsuspend THREAD, except EXCEPT, and proceed.  */\n+  void unsuspend_and_proceed_one_lwp (thread_info *thread, lwp_info *except);\n+\n+  /* Return true if this lwp still has an interesting status pending.\n+     If not (e.g., it had stopped for a breakpoint that is gone), return\n+     false.  */\n+  bool thread_still_has_status_pending (thread_info *thread);\n+\n+  /* Return true if this lwp is to-be-resumed and has an interesting\n+     status pending.  */\n+  bool resume_status_pending (thread_info *thread);\n+\n+  /* Return true if this lwp that GDB wants running is stopped at an\n+     internal breakpoint that we need to step over.  It assumes that\n+     any required STOP_PC adjustment has already been propagated to\n+     the inferior's regcache.  */\n+  bool thread_needs_step_over (thread_info *thread);\n+\n+  /* Single step via hardware or software single step.\n+     Return 1 if hardware single stepping, 0 if software single stepping\n+     or can't single step.  */\n+  int single_step (lwp_info* lwp);\n+\n+  /* Install breakpoints for software single stepping.  */\n+  void install_software_single_step_breakpoints (lwp_info *lwp);\n+\n protected:\n   /* The architecture-specific \"low\" methods are listed below.  */\n "
    }
  ]
}