{
  "sha": "c272a98cbf596ddf1a70a41801c6e86d9564d152",
  "node_id": "C_kwDOANOeidoAKGMyNzJhOThjYmY1OTZkZGYxYTcwYTQxODAxYzZlODZkOTU2NGQxNTI",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-11-22T16:27:31Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-11-22T18:57:54Z"
    },
    "message": "gdb: pass more const target_waitstatus by reference\n\nWhile working on target_waitstatus changes, I noticed a few places where\nconst target_waitstatus objects could be passed by reference instead of\nby pointers.  And in some cases, places where a target_waitstatus could\nbe passed as const, but was not.  Convert them as much as possible.\n\nChange-Id: Ied552d464be5d5b87489913b95f9720a5ad50c5a",
    "tree": {
      "sha": "366b8b105f8450dd1894aebbbae82b8e1946d249",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/366b8b105f8450dd1894aebbbae82b8e1946d249"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c272a98cbf596ddf1a70a41801c6e86d9564d152",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c272a98cbf596ddf1a70a41801c6e86d9564d152",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c272a98cbf596ddf1a70a41801c6e86d9564d152",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c272a98cbf596ddf1a70a41801c6e86d9564d152/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "06de25b7af21eb1173d7b86c5c0f37aae5ec2674",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/06de25b7af21eb1173d7b86c5c0f37aae5ec2674",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/06de25b7af21eb1173d7b86c5c0f37aae5ec2674"
    }
  ],
  "stats": {
    "total": 249,
    "additions": 124,
    "deletions": 125
  },
  "files": [
    {
      "sha": "7fe35dcdb0cfc374e154efbc8583f5758b4d06ae",
      "filename": "gdb/break-catch-sig.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/break-catch-sig.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/break-catch-sig.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-sig.c?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -149,16 +149,16 @@ static int\n signal_catchpoint_breakpoint_hit (const struct bp_location *bl,\n \t\t\t\t  const address_space *aspace,\n \t\t\t\t  CORE_ADDR bp_addr,\n-\t\t\t\t  const struct target_waitstatus *ws)\n+\t\t\t\t  const target_waitstatus &ws)\n {\n   const struct signal_catchpoint *c\n     = (const struct signal_catchpoint *) bl->owner;\n   gdb_signal signal_number;\n \n-  if (ws->kind () != TARGET_WAITKIND_STOPPED)\n+  if (ws.kind () != TARGET_WAITKIND_STOPPED)\n     return 0;\n \n-  signal_number = ws->sig ();\n+  signal_number = ws.sig ();\n \n   /* If we are catching specific signals in this breakpoint, then we\n      must guarantee that the called signal is the same signal we are"
    },
    {
      "sha": "02123736ff4de362265d9401e182edf32e293720",
      "filename": "gdb/break-catch-syscall.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/break-catch-syscall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/break-catch-syscall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-syscall.c?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -143,7 +143,7 @@ remove_catch_syscall (struct bp_location *bl, enum remove_bp_reason reason)\n static int\n breakpoint_hit_catch_syscall (const struct bp_location *bl,\n \t\t\t      const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t      const struct target_waitstatus *ws)\n+\t\t\t      const target_waitstatus &ws)\n {\n   /* We must check if we are catching specific syscalls in this\n      breakpoint.  If we are, then we must guarantee that the called\n@@ -152,11 +152,11 @@ breakpoint_hit_catch_syscall (const struct bp_location *bl,\n   const struct syscall_catchpoint *c\n     = (const struct syscall_catchpoint *) bl->owner;\n \n-  if (ws->kind () != TARGET_WAITKIND_SYSCALL_ENTRY\n-      && ws->kind () != TARGET_WAITKIND_SYSCALL_RETURN)\n+  if (ws.kind () != TARGET_WAITKIND_SYSCALL_ENTRY\n+      && ws.kind () != TARGET_WAITKIND_SYSCALL_RETURN)\n     return 0;\n \n-  syscall_number = ws->syscall_number ();\n+  syscall_number = ws.syscall_number ();\n \n   /* Now, checking if the syscall is the same.  */\n   if (!c->syscalls_to_be_caught.empty ())"
    },
    {
      "sha": "b1eae3af634f8208d47f2bd4da944aa98fe9341f",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -4771,7 +4771,7 @@ bpstat::bpstat ()\n    watchpoints have triggered, according to the target.  */\n \n int\n-watchpoints_triggered (struct target_waitstatus *ws)\n+watchpoints_triggered (const target_waitstatus &ws)\n {\n   bool stopped_by_watchpoint = target_stopped_by_watchpoint ();\n   CORE_ADDR addr;\n@@ -5014,7 +5014,7 @@ watchpoint_check (bpstat *bs)\n static int\n bpstat_check_location (const struct bp_location *bl,\n \t\t       const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t       const struct target_waitstatus *ws)\n+\t\t       const target_waitstatus &ws)\n {\n   struct breakpoint *b = bl->owner;\n \n@@ -5349,7 +5349,7 @@ need_moribund_for_location_type (struct bp_location *loc)\n \n bpstat *\n build_bpstat_chain (const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t    const struct target_waitstatus *ws)\n+\t\t    const target_waitstatus &ws)\n {\n   bpstat *bs_head = nullptr, **bs_link = &bs_head;\n \n@@ -5425,7 +5425,7 @@ build_bpstat_chain (const address_space *aspace, CORE_ADDR bp_addr,\n bpstat *\n bpstat_stop_status (const address_space *aspace,\n \t\t    CORE_ADDR bp_addr, thread_info *thread,\n-\t\t    const struct target_waitstatus *ws,\n+\t\t    const target_waitstatus &ws,\n \t\t    bpstat *stop_chain)\n {\n   struct breakpoint *b = NULL;\n@@ -7760,14 +7760,14 @@ remove_catch_fork (struct bp_location *bl, enum remove_bp_reason reason)\n static int\n breakpoint_hit_catch_fork (const struct bp_location *bl,\n \t\t\t   const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t   const struct target_waitstatus *ws)\n+\t\t\t   const target_waitstatus &ws)\n {\n   struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n \n-  if (ws->kind () != TARGET_WAITKIND_FORKED)\n+  if (ws.kind () != TARGET_WAITKIND_FORKED)\n     return 0;\n \n-  c->forked_inferior_pid = ws->child_ptid ();\n+  c->forked_inferior_pid = ws.child_ptid ();\n   return 1;\n }\n \n@@ -7876,14 +7876,14 @@ remove_catch_vfork (struct bp_location *bl, enum remove_bp_reason reason)\n static int\n breakpoint_hit_catch_vfork (const struct bp_location *bl,\n \t\t\t    const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t    const struct target_waitstatus *ws)\n+\t\t\t    const target_waitstatus &ws)\n {\n   struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n \n-  if (ws->kind () != TARGET_WAITKIND_VFORKED)\n+  if (ws.kind () != TARGET_WAITKIND_VFORKED)\n     return 0;\n \n-  c->forked_inferior_pid = ws->child_ptid ();\n+  c->forked_inferior_pid = ws.child_ptid ();\n   return 1;\n }\n \n@@ -7998,11 +7998,11 @@ static int\n breakpoint_hit_catch_solib (const struct bp_location *bl,\n \t\t\t    const address_space *aspace,\n \t\t\t    CORE_ADDR bp_addr,\n-\t\t\t    const struct target_waitstatus *ws)\n+\t\t\t    const target_waitstatus &ws)\n {\n   struct solib_catchpoint *self = (struct solib_catchpoint *) bl->owner;\n \n-  if (ws->kind () == TARGET_WAITKIND_LOADED)\n+  if (ws.kind () == TARGET_WAITKIND_LOADED)\n     return 1;\n \n   for (breakpoint *other : all_breakpoints ())\n@@ -8274,14 +8274,14 @@ remove_catch_exec (struct bp_location *bl, enum remove_bp_reason reason)\n static int\n breakpoint_hit_catch_exec (const struct bp_location *bl,\n \t\t\t   const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t   const struct target_waitstatus *ws)\n+\t\t\t   const target_waitstatus &ws)\n {\n   struct exec_catchpoint *c = (struct exec_catchpoint *) bl->owner;\n \n-  if (ws->kind () != TARGET_WAITKIND_EXECD)\n+  if (ws.kind () != TARGET_WAITKIND_EXECD)\n     return 0;\n \n-  c->exec_pathname = make_unique_xstrdup (ws->execd_pathname ());\n+  c->exec_pathname = make_unique_xstrdup (ws.execd_pathname ());\n   return 1;\n }\n \n@@ -9781,10 +9781,10 @@ static int\n breakpoint_hit_ranged_breakpoint (const struct bp_location *bl,\n \t\t\t\t  const address_space *aspace,\n \t\t\t\t  CORE_ADDR bp_addr,\n-\t\t\t\t  const struct target_waitstatus *ws)\n+\t\t\t\t  const target_waitstatus &ws)\n {\n-  if (ws->kind () != TARGET_WAITKIND_STOPPED\n-      || ws->sig () != GDB_SIGNAL_TRAP)\n+  if (ws.kind () != TARGET_WAITKIND_STOPPED\n+      || ws.sig () != GDB_SIGNAL_TRAP)\n     return 0;\n \n   return breakpoint_address_match_range (bl->pspace->aspace, bl->address,\n@@ -10125,7 +10125,7 @@ remove_watchpoint (struct bp_location *bl, enum remove_bp_reason reason)\n static int\n breakpoint_hit_watchpoint (const struct bp_location *bl,\n \t\t\t   const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t   const struct target_waitstatus *ws)\n+\t\t\t   const target_waitstatus &ws)\n {\n   struct breakpoint *b = bl->owner;\n   struct watchpoint *w = (struct watchpoint *) b;\n@@ -12280,7 +12280,7 @@ static int\n base_breakpoint_breakpoint_hit (const struct bp_location *bl,\n \t\t\t\tconst address_space *aspace,\n \t\t\t\tCORE_ADDR bp_addr,\n-\t\t\t\tconst struct target_waitstatus *ws)\n+\t\t\t\tconst target_waitstatus &ws)\n {\n   internal_error_pure_virtual_called ();\n }\n@@ -12447,10 +12447,10 @@ bkpt_remove_location (struct bp_location *bl, enum remove_bp_reason reason)\n static int\n bkpt_breakpoint_hit (const struct bp_location *bl,\n \t\t     const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t     const struct target_waitstatus *ws)\n+\t\t     const target_waitstatus &ws)\n {\n-  if (ws->kind () != TARGET_WAITKIND_STOPPED\n-      || ws->sig () != GDB_SIGNAL_TRAP)\n+  if (ws.kind () != TARGET_WAITKIND_STOPPED\n+      || ws.sig () != GDB_SIGNAL_TRAP)\n     return 0;\n \n   if (!breakpoint_address_match (bl->pspace->aspace, bl->address,\n@@ -12468,7 +12468,7 @@ bkpt_breakpoint_hit (const struct bp_location *bl,\n static int\n dprintf_breakpoint_hit (const struct bp_location *bl,\n \t\t\tconst address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\tconst struct target_waitstatus *ws)\n+\t\t\tconst target_waitstatus &ws)\n {\n   if (dprintf_style == dprintf_style_agent\n       && target_can_run_breakpoint_commands ())\n@@ -12822,7 +12822,7 @@ tracepoint_re_set (struct breakpoint *b)\n static int\n tracepoint_breakpoint_hit (const struct bp_location *bl,\n \t\t\t   const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t   const struct target_waitstatus *ws)\n+\t\t\t   const target_waitstatus &ws)\n {\n   /* By definition, the inferior does not report stops at\n      tracepoints.  */\n@@ -15194,7 +15194,7 @@ is_non_inline_function (struct breakpoint *b)\n \n int\n pc_at_non_inline_function (const address_space *aspace, CORE_ADDR pc,\n-\t\t\t   const struct target_waitstatus *ws)\n+\t\t\t   const target_waitstatus &ws)\n {\n   for (breakpoint *b : all_breakpoints ())\n     {"
    },
    {
      "sha": "1704d6a3fd75227e095ed65c0485320923a38698",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -587,7 +587,7 @@ struct breakpoint_ops\n   int (*breakpoint_hit) (const struct bp_location *bl,\n \t\t\t const address_space *aspace,\n \t\t\t CORE_ADDR bp_addr,\n-\t\t\t const struct target_waitstatus *ws);\n+\t\t\t const target_waitstatus &ws);\n \n   /* Check internal conditions of the breakpoint referred to by BS.\n      If we should not stop for this breakpoint, set BS->stop to 0.  */\n@@ -948,7 +948,7 @@ extern bpstat *bpstat_copy (bpstat *);\n \n extern bpstat *build_bpstat_chain (const address_space *aspace,\n \t\t\t\t  CORE_ADDR bp_addr,\n-\t\t\t\t  const struct target_waitstatus *ws);\n+\t\t\t\t  const target_waitstatus &ws);\n \n /* Get a bpstat associated with having just stopped at address\n    BP_ADDR in thread PTID.  STOP_CHAIN may be supplied as a previously\n@@ -972,7 +972,7 @@ extern bpstat *build_bpstat_chain (const address_space *aspace,\n \n extern bpstat *bpstat_stop_status (const address_space *aspace,\n \t\t\t\t  CORE_ADDR pc, thread_info *thread,\n-\t\t\t\t  const struct target_waitstatus *ws,\n+\t\t\t\t  const target_waitstatus &ws,\n \t\t\t\t  bpstat *stop_chain = nullptr);\n \f\n /* This bpstat_what stuff tells wait_for_inferior what to do with a\n@@ -1609,7 +1609,7 @@ extern int insert_single_step_breakpoints (struct gdbarch *);\n \n /* Check if any hardware watchpoints have triggered, according to the\n    target.  */\n-int watchpoints_triggered (struct target_waitstatus *);\n+int watchpoints_triggered (const target_waitstatus &);\n \n /* Helper for transparent breakpoint hiding for memory read and write\n    routines.\n@@ -1745,7 +1745,7 @@ const std::vector<bp_location *> &all_bp_locations ();\n \n extern int pc_at_non_inline_function (const address_space *aspace,\n \t\t\t\t      CORE_ADDR pc,\n-\t\t\t\t      const struct target_waitstatus *ws);\n+\t\t\t\t      const target_waitstatus &ws);\n \n extern int user_breakpoint_p (struct breakpoint *);\n "
    },
    {
      "sha": "e4739ed14f665d43b78ffdece9fa086ab731cf95",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 31,
      "deletions": 31,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -3470,15 +3470,15 @@ delete_just_stopped_threads_single_step_breakpoints (void)\n \n void\n print_target_wait_results (ptid_t waiton_ptid, ptid_t result_ptid,\n-\t\t\t   const struct target_waitstatus *ws)\n+\t\t\t   const struct target_waitstatus &ws)\n {\n   infrun_debug_printf (\"target_wait (%s [%s], status) =\",\n \t\t       waiton_ptid.to_string ().c_str (),\n \t\t       target_pid_to_str (waiton_ptid).c_str ());\n   infrun_debug_printf (\"  %s [%s],\",\n \t\t       result_ptid.to_string ().c_str (),\n \t\t       target_pid_to_str (result_ptid).c_str ());\n-  infrun_debug_printf (\"  %s\", ws->to_string ().c_str ());\n+  infrun_debug_printf (\"  %s\", ws.to_string ().c_str ());\n }\n \n /* Select a thread at random, out of those which are resumed and have\n@@ -3833,7 +3833,7 @@ prepare_for_detach (void)\n \t  event.ptid = do_target_wait_1 (inf, pid_ptid, &event.ws, 0);\n \n \t  if (debug_infrun)\n-\t    print_target_wait_results (pid_ptid, event.ptid, &event.ws);\n+\t    print_target_wait_results (pid_ptid, event.ptid, event.ws);\n \n \t  handle_one (event);\n \t}\n@@ -3880,7 +3880,7 @@ wait_for_inferior (inferior *inf)\n       ecs->target = inf->process_target ();\n \n       if (debug_infrun)\n-\tprint_target_wait_results (minus_one_ptid, ecs->ptid, &ecs->ws);\n+\tprint_target_wait_results (minus_one_ptid, ecs->ptid, ecs->ws);\n \n       /* Now figure out what to do with the result of the result.  */\n       handle_inferior_event (ecs);\n@@ -4070,7 +4070,7 @@ fetch_inferior_event ()\n     switch_to_target_no_thread (ecs->target);\n \n     if (debug_infrun)\n-      print_target_wait_results (minus_one_ptid, ecs->ptid, &ecs->ws);\n+      print_target_wait_results (minus_one_ptid, ecs->ptid, ecs->ws);\n \n     /* If an error happens while handling the event, propagate GDB's\n        knowledge of the executing state to the frontend/user running\n@@ -4257,7 +4257,7 @@ context_switch (execution_control_state *ecs)\n \n static void\n adjust_pc_after_break (struct thread_info *thread,\n-\t\t       const target_waitstatus *ws)\n+\t\t       const target_waitstatus &ws)\n {\n   struct regcache *regcache;\n   struct gdbarch *gdbarch;\n@@ -4284,10 +4284,10 @@ adjust_pc_after_break (struct thread_info *thread,\n      target with both of these set in GDB history, and it seems unlikely to be\n      correct, so gdbarch_have_nonsteppable_watchpoint is not checked here.  */\n \n-  if (ws->kind () != TARGET_WAITKIND_STOPPED)\n+  if (ws.kind () != TARGET_WAITKIND_STOPPED)\n     return;\n \n-  if (ws->sig () != GDB_SIGNAL_TRAP)\n+  if (ws.sig () != GDB_SIGNAL_TRAP)\n     return;\n \n   /* In reverse execution, when a breakpoint is hit, the instruction\n@@ -4494,7 +4494,7 @@ handle_syscall_event (struct execution_control_state *ecs)\n       ecs->event_thread->control.stop_bpstat\n \t= bpstat_stop_status (regcache->aspace (),\n \t\t\t      ecs->event_thread->stop_pc (),\n-\t\t\t      ecs->event_thread, &ecs->ws);\n+\t\t\t      ecs->event_thread, ecs->ws);\n \n       if (handle_stop_requested (ecs))\n \treturn false;\n@@ -4593,7 +4593,7 @@ poll_one_curr_target (struct target_waitstatus *ws)\n     event_ptid = target_wait (minus_one_ptid, ws, TARGET_WNOHANG);\n \n   if (debug_infrun)\n-    print_target_wait_results (minus_one_ptid, event_ptid, ws);\n+    print_target_wait_results (minus_one_ptid, event_ptid, *ws);\n \n   return event_ptid;\n }\n@@ -4674,23 +4674,23 @@ wait_one ()\n /* Save the thread's event and stop reason to process it later.  */\n \n static void\n-save_waitstatus (struct thread_info *tp, const target_waitstatus *ws)\n+save_waitstatus (struct thread_info *tp, const target_waitstatus &ws)\n {\n   infrun_debug_printf (\"saving status %s for %s\",\n-\t\t       ws->to_string ().c_str (),\n+\t\t       ws.to_string ().c_str (),\n \t\t       tp->ptid.to_string ().c_str ());\n \n   /* Record for later.  */\n-  tp->set_pending_waitstatus (*ws);\n+  tp->set_pending_waitstatus (ws);\n \n-  if (ws->kind () == TARGET_WAITKIND_STOPPED\n-      && ws->sig () == GDB_SIGNAL_TRAP)\n+  if (ws.kind () == TARGET_WAITKIND_STOPPED\n+      && ws.sig () == GDB_SIGNAL_TRAP)\n     {\n       struct regcache *regcache = get_thread_regcache (tp);\n       const address_space *aspace = regcache->aspace ();\n       CORE_ADDR pc = regcache_read_pc (regcache);\n \n-      adjust_pc_after_break (tp, &tp->pending_waitstatus ());\n+      adjust_pc_after_break (tp, tp->pending_waitstatus ());\n \n       scoped_restore_current_thread restore_thread;\n       switch_to_thread (tp);\n@@ -4824,7 +4824,7 @@ handle_one (const wait_one_event &event)\n \t  switch_to_thread_no_regs (t);\n \t  mark_non_executing_threads (event.target, event.ptid,\n \t\t\t\t      event.ws);\n-\t  save_waitstatus (t, &event.ws);\n+\t  save_waitstatus (t, event.ws);\n \t  t->stop_requested = false;\n \t}\n     }\n@@ -4878,7 +4878,7 @@ handle_one (const wait_one_event &event)\n \t     t->ptid.to_string ().c_str ());\n \n \t  /* Record for later.  */\n-\t  save_waitstatus (t, &event.ws);\n+\t  save_waitstatus (t, event.ws);\n \n \t  sig = (event.ws.kind () == TARGET_WAITKIND_STOPPED\n \t\t ? event.ws.sig () : GDB_SIGNAL_0);\n@@ -5236,7 +5236,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n     }\n \n   /* Dependent on valid ECS->EVENT_THREAD.  */\n-  adjust_pc_after_break (ecs->event_thread, &ecs->ws);\n+  adjust_pc_after_break (ecs->event_thread, ecs->ws);\n \n   /* Dependent on the current PC value modified by adjust_pc_after_break.  */\n   reinit_frame_cache ();\n@@ -5295,7 +5295,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t    ecs->event_thread->control.stop_bpstat\n \t      = bpstat_stop_status (regcache->aspace (),\n \t\t\t\t    ecs->event_thread->stop_pc (),\n-\t\t\t\t    ecs->event_thread, &ecs->ws);\n+\t\t\t\t    ecs->event_thread, ecs->ws);\n \n \t    if (handle_stop_requested (ecs))\n \t      return;\n@@ -5538,7 +5538,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n       ecs->event_thread->control.stop_bpstat\n \t= bpstat_stop_status (get_current_regcache ()->aspace (),\n \t\t\t      ecs->event_thread->stop_pc (),\n-\t\t\t      ecs->event_thread, &ecs->ws);\n+\t\t\t      ecs->event_thread, ecs->ws);\n \n       if (handle_stop_requested (ecs))\n \treturn;\n@@ -5649,7 +5649,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n       ecs->event_thread->control.stop_bpstat\n \t= bpstat_stop_status (get_current_regcache ()->aspace (),\n \t\t\t      ecs->event_thread->stop_pc (),\n-\t\t\t      ecs->event_thread, &ecs->ws);\n+\t\t\t      ecs->event_thread, ecs->ws);\n \n       if (handle_stop_requested (ecs))\n \treturn;\n@@ -5886,7 +5886,7 @@ finish_step_over (struct execution_control_state *ecs)\n \t  gdb_assert (pending != tp);\n \n \t  /* Record the event thread's event for later.  */\n-\t  save_waitstatus (tp, &ecs->ws);\n+\t  save_waitstatus (tp, ecs->ws);\n \t  /* This was cleared early, by handle_inferior_event.  Set it\n \t     so this pending event is considered by\n \t     do_target_wait.  */\n@@ -6061,7 +6061,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n       && ecs->event_thread->stepping_over_watchpoint)\n     stopped_by_watchpoint = 0;\n   else\n-    stopped_by_watchpoint = watchpoints_triggered (&ecs->ws);\n+    stopped_by_watchpoint = watchpoints_triggered (ecs->ws);\n \n   /* If necessary, step over this watchpoint.  We'll be back to display\n      it in a moment.  */\n@@ -6134,16 +6134,16 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t that's an extremely unlikely scenario.  */\n       if (!pc_at_non_inline_function (aspace,\n \t\t\t\t      ecs->event_thread->stop_pc (),\n-\t\t\t\t      &ecs->ws)\n+\t\t\t\t      ecs->ws)\n \t  && !(ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP\n \t       && ecs->event_thread->control.trap_expected\n \t       && pc_at_non_inline_function (aspace,\n \t\t\t\t\t     ecs->event_thread->prev_pc,\n-\t\t\t\t\t     &ecs->ws)))\n+\t\t\t\t\t     ecs->ws)))\n \t{\n \t  stop_chain = build_bpstat_chain (aspace,\n \t\t\t\t\t   ecs->event_thread->stop_pc (),\n-\t\t\t\t\t   &ecs->ws);\n+\t\t\t\t\t   ecs->ws);\n \t  skip_inline_frames (ecs->event_thread, stop_chain);\n \n \t  /* Re-fetch current thread's frame in case that invalidated\n@@ -6195,7 +6195,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n   ecs->event_thread->control.stop_bpstat\n     = bpstat_stop_status (get_current_regcache ()->aspace (),\n \t\t\t  ecs->event_thread->stop_pc (),\n-\t\t\t  ecs->event_thread, &ecs->ws, stop_chain);\n+\t\t\t  ecs->event_thread, ecs->ws, stop_chain);\n \n   /* Following in case break condition called a\n      function.  */\n@@ -8258,14 +8258,14 @@ print_no_history_reason (struct ui_out *uiout)\n    based on the event(s) that just occurred.  */\n \n static void\n-print_stop_location (struct target_waitstatus *ws)\n+print_stop_location (const target_waitstatus &ws)\n {\n   int bpstat_ret;\n   enum print_what source_flag;\n   int do_frame_printing = 1;\n   struct thread_info *tp = inferior_thread ();\n \n-  bpstat_ret = bpstat_print (tp->control.stop_bpstat, ws->kind ());\n+  bpstat_ret = bpstat_print (tp->control.stop_bpstat, ws.kind ());\n   switch (bpstat_ret)\n     {\n     case PRINT_UNKNOWN:\n@@ -8325,7 +8325,7 @@ print_stop_event (struct ui_out *uiout, bool displays)\n   {\n     scoped_restore save_uiout = make_scoped_restore (&current_uiout, uiout);\n \n-    print_stop_location (&last);\n+    print_stop_location (last);\n \n     /* Display the auto-display expressions.  */\n     if (displays)"
    },
    {
      "sha": "644e57f0bca7865613a9117d13ddd66be83f6ef9",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -209,7 +209,7 @@ extern void print_stop_event (struct ui_out *uiout, bool displays = true);\n /* Pretty print the results of target_wait, for debugging purposes.  */\n \n extern void print_target_wait_results (ptid_t waiton_ptid, ptid_t result_ptid,\n-\t\t\t\t       const struct target_waitstatus *ws);\n+\t\t\t\t       const struct target_waitstatus &ws);\n \n extern int signal_stop_state (int);\n "
    },
    {
      "sha": "724386e09164298f3f99f8f366f0ab05593ad473",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -762,7 +762,7 @@ class remote_target : public process_stratum_target\n \t\t\t     target_waitstatus *status);\n \n   ptid_t select_thread_for_ambiguous_stop_reply\n-    (const struct target_waitstatus *status);\n+    (const struct target_waitstatus &status);\n \n   void remote_notice_new_inferior (ptid_t currthread, bool executing);\n \n@@ -4542,7 +4542,7 @@ remote_target::process_initial_stop_replies (int from_tty)\n \n       event_ptid = target_wait (waiton_ptid, &ws, TARGET_WNOHANG);\n       if (remote_debug)\n-\tprint_target_wait_results (waiton_ptid, event_ptid, &ws);\n+\tprint_target_wait_results (waiton_ptid, event_ptid, ws);\n \n       switch (ws.kind ())\n \t{\n@@ -7224,11 +7224,11 @@ struct notif_client notif_client_stop =\n    -1 if we want to check all threads.  */\n \n static int\n-is_pending_fork_parent (const target_waitstatus *ws, int event_pid,\n+is_pending_fork_parent (const target_waitstatus &ws, int event_pid,\n \t\t\tptid_t thread_ptid)\n {\n-  if (ws->kind () == TARGET_WAITKIND_FORKED\n-      || ws->kind () == TARGET_WAITKIND_VFORKED)\n+  if (ws.kind () == TARGET_WAITKIND_FORKED\n+      || ws.kind () == TARGET_WAITKIND_VFORKED)\n     {\n       if (event_pid == -1 || event_pid == thread_ptid.pid ())\n \treturn 1;\n@@ -7240,21 +7240,21 @@ is_pending_fork_parent (const target_waitstatus *ws, int event_pid,\n /* Return the thread's pending status used to determine whether the\n    thread is a fork parent stopped at a fork event.  */\n \n-static const target_waitstatus *\n+static const target_waitstatus &\n thread_pending_fork_status (struct thread_info *thread)\n {\n   if (thread->has_pending_waitstatus ())\n-    return &thread->pending_waitstatus ();\n+    return thread->pending_waitstatus ();\n   else\n-    return &thread->pending_follow;\n+    return thread->pending_follow;\n }\n \n /* Determine if THREAD is a pending fork parent thread.  */\n \n static int\n is_pending_fork_parent_thread (struct thread_info *thread)\n {\n-  const target_waitstatus *ws = thread_pending_fork_status (thread);\n+  const target_waitstatus &ws = thread_pending_fork_status (thread);\n   int pid = -1;\n \n   return is_pending_fork_parent (ws, pid, thread->ptid);\n@@ -7276,10 +7276,10 @@ remote_target::remove_new_fork_children (threads_listing_context *context)\n      fork child threads from the CONTEXT list.  */\n   for (thread_info *thread : all_non_exited_threads (this))\n     {\n-      const target_waitstatus *ws = thread_pending_fork_status (thread);\n+      const target_waitstatus &ws = thread_pending_fork_status (thread);\n \n       if (is_pending_fork_parent (ws, pid, thread->ptid))\n-\tcontext->remove_thread (ws->child_ptid ());\n+\tcontext->remove_thread (ws.child_ptid ());\n     }\n \n   /* Check for any pending fork events (not reported or processed yet)\n@@ -7940,15 +7940,15 @@ remote_notif_get_pending_events (remote_target *remote, notif_client *nc)\n \n ptid_t\n remote_target::select_thread_for_ambiguous_stop_reply\n-  (const struct target_waitstatus *status)\n+  (const target_waitstatus &status)\n {\n   REMOTE_SCOPED_DEBUG_ENTER_EXIT;\n \n   /* Some stop events apply to all threads in an inferior, while others\n      only apply to a single thread.  */\n   bool process_wide_stop\n-    = (status->kind () == TARGET_WAITKIND_EXITED\n-       || status->kind () == TARGET_WAITKIND_SIGNALLED);\n+    = (status.kind () == TARGET_WAITKIND_EXITED\n+       || status.kind () == TARGET_WAITKIND_SIGNALLED);\n \n   remote_debug_printf (\"process_wide_stop = %d\", process_wide_stop);\n \n@@ -8030,7 +8030,7 @@ remote_target::process_stop_reply (struct stop_reply *stop_reply,\n   /* If no thread/process was reported by the stub then select a suitable\n      thread/process.  */\n   if (ptid == null_ptid)\n-    ptid = select_thread_for_ambiguous_stop_reply (status);\n+    ptid = select_thread_for_ambiguous_stop_reply (*status);\n   gdb_assert (ptid != null_ptid);\n \n   if (status->kind () != TARGET_WAITKIND_EXITED\n@@ -10056,11 +10056,11 @@ remote_target::kill_new_fork_children (int pid)\n      that are stopped at a fork event.  */\n   for (thread_info *thread : all_non_exited_threads (this))\n     {\n-      struct target_waitstatus *ws = &thread->pending_follow;\n+      const target_waitstatus &ws = thread->pending_follow;\n \n       if (is_pending_fork_parent (ws, pid, thread->ptid))\n \t{\n-\t  int child_pid = ws->child_ptid ().pid ();\n+\t  int child_pid = ws.child_ptid ().pid ();\n \t  int res;\n \n \t  res = remote_vkill (child_pid);\n@@ -10073,7 +10073,7 @@ remote_target::kill_new_fork_children (int pid)\n      in process PID and kill those fork child threads as well.  */\n   remote_notif_get_pending_events (notif);\n   for (auto &event : rs->stop_reply_queue)\n-    if (is_pending_fork_parent (&event->ws, pid, event->ptid))\n+    if (is_pending_fork_parent (event->ws, pid, event->ptid))\n       {\n \tint child_pid = event->ws.child_ptid ().pid ();\n \tint res;"
    },
    {
      "sha": "8202365350a29b986780ae19a16aaa5440772a52",
      "filename": "gdbserver/remote-utils.cc",
      "status": "modified",
      "additions": 22,
      "deletions": 23,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdbserver/remote-utils.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdbserver/remote-utils.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.cc?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -1081,15 +1081,14 @@ outreg (struct regcache *regcache, int regno, char *buf)\n }\n \n void\n-prepare_resume_reply (char *buf, ptid_t ptid,\n-\t\t      struct target_waitstatus *status)\n+prepare_resume_reply (char *buf, ptid_t ptid, const target_waitstatus &status)\n {\n   client_state &cs = get_client_state ();\n   if (debug_threads)\n     debug_printf (\"Writing resume reply for %s:%d\\n\",\n-\t\t  target_pid_to_str (ptid).c_str (), status->kind ());\n+\t\t  target_pid_to_str (ptid).c_str (), status.kind ());\n \n-  switch (status->kind ())\n+  switch (status.kind ())\n     {\n     case TARGET_WAITKIND_STOPPED:\n     case TARGET_WAITKIND_FORKED:\n@@ -1104,27 +1103,27 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n \tconst char **regp;\n \tstruct regcache *regcache;\n \n-\tif ((status->kind () == TARGET_WAITKIND_FORKED && cs.report_fork_events)\n-\t    || (status->kind () == TARGET_WAITKIND_VFORKED\n+\tif ((status.kind () == TARGET_WAITKIND_FORKED && cs.report_fork_events)\n+\t    || (status.kind () == TARGET_WAITKIND_VFORKED\n \t\t&& cs.report_vfork_events))\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n-\t    const char *event = (status->kind () == TARGET_WAITKIND_FORKED\n+\t    const char *event = (status.kind () == TARGET_WAITKIND_FORKED\n \t\t\t\t ? \"fork\" : \"vfork\");\n \n \t    sprintf (buf, \"T%02x%s:\", signal, event);\n \t    buf += strlen (buf);\n-\t    buf = write_ptid (buf, status->child_ptid ());\n+\t    buf = write_ptid (buf, status.child_ptid ());\n \t    strcat (buf, \";\");\n \t  }\n-\telse if (status->kind () == TARGET_WAITKIND_VFORK_DONE\n+\telse if (status.kind () == TARGET_WAITKIND_VFORK_DONE\n \t\t && cs.report_vfork_events)\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n \n \t    sprintf (buf, \"T%02xvforkdone:;\", signal);\n \t  }\n-\telse if (status->kind () == TARGET_WAITKIND_EXECD && cs.report_exec_events)\n+\telse if (status.kind () == TARGET_WAITKIND_EXECD && cs.report_exec_events)\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n \t    const char *event = \"exec\";\n@@ -1134,32 +1133,32 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n \t    buf += strlen (buf);\n \n \t    /* Encode pathname to hexified format.  */\n-\t    bin2hex ((const gdb_byte *) status->execd_pathname (),\n+\t    bin2hex ((const gdb_byte *) status.execd_pathname (),\n \t\t     hexified_pathname,\n-\t\t     strlen (status->execd_pathname ()));\n+\t\t     strlen (status.execd_pathname ()));\n \n \t    sprintf (buf, \"%s;\", hexified_pathname);\n \t    buf += strlen (buf);\n \t  }\n-\telse if (status->kind () == TARGET_WAITKIND_THREAD_CREATED\n+\telse if (status.kind () == TARGET_WAITKIND_THREAD_CREATED\n \t\t && cs.report_thread_events)\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n \n \t    sprintf (buf, \"T%02xcreate:;\", signal);\n \t  }\n-\telse if (status->kind () == TARGET_WAITKIND_SYSCALL_ENTRY\n-\t\t || status->kind () == TARGET_WAITKIND_SYSCALL_RETURN)\n+\telse if (status.kind () == TARGET_WAITKIND_SYSCALL_ENTRY\n+\t\t || status.kind () == TARGET_WAITKIND_SYSCALL_RETURN)\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n-\t    const char *event = (status->kind () == TARGET_WAITKIND_SYSCALL_ENTRY\n+\t    const char *event = (status.kind () == TARGET_WAITKIND_SYSCALL_ENTRY\n \t\t\t\t ? \"syscall_entry\" : \"syscall_return\");\n \n \t    sprintf (buf, \"T%02x%s:%x;\", signal, event,\n-\t\t     status->syscall_number ());\n+\t\t     status.syscall_number ());\n \t  }\n \telse\n-\t  sprintf (buf, \"T%02x\", status->sig ());\n+\t  sprintf (buf, \"T%02x\", status.sig ());\n \n \tif (disable_packet_T)\n \t  {\n@@ -1281,19 +1280,19 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n     case TARGET_WAITKIND_EXITED:\n       if (cs.multi_process)\n \tsprintf (buf, \"W%x;process:%x\",\n-\t\t status->exit_status (), ptid.pid ());\n+\t\t status.exit_status (), ptid.pid ());\n       else\n-\tsprintf (buf, \"W%02x\", status->exit_status ());\n+\tsprintf (buf, \"W%02x\", status.exit_status ());\n       break;\n     case TARGET_WAITKIND_SIGNALLED:\n       if (cs.multi_process)\n \tsprintf (buf, \"X%x;process:%x\",\n-\t\t status->sig (), ptid.pid ());\n+\t\t status.sig (), ptid.pid ());\n       else\n-\tsprintf (buf, \"X%02x\", status->sig ());\n+\tsprintf (buf, \"X%02x\", status.sig ());\n       break;\n     case TARGET_WAITKIND_THREAD_EXITED:\n-      sprintf (buf, \"w%x;\", status->exit_status ());\n+      sprintf (buf, \"w%x;\", status.exit_status ());\n       buf += strlen (buf);\n       buf = write_ptid (buf, ptid);\n       break;"
    },
    {
      "sha": "b856862d367d8c94a3a7300a39e3c02aba00845c",
      "filename": "gdbserver/remote-utils.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdbserver/remote-utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdbserver/remote-utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.h?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -41,7 +41,7 @@ void enable_async_io (void);\n void disable_async_io (void);\n void check_remote_input_interrupt_request (void);\n void prepare_resume_reply (char *buf, ptid_t ptid,\n-\t\t\t   struct target_waitstatus *status);\n+\t\t\t   const target_waitstatus &status);\n \n const char *decode_address_to_semicolon (CORE_ADDR *addrp, const char *start);\n void decode_address (CORE_ADDR *addrp, const char *start, int len);"
    },
    {
      "sha": "b1d4c92b3d97062af1ea3ed05d498a1770fcc0c4",
      "filename": "gdbserver/server.cc",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdbserver/server.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c272a98cbf596ddf1a70a41801c6e86d9564d152/gdbserver/server.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.cc?ref=c272a98cbf596ddf1a70a41801c6e86d9564d152",
      "patch": "@@ -173,12 +173,12 @@ get_client_state ()\n /* Put a stop reply to the stop reply queue.  */\n \n static void\n-queue_stop_reply (ptid_t ptid, struct target_waitstatus *status)\n+queue_stop_reply (ptid_t ptid, const target_waitstatus &status)\n {\n   struct vstop_notif *new_notif = new struct vstop_notif;\n \n   new_notif->ptid = ptid;\n-  new_notif->status = *status;\n+  new_notif->status = status;\n \n   notif_event_enque (&notif_stop, new_notif);\n }\n@@ -225,7 +225,7 @@ vstop_notif_reply (struct notif_event *event, char *own_buf)\n {\n   struct vstop_notif *vstop = (struct vstop_notif *) event;\n \n-  prepare_resume_reply (own_buf, vstop->ptid, &vstop->status);\n+  prepare_resume_reply (own_buf, vstop->ptid, vstop->status);\n }\n \n /* Helper for in_queued_stop_replies.  */\n@@ -2795,7 +2795,7 @@ handle_pending_status (const struct thread_resume *resumption,\n \n       cs.last_status = thread->last_status;\n       cs.last_ptid = thread->id;\n-      prepare_resume_reply (cs.own_buf, cs.last_ptid, &cs.last_status);\n+      prepare_resume_reply (cs.own_buf, cs.last_ptid, cs.last_status);\n       return 1;\n     }\n   return 0;\n@@ -2963,7 +2963,7 @@ resume (struct thread_resume *actions, size_t num_actions)\n \t so by now).  Tag all threads as \"want-stopped\", so we don't\n \t resume them implicitly without the client telling us to.  */\n       gdb_wants_all_threads_stopped ();\n-      prepare_resume_reply (cs.own_buf, cs.last_ptid, &cs.last_status);\n+      prepare_resume_reply (cs.own_buf, cs.last_ptid, cs.last_status);\n       disable_async_io ();\n \n       if (cs.last_status.kind () == TARGET_WAITKIND_EXITED\n@@ -2996,7 +2996,7 @@ handle_v_attach (char *own_buf)\n \t  write_ok (own_buf);\n \t}\n       else\n-\tprepare_resume_reply (own_buf, cs.last_ptid, &cs.last_status);\n+\tprepare_resume_reply (own_buf, cs.last_ptid, cs.last_status);\n     }\n   else\n     write_enn (own_buf);\n@@ -3114,7 +3114,7 @@ handle_v_run (char *own_buf)\n \n   if (cs.last_status.kind () == TARGET_WAITKIND_STOPPED)\n     {\n-      prepare_resume_reply (own_buf, cs.last_ptid, &cs.last_status);\n+      prepare_resume_reply (own_buf, cs.last_ptid, cs.last_status);\n \n       /* In non-stop, sending a resume reply doesn't set the general\n \t thread, but GDB assumes a vRun sets it (this is so GDB can\n@@ -3313,7 +3313,7 @@ queue_stop_reply_callback (thread_info *thread)\n \n \t  /* Pass the last stop reply back to GDB, but don't notify\n \t     yet.  */\n-\t  queue_stop_reply (thread->id, &thread->last_status);\n+\t  queue_stop_reply (thread->id, thread->last_status);\n \t}\n     }\n }\n@@ -3436,7 +3436,7 @@ handle_status (char *own_buf)\n \t  set_desired_thread ();\n \n \t  gdb_assert (tp->last_status.kind () != TARGET_WAITKIND_IGNORE);\n-\t  prepare_resume_reply (own_buf, tp->id, &tp->last_status);\n+\t  prepare_resume_reply (own_buf, tp->id, tp->last_status);\n \t}\n       else\n \tstrcpy (own_buf, \"W00\");\n@@ -4562,11 +4562,11 @@ handle_serial_event (int err, gdb_client_data client_data)\n /* Push a stop notification on the notification queue.  */\n \n static void\n-push_stop_notification (ptid_t ptid, struct target_waitstatus *status)\n+push_stop_notification (ptid_t ptid, const target_waitstatus &status)\n {\n   struct vstop_notif *vstop_notif = new struct vstop_notif;\n \n-  vstop_notif->status = *status;\n+  vstop_notif->status = status;\n   vstop_notif->ptid = ptid;\n   /* Push Stop notification.  */\n   notif_push (&notif_stop, vstop_notif);\n@@ -4587,7 +4587,7 @@ handle_target_event (int err, gdb_client_data client_data)\n   if (cs.last_status.kind () == TARGET_WAITKIND_NO_RESUMED)\n     {\n       if (gdb_connected () && report_no_resumed)\n-\tpush_stop_notification (null_ptid, &cs.last_status);\n+\tpush_stop_notification (null_ptid, cs.last_status);\n     }\n   else if (cs.last_status.kind () != TARGET_WAITKIND_IGNORE)\n     {\n@@ -4645,7 +4645,7 @@ handle_target_event (int err, gdb_client_data client_data)\n \t    }\n \t}\n       else\n-\tpush_stop_notification (cs.last_ptid, &cs.last_status);\n+\tpush_stop_notification (cs.last_ptid, cs.last_status);\n     }\n \n   /* Be sure to not change the selected thread behind GDB's back."
    }
  ]
}