{
  "sha": "3054dd54700066c423fe73731ab46ea2a9c3f541",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzA1NGRkNTQ3MDAwNjZjNDIzZmU3MzczMWFiNDZlYTJhOWMzZjU0MQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:55Z"
    },
    "message": "Create dwarf2/abbrev.[ch]\n\nThis moves the abbrev table code out of dwarf2read.c and into new\nfiles dwarf2/abbrev.[ch].\n\ngdb/ChangeLog\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2read.c (abbrev_table_up, struct abbrev_info)\n\t(struct attr_abbrev, ABBREV_HASH_SIZE, struct abbrev_table):\n\tMove.\n\t(read_cutu_die_from_dwo, build_type_psymtabs_1): Update.\n\t(abbrev_table::alloc_abbrev, abbrev_table::add_abbrev)\n\t(abbrev_table::lookup_abbrev, abbrev_table_read_table): Move to\n\tabbrev.c.\n\t* dwarf2/abbrev.h: New file.\n\t* dwarf2/abbrev.c: New file, from dwarf2read.c.\n\t* Makefile.in (COMMON_SFILES): Add dwarf2/abbrev.c.\n\nChange-Id: I87911bc5297de4407587ca849fef8e8d19136c30",
    "tree": {
      "sha": "2886ae5e6f935730da5f3b5acc6210b56a41aa3a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2886ae5e6f935730da5f3b5acc6210b56a41aa3a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3054dd54700066c423fe73731ab46ea2a9c3f541",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3054dd54700066c423fe73731ab46ea2a9c3f541",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3054dd54700066c423fe73731ab46ea2a9c3f541",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3054dd54700066c423fe73731ab46ea2a9c3f541/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "96b792931fe4dd30f42eecd711ad5e44b6b135a3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/96b792931fe4dd30f42eecd711ad5e44b6b135a3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/96b792931fe4dd30f42eecd711ad5e44b6b135a3"
    }
  ],
  "stats": {
    "total": 524,
    "additions": 300,
    "deletions": 224
  },
  "files": [
    {
      "sha": "5b6feb6cb8f34ac16bee0f2fc59bb7706cc71403",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3054dd54700066c423fe73731ab46ea2a9c3f541",
      "patch": "@@ -1,3 +1,16 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2read.c (abbrev_table_up, struct abbrev_info)\n+\t(struct attr_abbrev, ABBREV_HASH_SIZE, struct abbrev_table):\n+\tMove.\n+\t(read_cutu_die_from_dwo, build_type_psymtabs_1): Update.\n+\t(abbrev_table::alloc_abbrev, abbrev_table::add_abbrev)\n+\t(abbrev_table::lookup_abbrev, abbrev_table_read_table): Move to\n+\tabbrev.c.\n+\t* dwarf2/abbrev.h: New file.\n+\t* dwarf2/abbrev.c: New file, from dwarf2read.c.\n+\t* Makefile.in (COMMON_SFILES): Add dwarf2/abbrev.c.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2read.c (dwarf2_section_buffer_overflow_complaint)"
    },
    {
      "sha": "12abfa43f7b69adac325408cb705a28b8f0cd18b",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=3054dd54700066c423fe73731ab46ea2a9c3f541",
      "patch": "@@ -1002,6 +1002,7 @@ COMMON_SFILES = \\\n \tdwarf2expr.c \\\n \tdwarf2loc.c \\\n \tdwarf2read.c \\\n+\tdwarf2/abbrev.c \\\n \tdwarf2/leb.c \\\n \tdwarf2/section.c \\\n \teval.c \\"
    },
    {
      "sha": "6bd455f012b11ec240d4b7c3414c3273a8bdc006",
      "filename": "gdb/dwarf2/abbrev.c",
      "status": "added",
      "additions": 178,
      "deletions": 0,
      "changes": 178,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/dwarf2/abbrev.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/dwarf2/abbrev.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/abbrev.c?ref=3054dd54700066c423fe73731ab46ea2a9c3f541",
      "patch": "@@ -0,0 +1,178 @@\n+/* DWARF 2 abbreviations\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"dwarf2read.h\"\n+#include \"dwarf2/abbrev.h\"\n+#include \"dwarf2/leb.h\"\n+#include \"bfd.h\"\n+\n+/* Abbreviation tables.\n+\n+   In DWARF version 2, the description of the debugging information is\n+   stored in a separate .debug_abbrev section.  Before we read any\n+   dies from a section we read in all abbreviations and install them\n+   in a hash table.  */\n+\n+/* Allocate space for a struct abbrev_info object in ABBREV_TABLE.  */\n+\n+struct abbrev_info *\n+abbrev_table::alloc_abbrev ()\n+{\n+  struct abbrev_info *abbrev;\n+\n+  abbrev = XOBNEW (&abbrev_obstack, struct abbrev_info);\n+  memset (abbrev, 0, sizeof (struct abbrev_info));\n+\n+  return abbrev;\n+}\n+\n+/* Add an abbreviation to the table.  */\n+\n+void\n+abbrev_table::add_abbrev (unsigned int abbrev_number,\n+\t\t\t  struct abbrev_info *abbrev)\n+{\n+  unsigned int hash_number;\n+\n+  hash_number = abbrev_number % ABBREV_HASH_SIZE;\n+  abbrev->next = m_abbrevs[hash_number];\n+  m_abbrevs[hash_number] = abbrev;\n+}\n+\n+/* Look up an abbrev in the table.\n+   Returns NULL if the abbrev is not found.  */\n+\n+struct abbrev_info *\n+abbrev_table::lookup_abbrev (unsigned int abbrev_number)\n+{\n+  unsigned int hash_number;\n+  struct abbrev_info *abbrev;\n+\n+  hash_number = abbrev_number % ABBREV_HASH_SIZE;\n+  abbrev = m_abbrevs[hash_number];\n+\n+  while (abbrev)\n+    {\n+      if (abbrev->number == abbrev_number)\n+\treturn abbrev;\n+      abbrev = abbrev->next;\n+    }\n+  return NULL;\n+}\n+\n+/* Read in an abbrev table.  */\n+\n+abbrev_table_up\n+abbrev_table_read_table (struct objfile *objfile,\n+\t\t\t struct dwarf2_section_info *section,\n+\t\t\t sect_offset sect_off)\n+{\n+  bfd *abfd = section->get_bfd_owner ();\n+  const gdb_byte *abbrev_ptr;\n+  struct abbrev_info *cur_abbrev;\n+  unsigned int abbrev_number, bytes_read, abbrev_name;\n+  unsigned int abbrev_form;\n+  std::vector<struct attr_abbrev> cur_attrs;\n+\n+  abbrev_table_up abbrev_table (new struct abbrev_table (sect_off));\n+\n+  section->read (objfile);\n+  abbrev_ptr = section->buffer + to_underlying (sect_off);\n+  abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n+  abbrev_ptr += bytes_read;\n+\n+  /* Loop until we reach an abbrev number of 0.  */\n+  while (abbrev_number)\n+    {\n+      cur_attrs.clear ();\n+      cur_abbrev = abbrev_table->alloc_abbrev ();\n+\n+      /* read in abbrev header */\n+      cur_abbrev->number = abbrev_number;\n+      cur_abbrev->tag\n+\t= (enum dwarf_tag) read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n+      abbrev_ptr += bytes_read;\n+      cur_abbrev->has_children = read_1_byte (abfd, abbrev_ptr);\n+      abbrev_ptr += 1;\n+\n+      /* now read in declarations */\n+      for (;;)\n+\t{\n+\t  LONGEST implicit_const;\n+\n+\t  abbrev_name = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n+\t  abbrev_ptr += bytes_read;\n+\t  abbrev_form = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n+\t  abbrev_ptr += bytes_read;\n+\t  if (abbrev_form == DW_FORM_implicit_const)\n+\t    {\n+\t      implicit_const = read_signed_leb128 (abfd, abbrev_ptr,\n+\t\t\t\t\t\t   &bytes_read);\n+\t      abbrev_ptr += bytes_read;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Initialize it due to a false compiler warning.  */\n+\t      implicit_const = -1;\n+\t    }\n+\n+\t  if (abbrev_name == 0)\n+\t    break;\n+\n+\t  cur_attrs.emplace_back ();\n+\t  struct attr_abbrev &cur_attr = cur_attrs.back ();\n+\t  cur_attr.name = (enum dwarf_attribute) abbrev_name;\n+\t  cur_attr.form = (enum dwarf_form) abbrev_form;\n+\t  cur_attr.implicit_const = implicit_const;\n+\t  ++cur_abbrev->num_attrs;\n+\t}\n+\n+      cur_abbrev->attrs =\n+\tXOBNEWVEC (&abbrev_table->abbrev_obstack, struct attr_abbrev,\n+\t\t   cur_abbrev->num_attrs);\n+      memcpy (cur_abbrev->attrs, cur_attrs.data (),\n+\t      cur_abbrev->num_attrs * sizeof (struct attr_abbrev));\n+\n+      abbrev_table->add_abbrev (abbrev_number, cur_abbrev);\n+\n+      /* Get next abbreviation.\n+         Under Irix6 the abbreviations for a compilation unit are not\n+         always properly terminated with an abbrev number of 0.\n+         Exit loop if we encounter an abbreviation which we have\n+         already read (which means we are about to read the abbreviations\n+         for the next compile unit) or if the end of the abbreviation\n+         table is reached.  */\n+      if ((unsigned int) (abbrev_ptr - section->buffer) >= section->size)\n+\tbreak;\n+      abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n+      abbrev_ptr += bytes_read;\n+      if (abbrev_table->lookup_abbrev (abbrev_number) != NULL)\n+\tbreak;\n+    }\n+\n+  return abbrev_table;\n+}"
    },
    {
      "sha": "df83c093be2768a4f48cf46ea13411faabd860f7",
      "filename": "gdb/dwarf2/abbrev.h",
      "status": "added",
      "additions": 103,
      "deletions": 0,
      "changes": 103,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/dwarf2/abbrev.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/dwarf2/abbrev.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/abbrev.h?ref=3054dd54700066c423fe73731ab46ea2a9c3f541",
      "patch": "@@ -0,0 +1,103 @@\n+/* DWARF abbrev table\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDB_DWARF2_ABBREV_H\n+#define GDB_DWARF2_ABBREV_H\n+\n+/* This data structure holds the information of an abbrev.  */\n+struct abbrev_info\n+  {\n+    unsigned int number;\t/* number identifying abbrev */\n+    enum dwarf_tag tag;\t\t/* dwarf tag */\n+    unsigned short has_children;\t\t/* boolean */\n+    unsigned short num_attrs;\t/* number of attributes */\n+    struct attr_abbrev *attrs;\t/* an array of attribute descriptions */\n+    struct abbrev_info *next;\t/* next in chain */\n+  };\n+\n+struct attr_abbrev\n+  {\n+    ENUM_BITFIELD(dwarf_attribute) name : 16;\n+    ENUM_BITFIELD(dwarf_form) form : 16;\n+\n+    /* It is valid only if FORM is DW_FORM_implicit_const.  */\n+    LONGEST implicit_const;\n+  };\n+\n+/* Size of abbrev_table.abbrev_hash_table.  */\n+#define ABBREV_HASH_SIZE 121\n+\n+/* Top level data structure to contain an abbreviation table.  */\n+\n+struct abbrev_table\n+{\n+  explicit abbrev_table (sect_offset off)\n+    : sect_off (off)\n+  {\n+    m_abbrevs =\n+      XOBNEWVEC (&abbrev_obstack, struct abbrev_info *, ABBREV_HASH_SIZE);\n+    memset (m_abbrevs, 0, ABBREV_HASH_SIZE * sizeof (struct abbrev_info *));\n+  }\n+\n+  DISABLE_COPY_AND_ASSIGN (abbrev_table);\n+\n+  /* Allocate space for a struct abbrev_info object in\n+     ABBREV_TABLE.  */\n+  struct abbrev_info *alloc_abbrev ();\n+\n+  /* Add an abbreviation to the table.  */\n+  void add_abbrev (unsigned int abbrev_number, struct abbrev_info *abbrev);\n+\n+  /* Look up an abbrev in the table.\n+     Returns NULL if the abbrev is not found.  */\n+\n+  struct abbrev_info *lookup_abbrev (unsigned int abbrev_number);\n+\n+\n+  /* Where the abbrev table came from.\n+     This is used as a sanity check when the table is used.  */\n+  const sect_offset sect_off;\n+\n+  /* Storage for the abbrev table.  */\n+  auto_obstack abbrev_obstack;\n+\n+private:\n+\n+  /* Hash table of abbrevs.\n+     This is an array of size ABBREV_HASH_SIZE allocated in abbrev_obstack.\n+     It could be statically allocated, but the previous code didn't so we\n+     don't either.  */\n+  struct abbrev_info **m_abbrevs;\n+};\n+\n+typedef std::unique_ptr<struct abbrev_table> abbrev_table_up;\n+\n+extern abbrev_table_up abbrev_table_read_table\n+  (struct objfile *objfile,\n+   struct dwarf2_section_info *section,\n+   sect_offset sect_off);\n+\n+#endif /* GDB_DWARF2_ABBREV_H */"
    },
    {
      "sha": "59ed073a9942522210939300248f3c426566df19",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 5,
      "deletions": 224,
      "changes": 229,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3054dd54700066c423fe73731ab46ea2a9c3f541/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=3054dd54700066c423fe73731ab46ea2a9c3f541",
      "patch": "@@ -30,6 +30,7 @@\n \n #include \"defs.h\"\n #include \"dwarf2read.h\"\n+#include \"dwarf2/abbrev.h\"\n #include \"dwarf-index-cache.h\"\n #include \"dwarf-index-common.h\"\n #include \"dwarf2/leb.h\"\n@@ -875,9 +876,6 @@ struct dwp_file\n   asection **elf_sections = nullptr;\n };\n \n-struct abbrev_table;\n-typedef std::unique_ptr<struct abbrev_table> abbrev_table_up;\n-\n /* Struct used to pass misc. parameters to read_die_and_children, et\n    al.  which are used for both .debug_info and .debug_types dies.\n    All parameters here are unchanging for the life of the call.  This\n@@ -1235,72 +1233,6 @@ struct partial_die_info : public allocate_on_obstack\n     }\n   };\n \n-/* This data structure holds the information of an abbrev.  */\n-struct abbrev_info\n-  {\n-    unsigned int number;\t/* number identifying abbrev */\n-    enum dwarf_tag tag;\t\t/* dwarf tag */\n-    unsigned short has_children;\t\t/* boolean */\n-    unsigned short num_attrs;\t/* number of attributes */\n-    struct attr_abbrev *attrs;\t/* an array of attribute descriptions */\n-    struct abbrev_info *next;\t/* next in chain */\n-  };\n-\n-struct attr_abbrev\n-  {\n-    ENUM_BITFIELD(dwarf_attribute) name : 16;\n-    ENUM_BITFIELD(dwarf_form) form : 16;\n-\n-    /* It is valid only if FORM is DW_FORM_implicit_const.  */\n-    LONGEST implicit_const;\n-  };\n-\n-/* Size of abbrev_table.abbrev_hash_table.  */\n-#define ABBREV_HASH_SIZE 121\n-\n-/* Top level data structure to contain an abbreviation table.  */\n-\n-struct abbrev_table\n-{\n-  explicit abbrev_table (sect_offset off)\n-    : sect_off (off)\n-  {\n-    m_abbrevs =\n-      XOBNEWVEC (&abbrev_obstack, struct abbrev_info *, ABBREV_HASH_SIZE);\n-    memset (m_abbrevs, 0, ABBREV_HASH_SIZE * sizeof (struct abbrev_info *));\n-  }\n-\n-  DISABLE_COPY_AND_ASSIGN (abbrev_table);\n-\n-  /* Allocate space for a struct abbrev_info object in\n-     ABBREV_TABLE.  */\n-  struct abbrev_info *alloc_abbrev ();\n-\n-  /* Add an abbreviation to the table.  */\n-  void add_abbrev (unsigned int abbrev_number, struct abbrev_info *abbrev);\n-\n-  /* Look up an abbrev in the table.\n-     Returns NULL if the abbrev is not found.  */\n-\n-  struct abbrev_info *lookup_abbrev (unsigned int abbrev_number);\n-\n-\n-  /* Where the abbrev table came from.\n-     This is used as a sanity check when the table is used.  */\n-  const sect_offset sect_off;\n-\n-  /* Storage for the abbrev table.  */\n-  auto_obstack abbrev_obstack;\n-\n-private:\n-\n-  /* Hash table of abbrevs.\n-     This is an array of size ABBREV_HASH_SIZE allocated in abbrev_obstack.\n-     It could be statically allocated, but the previous code didn't so we\n-     don't either.  */\n-  struct abbrev_info **m_abbrevs;\n-};\n-\n /* Attributes have a name and a value.  */\n struct attribute\n   {\n@@ -1510,10 +1442,6 @@ static void add_partial_subprogram (struct partial_die_info *pdi,\n \t\t\t\t    CORE_ADDR *lowpc, CORE_ADDR *highpc,\n \t\t\t\t    int need_pc, struct dwarf2_cu *cu);\n \n-static abbrev_table_up abbrev_table_read_table\n-  (struct dwarf2_per_objfile *dwarf2_per_objfile, struct dwarf2_section_info *,\n-   sect_offset);\n-\n static unsigned int peek_abbrev_code (bfd *, const gdb_byte *);\n \n static struct partial_die_info *load_partial_dies\n@@ -7206,7 +7134,7 @@ read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,\n     }\n \n   *result_dwo_abbrev_table\n-    = abbrev_table_read_table (dwarf2_per_objfile, dwo_abbrev_section,\n+    = abbrev_table_read_table (objfile, dwo_abbrev_section,\n \t\t\t       cu->header.abbrev_sect_off);\n   init_cu_die_reader (result_reader, cu, section, dwo_unit->dwo_file,\n \t\t      result_dwo_abbrev_table->get ());\n@@ -7511,7 +7439,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n   else\n     {\n       m_abbrev_table_holder\n-\t= abbrev_table_read_table (dwarf2_per_objfile, abbrev_section,\n+\t= abbrev_table_read_table (objfile, abbrev_section,\n \t\t\t\t   cu->header.abbrev_sect_off);\n       abbrev_table = m_abbrev_table_holder.get ();\n     }\n@@ -7658,7 +7586,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n     }\n \n   m_abbrev_table_holder\n-    = abbrev_table_read_table (dwarf2_per_objfile, abbrev_section,\n+    = abbrev_table_read_table (objfile, abbrev_section,\n \t\t\t       m_new_cu->header.abbrev_sect_off);\n \n   init_cu_die_reader (this, m_new_cu.get (), section, dwo_file,\n@@ -8153,7 +8081,7 @@ build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \t{\n \t  abbrev_offset = tu.abbrev_offset;\n \t  abbrev_table =\n-\t    abbrev_table_read_table (dwarf2_per_objfile,\n+\t    abbrev_table_read_table (dwarf2_per_objfile->objfile,\n \t\t\t\t     &dwarf2_per_objfile->abbrev,\n \t\t\t\t     abbrev_offset);\n \t  ++tu_stats->nr_uniq_abbrev_tables;\n@@ -18257,153 +18185,6 @@ read_full_die (const struct die_reader_specs *reader,\n   return result;\n }\n \f\n-/* Abbreviation tables.\n-\n-   In DWARF version 2, the description of the debugging information is\n-   stored in a separate .debug_abbrev section.  Before we read any\n-   dies from a section we read in all abbreviations and install them\n-   in a hash table.  */\n-\n-/* Allocate space for a struct abbrev_info object in ABBREV_TABLE.  */\n-\n-struct abbrev_info *\n-abbrev_table::alloc_abbrev ()\n-{\n-  struct abbrev_info *abbrev;\n-\n-  abbrev = XOBNEW (&abbrev_obstack, struct abbrev_info);\n-  memset (abbrev, 0, sizeof (struct abbrev_info));\n-\n-  return abbrev;\n-}\n-\n-/* Add an abbreviation to the table.  */\n-\n-void\n-abbrev_table::add_abbrev (unsigned int abbrev_number,\n-\t\t\t  struct abbrev_info *abbrev)\n-{\n-  unsigned int hash_number;\n-\n-  hash_number = abbrev_number % ABBREV_HASH_SIZE;\n-  abbrev->next = m_abbrevs[hash_number];\n-  m_abbrevs[hash_number] = abbrev;\n-}\n-\n-/* Look up an abbrev in the table.\n-   Returns NULL if the abbrev is not found.  */\n-\n-struct abbrev_info *\n-abbrev_table::lookup_abbrev (unsigned int abbrev_number)\n-{\n-  unsigned int hash_number;\n-  struct abbrev_info *abbrev;\n-\n-  hash_number = abbrev_number % ABBREV_HASH_SIZE;\n-  abbrev = m_abbrevs[hash_number];\n-\n-  while (abbrev)\n-    {\n-      if (abbrev->number == abbrev_number)\n-\treturn abbrev;\n-      abbrev = abbrev->next;\n-    }\n-  return NULL;\n-}\n-\n-/* Read in an abbrev table.  */\n-\n-static abbrev_table_up\n-abbrev_table_read_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n-\t\t\t struct dwarf2_section_info *section,\n-\t\t\t sect_offset sect_off)\n-{\n-  struct objfile *objfile = dwarf2_per_objfile->objfile;\n-  bfd *abfd = section->get_bfd_owner ();\n-  const gdb_byte *abbrev_ptr;\n-  struct abbrev_info *cur_abbrev;\n-  unsigned int abbrev_number, bytes_read, abbrev_name;\n-  unsigned int abbrev_form;\n-  std::vector<struct attr_abbrev> cur_attrs;\n-\n-  abbrev_table_up abbrev_table (new struct abbrev_table (sect_off));\n-\n-  section->read (objfile);\n-  abbrev_ptr = section->buffer + to_underlying (sect_off);\n-  abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n-  abbrev_ptr += bytes_read;\n-\n-  /* Loop until we reach an abbrev number of 0.  */\n-  while (abbrev_number)\n-    {\n-      cur_attrs.clear ();\n-      cur_abbrev = abbrev_table->alloc_abbrev ();\n-\n-      /* read in abbrev header */\n-      cur_abbrev->number = abbrev_number;\n-      cur_abbrev->tag\n-\t= (enum dwarf_tag) read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n-      abbrev_ptr += bytes_read;\n-      cur_abbrev->has_children = read_1_byte (abfd, abbrev_ptr);\n-      abbrev_ptr += 1;\n-\n-      /* now read in declarations */\n-      for (;;)\n-\t{\n-\t  LONGEST implicit_const;\n-\n-\t  abbrev_name = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n-\t  abbrev_ptr += bytes_read;\n-\t  abbrev_form = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n-\t  abbrev_ptr += bytes_read;\n-\t  if (abbrev_form == DW_FORM_implicit_const)\n-\t    {\n-\t      implicit_const = read_signed_leb128 (abfd, abbrev_ptr,\n-\t\t\t\t\t\t   &bytes_read);\n-\t      abbrev_ptr += bytes_read;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Initialize it due to a false compiler warning.  */\n-\t      implicit_const = -1;\n-\t    }\n-\n-\t  if (abbrev_name == 0)\n-\t    break;\n-\n-\t  cur_attrs.emplace_back ();\n-\t  struct attr_abbrev &cur_attr = cur_attrs.back ();\n-\t  cur_attr.name = (enum dwarf_attribute) abbrev_name;\n-\t  cur_attr.form = (enum dwarf_form) abbrev_form;\n-\t  cur_attr.implicit_const = implicit_const;\n-\t  ++cur_abbrev->num_attrs;\n-\t}\n-\n-      cur_abbrev->attrs =\n-\tXOBNEWVEC (&abbrev_table->abbrev_obstack, struct attr_abbrev,\n-\t\t   cur_abbrev->num_attrs);\n-      memcpy (cur_abbrev->attrs, cur_attrs.data (),\n-\t      cur_abbrev->num_attrs * sizeof (struct attr_abbrev));\n-\n-      abbrev_table->add_abbrev (abbrev_number, cur_abbrev);\n-\n-      /* Get next abbreviation.\n-         Under Irix6 the abbreviations for a compilation unit are not\n-         always properly terminated with an abbrev number of 0.\n-         Exit loop if we encounter an abbreviation which we have\n-         already read (which means we are about to read the abbreviations\n-         for the next compile unit) or if the end of the abbreviation\n-         table is reached.  */\n-      if ((unsigned int) (abbrev_ptr - section->buffer) >= section->size)\n-\tbreak;\n-      abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);\n-      abbrev_ptr += bytes_read;\n-      if (abbrev_table->lookup_abbrev (abbrev_number) != NULL)\n-\tbreak;\n-    }\n-\n-  return abbrev_table;\n-}\n \n /* Returns nonzero if TAG represents a type that we might generate a partial\n    symbol for.  */"
    }
  ]
}