{
  "sha": "d10eccaa723e31689cdeadaea6bebabe2f63de34",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDEwZWNjYWE3MjNlMzE2ODljZGVhZGFlYTZiZWJhYmUyZjYzZGUzNA==",
  "commit": {
    "author": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2019-10-16T15:11:56Z"
    },
    "committer": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2019-10-16T15:11:56Z"
    },
    "message": "[gdb/tdep] Fix inferior call arg passing for amd64\n\nWe currently have 12 KFAILS in gdb.base/infcall-nested-structs.exp for\nPR tdep/25096.\n\nA minimal version of the failure looks like this.  Consider test.c:\n...\nstruct s { int c; struct { int a; float b; } s1; };\nstruct s ref = { 0, { 'a', 'b' } };\n\nint __attribute__((noinline,noclone)) check (struct s arg)\n{ return arg.s1.a == 'a' && arg.s1.b == 'b' && arg.c == 0; }\n\nint main (void)\n{ return check (ref); }\n...\n\nWhen calling 'check (ref)' from main, we have '1' as expected:\n...\n$ g++ test.c -g ; ./a.out ; echo $?\n1\n...\n\nBut when calling 'check (ref)' from the gdb prompt, we get '0':\n...\n$ gdb a.out -batch -ex start -ex \"p check (ref)\"\nTemporary breakpoint 1 at 0x400518: file test.c, line 8.\n\nTemporary breakpoint 1, main () at test.c:8\n8       { return check (ref); }\n$1 = 0\n...\n\nThe layout of struct s is this:\n- the field c occupies 4 bytes at offset 0,\n- the s1.a field occupies 4 bytes at offset 4, and\n- the s1.b field occupies 4 bytes at offset 8.\n\nWhen compiling at -O2, we can see from the disassembly of main:\n...\n  4003f0:       48 8b 3d 31 0c 20 00    mov    0x200c31(%rip),%rdi \\\n                                               # 601028 <ref>\n  4003f7:       f3 0f 10 05 31 0c 20    movss  0x200c31(%rip),%xmm0 \\\n                                               # 601030 <ref+0x8>\n  4003fe:       00\n  4003ff:       e9 ec 00 00 00          jmpq   4004f0 <_Z5check1s>\n...\nthat check is called with fields c and s1.a passed in %rdi, and s1.b passed\nin %xmm0.\n\nHowever, the classification in theclass (a variable representing the first and\nsecond eightbytes, to put it in SYSV X86_64 psABI terms) in\namd64_push_arguments is incorrect:\n...\n(gdb) p theclass\n$1 = {AMD64_INTEGER, AMD64_INTEGER}\n...\nand therefore the struct is passed using %rdi and %rsi instead of using %rdi\nand %xmm0, which explains the failure.\n\nThe reason that we're misclassifying the argument in amd64_classify_aggregate\nhas to do with how nested struct are handled.\n\nRather than using fields c and s1.a for the first eightbyte, and using field\ns1.b for the second eightbyte, instead field c is used for the first\neightbyte, and fields s1.a and s1.b are classified together in an intermediate\neightbyte, which is then used to merge with both the first and second\neightbyte.\n\nFix this by factoring out a new function amd64_classify_aggregate_field, and\nletting it recursively handle fields of nested structs.\n\nTested on x86_64-linux.\n\nTested with g++ 4.8.5, 7.4.1, 8.3.1, 9.2.1.\n\nTested with clang++ 5.0.2 (which requires removing additional_flags=-Wno-psabi\nand adding additional_flags=-Wno-deprecated).\n\ngdb/ChangeLog:\n\n2019-10-16  Tom de Vries  <tdevries@suse.de>\n\n\tPR tdep/25096\n\t* amd64-tdep.c (amd64_classify_aggregate_field): Factor out of ...\n\t(amd64_classify_aggregate): ... here.\n\t(amd64_classify_aggregate_field): Handled fiels of nested structs\n\trecursively.\n\ngdb/testsuite/ChangeLog:\n\n2019-10-16  Tom de Vries  <tdevries@suse.de>\n\n\tPR tdep/25096\n\t* gdb.base/infcall-nested-structs.exp: Remove PR25096 KFAILs.\n\nChange-Id: Id55c74755f0a431ce31223acc86865718ae0c123",
    "tree": {
      "sha": "5d5f063c7679551fc6c2a536aaff8513f5ef3e8d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5d5f063c7679551fc6c2a536aaff8513f5ef3e8d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d10eccaa723e31689cdeadaea6bebabe2f63de34",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d10eccaa723e31689cdeadaea6bebabe2f63de34",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d10eccaa723e31689cdeadaea6bebabe2f63de34",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d10eccaa723e31689cdeadaea6bebabe2f63de34/comments",
  "author": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "745ff14e6e1b88f04eb447d4883fab81650f745f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/745ff14e6e1b88f04eb447d4883fab81650f745f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/745ff14e6e1b88f04eb447d4883fab81650f745f"
    }
  ],
  "stats": {
    "total": 135,
    "additions": 80,
    "deletions": 55
  },
  "files": [
    {
      "sha": "8748257e015800b977713bacfe2396599a82be77",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d10eccaa723e31689cdeadaea6bebabe2f63de34/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d10eccaa723e31689cdeadaea6bebabe2f63de34/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d10eccaa723e31689cdeadaea6bebabe2f63de34",
      "patch": "@@ -1,3 +1,11 @@\n+2019-10-16  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR tdep/25096\n+\t* amd64-tdep.c (amd64_classify_aggregate_field): Factor out of ...\n+\t(amd64_classify_aggregate): ... here.\n+\t(amd64_classify_aggregate_field): Handled fiels of nested structs\n+\trecursively.\n+\n 2019-10-16  Tom de Vries  <tdevries@suse.de>\n \n \tPR tdep/24104"
    },
    {
      "sha": "67a4d3f11a959bf8c488f5f1f9340cbc3a1617ea",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 67,
      "deletions": 47,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d10eccaa723e31689cdeadaea6bebabe2f63de34/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d10eccaa723e31689cdeadaea6bebabe2f63de34/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=d10eccaa723e31689cdeadaea6bebabe2f63de34",
      "patch": "@@ -579,6 +579,72 @@ amd64_has_unaligned_fields (struct type *type)\n   return false;\n }\n \n+/* Classify field I of TYPE starting at BITOFFSET according to the rules for\n+   structures and union types, and store the result in THECLASS.  */\n+\n+static void\n+amd64_classify_aggregate_field (struct type *type, int i,\n+\t\t\t\tenum amd64_reg_class theclass[2],\n+\t\t\t\tunsigned int bitoffset)\n+{\n+  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n+  int bitpos = bitoffset + TYPE_FIELD_BITPOS (type, i);\n+  int pos = bitpos / 64;\n+  enum amd64_reg_class subclass[2];\n+  int bitsize = TYPE_FIELD_BITSIZE (type, i);\n+  int endpos;\n+\n+  if (bitsize == 0)\n+    bitsize = TYPE_LENGTH (subtype) * 8;\n+  endpos = (bitpos + bitsize - 1) / 64;\n+\n+  /* Ignore static fields, or empty fields, for example nested\n+     empty structures.*/\n+  if (field_is_static (&TYPE_FIELD (type, i)) || bitsize == 0)\n+    return;\n+\n+  if (TYPE_CODE (subtype) == TYPE_CODE_STRUCT\n+      || TYPE_CODE (subtype) == TYPE_CODE_UNION)\n+    {\n+      /* Each field of an object is classified recursively.  */\n+      int j;\n+      for (j = 0; j < TYPE_NFIELDS (subtype); j++)\n+\tamd64_classify_aggregate_field (subtype, j, theclass, bitpos);\n+      return;\n+    }\n+\n+  gdb_assert (pos == 0 || pos == 1);\n+\n+  amd64_classify (subtype, subclass);\n+  theclass[pos] = amd64_merge_classes (theclass[pos], subclass[0]);\n+  if (bitsize <= 64 && pos == 0 && endpos == 1)\n+    /* This is a bit of an odd case:  We have a field that would\n+       normally fit in one of the two eightbytes, except that\n+       it is placed in a way that this field straddles them.\n+       This has been seen with a structure containing an array.\n+\n+       The ABI is a bit unclear in this case, but we assume that\n+       this field's class (stored in subclass[0]) must also be merged\n+       into class[1].  In other words, our field has a piece stored\n+       in the second eight-byte, and thus its class applies to\n+       the second eight-byte as well.\n+\n+       In the case where the field length exceeds 8 bytes,\n+       it should not be necessary to merge the field class\n+       into class[1].  As LEN > 8, subclass[1] is necessarily\n+       different from AMD64_NO_CLASS.  If subclass[1] is equal\n+       to subclass[0], then the normal class[1]/subclass[1]\n+       merging will take care of everything.  For subclass[1]\n+       to be different from subclass[0], I can only see the case\n+       where we have a SSE/SSEUP or X87/X87UP pair, which both\n+       use up all 16 bytes of the aggregate, and are already\n+       handled just fine (because each portion sits on its own\n+       8-byte).  */\n+    theclass[1] = amd64_merge_classes (theclass[1], subclass[0]);\n+  if (pos == 0)\n+    theclass[1] = amd64_merge_classes (theclass[1], subclass[1]);\n+}\n+\n /* Classify TYPE according to the rules for aggregate (structures and\n    arrays) and union types, and store the result in CLASS.  */\n \n@@ -619,53 +685,7 @@ amd64_classify_aggregate (struct type *type, enum amd64_reg_class theclass[2])\n \t\t  || TYPE_CODE (type) == TYPE_CODE_UNION);\n \n       for (i = 0; i < TYPE_NFIELDS (type); i++)\n-\t{\n-\t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n-\t  int pos = TYPE_FIELD_BITPOS (type, i) / 64;\n-\t  enum amd64_reg_class subclass[2];\n-\t  int bitsize = TYPE_FIELD_BITSIZE (type, i);\n-\t  int endpos;\n-\n-\t  if (bitsize == 0)\n-\t    bitsize = TYPE_LENGTH (subtype) * 8;\n-\t  endpos = (TYPE_FIELD_BITPOS (type, i) + bitsize - 1) / 64;\n-\n-\t  /* Ignore static fields, or empty fields, for example nested\n-\t     empty structures.*/\n-\t  if (field_is_static (&TYPE_FIELD (type, i)) || bitsize == 0)\n-\t    continue;\n-\n-\t  gdb_assert (pos == 0 || pos == 1);\n-\n-\t  amd64_classify (subtype, subclass);\n-\t  theclass[pos] = amd64_merge_classes (theclass[pos], subclass[0]);\n-\t  if (bitsize <= 64 && pos == 0 && endpos == 1)\n-\t    /* This is a bit of an odd case:  We have a field that would\n-\t       normally fit in one of the two eightbytes, except that\n-\t       it is placed in a way that this field straddles them.\n-\t       This has been seen with a structure containing an array.\n-\n-\t       The ABI is a bit unclear in this case, but we assume that\n-\t       this field's class (stored in subclass[0]) must also be merged\n-\t       into class[1].  In other words, our field has a piece stored\n-\t       in the second eight-byte, and thus its class applies to\n-\t       the second eight-byte as well.\n-\n-\t       In the case where the field length exceeds 8 bytes,\n-\t       it should not be necessary to merge the field class\n-\t       into class[1].  As LEN > 8, subclass[1] is necessarily\n-\t       different from AMD64_NO_CLASS.  If subclass[1] is equal\n-\t       to subclass[0], then the normal class[1]/subclass[1]\n-\t       merging will take care of everything.  For subclass[1]\n-\t       to be different from subclass[0], I can only see the case\n-\t       where we have a SSE/SSEUP or X87/X87UP pair, which both\n-\t       use up all 16 bytes of the aggregate, and are already\n-\t       handled just fine (because each portion sits on its own\n-\t       8-byte).  */\n-\t    theclass[1] = amd64_merge_classes (theclass[1], subclass[0]);\n-\t  if (pos == 0)\n-\t    theclass[1] = amd64_merge_classes (theclass[1], subclass[1]);\n-\t}\n+\tamd64_classify_aggregate_field (type, i, theclass, 0);\n     }\n \n   /* 4. Then a post merger cleanup is done:  */"
    },
    {
      "sha": "befc4bb0100b9dba9a37c37c23d45e3ac4a5bf28",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d10eccaa723e31689cdeadaea6bebabe2f63de34/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d10eccaa723e31689cdeadaea6bebabe2f63de34/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=d10eccaa723e31689cdeadaea6bebabe2f63de34",
      "patch": "@@ -1,3 +1,8 @@\n+2019-10-16  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR tdep/25096\n+\t* gdb.base/infcall-nested-structs.exp: Remove PR25096 KFAILs.\n+\n 2019-10-16  Tom de Vries  <tdevries@suse.de>\n \n \tPR tdep/24104"
    },
    {
      "sha": "982149f42c1b60818ba40b22dd2a117880c336af",
      "filename": "gdb/testsuite/gdb.base/infcall-nested-structs.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d10eccaa723e31689cdeadaea6bebabe2f63de34/gdb/testsuite/gdb.base/infcall-nested-structs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d10eccaa723e31689cdeadaea6bebabe2f63de34/gdb/testsuite/gdb.base/infcall-nested-structs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/infcall-nested-structs.exp?ref=d10eccaa723e31689cdeadaea6bebabe2f63de34",
      "patch": "@@ -132,10 +132,6 @@ proc run_tests { lang types } {\n \t    continue\n \t}\n \n-\tif { $lang == \"c++\" && $name == \"struct_02_01\"\n-\t     && [regexp \"^types-(tf-t(c|s|i)|t(c|s|i)-tf)\" $types match] } {\n-\t    setup_kfail gdb/25096 \"x86_64-*-linux*\"\n-\t}\n \tgdb_test \"p/d check_arg_${name} (ref_val_${name})\" \"= 1\"\n \n \tset refval [ get_valueof \"\" \"ref_val_${name}\" \"\" ]\n@@ -147,10 +143,6 @@ proc run_tests { lang types } {\n \t    set answer [ get_valueof \"\" \"rtn_str_${name} ()\" \"XXXX\"]\n \t    verbose -log \"Answer: ${answer}\"\n \n-\t    if { $lang == \"c++\" && $name == \"struct_02_01\"\n-\t\t && [regexp \"^types-(tf-t(c|s|i)|t(c|s|i)-tf)\" $types match] } {\n-\t\tsetup_kfail gdb/25096 \"x86_64-*-linux*\"\n-\t    }\n \t    gdb_assert [string eq ${answer} ${refval}] ${test}\n \t} else {\n \t    unresolved $test"
    }
  ]
}