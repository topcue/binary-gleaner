{
  "sha": "013e3554b269aa1da0fcd478969f0df65341e50e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDEzZTM1NTRiMjY5YWExZGEwZmNkNDc4OTY5ZjBkZjY1MzQxZTUwZQ==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-06-22T12:13:48Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-06-22T12:13:48Z"
    },
    "message": "gdbserver/linux-low: use std::list to store pending signals\n\nUse std::list to store pending signals instead of a manually-managed\nlinked list.  This is a refactoring.\n\nIn the existing code, pending signals are kept in a manually-created\nlinked list with \"prev\" pointers.  A new pending signal is thus\ninserted to the beginning of the list.  When consuming, GDB goes until\nthe end of the list, following the \"prev\" pointers, and processes the\nfinal item.  With this patch, a new item is added to the end of the\nlist and the item at the front of the list is consumed.  In other\nwords, the list elements used to be stored in reverse order; with this\npatch, they are stored in their order of arrival.  This causes a change\nin the debug messages that print the pending signals.  Otherwise, no\nbehavioral change is expected.\n\ngdbserver/ChangeLog:\n2020-06-22  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\tUse std::list to stop pending signal instead of manually-created\n\tlinked list.\n\t* linux-low.h: Include <list>.\n\t(struct pending_signal): Move here from linux-low.cc.\n\t(struct lwp_info) <pending_signals>\n\t<pending_signals_to_report>: Update the type.\n\t* linux-low.cc (struct pending_signals): Remove.\n\t(linux_process_target::delete_lwp)\n\t(linux_process_target::add_lwp)\n\t(enqueue_one_deferred_signal)\n\t(dequeue_one_deferred_signal)\n\t(enqueue_pending_signal)\n\t(linux_process_target::resume_one_lwp_throw)\n\t(linux_process_target::thread_needs_step_over)\n\t(linux_process_target::resume_one_thread)\n\t(linux_process_target::proceed_one_lwp): Update the use of pending\n\tsignal list.",
    "tree": {
      "sha": "b7ef9feb80297403a78f0ab0bd582d7b764f1b1d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b7ef9feb80297403a78f0ab0bd582d7b764f1b1d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/013e3554b269aa1da0fcd478969f0df65341e50e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/013e3554b269aa1da0fcd478969f0df65341e50e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/013e3554b269aa1da0fcd478969f0df65341e50e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/013e3554b269aa1da0fcd478969f0df65341e50e/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bd920864f3dc2cad376989a642ab774aef6b2fce",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bd920864f3dc2cad376989a642ab774aef6b2fce",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bd920864f3dc2cad376989a642ab774aef6b2fce"
    }
  ],
  "stats": {
    "total": 148,
    "additions": 72,
    "deletions": 76
  },
  "files": [
    {
      "sha": "c5c3b09841e0c159cb01c46740aa1172cfd32661",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/013e3554b269aa1da0fcd478969f0df65341e50e/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/013e3554b269aa1da0fcd478969f0df65341e50e/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=013e3554b269aa1da0fcd478969f0df65341e50e",
      "patch": "@@ -1,3 +1,23 @@\n+2020-06-22  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\tUse std::list to stop pending signal instead of manually-created\n+\tlinked list.\n+\t* linux-low.h: Include <list>.\n+\t(struct pending_signal): Move here from linux-low.cc.\n+\t(struct lwp_info) <pending_signals>\n+\t<pending_signals_to_report>: Update the type.\n+\t* linux-low.cc (struct pending_signals): Remove.\n+\t(linux_process_target::delete_lwp)\n+\t(linux_process_target::add_lwp)\n+\t(enqueue_one_deferred_signal)\n+\t(dequeue_one_deferred_signal)\n+\t(enqueue_pending_signal)\n+\t(linux_process_target::resume_one_lwp_throw)\n+\t(linux_process_target::thread_needs_step_over)\n+\t(linux_process_target::resume_one_thread)\n+\t(linux_process_target::proceed_one_lwp): Update the use of pending\n+\tsignal list.\n+\n 2020-06-17  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* Makefile.in (%-generated.cc: ../gdb/regformats/arm/%.dat):"
    },
    {
      "sha": "9684922d1a1026a09cde6d43a55007a3947928ea",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 32,
      "deletions": 69,
      "changes": 101,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/013e3554b269aa1da0fcd478969f0df65341e50e/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/013e3554b269aa1da0fcd478969f0df65341e50e/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=013e3554b269aa1da0fcd478969f0df65341e50e",
      "patch": "@@ -315,13 +315,6 @@ lwp_in_step_range (struct lwp_info *lwp)\n   return (pc >= lwp->step_range_start && pc < lwp->step_range_end);\n }\n \n-struct pending_signals\n-{\n-  int signal;\n-  siginfo_t info;\n-  struct pending_signals *prev;\n-};\n-\n /* The read/write ends of the pipe registered as waitable file in the\n    event loop.  */\n static int linux_event_pipe[2] = { -1, -1 };\n@@ -397,7 +390,7 @@ linux_process_target::delete_lwp (lwp_info *lwp)\n \n   low_delete_thread (lwp->arch_private);\n \n-  free (lwp);\n+  delete lwp;\n }\n \n void\n@@ -914,7 +907,7 @@ linux_process_target::add_lwp (ptid_t ptid)\n {\n   struct lwp_info *lwp;\n \n-  lwp = XCNEW (struct lwp_info);\n+  lwp = new lwp_info {};\n \n   lwp->waitstatus.kind = TARGET_WAITKIND_IGNORE;\n \n@@ -2119,7 +2112,6 @@ linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n static void\n enqueue_one_deferred_signal (struct lwp_info *lwp, int *wstat)\n {\n-  struct pending_signals *p_sig;\n   struct thread_info *thread = get_lwp_thread (lwp);\n \n   if (debug_threads)\n@@ -2128,13 +2120,9 @@ enqueue_one_deferred_signal (struct lwp_info *lwp, int *wstat)\n \n   if (debug_threads)\n     {\n-      struct pending_signals *sig;\n-\n-      for (sig = lwp->pending_signals_to_report;\n-\t   sig != NULL;\n-\t   sig = sig->prev)\n+      for (const auto &sig : lwp->pending_signals_to_report)\n \tdebug_printf (\"   Already queued %d\\n\",\n-\t\t      sig->signal);\n+\t\t      sig.signal);\n \n       debug_printf (\"   (no more currently queued signals)\\n\");\n     }\n@@ -2144,32 +2132,24 @@ enqueue_one_deferred_signal (struct lwp_info *lwp, int *wstat)\n      twice)  */\n   if (WSTOPSIG (*wstat) < __SIGRTMIN)\n     {\n-      struct pending_signals *sig;\n-\n-      for (sig = lwp->pending_signals_to_report;\n-\t   sig != NULL;\n-\t   sig = sig->prev)\n+      for (const auto &sig : lwp->pending_signals_to_report)\n \t{\n-\t  if (sig->signal == WSTOPSIG (*wstat))\n+\t  if (sig.signal == WSTOPSIG (*wstat))\n \t    {\n \t      if (debug_threads)\n \t\tdebug_printf (\"Not requeuing already queued non-RT signal %d\"\n \t\t\t      \" for LWP %ld\\n\",\n-\t\t\t      sig->signal,\n+\t\t\t      sig.signal,\n \t\t\t      lwpid_of (thread));\n \t      return;\n \t    }\n \t}\n     }\n \n-  p_sig = XCNEW (struct pending_signals);\n-  p_sig->prev = lwp->pending_signals_to_report;\n-  p_sig->signal = WSTOPSIG (*wstat);\n+  lwp->pending_signals_to_report.emplace_back (WSTOPSIG (*wstat));\n \n   ptrace (PTRACE_GETSIGINFO, lwpid_of (thread), (PTRACE_TYPE_ARG3) 0,\n-\t  &p_sig->info);\n-\n-  lwp->pending_signals_to_report = p_sig;\n+\t  &lwp->pending_signals_to_report.back ().info);\n }\n \n /* Dequeue one signal from the \"signals to report later when out of\n@@ -2180,34 +2160,26 @@ dequeue_one_deferred_signal (struct lwp_info *lwp, int *wstat)\n {\n   struct thread_info *thread = get_lwp_thread (lwp);\n \n-  if (lwp->pending_signals_to_report != NULL)\n+  if (!lwp->pending_signals_to_report.empty ())\n     {\n-      struct pending_signals **p_sig;\n+      const pending_signal &p_sig = lwp->pending_signals_to_report.front ();\n \n-      p_sig = &lwp->pending_signals_to_report;\n-      while ((*p_sig)->prev != NULL)\n-\tp_sig = &(*p_sig)->prev;\n-\n-      *wstat = W_STOPCODE ((*p_sig)->signal);\n-      if ((*p_sig)->info.si_signo != 0)\n+      *wstat = W_STOPCODE (p_sig.signal);\n+      if (p_sig.info.si_signo != 0)\n \tptrace (PTRACE_SETSIGINFO, lwpid_of (thread), (PTRACE_TYPE_ARG3) 0,\n-\t\t&(*p_sig)->info);\n-      free (*p_sig);\n-      *p_sig = NULL;\n+\t\t&p_sig.info);\n+\n+      lwp->pending_signals_to_report.pop_front ();\n \n       if (debug_threads)\n \tdebug_printf (\"Reporting deferred signal %d for LWP %ld.\\n\",\n \t\t      WSTOPSIG (*wstat), lwpid_of (thread));\n \n       if (debug_threads)\n \t{\n-\t  struct pending_signals *sig;\n-\n-\t  for (sig = lwp->pending_signals_to_report;\n-\t       sig != NULL;\n-\t       sig = sig->prev)\n+\t  for (const auto &sig : lwp->pending_signals_to_report)\n \t    debug_printf (\"   Still queued %d\\n\",\n-\t\t\t  sig->signal);\n+\t\t\t  sig.signal);\n \n \t  debug_printf (\"   (no more queued signals)\\n\");\n \t}\n@@ -4050,15 +4022,11 @@ linux_process_target::stop_all_lwps (int suspend, lwp_info *except)\n static void\n enqueue_pending_signal (struct lwp_info *lwp, int signal, siginfo_t *info)\n {\n-  struct pending_signals *p_sig = XNEW (struct pending_signals);\n-\n-  p_sig->prev = lwp->pending_signals;\n-  p_sig->signal = signal;\n-  if (info == NULL)\n-    memset (&p_sig->info, 0, sizeof (siginfo_t));\n+  lwp->pending_signals.emplace_back (signal);\n+  if (info == nullptr)\n+    memset (&lwp->pending_signals.back ().info, 0, sizeof (siginfo_t));\n   else\n-    memcpy (&p_sig->info, info, sizeof (siginfo_t));\n-  lwp->pending_signals = p_sig;\n+    lwp->pending_signals.back ().info = *info;\n }\n \n void\n@@ -4154,7 +4122,7 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n      inferior right now.  */\n   if (signal != 0\n       && (lwp->status_pending_p\n-\t  || lwp->pending_signals != NULL\n+\t  || !lwp->pending_signals.empty ()\n \t  || !lwp_signal_can_be_delivered (lwp)))\n     {\n       enqueue_pending_signal (lwp, signal, info);\n@@ -4263,21 +4231,16 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n \n   /* If we have pending signals, consume one if it can be delivered to\n      the inferior.  */\n-  if (lwp->pending_signals != NULL && lwp_signal_can_be_delivered (lwp))\n+  if (!lwp->pending_signals.empty () && lwp_signal_can_be_delivered (lwp))\n     {\n-      struct pending_signals **p_sig;\n-\n-      p_sig = &lwp->pending_signals;\n-      while ((*p_sig)->prev != NULL)\n-\tp_sig = &(*p_sig)->prev;\n+      const pending_signal &p_sig = lwp->pending_signals.front ();\n \n-      signal = (*p_sig)->signal;\n-      if ((*p_sig)->info.si_signo != 0)\n+      signal = p_sig.signal;\n+      if (p_sig.info.si_signo != 0)\n \tptrace (PTRACE_SETSIGINFO, lwpid_of (thread), (PTRACE_TYPE_ARG3) 0,\n-\t\t&(*p_sig)->info);\n+\t\t&p_sig.info);\n \n-      free (*p_sig);\n-      *p_sig = NULL;\n+      lwp->pending_signals.pop_front ();\n     }\n \n   if (debug_threads)\n@@ -4570,7 +4533,7 @@ linux_process_target::thread_needs_step_over (thread_info *thread)\n   /* On software single step target, resume the inferior with signal\n      rather than stepping over.  */\n   if (supports_software_single_step ()\n-      && lwp->pending_signals != NULL\n+      && !lwp->pending_signals.empty ()\n       && lwp_signal_can_be_delivered (lwp))\n     {\n       if (debug_threads)\n@@ -4787,7 +4750,7 @@ linux_process_target::resume_one_thread (thread_info *thread,\n \t     midway through moving the LWP out of the jumppad, and we\n \t     will report the pending signal as soon as that is\n \t     finished.  */\n-\t  if (lwp->pending_signals_to_report == NULL)\n+\t  if (lwp->pending_signals_to_report.empty ())\n \t    send_sigstop (lwp);\n \t}\n \n@@ -4966,7 +4929,7 @@ linux_process_target::proceed_one_lwp (thread_info *thread, lwp_info *except)\n     }\n \n   if (thread->last_resume_kind == resume_stop\n-      && lwp->pending_signals_to_report == NULL\n+      && lwp->pending_signals_to_report.empty ()\n       && (lwp->collecting_fast_tracepoint\n \t  == fast_tpoint_collect_result::not_collecting))\n     {"
    },
    {
      "sha": "0ef659fb0f06bd31c1990509c52029349e0fdca4",
      "filename": "gdbserver/linux-low.h",
      "status": "modified",
      "additions": 20,
      "deletions": 7,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/013e3554b269aa1da0fcd478969f0df65341e50e/gdbserver/linux-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/013e3554b269aa1da0fcd478969f0df65341e50e/gdbserver/linux-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.h?ref=013e3554b269aa1da0fcd478969f0df65341e50e",
      "patch": "@@ -31,6 +31,8 @@\n #include \"target/waitstatus.h\" /* For enum target_stop_reason.  */\n #include \"tracepoint.h\"\n \n+#include <list>\n+\n #define PTRACE_XFER_TYPE long\n \n #ifdef HAVE_LINUX_REGSETS\n@@ -695,6 +697,18 @@ extern linux_process_target *the_linux_target;\n #define get_thread_lwp(thr) ((struct lwp_info *) (thread_target_data (thr)))\n #define get_lwp_thread(lwp) ((lwp)->thread)\n \n+/* Information about a signal that is to be delivered to a thread.  */\n+\n+struct pending_signal\n+{\n+  pending_signal (int signal)\n+    : signal {signal}\n+  {};\n+\n+  int signal;\n+  siginfo_t info;\n+};\n+\n /* This struct is recorded in the target_data field of struct thread_info.\n \n    On linux ``all_threads'' is keyed by the LWP ID, which we use as the\n@@ -786,9 +800,8 @@ struct lwp_info\n      next time we see this LWP stop.  */\n   int must_set_ptrace_flags;\n \n-  /* If this is non-zero, it points to a chain of signals which need to\n-     be delivered to this process.  */\n-  struct pending_signals *pending_signals;\n+  /* A chain of signals that need to be delivered to this process.  */\n+  std::list<pending_signal> pending_signals;\n \n   /* A link used when resuming.  It is initialized from the resume request,\n      and then processed and cleared in linux_resume_one_lwp.  */\n@@ -800,10 +813,10 @@ struct lwp_info\n      if a signal arrives to this lwp while it is collecting.  */\n   fast_tpoint_collect_result collecting_fast_tracepoint;\n \n-  /* If this is non-zero, it points to a chain of signals which need\n-     to be reported to GDB.  These were deferred because the thread\n-     was doing a fast tracepoint collect when they arrived.  */\n-  struct pending_signals *pending_signals_to_report;\n+  /* A chain of signals that need to be reported to GDB.  These were\n+     deferred because the thread was doing a fast tracepoint collect\n+     when they arrived.  */\n+  std::list<pending_signal> pending_signals_to_report;\n \n   /* When collecting_fast_tracepoint is first found to be 1, we insert\n      a exit-jump-pad-quickly breakpoint.  This is it.  */"
    }
  ]
}