{
  "sha": "40cb8ca5396e563968fa8465a10173e7c2fd9d84",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDBjYjhjYTUzOTZlNTYzOTY4ZmE4NDY1YTEwMTczZTdjMmZkOWQ4NA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:37Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:37Z"
    },
    "message": "gdb: add breakpoint::locations method\n\nAdd the breakpoint::locations method, which returns a range that can be\nused to iterate over a breakpoint's locations.  This shortens\n\n  for (bp_location *loc = b->loc; loc != nullptr; loc = loc->next)\n\ninto\n\n  for (bp_location *loc : b->locations ())\n\nChange all the places that I found that could use it.\n\ngdb/ChangeLog:\n\n\t* breakpoint.h (bp_locations_range): New.\n\t(struct breakpoint) <locations>: New.  Use where possible.\n\nChange-Id: I1ba2f7d93d57e544e1f8609124587dcf2e1da037",
    "tree": {
      "sha": "aefc927ed2d6358fffd3c6db828751a3fd0996ce",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/aefc927ed2d6358fffd3c6db828751a3fd0996ce"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/40cb8ca5396e563968fa8465a10173e7c2fd9d84",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/40cb8ca5396e563968fa8465a10173e7c2fd9d84",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/40cb8ca5396e563968fa8465a10173e7c2fd9d84",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/40cb8ca5396e563968fa8465a10173e7c2fd9d84/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f6d17b2b1c042853b80d790b0c6a10d2b4347faa",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f6d17b2b1c042853b80d790b0c6a10d2b4347faa"
    }
  ],
  "stats": {
    "total": 184,
    "additions": 83,
    "deletions": 101
  },
  "files": [
    {
      "sha": "a52819459fa984a46d9e43ccfd38c623a45bbd36",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -1,3 +1,8 @@\n+2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* breakpoint.h (bp_locations_range): New.\n+\t(struct breakpoint) <locations>: New.  Use where possible.\n+\n 2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* breakpoint.h (all_tracepoints): Remove."
    },
    {
      "sha": "f0c1aa2c8a67a6520c43dbad70efcdd2779ad70b",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -11552,8 +11552,6 @@ static void\n create_excep_cond_exprs (struct ada_catchpoint *c,\n \t\t\t enum ada_exception_catchpoint_kind ex)\n {\n-  struct bp_location *bl;\n-\n   /* Nothing to do if there's no specific exception to catch.  */\n   if (c->excep_string.empty ())\n     return;\n@@ -11569,7 +11567,7 @@ create_excep_cond_exprs (struct ada_catchpoint *c,\n \n   /* Iterate over all the catchpoint's locations, and parse an\n      expression for each.  */\n-  for (bl = c->loc; bl != NULL; bl = bl->next)\n+  for (bp_location *bl : c->locations ())\n     {\n       struct ada_catchpoint_location *ada_loc\n \t= (struct ada_catchpoint_location *) bl;"
    },
    {
      "sha": "593a7714886aed30ba230d964d524e6d40a0964a",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 58,
      "deletions": 74,
      "changes": 132,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -680,8 +680,6 @@ get_breakpoint (int num)\n static void\n mark_breakpoint_modified (struct breakpoint *b)\n {\n-  struct bp_location *loc;\n-\n   /* This is only meaningful if the target is\n      evaluating conditions and if the user has\n      opted for condition evaluation on the target's\n@@ -693,7 +691,7 @@ mark_breakpoint_modified (struct breakpoint *b)\n   if (!is_breakpoint (b))\n     return;\n \n-  for (loc = b->loc; loc; loc = loc->next)\n+  for (bp_location *loc : b->locations ())\n     loc->condition_changed = condition_modified;\n }\n \n@@ -910,7 +908,7 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n       else\n \t{\n \t  int loc_num = 1;\n-\t  for (bp_location *loc = b->loc; loc != nullptr; loc = loc->next)\n+\t  for (bp_location *loc : b->locations ())\n \t    {\n \t      loc->cond.reset ();\n \t      if (loc->disabled_by_cond && loc->enabled)\n@@ -952,7 +950,7 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \t     the error and the condition string will be rejected.\n \t     This two-pass approach is taken to avoid setting the\n \t     state of locations in case of a reject.  */\n-\t  for (bp_location *loc = b->loc; loc != nullptr; loc = loc->next)\n+\t  for (bp_location *loc : b->locations ())\n \t    {\n \t      try\n \t\t{\n@@ -975,9 +973,11 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \n \t  /* If we reach here, the condition is valid at some locations.  */\n \t  int loc_num = 1;\n-\t  for (bp_location *loc = b->loc; loc != nullptr;\n-\t       loc = loc->next, loc_num++)\n-\t    set_breakpoint_location_condition (exp, loc, b->number, loc_num);\n+\t  for (bp_location *loc : b->locations ())\n+\t    {\n+\t      set_breakpoint_location_condition (exp, loc, b->number, loc_num);\n+\t      loc_num++;\n+\t    }\n \t}\n \n       /* We know that the new condition parsed successfully.  The\n@@ -1287,12 +1287,11 @@ std::vector<breakpoint *>\n static_tracepoints_here (CORE_ADDR addr)\n {\n   std::vector<breakpoint *> found;\n-  struct bp_location *loc;\n \n   for (breakpoint *b : all_breakpoints ())\n     if (b->type == bp_static_tracepoint)\n       {\n-\tfor (loc = b->loc; loc; loc = loc->next)\n+\tfor (bp_location *loc : b->locations ())\n \t  if (loc->address == addr)\n \t    found.push_back (b);\n       }\n@@ -2032,7 +2031,6 @@ update_watchpoint (struct watchpoint *b, int reparse)\n \t{\n \t  int reg_cnt;\n \t  enum bp_loc_type loc_type;\n-\t  struct bp_location *bl;\n \n \t  reg_cnt = can_use_hardware_watchpoint (val_chain);\n \n@@ -2108,7 +2106,7 @@ update_watchpoint (struct watchpoint *b, int reparse)\n \n \t  loc_type = (b->type == bp_watchpoint? bp_loc_other\n \t\t      : bp_loc_hardware_watchpoint);\n-\t  for (bl = b->loc; bl; bl = bl->next)\n+\t  for (bp_location *bl : b->locations ())\n \t    bl->loc_type = loc_type;\n \t}\n \n@@ -3083,7 +3081,6 @@ insert_breakpoint_locations (void)\n   for (breakpoint *bpt : all_breakpoints ())\n     {\n       int some_failed = 0;\n-      struct bp_location *loc;\n \n       if (!is_hardware_watchpoint (bpt))\n \tcontinue;\n@@ -3094,15 +3091,16 @@ insert_breakpoint_locations (void)\n       if (bpt->disposition == disp_del_at_next_stop)\n \tcontinue;\n       \n-      for (loc = bpt->loc; loc; loc = loc->next)\n+      for (bp_location *loc : bpt->locations ())\n \tif (!loc->inserted && should_be_inserted (loc))\n \t  {\n \t    some_failed = 1;\n \t    break;\n \t  }\n+\n       if (some_failed)\n \t{\n-\t  for (loc = bpt->loc; loc; loc = loc->next)\n+\t  for (bp_location *loc : bpt->locations ())\n \t    if (loc->inserted)\n \t      remove_breakpoint (loc);\n \n@@ -4287,16 +4285,14 @@ hardware_watchpoint_inserted_in_range (const address_space *aspace,\n {\n   for (breakpoint *bpt : all_breakpoints ())\n     {\n-      struct bp_location *loc;\n-\n       if (bpt->type != bp_hardware_watchpoint\n \t  && bpt->type != bp_access_watchpoint)\n \tcontinue;\n \n       if (!breakpoint_enabled (bpt))\n \tcontinue;\n \n-      for (loc = bpt->loc; loc; loc = loc->next)\n+      for (bp_location *loc : bpt->locations ())\n \tif (loc->pspace->aspace == aspace && loc->inserted)\n \t  {\n \t    CORE_ADDR l, h;\n@@ -4903,10 +4899,9 @@ watchpoints_triggered (struct target_waitstatus *ws)\n     if (is_hardware_watchpoint (b))\n       {\n \tstruct watchpoint *w = (struct watchpoint *) b;\n-\tstruct bp_location *loc;\n \n \tw->watchpoint_triggered = watch_triggered_no;\n-\tfor (loc = b->loc; loc; loc = loc->next)\n+\tfor (bp_location *loc : b->locations ())\n \t  {\n \t    if (is_masked_watchpoint (b))\n \t      {\n@@ -5448,7 +5443,7 @@ build_bpstat_chain (const address_space *aspace, CORE_ADDR bp_addr,\n       if (!breakpoint_enabled (b))\n \tcontinue;\n \n-      for (bp_location *bl = b->loc; bl != NULL; bl = bl->next)\n+      for (bp_location *bl : b->locations ())\n \t{\n \t  /* For hardware watchpoints, we look only at the first\n \t     location.  The watchpoint_check function will work on the\n@@ -5918,7 +5913,6 @@ wrap_indent_at_field (struct ui_out *uiout, const char *col_name)\n static const char *\n bp_condition_evaluator (struct breakpoint *b)\n {\n-  struct bp_location *bl;\n   char host_evals = 0;\n   char target_evals = 0;\n \n@@ -5932,7 +5926,7 @@ bp_condition_evaluator (struct breakpoint *b)\n       || !target_supports_evaluation_of_breakpoint_conditions ())\n     return condition_evaluation_host;\n \n-  for (bl = b->loc; bl; bl = bl->next)\n+  for (bp_location *bl : b->locations ())\n     {\n       if (bl->cond_bytecode)\n \ttarget_evals++;\n@@ -6516,11 +6510,12 @@ print_one_breakpoint (struct breakpoint *b,\n \t    locations_list.emplace (uiout, \"locations\");\n \n \t  int n = 1;\n-\t  for (bp_location *loc = b->loc; loc != NULL; loc = loc->next, ++n)\n+\t  for (bp_location *loc : b->locations ())\n \t    {\n \t      ui_out_emit_tuple loc_tuple_emitter (uiout, NULL);\n \t      print_one_breakpoint_location (b, loc, n, last_loc,\n \t\t\t\t\t     allflag, allflag);\n+\t      n++;\n \t    }\n \t}\n     }\n@@ -6530,14 +6525,13 @@ static int\n breakpoint_address_bits (struct breakpoint *b)\n {\n   int print_address_bits = 0;\n-  struct bp_location *loc;\n \n   /* Software watchpoints that aren't watching memory don't have an\n      address to print.  */\n   if (is_no_memory_software_watchpoint (b))\n     return 0;\n \n-  for (loc = b->loc; loc; loc = loc->next)\n+  for (bp_location *loc : b->locations ())\n     {\n       int addr_bit;\n \n@@ -6701,7 +6695,7 @@ breakpoint_1 (const char *bp_num_list, bool show_internal,\n \tif (show_internal || user_breakpoint_p (b))\n \t  {\n \t    print_one_breakpoint (b, &last_loc, show_internal);\n-\t    for (bp_location *loc = b->loc; loc != NULL; loc = loc->next)\n+\t    for (bp_location *loc : b->locations ())\n \t      if (loc->disabled_by_cond)\n \t\thas_disabled_by_cond_location = true;\n \t  }\n@@ -6795,9 +6789,7 @@ breakpoint_has_pc (struct breakpoint *b,\n \t\t   struct program_space *pspace,\n \t\t   CORE_ADDR pc, struct obj_section *section)\n {\n-  struct bp_location *bl = b->loc;\n-\n-  for (; bl; bl = bl->next)\n+  for (bp_location *bl : b->locations ())\n     {\n       if (bl->pspace == pspace\n \t  && bl->address == pc\n@@ -7731,13 +7723,12 @@ disable_breakpoints_in_freed_objfile (struct objfile *objfile)\n \n   for (breakpoint *b : all_breakpoints ())\n     {\n-      struct bp_location *loc;\n       int bp_modified = 0;\n \n       if (!is_breakpoint (b) && !is_tracepoint (b))\n \tcontinue;\n \n-      for (loc = b->loc; loc != NULL; loc = loc->next)\n+      for (bp_location *loc : b->locations ())\n \t{\n \t  CORE_ADDR loc_addr = loc->address;\n \n@@ -8067,8 +8058,6 @@ breakpoint_hit_catch_solib (const struct bp_location *bl,\n \n   for (breakpoint *other : all_breakpoints ())\n   {\n-    struct bp_location *other_bl;\n-\n     if (other == bl->owner)\n       continue;\n \n@@ -8078,7 +8067,7 @@ breakpoint_hit_catch_solib (const struct bp_location *bl,\n     if (self->pspace != NULL && other->pspace != self->pspace)\n       continue;\n \n-    for (other_bl = other->loc; other_bl != NULL; other_bl = other_bl->next)\n+    for (bp_location *other_bl : other->locations ())\n       {\n \tif (other->ops->breakpoint_hit (other_bl, aspace, bp_addr, ws))\n \t  return 1;\n@@ -8426,11 +8415,10 @@ static int\n hw_breakpoint_used_count (void)\n {\n   int i = 0;\n-  struct bp_location *bl;\n \n   for (breakpoint *b : all_breakpoints ())\n     if (b->type == bp_hardware_breakpoint && breakpoint_enabled (b))\n-      for (bl = b->loc; bl; bl = bl->next)\n+      for (bp_location *bl : b->locations ())\n \t{\n \t  /* Special types of hardware breakpoints may use more than\n \t     one register.  */\n@@ -8447,12 +8435,11 @@ static int\n hw_watchpoint_use_count (struct breakpoint *b)\n {\n   int i = 0;\n-  struct bp_location *bl;\n \n   if (!breakpoint_enabled (b))\n     return 0;\n \n-  for (bl = b->loc; bl; bl = bl->next)\n+  for (bp_location *bl : b->locations ())\n     {\n       /* Special types of hardware watchpoints may use more than\n \t one register.  */\n@@ -8995,7 +8982,7 @@ init_breakpoint_sal (struct breakpoint *b, struct gdbarch *gdbarch,\n   /* The order of the locations is now stable.  Set the location\n      condition using the location's number.  */\n   int loc_num = 1;\n-  for (bp_location *loc = b->loc; loc != nullptr; loc = loc->next)\n+  for (bp_location *loc : b->locations ())\n     {\n       if (b->cond_string != nullptr)\n \tset_breakpoint_location_condition (b->cond_string, loc, b->number,\n@@ -11531,8 +11518,7 @@ clear_command (const char *arg, int from_tty)\n \t  /* Are we going to delete b?  */\n \t  if (b->type != bp_none && !is_watchpoint (b))\n \t    {\n-\t      struct bp_location *loc = b->loc;\n-\t      for (; loc; loc = loc->next)\n+\t      for (bp_location *loc : b->locations ())\n \t\t{\n \t\t  /* If the user specified file:line, don't allow a PC\n \t\t     match.  This matches historical gdb behavior.  */\n@@ -11718,7 +11704,6 @@ download_tracepoint_locations (void)\n \n   for (breakpoint *b : all_tracepoints ())\n     {\n-      struct bp_location *bl;\n       struct tracepoint *t;\n       int bp_location_downloaded = 0;\n \n@@ -11738,7 +11723,7 @@ download_tracepoint_locations (void)\n       if (can_download_tracepoint == TRIBOOL_FALSE)\n \tbreak;\n \n-      for (bl = b->loc; bl; bl = bl->next)\n+      for (bp_location *bl : b->locations ())\n \t{\n \t  /* In tracepoint, locations are _never_ duplicated, so\n \t     should_be_inserted is equivalent to\n@@ -11846,7 +11831,7 @@ force_breakpoint_reinsertion (struct bp_location *bl)\n static void\n update_global_location_list (enum ugll_insert_mode insert_mode)\n {\n-  struct bp_location **locp, *loc;\n+  struct bp_location **locp;\n   /* Last breakpoint location address that was marked for update.  */\n   CORE_ADDR last_addr = 0;\n   /* Last breakpoint location program space that was marked for update.  */\n@@ -11874,13 +11859,13 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n   bp_locations_count = 0;\n \n   for (breakpoint *b : all_breakpoints ())\n-    for (loc = b->loc; loc; loc = loc->next)\n+    for (bp_location *loc ATTRIBUTE_UNUSED : b->locations ())\n       bp_locations_count++;\n \n   bp_locations = XNEWVEC (struct bp_location *, bp_locations_count);\n   locp = bp_locations;\n   for (breakpoint *b : all_breakpoints ())\n-    for (loc = b->loc; loc; loc = loc->next)\n+    for (bp_location *loc : b->locations ())\n       *locp++ = loc;\n \n   /* See if we need to \"upgrade\" a software breakpoint to a hardware\n@@ -11891,7 +11876,7 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n        locp < bp_locations + bp_locations_count;\n        locp++)\n     {\n-      loc = *locp;\n+      bp_location *loc = *locp;\n       if (!loc->inserted && should_be_inserted (loc))\n \thandle_automatic_hardware_breakpoints (loc);\n     }\n@@ -12135,6 +12120,8 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n   wp_loc_first = NULL;\n   awp_loc_first = NULL;\n   rwp_loc_first = NULL;\n+\n+  bp_location *loc;\n   ALL_BP_LOCATIONS (loc, locp)\n     {\n       /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always\n@@ -12352,6 +12339,13 @@ breakpoint::~breakpoint ()\n   xfree (this->extra_string);\n }\n \n+/* See breakpoint.h.  */\n+\n+bp_locations_range breakpoint::locations ()\n+{\n+  return bp_locations_range (this->loc);\n+}\n+\n static struct bp_location *\n base_breakpoint_allocate_location (struct breakpoint *self)\n {\n@@ -13398,9 +13392,7 @@ delete_command (const char *arg, int from_tty)\n static int\n all_locations_are_pending (struct breakpoint *b, struct program_space *pspace)\n {\n-  struct bp_location *loc;\n-\n-  for (loc = b->loc; loc != NULL; loc = loc->next)\n+  for (bp_location *loc : b->locations ())\n     if ((pspace == NULL\n \t || loc->pspace == pspace)\n \t&& !loc->shlib_disabled\n@@ -13719,10 +13711,9 @@ update_breakpoint_locations (struct breakpoint *b,\n       {\n \tif ((!e->enabled || e->disabled_by_cond) && e->function_name)\n \t  {\n-\t    struct bp_location *l = b->loc;\n \t    if (have_ambiguous_names)\n \t      {\n-\t\tfor (; l; l = l->next)\n+\t\tfor (bp_location *l : b->locations ())\n \t\t  {\n \t\t    /* Ignore software vs hardware location type at\n \t\t       this point, because with \"set breakpoint\n@@ -13741,7 +13732,7 @@ update_breakpoint_locations (struct breakpoint *b,\n \t      }\n \t    else\n \t      {\n-\t\tfor (; l; l = l->next)\n+\t\tfor (bp_location *l : b->locations ())\n \t\t  if (l->function_name\n \t\t      && strcmp (e->function_name, l->function_name) == 0)\n \t\t    {\n@@ -14154,7 +14145,7 @@ find_location_by_number (int bp_num, int loc_num)\n     error (_(\"Bad breakpoint location number '%d'\"), loc_num);\n \n   int n = 0;\n-  for (bp_location *loc = b->loc; loc != NULL; loc = loc->next)\n+  for (bp_location *loc : b->locations ())\n     if (++n == loc_num)\n       return loc;\n \n@@ -14350,9 +14341,7 @@ disable_breakpoint (struct breakpoint *bpt)\n   if (target_supports_enable_disable_tracepoint ()\n       && current_trace_status ()->running && is_tracepoint (bpt))\n     {\n-      struct bp_location *location;\n-     \n-      for (location = bpt->loc; location; location = location->next)\n+      for (bp_location *location : bpt->locations ())\n \ttarget_disable_tracepoint (location);\n     }\n \n@@ -14471,9 +14460,7 @@ enable_breakpoint_disp (struct breakpoint *bpt, enum bpdisp disposition,\n   if (target_supports_enable_disable_tracepoint ()\n       && current_trace_status ()->running && is_tracepoint (bpt))\n     {\n-      struct bp_location *location;\n-\n-      for (location = bpt->loc; location; location = location->next)\n+      for (bp_location *location : bpt->locations ())\n \ttarget_enable_tracepoint (location);\n     }\n \n@@ -14568,9 +14555,7 @@ invalidate_bp_value_on_memory_change (struct inferior *inferior,\n \n \tif (wp->val_valid && wp->val != nullptr)\n \t  {\n-\t    struct bp_location *loc;\n-\n-\t    for (loc = bp->loc; loc != NULL; loc = loc->next)\n+\t    for (bp_location *loc : bp->locations ())\n \t      if (loc->loc_type == bp_loc_hardware_watchpoint\n \t\t  && loc->address + loc->length > addr\n \t\t  && addr + len > loc->address)\n@@ -14639,9 +14624,7 @@ breakpoint_has_location_inserted_here (struct breakpoint *bp,\n \t\t\t\t       const address_space *aspace,\n \t\t\t\t       CORE_ADDR pc)\n {\n-  struct bp_location *loc;\n-\n-  for (loc = bp->loc; loc != NULL; loc = loc->next)\n+  for (bp_location *loc : bp->locations ())\n     if (loc->inserted\n \t&& breakpoint_location_address_match (loc, aspace, pc))\n       return 1;\n@@ -15182,12 +15165,15 @@ save_breakpoints (const char *filename, int from_tty,\n        special, and not user visible.  */\n     if (!is_watchpoint (tp) && tp->loc && tp->loc->next)\n       {\n-\tstruct bp_location *loc;\n \tint n = 1;\n \n-\tfor (loc = tp->loc; loc != NULL; loc = loc->next, n++)\n-\t  if (!loc->enabled)\n-\t    fp.printf (\"disable $bpnum.%d\\n\", n);\n+\tfor (bp_location *loc : tp->locations ())\n+\t  {\n+\t    if (!loc->enabled)\n+\t      fp.printf (\"disable $bpnum.%d\\n\", n);\n+\n+\t    n++;\n+\t  }\n       }\n   }\n \n@@ -15330,14 +15316,12 @@ int\n pc_at_non_inline_function (const address_space *aspace, CORE_ADDR pc,\n \t\t\t   const struct target_waitstatus *ws)\n {\n-  struct bp_location *bl;\n-\n   for (breakpoint *b : all_breakpoints ())\n     {\n       if (!is_non_inline_function (b))\n \tcontinue;\n \n-      for (bl = b->loc; bl != NULL; bl = bl->next)\n+      for (bp_location *bl : b->locations ())\n \t{\n \t  if (!bl->shlib_disabled\n \t      && bpstat_check_location (bl, aspace, pc, ws))"
    },
    {
      "sha": "f31498a54eb812f6aab76b845d5f1ce29592668c",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -703,6 +703,10 @@ enum watchpoint_triggered\n \n extern bool target_exact_watchpoints;\n \n+/* bp_location linked list range.  */\n+\n+using bp_locations_range = next_adapter<bp_location>;\n+\n /* Note that the ->silent field is not currently used by any commands\n    (though the code is in there if it was to be, and set_raw_breakpoint\n    does set it to 0).  I implemented it because I thought it would be\n@@ -715,6 +719,9 @@ struct breakpoint\n {\n   virtual ~breakpoint ();\n \n+  /* Return a range of this breakpoint's locations.  */\n+  bp_locations_range locations ();\n+\n   /* Methods associated with this breakpoint.  */\n   const breakpoint_ops *ops = NULL;\n "
    },
    {
      "sha": "1de785b8de08c0e679fe51e2efe1fadff4e68571",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -783,7 +783,7 @@ jit_breakpoint_deleted (struct breakpoint *b)\n   if (b->type != bp_jit_event)\n     return;\n \n-  for (bp_location *iter = b->loc; iter != nullptr; iter = iter->next)\n+  for (bp_location *iter : b->locations ())\n     {\n       for (objfile *objf : iter->pspace->objfiles ())\n \t{"
    },
    {
      "sha": "9a6dd33634fd9ec0c8e1dc35a9b7bfafe4bb90ba",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -13521,15 +13521,14 @@ remote_target::get_tracepoint_status (struct breakpoint *bp,\n {\n   struct remote_state *rs = get_remote_state ();\n   char *reply;\n-  struct bp_location *loc;\n   struct tracepoint *tp = (struct tracepoint *) bp;\n   size_t size = get_remote_packet_size ();\n \n   if (tp)\n     {\n       tp->hit_count = 0;\n       tp->traceframe_usage = 0;\n-      for (loc = tp->loc; loc; loc = loc->next)\n+      for (bp_location *loc : tp->locations ())\n \t{\n \t  /* If the tracepoint was never downloaded, don't go asking for\n \t     any status.  */"
    },
    {
      "sha": "2642e1ad2fdb9c88d9494a0cc2cf454a24f2a206",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -2019,15 +2019,13 @@ svr4_handle_solib_event (void)\n static bool\n svr4_update_solib_event_breakpoint (struct breakpoint *b)\n {\n-  struct bp_location *loc;\n-\n   if (b->type != bp_shlib_event)\n     {\n       /* Continue iterating.  */\n       return false;\n     }\n \n-  for (loc = b->loc; loc != NULL; loc = loc->next)\n+  for (bp_location *loc : b->locations ())\n     {\n       struct svr4_info *info;\n       struct probe_and_action *pa;"
    },
    {
      "sha": "cb8b4cbd0728bed3af74be73af747dbe468786e0",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 15,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -636,7 +636,6 @@ validate_actionline (const char *line, struct breakpoint *b)\n   struct cmd_list_element *c;\n   const char *tmp_p;\n   const char *p;\n-  struct bp_location *loc;\n   struct tracepoint *t = (struct tracepoint *) b;\n \n   /* If EOF is typed, *line is NULL.  */\n@@ -682,7 +681,7 @@ validate_actionline (const char *line, struct breakpoint *b)\n \t      /* else fall thru, treat p as an expression and parse it!  */\n \t    }\n \t  tmp_p = p;\n-\t  for (loc = t->loc; loc; loc = loc->next)\n+\t  for (bp_location *loc : t->locations ())\n \t    {\n \t      p = tmp_p;\n \t      expression_up exp = parse_exp_1 (&p, loc->address,\n@@ -732,7 +731,7 @@ validate_actionline (const char *line, struct breakpoint *b)\n \t  p = skip_spaces (p);\n \n \t  tmp_p = p;\n-\t  for (loc = t->loc; loc; loc = loc->next)\n+\t  for (bp_location *loc : t->locations ())\n \t    {\n \t      p = tmp_p;\n \n@@ -1565,9 +1564,7 @@ process_tracepoint_on_disconnect (void)\n \t}\n       else\n \t{\n-\t  struct bp_location *loc1;\n-\n-\t  for (loc1 = b->loc; loc1; loc1 = loc1->next)\n+\t  for (bp_location *loc1 : b->locations ())\n \t    {\n \t      if (loc1->shlib_disabled)\n \t\t{\n@@ -1643,11 +1640,10 @@ start_tracing (const char *notes)\n   for (breakpoint *b : tracepoint_range)\n     {\n       struct tracepoint *t = (struct tracepoint *) b;\n-      struct bp_location *loc;\n       int bp_location_downloaded = 0;\n \n       /* Clear `inserted' flag.  */\n-      for (loc = b->loc; loc; loc = loc->next)\n+      for (bp_location *loc : b->locations ())\n \tloc->inserted = 0;\n \n       if ((b->type == bp_fast_tracepoint\n@@ -1657,7 +1653,7 @@ start_tracing (const char *notes)\n \n       t->number_on_target = 0;\n \n-      for (loc = b->loc; loc; loc = loc->next)\n+      for (bp_location *loc : b->locations ())\n \t{\n \t  /* Since tracepoint locations are never duplicated, `inserted'\n \t     flag should be zero.  */\n@@ -1671,7 +1667,7 @@ start_tracing (const char *notes)\n \n       t->number_on_target = b->number;\n \n-      for (loc = b->loc; loc; loc = loc->next)\n+      for (bp_location *loc : b->locations ())\n \tif (loc->probe.prob != NULL)\n \t  loc->probe.prob->set_semaphore (loc->probe.objfile,\n \t\t\t\t\t  loc->gdbarch);\n@@ -1750,14 +1746,12 @@ stop_tracing (const char *note)\n \n   for (breakpoint *t : all_tracepoints ())\n     {\n-      struct bp_location *loc;\n-\n       if ((t->type == bp_fast_tracepoint\n \t   ? !may_insert_fast_tracepoints\n \t   : !may_insert_tracepoints))\n \tcontinue;\n \n-      for (loc = t->loc; loc; loc = loc->next)\n+      for (bp_location *loc : t->locations ())\n \t{\n \t  /* GDB can be totally absent in some disconnected trace scenarios,\n \t     but we don't really care if this semaphore goes out of sync.\n@@ -2763,7 +2757,6 @@ struct bp_location *\n get_traceframe_location (int *stepping_frame_p)\n {\n   struct tracepoint *t;\n-  struct bp_location *tloc;\n   struct regcache *regcache;\n \n   if (tracepoint_number == -1)\n@@ -2784,7 +2777,7 @@ get_traceframe_location (int *stepping_frame_p)\n      locations, assume it is a direct hit rather than a while-stepping\n      frame.  (FIXME this is not reliable, should record each frame's\n      type.)  */\n-  for (tloc = t->loc; tloc; tloc = tloc->next)\n+  for (bp_location *tloc : t->locations ())\n     if (tloc->address == regcache_read_pc (regcache))\n       {\n \t*stepping_frame_p = 0;"
    },
    {
      "sha": "738f691564850cb3dbde65fef3042d52d153fd94",
      "filename": "gdb/tui/tui-winsource.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/tui/tui-winsource.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40cb8ca5396e563968fa8465a10173e7c2fd9d84/gdb/tui/tui-winsource.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-winsource.c?ref=40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "patch": "@@ -459,12 +459,10 @@ tui_source_window_base::update_breakpoint_info\n       tui_bp_flags mode = 0;\n       iterate_over_breakpoints ([&] (breakpoint *bp) -> bool\n \t{\n-\t  struct bp_location *loc;\n-\n \t  if (bp == being_deleted)\n \t    return false;\n \n-\t  for (loc = bp->loc; loc != NULL; loc = loc->next)\n+\t  for (bp_location *loc : bp->locations ())\n \t    {\n \t      if (location_matches_p (loc, i))\n \t\t{"
    }
  ]
}