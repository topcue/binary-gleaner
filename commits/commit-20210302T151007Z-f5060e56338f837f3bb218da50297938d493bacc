{
  "sha": "f5060e56338f837f3bb218da50297938d493bacc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjUwNjBlNTYzMzhmODM3ZjNiYjIxOGRhNTAyOTc5MzhkNDkzYmFjYw==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-02T15:10:05Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-02T15:10:07Z"
    },
    "message": "libctf: add a deduplicator-specific type mapping table\n\nWhen CTF linking is done, the linker has to track the association\nbetween types in the inputs and types in the outputs.  The deduplicator\ndoes this via the cd_output_emission_hashes, which maps from hashes of\ntypes (valid in both the input and output) to the IDs of types in the\nspecific dict in which the cd_emission_hashes is held.  However, the\nnondeduplicating linker and ctf_add_type used a different mechanism, a\ndedicated hashtab stored in the ctf_link_type_mapping, populated via\nctf_add_type_mapping and queried via the ctf_type_mapping function.  To\nallow the same functions to be used for variable and symbol population\nin both the deduplicating and nondeduplicating linker, the deduplicator\ncarefully transferred all its input->output mappings into this hashtab\nbefore returning.\n\nThis is *expensive*. The number of entries in this hashtab scales as the\nnumber of input types, and unlike the hashing machinery the type mapping\nmachinery (the only other thing which scales that way) has not been much\noptimized.\n\nNow the nondeduplicating linker is gone, we can throw this out, move\nthe existing type mapping machinery to ctf-create.c and dedicate it to\nctf_add_type alone, and add a new function ctf_dedup_type_mapping which\nuses the deduplicator's built-in knowledge of type mappings directly,\nwithout requiring an expensive repopulation phase.\n\nThis speeds up a test link of nouveau.ko (a good worst-case candidate\nwith a lot of types in each of a lot of input files) from 9.11s to 7.15s\nin my testing, a speedup of over 20%.\n\nlibctf/ChangeLog\n2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h (ctf_dict_t) <ctf_link_type_mapping>: No longer used\n\tby the nondeduplicating linker.\n\t(ctf_add_type_mapping): Removed, now static.\n\t(ctf_type_mapping): Likewise.\n\t(ctf_dedup_type_mapping): New.\n\t(ctf_dedup_t) <cd_input_nums>: New.\n\t* ctf-dedup.c (ctf_dedup_init): Populate it.\n\t(ctf_dedup_fini): Free it again.  Emphasise that this has to be\n\tthe last thing called.\n\t(ctf_dedup): Populate it.\n\t(ctf_dedup_populate_type_mapping): Removed.\n\t(ctf_dedup_populate_type_mappings): Likewise.\n\t(ctf_dedup_emit): No longer call it.  No longer call\n\tctf_dedup_fini either.\n\t(ctf_dedup_type_mapping): New.\n\t* ctf-link.c (ctf_unnamed_cuname): New.\n\t(ctf_create_per_cu): Arguments must be non-null now.\n\t(ctf_in_member_cb_arg): Removed.\n\t(ctf_link): No longer populate it.  No longer discard the\n\tmapping table.\n\t(ctf_link_deduplicating_one_symtypetab): Use\n\tctf_dedup_type_mapping, not ctf_type_mapping.  Use\n\tctf_unnamed_cuname.\n\t(ctf_link_one_variable): Likewise.  Pass in args individually: no\n\tlonger a ctf_variable_iter callback.\n\t(empty_link_type_mapping): Removed.\n\t(ctf_link_deduplicating_variables): Use ctf_variable_next, not\n\tctf_variable_iter.  No longer pack arguments to\n\tctf_link_one_variable into a struct.\n\t(ctf_link_deduplicating_per_cu): Call ctf_dedup_fini once\n\tall link phases are done.\n\t(ctf_link_deduplicating): Likewise.\n\t(ctf_link_intern_extern_string): Improve comment.\n\t(ctf_add_type_mapping): Migrate...\n\t(ctf_type_mapping): ... these functions...\n\t* ctf-create.c (ctf_add_type_mapping): ... here...\n\t(ctf_type_mapping): ... and make static, for the sole use of\n\tctf_add_type.",
    "tree": {
      "sha": "e80d03f9496c0fb98bb6b89d69bbd9f3f9076aa9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e80d03f9496c0fb98bb6b89d69bbd9f3f9076aa9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f5060e56338f837f3bb218da50297938d493bacc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5060e56338f837f3bb218da50297938d493bacc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f5060e56338f837f3bb218da50297938d493bacc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5060e56338f837f3bb218da50297938d493bacc/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "478c04a55ee59bf7e7f104c36a08253d15863610",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/478c04a55ee59bf7e7f104c36a08253d15863610",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/478c04a55ee59bf7e7f104c36a08253d15863610"
    }
  ],
  "stats": {
    "total": 672,
    "additions": 344,
    "deletions": 328
  },
  "files": [
    {
      "sha": "97069191c48b6c37eb5e1f10c402cece670c8cef",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 41,
      "deletions": 0,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5060e56338f837f3bb218da50297938d493bacc/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5060e56338f837f3bb218da50297938d493bacc/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=f5060e56338f837f3bb218da50297938d493bacc",
      "patch": "@@ -1,3 +1,44 @@\n+2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_dict_t) <ctf_link_type_mapping>: No longer used\n+\tby the nondeduplicating linker.\n+\t(ctf_add_type_mapping): Removed, now static.\n+\t(ctf_type_mapping): Likewise.\n+\t(ctf_dedup_type_mapping): New.\n+\t(ctf_dedup_t) <cd_input_nums>: New.\n+\t* ctf-dedup.c (ctf_dedup_init): Populate it.\n+\t(ctf_dedup_fini): Free it again.  Emphasise that this has to be\n+\tthe last thing called.\n+\t(ctf_dedup): Populate it.\n+\t(ctf_dedup_populate_type_mapping): Removed.\n+\t(ctf_dedup_populate_type_mappings): Likewise.\n+\t(ctf_dedup_emit): No longer call it.  No longer call\n+\tctf_dedup_fini either.\n+\t(ctf_dedup_type_mapping): New.\n+\t* ctf-link.c (ctf_unnamed_cuname): New.\n+\t(ctf_create_per_cu): Arguments must be non-null now.\n+\t(ctf_in_member_cb_arg): Removed.\n+\t(ctf_link): No longer populate it.  No longer discard the\n+\tmapping table.\n+\t(ctf_link_deduplicating_one_symtypetab): Use\n+\tctf_dedup_type_mapping, not ctf_type_mapping.  Use\n+\tctf_unnamed_cuname.\n+\t(ctf_link_one_variable): Likewise.  Pass in args individually: no\n+\tlonger a ctf_variable_iter callback.\n+\t(empty_link_type_mapping): Removed.\n+\t(ctf_link_deduplicating_variables): Use ctf_variable_next, not\n+\tctf_variable_iter.  No longer pack arguments to\n+\tctf_link_one_variable into a struct.\n+\t(ctf_link_deduplicating_per_cu): Call ctf_dedup_fini once\n+\tall link phases are done.\n+\t(ctf_link_deduplicating): Likewise.\n+\t(ctf_link_intern_extern_string): Improve comment.\n+\t(ctf_add_type_mapping): Migrate...\n+\t(ctf_type_mapping): ... these functions...\n+\t* ctf-create.c (ctf_add_type_mapping): ... here...\n+\t(ctf_type_mapping): ... and make static, for the sole use of\n+\tctf_add_type.\n+\n 2021-03-02  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-link.c (ctf_link_one_variable): Remove reference to"
    },
    {
      "sha": "d417922e7fde5f6db8fd950f51d2d215b58bad38",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 95,
      "deletions": 0,
      "changes": 95,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5060e56338f837f3bb218da50297938d493bacc/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5060e56338f837f3bb218da50297938d493bacc/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=f5060e56338f837f3bb218da50297938d493bacc",
      "patch": "@@ -2471,6 +2471,101 @@ membadd (const char *name, ctf_id_t type, unsigned long offset, void *arg)\n   return 0;\n }\n \n+/* Record the correspondence between a source and ctf_add_type()-added\n+   destination type: both types are translated into parent type IDs if need be,\n+   so they relate to the actual dictionary they are in.  Outside controlled\n+   circumstances (like linking) it is probably not useful to do more than\n+   compare these pointers, since there is nothing stopping the user closing the\n+   source dict whenever they want to.\n+\n+   Our OOM handling here is just to not do anything, because this is called deep\n+   enough in the call stack that doing anything useful is painfully difficult:\n+   the worst consequence if we do OOM is a bit of type duplication anyway.  */\n+\n+static void\n+ctf_add_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type,\n+\t\t      ctf_dict_t *dst_fp, ctf_id_t dst_type)\n+{\n+  if (LCTF_TYPE_ISPARENT (src_fp, src_type) && src_fp->ctf_parent)\n+    src_fp = src_fp->ctf_parent;\n+\n+  src_type = LCTF_TYPE_TO_INDEX(src_fp, src_type);\n+\n+  if (LCTF_TYPE_ISPARENT (dst_fp, dst_type) && dst_fp->ctf_parent)\n+    dst_fp = dst_fp->ctf_parent;\n+\n+  dst_type = LCTF_TYPE_TO_INDEX(dst_fp, dst_type);\n+\n+  if (dst_fp->ctf_link_type_mapping == NULL)\n+    {\n+      ctf_hash_fun f = ctf_hash_type_key;\n+      ctf_hash_eq_fun e = ctf_hash_eq_type_key;\n+\n+      if ((dst_fp->ctf_link_type_mapping = ctf_dynhash_create (f, e, free,\n+\t\t\t\t\t\t\t       NULL)) == NULL)\n+\treturn;\n+    }\n+\n+  ctf_link_type_key_t *key;\n+  key = calloc (1, sizeof (struct ctf_link_type_key));\n+  if (!key)\n+    return;\n+\n+  key->cltk_fp = src_fp;\n+  key->cltk_idx = src_type;\n+\n+  /* No OOM checking needed, because if this doesn't work the worst we'll do is\n+     add a few more duplicate types (which will probably run out of memory\n+     anyway).  */\n+  ctf_dynhash_insert (dst_fp->ctf_link_type_mapping, key,\n+\t\t      (void *) (uintptr_t) dst_type);\n+}\n+\n+/* Look up a type mapping: return 0 if none.  The DST_FP is modified to point to\n+   the parent if need be.  The ID returned is from the dst_fp's perspective.  */\n+static ctf_id_t\n+ctf_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type, ctf_dict_t **dst_fp)\n+{\n+  ctf_link_type_key_t key;\n+  ctf_dict_t *target_fp = *dst_fp;\n+  ctf_id_t dst_type = 0;\n+\n+  if (LCTF_TYPE_ISPARENT (src_fp, src_type) && src_fp->ctf_parent)\n+    src_fp = src_fp->ctf_parent;\n+\n+  src_type = LCTF_TYPE_TO_INDEX(src_fp, src_type);\n+  key.cltk_fp = src_fp;\n+  key.cltk_idx = src_type;\n+\n+  if (target_fp->ctf_link_type_mapping)\n+    dst_type = (uintptr_t) ctf_dynhash_lookup (target_fp->ctf_link_type_mapping,\n+\t\t\t\t\t       &key);\n+\n+  if (dst_type != 0)\n+    {\n+      dst_type = LCTF_INDEX_TO_TYPE (target_fp, dst_type,\n+\t\t\t\t     target_fp->ctf_parent != NULL);\n+      *dst_fp = target_fp;\n+      return dst_type;\n+    }\n+\n+  if (target_fp->ctf_parent)\n+    target_fp = target_fp->ctf_parent;\n+  else\n+    return 0;\n+\n+  if (target_fp->ctf_link_type_mapping)\n+    dst_type = (uintptr_t) ctf_dynhash_lookup (target_fp->ctf_link_type_mapping,\n+\t\t\t\t\t       &key);\n+\n+  if (dst_type)\n+    dst_type = LCTF_INDEX_TO_TYPE (target_fp, dst_type,\n+\t\t\t\t   target_fp->ctf_parent != NULL);\n+\n+  *dst_fp = target_fp;\n+  return dst_type;\n+}\n+\n /* The ctf_add_type routine is used to copy a type from a source CTF dictionary\n    to a dynamic destination dictionary.  This routine operates recursively by\n    following the source type's links and embedded member types.  If the"
    },
    {
      "sha": "50da4ac5c1194dafe49365c1adc98c91869d1a3d",
      "filename": "libctf/ctf-dedup.c",
      "status": "modified",
      "additions": 97,
      "deletions": 101,
      "changes": 198,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5060e56338f837f3bb218da50297938d493bacc/libctf/ctf-dedup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5060e56338f837f3bb218da50297938d493bacc/libctf/ctf-dedup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dedup.c?ref=f5060e56338f837f3bb218da50297938d493bacc",
      "patch": "@@ -1642,6 +1642,12 @@ ctf_dedup_init (ctf_dict_t *fp)\n     goto oom;\n #endif\n \n+  if ((d->cd_input_nums\n+       = ctf_dynhash_create (ctf_hash_integer,\n+\t\t\t     ctf_hash_eq_integer,\n+\t\t\t     NULL, NULL)) == NULL)\n+    goto oom;\n+\n   if ((d->cd_emission_struct_members\n        = ctf_dynhash_create (ctf_hash_integer,\n \t\t\t     ctf_hash_eq_integer,\n@@ -1661,6 +1667,8 @@ ctf_dedup_init (ctf_dict_t *fp)\n   return ctf_set_errno (fp, ENOMEM);\n }\n \n+/* No ctf_dedup calls are allowed after this call other than starting a new\n+   deduplication via ctf_dedup (not even ctf_dedup_type_mapping lookups).  */\n void\n ctf_dedup_fini (ctf_dict_t *fp, ctf_dict_t **outputs, uint32_t noutputs)\n {\n@@ -1682,6 +1690,7 @@ ctf_dedup_fini (ctf_dict_t *fp, ctf_dict_t **outputs, uint32_t noutputs)\n #ifdef ENABLE_LIBCTF_HASH_DEBUGGING\n   ctf_dynhash_destroy (d->cd_output_mapping_guard);\n #endif\n+  ctf_dynhash_destroy (d->cd_input_nums);\n   ctf_dynhash_destroy (d->cd_emission_struct_members);\n   ctf_dynset_destroy (d->cd_conflicting_types);\n \n@@ -1876,12 +1885,22 @@ ctf_dedup (ctf_dict_t *output, ctf_dict_t **inputs, uint32_t ninputs,\n   size_t i;\n   ctf_next_t *it = NULL;\n \n-  for (i = 0; i < ninputs; i++)\n-    ctf_dprintf (\"Input %i: %s\\n\", (int) i, ctf_link_input_name (inputs[i]));\n-\n   if (ctf_dedup_init (output) < 0)\n     return -1; \t\t\t\t\t/* errno is set for us.  */\n \n+  for (i = 0; i < ninputs; i++)\n+    {\n+      ctf_dprintf (\"Input %i: %s\\n\", (int) i, ctf_link_input_name (inputs[i]));\n+      if (ctf_dynhash_insert (d->cd_input_nums, inputs[i],\n+\t\t\t      (void *) (uintptr_t) i) < 0)\n+\t{\n+\t  ctf_set_errno (output, errno);\n+\t  ctf_err_warn (output, 0, errno, _(\"ctf_dedup: cannot initialize: %s\\n\"),\n+\t\t\tctf_errmsg (errno));\n+\t  goto err;\n+\t}\n+    }\n+\n   /* Some flags do not apply when CU-mapping: this is not a duplicated link,\n      because there is only one output and we really don't want to end up marking\n      all nonconflicting but appears-only-once types as conflicting (which in the\n@@ -1937,6 +1956,10 @@ ctf_dedup (ctf_dict_t *output, ctf_dict_t **inputs, uint32_t ninputs,\n \treturn -1;\t\t\t\t/* errno is set for us.  */\n     }\n   return 0;\n+\n+ err:\n+  ctf_dedup_fini (output, NULL, 0);\n+  return -1;\n }\n \n static int\n@@ -3003,100 +3026,6 @@ ctf_dedup_emit_struct_members (ctf_dict_t *output, ctf_dict_t **inputs,\n   return ctf_set_errno (output, err);\n }\n \n-/* Populate the type mapping used by the types in one FP (which must be an input\n-   dict containing a non-null cd_output resulting from a ctf_dedup_emit_type\n-   walk).  */\n-static int\n-ctf_dedup_populate_type_mapping (ctf_dict_t *shared, ctf_dict_t *fp,\n-\t\t\t\t ctf_dict_t **inputs)\n-{\n-  ctf_dedup_t *d = &shared->ctf_dedup;\n-  ctf_dict_t *output = fp->ctf_dedup.cd_output;\n-  const void *k, *v;\n-  ctf_next_t *i = NULL;\n-  int err;\n-\n-  /* The shared dict (the output) stores its types in the fp itself, not in a\n-     separate cd_output dict.  */\n-  if (shared == fp)\n-    output = fp;\n-\n-  /* There may be no types to emit at all, or all the types in this TU may be\n-     shared.  */\n-  if (!output || !output->ctf_dedup.cd_output_emission_hashes)\n-    return 0;\n-\n-  while ((err = ctf_dynhash_cnext (output->ctf_dedup.cd_output_emission_hashes,\n-\t\t\t\t  &i, &k, &v)) == 0)\n-    {\n-      const char *hval = (const char *) k;\n-      ctf_id_t id_out = (ctf_id_t) (uintptr_t) v;\n-      ctf_next_t *j = NULL;\n-      ctf_dynset_t *type_ids;\n-      const void *id;\n-\n-      type_ids = ctf_dynhash_lookup (d->cd_output_mapping, hval);\n-      if (!ctf_assert (shared, type_ids))\n-\treturn -1;\n-#ifdef ENABLE_LIBCTF_HASH_DEBUGGING\n-      ctf_dprintf (\"Traversing emission hash: hval %s\\n\", hval);\n-#endif\n-\n-      while ((err = ctf_dynset_cnext (type_ids, &j, &id)) == 0)\n-\t{\n-\t  ctf_dict_t *input = inputs[CTF_DEDUP_GID_TO_INPUT (id)];\n-\t  ctf_id_t id_in = CTF_DEDUP_GID_TO_TYPE (id);\n-\n-#ifdef ENABLE_LIBCTF_HASH_DEBUGGING\n-\t  ctf_dprintf (\"Adding mapping from %i/%lx to %lx\\n\",\n-\t\t       CTF_DEDUP_GID_TO_INPUT (id), id_in, id_out);\n-#endif\n-\t  ctf_add_type_mapping (input, id_in, output, id_out);\n-\t}\n-      if (err != ECTF_NEXT_END)\n-\t{\n-\t  ctf_next_destroy (i);\n-\t  goto err;\n-\t}\n-    }\n-  if (err != ECTF_NEXT_END)\n-    goto err;\n-\n-  return 0;\n-\n- err:\n-  ctf_err_warn (shared, 0, err, _(\"iteration error populating the type mapping\"));\n-  return ctf_set_errno (shared, err);\n-}\n-\n-/* Populate the type mapping machinery used by the rest of the linker,\n-   by ctf_add_type, etc.  */\n-static int\n-ctf_dedup_populate_type_mappings (ctf_dict_t *output, ctf_dict_t **inputs,\n-\t\t\t\t  uint32_t ninputs)\n-{\n-  size_t i;\n-\n-  if (ctf_dedup_populate_type_mapping (output, output, inputs) < 0)\n-    {\n-      ctf_err_warn (output, 0, 0, _(\"cannot populate type mappings for shared \"\n-\t\t\t\t    \"CTF dict\"));\n-      return -1;\t\t\t\t/* errno is set for us.  */\n-    }\n-\n-  for (i = 0; i < ninputs; i++)\n-    {\n-      if (ctf_dedup_populate_type_mapping (output, inputs[i], inputs) < 0)\n-\t{\n-\t  ctf_err_warn (output, 0, ctf_errno (inputs[i]),\n-\t\t\t_(\"cannot populate type mappings for per-CU CTF dict\"));\n-\t  return ctf_set_errno (output, ctf_errno (inputs[i]));\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n /* Emit deduplicated types into the outputs.  The shared type repository is\n    OUTPUT, on which the ctf_dedup function must have already been called.  The\n    PARENTS array contains the INPUTS index of the parent dict for every child\n@@ -3127,9 +3056,6 @@ ctf_dedup_emit (ctf_dict_t *output, ctf_dict_t **inputs, uint32_t ninputs,\n   if (ctf_dedup_emit_struct_members (output, inputs, ninputs, parents) < 0)\n     return NULL;\t\t\t\t/* errno is set for us.  */\n \n-  if (ctf_dedup_populate_type_mappings (output, inputs, ninputs) < 0)\n-    return NULL;\t\t\t\t/* errno is set for us.  */\n-\n   for (i = 0; i < ninputs; i++)\n     {\n       if (inputs[i]->ctf_dedup.cd_output)\n@@ -3163,6 +3089,76 @@ ctf_dedup_emit (ctf_dict_t *output, ctf_dict_t **inputs, uint32_t ninputs,\n \t}\n     }\n \n-  ctf_dedup_fini (output, outputs, num_outputs);\n   return outputs;\n }\n+\n+/* Determine what type SRC_FP / SRC_TYPE was emitted as in the FP, which\n+   must be the shared dict or have it as a parent: return 0 if none.  The SRC_FP\n+   must be a past input to ctf_dedup.  */\n+\n+ctf_id_t\n+ctf_dedup_type_mapping (ctf_dict_t *fp, ctf_dict_t *src_fp, ctf_id_t src_type)\n+{\n+  ctf_dict_t *output = NULL;\n+  ctf_dedup_t *d;\n+  int input_num;\n+  void *num_ptr;\n+  void *type_ptr;\n+  int found;\n+  const char *hval;\n+\n+  /* It is an error (an internal error in the caller, in ctf-link.c) to call\n+     this with an FP that is not a per-CU output or shared output dict, or with\n+     a SRC_FP that was not passed to ctf_dedup as an input; it is an internal\n+     error in ctf-dedup for the type passed not to have been hashed, though if\n+     the src_fp is a child dict and the type is not a child type, it will have\n+     been hashed under the GID corresponding to the parent.  */\n+\n+  if (fp->ctf_dedup.cd_type_hashes != NULL)\n+    output = fp;\n+  else if (fp->ctf_parent && fp->ctf_parent->ctf_dedup.cd_type_hashes != NULL)\n+    output = fp->ctf_parent;\n+  else\n+    {\n+      ctf_set_errno (fp, ECTF_INTERNAL);\n+      ctf_err_warn (fp, 0, ECTF_INTERNAL,\n+\t\t    _(\"dict %p passed to ctf_dedup_type_mapping is not a \"\n+\t\t      \"deduplicated output\"), (void *) fp);\n+      return CTF_ERR;\n+    }\n+\n+  if (src_fp->ctf_parent && ctf_type_isparent (src_fp, src_type))\n+    src_fp = src_fp->ctf_parent;\n+\n+  d = &output->ctf_dedup;\n+\n+  found = ctf_dynhash_lookup_kv (d->cd_input_nums, src_fp, NULL, &num_ptr);\n+  if (!ctf_assert (output, found != 0))\n+    return CTF_ERR;\t\t\t\t/* errno is set for us.  */\n+  input_num = (uintptr_t) num_ptr;\n+\n+  hval = ctf_dynhash_lookup (d->cd_type_hashes,\n+\t\t\t     CTF_DEDUP_GID (output, input_num, src_type));\n+\n+  if (!ctf_assert (output, hval != NULL))\n+    return CTF_ERR;\t\t\t\t/* errno is set for us.  */\n+\n+  /* The emission hashes may be unset if this dict was created after\n+     deduplication to house variables or other things that would conflict if\n+     stored in the shared dict.  */\n+  if (fp->ctf_dedup.cd_output_emission_hashes)\n+    if (ctf_dynhash_lookup_kv (fp->ctf_dedup.cd_output_emission_hashes, hval,\n+\t\t\t       NULL, &type_ptr))\n+      return (ctf_id_t) (uintptr_t) type_ptr;\n+\n+  if (fp->ctf_parent)\n+    {\n+      ctf_dict_t *pfp = fp->ctf_parent;\n+      if (pfp->ctf_dedup.cd_output_emission_hashes)\n+\tif (ctf_dynhash_lookup_kv (pfp->ctf_dedup.cd_output_emission_hashes,\n+\t\t\t\t   hval, NULL, &type_ptr))\n+\t  return (ctf_id_t) (uintptr_t) type_ptr;\n+    }\n+\n+  return 0;\n+}"
    },
    {
      "sha": "78a41ff49321ad53c89648d2b6c223baee76cdd3",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 9,
      "deletions": 8,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5060e56338f837f3bb218da50297938d493bacc/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5060e56338f837f3bb218da50297938d493bacc/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=f5060e56338f837f3bb218da50297938d493bacc",
      "patch": "@@ -347,6 +347,11 @@ typedef struct ctf_dedup\n   /* A set (a hash) of hash values of conflicting types.  */\n   ctf_dynset_t *cd_conflicting_types;\n \n+  /* A hash mapping fp *'s of inputs to their input_nums.  Used only by\n+     functions outside the core ctf_dedup / ctf_dedup_emit machinery which do\n+     not take an inputs array.  */\n+  ctf_dynhash_t *cd_input_nums;\n+\n   /* Maps type hashes to ctf_id_t's in this dictionary.  Populated only at\n      emission time, in the dictionary where emission is taking place.  */\n   ctf_dynhash_t *cd_output_emission_hashes;\n@@ -455,9 +460,8 @@ struct ctf_dict\n   ctf_dynhash_t *ctf_link_inputs; /* Inputs to this link.  */\n   ctf_dynhash_t *ctf_link_outputs; /* Additional outputs from this link.  */\n \n-  /* Map input types to output types: populated in each output dict.\n-     Key is a ctf_link_type_key_t: value is a type ID.  Used by\n-     nondeduplicating links and ad-hoc ctf_add_type calls only.  */\n+  /* Map input types to output types for ctf_add_type.  Key is a\n+     ctf_link_type_key_t: value is a type ID.  */\n   ctf_dynhash_t *ctf_link_type_mapping;\n \n   /* Map input CU names to output CTF dict names: populated in the top-level\n@@ -703,18 +707,15 @@ extern ctf_id_t ctf_add_encoded (ctf_dict_t *, uint32_t, const char *,\n extern ctf_id_t ctf_add_reftype (ctf_dict_t *, uint32_t, ctf_id_t,\n \t\t\t\t uint32_t kind);\n \n-extern void ctf_add_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type,\n-\t\t\t\t  ctf_dict_t *dst_fp, ctf_id_t dst_type);\n-extern ctf_id_t ctf_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type,\n-\t\t\t\t  ctf_dict_t **dst_fp);\n-\n extern int ctf_dedup_atoms_init (ctf_dict_t *);\n extern int ctf_dedup (ctf_dict_t *, ctf_dict_t **, uint32_t ninputs,\n \t\t      uint32_t *parents, int cu_mapped);\n extern void ctf_dedup_fini (ctf_dict_t *, ctf_dict_t **, uint32_t);\n extern ctf_dict_t **ctf_dedup_emit (ctf_dict_t *, ctf_dict_t **,\n \t\t\t\t    uint32_t ninputs, uint32_t *parents,\n \t\t\t\t    uint32_t *noutputs, int cu_mapped);\n+extern ctf_id_t ctf_dedup_type_mapping (ctf_dict_t *fp, ctf_dict_t *src_fp,\n+\t\t\t\t\tctf_id_t src_type);\n \n extern void ctf_decl_init (ctf_decl_t *);\n extern void ctf_decl_fini (ctf_decl_t *);"
    },
    {
      "sha": "c0b0916f53650086e63fdfa2f85166e937b5ad48",
      "filename": "libctf/ctf-link.c",
      "status": "modified",
      "additions": 102,
      "deletions": 219,
      "changes": 321,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5060e56338f837f3bb218da50297938d493bacc/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5060e56338f837f3bb218da50297938d493bacc/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=f5060e56338f837f3bb218da50297938d493bacc",
      "patch": "@@ -24,118 +24,18 @@\n #pragma weak ctf_open\n #endif\n \n-/* Type tracking machinery.  */\n-\n-/* Record the correspondence between a source and ctf_add_type()-added\n-   destination type: both types are translated into parent type IDs if need be,\n-   so they relate to the actual dictionary they are in.  Outside controlled\n-   circumstances (like linking) it is probably not useful to do more than\n-   compare these pointers, since there is nothing stopping the user closing the\n-   source dict whenever they want to.\n-\n-   Our OOM handling here is just to not do anything, because this is called deep\n-   enough in the call stack that doing anything useful is painfully difficult:\n-   the worst consequence if we do OOM is a bit of type duplication anyway.  */\n-\n-void\n-ctf_add_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type,\n-\t\t      ctf_dict_t *dst_fp, ctf_id_t dst_type)\n-{\n-  if (LCTF_TYPE_ISPARENT (src_fp, src_type) && src_fp->ctf_parent)\n-    src_fp = src_fp->ctf_parent;\n-\n-  src_type = LCTF_TYPE_TO_INDEX(src_fp, src_type);\n-\n-  if (LCTF_TYPE_ISPARENT (dst_fp, dst_type) && dst_fp->ctf_parent)\n-    dst_fp = dst_fp->ctf_parent;\n-\n-  dst_type = LCTF_TYPE_TO_INDEX(dst_fp, dst_type);\n-\n-  if (dst_fp->ctf_link_type_mapping == NULL)\n-    {\n-      ctf_hash_fun f = ctf_hash_type_key;\n-      ctf_hash_eq_fun e = ctf_hash_eq_type_key;\n-\n-      if ((dst_fp->ctf_link_type_mapping = ctf_dynhash_create (f, e, free,\n-\t\t\t\t\t\t\t       NULL)) == NULL)\n-\treturn;\n-    }\n-\n-  ctf_link_type_key_t *key;\n-  key = calloc (1, sizeof (struct ctf_link_type_key));\n-  if (!key)\n-    return;\n-\n-  key->cltk_fp = src_fp;\n-  key->cltk_idx = src_type;\n-\n-  /* No OOM checking needed, because if this doesn't work the worst we'll do is\n-     add a few more duplicate types (which will probably run out of memory\n-     anyway).  */\n-  ctf_dynhash_insert (dst_fp->ctf_link_type_mapping, key,\n-\t\t      (void *) (uintptr_t) dst_type);\n-}\n-\n-/* Look up a type mapping: return 0 if none.  The DST_FP is modified to point to\n-   the parent if need be.  The ID returned is from the dst_fp's perspective.  */\n-ctf_id_t\n-ctf_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type, ctf_dict_t **dst_fp)\n-{\n-  ctf_link_type_key_t key;\n-  ctf_dict_t *target_fp = *dst_fp;\n-  ctf_id_t dst_type = 0;\n-\n-  if (LCTF_TYPE_ISPARENT (src_fp, src_type) && src_fp->ctf_parent)\n-    src_fp = src_fp->ctf_parent;\n-\n-  src_type = LCTF_TYPE_TO_INDEX(src_fp, src_type);\n-  key.cltk_fp = src_fp;\n-  key.cltk_idx = src_type;\n-\n-  if (target_fp->ctf_link_type_mapping)\n-    dst_type = (uintptr_t) ctf_dynhash_lookup (target_fp->ctf_link_type_mapping,\n-\t\t\t\t\t       &key);\n-\n-  if (dst_type != 0)\n-    {\n-      dst_type = LCTF_INDEX_TO_TYPE (target_fp, dst_type,\n-\t\t\t\t     target_fp->ctf_parent != NULL);\n-      *dst_fp = target_fp;\n-      return dst_type;\n-    }\n-\n-  if (target_fp->ctf_parent)\n-    target_fp = target_fp->ctf_parent;\n-  else\n-    return 0;\n-\n-  if (target_fp->ctf_link_type_mapping)\n-    dst_type = (uintptr_t) ctf_dynhash_lookup (target_fp->ctf_link_type_mapping,\n-\t\t\t\t\t       &key);\n-\n-  if (dst_type)\n-    dst_type = LCTF_INDEX_TO_TYPE (target_fp, dst_type,\n-\t\t\t\t   target_fp->ctf_parent != NULL);\n-\n-  *dst_fp = target_fp;\n-  return dst_type;\n-}\n-\n-/* Linker machinery.\n-\n-   CTF linking consists of adding CTF archives full of content to be merged into\n+/* CTF linking consists of adding CTF archives full of content to be merged into\n    this one to the current file (which must be writable) by calling\n-   ctf_link_add_ctf().  Once this is done, a call to ctf_link() will merge the\n-   type tables together, generating new CTF files as needed, with this one as a\n-   parent, to contain types from the inputs which conflict.\n-   ctf_link_add_strtab() takes a callback which provides string/offset pairs to\n-   be added to the external symbol table and deduplicated from all CTF string\n-   tables in the output link; ctf_link_shuffle_syms() takes a callback which\n-   provides symtab entries in ascending order, and shuffles the function and\n-   data sections to match; and ctf_link_write() emits a CTF file (if there are\n-   no conflicts requiring per-compilation-unit sub-CTF files) or CTF archives\n-   (otherwise) and returns it, suitable for addition in the .ctf section of the\n-   output.  */\n+   ctf_link_add_ctf.  Once this is done, a call to ctf_link will merge the type\n+   tables together, generating new CTF files as needed, with this one as a\n+   parent, to contain types from the inputs which conflict.  ctf_link_add_strtab\n+   takes a callback which provides string/offset pairs to be added to the\n+   external symbol table and deduplicated from all CTF string tables in the\n+   output link; ctf_link_shuffle_syms takes a callback which provides symtab\n+   entries in ascending order, and shuffles the function and data sections to\n+   match; and ctf_link_write emits a CTF file (if there are no conflicts\n+   requiring per-compilation-unit sub-CTF files) or CTF archives (otherwise) and\n+   returns it, suitable for addition in the .ctf section of the output.  */\n \n /* Return the name of the compilation unit this CTF dict or its parent applies\n    to, or a non-null string otherwise: prefer the parent.  Used in debugging\n@@ -151,6 +51,19 @@ ctf_link_input_name (ctf_dict_t *fp)\n     return \"(unnamed)\";\n }\n \n+/* Return the cuname of a dict, or the string \"unnamed-CU\" if none.  */\n+\n+static const char *\n+ctf_unnamed_cuname (ctf_dict_t *fp)\n+{\n+  const char *cuname = ctf_cuname (fp);\n+\n+  if (!cuname)\n+    cuname = \"unnamed-CU\";\n+\n+  return cuname;\n+}\n+\n /* The linker inputs look like this.  clin_fp is used for short-circuited\n    CU-mapped links that can entirely avoid the first link phase in some\n    situations in favour of just passing on the contained ctf_dict_t: it is\n@@ -279,6 +192,7 @@ ctf_link_add_ctf (ctf_dict_t *fp, ctf_archive_t *ctf, const char *name)\n /* Return a per-CU output CTF dictionary suitable for the given CU, creating and\n    interning it if need be.  */\n \n+_libctf_nonnull_((1,2))\n static ctf_dict_t *\n ctf_create_per_cu (ctf_dict_t *fp, const char *cu_name)\n {\n@@ -429,21 +343,6 @@ ctf_link_set_memb_name_changer (ctf_dict_t *fp,\n   fp->ctf_link_memb_name_changer_arg = arg;\n }\n \n-typedef struct ctf_link_in_member_cb_arg\n-{\n-  /* The shared output dictionary.  */\n-  ctf_dict_t *out_fp;\n-\n-  /* The cuname of the input file, and an fp to each dictionary in that file\n-     in turn.  */\n-  const char *in_cuname;\n-  ctf_dict_t *in_fp;\n-\n-  /* If true, this is the CU-mapped portion of a deduplicating link: no child\n-     dictionaries should be created.  */\n-  int cu_mapped;\n-} ctf_link_in_member_cb_arg_t;\n-\n /* Set a function which is used to filter out unwanted variables from the link.  */\n int\n ctf_link_set_variable_filter (ctf_dict_t *fp, ctf_link_variable_filter_f *filter,\n@@ -479,101 +378,89 @@ check_variable (const char *name, ctf_dict_t *fp, ctf_id_t type,\n   return 0;\t\t\t\t      /* Already exists.  */\n }\n \n-/* Link one variable in.  */\n+/* Link one variable named NAME of type TYPE found in IN_FP into FP.  */\n \n static int\n-ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n+ctf_link_one_variable (ctf_dict_t *fp, ctf_dict_t *in_fp, const char *name,\n+\t\t       ctf_id_t type, int cu_mapped)\n {\n-  ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n   ctf_dict_t *per_cu_out_fp;\n   ctf_id_t dst_type = 0;\n-  ctf_dict_t *insert_fp;\n   ctf_dvdef_t *dvd;\n \n   /* See if this variable is filtered out.  */\n \n-  if (arg->out_fp->ctf_link_variable_filter)\n+  if (fp->ctf_link_variable_filter)\n     {\n-      void *farg = arg->out_fp->ctf_link_variable_filter_arg;\n-      if (arg->out_fp->ctf_link_variable_filter (arg->in_fp, name, type, farg))\n+      void *farg = fp->ctf_link_variable_filter_arg;\n+      if (fp->ctf_link_variable_filter (in_fp, name, type, farg))\n \treturn 0;\n     }\n \n   /* If this type is mapped to a type in the parent dict, we want to try to add\n      to that first: if it reports a duplicate, or if the type is in a child\n      already, add straight to the child.  */\n \n-  insert_fp = arg->out_fp;\n+  if ((dst_type = ctf_dedup_type_mapping (fp, in_fp, type)) == CTF_ERR)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n \n-  dst_type = ctf_type_mapping (arg->in_fp, type, &insert_fp);\n   if (dst_type != 0)\n     {\n-      if (insert_fp == arg->out_fp)\n-\t{\n-\t  if (check_variable (name, insert_fp, dst_type, &dvd))\n-\t    {\n-\t      /* No variable here: we can add it.  */\n-\t      if (ctf_add_variable (insert_fp, name, dst_type) < 0)\n-\t\treturn (ctf_set_errno (arg->out_fp, ctf_errno (insert_fp)));\n-\t      return 0;\n-\t    }\n+      if (!ctf_assert (fp, ctf_type_isparent (fp, dst_type)))\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n \n-\t  /* Already present?  Nothing to do.  */\n-\t  if (dvd && dvd->dvd_type == dst_type)\n-\t    return 0;\n+      if (check_variable (name, fp, dst_type, &dvd))\n+\t{\n+\t  /* No variable here: we can add it.  */\n+\t  if (ctf_add_variable (fp, name, dst_type) < 0)\n+\t    return -1; \t\t\t\t/* errno is set for us.  */\n+\t  return 0;\n \t}\n+\n+      /* Already present?  Nothing to do.  */\n+      if (dvd && dvd->dvd_type == dst_type)\n+\treturn 0;\n     }\n \n   /* Can't add to the parent due to a name clash, or because it references a\n      type only present in the child.  Try adding to the child, creating if need\n      be.  If we can't do that, skip it.  Don't add to a child if we're doing a\n      CU-mapped link, since that has only one output.  */\n \n-  if (arg->cu_mapped)\n+  if (cu_mapped)\n     {\n       ctf_dprintf (\"Variable %s in input file %s depends on a type %lx hidden \"\n-\t\t   \"due to conflicts: skipped.\\n\", name, arg->in_cuname,\n-\t\t   type);\n+\t\t   \"due to conflicts: skipped.\\n\", name,\n+\t\t   ctf_unnamed_cuname (in_fp), type);\n       return 0;\n     }\n \n-  if ((per_cu_out_fp = ctf_create_per_cu (arg->out_fp, arg->in_cuname)) == NULL)\n-    return -1;\t\t\t\t\t/* Errno is set for us.  */\n+  if ((per_cu_out_fp = ctf_create_per_cu (fp, ctf_unnamed_cuname (in_fp))) == NULL)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n \n   /* If the type was not found, check for it in the child too.  */\n   if (dst_type == 0)\n     {\n-      insert_fp = per_cu_out_fp;\n-      dst_type = ctf_type_mapping (arg->in_fp, type, &insert_fp);\n+      if ((dst_type = ctf_dedup_type_mapping (per_cu_out_fp,\n+\t\t\t\t\t      in_fp, type)) == CTF_ERR)\n+\treturn -1;\t\t\t\t/* errno is set for us.   */\n \n       if (dst_type == 0)\n \t{\n-\t  ctf_err_warn (arg->out_fp, 1, 0,\n-\t\t\t_(\"type %lx for variable %s in input file %s \"\n-\t\t\t  \"not found: skipped\"), type, name,\n-\t\t\targ->in_cuname);\n+\t  ctf_err_warn (fp, 1, 0, _(\"type %lx for variable %s in input file %s \"\n+\t\t\t\t    \"not found: skipped\"), type, name,\n+\t\t\tctf_unnamed_cuname (in_fp));\n \t  /* Do not terminate the link: just skip the variable.  */\n \t  return 0;\n \t}\n     }\n \n   if (check_variable (name, per_cu_out_fp, dst_type, &dvd))\n     if (ctf_add_variable (per_cu_out_fp, name, dst_type) < 0)\n-      return (ctf_set_errno (arg->out_fp, ctf_errno (per_cu_out_fp)));\n+      return (ctf_set_errno (fp, ctf_errno (per_cu_out_fp)));\n   return 0;\n }\n \n-/* Dump the unnecessary link type mapping after one input file is processed.  */\n-static void\n-empty_link_type_mapping (void *key _libctf_unused_, void *value,\n-\t\t\t void *arg _libctf_unused_)\n-{\n-  ctf_dict_t *fp = (ctf_dict_t *) value;\n-\n-  if (fp->ctf_link_type_mapping)\n-    ctf_dynhash_empty (fp->ctf_link_type_mapping);\n-}\n-\n /* Lazily open a CTF archive for linking, if not already open.\n \n    Returns the number of files contained within the opened archive (0 for none),\n@@ -925,21 +812,24 @@ static int\n ctf_link_deduplicating_variables (ctf_dict_t *fp, ctf_dict_t **inputs,\n \t\t\t\t  size_t ninputs, int cu_mapped)\n {\n-  ctf_link_in_member_cb_arg_t arg;\n   size_t i;\n \n-  arg.cu_mapped = cu_mapped;\n-  arg.out_fp = fp;\n-\n   for (i = 0; i < ninputs; i++)\n     {\n-      arg.in_fp = inputs[i];\n-      if (ctf_cuname (inputs[i]) != NULL)\n-\targ.in_cuname = ctf_cuname (inputs[i]);\n-      else\n-\targ.in_cuname = \"unnamed-CU\";\n-      if (ctf_variable_iter (arg.in_fp, ctf_link_one_variable, &arg) < 0)\n-\treturn ctf_set_errno (fp, ctf_errno (arg.in_fp));\n+      ctf_next_t *it = NULL;\n+      ctf_id_t type;\n+      const char *name;\n+\n+      while ((type = ctf_variable_next (inputs[i], &it, &name)) != CTF_ERR)\n+\t{\n+\t  if (ctf_link_one_variable (fp, inputs[i], name, type, cu_mapped) < 0)\n+\t    {\n+\t      ctf_next_destroy (it);\n+\t      return -1;\t\t\t/* errno is set for us.  */\n+\t    }\n+\t}\n+      if (ctf_errno (inputs[i]) != ECTF_NEXT_END)\n+\treturn ctf_set_errno (fp, ctf_errno (inputs[i]));\n     }\n   return 0;\n }\n@@ -982,40 +872,35 @@ ctf_link_deduplicating_one_symtypetab (ctf_dict_t *fp, ctf_dict_t *input,\n   ctf_next_t *it = NULL;\n   const char *name;\n   ctf_id_t type;\n-  const char *in_file_name;\n-\n-  if (ctf_cuname (input) != NULL)\n-    in_file_name = ctf_cuname (input);\n-  else\n-    in_file_name = \"unnamed-CU\";\n \n   while ((type = ctf_symbol_next (input, &it, &name, functions)) != CTF_ERR)\n     {\n       ctf_id_t dst_type;\n       ctf_dict_t *per_cu_out_fp;\n-      ctf_dict_t *insert_fp = fp;\n       int sym;\n \n       /* Look in the parent first.  */\n \n-      dst_type = ctf_type_mapping (input, type, &insert_fp);\n+      if ((dst_type = ctf_dedup_type_mapping (fp, input, type)) == CTF_ERR)\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+\n       if (dst_type != 0)\n \t{\n-\t  if (insert_fp == fp)\n-\t    {\n-\t      sym = check_sym (fp, name, dst_type, functions);\n+\t  if (!ctf_assert (fp, ctf_type_isparent (fp, dst_type)))\n+\t    return -1;\t\t\t\t/* errno is set for us.  */\n \n-\t      /* Already present: next symbol.  */\n-\t      if (sym == 0)\n-\t\tcontinue;\n-\t      /* Not present: add it.  */\n-\t      else if (sym > 0)\n-\t\t{\n-\t\t  if (ctf_add_funcobjt_sym (fp, functions,\n-\t\t\t\t\t    name, dst_type) < 0)\n-\t\t    return -1; \t\t\t/* errno is set for us.  */\n-\t\t  continue;\n-\t\t}\n+\t  sym = check_sym (fp, name, dst_type, functions);\n+\n+\t  /* Already present: next symbol.  */\n+\t  if (sym == 0)\n+\t    continue;\n+\t  /* Not present: add it.  */\n+\t  else if (sym > 0)\n+\t    {\n+\t      if (ctf_add_funcobjt_sym (fp, functions,\n+\t\t\t\t\tname, dst_type) < 0)\n+\t\treturn -1; \t\t\t/* errno is set for us.  */\n+\t      continue;\n \t    }\n \t}\n \n@@ -1028,24 +913,26 @@ ctf_link_deduplicating_one_symtypetab (ctf_dict_t *fp, ctf_dict_t *input,\n \t{\n \t  ctf_dprintf (\"Symbol %s in input file %s depends on a type %lx \"\n \t\t       \"hidden due to conflicts: skipped.\\n\", name,\n-\t\t       in_file_name, type);\n+\t\t       ctf_unnamed_cuname (input), type);\n \t  continue;\n \t}\n \n-      if ((per_cu_out_fp = ctf_create_per_cu (fp, in_file_name)) == NULL)\n+      if ((per_cu_out_fp = ctf_create_per_cu (fp, ctf_unnamed_cuname (input))) == NULL)\n \treturn -1;\t\t\t\t/* errno is set for us.  */\n \n       /* If the type was not found, check for it in the child too.  */\n       if (dst_type == 0)\n \t{\n-\t  insert_fp = per_cu_out_fp;\n-\t  dst_type = ctf_type_mapping (input, type, &insert_fp);\n+\t  if ((dst_type = ctf_dedup_type_mapping (per_cu_out_fp,\n+\t\t\t\t\t\t  input, type)) == CTF_ERR)\n+\t    return -1;\t\t\t\t/* errno is set for us.  */\n \n \t  if (dst_type == 0)\n \t    {\n \t      ctf_err_warn (fp, 1, 0,\n \t\t\t    _(\"type %lx for symbol %s in input file %s \"\n-\t\t\t      \"not found: skipped\"), type, name, in_file_name);\n+\t\t\t      \"not found: skipped\"), type, name,\n+\t\t\t    ctf_unnamed_cuname (input));\n \t      continue;\n \t    }\n \t}\n@@ -1068,7 +955,7 @@ ctf_link_deduplicating_one_symtypetab (ctf_dict_t *fp, ctf_dict_t *input,\n \t  ctf_err_warn (fp, 0, ECTF_DUPLICATE,\n \t\t\t_(\"symbol %s in input file %s found conflicting \"\n \t\t\t  \"even when trying in per-CU dict.\"), name,\n-\t\t\tin_file_name);\n+\t\t\tctf_unnamed_cuname (input));\n \t  return (ctf_set_errno (fp, ECTF_DUPLICATE));\n \t}\n     }\n@@ -1258,6 +1145,8 @@ ctf_link_deduplicating_per_cu (ctf_dict_t *fp)\n \t  goto err_inputs_outputs;\n \t}\n \n+      ctf_dedup_fini (out, outputs, noutputs);\n+\n       /* For now, we omit symbol section linking for CU-mapped links, until it\n \t is clear how to unify the symbol table across such links.  (Perhaps we\n \t should emit an unconditionally indexed symtab, like the compiler\n@@ -1420,6 +1309,8 @@ ctf_link_deduplicating (ctf_dict_t *fp)\n       goto err_clean_outputs;\n     }\n \n+  ctf_dedup_fini (fp, outputs, noutputs);\n+\n   /* Now close all the inputs, including per-CU intermediates.  */\n \n   if (ctf_link_deduplicating_close_inputs (fp, NULL, inputs, ninputs) < 0)\n@@ -1452,12 +1343,9 @@ ctf_link_deduplicating (ctf_dict_t *fp)\n int\n ctf_link (ctf_dict_t *fp, int flags)\n {\n-  ctf_link_in_member_cb_arg_t arg;\n   ctf_next_t *i = NULL;\n   int err;\n \n-  memset (&arg, 0, sizeof (struct ctf_link_in_member_cb_arg));\n-  arg.out_fp = fp;\n   fp->ctf_link_flags = flags;\n \n   if (fp->ctf_link_inputs == NULL)\n@@ -1503,11 +1391,6 @@ ctf_link (ctf_dict_t *fp, int flags)\n \n   ctf_link_deduplicating (fp);\n \n-  /* Discard the now-unnecessary mapping table data from all the outputs.  */\n-  if (fp->ctf_link_type_mapping)\n-    ctf_dynhash_empty (fp->ctf_link_type_mapping);\n-  ctf_dynhash_iter (fp->ctf_link_outputs, empty_link_type_mapping, NULL);\n-\n   fp->ctf_flags &= ~LCTF_LINKING;\n   if ((ctf_errno (fp) != 0) && (ctf_errno (fp) != ECTF_NOCTFDATA))\n     return -1;\n@@ -1537,8 +1420,8 @@ ctf_link_intern_extern_string (void *key _libctf_unused_, void *value,\n /* Repeatedly call ADD_STRING to acquire strings from the external string table,\n    adding them to the atoms table for this CU and all subsidiary CUs.\n \n-   If ctf_link() is also called, it must be called first if you want the new CTF\n-   files ctf_link() can create to get their strings dedupped against the ELF\n+   If ctf_link is also called, it must be called first if you want the new CTF\n+   files ctf_link can create to get their strings dedupped against the ELF\n    strtab properly.  */\n int\n ctf_link_add_strtab (ctf_dict_t *fp, ctf_link_strtab_string_f *add_string,"
    }
  ]
}