{
  "sha": "0d6aab77761274e479ca443f8bcb35a0eee3a4c4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGQ2YWFiNzc3NjEyNzRlNDc5Y2E0NDNmOGJjYjM1YTBlZWUzYTRjNA==",
  "commit": {
    "author": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-01-22T02:16:12Z"
    },
    "committer": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-02-17T03:02:09Z"
    },
    "message": "RISC-V: PR27200, allow the first input non-ABI binary to be linked with any one.\n\nRISC-V only defines two float ABIs, soft-float and double-float, and the\nvalue of soft-float is 0x0.  But 0x0 usually means unknown/default setting\nfor many targets, and the non-ABI binary, which is generated by \"ld/objcopy\n-b binary\", also has the 0x0 elf header flags, this may be confused.\n\nWe probably can define a new unknown/default ABI value to make them more\nclear, but that will need more bits in the elf header flags, and also need\nto discuss in the riscv psabi spec.\n\nTraining linker have a default ABI setting, and can be changed by ld\noptions or configure options is another solution, like what assemblr\nusually do.  So all objects, including the binary files, will have\nexplicit ABI setting.  But the binary files will no longer be linked\nwith any object, users need to recompile them with the exactly ABI\nthey want.  It may be inconvenience sometimes.  Besides, I think linker\ndoesn't need to know the default arch/abi so far, just set them according\nto the linked objects should be enough.\n\nTherefore, without changing the riscv psabi, and keep the non-ABI binary\ncan be linked with any object, we don't check the ABI flags if no code\nsection in the PR24389.  Just that we find the first input non-ABI binary\nstill cannot be linked with others in the PR27200.  This patch fixs the\nproblem by delaying the elf_flags_init(obfd) check, since the flags of\nnon-ABI object with no code cannot be copyed to output BFD, we should\nskip it, even if it is the first linked object.\n\nHowever, there is a strange \"break\" at the end of loop in the PR24389.\nThe \"break\" cause the ld testcase \"Link with zlib-gabi compressed debug\noutput 1\" fails for rv64gc-linux toolchain, after applying the above\nchange.  The root cause is that - the \"break\" make linker only checks\nthe \"first\" section of input BFD rather than the entire sections.\nI have checked that AARCH64 and ARM both have the \"break\" at the end\nof loop, but ARC doesn't.  I suppose we should remove the \"break\" like\nwhat ARC do, or use a pair of braces for the if statement.\n\nI have passed the elf/linux toolchain regressions, so the change should\nbe fine.\n\nbfd/\n    PR 27200\n    * elfnn-riscv.c (_bfd_riscv_elf_merge_private_bfd_data): Delay\n    copying the elf flags from input BFD to output BFD, until we have\n    checked if the input BFD has no code section or not.  Also fix the\n    problem that we only check the first section rather than the entire\n    sections for input BFD.",
    "tree": {
      "sha": "905ffcb9c2fad429f8043c59f0272e88f901af19",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/905ffcb9c2fad429f8043c59f0272e88f901af19"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0d6aab77761274e479ca443f8bcb35a0eee3a4c4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0d6aab77761274e479ca443f8bcb35a0eee3a4c4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0d6aab77761274e479ca443f8bcb35a0eee3a4c4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0d6aab77761274e479ca443f8bcb35a0eee3a4c4/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "0b5500cdd54eb93891d303af6d1c2721e4e7317b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0b5500cdd54eb93891d303af6d1c2721e4e7317b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0b5500cdd54eb93891d303af6d1c2721e4e7317b"
    }
  ],
  "stats": {
    "total": 39,
    "additions": 25,
    "deletions": 14
  },
  "files": [
    {
      "sha": "b7c35c79ce22978904c47b0d7c8ac748e02f285e",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0d6aab77761274e479ca443f8bcb35a0eee3a4c4/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0d6aab77761274e479ca443f8bcb35a0eee3a4c4/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=0d6aab77761274e479ca443f8bcb35a0eee3a4c4",
      "patch": "@@ -1,3 +1,12 @@\n+2021-02-17  Nelson Chu  <nelson.chu@sifive.com>\n+\n+\tPR 27200\n+\t* elfnn-riscv.c (_bfd_riscv_elf_merge_private_bfd_data): Delay\n+\tcopying the elf flags from input BFD to output BFD, until we have\n+\tchecked if the input BFD has no code section or not.  Also fix the\n+\tproblem that we only check the first section rather than the entire\n+\tsections for input BFD.\n+\n 2021-02-16  Alan Modra  <amodra@gmail.com>\n \n \t* libbfd.c (_bfd_read_unsigned_leb128): Avoid excessive shift."
    },
    {
      "sha": "66272f5c661e39b17b2a1cee706f5aefd4f55ee2",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 16,
      "deletions": 14,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0d6aab77761274e479ca443f8bcb35a0eee3a4c4/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0d6aab77761274e479ca443f8bcb35a0eee3a4c4/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=0d6aab77761274e479ca443f8bcb35a0eee3a4c4",
      "patch": "@@ -3801,16 +3801,6 @@ _bfd_riscv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n   if (!riscv_merge_attributes (ibfd, info))\n     return FALSE;\n \n-  new_flags = elf_elfheader (ibfd)->e_flags;\n-  old_flags = elf_elfheader (obfd)->e_flags;\n-\n-  if (! elf_flags_init (obfd))\n-    {\n-      elf_flags_init (obfd) = TRUE;\n-      elf_elfheader (obfd)->e_flags = new_flags;\n-      return TRUE;\n-    }\n-\n   /* Check to see if the input BFD actually contains any sections.  If not,\n      its flags may not have been initialized either, but it cannot actually\n      cause any incompatibility.  Do not short-circuit dynamic objects; their\n@@ -3826,19 +3816,31 @@ _bfd_riscv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n \n       for (sec = ibfd->sections; sec != NULL; sec = sec->next)\n \t{\n+\t  null_input_bfd = FALSE;\n+\n \t  if ((bfd_section_flags (sec)\n \t       & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n \t      == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))\n-\t    only_data_sections = FALSE;\n-\n-\t  null_input_bfd = FALSE;\n-\t  break;\n+\t    {\n+\t      only_data_sections = FALSE;\n+\t      break;\n+\t    }\n \t}\n \n       if (null_input_bfd || only_data_sections)\n \treturn TRUE;\n     }\n \n+  new_flags = elf_elfheader (ibfd)->e_flags;\n+  old_flags = elf_elfheader (obfd)->e_flags;\n+\n+  if (!elf_flags_init (obfd))\n+    {\n+      elf_flags_init (obfd) = TRUE;\n+      elf_elfheader (obfd)->e_flags = new_flags;\n+      return TRUE;\n+    }\n+\n   /* Disallow linking different float ABIs.  */\n   if ((old_flags ^ new_flags) & EF_RISCV_FLOAT_ABI)\n     {"
    }
  ]
}