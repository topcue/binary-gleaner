{
  "sha": "4483a8e72ad265b5d428899d384bf190db071759",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDQ4M2E4ZTcyYWQyNjViNWQ0Mjg4OTlkMzg0YmYxOTBkYjA3MTc1OQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-11T00:55:56Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-12-11T00:56:23Z"
    },
    "message": "gdb/testsuite: fix race condition in gdb.multi/multi-arch-exec.exp\n\nThat test fails intermittently for me.  The problem is a race condition\nbetween the exec syscall and GDB resuming threads.\n\nThe initial situation is that we have two threads, let's call them\n\"leader\" and \"other\".  Leader is the one who is going to do the exec.\nWe stop at the breakpoint on the all_started function, so both threads\nare stopped.  When resuming, GDB resumes leader first and other second.\nHowever, between resuming the two threads, leader has time to run and do\nits exec, making other disappear.  When GDB tries to resume other, it is\nino longer there.  We get some \"Couldn't get registers: No such\nprocess.\" messages, and the state is a bit messed up.\n\nThe issue can be triggered consistently by adding a small delay after\nthe resume syscall:\n\n    diff --git a/gdb/inf-ptrace.c b/gdb/inf-ptrace.c\n    index d5a062163c7..9540339a9da 100644\n    --- a/gdb/inf-ptrace.c\n    +++ b/gdb/inf-ptrace.c\n    @@ -308,6 +308,8 @@ inf_ptrace_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n       gdb_ptrace (request, ptid, (PTRACE_TYPE_ARG3)1, gdb_signal_to_host (signal));\n       if (errno != 0)\n         perror_with_name ((\"ptrace\"));\n    +  for (int i = 0 ; i < 100; i++)\n    +    usleep (10000);\n     }\n\n     /* Wait for the child specified by PTID to do something.  Return the\n\nThis patch is about fixing the test to avoid this, since the test is not\nabout testing this particular corner case.  Handling of multi-threaded\nprogram doing execs should be improved too, but that's not the goal of\nthis patch.\n\nFix it by adding a synchronization point in the test to make sure both\nthreads were resumed by GDB before doing the exec.  I added two\npthread_barrier_wait calls in each thread (for a total of three).  I\nthink adding one call in each thread would not be enough, because this\ncould happen:\n\n- both threads reach the first barrier\n- the \"other\" thread is scheduled so has time to run and hit the second\n  barrier\n- the \"leader\" thread hits the all_started function breakpoint, causing\n  both threads to be stopped by GDB\n- GDB resumes the \"leader\" thread\n- Since the \"other\" thread has already reached the second barrier, the\n  \"leader\" thread is free to run past its second barrier and do the\n  exec, while GDB still hasn't resumed the second one\n\nBy adding two barrier calls in each thread, I think we are good.  The test\npasses consistently for me, even with the artificial delay added.\n\ngdb/testsuite/ChangeLog:\n\n\tPR gdb/24694\n\t* gdb.multi/multi-arch-exec.c (thread_start, main): Add barrier\n\tcalls.\n\nChange-Id: I25c8ea9724010b6bf20b42691c716235537d0e27",
    "tree": {
      "sha": "da677f870b7fee2c962283a508aa7c6d544dd75c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/da677f870b7fee2c962283a508aa7c6d544dd75c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4483a8e72ad265b5d428899d384bf190db071759",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4483a8e72ad265b5d428899d384bf190db071759",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4483a8e72ad265b5d428899d384bf190db071759",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4483a8e72ad265b5d428899d384bf190db071759/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "33e06c75aae5085dea50fbd50109c1477056a3a3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/33e06c75aae5085dea50fbd50109c1477056a3a3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/33e06c75aae5085dea50fbd50109c1477056a3a3"
    }
  ],
  "stats": {
    "total": 13,
    "additions": 13,
    "deletions": 0
  },
  "files": [
    {
      "sha": "07e206a1a5ccdf5cdc1b76054bcdbd69a735a03b",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4483a8e72ad265b5d428899d384bf190db071759/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4483a8e72ad265b5d428899d384bf190db071759/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=4483a8e72ad265b5d428899d384bf190db071759",
      "patch": "@@ -1,3 +1,9 @@\n+2020-12-10  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\tPR gdb/24694\n+\t* gdb.multi/multi-arch-exec.c (thread_start, main): Add barrier\n+\tcalls.\n+\n 2020-12-10  Tom de Vries  <tdevries@suse.de>\n \n \tPR testsuite/26947"
    },
    {
      "sha": "1c22050a00947f37245bcaa692929b6e68aaa794",
      "filename": "gdb/testsuite/gdb.multi/multi-arch-exec.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4483a8e72ad265b5d428899d384bf190db071759/gdb/testsuite/gdb.multi/multi-arch-exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4483a8e72ad265b5d428899d384bf190db071759/gdb/testsuite/gdb.multi/multi-arch-exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.multi/multi-arch-exec.c?ref=4483a8e72ad265b5d428899d384bf190db071759",
      "patch": "@@ -30,6 +30,8 @@ static void *\n thread_start (void *arg)\n {\n   pthread_barrier_wait (&barrier);\n+  pthread_barrier_wait (&barrier);\n+  pthread_barrier_wait (&barrier);\n \n   while (1)\n     sleep (1);\n@@ -60,6 +62,11 @@ main (int argc, char ** argv)\n   pthread_barrier_wait (&barrier);\n   all_started ();\n \n+  /* Avoid races with GDB ptrace-resuming the threads and the exec: ensure\n+     both threads were resumed by GDB before going into the exec.  */\n+  pthread_barrier_wait (&barrier);\n+  pthread_barrier_wait (&barrier);\n+\n   execl (prog,\n          prog,\n          (char *) NULL);"
    }
  ]
}