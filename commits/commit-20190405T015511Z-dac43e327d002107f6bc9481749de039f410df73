{
  "sha": "dac43e327d002107f6bc9481749de039f410df73",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGFjNDNlMzI3ZDAwMjEwN2Y2YmM5NDgxNzQ5ZGUwMzlmNDEwZGY3Mw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-03-31T19:43:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-05T01:55:11Z"
    },
    "message": "Move type stack handling to a new class\n\nThis introduces a new \"type_stack\" class, and moves all the parser\ntype stack handling to this class.  Parsers that wish to use this\nfacility must now instantiate this class somehow.  I chose this\napproach because a minority of the existing parsers require this.\n\ngdb/ChangeLog\n2019-04-04  Tom Tromey  <tom@tromey.com>\n\n\t* type-stack.h: New file.\n\t* type-stack.c: New file.\n\t* parser-defs.h (enum type_pieces, union type_stack_elt): Move to\n\ttype-stack.h.\n\t(insert_into_type_stack, insert_type, push_type, push_type_int)\n\t(insert_type_address_space, pop_type, pop_type_int)\n\t(pop_typelist, pop_type_stack, append_type_stack)\n\t(push_type_stack, get_type_stack, push_typelist)\n\t(follow_type_instance_flags, follow_types): Don't declare.\n\t* parse.c (type_stack): Remove global.\n\t(parse_exp_in_context): Update.\n\t(insert_into_type_stack, insert_type, push_type, push_type_int)\n\t(insert_type_address_space, pop_type, pop_type_int)\n\t(pop_typelist, pop_type_stack, append_type_stack)\n\t(push_type_stack, get_type_stack, push_typelist)\n\t(follow_type_instance_flags, follow_types): Remove (moved to\n\ttype-stack.c).\n\t* f-exp.y (type_stack): New global.\n\tUpdate rules.\n\t(push_kind_type, f_parse): Update.\n\t* d-exp.y (type_stack): New global.\n\tUpdate rules.\n\t(d_parse): Update.\n\t* c-exp.y (struct c_parse_state) <type_stack>: New member.\n\tUpdate rules.\n\t* Makefile.in (COMMON_SFILES): Add type-stack.c.\n\t(HFILES_NO_SRCDIR): Add type-stack.h.",
    "tree": {
      "sha": "e3f3ae3d7b892d2a68e271127e5b53cf75e2c0d0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e3f3ae3d7b892d2a68e271127e5b53cf75e2c0d0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/dac43e327d002107f6bc9481749de039f410df73",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dac43e327d002107f6bc9481749de039f410df73",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/dac43e327d002107f6bc9481749de039f410df73",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dac43e327d002107f6bc9481749de039f410df73/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2a61252965c91540133bece7deb92eb22e3cf929",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2a61252965c91540133bece7deb92eb22e3cf929",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2a61252965c91540133bece7deb92eb22e3cf929"
    }
  ],
  "stats": {
    "total": 965,
    "additions": 521,
    "deletions": 444
  },
  "files": [
    {
      "sha": "238d6782155974c67225d8b40065367549550556",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -1,3 +1,33 @@\n+2019-04-04  Tom Tromey  <tom@tromey.com>\n+\n+\t* type-stack.h: New file.\n+\t* type-stack.c: New file.\n+\t* parser-defs.h (enum type_pieces, union type_stack_elt): Move to\n+\ttype-stack.h.\n+\t(insert_into_type_stack, insert_type, push_type, push_type_int)\n+\t(insert_type_address_space, pop_type, pop_type_int)\n+\t(pop_typelist, pop_type_stack, append_type_stack)\n+\t(push_type_stack, get_type_stack, push_typelist)\n+\t(follow_type_instance_flags, follow_types): Don't declare.\n+\t* parse.c (type_stack): Remove global.\n+\t(parse_exp_in_context): Update.\n+\t(insert_into_type_stack, insert_type, push_type, push_type_int)\n+\t(insert_type_address_space, pop_type, pop_type_int)\n+\t(pop_typelist, pop_type_stack, append_type_stack)\n+\t(push_type_stack, get_type_stack, push_typelist)\n+\t(follow_type_instance_flags, follow_types): Remove (moved to\n+\ttype-stack.c).\n+\t* f-exp.y (type_stack): New global.\n+\tUpdate rules.\n+\t(push_kind_type, f_parse): Update.\n+\t* d-exp.y (type_stack): New global.\n+\tUpdate rules.\n+\t(d_parse): Update.\n+\t* c-exp.y (struct c_parse_state) <type_stack>: New member.\n+\tUpdate rules.\n+\t* Makefile.in (COMMON_SFILES): Add type-stack.c.\n+\t(HFILES_NO_SRCDIR): Add type-stack.h.\n+\n 2019-04-04  Tom Tromey  <tom@tromey.com>\n \n \t* rust-exp.y (rust_parser::lex_identifier, rustyylex)"
    },
    {
      "sha": "0f49578360000c857e365ca5199a93213793043c",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -1131,6 +1131,7 @@ COMMON_SFILES = \\\n \ttrad-frame.c \\\n \ttramp-frame.c \\\n \ttarget-float.c \\\n+\ttype-stack.c \\\n \ttypeprint.c \\\n \tui-file.c \\\n \tui-out.c \\\n@@ -1406,6 +1407,7 @@ HFILES_NO_SRCDIR = \\\n \ttrad-frame.h \\\n \ttarget-float.h \\\n \ttramp-frame.h \\\n+\ttype-stack.h \\\n \ttypeprint.h \\\n \tui-file.h \\\n \tui-out.h \\"
    },
    {
      "sha": "627ea1f3baeb4f15ebb585961f0ea13857f3b679",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 43,
      "deletions": 34,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -53,6 +53,7 @@\n #include \"objc-lang.h\"\n #include \"typeprint.h\"\n #include \"cp-abi.h\"\n+#include \"type-stack.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n \n@@ -104,6 +105,9 @@ struct c_parse_state\n      token, we simply keep it all and delete it after parsing has\n      completed.  */\n   auto_obstack expansion_obstack;\n+\n+  /* The type stack.  */\n+  struct type_stack type_stack;\n };\n \n /* This is set and cleared in c_parse.  */\n@@ -604,8 +608,10 @@ function_method:       exp '(' parameter_typelist ')' const_or_volatile\n \t\t\t  /* Save the const/volatile qualifiers as\n \t\t\t     recorded by the const_or_volatile\n \t\t\t     production's actions.  */\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t follow_type_instance_flags ());\n+\t\t\t  write_exp_elt_longcst\n+\t\t\t    (pstate,\n+\t\t\t     (cpstate->type_stack\n+\t\t\t      .follow_type_instance_flags ()));\n \t\t\t  write_exp_elt_longcst (pstate, len);\n \t\t\t  for (type *type_elt : *type_list)\n \t\t\t    write_exp_elt_type (pstate, type_elt);\n@@ -617,8 +623,9 @@ function_method:       exp '(' parameter_typelist ')' const_or_volatile\n function_method_void:\t    exp '(' ')' const_or_volatile\n \t\t       { write_exp_elt_opcode (pstate, TYPE_INSTANCE);\n \t\t\t /* See above.  */\n-\t\t\t write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\tfollow_type_instance_flags ());\n+\t\t\t write_exp_elt_longcst\n+\t\t\t   (pstate,\n+\t\t\t    cpstate->type_stack.follow_type_instance_flags ());\n \t\t\t write_exp_elt_longcst (pstate, 0);\n \t\t\t write_exp_elt_longcst (pstate, 0);\n \t\t\t write_exp_elt_opcode (pstate, TYPE_INSTANCE);\n@@ -1158,7 +1165,9 @@ variable:\tname_not_typename\n \t;\n \n space_identifier : '@' NAME\n-\t\t{ insert_type_address_space (pstate, copy_name ($2.stoken)); }\n+\t\t{\n+\t\t  cpstate->type_stack.insert (pstate, copy_name ($2.stoken));\n+\t\t}\n \t;\n \n const_or_volatile: const_or_volatile_noopt\n@@ -1179,30 +1188,30 @@ const_or_volatile_or_space_identifier:\n \n ptr_operator:\n \t\tptr_operator '*'\n-\t\t\t{ insert_type (tp_pointer); }\n+\t\t\t{ cpstate->type_stack.insert (tp_pointer); }\n \t\tconst_or_volatile_or_space_identifier\n \t|\t'*'\n-\t\t\t{ insert_type (tp_pointer); }\n+\t\t\t{ cpstate->type_stack.insert (tp_pointer); }\n \t\tconst_or_volatile_or_space_identifier\n \t|\t'&'\n-\t\t\t{ insert_type (tp_reference); }\n+\t\t\t{ cpstate->type_stack.insert (tp_reference); }\n \t|\t'&' ptr_operator\n-\t\t\t{ insert_type (tp_reference); }\n+\t\t\t{ cpstate->type_stack.insert (tp_reference); }\n \t|       ANDAND\n-\t\t\t{ insert_type (tp_rvalue_reference); }\n+\t\t\t{ cpstate->type_stack.insert (tp_rvalue_reference); }\n \t|       ANDAND ptr_operator\n-\t\t\t{ insert_type (tp_rvalue_reference); }\n+\t\t\t{ cpstate->type_stack.insert (tp_rvalue_reference); }\n \t;\n \n ptr_operator_ts: ptr_operator\n \t\t\t{\n-\t\t\t  $$ = get_type_stack ();\n+\t\t\t  $$ = cpstate->type_stack.create ();\n \t\t\t  cpstate->type_stacks.emplace_back ($$);\n \t\t\t}\n \t;\n \n abs_decl:\tptr_operator_ts direct_abs_decl\n-\t\t\t{ $$ = append_type_stack ($2, $1); }\n+\t\t\t{ $$ = $2->append ($1); }\n \t|\tptr_operator_ts\n \t|\tdirect_abs_decl\n \t;\n@@ -1211,31 +1220,31 @@ direct_abs_decl: '(' abs_decl ')'\n \t\t\t{ $$ = $2; }\n \t|\tdirect_abs_decl array_mod\n \t\t\t{\n-\t\t\t  push_type_stack ($1);\n-\t\t\t  push_type_int ($2);\n-\t\t\t  push_type (tp_array);\n-\t\t\t  $$ = get_type_stack ();\n+\t\t\t  cpstate->type_stack.push ($1);\n+\t\t\t  cpstate->type_stack.push ($2);\n+\t\t\t  cpstate->type_stack.push (tp_array);\n+\t\t\t  $$ = cpstate->type_stack.create ();\n \t\t\t  cpstate->type_stacks.emplace_back ($$);\n \t\t\t}\n \t|\tarray_mod\n \t\t\t{\n-\t\t\t  push_type_int ($1);\n-\t\t\t  push_type (tp_array);\n-\t\t\t  $$ = get_type_stack ();\n+\t\t\t  cpstate->type_stack.push ($1);\n+\t\t\t  cpstate->type_stack.push (tp_array);\n+\t\t\t  $$ = cpstate->type_stack.create ();\n \t\t\t  cpstate->type_stacks.emplace_back ($$);\n \t\t\t}\n \n \t| \tdirect_abs_decl func_mod\n \t\t\t{\n-\t\t\t  push_type_stack ($1);\n-\t\t\t  push_typelist ($2);\n-\t\t\t  $$ = get_type_stack ();\n+\t\t\t  cpstate->type_stack.push ($1);\n+\t\t\t  cpstate->type_stack.push ($2);\n+\t\t\t  $$ = cpstate->type_stack.create ();\n \t\t\t  cpstate->type_stacks.emplace_back ($$);\n \t\t\t}\n \t|\tfunc_mod\n \t\t\t{\n-\t\t\t  push_typelist ($1);\n-\t\t\t  $$ = get_type_stack ();\n+\t\t\t  cpstate->type_stack.push ($1);\n+\t\t\t  $$ = cpstate->type_stack.create ();\n \t\t\t  cpstate->type_stacks.emplace_back ($$);\n \t\t\t}\n \t;\n@@ -1489,9 +1498,9 @@ typebase\n \t\t\t     pstate->expression_context_block);\n \t\t\t}\n \t| const_or_volatile_or_space_identifier_noopt typebase\n-\t\t\t{ $$ = follow_types ($2); }\n+\t\t\t{ $$ = cpstate->type_stack.follow_types ($2); }\n \t| typebase const_or_volatile_or_space_identifier_noopt\n-\t\t\t{ $$ = follow_types ($1); }\n+\t\t\t{ $$ = cpstate->type_stack.follow_types ($1); }\n \t;\n \n type_name:\tTYPENAME\n@@ -1552,13 +1561,13 @@ nonempty_typelist\n ptype\t:\ttypebase\n \t|\tptype abs_decl\n \t\t{\n-\t\t  push_type_stack ($2);\n-\t\t  $$ = follow_types ($1);\n+\t\t  cpstate->type_stack.push ($2);\n+\t\t  $$ = cpstate->type_stack.follow_types ($1);\n \t\t}\n \t;\n \n conversion_type_id: typebase conversion_declarator\n-\t\t{ $$ = follow_types ($1); }\n+\t\t{ $$ = cpstate->type_stack.follow_types ($1); }\n \t;\n \n conversion_declarator:  /* Nothing.  */\n@@ -1570,13 +1579,13 @@ const_and_volatile: \tCONST_KEYWORD VOLATILE_KEYWORD\n \t;\n \n const_or_volatile_noopt:  \tconst_and_volatile\n-\t\t\t{ insert_type (tp_const);\n-\t\t\t  insert_type (tp_volatile);\n+\t\t\t{ cpstate->type_stack.insert (tp_const);\n+\t\t\t  cpstate->type_stack.insert (tp_volatile);\n \t\t\t}\n \t| \t\tCONST_KEYWORD\n-\t\t\t{ insert_type (tp_const); }\n+\t\t\t{ cpstate->type_stack.insert (tp_const); }\n \t| \t\tVOLATILE_KEYWORD\n-\t\t\t{ insert_type (tp_volatile); }\n+\t\t\t{ cpstate->type_stack.insert (tp_volatile); }\n \t;\n \n oper:\tOPERATOR NEW"
    },
    {
      "sha": "ca9aaf8580274e3ac7ddcb7e625efe52ce09434e",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 15,
      "deletions": 7,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -51,6 +51,7 @@\n #include \"objfiles.h\" /* For have_full_symbols and have_partial_symbols */\n #include \"charset.h\"\n #include \"block.h\"\n+#include \"type-stack.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n #define parse_d_type(ps) builtin_d_type (ps->gdbarch ())\n@@ -65,6 +66,9 @@\n \n static struct parser_state *pstate = NULL;\n \n+/* The current type stack.  */\n+static struct type_stack *type_stack;\n+\n int yyparse (void);\n \n static int yylex (void);\n@@ -606,7 +610,7 @@ TypeExp:\n \t\t  write_exp_elt_type (pstate, $1);\n \t\t  write_exp_elt_opcode (pstate, OP_TYPE); }\n |\tBasicType BasicType2\n-\t\t{ $$ = follow_types ($1);\n+\t\t{ $$ = type_stack->follow_types ($1);\n \t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n \t\t  write_exp_elt_type (pstate, $$);\n \t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n@@ -615,15 +619,15 @@ TypeExp:\n \n BasicType2:\n \t'*'\n-\t\t{ push_type (tp_pointer); }\n+\t\t{ type_stack->push (tp_pointer); }\n |\t'*' BasicType2\n-\t\t{ push_type (tp_pointer); }\n+\t\t{ type_stack->push (tp_pointer); }\n |\t'[' INTEGER_LITERAL ']'\n-\t\t{ push_type_int ($2.val);\n-\t\t  push_type (tp_array); }\n+\t\t{ type_stack->push ($2.val);\n+\t\t  type_stack->push (tp_array); }\n |\t'[' INTEGER_LITERAL ']' BasicType2\n-\t\t{ push_type_int ($2.val);\n-\t\t  push_type (tp_array); }\n+\t\t{ type_stack->push ($2.val);\n+\t\t  type_stack->push (tp_array); }\n ;\n \n BasicType:\n@@ -1619,6 +1623,10 @@ d_parse (struct parser_state *par_state)\n   scoped_restore restore_yydebug = make_scoped_restore (&yydebug,\n \t\t\t\t\t\t\tparser_debug);\n \n+  struct type_stack stack;\n+  scoped_restore restore_type_stack = make_scoped_restore (&type_stack,\n+\t\t\t\t\t\t\t   &stack);\n+\n   /* Initialize some state used by the lexer.  */\n   last_was_structop = 0;\n   saw_name_at_eof = 0;"
    },
    {
      "sha": "403dfa20687b88d2af37d113ee083563ad174a8f",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 19,
      "deletions": 11,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -54,6 +54,7 @@\n #include \"block.h\"\n #include <ctype.h>\n #include <algorithm>\n+#include \"type-stack.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n #define parse_f_type(ps) builtin_f_type (ps->gdbarch ())\n@@ -71,6 +72,9 @@ static struct parser_state *pstate = NULL;\n /* Depth of parentheses.  */\n static int paren_depth;\n \n+/* The current type stack.  */\n+static struct type_stack *type_stack;\n+\n int yyparse (void);\n \n static int yylex (void);\n@@ -515,7 +519,7 @@ ptype\t:\ttypebase\n \t\t  struct type *range_type;\n \t\t  \n \t\t  while (!done)\n-\t\t    switch (pop_type ())\n+\t\t    switch (type_stack->pop ())\n \t\t      {\n \t\t      case tp_end:\n \t\t\tdone = 1;\n@@ -527,7 +531,7 @@ ptype\t:\ttypebase\n \t\t\tfollow_type = lookup_lvalue_reference_type (follow_type);\n \t\t\tbreak;\n \t\t      case tp_array:\n-\t\t\tarray_size = pop_type_int ();\n+\t\t\tarray_size = type_stack->pop_int ();\n \t\t\tif (array_size != -1)\n \t\t\t  {\n \t\t\t    range_type =\n@@ -547,7 +551,7 @@ ptype\t:\ttypebase\n \t\t\tbreak;\n \t\t      case tp_kind:\n \t\t\t{\n-\t\t\t  int kind_val = pop_type_int ();\n+\t\t\t  int kind_val = type_stack->pop_int ();\n \t\t\t  follow_type\n \t\t\t    = convert_to_kind_type (follow_type, kind_val);\n \t\t\t}\n@@ -558,13 +562,13 @@ ptype\t:\ttypebase\n \t;\n \n abs_decl:\t'*'\n-\t\t\t{ push_type (tp_pointer); $$ = 0; }\n+\t\t\t{ type_stack->push (tp_pointer); $$ = 0; }\n \t|\t'*' abs_decl\n-\t\t\t{ push_type (tp_pointer); $$ = $2; }\n+\t\t\t{ type_stack->push (tp_pointer); $$ = $2; }\n \t|\t'&'\n-\t\t\t{ push_type (tp_reference); $$ = 0; }\n+\t\t\t{ type_stack->push (tp_reference); $$ = 0; }\n \t|\t'&' abs_decl\n-\t\t\t{ push_type (tp_reference); $$ = $2; }\n+\t\t\t{ type_stack->push (tp_reference); $$ = $2; }\n \t|\tdirect_abs_decl\n \t;\n \n@@ -575,9 +579,9 @@ direct_abs_decl: '(' abs_decl ')'\n \t|\t'*' INT\n \t\t\t{ push_kind_type ($2.val, $2.type); }\n \t| \tdirect_abs_decl func_mod\n-\t\t\t{ push_type (tp_function); }\n+\t\t\t{ type_stack->push (tp_function); }\n \t|\tfunc_mod\n-\t\t\t{ push_type (tp_function); }\n+\t\t\t{ type_stack->push (tp_function); }\n \t;\n \n func_mod:\t'(' ')'\n@@ -821,8 +825,8 @@ push_kind_type (LONGEST val, struct type *type)\n       ival = static_cast <int> (val);\n     }\n \n-  push_type_int (ival);\n-  push_type (tp_kind);\n+  type_stack->push (ival);\n+  type_stack->push (tp_kind);\n }\n \n /* Called when a type has a '(kind=N)' modifier after it, for example\n@@ -1333,6 +1337,10 @@ f_parse (struct parser_state *par_state)\n   pstate = par_state;\n   paren_depth = 0;\n \n+  struct type_stack stack;\n+  scoped_restore restore_type_stack = make_scoped_restore (&type_stack,\n+\t\t\t\t\t\t\t   &stack);\n+\n   return yyparse ();\n }\n "
    },
    {
      "sha": "89a29f0f60218c0dca81af6c7df474eed912f30d",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 0,
      "deletions": 333,
      "changes": 333,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -67,7 +67,6 @@ const struct exp_descriptor exp_descriptor_standard =\n \f\n /* Global variables declared in parser-defs.h (and commented there).  */\n innermost_block_tracker innermost_block;\n-static struct type_stack type_stack;\n \n \f\n static unsigned int expressiondebug = 0;\n@@ -1073,7 +1072,6 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n   const struct language_defn *lang = NULL;\n   int subexp;\n \n-  type_stack.elements.clear ();\n   innermost_block.reset (tracker_types);\n \n   if (*stringptr == 0 || **stringptr == 0)\n@@ -1287,337 +1285,6 @@ parse_float (const char *p, int len,\n   return target_float_from_string (data, type, std::string (p, len));\n }\n \f\n-/* Stuff for maintaining a stack of types.  Currently just used by C, but\n-   probably useful for any language which declares its types \"backwards\".  */\n-\n-/* A helper function for insert_type and insert_type_address_space.\n-   This does work of expanding the type stack and inserting the new\n-   element, ELEMENT, into the stack at location SLOT.  */\n-\n-static void\n-insert_into_type_stack (int slot, union type_stack_elt element)\n-{\n-  gdb_assert (slot <= type_stack.elements.size ());\n-  type_stack.elements.insert (type_stack.elements.begin () + slot, element);\n-}\n-\n-/* Insert a new type, TP, at the bottom of the type stack.  If TP is\n-   tp_pointer, tp_reference or tp_rvalue_reference, it is inserted at the\n-   bottom.  If TP is a qualifier, it is inserted at slot 1 (just above a\n-   previous tp_pointer) if there is anything on the stack, or simply pushed\n-   if the stack is empty.  Other values for TP are invalid.  */\n-\n-void\n-insert_type (enum type_pieces tp)\n-{\n-  union type_stack_elt element;\n-  int slot;\n-\n-  gdb_assert (tp == tp_pointer || tp == tp_reference\n-\t      || tp == tp_rvalue_reference || tp == tp_const\n-\t      || tp == tp_volatile);\n-\n-  /* If there is anything on the stack (we know it will be a\n-     tp_pointer), insert the qualifier above it.  Otherwise, simply\n-     push this on the top of the stack.  */\n-  if (!type_stack.elements.empty () && (tp == tp_const || tp == tp_volatile))\n-    slot = 1;\n-  else\n-    slot = 0;\n-\n-  element.piece = tp;\n-  insert_into_type_stack (slot, element);\n-}\n-\n-void\n-push_type (enum type_pieces tp)\n-{\n-  type_stack_elt elt;\n-  elt.piece = tp;\n-  type_stack.elements.push_back (elt);\n-}\n-\n-void\n-push_type_int (int n)\n-{\n-  type_stack_elt elt;\n-  elt.int_val = n;\n-  type_stack.elements.push_back (elt);\n-}\n-\n-/* Insert a tp_space_identifier and the corresponding address space\n-   value into the stack.  STRING is the name of an address space, as\n-   recognized by address_space_name_to_int.  If the stack is empty,\n-   the new elements are simply pushed.  If the stack is not empty,\n-   this function assumes that the first item on the stack is a\n-   tp_pointer, and the new values are inserted above the first\n-   item.  */\n-\n-void\n-insert_type_address_space (struct expr_builder *pstate, char *string)\n-{\n-  union type_stack_elt element;\n-  int slot;\n-\n-  /* If there is anything on the stack (we know it will be a\n-     tp_pointer), insert the address space qualifier above it.\n-     Otherwise, simply push this on the top of the stack.  */\n-  if (!type_stack.elements.empty ())\n-    slot = 1;\n-  else\n-    slot = 0;\n-\n-  element.piece = tp_space_identifier;\n-  insert_into_type_stack (slot, element);\n-  element.int_val = address_space_name_to_int (pstate->gdbarch (),\n-\t\t\t\t\t       string);\n-  insert_into_type_stack (slot, element);\n-}\n-\n-enum type_pieces\n-pop_type (void)\n-{\n-  if (!type_stack.elements.empty ())\n-    {\n-      type_stack_elt elt = type_stack.elements.back ();\n-      type_stack.elements.pop_back ();\n-      return elt.piece;\n-    }\n-  return tp_end;\n-}\n-\n-int\n-pop_type_int (void)\n-{\n-  if (!type_stack.elements.empty ())\n-    {\n-      type_stack_elt elt = type_stack.elements.back ();\n-      type_stack.elements.pop_back ();\n-      return elt.int_val;\n-    }\n-  /* \"Can't happen\".  */\n-  return 0;\n-}\n-\n-/* Pop a type list element from the global type stack.  */\n-\n-static std::vector<struct type *> *\n-pop_typelist (void)\n-{\n-  gdb_assert (!type_stack.elements.empty ());\n-  type_stack_elt elt = type_stack.elements.back ();\n-  type_stack.elements.pop_back ();\n-  return elt.typelist_val;\n-}\n-\n-/* Pop a type_stack element from the global type stack.  */\n-\n-static struct type_stack *\n-pop_type_stack (void)\n-{\n-  gdb_assert (!type_stack.elements.empty ());\n-  type_stack_elt elt = type_stack.elements.back ();\n-  type_stack.elements.pop_back ();\n-  return elt.stack_val;\n-}\n-\n-/* Append the elements of the type stack FROM to the type stack TO.\n-   Always returns TO.  */\n-\n-struct type_stack *\n-append_type_stack (struct type_stack *to, struct type_stack *from)\n-{\n-  to->elements.insert (to->elements.end (), from->elements.begin (),\n-\t\t       from->elements.end ());\n-  return to;\n-}\n-\n-/* Push the type stack STACK as an element on the global type stack.  */\n-\n-void\n-push_type_stack (struct type_stack *stack)\n-{\n-  type_stack_elt elt;\n-  elt.stack_val = stack;\n-  type_stack.elements.push_back (elt);\n-  push_type (tp_type_stack);\n-}\n-\n-/* Copy the global type stack into a newly allocated type stack and\n-   return it.  The global stack is cleared.  The returned type stack\n-   must be freed with delete.  */\n-\n-struct type_stack *\n-get_type_stack (void)\n-{\n-  struct type_stack *result = new struct type_stack (std::move (type_stack));\n-  type_stack.elements.clear ();\n-  return result;\n-}\n-\n-/* Push a function type with arguments onto the global type stack.\n-   LIST holds the argument types.  If the final item in LIST is NULL,\n-   then the function will be varargs.  */\n-\n-void\n-push_typelist (std::vector<struct type *> *list)\n-{\n-  type_stack_elt elt;\n-  elt.typelist_val = list;\n-  type_stack.elements.push_back (elt);\n-  push_type (tp_function_with_arguments);\n-}\n-\n-/* Pop the type stack and return a type_instance_flags that\n-   corresponds the const/volatile qualifiers on the stack.  This is\n-   called by the C++ parser when parsing methods types, and as such no\n-   other kind of type in the type stack is expected.  */\n-\n-type_instance_flags\n-follow_type_instance_flags ()\n-{\n-  type_instance_flags flags = 0;\n-\n-  for (;;)\n-    switch (pop_type ())\n-      {\n-      case tp_end:\n-\treturn flags;\n-      case tp_const:\n-\tflags |= TYPE_INSTANCE_FLAG_CONST;\n-\tbreak;\n-      case tp_volatile:\n-\tflags |= TYPE_INSTANCE_FLAG_VOLATILE;\n-\tbreak;\n-      default:\n-\tgdb_assert_not_reached (\"unrecognized tp_ value in follow_types\");\n-      }\n-}\n-\n-\n-/* Pop the type stack and return the type which corresponds to FOLLOW_TYPE\n-   as modified by all the stuff on the stack.  */\n-struct type *\n-follow_types (struct type *follow_type)\n-{\n-  int done = 0;\n-  int make_const = 0;\n-  int make_volatile = 0;\n-  int make_addr_space = 0;\n-  int array_size;\n-\n-  while (!done)\n-    switch (pop_type ())\n-      {\n-      case tp_end:\n-\tdone = 1;\n-\tif (make_const)\n-\t  follow_type = make_cv_type (make_const, \n-\t\t\t\t      TYPE_VOLATILE (follow_type), \n-\t\t\t\t      follow_type, 0);\n-\tif (make_volatile)\n-\t  follow_type = make_cv_type (TYPE_CONST (follow_type), \n-\t\t\t\t      make_volatile, \n-\t\t\t\t      follow_type, 0);\n-\tif (make_addr_space)\n-\t  follow_type = make_type_with_address_space (follow_type, \n-\t\t\t\t\t\t      make_addr_space);\n-\tmake_const = make_volatile = 0;\n-\tmake_addr_space = 0;\n-\tbreak;\n-      case tp_const:\n-\tmake_const = 1;\n-\tbreak;\n-      case tp_volatile:\n-\tmake_volatile = 1;\n-\tbreak;\n-      case tp_space_identifier:\n-\tmake_addr_space = pop_type_int ();\n-\tbreak;\n-      case tp_pointer:\n-\tfollow_type = lookup_pointer_type (follow_type);\n-\tif (make_const)\n-\t  follow_type = make_cv_type (make_const, \n-\t\t\t\t      TYPE_VOLATILE (follow_type), \n-\t\t\t\t      follow_type, 0);\n-\tif (make_volatile)\n-\t  follow_type = make_cv_type (TYPE_CONST (follow_type), \n-\t\t\t\t      make_volatile, \n-\t\t\t\t      follow_type, 0);\n-\tif (make_addr_space)\n-\t  follow_type = make_type_with_address_space (follow_type, \n-\t\t\t\t\t\t      make_addr_space);\n-\tmake_const = make_volatile = 0;\n-\tmake_addr_space = 0;\n-\tbreak;\n-      case tp_reference:\n-\t follow_type = lookup_lvalue_reference_type (follow_type);\n-\t goto process_reference;\n-\tcase tp_rvalue_reference:\n-\t follow_type = lookup_rvalue_reference_type (follow_type);\n-\tprocess_reference:\n-\t if (make_const)\n-\t   follow_type = make_cv_type (make_const,\n-\t\t\t\t       TYPE_VOLATILE (follow_type),\n-\t\t\t\t       follow_type, 0);\n-\t if (make_volatile)\n-\t   follow_type = make_cv_type (TYPE_CONST (follow_type),\n-\t\t\t\t       make_volatile,\n-\t\t\t\t       follow_type, 0);\n-\t if (make_addr_space)\n-\t   follow_type = make_type_with_address_space (follow_type,\n-\t\t\t\t\t\t       make_addr_space);\n-\tmake_const = make_volatile = 0;\n-\tmake_addr_space = 0;\n-\tbreak;\n-      case tp_array:\n-\tarray_size = pop_type_int ();\n-\t/* FIXME-type-allocation: need a way to free this type when we are\n-\t   done with it.  */\n-\tfollow_type =\n-\t  lookup_array_range_type (follow_type,\n-\t\t\t\t   0, array_size >= 0 ? array_size - 1 : 0);\n-\tif (array_size < 0)\n-\t  TYPE_HIGH_BOUND_KIND (TYPE_INDEX_TYPE (follow_type))\n-\t    = PROP_UNDEFINED;\n-\tbreak;\n-      case tp_function:\n-\t/* FIXME-type-allocation: need a way to free this type when we are\n-\t   done with it.  */\n-\tfollow_type = lookup_function_type (follow_type);\n-\tbreak;\n-\n-      case tp_function_with_arguments:\n-\t{\n-\t  std::vector<struct type *> *args = pop_typelist ();\n-\n-\t  follow_type\n-\t    = lookup_function_type_with_arguments (follow_type,\n-\t\t\t\t\t\t   args->size (),\n-\t\t\t\t\t\t   args->data ());\n-\t}\n-\tbreak;\n-\n-      case tp_type_stack:\n-\t{\n-\t  struct type_stack *stack = pop_type_stack ();\n-\t  /* Sort of ugly, but not really much worse than the\n-\t     alternatives.  */\n-\t  struct type_stack save = type_stack;\n-\n-\t  type_stack = *stack;\n-\t  follow_type = follow_types (follow_type);\n-\t  gdb_assert (type_stack.elements.empty ());\n-\n-\t  type_stack = save;\n-\t}\n-\tbreak;\n-      default:\n-\tgdb_assert_not_reached (\"unrecognized tp_ value in follow_types\");\n-      }\n-  return follow_type;\n-}\n-\f\n /* This function avoids direct calls to fprintf \n    in the parser generated debug code.  */\n void"
    },
    {
      "sha": "edbd3b7b673254e8cdff0050ac4ea4f857a7fb0a",
      "filename": "gdb/parser-defs.h",
      "status": "modified",
      "additions": 0,
      "deletions": 59,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/parser-defs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/parser-defs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parser-defs.h?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -299,40 +299,6 @@ struct objc_class_str\n     int theclass;\n   };\n \n-/* For parsing of complicated types.\n-   An array should be preceded in the list by the size of the array.  */\n-enum type_pieces\n-  {\n-    tp_end = -1, \n-    tp_pointer, \n-    tp_reference, \n-    tp_rvalue_reference,\n-    tp_array, \n-    tp_function,\n-    tp_function_with_arguments,\n-    tp_const, \n-    tp_volatile, \n-    tp_space_identifier,\n-    tp_type_stack,\n-    tp_kind\n-  };\n-/* The stack can contain either an enum type_pieces or an int.  */\n-union type_stack_elt\n-  {\n-    enum type_pieces piece;\n-    int int_val;\n-    struct type_stack *stack_val;\n-    std::vector<struct type *> *typelist_val;\n-  };\n-\n-/* The type stack is an instance of this structure.  */\n-\n-struct type_stack\n-{\n-  /* Elements on the stack.  */\n-  std::vector<union type_stack_elt> elements;\n-};\n-\n /* Reverse an expression from suffix form (in which it is constructed)\n    to prefix form (in which we can conveniently print or execute it).\n    Ordinarily this always returns -1.  However, if LAST_STRUCT\n@@ -376,27 +342,6 @@ extern const char *find_template_name_end (const char *);\n \n extern char *copy_name (struct stoken);\n \n-extern void insert_type (enum type_pieces);\n-\n-extern void push_type (enum type_pieces);\n-\n-extern void push_type_int (int);\n-\n-extern void insert_type_address_space (struct expr_builder *, char *);\n-\n-extern enum type_pieces pop_type (void);\n-\n-extern int pop_type_int (void);\n-\n-extern struct type_stack *get_type_stack (void);\n-\n-extern struct type_stack *append_type_stack (struct type_stack *to,\n-\t\t\t\t\t     struct type_stack *from);\n-\n-extern void push_type_stack (struct type_stack *stack);\n-\n-extern void push_typelist (std::vector<struct type *> *typelist);\n-\n extern int dump_subexp (struct expression *, struct ui_file *, int);\n \n extern int dump_subexp_body_standard (struct expression *, \n@@ -414,10 +359,6 @@ extern int operator_check_standard (struct expression *exp, int pos,\n \n extern const char *op_name_standard (enum exp_opcode);\n \n-extern struct type *follow_types (struct type *);\n-\n-extern type_instance_flags follow_type_instance_flags ();\n-\n extern void null_post_parser (expression_up *, int, int);\n \n extern bool parse_float (const char *p, int len,"
    },
    {
      "sha": "cb0c147d307afb8472355ab20664bc4de54b07f5",
      "filename": "gdb/type-stack.c",
      "status": "added",
      "additions": 209,
      "deletions": 0,
      "changes": 209,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/type-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/type-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/type-stack.c?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -0,0 +1,209 @@\n+/* Type stack for GDB parser.\n+\n+   Copyright (C) 1986-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"type-stack.h\"\n+\n+#include \"gdbtypes.h\"\n+#include \"parser-defs.h\"\n+\n+/* See type-stack.h.  */\n+\n+void\n+type_stack::insert (enum type_pieces tp)\n+{\n+  union type_stack_elt element;\n+  int slot;\n+\n+  gdb_assert (tp == tp_pointer || tp == tp_reference\n+\t      || tp == tp_rvalue_reference || tp == tp_const\n+\t      || tp == tp_volatile);\n+\n+  /* If there is anything on the stack (we know it will be a\n+     tp_pointer), insert the qualifier above it.  Otherwise, simply\n+     push this on the top of the stack.  */\n+  if (!m_elements.empty () && (tp == tp_const || tp == tp_volatile))\n+    slot = 1;\n+  else\n+    slot = 0;\n+\n+  element.piece = tp;\n+  insert_into (slot, element);\n+}\n+\n+/* See type-stack.h.  */\n+\n+void\n+type_stack::insert (struct expr_builder *pstate, char *string)\n+{\n+  union type_stack_elt element;\n+  int slot;\n+\n+  /* If there is anything on the stack (we know it will be a\n+     tp_pointer), insert the address space qualifier above it.\n+     Otherwise, simply push this on the top of the stack.  */\n+  if (!m_elements.empty ())\n+    slot = 1;\n+  else\n+    slot = 0;\n+\n+  element.piece = tp_space_identifier;\n+  insert_into (slot, element);\n+  element.int_val = address_space_name_to_int (pstate->gdbarch (),\n+\t\t\t\t\t       string);\n+  insert_into (slot, element);\n+}\n+\n+/* See type-stack.h.  */\n+\n+type_instance_flags\n+type_stack::follow_type_instance_flags ()\n+{\n+  type_instance_flags flags = 0;\n+\n+  for (;;)\n+    switch (pop ())\n+      {\n+      case tp_end:\n+\treturn flags;\n+      case tp_const:\n+\tflags |= TYPE_INSTANCE_FLAG_CONST;\n+\tbreak;\n+      case tp_volatile:\n+\tflags |= TYPE_INSTANCE_FLAG_VOLATILE;\n+\tbreak;\n+      default:\n+\tgdb_assert_not_reached (\"unrecognized tp_ value in follow_types\");\n+      }\n+}\n+\n+/* See type-stack.h.  */\n+\n+struct type *\n+type_stack::follow_types (struct type *follow_type)\n+{\n+  int done = 0;\n+  int make_const = 0;\n+  int make_volatile = 0;\n+  int make_addr_space = 0;\n+  int array_size;\n+\n+  while (!done)\n+    switch (pop ())\n+      {\n+      case tp_end:\n+\tdone = 1;\n+\tif (make_const)\n+\t  follow_type = make_cv_type (make_const, \n+\t\t\t\t      TYPE_VOLATILE (follow_type), \n+\t\t\t\t      follow_type, 0);\n+\tif (make_volatile)\n+\t  follow_type = make_cv_type (TYPE_CONST (follow_type), \n+\t\t\t\t      make_volatile, \n+\t\t\t\t      follow_type, 0);\n+\tif (make_addr_space)\n+\t  follow_type = make_type_with_address_space (follow_type, \n+\t\t\t\t\t\t      make_addr_space);\n+\tmake_const = make_volatile = 0;\n+\tmake_addr_space = 0;\n+\tbreak;\n+      case tp_const:\n+\tmake_const = 1;\n+\tbreak;\n+      case tp_volatile:\n+\tmake_volatile = 1;\n+\tbreak;\n+      case tp_space_identifier:\n+\tmake_addr_space = pop_int ();\n+\tbreak;\n+      case tp_pointer:\n+\tfollow_type = lookup_pointer_type (follow_type);\n+\tif (make_const)\n+\t  follow_type = make_cv_type (make_const, \n+\t\t\t\t      TYPE_VOLATILE (follow_type), \n+\t\t\t\t      follow_type, 0);\n+\tif (make_volatile)\n+\t  follow_type = make_cv_type (TYPE_CONST (follow_type), \n+\t\t\t\t      make_volatile, \n+\t\t\t\t      follow_type, 0);\n+\tif (make_addr_space)\n+\t  follow_type = make_type_with_address_space (follow_type, \n+\t\t\t\t\t\t      make_addr_space);\n+\tmake_const = make_volatile = 0;\n+\tmake_addr_space = 0;\n+\tbreak;\n+      case tp_reference:\n+\t follow_type = lookup_lvalue_reference_type (follow_type);\n+\t goto process_reference;\n+\tcase tp_rvalue_reference:\n+\t follow_type = lookup_rvalue_reference_type (follow_type);\n+\tprocess_reference:\n+\t if (make_const)\n+\t   follow_type = make_cv_type (make_const,\n+\t\t\t\t       TYPE_VOLATILE (follow_type),\n+\t\t\t\t       follow_type, 0);\n+\t if (make_volatile)\n+\t   follow_type = make_cv_type (TYPE_CONST (follow_type),\n+\t\t\t\t       make_volatile,\n+\t\t\t\t       follow_type, 0);\n+\t if (make_addr_space)\n+\t   follow_type = make_type_with_address_space (follow_type,\n+\t\t\t\t\t\t       make_addr_space);\n+\tmake_const = make_volatile = 0;\n+\tmake_addr_space = 0;\n+\tbreak;\n+      case tp_array:\n+\tarray_size = pop_int ();\n+\t/* FIXME-type-allocation: need a way to free this type when we are\n+\t   done with it.  */\n+\tfollow_type =\n+\t  lookup_array_range_type (follow_type,\n+\t\t\t\t   0, array_size >= 0 ? array_size - 1 : 0);\n+\tif (array_size < 0)\n+\t  TYPE_HIGH_BOUND_KIND (TYPE_INDEX_TYPE (follow_type))\n+\t    = PROP_UNDEFINED;\n+\tbreak;\n+      case tp_function:\n+\t/* FIXME-type-allocation: need a way to free this type when we are\n+\t   done with it.  */\n+\tfollow_type = lookup_function_type (follow_type);\n+\tbreak;\n+\n+      case tp_function_with_arguments:\n+\t{\n+\t  std::vector<struct type *> *args = pop_typelist ();\n+\n+\t  follow_type\n+\t    = lookup_function_type_with_arguments (follow_type,\n+\t\t\t\t\t\t   args->size (),\n+\t\t\t\t\t\t   args->data ());\n+\t}\n+\tbreak;\n+\n+      case tp_type_stack:\n+\t{\n+\t  struct type_stack *stack = pop_type_stack ();\n+\t  follow_type = stack->follow_types (follow_type);\n+\t}\n+\tbreak;\n+      default:\n+\tgdb_assert_not_reached (\"unrecognized tp_ value in follow_types\");\n+      }\n+  return follow_type;\n+}"
    },
    {
      "sha": "672ad05483774e25c1fa04d2a23e6a6f0109e1da",
      "filename": "gdb/type-stack.h",
      "status": "added",
      "additions": 203,
      "deletions": 0,
      "changes": 203,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dac43e327d002107f6bc9481749de039f410df73/gdb/type-stack.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dac43e327d002107f6bc9481749de039f410df73/gdb/type-stack.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/type-stack.h?ref=dac43e327d002107f6bc9481749de039f410df73",
      "patch": "@@ -0,0 +1,203 @@\n+/* Type stack for GDB parser.\n+\n+   Copyright (C) 1986-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef TYPE_STACK_H\n+#define TYPE_STACK_H\n+\n+#include <vector>\n+\n+struct type;\n+struct expr_builder;\n+\n+/* For parsing of complicated types.\n+   An array should be preceded in the list by the size of the array.  */\n+enum type_pieces\n+  {\n+    tp_end = -1, \n+    tp_pointer, \n+    tp_reference, \n+    tp_rvalue_reference,\n+    tp_array, \n+    tp_function,\n+    tp_function_with_arguments,\n+    tp_const, \n+    tp_volatile, \n+    tp_space_identifier,\n+    tp_type_stack,\n+    tp_kind\n+  };\n+\n+/* The stack can contain either an enum type_pieces or an int.  */\n+union type_stack_elt\n+  {\n+    enum type_pieces piece;\n+    int int_val;\n+    struct type_stack *stack_val;\n+    std::vector<struct type *> *typelist_val;\n+  };\n+\n+/* The type stack is an instance of this structure.  */\n+\n+struct type_stack\n+{\n+public:\n+\n+  type_stack () = default;\n+\n+  DISABLE_COPY_AND_ASSIGN (type_stack);\n+\n+  type_stack *create ()\n+  {\n+    type_stack *result = new type_stack ();\n+    result->m_elements = std::move (m_elements);\n+    return result;\n+  }\n+\n+  /* Insert a new type, TP, at the bottom of the type stack.  If TP is\n+     tp_pointer, tp_reference or tp_rvalue_reference, it is inserted at the\n+     bottom.  If TP is a qualifier, it is inserted at slot 1 (just above a\n+     previous tp_pointer) if there is anything on the stack, or simply pushed\n+     if the stack is empty.  Other values for TP are invalid.  */\n+\n+  void insert (enum type_pieces tp);\n+\n+  void push (enum type_pieces tp)\n+  {\n+    type_stack_elt elt;\n+    elt.piece = tp;\n+    m_elements.push_back (elt);\n+  }\n+\n+  void push (int n)\n+  {\n+    type_stack_elt elt;\n+    elt.int_val = n;\n+    m_elements.push_back (elt);\n+  }\n+\n+  /* Push the type stack STACK as an element on this type stack.  */\n+\n+  void push (struct type_stack *stack)\n+  {\n+    type_stack_elt elt;\n+    elt.stack_val = stack;\n+    m_elements.push_back (elt);\n+    push (tp_type_stack);\n+  }\n+\n+  /* Push a function type with arguments onto the global type stack.\n+     LIST holds the argument types.  If the final item in LIST is NULL,\n+     then the function will be varargs.  */\n+\n+  void push (std::vector<struct type *> *list)\n+  {\n+    type_stack_elt elt;\n+    elt.typelist_val = list;\n+    m_elements.push_back (elt);\n+    push (tp_function_with_arguments);\n+  }\n+\n+  enum type_pieces pop ()\n+  {\n+    if (m_elements.empty ())\n+      return tp_end;\n+    type_stack_elt elt = m_elements.back ();\n+    m_elements.pop_back ();\n+    return elt.piece;\n+  }\n+\n+  int pop_int ()\n+  {\n+    if (m_elements.empty ())\n+      {\n+\t/* \"Can't happen\".  */\n+\treturn 0;\n+      }\n+    type_stack_elt elt = m_elements.back ();\n+    m_elements.pop_back ();\n+    return elt.int_val;\n+  }\n+\n+  std::vector<struct type *> *pop_typelist ()\n+  {\n+    gdb_assert (!m_elements.empty ());\n+    type_stack_elt elt = m_elements.back ();\n+    m_elements.pop_back ();\n+    return elt.typelist_val;\n+  }\n+\n+  /* Pop a type_stack element.  */\n+\n+  struct type_stack *pop_type_stack ()\n+  {\n+    gdb_assert (!m_elements.empty ());\n+    type_stack_elt elt = m_elements.back ();\n+    m_elements.pop_back ();\n+    return elt.stack_val;\n+  }\n+\n+  /* Insert a tp_space_identifier and the corresponding address space\n+     value into the stack.  STRING is the name of an address space, as\n+     recognized by address_space_name_to_int.  If the stack is empty,\n+     the new elements are simply pushed.  If the stack is not empty,\n+     this function assumes that the first item on the stack is a\n+     tp_pointer, and the new values are inserted above the first\n+     item.  */\n+\n+  void insert (struct expr_builder *pstate, char *string);\n+\n+  /* Append the elements of the type stack FROM to the type stack\n+     THIS.  Always returns THIS.  */\n+\n+  struct type_stack *append (struct type_stack *from)\n+  {\n+    m_elements.insert (m_elements.end (), from->m_elements.begin (),\n+\t\t       from->m_elements.end ());\n+    return this;\n+  }\n+\n+  /* Pop the type stack and return a type_instance_flags that\n+     corresponds the const/volatile qualifiers on the stack.  This is\n+     called by the C++ parser when parsing methods types, and as such no\n+     other kind of type in the type stack is expected.  */\n+\n+  type_instance_flags follow_type_instance_flags ();\n+\n+  /* Pop the type stack and return the type which corresponds to\n+     FOLLOW_TYPE as modified by all the stuff on the stack.  */\n+  struct type *follow_types (struct type *follow_type);\n+\n+private:\n+\n+  /* A helper function for insert_type and insert_type_address_space.\n+     This does work of expanding the type stack and inserting the new\n+     element, ELEMENT, into the stack at location SLOT.  */\n+\n+  void insert_into (int slot, union type_stack_elt element)\n+  {\n+    gdb_assert (slot <= m_elements.size ());\n+    m_elements.insert (m_elements.begin () + slot, element);\n+  }\n+\n+\n+  /* Elements on the stack.  */\n+  std::vector<union type_stack_elt> m_elements;\n+};\n+\n+#endif /* TYPE_STACK_H */"
    }
  ]
}