{
  "sha": "30fe183248b2523ecff9da36853e2f893c4c4b91",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzBmZTE4MzI0OGIyNTIzZWNmZjlkYTM2ODUzZTJmODkzYzRjNGI5MQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-10-23T07:10:51Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-10-25T03:00:05Z"
    },
    "message": "PR4499, assign file positions assumes segment offsets increasing\n\nThis rewrites much of assign_file_positions_for_non_load_sections to\nallow objcopy and strip to handle cases like that in PR4499 where\nprogram headers were not in their usual position immediately after the\nELF file header, and PT_LOAD headers were not sorted by paddr.\n\n\tPR 4499\ninclude/\n\t* elf/internal.h (struct elf_segment_map): Delete header_size.\n\tAdd no_sort_lma and idx.\nbfd/\n\t* elf-nacl.c (nacl_modify_segment_map): Set no_sort_lma for all\n\tPT_LOAD segments.\n\t* elf32-spu.c (spu_elf_modify_segment_map): Likewise on overlay\n\tPT_LOAD segments.\n\t* elf.c (elf_sort_segments): New function.\n\t(assign_file_positions_except_relocs): Use shortcuts to elfheader\n\tand elf_tdata.  Seek to e_phoff not sizeof_ehdr to write program\n\theaders.  Move PT_PHDR check..\n\t(assign_file_positions_for_non_load_sections): ..and code setting\n\tPT_PHDR p_vaddr and p_paddr, and code setting __ehdr_start value..\n\t(assign_file_positions_for_load_sections): ..to here.  Sort\n\tPT_LOAD headers.  Delete header_pad code.  Use actual number of\n\theaders rather than allocated in calculating size for program\n\theaders.  Don't assume program headers follow ELF file header.\n\tSimplify pt_load_count code.  Only set \"off\" for PT_LOAD or\n\tPT_NOTE in cores.\n\t(rewrite_elf_program_header): Set p_vaddr_offset for segments\n\tthat include file and program headers.\n\t(copy_elf_program_header): Likewise, replacing header_size code.",
    "tree": {
      "sha": "3f65ea3d49d3ed120a2ed8ef92e4ef8657321a25",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3f65ea3d49d3ed120a2ed8ef92e4ef8657321a25"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/30fe183248b2523ecff9da36853e2f893c4c4b91",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30fe183248b2523ecff9da36853e2f893c4c4b91",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/30fe183248b2523ecff9da36853e2f893c4c4b91",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30fe183248b2523ecff9da36853e2f893c4c4b91/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c0c121b01c8a9408ae22ee9007dd0273f4c8d0be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0c121b01c8a9408ae22ee9007dd0273f4c8d0be",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c0c121b01c8a9408ae22ee9007dd0273f4c8d0be"
    }
  ],
  "stats": {
    "total": 536,
    "additions": 298,
    "deletions": 238
  },
  "files": [
    {
      "sha": "2b41fb36c4c68a8258b6fb612ea2935cee69e42c",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30fe183248b2523ecff9da36853e2f893c4c4b91/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30fe183248b2523ecff9da36853e2f893c4c4b91/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=30fe183248b2523ecff9da36853e2f893c4c4b91",
      "patch": "@@ -1,3 +1,26 @@\n+2019-10-25  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 4499\n+\t* elf-nacl.c (nacl_modify_segment_map): Set no_sort_lma for all\n+\tPT_LOAD segments.\n+\t* elf32-spu.c (spu_elf_modify_segment_map): Likewise on overlay\n+\tPT_LOAD segments.\n+\t* elf.c (elf_sort_segments): New function.\n+\t(assign_file_positions_except_relocs): Use shortcuts to elfheader\n+\tand elf_tdata.  Seek to e_phoff not sizeof_ehdr to write program\n+\theaders.  Move PT_PHDR check..\n+\t(assign_file_positions_for_non_load_sections): ..and code setting\n+\tPT_PHDR p_vaddr and p_paddr, and code setting __ehdr_start value..\n+\t(assign_file_positions_for_load_sections): ..to here.  Sort\n+\tPT_LOAD headers.  Delete header_pad code.  Use actual number of\n+\theaders rather than allocated in calculating size for program\n+\theaders.  Don't assume program headers follow ELF file header.\n+\tSimplify pt_load_count code.  Only set \"off\" for PT_LOAD or\n+\tPT_NOTE in cores.\n+\t(rewrite_elf_program_header): Set p_vaddr_offset for segments\n+\tthat include file and program headers.\n+\t(copy_elf_program_header): Likewise, replacing header_size code.\n+\n 2019-10-21  Alan Modra  <amodra@gmail.com>\n \n \tPR 452"
    },
    {
      "sha": "ddac3b372bf2c84d67fed2b9267bbe637af50daf",
      "filename": "bfd/elf-nacl.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30fe183248b2523ecff9da36853e2f893c4c4b91/bfd/elf-nacl.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30fe183248b2523ecff9da36853e2f893c4c4b91/bfd/elf-nacl.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-nacl.c?ref=30fe183248b2523ecff9da36853e2f893c4c4b91",
      "patch": "@@ -197,6 +197,7 @@ nacl_modify_segment_map (bfd *abfd, struct bfd_link_info *info)\n \t\t included the file header and phdrs.  */\n \t      seg->includes_filehdr = 0;\n \t      seg->includes_phdrs = 0;\n+\t      seg->no_sort_lma = 1;\n \t      /* Also strip out empty segments.  */\n \t      if (seg->count == 0)\n \t\t{"
    },
    {
      "sha": "38872d7757e3a7ae5336f9a28a4e2ae8e533f737",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 260,
      "deletions": 236,
      "changes": 496,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30fe183248b2523ecff9da36853e2f893c4c4b91/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30fe183248b2523ecff9da36853e2f893c4c4b91/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=30fe183248b2523ecff9da36853e2f893c4c4b91",
      "patch": "@@ -5296,6 +5296,48 @@ elf_sort_sections (const void *arg1, const void *arg2)\n   return sec1->target_index - sec2->target_index;\n }\n \n+/* This qsort comparison functions sorts PT_LOAD segments first and\n+   by p_paddr, for assign_file_positions_for_load_sections.  */\n+\n+static int\n+elf_sort_segments (const void *arg1, const void *arg2)\n+{\n+  const struct elf_segment_map *m1 = *(const struct elf_segment_map **) arg1;\n+  const struct elf_segment_map *m2 = *(const struct elf_segment_map **) arg2;\n+\n+  if (m1->p_type != m2->p_type)\n+    {\n+      if (m1->p_type == PT_NULL)\n+\treturn 1;\n+      if (m2->p_type == PT_NULL)\n+\treturn -1;\n+      return m1->p_type < m2->p_type ? -1 : 1;\n+    }\n+  if (m1->includes_filehdr != m2->includes_filehdr)\n+    return m1->includes_filehdr ? -1 : 1;\n+  if (m1->no_sort_lma != m2->no_sort_lma)\n+    return m1->no_sort_lma ? -1 : 1;\n+  if (m1->p_type == PT_LOAD && !m1->no_sort_lma)\n+    {\n+      bfd_vma lma1, lma2;\n+      lma1 = 0;\n+      if (m1->p_paddr_valid)\n+\tlma1 = m1->p_paddr;\n+      else if (m1->count != 0)\n+\tlma1 = m1->sections[0]->lma + m1->p_vaddr_offset;\n+      lma2 = 0;\n+      if (m2->p_paddr_valid)\n+\tlma2 = m2->p_paddr;\n+      else if (m2->count != 0)\n+\tlma2 = m2->sections[0]->lma + m2->p_vaddr_offset;\n+      if (lma1 != lma2)\n+\treturn lma1 < lma2 ? -1 : 1;\n+    }\n+  if (m1->idx != m2->idx)\n+    return m1->idx < m2->idx ? -1 : 1;\n+  return 0;\n+}\n+\n /* Ian Lance Taylor writes:\n \n    We shouldn't be using % with a negative signed number.  That's just\n@@ -5382,26 +5424,22 @@ assign_file_positions_for_load_sections (bfd *abfd,\n {\n   const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n   struct elf_segment_map *m;\n+  struct elf_segment_map *phdr_load_seg;\n   Elf_Internal_Phdr *phdrs;\n   Elf_Internal_Phdr *p;\n   file_ptr off;\n   bfd_size_type maxpagesize;\n-  unsigned int pt_load_count = 0;\n-  unsigned int alloc;\n+  unsigned int alloc, actual;\n   unsigned int i, j;\n-  bfd_vma header_pad = 0;\n+  struct elf_segment_map **sorted_seg_map;\n \n   if (link_info == NULL\n       && !_bfd_elf_map_sections_to_segments (abfd, link_info))\n     return FALSE;\n \n   alloc = 0;\n   for (m = elf_seg_map (abfd); m != NULL; m = m->next)\n-    {\n-      ++alloc;\n-      if (m->header_size)\n-\theader_pad = m->header_size;\n-    }\n+    m->idx = alloc++;\n \n   if (alloc)\n     {\n@@ -5418,10 +5456,17 @@ assign_file_positions_for_load_sections (bfd *abfd,\n   elf_elfheader (abfd)->e_phnum = alloc;\n \n   if (elf_program_header_size (abfd) == (bfd_size_type) -1)\n-    elf_program_header_size (abfd) = alloc * bed->s->sizeof_phdr;\n+    {\n+      actual = alloc;\n+      elf_program_header_size (abfd) = alloc * bed->s->sizeof_phdr;\n+    }\n   else\n-    BFD_ASSERT (elf_program_header_size (abfd)\n-\t\t>= alloc * bed->s->sizeof_phdr);\n+    {\n+      actual = elf_program_header_size (abfd) / bed->s->sizeof_phdr;\n+      BFD_ASSERT (elf_program_header_size (abfd)\n+\t\t  == actual * bed->s->sizeof_phdr);\n+      BFD_ASSERT (actual >= alloc);\n+    }\n \n   if (alloc == 0)\n     {\n@@ -5438,36 +5483,16 @@ assign_file_positions_for_load_sections (bfd *abfd,\n      See ld/emultempl/elf-generic.em:gld${EMULATION_NAME}_map_segments\n      where the layout is forced to according to a larger size in the\n      last iterations for the testcase ld-elf/header.  */\n-  BFD_ASSERT (elf_program_header_size (abfd) % bed->s->sizeof_phdr\n-\t      == 0);\n-  phdrs = (Elf_Internal_Phdr *)\n-     bfd_zalloc2 (abfd,\n-\t\t  (elf_program_header_size (abfd) / bed->s->sizeof_phdr),\n-\t\t  sizeof (Elf_Internal_Phdr));\n+  phdrs = bfd_zalloc (abfd, (actual * sizeof (*phdrs)\n+\t\t\t     + alloc * sizeof (*sorted_seg_map)));\n+  sorted_seg_map = (struct elf_segment_map **) (phdrs + actual);\n   elf_tdata (abfd)->phdr = phdrs;\n   if (phdrs == NULL)\n     return FALSE;\n \n-  maxpagesize = 1;\n-  if ((abfd->flags & D_PAGED) != 0)\n-    maxpagesize = bed->maxpagesize;\n-\n-  off = bed->s->sizeof_ehdr;\n-  off += alloc * bed->s->sizeof_phdr;\n-  if (header_pad < (bfd_vma) off)\n-    header_pad = 0;\n-  else\n-    header_pad -= off;\n-  off += header_pad;\n-\n-  for (m = elf_seg_map (abfd), p = phdrs, j = 0;\n-       m != NULL;\n-       m = m->next, p++, j++)\n+  for (m = elf_seg_map (abfd), j = 0; m != NULL; m = m->next, j++)\n     {\n-      asection **secpp;\n-      bfd_vma off_adjust;\n-      bfd_boolean no_contents;\n-\n+      sorted_seg_map[j] = m;\n       /* If elf_segment_map is not from map_sections_to_segments, the\n \t sections may not be correctly ordered.  NOTE: sorting should\n \t not be done to the PT_NOTE section of a corefile, which may\n@@ -5482,12 +5507,48 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t  qsort (m->sections, (size_t) m->count, sizeof (asection *),\n \t\t elf_sort_sections);\n \t}\n+    }\n+  if (alloc > 1)\n+    qsort (sorted_seg_map, alloc, sizeof (*sorted_seg_map),\n+\t   elf_sort_segments);\n+\n+  maxpagesize = 1;\n+  if ((abfd->flags & D_PAGED) != 0)\n+    maxpagesize = bed->maxpagesize;\n+\n+  /* Sections must map to file offsets past the ELF file header.  */\n+  off = bed->s->sizeof_ehdr;\n+  /* And if one of the PT_LOAD headers doesn't include the program\n+     headers then we'll be mapping program headers in the usual\n+     position after the ELF file header.  */\n+  phdr_load_seg = NULL;\n+  for (j = 0; j < alloc; j++)\n+    {\n+      m = sorted_seg_map[j];\n+      if (m->p_type != PT_LOAD)\n+\tbreak;\n+      if (m->includes_phdrs)\n+\t{\n+\t  phdr_load_seg = m;\n+\t  break;\n+\t}\n+    }\n+  if (phdr_load_seg == NULL)\n+    off += actual * bed->s->sizeof_phdr;\n+\n+  for (j = 0; j < alloc; j++)\n+    {\n+      asection **secpp;\n+      bfd_vma off_adjust;\n+      bfd_boolean no_contents;\n \n       /* An ELF segment (described by Elf_Internal_Phdr) may contain a\n \t number of sections with contents contributing to both p_filesz\n \t and p_memsz, followed by a number of sections with no contents\n \t that just contribute to p_memsz.  In this loop, OFF tracks next\n \t available file offset for PT_LOAD and PT_NOTE segments.  */\n+      m = sorted_seg_map[j];\n+      p = phdrs + m->idx;\n       p->p_type = m->p_type;\n       p->p_flags = m->p_flags;\n \n@@ -5518,14 +5579,18 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t    maxpagesize = m->p_align;\n \n \t  p->p_align = maxpagesize;\n-\t  pt_load_count += 1;\n \t}\n       else if (m->p_align_valid)\n \tp->p_align = m->p_align;\n       else if (m->count == 0)\n \tp->p_align = 1 << bed->s->log_file_align;\n-      else\n-\tp->p_align = 0;\n+\n+      if (m == phdr_load_seg)\n+\t{\n+\t  if (!m->includes_filehdr)\n+\t    p->p_offset = off;\n+\t  off += actual * bed->s->sizeof_phdr;\n+\t}\n \n       no_contents = FALSE;\n       off_adjust = 0;\n@@ -5574,7 +5639,8 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \t  /* Broken hardware and/or kernel require that files do not\n \t     map the same page with different permissions on some hppa\n \t     processors.  */\n-\t  if (pt_load_count > 1\n+\t  if (j != 0\n+\t      && (abfd->flags & D_PAGED) != 0\n \t      && bed->no_page_alias\n \t      && (off & (maxpagesize - 1)) != 0\n \t      && (off & -maxpagesize) == ((off + off_adjust) & -maxpagesize))\n@@ -5612,59 +5678,72 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \tfor (i = 0; i < m->count; i++)\n \t  elf_section_type (m->sections[i]) = SHT_NOTE;\n \n-      p->p_offset = 0;\n-      p->p_filesz = 0;\n-      p->p_memsz = 0;\n-\n       if (m->includes_filehdr)\n \t{\n \t  if (!m->p_flags_valid)\n \t    p->p_flags |= PF_R;\n \t  p->p_filesz = bed->s->sizeof_ehdr;\n \t  p->p_memsz = bed->s->sizeof_ehdr;\n-\t  if (m->count > 0)\n+\t  if (p->p_type == PT_LOAD)\n \t    {\n-\t      if (p->p_vaddr < (bfd_vma) off\n-\t\t  || (!m->p_paddr_valid\n-\t\t      && p->p_paddr < (bfd_vma) off))\n+\t      if (m->count > 0)\n \t\t{\n-\t\t  _bfd_error_handler\n-\t\t    (_(\"%pB: not enough room for program headers,\"\n-\t\t       \" try linking with -N\"),\n-\t\t     abfd);\n-\t\t  bfd_set_error (bfd_error_bad_value);\n-\t\t  return FALSE;\n+\t\t  if (p->p_vaddr < (bfd_vma) off\n+\t\t      || (!m->p_paddr_valid\n+\t\t\t  && p->p_paddr < (bfd_vma) off))\n+\t\t    {\n+\t\t      _bfd_error_handler\n+\t\t\t(_(\"%pB: not enough room for program headers,\"\n+\t\t\t   \" try linking with -N\"),\n+\t\t\t abfd);\n+\t\t      bfd_set_error (bfd_error_bad_value);\n+\t\t      return FALSE;\n+\t\t    }\n+\t\t  p->p_vaddr -= off;\n+\t\t  if (!m->p_paddr_valid)\n+\t\t    p->p_paddr -= off;\n \t\t}\n-\n-\t      p->p_vaddr -= off;\n+\t    }\n+\t  else if (sorted_seg_map[0]->includes_filehdr)\n+\t    {\n+\t      Elf_Internal_Phdr *filehdr = phdrs + sorted_seg_map[0]->idx;\n+\t      p->p_vaddr = filehdr->p_vaddr;\n \t      if (!m->p_paddr_valid)\n-\t\tp->p_paddr -= off;\n+\t\tp->p_paddr = filehdr->p_paddr;\n \t    }\n \t}\n \n       if (m->includes_phdrs)\n \t{\n \t  if (!m->p_flags_valid)\n \t    p->p_flags |= PF_R;\n-\n+\t  p->p_filesz += actual * bed->s->sizeof_phdr;\n+\t  p->p_memsz += actual * bed->s->sizeof_phdr;\n \t  if (!m->includes_filehdr)\n \t    {\n-\t      p->p_offset = bed->s->sizeof_ehdr;\n-\n-\t      if (m->count > 0)\n+\t      if (p->p_type == PT_LOAD)\n+\t\t{\n+\t\t  elf_elfheader (abfd)->e_phoff = p->p_offset;\n+\t\t  if (m->count > 0)\n+\t\t    {\n+\t\t      p->p_vaddr -= off - p->p_offset;\n+\t\t      if (!m->p_paddr_valid)\n+\t\t\tp->p_paddr -= off - p->p_offset;\n+\t\t    }\n+\t\t}\n+\t      else if (phdr_load_seg != NULL)\n \t\t{\n-\t\t  p->p_vaddr -= off - p->p_offset;\n+\t\t  Elf_Internal_Phdr *phdr = phdrs + phdr_load_seg->idx;\n+\t\t  bfd_vma phdr_off = 0;\n+\t\t  if (phdr_load_seg->includes_filehdr)\n+\t\t    phdr_off = bed->s->sizeof_ehdr;\n+\t\t  p->p_vaddr = phdr->p_vaddr + phdr_off;\n \t\t  if (!m->p_paddr_valid)\n-\t\t    p->p_paddr -= off - p->p_offset;\n+\t\t    p->p_paddr = phdr->p_paddr + phdr_off;\n+\t\t  p->p_offset = phdr->p_offset + phdr_off;\n \t\t}\n-\t    }\n-\n-\t  p->p_filesz += alloc * bed->s->sizeof_phdr;\n-\t  p->p_memsz += alloc * bed->s->sizeof_phdr;\n-\t  if (m->count)\n-\t    {\n-\t      p->p_filesz += header_pad;\n-\t      p->p_memsz += header_pad;\n+\t      else\n+\t\tp->p_offset = bed->s->sizeof_ehdr;\n \t    }\n \t}\n \n@@ -5726,16 +5805,19 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \n \t      if (this_hdr->sh_type != SHT_NOBITS)\n \t\t{\n-\t\t  if (p->p_filesz + adjust < p->p_memsz)\n+\t\t  if (p->p_type == PT_LOAD)\n \t\t    {\n-\t\t      /* We have a PROGBITS section following NOBITS ones.\n-\t\t\t Allocate file space for the NOBITS section(s) and\n-\t\t\t zero it.  */\n-\t\t      adjust = p->p_memsz - p->p_filesz;\n-\t\t      if (!write_zeros (abfd, off, adjust))\n-\t\t\treturn FALSE;\n+\t\t      if (p->p_filesz + adjust < p->p_memsz)\n+\t\t\t{\n+\t\t\t  /* We have a PROGBITS section following NOBITS ones.\n+\t\t\t     Allocate file space for the NOBITS section(s) and\n+\t\t\t     zero it.  */\n+\t\t\t  adjust = p->p_memsz - p->p_filesz;\n+\t\t\t  if (!write_zeros (abfd, off, adjust))\n+\t\t\t    return FALSE;\n+\t\t\t}\n+\t\t      off += adjust;\n \t\t    }\n-\t\t  off += adjust;\n \t\t  p->p_filesz += adjust;\n \t\t}\n \t    }\n@@ -5824,6 +5906,22 @@ assign_file_positions_for_load_sections (bfd *abfd,\n \n       off -= off_adjust;\n \n+      /* PR ld/20815 - Check that the program header segment, if\n+\t present, will be loaded into memory.  */\n+      if (p->p_type == PT_PHDR\n+\t  && phdr_load_seg == NULL\n+\t  && !(bed->elf_backend_allow_non_load_phdr != NULL\n+\t       && bed->elf_backend_allow_non_load_phdr (abfd, phdrs, alloc)))\n+\t{\n+\t  /* The fix for this error is usually to edit the linker script being\n+\t     used and set up the program headers manually.  Either that or\n+\t     leave room for the headers at the start of the SECTIONS.  */\n+\t  _bfd_error_handler (_(\"%pB: error: PHDR segment not covered\"\n+\t\t\t\t\" by LOAD segment\"),\n+\t\t\t      abfd);\n+\t  return FALSE;\n+\t}\n+\n       /* Check that all sections are in a PT_LOAD segment.\n \t Don't check funky gdb generated core files.  */\n       if (p->p_type == PT_LOAD && bfd_get_format (abfd) != bfd_core)\n@@ -5863,6 +5961,57 @@ assign_file_positions_for_load_sections (bfd *abfd,\n     }\n \n   elf_next_file_pos (abfd) = off;\n+\n+  if (link_info != NULL\n+      && phdr_load_seg != NULL\n+      && phdr_load_seg->includes_filehdr)\n+    {\n+      /* There is a segment that contains both the file headers and the\n+\t program headers, so provide a symbol __ehdr_start pointing there.\n+\t A program can use this to examine itself robustly.  */\n+\n+      struct elf_link_hash_entry *hash\n+\t= elf_link_hash_lookup (elf_hash_table (link_info), \"__ehdr_start\",\n+\t\t\t\tFALSE, FALSE, TRUE);\n+      /* If the symbol was referenced and not defined, define it.  */\n+      if (hash != NULL\n+\t  && (hash->root.type == bfd_link_hash_new\n+\t      || hash->root.type == bfd_link_hash_undefined\n+\t      || hash->root.type == bfd_link_hash_undefweak\n+\t      || hash->root.type == bfd_link_hash_common))\n+\t{\n+\t  asection *s = NULL;\n+\t  bfd_vma filehdr_vaddr = phdrs[phdr_load_seg->idx].p_vaddr;\n+\n+\t  if (phdr_load_seg->count != 0)\n+\t    /* The segment contains sections, so use the first one.  */\n+\t    s = phdr_load_seg->sections[0];\n+\t  else\n+\t    /* Use the first (i.e. lowest-addressed) section in any segment.  */\n+\t    for (m = elf_seg_map (abfd); m != NULL; m = m->next)\n+\t      if (m->p_type == PT_LOAD && m->count != 0)\n+\t\t{\n+\t\t  s = m->sections[0];\n+\t\t  break;\n+\t\t}\n+\n+\t  if (s != NULL)\n+\t    {\n+\t      hash->root.u.def.value = filehdr_vaddr - s->vma;\n+\t      hash->root.u.def.section = s;\n+\t    }\n+\t  else\n+\t    {\n+\t      hash->root.u.def.value = filehdr_vaddr;\n+\t      hash->root.u.def.section = bfd_abs_section_ptr;\n+\t    }\n+\n+\t  hash->root.type = bfd_link_hash_defined;\n+\t  hash->def_regular = 1;\n+\t  hash->non_elf = 0;\n+\t}\n+    }\n+\n   return TRUE;\n }\n \n@@ -5908,11 +6057,7 @@ assign_file_positions_for_non_load_sections (bfd *abfd,\n   Elf_Internal_Phdr *phdrs;\n   Elf_Internal_Phdr *p;\n   struct elf_segment_map *m;\n-  struct elf_segment_map *hdrs_segment;\n-  bfd_vma filehdr_vaddr, filehdr_paddr;\n-  bfd_vma phdrs_vaddr, phdrs_paddr;\n   file_ptr off;\n-  unsigned int count;\n \n   i_shdrpp = elf_elfsections (abfd);\n   end_hdrpp = i_shdrpp + elf_numsections (abfd);\n@@ -5970,86 +6115,11 @@ assign_file_positions_for_non_load_sections (bfd *abfd,\n       else\n \toff = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);\n     }\n+  elf_next_file_pos (abfd) = off;\n \n   /* Now that we have set the section file positions, we can set up\n      the file positions for the non PT_LOAD segments.  */\n-  count = 0;\n-  filehdr_vaddr = 0;\n-  filehdr_paddr = 0;\n-  phdrs_vaddr = bed->maxpagesize + bed->s->sizeof_ehdr;\n-  phdrs_paddr = 0;\n-  hdrs_segment = NULL;\n   phdrs = elf_tdata (abfd)->phdr;\n-  for (m = elf_seg_map (abfd), p = phdrs; m != NULL; m = m->next, p++)\n-    {\n-      ++count;\n-      if (p->p_type != PT_LOAD)\n-\tcontinue;\n-\n-      if (m->includes_filehdr)\n-\t{\n-\t  filehdr_vaddr = p->p_vaddr;\n-\t  filehdr_paddr = p->p_paddr;\n-\t}\n-      if (m->includes_phdrs)\n-\t{\n-\t  phdrs_vaddr = p->p_vaddr;\n-\t  phdrs_paddr = p->p_paddr;\n-\t  if (m->includes_filehdr)\n-\t    {\n-\t      hdrs_segment = m;\n-\t      phdrs_vaddr += bed->s->sizeof_ehdr;\n-\t      phdrs_paddr += bed->s->sizeof_ehdr;\n-\t    }\n-\t}\n-    }\n-\n-  if (hdrs_segment != NULL && link_info != NULL)\n-    {\n-      /* There is a segment that contains both the file headers and the\n-\t program headers, so provide a symbol __ehdr_start pointing there.\n-\t A program can use this to examine itself robustly.  */\n-\n-      struct elf_link_hash_entry *hash\n-\t= elf_link_hash_lookup (elf_hash_table (link_info), \"__ehdr_start\",\n-\t\t\t\tFALSE, FALSE, TRUE);\n-      /* If the symbol was referenced and not defined, define it.  */\n-      if (hash != NULL\n-\t  && (hash->root.type == bfd_link_hash_new\n-\t      || hash->root.type == bfd_link_hash_undefined\n-\t      || hash->root.type == bfd_link_hash_undefweak\n-\t      || hash->root.type == bfd_link_hash_common))\n-\t{\n-\t  asection *s = NULL;\n-\t  if (hdrs_segment->count != 0)\n-\t    /* The segment contains sections, so use the first one.  */\n-\t    s = hdrs_segment->sections[0];\n-\t  else\n-\t    /* Use the first (i.e. lowest-addressed) section in any segment.  */\n-\t    for (m = elf_seg_map (abfd); m != NULL; m = m->next)\n-\t      if (m->count != 0)\n-\t\t{\n-\t\t  s = m->sections[0];\n-\t\t  break;\n-\t\t}\n-\n-\t  if (s != NULL)\n-\t    {\n-\t      hash->root.u.def.value = filehdr_vaddr - s->vma;\n-\t      hash->root.u.def.section = s;\n-\t    }\n-\t  else\n-\t    {\n-\t      hash->root.u.def.value = filehdr_vaddr;\n-\t      hash->root.u.def.section = bfd_abs_section_ptr;\n-\t    }\n-\n-\t  hash->root.type = bfd_link_hash_defined;\n-\t  hash->def_regular = 1;\n-\t  hash->non_elf = 0;\n-\t}\n-    }\n-\n   for (m = elf_seg_map (abfd), p = phdrs; m != NULL; m = m->next, p++)\n     {\n       if (p->p_type == PT_GNU_RELRO)\n@@ -6195,22 +6265,8 @@ assign_file_positions_for_non_load_sections (bfd *abfd,\n \t\t}\n \t    }\n \t}\n-      else if (m->includes_filehdr)\n-\t{\n-\t  p->p_vaddr = filehdr_vaddr;\n-\t  if (! m->p_paddr_valid)\n-\t    p->p_paddr = filehdr_paddr;\n-\t}\n-      else if (m->includes_phdrs)\n-\t{\n-\t  p->p_vaddr = phdrs_vaddr;\n-\t  if (! m->p_paddr_valid)\n-\t    p->p_paddr = phdrs_paddr;\n-\t}\n     }\n \n-  elf_next_file_pos (abfd) = off;\n-\n   return TRUE;\n }\n \n@@ -6310,8 +6366,8 @@ assign_file_positions_except_relocs (bfd *abfd,\n       /* Set e_type in ELF header to ET_EXEC for -pie -Ttext-segment=.  */\n       if (link_info != NULL && bfd_link_pie (link_info))\n \t{\n-\t  unsigned int num_segments = elf_elfheader (abfd)->e_phnum;\n-\t  Elf_Internal_Phdr *segment = elf_tdata (abfd)->phdr;\n+\t  unsigned int num_segments = i_ehdrp->e_phnum;\n+\t  Elf_Internal_Phdr *segment = tdata->phdr;\n \t  Elf_Internal_Phdr *end_segment = &segment[num_segments];\n \n \t  /* Find the lowest p_vaddr in PT_LOAD segments.  */\n@@ -6326,42 +6382,16 @@ assign_file_positions_except_relocs (bfd *abfd,\n \t    i_ehdrp->e_type = ET_EXEC;\n \t}\n \n-      /* Write out the program headers.  */\n-      alloc = elf_elfheader (abfd)->e_phnum;\n-      if (alloc == 0)\n-\treturn TRUE;\n-\n-      /* PR ld/20815 - Check that the program header segment, if present, will\n-\t be loaded into memory.  FIXME: The check below is not sufficient as\n-\t really all PT_LOAD segments should be checked before issuing an error\n-\t message.  Plus the PHDR segment does not have to be the first segment\n-\t in the program header table.  But this version of the check should\n-\t catch all real world use cases.\n-\n+      /* Write out the program headers.\n \t FIXME: We used to have code here to sort the PT_LOAD segments into\n \t ascending order, as per the ELF spec.  But this breaks some programs,\n \t including the Linux kernel.  But really either the spec should be\n \t changed or the programs updated.  */\n-      if (alloc > 1\n-\t  && tdata->phdr[0].p_type == PT_PHDR\n-\t  && (bed->elf_backend_allow_non_load_phdr == NULL\n-\t      || !bed->elf_backend_allow_non_load_phdr (abfd, tdata->phdr,\n-\t\t\t\t\t\t\talloc))\n-\t  && tdata->phdr[1].p_type == PT_LOAD\n-\t  && (tdata->phdr[1].p_vaddr > tdata->phdr[0].p_vaddr\n-\t      || (tdata->phdr[1].p_vaddr + tdata->phdr[1].p_memsz\n-\t\t  < tdata->phdr[0].p_vaddr + tdata->phdr[0].p_memsz)))\n-\t{\n-\t  /* The fix for this error is usually to edit the linker script being\n-\t     used and set up the program headers manually.  Either that or\n-\t     leave room for the headers at the start of the SECTIONS.  */\n-\t  _bfd_error_handler (_(\"%pB: error: PHDR segment not covered\"\n-\t\t\t\t\" by LOAD segment\"),\n-\t\t\t      abfd);\n-\t  return FALSE;\n-\t}\n+      alloc = i_ehdrp->e_phnum;\n+      if (alloc == 0)\n+\treturn TRUE;\n \n-      if (bfd_seek (abfd, (bfd_signed_vma) bed->s->sizeof_ehdr, SEEK_SET) != 0\n+      if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) != 0\n \t  || bed->s->write_out_phdrs (abfd, tdata->phdr, alloc) != 0)\n \treturn FALSE;\n     }\n@@ -7185,14 +7215,18 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd)\n \t  pointer_to_map = &map->next;\n \n \t  if (p_paddr_valid\n-\t      && !bed->want_p_paddr_set_to_zero\n-\t      && matching_lma->lma != map->p_paddr\n-\t      && !map->includes_filehdr\n-\t      && !map->includes_phdrs)\n-\t    /* There is some padding before the first section in the\n-\t       segment.  So, we must account for that in the output\n-\t       segment's vma.  */\n-\t    map->p_vaddr_offset = map->p_paddr - matching_lma->lma;\n+\t      && !bed->want_p_paddr_set_to_zero)\n+\t    {\n+\t      bfd_vma hdr_size = 0;\n+\t      if (map->includes_filehdr)\n+\t\thdr_size = iehdr->e_ehsize;\n+\t      if (map->includes_phdrs)\n+\t\thdr_size += iehdr->e_phnum * iehdr->e_phentsize;\n+\n+\t      /* Account for padding before the first section in the\n+\t\t segment.  */\n+\t      map->p_vaddr_offset = map->p_paddr + hdr_size - matching_lma->lma;\n+\t    }\n \n \t  free (sections);\n \t  continue;\n@@ -7441,7 +7475,6 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)\n       Elf_Internal_Shdr *this_hdr;\n       asection *first_section = NULL;\n       asection *lowest_section;\n-      bfd_boolean no_contents = TRUE;\n \n       /* Compute how many sections are in this segment.  */\n       for (section = ibfd->sections, section_count = 0;\n@@ -7453,8 +7486,6 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)\n \t    {\n \t      if (first_section == NULL)\n \t\tfirst_section = section;\n-\t      if (elf_section_type (section) != SHT_NOBITS)\n-\t\tno_contents = FALSE;\n \t      section_count++;\n \t    }\n \t}\n@@ -7549,27 +7580,20 @@ copy_elf_program_header (bfd *ibfd, bfd *obfd)\n \t    }\n \t}\n \n-      if (map->includes_filehdr && lowest_section != NULL)\n-\t{\n-\t  /* Try to keep the space used by the headers plus any\n-\t     padding fixed.  If there are sections with file contents\n-\t     in this segment then the lowest sh_offset is the best\n-\t     guess.  Otherwise the segment only has file contents for\n-\t     the headers, and p_filesz is the best guess.  */\n-\t  if (no_contents)\n-\t    map->header_size = segment->p_filesz;\n-\t  else\n-\t    map->header_size = lowest_section->filepos;\n-\t}\n-\n       if (section_count == 0)\n \tmap->p_vaddr_offset = segment->p_vaddr;\n-      else if (!map->includes_phdrs\n-\t       && !map->includes_filehdr\n-\t       && map->p_paddr_valid)\n-\t/* Account for padding before the first section.  */\n-\tmap->p_vaddr_offset = (segment->p_paddr\n-\t\t\t       - (lowest_section ? lowest_section->lma : 0));\n+      else if (map->p_paddr_valid)\n+\t{\n+\t  /* Account for padding before the first section in the segment.  */\n+\t  bfd_vma hdr_size = 0;\n+\t  if (map->includes_filehdr)\n+\t    hdr_size = iehdr->e_ehsize;\n+\t  if (map->includes_phdrs)\n+\t    hdr_size += iehdr->e_phnum * iehdr->e_phentsize;\n+\n+\t  map->p_vaddr_offset = (map->p_paddr + hdr_size\n+\t\t\t\t - (lowest_section ? lowest_section->lma : 0));\n+\t}\n \n       map->count = section_count;\n       *pointer_to_map = map;"
    },
    {
      "sha": "b557c865b3eb2d0b9497ac32e5cd714eeb1331b3",
      "filename": "bfd/elf32-spu.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30fe183248b2523ecff9da36853e2f893c4c4b91/bfd/elf32-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30fe183248b2523ecff9da36853e2f893c4c4b91/bfd/elf32-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-spu.c?ref=30fe183248b2523ecff9da36853e2f893c4c4b91",
      "patch": "@@ -5302,6 +5302,7 @@ spu_elf_modify_segment_map (bfd *abfd, struct bfd_link_info *info)\n \t      && spu_elf_section_data ((*p)->sections[0])->u.o.ovl_index != 0)\n \t    {\n \t      m = *p;\n+\t      m->no_sort_lma = 1;\n \t      *p = m->next;\n \t      *p_overlay = m;\n \t      p_overlay = &m->next;"
    },
    {
      "sha": "1b3a519f6ce3d4a320b878bfd0306ec70dd05ff4",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30fe183248b2523ecff9da36853e2f893c4c4b91/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30fe183248b2523ecff9da36853e2f893c4c4b91/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=30fe183248b2523ecff9da36853e2f893c4c4b91",
      "patch": "@@ -1,3 +1,9 @@\n+2019-10-25  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 4499\n+\t* elf/internal.h (struct elf_segment_map): Delete header_size.\n+\tAdd no_sort_lma and idx.\n+\n 2019-10-16  Alan Modra  <amodra@gmail.com>\n \n \tPR 13616"
    },
    {
      "sha": "794c16812eea6c3cb6acda720203920549364500",
      "filename": "include/elf/internal.h",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30fe183248b2523ecff9da36853e2f893c4c4b91/include/elf/internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30fe183248b2523ecff9da36853e2f893c4c4b91/include/elf/internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/elf/internal.h?ref=30fe183248b2523ecff9da36853e2f893c4c4b91",
      "patch": "@@ -273,8 +273,6 @@ struct elf_segment_map\n   bfd_vma p_align;\n   /* Segment size in file and memory */\n   bfd_vma p_size;\n-  /* Required size of filehdr + phdrs, if non-zero */\n-  bfd_vma header_size;\n   /* Whether the p_flags field is valid; if not, the flags are based\n      on the section flags.  */\n   unsigned int p_flags_valid : 1;\n@@ -291,6 +289,13 @@ struct elf_segment_map\n   unsigned int includes_filehdr : 1;\n   /* Whether this segment includes the program headers.  */\n   unsigned int includes_phdrs : 1;\n+  /* Assume this PT_LOAD header has an lma of zero when sorting\n+     headers before assigning file offsets.  PT_LOAD headers with this\n+     flag set are placed after one with includes_filehdr set, and\n+     before PT_LOAD headers without this flag set.  */\n+  unsigned int no_sort_lma : 1;\n+  /* Index holding original order before sorting segments.  */\n+  unsigned int idx;\n   /* Number of sections (may be 0).  */\n   unsigned int count;\n   /* Sections.  Actual number of elements is in count field.  */"
    }
  ]
}