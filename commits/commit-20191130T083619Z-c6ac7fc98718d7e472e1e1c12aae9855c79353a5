{
  "sha": "c6ac7fc98718d7e472e1e1c12aae9855c79353a5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzZhYzdmYzk4NzE4ZDdlNDcyZTFlMWMxMmFhZTk4NTVjNzkzNTNhNQ==",
  "commit": {
    "author": {
      "name": "Philippe Waroquiers",
      "email": "philippe.waroquiers@skynet.be",
      "date": "2019-09-08T13:48:32Z"
    },
    "committer": {
      "name": "Philippe Waroquiers",
      "email": "philippe.waroquiers@skynet.be",
      "date": "2019-11-30T08:36:19Z"
    },
    "message": "Implement user defined prefix.\n\nThis patch adds the new 'define-prefix' command that creates (or mark an\nexisting user defined command) as a prefix command.\nThis approach was preferred compared to add a -prefix option to\n'define' command : with define-prefix, a command can be defined and\nafterwards marked as a prefix.  Also, it is easier to define a\n'prefix' only command in one operation.\n\nThis patch also adds completers for the 'define' and 'document' commands.\nThis makes it easier for the user to type the prefixes for 'define'\nand type the documented command name for 'document'.\n\ngdb/ChangeLog\n2019-11-30  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n\n\t* cli/cli-script.c (do_define_command): Ensure a redefined\n\tprefix command is kept as a prefix command.\n\t(define_prefix_command): New function.\n\t(show_user_1): Report user defined prefixes.\n\t(_initialize_cli_script):  Create the new 'define-prefix' command.\n\tAdd completers for 'define' and 'document'.\n\t* top.c (execute_command):  If command is a user-defined prefix only\n\tcommand, report the list of commands for this prefix command.",
    "tree": {
      "sha": "0bf31537b160a0ecb05b60880735e15e8ec18b1b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0bf31537b160a0ecb05b60880735e15e8ec18b1b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c6ac7fc98718d7e472e1e1c12aae9855c79353a5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c6ac7fc98718d7e472e1e1c12aae9855c79353a5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c6ac7fc98718d7e472e1e1c12aae9855c79353a5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c6ac7fc98718d7e472e1e1c12aae9855c79353a5/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "ce4331325cd8407c32407c03e3126fb1dc120304",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ce4331325cd8407c32407c03e3126fb1dc120304",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ce4331325cd8407c32407c03e3126fb1dc120304"
    }
  ],
  "stats": {
    "total": 151,
    "additions": 135,
    "deletions": 16
  },
  "files": [
    {
      "sha": "d123622a42460939fc43e507a90c42767b224abd",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c6ac7fc98718d7e472e1e1c12aae9855c79353a5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c6ac7fc98718d7e472e1e1c12aae9855c79353a5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c6ac7fc98718d7e472e1e1c12aae9855c79353a5",
      "patch": "@@ -1,3 +1,14 @@\n+2019-11-30  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n+\n+\t* cli/cli-script.c (do_define_command): Ensure a redefined\n+\tprefix command is kept as a prefix command.\n+\t(define_prefix_command): New function.\n+\t(show_user_1): Report user defined prefixes.\n+\t(_initialize_cli_script):  Create the new 'define-prefix' command.\n+\tAdd completers for 'define' and 'document'.\n+\t* top.c (execute_command):  If command is a user-defined prefix only\n+\tcommand, report the list of commands for this prefix command.\n+\n 2019-11-29  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* valops.c (find_oload_champ): Improve debug output."
    },
    {
      "sha": "55dcb3435b02360de939fc34981f2c1580582c80",
      "filename": "gdb/cli/cli-script.c",
      "status": "modified",
      "additions": 112,
      "deletions": 16,
      "changes": 128,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c6ac7fc98718d7e472e1e1c12aae9855c79353a5/gdb/cli/cli-script.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c6ac7fc98718d7e472e1e1c12aae9855c79353a5/gdb/cli/cli-script.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-script.c?ref=c6ac7fc98718d7e472e1e1c12aae9855c79353a5",
      "patch": "@@ -29,6 +29,7 @@\n #include \"cli/cli-cmds.h\"\n #include \"cli/cli-decode.h\"\n #include \"cli/cli-script.h\"\n+#include \"cli/cli-style.h\"\n \n #include \"extension.h\"\n #include \"interps.h\"\n@@ -1395,7 +1396,17 @@ do_define_command (const char *comname, int from_tty,\n       int q;\n \n       if (c->theclass == class_user || c->theclass == class_alias)\n-\tq = query (_(\"Redefine command \\\"%s\\\"? \"), c->name);\n+\t{\n+\t  /* if C is a prefix command that was previously defined,\n+\t     tell the user its subcommands will be kept, and ask\n+\t     if ok to redefine the command.  */\n+\t  if (c->prefixlist != nullptr)\n+\t    q = (c->user_commands.get () == nullptr\n+\t\t || query (_(\"Keeping subcommands of prefix command \\\"%s\\\".\\n\"\n+\t\t\t     \"Redefine command \\\"%s\\\"? \"), c->name, c->name));\n+\t  else\n+\t    q = query (_(\"Redefine command \\\"%s\\\"? \"), c->name);\n+\t}\n       else\n \tq = query (_(\"Really redefine built-in command \\\"%s\\\"? \"), c->name);\n       if (!q)\n@@ -1416,7 +1427,7 @@ do_define_command (const char *comname, int from_tty,\n       hook_type      = CMD_POST_HOOK;\n       hook_name_size = HOOK_POST_LEN;\n     }\n-   \n+\n   if (hook_type != CMD_NO_HOOK)\n     {\n       /* Look up cmd it hooks, and verify that we got an exact match.  */\n@@ -1446,10 +1457,27 @@ do_define_command (const char *comname, int from_tty,\n   else\n     cmds = *commands;\n \n-  newc = add_cmd (comname, class_user, user_defined_command,\n-\t\t  (c && c->theclass == class_user)\n-\t\t  ? c->doc : xstrdup (\"User-defined.\"), list);\n-  newc->user_commands = std::move (cmds);\n+  {\n+    struct cmd_list_element **c_prefixlist\n+      = c == nullptr ? nullptr : c->prefixlist;\n+    const char *c_prefixname = c == nullptr ? nullptr : c->prefixname;\n+\n+    newc = add_cmd (comname, class_user, user_defined_command,\n+\t\t    (c != nullptr && c->theclass == class_user)\n+\t\t    ? c->doc : xstrdup (\"User-defined.\"), list);\n+    newc->user_commands = std::move (cmds);\n+\n+    /* If we define or re-define a command that was previously defined\n+       as a prefix, keep the prefix information.  */\n+    if (c_prefixlist != nullptr)\n+      {\n+\tnewc->prefixlist = c_prefixlist;\n+\tnewc->prefixname = c_prefixname;\n+\t/* allow_unknown: see explanation in equivalent logic in\n+\t   define_prefix_command ().  */\n+\tnewc->allow_unknown = newc->user_commands.get () != nullptr;\n+    }\n+  }\n \n   /* If this new command is a hook, then mark both commands as being\n      tied.  */\n@@ -1524,6 +1552,54 @@ document_command (const char *comname, int from_tty)\n     c->doc = doc;\n   }\n }\n+\n+/* Implementation of the \"define-prefix\" command.  */\n+\n+static void\n+define_prefix_command (const char *comname, int from_tty)\n+{\n+  struct cmd_list_element *c, **list;\n+  const char *tem;\n+  const char *comfull;\n+\n+  comfull = comname;\n+  list = validate_comname (&comname);\n+\n+  /* Look it up, and verify that we got an exact match.  */\n+  tem = comname;\n+  c = lookup_cmd (&tem, *list, \"\", -1, 1);\n+  if (c != nullptr && strcmp (comname, c->name) != 0)\n+    c = nullptr;\n+\n+  if (c != nullptr && c->theclass != class_user)\n+    error (_(\"Command \\\"%s\\\" is built-in.\"), comfull);\n+\n+  if (c != nullptr && c->prefixlist != nullptr)\n+    {\n+      /* c is already a user defined prefix command.  */\n+      return;\n+    }\n+\n+  /* If the command does not exist at all, create it.  */\n+  if (c == nullptr)\n+    {\n+      comname = xstrdup (comname);\n+      c = add_cmd (comname, class_user, user_defined_command,\n+\t\t   xstrdup (\"User-defined.\"), list);\n+    }\n+\n+  /* Allocate the c->prefixlist, which marks the command as a prefix\n+     command.  */\n+  c->prefixlist = new struct cmd_list_element*;\n+  *(c->prefixlist) = nullptr;\n+  c->prefixname = xstrprintf (\"%s \", comfull);\n+  /* If the prefix command C is not a command, then it must be followed\n+     by known subcommands.  Otherwise, if C is also a normal command,\n+     it can be followed by C args that must not cause a 'subcommand'\n+     not recognised error, and thus we must allow unknown.  */\n+  c->allow_unknown = c->user_commands.get () != nullptr;\n+}\n+\n \f\n /* Used to implement source_command.  */\n \n@@ -1564,7 +1640,21 @@ void\n show_user_1 (struct cmd_list_element *c, const char *prefix, const char *name,\n \t     struct ui_file *stream)\n {\n-  struct command_line *cmdlines;\n+  if (cli_user_command_p (c))\n+    {\n+      struct command_line *cmdlines = c->user_commands.get ();\n+\n+      fprintf_filtered (stream, \"User %scommand \\\"\",\n+\t\t\tc->prefixlist == NULL ? \"\" : \"prefix \");\n+      fprintf_styled (stream, title_style.style (), \"%s%s\",\n+\t\t      prefix, name);\n+      fprintf_filtered (stream, \"\\\":\\n\");\n+      if (cmdlines)\n+\t{\n+\t  print_command_lines (current_uiout, cmdlines, 1);\n+\t  fputs_filtered (\"\\n\", stream);\n+\t}\n+    }\n \n   if (c->prefixlist != NULL)\n     {\n@@ -1573,25 +1663,23 @@ show_user_1 (struct cmd_list_element *c, const char *prefix, const char *name,\n       for (c = *c->prefixlist; c != NULL; c = c->next)\n \tif (c->theclass == class_user || c->prefixlist != NULL)\n \t  show_user_1 (c, prefixname, c->name, gdb_stdout);\n-      return;\n     }\n \n-  cmdlines = c->user_commands.get ();\n-  fprintf_filtered (stream, \"User command \\\"%s%s\\\":\\n\", prefix, name);\n-\n-  if (!cmdlines)\n-    return;\n-  print_command_lines (current_uiout, cmdlines, 1);\n-  fputs_filtered (\"\\n\", stream);\n }\n \n void\n _initialize_cli_script (void)\n {\n-  add_com (\"document\", class_support, document_command, _(\"\\\n+  struct cmd_list_element *c;\n+\n+  /* \"document\", \"define\" and \"define-prefix\" use command_completer,\n+     as this helps the user to either type the command name and/or\n+     its prefixes.  */\n+  c = add_com (\"document\", class_support, document_command, _(\"\\\n Document a user-defined command.\\n\\\n Give command name as argument.  Give documentation on following lines.\\n\\\n End with a line of just \\\"end\\\".\"));\n+  set_cmd_completer (c, command_completer);\n   define_cmd_element = add_com (\"define\", class_support, define_command, _(\"\\\n Define a new command name.  Command name is argument.\\n\\\n Definition appears on following lines, one command per line.\\n\\\n@@ -1600,6 +1688,14 @@ Use the \\\"document\\\" command to give documentation for the new command.\\n\\\n Commands defined in this way may accept an unlimited number of arguments\\n\\\n accessed via $arg0 .. $argN.  $argc tells how many arguments have\\n\\\n been passed.\"));\n+  set_cmd_completer (define_cmd_element, command_completer);\n+  c = add_com (\"define-prefix\", class_support, define_prefix_command,\n+\t   _(\"\\\n+Define or mark a command as a user-defined prefix command.\\n\\\n+User defined prefix commands can be used as prefix commands for\\n\\\n+other user defined commands.\\n\\\n+If the command already exists, it is changed to a prefix command.\"));\n+  set_cmd_completer (c, command_completer);\n \n   while_cmd_element = add_com (\"while\", class_support, while_command, _(\"\\\n Execute nested commands WHILE the conditional expression is non zero.\\n\\"
    },
    {
      "sha": "e8ed3b2747eebc8b1414225984e009ddc82630ee",
      "filename": "gdb/top.c",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c6ac7fc98718d7e472e1e1c12aae9855c79353a5/gdb/top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c6ac7fc98718d7e472e1e1c12aae9855c79353a5/gdb/top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/top.c?ref=c6ac7fc98718d7e472e1e1c12aae9855c79353a5",
      "patch": "@@ -627,6 +627,18 @@ execute_command (const char *p, int from_tty)\n       /* c->user_commands would be NULL in the case of a python command.  */\n       if (c->theclass == class_user && c->user_commands)\n \texecute_user_command (c, arg);\n+      else if (c->theclass == class_user\n+\t       && c->prefixlist && !c->allow_unknown)\n+\t/* If this is a user defined prefix that does not allow unknown\n+\t   (in other words, C is a prefix command and not a command\n+\t   that can be followed by its args), report the list of\n+\t   subcommands.  */\n+\t{\n+\t  printf_unfiltered\n+\t    (\"\\\"%.*s\\\" must be followed by the name of a subcommand.\\n\",\n+\t     (int) strlen (c->prefixname) - 1, c->prefixname);\n+\t  help_list (*c->prefixlist, c->prefixname, all_commands, gdb_stdout);\n+\t}\n       else if (c->type == set_cmd)\n \tdo_set_command (arg, from_tty, c);\n       else if (c->type == show_cmd)"
    }
  ]
}