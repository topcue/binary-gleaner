{
  "sha": "733ae98cb8fb0d5653887cfd79aec3cfe5e44846",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzMzYWU5OGNiOGZiMGQ1NjUzODg3Y2ZkNzlhZWMzY2ZlNWU0NDg0Ng==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-09-08T03:48:02Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-09-08T12:52:34Z"
    },
    "message": "PowerPC64, sanity check r_offset in relocate_section\n\nThis hardens the powerpc64 linker code transformations.\n\n\t* elf64-ppc.c (is_8byte_reloc, offset_in_range): New functions.\n\t(ppc64_elf_relocate_section): Sanity check r_offset before\n\taccessing section contents for various code transformations.",
    "tree": {
      "sha": "98dcd9c74201869ba26ae57e9d6931c3bbd1cf32",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/98dcd9c74201869ba26ae57e9d6931c3bbd1cf32"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/733ae98cb8fb0d5653887cfd79aec3cfe5e44846",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/733ae98cb8fb0d5653887cfd79aec3cfe5e44846",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/733ae98cb8fb0d5653887cfd79aec3cfe5e44846",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/733ae98cb8fb0d5653887cfd79aec3cfe5e44846/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "beaddc1a805d70131ffbeaee4d8d4ba41b9e5a2e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/beaddc1a805d70131ffbeaee4d8d4ba41b9e5a2e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/beaddc1a805d70131ffbeaee4d8d4ba41b9e5a2e"
    }
  ],
  "stats": {
    "total": 168,
    "additions": 119,
    "deletions": 49
  },
  "files": [
    {
      "sha": "4ebacbd99457bcc6ea1d239159bd9d8b065115dc",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 119,
      "deletions": 49,
      "changes": 168,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/733ae98cb8fb0d5653887cfd79aec3cfe5e44846/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/733ae98cb8fb0d5653887cfd79aec3cfe5e44846/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=733ae98cb8fb0d5653887cfd79aec3cfe5e44846",
      "patch": "@@ -4601,6 +4601,26 @@ is_plt_seq_reloc (enum elf_ppc64_reloc_type r_type)\n \t  || r_type == R_PPC64_PLTSEQ_NOTOC);\n }\n \n+/* Of relocs which might appear paired with TLSGD and TLSLD marker\n+   relocs, return true for those that operate on a dword.  */\n+\n+static bool\n+is_8byte_reloc (enum elf_ppc64_reloc_type r_type)\n+{\n+  return (r_type == R_PPC64_PLT_PCREL34\n+\t  || r_type == R_PPC64_PLT_PCREL34_NOTOC\n+\t  || r_type == R_PPC64_PLTCALL);\n+}\n+\n+/* Like bfd_reloc_offset_in_range but without a howto.  Return true\n+   iff a field of SIZE bytes at OFFSET is within SEC limits.  */\n+\n+static bool\n+offset_in_range (asection *sec, bfd_vma offset, size_t size)\n+{\n+  return offset <= sec->size && size <= sec->size - offset;\n+}\n+\n /* Look through the relocs for a section during the first phase, and\n    calculate needed space in the global offset table, procedure\n    linkage table, and dynamic reloc sections.  */\n@@ -15222,13 +15242,18 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  break;\n \n \tcase R_PPC64_LO_DS_OPT:\n-\t  insn = bfd_get_32 (input_bfd, contents + rel->r_offset - d_offset);\n-\t  if ((insn & (0x3fu << 26)) != 58u << 26)\n-\t    abort ();\n-\t  insn += (14u << 26) - (58u << 26);\n-\t  bfd_put_32 (input_bfd, insn, contents + rel->r_offset - d_offset);\n-\t  r_type = R_PPC64_TOC16_LO;\n-\t  rel->r_info = ELF64_R_INFO (r_symndx, r_type);\n+\t  if (offset_in_range (input_section, rel->r_offset - d_offset, 4))\n+\t    {\n+\t      insn = bfd_get_32 (input_bfd,\n+\t\t\t\t contents + rel->r_offset - d_offset);\n+\t      if ((insn & (0x3fu << 26)) != 58u << 26)\n+\t\tabort ();\n+\t      insn += (14u << 26) - (58u << 26);\n+\t      bfd_put_32 (input_bfd, insn,\n+\t\t\t  contents + rel->r_offset - d_offset);\n+\t      r_type = R_PPC64_TOC16_LO;\n+\t      rel->r_info = ELF64_R_INFO (r_symndx, r_type);\n+\t    }\n \t  break;\n \n \tcase R_PPC64_TOC16:\n@@ -15280,7 +15305,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_GOT_TPREL16_HI:\n \tcase R_PPC64_GOT_TPREL16_HA:\n \t  if ((tls_mask & TLS_TLS) != 0\n-\t      && (tls_mask & TLS_TPREL) == 0)\n+\t      && (tls_mask & TLS_TPREL) == 0\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    {\n \t      rel->r_offset -= d_offset;\n \t      bfd_put_32 (input_bfd, NOP, contents + rel->r_offset);\n@@ -15292,7 +15318,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_GOT_TPREL16_DS:\n \tcase R_PPC64_GOT_TPREL16_LO_DS:\n \t  if ((tls_mask & TLS_TLS) != 0\n-\t      && (tls_mask & TLS_TPREL) == 0)\n+\t      && (tls_mask & TLS_TPREL) == 0\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    {\n \t    toctprel:\n \t      insn = bfd_get_32 (input_bfd,\n@@ -15317,7 +15344,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC64_GOT_TPREL_PCREL34:\n \t  if ((tls_mask & TLS_TLS) != 0\n-\t      && (tls_mask & TLS_TPREL) == 0)\n+\t      && (tls_mask & TLS_TPREL) == 0\n+\t      && offset_in_range (input_section, rel->r_offset, 8))\n \t    {\n \t      /* pld ra,sym@got@tprel@pcrel -> paddi ra,r13,sym@tprel  */\n \t      pinsn = bfd_get_32 (input_bfd, contents + rel->r_offset);\n@@ -15336,7 +15364,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC64_TLS:\n \t  if ((tls_mask & TLS_TLS) != 0\n-\t      && (tls_mask & TLS_TPREL) == 0)\n+\t      && (tls_mask & TLS_TPREL) == 0\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t      insn = bfd_get_32 (input_bfd, contents + (rel->r_offset & ~3));\n \t      insn = _bfd_elf_ppc_at_tls_transform (insn, 13);\n@@ -15387,13 +15416,15 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_GOT_TLSGD16_HI:\n \tcase R_PPC64_GOT_TLSGD16_HA:\n \t  tls_gd = TLS_GDIE;\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    goto tls_gdld_hi;\n \t  break;\n \n \tcase R_PPC64_GOT_TLSLD16_HI:\n \tcase R_PPC64_GOT_TLSLD16_HA:\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t    tls_gdld_hi:\n \t      if ((tls_mask & tls_gd) != 0)\n@@ -15412,13 +15443,15 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_GOT_TLSGD16:\n \tcase R_PPC64_GOT_TLSGD16_LO:\n \t  tls_gd = TLS_GDIE;\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    goto tls_ldgd_opt;\n \t  break;\n \n \tcase R_PPC64_GOT_TLSLD16:\n \tcase R_PPC64_GOT_TLSLD16_LO:\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t      unsigned int insn1, insn2;\n \n@@ -15488,10 +15521,11 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t}\n \t      bfd_put_32 (input_bfd, insn1,\n \t\t\t  contents + rel->r_offset - d_offset);\n-\t      if (offset != (bfd_vma) -1)\n+\t      if (offset != (bfd_vma) -1\n+\t\t  && offset_in_range (input_section, offset, 4))\n \t\t{\n \t\t  bfd_put_32 (input_bfd, insn2, contents + offset);\n-\t\t  if (offset + 8 <= input_section->size)\n+\t\t  if (offset_in_range (input_section, offset + 4, 4))\n \t\t    {\n \t\t      insn2 = bfd_get_32 (input_bfd, contents + offset + 4);\n \t\t      if (insn2 == LD_R2_0R1 + STK_TOC (htab))\n@@ -15509,7 +15543,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  break;\n \n \tcase R_PPC64_GOT_TLSGD_PCREL34:\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset, 8))\n \t    {\n \t      pinsn = bfd_get_32 (input_bfd, contents + rel->r_offset);\n \t      pinsn <<= 32;\n@@ -15535,7 +15570,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  break;\n \n \tcase R_PPC64_GOT_TLSLD_PCREL34:\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset, 8))\n \t    {\n \t      pinsn = bfd_get_32 (input_bfd, contents + rel->r_offset);\n \t      pinsn <<= 32;\n@@ -15555,7 +15591,10 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC64_TLSGD:\n \t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0\n-\t      && rel + 1 < relend)\n+\t      && rel + 1 < relend\n+\t      && offset_in_range (input_section, rel->r_offset,\n+\t\t\t\t  is_8byte_reloc (ELF64_R_TYPE (rel[1].r_info))\n+\t\t\t\t  ? 8 : 4))\n \t    {\n \t      unsigned int insn2;\n \t      enum elf_ppc64_reloc_type r_type1 = ELF64_R_TYPE (rel[1].r_info);\n@@ -15571,7 +15610,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t  break;\n \t\t}\n \n-\t      if (ELF64_R_TYPE (rel[1].r_info) == R_PPC64_PLTCALL)\n+\t      if (r_type1 == R_PPC64_PLTCALL)\n \t\tbfd_put_32 (output_bfd, NOP, contents + offset + 4);\n \n \t      if ((tls_mask & TLS_GDIE) != 0)\n@@ -15615,7 +15654,10 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC64_TLSLD:\n \t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0\n-\t      && rel + 1 < relend)\n+\t      && rel + 1 < relend\n+\t      && offset_in_range (input_section, rel->r_offset,\n+\t\t\t\t  is_8byte_reloc (ELF64_R_TYPE (rel[1].r_info))\n+\t\t\t\t  ? 8 : 4))\n \t    {\n \t      unsigned int insn2;\n \t      enum elf_ppc64_reloc_type r_type1 = ELF64_R_TYPE (rel[1].r_info);\n@@ -15631,7 +15673,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t  break;\n \t\t}\n \n-\t      if (ELF64_R_TYPE (rel[1].r_info) == R_PPC64_PLTCALL)\n+\t      if (r_type1 == R_PPC64_PLTCALL)\n \t\tbfd_put_32 (output_bfd, NOP, contents + offset + 4);\n \n \t      if (r_type1 == R_PPC64_REL24_NOTOC\n@@ -15663,7 +15705,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)\n \t      && rel[1].r_offset == rel->r_offset + 8)\n \t    {\n-\t      if ((tls_mask & TLS_GD) == 0)\n+\t      if ((tls_mask & TLS_GD) == 0\n+\t\t  && offset_in_range (input_section, rel->r_offset, 8))\n \t\t{\n \t\t  rel[1].r_info = ELF64_R_INFO (r_symndx, R_PPC64_NONE);\n \t\t  if ((tls_mask & TLS_GDIE) != 0)\n@@ -15678,7 +15721,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t    }\n \t  else\n \t    {\n-\t      if ((tls_mask & TLS_LD) == 0)\n+\t      if ((tls_mask & TLS_LD) == 0\n+\t\t  && offset_in_range (input_section, rel->r_offset, 8))\n \t\t{\n \t\t  bfd_put_64 (output_bfd, 1, contents + rel->r_offset);\n \t\t  r_type = R_PPC64_NONE;\n@@ -15699,7 +15743,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  relocation = TOCstart + htab->sec_info[input_section->id].toc_off;\n \t  if (!bfd_link_pic (info)\n \t      && !info->traditional_format\n-\t      && relocation + 0x80008000 <= 0xffffffff)\n+\t      && relocation + 0x80008000 <= 0xffffffff\n+\t      && offset_in_range (input_section, rel->r_offset, 8))\n \t    {\n \t      unsigned int insn1, insn2;\n \n@@ -15721,7 +15766,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      relocation -= (rel->r_offset\n \t\t\t     + input_section->output_offset\n \t\t\t     + input_section->output_section->vma);\n-\t      if (relocation + 0x80008000 <= 0xffffffff)\n+\t      if (relocation + 0x80008000 <= 0xffffffff\n+\t\t  && offset_in_range (input_section, rel->r_offset, 8))\n \t\t{\n \t\t  unsigned int insn1, insn2;\n \n@@ -15758,7 +15804,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_REL16_LO)\n \t      && rel[1].r_offset == rel->r_offset + 4\n \t      && rel[1].r_addend == rel->r_addend + 4\n-\t      && relocation + 0x80008000 <= 0xffffffff)\n+\t      && relocation + 0x80008000 <= 0xffffffff\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 8))\n \t    {\n \t      unsigned int insn1, insn2;\n \t      offset = rel->r_offset - d_offset;\n@@ -15793,7 +15840,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t\t\t      + input_section->output_offset\n \t\t\t\t      + input_section->output_section->vma)\n \t      && tocsave_find (htab, NO_INSERT,\n-\t\t\t       &local_syms, rel, input_bfd))\n+\t\t\t       &local_syms, rel, input_bfd)\n+\t      && offset_in_range (input_section, rel->r_offset, 4))\n \t    {\n \t      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);\n \t      if (insn == NOP\n@@ -15813,6 +15861,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  /* Branch not taken prediction relocations.  */\n \tcase R_PPC64_ADDR14_BRNTAKEN:\n \tcase R_PPC64_REL14_BRNTAKEN:\n+\t  if (!offset_in_range (input_section, rel->r_offset, 4))\n+\t    break;\n \t  insn |= bfd_get_32 (input_bfd,\n \t\t\t      contents + rel->r_offset) & ~(0x01 << 21);\n \t  /* Fall through.  */\n@@ -15873,7 +15923,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      /* All of these stubs may modify r2, so there must be a\n \t\t branch and link followed by a nop.  The nop is\n \t\t replaced by an insn to restore r2.  */\n-\t      else if (rel->r_offset + 8 <= input_section->size)\n+\t      else if (offset_in_range (input_section, rel->r_offset, 8))\n \t\t{\n \t\t  unsigned long br;\n \n@@ -16111,7 +16161,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t   && (r_type == R_PPC64_REL24\n \t\t       || r_type == R_PPC64_REL24_NOTOC)\n \t\t   && relocation == 0\n-\t\t   && addend == 0)\n+\t\t   && addend == 0\n+\t\t   && offset_in_range (input_section, rel->r_offset, 4))\n \t    {\n \t      bfd_put_32 (input_bfd, NOP, contents + rel->r_offset);\n \t      goto copy_reloc;\n@@ -16127,7 +16178,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      && sec != NULL\n \t      && sec->output_section != NULL\n \t      && !discarded_section (sec)\n-\t      && (h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->elf)))\n+\t      && (h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->elf))\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t      insn = bfd_get_32 (input_bfd, contents + (rel->r_offset & ~3));\n \t      if ((insn & (0x3fu << 26 | 0x3)) == 58u << 26 /* ld */)\n@@ -16150,7 +16202,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      && sec != NULL\n \t      && sec->output_section != NULL\n \t      && !discarded_section (sec)\n-\t      && (h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->elf)))\n+\t      && (h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->elf))\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t      insn = bfd_get_32 (input_bfd, contents + (rel->r_offset & ~3));\n \t      if (r_type == R_PPC64_GOT16_LO_DS\n@@ -16181,7 +16234,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t&& sec != NULL\n \t\t&& sec->output_section != NULL\n \t\t&& !discarded_section (sec)\n-\t\t&& (h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->elf))))\n+\t\t&& (h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->elf))\n+\t\t&& offset_in_range (input_section, rel->r_offset, 8)))\n \t    break;\n \n \t  offset = rel->r_offset;\n@@ -16205,7 +16259,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      && rel + 1 < relend\n \t      && rel[1].r_offset == rel->r_offset\n \t      && rel[1].r_info == ELF64_R_INFO (0, R_PPC64_PCREL_OPT)\n-\t      && (h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->elf)))\n+\t      && (h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->elf))\n+\t      && offset_in_range (input_section, rel->r_offset, 8))\n \t    {\n \t      offset = rel->r_offset;\n \t      pinsn = bfd_get_32 (input_bfd, contents + offset);\n@@ -16220,15 +16275,15 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t    /* zero means next insn.  */\n \t\t    off2 = 8;\n \t\t  off2 += offset;\n-\t\t  if (off2 + 4 <= input_section->size)\n+\t\t  if (offset_in_range (input_section, off2, 4))\n \t\t    {\n \t\t      uint64_t pinsn2;\n \t\t      bfd_signed_vma addend_off;\n \t\t      pinsn2 = bfd_get_32 (input_bfd, contents + off2);\n \t\t      pinsn2 <<= 32;\n \t\t      if ((pinsn2 & (63ULL << 58)) == 1ULL << 58)\n \t\t\t{\n-\t\t\t  if (off2 + 8 > input_section->size)\n+\t\t\t  if (!offset_in_range (input_section, off2, 8))\n \t\t\t    break;\n \t\t\t  pinsn2 |= bfd_get_32 (input_bfd,\n \t\t\t\t\t\tcontents + off2 + 4);\n@@ -16659,7 +16714,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_TPREL16_HIGHESTA:\n \t  if (h != NULL\n \t      && h->elf.root.type == bfd_link_hash_undefweak\n-\t      && h->elf.dynindx == -1)\n+\t      && h->elf.dynindx == -1\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    {\n \t      /* Make this relocation against an undefined weak symbol\n \t\t resolve to zero.  This is really just a tweak, since\n@@ -17041,7 +17097,9 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t    htab->notoc_plt = 1;\n \t  /* Fall through.  */\n \tcase R_PPC64_PLTCALL:\n-\t  if (unresolved_reloc)\n+\t  if (unresolved_reloc\n+\t      && offset_in_range (input_section, rel->r_offset,\n+\t\t\t\t  r_type == R_PPC64_PLTCALL ? 8 : 4))\n \t    {\n \t      /* No plt entry.  Make this into a direct call.  */\n \t      bfd_byte *p = contents + rel->r_offset;\n@@ -17069,7 +17127,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t    htab->notoc_plt = 1;\n \t  /* Fall through.  */\n \tcase R_PPC64_PLT_PCREL34:\n-\t  if (unresolved_reloc)\n+\t  if (unresolved_reloc\n+\t      && offset_in_range (input_section, rel->r_offset, 8))\n \t    {\n \t      bfd_byte *p = contents + rel->r_offset;\n \t      bfd_put_32 (input_bfd, PNOP >> 32, p);\n@@ -17097,9 +17156,12 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t    {\n \t      bfd_byte *p;\n \t    nop_it:\n-\t      p = contents + (rel->r_offset & ~3);\n-\t      bfd_put_32 (input_bfd, NOP, p);\n-\t      goto copy_reloc;\n+\t      if (offset_in_range (input_section, rel->r_offset & ~3, 4))\n+\t\t{\n+\t\t  p = contents + (rel->r_offset & ~3);\n+\t\t  bfd_put_32 (input_bfd, NOP, p);\n+\t\t  goto copy_reloc;\n+\t\t}\n \t    }\n \t  break;\n \n@@ -17120,7 +17182,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_TOC16_LO:\n \tcase R_PPC64_TOC16_LO_DS:\n \t  if (htab->do_toc_opt && relocation + addend + 0x8000 < 0x10000\n-\t      && !ppc64_elf_tdata (input_bfd)->unexpected_toc_insn)\n+\t      && !ppc64_elf_tdata (input_bfd)->unexpected_toc_insn\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t      bfd_byte *p = contents + (rel->r_offset & ~3);\n \t      insn = bfd_get_32 (input_bfd, p);\n@@ -17140,7 +17203,9 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  break;\n \n \tcase R_PPC64_TPREL16_HA:\n-\t  if (htab->do_tls_opt && relocation + addend + 0x8000 < 0x10000)\n+\t  if (htab->do_tls_opt\n+\t      && relocation + addend + 0x8000 < 0x10000\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t      bfd_byte *p = contents + (rel->r_offset & ~3);\n \t      bfd_put_32 (input_bfd, NOP, p);\n@@ -17150,7 +17215,9 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC64_TPREL16_LO:\n \tcase R_PPC64_TPREL16_LO_DS:\n-\t  if (htab->do_tls_opt && relocation + addend + 0x8000 < 0x10000)\n+\t  if (htab->do_tls_opt\n+\t      && relocation + addend + 0x8000 < 0x10000\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t      bfd_byte *p = contents + (rel->r_offset & ~3);\n \t      insn = bfd_get_32 (input_bfd, p);\n@@ -17234,6 +17301,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_TPREL16_LO_DS:\n \tcase R_PPC64_DTPREL16_DS:\n \tcase R_PPC64_DTPREL16_LO_DS:\n+\t  if (!offset_in_range (input_section, rel->r_offset & ~3, 4))\n+\t    break;\n \t  insn = bfd_get_32 (input_bfd, contents + (rel->r_offset & ~3));\n \t  mask = 3;\n \t  /* If this reloc is against an lq, lxv, or stxv insn, then\n@@ -17287,7 +17356,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t have different reloc types.  */\n       if (howto->complain_on_overflow != complain_overflow_dont\n \t  && howto->dst_mask == 0xffff\n-\t  && (input_section->flags & SEC_CODE) != 0)\n+\t  && (input_section->flags & SEC_CODE) != 0\n+\t  && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t{\n \t  enum complain_overflow complain = complain_overflow_signed;\n \n@@ -17329,7 +17399,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_PLT_PCREL34_NOTOC:\n \tcase R_PPC64_D28:\n \tcase R_PPC64_PCREL28:\n-\t  if (rel->r_offset + 8 > input_section->size)\n+\t  if (!offset_in_range (input_section, rel->r_offset, 8))\n \t    r = bfd_reloc_outofrange;\n \t  else\n \t    {\n@@ -17358,7 +17428,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  break;\n \n \tcase R_PPC64_REL16DX_HA:\n-\t  if (rel->r_offset + 4 > input_section->size)\n+\t  if (!offset_in_range (input_section, rel->r_offset, 4))\n \t    r = bfd_reloc_outofrange;\n \t  else\n \t    {"
    }
  ]
}