{
  "sha": "fceac76e64b998c9b66a229134a9ead25209e095",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmNlYWM3NmU2NGI5OThjOWI2NmEyMjkxMzRhOWVhZDI1MjA5ZTA5NQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-23T17:02:25Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:06:55Z"
    },
    "message": "include: new header ctf.h: file format description\n\nThe data structures and macros in this header can be used, if desired,\nto access or create CTF files directly, without going through libctf,\nthough this should rarely be necessary in practice.\n\nlibctf relies on this header as its description of the CTF file format.\n\ninclude/\n\t* ctf.h: New file.",
    "tree": {
      "sha": "e761de9c5bbe328097c2c223a20d3f8ccc738ff2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e761de9c5bbe328097c2c223a20d3f8ccc738ff2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fceac76e64b998c9b66a229134a9ead25209e095",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fceac76e64b998c9b66a229134a9ead25209e095",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fceac76e64b998c9b66a229134a9ead25209e095",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fceac76e64b998c9b66a229134a9ead25209e095/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "eabf307f1d77b952dd76f2618e4e6f72d87e5d10",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/eabf307f1d77b952dd76f2618e4e6f72d87e5d10",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/eabf307f1d77b952dd76f2618e4e6f72d87e5d10"
    }
  ],
  "stats": {
    "total": 521,
    "additions": 521,
    "deletions": 0
  },
  "files": [
    {
      "sha": "b6005f880dce1d37b0c58f0273722ec17f99288d",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fceac76e64b998c9b66a229134a9ead25209e095/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fceac76e64b998c9b66a229134a9ead25209e095/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=fceac76e64b998c9b66a229134a9ead25209e095",
      "patch": "@@ -1,3 +1,7 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf.h: New file.\n+\n 2019-05-24  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \t* elf/aarch64.h (DT_AARCH64_VARIANT_PCS): Define."
    },
    {
      "sha": "6580a2143c3fc5fc903af9e49383d79c7d5bd12c",
      "filename": "include/ctf.h",
      "status": "added",
      "additions": 517,
      "deletions": 0,
      "changes": 517,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fceac76e64b998c9b66a229134a9ead25209e095/include/ctf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fceac76e64b998c9b66a229134a9ead25209e095/include/ctf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf.h?ref=fceac76e64b998c9b66a229134a9ead25209e095",
      "patch": "@@ -0,0 +1,517 @@\n+/* CTF format description.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef\t_CTF_H\n+#define\t_CTF_H\n+\n+#include <sys/types.h>\n+#include <limits.h>\n+#include <stdint.h>\n+\n+\n+#ifdef\t__cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+/* CTF - Compact ANSI-C Type Format\n+\n+   This file format can be used to compactly represent the information needed\n+   by a debugger to interpret the ANSI-C types used by a given program.\n+   Traditionally, this kind of information is generated by the compiler when\n+   invoked with the -g flag and is stored in \"stabs\" strings or in the more\n+   modern DWARF format.  CTF provides a representation of only the information\n+   that is relevant to debugging a complex, optimized C program such as the\n+   operating system kernel in a form that is significantly more compact than\n+   the equivalent stabs or DWARF representation.  The format is data-model\n+   independent, so consumers do not need different code depending on whether\n+   they are 32-bit or 64-bit programs; libctf automatically compensates for\n+   endianness variations.  CTF assumes that a standard ELF symbol table is\n+   available for use in the debugger, and uses the structure and data of the\n+   symbol table to avoid storing redundant information.  The CTF data may be\n+   compressed on disk or in memory, indicated by a bit in the header.  CTF may\n+   be interpreted in a raw disk file, or it may be stored in an ELF section,\n+   typically named .ctf.  Data structures are aligned so that a raw CTF file or\n+   CTF ELF section may be manipulated using mmap(2).\n+\n+   The CTF file or section itself has the following structure:\n+\n+   +--------+--------+---------+----------+----------+-------+--------+\n+   |  file  |  type  |  data   | function | variable | data  | string |\n+   | header | labels | objects |   info   |   info   | types | table  |\n+   +--------+--------+---------+----------+----------+-------+--------+\n+\n+   The file header stores a magic number and version information, encoding\n+   flags, and the byte offset of each of the sections relative to the end of the\n+   header itself.  If the CTF data has been uniquified against another set of\n+   CTF data, a reference to that data also appears in the the header.  This\n+   reference is the name of the label corresponding to the types uniquified\n+   against.\n+\n+   Following the header is a list of labels, used to group the types included in\n+   the data types section.  Each label is accompanied by a type ID i.  A given\n+   label refers to the group of types whose IDs are in the range [0, i].\n+\n+   Data object and function records are stored in the same order as they appear\n+   in the corresponding symbol table, except that symbols marked SHN_UNDEF are\n+   not stored and symbols that have no type data are padded out with zeroes.\n+   For each data object, the type ID (a small integer) is recorded.  For each\n+   function, the type ID of the return type and argument types is recorded.\n+\n+   Variable records (as distinct from data objects) provide a modicum of support\n+   for non-ELF systems, mapping a variable name to a CTF type ID.  The variable\n+   names are sorted into ASCIIbetical order, permitting binary searching.\n+\n+   The data types section is a list of variable size records that represent each\n+   type, in order by their ID.  The types themselves form a directed graph,\n+   where each node may contain one or more outgoing edges to other type nodes,\n+   denoted by their ID.\n+\n+   Strings are recorded as a string table ID (0 or 1) and a byte offset into the\n+   string table.  String table 0 is the internal CTF string table.  String table\n+   1 is the external string table, which is the string table associated with the\n+   ELF symbol table for this object.  CTF does not record any strings that are\n+   already in the symbol table, and the CTF string table does not contain any\n+   duplicated strings.\n+\n+   If the CTF data has been merged with another parent CTF object, some outgoing\n+   edges may refer to type nodes that exist in another CTF object.  The debugger\n+   and libctf library are responsible for connecting the appropriate objects\n+   together so that the full set of types can be explored and manipulated.\n+\n+   This connection is done purely using the ctf_import() function.  There is no\n+   notation anywhere in the child CTF file indicating which parent it is\n+   connected to: it is the debugger's responsibility to track this.  */\n+\n+#define CTF_MAX_TYPE\t0xfffffffe\t/* Max type identifier value.  */\n+#define CTF_MAX_PTYPE\t0x7fffffff\t/* Max parent type identifier value.  */\n+#define CTF_MAX_NAME 0x7fffffff\t\t/* Max offset into a string table.  */\n+#define CTF_MAX_VLEN\t0xffffff /* Max struct, union, enum members or args.  */\n+\n+/* See ctf_type_t */\n+#define CTF_MAX_SIZE\t0xfffffffe\t/* Max size of a v2 type in bytes. */\n+#define CTF_LSIZE_SENT\t0xffffffff\t/* Sentinel for v2 ctt_size.  */\n+\n+# define CTF_MAX_TYPE_V1\t0xffff\t/* Max type identifier value.  */\n+# define CTF_MAX_PTYPE_V1\t0x7fff\t/* Max parent type identifier value.  */\n+# define CTF_MAX_VLEN_V1\t0x3ff\t/* Max struct, union, enums or args.  */\n+# define CTF_MAX_SIZE_V1\t0xfffe\t/* Max size of a type in bytes. */\n+# define CTF_LSIZE_SENT_V1\t0xffff\t/* Sentinel for v1 ctt_size.  */\n+\n+  /* Start of actual data structure definitions.\n+\n+     Every field in these structures must have corresponding code in the\n+     endianness-swapping machinery in libctf/ctf-open.c.  */\n+\n+typedef struct ctf_preamble\n+{\n+  unsigned short ctp_magic;\t/* Magic number (CTF_MAGIC).  */\n+  unsigned char ctp_version;\t/* Data format version number (CTF_VERSION).  */\n+  unsigned char ctp_flags;\t/* Flags (see below).  */\n+} ctf_preamble_t;\n+\n+typedef struct ctf_header\n+{\n+  ctf_preamble_t cth_preamble;\n+  uint32_t cth_parlabel;\t/* Ref to name of parent lbl uniq'd against.  */\n+  uint32_t cth_parname;\t\t/* Ref to basename of parent.  */\n+  uint32_t cth_lbloff;\t\t/* Offset of label section.  */\n+  uint32_t cth_objtoff;\t\t/* Offset of object section.  */\n+  uint32_t cth_funcoff;\t\t/* Offset of function section.  */\n+  uint32_t cth_varoff;\t\t/* Offset of variable section.  */\n+  uint32_t cth_typeoff;\t\t/* Offset of type section.  */\n+  uint32_t cth_stroff;\t\t/* Offset of string section.  */\n+  uint32_t cth_strlen;\t\t/* Length of string section in bytes.  */\n+} ctf_header_t;\n+\n+#define cth_magic   cth_preamble.ctp_magic\n+#define cth_version cth_preamble.ctp_version\n+#define cth_flags   cth_preamble.ctp_flags\n+\n+#define CTF_MAGIC\t0xdff2\t/* Magic number identifying header.  */\n+\n+/* Data format version number.  */\n+\n+/* v1 upgraded to v2 is not quite the same as native v2 (the boundary between\n+   parent and child types is different), and you can write it out again via\n+   ctf_compress_write(), so we must track whether the thing was originally v1 or\n+   not.  If we were writing the header from scratch, we would add a *pair* of\n+   version number fields to allow for this, but this will do for now.  (A flag\n+   will not do, because we need to encode both the version we came from and the\n+   version we went to, not just \"we were upgraded\".) */\n+\n+# define CTF_VERSION_1 1\n+# define CTF_VERSION_1_UPGRADED_3 2\n+# define CTF_VERSION_2 3\n+\n+#define CTF_VERSION_3 4\n+#define CTF_VERSION CTF_VERSION_3 /* Current version.  */\n+\n+#define CTF_F_COMPRESS\t0x1\t/* Data buffer is compressed by libctf.  */\n+\n+typedef struct ctf_lblent\n+{\n+  uint32_t ctl_label;\t\t/* Ref to name of label.  */\n+  uint32_t ctl_type;\t\t/* Last type associated with this label.  */\n+} ctf_lblent_t;\n+\n+typedef struct ctf_varent\n+{\n+  uint32_t ctv_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctv_type;\t\t/* Index of type of this variable.  */\n+} ctf_varent_t;\n+\n+/* In format v2, type sizes, measured in bytes, come in two flavours.  Nearly\n+   all of them fit into a (UINT_MAX - 1), and thus can be stored in the ctt_size\n+   member of a ctf_stype_t.  The maximum value for these sizes is CTF_MAX_SIZE.\n+   Types larger than this must be stored in the ctf_lsize member of a\n+   ctf_type_t.  Use of this member is indicated by the presence of\n+   CTF_LSIZE_SENT in ctt_size.  */\n+\n+/* In v1, the same applies, only the limit is (USHRT_MAX - 1) and\n+   CTF_MAX_SIZE_V1, and CTF_LSIZE_SENT_V1 is the sentinel.  */\n+\n+typedef struct ctf_stype_v1\n+{\n+  uint32_t ctt_name;\t\t/* Reference to name in string table.  */\n+  unsigned short ctt_info;\t/* Encoded kind, variant length (see below).  */\n+#ifndef __GNUC__\n+  union\n+  {\n+    unsigned short _size;\t/* Size of entire type in bytes.  */\n+    unsigned short _type;\t/* Reference to another type.  */\n+  } _u;\n+#else\n+  __extension__\n+  union\n+  {\n+    unsigned short ctt_size;\t/* Size of entire type in bytes.  */\n+    unsigned short ctt_type;\t/* Reference to another type.  */\n+  };\n+#endif\n+} ctf_stype_v1_t;\n+\n+typedef struct ctf_type_v1\n+{\n+  uint32_t ctt_name;\t\t/* Reference to name in string table.  */\n+  unsigned short ctt_info;\t/* Encoded kind, variant length (see below).  */\n+#ifndef __GNUC__\n+  union\n+  {\n+    unsigned short _size;\t/* Always CTF_LSIZE_SENT_V1.  */\n+    unsigned short _type;\t/* Do not use.  */\n+  } _u;\n+#else\n+  __extension__\n+  union\n+  {\n+    unsigned short ctt_size;\t/* Always CTF_LSIZE_SENT_V1.  */\n+    unsigned short ctt_type;\t/* Do not use.  */\n+  };\n+#endif\n+  uint32_t ctt_lsizehi;\t\t/* High 32 bits of type size in bytes.  */\n+  uint32_t ctt_lsizelo;\t\t/* Low 32 bits of type size in bytes.  */\n+} ctf_type_v1_t;\n+\n+\n+typedef struct ctf_stype\n+{\n+  uint32_t ctt_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctt_info;\t\t/* Encoded kind, variant length (see below).  */\n+#ifndef __GNUC__\n+  union\n+  {\n+    uint32_t _size;\t\t/* Size of entire type in bytes.  */\n+    uint32_t _type;\t\t/* Reference to another type.  */\n+  } _u;\n+#else\n+  __extension__\n+  union\n+  {\n+    uint32_t ctt_size;\t\t/* Size of entire type in bytes.  */\n+    uint32_t ctt_type;\t\t/* Reference to another type.  */\n+  };\n+#endif\n+} ctf_stype_t;\n+\n+typedef struct ctf_type\n+{\n+  uint32_t ctt_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctt_info;\t\t/* Encoded kind, variant length (see below).  */\n+#ifndef __GNUC__\n+union\n+  {\n+    uint32_t _size;\t\t/* Always CTF_LSIZE_SENT.  */\n+    uint32_t _type;\t\t/* Do not use.  */\n+  } _u;\n+#else\n+  __extension__\n+  union\n+  {\n+    uint32_t ctt_size;\t\t/* Always CTF_LSIZE_SENT.  */\n+    uint32_t ctt_type;\t\t/* Do not use.  */\n+  };\n+#endif\n+  uint32_t ctt_lsizehi;\t\t/* High 32 bits of type size in bytes.  */\n+  uint32_t ctt_lsizelo;\t\t/* Low 32 bits of type size in bytes.  */\n+} ctf_type_t;\n+\n+#ifndef __GNUC__\n+#define ctt_size _u._size\t/* For fundamental types that have a size.  */\n+#define ctt_type _u._type\t/* For types that reference another type.  */\n+#endif\n+\n+/* The following macros and inline functions compose and decompose values for\n+   ctt_info and ctt_name, as well as other structures that contain name\n+   references.  Use outside libdtrace-ctf itself is explicitly for access to CTF\n+   files directly: types returned from the library will always appear to be\n+   CTF_V2.\n+\n+   v1: (transparently upgraded to v2 at open time: may be compiled out of the\n+   library)\n+               ------------------------\n+   ctt_info:   | kind | isroot | vlen |\n+               ------------------------\n+               15   11    10    9     0\n+\n+   v2:\n+               ------------------------\n+   ctt_info:   | kind | isroot | vlen |\n+               ------------------------\n+               31    26    25  24     0\n+\n+   CTF_V1 and V2 _INFO_VLEN have the same interface:\n+\n+   kind = CTF_*_INFO_KIND(c.ctt_info);     <-- CTF_K_* value (see below)\n+   vlen = CTF_*_INFO_VLEN(fp, c.ctt_info); <-- length of variable data list\n+\n+   stid = CTF_NAME_STID(c.ctt_name);     <-- string table id number (0 or 1)\n+   offset = CTF_NAME_OFFSET(c.ctt_name); <-- string table byte offset\n+\n+   c.ctt_info = CTF_TYPE_INFO(kind, vlen);\n+   c.ctt_name = CTF_TYPE_NAME(stid, offset);  */\n+\n+# define CTF_V1_INFO_KIND(info)\t\t(((info) & 0xf800) >> 11)\n+# define CTF_V1_INFO_ISROOT(info)\t(((info) & 0x0400) >> 10)\n+# define CTF_V1_INFO_VLEN(info)\t\t(((info) & CTF_MAX_VLEN_V1))\n+\n+#define CTF_V2_INFO_KIND(info)\t\t(((info) & 0xfc000000) >> 26)\n+#define CTF_V2_INFO_ISROOT(info)\t(((info) & 0x2000000) >> 25)\n+#define CTF_V2_INFO_VLEN(info)\t\t(((info) & CTF_MAX_VLEN))\n+\n+#define CTF_NAME_STID(name)\t\t((name) >> 31)\n+#define CTF_NAME_OFFSET(name)\t\t((name) & CTF_MAX_NAME)\n+\n+/* V2 only. */\n+#define CTF_TYPE_INFO(kind, isroot, vlen) \\\n+\t(((kind) << 26) | (((isroot) ? 1 : 0) << 25) | ((vlen) & CTF_MAX_VLEN))\n+\n+#define CTF_TYPE_NAME(stid, offset) \\\n+\t(((stid) << 31) | ((offset) & CTF_MAX_NAME))\n+\n+/* The next set of macros are for public consumption only.  Not used internally,\n+   since the relevant type boundary is dependent upon the version of the file at\n+   *opening* time, not the version after transparent upgrade.  Use\n+   ctf_type_isparent() / ctf_type_ischild() for that.  */\n+\n+#define CTF_V2_TYPE_ISPARENT(fp, id)\t((id) <= CTF_MAX_PTYPE)\n+#define CTF_V2_TYPE_ISCHILD(fp, id)\t((id) > CTF_MAX_PTYPE)\n+#define CTF_V2_TYPE_TO_INDEX(id)\t((id) & CTF_MAX_PTYPE)\n+#define CTF_V2_INDEX_TO_TYPE(id, child) ((child) ? ((id) | (CTF_MAX_PTYPE+1)) : (id))\n+\n+# define CTF_V1_TYPE_ISPARENT(fp, id)\t((id) <= CTF_MAX_PTYPE_V1)\n+# define CTF_V1_TYPE_ISCHILD(fp, id)\t((id) > CTF_MAX_PTYPE_V1)\n+# define CTF_V1_TYPE_TO_INDEX(id)\t((id) & CTF_MAX_PTYPE_V1)\n+# define CTF_V1_INDEX_TO_TYPE(id, child) ((child) ? ((id) | (CTF_MAX_PTYPE_V1+1)) : (id))\n+\n+/* Valid for both V1 and V2. */\n+#define CTF_TYPE_LSIZE(cttp) \\\n+\t(((uint64_t)(cttp)->ctt_lsizehi) << 32 | (cttp)->ctt_lsizelo)\n+#define CTF_SIZE_TO_LSIZE_HI(size)\t((uint32_t)((uint64_t)(size) >> 32))\n+#define CTF_SIZE_TO_LSIZE_LO(size)\t((uint32_t)(size))\n+\n+#define CTF_STRTAB_0\t0\t/* String table id 0 (in-CTF).  */\n+#define CTF_STRTAB_1\t1\t/* String table id 1 (ELF strtab).  */\n+\n+/* Values for CTF_TYPE_KIND().  If the kind has an associated data list,\n+   CTF_INFO_VLEN() will extract the number of elements in the list, and\n+   the type of each element is shown in the comments below. */\n+\n+#define CTF_K_UNKNOWN\t0\t/* Unknown type (used for padding).  */\n+#define CTF_K_INTEGER\t1\t/* Variant data is CTF_INT_DATA (see below).  */\n+#define CTF_K_FLOAT\t2\t/* Variant data is CTF_FP_DATA (see below).  */\n+#define CTF_K_POINTER\t3\t/* ctt_type is referenced type.  */\n+#define CTF_K_ARRAY\t4\t/* Variant data is single ctf_array_t.  */\n+#define CTF_K_FUNCTION\t5\t/* ctt_type is return type, variant data is\n+\t\t\t\t   list of argument types (unsigned short's for v1,\n+\t\t\t\t   uint32_t's for v2).  */\n+#define CTF_K_STRUCT\t6\t/* Variant data is list of ctf_member_t's.  */\n+#define CTF_K_UNION\t7\t/* Variant data is list of ctf_member_t's.  */\n+#define CTF_K_ENUM\t8\t/* Variant data is list of ctf_enum_t's.  */\n+#define CTF_K_FORWARD\t9\t/* No additional data; ctt_name is tag.  */\n+#define CTF_K_TYPEDEF\t10\t/* ctt_type is referenced type.  */\n+#define CTF_K_VOLATILE\t11\t/* ctt_type is base type.  */\n+#define CTF_K_CONST\t12\t/* ctt_type is base type.  */\n+#define CTF_K_RESTRICT\t13\t/* ctt_type is base type.  */\n+#define CTF_K_SLICE\t14\t/* Variant data is a ctf_slice_t.  */\n+\n+#define CTF_K_MAX\t63\t/* Maximum possible (V2) CTF_K_* value.  */\n+\n+/* Values for ctt_type when kind is CTF_K_INTEGER.  The flags, offset in bits,\n+   and size in bits are encoded as a single word using the following macros.\n+   (However, you can also encode the offset and bitness in a slice.)  */\n+\n+#define CTF_INT_ENCODING(data) (((data) & 0xff000000) >> 24)\n+#define CTF_INT_OFFSET(data)   (((data) & 0x00ff0000) >> 16)\n+#define CTF_INT_BITS(data)     (((data) & 0x0000ffff))\n+\n+#define CTF_INT_DATA(encoding, offset, bits) \\\n+       (((encoding) << 24) | ((offset) << 16) | (bits))\n+\n+#define CTF_INT_SIGNED\t0x01\t/* Integer is signed (otherwise unsigned).  */\n+#define CTF_INT_CHAR\t0x02\t/* Character display format.  */\n+#define CTF_INT_BOOL\t0x04\t/* Boolean display format.  */\n+#define CTF_INT_VARARGS\t0x08\t/* Varargs display format.  */\n+\n+/* Use CTF_CHAR to produce a char that agrees with the system's native\n+   char signedness.  */\n+#if CHAR_MIN == 0\n+# define CTF_CHAR (CTF_INT_CHAR)\n+#else\n+# define CTF_CHAR (CTF_INT_CHAR | CTF_INT_SIGNED)\n+#endif\n+\n+/* Values for ctt_type when kind is CTF_K_FLOAT.  The encoding, offset in bits,\n+   and size in bits are encoded as a single word using the following macros.\n+   (However, you can also encode the offset and bitness in a slice.)  */\n+\n+#define CTF_FP_ENCODING(data)  (((data) & 0xff000000) >> 24)\n+#define CTF_FP_OFFSET(data)    (((data) & 0x00ff0000) >> 16)\n+#define CTF_FP_BITS(data)      (((data) & 0x0000ffff))\n+\n+#define CTF_FP_DATA(encoding, offset, bits) \\\n+       (((encoding) << 24) | ((offset) << 16) | (bits))\n+\n+/* Variant data when kind is CTF_K_FLOAT is an encoding in the top eight bits.  */\n+#define CTF_FP_ENCODING(data)\t(((data) & 0xff000000) >> 24)\n+\n+#define CTF_FP_SINGLE\t1\t/* IEEE 32-bit float encoding.  */\n+#define CTF_FP_DOUBLE\t2\t/* IEEE 64-bit float encoding.  */\n+#define CTF_FP_CPLX\t3\t/* Complex encoding.  */\n+#define CTF_FP_DCPLX\t4\t/* Double complex encoding.  */\n+#define CTF_FP_LDCPLX\t5\t/* Long double complex encoding.  */\n+#define CTF_FP_LDOUBLE\t6\t/* Long double encoding.  */\n+#define CTF_FP_INTRVL\t7\t/* Interval (2x32-bit) encoding.  */\n+#define CTF_FP_DINTRVL\t8\t/* Double interval (2x64-bit) encoding.  */\n+#define CTF_FP_LDINTRVL\t9\t/* Long double interval (2x128-bit) encoding.  */\n+#define CTF_FP_IMAGRY\t10\t/* Imaginary (32-bit) encoding.  */\n+#define CTF_FP_DIMAGRY\t11\t/* Long imaginary (64-bit) encoding.  */\n+#define CTF_FP_LDIMAGRY\t12\t/* Long double imaginary (128-bit) encoding.  */\n+\n+#define CTF_FP_MAX\t12\t/* Maximum possible CTF_FP_* value */\n+\n+/* A slice increases the offset and reduces the bitness of the referenced\n+   ctt_type, which must be a type which has an encoding (fp, int, or enum).  We\n+   also store the referenced type in here, because it is easier to keep the\n+   ctt_size correct for the slice than to shuffle the size into here and keep\n+   the ctt_type where it is for other types.  */\n+\n+typedef struct ctf_slice\n+{\n+  uint32_t cts_type;\n+  unsigned char cts_offset;\n+  unsigned char cts_bits;\n+} ctf_slice_t;\n+\n+typedef struct ctf_array_v1\n+{\n+  unsigned short cta_contents;\t/* Reference to type of array contents.  */\n+  unsigned short cta_index;\t/* Reference to type of array index.  */\n+  uint32_t cta_nelems;\t\t/* Number of elements.  */\n+} ctf_array_v1_t;\n+\n+typedef struct ctf_array\n+{\n+  uint32_t cta_contents;\t/* Reference to type of array contents.  */\n+  uint32_t cta_index;\t\t/* Reference to type of array index.  */\n+  uint32_t cta_nelems;\t\t/* Number of elements.  */\n+} ctf_array_t;\n+\n+/* Most structure members have bit offsets that can be expressed using a short.\n+   Some don't.  ctf_member_t is used for structs which cannot contain any of\n+   these large offsets, whereas ctf_lmember_t is used in the latter case.  If\n+   any member of a given struct has an offset that cannot be expressed using a\n+   uint32_t, all members will be stored as type ctf_lmember_t.  This is expected\n+   to be very rare (but nonetheless possible).  */\n+\n+#define CTF_LSTRUCT_THRESH\t536870912\n+\n+/* In v1, the same is true, except that lmembers are used for structs >= 8192\n+   bytes in size.  (The ordering of members in the ctf_member_* structures is\n+   different to improve padding.)  */\n+\n+#define CTF_LSTRUCT_THRESH_V1\t8192\n+\n+typedef struct ctf_member_v1\n+{\n+  uint32_t ctm_name;\t\t/* Reference to name in string table.  */\n+  unsigned short ctm_type;\t/* Reference to type of member.  */\n+  unsigned short ctm_offset;\t/* Offset of this member in bits.  */\n+} ctf_member_v1_t;\n+\n+typedef struct ctf_lmember_v1\n+{\n+  uint32_t ctlm_name;\t\t/* Reference to name in string table.  */\n+  unsigned short ctlm_type;\t/* Reference to type of member.  */\n+  unsigned short ctlm_pad;\t/* Padding.  */\n+  uint32_t ctlm_offsethi;\t/* High 32 bits of member offset in bits.  */\n+  uint32_t ctlm_offsetlo;\t/* Low 32 bits of member offset in bits.  */\n+} ctf_lmember_v1_t;\n+\n+typedef struct ctf_member_v2\n+{\n+  uint32_t ctm_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctm_offset;\t\t/* Offset of this member in bits.  */\n+  uint32_t ctm_type;\t\t/* Reference to type of member.  */\n+} ctf_member_t;\n+\n+typedef struct ctf_lmember_v2\n+{\n+  uint32_t ctlm_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctlm_offsethi;\t/* High 32 bits of member offset in bits.  */\n+  uint32_t ctlm_type;\t\t/* Reference to type of member.  */\n+  uint32_t ctlm_offsetlo;\t/* Low 32 bits of member offset in bits.  */\n+} ctf_lmember_t;\n+\n+#define\tCTF_LMEM_OFFSET(ctlmp) \\\n+\t(((uint64_t)(ctlmp)->ctlm_offsethi) << 32 | (ctlmp)->ctlm_offsetlo)\n+#define\tCTF_OFFSET_TO_LMEMHI(offset)\t((uint32_t)((uint64_t)(offset) >> 32))\n+#define\tCTF_OFFSET_TO_LMEMLO(offset)\t((uint32_t)(offset))\n+\n+typedef struct ctf_enum\n+{\n+  uint32_t cte_name;\t\t/* Reference to name in string table.  */\n+  int cte_value;\t\t/* Value associated with this name.  */\n+} ctf_enum_t;\n+\n+#ifdef\t__cplusplus\n+}\n+#endif\n+\n+#endif\t\t\t\t/* _CTF_H */"
    }
  ]
}