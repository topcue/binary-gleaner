{
  "sha": "a0486bac41d6ce47f27795a5abbca5cc53ddba00",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTA0ODZiYWM0MWQ2Y2U0N2YyNzc5NWE1YWJiY2E1Y2M1M2RkYmEwMA==",
  "commit": {
    "author": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2019-05-31T09:10:51Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2019-05-31T09:10:51Z"
    },
    "message": "libctf: fix a number of build problems found on Solaris and NetBSD\n\n- Use of nonportable <endian.h>\n- Use of qsort_r\n- Use of zlib without appropriate magic to pull in the binutils zlib\n- Use of off64_t without checking (fixed by dropping the unused fields\n  that need off64_t entirely)\n- signedness problems due to long being too short a type on 32-bit\n  platforms: ctf_id_t is now 'unsigned long', and CTF_ERR must be\n  used only for functions that return ctf_id_t\n- One lingering use of bzero() and of <sys/errno.h>\n\nAll fixed, using code from gnulib where possible.\n\nRelatedly, set cts_size in a couple of places it was missed\n(string table and symbol table loading upon ctf_bfdopen()).\n\nbinutils/\n\t* objdump.c (make_ctfsect): Drop cts_type, cts_flags, and\n\tcts_offset.\n\t* readelf.c (shdr_to_ctf_sect): Likewise.\ninclude/\n\t* ctf-api.h (ctf_sect_t): Drop cts_type, cts_flags, and cts_offset.\n\t(ctf_id_t): This is now an unsigned type.\n\t(CTF_ERR): Cast it to ctf_id_t.  Note that it should only be used\n\tfor ctf_id_t-returning functions.\nlibctf/\n\t* Makefile.am (ZLIB): New.\n\t(ZLIBINC): Likewise.\n\t(AM_CFLAGS): Use them.\n\t(libctf_a_LIBADD): New, for LIBOBJS.\n\t* configure.ac: Check for zlib, endian.h, and qsort_r.\n\t* ctf-endian.h: New, providing htole64 and le64toh.\n\t* swap.h: Code style fixes.\n\t(bswap_identity_64): New.\n\t* qsort_r.c: New, from gnulib (with one added #include).\n\t* ctf-decls.h: New, providing a conditional qsort_r declaration,\n\tand unconditional definitions of MIN and MAX.\n\t* ctf-impl.h: Use it.  Do not use <sys/errno.h>.\n\t(ctf_set_errno): Now returns unsigned long.\n\t* ctf-util.c (ctf_set_errno): Adjust here too.\n\t* ctf-archive.c: Use ctf-endian.h.\n\t(ctf_arc_open_by_offset): Use memset, not bzero.  Drop cts_type,\n\tcts_flags and cts_offset.\n\t(ctf_arc_write): Drop debugging dependent on the size of off_t.\n\t* ctf-create.c: Provide a definition of roundup if not defined.\n\t(ctf_create): Drop cts_type, cts_flags and cts_offset.\n\t(ctf_add_reftype): Do not check if type IDs are below zero.\n\t(ctf_add_slice): Likewise.\n\t(ctf_add_typedef): Likewise.\n\t(ctf_add_member_offset): Cast error-returning ssize_t's to size_t\n\twhen known error-free.  Drop CTF_ERR usage for functions returning\n\tint.\n\t(ctf_add_member_encoded): Drop CTF_ERR usage for functions returning\n\tint.\n\t(ctf_add_variable): Likewise.\n\t(enumcmp): Likewise.\n\t(enumadd): Likewise.\n\t(membcmp): Likewise.\n\t(ctf_add_type): Likewise.  Cast error-returning ssize_t's to size_t\n\twhen known error-free.\n\t* ctf-dump.c (ctf_is_slice): Drop CTF_ERR usage for functions\n\treturning int: use CTF_ERR for functions returning ctf_type_id.\n\t(ctf_dump_label): Likewise.\n\t(ctf_dump_objts): Likewise.\n\t* ctf-labels.c (ctf_label_topmost): Likewise.\n\t(ctf_label_iter): Likewise.\n\t(ctf_label_info): Likewise.\n\t* ctf-lookup.c (ctf_func_args): Likewise.\n\t* ctf-open.c (upgrade_types): Cast to size_t where appropriate.\n\t(ctf_bufopen): Likewise.  Use zlib types as needed.\n\t* ctf-types.c (ctf_member_iter): Drop CTF_ERR usage for functions\n\treturning int.\n\t(ctf_enum_iter): Likewise.\n\t(ctf_type_size): Likewise.\n\t(ctf_type_align): Likewise.  Cast to size_t where appropriate.\n\t(ctf_type_kind_unsliced): Likewise.\n\t(ctf_type_kind): Likewise.\n\t(ctf_type_encoding): Likewise.\n\t(ctf_member_info): Likewise.\n\t(ctf_array_info): Likewise.\n\t(ctf_enum_value): Likewise.\n\t(ctf_type_rvisit): Likewise.\n\t* ctf-open-bfd.c (ctf_bfdopen): Drop cts_type, cts_flags and\n\tcts_offset.\n\t(ctf_simple_open): Likewise.\n\t(ctf_bfdopen_ctfsect): Likewise.  Set cts_size properly.\n\t* Makefile.in: Regenerate.\n\t* aclocal.m4: Likewise.\n\t* config.h: Likewise.\n\t* configure: Likewise.",
    "tree": {
      "sha": "f68e14cbd729cfb89a15307d4ccdd110658286dc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f68e14cbd729cfb89a15307d4ccdd110658286dc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a0486bac41d6ce47f27795a5abbca5cc53ddba00",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a0486bac41d6ce47f27795a5abbca5cc53ddba00",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a0486bac41d6ce47f27795a5abbca5cc53ddba00",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a0486bac41d6ce47f27795a5abbca5cc53ddba00/comments",
  "author": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ff4a4474eba6488c8ad3cae51a685fe282ab249a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ff4a4474eba6488c8ad3cae51a685fe282ab249a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ff4a4474eba6488c8ad3cae51a685fe282ab249a"
    }
  ],
  "stats": {
    "total": 998,
    "additions": 883,
    "deletions": 115
  },
  "files": [
    {
      "sha": "950dee7af505b3469475d13eb4eec35e8557f71d",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -1,3 +1,9 @@\n+2019-05-30  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* objdump.c (make_ctfsect): Drop cts_type, cts_flags, and\n+\tcts_offset.\n+\t* readelf.c (shdr_to_ctf_sect): Likewise.\n+\n 2019-05-30  Nick Clifton  <nickc@redhat.com>\n \n \tPR 24627"
    },
    {
      "sha": "b9d08f70f95c4f9e0f0c19c35b7cb3710601080f",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -3240,10 +3240,7 @@ make_ctfsect (const char *name, bfd_byte *data,\n   ctf_sect_t ctfsect;\n \n   ctfsect.cts_name = name;\n-  ctfsect.cts_type = SHT_PROGBITS;\n-  ctfsect.cts_flags = 0;\n   ctfsect.cts_entsize = 1;\n-  ctfsect.cts_offset = 0;\n   ctfsect.cts_size = size;\n   ctfsect.cts_data = data;\n "
    },
    {
      "sha": "8e2902fdcac41201edd37c2351df3b465a533851",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -13829,11 +13829,8 @@ static ctf_sect_t *\n shdr_to_ctf_sect (ctf_sect_t *buf, Elf_Internal_Shdr *shdr, Filedata *filedata)\n {\n   buf->cts_name = SECTION_NAME (shdr);\n-  buf->cts_type = shdr->sh_type;\n-  buf->cts_flags = shdr->sh_flags;\n   buf->cts_size = shdr->sh_size;\n   buf->cts_entsize = shdr->sh_entsize;\n-  buf->cts_offset = (off64_t) shdr->sh_offset;\n \n   return buf;\n }"
    },
    {
      "sha": "1f216b38218070655abb590ef2b9b6f2a42a9a31",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -1,3 +1,10 @@\n+2019-05-29  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_sect_t): Drop cts_type, cts_flags, and cts_offset.\n+\t(ctf_id_t): This is now an unsigned type.\n+\t(CTF_ERR): Cast it to ctf_id_t.  Note that it should only be used\n+\tfor ctf_id_t-returning functions.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_dump_decorate_f): New."
    },
    {
      "sha": "3acbc91b9ae638c45c04a4a2edd5ab5f436aad62",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -43,7 +43,7 @@ extern \"C\"\n \n typedef struct ctf_file ctf_file_t;\n typedef struct ctf_archive_internal ctf_archive_t;\n-typedef long ctf_id_t;\n+typedef unsigned long ctf_id_t;\n \n /* This opaque definition allows libctf to accept BFD data structures without\n    importing all the BFD noise into users' namespaces.  */\n@@ -60,12 +60,9 @@ struct bfd;\n typedef struct ctf_sect\n {\n   const char *cts_name;\t\t  /* Section name (if any).  */\n-  unsigned long cts_type;\t  /* Section type (ELF SHT_... value).  */\n-  unsigned long cts_flags;\t  /* Section flags (ELF SHF_... value).  */\n   const void *cts_data;\t\t  /* Pointer to section data.  */\n   size_t cts_size;\t\t  /* Size of data in bytes.  */\n   size_t cts_entsize;\t\t  /* Size of each section entry (symtab only).  */\n-  off64_t cts_offset;\t\t  /* File offset of this section (if any).  */\n } ctf_sect_t;\n \n /* Symbolic names for CTF sections.  */\n@@ -125,9 +122,10 @@ typedef struct ctf_snapshot_id\n \n #define\tCTF_FUNC_VARARG\t0x1\t/* Function arguments end with varargs.  */\n \n-/* Functions that return integer status or a ctf_id_t use the following value\n-   to indicate failure.  ctf_errno() can be used to obtain an error code.  */\n-#define\tCTF_ERR\t(-1L)\n+/* Functions that return a ctf_id_t use the following value to indicate failure.\n+   ctf_errno() can be used to obtain an error code.  Functions that return\n+   a straight integral -1 also use ctf_errno().  */\n+#define\tCTF_ERR\t((ctf_id_t) -1L)\n \n #define\tECTF_BASE\t1000\t/* Base value for libctf errnos.  */\n "
    },
    {
      "sha": "d059d58d19b116a4ed5f94d700132a5688bfd1f8",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 67,
      "deletions": 0,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -1,3 +1,70 @@\n+2019-05-29  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* Makefile.am (ZLIB): New.\n+\t(ZLIBINC): Likewise.\n+\t(AM_CFLAGS): Use them.\n+\t(libctf_a_LIBADD): New, for LIBOBJS.\n+\t* configure.ac: Check for zlib, endian.h, and qsort_r.\n+\t* ctf-endian.h: New, providing htole64 and le64toh.\n+\t* swap.h: Code style fixes.\n+\t(bswap_identity_64): New.\n+\t* qsort_r.c: New, from gnulib (with one added #include).\n+\t* ctf-decls.h: New, providing a conditional qsort_r declaration,\n+\tand unconditional definitions of MIN and MAX.\n+\t* ctf-impl.h: Use it.  Do not use <sys/errno.h>.\n+\t(ctf_set_errno): Now returns unsigned long.\n+\t* ctf-util.c (ctf_set_errno): Adjust here too.\n+\t* ctf-archive.c: Use ctf-endian.h.\n+\t(ctf_arc_open_by_offset): Use memset, not bzero.  Drop cts_type,\n+\tcts_flags and cts_offset.\n+\t(ctf_arc_write): Drop debugging dependent on the size of off_t.\n+\t* ctf-create.c: Provide a definition of roundup if not defined.\n+\t(ctf_create): Drop cts_type, cts_flags and cts_offset.\n+\t(ctf_add_reftype): Do not check if type IDs are below zero.\n+\t(ctf_add_slice): Likewise.\n+\t(ctf_add_typedef): Likewise.\n+\t(ctf_add_member_offset): Cast error-returning ssize_t's to size_t\n+\twhen known error-free.  Drop CTF_ERR usage for functions returning\n+\tint.\n+\t(ctf_add_member_encoded): Drop CTF_ERR usage for functions returning\n+\tint.\n+\t(ctf_add_variable): Likewise.\n+\t(enumcmp): Likewise.\n+\t(enumadd): Likewise.\n+\t(membcmp): Likewise.\n+\t(ctf_add_type): Likewise.  Cast error-returning ssize_t's to size_t\n+\twhen known error-free.\n+\t* ctf-dump.c (ctf_is_slice): Drop CTF_ERR usage for functions\n+\treturning int: use CTF_ERR for functions returning ctf_type_id.\n+\t(ctf_dump_label): Likewise.\n+\t(ctf_dump_objts): Likewise.\n+\t* ctf-labels.c (ctf_label_topmost): Likewise.\n+\t(ctf_label_iter): Likewise.\n+\t(ctf_label_info): Likewise.\n+\t* ctf-lookup.c (ctf_func_args): Likewise.\n+\t* ctf-open.c (upgrade_types): Cast to size_t where appropriate.\n+\t(ctf_bufopen): Likewise.  Use zlib types as needed.\n+\t* ctf-types.c (ctf_member_iter): Drop CTF_ERR usage for functions\n+\treturning int.\n+\t(ctf_enum_iter): Likewise.\n+\t(ctf_type_size): Likewise.\n+\t(ctf_type_align): Likewise.  Cast to size_t where appropriate.\n+\t(ctf_type_kind_unsliced): Likewise.\n+\t(ctf_type_kind): Likewise.\n+\t(ctf_type_encoding): Likewise.\n+\t(ctf_member_info): Likewise.\n+\t(ctf_array_info): Likewise.\n+\t(ctf_enum_value): Likewise.\n+\t(ctf_type_rvisit): Likewise.\n+\t* ctf-open-bfd.c (ctf_bfdopen): Drop cts_type, cts_flags and\n+\tcts_offset.\n+\t(ctf_simple_open): Likewise.\n+\t(ctf_bfdopen_ctfsect): Likewise.  Set cts_size properly.\n+\t* Makefile.in: Regenerate.\n+\t* aclocal.m4: Likewise.\n+\t* config.h: Likewise.\n+\t* configure: Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* configure.in: Check for bfd_section_from_elf_index."
    },
    {
      "sha": "49c9f5280a93923ae26b9257943eaab824dbe128",
      "filename": "libctf/Makefile.am",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/Makefile.am?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -21,11 +21,18 @@ ACLOCAL_AMFLAGS = -I .. -I ../config\n \n AUTOMAKE_OPTIONS = foreign no-texinfo.tex\n \n+# This is where we get zlib from.  zlibdir is -L../zlib and zlibinc is\n+# -I../zlib, unless we were configured with --with-system-zlib, in which\n+# case both are empty.\n+ZLIB = @zlibdir@ -lz\n+ZLIBINC = @zlibinc@\n+\n AM_CPPFLAGS = -D_GNU_SOURCE -I$(top_srcdir) -I$(top_srcdir)/../include -I$(top_srcdir)/../bfd -I../bfd\n-AM_CFLAGS = -std=gnu99 @ac_libctf_warn_cflags@ @warn@ @c_warn@ @WARN_PEDANTIC@ @WERROR@\n+AM_CFLAGS = -std=gnu99 @ac_libctf_warn_cflags@ @warn@ @c_warn@ @WARN_PEDANTIC@ @WERROR@ $(ZLIBINC)\n \n noinst_LIBRARIES = libctf.a\n \n libctf_a_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c ctf-decl.c ctf-error.c \\\n \t\t   ctf-hash.c ctf-labels.c ctf-lookup.c ctf-open.c ctf-open-bfd.c \\\n \t\t   ctf-subr.c ctf-types.c ctf-util.c\n+libctf_a_LIBADD = $(LIBOBJS)"
    },
    {
      "sha": "c2cada66167005a47ee9e917e3fcedd882c4d992",
      "filename": "libctf/Makefile.in",
      "status": "modified",
      "additions": 18,
      "deletions": 6,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/Makefile.in?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -109,7 +109,8 @@ ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n \t$(top_srcdir)/../config/lead-dot.m4 \\\n \t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/warnings.m4 $(top_srcdir)/configure.ac\n+\t$(top_srcdir)/../config/warnings.m4 \\\n+\t$(top_srcdir)/../config/zlib.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \\\n@@ -127,7 +128,7 @@ am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)\n am__v_AR_0 = @echo \"  AR      \" $@;\n am__v_AR_1 = \n libctf_a_AR = $(AR) $(ARFLAGS)\n-libctf_a_LIBADD =\n+libctf_a_DEPENDENCIES = $(LIBOBJS)\n am_libctf_a_OBJECTS = ctf-archive.$(OBJEXT) ctf-dump.$(OBJEXT) \\\n \tctf-create.$(OBJEXT) ctf-decl.$(OBJEXT) ctf-error.$(OBJEXT) \\\n \tctf-hash.$(OBJEXT) ctf-labels.$(OBJEXT) ctf-lookup.$(OBJEXT) \\\n@@ -194,7 +195,8 @@ AM_RECURSIVE_TARGETS = cscope\n am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/config.h.in \\\n \t$(top_srcdir)/../ar-lib $(top_srcdir)/../compile \\\n \t$(top_srcdir)/../depcomp $(top_srcdir)/../install-sh \\\n-\t$(top_srcdir)/../missing $(top_srcdir)/../mkinstalldirs\n+\t$(top_srcdir)/../missing $(top_srcdir)/../mkinstalldirs \\\n+\tChangeLog qsort_r.c\n DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n distdir = $(PACKAGE)-$(VERSION)\n top_distdir = $(distdir)\n@@ -308,15 +310,24 @@ top_build_prefix = @top_build_prefix@\n top_builddir = @top_builddir@\n top_srcdir = @top_srcdir@\n warn = @warn@\n+zlibdir = @zlibdir@\n+zlibinc = @zlibinc@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n AUTOMAKE_OPTIONS = foreign no-texinfo.tex\n+\n+# This is where we get zlib from.  zlibdir is -L../zlib and zlibinc is\n+# -I../zlib, unless we were configured with --with-system-zlib, in which\n+# case both are empty.\n+ZLIB = @zlibdir@ -lz\n+ZLIBINC = @zlibinc@\n AM_CPPFLAGS = -D_GNU_SOURCE -I$(top_srcdir) -I$(top_srcdir)/../include -I$(top_srcdir)/../bfd -I../bfd\n-AM_CFLAGS = -std=gnu99 @ac_libctf_warn_cflags@ @warn@ @c_warn@ @WARN_PEDANTIC@ @WERROR@\n+AM_CFLAGS = -std=gnu99 @ac_libctf_warn_cflags@ @warn@ @c_warn@ @WARN_PEDANTIC@ @WERROR@ $(ZLIBINC)\n noinst_LIBRARIES = libctf.a\n libctf_a_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c ctf-decl.c ctf-error.c \\\n \t\t   ctf-hash.c ctf-labels.c ctf-lookup.c ctf-open.c ctf-open-bfd.c \\\n \t\t   ctf-subr.c ctf-types.c ctf-util.c\n \n+libctf_a_LIBADD = $(LIBOBJS)\n all: config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-am\n \n@@ -385,6 +396,7 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/qsort_r.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-archive.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-create.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-decl.Po@am__quote@\n@@ -675,7 +687,7 @@ clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am\n \n distclean: distclean-am\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR)\n+\t-rm -rf $(DEPDIR) ./$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-hdr distclean-tags\n@@ -723,7 +735,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-am\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR)\n+\t-rm -rf $(DEPDIR) ./$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n "
    },
    {
      "sha": "074f03638fcefb5b5d82ab4252897db0a358f27f",
      "filename": "libctf/aclocal.m4",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/aclocal.m4",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/aclocal.m4",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/aclocal.m4?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -1231,3 +1231,4 @@ m4_include([../config/depstand.m4])\n m4_include([../config/lead-dot.m4])\n m4_include([../config/override.m4])\n m4_include([../config/warnings.m4])\n+m4_include([../config/zlib.m4])"
    },
    {
      "sha": "0ecb5bb7211b98c550a472399e7aa9bc94d775a8",
      "filename": "libctf/config.h.in",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/config.h.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/config.h.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/config.h.in?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -1,11 +1,21 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n+/* Define if building universal (internal helper macro) */\n+#undef AC_APPLE_UNIVERSAL_BUILD\n+\n /* Whether libbfd was configured for an ELF target. */\n #undef HAVE_BFD_ELF\n \n /* Define to 1 if you have the <byteswap.h> header file. */\n #undef HAVE_BYTESWAP_H\n \n+/* Define to 1 if you have the declaration of `qsort_r', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_QSORT_R\n+\n+/* Define to 1 if you have the <endian.h> header file. */\n+#undef HAVE_ENDIAN_H\n+\n /* Define to 1 if you have the `getpagesize' function. */\n #undef HAVE_GETPAGESIZE\n \n@@ -94,6 +104,18 @@\n /* Version number of package */\n #undef VERSION\n \n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+#  undef WORDS_BIGENDIAN\n+# endif\n+#endif\n+\n /* Enable large inode numbers on Mac OS X 10.5.  */\n #ifndef _DARWIN_USE_64_BIT_INODE\n # define _DARWIN_USE_64_BIT_INODE 1"
    },
    {
      "sha": "4fb44eb2cc6d278faa3aa76b491c747b3ea0d0cd",
      "filename": "libctf/configure",
      "status": "modified",
      "additions": 318,
      "deletions": 4,
      "changes": 322,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/configure?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -624,6 +624,8 @@ ac_subst_vars='am__EXEEXT_FALSE\n am__EXEEXT_TRUE\n LTLIBOBJS\n LIBOBJS\n+zlibinc\n+zlibdir\n ac_libctf_warn_cflags\n MAINT\n MAINTAINER_MODE_FALSE\n@@ -728,6 +730,7 @@ enable_silent_rules\n enable_largefile\n enable_werror_always\n enable_maintainer_mode\n+with_system_zlib\n '\n       ac_precious_vars='build_alias\n host_alias\n@@ -1364,6 +1367,11 @@ Optional Features:\n                           enable make rules and dependencies not useful (and\n                           sometimes confusing) to the casual installer\n \n+Optional Packages:\n+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]\n+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)\n+  --with-system-zlib      use installed libz\n+\n Some influential environment variables:\n   CC          C compiler command\n   CFLAGS      C compiler flags\n@@ -1801,6 +1809,52 @@ $as_echo \"$ac_res\" >&6; }\n   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n \n } # ac_fn_c_check_func\n+\n+# ac_fn_c_check_decl LINENO SYMBOL VAR INCLUDES\n+# ---------------------------------------------\n+# Tests whether SYMBOL is declared in INCLUDES, setting cache variable VAR\n+# accordingly.\n+ac_fn_c_check_decl ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  as_decl_name=`echo $2|sed 's/ *(.*//'`\n+  as_decl_use=`echo $2|sed -e 's/(/((/' -e 's/)/) 0&/' -e 's/,/) 0& (/g'`\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $as_decl_name is declared\" >&5\n+$as_echo_n \"checking whether $as_decl_name is declared... \" >&6; }\n+if eval \\${$3+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+#ifndef $as_decl_name\n+#ifdef __cplusplus\n+  (void) $as_decl_use;\n+#else\n+  (void) $as_decl_name;\n+#endif\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$3=yes\"\n+else\n+  eval \"$3=no\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n+\n+} # ac_fn_c_check_decl\n cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n@@ -6031,6 +6085,23 @@ if test \"$ac_res\" != no; then :\n fi\n \n \n+  # Use the system's zlib library.\n+  zlibdir=\"-L\\$(top_builddir)/../zlib\"\n+  zlibinc=\"-I\\$(top_srcdir)/../zlib\"\n+\n+# Check whether --with-system-zlib was given.\n+if test \"${with_system_zlib+set}\" = set; then :\n+  withval=$with_system_zlib; if test x$with_system_zlib = xyes ; then\n+    zlibdir=\n+    zlibinc=\n+  fi\n+\n+fi\n+\n+\n+\n+\n+\n # Similar to GDB_AC_CHECK_BFD.\n OLD_CFLAGS=$CFLAGS\n OLD_LDFLAGS=$LDFLAGS\n@@ -6082,12 +6153,237 @@ $as_echo \"#define HAVE_BFD_ELF 1\" >>confdefs.h\n \n fi\n \n-for ac_header in byteswap.h\n+ { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian\" >&5\n+$as_echo_n \"checking whether byte ordering is bigendian... \" >&6; }\n+if ${ac_cv_c_bigendian+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_cv_c_bigendian=unknown\n+    # See if we're dealing with a universal compiler.\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#ifndef __APPLE_CC__\n+\t       not a universal capable compiler\n+\t     #endif\n+\t     typedef int dummy;\n+\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+\t# Check for potential -arch flags.  It is not universal unless\n+\t# there are at least two -arch flags with different values.\n+\tac_arch=\n+\tac_prev=\n+\tfor ac_word in $CC $CFLAGS $CPPFLAGS $LDFLAGS; do\n+\t if test -n \"$ac_prev\"; then\n+\t   case $ac_word in\n+\t     i?86 | x86_64 | ppc | ppc64)\n+\t       if test -z \"$ac_arch\" || test \"$ac_arch\" = \"$ac_word\"; then\n+\t\t ac_arch=$ac_word\n+\t       else\n+\t\t ac_cv_c_bigendian=universal\n+\t\t break\n+\t       fi\n+\t       ;;\n+\t   esac\n+\t   ac_prev=\n+\t elif test \"x$ac_word\" = \"x-arch\"; then\n+\t   ac_prev=arch\n+\t fi\n+       done\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+    if test $ac_cv_c_bigendian = unknown; then\n+      # See if sys/param.h defines the BYTE_ORDER macro.\n+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <sys/types.h>\n+\t     #include <sys/param.h>\n+\n+int\n+main ()\n+{\n+#if ! (defined BYTE_ORDER && defined BIG_ENDIAN \\\n+\t\t     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN \\\n+\t\t     && LITTLE_ENDIAN)\n+\t      bogus endian macros\n+\t     #endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  # It does; now see whether it defined to BIG_ENDIAN or not.\n+\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <sys/types.h>\n+\t\t#include <sys/param.h>\n+\n+int\n+main ()\n+{\n+#if BYTE_ORDER != BIG_ENDIAN\n+\t\t not big endian\n+\t\t#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_cv_c_bigendian=yes\n+else\n+  ac_cv_c_bigendian=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+    fi\n+    if test $ac_cv_c_bigendian = unknown; then\n+      # See if <limits.h> defines _LITTLE_ENDIAN or _BIG_ENDIAN (e.g., Solaris).\n+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <limits.h>\n+\n+int\n+main ()\n+{\n+#if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)\n+\t      bogus endian macros\n+\t     #endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  # It does; now see whether it defined to _BIG_ENDIAN or not.\n+\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <limits.h>\n+\n+int\n+main ()\n+{\n+#ifndef _BIG_ENDIAN\n+\t\t not big endian\n+\t\t#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_cv_c_bigendian=yes\n+else\n+  ac_cv_c_bigendian=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+    fi\n+    if test $ac_cv_c_bigendian = unknown; then\n+      # Compile a test program.\n+      if test \"$cross_compiling\" = yes; then :\n+  # Try to guess by grepping values from an object file.\n+\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+short int ascii_mm[] =\n+\t\t  { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };\n+\t\tshort int ascii_ii[] =\n+\t\t  { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };\n+\t\tint use_ascii (int i) {\n+\t\t  return ascii_mm[i] + ascii_ii[i];\n+\t\t}\n+\t\tshort int ebcdic_ii[] =\n+\t\t  { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };\n+\t\tshort int ebcdic_mm[] =\n+\t\t  { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };\n+\t\tint use_ebcdic (int i) {\n+\t\t  return ebcdic_mm[i] + ebcdic_ii[i];\n+\t\t}\n+\t\textern int foo;\n+\n+int\n+main ()\n+{\n+return use_ascii (foo) == use_ebcdic (foo);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null; then\n+\t      ac_cv_c_bigendian=yes\n+\t    fi\n+\t    if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then\n+\t      if test \"$ac_cv_c_bigendian\" = unknown; then\n+\t\tac_cv_c_bigendian=no\n+\t      else\n+\t\t# finding both strings is unlikely to happen, but who knows?\n+\t\tac_cv_c_bigendian=unknown\n+\t      fi\n+\t    fi\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+\n+\t     /* Are we little or big endian?  From Harbison&Steele.  */\n+\t     union\n+\t     {\n+\t       long int l;\n+\t       char c[sizeof (long int)];\n+\t     } u;\n+\t     u.l = 1;\n+\t     return u.c[sizeof (long int) - 1] == 1;\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+  ac_cv_c_bigendian=no\n+else\n+  ac_cv_c_bigendian=yes\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+    fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_bigendian\" >&5\n+$as_echo \"$ac_cv_c_bigendian\" >&6; }\n+ case $ac_cv_c_bigendian in #(\n+   yes)\n+     $as_echo \"#define WORDS_BIGENDIAN 1\" >>confdefs.h\n+;; #(\n+   no)\n+      ;; #(\n+   universal)\n+\n+$as_echo \"#define AC_APPLE_UNIVERSAL_BUILD 1\" >>confdefs.h\n+\n+     ;; #(\n+   *)\n+     as_fn_error $? \"unknown endianness\n+ presetting ac_cv_c_bigendian=no (or yes) will help\" \"$LINENO\" 5 ;;\n+ esac\n+\n+for ac_header in byteswap.h endian.h\n do :\n-  ac_fn_c_check_header_mongrel \"$LINENO\" \"byteswap.h\" \"ac_cv_header_byteswap_h\" \"$ac_includes_default\"\n-if test \"x$ac_cv_header_byteswap_h\" = xyes; then :\n+  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n+ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\n+if eval test \\\"x\\$\"$as_ac_Header\"\\\" = x\"yes\"; then :\n   cat >>confdefs.h <<_ACEOF\n-#define HAVE_BYTESWAP_H 1\n+#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n _ACEOF\n \n fi\n@@ -6105,6 +6401,23 @@ _ACEOF\n fi\n done\n \n+ac_fn_c_check_decl \"$LINENO\" \"qsort_r\" \"ac_cv_have_decl_qsort_r\" \"$ac_includes_default\"\n+if test \"x$ac_cv_have_decl_qsort_r\" = xyes; then :\n+  ac_have_decl=1\n+else\n+  ac_have_decl=0\n+fi\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_QSORT_R $ac_have_decl\n+_ACEOF\n+\n+case \" $LIBOBJS \" in\n+  *\" qsort_r.$ac_objext \"* ) ;;\n+  *) LIBOBJS=\"$LIBOBJS qsort_r.$ac_objext\"\n+ ;;\n+esac\n+\n \n ac_config_files=\"$ac_config_files Makefile\"\n \n@@ -6248,6 +6561,7 @@ if test -z \"${MAINTAINER_MODE_TRUE}\" && test -z \"${MAINTAINER_MODE_FALSE}\"; then\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n \n+\n : \"${CONFIG_STATUS=./config.status}\"\n ac_write_fail=0\n ac_clean_files_save=$ac_clean_files"
    },
    {
      "sha": "8fd5388d2a0b2c5b014e792f1515525a48fd9a79",
      "filename": "libctf/configure.ac",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/configure.ac?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -56,6 +56,7 @@ ACX_PROG_CC_WARNING_OPTS([-Wall], [ac_libctf_warn_cflags])\n \n AC_FUNC_MMAP\n AC_SEARCH_LIBS(dlopen, dl)\n+AM_ZLIB\n \n # Similar to GDB_AC_CHECK_BFD.\n OLD_CFLAGS=$CFLAGS\n@@ -86,8 +87,11 @@ if test $ac_cv_libctf_bfd_elf = yes; then\n \t    [Whether libbfd was configured for an ELF target.])\n fi\n \n-AC_CHECK_HEADERS(byteswap.h)\n+AC_C_BIGENDIAN\n+AC_CHECK_HEADERS(byteswap.h endian.h)\n AC_CHECK_FUNCS(pread)\n+AC_CHECK_DECLS([qsort_r])\n+AC_LIBOBJ([qsort_r])\n \n AC_CONFIG_FILES(Makefile)\n AC_CONFIG_HEADERS(config.h)"
    },
    {
      "sha": "a238edb66baaa5f666dc74e7efeb40b195f09de0",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -21,7 +21,7 @@\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <elf.h>\n-#include <endian.h>\n+#include \"ctf-endian.h\"\n #include <errno.h>\n #include <fcntl.h>\n #include <stdio.h>\n@@ -150,7 +150,6 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n       strcpy (&nametbl[namesz], names[i]);\n \n       off = arc_write_one_ctf (ctf_files[i], fd, threshold);\n-      ctf_dprintf (\"Written %s, offset now %zi\\n\", names[i], off);\n       if ((off < 0) && (off > -ECTF_BASE))\n \t{\n \t  errmsg = \"ctf_arc_write(): Cannot determine file \"\n@@ -512,16 +511,13 @@ ctf_arc_open_by_offset (const struct ctf_archive *arc,\n \n   ctf_dprintf (\"ctf_arc_open_by_offset(%zi): opening\\n\", offset);\n \n-  bzero (&ctfsect, sizeof (ctf_sect_t));\n+  memset (&ctfsect, 0, sizeof (ctf_sect_t));\n \n   offset += le64toh (arc->ctfa_ctfs);\n \n   ctfsect.cts_name = _CTF_SECTION;\n-  ctfsect.cts_type = SHT_PROGBITS;\n-  ctfsect.cts_flags = SHF_ALLOC;\n   ctfsect.cts_size = le64toh (*((uint64_t *) ((char *) arc + offset)));\n   ctfsect.cts_entsize = 1;\n-  ctfsect.cts_offset = 0;\n   ctfsect.cts_data = (void *) ((char *) arc + offset + sizeof (uint64_t));\n   fp = ctf_bufopen (&ctfsect, symsect, strsect, errp);\n   if (fp)"
    },
    {
      "sha": "227f62d8fd73b6cf56eb1523815a6f2806d0877c",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 28,
      "deletions": 22,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -23,6 +23,10 @@\n #include <string.h>\n #include <zlib.h>\n \n+#ifndef roundup\n+#define roundup(x, y)  ((((x) + ((y) - 1)) / (y)) * (y))\n+#endif\n+\n /* To create an empty CTF container, we just declare a zeroed header and call\n    ctf_bufopen() on it.  If ctf_bufopen succeeds, we mark the new container r/w\n    and initialize the dynamic members.  We set dtvstrlen to 1 to reserve the\n@@ -67,12 +71,9 @@ ctf_create (int *errp)\n     }\n \n   cts.cts_name = _CTF_SECTION;\n-  cts.cts_type = SHT_PROGBITS;\n-  cts.cts_flags = 0;\n   cts.cts_data = &hdr;\n   cts.cts_size = sizeof (hdr);\n   cts.cts_entsize = 1;\n-  cts.cts_offset = 0;\n \n   if ((fp = ctf_bufopen (&cts, NULL, NULL, errp)) == NULL)\n       goto err_dtbyname;\n@@ -812,7 +813,7 @@ ctf_add_reftype (ctf_file_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n   ctf_id_t type;\n   ctf_file_t *tmp = fp;\n \n-  if (ref == CTF_ERR || ref < 0 || ref > CTF_MAX_TYPE)\n+  if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, EINVAL));\n \n   if (ctf_lookup_by_id (&tmp, ref) == NULL)\n@@ -843,7 +844,7 @@ ctf_add_slice (ctf_file_t *fp, uint32_t flag, ctf_id_t ref,\n   if ((ep->cte_bits > 255) || (ep->cte_offset > 255))\n     return (ctf_set_errno (fp, ECTF_SLICEOVERFLOW));\n \n-  if (ref == CTF_ERR || ref < 0 || ref > CTF_MAX_TYPE)\n+  if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, EINVAL));\n \n   if ((tp = ctf_lookup_by_id (&tmp, ref)) == NULL)\n@@ -1175,7 +1176,7 @@ ctf_add_typedef (ctf_file_t *fp, uint32_t flag, const char *name,\n   ctf_id_t type;\n   ctf_file_t *tmp = fp;\n \n-  if (ref == CTF_ERR || ref < 0 || ref > CTF_MAX_TYPE)\n+  if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, EINVAL));\n \n   if (ctf_lookup_by_id (&tmp, ref) == NULL)\n@@ -1304,9 +1305,9 @@ ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n \t}\n     }\n \n-  if ((msize = ctf_type_size (fp, type)) == CTF_ERR ||\n-      (malign = ctf_type_align (fp, type)) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+  if ((msize = ctf_type_size (fp, type)) < 0 ||\n+      (malign = ctf_type_align (fp, type)) < 0)\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((dmd = ctf_alloc (sizeof (ctf_dmdef_t))) == NULL)\n     return (ctf_set_errno (fp, EAGAIN));\n@@ -1334,9 +1335,9 @@ ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n \t  ctf_encoding_t linfo;\n \t  ssize_t lsize;\n \n-\t  if (ctf_type_encoding (fp, ltype, &linfo) != CTF_ERR)\n+\t  if (ctf_type_encoding (fp, ltype, &linfo) == 0)\n \t    off += linfo.cte_bits;\n-\t  else if ((lsize = ctf_type_size (fp, ltype)) != CTF_ERR)\n+\t  else if ((lsize = ctf_type_size (fp, ltype)) > 0)\n \t    off += lsize * NBBY;\n \n \t  /* Round up the offset of the end of the last member to\n@@ -1359,7 +1360,7 @@ ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n \n \t  dmd->dmd_offset = bit_offset;\n \t  ssize = ctf_get_ctt_size (fp, &dtd->dtd_data, NULL, NULL);\n-\t  ssize = MAX (ssize, (bit_offset / NBBY) + msize);\n+\t  ssize = MAX (ssize, ((signed) bit_offset / NBBY) + msize);\n \t}\n     }\n   else\n@@ -1369,7 +1370,7 @@ ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n       ssize = MAX (ssize, msize);\n     }\n \n-  if (ssize > CTF_MAX_SIZE)\n+  if ((size_t) ssize > CTF_MAX_SIZE)\n     {\n       dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n       dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (ssize);\n@@ -1401,7 +1402,7 @@ ctf_add_member_encoded (ctf_file_t *fp, ctf_id_t souid, const char *name,\n     return (ctf_set_errno (fp, ECTF_NOTINTFP));\n \n   if ((type = ctf_add_slice (fp, CTF_ADD_NONROOT, otype, &encoding)) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   return ctf_add_member_offset (fp, souid, name, type, bit_offset);\n }\n@@ -1426,7 +1427,7 @@ ctf_add_variable (ctf_file_t *fp, const char *name, ctf_id_t ref)\n     return (ctf_set_errno (fp, ECTF_DUPLICATE));\n \n   if (ctf_lookup_by_id (&tmp, ref) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((dvd = ctf_alloc (sizeof (ctf_dvdef_t))) == NULL)\n     return (ctf_set_errno (fp, EAGAIN));\n@@ -1452,7 +1453,7 @@ enumcmp (const char *name, int value, void *arg)\n   ctf_bundle_t *ctb = arg;\n   int bvalue;\n \n-  if (ctf_enum_value (ctb->ctb_file, ctb->ctb_type, name, &bvalue) == CTF_ERR)\n+  if (ctf_enum_value (ctb->ctb_file, ctb->ctb_type, name, &bvalue) < 0)\n     {\n       ctf_dprintf (\"Conflict due to member %s iteration error.\\n\", name);\n       return 1;\n@@ -1472,7 +1473,7 @@ enumadd (const char *name, int value, void *arg)\n   ctf_bundle_t *ctb = arg;\n \n   return (ctf_add_enumerator (ctb->ctb_file, ctb->ctb_type,\n-\t\t\t      name, value) == CTF_ERR);\n+\t\t\t      name, value) < 0);\n }\n \n static int\n@@ -1482,7 +1483,7 @@ membcmp (const char *name, ctf_id_t type _libctf_unused_, unsigned long offset,\n   ctf_bundle_t *ctb = arg;\n   ctf_membinfo_t ctm;\n \n-  if (ctf_member_info (ctb->ctb_file, ctb->ctb_type, name, &ctm) == CTF_ERR)\n+  if (ctf_member_info (ctb->ctb_file, ctb->ctb_type, name, &ctm) < 0)\n     {\n       ctf_dprintf (\"Conflict due to member %s iteration error.\\n\", name);\n       return 1;\n@@ -1550,7 +1551,6 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \n   ctf_dtdef_t *dtd;\n   ctf_funcinfo_t ctc;\n-  ssize_t size;\n \n   ctf_hash_t *hp;\n \n@@ -1756,7 +1756,7 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n       break;\n \n     case CTF_K_ARRAY:\n-      if (ctf_array_info (src_fp, src_type, &src_ar) == CTF_ERR)\n+      if (ctf_array_info (src_fp, src_type, &src_ar) != 0)\n \treturn (ctf_set_errno (dst_fp, ctf_errno (src_fp)));\n \n       src_ar.ctr_contents =\n@@ -1803,6 +1803,8 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n       {\n \tctf_dmdef_t *dmd;\n \tint errs = 0;\n+\tsize_t size;\n+\tssize_t ssize;\n \n \t/* Technically to match a struct or union we need to check both\n \t   ways (src members vs. dst, dst members vs. src) but we make\n@@ -1818,7 +1820,7 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \t\tctf_type_size (dst_fp, dst_type))\n \t      {\n \t\tctf_dprintf (\"Conflict for type %s against ID %lx: \"\n-\t\t\t     \"union size differs, old %li, new %li\\n\",\n+\t\t\t     \"union size differs, old %zi, new %zi\\n\",\n \t\t\t     name, dst_type, ctf_type_size (src_fp, src_type),\n \t\t\t     ctf_type_size (dst_fp, dst_type));\n \t\treturn (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n@@ -1848,7 +1850,11 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \tif (ctf_member_iter (src_fp, src_type, membadd, &dst) != 0)\n \t  errs++;\t       /* Increment errs and fail at bottom of case.  */\n \n-\tif ((size = ctf_type_size (src_fp, src_type)) > CTF_MAX_SIZE)\n+\tif ((ssize = ctf_type_size (src_fp, src_type)) < 0)\n+\t  return CTF_ERR;\t\t\t/* errno is set for us.  */\n+\n+\tsize = (size_t) ssize;\n+\tif (size > CTF_MAX_SIZE)\n \t  {\n \t    dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n \t    dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);"
    },
    {
      "sha": "5e9ede48099de2c105d408609c6a0ba17a80b714",
      "filename": "libctf/ctf-decls.h",
      "status": "added",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-decls.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-decls.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-decls.h?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -0,0 +1,37 @@\n+/* Declarations for missing functions.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _CTF_DECLS_H\n+#define _CTF_DECLS_H\n+\n+#include \"config.h\"\n+\n+#if !HAVE_DECL_QSORT_R\n+#include <stddef.h>\n+void qsort_r (void *base, size_t nmemb, size_t size,\n+\t      int (*compar)(const void *, const void *, void *),\n+\t      void *arg);\n+#endif /* !HAVE_DECL_QSORT_R */\n+\n+#undef MAX\n+#undef MIN\n+#define MAX(a, b) ((a) > (b) ? (a) : (b))\n+#define MIN(a, b) ((a) < (b) ? (a) : (b))\n+\n+#endif /* _CTF_DECLS_H */"
    },
    {
      "sha": "c2ed791eea690cbb0885fa6e0dc23c1f72ce9b2d",
      "filename": "libctf/ctf-dump.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-dump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-dump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dump.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -88,7 +88,7 @@ ctf_is_slice (ctf_file_t *fp, ctf_id_t id, ctf_encoding_t *enc)\n   return (((kind == CTF_K_INTEGER) || (kind == CTF_K_ENUM)\n \t   || (kind == CTF_K_FLOAT))\n \t  && ctf_type_reference (fp, id) != CTF_ERR\n-\t  && ctf_type_encoding (fp, id, enc) != CTF_ERR);\n+\t  && ctf_type_encoding (fp, id, enc) == 0);\n }\n \n /* Return a dump for a single type, without member info: but do show the\n@@ -168,7 +168,7 @@ ctf_dump_label (const char *name, const ctf_lblinfo_t *info,\n   if ((typestr = ctf_dump_format_type (state->cds_fp, info->ctb_type)) == NULL)\n     {\n       free (str);\n-      return CTF_ERR;\t\t\t/* errno is set for us.  */\n+      return -1;\t\t\t/* errno is set for us.  */\n     }\n \n   str = ctf_str_append (str, typestr);\n@@ -194,14 +194,14 @@ ctf_dump_objts (ctf_file_t *fp, ctf_dump_state_t *state)\n       const char *sym_name;\n       ctf_id_t type;\n \n-      if ((type = ctf_lookup_by_symbol (state->cds_fp, i)) < 0)\n+      if ((type = ctf_lookup_by_symbol (state->cds_fp, i)) == CTF_ERR)\n \tswitch (ctf_errno (state->cds_fp))\n \t  {\n \t    /* Most errors are just an indication that this symbol is not a data\n \t       symbol, but this one indicates that we were called wrong, on a\n \t       CTF file with no associated symbol table.  */\n \t  case ECTF_NOSYMTAB:\n-\t    return CTF_ERR;\n+\t    return -1;\n \t  case ECTF_NOTDATA:\n \t  case ECTF_NOTYPEDAT:\n \t    continue;\n@@ -224,7 +224,7 @@ ctf_dump_objts (ctf_file_t *fp, ctf_dump_state_t *state)\n       if ((typestr = ctf_dump_format_type (state->cds_fp, type)) == NULL)\n \t{\n \t  free (str);\n-\t  return CTF_ERR;\t\t/* errno is set for us.  */\n+\t  return -1;\t\t\t/* errno is set for us.  */\n \t}\n \n       str = ctf_str_append (str, typestr);\n@@ -253,14 +253,14 @@ ctf_dump_funcs (ctf_file_t *fp, ctf_dump_state_t *state)\n       size_t j;\n       ctf_id_t *args;\n \n-      if ((type = ctf_func_info (state->cds_fp, i, &fi)) < 0)\n+      if ((type = ctf_func_info (state->cds_fp, i, &fi)) == CTF_ERR)\n \tswitch (ctf_errno (state->cds_fp))\n \t  {\n \t    /* Most errors are just an indication that this symbol is not a data\n \t       symbol, but this one indicates that we were called wrong, on a\n \t       CTF file with no associated symbol table.  */\n \t  case ECTF_NOSYMTAB:\n-\t    return CTF_ERR;\n+\t    return -1;\n \t  case ECTF_NOTDATA:\n \t  case ECTF_NOTYPEDAT:\n \t    continue;\n@@ -321,7 +321,7 @@ ctf_dump_funcs (ctf_file_t *fp, ctf_dump_state_t *state)\n     err:\n       free (args);\n       free (str);\n-      return CTF_ERR;\t\t/* errno is set for us.  */\n+      return -1;\t\t/* errno is set for us.  */\n     }\n   return 0;\n }\n@@ -340,7 +340,7 @@ ctf_dump_var (const char *name, ctf_id_t type, void *arg)\n   if ((typestr = ctf_dump_format_type (state->cds_fp, type)) == NULL)\n     {\n       free (str);\n-      return CTF_ERR;\t\t\t/* errno is set for us.  */\n+      return -1;\t\t\t/* errno is set for us.  */\n     }\n \n   str = ctf_str_append (str, typestr);\n@@ -426,7 +426,7 @@ ctf_dump_type (ctf_id_t id, void *arg)\n \n  err:\n   free (str);\n-  return CTF_ERR;\t\t\t/* errno is set for us.  */\n+  return -1;\t\t\t\t/* errno is set for us.  */\n }\n \n /* Dump the string table into the cds_items.  */"
    },
    {
      "sha": "ec177d1bdd816e4a56a406519b923bfbfaae8243",
      "filename": "libctf/ctf-endian.h",
      "status": "added",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-endian.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-endian.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-endian.h?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -0,0 +1,37 @@\n+/* Interface to endianness-neutrality functions.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _CTF_ENDIAN_H\n+#define _CTF_ENDIAN_H\n+\n+#include \"config.h\"\n+#include <stdint.h>\n+#include \"swap.h\"\n+\n+#ifndef HAVE_ENDIAN_H\n+#ifndef WORDS_BIGENDIAN\n+# define htole64(x) bswap_identity_64 ((x))\n+# define le64toh(x) bswap_identity_64 ((x))\n+#else\n+# define htole64(x) bswap_64 ((x))\n+# define le64toh(x) bswap_64 ((x))\n+#endif /* WORDS_BIGENDIAN */\n+#endif /* !defined(HAVE_ENDIAN_H) */\n+\n+#endif /* !defined(_CTF_ENDIAN_H) */"
    },
    {
      "sha": "fa9c574941415a3f896b6fbe9710782cc296ece5",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -21,7 +21,8 @@\n #define\t_CTF_IMPL_H\n \n #include \"config.h\"\n-#include <sys/errno.h>\n+#include <errno.h>\n+#include \"ctf-decls.h\"\n #include <ctf-api.h>\n #include <sys/types.h>\n #include <stdlib.h>\n@@ -339,7 +340,7 @@ extern struct ctf_archive *ctf_arc_open_internal (const char *, int *);\n extern struct ctf_archive *ctf_arc_bufopen (const void *, size_t, int *);\n extern void ctf_arc_close_internal (struct ctf_archive *);\n extern void *ctf_set_open_errno (int *, int);\n-extern long ctf_set_errno (ctf_file_t *, int);\n+extern unsigned long ctf_set_errno (ctf_file_t *, int);\n \n _libctf_malloc_\n extern void *ctf_data_alloc (size_t);"
    },
    {
      "sha": "1755b9720a61382d8830b7129b4b14a33c360021",
      "filename": "libctf/ctf-labels.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-labels.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-labels.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-labels.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -43,7 +43,7 @@ ctf_label_topmost (ctf_file_t *fp)\n   const char *s;\n   uint32_t num_labels = 0;\n \n-  if (extract_label_info (fp, &ctlp, &num_labels) == CTF_ERR)\n+  if (extract_label_info (fp, &ctlp, &num_labels) < 0)\n     return NULL;\t\t\t\t/* errno is set for us.  */\n \n   if (num_labels == 0)\n@@ -70,8 +70,8 @@ ctf_label_iter (ctf_file_t *fp, ctf_label_f *func, void *arg)\n   const char *lname;\n   int rc;\n \n-  if (extract_label_info (fp, &ctlp, &num_labels) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+  if (extract_label_info (fp, &ctlp, &num_labels) < 0)\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if (num_labels == 0)\n     return (ctf_set_errno (fp, ECTF_NOLABELDATA));\n@@ -128,7 +128,7 @@ ctf_label_info (ctf_file_t *fp, const char *lname, ctf_lblinfo_t *linfo)\n   cb_arg.lca_name = lname;\n   cb_arg.lca_info = linfo;\n \n-  if ((rc = ctf_label_iter (fp, label_info_cb, &cb_arg)) == CTF_ERR)\n+  if ((rc = ctf_label_iter (fp, label_info_cb, &cb_arg)) < 0)\n     return rc;\n \n   if (rc != 1)"
    },
    {
      "sha": "ab12715f4b1d557116ab4a5bc34178a453b3bf0d",
      "filename": "libctf/ctf-lookup.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -412,8 +412,8 @@ ctf_func_args (ctf_file_t * fp, unsigned long symidx, uint32_t argc,\n   const uint32_t *dp;\n   ctf_funcinfo_t f;\n \n-  if (ctf_func_info (fp, symidx, &f) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+  if (ctf_func_info (fp, symidx, &f) < 0)\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   /* The argument data is two uint32_t's past the translation table\n      offset: one for the function info, and one for the return type. */"
    },
    {
      "sha": "76b7f9d1629b5871a16c3bc04e372e732f927251",
      "filename": "libctf/ctf-open-bfd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 9,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-open-bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-open-bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open-bfd.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -97,10 +97,7 @@ ctf_bfdopen (struct bfd *abfd, int *errp)\n     }\n \n   ctfsect.cts_name = _CTF_SECTION;\n-  ctfsect.cts_type = SHT_PROGBITS;\n-  ctfsect.cts_flags = 0;\n   ctfsect.cts_entsize = 1;\n-  ctfsect.cts_offset = 0;\n   ctfsect.cts_size = bfd_section_size (abfd, ctf_asect);\n   ctfsect.cts_data = contents;\n \n@@ -158,10 +155,8 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n \t    }\n \t  strsect.cts_data = contents;\n \t  strsect.cts_name = (char *) strsect.cts_data + strhdr->sh_name;\n-\t  strsect.cts_type = strhdr->sh_type;\n-\t  strsect.cts_flags = strhdr->sh_flags;\n+\t  strsect.cts_size = bfd_section_size (abfd, str_asect);\n \t  strsect.cts_entsize = strhdr->sh_size;\n-\t  strsect.cts_offset = strhdr->sh_offset;\n \t  strsectp = &strsect;\n \n \t  if (!bfd_malloc_and_get_section (abfd, sym_asect, &contents))\n@@ -172,11 +167,9 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n \t    }\n \n \t  symsect.cts_name = (char *) strsect.cts_data + symhdr->sh_name;\n-\t  symsect.cts_type = symhdr->sh_type;\n-\t  symsect.cts_flags = symhdr->sh_flags;\n \t  symsect.cts_entsize = symhdr->sh_size;\n+\t  symsect.cts_size = bfd_section_size (abfd, sym_asect);\n \t  symsect.cts_data = contents;\n-\t  symsect.cts_offset = symhdr->sh_offset;\n \t  symsectp = &symsect;\n \t}\n     }"
    },
    {
      "sha": "1a517a140cae5284f107c22d2c5a665d58be8aaa",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -503,7 +503,7 @@ upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n \tcase CTF_K_UNION:\n \tcase CTF_K_ENUM:\n \tcase CTF_K_UNKNOWN:\n-\t  if (size <= CTF_MAX_SIZE)\n+\t  if ((size_t) size <= CTF_MAX_SIZE)\n \t    t2p->ctt_size = size;\n \t  else\n \t    {\n@@ -1170,10 +1170,7 @@ ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n   ctf_sect_t *strsectp = NULL;\n \n   skeleton.cts_name = _CTF_SECTION;\n-  skeleton.cts_type = SHT_PROGBITS;\n-  skeleton.cts_flags = 0;\n   skeleton.cts_entsize = 1;\n-  skeleton.cts_offset = 0;\n \n   if (ctfsect)\n     {\n@@ -1317,7 +1314,8 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n   if (hp.cth_flags & CTF_F_COMPRESS)\n     {\n-      size_t srclen, dstlen;\n+      size_t srclen;\n+      uLongf dstlen;\n       const void *src;\n       int rc = Z_OK;\n \n@@ -1339,7 +1337,7 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t  return (ctf_set_open_errno (errp, ECTF_DECOMPRESS));\n \t}\n \n-      if (dstlen != size)\n+      if ((size_t) dstlen != size)\n \t{\n \t  ctf_dprintf (\"zlib inflate short -- got %lu of %lu \"\n \t\t       \"bytes\\n\", (unsigned long) dstlen, (unsigned long) size);\n@@ -1678,12 +1676,15 @@ ctf_getmodel (ctf_file_t *fp)\n   return fp->ctf_dmodel->ctd_code;\n }\n \n+/* The caller can hang an arbitrary pointer off each ctf_file_t using this\n+   function.  */\n void\n ctf_setspecific (ctf_file_t *fp, void *data)\n {\n   fp->ctf_specific = data;\n }\n \n+/* Retrieve the arbitrary pointer again.  */\n void *\n ctf_getspecific (ctf_file_t *fp)\n {"
    },
    {
      "sha": "dc158e2f52bb692d9c07d9cf5c8e6269e935dd56",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 24,
      "deletions": 24,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -47,10 +47,10 @@ ctf_member_iter (ctf_file_t *fp, ctf_id_t type, ctf_member_f *func, void *arg)\n   int rc;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n   kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n@@ -102,10 +102,10 @@ ctf_enum_iter (ctf_file_t *fp, ctf_id_t type, ctf_enum_f *func, void *arg)\n   int rc;\n \n   if ((type = ctf_type_resolve_unsliced (fp, type)) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if (LCTF_INFO_KIND (fp, tp->ctt_info) != CTF_K_ENUM)\n     return (ctf_set_errno (ofp, ECTF_NOTENUM));\n@@ -406,8 +406,8 @@ ctf_type_size (ctf_file_t *fp, ctf_id_t type)\n       if ((size = ctf_get_ctt_size (fp, tp, NULL, NULL)) > 0)\n \treturn size;\n \n-      if (ctf_array_info (fp, type, &ar) == CTF_ERR\n-\t  || (size = ctf_type_size (fp, ar.ctr_contents)) == CTF_ERR)\n+      if (ctf_array_info (fp, type, &ar) < 0\n+\t  || (size = ctf_type_size (fp, ar.ctr_contents)) < 0)\n \treturn -1;\t\t/* errno is set for us.  */\n \n       return size * ar.ctr_nelems;\n@@ -445,7 +445,7 @@ ctf_type_align (ctf_file_t *fp, ctf_id_t type)\n     case CTF_K_ARRAY:\n       {\n \tctf_arinfo_t r;\n-\tif (ctf_array_info (fp, type, &r) == CTF_ERR)\n+\tif (ctf_array_info (fp, type, &r) < 0)\n \t  return -1;\t\t/* errno is set for us.  */\n \treturn (ctf_type_align (fp, r.ctr_contents));\n       }\n@@ -474,7 +474,7 @@ ctf_type_align (ctf_file_t *fp, ctf_id_t type)\n \t\tfor (; n != 0; n--, mp++)\n \t\t  {\n \t\t    ssize_t am = ctf_type_align (fp, mp->ctm_type);\n-\t\t    align = MAX (align, am);\n+\t\t    align = MAX (align, (size_t) am);\n \t\t  }\n \t      }\n \t    else\n@@ -483,7 +483,7 @@ ctf_type_align (ctf_file_t *fp, ctf_id_t type)\n \t\tfor (; n != 0; n--, lmp++)\n \t\t  {\n \t\t    ssize_t am = ctf_type_align (fp, lmp->ctlm_type);\n-\t\t    align = MAX (align, am);\n+\t\t    align = MAX (align, (size_t) am);\n \t\t  }\n \t      }\n \t  }\n@@ -495,7 +495,7 @@ ctf_type_align (ctf_file_t *fp, ctf_id_t type)\n \t\t   dmd != NULL; dmd = ctf_list_next (dmd))\n \t\t{\n \t\t  ssize_t am = ctf_type_align (fp, dmd->dmd_type);\n-\t\t  align = MAX (align, am);\n+\t\t  align = MAX (align, (size_t) am);\n \t\t  if (kind == CTF_K_STRUCT)\n \t\t    break;\n \t\t}\n@@ -520,7 +520,7 @@ ctf_type_kind_unsliced (ctf_file_t *fp, ctf_id_t type)\n   const ctf_type_t *tp;\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   return (LCTF_INFO_KIND (fp, tp->ctt_info));\n }\n@@ -533,13 +533,13 @@ ctf_type_kind (ctf_file_t *fp, ctf_id_t type)\n {\n   int kind;\n \n-  if ((kind = ctf_type_kind_unsliced (fp, type)) == CTF_ERR)\n-    return CTF_ERR;\n+  if ((kind = ctf_type_kind_unsliced (fp, type)) < 0)\n+    return -1;\n \n   if (kind == CTF_K_SLICE)\n     {\n       if ((type = ctf_type_reference (fp, type)) == CTF_ERR)\n-\treturn CTF_ERR;\n+\treturn -1;\n       kind = ctf_type_kind_unsliced (fp, type);\n     }\n \n@@ -624,7 +624,7 @@ ctf_type_encoding (ctf_file_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n   uint32_t data;\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((dtd = ctf_dynamic_type (ofp, type)) != NULL)\n     {\n@@ -790,10 +790,10 @@ ctf_member_info (ctf_file_t *fp, ctf_id_t type, const char *name,\n   uint32_t kind, n;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n   kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n@@ -847,7 +847,7 @@ ctf_array_info (ctf_file_t *fp, ctf_id_t type, ctf_arinfo_t *arp)\n   ssize_t increment;\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if (LCTF_INFO_KIND (fp, tp->ctt_info) != CTF_K_ARRAY)\n     return (ctf_set_errno (ofp, ECTF_NOTARRAY));\n@@ -919,15 +919,15 @@ ctf_enum_value (ctf_file_t * fp, ctf_id_t type, const char *name, int *valp)\n   uint32_t n;\n \n   if ((type = ctf_type_resolve_unsliced (fp, type)) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if (LCTF_INFO_KIND (fp, tp->ctt_info) != CTF_K_ENUM)\n     {\n       (void) ctf_set_errno (ofp, ECTF_NOTENUM);\n-      return CTF_ERR;\n+      return -1;\n     }\n \n   (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n@@ -945,7 +945,7 @@ ctf_enum_value (ctf_file_t * fp, ctf_id_t type, const char *name, int *valp)\n     }\n \n   (void) ctf_set_errno (ofp, ECTF_NOENUMNAM);\n-  return CTF_ERR;\n+  return -1;\n }\n \n /* Recursively visit the members of any type.  This function is used as the\n@@ -965,10 +965,10 @@ ctf_type_rvisit (ctf_file_t *fp, ctf_id_t type, ctf_visit_f *func,\n   int rc;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n-    return CTF_ERR;\t\t/* errno is set for us.  */\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if ((rc = func (name, otype, offset, depth, arg)) != 0)\n     return rc;"
    },
    {
      "sha": "730f358a9318a258704fce73d04fcf64d68bda6c",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -166,9 +166,9 @@ ctf_set_open_errno (int *errp, int error)\n }\n \n /* Store the specified error code into the CTF container, and then return\n-   CTF_ERR for the benefit of the caller. */\n+   CTF_ERR / -1 for the benefit of the caller. */\n \n-long\n+unsigned long\n ctf_set_errno (ctf_file_t * fp, int err)\n {\n   fp->ctf_errno = err;"
    },
    {
      "sha": "6c334fdaf39b3851a5ff3a4bc2a34822890b3ab3",
      "filename": "libctf/qsort_r.c",
      "status": "added",
      "additions": 259,
      "deletions": 0,
      "changes": 259,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/qsort_r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/qsort_r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/qsort_r.c?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -0,0 +1,259 @@\n+/* Copyright (C) 1991-2019 Free Software Foundation, Inc.\n+   This file is part of libctf (imported from Gnulib).\n+   Written by Douglas C. Schmidt (schmidt@ics.uci.edu).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <https://www.gnu.org/licenses/>.  */\n+\n+/* If you consider tuning this algorithm, you should consult first:\n+   Engineering a sort function; Jon Bentley and M. Douglas McIlroy;\n+   Software - Practice and Experience; Vol. 23 (11), 1249-1265, 1993.  */\n+\n+#ifndef _LIBC\n+# include <config.h>\n+#endif\n+\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"ctf-decls.h\"\n+\n+#ifndef _LIBC\n+# define _quicksort qsort_r\n+# define __compar_d_fn_t compar_d_fn_t\n+typedef int (*compar_d_fn_t) (const void *, const void *, void *);\n+#endif\n+\n+/* Byte-wise swap two items of size SIZE. */\n+#define SWAP(a, b, size)\t\t\t\t\t\t      \\\n+  do\t\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      size_t __size = (size);\t\t\t\t\t\t      \\\n+      char *__a = (a), *__b = (b);\t\t\t\t\t      \\\n+      do\t\t\t\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t\t      \\\n+\t  char __tmp = *__a;\t\t\t\t\t\t      \\\n+\t  *__a++ = *__b;\t\t\t\t\t\t      \\\n+\t  *__b++ = __tmp;\t\t\t\t\t\t      \\\n+\t} while (--__size > 0);\t\t\t\t\t\t      \\\n+    } while (0)\n+\n+/* Discontinue quicksort algorithm when partition gets below this size.\n+   This particular magic number was chosen to work best on a Sun 4/260. */\n+#define MAX_THRESH 4\n+\n+/* Stack node declarations used to store unfulfilled partition obligations. */\n+typedef struct\n+  {\n+    char *lo;\n+    char *hi;\n+  } stack_node;\n+\n+/* The next 4 #defines implement a very fast in-line stack abstraction. */\n+/* The stack needs log (total_elements) entries (we could even subtract\n+   log(MAX_THRESH)).  Since total_elements has type size_t, we get as\n+   upper bound for log (total_elements):\n+   bits per byte (CHAR_BIT) * sizeof(size_t).  */\n+#define STACK_SIZE\t(CHAR_BIT * sizeof(size_t))\n+#define PUSH(low, high)\t((void) ((top->lo = (low)), (top->hi = (high)), ++top))\n+#define\tPOP(low, high)\t((void) (--top, (low = top->lo), (high = top->hi)))\n+#define\tSTACK_NOT_EMPTY\t(stack < top)\n+\n+\n+/* Order size using quicksort.  This implementation incorporates\n+   four optimizations discussed in Sedgewick:\n+\n+   1. Non-recursive, using an explicit stack of pointer that store the\n+      next array partition to sort.  To save time, this maximum amount\n+      of space required to store an array of SIZE_MAX is allocated on the\n+      stack.  Assuming a 32-bit (64 bit) integer for size_t, this needs\n+      only 32 * sizeof(stack_node) == 256 bytes (for 64 bit: 1024 bytes).\n+      Pretty cheap, actually.\n+\n+   2. Chose the pivot element using a median-of-three decision tree.\n+      This reduces the probability of selecting a bad pivot value and\n+      eliminates certain extraneous comparisons.\n+\n+   3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving\n+      insertion sort to order the MAX_THRESH items within each partition.\n+      This is a big win, since insertion sort is faster for small, mostly\n+      sorted array segments.\n+\n+   4. The larger of the two sub-partitions is always pushed onto the\n+      stack first, with the algorithm then concentrating on the\n+      smaller partition.  This *guarantees* no more than log (total_elems)\n+      stack size is needed (actually O(1) in this case)!  */\n+\n+void\n+_quicksort (void *const pbase, size_t total_elems, size_t size,\n+\t    __compar_d_fn_t cmp, void *arg)\n+{\n+  char *base_ptr = (char *) pbase;\n+\n+  const size_t max_thresh = MAX_THRESH * size;\n+\n+  if (total_elems == 0)\n+    /* Avoid lossage with unsigned arithmetic below.  */\n+    return;\n+\n+  if (total_elems > MAX_THRESH)\n+    {\n+      char *lo = base_ptr;\n+      char *hi = &lo[size * (total_elems - 1)];\n+      stack_node stack[STACK_SIZE];\n+      stack_node *top = stack;\n+\n+      PUSH (NULL, NULL);\n+\n+      while (STACK_NOT_EMPTY)\n+        {\n+          char *left_ptr;\n+          char *right_ptr;\n+\n+\t  /* Select median value from among LO, MID, and HI. Rearrange\n+\t     LO and HI so the three values are sorted. This lowers the\n+\t     probability of picking a pathological pivot value and\n+\t     skips a comparison for both the LEFT_PTR and RIGHT_PTR in\n+\t     the while loops. */\n+\n+\t  char *mid = lo + size * ((hi - lo) / size >> 1);\n+\n+\t  if ((*cmp) ((void *) mid, (void *) lo, arg) < 0)\n+\t    SWAP (mid, lo, size);\n+\t  if ((*cmp) ((void *) hi, (void *) mid, arg) < 0)\n+\t    SWAP (mid, hi, size);\n+\t  else\n+\t    goto jump_over;\n+\t  if ((*cmp) ((void *) mid, (void *) lo, arg) < 0)\n+\t    SWAP (mid, lo, size);\n+\tjump_over:;\n+\n+\t  left_ptr  = lo + size;\n+\t  right_ptr = hi - size;\n+\n+\t  /* Here's the famous ``collapse the walls'' section of quicksort.\n+\t     Gotta like those tight inner loops!  They are the main reason\n+\t     that this algorithm runs much faster than others. */\n+\t  do\n+\t    {\n+\t      while ((*cmp) ((void *) left_ptr, (void *) mid, arg) < 0)\n+\t\tleft_ptr += size;\n+\n+\t      while ((*cmp) ((void *) mid, (void *) right_ptr, arg) < 0)\n+\t\tright_ptr -= size;\n+\n+\t      if (left_ptr < right_ptr)\n+\t\t{\n+\t\t  SWAP (left_ptr, right_ptr, size);\n+\t\t  if (mid == left_ptr)\n+\t\t    mid = right_ptr;\n+\t\t  else if (mid == right_ptr)\n+\t\t    mid = left_ptr;\n+\t\t  left_ptr += size;\n+\t\t  right_ptr -= size;\n+\t\t}\n+\t      else if (left_ptr == right_ptr)\n+\t\t{\n+\t\t  left_ptr += size;\n+\t\t  right_ptr -= size;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  while (left_ptr <= right_ptr);\n+\n+          /* Set up pointers for next iteration.  First determine whether\n+             left and right partitions are below the threshold size.  If so,\n+             ignore one or both.  Otherwise, push the larger partition's\n+             bounds on the stack and continue sorting the smaller one. */\n+\n+          if ((size_t) (right_ptr - lo) <= max_thresh)\n+            {\n+              if ((size_t) (hi - left_ptr) <= max_thresh)\n+\t\t/* Ignore both small partitions. */\n+                POP (lo, hi);\n+              else\n+\t\t/* Ignore small left partition. */\n+                lo = left_ptr;\n+            }\n+          else if ((size_t) (hi - left_ptr) <= max_thresh)\n+\t    /* Ignore small right partition. */\n+            hi = right_ptr;\n+          else if ((right_ptr - lo) > (hi - left_ptr))\n+            {\n+\t      /* Push larger left partition indices. */\n+              PUSH (lo, right_ptr);\n+              lo = left_ptr;\n+            }\n+          else\n+            {\n+\t      /* Push larger right partition indices. */\n+              PUSH (left_ptr, hi);\n+              hi = right_ptr;\n+            }\n+        }\n+    }\n+\n+  /* Once the BASE_PTR array is partially sorted by quicksort the rest\n+     is completely sorted using insertion sort, since this is efficient\n+     for partitions below MAX_THRESH size. BASE_PTR points to the beginning\n+     of the array to sort, and END_PTR points at the very last element in\n+     the array (*not* one beyond it!). */\n+\n+#define min(x, y) ((x) < (y) ? (x) : (y))\n+\n+  {\n+    char *const end_ptr = &base_ptr[size * (total_elems - 1)];\n+    char *tmp_ptr = base_ptr;\n+    char *thresh = min(end_ptr, base_ptr + max_thresh);\n+    char *run_ptr;\n+\n+    /* Find smallest element in first threshold and place it at the\n+       array's beginning.  This is the smallest array element,\n+       and the operation speeds up insertion sort's inner loop. */\n+\n+    for (run_ptr = tmp_ptr + size; run_ptr <= thresh; run_ptr += size)\n+      if ((*cmp) ((void *) run_ptr, (void *) tmp_ptr, arg) < 0)\n+        tmp_ptr = run_ptr;\n+\n+    if (tmp_ptr != base_ptr)\n+      SWAP (tmp_ptr, base_ptr, size);\n+\n+    /* Insertion sort, running from left-hand-side up to right-hand-side.  */\n+\n+    run_ptr = base_ptr + size;\n+    while ((run_ptr += size) <= end_ptr)\n+      {\n+\ttmp_ptr = run_ptr - size;\n+\twhile ((*cmp) ((void *) run_ptr, (void *) tmp_ptr, arg) < 0)\n+\t  tmp_ptr -= size;\n+\n+\ttmp_ptr += size;\n+        if (tmp_ptr != run_ptr)\n+          {\n+            char *trav;\n+\n+\t    trav = run_ptr + size;\n+\t    while (--trav >= run_ptr)\n+              {\n+                char c = *trav;\n+                char *hi, *lo;\n+\n+                for (hi = lo = trav; (lo -= size) >= tmp_ptr; hi = lo)\n+                  *hi = *lo;\n+                *hi = c;\n+              }\n+          }\n+      }\n+  }\n+}"
    },
    {
      "sha": "e75e8d408a95bd7ba16a8d9939e1f89628c2a23b",
      "filename": "libctf/swap.h",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/swap.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a0486bac41d6ce47f27795a5abbca5cc53ddba00/libctf/swap.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/swap.h?ref=a0486bac41d6ce47f27795a5abbca5cc53ddba00",
      "patch": "@@ -29,13 +29,13 @@\n \n /* Provide our own versions of the byteswap functions.  */\n inline uint16_t\n-bswap_16(uint16_t v)\n+bswap_16 (uint16_t v)\n {\n   return ((v >> 8) & 0xff) | ((v & 0xff) << 8);\n }\n \n inline uint32_t\n-bswap_32(uint32_t v)\n+bswap_32 (uint32_t v)\n {\n   return (  ((v & 0xff000000) >> 24)\n \t  | ((v & 0x00ff0000) >>  8)\n@@ -44,7 +44,13 @@ bswap_32(uint32_t v)\n }\n \n inline uint64_t\n-bswap_64(uint64_t v)\n+bswap_identity_64 (uint64_t v)\n+{\n+  return v;\n+}\n+\n+inline uint64_t\n+bswap_64 (uint64_t v)\n {\n   return (  ((v & 0xff00000000000000ULL) >> 56)\n \t  | ((v & 0x00ff000000000000ULL) >> 40)"
    }
  ]
}