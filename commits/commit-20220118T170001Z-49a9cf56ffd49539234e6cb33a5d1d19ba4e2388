{
  "sha": "49a9cf56ffd49539234e6cb33a5d1d19ba4e2388",
  "node_id": "C_kwDOANOeidoAKDQ5YTljZjU2ZmZkNDk1MzkyMzRlNmNiMzNhNWQxZDE5YmE0ZTIzODg",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-14T14:33:33Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-18T17:00:01Z"
    },
    "message": "Remove EL_* macros from location.c\n\nThis patch removes the old-style EL_* macros from location.c.  This\ncleans up the code by itself, IMO, but also enables further cleanups\nin subsequent patches.",
    "tree": {
      "sha": "e9a6e6dd9111a23dbe43810cce9ec6b476301e5e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e9a6e6dd9111a23dbe43810cce9ec6b476301e5e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/49a9cf56ffd49539234e6cb33a5d1d19ba4e2388",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/49a9cf56ffd49539234e6cb33a5d1d19ba4e2388",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/49a9cf56ffd49539234e6cb33a5d1d19ba4e2388",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/49a9cf56ffd49539234e6cb33a5d1d19ba4e2388/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7910e2dee3d8b5ea7f59973277baf95525c63be1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7910e2dee3d8b5ea7f59973277baf95525c63be1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7910e2dee3d8b5ea7f59973277baf95525c63be1"
    }
  ],
  "stats": {
    "total": 183,
    "additions": 90,
    "deletions": 93
  },
  "files": [
    {
      "sha": "9c33ea4746ebd98d5835f4270ce003be0a441167",
      "filename": "gdb/location.c",
      "status": "modified",
      "additions": 90,
      "deletions": 93,
      "changes": 183,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/49a9cf56ffd49539234e6cb33a5d1d19ba4e2388/gdb/location.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/49a9cf56ffd49539234e6cb33a5d1d19ba4e2388/gdb/location.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/location.c?ref=49a9cf56ffd49539234e6cb33a5d1d19ba4e2388",
      "patch": "@@ -37,39 +37,33 @@ struct event_location\n {\n   /* The type of this breakpoint specification.  */\n   enum event_location_type type;\n-#define EL_TYPE(P) (P)->type\n \n   union\n   {\n     /* A probe.  */\n     char *addr_string;\n-#define EL_PROBE(P) ((P)->u.addr_string)\n \n     /* A \"normal\" linespec.  */\n     struct linespec_location linespec_location;\n-#define EL_LINESPEC(P) (&(P)->u.linespec_location)\n \n     /* An address in the inferior.  */\n     CORE_ADDR address;\n-#define EL_ADDRESS(P) (P)->u.address\n \n     /* An explicit location.  */\n     struct explicit_location explicit_loc;\n-#define EL_EXPLICIT(P) (&((P)->u.explicit_loc))\n   } u;\n \n   /* Cached string representation of this location.  This is used, e.g., to\n      save stop event locations to file.  Malloc'd.  */\n   char *as_string;\n-#define EL_STRING(P) ((P)->as_string)\n };\n \n /* See description in location.h.  */\n \n enum event_location_type\n event_location_type (const struct event_location *location)\n {\n-  return EL_TYPE (location);\n+  return location->type;\n }\n \n /* See description in location.h.  */\n@@ -91,8 +85,8 @@ new_linespec_location (const char **linespec,\n   struct event_location *location;\n \n   location = XCNEW (struct event_location);\n-  EL_TYPE (location) = LINESPEC_LOCATION;\n-  EL_LINESPEC (location)->match_type = match_type;\n+  location->type = LINESPEC_LOCATION;\n+  location->u.linespec_location.match_type = match_type;\n   if (*linespec != NULL)\n     {\n       const char *p;\n@@ -101,7 +95,8 @@ new_linespec_location (const char **linespec,\n       linespec_lex_to_end (linespec);\n       p = remove_trailing_whitespace (orig, *linespec);\n       if ((p - orig) > 0)\n-\tEL_LINESPEC (location)->spec_string = savestring (orig, p - orig);\n+\tlocation->u.linespec_location.spec_string\n+\t  = savestring (orig, p - orig);\n     }\n   return event_location_up (location);\n }\n@@ -111,8 +106,8 @@ new_linespec_location (const char **linespec,\n const linespec_location *\n get_linespec_location (const struct event_location *location)\n {\n-  gdb_assert (EL_TYPE (location) == LINESPEC_LOCATION);\n-  return EL_LINESPEC (location);\n+  gdb_assert (location->type == LINESPEC_LOCATION);\n+  return &location->u.linespec_location;\n }\n \n /* See description in location.h.  */\n@@ -124,10 +119,10 @@ new_address_location (CORE_ADDR addr, const char *addr_string,\n   struct event_location *location;\n \n   location = XCNEW (struct event_location);\n-  EL_TYPE (location) = ADDRESS_LOCATION;\n-  EL_ADDRESS (location) = addr;\n+  location->type = ADDRESS_LOCATION;\n+  location->u.address = addr;\n   if (addr_string != NULL)\n-    EL_STRING (location) = xstrndup (addr_string, addr_string_len);\n+    location->as_string = xstrndup (addr_string, addr_string_len);\n   return event_location_up (location);\n }\n \n@@ -136,17 +131,17 @@ new_address_location (CORE_ADDR addr, const char *addr_string,\n CORE_ADDR\n get_address_location (const struct event_location *location)\n {\n-  gdb_assert (EL_TYPE (location) == ADDRESS_LOCATION);\n-  return EL_ADDRESS (location);\n+  gdb_assert (location->type == ADDRESS_LOCATION);\n+  return location->u.address;\n }\n \n /* See description in location.h.  */\n \n const char *\n get_address_string_location (const struct event_location *location)\n {\n-  gdb_assert (EL_TYPE (location) == ADDRESS_LOCATION);\n-  return EL_STRING (location);\n+  gdb_assert (location->type == ADDRESS_LOCATION);\n+  return location->as_string;\n }\n \n /* See description in location.h.  */\n@@ -157,9 +152,9 @@ new_probe_location (const char *probe)\n   struct event_location *location;\n \n   location = XCNEW (struct event_location);\n-  EL_TYPE (location) = PROBE_LOCATION;\n+  location->type = PROBE_LOCATION;\n   if (probe != NULL)\n-    EL_PROBE (location) = xstrdup (probe);\n+    location->u.addr_string = xstrdup (probe);\n   return event_location_up (location);\n }\n \n@@ -168,8 +163,8 @@ new_probe_location (const char *probe)\n const char *\n get_probe_location (const struct event_location *location)\n {\n-  gdb_assert (EL_TYPE (location) == PROBE_LOCATION);\n-  return EL_PROBE (location);\n+  gdb_assert (location->type == PROBE_LOCATION);\n+  return location->u.addr_string;\n }\n \n /* See description in location.h.  */\n@@ -180,28 +175,28 @@ new_explicit_location (const struct explicit_location *explicit_loc)\n   struct event_location tmp;\n \n   memset (&tmp, 0, sizeof (struct event_location));\n-  EL_TYPE (&tmp) = EXPLICIT_LOCATION;\n-  initialize_explicit_location (EL_EXPLICIT (&tmp));\n+  tmp.type = EXPLICIT_LOCATION;\n+  initialize_explicit_location (&tmp.u.explicit_loc);\n   if (explicit_loc != NULL)\n     {\n-      EL_EXPLICIT (&tmp)->func_name_match_type\n+      tmp.u.explicit_loc.func_name_match_type\n \t= explicit_loc->func_name_match_type;\n \n       if (explicit_loc->source_filename != NULL)\n \t{\n-\t  EL_EXPLICIT (&tmp)->source_filename\n+\t  tmp.u.explicit_loc.source_filename\n \t    = explicit_loc->source_filename;\n \t}\n \n       if (explicit_loc->function_name != NULL)\n-\tEL_EXPLICIT (&tmp)->function_name\n+\ttmp.u.explicit_loc.function_name\n \t  = explicit_loc->function_name;\n \n       if (explicit_loc->label_name != NULL)\n-\tEL_EXPLICIT (&tmp)->label_name = explicit_loc->label_name;\n+\ttmp.u.explicit_loc.label_name = explicit_loc->label_name;\n \n       if (explicit_loc->line_offset.sign != LINE_OFFSET_UNKNOWN)\n-\tEL_EXPLICIT (&tmp)->line_offset = explicit_loc->line_offset;\n+\ttmp.u.explicit_loc.line_offset = explicit_loc->line_offset;\n     }\n \n   return copy_event_location (&tmp);\n@@ -212,17 +207,17 @@ new_explicit_location (const struct explicit_location *explicit_loc)\n struct explicit_location *\n get_explicit_location (struct event_location *location)\n {\n-  gdb_assert (EL_TYPE (location) == EXPLICIT_LOCATION);\n-  return EL_EXPLICIT (location);\n+  gdb_assert (location->type == EXPLICIT_LOCATION);\n+  return &location->u.explicit_loc;\n }\n \n /* See description in location.h.  */\n \n const struct explicit_location *\n get_explicit_location_const (const struct event_location *location)\n {\n-  gdb_assert (EL_TYPE (location) == EXPLICIT_LOCATION);\n-  return EL_EXPLICIT (location);\n+  gdb_assert (location->type == EXPLICIT_LOCATION);\n+  return &location->u.explicit_loc;\n }\n \n /* This convenience function returns a malloc'd string which\n@@ -309,44 +304,46 @@ copy_event_location (const struct event_location *src)\n   struct event_location *dst;\n \n   dst = XCNEW (struct event_location);\n-  EL_TYPE (dst) = EL_TYPE (src);\n-  if (EL_STRING (src) != NULL)\n-    EL_STRING (dst) = xstrdup (EL_STRING (src));\n+  dst->type = src->type;\n+  if (src->as_string != NULL)\n+    dst->as_string = xstrdup (src->as_string);\n \n-  switch (EL_TYPE (src))\n+  switch (src->type)\n     {\n     case LINESPEC_LOCATION:\n-      EL_LINESPEC (dst)->match_type = EL_LINESPEC (src)->match_type;\n-      if (EL_LINESPEC (src)->spec_string != NULL)\n-\tEL_LINESPEC (dst)->spec_string\n-\t  = xstrdup (EL_LINESPEC (src)->spec_string);\n+      dst->u.linespec_location.match_type\n+\t= src->u.linespec_location.match_type;\n+      if (src->u.linespec_location.spec_string != NULL)\n+\tdst->u.linespec_location.spec_string\n+\t  = xstrdup (src->u.linespec_location.spec_string);\n       break;\n \n     case ADDRESS_LOCATION:\n-      EL_ADDRESS (dst) = EL_ADDRESS (src);\n+      dst->u.address = src->u.address;\n       break;\n \n     case EXPLICIT_LOCATION:\n-      EL_EXPLICIT (dst)->func_name_match_type\n-\t= EL_EXPLICIT (src)->func_name_match_type;\n-      if (EL_EXPLICIT (src)->source_filename != NULL)\n-\tEL_EXPLICIT (dst)->source_filename\n-\t  = xstrdup (EL_EXPLICIT (src)->source_filename);\n+      dst->u.explicit_loc.func_name_match_type\n+\t= src->u.explicit_loc.func_name_match_type;\n+      if (src->u.explicit_loc.source_filename != NULL)\n+\tdst->u.explicit_loc.source_filename\n+\t  = xstrdup (src->u.explicit_loc.source_filename);\n \n-      if (EL_EXPLICIT (src)->function_name != NULL)\n-\tEL_EXPLICIT (dst)->function_name\n-\t  = xstrdup (EL_EXPLICIT (src)->function_name);\n+      if (src->u.explicit_loc.function_name != NULL)\n+\tdst->u.explicit_loc.function_name\n+\t  = xstrdup (src->u.explicit_loc.function_name);\n \n-      if (EL_EXPLICIT (src)->label_name != NULL)\n-\tEL_EXPLICIT (dst)->label_name = xstrdup (EL_EXPLICIT (src)->label_name);\n+      if (src->u.explicit_loc.label_name != NULL)\n+\tdst->u.explicit_loc.label_name\n+\t  = xstrdup (src->u.explicit_loc.label_name);\n \n-      EL_EXPLICIT (dst)->line_offset = EL_EXPLICIT (src)->line_offset;\n+      dst->u.explicit_loc.line_offset = src->u.explicit_loc.line_offset;\n       break;\n \n \n     case PROBE_LOCATION:\n-      if (EL_PROBE (src) != NULL)\n-\tEL_PROBE (dst) = xstrdup (EL_PROBE (src));\n+      if (src->u.addr_string != NULL)\n+\tdst->u.addr_string = xstrdup (src->u.addr_string);\n       break;\n \n     default:\n@@ -361,26 +358,26 @@ event_location_deleter::operator() (event_location *location) const\n {\n   if (location != NULL)\n     {\n-      xfree (EL_STRING (location));\n+      xfree (location->as_string);\n \n-      switch (EL_TYPE (location))\n+      switch (location->type)\n \t{\n \tcase LINESPEC_LOCATION:\n-\t  xfree (EL_LINESPEC (location)->spec_string);\n+\t  xfree (location->u.linespec_location.spec_string);\n \t  break;\n \n \tcase ADDRESS_LOCATION:\n \t  /* Nothing to do.  */\n \t  break;\n \n \tcase EXPLICIT_LOCATION:\n-\t  xfree (EL_EXPLICIT (location)->source_filename);\n-\t  xfree (EL_EXPLICIT (location)->function_name);\n-\t  xfree (EL_EXPLICIT (location)->label_name);\n+\t  xfree (location->u.explicit_loc.source_filename);\n+\t  xfree (location->u.explicit_loc.function_name);\n+\t  xfree (location->u.explicit_loc.label_name);\n \t  break;\n \n \tcase PROBE_LOCATION:\n-\t  xfree (EL_PROBE (location));\n+\t  xfree (location->u.addr_string);\n \t  break;\n \n \tdefault:\n@@ -396,48 +393,48 @@ event_location_deleter::operator() (event_location *location) const\n const char *\n event_location_to_string (struct event_location *location)\n {\n-  if (EL_STRING (location) == NULL)\n+  if (location->as_string == NULL)\n     {\n-      switch (EL_TYPE (location))\n+      switch (location->type)\n \t{\n \tcase LINESPEC_LOCATION:\n-\t  if (EL_LINESPEC (location)->spec_string != NULL)\n+\t  if (location->u.linespec_location.spec_string != NULL)\n \t    {\n-\t      linespec_location *ls = EL_LINESPEC (location);\n+\t      linespec_location *ls = &location->u.linespec_location;\n \t      if (ls->match_type == symbol_name_match_type::FULL)\n \t\t{\n-\t\t  EL_STRING (location)\n+\t\t  location->as_string\n \t\t    = concat (\"-qualified \", ls->spec_string, (char *) NULL);\n \t\t}\n \t      else\n-\t\tEL_STRING (location) = xstrdup (ls->spec_string);\n+\t\tlocation->as_string = xstrdup (ls->spec_string);\n \t    }\n \t  break;\n \n \tcase ADDRESS_LOCATION:\n \t  {\n \t    const char *addr_string\n-\t      = core_addr_to_string (EL_ADDRESS (location));\n-\t    EL_STRING (location)\n+\t      = core_addr_to_string (location->u.address);\n+\t    location->as_string\n \t      = xstrprintf (\"*%s\", addr_string).release ();\n \t  }\n \t  break;\n \n \tcase EXPLICIT_LOCATION:\n-\t  EL_STRING (location)\n-\t    = explicit_location_to_string (EL_EXPLICIT (location)).release ();\n+\t  location->as_string\n+\t    = explicit_location_to_string (&location->u.explicit_loc).release ();\n \t  break;\n \n \tcase PROBE_LOCATION:\n-\t  EL_STRING (location) = xstrdup (EL_PROBE (location));\n+\t  location->as_string = xstrdup (location->u.addr_string);\n \t  break;\n \n \tdefault:\n \t  gdb_assert_not_reached (\"unknown event location type\");\n \t}\n     }\n \n-  return EL_STRING (location);\n+  return location->as_string;\n }\n \n /* Find an instance of the quote character C in the string S that is\n@@ -804,17 +801,17 @@ string_to_explicit_location (const char **argp,\n \t{\n \t  set_oarg (explicit_location_lex_one (argp, language,\n \t\t\t\t\t       completion_info));\n-\t  EL_EXPLICIT (location)->source_filename = oarg.release ();\n+\t  location->u.explicit_loc.source_filename = oarg.release ();\n \t}\n       else if (strncmp (opt.get (), \"-function\", len) == 0)\n \t{\n \t  set_oarg (explicit_location_lex_one_function (argp, language,\n \t\t\t\t\t\t\tcompletion_info));\n-\t  EL_EXPLICIT (location)->function_name = oarg.release ();\n+\t  location->u.explicit_loc.function_name = oarg.release ();\n \t}\n       else if (strncmp (opt.get (), \"-qualified\", len) == 0)\n \t{\n-\t  EL_EXPLICIT (location)->func_name_match_type\n+\t  location->u.explicit_loc.func_name_match_type\n \t    = symbol_name_match_type::FULL;\n \t}\n       else if (strncmp (opt.get (), \"-line\", len) == 0)\n@@ -823,15 +820,15 @@ string_to_explicit_location (const char **argp,\n \t  *argp = skip_spaces (*argp);\n \t  if (have_oarg)\n \t    {\n-\t      EL_EXPLICIT (location)->line_offset\n+\t      location->u.explicit_loc.line_offset\n \t\t= linespec_parse_line_offset (oarg.get ());\n \t      continue;\n \t    }\n \t}\n       else if (strncmp (opt.get (), \"-label\", len) == 0)\n \t{\n \t  set_oarg (explicit_location_lex_one (argp, language, completion_info));\n-\t  EL_EXPLICIT (location)->label_name = oarg.release ();\n+\t  location->u.explicit_loc.label_name = oarg.release ();\n \t}\n       /* Only emit an \"invalid argument\" error for options\n \t that look like option strings.  */\n@@ -861,10 +858,10 @@ string_to_explicit_location (const char **argp,\n \n   /* One special error check:  If a source filename was given\n      without offset, function, or label, issue an error.  */\n-  if (EL_EXPLICIT (location)->source_filename != NULL\n-      && EL_EXPLICIT (location)->function_name == NULL\n-      && EL_EXPLICIT (location)->label_name == NULL\n-      && (EL_EXPLICIT (location)->line_offset.sign == LINE_OFFSET_UNKNOWN)\n+  if (location->u.explicit_loc.source_filename != NULL\n+      && location->u.explicit_loc.function_name == NULL\n+      && location->u.explicit_loc.label_name == NULL\n+      && (location->u.explicit_loc.line_offset.sign == LINE_OFFSET_UNKNOWN)\n       && completion_info == NULL)\n     {\n       error (_(\"Source filename requires function, label, or \"\n@@ -940,7 +937,7 @@ string_to_event_location (const char **stringp,\n \t \"-qualified\", otherwise string_to_explicit_location would\n \t have thrown an error.  Save the flags for \"basic\" linespec\n \t parsing below and discard the explicit location.  */\n-      match_type = EL_EXPLICIT (location)->func_name_match_type;\n+      match_type = location->u.explicit_loc.func_name_match_type;\n     }\n \n   /* Everything else is a \"basic\" linespec, address, or probe\n@@ -953,7 +950,7 @@ string_to_event_location (const char **stringp,\n int\n event_location_empty_p (const struct event_location *location)\n {\n-  switch (EL_TYPE (location))\n+  switch (location->type)\n     {\n     case LINESPEC_LOCATION:\n       /* Linespecs are never \"empty.\"  (NULL is a valid linespec)  */\n@@ -963,14 +960,14 @@ event_location_empty_p (const struct event_location *location)\n       return 0;\n \n     case EXPLICIT_LOCATION:\n-      return (EL_EXPLICIT (location)->source_filename == NULL\n-\t      && EL_EXPLICIT (location)->function_name == NULL\n-\t      && EL_EXPLICIT (location)->label_name == NULL\n-\t      && (EL_EXPLICIT (location)->line_offset.sign\n+      return (location->u.explicit_loc.source_filename == NULL\n+\t      && location->u.explicit_loc.function_name == NULL\n+\t      && location->u.explicit_loc.label_name == NULL\n+\t      && (location->u.explicit_loc.line_offset.sign\n \t\t  == LINE_OFFSET_UNKNOWN));\n \n     case PROBE_LOCATION:\n-      return EL_PROBE (location) == NULL;\n+      return location->u.addr_string == NULL;\n \n     default:\n       gdb_assert_not_reached (\"unknown event location type\");\n@@ -983,6 +980,6 @@ void\n set_event_location_string (struct event_location *location,\n \t\t\t   gdb::unique_xmalloc_ptr<char> string)\n {\n-  xfree (EL_STRING (location));\n-  EL_STRING (location) = string.release ();\n+  xfree (location->as_string);\n+  location->as_string = string.release ();\n }"
    }
  ]
}