{
  "sha": "5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWI2ZDFlNGZhNGZjNjgyN2M3YjNmMGU5OWZmMTIwZGZhMTRkNjVkMg==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-01-10T20:06:08Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-01-10T20:06:08Z"
    },
    "message": "Multi-target support\n\nThis commit adds multi-target support to GDB.  What this means is that\nwith this commit, GDB can now be connected to different targets at the\nsame time.  E.g., you can debug a live native process and a core dump\nat the same time, connect to multiple gdbservers, etc.\n\nActually, the word \"target\" is overloaded in gdb.  We already have a\ntarget stack, with pushes several target_ops instances on top of one\nanother.  We also have \"info target\" already, which means something\ncompletely different to what this patch does.\n\nSo from here on, I'll be using the \"target connections\" term, to mean\nan open process_stratum target, pushed on a target stack.  This patch\nmakes gdb have multiple target stacks, and multiple process_stratum\ntargets open simultaneously.  The user-visible changes / commands will\nalso use this terminology, but of course it's all open to debate.\n\nUser-interface-wise, not that much changes.  The main difference is\nthat each inferior may have its own target connection.\n\nA target connection (e.g., a target extended-remote connection) may\nsupport debugging multiple processes, just as before.\n\nSay you're debugging against gdbserver in extended-remote mode, and\nyou do \"add-inferior\" to prepare to spawn a new process, like:\n\n (gdb) target extended-remote :9999\n ...\n (gdb) start\n ...\n (gdb) add-inferior\n Added inferior 2\n (gdb) inferior 2\n [Switching to inferior 2 [<null>] (<noexec>)]\n (gdb) file a.out\n ...\n (gdb) start\n ...\n\nAt this point, you have two inferiors connected to the same gdbserver.\n\nWith this commit, GDB will maintain a target stack per inferior,\ninstead of a global target stack.\n\nTo preserve the behavior above, by default, \"add-inferior\" makes the\nnew inferior inherit a copy of the target stack of the current\ninferior.  Same across a fork - the child inherits a copy of the\ntarget stack of the parent.  While the target stacks are copied, the\ntargets themselves are not.  Instead, target_ops is made a\nrefcounted_object, which means that target_ops instances are\nrefcounted, which each inferior counting for a reference.\n\nWhat if you want to create an inferior and connect it to some _other_\ntarget?  For that, this commit introduces a new \"add-inferior\n-no-connection\" option that makes the new inferior not share the\ncurrent inferior's target.  So you could do:\n\n (gdb) target extended-remote :9999\n Remote debugging using :9999\n ...\n (gdb) add-inferior -no-connection\n [New inferior 2]\n Added inferior 2\n (gdb) inferior 2\n [Switching to inferior 2 [<null>] (<noexec>)]\n (gdb) info inferiors\n   Num  Description       Executable\n   1    process 18401     target:/home/pedro/tmp/main\n * 2    <null>\n (gdb) tar extended-remote :10000\n Remote debugging using :10000\n ...\n (gdb) info inferiors\n   Num  Description       Executable\n   1    process 18401     target:/home/pedro/tmp/main\n * 2    process 18450     target:/home/pedro/tmp/main\n (gdb)\n\nA following patch will extended \"info inferiors\" to include a column\nindicating which connection an inferior is bound to, along with a\ncouple other UI tweaks.\n\nOther than that, debugging is the same as before.  Users interact with\ninferiors and threads as before.  The only difference is that\ninferiors may be bound to processes running in different machines.\n\nThat's pretty much all there is to it in terms of noticeable UI\nchanges.\n\nOn to implementation.\n\nSince we can be connected to different systems at the same time, a\nptid_t is no longer a unique identifier.  Instead a thread can be\nidentified by a pair of ptid_t and 'process_stratum_target *', the\nlater being the instance of the process_stratum target that owns the\nprocess/thread.  Note that process_stratum_target inherits from\ntarget_ops, and all process_stratum targets inherit from\nprocess_stratum_target.  In earlier patches, many places in gdb were\nconverted to refer to threads by thread_info pointer instead of\nptid_t, but there are still places in gdb where we start with a\npid/tid and need to find the corresponding inferior or thread_info\nobjects.  So you'll see in the patch many places adding a\nprocess_stratum_target parameter to functions that used to take only a\nptid_t.\n\nSince each inferior has its own target stack now, we can always find\nthe process_stratum target for an inferior.  That is done via a\ninf->process_target() convenience method.\n\nSince each inferior has its own target stack, we need to handle the\n\"beneath\" calls when servicing target calls.  The solution I settled\nwith is just to make sure to switch the current inferior to the\ninferior you want before making a target call.  Not relying on global\ncontext is just not feasible in current GDB.  Fortunately, there\naren't that many places that need to do that, because generally most\ncode that calls target methods already has the current context\npointing to the right inferior/thread.  Note, to emphasize -- there's\nno method to \"switch to this target stack\".  Instead, you switch the\ncurrent inferior, and that implicitly switches the target stack.\n\nIn some spots, we need to iterate over all inferiors so that we reach\nall target stacks.\n\nNative targets are still singletons.  There's always only a single\ninstance of such targets.\n\nRemote targets however, we'll have one instance per remote connection.\n\nThe exec target is still a singleton.  There's only one instance.  I\ndid not see the point of instanciating more than one exec_target\nobject.\n\nAfter vfork, we need to make sure to push the exec target on the new\ninferior.  See exec_on_vfork.\n\nFor type safety, functions that need a {target, ptid} pair to identify\na thread, take a process_stratum_target pointer for target parameter\ninstead of target_ops *.  Some shared code in gdb/nat/ also need to\ngain a target pointer parameter.  This poses an issue, since gdbserver\ndoesn't have process_stratum_target, only target_ops.  To fix this,\nthis commit renames gdbserver's target_ops to process_stratum_target.\nI think this makes sense.  There's no concept of target stack in\ngdbserver, and gdbserver's target_ops really implements a\nprocess_stratum-like target.\n\nThe thread and inferior iterator functions also gain\nprocess_stratum_target parameters.  These are used to be able to\niterate over threads and inferiors of a given target.  Following usual\nconventions, if the target pointer is null, then we iterate over\nthreads and inferiors of all targets.\n\nI tried converting \"add-inferior\" to the gdb::option framework, as a\npreparatory patch, but that stumbled on the fact that gdb::option does\nnot support file options yet, for \"add-inferior -exec\".  I have a WIP\npatchset that adds that, but it's not a trivial patch, mainly due to\nneed to integrate readline's filename completion, so I deferred that\nto some other time.\n\nIn infrun.c/infcmd.c, the main change is that we need to poll events\nout of all targets.  See do_target_wait.  Right after collecting an\nevent, we switch the current inferior to an inferior bound to the\ntarget that reported the event, so that target methods can be used\nwhile handling the event.  This makes most of the code transparent to\nmulti-targets.  See fetch_inferior_event.\n\ninfrun.c:stop_all_threads is interesting -- in this function we need\nto stop all threads of all targets.  What the function does is send an\nasynchronous stop request to all threads, and then synchronously waits\nfor events, with target_wait, rinse repeat, until all it finds are\nstopped threads.  Now that we have multiple targets, it's not\nefficient to synchronously block in target_wait waiting for events out\nof one target.  Instead, we implement a mini event loop, with\ninterruptible_select, select'ing on one file descriptor per target.\nFor this to work, we need to be able to ask the target for a waitable\nfile descriptor.  Such file descriptors already exist, they are the\ndescriptors registered in the main event loop with add_file_handler,\ninside the target_async implementations.  This commit adds a new\ntarget_async_wait_fd target method that just returns the file\ndescriptor in question.  See wait_one / stop_all_threads in infrun.c.\n\nThe 'threads_executing' global is made a per-target variable.  Since\nit is only relevant to process_stratum_target targets, this is where\nit is put, instead of in target_ops.\n\nYou'll notice that remote.c includes some FIXME notes.  These refer to\nthe fact that the global arrays that hold data for the remote packets\nsupported are still globals.  For example, if we connect to two\ndifferent servers/stubs, then each might support different remote\nprotocol features.  They might even be different architectures, like\ne.g., one ARM baremetal stub, and a x86 gdbserver, to debug a\nhost/controller scenario as a single program.  That isn't going to\nwork correctly today, because of said globals.  I'm leaving fixing\nthat for another pass, since it does not appear to be trivial, and I'd\nrather land the base work first.  It's already useful to be able to\ndebug multiple instances of the same server (e.g., a distributed\ncluster, where you have full control over the servers installed), so I\nthink as is it's already reasonable incremental progress.\n\nCurrent limitations:\n\n - You can only resume more that one target at the same time if all\n   targets support asynchronous debugging, and support non-stop mode.\n   It should be possible to support mixed all-stop + non-stop\n   backends, but that is left for another time.  This means that\n   currently in order to do multi-target with gdbserver you need to\n   issue \"maint set target-non-stop on\".  I would like to make that\n   mode be the default, but we're not there yet.  Note that I'm\n   talking about how the target backend works, only.  User-visible\n   all-stop mode works just fine.\n\n - As explained above, connecting to different remote servers at the\n   same time is likely to produce bad results if they don't support the\n   exact set of RSP features.\n\nFreeBSD updates courtesy of John Baldwin.\n\ngdb/ChangeLog:\n2020-01-10  Pedro Alves  <palves@redhat.com>\n\t    John Baldwin  <jhb@FreeBSD.org>\n\n\t* aarch64-linux-nat.c\n\t(aarch64_linux_nat_target::thread_architecture): Adjust.\n\t* ada-tasks.c (print_ada_task_info): Adjust find_thread_ptid call.\n\t(task_command_1): Likewise.\n\t* aix-thread.c (sync_threadlists, aix_thread_target::resume)\n\t(aix_thread_target::wait, aix_thread_target::fetch_registers)\n\t(aix_thread_target::store_registers)\n\t(aix_thread_target::thread_alive): Adjust.\n\t* amd64-fbsd-tdep.c: Include \"inferior.h\".\n\t(amd64fbsd_get_thread_local_address): Pass down target.\n\t* amd64-linux-nat.c (ps_get_thread_area): Use ps_prochandle\n\tthread's gdbarch instead of target_gdbarch.\n\t* break-catch-sig.c (signal_catchpoint_print_it): Adjust call to\n\tget_last_target_status.\n\t* break-catch-syscall.c (print_it_catch_syscall): Likewise.\n\t* breakpoint.c (breakpoints_should_be_inserted_now): Consider all\n\tinferiors.\n\t(update_inserted_breakpoint_locations): Skip if inferiors with no\n\texecution.\n\t(update_global_location_list): When handling moribund locations,\n\tfind representative inferior for location's pspace, and use thread\n\tcount of its process_stratum target.\n\t* bsd-kvm.c (bsd_kvm_target_open): Pass target down.\n\t* bsd-uthread.c (bsd_uthread_target::wait): Use\n\tas_process_stratum_target and adjust thread_change_ptid and\n\tadd_thread calls.\n\t(bsd_uthread_target::update_thread_list): Use\n\tas_process_stratum_target and adjust find_thread_ptid,\n\tthread_change_ptid and add_thread calls.\n\t* btrace.c (maint_btrace_packet_history_cmd): Adjust\n\tfind_thread_ptid call.\n\t* corelow.c (add_to_thread_list): Adjust add_thread call.\n\t(core_target_open): Adjust add_thread_silent and thread_count\n\tcalls.\n\t(core_target::pid_to_str): Adjust find_inferior_ptid call.\n\t* ctf.c (ctf_target_open): Adjust add_thread_silent call.\n\t* event-top.c (async_disconnect): Pop targets from all inferiors.\n\t* exec.c (add_target_sections): Push exec target on all inferiors\n\tsharing the program space.\n\t(remove_target_sections): Remove the exec target from all\n\tinferiors sharing the program space.\n\t(exec_on_vfork): New.\n\t* exec.h (exec_on_vfork): Declare.\n\t* fbsd-nat.c (fbsd_add_threads): Add fbsd_nat_target parameter.\n\tPass it down.\n\t(fbsd_nat_target::update_thread_list): Adjust.\n\t(fbsd_nat_target::resume): Adjust.\n\t(fbsd_handle_debug_trap): Add fbsd_nat_target parameter.  Pass it\n\tdown.\n\t(fbsd_nat_target::wait, fbsd_nat_target::post_attach): Adjust.\n\t* fbsd-tdep.c (fbsd_corefile_thread): Adjust\n\tget_thread_arch_regcache call.\n\t* fork-child.c (gdb_startup_inferior): Pass target down to\n\tstartup_inferior and set_executing.\n\t* gdbthread.h (struct process_stratum_target): Forward declare.\n\t(add_thread, add_thread_silent, add_thread_with_info)\n\t(in_thread_list): Add process_stratum_target parameter.\n\t(find_thread_ptid(inferior*, ptid_t)): New overload.\n\t(find_thread_ptid, thread_change_ptid): Add process_stratum_target\n\tparameter.\n\t(all_threads()): Delete overload.\n\t(all_threads, all_non_exited_threads): Add process_stratum_target\n\tparameter.\n\t(all_threads_safe): Use brace initialization.\n\t(thread_count): Add process_stratum_target parameter.\n\t(set_resumed, set_running, set_stop_requested, set_executing)\n\t(threads_are_executing, finish_thread_state): Add\n\tprocess_stratum_target parameter.\n\t(switch_to_thread): Use is_current_thread.\n\t* i386-fbsd-tdep.c: Include \"inferior.h\".\n\t(i386fbsd_get_thread_local_address): Pass down target.\n\t* i386-linux-nat.c (i386_linux_nat_target::low_resume): Adjust.\n\t* inf-child.c (inf_child_target::maybe_unpush_target): Remove\n\thave_inferiors check.\n\t* inf-ptrace.c (inf_ptrace_target::create_inferior)\n\t(inf_ptrace_target::attach): Adjust.\n\t* infcall.c (run_inferior_call): Adjust.\n\t* infcmd.c (run_command_1): Pass target to\n\tscoped_finish_thread_state.\n\t(proceed_thread_callback): Skip inferiors with no execution.\n\t(continue_command): Rename 'all_threads' local to avoid hiding\n\t'all_threads' function.  Adjust get_last_target_status call.\n\t(prepare_one_step): Adjust set_running call.\n\t(signal_command): Use user_visible_resume_target.  Compare thread\n\tpointers instead of inferior_ptid.\n\t(info_program_command): Adjust to pass down target.\n\t(attach_command): Mark target's 'thread_executing' flag.\n\t(stop_current_target_threads_ns): New, factored out from ...\n\t(interrupt_target_1): ... this.  Switch inferior before making\n\ttarget calls.\n\t* inferior-iter.h\n\t(struct all_inferiors_iterator, struct all_inferiors_range)\n\t(struct all_inferiors_safe_range)\n\t(struct all_non_exited_inferiors_range): Filter on\n\tprocess_stratum_target too.  Remove explicit.\n\t* inferior.c (inferior::inferior): Push dummy target on target\n\tstack.\n\t(find_inferior_pid, find_inferior_ptid, number_of_live_inferiors):\n\tAdd process_stratum_target parameter, and pass it down.\n\t(have_live_inferiors): Adjust.\n\t(switch_to_inferior_and_push_target): New.\n\t(add_inferior_command, clone_inferior_command): Handle\n\t\"-no-connection\" parameter.  Use\n\tswitch_to_inferior_and_push_target.\n\t(_initialize_inferior): Mention \"-no-connection\" option in\n\tthe help of \"add-inferior\" and \"clone-inferior\" commands.\n\t* inferior.h: Include \"process-stratum-target.h\".\n\t(interrupt_target_1): Use bool.\n\t(struct inferior) <push_target, unpush_target, target_is_pushed,\n\tfind_target_beneath, top_target, process_target, target_at,\n\tm_stack>: New.\n\t(discard_all_inferiors): Delete.\n\t(find_inferior_pid, find_inferior_ptid, number_of_live_inferiors)\n\t(all_inferiors, all_non_exited_inferiors): Add\n\tprocess_stratum_target parameter.\n\t* infrun.c: Include \"gdb_select.h\" and <unordered_map>.\n\t(target_last_proc_target): New global.\n\t(follow_fork_inferior): Push target on new inferior.  Pass target\n\tto add_thread_silent.  Call exec_on_vfork.  Handle target's\n\treference count.\n\t(follow_fork): Adjust get_last_target_status call.  Also consider\n\ttarget.\n\t(follow_exec): Push target on new inferior.\n\t(struct execution_control_state) <target>: New field.\n\t(user_visible_resume_target): New.\n\t(do_target_resume): Call target_async.\n\t(resume_1): Set target's threads_executing flag.  Consider resume\n\ttarget.\n\t(commit_resume_all_targets): New.\n\t(proceed): Also consider resume target.  Skip threads of inferiors\n\twith no execution.  Commit resumtion in all targets.\n\t(start_remote): Pass current inferior to wait_for_inferior.\n\t(infrun_thread_stop_requested): Consider target as well.  Pass\n\tthread_info pointer to clear_inline_frame_state instead of ptid.\n\t(infrun_thread_thread_exit): Consider target as well.\n\t(random_pending_event_thread): New inferior parameter.  Use it.\n\t(do_target_wait): Rename to ...\n\t(do_target_wait_1): ... this.  Add inferior parameter, and pass it\n\tdown.\n\t(threads_are_resumed_pending_p, do_target_wait): New.\n\t(prepare_for_detach): Adjust calls.\n\t(wait_for_inferior): New inferior parameter.  Handle it.  Use\n\tdo_target_wait_1 instead of do_target_wait.\n\t(fetch_inferior_event): Adjust.  Switch to representative\n\tinferior.  Pass target down.\n\t(set_last_target_status): Add process_stratum_target parameter.\n\tSave target in global.\n\t(get_last_target_status): Add process_stratum_target parameter and\n\thandle it.\n\t(nullify_last_target_wait_ptid): Clear 'target_last_proc_target'.\n\t(context_switch): Check inferior_ptid == null_ptid before calling\n\tinferior_thread().\n\t(get_inferior_stop_soon): Pass down target.\n\t(wait_one): Rename to ...\n\t(poll_one_curr_target): ... this.\n\t(struct wait_one_event): New.\n\t(wait_one): New.\n\t(stop_all_threads): Adjust.\n\t(handle_no_resumed, handle_inferior_event): Adjust to consider the\n\tevent's target.\n\t(switch_back_to_stepped_thread): Also consider target.\n\t(print_stop_event): Update.\n\t(normal_stop): Update.  Also consider the resume target.\n\t* infrun.h (wait_for_inferior): Remove declaration.\n\t(user_visible_resume_target): New declaration.\n\t(get_last_target_status, set_last_target_status): New\n\tprocess_stratum_target parameter.\n\t* inline-frame.c (clear_inline_frame_state(ptid_t)): Add\n\tprocess_stratum_target parameter, and use it.\n\t(clear_inline_frame_state (thread_info*)): New.\n\t* inline-frame.c (clear_inline_frame_state(ptid_t)): Add\n\tprocess_stratum_target parameter.\n\t(clear_inline_frame_state (thread_info*)): Declare.\n\t* linux-fork.c (delete_checkpoint_command): Pass target down to\n\tfind_thread_ptid.\n\t(checkpoint_command): Adjust.\n\t* linux-nat.c (linux_nat_target::follow_fork): Switch to thread\n\tinstead of just tweaking inferior_ptid.\n\t(linux_nat_switch_fork): Pass target down to thread_change_ptid.\n\t(exit_lwp): Pass target down to find_thread_ptid.\n\t(attach_proc_task_lwp_callback): Pass target down to\n\tadd_thread/set_running/set_executing.\n\t(linux_nat_target::attach): Pass target down to\n\tthread_change_ptid.\n\t(get_detach_signal): Pass target down to find_thread_ptid.\n\tConsider last target status's target.\n\t(linux_resume_one_lwp_throw, resume_lwp)\n\t(linux_handle_syscall_trap, linux_handle_extended_wait, wait_lwp)\n\t(stop_wait_callback, save_stop_reason, linux_nat_filter_event)\n\t(linux_nat_wait_1, resume_stopped_resumed_lwps): Pass target down.\n\t(linux_nat_target::async_wait_fd): New.\n\t(linux_nat_stop_lwp, linux_nat_target::thread_address_space): Pass\n\ttarget down.\n\t* linux-nat.h (linux_nat_target::async_wait_fd): Declare.\n\t* linux-tdep.c (get_thread_arch_regcache): Pass target down.\n\t* linux-thread-db.c (struct thread_db_info::process_target): New\n\tfield.\n\t(add_thread_db_info): Save target.\n\t(get_thread_db_info): New process_stratum_target parameter.  Also\n\tmatch target.\n\t(delete_thread_db_info): New process_stratum_target parameter.\n\tAlso match target.\n\t(thread_from_lwp): Adjust to pass down target.\n\t(thread_db_notice_clone): Pass down target.\n\t(check_thread_db_callback): Pass down target.\n\t(try_thread_db_load_1): Always push the thread_db target.\n\t(try_thread_db_load, record_thread): Pass target down.\n\t(thread_db_target::detach): Pass target down.  Always unpush the\n\tthread_db target.\n\t(thread_db_target::wait, thread_db_target::mourn_inferior): Pass\n\ttarget down.  Always unpush the thread_db target.\n\t(find_new_threads_callback, thread_db_find_new_threads_2)\n\t(thread_db_target::update_thread_list): Pass target down.\n\t(thread_db_target::pid_to_str): Pass current inferior down.\n\t(thread_db_target::get_thread_local_address): Pass target down.\n\t(thread_db_target::resume, maintenance_check_libthread_db): Pass\n\ttarget down.\n\t* nto-procfs.c (nto_procfs_target::update_thread_list): Adjust.\n\t* procfs.c (procfs_target::procfs_init_inferior): Declare.\n\t(proc_set_current_signal, do_attach, procfs_target::wait): Adjust.\n\t(procfs_init_inferior): Rename to ...\n\t(procfs_target::procfs_init_inferior): ... this and adjust.\n\t(procfs_target::create_inferior, procfs_notice_thread)\n\t(procfs_do_thread_registers): Adjust.\n\t* ppc-fbsd-tdep.c: Include \"inferior.h\".\n\t(ppcfbsd_get_thread_local_address): Pass down target.\n\t* proc-service.c (ps_xfer_memory): Switch current inferior and\n\tprogram space as well.\n\t(get_ps_regcache): Pass target down.\n\t* process-stratum-target.c\n\t(process_stratum_target::thread_address_space)\n\t(process_stratum_target::thread_architecture): Pass target down.\n\t* process-stratum-target.h\n\t(process_stratum_target::threads_executing): New field.\n\t(as_process_stratum_target): New.\n\t* ravenscar-thread.c\n\t(ravenscar_thread_target::update_inferior_ptid): Pass target down.\n\t(ravenscar_thread_target::wait, ravenscar_add_thread): Pass target\n\tdown.\n\t* record-btrace.c (record_btrace_target::info_record): Adjust.\n\t(record_btrace_target::record_method)\n\t(record_btrace_target::record_is_replaying)\n\t(record_btrace_target::fetch_registers)\n\t(get_thread_current_frame_id, record_btrace_target::resume)\n\t(record_btrace_target::wait, record_btrace_target::stop): Pass\n\ttarget down.\n\t* record-full.c (record_full_wait_1): Switch to event thread.\n\tPass target down.\n\t* regcache.c (regcache::regcache)\n\t(get_thread_arch_aspace_regcache, get_thread_arch_regcache): Add\n\tprocess_stratum_target parameter and handle it.\n\t(current_thread_target): New global.\n\t(get_thread_regcache): Add process_stratum_target parameter and\n\thandle it.  Switch inferior before calling target method.\n\t(get_thread_regcache): Pass target down.\n\t(get_thread_regcache_for_ptid): Pass target down.\n\t(registers_changed_ptid): Add process_stratum_target parameter and\n\thandle it.\n\t(registers_changed_thread, registers_changed): Pass target down.\n\t(test_get_thread_arch_aspace_regcache): New.\n\t(current_regcache_test): Define a couple local test_target_ops\n\tinstances and use them for testing.\n\t(readwrite_regcache): Pass process_stratum_target parameter.\n\t(cooked_read_test, cooked_write_test): Pass mock_target down.\n\t* regcache.h (get_thread_regcache, get_thread_arch_regcache)\n\t(get_thread_arch_aspace_regcache): Add process_stratum_target\n\tparameter.\n\t(regcache::target): New method.\n\t(regcache::regcache, regcache::get_thread_arch_aspace_regcache)\n\t(regcache::registers_changed_ptid): Add process_stratum_target\n\tparameter.\n\t(regcache::m_target): New field.\n\t(registers_changed_ptid): Add process_stratum_target parameter.\n\t* remote.c (remote_state::supports_vCont_probed): New field.\n\t(remote_target::async_wait_fd): New method.\n\t(remote_unpush_and_throw): Add remote_target parameter.\n\t(get_current_remote_target): Adjust.\n\t(remote_target::remote_add_inferior): Push target.\n\t(remote_target::remote_add_thread)\n\t(remote_target::remote_notice_new_inferior)\n\t(get_remote_thread_info): Pass target down.\n\t(remote_target::update_thread_list): Skip threads of inferiors\n\tbound to other targets.  (remote_target::close): Don't discard\n\tinferiors.  (remote_target::add_current_inferior_and_thread)\n\t(remote_target::process_initial_stop_replies)\n\t(remote_target::start_remote)\n\t(remote_target::remote_serial_quit_handler): Pass down target.\n\t(remote_target::remote_unpush_target): New remote_target\n\tparameter.  Unpush the target from all inferiors.\n\t(remote_target::remote_unpush_and_throw): New remote_target\n\tparameter.  Pass it down.\n\t(remote_target::open_1): Check whether the current inferior has\n\texecution instead of checking whether any inferior is live.  Pass\n\ttarget down.\n\t(remote_target::remote_detach_1): Pass down target.  Use\n\tremote_unpush_target.\n\t(extended_remote_target::attach): Pass down target.\n\t(remote_target::remote_vcont_probe): Set supports_vCont_probed.\n\t(remote_target::append_resumption): Pass down target.\n\t(remote_target::append_pending_thread_resumptions)\n\t(remote_target::remote_resume_with_hc, remote_target::resume)\n\t(remote_target::commit_resume): Pass down target.\n\t(remote_target::remote_stop_ns): Check supports_vCont_probed.\n\t(remote_target::interrupt_query)\n\t(remote_target::remove_new_fork_children)\n\t(remote_target::check_pending_events_prevent_wildcard_vcont)\n\t(remote_target::remote_parse_stop_reply)\n\t(remote_target::process_stop_reply): Pass down target.\n\t(first_remote_resumed_thread): New remote_target parameter.  Pass\n\tit down.\n\t(remote_target::wait_as): Pass down target.\n\t(unpush_and_perror): New remote_target parameter.  Pass it down.\n\t(remote_target::readchar, remote_target::remote_serial_write)\n\t(remote_target::getpkt_or_notif_sane_1)\n\t(remote_target::kill_new_fork_children, remote_target::kill): Pass\n\tdown target.\n\t(remote_target::mourn_inferior): Pass down target.  Use\n\tremote_unpush_target.\n\t(remote_target::core_of_thread)\n\t(remote_target::remote_btrace_maybe_reopen): Pass down target.\n\t(remote_target::pid_to_exec_file)\n\t(remote_target::thread_handle_to_thread_info): Pass down target.\n\t(remote_target::async_wait_fd): New.\n\t* riscv-fbsd-tdep.c: Include \"inferior.h\".\n\t(riscv_fbsd_get_thread_local_address): Pass down target.\n\t* sol2-tdep.c (sol2_core_pid_to_str): Pass down target.\n\t* sol-thread.c (sol_thread_target::wait, ps_lgetregs, ps_lsetregs)\n\t(ps_lgetfpregs, ps_lsetfpregs, sol_update_thread_list_callback):\n\tAdjust.\n\t* solib-spu.c (spu_skip_standalone_loader): Pass down target.\n\t* solib-svr4.c (enable_break): Pass down target.\n\t* spu-multiarch.c (parse_spufs_run): Pass down target.\n\t* spu-tdep.c (spu2ppu_sniffer): Pass down target.\n\t* target-delegates.c: Regenerate.\n\t* target.c (g_target_stack): Delete.\n\t(current_top_target): Return the current inferior's top target.\n\t(target_has_execution_1): Refer to the passed-in inferior's top\n\ttarget.\n\t(target_supports_terminal_ours): Check whether the initial\n\tinferior was already created.\n\t(decref_target): New.\n\t(target_stack::push): Incref/decref the target.\n\t(push_target, push_target, unpush_target): Adjust.\n\t(target_stack::unpush): Defref target.\n\t(target_is_pushed): Return bool.  Adjust to refer to the current\n\tinferior's target stack.\n\t(dispose_inferior): Delete, and inline parts ...\n\t(target_preopen): ... here.  Only dispose of the current inferior.\n\t(target_detach): Hold strong target reference while detaching.\n\tPass target down.\n\t(target_thread_name): Add assertion.\n\t(target_resume): Pass down target.\n\t(target_ops::beneath, find_target_at): Adjust to refer to the\n\tcurrent inferior's target stack.\n\t(get_dummy_target): New.\n\t(target_pass_ctrlc): Pass the Ctrl-C to the first inferior that\n\thas a thread running.\n\t(initialize_targets): Rename to ...\n\t(_initialize_target): ... this.\n\t* target.h: Include \"gdbsupport/refcounted-object.h\".\n\t(struct target_ops): Inherit refcounted_object.\n\t(target_ops::shortname, target_ops::longname): Make const.\n\t(target_ops::async_wait_fd): New method.\n\t(decref_target): Declare.\n\t(struct target_ops_ref_policy): New.\n\t(target_ops_ref): New typedef.\n\t(get_dummy_target): Declare function.\n\t(target_is_pushed): Return bool.\n\t* thread-iter.c (all_matching_threads_iterator::m_inf_matches)\n\t(all_matching_threads_iterator::all_matching_threads_iterator):\n\tHandle filter target.\n\t* thread-iter.h (struct all_matching_threads_iterator, struct\n\tall_matching_threads_range, class all_non_exited_threads_range):\n\tFilter by target too.  Remove explicit.\n\t* thread.c (threads_executing): Delete.\n\t(inferior_thread): Pass down current inferior.\n\t(clear_thread_inferior_resources): Pass down thread pointer\n\tinstead of ptid_t.\n\t(add_thread_silent, add_thread_with_info, add_thread): Add\n\tprocess_stratum_target parameter.  Use it for thread and inferior\n\tsearches.\n\t(is_current_thread): New.\n\t(thread_info::deletable): Use it.\n\t(find_thread_ptid, thread_count, in_thread_list)\n\t(thread_change_ptid, set_resumed, set_running): New\n\tprocess_stratum_target parameter.  Pass it down.\n\t(set_executing): New process_stratum_target parameter.  Pass it\n\tdown.  Adjust reference to 'threads_executing'.\n\t(threads_are_executing): New process_stratum_target parameter.\n\tAdjust reference to 'threads_executing'.\n\t(set_stop_requested, finish_thread_state): New\n\tprocess_stratum_target parameter.  Pass it down.\n\t(switch_to_thread): Also match inferior.\n\t(switch_to_thread): New process_stratum_target parameter.  Pass it\n\tdown.\n\t(update_threads_executing): Reimplement.\n\t* top.c (quit_force): Pop targets from all inferior.\n\t(gdb_init): Don't call initialize_targets.\n\t* windows-nat.c (windows_nat_target) <get_windows_debug_event>:\n\tDeclare.\n\t(windows_add_thread, windows_delete_thread): Adjust.\n\t(get_windows_debug_event): Rename to ...\n\t(windows_nat_target::get_windows_debug_event): ... this.  Adjust.\n\t* tracefile-tfile.c (tfile_target_open): Pass down target.\n\t* gdbsupport/common-gdbthread.h (struct process_stratum_target):\n\tForward declare.\n\t(switch_to_thread): Add process_stratum_target parameter.\n\t* mi/mi-interp.c (mi_on_resume_1): Add process_stratum_target\n\tparameter.  Use it.\n\t(mi_on_resume): Pass target down.\n\t* nat/fork-inferior.c (startup_inferior): Add\n\tprocess_stratum_target parameter.  Pass it down.\n\t* nat/fork-inferior.h (startup_inferior): Add\n\tprocess_stratum_target parameter.\n\t* python/py-threadevent.c (py_get_event_thread): Pass target down.\n\ngdb/gdbserver/ChangeLog:\n2020-01-10  Pedro Alves  <palves@redhat.com>\n\n\t* fork-child.c (post_fork_inferior): Pass target down to\n\tstartup_inferior.\n\t* inferiors.c (switch_to_thread): Add process_stratum_target\n\tparameter.\n\t* lynx-low.c (lynx_target_ops): Now a process_stratum_target.\n\t* nto-low.c (nto_target_ops): Now a process_stratum_target.\n\t* linux-low.c (linux_target_ops): Now a process_stratum_target.\n\t* remote-utils.c (prepare_resume_reply): Pass the target to\n\tswitch_to_thread.\n\t* target.c (the_target): Now a process_stratum_target.\n\t(done_accessing_memory): Pass the target to switch_to_thread.\n\t(set_target_ops): Ajust to use process_stratum_target.\n\t* target.h (struct target_ops): Rename to ...\n\t(struct process_stratum_target): ... this.\n\t(the_target, set_target_ops): Adjust.\n\t(prepare_to_access_memory): Adjust comment.\n\t* win32-low.c (child_xfer_memory): Adjust to use\n\tprocess_stratum_target.\n\t(win32_target_ops): Now a process_stratum_target.",
    "tree": {
      "sha": "a9950394d47bda650df5bc9dcabd7094baf8d30b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a9950394d47bda650df5bc9dcabd7094baf8d30b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "75c6c844d9df37761e0e834df057b89e41816e55",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/75c6c844d9df37761e0e834df057b89e41816e55",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/75c6c844d9df37761e0e834df057b89e41816e55"
    }
  ],
  "stats": {
    "total": 3129,
    "additions": 2263,
    "deletions": 866
  },
  "files": [
    {
      "sha": "5218bbd58b55a9f2ab005d3e90d5b22de0470129",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 419,
      "deletions": 0,
      "changes": 419,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1,3 +1,422 @@\n+2020-01-10  Pedro Alves  <palves@redhat.com>\n+\t    John Baldwin  <jhb@FreeBSD.org>\n+\n+\t* aarch64-linux-nat.c\n+\t(aarch64_linux_nat_target::thread_architecture): Adjust.\n+\t* ada-tasks.c (print_ada_task_info): Adjust find_thread_ptid call.\n+\t(task_command_1): Likewise.\n+\t* aix-thread.c (sync_threadlists, aix_thread_target::resume)\n+\t(aix_thread_target::wait, aix_thread_target::fetch_registers)\n+\t(aix_thread_target::store_registers)\n+\t(aix_thread_target::thread_alive): Adjust.\n+\t* amd64-fbsd-tdep.c: Include \"inferior.h\".\n+\t(amd64fbsd_get_thread_local_address): Pass down target.\n+\t* amd64-linux-nat.c (ps_get_thread_area): Use ps_prochandle\n+\tthread's gdbarch instead of target_gdbarch.\n+\t* break-catch-sig.c (signal_catchpoint_print_it): Adjust call to\n+\tget_last_target_status.\n+\t* break-catch-syscall.c (print_it_catch_syscall): Likewise.\n+\t* breakpoint.c (breakpoints_should_be_inserted_now): Consider all\n+\tinferiors.\n+\t(update_inserted_breakpoint_locations): Skip if inferiors with no\n+\texecution.\n+\t(update_global_location_list): When handling moribund locations,\n+\tfind representative inferior for location's pspace, and use thread\n+\tcount of its process_stratum target.\n+\t* bsd-kvm.c (bsd_kvm_target_open): Pass target down.\n+\t* bsd-uthread.c (bsd_uthread_target::wait): Use\n+\tas_process_stratum_target and adjust thread_change_ptid and\n+\tadd_thread calls.\n+\t(bsd_uthread_target::update_thread_list): Use\n+\tas_process_stratum_target and adjust find_thread_ptid,\n+\tthread_change_ptid and add_thread calls.\n+\t* btrace.c (maint_btrace_packet_history_cmd): Adjust\n+\tfind_thread_ptid call.\n+\t* corelow.c (add_to_thread_list): Adjust add_thread call.\n+\t(core_target_open): Adjust add_thread_silent and thread_count\n+\tcalls.\n+\t(core_target::pid_to_str): Adjust find_inferior_ptid call.\n+\t* ctf.c (ctf_target_open): Adjust add_thread_silent call.\n+\t* event-top.c (async_disconnect): Pop targets from all inferiors.\n+\t* exec.c (add_target_sections): Push exec target on all inferiors\n+\tsharing the program space.\n+\t(remove_target_sections): Remove the exec target from all\n+\tinferiors sharing the program space.\n+\t(exec_on_vfork): New.\n+\t* exec.h (exec_on_vfork): Declare.\n+\t* fbsd-nat.c (fbsd_add_threads): Add fbsd_nat_target parameter.\n+\tPass it down.\n+\t(fbsd_nat_target::update_thread_list): Adjust.\n+\t(fbsd_nat_target::resume): Adjust.\n+\t(fbsd_handle_debug_trap): Add fbsd_nat_target parameter.  Pass it\n+\tdown.\n+\t(fbsd_nat_target::wait, fbsd_nat_target::post_attach): Adjust.\n+\t* fbsd-tdep.c (fbsd_corefile_thread): Adjust\n+\tget_thread_arch_regcache call.\n+\t* fork-child.c (gdb_startup_inferior): Pass target down to\n+\tstartup_inferior and set_executing.\n+\t* gdbthread.h (struct process_stratum_target): Forward declare.\n+\t(add_thread, add_thread_silent, add_thread_with_info)\n+\t(in_thread_list): Add process_stratum_target parameter.\n+\t(find_thread_ptid(inferior*, ptid_t)): New overload.\n+\t(find_thread_ptid, thread_change_ptid): Add process_stratum_target\n+\tparameter.\n+\t(all_threads()): Delete overload.\n+\t(all_threads, all_non_exited_threads): Add process_stratum_target\n+\tparameter.\n+\t(all_threads_safe): Use brace initialization.\n+\t(thread_count): Add process_stratum_target parameter.\n+\t(set_resumed, set_running, set_stop_requested, set_executing)\n+\t(threads_are_executing, finish_thread_state): Add\n+\tprocess_stratum_target parameter.\n+\t(switch_to_thread): Use is_current_thread.\n+\t* i386-fbsd-tdep.c: Include \"inferior.h\".\n+\t(i386fbsd_get_thread_local_address): Pass down target.\n+\t* i386-linux-nat.c (i386_linux_nat_target::low_resume): Adjust.\n+\t* inf-child.c (inf_child_target::maybe_unpush_target): Remove\n+\thave_inferiors check.\n+\t* inf-ptrace.c (inf_ptrace_target::create_inferior)\n+\t(inf_ptrace_target::attach): Adjust.\n+\t* infcall.c (run_inferior_call): Adjust.\n+\t* infcmd.c (run_command_1): Pass target to\n+\tscoped_finish_thread_state.\n+\t(proceed_thread_callback): Skip inferiors with no execution.\n+\t(continue_command): Rename 'all_threads' local to avoid hiding\n+\t'all_threads' function.  Adjust get_last_target_status call.\n+\t(prepare_one_step): Adjust set_running call.\n+\t(signal_command): Use user_visible_resume_target.  Compare thread\n+\tpointers instead of inferior_ptid.\n+\t(info_program_command): Adjust to pass down target.\n+\t(attach_command): Mark target's 'thread_executing' flag.\n+\t(stop_current_target_threads_ns): New, factored out from ...\n+\t(interrupt_target_1): ... this.  Switch inferior before making\n+\ttarget calls.\n+\t* inferior-iter.h\n+\t(struct all_inferiors_iterator, struct all_inferiors_range)\n+\t(struct all_inferiors_safe_range)\n+\t(struct all_non_exited_inferiors_range): Filter on\n+\tprocess_stratum_target too.  Remove explicit.\n+\t* inferior.c (inferior::inferior): Push dummy target on target\n+\tstack.\n+\t(find_inferior_pid, find_inferior_ptid, number_of_live_inferiors):\n+\tAdd process_stratum_target parameter, and pass it down.\n+\t(have_live_inferiors): Adjust.\n+\t(switch_to_inferior_and_push_target): New.\n+\t(add_inferior_command, clone_inferior_command): Handle\n+\t\"-no-connection\" parameter.  Use\n+\tswitch_to_inferior_and_push_target.\n+\t(_initialize_inferior): Mention \"-no-connection\" option in\n+\tthe help of \"add-inferior\" and \"clone-inferior\" commands.\n+\t* inferior.h: Include \"process-stratum-target.h\".\n+\t(interrupt_target_1): Use bool.\n+\t(struct inferior) <push_target, unpush_target, target_is_pushed,\n+\tfind_target_beneath, top_target, process_target, target_at,\n+\tm_stack>: New.\n+\t(discard_all_inferiors): Delete.\n+\t(find_inferior_pid, find_inferior_ptid, number_of_live_inferiors)\n+\t(all_inferiors, all_non_exited_inferiors): Add\n+\tprocess_stratum_target parameter.\n+\t* infrun.c: Include \"gdb_select.h\" and <unordered_map>.\n+\t(target_last_proc_target): New global.\n+\t(follow_fork_inferior): Push target on new inferior.  Pass target\n+\tto add_thread_silent.  Call exec_on_vfork.  Handle target's\n+\treference count.\n+\t(follow_fork): Adjust get_last_target_status call.  Also consider\n+\ttarget.\n+\t(follow_exec): Push target on new inferior.\n+\t(struct execution_control_state) <target>: New field.\n+\t(user_visible_resume_target): New.\n+\t(do_target_resume): Call target_async.\n+\t(resume_1): Set target's threads_executing flag.  Consider resume\n+\ttarget.\n+\t(commit_resume_all_targets): New.\n+\t(proceed): Also consider resume target.  Skip threads of inferiors\n+\twith no execution.  Commit resumtion in all targets.\n+\t(start_remote): Pass current inferior to wait_for_inferior.\n+\t(infrun_thread_stop_requested): Consider target as well.  Pass\n+\tthread_info pointer to clear_inline_frame_state instead of ptid.\n+\t(infrun_thread_thread_exit): Consider target as well.\n+\t(random_pending_event_thread): New inferior parameter.  Use it.\n+\t(do_target_wait): Rename to ...\n+\t(do_target_wait_1): ... this.  Add inferior parameter, and pass it\n+\tdown.\n+\t(threads_are_resumed_pending_p, do_target_wait): New.\n+\t(prepare_for_detach): Adjust calls.\n+\t(wait_for_inferior): New inferior parameter.  Handle it.  Use\n+\tdo_target_wait_1 instead of do_target_wait.\n+\t(fetch_inferior_event): Adjust.  Switch to representative\n+\tinferior.  Pass target down.\n+\t(set_last_target_status): Add process_stratum_target parameter.\n+\tSave target in global.\n+\t(get_last_target_status): Add process_stratum_target parameter and\n+\thandle it.\n+\t(nullify_last_target_wait_ptid): Clear 'target_last_proc_target'.\n+\t(context_switch): Check inferior_ptid == null_ptid before calling\n+\tinferior_thread().\n+\t(get_inferior_stop_soon): Pass down target.\n+\t(wait_one): Rename to ...\n+\t(poll_one_curr_target): ... this.\n+\t(struct wait_one_event): New.\n+\t(wait_one): New.\n+\t(stop_all_threads): Adjust.\n+\t(handle_no_resumed, handle_inferior_event): Adjust to consider the\n+\tevent's target.\n+\t(switch_back_to_stepped_thread): Also consider target.\n+\t(print_stop_event): Update.\n+\t(normal_stop): Update.  Also consider the resume target.\n+\t* infrun.h (wait_for_inferior): Remove declaration.\n+\t(user_visible_resume_target): New declaration.\n+\t(get_last_target_status, set_last_target_status): New\n+\tprocess_stratum_target parameter.\n+\t* inline-frame.c (clear_inline_frame_state(ptid_t)): Add\n+\tprocess_stratum_target parameter, and use it.\n+\t(clear_inline_frame_state (thread_info*)): New.\n+\t* inline-frame.c (clear_inline_frame_state(ptid_t)): Add\n+\tprocess_stratum_target parameter.\n+\t(clear_inline_frame_state (thread_info*)): Declare.\n+\t* linux-fork.c (delete_checkpoint_command): Pass target down to\n+\tfind_thread_ptid.\n+\t(checkpoint_command): Adjust.\n+\t* linux-nat.c (linux_nat_target::follow_fork): Switch to thread\n+\tinstead of just tweaking inferior_ptid.\n+\t(linux_nat_switch_fork): Pass target down to thread_change_ptid.\n+\t(exit_lwp): Pass target down to find_thread_ptid.\n+\t(attach_proc_task_lwp_callback): Pass target down to\n+\tadd_thread/set_running/set_executing.\n+\t(linux_nat_target::attach): Pass target down to\n+\tthread_change_ptid.\n+\t(get_detach_signal): Pass target down to find_thread_ptid.\n+\tConsider last target status's target.\n+\t(linux_resume_one_lwp_throw, resume_lwp)\n+\t(linux_handle_syscall_trap, linux_handle_extended_wait, wait_lwp)\n+\t(stop_wait_callback, save_stop_reason, linux_nat_filter_event)\n+\t(linux_nat_wait_1, resume_stopped_resumed_lwps): Pass target down.\n+\t(linux_nat_target::async_wait_fd): New.\n+\t(linux_nat_stop_lwp, linux_nat_target::thread_address_space): Pass\n+\ttarget down.\n+\t* linux-nat.h (linux_nat_target::async_wait_fd): Declare.\n+\t* linux-tdep.c (get_thread_arch_regcache): Pass target down.\n+\t* linux-thread-db.c (struct thread_db_info::process_target): New\n+\tfield.\n+\t(add_thread_db_info): Save target.\n+\t(get_thread_db_info): New process_stratum_target parameter.  Also\n+\tmatch target.\n+\t(delete_thread_db_info): New process_stratum_target parameter.\n+\tAlso match target.\n+\t(thread_from_lwp): Adjust to pass down target.\n+\t(thread_db_notice_clone): Pass down target.\n+\t(check_thread_db_callback): Pass down target.\n+\t(try_thread_db_load_1): Always push the thread_db target.\n+\t(try_thread_db_load, record_thread): Pass target down.\n+\t(thread_db_target::detach): Pass target down.  Always unpush the\n+\tthread_db target.\n+\t(thread_db_target::wait, thread_db_target::mourn_inferior): Pass\n+\ttarget down.  Always unpush the thread_db target.\n+\t(find_new_threads_callback, thread_db_find_new_threads_2)\n+\t(thread_db_target::update_thread_list): Pass target down.\n+\t(thread_db_target::pid_to_str): Pass current inferior down.\n+\t(thread_db_target::get_thread_local_address): Pass target down.\n+\t(thread_db_target::resume, maintenance_check_libthread_db): Pass\n+\ttarget down.\n+\t* nto-procfs.c (nto_procfs_target::update_thread_list): Adjust.\n+\t* procfs.c (procfs_target::procfs_init_inferior): Declare.\n+\t(proc_set_current_signal, do_attach, procfs_target::wait): Adjust.\n+\t(procfs_init_inferior): Rename to ...\n+\t(procfs_target::procfs_init_inferior): ... this and adjust.\n+\t(procfs_target::create_inferior, procfs_notice_thread)\n+\t(procfs_do_thread_registers): Adjust.\n+\t* ppc-fbsd-tdep.c: Include \"inferior.h\".\n+\t(ppcfbsd_get_thread_local_address): Pass down target.\n+\t* proc-service.c (ps_xfer_memory): Switch current inferior and\n+\tprogram space as well.\n+\t(get_ps_regcache): Pass target down.\n+\t* process-stratum-target.c\n+\t(process_stratum_target::thread_address_space)\n+\t(process_stratum_target::thread_architecture): Pass target down.\n+\t* process-stratum-target.h\n+\t(process_stratum_target::threads_executing): New field.\n+\t(as_process_stratum_target): New.\n+\t* ravenscar-thread.c\n+\t(ravenscar_thread_target::update_inferior_ptid): Pass target down.\n+\t(ravenscar_thread_target::wait, ravenscar_add_thread): Pass target\n+\tdown.\n+\t* record-btrace.c (record_btrace_target::info_record): Adjust.\n+\t(record_btrace_target::record_method)\n+\t(record_btrace_target::record_is_replaying)\n+\t(record_btrace_target::fetch_registers)\n+\t(get_thread_current_frame_id, record_btrace_target::resume)\n+\t(record_btrace_target::wait, record_btrace_target::stop): Pass\n+\ttarget down.\n+\t* record-full.c (record_full_wait_1): Switch to event thread.\n+\tPass target down.\n+\t* regcache.c (regcache::regcache)\n+\t(get_thread_arch_aspace_regcache, get_thread_arch_regcache): Add\n+\tprocess_stratum_target parameter and handle it.\n+\t(current_thread_target): New global.\n+\t(get_thread_regcache): Add process_stratum_target parameter and\n+\thandle it.  Switch inferior before calling target method.\n+\t(get_thread_regcache): Pass target down.\n+\t(get_thread_regcache_for_ptid): Pass target down.\n+\t(registers_changed_ptid): Add process_stratum_target parameter and\n+\thandle it.\n+\t(registers_changed_thread, registers_changed): Pass target down.\n+\t(test_get_thread_arch_aspace_regcache): New.\n+\t(current_regcache_test): Define a couple local test_target_ops\n+\tinstances and use them for testing.\n+\t(readwrite_regcache): Pass process_stratum_target parameter.\n+\t(cooked_read_test, cooked_write_test): Pass mock_target down.\n+\t* regcache.h (get_thread_regcache, get_thread_arch_regcache)\n+\t(get_thread_arch_aspace_regcache): Add process_stratum_target\n+\tparameter.\n+\t(regcache::target): New method.\n+\t(regcache::regcache, regcache::get_thread_arch_aspace_regcache)\n+\t(regcache::registers_changed_ptid): Add process_stratum_target\n+\tparameter.\n+\t(regcache::m_target): New field.\n+\t(registers_changed_ptid): Add process_stratum_target parameter.\n+\t* remote.c (remote_state::supports_vCont_probed): New field.\n+\t(remote_target::async_wait_fd): New method.\n+\t(remote_unpush_and_throw): Add remote_target parameter.\n+\t(get_current_remote_target): Adjust.\n+\t(remote_target::remote_add_inferior): Push target.\n+\t(remote_target::remote_add_thread)\n+\t(remote_target::remote_notice_new_inferior)\n+\t(get_remote_thread_info): Pass target down.\n+\t(remote_target::update_thread_list): Skip threads of inferiors\n+\tbound to other targets.  (remote_target::close): Don't discard\n+\tinferiors.  (remote_target::add_current_inferior_and_thread)\n+\t(remote_target::process_initial_stop_replies)\n+\t(remote_target::start_remote)\n+\t(remote_target::remote_serial_quit_handler): Pass down target.\n+\t(remote_target::remote_unpush_target): New remote_target\n+\tparameter.  Unpush the target from all inferiors.\n+\t(remote_target::remote_unpush_and_throw): New remote_target\n+\tparameter.  Pass it down.\n+\t(remote_target::open_1): Check whether the current inferior has\n+\texecution instead of checking whether any inferior is live.  Pass\n+\ttarget down.\n+\t(remote_target::remote_detach_1): Pass down target.  Use\n+\tremote_unpush_target.\n+\t(extended_remote_target::attach): Pass down target.\n+\t(remote_target::remote_vcont_probe): Set supports_vCont_probed.\n+\t(remote_target::append_resumption): Pass down target.\n+\t(remote_target::append_pending_thread_resumptions)\n+\t(remote_target::remote_resume_with_hc, remote_target::resume)\n+\t(remote_target::commit_resume): Pass down target.\n+\t(remote_target::remote_stop_ns): Check supports_vCont_probed.\n+\t(remote_target::interrupt_query)\n+\t(remote_target::remove_new_fork_children)\n+\t(remote_target::check_pending_events_prevent_wildcard_vcont)\n+\t(remote_target::remote_parse_stop_reply)\n+\t(remote_target::process_stop_reply): Pass down target.\n+\t(first_remote_resumed_thread): New remote_target parameter.  Pass\n+\tit down.\n+\t(remote_target::wait_as): Pass down target.\n+\t(unpush_and_perror): New remote_target parameter.  Pass it down.\n+\t(remote_target::readchar, remote_target::remote_serial_write)\n+\t(remote_target::getpkt_or_notif_sane_1)\n+\t(remote_target::kill_new_fork_children, remote_target::kill): Pass\n+\tdown target.\n+\t(remote_target::mourn_inferior): Pass down target.  Use\n+\tremote_unpush_target.\n+\t(remote_target::core_of_thread)\n+\t(remote_target::remote_btrace_maybe_reopen): Pass down target.\n+\t(remote_target::pid_to_exec_file)\n+\t(remote_target::thread_handle_to_thread_info): Pass down target.\n+\t(remote_target::async_wait_fd): New.\n+\t* riscv-fbsd-tdep.c: Include \"inferior.h\".\n+\t(riscv_fbsd_get_thread_local_address): Pass down target.\n+\t* sol2-tdep.c (sol2_core_pid_to_str): Pass down target.\n+\t* sol-thread.c (sol_thread_target::wait, ps_lgetregs, ps_lsetregs)\n+\t(ps_lgetfpregs, ps_lsetfpregs, sol_update_thread_list_callback):\n+\tAdjust.\n+\t* solib-spu.c (spu_skip_standalone_loader): Pass down target.\n+\t* solib-svr4.c (enable_break): Pass down target.\n+\t* spu-multiarch.c (parse_spufs_run): Pass down target.\n+\t* spu-tdep.c (spu2ppu_sniffer): Pass down target.\n+\t* target-delegates.c: Regenerate.\n+\t* target.c (g_target_stack): Delete.\n+\t(current_top_target): Return the current inferior's top target.\n+\t(target_has_execution_1): Refer to the passed-in inferior's top\n+\ttarget.\n+\t(target_supports_terminal_ours): Check whether the initial\n+\tinferior was already created.\n+\t(decref_target): New.\n+\t(target_stack::push): Incref/decref the target.\n+\t(push_target, push_target, unpush_target): Adjust.\n+\t(target_stack::unpush): Defref target.\n+\t(target_is_pushed): Return bool.  Adjust to refer to the current\n+\tinferior's target stack.\n+\t(dispose_inferior): Delete, and inline parts ...\n+\t(target_preopen): ... here.  Only dispose of the current inferior.\n+\t(target_detach): Hold strong target reference while detaching.\n+\tPass target down.\n+\t(target_thread_name): Add assertion.\n+\t(target_resume): Pass down target.\n+\t(target_ops::beneath, find_target_at): Adjust to refer to the\n+\tcurrent inferior's target stack.\n+\t(get_dummy_target): New.\n+\t(target_pass_ctrlc): Pass the Ctrl-C to the first inferior that\n+\thas a thread running.\n+\t(initialize_targets): Rename to ...\n+\t(_initialize_target): ... this.\n+\t* target.h: Include \"gdbsupport/refcounted-object.h\".\n+\t(struct target_ops): Inherit refcounted_object.\n+\t(target_ops::shortname, target_ops::longname): Make const.\n+\t(target_ops::async_wait_fd): New method.\n+\t(decref_target): Declare.\n+\t(struct target_ops_ref_policy): New.\n+\t(target_ops_ref): New typedef.\n+\t(get_dummy_target): Declare function.\n+\t(target_is_pushed): Return bool.\n+\t* thread-iter.c (all_matching_threads_iterator::m_inf_matches)\n+\t(all_matching_threads_iterator::all_matching_threads_iterator):\n+\tHandle filter target.\n+\t* thread-iter.h (struct all_matching_threads_iterator, struct\n+\tall_matching_threads_range, class all_non_exited_threads_range):\n+\tFilter by target too.  Remove explicit.\n+\t* thread.c (threads_executing): Delete.\n+\t(inferior_thread): Pass down current inferior.\n+\t(clear_thread_inferior_resources): Pass down thread pointer\n+\tinstead of ptid_t.\n+\t(add_thread_silent, add_thread_with_info, add_thread): Add\n+\tprocess_stratum_target parameter.  Use it for thread and inferior\n+\tsearches.\n+\t(is_current_thread): New.\n+\t(thread_info::deletable): Use it.\n+\t(find_thread_ptid, thread_count, in_thread_list)\n+\t(thread_change_ptid, set_resumed, set_running): New\n+\tprocess_stratum_target parameter.  Pass it down.\n+\t(set_executing): New process_stratum_target parameter.  Pass it\n+\tdown.  Adjust reference to 'threads_executing'.\n+\t(threads_are_executing): New process_stratum_target parameter.\n+\tAdjust reference to 'threads_executing'.\n+\t(set_stop_requested, finish_thread_state): New\n+\tprocess_stratum_target parameter.  Pass it down.\n+\t(switch_to_thread): Also match inferior.\n+\t(switch_to_thread): New process_stratum_target parameter.  Pass it\n+\tdown.\n+\t(update_threads_executing): Reimplement.\n+\t* top.c (quit_force): Pop targets from all inferior.\n+\t(gdb_init): Don't call initialize_targets.\n+\t* windows-nat.c (windows_nat_target) <get_windows_debug_event>:\n+\tDeclare.\n+\t(windows_add_thread, windows_delete_thread): Adjust.\n+\t(get_windows_debug_event): Rename to ...\n+\t(windows_nat_target::get_windows_debug_event): ... this.  Adjust.\n+\t* tracefile-tfile.c (tfile_target_open): Pass down target.\n+\t* gdbsupport/common-gdbthread.h (struct process_stratum_target):\n+\tForward declare.\n+\t(switch_to_thread): Add process_stratum_target parameter.\n+\t* mi/mi-interp.c (mi_on_resume_1): Add process_stratum_target\n+\tparameter.  Use it.\n+\t(mi_on_resume): Pass target down.\n+\t* nat/fork-inferior.c (startup_inferior): Add\n+\tprocess_stratum_target parameter.  Pass it down.\n+\t* nat/fork-inferior.h (startup_inferior): Add\n+\tprocess_stratum_target parameter.\n+\t* python/py-threadevent.c (py_get_event_thread): Pass target down.\n+\n 2020-01-10  Pedro Alves  <palves@redhat.com>\n \n \t* remote.c (remote_target::start_remote): Don't set inferior_ptid"
    },
    {
      "sha": "b385b5866c0d718f569066b5a473373ef40ae30b",
      "filename": "gdb/aarch64-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/aarch64-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/aarch64-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-nat.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -959,7 +959,7 @@ aarch64_linux_nat_target::thread_architecture (ptid_t ptid)\n \n   /* Find the current gdbarch the same way as process_stratum_target.  Only\n      return it if the current vector length matches the one in the tdep.  */\n-  inferior *inf = find_inferior_ptid (ptid);\n+  inferior *inf = find_inferior_ptid (this, ptid);\n   gdb_assert (inf != NULL);\n   if (vq == gdbarch_tdep (inf->gdbarch)->vq)\n     return inf->gdbarch;"
    },
    {
      "sha": "0b7a8eb4ad46378eadea684c679020c3aa1966cf",
      "filename": "gdb/ada-tasks.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/ada-tasks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/ada-tasks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-tasks.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1128,7 +1128,7 @@ print_ada_task_info (struct ui_out *uiout,\n       if (uiout->is_mi_like_p ())\n         {\n \t  thread_info *thread = (ada_task_is_alive (task_info)\n-\t\t\t\t ? find_thread_ptid (task_info->ptid)\n+\t\t\t\t ? find_thread_ptid (inf, task_info->ptid)\n \t\t\t\t : nullptr);\n \n \t  if (thread != NULL)\n@@ -1343,7 +1343,7 @@ task_command_1 (const char *taskno_str, int from_tty, struct inferior *inf)\n      computed if target_get_ada_task_ptid has not been implemented for\n      our target (yet).  Rather than cause an assertion error in that case,\n      it's nicer for the user to just refuse to perform the task switch.  */\n-  thread_info *tp = find_thread_ptid (task_info->ptid);\n+  thread_info *tp = find_thread_ptid (inf, task_info->ptid);\n   if (tp == NULL)\n     error (_(\"Unable to compute thread ID for task %s.\\n\"\n              \"Cannot switch to this task.\"),"
    },
    {
      "sha": "b9b25d5e3cb637f7a79cd8bf1f00f2cc49672a52",
      "filename": "gdb/aix-thread.c",
      "status": "modified",
      "additions": 17,
      "deletions": 7,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/aix-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/aix-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aix-thread.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -805,7 +805,11 @@ sync_threadlists (void)\n \t  priv->pdtid = pbuf[pi].pdtid;\n \t  priv->tid = pbuf[pi].tid;\n \n-\t  thread = add_thread_with_info (ptid_t (infpid, 0, pbuf[pi].pthid), priv);\n+\t  process_stratum_target *proc_target\n+\t    = current_inferior ()->process_target ();\n+\t  thread = add_thread_with_info (proc_target,\n+\t\t\t\t\t ptid_t (infpid, 0, pbuf[pi].pthid),\n+\t\t\t\t\t priv);\n \n \t  pi++;\n \t}\n@@ -837,7 +841,9 @@ sync_threadlists (void)\n \t    }\n \t  else\n \t    {\n-\t      thread = add_thread (pptid);\n+\t      process_stratum_target *proc_target\n+\t\t= current_inferior ()->process_target ();\n+\t      thread = add_thread (proc_target, pptid);\n \n \t      aix_thread_info *priv = new aix_thread_info;\n \t      thread->priv.reset (priv);\n@@ -1043,7 +1049,7 @@ aix_thread_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n     }\n   else\n     {\n-      thread = find_thread_ptid (ptid);\n+      thread = find_thread_ptid (current_inferior (), ptid);\n       if (!thread)\n \terror (_(\"aix-thread resume: unknown pthread %ld\"),\n \t       ptid.lwp ());\n@@ -1089,7 +1095,9 @@ aix_thread_target::wait (ptid_t ptid, struct target_waitstatus *status,\n   if (!pd_active && status->kind == TARGET_WAITKIND_STOPPED\n       && status->value.sig == GDB_SIGNAL_TRAP)\n     {\n-      struct regcache *regcache = get_thread_regcache (ptid);\n+      process_stratum_target *proc_target\n+\t= current_inferior ()->process_target ();\n+      struct regcache *regcache = get_thread_regcache (proc_target, ptid);\n       struct gdbarch *gdbarch = regcache->arch ();\n \n       if (regcache_read_pc (regcache)\n@@ -1354,7 +1362,7 @@ aix_thread_target::fetch_registers (struct regcache *regcache, int regno)\n     beneath ()->fetch_registers (regcache, regno);\n   else\n     {\n-      thread = find_thread_ptid (regcache->ptid ());\n+      thread = find_thread_ptid (current_inferior (), regcache->ptid ());\n       aix_thread_info *priv = get_aix_thread_info (thread);\n       tid = priv->tid;\n \n@@ -1692,7 +1700,7 @@ aix_thread_target::store_registers (struct regcache *regcache, int regno)\n     beneath ()->store_registers (regcache, regno);\n   else\n     {\n-      thread = find_thread_ptid (regcache->ptid ());\n+      thread = find_thread_ptid (current_inferior (), regcache->ptid ());\n       aix_thread_info *priv = get_aix_thread_info (thread);\n       tid = priv->tid;\n \n@@ -1740,7 +1748,9 @@ aix_thread_target::thread_alive (ptid_t ptid)\n \n   /* We update the thread list every time the child stops, so all\n      valid threads should be in the thread list.  */\n-  return in_thread_list (ptid);\n+  process_stratum_target *proc_target\n+    = current_inferior ()->process_target ();\n+  return in_thread_list (proc_target, ptid);\n }\n \n /* Return a printable representation of composite PID for use in"
    },
    {
      "sha": "b0639ed95a672102ccf0395c99610dc2ad074b90",
      "filename": "gdb/amd64-fbsd-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/amd64-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/amd64-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-fbsd-tdep.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -30,6 +30,7 @@\n #include \"amd64-tdep.h\"\n #include \"fbsd-tdep.h\"\n #include \"solib-svr4.h\"\n+#include \"inferior.h\"\n \n /* Support for signal handlers.  */\n \n@@ -212,7 +213,8 @@ amd64fbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n {\n   struct regcache *regcache;\n \n-  regcache = get_thread_arch_regcache (ptid, gdbarch);\n+  regcache = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\t       ptid, gdbarch);\n \n   target_fetch_registers (regcache, AMD64_FSBASE_REGNUM);\n "
    },
    {
      "sha": "27748ff9860081f577de143b1b197ab314dc2e4f",
      "filename": "gdb/amd64-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/amd64-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/amd64-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-linux-nat.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -383,7 +383,7 @@ ps_err_e\n ps_get_thread_area (struct ps_prochandle *ph,\n                     lwpid_t lwpid, int idx, void **base)\n {\n-  if (gdbarch_bfd_arch_info (target_gdbarch ())->bits_per_word == 32)\n+  if (gdbarch_bfd_arch_info (ph->thread->inf->gdbarch)->bits_per_word == 32)\n     {\n       unsigned int base_addr;\n       ps_err_e result;"
    },
    {
      "sha": "c645746aa834f83f3eabdd9db809b1b94961863e",
      "filename": "gdb/break-catch-sig.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/break-catch-sig.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/break-catch-sig.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-sig.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -185,7 +185,7 @@ signal_catchpoint_print_it (bpstat bs)\n   const char *signal_name;\n   struct ui_out *uiout = current_uiout;\n \n-  get_last_target_status (nullptr, &last);\n+  get_last_target_status (nullptr, nullptr, &last);\n \n   signal_name = signal_to_name_or_int (last.value.sig);\n "
    },
    {
      "sha": "553c01cb320378e9c83031769867ed9959a5e79c",
      "filename": "gdb/break-catch-syscall.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/break-catch-syscall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/break-catch-syscall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-syscall.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -186,7 +186,7 @@ print_it_catch_syscall (bpstat bs)\n   struct syscall s;\n   struct gdbarch *gdbarch = bs->bp_location_at->gdbarch;\n \n-  get_last_target_status (nullptr, &last);\n+  get_last_target_status (nullptr, nullptr, &last);\n \n   get_syscall_by_number (gdbarch, last.value.syscall_number, &s);\n "
    },
    {
      "sha": "5b734abf1c161b41001b428782a0f27d19f13edb",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 19,
      "deletions": 6,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -389,7 +389,7 @@ breakpoints_should_be_inserted_now (void)\n \t no threads under GDB's control yet.  */\n       return 1;\n     }\n-  else if (target_has_execution)\n+  else\n     {\n       if (always_inserted_mode)\n \t{\n@@ -398,8 +398,10 @@ breakpoints_should_be_inserted_now (void)\n \t  return 1;\n \t}\n \n-      if (threads_are_executing ())\n-\treturn 1;\n+      for (inferior *inf : all_inferiors ())\n+\tif (inf->has_execution ()\n+\t    && threads_are_executing (inf->process_target ()))\n+\t  return 1;\n \n       /* Don't remove breakpoints yet if, even though all threads are\n \t stopped, we still have events to process.  */\n@@ -2887,7 +2889,7 @@ update_inserted_breakpoint_locations (void)\n \t if we aren't attached to any process yet, we should still\n \t insert breakpoints.  */\n       if (!gdbarch_has_global_breakpoints (target_gdbarch ())\n-\t  && inferior_ptid == null_ptid)\n+\t  && (inferior_ptid == null_ptid || !target_has_execution))\n \tcontinue;\n \n       val = insert_bp_location (bl, &tmp_error_stream, &disabled_breaks,\n@@ -2943,7 +2945,7 @@ insert_breakpoint_locations (void)\n \t if we aren't attached to any process yet, we should still\n \t insert breakpoints.  */\n       if (!gdbarch_has_global_breakpoints (target_gdbarch ())\n-\t  && inferior_ptid == null_ptid)\n+\t  && (inferior_ptid == null_ptid || !target_has_execution))\n \tcontinue;\n \n       val = insert_bp_location (bl, &tmp_error_stream, &disabled_breaks,\n@@ -11903,7 +11905,18 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n \t\t around.  We simply always ignore hardware watchpoint\n \t\t traps we can no longer explain.  */\n \n-\t      old_loc->events_till_retirement = 3 * (thread_count () + 1);\n+\t      process_stratum_target *proc_target = nullptr;\n+\t      for (inferior *inf : all_inferiors ())\n+\t\tif (inf->pspace == old_loc->pspace)\n+\t\t  {\n+\t\t    proc_target = inf->process_target ();\n+\t\t    break;\n+\t\t  }\n+\t      if (proc_target != nullptr)\n+\t\told_loc->events_till_retirement\n+\t\t  = 3 * (thread_count (proc_target) + 1);\n+\t      else\n+\t\told_loc->events_till_retirement = 1;\n \t      old_loc->owner = NULL;\n \n \t      moribund_locations.push_back (old_loc);"
    },
    {
      "sha": "f864ba8b41ced3688fc922ef47ffbc571de3f0bb",
      "filename": "gdb/bsd-kvm.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/bsd-kvm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/bsd-kvm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bsd-kvm.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -136,7 +136,7 @@ bsd_kvm_target_open (const char *arg, int from_tty)\n   core_kd = temp_kd;\n   push_target (&bsd_kvm_ops);\n \n-  add_thread_silent (bsd_kvm_ptid);\n+  add_thread_silent (&bsd_kvm_ops, bsd_kvm_ptid);\n   inferior_ptid = bsd_kvm_ptid;\n \n   target_fetch_registers (get_current_regcache (), -1);"
    },
    {
      "sha": "a8622a8b0e47346e94ef49aaf2e39431a4fac0a9",
      "filename": "gdb/bsd-uthread.c",
      "status": "modified",
      "additions": 12,
      "deletions": 8,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/bsd-uthread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/bsd-uthread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bsd-uthread.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -381,9 +381,11 @@ bsd_uthread_target::wait (ptid_t ptid, struct target_waitstatus *status,\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n   CORE_ADDR addr;\n+  process_stratum_target *beneath\n+    = as_process_stratum_target (this->beneath ());\n \n   /* Pass the request to the layer beneath.  */\n-  ptid = beneath ()->wait (ptid, status, options);\n+  ptid = beneath->wait (ptid, status, options);\n \n   /* If the process is no longer alive, there's no point in figuring\n      out the thread ID.  It will fail anyway.  */\n@@ -414,13 +416,13 @@ bsd_uthread_target::wait (ptid_t ptid, struct target_waitstatus *status,\n      ptid with tid set, then ptid is still the initial thread of\n      the process.  Notify GDB core about it.  */\n   if (inferior_ptid.tid () == 0\n-      && ptid.tid () != 0 && !in_thread_list (ptid))\n-    thread_change_ptid (inferior_ptid, ptid);\n+      && ptid.tid () != 0 && !in_thread_list (beneath, ptid))\n+    thread_change_ptid (beneath, inferior_ptid, ptid);\n \n   /* Don't let the core see a ptid without a corresponding thread.  */\n-  thread_info *thread = find_thread_ptid (ptid);\n+  thread_info *thread = find_thread_ptid (beneath, ptid);\n   if (thread == NULL || thread->state == THREAD_EXITED)\n-    add_thread (ptid);\n+    add_thread (beneath, ptid);\n \n   return ptid;\n }\n@@ -467,16 +469,18 @@ bsd_uthread_target::update_thread_list ()\n     {\n       ptid_t ptid = ptid_t (pid, 0, addr);\n \n-      thread_info *thread = find_thread_ptid (ptid);\n+      process_stratum_target *proc_target\n+\t= as_process_stratum_target (this->beneath ());\n+      thread_info *thread = find_thread_ptid (proc_target, ptid);\n       if (thread == nullptr || thread->state == THREAD_EXITED)\n \t{\n \t  /* If INFERIOR_PTID doesn't have a tid member yet, then ptid\n \t     is still the initial thread of the process.  Notify GDB\n \t     core about it.  */\n \t  if (inferior_ptid.tid () == 0)\n-\t    thread_change_ptid (inferior_ptid, ptid);\n+\t    thread_change_ptid (proc_target, inferior_ptid, ptid);\n \t  else\n-\t    add_thread (ptid);\n+\t    add_thread (proc_target, ptid);\n \t}\n \n       addr = bsd_uthread_read_memory_address (addr + offset);"
    },
    {
      "sha": "a91a67681302ad032e6974fcebfca9d8ca92f3eb",
      "filename": "gdb/btrace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/btrace.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -3228,7 +3228,7 @@ maint_btrace_packet_history_cmd (const char *arg, int from_tty)\n   struct btrace_thread_info *btinfo;\n   unsigned int size, begin, end, from, to;\n \n-  thread_info *tp = find_thread_ptid (inferior_ptid);\n+  thread_info *tp = find_thread_ptid (current_inferior (), inferior_ptid);\n   if (tp == NULL)\n     error (_(\"No thread.\"));\n "
    },
    {
      "sha": "c53bf1df8fd80a542d940efccd5d27b419308378",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -314,7 +314,7 @@ add_to_thread_list (bfd *abfd, asection *asect, void *reg_sect_arg)\n \n   ptid = ptid_t (pid, lwpid, 0);\n \n-  add_thread (ptid);\n+  add_thread (inf->process_target (), ptid);\n \n /* Warning, Will Robinson, looking at BFD private data! */\n \n@@ -472,7 +472,7 @@ core_target_open (const char *arg, int from_tty)\n \t{\n \t  inferior_appeared (current_inferior (), CORELOW_PID);\n \t  inferior_ptid = ptid_t (CORELOW_PID);\n-\t  add_thread_silent (inferior_ptid);\n+\t  add_thread_silent (target, inferior_ptid);\n \t}\n       else\n \tswitch_to_thread (thread);\n@@ -540,7 +540,7 @@ core_target_open (const char *arg, int from_tty)\n   /* Current thread should be NUM 1 but the user does not know that.\n      If a program is single threaded gdb in general does not mention\n      anything about threads.  That is why the test is >= 2.  */\n-  if (thread_count () >= 2)\n+  if (thread_count (target) >= 2)\n     {\n       try\n \t{\n@@ -944,7 +944,7 @@ core_target::pid_to_str (ptid_t ptid)\n \n   /* Otherwise, this isn't a \"threaded\" core -- use the PID field, but\n      only if it isn't a fake PID.  */\n-  inf = find_inferior_ptid (ptid);\n+  inf = find_inferior_ptid (this, ptid);\n   if (inf != NULL && !inf->fake_pid_p)\n     return normal_pid_to_str (ptid);\n "
    },
    {
      "sha": "3f10b21280d6626382932b30ffce702c9c814167",
      "filename": "gdb/event-top.c",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/event-top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/event-top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/event-top.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1137,12 +1137,16 @@ async_disconnect (gdb_client_data arg)\n       exception_print (gdb_stderr, exception);\n     }\n \n-  try\n-    {\n-      pop_all_targets ();\n-    }\n-  catch (const gdb_exception &exception)\n+  for (inferior *inf : all_inferiors ())\n     {\n+      switch_to_inferior_no_thread (inf);\n+      try\n+\t{\n+\t  pop_all_targets ();\n+\t}\n+      catch (const gdb_exception &exception)\n+\t{\n+\t}\n     }\n \n   signal (SIGHUP, SIG_DFL);\t/*FIXME: ???????????  */"
    },
    {
      "sha": "468f9f57f76cceee2156f77887d58dcd0cb595fe",
      "filename": "gdb/exec.c",
      "status": "modified",
      "additions": 41,
      "deletions": 10,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -547,10 +547,23 @@ add_target_sections (void *owner,\n \t  table->sections[space + i].owner = owner;\n \t}\n \n+      scoped_restore_current_thread restore_thread;\n+      program_space *curr_pspace = current_program_space;\n+\n       /* If these are the first file sections we can provide memory\n-\t from, push the file_stratum target.  */\n-      if (!target_is_pushed (&exec_ops))\n-\tpush_target (&exec_ops);\n+\t from, push the file_stratum target.  Must do this in all\n+\t inferiors sharing the program space.  */\n+      for (inferior *inf : all_inferiors ())\n+\t{\n+\t  if (inf->pspace != curr_pspace)\n+\t    continue;\n+\n+\t  if (inf->target_is_pushed (&exec_ops))\n+\t    continue;\n+\n+\t  switch_to_inferior_no_thread (inf);\n+\t  push_target (&exec_ops);\n+\t}\n     }\n }\n \n@@ -628,21 +641,39 @@ remove_target_sections (void *owner)\n       old_count = resize_section_table (table, dest - src);\n \n       /* If we don't have any more sections to read memory from,\n-\t remove the file_stratum target from the stack.  */\n+\t remove the file_stratum target from the stack of each\n+\t inferior sharing the program space.  */\n       if (old_count + (dest - src) == 0)\n \t{\n-\t  struct program_space *pspace;\n+\t  scoped_restore_current_thread restore_thread;\n+\t  program_space *curr_pspace = current_program_space;\n+\n+\t  for (inferior *inf : all_inferiors ())\n+\t    {\n+\t      if (inf->pspace != curr_pspace)\n+\t\tcontinue;\n \n-\t  ALL_PSPACES (pspace)\n-\t    if (pspace->target_sections.sections\n-\t\t!= pspace->target_sections.sections_end)\n-\t      return;\n+\t      if (inf->pspace->target_sections.sections\n+\t\t  != inf->pspace->target_sections.sections_end)\n+\t\tcontinue;\n \n-\t  unpush_target (&exec_ops);\n+\t      switch_to_inferior_no_thread (inf);\n+\t      unpush_target (&exec_ops);\n+\t    }\n \t}\n     }\n }\n \n+/* See exec.h.  */\n+\n+void\n+exec_on_vfork ()\n+{\n+  if (current_program_space->target_sections.sections\n+      != current_program_space->target_sections.sections_end)\n+    push_target (&exec_ops);\n+}\n+\n \f\n \n enum target_xfer_status"
    },
    {
      "sha": "54e6ff4d9bab6c2c6f730b1faaf5a4062e20ce65",
      "filename": "gdb/exec.h",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/exec.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/exec.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -44,6 +44,13 @@ extern int build_section_table (struct bfd *, struct target_section **,\n \n extern void clear_section_table (struct target_section_table *table);\n \n+/* The current inferior is a child vforked and its program space is\n+   shared with its parent.  This pushes the exec target on the\n+   current/child inferior's target stack if there are sections in the\n+   program space's section table.  */\n+\n+extern void exec_on_vfork ();\n+\n /* Read from mappable read-only sections of BFD executable files.\n    Return TARGET_XFER_OK, if read is successful.  Return\n    TARGET_XFER_EOF if read is done.  Return TARGET_XFER_E_IO"
    },
    {
      "sha": "698d1f0b35e108f961b288108cb38f8f8e298dcb",
      "filename": "gdb/fbsd-nat.c",
      "status": "modified",
      "additions": 17,
      "deletions": 16,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -991,11 +991,11 @@ fbsd_enable_proc_events (pid_t pid)\n    called to discover new threads each time the thread list is updated.  */\n \n static void\n-fbsd_add_threads (pid_t pid)\n+fbsd_add_threads (fbsd_nat_target *target, pid_t pid)\n {\n   int i, nlwps;\n \n-  gdb_assert (!in_thread_list (ptid_t (pid)));\n+  gdb_assert (!in_thread_list (target, ptid_t (pid)));\n   nlwps = ptrace (PT_GETNUMLWPS, pid, NULL, 0);\n   if (nlwps == -1)\n     perror_with_name ((\"ptrace\"));\n@@ -1010,7 +1010,7 @@ fbsd_add_threads (pid_t pid)\n     {\n       ptid_t ptid = ptid_t (pid, lwps[i], 0);\n \n-      if (!in_thread_list (ptid))\n+      if (!in_thread_list (target, ptid))\n \t{\n #ifdef PT_LWP_EVENTS\n \t  struct ptrace_lwpinfo pl;\n@@ -1026,7 +1026,7 @@ fbsd_add_threads (pid_t pid)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"FLWP: adding thread for LWP %u\\n\",\n \t\t\t\tlwps[i]);\n-\t  add_thread (ptid);\n+\t  add_thread (target, ptid);\n \t}\n     }\n }\n@@ -1043,7 +1043,7 @@ fbsd_nat_target::update_thread_list ()\n #else\n   prune_threads ();\n \n-  fbsd_add_threads (inferior_ptid.pid ());\n+  fbsd_add_threads (this, inferior_ptid.pid ());\n #endif\n }\n \n@@ -1174,7 +1174,7 @@ fbsd_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n   if (ptid.lwp_p ())\n     {\n       /* If ptid is a specific LWP, suspend all other LWPs in the process.  */\n-      inferior *inf = find_inferior_ptid (ptid);\n+      inferior *inf = find_inferior_ptid (this, ptid);\n \n       for (thread_info *tp : inf->non_exited_threads ())\n         {\n@@ -1193,7 +1193,7 @@ fbsd_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n     {\n       /* If ptid is a wildcard, resume all matching threads (they won't run\n \t until the process is continued however).  */\n-      for (thread_info *tp : all_non_exited_threads (ptid))\n+      for (thread_info *tp : all_non_exited_threads (this, ptid))\n \tif (ptrace (PT_RESUME, tp->ptid.lwp (), NULL, 0) == -1)\n \t  perror_with_name ((\"ptrace\"));\n       ptid = inferior_ptid;\n@@ -1239,7 +1239,8 @@ fbsd_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n    core, return true.  */\n \n static bool\n-fbsd_handle_debug_trap (ptid_t ptid, const struct ptrace_lwpinfo &pl)\n+fbsd_handle_debug_trap (fbsd_nat_target *target, ptid_t ptid,\n+\t\t\tconst struct ptrace_lwpinfo &pl)\n {\n \n   /* Ignore traps without valid siginfo or for signals other than\n@@ -1266,7 +1267,7 @@ fbsd_handle_debug_trap (ptid_t ptid, const struct ptrace_lwpinfo &pl)\n   if (pl.pl_siginfo.si_code == TRAP_BRKPT)\n     {\n       /* Fixup PC for the software breakpoint.  */\n-      struct regcache *regcache = get_thread_regcache (ptid);\n+      struct regcache *regcache = get_thread_regcache (target, ptid);\n       struct gdbarch *gdbarch = regcache->arch ();\n       int decr_pc = gdbarch_decr_pc_after_break (gdbarch);\n \n@@ -1340,7 +1341,7 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t\t threads might be skipped during post_attach that\n \t\t have not yet reported their PL_FLAG_EXITED event.\n \t\t Ignore EXITED events for an unknown LWP.  */\n-\t      thread_info *thr = find_thread_ptid (wptid);\n+\t      thread_info *thr = find_thread_ptid (this, wptid);\n \t      if (thr != nullptr)\n \t\t{\n \t\t  if (debug_fbsd_lwp)\n@@ -1364,13 +1365,13 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t     PL_FLAG_BORN in case the first stop reported after\n \t     attaching to an existing process is a PL_FLAG_BORN\n \t     event.  */\n-\t  if (in_thread_list (ptid_t (pid)))\n+\t  if (in_thread_list (this, ptid_t (pid)))\n \t    {\n \t      if (debug_fbsd_lwp)\n \t\tfprintf_unfiltered (gdb_stdlog,\n \t\t\t\t    \"FLWP: using LWP %u for first thread\\n\",\n \t\t\t\t    pl.pl_lwpid);\n-\t      thread_change_ptid (ptid_t (pid), wptid);\n+\t      thread_change_ptid (this, ptid_t (pid), wptid);\n \t    }\n \n #ifdef PT_LWP_EVENTS\n@@ -1380,13 +1381,13 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t\t threads might be added by fbsd_add_threads that have\n \t\t not yet reported their PL_FLAG_BORN event.  Ignore\n \t\t BORN events for an already-known LWP.  */\n-\t      if (!in_thread_list (wptid))\n+\t      if (!in_thread_list (this, wptid))\n \t\t{\n \t\t  if (debug_fbsd_lwp)\n \t\t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\t\"FLWP: adding thread for LWP %u\\n\",\n \t\t\t\t\tpl.pl_lwpid);\n-\t\t  add_thread (wptid);\n+\t\t  add_thread (this, wptid);\n \t\t}\n \t      ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n \t      return wptid;\n@@ -1474,7 +1475,7 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n #endif\n \n #ifdef USE_SIGTRAP_SIGINFO\n-\t  if (fbsd_handle_debug_trap (wptid, pl))\n+\t  if (fbsd_handle_debug_trap (this, wptid, pl))\n \t    return wptid;\n #endif\n \n@@ -1633,7 +1634,7 @@ void\n fbsd_nat_target::post_attach (int pid)\n {\n   fbsd_enable_proc_events (pid);\n-  fbsd_add_threads (pid);\n+  fbsd_add_threads (this, pid);\n }\n \n #ifdef PL_FLAG_EXEC"
    },
    {
      "sha": "9e5d23a4bc8def5dd4b7edd309bd123c807a7987",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -673,7 +673,8 @@ fbsd_corefile_thread (struct thread_info *info,\n {\n   struct regcache *regcache;\n \n-  regcache = get_thread_arch_regcache (info->ptid, args->gdbarch);\n+  regcache = get_thread_arch_regcache (info->inf->process_target (),\n+\t\t\t\t       info->ptid, args->gdbarch);\n \n   target_fetch_registers (regcache, -1);\n "
    },
    {
      "sha": "65a189e0487897fc67b3bc5bcff7a545a248398b",
      "filename": "gdb/fork-child.c",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/fork-child.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/fork-child.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fork-child.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -128,10 +128,13 @@ postfork_child_hook ()\n ptid_t\n gdb_startup_inferior (pid_t pid, int num_traps)\n {\n-  ptid_t ptid = startup_inferior (pid, num_traps, NULL, NULL);\n+  inferior *inf = current_inferior ();\n+  process_stratum_target *proc_target = inf->process_target ();\n+\n+  ptid_t ptid = startup_inferior (proc_target, pid, num_traps, NULL, NULL);\n \n   /* Mark all threads non-executing.  */\n-  set_executing (ptid, 0);\n+  set_executing (proc_target, ptid, 0);\n \n   return ptid;\n }"
    },
    {
      "sha": "b62ed4c02b47e8bcee507045e566419c571a4b3b",
      "filename": "gdb/gdbserver/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/ChangeLog?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1,3 +1,25 @@\n+2020-01-10  Pedro Alves  <palves@redhat.com>\n+\n+\t* fork-child.c (post_fork_inferior): Pass target down to\n+\tstartup_inferior.\n+\t* inferiors.c (switch_to_thread): Add process_stratum_target\n+\tparameter.\n+\t* lynx-low.c (lynx_target_ops): Now a process_stratum_target.\n+\t* nto-low.c (nto_target_ops): Now a process_stratum_target.\n+\t* linux-low.c (linux_target_ops): Now a process_stratum_target.\n+\t* remote-utils.c (prepare_resume_reply): Pass the target to\n+\tswitch_to_thread.\n+\t* target.c (the_target): Now a process_stratum_target.\n+\t(done_accessing_memory): Pass the target to switch_to_thread.\n+\t(set_target_ops): Ajust to use process_stratum_target.\n+\t* target.h (struct target_ops): Rename to ...\n+\t(struct process_stratum_target): ... this.\n+\t(the_target, set_target_ops): Adjust.\n+\t(prepare_to_access_memory): Adjust comment.\n+\t* win32-low.c (child_xfer_memory): Adjust to use\n+\tprocess_stratum_target.\n+\t(win32_target_ops): Now a process_stratum_target.\n+\n 2020-01-06  Eli Zaretskii  <eliz@gnu.org>\n \t    Pedro Alves  <palves@redhat.com>\n "
    },
    {
      "sha": "7a71ec0b1cafbc7dddaafb1cccd4d42e0ab8353f",
      "filename": "gdb/gdbserver/fork-child.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/fork-child.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/fork-child.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/fork-child.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -107,7 +107,8 @@ post_fork_inferior (int pid, const char *program)\n   atexit (restore_old_foreground_pgrp);\n #endif\n \n-  startup_inferior (pid, START_INFERIOR_TRAPS_EXPECTED,\n+  startup_inferior (the_target, pid,\n+\t\t    START_INFERIOR_TRAPS_EXPECTED,\n \t\t    &cs.last_status, &cs.last_ptid);\n   current_thread->last_resume_kind = resume_stop;\n   current_thread->last_status = cs.last_status;"
    },
    {
      "sha": "cf6e914863b69e79d8afc466b5f1e66502696ec3",
      "filename": "gdb/gdbserver/inferiors.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/inferiors.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/inferiors.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/inferiors.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -216,7 +216,7 @@ current_process (void)\n /* See gdbsupport/common-gdbthread.h.  */\n \n void\n-switch_to_thread (ptid_t ptid)\n+switch_to_thread (process_stratum_target *ops, ptid_t ptid)\n {\n   gdb_assert (ptid != minus_one_ptid);\n   current_thread = find_thread_ptid (ptid);"
    },
    {
      "sha": "676dea26c637afbd0a146f78810f20ccbda0b830",
      "filename": "gdb/gdbserver/linux-low.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/linux-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/linux-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-low.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -7354,7 +7354,7 @@ linux_get_hwcap2 (int wordsize)\n   return hwcap2;\n }\n \n-static struct target_ops linux_target_ops = {\n+static process_stratum_target linux_target_ops = {\n   linux_create_inferior,\n   linux_post_create_inferior,\n   linux_attach,"
    },
    {
      "sha": "a5b019396fa4f784ca54853ffdc1ce2e989e4ba5",
      "filename": "gdb/gdbserver/lynx-low.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/lynx-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/lynx-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/lynx-low.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -721,7 +721,7 @@ lynx_request_interrupt (void)\n \n /* The LynxOS target_ops vector.  */\n \n-static struct target_ops lynx_target_ops = {\n+static process_stratum_target lynx_target_ops = {\n   lynx_create_inferior,\n   NULL,  /* post_create_inferior */\n   lynx_attach,"
    },
    {
      "sha": "b4dea479b9c3a01d8ec08cbe612cff5dd37121dd",
      "filename": "gdb/gdbserver/nto-low.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/nto-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/nto-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/nto-low.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -931,7 +931,7 @@ nto_sw_breakpoint_from_kind (int kind, int *size)\n }\n \n \n-static struct target_ops nto_target_ops = {\n+static process_stratum_target nto_target_ops = {\n   nto_create_inferior,\n   NULL,  /* post_create_inferior */\n   nto_attach,"
    },
    {
      "sha": "b8a8c6576f974b57264d1f6f8c18de79a5b72cb8",
      "filename": "gdb/gdbserver/remote-utils.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/remote-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/remote-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/remote-utils.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1208,7 +1208,7 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n \n \tsaved_thread = current_thread;\n \n-\tswitch_to_thread (ptid);\n+\tswitch_to_thread (the_target, ptid);\n \n \tregp = current_target_desc ()->expedite_regs;\n "
    },
    {
      "sha": "a4593cf6df91c1f58951aa17b95d7ddbe0d55cbb",
      "filename": "gdb/gdbserver/target.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/target.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -22,7 +22,7 @@\n #include \"tracepoint.h\"\n #include \"gdbsupport/byte-vector.h\"\n \n-struct target_ops *the_target;\n+process_stratum_target *the_target;\n \n int\n set_desired_thread ()\n@@ -119,7 +119,7 @@ done_accessing_memory (void)\n \n   /* Restore the previous selected thread.  */\n   cs.general_thread = prev_general_thread;\n-  switch_to_thread (cs.general_thread);\n+  switch_to_thread (the_target, cs.general_thread);\n }\n \n int\n@@ -284,9 +284,9 @@ start_non_stop (int nonstop)\n }\n \n void\n-set_target_ops (struct target_ops *target)\n+set_target_ops (process_stratum_target *target)\n {\n-  the_target = XNEW (struct target_ops);\n+  the_target = XNEW (process_stratum_target);\n   memcpy (the_target, target, sizeof (*the_target));\n }\n "
    },
    {
      "sha": "1b0810ba04987e2522a00735833ee7c7e5d290bc",
      "filename": "gdb/gdbserver/target.h",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/target.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -63,7 +63,10 @@ struct thread_resume\n   CORE_ADDR step_range_end;\t/* Exclusive */\n };\n \n-struct target_ops\n+/* GDBserver doesn't have a concept of strata like GDB, but we call\n+   its target vector \"process_stratum\" anyway for the benefit of\n+   shared code.  */\n+struct process_stratum_target\n {\n   /* Start a new process.\n \n@@ -476,9 +479,9 @@ struct target_ops\n   bool (*thread_handle) (ptid_t ptid, gdb_byte **handle, int *handle_len);\n };\n \n-extern struct target_ops *the_target;\n+extern process_stratum_target *the_target;\n \n-void set_target_ops (struct target_ops *);\n+void set_target_ops (process_stratum_target *);\n \n #define create_inferior(program, program_args)\t\\\n   (*the_target->create_inferior) (program, program_args)\n@@ -702,7 +705,7 @@ ptid_t mywait (ptid_t ptid, struct target_waitstatus *ourstatus, int options,\n \t       int connected_wait);\n \n /* Prepare to read or write memory from the inferior process.  See the\n-   corresponding target_ops methods for more details.  */\n+   corresponding process_stratum_target methods for more details.  */\n \n int prepare_to_access_memory (void);\n void done_accessing_memory (void);"
    },
    {
      "sha": "2c4a9b1074b2f857d744b3831204604146395935",
      "filename": "gdb/gdbserver/win32-low.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/win32-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbserver/win32-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/win32-low.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -307,7 +307,7 @@ win32_stopped_data_address (void)\n /* Transfer memory from/to the debugged process.  */\n static int\n child_xfer_memory (CORE_ADDR memaddr, char *our, int len,\n-\t\t   int write, struct target_ops *target)\n+\t\t   int write, process_stratum_target *target)\n {\n   BOOL success;\n   SIZE_T done = 0;\n@@ -1795,7 +1795,7 @@ win32_sw_breakpoint_from_kind (int kind, int *size)\n   return the_low_target.breakpoint;\n }\n \n-static struct target_ops win32_target_ops = {\n+static process_stratum_target win32_target_ops = {\n   win32_create_inferior,\n   NULL,  /* post_create_inferior */\n   win32_attach,"
    },
    {
      "sha": "050ad80322b500321e5210cbb045225c661ad8e8",
      "filename": "gdb/gdbsupport/common-gdbthread.h",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbsupport/common-gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbsupport/common-gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbsupport/common-gdbthread.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -19,7 +19,10 @@\n #ifndef COMMON_COMMON_GDBTHREAD_H\n #define COMMON_COMMON_GDBTHREAD_H\n \n+struct process_stratum_target;\n+\n /* Switch from one thread to another.  */\n-extern void switch_to_thread (ptid_t ptid);\n+extern void switch_to_thread (process_stratum_target *proc_target,\n+\t\t\t      ptid_t ptid);\n \n #endif /* COMMON_COMMON_GDBTHREAD_H */"
    },
    {
      "sha": "f205e29dd7dd2f1e4957c2ae3473e15a770fa454",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 76,
      "deletions": 51,
      "changes": 127,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -34,6 +34,7 @@ struct symtab;\n #include \"gdbsupport/forward-scope-exit.h\"\n \n struct inferior;\n+struct process_stratum_target;\n \n /* Frontend view of the thread state.  Possible extensions: stepping,\n    finishing, until(ling),...\n@@ -304,7 +305,7 @@ class thread_info : public refcounted_object\n      from saying that there is an active target and we are stopped at\n      a breakpoint, for instance.  This is a real indicator whether the\n      thread is off and running.  */\n-  int executing = 0;\n+  bool executing = false;\n \n   /* Non-zero if this thread is resumed from infrun's perspective.\n      Note that a thread can be marked both as not-executing and\n@@ -419,15 +420,18 @@ extern void init_thread_list (void);\n    that a new thread is found, and return the pointer to\n    the new thread.  Caller my use this pointer to \n    initialize the private thread data.  */\n-extern struct thread_info *add_thread (ptid_t ptid);\n+extern struct thread_info *add_thread (process_stratum_target *targ,\n+\t\t\t\t       ptid_t ptid);\n \n-/* Same as add_thread, but does not print a message\n-   about new thread.  */\n-extern struct thread_info *add_thread_silent (ptid_t ptid);\n+/* Same as add_thread, but does not print a message about new\n+   thread.  */\n+extern struct thread_info *add_thread_silent (process_stratum_target *targ,\n+\t\t\t\t\t      ptid_t ptid);\n \n /* Same as add_thread, and sets the private info.  */\n-extern struct thread_info *add_thread_with_info (ptid_t ptid,\n-\t\t\t\t\t\t struct private_thread_info *);\n+extern struct thread_info *add_thread_with_info (process_stratum_target *targ,\n+\t\t\t\t\t\t ptid_t ptid,\n+\t\t\t\t\t\t private_thread_info *);\n \n /* Delete an existing thread list entry.  */\n extern void delete_thread (struct thread_info *thread);\n@@ -468,14 +472,18 @@ extern int show_inferior_qualified_tids (void);\n const char *print_thread_id (struct thread_info *thr);\n \n /* Boolean test for an already-known ptid.  */\n-extern int in_thread_list (ptid_t ptid);\n+extern bool in_thread_list (process_stratum_target *targ, ptid_t ptid);\n \n /* Boolean test for an already-known global thread id (GDB's homegrown\n    global id, not the system's).  */\n extern int valid_global_thread_id (int global_id);\n \n+/* Find thread PTID of inferior INF.  */\n+extern thread_info *find_thread_ptid (inferior *inf, ptid_t ptid);\n+\n /* Search function to lookup a thread by 'pid'.  */\n-extern struct thread_info *find_thread_ptid (ptid_t ptid);\n+extern struct thread_info *find_thread_ptid (process_stratum_target *targ,\n+\t\t\t\t\t     ptid_t ptid);\n \n /* Search function to lookup a thread by 'ptid'.  Only searches in\n    threads of INF.  */\n@@ -500,7 +508,8 @@ extern struct thread_info *any_thread_of_inferior (inferior *inf);\n extern struct thread_info *any_live_thread_of_inferior (inferior *inf);\n \n /* Change the ptid of thread OLD_PTID to NEW_PTID.  */\n-void thread_change_ptid (ptid_t old_ptid, ptid_t new_ptid);\n+void thread_change_ptid (process_stratum_target *targ,\n+\t\t\t ptid_t old_ptid, ptid_t new_ptid);\n \n /* Iterator function to call a user-provided callback function\n    once for each known thread.  */\n@@ -511,34 +520,44 @@ extern struct thread_info *iterate_over_threads (thread_callback_func, void *);\n    iterators.  Must be done after struct thread_info is defined.  */\n #include \"thread-iter.h\"\n \n-/* Return a range that can be used to walk over all threads of all\n-   inferiors, with range-for.  Used like this:\n+/* Return a range that can be used to walk over threads, with\n+   range-for.\n+\n+   Used like this, it walks over all threads of all inferiors of all\n+   targets:\n \n        for (thread_info *thr : all_threads ())\n \t { .... }\n-*/\n-inline all_threads_range\n-all_threads ()\n-{\n-  return {};\n-}\n \n-/* Likewise, but accept a filter PTID.  */\n+   FILTER_PTID can be used to filter out threads that don't match.\n+   FILTER_PTID can be:\n+\n+   - minus_one_ptid, meaning walk all threads of all inferiors of\n+     PROC_TARGET.  If PROC_TARGET is NULL, then of all targets.\n+\n+   - A process ptid, in which case walk all threads of the specified\n+     process.  PROC_TARGET must be non-NULL in this case.\n+\n+   - A thread ptid, in which case walk that thread only.  PROC_TARGET\n+     must be non-NULL in this case.\n+*/\n \n inline all_matching_threads_range\n-all_threads (ptid_t filter_ptid)\n+all_threads (process_stratum_target *proc_target = nullptr,\n+\t     ptid_t filter_ptid = minus_one_ptid)\n {\n-  return all_matching_threads_range (filter_ptid);\n+  return all_matching_threads_range (proc_target, filter_ptid);\n }\n \n /* Return a range that can be used to walk over all non-exited threads\n-   of all inferiors, with range-for.  FILTER_PTID can be used to\n-   filter out thread that don't match.  */\n+   of all inferiors, with range-for.  Arguments are like all_threads\n+   above.  */\n \n inline all_non_exited_threads_range\n-all_non_exited_threads (ptid_t filter_ptid = minus_one_ptid)\n+all_non_exited_threads (process_stratum_target *proc_target = nullptr,\n+\t\t\tptid_t filter_ptid = minus_one_ptid)\n {\n-  return all_non_exited_threads_range (filter_ptid);\n+  return all_non_exited_threads_range (proc_target, filter_ptid);\n }\n \n /* Return a range that can be used to walk over all threads of all\n@@ -554,10 +573,10 @@ all_non_exited_threads (ptid_t filter_ptid = minus_one_ptid)\n inline all_threads_safe_range\n all_threads_safe ()\n {\n-  return all_threads_safe_range ();\n+  return {};\n }\n \n-extern int thread_count (void);\n+extern int thread_count (process_stratum_target *proc_target);\n \n /* Return true if we have any thread in any inferior.  */\n extern bool any_thread_p ();\n@@ -571,44 +590,50 @@ extern void switch_to_no_thread ();\n /* Switch from one thread to another.  Does not read registers.  */\n extern void switch_to_thread_no_regs (struct thread_info *thread);\n \n-/* Marks or clears thread(s) PTID as resumed.  If PTID is\n-   MINUS_ONE_PTID, applies to all threads.  If ptid_is_pid(PTID) is\n-   true, applies to all threads of the process pointed at by PTID.  */\n-extern void set_resumed (ptid_t ptid, int resumed);\n-\n-/* Marks thread PTID is running, or stopped. \n-   If PTID is minus_one_ptid, marks all threads.  */\n-extern void set_running (ptid_t ptid, int running);\n-\n-/* Marks or clears thread(s) PTID as having been requested to stop.\n-   If PTID is MINUS_ONE_PTID, applies to all threads.  If\n+/* Marks or clears thread(s) PTID of TARG as resumed.  If PTID is\n+   MINUS_ONE_PTID, applies to all threads of TARG.  If\n    ptid_is_pid(PTID) is true, applies to all threads of the process\n-   pointed at by PTID.  If STOP, then the THREAD_STOP_REQUESTED\n-   observer is called with PTID as argument.  */\n-extern void set_stop_requested (ptid_t ptid, int stop);\n-\n-/* Marks thread PTID as executing, or not.  If PTID is minus_one_ptid,\n-   marks all threads.\n+   pointed at by {TARG,PTID}.  */\n+extern void set_resumed (process_stratum_target *targ,\n+\t\t\t ptid_t ptid, bool resumed);\n+\n+/* Marks thread PTID of TARG as running, or as stopped.  If PTID is\n+   minus_one_ptid, marks all threads of TARG.  */\n+extern void set_running (process_stratum_target *targ,\n+\t\t\t ptid_t ptid, bool running);\n+\n+/* Marks or clears thread(s) PTID of TARG as having been requested to\n+   stop.  If PTID is MINUS_ONE_PTID, applies to all threads of TARG.\n+   If ptid_is_pid(PTID) is true, applies to all threads of the process\n+   pointed at by {TARG, PTID}.  If STOP, then the\n+   THREAD_STOP_REQUESTED observer is called with PTID as argument.  */\n+extern void set_stop_requested (process_stratum_target *targ,\n+\t\t\t\tptid_t ptid, bool stop);\n+\n+/* Marks thread PTID of TARG as executing, or not.  If PTID is\n+   minus_one_ptid, marks all threads of TARG.\n \n    Note that this is different from the running state.  See the\n    description of state and executing fields of struct\n    thread_info.  */\n-extern void set_executing (ptid_t ptid, int executing);\n+extern void set_executing (process_stratum_target *targ,\n+\t\t\t   ptid_t ptid, bool executing);\n \n-/* True if any (known or unknown) thread is or may be executing.  */\n-extern int threads_are_executing (void);\n+/* True if any (known or unknown) thread of TARG is or may be\n+   executing.  */\n+extern bool threads_are_executing (process_stratum_target *targ);\n \n-/* Merge the executing property of thread PTID over to its thread\n-   state property (frontend running/stopped view).\n+/* Merge the executing property of thread PTID of TARG over to its\n+   thread state property (frontend running/stopped view).\n \n    \"not executing\" -> \"stopped\"\n    \"executing\"     -> \"running\"\n    \"exited\"        -> \"exited\"\n \n-   If PTID is minus_one_ptid, go over all threads.\n+   If PTID is minus_one_ptid, go over all threads of TARG.\n \n    Notifications are only emitted if the thread state did change.  */\n-extern void finish_thread_state (ptid_t ptid);\n+extern void finish_thread_state (process_stratum_target *targ, ptid_t ptid);\n \n /* Calls finish_thread_state on scope exit, unless release() is called\n    to disengage.  */"
    },
    {
      "sha": "d072709929067d7a0eb6875b54bcbe91f8778a80",
      "filename": "gdb/i386-fbsd-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/i386-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/i386-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-fbsd-tdep.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -30,6 +30,7 @@\n #include \"i387-tdep.h\"\n #include \"fbsd-tdep.h\"\n #include \"solib-svr4.h\"\n+#include \"inferior.h\"\n \n /* Support for signal handlers.  */\n \n@@ -332,7 +333,8 @@ i386fbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n   if (tdep->fsbase_regnum == -1)\n     error (_(\"Unable to fetch %%gsbase\"));\n \n-  regcache = get_thread_arch_regcache (ptid, gdbarch);\n+  regcache = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\t       ptid, gdbarch);\n \n   target_fetch_registers (regcache, tdep->fsbase_regnum + 1);\n "
    },
    {
      "sha": "32cd879de80b9bb87050fb6599f3822d179e3909",
      "filename": "gdb/i386-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/i386-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/i386-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-linux-nat.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -657,7 +657,7 @@ i386_linux_nat_target::low_resume (ptid_t ptid, int step, enum gdb_signal signal\n \n   if (step)\n     {\n-      struct regcache *regcache = get_thread_regcache (ptid);\n+      struct regcache *regcache = get_thread_regcache (this, ptid);\n       struct gdbarch *gdbarch = regcache->arch ();\n       enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n       ULONGEST pc;"
    },
    {
      "sha": "48330948895085e4ec8e82f35d77276c0457439a",
      "filename": "gdb/inf-child.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inf-child.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inf-child.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-child.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -206,7 +206,7 @@ inf_child_target::mourn_inferior ()\n void\n inf_child_target::maybe_unpush_target ()\n {\n-  if (!inf_child_explicitly_opened && !have_inferiors ())\n+  if (!inf_child_explicitly_opened)\n     unpush_target (this);\n }\n "
    },
    {
      "sha": "ecd82ada4ed3deaa5cfed5c575a51fdd830c338a",
      "filename": "gdb/inf-ptrace.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inf-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inf-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-ptrace.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -136,7 +136,7 @@ inf_ptrace_target::create_inferior (const char *exec_file,\n   /* We have something that executes now.  We'll be running through\n      the shell at this point (if startup-with-shell is true), but the\n      pid shouldn't change.  */\n-  add_thread_silent (ptid);\n+  add_thread_silent (this, ptid);\n \n   unpusher.release ();\n \n@@ -235,10 +235,10 @@ inf_ptrace_target::attach (const char *args, int from_tty)\n \n   /* Always add a main thread.  If some target extends the ptrace\n      target, it should decorate the ptid later with more info.  */\n-  thread_info *thr = add_thread_silent (inferior_ptid);\n+  thread_info *thr = add_thread_silent (this, inferior_ptid);\n   /* Don't consider the thread stopped until we've processed its\n      initial SIGSTOP stop.  */\n-  set_executing (thr->ptid, true);\n+  set_executing (this, thr->ptid, true);\n \n   unpusher.release ();\n }"
    },
    {
      "sha": "240644a4eef9cfcc909053c08a6a91dc21adf974",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -649,7 +649,8 @@ run_inferior_call (struct call_thread_fsm *sm,\n   if (!was_running\n       && call_thread_ptid == inferior_ptid\n       && stop_stack_dummy == STOP_STACK_DUMMY)\n-    finish_thread_state (user_visible_resume_ptid (0));\n+    finish_thread_state (call_thread->inf->process_target (),\n+\t\t\t user_visible_resume_ptid (0));\n \n   enable_watchpoints_after_interactive_call_stop ();\n "
    },
    {
      "sha": "2bf21e26f1924e0af1b3c94ff88e677a3be80909",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 78,
      "deletions": 34,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -645,10 +645,19 @@ run_command_1 (const char *args, int from_tty, enum run_how run_how)\n      events --- the frontend shouldn't see them as stopped.  In\n      all-stop, always finish the state of all threads, as we may be\n      resuming more than just the new process.  */\n-  ptid_t finish_ptid = (non_stop\n-\t\t\t? ptid_t (current_inferior ()->pid)\n-\t\t\t: minus_one_ptid);\n-  scoped_finish_thread_state finish_state (finish_ptid);\n+  process_stratum_target *finish_target;\n+  ptid_t finish_ptid;\n+  if (non_stop)\n+    {\n+      finish_target = current_inferior ()->process_target ();\n+      finish_ptid = ptid_t (current_inferior ()->pid);\n+    }\n+  else\n+    {\n+      finish_target = nullptr;\n+      finish_ptid = minus_one_ptid;\n+    }\n+  scoped_finish_thread_state finish_state (finish_target, finish_ptid);\n \n   /* Pass zero for FROM_TTY, because at this point the \"run\" command\n      has done its thing; now we are setting up the running program.  */\n@@ -718,6 +727,9 @@ proceed_thread_callback (struct thread_info *thread, void *arg)\n   if (thread->state != THREAD_STOPPED)\n     return 0;\n \n+  if (!thread->inf->has_execution ())\n+    return 0;\n+\n   switch_to_thread (thread);\n   clear_proceed_status (0);\n   proceed ((CORE_ADDR) -1, GDB_SIGNAL_DEFAULT);\n@@ -811,7 +823,7 @@ static void\n continue_command (const char *args, int from_tty)\n {\n   int async_exec;\n-  int all_threads = 0;\n+  bool all_threads_p = false;\n \n   ERROR_NO_INFERIOR;\n \n@@ -823,17 +835,17 @@ continue_command (const char *args, int from_tty)\n     {\n       if (startswith (args, \"-a\"))\n \t{\n-\t  all_threads = 1;\n+\t  all_threads_p = true;\n \t  args += sizeof (\"-a\") - 1;\n \t  if (*args == '\\0')\n \t    args = NULL;\n \t}\n     }\n \n-  if (!non_stop && all_threads)\n+  if (!non_stop && all_threads_p)\n     error (_(\"`-a' is meaningless in all-stop mode.\"));\n \n-  if (args != NULL && all_threads)\n+  if (args != NULL && all_threads_p)\n     error (_(\"Can't resume all threads and specify \"\n \t     \"proceed count simultaneously.\"));\n \n@@ -850,10 +862,11 @@ continue_command (const char *args, int from_tty)\n \ttp = inferior_thread ();\n       else\n \t{\n+\t  process_stratum_target *last_target;\n \t  ptid_t last_ptid;\n \n-\t  get_last_target_status (&last_ptid, nullptr);\n-\t  tp = find_thread_ptid (last_ptid);\n+\t  get_last_target_status (&last_target, &last_ptid, nullptr);\n+\t  tp = find_thread_ptid (last_target, last_ptid);\n \t}\n       if (tp != NULL)\n \tbs = tp->control.stop_bpstat;\n@@ -881,7 +894,7 @@ continue_command (const char *args, int from_tty)\n   ERROR_NO_INFERIOR;\n   ensure_not_tfind_mode ();\n \n-  if (!non_stop || !all_threads)\n+  if (!non_stop || !all_threads_p)\n     {\n       ensure_valid_thread ();\n       ensure_not_running ();\n@@ -892,7 +905,7 @@ continue_command (const char *args, int from_tty)\n   if (from_tty)\n     printf_filtered (_(\"Continuing.\\n\"));\n \n-  continue_1 (all_threads);\n+  continue_1 (all_threads_p);\n }\n \f\n /* Record the starting point of a \"step\" or \"next\" command.  */\n@@ -1112,7 +1125,7 @@ prepare_one_step (struct step_command_fsm *sm)\n \n \t      /* Pretend that we've ran.  */\n \t      resume_ptid = user_visible_resume_ptid (1);\n-\t      set_running (resume_ptid, 1);\n+\t      set_running (tp->inf->process_target (), resume_ptid, true);\n \n \t      step_into_inline_frame (tp);\n \n@@ -1316,10 +1329,14 @@ signal_command (const char *signum_exp, int from_tty)\n       /* This indicates what will be resumed.  Either a single thread,\n \t a whole process, or all threads of all processes.  */\n       ptid_t resume_ptid = user_visible_resume_ptid (0);\n+      process_stratum_target *resume_target\n+\t= user_visible_resume_target (resume_ptid);\n \n-      for (thread_info *tp : all_non_exited_threads (resume_ptid))\n+      thread_info *current = inferior_thread ();\n+\n+      for (thread_info *tp : all_non_exited_threads (resume_target, resume_ptid))\n \t{\n-\t  if (tp->ptid == inferior_ptid)\n+\t  if (tp == current)\n \t    continue;\n \n \t  if (tp->suspend.stop_signal != GDB_SIGNAL_0\n@@ -1982,6 +1999,7 @@ info_program_command (const char *args, int from_tty)\n   bpstat bs;\n   int num, stat;\n   ptid_t ptid;\n+  process_stratum_target *proc_target;\n \n   if (!target_has_execution)\n     {\n@@ -1990,14 +2008,17 @@ info_program_command (const char *args, int from_tty)\n     }\n \n   if (non_stop)\n-    ptid = inferior_ptid;\n+    {\n+      ptid = inferior_ptid;\n+      proc_target = current_inferior ()->process_target ();\n+    }\n   else\n-    get_last_target_status (&ptid, nullptr);\n+    get_last_target_status (&proc_target, &ptid, nullptr);\n \n   if (ptid == null_ptid || ptid == minus_one_ptid)\n     error (_(\"No selected thread.\"));\n \n-  thread_info *tp = find_thread_ptid (ptid);\n+  thread_info *tp = find_thread_ptid (proc_target, ptid);\n \n   if (tp->state == THREAD_EXITED)\n     error (_(\"Invalid selected thread.\"));\n@@ -2786,12 +2807,16 @@ attach_command (const char *args, int from_tty)\n       add_inferior_continuation (attach_command_continuation, a,\n \t\t\t\t attach_command_continuation_free_args);\n \n+      /* Let infrun consider waiting for events out of this\n+\t target.  */\n+      inferior->process_target ()->threads_executing = true;\n+\n       if (!target_is_async_p ())\n \tmark_infrun_async_event_handler ();\n       return;\n     }\n-\n-  attach_post_wait (args, from_tty, mode);\n+  else\n+    attach_post_wait (args, from_tty, mode);\n }\n \n /* We had just found out that the target was already attached to an\n@@ -2908,29 +2933,48 @@ disconnect_command (const char *args, int from_tty)\n     deprecated_detach_hook ();\n }\n \n-void \n-interrupt_target_1 (int all_threads)\n-{\n-  ptid_t ptid;\n-\n-  if (all_threads)\n-    ptid = minus_one_ptid;\n-  else\n-    ptid = inferior_ptid;\n+/* Stop PTID in the current target, and tag the PTID threads as having\n+   been explicitly requested to stop.  PTID can be a thread, a\n+   process, or minus_one_ptid, meaning all threads of all inferiors of\n+   the current target.  */\n \n-  if (non_stop)\n-    target_stop (ptid);\n-  else\n-    target_interrupt ();\n+static void\n+stop_current_target_threads_ns (ptid_t ptid)\n+{\n+  target_stop (ptid);\n \n   /* Tag the thread as having been explicitly requested to stop, so\n      other parts of gdb know not to resume this thread automatically,\n      if it was stopped due to an internal event.  Limit this to\n      non-stop mode, as when debugging a multi-threaded application in\n      all-stop mode, we will only get one stop event --- it's undefined\n      which thread will report the event.  */\n+  set_stop_requested (current_inferior ()->process_target (),\n+\t\t      ptid, 1);\n+}\n+\n+/* See inferior.h.  */\n+\n+void\n+interrupt_target_1 (bool all_threads)\n+{\n   if (non_stop)\n-    set_stop_requested (ptid, 1);\n+    {\n+      if (all_threads)\n+\t{\n+\t  scoped_restore_current_thread restore_thread;\n+\n+\t  for (inferior *inf : all_inferiors ())\n+\t    {\n+\t      switch_to_inferior_no_thread (inf);\n+\t      stop_current_target_threads_ns (minus_one_ptid);\n+\t    }\n+\t}\n+      else\n+\tstop_current_target_threads_ns (inferior_ptid);\n+    }\n+  else\n+    target_interrupt ();\n }\n \n /* interrupt [-a]"
    },
    {
      "sha": "8061dcca4efec016daa07b7a2064c523c48e0d19",
      "filename": "gdb/inferior-iter.h",
      "status": "modified",
      "additions": 72,
      "deletions": 8,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inferior-iter.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inferior-iter.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior-iter.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -36,18 +36,23 @@ class all_inferiors_iterator\n   typedef int difference_type;\n \n   /* Create an iterator pointing at HEAD.  */\n-  explicit all_inferiors_iterator (inferior *head)\n-    : m_inf (head)\n-  {}\n+  all_inferiors_iterator (process_stratum_target *proc_target, inferior *head)\n+    : m_proc_target (proc_target)\n+  {\n+    /* Advance M_INF to the first inferior's position.  */\n+    for (m_inf = head; m_inf != NULL; m_inf = m_inf->next)\n+      if (m_inf_matches ())\n+\treturn;\n+  }\n \n   /* Create a one-past-end iterator.  */\n   all_inferiors_iterator ()\n-    : m_inf (nullptr)\n+    : m_proc_target (nullptr), m_inf (nullptr)\n   {}\n \n   all_inferiors_iterator &operator++ ()\n   {\n-    m_inf = m_inf->next;\n+    advance ();\n     return *this;\n   }\n \n@@ -58,6 +63,30 @@ class all_inferiors_iterator\n   { return m_inf != other.m_inf; }\n \n private:\n+  /* Advance to next inferior, skipping filtered inferiors.  */\n+  void advance ()\n+  {\n+    /* The loop below is written in the natural way as-if we'd always\n+       start at the beginning of the inferior list.  This\n+       fast-forwards the algorithm to the actual current position.  */\n+    goto start;\n+\n+    while (m_inf != NULL)\n+      {\n+\tif (m_inf_matches ())\n+\t  return;\n+      start:\n+\tm_inf = m_inf->next;\n+      }\n+  }\n+\n+  bool m_inf_matches ()\n+  {\n+    return (m_proc_target == nullptr\n+\t    || m_proc_target == m_inf->process_target ());\n+  }\n+\n+  process_stratum_target *m_proc_target;\n   inferior *m_inf;\n };\n \n@@ -80,10 +109,17 @@ using all_non_exited_inferiors_iterator\n    inferiors with range-for.  */\n struct all_inferiors_range\n {\n+  all_inferiors_range (process_stratum_target *proc_target = nullptr)\n+    : m_filter_target (proc_target)\n+  {}\n+\n   all_inferiors_iterator begin () const\n-  { return all_inferiors_iterator (inferior_list); }\n+  { return all_inferiors_iterator (m_filter_target, inferior_list); }\n   all_inferiors_iterator end () const\n   { return all_inferiors_iterator (); }\n+\n+private:\n+  process_stratum_target *m_filter_target;\n };\n \n /* Iterate over all inferiors, safely.  */\n@@ -97,21 +133,49 @@ using all_inferiors_safe_iterator\n \n struct all_inferiors_safe_range\n {\n+  explicit all_inferiors_safe_range (process_stratum_target *filter_target)\n+    : m_filter_target (filter_target)\n+  {}\n+\n+  all_inferiors_safe_range ()\n+    : m_filter_target (nullptr)\n+  {}\n+\n   all_inferiors_safe_iterator begin () const\n-  { return all_inferiors_safe_iterator (inferior_list); }\n+  {\n+    return (all_inferiors_safe_iterator\n+\t    (all_inferiors_iterator (m_filter_target, inferior_list)));\n+  }\n+\n   all_inferiors_safe_iterator end () const\n   { return all_inferiors_safe_iterator (); }\n+\n+private:\n+  /* The filter.  */\n+  process_stratum_target *m_filter_target;\n };\n \n /* A range adapter that makes it possible to iterate over all\n    non-exited inferiors with range-for.  */\n \n struct all_non_exited_inferiors_range\n {\n+  explicit all_non_exited_inferiors_range (process_stratum_target *filter_target)\n+    : m_filter_target (filter_target)\n+  {}\n+\n+  all_non_exited_inferiors_range ()\n+    : m_filter_target (nullptr)\n+  {}\n+\n   all_non_exited_inferiors_iterator begin () const\n-  { return all_non_exited_inferiors_iterator (inferior_list); }\n+  { return all_non_exited_inferiors_iterator (m_filter_target, inferior_list); }\n   all_non_exited_inferiors_iterator end () const\n   { return all_non_exited_inferiors_iterator (); }\n+\n+private:\n+  /* The filter.  */\n+  process_stratum_target *m_filter_target;\n };\n \n #endif /* !defined (INFERIOR_ITER_H) */"
    },
    {
      "sha": "d732690a3cd66ca68af5ad2b30bee3b879c8ff12",
      "filename": "gdb/inferior.c",
      "status": "modified",
      "additions": 55,
      "deletions": 23,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -90,6 +90,8 @@ inferior::inferior (int pid_)\n     registry_data ()\n {\n   inferior_alloc_data (this);\n+\n+  m_target_stack.push (get_dummy_target ());\n }\n \n struct inferior *\n@@ -276,14 +278,14 @@ find_inferior_id (int num)\n }\n \n struct inferior *\n-find_inferior_pid (int pid)\n+find_inferior_pid (process_stratum_target *targ, int pid)\n {\n   /* Looking for inferior pid == 0 is always wrong, and indicative of\n      a bug somewhere else.  There may be more than one with pid == 0,\n      for instance.  */\n   gdb_assert (pid != 0);\n \n-  for (inferior *inf : all_inferiors ())\n+  for (inferior *inf : all_inferiors (targ))\n     if (inf->pid == pid)\n       return inf;\n \n@@ -293,9 +295,9 @@ find_inferior_pid (int pid)\n /* See inferior.h */\n \n struct inferior *\n-find_inferior_ptid (ptid_t ptid)\n+find_inferior_ptid (process_stratum_target *targ, ptid_t ptid)\n {\n-  return find_inferior_pid (ptid.pid ());\n+  return find_inferior_pid (targ, ptid.pid ());\n }\n \n /* See inferior.h.  */\n@@ -340,11 +342,11 @@ have_inferiors (void)\n    in the middle of a 'mourn' operation.  */\n \n int\n-number_of_live_inferiors (void)\n+number_of_live_inferiors (process_stratum_target *proc_target)\n {\n   int num_inf = 0;\n \n-  for (inferior *inf : all_non_exited_inferiors ())\n+  for (inferior *inf : all_non_exited_inferiors (proc_target))\n     if (inf->has_execution ())\n       for (thread_info *tp ATTRIBUTE_UNUSED : inf->non_exited_threads ())\n \t{\n@@ -362,7 +364,7 @@ number_of_live_inferiors (void)\n int\n have_live_inferiors (void)\n {\n-  return number_of_live_inferiors () > 0;\n+  return number_of_live_inferiors (NULL) > 0;\n }\n \n /* Prune away any unused inferiors, and then prune away no longer used\n@@ -694,14 +696,36 @@ add_inferior_with_spaces (void)\n   return inf;\n }\n \n-/* add-inferior [-copies N] [-exec FILENAME]  */\n+/* Switch to inferior NEW_INF, a new inferior, and unless\n+   NO_CONNECTION is true, push the process_stratum_target of ORG_INF\n+   to NEW_INF.  */\n+\n+static void\n+switch_to_inferior_and_push_target (inferior *new_inf,\n+\t\t\t\t    bool no_connection, inferior *org_inf)\n+{\n+  process_stratum_target *proc_target = org_inf->process_target ();\n+\n+  /* Switch over temporarily, while reading executable and\n+     symbols.  */\n+  switch_to_inferior_no_thread (new_inf);\n+\n+  /* Reuse the target for new inferior.  */\n+  if (!no_connection && proc_target != NULL)\n+    push_target (proc_target);\n+\n+  printf_filtered (_(\"Added inferior %d\\n\"), new_inf->num);\n+}\n+\n+/* add-inferior [-copies N] [-exec FILENAME] [-no-connection] */\n \n static void\n add_inferior_command (const char *args, int from_tty)\n {\n   int i, copies = 1;\n   gdb::unique_xmalloc_ptr<char> exec;\n   symfile_add_flags add_flags = 0;\n+  bool no_connection = false;\n \n   if (from_tty)\n     add_flags |= SYMFILE_VERBOSE;\n@@ -721,6 +745,8 @@ add_inferior_command (const char *args, int from_tty)\n \t\t    error (_(\"No argument to -copies\"));\n \t\t  copies = parse_and_eval_long (*argv);\n \t\t}\n+\t      else if (strcmp (*argv, \"-no-connection\") == 0)\n+\t\tno_connection = true;\n \t      else if (strcmp (*argv, \"-exec\") == 0)\n \t\t{\n \t\t  ++argv;\n@@ -734,32 +760,32 @@ add_inferior_command (const char *args, int from_tty)\n \t}\n     }\n \n+  inferior *orginf = current_inferior ();\n+\n   scoped_restore_current_pspace_and_thread restore_pspace_thread;\n \n   for (i = 0; i < copies; ++i)\n     {\n-      struct inferior *inf = add_inferior_with_spaces ();\n+      inferior *inf = add_inferior_with_spaces ();\n \n-      printf_filtered (_(\"Added inferior %d\\n\"), inf->num);\n+      switch_to_inferior_and_push_target (inf, no_connection, orginf);\n \n       if (exec != NULL)\n \t{\n-\t  /* Switch over temporarily, while reading executable and\n-\t     symbols.  */\n-\t  switch_to_inferior_no_thread (inf);\n \t  exec_file_attach (exec.get (), from_tty);\n \t  symbol_file_add_main (exec.get (), add_flags);\n \t}\n     }\n }\n \n-/* clone-inferior [-copies N] [ID] */\n+/* clone-inferior [-copies N] [ID] [-no-connection] */\n \n static void\n clone_inferior_command (const char *args, int from_tty)\n {\n   int i, copies = 1;\n   struct inferior *orginf = NULL;\n+  bool no_connection = false;\n \n   if (args)\n     {\n@@ -780,6 +806,8 @@ clone_inferior_command (const char *args, int from_tty)\n \t\t  if (copies < 0)\n \t\t    error (_(\"Invalid copies number\"));\n \t\t}\n+\t      else if (strcmp (*argv, \"-no-connection\") == 0)\n+\t\tno_connection = true;\n \t    }\n \t  else\n \t    {\n@@ -825,15 +853,13 @@ clone_inferior_command (const char *args, int from_tty)\n       inf->aspace = pspace->aspace;\n       inf->gdbarch = orginf->gdbarch;\n \n+      switch_to_inferior_and_push_target (inf, no_connection, orginf);\n+\n       /* If the original inferior had a user specified target\n \t description, make the clone use it too.  */\n       if (target_desc_info_from_user_p (inf->tdesc_info))\n \tcopy_inferior_target_desc_info (inf, orginf);\n \n-      printf_filtered (_(\"Added inferior %d.\\n\"), inf->num);\n-\n-      set_current_inferior (inf);\n-      switch_to_no_thread ();\n       clone_program_space (pspace, orginf->pspace);\n     }\n }\n@@ -894,10 +920,13 @@ By default all inferiors are displayed.\"));\n \n   c = add_com (\"add-inferior\", no_class, add_inferior_command, _(\"\\\n Add a new inferior.\\n\\\n-Usage: add-inferior [-copies N] [-exec FILENAME]\\n\\\n+Usage: add-inferior [-copies N] [-exec FILENAME] [-no-connection]\\n\\\n N is the optional number of inferiors to add, default is 1.\\n\\\n FILENAME is the file name of the executable to use\\n\\\n-as main program.\"));\n+as main program.\\n\\\n+By default, the new inferior inherits the current inferior's connection.\\n\\\n+If -no-connection is specified, the new inferior begins with\\n\\\n+no target connection yet.\"));\n   set_cmd_completer (c, filename_completer);\n \n   add_com (\"remove-inferiors\", no_class, remove_inferior_command, _(\"\\\n@@ -906,11 +935,14 @@ Usage: remove-inferiors ID...\"));\n \n   add_com (\"clone-inferior\", no_class, clone_inferior_command, _(\"\\\n Clone inferior ID.\\n\\\n-Usage: clone-inferior [-copies N] [ID]\\n\\\n-Add N copies of inferior ID.  The new inferior has the same\\n\\\n+Usage: clone-inferior [-copies N] [-no-connection] [ID]\\n\\\n+Add N copies of inferior ID.  The new inferiors have the same\\n\\\n executable loaded as the copied inferior.  If -copies is not specified,\\n\\\n adds 1 copy.  If ID is not specified, it is the current inferior\\n\\\n-that is cloned.\"));\n+that is cloned.\\n\\\n+By default, the new inferiors inherit the copied inferior's connection.\\n\\\n+If -no-connection is specified, the new inferiors begin with\\n\\\n+no target connection yet.\"));\n \n   add_cmd (\"inferiors\", class_run, detach_inferior_command, _(\"\\\n Detach from inferior ID (or list of IDS).\\n\\"
    },
    {
      "sha": "4229c6017d92eb9742ef83e1b83688ed6a9e6b30",
      "filename": "gdb/inferior.h",
      "status": "modified",
      "additions": 50,
      "deletions": 14,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inferior.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inferior.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -56,6 +56,8 @@ struct thread_info;\n #include \"gdbsupport/common-inferior.h\"\n #include \"gdbthread.h\"\n \n+#include \"process-stratum-target.h\"\n+\n struct infcall_suspend_state;\n struct infcall_control_state;\n \n@@ -206,7 +208,7 @@ extern void registers_info (const char *, int);\n \n extern void continue_1 (int all_threads);\n \n-extern void interrupt_target_1 (int all_threads);\n+extern void interrupt_target_1 (bool all_threads);\n \n using delete_longjmp_breakpoint_cleanup\n   = FORWARD_SCOPE_EXIT (delete_longjmp_breakpoint);\n@@ -343,6 +345,35 @@ class inferior : public refcounted_object\n   /* Returns true if we can delete this inferior.  */\n   bool deletable () const { return refcount () == 0; }\n \n+  /* Push T in this inferior's target stack.  */\n+  void push_target (struct target_ops *t)\n+  { m_target_stack.push (t); }\n+\n+  /* Unpush T from this inferior's target stack.  */\n+  int unpush_target (struct target_ops *t)\n+  { return m_target_stack.unpush (t); }\n+\n+  /* Returns true if T is pushed in this inferior's target stack.  */\n+  bool target_is_pushed (target_ops *t)\n+  { return m_target_stack.is_pushed (t); }\n+\n+  /* Find the target beneath T in this inferior's target stack.  */\n+  target_ops *find_target_beneath (const target_ops *t)\n+  { return m_target_stack.find_beneath (t); }\n+\n+  /* Return the target at the top of this inferior's target stack.  */\n+  target_ops *top_target ()\n+  { return m_target_stack.top (); }\n+\n+  /* Return the target at process_stratum level in this inferior's\n+     target stack.  */\n+  struct process_stratum_target *process_target ()\n+  { return (process_stratum_target *) m_target_stack.at (process_stratum); }\n+\n+  /* Return the target at STRATUM in this inferior's target stack.  */\n+  target_ops *target_at (enum strata stratum)\n+  { return m_target_stack.at (stratum); }\n+\n   bool has_execution ()\n   { return target_has_execution_1 (this); }\n \n@@ -507,6 +538,10 @@ class inferior : public refcounted_object\n \n   /* Per inferior data-pointers required by other GDB modules.  */\n   REGISTRY_FIELDS;\n+\n+private:\n+  /* The inferior's target stack.  */\n+  target_stack m_target_stack;\n };\n \n /* Keep a registry of per-inferior data-pointers required by other GDB\n@@ -537,14 +572,14 @@ extern void exit_inferior_num_silent (int num);\n \n extern void inferior_appeared (struct inferior *inf, int pid);\n \n-/* Get rid of all inferiors.  */\n-extern void discard_all_inferiors (void);\n+/* Search function to lookup an inferior of TARG by target 'pid'.  */\n+extern struct inferior *find_inferior_pid (process_stratum_target *targ,\n+\t\t\t\t\t   int pid);\n \n-/* Search function to lookup an inferior by target 'pid'.  */\n-extern struct inferior *find_inferior_pid (int pid);\n-\n-/* Search function to lookup an inferior whose pid is equal to 'ptid.pid'. */\n-extern struct inferior *find_inferior_ptid (ptid_t ptid);\n+/* Search function to lookup an inferior of TARG whose pid is equal to\n+   'ptid.pid'. */\n+extern struct inferior *find_inferior_ptid (process_stratum_target *targ,\n+\t\t\t\t\t    ptid_t ptid);\n \n /* Search function to lookup an inferior by GDB 'num'.  */\n extern struct inferior *find_inferior_id (int num);\n@@ -571,8 +606,9 @@ extern struct inferior *iterate_over_inferiors (int (*) (struct inferior *,\n /* Returns true if the inferior list is not empty.  */\n extern int have_inferiors (void);\n \n-/* Returns the number of live inferiors (real live processes).  */\n-extern int number_of_live_inferiors (void);\n+/* Returns the number of live inferiors running on PROC_TARGET (real\n+   live processes with execution).  */\n+extern int number_of_live_inferiors (process_stratum_target *proc_target);\n \n /* Returns true if there are any live inferiors in the inferior list\n    (not cores, not executables, real live processes).  */\n@@ -629,18 +665,18 @@ all_inferiors_safe ()\n */\n \n inline all_inferiors_range\n-all_inferiors ()\n+all_inferiors (process_stratum_target *proc_target = nullptr)\n {\n-  return {};\n+  return all_inferiors_range (proc_target);\n }\n \n /* Return a range that can be used to walk over all inferiors with PID\n    not zero, with range-for.  */\n \n inline all_non_exited_inferiors_range\n-all_non_exited_inferiors ()\n+all_non_exited_inferiors (process_stratum_target *proc_target = nullptr)\n {\n-  return {};\n+  return all_non_exited_inferiors_range (proc_target);\n }\n \n /* Prune away automatically added inferiors that aren't required"
    },
    {
      "sha": "707c053e3ff93a02377f31edcff0e28b23ff5170",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 452,
      "deletions": 145,
      "changes": 597,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -63,6 +63,8 @@\n #include \"arch-utils.h\"\n #include \"gdbsupport/scope-exit.h\"\n #include \"gdbsupport/forward-scope-exit.h\"\n+#include \"gdb_select.h\"\n+#include <unordered_map>\n \n /* Prototypes for local functions */\n \n@@ -88,6 +90,8 @@ static int maybe_software_singlestep (struct gdbarch *gdbarch, CORE_ADDR pc);\n \n static void resume (gdb_signal sig);\n \n+static void wait_for_inferior (inferior *inf);\n+\n /* Asynchronous signal handler registered as event loop source for\n    when we have pending events ready to be passed to the core.  */\n static struct async_event_handler *infrun_async_inferior_event_token;\n@@ -370,9 +374,10 @@ show_stop_on_solib_events (struct ui_file *file, int from_tty,\n \n static int stop_print_frame;\n \n-/* This is a cached copy of the pid/waitstatus of the last event\n-   returned by target_wait()/deprecated_target_wait_hook().  This\n-   information is returned by get_last_target_status().  */\n+/* This is a cached copy of the target/ptid/waitstatus of the last\n+   event returned by target_wait()/deprecated_target_wait_hook().\n+   This information is returned by get_last_target_status().  */\n+static process_stratum_target *target_last_proc_target;\n static ptid_t target_last_wait_ptid;\n static struct target_waitstatus target_last_waitstatus;\n \n@@ -478,10 +483,12 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \n \t  scoped_restore_current_pspace_and_thread restore_pspace_thread;\n \n-\t  inferior_ptid = child_ptid;\n-\t  add_thread_silent (inferior_ptid);\n \t  set_current_inferior (child_inf);\n+\t  switch_to_no_thread ();\n \t  child_inf->symfile_flags = SYMFILE_NO_READ;\n+\t  push_target (parent_inf->process_target ());\n+\t  add_thread_silent (child_inf->process_target (), child_ptid);\n+\t  inferior_ptid = child_ptid;\n \n \t  /* If this is a vfork child, then the address-space is\n \t     shared with the parent.  */\n@@ -490,6 +497,8 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t      child_inf->pspace = parent_inf->pspace;\n \t      child_inf->aspace = parent_inf->aspace;\n \n+\t      exec_on_vfork ();\n+\n \t      /* The parent will be frozen until the child is done\n \t\t with the shared region.  Keep track of the\n \t\t parent.  */\n@@ -565,52 +574,64 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \n       parent_pspace = parent_inf->pspace;\n \n-      /* If we're vforking, we want to hold on to the parent until the\n-\t child exits or execs.  At child exec or exit time we can\n-\t remove the old breakpoints from the parent and detach or\n-\t resume debugging it.  Otherwise, detach the parent now; we'll\n-\t want to reuse it's program/address spaces, but we can't set\n-\t them to the child before removing breakpoints from the\n-\t parent, otherwise, the breakpoints module could decide to\n-\t remove breakpoints from the wrong process (since they'd be\n-\t assigned to the same address space).  */\n+      process_stratum_target *target = parent_inf->process_target ();\n \n-      if (has_vforked)\n-\t{\n-\t  gdb_assert (child_inf->vfork_parent == NULL);\n-\t  gdb_assert (parent_inf->vfork_child == NULL);\n-\t  child_inf->vfork_parent = parent_inf;\n-\t  child_inf->pending_detach = 0;\n-\t  parent_inf->vfork_child = child_inf;\n-\t  parent_inf->pending_detach = detach_fork;\n-\t  parent_inf->waiting_for_vfork_done = 0;\n-\t}\n-      else if (detach_fork)\n-\t{\n-\t  if (print_inferior_events)\n-\t    {\n-\t      /* Ensure that we have a process ptid.  */\n-\t      ptid_t process_ptid = ptid_t (parent_ptid.pid ());\n+      {\n+\t/* Hold a strong reference to the target while (maybe)\n+\t   detaching the parent.  Otherwise detaching could close the\n+\t   target.  */\n+\tauto target_ref = target_ops_ref::new_reference (target);\n+\n+\t/* If we're vforking, we want to hold on to the parent until\n+\t   the child exits or execs.  At child exec or exit time we\n+\t   can remove the old breakpoints from the parent and detach\n+\t   or resume debugging it.  Otherwise, detach the parent now;\n+\t   we'll want to reuse it's program/address spaces, but we\n+\t   can't set them to the child before removing breakpoints\n+\t   from the parent, otherwise, the breakpoints module could\n+\t   decide to remove breakpoints from the wrong process (since\n+\t   they'd be assigned to the same address space).  */\n+\n+\tif (has_vforked)\n+\t  {\n+\t    gdb_assert (child_inf->vfork_parent == NULL);\n+\t    gdb_assert (parent_inf->vfork_child == NULL);\n+\t    child_inf->vfork_parent = parent_inf;\n+\t    child_inf->pending_detach = 0;\n+\t    parent_inf->vfork_child = child_inf;\n+\t    parent_inf->pending_detach = detach_fork;\n+\t    parent_inf->waiting_for_vfork_done = 0;\n+\t  }\n+\telse if (detach_fork)\n+\t  {\n+\t    if (print_inferior_events)\n+\t      {\n+\t\t/* Ensure that we have a process ptid.  */\n+\t\tptid_t process_ptid = ptid_t (parent_ptid.pid ());\n+\n+\t\ttarget_terminal::ours_for_output ();\n+\t\tfprintf_filtered (gdb_stdlog,\n+\t\t\t\t  _(\"[Detaching after fork from \"\n+\t\t\t\t    \"parent %s]\\n\"),\n+\t\t\t\t  target_pid_to_str (process_ptid).c_str ());\n+\t      }\n \n-\t      target_terminal::ours_for_output ();\n-\t      fprintf_filtered (gdb_stdlog,\n-\t\t\t\t_(\"[Detaching after fork from \"\n-\t\t\t\t  \"parent %s]\\n\"),\n-\t\t\t\ttarget_pid_to_str (process_ptid).c_str ());\n-\t    }\n+\t    target_detach (parent_inf, 0);\n+\t    parent_inf = NULL;\n+\t  }\n \n-\t  target_detach (parent_inf, 0);\n-\t}\n+\t/* Note that the detach above makes PARENT_INF dangling.  */\n \n-      /* Note that the detach above makes PARENT_INF dangling.  */\n+\t/* Add the child thread to the appropriate lists, and switch\n+\t   to this new thread, before cloning the program space, and\n+\t   informing the solib layer about this new process.  */\n \n-      /* Add the child thread to the appropriate lists, and switch to\n-\t this new thread, before cloning the program space, and\n-\t informing the solib layer about this new process.  */\n+\tset_current_inferior (child_inf);\n+\tpush_target (target);\n+      }\n \n+      add_thread_silent (target, child_ptid);\n       inferior_ptid = child_ptid;\n-      add_thread_silent (inferior_ptid);\n-      set_current_inferior (child_inf);\n \n       /* If this is a vfork child, then the address-space is shared\n \t with the parent.  If we detached from the parent, then we can\n@@ -619,6 +640,8 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t{\n \t  child_inf->pspace = parent_pspace;\n \t  child_inf->aspace = child_inf->pspace->aspace;\n+\n+\t  exec_on_vfork ();\n \t}\n       else\n \t{\n@@ -665,11 +688,12 @@ follow_fork (void)\n \n   if (!non_stop)\n     {\n+      process_stratum_target *wait_target;\n       ptid_t wait_ptid;\n       struct target_waitstatus wait_status;\n \n       /* Get the last target status returned by target_wait().  */\n-      get_last_target_status (&wait_ptid, &wait_status);\n+      get_last_target_status (&wait_target, &wait_ptid, &wait_status);\n \n       /* If not stopped at a fork event, then there's nothing else to\n \t do.  */\n@@ -680,14 +704,14 @@ follow_fork (void)\n       /* Check if we switched over from WAIT_PTID, since the event was\n \t reported.  */\n       if (wait_ptid != minus_one_ptid\n-\t  && inferior_ptid != wait_ptid)\n+\t  && (current_inferior ()->process_target () != wait_target\n+\t      || inferior_ptid != wait_ptid))\n \t{\n \t  /* We did.  Switch back to WAIT_PTID thread, to tell the\n \t     target to follow it (in either direction).  We'll\n \t     afterwards refuse to resume, and inform the user what\n \t     happened.  */\n-\t  thread_info *wait_thread\n-\t    = find_thread_ptid (wait_ptid);\n+\t  thread_info *wait_thread = find_thread_ptid (wait_target, wait_ptid);\n \t  switch_to_thread (wait_thread);\n \t  should_resume = 0;\n \t}\n@@ -733,6 +757,7 @@ follow_fork (void)\n \tparent = inferior_ptid;\n \tchild = tp->pending_follow.value.related_pid;\n \n+\tprocess_stratum_target *parent_targ = tp->inf->process_target ();\n \t/* Set up inferior(s) as specified by the caller, and tell the\n \t   target to do whatever is necessary to follow either parent\n \t   or child.  */\n@@ -748,7 +773,7 @@ follow_fork (void)\n \t       or another.  The previous selected thread may be gone\n \t       from the lists by now, but if it is still around, need\n \t       to clear the pending follow request.  */\n-\t    tp = find_thread_ptid (parent);\n+\t    tp = find_thread_ptid (parent_targ, parent);\n \t    if (tp)\n \t      tp->pending_follow.kind = TARGET_WAITKIND_SPURIOUS;\n \n@@ -759,7 +784,7 @@ follow_fork (void)\n \t    /* If we followed the child, switch to it...  */\n \t    if (follow_child)\n \t      {\n-\t\tthread_info *child_thr = find_thread_ptid (child);\n+\t\tthread_info *child_thr = find_thread_ptid (parent_targ, child);\n \t\tswitch_to_thread (child_thr);\n \n \t\t/* ... and preserve the stepping state, in case the\n@@ -1188,9 +1213,11 @@ follow_exec (ptid_t ptid, const char *exec_file_target)\n       inf->pid = pid;\n       target_follow_exec (inf, exec_file_target);\n \n-      set_current_inferior (inf);\n-      set_current_program_space (inf->pspace);\n-      add_thread (ptid);\n+      inferior *org_inferior = current_inferior ();\n+      switch_to_inferior_no_thread (inf);\n+      push_target (org_inferior->process_target ());\n+      thread_info *thr = add_thread (inf->process_target (), ptid);\n+      switch_to_thread (thr);\n     }\n   else\n     {\n@@ -1884,6 +1911,7 @@ displaced_step_fixup (thread_info *event_thread, enum gdb_signal signal)\n    discarded between events.  */\n struct execution_control_state\n {\n+  process_stratum_target *target;\n   ptid_t ptid;\n   /* The thread that got the event, if this was a thread event; NULL\n      otherwise.  */\n@@ -2140,6 +2168,16 @@ user_visible_resume_ptid (int step)\n   return resume_ptid;\n }\n \n+/* See infrun.h.  */\n+\n+process_stratum_target *\n+user_visible_resume_target (ptid_t resume_ptid)\n+{\n+  return (resume_ptid == minus_one_ptid && sched_multi\n+\t  ? NULL\n+\t  : current_inferior ()->process_target ());\n+}\n+\n /* Return a ptid representing the set of threads that we will resume,\n    in the perspective of the target, assuming run control handling\n    does not require leaving some threads stopped (e.g., stepping past\n@@ -2204,6 +2242,9 @@ do_target_resume (ptid_t resume_ptid, int step, enum gdb_signal sig)\n   target_resume (resume_ptid, step, sig);\n \n   target_commit_resume ();\n+\n+  if (target_can_async_p ())\n+    target_async (1);\n }\n \n /* Resume the inferior.  SIG is the signal to give the inferior\n@@ -2247,6 +2288,7 @@ resume_1 (enum gdb_signal sig)\n \t\t\t      currently_stepping (tp));\n \t}\n \n+      tp->inf->process_target ()->threads_executing = true;\n       tp->resumed = 1;\n \n       /* FIXME: What should we do if we are supposed to resume this\n@@ -2732,10 +2774,12 @@ clear_proceed_status (int step)\n   if (!non_stop && inferior_ptid != null_ptid)\n     {\n       ptid_t resume_ptid = user_visible_resume_ptid (step);\n+      process_stratum_target *resume_target\n+\t= user_visible_resume_target (resume_ptid);\n \n       /* In all-stop mode, delete the per-thread status of all threads\n \t we're about to resume, implicitly and explicitly.  */\n-      for (thread_info *tp : all_non_exited_threads (resume_ptid))\n+      for (thread_info *tp : all_non_exited_threads (resume_target, resume_ptid))\n \tclear_proceed_status_thread (tp);\n     }\n \n@@ -2812,6 +2856,31 @@ schedlock_applies (struct thread_info *tp)\n \t\t\t\t\t    execution_direction)));\n }\n \n+/* Calls target_commit_resume on all targets.  */\n+\n+static void\n+commit_resume_all_targets ()\n+{\n+  scoped_restore_current_thread restore_thread;\n+\n+  /* Map between process_target and a representative inferior.  This\n+     is to avoid committing a resume in the same target more than\n+     once.  Resumptions must be idempotent, so this is an\n+     optimization.  */\n+  std::unordered_map<process_stratum_target *, inferior *> conn_inf;\n+\n+  for (inferior *inf : all_non_exited_inferiors ())\n+    if (inf->has_execution ())\n+      conn_inf[inf->process_target ()] = inf;\n+\n+  for (const auto &ci : conn_inf)\n+    {\n+      inferior *inf = ci.second;\n+      switch_to_inferior_no_thread (inf);\n+      target_commit_resume ();\n+    }\n+}\n+\n /* Basic routine for continuing the program in various fashions.\n \n    ADDR is the address to resume at, or -1 for resume where stopped.\n@@ -2826,7 +2895,6 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n   struct regcache *regcache;\n   struct gdbarch *gdbarch;\n   CORE_ADDR pc;\n-  ptid_t resume_ptid;\n   struct execution_control_state ecss;\n   struct execution_control_state *ecs = &ecss;\n   int started;\n@@ -2858,6 +2926,11 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \n   gdb_assert (!thread_is_in_step_over_chain (cur_thr));\n \n+  ptid_t resume_ptid\n+    = user_visible_resume_ptid (cur_thr->control.stepping_command);\n+  process_stratum_target *resume_target\n+    = user_visible_resume_target (resume_ptid);\n+\n   if (addr == (CORE_ADDR) -1)\n     {\n       if (pc == cur_thr->suspend.stop_pc\n@@ -2887,12 +2960,10 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n   if (siggnal != GDB_SIGNAL_DEFAULT)\n     cur_thr->suspend.stop_signal = siggnal;\n \n-  resume_ptid = user_visible_resume_ptid (cur_thr->control.stepping_command);\n-\n   /* If an exception is thrown from this point on, make sure to\n      propagate GDB's knowledge of the executing state to the\n      frontend/user running state.  */\n-  scoped_finish_thread_state finish_state (resume_ptid);\n+  scoped_finish_thread_state finish_state (resume_target, resume_ptid);\n \n   /* Even if RESUME_PTID is a wildcard, and we end up resuming fewer\n      threads (e.g., we might need to set threads stepping over\n@@ -2901,7 +2972,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n      inferior function, as in that case we pretend the inferior\n      doesn't run at all.  */\n   if (!cur_thr->control.in_infcall)\n-   set_running (resume_ptid, 1);\n+    set_running (resume_target, resume_ptid, 1);\n \n   if (debug_infrun)\n     fprintf_unfiltered (gdb_stdlog,\n@@ -2936,7 +3007,8 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n      threads.  */\n   if (!non_stop && !schedlock_applies (cur_thr))\n     {\n-      for (thread_info *tp : all_non_exited_threads (resume_ptid))\n+      for (thread_info *tp : all_non_exited_threads (resume_target,\n+\t\t\t\t\t\t     resume_ptid))\n \t{\n \t  switch_to_thread_no_regs (tp);\n \n@@ -2993,9 +3065,20 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n       {\n \t/* In all-stop, but the target is always in non-stop mode.\n \t   Start all other threads that are implicitly resumed too.  */\n-      for (thread_info *tp : all_non_exited_threads (resume_ptid))\n-        {\n-\t  switch_to_thread_no_regs (tp);\n+\tfor (thread_info *tp : all_non_exited_threads (resume_target,\n+\t\t\t\t\t\t       resume_ptid))\n+\t  {\n+\t    switch_to_thread_no_regs (tp);\n+\n+\t  if (!tp->inf->has_execution ())\n+\t    {\n+\t      if (debug_infrun)\n+\t\tfprintf_unfiltered (gdb_stdlog,\n+\t\t\t\t    \"infrun: proceed: [%s] target has \"\n+\t\t\t\t    \"no execution\\n\",\n+\t\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n+\t      continue;\n+\t    }\n \n \t  if (tp->resumed)\n \t    {\n@@ -3039,7 +3122,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n       }\n   }\n \n-  target_commit_resume ();\n+  commit_resume_all_targets ();\n \n   finish_state.release ();\n \n@@ -3061,10 +3144,8 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n void\n start_remote (int from_tty)\n {\n-  struct inferior *inferior;\n-\n-  inferior = current_inferior ();\n-  inferior->control.stop_soon = STOP_QUIETLY_REMOTE;\n+  inferior *inf = current_inferior ();\n+  inf->control.stop_soon = STOP_QUIETLY_REMOTE;\n \n   /* Always go on waiting for the target, regardless of the mode.  */\n   /* FIXME: cagney/1999-09-23: At present it isn't possible to\n@@ -3080,7 +3161,7 @@ start_remote (int from_tty)\n      target_open() return to the caller an indication that the target\n      is currently running and GDB state should be set to the same as\n      for an async run.  */\n-  wait_for_inferior ();\n+  wait_for_inferior (inf);\n \n   /* Now that the inferior has stopped, do any bookkeeping like\n      loading shared libraries.  We want to do this before normal_stop,\n@@ -3131,11 +3212,13 @@ static int switch_back_to_stepped_thread (struct execution_control_state *ecs);\n static void\n infrun_thread_stop_requested (ptid_t ptid)\n {\n+  process_stratum_target *curr_target = current_inferior ()->process_target ();\n+\n   /* PTID was requested to stop.  If the thread was already stopped,\n      but the user/frontend doesn't know about that yet (e.g., the\n      thread had been temporarily paused for some step-over), set up\n      for reporting the stop now.  */\n-  for (thread_info *tp : all_threads (ptid))\n+  for (thread_info *tp : all_threads (curr_target, ptid))\n     {\n       if (tp->state != THREAD_RUNNING)\n \tcontinue;\n@@ -3161,7 +3244,7 @@ infrun_thread_stop_requested (ptid_t ptid)\n \n       /* Clear the inline-frame state, since we're re-processing the\n \t stop.  */\n-      clear_inline_frame_state (tp->ptid);\n+      clear_inline_frame_state (tp);\n \n       /* If this thread was paused because some other thread was\n \t doing an inline-step over, let that finish first.  Once\n@@ -3180,7 +3263,8 @@ infrun_thread_stop_requested (ptid_t ptid)\n static void\n infrun_thread_thread_exit (struct thread_info *tp, int silent)\n {\n-  if (target_last_wait_ptid == tp->ptid)\n+  if (target_last_proc_target == tp->inf->process_target ()\n+      && target_last_wait_ptid == tp->ptid)\n     nullify_last_target_wait_ptid ();\n }\n \n@@ -3276,19 +3360,20 @@ print_target_wait_results (ptid_t waiton_ptid, ptid_t result_ptid,\n    had events.  */\n \n static struct thread_info *\n-random_pending_event_thread (ptid_t waiton_ptid)\n+random_pending_event_thread (inferior *inf, ptid_t waiton_ptid)\n {\n   int num_events = 0;\n \n-  auto has_event = [] (thread_info *tp)\n+  auto has_event = [&] (thread_info *tp)\n     {\n-      return (tp->resumed\n+      return (tp->ptid.matches (waiton_ptid)\n+\t      && tp->resumed\n \t      && tp->suspend.waitstatus_pending_p);\n     };\n \n   /* First see how many events we have.  Count only resumed threads\n      that have an event pending.  */\n-  for (thread_info *tp : all_non_exited_threads (waiton_ptid))\n+  for (thread_info *tp : inf->non_exited_threads ())\n     if (has_event (tp))\n       num_events++;\n \n@@ -3305,7 +3390,7 @@ random_pending_event_thread (ptid_t waiton_ptid)\n \t\t\tnum_events, random_selector);\n \n   /* Select the Nth thread that has had an event.  */\n-  for (thread_info *tp : all_non_exited_threads (waiton_ptid))\n+  for (thread_info *tp : inf->non_exited_threads ())\n     if (has_event (tp))\n       if (random_selector-- == 0)\n \treturn tp;\n@@ -3315,10 +3400,12 @@ random_pending_event_thread (ptid_t waiton_ptid)\n \n /* Wrapper for target_wait that first checks whether threads have\n    pending statuses to report before actually asking the target for\n-   more events.  */\n+   more events.  INF is the inferior we're using to call target_wait\n+   on.  */\n \n static ptid_t\n-do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n+do_target_wait_1 (inferior *inf, ptid_t ptid,\n+\t\t  target_waitstatus *status, int options)\n {\n   ptid_t event_ptid;\n   struct thread_info *tp;\n@@ -3327,7 +3414,7 @@ do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n      pending.  */\n   if (ptid == minus_one_ptid || ptid.is_pid ())\n     {\n-      tp = random_pending_event_thread (ptid);\n+      tp = random_pending_event_thread (inf, ptid);\n     }\n   else\n     {\n@@ -3337,7 +3424,7 @@ do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n \t\t\t    target_pid_to_str (ptid).c_str ());\n \n       /* We have a specific thread to check.  */\n-      tp = find_thread_ptid (ptid);\n+      tp = find_thread_ptid (inf, ptid);\n       gdb_assert (tp != NULL);\n       if (!tp->suspend.waitstatus_pending_p)\n \ttp = NULL;\n@@ -3444,6 +3531,109 @@ do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n   return event_ptid;\n }\n \n+/* Returns true if INF has any resumed thread with a status\n+   pending.  */\n+\n+static bool\n+threads_are_resumed_pending_p (inferior *inf)\n+{\n+  for (thread_info *tp : inf->non_exited_threads ())\n+    if (tp->resumed\n+\t&& tp->suspend.waitstatus_pending_p)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Wrapper for target_wait that first checks whether threads have\n+   pending statuses to report before actually asking the target for\n+   more events. Polls for events from all inferiors/targets.  */\n+\n+static bool\n+do_target_wait (ptid_t wait_ptid, execution_control_state *ecs, int options)\n+{\n+  int num_inferiors = 0;\n+  int random_selector;\n+\n+  /* For fairness, we pick the first inferior/target to poll at\n+     random, and then continue polling the rest of the inferior list\n+     starting from that one in a circular fashion until the whole list\n+     is polled once.  */\n+\n+  auto inferior_matches = [&wait_ptid] (inferior *inf)\n+    {\n+      return (inf->process_target () != NULL\n+\t      && (threads_are_executing (inf->process_target ())\n+\t\t  || threads_are_resumed_pending_p (inf))\n+\t      && ptid_t (inf->pid).matches (wait_ptid));\n+    };\n+\n+  /* First see how many resumed inferiors we have.  */\n+  for (inferior *inf : all_inferiors ())\n+    if (inferior_matches (inf))\n+      num_inferiors++;\n+\n+  if (num_inferiors == 0)\n+    {\n+      ecs->ws.kind = TARGET_WAITKIND_IGNORE;\n+      return false;\n+    }\n+\n+  /* Now randomly pick an inferior out of those that were resumed.  */\n+  random_selector = (int)\n+    ((num_inferiors * (double) rand ()) / (RAND_MAX + 1.0));\n+\n+  if (debug_infrun && num_inferiors > 1)\n+    fprintf_unfiltered (gdb_stdlog,\n+\t\t\t\"infrun: Found %d inferiors, starting at #%d\\n\",\n+\t\t\tnum_inferiors, random_selector);\n+\n+  /* Select the Nth inferior that was resumed.  */\n+\n+  inferior *selected = nullptr;\n+\n+  for (inferior *inf : all_inferiors ())\n+    if (inferior_matches (inf))\n+      if (random_selector-- == 0)\n+\t{\n+\t  selected = inf;\n+\t  break;\n+\t}\n+\n+  /* Now poll for events out of each of the resumed inferior's\n+     targets, starting from the selected one.  */\n+\n+  auto do_wait = [&] (inferior *inf)\n+  {\n+    switch_to_inferior_no_thread (inf);\n+\n+    ecs->ptid = do_target_wait_1 (inf, wait_ptid, &ecs->ws, options);\n+    ecs->target = inf->process_target ();\n+    return (ecs->ws.kind != TARGET_WAITKIND_IGNORE);\n+  };\n+\n+  /* Needed in all-stop+target-non-stop mode, because we end up here\n+     spuriously after the target is all stopped and we've already\n+     reported the stop to the user, polling for events.  */\n+  scoped_restore_current_thread restore_thread;\n+\n+  int inf_num = selected->num;\n+  for (inferior *inf = selected; inf != NULL; inf = inf->next)\n+    if (inferior_matches (inf))\n+      if (do_wait (inf))\n+\treturn true;\n+\n+  for (inferior *inf = inferior_list;\n+       inf != NULL && inf->num < inf_num;\n+       inf = inf->next)\n+    if (inferior_matches (inf))\n+      if (do_wait (inf))\n+\treturn true;\n+\n+  ecs->ws.kind = TARGET_WAITKIND_IGNORE;\n+  return false;\n+}\n+\n /* Prepare and stabilize the inferior for detaching it.  E.g.,\n    detaching while a thread is displaced stepping is a recipe for\n    crashing it, as nothing would readjust the PC out of the scratch\n@@ -3483,15 +3673,16 @@ prepare_for_detach (void)\n \t don't get any event.  */\n       target_dcache_invalidate ();\n \n-      ecs->ptid = do_target_wait (pid_ptid, &ecs->ws, 0);\n+      do_target_wait (pid_ptid, ecs, 0);\n \n       if (debug_infrun)\n \tprint_target_wait_results (pid_ptid, ecs->ptid, &ecs->ws);\n \n       /* If an error happens while handling the event, propagate GDB's\n \t knowledge of the executing state to the frontend/user running\n \t state.  */\n-      scoped_finish_thread_state finish_state (minus_one_ptid);\n+      scoped_finish_thread_state finish_state (inf->process_target (),\n+\t\t\t\t\t       minus_one_ptid);\n \n       /* Now figure out what to do with the result of the result.  */\n       handle_inferior_event (ecs);\n@@ -3519,8 +3710,8 @@ prepare_for_detach (void)\n    When this function actually returns it means the inferior\n    should be left stopped and GDB should read more commands.  */\n \n-void\n-wait_for_inferior (void)\n+static void\n+wait_for_inferior (inferior *inf)\n {\n   if (debug_infrun)\n     fprintf_unfiltered\n@@ -3531,13 +3722,13 @@ wait_for_inferior (void)\n   /* If an error happens while handling the event, propagate GDB's\n      knowledge of the executing state to the frontend/user running\n      state.  */\n-  scoped_finish_thread_state finish_state (minus_one_ptid);\n+  scoped_finish_thread_state finish_state\n+    (inf->process_target (), minus_one_ptid);\n \n   while (1)\n     {\n       struct execution_control_state ecss;\n       struct execution_control_state *ecs = &ecss;\n-      ptid_t waiton_ptid = minus_one_ptid;\n \n       memset (ecs, 0, sizeof (*ecs));\n \n@@ -3549,10 +3740,11 @@ wait_for_inferior (void)\n \t don't get any event.  */\n       target_dcache_invalidate ();\n \n-      ecs->ptid = do_target_wait (waiton_ptid, &ecs->ws, 0);\n+      ecs->ptid = do_target_wait_1 (inf, minus_one_ptid, &ecs->ws, 0);\n+      ecs->target = inf->process_target ();\n \n       if (debug_infrun)\n-\tprint_target_wait_results (waiton_ptid, ecs->ptid, &ecs->ws);\n+\tprint_target_wait_results (minus_one_ptid, ecs->ptid, &ecs->ws);\n \n       /* Now figure out what to do with the result of the result.  */\n       handle_inferior_event (ecs);\n@@ -3678,7 +3870,6 @@ fetch_inferior_event (void *client_data)\n   struct execution_control_state ecss;\n   struct execution_control_state *ecs = &ecss;\n   int cmd_done = 0;\n-  ptid_t waiton_ptid = minus_one_ptid;\n \n   memset (ecs, 0, sizeof (*ecs));\n \n@@ -3719,17 +3910,28 @@ fetch_inferior_event (void *client_data)\n       = make_scoped_restore (&execution_direction,\n \t\t\t     target_execution_direction ());\n \n-    ecs->ptid = do_target_wait (waiton_ptid, &ecs->ws,\n-\t\t\t\ttarget_can_async_p () ? TARGET_WNOHANG : 0);\n+    if (!do_target_wait (minus_one_ptid, ecs, TARGET_WNOHANG))\n+      return;\n+\n+    gdb_assert (ecs->ws.kind != TARGET_WAITKIND_IGNORE);\n+\n+    /* Switch to the target that generated the event, so we can do\n+       target calls.  Any inferior bound to the target will do, so we\n+       just switch to the first we find.  */\n+    for (inferior *inf : all_inferiors (ecs->target))\n+      {\n+\tswitch_to_inferior_no_thread (inf);\n+\tbreak;\n+      }\n \n     if (debug_infrun)\n-      print_target_wait_results (waiton_ptid, ecs->ptid, &ecs->ws);\n+      print_target_wait_results (minus_one_ptid, ecs->ptid, &ecs->ws);\n \n     /* If an error happens while handling the event, propagate GDB's\n        knowledge of the executing state to the frontend/user running\n        state.  */\n     ptid_t finish_ptid = !target_is_non_stop_p () ? minus_one_ptid : ecs->ptid;\n-    scoped_finish_thread_state finish_state (finish_ptid);\n+    scoped_finish_thread_state finish_state (ecs->target, finish_ptid);\n \n     /* Get executed before scoped_restore_current_thread above to apply\n        still for the thread which has thrown the exception.  */\n@@ -3743,7 +3945,7 @@ fetch_inferior_event (void *client_data)\n \n     if (!ecs->wait_some_more)\n       {\n-\tstruct inferior *inf = find_inferior_ptid (ecs->ptid);\n+\tstruct inferior *inf = find_inferior_ptid (ecs->target, ecs->ptid);\n \tint should_stop = 1;\n \tstruct thread_info *thr = ecs->event_thread;\n \n@@ -3848,17 +4050,22 @@ init_thread_stepping_state (struct thread_info *tss)\n /* See infrun.h.  */\n \n void\n-set_last_target_status (ptid_t ptid, struct target_waitstatus status)\n+set_last_target_status (process_stratum_target *target, ptid_t ptid,\n+\t\t\ttarget_waitstatus status)\n {\n+  target_last_proc_target = target;\n   target_last_wait_ptid = ptid;\n   target_last_waitstatus = status;\n }\n \n /* See infrun.h.  */\n \n void\n-get_last_target_status (ptid_t *ptid, struct target_waitstatus *status)\n+get_last_target_status (process_stratum_target **target, ptid_t *ptid,\n+\t\t\ttarget_waitstatus *status)\n {\n+  if (target != nullptr)\n+    *target = target_last_proc_target;\n   if (ptid != nullptr)\n     *ptid = target_last_wait_ptid;\n   if (status != nullptr)\n@@ -3870,6 +4077,7 @@ get_last_target_status (ptid_t *ptid, struct target_waitstatus *status)\n void\n nullify_last_target_wait_ptid (void)\n {\n+  target_last_proc_target = nullptr;\n   target_last_wait_ptid = minus_one_ptid;\n   target_last_waitstatus = {};\n }\n@@ -3881,7 +4089,8 @@ context_switch (execution_control_state *ecs)\n {\n   if (debug_infrun\n       && ecs->ptid != inferior_ptid\n-      && ecs->event_thread != inferior_thread ())\n+      && (inferior_ptid == null_ptid\n+\t  || ecs->event_thread != inferior_thread ()))\n     {\n       fprintf_unfiltered (gdb_stdlog, \"infrun: Switching context from %s \",\n \t\t\t  target_pid_to_str (inferior_ptid).c_str ());\n@@ -4206,20 +4415,19 @@ fill_in_stop_func (struct gdbarch *gdbarch,\n static enum stop_kind\n get_inferior_stop_soon (execution_control_state *ecs)\n {\n-  struct inferior *inf = find_inferior_ptid (ecs->ptid);\n+  struct inferior *inf = find_inferior_ptid (ecs->target, ecs->ptid);\n \n   gdb_assert (inf != NULL);\n   return inf->control.stop_soon;\n }\n \n-/* Wait for one event.  Store the resulting waitstatus in WS, and\n-   return the event ptid.  */\n+/* Poll for one event out of the current target.  Store the resulting\n+   waitstatus in WS, and return the event ptid.  Does not block.  */\n \n static ptid_t\n-wait_one (struct target_waitstatus *ws)\n+poll_one_curr_target (struct target_waitstatus *ws)\n {\n   ptid_t event_ptid;\n-  ptid_t wait_ptid = minus_one_ptid;\n \n   overlay_cache_invalid = 1;\n \n@@ -4230,16 +4438,101 @@ wait_one (struct target_waitstatus *ws)\n   target_dcache_invalidate ();\n \n   if (deprecated_target_wait_hook)\n-    event_ptid = deprecated_target_wait_hook (wait_ptid, ws, 0);\n+    event_ptid = deprecated_target_wait_hook (minus_one_ptid, ws, TARGET_WNOHANG);\n   else\n-    event_ptid = target_wait (wait_ptid, ws, 0);\n+    event_ptid = target_wait (minus_one_ptid, ws, TARGET_WNOHANG);\n \n   if (debug_infrun)\n-    print_target_wait_results (wait_ptid, event_ptid, ws);\n+    print_target_wait_results (minus_one_ptid, event_ptid, ws);\n \n   return event_ptid;\n }\n \n+/* An event reported by wait_one.  */\n+\n+struct wait_one_event\n+{\n+  /* The target the event came out of.  */\n+  process_stratum_target *target;\n+\n+  /* The PTID the event was for.  */\n+  ptid_t ptid;\n+\n+  /* The waitstatus.  */\n+  target_waitstatus ws;\n+};\n+\n+/* Wait for one event out of any target.  */\n+\n+static wait_one_event\n+wait_one ()\n+{\n+  while (1)\n+    {\n+      for (inferior *inf : all_inferiors ())\n+\t{\n+\t  process_stratum_target *target = inf->process_target ();\n+\t  if (target == NULL\n+\t      || !target->is_async_p ()\n+\t      || !target->threads_executing)\n+\t    continue;\n+\n+\t  switch_to_inferior_no_thread (inf);\n+\n+\t  wait_one_event event;\n+\t  event.target = target;\n+\t  event.ptid = poll_one_curr_target (&event.ws);\n+\n+\t  if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED)\n+\t    {\n+\t      /* If nothing is resumed, remove the target from the\n+\t\t event loop.  */\n+\t      target_async (0);\n+\t    }\n+\t  else if (event.ws.kind != TARGET_WAITKIND_IGNORE)\n+\t    return event;\n+\t}\n+\n+      /* Block waiting for some event.  */\n+\n+      fd_set readfds;\n+      int nfds = 0;\n+\n+      FD_ZERO (&readfds);\n+\n+      for (inferior *inf : all_inferiors ())\n+\t{\n+\t  process_stratum_target *target = inf->process_target ();\n+\t  if (target == NULL\n+\t      || !target->is_async_p ()\n+\t      || !target->threads_executing)\n+\t    continue;\n+\n+\t  int fd = target->async_wait_fd ();\n+\t  FD_SET (fd, &readfds);\n+\t  if (nfds <= fd)\n+\t    nfds = fd + 1;\n+\t}\n+\n+      if (nfds == 0)\n+\t{\n+\t  /* No waitable targets left.  All must be stopped.  */\n+\t  return {NULL, minus_one_ptid, {TARGET_WAITKIND_NO_RESUMED}};\n+\t}\n+\n+      QUIT;\n+\n+      int numfds = interruptible_select (nfds, &readfds, 0, NULL, 0);\n+      if (numfds < 0)\n+\t{\n+\t  if (errno == EINTR)\n+\t    continue;\n+\t  else\n+\t    perror_with_name (\"interruptible_select\");\n+\t}\n+    }\n+}\n+\n /* Generate a wrapper for target_stopped_by_REASON that works on PTID\n    instead of the current thread.  */\n #define THREAD_STOPPED_BY(REASON)\t\t\\\n@@ -4262,7 +4555,7 @@ THREAD_STOPPED_BY (hw_breakpoint)\n /* Save the thread's event and stop reason to process it later.  */\n \n static void\n-save_waitstatus (struct thread_info *tp, struct target_waitstatus *ws)\n+save_waitstatus (struct thread_info *tp, const target_waitstatus *ws)\n {\n   if (debug_infrun)\n     {\n@@ -4362,8 +4655,6 @@ stop_all_threads (void)\n \t\t\t    \"iterations=%d\\n\", pass, iterations);\n       while (1)\n \t{\n-\t  ptid_t event_ptid;\n-\t  struct target_waitstatus ws;\n \t  int need_wait = 0;\n \n \t  update_thread_list ();\n@@ -4421,28 +4712,29 @@ stop_all_threads (void)\n \t  if (pass > 0)\n \t    pass = -1;\n \n-\t  event_ptid = wait_one (&ws);\n+\t  wait_one_event event = wait_one ();\n+\n \t  if (debug_infrun)\n \t    {\n \t      fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t  \"infrun: stop_all_threads %s %s\\n\",\n-\t\t\t\t  target_waitstatus_to_string (&ws).c_str (),\n-\t\t\t\t  target_pid_to_str (event_ptid).c_str ());\n+\t\t\t\t  target_waitstatus_to_string (&event.ws).c_str (),\n+\t\t\t\t  target_pid_to_str (event.ptid).c_str ());\n \t    }\n \n-\t  if (ws.kind == TARGET_WAITKIND_NO_RESUMED\n-\t      || ws.kind == TARGET_WAITKIND_THREAD_EXITED\n-\t      || ws.kind == TARGET_WAITKIND_EXITED\n-\t      || ws.kind == TARGET_WAITKIND_SIGNALLED)\n+\t  if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED\n+\t      || event.ws.kind == TARGET_WAITKIND_THREAD_EXITED\n+\t      || event.ws.kind == TARGET_WAITKIND_EXITED\n+\t      || event.ws.kind == TARGET_WAITKIND_SIGNALLED)\n \t    {\n \t      /* All resumed threads exited\n \t\t or one thread/process exited/signalled.  */\n \t    }\n \t  else\n \t    {\n-\t      thread_info *t = find_thread_ptid (event_ptid);\n+\t      thread_info *t = find_thread_ptid (event.target, event.ptid);\n \t      if (t == NULL)\n-\t\tt = add_thread (event_ptid);\n+\t\tt = add_thread (event.target, event.ptid);\n \n \t      t->stop_requested = 0;\n \t      t->executing = 0;\n@@ -4451,15 +4743,15 @@ stop_all_threads (void)\n \n \t      /* This may be the first time we see the inferior report\n \t\t a stop.  */\n-\t      inferior *inf = find_inferior_ptid (event_ptid);\n+\t      inferior *inf = find_inferior_ptid (event.target, event.ptid);\n \t      if (inf->needs_setup)\n \t\t{\n \t\t  switch_to_thread_no_regs (t);\n \t\t  setup_inferior (0);\n \t\t}\n \n-\t      if (ws.kind == TARGET_WAITKIND_STOPPED\n-\t\t  && ws.value.sig == GDB_SIGNAL_0)\n+\t      if (event.ws.kind == TARGET_WAITKIND_STOPPED\n+\t\t  && event.ws.value.sig == GDB_SIGNAL_0)\n \t\t{\n \t\t  /* We caught the event that we intended to catch, so\n \t\t     there's no event pending.  */\n@@ -4488,7 +4780,7 @@ stop_all_threads (void)\n \n \t\t  if (debug_infrun)\n \t\t    {\n-\t\t      std::string statstr = target_waitstatus_to_string (&ws);\n+\t\t      std::string statstr = target_waitstatus_to_string (&event.ws);\n \n \t\t      fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\t  \"infrun: target_wait %s, saving \"\n@@ -4500,10 +4792,10 @@ stop_all_threads (void)\n \t\t    }\n \n \t\t  /* Record for later.  */\n-\t\t  save_waitstatus (t, &ws);\n+\t\t  save_waitstatus (t, &event.ws);\n \n-\t\t  sig = (ws.kind == TARGET_WAITKIND_STOPPED\n-\t\t\t ? ws.value.sig : GDB_SIGNAL_0);\n+\t\t  sig = (event.ws.kind == TARGET_WAITKIND_STOPPED\n+\t\t\t ? event.ws.value.sig : GDB_SIGNAL_0);\n \n \t\t  if (displaced_step_fixup (t, sig) < 0)\n \t\t    {\n@@ -4601,7 +4893,7 @@ handle_no_resumed (struct execution_control_state *ecs)\n      the synchronous command show \"no unwaited-for \" to the user.  */\n   update_thread_list ();\n \n-  for (thread_info *thread : all_non_exited_threads ())\n+  for (thread_info *thread : all_non_exited_threads (ecs->target))\n     {\n       if (thread->executing\n \t  || thread->suspend.waitstatus_pending_p)\n@@ -4621,7 +4913,7 @@ handle_no_resumed (struct execution_control_state *ecs)\n      process exited meanwhile (thus updating the thread list results\n      in an empty thread list).  In this case we know we'll be getting\n      a process exit event shortly.  */\n-  for (inferior *inf : all_non_exited_inferiors ())\n+  for (inferior *inf : all_non_exited_inferiors (ecs->target))\n     {\n       thread_info *thread = any_live_thread_of_inferior (inf);\n       if (thread == NULL)\n@@ -4691,8 +4983,8 @@ handle_inferior_event (struct execution_control_state *ecs)\n       && handle_no_resumed (ecs))\n     return;\n \n-  /* Cache the last pid/waitstatus.  */\n-  set_last_target_status (ecs->ptid, ecs->ws);\n+  /* Cache the last target/ptid/waitstatus.  */\n+  set_last_target_status (ecs->target, ecs->ptid, ecs->ws);\n \n   /* Always clear state belonging to the previous time we stopped.  */\n   stop_stack_dummy = STOP_NONE;\n@@ -4709,10 +5001,10 @@ handle_inferior_event (struct execution_control_state *ecs)\n   if (ecs->ws.kind != TARGET_WAITKIND_EXITED\n       && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED)\n     {\n-      ecs->event_thread = find_thread_ptid (ecs->ptid);\n+      ecs->event_thread = find_thread_ptid (ecs->target, ecs->ptid);\n       /* If it's a new thread, add it to the thread database.  */\n       if (ecs->event_thread == NULL)\n-\tecs->event_thread = add_thread (ecs->ptid);\n+\tecs->event_thread = add_thread (ecs->target, ecs->ptid);\n \n       /* Disable range stepping.  If the next step request could use a\n \t range, this will be end up re-enabled then.  */\n@@ -4784,10 +5076,10 @@ handle_inferior_event (struct execution_control_state *ecs)\n     else\n       mark_ptid = ecs->ptid;\n \n-    set_executing (mark_ptid, 0);\n+    set_executing (ecs->target, mark_ptid, 0);\n \n     /* Likewise the resumed flag.  */\n-    set_resumed (mark_ptid, 0);\n+    set_resumed (ecs->target, mark_ptid, 0);\n   }\n \n   switch (ecs->ws.kind)\n@@ -4888,7 +5180,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n     case TARGET_WAITKIND_EXITED:\n     case TARGET_WAITKIND_SIGNALLED:\n       inferior_ptid = ecs->ptid;\n-      set_current_inferior (find_inferior_ptid (ecs->ptid));\n+      set_current_inferior (find_inferior_ptid (ecs->target, ecs->ptid));\n       set_current_program_space (current_inferior ()->pspace);\n       handle_vfork_child_exec_or_exit (0);\n       target_terminal::ours ();\t/* Must do this before mourn anyway.  */\n@@ -4961,7 +5253,7 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n \tif (displaced_step_in_progress_thread (ecs->event_thread))\n \t  {\n \t    struct inferior *parent_inf\n-\t      = find_inferior_ptid (ecs->ptid);\n+\t      = find_inferior_ptid (ecs->target, ecs->ptid);\n \t    struct regcache *child_regcache;\n \t    CORE_ADDR parent_pc;\n \n@@ -4992,7 +5284,8 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n \t       list yet at this point.  */\n \n \t    child_regcache\n-\t      = get_thread_arch_aspace_regcache (ecs->ws.value.related_pid,\n+\t      = get_thread_arch_aspace_regcache (parent_inf->process_target (),\n+\t\t\t\t\t\t ecs->ws.value.related_pid,\n \t\t\t\t\t\t gdbarch,\n \t\t\t\t\t\t parent_inf->aspace);\n \t    /* Read PC value of parent process.  */\n@@ -5060,10 +5353,16 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n \n \t  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n \n+\t  process_stratum_target *targ\n+\t    = ecs->event_thread->inf->process_target ();\n+\n \t  should_resume = follow_fork ();\n \n+\t  /* Note that one of these may be an invalid pointer,\n+\t     depending on detach_fork.  */\n \t  thread_info *parent = ecs->event_thread;\n-\t  thread_info *child = find_thread_ptid (ecs->ws.value.related_pid);\n+\t  thread_info *child\n+\t    = find_thread_ptid (targ, ecs->ws.value.related_pid);\n \n \t  /* At this point, the parent is marked running, and the\n \t     child is marked stopped.  */\n@@ -5876,7 +6175,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n   if (random_signal)\n     {\n       /* Signal not for debugging purposes.  */\n-      struct inferior *inf = find_inferior_ptid (ecs->ptid);\n+      struct inferior *inf = find_inferior_ptid (ecs->target, ecs->ptid);\n       enum gdb_signal stop_signal = ecs->event_thread->suspend.stop_signal;\n \n       if (debug_infrun)\n@@ -6934,7 +7233,8 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t  /* Ignore threads of processes the caller is not\n \t     resuming.  */\n \t  if (!sched_multi\n-\t      && tp->ptid.pid () != ecs->ptid.pid ())\n+\t      && (tp->inf->process_target () != ecs->target\n+\t\t  || tp->inf->pid != ecs->ptid.pid ()))\n \t    continue;\n \n \t  /* When stepping over a breakpoint, we lock all threads\n@@ -7875,7 +8175,7 @@ print_stop_event (struct ui_out *uiout, bool displays)\n   struct target_waitstatus last;\n   struct thread_info *tp;\n \n-  get_last_target_status (nullptr, &last);\n+  get_last_target_status (nullptr, nullptr, &last);\n \n   {\n     scoped_restore save_uiout = make_scoped_restore (&current_uiout, uiout);\n@@ -7995,7 +8295,7 @@ normal_stop (void)\n {\n   struct target_waitstatus last;\n \n-  get_last_target_status (nullptr, &last);\n+  get_last_target_status (nullptr, nullptr, &last);\n \n   new_stop_id ();\n \n@@ -8004,10 +8304,10 @@ normal_stop (void)\n      frontend/user running state.  A QUIT is an easy exception to see\n      here, so do this before any filtered output.  */\n \n-  gdb::optional<scoped_finish_thread_state> maybe_finish_thread_state;\n+  ptid_t finish_ptid = null_ptid;\n \n   if (!non_stop)\n-    maybe_finish_thread_state.emplace (minus_one_ptid);\n+    finish_ptid = minus_one_ptid;\n   else if (last.kind == TARGET_WAITKIND_SIGNALLED\n \t   || last.kind == TARGET_WAITKIND_EXITED)\n     {\n@@ -8017,10 +8317,17 @@ normal_stop (void)\n \t linux-fork.c automatically switches to another fork from\n \t within target_mourn_inferior.  */\n       if (inferior_ptid != null_ptid)\n-\tmaybe_finish_thread_state.emplace (ptid_t (inferior_ptid.pid ()));\n+\tfinish_ptid = ptid_t (inferior_ptid.pid ());\n     }\n   else if (last.kind != TARGET_WAITKIND_NO_RESUMED)\n-    maybe_finish_thread_state.emplace (inferior_ptid);\n+    finish_ptid = inferior_ptid;\n+\n+  gdb::optional<scoped_finish_thread_state> maybe_finish_thread_state;\n+  if (finish_ptid != null_ptid)\n+    {\n+      maybe_finish_thread_state.emplace\n+\t(user_visible_resume_target (finish_ptid), finish_ptid);\n+    }\n \n   /* As we're presenting a stop, and potentially removing breakpoints,\n      update the thread list so we can tell whether there are threads"
    },
    {
      "sha": "8040b28f0172b00dc986de9a72bfb6dec8b930f5",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 13,
      "deletions": 5,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -25,6 +25,7 @@ struct target_waitstatus;\n struct frame_info;\n struct address_space;\n struct return_value_info;\n+struct process_stratum_target;\n \n /* True if we are debugging run control.  */\n extern unsigned int debug_infrun;\n@@ -93,23 +94,30 @@ extern void proceed (CORE_ADDR, enum gdb_signal);\n    resumed.  */\n extern ptid_t user_visible_resume_ptid (int step);\n \n-extern void wait_for_inferior (void);\n+/* Return the process_stratum target that we will proceed, in the\n+   perspective of the user/frontend.  If RESUME_PTID is\n+   MINUS_ONE_PTID, then we'll resume all threads of all targets, so\n+   the function returns NULL.  Otherwise, we'll be resuming a process\n+   or thread of the current process, so we return the current\n+   inferior's process stratum target.  */\n+extern process_stratum_target *user_visible_resume_target (ptid_t resume_ptid);\n \n /* Return control to GDB when the inferior stops for real.  Print\n    appropriate messages, remove breakpoints, give terminal our modes,\n    and run the stop hook.  Returns true if the stop hook proceeded the\n    target, false otherwise.  */\n extern int normal_stop (void);\n \n-/* Return the cached copy of the last ptid/waitstatus returned\n+/* Return the cached copy of the last target/ptid/waitstatus returned\n    by target_wait()/deprecated_target_wait_hook().  The data is\n    actually cached by handle_inferior_event(), which gets called\n    immediately after target_wait()/deprecated_target_wait_hook().  */\n-extern void get_last_target_status (ptid_t *ptid,\n+extern void get_last_target_status (process_stratum_target **target,\n+\t\t\t\t    ptid_t *ptid,\n \t\t\t\t    struct target_waitstatus *status);\n \n-/* Set the cached copy of the last ptid/waitstatus.  */\n-extern void set_last_target_status (ptid_t ptid,\n+/* Set the cached copy of the last target/ptid/waitstatus.  */\n+extern void set_last_target_status (process_stratum_target *target, ptid_t ptid,\n \t\t\t\t    struct target_waitstatus status);\n \n /* Clear the cached copy of the last ptid/waitstatus returned by"
    },
    {
      "sha": "0ee1de3a1f1c6a423eec4486e5beb7090520d2f5",
      "filename": "gdb/inline-frame.c",
      "status": "modified",
      "additions": 34,
      "deletions": 17,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inline-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inline-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inline-frame.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -95,37 +95,54 @@ find_inline_frame_state (thread_info *thread)\n   return &state;\n }\n \n-/* Forget about any hidden inlined functions in PTID, which is new or\n-   about to be resumed.  PTID may be minus_one_ptid (all processes)\n-   or a PID (all threads in this process).  */\n+/* See inline-frame.h.  */\n \n void\n-clear_inline_frame_state (ptid_t ptid)\n+clear_inline_frame_state (process_stratum_target *target, ptid_t filter_ptid)\n {\n-  if (ptid == minus_one_ptid)\n-    {\n-      inline_states.clear ();\n-      return;\n-    }\n+  gdb_assert (target != NULL);\n \n-  if (ptid.is_pid ())\n+  if (filter_ptid == minus_one_ptid || filter_ptid.is_pid ())\n     {\n-      int pid = ptid.pid ();\n+      auto matcher = [target, &filter_ptid] (const inline_state &state)\n+\t{\n+\t  thread_info *t = state.thread;\n+\t  return (t->inf->process_target () == target\n+\t\t  && t->ptid.matches (filter_ptid));\n+\t};\n+\n       auto it = std::remove_if (inline_states.begin (), inline_states.end (),\n-\t\t\t\t[pid] (const inline_state &state)\n-\t\t\t\t  {\n-\t\t\t\t    return pid == state.thread->inf->pid;\n-\t\t\t\t  });\n+\t\t\t\tmatcher);\n \n       inline_states.erase (it, inline_states.end ());\n \n       return;\n     }\n \n+\n+  auto matcher = [target, &filter_ptid] (const inline_state &state)\n+    {\n+      thread_info *t = state.thread;\n+      return (t->inf->process_target () == target\n+\t      && filter_ptid == t->ptid);\n+    };\n+\n+  auto it = std::find_if (inline_states.begin (), inline_states.end (),\n+\t\t\t  matcher);\n+\n+  if (it != inline_states.end ())\n+    unordered_remove (inline_states, it);\n+}\n+\n+/* See inline-frame.h.  */\n+\n+void\n+clear_inline_frame_state (thread_info *thread)\n+{\n   auto it = std::find_if (inline_states.begin (), inline_states.end (),\n-\t\t\t  [&ptid] (const inline_state &state)\n+\t\t\t  [thread] (const inline_state &state)\n \t\t\t    {\n-\t\t\t      return ptid == state.thread->ptid;\n+\t\t\t      return thread == state.thread;\n \t\t\t    });\n \n   if (it != inline_states.end ())"
    },
    {
      "sha": "f68d1242f6850af4be874fcec597ec96d6b41ef9",
      "filename": "gdb/inline-frame.h",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inline-frame.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/inline-frame.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inline-frame.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -23,6 +23,7 @@\n struct frame_info;\n struct frame_unwind;\n struct bpstats;\n+struct process_stratum_target;\n \n /* The inline frame unwinder.  */\n \n@@ -39,10 +40,15 @@ extern const struct frame_unwind inline_frame_unwind;\n void skip_inline_frames (thread_info *thread, struct bpstats *stop_chain);\n \n /* Forget about any hidden inlined functions in PTID, which is new or\n-   about to be resumed.  If PTID is minus_one_ptid, forget about all\n-   hidden inlined functions.  */\n+   about to be resumed.  PTID may be minus_one_ptid (all processes of\n+   TARGET) or a PID (all threads in this process of TARGET).  */\n \n-void clear_inline_frame_state (ptid_t ptid);\n+void clear_inline_frame_state (process_stratum_target *target, ptid_t ptid);\n+\n+/* Forget about any hidden inlined functions in THREAD, which is new\n+   or about to be resumed.  */\n+\n+void clear_inline_frame_state (thread_info *thread);\n \n /* Step into an inlined function by unhiding it.  */\n "
    },
    {
      "sha": "c77fb6c73ac98dbef349e4af30d357bd451f2670",
      "filename": "gdb/linux-fork.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-fork.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-fork.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-fork.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -519,7 +519,7 @@ Please switch to another checkpoint before deleting the current one\"));\n      list, waitpid the ptid.\n      If fi->parent_ptid is a part of lwp and it is stopped, waitpid the\n      ptid.  */\n-  thread_info *parent = find_thread_ptid (pptid);\n+  thread_info *parent = find_thread_ptid (linux_target, pptid);\n   if ((parent == NULL && find_fork_ptid (pptid))\n       || (parent != NULL && parent->state == THREAD_STOPPED))\n     {\n@@ -679,7 +679,7 @@ checkpoint_command (const char *args, int from_tty)\n     error (_(\"checkpoint: call_function_by_hand returned null.\"));\n \n   retpid = value_as_long (ret);\n-  get_last_target_status (&last_target_ptid, &last_target_waitstatus);\n+  get_last_target_status (nullptr, &last_target_ptid, &last_target_waitstatus);\n \n   fp = find_fork_pid (retpid);\n "
    },
    {
      "sha": "45b71ea8627fbf372a7af854a703dd22ad5aa138",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 43,
      "deletions": 32,
      "changes": 75,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -515,9 +515,12 @@ linux_nat_target::follow_fork (int follow_child, int detach_fork)\n \t}\n       else\n \t{\n-\t  scoped_restore save_inferior_ptid\n-\t    = make_scoped_restore (&inferior_ptid);\n-\t  inferior_ptid = child_ptid;\n+\t  /* Switching inferior_ptid is not enough, because then\n+\t     inferior_thread () would crash by not finding the thread\n+\t     in the current inferior.  */\n+\t  scoped_restore_current_thread restore_current_thread;\n+\t  thread_info *child = find_thread_ptid (this, child_ptid);\n+\t  switch_to_thread (child);\n \n \t  /* Let the thread_db layer learn about this new process.  */\n \t  check_for_thread_db ();\n@@ -989,7 +992,7 @@ linux_nat_switch_fork (ptid_t new_ptid)\n   /* This changes the thread's ptid while preserving the gdb thread\n      num.  Also changes the inferior pid, while preserving the\n      inferior num.  */\n-  thread_change_ptid (inferior_ptid, new_ptid);\n+  thread_change_ptid (linux_target, inferior_ptid, new_ptid);\n \n   /* We've just told GDB core that the thread changed target id, but,\n      in fact, it really is a different thread, with different register\n@@ -1002,7 +1005,7 @@ linux_nat_switch_fork (ptid_t new_ptid)\n static void\n exit_lwp (struct lwp_info *lp)\n {\n-  struct thread_info *th = find_thread_ptid (lp->ptid);\n+  struct thread_info *th = find_thread_ptid (linux_target, lp->ptid);\n \n   if (th)\n     {\n@@ -1162,9 +1165,9 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n \t  /* Also add the LWP to gdb's thread list, in case a\n \t     matching libthread_db is not found (or the process uses\n \t     raw clone).  */\n-\t  add_thread (lp->ptid);\n-\t  set_running (lp->ptid, 1);\n-\t  set_executing (lp->ptid, 1);\n+\t  add_thread (linux_target, lp->ptid);\n+\t  set_running (linux_target, lp->ptid, 1);\n+\t  set_executing (linux_target, lp->ptid, 1);\n \t}\n \n       return 1;\n@@ -1203,7 +1206,7 @@ linux_nat_target::attach (const char *args, int from_tty)\n   ptid = ptid_t (inferior_ptid.pid (),\n \t\t inferior_ptid.pid (),\n \t\t 0);\n-  thread_change_ptid (inferior_ptid, ptid);\n+  thread_change_ptid (linux_target, inferior_ptid, ptid);\n \n   /* Add the initial process as the first LWP to the list.  */\n   lp = add_initial_lwp (ptid);\n@@ -1304,7 +1307,7 @@ get_detach_signal (struct lwp_info *lp)\n     signo = gdb_signal_from_host (WSTOPSIG (lp->status));\n   else\n     {\n-      struct thread_info *tp = find_thread_ptid (lp->ptid);\n+      struct thread_info *tp = find_thread_ptid (linux_target, lp->ptid);\n \n       if (target_is_non_stop_p () && !tp->executing)\n \t{\n@@ -1316,10 +1319,12 @@ get_detach_signal (struct lwp_info *lp)\n       else if (!target_is_non_stop_p ())\n \t{\n \t  ptid_t last_ptid;\n+\t  process_stratum_target *last_target;\n \n-\t  get_last_target_status (&last_ptid, nullptr);\n+\t  get_last_target_status (&last_target, &last_ptid, nullptr);\n \n-\t  if (lp->ptid.lwp () == last_ptid.lwp ())\n+\t  if (last_target == linux_target\n+\t      && lp->ptid.lwp () == last_ptid.lwp ())\n \t    signo = tp->suspend.stop_signal;\n \t}\n     }\n@@ -1516,7 +1521,7 @@ linux_resume_one_lwp_throw (struct lwp_info *lp, int step,\n      handle the case of stepping a breakpoint instruction).  */\n   if (step)\n     {\n-      struct regcache *regcache = get_thread_regcache (lp->ptid);\n+      struct regcache *regcache = get_thread_regcache (linux_target, lp->ptid);\n \n       lp->stop_pc = regcache_read_pc (regcache);\n     }\n@@ -1535,7 +1540,7 @@ linux_resume_one_lwp_throw (struct lwp_info *lp, int step,\n   lp->stopped = 0;\n   lp->core = -1;\n   lp->stop_reason = TARGET_STOPPED_BY_NO_REASON;\n-  registers_changed_ptid (lp->ptid);\n+  registers_changed_ptid (linux_target, lp->ptid);\n }\n \n /* Called when we try to resume a stopped LWP and that errors out.  If\n@@ -1594,7 +1599,7 @@ resume_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)\n {\n   if (lp->stopped)\n     {\n-      struct inferior *inf = find_inferior_ptid (lp->ptid);\n+      struct inferior *inf = find_inferior_ptid (linux_target, lp->ptid);\n \n       if (inf->vfork_child != NULL)\n \t{\n@@ -1648,7 +1653,7 @@ linux_nat_resume_callback (struct lwp_info *lp, struct lwp_info *except)\n     {\n       struct thread_info *thread;\n \n-      thread = find_thread_ptid (lp->ptid);\n+      thread = find_thread_ptid (linux_target, lp->ptid);\n       if (thread != NULL)\n \t{\n \t  signo = thread->suspend.stop_signal;\n@@ -1805,7 +1810,7 @@ linux_handle_syscall_trap (struct lwp_info *lp, int stopping)\n {\n   struct target_waitstatus *ourstatus = &lp->waitstatus;\n   struct gdbarch *gdbarch = target_thread_architecture (lp->ptid);\n-  thread_info *thread = find_thread_ptid (lp->ptid);\n+  thread_info *thread = find_thread_ptid (linux_target, lp->ptid);\n   int syscall_number = (int) gdbarch_get_syscall_number (gdbarch, thread);\n \n   if (stopping)\n@@ -2025,15 +2030,15 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \t      /* The process is not using thread_db.  Add the LWP to\n \t\t GDB's list.  */\n \t      target_post_attach (new_lp->ptid.lwp ());\n-\t      add_thread (new_lp->ptid);\n+\t      add_thread (linux_target, new_lp->ptid);\n \t    }\n \n \t  /* Even if we're stopping the thread for some reason\n \t     internal to this module, from the perspective of infrun\n \t     and the user/frontend, this new thread is running until\n \t     it next reports a stop.  */\n-\t  set_running (new_lp->ptid, 1);\n-\t  set_executing (new_lp->ptid, 1);\n+\t  set_running (linux_target, new_lp->ptid, 1);\n+\t  set_executing (linux_target, new_lp->ptid, 1);\n \n \t  if (WSTOPSIG (status) != SIGSTOP)\n \t    {\n@@ -2256,7 +2261,7 @@ wait_lwp (struct lwp_info *lp)\n \n   if (lp->must_set_ptrace_flags)\n     {\n-      struct inferior *inf = find_inferior_pid (lp->ptid.pid ());\n+      inferior *inf = find_inferior_pid (linux_target, lp->ptid.pid ());\n       int options = linux_nat_ptrace_options (inf->attach_flag);\n \n       linux_enable_event_reporting (lp->ptid.lwp (), options);\n@@ -2483,7 +2488,7 @@ linux_nat_target::low_status_is_event (int status)\n static int\n stop_wait_callback (struct lwp_info *lp)\n {\n-  struct inferior *inf = find_inferior_ptid (lp->ptid);\n+  inferior *inf = find_inferior_ptid (linux_target, lp->ptid);\n \n   /* If this is a vfork parent, bail out, it is not going to report\n      any SIGSTOP until the vfork is done with.  */\n@@ -2576,7 +2581,7 @@ status_callback (struct lwp_info *lp)\n   if (lp->stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT\n       || lp->stop_reason == TARGET_STOPPED_BY_HW_BREAKPOINT)\n     {\n-      struct regcache *regcache = get_thread_regcache (lp->ptid);\n+      struct regcache *regcache = get_thread_regcache (linux_target, lp->ptid);\n       CORE_ADDR pc;\n       int discard = 0;\n \n@@ -2697,7 +2702,7 @@ save_stop_reason (struct lwp_info *lp)\n   if (!linux_target->low_status_is_event (lp->status))\n     return;\n \n-  regcache = get_thread_regcache (lp->ptid);\n+  regcache = get_thread_regcache (linux_target, lp->ptid);\n   gdbarch = regcache->arch ();\n \n   pc = regcache_read_pc (regcache);\n@@ -2959,7 +2964,7 @@ linux_nat_filter_event (int lwpid, int status)\n       lp = add_lwp (ptid_t (lwpid, lwpid, 0));\n       lp->stopped = 1;\n       lp->resumed = 1;\n-      add_thread (lp->ptid);\n+      add_thread (linux_target, lp->ptid);\n     }\n \n   if (WIFSTOPPED (status) && !lp)\n@@ -2985,7 +2990,7 @@ linux_nat_filter_event (int lwpid, int status)\n \n   if (WIFSTOPPED (status) && lp->must_set_ptrace_flags)\n     {\n-      struct inferior *inf = find_inferior_pid (lp->ptid.pid ());\n+      inferior *inf = find_inferior_pid (linux_target, lp->ptid.pid ());\n       int options = linux_nat_ptrace_options (inf->attach_flag);\n \n       linux_enable_event_reporting (lp->ptid.lwp (), options);\n@@ -3151,7 +3156,7 @@ linux_nat_filter_event (int lwpid, int status)\n       if (!lp->step\n \t  && WSTOPSIG (status) && sigismember (&pass_mask, WSTOPSIG (status))\n \t  && (WSTOPSIG (status) != SIGSTOP\n-\t      || !find_thread_ptid (lp->ptid)->stop_requested)\n+\t      || !find_thread_ptid (linux_target, lp->ptid)->stop_requested)\n \t  && !linux_wstatus_maybe_breakpoint (status))\n \t{\n \t  linux_resume_one_lwp (lp, lp->step, signo);\n@@ -3270,7 +3275,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   if (inferior_ptid.is_pid ())\n     {\n       /* Upgrade the main thread's ptid.  */\n-      thread_change_ptid (inferior_ptid,\n+      thread_change_ptid (linux_target, inferior_ptid,\n \t\t\t  ptid_t (inferior_ptid.pid (),\n \t\t\t\t  inferior_ptid.pid (), 0));\n \n@@ -3415,7 +3420,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   if (lp->stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT\n       && !USE_SIGTRAP_SIGINFO)\n     {\n-      struct regcache *regcache = get_thread_regcache (lp->ptid);\n+      struct regcache *regcache = get_thread_regcache (linux_target, lp->ptid);\n       struct gdbarch *gdbarch = regcache->arch ();\n       int decr_pc = gdbarch_decr_pc_after_break (gdbarch);\n \n@@ -3516,7 +3521,7 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n     }\n   else\n     {\n-      struct regcache *regcache = get_thread_regcache (lp->ptid);\n+      struct regcache *regcache = get_thread_regcache (linux_target, lp->ptid);\n       struct gdbarch *gdbarch = regcache->arch ();\n \n       try\n@@ -4264,6 +4269,12 @@ linux_async_pipe (int enable)\n   return previous;\n }\n \n+int\n+linux_nat_target::async_wait_fd ()\n+{\n+  return linux_nat_event_pipe[0];\n+}\n+\n /* target_async implementation.  */\n \n void\n@@ -4321,7 +4332,7 @@ linux_nat_stop_lwp (struct lwp_info *lwp)\n \n       if (debug_linux_nat)\n \t{\n-\t  if (find_thread_ptid (lwp->ptid)->stop_requested)\n+\t  if (find_thread_ptid (linux_target, lwp->ptid)->stop_requested)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"LNSL: already stopped/stop_requested %s\\n\",\n \t\t\t\ttarget_pid_to_str (lwp->ptid).c_str ());\n@@ -4378,7 +4389,7 @@ linux_nat_target::thread_address_space (ptid_t ptid)\n       pid = ptid.pid ();\n     }\n \n-  inf = find_inferior_pid (pid);\n+  inf = find_inferior_pid (this, pid);\n   gdb_assert (inf != NULL);\n   return inf->aspace;\n }"
    },
    {
      "sha": "e02611fcf14cff52f2fc0343be37ab3e92a4939f",
      "filename": "gdb/linux-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -88,6 +88,7 @@ class linux_nat_target : public inf_ptrace_target\n   bool supports_non_stop () override;\n   bool always_non_stop_p () override;\n \n+  int async_wait_fd () override;\n   void async (int) override;\n \n   void close () override;"
    },
    {
      "sha": "820657a1038ed05d96ad0506e6aa319e822e9228",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1651,7 +1651,8 @@ linux_corefile_thread (struct thread_info *info,\n {\n   struct regcache *regcache;\n \n-  regcache = get_thread_arch_regcache (info->ptid, args->gdbarch);\n+  regcache = get_thread_arch_regcache (info->inf->process_target (),\n+\t\t\t\t       info->ptid, args->gdbarch);\n \n   target_fetch_registers (regcache, -1);\n   gdb::byte_vector siginfo_data = linux_get_siginfo_data (info, args->gdbarch);"
    },
    {
      "sha": "ed37de6d198daffdc4fefe724cca470a0da49914",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 59,
      "deletions": 51,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -168,6 +168,9 @@ struct thread_db_info\n {\n   struct thread_db_info *next;\n \n+  /* The target this thread_db_info is bound to.  */\n+  process_stratum_target *process_target;\n+\n   /* Process id this object refers to.  */\n   int pid;\n \n@@ -228,6 +231,7 @@ add_thread_db_info (void *handle)\n {\n   struct thread_db_info *info = XCNEW (struct thread_db_info);\n \n+  info->process_target = current_inferior ()->process_target ();\n   info->pid = inferior_ptid.pid ();\n   info->handle = handle;\n \n@@ -246,12 +250,12 @@ add_thread_db_info (void *handle)\n    related to process PID, if any; NULL otherwise.  */\n \n static struct thread_db_info *\n-get_thread_db_info (int pid)\n+get_thread_db_info (process_stratum_target *targ, int pid)\n {\n   struct thread_db_info *info;\n \n   for (info = thread_db_list; info; info = info->next)\n-    if (pid == info->pid)\n+    if (targ == info->process_target && pid == info->pid)\n       return info;\n \n   return NULL;\n@@ -265,14 +269,14 @@ static const char *thread_db_err_str (td_err_e err);\n    LIBTHREAD_DB_SO's dlopen'ed handle.  */\n \n static void\n-delete_thread_db_info (int pid)\n+delete_thread_db_info (process_stratum_target *targ, int pid)\n {\n   struct thread_db_info *info, *info_prev;\n \n   info_prev = NULL;\n \n   for (info = thread_db_list; info; info_prev = info, info = info->next)\n-    if (pid == info->pid)\n+    if (targ == info->process_target && pid == info->pid)\n       break;\n \n   if (info == NULL)\n@@ -406,7 +410,7 @@ thread_from_lwp (thread_info *stopped, ptid_t ptid)\n      LWP.  */\n   gdb_assert (ptid.lwp () != 0);\n \n-  info = get_thread_db_info (ptid.pid ());\n+  info = get_thread_db_info (stopped->inf->process_target (), ptid.pid ());\n \n   /* Access an lwp we know is stopped.  */\n   info->proc_handle.thread = stopped;\n@@ -422,7 +426,7 @@ thread_from_lwp (thread_info *stopped, ptid_t ptid)\n \t   thread_db_err_str (err));\n \n   /* Fill the cache.  */\n-  tp = find_thread_ptid (ptid);\n+  tp = find_thread_ptid (stopped->inf->process_target (), ptid);\n   return record_thread (info, tp, ptid, &th, &ti);\n }\n \f\n@@ -434,12 +438,12 @@ thread_db_notice_clone (ptid_t parent, ptid_t child)\n {\n   struct thread_db_info *info;\n \n-  info = get_thread_db_info (child.pid ());\n+  info = get_thread_db_info (linux_target, child.pid ());\n \n   if (info == NULL)\n     return 0;\n \n-  thread_info *stopped = find_thread_ptid (parent);\n+  thread_info *stopped = find_thread_ptid (linux_target, parent);\n \n   thread_from_lwp (stopped, child);\n \n@@ -684,13 +688,13 @@ check_thread_db_callback (const td_thrhandle_t *th, void *arg)\n      to how GDB accesses TLS could result in this passing\n      without exercising the calls it's supposed to.  */\n   ptid_t ptid = ptid_t (tdb_testinfo->info->pid, ti.ti_lid, 0);\n-  struct thread_info *thread_info = find_thread_ptid (ptid);\n+  thread_info *thread_info = find_thread_ptid (linux_target, ptid);\n   if (thread_info != NULL && thread_info->priv != NULL)\n     {\n       LOG (\"; errno\");\n \n       scoped_restore_current_thread restore_current_thread;\n-      switch_to_thread (ptid);\n+      switch_to_thread (thread_info);\n \n       expression_up expr = parse_expression (\"(int) errno\");\n       struct value *val = evaluate_expression (expr.get ());\n@@ -940,10 +944,8 @@ try_thread_db_load_1 (struct thread_db_info *info)\n     }\n \n   /* The thread library was detected.  Activate the thread_db target\n-     if this is the first process using it.  */\n-  if (thread_db_list->next == NULL)\n-    push_target (&the_thread_db_target);\n-\n+     for this process.  */\n+  push_target (&the_thread_db_target);\n   return true;\n }\n \n@@ -1013,7 +1015,8 @@ try_thread_db_load (const char *library, bool check_auto_load_safe)\n     return true;\n \n   /* This library \"refused\" to work on current inferior.  */\n-  delete_thread_db_info (inferior_ptid.pid ());\n+  delete_thread_db_info (current_inferior ()->process_target (),\n+\t\t\t inferior_ptid.pid ());\n   return false;\n }\n \n@@ -1182,7 +1185,8 @@ thread_db_load (void)\n {\n   struct thread_db_info *info;\n \n-  info = get_thread_db_info (inferior_ptid.pid ());\n+  info = get_thread_db_info (current_inferior ()->process_target (),\n+\t\t\t     inferior_ptid.pid ());\n \n   if (info != NULL)\n     return true;\n@@ -1349,7 +1353,7 @@ record_thread (struct thread_db_info *info,\n      thread with this PTID, but it's marked exited, then the kernel\n      reused the tid of an old thread.  */\n   if (tp == NULL || tp->state == THREAD_EXITED)\n-    tp = add_thread_with_info (ptid, priv);\n+    tp = add_thread_with_info (info->process_target, ptid, priv);\n   else\n     tp->priv.reset (priv);\n \n@@ -1362,16 +1366,14 @@ record_thread (struct thread_db_info *info,\n void\n thread_db_target::detach (inferior *inf, int from_tty)\n {\n-  delete_thread_db_info (inf->pid);\n+  delete_thread_db_info (inf->process_target (), inf->pid);\n \n   beneath ()->detach (inf, from_tty);\n \n   /* NOTE: From this point on, inferior_ptid is null_ptid.  */\n \n-  /* If there are no more processes using libpthread, detach the\n-     thread_db target ops.  */\n-  if (!thread_db_list)\n-    unpush_target (this);\n+  /* Detach the thread_db target from this inferior.  */\n+  unpush_target (this);\n }\n \n ptid_t\n@@ -1380,7 +1382,10 @@ thread_db_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n {\n   struct thread_db_info *info;\n \n-  ptid = beneath ()->wait (ptid, ourstatus, options);\n+  process_stratum_target *beneath\n+    = as_process_stratum_target (this->beneath ());\n+\n+  ptid = beneath->wait (ptid, ourstatus, options);\n \n   switch (ourstatus->kind)\n     {\n@@ -1391,7 +1396,7 @@ thread_db_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n       return ptid;\n     }\n \n-  info = get_thread_db_info (ptid.pid ());\n+  info = get_thread_db_info (beneath, ptid.pid ());\n \n   /* If this process isn't using thread_db, we're done.  */\n   if (info == NULL)\n@@ -1401,29 +1406,30 @@ thread_db_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n     {\n       /* New image, it may or may not end up using thread_db.  Assume\n \t not unless we find otherwise.  */\n-      delete_thread_db_info (ptid.pid ());\n-      if (!thread_db_list)\n-\tunpush_target (&the_thread_db_target);\n+      delete_thread_db_info (beneath, ptid.pid ());\n+      unpush_target (this);\n \n       return ptid;\n     }\n \n   /* Fill in the thread's user-level thread id and status.  */\n-  thread_from_lwp (find_thread_ptid (ptid), ptid);\n+  thread_from_lwp (find_thread_ptid (beneath, ptid), ptid);\n \n   return ptid;\n }\n \n void\n thread_db_target::mourn_inferior ()\n {\n-  delete_thread_db_info (inferior_ptid.pid ());\n+  process_stratum_target *target_beneath\n+    = as_process_stratum_target (this->beneath ());\n+\n+  delete_thread_db_info (target_beneath, inferior_ptid.pid ());\n \n-  beneath ()->mourn_inferior ();\n+  target_beneath->mourn_inferior ();\n \n-  /* Detach thread_db target ops.  */\n-  if (!thread_db_list)\n-    unpush_target (&the_thread_db_target);\n+  /* Detach the thread_db target from this inferior.  */\n+  unpush_target (this);\n }\n \n struct callback_data\n@@ -1488,7 +1494,7 @@ find_new_threads_callback (const td_thrhandle_t *th_p, void *data)\n     }\n \n   ptid_t ptid (info->pid, ti.ti_lid);\n-  tp = find_thread_ptid (ptid);\n+  tp = find_thread_ptid (info->process_target, ptid);\n   if (tp == NULL || tp->priv == NULL)\n     record_thread (info, tp, ptid, th_p, &ti);\n \n@@ -1555,7 +1561,8 @@ thread_db_find_new_threads_2 (thread_info *stopped, bool until_no_new)\n   struct thread_db_info *info;\n   int i, loop;\n \n-  info = get_thread_db_info (stopped->ptid.pid ());\n+  info = get_thread_db_info (stopped->inf->process_target (),\n+\t\t\t     stopped->ptid.pid ());\n \n   /* Access an lwp we know is stopped.  */\n   info->proc_handle.thread = stopped;\n@@ -1598,16 +1605,14 @@ thread_db_target::update_thread_list ()\n \n   for (inferior *inf : all_inferiors ())\n     {\n-      struct thread_info *thread;\n-\n       if (inf->pid == 0)\n \tcontinue;\n \n-      info = get_thread_db_info (inf->pid);\n+      info = get_thread_db_info (inf->process_target (), inf->pid);\n       if (info == NULL)\n \tcontinue;\n \n-      thread = any_live_thread_of_inferior (inf);\n+      thread_info *thread = any_live_thread_of_inferior (inf);\n       if (thread == NULL || thread->executing)\n \tcontinue;\n \n@@ -1635,7 +1640,7 @@ thread_db_target::update_thread_list ()\n std::string\n thread_db_target::pid_to_str (ptid_t ptid)\n {\n-  struct thread_info *thread_info = find_thread_ptid (ptid);\n+  thread_info *thread_info = find_thread_ptid (current_inferior (), ptid);\n \n   if (thread_info != NULL && thread_info->priv != NULL)\n     {\n@@ -1728,9 +1733,10 @@ thread_db_target::get_thread_local_address (ptid_t ptid,\n \t\t\t\t\t    CORE_ADDR offset)\n {\n   struct thread_info *thread_info;\n-\n+  process_stratum_target *beneath\n+    = as_process_stratum_target (this->beneath ());\n   /* Find the matching thread.  */\n-  thread_info = find_thread_ptid (ptid);\n+  thread_info = find_thread_ptid (beneath, ptid);\n \n   /* We may not have discovered the thread yet.  */\n   if (thread_info != NULL && thread_info->priv == NULL)\n@@ -1740,7 +1746,7 @@ thread_db_target::get_thread_local_address (ptid_t ptid,\n     {\n       td_err_e err;\n       psaddr_t address;\n-      thread_db_info *info = get_thread_db_info (ptid.pid ());\n+      thread_db_info *info = get_thread_db_info (beneath, ptid.pid ());\n       thread_db_thread_info *priv = get_thread_db_thread_info (thread_info);\n \n       /* Finally, get the address of the variable.  */\n@@ -1799,7 +1805,7 @@ thread_db_target::get_thread_local_address (ptid_t ptid,\n \t      : (CORE_ADDR) (uintptr_t) address);\n     }\n \n-  return beneath ()->get_thread_local_address (ptid, lm, offset);\n+  return beneath->get_thread_local_address (ptid, lm, offset);\n }\n \n /* Implement the to_get_ada_task_ptid target method for this target.  */\n@@ -1814,20 +1820,21 @@ thread_db_target::get_ada_task_ptid (long lwp, long thread)\n void\n thread_db_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n {\n-  struct thread_db_info *info;\n+  process_stratum_target *beneath\n+    = as_process_stratum_target (this->beneath ());\n \n-  if (ptid == minus_one_ptid)\n-    info = get_thread_db_info (inferior_ptid.pid ());\n-  else\n-    info = get_thread_db_info (ptid.pid ());\n+  thread_db_info *info\n+    = get_thread_db_info (beneath, (ptid == minus_one_ptid\n+\t\t\t\t    ? inferior_ptid.pid ()\n+\t\t\t\t    : ptid.pid ()));\n \n   /* This workaround is only needed for child fork lwps stopped in a\n      PTRACE_O_TRACEFORK event.  When the inferior is resumed, the\n      workaround can be disabled.  */\n   if (info)\n     info->need_stale_parent_threads_check = 0;\n \n-  beneath ()->resume (ptid, step, signo);\n+  beneath->resume (ptid, step, signo);\n }\n \n /* std::sort helper function for info_auto_load_libthread_db, sort the\n@@ -1953,7 +1960,8 @@ maintenance_check_libthread_db (const char *args, int from_tty)\n   if (inferior_pid == 0)\n     error (_(\"No inferior running\"));\n \n-  info = get_thread_db_info (inferior_pid);\n+  info = get_thread_db_info (current_inferior ()->process_target (),\n+\t\t\t     inferior_pid);\n   if (info == NULL)\n     error (_(\"No libthread_db loaded\"));\n "
    },
    {
      "sha": "556f446c2e19ef2f49725135f61ea9981dbe9809",
      "filename": "gdb/mi/mi-interp.c",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/mi/mi-interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/mi/mi-interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-interp.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -961,7 +961,8 @@ multiple_inferiors_p ()\n }\n \n static void\n-mi_on_resume_1 (struct mi_interp *mi, ptid_t ptid)\n+mi_on_resume_1 (struct mi_interp *mi,\n+\t\tprocess_stratum_target *targ, ptid_t ptid)\n {\n   /* To cater for older frontends, emit ^running, but do it only once\n      per each command.  We do it here, since at this point we know\n@@ -984,7 +985,7 @@ mi_on_resume_1 (struct mi_interp *mi, ptid_t ptid)\n       && !multiple_inferiors_p ())\n     fprintf_unfiltered (mi->raw_stdout, \"*running,thread-id=\\\"all\\\"\\n\");\n   else\n-    for (thread_info *tp : all_non_exited_threads (ptid))\n+    for (thread_info *tp : all_non_exited_threads (targ, ptid))\n       mi_output_running (tp);\n \n   if (!running_result_record_printed && mi_proceeded)\n@@ -1004,10 +1005,11 @@ mi_on_resume (ptid_t ptid)\n {\n   struct thread_info *tp = NULL;\n \n+  process_stratum_target *target = current_inferior ()->process_target ();\n   if (ptid == minus_one_ptid || ptid.is_pid ())\n     tp = inferior_thread ();\n   else\n-    tp = find_thread_ptid (ptid);\n+    tp = find_thread_ptid (target, ptid);\n \n   /* Suppress output while calling an inferior function.  */\n   if (tp->control.in_infcall)\n@@ -1023,7 +1025,7 @@ mi_on_resume (ptid_t ptid)\n       target_terminal::scoped_restore_terminal_state term_state;\n       target_terminal::ours_for_output ();\n \n-      mi_on_resume_1 (mi, ptid);\n+      mi_on_resume_1 (mi, target, ptid);\n     }\n }\n "
    },
    {
      "sha": "78f972a7496d44a8e056b15fec8915e26a0d3268",
      "filename": "gdb/nat/fork-inferior.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/nat/fork-inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/nat/fork-inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/fork-inferior.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -450,7 +450,7 @@ fork_inferior (const char *exec_file_arg, const std::string &allargs,\n /* See nat/fork-inferior.h.  */\n \n ptid_t\n-startup_inferior (pid_t pid, int ntraps,\n+startup_inferior (process_stratum_target *proc_target, pid_t pid, int ntraps,\n \t\t  struct target_waitstatus *last_waitstatus,\n \t\t  ptid_t *last_ptid)\n {\n@@ -502,7 +502,7 @@ startup_inferior (pid_t pid, int ntraps,\n \t  case TARGET_WAITKIND_SYSCALL_ENTRY:\n \t  case TARGET_WAITKIND_SYSCALL_RETURN:\n \t    /* Ignore gracefully during startup of the inferior.  */\n-\t    switch_to_thread (event_ptid);\n+\t    switch_to_thread (proc_target, event_ptid);\n \t    break;\n \n \t  case TARGET_WAITKIND_SIGNALLED:\n@@ -527,12 +527,12 @@ startup_inferior (pid_t pid, int ntraps,\n \t    /* Handle EXEC signals as if they were SIGTRAP signals.  */\n \t    xfree (ws.value.execd_pathname);\n \t    resume_signal = GDB_SIGNAL_TRAP;\n-\t    switch_to_thread (event_ptid);\n+\t    switch_to_thread (proc_target, event_ptid);\n \t    break;\n \n \t  case TARGET_WAITKIND_STOPPED:\n \t    resume_signal = ws.value.sig;\n-\t    switch_to_thread (event_ptid);\n+\t    switch_to_thread (proc_target, event_ptid);\n \t    break;\n \t}\n "
    },
    {
      "sha": "9cbe9bd19d5a3b00591fa7b8efdc320550d29278",
      "filename": "gdb/nat/fork-inferior.h",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/nat/fork-inferior.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/nat/fork-inferior.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/fork-inferior.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -22,6 +22,8 @@\n \n #include <string>\n \n+struct process_stratum_target;\n+\n /* Number of traps that happen between exec'ing the shell to run an\n    inferior and when we finally get to the inferior code, not counting\n    the exec for the shell.  This is 1 on all supported\n@@ -50,7 +52,8 @@ extern pid_t fork_inferior (const char *exec_file_arg,\n /* Accept NTRAPS traps from the inferior.\n \n    Return the ptid of the inferior being started.  */\n-extern ptid_t startup_inferior (pid_t pid, int ntraps,\n+extern ptid_t startup_inferior (process_stratum_target *proc_target,\n+\t\t\t\tpid_t pid, int ntraps,\n \t\t\t\tstruct target_waitstatus *mystatus,\n \t\t\t\tptid_t *myptid);\n "
    },
    {
      "sha": "c31dbf136c8cb9966c20f33b73ef5a74c97e0d82",
      "filename": "gdb/nto-procfs.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/nto-procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/nto-procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nto-procfs.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -409,7 +409,7 @@ nto_procfs_target::update_thread_list ()\n \t   (e.g. thread exited).  */\n \tcontinue;\n       ptid = ptid_t (pid, 0, tid);\n-      new_thread = find_thread_ptid (ptid);\n+      new_thread = find_thread_ptid (this, ptid);\n       if (!new_thread)\n \tnew_thread = add_thread (ptid);\n       update_thread_private_data (new_thread, tid, status.state, 0);"
    },
    {
      "sha": "8ae108438d3b684ee55335fdcb524690fd2a7063",
      "filename": "gdb/ppc-fbsd-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/ppc-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/ppc-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-fbsd-tdep.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -35,6 +35,7 @@\n #include \"ppc-fbsd-tdep.h\"\n #include \"fbsd-tdep.h\"\n #include \"solib-svr4.h\"\n+#include \"inferior.h\"\n \n \n /* 32-bit regset descriptions.  */\n@@ -289,7 +290,8 @@ ppcfbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n   struct regcache *regcache;\n   int tp_offset, tp_regnum;\n \n-  regcache = get_thread_arch_regcache (ptid, gdbarch);\n+  regcache = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\t       ptid, gdbarch);\n \n   if (tdep->wordsize == 4)\n     {"
    },
    {
      "sha": "86f79ad5838931faf15914c4930a094c15b9c85e",
      "filename": "gdb/proc-service.c",
      "status": "modified",
      "additions": 12,
      "deletions": 5,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/proc-service.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/proc-service.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/proc-service.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -70,17 +70,22 @@ static ps_err_e\n ps_xfer_memory (const struct ps_prochandle *ph, psaddr_t addr,\n \t\tgdb_byte *buf, size_t len, int write)\n {\n-  scoped_restore save_inferior_ptid = make_scoped_restore (&inferior_ptid);\n-  int ret;\n-  CORE_ADDR core_addr = ps_addr_to_core_addr (addr);\n+  scoped_restore_current_inferior restore_inferior;\n+  set_current_inferior (ph->thread->inf);\n \n+  scoped_restore_current_program_space restore_current_progspace;\n+  set_current_program_space (ph->thread->inf->pspace);\n+\n+  scoped_restore save_inferior_ptid = make_scoped_restore (&inferior_ptid);\n   inferior_ptid = ph->thread->ptid;\n \n+  CORE_ADDR core_addr = ps_addr_to_core_addr (addr);\n+\n+  int ret;\n   if (write)\n     ret = target_write_memory (core_addr, buf, len);\n   else\n     ret = target_read_memory (core_addr, buf, len);\n-\n   return (ret == 0 ? PS_OK : PS_ERR);\n }\n \f\n@@ -135,7 +140,9 @@ static struct regcache *\n get_ps_regcache (struct ps_prochandle *ph, lwpid_t lwpid)\n {\n   inferior *inf = ph->thread->inf;\n-  return get_thread_arch_regcache (ptid_t (inf->pid, lwpid), inf->gdbarch);\n+  return get_thread_arch_regcache (inf->process_target (),\n+\t\t\t\t   ptid_t (inf->pid, lwpid),\n+\t\t\t\t   inf->gdbarch);\n }\n \n /* Get the general registers of LWP LWPID within the target process PH"
    },
    {
      "sha": "f3fd9ee905db65e5bd52efa77c82608f3d3ad3e9",
      "filename": "gdb/process-stratum-target.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/process-stratum-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/process-stratum-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/process-stratum-target.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -29,7 +29,7 @@ struct address_space *\n process_stratum_target::thread_address_space (ptid_t ptid)\n {\n   /* Fall-back to the \"main\" address space of the inferior.  */\n-  inferior *inf = find_inferior_ptid (ptid);\n+  inferior *inf = find_inferior_ptid (this, ptid);\n \n   if (inf == NULL || inf->aspace == NULL)\n     internal_error (__FILE__, __LINE__,\n@@ -43,7 +43,7 @@ process_stratum_target::thread_address_space (ptid_t ptid)\n struct gdbarch *\n process_stratum_target::thread_architecture (ptid_t ptid)\n {\n-  inferior *inf = find_inferior_ptid (ptid);\n+  inferior *inf = find_inferior_ptid (this, ptid);\n   gdb_assert (inf != NULL);\n   return inf->gdbarch;\n }"
    },
    {
      "sha": "53d221d9aaaf4e66a54c2de21ce255c8ec92e020",
      "filename": "gdb/process-stratum-target.h",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/process-stratum-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/process-stratum-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/process-stratum-target.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -51,6 +51,22 @@ class process_stratum_target : public target_ops\n   bool has_stack () override;\n   bool has_registers () override;\n   bool has_execution (inferior *inf) override;\n+\n+  /* True if any thread is, or may be executing.  We need to track\n+     this separately because until we fully sync the thread list, we\n+     won't know whether the target is fully stopped, even if we see\n+     stop events for all known threads, because any of those threads\n+     may have spawned new threads we haven't heard of yet.  */\n+  bool threads_executing = false;\n };\n \n+/* Downcast TARGET to process_stratum_target.  */\n+\n+static inline process_stratum_target *\n+as_process_stratum_target (target_ops *target)\n+{\n+  gdb_assert (target->stratum () == process_stratum);\n+  return static_cast<process_stratum_target *> (target);\n+}\n+\n #endif /* !defined (PROCESS_STRATUM_TARGET_H) */"
    },
    {
      "sha": "a59e32c6d7ad315527e4d2cb14cf826c20ec740c",
      "filename": "gdb/procfs.c",
      "status": "modified",
      "additions": 26,
      "deletions": 23,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/procfs.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -160,6 +160,8 @@ class procfs_target final : public inf_child_target\n \n   int can_use_hw_breakpoint (enum bptype, int, int) override;\n   bool stopped_data_address (CORE_ADDR *) override;\n+\n+  void procfs_init_inferior (int pid);\n };\n \n static procfs_target the_procfs_target;\n@@ -1315,6 +1317,7 @@ proc_set_current_signal (procinfo *pi, int signo)\n     char sinfo[sizeof (siginfo_t)];\n   } arg;\n   siginfo_t mysinfo;\n+  process_stratum_target *wait_target;\n   ptid_t wait_ptid;\n   struct target_waitstatus wait_status;\n \n@@ -1327,8 +1330,9 @@ proc_set_current_signal (procinfo *pi, int signo)\n     pi = find_procinfo_or_die (pi->pid, 0);\n \n   /* The pointer is just a type alias.  */\n-  get_last_target_status (&wait_ptid, &wait_status);\n-  if (wait_ptid == inferior_ptid\n+  get_last_target_status (&wait_target, &wait_ptid, &wait_status);\n+  if (wait_target == &the_procfs_target\n+      && wait_ptid == inferior_ptid\n       && wait_status.kind == TARGET_WAITKIND_STOPPED\n       && wait_status.value.sig == gdb_signal_from_host (signo)\n       && proc_get_status (pi)\n@@ -1987,7 +1991,7 @@ do_attach (ptid_t ptid)\n \n   /* Add it to gdb's thread list.  */\n   ptid = ptid_t (pi->pid, lwpid, 0);\n-  add_thread (ptid);\n+  add_thread (&the_procfs_target, ptid);\n \n   return ptid;\n }\n@@ -2285,7 +2289,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t    if (print_thread_events)\n \t\t      printf_unfiltered (_(\"[%s exited]\\n\"),\n \t\t\t\t\t target_pid_to_str (retval).c_str ());\n-\t\t    delete_thread (find_thread_ptid (retval));\n+\t\t    delete_thread (find_thread_ptid (this, retval));\n \t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n \t\t    return retval;\n \t\t  }\n@@ -2307,7 +2311,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t    if (!proc_run_process (pi, 0, 0))\n \t\t      proc_error (pi, \"target_wait, run_process\", __LINE__);\n \n-\t\t    inf = find_inferior_pid (pi->pid);\n+\t\t    inf = find_inferior_pid (this, pi->pid);\n \t\t    if (inf->attach_flag)\n \t\t      {\n \t\t\t/* Don't call wait: simulate waiting for exit,\n@@ -2394,8 +2398,8 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n \t\t    temp_ptid = ptid_t (pi->pid, temp_tid, 0);\n \t\t    /* If not in GDB's thread list, add it.  */\n-\t\t    if (!in_thread_list (temp_ptid))\n-\t\t      add_thread (temp_ptid);\n+\t\t    if (!in_thread_list (this, temp_ptid))\n+\t\t      add_thread (this, temp_ptid);\n \n \t\t    /* Return to WFI, but tell it to immediately resume.  */\n \t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n@@ -2406,7 +2410,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t    if (print_thread_events)\n \t\t      printf_unfiltered (_(\"[%s exited]\\n\"),\n \t\t\t\t\t target_pid_to_str (retval).c_str ());\n-\t\t    delete_thread (find_thread_ptid (retval));\n+\t\t    delete_thread (find_thread_ptid (this, retval));\n \t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n \t\t    return retval;\n \t\t  }\n@@ -2463,8 +2467,8 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n \t\t    /* If not in GDB's thread list, add it.  */\n \t\t    temp_ptid = ptid_t (pi->pid, temp_tid, 0);\n-\t\t    if (!in_thread_list (temp_ptid))\n-\t\t      add_thread (temp_ptid);\n+\t\t    if (!in_thread_list (this, temp_ptid))\n+\t\t      add_thread (this, temp_ptid);\n \n \t\t    status->kind = TARGET_WAITKIND_STOPPED;\n \t\t    status->value.sig = GDB_SIGNAL_0;\n@@ -2492,12 +2496,12 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t threads database, add it.  */\n \t      if (retval.pid () > 0\n \t\t  && retval != inferior_ptid\n-\t\t  && !in_thread_list (retval))\n+\t\t  && !in_thread_list (this, retval))\n \t\t{\n \t\t  /* We have a new thread.  We need to add it both to\n \t\t     GDB's list and to our own.  If we don't create a\n \t\t     procinfo, resume may be unhappy later.  */\n-\t\t  add_thread (retval);\n+\t\t  add_thread (this, retval);\n \t\t  if (find_procinfo (retval.pid (),\n \t\t\t\t     retval.lwp ()) == NULL)\n \t\t    create_procinfo (retval.pid (),\n@@ -2850,17 +2854,17 @@ procfs_target::mourn_inferior ()\n    whatever is necessary to make the child ready to be debugged, and\n    then wait for the child to synchronize.  */\n \n-static void\n-procfs_init_inferior (struct target_ops *ops, int pid)\n+void\n+procfs_target::procfs_init_inferior (int pid)\n {\n   procinfo *pi;\n   int fail;\n   int lwpid;\n \n   /* This routine called on the parent side (GDB side)\n      after GDB forks the inferior.  */\n-  if (!target_is_pushed (ops))\n-    push_target (ops);\n+  if (!target_is_pushed (this))\n+    push_target (this);\n \n   pi = create_procinfo (pid, 0);\n   if (pi == NULL)\n@@ -2921,8 +2925,7 @@ procfs_init_inferior (struct target_ops *ops, int pid)\n   /* We already have a main thread registered in the thread table at\n      this point, but it didn't have any lwp info yet.  Notify the core\n      about it.  This changes inferior_ptid as well.  */\n-  thread_change_ptid (ptid_t (pid),\n-\t\t      ptid_t (pid, lwpid, 0));\n+  thread_change_ptid (this, ptid_t (pid), ptid_t (pid, lwpid, 0));\n \n   gdb_startup_inferior (pid, START_INFERIOR_TRAPS_EXPECTED);\n }\n@@ -3089,9 +3092,9 @@ procfs_target::create_inferior (const char *exec_file,\n   /* We have something that executes now.  We'll be running through\n      the shell at this point (if startup-with-shell is true), but the\n      pid shouldn't change.  */\n-  add_thread_silent (ptid_t (pid));\n+  add_thread_silent (this, ptid_t (pid));\n \n-  procfs_init_inferior (this, pid);\n+  procfs_init_inferior (pid);\n }\n \n /* An observer for the \"inferior_created\" event.  */\n@@ -3108,9 +3111,9 @@ procfs_notice_thread (procinfo *pi, procinfo *thread, void *ptr)\n {\n   ptid_t gdb_threadid = ptid_t (pi->pid, thread->tid, 0);\n \n-  thread_info *thr = find_thread_ptid (gdb_threadid);\n+  thread_info *thr = find_thread_ptid (&the_procfs_target, gdb_threadid);\n   if (thr == NULL || thr->state == THREAD_EXITED)\n-    add_thread (gdb_threadid);\n+    add_thread (&the_procfs_target, gdb_threadid);\n \n   return 0;\n }\n@@ -3739,7 +3742,7 @@ procfs_do_thread_registers (bfd *obfd, ptid_t ptid,\n \t\t\t    char *note_data, int *note_size,\n \t\t\t    enum gdb_signal stop_signal)\n {\n-  struct regcache *regcache = get_thread_regcache (ptid);\n+  struct regcache *regcache = get_thread_regcache (&the_procfs_target, ptid);\n   gdb_gregset_t gregs;\n   gdb_fpregset_t fpregs;\n   unsigned long merged_pid;"
    },
    {
      "sha": "3be86b71daa3327e8920926928f119732eb5da64",
      "filename": "gdb/python/py-threadevent.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/python/py-threadevent.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/python/py-threadevent.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-threadevent.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -27,7 +27,9 @@ py_get_event_thread (ptid_t ptid)\n {\n   if (non_stop)\n     {\n-      thread_info *thread = find_thread_ptid (ptid);\n+      thread_info *thread\n+\t= find_thread_ptid (current_inferior ()->process_target (),\n+\t\t\t    ptid);\n       if (thread != nullptr)\n \treturn thread_to_thread_object (thread);\n       PyErr_SetString (PyExc_RuntimeError, \"Could not find event thread\");"
    },
    {
      "sha": "59fdfaba794694434f1e3a2e59164f5de0caa98e",
      "filename": "gdb/ravenscar-thread.c",
      "status": "modified",
      "additions": 10,
      "deletions": 5,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/ravenscar-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/ravenscar-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ravenscar-thread.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -219,6 +219,9 @@ get_base_thread_from_ravenscar_task (ptid_t ptid)\n void\n ravenscar_thread_target::update_inferior_ptid ()\n {\n+  process_stratum_target *proc_target\n+    = as_process_stratum_target (this->beneath ());\n+\n   int base_cpu;\n \n   m_base_ptid = inferior_ptid;\n@@ -239,8 +242,8 @@ ravenscar_thread_target::update_inferior_ptid ()\n   /* The running thread may not have been added to\n      system.tasking.debug's list yet; so ravenscar_update_thread_list\n      may not always add it to the thread list.  Add it here.  */\n-  if (!find_thread_ptid (inferior_ptid))\n-    add_thread (inferior_ptid);\n+  if (!find_thread_ptid (proc_target, inferior_ptid))\n+    add_thread (proc_target, inferior_ptid);\n }\n \n /* The Ravenscar Runtime exports a symbol which contains the ID of\n@@ -336,12 +339,14 @@ ravenscar_thread_target::wait (ptid_t ptid,\n \t\t\t       struct target_waitstatus *status,\n \t\t\t       int options)\n {\n+  process_stratum_target *beneath\n+    = as_process_stratum_target (this->beneath ());\n   ptid_t event_ptid;\n \n   inferior_ptid = m_base_ptid;\n   if (ptid != minus_one_ptid)\n     ptid = m_base_ptid;\n-  event_ptid = beneath ()->wait (ptid, status, 0);\n+  event_ptid = beneath->wait (ptid, status, 0);\n   /* Find any new threads that might have been created, and update\n      inferior_ptid to the active thread.\n \n@@ -367,8 +372,8 @@ ravenscar_thread_target::wait (ptid_t ptid,\n static void\n ravenscar_add_thread (struct ada_task_info *task)\n {\n-  if (find_thread_ptid (task->ptid) == NULL)\n-    add_thread (task->ptid);\n+  if (find_thread_ptid (current_inferior (), task->ptid) == NULL)\n+    add_thread (current_inferior ()->process_target (), task->ptid);\n }\n \n void"
    },
    {
      "sha": "7e5b7860df6ee5d8c7de9c00a45660b823827f1b",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 25,
      "deletions": 16,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -556,10 +556,11 @@ record_btrace_target::info_record ()\n \n   DEBUG (\"info\");\n \n-  tp = find_thread_ptid (inferior_ptid);\n-  if (tp == NULL)\n+  if (inferior_ptid == null_ptid)\n     error (_(\"No thread.\"));\n \n+  tp = inferior_thread ();\n+\n   validate_registers_access ();\n \n   btinfo = &tp->btrace;\n@@ -1373,7 +1374,8 @@ record_btrace_target::call_history_from (ULONGEST from, int size,\n enum record_method\n record_btrace_target::record_method (ptid_t ptid)\n {\n-  struct thread_info * const tp = find_thread_ptid (ptid);\n+  process_stratum_target *proc_target = current_inferior ()->process_target ();\n+  thread_info *const tp = find_thread_ptid (proc_target, ptid);\n \n   if (tp == NULL)\n     error (_(\"No thread.\"));\n@@ -1389,7 +1391,8 @@ record_btrace_target::record_method (ptid_t ptid)\n bool\n record_btrace_target::record_is_replaying (ptid_t ptid)\n {\n-  for (thread_info *tp : all_non_exited_threads (ptid))\n+  process_stratum_target *proc_target = current_inferior ()->process_target ();\n+  for (thread_info *tp : all_non_exited_threads (proc_target, ptid))\n     if (btrace_is_replaying (tp))\n       return true;\n \n@@ -1519,13 +1522,10 @@ record_btrace_target::remove_breakpoint (struct gdbarch *gdbarch,\n void\n record_btrace_target::fetch_registers (struct regcache *regcache, int regno)\n {\n-  struct btrace_insn_iterator *replay;\n-  struct thread_info *tp;\n-\n-  tp = find_thread_ptid (regcache->ptid ());\n+  thread_info *tp = find_thread_ptid (regcache->target (), regcache->ptid ());\n   gdb_assert (tp != NULL);\n \n-  replay = tp->btrace.replay;\n+  btrace_insn_iterator *replay = tp->btrace.replay;\n   if (replay != NULL && !record_btrace_generating_corefile)\n     {\n       const struct btrace_insn *insn;\n@@ -1966,6 +1966,8 @@ get_thread_current_frame_id (struct thread_info *tp)\n \n   switch_to_thread (tp);\n \n+  process_stratum_target *proc_target = tp->inf->process_target ();\n+\n   /* Clear the executing flag to allow changes to the current frame.\n      We are not actually running, yet.  We just started a reverse execution\n      command or a record goto command.\n@@ -1974,7 +1976,7 @@ get_thread_current_frame_id (struct thread_info *tp)\n      move the thread.  Since we need to recompute the stack, we temporarily\n      set EXECUTING to false.  */\n   executing = tp->executing;\n-  set_executing (inferior_ptid, false);\n+  set_executing (proc_target, inferior_ptid, false);\n \n   id = null_frame_id;\n   try\n@@ -1984,13 +1986,13 @@ get_thread_current_frame_id (struct thread_info *tp)\n   catch (const gdb_exception &except)\n     {\n       /* Restore the previous execution state.  */\n-      set_executing (inferior_ptid, executing);\n+      set_executing (proc_target, inferior_ptid, executing);\n \n       throw;\n     }\n \n   /* Restore the previous execution state.  */\n-  set_executing (inferior_ptid, executing);\n+  set_executing (proc_target, inferior_ptid, executing);\n \n   return id;\n }\n@@ -2154,11 +2156,14 @@ record_btrace_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n      record_btrace_wait below.\n \n      For all-stop targets, we only step INFERIOR_PTID and continue others.  */\n+\n+  process_stratum_target *proc_target = current_inferior ()->process_target ();\n+\n   if (!target_is_non_stop_p ())\n     {\n       gdb_assert (inferior_ptid.matches (ptid));\n \n-      for (thread_info *tp : all_non_exited_threads (ptid))\n+      for (thread_info *tp : all_non_exited_threads (proc_target, ptid))\n \t{\n \t  if (tp->ptid.matches (inferior_ptid))\n \t    record_btrace_resume_thread (tp, flag);\n@@ -2168,7 +2173,7 @@ record_btrace_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n     }\n   else\n     {\n-      for (thread_info *tp : all_non_exited_threads (ptid))\n+      for (thread_info *tp : all_non_exited_threads (proc_target, ptid))\n \trecord_btrace_resume_thread (tp, flag);\n     }\n \n@@ -2526,7 +2531,8 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     }\n \n   /* Keep a work list of moving threads.  */\n-  for (thread_info *tp : all_non_exited_threads (ptid))\n+  process_stratum_target *proc_target = current_inferior ()->process_target ();\n+  for (thread_info *tp : all_non_exited_threads (proc_target, ptid))\n     if ((tp->btrace.flags & (BTHR_MOVE | BTHR_STOP)) != 0)\n       moving.push_back (tp);\n \n@@ -2646,7 +2652,10 @@ record_btrace_target::stop (ptid_t ptid)\n     }\n   else\n     {\n-      for (thread_info *tp : all_non_exited_threads (ptid))\n+      process_stratum_target *proc_target\n+\t= current_inferior ()->process_target ();\n+\n+      for (thread_info *tp : all_non_exited_threads (proc_target, ptid))\n \t{\n \t  tp->btrace.flags &= ~BTHR_MOVE;\n \t  tp->btrace.flags |= BTHR_STOP;"
    },
    {
      "sha": "f759a5185fd2a02a0d7d1235fe9d0ea303c3de9d",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 9,
      "deletions": 2,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1228,6 +1228,8 @@ record_full_wait_1 (struct target_ops *ops,\n \t\t     interested in the event.  */\n \n \t\t  registers_changed ();\n+\t\t  switch_to_thread (current_inferior ()->process_target (),\n+\t\t\t\t    ret);\n \t\t  regcache = get_current_regcache ();\n \t\t  tmp_pc = regcache_read_pc (regcache);\n \t\t  const struct address_space *aspace = regcache->aspace ();\n@@ -1260,14 +1262,17 @@ record_full_wait_1 (struct target_ops *ops,\n \n                       if (gdbarch_software_single_step_p (gdbarch))\n \t\t\t{\n+\t\t\t  process_stratum_target *proc_target\n+\t\t\t    = current_inferior ()->process_target ();\n+\n \t\t\t  /* Try to insert the software single step breakpoint.\n \t\t\t     If insert success, set step to 0.  */\n-\t\t\t  set_executing (inferior_ptid, 0);\n+\t\t\t  set_executing (proc_target, inferior_ptid, 0);\n \t\t\t  reinit_frame_cache ();\n \n \t\t\t  step = !insert_single_step_breakpoints (gdbarch);\n \n-\t\t\t  set_executing (inferior_ptid, 1);\n+\t\t\t  set_executing (proc_target, inferior_ptid, 1);\n \t\t\t}\n \n \t\t      if (record_debug)\n@@ -1290,6 +1295,8 @@ record_full_wait_1 (struct target_ops *ops,\n     }\n   else\n     {\n+      switch_to_thread (current_inferior ()->process_target (),\n+\t\t\trecord_full_resume_ptid);\n       struct regcache *regcache = get_current_regcache ();\n       struct gdbarch *gdbarch = regcache->arch ();\n       const struct address_space *aspace = regcache->aspace ();"
    },
    {
      "sha": "b9f1b0a349fdbf0bf8cdf42352e41eb05c70fa2d",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 110,
      "deletions": 52,
      "changes": 162,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -196,10 +196,11 @@ reg_buffer::reg_buffer (gdbarch *gdbarch, bool has_pseudo)\n     }\n }\n \n-regcache::regcache (gdbarch *gdbarch, const address_space *aspace_)\n+regcache::regcache (process_stratum_target *target, gdbarch *gdbarch,\n+\t\t    const address_space *aspace_)\n /* The register buffers.  A read/write register cache can only hold\n    [0 .. gdbarch_num_regs).  */\n-  : detached_regcache (gdbarch, false), m_aspace (aspace_)\n+  : detached_regcache (gdbarch, false), m_aspace (aspace_), m_target (target)\n {\n   m_ptid = minus_one_ptid;\n }\n@@ -320,14 +321,19 @@ reg_buffer::assert_regnum (int regnum) const\n std::forward_list<regcache *> regcache::current_regcache;\n \n struct regcache *\n-get_thread_arch_aspace_regcache (ptid_t ptid, struct gdbarch *gdbarch,\n+get_thread_arch_aspace_regcache (process_stratum_target *target,\n+\t\t\t\t ptid_t ptid, struct gdbarch *gdbarch,\n \t\t\t\t struct address_space *aspace)\n {\n+  gdb_assert (target != nullptr);\n+\n   for (const auto &regcache : regcache::current_regcache)\n-    if (regcache->ptid () == ptid && regcache->arch () == gdbarch)\n+    if (regcache->target () == target\n+\t&& regcache->ptid () == ptid\n+\t&& regcache->arch () == gdbarch)\n       return regcache;\n \n-  regcache *new_regcache = new regcache (gdbarch, aspace);\n+  regcache *new_regcache = new regcache (target, gdbarch, aspace);\n \n   regcache::current_regcache.push_front (new_regcache);\n   new_regcache->set_ptid (ptid);\n@@ -336,34 +342,47 @@ get_thread_arch_aspace_regcache (ptid_t ptid, struct gdbarch *gdbarch,\n }\n \n struct regcache *\n-get_thread_arch_regcache (ptid_t ptid, struct gdbarch *gdbarch)\n+get_thread_arch_regcache (process_stratum_target *target, ptid_t ptid,\n+\t\t\t  struct gdbarch *gdbarch)\n {\n+  scoped_restore_current_inferior restore_current_inferior;\n+  set_current_inferior (find_inferior_ptid (target, ptid));\n   address_space *aspace = target_thread_address_space (ptid);\n \n-  return get_thread_arch_aspace_regcache  (ptid, gdbarch, aspace);\n+  return get_thread_arch_aspace_regcache (target, ptid, gdbarch, aspace);\n }\n \n+static process_stratum_target *current_thread_target;\n static ptid_t current_thread_ptid;\n static struct gdbarch *current_thread_arch;\n \n struct regcache *\n-get_thread_regcache (ptid_t ptid)\n+get_thread_regcache (process_stratum_target *target, ptid_t ptid)\n {\n-  if (!current_thread_arch || current_thread_ptid != ptid)\n+  if (!current_thread_arch\n+      || target != current_thread_target\n+      || current_thread_ptid != ptid)\n     {\n+      gdb_assert (ptid != null_ptid);\n+\n       current_thread_ptid = ptid;\n+      current_thread_target = target;\n+\n+      scoped_restore_current_inferior restore_current_inferior;\n+      set_current_inferior (find_inferior_ptid (target, ptid));\n       current_thread_arch = target_thread_architecture (ptid);\n     }\n \n-  return get_thread_arch_regcache (ptid, current_thread_arch);\n+  return get_thread_arch_regcache (target, ptid, current_thread_arch);\n }\n \n /* See regcache.h.  */\n \n struct regcache *\n get_thread_regcache (thread_info *thread)\n {\n-  return get_thread_regcache (thread->ptid);\n+  return get_thread_regcache (thread->inf->process_target (),\n+\t\t\t      thread->ptid);\n }\n \n struct regcache *\n@@ -377,7 +396,11 @@ get_current_regcache (void)\n struct regcache *\n get_thread_regcache_for_ptid (ptid_t ptid)\n {\n-  return get_thread_regcache (ptid);\n+  /* This function doesn't take a process_stratum_target parameter\n+     because it's a gdbsupport/ routine implemented by both gdb and\n+     gdbserver.  It always refers to a ptid of the current target.  */\n+  process_stratum_target *proc_target = current_inferior ()->process_target ();\n+  return get_thread_regcache (proc_target, ptid);\n }\n \n /* Observer for the target_changed event.  */\n@@ -412,29 +435,34 @@ regcache::regcache_thread_ptid_changed (ptid_t old_ptid, ptid_t new_ptid)\n    Indicate that registers may have changed, so invalidate the cache.  */\n \n void\n-registers_changed_ptid (ptid_t ptid)\n+registers_changed_ptid (process_stratum_target *target, ptid_t ptid)\n {\n   for (auto oit = regcache::current_regcache.before_begin (),\n \t it = std::next (oit);\n        it != regcache::current_regcache.end ();\n        )\n     {\n-      if ((*it)->ptid ().matches (ptid))\n+      struct regcache *regcache = *it;\n+      if ((target == nullptr || regcache->target () == target)\n+\t  && regcache->ptid ().matches (ptid))\n \t{\n-\t  delete *it;\n+\t  delete regcache;\n \t  it = regcache::current_regcache.erase_after (oit);\n \t}\n       else\n \toit = it++;\n     }\n \n-  if (current_thread_ptid.matches (ptid))\n+  if ((target == nullptr || current_thread_target == target)\n+      && current_thread_ptid.matches (ptid))\n     {\n+      current_thread_target = NULL;\n       current_thread_ptid = null_ptid;\n       current_thread_arch = NULL;\n     }\n \n-  if (inferior_ptid.matches (ptid))\n+  if ((target == nullptr || current_inferior ()->process_target () == target)\n+      && inferior_ptid.matches (ptid))\n     {\n       /* We just deleted the regcache of the current thread.  Need to\n \t forget about any frames we have cached, too.  */\n@@ -447,13 +475,13 @@ registers_changed_ptid (ptid_t ptid)\n void\n registers_changed_thread (thread_info *thread)\n {\n-  registers_changed_ptid (thread->ptid);\n+  registers_changed_ptid (thread->inf->process_target (), thread->ptid);\n }\n \n void\n registers_changed (void)\n {\n-  registers_changed_ptid (minus_one_ptid);\n+  registers_changed_ptid (nullptr, minus_one_ptid);\n }\n \n void\n@@ -1400,6 +1428,21 @@ class regcache_access : public regcache\n   }\n };\n \n+/* Wrapper around get_thread_arch_aspace_regcache that does some self checks.  */\n+\n+static void\n+test_get_thread_arch_aspace_regcache (process_stratum_target *target,\n+\t\t\t\t      ptid_t ptid, struct gdbarch *gdbarch,\n+\t\t\t\t      address_space *aspace)\n+{\n+  struct regcache *regcache\n+    = get_thread_arch_aspace_regcache (target, ptid, gdbarch, aspace);\n+  SELF_CHECK (regcache != NULL);\n+  SELF_CHECK (regcache->target () == target);\n+  SELF_CHECK (regcache->ptid () == ptid);\n+  SELF_CHECK (regcache->aspace () == aspace);\n+}\n+\n static void\n current_regcache_test (void)\n {\n@@ -1408,47 +1451,61 @@ current_regcache_test (void)\n \n   ptid_t ptid1 (1), ptid2 (2), ptid3 (3);\n \n-  /* Get regcache from ptid1, a new regcache is added to\n-     current_regcache.  */\n-  regcache *regcache = get_thread_arch_aspace_regcache (ptid1,\n-\t\t\t\t\t\t\ttarget_gdbarch (),\n-\t\t\t\t\t\t\tNULL);\n+  test_target_ops test_target1;\n+  test_target_ops test_target2;\n \n-  SELF_CHECK (regcache != NULL);\n-  SELF_CHECK (regcache->ptid () == ptid1);\n+  /* Get regcache from (target1,ptid1), a new regcache is added to\n+     current_regcache.  */\n+  test_get_thread_arch_aspace_regcache (&test_target1, ptid1,\n+\t\t\t\t\ttarget_gdbarch (),\n+\t\t\t\t\tNULL);\n   SELF_CHECK (regcache_access::current_regcache_size () == 1);\n \n-  /* Get regcache from ptid2, a new regcache is added to\n+  /* Get regcache from (target1,ptid2), a new regcache is added to\n      current_regcache.  */\n-  regcache = get_thread_arch_aspace_regcache (ptid2,\n-\t\t\t\t\t      target_gdbarch (),\n-\t\t\t\t\t      NULL);\n-  SELF_CHECK (regcache != NULL);\n-  SELF_CHECK (regcache->ptid () == ptid2);\n+  test_get_thread_arch_aspace_regcache (&test_target1, ptid2,\n+\t\t\t\t\ttarget_gdbarch (),\n+\t\t\t\t\tNULL);\n   SELF_CHECK (regcache_access::current_regcache_size () == 2);\n \n-  /* Get regcache from ptid3, a new regcache is added to\n+  /* Get regcache from (target1,ptid3), a new regcache is added to\n      current_regcache.  */\n-  regcache = get_thread_arch_aspace_regcache (ptid3,\n-\t\t\t\t\t      target_gdbarch (),\n-\t\t\t\t\t      NULL);\n-  SELF_CHECK (regcache != NULL);\n-  SELF_CHECK (regcache->ptid () == ptid3);\n+  test_get_thread_arch_aspace_regcache (&test_target1, ptid3,\n+\t\t\t\t\ttarget_gdbarch (),\n+\t\t\t\t\tNULL);\n   SELF_CHECK (regcache_access::current_regcache_size () == 3);\n \n-  /* Get regcache from ptid2 again, nothing is added to\n+  /* Get regcache from (target1,ptid2) again, nothing is added to\n      current_regcache.  */\n-  regcache = get_thread_arch_aspace_regcache (ptid2,\n-\t\t\t\t\t      target_gdbarch (),\n-\t\t\t\t\t      NULL);\n-  SELF_CHECK (regcache != NULL);\n-  SELF_CHECK (regcache->ptid () == ptid2);\n+  test_get_thread_arch_aspace_regcache (&test_target1, ptid2,\n+\t\t\t\t\ttarget_gdbarch (),\n+\t\t\t\t\tNULL);\n   SELF_CHECK (regcache_access::current_regcache_size () == 3);\n \n-  /* Mark ptid2 is changed, so regcache of ptid2 should be removed from\n-     current_regcache.  */\n-  registers_changed_ptid (ptid2);\n-  SELF_CHECK (regcache_access::current_regcache_size () == 2);\n+  /* Get regcache from (target2,ptid2), a new regcache is added to\n+     current_regcache, since this time we're using a differen\n+     target.  */\n+  test_get_thread_arch_aspace_regcache (&test_target2, ptid2,\n+\t\t\t\t\ttarget_gdbarch (),\n+\t\t\t\t\tNULL);\n+  SELF_CHECK (regcache_access::current_regcache_size () == 4);\n+\n+  /* Mark that (target1,ptid2) changed.  The regcache of (target1,\n+     ptid2) should be removed from current_regcache.  */\n+  registers_changed_ptid (&test_target1, ptid2);\n+  SELF_CHECK (regcache_access::current_regcache_size () == 3);\n+\n+  /* Get the regcache from (target2,ptid2) again, confirming the\n+     registers_changed_ptid call above did not delete it.  */\n+  test_get_thread_arch_aspace_regcache (&test_target2, ptid2,\n+\t\t\t\t\ttarget_gdbarch (),\n+\t\t\t\t\tNULL);\n+  SELF_CHECK (regcache_access::current_regcache_size () == 3);\n+\n+  /* Confirm that marking all regcaches of all targets as changed\n+     clears current_regcache.  */\n+  registers_changed_ptid (nullptr, minus_one_ptid);\n+  SELF_CHECK (regcache_access::current_regcache_size () == 0);\n }\n \n class target_ops_no_register : public test_target_ops\n@@ -1509,8 +1566,9 @@ target_ops_no_register::xfer_partial (enum target_object object,\n class readwrite_regcache : public regcache\n {\n public:\n-  readwrite_regcache (struct gdbarch *gdbarch)\n-    : regcache (gdbarch, nullptr)\n+  readwrite_regcache (process_stratum_target *target,\n+\t\t      struct gdbarch *gdbarch)\n+    : regcache (target, gdbarch, nullptr)\n   {}\n };\n \n@@ -1577,7 +1635,7 @@ cooked_read_test (struct gdbarch *gdbarch)\n \tbreak;\n     }\n \n-  readwrite_regcache readwrite (gdbarch);\n+  readwrite_regcache readwrite (&mock_target, gdbarch);\n   gdb::def_vector<gdb_byte> buf (register_size (gdbarch, nonzero_regnum));\n \n   readwrite.raw_read (nonzero_regnum, buf.data ());\n@@ -1710,7 +1768,7 @@ cooked_write_test (struct gdbarch *gdbarch)\n     }\n   } pop_targets;\n \n-  readwrite_regcache readwrite (gdbarch);\n+  readwrite_regcache readwrite (&mock_target, gdbarch);\n \n   const int num_regs = gdbarch_num_cooked_regs (gdbarch);\n "
    },
    {
      "sha": "b8561d714c9edb268539c33b57a01deef42c8ef1",
      "filename": "gdb/regcache.h",
      "status": "modified",
      "additions": 21,
      "deletions": 9,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/regcache.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/regcache.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -29,17 +29,20 @@ struct regset;\n struct gdbarch;\n struct address_space;\n class thread_info;\n+struct process_stratum_target;\n \n extern struct regcache *get_current_regcache (void);\n-extern struct regcache *get_thread_regcache (ptid_t ptid);\n+extern struct regcache *get_thread_regcache (process_stratum_target *target,\n+\t\t\t\t\t     ptid_t ptid);\n \n /* Get the regcache of THREAD.  */\n extern struct regcache *get_thread_regcache (thread_info *thread);\n \n-extern struct regcache *get_thread_arch_regcache (ptid_t, struct gdbarch *);\n-extern struct regcache *get_thread_arch_aspace_regcache (ptid_t,\n-\t\t\t\t\t\t\t struct gdbarch *,\n-\t\t\t\t\t\t\t struct address_space *);\n+extern struct regcache *get_thread_arch_regcache\n+  (process_stratum_target *targ, ptid_t, struct gdbarch *);\n+extern struct regcache *get_thread_arch_aspace_regcache\n+  (process_stratum_target *target, ptid_t,\n+   struct gdbarch *, struct address_space *);\n \n extern enum register_status\n   regcache_raw_read_signed (struct regcache *regcache,\n@@ -385,13 +388,19 @@ class regcache : public detached_regcache\n     this->m_ptid = ptid;\n   }\n \n+  process_stratum_target *target () const\n+  {\n+    return m_target;\n+  }\n+\n /* Dump the contents of a register from the register cache to the target\n    debug.  */\n   void debug_print_register (const char *func, int regno);\n \n   static void regcache_thread_ptid_changed (ptid_t old_ptid, ptid_t new_ptid);\n protected:\n-  regcache (gdbarch *gdbarch, const address_space *aspace_);\n+  regcache (process_stratum_target *target, gdbarch *gdbarch,\n+\t    const address_space *aspace);\n \n   static std::forward_list<regcache *> current_regcache;\n \n@@ -421,14 +430,16 @@ class regcache : public detached_regcache\n \n   /* If this is a read-write cache, which thread's registers is\n      it connected to?  */\n+  process_stratum_target *m_target;\n   ptid_t m_ptid;\n \n   friend struct regcache *\n-  get_thread_arch_aspace_regcache (ptid_t ptid, struct gdbarch *gdbarch,\n+  get_thread_arch_aspace_regcache (process_stratum_target *target, ptid_t ptid,\n+\t\t\t\t   struct gdbarch *gdbarch,\n \t\t\t\t   struct address_space *aspace);\n \n   friend void\n-  registers_changed_ptid (ptid_t ptid);\n+  registers_changed_ptid (process_stratum_target *target, ptid_t ptid);\n };\n \n class readonly_detached_regcache : public readable_regcache\n@@ -451,7 +462,8 @@ class readonly_detached_regcache : public readable_regcache\n };\n \n extern void registers_changed (void);\n-extern void registers_changed_ptid (ptid_t);\n+extern void registers_changed_ptid (process_stratum_target *target,\n+\t\t\t\t    ptid_t ptid);\n \n /* Indicate that registers of THREAD may have changed, so invalidate\n    the cache.  */"
    },
    {
      "sha": "7453a3b31a7bff7ba90adf3c2c346bae0e6d70e9",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 125,
      "deletions": 96,
      "changes": 221,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -278,6 +278,9 @@ class remote_state\n \n   /* The status of the stub support for the various vCont actions.  */\n   vCont_action_support supports_vCont;\n+  /* Whether vCont support was probed already.  This is a workaround\n+     until packet_support is per-connection.  */\n+  bool supports_vCont_probed;\n \n   /* True if the user has pressed Ctrl-C, but the target hasn't\n      responded to that.  */\n@@ -537,6 +540,8 @@ class remote_target : public process_stratum_target\n \n   void async (int) override;\n \n+  int async_wait_fd () override;\n+\n   void thread_events (int) override;\n \n   int can_do_single_step () override;\n@@ -1026,7 +1031,7 @@ static void remote_console_output (const char *msg);\n \n static void remote_btrace_reset (remote_state *rs);\n \n-static void remote_unpush_and_throw (void);\n+static void remote_unpush_and_throw (remote_target *target);\n \n /* For \"remote\".  */\n \n@@ -1376,7 +1381,7 @@ remote_arch_state::remote_arch_state (struct gdbarch *gdbarch)\n static remote_target *\n get_current_remote_target ()\n {\n-  target_ops *proc_target = find_target_at (process_stratum);\n+  target_ops *proc_target = current_inferior ()->process_target ();\n   return dynamic_cast<remote_target *> (proc_target);\n }\n \n@@ -1657,6 +1662,7 @@ show_memory_packet_size (struct memory_packet_config *config)\n     }\n }\n \n+/* FIXME: needs to be per-remote-target.  */\n static struct memory_packet_config memory_write_packet_config =\n {\n   \"memory-write-packet-size\",\n@@ -1730,6 +1736,7 @@ remote_target::get_memory_write_packet_size ()\n   return get_memory_packet_size (&memory_write_packet_config);\n }\n \n+/* FIXME: needs to be per-remote-target.  */\n static struct memory_packet_config memory_read_packet_config =\n {\n   \"memory-read-packet-size\",\n@@ -2086,6 +2093,9 @@ enum {\n   PACKET_MAX\n };\n \n+/* FIXME: needs to be per-remote-target.  Ignoring this for now,\n+   assuming all remote targets are the same server (thus all support\n+   the same packets).  */\n static struct packet_config remote_protocol_packets[PACKET_MAX];\n \n /* Returns the packet's corresponding \"set remote foo-packet\" command\n@@ -2387,6 +2397,7 @@ remote_target::remote_add_inferior (bool fake_pid_p, int pid, int attached,\n \t  inf = add_inferior_with_spaces ();\n \t}\n       switch_to_inferior_no_thread (inf);\n+      push_target (this);\n       inferior_appeared (inf, pid);\n     }\n \n@@ -2402,7 +2413,8 @@ remote_target::remote_add_inferior (bool fake_pid_p, int pid, int attached,\n }\n \n static remote_thread_info *get_remote_thread_info (thread_info *thread);\n-static remote_thread_info *get_remote_thread_info (ptid_t ptid);\n+static remote_thread_info *get_remote_thread_info (remote_target *target,\n+\t\t\t\t\t\t   ptid_t ptid);\n \n /* Add thread PTID to GDB's thread list.  Tag it as executing/running\n    according to RUNNING.  */\n@@ -2420,13 +2432,13 @@ remote_target::remote_add_thread (ptid_t ptid, bool running, bool executing)\n      might be confusing to the user.  Be silent then, preserving the\n      age old behavior.  */\n   if (rs->starting_up)\n-    thread = add_thread_silent (ptid);\n+    thread = add_thread_silent (this, ptid);\n   else\n-    thread = add_thread (ptid);\n+    thread = add_thread (this, ptid);\n \n   get_remote_thread_info (thread)->vcont_resumed = executing;\n-  set_executing (ptid, executing);\n-  set_running (ptid, running);\n+  set_executing (this, ptid, executing);\n+  set_running (this, ptid, running);\n \n   return thread;\n }\n@@ -2449,7 +2461,7 @@ remote_target::remote_notice_new_inferior (ptid_t currthread, int executing)\n   /* If this is a new thread, add it to GDB's thread list.\n      If we leave it up to WFI to do this, bad things will happen.  */\n \n-  thread_info *tp = find_thread_ptid (currthread);\n+  thread_info *tp = find_thread_ptid (this, currthread);\n   if (tp != NULL && tp->state == THREAD_EXITED)\n     {\n       /* We're seeing an event on a thread id we knew had exited.\n@@ -2458,7 +2470,7 @@ remote_target::remote_notice_new_inferior (ptid_t currthread, int executing)\n       return;\n     }\n \n-  if (!in_thread_list (currthread))\n+  if (!in_thread_list (this, currthread))\n     {\n       struct inferior *inf = NULL;\n       int pid = currthread.pid ();\n@@ -2471,8 +2483,8 @@ remote_target::remote_notice_new_inferior (ptid_t currthread, int executing)\n \t     stub doesn't support qC.  This is the first stop reported\n \t     after an attach, so this is the main thread.  Update the\n \t     ptid in the thread list.  */\n-\t  if (in_thread_list (ptid_t (pid)))\n-\t    thread_change_ptid (inferior_ptid, currthread);\n+\t  if (in_thread_list (this, ptid_t (pid)))\n+\t    thread_change_ptid (this, inferior_ptid, currthread);\n \t  else\n \t    {\n \t      remote_add_thread (currthread, running, executing);\n@@ -2488,15 +2500,15 @@ remote_target::remote_notice_new_inferior (ptid_t currthread, int executing)\n \t     doesn't support qC.  This is the first stop reported\n \t     after an attach, so this is the main thread.  Update the\n \t     ptid in the thread list.  */\n-\t  thread_change_ptid (inferior_ptid, currthread);\n+\t  thread_change_ptid (this, inferior_ptid, currthread);\n \t  return;\n \t}\n \n       /* When connecting to a target remote, or to a target\n \t extended-remote which already was debugging an inferior, we\n \t may not know about it yet.  Add it before adding its child\n \t thread, so notifications are emitted in a sensible order.  */\n-      if (find_inferior_pid (currthread.pid ()) == NULL)\n+      if (find_inferior_pid (this, currthread.pid ()) == NULL)\n \t{\n \t  struct remote_state *rs = get_remote_state ();\n \t  bool fake_pid_p = !remote_multi_process_p (rs);\n@@ -2536,10 +2548,12 @@ get_remote_thread_info (thread_info *thread)\n   return static_cast<remote_thread_info *> (thread->priv.get ());\n }\n \n+/* Return PTID's private thread data, creating it if necessary.  */\n+\n static remote_thread_info *\n-get_remote_thread_info (ptid_t ptid)\n+get_remote_thread_info (remote_target *target, ptid_t ptid)\n {\n-  thread_info *thr = find_thread_ptid (ptid);\n+  thread_info *thr = find_thread_ptid (target, ptid);\n   return get_remote_thread_info (thr);\n }\n \n@@ -3799,6 +3813,9 @@ remote_target::update_thread_list ()\n \t target.  */\n       for (thread_info *tp : all_threads_safe ())\n \t{\n+\t  if (tp->inf->process_target () != this)\n+\t    continue;\n+\n \t  if (!context.contains_thread (tp->ptid))\n \t    {\n \t      /* Not found.  */\n@@ -3824,7 +3841,7 @@ remote_target::update_thread_list ()\n \n \t      remote_notice_new_inferior (item.ptid, executing);\n \n-\t      thread_info *tp = find_thread_ptid (item.ptid);\n+\t      thread_info *tp = find_thread_ptid (this, item.ptid);\n \t      remote_thread_info *info = get_remote_thread_info (tp);\n \t      info->core = item.core;\n \t      info->extra = std::move (item.extra);\n@@ -4026,13 +4043,6 @@ remote_target::close ()\n   /* Make sure we leave stdin registered in the event loop.  */\n   terminal_ours ();\n \n-  /* We don't have a connection to the remote stub anymore.  Get rid\n-     of all the inferiors and their threads we were controlling.\n-     Reset inferior_ptid to null_ptid first, as otherwise has_stack_frame\n-     will be unable to find the thread corresponding to (pid, 0, 0).  */\n-  inferior_ptid = null_ptid;\n-  discard_all_inferiors ();\n-\n   trace_reset_local_state ();\n \n   delete this;\n@@ -4338,7 +4348,7 @@ remote_target::add_current_inferior_and_thread (char *wait_status)\n   /* Add the main thread and switch to it.  Don't try reading\n      registers yet, since we haven't fetched the target description\n      yet.  */\n-  thread_info *tp = add_thread_silent (curr_ptid);\n+  thread_info *tp = add_thread_silent (this, curr_ptid);\n   switch_to_thread_no_regs (tp);\n }\n \n@@ -4414,7 +4424,7 @@ remote_target::process_initial_stop_replies (int from_tty)\n       if (ignore_event)\n \tcontinue;\n \n-      struct thread_info *evthread = find_thread_ptid (event_ptid);\n+      thread_info *evthread = find_thread_ptid (this, event_ptid);\n \n       if (ws.kind == TARGET_WAITKIND_STOPPED)\n \t{\n@@ -4434,14 +4444,14 @@ remote_target::process_initial_stop_replies (int from_tty)\n \t  || ws.value.sig != GDB_SIGNAL_0)\n \tevthread->suspend.waitstatus_pending_p = 1;\n \n-      set_executing (event_ptid, 0);\n-      set_running (event_ptid, 0);\n+      set_executing (this, event_ptid, 0);\n+      set_running (this, event_ptid, 0);\n       get_remote_thread_info (evthread)->vcont_resumed = 0;\n     }\n \n   /* \"Notice\" the new inferiors before anything related to\n      registers/memory.  */\n-  for (inferior *inf : all_non_exited_inferiors ())\n+  for (inferior *inf : all_non_exited_inferiors (this))\n     {\n       inf->needs_setup = 1;\n \n@@ -4462,7 +4472,7 @@ remote_target::process_initial_stop_replies (int from_tty)\n \n       /* If all threads of an inferior were already stopped, we\n \t haven't setup the inferior yet.  */\n-      for (inferior *inf : all_non_exited_inferiors ())\n+      for (inferior *inf : all_non_exited_inferiors (this))\n \t{\n \t  if (inf->needs_setup)\n \t    {\n@@ -4476,7 +4486,7 @@ remote_target::process_initial_stop_replies (int from_tty)\n   /* Now go over all threads that are stopped, and print their current\n      frame.  If all-stop, then if there's a signalled thread, pick\n      that as current.  */\n-  for (thread_info *thread : all_non_exited_threads ())\n+  for (thread_info *thread : all_non_exited_threads (this))\n     {\n       if (first == NULL)\n \tfirst = thread;\n@@ -4515,7 +4525,7 @@ remote_target::process_initial_stop_replies (int from_tty)\n   /* For \"info program\".  */\n   thread_info *thread = inferior_thread ();\n   if (thread->state == THREAD_STOPPED)\n-    set_last_target_status (inferior_ptid, thread->suspend.waitstatus);\n+    set_last_target_status (this, inferior_ptid, thread->suspend.waitstatus);\n }\n \n /* Start the remote connection and sync state.  */\n@@ -4688,7 +4698,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n       /* Let the stub know that we want it to return the thread.  */\n       set_continue_thread (minus_one_ptid);\n \n-      if (thread_count () == 0)\n+      if (thread_count (this) == 0)\n \t{\n \t  /* Target has no concept of threads at all.  GDB treats\n \t     non-threaded target as single-threaded; add a main\n@@ -4714,14 +4724,15 @@ remote_target::start_remote (int from_tty, int extended_p)\n \t\t                    \"warning: couldn't determine remote \"\n \t\t\t\t    \"current thread; picking first in list.\\n\");\n \n-\t      for (thread_info *tp : all_non_exited_threads ())\n+\t      for (thread_info *tp : all_non_exited_threads (this,\n+\t\t\t\t\t\t\t     minus_one_ptid))\n \t\t{\n \t\t  switch_to_thread (tp);\n \t\t  break;\n \t\t}\n \t    }\n \t  else\n-\t    switch_to_thread (find_thread_ptid (curr_thread));\n+\t    switch_to_thread (find_thread_ptid (this, curr_thread));\n \t}\n \n       /* init_wait_for_inferior should be called before get_offsets in order\n@@ -4780,7 +4791,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n \t  remote_notif_get_pending_events (notif);\n \t}\n \n-      if (thread_count () == 0)\n+      if (thread_count (this) == 0)\n \t{\n \t  if (!extended_p)\n \t    error (_(\"The target is not running (try extended-remote?)\"));\n@@ -5434,7 +5445,7 @@ remote_target::remote_serial_quit_handler ()\n \t{\n \t  if (query (_(\"The target is not responding to GDB commands.\\n\"\n \t\t       \"Stop debugging it? \")))\n-\t    remote_unpush_and_throw ();\n+\t    remote_unpush_and_throw (this);\n \t}\n       /* If ^C has already been sent once, offer to disconnect.  */\n       else if (!target_terminal::is_ours () && rs->ctrlc_pending_p)\n@@ -5458,19 +5469,29 @@ remote_serial_quit_handler ()\n   curr_quit_handler_target->remote_serial_quit_handler ();\n }\n \n-/* Remove any of the remote.c targets from target stack.  Upper targets depend\n-   on it so remove them first.  */\n+/* Remove the remote target from the target stack of each inferior\n+   that is using it.  Upper targets depend on it so remove them\n+   first.  */\n \n static void\n-remote_unpush_target (void)\n+remote_unpush_target (remote_target *target)\n {\n-  pop_all_targets_at_and_above (process_stratum);\n+  /* We have to unpush the target from all inferiors, even those that\n+     aren't running.  */\n+  scoped_restore_current_inferior restore_current_inferior;\n+\n+  for (inferior *inf : all_inferiors (target))\n+    {\n+      switch_to_inferior_no_thread (inf);\n+      pop_all_targets_at_and_above (process_stratum);\n+      generic_mourn_inferior ();\n+    }\n }\n \n static void\n-remote_unpush_and_throw (void)\n+remote_unpush_and_throw (remote_target *target)\n {\n-  remote_unpush_target ();\n+  remote_unpush_target (target);\n   throw_error (TARGET_CLOSE_ERROR, _(\"Disconnected from target.\"));\n }\n \n@@ -5487,7 +5508,7 @@ remote_target::open_1 (const char *name, int from_tty, int extended_p)\n   /* If we're connected to a running target, target_preopen will kill it.\n      Ask this question first, before target_preopen has a chance to kill\n      anything.  */\n-  if (curr_remote != NULL && !have_inferiors ())\n+  if (curr_remote != NULL && !target_has_execution)\n     {\n       if (from_tty\n \t  && !query (_(\"Already connected to a remote target.  Disconnect? \")))\n@@ -5616,7 +5637,7 @@ remote_target::open_1 (const char *name, int from_tty, int extended_p)\n \t/* Pop the partially set up target - unless something else did\n \t   already before throwing the exception.  */\n \tif (ex.error != TARGET_CLOSE_ERROR)\n-\t  remote_unpush_target ();\n+\t  remote_unpush_target (remote);\n \tthrow;\n       }\n   }\n@@ -5680,10 +5701,10 @@ remote_target::remote_detach_1 (inferior *inf, int from_tty)\n   remote_detach_pid (pid);\n \n   /* Exit only if this is the only active inferior.  */\n-  if (from_tty && !rs->extended && number_of_live_inferiors () == 1)\n+  if (from_tty && !rs->extended && number_of_live_inferiors (this) == 1)\n     puts_filtered (_(\"Ending remote debugging.\\n\"));\n \n-  struct thread_info *tp = find_thread_ptid (inferior_ptid);\n+  thread_info *tp = find_thread_ptid (this, inferior_ptid);\n \n   /* Check to see if we are detaching a fork parent.  Note that if we\n      are detaching a fork child, tp == NULL.  */\n@@ -5785,10 +5806,10 @@ remote_target::disconnect (const char *args, int from_tty)\n     error (_(\"Argument given to \\\"disconnect\\\" when remotely debugging.\"));\n \n   /* Make sure we unpush even the extended remote targets.  Calling\n-     target_mourn_inferior won't unpush, and remote_mourn won't\n-     unpush if there is more than one inferior left.  */\n-  unpush_target (this);\n-  generic_mourn_inferior ();\n+     target_mourn_inferior won't unpush, and\n+     remote_target::mourn_inferior won't unpush if there is more than\n+     one inferior left.  */\n+  remote_unpush_target (this);\n \n   if (from_tty)\n     puts_filtered (\"Ending remote debugging.\\n\");\n@@ -5876,10 +5897,10 @@ extended_remote_target::attach (const char *args, int from_tty)\n       inferior_ptid = remote_current_thread (inferior_ptid);\n \n       /* Add the main thread to the thread list.  */\n-      thread_info *thr = add_thread_silent (inferior_ptid);\n+      thread_info *thr = add_thread_silent (this, inferior_ptid);\n       /* Don't consider the thread stopped until we've processed the\n \t saved stop reply.  */\n-      set_executing (thr->ptid, true);\n+      set_executing (this, thr->ptid, true);\n     }\n \n   /* Next, if the target can specify a description, read it.  We do\n@@ -5981,6 +6002,7 @@ remote_target::remote_vcont_probe ()\n     }\n \n   packet_ok (rs->buf, &remote_protocol_packets[PACKET_vCont]);\n+  rs->supports_vCont_probed = true;\n }\n \n /* Helper function for building \"vCont\" resumptions.  Write a\n@@ -6018,10 +6040,10 @@ remote_target::append_resumption (char *p, char *endp,\n \t{\n \t  /* If we don't know about the target thread's tid, then\n \t     we're resuming magic_null_ptid (see caller).  */\n-\t  tp = find_thread_ptid (magic_null_ptid);\n+\t  tp = find_thread_ptid (this, magic_null_ptid);\n \t}\n       else\n-\ttp = find_thread_ptid (ptid);\n+\ttp = find_thread_ptid (this, ptid);\n       gdb_assert (tp != NULL);\n \n       if (tp->control.may_range_step)\n@@ -6084,7 +6106,7 @@ char *\n remote_target::append_pending_thread_resumptions (char *p, char *endp,\n \t\t\t\t\t\t  ptid_t ptid)\n {\n-  for (thread_info *thread : all_non_exited_threads (ptid))\n+  for (thread_info *thread : all_non_exited_threads (this, ptid))\n     if (inferior_ptid != thread->ptid\n \t&& thread->suspend.stop_signal != GDB_SIGNAL_0)\n       {\n@@ -6117,7 +6139,7 @@ remote_target::remote_resume_with_hc (ptid_t ptid, int step,\n   else\n     set_continue_thread (ptid);\n \n-  for (thread_info *thread : all_non_exited_threads ())\n+  for (thread_info *thread : all_non_exited_threads (this))\n     resume_clear_thread_private_info (thread);\n \n   buf = rs->buf.data ();\n@@ -6254,9 +6276,9 @@ remote_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n       remote_thread_info *remote_thr;\n \n       if (minus_one_ptid == ptid || ptid.is_pid ())\n-\tremote_thr = get_remote_thread_info (inferior_ptid);\n+\tremote_thr = get_remote_thread_info (this, inferior_ptid);\n       else\n-\tremote_thr = get_remote_thread_info (ptid);\n+\tremote_thr = get_remote_thread_info (this, ptid);\n \n       remote_thr->last_resume_step = step;\n       remote_thr->last_resume_sig = siggnal;\n@@ -6488,7 +6510,7 @@ remote_target::commit_resume ()\n   may_global_wildcard_vcont = 1;\n \n   /* And assume every process is individually wildcard-able too.  */\n-  for (inferior *inf : all_non_exited_inferiors ())\n+  for (inferior *inf : all_non_exited_inferiors (this))\n     {\n       remote_inferior *priv = get_remote_inferior (inf);\n \n@@ -6499,7 +6521,7 @@ remote_target::commit_resume ()\n      disable process and global wildcard resumes appropriately.  */\n   check_pending_events_prevent_wildcard_vcont (&may_global_wildcard_vcont);\n \n-  for (thread_info *tp : all_non_exited_threads ())\n+  for (thread_info *tp : all_non_exited_threads (this))\n     {\n       /* If a thread of a process is not meant to be resumed, then we\n \t can't wildcard that process.  */\n@@ -6528,7 +6550,7 @@ remote_target::commit_resume ()\n   struct vcont_builder vcont_builder (this);\n \n   /* Threads first.  */\n-  for (thread_info *tp : all_non_exited_threads ())\n+  for (thread_info *tp : all_non_exited_threads (this))\n     {\n       remote_thread_info *remote_thr = get_remote_thread_info (tp);\n \n@@ -6557,7 +6579,7 @@ remote_target::commit_resume ()\n      supposed to be resumed.  */\n   any_process_wildcard = 0;\n \n-  for (inferior *inf : all_non_exited_inferiors ())\n+  for (inferior *inf : all_non_exited_inferiors (this))\n     {\n       if (get_remote_inferior (inf)->may_wildcard_vcont)\n \t{\n@@ -6578,7 +6600,7 @@ remote_target::commit_resume ()\n \t}\n       else\n \t{\n-\t  for (inferior *inf : all_non_exited_inferiors ())\n+\t  for (inferior *inf : all_non_exited_inferiors (this))\n \t    {\n \t      if (get_remote_inferior (inf)->may_wildcard_vcont)\n \t\t{\n@@ -6605,7 +6627,10 @@ remote_target::remote_stop_ns (ptid_t ptid)\n   char *p = rs->buf.data ();\n   char *endp = p + get_remote_packet_size ();\n \n-  if (packet_support (PACKET_vCont) == PACKET_SUPPORT_UNKNOWN)\n+  /* FIXME: This supports_vCont_probed check is a workaround until\n+     packet_support is per-connection.  */\n+  if (packet_support (PACKET_vCont) == PACKET_SUPPORT_UNKNOWN\n+      || !rs->supports_vCont_probed)\n     remote_vcont_probe ();\n \n   if (!rs->supports_vCont.t)\n@@ -6762,7 +6787,7 @@ remote_target::interrupt_query ()\n       if (query (_(\"The target is not responding to interrupt requests.\\n\"\n \t\t   \"Stop debugging it? \")))\n \t{\n-\t  remote_unpush_target ();\n+\t  remote_unpush_target (this);\n \t  throw_error (TARGET_CLOSE_ERROR, _(\"Disconnected from target.\"));\n \t}\n     }\n@@ -6969,7 +6994,7 @@ remote_target::remove_new_fork_children (threads_listing_context *context)\n \n   /* For any threads stopped at a fork event, remove the corresponding\n      fork child threads from the CONTEXT list.  */\n-  for (thread_info *thread : all_non_exited_threads ())\n+  for (thread_info *thread : all_non_exited_threads (this))\n     {\n       struct target_waitstatus *ws = thread_pending_fork_status (thread);\n \n@@ -7011,7 +7036,7 @@ remote_target::check_pending_events_prevent_wildcard_vcont\n \t  || event->ws.kind == TARGET_WAITKIND_VFORKED)\n \t*may_global_wildcard = 0;\n \n-      struct inferior *inf = find_inferior_ptid (event->ptid);\n+      struct inferior *inf = find_inferior_ptid (this, event->ptid);\n \n       /* This may be the first time we heard about this process.\n \t Regardless, we must not do a global wildcard resume, otherwise\n@@ -7377,9 +7402,10 @@ Packet: '%s'\\n\"),\n \n \t\t  if (rsa == NULL)\n \t\t    {\n-\t\t      inferior *inf = (event->ptid == null_ptid\n-\t\t\t\t       ? NULL\n-\t\t\t\t       : find_inferior_ptid (event->ptid));\n+\t\t      inferior *inf\n+\t\t\t= (event->ptid == null_ptid\n+\t\t\t   ? NULL\n+\t\t\t   : find_inferior_ptid (this, event->ptid));\n \t\t      /* If this is the first time we learn anything\n \t\t\t about this process, skip the registers\n \t\t\t included in this packet, since we don't yet\n@@ -7639,7 +7665,7 @@ remote_target::process_stop_reply (struct stop_reply *stop_reply,\n       if (!stop_reply->regcache.empty ())\n \t{\n \t  struct regcache *regcache\n-\t    = get_thread_arch_regcache (ptid, stop_reply->arch);\n+\t    = get_thread_arch_regcache (this, ptid, stop_reply->arch);\n \n \t  for (cached_reg_t &reg : stop_reply->regcache)\n \t    {\n@@ -7651,7 +7677,7 @@ remote_target::process_stop_reply (struct stop_reply *stop_reply,\n \t}\n \n       remote_notice_new_inferior (ptid, 0);\n-      remote_thread_info *remote_thr = get_remote_thread_info (ptid);\n+      remote_thread_info *remote_thr = get_remote_thread_info (this, ptid);\n       remote_thr->core = stop_reply->core;\n       remote_thr->stop_reason = stop_reply->stop_reason;\n       remote_thr->watch_data_address = stop_reply->watch_data_address;\n@@ -7721,9 +7747,9 @@ remote_target::wait_ns (ptid_t ptid, struct target_waitstatus *status, int optio\n /* Return the first resumed thread.  */\n \n static ptid_t\n-first_remote_resumed_thread ()\n+first_remote_resumed_thread (remote_target *target)\n {\n-  for (thread_info *tp : all_non_exited_threads (minus_one_ptid))\n+  for (thread_info *tp : all_non_exited_threads (target, minus_one_ptid))\n     if (tp->resumed)\n       return tp->ptid;\n   return null_ptid;\n@@ -7865,15 +7891,15 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status, int options)\n       if (event_ptid != null_ptid)\n \trecord_currthread (rs, event_ptid);\n       else\n-\tevent_ptid = first_remote_resumed_thread ();\n+\tevent_ptid = first_remote_resumed_thread (this);\n     }\n   else\n     {\n       /* A process exit.  Invalidate our notion of current thread.  */\n       record_currthread (rs, minus_one_ptid);\n       /* It's possible that the packet did not include a pid.  */\n       if (event_ptid == null_ptid)\n-\tevent_ptid = first_remote_resumed_thread ();\n+\tevent_ptid = first_remote_resumed_thread (this);\n       /* EVENT_PTID could still be NULL_PTID.  Double-check.  */\n       if (event_ptid == null_ptid)\n \tevent_ptid = magic_null_ptid;\n@@ -8988,11 +9014,11 @@ remote_target::files_info ()\n    for output compatibility with throw_perror_with_name.  */\n \n static void\n-unpush_and_perror (const char *string)\n+unpush_and_perror (remote_target *target, const char *string)\n {\n   int saved_errno = errno;\n \n-  remote_unpush_target ();\n+  remote_unpush_target (target);\n   throw_error (TARGET_CLOSE_ERROR, \"%s: %s.\", string,\n \t       safe_strerror (saved_errno));\n }\n@@ -9028,12 +9054,12 @@ remote_target::readchar (int timeout)\n   switch ((enum serial_rc) ch)\n     {\n     case SERIAL_EOF:\n-      remote_unpush_target ();\n+      remote_unpush_target (this);\n       throw_error (TARGET_CLOSE_ERROR, _(\"Remote connection closed\"));\n       /* no return */\n     case SERIAL_ERROR:\n-      unpush_and_perror (_(\"Remote communication error.  \"\n-\t\t\t   \"Target disconnected.\"));\n+      unpush_and_perror (this, _(\"Remote communication error.  \"\n+\t\t\t\t \"Target disconnected.\"));\n       /* no return */\n     case SERIAL_TIMEOUT:\n       break;\n@@ -9061,8 +9087,8 @@ remote_target::remote_serial_write (const char *str, int len)\n \n   if (serial_write (rs->remote_desc, str, len))\n     {\n-      unpush_and_perror (_(\"Remote communication error.  \"\n-\t\t\t   \"Target disconnected.\"));\n+      unpush_and_perror (this, _(\"Remote communication error.  \"\n+\t\t\t\t \"Target disconnected.\"));\n     }\n \n   if (rs->got_ctrlc_during_io)\n@@ -9585,7 +9611,7 @@ remote_target::getpkt_or_notif_sane_1 (gdb::char_vector *buf,\n \n \t      if (forever)\t/* Watchdog went off?  Kill the target.  */\n \t\t{\n-\t\t  remote_unpush_target ();\n+\t\t  remote_unpush_target (this);\n \t\t  throw_error (TARGET_CLOSE_ERROR,\n \t\t\t       _(\"Watchdog timeout has expired.  \"\n \t\t\t\t \"Target detached.\"));\n@@ -9702,7 +9728,7 @@ remote_target::kill_new_fork_children (int pid)\n \n   /* Kill the fork child threads of any threads in process PID\n      that are stopped at a fork event.  */\n-  for (thread_info *thread : all_non_exited_threads ())\n+  for (thread_info *thread : all_non_exited_threads (this))\n     {\n       struct target_waitstatus *ws = &thread->pending_follow;\n \n@@ -9762,7 +9788,7 @@ remote_target::kill ()\n      inferior, then we will tell gdbserver to exit and unpush the\n      target.  */\n   if (res == -1 && !remote_multi_process_p (rs)\n-      && number_of_live_inferiors () == 1)\n+      && number_of_live_inferiors (this) == 1)\n     {\n       remote_kill_k ();\n \n@@ -9848,12 +9874,9 @@ remote_target::mourn_inferior ()\n   discard_pending_stop_replies (current_inferior ());\n \n   /* In 'target remote' mode with one inferior, we close the connection.  */\n-  if (!rs->extended && number_of_live_inferiors () <= 1)\n+  if (!rs->extended && number_of_live_inferiors (this) <= 1)\n     {\n-      unpush_target (this);\n-\n-      /* remote_close takes care of doing most of the clean up.  */\n-      generic_mourn_inferior ();\n+      remote_unpush_target (this);\n       return;\n     }\n \n@@ -13437,7 +13460,7 @@ remote_target::set_disconnected_tracing (int val)\n int\n remote_target::core_of_thread (ptid_t ptid)\n {\n-  struct thread_info *info = find_thread_ptid (ptid);\n+  thread_info *info = find_thread_ptid (this, ptid);\n \n   if (info != NULL && info->priv != NULL)\n     return get_remote_thread_info (info)->core;\n@@ -13717,7 +13740,7 @@ remote_target::remote_btrace_maybe_reopen ()\n \n   scoped_restore_current_thread restore_thread;\n \n-  for (thread_info *tp : all_non_exited_threads ())\n+  for (thread_info *tp : all_non_exited_threads (this))\n     {\n       set_general_thread (tp->ptid);\n \n@@ -13933,13 +13956,12 @@ char *\n remote_target::pid_to_exec_file (int pid)\n {\n   static gdb::optional<gdb::char_vector> filename;\n-  struct inferior *inf;\n   char *annex = NULL;\n \n   if (packet_support (PACKET_qXfer_exec_file) != PACKET_ENABLE)\n     return NULL;\n \n-  inf = find_inferior_pid (pid);\n+  inferior *inf = find_inferior_pid (this, pid);\n   if (inf == NULL)\n     internal_error (__FILE__, __LINE__,\n \t\t    _(\"not currently attached to process %d\"), pid);\n@@ -14000,7 +14022,7 @@ remote_target::thread_handle_to_thread_info (const gdb_byte *thread_handle,\n \t\t\t\t\t     int handle_len,\n \t\t\t\t\t     inferior *inf)\n {\n-  for (thread_info *tp : all_non_exited_threads ())\n+  for (thread_info *tp : all_non_exited_threads (this))\n     {\n       remote_thread_info *priv = get_remote_thread_info (tp);\n \n@@ -14072,6 +14094,13 @@ remote_async_inferior_event_handler (gdb_client_data data)\n   inferior_event_handler (INF_REG_EVENT, data);\n }\n \n+int\n+remote_target::async_wait_fd ()\n+{\n+  struct remote_state *rs = get_remote_state ();\n+  return rs->remote_desc->fd;\n+}\n+\n void\n remote_target::async (int enable)\n {"
    },
    {
      "sha": "157907373c4e16d3a9a433000588451238851c3c",
      "filename": "gdb/riscv-fbsd-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/riscv-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/riscv-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-fbsd-tdep.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -26,6 +26,7 @@\n #include \"trad-frame.h\"\n #include \"tramp-frame.h\"\n #include \"gdbarch.h\"\n+#include \"inferior.h\"\n \n /* Register maps.  */\n \n@@ -183,7 +184,8 @@ riscv_fbsd_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid,\n {\n   struct regcache *regcache;\n \n-  regcache = get_thread_arch_regcache (ptid, gdbarch);\n+  regcache = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\t       ptid, gdbarch);\n \n   target_fetch_registers (regcache, RISCV_TP_REGNUM);\n "
    },
    {
      "sha": "bf2325b6a9e7f712d0f110b1efdf435cfaea6ce9",
      "filename": "gdb/sol-thread.c",
      "status": "modified",
      "additions": 20,
      "deletions": 8,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/sol-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/sol-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sol-thread.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -461,9 +461,13 @@ sol_thread_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n       /* See if we have a new thread.  */\n       if (rtnval.tid_p () && rtnval != save_ptid)\n \t{\n-\t  thread_info *thr = find_thread_ptid (rtnval);\n+\t  thread_info *thr = find_thread_ptid (current_inferior (), rtnval);\n \t  if (thr == NULL || thr->state == THREAD_EXITED)\n-\t    add_thread (rtnval);\n+\t    {\n+\t      process_stratum_target *proc_target\n+\t\t= current_inferior ()->process_target ();\n+\t      add_thread (proc_target, rtnval);\n+\t    }\n \t}\n     }\n \n@@ -853,7 +857,8 @@ ps_lgetregs (struct ps_prochandle *ph, lwpid_t lwpid, prgregset_t gregset)\n {\n   ptid_t ptid = ptid_t (inferior_ptid.pid (), lwpid, 0);\n   struct regcache *regcache\n-    = get_thread_arch_regcache (ptid, target_gdbarch ());\n+    = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\tptid, target_gdbarch ());\n \n   target_fetch_registers (regcache, -1);\n   fill_gregset (regcache, (gdb_gregset_t *) gregset, -1);\n@@ -869,7 +874,8 @@ ps_lsetregs (struct ps_prochandle *ph, lwpid_t lwpid,\n {\n   ptid_t ptid = ptid_t (inferior_ptid.pid (), lwpid, 0);\n   struct regcache *regcache\n-    = get_thread_arch_regcache (ptid, target_gdbarch ());\n+    = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\tptid, target_gdbarch ());\n \n   supply_gregset (regcache, (const gdb_gregset_t *) gregset);\n   target_store_registers (regcache, -1);\n@@ -921,7 +927,8 @@ ps_lgetfpregs (struct ps_prochandle *ph, lwpid_t lwpid,\n {\n   ptid_t ptid = ptid_t (inferior_ptid.pid (), lwpid, 0);\n   struct regcache *regcache\n-    = get_thread_arch_regcache (ptid, target_gdbarch ());\n+    = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\tptid, target_gdbarch ());\n \n   target_fetch_registers (regcache, -1);\n   fill_fpregset (regcache, (gdb_fpregset_t *) fpregset, -1);\n@@ -937,7 +944,8 @@ ps_lsetfpregs (struct ps_prochandle *ph, lwpid_t lwpid,\n {\n   ptid_t ptid = ptid_t (inferior_ptid.pid (), lwpid, 0);\n   struct regcache *regcache\n-    = get_thread_arch_regcache (ptid, target_gdbarch ());\n+    = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\tptid, target_gdbarch ());\n \n   supply_fpregset (regcache, (const gdb_fpregset_t *) fpregset);\n   target_store_registers (regcache, -1);\n@@ -1037,9 +1045,13 @@ sol_update_thread_list_callback (const td_thrhandle_t *th, void *ignored)\n     return -1;\n \n   ptid_t ptid = ptid_t (inferior_ptid.pid (), 0, ti.ti_tid);\n-  thread_info *thr = find_thread_ptid (ptid);\n+  thread_info *thr = find_thread_ptid (current_inferior (), ptid);\n   if (thr == NULL || thr->state == THREAD_EXITED)\n-    add_thread (ptid);\n+    {\n+      process_stratum_target *proc_target\n+\t= current_inferior ()->process_target ();\n+      add_thread (proc_target, ptid);\n+    }\n \n   return 0;\n }"
    },
    {
      "sha": "03b510c9adedbbbad25a6ba95d3190cefaff04ba",
      "filename": "gdb/sol2-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/sol2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/sol2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sol2-tdep.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -58,7 +58,7 @@ sol2_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)\n   /* GDB didn't use to put a NT_PSTATUS note in Solaris cores.  If\n      that's missing, then we're dealing with a fake PID corelow.c made\n      up.  */\n-  inf = find_inferior_ptid (ptid);\n+  inf = find_inferior_ptid (current_inferior ()->process_target (), ptid);\n   if (inf == NULL || inf->fake_pid_p)\n     return \"<core>\";\n "
    },
    {
      "sha": "3122f06939f5f88f01fe8fc515a0e8fcbbea5964",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -2394,7 +2394,8 @@ enable_break (struct svr4_info *info, int from_tty)\n       if (!load_addr_found)\n \t{\n \t  struct regcache *regcache\n-\t    = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());\n+\t    = get_thread_arch_regcache (current_inferior ()->process_target (),\n+\t\t\t\t\tinferior_ptid, target_gdbarch ());\n \n \t  load_addr = (regcache_read_pc (regcache)\n \t\t       - exec_entry_point (tmp_bfd.get (), tmp_bfd_target));"
    },
    {
      "sha": "5c2142b63fa115f911c3d9fb54d6ca242384cdbb",
      "filename": "gdb/target-delegates.c",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/target-delegates.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/target-delegates.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-delegates.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -83,6 +83,7 @@ struct dummy_target : public target_ops\n   bool can_async_p () override;\n   bool is_async_p () override;\n   void async (int arg0) override;\n+  int async_wait_fd () override;\n   void thread_events (int arg0) override;\n   bool supports_non_stop () override;\n   bool always_non_stop_p () override;\n@@ -251,6 +252,7 @@ struct debug_target : public target_ops\n   bool can_async_p () override;\n   bool is_async_p () override;\n   void async (int arg0) override;\n+  int async_wait_fd () override;\n   void thread_events (int arg0) override;\n   bool supports_non_stop () override;\n   bool always_non_stop_p () override;\n@@ -2162,6 +2164,31 @@ debug_target::async (int arg0)\n   fputs_unfiltered (\")\\n\", gdb_stdlog);\n }\n \n+int\n+target_ops::async_wait_fd ()\n+{\n+  return this->beneath ()->async_wait_fd ();\n+}\n+\n+int\n+dummy_target::async_wait_fd ()\n+{\n+  noprocess ();\n+}\n+\n+int\n+debug_target::async_wait_fd ()\n+{\n+  int result;\n+  fprintf_unfiltered (gdb_stdlog, \"-> %s->async_wait_fd (...)\\n\", this->beneath ()->shortname ());\n+  result = this->beneath ()->async_wait_fd ();\n+  fprintf_unfiltered (gdb_stdlog, \"<- %s->async_wait_fd (\", this->beneath ()->shortname ());\n+  fputs_unfiltered (\") = \", gdb_stdlog);\n+  target_debug_print_int (result);\n+  fputs_unfiltered (\"\\n\", gdb_stdlog);\n+  return result;\n+}\n+\n void\n target_ops::thread_events (int arg0)\n {"
    },
    {
      "sha": "33c41cc4b69ad5cc3e5d75e4da5bd6768342e8ee",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 105,
      "deletions": 65,
      "changes": 170,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -110,18 +110,14 @@ static std::unordered_map<const target_info *, target_open_ftype *>\n \n static struct target_ops *the_debug_target;\n \n-/* The target stack.  */\n-\n-static target_stack g_target_stack;\n-\n /* Top of target stack.  */\n /* The target structure we are currently using to talk to a process\n    or file or whatever \"inferior\" we have.  */\n \n target_ops *\n current_top_target ()\n {\n-  return g_target_stack.top ();\n+  return current_inferior ()->top_target ();\n }\n \n /* Command list for target.  */\n@@ -226,7 +222,9 @@ target_has_registers_1 (void)\n bool\n target_has_execution_1 (inferior *inf)\n {\n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = inf->top_target ();\n+       t != nullptr;\n+       t = inf->find_target_beneath (t))\n     if (t->has_execution (inf))\n       return true;\n \n@@ -501,13 +499,16 @@ target_terminal::info (const char *arg, int from_tty)\n bool\n target_supports_terminal_ours (void)\n {\n-  /* This can be called before there is any target, so we must check\n-     for nullptr here.  */\n-  target_ops *top = current_top_target ();\n+  /* The current top target is the target at the top of the target\n+     stack of the current inferior.  While normally there's always an\n+     inferior, we must check for nullptr here because we can get here\n+     very early during startup, before the initial inferior is first\n+     created.  */\n+  inferior *inf = current_inferior ();\n \n-  if (top == nullptr)\n+  if (inf == nullptr)\n     return false;\n-  return top->supports_terminal_ours ();\n+  return inf->top_target ()->supports_terminal_ours ();\n }\n \n static void\n@@ -555,12 +556,25 @@ to_execution_direction must be implemented for reverse async\");\n \n /* See target.h.  */\n \n+void\n+decref_target (target_ops *t)\n+{\n+  t->decref ();\n+  if (t->refcount () == 0)\n+    target_close (t);\n+}\n+\n+/* See target.h.  */\n+\n void\n target_stack::push (target_ops *t)\n {\n-  /* If there's already a target at this stratum, remove it.  */\n+  t->incref ();\n+\n   strata stratum = t->stratum ();\n \n+  /* If there's already a target at this stratum, remove it.  */\n+\n   if (m_stack[stratum] != NULL)\n     unpush (m_stack[stratum]);\n \n@@ -576,15 +590,15 @@ target_stack::push (target_ops *t)\n void\n push_target (struct target_ops *t)\n {\n-  g_target_stack.push (t);\n+  current_inferior ()->push_target (t);\n }\n \n-/* See target.h  */\n+/* See target.h.  */\n \n void\n push_target (target_ops_up &&t)\n {\n-  g_target_stack.push (t.get ());\n+  current_inferior ()->push_target (t.get ());\n   t.release ();\n }\n \n@@ -593,7 +607,7 @@ push_target (target_ops_up &&t)\n int\n unpush_target (struct target_ops *t)\n {\n-  return g_target_stack.unpush (t);\n+  return current_inferior ()->unpush_target (t);\n }\n \n /* See target.h.  */\n@@ -625,10 +639,13 @@ target_stack::unpush (target_ops *t)\n   if (m_top == stratum)\n     m_top = t->beneath ()->stratum ();\n \n-  /* Finally close the target.  Note we do this after unchaining, so\n-     any target method calls from within the target_close\n-     implementation don't end up in T anymore.  */\n-  target_close (t);\n+  /* Finally close the target, if there are no inferiors\n+     referencing this target still.  Note we do this after unchaining,\n+     so any target method calls from within the target_close\n+     implementation don't end up in T anymore.  Do leave the target\n+     open if we have are other inferiors referencing this target\n+     still.  */\n+  decref_target (t);\n \n   return true;\n }\n@@ -670,12 +687,13 @@ pop_all_targets (void)\n   pop_all_targets_above (dummy_stratum);\n }\n \n-/* Return 1 if T is now pushed in the target stack.  Return 0 otherwise.  */\n+/* Return true if T is now pushed in the current inferior's target\n+   stack.  Return false otherwise.  */\n \n-int\n-target_is_pushed (struct target_ops *t)\n+bool\n+target_is_pushed (target_ops *t)\n {\n-  return g_target_stack.is_pushed (t);\n+  return current_inferior ()->target_is_pushed (t);\n }\n \n /* Default implementation of to_get_thread_local_address.  */\n@@ -1947,33 +1965,6 @@ target_pre_inferior (int from_tty)\n   agent_capability_invalidate ();\n }\n \n-/* Callback for iterate_over_inferiors.  Gets rid of the given\n-   inferior.  */\n-\n-static int\n-dispose_inferior (struct inferior *inf, void *args)\n-{\n-  /* Not all killed inferiors can, or will ever be, removed from the\n-     inferior list.  Killed inferiors clearly don't need to be killed\n-     again, so, we're done.  */\n-  if (inf->pid == 0)\n-    return 0;\n-\n-  thread_info *thread = any_thread_of_inferior (inf);\n-  if (thread != NULL)\n-    {\n-      switch_to_thread (thread);\n-\n-      /* Core inferiors actually should be detached, not killed.  */\n-      if (target_has_execution)\n-\ttarget_kill ();\n-      else\n-\ttarget_detach (inf, 0);\n-    }\n-\n-  return 0;\n-}\n-\n /* This is to be called by the open routine before it does\n    anything.  */\n \n@@ -1982,12 +1973,19 @@ target_preopen (int from_tty)\n {\n   dont_repeat ();\n \n-  if (have_inferiors ())\n+  if (current_inferior ()->pid != 0)\n     {\n       if (!from_tty\n-\t  || !have_live_inferiors ()\n+\t  || !target_has_execution\n \t  || query (_(\"A program is being debugged already.  Kill it? \")))\n-\titerate_over_inferiors (dispose_inferior, NULL);\n+\t{\n+\t  /* Core inferiors actually should be detached, not\n+\t     killed.  */\n+\t  if (target_has_execution)\n+\t    target_kill ();\n+\t  else\n+\t    target_detach (current_inferior (), 0);\n+\t}\n       else\n \terror (_(\"Program not killed.\"));\n     }\n@@ -2029,9 +2027,16 @@ target_detach (inferior *inf, int from_tty)\n \n   prepare_for_detach ();\n \n+  /* Hold a strong reference because detaching may unpush the\n+     target.  */\n+  auto proc_target_ref = target_ops_ref::new_reference (inf->process_target ());\n+\n   current_top_target ()->detach (inf, from_tty);\n \n-  registers_changed_ptid (save_pid_ptid);\n+  process_stratum_target *proc_target\n+    = as_process_stratum_target (proc_target_ref.get ());\n+\n+  registers_changed_ptid (proc_target, save_pid_ptid);\n \n   /* We have to ensure we have no frame cache left.  Normally,\n      registers_changed_ptid (save_pid_ptid) calls reinit_frame_cache when\n@@ -2079,6 +2084,8 @@ target_pid_to_str (ptid_t ptid)\n const char *\n target_thread_name (struct thread_info *info)\n {\n+  gdb_assert (info->inf == current_inferior ());\n+\n   return current_top_target ()->thread_name (info);\n }\n \n@@ -2102,16 +2109,18 @@ target_thread_info_to_thread_handle (struct thread_info *tip)\n void\n target_resume (ptid_t ptid, int step, enum gdb_signal signal)\n {\n+  process_stratum_target *curr_target = current_inferior ()->process_target ();\n+\n   target_dcache_invalidate ();\n \n   current_top_target ()->resume (ptid, step, signal);\n \n-  registers_changed_ptid (ptid);\n+  registers_changed_ptid (curr_target, ptid);\n   /* We only set the internal executing state here.  The user/frontend\n      running state is set at a higher level.  This also clears the\n      thread's stop_pc as side effect.  */\n-  set_executing (ptid, 1);\n-  clear_inline_frame_state (ptid);\n+  set_executing (curr_target, ptid, 1);\n+  clear_inline_frame_state (curr_target, ptid);\n }\n \n /* If true, target_commit_resume is a nop.  */\n@@ -2536,7 +2545,6 @@ target_get_osdata (const char *type)\n   return target_read_stralloc (t, TARGET_OBJECT_OSDATA, type);\n }\n \n-\n /* Determine the current address space of thread PTID.  */\n \n struct address_space *\n@@ -2555,7 +2563,7 @@ target_thread_address_space (ptid_t ptid)\n target_ops *\n target_ops::beneath () const\n {\n-  return g_target_stack.find_beneath (this);\n+  return current_inferior ()->find_target_beneath (this);\n }\n \n void\n@@ -3151,7 +3159,7 @@ target_stack::find_beneath (const target_ops *t) const\n struct target_ops *\n find_target_at (enum strata stratum)\n {\n-  return g_target_stack.at (stratum);\n+  return current_inferior ()->target_at (stratum);\n }\n \n \f\n@@ -3247,6 +3255,14 @@ dummy_make_corefile_notes (struct target_ops *self,\n \n static dummy_target the_dummy_target;\n \n+/* See target.h.  */\n+\n+target_ops *\n+get_dummy_target ()\n+{\n+  return &the_dummy_target;\n+}\n+\n static const target_info dummy_target_info = {\n   \"None\",\n   N_(\"None\"),\n@@ -3333,7 +3349,33 @@ target_interrupt ()\n void\n target_pass_ctrlc (void)\n {\n-  current_top_target ()->pass_ctrlc ();\n+  /* Pass the Ctrl-C to the first target that has a thread\n+     running.  */\n+  for (inferior *inf : all_inferiors ())\n+    {\n+      target_ops *proc_target = inf->process_target ();\n+      if (proc_target == NULL)\n+\tcontinue;\n+\n+      for (thread_info *thr : inf->threads ())\n+\t{\n+\t  /* A thread can be THREAD_STOPPED and executing, while\n+\t     running an infcall.  */\n+\t  if (thr->state == THREAD_RUNNING || thr->executing)\n+\t    {\n+\t      /* We can get here quite deep in target layers.  Avoid\n+\t\t switching thread context or anything that would\n+\t\t communicate with the target (e.g., to fetch\n+\t\t registers), or flushing e.g., the frame cache.  We\n+\t\t just switch inferior in order to be able to call\n+\t\t through the target_stack.  */\n+\t      scoped_restore_current_inferior restore_inferior;\n+\t      set_current_inferior (inf);\n+\t      current_top_target ()->pass_ctrlc ();\n+\t      return;\n+\t    }\n+\t}\n+    }\n }\n \n /* See target.h.  */\n@@ -3981,10 +4023,8 @@ set_write_memory_permission (const char *args, int from_tty,\n }\n \n void\n-initialize_targets (void)\n+_initialize_target ()\n {\n-  push_target (&the_dummy_target);\n-\n   the_debug_target = new debug_target ();\n \n   add_info (\"target\", info_target_command, targ_desc);"
    },
    {
      "sha": "26b71cfeb09297156dfaf39ba556a7d733ae3a8b",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 31,
      "deletions": 3,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -43,6 +43,7 @@ struct inferior;\n #include \"infrun.h\" /* For enum exec_direction_kind.  */\n #include \"breakpoint.h\" /* For enum bptype.  */\n #include \"gdbsupport/scoped_restore.h\"\n+#include \"gdbsupport/refcounted-object.h\"\n \n /* This include file defines the interface between the main part\n    of the debugger, and the part which is target-specific, or\n@@ -427,6 +428,7 @@ struct target_info\n };\n \n struct target_ops\n+  : public refcounted_object\n   {\n     /* Return this target's stratum.  */\n     virtual strata stratum () const = 0;\n@@ -445,10 +447,10 @@ struct target_ops\n     virtual const target_info &info () const = 0;\n \n     /* Name this target type.  */\n-    const char *shortname ()\n+    const char *shortname () const\n     { return info ().shortname; }\n \n-    const char *longname ()\n+    const char *longname () const\n     { return info ().longname; }\n \n     /* Close the target.  This is where the target can handle\n@@ -701,6 +703,8 @@ struct target_ops\n       TARGET_DEFAULT_RETURN (false);\n     virtual void async (int)\n       TARGET_DEFAULT_NORETURN (tcomplain ());\n+    virtual int async_wait_fd ()\n+      TARGET_DEFAULT_NORETURN (noprocess ());\n     virtual void thread_events (int)\n       TARGET_DEFAULT_IGNORE ();\n     /* This method must be implemented in some situations.  See the\n@@ -1264,6 +1268,27 @@ struct target_ops_deleter\n /* A unique pointer for target_ops.  */\n typedef std::unique_ptr<target_ops, target_ops_deleter> target_ops_up;\n \n+/* Decref a target and close if, if there are no references left.  */\n+extern void decref_target (target_ops *t);\n+\n+/* A policy class to interface gdb::ref_ptr with target_ops.  */\n+\n+struct target_ops_ref_policy\n+{\n+  static void incref (target_ops *t)\n+  {\n+    t->incref ();\n+  }\n+\n+  static void decref (target_ops *t)\n+  {\n+    decref_target (t);\n+  }\n+};\n+\n+/* A gdb::ref_ptr pointer to a target_ops.  */\n+typedef gdb::ref_ptr<target_ops, target_ops_ref_policy> target_ops_ref;\n+\n /* Native target backends call this once at initialization time to\n    inform the core about which is the target that can respond to \"run\"\n    or \"attach\".  Note: native targets are always singletons.  */\n@@ -1318,6 +1343,9 @@ class target_stack\n \n extern target_ops *current_top_target ();\n \n+/* Return the dummy target.  */\n+extern target_ops *get_dummy_target ();\n+\n /* Define easy words for doing these operations on our current target.  */\n \n #define\ttarget_shortname\t(current_top_target ()->shortname ())\n@@ -2366,7 +2394,7 @@ extern void pop_all_targets_at_and_above (enum strata stratum);\n    strictly above ABOVE_STRATUM.  */\n extern void pop_all_targets_above (enum strata above_stratum);\n \n-extern int target_is_pushed (struct target_ops *t);\n+extern bool target_is_pushed (target_ops *t);\n \n extern CORE_ADDR target_translate_tls_address (struct objfile *objfile,\n \t\t\t\t\t       CORE_ADDR offset);"
    },
    {
      "sha": "a6bbc50185a8f4ab45ced0fed307260821462f28",
      "filename": "gdb/thread-iter.c",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/thread-iter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/thread-iter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread-iter.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -58,16 +58,22 @@ all_threads_iterator::advance ()\n bool\n all_matching_threads_iterator::m_inf_matches ()\n {\n-  return (m_filter_ptid == minus_one_ptid\n-\t  || m_filter_ptid.pid () == m_inf->pid);\n+  return ((m_filter_target == nullptr\n+\t   || m_filter_target == m_inf->process_target ())\n+\t  && (m_filter_ptid == minus_one_ptid\n+\t      || m_filter_ptid.pid () == m_inf->pid));\n }\n \n /* See thread-iter.h.  */\n \n all_matching_threads_iterator::all_matching_threads_iterator\n-  (ptid_t filter_ptid)\n-  : m_filter_ptid (filter_ptid)\n+  (process_stratum_target *filter_target, ptid_t filter_ptid)\n+    : m_filter_target (filter_target),\n+      m_filter_ptid (filter_ptid)\n {\n+  gdb_assert ((filter_target == nullptr && filter_ptid == minus_one_ptid)\n+\t      || filter_target->stratum () == process_stratum);\n+\n   m_thr = nullptr;\n   for (m_inf = inferior_list; m_inf != NULL; m_inf = m_inf->next)\n     if (m_inf_matches ())"
    },
    {
      "sha": "95dc562436813db4ae939bf7458f1a96c3ad3ad7",
      "filename": "gdb/thread-iter.h",
      "status": "modified",
      "additions": 16,
      "deletions": 9,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/thread-iter.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/thread-iter.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread-iter.h?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -92,12 +92,14 @@ class all_matching_threads_iterator\n \n   /* Creates an iterator that iterates over all threads that match\n      FILTER_PTID.  */\n-  explicit all_matching_threads_iterator (ptid_t filter_ptid);\n+  all_matching_threads_iterator (process_stratum_target *filter_target,\n+\t\t\t\t ptid_t filter_ptid);\n \n   /* Create a one-past-end iterator.  */\n   all_matching_threads_iterator ()\n     : m_inf (nullptr),\n       m_thr (nullptr),\n+      m_filter_target (nullptr),\n       m_filter_ptid (minus_one_ptid)\n   {}\n \n@@ -131,6 +133,7 @@ class all_matching_threads_iterator\n   thread_info *m_thr;\n \n   /* The filter.  */\n+  process_stratum_target *m_filter_target;\n   ptid_t m_filter_ptid;\n };\n \n@@ -211,20 +214,22 @@ struct all_threads_safe_range\n struct all_matching_threads_range\n {\n public:\n-  explicit all_matching_threads_range (ptid_t filter_ptid)\n-    : m_filter_ptid (filter_ptid)\n+  all_matching_threads_range (process_stratum_target *filter_target,\n+\t\t\t      ptid_t filter_ptid)\n+    : m_filter_target (filter_target), m_filter_ptid (filter_ptid)\n   {}\n   all_matching_threads_range ()\n-    : m_filter_ptid (minus_one_ptid)\n+    : m_filter_target (nullptr), m_filter_ptid (minus_one_ptid)\n   {}\n \n   all_matching_threads_iterator begin () const\n-  { return all_matching_threads_iterator (m_filter_ptid); }\n+  { return all_matching_threads_iterator (m_filter_target, m_filter_ptid); }\n   all_matching_threads_iterator end () const\n   { return all_matching_threads_iterator (); }\n \n private:\n   /* The filter.  */\n+  process_stratum_target *m_filter_target;\n   ptid_t m_filter_ptid;\n };\n \n@@ -236,20 +241,22 @@ struct all_matching_threads_range\n class all_non_exited_threads_range\n {\n public:\n-  explicit all_non_exited_threads_range (ptid_t filter_ptid)\n-    : m_filter_ptid (filter_ptid)\n+  all_non_exited_threads_range (process_stratum_target *filter_target,\n+\t\t\t\tptid_t filter_ptid)\n+    : m_filter_target (filter_target), m_filter_ptid (filter_ptid)\n   {}\n \n   all_non_exited_threads_range ()\n-    : m_filter_ptid (minus_one_ptid)\n+    : m_filter_target (nullptr), m_filter_ptid (minus_one_ptid)\n   {}\n \n   all_non_exited_threads_iterator begin () const\n-  { return all_non_exited_threads_iterator (m_filter_ptid); }\n+  { return all_non_exited_threads_iterator (m_filter_target, m_filter_ptid); }\n   all_non_exited_threads_iterator end () const\n   { return all_non_exited_threads_iterator (); }\n \n private:\n+  process_stratum_target *m_filter_target;\n   ptid_t m_filter_ptid;\n };\n "
    },
    {
      "sha": "03fdc05140c1b5862fa1f71a4e27ed556e3cf1a3",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 83,
      "deletions": 56,
      "changes": 139,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -55,13 +55,6 @@\n \n static int highest_thread_num;\n \n-/* True if any thread is, or may be executing.  We need to track this\n-   separately because until we fully sync the thread list, we won't\n-   know whether the target is fully stopped, even if we see stop\n-   events for all known threads, because any of those threads may have\n-   spawned new threads we haven't heard of yet.  */\n-static int threads_executing;\n-\n /* RAII type used to increase / decrease the refcount of each thread\n    in a given list of threads.  */\n \n@@ -89,7 +82,7 @@ class scoped_inc_dec_ref\n struct thread_info*\n inferior_thread (void)\n {\n-  struct thread_info *tp = find_thread_ptid (inferior_ptid);\n+  struct thread_info *tp = find_thread_ptid (current_inferior (), inferior_ptid);\n   gdb_assert (tp);\n   return tp;\n }\n@@ -195,7 +188,7 @@ clear_thread_inferior_resources (struct thread_info *tp)\n \n   thread_cancel_execution_command (tp);\n \n-  clear_inline_frame_state (tp->ptid);\n+  clear_inline_frame_state (tp);\n }\n \n /* Set the TP's state as exited.  */\n@@ -260,12 +253,11 @@ new_thread (struct inferior *inf, ptid_t ptid)\n }\n \n struct thread_info *\n-add_thread_silent (ptid_t ptid)\n+add_thread_silent (process_stratum_target *targ, ptid_t ptid)\n {\n-  struct inferior *inf = find_inferior_ptid (ptid);\n-  gdb_assert (inf != NULL);\n+  inferior *inf;\n \n-  thread_info *tp = find_thread_ptid (inf, ptid);\n+  thread_info *tp = find_thread_ptid (targ, ptid);\n   if (tp)\n     /* Found an old thread with the same id.  It has to be dead,\n        otherwise we wouldn't be adding a new thread with the same id.\n@@ -281,7 +273,7 @@ add_thread_silent (ptid_t ptid)\n \n       if (inferior_ptid == ptid)\n \t{\n-\t  thread_info *new_thr = new_thread (inf, null_ptid);\n+\t  thread_info *new_thr = new_thread (tp->inf, null_ptid);\n \n \t  /* Make switch_to_thread not read from the thread.  */\n \t  new_thr->state = THREAD_EXITED;\n@@ -300,10 +292,14 @@ add_thread_silent (ptid_t ptid)\n \t  /* All done.  */\n \t  return new_thr;\n \t}\n-      else\n-\t/* Just go ahead and delete it.  */\n-\tdelete_thread (tp);\n+\n+      inf = tp->inf;\n+\n+      /* Just go ahead and delete it.  */\n+      delete_thread (tp);\n     }\n+  else\n+    inf = find_inferior_ptid (targ, ptid);\n \n   tp = new_thread (inf, ptid);\n   gdb::observers::new_thread.notify (tp);\n@@ -312,9 +308,10 @@ add_thread_silent (ptid_t ptid)\n }\n \n struct thread_info *\n-add_thread_with_info (ptid_t ptid, private_thread_info *priv)\n+add_thread_with_info (process_stratum_target *targ, ptid_t ptid,\n+\t\t      private_thread_info *priv)\n {\n-  struct thread_info *result = add_thread_silent (ptid);\n+  thread_info *result = add_thread_silent (targ, ptid);\n \n   result->priv.reset (priv);\n \n@@ -326,9 +323,9 @@ add_thread_with_info (ptid_t ptid, private_thread_info *priv)\n }\n \n struct thread_info *\n-add_thread (ptid_t ptid)\n+add_thread (process_stratum_target *targ, ptid_t ptid)\n {\n-  return add_thread_with_info (ptid, NULL);\n+  return add_thread_with_info (targ, ptid, NULL);\n }\n \n private_thread_info::~private_thread_info () = default;\n@@ -352,14 +349,22 @@ thread_info::~thread_info ()\n   xfree (this->name);\n }\n \n+/* Returns true if THR is the current thread.  */\n+\n+static bool\n+is_current_thread (const thread_info *thr)\n+{\n+  return thr->inf == current_inferior () && thr->ptid == inferior_ptid;\n+}\n+\n /* See gdbthread.h.  */\n \n bool\n thread_info::deletable () const\n {\n   /* If this is the current thread, or there's code out there that\n      relies on it existing (refcount > 0) we can't delete yet.  */\n-  return refcount () == 0 && ptid != inferior_ptid;\n+  return refcount () == 0 && !is_current_thread (this);\n }\n \n /* Add TP to the end of the step-over chain LIST_P.  */\n@@ -514,12 +519,12 @@ find_thread_id (struct inferior *inf, int thr_num)\n   return NULL;\n }\n \n-/* Find a thread_info by matching PTID.  */\n+/* See gdbthread.h.  */\n \n struct thread_info *\n-find_thread_ptid (ptid_t ptid)\n+find_thread_ptid (process_stratum_target *targ, ptid_t ptid)\n {\n-  inferior *inf = find_inferior_ptid (ptid);\n+  inferior *inf = find_inferior_ptid (targ, ptid);\n   if (inf == NULL)\n     return NULL;\n   return find_thread_ptid (inf, ptid);\n@@ -584,9 +589,9 @@ any_thread_p ()\n }\n \n int\n-thread_count (void)\n+thread_count (process_stratum_target *proc_target)\n {\n-  auto rng = all_threads ();\n+  auto rng = all_threads (proc_target);\n   return std::distance (rng.begin (), rng.end ());\n }\n \n@@ -609,10 +614,10 @@ valid_global_thread_id (int global_id)\n   return 0;\n }\n \n-int\n-in_thread_list (ptid_t ptid)\n+bool\n+in_thread_list (process_stratum_target *targ, ptid_t ptid)\n {\n-  return find_thread_ptid (ptid) != nullptr;\n+  return find_thread_ptid (targ, ptid) != nullptr;\n }\n \n /* Finds the first thread of the inferior.  */\n@@ -788,15 +793,16 @@ get_last_thread_stack_temporary (thread_info *tp)\n }\n \n void\n-thread_change_ptid (ptid_t old_ptid, ptid_t new_ptid)\n+thread_change_ptid (process_stratum_target *targ,\n+\t\t    ptid_t old_ptid, ptid_t new_ptid)\n {\n   struct inferior *inf;\n   struct thread_info *tp;\n \n   /* It can happen that what we knew as the target inferior id\n      changes.  E.g, target remote may only discover the remote process\n      pid after adding the inferior to GDB's list.  */\n-  inf = find_inferior_ptid (old_ptid);\n+  inf = find_inferior_ptid (targ, old_ptid);\n   inf->pid = new_ptid.pid ();\n \n   tp = find_thread_ptid (inf, old_ptid);\n@@ -808,9 +814,9 @@ thread_change_ptid (ptid_t old_ptid, ptid_t new_ptid)\n /* See gdbthread.h.  */\n \n void\n-set_resumed (ptid_t ptid, int resumed)\n+set_resumed (process_stratum_target *targ, ptid_t ptid, bool resumed)\n {\n-  for (thread_info *tp : all_non_exited_threads (ptid))\n+  for (thread_info *tp : all_non_exited_threads (targ, ptid))\n     tp->resumed = resumed;\n }\n \n@@ -848,15 +854,15 @@ thread_info::set_running (bool running)\n }\n \n void\n-set_running (ptid_t ptid, int running)\n+set_running (process_stratum_target *targ, ptid_t ptid, bool running)\n {\n   /* We try not to notify the observer if no thread has actually\n      changed the running state -- merely to reduce the number of\n      messages to the MI frontend.  A frontend is supposed to handle\n      multiple *running notifications just fine.  */\n   bool any_started = false;\n \n-  for (thread_info *tp : all_non_exited_threads (ptid))\n+  for (thread_info *tp : all_non_exited_threads (targ, ptid))\n     if (set_running_thread (tp, running))\n       any_started = true;\n \n@@ -878,32 +884,32 @@ set_executing_thread (thread_info *thr, bool executing)\n }\n \n void\n-set_executing (ptid_t ptid, int executing)\n+set_executing (process_stratum_target *targ, ptid_t ptid, bool executing)\n {\n-  for (thread_info *tp : all_non_exited_threads (ptid))\n+  for (thread_info *tp : all_non_exited_threads (targ, ptid))\n     set_executing_thread (tp, executing);\n \n   /* It only takes one running thread to spawn more threads.  */\n   if (executing)\n-    threads_executing = 1;\n+    targ->threads_executing = true;\n   /* Only clear the flag if the caller is telling us everything is\n      stopped.  */\n   else if (minus_one_ptid == ptid)\n-    threads_executing = 0;\n+    targ->threads_executing = false;\n }\n \n /* See gdbthread.h.  */\n \n-int\n-threads_are_executing (void)\n+bool\n+threads_are_executing (process_stratum_target *target)\n {\n-  return threads_executing;\n+  return target->threads_executing;\n }\n \n void\n-set_stop_requested (ptid_t ptid, int stop)\n+set_stop_requested (process_stratum_target *targ, ptid_t ptid, bool stop)\n {\n-  for (thread_info *tp : all_non_exited_threads (ptid))\n+  for (thread_info *tp : all_non_exited_threads (targ, ptid))\n     tp->stop_requested = stop;\n \n   /* Call the stop requested observer so other components of GDB can\n@@ -913,11 +919,11 @@ set_stop_requested (ptid_t ptid, int stop)\n }\n \n void\n-finish_thread_state (ptid_t ptid)\n+finish_thread_state (process_stratum_target *targ, ptid_t ptid)\n {\n   bool any_started = false;\n \n-  for (thread_info *tp : all_non_exited_threads (ptid))\n+  for (thread_info *tp : all_non_exited_threads (targ, ptid))\n     if (set_running_thread (tp, tp->executing))\n       any_started = true;\n \n@@ -1333,7 +1339,7 @@ switch_to_thread (thread_info *thr)\n {\n   gdb_assert (thr != NULL);\n \n-  if (inferior_ptid == thr->ptid)\n+  if (is_current_thread (thr))\n     return;\n \n   switch_to_thread_no_regs (thr);\n@@ -1344,9 +1350,9 @@ switch_to_thread (thread_info *thr)\n /* See gdbsupport/common-gdbthread.h.  */\n \n void\n-switch_to_thread (ptid_t ptid)\n+switch_to_thread (process_stratum_target *proc_target, ptid_t ptid)\n {\n-  thread_info *thr = find_thread_ptid (ptid);\n+  thread_info *thr = find_thread_ptid (proc_target, ptid);\n   switch_to_thread (thr);\n }\n \n@@ -2073,18 +2079,39 @@ print_selected_thread_frame (struct ui_out *uiout,\n }\n \n /* Update the 'threads_executing' global based on the threads we know\n-   about right now.  */\n+   about right now.  This is used by infrun to tell whether we should\n+   pull events out of the current target.  */\n \n static void\n update_threads_executing (void)\n {\n-  threads_executing = 0;\n-  for (thread_info *tp : all_non_exited_threads ())\n+  process_stratum_target *targ = current_inferior ()->process_target ();\n+\n+  if (targ == NULL)\n+    return;\n+\n+  targ->threads_executing = false;\n+\n+  for (inferior *inf : all_non_exited_inferiors (targ))\n     {\n-      if (tp->executing)\n+      if (!inf->has_execution ())\n+\tcontinue;\n+\n+      /* If the process has no threads, then it must be we have a\n+\t process-exit event pending.  */\n+      if (inf->thread_list == NULL)\n+\t{\n+\t  targ->threads_executing = true;\n+\t  return;\n+\t}\n+\n+      for (thread_info *tp : inf->non_exited_threads ())\n \t{\n-\t  threads_executing = 1;\n-\t  break;\n+\t  if (tp->executing)\n+\t    {\n+\t      targ->threads_executing = true;\n+\t      return;\n+\t    }\n \t}\n     }\n }"
    },
    {
      "sha": "a266bfa59256406b64624b1ee6547c1668b15293",
      "filename": "gdb/top.c",
      "status": "modified",
      "additions": 10,
      "deletions": 7,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/top.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1740,13 +1740,17 @@ quit_force (int *exit_arg, int from_tty)\n \n   /* Give all pushed targets a chance to do minimal cleanup, and pop\n      them all out.  */\n-  try\n+  for (inferior *inf : all_inferiors ())\n     {\n-      pop_all_targets ();\n-    }\n-  catch (const gdb_exception &ex)\n-    {\n-      exception_print (gdb_stderr, ex);\n+      switch_to_inferior_no_thread (inf);\n+      try\n+\t{\n+\t  pop_all_targets ();\n+\t}\n+      catch (const gdb_exception &ex)\n+\t{\n+\t  exception_print (gdb_stderr, ex);\n+\t}\n     }\n \n   /* Save the history information if it is appropriate to do so.  */\n@@ -2298,7 +2302,6 @@ gdb_init (char *argv0)\n #endif\n \n   init_cmd_lists ();\t    /* This needs to be done first.  */\n-  initialize_targets ();    /* Setup target_terminal macros for utils.c.  */\n \n   init_page_info ();\n "
    },
    {
      "sha": "374e9bbcc50723e42bdef2d0cd33219c121c8f03",
      "filename": "gdb/tracectf.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/tracectf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/tracectf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracectf.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -1169,7 +1169,7 @@ ctf_target_open (const char *dirname, int from_tty)\n \n   inferior_appeared (current_inferior (), CTF_PID);\n   inferior_ptid = ptid_t (CTF_PID);\n-  add_thread_silent (inferior_ptid);\n+  add_thread_silent (&ctf_ops, inferior_ptid);\n \n   merge_uploaded_trace_state_variables (&uploaded_tsvs);\n   merge_uploaded_tracepoints (&uploaded_tps);"
    },
    {
      "sha": "c1a4a49337246e34d9586e4a2a8d8db836002d92",
      "filename": "gdb/tracefile-tfile.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/tracefile-tfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/tracefile-tfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracefile-tfile.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -557,7 +557,7 @@ tfile_target_open (const char *arg, int from_tty)\n \n   inferior_appeared (current_inferior (), TFILE_PID);\n   inferior_ptid = ptid_t (TFILE_PID);\n-  add_thread_silent (inferior_ptid);\n+  add_thread_silent (&tfile_ops, inferior_ptid);\n \n   if (ts->traceframe_count <= 0)\n     warning (_(\"No traceframes present in this file.\"));"
    },
    {
      "sha": "be5955d379fb4efcca6779b0aea1036d40657174",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 11,
      "deletions": 9,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2",
      "patch": "@@ -350,6 +350,8 @@ struct windows_nat_target final : public x86_nat_target<inf_child_target>\n   bool get_tib_address (ptid_t ptid, CORE_ADDR *addr) override;\n \n   const char *thread_name (struct thread_info *) override;\n+\n+  int get_windows_debug_event (int pid, struct target_waitstatus *ourstatus);\n };\n \n static windows_nat_target the_windows_nat_target;\n@@ -458,9 +460,9 @@ windows_add_thread (ptid_t ptid, HANDLE h, void *tlb, bool main_thread_p)\n      the main thread silently (in reality, this thread is really\n      more of a process to the user than a thread).  */\n   if (main_thread_p)\n-    add_thread_silent (ptid);\n+    add_thread_silent (&the_windows_nat_target, ptid);\n   else\n-    add_thread (ptid);\n+    add_thread (&the_windows_nat_target, ptid);\n \n   /* Set the debug registers for the new thread if they are used.  */\n   if (debug_registers_used)\n@@ -529,7 +531,7 @@ windows_delete_thread (ptid_t ptid, DWORD exit_code, bool main_thread_p)\n \t\t       target_pid_to_str (ptid).c_str (),\n \t\t       (unsigned) exit_code);\n \n-  delete_thread (find_thread_ptid (ptid));\n+  delete_thread (find_thread_ptid (&the_windows_nat_target, ptid));\n \n   for (th = &thread_head;\n        th->next != NULL && th->next->id != id;\n@@ -1524,9 +1526,10 @@ ctrl_c_handler (DWORD event_type)\n \n /* Get the next event from the child.  Returns a non-zero thread id if the event\n    requires handling by WFI (or whatever).  */\n-static int\n-get_windows_debug_event (struct target_ops *ops,\n-\t\t\t int pid, struct target_waitstatus *ourstatus)\n+\n+int\n+windows_nat_target::get_windows_debug_event (int pid,\n+\t\t\t\t\t     struct target_waitstatus *ourstatus)\n {\n   BOOL debug_event;\n   DWORD continue_status, event_code;\n@@ -1556,8 +1559,7 @@ get_windows_debug_event (struct target_ops *ops,\n \t\t     \"CREATE_THREAD_DEBUG_EVENT\"));\n       if (saw_create != 1)\n \t{\n-\t  struct inferior *inf;\n-\t  inf = find_inferior_pid (current_event.dwProcessId);\n+\t  inferior *inf = find_inferior_pid (this, current_event.dwProcessId);\n \t  if (!saw_create && inf->attach_flag)\n \t    {\n \t      /* Kludge around a Windows bug where first event is a create\n@@ -1779,7 +1781,7 @@ windows_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t     the user tries to resume the execution in the inferior.\n \t     This is a classic race that we should try to fix one day.  */\n       SetConsoleCtrlHandler (&ctrl_c_handler, TRUE);\n-      retval = get_windows_debug_event (this, pid, ourstatus);\n+      retval = get_windows_debug_event (pid, ourstatus);\n       SetConsoleCtrlHandler (&ctrl_c_handler, FALSE);\n \n       if (retval)"
    }
  ]
}