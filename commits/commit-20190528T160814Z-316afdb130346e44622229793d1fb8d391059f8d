{
  "sha": "316afdb130346e44622229793d1fb8d391059f8d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzE2YWZkYjEzMDM0NmU0NDYyMjIyOTc5M2QxZmI4ZDM5MTA1OWY4ZA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-24T10:03:37Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:08:14Z"
    },
    "message": "libctf: core type lookup\n\nFinally we get to the functions used to actually look up and enumerate\nproperties of types in a container (names, sizes, members, what type a\npointer or cv-qual references, determination of whether two types are\nassignment-compatible, etc).\n\nWith a very few exceptions these do not work for types newly added via\nctf_add_*(): they only work on types in read-only containers, or types\nadded before the most recent call to ctf_update().\n\nThis also adds support for lookup of \"variables\" (string -> type ID\nmappings) and for generation of C type names corresponding to a type ID.\n\nlibctf/\n\t* ctf-decl.c: New file.\n\t* ctf-types.c: Likewise.\n\t* ctf-impl.h: New declarations.\n\ninclude/\n\t* ctf-api.h (ctf_visit_f): New definition.\n\t(ctf_member_f): Likewise.\n\t(ctf_enum_f): Likewise.\n\t(ctf_variable_f): Likewise.\n\t(ctf_type_f): Likewise.\n\t(ctf_type_isparent): Likewise.\n\t(ctf_type_ischild): Likewise.\n\t(ctf_type_resolve): Likewise.\n\t(ctf_type_aname): Likewise.\n\t(ctf_type_lname): Likewise.\n\t(ctf_type_name): Likewise.\n\t(ctf_type_sizee): Likewise.\n\t(ctf_type_align): Likewise.\n\t(ctf_type_kind): Likewise.\n\t(ctf_type_reference): Likewise.\n\t(ctf_type_pointer): Likewise.\n\t(ctf_type_encoding): Likewise.\n\t(ctf_type_visit): Likewise.\n\t(ctf_type_cmp): Likewise.\n\t(ctf_type_compat): Likewise.\n\t(ctf_member_info): Likewise.\n\t(ctf_array_info): Likewise.\n\t(ctf_enum_name): Likewise.\n\t(ctf_enum_value): Likewise.\n\t(ctf_member_iter): Likewise.\n\t(ctf_enum_iter): Likewise.\n\t(ctf_type_iter): Likewise.\n\t(ctf_variable_iter): Likewise.",
    "tree": {
      "sha": "869ce03acfa79331cb89475282a11ca7e1cdb7e4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/869ce03acfa79331cb89475282a11ca7e1cdb7e4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/316afdb130346e44622229793d1fb8d391059f8d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/316afdb130346e44622229793d1fb8d391059f8d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/316afdb130346e44622229793d1fb8d391059f8d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/316afdb130346e44622229793d1fb8d391059f8d/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/143dce8481f09f60704ab52b98cf8fe6d8b29fc9"
    }
  ],
  "stats": {
    "total": 1299,
    "additions": 1299,
    "deletions": 0
  },
  "files": [
    {
      "sha": "b935cb4e38f0e24b2498856d745e3f22106b8b54",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/316afdb130346e44622229793d1fb8d391059f8d/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/316afdb130346e44622229793d1fb8d391059f8d/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=316afdb130346e44622229793d1fb8d391059f8d",
      "patch": "@@ -1,3 +1,34 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_visit_f): New definition.\n+\t(ctf_member_f): Likewise.\n+\t(ctf_enum_f): Likewise.\n+\t(ctf_variable_f): Likewise.\n+\t(ctf_type_f): Likewise.\n+\t(ctf_type_isparent): Likewise.\n+\t(ctf_type_ischild): Likewise.\n+\t(ctf_type_resolve): Likewise.\n+\t(ctf_type_aname): Likewise.\n+\t(ctf_type_lname): Likewise.\n+\t(ctf_type_name): Likewise.\n+\t(ctf_type_sizee): Likewise.\n+\t(ctf_type_align): Likewise.\n+\t(ctf_type_kind): Likewise.\n+\t(ctf_type_reference): Likewise.\n+\t(ctf_type_pointer): Likewise.\n+\t(ctf_type_encoding): Likewise.\n+\t(ctf_type_visit): Likewise.\n+\t(ctf_type_cmp): Likewise.\n+\t(ctf_type_compat): Likewise.\n+\t(ctf_member_info): Likewise.\n+\t(ctf_array_info): Likewise.\n+\t(ctf_enum_name): Likewise.\n+\t(ctf_enum_value): Likewise.\n+\t(ctf_member_iter): Likewise.\n+\t(ctf_enum_iter): Likewise.\n+\t(ctf_type_iter): Likewise.\n+\t(ctf_variable_iter): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (struct bfd): New forward."
    },
    {
      "sha": "023c890d7d0e999f37c4dd323dcda284fd49860c",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 36,
      "deletions": 0,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/316afdb130346e44622229793d1fb8d391059f8d/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/316afdb130346e44622229793d1fb8d391059f8d/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=316afdb130346e44622229793d1fb8d391059f8d",
      "patch": "@@ -206,6 +206,13 @@ enum\n /* These typedefs are used to define the signature for callback functions\n    that can be used with the iteration and visit functions below.  */\n \n+typedef int ctf_visit_f (const char *name, ctf_id_t type, unsigned long offset,\n+\t\t\t int depth, void *arg);\n+typedef int ctf_member_f (const char *name, ctf_id_t membtype,\n+\t\t\t  unsigned long offset, void *arg);\n+typedef int ctf_enum_f (const char *name, int val, void *arg);\n+typedef int ctf_variable_f (const char *name, ctf_id_t type, void *arg);\n+typedef int ctf_type_f (ctf_id_t type, void *arg);\n typedef int ctf_archive_member_f (ctf_file_t *fp, const char *name, void *arg);\n typedef int ctf_archive_raw_member_f (const char *name, const void *content,\n \t\t\t\t      size_t len, void *arg);\n@@ -250,6 +257,8 @@ extern int ctf_arc_write (const char *, ctf_file_t **, size_t,\n extern ctf_file_t *ctf_parent_file (ctf_file_t *);\n extern const char *ctf_parent_name (ctf_file_t *);\n extern void ctf_parent_name_set (ctf_file_t *, const char *);\n+extern int ctf_type_isparent (ctf_file_t *, ctf_id_t);\n+extern int ctf_type_ischild (ctf_file_t *, ctf_id_t);\n \n extern int ctf_import (ctf_file_t *, ctf_file_t *);\n extern int ctf_setmodel (ctf_file_t *, int);\n@@ -260,6 +269,32 @@ extern void *ctf_getspecific (ctf_file_t *);\n \n extern int ctf_errno (ctf_file_t *);\n extern const char *ctf_errmsg (int);\n+\n+extern ctf_id_t ctf_type_resolve (ctf_file_t *, ctf_id_t);\n+extern char *ctf_type_aname (ctf_file_t *, ctf_id_t);\n+extern ssize_t ctf_type_lname (ctf_file_t *, ctf_id_t, char *, size_t);\n+extern char *ctf_type_name (ctf_file_t *, ctf_id_t, char *, size_t);\n+extern ssize_t ctf_type_size (ctf_file_t *, ctf_id_t);\n+extern ssize_t ctf_type_align (ctf_file_t *, ctf_id_t);\n+extern int ctf_type_kind (ctf_file_t *, ctf_id_t);\n+extern ctf_id_t ctf_type_reference (ctf_file_t *, ctf_id_t);\n+extern ctf_id_t ctf_type_pointer (ctf_file_t *, ctf_id_t);\n+extern int ctf_type_encoding (ctf_file_t *, ctf_id_t, ctf_encoding_t *);\n+extern int ctf_type_visit (ctf_file_t *, ctf_id_t, ctf_visit_f *, void *);\n+extern int ctf_type_cmp (ctf_file_t *, ctf_id_t, ctf_file_t *, ctf_id_t);\n+extern int ctf_type_compat (ctf_file_t *, ctf_id_t, ctf_file_t *, ctf_id_t);\n+\n+extern int ctf_member_info (ctf_file_t *, ctf_id_t, const char *,\n+\t\t\t    ctf_membinfo_t *);\n+extern int ctf_array_info (ctf_file_t *, ctf_id_t, ctf_arinfo_t *);\n+\n+extern const char *ctf_enum_name (ctf_file_t *, ctf_id_t, int);\n+extern int ctf_enum_value (ctf_file_t *, ctf_id_t, const char *, int *);\n+\n+extern int ctf_member_iter (ctf_file_t *, ctf_id_t, ctf_member_f *, void *);\n+extern int ctf_enum_iter (ctf_file_t *, ctf_id_t, ctf_enum_f *, void *);\n+extern int ctf_type_iter (ctf_file_t *, ctf_type_f *, void *);\n+extern int ctf_variable_iter (ctf_file_t *, ctf_variable_f *, void *);\n extern int ctf_archive_iter (const ctf_archive_t *, ctf_archive_member_f *,\n \t\t\t     void *);\n /* This function alone does not currently operate on CTF files masquerading\n@@ -268,6 +303,7 @@ extern int ctf_archive_iter (const ctf_archive_t *, ctf_archive_member_f *,\n    to deal with non-archives at all.  */\n extern int ctf_archive_raw_iter (const ctf_archive_t *,\n \t\t\t\t ctf_archive_raw_member_f *, void *);\n+\n extern ctf_id_t ctf_add_array (ctf_file_t *, uint32_t,\n \t\t\t       const ctf_arinfo_t *);\n extern ctf_id_t ctf_add_const (ctf_file_t *, uint32_t, ctf_id_t);"
    },
    {
      "sha": "56d6016c20045b4fe99c7e798e61d9325aa7192d",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/316afdb130346e44622229793d1fb8d391059f8d/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/316afdb130346e44622229793d1fb8d391059f8d/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=316afdb130346e44622229793d1fb8d391059f8d",
      "patch": "@@ -1,3 +1,9 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-decl.c: New file.\n+\t* ctf-types.c: Likewise.\n+\t* ctf-impl.h: New declarations.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-open-bfd.c: New file."
    },
    {
      "sha": "c85982e4a3f16ea93c1f10a02296d16334de4eab",
      "filename": "libctf/ctf-decl.c",
      "status": "added",
      "additions": 195,
      "deletions": 0,
      "changes": 195,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/316afdb130346e44622229793d1fb8d391059f8d/libctf/ctf-decl.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/316afdb130346e44622229793d1fb8d391059f8d/libctf/ctf-decl.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-decl.c?ref=316afdb130346e44622229793d1fb8d391059f8d",
      "patch": "@@ -0,0 +1,195 @@\n+/* C declarator syntax glue.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* CTF Declaration Stack\n+\n+   In order to implement ctf_type_name(), we must convert a type graph back\n+   into a C type declaration.  Unfortunately, a type graph represents a storage\n+   class ordering of the type whereas a type declaration must obey the C rules\n+   for operator precedence, and the two orderings are frequently in conflict.\n+   For example, consider these CTF type graphs and their C declarations:\n+\n+   CTF_K_POINTER -> CTF_K_FUNCTION -> CTF_K_INTEGER  : int (*)()\n+   CTF_K_POINTER -> CTF_K_ARRAY -> CTF_K_INTEGER     : int (*)[]\n+\n+   In each case, parentheses are used to raise operator * to higher lexical\n+   precedence, so the string form of the C declaration cannot be constructed by\n+   walking the type graph links and forming the string from left to right.\n+\n+   The functions in this file build a set of stacks from the type graph nodes\n+   corresponding to the C operator precedence levels in the appropriate order.\n+   The code in ctf_type_name() can then iterate over the levels and nodes in\n+   lexical precedence order and construct the final C declaration string.  */\n+\n+#include <ctf-impl.h>\n+#include <string.h>\n+\n+void\n+ctf_decl_init (ctf_decl_t *cd)\n+{\n+  int i;\n+\n+  memset (cd, 0, sizeof (ctf_decl_t));\n+\n+  for (i = CTF_PREC_BASE; i < CTF_PREC_MAX; i++)\n+    cd->cd_order[i] = CTF_PREC_BASE - 1;\n+\n+  cd->cd_qualp = CTF_PREC_BASE;\n+  cd->cd_ordp = CTF_PREC_BASE;\n+}\n+\n+void\n+ctf_decl_fini (ctf_decl_t *cd)\n+{\n+  ctf_decl_node_t *cdp, *ndp;\n+  int i;\n+\n+  for (i = CTF_PREC_BASE; i < CTF_PREC_MAX; i++)\n+    {\n+      for (cdp = ctf_list_next (&cd->cd_nodes[i]); cdp != NULL; cdp = ndp)\n+\t{\n+\t  ndp = ctf_list_next (cdp);\n+\t  ctf_free (cdp);\n+\t}\n+    }\n+}\n+\n+void\n+ctf_decl_push (ctf_decl_t *cd, ctf_file_t *fp, ctf_id_t type)\n+{\n+  ctf_decl_node_t *cdp;\n+  ctf_decl_prec_t prec;\n+  uint32_t kind, n = 1;\n+  int is_qual = 0;\n+\n+  const ctf_type_t *tp;\n+  ctf_arinfo_t ar;\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    {\n+      cd->cd_err = fp->ctf_errno;\n+      return;\n+    }\n+\n+  switch (kind = LCTF_INFO_KIND (fp, tp->ctt_info))\n+    {\n+    case CTF_K_ARRAY:\n+      (void) ctf_array_info (fp, type, &ar);\n+      ctf_decl_push (cd, fp, ar.ctr_contents);\n+      n = ar.ctr_nelems;\n+      prec = CTF_PREC_ARRAY;\n+      break;\n+\n+    case CTF_K_TYPEDEF:\n+      if (ctf_strptr (fp, tp->ctt_name)[0] == '\\0')\n+\t{\n+\t  ctf_decl_push (cd, fp, tp->ctt_type);\n+\t  return;\n+\t}\n+      prec = CTF_PREC_BASE;\n+      break;\n+\n+    case CTF_K_FUNCTION:\n+      ctf_decl_push (cd, fp, tp->ctt_type);\n+      prec = CTF_PREC_FUNCTION;\n+      break;\n+\n+    case CTF_K_POINTER:\n+      ctf_decl_push (cd, fp, tp->ctt_type);\n+      prec = CTF_PREC_POINTER;\n+      break;\n+\n+    case CTF_K_SLICE:\n+      ctf_decl_push (cd, fp, ctf_type_reference (fp, type));\n+      prec = CTF_PREC_BASE;\n+      break;\n+\n+    case CTF_K_VOLATILE:\n+    case CTF_K_CONST:\n+    case CTF_K_RESTRICT:\n+      ctf_decl_push (cd, fp, tp->ctt_type);\n+      prec = cd->cd_qualp;\n+      is_qual++;\n+      break;\n+\n+    default:\n+      prec = CTF_PREC_BASE;\n+    }\n+\n+  if ((cdp = ctf_alloc (sizeof (ctf_decl_node_t))) == NULL)\n+    {\n+      cd->cd_err = EAGAIN;\n+      return;\n+    }\n+\n+  cdp->cd_type = type;\n+  cdp->cd_kind = kind;\n+  cdp->cd_n = n;\n+\n+  if (ctf_list_next (&cd->cd_nodes[prec]) == NULL)\n+    cd->cd_order[prec] = cd->cd_ordp++;\n+\n+  /* Reset cd_qualp to the highest precedence level that we've seen so\n+     far that can be qualified (CTF_PREC_BASE or CTF_PREC_POINTER).  */\n+\n+  if (prec > cd->cd_qualp && prec < CTF_PREC_ARRAY)\n+    cd->cd_qualp = prec;\n+\n+  /* C array declarators are ordered inside out so prepend them.  Also by\n+     convention qualifiers of base types precede the type specifier (e.g.\n+     const int vs. int const) even though the two forms are equivalent.  */\n+\n+  if (kind == CTF_K_ARRAY || (is_qual && prec == CTF_PREC_BASE))\n+    ctf_list_prepend (&cd->cd_nodes[prec], cdp);\n+  else\n+    ctf_list_append (&cd->cd_nodes[prec], cdp);\n+}\n+\n+_libctf_printflike_ (2, 3)\n+void ctf_decl_sprintf (ctf_decl_t *cd, const char *format, ...)\n+{\n+  va_list ap;\n+  char *str;\n+  int n;\n+\n+  if (cd->cd_enomem)\n+    return;\n+\n+  va_start (ap, format);\n+  n = vasprintf (&str, format, ap);\n+  va_end (ap);\n+\n+  if (n > 0)\n+      cd->cd_buf = ctf_str_append (cd->cd_buf, str);\n+\n+  /* Sticky error condition.  */\n+  if (n < 0)\n+    {\n+      free (cd->cd_buf);\n+      cd->cd_buf = NULL;\n+      cd->cd_enomem = 1;\n+    }\n+\n+  free (str);\n+}\n+\n+char *ctf_decl_buf (ctf_decl_t *cd)\n+{\n+  return cd->cd_buf;\n+}"
    },
    {
      "sha": "cd8450550eb0b9f8193b255966e3afc06966f3d9",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/316afdb130346e44622229793d1fb8d391059f8d/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/316afdb130346e44622229793d1fb8d391059f8d/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=316afdb130346e44622229793d1fb8d391059f8d",
      "patch": "@@ -324,6 +324,14 @@ extern void ctf_dvd_insert (ctf_file_t *, ctf_dvdef_t *);\n extern void ctf_dvd_delete (ctf_file_t *, ctf_dvdef_t *);\n extern ctf_dvdef_t *ctf_dvd_lookup (const ctf_file_t *, const char *);\n \n+extern void ctf_decl_init (ctf_decl_t *);\n+extern void ctf_decl_fini (ctf_decl_t *);\n+extern void ctf_decl_push (ctf_decl_t *, ctf_file_t *, ctf_id_t);\n+\n+_libctf_printflike_ (2, 3)\n+extern void ctf_decl_sprintf (ctf_decl_t *, const char *, ...);\n+extern char *ctf_decl_buf (ctf_decl_t *cd);\n+\n extern const char *ctf_strraw (ctf_file_t *, uint32_t);\n extern const char *ctf_strptr (ctf_file_t *, uint32_t);\n "
    },
    {
      "sha": "a7fe5d0b184525d3290915892597979e81396e89",
      "filename": "libctf/ctf-types.c",
      "status": "added",
      "additions": 1023,
      "deletions": 0,
      "changes": 1023,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/316afdb130346e44622229793d1fb8d391059f8d/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/316afdb130346e44622229793d1fb8d391059f8d/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=316afdb130346e44622229793d1fb8d391059f8d",
      "patch": "@@ -0,0 +1,1023 @@\n+/* Type handling functions.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <string.h>\n+\n+/* Determine whether a type is a parent or a child.  */\n+\n+int\n+ctf_type_isparent (ctf_file_t *fp, ctf_id_t id)\n+{\n+  return (LCTF_TYPE_ISPARENT (fp, id));\n+}\n+\n+int\n+ctf_type_ischild (ctf_file_t * fp, ctf_id_t id)\n+{\n+  return (LCTF_TYPE_ISCHILD (fp, id));\n+}\n+\n+/* Iterate over the members of a STRUCT or UNION.  We pass the name, member\n+   type, and offset of each member to the specified callback function.  */\n+\n+int\n+ctf_member_iter (ctf_file_t *fp, ctf_id_t type, ctf_member_f *func, void *arg)\n+{\n+  ctf_file_t *ofp = fp;\n+  const ctf_type_t *tp;\n+  ssize_t size, increment;\n+  uint32_t kind, n;\n+  int rc;\n+\n+  if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n+  kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n+\n+  if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n+    return (ctf_set_errno (ofp, ECTF_NOTSOU));\n+\n+  if (size < CTF_LSTRUCT_THRESH)\n+    {\n+      const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t       increment);\n+\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+\t{\n+\t  const char *name = ctf_strptr (fp, mp->ctm_name);\n+\t  if ((rc = func (name, mp->ctm_type, mp->ctm_offset, arg)) != 0)\n+\t    return rc;\n+\t}\n+\n+    }\n+  else\n+    {\n+      const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t  increment);\n+\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+\t{\n+\t  const char *name = ctf_strptr (fp, lmp->ctlm_name);\n+\t  if ((rc = func (name, lmp->ctlm_type,\n+\t\t\t  (unsigned long) CTF_LMEM_OFFSET (lmp), arg)) != 0)\n+\t    return rc;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Iterate over the members of an ENUM.  We pass the string name and associated\n+   integer value of each enum element to the specified callback function.  */\n+\n+int\n+ctf_enum_iter (ctf_file_t *fp, ctf_id_t type, ctf_enum_f *func, void *arg)\n+{\n+  ctf_file_t *ofp = fp;\n+  const ctf_type_t *tp;\n+  const ctf_enum_t *ep;\n+  ssize_t increment;\n+  uint32_t n;\n+  int rc;\n+\n+  if ((type = ctf_type_resolve_unsliced (fp, type)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if (LCTF_INFO_KIND (fp, tp->ctt_info) != CTF_K_ENUM)\n+    return (ctf_set_errno (ofp, ECTF_NOTENUM));\n+\n+  (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n+\n+  ep = (const ctf_enum_t *) ((uintptr_t) tp + increment);\n+\n+  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n+    {\n+      const char *name = ctf_strptr (fp, ep->cte_name);\n+      if ((rc = func (name, ep->cte_value, arg)) != 0)\n+\treturn rc;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Iterate over every root (user-visible) type in the given CTF container.\n+   We pass the type ID of each type to the specified callback function.  */\n+\n+int\n+ctf_type_iter (ctf_file_t *fp, ctf_type_f *func, void *arg)\n+{\n+  ctf_id_t id, max = fp->ctf_typemax;\n+  int rc, child = (fp->ctf_flags & LCTF_CHILD);\n+\n+  for (id = 1; id <= max; id++)\n+    {\n+      const ctf_type_t *tp = LCTF_INDEX_TO_TYPEPTR (fp, id);\n+      if (LCTF_INFO_ISROOT (fp, tp->ctt_info)\n+\t  && (rc = func (LCTF_INDEX_TO_TYPE (fp, id, child), arg)) != 0)\n+\treturn rc;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Iterate over every variable in the given CTF container, in arbitrary order.\n+   We pass the name of each variable to the specified callback function.  */\n+\n+int\n+ctf_variable_iter (ctf_file_t *fp, ctf_variable_f *func, void *arg)\n+{\n+  unsigned long i;\n+  int rc;\n+\n+  if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parent == NULL))\n+    return ECTF_NOPARENT;\n+\n+  for (i = 0; i < fp->ctf_nvars; i++)\n+    if ((rc = func (ctf_strptr (fp, fp->ctf_vars[i].ctv_name),\n+\t\t    fp->ctf_vars[i].ctv_type, arg)) != 0)\n+      return rc;\n+\n+  return 0;\n+}\n+\n+/* Follow a given type through the graph for TYPEDEF, VOLATILE, CONST, and\n+   RESTRICT nodes until we reach a \"base\" type node.  This is useful when\n+   we want to follow a type ID to a node that has members or a size.  To guard\n+   against infinite loops, we implement simplified cycle detection and check\n+   each link against itself, the previous node, and the topmost node.\n+\n+   Does not drill down through slices to their contained type.  */\n+\n+ctf_id_t\n+ctf_type_resolve (ctf_file_t *fp, ctf_id_t type)\n+{\n+  ctf_id_t prev = type, otype = type;\n+  ctf_file_t *ofp = fp;\n+  const ctf_type_t *tp;\n+\n+  while ((tp = ctf_lookup_by_id (&fp, type)) != NULL)\n+    {\n+      switch (LCTF_INFO_KIND (fp, tp->ctt_info))\n+\t{\n+\tcase CTF_K_TYPEDEF:\n+\tcase CTF_K_VOLATILE:\n+\tcase CTF_K_CONST:\n+\tcase CTF_K_RESTRICT:\n+\t  if (tp->ctt_type == type || tp->ctt_type == otype\n+\t      || tp->ctt_type == prev)\n+\t    {\n+\t      ctf_dprintf (\"type %ld cycle detected\\n\", otype);\n+\t      return (ctf_set_errno (ofp, ECTF_CORRUPT));\n+\t    }\n+\t  prev = type;\n+\t  type = tp->ctt_type;\n+\t  break;\n+\tdefault:\n+\t  return type;\n+\t}\n+    }\n+\n+  return CTF_ERR;\t\t/* errno is set for us.  */\n+}\n+\n+/* Like ctf_type_resolve(), but traverse down through slices to their contained\n+   type.  */\n+\n+ctf_id_t\n+ctf_type_resolve_unsliced (ctf_file_t *fp, ctf_id_t type)\n+{\n+  const ctf_type_t *tp;\n+\n+  if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n+    return -1;\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((LCTF_INFO_KIND (fp, tp->ctt_info)) == CTF_K_SLICE)\n+    return ctf_type_reference (fp, type);\n+  return type;\n+}\n+\n+/* Lookup the given type ID and return its name as a new dynamcally-allocated\n+   string.  */\n+\n+char *\n+ctf_type_aname (ctf_file_t *fp, ctf_id_t type)\n+{\n+  ctf_decl_t cd;\n+  ctf_decl_node_t *cdp;\n+  ctf_decl_prec_t prec, lp, rp;\n+  int ptr, arr;\n+  uint32_t k;\n+  char *buf;\n+\n+  if (fp == NULL && type == CTF_ERR)\n+    return NULL;\t/* Simplify caller code by permitting CTF_ERR.  */\n+\n+  ctf_decl_init (&cd);\n+  ctf_decl_push (&cd, fp, type);\n+\n+  if (cd.cd_err != 0)\n+    {\n+      ctf_decl_fini (&cd);\n+      ctf_set_errno (fp, cd.cd_err);\n+      return NULL;\n+    }\n+\n+  /* If the type graph's order conflicts with lexical precedence order\n+     for pointers or arrays, then we need to surround the declarations at\n+     the corresponding lexical precedence with parentheses.  This can\n+     result in either a parenthesized pointer (*) as in int (*)() or\n+     int (*)[], or in a parenthesized pointer and array as in int (*[])().  */\n+\n+  ptr = cd.cd_order[CTF_PREC_POINTER] > CTF_PREC_POINTER;\n+  arr = cd.cd_order[CTF_PREC_ARRAY] > CTF_PREC_ARRAY;\n+\n+  rp = arr ? CTF_PREC_ARRAY : ptr ? CTF_PREC_POINTER : -1;\n+  lp = ptr ? CTF_PREC_POINTER : arr ? CTF_PREC_ARRAY : -1;\n+\n+  k = CTF_K_POINTER;\t\t/* Avoid leading whitespace (see below).  */\n+\n+  for (prec = CTF_PREC_BASE; prec < CTF_PREC_MAX; prec++)\n+    {\n+      for (cdp = ctf_list_next (&cd.cd_nodes[prec]);\n+\t   cdp != NULL; cdp = ctf_list_next (cdp))\n+\t{\n+\t  ctf_file_t *rfp = fp;\n+\t  const ctf_type_t *tp = ctf_lookup_by_id (&rfp, cdp->cd_type);\n+\t  const char *name = ctf_strptr (rfp, tp->ctt_name);\n+\n+\t  if (k != CTF_K_POINTER && k != CTF_K_ARRAY)\n+\t    ctf_decl_sprintf (&cd, \" \");\n+\n+\t  if (lp == prec)\n+\t    {\n+\t      ctf_decl_sprintf (&cd, \"(\");\n+\t      lp = -1;\n+\t    }\n+\n+\t  switch (cdp->cd_kind)\n+\t    {\n+\t    case CTF_K_INTEGER:\n+\t    case CTF_K_FLOAT:\n+\t    case CTF_K_TYPEDEF:\n+\t      ctf_decl_sprintf (&cd, \"%s\", name);\n+\t      break;\n+\t    case CTF_K_POINTER:\n+\t      ctf_decl_sprintf (&cd, \"*\");\n+\t      break;\n+\t    case CTF_K_ARRAY:\n+\t      ctf_decl_sprintf (&cd, \"[%u]\", cdp->cd_n);\n+\t      break;\n+\t    case CTF_K_FUNCTION:\n+\t      ctf_decl_sprintf (&cd, \"()\");\n+\t      break;\n+\t    case CTF_K_STRUCT:\n+\t    case CTF_K_FORWARD:\n+\t      ctf_decl_sprintf (&cd, \"struct %s\", name);\n+\t      break;\n+\t    case CTF_K_UNION:\n+\t      ctf_decl_sprintf (&cd, \"union %s\", name);\n+\t      break;\n+\t    case CTF_K_ENUM:\n+\t      ctf_decl_sprintf (&cd, \"enum %s\", name);\n+\t      break;\n+\t    case CTF_K_VOLATILE:\n+\t      ctf_decl_sprintf (&cd, \"volatile\");\n+\t      break;\n+\t    case CTF_K_CONST:\n+\t      ctf_decl_sprintf (&cd, \"const\");\n+\t      break;\n+\t    case CTF_K_RESTRICT:\n+\t      ctf_decl_sprintf (&cd, \"restrict\");\n+\t      break;\n+\t    case CTF_K_SLICE:\n+\t      /* No representation: just changes encoding of contained type,\n+\t\t which is not in any case printed.  Skip it.  */\n+\t      break;\n+\t    }\n+\n+\t  k = cdp->cd_kind;\n+\t}\n+\n+      if (rp == prec)\n+\tctf_decl_sprintf (&cd, \")\");\n+    }\n+\n+  if (cd.cd_enomem)\n+    (void) ctf_set_errno (fp, ENOMEM);\n+\n+  buf = ctf_decl_buf (&cd);\n+\n+  ctf_decl_fini (&cd);\n+  return buf;\n+}\n+\n+/* Lookup the given type ID and print a string name for it into buf.  Return\n+   the actual number of bytes (not including \\0) needed to format the name.  */\n+\n+ssize_t\n+ctf_type_lname (ctf_file_t *fp, ctf_id_t type, char *buf, size_t len)\n+{\n+  char *str = ctf_type_aname (fp, type);\n+  size_t slen = strlen (str);\n+\n+  if (str == NULL)\n+    return CTF_ERR;             /* errno is set for us */\n+\n+  snprintf (buf, len, \"%s\", str);\n+  free (str);\n+\n+  if (slen >= len)\n+    (void) ctf_set_errno (fp, ECTF_NAMELEN);\n+\n+  return slen;\n+}\n+\n+/* Lookup the given type ID and print a string name for it into buf.  If buf\n+   is too small, return NULL: the ECTF_NAMELEN error is set on 'fp' for us.  */\n+\n+char *\n+ctf_type_name (ctf_file_t *fp, ctf_id_t type, char *buf, size_t len)\n+{\n+  ssize_t rv = ctf_type_lname (fp, type, buf, len);\n+  return (rv >= 0 && (size_t) rv < len ? buf : NULL);\n+}\n+\n+/* Resolve the type down to a base type node, and then return the size\n+   of the type storage in bytes.  */\n+\n+ssize_t\n+ctf_type_size (ctf_file_t *fp, ctf_id_t type)\n+{\n+  const ctf_type_t *tp;\n+  ssize_t size;\n+  ctf_arinfo_t ar;\n+\n+  if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n+    return -1;\t\t\t/* errno is set for us.  */\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return -1;\t\t\t/* errno is set for us.  */\n+\n+  switch (LCTF_INFO_KIND (fp, tp->ctt_info))\n+    {\n+    case CTF_K_POINTER:\n+      return fp->ctf_dmodel->ctd_pointer;\n+\n+    case CTF_K_FUNCTION:\n+      return 0;\t\t/* Function size is only known by symtab.  */\n+\n+    case CTF_K_ENUM:\n+      return fp->ctf_dmodel->ctd_int;\n+\n+    case CTF_K_ARRAY:\n+      /* ctf_add_array() does not directly encode the element size, but\n+\t requires the user to multiply to determine the element size.\n+\n+\t If ctf_get_ctt_size() returns nonzero, then use the recorded\n+\t size instead.  */\n+\n+      if ((size = ctf_get_ctt_size (fp, tp, NULL, NULL)) > 0)\n+\treturn size;\n+\n+      if (ctf_array_info (fp, type, &ar) == CTF_ERR\n+\t  || (size = ctf_type_size (fp, ar.ctr_contents)) == CTF_ERR)\n+\treturn -1;\t\t/* errno is set for us.  */\n+\n+      return size * ar.ctr_nelems;\n+\n+    default: /* including slices of enums, etc */\n+      return (ctf_get_ctt_size (fp, tp, NULL, NULL));\n+    }\n+}\n+\n+/* Resolve the type down to a base type node, and then return the alignment\n+   needed for the type storage in bytes.\n+\n+   XXX may need arch-dependent attention.  */\n+\n+ssize_t\n+ctf_type_align (ctf_file_t *fp, ctf_id_t type)\n+{\n+  const ctf_type_t *tp;\n+  ctf_file_t *ofp = fp;\n+  int kind;\n+\n+  if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n+    return -1;\t\t\t/* errno is set for us.  */\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return -1;\t\t\t/* errno is set for us.  */\n+\n+  kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n+  switch (kind)\n+    {\n+    case CTF_K_POINTER:\n+    case CTF_K_FUNCTION:\n+      return fp->ctf_dmodel->ctd_pointer;\n+\n+    case CTF_K_ARRAY:\n+      {\n+\tctf_arinfo_t r;\n+\tif (ctf_array_info (fp, type, &r) == CTF_ERR)\n+\t  return -1;\t\t/* errno is set for us.  */\n+\treturn (ctf_type_align (fp, r.ctr_contents));\n+      }\n+\n+    case CTF_K_STRUCT:\n+    case CTF_K_UNION:\n+      {\n+\tsize_t align = 0;\n+\tctf_dtdef_t *dtd;\n+\n+\tif ((dtd = ctf_dynamic_type (ofp, type)) == NULL)\n+\t  {\n+\t    uint32_t n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n+\t    ssize_t size, increment;\n+\t    const void *vmp;\n+\n+\t    (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n+\t    vmp = (unsigned char *) tp + increment;\n+\n+\t    if (kind == CTF_K_STRUCT)\n+\t      n = MIN (n, 1);\t/* Only use first member for structs.  */\n+\n+\t    if (size < CTF_LSTRUCT_THRESH)\n+\t      {\n+\t\tconst ctf_member_t *mp = vmp;\n+\t\tfor (; n != 0; n--, mp++)\n+\t\t  {\n+\t\t    ssize_t am = ctf_type_align (fp, mp->ctm_type);\n+\t\t    align = MAX (align, am);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tconst ctf_lmember_t *lmp = vmp;\n+\t\tfor (; n != 0; n--, lmp++)\n+\t\t  {\n+\t\t    ssize_t am = ctf_type_align (fp, lmp->ctlm_type);\n+\t\t    align = MAX (align, am);\n+\t\t  }\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t      ctf_dmdef_t *dmd;\n+\n+\t      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t\t   dmd != NULL; dmd = ctf_list_next (dmd))\n+\t\t{\n+\t\t  ssize_t am = ctf_type_align (fp, dmd->dmd_type);\n+\t\t  align = MAX (align, am);\n+\t\t  if (kind == CTF_K_STRUCT)\n+\t\t    break;\n+\t\t}\n+\t  }\n+\n+\treturn align;\n+      }\n+\n+    case CTF_K_ENUM:\n+      return fp->ctf_dmodel->ctd_int;\n+\n+    default:  /* including slices of enums, etc */\n+      return (ctf_get_ctt_size (fp, tp, NULL, NULL));\n+    }\n+}\n+\n+/* Return the kind (CTF_K_* constant) for the specified type ID.  */\n+\n+int\n+ctf_type_kind_unsliced (ctf_file_t *fp, ctf_id_t type)\n+{\n+  const ctf_type_t *tp;\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  return (LCTF_INFO_KIND (fp, tp->ctt_info));\n+}\n+\n+/* Return the kind (CTF_K_* constant) for the specified type ID.\n+   Slices are considered to be of the same kind as the type sliced.  */\n+\n+int\n+ctf_type_kind (ctf_file_t *fp, ctf_id_t type)\n+{\n+  int kind;\n+\n+  if ((kind = ctf_type_kind_unsliced (fp, type)) == CTF_ERR)\n+    return CTF_ERR;\n+\n+  if (kind == CTF_K_SLICE)\n+    {\n+      if ((type = ctf_type_reference (fp, type)) == CTF_ERR)\n+\treturn CTF_ERR;\n+      kind = ctf_type_kind_unsliced (fp, type);\n+    }\n+\n+  return kind;\n+}\n+\n+/* If the type is one that directly references another type (such as POINTER),\n+   then return the ID of the type to which it refers.  */\n+\n+ctf_id_t\n+ctf_type_reference (ctf_file_t *fp, ctf_id_t type)\n+{\n+  ctf_file_t *ofp = fp;\n+  const ctf_type_t *tp;\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  switch (LCTF_INFO_KIND (fp, tp->ctt_info))\n+    {\n+    case CTF_K_POINTER:\n+    case CTF_K_TYPEDEF:\n+    case CTF_K_VOLATILE:\n+    case CTF_K_CONST:\n+    case CTF_K_RESTRICT:\n+      return tp->ctt_type;\n+      /* Slices store their type in an unusual place.  */\n+    case CTF_K_SLICE:\n+      {\n+\tconst ctf_slice_t *sp;\n+\tssize_t increment;\n+\t(void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n+\tsp = (const ctf_slice_t *) ((uintptr_t) tp + increment);\n+\treturn sp->cts_type;\n+      }\n+    default:\n+      return (ctf_set_errno (ofp, ECTF_NOTREF));\n+    }\n+}\n+\n+/* Find a pointer to type by looking in fp->ctf_ptrtab.  If we can't find a\n+   pointer to the given type, see if we can compute a pointer to the type\n+   resulting from resolving the type down to its base type and use that\n+   instead.  This helps with cases where the CTF data includes \"struct foo *\"\n+   but not \"foo_t *\" and the user accesses \"foo_t *\" in the debugger.\n+\n+   XXX what about parent containers?  */\n+\n+ctf_id_t\n+ctf_type_pointer (ctf_file_t *fp, ctf_id_t type)\n+{\n+  ctf_file_t *ofp = fp;\n+  ctf_id_t ntype;\n+\n+  if (ctf_lookup_by_id (&fp, type) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((ntype = fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, type)]) != 0)\n+    return (LCTF_INDEX_TO_TYPE (fp, ntype, (fp->ctf_flags & LCTF_CHILD)));\n+\n+  if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n+    return (ctf_set_errno (ofp, ECTF_NOTYPE));\n+\n+  if (ctf_lookup_by_id (&fp, type) == NULL)\n+    return (ctf_set_errno (ofp, ECTF_NOTYPE));\n+\n+  if ((ntype = fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, type)]) != 0)\n+    return (LCTF_INDEX_TO_TYPE (fp, ntype, (fp->ctf_flags & LCTF_CHILD)));\n+\n+  return (ctf_set_errno (ofp, ECTF_NOTYPE));\n+}\n+\n+/* Return the encoding for the specified INTEGER or FLOAT.  */\n+\n+int\n+ctf_type_encoding (ctf_file_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n+{\n+  ctf_file_t *ofp = fp;\n+  ctf_dtdef_t *dtd;\n+  const ctf_type_t *tp;\n+  ssize_t increment;\n+  uint32_t data;\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((dtd = ctf_dynamic_type (ofp, type)) != NULL)\n+    {\n+      *ep = dtd->dtd_u.dtu_enc;\n+      return 0;\n+    }\n+\n+  (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n+\n+  switch (LCTF_INFO_KIND (fp, tp->ctt_info))\n+    {\n+    case CTF_K_INTEGER:\n+      data = *(const uint32_t *) ((uintptr_t) tp + increment);\n+      ep->cte_format = CTF_INT_ENCODING (data);\n+      ep->cte_offset = CTF_INT_OFFSET (data);\n+      ep->cte_bits = CTF_INT_BITS (data);\n+      break;\n+    case CTF_K_FLOAT:\n+      data = *(const uint32_t *) ((uintptr_t) tp + increment);\n+      ep->cte_format = CTF_FP_ENCODING (data);\n+      ep->cte_offset = CTF_FP_OFFSET (data);\n+      ep->cte_bits = CTF_FP_BITS (data);\n+      break;\n+    case CTF_K_SLICE:\n+      {\n+\tconst ctf_slice_t *slice;\n+\tctf_encoding_t underlying_en;\n+\n+\tslice = (ctf_slice_t *) ((uintptr_t) tp + increment);\n+\tdata = ctf_type_encoding (fp, slice->cts_type, &underlying_en);\n+\n+\tep->cte_format = underlying_en.cte_format;\n+\tep->cte_offset = slice->cts_offset;\n+\tep->cte_bits = slice->cts_bits;\n+\tbreak;\n+      }\n+    default:\n+      return (ctf_set_errno (ofp, ECTF_NOTINTFP));\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+ctf_type_cmp (ctf_file_t *lfp, ctf_id_t ltype, ctf_file_t *rfp,\n+\t      ctf_id_t rtype)\n+{\n+  int rval;\n+\n+  if (ltype < rtype)\n+    rval = -1;\n+  else if (ltype > rtype)\n+    rval = 1;\n+  else\n+    rval = 0;\n+\n+  if (lfp == rfp)\n+    return rval;\n+\n+  if (LCTF_TYPE_ISPARENT (lfp, ltype) && lfp->ctf_parent != NULL)\n+    lfp = lfp->ctf_parent;\n+\n+  if (LCTF_TYPE_ISPARENT (rfp, rtype) && rfp->ctf_parent != NULL)\n+    rfp = rfp->ctf_parent;\n+\n+  if (lfp < rfp)\n+    return -1;\n+\n+  if (lfp > rfp)\n+    return 1;\n+\n+  return rval;\n+}\n+\n+/* Return a boolean value indicating if two types are compatible.  This function\n+   returns true if the two types are the same, or if they (or their ultimate\n+   base type) have the same encoding properties, or (for structs / unions /\n+   enums / forward declarations) if they have the same name and (for structs /\n+   unions) member count.  */\n+\n+int\n+ctf_type_compat (ctf_file_t *lfp, ctf_id_t ltype,\n+\t\t ctf_file_t *rfp, ctf_id_t rtype)\n+{\n+  const ctf_type_t *ltp, *rtp;\n+  ctf_encoding_t le, re;\n+  ctf_arinfo_t la, ra;\n+  uint32_t lkind, rkind;\n+  int same_names = 0;\n+\n+  if (ctf_type_cmp (lfp, ltype, rfp, rtype) == 0)\n+    return 1;\n+\n+  ltype = ctf_type_resolve (lfp, ltype);\n+  lkind = ctf_type_kind (lfp, ltype);\n+\n+  rtype = ctf_type_resolve (rfp, rtype);\n+  rkind = ctf_type_kind (rfp, rtype);\n+\n+  ltp = ctf_lookup_by_id (&lfp, ltype);\n+  rtp = ctf_lookup_by_id (&rfp, rtype);\n+\n+  if (ltp != NULL && rtp != NULL)\n+    same_names = (strcmp (ctf_strptr (lfp, ltp->ctt_name),\n+\t\t\t  ctf_strptr (rfp, rtp->ctt_name)) == 0);\n+\n+  if (((lkind == CTF_K_ENUM) && (rkind == CTF_K_INTEGER)) ||\n+      ((rkind == CTF_K_ENUM) && (lkind == CTF_K_INTEGER)))\n+    return 1;\n+\n+  if (lkind != rkind)\n+    return 0;\n+\n+  switch (lkind)\n+    {\n+    case CTF_K_INTEGER:\n+    case CTF_K_FLOAT:\n+      memset (&le, 0, sizeof (le));\n+      memset (&re, 0, sizeof (re));\n+      return (ctf_type_encoding (lfp, ltype, &le) == 0\n+\t      && ctf_type_encoding (rfp, rtype, &re) == 0\n+\t      && memcmp (&le, &re, sizeof (ctf_encoding_t)) == 0);\n+    case CTF_K_POINTER:\n+      return (ctf_type_compat (lfp, ctf_type_reference (lfp, ltype),\n+\t\t\t       rfp, ctf_type_reference (rfp, rtype)));\n+    case CTF_K_ARRAY:\n+      return (ctf_array_info (lfp, ltype, &la) == 0\n+\t      && ctf_array_info (rfp, rtype, &ra) == 0\n+\t      && la.ctr_nelems == ra.ctr_nelems\n+\t      && ctf_type_compat (lfp, la.ctr_contents, rfp, ra.ctr_contents)\n+\t      && ctf_type_compat (lfp, la.ctr_index, rfp, ra.ctr_index));\n+    case CTF_K_STRUCT:\n+    case CTF_K_UNION:\n+      return (same_names && (ctf_type_size (lfp, ltype)\n+\t\t\t     == ctf_type_size (rfp, rtype)));\n+    case CTF_K_ENUM:\n+      {\n+\tint lencoded, rencoded;\n+\tlencoded = ctf_type_encoding (lfp, ltype, &le);\n+\trencoded = ctf_type_encoding (rfp, rtype, &re);\n+\n+\tif ((lencoded != rencoded) ||\n+\t    ((lencoded == 0) && memcmp (&le, &re, sizeof (ctf_encoding_t)) != 0))\n+\t  return 0;\n+      }\n+      /* FALLTHRU */\n+    case CTF_K_FORWARD:\n+      return same_names;   /* No other checks required for these type kinds.  */\n+    default:\n+      return 0;\t\t      /* Should not get here since we did a resolve.  */\n+    }\n+}\n+\n+/* Return the type and offset for a given member of a STRUCT or UNION.  */\n+\n+int\n+ctf_member_info (ctf_file_t *fp, ctf_id_t type, const char *name,\n+\t\t ctf_membinfo_t *mip)\n+{\n+  ctf_file_t *ofp = fp;\n+  const ctf_type_t *tp;\n+  ssize_t size, increment;\n+  uint32_t kind, n;\n+\n+  if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n+  kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n+\n+  if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n+    return (ctf_set_errno (ofp, ECTF_NOTSOU));\n+\n+  if (size < CTF_LSTRUCT_THRESH)\n+    {\n+      const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t       increment);\n+\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+\t{\n+\t  if (strcmp (ctf_strptr (fp, mp->ctm_name), name) == 0)\n+\t    {\n+\t      mip->ctm_type = mp->ctm_type;\n+\t      mip->ctm_offset = mp->ctm_offset;\n+\t      return 0;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t  increment);\n+\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+\t{\n+\t  if (strcmp (ctf_strptr (fp, lmp->ctlm_name), name) == 0)\n+\t    {\n+\t      mip->ctm_type = lmp->ctlm_type;\n+\t      mip->ctm_offset = (unsigned long) CTF_LMEM_OFFSET (lmp);\n+\t      return 0;\n+\t    }\n+\t}\n+    }\n+\n+  return (ctf_set_errno (ofp, ECTF_NOMEMBNAM));\n+}\n+\n+/* Return the array type, index, and size information for the specified ARRAY.  */\n+\n+int\n+ctf_array_info (ctf_file_t *fp, ctf_id_t type, ctf_arinfo_t *arp)\n+{\n+  ctf_file_t *ofp = fp;\n+  const ctf_type_t *tp;\n+  const ctf_array_t *ap;\n+  const ctf_dtdef_t *dtd;\n+  ssize_t increment;\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if (LCTF_INFO_KIND (fp, tp->ctt_info) != CTF_K_ARRAY)\n+    return (ctf_set_errno (ofp, ECTF_NOTARRAY));\n+\n+  if ((dtd = ctf_dynamic_type (ofp, type)) != NULL)\n+    {\n+      *arp = dtd->dtd_u.dtu_arr;\n+      return 0;\n+    }\n+\n+  (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n+\n+  ap = (const ctf_array_t *) ((uintptr_t) tp + increment);\n+  arp->ctr_contents = ap->cta_contents;\n+  arp->ctr_index = ap->cta_index;\n+  arp->ctr_nelems = ap->cta_nelems;\n+\n+  return 0;\n+}\n+\n+/* Convert the specified value to the corresponding enum tag name, if a\n+   matching name can be found.  Otherwise NULL is returned.  */\n+\n+const char *\n+ctf_enum_name (ctf_file_t *fp, ctf_id_t type, int value)\n+{\n+  ctf_file_t *ofp = fp;\n+  const ctf_type_t *tp;\n+  const ctf_enum_t *ep;\n+  ssize_t increment;\n+  uint32_t n;\n+\n+  if ((type = ctf_type_resolve_unsliced (fp, type)) == CTF_ERR)\n+    return NULL;\t\t/* errno is set for us.  */\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return NULL;\t\t/* errno is set for us.  */\n+\n+  if (LCTF_INFO_KIND (fp, tp->ctt_info) != CTF_K_ENUM)\n+    {\n+      (void) ctf_set_errno (ofp, ECTF_NOTENUM);\n+      return NULL;\n+    }\n+\n+  (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n+\n+  ep = (const ctf_enum_t *) ((uintptr_t) tp + increment);\n+\n+  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n+    {\n+      if (ep->cte_value == value)\n+\treturn (ctf_strptr (fp, ep->cte_name));\n+    }\n+\n+  (void) ctf_set_errno (ofp, ECTF_NOENUMNAM);\n+  return NULL;\n+}\n+\n+/* Convert the specified enum tag name to the corresponding value, if a\n+   matching name can be found.  Otherwise CTF_ERR is returned.  */\n+\n+int\n+ctf_enum_value (ctf_file_t * fp, ctf_id_t type, const char *name, int *valp)\n+{\n+  ctf_file_t *ofp = fp;\n+  const ctf_type_t *tp;\n+  const ctf_enum_t *ep;\n+  ssize_t increment;\n+  uint32_t n;\n+\n+  if ((type = ctf_type_resolve_unsliced (fp, type)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if (LCTF_INFO_KIND (fp, tp->ctt_info) != CTF_K_ENUM)\n+    {\n+      (void) ctf_set_errno (ofp, ECTF_NOTENUM);\n+      return CTF_ERR;\n+    }\n+\n+  (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n+\n+  ep = (const ctf_enum_t *) ((uintptr_t) tp + increment);\n+\n+  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n+    {\n+      if (strcmp (ctf_strptr (fp, ep->cte_name), name) == 0)\n+\t{\n+\t  if (valp != NULL)\n+\t    *valp = ep->cte_value;\n+\t  return 0;\n+\t}\n+    }\n+\n+  (void) ctf_set_errno (ofp, ECTF_NOENUMNAM);\n+  return CTF_ERR;\n+}\n+\n+/* Recursively visit the members of any type.  This function is used as the\n+   engine for ctf_type_visit, below.  We resolve the input type, recursively\n+   invoke ourself for each type member if the type is a struct or union, and\n+   then invoke the callback function on the current type.  If any callback\n+   returns non-zero, we abort and percolate the error code back up to the top.  */\n+\n+static int\n+ctf_type_rvisit (ctf_file_t *fp, ctf_id_t type, ctf_visit_f *func,\n+\t\t void *arg, const char *name, unsigned long offset, int depth)\n+{\n+  ctf_id_t otype = type;\n+  const ctf_type_t *tp;\n+  ssize_t size, increment;\n+  uint32_t kind, n;\n+  int rc;\n+\n+  if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((rc = func (name, otype, offset, depth, arg)) != 0)\n+    return rc;\n+\n+  kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n+\n+  if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n+    return 0;\n+\n+  (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n+\n+  if (size < CTF_LSTRUCT_THRESH)\n+    {\n+      const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t       increment);\n+\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+\t{\n+\t  if ((rc = ctf_type_rvisit (fp, mp->ctm_type,\n+\t\t\t\t     func, arg, ctf_strptr (fp, mp->ctm_name),\n+\t\t\t\t     offset + mp->ctm_offset,\n+\t\t\t\t     depth + 1)) != 0)\n+\t    return rc;\n+\t}\n+\n+    }\n+  else\n+    {\n+      const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t  increment);\n+\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+\t{\n+\t  if ((rc = ctf_type_rvisit (fp, lmp->ctlm_type,\n+\t\t\t\t     func, arg, ctf_strptr (fp,\n+\t\t\t\t\t\t\t    lmp->ctlm_name),\n+\t\t\t\t     offset + (unsigned long) CTF_LMEM_OFFSET (lmp),\n+\t\t\t\t     depth + 1)) != 0)\n+\t    return rc;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Recursively visit the members of any type.  We pass the name, member\n+ type, and offset of each member to the specified callback function.  */\n+int\n+ctf_type_visit (ctf_file_t *fp, ctf_id_t type, ctf_visit_f *func, void *arg)\n+{\n+  return (ctf_type_rvisit (fp, type, func, arg, \"\", 0, 0));\n+}"
    }
  ]
}