{
  "sha": "d851ecd373a3764581372b10be5b74c9ee98ae08",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDg1MWVjZDM3M2EzNzY0NTgxMzcyYjEwYmU1Yjc0YzllZTk4YWUwOA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-07-13T19:33:01Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-10-03T16:04:55Z"
    },
    "message": "libctf: support getting strings from the ELF strtab\n\nThe CTF file format has always supported \"external strtabs\", which\ninternally are strtab offsets with their MSB on: such refs\nget their strings from the strtab passed in at CTF file open time:\nthis is usually intended to be the ELF strtab, and that's what this\nimplementation is meant to support, though in theory the external\nstrtab could come from anywhere.\n\nThis commit adds support for these external strings in the ctf-string.c\nstrtab tracking layer.  It's quite easy: we just add a field csa_offset\nto the atoms table that tracks all strings: this field tracks the offset\nof the string in the ELF strtab (with its MSB already on, courtesy of a\nnew macro CTF_SET_STID), and adds a new function that sets the\ncsa_offset to the specified offset (plus MSB).  Then we just need to\navoid writing out strings to the internal strtab if they have csa_offset\nset, and note that the internal strtab is shorter than it might\notherwise be.\n\n(We could in theory save a little more time here by eschewing sorting\nsuch strings, since we never actually write the strings out anywhere,\nbut that would mean storing them separately and it's just not worth the\ncomplexity cost until profiling shows it's worth doing.)\n\nWe also have to go through a bit of extra effort at variable-sorting\ntime.  This was previously using direct references to the internal\nstrtab: it couldn't use ctf_strptr or ctf_strraw because the new strtab\nis not yet ready to put in its usual field (in a ctf_file_t that hasn't\neven been allocated yet at this stage): but now we're using the external\nstrtab, this will no longer do because it'll be looking things up in the\nwrong strtab, with disastrous results.  Instead, pass the new internal\nstrtab in to a new ctf_strraw_explicit function which is just like\nctf_strraw except you can specify a ne winternal strtab to use.\n\nBut even now that it is using a new internal strtab, this is not quite\nenough: it can't look up strings in the external strtab because ld\nhasn't written it out yet, and when it does will write it straight to\ndisk.  Instead, when we write the internal strtab, note all the offset\n-> string mappings that we have noted belong in the *external* strtab to\na new \"synthetic external strtab\" dynhash, ctf_syn_ext_strtab, and look\nin there at ctf_strraw time if it is set.  This uses minimal extra\nmemory (because only strings in the external strtab that we actually use\nare stored, and even those come straight out of the atoms table), but\nlet both variable sorting and name interning when ctf_bufopen is next\ncalled work fine.  (This also means that we don't need to filter out\nspurious ECTF_STRTAB warnings from ctf_bufopen but can pass them back to\nthe caller, once we wrap ctf_bufopen so that we have a new internal\nvariant of ctf_bufopen etc that we can pass the synthetic external\nstrtab to. That error has been filtered out since the days of Solaris\nlibctf, which didn't try to handle the problem of getting external\nstrtabs right at construction time at all.)\n\nv3: add the synthetic strtab and all associated machinery.\nv5: fix tabdamage.\n\ninclude/\n\t* ctf.h (CTF_SET_STID): New.\n\nlibctf/\n\t* ctf-impl.h (ctf_str_atom_t) <csa_offset>: New field.\n\t(ctf_file_t) <ctf_syn_ext_strtab>: Likewise.\n\t(ctf_str_add_ref): Name the last arg.\n\t(ctf_str_add_external) New.\n\t(ctf_str_add_strraw_explicit): Likewise.\n\t(ctf_simple_open_internal): Likewise.\n\t(ctf_bufopen_internal): Likewise.\n\n\t* ctf-string.c (ctf_strraw_explicit): Split from...\n\t(ctf_strraw): ... here, with new support for ctf_syn_ext_strtab.\n\t(ctf_str_add_ref_internal): Return the atom, not the\n\tstring.\n\t(ctf_str_add): Adjust accordingly.\n\t(ctf_str_add_ref): Likewise.  Move up in the file.\n\t(ctf_str_add_external): New: update the csa_offset.\n\t(ctf_str_count_strtab): Only account for strings with no csa_offset\n\tin the internal strtab length.\n\t(ctf_str_write_strtab): If the csa_offset is set, update the\n\tstring's refs without writing the string out, and update the\n\tctf_syn_ext_strtab.  Make OOM handling less ugly.\n\t* ctf-create.c (struct ctf_sort_var_arg_cb): New.\n\t(ctf_update): Handle failure to populate the strtab.  Pass in the\n\tnew ctf_sort_var arg.  Adjust for ctf_syn_ext_strtab addition.\n\tCall ctf_simple_open_internal, not ctf_simple_open.\n\t(ctf_sort_var): Call ctf_strraw_explicit rather than looking up\n\tstrings by hand.\n\t* ctf-hash.c (ctf_hash_insert_type): Likewise (but using\n\tctf_strraw).  Adjust to diagnose ECTF_STRTAB nonetheless.\n\t* ctf-open.c (init_types): No longer filter out ECTF_STRTAB.\n\t(ctf_file_close): Destroy the ctf_syn_ext_strtab.\n\t(ctf_simple_open): Rename to, and reimplement as a wrapper around...\n\t(ctf_simple_open_internal): ... this new function, which calls\n\tctf_bufopen_internal.\n\t(ctf_bufopen): Rename to, and reimplement as a wrapper around...\n\t(ctf_bufopen_internal): ... this new function, which sets\n\tctf_syn_ext_strtab.",
    "tree": {
      "sha": "e68101d7e8a629d55125daeae76f113c4d63c835",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e68101d7e8a629d55125daeae76f113c4d63c835"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d851ecd373a3764581372b10be5b74c9ee98ae08",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d851ecd373a3764581372b10be5b74c9ee98ae08",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d851ecd373a3764581372b10be5b74c9ee98ae08",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d851ecd373a3764581372b10be5b74c9ee98ae08/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0ac6231298cbc5a3a16bd4e98d85d98700b81dee",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0ac6231298cbc5a3a16bd4e98d85d98700b81dee",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0ac6231298cbc5a3a16bd4e98d85d98700b81dee"
    }
  ],
  "stats": {
    "total": 336,
    "additions": 266,
    "deletions": 70
  },
  "files": [
    {
      "sha": "96f1a557993443a5c4ea3d0a288d0e4c6f449e16",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d851ecd373a3764581372b10be5b74c9ee98ae08/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d851ecd373a3764581372b10be5b74c9ee98ae08/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=d851ecd373a3764581372b10be5b74c9ee98ae08",
      "patch": "@@ -1,3 +1,7 @@\n+2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf.h (CTF_SET_STID): New.\n+\n 2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_type_all_f): New."
    },
    {
      "sha": "ff3204b9aa2e1c91ea44f4e4209f5973bde91251",
      "filename": "include/ctf.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d851ecd373a3764581372b10be5b74c9ee98ae08/include/ctf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d851ecd373a3764581372b10be5b74c9ee98ae08/include/ctf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf.h?ref=d851ecd373a3764581372b10be5b74c9ee98ae08",
      "patch": "@@ -353,6 +353,7 @@ union\n \n #define CTF_NAME_STID(name)\t\t((name) >> 31)\n #define CTF_NAME_OFFSET(name)\t\t((name) & CTF_MAX_NAME)\n+#define CTF_SET_STID(name, stid)\t((name) | (stid) << 31)\n \n /* V2 only. */\n #define CTF_TYPE_INFO(kind, isroot, vlen) \\"
    },
    {
      "sha": "fbf765fdb61bbca9fffb21e5c8526468c41c0dde",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 39,
      "deletions": 0,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=d851ecd373a3764581372b10be5b74c9ee98ae08",
      "patch": "@@ -1,3 +1,42 @@\n+2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_str_atom_t) <csa_offset>: New field.\n+\t(ctf_file_t) <ctf_syn_ext_strtab>: Likewise.\n+\t(ctf_str_add_ref): Name the last arg.\n+\t(ctf_str_add_external) New.\n+\t(ctf_str_add_strraw_explicit): Likewise.\n+\t(ctf_simple_open_internal): Likewise.\n+\t(ctf_bufopen_internal): Likewise.\n+\n+\t* ctf-string.c (ctf_strraw_explicit): Split from...\n+\t(ctf_strraw): ... here, with new support for ctf_syn_ext_strtab.\n+\t(ctf_str_add_ref_internal): Return the atom, not the\n+\tstring.\n+\t(ctf_str_add): Adjust accordingly.\n+\t(ctf_str_add_ref): Likewise.  Move up in the file.\n+\t(ctf_str_add_external): New: update the csa_offset.\n+\t(ctf_str_count_strtab): Only account for strings with no csa_offset\n+\tin the internal strtab length.\n+\t(ctf_str_write_strtab): If the csa_offset is set, update the\n+\tstring's refs without writing the string out, and update the\n+\tctf_syn_ext_strtab.  Make OOM handling less ugly.\n+\t* ctf-create.c (struct ctf_sort_var_arg_cb): New.\n+\t(ctf_update): Handle failure to populate the strtab.  Pass in the\n+\tnew ctf_sort_var arg.  Adjust for ctf_syn_ext_strtab addition.\n+\tCall ctf_simple_open_internal, not ctf_simple_open.\n+\t(ctf_sort_var): Call ctf_strraw_explicit rather than looking up\n+\tstrings by hand.\n+\t* ctf-hash.c (ctf_hash_insert_type): Likewise (but using\n+\tctf_strraw).  Adjust to diagnose ECTF_STRTAB nonetheless.\n+\t* ctf-open.c (init_types): No longer filter out ECTF_STRTAB.\n+\t(ctf_file_close): Destroy the ctf_syn_ext_strtab.\n+\t(ctf_simple_open): Rename to, and reimplement as a wrapper around...\n+\t(ctf_simple_open_internal): ... this new function, which calls\n+\tctf_bufopen_internal.\n+\t(ctf_bufopen): Rename to, and reimplement as a wrapper around...\n+\t(ctf_bufopen_internal): ... this new function, which sets\n+\tctf_syn_ext_strtab.\n+\n 2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf_types.c (ctf_type_iter_all): New."
    },
    {
      "sha": "3e6a3197ff8149264c9f6c2c1bc303bfad4b526f",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 33,
      "deletions": 17,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=d851ecd373a3764581372b10be5b74c9ee98ae08",
      "patch": "@@ -170,31 +170,37 @@ ctf_copy_emembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n \n /* Sort a newly-constructed static variable array.  */\n \n+typedef struct ctf_sort_var_arg_cb\n+{\n+  ctf_file_t *fp;\n+  ctf_strs_t *strtab;\n+} ctf_sort_var_arg_cb_t;\n+\n static int\n-ctf_sort_var (const void *one_, const void *two_, void *strtab_)\n+ctf_sort_var (const void *one_, const void *two_, void *arg_)\n {\n   const ctf_varent_t *one = one_;\n   const ctf_varent_t *two = two_;\n-  const char *strtab = strtab_;\n-  const char *n1 = strtab + CTF_NAME_OFFSET (one->ctv_name);\n-  const char *n2 = strtab + CTF_NAME_OFFSET (two->ctv_name);\n+  ctf_sort_var_arg_cb_t *arg = arg_;\n \n-  return (strcmp (n1, n2));\n+  return (strcmp (ctf_strraw_explicit (arg->fp, one->ctv_name, arg->strtab),\n+\t\t  ctf_strraw_explicit (arg->fp, two->ctv_name, arg->strtab)));\n }\n \n /* If the specified CTF container is writable and has been modified, reload this\n    container with the updated type definitions.  In order to make this code and\n    the rest of libctf as simple as possible, we perform updates by taking the\n    dynamic type definitions and creating an in-memory CTF file containing the\n-   definitions, and then call ctf_simple_open() on it.  This not only leverages\n-   ctf_simple_open(), but also avoids having to bifurcate the rest of the library\n-   code with different lookup paths for static and dynamic type definitions.  We\n-   are therefore optimizing greatly for lookup over update, which we assume will\n-   be an uncommon operation.  We perform one extra trick here for the benefit of\n-   callers and to keep our code simple: ctf_simple_open() will return a new\n-   ctf_file_t, but we want to keep the fp constant for the caller, so after\n-   ctf_simple_open() returns, we use memcpy to swap the interior of the old and\n-   new ctf_file_t's, and then free the old.  */\n+   definitions, and then call ctf_simple_open_internal() on it.  This not only\n+   leverages ctf_simple_open(), but also avoids having to bifurcate the rest of\n+   the library code with different lookup paths for static and dynamic type\n+   definitions.  We are therefore optimizing greatly for lookup over update,\n+   which we assume will be an uncommon operation.  We perform one extra trick\n+   here for the benefit of callers and to keep our code simple:\n+   ctf_simple_open_internal() will return a new ctf_file_t, but we want to keep\n+   the fp constant for the caller, so after ctf_simple_open_internal() returns,\n+   we use memcpy to swap the interior of the old and new ctf_file_t's, and then\n+   free the old.  */\n int\n ctf_update (ctf_file_t *fp)\n {\n@@ -412,10 +418,17 @@ ctf_update (ctf_file_t *fp)\n   strtab = ctf_str_write_strtab (fp);\n   ctf_str_purge_refs (fp);\n \n+  if (strtab.cts_strs == NULL)\n+    {\n+      ctf_free (buf);\n+      return (ctf_set_errno (fp, EAGAIN));\n+    }\n+\n   /* Now the string table is constructed, we can sort the buffer of\n      ctf_varent_t's.  */\n+  ctf_sort_var_arg_cb_t sort_var_arg = { fp, (ctf_strs_t *) &strtab };\n   ctf_qsort_r (dvarents, nvars, sizeof (ctf_varent_t), ctf_sort_var,\n-\t       strtab.cts_strs);\n+\t       &sort_var_arg);\n \n   if ((newbuf = ctf_realloc (fp, buf, buf_size + strtab.cts_len)) == NULL)\n     {\n@@ -433,8 +446,9 @@ ctf_update (ctf_file_t *fp)\n   /* Finally, we are ready to ctf_simple_open() the new container.  If this\n      is successful, we then switch nfp and fp and free the old container.  */\n \n-  if ((nfp = ctf_simple_open ((char *) buf, buf_size, NULL, 0, 0, NULL,\n-\t\t\t      0, &err)) == NULL)\n+  if ((nfp = ctf_simple_open_internal ((char *) buf, buf_size, NULL, 0,\n+\t\t\t\t       0, NULL, 0, fp->ctf_syn_ext_strtab,\n+\t\t\t\t       &err)) == NULL)\n     {\n       ctf_free (buf);\n       return (ctf_set_errno (fp, err));\n@@ -456,6 +470,7 @@ ctf_update (ctf_file_t *fp)\n   nfp->ctf_dtoldid = fp->ctf_dtnextid - 1;\n   nfp->ctf_snapshots = fp->ctf_snapshots + 1;\n   nfp->ctf_specific = fp->ctf_specific;\n+  nfp->ctf_syn_ext_strtab = fp->ctf_syn_ext_strtab;\n \n   nfp->ctf_snapshot_lu = fp->ctf_snapshots;\n \n@@ -465,6 +480,7 @@ ctf_update (ctf_file_t *fp)\n   nfp->ctf_str_atoms = fp->ctf_str_atoms;\n   fp->ctf_str_atoms = NULL;\n   memset (&fp->ctf_dtdefs, 0, sizeof (ctf_list_t));\n+  fp->ctf_syn_ext_strtab = NULL;\n \n   fp->ctf_dvhash = NULL;\n   memset (&fp->ctf_dvdefs, 0, sizeof (ctf_list_t));"
    },
    {
      "sha": "3512d22a3476ce42de4752cd7e35a123b86c4fc3",
      "filename": "libctf/ctf-hash.c",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=d851ecd373a3764581372b10be5b74c9ee98ae08",
      "patch": "@@ -271,16 +271,18 @@ int\n ctf_hash_insert_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n \t\t      uint32_t name)\n {\n-  ctf_strs_t *ctsp = &fp->ctf_str[CTF_NAME_STID (name)];\n-  const char *str = ctsp->cts_strs + CTF_NAME_OFFSET (name);\n+  const char *str = ctf_strraw (fp, name);\n \n   if (type == 0)\n     return EINVAL;\n \n-  if (ctsp->cts_strs == NULL)\n+  if (str == NULL\n+      && CTF_NAME_STID (name) == CTF_STRTAB_1\n+      && fp->ctf_syn_ext_strtab == NULL\n+      && fp->ctf_str[CTF_NAME_STID (name)].cts_strs == NULL)\n     return ECTF_STRTAB;\n \n-  if (ctsp->cts_len <= CTF_NAME_OFFSET (name))\n+  if (str == NULL)\n     return ECTF_BADNAME;\n \n   if (str[0] == '\\0')"
    },
    {
      "sha": "03c48cf8a097031ea7d38176c79daef5efa430d7",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 15,
      "deletions": 2,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=d851ecd373a3764581372b10be5b74c9ee98ae08",
      "patch": "@@ -192,6 +192,7 @@ typedef struct ctf_str_atom\n {\n   const char *csa_str;\t\t/* Backpointer to string (hash key).  */\n   ctf_list_t csa_refs;\t\t/* This string's refs.  */\n+  uint32_t csa_offset;\t\t/* External strtab offset, if any.  */\n   unsigned long csa_snapshot_id; /* Snapshot ID at time of creation.  */\n } ctf_str_atom_t;\n \n@@ -222,6 +223,7 @@ struct ctf_file\n   ctf_sect_t ctf_data;\t\t    /* CTF data from object file.  */\n   ctf_sect_t ctf_symtab;\t    /* Symbol table from object file.  */\n   ctf_sect_t ctf_strtab;\t    /* String table from object file.  */\n+  ctf_dynhash_t *ctf_syn_ext_strtab; /* Maps ext-strtab offsets to names.  */\n   void *ctf_data_mmapped;\t    /* CTF data we mmapped, to free later.  */\n   size_t ctf_data_mmapped_len;\t    /* Length of CTF data we mmapped.  */\n   ctf_hash_t *ctf_structs;\t    /* Hash table of struct types.  */\n@@ -375,12 +377,15 @@ _libctf_printflike_ (2, 3)\n extern void ctf_decl_sprintf (ctf_decl_t *, const char *, ...);\n extern char *ctf_decl_buf (ctf_decl_t *cd);\n \n-extern const char *ctf_strraw (ctf_file_t *, uint32_t);\n extern const char *ctf_strptr (ctf_file_t *, uint32_t);\n+extern const char *ctf_strraw (ctf_file_t *, uint32_t);\n+extern const char *ctf_strraw_explicit (ctf_file_t *, uint32_t,\n+\t\t\t\t\tctf_strs_t *);\n extern int ctf_str_create_atoms (ctf_file_t *);\n extern void ctf_str_free_atoms (ctf_file_t *);\n extern const char *ctf_str_add (ctf_file_t *, const char *);\n-extern const char *ctf_str_add_ref (ctf_file_t *, const char *, uint32_t *);\n+extern const char *ctf_str_add_ref (ctf_file_t *, const char *, uint32_t *ref);\n+extern const char *ctf_str_add_external (ctf_file_t *, const char *, uint32_t offset);\n extern void ctf_str_rollback (ctf_file_t *, ctf_snapshot_id_t);\n extern void ctf_str_purge_refs (ctf_file_t *);\n extern ctf_strs_writable_t ctf_str_write_strtab (ctf_file_t *);\n@@ -391,6 +396,14 @@ extern void ctf_arc_close_internal (struct ctf_archive *);\n extern void *ctf_set_open_errno (int *, int);\n extern unsigned long ctf_set_errno (ctf_file_t *, int);\n \n+extern ctf_file_t *ctf_simple_open_internal (const char *, size_t, const char *,\n+\t\t\t\t\t     size_t, size_t,\n+\t\t\t\t\t     const char *, size_t,\n+\t\t\t\t\t     ctf_dynhash_t *, int *);\n+extern ctf_file_t *ctf_bufopen_internal (const ctf_sect_t *, const ctf_sect_t *,\n+\t\t\t\t\t const ctf_sect_t *, ctf_dynhash_t *,\n+\t\t\t\t\t int *);\n+\n _libctf_malloc_\n extern void *ctf_mmap (size_t length, size_t offset, int fd);\n extern void ctf_munmap (void *, size_t);"
    },
    {
      "sha": "f4179cb78e1b38f75f6ca8dd3aaafb3030c12882",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 39,
      "deletions": 11,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=d851ecd373a3764581372b10be5b74c9ee98ae08",
      "patch": "@@ -785,7 +785,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t      err = ctf_hash_define_type (fp->ctf_names, fp,\n \t\t\t\t\t  LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t\t  tp->ctt_name);\n-\t      if (err != 0 && err != ECTF_STRTAB)\n+\t      if (err != 0)\n \t\treturn err;\n \t    }\n \t  break;\n@@ -800,7 +800,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n-\t  if (err != 0 && err != ECTF_STRTAB)\n+\t  if (err != 0)\n \t    return err;\n \t  break;\n \n@@ -809,7 +809,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \n-\t  if (err != 0 && err != ECTF_STRTAB)\n+\t  if (err != 0)\n \t    return err;\n \n \t  if (size >= CTF_LSTRUCT_THRESH)\n@@ -821,7 +821,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \n-\t  if (err != 0 && err != ECTF_STRTAB)\n+\t  if (err != 0)\n \t    return err;\n \n \t  if (size >= CTF_LSTRUCT_THRESH)\n@@ -833,15 +833,15 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \n-\t  if (err != 0 && err != ECTF_STRTAB)\n+\t  if (err != 0)\n \t    return err;\n \t  break;\n \n \tcase CTF_K_TYPEDEF:\n \t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n-\t  if (err != 0 && err != ECTF_STRTAB)\n+\t  if (err != 0)\n \t    return err;\n \t  break;\n \n@@ -868,7 +868,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t      err = ctf_hash_insert_type (hp, fp,\n \t\t\t\t\t  LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t\t  tp->ctt_name);\n-\t      if (err != 0 && err != ECTF_STRTAB)\n+\t      if (err != 0)\n \t\treturn err;\n \t    }\n \t  break;\n@@ -889,7 +889,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n-\t  if (err != 0 && err != ECTF_STRTAB)\n+\t  if (err != 0)\n \t    return err;\n \t  break;\n \tdefault:\n@@ -1191,11 +1191,26 @@ flip_ctf (ctf_header_t *cth, unsigned char *buf)\n }\n \n /* Open a CTF file, mocking up a suitable ctf_sect.  */\n+\n ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n \t\t\t     const char *symsect, size_t symsect_size,\n \t\t\t     size_t symsect_entsize,\n \t\t\t     const char *strsect, size_t strsect_size,\n \t\t\t     int *errp)\n+{\n+  return ctf_simple_open_internal (ctfsect, ctfsect_size, symsect, symsect_size,\n+\t\t\t\t   symsect_entsize, strsect, strsect_size, NULL,\n+\t\t\t\t   errp);\n+}\n+\n+/* Open a CTF file, mocking up a suitable ctf_sect and overriding the external\n+   strtab with a synthetic one.  */\n+\n+ctf_file_t *ctf_simple_open_internal (const char *ctfsect, size_t ctfsect_size,\n+\t\t\t\t      const char *symsect, size_t symsect_size,\n+\t\t\t\t      size_t symsect_entsize,\n+\t\t\t\t      const char *strsect, size_t strsect_size,\n+\t\t\t\t      ctf_dynhash_t *syn_strtab, int *errp)\n {\n   ctf_sect_t skeleton;\n \n@@ -1232,7 +1247,7 @@ ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n       strsectp = &str_sect;\n     }\n \n-  return ctf_bufopen (ctfsectp, symsectp, strsectp, errp);\n+  return ctf_bufopen_internal (ctfsectp, symsectp, strsectp, syn_strtab, errp);\n }\n \n /* Decode the specified CTF buffer and optional symbol table, and create a new\n@@ -1243,6 +1258,16 @@ ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n ctf_file_t *\n ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t     const ctf_sect_t *strsect, int *errp)\n+{\n+  return ctf_bufopen_internal (ctfsect, symsect, strsect, NULL, errp);\n+}\n+\n+/* Like ctf_bufopen, but overriding the external strtab with a synthetic one.  */\n+\n+ctf_file_t *\n+ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n+\t\t      const ctf_sect_t *strsect, ctf_dynhash_t *syn_strtab,\n+\t\t      int *errp)\n {\n   const ctf_preamble_t *pp;\n   size_t hdrsz = sizeof (ctf_header_t);\n@@ -1253,7 +1278,8 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n   libctf_init_debug();\n \n-  if ((ctfsect == NULL) || ((symsect != NULL) && (strsect == NULL)))\n+  if ((ctfsect == NULL) || ((symsect != NULL) &&\n+\t\t\t    ((strsect == NULL) && syn_strtab == NULL)))\n     return (ctf_set_open_errno (errp, EINVAL));\n \n   if (symsect != NULL && symsect->cts_entsize != sizeof (Elf32_Sym) &&\n@@ -1466,6 +1492,7 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n       fp->ctf_str[CTF_STRTAB_1].cts_strs = strsect->cts_data;\n       fp->ctf_str[CTF_STRTAB_1].cts_len = strsect->cts_size;\n     }\n+  fp->ctf_syn_ext_strtab = syn_strtab;\n \n   if (foreign_endian &&\n       (err = flip_ctf (hp, fp->ctf_buf)) != 0)\n@@ -1592,12 +1619,13 @@ ctf_file_close (ctf_file_t *fp)\n \n   if (fp->ctf_strtab.cts_name != _CTF_NULLSTR)\n     ctf_free ((char *) fp->ctf_strtab.cts_name);\n-\n   else if (fp->ctf_data_mmapped)\n     ctf_munmap (fp->ctf_data_mmapped, fp->ctf_data_mmapped_len);\n \n   ctf_free (fp->ctf_dynbase);\n \n+  ctf_dynhash_destroy (fp->ctf_syn_ext_strtab);\n+\n   ctf_free (fp->ctf_sxlate);\n   ctf_free (fp->ctf_txlate);\n   ctf_free (fp->ctf_ptrtab);"
    },
    {
      "sha": "44cd4477331d060a0d25e646ee1496f292687e53",
      "filename": "libctf/ctf-string.c",
      "status": "modified",
      "additions": 129,
      "deletions": 36,
      "changes": 165,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d851ecd373a3764581372b10be5b74c9ee98ae08/libctf/ctf-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-string.c?ref=d851ecd373a3764581372b10be5b74c9ee98ae08",
      "patch": "@@ -20,20 +20,39 @@\n #include <ctf-impl.h>\n #include <string.h>\n \n-/* Convert an encoded CTF string name into a pointer to a C string by looking\n-  up the appropriate string table buffer and then adding the offset.  */\n+/* Convert an encoded CTF string name into a pointer to a C string, using an\n+  explicit internal strtab rather than the fp-based one.  */\n const char *\n-ctf_strraw (ctf_file_t *fp, uint32_t name)\n+ctf_strraw_explicit (ctf_file_t *fp, uint32_t name, ctf_strs_t *strtab)\n {\n   ctf_strs_t *ctsp = &fp->ctf_str[CTF_NAME_STID (name)];\n \n+  if ((CTF_NAME_STID (name) == CTF_STRTAB_0) && (strtab != NULL))\n+    ctsp = strtab;\n+\n+  /* If this name is in the external strtab, and there is a synthetic strtab,\n+     use it in preference.  */\n+\n+  if (CTF_NAME_STID (name) == CTF_STRTAB_1\n+      && fp->ctf_syn_ext_strtab != NULL)\n+    return ctf_dynhash_lookup (fp->ctf_syn_ext_strtab,\n+\t\t\t       (void *) (uintptr_t) name);\n+\n   if (ctsp->cts_strs != NULL && CTF_NAME_OFFSET (name) < ctsp->cts_len)\n     return (ctsp->cts_strs + CTF_NAME_OFFSET (name));\n \n   /* String table not loaded or corrupt offset.  */\n   return NULL;\n }\n \n+/* Convert an encoded CTF string name into a pointer to a C string by looking\n+  up the appropriate string table buffer and then adding the offset.  */\n+const char *\n+ctf_strraw (ctf_file_t *fp, uint32_t name)\n+{\n+  return ctf_strraw_explicit (fp, name, NULL);\n+}\n+\n /* Return a guaranteed-non-NULL pointer to the string with the given CTF\n    name.  */\n const char *\n@@ -88,11 +107,11 @@ ctf_str_free_atoms (ctf_file_t *fp)\n   ctf_dynhash_destroy (fp->ctf_str_atoms);\n }\n \n-/* Add a string to the atoms table and return it, or return an existing string\n-   if present, copying the passed-in string.  Returns NULL only when out of\n-   memory (and do not touch the passed-in string in that case).  Possibly\n-   augment the ref list with the passed-in ref.  */\n-static const char *\n+/* Add a string to the atoms table, copying the passed-in string.  Return the\n+   atom added. Return NULL only when out of memory (and do not touch the\n+   passed-in string in that case).  Possibly augment the ref list with the\n+   passed-in ref.  */\n+static ctf_str_atom_t *\n ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n \t\t\t  int add_ref, uint32_t *ref)\n {\n@@ -116,7 +135,7 @@ ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n \t  ctf_list_append (&atom->csa_refs, aref);\n \t  fp->ctf_str_num_refs++;\n \t}\n-      return atom->csa_str;\n+      return atom;\n     }\n \n   if ((atom = ctf_alloc (sizeof (struct ctf_str_atom))) == NULL)\n@@ -136,7 +155,7 @@ ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n       ctf_list_append (&atom->csa_refs, aref);\n       fp->ctf_str_num_refs++;\n     }\n-  return newstr;\n+  return atom;\n \n  oom:\n   ctf_free (atom);\n@@ -150,9 +169,48 @@ ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n const char *\n ctf_str_add (ctf_file_t *fp, const char *str)\n {\n-  if (str)\n-    return ctf_str_add_ref_internal (fp, str, FALSE, 0);\n-  return NULL;\n+  ctf_str_atom_t *atom;\n+  if (!str)\n+    return NULL;\n+\n+  atom = ctf_str_add_ref_internal (fp, str, FALSE, 0);\n+  if (!atom)\n+    return NULL;\n+\n+  return atom->csa_str;\n+}\n+\n+/* Like ctf_str_add(), but additionally augment the atom's refs list with the\n+   passed-in ref, whether or not the string is already present.  There is no\n+   attempt to deduplicate the refs list (but duplicates are harmless).  */\n+const char *\n+ctf_str_add_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n+{\n+  ctf_str_atom_t *atom;\n+  if (!str)\n+    return NULL;\n+\n+  atom = ctf_str_add_ref_internal (fp, str, TRUE, ref);\n+  if (!atom)\n+    return NULL;\n+\n+  return atom->csa_str;\n+}\n+\n+/* Add an external strtab reference at OFFSET.  */\n+const char *\n+ctf_str_add_external (ctf_file_t *fp, const char *str, uint32_t offset)\n+{\n+  ctf_str_atom_t *atom;\n+  if (!str)\n+    return NULL;\n+\n+  atom = ctf_str_add_ref_internal (fp, str, FALSE, 0);\n+  if (!atom)\n+    return NULL;\n+\n+  atom->csa_offset = CTF_SET_STID (offset, CTF_STRTAB_1);\n+  return atom->csa_str;\n }\n \n /* A ctf_dynhash_iter_remove() callback that removes atoms later than a given\n@@ -173,17 +231,6 @@ ctf_str_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n   ctf_dynhash_iter_remove (fp->ctf_str_atoms, ctf_str_rollback_atom, &id);\n }\n \n-/* Like ctf_str_add(), but additionally augment the atom's refs list with the\n-   passed-in ref, whether or not the string is already present.  There is no\n-   attempt to deduplicate the refs list (but duplicates are harmless).  */\n-const char *\n-ctf_str_add_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n-{\n-  if (str)\n-    return ctf_str_add_ref_internal (fp, str, TRUE, ref);\n-  return NULL;\n-}\n-\n /* An adaptor around ctf_purge_atom_refs.  */\n static void\n ctf_str_purge_one_atom_refs (void *key _libctf_unused_, void *value,\n@@ -238,7 +285,11 @@ ctf_str_count_strtab (void *key _libctf_unused_, void *value,\n   ctf_str_atom_t *atom = (ctf_str_atom_t *) value;\n   ctf_strtab_write_state_t *s = (ctf_strtab_write_state_t *) arg;\n \n-  s->strtab->cts_len += strlen (atom->csa_str) + 1;\n+  /* We only factor in the length of items that have no offset:\n+     other items are in the external strtab.  They still contribute to the\n+     total count, though, because we still have to sort them.  */\n+  if (!atom->csa_offset)\n+    s->strtab->cts_len += strlen (atom->csa_str) + 1;\n   s->strtab_count++;\n }\n \n@@ -268,8 +319,10 @@ ctf_str_sort_strtab (const void *a, const void *b)\n }\n \n /* Write out and return a strtab containing all strings with recorded refs,\n-   adjusting the refs to refer to the corresponding string.  The returned\n-   strtab may be NULL on error.  */\n+   adjusting the refs to refer to the corresponding string.  The returned strtab\n+   may be NULL on error.  Also populate the synthetic strtab with mappings from\n+   external strtab offsets to names, so we can look them up with ctf_strptr().\n+   Only external strtab offsets with references are added.  */\n ctf_strs_writable_t\n ctf_str_write_strtab (ctf_file_t *fp)\n {\n@@ -279,6 +332,7 @@ ctf_str_write_strtab (ctf_file_t *fp)\n   ctf_strtab_write_state_t s;\n   ctf_str_atom_t **sorttab;\n   size_t i;\n+  int any_external = 0;\n \n   memset (&strtab, 0, sizeof (struct ctf_strs_writable));\n   memset (&s, 0, sizeof (struct ctf_strtab_write_state));\n@@ -300,7 +354,7 @@ ctf_str_write_strtab (ctf_file_t *fp)\n   /* Sort the strtab.  Force the null string to be first.  */\n   sorttab = calloc (s.strtab_count, sizeof (ctf_str_atom_t *));\n   if (!sorttab)\n-      return strtab;\n+    goto oom;\n \n   sorttab[0] = nullstr;\n   s.i = 1;\n@@ -312,19 +366,58 @@ ctf_str_write_strtab (ctf_file_t *fp)\n \t ctf_str_sort_strtab);\n \n   if ((strtab.cts_strs = ctf_alloc (strtab.cts_len)) == NULL)\n-    {\n-      free (sorttab);\n-      return strtab;\n-    }\n+    goto oom_sorttab;\n+\n+  if (!fp->ctf_syn_ext_strtab)\n+    fp->ctf_syn_ext_strtab = ctf_dynhash_create (ctf_hash_integer,\n+\t\t\t\t\t\t ctf_hash_eq_integer,\n+\t\t\t\t\t\t NULL, NULL);\n+  if (!fp->ctf_syn_ext_strtab)\n+    goto oom_strtab;\n \n-  /* Update the strtab, and all refs.  */\n+  /* Update all refs: also update the strtab appropriately.  */\n   for (i = 0; i < s.strtab_count; i++)\n     {\n-      strcpy (&strtab.cts_strs[cur_stroff], sorttab[i]->csa_str);\n-      ctf_str_update_refs (sorttab[i], cur_stroff);\n-      cur_stroff += strlen (sorttab[i]->csa_str) + 1;\n+      if (sorttab[i]->csa_offset)\n+\t{\n+\t  /* External strtab entry: populate the synthetic external strtab.\n+\n+\t     This is safe because you cannot ctf_rollback to before the point\n+\t     when a ctf_update is done, and the strtab is written at ctf_update\n+\t     time.  So any atoms we reference here are sure to stick around\n+\t     until ctf_file_close.  */\n+\n+\t  any_external = 1;\n+\t  ctf_str_update_refs (sorttab[i], sorttab[i]->csa_offset);\n+\t  if (ctf_dynhash_insert (fp->ctf_syn_ext_strtab,\n+\t\t\t\t  (void *) (uintptr_t) sorttab[i]->csa_offset,\n+\t\t\t\t  (void *) sorttab[i]->csa_str) < 0)\n+\t    goto oom_strtab;\n+\t}\n+      else\n+\t{\n+\t  /* Internal strtab entry: actually add to the string table.  */\n+\n+\t  ctf_str_update_refs (sorttab[i], cur_stroff);\n+\t  strcpy (&strtab.cts_strs[cur_stroff], sorttab[i]->csa_str);\n+\t  cur_stroff += strlen (sorttab[i]->csa_str) + 1;\n+\t}\n     }\n   free (sorttab);\n \n+  if (!any_external)\n+    {\n+      ctf_dynhash_destroy (fp->ctf_syn_ext_strtab);\n+      fp->ctf_syn_ext_strtab = NULL;\n+    }\n+\n+  return strtab;\n+\n+ oom_strtab:\n+  free (strtab.cts_strs);\n+  strtab.cts_strs = NULL;\n+ oom_sorttab:\n+  free (sorttab);\n+ oom:\n   return strtab;\n }"
    }
  ]
}